00:06:56 <rwbarton> "It's like an XML version of C"
00:08:09 <BeelsebobWork> oh dear god
00:08:18 <BeelsebobWork> what an awful sentence to join #haskell to
00:08:29 <humasect> holymoses
00:09:36 <dons> rwbarton: its crazy whack
00:09:50 <rwbarton> :)
00:27:02 <kowey> does the filepath package work with GHC 6.4? anybody remember or know?
00:32:29 <thoughtpolice> kowey: according to ndm's page it was originally from yhc and then went into the standard libs as of 6.6 - i think it does but you would either have to try or ask ndm yourself
00:32:47 <kowey> thoughtpolice: thanks
00:44:09 <osfameron> so ((->) t) is the type signature for "functions" ?
00:44:12 <osfameron> or Functor ?
00:45:33 <dibblego> it's a type constructor of kind * -> *
00:45:42 <RayNbow> ((->) a) b == (a -> b)  is a function type
00:46:08 <dibblego> (->) * -> * -> *
00:46:10 <thoughtpolice> dons: ouch on the ion-wm thing; xmonad handles the xinerama stuff all perfectly I assume (never used two monitors)?
00:46:13 <dibblego> ((->) a) * -> *
00:46:18 <dibblego> ((->) a) b *
00:46:32 <RayNbow> (why doesn't Haskell allow us to type (t ->)...)
00:49:32 <osfameron> why is it declared with a different syntax from the (a -> b) you'd normally get in type signatures?
00:51:11 <RayNbow> osfameron: are you referring to the kinds dibblego talked about?
00:51:26 <osfameron> yes, I think so
00:51:34 <dibblego> osfameron, because it's a type constructor, not a type signature
00:51:47 <dibblego> osfameron, consider the kind of [] : * -> *
00:51:57 <dibblego> it takes one more type argument before giving rise to a type
00:51:59 <osfameron> and specifically to the "20 intermediate haskell exercises": instance Fluffy ((->) t)
00:52:31 <dibblego> osfameron, that is the Functor instance for the type constructor that is (forall t. t -> ...)
00:52:53 <dibblego> consider also the kind of the type constructor: Either : * -> * -> *
00:53:04 <dibblego> agree? it takes two more type arguments before giving rise to a type
00:53:19 <Twey> It's a sort of... type lambda
00:53:29 <osfameron> why doesn't functor take 2 arguments (a and b) ?
00:53:43 <dibblego> do you agree with the kind of Either?
00:53:51 <RayNbow> osfameron
00:53:55 <RayNbow> type Function = (->)
00:54:58 <quicksilver> osfameron: I think you're confusing function and functor?
00:54:59 <osfameron> dibblego: er, actually I'm not that familiar with Either -> it has a left and a right, not sure what the 3rd star is, and why it only needs 2 arguments before giving the type
00:55:13 <quicksilver> osfameron: function - or (->) - does indeed take two arguments
00:55:17 <quicksilver> (->) a b
00:55:24 <quicksilver> also written "a -> b"
00:55:40 <RayNbow> or maybe better.... type Function a b = a -> b
00:55:42 <quicksilver> if you choose to give it only one argument, then it's not finished yet.
00:55:48 <quicksilver> it's partially applied.
00:55:48 <dibblego> (->) is a Bifunctor, but forall t. ((->) t) is a functor
00:56:08 <dibblego> the kind of the type constructor that is passed to Functor *must* be * -> *
00:56:14 <dibblego> therefore, (->) would produce an error
00:56:54 <quicksilver> [(->) is, in fact, not a Bifunctor. At least not in the ordinary sense. But I"m not sure that comment moves us forwards here]
00:57:01 <osfameron> what's a bifunctor?
00:57:20 <dibblego> how is it not? it satisfies both identity and composition
00:57:36 <quicksilver> dibblego: it doesn't satisfy composition in the left argument.
00:57:55 <quicksilver> osfameron: a bifunctor is something with two (type) arguments, which is a functor in both.
00:58:22 <quicksilver> dibblego: it is, of course, contravarient in the left argument. But that's not what we normally mean by 'bifunctor', and it certainly isn't what the class 'Bifunctor' means/would mean.
00:58:36 <osfameron> right, I'll read up on functors again, as I clearly don't understand this at all
00:58:56 <dibblego> osfameron, forget bifunctors for now
00:59:02 <quicksilver> a functor is a type with an argument, such that it obeys certain rules
00:59:10 <quicksilver> the simplest examples are [a] and Maybe a
00:59:13 <RayNbow> http://hpaste.org/10625
00:59:23 <quicksilver> and the rules it has to obey basically say "you can apply a function to the stuff inside"
00:59:24 <RayNbow> @bot
00:59:25 <lambdabot> :)
00:59:40 <quicksilver> and it works the way you'd expect (identity inside, composition inside)
01:00:28 <RayNbow> osfameron, http://hpaste.org/10625 <-- do you understand these two simple examples?
01:00:58 <dibblego> quicksilver, sorry you're right
01:02:45 <osfameron> RayNbow: er, I think so, didn't know you could alias the -> with a type.
01:03:09 <osfameron> RayNbow: do you have to do the add with explicity currying style as you have done there?
01:03:14 <dibblego> data (->) a b = ...
01:03:38 <RayNbow> osfameron: no, the explicit currying is not necessary
01:05:56 * osfameron has a bad case of Haskell Perpetual Beginner Syndrome
01:07:09 <osfameron> I'm "very interested" in haskell, and I've got enough of an attention span to have not yet given up on it, but when I do get time to spend on it, I only really do the same beginner's exercises (and get a bit better at them) and still get baffled by the next step on
01:07:20 <quicksilver> osfameron: well you're in the right place to get help :)
01:07:35 <quicksilver> what is this morning's bafflement de jour?
01:08:01 <dibblego> osfameron, the exercises you are looking at originated from a Scala training course for people who use Java
01:08:06 <osfameron> quicksilver: I was looking at http://blog.tmorris.net/20-intermediate-haskell-exercises/
01:08:08 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
01:08:21 <osfameron> I did the beginner ones (folds and such) by the same guy (I think)
01:08:36 <osfameron> I stared for 20 mins at #1 on the list, before getting what it meant
01:08:37 <dibblego> yes
01:08:39 <quicksilver> those exercises are, in a sense, a joke.
01:08:43 <osfameron> #2 was easy
01:08:45 <quicksilver> although they are useful exercises.
01:09:10 <dibblego> they are useful because they are the quickest path that a student has ever understood the concepts involved
01:09:10 <osfameron> #3 I couldn't even work out the type signature for (though of course, the answer in one sense is exactly the same as the answer for the others...)
01:09:42 <osfameron> as in, I needed the fmap instance for ... something ... but just couldn't work out what for :-)
01:09:50 <quicksilver> (->) t is "functions from t"
01:10:06 <quicksilver> (->) t Int would also be written t -> Int
01:10:13 <quicksilver> is that much clear?
01:10:45 <quicksilver> so the signature of furry in this case is (a -> b) -> ((->) t a) -> ((->) t b)
01:10:50 <quicksilver> which would more naturally be written
01:10:59 <quicksilver> (a -> b) -> (t -> a) -> (t -> b)
01:11:48 <Twey> It's just an operator like all the others
01:12:42 <osfameron> is the t in (t->a) the same as the one in (t->b) ?
01:12:59 <dibblego> it's the same one as in the Functor declaration
01:13:12 <dibblego> instance Functor ((->) t) where ...
01:13:30 <osfameron> it doesn't seem to be from the fact that the fmap instance is apparently composition (I ended up looking at a spoiler)
01:13:45 <dibblego> @djinn (a -> b) -> (t -> a) -> (t -> b)
01:13:46 <lambdabot> f a b c = a (b c)
01:13:53 <dibblego> right, composition :)
01:14:20 <osfameron> I looked at it, saw that the fmap instance was composition, and assumed that ((->) t) must mean a function, as that's what get composed
01:14:49 <quicksilver> osfameron: yes, it's the same t
01:15:25 <quicksilver> djinn's solution looks confusing because it has three arguments
01:15:36 <dibblego> @djinn (a -> b) -> (t -> a) -> t -> b
01:15:36 <lambdabot> f a b c = a (b c)
01:15:41 <quicksilver> you may find it looks much more natural if you give it only two arguments
01:15:48 <quicksilver> which is arguably the way you should think about it.
01:16:39 <quicksilver> Twey: I think that's harsh. It's not "just" an operator like "all" the others. It is a type operator, not a value operator; it is the only type operator in haskell.
01:16:49 <quicksilver> there are no others.
01:16:54 <moshisushi> hello is there a function like "delete" but one that takes a list of indexes?
01:17:06 <dibblego> zip and filter
01:17:10 <quicksilver> moshisushi: no, there is no need. You just fold delete.
01:17:17 <RayNbow> f a b c = a (b c)   ~~>   compose f g x = f (g x)   -- let's do some renaming :)
01:18:08 <RayNbow> ~~> (f `compose` g) x = f (g x)  -- while we're at it, let's do some infix stuff :p
01:19:06 <osfameron> quicksilver: but in (furry (+1) length "hello"), (+1) is (Int->Int) and length = (String->Int), which are different t's ?
01:20:03 <quicksilver> yes, but (+1) is the (a -> b) part
01:20:15 <quicksilver> and length :: String -> Int is the (t -> a) part
01:20:22 <quicksilver> so 't' is String here.
01:20:31 <quicksilver> (and 'a' is Int and 'b' is Int)
01:22:24 <Twey> quicksilver: Heh, OK, OK :)
01:22:47 <Twey> I apologise for demeaning the One And Only Type Operator :-P
01:24:27 <osfameron> quicksilver: oh, I see, yes
01:24:45 <quicksilver> Twey: :P
01:24:59 <vlm> > foldl
01:25:00 <lambdabot>       Overlapping instances for Show ((a -> b -> a) -> a -> [b] -> a)
01:25:00 <lambdabot>        ...
01:25:32 <quicksilver> does it scare anyone else that someone just replied to a -cafe thread with "The first thing I thought of was to try to apply one of the recursion schemes in the category-extras package"
01:26:11 <Cale> ;)
01:26:39 <Cale> parazygohistomorphisms are the way of the future :)
01:27:02 <quicksilver> when is MS releasing ParaZygoHisto# ?
01:42:45 <BeelsebobWork> I'm confused -- darcs apply is telling me I'm lacking a patch from the hs-plugins repo, meanwhile darcs pull is telling me there's no changes
01:42:51 <BeelsebobWork> anyone got any idea how that can happen?
01:44:56 <ivanm> BeelsebobWork: the evil imperative demons got into your repo?
01:45:09 <BeelsebobWork> something like that
01:45:33 * BeelsebobWork ponders if he "got" from a different repo -- is there a special place for the repo that's tagged as v1.2?
01:47:07 <_zenon_> Geesh. The guys over at #lisp are sure hot today.
01:47:32 <sjanssen> ?
01:48:05 <_zenon_> I ask which interpreter they like and get beaten over the head.
01:48:18 <quicksilver> I like ghci
01:48:24 * quicksilver thwaps _zenon_ over the head
01:48:43 <_zenon_> quicksilver, et tu quicksilver?
01:48:53 <_zenon_> or what the quote is.
01:48:56 <_zenon_> et tu brutus.
01:49:15 <ozy`> _zenon_: which haskell interpreter they like?
01:49:16 <RayNbow> it's actually "Et tu, Brute?"
01:49:26 <ozy`> yeah, Latin has the vocative
01:49:27 <RayNbow> the vocative of Brutus is Brute ;)
01:49:39 <quicksilver> "kai su, teknon"
01:49:45 <quicksilver> is supposedly more likely.
01:49:49 <_zenon_> ozy`, no, just which interpeter they like.
01:50:04 <RayNbow> quicksilver: my Greek is terrible :p
01:50:37 * RayNbow only had 1 year of Greek a long time ago
01:50:56 * _zenon_ is sitting on the world's worst wifi
01:51:18 <RayNbow> _zenon_: be careful not to microwave your ass then
01:51:26 * ilyak once had a wi-fi session with stable 3kb/sec transfer rate
01:51:37 <ilyak> For a few minutes
01:51:41 <_zenon_> RayNbow, yeah, I'm trying not to. Actually I would be more careful about my b*lls
01:52:39 <ozy`> looks like he got a little too comfortable...
01:55:40 <Fuse_> Man I had the strangest nightmare last night: I installed FreeBSD but there was no GHC for it.
01:56:06 <BeelsebobWork> haha
01:56:13 <Baughn> Fuse_: That was real
01:56:14 <_zenon_> Fuse_, :=
01:56:28 * RayNbow is not hardcore enough to have Haskell related dreams
01:56:37 * Axman6 has them all the time
01:56:37 <RayNbow> (I still have a long way to go :p)
01:57:03 <Fuse_> mine are more generic - usually some combo of programming and maths, y'knoa
01:57:43 <Baughn> Urk. I had a nightmare last night about unsafePerformIO. The universe was simulated in haskell, you see.. and we found a loophole that let us use it...
01:57:47 <Baughn> We really shouldn't have. >_<
01:57:58 <Fuse_> hahaha
01:58:01 * BeelsebobWork ponders if sjanssen is anywhere about
01:58:02 <_zenon_>  /me just dreams dreams.
01:59:56 <RayNbow> _zenon_ dreams of better wifi world, methinks :p
02:00:00 <RayNbow> wb :)
02:00:04 <Fuse_> You know I was reading 'Caves of Steel' by Asimov the other day and it was pretty bleak. It was written in the 1940's so all the high technology was a mix of current sci-fi and weird lowtech. I was like "where's all the internet?" not to mention the premise of the book was that 8 billion people is so unsustainable it requires some weird amalgam of communism and capitalism. And the politeness... ack.
02:00:37 <Baughn> Poor guy. That was, inevitably, a victim of progress
02:00:47 <Baughn> 8 billion sounds pretty reasonable now. ^^;
02:00:55 <_zenon_> RayNbow, hehe, yeah. mmmm... wifi
02:01:17 * RayNbow is performing unsafeWiFi at home
02:01:20 <BeelsebobWork> not so sure about that, we're at 6 billion and having problems with it
02:01:30 <Fuse_> Oh yeah. It'll be interesting to see how his writing progresses... he kept it up till like the 1990's
02:01:51 <Fuse_> Er did that just send?
02:01:57 <_zenon_> Baughn, Isaac Asimov. A favourite of mine.
02:02:03 <RayNbow> (no WEP key at all... but that's because I have some very old PCMCIA cards in use in a few old computers :p)
02:02:11 <quicksilver> Fuse_: My favourite Asimove-related quote:
02:02:12 <quicksilver> Asimov went ahead and changed the ending in the book so it made sense. Hollywood, believing revenge is a dish best served cold, waited 40 years and then turned his book I, Robot into a love story between Will Smith and a pair of converse.
02:02:22 <Baughn> _zenon_: I've read it, of course
02:02:46 <Fuse_> Beelse: um no way. we're at about 7 billion now and things have only ever improved over time, slowly but surely.
02:03:01 <Fuse_> HIV put a bit of a spanner in it for Africa, but even that is surmountable
02:03:02 <Baughn> BeelsebobWork: Only a little, and food production is, by and large, still improving faster than the population is growing
02:03:11 <Baughn> Besides, eventually we'll master hydroponics
02:03:12 <_zenon_> quicksilver, :) hehehehe.
02:03:32 <Fuse_> food is very unevenly distributed atm, but we could probably easily support 20 billion on earth with a bit of tinkering
02:03:44 <Baughn> BeelsebobWork: That is to say, we're doing a lot better at feeding 7B now than we did at feeding 1B a century and a half ago. ^_^
02:03:54 <BeelsebobWork> true
02:04:27 <Fuse_> quicksilver: really? He changed the ending of Caves of Steel?
02:04:55 <_zenon_> Fuse_, yeah. but who will pay for the tinkering? No one is willing to pay for the transport of the over-production of food from the rich part of the world to the poor parts.
02:04:59 <RayNbow> Fuse_: isn't it like that 20% of the world uses like 80% of the available resources?
02:06:05 <Fuse_> RayNbow: something like that. it's easy to change by reducing meat consumption because cattle are very inefficient at converting plant energy in terms of you get back like 1/6th of the energy you put into them from grain and stuff
02:06:15 <Fuse_> _zenon_:  easy: the market will.
02:06:28 <Fuse_> I'm no libertarian but that stuff sorts itself out over time
02:06:55 <_zenon_> Fuse_, which market? "The market" is the current leader in waste disposal á la dump it in africa and don't look at it.
02:07:05 <Fuse_> Pardon?
02:07:28 <Fuse_> I don't know what you're getting it, but there's a general trend ever upwards in the undeveloped and developing countries
02:07:30 <quicksilver> Fuse_: sorry, no the quote is about fantastic voyage
02:07:38 <quicksilver> Fuse_: I just think it's funny :)
02:08:04 <Fuse_> yeah... what's his best book in your opinion?
02:08:28 * _zenon_ likes all his novels... soo many, so good.
02:08:46 <Baughn> Asimov's? Sorry.. I used to like the foundation series a lot, but they basically /all/ look horribly dated by now
02:09:15 <Baughn> The robot series are the worst. We don't know how to make AI yet, but we sure do know how to avoid any flaws as obvious as the ones he was using
02:09:26 <_zenon_> I haven't read any of his detective stories though. Maybe I should.
02:10:04 <Baughn> _zenon_: You might not like them, but go ahead and try
02:10:15 <_zenon_> Baughn, what? Nooo,.. The robot series are great :) I'ts like a detective story where you have to try and find the cause of the problems.
02:10:17 <Baughn> I believe series like Poirot have survived better, though
02:10:18 <Fuse_> *sigh* I was looking for some good solid sci-fi, not some sci-fi that was good and solid 40 years ago and inspired a younger generation
02:10:35 <wman> jack chalker ?
02:10:56 <wman> well of souls, wonderland gambit ...
02:11:01 <Baughn> _zenon_: Asimov wrote his three laws specifically as strawmen, to poke holes in them. Well, he succeeded; nobody in the field would even /consider/ using anything like that, now
02:11:09 <Fuse_> _zenon_: Caves of Steel was decent but I think the culture barrier made me lose sight of the rest of the book
02:11:15 <Baughn> Which makes the books too unrealistic to read, in my mind
02:11:41 <wman> probably not written 40 years ago, thug ;-)
02:11:42 <Fuse_> Baughn: you need to give him credit for help to spur such thought in the first place
02:12:05 <wman> thug -> though
02:12:09 <Baughn> Fuse_: Oh, I do
02:12:16 <_zenon_> Fuse_, what do you mean with culture barrier? Is it the time epoc+
02:12:16 <_zenon_> ?
02:12:22 <Fuse_> yep
02:12:59 <quicksilver> I enjoyed the foundation series very much.
02:13:11 <Baughn> It's 40's SF. He did try to evolve the cultural norms a bit, but.. in the wrong direction, as it turns out
02:13:21 <Baughn> *50s
02:13:41 <Fuse_> _zenon: in this day and age we have equality of the sexes, the internet, the IC, globalisation, less chivalry, etc. all together they just become too much to overcome I think
02:13:53 <Fuse_> maybe now I'm used to his universe the next book will be easier
02:13:56 <Baughn> It's a bit like reading hornblower; the norms are too alien to relate to, but unlike hornblower they're an important part of the story
02:14:10 <_zenon_> hornblower? never heard of.
02:14:29 <Baughn> Think Honor Harrington on sailing ships. ^_^
02:14:51 <Fuse_> has anybody read anything by Peter F Hamilton?
02:15:11 <Baughn> It's 19th century fiction about 18th century warships, so.. right, cultural norms are horrifyingly alien
02:15:31 <BeelsebobWork> Fuse_: he's an awesome author isn't he
02:15:43 <Ferdirand> mhh, funny problem with ghci
02:16:02 <_zenon_> Baughn, hm... Is it worse than those "What if?" books where the nazis send people back in time and create parallel universes and sh*t.
02:16:07 <Fuse_> beelsebob: oh hell yes
02:16:13 <Fuse_> do you know any other authors like him?
02:16:26 <paulanto> hi everyone. does anyone know if it is possible to use GSL / LAPACK from Haskell?
02:16:27 <Fuse_> Ferdirand: what is it?
02:16:34 <Ferdirand> i'm trying the exercises mentioned earlier, one of my solution attempts has ghci eating up 99% cpu when compiling
02:16:36 <Baughn> _zenon_: It's historical fiction. The world is the way the world really was, plus it was /written/ in the 19th century.
02:16:49 <Ferdirand> is that supposed to happen ?
02:16:58 <Fuse_> aha, probably not.
02:17:19 <Baughn> _zenon_: Worth reading just for the historical value, really, but they're good adventures too. It's just.. even the best men there look like xenophobic racist assholes by modern standards
02:17:41 <Fuse_> Baughn: exactly
02:17:42 <wman> and what about john wyndham ? not even a single robot afaik, but his books are imo still very readable today.
02:17:56 <_zenon_> Baughn, ah, yes. :) Hehe. Hard to beat that... like the "Miss Race Award" in Stockholm [capital of Sweden] in the 1940's :D
02:18:02 <Ferdirand> without a type signature, it compiles, but does not infer the type I expect, so it must be wrong; but if I add the expected type signature, it hangs
02:18:17 <Ferdirand> ghci 6.8.2
02:18:32 <_zenon_> A sarcastic smile that is.....
02:19:19 <Baughn> Ferdirand: Add more type signatures until it errors out
02:19:20 <RayNbow> paulanto: it's probably possible, but I have no experience with it
02:19:36 <RayNbow> paulanto, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas , http://www.cs.utah.edu/~hal/HBlas/index.html
02:19:40 <Fuse_> Wyndham was good. His books age far more slowly. I also love the books by the guys who wrote Red Dwarf. And the Tripods novels are epic.
02:19:41 <lambdabot> Title: HackageDB: blas-0.5
02:19:48 <paulanto> RayNbow: possible for sure. I know someone made a package for gsl-random-generators
02:19:49 <Baughn> Ferdirand: The sad fact is, haskell's type system is quite capable of exponential-time behaviour in edge cases. Even infinite loops, I'm pretty sure, though you'd really have to /try/ to manage that one
02:20:01 <quicksilver> Ferdirand: if it hangs whilst inferring types than there is a bug in the compiler.
02:20:10 <quicksilver> Baughn: there are no infinite loops in haskell's type system.
02:20:19 <Baughn> quicksilver: It's not turing-complete?
02:20:20 <quicksilver> [there are in some GHC extensions, but don't turn those on]
02:20:20 <paulanto> RayNbow: the thing is, I need some math functions in addition to the LAPACK stuff
02:20:24 <quicksilver> Baughn: certainly not.
02:20:25 <Baughn> Right. ^^;
02:20:42 <paulanto> RayNbow: which is in GSL, of course...
02:20:53 <Baughn> Ferdirand: Mercury makes a good point, of course. It could be a bug, and 6.8.2 is /not/ the newest version. ;)
02:21:11 <Fuse_> um, Haskell isn't turing complete?!
02:21:12 <RayNbow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gsl-random <-- the only GSL related package I can find on hackage
02:21:14 <lambdabot> Title: HackageDB: gsl-random-0.1.1, http://tinyurl.com/3v7fgy
02:21:15 <Fuse_> that's a new one
02:21:18 <Baughn> Fuse_: The type system isn't
02:21:24 <Fuse_> ah
02:21:26 <Baughn> Except with some extensions, apparently
02:21:42 <paulanto> RayNbow: yep, agree there. so I guess it's possible to make, but I don't want to do it all myself...
02:22:56 <quicksilver> undecidable + incoherent instances is enough to make infintie loops
02:23:03 <quicksilver> I'm not 100% sure it's enough for turing completeness
02:23:05 <quicksilver> btu I think so.
02:23:13 <paulanto> RayNbow: I guess you don't know any spherical harmonics implementation?...
02:23:13 <quicksilver> someone solved the rubik cube at compile time, IIRC.
02:23:27 <Fuse_> haha
02:23:49 <Fuse_> somebody solved sudoku with ubuntu's package management system's dependencies
02:24:04 <RayNbow> paulanto: I actually know nothing about LAPACK, GSL, spherical harmonics... sorry
02:24:08 <_zenon_> what are you talking about?
02:24:18 <_zenon_> somebody solved [X] with [Y] ?
02:24:27 <paulanto> RayNbow: thanks anyway :) I guess I'll do it in python if I don't find anything Haskellian soon
02:35:59 <mm_freak> imagine i need to learn a lisp dialect, and haskell is my main language
02:36:08 <mm_freak> which one would you recommend?  clisp or scheme?
02:36:16 <ilyak> scheme is much smaller
02:36:26 <ilyak> You can pick it up really fast
02:37:11 <mm_freak> how is library support in scheme compared to clisp?
02:37:16 <Fuse_> never learnt LISP, but I've heard only good things about Scheme
02:37:25 <MyCatVerbs> mm_freak: it isn't.
02:38:10 <MyCatVerbs> mm_freak: if you want something to hack in on a day to day basis, CL is rather more featureful and has more libraries. Scheme is much smaller and quicker to learn though, if you're just learning it for the sake of learning.
02:38:28 <mm_freak> ok then, i'll learn both
02:38:42 <mm_freak> scheme first to get the idea, then clisp to actually work with
02:38:59 <Fuse_> is LISP really that different to Haskell?
02:39:23 <mm_freak> it seems to have a few similarities, but otherwise it's a different idea
02:39:41 <mm_freak> it seems to be 'more functional' in a sense
02:40:11 <Fuse_> but I heard it's not purely functional like Haskell?
02:41:02 <flux> even further, lisp doesn't do tail recursion optimization (per specification, I guess some implementations may choose to do it anyway), so it's difficult to write certain constructs in a purely functional way
02:41:05 <BeelsebobWork> mm_freak: Haskell is much 'more functional', but is rarely written in a functional style
02:41:31 <mm_freak> BeelsebobWork: true
02:42:08 <flux> also, values are mutable by default in Lisp
02:42:25 <flux> I would say lisp is infact very far from haskell :)
02:42:58 <mm_freak> yeah, that's my impression, though i think that you could transfer most purely functional lisp programs verbatim to haskell
02:43:48 <mr_H> anyone here uses opensuse ? is there any repository i can add, to install ghc ?
02:44:00 <flux> unless they happen to use meta programming or if it is difficult to assign types to values
02:44:23 <Fuse_> You could add the Ubuntu respository. /facetious
02:44:48 <mm_freak> another question…  a widely used scheme interpreter/compiler?  guile?
02:44:50 <inimino> isn't SuSE RPM based?
02:45:37 <mr_H> inimino, yes, but its "special rpm's" as far as i know :/
02:45:54 <inimino> oh, ok
02:45:55 <Dynetrekk> RayNbow: (it's me again, the GSL guy.) it seems that you find GSL and LAPACK here: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
02:45:58 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
02:46:01 <Fuse_> just for laughs: http://www.google.com/trends?q=ubuntu%2C+fedora%2C+suse%2C+gentoo%2C+slackware&ctab=0&geo=all&date=all&sort=0
02:46:03 <lambdabot> Title: Google Trends: ubuntu, fedora, suse, gentoo, slackware, http://tinyurl.com/4zpku8
02:46:05 <ilyak> mm_freak: There's a cool thing which can be used for learning
02:46:15 <ilyak> Sort of mini-IDE with interpreter built in
02:46:18 <ilyak> ask ob #scheme
02:46:33 <ilyak> It also integrates with a few different interpreters
02:47:26 <mm_freak> ilyak: i prefer to separate editing from invoking…  i use emacs with a separate shell and i'm happy with that — so far
02:47:56 <mm_freak> i'll use guile for now
02:48:27 <inimino> mr_H: http://www.haskell.org/ghc/distribution_packages.html#opensuse
02:48:28 <lambdabot> Title: GHC: Distribution packages
02:54:09 <mr_H> thanks inimino
02:54:15 <inimino> np
03:21:07 <pmurias> is there a way for cabal's ./Setup configure to set the path where ld searches for shared libraries
03:21:58 <thoughtpolice> --extra-lib-dirs ?
03:24:20 <pmurias> thanks, worked the second time i tried it ;)
03:26:46 <pmurias> and i have to specify LD_LIBRARY_PATH to run the executable?
03:27:05 <thoughtpolice> not sure about that one
03:29:33 <pmurias> work only if i specify it
03:29:36 <pmurias> * works
03:36:24 <mm_freak> learning scheme isn't fun =/
03:36:24 <ilyak> mm_freak: Well, why?
03:36:24 <Fuse_> hah really?
03:36:24 <ozy`> is it because of the parentheses?
03:36:24 <ilyak> I mean, it's pretty low-level, but cute
03:36:24 <mm_freak> nope
03:36:33 <mm_freak> it's because i'm used to haskell
03:36:37 <Fuse_> the most fun languages I've ever learnt were Python and Haskell
03:36:37 <Fuse_> for much the same reasons
03:36:42 <mapreduce> How do you define low-level to include Scheme?
03:36:49 <Fuse_> haha
03:37:21 <ilyak> mapreduce: As in 'you'll have to do everything by hand', this way it's more a library issue than a language issue
03:37:29 <Fuse_> ah yeah
03:37:54 <ilyak> See also 'writing with boxing gloves on'
03:40:24 <Fuse_> Hmm
03:40:35 <Fuse_> could somebody give me some ideas of what to code?
03:40:51 <Fuse_> I've got a basic understanding of Haskell (a semester at uni)
03:41:24 <earthy> write a simple compiler
03:41:31 <Fuse_> ...
03:41:49 <thoughtpolice> Fuse_: a simple compiler is a good idea, with the harpy package on hackage you can do some really cool stuff
03:41:49 <earthy> or try your hand at the spoj assignments
03:42:01 <Fuse_> spoj?
03:42:01 <thoughtpolice> in terms of generating code easily
03:42:02 <earthy> http://www.spoj.pl/
03:42:08 <lambdabot> Title: Sphere Online Judge (SPOJ)
03:42:16 <Fuse_> A compiler seems amazingly complex to me, but I'll look at it
03:42:21 <thoughtpolice> Fuse_: also if you have the ghc 6.10 beta there is data parallel haskell which is still very rough but it's fun to play with
03:42:26 <Fuse_> I'm only half-way through my CS degree
03:42:52 <thoughtpolice> Fuse_: doesn't have to be complicated :]
03:42:54 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/calc
03:42:55 <lambdabot> Title: HackageDB: calc-0.1
03:43:05 <earthy> I helped architect a curriculum once that had a compiler in the first year of a CS degree
03:43:05 <mm_freak> Fuse_: a brainfuck compiler is easy to write ;)
03:43:10 <thoughtpolice> i wrote that in better part of a day or so, about 150 lines or something and turns arithmetic expressions into native code and executes it
03:43:29 <mm_freak> in fact, brainfuck is designed to have the shortest possible compiler
03:43:33 <earthy> compiling sounds difficult and hard but isn't... not really
03:43:44 <Fuse_> huh... alright, I'll have a gander at that
03:43:47 * Baughn notes that darcs 2.0.2 bugs out on trying to download the ghc 6.10 beta
03:43:47 <inimino> simple compilers are easy
03:43:53 <thoughtpolice> it's when the 'optimizing' part comes into play that things get tough :]
03:44:11 <inimino> real-world compilers are among the most complicated programs written
03:44:31 <Fuse_> so by 'compiler' you just mean 'takes a simple "language" and turns it into a programme'?
03:44:32 <earthy> inimino: true enough
03:44:38 <thoughtpolice> simple compilers even for x86 aren't that tough to write, even for a non-non-trivial language
03:45:00 <mm_freak> ok, the funniest languages i've learned so far were haskell and prolog, though i forgot most of prolog again
03:45:02 <earthy> fuse: take a reasonably simple language and turn it into machine code for a given machine
03:45:05 <inimino> non-non-trivial?
03:45:18 <Baughn> "Bus errorng repository http://darcs.haskell.org/ghc-6.10/ghc inventory" <-- Help?
03:45:18 * shapr boings
03:45:19 <lambdabot> Title: Index of /ghc-6.10/ghc
03:45:23 <Fuse_> earthy: doable if I don't know ASM?
03:45:32 <earthy> yup, even then
03:45:36 <thoughtpolice> i say non-non-trivial to mean a language that isn't the most featureful, but also not totally trivial and useless
03:45:38 <Fuse_> coolia
03:45:51 <mm_freak> some time i'll learn Clean, too
03:45:53 <thoughtpolice> so you get at least a reasonable scope as to what you need to do and how to do it
03:45:54 <earthy> take e.g. the JVM as the 'given machine'
03:45:56 <shapr> Fuse_: I haven't even started my CS degree!
03:45:58 <mm_freak> can't be too difficult, if you already know haskell
03:46:17 <inimino> so for you "non-non-trivial" /= "trivial"
03:46:38 <thoughtpolice> Fuse_: like I said check out harpy, it's really cool. it allows you to basically embed x86 into haskell, but you get all your awesome higher-order functions and whatnot and it makes things a lot simpler
03:47:05 <Fuse_> I don't know why I want to use Haskell. It's not exactly the most used real-world language out there and there's a lot of stuff I could do just as easily in Python. Still, it struck something in me and I want to keep learning it.
03:47:20 <thoughtpolice> see: real world haskell
03:47:24 <thoughtpolice> :]
03:47:27 <Fuse_> thoughtpolice: that sounds pretty sweet
03:47:46 <thoughtpolice> Fuse_: http://book.realworldhaskell.org/read/
03:47:57 <lambdabot> Title: Real World Haskell
03:48:05 <Fuse_> I'm not sure how one reconciles embedding ASM x86 into Haskell with safety and purity, but whatever - sounds neat
03:48:11 <thoughtpolice> absolutely excellent read for someone wanting to look at real stuff
03:48:11 <Fuse_> cheers
03:48:15 <thoughtpolice> Fuse_: uses a code generation monad
03:48:25 <parodyoflanguage> <Fuse_> could somebody give me some ideas of what to code? <-- You know, actually, this is a good question in general.  It would be nice to have a list on the internet of small/short projects that are both fun and educational.  Projects that could take anywhere from a few hours to a few weeks.
03:48:26 <thoughtpolice> it's just a DSL, basically
03:48:31 <Fuse_> I'm using "The Craft of Functional Programming" atm
03:49:13 <thoughtpolice> Fuse_: also it says on the webpage that I gave praise to it and that should say enough about the quality! ;]
03:50:32 <Fuse_> can I install harpy through repositories, do you know?
03:50:41 <thoughtpolice> Fuse_: you can with cabal install
03:51:00 <thoughtpolice> but native OS package managers? maybe, maybe not
03:51:12 <Fuse_> fair enough
03:51:27 <thoughtpolice> aside from archlinux (which dons updates with new packages at a mindblowing-speed) most distros seem to vary pretty heavily in their haskell support
03:52:03 <thoughtpolice> Fuse_: i talked about this the other day though on haskell-cafe and IMO if you're going to be coding haskell, cabal install is the way to go for sure
03:52:13 <Botje> Fuse_: i started work on a boat simpulator
03:52:14 <Fuse_> i'll google it
03:52:16 <Botje> *simulator
03:52:32 <Botje> recent small projects have included a small and simple webserver
03:52:38 <Botje> and a terrain generator
03:52:47 <thoughtpolice> Fuse_: you always get the latest and greatest, and package managers will only see what they have installed, not what e.g. you have installed from source/binary or some other means
03:53:10 <Axman6> hmm, it's possible to define your own show function for your datatypes right?
03:53:13 <thoughtpolice> which means sometimes the manager will say it needs to install ghc-6.8 because it's a dependency of say, haskell-HTTP, when you in reality have ghc installed but it was from an alternate source than the manager
03:53:17 <inimino> cabal install is the way to go
03:53:57 <thoughtpolice> distro-specific packages are more of use if you want haskell apps but you don't write haskell IMO, e.g. if you just do 'pacman -S pandoc' (or darcs or something) the manager can track all that stuff for you, and it's not a problem because you don't code haskell anyway
03:53:58 <inimino> Axman6: yes, you can give an instance of the Show class
03:54:11 <inimino> with your own show function
03:54:11 <Fuse_> cool. thanks for the ideas and tips guys!
03:54:15 <Axman6> ah yes, right
03:54:34 <Harpy> wot wot.. please don't hl me, I'm idling
03:54:52 <thoughtpolice> ;)
03:55:06 <Fuse_> the bane of using a nick coincident with a Haskell package ;)
03:55:20 <thoughtpolice> something like that
03:56:48 <Botje> IDLING FAIL
03:56:54 <thoughtpolice> hackage has been really slow lately... i should finish up my tokyocabinet bindings
03:57:38 <Axman6> inimino: hmm, i'm failing to not have ghc complain about ambiguous show occurances
03:57:41 <thoughtpolice> i only have like 200 more functions or something to bind up :P
03:57:51 <thoughtpolice> Axman6: paste code + err?
03:58:16 <zeno> http://i89.photobucket.com/albums/k220/kipper_308/fran_web.jpg <- lol! Anyone know where this is from?
03:58:22 <Axman6> in a sec, i've hyst found something that might help
03:59:09 <Axman6> just*
03:59:19 <Botje> lol
03:59:32 <Botje> tim's case is self-inflicted though
03:59:49 <thoughtpolice> perhaps "tim - the non recursive lambda expression" should meet "bob - the famous fixpoint combinator"
03:59:49 <thoughtpolice> ?
03:59:58 <Botje> yeah.
04:00:20 <Axman6> http://hpaste.org/10626 is what i have
04:00:53 * inimino looks
04:01:15 <Fuse_> hahahaha @ the automata cartoon
04:01:49 <Axman6> inimino: i've anotated the error if you refresh...
04:01:49 <thoughtpolice> Axman6: works fine here
04:01:57 <Axman6> :\
04:02:09 <Botje> Axman6: what's line 20 of turing-machine.hs ?
04:02:14 <inimino> hm...
04:02:15 <thoughtpolice> Axman6: in the case of the err we need more context
04:02:28 <thoughtpolice> show is already defined by the prelude, you have your own top-level show definition somewhere lese
04:02:37 <thoughtpolice> *else, it seems
04:02:59 <inimino> it compiles
04:03:01 <inimino> for me
04:03:11 <thoughtpolice> yeah the paste works fine
04:03:22 <thoughtpolice> your show instance is perfectly correct, you just have another function named 'show' somewhere
04:03:26 <Axman6> http://hpaste.org/10626#a2
04:03:40 <Axman6> oh, rawr, my bad
04:04:05 <Axman6> ok, well taking out the second show in there doesn't work...
04:04:10 <Botje> it should
04:04:19 <Botje> Axman6: any good reason for the triplet after T?
04:04:26 <Botje> might as well just have T l s r
04:04:26 <EvilTerran> don't forget to save and reload
04:04:46 <Botje> which will make pattern matches a bit clearer
04:04:52 <inimino> erm, scratch that
04:05:01 <Axman6> Botje: i don't want to have to aslway access it as T l s r, but T s
04:05:11 <inimino> that was a completely different file
04:05:27 <Axman6> anyway, seems to work now, cheers :)
04:05:27 <Botje> Axman6: compiles fine here
04:05:52 <inimino> ok, cool
04:12:44 <Baughn> If I write something like [x / sum xs | x <- xs], is ghc likely to be smart enough to float the sum?
04:13:22 <thoughtpolice> @t (/)
04:13:22 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:13:32 <thoughtpolice> :type (/)
04:13:59 <thoughtpolice> :/
04:14:03 <thoughtpolice> Baughn: (/) :: (Fractional a) => a -> a -> a
04:14:16 <thoughtpolice> oh no wait
04:14:35 <thoughtpolice> in the case of sum it has type 'Num a => [a] -> a'
04:14:37 <Baughn> thoughtpolice: I was referring to let-floating, not number representations. ;)
04:14:41 <thoughtpolice> ooo
04:14:43 <thoughtpolice> not sure
04:14:44 <thoughtpolice> check core
04:14:52 <Dynetrekk> hi guys. anyone who can help me with cabal configuration problems? http://hpaste.org/10627
04:14:58 <Baughn> Nah, I'll just take the where.
04:15:18 <thoughtpolice> Dynetrekk: you need the storable-complex package off of hackage.haskell.org
04:15:22 <thoughtpolice> Dynetrekk: I recommend installing cabal-install
04:15:32 <Dynetrekk> thoughtpolice: what is that?
04:15:35 <thoughtpolice> and then you can just 'cabal install hmatrix' and life is easy (auto-dependency tracking)
04:15:52 <Dynetrekk> thoughtpolice: similar to, say, debian's package management?
04:15:53 <thoughtpolice> Dynetrekk: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
04:15:59 <lambdabot> Title: HackageDB: cabal-install-0.5.2, http://tinyurl.com/2sj7lw
04:16:01 <thoughtpolice> Dynetrekk: package management in general
04:16:13 <Dynetrekk> thoughtpolice: thanks, great!
04:16:24 <thoughtpolice> Dynetrekk: you might need the zlib and HTTP packages before you can build it, though
04:16:34 <thoughtpolice> but iirc they don't depend on anything that isn't provided with GHC itself so that's it
04:16:45 <thoughtpolice> the tarball also comes with a 'bootstrap.sh' file that should take care of it anyway
04:17:31 <Dynetrekk> thoughtpolice: sounds great, I'll try to install it now...
04:17:59 <thoughtpolice> Dynetrekk: it is. I manually tracked dependencies with wget for a long time, and it's a godsend tbh :]
04:18:20 <thoughtpolice> not even 'tracked', more like 'somehow managed'
04:18:33 <Dynetrekk> thoughtpolice: I can understand. package managers are usually fantastic things
04:19:07 <Dynetrekk> thoughtpolice: doesn't give any instructions for installation though.... just run the bootstrap.sh on the command line?
04:19:16 <thoughtpolice> Dynetrekk: yeah just try 'sh bootstrap.sh' first
04:20:16 <thoughtpolice> Dynetrekk: after that just run 'cabal --help
04:20:20 <thoughtpolice> and go from there
04:21:19 <thoughtpolice> you basically want 'cabal update' which will update the package list, 'cabal install' which will track dependencies and install things, and 'cabal upgrade' which will install a package, but also build the most recent version of it against the most recent version of all the libraries and whatnot
04:21:23 <Dynetrekk> thoughtpolice: failed miserably... wget: command not found
04:21:40 <Botje> i'm planning on using unsafePerformIO to load a list of goods statically at start
04:21:52 <Botje> any really good arguments why i shouldn't do so?
04:21:55 <thoughtpolice> Dynetrekk: linux?
04:22:04 <Dynetrekk> thoughtpolice: mac OS X.5
04:22:14 <Dynetrekk> thoughtpolice: I found wget in fink, though
04:22:16 <thoughtpolice> Botje: i've seen it used for that seveal times and if you're sure e.g. the file you're reading from won't change during that time then it's fine
04:22:20 <thoughtpolice> Dynetrekk: yeah i use macports
04:22:30 <Botje> well, it won't :)
04:22:35 <Dynetrekk> okay, same thing more or less (to my knowledge).
04:22:37 <thoughtpolice> Botje: then go for it
04:22:47 <Botje> yay
04:25:12 <Dynetrekk> thoughtpolice: and now I can install any old package just by writing cabal install <package>, and the dependencies will "fix themselves" ?
04:25:34 <thoughtpolice> dependencies should end up fairly automatic, yes
04:38:40 <Dynetrekk> thoughtpolice: thanks. seems to work now, though there are some complaints that it can't find my BLAS / LAPACK libraries... :S
04:43:14 <Baughn> @pl \(a,b) -> (b,a)
04:43:14 <lambdabot> uncurry (flip (,))
04:43:39 <ehtom> are any major applications written in haskell?
04:44:21 <mapreduce> darcs, Perl 6.
04:44:43 <mapreduce> @go haskell commercial
04:44:44 <lambdabot> No Result Found.
04:46:03 <mapreduce> http://www.haskell.org/haskellwiki/Haskell_in_industry
04:46:04 <lambdabot> Title: Haskell in industry - HaskellWiki
04:48:17 <ehtom> cool
04:48:29 <nanothief> mapreduce: is Perl 6 really written in haskell? Never knew that (is that a new thing)
04:48:48 <mapreduce> @go pugs
04:48:51 <lambdabot> http://www.pugs.com/
04:48:51 <lambdabot> Title: PugsCom: You have been blocked from entering this site.
04:48:54 <ehtom> thats partially because perl 6 doesn't exist properly yet
04:48:55 <mapreduce> hah
04:49:04 <ehtom> pugs is the closest thing to an implementation
04:49:11 <ehtom> didnt know it was haskell though :P
04:49:18 <ehtom> perl 5 is what most people use
04:49:45 <nanothief> right
04:50:32 <mapreduce> Interesting.  It can compile to JavaScript.
04:50:44 <mapreduce> compile *Perl* to JavaScript, that is.
04:50:57 <ehtom> interesting
04:51:05 <ehtom> wonder how fast it is
04:51:33 <mapreduce> Faster than the imaginary implementations!
04:51:43 <osfameron> yeah, perl and haskell recursively bootstrap each other :-)
04:51:56 <mm_freak> pair x y = \f -> f x y   -- is there any advantage or disadvantage using this as opposed to using a Pair type?
04:51:58 <osfameron> I think the parrot version of perl 6 (called rakudo) is faster than pugs, but less complete
04:52:05 <mapreduce> "Because Haskell is a purely functional language, making the functional code interact with the real world (inputs/outputs and time-driven environment) requires thought. To achieve this, Pugs makes extensive use of monads."
04:52:10 <ozy`> perl 6 is ruby, by popular protest
04:52:16 <mapreduce> To achieve thought?
04:52:20 <mapreduce> Monads achieve thought?
04:53:34 <mapreduce> The author is called Audrey.
04:53:44 * mapreduce tries to get Coronation Street out of his head.
04:54:15 <ehtom> I was only asking because I started using haskell yesterday and wrote a runge kutta implementation which is far neater than ones i've written in C (the C++ ones are neat, but they took a while to code)
04:54:21 <quicksilver> mm_freak: yes.
04:54:27 <ehtom> i'm surprised its not used more
04:54:32 <ehtom> beats java by miles
04:55:06 <mm_freak> quicksilver: enlighten me
04:55:08 <mapreduce> ehtom: What doesn't?
04:55:27 <ehtom> most languages, in reality
04:55:33 <ehtom> although I personally dislike java
04:55:49 <mapreduce> Most mainstream languages are ahead of Java in most ways.
04:55:53 <quicksilver> mm_freak: yes, there is an advantage or disadvantage :)
04:56:08 <mapreduce> But sure, if you say "most languages" you include everyone's toy language.
04:56:22 <quicksilver> mm_freak: Under some circumstances, at least, explicit continuation style is faster as compiled by at least some versions of GHC.
04:56:40 <quicksilver> mm_freak: however most people find it awkward to work with.
04:57:01 * osfameron looks up an misreads "Coroutine Street"
04:57:03 <mm_freak> quicksilver: interesting…  i'd expect the opposite
04:57:16 <ehtom> well, I divide languages into 3 categories: Low (C/C++/asm), High (Java/C#/Haskell), Scripting (Python, Perl, ..._
04:57:28 <mapreduce> ehtom: Where do you put Forth?
04:57:29 <quicksilver> ehtom: scripting is a false category.
04:57:42 <ehtom> I disagree
04:57:52 <quicksilver> then you're wrong :P
04:57:52 <mapreduce> @go oustenhout dichotomy
04:57:54 <lambdabot> No Result Found.
04:57:56 <mapreduce> ffs
04:57:58 <ehtom> Forth died and is currently buried :(
04:58:05 <osfameron> quicksilver++
04:58:07 <quicksilver> python and perl are both used to write large applications.
04:58:14 <quicksilver> so's ruby, indeed.
04:58:15 * mapreduce always types that wrong.
04:58:16 <mapreduce> http://en.wikipedia.org/wiki/Ousterhout%27s_dichotomy
04:58:18 <ehtom> quicksilver: didn't say they weren't
04:58:18 <lambdabot> Title: Ousterhout's dichotomy - Wikipedia, the free encyclopedia
04:58:24 <mapreduce> ehtom: For you.
04:58:25 <mm_freak> IMO there are no "scripting languages" anymore other than shell or special purpose languages
04:58:44 <ehtom> quicksilver: s/Scripting/Dynamic interpreted/;
04:58:51 <ehtom> if it makes you happy
04:58:56 <ozy`> ehtom: where would you put lua (for example) in that categorization?
04:59:05 <mm_freak> ehtom: you can compile them
04:59:07 <quicksilver> ehtom: dynamic interpreted doesn't make me happier, no.
04:59:14 <mapreduce> ehtom: There are two C interpreters in the project I'm working on.
04:59:15 <quicksilver> interpretation is an implementation detail and quite uninteresting.
04:59:22 <quicksilver> dynamically typed, yes.
04:59:30 <quicksilver> that's an interesting distinction to make.
04:59:45 <osfameron> there *are* commonalities to the languages called "scripting languages" beyond dynamism
04:59:55 <ehtom> interpretation is not a detail. I'm trying to talk about real applications
05:00:03 <quicksilver> I'm also talking about real applications.
05:00:04 <mm_freak> btw, i wouldn't place C and C++ on the same level as assembly, though also not on the same level as java/c#/haskell
05:00:07 <ehtom> there is no python compiler at the moment for example
05:00:14 <mm_freak> i prefer to call them middle-level languages
05:00:20 <quicksilver> real applications are quite often written in interpreted languages, ehtom
05:00:23 <ozy`> ehtom: you don't count IronPython et al?
05:00:37 <ehtom> quicksilver: I didn't say they weren't
05:00:44 <mapreduce> ehtom: Being interpreted is not a factor of the language.
05:00:52 <quicksilver> so what did you mean by "interpretation is not a detail. I'm trying to talk about real applications"
05:00:55 <osfameron> and many interpreted languages have a compilation phase (that just doesn't write a separate bytecode file: as with Perl)
05:00:59 <mapreduce> The language is the bits of text you see and what they mean to the tools.
05:01:06 <quicksilver> Java is interpreted.
05:01:07 <thoughtpolice> yeah, you can dump the perl bytecode if you want
05:01:13 <quicksilver> The interpreted language is 'JVM bytecode'
05:01:17 <mapreduce> quicksilver: Java bytecode is interpreted.
05:01:21 <quicksilver> ...although it can be compiled.
05:01:35 <mapreduce> The Java language isn't, despite attempts to write a REPL for it.
05:01:43 <quicksilver> I only say this to amplify the point that interpreted/compiled is not an interesting boundary, if we're talking about real applications.
05:01:54 <ozy`> Java bytecode is JIT compiled in modern JVMs
05:02:01 <quicksilver> type systems are an interesting boundary.
05:02:01 <mapreduce> ozy`: Not all of it.
05:02:08 <thoughtpolice> but yeah, compilation vs. interpretation (and that's not exactly a black and white distinction these days) is just an implementation detail - hugs interprets haskell, for example.
05:02:20 <ehtom> okok, let me try to explain what I mean: C/C++/asm are very fast, Java/Haskell/C#(windows) are fast, python/perl/etc are slow
05:02:27 <mapreduce> JVMs profile running applications to work out what to compile to machine code.
05:02:43 <mapreduce> ehtom: Java and C# start much slower than Python/Perl/etc.
05:02:45 <thoughtpolice> mapreduce: right, hotspot does some real neat runtime performance profiling and feeds it back into the system
05:02:47 <quicksilver> ehtom: wrong.
05:03:06 <opqdonut> ehtom: java, haskell and c# are as fast as C
05:03:09 <Dynetrekk> ehtom: I'm quite sure Java beats the C's in a lot of cases
05:03:15 <ozy`> mapreduce: ah, didn't know that. thought it worked more or less the same way as C#
05:03:18 <quicksilver> ehtom: those speed differences are uninteresting generalisations.
05:03:20 <ehtom> however: python is very easy to code, Java/C# are medium difficulty and C/C++ are annoying to code
05:03:21 <mapreduce> ozy`: It does.
05:03:22 <quicksilver> and quite often not true.
05:03:25 <mapreduce> C# does the same.
05:03:31 <mapreduce> or rather, the CLR.
05:03:43 <thoughtpolice> ozy`: yeah, the amount of work that's gone into hotspot is real impressive
05:03:43 <ehtom> Dynetrekk: ICC vs any JVM, ICC wins...
05:03:47 <quicksilver> there are *particular appications* for which one of them shows a distinct speed advantage.
05:03:55 <quicksilver> but the general picture is complex.
05:04:17 <Dynetrekk> ehtom: well, not on any algorithm. I'd be surprised.
05:04:19 <opqdonut> java is very annoying to code imo ;)
05:04:34 <Dynetrekk> quicksilver: nicely put
05:04:34 <quicksilver> ehtom: that's not true, actually.
05:04:34 <ehtom> java, haskell and c# are not as fast as C/C++... thats just not true
05:04:44 <quicksilver> there are cases where JVM will beat ICC
05:04:49 <thoughtpolice> i am so fucking tired of the 'fast' vs. 'slow' bullcrap, I swear. it goes for anything - people have some general idea scripting is slow, compiled are always faster. likewise, people always for some reason want to think that laziness means things are a lot slower and strictness is always faster
05:04:56 <mapreduce> ehtom: Have you seen the shootout benchmarks?
05:05:01 <thoughtpolice> it's just not something I even remotely care about, anymore
05:05:02 <ehtom> mapreduce: which ones?
05:05:05 <thoughtpolice> when times come I'll pick my tools
05:05:12 <Dynetrekk> thoughtpolice: haha :)
05:05:16 <quicksilver> which is, for example, when the JIT code knows things that the compiler didn't
05:05:18 <thoughtpolice> and be happy with my choice
05:05:28 <quicksilver> things like cache structure, or particular opcodes available on this cpu.
05:05:35 <mapreduce> ehtom: http://shootout.alioth.debian.org/
05:05:36 <lambdabot> Title: The Computer Language Benchmarks Game
05:05:49 <ehtom> mapreduce: which benchmarks, specifically
05:05:50 <mapreduce> gcc will often win there, but not for every case.
05:05:55 <quicksilver> ehtom: it is posible to find programs where haskell, java and C# will outperform c and c++
05:05:55 <ehtom> gcc != icc
05:06:12 <quicksilver> it is also possible to find programs where fortran beats them all.
05:06:15 <ehtom> quicksilver: of course it is, a well coded program is faster than a badly coded one
05:06:17 <ozy`> I wonder how LLVM will change this picture....
05:06:26 <thoughtpolice> Dynetrekk: no joke, it's seriously on my nerves these days...
05:06:39 <osfameron> ndm had a good article on how his supercompiler generated significantly faster code than C for a case (it was a fairly trivial case iirc, but still very exciting)
05:06:52 <ozy`> ehtom: heh, Fortran is better than C for a lot of processor-intensive tasks, in general
05:06:54 <ehtom> thoughtpolice: thats sort of what I was trying to get at... Haskell makes up a gap in my toolset because I dislike C#/Java
05:07:21 <ozy`> Python + Fortran seems to be an increasingly popular combination for various fields
05:07:28 <zeno> hmmm sh bootstrap.sh -> At least the following dependencies are missing: Cabal >=1.4&&<1.5, zlib >=0.4; sai libghc6-cabal-dev -> libghc6-cabal-dev: Depends: ghc6 (< 6.6.1+) but 6.8.2-2ubuntu1 is to be installed
05:07:39 <thoughtpolice> the point I was making is that people have to make meaningless generalizations as if it stands for something and I'm sick of it
05:07:49 <Dynetrekk> thoughtpolice: I see your problem. I'm trying to do numerics though, so performance is more important than most cases. but, if I can use GSL bindings from haskell, I don't have to code fortran or something like that :D
05:08:16 <ehtom> ozy`: python + anything is a very nice combination :P
05:08:23 <daf> I think for most cases, fast enough is good enough
05:08:35 <osfameron> that said, I think it's perfectly human to make categorizations of things: I don't mind if people want to bundle Perl as a "scripting language" as long as they don't include it in blanket things like "it's slow" or "not good for writing real apps"
05:08:36 <thoughtpolice> notably when people (don't) quantify that by simply saying "it is" or "always"
05:08:43 <thoughtpolice> it's not as black and white as people always want to think
05:08:44 <BeelsebobWork> ehtom: you're saying python + something is a nice combination but complaining that Haskell is slow???
05:08:45 <zeno> thoughtpolice: also searching for zlib says i have it installed.  any idea how to resolve?
05:08:50 <daf> i.e. if I write my program in language X and I don't have to spend a lot of effort optimising it to run in a reasonable time, language X is good enough for that task
05:08:56 <ehtom> BeelsebobWork: where did I say haskell is slow?
05:09:01 <thoughtpolice> zeno: with what? cabal install?
05:09:07 <SamB_XP> thoughtpolice: that's only because you bought that fancy CGA adapter!
05:09:17 <mapreduce> ehtom: http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=gcc&lang2=java for example
05:09:18 <quicksilver> python + haskell - python is the best combination
05:09:18 <BeelsebobWork> ehtom: you were complaining about it (along with java and C#) not having the same performance as C code
05:09:19 <lambdabot> Title: C GNU gcc benchmarks | Ubuntu : Intel® Q6600® Computer Language Benchmarks Gam ..., http://tinyurl.com/4v49vq
05:09:28 <daf> Haskell doesn't have to be faster than language Y as long as one doens't have to put a lot of optimisation work in in most cases
05:09:30 <thoughtpolice> SamB_XP: and it is good :]
05:09:34 <ehtom> BeelsebobWork: gah... I did not just say that
05:09:38 <quicksilver> osfameron: but that's exactly what people mean by 'a scripting language'
05:09:44 <quicksilver> osfameron: (or most of them) which is why I object to the term.
05:09:52 <ehtom> BeelsebobWork: I said I split languages (loosely) into those three catagories
05:10:11 <SamB_XP> ooooh
05:10:15 <SamB_XP> I want to learn language Y
05:10:17 <quicksilver> any categorisation which separates C and C++ from Java and C# is a weird one
05:10:19 <SamB_XP> it sounds coool ;-P
05:10:22 <thoughtpolice> quicksilver: yeah, like it implies some sort of innate fragility and uselessness
05:10:38 <quicksilver> the C-like languages are all very very closely related
05:10:40 <SamB_XP> quicksilver: how about "is typically free of segfaults"?
05:10:41 <quicksilver> very similar type systems
05:10:50 <ehtom> BeelsebobWork: I said speed is one of the attributes of those categories, but not the defining factor... at least that is what I was trying to say
05:10:50 <quicksilver> SamB_XP: sure, you can think of differences :)
05:10:56 <mapreduce> The k-nucleotide entry for gcc must really suck, even Smalltalk's beats it.
05:10:56 <quicksilver> I just mean, if you're building broad categories
05:11:00 <daf> see also ““Scripting Language”, My Shiny Metal Arse”
05:11:03 <osfameron> quicksilver: well yes, people *do* use it disparagingly.  But I think of it as being high level, dynamic, great libraries, expressive.  Which are good things (or arguably not, for the dynamic thing, but hey ho)
05:11:04 <quicksilver> then C++ and Java go in the same bucket.
05:11:21 <dreixel> how can I build http://darcs.haskell.org/ghc-6.10/packages/base/ ? `runhaskell setup.hs configure' won't do.
05:11:22 <lambdabot> Title: Index of /ghc-6.10/packages/base
05:11:24 <quicksilver> osfameron: that sounds great. I really don't think that's what 'scripting' implies though :)
05:11:28 <SamB_XP> but I really don't think that "is typically free of segfaults" is a wierd distinction -- I rather like this property ;-P
05:11:29 <mapreduce> quicksilver: I would separate C and C++ from Java and C# by "garbage collected".
05:11:40 <SamB_XP> mapreduce: oh, that too
05:11:40 <quicksilver> mapreduce: "typically garbage collected" ?
05:11:42 <SamB_XP> I like that also
05:11:45 <thoughtpolice> dreixel: trying to build the GHC 6.10 beta?
05:11:50 <quicksilver> it's increasingly common to use GC with C and C++
05:11:57 <SamB_XP> quicksilver: meaning, memory management is not manual
05:12:02 <mapreduce> quicksilver: It might be.  But I've never noticed a project that does so.
05:12:05 <quicksilver> I'd still put them firmly in the same bucket
05:12:05 <ehtom> quicksilver: also, you can't realisically write OS-Level code in java/c#
05:12:09 <daf> SamB_XP: language Y sucks though
05:12:13 <dreixel> well, do I need to build the entire compiler just to build the base package?
05:12:13 <SamB_XP> daf: aww
05:12:14 <quicksilver> mapreduce: firefox is one of the most famous, I guess.
05:12:17 <thoughtpolice> dreixel: you have to issue the regular autoconf-dance, i.e. './configure --prefix=$HOME/ghc-6.10; make; make install'
05:12:18 <SamB_XP> such a waste of a good name
05:12:27 <thoughtpolice> dreixel: oo wait nvm you're talking about base
05:12:28 <SamB_XP> quicksilver: hahahahaha
05:12:35 <zeno> thoughtpolice: yes
05:12:36 <SamB_XP> quicksilver: firefox ... uses a GC?
05:12:37 <quicksilver> SamB_XP: I didn't say it had good GC :)
05:12:38 <osfameron> quicksilver: they're the commonalities of the P-languages perl/python/p...er...ruby/maybe php.  Oh, and pragmatism on coding paradigm including a little FP
05:12:41 <quicksilver> SamB_XP: yes, it does.
05:12:44 <SamB_XP> what FOR?
05:12:53 <quicksilver> same reason we use GC in haskell
05:12:57 <osfameron> and "scripting langauges" is a *little* more descriptive than "P-languages"
05:13:00 <thoughtpolice> zeno: so you have zlib installed? what is the issue?
05:13:00 <quicksilver> so it doesn't have to manage memory manually.
05:13:21 <SamB_XP> so you mean it would use even MORE memory if it didn't ?
05:13:22 <mapreduce> I collect garbage for FF.
05:13:25 <thoughtpolice> dreixel: the base package is tied pretty heavily to GHC itself
05:13:27 * mapreduce restarts Firefox again.
05:13:39 <ehtom> SamB_XP: haha
05:13:42 <quicksilver> ehtom: that is not a language feature, it's an RTS feature
05:13:52 <quicksilver> ehtom: people have written OS-level code in Java and indeed Haskell.
05:13:55 <ehtom> quicksilver: I never said it was a language feature
05:13:59 <dreixel> thoughtpolice: so I have to build the entire compiler?
05:14:04 <quicksilver> I'm not aware of any in C# but I wouldn't be that surprised.
05:14:12 <thoughtpolice> dreixel: yes, lots of changes in GHC affect base and vice versa
05:14:30 <thoughtpolice> dreixel: ask in #ghc to be sure though, but yeah you might have to build the entire compiler
05:14:38 <dreixel> thoughtpolice: thanks
05:14:43 <SamB_XP> thoughtpolice: well, the ones in base that effect GHC ... don't they usually require manual changes to GHC?
05:14:44 <thoughtpolice> dreixel: in particular the base that ships with GHC 6.10 is the new base4 which in particular has the new exceptions
05:14:45 <ehtom> quicksilver: nearly every driver for linux,solaris and windows is written in C, there is a reason for that, primarily that the linux,solaris and windows kernel's are either written in C or export C/C++ interfaces
05:14:51 <vincenz> @seen psykotic
05:14:51 <lambdabot> I saw psykotic leaving #haskell 1d 22h 35m 27s ago, and .
05:14:57 <SamB_XP> thoughtpolice: "the base"?
05:15:03 <vincenz> @tell psykotic What were you curious about in regards to lua?
05:15:04 <lambdabot> Consider it noted.
05:15:09 <thoughtpolice> SamB_XP: the base package :P
05:15:11 <zeno> thoughtpolice: error on bootstrap.sh -> At least the following dependencies are missing: Cabal >=1.4&&<1.5, zlib >=0.4
05:15:15 <mapreduce> ehtom: Generally, try to categorise languages by language rather than by their runtime systems.  Otherwise you're un unsteady ground.
05:15:15 <SamB_XP> thoughtpolice: I'm under the impression that there are two bases that ship with 6.10 ;-)
05:15:29 <thoughtpolice> SamB_XP: well yeah there's base 4.0 and then there's base3-compat
05:15:31 <mapreduce> s/un /on /
05:15:44 <daf> zeno: perhaps the problem is that you have to upgrade your libgch6-cabal-dev at the same time?
05:15:52 <daf> zeno: that's where the conflict is coming from
05:15:55 <thoughtpolice> SamB_XP:  for future reference if the '3-compat' suffix is not attached i am talking about base 4.0 :)
05:15:59 <ehtom> mapreduce: write a big web app in anything other than java? - possible? yes fast? probably realistic? no
05:16:19 <thoughtpolice> zeno: you will have to install cabal 1.4 (http://haskell.org/cabal/) and zlib off hackage, it seems
05:16:19 <lambdabot> Title: The Haskell Cabal
05:16:36 <daf> I don't think that will work
05:16:38 <zeno> thoughtpolice: ok, thanks
05:16:41 <osfameron> ehtom: huh?
05:16:44 * Somni sighs
05:16:46 <Somni> er, ww
05:16:47 <daf> cabal install refuses to install things if they are already installed
05:16:51 <Dynetrekk> anyone here used the "hmatrix" package from cabal before?
05:16:55 <daf> and zeno has the Ubuntu version installed
05:17:00 * osfameron must be imagining the large perl webapps he's been working on
05:17:04 <mapreduce> ehtom: Yahoo uses quite a considerable amount of PHP.
05:17:08 <thoughtpolice> daf: normally I mean build it from source...
05:17:16 <thoughtpolice> i.e. download it and do the classic cabal dance on the source code
05:17:26 <thoughtpolice> i rarely trust package managers for my haskell-related things
05:17:28 <mapreduce> And they're reportedly the biggest site on the web.
05:17:32 <thoughtpolice> (aside from cabal install)
05:17:54 <mapreduce> ehtom: Even if that wasn't true, your point is about runtime systems and therefore not about language.
05:17:55 <thoughtpolice> Dynetrekk: i have it installed i think, trying to find a way to justify messing with it - the homepage has some good intro docs
05:18:02 <ehtom> mapreduce: by large web app I was thinking of something like amazon's website (a large e-commerce engine)
05:18:03 <daf> thoughtpolice: works for me :P
05:18:04 <quicksilver> ehtom: yes.
05:18:14 <zeno> daf: the ubuntu version isnt installed
05:18:16 <daf> thoughtpolice: the Debian packages, at least
05:18:17 <quicksilver> ehtom: that is exactly the reason.
05:18:20 <zeno> wont, in fact
05:18:28 <quicksilver> ehtom: note that the reason is not "Java or Haskell could not be used for this purpose"
05:18:30 <thoughtpolice> daf: on principle I trust none, including macports and pacman :]
05:18:31 <quicksilver> :)
05:18:50 <quicksilver> ehtom: many of the world's largest webapps are written in perl and python
05:18:59 <thoughtpolice> daf: because you never know when it will needlessly pull in dependencies that are actually already installed, because the package manager just goes off what it knows more than what it knows about GHC
05:19:05 <quicksilver> ehtom: meanwhile, many of the worst and slowest are written in Java :P
05:19:08 <mapreduce> ehtom: I don't know the internals of any large e-commerce engines, but the answer is quite irrelevant to how those *languages* are.
05:19:10 <ehtom> I think you mean many of the world's largest webapps use perl or python
05:19:18 <ehtom> e.g. google
05:19:27 <thoughtpolice> (case in point: tried 'port install happy' to install happy, macports thought I didn't have GHC, so it proceeded to build ghc 6.8 when it was in fact, there - i used a .dmg to install)
05:19:39 <quicksilver> ehtom: I mean 'are written in'
05:19:57 <quicksilver> unless you're being pedantic and saying that because there is an HTTP server involved in the flow somewhere, they're written in C.
05:19:59 <Dynetrekk> thoughtpolice: I'm having problems finding some functions in some library... gah...
05:20:08 <mapreduce> Google is a strawman you set up - they use C++ and Java a lot and Python a little.
05:20:18 <quicksilver> it's true that typical deployments involve some C-language server like apache or lighttpd
05:20:31 <thoughtpolice> python is used a lot as internal glue from what I understand
05:20:36 <ehtom> quicksilver: Websphere is extremely fast last time I checked actually... far far faster than any python implementations i'm aware of
05:20:38 <thoughtpolice> but note that youtube is written predominately in python
05:20:46 <mapreduce> quicksilver: And that typical deployments involve some operating system written in C.
05:20:51 <thoughtpolice> and that's a pretty heavy traffic site, even if it is full of shit :]
05:20:56 <ehtom> thoughtpolice: cool, I wasn't aware of that
05:21:00 <mapreduce> Flickr is in python.
05:21:03 <ehtom> thoughtpolice: which python do they use?
05:21:09 <daf> thoughtpolice: sure, mixing different packaging systems is likely to work poorly
05:21:24 <zeno> eve online uses stackless python (but gui is in c++)
05:21:24 <thoughtpolice> ehtom: couldn't tell you
05:21:26 <quicksilver> mapreduce: yes indeed ;)
05:21:37 <quicksilver> ehtom: and that is relevant how?
05:21:45 <quicksilver> websphere is undoubtedly fine at the part that is its job.
05:21:50 <ehtom> quicksilver: you said java is slow for web stuff :P
05:21:54 <quicksilver> no, i didn't.
05:22:03 <ehtom> I dislike java too, but it isn't slow anymore
05:22:09 <quicksilver> I said many of the worst and slowest webapps were written in java.
05:22:18 <quicksilver> I didn't say this was *because* they were written in java; it isn't.
05:22:21 <ehtom> oh ok, thats a fair point
05:22:22 <osfameron> I've heard very good things about... "cricket"? - some java framework for component/event-based web stuff
05:22:36 <ehtom> many are coded in java because CS students learn java
05:22:36 * thoughtpolice --away --reason=breakfast
05:22:41 <sclv> wicket
05:22:47 <ehtom> rather than it being the right language for the job
05:22:52 <daf> osfameron: oh, I think Google used that for some of their XMPP stuff
05:23:21 <daf> osfameron: I got a bad impression of it because it always turns up in backtraces of code in infinite loops
05:23:23 <mapreduce> wicket seemed quite nice, I just couldn't be bothered learning how to configure Tomcat.
05:23:46 <mapreduce> I used it from Scala just to try it out.
05:23:51 <ehtom> tomcat is amazing... uses 50% of my memory no matter what its doing
05:24:03 <jeffz> from what I remember, Tomcat wasn't that hard to configure or use, especially with maven for deploying things
05:24:05 <mapreduce> You should see how much your OS uses!
05:24:13 <quicksilver> ehtom: most major websites are notably noncommunicative about what platform they use.
05:24:15 <osfameron> daf: ah, that's not nice!  I have to admit you very often see nasty stacktraces of Java code on the web.  (This may be a good tihng, as it shows they care about error reporting)
05:24:34 <mapreduce> jeffz: Maven and Tomcat both seem to struggle if you're doing anything the authors haven't thought of before.
05:24:35 <quicksilver> ehtom: lovefilm.com is one of the large ones prepared to admit it's using perl.
05:24:43 <ehtom> quicksilver: yeah, can usually find out with digging though
05:25:13 <sclv> bbc users perl i thought.
05:25:16 <ehtom> amazon and ebay are mentioned as case studies for websphere somewhere I think
05:25:19 <sclv> s/users/uses/
05:25:20 <jeffz> mapreduce: dunno, I didn't really spend much time with them, wrote half a dozen servlets and then buried it.
05:25:22 <ehtom> bbc probably uses asp
05:25:25 <osfameron> bbc uses some perl, as does guardian
05:25:29 * jeffz suspects ehtom is trolling, even if he isn't conscious of it.
05:25:30 <quicksilver> ehtom: Venda are a perl shop; http://www.venda.com/pcat/customers
05:25:32 <lambdabot> Title: Customers at Venda
05:25:40 <quicksilver> gives some idea of which websites they might be behind.
05:25:47 <ehtom> jeffz: i'm really not trying to
05:25:52 <quicksilver> amazon is mostly j2ee for its core systems
05:25:57 <quicksilver> but I believe it was not always so.
05:26:20 <mapreduce> Haskell is faster than C.
05:26:26 <jeffz> languages have no speed
05:26:31 <mapreduce> Open a Haskell file, open a C file, and scroll to the bottom of each.
05:26:38 <mapreduce> It will take less time in the Haskell file.
05:26:53 <osfameron> mapreduce: is that opening the file in yi or vi?
05:27:00 <mapreduce> emacs, of course.
05:27:25 <ehtom> well, emacs vs vi... yeah...
05:27:32 <jeffz> mapreduce: should take the same time if you use M-x end-of-buffer
05:27:38 <jeffz> mapreduce: subjectively, anyhow
05:27:44 <mapreduce> jeffz: I said "scroll".
05:28:04 <mapreduce> ehtom: emacs beats vi hands down.  vim might be another matter.
05:28:16 <sclv> jeffz: we're not interested in "subjective" definitions of language quality. the public demands unimpeachable metrics!
05:28:38 <jeffz> mapreduce: that's how emacs users "scroll" to the end of a buffer
05:28:49 <mapreduce> jeffz: I'd call that jumping, or going.
05:29:01 <mapreduce> Scrolling implies some motion.
05:29:29 <ehtom> doesn't scrolling in emacs require hardware acceleration though </emacsvsvimtrollwar>
05:29:41 <Dynetrekk> how to check if function bob is in module alice from the prelude?
05:29:54 <Dynetrekk> or, maybe, list functions in module alice from the prelude....
05:30:11 <mapreduce> "(goto-char (point-max)) is faster and avoids clobbering the mark." :)
05:30:53 <sclv> I have meta-control x g p m @^(! bound to just that command.
05:31:06 <ehtom> anyway, back to learning haskell :P
05:31:08 <Twey> As a vimmer who's recently learnt emacs and liking it, I'm not quite sure where to stand on this one.
05:31:14 <mapreduce> Twey: Over there.
05:31:16 * Twey does a balancing act on the fence.
05:31:21 <Twey> Heh
05:31:48 <sclv> Dynetrekk: maybe you want ":browse" in GHCI?
05:32:07 <Dynetrekk> sclv: cool :)
05:32:16 <quicksilver> Dynetrekk: the prelude doesn't really have module alice
05:32:17 <Dynetrekk> a bit fast though :P
05:32:24 <quicksilver> Dynetrekk: the prelude is just one module.
05:32:29 <Dynetrekk> quicksilver: alice is just a variable
05:32:32 <quicksilver> (called 'Prelude')
05:32:35 <quicksilver> yes, but you said "module"
05:32:41 <quicksilver> the Prelude doesn't have any other modules
05:32:44 <quicksilver> that's what I'm trying to say ;)
05:32:46 <Dynetrekk> quicksilver: but, from the prompt I mean...
05:32:50 <Dynetrekk> quicksilver: yeah, sure
05:32:52 <quicksilver> I recognised your meta-syntactic variable fine.
05:33:14 <quicksilver> I recommend running ghci in emacs and then using :browse, personally
05:33:17 <Dynetrekk> quicksilver: nice. is your intelligence artificial to enable this impressive recognition algorithm? :)
05:33:32 <quicksilver> then you have reverse-incremental-search
05:33:47 <quicksilver> I use lots of ":b" and ":i" when exploring unfamiliar haskell APIs
05:34:15 <quicksilver> Dynetrekk: it has been stated before that I am a bot, yes.
05:34:28 <Dynetrekk> quicksilver: indeed.
05:34:40 <Twey> While we're on emacs, how's haskell-mode coming along?  And does it work with xemacs?
05:34:42 <Axman6> a very personable one though
05:34:51 <Dynetrekk> quicksilver: I don't like emacs though. it hurts my <whatever>
05:35:17 <Twey> ... I would like to take that question back, it is in fact included with xemacs
05:35:29 <jeffz> Twey: isn't xemacs dead?
05:35:46 <quicksilver> I believe xemacs has no advantages, currently.
05:36:15 <Twey> It has the advantage of allowing me to attach to a session from screen and X at the same time
05:36:15 <quicksilver> Dynetrekk: that's your perogative. Having said that, I'm not aware of any alternative.
05:36:32 <quicksilver> Twey: gnu emacs has that now, has done for quite a while.
05:36:38 <Dynetrekk> quicksilver: text editors? there are loads. though I must admit, emacs has an impressive/depressive feature list
05:36:39 <Twey> Which FSF 23 should theoretically do but fails dismally
05:37:02 <redocdam> is there any o(1) operation for size of lists?
05:37:02 <Twey> quicksilver: Quite a while?  According to #emacs it's only supported in CVS
05:37:06 <quicksilver> Dynetrekk: the ability to run the interpreter in a buffer and copy-paste between that and your file easily, get easy search of the lengthy output from :browse, etc.
05:37:12 <Twey> (tests bear this out)
05:37:24 <redocdam> I mean size of one list
05:37:25 <Twey> redocdam: No
05:37:30 <Dynetrekk> redocdam: yep, storing the length of the list. I think java's arraylist does this, for example
05:37:33 <Twey> Still no :)
05:37:38 <quicksilver> Twey: ok, I could be wrong. certainly that feature is a long time coming then ;)
05:37:49 <Twey> quicksilver: Indeed
05:37:57 <Dynetrekk> quicksilver: in haskell, you mean? I guess you are right.
05:38:16 <quicksilver> Dynetrekk: that kind of integration is why I find emacs a useful tool.
05:38:26 <quicksilver> being able to use all the same keybindings in ghci as I can in source code, etc.
05:38:28 <Twey> quicksilver: 22 will let you connect to a console from another console, or between one X window and another, but not mix and match.  23 is meant to do it, but currently breaks horribly when I try (apparently Unicode's to blame)
05:38:32 <quicksilver> not wishing to start a flamewar.
05:38:45 <redocdam> could it be easily incorporated? By doing what Dynetrekk? Changing the code for lists?
05:38:48 <Twey> This is #haskell, no flamewars going to happen here
05:39:01 <Axman6> yay, i've made a turing machine that can add 1! :o
05:39:09 <zeno> data o1list a = O1List { size :: Int, list :: [a] }
05:39:39 <Twey> Dynetrekk: You can create your own type that does that fairly easily, but it's then no longer a list, and you'll have to rewrite the standard list functions to work with it (or unwrap it and rewrap it when passing it to them)
05:39:40 <inimino2> redocdam: given that Haskell lists can be infinite, it would have to be a significant change
05:39:45 <Dynetrekk> redocdam: in haskell I don't know. but in an OO language it should be easy to extend a class etc
05:40:13 <Dynetrekk> Twey: OO for the win in this case then :)
05:40:19 <Twey> Aye, and you'd lose the laziness advantages and end up with what's basically an Array
05:40:37 <inimino2> right
05:40:45 <Dynetrekk> Twey: sure. the man didn't ask if it was  a great idea :)
05:40:49 <Twey> (but slower)
05:40:58 <Twey> Aye :)
05:41:11 <redocdam> maybe I'm doing things wrong
05:41:30 <Twey> Quite likely
05:41:33 <zeno> inimino: is there a typeclass you can implament to get ++ and stuff?
05:41:43 <quicksilver> redocdam: depends what your objective is.
05:41:44 <Twey> :t (++)
05:41:45 <lambdabot> forall a. [a] -> [a] -> [a]
05:41:51 <Twey> zeno: No.
05:41:53 <inimino2> zeno: No
05:42:01 <quicksilver> redocdam: if you want O(1) size and various other efficient operations, maybe Data.Sequence is a better match for your problem?
05:42:05 <inimino2> you could create your own though
05:42:19 <quicksilver> redocdam: if you want O(1) size and the data never changes, maybe Array is a better match.
05:42:21 <Twey> But you'd have to rewrite them all.
05:42:26 <inimino2> yes
05:42:40 <Twey> Or, your class could have a toList function
05:42:53 <Twey> But that involves some converting
05:43:12 <BeelsebobWork> guh
05:43:20 <BeelsebobWork> getting hs-plugins to work in the latest 6.9 is painful
05:43:24 <zeno> Twey: arnt lists superoptimized under the hood though? So rewriting functions might lose speed
05:43:51 <quicksilver> if you're using ++ a lot, that might be a sign that you want Data.Sequence
05:43:53 <quicksilver> (or DList)
05:43:54 <Twey> zeno: By 'rewrite' I mean 'write a thin wrapper that gets the internal list and passes it along'.
05:44:00 <redocdam> http://pastebin.com/d3abe25b6
05:44:02 <inimino2> you could just wrap the native list and you'd have a strict list that knows it's own length
05:44:10 <inimino2> s/it's/its/
05:44:15 <redocdam> I don't want to pass along the size of the graph
05:44:33 <redocdam> but I also dont' want to count the size of the vertexlist
05:44:43 <redocdam> but then I guess I'm screwd anyways
05:44:57 <BeelsebobWork> redocdam: storing the vertex index both in the array and the vertex looks rather dangerous there btw
05:44:59 <quicksilver> redocdam: how long do you estimate your lists are?
05:45:41 <Twey> redocdam: Why is it Vertex Int [Int] [Char]?
05:45:54 <Twey> Surely a vertex can only have one co-ordinate per dimension?
05:46:00 <redocdam> index neighbours name
05:46:09 <redocdam> adjecency lists
05:46:12 <quicksilver> redocdam: if it's less than 10k, I would just use length and forget about the problem.
05:46:13 <redocdam> list
05:46:27 <zeno> what would be good for arrays/lists ~300 long, where i need to access a lot, but copy about 1/10th of the time?  arrays or lists?
05:46:28 <Twey> Oh ah.
05:46:31 <quicksilver> a one-off call to length at array creation time is only a one-off O(n) hit on an operation which is O(n) anyway.
05:46:50 <Twey> zeno: Random or sequential access?
05:47:09 <zeno> Twey: nonrandom indexes
05:47:18 <redocdam> can arrays grow?
05:47:26 <inimino2> sequential?
05:47:38 <BeelsebobWork> redocdam: only by copying them
05:47:40 <Twey> zeno: 'Random' in this case means 'not starting with the first element and working along' :)
05:47:52 <zeno> Twey: random then sorry :)
05:48:00 <Twey> Then you want an Array
05:48:01 <redocdam> I just got to say, I like Haskell better than Ocaml
05:48:17 <zeno> allright thanks.
05:48:28 <redocdam> glad I don't have to deal with that mess anymore
05:48:42 <zeno> redocdam: why? (never used ocaml jsut curious)
05:48:54 <Dynetrekk> complex numbers in Haskell anyone?
05:49:07 <redocdam> it just has everything, OO modules imperative features etc
05:49:13 <BeelsebobWork> Dynetrekk: Data.Complex
05:49:17 <redocdam> too much stuff in the language
05:49:25 <Dynetrekk> BeelsebobWork: that easy :P
05:49:33 <BeelsebobWork> yes, yes it is
05:49:38 <BeelsebobWork> that's my point :P
05:49:51 <redocdam> zeno, it was just to messy in my opinion
05:50:06 <zeno> redocdam: doesnt haskell have modules? and imperitive stuff (using IO or State)?
05:50:31 <Dynetrekk> BeelsebobWork: cool
05:50:35 <redocdam> zeno, as I understand it, it is purely functional?
05:50:38 <BeelsebobWork> zeno: most people would argue that Haskell doesn't have imperative stuff, it merely has functional stuff that produces an imperative program that the runtime runs
05:50:52 <BeelsebobWork> I would argue that if you're gonna argue that, you might as well be writing C pre-processor code
05:50:54 <quicksilver> zeno: haskell is pure in a way ocaml isn't.
05:51:04 <quicksilver> zeno: in ocaml, a function of type "a -> b" can do IO
05:51:10 <quicksilver> zeno: in haskell it can't. That's the key difference.
05:52:02 <BeelsebobWork> @let f x = seq (unsafePerformIO launchMissiles) $ show x
05:52:03 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
05:52:17 <thoughtpolice> unless you unsafePerformIO stuff and things go bad :[
05:52:25 <quicksilver> unsafePerformIO is not part of haskell.
05:52:29 <Twey> xemacs + haskell-mode + font-lock = (15) (warning/warning) Error caught in `font-lock-pre-idle-hook': (wrong-type-argument markerp nil)
05:52:31 <thoughtpolice> just sayin'
05:52:43 <quicksilver> (in the spirit that my comments were intended, at least)
05:52:44 <Twey> :(
05:52:57 <quicksilver> there are various other trivial but annoying issues with ocaml too.
05:53:03 <thoughtpolice> zeno: for the IO monad part of things, i suggest you check out http://haskell.org/haskellwiki/IO_inside
05:53:04 <lambdabot> Title: IO inside - HaskellWiki
05:53:08 <BeelsebobWork> quicksilver: that is a little false -- I think anyone here will refer to ghc haskell rather than H98 when saying "haskell"
05:53:11 <zeno> quicksilver: ah i think i get it now.  the difference in haskell is that doing IO requires the function being of the IO type, but ocaml doesnt
05:53:15 <quicksilver> the value restriction, constructors-aren't-functions
05:53:22 <quicksilver> BeelsebobWork: I am quite aware that I am inconsistent.
05:53:28 <BeelsebobWork> :D
05:53:34 <quicksilver> BeelsebobWork: but there are reasons for the dewfinitions I choose, when I choose them.
05:53:37 <Twey> BeelsebobWork: It's still kind of 'not Haskell' IMO
05:53:47 <quicksilver> that language which I choose to recommend to people, does not include unsafePerformIO.
05:53:48 <zeno> how is unsafePerformIO different than IO?
05:53:48 <thoughtpolice> zero: right, declare the occurrence of effects with the type system
05:53:56 <redocdam> BeelsebobWork, you took what I was doing quite fast I must  say
05:54:00 <BeelsebobWork> zeno: unsafePerformIO :: IO a -> a
05:54:02 <Twey> It's... an escape from Haskell, for FFI and special things
05:54:14 <Twey> It's not really meant to be used in everyday programming
05:54:15 <thoughtpolice> zeno: it is the only way to break purity, because otherwise everything in haskell (including the IO monad) is purely functional
05:54:17 <BeelsebobWork> i.e. it relies on you to verify the purity of your IO code
05:54:59 <zeno> hmmm when would you NEED that?  I thought the whole point of IO was that you coudlnt get out
05:55:14 <thoughtpolice> zeno: it can allow you to write for example, 'readFile :: String -> String' instead of having to have 'readFile :: String -> IO String'
05:55:27 <thoughtpolice> zeno: it can be pretty useful sometimes
05:55:43 <quicksilver> zeno: it's mostly a hook for extending the language.
05:55:44 <thoughtpolice> but only when you can ensure that using it doesn't "leak" the fact that it is in reality non-pure
05:55:53 <quicksilver> it's occasionally a hack for lazy people.
05:55:59 <thoughtpolice> ex: bytestring uses unsafePerformIO under the hood
05:56:08 <BeelsebobWork> zeno: an example -- I have a purely functional program that identifies the position of a bug in some code... at the end of it, I want the identification string to include the faulty part of the program... this can easily be implemented neatly by verifying for myself that readFile "theProgram" will happen only once
05:56:11 <thoughtpolice> but retains a purely functional interface
05:56:22 <thoughtpolice> although there are functions for example in Data.ByteString.Unsafe
05:56:25 <thoughtpolice> that are not pure
05:56:57 <BeelsebobWork> similarly, Data.Unamb uses unsafePerformIO to race two pure computations against each other, and return a pure value
05:57:40 <thoughtpolice> like unsafeUseAsCString - if you modify the returned CString you in turn modify all the copies of it, breaking referential transparency
05:58:07 <wjt> what's the point of unamb?
05:58:45 <BeelsebobWork> wjt: it lets you implement things like reactive
05:58:56 <BeelsebobWork> or it lets you implement (&&) in a properly lazy way
06:00:08 <zeno> this is lazy? && a b = if a then b else False
06:00:22 <thoughtpolice> zeno: for the most part you can pretty much shy away from unsafePerformIO because when used improperly all kinds of things can happen
06:00:23 <BeelsebobWork> not as lazy as it should be
06:00:33 <bd_> > False && undefined
06:00:34 <lambdabot>   False
06:00:42 <BeelsebobWork> > undefined && False
06:00:43 <lambdabot>   mueval: Prelude.read: no parse
06:00:44 <lambdabot>  mueval: *** Exception: Prelude.undefined
06:00:52 <bd_> BeelsebobWork: it can't be lazy on both sides
06:00:58 <BeelsebobWork> it can be if you use unamb
06:01:03 <bd_> unamb?
06:01:14 <BeelsebobWork> x && y = (x `land` y) `unamb` (y `land` x) where land False x = False; land True x = x
06:01:15 <zeno> > if False then undefined else True
06:01:17 <lambdabot>   True
06:01:18 <bd_> ... ah
06:01:19 <dblazakis> :t unamb
06:01:19 <lambdabot> Not in scope: `unamb'
06:01:28 <bd_> clever
06:01:34 <Axman6> hmm, what is :check supposed to do in ghci?
06:01:39 <bd_> but what if the bottom in this case is an explosion in C code? :)
06:02:02 <BeelsebobWork> bd_: then it'll run until the non-bottom gets evaluated, which may or may not be never
06:02:13 <BeelsebobWork> interesting point
06:02:25 <BeelsebobWork> actually no
06:02:28 <BeelsebobWork> both get demanded
06:02:32 <zeno> @src land
06:02:32 <lambdabot> Source not found. Are you on drugs?
06:02:34 <BeelsebobWork> so it will terminate if one terminates
06:02:44 <bd_> BeelsebobWork: can it stop infinite loops?
06:02:54 <bd_> and/or memory allocation loops
06:03:10 <BeelsebobWork> bd_: it runs each computation in a seperate thread, so as long as both aren't infinite loops one will eventually terminate
06:03:15 <quicksilver> it can stop memory allocation loops on a dual core
06:03:27 <quicksilver> I mean 'non-memory-allocation' loops, sorry
06:03:40 <quicksilver> with only one OS thread it probably can't.
06:03:52 * BeelsebobWork checks
06:04:01 <bd_> ah, it uses killThread, I see
06:04:15 <quicksilver> actually the killThread is superfluous as far as I know
06:04:22 <quicksilver> it might make the thread die a bit earlier in some cases.
06:04:23 <bd_> quicksilver: even on dual core, will the non-memory-allocation loop ever receive the execption?
06:04:25 <BeelsebobWork> quicksilver: it is, but it's more efficient
06:04:37 <quicksilver> bd_: it will get garbage collected, eventually.
06:04:40 <quicksilver> bd_: I believe.
06:04:51 <bd_> hmm, I thought that'd never enter the GC...
06:05:04 <quicksilver> I'm not sure, actually.
06:05:14 <quicksilver> maybe a non-allocating thread can block the entire RTS permanently.
06:05:29 <quicksilver> fortunately they're quite hard to write ;)
06:05:34 <BeelsebobWork> heh
06:17:45 <ski> how does unamb check equality ? pointers ?
06:20:07 <wjt> So, GHC can't deal with let Foo x = ... when Foo is existentially quantified (cf. http://hpaste.org/10628 ); any particular reason why not?
06:20:41 <ozy`> hmm, yi finally compiled, but now it's complaining about ~/.yi/yi-powerpc-darwin ....
06:21:36 <Axman6> ozy`: powerbook?
06:21:41 <ozy`> Axman6: yep
06:22:01 * ski idly wonders whether existentially-quantified constructors can be unpacked in list comprehensions ..
06:22:09 <ozy`> heh, I bet nobody's built/tested it on PPC in a year :p
06:22:15 <Axman6> i'm pretty impressed i guess that correctly, with a pretty high degree of confidence :P
06:22:24 <Axman6> guessed*
06:22:31 <quicksilver> wjt: because let bindings are recursive
06:22:49 <quicksilver> wjt: which would enable the existentially qualified bit to escape.
06:23:01 <quicksilver> there is no reason, in pricniple, why it couldn't be allowed for a non-recursive let.
06:23:04 <wjt> could you give an example?
06:24:08 <quicksilver> wjt: let Foo x = f y; Foo y = f x
06:24:18 <quicksilver> wjt: recursive dependency between existentials oop!
06:24:29 <wjt> i don't really see why this is so bad
06:24:32 <wjt> does it break inference?
06:24:34 <quicksilver> think it through
06:24:38 <quicksilver> it doesn't mean anything
06:24:48 <quicksilver> how do you construct the output of one 'f'?
06:25:21 <wjt> ditto let x = f y; y = f x
06:25:39 <quicksilver> that means something.
06:25:41 <quicksilver> it means fix f
06:26:03 <quicksilver> > let f = (1:); x = f y; y = f x; in x
06:26:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:26:10 <wjt> hmm
06:26:14 <quicksilver> but you can't fix an existential constructor.
06:26:22 <wjt> ah!
06:26:35 <ski> why ?
06:27:32 <quicksilver> ski: well, that is a question I cannot answer.
06:27:55 <quicksilver> ski: I suspect it doesnt lie in FC.
06:28:51 <quicksilver> of course, it's not fixing an existential constructor
06:28:53 <quicksilver> it's the dual to that
06:28:57 <quicksilver> fixing the existential itself.
06:28:59 <wjt> ah, i see, having written down some types
06:29:15 <ehtom> is there a page of leeto examples like rungekuttas = initvalue : [nextrunges yn n timestep | (yn,n) <- zip rungekuttas [0,1..] ]
06:29:33 <quicksilver> wjt: so, it's a good question to ask. And for all I know there *is* a way to make it meaningful.
06:29:42 <quicksilver> wjt: but you can now see why it's a bit different from what GHC normally does
06:29:50 <quicksilver> so it would represent some kind of type inference extension
06:29:53 <super> anyone know where i can obama vs mccain standings?
06:29:55 <quicksilver> and I'm not sure what it would mean.
06:29:56 <ski>   f :: forall a. a -> Something
06:29:57 <ski>   data Something = forall a. S a
06:30:05 <super> what languages do you think theyd use if they had to program?
06:30:18 <quicksilver> american.
06:30:23 <ehtom> lol
06:30:30 <super> mccain = java. obama = python
06:30:45 <ehtom> no, more like mccain = obama = brainfuck
06:30:56 <ehtom> or cobol or something
06:30:59 <super> bush = brainfuck
06:31:06 <mattam> quicksilver: you mean that would force x and y's types to be the same here but the inference engine can't handle that?
06:31:20 <wjt> or at least, i think i see: i can't find any way to make sense of it without coercing x and y in ways i can't justify
06:31:46 <ski> wjt : what about my example just above ?
06:32:15 <Axman6> heh, i found out a while ago that when the built the snowy river hydro electric scheme here, they had a computer comissioned for calculations of vasious things. They named it SNOBOL
06:32:29 <ozy`> ehtom: eh, obama at least conveys some degree of willingness to understand technology from the point of view of an engineer, rather than a CEO
06:32:55 <wjt> ski: in that case it makes sense because you don't want to have any information at all about the type wrapped in an existential, but if you have any constraints on it you have no way to figure out which dictionary to use
06:33:42 <ehtom> well, ok maybe that was a little harsh... mccain = brainfuck, obama = basic 0.1 alpha
06:34:10 <quicksilver> wjt: not all existentials have dictionaries.
06:34:19 <quicksilver> wjt: nonetheless I like the intuition there.
06:35:04 <quicksilver> the way I think of it is that "f" might require a dictionary, but if the not is tied, nothing is providing a dictionary.
06:35:04 <mattam> Weak existentials like those are generative. I think that's the only point.
06:35:15 <quicksilver> mattam: what does that mean?
06:35:43 <wjt> quicksilver: well, that's the best justification i can come up with: either you can't find a type for x and y apart from forall a . a which is useless, or you want it to be an instance of something, in which case you've got some kind of ouroboros dictionary problem
06:36:18 <mattam> That means each call to f generates another instance of the existential that can't be related to the others.
06:36:43 <quicksilver> mattam: *nod*
06:37:14 <mc__> Whats wrong with this? http://pastebin.com/m6c403499
06:37:23 <ski>   f :: forall a. Show a => a -> Showable
06:37:25 <ski>   data Showable = forall x. Show x => S x
06:37:46 <ski> seems to me `let S x = f y; S y = f x in show x' would work, to me
06:37:53 <ski> (s/, to me//)
06:37:56 <mc__> ski: was that ment to me? (the forall thing)
06:38:31 <ski> mc__ : no, to wjt(,quicksilver,mattam)
06:38:55 <mc__> ah, alright
06:38:58 <pcc1> what might cause an error message from happy: "No closing '}' in code segment" where the quoted line number is half way through a code segment (which is terminated by '}')
06:39:06 <ski> mc__ : you need to say `getUserInput :: IO (Int, Int)' since you do I/O
06:39:49 <mattam> On the other hand, if you had strong existentials like in type theory you could project out the type of the existential without "opening it" and relate different instances.
06:39:56 <ski> mc__ : if you perform I/O in some computation (whether directly or indirectly), you need to have `IO' somewhere in the result type (either directly in the type, or indirectly, hidden inside some other type)
06:39:58 <mc__> ski: I had it like that before but it didnt wokr either
06:40:16 <ski> mc__ : also, you need to prefix the last line with `return '
06:40:38 <mc__> ski: yeah, that was it, thank you!
06:41:04 <ski> since the last line is to have the same type as the whole `do'-block .. namely `IO ...' .. and your `(...,...)' has type `(a,b)' for some types `a',`b'
06:41:30 <ski> `return' converts a plain value into an action that will do nothing but return this value
06:41:49 <wjt> ski: where is the call to show going to get its Show dictionary from?
06:42:46 <ski> (note that `return' will *not* stop execution in a `do'-block, like `return' in C,Java,et.c. does .. here `return' is just an ordinary function that converts a value into an action (which is a kind of value) which when performed will yield the given value)
06:43:04 <ski> wjt
06:43:23 <ski> consider passing around the dictionary explicitly
06:43:40 <ski>   data Showable = forall x. S (ShowDict x) x
06:43:40 <sheyll> bye
06:43:55 <ski>   f :: forall a. ShowDict a -> a -> Showable
06:44:11 <ski> so
06:44:13 <ski>   let S x = f y; S y = f x in show x
06:44:14 <ski> becomes
06:44:34 <ski>   let S xDict x = f yDict y; S yDict y = f xDict x in show xDict x
06:44:48 <ski> (note that `x' and `y' are not known to have the same type)
06:45:01 <ski> so, this seems to me to be just a case of tying-the-knot
06:45:33 <mattam> If [f] is polymorphic like this I guess there's no problem.
06:45:48 <ski> if `f yDict y' can compute some information about `xDict' and `x' without looking at `yDict',`y', i think this could be non-bottom
06:46:09 <ehtom> isn't do - return just to hide a massive load of monad joining together operations?
06:46:20 <ski> (well, we have no idea what type `x' actually have, so we can only pass it polymorphically)
06:46:25 <mattam> ehtom: yes.
06:46:31 <ski> ehtom : `do' is, yes
06:46:55 <ski> (`return' is just as much (or as little) needed with or without `do'-notation)
06:47:15 <wjt> ski: honestly, i'm out of my depth
06:48:32 <BeelsebobWork> ehtom: the rules for do are do {x; stms} = x >> do stms, do {a <- x; stms} = x >>= \a -> do stms and do expr = expr
06:48:37 <BeelsebobWork> IIRC
06:48:46 <ski> wjt : have you seen examples of "circular programming" like this .. like e.g. `repMin' which replaces every element of a binary tree with the smallest element, in only one traversal ?
06:49:02 <wjt> i have
06:49:12 <wjt> existentials make my head hurt though :)
06:49:18 <ski> ok
06:54:36 <quicksilver> ski: I recall some comment from SPJ on this topic but I can't find it now
06:57:08 <BeelsebobWork> repMin x = let (m,rt) = repMin' x m; repMin' (Leaf x) m = (x,Leaf m); repMin' (Branch x y) m = (let (mx,rx) = repMin' x m; (my,ry) = repMin' y m in (min mx my, Branch rx ry) -- this?
06:58:00 <hackage> Uploaded to hackage: BerkeleyDBXML 0.1
06:59:09 <ozy`> Axman6: you up for writing auto-indent hook scripts for textmate? (if you don't have any already... :p)
06:59:42 <ski> BeelsebobWork : yes (bar a missing closing paren)
06:59:58 <Axman6> ozy`: if in knew how to, i might be?
07:00:08 <BeelsebobWork> ski: oh, so I do
07:00:14 <ozy`> all right, no worries :p
07:00:35 <Axman6> would it be frustrating? because if it is, i've had enough frustration tonight (MBP's keyboard and trackpad just died)
07:00:43 * ski thinks replacing every element with the difference of that element and the mean to be a slightly more "practical" variation
07:04:51 <zachk> does ghc compile for ARM?
07:05:01 <quicksilver> no.
07:05:34 <quicksilver> it principle it wouldn't be impossible to hack something together with -fvia-C but it's not a trivial endeavour
07:08:33 <shepheb> zachk: jhc can output portable C you can run through an ARM (cross-)compiler
07:08:50 <shepheb> also, I've looked into porting all of GHC to ARM (it doesn't cross compile)
07:09:16 <BeelsebobWork> a few people are working on a GHC ARM port I thought
07:09:26 <zachk> im looking at hbc but chalmers ftp seems down
07:09:40 <shepheb> http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc  documents my attempts
07:09:43 <lambdabot> Title: ArmLinuxGhc - GHC - Trac
07:09:56 <zachk> i just started asking about it cause of this http://beagleboard.org/
07:09:59 <BeelsebobWork> zachk: http://www.cs.chalmers.se/~augustss/hbc/hbc.html <-- working for me
07:10:04 <lambdabot> Title: BeagleBoard.org - default
07:10:04 <lambdabot> Title: The HBC compiler
07:10:08 <BeelsebobWork> oh, ftp, my bad
07:10:29 <BeelsebobWork> zachk: yeh there's a lot of people with new nokia phones/iPhones that are interested
07:11:16 <quicksilver> zachk: hugs on ARM is apparently fairly easy to arrange.
07:11:22 <quicksilver> hugs is quite portable C.
07:12:08 <zachk> i never liked hugs, i tried it a few years ago and it turned me off to haskell
07:12:13 <shepheb> yeah, see haskell-cafe, someone compiled hugs for the iPhone
07:12:45 <shepheb> anyway, if you want to look at that Trac page and work on it, I'd love the help.
07:15:10 <oal> hello
07:15:23 <ski> zachk : i think chalmers ftp been in non-functional state awhile .. there's some builds at <http://www.cs.chalmers.se/pub/haskell/chalmers/> .. or were you looking for source ?
07:15:39 <oal> I am building ghc-6.8.3 on a shiny x86_64 box and I have a problem
07:16:01 <oal> ./configure says
07:16:03 <oal> checking for path to top of build tree... /tmp/ghc28573_0/ghc28573_0.s: Assembler messages:
07:16:03 <oal> /tmp/ghc28573_0/ghc28573_0.s:135:0:
07:16:03 <oal>      Error: suffix or operands invalid for `push'
07:16:03 <oal> /tmp/ghc28573_0/ghc28573_0.s:176:0:
07:16:03 <oal>      Error: suffix or operands invalid for `push'
07:16:04 <oal> /tmp/ghc28573_0/ghc28573_0.s:670:0:
07:16:04 <zachk> a build just to mess around with it
07:16:06 <oal>      Error: suffix or operands invalid for `push'
07:16:08 <oal> /tmp/ghc28573_0/ghc28573_0.s:721:0:
07:16:10 <oal>      Error: suffix or operands invalid for `push'
07:16:12 <oal> ./configure: line 2664: utils/pwd/pwd: No such file or directory
07:16:14 <oal> configure: error: cannot determine current directory
07:16:17 <oal> sorry for the long paste
07:16:17 <EvilTerran> oal, please use a pastebin
07:16:29 <oal> ok
07:17:19 <ndmitchell> oal, you might want to try the 6.10 beta that came out last week - i remember that bug being fixed
07:19:08 <oal> ndmitchell, ok, thanks, I'll try it
07:19:24 <oal> to make it worse, we have a hacked version of ghc, which also fails to build
07:19:39 <oal> ./configure log is here
07:19:42 <oal> http://hpaste.org/10630
07:22:02 <oal> 6.10 beta fails just the same way
07:22:11 <oal> next try: HEAD
07:23:06 <ndmitchell> oal, no - if the beta fails, email cvs-ghc@haskell.org
07:23:30 <ndmitchell> 6.10 beta is very close to head, and they will want to fix beta bugs right now, before a release
07:25:07 <thoughtpolice> ndmitchell: did you get my derive patches?
07:25:30 <thoughtpolice> (fix quickcheck derivations mainly)
07:25:55 <ndmitchell> thoughtpolice: yep, took a very brief look - in canada on a machine without a haskell compiler at the mo, but will check them in once i return
07:26:24 <ndmitchell> i think i should be able to fix the type signature issue that was teh underlying cause, shouldn't be too hard
07:27:05 <ndmitchell> thoughtpolice++ -- for the patches
07:27:29 <thoughtpolice> ndmitchell: seems feasible, but you'll have to transform the TH ast returned since if you just do something like [| 1 :: Int |] it still generates stuff of the form 'SigE ... (ConT GHC.Base.Int)' from what I get
07:28:07 <thoughtpolice> which is annoying - type signatures saved my life, however and I discovered mkName
07:28:10 <ndmitchell> i think i can, but not relaly checked it out yet
07:28:27 <thoughtpolice> ndmitchell: ty. also looked at the uniplate paper earlier today and played around - very nice generics lib you got there :]
07:28:32 <ndmitchell> anyway, have to run to breakfast now
07:28:37 <ndmitchell> cool, glad you like it :)
07:28:42 <thoughtpolice> have fun
07:33:26 <c9s>  /win 6
07:34:09 * BeelsebobWork teleports c9s to window 6
07:36:05 <birkenfeld> what is the most recent haskell mode for emacs?
07:36:56 <quicksilver> I use the basic haskell-mode which has been around for ages
07:37:04 <quicksilver> but I add kuribas's indentation code
07:37:07 <quicksilver> which is much much better.
07:40:02 <super> is literate haskell a way to automatically document your code? is it like python docstrings?
07:40:33 <BeelsebobWork> super: no, it's just Haskell in which anything is a comment unless you start the line with >
07:40:46 <BeelsebobWork> so you can integrate Haskell into a latex document and have both pdflatex and ghc compile it
07:40:59 <super> ah ok
07:41:10 <birkenfeld> quicksilver: where can I find the indentation code?
07:41:51 <super> would there be any interest(or is there one already) in haskell-program that automatically creates documentation from a haskell-soruce-file?
07:41:58 <quicksilver> @where kuribas-indentation
07:41:58 <lambdabot> I know nothing about kuribas-indentation.
07:42:01 <quicksilver> super: haddock.
07:42:14 <quicksilver> super: it generates all the docs at http://www.haskell.org/ghc/docs/latest/html/libraries/
07:42:15 <lambdabot> Title: Haskell Hierarchical Libraries
07:42:20 <super> should be fairly easy to do right, create a html-page with just comments and type-declarations
07:42:47 <quicksilver> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
07:42:47 <lambdabot> Good to know.
07:42:59 <quicksilver> birkenfeld: there :)
07:43:11 <EvilTerran> super, the entirity of http://www.haskell.org/ghc/docs/latest/html/libraries/index.html is generated by haddock
07:43:12 <lambdabot> Title: Haskell Hierarchical Libraries
07:43:15 <birkenfeld> thanks!
07:43:20 <EvilTerran> oh, wait, quicksilver already said that
07:43:20 <super> ok
07:44:11 <quicksilver> lambdabot: now damn well remember it this time. I have better things to do that remind my secretary where things are/
07:48:06 <hugo_> hello
07:50:09 <super> im working on a visualing tool in haskell/opengl. anyone have any wishes?
07:50:42 <quicksilver> the moon on a stick.
07:50:59 <araujo> super, a happy lambda
07:54:46 <hugo_> i have this stress using/installing the curl: i did run the runhaskell Setup.hs install, but i can only load the modules on ghci when working on the directory of the module
07:55:08 <hugo_> and it outputs an error, saying it couldn't find the symbol "curl_easy_cleanup"
07:55:23 <quicksilver> sounds like runhaskell Setup.hs install didn't work.
07:55:28 <hugo_> i guess this must be because of opensuse distro :/
07:55:40 <quicksilver> does ghc-pkg list show your curl pacakge?
07:56:48 <hugo_> quicksilver: it outputs this: /usr/lib/ghc-6.8.3/package.conf:
07:56:53 <hugo_> and thats it :P
07:57:00 <hugo_> it doesn't list anything :/
07:57:06 <hugo_> shouldn't it list prelude ?
07:57:16 <hugo_> at least :P
07:57:53 <hugo_> ghc-pkg list | grep -i curl
07:57:56 <hugo_> it shows curl
07:58:11 <hugo_> curl-1.3.2.1
07:59:20 <quicksilver> hugo_: make up your mind?
07:59:26 <quicksilver> ghc-pkg list shows nothing?
07:59:30 <quicksilver> or it shows curl?
07:59:31 <quicksilver> ;)
07:59:31 <hugo_> yes
07:59:33 <hugo_> it shows
07:59:48 <quicksilver> and it's not in (..) ?
07:59:49 <hugo_> i runned the wrong cmd on the first time :P messy me
08:00:18 <hugo_> no braces shown
08:00:25 <hugo_> parenthesis
08:00:53 <hugo_> ghci outputs: <no location info>: module `Network.Curl' is a package module
08:01:06 <hugo_> when i do a :l Network.Curl :/
08:04:13 <Cs0>  /msg NickServ identify c0astline
08:04:29 <hugo_> nice to know your passwd Cs0 :)
08:04:39 <Cs0> y was thinking that
08:04:42 <Cs0> ha
08:04:57 <Cs0> doesn't matter
08:05:04 <hugo_> mine is qwerty123456
08:06:21 <Cs0> so, any guess where my cognitive dissonance set in? I just followed the instruction "This nickname is registered. Please choose a different nickname, or identify via /msg NickServ identify <password>."
08:06:46 <hugo_> just use /nickserv identify c0astline
08:07:02 <DroneZilla> \/msg works I use it
08:07:10 <ystael> Cs0: i'm guessing your problem was the initial space?
08:07:11 <DroneZilla>  /msg perhaps
08:07:13 <DroneZilla> yes
08:08:14 <EvilTerran> Cs0, you left as space before the /
08:08:19 <EvilTerran> that'll be the problem
08:08:31 * EvilTerran prefers to use /query nickserv, then type into that window
08:08:36 <Cs0> ah ty ty (bloody proportional fonts :o)
08:09:40 <hugo_> anyway, i got the libcurl working after all, i just didn't use the :l Network.Curl, and included a "import Network.Curl" on my file, then loaded it... strange that it works that way but not the other
08:10:39 <EvilTerran> hugo_, does ":m + Network.Curl" work?
08:11:33 <hugo_> yes
08:11:53 <hugo_> loads good, and i can fetch google, no stress with :m
08:12:13 <hugo_> that must be it, i have to use :m instead of :l on ghci :P
08:12:27 <hugo_> because as it outputs: module `Network.Curl' is a package module
08:18:39 <rog> hi folks
08:19:17 <rog> does anyone apart from me sometimes have strange behaviour when using Debug.trace. there's an example at http://hpaste.org/10631
08:19:35 <rog> basically it'll sometimes stop outputting the trace messages
08:20:22 <rog> originally i thought it might have been because i was interrupting the running process, but now it's happening regardless.
08:21:21 <rog> note that as far as i'm aware that last line should *always* print "hello".
08:21:24 <rog> but it doesn't
08:21:47 <andyjgill> Yes, I've seen the same behavior.
08:21:56 <rog> hmm. any fixes?
08:22:04 <andyjgill> Are you using ghci?
08:22:09 <rog> yup
08:22:17 <andyjgill> Reload :-)
08:22:22 <rog> i did...
08:22:34 <rog> the hpaste gives the entire session :-(
08:23:09 <andyjgill> Oh. I've only see it get confused, it always went away after reload.
08:23:24 <rog> i'm fairly sure there were some trace messages truncated from the first expression evaluation too.
08:23:29 <andyjgill> You are triggering the bug. Something to do with locked output.
08:23:33 <andyjgill> Perhaps.
08:23:51 <rog> it's really quite a simple program. it doesn't have anything to do with IO
08:24:31 <rog> (in fact it's my first proper haskell program, so this is a bit frustrating!)
08:24:31 <andyjgill> It does because it uses trace.
08:24:55 <rog> indeed. but other than that, i meant (in case there was some collision)
08:25:19 <andyjgill> You might upgrade ghci, to 6.10 or 6.8.3
08:25:28 <andyjgill> gtg
08:25:50 <rog> i'm on 6.8.2
08:26:04 <quicksilver> if you're using Debug.Trace in your first haskell program, you're doing something wrong.
08:26:13 <quicksilver> Debug.Trace is a disgusting hack of the last resort.
08:26:17 <quicksilver> You should feel guilty while using it :)
08:26:27 <birkenfeld> 6.10 is released?
08:26:27 <rog> quicksilver: probably. but how else do i find out what's going on?!
08:26:38 <quicksilver> by running various different interesting subexpressions in ghci
08:26:43 <quicksilver> learn to make the repl your friend
08:27:14 * EvilTerran wonders if he should feel bad for writing "insertWith (+) `flip` 1"
08:27:32 <rog> quicksilver: in this case i'd like to find out what subexpressions are generated in the course of running my actual code...
08:27:44 <rog> quicksilver: is that so unreasonable...
08:28:19 * EvilTerran is happy to read `flip` as a placeholder for a second-last parameter, but not so sure if other people are
08:28:20 <BeelsebobWork> EvilTerran: I'd say that's a yes
08:28:34 <rog> quicksilver: in particular, i'm wondering how useful memoisation might be.
08:29:17 <BeelsebobWork> EvilTerran: I think the obvious (but incorrect) parse for that is equal to insertWith (+1)
08:29:19 <micahcowan> EvilTerran, is the precedence even right on that? (anyway, what's wrong with (+ 1)?)
08:29:33 <BeelsebobWork> I think my point is proven
08:29:42 <EvilTerran> ...
08:29:52 <EvilTerran> function application binds tighter than any infix operator
08:29:56 <micahcowan> 'zactly.
08:29:56 <EvilTerran> there, `flip` is an infix operator
08:30:16 <EvilTerran> it'd be insertWith (const (+1)), actually
08:30:25 <BeelsebobWork> I think that would be much nicer code
08:30:46 <EvilTerran> in this case, yeah
08:30:46 <quicksilver> rog: Well, it's not unreasonable, no.
08:30:47 <BeelsebobWork> EvilTerran: exactly -- my point was thought that it's easy to parse it incorrectly as insertWith ((+) `flip` 1)
08:30:57 <quicksilver> rog: it is, in my opinion, a weakness of the haskell toolchain that it's not as easy as it shuold be to gain access to that kind of data.
08:31:08 <quicksilver> rog: heap profiling is there but it's maybe not as pleasant to read as you'd hope.
08:31:27 <EvilTerran> BeelsebobWork, i can't see that being a problem, really, but i'll use the version with const here
08:31:52 <BeelsebobWork> EvilTerran: didn't micahcowan kinda demonstrate my point though?
08:31:53 <birkenfeld> hmm, why does http://www.haskell.org/ghc/dist/current/docs/users_guide/index.html have release notes for 6.6?
08:31:55 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.9.200809 ..., http://tinyurl.com/2hl2qa
08:31:57 <EvilTerran> i can probably contrive an example where there isn't an alternate solution like that
08:31:59 <BeelsebobWork> that was the parse he came up with
08:32:21 <EvilTerran> meh. i have no trouble parsing that sort of thing.
08:32:22 <rog> quicksilver: i'm told hat is good, but i can't even get hmake to build on my macbook, let alone hat!
08:32:45 <BeelsebobWork> EvilTerran: I have no trouble with it -- but my first instinct is always wrong -- I have to deliberately go "no, function application binds tighter"
08:32:46 <quicksilver> I thought hat had bitrotted.
08:32:52 <quicksilver> If I'm wrong, that's great news.
08:32:56 <BeelsebobWork> quicksilver: hat still works
08:33:02 <quicksilver> that is great news :)
08:33:17 <quicksilver> I thought people routinely failed to build it on recent ghcs.
08:33:20 <quicksilver> I've not tried myself.
08:33:28 <micahcowan> Beelsebob, well, it was the parse I thought might possibly have been intended, not the one I thought would actually be processed. That still amounts to a legibility prob, though, IMO.
08:33:30 <BeelsebobWork> it routinely fails to build on OS X
08:33:44 <rog> quicksilver: somebody the other day said it had bitrotted, but the web page still sounded plausible, so i thought i'd at least try, only to fall at the first hurdle.
08:33:47 <BeelsebobWork> it's semi-bitrotted in that it still works with hmake -- it would be lovely to have it work with cabal
08:33:50 <quicksilver> that would be one reason for me not to try it least :)
08:33:53 <rog> (bloody configure)
08:34:08 <Cpplus> Hello, I'm trying to compile a program in haskell and could use some help figuring out the compiler errors. Thanks! http://hpaste.org/10632
08:34:17 <BeelsebobWork> quicksilver: it's not much fiddling required to make it work -- but it is fiddling all the same... the grep I inserted to fix it unfortunately broke other platforms
08:35:04 <quicksilver> Cpplus: I think that's probably using the wrong version of parsec
08:35:05 <rog> Cpplus: oh the glory of a completely general type system. good luck!
08:35:23 <quicksilver> parsec had a new version recently with a different API.
08:35:28 <quicksilver> (relatively recently)
08:35:32 <sbahra> Cale, ping?
08:35:53 <rog> quicksilver: will heap profiling give me call counts?
08:36:00 <Cpplus> quicksilver: I've installed parsec 3.0
08:36:06 <BeelsebobWork> rog: yes
08:36:09 <Cpplus> rog: Is it that bad?
08:36:42 <quicksilver> Cpplus: it may be that that code is designed for parsec 2, then
08:36:47 <quicksilver> Cpplus: (mind you, this is a guess on my part)
08:36:55 <rog> Cpplus: it's glorious... but its generality often means that errors are reported some distance away from the actual error.
08:37:52 <rog> Cpplus: i sometimes fantasise about an interface in which i can click around and find out what types the compiler has inferred at any point in my source code.
08:38:09 <dmwit> You can do that today!
08:38:12 <rog> Cpplus: though i don't know if that would really help!
08:38:24 <rog> dmwit: uh huh?
08:38:31 <dmwit> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
08:38:33 <lambdabot> Title: Haskell mode for Vim
08:38:42 <Cpplus> :)
08:39:13 <dmwit> rog: _t on a variable name will print a type annotation; _T will add the annotation to the file.
08:39:36 <Cpplus> quicksilver: It could be that it is developed with version 2.1.0.0 or 2.1.0.1 But shouldn't the library be backwards compatible with older versions?
08:39:41 * dmwit disappears
08:39:50 <Saizan> dmwit: but only for toplevel, right?
08:40:03 <rog> dmwit: unfortunately i gave up using vi over 10 years ago and i don't plan on re-starting now!
08:40:34 <quicksilver> Cpplus: should it? I don't know. It isn't, though.
08:40:50 <quicksilver> many libraries take the stand that major version numbers are the times when you can break source compat.
08:40:56 <Saizan> parsec3 is compatible if you use NoMonomorphismRestriction, iirc
08:41:19 <quicksilver> oh. I stand corrected.
08:41:30 <rog> dmwit: so if i just name a variable ending in _t, i get an annotation?
08:41:31 <quicksilver> I thought the new generalised stream stuff made the Api fundamentally different.
08:41:44 <Saizan> and you've to comment out the Applicative instance defined in ErrorFilters
08:42:00 <quicksilver> rog: no, that was a vim command.
08:42:06 <quicksilver> fwiw the emacs mode does similar stuff.
08:42:53 <rog> quicksilver: ok, i see. presumably it only works if the compiler manages to get past the initial syntax check. or is there an incremental compilation going on?
08:43:07 <Cpplus> Saizan, how would i use the NoMono option?
08:43:16 <quicksilver> the former.
08:43:19 <Cpplus> Saizan, <--- haskall noob
08:43:30 <Cpplus> saizan, I'm referring to myself ofc :P
08:44:14 <rog> if there was a command line tool that took a file and a file offset and produced a type, then i could easily hack up the same functionality in the editor i use.
08:44:26 <Saizan> Cpplus: put {-# LANGUAGE NoMonomorphismRestriction #-} at the top of ErrorFilters.hs
08:44:30 <EvilTerran> is HaskellDB suitable for serious use, or is it more of a curiosity / proof-of-concept?
08:44:38 <rog> maybe i'll have to look into the vim haskell-mode source
08:45:31 <EvilTerran> it looks somewhat olegian
08:46:18 <rog> is that a good thing?
08:47:54 <Cpplus> Saizan.. Hmm I did both things, and still get the same compiler errors
08:48:23 <joe22> Hi
08:49:07 <byorgey> hi joe22
08:49:18 <joe22> is there a specific name to call what we are using when defining f as "f = (+1)" instead of "f n = n +1" ?
08:49:20 <Saizan> Cpplus: at least the one referring to Applicate is gone?
08:49:26 <Saizan> *Applicative
08:49:28 <joe22> is it fixed point notation, or simply use of corrification?
08:49:35 <EvilTerran> "points-free notation"
08:49:37 <sbahra> EvilTerran, olegian?
08:49:44 <EvilTerran> "fixed point" means osmething else entirely
08:49:47 <EvilTerran> ?where oleg
08:49:47 <lambdabot> http://okmij.org/ftp/
08:49:49 <joe22> points free?
08:50:07 <EvilTerran> sbahra, Oleg Kiselyov has a reputation for doing crazy things in the haskell type system
08:50:14 <sbahra> ah
08:50:58 <joe22> thanks EvilTerran
08:51:09 <EvilTerran> in this case, i was referring to HaskellDB's types for representing database rows
08:51:23 <EvilTerran> in that the types of the columns appear to be encoded in the type of the row
08:51:27 <super> lambdabot
08:51:33 <super> @src lambdabot
08:51:33 <lambdabot> Source not found. There are some things that I just don't know.
08:51:45 <EvilTerran> this seems rather similar in principle to oleg's "heterogeneous lists" paper
08:51:49 <EvilTerran> ?where hlist
08:51:49 <Saizan> can someone point me to a typesystem where you can ensure that something like a MVar is written once before it's read?
08:51:49 <lambdabot> http://homepages.cwi.nl/~ralf/HList
08:51:50 <super> @complentate life
08:51:51 <lambdabot> Unknown command, try @list
08:51:55 <Cpplus> Saizan: Here's the source and the chances I've done you suggested http://hpaste.org/10633
08:51:58 <super> @list
08:51:58 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:52:07 <EvilTerran> Saizan, i think someone's even done something similar in haskell, actually
08:52:25 <EvilTerran> except it was more "static checks so a file handle can't be used after it's closed"
08:52:29 <EvilTerran> not sure how it was done
08:53:38 <matthew-_> err, are other people having issues getting to hackage?
08:53:56 <sbahra> matthew-_, not anymore
08:54:06 <sbahra> matthew-_, http://hackage.haskell.org/packages/archive/pkg-list.html
08:54:16 <birkenfeld> hmm, what is the reason for Map.lookup returning (Maybe v) in 6.10 instead of (Monad m => m v)?
08:54:26 <quicksilver> the fact that it's the right type
08:54:31 <sbahra> For some minutes though, I wasn't able to access it matthew-_.
08:54:40 <quicksilver> Monad m => m v is pointless generalisation.
08:54:48 <Baughn> Is darcs.haskell.org down?
08:55:02 <sbahra> no
08:55:05 <matthew-_> err, dns
08:55:05 <Saizan> Cpplus: oh, that code is defining a Parser class itself, i guess that the added generality of parsec3 is conflicting with the instances, i think your best bet is to compile it against parsec2
08:55:07 <birkenfeld> quicksilver: I can't give you an example right now, but wouldn't it be useful in some cases?
08:55:12 <matthew-_> no dns resolution is happening
08:55:23 <birkenfeld> like lookup x `mplus` lookup y `mplus` ...
08:55:24 <quicksilver> birkenfeld: yes. But you can trivially convert Maybe to any Monad
08:55:29 <hugo_> where can i learn about arrows ?
08:55:32 <quicksilver> birkenfeld: `mplus` already works in Maybe
08:55:37 <Baughn> Hm. No, I can connect too. It's just darcs that can't resolve the host name for some reason
08:55:41 <Cpplus> Saizan, I will try that thanks.
08:55:48 <birkenfeld> quicksilver: yes, but it returns a Maybe then
08:55:59 <birkenfeld> but let's say I want a list
08:56:07 <sbahra> Baughn, I experienced the same thing for some minutes now
08:56:20 <quicksilver> then you just wrap the whole thing in maybe mzero return
08:56:25 <quicksilver> :t maybe mzero return
08:56:26 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
08:56:34 <birkenfeld> ok...
08:56:47 <Baughn> sbahra: It's odd. I get an A record /and/ NXDoMAIN
08:56:48 <quicksilver> otherwise know as maybeToList, in this case, I think.
08:57:02 <Baughn> Oh, hey. Look. IPv6 brokenness.
08:57:29 <quicksilver> birkenfeld: the point is that all we are trying to express is 'this might fail, if not, it returns an 'a''
08:57:39 <quicksilver> birkenfeld: that is *precisely* the abstraction that Maybe models
08:57:50 <quicksilver> Maybe is the 'minimal' or 'universal' abstraction for this concept
08:58:00 <quicksilver> any other one can be wrapped around maybe with a trivial adapter.
08:58:01 <hackage> Uploaded to hackage: stb-image 0.1
08:58:01 <hackage> Uploaded to hackage: CLASE 2008.9.23
08:58:01 <hackage> Uploaded to hackage: hbeat 0.1.2
08:58:45 <matthew-_> hmm, so I can get as far as monk.galois.com but then the dns fails for that
08:58:58 <Baughn> matthew-_: Try with -t A
08:59:06 <Baughn> It's the AAAA record that's failing
08:59:10 <quicksilver> birkenfeld: the most coherent exposition of this in my opinion is Conor's post here : http://thread.gmane.org/gmane.comp.lang.haskell.libraries/8581/focus=8584
08:59:12 <matthew-_> ahh, cheers
08:59:15 <lambdabot> Title: Gmane Loom, http://tinyurl.com/4vrpzx
08:59:17 <quicksilver> birkenfeld: that's what convinced me, at least.
08:59:26 <Baughn> I wish I didn't have to turn off ipv6 just to download ghc. :
08:59:30 <quicksilver> birkenfeld: (that's in the context of reads/maybeRead but actually the idea is exactly the same)
08:59:41 <dblazakis> Saizan: the lightweight monadic regions paper that was posted on LTU did as EvilTerrain suggests (I think?)
08:59:56 <matthew-_> Baughn: no, still no joy
09:00:08 <dblazakis> Saizan: it might be a good starting point, http://lambda-the-ultimate.org/node/2926
09:00:08 <quicksilver> "...you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is..."
09:00:11 <lambdabot> Title: Lightweight Monadic Regions | Lambda the Ultimate
09:00:19 <quicksilver> mckinna++
09:00:32 <Baughn> matthew-_: host -t A darcs.haskell.org?
09:00:47 <matthew-_> Baughn: well, I'm trying to get to hackage
09:00:50 <Saizan> dblazakis: yup, thanks, i was trying to remember where i read the technique :)
09:00:57 <matthew-_> # host -t A hackage.haskell.org
09:00:57 <matthew-_> Host hackage.haskell.org not found: 2(SERVFAIL)
09:01:38 <Baughn> I get as far as monk.galois.com, but then I get NXDOMAIN. Oh well.
09:01:54 <matthew-_> Baughn: yup, that's exactly what I get
09:02:04 <Baughn> Not servfail, though
09:02:33 <quicksilver> servepicfail!
09:03:37 <matthew-_> Baughn: I get servfail for monk
09:03:46 <matthew-_> even with explicit ns
09:04:33 <birkenfeld> quicksilver: thanks. that thread is illuminating
09:04:56 <rog> hugo_: there are quite a few papers on Arrows. if you can get through any of them without skimming the last two thirds, you're a better man than i. here's one that i got further through than most: http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf
09:04:58 <lambdabot> Title: ¢¡¤£¥¡§¦© %$ '&© )(0¦1¦2 435 687@9©ACBEDGF@9GHPI QE7SR8HUTWVXHUYa`c ...
09:05:05 <rog> great title!
09:05:11 <matthew-_> find him and prod him
09:05:14 <matthew-_> ww
09:06:51 <Baughn> matthew-_: Now it's failing for me too. Guess the failure hadn't propagated all the way before..
09:07:50 <_Dae_> I was wondering... are the C-style arrays (using Ptr) faster than UArray (using unsafeRead and unsafeWrite), or are people just using the Ptr Double thingies because of a masochistic relationship with C?
09:08:46 <Baughn> _Dae_: I don't know. Please benchmark it for me. I'd like to know. ;_;
09:08:47 <hugo_> thank you rog
09:08:55 <mmorrow> i'd like to know that too
09:09:05 <Baughn> _Dae_: I have heard people claim that the Array library is in sore need of rewriting, but don't entirely know why
09:10:26 <Cpplus> Saizan: I tried parsec 2.1.0.1 and now it compiled fine :)
09:10:58 <_Dae_> Hmm.... ok...so I guess it's benchmark time! Anyone got a good idea for a benchmark? Forcing something down the throat of GHC can be.... tough
09:12:17 <Baughn> _Dae_: Look for UArray-using entries to the computer language shootout, write your own UArray replacement, compile, test both ways?
09:13:06 <_Dae_> Baughn: hmm....well... I was gonna try paralizing the nbody anyway....
09:13:51 <Baughn> _Dae_: Be careful to make it thread-safe
09:14:20 <Baughn> ..that might come for free..maybe
09:14:21 <quicksilver> _Dae_: Arrays have one more level of index translation.
09:14:32 * Baughn doesn't know enough about ghc internals to say
09:14:33 <quicksilver> if that doesn't get inlined completely that might account for the cost?
09:14:40 <quicksilver> thre is also a subtlety about which heap the memory ends up in
09:14:41 <_Dae_> quicksilver: not if you use the unsafeReads, right?
09:14:51 <quicksilver> unsafeReads turn off the bounds-check.
09:14:55 <quicksilver> not the index translation.
09:14:59 <_Dae_> quicksilver: unsafeAt then?
09:16:08 <quicksilver> @hoogle unsafeAt
09:16:08 <lambdabot> Data.Array.Base unsafeAt :: (IArray a e, Ix i) => a i e -> Int -> e
09:16:09 <_Dae_> Baughn: thread safe is for people afraid of getting the wrong answer....
09:16:31 <quicksilver> _Dae_: interesting, I never knew that was the difference between At and Read
09:16:39 <quicksilver> yes, that does indeed seem to skip the translation ;)
09:17:24 <quicksilver> I'm not sure what the performance ramifications are of the heap thing, either.
09:17:41 <Baughn> _Dae_: You're venturing into territories where nasal demons dwell
09:17:58 <bd_> unsafeSummonNasalDemon :: forall a. a
09:18:13 <_Dae_> quicksilver: What I find really curious is that there is no similar thing for Write.... can't skip translation there
09:18:20 <mmorrow> quicksilver: do you mean whether mallocBytes/free allocs mem in the haskell or "nonhaskell" heap?
09:18:22 <Baughn> unsafeSummonNasalDemon :: forall a. IO a -> a
09:18:54 <mmorrow> quicksilver: or something?
09:19:40 <quicksilver> mmorrow: yes, that's what I mean.
09:19:54 <quicksilver> haskell heap vs C heap
09:20:42 <mmorrow> quicksilver: hmm. would any performance ramifications be a result of whether the array is pinned in the haskell heap?
09:20:44 <_Dae_> Baughn: Pft! I always wanted a pet nasal demon.... though it would have to put up with tiny living conditions
09:21:18 <_Dae_> quicksilver: there's a big difference between the haskell and the C heap? No garbage collection in the C part, or?
09:22:03 <Baughn> If it's like any other copying language, allocating in the haskell heap will be much faster. Of course, your values will move around later.
09:22:14 <Baughn> *copying GC
09:23:51 <_Dae_> On the other hand I can't really imagine Dons deliberately writing code that's slower than pure monadic haskell....
09:24:22 <quicksilver> mmorrow: I think that's also related. I honestly don't know :)
09:24:37 <dons-icfp> ?users
09:24:38 <lambdabot> Maximum users seen in #haskell: 516, currently: 493 (95.5%), active: 21 (4.3%)
09:24:41 <dons-icfp> hey cool
09:24:50 <quicksilver> dons-icfp: apparently hackage dns is borked
09:24:56 <Baughn> Hm. If 6.10 has unsafeRunAssembly, we could use hand-tuned assembly for all the shootout programs?
09:24:57 <quicksilver> dons-icfp: do you know who to contact at galois?
09:24:58 <dons-icfp> quicksilver: yes. reported.
09:25:01 <quicksilver> ah, good.
09:25:01 <mmorrow> _Dae_: i wrote this experimenting with using a Ptr as a "C-style" array / other misc. maybe it'll be useful http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=57#a57
09:25:01 <dons-icfp> something happened recently.
09:25:10 <dons-icfp> quicksilver: you could email heinlein <> galois com
09:25:19 <dons-icfp> i've also done so.
09:25:27 <dons-icfp> (i'm at icfp, not galois this week, so not on site)
09:25:36 <quicksilver> do you think he's more likely to respond if he gets two emails than one ? ;)
09:25:44 <Baughn> "host -t MX galois.com" <-- NXDOMAIN
09:25:45 <dons-icfp> probably not.
09:25:47 <quicksilver> I assumed since he would recognise your name that would be good.
09:25:53 <matthew-_> how about 516 emails?
09:25:55 <quicksilver> oh, that's not good either.
09:26:04 <Igloo> dons-icfp: Have you sent a message in such a way that he'll actually receive it, given DNS is down?
09:26:12 <Baughn> I don't think he's very likely to respond to email to the downed domain
09:26:15 <dons-icfp> Igloo: i only have gmail atm..
09:26:29 <quicksilver> _Dae_: I think some of the code might have been written in a way which is obsoleted by more recent compiler versions (6.8 or even 6.6)
09:26:35 <dons-icfp> Igloo: i have no way to get in to galois. but let me see if we can msg someone over the phone network
09:26:38 <dons-icfp> glguy: around?
09:26:40 <quicksilver> _Dae_: That is, some of that ptr stuff may not be necessary.
09:27:47 <glguy> dons-icfp: ?
09:27:49 <_Dae_> quicksilver: that would be very nice! All those C-style haskell entries have been bothering me greatly (I mean, if you want to write C.... perhaps C is the language for you?)
09:28:21 <dons-icfp> glguy: dns to galois down. do you have heinlein's phone/text msg number ?
09:28:28 <dons-icfp> glguy: since email may not be working ... :)
09:28:35 <Baughn> _Dae_: On of haskell's main selling points is clarity. Sadly, that counts for naught in the shootout
09:28:47 <quicksilver> _Dae_: it is only a game.
09:28:54 <dons-icfp> someone should try writing a parallel fannkuch today.
09:29:00 <quicksilver> _Dae_: but of course we'd all love it to have the clearest possible code winning ;)
09:29:02 <Igloo> Baughn: There's size, which is related
09:30:17 <_Dae_> quicksilver: I guess it's an occupational hazard. Everything in my field is written in C and fortran for the speed gain, so I'm sometimes slightly speed fixated....
09:30:44 <_Dae_> while at the same time I still want the fuzzy feeling you get from writing in haskell
09:31:18 <Botje> fuzzy feelings aren't always aerodynamic, unfortunately.
09:31:46 <Apocalisp> @remember Botje fuzzy feelings aren't always aerodynamic, unfortunately.
09:31:46 <lambdabot> Done.
09:31:50 <dons-icfp> Igloo: isp notified.
09:32:48 <Baughn> _Dae_: Is your field the kind that will actually take the time to write multithreaded code in C?
09:33:29 <Igloo> dons-icfp: Cool, ta
09:33:31 <_Dae_> Baughn: yes. It is the kind that will run code on GPU's....
09:33:41 <Baughn> _Dae_: I do that for fun. ^_^
09:33:55 <_Dae_> Botje: One can always dream
09:34:28 <Baughn> A 2-4x speed boost from threading your code is one thing. A 100x speed boost from moving it to the GPU.. that's worth paying for.
09:34:36 * dons is back
09:34:51 <_Dae_> Baughn: I would too if I had a fancy new GPU to run it on ;) Actually it seems that it lends itself very nicely to a State monad kind of thingy, no?
09:35:16 <_Dae_> Baughn: True that
09:35:35 <Baughn> _Dae_: I'm waiting on a laptop capable of running cuda/opencl, yep. We'll see then; linking it nicely to haskell will certainly be a priority.
09:35:43 <b4taylor> lame, hackage is broke.
09:36:09 <Armored_Azrael> How can I make my app build linking statically against libc and such?
09:36:31 <Baughn> It's.. very convenient, how easy it is to have haskell hand you a code tree instead of /running/ your code
09:36:35 <Armored_Azrael> I'm sending my app to an outdated system that I can't modify the libraries on it, and glibc version mismatch is preventing my program from running
09:36:56 <Baughn> Armored_Azrael: Bundle libc, set LD_LIBRARY_PATH?
09:37:13 <Armored_Azrael> Baughn: This is one way of doing it, but in C I can just do gcc -static
09:37:19 <Armored_Azrael> And it builds them all in
09:37:27 <Armored_Azrael> It would be nice to be able to just ship a static executable
09:38:32 <Baughn> Armored_Azrael: Try passing -static -optl-static to ghc
09:38:43 <Armored_Azrael> Thanks
09:39:16 <Armored_Azrael> Generates linker errors
09:39:18 <Armored_Azrael> Alot of them
09:40:04 <Saizan> Armored_Azrael: with --make?
09:40:32 <mmorrow> that's been my experience
09:40:59 <Armored_Azrael> Saizan: Yes, I'll post to a pastebin
09:41:26 <dons> grr. joelr's erlang/haskell crash and burn 2 years ago continues to haunt.
09:41:38 <mmorrow> Armored_Azrael: try a bunch of optl-l...
09:41:41 <Armored_Azrael> http://pastebin.com/m43f2ec79
09:41:41 <quicksilver> dons: just consider it an opportunity ;)
09:41:53 <quicksilver> dons: a springboard on which to base an interesting discussion
09:42:21 <Armored_Azrael> There's no foreign calls, and it builds without the -static -optl-static, so I don't believe this is the fault of the underlying program, but source is availble if relevant
09:42:46 <b\6> anyone have an openal example that uses pcm data? i can't make a simple square wave thing stop crackling.
09:43:03 <_Dae_> Baughn: it's a pity that AMD and NVIDIA are using different standards for this :(
09:43:22 <Armored_Azrael> I suppose I'll try to find the pthreads library and manually add that...
09:43:27 <mmorrow> Armored_Azrael: try adding -optl-lpthread
09:43:35 <mmorrow> yeah
09:43:44 <Baughn> _Dae_: Not to mention Intel. I imagine it'll all settle down in a few years, though
09:44:16 <Armored_Azrael> mmorrow: Oddly, same errors
09:45:03 <_Dae_> Baughn: true, but intel still has to actually manufacture anything competitive.... also, from a purely technical point, I can't see how they intend to make x86 work on a GPU
09:45:08 <Armored_Azrael> -optl-pthread_nonshared seems to still yield the errors as well
09:45:19 <quicksilver> _Dae_: don't worry about AMD and NVIDIA and Intel; data parallel haskell is the future :)
09:45:23 <dons> this bulatz thread is the strangest one. 24 hours of negativity, and a stated unwillingness to discuss new results, or do anything constructive
09:45:23 <quicksilver> DPH on the GPU FTW!
09:45:25 <mmorrow> weird. i don't think it's ever been the case that i've been able to get a haskell static binary built if it didn't work first try
09:45:38 <quicksilver> dons: he's a bit like that sometimes.
09:45:42 <dons> why would someone put that much effort into doing negative assertions of the state of play
09:45:50 <dons> all with old examples from his freearc code 2.5 years ago
09:45:57 <Baughn> _Dae_: Don't discount them out of hand. They're a much larger company than either nvidia or ati; they just may be able to pull off a miracle
09:46:02 <_Dae_> quicksilver: I would cry with happiness the day that happened
09:46:11 <dons> talk about draining the energy of a community.
09:46:27 <Baughn> Though normally that just means being able to waste more money. :/
09:46:34 <dons> galois.com is back in the tubes.
09:46:36 <_Dae_> Baughn: sure, but it's not like it's the first time they've tried this.
09:46:39 <thetallguy> dons: he made some suggestions about changing the language definition some years ago
09:46:53 <dons> ah yes. with references and array syntax?
09:47:19 <dons> i just get frustrated, since he is so unrelentingly negative. puts no code on hackage, and cites only his experience from several years ago.
09:47:28 <thetallguy> dons:  mostly syntactic changes.  Don't remember the details much.  I do remember that many of the changes were reasonable
09:47:53 <thetallguy> dons: sounding, at least.  I wonder if he himself got frustrated that he couldn't budge anyone.
09:48:23 <mmorrow> dons: does he have a valid point about "ghc generates slow code" or not (i'm assuming he's talking about generated asm)
09:48:24 <dons> he really really wants us to understand that Haskell is not C++
09:48:36 <b\6> it is ?????
09:48:42 <dons> mmorrow: its not particularly slow. esp. since the cleanups.
09:48:53 <dons> there's some cases where more move instructions are generated, than you see in gcc.
09:49:01 <dons> but its not "slow" in any sense.
09:49:05 <Haskell_Noob> hey, I am a C guy trying to learn haskell I have been going through the Haskell for C programmers tutorial, but some of the examples aren't that well explained. I was wondering if you guys could help me out.
09:49:15 <Armored_Azrael> mmorrow: Could this have anything to do with it? http://pastebin.com/m397e0f7a
09:49:49 <geezusfreeek> talking about that guy on the mailing list?
09:49:52 <mmorrow> dons: interesting
09:49:53 <micahcowan> Haskell_Noob, so far, RWH has been the only resource available online that I've found to be adequate for learning.
09:49:58 <geezusfreeek> he seems difficult to reason with
09:50:01 <_Dae_> Haskell_Noob: we can try? What's your problem?
09:50:03 <dons> mmorrow: and that's what the new codegen is for.
09:50:07 <Haskell_Noob> for instance I am trying to learn about lists and lists comprehensions, but I don't quite get what it is doing. For instance what does [ 2 * x | x <- 9 : 1 : nums ] do? (nums being a predefined list of numbers)
09:50:35 <micahcowan> Haskell_Noob, I don't suppose you're familiar with Python's list comprehensions?
09:50:39 <dons> geezusfreeek: i think he doesn't engage. he continues to assert his original negative points, going so far to turn improvements into "that means things were worse in the past"
09:50:47 <Haskell_Noob> Unfortunately not
09:50:53 <dons> so there's some personality issues.
09:50:59 <DrSyzygy> > [ 2*x | x <- 9:1:[0..10] ]
09:51:00 <lambdabot>   [18,2,0,2,4,6,8,10,12,14,16,18,20]
09:51:13 <DrSyzygy> Haskell_Noob: Does that help with your specific question?
09:51:19 <mmorrow> dons: other than that, i'm not convinced of anything by his arguments
09:51:20 <Armored_Azrael> Hakell_Noob: It takes a list, adds 9 and 1 to the front, then returns a list which is that list with everything doubled
09:51:32 <Armored_Azrael> Haskell_Noob: Here, the list comprehenshion is just being used as a map
09:51:36 * araujo has read some of these 'haskell is useless' threads lately
09:51:36 <mmorrow> dons: the new codegen sounds interesting indeed, from what i've read about it
09:51:36 <_Dae_> Haskell_Noob: the code in the first part [2*x| is fairly easy to understand. For all x, multiply x by 2, where x = [9,1,nums]
09:51:40 <geezusfreeek> i don't think he's poisonous at least
09:51:41 <dons> mmorrow: well, i'm not sure there were arguments. just assertions. oh, some references to 8 year old papers too.
09:51:43 <Haskell_Noob> well that explanation helped
09:51:45 <Haskell_Noob> :)
09:51:46 <Baughn> Haskell_Noob: It's also very similar to mathematical.. set comprehension syntax? Erm. Something like that.
09:51:54 <dons> geezusfreeek: i find him emotionally draining.
09:52:02 <mmorrow> dons: s/arguments/whatev/ :)
09:52:03 <dons> nothing positive comes out of the discussions.
09:52:04 <Haskell_Noob> so what exactly do | and <- do?
09:52:16 <Baughn> Nothing; they're syntax
09:52:19 <dons> it doesn't suggest how, or even precisely what, to improve.
09:52:27 <DrSyzygy> Baughn: Well .....
09:52:29 <dons> so more throwing rocks from the sidelines.
09:52:34 <mmorrow> they sound more like
09:52:34 <micahcowan> Haskell_Noob, nothing by themselves, the whole [ ... | ... <- ...] is what means something.
09:52:35 <mmorrow> yeah
09:52:44 <mmorrow> throwing rocks is a nice way to put it
09:52:48 <Baughn> Haskell_Noob: You can read it as "For each x, make a list of x*2, where x is each element in <this list>"
09:52:54 <DrSyzygy> Haskell_Noob: | is just syntax, it separates the "map" statement from the conditions
09:52:56 <Haskell_Noob> ok well what exactly does [...|...<-...] mean?
09:53:02 <Haskell_Noob> ok :)
09:53:16 <DrSyzygy> Haskell_Noob: <- is connected to other wild and whacky bits of Haskell theory and syntax (keyword: Monad)
09:53:26 <micahcowan> When you've mastered this one, tell us, so we can add a boolean expression to the mix. :)
09:53:36 <DrSyzygy> micahcowan: Or two lists!
09:53:39 * araujo found this thread about ocaml superiority over haskell ... nevertheless, haskell's community seems doing by far better than the former in many regards
09:53:48 <Baughn> micahcowan: Or parallel comprehension!
09:54:02 <EvilTerran> Baughn, but that one's an extension...
09:54:03 <DrSyzygy> > [ x*y | x <- [1..5], y <- [3..5] ]
09:54:05 <lambdabot>   [3,4,5,6,8,10,9,12,15,12,16,20,15,20,25]
09:54:12 <Baughn> EvilTerran: I'm okay with extensions
09:54:16 <_Dae_> Baughn: parallel comprehension in list constructors??
09:54:18 <EvilTerran> > [f x | x <- [a,b,c]] :: [Expr
09:54:19 <lambdabot>   mueval: Prelude.read: no parse
09:54:21 <EvilTerran> > [f x | x <- [a,b,c]] :: [Expr] -- doh
09:54:22 <lambdabot>   [f a,f b,f c]
09:54:36 <Baughn> > [x+y | x <- [0..3] | y <- [0..4]]
09:54:37 <lambdabot>   [0,2,4,6]
09:54:45 <Haskell_Noob> ok well I now fully understand the first thing... all that other stuff... lol
09:55:09 <EvilTerran> Baughn, i figured, but just h98 is enough to confuse most newbies, throwing extensions in too will only make things worse...
09:55:11 <Baughn> _Dae_: Turning list comprehensions into N-ary zipWith, and thus making them really useful
09:55:28 <Baughn> EvilTerran: I don't know. It's really a generalization; it might make it easier
09:55:32 <mmorrow> araujo: link!
09:55:36 <thoughtpolice> araujo: link?
09:55:38 <DrSyzygy> > [ x+y | x <- [a,b,c] | y <- [d,e,f]] :: [Expr]
09:55:39 <lambdabot>       Ambiguous occurrence `d'
09:55:39 <lambdabot>      It could refer to either `L.d', defined a...
09:55:44 <_Dae_> Baughn: :D
09:55:44 <Baughn> map's just 1-ary zipWith to being with
09:55:47 <DrSyzygy> > [ x+y | x <- [a,b,c] | y <- [x,y,z]] :: [Expr]
09:55:47 <EvilTerran> ?undef
09:55:48 <lambdabot>   [a + x,b + y,c + z]
09:55:53 <DrSyzygy> Ahhhhhh
09:56:17 <DrSyzygy> *snerk* "When I used to work for the federal government, my programs would tend to begin something like for (i = 0; i < 1<<56; i++). I just used to let the damn things run and deal with the output whenever they finished -- whether it was after lunch or after a few days."
09:56:20 <araujo> http://flyingfrogblog.blogspot.com/2008/08/haskells-virginity.html
09:56:22 <lambdabot> Title: The Flying Frog Blog: Haskell's virginity, http://tinyurl.com/5b4yg9
09:56:26 <araujo> mmorrow, thoughtpolice ^^
09:56:34 <mmorrow> araujo: thx
09:56:39 <Haskell_Noob> DrSyzygy: that actually makes sense :)
09:56:39 <thoughtpolice> oh wow
09:56:42 <thoughtpolice> flying frog
09:56:45 <thoughtpolice> GUESS WHO WROTE THAT ONE?
09:56:51 <dons> bah
09:56:59 <dons> araujo: don't like to that stuff. its spam
09:57:13 <araujo> dons, just found it a couple of days ago
09:57:18 <dons> :/
09:57:20 <thoughtpolice> i always love reading harrop stuff
09:57:21 <thoughtpolice> for a laugh
09:57:42 <Haskell_Noob> DrSyzygy: what was wrong with your first expression?
09:58:02 <DrSyzygy> Haskell_Noob: That 'd' has a separate definition in the lambdabot system
09:58:21 <DrSyzygy> Haskell_Noob: Note the difference between the following two expressions:
09:58:25 <DrSyzygy> > [ x+y | x <- [a,b,c] | y <- [x,y,z]] :: [Expr]
09:58:30 <lambdabot>   [a + x,b + y,c + z]
09:58:45 <DrSyzygy> > [x+y | x <- [a,b,c], y <- [x,y,z]] :: [Expr]
09:58:45 <thoughtpolice> dons: on that note, people who criticize darcs stability/performance and use haskell as 'the reason for it' also make me laugh
09:58:47 <lambdabot>   [a + a,a + y,a + z,b + b,b + y,b + z,c + c,c + y,c + z]
09:59:02 <DrSyzygy> Wait.
09:59:03 <DrSyzygy> Doh!
09:59:23 <DrSyzygy> I'm using x and y for WAY too many things here
09:59:37 <Baughn> ..yes...
09:59:38 <DrSyzygy> > [xx+yy | xx <- [a,b,c] | yy <- [x,y,z]] :: [Expr]
09:59:39 <lambdabot>   [a + x,b + y,c + z]
09:59:51 <DrSyzygy> > [xx+yy | xx <- [a,b,c], yy <- [x,y,z]] :: [Expr]
09:59:53 <lambdabot>   [a + x,a + y,a + z,b + x,b + y,b + z,c + x,c + y,c + z]
09:59:59 <DrSyzygy> That's what I meant to do.
10:00:17 <Haskell_Noob> give me a minute...
10:00:20 <dons> let's not repeat old memes.
10:00:24 <Haskell_Noob> :)
10:02:32 <Haskell_Noob> ok so with the | it treats them as two separate lists whose values xx+yy operates on. without the | it xx+yy refers to the list not it's contents. So it is like matrix operations
10:02:35 <Haskell_Noob> right?
10:03:31 <Baughn> You might want to read "," as "cartesian product" in that syntax
10:03:48 <Haskell_Noob> ok
10:03:55 <Baughn> With multiple |s, it handles each clause separately, yes
10:04:27 <Baughn> (Feeding them all into the first, summary clause in parallel. Thus the name "parallel list comprehension")
10:04:30 <Haskell_Noob> so glad this place exists... Haskell is a really interesting language
10:05:20 <Baughn> The channel exists only when there are people in it (it's created lazily), but that's hard to test
10:05:38 <Haskell_Noob> so any other pearls of wisdom before I go back to the tutorial?
10:05:41 <DrSyzygy> And you can mix them, right? You can sprinkle , and | more or less as you like it, right?
10:05:54 <Baughn> DrSyzygy: Except for | being an extension, sure
10:06:23 <Baughn> > [x+y | x <- [1..7], x `mod` 2 == 1 | y <- [1..10]]
10:06:25 <lambdabot>   [2,5,8,11]
10:06:28 <DrSyzygy> Baughn: So I need to use GHC, but otherwise I'm good? :-)
10:06:52 <Baughn> DrSyzygy: It might be supported elsewhere; it's a simple extension
10:07:02 <DrSyzygy> Aight
10:07:44 <Haskell_Noob> > [xx+yy*zz | xx<-[a,b,c], yy<-[x,y,z] | zz<-[f,g,h]]::[Expr]
10:07:45 <lambdabot>   [a + x * f,a + y * g,a + z * h]
10:08:03 <DrSyzygy> Ah ... here's the thing!
10:08:23 <DrSyzygy> The first cartesian product generates 9 elements, but the parallell bit only has 3.
10:08:36 <DrSyzygy> > [xx+yy*zz | xx<-[a,b,c], yy<-[x,y,z] |zz<-[1..9]]::[Expr]
10:08:37 <lambdabot>   [a + x * 1,a + y * 2,a + z * 3,b + x * 4,b + y * 5,b + z * 6,c + x * 7,c + ...
10:08:44 <thoughtpolice> Haskell_Noob: purity is the light that will save you from the depths of a horrible, horrible unreasonable hell.
10:08:45 <thoughtpolice> that is all.
10:08:45 <Haskell_Noob> what does == do?
10:09:18 <Baughn> Equality. :P
10:09:27 <Baughn> > 1 == 2
10:09:29 <lambdabot>   False
10:09:36 <Haskell_Noob> ah
10:09:46 <EvilTerran> > 1 /= 2
10:09:47 <lambdabot>   True
10:09:52 <thoughtpolice> (also i'm totally serious about that advice :] )
10:09:52 <EvilTerran> ?src (/=)
10:09:52 <lambdabot> x /= y = not (x == y)
10:09:55 <Baughn> > let 1 = 2 in 1 == 2
10:09:56 <lambdabot>   False
10:10:10 <Baughn> Hmmph. I'm /sure/ that worked at some point.
10:10:16 <Haskell_Noob> huh now I am really confused by > [x+y | x <- [1..7], x `mod` 2 == 1 | y <- [1..10]]
10:10:22 <EvilTerran> Baughn, you might be thinking of redefining (+)
10:10:36 <Baughn> EvilTerran: I don't know. I lost the logs from back then. :/
10:10:41 <EvilTerran> Baughn, that one's equivalent to "let _ = 2 in 1 == 2", as the 1 is a constant pattern, not a variable
10:10:56 <mmorrow> haha, Heffalump correctly corrected Flying Frog Consultancy, Ltd.'s incorrect statement that libfftw is running any ocaml code at all
10:11:27 <EvilTerran> and patterns in lets are irrefutable
10:11:37 <Baughn> Haskell_Noob: It's the same sort of thing as the last parallel comprehension, except that the "x `mod` 2 == 1" clause restricts x to only be odd numbers
10:12:02 <Baughn> Haskell_Noob: An even number would be ignored, as if it wasn't in the list in the first place
10:12:12 <thoughtpolice> mmorrow: Heffalump took him to town fo' sho'
10:12:16 <thoughtpolice> :]
10:12:34 <Haskell_Noob> ok, that makes a bit of sense :)
10:12:47 <EvilTerran> mmorrow, i find it also worth mentioning that caml's been around since 1985, and ML in some form's been around since 1973
10:12:59 <EvilTerran> so it's got at least a 13-year head start
10:13:21 <Baughn> Haskell_Noob: Incidentally, you can do this same sort of thing with map, filter and (for two-clause parallel comprehensions) zipWith. You'll run into those later, I bet.
10:13:28 <thoughtpolice> of course, I generally think about myself as a functional programmer first, haskell programmer second. but harrop-insanity is different :P
10:13:36 <mmorrow> totally. so many "creative" uses of statistics there to even begin to mention them all
10:13:37 <micahcowan> > let 1 + 2 = 5 in 1 + 2
10:13:38 <lambdabot>   5
10:13:42 <Haskell_Noob> > [x+y | x <- [1..7], y <- [1..10]]
10:13:43 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
10:13:44 <micahcowan> Baughn, ^^^ ? :)
10:13:57 <Haskell_Noob> > [x+y | x <- [1..7], x < 6 | y <- [1..10]]
10:13:58 <lambdabot>   [2,4,6,8,10]
10:14:15 <dejones> In this line "renderPrimitive Polygon $ mapM_ ( \(x, y, z) ->  vertex $ Vertex3 x y z) myPoints" -- I am not completely understanding why the use of mapM_, it seems to me that you would want the results of the lambda function to be passed to renderPrimitive?
10:14:46 <EvilTerran> ?hoogle renderPrimitive
10:14:47 <lambdabot> No results found
10:15:04 <sw17ch> are there any compile time length checked fixed size container objects out there?
10:15:13 <thoughtpolice> hi Feuerbach, saw you commented on my dph post - rl responded on glasgow-haskell-users with some good points if you want to try to make your physics engine use dph as-is
10:15:16 <EvilTerran> sw17ch, apart from tuples, you mean?
10:15:20 <sw17ch> EvilTerran, yes
10:15:33 <EvilTerran> various things have been done
10:15:37 <dejones> EvilTerran: http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-BeginEnd.html#v%3ArenderPrimitive
10:15:39 <EvilTerran> i forget where, though
10:15:39 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.BeginEnd, http://tinyurl.com/4wsrmo
10:15:58 <EvilTerran> renderPrimitive :: PrimitiveMode -> IO a -> IO a
10:16:21 <EvilTerran> dejones, it doesn't use the return value, it uses some kind of mutable structure
10:16:29 <BMeph> sw17ch: ...arrays, perhaps? :)
10:16:51 <sw17ch> BMeph: do the arrays do compile time bounds checking?
10:16:55 <thoughtpolice> Feuerbach: in particular http://www.haskell.org/pipermail/glasgow-haskell-users/2008-September/015554.html
10:16:56 <EvilTerran> dejones, note vertex :: Vertex a => a -> IO ()
10:16:56 <lambdabot> Title: Some initial results with DPH, http://tinyurl.com/3vqpz2
10:17:44 <EvilTerran> sw17ch, wrappers have been written around arrays to do so
10:17:51 <mmorrow> sw17ch: template-haskell make dealing with tuples less painful
10:18:06 <sw17ch> mmorrow, i'll take a look. as of yet, i haven't touched TemplateHaskell
10:18:09 <dejones> EvilTerran: Right, but I am confused that mapM_ would "ignore the results" -- How do any of the vertexes get passed to renderPrimitive?
10:18:33 <EvilTerran> dejones, as i said, "vertex :: Vertex a => a -> IO ()", so the vertex isn't being returned anyway
10:18:42 <mmorrow> , $(tupE (fmap lift [0..9]))
10:18:43 <lunabot>      Ambiguous type variable `a' in the constraints:
10:18:47 <mmorrow> , $(tupE (fmap lift [0..9::Int]))
10:18:48 <lunabot>  (0,1,2,3,4,5,6,7,8,9)
10:18:48 <FunctorSalad> is there some simple way to get hold of the deep codomain of a function?
10:19:07 <EvilTerran> dejones, i presume the "IO ()" returned by vertex represents a "put a vertex here" action
10:19:10 <FunctorSalad> ("deep" as in the d in a -> b -> c -> d)
10:19:30 <subconscious> hm
10:19:34 <subconscious> hi FunctorSalad
10:19:46 <Saizan> FunctorSalad: not really, but there are some oleg's tricks
10:19:46 <FunctorSalad> ("simple" as in "not typeclass messing")
10:19:52 <FunctorSalad> hi subconscious
10:19:58 <Saizan> ok, then no :)
10:20:00 <subconscious> do you have code online?
10:20:02 <EvilTerran> sw17ch, something like "data Z; data S n; newtype Vector n a = Array Int a" as a starting point
10:20:21 <sw17ch> EvilTerran, alright, cool
10:20:25 <EvilTerran> sw17ch, then something like zipVector :: Vector n a -> Vector n b -> Vector n (a,b)
10:20:27 <EvilTerran> etcetc
10:20:35 <dejones> EvilTerran: Ohhh.  I wasn't thinking functional enough!  I see that the mapM_ is the argument to the renderPrimitive function!  :)
10:20:35 <sw17ch> yes yes...
10:20:36 <EvilTerran> o forgot the constructor in that newtype, but you get the idea
10:20:37 <dejones> Thanks EvilTerran.
10:20:48 <mmorrow> , $(let sel n i = let x = mkName "x" in lamE (tupP (replicate i wildP++[varP x]++replicate (n-i-1) wildP)) (varE x) in sel 10 7) $(tupE (fmap lift [0..9::Int]))
10:20:49 <lunabot>      Couldn't match expected type `[PatQ]' against inferred type `PatQ'
10:20:55 <FunctorSalad> subconscious: me? as in something finished? no :-(
10:20:59 <EvilTerran> dejones, indeed, the mapM_ is returning an action that does things
10:21:05 <subconscious> no, something in progress :)
10:21:08 <Saizan> FunctorSalad: if it's monomorphic you could use Typeable maybe
10:21:13 <EvilTerran> dejones, it doesn't matter that the action doesn't return anything meaningful
10:21:15 <subconscious> You should find some place to put up code anyway
10:21:55 <mmorrow> , $(let sel n i = let x = mkName "x" in lamE [tupP (replicate i wildP++[varP x]++replicate (n-i-1) wildP)] (varE x) in sel 10 7) $(tupE (fmap lift [0..9::Int]))
10:21:56 <lunabot>  7
10:21:57 <dejones> EvilTerran: Right, lol.  Thanks -- gotta love functional programming!
10:21:58 <dejones> hehe
10:24:31 <xsdnyd> hi
10:24:41 <FunctorSalad> Saizan: I don't really need a TypeRep of the "deep codomain", just make a function that takes functions with a specific "deep codomain"... that alone wouldn't be hard with classes, but I somehow got myself into additional mess ;-)
10:26:22 <Haskell_Noob> so what is normally considered the best development setup for working with haskell?
10:26:39 <xsdnyd> i have this: data Music = FileM File | SongM Song \n  data Song = Title Int      how can i filter [Music] to only include SongM ? assume i have list = [Music] then i tried filter (SongM ==) list
10:26:39 <xsdnyd> but this doesn't work
10:26:59 <subconscious> xsdnyd: filter isSongM list
10:27:11 <Saizan> FunctorSalad: well i thought you could use the TypeRep to check which was the deep codomain, you can decompose them iirc, however a typeclass solution is probably cleaner
10:27:11 <Haskell_Noob> right now I am in windows trying to use GHCi... I want to compile some stuff for windows but I don't mind (I actually prefer) using linux
10:27:17 <subconscious> xsdnyd: and define isSongM by pattern matching
10:27:24 <xsdnyd> subconscious: ok thx
10:27:37 <xsdnyd> subconscious: i thought haskell might have a built-in way to do it ;)
10:28:00 <subconscious> xsdnyd: I don't like list comprehensions
10:29:03 <jamii> xsdnyd: [ SongM s | SongM s <- list ]
10:29:13 <mmorrow> , disconnect
10:29:18 <mmorrow> , please
10:30:00 <mmorrow> , 42
10:30:05 <lunabot>  42
10:31:05 <xsdnyd> jamii: thats cool
10:31:23 <cads> what do you guys think is the killer app for haskell?
10:32:17 <bran> gopher client for sure
10:32:18 <Baughn> Support for massively multicore systems?
10:32:38 <mmorrow> crap, i forgot lunabot's password
10:32:48 <lament> haskell might not be as good for that as languages specifically designed for massively multicore systems
10:32:57 <mmorrow> (i actually can't remember if it was even me that registered that name)
10:33:00 <lament> although... it's a matter of perspective...
10:33:24 <MyCatVerbs> cads: the one that fires the missiles.
10:33:34 <Baughn> lament: Haskell isn't?
10:33:37 <olsner> MyCatVerbs: *killer* app - that's funny!
10:33:38 <Baughn> It could have fooled me
10:33:45 <Feuerbach> thoughtpolice: thanks for pointing!
10:34:16 <MyCatVerbs> olsner: no it isn't, it's a lame joke.
10:34:24 <mmorrow> i laughed
10:34:36 <cads> I chuckled
10:34:39 <Haskell_Noob> at not with...
10:34:42 <lament> Baughn: not in the same sense as, say, Chapel
10:34:46 <Haskell_Noob> I grimaced.
10:34:50 <Baughn> Is the ghc 6.10 beta ready for use? It isn't going to eat my cats?
10:35:01 <Zao> It may confiscate your tea.
10:35:09 <Baughn> Not my tea. :"(
10:35:09 <mmorrow> Baughn: see the disclaimer about pets and small children in the README
10:35:13 <MyCatVerbs> olsner: the only thing that helps at all is the fact that it's actually a reference to SPJ's talks on the nature of purity, and how the difference between a and IO a is that IO a is allowed to fire missiles, where you know for certain that evaluating something of type a won't.
10:35:14 <subconscious> Baughn: my cat is still, probably around here somewhere
10:35:32 <Baughn> mmorrow: I see no disclaimer
10:35:35 <cads> yes, I suppose it is silly for me to ask of the venerable haskell to have a killer app, when it already has so much that it mystifies the average killer app user
10:35:42 <FunctorSalad> subconscious Saizan : tried to put up a short description... http://hpaste.org/10637
10:35:48 <mmorrow> Baughn: heh
10:36:08 <MyCatVerbs> cads: nah. Actually we're being evasive because we can't think of one. ;)
10:36:08 <olsner> MyCatVerbs: yeah, "firing the missiles" is some kind of haskell meme
10:36:19 <Baughn> cads: Killer apps are generally language-agnostic. :P
10:36:37 <MyCatVerbs> cads: for actually useful languages, sure. Like, C's killer app? DOOM. C++'s? Half-Life, and Half-Life 2. :)
10:36:47 <cads> hehe
10:36:58 <Baughn> Haskell's is Monadius
10:37:02 <mmorrow> unsafeReleaseTheHoundsandFireTehMissiles
10:37:05 <cads> haha!
10:37:16 <cads> that game is awesome!
10:37:18 <olsner> languages don't really have killer apps, I think... except perhaps as examples that "yes, it *is* possible to build software using language X"
10:37:30 <MyCatVerbs> cads: Haskell's -real- "killer app" is that it's a pretty good vehicle for both programming language research, and for teaching functional programming to students.
10:37:32 <subconscious> ?faq is ?faq the killer app?
10:37:33 <lambdabot> The answer is: Yes! Haskell can do that.
10:37:33 * ystael votes for hound missiles
10:37:33 <Baughn> What is the purpose of ~/.darcs, and why is it 300MB?
10:37:40 <cads> but for example, ruby has got rails
10:37:41 <MyCatVerbs> cads: which are precisely the purposes that it was designed for.
10:37:47 <cads> MyCatVerbs: I agree with that
10:38:11 <lament> olsner: languages that desperately want mainstream acceptance often need killer apps
10:38:23 <MyCatVerbs> cads: in some ways, that's a weakness. Ruby has Rails, but now close to every other language on the planet has frameworks with more or less all of Rails' interesting features.
10:38:46 <vegai> MyCatVerbs: well, except Haskell :P
10:38:56 <cads> it's true, ruby without its frameworks isn't that interesting from a technical perspective
10:39:09 <cads> while haskell is astounding
10:39:26 <Botje> ruby is just a slower smalltalk :P
10:39:26 <mmorrow> imagine haskell once it has such frameworks in place
10:39:32 <MyCatVerbs> cads: I appreciate that Rails was certainly progress - it raised the bar for competing frameworks and improved things for everybody - but now that people have caught up again, Ruby doesn't really benefit on its own.
10:39:46 <olsner> i think the question is - if we manage to make haskell mainstream, where would all the excentric haskell coders find some even *more* pure, *more* outstream language to move their excentricity to?
10:39:56 <cads> yes
10:40:03 <cads> dependently typed languages, heh
10:40:04 <ystael> olsner: perhaps Coq :D
10:40:12 <lilac> olsner: i think you mean, if we fail and haskell becomes mainstream :)
10:40:27 <zachk> how would we fail
10:40:35 <lilac> we'd fail to avoid success
10:40:40 <olsner> hmm, yeah, possibly coq or agda or something like that could pick up the slack
10:40:57 <MyCatVerbs> zachk: Haskell's unofficial motto - its secret so far - has been "avoid success at all costs".
10:41:09 <zachk> i like that motto
10:41:20 <cads> the hair shirt of supreme laziness :)
10:41:34 <thoughtpolice> Feuerbach: note my initial example in the post (dot product) was wrong because I wasn't using a parallel list comprehension
10:41:52 <cads> ah well, I'd just like to see more people loving on haskell
10:42:03 <MyCatVerbs> zachk: it's expressing the fact that Haskell has been able to evolve really rapidly precisely because it has had such a small following and such a large proportion of them have been academics.
10:42:05 <thoughtpolice> Feuerbach: but regardless, just I.sumP (zipWithP (I.*) v w) doesn't make a difference, about 99% of the time goes to the GC and the optimizer still takes a long time to compile
10:42:08 <zachk> i like it because it works
10:42:22 <olsner> success for haskell would be to spawn ideas into languages that do make it mainstream... maybe something like Java+STM or sanely typed imperative languages based on monads
10:42:32 <thoughtpolice> Feuerbach: I emailed rl but right now I'd say a safer bet for something more stable would be to try and work with the dph-prim-{par,seq} packages instead of the higher level ones
10:42:37 <cads> it seems today we're about to see an explosion of erlang based cloud computing
10:42:53 <MyCatVerbs> cads: hang on a minute there.
10:43:00 <cads> but no-one is giving algebraic datatypes any love
10:43:10 <MyCatVerbs> cads: what we are seeing is an explosion of "cloud computing" -hype-.
10:43:10 <EvilTerran> <3 ADTs
10:43:15 <thoughtpolice> olsner: word
10:43:18 <MyCatVerbs> cads: distinguish carefully.
10:43:29 <cads> heh, that's true
10:43:38 <lament> i can't wait for the cloud hype to die
10:43:45 <lament> it's pretty much the most embarrassing thing ever
10:43:45 <lispy> cloud computing into the blogosphere
10:43:48 <thoughtpolice> olsner: i am perfectly happy with haskell not being the next big thing but being an inspiration - it means we can keep moving and keep inspiring, hopefully :]
10:44:10 <olsner> I read about some massively parallel JVM that used an STM-like model for running shared-state java threads, even capable of fixing up java code that had insufficient synchronization :)
10:44:14 <zachk> i left scheme cause i grew tired of it
10:44:39 <mmorrow> yuk. i hope java dies sooner than later
10:44:56 <lispy> I'm pretty sure the secret of Haskell being so whizbang cool is the army of PhDs behind it.  Even if that stops being the case for Haskell, the army of PhDs will still be somewhere.
10:45:02 <mmorrow> and a functional language (whether that be haskell or anothre) replaces it
10:45:23 <zachk> java was just a move by lisper/schemers to pull the c/c++ world into garbage collection, which used to be considered an area for quiche eaters
10:45:35 <EvilTerran> the army of PhDs will be designing the *next* fancy new language
10:45:40 <cads> lament, I don't see how it's different than "grid" computing, except perhaps all the support from the followers of inefficient dynamic web framework languages
10:45:45 <thoughtpolice> mmorrow: how's cayenne going? just wondering because I ran across ATTAPL in my library earlier and it's mentioned in a chapter :]
10:45:46 <Haskell_Noob> ah, but it won't. It is propped up by a huge corporation. It is taught in most universities as the definition of OO programming. And OO programming is taught as the only "right" way of doing things.
10:45:47 <Baughn> "What will we do today, Brian?" "Same as we do every day, Nikyp. Try not to take over the world."
10:45:51 <EvilTerran> once haskell becomes too static ofr people's liking
10:46:02 <mmorrow> thoughtpolice: gah! i'm having an epic cabalizing it.
10:46:04 <EvilTerran> *for the PhD's liking
10:46:18 <mmorrow> thoughtpolice: now that we're talking about it though, perhaps you can help.
10:46:23 <ehtom> Haskell_Noob: I don't know why so many universities like java so much
10:46:37 <zachk> java=jobs for programmers
10:46:41 <EvilTerran> i think many of them teach it primarily for employability
10:46:48 <subconscious> because object orientation solves all the problems of programming
10:46:52 <subconscious> obviously!
10:46:58 <EvilTerran> or, as zachk puts it so elegantly, "java=jobs" :P
10:46:59 <cads> hrm
10:47:02 <ehtom> OO is a tool, nothing more
10:47:10 <zachk> my java instructor is scared by recursion, i can just tell
10:47:11 <Haskell_Noob> Heh, thats why I am here, got so sick of that being drilled into my head.
10:47:23 <Vq^> ehtom: NO! it is the ultimate thingiemajig!
10:47:29 <thoughtpolice> i like larry wall's quote - 'the software world is still looking for a silver bullet that will let people write correct software without thinking. instead, we need to teach people to think.'
10:47:30 <EvilTerran> i like oxford's teaching of java
10:47:44 <lament> cads: the technical foundation is solid, the hype is inexcusable. Apple's replacement for .Mac now has a cloud icon. Everybody is anxious to produce a cloud-something. People are looking for excuses to call things clouds.
10:48:00 <EvilTerran> the lecturer mentioned the fragile base-class problem as a demonstration of a fundamental flaw in the principles of OO
10:48:01 <olsner> zachk: just write an interpreter for a subset of haskell in the first laboration, then write the rest of your java assignments in haskell :)
10:48:16 <zachk> its for people who measure productivity by line of code an hour by programmers. we need an army of programmers to solve our problem. mmm object specifications, design design design mmmm control for manament
10:48:22 <subconscious> olsner: I don't find that java syntax is very suitable for an embedding
10:48:24 <EvilTerran> (and explained and demonstrated it thoroughly)
10:48:28 <zachk> olsner i thought of that
10:48:55 <EvilTerran> and also brought up the problem with assigning to arrays potentially causing a run-time type error
10:48:57 <FunctorSalad> EvilTerran: link?
10:49:04 <EvilTerran> thus showing that java is broken as well as OO
10:49:09 <FunctorSalad> ("fragile base-class problem")
10:49:31 <cads> I just want a distributed webserver that's completely anonymized across participating peers, to which I can upload my law violating information (if that's what I so choose to do), and have it be transparently _there_, forming a virtual website
10:49:34 <subconscious> "broken" simply because its not type safe?
10:49:52 <EvilTerran> FunctorSalad, http://c2.com/cgi/wiki?FragileBaseClassProblem
10:49:53 <lambdabot> Title: Fragile Base Class Problem
10:50:04 <mmorrow> ok, so assume a library and the cayenne executable itself have been built under cabal just fine. now, i build all the *.cy base libraries for cayenne itself. once this is done, i need to get cabal to install /these/ files somewhere where the cayenne exec can access them. the problem is, these files reside in a directory tree instead of simply being a list of files, and it doesn't seem cabal supports making copying anything other tha
10:50:04 <mmorrow> n a list of files to the dataDir (???)
10:50:10 <FunctorSalad> EvilTerran: thanks
10:50:11 <Baughn> cads: Amazing. I want the exact same thing.
10:50:13 <EvilTerran> subconscious, because it claims to be statically typed, but you can get run-time type errors without using explicit casts anywhere
10:50:21 <olsner> Baughn, cads: me too :)
10:50:32 <lament> subconscious: in the case of java, yes, pretty much, because type-safety is supposed to be its main feature, compensating for the various inconveniences and shortcomings
10:50:48 <EvilTerran> cads, Baughn, olsner: isn't that kinda like Freenet?
10:50:56 <Baughn> EvilTerran: Except it'd work
10:51:01 <EvilTerran> fair point
10:51:10 <cads> hehe
10:51:14 <olsner> and I want it to be usable as a web application platform
10:51:23 <Baughn> Freenet has some good ideas, but the execution is lacking. Also, it sucks entirely too much cpu time.
10:51:41 <EvilTerran> Baughn, and wallclock time, from what i hear
10:51:42 <cads> as far as I'm concerned, cloud computing seems like a step towards crypto-anarchism, and I can forgive the hype a little
10:51:44 <Baughn> Hey, perhaps that could be haskell's killer app?
10:51:54 <Baughn> EvilTerran: That's the "lacking execution", yes
10:52:11 <thoughtpolice> mmorrow: it sounds like you might have to write a hook in Setup.hs, but that stuff is pretty fragile normally i'm afraid :[
10:52:14 <ehtom> EvilTerran: i'm not sure I consider the fragile base class problem as described on that page as 1. A problem or 2. "Proof that OO is b0rken!!"
10:52:17 <thoughtpolice> mmorrow: tried askin dcoutts_?
10:52:26 <cads> true, distributed, unstoppable crypto-anarchism, rather
10:52:36 <mmorrow> thoughtpolice: oh, i already have extensive hookage in Setup.hs
10:52:42 <EvilTerran> ehtom, calm down, you're overstating my original point somewhat
10:52:48 <Baughn> ehtom: To people who assume that OO is the solution to everything, the fragile base class is indeed proof that it is broken
10:52:55 <mmorrow> thoughtpolice: not about this in particular yet, but good idea
10:54:00 <subconscious> ehtom: I agree
10:54:14 <EvilTerran> ehtom, the problem (as i understand it) only occurs when you have a subclass relying on internals of the base class
10:54:24 <EvilTerran> i find this happening very frequently in OO settings
10:54:29 <ehtom> all that page says is "If your shared libraries are written by people who change things all the time without adhering to a proper specification, it may require you to do some massive grep expression on your code to change a function name"
10:54:38 <cads> Baughn: I think you could use haskell to come up with a mathematically provably amazing solution to anonymous distributed computing :)
10:54:59 <mmorrow> @seen dcoutts_
10:54:59 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts_ last spoke.
10:55:19 <mmorrow> @seen preflex
10:55:20 <lambdabot> Last time I saw preflex was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
10:55:20 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_
10:55:20 <lambdabot> ru, #jhc, #jtiger, #macosx, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 24d 20h 1m 17s ago, and .
10:55:37 <Baughn> ..whoops
10:55:38 <EvilTerran> ehtom, http://c2.com/cgi/wiki?InheritanceBreaksEncapsulation (which was linked to by the other page) explains my understanding of the problem better
10:55:38 <lambdabot> Title: Inheritance Breaks Encapsulation
10:56:02 <EvilTerran> well, differently
10:56:41 <FunctorSalad> isn't the moral simply that fixed interfaces are a good thing?
10:56:43 <ehtom> cads: I think in the current climate, designing such a system could get you in trouble
10:56:51 <ehtom> cads: particularly in the UK
10:57:23 <EvilTerran> ehtom, the problem as i understand it is that a subclass' behaviour may break even if you change none of the methods it uses or overrides
10:57:34 <mmorrow> ehtom: technology shouldn't be artificially crippled by such things
10:57:56 <mmorrow> ehtom: hmm, the /designer/ could get in trouble !?
10:58:09 <cads> I'd be willing to go to jail for it if the damn thing just got out an was not able to be killed
10:58:12 <EvilTerran> ehtom, as in, by adding a method to the superclass that fiddles with the internal state, when the subclass is trying to monitor all changes to the internal state
10:58:17 <EvilTerran> for example
10:58:42 <ehtom> EvilTerran: yeah, but I don't really understand why you see that as a problem?
10:59:06 <subconscious> It's like saying "recursion is proof that fp fails because sometimes it doesn't terminate"
10:59:06 <mmorrow> cads: the only way i can see that you could go to jail for that is if you live in a country with a repressive government
10:59:07 <cads> thought I agree with mmorrow in wondering how the designer would get in trouble
10:59:33 <subconscious> what are you being arrested for?
10:59:34 <EvilTerran> overloading a non-abstract method in a subclass breaks encapsulation
10:59:49 <mmorrow> <cads> Baughn: I think you could use haskell to come up with a mathematically provably amazing solution to anonymous distributed computing :)
10:59:53 <EvilTerran> potentially badly
11:00:12 <EvilTerran> without any developer doing anything that looks particularly like bad practice
11:00:16 <mmorrow> i mean, researches in crypto are constantly working toward such a goal every day
11:00:21 <mmorrow> *researchers
11:00:23 <cads> well, I guess it could be a seditious act
11:00:27 <subconscious> the prime search already does this
11:00:34 <subconscious> SETI does this
11:00:47 <subconscious> GIMPS is what it is colled
11:00:53 <ehtom> EvilTerran: All it means is that you have to trust whoever writes your base classes
11:01:11 <mmorrow> secure multiparty communication is particularly interesting
11:01:23 <cads> seti and the mersenne prime search don't allow anonymous code to travel freely through systems
11:01:26 <EvilTerran> ehtom, what, to not add an obvious convenience method in the next version etc/
11:01:26 <EvilTerran> ?
11:01:33 <ehtom> EvilTerran: I mean, someone could introduce a bug into the JVM breaking your code... there could be an OS or processor bug that breaks your code... how is that different?
11:01:39 <subconscious> cads: Do you claim that code and data are different things?
11:01:53 <EvilTerran> ehtom, because it could be designed out of the language
11:02:02 <ehtom> EvilTerran: no, to make documentation that says how the class is expected to behave and to stick to that documentation
11:02:05 <EvilTerran> ehtom, but accidental bugs cannot be designed out by their very nature
11:02:10 <cads> god forbid that I claim that, that would be counter to the whole point of the dream :D
11:02:41 <EvilTerran> ehtom, well, good luck with that
11:02:59 <Feuerbach> Is it possible to read (binary) directly into [Word8]? If not, how do I transform String to [Word8]?
11:03:05 <cads> it's that seti and gimps are very specific and defined computing models, and also not anonymous and for all people to use
11:03:24 <Baughn> Feuerbach: Directly? How about via a lazy bytestring?
11:04:56 <mmorrow> , fmap (toEnum . fromEnum) "asdf" :: [Word8]
11:04:57 <lunabot>  [97,115,100,102]
11:05:07 <mmorrow> , fmap (toEnum . fromEnum) "asdf\23456" :: [Word8]
11:05:08 <lunabot>  luna: Enum.toEnum{Word8}: tag (23456) is outside of bounds (0,255)
11:05:35 <Feuerbach> Baughn: I'm going to pass that to 'decode' then, so I'm not sure I'll gain anything from using ByteString..
11:05:39 <subconscious> ♪ toEnum . fromEnum . "asdf" :: [Word8]
11:05:39 <lunabot>      Couldn't match expected type `a -> b'
11:06:05 <cads> I for one would give up my computer's idle time to anonymous distributed processes being run by whoever, if the model was proven safe, and gave me the ability to inject my own code
11:06:51 <mmorrow> i think "autonomous agents" or that general idea is extremely interesting and cool
11:08:13 <mmorrow> , fmap (fromIntegral . ord) "asdf\23456" :: [Word8]
11:08:14 <lunabot>   Not in scope: `ord'
11:08:18 <mmorrow> bah
11:09:15 <mmorrow> , fmap (fromIntegral . ord) "asdf\23456" :: [Word8]
11:09:16 <lunabot>  [97,115,100,102,160]
11:09:35 <mmorrow> , fromIntegral (maxBound::Int) :: Word8
11:09:36 <lunabot>  255
11:10:09 <mmorrow> , fromIntegral (maxBound::Int - 1) :: Word8
11:10:09 <lunabot>   parse error on input `-'
11:10:16 <mmorrow> , fromIntegral ((maxBound::Int) - 1) :: Word8
11:10:17 <lunabot>  254
11:12:15 <EvilTerran> (maxBound - 1 :: Int) would work, too, 'cos of inference
11:13:08 <mmorrow> true
11:13:44 <Beelsebob> hang on... is there more than one type which is both Integral and Bounded?
11:13:55 <EvilTerran> Int
11:13:56 <mmorrow> hmm
11:14:00 <mmorrow> ?index Bounded
11:14:01 <lambdabot> Prelude
11:14:04 <EvilTerran> Int8, Int16, Int32, Word8, Word16, Word32
11:14:04 <mmorrow> err
11:14:10 <Beelsebob> ah, k
11:14:15 <mmorrow> ?instances Bounded
11:14:16 <Beelsebob> hadn't thought about them EvilTerran
11:14:16 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
11:14:31 <mmorrow> ?instances Integral
11:14:32 <lambdabot> Int, Integer
11:14:45 <Beelsebob> ?classes Int
11:14:45 <lambdabot> Unknown command, try @list
11:14:50 <mmorrow> is that from hoogle?
11:14:53 <Beelsebob> that sooooo is a necessary \bot command
11:15:04 <EvilTerran> Beelsebob, it should be ?coinstances :P
11:15:11 <Beelsebob> hehe, that would work
11:15:16 <Beelsebob> ?coinstances Int
11:15:16 <lambdabot> Couldn't find class `Int'. Try @instances-importing
11:15:29 <Beelsebob> @instances-importing Int
11:15:30 <lambdabot> Couldn't find class `Int'. Try @instances-importing
11:15:39 <mmorrow> @help hoogle
11:15:39 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
11:15:46 <mmorrow> @help instances
11:15:47 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
11:15:53 <Beelsebob> @help coinstances
11:15:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:16:06 <EvilTerran> ?instances-importing Data.Word Bounded
11:16:07 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a, Word, Word16, Word32, Word64, Word8
11:16:13 <mmorrow> @hoogle (a :: Integral)
11:16:14 <Beelsebob> ah, I see
11:16:16 <EvilTerran> ?instances-importing Data.Word Integral
11:16:21 <lambdabot> Parse error:
11:16:23 <lambdabot>   --count=20 "(a :: Integral)"
11:16:25 <lambdabot>                 ^
11:16:27 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
11:16:30 <Beelsebob> o.O
11:16:32 <mmorrow> heh
11:16:55 <chrisdone> Baughn: that problem I had with the memory usage going up and up. it stops going up at 19MB or so
11:17:09 <mmorrow> @hoogle `ls -la` (a :: Integral)
11:17:09 <lambdabot> Parse error:
11:17:09 <lambdabot>   --count=20 "`ls -la` (a :: Integral)"
11:17:09 <lambdabot>              ^
11:17:12 <Feuerbach> mmorrow: omnicodec is using fromIntegral.ord
11:17:18 <mmorrow> @hoogle `ls -la`
11:17:18 <lambdabot> Parse error:
11:17:18 <lambdabot>   --count=20 "`ls -la`"
11:17:18 <lambdabot>              ^
11:17:24 <mmorrow> hmm, windows?
11:17:25 <Feuerbach> I guess it's safe to use with hGetContents
11:17:30 <chrisdone> upgrade your lambdabot?
11:18:01 <mmorrow> how do you do `...` in cmd.exe ?
11:18:21 <chrisdone> I had that exact error with GHCi on ACID, turned out my lambdabot was out of date with the new hoogle
11:20:10 <mmorrow> Feuerbach: ByteString.Internal.c2w also uses fromIntegral.ord
11:20:39 <mmorrow> (or an equiv ghc-ification depending on a #ifdef)
11:26:14 <Phyx-> hi, does anyone know what the proper way to call translate is in glut? translate (Vector3 -4 -4 0::GLfloat) seems to create a type error
11:26:38 <Zao> Phyx-: Spam parens around the negative numbers?
11:27:02 <Phyx-> it's actually a type error of what results from Vector3
11:27:07 <Phyx-> it expects an IO()
11:27:30 <Phyx-> well, actualy
11:27:33 <Phyx-> lemme try that
11:27:57 <mmorrow> , (+) -4 -4
11:27:57 <lunabot>      No instance for (Num (a -> a -> a))
11:28:04 <mmorrow> , (+) (-4) (-4)
11:28:05 <lunabot>  -8
11:28:12 <Phyx-> nope, still error
11:28:13 <Phyx-> Couldn't match expected type `GLfloat'
11:28:14 <Phyx->        against inferred type `Vector3 a'
11:28:43 <Feuerbach> Phyx-: remove GLFloat annoutation
11:29:56 <Phyx-> now i get another one
11:30:10 <Phyx-> Ambiguous type variable `c' in the constraints: `Num c' arising from a use of `negate' at gfx.hs:34:22-23
11:30:21 <Phyx-> now it says add a type signature
11:30:24 <subconscious> I can only be attributed to human error
11:30:41 <Feuerbach> okay, change GLFloat to Vector3 GLFloat
11:32:24 <subconscious> @farbar
11:32:24 <lambdabot> Make hay while the apple is ripe.
11:32:27 <subconscious> @farbar
11:32:28 <Phyx-> same error as what i had originaly now
11:32:28 <lambdabot> You're not going to get anymore until you've eaten what you've already eaten.
11:32:34 <Phyx-> still a type error
11:33:10 <Feuerbach> maybe just Vector3 Float?
11:33:18 <Feuerbach> I can't find the docs
11:33:32 <Phyx-> well, they type of translate is
11:33:32 <Phyx-> (MatrixComponent c) => Vector3 c -> IO ()
11:33:56 <subconscious> hwat are the MatrixComponent?
11:34:07 <Feuerbach> what's the definition of Vector3?
11:34:11 <int-e> (Vector3 1 2 3 :: Vector3 GLfloat)
11:34:29 <int-e> oh.
11:34:58 <Feuerbach> Phyx-: Vector3 Float should work
11:35:10 <Phyx-> actually, int-e's one compiled
11:35:32 <Phyx-> seems the - are the problem
11:35:41 <subconscious> - is the problem of haskell
11:35:47 <subconscious> and typeclassess
11:35:49 <int-e> GLfloat is just a type alias for Float anyway.
11:35:58 <Feuerbach> Phyx-: oh, didn't you put parens?
11:36:04 <Phyx-> yeah i did
11:36:21 <Phyx-> but i had  :: Vector3 GLfloat at the wrong area
11:36:26 <int-e> (Vector3 (-4) (-4) 0 :: Vector3 GLfloat)
11:36:29 <Phyx-> thanks, works now :)
11:36:33 <int-e> ok.
11:39:47 <Phyx-> i have another small question. the program doesn't seem to quit when i close the window. but the tutorial makes no mention of this behaviour
11:46:53 <mmorrow> subconscious: how do you mean typeclasses?
11:51:29 <mmorrow> @src Show Doc
11:51:29 <lambdabot> Source not found. There are some things that I just don't know.
11:51:34 <mmorrow> @src Doc Show
11:51:34 <lambdabot> Source not found. stty: unknown mode: doofus
11:51:53 <mmorrow> @src Show Int
11:51:53 <lambdabot> Source not found.
11:57:51 <int-e> Phyx-: the GLUT mainLoop function should finish when the last window is gone. (works for me)
11:58:01 <hackage> Uploaded to hackage: CLASE 2008.9.23.1
11:59:12 <Beelsebob> Phyx-: what platform are you talking about?
12:02:13 <Phyx-> Beelsebob: windows
12:02:28 <Phyx-> int-e: here i have to terminate the process manually
12:02:53 <Beelsebob> Phyx-: and are you running within ghci?
12:03:44 <Phyx-> Beelsebob: no, compiling with ghc
12:04:01 <Phyx-> basically i do this
12:04:02 <Phyx-> ghc -package GLUT gfx.hs -o gfx.exe; ./gfx.exe
12:04:04 <igel> is there some (preprocessor-)trick to find out the name of the current module?
12:04:34 <igel> the idea is to provide precise error messages, but modules tend to be renamed during development :)
12:10:10 <mmorrow> igel: you can do it with template-haskell
12:10:32 <mmorrow> depending on what version of ghc you have, it's done two different ways
12:10:41 <igel> can you give me a hint where to start?
12:10:42 <mmorrow> with <=6.8.*
12:10:51 <mmorrow> currentModule :: Q String
12:10:56 <mmorrow> with >=6.9
12:11:06 <mmorrow> location :: Q Loc
12:11:26 <mmorrow> and
12:11:26 <mmorrow> data Loc
12:11:27 <mmorrow>   = Loc {loc_filename :: String,
12:11:27 <mmorrow>          loc_package :: String,
12:11:27 <mmorrow>          loc_module :: String,
12:11:27 <mmorrow>          loc_start :: CharPos,
12:11:28 <mmorrow>          loc_end :: CharPos}
12:11:56 <mmorrow> so say you want to have (at the top level):
12:12:07 <mmorrow> thisModule :: String
12:12:11 <mmorrow> you'd do
12:12:24 <mmorrow> thisModule = $(currentModule)
12:12:29 <mmorrow> err, oops
12:12:41 <subconscious> ♪ $(currentModule)
12:12:42 <lunabot>   Not in scope: `currentModule'
12:12:45 <mmorrow> thisModule = $(litE . stringL =<< currentModule)
12:12:55 <mmorrow> lunabot has a newer ghc
12:13:15 <mmorrow> , $(litE . stringL . loc_module =<< location)
12:13:16 <lunabot>  ":Interactive"
12:13:29 <mmorrow> , $(lift . loc_module =<< location)
12:13:30 <lunabot>  ":Interactive"
12:13:35 <mmorrow> oh,
12:13:41 <mmorrow> igel: you can just do
12:13:50 <mmorrow> thisModule = $(lift =<< currentModule)
12:14:14 <igel> what's the meaning of "$"?
12:14:22 <EvilTerran> Template Haskell splice
12:14:27 <mmorrow> it splices an expression in
12:14:31 <EvilTerran> > [| 1 |]
12:14:32 <lambdabot>   mueval: Prelude.read: no parse
12:14:37 <EvilTerran> , [| 1 |] -- even
12:14:38 <lunabot>   parse error (possibly incorrect indentation)
12:14:41 <EvilTerran> no?
12:14:49 <vininim> , [1]
12:14:49 <lunabot>  [1]
12:14:50 <mmorrow> oh, crap i think it's because of the comment
12:14:55 <EvilTerran> , [| 1 |]
12:14:55 <mmorrow> gotta fix that...
12:14:57 <lunabot>  LitE (IntegerL 1)
12:15:05 <EvilTerran> hehe
12:15:20 <mmorrow> , $(tupE (fmap lift [0..12]))
12:15:21 <lunabot>      Ambiguous type variable `a' in the constraints:
12:15:24 <EvilTerran> igel, [| ... |] and $( ... ) are (approximate) inverses in TH
12:15:24 <mmorrow> , $(tupE (fmap lift [0..12::Int]))
12:15:25 <lunabot>  (0,1,2,3,4,5,6,7,8,9,10,11,12)
12:15:32 <mmorrow> , tupE (fmap lift [0..12::Int])
12:15:33 <lunabot>  TupE [LitE (IntegerL 0),LitE (IntegerL 1),LitE (IntegerL 2),LitE (IntegerL 3...
12:15:51 <subconscious> ♪ ) << unsafePerformIO (kill everyone) --
12:15:52 <lunabot>   parse error (possibly incorrect indentation)
12:15:59 <mmorrow> and $([| .... |]) is just ....
12:16:08 <mmorrow> , $([|42|])
12:16:09 <lunabot>  42
12:16:26 <EvilTerran> igel, [|...|] contains an expression and yields its parse tree, and $(...) splices the contained parse tree into the parse tree of the surrounding code at compile-time
12:16:35 <mmorrow> , $([|show $(lift 42)|])
12:16:36 <lunabot>      Ambiguous type variable `t' in the constraints:
12:16:41 <mmorrow> , $([|show $(lift (42::Int))|])
12:16:42 <igel> hmm do you happen to know a nice tutorial/introduction to template haskell? the thing is, i have no idea about it :D
12:16:42 <lunabot>  "42"
12:17:23 <mmorrow> there are a few papers which may or may not be good "intros", depending on how you mean. i'll find the links
12:17:47 <mmorrow> unfortunately most of the papers use the old TH syntax, which has since been updated
12:18:12 <EvilTerran> does lunabot have ?type and ?let equivalents?
12:18:31 <mmorrow> igel: (but you should be able to get the module name without knowing anything about th)
12:18:47 <mmorrow> EvilTerran: no, lunabot only has eval
12:18:55 <mmorrow> (for now)
12:19:38 <igel> mmorrow: yes, but th is something i plan to get familiar with since a year or so
12:19:51 <mmorrow> igel: awesome. th is great.
12:19:56 * mmorrow finds those links
12:19:59 <SamB_XP_> ♪ ) << unsafePerformIO (kill everyone) (
12:20:00 <lunabot>   Not in scope: `<<'
12:20:00 <lunabot>  <interactive>:1:55: Not in scope: `unsafePerformIO'
12:20:10 <EvilTerran> , $(let roll 0 = [| id |]; roll i = [| \f -> $(roll (i-1)) . flip f |] in roll 3) f a b c :: Expr
12:20:10 <lunabot>   Not in scope: `f'
12:20:10 <lunabot>  <interactive>:1:132: Not in scope: `a'
12:20:15 <SamB_XP_> ♪ ) unsafePerformIO (print "hi!") (
12:20:16 <lunabot>   Not in scope: `unsafePerformIO'
12:20:16 <EvilTerran> bah
12:20:25 <EvilTerran> , $(let roll 0 = [| id |]; roll i = [| \f -> $(roll (i-1)) . flip f |] in roll 1) (,,) 1 2 3
12:20:26 <igel> what is lunabot, by the way? new version of lambdabot?
12:20:26 <lunabot>  (2,1,3)
12:20:30 <EvilTerran> , $(let roll 0 = [| id |]; roll i = [| \f -> $(roll (i-1)) . flip f |] in roll 2) (,,) 1 2 3
12:20:31 <lunabot>  (3,1,2)
12:20:32 <SamB_XP_> igel: heh
12:20:46 <EvilTerran> igel, there's a nice clear TH function
12:20:48 <EvilTerran> (IMO)
12:21:01 <mmorrow> no, just a bot i hacked together which communicates with an interactive evaluator i wrote which uses the ghc-api to compile expressions
12:21:15 <igel> i see
12:21:29 <mmorrow> , [|\x -> x|]
12:21:30 <lunabot>  LamE [VarP x_0] (VarE x_0)
12:21:39 <EvilTerran> actually, it'd probably be wise to write "roll i | i > 0 =" in place of "roll i ="
12:21:44 <SamB_XP_> mmorrow: and yet it doesn't enforce that they are syntactically valid!
12:21:49 <subconscious> weird mix of epigram and agda --- utterly confusing
12:22:04 <mmorrow> SamB_XP_: that what are syntactically valid?
12:22:14 <SamB_XP> mmorrow: the so-called expressions!
12:22:21 <SamB_XP> , )(
12:22:21 <lunabot>      Couldn't match expected type `() -> a'
12:22:24 <mmorrow> hmm, i don't know what you mean
12:22:33 <SamB_XP> mmorrow: look
12:22:35 <SamB_XP> see
12:22:36 <mmorrow> ah, it'll be clear what's happening if you see the src
12:22:38 <EvilTerran> , join (,)) (
12:22:39 <lunabot>      Couldn't match expected type `() -> a'
12:22:46 <SamB_XP> mmorrow: it is clear what is happening
12:22:51 <EvilTerran> , (join (,)) ()
12:22:52 <lunabot>  ((),())
12:22:53 <EvilTerran> hm
12:23:00 <SamB_XP> what's happening is that you are sticking together strings and just hoping for the best
12:23:09 <SamB_XP> ... just like lambdabot used to do ;-)
12:23:12 <mmorrow> (it wraps the expression string in "show ("++e++")" as a convenience to the person writing that expression
12:23:13 <EvilTerran> evidently it's not quite how i thought
12:23:19 <EvilTerran> i see
12:23:47 <igel> ok thank you
12:23:53 <mmorrow> since it compile with dynCompileExpression, the only way the (assuming ghc accepts it) expression will ever be run is if its type is String
12:23:58 <SamB_XP> , )++("hehehe!")
12:23:59 <lunabot>   parse error on input `)'
12:24:00 <SamB_XP> , )++("hehehe!"
12:24:01 <lunabot>  ()hehehe!
12:24:02 <subconscious> ♪ ( ++ const "X" (
12:24:02 <lunabot>   parse error (possibly incorrect indentation)
12:24:09 <subconscious> ♪ ) ++ const "X" (
12:24:10 <lunabot>  ()X
12:24:13 <EvilTerran> igel, did that TH example (roll) make sense to you?
12:24:19 <mmorrow> youo can't inject code because there's no surrounding context to inject code into
12:24:41 <igel> not quite
12:24:44 <SamB_XP> mmorrow: still!
12:24:49 <SamB_XP> we can inject code
12:24:53 <EvilTerran> mmorrow, hm, i'm guessing you can't have it yield something of type (exists a. Show a => a) somehow?
12:24:55 <SamB_XP> it just ... can't do a whole lot
12:24:56 <mmorrow> SamB_XP: still what?
12:25:06 <SamB_XP> hehehehe
12:25:08 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=52
12:25:13 <mmorrow> the evaluator ^^
12:25:24 <SamB_XP> , ))((
12:25:24 <lunabot>      Couldn't match expected type `() -> t'
12:25:44 <SamB_XP> , )) ++ ((""
12:25:44 <lunabot>      Couldn't match expected type `[a]' against inferred type `Dynamic'
12:25:50 <EvilTerran> r <- dynCompileExpr sess ("show (" ++ s ++ ")")
12:25:56 <EvilTerran> would be the relevant line
12:26:03 <SamB_XP> ... whoa ...
12:26:12 <mmorrow> even if you somehow manage to subvert the "show (   )", it doesn't change the fact that your expression must be of type String
12:26:15 <SamB_XP> that DOES NOT look GOOD ...
12:26:32 <SamB_XP> mmorrow: it's not a question of "if"
12:26:32 <subconscious> @yow
12:26:33 <lambdabot> My haircut is totally traditional!
12:26:39 <SamB_XP> , ))) ++ (((""
12:26:39 <lunabot>   parse error on input `)'
12:27:07 <mmorrow> SamB_XP: the show wrapping is there /only as a convenience to you/ so you don't have to wrap your expression in show manually
12:27:10 <mmorrow> , print 42
12:27:11 <lunabot>      No instance for (Show (IO ()))
12:27:16 <mmorrow> , 42
12:27:17 <lunabot>  42
12:27:24 <SamB_XP> @pl flip const
12:27:24 <lambdabot> const id
12:27:27 <EvilTerran> SamB_XP, from looking at line 77 of that (the line i pasted), i don't see how there could be a problem
12:27:28 <SamB_XP> rats
12:27:30 <mmorrow> you would have to do (if i removed the show wrap)
12:27:34 <mmorrow> , show 42
12:27:34 <lunabot>  "42"
12:27:36 <mmorrow> for
12:27:37 <mmorrow> ,42
12:27:38 <lunabot>  42
12:28:01 <mmorrow> or else fromDynamic would return Nothing
12:28:15 <EvilTerran> mmorrow, does ghc-api no longer allow use of qualified un-imported names?
12:28:46 <SamB_XP> apparantly dynCompileExpr itself uses string concatenation internally ...
12:28:48 <subconscious> i wonder why you don't get an AST and feed _that_ into an evaluator rather than a string
12:28:57 <mmorrow> dynCompileExp doesn't, but i thinkn runStmt does
12:29:24 <RayNbow> @bot
12:29:24 <lambdabot> :)
12:29:26 <mmorrow> subconscious: because ghc takes a String of src as input, instead of the AST
12:29:29 <SamB_XP> mmorrow: I'm not talking about such details as where the code is, just that it happens when you use dynCompileExpr
12:29:32 <rwbarton> , ) `const` (3
12:29:32 <lunabot>  ()
12:29:37 <SamB_XP> I can see it from that type error
12:29:57 <SamB_XP> , )) `const` (("hi!"
12:29:58 <lunabot>  ()
12:29:59 <rwbarton> , ) `seq` (3
12:30:00 <lunabot>  luna: no output
12:30:14 <rwbarton> , ) `seq` ("3"
12:30:15 <lunabot>  3
12:30:16 <SamB_XP> , )) `seq` (("hi!"
12:30:16 <lunabot>  Killed.
12:30:23 <rwbarton> , ) `seq` unsafePerformIO (return 2) `seq` ("3"
12:30:24 <lunabot>   Not in scope: `unsafePerformIO'
12:30:31 <SamB_XP> , )) `seq` ((toDyn 1
12:30:31 <lunabot>  luna: no output
12:30:40 <SamB_XP> hmm?
12:30:49 <rwbarton> too many parens probably?
12:31:00 <SamB_XP> rwbarton: no!
12:31:12 <rwbarton> , ) `seq` (toDyn 1
12:31:12 <lunabot>  luna: no output
12:31:25 <SamB_XP> , toDyn 1
12:31:25 <lunabot>  <<Integer>>
12:31:41 <rwbarton> Some kind of type error, then
12:31:53 <SamB_XP> , )) `seq` ((toDyn "bye!"
12:31:53 <lunabot>  bye!
12:32:16 <mmorrow> SamB_XP: i'll paste the code to dynCompileExp (from GHC.hs). but i still don't see your concern. The only way to eval an expression which results in a type String which is evil is to somehow have access to unsafePerformIO (an an equivalent). if no such way is possible given the in-scope function, then it's impossible to subvert it. i believe no such way is possible given the in-scope functions.
12:32:25 <SamB_XP> well, it doesn't do anything unless it's actually a String ...
12:32:33 <mmorrow> exactly
12:32:46 <int-e> > toDyn
12:32:46 <lambdabot>   mueval: Unsafe functions to use mentioned.
12:33:07 <SamB_XP> why does it say "no output", though, rather than complaining that the returned Dynamic was of unexpected type ?
12:33:11 <rwbarton> , ) `seq` ("I don't need the say function any more"
12:33:12 <lunabot>  I don't need the say function any more
12:33:47 <ehtom> how do I use seq?
12:33:58 <subconscious> ehtom: what do you want to do with it?
12:34:00 <SamB_XP> @index TH
12:34:00 <lambdabot> bzzt
12:34:02 <SamB_XP> @index THSyn
12:34:03 <lambdabot> bzzt
12:34:06 <SamB_XP> @index runQ
12:34:07 <lambdabot> Language.Haskell.TH.Syntax, Language.Haskell.TH
12:34:15 <SamB_XP> @doc Language.Haskell.TH
12:34:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
12:34:28 <ehtom> subconscious: nothing... I've just seen it in a few places and was wondering what it does
12:34:48 <SamB_XP> whoa
12:34:56 <subconscious> there's something in the docs about it
12:35:06 <SamB_XP> I open a new tab in Chrome, and guess what I see?
12:35:06 <mmorrow> SamB_XP: here's the src to dynCompileExpr. (my bad, it's in InteractiveEval.hs, not GHC.hs) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=52#a58
12:35:09 <SamB_XP> I see ... oleg cat!
12:35:25 <mmorrow> , text "hello"
12:35:25 <lunabot>  hello
12:35:40 <mmorrow> , vcat . fmap int $ [0..9]
12:35:41 <lunabot>  0
12:35:41 <lunabot>  1
12:35:41 <lunabot>  2
12:35:47 <lunabot>      Couldn't match expected type `String'
12:36:07 <mmorrow> um, not sure where that came from...
12:36:18 <mmorrow> oh, a privmsg probably, heh
12:36:27 <mmorrow> lunabot's bot can't do those yet
12:36:38 <SamB_XP> , vcat . fmap int $ [0..9]
12:36:39 <lunabot>  0
12:36:39 <lunabot>  1
12:36:39 <lunabot>  2
12:36:48 <SamB_XP> ... what happened to the rest?
12:36:49 <subconscious> I don't understand what pattern matching on refl means in agdo
12:36:56 <lunabot>  1
12:37:01 <subconscious> it obviously does something
12:37:02 <mmorrow> i just arbitrarily decided to chop it off at 3 lines
12:37:21 <SamB_XP> subconscious: it unifies the lhs and rhs of the type ...
12:37:51 <subconscious> so that unification is what K lets you do?
12:38:03 <SamB_XP> could be!
12:38:09 <SamB_XP> but, no, wait
12:38:16 <SamB_XP> you can do that in Coq too ...
12:38:25 <SamB_XP> even without K
12:38:39 <mmorrow> , runIO (print "ahahahaha") >> [|()|]
12:38:39 <lunabot>   Not in scope: `runIO'
12:38:46 <subconscious> oh well I guess I just don't know what's going on
12:39:39 <EvilTerran> , [| runIO (print "ahahahaha") >> return () |]
12:39:39 <lunabot>   Not in scope: `runIO'
12:41:30 <mmorrow> igel: ok, here's the "old" template-haskell page http://www.haskell.org/th/
12:41:30 <lambdabot> Title: Template Haskell
12:41:53 <mmorrow> and here's a list of helpful papers (some of which have outdated syntax :() http://www.haskell.org/th/papers.html
12:41:54 <lambdabot> Title: Template Haskell papers
12:42:15 <mmorrow> pretty much:
12:42:31 <mmorrow> type ExpQ = Q Exp
12:42:39 <mmorrow> type DecQ = Q Dec
12:42:44 <mmorrow> type TypeQ = Q Type
12:42:46 <mmorrow> etc..
12:42:53 <mmorrow> [| ... |] :: ExpQ
12:43:02 <mmorrow> [d| ... |] :: Q [Dec]
12:43:08 <vininim> oh my, why citeseerx? citeseer was way better...
12:43:09 <mmorrow> [t| ... |] :: TypeQ
12:43:33 <mmorrow> and in $( ... ), the "..." must be of type ExpQ
12:43:46 <int-e> , ) `seq` (unwords . map show . (0:) . scanl (+) 1 . map read . words . flip fromDyn "" $ __dynCompileExpr
12:43:47 <lunabot>  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 1...
12:44:03 <mmorrow> , __dynCompileExpr
12:44:03 <lunabot>  <<[Char]>>
12:44:15 <mmorrow> holy shit
12:44:37 <int-e> dynCompileExpr uses let stmt = "let __dynCompileExpr = Data.Dynamic.toDyn (" ++ expr ++ ")"  :)
12:44:49 <mmorrow> still though, i don't think that is a security risk
12:44:58 <mmorrow> it's extremely cool though
12:45:13 <mmorrow> having a way to eval expressions in and evaluated expression, that is
12:45:18 <mmorrow> s/and/an/
12:45:52 <int-e> , )) `seq` ((1
12:45:53 <mmorrow> int-e: haha, nice. i just realized how that was working.
12:45:53 <lunabot>  Killed.
12:46:10 <mmorrow> hmm, maybe it /is/ a problem...
12:46:15 * mmorrow looks at the code
12:46:21 <SamB_XP> mmorrow: no, it doesn't seem to be
12:46:45 <SamB_XP> unless, of course, it's a bug in GHC ;-P
12:46:50 <igel> mmorrow: thanks!
12:47:12 <mmorrow> SamB_XP: phew
12:47:12 <SamB_XP> like they forgot to check the type of the expression, and just assume it's a Dynamic ?
12:47:15 <mmorrow> igel: np
12:48:17 <mmorrow> SamB_XP: hmm
12:48:31 <SamB_XP> ... which I guess they do
12:48:47 <Baughn> The GHC 6.10 build appears not to be propagating CPPFLAGS to all its subprocesses - it's not seeing gmp.h, which is in /sw/include (which is in CPPFLAGS)
12:49:02 <Baughn> That is to say, have any of you seen the same?
12:49:07 <SamB_XP> because I don't see the any code that seems to constrain it ...
12:49:25 <mmorrow> SamB_XP: yeah, me neither
12:49:25 <Saizan> liftIO (unsafeCoerce# hvals :: IO [Dynamic]) <-- just unsafecoerced
12:49:34 <SamB_XP> yeah ... true
12:50:05 <mmorrow> another thing is that i think i should reimplement to core part of dynCompileExpr in luna, since it appears that it pushes mkModule
12:50:05 <mmorrow>             (stringToPackageId "base") (mkModuleName "Data.Dynamic")
12:50:07 <int-e> why is it a list though?
12:50:18 <mmorrow> onto my context /every time/ an expression is evaluated
12:50:45 <mmorrow> i guess that's ok though, since it's only a one-shot evaluator for the bot though
12:51:06 <SamB_XP> mmorrow: why, is that slow or something?
12:51:35 <Saizan> int-e: i guess because a single expression can bind more than one idenitifier
12:51:50 <mmorrow> it seems to me that say you evaluate 1000 expressions with dynCompileExpr, then the context in your Session will have that as the first 1000 members of it
12:52:20 <SamB_XP> mmorrow: it resets it after!
12:52:32 <mmorrow> ahhh, nice. i missed that.
12:52:42 <SamB_XP> incidentally, that pastebin has horrific line number creep
12:52:48 <mmorrow> totally!
12:52:59 <mmorrow> i wonder how that can be fixed...
12:53:10 <Saizan> creep?
12:53:31 <SamB_XP> Saizan: the line numbers flow independant of the lines they allegedly correspond with
12:53:32 <mmorrow> the line nums begin the get more and more unaligned the more lines there are in a paste
12:53:43 <mmorrow> the code is at
12:53:51 <mmorrow> http://code.haskell.org/hpaste.git
12:54:35 <SamB_XP> well, I don't know if it CAN be fixed without forcing people to manually remove line numbers when they copy and paste from there ...
12:54:57 <mmorrow> um. wut
12:55:19 <SamB_XP> I mean, you'd have to be able to say "these line numbers go with this other text, but aren't to be copied and pasted!"
12:55:43 <SamB_XP> are there CSS styles for "don't copy this to the clipboard" or anything like that?
12:55:59 <Saizan> uhm, they look fine to me
12:56:08 <mmorrow> i don't see what the clipboard has to do with this
12:56:08 <SamB_XP> Saizan: it's a coincidence
12:56:18 <Saizan> yeah, i guess
12:56:25 <mmorrow> Saizan: they only start to unalign after a few hundred lines
12:56:33 <SamB_XP> mmorrow: well, the reason they get unaligned is because the line numbers are in a seperate vertical box
12:56:43 <mmorrow> SamB: yes
12:56:57 <SamB_XP> hehehe, here I get unalignment by 17
12:57:14 <mmorrow> hah, me too actually
12:57:30 <SamB_XP> anyway, the REASON for this is presumably so that if you select some of the code, you can copy it without the line numbers ...
12:57:55 <mmorrow> weird, in a short paste, line 17 is perfectly aligned. but in a long paste, 17 is unaligned
12:58:01 <hackage> Uploaded to hackage: garsia-wachs 1.2
12:58:21 <mmorrow> it has a "download" link as well, to get the raw paste
12:58:22 <SamB_XP> I can't see a way to keep this property while also expressing the association between line numbers and lines
12:58:30 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/raw?id=52
12:58:34 <SamB_XP> mmorrow: yeah, I know
12:58:35 <int-e> Saizan: you're right.
12:58:45 <mmorrow> so that property doesn't really matter (?)
12:59:11 <SamB_XP> well, Google Chrome shows unalignment even in the http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=52#a58 bit
12:59:30 <mmorrow> igel: oh, here's the TH page in the hsakell wiki http://www.haskell.org/haskellwiki/Template_Haskell
12:59:31 <SamB_XP> and really, you can't blame it
12:59:31 <lambdabot> Title: Template Haskell - HaskellWiki
12:59:34 <sandbox> will something like {f (x:xs) = x:(f xs), f [] = []} be optimized as a loop?
12:59:43 <SamB_XP> it's only a coindicence that it EVER seems to work!
12:59:47 <super> anyone here do machine learning and datamining?
12:59:52 <sandbox> or would you have to make an accumulator?
12:59:53 <mmorrow> SamB_XP: ah, i didn't catch you were using google chrome
13:00:00 <igel> mmorrow: i also found something: __FILE__ :)
13:00:13 <mmorrow> ohhh, yeah. i forgot about that :)
13:00:19 <geezusfreeek> super, i have done some genetic programming in the past
13:00:19 <mmorrow> good to know
13:00:26 <mmorrow> (@igel)
13:00:29 <super> is haskell good for number crunching? i would like to not have to write my numbercrunching code in c/c++ or fortran
13:00:37 <geezusfreeek> but it was just for fun on the side, nothing impressive
13:00:38 <mmorrow> super: use hmatrix
13:00:52 <super> geezus: cool
13:00:52 <Saizan> maybe if we use <td class="code"> also for numbers they will get formatted uniformly with the code
13:00:59 <mmorrow> super: i do and it works nicely
13:01:08 <igel> __FILE__ not very nice, but it pretends depending on th for a fairly small package
13:01:11 <mmorrow> Saizan: hmm
13:01:27 <SamB_XP> mmorrow: well, the phenomenon occurs in some form or other in every browser where the vertical metrics of monospace fonts depend on the weight, I guess
13:01:51 <igel> super: you might be interested in "ndp": nested data parallel haskell
13:01:57 <MedeaMelana> @pl \r -> hd r ++ tl r
13:01:57 <lambdabot> liftM2 (++) hd tl
13:02:02 <geezusfreeek> super, i recommend using one of the nice libraries for maths on hackage, like mmorrow suggests. ghc will also be gaining some nice data parallelization stuff soon, which will end up being nice for number crunching due to a lot of optimizations, but it isn't there yet
13:02:03 <SamB_XP> or, well, not browser, but rather situation
13:02:04 <int-e> huh. typing  :i X  (anything that isn't a type class or type) quits ghci?
13:02:06 <mmorrow> ah, i see now. just resized my font
13:02:07 <igel> it's for parallel computations on large arrays
13:02:24 <igel> but i'm not sure how stable it is by now
13:02:34 <MedeaMelana> @locate liftM2
13:02:34 <lambdabot> Unknown command, try @list
13:02:36 <mmorrow> int-e: are you using >=6.9? editline is a bitch
13:02:42 <geezusfreeek> igel, it mostly works in the 6.10 beta, except the vectorization step is still not there
13:03:27 <igel> help me out... vectorisation was the flattening of nested arrays?
13:03:40 <mmorrow> int-e: it'll quit like that /all the friggin time/ and drive you crazy :):)
13:03:44 <int-e> mmorrow: 6.8.2 (6.9 too but it's not caused by editline, I've tamed editline by now. it just leaks some memory.)
13:03:49 <mmorrow> (unless they've fixed that )
13:04:06 <mmorrow> int-e: weird then. i dunno what's causing it.
13:04:10 <MedeaMelana> lambdabot suggests (\r -> hd r ++ tl r) equals (liftM2 (++) hd tl), but I get a compiler error: No instance for (Monad ((->) Range)). What's wrong?
13:04:23 <mmorrow> i read that the editline bug that causes that is unfixable from the ghc-side :(
13:04:28 <MedeaMelana> with r :: Range in the first version
13:04:44 <EvilTerran> MedeaMelana, you need to import Control.Monad.Instances for that version to work
13:05:09 <MedeaMelana> EvilTerran: yes, beautiful, thanks. that works.
13:05:10 <mmorrow> int-e: sweet! bug is fixed
13:05:14 <mmorrow> http://hackage.haskell.org/trac/ghc/ticket/2277
13:05:17 <lambdabot> Title: #2277 (GHCi silently aborts on 'take' computation) - GHC - Trac
13:05:23 <EvilTerran> it defines an instance Monad ((->) e) where return = const; (f >>= k) r = k (f r) r
13:05:25 <geezusfreeek> igel, vectorization is the part where operations are substituted with special parallel versions
13:06:03 <EvilTerran> MedeaMelana, i'd be wary of using the ((->) e) Monad instance unless you're sure how it works, though
13:06:07 <EvilTerran> ?type liftM2
13:06:08 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:06:18 <geezusfreeek> igel, mapP someOp ==> someParOp
13:06:20 <EvilTerran> ^ that's why you need that instance
13:07:08 <igel> geezusfreeek: hmm that's a central part :(
13:07:52 <MedeaMelana> EvilTerran: thanks. I'm not doing anything incredibly interesting with it. I just wanted a prettier way of writing \r -> hd r ++ tl r.
13:07:52 <int-e> mmorrow: yes, I saw the fix. before that, editline was unusable with ghc. now it's just the histfile management that causes trouble (with glibc, and possibly depending on the editline package you're using)
13:08:21 <geezusfreeek> igel, yes it is :(
13:08:33 <mmorrow> subconscious: i just realized how you meant with your parsing suggestion for the input exp. i thought about that, then was too lazy ;)
13:10:22 <mmorrow> int-e: what's the histfile issue?
13:10:40 <int-e> mmorrow: this one, http://bugs.gentoo.org/show_bug.cgi?id=237882
13:10:42 <lambdabot> Title: Gentoo Bug 237882 - dev-libs/libedit-20050930 enters an infinite loop upon readi ...
13:11:31 <mmorrow> hmm, that page doesn't load for me. probably just my location
13:12:00 <mmorrow> if editline was a whale, i'd harpoon it for sure.
13:14:10 <Baughn> editline? Can't I use readline anymore?
13:14:37 <mmorrow> you have to decide at ghc compile-time
13:14:49 <Baughn> How?
13:15:05 <Baughn> Oh, and did I mention that it's not reading CPPFLAGS?
13:15:30 <mmorrow> and if you want readline, you've to somehow mess with some build options or something terrible like that in the worst case
13:15:40 <mmorrow> in the best case, it'll be an option to ./configure
13:16:13 <Baughn> Editline compiled and installed fine, though, so I guess it doesn't matter
13:17:05 <Igloo> You can't use readline any more
13:17:06 <mmorrow> oh, yeah you can still get the readline package and all that. the decision is just for what ghci uses.
13:17:23 <Baughn> Igloo: Problem is, editline isn't in fink. Yet.
13:17:37 <mmorrow> Baughn: build it yourself?
13:17:38 <Baughn> Not that it matters, since the configure script doesn't look for libraries in /sw
13:17:44 <Baughn> mmorrow: Just did
13:17:50 <mmorrow> nice
13:17:53 <int-e> mmorrow: you'd have to mess with  compiler/ghci/InteractiveUI.hs  I think. Or provide an editline package replacement that has the System.Console.Editline.Readline module. I havn't tried.
13:18:43 <mmorrow> int-e: dang, worse than i though. but i've actually got to know that module somewhat over the paste few weeks. i wonder...
13:23:56 <roconnor> @pl (\f g x y -> g (f x) y)
13:23:57 <lambdabot> flip (.)
13:24:16 <Deewiant> a.k.a. (>>>)
13:24:54 <MedeaMelana> I wonder how many lines of code @pl is
13:25:21 <mmorrow> more than a few. i looked at it briefly. it's way cool.
13:25:46 <MedeaMelana> I bet
13:27:46 <byte-> is there a less circuitous way of converting from an Int to a Float than '(fromInteger . toInteger)' ?
13:28:29 <bd_> byte-: fromIntegral
13:28:30 <MedeaMelana> byte: how about just fromInteger?
13:28:33 <bd_> @src fromIntegral
13:28:34 <lambdabot> fromIntegral = fromInteger . toInteger
13:28:35 <Deewiant> ?ty fromIntegral
13:28:36 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:28:37 <Deewiant> er
13:28:40 <byte-> thanks
13:28:44 <Deewiant> s/ty/src/ and too slow to boot
13:29:08 <MedeaMelana> :t fromInteger 4 :: Float
13:29:09 <lambdabot> Float
13:29:15 <byte-> thanks guys, that worked perfectly
13:29:25 <bd_> :t 4 :: Float
13:29:26 <lambdabot> Float
13:29:35 <byte-> :t (fromInteger (4 :: Int)) :: Float
13:29:36 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
13:29:37 <lambdabot>     In the first argument of `fromInteger', namely `(4 :: Int)'
13:29:47 <MedeaMelana> Oh. Okay.
13:29:52 <byte-> for some reason fromEnum returns an Int rather than an Integer
13:30:24 <MedeaMelana> Yes. No more than 2 billion values of a type for you.
13:30:33 <bd_> it really should be Integral there though
13:30:58 <bd_> > fromEnum (40000000000000 :: Integer)
13:31:00 <lambdabot>   40000000000000
13:31:06 <bd_> > fromEnum (40000000000000 * 40000000000000:: Integer)
13:31:08 <lambdabot>   -3710740494427357184
13:31:18 <bd_> Integer shouldn't be Enum otherwise :)
13:33:51 <chrisdone> I can't decide on whether an irc library should provide some abstract data type to perform operations on, like setNick foo "bar", joinChan foo "#haskell", or whether it should provide a monad/monad transformer and associated functions which work inside of it
13:34:31 <chrisdone> but I can foresee programs which maybe want to fork new threads or just not work inside an IRC monad. like changing the nickname is a one-op. do I really want to write “runIRC foo $ setNick "bar"” for all irc commands about my program? not really
13:34:37 <bd_> chrisdone: I would think operating in IO would make the most sense, probably
13:34:53 <chrisdone> do you think? hm
13:35:20 <bd_> inventing a new monad makes more sense when you'll have a lot of context going on, and want to sort of draw a border between IO operations and IRC operations IMO...
13:35:21 <Deewiant> well you have to do IO for everything anyway
13:36:56 <lunabot>  I don't need the say function any more
13:36:57 <smoofra> chrisdone: unless your IRC lib wants to interact with an in-process IRC server, just use IO
13:36:57 <bd_> Deewiant: true, I'm just saying, there's no sense introducing a new monad when it's nothing more than ReaderT IRC IO :)
13:37:13 <Deewiant> bd_: yeah, that was sort of what I was saying as well :-)
13:37:33 <chrisdone> aye fair enough
13:37:52 <chrisdone> verily, the user of such a library would put the IO value in their own monad if needed
13:37:53 <bd_> I could see IRC bot libraries built on top of an irc lib with more of a monadic scheme
13:38:12 <chrisdone> yeah
13:38:18 <chrisdone> okay, I'm convinced
13:38:36 <lunabot>  I feel cold - does anyone have any fuzzy lambdas?
13:39:05 <Blub\0> mh... is there a way to get smaller executables with ghc? *hides*
13:39:05 <bd_> chrisdone: how will you be handling events coming from the IRC lib?
13:39:07 <mc__> lunabot: http://arcanux.org/lambdacats.html
13:39:08 <lambdabot> Title: Lambdacats
13:39:27 <BMeph> bd_: That sounds like an excellent choice for a tutorial...a monad tutorial! ;)
13:39:30 <Deewiant> Blub\0: -optl-s
13:39:38 <Baughn> Blub\0: Well.. wait for 6.10, hope they get dynamic linking in?
13:39:52 <Blub\0> does -optl-s "sacrifice" speed?
13:39:52 <bd_> BMeph: Oh dear. An IRC channel management monad tutorial...? :)
13:40:00 <bd_> it'd just end up being StateT Something IO, you know!
13:40:05 <Deewiant> Blub\0: no, it just strips the resulting binary
13:40:06 <BMeph> bd_: YES! Score!
13:40:12 <Blub\0> because when the C program is 9.1K and the hs program is 594K ... :/
13:40:13 <Deewiant> alternately, run "strip" on it
13:40:26 <chrisdone> bd_: I am pondering using a Chan of Message (of Network.IRC) values, or a callback. I'm not sure
13:40:26 <Deewiant> Blub\0: but the hs program does much more
13:40:36 <Deewiant> Blub\0: run <program> +RTS --help, for instance :-)
13:40:39 <chrisdone> bd_: callback(s)
13:40:42 <BMeph> bd_: I Demand that you use MaybeT inside it somewhere... >:)
13:40:52 <bd_> chrisdone: Chan of Message sounds nice, but that can always be built with a callback
13:41:04 <bd_> trivially, at that
13:41:06 <smoofra> Baughn: dynamic linking for haskell!?  really?
13:41:15 <Blub\0> oh boi
13:41:17 <dolio> It's on the list.
13:41:26 <chrisdone> bd_: true
13:41:28 <bd_> Does the dynamic linking still work when you upgrade the libs in question? :)
13:41:32 <Blub\0> even though this is very interesting and might be useful - is there a way to disable it? :P
13:41:32 <Deewiant> Blub\0: and before you ask, no, you can't remove the RTS from your program. :-)
13:41:45 <Blub\0> right
13:42:04 <bd_> chrisdone: that said, using a Chan makes it easier to do pseudo-mixins, maybe
13:42:04 <Baughn> Blub\0: Considering that it's the moral equivalent of libc, it's not very large
13:42:17 <bd_> ie, fork the Chan and direct it to a nickserv module, then forget about it
13:42:43 <chrisdone> bd_: right
13:43:02 <bd_> using that as the primitive might be better *shrug*
13:43:05 <Blub\0> I guess only small programs seem so extreme?
13:43:13 <Blub\0> or does it grow faster too?
13:43:15 <Deewiant> Blub\0: it's a constant difference, yes.
13:43:20 <chrisdone> bd_: a chan?
13:43:27 <Blub\0> fine :)
13:44:04 <bd_> chrisdone: Yeah - or better yet a TChan
13:44:30 <bd_> that way you can make generic irc mixins that'll Just Work, no matter what the rest of your app looks like
13:44:36 <Blub\0> so how likely is it that there will be dynamic linking?
13:44:45 <bd_> (the reason I suggest a TChan is so you can wait also for a "Stop doing stuff" flag0
13:45:57 <chrisdone> bd_: I don't think I follow. wait for a“stop doing stuff” flag?
13:47:00 <bd_> chrisdone: yeah, the idea being you'd do something like result <- atomically $ (fmap Right $ readTChan ircMsgs) `orElse` (fmap Left $ readTMVar stopProcessingMessages)
13:47:09 <bd_> in your mixin
13:47:36 <chrisdone> ah I see
13:47:39 <bd_> if result is Right (), then let the thread die
13:47:55 <bd_> regular Chans don't allow for that sort of thing (without doing killThread, with all the dangers that that implies)
13:48:34 <bd_> you could always have a utility function that sets up a thread to monitor the TChan and invoke a callback when appropriate
13:49:20 <bd_> ... which could in fact be the main externally exposed hook
13:49:27 <bd_> watchIRC :: IRC -> (Message -> IO ()) -> IO (IO ()) -- invoke the returned IO action to stop
13:50:19 <bd_> or newtype the returned value to provide better safety perhaps
13:51:16 <chrisdone> so like { do end <- watchIRC irc handler; end; }  -- here `end' stops the watcher thread?
13:51:26 <bd_> right.
13:51:40 <bd_> or even mdo { end <- watchIRC irc (handler end) }
13:52:28 <EvilTerran> o.ó
13:52:33 <chrisdone> what does that mean?
13:53:06 <bd_> chrisdone: the value of end is available from the start of the mdo block (this is a GHC extension, the name of which I've forgotten)
13:53:20 <chrisdone> so the handler can now end the loop if it needs do?
13:53:25 <bd_> of course, if you force it before the watchIRC thing returns, it'll explode... which, hm, is a race condition
13:53:43 <bd_> so I guess perhaps it's best if the handler can stop it by returning something as well...
13:55:08 <chrisdone> I think it is usually a Bool
14:05:40 <Phyx-> ah, GLUT is easy to work with once you get the hang of it
14:06:45 <pao> hi!
14:07:15 <Phyx-> hi
14:07:27 <pao> how do I remove a prefix list from a list? there exists a "builtin" function?
14:07:42 <igel> :t drop
14:07:43 <lambdabot> forall a. Int -> [a] -> [a]
14:07:53 <igel> > drop 3 "abcdefg"
14:07:54 <lambdabot>   "defg"
14:08:16 <byorgey> pao: if you don't know how long the prefix is, there's also 'dropWhile'
14:08:18 <pao> igel: drop (len prefix) xs
14:08:31 <byorgey> > dropWhile (>3) [6,8,7,4,2,6,7]
14:08:32 <lambdabot>   [2,6,7]
14:08:53 <Saizan> ?ty stripPrefix
14:08:53 <pao> byorgey: thanks
14:08:54 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
14:09:10 <byorgey> Saizan: wha...? where's that from?
14:09:17 <byorgey> @index stripPrefix
14:09:18 <lambdabot> bzzt
14:09:20 <Saizan> Data.List
14:09:23 <byorgey> really!?
14:09:24 <chrisdone> > let dropPrefix = drop . length in dropPrefix "ello " "ello dave"
14:09:25 <lambdabot>   "dave"
14:09:27 <byorgey> well, I'll be
14:09:36 <sjanssen> when did they sneak that in?
14:09:39 <chrisdone> heh
14:09:50 <FunctorSalad> say I have "class SomeRelation a b"... it's not possible to close that relation under reflexivity and transitivity without having the context reducer loop like this, is it? SomeRel a b <= (Some Rel a b, SomeRel b b) <= (Some Rel a b, SomeRel b b, Some Rel b b) <= ...
14:10:12 <pao> Saizan: great :-)
14:10:34 <FunctorSalad> actually reflexivity is not even necessary
14:10:44 <FunctorSalad> (that's just transitivity)
14:11:02 <FunctorSalad> though maybe it tries SomeRel b b because of reflexivity
14:15:05 <FunctorSalad> did I say something wrong? :(
14:15:09 <FunctorSalad> ;-)
14:16:12 <Saizan> so you've instance (Rel a b, Rel b c) => Rel a c and the typechecker loops?
14:16:28 <EvilTerran> that's not surprising
14:16:41 <FunctorSalad> of course I enabled UndecidableInstances
14:16:59 <FunctorSalad> the problem is that apparently there's no way to express inequality of types
14:17:05 <EvilTerran> indeed not
14:17:16 <EvilTerran> short of incoherent instances, anyway
14:17:38 <FunctorSalad> how's it possible then?
14:17:44 <dolio> I wouldn't be too sure about that.
14:17:48 <FunctorSalad> (except enumerating all the ground types ;-))
14:17:58 <FunctorSalad> err, unequal pairs of them
14:18:24 <FunctorSalad> incoherent instances are ok if you have a coherence theorem =)
14:18:29 <EvilTerran> "{-# LANGUAGE IncoherentInstances #-}; data True; data False; instance Equal a a True; instance Equal a b False" i think will work
14:18:44 <EvilTerran> it relies on the type inferrer taking the first of the two instances
14:18:49 <dolio> It's possible oleg's TypeEq/TypeCast stuff can express type inequality without incoherent instances.
14:19:00 <FunctorSalad> (I was trying to define a cast between any different way of associating a tupling like ((a,b),(c,(d,e)))
14:19:16 <EvilTerran> FunctorSalad, ah, i've thought about similar problems myself
14:19:33 <FunctorSalad> MacLane's coherence theorem says that it doesn't matter which path you take
14:19:49 <super> are there good bindings to postgresql or mysql from haskell?
14:20:26 <EvilTerran> FunctorSalad, it seems to me that should be expressible in a way that recurses on the structure of the type
14:20:41 <EvilTerran> not sure, though
14:20:42 <FunctorSalad> (to be fair the theorem is in a more general context; here it is kinda obvious)
14:21:11 <FunctorSalad> EvilTerran: yeah, in this case we could direct the equivalence into a term rewriting system
14:21:43 <Baughn> Cabal-install seems to be hanging. I suppose I need to update it?
14:22:49 <FunctorSalad> EvilTerran: I see, with that IncoherentInstances thing you exploit that the first matching instance is always chosen?
14:22:56 <EvilTerran> yes
14:23:03 <EvilTerran> it's terrible, i know
14:23:56 <FunctorSalad> a simple solution would be to give instance declarations numeric priorities, like in coq
14:24:21 <FunctorSalad> or maybe I'm overlooking something
14:25:21 <Baughn> FunctorSalad: How would that work if you instance something a package you're using is also using, but you give yours a higher priority?
14:25:29 <FunctorSalad> @djinn (a,(b,c)) -> ((a,b),c)
14:25:29 <lambdabot> f (a, (b, c)) = ((a, b), c)
14:25:41 <FunctorSalad> cool, lambdabot could write that module for me ;-)
14:26:34 <FunctorSalad> Baughn: hmm... you mean that would require recompilation of the other package?
14:26:41 <FunctorSalad> not to mention it could break it
14:27:03 <Baughn> FunctorSalad: Obviously that would be unrealistic, but you have to figure out some semantics that are consistent while /not/ requiring recompiling anything
14:27:12 <Baughn> Incoherent instances are consistent in that they give no guarantees at all. :P
14:27:39 <dancor> has anyone ever wanted something to be a Monad (or other thing) in two ways at the same time
14:27:52 <dancor> what if i wanted lists to also be monads with return a = repeat a
14:28:01 <Baughn> dancor: That's what newtypes are for
14:28:01 <dancor> what would be a way to have it both ways
14:28:03 <FunctorSalad> dancor: newtype?
14:28:16 <dancor> but can you have both at once
14:28:35 <dancor> you def can't right, bc there is no disambiguation for (>>=) etc
14:28:50 <dancor> just a thought, i have no use case
14:28:50 <Baughn> dancor: How would ghc know which to use?
14:29:06 <dancor> well maybe overloading isn't the answer
14:29:14 <dolio> What's the bind for that monad?
14:29:28 <dancor> dolio: idk
14:29:56 <dancor> maybe transformery is the way
14:30:19 <dolio> There's an applicative functor with pure = repeat.
14:30:23 <dolio> Called ZipList.
14:30:47 <dolio> And <*> is zipWith ($) I believe.
14:30:53 <Saizan> you can extend it to a monad, taking the diagonal
14:31:15 <Saizan> well, for infinite lists, or so
14:31:44 <Apocalisp> <*> is unzip :)
14:32:03 <Saizan> unzip?
14:32:04 <Apocalisp> for a different value of "is"
14:32:10 <byorgey> yeah, making ZipList a monad only works for infinite lists, IIRC
14:32:12 <Apocalisp> ?type unzip
14:32:13 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:32:25 <Apocalisp> ?type (Control.Applicative.<*>)
14:32:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:32:26 <Saizan> i'd say it's more like zip
14:32:35 <dolio> Yeah. I seem to recall the "corresponding monad" not being very satisfying.
14:33:32 <Apocalisp> Both unzip and <*> are (Arrow a, Functor f) => f (a b c) -> a (f b) (f c)
14:33:45 <Apocalisp> no?
14:33:59 <Saizan> with Arrow (,) ?
14:34:00 <dolio> (,) isn't an arrow.
14:34:08 <Saizan> indeed.
14:34:12 <Apocalisp> Oh, bifunctor
14:34:45 <Saizan> but (->) is contravariant on the first argument
14:34:50 <Apocalisp> That's the second time I've made that mistake. dibblego, I'm catching up with you.
14:34:58 <dibblego> haha :)
14:36:03 <noteventime> What's still ATS that's leading that parallel shootout?
14:36:06 <noteventime> this*
14:36:18 <noteventime> Never heard of it before
14:36:24 <subconscious> It's a programming language
14:36:39 <noteventime> I almost guessed ;)
14:37:13 <dancor> > first (+1) (32,8)
14:37:14 <lambdabot>   mueval: Prelude.read: no parse
14:37:19 <byorgey> it's a research language with dependent and linear types... and the ability to embed snippets of C =P
14:38:10 <noteventime> Sounds fun, I wonder why I haven't heard of it before
14:38:25 <noteventime> There doesn't seem to be a wikipedia article on it:|
14:39:00 <qwr> @src msum
14:39:00 <lambdabot> msum =  foldr mplus mzero
14:40:13 <quicksilver> dolio: (,) can be an arrow in a fairly boring way, if you have Monoid on the elements.
14:40:17 <quicksilver> dolio: or something like that.
14:40:51 <dolio> arr _ = (mempty, mempty)?
14:41:30 <dolio> That isn't actually allowed by the arrow interface, of course.
14:41:42 <quicksilver> arr f = (mempty, f mempty)
14:41:51 <quicksilver> was what I was thinking of
14:41:58 <dolio> Ah.
14:42:52 <dancor> how should i  read "1.5" :: Rational  without going thru Float and worrying about truncation
14:42:58 <quicksilver> and (a,b) >>> (b',c) = (a,c)
14:43:10 <dons> > read "1.5" :: Rational
14:43:11 <lambdabot>   mueval: Prelude.read: no parse
14:43:11 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
14:43:17 <dons> > read "1%5" :: Rational
14:43:18 <lambdabot>   1%5
14:43:20 <dons> hmm
14:43:34 <dancor> i guess i'll have to read around the dot
14:43:38 <subconscious> > read "1.5" :: CReal
14:43:39 <lambdabot>   1.5
14:43:49 <quicksilver> fraid so. 1.5 isn't part of the show/read contract for rational.
14:43:50 <subconscious> > (realToFrac (read "1.5" :: CReal)) :: Rational
14:43:51 <lambdabot>   mueval: Prelude.read: no parse
14:43:51 <lambdabot>  mueval: *** Exception: CReal.toRational
14:43:54 <quicksilver> which is a bit weird since
14:43:59 <quicksilver> > 1.5 :: Rational
14:44:00 <lambdabot>   3%2
14:44:01 <quicksilver> is allowed.
14:44:07 <quicksilver> not sure if that qualifies as a bug or not.
14:44:19 <subconscious> why don't you implement toRational in CReal
14:44:22 <vininim> > 15%10
14:44:23 <lambdabot>   3%2
14:44:37 <ehtom> can I make it do arbitrary precision calculations with transcendental numbers?
14:44:40 <dolio> @type \(a,c) (b,d) -> ((a,b),(c,d))
14:44:41 <lambdabot> forall t t1 t2 t3. (t, t1) -> (t2, t3) -> ((t, t2), (t1, t3))
14:44:45 <subconscious> ehtom: yes
14:44:48 <ehtom> how?
14:44:52 <dolio> @type (&&&)
14:44:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:44:57 <subconscious> > exp pi :: CReal
14:44:58 <lambdabot>   23.1406926327792690057290863679485473802661
14:45:07 <dolio> @type (***)
14:45:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:45:15 <ehtom> CReal?
14:45:38 <dancor> ehtom: http://en.wikipedia.org/wiki/Computable_number
14:45:40 <lambdabot> Title: Computable number - Wikipedia, the free encyclopedia
14:45:57 <ehtom> oh
14:46:15 <dancor> there are only countably many, we'll never really know about almost all reals :(
14:46:31 <ehtom> I thought CReal may be something like "double from C/C++"
14:48:08 <subconscious> dancor: Actually, I think there's even less than that
14:48:14 <ehtom> not closed under supremums...
14:48:17 <subconscious> CReal uses an Integer to index into the list of digits
14:48:17 <dons> http://www.reddit.com/r/programming/comments/7348d/naming_types_simon_peyton_jones_proposal_for_a/
14:48:20 <lambdabot> Title: Naming Types: Simon Peyton Jones' proposal for a clean up of Haskell's type synt ..., http://tinyurl.com/4xymvf
14:48:20 <subconscious> oops
14:48:26 <subconscious> CReal uses an _Int_ not an Integer
14:48:28 <dancor> subconscious: less than countable?  oh bc computers are finite?
14:48:32 <subconscious> (which is trivial to fix)
14:48:39 <subconscious> no because the implementation uses fixed size integers
14:49:44 <ehtom> What sequence of computable numbers has its supremum not in the CReal's?
14:49:49 <quicksilver> subconscious: ... which is a justifiable assumption because the size of the VM is Int
14:50:17 <quicksilver> subconscious: so you can't address a list of digits longer than that, anyway.
14:50:33 <dancor> so it does come down to finite computers after all :)
14:50:44 <quicksilver> yup.
14:50:49 <dancor> everytime!
14:50:59 <subconscious> I'm less interested in what a physical computer can actually do as the meaning of the code
14:51:04 <subconscious> so Int vs. Integer matters to me
14:51:16 <dancor> fork CRealPure
14:51:42 <dancor> when computers become 128bit, will Int stay 64bit
14:52:45 <dancor> CRealPure can use camelCase instead of weird_mixing too
14:53:47 <dolio> CReal is Int -> Integer internally, I believe so there are still countably many.
14:54:36 <bd_> where's CReal in the libraries?
14:54:50 <bd_> @hoogle CReal
14:54:50 <EvilTerran> ?index CReal
14:54:50 <lambdabot> No results found
14:54:50 <lambdabot> bzzt
14:54:53 <EvilTerran> :(
14:54:58 <subconscious> http://darcs.augustsson.net/Darcs/CReal/
14:55:00 <lambdabot> Title: Index of /Darcs/CReal
14:55:06 <dolio> If it's encoded via successive approximations like the formal definition of computable reals, that is.
14:55:33 <dolio> But it can't approximate the real in question to an arbitrary degree, if that's the case.
14:56:00 <dancor> there is a commented out implementation of toRational..
14:56:08 <dancor> wat..
14:58:26 <dons> ?users
14:58:26 <lambdabot> Maximum users seen in #haskell: 516, currently: 489 (94.8%), active: 20 (4.1%)
14:58:45 <dolio> So SPJ wants to turn Haskell into Omega? :)
14:58:59 <dolio> Only with data declarations automatically being replicated at the type level.
14:59:04 <subconscious> omega :(
14:59:10 <shepheb> whoa, when did we hit 500?
14:59:14 <subconscious> I thought haskell was pretty good already
14:59:24 <dolio> That is the name, right?
14:59:47 <dolio> Omega, with kind declarations and such.
14:59:57 <subconscious> oh
14:59:57 <subconscious> However, I really want to allow this too:
14:59:58 <subconscious>  data a + b = Left a | Right b
15:00:04 <subconscious> I am all for that
15:00:04 <dancor> Data.CReal is better than CReal right?
15:01:41 <dolio> Now I'm having trouble finding it, though.
15:01:59 <subconscious> by the way does anyone know how to make cabal not produce error messages and do something useful instead?
15:02:36 <dolio> http://web.cecs.pdx.edu/~sheard/Omega/index.html here we are, I think.
15:02:38 <dancor> append >/dev/null 2>&1; ./fortune
15:02:39 <lambdabot> Title: Omega Download Page
15:03:03 <sjanssen> subconscious: that is a pretty useless question
15:04:26 <dolio> SPJ should really add 'replace "forall" with "exists" in appropriate places' to that wiki page. :)
15:05:15 <wildwobby> Hi, Im new to haskell. I tried making this program but I got an unknown error on line 5. Can someone tell me what Im doing wrong please? http://tinylink.com/?drf6vcVRMu
15:05:17 <lambdabot> Title: TINYLINK.com
15:05:32 <subconscious> wildwobby: Are you actually spamming?
15:05:41 <wildwobby> ummm no.
15:05:49 <EvilTerran> ummm yes
15:05:51 <subconscious> wildwobby: maybe that is the wrong link, please use hpaste)
15:05:52 <EvilTerran> minicity
15:06:06 <wildwobby> Oh crap, yeh, wrong tinylink, shit sorry
15:06:08 <wildwobby> one second.
15:06:09 <EvilTerran> requires you to get people to follow links to make your city bigger
15:06:30 <subconscious> wildwobby: don't worry
15:06:34 --- mode: ChanServ set +o sjanssen
15:06:35 * EvilTerran really doesn't like those sites
15:06:39 --- mode: sjanssen set +b *!*=wildwobb@*.hsd1.il.comcast.net
15:06:39 --- kick: wildwobby was kicked by sjanssen (sjanssen)
15:06:45 <EvilTerran> !
15:06:46 <subconscious> oh
15:06:48 <subconscious> do worry
15:06:52 <dancor> burn
15:06:54 <sjanssen> hmm
15:06:54 <subconscious> although I think they made a genuine mistake
15:06:59 <sjanssen> yeah?
15:07:15 * sjanssen didn't read the rest :)
15:07:19 <subconscious> spammers don't usually put in effort to string a sentance together with any relevance to the channel they are in
15:07:47 <FunctorSalad> hmm... ghc won't even allow the relation-symmetrizing instance decl with XIncoherentInstances turned on
15:07:49 <dancor> detail-oriented spamming
15:07:58 <FunctorSalad> ("duplicate instance decl")
15:08:13 <dino-> http://hpaste.org/10639
15:08:25 <dino-> So, we wrote this code the other night, with the case x of...
15:08:39 --- mode: sjanssen set -b *!*=wildwobb@*.hsd1.il.comcast.net
15:08:42 <dino-> The idea being, if the string is empty, use a default string.
15:08:46 <vininim> subconscious: well, maybe google is working on that ;)
15:09:09 <dino-> And I thought, mm, this looks like mplus for Maybe. Wonder if there's some way to do this without the case
15:09:20 --- mode: ChanServ set -o sjanssen
15:09:22 <subconscious> weird
15:09:29 * dancor would love to use CReal but he's going to just do something lame until it gets into cabal at least
15:09:31 <subconscious> Distribution/Simple/Utils.hs:588:31:
15:09:31 <subconscious>     Ambiguous type variable `e' in the constraint:
15:09:36 <subconscious> trying to compile cabal
15:09:39 <sjanssen> dancor: it is on hackage
15:09:42 <dino-> But, of course, mplus for list doesn't do this, it does (++)
15:09:52 <sjanssen> dancor: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
15:09:55 <lambdabot> Title: HackageDB: numbers-2008.4.20, http://tinyurl.com/33mfjx
15:09:56 <subconscious> dancor: Do you not know how to use darcs?
15:10:01 <EvilTerran> dino-, that would be a valid alternate mplus for lists
15:10:05 <EvilTerran> but i don't think it's available anywhere
15:10:07 <dancor> sjanssen: cabal-install is my cutoff
15:10:07 <subconscious> dancor: or confused about build process or something?
15:10:09 <EvilTerran> predefined
15:10:19 <dancor> Help Fight Edge-Bleed.  No one else will!
15:10:44 <sjanssen> dancor: what?  Just 'cabal install numbers'
15:10:50 <dancor> oh numbers
15:11:04 <sjanssen> dancor: hackage.haskell.org contains the set of all packages that 'cabal install' knows about
15:11:08 <dino-> EvilTerran: ok. I couldn't find anything that looked promising either.
15:11:13 <dino-> EvilTerran: Thank you!
15:12:19 <dancor> so basically that CReal darcs repo is old and should be beletede
15:15:58 <EvilTerran> > map (($"default") =<< foldr.const.const) ["foo", ""]
15:16:00 <lambdabot>   ["foo","default"]
15:17:23 <dancor> the commented toRational in CReal works just fine.. anyway know why it might be commented
15:17:52 <ehtom> creals arent closed under supremum scares me alot
15:17:56 <dancor> tho ok, it does report a value for toRational pi which is wack
15:18:17 <sjanssen> dancor: toRational can't possibly be a total function on CReal
15:18:24 <ehtom> because completeness is what defines the normal real numbers in the first place
15:18:29 <dancor> sjanssen: right, but i assumed it would just hang on pi
15:19:08 <EvilTerran> > map (maybe "default" <$> const <*> listToMaybe) ["", "foo"]
15:19:09 <lambdabot>   ["default","foo"]
15:20:37 <FunctorSalad> ehtom: IIRC any infinite complete metric space is uncountable
15:21:04 <FunctorSalad> (if it has no isolated points)
15:21:06 <dino-> Huh, I have not used these Control.Applicative things yet.
15:21:59 <subconscious> sjanssen: and every function in haskell has to be total..
15:22:17 <ehtom> FunctorSalad: yes... so?
15:22:27 <cads> are there cryptosystems which do not lend themselves to being broken by quantum computing algorithms?
15:22:36 <ehtom> quantum encryption
15:22:43 <dancor> subconscious: not every function terminates on every value
15:22:45 <FunctorSalad> ehtom: computers have their difficulties with uncountable sets :)
15:23:18 <ehtom> FunctorSalad: yeah, but it doesn't say computer, computable reals are defined in terms of a turing machine
15:23:23 <cads> ehtom, I suppose I walked into that one :D
15:24:05 <FunctorSalad> ehtom: a turing machine (with countable alphabet) can only have countably many states
15:24:06 <subconscious> ehtom: the languages we implement on our computers are often turing compelete
15:24:19 <EvilTerran> subconscious, except they're all bounded by available memory
15:24:29 <subconscious> EvilTerran: really? I did not know that
15:24:52 <EvilTerran> all computers are modellable by sufficiently big DFAs :P
15:25:07 <FunctorSalad> EvilTerran: not if we assume that we add on more memory whenever it runs out :P
15:25:22 <dolio> You cannot do that.
15:25:25 <dbelange> The idea being that, in theory, with the right hardware and OS, you could keep plugging shit in to simulate the tape.
15:25:44 <FunctorSalad> dolio: I thought that question was still open ;-)
15:26:15 <dolio> My computer certainly doesn't allow that. :)
15:27:17 <FunctorSalad> if you add an usb device that takes commands "left, right, write/read 0/1" then why not?
15:27:28 <FunctorSalad> *g*
15:27:36 <ehtom> "A computable number [is] one for which there is a Turing machine which, given n on its initial tape, terminates with the nth digit of that number [encoded on its tape]." (Turing)
15:27:44 <ehtom> anyone know of a number which is NOT a CReal?
15:27:57 <dbelange> ?
15:28:02 <dbelange> c.e. real, you mean?
15:28:07 <subconscious> ehtom: There's one somewhere between 2 and 3
15:28:12 <dancor> ehtom: the sup of all the computable ones, right?
15:28:16 <dancor> :)
15:28:22 <ehtom> dancor: infinity...
15:28:26 <FunctorSalad> ehtom: pick a point at random on your monitor and it's pretty likely that it won't have computable coordinates ;-)
15:28:37 <FunctorSalad> (probability 1)
15:28:38 <ehtom> those answers don't help
15:28:48 <EvilTerran> (the first odd perfect number)^-1
15:28:48 <dbelange> ehtom: To get a real that's not computable, you can just take the halting set to be a binary expansion.
15:28:52 <subconscious> ehtom: I'm going to call it phi
15:28:57 <dancor> ehtom: ya there are definable numbers that aren't computable
15:28:59 <subconscious> actually no, I'll call it Xi
15:29:08 <dancor> ehtom: http://en.wikipedia.org/wiki/Definable_real_number
15:29:09 <lambdabot> Title: Definable real number - Wikipedia, the free encyclopedia
15:29:12 <subconscious> does it help _now_?
15:29:17 <dbelange> also, Chaitin's halting probability \Omega is a nice one.
15:29:29 <dancor> ehtom: i think you can make one with busy beaver stuff
15:29:40 <EvilTerran> the area of the mandelbrot set?
15:29:47 <EvilTerran> or is that computable?
15:29:58 <subconscious> dbelange: I'm bored of omega, how about area of the mandelbrot set
15:30:14 <ehtom> dbelange: ok, thanks
15:30:30 <dbelange> subconscious: Damned if I know.  I think you can approximate it reliably from below, right?
15:31:37 <dancor> i think mandelbrot might be open question..  e.g. http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=712C8712B1111FD3506FE40A1171A1A2?doi=10.1.1.95.2694
15:31:40 <lambdabot> Title: Is the Mandelbrot set computable - CiteSeerX, http://tinyurl.com/4872lv
15:31:54 <FunctorSalad> surprising
15:33:23 <EvilTerran> bad example, then
15:33:33 <dancor> i guess it's tough to do toRational on CReal bc you don't know if your func convergens
15:33:41 <dancor> sadface
15:34:02 <EvilTerran> i think you can use a non-constructive argument to show that non-computable numbers must exist
15:34:12 <dbelange> EvilTerran: Yeah, cardinality.
15:34:21 <dancor> obviterran
15:34:44 <cads> I remember that a finite language has countable statements and so the subset of the irrationals for which we may write names for is a countable subset which means that there is a subset infinitely larger than that, or irrational numbers which we can never single out
15:34:46 <EvilTerran> ... but i can't think of any nicer examples of one off-hand
15:34:54 <BMeph> EvilTerran: Now you're just abusing the definitions! ;)
15:35:25 <EvilTerran> BMeph, er, of what?
15:35:47 <EvilTerran> unless you're referring to the muddy philosophical waters around the "existence" of a number
15:36:05 <roconnor> Cale: algebras appear to be completely charcterized by a ring homomorphism.
15:36:09 <BMeph> EvilTerran: Of using a non-constructive argument to find a non-computable number. ;)
15:36:13 <dbelange> Just take any non-decidable subset of the naturals and call it a binary expansion.
15:36:16 <roconnor> i guess someone here said that, but it didn't sink in.
15:36:18 <EvilTerran> heh, ok...
15:36:46 <dbelange> Like, an encoding of which Diophantine equations have solutions or something.
15:36:50 <cads> EvilTerran: I read the blog of a broken-spirited mathematician who had studied logic and lost his faith in the existence of the natural numbers :D
15:37:16 <FunctorSalad> doesn't that happen to us all? ;-)
15:37:17 <ehtom> well, what's the use of real analysis if almost every real is incomputable?
15:37:21 <cads> it was unsettling
15:37:24 <BMeph> EvilTerran: Because if you used a constructive argument, you could possibly make the argument into an algorithm
15:37:39 <FunctorSalad> ehtom: completeness can be a useful fiction
15:37:50 <ehtom> Its a little bit of a fudge that to do useful stuff you need completeness, but to get a useful answer you can't have it
15:38:01 <EvilTerran> i believe it makes no more sense to say the natural numbers do or do not exist than it does to say that submarines do or do not swim
15:38:09 <cads> ehtom, you can still do a lot with countable subsets of function spaces and what have you
15:38:18 <ehtom> cads: yes
15:38:43 * BMeph goes to the sub base to see if any subs are doing the backstroke...
15:38:46 <FunctorSalad> ehtom: IMHO you need to look more at the usefulness of real numbers as a whole, not of single elements
15:38:54 <subconscious> ehtom: You don't have to shovel _everything_ inside a computer
15:39:03 <FunctorSalad> ehtom: completeness makes them simpler in some cases at the cost of weird elemetns
15:39:27 <EvilTerran> "exist" is a lot harder to define than "natural numbers", so i consider it to be primarily about existence rather than the natural numbers
15:39:40 <EvilTerran> and hence irrelevant outside of a metaphysical context :P
15:39:49 * cads notes that you can represent metareasoning about the real numbers as discrete statements in a computerized system
15:40:19 <ehtom> FunctorSalad: well of course, without completeness nothing works
15:40:25 <FunctorSalad> EvilTerran: let's take a simpler question, does three exist? ;-)
15:40:25 <dancor> using CReal for this toRational problem doesn't work
15:40:41 <dancor> inherently
15:40:51 <EvilTerran> FunctorSalad, that falls into the same problem
15:40:54 <roconnor> > exp pi :: CReal
15:40:55 <lambdabot>   23.1406926327792690057290863679485473802661
15:41:11 <FunctorSalad> EvilTerran: yes, I was just illustrating that you're right
15:41:25 <roconnor> > 3 :: CReal
15:41:26 <lambdabot>   3.0
15:41:35 <EvilTerran> in fact, the original reduces to that, as N can't exist without 3 existing :P
15:41:40 <cads> what substrate would 3 supposedly exist upon?
15:41:43 <EvilTerran> ... or maybe it can :D
15:41:45 <ehtom> FunctorSalad: but it just seems very strange to have to have completeness to define derivatives etc which are obviously very useful, yet the set of numbers you can calculate isnt complete
15:42:25 <FunctorSalad> ehtom: there's probably some constructive substitute, I don't know whether that makes things simpler or messier though
15:42:26 <roconnor> you don't need completeness to define derivatives; you need it for integrals.
15:42:33 <roconnor> :)
15:42:57 <dancor> > reads "1.5" :: [(Int, String)]
15:42:59 <lambdabot>   []
15:43:00 <dancor> why
15:43:02 <FunctorSalad> you can *define* derivatives, the question is will you have differentiable functions ;-)
15:43:03 <dancor> > reads "1." :: [(Int, String)]
15:43:04 <lambdabot>   [(1,".")]
15:43:10 <FunctorSalad> (except for polynomials)
15:44:01 <FunctorSalad> cads: human minds? :)
15:44:30 <cads> : )
15:45:07 <dancor> being trapped in a computer is nothing to smilee about!
15:45:09 <subconscious> FunctorSalad: Are you asking whether  exists x, x = 3  is provable? :p
15:46:19 <FunctorSalad> subconscious: nah, I believe that (assuming the usual defs and axioms)
15:46:30 <FunctorSalad> the question is more basic
15:46:58 <cads> I think it's easiest to believe that the space of all abstract concepts exists, including the ones which describe the evolutions of physical systems which contain subentities which grok that they exist
15:48:03 <EvilTerran> ... so the universe is a collection of axioms, and our existence and behaviour are provable from those axioms?
15:48:18 <LegendaryPenguin> anyone know why this algorithm could cause starvation if you removed the if statements? I dont understand how that would occur.  http://en.wikipedia.org/wiki/Dekker%27s_algorithm
15:48:19 <lambdabot> Title: Dekker's algorithm - Wikipedia, the free encyclopedia
15:49:03 <FunctorSalad> EvilTerran: "is"? that would seem like mistaking the map for the territory
15:49:18 <mmorrow> the Natural numbers "exist" because someone defined them and called that "thing" which those axioms describe "N"
15:49:43 <mmorrow> or am i using a hugely different concept for "exists" than others?
15:49:46 <FunctorSalad> mmorrow: we used them way before someone wrote down formal axioms
15:49:47 <EvilTerran> FunctorSalad, well, i don't think you can prove the map and territory to be distinct in this case
15:49:53 <sbahra> mmorrow, yes. :-)
15:49:57 * sbahra nods @ FunctorSalad 
15:50:06 <sbahra> Peano (sp?)
15:50:26 <TSC> LegendaryPenguin: You mean the paragraph: "If the algorithm were modified by performing the actions in the "while f1" loop..." ?
15:50:42 <LegendaryPenguin> yes
15:50:46 <cads> mmorrow, I think the wierd thing is that we can imagine that even if we didn't exist, things could still be countable
15:50:48 <mmorrow> FunctorSalad, sbahra: "they"?? suppose we didn't "use" "them". would they not have "existed"
15:50:49 <mmorrow> ?
15:50:50 <LegendaryPenguin> I really dont see how either one could starve
15:51:06 <zeno> I installed cabal-install, and then did cabal install yi, but ./yi (from ~/.cabal/bin) gives cCustom yi ("/home/zeno/.yi/yi-i386-linux") could not be cads
15:51:12 <zeno> launched*
15:51:21 <LegendaryPenguin> unless the OS scheduler was retarded or something.. But even with the if statement that scenario could occur
15:51:22 <mmorrow> the quatity 1 is not 1 `elem` N. this map is made by you.
15:51:56 <FunctorSalad> mmorrow: imho they would have "latently" existed in that future intelligent beings would be likely to develop something like them... but they don't exist by themselves I think
15:52:00 <LegendaryPenguin> oh wait i might see it now.. i think
15:52:41 <TSC> LegendaryPenguin: It's not obvious to me; what do you think is the reason?
15:52:42 <sbahra> mmorrow, that's a long discussion
15:52:49 <mmorrow> FunctorSalad: ok, i see my/the confusion. i don't define the existence of something as an absolute thing.
15:53:07 <sbahra> mmorrow, I have come to the realization that I don't give a fuck about realist/anti-realist perspective when it comes to the numbers (it's boring).
15:53:14 <mmorrow> exactly!
15:53:45 <mmorrow> it's not even a question to ask because it's meaningless (imho)
15:53:53 * SamB_XP is anti-realist -- he doesn't like the reals ;-P
15:53:55 <sbahra> And also within realism, some positions are laughable :-P (with all due respect to Plato).
15:53:56 <FunctorSalad> mmorrow: *nod*, I'm not sure the sentence "x exists" even has meaning without any context
15:54:03 <mmorrow> it's like asking if 4-dimension actually "exist"
15:54:15 <mmorrow> or 10-dimensions, etc
15:55:13 <FunctorSalad> "existence" may have varying (or no) meaning depending on the language game
15:55:25 <LegendaryPenguin> ok, i think this is it.. the first one enters its CS, and the second one is stuck in the while loop.  P0 will finish and set turn to P1.  P1 will soemtime later set f1 to true, and it will keep looping without entering the if statement.   If the if statement wasnt there, it could keep setting f1 to false and letting p0 run
15:55:31 <LegendaryPenguin> haha, tha was long explanation
15:56:00 <LegendaryPenguin> but the if statement being there means it will let p1 run once its schedule
15:56:18 <LegendaryPenguin> thinking about these is confusing imo
15:56:44 <EvilTerran> FunctorSalad, ah, the Wiggenstein tactic
15:56:50 <EvilTerran> *Wittgenstein
15:57:17 <icks> what's the right way to document a project with multiple Main-modules in it using haddock? just invoking haddock on all the files results in only one of the modules being properly documented.
15:57:38 <EvilTerran> the right way is to not have multiple modules with the same name
15:57:56 <EvilTerran> :P
15:58:00 <FunctorSalad> EvilTerran: couldn't bring myself to read through it, but I still have been thinking about this language-game idea
15:58:01 <hackage> Uploaded to hackage: CLASE 2008.9.23.2
15:58:34 <EvilTerran> FunctorSalad, well, the main thing i remember about Wittgenstein is that he alledgedly declared all the problems of philosophy to be problems of philosophy of language
15:58:54 <icks> EvilTerran: well.. how can i have multiple executables in one project then?
15:59:24 <FunctorSalad> EvilTerran: imho there's a lot of truth to that... some problems only arise because a word is vaguely generalized out of its original meaning
15:59:32 <FunctorSalad> (like in this case, "existence")
16:00:20 <EvilTerran> icks, well, you could use the -main-is flag
16:00:59 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#id340655
16:01:02 <lambdabot> Title: 5.10.�Options related to a particular phase, http://tinyurl.com/smq5n
16:02:06 <icks> ah thank you EvilTerran
16:04:49 <dons> anyone got hugs on the android tmobile device yet? :)
16:05:19 <Cale> roconnor: You mean, algebras built on a ring, rather than a plain Abelian group?
16:05:54 <roconnor> Cale: ah right, yes.
16:16:13 <mmorrow> roconnor: equivalently you can define a module M to be a ring hom M : R -> Hom(G,G)
16:16:30 <super> dons: is hugs smaller than ghc?
16:16:55 <super> i thought you could realistically not deply anything but java or perhaps scala on android?
16:23:33 <roconnor> mmorrow: is Hom(G,G) a ring?
16:23:37 <mmorrow> yes
16:23:51 <roconnor> composition is multiplication?
16:23:54 <mmorrow> (+,*) -> (+,.)
16:24:01 * roconnor nods
16:24:09 <roconnor> formalizing math is hard.
16:24:12 <roconnor> so many options
16:24:14 <mmorrow> hehe
16:24:24 <dancor> it's like the many monads thing i was talking about
16:24:27 <roconnor> hard to get the different characterizations to work magically together.
16:24:50 <mmorrow> that's why category theory is so awesome
16:26:20 <vincenz> Hey roconnor
16:26:37 <dancor> what's a simple but surprising result in category theory
16:27:33 <roconnor> vincenz: hey
16:27:59 <roconnor> mmorrow: why is category theory awesome?
16:29:03 <mmorrow> because it captures the root concept underlying seemingly unrelated things, and expresses it elegantly and without field-specific noise which obscures this underlying concept :)
16:29:12 <vincenz> Like monds
16:29:13 <vincenz> +a
16:29:34 <roconnor> mmorrow: that doesn't seem obvious to me.
16:29:38 <mmorrow> heh
16:29:51 <lament> monads ARE field-specific noise
16:30:06 <lament> anybody who thinks they're a natural abstraction is... some kind of Haskeller
16:30:08 <mmorrow> (and by "field-specific noise", i more was refering to subfields within mathematics)
16:30:20 <roconnor> CT often lacks predicativity and computational content.
16:30:32 <roconnor> but I don't know CT very well
16:30:34 <lament> perhaps sets are a natural abstraction, maybe even functions, but monads are certainly just made-up silly things
16:30:57 <SamB_XP> sets!
16:30:59 <SamB_XP> heh
16:31:01 <mmorrow> no more so or less than sets are "made up silly things"
16:31:02 <SamB_XP> sets!
16:31:07 <lament> i don't like sets
16:31:22 <lament> but at least they're ridiculously simple and correspond to a very natural everyday concept
16:31:27 <SamB_XP> ... uh, try topology instead ?
16:31:38 <lispy> I think lists are more natural than sets
16:31:44 <SamB_XP> ridiculously simple, are they?
16:31:50 <lament> SamB_XP: topology is all expressed in terms of sets, last time i checked
16:32:01 <mmorrow> but that need not be the case
16:32:01 <SamB_XP> lament: ... for the moment
16:32:13 <SamB_XP> sadly
16:32:14 <lispy> well, math is largely a language of reasoning about sets and specialized versions of sets
16:32:33 <lament> i've met people on irc who think all math stuff -is- sets in some profound way
16:32:58 <LegendaryPenguin> is there a such thing as double round robin process scheduling
16:33:21 <mmorrow> lispy: i'd agree if you s/sets/category theory/
16:33:32 <mmorrow> err, i meant @lament
16:34:01 <lament> mmorrow: right, then you're a nut too :)
16:34:09 <lament> but at least a less mainstream kind of nut!
16:34:14 <mmorrow> wooohooo
16:34:19 <mmorrow> :)
16:34:35 <dolio> I'm not sure 'all math is sets' is that much of a nut position.
16:34:51 <lament> dolio: you can argue that with mmorrow.
16:35:02 <dolio> You can probably get the majority of mathematicians to agree to that in a hand-wavey kind of way.
16:35:08 <roconnor> dolio: it ought to be.
16:35:25 <dolio> Making it precise is, of course, another matter.
16:35:54 <mmorrow> but sets say nothing about maps /between/ sets
16:35:55 <dolio> And, of course, nobody reduces all their specialized work down to set theory.
16:35:55 <lament> All math can certainly be expressed in terms of sets, just as all programs can be expressed as assembly
16:38:09 <mmorrow> All math can be expressed in terms of sets, as all programs can be expressed in terms of Intel(R) processors...you just'll have to write the asm
16:39:34 <lament> although i have also met people who think all programs are assembly (or, commonly heard, "ones and zeros")
16:40:09 <mmorrow> what if someone uses a non-binary machine?
16:41:12 <dolio> Set theory is also easy to point to as one point upon with you found all the rest of your mathematics.
16:41:49 <lament> dolio: right, same with programming and "ones and zeros"
16:41:52 <lament> doesn't make it right!
16:42:20 <dolio> Yeah, well. :)
16:42:58 <dolio> I don't know how well category theory would work in that role. The limited experience I've had always defines categories in terms of sets or something.
16:43:25 <shapr> d00d
16:47:11 <dolio> @yow!
16:47:12 <lambdabot> World War Three can be averted by adherence to a strictly enforced dress code!
16:47:41 <chrisdone> λ t-shirts ❤
16:49:40 <chrisdone> do haskellers like babylon 5?
16:49:46 <eyu100> > (\x -> 1)
16:49:47 <lambdabot>       Overlapping instances for Show (t1 -> t)
16:49:47 <lambdabot>        arising from a use of `...
16:49:58 <eyu100> > f = 1
16:49:59 <lambdabot>   mueval: Prelude.read: no parse
16:50:06 <eyu100> > let f = 1
16:50:07 <lambdabot>   mueval: Prelude.read: no parse
16:50:09 <mmorrow> > let f = 1 in f
16:50:10 <lambdabot>   1
16:50:15 <mmorrow> , (\x -> 1)
16:50:16 <lunabot>      No instance for (Show (t1 -> t))
16:50:23 <mmorrow> , [|(\x -> 1)|]
16:50:24 <lunabot>  LamE [VarP x_0] (LitE (IntegerL 1))
16:50:27 <chrisdone> > typeOf 1
16:50:28 <lambdabot>   Integer
16:50:28 <eyu100> > let x = 2 in (\x -> 1)
16:50:29 <lambdabot>       Overlapping instances for Show (t1 -> t)
16:50:29 <lambdabot>        arising from a use of `...
16:50:32 <chrisdone> , typeOf 1
16:50:33 <lunabot>  Integer
16:50:41 <vininim> vut
16:50:52 <eyu100> > 1 % 2
16:50:53 <lambdabot>   1%2
16:51:12 <mmorrow> , toDyn (print 4)
16:51:13 <lunabot>  <<IO ()>>
16:51:55 <vininim> , unfoldr Just (1,1)
16:51:56 <lunabot>      Occurs check: cannot construct the infinite type: b = (a, b)
16:52:02 <vininim> ^ in
16:52:03 <mmorrow> , fmap fromDynamic [toDyn (print 4), toDyn "asdf", toDyn 42] :: [Maybe String]
16:52:04 <lunabot>  [Nothing,Just "asdf",Nothing]
16:52:07 <vininim> *win
16:52:09 <mmorrow> , fmap fromDynamic [toDyn (print 4), toDyn "asdf", toDyn 42] :: [Maybe Integer]
16:52:11 <lunabot>  [Nothing,Nothing,Just 42]
16:52:20 <mmorrow> , fmap fromDynamic [toDyn (print 4), toDyn "asdf", toDyn 42] :: [Maybe (IO ())]
16:52:21 <lunabot>      No instance for (Show (IO ()))
16:54:28 <mmorrow> , typeOf id
16:54:29 <lunabot>      Ambiguous type variable `a' in the constraint:
16:54:50 <mmorrow> , toDyn id
16:54:51 <lunabot>      Ambiguous type variable `a' in the constraint:
16:54:52 <dolio> , unsafeIOToST
16:54:53 <lunabot>   Not in scope: `unsafeIOToST'
16:55:22 <mmorrow> too bad toDyn can't do polymorphism
16:55:32 <mmorrow> s/toDyn/Dynamic/
16:56:44 <ivanm> what is meant by an overlapping instance error?
16:57:18 <mmorrow> , unsafeIOToST (runST (print $ unsafePerformIO (runQ (runIO (print "asdf")))))
16:57:18 <lunabot>   Not in scope: `unsafeIOToST'
16:57:18 <lunabot>  <interactive>:1:64: Not in scope: `runST'
16:57:50 <mmorrow> asdf
16:57:51 <mmorrow> ()
16:58:02 <hackage> Uploaded to hackage: io-reactive 0.1.1
17:00:54 <mmorrow> oops
17:01:03 <mmorrow> ghci> runST (unsafeIOToST (print $ unsafePerformIO (runQ (runIO (print "asdf")))))
17:01:03 <mmorrow> "asdf"
17:01:03 <mmorrow> ()
17:01:03 <mmorrow> ()
17:02:09 <BONUS_> @pl \xs -> zip xs (tail xs)
17:02:09 <lambdabot> ap zip tail
17:02:44 <mmorrow> has anyone seen http://www.cs.york.ac.uk/fp/darcs/ELF ?
17:02:48 <lambdabot> Title: Index of /fp/darcs/ELF
17:02:49 <mmorrow> it's friggin sweet
17:03:04 <mmorrow> write your own objdump !@
17:03:32 <mmorrow> sweet x2 when combined with harpy's disassembler
17:03:48 <leimy> I'm somehow missing how to convert a String to a ByteString
17:03:53 <Botje> B.pack
17:04:00 <leimy> uhm
17:04:02 <TomMD> Oooo, a new AndyGill package.  But where is Timber?  Can't say I recall hearing about it before.
17:04:05 <TomMD> @where timber
17:04:05 <lambdabot> I know nothing about timber.
17:04:18 <leimy> Should Data.ByteString.pack "Hello" work then?
17:04:19 <TomMD> LtU says its an O'Haskell successor?
17:04:23 <Botje> yeah
17:04:28 <leimy> > Data.ByteString.pack "Hi"
17:04:28 <lambdabot>   mueval: Unsafe functions to use mentioned.
17:04:47 <Botje> @hoogle pack
17:04:47 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
17:04:48 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
17:04:48 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
17:04:56 <leimy> right
17:05:04 <leimy> ah
17:06:33 <leimy> Somehow I was missing that.
17:07:21 <Olathe> Is CReal in the standard Haskell distribution ?
17:07:45 <Olathe> > let x = 5 in (showCReal 5 x, show x)
17:07:47 <lambdabot>   ("5.0","5")
17:07:56 <Olathe> > let x = 5.123456789 in (showCReal 5 x, show x)
17:07:57 <lambdabot>   ("5.12346","5.123456789")
17:08:14 <Olathe> @index pi
17:08:15 <lambdabot> Prelude
17:08:49 <super> why is darcs so slow?
17:08:57 <super> what do i need to fix?
17:10:40 <dons> super: is it?
17:10:47 <TomMD> super: There isn't anyone paid to dedicate 40 hr/wk to darcs, you should fix that.
17:10:52 <dons> which operation, which version of darcs?
17:11:57 <TomMD> My main issue with darcs (from a speed perspective) is that it makes multiple ssh connections, each of which take take with public keys or lots of typing for passwords.
17:12:31 <shrughes> Does darcs 1 do that?  I just noticed with darcs 2
17:12:55 <SamB_XP> shrughes: pretty sure it does
17:13:22 <Olathe> @index showCReal
17:13:22 <lambdabot> bzzt
17:14:03 <shrughes> That's weird.  I seriously remember only having to type my password once.
17:19:53 <setuid_w00t> If I have a computationally expensive, infinite list such as primeNumbers, and then I do "let a = f primeNumbers   b = g primeNumbers in ..." my understanding is that the prime numbers may be computed repeatedly if both "f" and "g" read values from the list.  Is there a way to make sure that the primes are only computed once?
17:20:29 <BONUS_> let p = primeNumbers in a p
17:20:33 <BONUS_> or like
17:20:33 <TomMD> dons: aren't you in Canada right now, soaking up the FP goodness?
17:20:37 <shrughes> setuid_w00t, your understanding is wrong
17:21:07 <BONUS_> let p = primeNumbers; a = f p; b = f p; in ...
17:21:20 <BONUS_> i mean b = g p
17:21:26 <super> tomMD: ok but what is the problem, merging big files? if i want to work on it, what should i sit down and fix. also how big is the source code, how many lines? is it only haskell?
17:21:31 <shrughes> BONUS_, since you're already accessing it through the thunk primeNumbers, going through p isn't any help
17:21:44 <Olathe> setuid_w00t: map (\a -> (f a, g a)) primeNumbers
17:22:02 <Olathe> setuid_w00t: Maybe unzip that.
17:22:13 <dons> TomMD: for sure.
17:22:23 <shrughes> or am I wrong?
17:22:25 <dons> TomMD: see my twitterings http://twitter.com/galoisinc
17:22:26 <lambdabot> Title: Twitter / galoisinc
17:22:31 <TomMD> super: I can't really help you with DARCS beyond: yes, it's in Haskell.  It is rather complex, but you should ask on the ML to get involved.
17:22:38 <setuid_w00t> shrughes: can you elaborate a bit?
17:22:57 * TomMD jumps to twitter
17:23:17 <shrughes> setuid_w00t: say you have a "variable" named primeNumbers with type [Integer]
17:23:50 <setuid_w00t> ok, that much is true
17:24:43 <shrughes> setuid_w00t: then that value, in some sense, exists at a particular location, say, the memory address LocationFoo.
17:24:43 <dons> all the packages on hackage and how they depend on each other http://eelco.slashpunt.org/cabal-twopi-base.svg
17:24:46 <dons> thanks to eelco
17:24:54 <dons> also in .png http://eelco.slashpunt.org/cabal-twopi.png
17:25:21 <shrughes> setuid_w00t: before any of that list is computed, at that location there will exist a function pointer of some kind
17:25:27 <ivanm> dons: do you know how he did that graph up?
17:25:41 <dons> graphviz and a script
17:25:53 <ivanm> yeah, I was after the script :p
17:26:10 <shrughes> setuid_w00t: now suppose in accessing the value of (f primeNumbers), you need to access the first element of primeNumbers
17:26:38 <TomMD> dons: lol, I didn't expect the pure black screen in the middle when it started out so sparse and spread out.
17:27:07 <dons> it is so beautiful in inkscape
17:27:17 <shrughes> setuid_w00t: after that gets computed, it will get stored at the memory address LocationFoo.  So now instead of a function pointer, at that location, there will be a cons cell, i.e. an ordered pair, which contains memory locations of the head and tail of the list.
17:27:41 <shrughes> (and by 'function pointer' I mean that in the C sense)
17:27:47 <setuid_w00t> ok
17:28:34 <mmorrow> dons: do you know if the .dot for that accessible?
17:28:35 <dons> let me upload a video of navigating the package graph ...
17:28:50 <dons> chr1s, eelco is the dot accessible?
17:29:08 <chr1s> dons: sure, one sec.
17:29:11 * juhp is having install installing nightly linux binaries of ghc-6.9
17:29:12 <shrughes> setuid_w00t: so then, suppose while accessing the value of (g primeNumbers), you end up needing some of the elements of primeNumbers.  when the program looks at LocationFoo, it sees that the first cons cell of the list has already been simplified, so it doesn't need to compute that... instead, it just moves on to the pointers to the head and tail.
17:29:19 <mmorrow> chr1s: awesome
17:29:35 <ivanm> chr1s: how about the actual script used to generate it?
17:30:25 <shrughes> setuid_w00t: so, if you have a particular value, foo, then the expressions (f foo) and (g foo) will both end up holding references to the memory location of foo.
17:30:37 <mmorrow> ivanm: use curl to scan hackage, build a graph of [(String,[String])], prettyprint to .dot, cat hackage.dot | twopi -Tsvg ?
17:30:47 <chr1s> dons: http://chris.slashpunt.org/tmp/cabal.dot
17:31:20 <mmorrow> chr1s: sweets. i'll make some with pretty styles and such
17:31:23 <setuid_w00t> shrughes: That makes sense.
17:31:38 <chr1s> ivanm: http://chris.slashpunt.org/tmp/Graph.hs, put it in the cabal-install source dir.
17:31:55 <ivanm> oh? so it's a patch to cabal-install then?
17:32:00 <dons> whoever creats the prettiest 1024x768 pixel representation of the cabal /hackagegraph will have it seen during the haskell workshop
17:32:16 <dons> grr. running out of bandwidth.
17:32:35 <shrughes> setuid_w00t: the time you'd need to worry is if you had something like computePrimeNumbers = \() -> somethingFancy
17:32:40 <chr1s> ivanm: well, it's hacked together and depends on functions in cabal-install that should be in a library.
17:32:41 <ivanm> grrr.... xchat doesn't realise that the "," on the end isn't part of the URL :@
17:32:45 <ivanm> chr1s: *nod*
17:32:56 <ivanm> dons: when by?
17:32:59 <Olathe> @unpl \() -> 4
17:32:59 <lambdabot> \ () -> 4
17:33:04 <Olathe> @pl \() -> 4
17:33:04 <lambdabot> (line 1, column 4):
17:33:04 <lambdabot> unexpected " "
17:33:04 <lambdabot> expecting operator, pattern or "->"
17:33:16 <kosmikus> hmm, why does ghc-6.10 access files in my home directory. that doesn't please NixOS ...
17:33:20 <ivanm> pl doesn't like ()?
17:33:34 <Olathe> @pl \x -> ()
17:33:34 <lambdabot> const ()
17:33:36 <ivanm> kosmikus: you don't mean .ghci or something, do you?
17:33:47 <Olathe> > (\() -> 4)
17:33:48 <dons> ivanm: this time tomorrow.
17:33:48 <lambdabot>       Overlapping instances for Show (() -> t)
17:33:48 <lambdabot>        arising from a use of `...
17:33:51 <ivanm> Olathe: I meant as the LHS
17:33:57 * ivanm passes then
17:33:58 <Olathe> > (\() -> 4) ()
17:33:59 <lambdabot>   4
17:34:01 <Olathe> > (\() -> 4) 5
17:34:02 <lambdabot>       No instance for (Num ())
17:34:02 <lambdabot>        arising from the literal `5' at <intera...
17:34:19 <dons> there's a quick video of the graph being navigated :) galois.com/~dons/tmp/out.ogv
17:34:25 <kosmikus> ivanm: no, it seems to try to write to a package db in the home dir of the user that builds it
17:34:26 <ivanm> dons: but by the end of the month I'll hopefully be able to give you a graph of xmonad+contrib function-wise!
17:34:31 <ivanm> kosmikus: :o
17:34:32 <Olathe> > (\Integer -> 4) 5
17:34:33 <lambdabot>   mueval: Prelude.read: no parse
17:34:46 <Olathe> > (\5 -> 4) 5
17:34:47 <lambdabot>   4
17:34:49 <Olathe> > (\5 -> 4) 6
17:34:50 <lambdabot>   mueval: Prelude.read: no parse
17:34:50 <lambdabot>  mueval: *** Exception: /tmp/921533014481483...
17:34:54 <Olathe> Weird.
17:35:06 <Olathe> I wonder how to do more patterns in that.
17:35:08 <ivanm> maybe because it's doing pattern matching?
17:35:15 <shrughes> but "no parse"
17:35:16 <chr1s> the graph should be generated for every day since hackage existed.
17:35:27 <chr1s> so you can see the dependencies grow.
17:35:27 <Olathe> How would you do f 5 = 4; f 6 = 5 ?
17:35:35 <Olathe> With a lambda instead of f ?
17:35:41 <ivanm> chr1s: get dcoutts_ to make it part of hackage'? :p
17:35:44 <chr1s> s/existed/went online
17:35:44 <dons> chr1s: that would be awesome.
17:35:53 <ivanm> Olathe: \x -> pred x ?
17:35:57 <Olathe> > (\5 -> 4; \6 -> 5) 5
17:35:58 <lambdabot>   mueval: Prelude.read: no parse
17:35:59 <dons> we should do that for next year
17:36:02 <dons> an 'state of haskell' video
17:36:03 <kosmikus> Olathe: \ x -> case x of 5 -> 4; 6 -> 5
17:36:03 <shrughes> > (\x -> case x of 5 -> 4; 6 -> 5) 5
17:36:04 <lambdabot>   4
17:36:18 <Olathe> ivanm: I mean with the pattern matching lambda, like (\5 -> ...)
17:36:42 <Olathe> kosmikus: Ahh.
17:36:44 <shrughes> Olathe: you can't; go complain about adding "case of" to the language
17:38:50 <dons> pretty, http://galois.com/~dons/tmp/hackage.png
17:39:37 <chr1s> dons: beautiful!
17:39:43 <ivanm> dons: is that just a shrunken version?
17:39:48 <eelco> dons: cool, is that a png of the svg?
17:39:55 <ivanm> chr1s: now, how about colouring the vertices based upon which hackage group they're in? :p
17:40:18 <ivanm> chr1s: which graphviz app did you use? dot or neato?
17:40:39 <eelco> twopi
17:40:44 <ivanm> ahhhh
17:40:50 <ivanm> any particular reason why that one?
17:40:56 <ivanm> produced the nicest graph?
17:41:01 <eelco> the only one fast enough to run on my laptop
17:41:05 <dons> eelco: that's a screenshot of the scaled .svg
17:41:05 <ivanm> lol
17:41:16 <ivanm> eelco: because of the size of the graph?
17:41:26 <eelco> i would like to use neato -Gmodel=subset
17:41:31 <eelco> but that crashes
17:41:49 <ddarius> Do a HDR rendering of that, apply an Airy filter and then use a monochromatic color scheme.
17:41:54 <eelco> ivanm: yes, and because i'm on a powerbook
17:42:05 <ivanm> what's the powerbook got to do with it?
17:42:10 <ivanm> just slow in general?
17:42:18 <eelco> powerbook = 3 years old
17:42:28 <ivanm> oh, yeah
17:42:42 <ivanm> hmmm.... are you using just the latest version of each package, or every single version?
17:42:52 <eelco> latest
17:43:36 <ivanm> *nod*
17:45:13 <ddarius> dons: Pick a hue.
17:45:36 <dons> something pretty?
17:45:55 <dons> galois.com has a nice color set, imo. something like that/
17:46:19 <ddarius> A hue is a single color.
17:46:55 <dons> pick one :)
17:47:03 <dons> that nice sky blue?
17:47:13 * ivanm wishes there was a package with colour sets available...
17:47:30 <ddarius> Blue works.
17:47:33 <dons> ddarius: maybe you can do more with the svg.
17:47:33 <ivanm> dons: I see you've been corrupted alread though.... how dare you drop your 'u's????? :o
17:47:37 <ddarius> (Actually, pretty much any hue works.)
17:47:56 <ddarius> dons: I intend to start with the SVG.
17:47:56 <ddarius> Or the data from it rather.
17:48:03 <Olathe> @src until
17:48:04 <lambdabot> until p f x | p x       = x
17:48:04 <lambdabot>             | otherwise = until p f (f x)
17:48:46 <Olathe> > until (==0) (*0) 5
17:48:47 <lambdabot>   0
17:49:09 <mmorrow> just killed circo after 5 minutes of churning. i have a feeling the reulting visuals would be super cool
17:49:15 <ivanm> heh
17:49:22 <mmorrow> i'll have to try later when i don't need the cpu
17:49:25 <ivanm> how many nodes in the graph?
17:49:46 <mmorrow> a lot
17:49:49 <mmorrow> :)
17:50:47 <mmorrow> shit, i think i killed it while it was in the middle of writing to the svg :(
17:51:01 <dons> ddarius: you have everything you need?
17:51:22 <chr1s> haskell relative package sizes: http://chris.slashpunt.org/tmp/package-sizes.tiff
17:51:25 <ddarius> dons: I have the data.  Now all I need to do is look up the SVG format and write the software and then run the software.
17:51:34 <ddarius> Just a SMOP
17:51:36 <chr1s> (sorry for the tiff format)
17:51:48 <ivanm> mmorrow: then run it again! :p
17:56:01 <eelco> mmorrow: circo churned for more than 30 minutes on my laptop ;)
17:56:45 <chr1s> now in png!
17:56:47 <chr1s> http://chris.slashpunt.org/tmp/package-sizes.png
17:57:23 <ivanm> :o
17:57:38 <ivanm> what are the numbers in? MB?
17:57:46 <eelco> dependencies
17:57:47 <dons> oh lovely, chr1s
17:57:51 <ivanm> eelco: ahhh
17:57:55 <ivanm> gtk == soegtk?
17:57:57 <dons> so ranked by dependency size?
17:58:50 <chr1s> larger == more depended upon
17:59:19 <chr1s> or, the size is linear to the number of inverse dependencies?
18:00:08 <ivanm> size(p) \propto | { d | d depends on p } | ;_
18:00:11 <ivanm> (* ;-)
18:00:47 <chr1s> just for kicks: http://chris.slashpunt.org/tmp/package-sizes-words.png
18:00:52 <Igloo> chr1s: What generated that?
18:01:13 <ivanm> LOL!
18:01:14 <chrisdone> that totally kicks my word cloud library's ass
18:01:16 * Igloo is depressed by how large haskell98 is
18:01:34 <dons> Igloo: yeah
18:01:36 <dons> we should ban it
18:01:49 <shapr> How to make it smaller?
18:01:55 <ivanm> haskell98 is the compat package, isn't it?
18:02:28 <ivanm> shapr: gzip it? :p
18:02:28 <Igloo> It has the non-hierarchical modules in (except Prelude, which is in base)
18:02:34 <chr1s> Igloo: I'm not sure, it just came to me.
18:02:42 <chr1s> but to be honest, I used http://services.alphaworks.ibm.com/manyeyes
18:03:00 <chrisdone> 40
18:03:02 <chrisdone> 404
18:03:11 <Olathe> Are there any other numeric types that have the form CWhatever other than CReal ?
18:03:24 <chrisdone> CInt
18:03:28 <Olathe> Ahh.
18:03:38 <Olathe> Are there CInteger, CRational ?
18:03:40 <chrisdone> chr1s: that page is not found
18:03:47 <ivanm> chrisdone: he must have crashed it ;-)
18:03:51 <Olathe> Or CComplex ?
18:03:59 <ivanm> or is it the #haskell effect? :p
18:04:04 <Olathe> I don't think I found any, but I want to make sure.
18:04:24 <mmorrow> i'm running the transitive reduction of cabal.dot through circo now (that's what almost finished before i killed it)
18:04:32 <Igloo> chr1s: Sorry, I meant the one with circles. Or was that manyeyes too?
18:04:50 <mmorrow> transitive reduction being obtained from  cat a.dot | tred | circo -Tsvg > a.svg
18:04:52 <Igloo> Ah, yes, a bubble chart. Cool, thanks
18:05:09 <dons> chr1s: does the bubble graph have all the packages, all 750?
18:05:22 <dons> i didn't count  hte circles, but it seems like there are less.
18:05:33 <chr1s> final version: http://chris.slashpunt.org/tmp/package-sizes-color.png
18:05:43 <mmorrow> dons: http://chris.slashpunt.org/tmp/deps-count.txt
18:05:55 <mmorrow> (i assume that's the source data)
18:06:01 <chr1s> mmorrow: exactly.
18:06:25 <dons> ok
18:06:34 <chrisdone> http://chrisdone.com/haskell-sans-quicksilver.png
18:06:35 <chrisdone> jeje
18:07:07 <chr1s> chrisdone: cool
18:07:32 <dons> nice
18:07:41 <ivanm> chrisdone: don > dons? :o (I can't even find dons in there... :s )
18:07:42 <chrisdone> I don't think I put my word cloud library on hackage
18:07:51 <dons> so what's that last graph?
18:07:53 <ivanm> but I take it quicksilver took up the whole graph originally? :p
18:07:55 <mmorrow> lol, "schme"
18:07:55 <Igloo> chrisdone: What is what?
18:08:01 <dons> common words in .cabal files?
18:08:05 <chrisdone> Igloo: haskell IRC logs
18:08:07 <ivanm> chr1s: pretty...
18:08:19 <chr1s> yes, the colored version is indeed quite pretty!
18:08:21 <ivanm> but what are you calling the gtk library? soegtk?
18:08:47 <Igloo> chrisdone: Hmm, that isn't what I'd have expected
18:09:09 <mmorrow> haha, "out" + "timed"
18:09:15 <chrisdone> I had to remove quicksilver because he kind of ruins it: http://chrisdone.com/haskell.png
18:09:23 <dons> $ wc -l deps-count.txt
18:09:23 <dons> 277 deps-count.txt
18:09:24 <dons> ah
18:09:29 <dons> so that's missing 500 packages?
18:09:35 <chr1s> dons: really?
18:09:36 <ivanm> heh
18:09:46 <dons> well, it only has 277 items in the deps-count file
18:09:52 <chrisdone> mmorrow: haha
18:09:53 <dons> but we know there's something over 750 packages :)
18:10:00 <dons> so that's why the circle graph looks small.
18:10:04 <dcoutts> @yarr!
18:10:04 <lambdabot> Gangway!
18:10:05 <dons> but it is perfect. that's the one to use i think
18:10:14 <mmorrow> maybe the others aren't depended on by any others?
18:10:17 <chr1s> dons: so it's correct.
18:10:24 <chr1s> mmorrow is right again
18:10:25 * ddarius will need to program faster
18:10:33 <mmorrow> ddarius: hurry!!!
18:10:39 * ivanm gives ddarius some speed-coding drugs
18:10:42 <Igloo> chrisdone: Is that including the <nick> at the start of the line? If so, what happens if you sed that out?
18:11:02 <mmorrow> yeah, i think it's including everything
18:11:09 <ivanm> Igloo: so who asks who more rather than who says the most?
18:11:16 <chr1s> dons: for example, the twitter package isn't included, because nothing depends on twitter.
18:11:34 <dons> so perhaps add 1 to all the packages.
18:11:39 <dons> so everything depends on itself :)
18:11:46 <dons> but maybe on 1 or more other libs
18:11:48 <chr1s> ah, ok.
18:11:50 <chr1s> sure.
18:11:53 <chr1s> gimme a sec.
18:12:03 <dons> well, i'm not sure that makes sense.
18:12:17 <dons> i'd like to have all the packages.
18:12:26 <dons> if nothing depends on it, circle size 0
18:12:35 <dons> then increasing.
18:16:22 <dons> woo. augustuss paper on cayenne awared most significant paper from 1998
18:16:48 <dons> http://portal.acm.org/citation.cfm?id=289423.289451
18:16:57 <mmorrow> cool. if i ever figure out how to get cabal to do what i want, it'll be cabalized, too!
18:17:20 <dons> ICFP contest results being announced now!
18:17:55 <mgsloan> hello, hello! are there any haskell compilers modular enough that you could add a new frontend? eg, everything up to AST
18:18:08 <shapr> Hiya mgsloan!
18:18:09 * ivanm doesn't recall hearing anything about the contest this year, as opposed to last year...
18:18:26 <shapr> mgsloan: You may want to check out the GHC Plugins project, I don't know how far it got.
18:18:43 <mgsloan> alright, thanks!
18:18:46 <electronx> fellow haskell people are there any graphical debuggers for ghc?
18:18:51 <mmorrow> mgsloan: you could also just prettyprint the AST back to haskell src, then feed it to ghc/whatever
18:18:56 <shapr> But other compilers may be easier to hack, I don't know.
18:18:58 <mgsloan> I suppose it would be good to go with ghc, considering it has all the extensions and such
18:19:01 <electronx> i don't like doing it through ghci
18:19:02 <mgsloan> mmorrow - ah, good idea
18:19:23 <shapr> mgsloan: Doing something nifty?
18:19:34 <shapr> @users
18:19:35 <lambdabot> Maximum users seen in #haskell: 516, currently: 467 (90.5%), active: 18 (3.9%)
18:19:42 <chr1s> dons: you're going to love this!
18:19:55 <mgsloan> shapr - thinking I might soonish :)
18:20:02 <shapr> Cool!
18:20:13 <electronx> lots of people in haskell lately
18:20:23 <electronx> wonder why
18:20:26 <mgsloan> ?users
18:20:26 <lambdabot> Maximum users seen in #haskell: 516, currently: 468 (90.7%), active: 18 (3.8%)
18:20:28 <mmorrow> killed circo again. on second look, i don't think it was close to finishing that first time.
18:20:31 <shapr> mgsloan: Are you permanently in WA?
18:20:35 <mgsloan> yes
18:20:36 <shapr> electronx: Lately?
18:20:40 <electronx> ya
18:20:41 <shapr> mgsloan: Ooh, doing what?
18:20:43 <mgsloan> Univesity of washington actually
18:20:49 <shapr> electronx: Lately for me is the last seven years :-)
18:20:51 <dons> chr1s: ... :)
18:20:52 <mgsloan> unfortunately not attending icfp :(
18:21:06 <chr1s> http://chris.slashpunt.org/tmp/package-sizes-all.png
18:21:06 <electronx> shapr: for me its past week :)
18:21:23 <dons> i wonder which language will be the language of choice for discriminating programmers...
18:21:23 <shapr> electronx: I think Haskell has been somewhat popular since 2005 or so.
18:21:26 <dons> woo
18:21:29 <mmorrow> chr1s: friggin rad.
18:21:36 <dons> awesome!
18:21:37 <mmorrow> what program are you making that with?
18:21:38 <electronx> shapr: i mean number of people has increased in the last week
18:21:39 <dcoutts> chr1s: these are excellent pics
18:21:39 <shapr> It's hard to quantify popular.
18:21:44 <chr1s> thanks
18:21:52 <idnar> in haskell, or in #haskell?
18:21:57 <electronx> #haksell
18:21:58 <ivanm> shapr, mgsloan: since when has the university of washington had a campus in Western Australia? :p
18:22:08 <chr1s> mmorrow: http://services.alphaworks.ibm.com/manyeyes
18:22:16 <electronx> any graphical debugers of ghc?
18:22:23 <sbahra> chr1s, 404
18:22:24 <ivanm> chr1s: is that meant to be the haskell multi-gun death star? :p
18:22:26 <mmorrow> err, that link broke
18:22:28 <mgsloan> ivanm - well I'm pretty sure I'm in seattle right now :)
18:22:29 <shapr> ivanm: It's a remote extension campus.
18:22:31 <mmorrow> but i have the name now...
18:22:36 <sbahra> http://services.alphaworks.ibm.com/manyeyes/home
18:22:36 <lambdabot> Title: Many Eyes
18:22:45 <electronx> debugging more then 4k lines is hard with ghc
18:22:46 <mmorrow> http://services.alphaworks.ibm.com/manyeyes/home
18:22:47 <lambdabot> Title: Many Eyes
18:22:49 <shapr> Sort of like the University of Phoenix Arizona has a large facility here in Boston.
18:22:59 <ivanm> mgsloan: well, he asked if you were permanently in WA... last I checked, WA == Western Australia :p
18:23:11 <shapr> ivanm: Extension campus, I'm certain.
18:23:26 <chr1s> http://services.alphaworks.ibm.com/manyeyes/view/SLinXQsOtha6mFkKHVTYQ2~
18:23:27 <lambdabot> Title: Many Eyes: Hackage visualized., http://tinyurl.com/3q48fh
18:23:29 <shapr> mgsloan: Getting another degree? become a teacher?
18:23:32 <mgsloan> ivanm - well to me it means washington :)
18:23:40 <mgsloan> lol no.  I'm 18, a freshman
18:23:49 <mgsloan> but I'm majoring in CS, yes
18:23:49 <ivanm> heh, at least you got it.... I'm not sure if shapr did ;-)
18:24:02 <mgsloan> classes start on the morrow
18:24:02 <shapr> ivanm: I got it, I was just trying to tease you back!
18:24:16 <shapr> cool!
18:24:38 <ivanm> heh
18:24:46 <ivanm> mgsloan: but not on the mmorrow? :p
18:24:53 <shapr> mgsloan: Oh, I got you confused with someone else, doh!
18:25:00 * shapr sighs
18:25:05 <shapr> I've spent too much time away from #haskell :-(
18:25:16 <mgsloan> shapr - ahh, me too, i suppose
18:25:30 * ivanm hacks into shapr's computer, and sets it so that he's permanently signed into #haskell
18:25:32 <mgsloan> I feel kinda selfish.. i always pop in here when i have a question or something
18:25:51 <mgsloan> but hopefully I'll finish off my simple protocol buffers lib and give something back..
18:26:10 <sbahra> give them a hug
18:26:15 <dons> chr1s: super awesome. i'll credit tupil for data visualisation in the talk :)
18:26:17 <chr1s> mgsloan: that's okay, we're secretly training you to answers questions just like us.
18:26:24 <chr1s> dons: lol
18:26:44 <mgsloan> lol, nice. yeah, I could, i'm decently proficient in the haskell arts
18:26:56 <mgsloan> a few milliolegs maybe
18:27:37 <juhp> chr1s: many eyes gives me java error "Report code: -YUMTLL"
18:28:07 <chr1s> juhp: ah, too bad. I didn't write the java code, I guess I can't help you with that.
18:28:23 <juhp> :)
18:28:35 <juhp> maybe my java is too free :)
18:28:40 <mmorrow> too bad manyeyes has been swallowed by the ibm acquisition machine
18:28:49 <ivanm> juhp: iced tea?
18:28:57 <juhp> yeah openjdk
18:29:04 <chr1s> hey, somebody needs a bubble graph! ;)
18:30:55 <dons> live news from icfp contest results... http://twitter.com/galoisinc
18:30:56 <lambdabot> Title: Twitter / galoisinc
18:31:16 <dcoutts> Haskell submissions are up! C submissions are down
18:31:28 <dcoutts> C++ and python are also up
18:31:32 <dcoutts> perl also down
18:31:49 <dcoutts> comparing submissions vs 2002
18:32:14 <Igloo> Why 2002?
18:32:25 <dcoutts> that's when Tim has data from
18:32:38 <sbahra> damn
18:32:40 <sbahra> this was in md?
18:32:56 <sbahra> UPC consortium was going on at the same time :-(
18:40:34 <ivanm> winner announced yet?
18:40:41 <dons> not yet...
18:40:42 <dcoutts> not yet
18:40:45 <dons> hah
18:41:01 <dcoutts> we're getting the funny stats and quotes atm
18:41:17 <dcoutts> like the things people said in their README and code comments
18:41:18 <ivanm> ahhh
18:41:25 <dcoutts> there seemed to be a lot of drunk code
18:41:31 <dcoutts> class DrunkenDriver etc
18:42:14 <leimy> http://hpaste.org/10642  <-- anagram finder... uses tons of stack space, any way to make this more memory efficient?
18:42:18 <ivanm> why drunk?
18:42:31 <dcoutts> ivanm: the problem was to guide a martian rover around
18:42:46 <ivanm> ...so?
18:42:47 <dcoutts> so many teams labeled their driving strategies
18:42:50 <ivanm> ahhh
18:43:44 <TomMD> dcoutts: Did you know that hackage-server (happs, it seems) terminates when it can't contact DNS?  Wondering if anyone else noticed - its slightly annoying.
18:44:23 <dcoutts> TomMD: I did see that you found that. I don't have a solution yet
18:44:36 <dcoutts> TomMD: is that just when the server first starts?
18:44:40 <TomMD> Punt to happs, unless I'm wrong and its not their fault.
18:44:57 <dcoutts> TomMD: if it's at startup then it might be my fault
18:45:09 <TomMD> dcoutts: No, I can block the DNS through any number of means and it will cause hackage-server to terminate with said message in mid operation.
18:45:27 <dcoutts> TomMD: hmm, I don't know why that would be
18:45:49 <dcoutts> TomMD: I'd hope we're not doing a reverse dns lookup on all clients, that'd be bad
18:45:55 <TomMD> When sniffing, I see arp requests for the DNS server.  After a timeout the name resolution failure occurs.
18:46:05 <TomMD> dcoutts: Yes, quite.
18:46:22 <dcoutts> TomMD: take a look at the HAppS source
18:46:46 <dcoutts> ohh, results coming up...
18:47:00 <dcoutts> 140 entries in the lightening round
18:47:08 <dcoutts> 336 entries in the regular round
18:47:08 <Saizan> TomMD: like this? Main: getNameInfo: does not exist (Temporary failure in name resolution)
18:47:28 <chr1s> a graph of haskell dependencies: http://services.alphaworks.ibm.com/manyeyes/view/SLinXQsOtha6zFUiYuUYQ2~
18:47:32 <lambdabot> Title: Many Eyes: Haskell dependencies, http://tinyurl.com/458aew
18:47:59 <dcoutts> judges prize winner coming up...
18:48:13 <dcoutts> solo entry
18:48:17 <dcoutts> Tex!?!
18:48:24 <chr1s> omg.
18:48:35 <palmerc> Hi. data Tree a = Atom String | Term String [Tree a]
18:48:37 <dcoutts> Latex with perl wrapper
18:48:37 <ivanm> dcoutts: you're kidding me... someone programmed in a type-setting language? :o
18:48:43 <dmwit> dcoutts: I saw the blog post about writing that.  wacky
18:48:48 <TSC> leimy: How do you run your anagram-program to make it use lots of stack space?
18:48:50 <dcoutts> perl wrapper for for network stuff
18:48:52 <ivanm> chr1s: doesn't show up here... and I'm using sun's jdk-6 :s
18:49:00 <ivanm> (maybe it doesn't like *nix?)
18:49:03 <dcoutts> visualized using postscript
18:49:10 <ivanm> dmwit: link?
18:49:10 <chr1s> kosmikus: was that you?
18:49:12 <chr1s> ;)
18:49:12 <palmerc> I want to write a function that prints that data structure out and I am having trouble doing that
18:49:18 <leimy> TSC: anagrams >>= putStrLn . show
18:49:25 <ivanm> palmerc: don't think you can...
18:49:31 <dons> judges rize goes to solo guy using TeX
18:49:38 <palmerc> ivanm: Why is that?
18:49:38 <leimy> The problem is I kind of need that Map built up before I can do the other processing I want
18:49:45 <leimy> it's a function of the size of /usr/share/dict/words
18:49:46 <dcoutts> Stephen Hicks, the lone TeXnician
18:49:58 <dmwit> http://sdh33b.blogspot.com/2008/07/icfp-contest-2008.html
18:49:59 <lambdabot> Title: My Code Blog: ICFP Contest 2008
18:49:59 <TomMD> Saizan: Yes, like that!
18:50:01 <dmwit> ivanm: That?
18:50:03 <ivanm> you can put "deriving (show)" on the end that will display the actual data structure used for a particular instance, but not for an uninitialised data structure
18:50:07 <TSC> It works here without actually overflowing the stack
18:50:08 <dcoutts> dmwit: yes, him
18:50:15 <leimy> TSC: what platform?
18:50:26 <ivanm> dmwit: yeah
18:50:26 <leimy> I had to crank my stack way up
18:50:28 <dmwit> It was on proggit.
18:50:30 <TSC> Linux, GHC 6.8.2
18:50:31 <dcoutts> "Stephen Hicks is an extremely cool hacker" wins judges prize and $500
18:50:33 <TSC> Compiling with -O2
18:50:41 <palmerc> sorry I left off deriving (Eq,Ord,Read,Show) for brevity
18:50:58 <chr1s> ivanm: it takes a while to render.
18:51:02 <ivanm> oh...
18:51:08 <dons> http://www.reddit.com/r/programming/comments/735fx/live_from_icfp_2008_icfp_programming_contest/
18:51:09 <dcoutts> Next up, the Lightening Round
18:51:10 <lambdabot> Title: Live from ICFP: 2008 ICFP programming contest results! : programming, http://tinyurl.com/52ksd5
18:51:14 <ivanm> nope, it's still not doing anything
18:51:36 <Saizan> TomMD: this should help then, even if i'm not 100% sure on my comments in the log, http://code.google.com/p/happs/issues/detail?id=40&colspec=ID%20Type%20Status%20Priority%20Milestone%20Owner%20Summary%20ETA%20Modified
18:51:38 <lambdabot> Title: Issue 40 - happs - Google Code, http://tinyurl.com/4tltvn
18:51:38 <palmerc> I have come up with some sample input but I really am having making the leap from basic Haskell to complicated Haskell
18:51:48 <TSC> Even without optimisation it works
18:51:58 <chrisdone> palmerc: programming in the type system? :P
18:52:30 <leimy> tSC: seems I should be using -O2 all the time
18:52:31 <palmerc> Here is an example tree t2 = Term "term1" [ Atom "atom1", Term "term2" [Atom "atom2", Atom "atom3"]]
18:52:51 <ivanm> palmerc: ahhh
18:53:00 <dcoutts> ocaml wins lightening round!
18:53:04 <ivanm> then just put "deriving (Show)" on the end, and do show tree ;-)
18:53:05 <palmerc> I want to print that and other structures
18:53:07 <leimy> TSC: that's pretty cool... thanks :-)
18:53:08 <palmerc> out
18:53:18 <TSC> You're welcome
18:53:28 <ivanm> printing instances is possible, printing the actual structure isn't ;-)
18:53:54 <chr1s> here's a png of the last graph: http://chris.slashpunt.org/tmp/package-deps.png
18:53:58 <palmerc> I am actually supposed to read in the string version and put it back into the data structure but I didn't get anywhere with that I thought about printing out first
18:54:17 <palmerc> ivanm: I see
18:54:20 <waynemokane> if I am getting a timer_create error when building ghc, does that mean the binary I'm trying to bootstrap was built with a newer glibc than I have on my box?
18:55:31 <palmerc> ivanm: I have tried variations like this just to get something to print out
18:55:36 <shapr> Whoa, FermatsLastMargin shows up on that graph...
18:55:41 <palmerc> -- Generate the string representation of the tree
18:55:41 <palmerc> treeToString :: Tree -> String
18:55:41 <palmerc> treeToString Atom str = str : "(" : treeToString ++ ")"
18:55:41 <palmerc> treeToString Term str [Tree] = str : "(" : treeToString ++ ")"
18:56:01 <palmerc> but that obviously won't work
18:56:19 <Saizan> you need to put parenteses around the patterns
18:56:33 <ivanm> treeToString (Atom str) = "Atom " ++ str
18:56:34 <palmerc> treeToString (Atom str)
18:56:41 <Saizan> yeah
18:56:51 <palmerc> ... testing ...
18:56:53 <Saizan> and (Term str trees) = ..
18:57:01 <ivanm> treeToString (Term str [trees]) = "Term " ++ str ++ (map treeToString trees)
18:57:03 <ivanm> something like that
18:57:11 <Saizan> without []
18:57:12 <waynemokane> is Debug.Trace essentially a clean way of doing a bunch of putStrLns?  or is there some other power it has
18:57:19 <Saizan> if you don't want to match a singleton list
18:57:20 <ivanm> might need to unwords it or something
18:57:31 <ivanm> waynemokane: well, it prints to StdErr IIRC
18:57:39 <dcoutts> And the winner is Team SmartAass
18:57:40 <ivanm> and you shouldn't use it for anything except debugging purposes :p
18:57:44 <ivanm> dcoutts: which used?
18:57:47 <dcoutts> Java!
18:57:49 <dcoutts> Nooo
18:57:52 <ivanm> *shudder*
18:57:59 <ivanm> I worked on a project called SmartAss in Java :s
18:58:05 <Saizan> java..
18:58:10 <waynemokane> so trace has side effects?
18:58:10 <dcoutts> Java is the programming tool of choice for discriminating hackers
18:58:13 <waynemokane> @type trace
18:58:14 <lambdabot> Not in scope: `trace'
18:58:17 <ivanm> dcoutts: they're team didn't have anything to do with assignment generation, did it? :p
18:58:21 <waynemokane> bah... well anyway there is no constraint on MonadIO
18:58:26 <ivanm> dcoutts: for lightning hackers you mean? :p
18:58:37 <dcoutts> ivanm: no, the main contest
18:58:39 <ivanm> waynemokane: well, it prints something out, so yes ;-)
18:58:40 <ivanm> dcoutts: :o
18:58:46 <ivanm> so the tex guy one lightning then?
18:58:51 <dcoutts> ivanm: ML won the lightening
18:59:05 <dcoutts> Tex guy won the judges prize
18:59:12 <ivanm> oh, the _judges_ prize
18:59:14 <Saizan> waynemokane: trace str x ~= unsafePerformIO (putStrLn str) `seq` x
18:59:27 <ivanm> but... isn't Java one of the most anti-FP languages available? :o
18:59:36 <dons> Top 10 languages: Java, C++, Java, Haskell, Haskell, C , C++ , C , C++, C++
18:59:38 <dons> woo!
18:59:40 * ivanm obviously isn't discerning enough)
18:59:49 <dcoutts> ivanm: the ICFP contest is not biased to functional languages especially
18:59:51 <ivanm> dons: woo what, the amount of C*?
18:59:55 <ivanm> dcoutts: yeah, I know
19:00:00 <ivanm> but it's the icFP contest!
19:00:09 <dons> its a free for all. :)
19:00:11 <kosmikus> dons: good result for Haskell, but quite bad for FP in general
19:00:23 <dons> yes.
19:00:24 <palmerc> Ok so it is complaining that Tree is not applied to enough type arguments
19:00:31 <palmerc> What exactly does that mean
19:00:31 <dons> visualisation perhaps is a problem. we'll need to analyse.
19:01:15 <chr1s> I heard good things about Haskell and OpenGL, maybe we need better docs there?
19:01:33 <dcoutts> and GL can be used with Gtk quite well
19:01:51 <dcoutts> for UI widgets plus visualisation output
19:02:41 <kosmikus> I think we'll have to make it a priority to beat Team Smartass next year
19:02:56 <eelco> with a functional language too ;)
19:02:57 <dons> those guys own this contest :)
19:03:05 <dons> though at least they used haskell in the past.
19:03:05 <kosmikus> yes, they're really good
19:03:07 <dmwit> palmerc: Try "Tree a" instead.
19:03:08 <chr1s> I'm in =)
19:03:14 <dmwit> palmerc: ... or "Tree Int" or whatever.
19:03:15 <dcoutts> kosmikus: we'll need to put together a great team
19:03:18 <dons> kosmikus: others have described them as professional puzzle solvers :)
19:03:20 <kosmikus> dcoutts: yes
19:03:28 <Nafai> dcoutts: Is there a way to return an error code to the OS when I do "widgetDestroy window"?
19:03:29 <dons> (they've won other things besides ICFP)
19:04:06 <kosmikus> dons: actually, I'm somewhat pleased they won again. there was some (imho) unfair criticism against icfp 2007 that it favoured Smartass by being too similar to the 2006 edition.
19:04:06 <dmwit> exitWith ExitFailure?
19:04:11 <palmerc> dmwit: Is that in the functional prototype
19:04:18 <dcoutts> Nafai: exit code is returned using exitWith
19:04:21 <palmerc> As in treeToString Tree a -> String
19:04:26 <dons> kosmikus: yes. good.
19:04:34 * Nafai tries
19:04:34 <dmwit> palmerc: I have no idea what you're talking about.
19:04:40 <dmwit> palmerc: Was there a paste I missed?
19:04:50 <palmerc> sorry treeToString :: Tree a -> String
19:05:01 <TomMD> saizan: You mentioned it as an IPv6 bug.  I think you already know (but fyi anyway) my issue occurs on IPv4.
19:05:01 <palmerc> forgot the colons
19:05:18 <TomMD> s/ipv6 bug/bug in Network when using ipv6/
19:06:16 <palmerc> dmwit: I am trying to parse arbitrary trees with Haskell, and it isn't exactly the easiest first program.
19:06:31 <dmwit> ... "read"?
19:06:58 <palmerc> read?
19:07:30 <dmwit> > read "Node {rootLabel = 3, subForest = []}" :: Tree Int
19:07:31 <lambdabot>   Node {rootLabel = 3, subForest = []}
19:08:28 <dons> ciao all
19:08:44 <palmerc> Does that mean read can do it for you?
19:09:07 <chrisdone> bye dons
19:09:23 <dmwit> Pretty much, yeah.
19:10:35 <palmerc> So with my data structure... read "Term {rootLabel = 3, subForest = []}" :: Tree String
19:11:09 <dmwit> That is unlikely to work, unless your data structure is remarkably similar to Tree.
19:11:15 <dmwit> ...and your Strings are Ints. =)
19:11:55 <palmerc> Well to illustrate what I thought my data structure would look like:
19:12:02 <dmwit> But, if you derived "Read" and "Show" instances, it should be true that (read . show) === id.
19:12:03 <mmorrow> , show (Node 3 [])
19:12:05 <lunabot>  "Node {rootLabel = 3, subForest = []}"
19:12:08 <palmerc> data Tree a = Atom String | Term String [Tree a] deriving (Eq,Ord,Read,Show)
19:12:12 <mmorrow> , show (Node "3" [])
19:12:13 <lunabot>  "Node {rootLabel = \"3\", subForest = []}"
19:12:18 <palmerc> t2 = Term "term1" [ Atom "atom1", Term "term2" [Atom "atom2", Atom "atom3"]]
19:12:25 <dmwit> palmerc: But you don't use 'a'!
19:12:39 <palmerc> I got that from the Haskell book
19:12:43 <palmerc> Ummm
19:12:50 <palmerc> I guess I don't need it?
19:12:59 <mmorrow> , fmap read (read (show (Node "3" [])) :: Tree String) :: Tree Int
19:13:01 <lunabot>  Node {rootLabel = 3, subForest = []}
19:13:52 <mmorrow> termToTree (Node x xs) = Term x (fmap termToTree xs)
19:13:55 <mmorrow> oops
19:13:59 <mmorrow> treeToTerm
19:14:21 <dmwit> termFromTree
19:14:29 <mmorrow> treeAsTerm
19:15:13 <mmorrow> treeSurpriseNowATerm
19:16:31 <mmorrow> oh
19:16:58 <mmorrow> treeToTerm (Node x []) = Atom x ; treeToTerm (Node x xs) = Term x (fmap termToTree xs)
19:17:56 <mmorrow> that's sucky since the datatype allows inconsistent versions of terms (ie Term x [])
19:18:22 <palmerc> I didn't create it :)
19:18:31 <mmorrow> i'd modify it :)
19:18:58 <mmorrow> s/:)/;)/
19:19:08 <Nafai> http://hpaste.org/10643 <- I can't get keyPressHandler to compile
19:19:14 <palmerc> BTW Where did the data constructor Node come from?
19:19:34 <mmorrow> @src Tree
19:19:34 <lambdabot> Source not found. Wrong!  You cheating scum!
19:19:50 <TomMD> @src accept
19:19:51 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:19:54 <mmorrow> , (text . pprint . cleanNames') $(lift =<< ''Tree)
19:19:56 <lunabot>      Couldn't match expected type `Q a' against inferred type `Name'
19:19:59 <dmwit> ?src Data.Tree.Tree
19:20:00 <lambdabot> Source not found. Maybe you made a typo?
19:20:00 <TomMD> Humm, dart its limitation to base.
19:20:03 <mmorrow> , (text . pprint . cleanNames') $(lift =<< reify ''Tree)
19:20:05 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
19:20:06 <dmwit> ?source Data.Tree
19:20:07 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
19:20:12 <TomMD> ?src Maybe
19:20:12 <lambdabot> data Maybe a = Nothing | Just a
19:20:12 <mmorrow> , (text . pprint . cleanNames') $(lift =<< reify ''Forest)
19:20:14 <lunabot>  type Forest a = [] (Tree a)
19:20:28 <mmorrow> gah
19:21:07 <Nafai> Could someone look at my paste?
19:21:09 <palmerc> oh so it is a builtin
19:21:22 <mmorrow> palmerc: well, it's defined in Data.Tree
19:21:36 <sbahra> http://darcs.haskell.org/packages/base/Data/Tree.hs = 404?
19:21:44 <mmorrow> it could just as well be defined in your module, and Data.Tree not imported...
19:22:12 <mmorrow> , [t|[] (Tree a)|]
19:22:13 <lunabot>   Not in scope: type variable `a'
19:22:19 <mmorrow> , [t|forall a. [] (Tree a)|]
19:22:20 <lunabot>  ForallT [a_0] [] (AppT (ConT []) (AppT (ConT Tree) (VarT a_0)))
19:22:35 <palmerc> I just added import Tree
19:23:00 <dmwit> Nafai: Where is it?
19:23:07 <mmorrow> , [t|forall a. [a]|]
19:23:08 <dmwit> palmerc: Unless you're in Hugs, you should import Data.Tree.
19:23:09 <lunabot>  ForallT [a_0] [] (AppT ListT (VarT a_0))
19:23:14 <Nafai> http://hpaste.org/10643
19:23:24 <palmerc> you are right
19:23:27 <palmerc> again
19:24:29 <mmorrow> , let fixup (ConT ''[]) = ListT in (text . pprint . cleanNames' . everywhere (mkT fixup)) $(lift =<< reify ''Forest)
19:24:29 <lunabot>   Parse error in pattern
19:24:52 <dmwit> Nafai: exitWith (ExitFailure 1) -- or whatever exit code you wanted
19:25:09 <mmorrow> , let fixup (ConT n) | n==''[] = ListT  ; fixup t = (t::Type) in (text . pprint . cleanNames' . everywhere (mkT fixup)) $(lift =<< reify ''Forest)
19:25:11 <lunabot>  type Forest a = [Tree a]
19:25:30 <Nafai> Ah
19:25:31 <Nafai> Thanks :)
19:25:38 <palmerc> So when I import Data.Tree how do I add the Atom and Term concept
19:26:10 <dmwit> Nafai: Note that you can safely drop the "return True" after that, as exitWith never returns.
19:26:22 * Nafai nods
19:26:57 <mmorrow> (so its return type will be inferred as (m Bool))
19:27:28 <mmorrow> (replace m with whatever monad you're in)
19:27:44 <mmorrow> err
19:27:47 <mmorrow> @type exitWith
19:27:48 <lambdabot> Not in scope: `exitWith'
19:28:05 <mmorrow> i think it's :: ExitCode -> a ?
19:28:13 <mmorrow> or ExitCode -> IO a ?
19:28:29 <dmwit> IO a
19:28:30 <mmorrow> exitWith :: forall a. ExitCode -> IO a
19:28:38 <mmorrow> dang
19:29:08 <mmorrow> i guess that's a good thing, or else you'd be able to use it willynilly like how error is used
19:29:33 * mmorrow hates error
19:30:24 <Apocalisp> In Soviet Russia, error hate you.
19:30:31 <mmorrow> heh
19:30:43 <mmorrow> , (text . pprint . cleanNames') $(lift =<< reify 'error)
19:30:45 <lunabot>  error :: forall a . [] Char -> a
19:30:55 <mmorrow> , let fixup (ConT n) | n==''[] = ListT  ; fixup t = (t::Type) in (text . pprint . cleanNames' . everywhere (mkT fixup)) $(lift =<< reify 'error)
19:30:57 <lunabot>  error :: forall a . [Char] -> a
19:31:13 <mmorrow> @src error
19:31:13 <lambdabot> error s = throw (ErrorCall s)
19:31:18 <mmorrow> @src ErrorCall
19:31:18 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:31:29 <palmerc> mmorrow: I just found a post about Trees with your name on it
19:31:37 <mmorrow> palmerc: hehe
19:31:47 <palmerc> google group
19:31:56 <mmorrow> Trees are cool
19:32:09 <mmorrow> and useful and ubiquitous
19:32:31 <palmerc> Well they would be cooler if Haskell made more sense :)
19:32:41 <mmorrow> heh, it will soon
19:34:42 <palmerc> Are these libraries documented somewhere?
19:35:02 <dmwit> ?docs Data.Tree
19:35:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
19:35:11 <dmwit> Yes, but not there. =P
19:35:16 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/
19:35:17 <lambdabot> Title: Haskell Hierarchical Libraries
19:35:52 * dmwit notes that two of the functions in the Data.Tree module are documented as "neat"
19:35:52 <palmerc> Not to sound totally dumb, but are you type ?docs Data.Tree into ghci
19:36:05 <dmwit> No, unless you install lambdabot locally, then get GoA.
19:37:31 <palmerc> ok so I see where you got that rootLabel and subForest bit
19:41:15 <mmorrow> palmerc: haskell.org has all the stdlib docs, along w/src
19:41:29 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/
19:41:29 <lambdabot> Title: Haskell Hierarchical Libraries
19:41:42 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Tree.html
19:41:44 <lambdabot> Title: Data.Tree, http://tinyurl.com/2phbrb
19:41:48 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Tree.html
19:41:49 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5deb2l
19:42:27 <mmorrow> oh, i see dmwit already said this
19:43:01 <dmwit> It's the Dvorak keyboard, it makes me more productive.
19:43:04 <dmwit> I have more friends now.
19:43:39 <mmorrow> did the dvorak give you rippling abs, too?
19:43:54 <dmwit> No, that's from the situps. ;-)
19:44:20 <mmorrow> oh, right.
19:51:49 <sebaseba> Colemak ftw
19:53:23 <dmwit> where ftw = for the weird
19:54:41 <sebaseba> good one!
20:17:21 <dancor> if r has type   State a (Maybe String)   then how do i apply read to r iff it is a Just to get r' with type   State a (Maybe Int)   i thought   r' <- read <$> r   would work
20:17:52 <dmwit> r >>= fmap read
20:17:58 <dmwit> err...
20:18:01 <dmwit> not quite =P
20:18:09 <dmwit> fmap (fmap read) r
20:19:36 <dmwit> I guess ((read <$>) <$> r) would probably work, too, if you're into that kind of thing.  Let's see...
20:19:50 <dmwit> :t \r -> (read <$>) <$> r
20:19:52 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f, Read a) => f1 (f String) -> f1 (f a)
20:20:23 <dancor> so we need two fmaps bc there are two monads
20:20:28 <dmwit> yep
20:20:49 <dmwit> You could use a StateT a Maybe, then you could "lift" the read into your monad.
20:20:58 <dmwit> But it would still be a lift and an fmap.
20:21:03 <dancor> either way, i bet it gets awful with many monads deep
20:21:15 <dancor> do ppl ever have like 5 monads deep
20:21:20 <dmwit> With many monads, you use monad transformers that automatically do the right number of lifts.
20:21:38 <dancor> don't you still need to count your lifts
20:21:41 <dmwit> nope
20:21:50 <dmwit> Not in most good monad transformer stacks.
20:22:43 <lispy> :t (==)
20:22:44 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:23:06 <geezusfreeek> usually you use newtype to make a new monad out of smaller stacks, along with some helper functions, then you can further transform that monad with other transformers, etc. until you have all the abstractions you need
20:23:44 <palmerc> mmorrow?
20:23:55 <mmorrow> hi
20:23:56 <geezusfreeek> it's a lot like the decorator pattern in OOP, i suppose
20:24:48 <palmerc> mmorrow: I am still messing with my assigned task of printing out the stupid data structure. I can't seem to get past the fact I am passing the wrong type
20:24:57 <palmerc> treeToString :: Tree -> String
20:24:57 <palmerc> treeToString (Atom x) = x
20:24:57 <palmerc> treeToString (Term x xs) = Term x (treeToString xs)
20:25:21 <palmerc> treeToString (Term x xs) = Term x (fmap treeToString xs)
20:25:25 <mmorrow> ah, so you're trying to do (Term -> String), when you need to be doing (Tree  -> String)
20:25:28 <palmerc> sorry last line is here
20:25:35 <mmorrow> so you need a function (Term -> Tree)
20:25:51 <mmorrow> then to  (treeToString . termToTree) :: Term -> String
20:25:54 <palmerc> I am trying get just print out the data
20:25:55 <mmorrow> s/to/do/
20:26:04 <mmorrow> something like
20:26:17 <palmerc> I need to be able to round trip
20:26:24 <palmerc> s2 = "term1(atom1,term2(atom2,atom3))"
20:26:25 <dmwit> palmerc: You can use "show", or fix your current function.
20:26:26 <palmerc> thisat
20:26:26 <mmorrow> (also, there's a drawTree :: Tree String -> String)
20:26:28 <palmerc> that
20:26:30 <dmwit> palmerc: The problem is your last line.
20:26:39 <mmorrow> how do you mean "round trip"?
20:26:40 <palmerc> to
20:26:43 <palmerc> t2 = Term "term1" [Atom "atom1", Term "term2" [Atom "atom2", Atom "atom3"]]
20:27:00 <dmwit> palmerc: treeToString (Term x xs) = Term x foo -- this will return a Tree, not a String
20:27:15 <palmerc> ok
20:27:23 <dmwit> palmerc: But if you just want the simplest thing possible, use show.
20:27:24 <dmwit> :t show
20:27:25 <lambdabot> forall a. (Show a) => a -> String
20:27:25 <geezusfreeek> and also if xs is a list, then treeToString will not work on it
20:27:46 <dmwit> geezusfreeek: He revised it to use fmap.
20:27:54 <dmwit> Which should work just fine.
20:28:18 <palmerc> I had deleted fmap in a vain attempt to make Haskell like my program
20:28:19 <geezusfreeek> oh okay
20:29:01 <palmerc> Don't I want treeToString (Term x xs) = Term x foo to return a tree?
20:29:19 <palmerc> Now I am confused
20:29:22 <palmerc> :)
20:30:26 <Cale> palmerc: uh, doesn't the name treeToString suggest otherwise?
20:30:39 <palmerc> Well yes, I do want a string
20:30:50 <dmwit> palmerc: I would think you would want it to return a String, then.
20:31:04 <palmerc> I agree totally
20:31:20 <palmerc> the real question is, how do I do that
20:31:35 <dmwit> =)
20:31:41 <dmwit> Well, here's a few functions that can help:
20:31:44 <dmwit> :t (++)
20:31:45 <lambdabot> forall a. [a] -> [a] -> [a]
20:31:46 <dmwit> :t concat
20:31:47 <lambdabot> forall a. [[a]] -> [a]
20:32:00 <dmwit> Note that String = [Char].
20:32:03 <palmerc> well I had a printer for a simpler data structure
20:32:39 <palmerc> printer = collect_pars "(" ")" where
20:32:39 <palmerc>   collect_pars l r (C ns) =
20:32:39 <palmerc>     l++
20:32:39 <palmerc>       (concatMap (collect_pars l r) ns)
20:32:40 <palmerc>     ++r
20:33:04 <palmerc> but I couldn't get that adapted to this
20:34:03 <mmorrow> palmerc: something like this: http://hpaste.org/10644
20:34:16 <mmorrow> (converting to Tree to get drawTree for free)
20:35:11 <palmerc> so that is how you convert
20:36:02 * dmwit suggests that palmerc attempt to write his own printing function anyway
20:36:15 <palmerc> I agree
20:36:22 <dmwit> It's a pretty good exercise, and once you get the hang of it, the derived Show instances will make a lot of sense.
20:36:25 <palmerc> I need to understand the mechanics of what is going on
20:36:37 <palmerc> which now is near zero
20:36:49 <palmerc> I think imperatively
20:37:01 <dmwit> Okay, how would you do it imperatively?
20:37:03 <palmerc> and functionally is making my brain hurt
20:37:28 <palmerc> probably use an array
20:37:31 <palmerc> or stack
20:37:39 <dmwit> That doesn't say much.
20:37:43 <dmwit> *how* would you use it?
20:39:03 <sclv> mutation, duh. :-P
20:39:32 <palmerc> i am thinking
20:39:44 <dmwit> palmerc: It's expected.
20:40:04 <mmorrow> palmerc: then you can prettyprint Term something like http://hpaste.org/10644#a1
20:40:05 <dmwit> People who say "functional programming is hard" usually just haven't stopped to think how hard it would be imperatively.
20:40:13 <palmerc> well I was thinking I would shove the words and parens onto the stack
20:40:17 <dmwit> The real statement is, "programming is hard." =)
20:40:32 <palmerc> and then when I hit a right paren pop off tokens until I hit a left
20:40:34 <mmorrow> lists are stacks
20:40:48 <sclv> so is a call stack.
20:40:48 <dmwit> palmerc: Wait, are we talking about printing here, or parsing?
20:41:20 <palmerc> right now I am trying to print
20:42:05 <dmwit> Then I don't understand where this token popping is coming from.
20:42:06 <mmorrow> , let push = (:) ; pop [] = (Nothing, []) ; pop (x:xs) = (Just x, xs) in push 42 (push 12 [])
20:42:08 <lunabot>  [42,12]
20:42:14 <mmorrow> , let push = (:) ; pop [] = (Nothing, []) ; pop (x:xs) = (Just x, xs) in pop (push 42 (push 12 []))
20:42:15 <lunabot>  (Just 42,[12])
20:42:51 <mmorrow> , (head &&& tail) [0..9]
20:42:52 <lunabot>      Ambiguous occurrence `&&&'
20:42:58 <mmorrow> , (head Control.Arrow.&&& tail) [0..9]
20:42:59 <lunabot>  (0,[1,2,3,4,5,6,7,8,9])
20:43:07 <dmwit> What other (&&&) is there?
20:43:12 <mmorrow> Control.Category
20:43:21 <mmorrow> , id
20:43:21 <lunabot>      No instance for (Show (a -> a))
20:43:26 <mmorrow> err, actually no
20:43:30 <mmorrow> i'm not sure
20:43:30 <lunabot>   Not in scope: `t'
20:43:33 <dmwit> , (Control.Category.&&&) `asTypeOf` id
20:43:34 <lunabot>   Not in scope: `Control.Category.&&&'
20:43:44 <lunabot>  "foo"
20:43:45 <mmorrow> yeah, or else id would have been ambiguous
20:43:58 <dmwit> hehe
20:44:08 <dmwit> I bet lunabot doesn't understand privmsgs.
20:44:16 <lunabot>  "proof"
20:44:19 <palmerc> what is lunabot?
20:44:20 <dmwit> bwahaha
20:44:32 <lunabot>  "I really don't understand privmessages. What are privmessages?"
20:44:40 <mmorrow> heh, yeah i'm too lazy to add it
20:44:44 <mmorrow> palmerc: my bot
20:44:45 <dmwit> , fun "hey" :: Expr
20:44:46 <lunabot>   Not in scope: `fun'
20:44:46 <lunabot>  <interactive>:1:63: Not in scope: type constructor or class `Expr'
20:44:50 <dmwit> Ah, too bad. =)
20:44:54 <mmorrow> , text "hey"
20:44:55 <lunabot>  hey
20:45:02 <lunabot>  What are quotes?
20:45:08 <lunabot>   Not in scope: `sock'
20:45:08 <lunabot>  <interactive>:1:55: Not in scope: `puppeting'
20:45:12 <mmorrow> heh
20:45:15 <lunabot>  sock puppeting!
20:45:24 <lunabot>  dmwit++
20:45:26 <sclv> is lunabot based on mueval?
20:45:28 <dmwit> Rock!
20:45:51 <mmorrow> sclv: no, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=52
20:45:51 <lunabot>   Not in scope: `t'
20:46:25 <rwbarton> , fst
20:46:26 <lunabot>      Ambiguous occurrence `fst'
20:46:32 <mmorrow> shitcrap
20:46:35 <mmorrow> hmm
20:46:39 <rwbarton> looks like it's Control.Category.Cartesian
20:46:43 <mmorrow> ahh
20:46:56 <dmwit> , (Control.Category.Cartesian.&&&) `asTypeOf` id
20:46:57 <lunabot>      Occurs check: cannot construct the infinite type: a = a -> c
20:46:57 <mmorrow> i do have all 99 category-extras imported ;)
20:47:13 <mmorrow> cartesian is getting the chop
20:47:16 <rwbarton> ,instances Monad
20:47:16 <lunabot>   Not in scope: `instances'
20:47:16 <lunabot>  <interactive>:1:59: Not in scope: data constructor `Monad'
20:47:18 <rwbarton> :(
20:47:27 <geezusfreeek> all… 99?!
20:47:35 <dmwit> ?hackage category-extras
20:47:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
20:47:40 <geezusfreeek> (aren't there 100, or am i just crazy?)
20:47:42 <rwbarton> oh, it's not based on lambdabot at all
20:47:44 <rwbarton> ?
20:47:49 <dmwit> nope
20:47:56 <mmorrow> no. i used the ghc-api to write an evaluator
20:48:07 <sclv> oh nice!
20:48:08 <rwbarton> Got it.  I'll stop trying lambdabot commands then
20:48:09 <dmwit> Several people have made half-hearted attempts at replacing lambdabot (myself included). =)
20:48:22 <mmorrow> dynCompileExpr is perrrrrfect
20:48:24 <sclv> so you can do everything you want without plugins
20:48:26 <dmwit> lunabot and preflex are the best so far, I think.
20:48:34 <rwbarton> , text "mueval: parse error"
20:48:35 <mmorrow> sclv: totally.
20:48:35 <lunabot>  mueval: parse error
20:48:40 <mmorrow> heh
20:48:42 <dmwit> Oh, you used GHC api?
20:48:42 <rwbarton> mmorrow: broken :)
20:48:52 <dmwit> ?index unsafePerformIO
20:48:52 <lambdabot> System.IO.Unsafe, Foreign
20:48:54 <mmorrow> dmwit: yeah
20:48:55 <sclv> and its robust? is there a full repo somewhere?
20:49:01 <palmerc> I suppose that the Real World Haskell writer isn't in here?
20:49:06 <dmwit> , System.IO.Unsafe.unsafePerformIO (return "foo")
20:49:07 <lunabot>      Not in scope: `System.IO.Unsafe.unsafePerformIO'
20:49:08 <mmorrow> rwbarton: yeah, the bot part is hackish to say the least
20:49:17 <dmwit> Oh good, you got around that issue, at least.
20:49:25 <mmorrow> it communicates with the evaluator via runInteractiveCommand
20:49:33 <dmwit> palmerc: They go by dons, bos, and CosmicRay here, I think.
20:49:38 <geezusfreeek> palmerc: there are three of them, and there is usually at least one around
20:49:54 <mmorrow> (since it doesn't seem like there's any way to recover from eg "fix id" with the evaluator in the same program as the bot)
20:50:03 <mmorrow> and rlimits kills everything
20:50:07 <palmerc> Oh, the book looks good, although I have only finished Chapter 1-3
20:50:10 <palmerc> :)
20:50:52 <mmorrow> sclv: no repo at the moment, but i'll paste the newest version. i'm gonna make a repo once i get it working with 6.10, since the ghc-api is pretty unstable
20:51:18 <sclv> Do you think the ghc-api is in a state where we can build robust hot code swapping on top of it?
20:51:36 <mmorrow> the current version of the evaluator only works with a ghc-6.9 from augustish to about-last-weekish
20:52:38 <mmorrow> sclv: hmm. i think so. once we have 6.10 and can work from a stable base, i'd definitely be interested in pursuing that.
20:53:03 <SamB_XP> @remember mIRC %c03^_^
20:53:03 <lambdabot> Good to know.
20:53:07 <SamB_XP> hmm.
20:53:13 <SamB_XP> That wasn't what I wanted to do ...
20:53:14 * geezusfreeek wishes djinn understood lists
20:53:21 <SamB_XP> @remember mIRC %c03^_^
20:53:21 <lambdabot> It is stored.
20:53:25 <SamB_XP> arg
20:53:28 <SamB_XP> @remember mIRC %03^_^
20:53:28 <lambdabot> Nice!
20:53:33 <sclv> I've been working on some erlangish (emphasis on "ish") stuff that could be made really sweet with hot code swapping
20:53:39 <SamB_XP> how does that color syntax go?
20:53:50 <mmorrow> sclv: it'd probably entail extending some functionality, but that looks not that hard from looking at ghc/compiler/{GHC,InteractiveEval,et al}.hs
20:53:55 <SamB_XP> @forget mIRC %c03^_^
20:53:55 <lambdabot> Done.
20:53:57 <SamB_XP> @forget mIRC %c03^_^
20:53:57 <dmwit> SamB_XP: You need a literal byte 3.
20:53:57 <lambdabot> Done.
20:54:04 <dmwit> > say "foo"
20:54:05 <lambdabot>   mueval: Prelude.read: no parse
20:54:14 <SamB_XP> dmwit: so how does I type one?
20:54:18 <dmwit> , text "\3"
20:54:19 <lunabot>  
20:54:31 <dmwit> SamB_XP: I'm betting you can get it to happen that way.
20:54:43 <dmwit> SamB_XP: I think it only works in privmsgs, though.
20:54:43 <geezusfreeek> , text "\3foo"
20:54:44 <lunabot>  foo
20:54:50 <mmorrow> text [chr 0x2204]
20:54:52 <mmorrow> , text [chr 0x2204]
20:54:52 <lunabot>  
20:54:55 <dmwit> Needs more than just a \3, of course. =)
20:55:11 <mmorrow> ah crappy. i've gotta import some unicode handling or something
20:55:36 <mmorrow> > utf8s [chr 0x2204]
20:55:37 <lambdabot>   mueval: Prelude.read: no parse
20:55:43 <mmorrow> > utf8 (chr 0x2204)
20:55:46 <lambdabot>   mueval: Prelude.read: no parse
20:55:55 <palmerc> oh what is the . mean?
20:56:00 <palmerc> does
20:56:02 <dmwit> , text "\3\&5colored?"
20:56:02 <lunabot>  5colored?
20:56:16 <rwbarton> palmerc: function composition: (f . g) x = f (g x)
20:56:17 <palmerc> , text "\3\&5colored?"
20:56:18 <lunabot>  5colored?
20:56:26 <mmorrow> , text "\226\136\132"
20:56:26 <lunabot>  â
20:56:30 <mmorrow> gah
20:56:49 <palmerc> oh normally represented by a small hollow o
20:56:56 <palmerc> f o g
20:57:11 <mmorrow> sclv: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=59#a59
20:57:19 <sclv> any other files besides those two that I should look at?
20:57:22 <dmwit> palmerc: exactly
20:57:41 <dmwit> palmerc: It's not 'o' in Haskell because then you'd have to write `o` to get it infix, which is cumbersome at best. =P
20:57:44 <mmorrow> sclv: yeah. i'll make a quick list. one sec
20:57:51 <palmerc> I guess . is a good substitute until that character makes its way onto our keyboards
20:58:29 <SamB_XP> yeah, I can't type that here ;-)
20:59:12 <geezusfreeek> agda-mode for emacs allows you to type such symbols using their LaTeX names
20:59:19 <dmwit> color test
20:59:22 <sclv> ghc code is a thing of beauty.
20:59:24 <geezusfreeek> would be nice to have the same for haskell-mode
20:59:40 <sclv> I've poked around in the RTS before, but not the main compiler sources.
20:59:44 <rwbarton> how about M-x set-input-method TeX
21:00:19 <rwbarton> > let f ○ g = f . g in ((+1) ○ (*2)) 3
21:00:20 <lambdabot>   7
21:00:39 <dmwit> SamB_XP: (Did that work on your end?  Was "color test" in red?)
21:00:53 <SamB_XP> dmwit: sadly not :-(
21:00:57 <dmwit> ah
21:01:23 <palmerc> , rm -rf *
21:01:23 <lunabot>      The operator `*' [infixl 7] of a section
21:01:43 <dmwit> Oh come on, that's not valid Haskell. =)
21:02:24 <palmerc> Does it hold the last value in ghci, as in, can someone explain it in a nutshell
21:02:30 <dmwit> yes
21:03:13 <dmwit> With one exception: if the last action was an "IO foo", "it" will actually be a "foo", not an "IO foo".
21:03:23 <geezusfreeek> , system "echo 'uh oh'"
21:03:24 <lunabot>   Not in scope: `system'
21:03:32 <geezusfreeek> , System.Cmd.system "echo 'uh oh'"
21:03:33 <lunabot>   Not in scope: `System.Cmd.system'
21:03:41 <palmerc> hack the bot
21:04:03 <palmerc> , print "Hello, World"
21:04:03 <lunabot>      No instance for (Show (IO ()))
21:04:16 <dmwit> , fix show
21:04:16 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:04:34 <rwbarton> , inlinePerformIO (return 3)
21:04:35 <lunabot>   Not in scope: `inlinePerformIO'
21:04:39 <palmerc> , show "hello"
21:04:40 <lunabot>  "\"hello\""
21:04:44 <geezusfreeek> is lunabot on a whitelist or blacklist or other?
21:05:06 <dmwit> It seems to be on a whitelist system.
21:06:00 <dmwit> Since mmorrow said he had "all 99 category-extras imported". =)
21:06:25 <mmorrow> sclv: here's the list http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=59#a60
21:06:46 <mmorrow> the ByteCode* stuff in ghc/compiler/ghci/ is interesting as well
21:06:59 <sclv> awesome, thanks!
21:07:38 <sclv> I guess the issue is that you get bytecode-level performance with the naive way of hooking in...
21:08:00 <sclv> The trick is to get fully compiled and optimized too.
21:08:12 <palmerc> mmorrow: Why won't flatten work on the tree?
21:08:32 <dmwit> :t flatten
21:08:33 <mmorrow> geezusfreeek: it has no list, black or white. it imports modules by adding them to the Session explicitly, then during dynCompileExpr, only those are in scope
21:08:33 <lambdabot> forall a. Tree a -> [a]
21:08:44 <palmerc> :t flatten
21:08:45 <lambdabot> forall a. Tree a -> [a]
21:08:55 <dmwit> mmorrow: That's called a whitelist. =)
21:08:56 <mmorrow> palmerc: are you trying it on a Term instead of a Tree?
21:09:05 <geezusfreeek> mmorrow: i would call that a whitelist :P
21:09:06 <sclv> at which point, I think that'll be pretty unique -- vmless hot code swapping. (of course that's what plugins does, but unstably)
21:09:20 <electronx> i find it hard to believe that logo is more popular then haskell??????
21:09:26 <electronx> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
21:09:32 <lambdabot> Title: TIOBE Software: The Coding Standards Company
21:09:35 <mmorrow> geezusfreeek: yes, but a whitelist in the same way that ghc enforcing imports/exports in regular code is a whitelist
21:09:41 <dmwit> sclv: The GHC API has full support for compiling code at runtime.
21:09:48 <mmorrow> so yeah, whitelist :)
21:10:14 <palmerc> in other words do this:
21:10:16 <palmerc> flatten (termToTree t2)
21:10:57 <sclv> electronx: logo has a strong niche as a teaching language though, or used to at least.
21:11:17 <sclv> and besides, its functional :-)
21:11:35 <electronx> but how much better is haskell
21:11:51 <electronx> you use that as a teaching tool too
21:11:51 <mmorrow> sclv: totally! it'd be the bees knees to be able to get bytecode convenience/capabilities-wrt-dynamically-creating-whatever but s/bytecode/optimized machine code/
21:11:52 <geezusfreeek> i find it more interesting that haskell is higher on that list than objective-c
21:11:57 <dmwit> Nobody puts a lot of weight on the Tiobe index, anyway.
21:12:47 <electronx> well #logo is empty
21:13:13 <mmorrow> sclv: yeah, but plugins "cheats" by writing to a file in /tmp as an intermediate step ;)
21:13:33 <hml> i just got a mac book pro; i'm goingto remain running max osx ... what's the most painless way to isntall haskell on it?
21:13:51 <geezusfreeek> hml: there are pkgs for ghc, or you can do macports
21:14:05 <mmorrow> palmerc: exactly
21:14:07 <geezusfreeek> both are fairly painless, in my opinion, but macports takes a lot longer since it is a source distro
21:14:18 <geezusfreeek> and ghc takes a while to compile
21:14:20 <sclv> eh, I wouldn't mind cheating as long as it was working right. next thing you know, we'll have hot-loading haskell running network switches :-)
21:14:40 <mmorrow> hehe. the sooner the bettar!
21:14:49 <ozy`> geezusfreeek: I read that as "takes a week to compile" and almost agreed with you
21:15:12 <geezusfreeek> only takes me an hour or two :P
21:15:23 <geezusfreeek> or on my old g4 powerbook about 5 hours i think
21:15:29 <mmorrow> it's ok for plugins though, since it was/is the first. :)
21:15:50 <mmorrow> and the ghc-api didn't exist
21:15:52 <ozy`> geezusfreeek: yeah, I've got an old G4 powerbook, and it takes about that long
21:15:55 <mmorrow> ooh, that reminds me
21:16:29 <mmorrow> also, i wanna take a look at the code that plugins layers on top of Linker.hs
21:16:36 <ozy`> hml: don't trust macports for too much stuff. most of the builds tend not to work... GHC works though
21:16:43 <mmorrow> it chases deps and other misc
21:16:49 <ozy`> (but there are binaries you can download, if you're on intel)
21:17:07 <geezusfreeek> i have had problems with macports, but mostly just with it not being up to date all the time, not with things being broken
21:17:15 <palmerc> hml: I used macports
21:17:43 <palmerc> hml: Although I am in the macports sucks in general camp
21:18:07 <hml> got it; thanks
21:18:10 <palmerc> I have had broken issues
21:18:18 <palmerc> for other things
21:18:23 <hml> so the general  solution on the max is that macports/fink suck, there's no good alt to apt-get from ubuntu; just do ./configure, make, make install
21:18:33 <ozy`> macports is basically useless for most purposes... the only builds that actually work are the ones where it's easier to just install it yourself, anyway
21:18:35 <geezusfreeek> i don't like the way it handles multiple versions of things, mostly
21:19:27 <hml> how do i uninstall  max ports?
21:19:38 <ozy`> hml: delete /opt
21:20:27 <palmerc> is it installed as a pkg?
21:20:31 <palmerc> I forget
21:21:03 <ozy`> I think so
21:21:37 <palmerc> there is a folder you can go to and click on the pkg
21:22:07 <palmerc> They are called receipts
21:23:58 <palmerc> yep
21:24:06 <palmerc> under /Library/Receipts
21:25:21 <mmorrow> , fst (0,1)
21:25:21 <lunabot>  0
21:25:22 <palmerc> I believe if you double click MacPorts it should uninstall, but right now I am on a Ubuntu so can't tell you for sure
21:25:32 <mmorrow> , (head&&&tail) [0..9]
21:25:33 <lunabot>  (0,[1,2,3,4,5,6,7,8,9])
21:25:40 <hml> okay, so i found it in /library/receips
21:25:42 <mmorrow> ok, Control.Category.Cartesian go tthe chop
21:25:43 <hml> how do i use that to uninstall it?
21:26:00 <palmerc> Try double clicking it
21:26:06 <ozy`> I'm pretty sure that won't work
21:26:20 <ozy`> you can open it and then hit command-I to see the list of files it installed
21:26:20 <hml> pops up a msg "the selected file is a receipt"
21:26:29 <palmerc> good
21:26:33 <ozy`> yeah, it's not gonna remove it automatically
21:26:50 <hml> how do i use it tohow do i use the receipt to remove it?
21:35:36 <palmerc> Well you can do this
21:35:52 <palmerc> go into the .pkg directory and find Archive.bom
21:36:10 <palmerc> you can the list its contents using lsbom Archive.bim
21:36:13 <palmerc> you can the list its contents using lsbom Archive.bom
21:36:21 <palmerc> delete everything listed
21:36:27 <palmerc> I can't find an easier way
21:36:39 <palmerc> Anyway, good night everyone and thank you for the advice
21:40:11 <ddarius> My program runs a lot faster when it is (closer to being) correct.
21:43:47 <mmorrow> ddarius: still working on the svg colorizer?
21:44:29 <ddarius> mmorrow: Not really.  Just tweaking now.  It's producing reasonable pictures.  I'd just need to overlay the actual package names somehow.
21:44:52 <mmorrow> awesome. what does it do exactly?
21:45:37 <mmorrow> (or rather, what do you intend for it to do once it's finished?)
21:49:03 <mmorrow> re: overlaying names. i'm not sure if it's applicable to svg, but dot has an ouput format option that dumps a simply formatted txt file of the computed coordinates for each node, edge, etc.
21:51:29 <mmorrow> cat foo.dot | dot -Tplain > foo.txt
21:52:06 <mmorrow> dot -Tplain-ext has some more info, but i'm not sure exactly what
22:02:44 * ddarius learns not to use 2 decimal approximations when doing HSL -> RGB conversion.
22:03:11 <ddarius> A better/bigger kernel and I should be set.
22:08:35 * SamB_XP gives ddarius a 64-bit kernel ;-P
22:09:21 <ddarius> http://img99.imageshack.us/img99/2413/testid1.jpg
22:09:40 <mmorrow> beautiful
22:11:01 <mmorrow> ddarius: i'm extremely curious. is the code anywhere?
22:11:04 <ddarius> Made with vim and haskell and netpbm from scratch
22:11:30 <ddarius> It should fit in hpaste.
22:11:50 * mmorrow mentions to no one in particular that moonpatio.com:8080 has no limit on paste size ;)
22:12:03 <mmorrow> and better syntax highlighting imho
22:12:59 <ddarius> http://hpaste.org/10645
22:13:14 <mmorrow> actually, better syntax highlighting period
22:13:18 * mmorrow looks
22:13:42 <ddarius> It's not particularly pretty and by "not particularly", I mean not at all.
22:14:27 <ddarius> And I'm well aware that there are better ways of doing everything I'm doing there.
22:17:17 <mmorrow> ddarius: rad
22:18:00 <mmorrow> that looks like the first kick of a haskell imagemagick to me
22:20:03 <mmorrow> ddarius: this may be of interest: http://www1.cs.columbia.edu/~cs4162/html05s/assignment1.pdf
22:20:05 <lambdabot> Title: COMS 4162: Assignment 1—Image and Signal Processing
22:21:24 <mmorrow> oh, and the "support code" is here: http://www1.cs.columbia.edu/~cs4162/html05s/assignment1.zip
22:22:21 <mmorrow> (includes a sample solution (binaries for win+lin) for verification purposes)
22:25:48 <ddarius> I need to make command line options for most of those constants...
22:26:11 <ddarius> Playing with the hue is fun, and there's a lot that can be done with the kernel and the weight.
22:26:49 <mmorrow> totally and totally
22:34:47 <dmwit> , text "a\nb?"
22:34:48 <lunabot>  a
22:34:48 <lunabot>  b?
22:42:46 <lunabot>  
22:42:46 <lunabot>  
22:42:46 <lunabot>  
22:42:58 <dmwit> Ah, bummer.
22:44:20 <mmorrow> , )( "\226\136\132"
22:44:21 <lunabot>      Couldn't match expected type `[Char] -> a'
22:44:34 <mmorrow> , 0) `seq` ( "\226\136\132"
22:44:34 <lunabot>  â
22:44:40 <mmorrow> crap
22:44:48 <lispy> lunabot: you need to sit this one out.
22:45:04 <dmwit> ...what?
22:45:07 <dmwit> Those parens...
22:45:08 <lispy> lambdabot: show lunabot how it's done
22:45:34 <dmwit> , text "\226"
22:45:35 <lunabot>  â
22:45:47 <dmwit> , text "\2872"
22:45:48 <lunabot>  ସ
22:45:54 <dmwit> oh
22:45:59 <dmwit> , text "\x2872"
22:46:00 <lunabot>  ⡲
22:50:37 <dmwit> , text . unlines $ ["\x2880", "\x2884", "\x2886", "\x288e", "\x288e\x2801", "\x288e\x2811", "\x288e\x2831", "\x288e\x2871"]
22:50:37 <lunabot>  
22:50:37 <lunabot>  
22:50:37 <lunabot>  
22:50:45 <dmwit> ah, well
22:51:03 <dmwit> , text . unwords $ ["\x2880", "\x2884", "\x2886", "\x288e"]
22:51:04 <lunabot>     
22:51:36 <dmwit> , text "\x2880 \x2884"
22:51:37 <lunabot>   
22:51:44 <dmwit> , text "\x2880"
22:51:44 <lunabot>  
22:52:06 <dmwit> It worked before...
22:52:33 <rwbarton> yeah, lunabot, we get it.  â¢.
22:53:12 <dmwit> I was hoping to put on a cute braille-mation show for y'all, but I guess it didn't quite work out. =P
23:00:19 <mmorrow> dmwit
23:00:21 <mmorrow> , utf8 "\8704"
23:00:22 <lunabot>  
23:00:26 <mmorrow> grrrr
23:00:29 <mmorrow> hold on
23:01:30 <chylli> who is good at HDBC? I have a small problem.
23:10:15 <mmorrow> , toUTF8 "\8704"
23:10:15 <lunabot>  
23:10:30 <mmorrow> aaaargggghhh
23:12:27 <mmorrow> ok, i found it. it's mangling it because i'm doing filter (not . isControl) and this is picking up chars it shouldn't be
23:15:45 <mmorrow> , toUTF8 "\8704"
23:15:45 <lunabot>  ∀
23:16:00 <mmorrow> @yow
23:16:01 <lambdabot> I'm continually AMAZED at th'breathtaking effects of WIND EROSION!!
23:16:17 <mmorrow> , utf8enc "\8704"
23:16:17 <lunabot>  "\226\136\128"
23:16:26 <mmorrow> , (utf8dec . utf8enc) "\8704"
23:16:27 <lunabot>  "\8704"
23:17:25 <mmorrow> , toUTF8 "\8704\b\b\b\b\b\n\n\n\n\n"
23:17:25 <lunabot>  ∀
23:17:28 <Deewiant> , toUTF8 "\03bb"
23:17:29 <lunabot>  bb
23:17:36 <mmorrow> , toUTF8 "\b\b\b\8704\b\b\b\b\b\n\n\n\n\n"
23:17:37 <lunabot>  ∀
23:17:39 <mmorrow> yay
23:17:43 <Deewiant> , toUTF8 "\1673"
23:17:44 <lunabot>  ډ
23:17:50 <Deewiant> , toUTF8 "\955"
23:17:50 <lunabot>  λ
23:18:38 <mmorrow> , toUTF8 (fmap chr . take 20 $ [8704..])
23:18:39 <lunabot>  ∀∁∂∃∄∅∆∇∈∉∊∋∌∍∎∏∐∑−∓
23:18:52 <mmorrow> , toUTF8 (fmap chr [8704..])
23:18:53 <lunabot>  luna: out of memory (requested 1048576 bytes)
23:18:55 <mmorrow> , toUTF8 (fmap chr [8704..])
23:18:56 <lunabot>  luna: out of memory (requested 1048576 bytes)
23:19:18 <mmorrow> ohhh, since it goes through bytestring
23:19:22 <mmorrow> (maybe)
23:19:34 <mmorrow> , toUTF8 (fmap chr [8704..8800])
23:19:35 <lunabot>  ∀∁∂∃∄∅∆∇∈∉∊∋∌∍∎∏∐∑−∓∔∕∖∗∘∙√∛∜∝∞∟∠∡∢∣∤∥∦∧∨∩
23:19:45 <lispy> pretty
23:19:55 <lispy> now stop spamming us :)
23:19:58 <mmorrow> heh
23:20:52 <mmorrow> it'd be nice to have a function which emits the bytes which reset a terminal
23:21:36 <mmorrow> clear outputs "\ESC[H\ESC[2J" apparently
23:22:43 * mmorrow doesn't know enough about terminals to know if that is dependent on the termtype or what
23:24:45 <dmwit> , text . unlines $ ["\x2880", "\x2884", "\x2886", "\x288e", "\x288e\x2801", "\x288e\x2811", "\x288e\x2831", "\x288e\x2871"]
23:24:45 <lunabot>  
23:24:45 <lunabot>  
23:24:45 <lunabot>  
23:24:50 <mmorrow> haha, this'll clear your terminal
23:24:53 <mmorrow> text "\ESC[H\ESC[2J"
23:24:56 <mmorrow> (in ghci)
23:24:58 <dmwit> Still fail.
23:25:10 <dmwit> , text . unwords $ ["\x2880", "\x2884", "\x2886"]
23:25:11 <lunabot>   Ġ
23:25:12 <mmorrow> you have to do toUTF8
23:25:22 <mmorrow> , toUTF8
23:25:22 <RayNbow> <mmorrow> text "\ESC[H\ESC[2J" <-- does it? :p
23:25:22 <lunabot>      No instance for (Show (String -> UTF8))
23:25:25 <dmwit> oh yeah
23:25:26 <dmwit> heh
23:25:44 <dmwit> , toUTF8 . unwords $ ["\x2880", "\x2884", "\x2886", "\x288e", "\x288e\x2801", "\x288e\x2811", "\x288e\x2831", "\x288e\x2871"]
23:25:45 <lunabot>  ⢀ ⢄ ⢆ ⢎ ⢎⠁ ⢎⠑ ⢎⠱ ⢎⡱
23:25:46 <mmorrow> RayNbow: this does
23:25:54 <mmorrow> putStr "\ESC[H\ESC[2J"
23:26:04 <dmwit> Yep, good ol' VT100 codes.
23:26:10 <glguy> ?read "\ESC[H\ESC[2J"
23:26:10 <lambdabot>  [H[2J
23:26:17 <mmorrow> i hesitate to run text ... in lunabot because someone might be upset
23:26:21 <dmwit> The \ESC[H part probably isn't even necessary.
23:26:27 <dmwit> Just \ESC[2J
23:26:27 <mmorrow> i did
23:26:30 <mmorrow> clear > a
23:26:33 <mmorrow> then in ghci
23:26:39 <mmorrow> readFile "a"
23:26:48 <dmwit> \ESC[H # moves the cursor to the top left of the screen
23:26:52 <mmorrow> ah
23:27:23 <RayNbow> mmorrow: in Windows, the console (cmd.exe) does not support ANSI stuff ;)
23:27:51 <mmorrow> i would have guessed as much :)
23:27:57 <RayNbow> cygwin programs do however support ANSI
23:28:26 <RayNbow> so: "clear >foo.txt", "cat foo.txt" clears the screen in cmd.exe
23:28:31 <RayNbow> but "type foo.txt" does not
23:29:28 <mmorrow> i think if one does <<, text "\ESC[H\ESC[2J">> to lunabot, it'll clear everyone using a compatible term's screen/whatever
23:29:50 <mmorrow> > text "asdf"
23:29:51 <lambdabot>   asdf
23:30:00 <mmorrow> or to lambdabot for that matter
23:30:20 <RayNbow> (it's most likely that cygwin's write() function does some ANSI interpretation)
23:30:32 <ivanm> I'm trying to add haddock documentation to my code, and I'm going through the haddock docs... but they don't seem to cover items like stability, maintainer, etc.  Where are these documented?
23:30:51 <glguy> mmorrow: I suspect it wouldn't
23:31:19 <mmorrow> ok, i'm gonna try it (sorry to whoever's screen gets cleared if this works)
23:31:30 <glguy> they can ^L
23:31:36 <mmorrow> , text "\ESC[H\ESC[2J"
23:31:37 <lunabot>  [H[2J
23:31:48 <mmorrow> oh, i filter control chars, i forgot
23:32:20 <mmorrow> it'll work in ghci though
23:33:08 <mmorrow> holy crap, i never knew about ^L
23:33:14 <mmorrow> how nice
23:33:59 <mmorrow> > text "\ESC42"
23:34:00 <lambdabot>   42
23:34:15 <mmorrow> so does lb
23:34:22 <mmorrow> foiled
23:34:47 <glguy> if IRC allowed that to work
23:34:55 <glguy> you wouldn't need a bot to cause havoc
23:35:10 <mmorrow> oh, good point. hmm
23:36:26 <Pseudonym> I'm watching the ICFP contest report.
23:36:28 <Pseudonym> You know...
23:36:40 <Pseudonym> 18 person-years of work.
23:36:43 <Pseudonym> In three days.
23:36:58 <Pseudonym> Wouldn't it be interesting if you got that many people involved in different subtasks?
23:37:07 <Pseudonym> _Could_ you write a Haskell compiler in a weekend?
23:37:41 <vegai> Or have a baby in one month by impregnating 9 women
23:38:09 <glguy> or write a Haskell compiler by impregnating 9 women
23:38:12 <glguy> ?
23:38:14 <electronx> i think the ruby people should make ruby in haskell
23:38:28 <vegai> ruby6?
23:38:29 <Pseudonym> That's the question.
23:38:50 <Pseudonym> Assume for a moment that the subtasks were well-defined.
23:38:53 <vegai> Pseudonym: perhaps possible, but the specification task would be huge
23:39:02 <mmorrow> vegai, glguy: i think you may be on to something..
23:39:03 <Pseudonym> OK, here's another thought:
23:39:09 <Pseudonym> Could you _rewrite_ GHC in three days?
23:39:14 <Pseudonym> Keeping the interfaces.
23:39:28 <mmorrow> i think it could be done for sure, with enough people (under 10, more than 1)
23:39:45 <vegai> Pseudonym: coding is just writing text, isn't it? So it depends on your typing speed
23:39:53 <Pseudonym> I don't mean verbatim.
23:40:05 <Pseudonym> You keep the tests and the module interfaces, and write the implementations.
23:40:08 <mmorrow> and say |only targets x86|haskell parser+lexer are already available|
23:40:12 * vegai is taking the sarcastic middle-manager role
23:40:21 <Pseudonym> Sure.
23:40:24 <Pseudonym> I'm just thinking aloud.
23:40:37 <Pseudonym> It'd be a fascinating experiment to try to write something nontrivial in a weekend.
23:42:54 <mmorrow> (and assuming you have a week to plan before the timer starts)
23:44:08 <mmorrow> ((for the compiler))
23:54:57 <glguy>     GADT pattern match in non-rigid context for `Using'
23:54:57 <glguy>       Tell GHC HQ if you'd like this to unify the context
23:55:03 <glguy> anyone know what that means?
23:55:49 <flapz> hi
23:55:54 <flapz> is it possible to fuck someones eye out?
23:56:06 <flapz> http://www.youtube.com/watch?v=YMu2xNBpyQc   at 4:40  , they're holler'n it
23:56:07 <lambdabot> Title: YouTube - Steven Seagal in Out For Justice, Bar Scene!
23:56:14 --- mode: ChanServ set +o glguy
23:56:16 --- mode: glguy set +b *!*n=jerware@*.115.7.239.res-cmts.flt.ptd.net
23:57:10 --- mode: glguy set +b *!*@24.115.7.239.res-cmts.flt.ptd.net
23:57:20 <parodyoflanguage> Pseudonym: It would be like distributing human processing over multiple cores.
23:57:25 --- mode: glguy set -b *!*n=jerware@*.115.7.239.res-cmts.flt.ptd.net
23:57:29 <parodyoflanguage> Programming people.
23:58:18 <Pseudonym> Yes.
23:58:26 <Pseudonym> Obviously there's a certain amount of sequentialisation.
23:58:29 <Pseudonym> e.g. integration testing
