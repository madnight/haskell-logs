00:00:00 <_zenon_> medfly, I don't know if anything involving darwin award could be tupled with Terminator-ish things.
00:00:21 <luqui> being so smart as to remove yourself from the gene pool
00:00:29 <Cale> You create something more fit than you, and die out as a result :)
00:00:33 <_zenon_> terminators are just... too awesome.
00:00:45 <_zenon_> Cale, yeah, like an evolution-award
00:01:04 <Myoma> :t fmap show
00:01:05 <lambdabot> forall a (f :: * -> *). (Functor f, Show a) => f a -> f String
00:01:36 <medfly> i think its similar to the case of a disease so powerful it wipes out a specie. what happens then? it runs out of hosts and dies.
00:01:52 <_zenon_> medfly, well. but terminators don't need hosts.
00:02:16 <_zenon_> they just need a lot of assembly .............. and awesomeness
00:02:18 <Myoma>     Could not deduce (Show (f (Mu f)))
00:02:18 <Myoma>       from the context (Show (Mu f), Show a, Show (f a))
00:02:21 <Myoma> heh .. :(
00:02:41 <Myoma> we obviously need co-lp in the typeclasses..
00:04:20 <dons> ?yow
00:04:20 <lambdabot> Life is a POPULARITY CONTEST!  I'm REFRESHINGLY CANDID!!
00:04:25 <dons> hehe
00:05:40 <dolio> Oh man, yow is fixed!
00:05:54 <inimino> hm
00:06:12 <_zenon_> xmonad is great, just had to say it
00:06:37 <inimino> I'm getting an error trying to compile with -prof, "Perhaps you haven't installed the profiling libraries for package mtl-1.1.0.1?" but I have...
00:06:39 <_zenon_> or is it Xmonad ?
00:07:11 <inimino> how can I find out why this isn't working?
00:07:21 <Beelsebob> @. arr yow
00:07:21 <lambdabot> Keelhaul the swabs!
00:07:27 <Beelsebob> boring
00:07:35 * Beelsebob wishes not so many involved const
00:08:52 <Myoma> I can't write it
00:09:29 <luqui> Myoma, I thought it wasn't possible, but it is
00:09:32 <luqui> pasting
00:09:50 <luqui> unless you prefer to keep trying ;-)
00:10:09 <cjs> Hm. So how I can I make this less awkward? http://hpaste.org/10254
00:10:21 <luqui> http://hpaste.org/10255
00:11:00 <dolio> The problem is that you can't write the constraint you really want.
00:11:04 <mmorrow> hah
00:11:09 <mmorrow> newtype Mu f = Mu { out::f (Mu f) }
00:11:09 <mmorrow> instance Show (Mu f) where show (Mu f) = "Mu => ["++show f
00:11:09 <mmorrow> instance Show (f (Mu f)) where show = show . Mu
00:11:14 <cjs> Basically, if I have, e.g., a field #5 or a field #4 in the refresh, I should return a new Quote using fields 5 and 4 from the refresh, using the one from the snap if the one in the referesh is not available.
00:11:54 <dolio> Which is something like: (forall a. Show a => Show (f a)) => Show (Mu f)
00:12:08 <mmorrow> yeah
00:12:36 <Myoma> luqui: woah!
00:12:44 <Myoma> how did you think to try that ?
00:12:48 <quicksilver> dolio: 07:58 < quicksilver> (forall a. Show a => Show f a) => Show (Mu f) ;P
00:13:52 <luqui> Myoma, haha
00:14:10 <quicksilver> cjs: to be honest I think your code is fine :P
00:14:16 <luqui> Myoma, it _was_ actually a hunch though, I did pay attention to the obvious compiler hint: "Could not deduce (Show (f (Mu f))) from the context (Show (Mu f))"
00:14:17 <dolio> I can't be bothered to read stuff that old. :)
00:14:38 <Myoma> this is great
00:14:42 <Myoma> we should get it in lambdabot?
00:14:46 <cjs> Hm. I hate using "if" statements, thogh.
00:14:53 <cjs> s/thogh/though/
00:14:57 <luqui> it does require undecidableinstances....
00:15:07 <luqui> how do we know inference will terminate?
00:15:07 <quicksilver> cjs: use case? :)
00:15:28 <quicksilver> cjs: or guard
00:15:30 * cjs throws a brick at quicksilver.
00:15:33 <cjs> Ah, guard.
00:15:37 <quicksilver> cjs: guard (p `mplus` q)
00:15:46 <quicksilver> ^^ guarantee at least one is non-Nothing
00:15:56 * luqui never ever uses if anymore.
00:16:02 <luqui> not because I hate it, it just never comes up
00:16:09 <mmorrow> > let showMu0 = showMu . Mu ; showMu (Mu f) = "Mu ("++showMu0 f++")" in showMu . out $ Mu (fix id)
00:16:10 * Myoma would like 'if' removed
00:16:11 <lambdabot>   mueval: Prelude.read: no parse
00:16:17 <mmorrow> @typeMu
00:16:18 <lambdabot> <no location info>: not an expression: `'
00:16:19 <mmorrow> @type Mu
00:16:20 <lambdabot> Not in scope: data constructor `Mu'
00:16:26 <Myoma> @type In
00:16:26 <mmorrow> err
00:16:27 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
00:16:28 <mmorrow> ah
00:16:46 <mmorrow> > let showMu0 = showMu . In ; showMu (In f) = "Mu ("++showMu0 f++")" in showMu . out $ In (fix id)
00:16:47 <lambdabot>   Couldn't match kind `* -> *' against `(* -> *) -> *'
00:17:16 <cjs> Except I need to turn the result of p `mplus` q into a bool.
00:17:55 <cjs> guard $ (p `mplus` q) /= Nothing
00:18:01 <mmorrow> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (In (fix id))
00:18:03 <lambdabot>   "Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu...
00:18:16 <Myoma> Mu!
00:18:26 <luqui> :t let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu
00:18:27 <lambdabot> forall (t :: * -> *). Mu t -> [Char]
00:18:29 <quicksilver> cjs: doh.
00:18:34 <quicksilver> cjs: i'm an idiot.
00:18:36 <luqui> mmorrow, nicely done
00:18:41 <Myoma> :t let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu
00:18:42 <lambdabot> forall (t :: * -> *). Mu t -> [Char]
00:18:47 <cjs> Just what I was thinking. I don't even know why I listen to you. :-)
00:18:59 <mmorrow> it almost looks like cheating done that way
00:19:01 <quicksilver> cjs: you don't need guard.
00:19:02 <Myoma> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (fix (Just . In))
00:19:02 <quicksilver> cjs: http://hpaste.org/10254#a2
00:19:03 <lambdabot>   Couldn't match expected type `Mu' against inferred type `Maybe'
00:19:06 <quicksilver> cjs: guard is the 'right idea'
00:19:09 <Myoma> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (out (fix (Just . In)))
00:19:10 <lambdabot>   Couldn't match expected type `Mu' against inferred type `Maybe'
00:19:11 <mmorrow> but i guess that's what the show is doing
00:19:16 <quicksilver> cjs: but you can just write p `mplus` q
00:19:16 <Myoma> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (out (fix (In . Just)))
00:19:17 <lambdabot>   Couldn't match expected type `Mu t'
00:19:19 <Myoma> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu fix (In . Just))
00:19:20 <lambdabot>   mueval: Prelude.read: no parse
00:19:23 <Myoma> :[
00:19:26 <Myoma> this is not worknig
00:19:34 <mmorrow> @type In . fix
00:19:35 <luqui> :t let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (fromJust $ fix (Just . In))
00:19:36 <lambdabot> forall (f :: * -> *). (f (Mu f) -> f (Mu f)) -> Mu f
00:19:36 <lambdabot> [Char]
00:19:40 <luqui> let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (fromJust $ fix (Just . In))
00:19:41 <quicksilver> cjs: the semantics of the maybe monad will shortcircuit if it's nothing.
00:19:50 <luqui> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (fromJust $ fix (Just . In))
00:19:50 <lambdabot>   mueval: Prelude.read: no parse
00:19:55 <luqui> crap
00:19:58 <mmorrow> @type out . out
00:19:59 <lambdabot>     Couldn't match kind `* -> *' against `(* -> *) -> *'
00:19:59 <lambdabot>     When matching the kinds of `f :: * -> *' and `Mu :: (* -> *) -> *'
00:19:59 <lambdabot>       Expected type: Mu f -> Mu f1
00:20:11 <mmorrow> @type out . In . out
00:20:12 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
00:20:21 <dolio> @type fmap out . out
00:20:22 <lambdabot> forall (f :: * -> *). (Functor f) => Mu f -> f (f (Mu f))
00:20:25 <Myoma> :t ((out . In) . (out . In)) . ((out . In) . (out . In))
00:20:26 <lambdabot> forall (f :: * -> *). f (Mu f) -> f (Mu f)
00:20:46 <mmorrow> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (In (fix (In . out . In . out)))
00:20:47 <lambdabot>   Couldn't match kind `(* -> *) -> *' against `* -> *'
00:20:58 <mmorrow> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (In (fix (In . out . In . out $ id)))
00:20:59 <lambdabot>   Couldn't match expected type `Mu f' against inferred type `a -> a'
00:21:02 <mmorrow> gah
00:21:02 <luqui> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (fix (In . Just)
00:21:03 <lambdabot>   mueval: Prelude.read: no parse
00:21:11 <Myoma> @quote Mu
00:21:11 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
00:21:16 <Myoma> @quote .Mu.
00:21:17 <lambdabot> gmh33 says: Haskell makes so much more sense now and all I did was figure out the typing thing
00:21:18 <luqui> you guys are terrible at term inference :-)
00:21:42 <Myoma> ?djinn f (Mu f) -> String
00:21:43 <lambdabot> Error: Undefined type Mu
00:21:44 <Myoma> :D
00:22:20 <luqui> > "I am still alive"
00:22:21 <lambdabot>   "I am still alive"
00:22:33 <luqui> okay.  I don't know what that no parse business is
00:22:34 <dons> ?users
00:22:34 <lambdabot> Maximum users seen in #haskell: 504, currently: 438 (86.9%), active: 19 (4.3%)
00:23:56 <dolio> "no parse" is apparently mueval failing to parse error messages for your ill-formed code. :)
00:24:18 <Myoma> mueval-- # sucks
00:24:28 <luqui> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (fix (In . Just))
00:24:29 <lambdabot>   "Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu...
00:24:39 <luqui> hey what do you know.
00:24:48 <luqui> and also now I realize showMu is broken :-)
00:24:49 <Myoma> it should be (In (Just (In (Just ...
00:24:57 <Myoma> oops
00:25:00 <Myoma> In (Just (In (Just ...
00:25:02 <Myoma> not lisp
00:25:06 <mmorrow> yeah
00:25:13 <dolio> That just re-wraps before calling itself recursively.
00:25:25 <luqui> it's obvious now that I look with a critical eye
00:25:39 <dolio> > let showMu (In f) = "Mu ("++showMu (In f)++")" in showMu (In Nothing)
00:25:41 <lambdabot>   "Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu (Mu...
00:26:12 <mmorrow> > let showMu (In f) = "Mu ("++show f)++")" in showMu (fix (In . Just))
00:26:13 <lambdabot>   mueval: Prelude.read: no parse
00:26:20 <mmorrow> > let showMu (In f) = "Mu ("++show f++")" in showMu (fix (In . Just))
00:26:21 <lambdabot>       No instance for (Show (Mu Maybe))
00:26:22 <lambdabot>        arising from a use of `showMu'...
00:26:33 <mmorrow> oh
00:26:42 <luqui> mmorrow, see paste http://hpaste.org/10255
00:26:43 <quicksilver> win 20
00:27:16 <luqui> I don't think you can even do it without creating an instance...
00:27:23 <mmorrow> luqui: yeah, i saw. i also have a similar instance i'm trying to shoehorn into one function w/out show
00:27:30 <mmorrow> yeah, that's the killer there
00:28:23 <Myoma> it must be a show instance
00:28:33 <Myoma> because you need the functor to call it
00:28:36 <luqui> you could if there were, eg. showWith :: (ShowWith f) => (a -> String) -> f a -> String
00:28:39 <quicksilver> well, try passing the dictionary explicitly
00:28:52 <quicksilver> that's what the instance would be implemented as.
00:29:09 <quicksilver> :t In
00:29:10 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
00:29:44 <quicksilver> write inAndShow :: (f (Mu f), f (Mu f) -> String) -> (Mu f, Mu f -> String)
00:30:08 <luqui> quicksilver, that's an interesting idea.
00:30:46 <quicksilver> :k Mu
00:30:47 <lambdabot> (* -> *) -> *
00:33:24 <dolio> > let showMaybe s (Just a) = "Just (" ++ s a ++ ")" ; showMaybe s Nothing = "Nothing" ; showMu s (In f) = "In (" ++ s (showMu s) f ++ ")" in showMu showMaybe (fix $ In . Just)
00:33:25 <lambdabot>   "In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (...
00:35:17 <quicksilver> dolio++
00:37:59 <dolio> @karma
00:38:00 <lambdabot> You have a karma of 1
00:38:07 <luqui> what does * usually mean in category theory?
00:38:21 <luqui> I'm looking at the law: f * (g * t) = (f;g) * t
00:38:48 <dolio> What are f, g and t?
00:38:51 <rwbarton> luqui: looks like some kind of action
00:38:51 <cjs> quicksilver: That's great. Thanks!
00:39:16 <luqui> dolio, I don't know.  the paper is leaving it out.
00:39:21 <dolio> Heh.
00:40:00 <dolio> * might be functor application and ; functor composition.
00:40:06 <quicksilver> luqui: that looks like f $ g $ t = f.g $ t
00:40:11 <quicksilver> luqui: in one domain or another ;)
00:40:27 <mmorrow> dolio: sweet
00:40:38 <luqui> quicksilver, oh!  yeah I think * is exponentiation
00:40:49 <rwbarton> Oh, is it f^* g^* t?
00:40:55 <luqui> no, it's infix
00:41:20 <luqui> or no, I'm wrong...
00:41:46 <dolio> Oh.
00:41:59 <dolio> In that case, it means that map f (map g t) = map (f . g) t
00:42:06 <dolio> I suspect.
00:42:31 <luqui> dolio, ah that makes sene
00:47:33 <conal> luqui: i've seen that notation also: f* == fmap f
00:48:22 <dolio> Yeah, and ; is an alternate notation for composition I've seen.
00:48:30 <luqui> I recognized ;
00:48:58 <conal> dolio: me too, though usually for reversed composition: f;g == g . f,  in other words, "f then g"
00:49:18 <dolio> Yeah, I was about to say that. :)
00:49:30 <conal> e.g., in the semantics of sequential imperative language: M [f;g] = M[f] ; M[g]
00:50:13 <conal> where M : Statement -> (State->State)
00:50:25 <conal> Store->Store
00:51:24 <quicksilver> conal: lightstep pointed out that my Future's mappend is slightly non-deterministic.
00:51:33 <quicksilver> conal: and my patch to it reduces the chance, but doesn't fix it.
00:51:50 <quicksilver> conal: I suspect this problem is not unfamiliar to you :)
00:52:06 <quicksilver> conal: since you wrote "The current implementation is nondeterministic in mappend for futures that become knowable at the same time or nearly the same time. I want to make a deterministic implementation"
00:53:26 <conal> quicksilver: yep.  i know about that one. :)
00:54:07 <conal> quicksilver: it was one main motivator for my unamb solution, which lets me have deterministic semantics on top of nondeterministic scheduling.
00:54:55 <scorch_> I have a sorting function that needs to take two arguments of any type that can be sorted; how can I do that?
00:56:28 <Myoma> how can you do what ?
00:57:10 <luqui> :t compare
00:57:11 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
00:57:25 <luqui> scorch_, is that what you mean?
00:58:12 <luqui> quicksilver, there's a locking trick that you can do to make it deterministic
00:58:52 <scorch_> luqui: it takes two string arguments at the moment, but I want it to be able to take e.g. either two strings or two ints
00:58:54 <quicksilver> luqui: if there is, I'd love to here it.
00:59:10 <quicksilver> luqui: take a look at my Future impl and tell me how to add that ;)
00:59:25 <quicksilver> conal: I think I have thought of a solution using STM.
00:59:46 <luqui> quicksilver, Clock in reactive does it, but I have a hard time understanding it.  Clock was a refactor from a more direct implementation earlier, I'll try to find it.
01:00:16 <luqui> at least I think it applies to this situation
01:02:19 <luqui> hmm, how do I go to a previous version in darcs
01:03:18 <cjs> Can I do a partial applciation of tupling?
01:03:34 <BeelsebobWork> cjs: sure ((,) 5)
01:03:47 <luqui> but sadly not (5,) :-(
01:03:53 <BeelsebobWork> (or (flip (,)) 5)
01:04:05 <BeelsebobWork> luqui: indeed :(
01:04:09 <luqui> for the latter I would always use \x -> (5,x)
01:04:17 <conal> quicksilver: a few others have tried STM also, including myself, and weren't able to get it to cooperate with caching.  (e.g., fmap on future.)  if it works out for you, please let me know.
01:04:51 <BeelsebobWork> luqui: yes, I agree that's clearer
01:05:02 <BeelsebobWork> actually no luqui
01:05:08 <BeelsebobWork> that's ((,) 5)
01:05:12 <luqui> er, right
01:05:13 <BeelsebobWork> you meant \x -> (x,5)
01:06:38 <_zenon_> Hm... I'll abandon WriterT with Reader for now. Firstly I'll do a simple combination and then I'll wrap it up "properly"
01:07:02 <quicksilver> conal: I think I'm more concerned at the moment with correctness than caching :)
01:07:31 <conal> quicksilver: sure.
01:07:31 <quicksilver> conal: I think I can imagine another implementation which uses a master-thread to do explicit serialisation but that doesn't sound performant.
01:08:53 <quicksilver> conal: still it might be good to have the implementation available for comparison.
01:09:20 <conal> quicksilver: definitely.  and use reactive's test suite.
01:09:42 <quicksilver> _zenon_: what problem are you having with WriterT Reader ?
01:09:52 <quicksilver> _zenon_: it's probably very simple to fix.
01:10:16 <quicksilver> conal: I might try to grab one of the GHC RTS experts and see if they have any insights into the best way to make it perform.
01:10:37 <quicksilver> conal: are you sure your unamb has the right determinism property?
01:10:48 <luqui> quicksilver, however, lack of caching means asymptotic increases in programs.  I consider a program which should run in linear time which runs in quadratic time incorrect...
01:10:51 <_zenon_> quicksilver, mostly just me being dumb
01:11:05 <_zenon_> quicksilver, I'll just have to let it mature a bit,
01:12:02 <_zenon_> I'm really just using Reader for the [] part, which I can bake directly in Writer [String] [Propos] instead
01:12:04 <conal> quicksilver: when the precondition is satisfied.  pretty sure.
01:12:25 <quicksilver> luqui: Well, all I mean is I want to consider all the options which are definitely correct, and then see if it's possible to add caching to them.
01:12:41 <_zenon_> quicksilver, but thanks anyway
01:13:08 <quicksilver> luqui: I appreciate I'm going over old ground here, but I don't know how to understand it myself without retracing the route ;)
01:13:17 <conal> quicksilver: one problem with STM was that retry undid the writes (cachings), even though the correctness of writes didn't depend on choices made.
01:13:31 <conal> quicksilver: and by all means, give it a go.
01:14:26 <conal> i haven't been very good at documenting things that don't work, and why.
01:15:33 <Feuerbach> I have strange problem with exceptions (from Control.Exception). I use handleErrors from cgi package which is implemented using 'try'. When I invoke 'handleErrors undefined' it catches exception and prints error page. But when the same exception is rised deeply in the program, it isn't caught and is dumped to error.log
01:15:47 <Feuerbach> how can it be?
01:16:24 <quicksilver> conal: That doesn't sound like a terrible drawback, under the assumption that retries are rare.
01:16:56 <quicksilver> conal: but I don't know what work-patters would make retries rare or common :-/
01:19:08 <sjanssen> Feuerbach: sounds like you're hitting the difference between undefined and return undefined
01:19:22 <sjanssen> > undefined `seq` ()
01:19:23 <lambdabot>   mueval: Prelude.read: no parse
01:19:23 <lambdabot>  mueval: *** Exception: Prelude.undefined
01:19:35 <sjanssen> > (return undefined :: IO ()) `seq` ()
01:19:36 <lambdabot>   ()
01:19:47 <luqui> quicksilver, okay, this is quite different from what you will need to do because of your repr, but I think the basic idea still applies: http://hpaste.org/10256
01:20:01 <luqui> in particular makeFutureTrigger
01:20:08 <quicksilver> Feuerbach: don't throw exceptions from pure code
01:20:17 <quicksilver> Feuerbach: follow that guideline and you'll be fine ;)
01:21:21 <Feuerbach> quicksilver: but it's so comfortable... So, should I use Error monad instead?
01:21:50 <luqui> Feuerbach, for the time being.  soon you'll start writing total functions that can't possibly throw errors
01:22:10 <luqui> but it takes a brain shift to think of the right functions to write...
01:22:10 <osfameron> just don't mention head or tail...
01:22:13 <quicksilver> Feuerbach: yes.
01:22:21 <Feuerbach> luqui: there's always possibility of malformed input
01:22:28 <luqui> Feuerbach, nope.
01:22:35 <quicksilver> Feuerbach: you should "something like" the error monad. Just explicit use of Maybe or Either is enough for enough cases.
01:22:49 <quicksilver> Feuerbach: they are in fact 'just like' exceptions if you use them correctly.
01:22:51 <mapreduce> What's the error monad?
01:22:54 <quicksilver> but they're safe to use in pure code.
01:23:12 <luqui> Feuerbach, for example, if you design a type to capture exactly what the input should be, so that bad input is not representable, then you can't have malformed input
01:23:21 <quicksilver> mapreduce: the error monad is 'Either ErrorCode a'
01:23:23 <cjs> Hm. Is there something in the List monad that will let me return multiple values?
01:23:32 <mapreduce> > head []
01:23:33 <lambdabot>   mueval: Prelude.read: no parse
01:23:33 <lambdabot>  mueval: *** Exception: Prelude.head: empty ...
01:23:33 <quicksilver> cjs: [1,2,3]
01:23:42 <mapreduce> Lists hold multiple values.
01:23:48 <Myoma> cjs, tuples ..?
01:23:53 <luqui> Feuerbach, it isn't always possible to do that, of course, but it's possible more often than you think.
01:24:00 <BeelsebobWork> quicksilver: you made an interesting statement there -- "don't throw exceptions from pure code"
01:24:00 <cjs> > (return 13) :: [Int]
01:24:01 <lambdabot>   [13]
01:24:12 <BeelsebobWork> surely this implies that there's non-pure code in Haskell
01:24:14 <cjs> Right? But what if I want to come out with [13, 14]?
01:24:16 <Feuerbach> sjanssen: where can I learn more about that difference?
01:24:24 <Myoma> > (return 13 `mplus` return 14) :: [Int]
01:24:25 <lambdabot>   [13,14]
01:24:29 <cjs> Doh!
01:24:30 <luqui> BeelsebobWork, I think he means "don't use error"
01:24:42 <Myoma> cjs, think of mplus as logical dysjunction
01:24:47 <quicksilver> BeelsebobWork: I'm speaking sloppily.
01:24:50 <BeelsebobWork> luqui: yeh, I know -- just slightly getting back to the "is haskell a pure language" discussion
01:24:53 <Myoma> >>= as conjunction
01:24:57 <luqui> please don't...
01:25:00 <quicksilver> BeelsebobWork: in a way inconsistent with the view I took yesterday.
01:25:00 <BeelsebobWork> hehe
01:25:00 <BeelsebobWork> :P
01:25:07 <BeelsebobWork> quicksilver: okies
01:25:08 <cjs> Right. So, if I've got a list, I just fold it with mplus and I'm set. Cool.
01:25:15 <Myoma> cjs: msum
01:25:20 <quicksilver> cjs: No.
01:25:20 <luqui> (not that I didn't enjoy that flame war.  I felt flaming yesterday)
01:25:23 <quicksilver> cjs: you just use it.
01:25:29 <quicksilver> cjs: no need to fold it with mplus.
01:25:32 <quicksilver> cjs: just use the list itself.
01:25:33 <BeelsebobWork> luqui: I'm not sure that it need be a flame war
01:25:36 <BeelsebobWork> nor that it was yesterday
01:25:46 <BeelsebobWork> I mostly enjoyed yesterday's discussion because it wasn't on fire
01:25:53 <quicksilver> cjs: foldr mplus . map return $ [1,2,3] is just a daft way to say '[1,2,3]'
01:26:00 <sjanssen> Feuerbach: hmm, I don't know any good resource off the top of my head
01:26:13 <sjanssen> Feuerbach: but perhaps you can use Control.Exception.evaluate to your advantage?
01:26:33 <cjs> Right, but when I'm in do block, with a list in hand....
01:26:53 <quicksilver> cjs: just do it.
01:26:57 <quicksilver> do [1,2,3]
01:27:04 <cjs> Maybe this is a bit weird, but I'm actually using the list monad as sort of an error-handling thing; if anything goes wrong, the computation is aborted and the empty list comes out.
01:27:04 <luqui> quicksilver, uh, that doesn't typecheck
01:27:20 <quicksilver> > do [1,2,3]
01:27:21 <lambdabot>   [1,2,3]
01:27:23 <cjs> Oh, it does!
01:27:23 <quicksilver> luqui: ?
01:27:29 <luqui> quicksilver, no, I mean foldr mplus ...
01:27:37 <luqui> >  foldr mplus . map return $ [1,2,3]
01:27:38 <lambdabot>       Overlapping instances for Show ([[m a]] -> [m a])
01:27:38 <lambdabot>        arising from a...
01:27:44 <luqui> oh wait, I'm silly
01:27:57 <quicksilver> yeah, I mised a parameter ;)
01:28:02 <quicksilver> but I think the point I was trying to make was clear.
01:28:12 <quicksilver> cjs: the list monad is called the list monad because values are lists.
01:28:18 <quicksilver> cjs: you are allowed to "just use a list" if you want ;)
01:28:28 <cjs> Makes sense.
01:28:43 <luqui> quicksilver, oh okay.  man that was confusing... I thought you were in maybe.
01:28:44 <cjs> I was sort of thinking that originally, but somehow I couldn't wrap my brain around it.
01:28:45 <BeelsebobWork> cjs: note that return == :[] in the list monad
01:28:48 <quicksilver> cjs: there is nothing wrong about using the list monad as a sort-of-error-handling thing.
01:28:49 <Feuerbach> sjanssen: like evaluate $ handleErrors $ ... ?
01:28:54 <BeelsebobWork> so you are in fact always just using a list
01:28:55 <quicksilver> it's sort-of-error-handling like Maybe is.
01:29:07 <sjanssen> Feuerbach: not quite
01:29:10 <quicksilver> but it also adds multiple-return values into the mix
01:29:42 <sjanssen> Feuerbach: handleErrors $ evaluate -- is probably what you want (nb, I don't know the type of handleErrors)
01:31:01 <RayNbow> > [1,2,3] >> fail "Aborting computation"
01:31:03 <Feuerbach> ok, I'm going be a good boy and use pure code :)
01:31:05 <lambdabot>   []
01:31:39 <BeelsebobWork> > [1,2,3] >>= fail
01:31:40 <RayNbow> > [1,2,3] >> [] -- this is shorter though and doesn't rely on fail :p
01:31:40 <lambdabot>       No instance for (Num String)
01:31:40 <lambdabot>        arising from the literal `1' at <in...
01:31:41 <lambdabot>   []
01:32:08 <BeelsebobWork> RayNbow: why do you care about relying on fail -- you know that fail is defined for lists
01:32:41 <quicksilver> well 'mzero' is argubaly a better choice
01:32:49 <quicksilver> just because you know that the messasge to fail will be ignored
01:32:51 <quicksilver> in this case
01:32:58 <quicksilver> so putting a message there is perhaps confusing?
01:33:22 <BeelsebobWork> quicksilver: this is true
01:33:47 <BeelsebobWork> having said that, for a different reason I like RayNbow's one
01:33:55 <BeelsebobWork> we know this is lists -- so lets be explicit about the values
01:33:58 <BeelsebobWork> for the sake of code clarity
01:34:32 <BeelsebobWork> > [1,2,3] >>= fail or >> mzero requires you to think about what fail or mzero do in that particular instance
01:34:34 <lambdabot>   mueval: Prelude.read: no parse
01:34:43 <BeelsebobWork> they even require you to think what the returned monad type is
01:35:11 <ToRA> BeelsebobWork: the contra to that argument is that if you decide later you don't want to use lists, but something that is list-like, you now have to update 2 little bits of code
01:35:24 <BeelsebobWork> ToRA: this is true, yes
01:35:35 <BeelsebobWork> but we already have to update that code, because we already have an explicit list there
01:35:49 <ToRA> sure, but you only have to change the seed
01:35:58 <BeelsebobWork> yep
01:36:15 <quicksilver> you can take that argument too far.
01:36:21 <quicksilver> would you specialise mapM to a particular monad?
01:36:28 <quicksilver> and use that definition instead of the generic one?
01:36:44 <ToRA> > [1,2,3] `concatMap` []
01:36:45 <lambdabot>   Couldn't match expected type `a -> [b]'
01:36:46 <BeelsebobWork> quicksilver: I'm not sure I use mapM for any monad other than IO, so I don't know yet
01:36:52 <ToRA> bah
01:37:08 <BeelsebobWork> ToRA: that's join, not bind
01:37:14 <ToRA> ;)
01:37:16 <ToRA> you get the point
01:37:28 <BeelsebobWork> :P
01:37:36 <quicksilver> BeelsebobWork: *boggle*
01:37:52 <luqui> > [1,2,3] `concatMap` const []
01:37:53 <lambdabot>   Couldn't match expected type `a -> [b]'
01:37:54 <quicksilver> mapM is very useful in most monads IME :)
01:37:58 <BeelsebobWork> quicksilver: every other monad I use is also a functor -- so I tend to use fmap
01:38:02 <luqui> oh it's flipped
01:38:12 <quicksilver> BeelsebobWork: mapM != fmap.
01:38:14 <luqui> to the direction it should be
01:38:18 <BeelsebobWork> quicksilver: no, but very close
01:38:32 <BeelsebobWork> and can be used for the same tasks
01:38:45 <quicksilver> no, in no way.
01:38:51 <quicksilver> mapM takes a list of actions
01:38:56 <quicksilver> and collects all their effects
01:39:04 <quicksilver> fmap takes one action, and composes it with a pure funciton.
01:39:11 <BeelsebobWork> yep
01:39:16 <BeelsebobWork> hence I prefer fmap
01:39:21 <BeelsebobWork> because I tend to use actions less
01:39:21 <luqui> there's nothing to prefer
01:39:23 <quicksilver> but they're quite incomporable!
01:39:27 <quicksilver> mapM is about multiple actions
01:39:31 <quicksilver> fmap is about only one
01:39:43 <quicksilver> this is like saying "I don't like Either, I always use tuples"
01:39:46 <BeelsebobWork> sec, just off to talk to my boss
01:39:49 <quicksilver> ;)
01:40:32 <luqui> Either a b = (Bool,a,b); Left x = (False,x,undefined); Right x = (True,undefined,x)
01:40:52 <luqui> that's a good encoding if I've ever seen one.
01:41:04 <luqui> because I'm a C programmer!
01:41:10 <haskellian> is there null? in haskell?
01:41:17 <haskellian> lol [] yes
01:41:24 <quicksilver> haskellian: in many cases, Maybe is what you want.
01:41:33 <quicksilver> (with Nothing taking the role of null)
01:41:40 * RayNbow wonders in the mean time why uninstalling VS2k5 takes so much time (and so many manual steps :X)
01:41:41 <luqui> haskellian, also, undefined is a type of null.  but you can't check for it.
01:41:46 <quicksilver> in some other cases it could be []
01:41:54 <haskellian> length xs <= 1  = xs
01:42:12 <haskellian> i shoudl pattern match against [x] right?
01:42:12 <mmorrow> > (sequence .) . fmap $ replicate 4 (Just 42)
01:42:13 <lambdabot>   Couldn't match expected type `a1 -> m a'
01:42:21 <mmorrow> > (sequence .) . fmap show $ replicate 4 (Just 42)
01:42:22 <lambdabot>   Couldn't match expected type `m a' against inferred type `Char'
01:42:32 <mmorrow> > (sequence .) . fmap (return . show) $ replicate 4 (Just 42)
01:42:33 <lambdabot>   Couldn't match expected type `(->) a' against inferred type `[]'
01:42:40 <mmorrow> death
01:42:46 <luqui> haskellian, length xs <= 1 = xs doesn't mean anything to me.  what are you asking?
01:43:19 <mmorrow> > (sequence .) . fmap $ (return . show) $ replicate 4 (Just 42)
01:43:20 <lambdabot>       Overlapping instances for Show ([a] -> [[Char]])
01:43:20 <lambdabot>        arising from a ...
01:43:31 <quicksilver> luqui: I don't have time to entirely grok your legacy adapters code but I'm saving it for future perusal ;)
01:44:01 <luqui> quicksilver, yeah, there's some tricky stuff going on...  took quite a long time to get right
01:44:22 <mmorrow> > (\f -> sequence . fmap (f `fmap`)) show (replicate 4 (Just 42))
01:44:24 <lambdabot>   Just ["42","42","42","42"]
01:44:50 <mmorrow> @pl \f -> sequence . fmap (f `fmap`)
01:44:50 <lambdabot> (sequence .) . fmap . fmap
01:45:23 <mmorrow> @src mapM
01:45:23 <lambdabot> mapM f as = sequence (map f as)
01:45:41 <luqui> haskellian, oh! do you mean foo xs | length xs <= 1 = xs
01:46:11 <luqui> haskellian, if so, then yes, foo [] = []; foo [x] = [x]  would be a better way to write that
01:46:17 <haskellian> http://hpaste.org/10257
01:46:26 <haskellian> oh [x] on toher side
01:46:42 <haskellian> duh
01:47:19 <Myoma> :t null
01:47:20 <lambdabot> forall a. [a] -> Bool
01:47:30 <Myoma> [] is nil
01:47:54 <haskellian> haskell is really starting to seduce me
01:47:55 <ketil> is there a fast way to convert a ByteString to a ByteString containing the decimal representations of it?
01:47:58 <haskellian> it is so expressive
01:48:04 <luqui> yay!
01:48:05 <ketil> Current code is:  B.pack . unwords . map show . BB.unpack
01:48:07 <_zenon_> haskellian, indeed.
01:48:12 <haskellian> more than lisp
01:48:13 <ketil> but it is very slow.
01:48:14 <haskellian> and python
01:48:23 <luqui> ketil, more than lisp?
01:48:35 <Myoma> ketil, haskell is slow??
01:48:40 <ketil> I think he meant 'impressive'
01:48:43 <sjanssen> ketil: I can't think of a faster way
01:48:44 * _zenon_ should really take a look at zippers
01:48:50 <haskellian> ktil: it hought slow too but then i was shown how i was doing things wrong
01:49:03 <haskellian> i think it takes more knowledge to write good efficient haskellcode
01:49:03 <luqui> well, most of the time, languages aren't slow, programs are
01:49:06 <ketil> the code example I posted is slow.
01:49:11 <sjanssen> (unless you're using lazy ByteString, then it is advantageous to pack first)
01:49:16 <luqui> but haskellian, yes, that is approximately correct
01:49:16 <ketil> Haskell is as Haskell does, in general.
01:49:24 <haskellian> but you get it back in terms of low bugcounts, elegance, readability retc
01:49:34 <ketil> sjanssen, I am.  And I'll try.
01:49:46 <luqui> haskellian, and incomprehensible memory leaks!
01:49:50 <ketil> B.unwords . map (B.pack . show) ?
01:49:51 <sjanssen> ketil: you can also use a bit of memoization to speed things up
01:50:02 <haskellian> luqui: hehe
01:50:04 <ketil> sjanssen, yes, a lookup table.
01:50:23 <ketil> BRB.
01:50:25 <luqui> lazy programming subtle, I think it comes down to that
01:50:26 <ketil> And thanks.
01:50:41 <mmorrow> @free a -> m a
01:50:41 <lambdabot> Extra stuff at end of line
01:50:45 <mmorrow> @free id
01:50:46 <lambdabot> f . id = id . f
01:50:52 <mmorrow> @free sequence
01:50:53 <lambdabot> Expected variable or '.'
01:50:57 <mmorrow> @free join
01:50:58 <lambdabot> Expected variable or '.'
01:51:14 <Myoma> @free fix
01:51:15 <lambdabot> f . g = h . f => f (fix g) = fix h
01:51:15 <luqui> mmorrow, I don't think it can do typeclasses
01:51:19 <mmorrow> ahh
01:51:19 <Myoma> ^ my fav. free theorem :p
01:51:31 <luqui> Myoma, I can't understand that one
01:51:43 <quicksilver> ketil: the bytestring part of that might fuse together.
01:51:50 <quicksilver> ketil: it might just be 'show' that's being slow.
01:51:59 <Myoma> luqui: I can show you an example of using it if you like
01:52:04 <luqui> Myoma, sure!
01:52:27 <luqui> oh I think I see it actually
01:52:31 <Myoma> concat . ((:) x) = ((++) x) . concat
01:52:37 <mmorrow> @djinn m (n a) -> n (m a)
01:52:37 <lambdabot> -- f cannot be realized.
01:52:48 <Myoma> so, concat (fix ((:) x)) = fix ((++) x)
01:52:54 <mmorrow> does djinn do tyclasses?
01:53:04 <mmorrow> @djinn (Monad m, Monad n) => m (n a) -> n (m a)
01:53:04 <lambdabot> Error: Class not found: Monad
01:53:06 <luqui> fix (f . g) = f (g (f (g ...  = f (fix (g . f))
01:53:15 <ketil> quicksilver, right, I'm testing now.  Results in a minute...
01:53:20 <luqui> wow, that's amazing.  and it all comes from the type signature.
01:53:27 <Myoma> free theorems is pretty amazing
01:53:31 <Myoma> I don't really get it ....
01:53:52 <luqui> it is just interpreting "natural transformation" for you isn't it?
01:54:01 <luqui> not that I totally grok natural transformation either...
01:54:03 <quicksilver> ketil: are you compiling with -O2 ?
01:54:09 <RayNbow> @free (,)
01:54:09 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
01:54:21 <ketil> quicksilver, yes.
01:54:24 <Myoma> @let pair = (,)
01:54:26 <lambdabot>  Defined.
01:54:26 <Myoma> @free pair
01:54:28 <lambdabot> $map_Pair f g . pair x = pair (f x) . g
01:54:40 <Myoma> map_Pair ??
01:54:49 <luqui> (***)
01:55:01 <ketil> if I make a 'show' that traverses a table by pattern match, will ghc do a linear scan of the table?  So I should put expected frequent values early?
01:55:32 <luqui> ketil, a table?
01:55:40 <luqui> you mean [(a,b)]?
01:55:57 <quicksilver> no, he means f Foo = x; f Bar = y; f Baz = z
01:56:06 <quicksilver> I don't know the answer, though.
01:56:08 <luqui> ketil, it's not necessarily linear
01:56:20 <luqui> if they're all constructor matches, then it's a nice jump table
01:56:27 <luqui> if there are guards, then yes, it will be linear
01:57:30 <ketil> I'll just do a lookup in an array instead, shorter code.
01:58:01 <ketil> show = showtable ! ; showtable = [ B.pack (show i) | i <- [0..255]]
01:58:11 <mmorrow> whoa, free does locally defined functions..
01:58:57 <quicksilver> ketil: you mean 'listArray' or something.
01:59:01 <quicksilver> ketil: but I get the idea ;)
02:00:57 <ketil> listArray, yes.
02:00:59 <mmorrow> @let let cofix f a = f (`id` cofix f a) a
02:00:59 <lambdabot>   Parse error
02:01:08 <mmorrow> @type cofix
02:01:09 <lambdabot> Not in scope: `cofix'
02:01:15 <mmorrow> @let cofix f a = f (`id` cofix f a) a
02:01:16 <lambdabot>  Defined.
02:01:20 <mmorrow> @free cofix
02:01:21 <lambdabot> (forall q f1. (forall f2 f3. g . f2 = f3 . f                             =>                              g (q f2) = f1 f3)              =>               f . k q = p f1 . h) => f . cofix k = cofix p .
02:01:21 <lambdabot>  h
02:01:29 <mmorrow> holy crap
02:01:33 <ketil> hopefully, ghc will take the trouble of generating all the ByteStrings in advance...
02:02:20 <sjanssen> ketil: just make the array top level and GHC will hold on to it
02:02:23 <Myoma> :t cofix
02:02:24 <lambdabot> forall t1 t2 t. (((t1 -> t2) -> t2) -> t -> t1) -> t -> t1
02:02:27 <mmorrow> @let cofix_pretty = cofix :: (((a -> b) -> b) -> c -> a) -> c -> a
02:02:28 <lambdabot>  Defined.
02:02:31 <RayNbow> @free map
02:02:32 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
02:02:33 <mmorrow> @free cofix_pretty
02:02:34 <ketil> Hm. maybe it can't, since it's boxed?
02:02:35 <lambdabot> (forall q f1. (forall f2 f3. g . f2 = f3 . f                             =>                              g (q f2) = f1 f3)              =>               f . k q = p f1 . h) => f . cofix_pretty k =
02:02:35 <lambdabot> cofix_pretty p . h
02:02:36 <sjanssen> ketil: and what is the advantage to generating all strings in advance?
02:02:43 <mmorrow> ugh, that didn't help
02:02:46 <RayNbow> btw, how does @free work?
02:02:58 <ketil> sjanssen, that the compiler will do it, rather than the run time...
02:03:03 <mmorrow> it looks like the type sigs
02:03:08 <sjanssen> ketil: no, GHC won't do that
02:03:27 <sjanssen> ketil: but that really shouldn't cause you any problems
02:03:33 <mmorrow> RayNbow: meant to say "it looks like it's deriving that from the type sigs"
02:03:42 <quicksilver> ketil: GHC doesn't do any significant amount of compile-time computation, but that makes no asymptotic difference to your problem.
02:03:54 <RayNbow> @free flip
02:03:55 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
02:03:57 <mmorrow> @type cofix fmap
02:03:58 <lambdabot> forall t2 (f :: * -> *). (Functor f) => f (f t2 -> t2) -> f t2
02:05:26 <luqui> @src ((->) a) mfix
02:05:27 <lambdabot> Source not found. I feel much better now.
02:05:48 <luqui> :t mfix :: (((a -> b) -> b) -> c -> a) -> c -> a
02:05:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a -> b) -> b
02:05:53 <luqui> nope..
02:06:01 <mmorrow> > cofix fmap [(!!5),const 3,\x ->(x!!1)+(x!!1),(*2).(!!2),length,const 17]
02:06:02 <lambdabot>   [17,3,6,12,6,17]
02:06:02 <luqui> what is cofix.
02:06:19 <luqui> mmorrow
02:06:21 <kaol> @src cofix
02:06:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:06:24 <luqui> 's example explains it well
02:06:31 <luqui> the source didn't tell me anything
02:06:31 <mmorrow> a slight generalization from a func called "loeb" on the wiki. edwark calls it cofix
02:06:37 <mmorrow> *edwardk
02:06:54 <mmorrow> but he and loeb use the already-applied-to-fmap version
02:07:45 <mmorrow> i don't know if it qualified as be "cofix", but i haven't a clue what else to call it :)
02:07:50 <mmorrow> *qualifies
02:08:00 <mmorrow> err, you know what i meant
02:08:56 <luqui> looks a lot like the dual of mfix for comonads
02:09:27 <luqui> not quite the same though
02:16:16 <scorch_> I'm getting "Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `merge'" when I try to compile this: http://hpaste.org/10258
02:17:18 <haskellian> http://hpaste.org/10259 arent those equal? the second one is much clearer. why would you use the first one?
02:17:53 <dolio> Who's using the first one?
02:17:53 <RayNbow> \p -> \ xs ->
02:17:59 <RayNbow> ah crap...
02:18:11 <haskellian> i found the example
02:18:12 <RayNbow> \p -> \ xs -> someExpr   ==   \p xs -> someExpr
02:18:20 <haskellian> seems very unidiomatic? is hard to read..
02:18:34 <dolio> Someone who really likes scheme might use the first. :)
02:18:50 <sjanssen> haskellian: you'd never use the first?
02:18:59 <sjanssen> haskellian: I'm curious where you found it
02:19:03 <dolio> They're actually not identical, since the first one could potentially fall afoul of the monomorphism restriction.
02:19:15 <dolio> Although, not in this case.
02:20:27 <luqui> scorch_, c++a  -->  c++[a]
02:20:49 <luqui> scorch_, if you write this without the tail recursion "optimization", it will be much more efficient
02:21:55 <quicksilver> scorch_: in your testing code I thnk you mean [1,3,2] not [132] as well ;)
02:22:02 <sjanssen> scorch_: yes, you've managed to make merge O((n+m)^2)
02:23:07 <mmorrow> here's that @free for cofix cleaned up:
02:23:09 <mmorrow> (forall q f1. (forall f2 f3. g . f2 = f3 . f => g (q f2) = f1 f3) => f . k q = p f1 . h) => f . cofix k = cofix p . h
02:23:21 * luqui wonders what Data.Ord is...
02:23:44 <luqui> @yow that is still quite impenetrable, mmorrow
02:23:45 <lambdabot> We just joined the civil hair patrol!
02:24:26 <luqui> but I cannot understand most free theorems.
02:24:26 <mmorrow> luqui: heh, yeah. i was hoping i could tidy it with hstidy (==haskell-src-exts), but unfortunately it's not parseable
02:24:46 <luqui> of course not.  it has => and = ...
02:24:55 <mmorrow> yeah
02:25:07 <mmorrow> ghc lets you use forall as a var name though
02:25:14 <mmorrow> haskell src exts can't handle that
02:25:15 <luqui> heh
02:25:39 <scorch_> quicksilver: I actually meant [132] there :P
02:25:43 <mmorrow> hmm, maybe a minor sedding will do something
02:25:58 <scorch_> luqui: thanks, works fine. :)
02:26:15 <scorch_> sjanssen: hush, not so important
02:28:31 <quicksilver> scorch_: well the point is your version is more complex looking as well as slower
02:28:46 <quicksilver> scorch_: the more natural implementation of merge is simpler to read and runs better.
02:29:07 <scorch_> the more natural?
02:30:31 <quicksilver> scorch_: yes, direct defitnion instead of using res
02:30:43 <luqui> scorch_, i.e. one that looks like this:  merge (x:xs) (y:ys) = ... : ...
02:31:04 <luqui> (more or less)
02:31:17 <quicksilver> scorch_: merge (x:xs) (y:ys) = if x<y then x : merge xs (y:ys) else ...
02:32:00 <scorch_> oh
02:32:38 <_zenon_> @yow
02:32:38 <lambdabot> Don't worry, nobody really LISTENS to lectures in MOSCOW, either! ...
02:32:38 <lambdabot> FRENCH, HISTORY, ADVANCED CALCULUS, COMPUTER PROGRAMMING, BLACK
02:32:38 <lambdabot> STUDIES, SOCIOBIOLOGY! ...  Are there any QUESTIONS??
02:35:27 <mmorrow> luqui: a minor improvement, http://hpaste.org/10260
02:36:27 <luqui> mmorrow, it's not so much the formatting that I'm perplexed by... :-)
02:36:48 <gio123> 9980001
02:36:48 <gio123> <gio123> is resolution calculus complete for first order logic?
02:37:24 <mmorrow> luqui: tis true
02:39:08 <scorch_> http://hpaste.org/10261 <-- heh, a bit better. Thanks. :P
02:39:17 <Myoma> @free unsafePerformIO
02:39:18 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `unsafePerformIO'\n\n"
02:39:22 <Myoma> awwwwwwwwwwwww
02:39:24 <Myoma> :(
02:40:14 <Myoma> @free (>>=)
02:40:14 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
02:40:16 <quicksilver> scorch_: yup :)
02:40:18 <Myoma> @free fmap
02:40:20 <lambdabot> Expected variable or '.'
02:40:28 <Myoma> this is utterly broken
02:40:42 <quicksilver> scorch_: as a bonus that version works on infinite lists...
02:42:35 <scorch_> the otherone would crach when the memory gets filled?
02:42:38 <scorch_> crash*
02:42:54 <Myoma> @free reverse
02:42:55 <lambdabot> $map f . reverse = reverse . $map f
02:42:56 <Myoma> @free length
02:42:57 <lambdabot> length = length . $map f
02:43:27 <luqui> "working on infinite lists" and "efficient" are very commonly the same thing in haskell (for list functions)
02:43:53 <scorch_> what's a good reading resource to learn about type classes and instances?
02:46:24 <luqui> http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
02:46:29 <lambdabot> Title: Wadler: Type classes
02:46:37 <luqui> in particular the last paper, "how to make ad-hoc polymorphism less ad-hoc"
02:47:22 <luqui> scorch_, there is also http://www.haskell.org/tutorial/classes.html, I don't know how good that is
02:47:24 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
02:48:06 <luqui> scorch_, and as always, the literature can be tough going.  hang out in here and ask tons of questions to help yourself learn.  we don't mind :-)
02:48:27 <dcoutts> jeffz: with the latest cabal-install you can cabal install foo --enable-documentation and you can set that as default in the ~/.cabal/config
02:48:55 <yitz> luqui: the famous saying is that "A Gentle Introduction to Haskell" is neither gentle nor an introduction.
02:49:47 <luqui> I hated it when I was learning
02:50:06 <luqui> (because I'm not learning anymore, riight...)
02:51:06 <Wild_Cat> RWH looks like a better introduction. That, and a monad paper or two.
02:51:22 <scorch_> luqui: okey, thanks :)
02:51:23 <Wild_Cat> ("you could have invented monads" is one I like)
02:51:40 <yitz> luqui: I found it an interesting challange.
02:52:30 <luqui> Wild_Cat, "you could have invented monads" is not a typeclass tutorial...
02:52:32 <yitz> luqui: I learned Haskell from the Gentle Intro and the Report - that's all there was then if you weren't near a dead tree library
02:53:01 <luqui> I learned haskell from pugs.  a different kind of interesting challenge.
02:53:08 <MarcWeber> Can someone help me with this? http://hpaste.org/10263
02:53:09 <yitz> luqui: he
02:53:17 <dolio> I think I learned from the gentle intro. It's kind of hard to remember, though.
02:53:20 <Wild_Cat> luqui: My bad, I didn't see it was the topic of the discussion. I thought we were in the context of a plain old intro to Haskell itself.
02:53:55 <MarcWeber> Basically I'd like to have an instance   f :: a -> b   f = fa . fb where I need to add some constraints about the intermediate type to the class.
02:54:58 <Wild_Cat> while we're on the topic of types and classes, what does "forall" mean in a function signature context?
02:55:14 <MarcWeber> The point is that the type var estc should be determined by the result of endElT (class EndElT)
02:55:44 <quicksilver> Wild_Cat: you know the function map?
02:55:50 <quicksilver> :t map
02:55:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:55:59 <quicksilver> Wild_Cat: 'forall' means that type works for all types a and b
02:56:30 <quicksilver> in Haskell98 forall is not valid syntax. It is always assumed. All type variables are 'foralled' at the top level, but you never write it.
02:56:33 <Wild_Cat> right. What's the difference with simply "(a -> b) -> [a] -> [b]"?
02:56:39 <quicksilver> no difference.
02:56:52 <quicksilver> It's a GHC extension to permit you to use the word forall explicitly.
02:57:12 <Wild_Cat> quicksilver: okay, what's the use if everything is foralled at top level?
02:57:20 <quicksilver> two things
02:57:34 <quicksilver> (1) it allows us to express types where everything is *not* foralled at the top level
02:57:34 <MarcWeber> Wild_Cat: Try reading the ghc manual 8.7.4 (arbitrary rank-polymorphism) Not sure wether I've understood it by myself. But it says for rank-1 types the forall is added automatically for you
02:57:52 <quicksilver> (2) as a peculiar edge-case, GHC uses forall as a cue to introduce a type-scope
02:57:58 <quicksilver> if you have scoped type variables turned on.
02:58:31 <yitz> quicksilver: By (1) you mean things that are foralled *not* at the top level, right?
02:59:21 <quicksilver> yitz: yes.
02:59:30 <sjanssen> to be more precise, type variables can be scoped within a function type constructor
03:00:00 <Wild_Cat> quicksilver: do you have a quick example of (1), or should I just not bother?
03:00:31 <quicksilver> Wild_Cat: it's useful but there aren't that many simple uses.
03:00:39 <quicksilver> Wild_Cat: consider this, though:
03:00:59 <quicksilver> (\s -> (s 1, s "foo"))
03:01:01 <_zenon_> yeah.
03:01:03 <_zenon_> lunchtime
03:01:04 <_zenon_> cu
03:01:18 <quicksilver> Wild_Cat: it wants us to pass a variable 's' which is a function, which we can apply to both the number '1' and the string "foo"
03:01:38 <quicksilver> Wild_Cat: that doesn't sound possible in haskell. Surely no well-typed function can be applied to a number and a string!
03:01:49 <mmorrow> Wild_Cat: newtype MIO a = MIO (forall m. (MonadIO m) => m a)
03:01:59 <quicksilver> Wild_Cat: and indeed, haskell will fail to type check that.
03:02:05 <quicksilver> (\s -> (s (1::Int), s "foo"))
03:02:10 <quicksilver> to be scrupulously careful.
03:02:23 <quicksilver> otherwise we get a Num String constring which just confused the point I'm trying to make.
03:02:30 <Wild_Cat> well, show comes to mind here.
03:02:35 <quicksilver> Wild_Cat: *excatly*
03:02:38 <quicksilver> that's the answer.
03:02:46 <quicksilver> but that's not typable under normall haskell98 rules
03:02:55 <quicksilver> you can't pass polymorphic functions as arguments
03:03:00 <quicksilver> ...while keeping their polymorphism.
03:03:20 <quicksilver> any attempt to pass a polymorphic function as an argument ends up selecting a particular instance of it.
03:03:37 <quicksilver> Wild_Cat: fancy types with nested foralls are the answer.
03:04:16 <Wild_Cat> hrmm. So a function that's basically a map show over a list of arbitrary Show instances would be a possible use case, correct?
03:04:28 <mmorrow> yes
03:04:42 <mmorrow> but the /only/ thing you'll be able to do with them is show them
03:05:16 <Myoma> > map ($()) [\() -> show 3, \() -> show "foo", \() -> show True]
03:05:20 <lambdabot>   ["3","\"foo\"","True"]
03:05:45 <mmorrow> newtype S = S (forall a. (Show a) => a)
03:05:55 <Myoma> :t map show [\f -> f 3, \f -> f "foo", \f -> f True]
03:05:57 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[Char]'
03:05:57 <lambdabot>       Expected type: Bool -> t
03:05:57 <lambdabot>       Inferred type: [Char] -> t
03:08:21 <MarcWeber> :show languages
03:08:32 <MarcWeber> >:show languages
03:08:38 <MarcWeber> > :show languages
03:08:41 <lambdabot>   mueval: Prelude.read: no parse
03:08:52 <dolio> :t [\f -> f 3, \f -> f "foo", \f -> f True] :: [(forall a. (Show a) => a -> String) -> String]
03:08:54 <lambdabot> [(forall a. (Show a) => a -> String) -> String]
03:09:19 <wjt> :t [] :: [(forall a. (Show a) => a)]
03:09:20 <lambdabot> [forall a. (Show a) => a]
03:09:37 <wjt> hmm, i could have sworn you couldn't use bare existentials in that context
03:09:48 <dolio> Those aren't existentials.
03:10:30 <wjt> i guess i'm confusing terminology
03:10:34 <MarcWeber> Existentials will be resolved at runtime, but this is at compilation time?
03:11:04 <Wild_Cat> I'd then have to sig it as f :: forall a . (Show a) => [a] -> [String], right?
03:11:05 <Wild_Cat> (and an actual def in the lines of f = map show)
03:11:15 <Wild_Cat> wait, that wouldn't work anyway, lists can only contain objects of the same type.
03:11:19 <Wild_Cat> oh, well, AFK lunch. Be back later, thanks for the insight.
03:15:41 <yitz> > let g f (x, y) = (f x, f y) in g show (1, "foo")
03:15:44 <lambdabot>       No instance for (Num [Char])
03:15:44 <lambdabot>        arising from the literal `1' at <in...
03:15:46 <yitz> > let g :: (Show c, Show d) => (forall a. Show a => a -> b) -> (c, d) -> (b, b); g f (x, y) = (f x, f y) in g show (1, "foo")
03:15:50 <lambdabot>   ("1","\"foo\"")
03:16:26 <gvdm> what would provide Data.Binary.Strict.Get RE: Could not find module `Data.Binary.Strict.Get':
03:16:39 <MarcWeber> quicksilver: Do you feel like wanting to help me once more? http://hpaste.org/10264?lines=true
03:17:04 <MarcWeber> addElT :: PT est el -> PT estc elc -> PT est2 el2
03:17:11 <MarcWeber>  addElT el childEl = addElT el $ endElT childEl
03:18:07 <MarcWeber> My trouble is I don't know how to connect the result type of endElT with a constraint (line 43)
03:18:46 <MarcWeber> 43 should be deduced by the result of AddElT, if it was it would match the given constraint in line 26
03:19:21 <yitz> quicksilver: nice explanation of forall. Maybe paste that from the log to a wiki page. :)
03:24:18 <yitz> @let pent x = (3*x*x-x)`div`2
03:24:19 <lambdabot>   Parse error
03:24:29 <yitz> > let pent x = (3*x*x-x)`div`2 in pent 5
03:24:30 <lambdabot>   35
03:24:40 <yitz> wtf?
03:25:33 <yitz> @help let
03:25:34 <lambdabot> let <x> = <e>. Add a binding
03:25:52 <yitz> @let pent = \x -> (3*x*x-x)`div`2
03:25:53 <lambdabot>   Parse error
03:26:10 <yitz> what's going on here
03:26:26 <Myoma> @let pent = (\x -> (3*x*x-x)`div`2)
03:26:26 <lambdabot>   Parse error
03:26:40 <Myoma> @let pent x = (3*x*x-x)`div`2
03:26:40 <lambdabot>   Parse error
03:26:46 <lilac> > (\x -> (3*x*x-x)`div`2) 12
03:26:48 <lambdabot>   210
03:26:56 <Myoma> @let pent x = 3
03:26:57 <lambdabot>  Defined.
03:26:58 <Myoma> @undef
03:27:10 <lilac> @let pent x = div (3*x*x-x) 2
03:27:10 <lambdabot>   Parse error
03:27:23 <Myoma> @let pent x = 4
03:27:24 <lambdabot>  Defined.
03:27:28 <Myoma> @let pent x = 5
03:27:28 <lilac> @let pent x = div (3*x*x + (negate x)) 2
03:27:29 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
03:27:29 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
03:27:30 <Myoma> @undef
03:27:36 <lilac> @let pent x = div (3*x*x + (negate x)) 2
03:27:37 <lambdabot>  Defined.
03:27:40 <Myoma> Who do you tell about lambdabot bugs?
03:27:47 <yitz> Cale
03:27:50 <lilac> yitz: problem parsing (-) ?
03:28:09 <yitz> @let sb x y = x - y
03:28:10 <lambdabot>  Defined.
03:28:21 <yitz> @undef
03:28:21 <Myoma> preflex: tell Cale @undef seems broken, it _works_ but doesn't confirm
03:28:29 <yitz> @let sb x = x - x
03:28:30 <lambdabot>  Defined.
03:28:31 * lilac has had weird problems with @let before
03:28:39 <yitz> @undef
03:28:43 <lilac> usually with operator sections though
03:28:49 <yitz> @let sb x = 3*xx - x
03:28:50 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
03:28:55 <yitz> @let sb x = 3*x*x - x
03:28:56 <lambdabot>  Defined.
03:29:00 <yitz> @undef
03:29:12 <yitz> @let sb x = 3*x*x-x
03:29:12 <lambdabot>   Parse error in expression: HsPostOp (HsInfixApp (HsLit (HsInt 3)) (HsQVarOp...
03:29:18 <lilac> @let pent x = f (3*x*x - x) 2
03:29:19 <lambdabot>  Defined.
03:29:23 <yitz> aha
03:29:31 <lilac> @let pent x = div (3*x*x - x) 2
03:29:31 <yitz> @undef
03:29:32 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
03:29:36 <yitz> @undef
03:29:46 <lilac> @let pent x = div (3*x*x - x) 2 :: Int
03:29:47 <lambdabot>  Defined.
03:29:48 <yitz> @let sb x y = x-y
03:29:49 <lambdabot>  Defined.
03:29:53 <yitz> @undef
03:29:58 <yitz> @let sb x y = x*x-y
03:29:58 <lambdabot>   Parse error in expression: HsPostOp (HsVar (UnQual (HsIdent "x"))) (HsQVarO...
03:29:59 <lilac> yitz: no monomorphism restriction?
03:30:19 <yitz> lilac: huh?
03:30:28 <lilac> @undef
03:30:31 <lilac> @let pent x = div (3*x*x - x) 2
03:30:32 <lambdabot>  Defined.
03:30:55 <yitz> It has to do with spaces around -, which shouldn't be an issue
03:31:01 <yitz> @seen Cale
03:31:02 <lambdabot> I saw Cale leaving #haskell-overflow, #haskell and #ghc 3h 12m 56s ago, and .
03:32:36 <yitz> @tell Cale @let is sensitive to spaces in some weird way. @let f x y = x*x-y is a parse error, while @let f x y = x*x - y works.
03:32:36 <lambdabot> Consider it noted.
03:33:54 <lilac> @undef
03:33:57 <lilac> @let foo x = x-x
03:33:58 <lambdabot>  Defined.
03:34:00 <lilac> @let foo x = 2*x-x
03:34:00 <lambdabot>   Parse error in expression: HsPostOp (HsLit (HsInt 2)) (HsQVarOp (UnQual (Hs...
03:46:27 <MarcWeber> quicksilver: I had a typo somewhere else..
03:51:09 <quicksilver> MarcWeber: doh.
03:51:21 <quicksilver> MarcWeber: sorry I didn't answer. Those class problems take quite a while to grok.
03:55:40 <MarcWeber> quicksilver: This time it was better this way ;)
04:09:11 <conal> i'm looking for a quote.  maybe in the slides of an xmonad presentation.  it's something like "every bug is a missing quickcheck property".  can someone help me?
04:10:46 <guenni> mmorrow: ping
04:12:53 <cjs> Gah, another space leak. My life sometimes feels like an incessant battle with them.
04:22:57 <Xenoblitz> guys... quick question... i have a function of type State TypeA Bool and this function calls other functions ... also of the same type... say FuncA, FuncB, ... now FuncA itself doesn't required State input... is it possible to make this enclosing function not require any input ... don't know if i made myself clear enough :S
04:23:56 <Xenoblitz> if not i'll paste code in hpaste ?
04:24:27 <hackage> Uploaded to hackage: gameclock 1.0.3
04:24:36 <Xenoblitz> no one? :/
04:25:18 <Myoma> Xenoblitz: use eval/exec/runState ?
04:26:07 <Twey> Xenoblitz: Paste code
04:26:15 <Twey> Your description is hard to follow
04:28:08 <Xenoblitz> Myoma, Twey: i will paste code to make myself clearer, just a sec
04:30:01 <ac> how does one go about getting a Hackage package in to the Debian and Ubuntu archives?
04:30:48 <Xenoblitz> http://hpaste.org/10266
04:33:00 <ac> what do you mean by "pass a createGame"?
04:33:38 <ac> @users
04:33:38 <lambdabot> Maximum users seen in #haskell: 504, currently: 453 (89.9%), active: 15 (3.3%)
04:34:37 <Xenoblitz> i am passing the createGame function to runGame cause it needs a State as input... now i wish i didn't have to do that and leave the Game creation inside of createGame
04:35:50 <Saizan> Xenoblitz: you can just remove createNewGame from runGame
04:36:04 <Saizan> Xenoblitz: the initial state is passed in testGame
04:36:32 <Xenoblitz> Saizan: yes i know, but i wish to reventually write a language to describe the game
04:36:39 <EvilTerran> ... no preflex?
04:36:49 <Xenoblitz> and i wish that the construct createNewGame itself initializes the game
04:36:55 <Xenoblitz> EvilTerran: preflex?
04:37:07 <EvilTerran> ?seen preflex
04:37:07 <lambdabot> I saw preflex leaving #xmonad, #perl6, #haskell-overflow, #haskell-blah, #haskell and #ghc 3h 10m 2s ago, and .
04:37:08 <Xenoblitz> *eventually
04:37:16 <EvilTerran> 'e's buggad orf!
04:37:19 <Saizan> Xenoblitz: oh, so you don't want to pass an initial state?
04:37:25 <EvilTerran> ?karma
04:37:25 <lambdabot> You have a karma of 3
04:37:47 <Xenoblitz> Saizan: yes exactly, I am doing that just to make it work for now... but I wish to do without cause I don't want to use it
04:39:47 <Xenoblitz> Saizan: its probably something really simple I am not seeing, right?
04:40:20 <Saizan> Xenoblitz: i guess you could use a state of type Maybe Game and pass Nothing at the start, and wrap your state operations so that you can't reset the state to Nothing later (unless that's also what you want)
04:42:23 <Xenoblitz> Saizan: hmmm otherwise i'll just find a way to pass the function like i am... something i wouldn't like but... oh well :)
04:48:41 <quicksilver> conal: dons or dcoutss said something like 'the only bugs are bugs in the testsuite"
04:48:49 <quicksilver> conal: or 'the only kind of bug is a missing test'
04:48:52 <quicksilver> conal: someting like that.
04:48:58 <quicksilver> dcoutts_: do you recall?
04:49:12 <dcoutts_> hmm
04:49:24 <dcoutts_> quicksilver: I think it must have been dons
04:49:42 <dcoutts_> though I'm sure I agree with the sentiment
04:50:09 <conal> i like those forms also
04:50:47 <dcoutts_> I'm not sure that testing / writing properties is quite as easy as it should be though
04:51:00 <dcoutts_> it's a weak area in our toolchain
04:51:34 <dcoutts_> not that things like QC and SC arn't excellent, but we don't quite have the level of ease and integration that I think we want
04:51:56 * dcoutts_ has some ideas to make it better
04:52:53 <quicksilver> dcoutts_: agreed. We have excellent components but poor integration
04:52:59 <quicksilver> dcoutts_: that's true of quite a lot of things haskell
04:53:05 <dcoutts_> aye
04:53:19 <dcoutts_> we need more core cabal hackers imho
04:53:58 <ivanm> I don't suppose there's a way we can have some parts of a record-based data structure "read only"?
04:54:45 <luqui> ivanm, what do you mean?
04:55:15 <ivanm> luqui: I have a record that defines the "state" of a simulation, and  have functions that act open it
04:55:30 <ivanm> some of the parts of the record are constants of the simulation that shouldn't be changed
04:55:31 <dcoutts_> ivanm: then do not export the constructor
04:55:41 <EvilTerran> ivanm, sure, if you don't export the constructor or the field name, i thinkyou can't then change the field from outside that module
04:55:45 <ivanm> dcoutts_: _inside_ the module that defines it :p
04:55:58 <ivanm> I'm the only one who's going to use this code anyway, but just for neatness sake
04:56:05 <luqui> ivanm, well then you can't encapsulate
04:56:11 <ivanm> *nod*
04:56:17 <luqui> modules (unfortunately) are the primary method of encapsulation in haskell
04:56:28 <dcoutts_> ivanm: not so easily, you can encapsulate using types rather than module namespace but it's probably not worth it
04:56:31 <ivanm> didn't think so, just wanted to make sure
04:56:36 <ivanm> dcoutts_: *nod*
04:56:45 <luqui> i guess the unfortunate bit is the 1-1 correspondence between modules and files
04:56:46 <dcoutts_> abstract types are existential types
04:56:51 <Myoma> encapsulation is something that you'd ever want to do?
04:57:00 <luqui> or the nonexistance of "local modules"...
04:57:48 <Saizan> ivanm: if you're using monads you could split your record in two, and use something like ReaderT Constants (State Others) ..
04:58:25 <ivanm> nah, no monads
04:58:37 <ivanm> what I'm doing I could probably use the State monad for, but I can't see the point
04:58:56 <dancor> Saizan: looks like hbuild doesn't work with qualified imports: http://hpaste.org/10267
04:58:58 <quicksilver> ivanm: use the ReaderT ReadonlyBits (State modifiable bits) monad
04:59:07 <quicksilver> ivanm: or, build a custom setup which has those semantics.
04:59:26 <quicksilver> ivanm: let me give you a non-explicitly-monadic example
04:59:38 <quicksilver> ivanm: f :: (r,s) -> (a,s)
04:59:48 <quicksilver> ivanm: this function is, by inspection 'readonly' on the 'r' part
04:59:58 <quicksilver> ivanm: but it produces a new 's' part
05:00:03 <quicksilver> (and some kind of result 'a')
05:00:52 <ivanm> well, outside of the module that datatype won't ever be seen anyway
05:02:34 <Myoma> @let f :: (r,s) -> (a,s)
05:02:35 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
05:02:39 <Myoma> @free f :: (r,s) -> (a,s)
05:02:39 <lambdabot> $map_Pair k h . f = f . $map_Pair g h
05:03:38 <Saizan> dancor: you should pass it the module name, not the filename
05:03:52 <Saizan> dancor: "hbuild Test" works?
05:04:27 <dancor> Saizan: oh sorry, that does work.
05:04:43 <retybok> if I have f x y = (cos x) + (sin y) and g = f 2, I do partial application on the first argument. What if I want to do it on the second one?
05:05:00 <Myoma> retybok: flip f y
05:05:06 <Saizan> dancor: i realize this can be confusing, but i've not added input validation yet :)
05:05:18 <retybok> Myoma: what if there are more than two arguments?
05:05:30 <hansfbaier> Myoma: \x -> f x 2
05:05:59 <Myoma> hansfbaier: what
05:05:59 <retybok> hansfbaier: nice
05:06:00 <EvilTerran> > flip f x y :: Expr
05:06:00 <lambdabot>   f y x
05:06:07 <EvilTerran> > (flip . f) x y z :: Expr
05:06:09 <lambdabot>   f x z y
05:06:12 <EvilTerran> > (flip . flip f) x y z :: Expr
05:06:14 <lambdabot>   f z x y
05:06:30 <EvilTerran> etcetc, you can do it all with flip and (.) :P
05:07:03 <retybok> thank you all
05:07:13 <hansfbaier> EvilTerran: Yes, but it wont always yield the most readable code :)
05:12:31 <ivanm> grrr.... do hmatrix's types _have_ to be so convoluted? :@
05:12:51 <EvilTerran> > [f 1 2 3 | f <- [(,,), flip . (,,), flip (,,), flip (flip . (,,)), flip . flip (,,), flip (flip . flip (,,))]]
05:12:53 <lambdabot>   [(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)]
05:13:17 <EvilTerran> there, all permutations of three parameters, just from flip and (.) :P
05:13:34 <Botje> heh heh
05:13:34 * EvilTerran gets to thinking about a "shuffle" typeclass that matches up parameters based on types >:D
05:13:35 <Botje> neat
05:14:28 <ivanm> EvilTerran: :o
05:14:47 <ivanm> wow, don't think I've ever seen a list comprehension used to choose a function like that :o
05:15:41 <EvilTerran> i figured it was clearer than map (($3).($2).($1))
05:16:55 <EvilTerran> or (`sequence`3).(`sequence`2).(`sequence`1) $ ...
05:19:48 <dancor> > let pam x fs = [f x | f <- fs]
05:19:49 <lambdabot>   mueval: Prelude.read: no parse
05:20:14 <Myoma> map ($x)
05:20:25 <dancor> ah yes
05:20:33 <ivanm> anyone here familiar with hmatrix?
05:24:05 <Axman6> ivanm: does getting it installed, and playing with the examples count?
05:24:15 <ivanm> more playing
05:25:03 <Axman6> what's your problem anyway?
05:25:07 <ivanm> Numeric.LinearAlgebra.Interface says (if I read it correctly) that 2.*v is the correct way of  scaling a vector...
05:25:19 <ivanm> but ghci keeps complaining about my types :s
05:25:53 <ivanm> oh, wait, it doesn't like my type class for some reason :s
05:39:27 <jpcooper> hello
05:39:44 <jpcooper> could anyone tell me how I could read "3" as a PortNumber? I can show them but not read them
05:40:08 <Twey> jpcooper: You can read it as an Int, then convert
05:40:13 <jpcooper> how?
05:40:31 <Twey> PortNumber (fromIntegral (read "3" :: Int))
05:40:41 <jpcooper> @hoogle fromIntegral
05:40:41 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
05:40:49 <jpcooper> thanks
05:40:53 <Twey> Welcome
05:40:56 <ziman> @src fromIntegral
05:40:56 <lambdabot> fromIntegral = fromInteger . toInteger
05:41:26 <binrapt> > [f 1 2 3 4 | f <- [(,,), flip . (,,), flip (,,), flip (flip . (,,)), flip . flip (,,), flip (flip . flip (,,))]]
05:41:27 <lambdabot>   Couldn't match expected type `t1 -> t'
05:41:29 <binrapt> Failure
05:42:51 <Twey> Woah crap
05:42:56 <Twey> The hell is that O.O
05:43:06 <Twey> Oh
05:44:34 <ertai> Is there a known package that expose this class: class ToTree a where toTree :: a -> Tree String
05:44:39 <ertai> I found it very handy
05:46:36 <ivanm> http://hpaste.org/10268 <-- can someone see what's wrong with my nextStep function in here please?
05:49:35 <Saizan> ivanm: add the typesign without (Position (Vector a)), it should tell you which expression requires that context
05:50:56 <ivanm> yes... .*, +, etc.
05:51:05 <ivanm> all the matrix "math" calculations :s
05:51:39 <ivanm> even though  from what the docs say, .* should be (simplified) :: a -> Vector a -> Vector a
05:54:04 <Saizan> what's the type of scale?
05:57:33 <ivanm> scale :: (Linear c e) => e -> c e -> c e
05:58:10 <ivanm> ahh, sorry, scale x v = x .* v ( .* is an alias, I tried using the standard version to see if it was the problem :s )
05:58:16 <jpcooper> I've found an error in the GHC documentation. Could anyone tell me who to contact?
05:58:44 <Saizan> ?bug
05:58:45 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
05:58:46 <jpcooper> "It is a special case of groupBy, which allows the programmer to supply their own equality test." <- It is wrong to use "their" in that context
05:58:48 <ivanm> jpcooper: #ghc ?
05:59:01 <ivanm> jpcooper: ummmm.... why?
05:59:21 <jpcooper> because their is used to refer to multiple people
05:59:29 <ivanm> not always
05:59:43 <jpcooper> yes, otherwise it is used to refer to a person whose gender may not be known, which is wrong
05:59:46 <ivanm> and in this case, we're talking about any old programmer in the third person
05:59:54 <jpcooper> that's wrong
06:00:23 <ivanm> http://en.wikipedia.org/wiki/Their
06:00:24 <lambdabot> Title: They - Wikipedia, the free encyclopedia
06:00:33 <ivanm> oh, wait, it says plural...
06:00:38 <Wild_Cat> this is the standard, gender-neutral 3rd person possessive.
06:00:51 <jpcooper> if the people who right the documentation really care so much about gender-neutrality, surely they can write "his or her"?
06:00:54 <Wild_Cat> I'm pretty sure it's correct English.
06:01:08 <ivanm> Wild_Cat: well, it's right english in that it's how everyone does it...
06:01:08 <jpcooper> personally, I prefer grammatical correctness over the risk of offending someone
06:01:13 <vegai> Hey, I have a space leak that's weird to me and probably trivial to y'all
06:01:15 <vegai> http://hpaste.org/10269
06:01:25 <vegai> can someone explain?
06:02:04 <Wild_Cat> ivanm, jpcooper: http://en.wikipedia.org/wiki/Singular_they
06:02:05 <lambdabot> Title: Singular they - Wikipedia, the free encyclopedia
06:02:29 <vegai> jpcooper: surely they can just write "his"?
06:02:34 <ivanm> Wild_Cat: oh, so it _is_ official! :o
06:02:38 <Saizan> vegai: are you compiling with -O2 ?
06:02:48 <vegai> Saizan: hmm, no.
06:02:58 <ivanm> then again, it's the _Chicago_ manual of style... and americans don't butcher the queen's english at all, do they? :P
06:03:35 <jpcooper> vegai: yes, I don't really think that writing "his" alone implies that the writer thinks that women should have no rights
06:03:51 <vegai> Saizan: it *is* much faster, but still allocates memory like crazy
06:04:04 <jpcooper> I'm just getting rather annoyed with people's butchering of the language in the name of censorshiop
06:04:14 <vegai> this shouldn't happen as the BS is lazy, right?
06:04:45 <Saizan> vegai: yeah, you should just have a chunk at a time in memory
06:04:56 <jpcooper> and what is wrong with "one"?
06:05:00 <luqui> english is not a programming language...
06:05:13 <vegai> Saizan: bug in ghc / ByteString lib?
06:05:26 <jpcooper> anyway, I'll take my gripes somewhere else
06:05:31 <vegai> or perhaps (+1) does something nasty in that context
06:06:01 <Saizan> vegai: it looks like a bug, you should report it to the bytestring devs
06:06:06 <ivanm> vegai: maybe try (1+) or succ and see if that changes anything?
06:06:35 <Saizan> vegai: or try with the latest version of bytestring if you're not already using it
06:07:07 <Wild_Cat> according to that Wikipedia article, Shakespeare used "their" ;)
06:07:20 <vegai> ivanm: neither of those changed anything
06:07:27 <ivanm> Wild_Cat: yeah, and he was a paragorn of grammar, wasn't he :p
06:07:30 <vegai> Saizan: yes, I suppose I could try that later
06:07:35 <ivanm> vegai: *shrug* worth a try ;-)
06:07:44 <vegai> gotta go...
06:08:29 <Wild_Cat> ivanm: well, if it's good enough for him, it's good enough for me. My English is already bastardized enough that I can't really call it the Queen's or anything, so hey, any extra tricks I can use that don't look bad...
06:09:15 <Myoma> :t let a=(,);b=a.a;c=b.b;in c.c
06:09:16 <lambdabot> forall b b1 b2 b3 a b4 b5 b6 b7. a -> b -> (b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (b6 -> (b7 -> (a, b7), b6), b5), b4), b3), b2), b1), b)
06:09:47 * ivanm agreed with Blackadder the first time he saw Shakespeare in the millenium special ;-)
06:15:01 <ivanm> OK, wrt my hmatrix error, using the FlexibleContexts extension fixed it somehow :s
06:16:15 <Myoma> :t let a=join (,);b=a.a;c=b.b;in c.c
06:16:16 <lambdabot> forall a. a -> ((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((
06:16:16 <lambdabot> a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((
06:16:16 <lambdabot> a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((
06:16:16 <lambdabot> a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), (
06:16:19 <lambdabot> (a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a))
06:16:22 <lambdabot> , ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), (
06:16:25 <lambdabot> (a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))))
06:17:08 <BeelsebobWork> ahahahahaha
06:18:13 <Axman6> if you cross your eyes, there's a pony in there
06:18:44 <luqui> it's easier than that
06:18:54 * BeelsebobWork can't resist...
06:18:55 <BeelsebobWork> :t let a = join (,); b = a.a; c = b.b; d = c.c in d.d
06:18:55 <luqui> :T let a=join (,) in a.a.a.a.a
06:19:01 <lambdabot> forall a.*** Exception: stack overflow
06:19:02 <luqui> :t let a=join (,) in a.a.a.a.a
06:19:03 <lambdabot> forall a. a -> (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))
06:19:06 <BeelsebobWork> aww :(
06:19:29 <luqui> oh, except this one is growing as 2^2^n?
06:19:33 <BeelsebobWork> indeed
06:19:36 <luqui> by this one I mean Myoma's
06:19:48 <BeelsebobWork> well mine too -- but it exploded the type checker's stack
06:20:00 * luqui tries it at home
06:20:20 <Twigathy1> uh.
06:20:38 <luqui> nope. that's it for ghc.
06:20:47 <BeelsebobWork> haha
06:21:35 <luqui> however I did get it to eat up 1.5G of memory using the 2^n one
06:31:57 <cjs> Hey, how do I install this "generic" Linux x86 ghc?
06:32:05 <cjs> (Downloaded from the haksell.org web page.)
06:33:04 <lilac> hehe, "x :: forall a. *** Exception: stack overflow"
06:33:26 <Zao> cjs: ./configure --prefix=wherever; (sudo) make install
06:35:47 <cjs> Got it. I eventually found the file named "INSTALL". :-)
07:13:48 <CosmicRay> is there a function in the standard library to read a password from the terminal? Seems there ought to be, but I'm not finding it
07:14:14 <BeelsebobWork> just turn character copying off
07:14:15 <ivanm> CosmicRay: as in outputing * for each character?
07:14:21 <CosmicRay> ivanm: or outputting nothing
07:14:26 <ivanm> *nod*
07:14:30 <ivanm> what BeelsebobWork said ;-)
07:14:33 <CosmicRay> BeelsebobWork: of course.  what's the cross-platform way of doing so?
07:14:41 <BeelsebobWork> cross platform -- pass
07:14:47 <BeelsebobWork> all unicies, I'm sure is easy
07:14:56 <Igloo> There's hSetEcho
07:15:01 <BeelsebobWork> ah, shiny
07:15:13 <CosmicRay> Igloo: perfect
07:15:55 <FunctorSalad> hmm... ISTR hearing about hiding the constructor if you make a safer constructor... how do I do that?
07:15:55 <Igloo> I wouldn't put money on it working on Windows in all configurations, though
07:16:10 <gio123> does somebody knows reader for ps files?
07:16:18 <CosmicRay> Igloo: understood.
07:16:36 <CosmicRay> gio123: ghostscript, ghostview, gv, any ghostscript derivitave
07:16:57 <gio123> does not work
07:16:59 <BeelsebobWork> Preview.app on OS X
07:17:01 <gio123> ghostrip
07:17:09 <FunctorSalad> for actual reading I prefer evince
07:17:18 <BeelsebobWork> ps2pdf | <insert pdf viewer>
07:17:30 <CosmicRay> BeelsebobWork: which of course requires ghostscript ;-)
07:17:30 <gio123> i have windows
07:17:39 <CosmicRay> you can get ghostscript for windows
07:17:48 <ivanm> gio123: gs, there's a windows version
07:18:08 <gio123> does not work
07:18:15 <ivanm> :o
07:18:20 <ivanm> worked here when I used windows...
07:18:38 <gio123> it does not work since march
07:18:40 <ivanm> and I've used it on other machines with no problems (except for that annoying registration dialog that always comes up... :@ )
07:18:46 <ivanm> weird :s
07:19:24 * Axman6 wonders what this has to do with haskell...
07:19:39 <ivanm> Axman6: everything has to do with haskell! :p
07:19:48 <RayNbow> Igloo: I just tested hSetEcho... it works in XP
07:20:06 <Axman6> ivanm: you blaming haskell for crappy support for ps files on windows? :P
07:20:29 <ivanm> Axman6: no, but he obviously wants to read haskell papers in ps format on windows!
07:21:32 <ivanm> gio123: http://www.spaceblue.com/pdfblender/ maybe
07:22:21 <gio123> thanks
07:25:11 <gio123> ivanm: is it convertor?
07:25:23 <ivanm> no idea, found it on wikipedia
07:25:24 <ivanm> ;-)
07:25:28 <ivanm> there's also yap
07:37:17 <MarcWeber> dcoutts: Have you thought about keeping different configurations at the same time? (eg one for flag = true, one for flag = false, and the same for two different ghc versions?)
07:38:06 <dcoutts_> MarcWeber: huh?
07:38:43 <MarcWeber> dcoutts_: Maybe something like ./configure --alias="ghc-6.8" which does all the work in ./dist-ghc6.8 ?
07:38:57 <MarcWeber> Then you could configure --alias="ghc-head"
07:39:15 <MarcWeber> and finally do a ./setup build ghc6.8 ghc-head
07:39:16 <dcoutts_> MarcWeber: sorry, I must have missed some context, what are we talking about ?
07:39:39 <MarcWeber> I've not given you enough. I'm talking about cabal.
07:40:01 <MarcWeber> And it might be handy to have cabal build different settings in sequence or even at the same time.
07:40:14 <dcoutts_> MarcWeber: so you want to build a package in multiple configurations
07:40:22 <MarcWeber> yes
07:40:24 <dcoutts_> eg one source tree and multiple object trees
07:40:37 <dcoutts_> you're in luck! Cabal can do that.
07:40:54 <dcoutts_> --destdir=foo
07:41:29 <dcoutts_> and since Cabal puts all the state and generated files under the distdir then that allows multiple configurations and builds
07:42:07 <MarcWeber> I know tha latter
07:42:36 <dcoutts_> it's not enormously convenient since the same --distdir needs to be give each time, more handy would be to go to an empty dir and configure specifying the location of the package and then it'd put the dist dir locally so you'd not have to specify it again and again
07:42:46 <MarcWeber> dcoutts_:  --distpref=DIR ?
07:42:54 <MarcWeber> ah ok
07:43:09 <Igloo> Hmm, "distdir" is a bit similar to "destdir"
07:43:17 <dcoutts_> MarcWeber: in the latest Cabal it's --distdir though --distpref is a deprecated alias
07:43:30 <Igloo> Why is it "dist", anyway?
07:43:32 <dcoutts_> Igloo: dir is the suffix we use everywhere, not pref so I changed it
07:43:51 <dcoutts_> Igloo: because it's the ./dist/ dir init? :-)
07:43:57 <Igloo> dcoutts_: It's the dist/dest I'm thinking about. You wrote the wrong one earlier
07:44:01 <MarcWeber> I guess Igloo thinks it should be called build (the way cmake does call it by default)
07:44:07 <dcoutts_> Igloo: heh, oops
07:44:11 <Igloo> dcoutts_: Right, but /why/ is it the dist/ dir?
07:44:14 <dcoutts_> distribution I suppose
07:44:38 <dcoutts_> Igloo: ask Issac, I'm just going with the convention :-)
07:44:55 <dcoutts_> Igloo: but perhaps you're right and we should rename the option name before everyone starts using it :-)
07:45:02 <Igloo> Yeah, build seems like a much more sensible name
07:45:09 <dcoutts_> --builddir=
07:45:15 <dcoutts_> it does seem sensible
07:45:33 <Igloo> dcoutts_: Right, and in theory nothing will break if we rename the directory too, but let's leave it until post 6.10 just in case...
07:45:45 <twanvl> How do I get Data.Binary.decodeFile to close the file after it is done? Using evaluate to force the result doesn't seem to help.
07:45:51 <dcoutts_> Igloo: yeah, too many people rely on it
07:46:06 <dcoutts_> twanvl: I think it does in the latest version
07:46:22 <dcoutts_> twanvl: but only if your binary instance consumes the whole file
07:46:33 <Igloo> Anyone relying on it is going to not work correctly with --builddir, so I don't mind breaking them so that we can identify and fix them  :-)
07:46:44 <Igloo> But not just before a release
07:47:03 <MarcWeber> dcoutts_: Thanks! perfect
07:47:30 <dcoutts_> Igloo: ok, I'll leave --distpref so I don't break ghc immediately
07:47:39 <Igloo> OK
07:59:11 <Baughn> Funny thing. Is it normal for programmers to have to study and read large books just to learn how to write decent APIs?
07:59:23 <Zao> Baughn: Most don't bother.
07:59:47 <Baughn> Hm. That would explain this code.
08:00:50 <Twey> @src (.)
08:00:51 <lambdabot> (f . g) x = f (g x)
08:01:33 <dmwit> :t (.)
08:01:34 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:01:37 <dmwit> oh
08:01:54 <dmwit> I didn't even notice that we were no longer using Caleskell in here.
08:02:04 <byorgey> oh, no?
08:02:07 <byorgey> :t (++)
08:02:08 <lambdabot> forall a. [a] -> [a] -> [a]
08:02:10 <byorgey> indeed
08:03:08 <Twey> Where is Cale, anyway?  Been a while since I've seen him around
08:03:16 <Twey> medfly?
08:03:16 <byorgey> @seen Cale
08:03:16 <lambdabot> I saw Cale leaving #haskell-overflow, #haskell and #ghc 7h 45m 10s ago, and .
08:03:21 <Twey> Oh
08:03:28 <Twey> I must've just missed him, then :)
08:08:00 <maltem> My mind is ruining my life :(
08:13:02 <guenni> is there a data structure where I can store homogenous records, have indexes on multiple fields and can query the structure in a way similar to SQL? Do grouping and the like?
08:20:55 <RayNbow> hmm, hpaste should get a "find pastes by user" feature...
08:22:15 <zachk> > 2+2
08:22:16 <lambdabot>   4
08:23:07 <zachk> @faq can haskell let me avoid my college computer lab restrictions on no Instant messaging via writing my own irc client?
08:23:08 <lambdabot> The answer is: Yes! Haskell can do that.
08:23:17 <zachk> sweet
08:23:49 <byorgey> zachk: hehe, awesome =)
08:24:32 <hackage> Uploaded to hackage: dotgen 0.2
08:24:32 <hackage> Uploaded to hackage: debian-binary 0.0.1
08:25:50 <thoughtpolice> i was going to suggest bitlbee
08:25:52 <thoughtpolice> but okay :]
08:25:58 <thoughtpolice> haskell can do it regardless!
08:26:34 <ekidd> @faq Can Haskell help me build a low-earth orbiter?
08:26:34 <lambdabot> The answer is: Yes! Haskell can do that.
08:26:41 * ekidd is amused
08:27:24 <thoughtpolice> @faq can I use haskell to help build a low-orbit ion-cannon in the goals of world domination?
08:27:25 <lambdabot> The answer is: Yes! Haskell can do that.
08:27:31 <thoughtpolice> kick ass
08:28:32 <mc__>  @faq can haskell create a stone that is so heavy that not even haskell itself can lift it?
08:28:43 <RayNbow> mc__: lift it into what?
08:28:47 <RayNbow> a monad? :p
08:29:52 <mc__> Nope , I meant into the air :)
08:30:15 <RayNbow> :t liftAir
08:30:16 <lambdabot> Not in scope: `liftAir'
08:31:04 <Xenoblitz> guys... simple question which has been troubling me... how do you convert something of type IO Int to Int???
08:31:19 <quicksilver> Xenoblitz: you don't, technically.
08:31:24 <quicksilver> but in practice, you do this:
08:31:29 <quicksilver> a <- thingWhichIsIOInt
08:31:40 <quicksilver> return (a+5) --- a is an Int
08:32:36 <RayNbow> Xenoblitz: http://arcanux.org/lambdacats/io-monad.jpg
08:32:44 <Xenoblitz> quicksilver: thanks
08:32:49 <Xenoblitz> raynbow: will check it out
08:32:49 <Wild_Cat> @faq can Haskell kill my enemies, mutilate their corpses, burn their houses and rape their women while their children look upon me with despair and cry tears of blood?
08:32:50 <lambdabot> The answer is: Yes! Haskell can do that.
08:33:12 <Xenoblitz> omg lolcatz
08:33:13 <Xenoblitz> loool
08:33:25 <Wild_Cat> now that's what I'm talking about.
08:33:27 <u_quark> is there a form of Monad.when that return m a ?
08:33:58 <dmwit> :t when -- u_quark, like this?
08:33:59 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:34:07 <RayNbow> Xenoblitz, more at http://arcanux.org/lambdacats.html :)
08:34:08 <lambdabot> Title: Lambdacats
08:34:48 <Xenoblitz> omg good ones :)
08:36:41 <quicksilver> u_quark: what would it return when the condition was false?
08:36:51 <quicksilver> u_quark: I think you might as well just use 'if' in that case
08:36:58 <quicksilver> (you have to supply something for the false case)
08:36:58 <u_quark> xmmm something like Maybe i had in mind...
08:37:13 <quicksilver> if something then action else return 5
08:37:24 <u_quark> but an extra monad makes thing little more confusing :P
08:37:25 <quicksilver> the main advantage of 'when' is being able to skip one branch
08:37:39 <quicksilver> when you have both branches you might as well use lift.
08:37:43 <quicksilver> use 'if'
08:37:45 <quicksilver> damn fingers.
08:37:49 <quicksilver> never type what I tell them to.
08:38:06 <u_quark> lol
08:38:10 <thoughtpolice> you should teach them a lesson
08:38:26 <Xenoblitz> quicksilver: so its impossible for me to have this... getStdRandom (randomR (1,6)) but of type Int :/
08:38:31 <esteth> This seems like a silly question, but if two files are in the same directory, should I be able to do import OtherModule if OtherModule is defined in another file in the same directory? I'm getting an error that ghc can't find the module
08:39:09 <thoughtpolice> esteth: yes - is the file named OtherModule.hs for example?
08:39:38 <esteth> I'm importing Halso, and the file is called halso.hs
08:39:45 <esteth> do I have to uppercase the filenames?
08:39:53 <dylan> is there standard function that breaks a list into a list-of-2-tuples? e.g. [a] -> [[a]] = "whee" -> [ "wh", "ee" ]
08:40:01 <quicksilver> Xenoblitz: it's not so much impossible, as wrong.
08:40:27 <thoughtpolice> esteth: i believe so
08:40:28 <ziman> > let chunkBy n = map (take n) . takeWhile (not.null) . iterate (drop n) in "wheeee"
08:40:29 <lambdabot>   "wheeee"
08:40:36 <ziman> > let chunkBy n = map (take n) . takeWhile (not.null) . iterate (drop n) in chunkBy 2 "wheeee"
08:40:37 <lambdabot>   ["wh","ee","ee"]
08:40:38 <thoughtpolice> e.g. if Main imports Halso, then the other file needs to be Halso.hs
08:40:44 <RayNbow> Xenoblitz, could you see the problem of having "die :: Int" that randomly returns a value between 1 and 6?
08:40:44 <Xenoblitz> quicksilver: I just need a quick randomizing function :/ /cry
08:40:58 <dylan> ziman: That works, yes, but I was wondring if chunkBy was already defined.
08:41:00 <Xenoblitz> RayNbow: oh fudge... yes
08:41:03 <ziman> dylan, there's no such function and everybody has their implementation with their own name
08:41:19 <dylan> ziman: Much like split, I suppose. :-/
08:41:25 <Xenoblitz> RayNbow: its wrong in functional programming to have such a thing
08:41:58 <RayNbow> well, if you want purity and referential transparancy, then yes it's wrong :p
08:42:03 <Twey> It's not a function
08:42:11 <Twey> (in mathematical terms)
08:42:12 <Xenoblitz> RayNbow, quicksilver: but seriously... is there nothing I can do besides implementing my own huge random generator?
08:42:30 <RayNbow> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms#Using_QuickCheck_to_Generate_Random_Data <-- I once used QuickCheck's Gen monad
08:42:35 <lambdabot> http://tinyurl.com/2fpup7
08:43:10 <RayNbow> but there might be better alternatives
08:43:22 <Xenoblitz> i'll checkout the link
08:43:24 <Xenoblitz> thanks :)
08:43:36 <quicksilver> Xenoblitz: do not implement your own random number generator
08:43:41 <quicksilver> Xenoblitz: even if you do, that won't help.
08:43:47 <quicksilver> Xenoblitz: System.Random is fine, and it works fine.
08:44:05 <quicksilver> you just need to understand how to use it ;)
08:44:14 <esteth> Indeed. Random should work just fine for generating random values
08:44:43 <Xenoblitz> yes but its gonna involve a total rewrite of what i wrote so far i think :(
08:45:09 <Xenoblitz> plus seriously haskell documentation has a way of making everything seem cryptic sometimes
08:45:44 <quicksilver> it's really not hard
08:45:51 <quicksilver> and it won't require you to rewrite anything.
08:46:01 <quicksilver> so, show us some of the code and someone can show you how to wire a random number in
08:48:05 <Xenoblitz> its simple really, I'm writing a sort of DSL for tetris as an experiment, my monadic functions are of type State Game Bool ... eg do genBrick; moveDown; moveDown; rotateLeft; ... etc etc... and when I call genBrick I wish to randomly generate a number from 1-7 for a random brick type...
08:48:54 <Xenoblitz> wouldn't I have to somehow include some seed in my Game type if i use System.Random?
08:49:33 <quicksilver> Xenoblitz: yes, and that's the right thing to do.
08:49:40 <quicksilver> stick a StdGen in the Game type
08:49:47 <quicksilver> and use it/update it in genBrick
08:50:23 <quicksilver> you don't have to do it that way; you could just keep a StdGen hanging around in your main loop or you could just use randomIO in your main loop
08:50:31 <FunctorSalad> if you could write a pure random generator that doesn't need a seed you'd clearly lose referential transparency and everything
08:50:41 <quicksilver> but, really, putting a StdGen in the Game object sounds most elegant
08:51:07 <Xenoblitz> quicksilver: and that's what's bothering me... I might have to do some changes to the code to accomadate that
08:51:14 <RayNbow> quicksilver: he could also put in an infinite list of random values in the Game object, right?
08:51:17 <Xenoblitz> ok I'll add StGen and good willing...
08:51:36 <quicksilver> well if your code is well designed adding a new field to the Game record won't do much harm
08:51:46 <quicksilver> RayNbow: formally that's very nearly the same thing.
08:51:48 <Xenoblitz> quicksilver: well that's what i hope
08:51:50 <FunctorSalad> or have StdGen return a probability distribution =)
08:52:26 <Xenoblitz> hmmmm I think it's best I stick to the simplest solution as I am new at this
08:52:27 <Xenoblitz> hehe
08:52:31 <Xenoblitz> StdGen in Game it is!
08:52:32 <Xenoblitz> thanks guys
08:52:36 <RayNbow> good luck :)
08:53:15 <FunctorSalad> (I mean genBrick, not stdGen)
08:54:44 <FunctorSalad> hmm... has "lazy probability" been done? that is, formally work on probability distributions, but if "randomSample" is called in the end, only the necessary calculations are done?
08:55:02 <FunctorSalad> not sure that makes sense, just thought of it
08:56:35 <u_quark> is there a way to "flip" tow Monads ? :P like flip :: Monad m1, Monad m2 => m1 m2 a -> m2 m1 a ?
08:56:46 <FunctorSalad> I should probably take a look at the probability library first before asking such questions ;)
08:57:04 <Myoma> @instances Monad
08:57:05 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:57:36 <FunctorSalad> @src MonadTransformer
08:57:36 <lambdabot> Source not found. Where did you learn to type?
08:57:39 <FunctorSalad> @src MonadT
08:57:39 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:57:49 <Myoma> u_quark: is Maybe (Either e x) -> Either e (Maybe x)  a counterexample?
08:57:49 <lilac> u_quark: if m1 is [], then there's sequence IIRC
08:57:53 <lilac> @type sequence
08:57:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:58:35 <u_quark> the two monads are actually IO and Maybe
08:59:05 <lilac> Myoma: "Nothing -> Right Nothing; Just Left e -> Left e; Just Right e -> Right Just e" has the right type
08:59:16 <lilac> u_quark: then no.
08:59:24 <u_quark> :) i thought so ...
08:59:45 <lilac> u_quark: imagine getFileContents :: String -> IO (Maybe String)
08:59:58 <lilac> you can't find whether it's Nothing or Just without doing IO
09:00:22 <FunctorSalad> lilac: the choice of "Right" there seems arbitrary though
09:00:44 <u_quark> lilac: yes yes... :|
09:01:14 <BeelsebobWork> I'd even suggest than Left would be a better arbitrary choice
09:01:27 <BeelsebobWork> because Left and Nothing are both indicative of erros
09:01:29 <BeelsebobWork> errors*
09:01:35 <lilac> BeelsebobWork: for which case?
09:01:43 <BeelsebobWork> lilac: Nothing -> Left Nothing
09:01:52 <lilac> Nothing isn't a valid Left vfalue
09:02:10 <BeelsebobWork> huh? oh -- you're assuming it's an error
09:02:20 <BeelsebobWork> I assumed the output would be type Either (Maybe a) (Maybe b)
09:02:24 <lilac> Maybe (Either e x) -> Either e (Maybe x)
09:02:41 <FunctorSalad> I was trying to say that if you have to make an arbitrary choice that's a good hint that the general case won't work =)
09:02:48 <BeelsebobWork> oh course, Either e is the monad
09:02:59 <FunctorSalad> (general case is m1 m2 a -> m2 m1 a here)
09:02:59 <BeelsebobWork> FunctorSalad: it's not an arbitrary choice
09:03:07 <lilac> FunctorSalad: absolutely. but which arbitrary choice did i make, other than not just mapping everything to Right Nothing?
09:03:22 <Myoma> ?djinn Maybe (Either e x) -> Either e (Maybe x)
09:03:23 <lambdabot> f a =
09:03:23 <lambdabot>     case a of
09:03:23 <lambdabot>     Nothing -> Right Nothing
09:03:23 <lambdabot>     Just b -> case b of
09:03:23 <lambdabot>               Left c -> Left c
09:03:25 <lambdabot>               Right d -> Right (Just d)
09:03:50 <lilac> there appears to be exactly one isomorphism between the types.
09:03:52 <Myoma> ?djinn Either e (Maybe x) -> Maybe (Either e x)
09:03:53 <lambdabot> f a =
09:03:53 <lambdabot>     case a of
09:03:53 <lambdabot>     Left b -> Just (Left b)
09:03:53 <lambdabot>     Right c -> case c of
09:03:53 <lambdabot>                Nothing -> Nothing
09:03:55 <lambdabot>                Just d -> Just (Right d)
09:04:04 <Myoma> are they inverses?
09:04:08 <Myoma> I think so
09:04:10 <quicksilver> u_quark: you might call that a distribution property, or a commutation property.
09:04:11 <lilac> yes
09:04:18 <lilac> except for _|_ perhaps?
09:04:26 <Myoma> ignoring _|_
09:04:30 <quicksilver> u_quark: only some pairs of monads have that.
09:04:49 <FunctorSalad> lilac: if we have just Either and Maybe your definition is fine of course. I meant it doesn't rely only on the monad "interface"
09:04:59 <lilac> FunctorSalad: sure, absolutely :)
09:05:09 <quicksilver> lilac, Myoma : that's associativity for addition
09:05:18 <lilac> the isomorphism is unusual, though
09:05:21 <quicksilver> (A + B) + 1 = A + (B + 1)
09:05:33 <quicksilver> (where plus is type-sum)
09:05:34 <lilac> [] m -> m [] isn't an isomorphism, for instance
09:06:28 <quicksilver> Maybe is the same as Either ()
09:06:35 <esteth> Is there a way to instruct GHC too look in additional files to find modules? someinng like --additional "~/otherfile.hs"?
09:06:40 <Myoma> quicksilver: Nice intuition!
09:06:41 <quicksilver> so this is just saying that `Either` is associative
09:06:43 <quicksilver> which it is.
09:06:57 <BeelsebobWork> esteth: -i?
09:07:00 <quicksilver> Myoma: less intuition than practice, in my case ;)
09:07:46 <FunctorSalad> lilac: sorry, forget what I said, I forgot that Left and Right are not symmetrical here
09:08:24 <lilac> i am curious what the condition on m1 and m2 for (Monad m1, Monad m2) => m1 m2 a -> m2 m1 a existing is, though
09:08:44 <esteth> Beelsebob: Thanks. Still the same problem though. Looks like there's something wrong with my module definitions or something :(
09:08:50 <FunctorSalad> quicksilver's explanation that Either () ~~ Maybe seems good
09:08:56 <lilac> m1 being [], Maybe, Either is OK, but it's not MonadPlus I think
09:08:59 <FunctorSalad> (that's why it works well here)
09:09:14 <quicksilver> lilac: I've not seen an interesting criterion.
09:09:31 <quicksilver> lilac: IME the answer is "it usually doesn't exist" ;)
09:09:35 <lilac> i think further properties are wanted; [] Maybe -> Maybe [] -> [] Maybe isn't identity
09:09:58 <FunctorSalad> looks like a commutativity condition to me (m1 \circ m2 = m2 \circ m1)
09:10:21 <FunctorSalad> and in general function application is far from commutative ;-)
09:10:26 <FunctorSalad> err, composition
09:10:27 <quicksilver> either, [] and Maybe all offer what you might call 'short circuit' or 'rollback' operations
09:10:30 <lilac> perhaps this makes more sense expressed in terms of monad transformers
09:10:41 <quicksilver> as such, they cannot commute with State or Writer.
09:10:50 <lilac> in fact, does the property exist iff there exists a monad transformer?
09:10:52 <quicksilver> ISTR Reader commutes with most things.
09:10:54 <quicksilver> lilac: no.
09:11:10 <lilac> quicksilver: quick counterexample?
09:11:11 <quicksilver> lilac: StateT is perfectly well behaved monad transformer but still fails to commute with quite a lot.
09:11:21 <quicksilver> StateT Either /= Either StateT
09:11:24 <lilac> quicksilver: not commutativity, but 'push into monad'
09:11:52 <FunctorSalad> isn't that just "return"?
09:12:33 <lilac> that is, does there exist a transformation m1 (m2 a) -> m2 (m1 a) iff there's an equivalent transformer mt with mt m2 == m1 . m2?
09:13:05 <lilac> i suspect this is either obviously true or obviously false, but i'm nto sure which :)
09:13:14 <FunctorSalad> by the way, will such a transformation automatically be natural?
09:13:33 <quicksilver> lilac: looks backwards
09:13:42 <quicksilver> monad transformers are usually reverse composition
09:13:49 <quicksilver> MaybeT IO is IO :. Maybe
09:13:53 <lilac> quicksilver: quite possibly :)
09:14:22 <dylan> % echo '1AD8 69DD F56A E7AB 421C  7D8A C66D 87D9 82CD 4AE4' | runhaskell spak.hs
09:14:25 <dylan> bradbury stormy guitarist swelter visitor geiger truncated rhythm december befriend insincere oakland responsive goggles liberty sugar istanbul spindle direction tonic
09:14:27 <FunctorSalad> (istr that this is related to "theorems for free", but don't know what exactly the prerequisites are)
09:14:33 <lilac> FunctorSalad: i don't have a strong intuition for what a natural transformation is, so i ahve no idea ;-)
09:14:46 <dylan> Thanks #haskell, for once again allowing me to goof off in the strangest ways.
09:18:14 <FunctorSalad> lilac: many reformulations but I'm not sure which would be helpful
09:18:28 <quicksilver> lilac: one of the things people like about Applicative is that applicatives combine purely by type composition.
09:18:52 <u_quark> now... i did understand all that ... :P but my problem remains: I want to pre-evaluate a IO value only if some condition holds ... if the condition is false i am happy with just a dummy value witch i will ignore later ... so i thought Maybe.... but I don't get how I can do that ....
09:18:55 <FunctorSalad> they "deform" one functor into another
09:18:56 <quicksilver> (and that is provably enough to satisfy the applicative laws)
09:23:18 <FunctorSalad> a neat definition of "natural transformation" I saw the other day was: let 2 be the category 0 -> 1. then a functor H: 2 x A -> B is a natural transformation between H restricted to 0 and H restricted to 1
09:23:41 <FunctorSalad> ("0" and "1" are just object atoms here)
09:24:02 <FunctorSalad> very geometrical
09:25:01 <FunctorSalad> sorry, I mean H restricted to {0} x A and H restricted to {1} x A
09:26:15 <lilac> I think if we had joinTrans :: (MonadTrans t) => t Identity (t m a) -> t m a, then that's enough to get (MonadTrans t) => m (t Identity a) -> t m a
09:30:08 <FunctorSalad> the crazyfying thing when trying to computerize category theory is deciding what to put on the metalevel logic and what on the object level :| since everything is so readily internalizable in ct
09:32:18 <FunctorSalad> currently thinking whether I should hardcode the product-related isomorphisms like 1 x A ~ A or formulate the coherence theorem internally
09:33:04 <dons> ?users
09:33:04 <lambdabot> Maximum users seen in #haskell: 504, currently: 470 (93.3%), active: 12 (2.6%)
09:33:28 <FunctorSalad> (just throwing this into the room in the hope that anyone who cares about ct is present ;-))
09:46:15 <dons> http://www.reddit.com/r/programming/comments/70xal/return_return_or_programming_with_overloading_and/
09:46:20 <lambdabot> Title: Return return: or, programming with overloading and higher-order polymorphism :  ..., http://tinyurl.com/5lq526
09:48:36 <Eelis> i'm looking at Language.C, but can't seem to find a way to just do lexing with it. am i overlooking something, or is this really not possible?
09:49:12 <dcoutts_> g'morning dons, done with the daily haskell-blasting of reddit I see :-)
09:49:14 <dons> hmm. there's a lexer afaik.
09:49:19 <dons> dcoutts_: :)
09:49:28 <dons> i was travelling for a couple of days
09:49:32 <dons> so catching up on p.h.o
09:49:44 <dcoutts_> dons: somewhere fun?
09:49:51 <dons> east coast. haven't been there before.
09:49:54 <dons> all very interesting
09:50:11 <dcoutts_> Eelis: I've no idea about the language.c api but internally there is certainly a lexer, though I think it's monadic (it certainly was in c2hs)
09:50:21 <Eelis> dcoutts_: i see. ok, thanks
09:50:25 <dcoutts_> dons: oh right, where NY ?
09:50:33 <dons> i'll bug atomb@galois about writing up his experiments parsing the linux kernel with Language.C
09:50:37 <dons> he did a lot of fun things.
09:50:43 <dons> dcoutts_: john hopkins in maryland.
09:50:52 <dons> DC area.
09:50:59 <dcoutts_> that's a uni right?
09:51:01 <dons> yeah
09:51:40 <dcoutts_> dons: I'd be very interested to read about someone else having a crack at parsing the kernel with language.c
09:52:08 <dons> well, it was all very succesful
09:52:08 <dcoutts_> it's really pleasing to see language.c turn out to be useful :-)
09:52:18 <dons> so we may start using language.c for some real projects in analysis
09:52:22 <Eelis> it'd be more useful if the api supported lexing ;)
09:52:38 <Eelis> s/more/even more/
09:52:39 <dcoutts_> Eelis: I'm sure that's easy to do, it's all there internally
09:52:54 <dons> we probably need more analysis passes on top
09:53:00 <dons> i hope they'll build up over time
09:53:04 <dons> a suite of C transformations of use
09:53:21 <dcoutts_> dons: heh, that'd be fun. I remember asking if the original galois c parser was available before I started rewriting the c2hs one :-)
09:53:22 <sw17ch> dcoutts_: speaking of language.c, i figured out how to have it keep positional information :)
09:53:28 <dcoutts_> sw17ch: good
09:53:40 <sw17ch> as far as i can tell... it's going to be straight forward.. .if not easy
09:53:41 <dons> dcoutts_: i'm not sure we have a C parser? at least i've not seen one.
09:53:50 <dons> i could be wrong. there are a *lot* of parsers and pprs around
09:54:02 <dcoutts_> dons: it's one of the first projects galois did according to the ICFP 2004 talk
09:54:23 <dcoutts_> back in the really really early days
09:54:35 <sw17ch> I've been meaning to ask this, has any one tried to use Language.C to do some maximum stack size analysis?
09:54:47 <dons> dcoutts_: yeah, i'm not surprised.
09:54:50 <dons> i'll ask around.
09:55:23 <dons> dcoutts_: read rl's mutable array recycling fusion?
09:55:29 <dcoutts_> dons: bits of it
09:55:37 <dons> makes me wonder if there are other bits of fusion lore that should be written up
09:56:02 <dcoutts_> dons: I'm writing up a proof at the moment of all the short-cut fusion rules
09:56:06 <dons> sweet.
09:56:17 <dcoutts_> in the right setting they all fall out trivially
09:56:25 <dcoutts_> it's almost embarrassingly simple
09:56:35 <dcoutts_> though it's only for algebraic types, not arrays
09:56:54 <sw17ch> Eelis: the module isn't exposed, but take a look at Language.C.Parser.Lexer
09:57:01 <sw17ch> the darcs repo has the .x file in there
09:57:15 <sw17ch> and if you build it, you might be able to extract some info about it from the build directory
09:58:35 <dcoutts_> sw17ch: remind me where the repo is?
09:59:16 <sw17ch> dcoutts_: what's the darcs command to list information about the repo?
09:59:24 <sw17ch> i have it on my machine, i can't remember the direct url :)
09:59:26 <Eelis> sw17ch: thanks, but i wouldn't want to go digging in library internals. i don't want to add the whole Language.C code to my own project.
09:59:39 <dcoutts_> sw17ch: cat _darcs/prefs/defaultrepo
09:59:55 <sw17ch> dcoutts_: http://code.haskell.org/language-c
09:59:57 <lambdabot> Title: Index of /language-c
10:00:04 <dcoutts_> sw17ch: ah, ta
10:00:25 <sw17ch> Eelis: I think Benedikt has talked about opening up more of the internals as modules... but i haven't talked to him directly about this. dcoutts_, do you know any more about his plans?
10:00:36 <dcoutts_> sw17ch: nope
10:00:40 <zachk> @src words
10:00:40 <lambdabot> words s = case dropWhile isSpace s of
10:00:40 <lambdabot>     "" -> []
10:00:40 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:00:53 <BMeph> dcoutts_: I know the topic's passed, but Johns Hopkins is a really good uni, especially for medicine. :)
10:01:05 <dcoutts_> BMeph: I had heard of it :-)
10:01:11 <zachk> @src break
10:01:11 <lambdabot> break p =  span (not . p)
10:01:14 * sw17ch is curious what happens if he moves Language.C.Parser.Lexer from Other Modules to Exposed Modules...
10:01:15 <sw17ch> hmmm
10:01:20 <zachk> @src span
10:01:20 <lambdabot> Source not found. Just try something else.
10:01:28 <dcoutts_> sw17ch: should just work
10:01:33 <sw17ch> i'd think so...
10:01:37 <BMeph> dcoutts_: Okay, because they way you were "talking," it sounded as if you'd *barely* heard of it... ;)
10:01:52 <mmorrow> sw17ch: yeah, it'll do just what you want
10:02:11 <dcoutts_> BMeph: heh, I don't know of many US unis, so it's actually a compliment :-)
10:02:27 * dcoutts_ would move it to Language.C.Lexer
10:02:45 <Eelis> sw17ch: interesting. perhaps i'll send Benedikt a mail requesting this, then :)
10:03:03 <sw17ch> Eelis: i'm looking over the trac page, i know he's mentioned some of this stuff...
10:03:08 <mmorrow> sw17ch: and removing "# hide" from the tops of files which have it'll re-expose those modules to haddock
10:03:09 <BMeph> dcoutts_: Hmm, that sounds like an interesting list, the US unis that you know. :)
10:03:36 <sw17ch> mmorrow, oh, neato... :)
10:03:52 <mmorrow> yeah :)
10:05:27 <Eelis> sw17ch: ah. it doesn't seem there is a ticket for it. shall i open one?
10:05:52 <sw17ch> Eelis: i don't think it would hurt
10:05:52 <pgavin> dcoutts_: ping
10:05:58 <dcoutts_> pgavin: hia
10:06:03 <pgavin> hey
10:06:13 <pgavin> I was just thinking about the opensparc project :)
10:06:31 <pgavin> is there anything I should do?
10:06:43 <dcoutts_> pgavin: no news for you yet.
10:06:59 <dcoutts_> pgavin: We've only been looking at applications since Monday, we're making a short-list.
10:07:17 <pgavin> dcoutts_: ok, cool :)
10:07:32 <dcoutts_> pgavin: so don't worry, it'll be clear if we want you to answer any more Qs etc.
10:07:55 <pgavin> dcoutts_: k :)
10:10:20 <Eelis> sw17ch: (fyi, http://www.sivity.net/projects/language.c/ticket/17 )
10:10:25 <lambdabot> Title: #17 (Expose the lexer in the library API) - language.c - Trac
10:13:25 <Fekalienmann_> lol
10:13:27 <sw17ch> Eelis: you could grab the darcs repo and change the cabal to expose the Lexer your self if you wanted
10:13:40 <Fekalienmann_>  
10:13:47 <Fekalienmann_>  
10:14:04 <Eelis> sw17ch: but then either my users would have to do the same, or i would have to incorporate language.c into my own application. neither are attractive options
10:14:27 <sw17ch> Eelis: you're right, i'm just thinking it would be nice to check if exposing that module is a suitable answer :)
10:14:49 <Eelis> ah :)
10:19:57 <mmorrow> sw17ch, Eelis: here's a dir with a .dot+{pdf,png,svg} graph of the language-c modules http://code.haskell.org/~morrow/language-c/
10:19:58 <lambdabot> Title: Index of /~morrow/language-c
10:20:23 <sw17ch> mmorrow, what marvelous tool built that?!?
10:20:23 <dcoutts_> Eelis, sw17ch: the api of the Lexer is not very helpful directly. It's what happy expects but for a public api you want something nicer.
10:20:36 <sw17ch> dcoutts_: i was just going to point that out...
10:20:46 <dcoutts_> lexC :: (CToken -> P a) -> P a
10:21:21 <sw17ch> yes, unfortunately that's probably the reason he hasn't exposed it yet
10:21:38 <Eelis> i see
10:22:11 <sw17ch> mmorrow, that graph is a little distressing when i realize the part i want to change is Language.C.Data.Position
10:22:17 <sw17ch> :)
10:22:47 <mmorrow> sw17ch: i'm working on a package that's do that with one command to a dir tree. it's a modified haskell-src-exts + some haskell AST manipulating code + a graphviz pprinter. then i run the graphviz 'tred' program on the module dep graph to get the transitive reduction, which actually makes it viewable
10:23:01 <mmorrow> sw17ch: heh
10:23:13 <sw17ch> mmorrow, graphviz is a fun tool to use with haskell...
10:23:27 <sw17ch> mmorrow, i recently did a graph of the collatz conjecture backward with haskell and graphviz
10:23:44 <bos31337> @seen augustss
10:23:44 <lambdabot> I saw augustss leaving #haskell 17h 28m 2s ago, and .
10:23:51 <mmorrow> oh, actually i only picked up .hs files in there , so i guess the lexer mod is missing since the .hs isn't gen in the repo i ran that in
10:24:03 <sw17ch> http://sw17ch.com/code/collatz_15.png
10:24:05 <mmorrow> sw17ch: awesomer
10:24:25 <mmorrow> s/r//, but not because it's not true ;)
10:24:33 <Eelis> is a poset's covering relation the same as the transitive reduction of the poset viewed as a graph?
10:24:34 <hackage> Uploaded to hackage: benchpress 0.2.2.2
10:26:05 <Eelis> appears to be
10:26:08 <mmorrow> Eelis: hmm, that's an interesting thought. I'm not sure.
10:29:12 <sw17ch> How is a partially ordered set different from an ordered one? Is it just an incomplete ordering?
10:29:38 <mmorrow> oh, also i should note that i filtered that graph to only pick up module prefixed by Language.*
10:30:05 <mmorrow> sw17ch: eg the complex numbers
10:30:12 <cadabra> I'm trying to convert a C function to Haskell: http://hpaste.org/10277 I wanted to ask for some general tips on this, and also see if any can see anything particularly wrong about the paste.
10:30:28 <mmorrow> GT | EQ | LT | NotComparable
10:30:32 <sw17ch> mmorrow, good to know on both counts :)
10:30:34 <Eelis> sw17ch: depends on what you mean by "ordered set"
10:30:55 <mmorrow> i took it to mean a set with an ordering
10:31:06 <cadabra> One thing in particular is that in C it's very easy to take a x* and treat it as a y*, whereas reading bytes from a Word32 etc is a bit uglier
10:31:33 <Eelis> mmorrow: but some people use "ordering" to mean "total ordering", while others use it to mean "partial ordering", no?
10:31:35 <sw17ch> cadabra: can you give a 10 word summary of what the function is supposed to do?
10:32:01 <sw17ch> Eelis: i suppose i'm mixing up the words ordering and sorting, but then again... maybe i'm not?
10:32:23 <mmorrow> Eelis: that's true. i agree sometimes it's unclear exactly what's meant when someone says "ordering"
10:32:31 <cadabra> sw17ch: it's an algorithm for expanding an AES key. The first part of the result is just the original key (the memcpy), and the rest is generated
10:32:47 <Eelis> sw17ch: easiest is to just look at the definition: a poset is a set with a reflexive, transitive, antisymmetric relation :)
10:32:59 <cadabra> I wrote it in C, but the teacher let us choose the language, and I'd like to keep learning Haskell.
10:33:48 <sw17ch> cadabra: forgive my ignorance, but what does the expansion of a key do to the key?
10:34:06 <sw17ch> (i'd rather not read through your C too closely...
10:34:07 <sw17ch> )
10:34:15 <Cale> A poset is a small category with at most one arrow between any two objects, in either direction. :)
10:34:15 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:35:15 <bos31337> cadabra: it's trivial to read bytes from a Ptr Word32
10:35:33 * sw17ch hasn't learned Arrows yet...
10:35:33 <cadabra> sw17ch: it takes the key and generates a larger key. The result of key expansion is: [original key] ++ [generated data]
10:36:14 <mmorrow> cadabra: this might help (as an example of the "where go ..." method of doing things): http://hpaste.org/10277#a1
10:36:49 <lilac> sw17ch: an arrow is basically a monad which you can statically analyze. that is, you can find which arrows it's built out of without feeding it any data. this is handy for building parse tables, for instance :)
10:37:10 <sw17ch> lilac, static analysis is always good :)
10:37:11 <cadabra> mmorrow: Thanks, that's a good piece of code to look at
10:37:19 <mmorrow> :)
10:37:48 <lilac> sw17ch: although Cale's talking about arrows between categories, which i'm not certain are the same thing
10:38:08 * sw17ch wishes he could go back to school and take more math
10:38:18 <Cale> arrows between objects in a category
10:38:26 <lilac> Cale: right, sorry :)
10:38:32 <thomashartman1> hey I just uploaded happs-tutorail 0.3 to hackage. could someone try cabal install happs-tutorial for a sanity check?
10:38:34 <Eelis> a.k.a. morphisms
10:38:49 <cadabra> bos: can you point me somewhere?
10:39:01 <lilac> does anyone know of a good resource for learning category theory?
10:39:08 <Cale> If you take a normal poset, you can imagine forming a category whose objects are the elements of the poset, and where there's an arrow f: x -> y whenever x <= y under the poset's ordering.
10:39:27 <Cale> lilac: Let me get you a link :)
10:39:45 <Cale> http://cale.yi.org/autoshare/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
10:39:58 <lambdabot> Title: cache:http://cale.yi.org/autoshare/Category%20Theory%20-%20S.%20Awodey%20(Claren ..., http://tinyurl.com/62ypee
10:40:11 <lilac> thankyou :)
10:40:26 <thomashartman1> I gotta go do an errand but if anyone sees problems with the install please email me at thomashartman1 gmail. otherwise I'm gonna announce in an hour ;)
10:40:33 <Cale> That book is rather good in that it tries to be at least somewhat accessible to nonmathematicians, while developing some of the more important examples internally.
10:41:05 <thomashartman1> and here's a demo --- http://happstutorial.com:5001/
10:41:10 <lambdabot> Title: Index of /
10:41:31 <lilac> Cale: I have an MA in maths, but never did any category theory :-/
10:41:35 <FordCortina> when people refer to indexed types. the values in those type *do not* have to be uniquely determined by the type indexed, do they?
10:41:51 <FordCortina> s/those type/those types
10:43:01 <FordCortina> for instance, its quite easy to make a type of naturals, and each number has its own type
10:43:12 <Myoma> FordCortina: ranging over the index in a family of types
10:43:14 <Myoma> is *
10:43:32 <mapreduce> Is there a monad that works out what is parallelisable and does it in parallel?
10:43:38 <Myoma> data Fin n where
10:43:42 <Myoma>  FZ :: Fin (S n)
10:43:49 <Myoma>  FS :: Fin n -> Fin (S n)
10:44:12 <Myoma> FordCortina: here is an example which has multiple values in each index (except for Fin 0 and Fin 1)
10:46:00 <FordCortina> isnt Fin0 an empty type... given that definition?
10:46:03 <Myoma> yes
10:46:11 <Myoma> Fin 1 ~ (), Fin 2 ~ Bool,
10:46:29 <FordCortina> ah ic
10:46:38 <FordCortina> thanks
10:47:03 <cadabra> What's a close Haskell equivalent for struct Foo{ char foo[3]; }; ?
10:47:16 <Myoma> I'd use (char,char,char)
10:47:24 <thoughtpolice> newtype Foo = F (Char,Char,Char)
10:47:39 <trofi> @hoogle Storable
10:47:39 <lambdabot> module Data.Array.Storable
10:47:39 <lambdabot> module Foreign.Storable
10:47:39 <lambdabot> Foreign.Storable class Storable a
10:47:46 <cadabra> Myoma: but then your code is very bound to 3, and it's hard to change. You can't index through the array.
10:47:49 <Eelis> Cale__: i can't reach that url :(
10:47:54 <Myoma> cadabra: yeah
10:48:18 <Myoma> cadabra: if the 3 was likely to change I'd use a different representation
10:48:54 <cadabra> So let's do struct Foo{ char foo[X]; };
10:49:49 <sw17ch> [Char]?
10:50:04 <sw17ch> data Foo = Foo [Char]
10:50:28 <mmorrow> cadabra: you prob would want to use template-haskell for that type of thing (i'm assuming the X there is essentially a #define)
10:50:47 <Myoma> data Vec a n where
10:50:55 <Myoma>   Nil :: Vec a Z
10:51:05 <Myoma>   Cons :: a -> Vec a n -> Vec a (S n)
10:51:16 <Myoma> Vec Char (S (S (S Z)))
10:51:39 <Cale> grr...
10:52:00 <Cale> lilac: Did you manage to get that book before my connection died?
10:52:07 <_zenon_> Cale, do you know when next Terminator episode will come?
10:52:16 <Cale> _zenon_: I can check...
10:52:56 <Cale> The 16th
10:53:13 <Eelis> Cale: i'm also interested in that pdf, and only got to 50% before it died :)
10:53:20 <Cale> Try now. :)
10:53:31 <lilac> Cale: i have 7% of it :(
10:53:34 <_zenon_> Cale, thanks.
10:54:13 <Myoma> cadabra: And ou can use Fin 3 as a type safe index into it
10:54:21 <Myoma> i.e. can't go out of bounds
10:54:37 <Eelis> Cale: wget hangs during "connecting"
10:54:40 <Cale> hmm
10:54:41 <Cale> okay.
10:55:15 * Cale tries restarting apache.
10:55:42 <Cale> If this doesn't work, I suppose I'll go plug my router in again, rather than plugging into the connection directly.
10:56:28 <Cale> oh!
10:56:39 <Cale> duh, it's possible my IP has changed :)
10:56:52 <Cale> 99.247.247.160
10:57:02 <Eelis> yep, that's different :)
10:57:03 <Cale> (until that DNS record gets updated)
10:57:17 <Eelis> downloading :)
10:57:17 <lilac> success, thanks!
10:57:40 <mmorrow> Myoma: that won't be O(1) though (?)
10:57:53 <Myoma> mmorrow: O(3) :)
10:58:10 <mmorrow> but suppose he want a char[1024]?
10:58:25 <mmorrow> (err, tuples only go to 62 actually... :()
10:58:30 <Myoma> yeah you have to traverse down it, you can't get a single increment and deref
10:59:05 <Myoma> maybe a super advanced compiler could somehow do it ...
10:59:17 <trofi> @hoogle STUArray
10:59:18 <lambdabot> Data.Array.Base data STUArray s i a
10:59:18 <lambdabot> Data.Array.Base STUArray :: i -> i -> Int -> MutableByteArray# s -> STUArray s i a
10:59:18 <lambdabot> Data.Array.ST data STUArray s i a
11:00:24 <Cale> Oh, another one I'd recommend...
11:01:20 <Cale> http://www.math.uchicago.edu/~eugenia/catnotes/categorynotes-cheng.pdf
11:01:27 <lambdabot> Title: CATEGORY THEORY, http://tinyurl.com/28sclm
11:01:55 <Cale> However, that one moves at a fairly brisk pace.
11:02:15 <Cale> (but is rather well self-contained)
11:03:28 <Cale> http://www.youtube.com/user/TheCatsters -- Eugenia Cheng and Simon Willerton have some excellent lectures on category theory online too, if you're unaware :)
11:03:29 <lambdabot> Title: YouTube - TheCatsters's Channel
11:03:45 <Cale> (and hooray, there's a new one today :)
11:03:50 <medfly> oh god
11:06:17 <jpcooper> hello
11:06:25 <jpcooper> could anyone direct me to how to define instances of Read?
11:06:53 <Cale> Well, you define readsPrec, usually ignoring the integer parameter...
11:06:57 <Cale> :t readsPrec
11:06:58 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
11:07:22 <Cale> Which is more or less like defining reads
11:07:24 <Cale> :t reads
11:07:25 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:07:29 <jpcooper> I was wondering what the integer parameter is about
11:07:56 <Cale> It's for when you're printing expressions and want to handle parenthesizing with precedence levels...
11:08:05 <Cale> I don't think any of the built-in instances even use it.
11:08:19 <jpcooper> okay
11:08:23 <jpcooper> so shall I just define a reads?
11:08:29 <Cale> That may work :)
11:08:45 <Cale> I think there might be a default definition for readsPrec (and the others) in terms of reads.
11:09:04 <Cale> But if it doesn't, just change your definition so that it defines readsPrec and ignores the Int parameter.
11:09:33 <jpcooper> I've not done much to do with parsing before. What is the string (a, String) about?
11:09:51 <Botje> the first thing is the thing you parsed, the second is what's laeft
11:09:52 <Botje> -a
11:10:04 <jpcooper> thank you
11:10:16 <Botje> > reads "99 bottles of beer on the wall" :: [(Int, String)]
11:10:17 <lambdabot>   [(99," bottles of beer on the wall")]
11:10:45 <Cale> jpcooper: and it's a list of them so that you can give a list of parses if you want, but most things only give one parse.
11:11:04 <Cale> (read will just take the first one, by default)
11:11:07 <jpcooper> I guess I return [] if it fails
11:11:10 <Cale> yes
11:13:07 <mc__> > reads "1  test 3.4" :: [(Int, String, FLoat )]
11:13:08 <lambdabot>       Not in scope: type constructor or class `FLoat'
11:13:18 <mc__> > reads "1  test 3.4" :: [(Int, String, Float )]
11:13:19 <lambdabot>   Couldn't match expected type `(Int, String, Float)'
11:13:30 <Botje> can't quite do that :)
11:13:58 <mc__> yeah, but it would be cool
11:15:43 <chrisdone> in this function, would a load of tuples be created for every character in the string or would some kind of optimisation fix that? http://hpaste.org/10279
11:16:57 <Cale> chrisdone: You'd have to try it.
11:17:14 <chrisdone> Cale: you mean profile?
11:17:27 <Cale> I mean, check the core
11:17:37 <chrisdone> ah, good point
11:17:45 * chrisdone refers to dons's blog about viewing the core
11:18:16 <Myoma> foldr (\char (spaces,newlines) -> ...) (0,0)
11:18:21 <sw17ch> chrisdone, does that function ever produce anything but (0,0), (1,0), or (0,1)?
11:19:15 <chrisdone> sw17ch: yes
11:19:23 <sw17ch> ah, sorry, i misread part of it
11:19:30 <chrisdone> sw17ch: it counts the number of spaces and new lines
11:20:19 <chrisdone> Myoma: what are you trying to say?
11:20:32 <sw17ch> wouldn't you be better off passing the number of counts to a helper?
11:20:50 <sw17ch> chrisdone, there's no chance of that running well with a long string...
11:21:18 <chrisdone> sw17ch: I'm just asking about the function as it stands
11:21:33 <sw17ch> i think yuo'd end up with a lot of tuples... yes
11:22:02 <Cale> I think it's possible that after strictness analysis, it determines that most of the tuples are unnecessary.
11:22:20 <donri> Cale, how can they be?
11:22:43 <donri> it won't be able to make sense of the tuples until it reaches the end, right
11:22:55 <Cale> donri: You could transform that into a program with a pair of accumulating parameters
11:23:15 <Cale> (strict accumulating parameters)
11:23:24 <Cale> It might be too much to expect though.
11:24:35 <hackage> Uploaded to hackage: happs-tutorial 0.3
11:25:30 <chrisdone> judging from the dump it doesn't optimise out the tuples
11:25:42 <Cale> yeah...
11:26:03 <Cale> It does appear to unbox the integers though...
11:26:18 <sw17ch> chrisdone, http://hpaste.org/10279#a1
11:26:21 <ziman> what was the name of the pastebin that allowed you to run the pasted code?
11:26:37 <chrisdone> http://hpaste.org/10279#a2
11:26:43 <jeffz> ziman: codepad?.
11:26:54 <Cale> sw17ch: now, does strictness analysis catch that? :)
11:26:57 <ziman> jeffz, that's it, thanks
11:27:07 <Cale> (one would hope)
11:27:40 <sw17ch> Cale: i haven't the slightest :)
11:27:49 <sw17ch> i'm by no means a GHC hacker yet :P
11:28:29 <Myoma> How do you get the core?
11:28:31 <Cale> In fact, it appears to.
11:28:35 <Cale> -ddump-simpl
11:29:20 <Cale> It does unboxed Int arithmetic, even.
11:29:25 <sw17ch> Cale: :D
11:29:48 <thoughtpolice> Myoma: there's -ddump-simpl but I prefer ghc-core
11:29:52 <thoughtpolice> since it cleans it up a good bit
11:30:58 <sw17ch> chrisdone, was there a specific reason you used that method?
11:31:05 <chrisdone> no
11:31:36 <Cale> It's unfortunate that GHC doesn't currently find that optimisation.
11:32:13 <sw17ch> Cale: which optimization?
11:32:30 <Cale> sw17ch: The one you applied by hand.
11:32:38 <sw17ch> ah, yes :)
11:33:11 <sw17ch> Cale: i didn't realize that was an optimization... i figured that's how you were supposed to do it :)
11:33:35 <chrisdone> it is how you are supposed to do it
11:33:39 <sw17ch> i'd think that kind of optimization would be really hard to do automatically
11:33:57 <Cale> I think there are some very general methods for doing things like that in the research.
11:34:05 <chrisdone> yeah, I tried to work out that optimisation once
11:34:20 <Cale> The tricky part is more about *when* to apply it.
11:34:25 <FunctorSalad> hmm, no term rewriting system library on hackage? :o
11:34:28 <Myoma> Convert to CPS
11:34:35 <Cale> But GHC has a decent strictness analyser, so it should know.
11:34:39 <Myoma> notice that (x,y) is used as multiple return values
11:35:15 <FunctorSalad> we fail the stereotype (that only mathy/compsciency stuff gets written in haskell)
11:35:55 <Cale> FunctorSalad: What I really want is an implementation of GAP in Haskell :)
11:36:09 <FunctorSalad> Cale: whoa, why not just a binding?
11:36:41 <Cale> Well, maybe a binding would do, if you can find out a way to write one.
11:36:53 <Cale> GAP is a strange programming language, and I'm not sure it exposes things as C functions.
11:37:05 <FunctorSalad> pipe? ;-)
11:37:27 <Cale> But really, GAP could do with a nicer base language.
11:37:51 <Cale> One problem is that GAP doesn't have any support for namespaces.
11:37:55 <FunctorSalad> yeah, I intuitively got the syntax wrong on nearly everything I tried
11:38:07 <chrisdone> > foldr (\c (x,y) -> case c of ' ' -> (x+1,y); '\n' -> (x,y+1); _ -> (x,y)) (0,0) "hello there\ndave"
11:38:08 <lambdabot>   (1,1)
11:38:10 <thoughtpolice> hm, it seems like if you strictify the int parameters in sw17ch's post on hpaste you get even better core with a fold over unboxed integers
11:38:13 <chrisdone> could it ever be optimised into something like the above?
11:38:30 <Cale> You really do have to treat it as a programming language and not an interactive toy for playing with groups if you want to understand how to use it.
11:38:46 * FunctorSalad dislikes learning new syntax (punctuation rules) anyway, hence his support for haskell world domination
11:39:07 <FunctorSalad> ;-)
11:39:10 <Myoma> http://hpaste.org/10279#a4
11:39:26 <Cale> (I failed for a number of years to understand how to use it properly until I started treating it as a programming language, and using the Haskell-way of writing all my definitions into a file.
11:39:55 <FunctorSalad> Cale: hmm, I didn't use it in-depth
11:40:07 <Twey> GAP?
11:40:10 <FunctorSalad> yes
11:40:20 <thoughtpolice> http://hpaste.org/10279#a5
11:40:54 <Cale> http://www.gap-system.org/
11:41:00 <lambdabot> Title: GAP System for Computational Discrete Algebra
11:41:05 <Twey> Oh ah
11:41:05 <thoughtpolice> bang patterns ftw
11:41:08 <FunctorSalad> Cale: it could also use tags for the commands, sometimes they're hard to find
11:41:11 <Twey> That's weird
11:41:20 <chrisdone> Myoma: can you paste your core dump?
11:41:36 <Myoma> I don't have one
11:41:57 <roderyk> Could someone take a look at this: http://hpaste.org/10283 How should I rewrite it to lift the CouchMonad so the Either is actually caught (and ghc doesn't prematurely throw an exception)
11:42:08 <Myoma> if you follow 'k' it is only invoked once
11:42:16 <Myoma> that lets you be sure that (,) only happens once
11:42:36 * chrisdone reads
11:43:18 <chrisdone> very clever!
11:43:52 <FunctorSalad> CouchMonad? :D
11:44:40 <roderyk> FunctorSalad: it's not my api :) But to say the least, I'm a little sketchy on how to apply IOMonads to make it all play nice
11:44:44 <sw17ch> thoughtpolice, wow, that does clean things up
11:44:54 <roderyk> > :t C.runCouchDB'
11:44:54 <roderyk> C.runCouchDB' :: C.CouchMonad a -> IO a
11:44:54 <roderyk> *Main> :t C.newNamedDoc
11:44:55 <roderyk> C.newNamedDoc :: (JSON a) => String -> String -> a -> C.CouchMonad (Either String String)
11:44:55 <lambdabot>   mueval: Prelude.read: no parse
11:45:43 <Cale> roderyk: what do you mean by "the Either is actually caught"?
11:46:12 <chrisdone> Myoma: so it's essentially a nice abstraction on sw17ch's implementation?
11:46:20 <Cale> roderyk: I take it that C.newNamedDoc "testdb" (docID doc) doc :: CouchMonad (Either u v)  for some types u and v?
11:46:33 <Cale> ah, yes
11:46:43 <Cale> So what's wrong with your existing code then?
11:46:49 <Myoma> I haven't look at sw17ch's one
11:47:27 <chrisdone> um, ok..
11:47:28 <Myoma> if you write it as a fold, it seems very simple to pull the tuple to the left of the arguments
11:47:38 <roderyk> Cale: I think the case should be inside of the monad? (Before runCouchDB') ?  As it stands now, I can't catch Left, it just throws an exception
11:48:10 <Cale> roderyk: Then it's not giving Left at all. It's just throwing an exception.
11:48:22 <malouin> Are there any haskell algebra systems (CAS)?
11:48:35 <FunctorSalad> maybe runCouchDB' doesn't like a=Either String String?
11:48:43 <Cale> malouin: The closest thing I can think of is DoCon, but no, not really.
11:49:01 <malouin> Cale: thanks.
11:49:29 <roderyk> Cale: hmm. I know Right works fine. Maybe I misunderstood the api, I understood it was to handle conflicts elegantly
11:50:23 <FunctorSalad> maybe a CouchDb (Left something) just contains an error state and can't be run with runCouch?
11:50:35 <Cale> roderyk: Apparently, that is indeed what the documentation says it should do.
11:50:46 <Cale> roderyk: So if you're getting an exception, then that's something else.
11:51:07 <Myoma> chrisdone: sw17ch uses a left fold (which is much more sensible, but essentially different)
11:51:13 <roderyk> FunctorSalad: that's what I thought. That's why I thought I could somehow sandwich in the case before runCouch (if that makes any sense..)
11:51:23 <Myoma> (To your original)
11:51:27 <Botje> sandwiches .. couches ..
11:51:31 <roderyk> :P
11:51:32 <Botje> am i on the right channel?
11:51:43 <Cale> Apparently for HTTP response code 201, it gives Right x, for code 409 it gives Left e, and otherwise, it throws an exception.
11:51:47 <chrisdone> Myoma: hmm. could his be re-written with foldl?
11:51:52 <FunctorSalad> > let runCouchDB = error "naaaah no stress"
11:51:53 <lambdabot>   mueval: Prelude.read: no parse
11:52:00 <Cale> roderyk: So you're getting some error *other than* a conflict.
11:52:14 <chrisdone> > foldl f [1..3]
11:52:16 <lambdabot>       Overlapping instances for Show ([b] -> [t])
11:52:16 <lambdabot>        arising from a use o...
11:52:26 <Cale> roderyk: Or your server is not behaving in the way that the library expects.
11:52:28 <chrisdone> > foldl f 0 [1..3]
11:52:29 <lambdabot>   Add a type signature
11:52:40 <chrisdone> > foldl f z [a,b,c]
11:52:42 <lambdabot>   f (f (f z a) b) c
11:52:53 <chrisdone> > foldr f z [a,b,c]
11:52:55 <lambdabot>   f a (f b (f c z))
11:52:57 <Cale> roderyk: The exception ought to contain a string with the HTTP response code.
11:52:58 <chrisdone> sometimes I forget
11:53:10 <Myoma> chrisdone: Yes, then you could also pull out the (,) continuation as I did with the foldr to get a foldl'k2
11:53:14 <Cale> chrisdone: foldr is the natural one
11:53:43 <Cale> > foldr (:) [] [1,2,3]
11:53:44 <lambdabot>   [1,2,3]
11:53:50 <roderyk> Cale: ah, I see. the code checks for 409, but I'm getting back 412 Precondition Failed when I try to store a doc a second time
11:53:51 <Cale> > foldl (flip (:)) [] [1,2,3]
11:53:53 <lambdabot>   [3,2,1]
11:54:24 <chrisdone> Myoma:  let me try to write a foldl'k2
11:54:56 <Cale> roderyk: If you want to catch the error, you can wrap your whole do-block in a catch.
11:56:48 <Cale> http://hpaste.org/10283#a1
11:57:10 <Cale> roderyk: ^^ something like that
11:57:28 <Twey> Hey guys, what's up with this?  http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html#elems
11:57:32 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2v3nau
11:57:39 <Twey> elems = toList; toList = toAscList
11:57:43 <Cale> Twey: yeah.
11:57:48 <Cale> Twey: It's a bit silly.
11:57:55 <Twey> Just a little :-\
11:58:01 <Twey> Three synonyms for one function?
11:58:06 <Myoma> :t elems
11:58:07 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
11:58:08 <Myoma> :t toList
11:58:09 <lambdabot> Not in scope: `toList'
11:58:11 <Cale> I guess they wanted to make it guessable?
11:58:11 <Myoma> :t toAscList
11:58:12 <lambdabot> Not in scope: `toAscList'
11:58:16 <Twey> I guess
11:58:23 <Myoma> I don't think they are all the same
11:58:32 <Twey> They are, Myoma
11:58:32 <Cale> Myoma: The code says that they are.
11:58:34 <Twey> Those aren't the ones
11:58:39 <Twey> Read http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html#elems
11:58:40 <Cale> :t Set.elems
11:58:40 <Myoma> but :t says they aren't
11:58:40 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2v3nau
11:58:41 <lambdabot> Couldn't find qualified module.
11:58:43 <Cale> :t Data.Set.elems
11:58:44 <lambdabot> forall a. S.Set a -> [a]
11:58:49 <Cale> :t Data.Set.toList
11:58:50 <lambdabot> forall a. S.Set a -> [a]
11:58:54 <Cale> :t Data.Set.toAscList
11:58:55 <lambdabot> forall a. S.Set a -> [a]
11:59:10 <Cale> See?
11:59:23 * Twey has horrible flashbacks to PHP
12:00:11 <Cale> Nah, in PHP, they would be subtly different and incompatible, while more or less doing the same thing.
12:00:29 <Twey> Heh
12:01:07 <roderyk> Cale: thanks a lot, that works for me
12:01:37 <Cale> roderyk: It's really unfortunate that they didn't think to catch all the rest of the possible errors :)
12:03:43 <roderyk> Cale: I'm going to just test for the specific string and re-throw the exception otherwise. I hope that's not frowned upon :)
12:03:47 <donquach> I'm having an indentation problem.  Can some tell me why the second version in http://hpaste.org/10284 doesn't work?
12:04:29 <Deewiant> donquach: <|> is outside the do, it seems
12:04:32 <Cale> donquach: because you're taking the <|> of the entire do-block
12:04:38 <Cale> and return [c]
12:04:45 <Cale> But c is bound inside the do-block
12:05:24 <Cale> In order for the <|> to be part of the expression containing the inner do-block, it needs to be indented more than it.
12:05:49 <donquach> hmm so I tried aligning <|> with c and the inner do, but that doesn't help
12:05:54 <Cale> You also have the problem that return (c:cs) is not indented enough by one space
12:06:07 <Cale> (it must line up with "cs <- word")
12:06:43 <donquach> oh that was an editing when I copied to hpaste
12:06:46 <Cale> oh, and the inner do-block is overly indented...
12:06:55 <Cale> http://hpaste.org/10284#a1
12:07:38 <Cale> Of course, word is the same as  many1 letter
12:07:45 <bbs> anyone know a good linux version of haskell available in gentoo
12:07:52 <donquach> yeah.. I'm just following the Parsec tutorial
12:08:00 <donquach> rewriting it using Parsec3
12:08:14 <Cale> bbs: I think there's a Haskell overlay for gentoo.
12:08:16 <donquach> but that indentation problem was annoying me .. since I'm a Haskell newbie
12:08:20 <dblazakis> could any explain why scheckOut cannot bind based on the class predicate, but the internal class function, scheck can?  http://hpaste.org/10285
12:08:49 <unmarshal> does anyone know if the source code is available for the paper: Writing High Performance Server Applications in Haskell by Simon Marlow?
12:08:51 <donquach> thanks for the reply, the code compiles now..
12:09:20 <Cale> bbs: But I don't use gentoo myself, not wanting to unduly contribute to the heat-death of the universe ;)
12:09:21 <fnordb> Hi all. Does anyone know what the status on the SDL bindings are. i.e. are they useful? Or in a horrid state of disrepair?
12:09:34 <bbs> Cale: yea -- i'm an exherbousers
12:09:38 <bbs> i love overlays
12:09:44 <bbs> thx
12:10:11 <jeffz> fnordb: I reinstalled them 10 minutes ago and they built fine. tias.
12:10:29 <Cale> fnordb: From what I recall, they work fine.
12:12:11 <Cale> dblazakis: Remove the type signature for scheckOut
12:12:57 <Cale> er, that's interesting :)
12:13:10 <cadabra> I have a stupid syntax question. foo :: Num a => a -> a   .. What's the syntax for adding more than Num to a? like foo :: (Num, Bits) a => or something
12:13:13 <Cale> heh, it doesn't require that class at all of course :)
12:13:31 <Cale> foo :: (Num a, Bits a) => ...
12:14:09 <cadabra> What if there's a second arg 'b' as well?
12:14:33 <Cale> cadabra: Then you can apply whatever classes are required to b, separately.
12:14:37 <Cale> :t (^)
12:14:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:14:43 <Cale> Like that.
12:15:18 <cadabra> Got it. Thanks Cale!
12:15:23 <Cale> No problem :)
12:16:06 <unmarshal> haskell has a great community, you guys should all be very proud
12:16:12 <Cale> :)
12:16:13 <chrisdone> Myoma: so this foldr'k2 generates a big "stack" (bad wording) of applications of cons to each element in the list, sort of nested, and then when we get to [] k HOLY SHIT haha, I was just looking at the code and it just clicked
12:16:28 <unmarshal> i've been moving forward learning nicely thanks to all the great docs and irc logs and all that
12:16:34 <unmarshal> thanks everyone ;)
12:16:47 <unmarshal> the infrastructure is really coming together
12:16:50 <unmarshal> cabal-install is awesome
12:16:51 <Botje> unmarshal: we are utterly failing at not getting popular :]
12:16:52 <Cale> unmarshal: Feel free to ask questions here any time :)
12:17:02 <unmarshal> yeah i won't hesitate
12:17:23 <unmarshal> i'm working on something interesting
12:17:27 <unmarshal> will see how it goes
12:17:34 <unmarshal> but basically a distributed map reduce
12:17:40 <Myoma> good :)
12:17:52 <dcoutts_> unmarshal: I'm glad you like the infrastructure, we've worked pretty hard to get this far and there's quite a way to go yet
12:17:59 <unmarshal> i'm constantly amazed by how clean everything feels
12:18:08 <unmarshal> when i code in oop languages, sometimes it just doesn't feel right
12:18:15 <unmarshal> and i don't get that dreary feeling often coding haskell
12:18:40 <Myoma> unmarshal: yeah but I can type for(i = 0; i < length; i++) { 100x a min
12:18:47 <Myoma> unmarshal: You wont learn that from using haskell :p
12:18:48 <Cale> Myoma: hehe
12:18:51 <unmarshal> infrastructure is super important
12:19:04 <unmarshal> i don't see haskell being the next java or anything
12:19:13 <unmarshal> but i think it will definitely have a place for hard problems solved in elegant ways
12:19:33 <unmarshal> anyway, i'm excited :)
12:19:46 <Cale> unmarshal: I certainly hope it's not the next Java, but at present I have no financial interest in using Haskell for work :)
12:19:49 <unmarshal> i've been working on it for about a year, took a 4-5 month break and now everything feels to have clicked
12:19:52 <Twey> Of course it won't be the next Java, it requires thought :)
12:20:12 <unmarshal> taking breaks can be good for the mind
12:20:19 <Cale> Java requires more thought in some ways, but lets you get away with writing bad programs more often. :)
12:20:20 <Twey> Same happened to me, unmarshal
12:20:28 <Myoma> not requiring thought would be an excellent thin for a language
12:20:34 <unmarshal> monad transformers and all that gave me problems a while back
12:20:37 <unmarshal> and now it's like nothin'
12:20:47 <unmarshal> i still haven't grokked all the type system features
12:20:49 <unmarshal> gadts etc
12:20:52 <unmarshal> don't know when to use them, etc.
12:20:58 <unmarshal> but i can write useful programs now
12:21:06 <unmarshal> so next step will be doing them the haskell way
12:21:17 <unmarshal> so anyway
12:21:21 <unmarshal> mad props to all of you
12:21:22 <Myoma> oh don't touch GADTs
12:21:29 <unmarshal> yeah?
12:21:29 <Myoma> You wont be able to stop once you do
12:21:31 <unmarshal> hehe
12:21:36 <Cale> unmarshal: The same I find is true while writing Haskell code (taking breaks)... the nice thing about Haskell is that I can get a useful amount done in the amount of code that fits in my short term memory.
12:21:42 <Cale> (and visual memory, even)
12:21:45 <unmarshal> Cale: absolutely
12:21:56 <unmarshal> Cale: i can come back to code i've written months later and pick up where i left off
12:21:59 <Cale> So I can leave the computer and still be working, which is nice :)
12:22:00 <unmarshal> not the same for bloated oop architectures
12:22:25 <unmarshal> i find reading other people's haskell code much more straight forward than other languages as well
12:22:37 <unmarshal> i think that's one of the huge advantages of the functional style
12:22:50 <unmarshal> bottom up reading
12:22:56 <Myoma> You aren't reading hard enough code :p
12:23:02 <unmarshal> probably :)
12:23:22 <Deewiant> I recommend Oleg's
12:23:30 <cadabra> I'm not sure I understand the compiler message for the following: bytesToBits :: (Integral a, Num a, Bits a) => [Byte] -> a
12:23:30 <cadabra> bytesToBits bs = let sz = bitSize (undefined::a) in 0
12:24:07 <cadabra> Ambiguous type variable `a' in constraint `Bits a' arising from use of bitSize
12:24:09 <unmarshal> anyway, i've still a long way to go, but it's starting to gel nicely
12:24:14 <unmarshal> thanks again :)
12:28:09 <Myoma> @faramer
12:28:09 <lambdabot> I'm not going to get side tracked onto a tangent.
12:28:11 <Myoma> @faramer
12:28:11 <lambdabot> They're very far and few between.
12:28:14 <Myoma> @faramer
12:28:14 <lambdabot> It's a travesty on the face of the void.
12:28:24 <Myoma> heh
12:28:25 <Botje> @protontorpedo
12:28:25 <lambdabot> are you wealthy concultants?
12:28:35 <Myoma> @w80 concultant
12:28:37 <lambdabot> No match for "concultant".
12:28:40 <Botje> some of us are. not all of us, unfortunately.
12:33:25 <Twey> Hmn, how do I make this not overflow? http://hpaste.org/10279#a7
12:38:42 <newsham> ?go 200km/h in miles per hour
12:38:54 <lambdabot> http://www.shc-forum.com/viewtopic.php?p=1872109&sid=a07bc46ab1e43c38201bcaf3eba59916
12:38:59 <newsham> why doesnt that work anymore?
12:39:09 <medfly> ?go 200 km per hour in miles per hour
12:39:11 <lambdabot> http://solar-center.stanford.edu/FAQ/Qsolsysspeed.html
12:39:11 <lambdabot> Title: Stanford SOLAR Center -- Ask A Solar Physicist FAQs - Answer
12:39:20 <medfly> maybe it has a google suggestions things
12:39:29 <newsham> that used to work
12:40:58 <medfly> i think its 125 miles per hour
12:41:11 <newsham> i know the answer (google gives it, btw)
12:41:19 <newsham> just wanting to know why this is broken
12:41:23 <medfly> am i right? :o
12:41:32 <newsham> aproximately
12:41:41 <newsham> 200 (kilometers / hr) = 124.274238 miles per hour
12:41:52 <medfly> hehe neat
12:49:45 <dons> ?users
12:49:45 <lambdabot> Maximum users seen in #haskell: 504, currently: 491 (97.4%), active: 18 (3.7%)
12:50:16 <Twey> Overflow-fixing?  Anybody?  http://hpaste.org/10279#a7
12:50:24 <dons> stack?
12:50:28 <Twey> Yeah
12:50:34 <Twey> I've tried adding some $!s in obvious places, but I think there's some hidden laziness...
12:50:39 <dons> insertWith' ?
12:50:45 <dons> could be the adjust is lazy in the map.
12:50:55 <dons> oh, yolu're building a big function eh?
12:51:10 <Twey> Erm, seems so
12:51:11 <dons> the toList fromList looks expensive
12:51:29 <Twey> No, it isn't (well, possibly, but it probably won't be called on a big set)
12:51:36 <Twey> It's the string length that's getting me
12:52:05 <int-e> Map.adjust (+1) c ... looks dangerous
12:52:26 <Twey> Yeah, I'm thinking it's probably there, but there's no adjust'...
12:52:46 <sw17ch> just a random question, has there been any work with GHC and VxWorks?
12:54:24 <CosmicRay> is anyone aware of a function anywhere, String -> [String], that will take plain ASCII text and wrap it so that lines don't exceed a certain length?
12:54:34 <int-e> Twey: adjust' f k m = case Map.lookup k m of Just a -> let a' = f a in a' `seq` Map.insert k a' m; Nothing -> m
12:54:35 <CosmicRay> wrap it on word boundries, that is
12:54:39 <int-e> Twey: or something like that
12:54:48 <dons> CosmicRay: ooh.
12:54:54 <Twey> int-e: Ah, thanks
12:55:02 <dons> we *should* have a lib for that, if there isn't one.
12:55:12 <CosmicRay> dons: just what I'm thinking, indeed ;-)
12:55:13 <dons> isn't there a tex/knuth word wrapping package?
12:55:18 <CosmicRay> hrm.
12:55:21 <dons> i've definitely seen something in this area.
12:55:34 <Heffalump> isn't it a fairly short bit of code starting from unwords?
12:55:36 <CosmicRay> I'm not sure that tex would be what I'm after.  this is just plain text, not typesetting
12:55:43 <CosmicRay> Heffalump: beware the corner cases
12:55:43 <Heffalump> If you want proper paragraph formatting, that's more effort.
12:55:45 <dons> well it was the tex algorithm
12:55:53 <dons> if i can find the package..
12:55:56 <Heffalump> what corner cases?
12:56:02 <CosmicRay> dons: incidentally, did you see my json email?
12:56:13 <dons> CosmicRay: yeah. just got back from business travel
12:56:20 <dons> so will get to all my outstanding mails
12:56:37 <dons> CosmicRay: hopefully we'll have opensource@galois.com set up soon for all open source queries, too, btw
12:56:40 <CosmicRay> Heffalump: well, is a hyphen a word separator?  If so, if you wrap there, the hyphen goes on the end of the line.  what about words that are longer than the line width.  that sort of stuff
12:56:43 <dons> and a big new set of libs are close to being released.
12:57:15 <CosmicRay> Heffalump: is a tab a word separator?  A period?  A period probably is if it's after a letter, not if it's after a number.
12:57:18 <CosmicRay> all that sort of stuff.
12:57:26 <CosmicRay> actually if it's between numbers, it probably isn't.
12:57:33 <CosmicRay> see, it's more complex than you might think
12:57:38 <Heffalump> I would just use isSpace.
12:57:42 <dcoutts> CosmicRay: there's a function in Cabal that does that for error messages
12:57:47 <CosmicRay> maybe I should just pipe through fmt
12:57:53 <CosmicRay> dcoutts: ooo, sweetness
12:57:56 <dons> hmm maybe its not on hackage.
12:58:06 <dons> i've definitely seen someone implement a tex paragraph wrapping library
12:58:24 <Heffalump> A period isn't a word separator since if it was at the end of a sentence you'd have a space after it.
12:58:25 <dcoutts> dons: that's a good deal more sophisticated
12:58:36 <dons> eyeah
12:58:51 <CosmicRay> Heffalump: but a hyphen?
12:58:54 <dcoutts> CosmicRay: it's just a greedy algorithm, still it's handy
12:59:02 <Heffalump> I wouldn't break on them.
12:59:03 <CosmicRay> dcoutts: that is good enough for me.
12:59:06 <Heffalump> As I said, I'd just use isSpace.
12:59:17 <CosmicRay> dcoutts: I'm just displaying twitter updates here.
12:59:30 <dcoutts> CosmicRay: see wrapText in Distribution/Simple/Utils.hs
12:59:38 <CosmicRay> THANKS!
12:59:40 <CosmicRay> argh, meeting.
13:00:34 <dcoutts> CosmicRay: I've got another version elsewhere with a configurable first line offset
13:00:55 <dons> maybe the wrapping stuff should be in a little text package?
13:01:04 <Twey> int-e: Awesome, that fixes it :)  Thanks!
13:01:28 <dcoutts> dons: or at least on a wiki page, it's only 20 lines of code
13:03:22 <int-e> Twey: nice :)
13:04:01 <dons> dcoutts: code reuse, man, reuse
13:04:36 <dcoutts> dons: though often it has to be reused a few times in a few contexts before it becomes clear what the general useful form is
13:05:27 <heatsink> Will ghc unbox strict Int and Float fields if I don't use {-# UNPACK #-} or -funbox-strict-fields?
13:06:13 * heatsink hopes the answer is yes
13:06:30 <olsner> why does ghc even need an option to unbox strict fields? shouldn't that always be faster than boxing them?
13:07:27 <heatsink> olsner, it can be slower if the code needs to re-box the field before using it.
13:07:43 <heatsink> For example, if you extract the field and then pass it to a polymorphic function.
13:08:47 <dons> heatsink: no.
13:08:56 <dons> fields in the data structure will be boxed.
13:08:57 <heatsink> ok
13:09:03 <dons> so use {-# UNPACK #-}
13:09:12 <dons> if you want to reliably do it (which is yes)
13:09:49 <dons> dcoutts: we need to write an optimisation, and a paper, on reliably unboxing atomic/strict data types inside polymorphic structures :)
13:10:08 <dcoutts> mm
13:10:12 <dons> so my strict [] Double becoms [] | Cons Double# ([a])
13:10:19 <dcoutts> right
13:10:25 <dcoutts> newtypes ftw!
13:10:29 <dons> it'd be a killer optimisation
13:10:32 <dcoutts> that's what I think anyway
13:11:39 <dcoutts> newtype MyDoubleList = MyDoubleList {-# !!!?! #-} [Double]
13:11:44 <dcoutts> or something like that
13:12:08 <Botje> swearing at GHC is not a good plan of action. it is capable of holding grudges.
13:12:15 <dcoutts> the point being that a newtype boundary is a good place to allow for a (derived) representation change
13:12:53 <dcoutts> Botje: actually it's a polite request to unbox things
13:13:52 <Botje> :)
13:24:35 <hackage> Uploaded to hackage: graphmod 1.1.1
13:24:35 <hackage> Uploaded to hackage: mime 0.2.1
13:42:21 <thoughtpolice> olsner: it can cause some slowdowns in the case that certain values need to be reboxed
13:42:26 <thoughtpolice> the manual addresses it
13:42:36 <thoughtpolice> but it's up to debate whether it's worth it to always have it on
13:44:40 <dons> that's rare, the reboxing.
13:44:54 <roderyk> I get an internal error when running my program via "ghc --make" but not in ghci >> main. Any suggestions on trace/debug flags so I can get a little more info out of ghc? ghc doesn't give me much by default:
13:44:58 <roderyk> internal error: task 0x153dc60: main thread 1 has been GC'd (GHC version 6.8.2 for x86_64_unknown_linux)
13:47:28 <Twey> roderyk: I think that means that your main thread has finished before your other thread(s), but I'm not too sure...
13:47:46 <Heffalump> no, it'd exit if that happened
13:48:06 <Twey> Hmn
13:49:14 <dons> ?users
13:49:14 <lambdabot> Maximum users seen in #haskell: 504, currently: 483 (95.8%), active: 18 (3.7%)
13:56:14 <Saizan> roderyk: what if you compile with -threaded ?
14:02:27 <roderyk> Saizan: that works, thanks
14:02:43 <laz0r> can i create type synonyms that i can use in the context declaration of a function?
14:02:51 <roderyk> is there any reason why -threaded is not default?
14:04:05 <laz0r> for example: type Foo c = (Ord c,Enum c) and then use that like this: bar :: Foo c => [c] -> c...
14:04:33 <Saizan> laz0r: no, (Ord c, Enum c) is not a type
14:05:03 <Saizan> you want class aliases, but there's no implementation of them
14:05:14 <laz0r> ok
14:10:42 <CosmicRay> roderyk: -threaded is not supported on all platforms
14:11:04 <CosmicRay> roderyk: it is supported on almost all of them by popularity, or almost none of them by quantity.  look at it how you wish. ;-)
14:11:17 <sjanssen> roderyk: -threaded also has interesting implications with forking and such
14:11:29 <sjanssen> forking of processes, to be specific
14:12:00 * araujo wonders if he could ask for suggestions in here
14:12:01 <roderyk> good to keep in mind for the future
14:12:29 <CosmicRay> araujo: of course
14:12:36 <araujo> CosmicRay, :-) , hi there
14:12:56 <araujo> I will paste the questions here, it's a haskell app, so I guess there is no problem :-P
14:13:20 <araujo> I am writing an app that requires to run privileged operations
14:13:24 <araujo> <araujo> Though I still have two approaches at hand ... any suggestion:
14:13:24 <araujo> <araujo> 1) Add the user to a specific group to run such a privileged operations.
14:13:24 <araujo> <araujo> 2) Ask the privileged user password every time to run such an operations
14:13:24 <araujo> <araujo> any suggestion?
14:13:42 <CosmicRay> I'm not quite getting the haskell angle there
14:13:48 <CosmicRay> are these unix questions?
14:14:01 <CosmicRay> I'm happy to answer if so ;-)
14:14:03 <araujo> CosmicRay, oh, yeah ... indeed .. it's just a haskell app
14:14:06 <CosmicRay> ah ok
14:14:08 <araujo> :-]
14:14:11 <CosmicRay> for #2, look at manpages for su and sudo
14:14:15 <CosmicRay> probably sudo
14:14:31 <CosmicRay> for #1, you'll need to edit /etc/group or whatever file your system is using.  see vigr
14:14:32 <zachk> just run as root on a machine that doesnt have a network connection
14:14:37 <araujo> CosmicRay, yeah, #2 is with sudo ... I know how to implement both ... I am just not sure which one is better
14:14:44 * CosmicRay thwacks zachk
14:14:53 <CosmicRay> araujo: well, it depends on your needs.
14:15:08 <CosmicRay> araujo: giving them a password to a different account lets them su to it and do anything.
14:15:22 <CosmicRay> araujo: with sudo they can use their own password to do a (potentially) limited set of actions.
14:15:30 <araujo> CosmicRay, I see
14:15:40 <CosmicRay> generally sudo is preferred because of limiting the actions
14:15:47 <CosmicRay> but there are instances where su makes more sense
14:16:15 <davidL> why not setuid root and drop privileges afterwards?
14:16:27 <araujo> CosmicRay, well, I am trying to see the advantages of both from an application development perspective ... I am adding such a support for himerge , in case you know it
14:16:41 <CosmicRay> I was just reading your webpage on it now.
14:16:53 <CosmicRay> araujo: in that case, you will probably want to use one of the gui tools to gain root privs, right?
14:16:58 <CosmicRay> there is a gnomesu or gnomesudo or something
14:17:03 <CosmicRay> whatever the other gnome apps use
14:17:04 <CosmicRay> use it
14:17:05 <araujo> davidL, yeah .. that plus adding the user to a group is what I have in mind
14:17:23 <CosmicRay> on debian, adduser is a way to add a user to a group.  dunno if gentoo has such automation.
14:17:29 <CosmicRay> why do you need to add a user to a group?
14:17:40 <araujo> CosmicRay, well, it's how it works right now ... but.. some people seems willing to have only haskell code running :-)
14:17:50 <araujo> CosmicRay, yes we have
14:18:12 <araujo> CosmicRay, so we can control who run such a privileged operations ...
14:18:30 <araujo> Instead of using sudo
14:21:26 <zachk> > let a=[1..3] in filter ( \x->head x=/(head $ tail x) ) $ sequence a a
14:21:27 <lambdabot>   mueval: Prelude.read: no parse
14:21:44 <zachk> > sequence a a
14:21:45 <lambdabot>   Couldn't match expected type `[m a]' against inferred type `Expr'
14:21:51 <zachk> >sequence [1..3] [1..3]
14:22:06 <zachk> > sequence [1..3] [1..3]
14:22:07 <lambdabot>       No instance for (Enum ([t] -> a))
14:22:07 <lambdabot>        arising from the arithmetic se...
14:22:14 <trofi> :t sequence
14:22:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:22:54 <trofi> > sequence [Just 1, Nothing, Just 2]
14:22:56 <lambdabot>   Nothing
14:23:06 <trofi> > sequence [Just 1, Just 3, Just 2]
14:23:07 <lambdabot>   Just [1,3,2]
14:23:48 <zachk> > let a=[1..3] in filter ( \x->head x/=head $ tail x) $ sequence [a,a]
14:23:49 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
14:24:09 <zachk> > let a=[1..3] in filter ( \x->head x/=head $ tail x) (sequence [a,a])
14:24:10 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
14:24:36 <hackage> Uploaded to hackage: n-m 0.0.1
14:24:56 <zachk> > let a=[1..3] in filter ( \x->head x/=head (tail x))  (sequence [a,a])
14:24:58 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
14:25:01 <bos> @seen ketil
14:25:02 <lambdabot> ketil is in #haskell. I last heard ketil speak 2h 37m 38s ago.
14:26:16 <zachk> @seen zachk
14:26:16 <lambdabot> You are in #haskell. I last heard you speak just now.
14:26:23 <zachk> dang it
14:28:12 <zachk> > let a=[1..3] in sort $ map sort filter ( \x->head x/=head  (tail x))  (sequence [a,a])
14:28:13 <lambdabot>   Couldn't match expected type `[[a]]'
14:30:41 <CosmicRay> dcoutts: I am not entirely certain how wrapText should work from reading the api docs
14:30:48 <CosmicRay> I tried wrapText 40 ["", "asdf asdf asdfasflkjh saflhkj sdaflkjh afsdlkjh fasdkljh aasdflkjh fadslkjh flasfdkjh fasdkljh afdslkjh afsdaklhj afds"]
14:30:53 <CosmicRay> dcoutts: it didn't wrap anything
14:37:36 <geezusfreeek> there are some good ideas here: http://www.haskell.org/pipermail/haskell/2004-February/013617.html
14:37:38 <lambdabot> Title: [Haskell] Haddock, QuickCheck, and Functional Design by Contract, http://tinyurl.com/3nj3d4
14:38:17 <geezusfreeek> i haven't seen anything that automates any of this kind of stuff though, yet, so i guess the idea was abandoned
14:38:57 <geezusfreeek> i just thought i would ping the channel with it in case anybody is interested
14:39:22 <zachk> > let a=3 in  nub $ sort $ map sort $ filter (\x->head x/=head (tail x)) (sequence [[1..a],[1..a]])
14:39:24 <lambdabot>   [[1,2],[1,3],[2,3]]
14:41:21 <gutworth> does haskell provide a hashtable?
14:41:29 <Cale> gutworth: Use Data.Map
14:41:32 <unmarshal> Data.Map is what you're looking for
14:41:37 <gutworth> neat
14:41:57 <Cale> Avoid Data.Hashtable, since it's in basically all cases slower than Data.Map, doesn't scale as well, and requires IO.
14:42:25 <Cale> (It's only there for historical reasons)
14:42:37 <geezusfreeek> i never looked into exactly why it is that we don't have good hash functions
14:42:46 <geezusfreeek> any takers for that question?
14:43:29 <Cale> Good hash functions are hard to come up with, hard to prove anything about, and hashtables don't provide much practical advantage over balanced trees.
14:44:12 <geezusfreeek> even for very large maps?
14:44:23 <Cale> Seemingly especially for very large maps.
14:44:46 <geezusfreeek> i find that suspicious
14:45:07 <Cale> As the map gets large, you start having trouble with collisions.
14:45:36 <gutworth> I suppose it depends a lot on the quality of your hash function
14:46:11 <geezusfreeek> it's just a time/space tradeoff though, no? large maps need large tables to avoid too many collisions
14:47:18 <Cale> Well, you can introduce resizing...
14:47:38 <Cale> But you have to come up with new hash functions which are also good.
14:48:24 <dons> compressed patricia tries forever!
14:48:34 <Cale> I suppose if you fix an upper bound on the sizes that you care about, you can invent a fixed number of hash functions that you experimentally verify to be good.
14:48:38 <dons> no more hash functions!
14:49:00 <geezusfreeek> and there are also interesting variants like cuckoo hash tables which have constant time lookups in worst case
14:49:12 <Cale> That's a lie ;)
14:49:18 <geezusfreeek> orly?
14:49:34 <geezusfreeek> inserts, of course, can take a while
14:49:45 <Cale> Unless the size of the table is bounded, then yes.
14:49:47 <Cale> Any unbounded datastructure which claims to have constant time lookups is a lie.
14:50:04 <Cale> (you're ignoring a log factor somewhere)
14:50:59 <geezusfreeek> it's constant time because there is a guarantee that what you are looking for is in one of only two locations in the table
14:51:14 <geezusfreeek> both indexed by slightly different hash functions
14:51:17 <Cale> The fixed-size table?
14:51:36 <geezusfreeek> the table may grow with inserts, and when it does it's bad
14:51:46 <geezusfreeek> http://en.wikipedia.org/wiki/Cuckoo_hashing
14:51:47 <lambdabot> Title: Cuckoo hashing - Wikipedia, the free encyclopedia
14:52:51 <Cale> People really like to ignore the log factor associated with larger addresses (simply because people only have finite amounts of memory), but the factor is still there.
14:53:46 <Cale> Pointer indirection costs more, the longer that addresses get. So even arrays can't really have constant time lookup.
14:54:16 <Cale> Of course, you can make the assumption that n is bounded, but then in some sense everything is O(1) :)
14:54:39 <Cale> So people like to ignore log factors, which is fine, but if you do it, I think you should do it consistently :)
14:55:00 <geezusfreeek> well it's a matter of deciding what the significant operations to measure are
14:55:40 <geezusfreeek> if i am counting pointer indirections, then the cost of each pointer indirection is not so important toward time complexity
14:56:48 <mattam> Cale: why does it take longer, because of page faults or just the plain "the msb is higher" ?
14:57:05 <Cale> mattam: Because the addresses are longer, so they take more time to process.
14:57:51 <mattam> By adresses you mean integers that map to main memory locations right?
14:57:55 <Cale> yes.
14:58:20 <geezusfreeek> mattam: virtual memory systems use trees to map virtual addresses to physical addresses
14:58:21 <mattam> So you're counting the fact that the arithmetical unit takes longer on larger numbers?
14:58:26 <geezusfreeek> and longer virtual address mean larger tables
14:58:40 <Cale> mattam: In our machine with infinite memory, yes :)
14:59:00 <geezusfreeek> *deeper trees
14:59:25 <mattam> Alright, I'm remembering now.
14:59:28 <Cale> Asymptotic complexity has the unfortunate property that it trivialises on machines with finite memory.
14:59:50 <mattam> I wonder if it's been quantified.
15:00:08 <luite> if you'd count those things, trees would also need an extra log factor, right?
15:00:08 <geezusfreeek> Cale: i consider that property to be fortunate for my brain
15:01:01 <geezusfreeek> luite: i think Cale is just being pedantic ;)
15:01:05 <Cale> luite: right.
15:01:26 <FunctorSalad> I guess the idea is that under the (non-physical) assumption of constant-time steps, the hashtable is O(1)... this gives you some idea of what a hashtable does
15:01:40 <FunctorSalad> just another abstraction
15:01:49 <Cale> It's just that people already use the fact that n is at most 2^32, so log_2(n) is about 32, and then absorb that into their constant factor.
15:01:54 <Cale> So why not do it again?
15:02:09 <geezusfreeek> you do have a point
15:03:03 <geezusfreeek> but i think the difference is that with pointer lengths you're only going to have the scaling problems over generations of hardware, but with trees vs. hash tables you're going to run into them even on the same hardware
15:03:15 <Cale> But really you're not.
15:03:32 <Cale> Not likely anyway...
15:03:48 <Cale> That log factor is at most 32 still, which can still be quite reasonable, depending.
15:04:14 <geezusfreeek> it depends how complex your comparison operation is
15:04:16 <Cale> (in fact, it's very unlikely that it's even as large as 32)
15:04:36 <geezusfreeek> and how often you do lookups and inserts
15:04:59 <geezusfreeek> but i still concede that you have a point about just considering that to be constant time
15:05:05 <geezusfreeek> 32 is not very large
15:05:09 <Cale> I've found balanced trees to compete very favourably with hashtables in all the practical situations I've run into.
15:05:19 <dons> Cale, agreed.
15:05:32 <dons> i'm working on a bytestring trie atm, actually
15:05:52 <dons> some initial benchmarks look fairly promising (certainly outperforming bytestring hashtables for dictionary use)
15:06:01 <dons> lookup gets a lot cheaper.
15:06:18 <dons> no stupid hash function+collision+lists to traverse, just check the prefix and exit early.
15:06:54 <bos> my bloom filter code is essentially a hash table, and has worked out wonderfully in practice.
15:06:55 <dons> but, benchmarks first. then we can take over the world with smarter data structures
15:07:00 <geezusfreeek> oh i wasn't thinking about that either, early exit comparisons
15:07:25 <bos> we can index the entire human genome in a few minutes, using just a few hundred megs of memory.
15:07:31 <dons> sweet.
15:07:37 <dons> bos, did you get the paper in?
15:07:44 <bos> submitting it in a few minutes.
15:07:48 <dons> go go go!
15:07:53 <geezusfreeek> nice!
15:08:32 <Cale> Another way to think about it is how good of a hash function can you invent which takes less time than 32 memory indirections?
15:08:46 <bos> we can filter for e.g. E. coli contamination far faster than traditional methods, all in 75 lines of haskell.
15:08:57 <geezusfreeek> *32 memory indirections + 32 comparisons
15:09:00 <Cale> It's possible that there's something decent, sure, but it's certainly not obviously better :)
15:09:36 <Cale> right...
15:09:43 <geezusfreeek> it depends on how easily the data structures we are comparing hash
15:09:52 <dons> bos, do you look at parallelisation?
15:09:59 <geezusfreeek> and whether we could benefit from early exit, as dons said
15:10:02 <Cale> Right, and how much of them you need to look at in order to get a good hash
15:10:10 <bos> dons: got preoccupied with writing the paper.
15:10:11 <dons> right, if you have to has the entire string
15:10:18 <dons> bos, so that's future work?
15:10:31 <bos> dons: parallelisation was pretty tricky at least early on, because we were doing too much allocation in the inner loop.
15:10:36 * dons imagines scalable, high perf bloom filter search is a killer app
15:10:56 <Cale> (comparisons can usually be made on the basis of a small part of the data, good hashes usually can't, almost by definition)
15:11:19 <dons> Cale, "the cult of the hash function" we should name this meme for what it is
15:11:36 <Cale> Since, if, say, your hash function only looks at the first 5 characters of a string to get a hash, then all strings having those 5 initial characters will collide.
15:11:48 <bos> dons: yes, definitely.
15:12:03 <bos> dons: my guesstimate is that it will take a day or two to get good parallel scaling.
15:14:56 <bos> ok, it's in.
15:24:36 <hackage> Uploaded to hackage: download-curl 0.1.1
15:25:10 <Cale> I wonder if we can actually prove that if a hash function (for an algebraic datatype) is actually good in the sense that for any structural prefix of size k, the probability that two pieces of data which share that prefix hash to the same thing is not 1, then the function takes at least O(log n) time to compute. (In fact, it feels like it ought to take O(n) time.)
15:25:32 <Cale> er, I switched between k and n there.
15:25:40 <Cale> s/k/n/ :)
15:25:42 <bos> Cale: you can, yes.
15:26:11 <bos> most hash functions have terrible mixing properties.
15:27:17 <bos> here's a useful page: http://home.comcast.net/~bretm/hash/7.html
15:27:18 <lambdabot> Title: Pluto Scarab — Evaluation of Bob Jenkins' Hash
15:27:43 <bos> that's the hash function we use for gene filtering. for other hash functions, you can see analyses on nearby pages.
15:28:36 * edwardk waves hello.
15:28:55 <Saizan> hi edwardk :)
15:28:59 <edwardk> how goes?
15:29:00 <bos> hi edwardk. moved jobs yet?
15:29:05 <edwardk> bos: decided to stay
15:29:24 <Cale> What I'm really interested in though is whether we might be able to use a theorem like that to show that in general, hashtables are at least as expensive as using trees.
15:29:35 <Cale> (at least for representing sets)
15:31:43 <Cale> This would be because computing a good hash must be expensive enough to distinguish an element from all the others (at least probabilistically), and so it's at least as bad as any set of (say lexicographic) comparisons one might have to do.
15:32:33 <Cale> (at least, that's my conjecture :)
15:35:51 <Cale> It might need some tweaking and refinement to ensure that it's actually true.
15:35:55 <Cale> :)
15:37:45 <bos> that would be interesting. an offal lot of people seem to think that hashtables have magical linear performance pixie dust.
15:37:59 <dejones> http://hpaste.org/10289
15:38:26 <dejones> Can anyone help me out with linker errors when compiling 'Hello World' for Haskell OpenGL / GLUT...?
15:38:27 <dejones> :)
15:38:31 <bos> dejones: you don't have libglut installed.
15:38:44 <DrSyzygy> Yo bos! Thanks for the talk yesterday.
15:39:02 <bos> cheers.
15:39:27 <dejones> bos: Odd, I installed glutg3-dev debian package, but you are right, there is a libglut3-dev too!
15:39:30 <dejones> bos: thanks.
15:39:31 <dejones> :)
15:39:49 <dibblego> data Parser in a e = Parser (in -> Either e (a, in)) -- is this the essence of a Parsec parser?
15:41:04 <dejones> bos: That didn't fix it.  :(
15:41:14 <bos> dejones: huh.
15:41:47 <dejones> bos: Quite odd.  :(
15:42:10 <luite> Cale: but the comparisons would probably be bad for pipelined processors when branches are unpredictable. the hash function would probably be mostly 1-clocktick operations without many branches
15:43:03 <Cale> Suppose you have a hashtable representing a set of n elements. In order to have n distinct elements, those elements have to (at least on average) have log n bits. In order to not have too many collisions then, the hash function must be looking at on the order of log n bits of its input. This means that the hash function is taking log n time to compute. Done.
15:43:07 <bos> luite: hashes are chock full of data dependencies.
15:43:42 <TomMD> md6 is an odd one though.
15:43:46 <Cale> At least, I'm happy with that argument :)
15:43:53 <bos> so you get no meaningful pipelining, unless you're performing a big parallel cryptographic hash.
15:44:26 <DrSyzygy> By the way, that was something I didn't understand with your project: Why grab a hash from the cryptographic world?
15:44:41 <TSC> dejones: Are you on debian?  Maybe you want freeglut3-* instead of libglut*
15:44:49 <bos> DrSyzygy: it's not a cryptographic hash.
15:44:49 <DrSyzygy> If you're hashing for a hashtable, then the impossibility to invert the hashfunction doesn't sound like what you REALLY need...
15:44:53 <DrSyzygy> Good.
15:45:00 <DrSyzygy> I somehow got that impression from the talk...
15:45:26 <bos> no, it's a high-quality hash without the bad diffusion properties that most hand-cooked hashes have.
15:45:34 <DrSyzygy> Right.
15:45:56 <Cale> So, at the very least, I think it's safe to claim that hashtable lookups are O(log n) under the same assumptions that people normally use to claim that they're constant time (ignoring the cost of their hash function).
15:49:05 <mmorrow> trie lookup of strings otoh is O(l), where l is the length of the longest string :)
15:49:09 <Cale> right
15:49:21 <Cale> And the best case times are even nicer :)
15:49:34 <mmorrow> indeedy and most speedy!
15:49:47 <Cale> Because you always have to compute your hash, and so you're paying up front every time.
15:49:57 <loop> mmorrow, if child lookup is constant time?
15:50:00 <luite> mmorrow: are they? you'd need the same pointer-size log factor?
15:50:06 <Cale> With the balanced tree, you might find your element at a shallower depth.
15:50:18 <mmorrow> loop: true
15:51:18 <mmorrow> trie lookup on strings, assuming child lookup is O(k), is O(l*k)
15:51:33 <dcoutts> I love tries and hate hashes, because I like persistent data structures, but cpus do not seem to be on our side. Hashes get cheaper to calculate assuming the thing you're hashing fits in a few cache lines, where as looking up tries has to suffer the latency of ram
15:51:44 <Cale> So in the end, they're both O(log^2 n) or O(log n), depending on whether you're counting raw memory indirections or not.
15:51:59 <dcoutts> unless the hash ends up probing multiple locations in which case they loose too
15:53:10 <mmorrow> if the set of strings is know at compile-time, it can be turned into a trie of case statements on the chars. i'm not sure the full implications of this for speed though.
15:53:13 <olsner> I've always pointed to hash collision behaviour when arguing that hashtables are >= O(log n) - i.e. that even if the hash function is O(1) you'll have O(n) hash collissions and need some way of managing them, a binary tree has O(log n) lookup within the hash bucket, a linked list or other thing would give the hash-table a  O(n) worst-case
15:53:15 <mmorrow> i'll paste
15:53:59 <luite> mmorrow: or into a minimum perfect hashing function
15:54:00 <dcoutts> olsner: though isn't there a way of growing the table, to keep the number of collisions down?
15:54:04 <guenni> mmorrow: hi
15:54:26 <mrd> exponentially
15:55:15 <olsner> well, if you can also prove that you can always grow the table to a size where the number of collissions goes down to at most a constant factor away from the load factor
15:55:40 <dcoutts> My point is, even if they're the same complexity in the limit, the issue of fast cpus with caches and slow memory, doesn't that mean that hashes end up with fewer cache line loads on average?
15:56:07 <olsner> but in the absolute worst case, you'll still have a data set that gives the exact same hash value for every item in your table
15:56:38 <Cale> dcoutts: In order to look at whether that's the case, you need to know something about the representation of your datatypes though.
15:57:33 <Cale> If the datatypes are anything like Haskell algebraic datatypes, it seems unlikely that they will be represented in such a way that you get significant improvements in terms of cache coherency. I might be wrong about that...
15:58:31 <dcoutts> Cale: aye, because they involve lots of indirections too. So hashes seem to be best suited for short records/objects of primitive types, or short strings.
15:58:50 <dcoutts> basically something that fits entirely within a couple cache lines
15:59:27 <mmorrow> luite: http://hpaste.org/10290
15:59:39 <mmorrow> guenni: hi, howsit going
16:00:27 <guenni> mmorrow: great, after weeks somebody on happs helped me to get happs installed on windows which I so badly needed
16:00:37 <guenni> mmorrow: how are you?
16:00:50 <luite> mmorrow: hehe, nice :) how long does it take to compile the entire words program? :)
16:01:06 <mmorrow> guenni: ooh, awesome! i'm good, same ole same ole. what're you planning on doing with happs?
16:01:13 <mmorrow> luite: i'll try now
16:01:42 <Cale> This theorem that I just sketched regarding the cost of the hash function -- is it often included in CS curricula? I've never heard it before, and given the number of people who swear up and down that lookups in hashtables of size n are O(1) time, I think a lot of other people are missing this subtlety as well.
16:01:44 <guenni> mmorrow: well I actually only need the IxSet module
16:02:01 <mrd> Cale: i highly doubt it
16:02:16 <Cale> (My background is in mathematics, and I've only had a limited number of CS courses, so I'm not sure :)
16:02:20 <Botje> Cale: there was some talk of picking hash function that didn't generate much collisions, but nothing about the actual cost, no
16:02:29 <Cale> That's interesting.
16:02:31 <mrd> they worried about showing universality for hash functions in my course
16:02:50 <guenni> mmorrow: I have large amounts of data that I want to be free to query any way I like and cannot necessarily foresee upfront
16:03:57 <MarcWeber> What am I doing wrong ? http://rafb.net/p/V1hIwU84.html
16:04:01 <lambdabot> Title: Nopaste - No description
16:04:03 <mmorrow> luite: not bad: http://hpaste.org/10290#a1
16:04:42 <mmorrow> guenni: cool. i've checked that module out, but haven't used it. it looks interesting.
16:04:48 <luite> mmorrow: and with the whole words list?
16:05:10 <Botje> MarcWeber: wayyyy too scary language flags :)
16:05:39 <mmorrow> luite: i have to reimplem the parts from Data.Tree i'm using because it can't seem to do it without stack overflowing (and i'm not sure yet what's causing it...) :(
16:06:11 <guenni> mmorrow: do you know of anything similar, what do you do in such a case?
16:06:52 <MarcWeber> Botje I'm not sure wether I understand them all. ghc told me to use them :-O
16:07:16 <Botje> ghc just wants you to make it more powerful :p
16:07:26 <mmorrow> guenni: hmm. if i have a /huge/ amount of data, usually a database, but i use Data.Map a bunch. what sort of data is it that you want to query?
16:07:43 <MarcWeber> Anyway that doesn't help me!
16:07:58 <mmorrow> guenni: or better question, how's it structured?
16:08:29 <guenni> mmorrow: records from a csv file, I need to select data based upon values from different fields
16:09:39 <guenni> mmorrow: and since the guys that I'm writing this code for are giving me the algo piece by piece I cannot be sure which particular fields I might have to group by or select or whatever
16:10:08 <guenni> mmorrow: the only thing I do know are the structure of the record
16:10:19 <mmorrow> guenni: ah. i've done various things with that. mostly using Data.Map as the lookup primitive, then putting Maps in Maps or Maps in Trees or something like that (whatever is best for the particular case)
16:11:09 <guenni> mmorrow: right, that'd be my approach too if I knew upfront by which field to order the records, I do not however
16:11:44 <guenni> so I thought IxSet with its multiple index cabapilities might be the answer
16:12:13 <mmorrow> guenni: it's nice to build indexes like   [[Value]] -> [Map Value [Int]] , where the [Int] you get from looking up a value is the indexes of all the rows where that value occurs
16:12:46 <mmorrow> guenni: Data.IxSet looks great though. I'll have to look at it again.
16:13:34 <guenni> mmorrow: let's hope it lives up to its promise, I'll start playing with it tomorrow
16:14:02 <mmorrow> guenni: yeah, and i'm sure Data.IxSet has been used a bunch via HAppS too, so it's probably relatively optimized/whatnot
16:14:18 <mmorrow> guenni: cool. lemme know how it goes :)
16:14:39 <guenni> mmorrow: it also seems to be the only solution so far, haven't seen or heard of anything similar
16:14:53 <mmorrow> guenni: me neither
16:15:14 <guenni> mmorrow: questions here and on happs always drew a blank
16:15:53 <guenni> mmorrow: which surprises me a bit, cause it's kind of a very common scenario
16:15:57 <Saizan> btw, IxSet is just a bunch of Map SomeIndex Record
16:16:13 <mmorrow> guenni: yeah, the only way to learn it it seems is to read the code, although i've seen a few blog posts/etc of mini examples
16:16:37 <guenni> Saizan: thx again for helping me!
16:16:50 <Saizan> guenni: np :)
16:17:12 <guenni> Saizan: that might be true, but as a newbie in haskell I would just not be able to build it myself
16:17:48 <guenni> Saizan: I'm not expecting it to be build on magic or anything
16:17:59 <Saizan> (Map Index (Set Record) actually)
16:18:20 <Saizan> guenni: 'k, it was just to dispel any possible magic :)
16:19:10 <lightstep> re hashtables being O(log n), if "robin hood hashing" is used, you only have O(log log n) elements in the largest cell
16:19:39 <mmorrow> guenni: that's awesome that your using haskell for this.
16:19:45 <mmorrow> *you're
16:20:42 <guenni> well I've been programming for a while now, also Java, Smalltalk and others and I know intimately how bad theses languages are
16:21:21 <mmorrow> heh. after haskell, everything seems to be lacking ;)
16:21:30 <guenni> I must say though that Haskell has one steeeep learning curve
16:21:40 <MarcWeber> guenni: Java is not that bad if there are libraries you can use for your task.. But if not.. I agree :-)
16:21:59 <guenni> well Smalltalk was my one great love so far
16:22:17 <guenni> fast easy, one principal, great, great IDE
16:22:49 <guenni> but also impossible to recycle *any* code
16:23:01 <MarcWeber> There is no great IDE for haskell yet :-( (I haven't tried the one based on Visual Studio)
16:23:04 <mmorrow> one thing that haskell has that now that i've used it can't imagine not having it is ghci (or equivalent)
16:23:20 <mmorrow> fire up ghci
16:23:28 <mmorrow> rattle off four lines
16:23:34 <mmorrow> do some huge task
16:23:36 <mmorrow> :q
16:23:48 <mmorrow> so nice.
16:24:07 <MarcWeber> guenni: And can you imagine spending two weeks using haskell just to generate some lines of xml ? (They are validated against dtd automatically now though :))
16:24:38 <mmorrow> MarcWeber: awesome
16:24:45 <guenni> Smalltalk was great for debugging, stepping etc, no need for editing files, class browser, the works
16:24:57 <Associat0r> MarcWeber : the 2005 version is unstable here
16:25:07 <Associat0r> lleksah may be good
16:25:23 <MarcWeber> mmorrow Anyway the lib is not heavily tested an still alpha..
16:25:31 <guenni> Associat0r: don't hold your breath though
16:25:53 <Associat0r> guenni : no good?
16:25:55 <MarcWeber> Associat0r: :-) I like some parts of leksah, but If you're used to vim - no chance
16:26:10 <guenni> Associat0r: for now at least, no
16:26:28 <MarcWeber> But the browsing capabilities are realy nice.
16:26:58 <Associat0r> I will try the VS 2003 version
16:27:01 <guenni> well I did come to appreciate Eclipse with Java, damn slow, but nice features
16:27:31 <Associat0r> F# with Visual studio is good
16:27:42 <guenni> certainly when you have to edit source code, debugging not too bad either
16:27:47 <mapreduce> I use Eclipse at work and would probably go mad without shifting to emacs often.
16:28:39 <Associat0r> http://www.viemu.com/
16:28:43 <lambdabot> Title: ViEmu: vi-vim editor emulation for Visual Studio, Word, Outlook and SQL Server
16:29:06 <guenni> mapreduce: I kinda like the F3, where you can just jump to code
16:30:15 <guenni> Associat0r: I don't get it ...
16:30:30 <mapreduce> guenni: M-. in emacs
16:30:37 <mapreduce> (if you have tags set up)
16:31:03 <guenni> mapreduce: what does that do?
16:31:19 <mapreduce> Navigates to something's definition.
16:31:46 <mapreduce> On a 4 million line C project it worked about 20 times faster than Eclipse does on a 2000 line Java project.
16:31:56 <guenni> mapreduce: quick, tell me how I can set this up, please don't leave now
16:32:11 <guenni> mapreduce: pleeeeeeeeease
16:32:22 <mmorrow> lol
16:32:56 <mapreduce> guenni: cd yourproject && find . -name '*.[ch]' | etags -
16:33:15 <mapreduce> M-x visit-tags-table yourproject/TAGS
16:33:25 <mapreduce> Then M-. on a symbol (or type one)
16:33:54 <mapreduce> Change .[ch] to whatever you're using, and remember to customise etags yourself if it doesn't support your files :)
16:34:25 <Saizan> is there an etags for haskell?
16:34:52 <guenni> well my files would *.hs, right?
16:35:28 <mapreduce> guenni: Sure.  But I haven't noticed any indication that etags supports Haskell.  Nor have I searched for that.
16:36:03 <mapreduce> I have less than a screenful of Haskell code to look at :)
16:36:27 <guenni> mapreduce: what a minute, you're making me hot and then give me a "...maybe"?
16:36:40 <mmorrow> heh
16:36:53 <guenni> guenni: story of my life
16:37:31 <guenni> except it's not usually guys
16:37:32 <mapreduce> @go hasktags
16:37:34 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/utils.html
16:37:34 <lambdabot> Title: Chapter�11.�Other Haskell utility programs
16:37:40 <mapreduce> guenni: ^^
16:38:23 <mmorrow> guenni: http://www.haskell.org/ghc/docs/latest/html/users_guide/utils.html#hasktags
16:38:24 <lambdabot> Title: Chapter�11.�Other Haskell utility programs, http://tinyurl.com/yttywz
16:38:29 <mmorrow> ah, beat me too it
16:39:14 <guenni> mmorrow: you knew this and didn't tell me?
16:39:30 <guenni> mmorrow: some friend you are!
16:39:39 <mmorrow> haha, didn't think of it til now
16:39:44 <guenni> mmorrow: ;)
16:39:49 <mapreduce> I find this more interesting for Haskell: http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
16:40:01 <lambdabot> Title: EmacsWiki: Pretty Lambda
16:43:48 <guenni> uhm, about hasktags? so where is the programm?
16:45:06 <guenni> and doesn't it need to be re-run after each edit?
16:45:44 <mmorrow> guenni: i've never used it, but it appears so.
16:46:51 <mapreduce> You might use that with flymake I imagine.
16:47:13 <mmorrow> i've been doing some stuff with parsing hs source and doing <something-that-makes-coding-easier> with it lately though, and just put tags/somthing-similar on my todo list though. i'll let you know if anything comes of that.
16:48:39 <mapreduce> guenni: http://darcs.brianweb.net/ghc/utils/hasktags/
16:48:48 <lambdabot> Title: Index of /ghc/utils/hasktags
16:49:02 <mmorrow> guenni: this discussion (the one right now) finally put me over the edge on installing/using yi. http://haskell.org/haskellwiki/Yi
16:49:03 <lambdabot> Title: Yi - HaskellWiki
16:49:05 <guenni> mapreduce: thx
16:49:06 * mmorrow darcs get s
16:49:46 <mmorrow> it looks like it could be /amazing/
16:50:04 <mapreduce> I've considered trying it out.
16:50:06 <guenni> mmorrow: you serious?
16:50:24 <mmorrow> about what? that i just decided to start using it? yes.
16:50:35 <mmorrow> the best part is, it's scriptable dynamically in haskell
16:50:56 <guenni> mmorrow: hasktags?
16:51:25 <mmorrow> err, what is the question?
16:51:34 <mmorrow> ohh
16:51:38 <mmorrow> no, i meant yi
16:51:41 <Twey> @pl \x y z -> [x, y, z]
16:51:41 <lambdabot> (. ((. return) . (:))) . (.) . (:)
16:51:46 <guenni> aso
16:51:46 * Twey twitches.
16:52:33 <guenni> mmorrow: which platform are you using?
16:54:27 <thoughtpolice> dons: you were advocating monadLib I remember - are there any good examples of its use? or just try bunches of stuff? :]
16:54:42 <bos> monadLib is pretty easy to just read.
16:55:14 <mmorrow> guenni: x86 32bit fedora linux
16:55:17 <dons> hpaste2 uses it i think.
16:55:46 <guenni> mmorrow: k
16:56:57 <mmorrow> guenni: are you on linux?
16:57:02 <mmorrow> dons: it does
16:57:15 <guenni> mmorrow: nope, winxp
16:57:22 <guenni> mmorrow: 32 bit
16:57:29 <mmorrow> guenni: get linux noww!@
16:58:16 <guenni> mmorrow: 1st of all sweetie: it wouldn't be linux, it would always be FreeBSD, because that really rocks!
16:58:25 <mmorrow> hehe
16:58:37 <mmorrow> get bsd noww!@
16:59:01 <guenni> mmorrow: 2nd I have no choice, the app I'm working on is for XP, I also need M$ Access and Excel
16:59:46 <guenni> mmorrow: and 3rd-ly: I'm using Windows on VMware on Mac OS X
16:59:56 <mmorrow> yeah i hear you. gnumeric i've found can handle all things excel, but access... i dunno.
17:00:13 <mmorrow> guenni: oh, nice. i have winxp in vmware as well.
17:00:24 <guenni> mmorrow: yep
17:06:59 <guenni> I so hate it when packages have unix dependencies
17:12:33 <mmorrow> guenni: heh
17:14:29 <araujo> hello
17:14:37 <guenni> hi
17:21:53 <thoughtpolice> guenni: vmware fusion is pretty nice indeed
17:22:00 <thoughtpolice> it was cheap here at school so i couldn't pass it up
17:29:53 <Saizan> anyone have an implementation of serialization of Dynamics handy?
17:37:49 <guenni2> mmorrow: are you trying to get yi installed?
17:39:06 <guenni> mmorrow: thought so ...
17:39:46 <mmorrow> mmorrow: heh, yeah. i'm battling getting all the packages i need installed with a ghc i just built last week
17:40:09 <mmorrow> i think i may have just got it. about to try building yi
17:40:17 <guenni> lemme know how it went
17:41:30 <mmorrow> crap, need more stuff
17:41:32 <mmorrow> i will
17:42:45 <mmorrow> Saizan: hmm. i think there's something related to that on hackage, but i don't know anything about it.
17:51:13 <Saizan> mmorrow: found this http://www.haskell.org/pipermail/haskell-cafe/2008-May/042860.html
17:51:17 <lambdabot> Title: [Haskell-cafe] Data.Dynamic over the wire, http://tinyurl.com/6bwtka
17:52:49 <mmorrow> Saizan: oh nice, i vaguely remember that. seems like there's a bunch of interesting/useful things that can be somehow done with that general idea
17:52:57 <mmorrow> just dunno what they are yet ;)
17:59:52 <Saizan> mmorrow: yeah, storing the dictionaries separately and looking them up with the TypeRep is kind of twisted but nice :)
18:00:29 <mmorrow> twisted is good though... ;)
18:03:14 <Saizan> however you get a benefit only if the table is not fixed, because in that case you could just use an union, no?
18:11:33 <mmorrow> Saizan: possibly. one thing i was thinking of is suppose you binary encode some data, then send it to another runtime (wherever that may be/however it's sent) along with its full TypeRep (recursively expanded). then if both sides derive the binary encoding function from the TypeRep in the same way, the other side'll be able to decode the data.
18:12:46 <mmorrow> grrrr, yi has bested me for the moment, but when i get back it's going down..
18:14:26 <Saizan> mmorrow: you mean without having the same type on the other side of the wire?
18:17:46 <guenni> mmorrow: lol
18:26:41 <lispy> was lambdaVM ever finished?
18:26:47 <lispy> it looks to be unfinished to me
18:29:17 <thoughtpolice> lispy: it's been mentioned on -cafe recently; bugging the author to perhaps moving it up to e.g. HEAD or 6.10 might be worth something
18:29:36 <lispy> thoughtpolice: yeah, I saw the mention on -cafe
18:29:44 <lispy> thoughtpolice: and I was intrigued
18:30:07 <lispy> I didn't really understand the author's appoarch
18:30:25 <lispy> Are they translating from core to java or core to bytecode?
18:30:47 <thoughtpolice> core to bytecode it seems
18:30:54 <lispy> It seems like all you'd need to do in a first implementation is modify the backend to add a code generator for java, but is this a hard problem?
18:31:41 <lispy> Initially, maybe I don't care if my FFI options are limited to builtins
18:31:53 <thoughtpolice> apparently the RTS is also rewritten in java, and the codegen to take STG and output jvm bytecode instead of c--
18:32:12 <thoughtpolice> just from the looks of the homepage
18:32:21 <lispy> rewriting the RTS seems like a huge effort, I wonder why that was a good idea
18:33:22 <lispy> That was probably needed to work with the code generated from STG?
18:33:23 <thoughtpolice> ask him :)
18:33:59 <dancor> can i make these num casts more concise: http://hpaste.org/10292
18:34:09 <sjanssen> lispy: it seems necessary to rewrite the RTS in Java
18:34:12 <ddarius> lispy: How are they supposed to not rewrite the RTS?
18:34:15 <sjanssen> C is not Java
18:34:46 <lispy> you can't the GC and what not builtin to the jvm?
18:35:13 <ddarius> lispy: Not every detail of the C RTS needs to be recreated.
18:35:21 <sjanssen> lispy: even removing the GC in favor of Java's requires modifying the RTS
18:36:54 <lispy> so what you're saying is that by only modifying an existing code generator (instead of writing one from scratch) there are implicit dependencies on the existing RTS framework?
18:38:31 <unmarshal> can someone answer this for me: what is the purpose of toChunks in Lazy ByteString.  What is the purpose of converting a lazy bytestring to an array of strict bytestrings? why isn't there a way to convert a lazy directly to a strict?
18:39:12 <sjanssen> s/array/list
18:39:29 <unmarshal> surely.
18:40:23 <lispy> a lazy byte string is a list of strict bytestrings internally
18:40:49 <lispy> unmarshal: so, suppose you wanted to process a lazy bytestring using a function that only works on strict byte strings
18:40:53 <lispy> unmarshal: you could process the chunks
18:41:11 <unmarshal> okay that makes sense. thanks
18:41:13 <lispy> or say you wanted to join the chunks to form one strict string
18:41:29 <unmarshal> i want to use the zlib functions
18:41:31 <unmarshal> which use lazy bytestrings
18:41:33 <unmarshal> i'm using strict
18:41:42 <unmarshal> so doing that conversion seemed kinda ugly
18:41:58 <lispy> oh, dcoutts and Heffalump are working on tht
18:42:18 <lispy> they were adding a function to zlib (I thought it made it in actually) where it returns a strict bytstring
18:42:29 <unmarshal> i come from the land of dynamic languages, so when i feel like i'm doing unnecessary marshaling, i think twice
18:42:38 <lispy> well, actually it was going to return a lazy single chunk, but that's equivalent
18:42:39 <unmarshal> cool, sounds good
18:42:54 <lispy> But it would require knowing the size up front
18:43:03 <unmarshal> makes sense
18:43:09 <unmarshal> i should prob convert all my stuff to lazy bytestrings
18:43:12 <unmarshal> i'm reading off a tcp socket
18:44:29 <dejones> How do you uninstall a package that was installed with Cabal?
18:45:30 <Saizan> dejones: ghc-pkg unregister it, and rm the files
18:45:40 <dejones> Saizan: Ty.
18:46:36 <unmarshal> later all
18:46:39 <unmarshal> thanks for help!
18:48:54 <dejones> http://hpaste.org/10293
18:49:04 <dejones> I'm having issues unregistering GLUT from ghc packages.
18:49:21 <dejones> ghc-pkg can't seem to find the package, although it is shown in ghc-pkg list.
18:50:46 <dejones> Help?  :)
18:57:07 <lispy> dancor: you could use a where clause
18:58:07 <lispy> dancor: you that would allow you to easily say, "Float" for example
19:08:58 <MarcWeber> dejones: Have you tried --user or specifying the package db by --package-conf (or such? see ghc-pkg --help)
19:09:27 <dejones> MarcWeber: Nope, haven't tried that... I was unaware of those options.  :/
19:10:18 <dblazakis> check it out, i ported an example from the thrists paper: http://hpaste.org/10294
19:10:31 <dejones> MarcWeber: Odd, unregister with --user worked.  Thanks for the tip.  :)
19:11:01 <MarcWeber> dejones If we are at it: There is also GHC_PACKAGE_PATH, but its not used very often
19:11:46 <dejones> MarcWeber: Thanks.
19:24:39 <hackage> Uploaded to hackage: CouchDB 0.8.0.3
19:26:55 <mmorrow> Saizan:  no, the other side would decode it to the /same/ type, but they just don't know which type that'll be ahead of time.
19:29:28 <mmorrow> Saizan: actually, for an encoded type T, you'd probably need all the infos in the transitive closure of the Info of T, where Info is that from (reify ''T :: Q Info)
19:30:00 * shapr waves to glith
19:30:03 <shapr> er, glguy !
19:30:11 <glguy> hi
19:30:27 <shapr> How's code?
19:31:51 <dons> dcoutts_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gameclock-1.0.3
19:31:53 <lambdabot> Title: HackageDB: gameclock-1.0.3, http://tinyurl.com/46zyx4
19:31:59 <dons> nice hsclock variant, a chess game clock. quite nifty.
19:32:09 <dons> dcoutts_: see, this is why we put things on hackage!
19:32:18 <dons> glguy: put some things on hackage!
19:32:31 <glguy> ?
19:32:36 <Nafai> Hi shapr!
19:32:39 <shapr> hi Nafai!
19:33:04 <dons> glguy: i'm just suggesting that you should put some of your cool things on hackage.
19:33:12 <dons> union-find's been sitting around for a while. hpaste2. et al..
19:33:21 <dons> since then people use them, extend them, study them and learn from them.
19:33:44 <dons> for example, i put up this little hsclock, the standard gtk2hs cairo demo
19:33:56 <dons> and someone took the package, and modified it, turning it into a chess game clock
19:34:24 <dons> now, say i wanted to implement union-find. if only there was a package on hackage i could study.
19:34:56 <glguy> the code is available on github
19:35:06 <glguy> but I don't think it merits another line on hackages package list
19:35:09 <dons> but you're not going to put it on hackage yourself?
19:35:22 <mmorrow> dons: i'm not sure if this is fixed/whatever somewhere else, but i just got darcs bytestring-9...2 and built it on HEAD from 20080822 and on of the functions has too many specializations. adding -fspec-constr-count=4 fixed it though.
19:35:22 <dons> neither hpaste nor union-find at this point?
19:35:30 <dons> mmorrow: whoa.
19:35:34 <dons> that's interesting.
19:36:32 * dons doesn't understand why everyone doesn't upload all their open code.
19:36:36 <mmorrow> heh, i'm building the hackage regex-tdfa on the same ghc right now... i had to add -fspec-constr-count=100 because i couldn't count the num in the error msgs by hand thhere were so many
19:36:48 <dons> hmm. mmorrow maybe you should mention this on the list.
19:36:54 <dons> give some indication of how common it is.
19:37:04 <mmorrow> cool. it happens a fair amount actually.
19:37:07 <mmorrow> which list?
19:37:10 <dons> shapr: you know, we're closer to taking over the world than we were a few years ago.
19:37:13 <dons> mmorrow: cvs-ghc@
19:37:23 <mmorrow> will do
19:38:10 <thoughtpolice> "Gee brain, what do you want to do tonight?"
19:38:56 <dons> i think this is quite a lovely little haskell app, http://aur.archlinux.org/packages.php?ID=19871
19:39:07 <lambdabot> Title: AUR (en) - gameclock
19:39:10 <dons> it fills a niche perfectly, it's well executed, and it used open source for both inspiration and result.
19:40:28 * dons is filled with optimism this afternoon
19:40:29 <dons> boing!
19:40:43 <dejones> :)
19:40:48 <dons> almost wrote "optimisation"
19:40:58 <dejones> dons: Give me some of that optimism..  Today I've been defeated over and over by HOpenGL.  :(
19:41:12 <ivanm> dons: and of course, you paste the link to your arch package, rather than hackage I noticed...
19:41:16 <dons> we've heard a lot of good things about hopengl this year.
19:41:22 <dons> ivanm: well, i just uploaded it :)
19:41:26 <ivanm> heh
19:41:29 <dblazakis> dons: i saw you visited JHU, did you meet with Jonathan Shapiro (one of the bit-c guys)?
19:41:30 <ivanm> wtf is "Fischer time"?
19:41:34 <dejones> dons: I can't get HOpenGL installed.  :/
19:41:41 <dons> dblazakis: no, i was there on work stuff.
19:41:46 <dons> dejones: oh, that's weird.
19:41:51 <dons> ivanm: some clock timing system?
19:41:52 <dons> chess
19:41:58 <dejones> dblazakis: I know of him from Gnu Hurd too and Coyotos Kernel.
19:42:00 <ivanm> ahhh
19:42:06 <dons> it's a chess game clock
19:42:18 <dejones> dons: HOpenGL can't seem to find my OpenGL and GLUT libraries.
19:42:25 <dons> do you have them installed?
19:42:31 <dons> they're not necessarily installed by default.
19:42:36 <dons> look for them in ghc-pkg's output
19:42:41 <dons> or use your distro arch.
19:42:45 <dons> specific packages
19:42:51 <dblazakis> dejones: yah, he also has a small company here doing ukernel stuff for embedded systems
19:42:57 <dejones> dons: I installed them with Debian packages.
19:43:02 <glguy> some distros have separate -devel packages
19:43:03 <dejones> dblazakis: Ah yes, I remember something like that.
19:43:13 <dons> dejones: see what ghc-pkg says
19:44:31 <dons> dejones: oh, yes, the C packages might have -devel suffixes (or other things)
19:44:36 <dons> or you might need to set include paths
19:44:49 <dejones> dons: GLUT and OpenGL packages install fine with Cabal, but during the configure of GLUT it says, "checking for GLUT library... no" among other similar lines, but no errors during the install.  ;)
19:45:03 <dejones> dons: ghc-pkg list shows both GLUT and OpenGL installed.
19:45:07 <dons> so look for where glut.h live
19:45:09 <dons> on your system
19:45:23 <dejones> dons: Ok. :)
19:45:52 <glguy> if autoconf can't find the library, it means you don't have the c-headers
19:45:58 <glguy> not that you don't have the haskell package
19:46:19 <dejones> glguy: Yah, but I am pretty certain I have the c-headers, which were installed from the Debian -dev packages.
19:46:31 <dejones> glguy, dons: freeglut3-dev is the package.
19:46:36 <dons> it's annoying happs depends on an old haxml.
19:46:37 <dejones> * Debian package, that is.
19:46:52 <dejones> http://packages.debian.org/etch/freeglut3-dev
19:47:03 <lambdabot> Title: Debian -- Details of package freeglut3-dev in etch
19:48:50 <shapr> dons: yay!
19:49:11 <dons> boing!
19:49:11 <dejones> dons, glguy: Also, I installed all the packages that are listed in the Debian package for libghc6-opengl-dev: http://packages.debian.org/lenny/libghc6-opengl-dev
19:49:13 <lambdabot> Title: Debian -- Details of package libghc6-opengl-dev in lenny
19:49:35 <dejones> I just don't see how I am missing the headers for OpenGL and GLUT...  Maybe some kind of path issue?
19:49:55 <dons> did you find glut.h ?
19:50:02 <dons> if so, then paths, yes.
19:50:09 <dons> you might need to set CPPFLAGS and LDFLAGS
19:50:16 <dons> $ echo $CPPFLAGS
19:50:16 <dons> -I/usr/local/include -I/home/dons/include
19:50:18 <dons> for exapmle
19:50:41 <dejones> dons: Searching for glut.h now
19:51:08 * dons enjoys some open source hacking, and a cool, refreshing glass of portland's finest
19:51:27 <shapr> portland's finest ... water?
19:51:30 <shapr> beer?
19:51:33 <dmwit_> ac: Congrats on your first Hackage package! =)
19:51:33 <dons> beer, actually :)
19:51:36 <shapr> Acai juice?
19:51:37 <shapr> ah!
19:51:40 <Pseudonym> {- drunk.. fix later -}
19:51:43 <shapr> heh
19:52:00 <dejones> Pseudonym: Now, that is a useful comment.  :)
19:52:00 <TomMD> shapr: Haven't you heard?  The brewery to person ratio is greater than one in Portland.
19:52:04 <dons> that's true.
19:52:06 <shapr> wow
19:52:08 <Pseudonym> ?go drunk fix later
19:52:10 <lambdabot> No Result Found.
19:52:16 <cjb> dons: oh, do you live in Portland?
19:52:20 <dons> the beer is from a brewery 3 blocks down the road. and that's not   the closest one.
19:52:28 <cjb> dons: I'll be there next week for the Linux Plumbers Conference
19:52:28 <dons> cjb: yup.
19:52:39 <dons> cool. yeah, i think we've got someone going to that.
19:52:52 <sjanssen> cjb: a hybrid Linux/Plumbing conference?
19:53:00 * sjanssen can't imagine there's much of an audience for that
19:53:04 <dons> heh
19:53:32 <cjb> :)
19:53:50 <cjb> http://linuxplumbersconf.org/
19:53:56 <sjanssen> cjb: I just googled it, looks interesting
19:54:00 <lambdabot> Title: Linux Plumbers Conference 2008
19:54:19 <sjanssen> good to see somebody is thinking about how all those bits fit together
19:54:57 <dons> sjanssen: so have you switched to Arch yet?
19:55:36 <waynemokane> hi everyone.. I'm wondeirng if anybody can help with my "directives may not be used inside a macro argument" error when trying to build ghc
19:55:42 <waynemokane> http://hpaste.org/10252
19:55:44 <sjanssen> dons: nah, I'm still on Ubuntu
19:55:54 <dons> boo. they don't have have haskell-parallel, did you notice?
19:56:01 <sjanssen> I think it'd take some convincing to get me more on the DIY scale of distros
19:56:02 <dons> hardy's got broken haskell support :(
19:56:24 <dons> sjanssen: you can update to the latest package set using a 'darcs pull' like operation
19:56:24 * sjanssen probably just cabal installed it
19:57:27 <dons> unusual haskell app, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/n-m-0.0.1
19:57:28 <lambdabot> Title: HackageDB: n-m-0.0.1, http://tinyurl.com/52grrk
19:57:32 <dons> "This program choses between the available open wireless networks and tries to connect to them using DHCP. "
19:57:38 <TomMD> dons: I've (somewhat) recently switched to arch and I must confess some confusion over what the AUR haskell packages offers me over hackage.
19:57:47 <dons> TomMD: it's a clone of hackage.
19:57:57 <dons> with different skin. so not for cabal-install familiars.
19:58:21 <dons> for non haskell devs, its an easy gateway into haskell apps -- they may not even know they're haskell apps.
19:58:34 <TomMD> Ah, got ya.
19:58:42 <dons> so hopefully people start using say, 'gameclock', and never realise they're running a haskell runtime system ... until it is too late!
19:58:46 <dons> mwhahaha
19:58:46 <sjanssen> dons: recognize the author's name from xmonad-contrib?
19:58:49 <bitrot> dons: curious...what *IS* Portland's finest?
19:58:54 <dons> oh yes, marcot.
19:59:04 <dons> bitrot: well, Bridgeport IPA, supposedly.
19:59:20 <dons> it's a great northwest IPA. i'd put it up there with Deschutes Inversion IPA.
19:59:34 <waynemokane> mmorrow: are you here?
19:59:50 * dons is rapidly turning into a beer geek.
19:59:52 <bitrot> dons: Bridgeport is good, but that's the best?  Really?
20:00:02 <waynemokane> Goose Island baby!
20:00:03 <dons> in popular opinion.
20:00:09 * cjb is excited to try Portland beer.
20:00:21 <dons> i'm not sure it is the best, it's very well regarded, and widely found.
20:00:22 * bitrot admits to being a homebrew hacker
20:00:30 <dons> yeah, i need to get back into that.
20:00:41 <dons> but in a little studio aprt. might be too intrusive :)
20:00:53 <dons> i know, we can set up the kegs at glguy's house.
20:01:53 <bitrot> I happen to have some Widmer Bros. IPA in front..not quite as good as I recall..
20:01:53 <dons> huh, we've got more apps than libraries released today i think.
20:01:59 <mmorrow> waynemokane: hey
20:02:07 <dons> yeah, i don't recall that one as being terribly distinct.
20:02:33 <bitrot> kinda sad, really
20:02:33 <waynemokane> mmorrow: for some reason my ghc is behaving like a naughty gcc :(
20:03:31 <mmorrow> waynemokane: weird. why do you tell me? (i'm confused)
20:04:03 <mmorrow> i'd love to help, though
20:04:05 <mmorrow> :)
20:04:09 <waynemokane> mmorrow: oh... sorry I guess I was just talking to you about it the other night
20:04:33 <mmorrow> remind me, i can't recall the exact topic of discussion off the top of my head
20:04:56 <waynemokane> mmorrow: basically, I was trying to get ghc built and working at my company
20:05:01 <mmorrow> ohhh. yeah, so you finally got 6.6 going
20:05:04 <waynemokane> mmorrow: it having a strange inffrastructure
20:05:09 <waynemokane> mmorrow: yes got 6.6 going finally
20:05:13 <mmorrow> then were gonna build 6.8
20:05:15 <cjb> dons: let me know if you have any suggestions on fun things to do in Portland :)
20:05:16 <waynemokane> mmorrow: exactly
20:05:21 <bitrot> hey, here's a random question thought: string concatenation..in Java, (+) is "notoriously slow".  any idea how python/haskell/$something_else compare?  what might be the most efficient REPL-sort-of-language approach (operating on 50-100GB of data, btw...)
20:05:25 * cjb will be there Tue-Fri, is planning on finding the Go club.
20:05:26 <mmorrow> waynemokane: cool cool
20:05:27 <dons> cjb: yeah, i'll have a think.
20:05:28 <waynemokane> mmorrow: so I got the source tarball for 6.8.3
20:05:33 <mmorrow> waynemokane: ok
20:05:43 <waynemokane> and it seemed to make it most of the way through fine... ghc was compiling a bunch of stuff without problem
20:05:54 <waynemokane> then I got those strange errors... and it was in a C file
20:06:05 <waynemokane> so I dunno what the heck it's trying to do
20:06:08 <mmorrow> what did the errors say?
20:06:10 <waynemokane> something with the RTS component
20:06:12 <waynemokane> http://hpaste.org/10252
20:06:13 <TomMD> If my sources are to be belived, there are only three things to do in Portland.  1) Program Haskell 2) Brew/drink beer 3) Play frisbee.
20:06:17 * mmorrow looks
20:06:25 <cjb> TomMD: :)
20:06:41 <waynemokane> mmorrow: actually there are a bunch of errors below that as well, I just pasted a bit starting from the first
20:06:42 <TomMD> :-)  Not that this is a bad or limited selection
20:06:47 <cjb> my wife and I pretty much agreed on moving to the west coast next year, but she wants to go to SoCal and I want to go to Portland ;-)
20:07:00 <cjb> maybe we'll compromise with SF or something.
20:07:04 <waynemokane> it's almost like complaining about nested C macros
20:07:06 <dons> hmm. it'd be interesting to see a graph of "average number of dependencies" of haskell packages, over time.
20:07:10 <TomMD> My wife already has half the house in boxes ready for the move to Portland.
20:07:18 <mmorrow> waynemokane: hmm. lemme check something real quick...
20:07:18 <cjb> gosh
20:07:20 <dons> i think the dep count average is growing nicely.
20:07:23 <cjb> Portland's pretty popular, huh.
20:07:33 <cjb> TomMD: what kind of job would you have there?
20:07:35 <TomMD> Yeah, Portland is the new black.
20:07:37 <dons> TomMD: that list of top 3) is about right. :)
20:07:49 <dons> haskell , beer, frisbee, *coffee*
20:08:02 <dons> i know, life's hard.
20:08:03 <TomMD> cjb: I'd have a great job earning zero dollars as a student.
20:08:14 <dons> he's joining the ranks of the phd-to-be :)
20:08:16 * cjb is a Go-playing Linux-developing vegetarian cyclist.
20:08:19 <waynemokane> the file it's complaining about:  http://darcs.haskell.org/ghc/rts/RtsFlags.c
20:08:21 <cjb> TomMD: cool, congrats
20:08:25 <dons> cjb: hey, you must live in portland :)
20:08:35 <dons> yeah, *bicyles* that's also required.
20:08:39 <cjb> dons: Boston at the moment :)
20:08:55 <dons> i notice there's a bicycles-of-oregon display case at PDX airport now.
20:08:55 * shapr hugs cjb
20:08:57 <cjb> TomMD: there are some Haskell academics around, right?  Like.. Bart Massey.
20:08:59 <waynemokane> mmorrow: I looked through the source and it seemed like this was the only C file which had the nested macro stuff going on
20:09:12 <TomMD> cjb: Don't forget Andrew Tolmach and Mark Jones!
20:09:12 <waynemokane> mmorrow: so I thought of just trying to yank it out... but I didn't want to touch the source
20:09:21 <dons> cjb: Tolmach, MPJ, Sheard et al
20:09:24 <TomMD> Halgren and Leslie
20:09:24 * cjb saw an OLPC XO in the display cases at SFO on his way to China to fix OLPC hardware problems.  *wince*
20:09:44 <cjb> TomMD: ah, I don't know many Haskell people.
20:09:44 <waynemokane> mmorrow: anyway. let me know if the full output would be useful, I can get it in a jiff
20:09:46 <dons> TomMD: it's like Galois+PSU is drawing in typed lambda geeks
20:09:59 * cjb is still lurking on the periphery as far as Haskell goes.
20:10:03 <TomMD> I think I'm evidence of that
20:10:08 <cjb> (being paid to write Python isn't helping.)
20:10:14 <dons> speaking of which, next week, theorem proving tutorial at galois!  http://www.galois.com/blog/2008/09/11/theorem-proving-for-verification/
20:10:16 <lambdabot> Title: Galois › Blog › Blog » Theorem Proving for Verification, http://tinyurl.com/45wzmg
20:10:17 <TomMD> cjb: What?  You don't program Haskell for your day job?
20:10:25 <dons> come along at 10.30 tuesday to learn how to verify your programs.
20:10:26 <cjb> TomMD: shocking, I know.
20:10:37 <TomMD> dons: Isabelle?
20:10:45 <cjb> I get in late Tuesday.  But I've been to theorem-proving lectures before.  :)
20:10:54 <dons> TomMD: it's harrison, i'm not sure he's an isabelle guy, is he?
20:11:01 <cjb> (yours will probably be better, though)
20:11:13 <dons> didn't he write HOL Light?
20:11:19 <bitrot> dons: btw: any news on getting the galois tech talks video-recorded an posted on teh web?
20:11:30 <dons> bitrot: i'm working on it.
20:11:43 <dejones> dons: I'm taking a course on Model Checking this semester.  :)
20:11:52 <bitrot> dons: fantastic!  bated breath, and all..
20:12:13 <dons> yeah, we have some seriously good talks, so only makes sense to stick 'em online
20:12:16 <HaskellDesperate> Hey all, I'm desperate, please help me with Text.Regex.Base and MatchResult, promise gonna love Haskell then
20:12:28 <dejones> dons: I definitely would love to see the talks video recorded.  ;)
20:12:41 <dons> HaskellDesperate: you'll need to describe your problem first.
20:12:57 * dons would like to see the formal methods community writing more haskell systems.
20:12:57 <TomMD> HaskellDesperate: Feel free to use hpaste.org for code.
20:13:00 <mmorrow> waynemokane: hmm. all i can think of is either (1) gcc3.4 is rejected it while a newer gcc would accept it, or (2) doing that is some c extension which isn't turned on when it should be (somehow). i can't think of anything else it could be.
20:13:08 <dons> all these legacy ml and ocaml apps boo boo
20:13:15 <HaskellDesperate> cool, thanks, give a second
20:13:20 <mmorrow> waynemokane: maybe just expanding the macro by hand'll work?
20:13:36 <mmorrow> (or building with a newer gcc?)
20:13:43 <dejones> dons: I hope to use Haskell for my Model Checking course projects.  I'll let you know if anything useful code is created.
20:13:44 <TomMD> dons: The main issue I see with industrial FM and Haskell is much of the industrial FM runs on embedded hardware - as in architectures that GHC doesn't support and are memory constrained.
20:14:19 <dons> yeah, a solution there. like a more visible cross compiler, would help.
20:14:20 <TomMD> The Ada guys at the last HCSS were all happy as clams.
20:14:41 <dons> dejones: right, i'd not be surprised if most *new* FM systems are in haskell
20:14:57 <dons> just the large, heavy old ones are ML-ish, with their mid-early 90s history
20:15:06 <mmorrow> waynemokane: nice. you should be able to just kill that macro, since...
20:15:08 <mmorrow> #ifdef THREADED_RTS
20:15:08 <mmorrow> # define THREADED_BUILD_ONLY(x)      x
20:15:08 <mmorrow> #else
20:15:08 <dons> TomMD: fixing up the Arm backend would be useful.
20:15:13 <HaskellDesperate> ok ready, I can't make compile this code http://hpaste.org/10295
20:15:18 <HaskellDesperate> help me please
20:15:27 * dons just finished uploading 10 Haskell apps and libs to Arch.
20:15:27 <dejones> dons: Ah.  Yah, I was surprised my prof was familiar with Haskell.  He's one of the few at my university who has heard of it.  ;)
20:15:47 <dejones> dons: Not a lot of functional programmers at my uni.
20:16:08 <dejones> I think this GLUT issue is going to make me pull my hair out.  :(
20:16:20 <dons> TomMD: so we'll have to do some awesome projects together once you're here :)
20:16:37 <dons> time to think about how to take over the world
20:16:41 <dejones> lol
20:16:49 * dejones wants to be included in world domination!
20:17:00 <dons> you gotta move to portland, Or first :)
20:17:04 <dons> OR.
20:17:06 <dejones> but included in the dominating, not included in being dominated.  ;)
20:17:07 <dejones> ha
20:18:05 <dejones> dons: Well, I already accepted a job with NVIDIA in their Compilers group.  Honestly, I would have applied at Galois, but my long-term gf didn't want to move to Portland.  We are moving to Austin, TX -- she demanded warm weather, heh.
20:18:20 <dons> oh, interesting.
20:18:25 <dons> going to work on haskell on gpus then? :)
20:18:47 <TomMD> dons: I look forward to it!  I've had a desire to get Haskell running on a portable, such as Nokia N800, for a while now.
20:18:56 <dons> TomMD: yeah, and the iphone.
20:18:59 <dejones> dons: I am going to try.  That's not my job, but since Sean Lee was doing some of that work, I am hoping they let me do some Haskell work too.
20:18:59 <TomMD> Keeping it maintained would be great.
20:19:00 <dons> lots of fun opportunties there
20:19:15 <dons> TomMD: just need a few devices, some motivation, and a bit of time.
20:19:21 <dejones> I shall try.  :)
20:19:26 <mmorrow> waynemokane: weird. actually, it seems like the arg list actually /isn't/ terminated.
20:19:34 <bitrot> dejones: Austin, TX FTW!
20:19:36 * dejones would be very happy to be the "Haskell guy" at NVIDIA, hehe.
20:19:39 <dejones> bitrot: YEP!
20:19:57 <bitrot> dejones: there's an AustinFP google-group...
20:20:24 <bitrot> dejones: small, but some interesting stuff + pub afterwards..
20:20:24 <dejones> bitrot: Awesome.  I don't move until January though.  I have to finish this semester.  I will definitely check it out.
20:20:32 <dejones> bitrot: You in Austin?
20:21:00 <bitrot> dejones: yep!
20:21:18 <dejones> bitrot: Cool, definitely have to meet up some time, particularly the FPers group.
20:21:23 <dejones> bitrot: you at univ?
20:21:28 <dejones> UT austin?
20:21:36 <waynemokane> mmorrow: how do you mean?
20:22:12 <bitrot> dejones: nope, past that, got a (ducks) java job ATM in financial services..
20:22:41 <dejones> bitrot: lol, jjjjaaaavvvvvaaaa,, noooo
20:22:43 <dejones> hehe
20:23:00 <mmorrow> waynemokane: maybe try:  cp -f rts/RtsFlags.c rts/RtsFlags.c.bak; cat rts/RtsFlags.c | sed -r 's/THREADED_BUILD_ONLY\([\s\t]*$/THREADED_BUILD_ONLY()/g' > a; mv -f a rts/RtsFlags.c;
20:23:54 <TomMD> HaskellDesperate: Sorry no ones answering you - I looked and, not being a Haskell regex user, don't know off the top of my head.  Fwiw, there is a new regex package (pcre-light, binding to the BSD pcre library) and a tutorial on the RWH site.
20:24:01 <mmorrow> waynemokane: looking at the code, i can't find the terminating ')', and since you're building with the threaded runtime enabled, that macro is useless because it's the identity in this case
20:24:03 <waynemokane> mmorrow: hmm let me ponder that a moment
20:24:24 <waynemokane> mmorrow: and the gcc thing is weird too... found some post online where a gcc dev was saying it was "fixed" in 3.2, I'm on 3.4
20:24:39 <waynemokane> "fixed" in quotes because it actually isn't part of the C standard so there was never anything wrong, per se
20:25:19 <mmorrow> waynemokane: hmm. here, though, we could sidestep that issue completely though, since that macro does nothing in this case
20:25:26 <waynemokane> mmorrow: wait you're saying that actual C file has a bug in it?
20:25:28 * TomMD is falling a sleep and can't keep typing.
20:25:46 <mmorrow> waynemokane: that's what i'm thinking. the odd thing is though, it built fine for me.
20:26:17 <mmorrow> but, since that macro is doing nothing here, i'm thinking it'll be fine to disable it
20:26:36 <dejones> mmorrow: Which C file?
20:26:44 <mmorrow> RtsFlags.c
20:26:51 <mmorrow> that sed command should do it
20:26:52 <dejones> mmorrow: I've built GHC HEAD many times lately with threaded Way and it builds fine fo rme.
20:27:07 <mmorrow> dejones: yeah, the problem is with gcc and macros
20:27:11 <mmorrow> http://hpaste.org/10252
20:27:14 <waynemokane> mmorrow: ok... well so much for going to bed early
20:27:18 <waynemokane> mmorrow: gonna log in and try this
20:27:24 <dejones> mmorrow: There should not be a bug in RtsFlags.c -- it builds fine for me with threaded Way.  I'm building GHC HEAD for my parallel profiling code.
20:27:37 <mmorrow> his gcc is rejecting this macro, but that doesn't actually even matter because the macro in question happens to do nothing
20:28:01 <mmorrow> this is the full macro def
20:28:18 <mmorrow> (warning this is 5-6 lines, apologies ahead of time)
20:28:23 <mmorrow> #ifdef THREADED_RTS
20:28:24 <mmorrow> # define THREADED_BUILD_ONLY(x)      x
20:28:24 <mmorrow> #else
20:28:24 <mmorrow> # define THREADED_BUILD_ONLY(x) \
20:28:24 <mmorrow> errorBelch("not built for: -smp"); \
20:28:24 <mmorrow> error = rtsTrue;
20:28:26 <mmorrow> #endif
20:28:28 <mmorrow> sorry
20:29:01 <HaskellDesperate> thanks guys, basically what I want to know is how to read the documentation at http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html. What does mean RegexLike a b => RegexContext a b (MatchResult b)
20:29:03 <mmorrow> oh, and backup RtsFlags.c first :)
20:29:05 <lambdabot> Title: Text.Regex.Base.Context, http://tinyurl.com/yovda9
20:29:21 <dejones> mmorrow: I'm very familiar with RtsFlags.c -- I had to modify it to add my flag for parallel profiling.  ;)
20:29:36 <mmorrow> dejones: oh cool. what do you think's going on?
20:30:02 <mmorrow> do you think waynemokane should do what i just suggested?
20:30:29 <dejones> mmorrow: Sorry, I missed what you suggested...
20:30:56 <mmorrow> essentially a hackish way to add a closing paren so his gcc is fooled
20:31:09 <mmorrow> oh, actually wait, it depends on if this is valid
20:31:18 <mmorrow> THREADED_BUILD_ONLY()
20:31:21 <mmorrow> ?
20:31:27 <dejones> mmorrow: it is valid.  you want it to build with the thr Way.
20:31:40 <mmorrow> but is an empty arg list valid?
20:31:51 <dejones> mmorrow: THREADED_BUILD_ONLY(x) generates the code 'x' when thr Way is used..
20:31:53 <mmorrow> because that's what my sed command that i gave him'll di
20:31:57 <mmorrow> s/di/do/
20:32:22 <mmorrow> his gcc is complaining that there's no terminating ')' for that macro
20:33:05 <mmorrow> (i'm assuming he /is/ building with a threaded runtime also)
20:33:11 <mmorrow> s/with//
20:33:31 <dejones> mmorrow: He is building with thr Way, which should define THREADED_RTS.
20:33:52 <dejones> and that should cause THREADED_BUILD_ONLY(x) to generate code 'x'
20:34:14 <dancor> HaskellDesperate: grabbing the source helped me to understand better http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-base
20:34:16 <lambdabot> Title: HackageDB: regex-base-0.93.1, http://tinyurl.com/3zx453
20:34:53 <dancor> HaskellDesperate: @RegexContext a b c@ takes a regular expression suppied in a type 'a'
20:34:56 <dancor> generated by 'RegexMaker' and a target text supplied in type 'b' to a
20:34:59 <dancor> result type 'c' using the 'match' class function.
20:35:08 <dejones> mmorrow: THREADED_BUILD_ONLY(x) seems like a rather simple macro, I don't know why the error is occuring...
20:35:15 <mmorrow> me neither
20:35:24 <mmorrow> he gets
20:35:25 <dancor> HaskellDesperate: and that page is just a list of the different possible c's (result types)
20:35:25 <mmorrow> RtsFlags.c:1120:1:
20:35:25 <mmorrow>      directives may not be used inside a macro argument
20:35:31 <mmorrow>  unterminated argument list invoking macro "THREADED_BUILD_ONLY"
20:35:36 <mmorrow> `THREADED_BUILD_ONLY' undeclared (first use in this function)
20:36:19 <dejones> mmorrow: What version of gcc?
20:36:32 <waynemokane> dejones: 3.4
20:36:40 <HaskellDesperate> dancor: so parse s = (s =~ oneLine :: MatchResult String) should work right?
20:37:04 <dejones> waynemokane: Have you tried a different version of gcc...?
20:37:17 <dejones> waynemokane: I'm using gcc 4.2.3
20:37:20 <waynemokane> dejones: I could also try 3.2, but I haven't
20:37:29 <mmorrow> waynemokane: err, actually looking at that c file more, my sed thing probably won't work
20:37:30 <waynemokane> dejones: yeah unfortunately I can't (easily) do 4.x at the moment
20:37:45 <mmorrow> it's definitely gcc doing weird things though
20:37:56 <waynemokane> I guess I could try building for x86_64
20:38:00 <waynemokane> that would let me use gcc 4
20:38:16 <dejones> waynemokane: http://gcc.gnu.org/ml/gcc-patches/2000-02/msg00073.html
20:38:19 <lambdabot> Title: fix cpp segmentation fault with perverse input
20:38:23 <waynemokane> I think I would have to re-bootstrap ghc 6.6 for that architecture though
20:38:40 <mmorrow> my best guess is it's not seeing the terminating ')', then thinking two macros are nested, OR there /are/ two nested macros, and this is making gcc not see the terminating ')'
20:38:40 <dejones> waynemokane: That seems to explain that the no_directives flag is in use...?
20:38:45 <sjanssen> bootstrapping works with ghc 6.6?
20:39:09 <waynemokane> sjannsen: yeah I used the "i386-unknown-linux" tarball and got 6.6 going
20:39:13 <mmorrow> sjanssen: he's building 6.8 with 6.6
20:39:20 <waynemokane> with only minor "tweaks" to work in our weird filesystem
20:40:50 <mmorrow> i guess just mess with the macros to make it work then
20:41:14 <waynemokane> ok, so in summary, possibly try messing with the macros
20:41:16 <mmorrow> and hope there aren't a ton of places with macro problems
20:41:24 <waynemokane> and otherwise try using a newer gcc
20:41:34 <mmorrow> waynemokane: yes, that's my personal opinion :)
20:41:59 <mmorrow> and what i would do
20:42:26 <waynemokane> the weird thing is... I got that same error further up for another file but it didn't seem to error..
20:42:41 <waynemokane> I guess I could try pasting the full output somewhere
20:42:54 <dejones> waynemokane: I'd try new version of gcc before changing those macros.  I think they are used often in that file.
20:43:09 <dejones> waynemokane: Also, look into the -fdirectives-only gcc flag.  I think that may be related, but hard to tell.
20:43:17 <mmorrow> yeah, this looks like some combination of things is causing the error
20:44:25 <mmorrow> and for the record, there /is/ a terminating ')'
20:44:37 <mmorrow> so it's gotta be the nesting
20:44:54 <waynemokane> but it works fine from some other command... one sec
20:44:55 <dejones> mmorrow: Yah, it is the nesting, based upon the ghc mailing list patch I posted above.
20:45:10 <mmorrow> cool
20:45:25 <dejones> mmorrow, waynemokane: I think it is when the macro contains another #ifdef or similar.
20:45:28 <waynemokane> the utils/mkdependC/mkdependC command is giving the same message but it gets through it
20:45:36 <waynemokane> dejones: yeah it is
20:45:42 <mmorrow> ah, just saw your link
20:45:55 <waynemokane> dejones: but that is only supposed to affect gcc prior to 3.2... so I still don't quite understand why I'm getting it
20:46:19 <waynemokane> this method is using the gcc on my path right?  there's not something going on with the fact that the command is ghc-inplace ?
20:46:24 <waynemokane> from my bootstrapped 6.6
20:46:29 <dejones> waynemokane: Yeah..  Well, I definitely know that it builds fine with gcc 4.2.3 and ghc6 on GHC HEAD.  ;)
20:46:56 <waynemokane> crap... newest we have disted is 4.1, and on a different platform
20:47:01 <waynemokane> *sigh
20:47:20 <mmorrow> i built successfully with gcc4.1.2
20:47:37 <waynemokane> ok I'll try bootstrapping a different 6.6, for a different architecture, so that I can try making 6.8.3 with ghc 4
20:47:45 <waynemokane> or just be happy with 6.6 and get back to my day job
20:47:52 <waynemokane> decisions, decisions
20:47:53 <dejones> waynemokane: Sorry couldn't help more...
20:47:53 <dejones> hehe
20:48:03 <dejones> I gotta get back to trying to fix Haskell OpenGL package.  :(
20:48:04 <dancor> HaskellDesperate: idk about parse and =~, what package are they in
20:48:11 <dancor> HaskellDesperate: main = print ((match (makeRegex ".*" :: Regex) "a") :: Bool)
20:48:15 <dancor> is an example tho
20:48:19 <waynemokane> dejones: no, thanks a ton for your help and insights
20:48:24 <waynemokane> mmorrow: you too
20:48:35 <mmorrow> waynemokane: :) good luck
20:48:36 <dejones> waynemokane: np.  good luck!
20:48:55 <dejones> waynemokane: That code I've looked at many, many days lately.. hehe.
20:49:02 <dejones> Glad I could help some.
20:49:45 <dancor> > match (makeRegex ".*" :: Regex) "a" :: Bool
20:49:47 <lambdabot>   mueval: Prelude.read: no parse
20:50:03 <mmorrow> dejones: since you're right here... do you happen to know what's happened to the ghc package in HEAD?
20:50:23 <mmorrow> as in ghc-pkg list ghc returns no results
20:50:35 <dancor> > (match (makeRegex ".*" :: Regex) "a") :: Bool
20:50:36 <lambdabot>   mueval: Prelude.read: no parse
20:51:00 <dejones> mmorrow: one sec, let me try my built GHC HEAD ghc-pkg
20:51:06 <mmorrow> cool
20:52:32 <waynemokane> by the way, what OS/arch are you guys building on?
20:52:49 <HaskellDesperate> dancor: thanks, gonna try it
20:52:52 <mmorrow> Linux ganon 2.6.25.9-40.fc8 #1 SMP Fri Jun 27 16:25:53 EDT 2008 i686 GNU/Linux
20:53:02 <Olathe> > 5
20:54:09 <waynemokane> what do you think I'll have the most luck with - ia32.linux.2.4.glibc.2.3  ,   amd64.linux.2.4.glibc.2.3  ,  ia32.linux.2.6.glibc.2.3   , x86_64.linux.2.6.glibc.2.3    ?
20:54:09 <dejones> mmorrow: Worked for me.  I haven't updated in a couple of days though, so it could have been broken very recently.  I sent you a PM with the output.
20:54:24 <mmorrow> cool, thx
20:54:34 <waynemokane> first bit being arch, then OS, then kernel version, then glibc ver
20:54:35 <mmorrow> (my ghc is from 20080821)
20:54:53 <waynemokane> all are Redhat EL 3.0 or 4.0
20:55:23 <lambdabot>   thread killed
20:55:41 <dejones> waynemokane: Which ever glibc goes with gcc 4.x.x?
20:55:44 <dejones> heh.
20:57:24 <mmorrow> waynemokane: hmm, i'd i was actually able to build 6.8.3 with 6.4 and gcc version 3.4.6 20060404 (Red Hat 3.4.6-9)
20:57:32 <mmorrow> s/i'd i/i/
20:57:40 <mmorrow> without any issues
20:58:32 <waynemokane> it seems that glibc 2.3 is going with gcc 4.1
20:58:33 <dejones> I gotta get some sleep.
20:58:40 <dejones> g'night waynemokane, mmorrow, bitrot
20:58:45 <mmorrow> night
20:58:46 <Olathe> @pl (\(a, b, c) -> (a, b))
20:58:46 <lambdabot> (line 1, column 8):
20:58:46 <lambdabot> unexpected ","
20:58:46 <lambdabot> expecting letter or digit, operator or ")"
20:58:46 <lambdabot> ambiguous use of a non associative operator
20:59:00 <Olathe> > (\(a, b, c) -> (a, b)) (1, 2, 3)
20:59:02 <lambdabot>   (1,2)
20:59:27 <mmorrow> waynemokane: that machine i just referenced has libc-2.3.4
20:59:28 <waynemokane> goodnight!
21:02:26 <waynemokane> actually... wow wtf.. now I am starting to wonder whether this was even using 3.4 to begin with or 3.2
21:02:44 <waynemokane> looks like I have to get some stuff straight on my side before bugging you guys anymore
21:03:32 <waynemokane> that machine -what processor arch is it?
21:07:44 <waynemokane> mmorrow: also which kernel version, if you please
21:09:25 <mmorrow> waynemokane: 2.6.9-023stab046.2-enterprise #1 SMP Mon Dec 10 15:22:33 MSK 2007 i686 i686 i386 GNU/Linux
21:10:08 <waynemokane> mmorrow: what did you run to get that output?
21:10:11 <mmorrow> i'll paste the other info
21:10:16 <mmorrow> uname -a
21:10:20 <waynemokane> aahok, thanks
21:14:50 <mmorrow> waynemokane: http://hpaste.org/10296
21:15:57 <waynemokane> mmorrow: awesome, this is going to be very helpful
21:16:05 <waynemokane> but sadly I still don't understand the CPU arch from this
21:16:11 <waynemokane> is it Intel 32 bit or 64?:
21:16:32 <mmorrow> i believe 32
21:16:57 <mmorrow> Xeon are weird though, i think they have some 64 features or some such thing
21:16:58 <waynemokane> mmorrow: all right, excellent, I should be able to find one of our servers with roughtly this same config
21:17:07 <mmorrow> cool
21:17:18 <waynemokane> mmorrow: turns out I was trying this 6.8.3 build against gcc 3.2 the entire time
21:17:37 <mmorrow> heh.
21:18:01 <waynemokane> mmorrow: and our build system doesn't warn you... even though I explicitly asked for gcc 3.4, it wasn't on my platform so my request was just ignored (no error) and it went on happily with /usr/bin/gcc
21:18:35 <mmorrow> haha, gotta love it though
21:18:50 <waynemokane> anyway... my boss it out of town tomorrow so maybe I'll find a couple hours of "free time" to mess with this some more :)
21:19:11 <waynemokane> mmorrow: thanks again!  if you ever come to Chicago I will buy you a beer
21:19:16 <mmorrow> sweet, good luck. looks like you're in the clear :)
21:19:17 <mmorrow> np
21:19:56 <mmorrow> waynemokane: awesome. i'm actually from chicago originally. i may take you up on that ;)
21:27:30 <dejones> http://www.haskell.org/pipermail/haskell-cafe/2008-September/047357.html --- Here is a more detailed description of the linker errors and other issues I am having with a Haskell OpenGL / GLUT program.  Any replies would be great.  :)
21:27:33 <lambdabot> Title: [Haskell-cafe] Linker Errors For OpenGL / GLUT 'Hello World' Program., http://tinyurl.com/4ozvpr
21:27:39 <dejones> G'night everyone.
21:28:17 <dejones> dons: I posted to the mailing list, see description above.  Maybe you can help with your infinite wisdom of Haskell and packages.  ;)
21:28:36 <dejones> Ok, really going to sleep now.  ZzZzZz...
21:42:46 <Myoma> ?go HOL Light in the type system
21:42:52 <Myoma> no results :(
21:43:00 <lambdabot> http://www.cs.ru.nl/~freek/mizar/miz.pdf
21:43:00 <lambdabot> Title: Mizar Light for HOL Light
21:47:44 <Myoma> > let l = [1,2,3,4] in do (h:t) <- inits l ; b <- t ; return (h,b)
21:47:48 <lambdabot>   [(1,2),(1,2),(1,3),(1,2),(1,3),(1,4)]
21:47:57 <Myoma> > let l = [1,2,3,4] in do (h:t) <- tails l ; b <- t ; return (h,b)
21:47:58 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
21:51:45 <Olathe> @undo do (h:t) <- tails l ; b <- t ; return (h,b)
21:51:46 <lambdabot> tails l >>= \ a -> case a of { (h : t) -> t >>= \ b -> return (h, b); _ -> fail ""}
21:57:17 <kaol> > ['a','a'..]
21:57:18 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:57:29 <bd_> > fix ('a':)
21:57:30 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:58:32 <kaol> > ['a'..]
21:58:34 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
21:58:37 <Olathe> > repeat 'a'
21:58:38 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:59:15 <Olathe> > map (const 'a') [1,5..]
21:59:16 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:59:50 <kaol> > ['\SOH'..]
21:59:51 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
22:08:39 <Olathe> > say $ concat $ intersperse ", " $ map (\(n, desc) -> show n ++ ":" ++ desc) $ filter (\(n,desc) -> show n /= desc) $ filter (not.null.snd) $ map (\x -> (ord x, drop 2.reverse.drop 1.reverse.show $ x)) ['\0'..(maxBound :: Char)]
22:08:46 <lambdabot>   0:NUL, 1:SOH, 2:STX, 3:ETX, 4:EOT, 5:ENQ, 6:ACK, 7:a, 8:b, 9:t, 10:n, 11:v,...
22:10:57 <dolio> > ['\SO', 'H']
22:10:58 <lambdabot>   "\SO\&H"
22:11:55 <Olathe> > ord '\&'
22:11:56 <lambdabot>       lexical error in string/character literal at character '\''
22:12:07 <dmwit> > say . concat $ [n ++ ':':filter isAlpha (chr n) | n <- [0..]]
22:12:08 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
22:12:10 <dolio> '\SO\&' is one character.
22:12:18 <dmwit> > say . concat $ [show n ++ ':':filter isAlpha (chr n) | n <- [0..]]
22:12:19 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
22:12:21 <Olathe> > map (\a -> [a]) ['\SO', 'H']
22:12:22 <lambdabot>   ["\SO","H"]
22:12:25 <dolio> The same character as '\SO' actually.
22:12:36 <Olathe> > ord '\SO'
22:12:38 <lambdabot>   14
22:12:48 <dmwit> > ord '\SOH'
22:12:50 <lambdabot>   1
22:12:57 <dolio> But it's there to differentiate the string '\SOH':[] from the string '\SO':'H':[]
22:13:07 <Olathe> Oh.
22:13:12 <dmwit> > say . concat $ [show n ++ ':':filter isAlpha (show . chr $ n) | n <- [0..]]
22:13:14 <lambdabot>   0:NUL1:SOH2:STX3:ETX4:EOT5:ENQ6:ACK7:a8:b9:t10:n11:v12:f13:r14:SO15:SI16:DL...
22:13:16 <Olathe> Quite odd.
22:13:21 <dmwit> oh, right
22:13:34 <dmwit> > say . concat $ [show n ++ ':':filter isAlpha (show . chr $ n) ++ ", " | n <- [0..]]
22:13:35 <lambdabot>   0:NUL, 1:SOH, 2:STX, 3:ETX, 4:EOT, 5:ENQ, 6:ACK, 7:a, 8:b, 9:t, 10:n, 11:v,...
22:16:07 <dmwit> > say . concat $ [0..] >>= \n -> [show n, ":", filter isAlpha . show . chr $ n, ", "]
22:16:09 <lambdabot>   0:NUL, 1:SOH, 2:STX, 3:ETX, 4:EOT, 5:ENQ, 6:ACK, 7:a, 8:b, 9:t, 10:n, 11:v,...
22:38:44 <xpika> how do you interpret infixl or infixr?
22:41:35 <sjanssen> infix left, infix right
22:42:57 <xpika> but how does it translate to the order of operations?
22:43:43 <dolio> The number tells you the precedence. Higher numbers bind tighter than lower numbers.
22:44:08 <dolio> The l or r tells you which way multiple operations of the same precedence associate.
22:44:28 <dolio> so a * b * c is (a * b) * c for infixl, and a * (b * c) for infixr.
22:44:58 <dolio> You can't mix l and r of the same precedence.
22:45:15 <dolio> Without explicit parentheses, that is.
22:47:36 <xpika> dolio: since (*) has the associative law it doesnt really matter?
22:48:10 <dolio> (*) isn't really guaranteed to be associative, I think.
22:48:22 <dolio> But, if you'd rather, take (+) as an example.
22:48:30 <quicksilver> xpika: it's doesn't matter much, in theory.
22:48:34 <quicksilver> xpika: the compiler doesn't know this, though.
22:48:38 <dolio> It's not associative for Float/Double.
22:48:43 <xpika> dolio: (+) is also associative
22:48:44 <quicksilver> so the compiler still behaves in a particular way.
22:49:29 <quicksilver> (+) also fails to be perfectly associative for floating point types
22:52:14 <xpika> quicksilver: (/) is a good example
22:52:45 <quicksilver> xpika: no, it's not.
22:52:52 <quicksilver> xpika: it's a bad example of the point I'm making.
22:53:02 <xpika> quicksilver: :o
22:53:10 <quicksilver> xpika: the point I'm making is that, even those operations which are mathematically associative
22:53:15 <quicksilver> are not, on computers.
22:53:21 <quicksilver> for fixed-precision types.
22:53:35 <quicksilver> so, the compiler does not assume associativity or act upon it.
22:57:07 <xpika> > 1.0*(2.0*3.0) == (1.0*2.0)*3.0
22:57:09 <lambdabot>   True
22:57:12 <dolio> > 1e38 * (10 * 0.1) :: Float
22:57:14 <lambdabot>   1.0e38
22:57:20 <dolio> > (1e38 * 10) * 0.1 :: Float
22:57:21 <lambdabot>   Infinity
22:59:04 <quicksilver> > 1 + (1e-16 + 1e-16)
22:59:05 <lambdabot>   1.0000000000000002
22:59:07 <quicksilver> > (1 + 1e-16) + 1e-16
22:59:08 <lambdabot>   1.0
23:10:11 <dolio> > (9223372036854775807 * 2) * 0.5 :: Ratio Int
23:10:12 <lambdabot>   (-1)%1
23:10:24 <rmdashrf> Does anyone know of any package using HaskellDB?  All the code I've found in my haphazard Googling has been snippets, and vague mentions of API changes and whatnot.  I've managed to install 0.11 but haven't got it figured out.
23:10:28 <dolio> > 9223372036854775807 * (2 * 0.5) :: Ratio Int
23:10:30 <lambdabot>   9223372036854775807%1
23:14:21 <roconnor> > 2^50
23:14:22 <lambdabot>   1125899906842624
23:14:29 <roconnor> :/
23:14:37 <roconnor> that seems like a big number
23:14:47 <dolio> Not that big.
23:14:47 <roconnor> > sum [1..2^50]
23:14:57 <roconnor> can I sum that many terms?
23:15:03 <lambdabot>   thread killed
23:15:07 <thoughtpolice> apparently not
23:16:12 <dolio> > 2^49 * (2^50 + 1)
23:16:16 <lambdabot>   633825300114115263698305024000
23:17:04 <olsner> roconnor: that'd take 13 days at 1 GHz
23:17:18 <roconnor> olsner: ah
23:17:25 <roconnor> too slow :)
23:17:29 <roconnor> stupid exponential growth
23:17:44 <bd_> olsner: assuming how many cycles per loop?
23:17:48 <bd_> or term rather
23:17:53 <olsner> well, it is the exponential function... go figure it grows exponential :P
23:17:55 <roconnor> I wonder how people compute expected values in real life?
23:18:01 <roconnor> run simulations?
23:18:18 <dolio> > (2^50) / 1000 / 60 / 60 / 24
23:18:20 <lambdabot>   1.3031248921789631e7
23:18:28 <dolio> > (2^50) / 1000 / 60 / 60 / 24 / 1^9
23:18:30 <lambdabot>   1.3031248921789631e7
23:18:47 <roconnor> 10^9
23:18:51 <dolio> Oh, right.
23:19:01 <dolio> I should remove the 1000, too.
23:19:10 <olsner> bd_: assuming a single cycle per loop
23:19:22 <jbapple> Does anyone know how to build haddock for Base?
23:19:52 <olsner> i.e. that's GHz measuring terms per second :P
23:29:07 <sicp> how can i implement if in haskell?
23:29:23 <ibid> use the builtin if?
23:29:31 <sicp> like what are the construtcs? i mean impkementing my own if without using the builtins
23:29:34 <ibid> or guards, or pattern matching
23:29:52 <ibid> depends on what you consider cheating :)
23:29:54 <sicp> i dont need if, i just want to implement it
23:30:06 <sicp> yes but how is if implemented in haskell?
23:30:18 <ibid> it's syntax
23:30:20 <sicp> what are the underlying constructs?
23:30:23 <ibid> compiler magic
23:30:30 <sicp> no not according to spj
23:30:34 <ivanm> @src if
23:30:34 <lambdabot> Source not found. There are some things that I just don't know.
23:30:37 <ivanm> @src if'
23:30:37 <lambdabot> Source not found. Do you think like you type?
23:30:42 <sicp> at least you could implement it without magic he says
23:30:50 <jamii__> if True then else = then; if False then else = else
23:30:51 <ibid> sicp: oh, sure
23:30:55 <bd_> the 'if' in haskell requires special parsing
23:31:01 <ibid> sicp: but in real life it's part of the syntax
23:31:09 <ibid> sicp: and thus compiler magic
23:31:11 <bd_> you could make something similar with different syntax using pattern matching
23:31:24 <bd_> indeed, internally it gets turned into a case in GHC, I believe
23:31:41 <ibid> sicp: but as i said, you'll need to specify what's cheating before we can tell you what alternative to use
23:32:23 <ibid> sicp: because if E then E' else E'' is just syntax for case E of True -> E' ; False -> E'', but that might be cheating, depending on what you want to achieve
23:33:27 <slarba> does ghc core have if? I think it converts to case expression
23:33:40 <ibid> sicp: if you want to use the predefined Bool type, that's the best you can do in terms of primitive constructs. but if you want to do function gymnastics, you can of course use the standard Church encodings, i believe
23:33:53 <ibid> slarba: the core probably uses the case expression
23:36:02 <sicp> jamii: is your example supposed to compile? it get sparse error on input else
23:36:19 <bd_> GHC core just has case, let, apply, and lambda, I thought?
23:36:48 <sicp> is that the functional language between ghc and the machine your are talking about?
23:36:53 <slarba> yes
23:37:09 <ibid> not sure if the use of "the" is appropriate there
23:37:33 <ibid> but core is the "stripped down" language ghc uses for most of its procsesing
23:37:44 <sicp> ok
23:37:50 <thoughtpolice> bd_: correct - let is the lazy construct, case evaluates something, and application and lambda are obvious
23:37:56 <waynemokane> does anyone know, in ghc 6.8.3, which gmake target creates the final scripts?
23:41:18 <mmorrow> rmdashrf: are you still there?
23:43:41 <jamii> sicp: Ooops - if, then and else are keywords. So it would need to be: if' True t e = t ; if' False t e = e
23:52:05 * Beelsebob hates that def of if'
23:52:32 <Beelsebob> I'd much rather see if' = liftA3 (\c t e = if c then t else e)
23:57:52 <dancor> is there already something somewhere to do shell escaping
23:58:16 <dancor> f "a'b" = "'a'\\''b'"
23:58:33 <dancor> or it could just do \ for &,|,etc
