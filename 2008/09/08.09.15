00:02:45 <jinjing> @bot
00:02:45 <lambdabot> :)
00:13:51 <Armored_Azrael> Hey, anyone know what the push/pop matrix level action is in hopengl?
00:15:48 <thoughtpolice> Armored_Azrael: http://hackage.haskell.org/packages/archive/OpenGL/2.2.1.1/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html
00:15:50 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.CoordTrans, http://tinyurl.com/66y4tc
00:17:10 <Armored_Azrael> That's where I thought it would be, but the only thing I see that's related is preservingMatrix
00:17:57 <Baughn> Armored_Azrael: withMatrix?
00:18:30 <Baughn> Armored_Azrael: Or preservingMatrix, or..
00:20:00 <Armored_Azrael> Hm.
00:20:16 <Baughn> Well, a primitive pushMatrix does seem to be missing
00:20:27 <Armored_Azrael> Baughn: Yes, those are what I was looking for
00:20:37 <Baughn> Armored_Azrael: Read preservingMatrix's source
00:20:41 <Armored_Azrael> ok
00:22:26 <Armored_Azrael> OK, looks like I'll have to manually re-export them
00:22:47 <Baughn> Or do without 'em
00:23:09 <Baughn> Do you intend to push without popping, or.. why won't preservingMatrix do?
00:24:41 <Armored_Azrael> preservingMatrix won't do because I'm hoping to use one action in my main function to set up the scene, which involves placing a few things on the card and also setting up the camera and view angle transforms
00:24:53 <Armored_Azrael> Then I'm going to set up a callback that updates other things
00:24:56 <Armored_Azrael> (using GLUT)
00:25:10 <cad1> does anyone know of a good, concise language reference for haskell?
00:25:19 <Armored_Azrael> So if I were to use preservingMatrix, somehow each time the callback were called, it would need to have the preservingMatrix context somehow
00:25:53 <Baughn> installCallback (preservingMatrix foo)?
00:27:40 <Armored_Azrael> Wow. I'm retarded
00:27:41 <Armored_Azrael> Thanks
00:29:09 <Armored_Azrael> Wait, one thing still--how will I be able to keep my the transform installed in my setup function separate from the transform for when the viewing angle changes?
00:29:17 <Armored_Azrael> Wouldn't that require a push without a pop?
00:29:30 <olsner> oh great, I need the full pathname of argv[0], but getProgName helpfully removes the directory component
00:34:23 <yitz> cad1: http://www.haskell.org/onlinereport/
00:34:24 <lambdabot> Title: The Haskell 98 Language Report
00:42:12 <yitz> olsner: yeah, getProgName is meant to be portable, and I don't see any built-in access to argv in System.Posix.
00:42:56 <yitz> olsner: I guess if you really need this you may need to use FFI.
00:43:25 <cad1> thankyou yitz
00:49:15 <yitz> olsner: this sounds like something that would be trivial to add to System.Posix. If you think it should be there, maybe you should post to libraries.
00:51:12 <yitz> cad1: unfortunately the Report assumes some familiarity with some terms that are obscure outside the functional community.
00:52:15 <yitz> cad1: Read the introduction. If you then have any questions, ask here. or on the haskell-cafe or haskell-beginners list.
00:53:00 <yitz> cad1: also: there are some newer features that have become more or less standard since then.
00:53:46 <yitz> cad1: the best place to look for those is in the section of the GHC manual called "GHC Extensions".
00:54:14 <yitz> cad1: however, not all of those extensions are at all standard, some are very esoteric and hardly used (or understood).
00:54:28 <yitz> cad1: again, if you have questions, ask the community.
00:55:48 <yitz> cad1: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
00:55:50 <lambdabot> Title: Chapter�8.�GHC Language Features, http://tinyurl.com/kf2g3
00:56:51 <Myoma> ?version ghc
00:56:51 <lambdabot> lambdabot 4.2.1
00:56:51 <lambdabot> darcs get http://code.haskell.org/lambdabot
00:57:24 <yitz> cad1: another difference is that the "standard libraries" has undergone vast changes from what is in the Report.
00:59:17 <cad1> is the syntactic structure most that described in the report?
00:59:47 <Cale> It's been extended in some ways by GHC, but mostly.
01:00:20 <cad1> I'm really enjoying the report so far
01:01:26 <cad1> it's more precise than the tutorials I've been using
01:01:27 <yitz> cad1: glad to hear that! it took me a long time before I could appreciate its beauty.
01:01:46 <yitz> cad1: about the same amount of time it took me to learn to appreciate fine wine.
01:04:03 <cad1> it feels like haskell has been waiting for me for a long time : )
01:04:07 <yitz> cad1: I also enjoy learning from ref guides more than from tutorials.
01:06:09 <olsner> yitz: hmm, I'll be doing an FFI hack for now, but may revisit the issue later and come up with something like a patch for posix
01:07:22 <Myoma> does anyone have a good name for  forall x:X, P x -> Y  , it's sort of like X -> Y but partial
01:08:15 <cad1> "for all x such that a predicate on x is true, some fixed y"?
01:08:23 <stanv> hello, why is it necessary to write in ghci `let' each time ?
01:08:39 <Korollary> Tutorials waste time in the long term.
01:09:06 <Zao> stanv: No particular reason at all, I believe.
01:09:12 <stanv> why I can't define variable type in ghci using `::'
01:09:19 <cad1> Myoma: is that what your statement translated to?
01:09:26 <jinjing> stanv: since you are inside IO monad?
01:09:28 <Cale> stanv: You aren't really meant to write your program at the ghci prompt.
01:09:53 <Cale> stanv: Rather, the normal thing to do is to write definitions into a file, and load the file into ghci
01:10:05 <Myoma> cad1: yes
01:10:11 <Cale> Whenever you save changes to the file, :r  in ghci will reload it.
01:10:30 <stanv> hm... it's to wearily says :reload
01:10:49 <Myoma> it's like  f x | P x = (create a y from x)
01:11:14 <Cale> (in fact, just : on its own on a line will reload :)
01:11:15 <Korollary> :r or just : also reloads.
01:12:19 <cad1> Myoma: does it return bottom if P is false?
01:13:47 <cad1> hrm, it seems I don't know enough of how such things work in haskell yet, but it seems like it would something like   "if x is in X U
01:13:53 <cad1> err
01:14:12 <Myoma> cad1: P is always true
01:14:52 <cad1> P is a function?
01:15:01 <Myoma> I mean P of x
01:15:04 <Myoma> yeah
01:16:05 <stanv> i have one more question.... when i says: double n = n*n Why doube 2+4 return 8 and double 4+2 return 18 ?   (2+4*2+4=14; 2+4*4+2=20; 4+2*2+4=12; ther no 8 or 18)
01:16:27 <Myoma> stanv: You should try double (2+4) as well
01:16:40 <stanv> (2+4) works fine...
01:16:55 <Myoma> and (double 2)+4 is the same as double 2+4
01:16:59 <cad1> Myoma, is "If x is in X then P x else undefined" what you mean?
01:17:13 <Myoma> cad1, yeah sort of
01:17:18 <stanv> Myoma: thanks!
01:18:43 <Myoma> I wish there was a name for this
01:20:37 <cad1> well, P is a function from the set X to the set Y. The forall now makes it seem like you'd like to define the subset of Y which is mapped to from X under P... which would be the image of X under P
01:20:55 <Myoma> oh you could have P say,
01:21:01 <Myoma> :t even
01:21:02 <lambdabot> forall a. (Integral a) => a -> Bool
01:21:13 <Myoma> then you have this function only defined on even numbers as the input
01:21:24 <Myoma> so it's like X | x is even -> Y
01:21:46 <cad1> ah.
01:22:01 <Myoma> I just don't know any name for this kind of thing
01:22:19 <electronx> since the #C++ are being idiots can someone help me with a c prob
01:22:24 <cad1> yeah, some kind of filtered partial function
01:22:42 <electronx> i need a func 45/2=23
01:23:09 <Myoma> > 45`div`2
01:23:11 <lambdabot>   22
01:23:21 <Myoma> > round(45/2)
01:23:22 <lambdabot>   22
01:23:27 <Myoma> > round(45/2)+1
01:23:29 <lambdabot>   23
01:23:37 <electronx> or 11/4=3
01:23:46 <Myoma> > round(11/4)+1
01:23:47 <lambdabot>   4
01:24:14 <Myoma> > round(11/4+1/2)
01:24:16 <lambdabot>   3
01:24:19 <Myoma> > round(45/2+1/2)
01:24:21 <lambdabot>   23
01:24:27 <electronx> nice
01:24:53 <cad1> > (11.0/4.0)*(4.0/11.0)*3
01:24:55 <lambdabot>   3.0
01:25:00 <electronx> does it work in all cases?
01:25:07 <Myoma> > round(0/0+1/2)
01:25:08 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
01:25:37 <Myoma> yes it does :)
01:25:40 <Myoma> you gave two cases
01:25:45 <electronx> lol
01:26:00 <electronx> a genric solutions?
01:26:10 <Armored_Azrael> electronx: Perhaps
01:26:10 <electronx> generic, solution*
01:26:17 <Armored_Azrael> > ceiling (45 / 2)
01:26:18 <lambdabot>   23
01:26:23 <Myoma> @w80 partial
01:26:25 <lambdabot> *** "partial" wn "WordNet (r) 2.0"
01:26:25 <lambdabot> partial
01:26:25 <lambdabot>      adj 1: being or affecting only a part; not total; "a partial
01:26:25 <lambdabot>             description of the suspect"; "partial collapse"; "a
01:26:25 <lambdabot>             partial eclipse"; "a partial monopoly"; "partial
01:26:27 <lambdabot> [10 @more lines]
01:26:29 <Myoma> @w80 restricted
01:26:30 <lambdabot> *** "restricted" wn "WordNet (r) 2.0"
01:26:31 <lambdabot> restricted
01:26:33 <lambdabot>      adj 1: subject to restriction or subjected to restriction; "of
01:26:35 <lambdabot>             restricted importance" [ant: {unrestricted}]
01:26:37 <lambdabot>      2: restricted in meaning; (as e.g. `man' in `a tall man') [syn:
01:26:39 <lambdabot> [3 @more lines]
01:26:45 <electronx> i don't have access to ceiling
01:26:58 <Armored_Azrael> What are you trying to accomplish then?
01:27:05 <Myoma> C++ doesn't have C's ceil from math.h?
01:27:06 <Armored_Azrael> Just round up arithmetic?
01:27:08 <electronx> uni project
01:27:10 <Myoma> that's really dumb
01:27:36 <Armored_Azrael> Myoma: C++ does have every feature of C, so if math.h has ceil, then he has it
01:27:37 <electronx> i can't modifiy makefile to add math lib
01:28:10 <electronx> all i have is #include	<stdio.h>
01:28:10 <electronx> #include	<stdlib.h>
01:28:24 <Myoma> anyway
01:28:41 <Zao> Armored_Azrael: As ceil is C89, C++'s <cmath> has it.
01:29:04 <Armored_Azrael> So, you aren't even fully defining your problem. You gave a few inputs and outputs, but not enough to know if you just want round up arithmetic or something different.
01:29:18 <electronx> ya round up basically
01:29:26 <electronx> 23.3 = 24 etc
01:29:37 <Myoma> that's rounding down
01:29:51 <cad1> in C, x/y for x,y::Int is whole number division?
01:29:54 <Myoma> > floor(23.3+1)
01:29:56 <Armored_Azrael> If you just want ceil in C, then
01:29:56 <Armored_Azrael> int ceil(float n) { return (int) (n + 0.5);}
01:29:56 <lambdabot>   24
01:30:01 <electronx> turning 23.3 into 24 is not rounding down
01:30:06 <Myoma> cad1: yeah truncation of x by y
01:30:06 <Armored_Azrael> There, you've got ceil, let's stop discussing this inane problem.
01:30:12 <Myoma> electronx: yes it is
01:30:12 <Zao> cad1: Integer division with truncation towards zero.
01:30:21 <Myoma> electronx: trunctation
01:30:27 <Armored_Azrael> (for positive n)
01:30:44 <Myoma> electronx: (hint: What is it rounding down _from_?)
01:30:56 <cad1> so, he needs 23 and 3 from 45/2 and 11/4 respectively?
01:31:13 <Myoma> he's just being off topic
01:31:49 <cad1> > (1+ div 45 2,1+ div 11/4
01:31:50 <lambdabot>   mueval: Prelude.read: no parse
01:31:56 <cad1> crud
01:32:07 <cad1> ﻿> (1+ div 45 2,1+ div 11/4)
01:33:00 <cad1> darn I see where I was wrong again
01:33:28 <Myoma> @let (/.) = div
01:33:31 <lambdabot>  Defined.
01:33:43 <Myoma> > (1+ /. 45 2,1+ /. 11/4)
01:33:44 <lambdabot>   mueval: Prelude.read: no parse
01:33:59 <cad1> you made my same mistake
01:34:03 <cad1> ﻿(1+ div 45 2,1+ div 11 4)
01:34:09 <cad1> > ﻿(1+ div 45 2,1+ div 11/4)
01:34:10 <lambdabot>   mueval: Prelude.read: no parse
01:34:17 <cad1> aarg
01:34:27 <cad1> > ﻿(1+ div 45 2,1+ div 11 4)
01:34:29 <lambdabot>   mueval: Prelude.read: no parse
01:34:47 <thoughtpolice> > (1 + (42 `div` 2), 1 + (11 `div` 4))
01:34:48 <lambdabot>   (22,3)
01:34:53 <cad1> what was wrong that time?!
01:35:05 <Myoma> cad1: mueval is broken
01:35:06 <thoughtpolice> > (1 + 42 `div` 2, 1 + 11 `div` 4)
01:35:07 <lambdabot>   (22,3)
01:35:16 <Myoma> > ﻿(1+ div 45 2,1+ div 11 4)
01:35:17 <lambdabot>   mueval: Prelude.read: no parse
01:35:20 <Myoma> > ﻿(1              + div 45 2,1         + div 11 4)
01:35:21 <lambdabot>   mueval: Prelude.read: no parse
01:35:26 <Myoma> > ﻿(1              + div 45 2      ,       1         + div 11 4)
01:35:27 <lambdabot>   mueval: Prelude.read: no parse
01:35:41 <Myoma> @tell gwern mueval doesn't like (1+ div 45 2,1+ div 11 4)
01:35:41 <lambdabot> Consider it noted.
01:35:51 <cad1> > ﻿(1+ (div 45 2),1+ (div 11 4))
01:35:52 <lambdabot>   mueval: Prelude.read: no parse
01:36:16 <cad1> this is has been silly
01:36:20 <electronx> @tell gwern lambdabot is cool
01:36:20 <lambdabot> Consider it noted.
01:36:24 <Myoma> > ﻿((1+ (div 45 2)),(1+ (div 11 4)))
01:36:25 <lambdabot>   mueval: Prelude.read: no parse
01:36:26 <Vq^> > (div 45 2)
01:36:27 <lambdabot>   22
01:36:31 <Vq^> > (1 + div 45 2)
01:36:33 <lambdabot>   23
01:36:35 <Myoma> > ﻿((1 + (div 45 2)),(1 + (div 11 4)))
01:36:37 <lambdabot>   mueval: Prelude.read: no parse
01:36:38 <Myoma> > ﻿((1 + (div 45 2)), (1 + (div 11 4)))
01:36:39 <lambdabot>   mueval: Prelude.read: no parse
01:36:39 <Vq^> > (1 + div 45 2, 1 + div 11 4)
01:36:40 <lambdabot>   (23,3)
01:36:52 <Myoma> > ﻿(1 + (div 45 2), 1 + (div 11 4))
01:36:53 <lambdabot>   mueval: Prelude.read: no parse
01:36:56 <Vq^> could it be cad1's encoding?
01:36:57 <Myoma> > ﻿(1 + div 45 2, 1 + div 11 4)
01:36:59 <lambdabot>   mueval: Prelude.read: no parse
01:37:12 <Myoma> > (1 + div 42 2, 1 + div 11 4)
01:37:13 <lambdabot>   (22,3)
01:37:18 <cad1> I am chatting from pidgin
01:37:30 <Myoma> > map chr "> ﻿(1 + div 45 2, 1 + div 11 4)"
01:37:31 <lambdabot>       lexical error in string/character literal at character '\65279'
01:37:36 <Myoma> > map chr "> (1 + div 42 2, 1 + div 11 4)"
01:37:37 <cad1> i've had trouble with lambdabot before
01:37:38 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
01:37:43 <Myoma> > map ord "> ﻿(1 + div 45 2, 1 + div 11 4)"
01:37:44 <lambdabot>       lexical error in string/character literal at character '\65279'
01:37:49 <cad1> Myoma: did you copy my text?
01:37:51 <Myoma> > map ord "> ﻿(1 + div 45 2, 1 + div 11 4)"
01:37:52 <lambdabot>       lexical error in string/character literal at character '\65279'
01:38:01 <Myoma> > map ord "> (1 + div 42 2, 1 + div 11 4)"
01:38:02 <lambdabot>   [62,32,40,49,32,43,32,100,105,118,32,52,50,32,50,44,32,49,32,43,32,100,105,...
01:38:17 <cad1> > (1 + div 42 2, 1 + div 11 4)
01:38:18 <lambdabot>   (22,3)
01:38:23 <cad1> I'll be
01:38:34 <Myoma> [62,32,40,49,32,43,32,100,105,118,32,52,53,32,50,44,32,49,32,43,32,100,105,118,32,49,49,32,52,41]
01:40:09 <Myoma> cad1, weird
01:40:14 <Myoma> > " ﻿("
01:40:15 <lambdabot>       lexical error in string/character literal at character '\65279'
01:40:23 <cad1> ﻿> (1 + div 42 2, 1 + div 11 4)
01:40:26 <Myoma> @untell gwern
01:40:27 <lambdabot> Consider it noted.
01:40:53 <cad1> I think it's a result of copying and pasting from my chat buffer... bizarre
01:40:58 <Myoma> cad1, I think you should tell the pigdin people that it's randomly inserting \65279 characters
01:42:43 * Myoma ends up calling it restrictedP until a better name comes along
01:42:52 <cad1> that and move to a real irc client :/
01:43:17 <cad1> what is the code you're going to use for the function?
01:43:55 <Myoma> I've got a set of numbers in {0,1,...,n-1}
01:44:56 <Myoma> and I pull one of the numbers out, say 4, and I want to map that on the function that takes x : {0,1,...,n-1} -> (x /= 4) -> {0,1,..,n-2}
01:48:21 <cad1> like  P x k = if x <k then x else if x > k then x - 1 else undefined    (I don't know how to say undefined in haskell yet)
01:48:26 <cad1> ?
01:48:31 <Myoma> undefined is fine
01:48:35 <sjanssen> > undefined
01:48:37 <lambdabot>   mueval: Prelude.read: no parse
01:48:37 <lambdabot>  mueval: *** Exception: Prelude.undefined
01:49:12 <sjanssen> cad1: but you can't start function names with a capital letter
01:49:38 <Myoma> We're kind of abusing haskell syntax
01:52:14 <cad1> hmm, so we have a whole parametrized family of functions with the property that each function does not have the value of the parameter in its domain
01:56:11 <Myoma> @seen mauke
01:56:12 <lambdabot> mauke is in #xmonad and #haskell. I don't know when mauke last spoke.
01:57:40 <Myoma> preflex: be TRWBW
01:57:47 <Myoma> :/
02:23:52 <Myoma> cad1: I am starting to wonder if it's a monad or a functor or something like that
02:23:59 <cjs> Hey, quick question here: should not 'map' = length replacement `seq` M.insert name replacement map' for an evaluation of the list 'replacement'?
02:24:38 <Myoma> cjs, I don't understand what you are asking
02:24:42 <cjs> For whatever reason, I have a space leak with that, but not if on every replacement I then do a 'M.fold (\lst len -> len + length lst) 0 map'.
02:24:54 <cjs> (And print the result of that.)
02:24:58 <sjanssen> cjs: that will only evaluate the spine of the list, not the elements
02:25:16 <Myoma> cjs, if you want to normalize things there is a Control.Concurrent or something
02:25:24 <cjs> Oh, that's no worry; the elements are already evaluated through bangs on arguments coming into the function that builds that list.
02:25:34 <Myoma> Control.Parallel.Strategies
02:25:47 <Myoma> force list = evaluate (rnf list)
02:25:59 <Myoma> but like ... why not just use a strict language . . .
02:26:38 <cjs> Well, it seems easier to fix the space leak than to rewrite four thousand lines of Haskell in Ocaml.
02:26:49 <sjanssen> cjs: are you demanding the result of map'?
02:27:05 <Myoma> 4000 isn't much :)
02:28:39 <cjs> Yes, I return a "MarketSim map'". The data structure is "data MarketSim = MarketSim ! (M.Map StockName Available)"
02:28:50 <cjs> 4000 is a lot, in Haskell. :-)
02:29:17 <sjanssen> cjs: are you demanding the result of your function?
02:29:39 <cjs> Hmmm. Maybe not yet, come to think of it.
02:29:50 <sjanssen> also, you should probably just use "newtype MarketSim = MarketSim (M.Map StockName Available)"
02:30:16 <cjs> Well, wait, I'm putting into a big state object, where that's also a strict field.
02:30:53 <sjanssen> repeat my question for that "big state object" :)
02:31:22 <cjs> Yeah, big state object is used.
02:32:45 <Myoma> cjs, are you going to release this program ever?
02:32:59 <cjs> Not this one, no. It's a proprietary trading system.
02:33:09 <cjs> Well, release to the client, but not to anybody else.
02:34:23 <sjanssen> cjs: does your space leak go away if you "Control.Exception.evaluate result"?
02:37:16 <electronx> does anyone here use F#
02:37:43 <sjanssen> of course not, we use Haskell :)
02:38:21 <Myoma> Haskell#
02:38:40 <electronx> that doesn't matter fp channel :)
02:38:41 <cad1> > sum [1,1000000]
02:38:46 <lambdabot>   1000001
02:39:07 <BeelsebobWork> Myoma: I was under the impression that F# exists because .net and Haskel make some pretty different assumptions about how type systems work
02:39:08 <cad1> > sum [1..1000000]
02:39:10 <lambdabot>   mueval: Prelude.read: no parse
02:39:10 <lambdabot>  mueval: *** Exception: stack overflow
02:42:22 <Wild_Cat> I wouldn't be surprised if it was more because the CLR was built for strict languages.
02:42:34 <cad1> div (1000000*(1000000+1)) 2
02:42:59 <cad1> > div (1000000*(1000000+1)) 2
02:43:00 <lambdabot>   500000500000
02:43:20 <Myoma> > sum [1..1000000]
02:43:22 <lambdabot>   mueval: Prelude.read: no parse
02:43:22 <lambdabot>  mueval: *** Exception: stack overflow
02:43:28 <Myoma> > sum [1..100000]
02:43:29 <lambdabot>   5000050000
02:43:34 <Myoma> > sum [1..1000000]
02:43:36 <lambdabot>   mueval: Prelude.read: no parse
02:43:36 <lambdabot>  mueval: *** Exception: stack overflow
02:43:46 <Myoma> > sum [1..100000] + sum [100000..1000000]
02:43:49 <lambdabot>   mueval: Prelude.read: no parse
02:43:49 <lambdabot>  mueval: *** Exception: stack overflow
02:44:04 <sjanssen> > sum [1..1000000] :: Int
02:44:06 <lambdabot>   mueval: Prelude.read: no parse
02:44:06 <lambdabot>  mueval: *** Exception: stack overflow
02:44:15 <sjanssen> lambdabot is not using ghc -O, it seems
02:44:32 <Baughn> It used to. ;_;
02:44:32 <Myoma> eep
02:44:35 <Myoma> > sum [1..100000] + sum [100001..1000000]
02:44:35 <quicksilver> the old hs-plugins lambdabot used to.
02:44:37 <lambdabot>   mueval: Prelude.read: no parse
02:44:37 <lambdabot>  mueval: *** Exception: stack overflow
02:44:41 <quicksilver> maybe mueval works a different way?
02:44:44 <Baughn> > foldl' (+) 0 [1..100000]
02:44:45 <lambdabot>   5000050000
02:45:14 <Baughn> > foldl' (+) 0 [1..1000000]
02:45:16 <lambdabot>   500000500000
02:45:20 <Baughn> > foldl' (+) 0 [1..10000000]
02:45:21 <Myoma> > sum [1..100000] + sum [100001..200000] + sum [200001..300000] + sum [300001..400000] + sum [400001..500000] + sum [500001..600000] + sum [600001..700000] + sum [700001..800000] + sum [800001..900000] + sum [900001..1000000]
02:45:23 <lambdabot>   50000005000000
02:45:23 <lambdabot>  Terminated
02:45:33 <sjanssen> quicksilver: mueval uses hint, which uses the GHC API
02:45:46 <sjanssen> so the execution path is probably similar to ghci
02:45:57 * quicksilver nods
02:47:07 <cad1> > sum [1..520170]
02:47:09 <lambdabot>   mueval: Prelude.read: no parse
02:47:09 <lambdabot>  mueval: *** Exception: stack overflow
02:48:38 <Baughn> > [1,2,3,undefined,4]
02:48:39 <lambdabot>   mueval: Prelude.read: no parse
02:48:39 <lambdabot>  mueval: [1,2,3,*** Exception: Prelude.undef...
02:54:16 <cjs> sjanssen: Yes, it does. I had no idea that function existed.
02:56:48 <Myoma> I used it it benchmark some sorting alrgorithms
02:57:50 <Myoma> hey can you run normal haskell code as is in DDC?
02:58:57 <Myoma> cjs: it could be really interesting to see if your program works in DDC
02:59:52 <Myoma> maybe it doesn't have all the libraries haskell does?
03:04:27 <sjanssen> cjs: this means you were using seq wrong
03:04:39 <sjanssen> cjs: probably you were not demanding that map', or something
03:07:15 <nha_> is it possible to :t a function local definition in ghci?
03:07:20 <nha_> like something in a where clause
03:09:53 <sjanssen> nha_: no
03:19:52 <cjs> sjanssen: Thanks.
03:19:59 <cjs> Myoma: DDC?
03:20:22 <Myoma> ?wiki DDC
03:20:22 <lambdabot> http://www.haskell.org/haskellwiki/DDC
03:20:45 <Myoma> I think now, it would probably not be easy to run something on it
03:23:33 <cjs> Myoma: I rather like the lazyness, much of the time, actually.
03:23:42 <cjs> It's just the odd thing here and there where it gets me.
03:29:59 <nha_> @src (<*>)
03:30:00 <lambdabot> Source not found. You type like i drive.
03:30:19 <jinjing> is there a way to unescape xml to utf-8 string ?
03:34:47 <maciek> I write a library which automates checking if logic sentence is a tautology
03:34:56 <maciek> One of operators is implication (=>)
03:35:17 <maciek> can I redefine it for Bools?
03:35:23 <maciek> (=>) :: Bool -> Bool -> Bool
03:35:24 <maciek> (=>) p q | p == Fasle = True
03:35:24 <maciek>          | p == True && q == True = True
03:35:24 <maciek>          | p == True && q == Fasle = False
03:35:32 <maciek> it doesn't compile
03:36:22 <maciek> can someone help me guessing why?
03:37:16 <maciek> with ==> it works
03:37:36 <Myoma> maciek: Fasle
03:37:41 <maciek> but I have lots of excercises to check which use =>
03:38:01 <maciek> I wrote it by hand here, in code it's False :)
03:38:12 <Myoma> you may also write
03:38:12 <maciek> sorry about that
03:38:22 <Myoma> False => _ = True
03:38:31 <Myoma> True => False = True
03:38:39 <Myoma> oops
03:38:41 <Myoma> but you get the idea
03:38:53 <maciek> haskell is beautiful, I get it
03:39:05 <Myoma> may => is not allowed
03:39:26 <maciek> I guess it isn't. ==> works
03:39:39 <Myoma> ⇒ is what I would use here
03:39:48 <maciek> how?
03:40:09 <Myoma> False ⇒ _ = True
03:40:09 <Myoma> True ⇒ q = q
03:40:13 <maciek> no no
03:40:16 <Myoma> yes yes
03:40:21 <maciek> where is it on my keyboard :D
03:40:28 <Myoma> lol
03:40:32 <Myoma> I don't think it's on your keyboard
03:40:43 <maciek> so lent my yours
03:40:50 <Myoma> here ⇒⇒⇒⇒⇒
03:40:53 <Myoma> you should not run out now :p
03:41:12 <maciek> give my 5 more and I am satisfied
03:41:29 <Myoma> > repeat '⇒'
03:41:30 <lambdabot>   "\8658\8658\8658\8658\8658\8658\8658\8658\8658\8658\8658\8658\8658\8658\865...
03:41:33 <Myoma> aww..
03:41:46 <Myoma> disappointing
03:41:58 <maciek> Oh, my excercises also contains this symbols
03:41:59 <maciek> so it's the best solution
03:42:34 <conal> maciek: "=>" is special syntax (for type class & instance decls)
03:43:03 <maciek> thanks. I just thought I can overload it for bool
03:43:24 <conal> maciek: also you can define implication as a one-liner with not and (||)
03:43:48 <maciek> But from definition it's more readable I think
03:43:59 <maciek> ayway, can you show me how?
03:44:02 <conal> maciek: and you never need to use ... == True and ... == False.
03:44:08 <Myoma> @let False ⇒ _ = True ; True ⇒ q = q
03:44:10 <lambdabot>  Defined.
03:44:14 <maciek> wait, I'lll work it out better
03:44:24 <Myoma> > liftM2 (⇒) [True,False] [True,False]
03:44:24 <lambdabot>   mueval: Prelude.read: no parse
03:44:25 <conal> yeah :)
03:44:30 <Myoma> hmf
03:45:57 <maciek> monadic stuff. thing for wizards.
03:46:25 <Myoma> > liftM2 (,) [True,False] [True,False]
03:46:25 <lambdabot>   mueval: Prelude.read: no parse
03:46:50 <Myoma> mueval--
03:47:38 <maciek> Myoma: is <=> on your keyboard?
03:47:46 <Myoma> no
03:47:48 <Myoma> ⇔
03:49:05 <maciek> Do you have keyboard for APL?
03:49:12 <Myoma> hehe :D
03:49:22 <Myoma> I don't but I would like one
03:50:11 <ivanm> OK, looks like I'm now getting an error in my code _because_ of a LANGUAGE pragma I'm using :s
03:50:14 <maciek> I wish I had one too, but for now I want only ⇔ on it.
03:50:51 <ivanm> wait, my mistake, I was mixing up two functions :s
03:51:17 <Myoma> 0 results found for APL keyboard
03:51:17 <Myoma> :(
03:55:56 <Zao> Myoma: http://www.catb.org/jargon/html/S/space-cadet-keyboard.html
03:55:57 <lambdabot> Title: space-cadet keyboard
03:56:27 <Myoma> I love the comic
03:57:39 <painy> hello haskellers!
03:59:55 <maciek> conal: p ==> q = q || not p
04:00:14 <conal> maciek: you got it! :)
04:01:10 <maciek> and like it better than definition. It's more myish.
04:03:06 <conal> maciek: what's "myish"?
04:04:06 <maciek> English is not my first language, so it could not even exist
04:04:14 <Saizan> Myoma: mueval has -fglasgow-exts on, so ⇔ is reserved for types
04:04:55 <Myoma> what is ⇔ in a type?
04:05:16 <Saizan> sorry, i meant (⇒)
04:05:19 <maciek> closer to my heart is how my sister explained myish
04:05:39 <conal> maciek: i guessed it's an internet term i don't know.
04:06:35 <maciek> conal: no no no. I just translated polish term too verbose.
04:07:24 <maciek> I also defined (¬) = not. Why should I write (¬)p instead of ¬p?
04:07:55 <Myoma> haskell doesn't have very good support for infix ops
04:08:06 <Myoma> maybe (¬ p) works though
04:08:26 <Myoma> well prefix and postfix is what I meant, not infix
04:08:39 <Axman6> does anyone have a recomendation for an editor for use with haskell on linux?
04:09:24 <maciek> I use The Emacs Editor
04:09:25 <profmakx> Axman6: yi ;)
04:09:31 * profmakx uses vim
04:10:02 <ivanm> so, should I be faithful to the original version of the algorithm I'm using (which uses randomness but seems to give poor results in my admittedly crude tests) or my simplified version (which is deterministic but seems to give better results)?
04:10:13 <maciek> Myoma: (¬p) doesn't work
04:10:18 <Axman6> ok, i'll have a look
04:10:35 <maciek> Emacs with emacs haskell mode
04:10:51 * ivanm seconds emacs
04:11:08 <ivanm> the indentation algorithm could be a touch smarter, but we can't have everything we want
04:11:47 <ivanm> Axman6: or there's always yi ;-)
04:11:58 <Axman6> yeah, installing it now ;)
04:15:52 <gwern> ivanm: don't you want determinism anyway?
04:15:52 <lambdabot> gwern: You have 3 new messages. '/msg lambdabot @messages' to read them.
04:16:00 <gwern> @messages
04:16:00 <lambdabot> Myoma said 2h 40m 20s ago: mueval doesn't like (1+ div 45 2,1+ div 11 4)
04:16:00 <lambdabot> electronx said 2h 39m 40s ago: lambdabot is cool
04:16:00 <lambdabot> Myoma said 2h 35m 34s ago:
04:16:50 <Myoma> gwern: oh it turned out not a problem with mueval, sorry about that
04:16:51 <ivanm> gwern: well, the algorithm is a nondeterministic clustering algorithm, and part of why it's meant to be good is the nondeterminism
04:16:53 * gwern receives Myoma's teaching without words, a transmission outside scriptures :)
04:17:03 <Myoma> :))
04:17:10 <Myoma> lol
04:17:39 <gwern> ivanm: oh. I was just thinking that determinism is like referential transparency and good for all the same reasons
04:18:04 <gwern> (or is referential transparency? I'm not entirely sure. one is a subset of t'other pr'aps)
04:18:39 <ivanm> now it seems I can't get my original behaviour back :s
04:18:49 * gwern reads the news. wow, this subprime crisis is the crisis that just keeps on giving - and giving - and giving...
04:18:50 * ivanm really should have  done darcs record before altering :s
04:21:03 <dancor> i think i see yampa gaming now, you can generate output pictures every tick but if you actuate function only prints them periodically laziness makes it ok
04:21:12 <dancor> s/if you/\0r
04:24:58 <mapreduce> > "test"
04:24:59 <lambdabot>   "test"
04:28:56 <ivanm> gwern: nah
04:29:44 <ivanm> anyway, turns out that in the end, the sole difference was that in my non-deterministic version I'd added in a stability measure which was lacking in my random version
04:29:54 <ivanm> i.e. I had n:ns versus ns ;-)
04:30:15 <gwern> oh that dratted list type; if only it weren't so easy to use
04:31:03 <unenough> I made a simple design and want to know if it has a text-book name
04:31:38 <unenough> it's a DAG of objects that depend on each other to be satisfied (the root depends on all it's children to become satisfied)
04:31:46 <quicksilver> conal: did you read Tim Sweeney's interview on ars?
04:31:59 <quicksilver> conal: he takes a very different view to me (and I'm sure you)
04:32:02 <unenough> the leaf objects could be something that depends on system state
04:32:15 <unenough> does this sound like anything familiar?
04:35:45 <ivanm> gwern: why? what's wrong with lists?
04:35:53 <ivanm> especially when it does all I need it to do?
04:36:10 <ivanm> (and ns is the output of a library function :p )
04:39:31 <ivanm> gwern: I lied, there _is_ one other difference which makes a difference :p
04:40:15 <gwern> ivanm: I dunno, n:ns makes it sound like 'stability':'data', at which point it looks to me like you're ad hoc parsing a list when you really should be lifting invariants to the type level to something like (Stability, [Data])
04:40:27 <gwern> also, lists seem to encourage partiality
04:41:01 <ivanm> nah, when I say "stability" measure, I'm implementing a graph clustering algorithm where each node chooses a new cluster value based upon its neighbours
04:41:28 * gwern ponders how to do graphing of polar coordinate equations in haskell
04:41:31 <ivanm> but I added in that node itself (n) to act as a stability measure, in case it doesn't want to change
04:41:38 <ivanm> gwern: the Chart library?
04:42:17 <gwern> I thought of that, but chart only seems to take lists of cartesian coordinates
04:42:25 <gwern> and diagrams is no good
04:42:27 <conal> quicksilver: no.  url?
04:42:28 <ivanm> convert them?
04:42:29 <Myoma> turn cartesian into polar ?
04:42:34 <Myoma> I mean the opposite
04:42:37 <ivanm> lol
04:42:55 <ivanm> (r,t) ==> (r*cos t, r*sin t)
04:42:56 <gwern> ivanm: no, I mean chart takes points, not equations
04:42:56 <quicksilver> conal: http://arstechnica.com/articles/paedia/gpu-sweeney-interview.ars
04:43:07 <ivanm> gwern: it can take equations
04:43:11 <ivanm> see the simple module
04:43:23 <gwern> hm
04:43:29 <ivanm> but no, I don't think it does parametric equations yet
04:43:34 <ivanm> I could be wrong though...
04:43:51 <ivanm> gwern: otherwise... dump it to graphviz?
04:44:09 <ivanm> s/graphviz/gnuplot/
04:44:10 <gwern> dump to graphviz? eevil
04:44:21 <ivanm> yeah, I've been using it lately so I have it on the brain
04:44:23 <ivanm> but why evil?
04:44:28 <ivanm> what else can draw graphs?
04:45:16 <gwern> if I'm willing to call out, I might as well just call out to R and use the canned equations for Chernoff faces I found instead of cooking up my own
04:46:28 <ivanm> OK, fine, I'm dumping the nondeterminism...
04:46:55 <ivanm> my algorithm won't be correct, but it'll work :p
04:52:36 <ivanm> OK, so I've got a fixPoint function defined as: fixPoint f x = let x' = f x in if (x' == x) then x' else fixPoint f x'
04:52:58 <ivanm> oh, wait, I worked out what I wanted...
04:53:00 <ivanm> nevermind ;-)
04:54:51 <skorpan> i'm using Graphics.Vty for drawing my MPD client, but i'm experiencing that it's too slow to cope with it.
04:55:07 <skorpan> is it inherently slow or am i just doing something wrong?
04:55:20 <skorpan> @hackage yi
04:55:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/yi
04:56:28 <Myoma> How do you keep track of which youtube video you watched and didn't?
04:56:43 <Myoma> you guys got me hooked on TheCatsters..
04:57:34 <hackage> Uploaded to hackage: panda 0.0.0.4.2
05:00:42 <Myoma> I think it's bad for me to watch this
05:03:49 <_Dae_> Anyone here worked on the fankuch benchmark?
05:05:23 <quicksilver> _Dae_: I spent a little time poking at your code on Friday and couldn't make it go at all parallel.
05:05:41 <quicksilver> _Dae_: I wonder if any attempt at parallelism is blocked on the evaluation of 'permutations'
05:06:23 <quicksilver> note that the construction of 'permutations' is internally recursive in quite a complex fashion.
05:06:25 <_Dae_> quicksilver: neither could I.... it's not the permutations, I had it evaluate the first million and only do the calculation on those
05:07:46 <Myoma> :t fmap
05:07:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:07:56 <Myoma> what is the name for (a -> b) in fmap?
05:08:18 <quicksilver> _Dae_: what did you do to make it evaluation the first million perms?
05:09:41 <_Dae_> heh, lots of things, but I think the best was k = take 1000000 p `using` parList rnf
05:11:42 <LeoD> Myoma: predicate?
05:13:09 <quicksilver> _Dae_: did you try parListChunk for parM?
05:14:39 <_Dae_> quicksilver: parListChunk isn't lazy... but I could probably work around that
05:16:26 <quicksilver> _Dae_: only parListChunk inside your splitAt
05:16:32 <quicksilver> _Dae_: that seems to make most sense to me
05:16:44 <quicksilver> e.g. splitAt 1024, and parListChunk that 256
05:23:37 <_Dae_> quicksilver:  no dice :s  I think the plan is to rewrite the whole thing. My haskell skillz are not up to the task of deciphering dons translation from c.
05:24:13 <Myoma> _Dae_: What's the program?
05:25:06 <_Dae_> Myoma: parallel version of the fankuch shootout benchmark: http://shootout.alioth.debian.org/u64q/benchmark.php?test=fannkuch&lang=ghc&id=1
05:25:08 <lambdabot> Title: fannkuch Haskell GHC program | x64 Ubuntu : Intel® Q6600® quad-core Computer L ..., http://tinyurl.com/54n3uw
05:25:33 <Myoma> is there a problem statement?
05:25:58 <quicksilver> Myoma: well the current problem is 'why won't dae's code run in parallel?' ;)
05:26:20 <quicksilver> _Dae_: I don't think this program is anything like a 'translation from C'
05:26:37 <quicksilver> it's just go some manual case unfolding
05:26:58 <_Dae_> quicksilver: nope, but this: http://shootout.alioth.debian.org/u64q/benchmark.php?test=fannkuch&lang=ghc&id=2 is. It is also twice as fast.....
05:26:59 <lambdabot> Title: fannkuch Haskell GHC #2 program | x64 Ubuntu : Intel® Q6600® quad-core Compute ..., http://tinyurl.com/6qnl7e
05:28:23 <_Dae_> Myoma: http://www.hpaste.org/10311 is my attempt to make it parallel. Or one of them
05:29:35 <bringert> Seen in ghc/compiler/parser/Lexer.x: "-- This stuff is horrible.  I hates it."
05:29:59 <bringert> wow
05:30:17 <quicksilver> _Dae_: Oh. Yes ;) That is.
05:30:36 * bringert is looking at how ghc can handle utf-8 source files when alex doesn't support unicode
05:32:04 <_Dae_> bringert: convert them first, or?
05:32:28 <bringert> _Dae_: nope, can't do that since alex can handle Unicode, only bytes
05:32:37 <bringert> _Dae_: it's quite horrible really
05:32:47 <bringert> uses magic values
05:32:57 <guenni> how can I "upgrade" my ghc packages on Win32, cabal will fail because a lot of the packages will not compile?
05:33:59 <_Dae_> bringert: no, I mean...can't you simply pass it to a converter before handing them on to alex?
05:34:13 <bringert> _Dae_: what would that convert it to?
05:34:32 <_Dae_> bringert: ascii? Maybe I'm not getting the problem
05:34:46 <bringert> _Dae_: how do you convert UTF-8 to ascii?
05:36:04 <_Dae_> bringert: right... the full extent of the problem just dawned on me.... bad idea then
05:36:56 * _Dae_ was about to propose a very hacked ad-hoc solution
05:38:08 <bringert> _Dae_: right, that's what's there now...
05:38:28 <Axman6> hmm, anyone seen the error "yi: exception :: System.Glib.GError.GError" when launching yi before? i can't get it to launch
05:44:08 <Myoma> If you want to parallelize on concurrentify a program
05:44:23 <Myoma> and you have, say a 2 core computer, you just need to have two things happening at once, all the time?
05:44:50 <gwern> why only 2?
05:45:06 <Myoma> I don't know gwern
05:45:11 <Myoma> I am asking how it should be done
05:45:42 <gwern> my rule of thumb is 'paralleization is hard, so parallize as much as possible and see what happens'
05:46:12 <Myoma> sure that probably works well in practice but I'm only interested in the theoretical best possible situation :p
05:46:42 <_Dae_> Myoma: that's the gist of it... sometimes it's easy (divide and conquer algorithms), sometimes it's hard (strictly sequential algorithms)
05:46:43 <Axman6> Myoma: you can usually run a lot more that at once, but sometimes you get to a point when you're running too much in parallel (quicksort i've found can suffer from that, so you stop doing it in parallel when the list is below a certain length)
05:51:37 <Myoma> so having more than the number of cores things happening at once is never going to run faster than having the number of cores things happening at once?
05:53:07 <_Dae_> Myoma: ehh.... technically true, but all this intel hyperthreading means it doesn't always hold
05:53:22 <Myoma> what is hyperthreading ?
05:53:22 <gwern> hard to say. maybe more than cores could go faster when IO is considered
05:55:14 <Myoma> Axman6: Why not take as a parameter the max number of forks to use -- and pass the number of cores in at the start
05:55:22 <Myoma> would that work better?
05:55:27 <Myoma> @hoogle cores
05:55:27 <lambdabot> No results found
05:55:29 <Myoma> @hoogle Cores
05:55:30 <lambdabot> No results found
05:55:34 <Axman6> Myoma: trial and error
05:55:39 <Myoma>  ?
05:55:46 <gwern> iirc, isn't there a stdlib function for # of system processors ?
05:56:01 <Axman6> you test and see what works best. you might be surprised, or it might do exactly what you want
05:56:01 <MyCatVerbs> gwern: mmmmmmno. :)
05:56:11 <Myoma> I'm trying to find out its name gwern
05:56:18 <_Dae_> Myoma: haskells threads are already very lightweight, so as long as your grainsize is reasonable, the difference between having it optimized for 2 and for N cores isn't that big
05:56:29 <Myoma> Axman6: So it's impossible to reason about concurrency
05:56:40 <Axman6> i didn't say that
05:57:15 <Axman6> just saying that my experience has been that sometimes it can make things slower rather than faster, if you try ro make things too parallel
05:57:15 <MyCatVerbs> gwern: stdlib doesn't even include threading primitives. Why on Earth would it include something so specific as CPU count? :)
05:57:42 <Myoma> Axman6: Did you read what I wrote about the quicksort
05:57:57 <Myoma> Axman6: I'm wondering if thaht would be better than stopping when the list is a certain length
05:57:58 <gwern> MyCatVerbs: you know what I mean, the usual libraries bundled with ghc
05:58:06 <MyCatVerbs> gwern: ohhhh. Hrmn.
05:58:08 * gwern is sure I've seen such a function before
05:58:39 <MyCatVerbs> I don't *think* it does. There isn't any portable way to check that - certainly nothing in POSIX.
05:58:46 <Axman6> Myoma: i'm no expert on this matter tbh
05:58:49 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#v%3AnumCapabilities
05:58:51 <lambdabot> Title: GHC.Conc, http://tinyurl.com/ys92tb
05:59:15 <Myoma> thank you Saizan
05:59:28 <MyCatVerbs> That's just giving you access to the -N flag the user passed. Can't use it to *set* the -N flag, but prolly good enough, I guess.
06:00:09 * Myoma is going to measure it
06:00:17 <_Dae_> MyCatVerbs: I think plans are for future versions of GHC to set the N flag automaticly to the number of cores
06:00:41 <MyCatVerbs> That would be awkward to do portably.
06:00:55 <Myoma> MyCatVerbs: portably??
06:01:08 <Myoma> MyCatVerbs: you have got something against using different code on each OS ?
06:01:16 <MyCatVerbs> Myoma: yes.
06:01:36 <Axman6> anyone know a file manager that works will with Xmonad?
06:01:38 <MyCatVerbs> Myoma: it involves writing - and maintaining - more code than a single portable solution would.
06:01:38 <Myoma> MyCatVerbs: In a language implementation ...?
06:02:22 <_Dae_> MyCatVerbs: No no, I mean, ghc will make the progam it compiles set the falg automaticly
06:02:22 <MyCatVerbs> Myoma: GHC sticks mostly to POSIX, even though it's apparently used mainly on Linux. This means (almost) no extra work has to be done to get it to work on BSD, Solaris, etc.
06:02:22 <gwern> Axman6: midnight commander...
06:02:24 <gwern> dired
06:02:27 <gwern> etc.
06:02:48 <birkenfeld> how would you write a variation of parsec's manyTill that returns the end token?
06:03:11 <MyCatVerbs> _Dae_: I understood. You'd have still have to write some code in the RTS to do that.
06:04:00 <_Dae_> MyCatVerbs: allright, yes... ghc would be less portable
06:04:43 <Myoma> MyCatVerbs: What about the native code generator ? :|
06:04:49 <Myoma> I'm sure that works different on each OS
06:06:00 <MyCatVerbs> Myoma: not particularly, I think. Has to cope with differences in ELF output, but ELF is actually really well standardised across OSes.
06:07:20 <MyCatVerbs> Well, you could still do it. It's not difficult to count the inodes in /sys/devices/system/cpu/ on Linux, or hit up sysctl hw.ncpu on BSD, or... etc. It's just a teeny bit irksome to have to do _all_ of those.
06:07:24 <birkenfeld> how's http://hpaste.org/10388 ?
06:07:43 <MyCatVerbs> birkenfeld: hpaste is working just fine!
06:07:50 <MyCatVerbs> birkenfeld: oh wait, you meant the contents...? ;)
06:07:58 <Myoma> birkenfeld: You are reimplementing bits of parsec
06:07:58 <Myoma> ?
06:08:31 <MyCatVerbs> Myoma: looks more like a custom parsec combinator.
06:08:46 <birkenfeld> Myoma: as I said, I'm looking for a manyTill that returns the end token too
06:08:57 <Myoma> ok I missed that
06:10:03 <MyCatVerbs> Looks good to me. Just put a comment in above saying what it does, and give an explicit type signature. Otherwise, people will wonder what the Heck it's for (the name isn't really quite enough, unless you plan to give paragraph-long names to everything).
06:10:11 <Myoma> birkenfeld: why don't you base yours on http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/parsec/Text/ParserCombinators/Parsec/Combinator.hs?rev=1.2;content-type=text%2Fplain
06:10:13 <lambdabot> http://tinyurl.com/669ufv
06:10:17 <Myoma> manyTill is in there
06:10:41 <birkenfeld> yes, and that's where I got the idea how to do my version :)
06:10:41 <Toxaris> birkenfeld: have you tried it? I would guess that the results are in the wrong order
06:10:49 <Toxaris> but maybe i'm wrong
06:10:53 <birkenfeld> good point
06:11:03 <Myoma> birkenfeld: Your version doesn't look anything ilke that one though :/
06:11:32 <birkenfeld> Myoma: I had to adapt it
06:11:53 <Myoma>                       scan  = end
06:12:01 <Myoma> do{ x <- p; scan; }
06:12:08 <Myoma> just htose two changes should do it right?
06:12:25 <skorpan> @pl \x -> modify (\y -> y { screen = x })
06:12:26 <lambdabot> (line 1, column 23):
06:12:26 <lambdabot> unexpected "{"
06:12:26 <lambdabot> expecting variable, "(", operator or ")"
06:12:53 <birkenfeld> Myoma: well it should return both
06:12:58 <Myoma> both what?
06:13:14 <birkenfeld> both the list of "p" parsed tokens and the "end" one
06:13:23 <Myoma> as a tuple ([a],a) ?
06:13:26 <birkenfeld> yes
06:13:32 <birkenfeld> ([a], b) actually
06:13:43 <skorpan> @pl modify (\y -> y { screen = x })
06:13:43 <lambdabot> (line 1, column 17):
06:13:43 <lambdabot> unexpected "{"
06:13:43 <lambdabot> expecting variable, "(", operator or ")"
06:14:16 <Myoma> ah ok, you could use scan = do e <- end ; ([],e), and do{ x <- p; (xs,e) <- scan; return (x:xs,e) }
06:14:20 <Myoma> as the two changes
06:14:32 <Myoma> other than that exactly the same as the original
06:14:38 <skorpan> is it possible to make a pointless record update?
06:15:03 <Myoma> skorpan: withing defining a new function?
06:15:06 <Toxaris> skorpan: no
06:15:08 <Myoma> without *
06:15:11 <skorpan> yes Myoma
06:15:18 <birkenfeld> that sounds good
06:18:05 <Toxaris> birkenfeld: manyTill' p end = scan where scan = ((,) [] <$> end) <|> (first (:) <$> p <*> scan)
06:18:15 <dmwit> > let f x = f x in f 3
06:18:29 <Myoma> Toxaris :(
06:18:30 <lambdabot>   thread killed
06:18:44 <birkenfeld> Toxaris: ah, the next level :)
06:18:52 <Myoma> Toxaris. you could have at least factored out 'scan' and taken the fixpoint
06:19:27 <Toxaris> Myoma: yeah thought about that, but I find taking the fixpoint of a action-building function confusing
06:19:47 <Toxaris> Myoma: so I decided to introduce just liftM and ap instead of bind
06:19:48 <Saizan> ?pl fix \scan -> ((,) [] <$> end) <|> (first (:) <$> p <*> scan)
06:19:48 <lambdabot> (line 1, column 5):
06:19:48 <lambdabot> unexpected "\\"
06:19:48 <lambdabot> expecting variable, "(", operator or end of input
06:19:53 <Myoma> @type fix (liftM2 (<|>) (const ((,) [] <$> end)) ((<*>) (first (:) <$> p) <*>))
06:19:55 <lambdabot> Not in scope: `end'
06:20:03 <Myoma> @type \p end -> fix (liftM2 (<|>) (const ((,) [] <$> end)) ((<*>) (first (:) <$> p) <*>))
06:20:04 <lambdabot>     Couldn't match expected type `a -> b'
06:20:04 <lambdabot>            against inferred type `([b1] -> [b1], d)'
06:20:04 <lambdabot>     Probable cause: `first' is applied to too many arguments
06:20:15 <Toxaris> oups :(
06:20:18 <Saizan> ?pl fix \scan -> (tuple [] <$> end) <|> (first (:) <$> p <*> scan)
06:20:18 <lambdabot> (line 1, column 5):
06:20:18 <lambdabot> unexpected "\\"
06:20:18 <lambdabot> expecting variable, "(", operator or end of input
06:20:23 <Toxaris> seems like I need first2 :)
06:20:24 <Myoma> Toxaris: ...and that whole thing you posted _isnt_ confusing??
06:20:51 <Saizan> Myoma: it's perfect applicative style :)
06:21:03 <Toxaris> Myoma: well, birkenfeld already used bind instead of do notation, so I guess the next step is ok
06:21:14 <unenough> Myoma, hyperthreading is an Intel name for a cpu that has two "logical" cores, meaning, most of the hardware is not duplicated but a smarter architecture allows two logical cpu's to share the same hardware
06:21:18 <unenough> as far as I know :)
06:21:33 <birkenfeld> Toxaris: the whole applicative stuff is still new to me
06:21:41 <Toxaris> Myoma: ok, the first is confusing (and wrong, as it seems), but to use bind when fmap and ap would work is bad style imho
06:21:45 <Myoma> @hoogle getClockTime
06:21:45 <lambdabot> No results found
06:21:49 <Myoma> wtf
06:21:52 <Myoma> @Inde getClockTime
06:21:52 <lambdabot> Maybe you meant: index undo
06:23:05 <skorpan> is it possible to make an import "take precedence" over any other import?
06:23:11 <skorpan> without using qualified
06:23:18 <quicksilver> no.
06:23:22 <Myoma> :t getCPUTime
06:23:23 <lambdabot> Not in scope: `getCPUTime'
06:24:00 <Myoma> How do you display the difference of two CPU times as "3 seconds foo " type thing?
06:24:20 <birkenfeld> Toxaris: is there a nice way to write p >>= \v -> return (v:[]) too?
06:25:07 <Myoma> birkenfeld: do notation
06:25:54 <birkenfeld> that's not nicer to me... especially when written with braces
06:25:58 <Saizan> birkenfeld: fmap (:[]) p, or (:[]) <$> p
06:26:06 <unenough> what is hypothreading, that is the question
06:26:39 <Myoma> birkenfeld: I see value in staying as close as possible to the codebase you're working with (Parsec in this case), but not doing so is fine, just a matter of choice
06:27:23 <birkenfeld> Myoma: for the manyTill' function, I've used your version which is simply a bit more readable :)
06:27:27 * Myoma also notes that it's terrifically painful to collaborate with people who don't do this
06:29:06 <Myoma> that's funny I thought seq did something other than it does
06:29:45 <sw17ch> seq only forces strictness on one of its arguments, correct?
06:29:52 <sw17ch> @type seq
06:29:53 <lambdabot> forall a t. a -> t -> t
06:30:01 <sw17ch> specifically, the first one
06:30:08 <Myoma> seq _|_ b = _|_, else seq _ b = b
06:30:26 <Myoma> from the pseq docs
06:30:26 <sw17ch> oh, neato
06:30:35 <Myoma> "the compiler may, for example, rearrange a seq b into b seq a seq b."
06:30:40 <Myoma> assuming it means
06:30:46 <Myoma> "the compiler may, for example, rearrange a `seq` b into b `seq` a `seq` b."
06:30:57 <Myoma> so anyway, pseq does what I though seq does
06:31:16 <Myoma> 'ensures that the user can retain control of the evaluation order.'
06:31:48 <sw17ch> so, seq is just to make sure the strictness happens, but pseq tells the compiler to do it in a specific order?
06:32:11 <quicksilver> seq imposes order in a very weak sense
06:32:13 <Myoma> yes
06:32:16 <quicksilver> pseq is a strong sense of order
06:32:28 <quicksilver> I don't know if GHC treats them any differently
06:32:40 * Myoma does not want to take the risk
06:33:13 * sw17ch tries not to take advantage of specific implementation features... but it's a little different when GHC has sooo many nice features others don't
06:33:59 <Myoma> I did a comparison of quicksort with a parallel version of quicksort
06:34:15 <Myoma> it doesn't seem to help, running them in parallel
06:35:21 <MyCatVerbs> Takes a lot of tuning to get right.
06:35:49 <MyCatVerbs> Heck, Data.List.sort is a rather scary-looking mergesort implementation. Perhaps you might wish to take a looksee at it?
06:36:59 <sw17ch> MyCatVerbs, wow, mergesort... really. that's cool
06:37:31 <Myoma> I've got
06:37:35 <Myoma> sequential: 5898751000000
06:37:36 <Myoma> concurrent: 5683517000000
06:37:43 <Myoma> I was excepting concurrent to take half the time of sequential
06:37:58 <Myoma> is my expectation just really wrong, or maybe my code is?
06:38:03 <MyCatVerbs> Myoma: ouch.
06:38:42 <MyCatVerbs> Myoma: your code. Sorting algorithms *in theory* have quite a bit of geometric parallelism to take advantage.
06:38:50 <Myoma> quicksort' (x:xs) = let (before,after) = around x xs
06:38:50 <Myoma>                         quicksort'before = quicksort before
06:38:50 <Myoma>                         quicksort'after = quicksort after
06:38:50 <Myoma>                      in par quicksort'after (quicksort'before ++ [x] ++ quicksort'after)
06:39:02 <Myoma> is that wrong ?
06:39:11 <MyCatVerbs> sw17ch: Partly it's because people don't actually like Quicksort's O(n^2) case. Largely it's also because Mergesort is actually pretty darn good if what you're sorting is a list anyway.
06:39:34 <sw17ch> yeah :)
06:39:42 <MyCatVerbs> Myoma: for a start, don't use `par` all the way down, elsewise sparking overhead will *annihilate* the gains.
06:39:51 <Myoma> "all the way down"?
06:40:05 <sw17ch> Myoma: i know very little about par and friends, but doesn't that just evaluate to WHNF all the way down? that's a lot of overhead
06:40:11 <sw17ch> oh, yes, MyCatVerbs got it right
06:40:31 <Myoma> How should I write this?
06:40:35 <MyCatVerbs> Myoma: as in, if quicksort'before is only one element long, there's no point trying to evaluate it in parallel with quicksort'after.
06:40:36 <sw17ch> Myoma: a better strategy would be to par only the first split
06:40:37 <sw17ch> for a dual core
06:40:49 <sw17ch> well, that's not right either
06:40:54 <quicksilver> also that's only "par"in the whnf of the lists
06:40:56 <sw17ch> if you have a known, balanced split, that's better
06:40:59 <Myoma> my function here is called quicksort'
06:41:08 <quicksilver> so it's just par'ing the check if the lists are not empty
06:41:10 <quicksilver> not any of the real work
06:41:21 <Myoma> it uses a non parallel function in the recursive case, that function is called quicksort
06:41:35 <MyCatVerbs> quicksilver: So you need to force the entire list spine, aye?
06:41:58 <Myoma> sw17ch; ah!! I see what you mean!
06:42:11 <MyCatVerbs> Myoma: ah, right, aye. Then your problem is that it's only evaluating as far as WHNF.
06:42:21 <sw17ch> Myoma, do take note that my solution breaks if you have a bad pivot
06:42:49 <sw17ch> but also, you'll need to force more than the WHNF of the list at the top
06:43:44 <sw17ch> (some one correct me if i'm getting this wrong... i'm not entirely confident in my answers)
06:44:39 <_Dae_> chanes are that parList would be easier, no?
06:44:42 <_Dae_> *chances
06:45:18 <birkenfeld> @pl t x = u x x
06:45:19 <lambdabot> t = join u
06:45:33 <birkenfeld> huh
06:54:50 <Myoma> is there anything like parPair :: IO x -> IO y -> IO (x,y) ?
06:55:01 <Myoma> which runs each action in parallel and col/ects the results
06:56:37 <sioraiocht> parPair x y = a <- x; b <- y; a `par` b `par` return (x,y)
06:56:37 <sioraiocht> ?
06:57:00 <sioraiocht> sorry, a `par` b `seq` return (a,b)
06:57:34 <sioraiocht> does that do what you want?
06:57:38 <Myoma> I don't know
06:57:43 <sioraiocht> it ought to
06:57:47 <Myoma> I'm not sure how a <- x works
06:57:47 <bd_> it doesn't
06:57:52 <Myoma> hoes that evaluate x ?
06:57:53 <sioraiocht> bd_: why not?
06:57:55 <bd_> the type is wrong :)
06:57:59 <Myoma> which means x and y are sequential
06:58:03 <bd_> :t \a b ->  a `par` b `seq` return (a,b)
06:58:04 <lambdabot> forall a b (m :: * -> *). (Monad m) => a -> b -> m (a, b)
06:58:18 <sioraiocht> yeah...
06:58:26 <sioraiocht> sorry, forgot the do
06:58:41 <bd_> you can't just sprinkle a do in there and have it work...
06:58:54 <quicksilver> in IO you want to use forkIO, MyCatVerbs
06:58:57 <quicksilver> argh
06:58:58 <quicksilver> Myoma:
06:59:02 <quicksilver> damn tab-complete :)
06:59:10 <sioraiocht> :t (\x y -> do {a <-x; b <- y; a `par` b `seq` return (x,y)})
06:59:10 <lambdabot> forall t t1 (m :: * -> *). (Monad m) => m t -> m t1 -> m (m t, m t1)
06:59:11 <bd_> :t \a b -> do { va <- newEmptyMVar; forkIO (a >>= putMVar va); vb <- b; va' <- takeMVar va; return (va', vb) }
06:59:12 <lambdabot> Not in scope: `newEmptyMVar'
06:59:12 <lambdabot> Not in scope: `forkIO'
06:59:12 <lambdabot> Not in scope: `putMVar'
06:59:16 <quicksilver> par is for pure computations.
06:59:21 <bd_> sioraiocht: that doesn't do what you want
06:59:36 <bd_> sioraiocht: if evaluating the x in IO takes a while, there's no point in usine par
06:59:40 <Myoma> I needed to make this in IO so I could force the list
06:59:43 <bd_> see above for an example using MVars
06:59:50 <quicksilver> Myoma: rubbish ;)
06:59:54 <bd_> note that exceptions are left as an exercise for the reader
06:59:55 <quicksilver> Myoma: IO is not for forcing.
07:00:07 <quicksilver> there is no relationship between IO and strictness.
07:00:13 <Myoma> force :: [a] -> IO () .....
07:00:20 <sioraiocht> Myoma: if you want to force every member of a list
07:00:42 <bd_> Myoma: force :: [a] -> ()  can be made
07:01:36 <bd_> :t foldr seq ()
07:01:37 <lambdabot> forall a. [a] -> ()
07:01:44 <bd_> > foldr seq () [1,2,3,undefined]
07:01:46 <lambdabot>   mueval: Prelude.read: no parse
07:01:46 <lambdabot>  mueval: *** Exception: Prelude.undefined
07:01:47 <sioraiocht> :t foldl1' (flip seq)
07:01:48 <lambdabot> forall a. [a] -> a
07:01:58 <sioraiocht> :t foldl' (flip seq) ()
07:01:59 <lambdabot> forall b. [b] -> ()
07:02:20 <sioraiocht> bd_: why would you use lazy fold to force a list?
07:02:45 <bd_> sioraiocht: no idea, foldl' is probably a better idea XD
07:02:52 <bd_> <-- tired, didn't get enough sleep
07:02:56 <sioraiocht> heh
07:03:14 <sioraiocht> and then Myoma, if you AREN'T in the IO monad
07:03:19 <sioraiocht> you can use `par` ;)
07:03:28 * Myoma is no longer in IO
07:04:13 <mattam> @src zip
07:04:14 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:04:14 <lambdabot> zip _      _      = []
07:04:15 <painy> IO
07:04:26 <sioraiocht> @src parZip
07:04:26 <lambdabot> Source not found. Take a stress pill and think things over.
07:04:27 <painy> hello haskellers!
07:04:29 <sioraiocht> damn
07:04:32 <sioraiocht> well
07:04:39 <sioraiocht> if you want a parallel zip you can make one
07:04:46 <Myoma> @hoogle foldl'
07:04:46 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
07:04:47 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
07:04:47 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
07:08:28 <Myoma> does anyone have a paralllel quicksort that works well?
07:08:45 <Myoma> i.e. is about twice the speed of a normal quicksort
07:08:52 <sioraiocht> parZip (a:as) (b:bs) = a `par` b `seq` (a,b): parZip as bs?
07:09:40 <quicksilver> Myoma: no one will have one which is twice the speed, no.
07:09:53 <quicksilver> that's just not possible because of memory bandwidth and cache coherency.
07:09:59 <Myoma> how much would it be
07:10:02 <quicksilver> quicksort will be memory bound not computation bound
07:10:30 <quicksilver> and parallelising doesn't help memory bounds much
07:10:49 <Myoma> ok I guess that explains why I haven't seen any improvement of parallelising this
07:11:06 <Myoma> do you know any sort algorithm on a list which would work better?
07:11:14 <sioraiocht> mergesort?
07:11:31 <sioraiocht> parallel mergesort, btw, is also usually pretty slow =p
07:11:48 <osfameron> why's is slow?
07:12:05 <osfameron> and does it have advantaes like, for example, scaling better to enormous sets?
07:12:07 <Myoma> I'm just trying to find something I can do in parallel that runs faster than with one thread
07:12:17 <sioraiocht> osfameron: it's still faster than regular mergesort, but not a LOT better
07:12:24 <quicksilver> I can't see any sort being anything but memory bound
07:12:38 <quicksilver> since a sort is all about readig unsorted items and writing sorted ones
07:12:48 <sioraiocht> osfameron: usually parallelmergesort breaks down into chunks of sequential mergesort
07:13:03 <quicksilver> if you want to find an algorithm which parallelises well on modern hardware you need lots of *computation*
07:13:14 <quicksilver> because modern chips have computation power which outweighs their memory bandwidth
07:15:35 <BeelsebobWork> quicksilver: yes and no -- depends if by "modern chips" you mean GPUs
07:15:41 <quicksilver> BeelsebobWork: no, I don't.
07:15:44 <quicksilver> BeelsebobWork: I mean CPUs.
07:15:44 <Myoma> yeah
07:16:00 <Myoma> I compared the gph quicksort and it's slower than sequential
07:16:21 <BeelsebobWork> Myoma: doesn't mean it's impossible to write it well in parallel
07:16:27 <Myoma> yeah it does
07:16:38 <BeelsebobWork> I know someone who's written a parallel quicksort that's faster than Haskell's sort implementation
07:16:43 <quicksilver> Myoma: you might manage to demonstrate a sort which runs faster if its dataset is entirely in cache
07:16:47 <Myoma> in haskell?
07:16:50 <BeelsebobWork> yes
07:16:51 <BeelsebobWork> in haskell
07:16:53 <quicksilver> ...but you still have cache coherency problems.
07:16:57 <Myoma> where is the code
07:17:03 <BeelsebobWork> Myoma: ask Axman6
07:18:00 <sioraiocht> oh, and why do the memcpy wrappers in GHC have functions that let you specify a src OR dest offset but never BOTH?
07:18:20 <Myoma> @seen Axman6
07:18:21 <lambdabot> Axman6 is in #haskell and #macosx. I last heard Axman6 speak 1h 16m 44s ago.
07:18:40 <Axman6> o/
07:18:54 <BeelsebobWork> Axman6: fast sorting -- you did it in parallel, right?
07:18:54 <mrh> Hey guys, i want to create a logical matrix in Haskell, is there any easy way of doing that?
07:19:02 <Axman6> yeah
07:19:09 <BeelsebobWork> Myoma: doesn't believe you can
07:19:09 <Botje> Data.Array ?
07:19:16 <Axman6> faster than Data.List.sort :)
07:19:31 <mrh> :hoogle Data.Array
07:19:41 <_Dae_> I can't for the life of me get this piece of code right: http://hpaste.org/10390 It keeps popping indention errors, which I don't get at all
07:19:43 <quicksilver> I didn't say it couldn't be faster than Data.List.sort
07:19:55 <BeelsebobWork> quicksilver: no, but Myoma did
07:19:58 <quicksilver> I said it couldn't be 2x faster than the same algorithm run on one core
07:20:04 <Myoma> Axman6: Can I see the code? I want to compare it with my sequential one
07:20:04 <quicksilver> BeelsebobWork: myoma was just echoing me.
07:20:08 <Botje> _Dae_: put the do on a new line
07:20:39 <quicksilver> _Dae_: the error is the 'else' IMO
07:20:39 <Myoma> quicksilver: I wasn't echoing you, the gph quicksort is slower than sequential,
07:20:48 <Botje> heh
07:20:48 <Botje> also
07:20:51 <BeelsebobWork> quicksilver: the statement about not getting to 2x performance sounds reasonable to me
07:20:52 <quicksilver> Myoma: yes, but that's not interesting.
07:20:54 <Botje> you left out the then :)
07:20:55 <Myoma> quicksilver: I don't think anybody is going to write a faster parallel quicksort than gph
07:21:13 <quicksilver> Myoma: comparing two completely different algorithms has nothing to do with parallel vs sequential.
07:21:22 <Myoma> quicksilver: different algorithms?
07:21:28 <Axman6> Myoma: one sec
07:21:46 <Myoma> the only variable I changed was sequential vs parallel evaluation, they use the same algorithm
07:21:49 <quicksilver> _Dae_: you can't start a satement with 'else'
07:23:16 <_Dae_> quicksilver: right.... forgot the then.... and the bugs in haskell mode... thanks :)
07:23:35 <Axman6> Myoma: http://hpaste.org/10391#a1
07:23:41 <Myoma> thanks
07:23:57 <quicksilver> _Dae_: use kuribas' better indentation package
07:23:59 <Axman6> there's a better one, but it's harder to parallelise
07:24:01 <quicksilver> _Dae_: it works :)
07:24:57 <_Dae_> quicksilver: I must admit that I havne't been able to install anything on fedora that doesn't come in a fancy RPM...or at least with a "make install"
07:26:02 <Axman6> Myoma: it's not really all my code. i wrote it all, but using tricks from some site i saw. i'm also not sure if it's actually any good
07:26:10 <Myoma> Axman6: looks like your qsort is faster than the pqsort
07:26:17 <Myoma> by my benchmark
07:26:46 <Axman6> Myoma: how large is the data, and are you using a compiled version, and using multiple cores with it?
07:27:04 <Axman6> because, for large data, it's quite a bit faster. maybe 1.5x
07:27:04 <Myoma> 2^16 through to 2^20, yes, yes
07:28:02 <Axman6> and you're running with +RTS -N2 or something?
07:29:15 <quicksilver> _Dae_: you should be up to the task of installing a single .el file somewhere emacs can find it :)
07:29:46 <_Dae_> quicksilver: heh, actually I can't find my .emacs file, which makes it a lot harder....
07:32:02 <Axman6> Myoma: try out this: http://hpaste.org/10392
07:33:36 <BeelsebobWork> Axman6: I have to say -- I'm finding your parallel version to be roughly 2x slower than the sequential one on a 4 core xeon
07:33:49 <BeelsebobWork> (with a list of 10,000,000 elements)
07:33:55 <Axman6> heh, fair enough. i never said it was very good
07:34:24 <quicksilver> that's what I'd expect.
07:34:44 <quicksilver> I'd only expect a speed up when everything fits neatly in cache and some magic gets the coherency between the cores right.
07:35:01 <quicksilver> otherwise, sort of large lists should be memory bound and thus not parallelisable
07:38:21 <laz0r> anyone here who ever attempted to write a haskell binding for ODE?
07:42:41 <mrh> how can create two diffrent data types, but with same name for e.g data X = A { a :: String } B {a :: String } AND data Y = A {a :: String, b :: Int }
07:42:55 <Myoma> mrh: put them in different files
07:44:00 <mrh> aha ok
07:45:02 <Xenoblitz> Hi guys... quick question. I have a syntax error I can't figure out. Its probably very simple put I've been working on it for some time now and I can't find the actual error at hand. Code: http://hpaste.org/10394
07:45:23 <Xenoblitz> Any ideas would be greatly appreciated.
07:45:27 <Myoma> put spaces before then and else
07:45:39 <BeelsebobWork> Xenoblitz: let expressions need an in part
07:45:41 <Myoma> but you should also lift the let out from the branches
07:45:46 <Myoma> No they don't
07:45:50 <Twey> Not in do notation, BeelsebobWork
07:45:51 <BeelsebobWork> yes they do
07:45:58 <ziman> let newB = if .. then .. else
07:45:59 <BeelsebobWork> no, but those aren't in do notation
07:46:00 <Twey> Ah
07:46:03 <Twey> Indeed
07:46:22 <quicksilver> what a lot of confused advise
07:46:25 <quicksilver> no offence guys :P
07:46:34 <BeelsebobWork> indeed, we were all saying the same thing from a different angle
07:46:37 <quicksilver> there already are spaces before then and else, as far as I can see.
07:46:47 <quicksilver> Xenoblitz: "let" isn't like a statement.
07:46:51 <BeelsebobWork> either way ,you need to get to let newB = if (....) then (Brick ...) else (Brick ...)
07:47:02 <quicksilver> Xenoblitz: you can't have it inside the 'if' and expect it to have effect outside the if
07:47:04 <Twey> Better: let newB = if s == No_Shape then Brick newS (0, 0) Up_Direction newG else Brick newS (x,y) d newG
07:47:18 <Xenoblitz> i think i know what you guys mean
07:47:27 <BeelsebobWork> in the mean time
07:47:27 <andrewsw> quicksilver: scope issue?
07:47:30 <BeelsebobWork> that's a load of imperative code
07:47:34 <BeelsebobWork> for something functional
07:47:35 <BeelsebobWork> fix it
07:47:42 <Twey> Heh
07:47:57 <Xenoblitz> BeelsebobWork: i need it to be imperative... its what I need right now... writing a DSL for tetris...
07:48:04 <Xenoblitz> quicksilver: thanks again mate...
07:48:30 <BeelsebobWork> Xenoblitz: doesn't sound like you need it to be imperative at all then -- it sounds like you're trying to trick yourself into not learning functional programming
07:48:32 <quicksilver> andrewsw: more of an impedance mismatch on what scope means in haskell. or what a statement is.
07:48:52 <quicksilver> Xenoblitz: I don't take as extreme a view as BeelsebobWork does. What are you doing there *is* functional programming ;)
07:49:05 <quicksilver> State Game Bool is a perfectly nicely behaved function type.
07:49:23 <quicksilver> it's just Game -> (Game,Bool)
07:49:27 <Xenoblitz> BeelsebobWork: I am doing my best to learn... I went from nothing to that as fast as I could... I don't know how to do it otherwise
07:49:28 <Twey> Mm.  I agree that it's not as nicely-written as it could be.
07:50:11 <BeelsebobWork> quicksilver: no, it's imperative programming -- in a functional language
07:50:23 <quicksilver> BeelsebobWork: I don't agree.
07:50:34 <Xenoblitz> guys: thanks for the advice... and seriously I know I need to get better
07:50:35 <BeelsebobWork> in the same way as I'm perfectly capable of writing functional programs in map reduce
07:50:40 <quicksilver> he is constructing a function of type Game -> (Game,Bool)
07:50:43 <BeelsebobWork> that's a functional program in an imperative launguage
07:50:48 <Xenoblitz> :S
07:50:50 <BeelsebobWork> this is imperative programming in a functional language
07:50:51 <quicksilver> which is a nice functional type
07:51:03 <quicksilver> he's constructign it using some combinators (put,>>) which are handy
07:51:11 <quicksilver> sure, the style he's chosen is mildy imperative, but not very.
07:51:17 <BeelsebobWork> it's very very imperative
07:51:26 <BeelsebobWork> it's litterally, "do this, do that, do that"
07:51:30 <BeelsebobWork> you can't get more imperative
07:51:41 <Twey> Xenoblitz: It does look like it's been translated line-by-line from Java or something
07:51:47 <Xenoblitz> no its not
07:51:50 <quicksilver> > (+1) . (*3) $ 5
07:51:51 <lambdabot>   16
07:51:56 <Twey> Xenoblitz: What are you learning from?
07:51:59 <quicksilver> ^^ that is "do this then do that"
07:52:09 <quicksilver> "multiply by 3" then "add one"
07:52:13 <Xenoblitz> online, books, tutorials
07:52:15 <quicksilver> I wouldn't consider it imperative.
07:52:17 <BeelsebobWork> quicksilver: yes, yes it is, that's why I'd write 5*3+ 1
07:52:35 <Twey> Xenoblitz: Have you gone through this: http://book.realworldhaskell.org/read/ yet?
07:52:49 <mc__> Functional Programming is also a great book
07:52:57 <dblazakis> someone should write it in a style they believe to be clearer, or at least an example of what would be more *Haskell* like
07:52:59 <Xenoblitz> instead of questioning my code... why don't you tell me WHY its wrong?
07:53:14 <dblazakis> Xenoblitz: exactly ;-)
07:53:15 <chrisdone> I'd say imperative is a process that can't be performed by substitution
07:53:21 <Xenoblitz> i mean sure... its imperative... but that's what the state monad is for right? and i need the state monad!
07:53:29 <BeelsebobWork> dblazakis: well, which do you consider clearer? (5*3+1), or (+1) . (*3) $ 5
07:53:30 <Axman6> Xenoblitz: what fun would peer help be without critisism?
07:53:43 <BeelsebobWork> I'd say you'd have a tough time arguing for the latter
07:54:03 <BeelsebobWork> because it's annotating something purely functional with a load of ordering information, that isn't in any way relevant to the computation
07:54:04 <dblazakis> BeelsebobWork: i agree, but i'm not sure what the point is
07:54:13 <maltem_> Xenoblitz: I suppose what bothers most people is that you don't encapsulate/seperate as much as people usually do in functional languages. For example it doesn't feel good to have a variable d for direction even if there is no shape that the direction may apply to
07:54:42 <BeelsebobWork> dblazakis: the point I'm making is that writing something in an order independant way is usually clearer than with order -- becuase most of the time order isn't important at all
07:54:43 <Xenoblitz> guys you totally lost me
07:54:52 <maltem_> Xenoblitz: There nothing "wrong" about that, it just isn't as pretty as one might wish for code to be.
07:54:53 <Xenoblitz> it is here !!!
07:54:57 <quicksilver> Xenoblitz: just ignore it. You're doing fine.
07:55:02 <Xenoblitz> order is important here!
07:55:08 <maltem_> heh
07:55:08 <BeelsebobWork> no it isn't
07:55:11 <Xenoblitz> i need to generate a brick depending on something else!
07:55:15 <chrisdone> I'm running this program http://hpaste.org/10395#a1 and I'm looking at the memory usage in my system monitor, and each time I hit enter, the memory usage goes up about 4KB, after a couple thousand uses of `run', it's up to a 1MB. is ghc's runtime planning on collecting any of this or will it go up and up and up? also, can anyone see anything blatant about why this might be happening?
07:55:26 <quicksilver> BeelsebobWork: there is just as much order in (5*3)+1 as there is in (+1).(*3)$5
07:55:32 <quicksilver> BeelsebobWork: it's just expressed differently.
07:55:37 <Axman6> anyone here use yi?
07:55:38 <BeelsebobWork> quicksilver: absolutely
07:55:42 <quicksilver> you still need to apply the * before the +
07:55:46 <BeelsebobWork> indeed you do
07:56:02 <BeelsebobWork> but when you *read* the code you read one as five times 3 plus one
07:56:15 <BeelsebobWork> and the other as "start with 5, multiply by 3, and add one to the result"
07:56:19 <Xenoblitz> BeelsebobWork: Seriously, now pls give me more concrete advise, how I can improve! Just telling me I didn't something wrong is not improving anyone's life.
07:56:26 <Baughn> chrisdone: Where are you closing the handles?
07:56:46 <chrisdone> Baughn: hGetContents closes the handles as far as I'm aware. let me double check
07:57:05 <Baughn> chrisdone: SO it does. Never mind.
07:57:06 <chrisdone> Baughn: Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is immediate closed.
07:57:07 <BeelsebobWork> Xenoblitz: I'd suggest trying to write it without any IO in it, and without the do
07:57:09 <BeelsebobWork> and see how it comes out
07:57:19 <maltem_> Xenoblitz: personally I'd remove No_Shape from the code and instead use Maybe in the definition of Game
07:57:33 <quicksilver> BeelsebobWork: the code of Xenoblitz's that we were looking at just now doesn't have any IO in it.
07:57:40 <Xenoblitz> BeelsebobWork: 1. there is no IO monad
07:57:43 <quicksilver> BeelsebobWork: generateNewBrick :: State Game Bool
07:57:46 <maltem_> BeelsebobWork: There's no IO in it
07:57:50 <Baughn> chrisdone: Not /immediately/, no. It doesn't close until you find the end, or the string is GC'd
07:57:56 <Xenoblitz> maltem_: the No_Shape is needed for when I don't want to have a shape... its not a Maybe value
07:57:57 <BeelsebobWork> oh, wubs so it isn't -- sorry, remove the State monad
07:58:04 <Baughn> chrisdone: ..strictIO? Hmm
07:58:05 <BeelsebobWork> I saw the bind and the random in there and assumed IO
07:58:10 <quicksilver> Xenoblitz: don't remove the state monad.
07:58:19 <Xenoblitz> BeelsebobWork: Why remove the state monad???
07:58:21 <chrisdone> Baughn: right, I am using http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html#v%3AhGetContents
07:58:27 <lambdabot> Title: System.IO.Strict, http://tinyurl.com/58xunw
07:58:28 <BeelsebobWork> Xenoblitz: because what you're doing is not stateful
07:58:39 <quicksilver> Xenoblitz: the state monad is a convenient way to build up pure functions.
07:58:39 <BeelsebobWork> you're transforming one well into another
07:58:43 <BeelsebobWork> there's no state involved at all
07:59:00 <maltem_> Xenoblitz: well I'm guessing here about your code, but Maybe is exactly used in situations where you might want to not have something
07:59:01 <Baughn> chrisdone: Now, as for your question..
07:59:09 <Xenoblitz> BeelsebobWork wellBefore -> wellAfter... if you ask me that's a change of state
07:59:11 <BeelsebobWork> that function should be along the lines of addNewBrick :: Well -> Well
07:59:22 <Baughn> chrisdone: I have no idea. You're not keeping a handle on /anything/. So unless there is, in fact, a handle that's staying open...
07:59:27 <quicksilver> BeelsebobWork: there is no different between Well -> Well and State Well ()
07:59:39 <quicksilver> BeelsebobWork: the State monad *is* just a convenient tool for building up functions.
07:59:40 <BeelsebobWork> quicksilver: sure there is -- whether you do things in an ordered way or not
07:59:45 <quicksilver> BeelsebobWork: rubbish.
07:59:48 <BeelsebobWork> whether you specify what you do, or what it is
07:59:51 <quicksilver> absolute rubbish.
08:00:07 <Twey> Technically, I'm with quicksilver
08:00:08 <quicksilver> newtype State s a = State (s -> (s,a))
08:00:11 <Twey> Semantically, BeelsebobWork
08:00:11 <quicksilver> that really is all it is.
08:00:21 <quicksilver> it's just a tool for building up functions.
08:00:22 <BeelsebobWork> quicksilver: I don't *care* what the internal data structures look like
08:00:25 <BeelsebobWork> I care what my code looks like
08:00:26 <quicksilver> when it's a useful tool, use it.
08:00:27 <Twey> It *is* just another way of doing that
08:00:37 <Twey> But it's also another way of *thinking* about that problem
08:00:45 <BeelsebobWork> I care that my code does not give implicit orderings that are not there
08:00:56 <Baughn> chrisdone: Which you say there isn't. This is odd, though - how can it "immediately close" out without reading anything from err? Unless it's not actually /printing/ anything to err, I'd expect that handle to "back up" and cat to block until it your program reads it, which it won't..
08:01:27 <Xenoblitz> what order do you see as superfluous?
08:01:27 <quicksilver> well written state monad code gives no more implement orderings than the direct equivalent.
08:01:27 <quicksilver> s/implement/implicit/
08:01:27 <chrisdone> Baughn: as far as I can see, the handles are just stdin, stdout and stderr. now, I close stdin myself, and stderr and stdout are closed by hGetContents. I will say not that I previously added hClose for stderr and stdout just in case, but the memory usage is the same
08:02:01 <Xenoblitz> BeelsebobWork: what order is there that you see as superfluous?
08:02:16 <Xenoblitz> BeelsebobWork: tell me that and if I see that you have a valid point I'll fix it
08:02:18 <Baughn> chrisdone: Nope. Don't get it. I stand by my statement on strictly reading out, since they're interleaved /in the program/, but as cat wouldn"t print anything to stderr..
08:02:26 <Axman6> hmm, that sure is some very imperitive code
08:02:36 <BeelsebobWork> Xenoblitz: does s *have* to be compared with No_Shape after making a new random value?
08:02:40 <BeelsebobWork> or can it be done in either order?
08:02:48 <Axman6> uh, imperative
08:02:54 <BeelsebobWork> can you produce Brick before generating the random value?
08:02:59 <BeelsebobWork> etc
08:03:25 <BeelsebobWork> if you do it without the state monad you get rid of the put/get (which scream modification, even if they aren't implemented that way)
08:03:33 <BeelsebobWork> you instead just get a pattern match
08:03:42 <BeelsebobWork> what does the well look like before
08:03:47 <BeelsebobWork> and then you say what the well looks like after
08:03:57 <BeelsebobWork> it's just a transformation from one well to another
08:04:03 <chrisdone> can you please utilise a comma, instead of enter?
08:04:32 <chrisdone> Baughn: I'm not sure I follow about the interleaved part of what you are saying. let me re-read
08:04:38 <BeelsebobWork> chrisdone: I'd rather not -- I find lots of short lines more useful in IRC than one big long one both for readers and writers.
08:05:44 * Axman6 agrees, kinda
08:05:46 <chrisdone> BeelsebobWork: I find I have to scroll up past your soliloquy
08:05:57 <BeelsebobWork> chrisdone: sorry, it was a little much, yes
08:06:26 <BeelsebobWork> there was just a lot that I'd change about that code
08:06:31 <dblazakis> i forgot an in, but is this what you mean http://hpaste.org/10394#a1
08:06:35 <Xenoblitz> BeelsebobWork: i read what you said but I put everything there for a reason. It could be clearer maybe yes... but the semantics are there.
08:06:50 <mrh> Hey, im receiving this error "Illegal type  "Array -> Profile" in constructor application" here's the link: http://hpaste.org/10397
08:06:53 <Axman6> anyway, Xenoblitz, just think about your problem a bit more, and decide if it really needs to be that imperative. there aren't that many things in haskell that do need to be
08:06:58 <maltem_> BeelsebobWork: as for the order of comparison and new value, there isn't really expressed any order in the code. It's on different lines, but the same would be the case with a non-monadic let statement or any other way to express it
08:07:22 <BeelsebobWork> maltem_: I disagree -- using do notation, and words like put and get are provocative things
08:07:32 <BeelsebobWork> they get red as "do this then that then this then that"
08:07:39 <dblazakis> oops that codes a little wrong, maybe type don't make sense, but... general idea
08:07:42 <BeelsebobWork> and "put this into this box" i.e. "mutate this box"
08:08:00 * Axman6 thinks he would alsp prefer let newB = if (n ==...) then ... else...
08:08:04 <Axman6> also*
08:08:15 <Xenoblitz> Axman6: that's the only thing i asked here
08:08:16 <maltem_> BeelsebobWork: agreed, but not for let statements inside a do block
08:08:24 * Axman6 wins!
08:08:32 <BeelsebobWork> maltem_: I'm arguing to completely remove the do block and the State monad
08:08:48 <BeelsebobWork> he's writing a pure function from Well -> Well
08:08:55 <BeelsebobWork> he should write it like one
08:09:01 <chrisdone> Baughn: can you please clarify what you mean about the stderr and stdout?
08:09:07 <quicksilver> and the State monad is a very good way to write pure funcitons Well -> (Well,Bool)
08:09:11 <maltem_> BeelsebobWork: yeah he would save the line with the get and the line with the put
08:09:20 <Saizan> it's true that when you use do-notation or (>>=) you've to analyze what the code is actually doing to infer that the operations commute
08:09:25 <maltem_> BeelsebobWork: but that would be it
08:09:25 <quicksilver> it has compositionality you don't get with simplistic functions
08:09:42 <quicksilver> and it stops you making s-primed-errors
08:09:46 <quicksilver> which are a common cause of bugs
08:09:49 <BeelsebobWork> maltem_: it's not really about saving lines -- it's about expressing it in a way that doesn't produce thoughts like "now mutate a variable" and "do this in order"
08:09:51 <Saizan> it's also true that in a let- or where- you've to analyze data-dependencies to see what's happening
08:09:58 <BeelsebobWork> because the computation he's expressing does not have order
08:10:06 <BeelsebobWork> so why should he express it in an ordered way?
08:10:38 <Xenoblitz> BeelsebobWork I need to generate and number, then use it to generate the brick, then use it to put it in the well... there is a kind of order involved... using let and in you do the same thing really don't you? its just implicit
08:10:46 <Axman6> hmm, would using fold* and (>>=) be useful, if you had a lot of things you needed to apply on a monad?
08:10:55 <Xenoblitz> if that's not the case, then I spent 2 months reading and I understood nothing
08:10:57 <BeelsebobWork> Xenoblitz: oh? why should you generate the brick before putting it in the well?
08:11:12 <quicksilver> Xenoblitz: no, your understand was absolutely correct.
08:11:13 <Xenoblitz> :S how could you do it otherwise?
08:11:13 <BeelsebobWork> why shouldn't you create a well, with a brick in it, that you don't yet know the shape of?
08:11:17 <Axman6> > foldr f x [1..10]
08:11:18 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 x)))))))))
08:11:32 <Axman6> > foldr (>>=) x [1..10]
08:11:34 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
08:11:34 <lambdabot>      Proba...
08:11:38 <quicksilver> Xenoblitz: there might well be ways your code could be made a little neater, but your basic understanding is correct, and the State monad is useful for this sort of thing.
08:11:46 <Axman6> > foldr (>>=) x [f,g,h]
08:11:47 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
08:11:47 <lambdabot>      Proba...
08:11:53 <maltem_> BeelsebobWork: alright, maybe he reads his code as if it were describing something ordered, and maybe he wouldn't do so if he didn't use a State monad... That's didactics, though, I'd argue
08:11:57 <Xenoblitz> because i am also doing this because its the second brick after the first, or the third...
08:12:01 <BeelsebobWork> Xenoblitz: you can easily describe what your ouput is going to look like "it's a well, with a brick in it, which has a random shape"
08:12:03 <Axman6> guess not...
08:12:08 <BeelsebobWork> that's got nothing to do with order at all
08:12:14 <Axman6> > foldl (>>=) x [f,g,h]
08:12:15 <lambdabot>   Couldn't match expected type `m b' against inferred type `Expr'
08:12:55 <Axman6> > foldl (>>) x [f,g,h]
08:12:56 <lambdabot>   Couldn't match expected type `m b' against inferred type `Expr'
08:13:13 <Axman6> > foldl (>>) (Just x) [f,g,h]
08:13:14 <lambdabot>       No instance for (SimpleReflect.FromExpr (Maybe Expr))
08:13:14 <lambdabot>        arising fr...
08:13:32 <Axman6> whatevs, see if i care lambdabot
08:13:38 <Xenoblitz> BeelsebobWork: I think that's much more harder to describe than you think :S
08:14:30 * Axman6 mumbles about 'harder' or 'more hard'
08:14:47 * BeelsebobWork_ wonders what he missed in the net splode
08:15:08 * maltem_ suggests the IRC log
08:15:09 <BeelsebobWork_> maltem_: I'd argue it's using haskell for what it's best at -- describing what things are, not how to make things
08:15:38 <Axman6> BeelsebobWork_: "01:16 < Xenoblitz> BeelsebobWork: I think that's much more harder to describe than you think :S"
08:15:41 <Axman6> that's all
08:15:53 <Axman6> and possibly me screwing with code that doesn't work
08:15:56 <BeelsebobWork_> Xenoblitz: well, there was one thing that my description didn't include
08:16:04 <BeelsebobWork_> and that was that the well should contain all the stuff it used to
08:16:10 <Axman6> @hoogle a -> Maybe a
08:16:10 <lambdabot> Prelude Just :: a -> Maybe a
08:16:10 <lambdabot> Data.Maybe Just :: a -> Maybe a
08:16:10 <lambdabot> Distribution.ParseUtils ignoreUnrec :: UnrecFieldParser a
08:16:31 <Axman6> > just 1
08:16:32 <lambdabot>   mueval: Prelude.read: no parse
08:16:34 <BeelsebobWork_> so, given a match on a certain well -- it should contain the same bricks as it did before, plus one more that gets generated randomly
08:16:37 <Axman6> > Just 1
08:16:37 <BeelsebobWork_> that's not hard to write
08:16:38 <lambdabot>   Just 1
08:16:52 <Axman6> @hoogle a -> Maybe
08:16:52 <lambdabot> Did you mean: a -> Maybe a /count=20
08:16:52 <lambdabot> Prelude id :: a -> a
08:16:52 <lambdabot> Data.Function id :: a -> a
08:16:57 <Xenoblitz> can you then in the end do stuff like this...
08:17:28 * sw17ch isn't sure what the argument is about
08:17:38 <Xenoblitz> runGame :: State Game Bool
08:17:38 <Xenoblitz> runGame
08:17:38 <Xenoblitz>   = do
08:17:38 <Xenoblitz>        generateNewBrick
08:17:38 <Xenoblitz>        rotateRight
08:17:39 <Xenoblitz>        rotateLeft
08:17:41 <Xenoblitz>        rotateRight
08:17:43 <Xenoblitz>        moveRight
08:17:45 <Xenoblitz>        moveRight
08:17:47 <Xenoblitz>        rotateLeft
08:17:49 <Xenoblitz>        dropBrick
08:17:51 <Xenoblitz>        generateNewBrick
08:17:52 * Twey winces.
08:17:52 <Axman6> ....
08:17:53 <BeelsebobWork_> Xenoblitz: you could -- but why would you want to?
08:17:53 <Xenoblitz> cause that's what i am aiming at
08:17:55 <Xenoblitz> sorry about the paste but hpaste isn't for that i think
08:18:03 <Axman6> yes it is
08:18:04 <Xenoblitz> because I want a DSEL for Tetris in Haskell
08:18:06 <_Dae_> sw17ch: semantics
08:18:07 <Twey> hpaste is for whatever you use it for
08:18:30 <Botje> Xenoblitz: in general, anything over 4 lines should go on hpaste
08:18:47 <sw17ch> _Dae_: i think that one of the good things about programming is taht we let people do things in more than one way.... something tells me dropping do notation and the state monad would be a big mistake... since we remove a way to do something that is well understood
08:18:48 <Xenoblitz> ok but that's beside the point here guys... I want to know what BeelsebobWork wants me to learn
08:18:50 <Axman6> quick question, could that code be written as generateNewBrick >> rotateRight >> ...?
08:18:58 <chrisdone> yes
08:19:08 <Axman6> excellent
08:19:08 <Xenoblitz> yes but its neater like that imho
08:19:22 <Axman6> sure, i was just wondering
08:19:35 <quicksilver> Xenoblitz: if your DSL never returns values, it may as well be a Monoid
08:19:43 <quicksilver> which most people consider a simpler structure than a monad
08:19:56 <quicksilver> but perhaps it does generate a Bool?
08:20:11 <_Dae_> sw17ch: In this case, I agree. In general....well...the multi-paradigm languages seems to be an invitation to spaghetti code ;)
08:20:29 <sw17ch> _Dae_: can't you spaghetti anything?
08:20:31 <Axman6> yay! OS X decided to give me back my ram. about time
08:20:34 <Twey> *cough Python cough*
08:21:15 <_Dae_> sw17ch: sure.... but certain languages almost force you to do it
08:21:29 <Wild_Cat> Python doesn't really invite spaghetti IMO.
08:21:34 <Twey> Indeed.
08:21:38 <Twey> That's why I brought it up :)
08:21:50 <Xenoblitz> Python is directly impure, no?
08:21:55 <Wild_Cat> Twey: ah, I thought you were bringing it up for the other side of the argument.
08:22:03 <Twey> Aye, but it's also multi-paradigm.
08:22:13 <sw17ch> (i suppose my Haskell is generally less spaghetti and more ruote)
08:22:19 <Twey> (imperative + OO + a-little-bit-of-functional)
08:22:56 <Wild_Cat> well, Python's a pure OO language now. In that everything's an object. But it has function objects, which may or may not fit the pure/impure model. YMMV.
08:23:11 <Axman6> any yi users around? :\
08:23:31 <flux> wild_cat, is "if" an object also?
08:24:10 <chrisdone> is the function application operator () an object?
08:24:13 <Wild_Cat> flux: nope, it's a statement... But I don't really see how that's relevant to its OO purity?
08:24:15 <chrisdone> is whitespace an object?
08:24:18 <_Dae_> Actually.... I guess c++ is one of the worst spaghetti languages out there if you're not areful
08:24:18 <skorpan> could someone tell me if this snippet can be shortened? http://hpaste.org/10398
08:24:46 <flux> wild_cat, pure OO simply means all first-class object are, well, objects?
08:24:53 <sw17ch> skorpan: get >>= vty
08:24:54 <sw17ch> ?
08:24:57 <Botje> skorpan: vty `liftM` get
08:24:59 <sioraiocht> get >>= return . vty
08:25:00 <quicksilver> skorpan: vty <$> get
08:25:09 <Botje> skorpan: or gets vty
08:25:09 <sioraiocht> :t (<$>$
08:25:10 <lambdabot> parse error (possibly incorrect indentation)
08:25:11 <quicksilver> skorpan: or 'gets vty'
08:25:13 <sioraiocht> :t (<$>)
08:25:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:25:19 <chrisdone> getVty = vty `fmap` get
08:25:25 <sioraiocht> :t fmap
08:25:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:25:29 <flux> wild_cat, the comparison obviously was to smalltalk, which I guess serves as the prime example of pure OO
08:25:31 <sioraiocht> so <$> = fmap?
08:25:35 <chrisdone> yes
08:25:35 <skorpan> ah, of course gets
08:25:48 <sioraiocht> is state a functor, then?
08:25:56 <chrisdone> no, monads are functors
08:26:05 <chrisdone> and state is because it's a monad
08:26:15 <sioraiocht> chrisdone: well, not all functors are also monads
08:26:15 <skorpan> it's interesting that i got four completely different answers :)
08:26:21 <sioraiocht> but yes, i forgot that all monads are functors
08:26:22 <chrisdone> sioraiocht: so?
08:26:39 <sioraiocht> i was more asking if state was an instance of Fuctor
08:26:41 <sioraiocht> *functor
08:26:42 <Wild_Cat> flux: Smalltalk has if, for et al. as objects? Interesting
08:26:49 <quicksilver> skorpan: in my opinion "gets" is inferior to "fmap"/<$>
08:26:49 <chrisdone> sioraiocht: it is because it's an instance of Monad
08:27:04 <sioraiocht> chrisdone: orly? last I checked that's not how type classes worked..
08:27:11 <quicksilver> skorpan: because the fmap/<$> solution is applicable to everything, not just get
08:27:20 <sioraiocht> and Monad doesn't require that instances also be functors
08:27:29 <quicksilver> chrisdone: "because" in a moral sense
08:27:38 <quicksilver> not in a technical haskell-is-built-like-that sense
08:27:49 <sioraiocht> chrisdone: yes, exactly
08:28:06 <sioraiocht> I understand in the category theoretic notion of functors and monads
08:28:19 <sioraiocht> and it doesn't relate exactly to haskell instances
08:28:32 <chrisdone> the point is sensible people define instances of Functor along with instances of Monad
08:28:34 <Saizan> all the monads in mtl are also instances of Functor
08:28:36 <chrisdone> and Haskellers are sensible people
08:28:54 <vegai> are they?
08:28:58 <chrisdone> well, you aren't
08:28:59 <_Dae_> chrisdone: can I quote you on that?
08:28:59 <chrisdone> but mostly
08:29:06 <chrisdone> ;_;
08:29:07 <eu-prleu-peupeu> hello people from planet haskell
08:29:16 <flux> wild_cat, actually if isn't an object, but you send messages such as ifTrue or ifFalse to objects
08:29:29 <sioraiocht> chrisdone: that is SO not always true, heh
08:29:31 <sw17ch> i think i sense a bot...
08:29:36 <chrisdone> _Dae_: yes
08:29:39 <vegai> can I quote you on calling me a Haskeller?
08:29:47 <chrisdone> vegai: no
08:30:32 <Wild_Cat> flux: as in, "myObject ifTrue: codeBlockToEvaluateIfTrue ifFalse: codeBlockToEvaluateIfFalse"?
08:30:38 <flux> wild_cat, yes
08:30:57 <Wild_Cat> am I allowed to say "yuck"?
08:31:12 <flux> this gives some examples and explanations: http://wiki.squeak.org/squeak/3290
08:31:17 <vegai> hey, you're the kibro guy! How's that going?
08:31:44 <flux> wild_cat, no you're not, it's called cultural tolerance!
08:31:45 <flux> ;)
08:34:05 <chrisdone> vegai:  fine. hm, I used it for one or two projects. HDBC's sqlite3 has some problems which I may or may not be prepared to fix. I may just switch to mysql or postgre because it's less to worry about with threads and locking and whatnot
08:34:16 <igel> hi
08:34:25 <chrisdone> vegai: did you use it or something?
08:34:33 <igel> i try to run a Tests.lhs file with runghc
08:34:52 <igel> and i have to c-preprocessor-like define "__DEBUG__" to do that
08:35:09 <igel> how do the command line arguments look like for that?
08:35:26 <igel> i tried -D__DEBUG__ and -cpp -D__DEBUG__
08:35:47 <igel> but runghc complains: "-D__DEBUG__: no such file or directory"
08:35:50 <vegai> chrisdone: not so much, but a usable web toolkit would be a plus for the whole platform
08:35:58 <vegai> so I'm interested.
08:36:02 <igel> what am i doing wrong?
08:38:22 <igel> argh... these arguments were passed to /usr/bin/env and not runghc...
08:38:32 <igel> now it all works
08:38:53 <chrisdone> vegai: ah, right. well, whatever that platform may end up being, Formlets will certainly be included. check out this site I wrote (all in one file): http://paste.lisp.org/display/66863
08:39:02 <zachk> how do i use regex from ghc 6.8.3 out of the box
08:39:24 <chrisdone> vegai: are you aware of the Formlets library?
08:39:31 <chrisdone> zachk: Text.Regex?
08:39:45 <Wild_Cat> Text.Regex isn't part of Base
08:40:30 <zachk> chrisdone: yea im doing that but not getting any matches
08:40:47 <vegai> chrisdone: yes. I nifty to way to build web forms
08:42:01 <Wild_Cat> zachk: if you're using Ubuntu or Debian, the libghc6-regex-* packages will interest you.
08:42:24 <opqdonut>     
08:42:34 <opqdonut> sorry about that, network lag
08:42:50 <chrisdone> vegai: right. if you scroll down to "-- Registration form", that's one complete sign-up page. and scroll to "-- A simple drop down formlet", I built a simple dropdown/select formlet! I think formlets are probably the best example of Haskell's composability that I have seen
08:46:17 <chrisdone> chr1s❤
08:46:24 <dancor> after using first etc all this time, i really don't get arrows
08:46:43 <dancor> what is a very simple something you might want to use arrow syntax for
08:51:09 <dancor> actually this looks pretty good: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
08:51:36 <quicksilver> dancor: I find the first 2/3 of that to be unhelpful
08:51:46 <quicksilver> dancor: it's all about functions, and nothing about arrows-which-are-not-functions
08:51:54 <quicksilver> (surely we all know how functions behave)
08:52:03 <quicksilver> the example with the parser is good, though.
08:52:24 <quicksilver> there's nothing about arrow notation there though, unless I'm blind.
08:53:05 <zachk> how do i make Text.Regex the opposite of greedy matching? or I can't?
08:54:42 <dino-> zachk: I'm not sure if Text.Regex recognizes them, but p5 has the *?, +?, ?? etc not greedy things.
08:54:44 <chrisdone> I seem to remember recently that you can't
08:55:02 <chrisdone> there's the other regex library by dons that does have ?
08:56:02 <chrisdone> I know this one does: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light
08:56:05 <chrisdone> haven't tried the others
08:56:06 <lambdabot> Title: HackageDB: pcre-light-0.3.1, http://tinyurl.com/6agmkz
08:56:29 <Axman6> who here uses xmonad? i keep getting errors that defaultGaps doesn't exist
08:57:24 <skorpan> http://hpaste.org/10399 <- how would getPlaylistLine be shortened to one line?
08:58:06 <zachk> text reg ex does not have the p5 option dino-. by p5 you mean perl 5?
08:58:16 <swiert> skorpan: try using gets.
08:58:16 <chrisdone> skorpan:  playlistLine `fmap` gets display
08:58:46 <dino-> zachk: Yes, I was just musing on if it handled those *? type things, but chrisdone says NO.
08:59:00 <dino-> from Perl5's re rules
08:59:28 <skorpan> thanks chrisdone
08:59:42 <Saizan> Axman6: defaultGaps no longer exists, i think you've to use manageDocks now, (there's also #xmonad btw)
08:59:56 <chrisdone> dino-: it can be confirmed that it does not support `?' here:
08:59:58 <chrisdone> Text.Regex> matchRegex (mkRegex "(<.*?>)") "<foo></foo>"
08:59:58 <chrisdone> Just ["<foo></foo>"]
09:00:18 <Axman6> Saizan: yeah, in there already :)
09:00:58 <dino-> Interesting, it takes the notation in the re.
09:01:00 <chrisdone> dino-: if it supported non-greedy, that would be Just ["<foo>"]
09:01:04 <dino-> ya
09:01:12 <chrisdone> yeah, I'm not sure why it takes the notation
09:01:24 <quicksilver> skorpan: or, playlistLine . display `fmap` get
09:01:45 <quicksilver> skorpan: choice between special-case "gets" and a more general notion of composition.
09:03:34 <chrisdone> quicksilver: or gets (playlistLine . display)
09:04:12 <zachk> ahhh cabal install regex-pcre for perl regex's
09:05:28 <dino-> Axman6: I use xmonad, but I'm not using that defaultGaps.
09:05:44 <Axman6> dino-: yeah, it was removed in 0.8 apparently
09:05:51 <dino-> ah
09:05:55 <quicksilver> chrisdone: yup :)
09:06:06 <quicksilver> chrisdone: TMTOWTDI!
09:06:14 <chrisdone> quicksilver: what does that mean?
09:06:24 <quicksilver> There's More Than One Way To Do It
09:06:50 <chrisdone> I think I like `gets (playlistLine . display)' the best
09:06:57 <quicksilver> chrisdone: althouh I think if the practice of using <$> as an infix fmap was already widespread, maybe gets wouldn't have come to exist at all.
09:07:06 <chrisdone> quicksilver: true
09:07:30 <quicksilver> although I wish field names were actually lenses
09:07:36 <quicksilver> and then you *would* need something like gets
09:07:41 <quicksilver> to choose the selector-part
09:07:51 <chrisdone> but it would be a good thing then
09:08:11 * dancor wonders if he's uncool for using fmap instead of importing Control.Applicative
09:08:37 <dino-> Oh I was thinking  get >>= return . playlistLine . display  but the gets is best. I have to get used to not taking things out with >>= only to put them right back in. :P
09:09:12 <quicksilver> dino-: (>>=) . return is known as fmap or liftM
09:09:34 <quicksilver> @src liftM
09:09:35 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:09:35 <Baughn> chrisdone: Did you ever figure out where the leak was?
09:09:38 <chrisdone> quicksilver: LOL BUT I THOUGHT NOT ALL MONADS WERE FUNCTORS
09:09:49 <chrisdone> quicksilver: sorry. poor joke
09:09:53 <chrisdone> Baughn: no, I'm still looking at it
09:09:54 <quicksilver> ;)
09:10:33 <chrisdone> Baughn: I'm trying to use profiling. maybe that can show me what function is using space
09:10:37 <Baughn> chrisdone: It just doesn't seem possible. You're not keeping /anything/ between invocations of run, and handles have finalizers.. *pout*
09:10:48 * chrisdone chuckles
09:10:55 <quicksilver> chrisdone: did you try explicitly calling System.performGC?
09:11:15 <chrisdone> quicksilver: no, I haven't. at what point should I call it, do you think?
09:11:22 <dino-> I need to put that on a sign on the wall above my monitor: (>>=) . return == liftM == fmap
09:11:30 <quicksilver> once each time through the main loop, chrisdone
09:11:30 <Baughn> Surely not? Sure, it might not get called on every run invocation, but it would get called long before hitting 1MB
09:11:43 <quicksilver> just to see if GC is being called often enough
09:11:49 <chrisdone> I'll try it, one moment
09:11:51 <Baughn> chrisdone: Oh yeah, and you should use forever, not explicit recursion. Explicit recursion is bad. ;)
09:11:58 <quicksilver> Baughn: I agree, but it's an easy thing to try to eliminate the possibility
09:12:02 <chrisdone> Baughn: ah, whoops ;)
09:12:40 <Baughn> chrisdone: Run with +RTS -Sstderr -g1, while you're at it
09:12:52 <chrisdone> Baughn: okay
09:12:55 <Baughn> Er, -G1
09:14:57 <chrisdone> @hoogle performGC
09:14:58 <lambdabot> System.Mem performGC :: IO ()
09:14:59 <chrisdone> ah
09:18:55 <chrisdone> mmkay. I pasted the output: http://hpaste.org/10401
09:18:57 <zachk> @src any
09:18:57 <lambdabot> any p =  or . map p
09:19:45 <skorpan> where can i find information about haddock documentation?
09:19:45 <Baughn> > any (>2) [1..]
09:19:46 <lambdabot>   True
09:19:52 <chrisdone> so in the first one it looped a few times, but only one GC generation happend, apparently. whereas with performGC it did for each loop
09:20:32 <Baughn> chrisdone: Don't forget to account for the effect of -G1. It might not be the performGC call, per se
09:20:40 <Baughn> Actually, that shouldn't be why
09:21:03 <Baughn> (It already performs a GC when idle, such as while waiting for input)
09:21:05 <chrisdone> Baughn: I don't know how to interpret this output
09:21:46 <chrisdone> Baughn: but this bit kind of concerns me: 312,832 bytes allocated in the heap
09:22:10 <chrisdone> Baughn: where does it say how much of that was deallocated?
09:22:23 <dancor> what is a yampa arrow SF (Event Bool) (Event Bool) where the output becomes True forever once any input is True?
09:22:30 <chrisdone> Baughn: (if any)
09:22:32 <Baughn> chrisdone: Deallocated = alloc byytes - copied bytes
09:22:51 <dancor> oh actually, we can just make it SF (Event ()) (Event ())  too
09:23:10 <dancor> or SF (Event ()) Bool  may be clearest
09:23:23 <chrisdone> Baughn: ah
09:23:45 <Baughn> chrisdone: That first one is odd - it suggests that something is holding on to data when it should be unreferenced and GC-able
09:23:52 <Baughn> chrisdone: "233700 copis bytes"..
09:24:30 <scodil> ping dons
09:24:35 <Baughn> Oh wait, that's just the layout going wrong
09:24:40 <chrisdone> Baughn: 233700 allocated, 2500 copied
09:24:44 <chrisdone> Baughn: yeah, sorry about that
09:25:39 <Baughn> chrisdone: That the first only triggered one GC, suggests that you didn't invoke run enough
09:25:48 <Baughn> chrisdone: Try pressing enter more, or whatever it is you're doing. ;)
09:26:11 <chrisdone> Baughn: heh, okay
09:26:38 <Baughn> chrisdone: There are also options to tune the gc; normally, it's trying to balance GC time vs. memory size, which means your program can end up using a lot more memory than is actually live if it allocates enough; GC is cheaper the larger your arena is
09:26:43 <Baughn> At least, this kind of GC is
09:27:30 <Baughn> Though it's normally quite conservative, nobody seems to care that it might use a megabyte extra
09:28:34 <chrisdone> Baughn: right. I've never thought about the memory consumption this closely before. but the program which is using `run' is supposed to run for days on end. so it mounts up
09:28:58 <Baughn> chrisdone: My guess is, it'll hit a maximum memory use of maybe a megabyte or two
09:29:06 <atzeus> hi all, could someone please help me? I have major indentation issues and it's driving me nuts :)
09:29:17 <Baughn> chrisdone: You /should/ try to automate it. Make it run at max speed - pipe yes into it or something.
09:29:36 <sheyll> hi
09:29:44 <Baughn> atzeus: We can try. What editor are you using, by the way?
09:29:54 <Baughn> atzeus: Something with actual support for haskell (such as emacs/haskell-mode) does help
09:30:04 <atzeus> i'm using eclipse plugin
09:30:11 <atzeus> i just installed emacs with haskell mode
09:30:18 <atzeus> but i didn't help so far
09:30:23 <sebaseba> atzeus: post your code on hpaste
09:30:25 <sheyll> also vim is nice...
09:30:25 <atzeus> i'll show you the code
09:30:27 <chrisdone> Baughn: I did automate it. I ran it a couple thousand times and it got up to 3MB. I didn't try it any further, presuming that the GC would never collect it
09:30:36 <Baughn> chrisdone: With -Sstderr on?
09:30:52 <Baughn> chrisdone: (So you can tell when it collects)
09:31:17 <atzeus> i've put the code on hpast
09:31:24 <chrisdone> Baughn: it seems to collect every 10 or so hits of enter. but I'll do it with an automated one
09:31:26 <atzeus> title haskell indentation woes
09:31:39 <Baughn> chrisdone: You could try running with +RTS -M512k or so, to enforce more GCs
09:31:44 <atzeus> the problem is that i keep getting a parse error on the second where
09:31:59 <atzeus> total newbie question no doubt
09:32:09 <atzeus> i just can't figure out what the indentation should be
09:32:13 <sheyll> indent more
09:32:21 <sheyll> after where
09:32:22 <Baughn> atzeus: Post the url
09:32:33 <atzeus> http://hpaste.org/10402
09:32:53 <atzeus> uhmm ok, but it doesn't eat the where
09:33:24 <Baughn> atzeus: The where is supposed to attach to the function, right?
09:33:33 <atzeus> still the same error
09:33:35 <Baughn> atzeus: Then you need to indent your if-block more
09:33:42 <atzeus> yeah
09:33:46 <Baughn> Or.. which where?
09:33:51 <atzeus> attach to the whole function
09:33:52 <sheyll> atzeus: take a look at that http://en.wikibooks.org/wiki/Haskell/Indentation
09:33:54 <Wild_Cat> atzeus: did you check that you weren't mixing tabs and spaces? That's major bad
09:34:00 <atzeus> second where errror
09:34:09 <atzeus> yeah i cheched that
09:34:24 <Baughn> ..I think he /is/ mixing them
09:34:29 <Baughn> At least, the hpaste has them mixed
09:34:45 <atzeus> i'll double check
09:34:46 <Saizan> but you can't attach a where to an if-then-else, can you?
09:34:50 <Wild_Cat> and what's worse is that emacs seems pretty happy doing it, thinking it's oh so smart for saving you seven whole bytes of space...
09:34:53 <Baughn> Saizan: Nope
09:35:26 <quicksilver> atzeus: you can't have a 'where' on an 'if block'
09:35:36 <Baughn> Wild_Cat: Depends on the mode. Haskell-mode pointedly turns that off.
09:35:45 <quicksilver> atzeus: 'where's go on declarations not on expressions.
09:35:45 <atzeus> ah
09:36:05 <quicksilver> just stick all that into one large where
09:36:09 <Wild_Cat> Baughn: hopefully it does. But no matter what mode you're in, if shouldn't even exist.
09:36:09 <quicksilver> will be the simplest solution
09:36:10 <Baughn> atzeus: So the where there is fine, but the if needs to be more indented
09:36:23 <atzeus> ok
09:36:29 <Wild_Cat> I mean, tabs/spaces, pick one I don't care which, but for the love of Haruhi, pick *one*. :p
09:36:37 <atzeus> you're all confusing me :)
09:36:41 <quicksilver> Baughn: I don't believe this has anything to do with the indentation of the 'if'
09:36:45 <chrisdone> Baughn: is it me or does it always seem to be collecting less bytes than it allocates? http://chrisdone.com/out.txt
09:37:04 <Wild_Cat> but yeah, the where inside the if block is likely what screws things up, more than anything.
09:37:13 <Saizan> atzeus: the outer where is fine, the inner one is not because of what quicksilver said
09:37:13 <Baughn> atzeus: Actually, maybe you could paste your errors too? :)
09:37:28 <Saizan> atzeus: the simplest solution is to put all the definitions in the outer where
09:37:54 <chrisdone> Baughn: I'll try that option you said
09:37:54 <atzeus> ok making it one big where works
09:38:09 <atzeus> but why can't i make a local where just for the else?
09:38:23 <Wild_Cat> atzeus: because the language doesn't allow you to ;)
09:38:25 <quicksilver> atzeus: because you can't.
09:38:29 <quicksilver> atzeus: you can have a local 'let' though
09:38:30 <atzeus> :)
09:38:35 <Saizan> atzeus: because where works only in definitions, inside expressions you can use let .. in
09:38:43 <quicksilver> else let foo =bar; baz=bar in ...
09:38:47 <Baughn> chrisdone: I'm having difficulty understanding this output. With only a single generation, copied bytes "should" be equal to (the next row of?) live bytes
09:38:55 <Wild_Cat> atzeus: besides, Haskell is lazy. None of your definitions inside the where clause will be evaluated unless they're actually used somewhere.
09:38:57 <atzeus> ok, so instead of local where i can have a local let
09:39:14 <chrisdone> Baughn: it just seems to collect a lot more with the -M512k, that is, it keeps going up and up (to 2MB before I stopped it), but just slower
09:39:15 <Wild_Cat> so if it's performance you're worried about, don't ;)
09:39:23 <atzeus> wild_cat : i know :) i just wanted the definition to be local for clarity
09:39:33 <Baughn> chrisdone: Try compiling with -O2
09:39:50 <chrisdone> Baughn: I've been using that all along
09:39:58 <atzeus> so where can only be at the end of a function definition?
09:40:16 <chrisdone> Baughn: that output I linked is without performGC
09:40:18 <atzeus> and type, class etc definitions?
09:40:55 <Saizan> > let foo = bar where bar = 42 in foo -- also here
09:40:56 <lambdabot>   42
09:41:08 <chrisdone> Baughn: I don't follow any of this. I'm not happy :(
09:41:24 <Baughn> > if foo == 2 then 1 else 2 where foo = 2
09:41:25 <lambdabot>   1
09:41:32 <atzeus> allright thanks all!!! I going to get a bite to eat
09:41:43 <quicksilver> chrisdone: if you can't get an answer you're happy with, perhaps you could paste this to the -cafe?
09:41:58 <Baughn> chrisdone: A shot in the dark, but try with -Onot?
09:42:03 <quicksilver> chrisdone: it's not the first time I've seen people complain of apparent memroy leaks and I'd like to understand why.
09:42:05 <Baughn> chrisdone: Oh, and use forever, already
09:42:08 <chrisdone> Baughn: sure
09:42:27 <chrisdone> Baughn: I am
09:42:39 <chrisdone> quicksilver: okay
09:43:04 <chrisdone> Baughn: main = forever $ do run "cat" "foo"; return ()
09:43:34 <Baughn> chrisdone: main = forever (run "cat" "foo")?
09:43:52 <Baughn> @type forever
09:43:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
09:44:11 <dancor> oh i bet i can use accumBy for my problem
09:44:25 <chrisdone> Baughn: ah, thought it took m ()
09:45:35 <Baughn> chrisdone: Could you paste the full code again? I'd like to experiment with it.
09:46:01 <chrisdone> Baughn: okay!
09:48:02 <chrisdone> Baughn: http://hpaste.org/10403
09:49:20 <chrisdone> Baughn: can you compile it?
09:49:40 <Baughn> chrisdone: Waiting on hackage to install strictio
09:49:51 <chrisdone> Baughn: right
09:50:07 * birkenfeld replaces all "return f `ap` x" by "f <$> x"...
09:50:23 <Baughn> chrisdone: What was that package name, again?
09:51:44 <chrisdone> Baughn: it's just called strict: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
09:51:49 <lambdabot> Title: HackageDB: strict-0.3.2
09:52:40 <Baughn> chrisdone: Ah. Bad description, then.
09:52:48 <chrisdone> Baughn: alternatively just define IO.hGetContents h >>= \s -> length s `seq` return s
09:53:09 <Baughn> "cabal install strict" is faster. :P
09:53:12 <chrisdone> pasted before I had change to edit it, but w/e
09:53:17 <chrisdone> yes, hehe
09:55:43 <Baughn> chrisdone: ...are you *sure* you have a leak?
09:56:44 <chrisdone> Baughn: well, I don't know if it's a leak. it's just that the memory consumption goes up and up. if my program is going to be running for a long time with lots of calls to `run', I don't like the sound of it going into the 100MB region
09:57:05 <chrisdone> Baughn: why do you ask?
09:57:34 <Baughn> chrisdone: How fast does it go up? How long before I should see a result?
09:57:44 <Baughn> Because it's /not leaking/.
09:58:29 <chrisdone> Baughn: you mean yours isn't going up at all?
09:59:14 <chrisdone> Baughn: it takes 10 seconds to get to 2.3MB
09:59:25 <Baughn> chrisdone: Nope. Jumping between 40960 and 49152, and has been for minutes now
09:59:31 <chrisdone> Baughn: what GHC version?
09:59:43 <Baughn> 6.8.3, on os x 32-bit
10:00:05 <chrisdone> I'm using 6.8.3, linux 32-bit. hrrrm
10:00:06 <Baughn> Hang on, let me try another machine
10:00:58 <vegai> I'm using Data.Binary a bit wrong, but I'm not sure how
10:01:03 <vegai> here's a snippet: http://hpaste.org/10404
10:01:04 <chrisdone> Baughn:  see. jumping between 20960 and 49512 is the kind of behaviour I'd /expect/. that's why I was confused when it just kept going up
10:01:44 <vegai> the idea is that a datafile consists of 0x224 bytes of junk, then strings padded up to 14 bytes
10:02:19 <chrisdone> Baughn: I just let it run to "11 Mb total memory in use". what are the precise compilation and running arguments that you are using?
10:02:30 <vegai> but somehow the reads are all misaligned there
10:02:48 <Baughn> chrisdone: Linux x86_64, same result, though the gc is obviously tuned a lot differently
10:03:00 <Baughn> Only 75% productivity. I wonder who's responsible. :/
10:03:09 <Baughn> chrisdone: Just ghc --make -O2 test
10:03:13 <chrisdone> interesting!
10:03:40 <chrisdone> Baughn: linux produces the same result as I am getting, yes?
10:03:41 <Beelsebob> chrisdone: on OS X I've found ghc binaries can be a bit slow to start becaues of OS X's shit malloc implementation
10:03:48 <chrisdone> hmm
10:03:56 <Beelsebob> if you're passing -A to the command line, that's more than certainly the problem
10:03:59 <Beelsebob> try -H instead
10:04:12 <chrisdone> I'm not passing -A or -H
10:04:25 <Beelsebob> then it'll just be OS X being slow at mallocing
10:05:24 <Baughn> chrisdone: No, no problem on linux
10:05:29 <Baughn> Heap size doesn't /increase/
10:05:57 <Baughn> But it does collect much too often, with too low productivity. Hmm
10:06:13 <Baughn> I think that's your application's fault. It never quite manages to overflow into the second generation.
10:06:34 <vegai> oh well, I'll just do it without Data.Binary.  http://hpaste.org/10404
10:06:44 <Baughn> Ah yes. Setting a higher allocation area size helped a lot.
10:07:22 <chrisdone> Baughn: is this kind of thing why lambdabot had to be restarted because it maxed out on memory?
10:07:38 <Baughn> chrisdone: No, LB  had actual leaks
10:07:52 <Baughn> chrisdone: Yours seem to exist only on your machine, or possibly only on linux 32-bit
10:08:05 <chrisdone> Baughn: great... :P
10:08:35 <Baughn> chrisdone: Did you post to h-cafe already?
10:08:45 <chrisdone> Baughn: no. I'll do it now
10:09:08 <Baughn> chrisdone: Be sure to mention that, since undoubtedly a lot of the readers won't think to try different architectures
10:09:29 <chrisdone> Baughn: is it proper etiquette to paste code or a url to a pastebin?
10:09:49 <Baughn> chrisdone: On haskell-cafe? With your amount of code? Put it inline.
10:09:54 <chrisdone> Baughn: ok
10:10:03 <Baughn> chrisdone: It just struck me, which version of strict are you using?
10:10:12 * chrisdone looks
10:10:32 <Baughn> Anything that deals with low-level handles risks memory leaks if it isn't very careful
10:10:51 <chrisdone> Baughn: 0.3.2
10:10:57 <Baughn> Hmm. Same here.
10:16:33 <newsham> is http://luqui.org/ down?
10:25:04 <laz0r> newsham: it works here
10:25:39 <BMeph> newsh: "It's just you." :)
10:25:43 <laz0r> and what i actually want: is there a good ffi tutorial you guys would recommend?
10:26:33 <laz0r> just googling turned up the ffi cook book, that seems to be ok for a start
10:26:41 * BMeph respects the Coq language, but wishes there weren't so many opportunities for all of the cheap jokes at its name's expense...
10:26:41 <Cale> The FFI spec is pretty tutorial in nature actually
10:28:19 <laz0r> ok, i guess i'll just fiddle around with some actual code until i have more specific questions
10:28:58 <zachk> how can a pattern be nonexhaustive if there is an otherwise?
10:29:30 <sw17ch> zachk: do you ahve an example on hpaste somewhere?
10:29:49 <zachk> i just deleted the line oops :-9
10:30:12 <_zenon_> is otherwise not bound to guards? guards don't pattern-match per say.
10:30:13 <sw17ch> that would do it :)
10:30:15 <_zenon_> right?
10:32:50 <BMeph> Does anyone here have a good explanation for why it is said that functions are applied to arguments, instead of aarguments applied to functions? :)
10:33:05 <BMeph> I've always wondered, and hope that someone knows...
10:33:33 <quicksilver> well functions are verbs and arguments are nouns
10:33:39 <quicksilver> is one way of thinking of it
10:33:46 <quicksilver> but, it's entirely
10:33:53 <quicksilver> just conventinal :)
10:34:05 <trofi> argument is static :]
10:34:28 <BMeph> quicksilver: Ah, kind of why we write "f x" and not "x f"? :)
10:34:42 <sw17ch> 1 2 +
10:34:44 <_zenon_> Well, would you apply 1 and 2 on  (+) ?  or apply (+) on 1 and 2?
10:34:49 <quicksilver> plenty of people write x f
10:35:00 <sw17ch> 1 2 3 + *
10:35:02 <quicksilver> a certain school of mathematics has always had it that way around
10:35:06 <BMeph> trofi: Exactly! Why should you have to apply something that isn't static? :)
10:35:20 <birkenfeld> what is the reason for the "WrappedMonad" in Applicative?
10:36:08 <chrisdone> to apply is to put into effect, like a applying a rule, in this sense your function is like a rule. like applying a rule in the workplace, the rule is the function, the people are the arguments
10:36:10 <BMeph> _zenon_: I would apply 1 and 2 to (+), actually. That's my problem... ;)
10:36:19 <_zenon_> BMeph, hehe, interesting.
10:36:33 <BMeph> birkenfeld: So that "WrappedArrow doesn't get lonely? ;)
10:36:40 <quicksilver> birkenfeld: to work around the fact that there is no way to say "all Monads are Applicatives" without changing the definition of Monad.
10:36:40 <mattam> One applies a method to a problem not a problem to a method.
10:36:53 <chrisdone> right
10:37:07 <birkenfeld> quicksilver: but to just define an Applicative instance for my monad is okay?
10:37:13 <quicksilver> yes.
10:37:19 <quicksilver> recommended, indeed.
10:37:24 <birkenfeld> is that a type system restriction?
10:37:39 <quicksilver> anything which stops us doing what we wanted to do is a restriction.
10:37:43 <andrewsw> BMeph: no matter how many functions you apply to a 2, it's still a 2, so perhaps looking at it the other way makes some sense?
10:37:44 <quicksilver> there are reasons for it, though.
10:37:59 <sw17ch> I'm starting to think RPN haskell would be fun
10:38:06 <birkenfeld> I got GHC to compile a "Monad a => Applicative a" instance, but only with -fundecidable-instances
10:38:09 <lament> sw17ch: noooooo
10:38:16 <quicksilver> birkenfeld: yes, don't do that.
10:38:20 <birkenfeld> quicksilver: good. :D
10:38:23 <BMeph> mattam, chrisdone:  Hm, that makes sense.
10:38:38 <quicksilver> birkenfeld: it prevents you having any Applicatives which aren't Monads.
10:38:59 <birkenfeld> can I understand why or will my head explode? ;)
10:38:59 <mattam> That's the way I remember it :)
10:39:00 <quicksilver> not that, off-hand, I can think of one.
10:39:00 <zachk> finally, managed to pull tags out of html
10:39:16 <quicksilver> birkenfeld: instance Monad a => Applicative a means "All types a are Applicative"
10:39:24 <quicksilver> birkenfeld: "... but add a monad constraint"
10:39:27 <sw17ch> lament: oh, it might be fun. > "Hello World" putStrLn
10:39:39 <quicksilver> birkenfeld: contexts are not taken into account when choosing instances.
10:39:40 <lament> sw17ch: RPN is the Satan
10:39:43 <lament> pretty much
10:39:52 <birkenfeld> quicksilver: ah, okay.
10:39:53 <_zenon_> BMeph, (f o g) t is  f(g(t)) , so i guess It maybe comes from there?
10:39:54 <quicksilver> birkenfeld: as to why that whould be the case, I'm not sure I can explain it concisely.
10:40:05 <sw17ch> well, then my attempt to write the most evil language will definitely implement RPN for everything
10:40:13 <newsham> > let (^) = flip ($) in 2 ^ 3 ^ (+)
10:40:14 <lambdabot>       Overlapping instances for Show (b -> b)
10:40:14 <lambdabot>        arising from a use of `s...
10:40:18 <_zenon_> BMeph, from calculus that is.
10:40:21 <chrisdone> BMeph: I have the same problem myself. sometimes I say them the opposite way round, but people seem to know what I mean regardless
10:40:29 <lament> sw17ch: once you start dupping and rotting, RPN eats your brain
10:40:44 <BMeph> _zenon_: Ah, good observations, I like it. Thank you. :)
10:41:13 <BONUS_> so hmm
10:41:14 <BMeph> chrisdone: Well, that's comforting, not being alone in it. :)
10:41:16 <malouin> Yikes... any obvious cause of error like this in ghci?: Loading package gd-3000.4.0 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
10:41:22 <sw17ch> lament: RPN does work well with a linked list for the stack... i suppose you'd have to try extra hard to figure out waht to do with () results...
10:41:23 <BONUS_> what *should* monad be a subclass of?
10:41:24 <malouin> installed gd from cabal
10:41:39 <BONUS_> i heard a lot of times that it should be a subclass of functor
10:41:48 <BONUS_> how about applicative then?
10:41:52 <chrisdone> malouin: I had that problem.. there is a fix.. ERRR agh let me think
10:42:09 <newsham> > let (^) = flip ($) in 2^ (3^ (+))
10:42:11 <lambdabot>   5
10:42:21 <newsham> hmm, i was hoping using (^) woulda given me right assoc
10:42:45 <newsham> can you do fixity in lambdabot?
10:42:46 <chrisdone> malouin: I'll find out for you
10:42:50 <BMeph> BONUS_: Applicative is short for "Applicative Functor," you know... :)
10:42:51 <malouin> chrisdone: awesome
10:43:03 <chrisdone> malouin: it was basically a change in the .cabal file IIRC
10:43:06 <BONUS_> yeah BMeph, but i was wondering from a practical viewpoint
10:43:17 <malouin> chrisdone: that would make sense.
10:43:30 <BONUS_> so if i wanted to make a simple monad, i'd then have to make it a functor as well as an applicative functor
10:43:45 <BONUS_> even though i may never use pure and <*>
10:43:48 <BONUS_> because of return and `ap`
10:43:56 <newsham> yah, you dont get Applicative for free when you make a Monad
10:44:19 <newsham> you can use `fmap` instead of <$> if you like
10:44:20 <BMeph> BONUS_: In that sense, you are using them, just with dif't names. :)
10:44:29 <BONUS_> yeah
10:44:36 <newsham> return/fmap/ap instead of applicative
10:46:05 <chrisdone> malouin: okay, you can remove the pthread entry from the .cabal file, recompile and install, restart ghci
10:46:32 <malouin> chrisdone: ok, trying.
10:49:50 <malouin> how do I uninstall a cabal package?
10:50:29 <pdarnows> n00bish question, what's the difference between $ and .?
10:50:43 <paczesiowa> :t ($)
10:50:44 <lambdabot> forall a b. (a -> b) -> a -> b
10:50:45 <paczesiowa> :t (.)
10:50:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:50:46 <chrisdone> malouin: there is no such function
10:51:25 <dcoutts_> malouin: using ghc-pkg unregister for the pkg registration and rm for the files
10:51:41 <Cale> pdarnows: f $ x  applies the function f to the value x, while f . g composes the two functions f and g producing a new function.
10:51:44 <malouin> dcoutts_: ok, that's what I thought.  What is the pkg-id ghc-pkg is looking for?
10:51:49 <ziman> ($) is apply (a function to an argument), (.) is compose (two functions)
10:52:02 <dcoutts_> malouin: the name and optionally version of the package
10:52:11 <malouin> huh...
10:52:15 <BONUS_> the thing about $ is that it has a really low precedence
10:52:16 <dcoutts_> malouin: if it's a per-user registered package then you need --user too
10:52:25 <BONUS_> so you can think about it as sort of extending parentheses all the way to the right
10:52:27 <malouin> ah, that might be the problem.
10:52:29 <dcoutts_> malouin: see ghc-pkg list, there's the --global section and the --user section
10:52:37 <malouin> dcoutts_: ok, got it.
10:52:45 <malouin> dcoutts_: that worked, thanks.
10:52:49 <pdarnows> bonus_: yeah, I'm at a point where I routinely use $ to make my code look nicer by ditching parens...
10:52:59 <chrisdone> the thing about `.' is it has the same precedence of `foo`
10:53:34 <chrisdone> > id . id `id` 1
10:53:35 <lambdabot>       precedence parsing error
10:53:35 <lambdabot>          cannot mix `(.)' [infixr 9] and `id' ...
10:53:47 <Cale> pdarnows: okay, so, whenever you presently have:   f $ g $ h $ x, you could write:  f . g . h $ x  which is probably why you're confused about the difference :)
10:53:53 <chrisdone> lambdabot needs some unwords . words
10:54:10 <pdarnows> cale: yeah, it seems pretty arbitrary sometimes, though I know it must just be me misunderstanding
10:54:16 <pdarnows> because computers aren't arbitrary, right?
10:54:18 <pdarnows> right?
10:54:20 <pdarnows> please?
10:54:28 <Cale> pdarnows: However, the first relies on the fact that $ is (unfortunately) defined to be right associative, as opposed to left associative like function application usually is.
10:54:45 <zachk> mmmm textmode pseudobrowser in haskell hooray for me
10:54:50 <Valodim> @src lines
10:54:51 <lambdabot> Source not found. Just try something else.
10:54:52 <Cale> So: f $ g $ h $ x means:  f $ (g $ (h $ x))
10:54:56 <BONUS_> pdarnows: read this i think it might explain things http://learnyouahaskell.com/higher-order-functions/#function-application
10:54:59 <Beelsebob> Cale: it's not unfortunate at all
10:54:59 <lambdabot> Title: Learn You a Haskell for Great Good! - Higher Order Functions, http://tinyurl.com/6bazzz
10:55:03 <Beelsebob> it's very very deliberate
10:55:04 <Cale> Beelsebob: It really is.
10:55:09 <Beelsebob> we have left associative application
10:55:09 <malouin> chrisdone: success! thanks a bunch!
10:55:15 <chrisdone> malouin: yaaay :)
10:55:16 <Beelsebob> it's spelled "space"
10:55:26 <zachk> wannabe lynx in 70 lines of codes
10:55:30 <Cale> Beelsebob: The important thing about $ is its precedence.
10:55:55 <Beelsebob> Cale: and it's associativity
10:55:59 <chrisdone> zachk: paste codez!?‽
10:56:05 <Cale> Presently, any chain of $'s can be rewritten using composition, and a single $
10:56:07 <Beelsebob> I agree it would be nice to have a low precidence left-associative one though
10:56:27 <Cale> However, there are things which could be written with a left-associative $ which we can't currently write without parens.
10:56:42 <BONUS_> Cale: for example?
10:56:43 <Cale> For example, f (g x) (h y) (k z)
10:56:50 <BONUS_> ah
10:56:59 <Cale> Would be:  f $ g x $ h y $ k z  if $ were left associative.
10:57:03 <chrisdone> yeah, I've considered that a few times
10:57:07 <chrisdone> that would be lovely
10:57:13 <Beelsebob> not really
10:57:25 <osfameron> $ is so noisy!
10:57:26 <Beelsebob> but I can see why you might want it
10:57:38 <BONUS_> i routinely overuse function composition :(
10:57:42 <Cale> This is really make obvious by trying to use $! to strictify on any but the last argument.
10:57:49 <Cale> made*
10:58:01 <BONUS_> this is me all the time: blah . blah . blaah . blaaah blah . blaaah blaah $ x
10:58:05 <Cale> You have to parenthesize things awkwardly.
10:58:14 <Cale> BONUS_: That's how I write things too.
10:58:31 <Cale> (and I recommend that style)
10:58:42 <BONUS_> i'd recommend let bindings to give stuff sensible names
10:58:45 <BONUS_> and make it more readable
10:58:50 <BONUS_> but i dont care cause that's just how i roll
10:58:53 <chrisdone> yes, me too. pretty much because most of my code is composition and on those occasions where I need formal parameters, I have to use $
10:58:59 <newsham> pointless names
10:59:15 <Cale> pdarnows: Note that if you write  f . g . h $ x rather than f $ g $ h $ x, there is a really nice advantage: g . h is a well-typed expression, whereas g $ h is not.
10:59:15 <sw17ch> @pl f x y z = x ( y ( z ) )
10:59:16 <lambdabot> f = (.)
10:59:19 <sw17ch> oh dang
10:59:30 <sw17ch> haha
10:59:39 <BONUS_> yeah im a composition junky and a lot of times i do $ xs because of the MR
10:59:46 <sw17ch> @pl f x y z = z $ y  $ x
10:59:47 <lambdabot> f = (flip id .) . flip id
10:59:50 <Cale> Yeah, I just switch the MR off ;)
11:00:06 <jpcooper> what is MR?
11:00:10 <trofi> what is MR ?
11:00:12 <BONUS_> monomorphism restriction
11:00:24 <pdarnows> cale: "well-typed" meaning that there's a defined type?
11:00:27 <BONUS_> its eh .. sometimes haskell whines at you when you make point free fucntions
11:00:35 <zachk> chrisdone:
11:00:36 <Cale> pdarnows: yeah.
11:00:38 <BONUS_> turning off the MR shuts it up
11:00:45 <zachk> chrisdone: http://hpaste.org/10405 there is the code for you
11:00:49 <Cale> pdarnows: Well, basically, that it's meaningful at all.
11:01:10 <pdarnows> cale: yeah, I guess something in Haskell either has a type or...uh, is not proper Haskell
11:01:19 <Cale> pdarnows: So f . g . h $ x essentially has "more subexpressions" than f $ g $ h $ x, because . is an associative operator.
11:01:20 <zachk> the bulk of it was from google, splitCore was were i did most of my work
11:01:22 <BONUS_> length . filter (==3) $ [1,2,3,3,4] ... length . filter has a meaning
11:01:25 <BONUS_> its a function in its own right
11:01:26 <BONUS_> i mean
11:01:28 <BONUS_> length . filter (==3)
11:01:38 <BONUS_> whereas length $ filter (==3) doesnt have much meaning on its own
11:01:42 <Cale> That is, you can count on the property that f . (g . h) = (f . g) . h
11:01:46 <chrisdone> zachk: bluntly, I will say that your code layout and indentation is awful, imho
11:01:59 <chrisdone> zachk: now that I've said that, I'll read the code itself
11:02:03 <zachk> the layout rules confuse me
11:02:25 <Cale> So it doesn't matter how you parenthesise compositions. How you parenthesise $'s though matters a great deal to the meaning.
11:02:58 <chrisdone> zachk: generally, the rule is space out operators and parameters, "a = b" instead of "a=b", and try to keep it on the left hand side
11:03:07 <pdarnows> cale: what's an associative operator?
11:03:14 <malouin> chrisdone: here's a present for you: http://hpaste.org/10406
11:03:18 <pdarnows> ohhh, wait, you mean associative in the mathematical sense
11:03:21 <malouin> chrisdone: it generates a png file called out.png
11:03:22 <Cale> pdarnows: An operator * for which f * (g * h) = (f * g) * h
11:03:29 <Cale> yes
11:03:33 * chrisdone runs it willy nilly
11:03:39 <zachk> chrisdone: keep what on the left hand side?
11:03:49 <malouin> chrisdone: it's not terribly hard to figure out what it does :)
11:03:51 <sw17ch> does any one else think that Graphviz is one of the best tools EVAR?
11:04:00 <sw17ch> sorry... i get a little excited
11:04:00 <pdarnows> I've just started to study a little abstract algebra, and it's helping me get Haskell much more easily, and vice versa
11:04:14 <Cale> :)
11:04:16 <chrisdone> zachk: the code in general, so that reading it is like one straight column
11:05:20 <zachk> i could have been doing my java homework but this was more fun
11:05:35 <pdarnows> zachk: I'm supposed to be doing my day job in Ruby right now
11:05:43 <chrisdone> malouin: mandelbrot❤♥
11:06:18 <Cale> pdarnows: Have you been introduced to the idea of a category?
11:06:20 <chrisdone> pdarnows: ruby programmers are all turning to haskell
11:06:28 <malouin> :)
11:06:54 <zachk> i ran into a virus last night on my buddies winxp laptop. it even redirected lynx to an HTTPS and tried sending it an xml application, so that inspired me to get my own code working that fiddles with html
11:06:58 <chrisdone> zachk: what's REG?
11:07:23 <BONUS_> is there an experienced haskeller who like language X more than haskell?
11:07:23 <chrisdone> zachk: regex?
11:07:26 <BONUS_> is there such a thing
11:07:27 <zachk> some non greedy basic regex library, sec ill get the weblink
11:07:37 <zachk> regex is just the regular expression from the command line
11:07:51 <Cale> BONUS_: I think so, where X is sufficiently obscure.
11:07:51 <pdarnows> cale: no, I think I'm still a long way off, I'm still learning the basics of rings
11:07:54 <chrisdone> BONUS_: me and Twey have a successful hobby of converting ruby programmers to haskell
11:08:01 <BONUS_> haha
11:08:05 <Cale> pdarnows: Well, a category is not that much harder than a ring :)
11:08:13 <zachk> http://blog.thoughtfolder.com/2008-02-04-even-more-beautiful-code-c-haskell-.html and i use some code from roll your own irc bot
11:08:19 <zachk> s/use/used
11:08:21 <lambdabot> Title: Even more Beautiful Code (C → Haskell) — Thoughtfolder, http://tinyurl.com/5r96zg
11:08:25 <Cale> pdarnows: But usually they're studied later, since groups, rings, vector spaces, are all examples of categories.
11:08:49 <zachk> im on windows and cabal wouldnt install pcre-regex which gives you perl 5 non greedy regexes
11:09:06 <chrisdone> ahh
11:09:10 <pdarnows> cale: understood.  but right now I've put abstract algebra on the backburner so I can spend more time on calculus...
11:09:33 <pdarnows> cale: since my main motivation is not embarrassing myself on the math subject test GREs, and it's been a long long time since I took calc
11:09:34 <dcoutts_> zachk: presumably because your system lacks libpcre and headers
11:09:45 <Cale> pdarnows: Want a book recommendation?
11:09:48 * sw17ch likes the subset of calculus which does not include trig
11:09:49 <pdarnows> cale: you bet
11:10:09 <Cale> pdarnows: Michael Spivak "Calculus" (not the same as "Calculus on Manifolds", though that's also decent)
11:10:28 * pdarnows makes a note of it
11:10:31 <pdarnows> cale: cool, thanks
11:10:49 <chrisdone> Cale: I have that book. I read the first chapter but I'm not educated well enough for the rest.   .. one day!
11:10:52 <Cale> It's far and away one of the best introductions to Calculus, or even mathematics in general that I know of.
11:11:20 <Cale> chrisdone: It can be heavy going. Don't be too put off if you can't do all the exercises right away.
11:11:25 <zachk> latter
11:12:10 <Cale> chrisdone: (many of them are intended to be thought about and set aside for later :)
11:12:12 <pdarnows> cale: I am actually about refreshed on all the calc I learned in the past, but now I have about a month to teach myself a semester's worth of new material
11:13:41 <Cale> The thing that I love about Spivak's book is that it doesn't get too caught up trying to show you how Calculus is useful (though it does include at least one major application, a chapter devoted to Kepler's laws of planetary motion), instead it tries to show how these ideas can be interesting in their own right, which I think is the right approach to take with mathematics :)
11:14:07 <pdarnows> cale: assuming that I can only find "Calculus on Manifolds", do you think that one would be  helpful?
11:14:22 <Cale> Uh, well, it's not terribly introductory.
11:14:29 <sw17ch> Cale: i agree... somehow i think taht math in highschool and college would have been easier if they ignored the parents who wanted to know "why my kid needs algebra/calculus/trig/geometry"
11:14:35 <Cale> It's a good intro to differential geometry though.
11:14:44 <Baughn> Cale: Are there major differences between the various editions?
11:15:02 <Cale> Baughn: Of "Calculus"? I only have the 3rd edition, so I'm not so sure.
11:15:24 <Cale> They seem separated enough in time for some large changes to have been made.
11:15:53 <Cale> I think there are some new chapters in the newer editions.
11:16:25 <Cale> Spivak isn't one to just permute the exercises and release a new edition. :)
11:16:46 <chrisdone> I have the third edition
11:17:15 <Baughn> Cale: Actually, my library has no copies. Given that I've already got one book on calculus, and am trying to learn more about it, is it worth ordering?
11:17:35 <mancalledhash> Haskell is a great language but is there any way besides HSLUA to combine Haskell and LUA?  It seem the versions .1 and .2 of this package does not have any examples or decent documentation.
11:17:46 <Cale> Well, it's my favourite textbook from undergrad at least, and rather different from most textbooks on Calculus. :)
11:18:05 <Cale> The only Calculus text I can imagine as remotely comparable to it is Apostol's.
11:18:35 <chrisdone> that's what they said in #math which is why I got it
11:19:19 <Cale> mancalledhash: HsLua has documentation, but it mostly seems to be references to the Lua reference manual :)
11:19:39 <Cale> chrisdone: If you'd ever like help with understanding parts of it, you can ask me :)
11:20:14 <Cale> The exercises can be really hard. I remember spending upwards of 14 hours on single problems in 1st year. :)
11:20:16 <mancalledhash> Cale: reference to LUA.  It is not getting me no where :(
11:20:20 <Baughn> Cale: Got it. Maybe this one will actually let me /understand/ calculus.
11:20:43 <Baughn> I've gotten some sort of mental block in that field after the trauma of the (updated yearly) "textbook" we used here
11:20:50 <pdarnows> cale: where did you go to school?
11:20:58 <Cale> pdarnows: University of Waterloo
11:21:15 <Cale> (In Canada :)
11:21:29 <pdarnows> I've heard good things about it
11:22:11 * sw17ch went to a small liberal arts college in Michigan... wishes people had heard of it
11:22:50 <pdarnows> I took some pretty poor calc classes in the 90s whilst doing my BA, then some surprisingly good ones at City College of San Francisco in the past few years...but I couldn't keep up with the courseload and a fulltime job
11:23:03 <pdarnows> in retrospect, I wish I'd dropped something _other_ than calc.
11:23:48 <lament> i took calculus four times
11:24:15 <lament> now i actually remember the definition of the derivative!
11:24:21 <Cale> ehehe
11:24:45 <Baughn> Oh, the definition is simple. But solving.. *gibber*
11:25:07 <Baughn> I'll remember that binomial integration assignment the rest of my life
11:25:18 <lament> (this happened by moving from one country to another with progressively lower-quality math curricula: Ukraine, Israel, Canada, and finally Canadian university)
11:25:21 <Cale> I really like the generalisation of the derivative to functions R^m -> R^n
11:25:36 <pdarnows> lament: at least you didn't try learning math in the U.S. :)
11:25:39 * sw17ch cherishes his TI-89 and it's symbolic integration/derivation abilities
11:25:44 <lament> pdarnows: i'm sure Canada's no different
11:25:48 <Cale> I think that generalisation forces you to write the derivative in a way which cuts more to the heart of its meaning.
11:25:57 <lament> i'm lucky (?) to have had calculus in high school in Canada at all
11:26:05 <lament> Cale: is that the thing Rudin ends with?
11:26:27 <Cale> Highschool mathematics in Canada is "not so good", but I'm pretty sure you don't want to get me started ;)
11:26:37 <Cale> lament: I'm not sure :)
11:26:46 <Baughn> chrisdone: Oh, and your email seems not to have made it to the cafe
11:26:50 <lament> generalization of... green's theorem, i think
11:27:05 <lament> oh, that's integrals
11:27:10 <chrisdone> Baughn: yes it seems I got a response saying I'm not allowed. I guess I have to register
11:27:19 <lament> right, it was the generalization of green's theorem to any domain
11:27:28 <lament> integrals over surface and area
11:27:41 <Cale> ah
11:27:48 <lament> which feels quite related
11:27:50 <Cale> That stuff is nice as well. :)
11:28:15 <sw17ch> i really enjoyed 3d integrals and gradients... gradients were my favorite
11:28:59 * ddarius prefers the geometric calculus definitions far above any others he's seen.
11:29:18 <_zenon_> @seen danten
11:29:18 <lambdabot> danten is in #ghc, #haskell.se, #haskell and #xmonad. I last heard danten speak 4m 39s ago.
11:29:20 <jpcooper> sw17ch, I once tried to mod my TI-82 by adding a different transistor to make it faster. I broke it :(
11:29:35 <sw17ch> jpcooper, taht's really sad :(
11:29:44 <jpcooper> yeah, I saved up for ages
11:29:49 <sw17ch> i don't dare pop the case on my 89... that thing cost me $130
11:29:55 <sw17ch> back when the dollar was worth soemthing :)
11:30:04 <jpcooper> what's that, like two quid?
11:30:20 <lament> $20 canadian
11:30:25 <jpcooper> haha
11:30:28 <sw17ch> :(
11:30:33 <lament> or a cup of gasoline
11:30:35 <sw17ch> i wish my job paid in euros
11:30:48 * ddarius personally prefers seeing how math is useful in applications; interest in it itself will follow (or if it doesn't, so what?)
11:31:02 <jpcooper> aah
11:31:07 <jpcooper> I can't stand the practical part of CS
11:31:09 <lament> ddarius: I agree, especially for things where practical applications are so profound and motivating
11:31:14 * pdarnows is considering a job paying in UK pounds
11:31:17 * Baughn wonders how much haskell (and other languages, and tools..) is like intelligence amplification
11:31:28 <lament> Baughn: it makes me feel dumber :)
11:31:29 <jpcooper> I failed the human-computer-interaction module
11:31:37 <jpcooper> well, got a D
11:31:47 <Baughn> How much faster do programmers work today than twenty years ago, just due to improved tools? How much more is that than the amplification in other fields?
11:32:20 <pdarnows> baughn: if you read "The Mythical Man-Month," they talk about how, with good organization and (1960s-1970s) tools, you could get three or four "shots" a day
11:32:49 <lament> i don't think the programming language is a bottleneck when writing software in a team.
11:33:03 <lament> it wasn't 30 years ago and it isn't now
11:33:05 <pdarnows> baughn: I'm thinking a shot is roughly like a test run, or running a test suite...
11:33:19 <Cale> ddarius: Hehe, I'm actually exactly the opposite. My thinking is that applications will follow, and the primary interest is the structure itself :)
11:33:53 <sw17ch> Cale: i'd agree. you learn the pattern of the artform, and then you'll notice patterns which it could solve well
11:33:58 <Cale> It's nice that mathematics can be applied to the "real world" as such, but it's not something which motivates me, really.
11:34:12 <lament> Cale: calculus is amazing because it deeply connects a bunch of unrelated stuff. When you don't know what the unrelated stuff is, it's not as impressive!
11:34:31 <jpcooper> Cale, did you study CS atall?
11:34:34 <jpcooper> at all*
11:34:40 <Cale> jpcooper: Only in 1st and 2nd year.
11:34:46 <mapreduce> lament: The programming language can, especially in a team, impose an 'abstraction ceiling'.
11:34:48 <Cale> jpcooper: Enough to have written a small compiler.
11:35:03 <Cale> jpcooper: Oh, and then on my own, quite a bit :)
11:35:33 <newsham> is there a good paper/tutorial/blog on left fold enumerators thats easy to read and has examples?
11:35:40 <jpcooper> I've become disappointed with my curriculum
11:35:40 <Cale> But CS courses cost more than mathematics courses, and as a pure mathematics major, you needed a special exemption to take those beyond what you were required to do.
11:35:46 <jpcooper> there's going to be a lot of business cruft
11:36:02 <jpcooper> Cale, in Scotland, they cost the same
11:36:31 <ddarius> Cale: Many of the people who developed these fields had clear applications in mind (though not always)
11:36:45 <Cale> jpcooper: This was just a peculiarity of my university.
11:37:00 <Cale> Well, I think of Calculus as a lovely way to study how functions can misbehave.
11:37:15 <newsham> functions gone wild
11:37:26 <Cale> Which is perhaps a little perverse, given the usual perspective on it. :)
11:37:57 <ddarius> Cale: That makes sense to me, though I may not be interpreting it the way you intend.
11:38:39 <sw17ch> I wonder if Haskell is used with the LHC at all...
11:38:53 <ddarius> Probably not
11:38:54 <Cale> Well, once you've defined differentiability, say, you can ask questions like whether a function can fail to be differentiable at every point, and things like that.
11:39:22 <pdarnows> sw17ch: LHC?
11:39:30 <sw17ch> Large Hadron Collider
11:39:30 <ddarius> To specify what "nice" functions are you have to know in what ways they can fail to be "nice"
11:39:32 <sw17ch> sorry
11:40:16 <pdarnows> sw17ch: only when they're looking at lambda particles
11:40:18 * pdarnows ducks, runs
11:40:36 <mancalledhash> Cale: you ever used HSLua?
11:40:41 <Cale> mancalledhash: no.
11:41:21 <mancalledhash> awww man, and you know everything lol
11:41:26 <Cale> mancalledhash: However, I might still be able to help :)
11:41:34 <Cale> mancalledhash: What are you trying to figure out? :)
11:42:03 <skorpan> Loading package terminfo-0.2.1 ... can't load .so/.DLL for: curses (/usr/lib/libcurses.so: file too short)
11:42:04 <skorpan> dammit
11:43:45 * sw17ch is really excited about Language.C
11:44:06 <sw17ch> ...just in case every one wasn't aware yet
11:45:52 * sw17ch considers chasing down pdarnows for his awful pun...
11:46:23 <Cale> One thing that I found really surprising is that there's a function R -> R which is differentiable everywhere, but the sets on which its derivative is positive, negative, and zero are all dense in R.
11:47:10 <olsner> I don't even know what that means
11:47:40 <sw17ch> Cale: could you define dense in R?
11:48:13 <scodil> does the c preprocessor in ghc do token concatentation with ## ?
11:48:15 <Cale> Between any two (distinct) points of the set, there is another.
11:48:41 <ziman> wow
11:48:43 <sw17ch> scodil: i *think* the preprocessor is gcc's c preprocessor
11:48:49 <ddarius> Cale: What's a description of the function?
11:49:02 <ziman> Cale, do you have an example or you just know there is one?
11:49:06 <Cale> I'd have to look it up... it was in a paper.
11:49:06 <scodil> sw17ch: I get a parse error on input `##'
11:49:13 <Cale> I don't think it was a constructive proof.
11:49:22 <sw17ch> scodil, i still needs to be lexed by GHC
11:49:25 <ddarius> Yeah, that's what I was afraid of.
11:49:27 <sw17ch> it*
11:49:33 <scodil> sw17ch: this is ghc giving me the parse error
11:49:47 <sw17ch> scodil, i'm probably wrong then :)
11:49:50 <scodil> i can't see what its being expanded to cause I can't use cpp from the command line
11:49:59 <sw17ch> scodil, can't?
11:50:00 <sw17ch> why not?
11:50:06 <scodil> is there a ghc flag to show pre-processed output?
11:50:12 <scodil> regular cpp can't parse it
11:50:22 <sw17ch> scodil, oh, right
11:50:34 <sw17ch> scodil, ghc -E
11:50:36 <scodil> thanks
11:51:19 <jpcooper> @hoogle lookup
11:51:19 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
11:51:19 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
11:51:19 <lambdabot> Data.IntMap lookup :: Monad m => Key -> IntMap a -> m a
11:51:28 <scodil> how lame! ghc doesn't do token pasting
11:51:51 <sw17ch> scodil, token parsing and the CPP concatenation/stringification stuff is a little bit esoteric, isn't it?
11:52:04 <scodil> yes, and also awesome
11:52:10 <sw17ch> scodil, i have to agree with you there :)
11:52:19 <sw17ch> (except that i'm writing a preprocessor right now, and those parts suck)
11:58:30 <Cale> http://cale.yi.org/autoshare/NowhereMonotone.pdf
11:58:32 <lambdabot> Title: cache:http://cale.yi.org/autoshare/NowhereMonotone.pdf - Google Search
11:59:24 <Cale> I think that it's possible someone has actually constructed one (given some vague comments that turned up in my Google searching), but it's easier to use the Baire Category theorem to show they exist.
11:59:35 <MyCatVerbs> Cale: server a not flaky? Failed to load first time I tried to hit it.
11:59:55 <MyCatVerbs> Wut. s/a not/a bit/, dammit.
12:00:02 <Cale> oh
12:00:10 <Cale> Did it eventually work?
12:00:25 <MyCatVerbs> Tried it again, yes.
12:00:29 <Cale> okay.
12:00:32 <Cale> I have no idea :)
12:00:43 <MyCatVerbs> I think. Either that or I just hit reload on the google cache page twice in a row by mistake.
12:00:44 <Cale> I'm doing some uploading, so it's possible that it's a tad slow.
12:00:51 <MyCatVerbs> Ah, I see.
12:02:37 <BMeph> Cale: Whoa, that's wild - I'm looking at the "Baire space" entry on Wikipedia now. o.O
12:06:02 <Cale> Yeah, actually, that paper proves a bit less than I claimed.
12:06:32 <Cale> (because it doesn't ensure the condition regarding the sets on which the derivative is positive and negative)
12:06:50 <Cale> But you can get that simultaneously, I recall it being a bit more involved though.
12:11:27 <Cale> Another really nice class of functions R -> R are those which are everywhere dense, in that the image of any open set is a set which is dense in R :)
12:12:29 <Cale> I'm pretty sure those won't exist without the axiom of choice though :)
12:13:34 <Cale> Nice to imagine there are functions where if you try to draw their graph, the best you can do is chalk in the whole blackboard :)
12:19:23 <sheyll> I cannot get my flipflop under control, what is the problem? http://hpaste.org/10407
12:21:41 * FunctorSalad has a class: "class (Show a) => TheClass a" and a GADT "data D = forall a. (TheClass a) -> D".
12:21:55 <FordCortina> i think ive managed to build Yi. but there's no executable. there was no error though. :( i dont get it
12:22:37 * FunctorSalad forgot the name of the constructor: "data D = MkD :: forall a. (TheClass a) -> D"
12:22:57 <FunctorSalad> now anyway, /me doesn't understand why he can't pattern match (MkD x) and then show the x.
12:23:13 <FunctorSalad> since every TheClass is also a Show
12:23:37 <dolio> You mean data D = forall a. TheClass a => MkD a?
12:24:08 <thomasha`> Can someone point me to how to take a string, and make a hash out of it suitable for storing passwords? I thought, md5, and I just tried installing crypto on ghc 6.8.3 and got a panic. There's gotta be code in the public domain for this... or another library... ?
12:24:09 <dolio> Or data D where MkD :: TheClass a => a -> D?
12:24:11 <FunctorSalad> dolio: sorry, I got it wrong yet again ;-) "data D where MkD :: forall a. TheClass a -> D"
12:24:25 <FunctorSalad> yes, your last one
12:24:31 <dolio> :)
12:24:34 <gladpack2> is there a way to run a haskell core interpreter and play around with lmabda calculus basics? or anyone know of a lambda calc interpreter?
12:24:36 <thomasha`> Or is the easiest thing to update to ghc head and try installing crypto again?
12:24:55 <FunctorSalad> dolio: pictue the "I can't haskell today" cat ;-)
12:25:11 <dolio> You should be able to show the x. I don't know why it wouldn't work.
12:25:33 <FunctorSalad> dolio: that example was simplified so it may be sth else. the error is "ambiguous" something
12:25:54 <FunctorSalad> dolio: and I can't add annotations to the pattern matching function because I can't get hold of the a there
12:26:03 <gladpack2> quote myoma
12:26:09 <gladpack2> @quote myoma
12:26:09 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
12:26:34 <sw17ch> @quote Myoma
12:26:34 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
12:26:45 <sw17ch> @quote lambdabot
12:26:45 <lambdabot> lambdabot says: I know nothing about comprehending.
12:27:05 <ziman> @quote
12:27:07 <lambdabot> #perl says: <tech> who needs saneness
12:27:23 <lispy> ?quote perl
12:27:23 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
12:27:45 * FunctorSalad just hit the keyboard accidentally and got a "you need to be a channel op to do that" msg :) (was no attack attempt)
12:28:00 <dino-> thomasha`: Recently we were trying to build and install crypto too. I was not successful.
12:28:12 <thomasha`> dino: maybe this: darcs get http://code.haskell.org/~tommd/pureMD5
12:28:12 <dino-> Sorry about the unhelpful "me too" comment. :/
12:28:13 <lambdabot> Title: Index of /~tommd/pureMD5
12:28:19 <dolio> FunctorSalad: Your above example works for me. :)
12:28:25 <dolio> You need to make a more complex one. :)
12:28:31 <dino-> I actually need it to do symmetric encryption.
12:28:39 <FunctorSalad> dolio: I could hpaste the actual one...
12:28:46 <thomasha`> for md5 at least. I am trying to create a "batteries include" happs application though, so it should really all come from hackage.
12:28:52 <dino-> So atm calling out to /usr/bin/gpg, sadly.
12:28:56 <thomasha`> I guess I'll leave in a rot13 placeholder for now.
12:29:08 <thomasha`> dino: can you hpaste?
12:29:28 <dino-> thomasha`: sure
12:30:13 <thomasha`> dino: are you doing a password salt too?
12:30:40 <dino-> thomasha`: no
12:30:45 <dino-> Well, I don't think so
12:30:46 <thomasha`> ah, then it won't help me.
12:31:05 <thomasha`> I meant, I was using md5 to store passwords.
12:32:25 <gladpack2> is there a way to run a haskell core interpreter and play around with lmabda calculus basics? or anyone know of a lambda calc interpreter?
12:32:43 <Myoma> gladpack2: I have written one
12:32:45 <lament> there're javascript lambda calculus interpreters online, google
12:33:01 <Myoma> gladpack2: I didn't do the syntax yet though
12:33:13 <dino-> thomasha`: ok. Sorry
12:33:33 <thomasha`> dino: thanks anyways
12:33:43 <Myoma> gladpack2: Scheme is a pretty good substitute if you don't want to wait
12:34:09 <bbs> hey guys
12:34:10 <bbs> question
12:34:46 <bbs> http://rafb.net/p/OpB9xX65.html
12:34:46 <lambdabot> Title: Nopaste - No description
12:35:06 <bbs> i want returnbabies to take 5 and return [4,3,2,1]
12:35:08 <FunctorSalad> dolio: omg. I tried to make a minimal compileable example and that compiles fine too
12:35:13 <ddarius> sheyll: What is your code doing?
12:35:14 <bbs> lambdabot: ?
12:35:15 <lambdabot> Maybe you meant: . ? @ activity activity-full admin all-dicts arr ask b52s babel bf bid botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add
12:35:15 <lambdabot> djinn-clr djinn-del djinn-env djinn-names djinn-ver docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune
12:35:15 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma karma+
12:35:15 <lambdabot> karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on nixon oeis offline oldwiki
12:35:18 <lambdabot> palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc read
12:35:21 <lambdabot> [3 @more lines]
12:35:23 <dolio> Heh.
12:35:26 <bbs> WTF
12:35:41 <bbs> stupid bot
12:35:55 <trofi> ]
12:36:03 <dolio> FunctorSalad: What exactly is the error you're getting?
12:36:53 <_zenon_> bbs, reverse [1..(n-1)]
12:37:24 <thomasha`> is there a way to unregister a package using the cabal command? I tried ghc-pkg unregister puremd5    but it didn't remove the package, I think because it was installed under .cabal using cabal install
12:37:29 <bbs> _zenon_: ah!
12:37:50 <dcoutts_> thomasha`: no, at the moment you just have to use ghc-pkg unregister and rm for the files
12:38:02 <ddarius> > [(n-1), (n-2), .. 1]
12:38:03 <lambdabot>   mueval: Prelude.read: no parse
12:38:06 <FunctorSalad> dolio: Ambiguous type variable `a' in the constraint:
12:38:06 <FunctorSalad>       `HasFresh a'
12:38:06 <FunctorSalad>         arising from a use of `freshes' at (...)
12:38:06 <FunctorSalad>     Probable fix: add a type signature that fixes these type variable(s)
12:38:12 <_zenon_> bbs, np
12:38:17 <ddarius> > [n-1, n-2 .. 1]
12:38:18 <lambdabot>   mueval: Prelude.read: no parse
12:38:18 <lambdabot>  mueval: *** Exception: not a number
12:38:19 <FunctorSalad> dolio: where "HasFresh" is analogous to "TheClass"
12:38:23 <dolio> thomasha`: You might need to add a --user flag to ghc-pkg.
12:38:31 <ddarius> > let n = 5 in [n-1, n-2 .. 1]
12:38:32 <lambdabot>   [4,3,2,1]
12:38:35 <dolio> Since cabal-install installs things as user by default.
12:39:57 <dolio> FunctorSalad: Well, that sounds like freshes can return one of several types belonging to the HasFresh class, but one particular one needs to be chosen to pack into the existential type.
12:40:22 <dolio> And the compiler can't pick it for you, unless you declare a default or something.
12:40:51 <thomasha`> dolio: thanks, you're right
12:41:22 <FunctorSalad> dolio: the decl is "class (Show a) => HasFresh a where { fresh :: State Int a }"
12:41:46 <FunctorSalad> dolio: but like I said, in my minimal example I can do that show :-(
12:41:56 <FunctorSalad> I'll have to look what could be it
12:42:52 <dolio> Well, from the error, it doesn't sound like the show is the problem to me. But I'd have to see more context to be certain.
12:46:10 <FunctorSalad> dolio: okay, I can cause the error in the example by adding all the OPTIONS_GHC from my real module
12:46:54 <dolio> Huh.
12:47:05 <dolio> Pasting?
12:47:24 * bbs forces himself to think recursively
12:47:46 <newsham> think combinatorially
12:47:52 <bbs> lol
12:47:54 <bbs> ok
12:47:59 <dolio> Categorically.
12:48:29 <trofi> productive
12:48:51 <newsham> see you later, combinator
12:49:19 <jpcooper> newsham, I cringed
12:49:27 <FunctorSalad> dolio: so finally, here's an example that doesn't fail at failing :D http://hpaste.org/10408
12:50:56 <dolio> Oh.
12:50:58 <FunctorSalad> the error is at the "(show freshes)" at the end
12:51:00 <olsner> hmm, most of those could be language pragmas
12:51:10 <dolio> NoMonomorphismRestriction is causing the problem.
12:51:33 <olsner> because let's are monomorphic with the MR?
12:51:34 <dolio> Without it, freshes gets defaulted to something.
12:52:02 <FunctorSalad> (don't ask me why I did a "case" there rather than plain pattern match)
12:52:07 <newsham> functor: you indent the whole module?
12:52:11 <dolio> With it, freshes gets left polymorphic, and then you're calling show on something polymorphic, and it needs to pick something.
12:52:34 <dolio> Which is ambiguous.
12:53:05 <FunctorSalad> newsham: isn't that standard practice? :o
12:53:25 <newsham> seems like a waste of margin, when there's only one line not indented
12:53:42 <olsner> yeah, indending the whole file seems wasteful
12:54:23 <newsham> if thre were multiple module's per file i could see a good reasn for it
12:54:25 <FunctorSalad> hmm IIRC the indenter suggested it and I thought it was mandatory
12:54:55 <newsham> you can start the "import" "class" "data" and "instance" lines on the left margin
12:55:54 <FunctorSalad> :)
12:56:18 <FunctorSalad> dolio: to be honest I don't really understand
12:56:32 <FunctorSalad> I guess that's why it's called the *dreaded* MR ;-)
12:57:09 <dolio> Actually, the problem isn't with the MR. It's just not encountered in this case when the MR is enabled.
12:57:25 <dolio> It's like trying to do 'show . read'.
12:57:33 <newsham> is there a reason you have a show restriction on the whole class?
12:58:10 <dolio> There has to be some intermediate value, but there's no way for the type checker to decide what concrete type it is.
12:59:05 <FunctorSalad> okay I think I vaguely get it now, thanks :)
12:59:13 <dolio> You're trying to do 'show freshes', where freshes can be any type in HasFresh.
12:59:38 <dolio> The MR picks one, since with it on, freshes isn't allowed to be polymorphic.
12:59:42 <FunctorSalad> yeah but "any type in HasFresh" is a subset of "any type in Show"
12:59:55 <dolio> But with it off, there's no mechanism for choosing an arbitrary HasFresh.
13:00:16 <FunctorSalad> I guess I'm thinking in terms of OO-like late binding
13:01:16 <FunctorSalad> newsham: not sure yet whether it needs it
13:01:22 <gladpack2> http://wiki.tcl.tk/16695
13:01:27 <gladpack2> which language is that?
13:01:35 <FunctorSalad> newsham: Show is just convenient for interactive testing
13:01:47 <newsham> right but you can put show restrictions on the things that need them
13:01:52 <newsham> and leave it off the class
13:02:05 <FunctorSalad> hmm yeah, that's more verbose though
13:02:14 <Dybber>  JRe
13:02:15 <vegai> gladpack2: tcl/tk?
13:02:46 <bbs> pair::[a] -> (a,a)
13:02:46 <bbs> pair ps = [(x,y)|[_,_,x,y] <- ps]
13:02:55 <bbs> i want that to return the third and fourth element of a list
13:03:21 * bbs messedup
13:03:26 <bbs> messedup.hs
13:03:30 <seliopou> bbs: pair as you've written it has type [[a]] -> (a, a)
13:04:08 <bbs> seliopou: ok so where am i going wrong is that the right idea even?
13:04:13 <seliopou> pair [_, _, x, y] = (x, y)
13:04:40 <bbs> even if the list is like 100 elements
13:04:55 <seliopou> ah, then match on the rest
13:04:56 <seliopou> so like
13:05:09 <newsham> pair (_:_:x:y:zs) = (x,y)
13:05:19 <seliopou> pair (_:_:x:y:_) = (x, y)
13:05:20 <newsham> > let pair (_:_:x:y:zs) = (x,y) in pair [1..]
13:05:20 <seliopou> yeah
13:05:21 <lambdabot>   (3,4)
13:05:34 <bbs> i mean in any list this should just take the third and fourth element of ANY list and make it a pair
13:05:48 <newsham> > let pair (_:_:x:y:zs) = (x,y) in pair "the quick brown fox"
13:05:49 <lambdabot>   ('e',' ')
13:06:03 <newsham> not "any" list though
13:06:05 <seliopou> bbs: as long as it has at least 4 elements
13:06:07 <newsham> > let pair (_:_:x:y:zs) = (x,y) in pair [1,2]
13:06:08 <lambdabot>   mueval: Prelude.read: no parse
13:06:08 <lambdabot>  mueval: *** Exception: /tmp/894650222055878...
13:06:11 <bbs> haha
13:06:16 <bbs> newsham: well yea :) thanks
13:06:24 <bbs> u guys are mad helpful lol
13:06:36 <bbs> you should have seen my try to learn c
13:06:41 <bbs> _gasp_
13:06:44 <newsham> please credit us in any homework assignments you submit
13:06:57 <pdarnows> a small cash payment would also be nice
13:07:00 <seliopou> make checks payable to haskell.org :P
13:07:00 <bbs> newsham: naturally
13:07:04 <FunctorSalad> newsham: cool, now my top-level function decls are highlighted ;-)
13:07:26 <newsham> is that good?
13:07:26 <pdarnows> functorsalad: which editor?
13:07:40 <FunctorSalad> pdarnows: emacs haskell-mode
13:08:21 <FunctorSalad> with the color-themes extension :D
13:08:33 <FunctorSalad> (for emacs in general)
13:08:39 * bbs hugs vim 
13:08:43 * bbs ducks
13:08:44 <bbs> :)
13:08:50 <FunctorSalad> bbs: but does it have color themes?
13:08:53 <FunctorSalad> ;-)
13:08:58 <bbs> for freedom!
13:09:03 <bbs> idk  -- maybe
13:09:10 <bbs> freebsd hsa a nice default
13:09:23 <bbs> so i just stick with that and put my c extensions on it
13:10:09 <FunctorSalad> yeah but it's fun to switch them so you notice the colors again ;-)
13:11:11 <newsham> like most predators, functor's vision is highly tuned to notice motion, but not color.
13:12:20 <FunctorSalad> I'm human :o
13:12:22 <Botje> ah
13:12:23 <Botje> moving code
13:12:32 <ddarius> Humans are predators
13:12:32 <Botje> now _THAT_ is headache-inducing
13:12:46 <FunctorSalad> actually emacs has that too.
13:12:48 <pdarnows> ddarius: APEX predators, ohhhh yeah
13:12:54 <pdarnows> (get out of here, grizzly bears)
13:13:01 <FunctorSalad> meta-x zone-mode
13:13:11 <bbs> haha
13:13:11 <FunctorSalad> it's quite startling if you forgot you turned it on.
13:13:17 <pdarnows> gotta go to the store, see y'all later
13:13:24 <bbs> pdarnows: see you
13:13:25 <FunctorSalad> (it does weird stuff to the screen if you're idle)
13:13:31 <bbs> lol
13:13:40 <FunctorSalad> :)
13:14:24 <FunctorSalad> err sorry zone-mode is sth else, what I meant is just meta-x zone
13:20:10 <Myoma> what do you call f x == f y -> x = y?
13:20:15 <Myoma> f is injective over ==
13:20:20 <Myoma> or something like that?
13:20:33 <Myoma> f x == f y -> x == y
13:21:28 <newsham> he function f is injective if, for all a and b in A, if f(a) = f(b) then a = b.
13:21:50 <Myoma> ok but what about
13:21:57 <Myoma> f(a) R f(b) -> a R b ?
13:22:31 <ddarius> You might say that it reflects R
13:22:52 <Myoma> ?w80 epimorphic
13:22:57 <lambdabot> *** "epimorphic" wn "WordNet (r) 2.0"
13:22:58 <lambdabot> epimorphic
13:22:58 <lambdabot>      adj : characterized by incomplete metamorphosis; having the same
13:22:58 <lambdabot>            number of body segments in successive stages
13:23:17 <Myoma> ddarius: would  f reflects over ==  make sense?
13:23:29 <Myoma> oh I see
13:23:30 <ddarius> You wouldn't say that it "reflects over"
13:24:15 <dolio> Or f respects ==.
13:24:38 <ddarius> dolio: That's usually for the implication going the other way
13:24:55 <dolio> Hmm, yeah, I guess that's true.
13:25:35 <quicksilver> aren't "preserves" and "reflects" the usual terms
13:25:47 <quicksilver> or sometimes "preserves" and "creates"
13:26:50 <ddarius> quicksilver: In category theory those are the usual terms and there's a difference between a functor creating limits, say, and reflecting them, if I remember correctly.
13:29:52 <FunctorSalad> Myoma: "f factors through the quotient map that enforces the equivalence relation R"? :)
13:30:08 <FunctorSalad> oops, that's the other way
13:31:27 <FunctorSalad> so I'd say that the map between the quotients is injective
13:31:43 <FunctorSalad> (assuming it even exists)
13:35:52 <FunctorSalad> wait, I'll make a diagram
13:40:01 * BMeph waits eagerly, salivating slightly...
13:42:13 <FunctorSalad> Myoma: http://graph.gafol.net/lTLayamR
13:42:17 <FunctorSalad> BMeph: ;-))
13:43:17 <FunctorSalad> f is the original thingy Myoma mentioned and ea1, ea2 enumerates the equivalence on a, similarly for b
13:43:44 <FunctorSalad> sorry for the bad tilde-overscript imitation ;-)
13:45:32 <FunctorSalad> stated pointlessly like that it works in any category with coequalizers =)
13:46:22 <FunctorSalad> in Set or Hask it reduces to the usual definition of "injective" if you take X the singleton
13:47:44 <awarring> this question may sound silly, but how do closures work in haskell? Can't closures carry around state? That seems unpure
13:48:10 <Myoma> awarring: you can't observably mutate a closure in haskell
13:48:23 <awarring> ohhhhh, interesting Myoma
13:48:40 <awarring> what do you mean by "observably"
13:48:41 <Myoma> i.e. <compute 5> might be mutated into <actual real thing 5>
13:49:33 <Myoma> but you can't do (lambda (x) (lambda (y) (set! x y)))
13:50:34 <awarring> interesting
13:50:44 <bd_> (simply because there is no set!)
13:51:16 <wolverian> is there a type class for things that can be flattened/extracted into lists?
13:51:45 <bd_> @hoogle toList
13:51:45 <ddarius> Traversable or Foldable
13:51:45 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
13:51:45 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
13:51:45 <lambdabot> Data.IntMap toList :: IntMap a -> [(Key, a)]
13:51:47 <mattam> wolverian: Traversable
13:52:05 <geezusfreeek> traversable is different
13:52:07 <bd_> Data.Foldable surely?
13:52:21 <bd_> although, hmmm
13:52:34 <bd_> maybe it's possible to write toList with mapM
13:53:27 <bd_> :t \v -> reverse $ execStateT (mapM (modify . (:)) v) []
13:53:28 <lambdabot> forall a. [a] -> [[a]]
13:53:51 <wolverian> thanks, toList looks appropriate :)
13:54:44 <bd_> hmm
13:54:47 <geezusfreeek> bd_: probably, but Traversable must be Foldable anyway
13:54:50 <bd_> > (\v -> reverse $ execStateT (mapM (modify . (:)) v) []) [1,2,3]
13:54:52 <lambdabot>   [[3,2,1]]
13:54:53 <bd_> geezusfreeek: oh, point
13:55:12 <bd_> > (\v -> reverse $ execState (mapM (modify . (:)) v) []) [1,2,3]
13:55:13 <lambdabot>   [1,2,3]
13:55:16 <bd_> There we go
13:55:25 <trofi> what is faster? (nub.sort) or (sort.nub)?
13:55:25 <trofi> or yet something more efficient
13:55:41 <bd_> @hoogle uniq
13:55:41 <lambdabot> Language.Haskell.TH.Syntax type Uniq = Int
13:55:41 <lambdabot> module Data.Unique
13:55:41 <lambdabot> Data.Unique data Unique
13:55:44 <bd_> hmm
13:55:57 <Myoma> @let uniq = map head . group
13:55:57 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
13:55:58 <bd_> trofi: if you're going to be sorting it, you don't want nub
13:56:01 <ddarius> trofi: Out of those options, sort . nub, but there are asymptotically better versions
13:56:05 <bd_> :t map head . group . soft
13:56:06 <lambdabot> Not in scope: `soft'
13:56:06 <bd_> :t map head . group . sort
13:56:07 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:56:30 <geezusfreeek> :t nub
13:56:31 <lambdabot> forall a. (Eq a) => [a] -> [a]
13:56:32 <bd_> @check \l -> (map head . group . sort $ l) == (nub . sort $ l :: [Int])
13:56:33 <lambdabot>   "OK, passed 500 tests."
13:57:16 <geezusfreeek> @src nub
13:57:17 <lambdabot> nub = nubBy (==)
13:57:29 <geezusfreeek> @src nubBy
13:57:29 <lambdabot> nubBy eq []             =  []
13:57:29 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:57:58 <bbs> http://rafb.net/p/YadznW74.html
13:58:03 <lambdabot> Title: Nopaste - No description
13:58:08 <bbs> yo that is supposed to return the minimum in the list
13:58:13 <bbs> but it doesn't always work :(
13:58:23 <geezusfreeek> bbs: you never check the head of the list
13:58:27 <bbs> geezusfreeek: yea
13:58:30 <bbs> how do i append the head
13:58:34 <bbs> :head?
13:59:22 <Botje> bbs: uh. you don't do a recursive call either.
13:59:37 <bd_> bbs: the first problem is you peel off an element with x, then throw it away
13:59:47 <bd_> what if x is the element you want?
13:59:58 <bd_> the second problem is you're just wrapping minimum, poorly :)
14:00:20 <geezusfreeek> @src minimum
14:00:20 <lambdabot> minimum [] = undefined
14:00:20 <lambdabot> minimum xs = foldl1 min xs
14:01:24 <tristes_tigres> The ghci does not seem to have any way to look at the source, like lambdabot's @src
14:01:42 <geezusfreeek> there is a lambdabot plugin for ghci though ;)
14:01:58 <geezusfreeek> though i have never used it
14:02:02 <tristes_tigres> geezusfreeek: it's no good when you are offline
14:02:09 <geezusfreeek> oh, that stinks
14:02:20 <ddarius> It should work fine offline.
14:02:29 <tristes_tigres> geezusfreeek: Hugs for instance allows to look at the source
14:03:04 <retybok> how should I implement python's ",".join(stringlist) in haskell?
14:03:11 <tristes_tigres> ddarius: how it will query lambdabot when you are not connected to the net ?
14:03:12 <Botje> @src intercalate
14:03:12 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:03:16 <Botje> retybok: ^^
14:03:21 <retybok> Botje: thanks
14:03:31 <ddarius> tristes_tigres: It -is- lambdabot.  It doesn't interact through IRC.
14:03:58 <tristes_tigres> ddarius: by offline I mean not just not on the IRC
14:04:09 <tristes_tigres> but not on the net period
14:04:30 <ddarius> tristes_tigres: GHCi on Acid is a -local copy- of lambdabot.  To build it, you need to build lambdabot.
14:05:05 <tristes_tigres> ddarius: but out of the box GHCi does not have this functionality
14:05:07 <ddarius> In fact, as I said, GOA doesn't "require" lambdabot, it -is- lambdabot
14:05:19 <newsham> http://www.thenewsh.com/~newsham/x/machine/Sawzall.hs
14:05:28 <ddarius> That would be why geezusfreeek said it is a "plugin for ghci"
14:05:34 <tristes_tigres> and hugs *does*
14:05:51 <geezusfreeek> tristes_tigres: what is the point of all this?
14:06:00 <ddarius> Hugs is an interpreter.  The source must still be around.
14:06:19 <tristes_tigres> geezusfreeek: the point of being able to look at the source ?
14:06:36 <Myoma> newsham: cool
14:06:41 <geezusfreeek> the point of going on about how ghci doesn't have it built in when there is a solution already?
14:06:42 <Myoma> newsham: where does the name sawzall come from
14:06:43 <bbs> shit this is annoying
14:06:49 <bbs> i'm so bad at this language lol
14:06:54 <newsham> http://research.google.com/archive/sawzall.html
14:06:54 <lambdabot> Title: Google Research Publication: Sawzall
14:07:03 <MyCatVerbs> bbs: what is your boggle, citizen? :)
14:07:23 <geezusfreeek> :t Data.Foldable.fold
14:07:24 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
14:07:24 <tristes_tigres> bbs: Haskell is not a lnaguage, it is a religion
14:07:26 <MyCatVerbs> bbs: I mean. Greeting, citizen. What's your boggle?
14:07:44 <geezusfreeek> :t Data.Foldable.foldMap
14:07:45 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
14:07:51 <MyCatVerbs> *Greetings, even. Gah. At this rate, I'm never going to find out what those seashells are for.
14:08:07 <geezusfreeek> newsham: how does sawzall differ from foldMap?
14:08:23 <newsham> dont know
14:08:28 <zachk> so i tried prototyping my Java lab assignment in haskell, and ended up with no java program, but got an extension to wednesday, and i skipped german to make a nonworking program. geezum
14:08:51 <newsham> geezus: perhaps foldMap is sawzall embodied
14:08:53 <bd_> zachk: but did the haskell program work? >.>
14:09:03 <ddarius> zachk: I recommend doing your Java assignments in Java.
14:09:14 * Myoma seconds ddarius ..
14:09:30 <Myoma> (or at least embed a DSL in java using reflection..)
14:09:33 <newsham> whats the minimum definition for instance Foldable?
14:09:44 <geezusfreeek> either foldMap or foldr
14:09:59 <zachk> bd_: no the haskell program didnt work, and ddarius I agree with you 100%
14:10:23 <newsham> hrmm.. one point though,  "sawzall" is just a minimal implementation, its really the interface and not the implementation that is important
14:10:32 <bbs> lol i have no problem
14:10:33 <newsham> in a real "sawzall" implementation, it would distribute work across nodes
14:10:40 <bbs> i'm just used to c and being a little whiner
14:10:48 <bbs> so how do i append the head of the list
14:11:05 <newsham> > 1 : [2,3,4,5]
14:11:06 <lambdabot>   [1,2,3,4,5]
14:11:07 <Twey> `a : xs`?
14:11:43 <Twey> ddarius: What if you write a Haskell compiler in Java?  :-P
14:12:02 <FunctorSalad> can the development version of TH already do splices that refer to previous splices in the same file?
14:15:13 <bbs> the reason i was asking is because i'm trying to find the minimum of a list --
14:15:19 <zachk> ddarius that sounds like a good idea but now to go home ahhh yea that would be a lot of work
14:15:22 <bbs> using the minimum command
14:15:36 <lispy> haskell compiler in java?
14:15:36 <zachk> bbs: do this
14:15:48 <geezusfreeek> > minimum [3,6,5,1,8]
14:15:49 <lambdabot>   1
14:15:57 <zachk> > head $ sort [5,2,1,2,3,2]
14:15:57 <Myoma> bootstrapping a haskell -> java compiler would be more interesting
14:15:58 <lambdabot>   1
14:16:03 <Twey> lispy: Hell yeah
14:16:15 <zachk> how about a jvm in haskell
14:16:15 <lispy> Twey: finishing lambdaVM is probably less work
14:16:23 <zachk> or a java compiler written in haskell
14:16:26 <Twey> I want to write one in C#, too.  That way I'm covered for any possible CS assignment.
14:16:44 <Myoma> Why don't you just not do CS assignments?
14:16:49 <Myoma> This has worked very well for me
14:16:56 <zachk> peace
14:16:56 <newsham> hmm.. no Minimum monoid in Data.Monoid?
14:17:09 <bbs> wow that didn't help me at all
14:17:37 <geezusfreeek> bbs: you are trying to find the minimum of a list. just do "minimum myList" and you're done
14:17:46 <lispy> if you want to do functional programming on the JVM, I think scala is the most realistic option.  For the .NET CLR, go with F#
14:18:14 <geezusfreeek> bbs: that is, unless you really are trying to do something else and didn't specify it very well
14:18:19 <bbs> geezusfreeek: lol
14:18:26 <bbs> http://rafb.net/p/YadznW74.html
14:18:27 <lambdabot> Title: Nopaste - No description
14:18:32 <bbs> ^^ is what i'm doing
14:18:36 <bbs> but i'm fail
14:18:47 <geezusfreeek> is lmin supposed to return the smallest element of the list?
14:18:50 <pjdelport> newsham: you would need mempty
14:18:56 <geezusfreeek> because the minimum function you are using already does that
14:19:24 <bbs> geezusfreeek: yea
14:19:32 <lispy> 0 might not be an element of the list
14:19:47 <geezusfreeek> oh wait, you want the find the minimum of the list unless it's empty in which case you want zero?
14:20:20 <lispy> myMin :: Ord a => [a] -> Maybe a
14:20:20 <geezusfreeek> lmin [] = 0; lmin xs = minimum xs
14:20:27 <lispy> myMin [] = Nothing
14:20:30 <Baughn> Is there a more efficient/idiomatic form of "iterate f x !! 7"?
14:20:44 <geezusfreeek> but yeah, lispy's way is more haskelly
14:20:51 <bbs> geezusfreeek: exactly
14:20:51 <DrSyzygy> f . f . f . f . f . f . f $ x
14:20:56 <newsham> newtype Min = Min { Maybe Int }    ?
14:20:56 <DrSyzygy> For instance. :-)
14:21:08 <Baughn> DrSyzygy: ..right, sticking with iterate.
14:21:08 <Twey> > fix (.)
14:21:09 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
14:21:09 <lambdabot>      Proba...
14:21:15 <Myoma> :t mconcat . replicate 7
14:21:16 <lambdabot> forall a. (Monoid a) => a -> a
14:21:16 <DrSyzygy> Baughn: Heh
14:21:33 <Myoma> :t (mconcat . replicate 7 $ ?f) ()
14:21:34 <lambdabot> forall t. (?f::() -> t, Monoid (() -> t)) => t
14:21:43 <FunctorSalad> with TH you could even make it work for arbitrary numbers instead of 7
14:21:49 <dolio> Sadly, that doesn't work.
14:21:49 <Myoma> that's not right
14:21:58 <FunctorSalad> not? :(
14:22:02 <newsham> > (mconcat $ replicate 7 (*2)) 5
14:22:02 <bbs> geezusfreeek: thank you -- t
14:22:03 <lambdabot>   Add a type signature
14:22:08 <dolio> It'd have to be: appEndo . mconcat . replicate 7 . Endo
14:22:11 <dolio> Or something like that.
14:22:11 <Myoma> FunctorSalad: what I wrote isn't write
14:22:18 <FunctorSalad> ah
14:23:22 <geezusfreeek> bbs: no problem. for the record, if you are using 0 to represent null then you're doing it wrong. if 0 is actually what you wanted for math reasons and stuff, go right ahead, but otherwise i would recommend you try it the way lisp suggested, using Maybe
14:23:35 <dolio> @type appEndo . mconcat . replicate 7 . Endo
14:23:36 <lambdabot> forall a. (a -> a) -> a -> a
14:25:21 <FunctorSalad> > let pow f n = foldr1 (.) (replicate n f) in (pow (*2) 7) 1
14:25:22 <lambdabot>   128
14:26:14 <newsham> iterate doesnt seem like such a bad solution
14:26:49 <twanvl> > let pow f n = (!!n) . iterate f in pow (*2) 7 1
14:26:50 <lambdabot>   128
14:27:57 <FunctorSalad> we could let (^^) = pow so we have more exponentiation operators.
14:28:02 <FunctorSalad> ;-)
14:28:23 <lilac> FunctorSalad: (^^^) perhaps?
14:28:38 <Botje> ^__^
14:28:46 <FunctorSalad> lilac: oh right, (^^) is taken
14:28:59 <newsham> (^5)
14:29:29 <FunctorSalad> ?let (^_^) f n = (!!n) . iterate f
14:29:30 <lambdabot>   Parse error
14:29:35 <FunctorSalad> :(
14:30:10 <bwr_> hhaa
14:30:10 <dolio> _ isn't an operator character.
14:30:51 <bwr_> ?let (^-^) f n = (!!n) . iterate f
14:30:52 <lambdabot>  Defined.
14:30:56 <lilac> > let pow f n x = foldr id x $ replicate n f in pow (*2) 7 1
14:30:57 <lambdabot>   128
14:31:11 <newsham> > (*2) ^-^ 7 1
14:31:11 <lilac> every non-trivial function is a fold :)
14:31:11 <lambdabot>       Overlapping instances for Show (a -> a)
14:31:12 <lambdabot>        arising from a use of `s...
14:31:22 <newsham> > ((*2) ^-^ 7) 1
14:31:23 <lambdabot>   128
14:31:24 <olsner> is (^^) taken?
14:31:30 <ddarius> > (-5) `div` 2
14:31:31 <lambdabot>   -3
14:31:34 <lilac> > 6 ^^ 7
14:31:35 <lambdabot>   279936.0
14:31:49 <newsham> ?type (^^)
14:31:50 <olsner> > 6 ^7
14:31:50 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
14:31:51 <lambdabot>   279936
14:31:59 <FunctorSalad> lilac: but as the generics doc says, tying to understand the type of gfoldl can lead to brain damage.
14:32:08 <lilac> hehe :)
14:33:36 <FunctorSalad> @type gfoldl
14:33:37 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
14:33:49 <lilac> let a =!====> b = attackWithSword a b
14:33:50 <bbs> is it possible to define two vars in type?
14:33:52 <FunctorSalad> the goggles, they do nothing!
14:33:55 <lilac> hmm.
14:33:56 <olsner> FunctorSalad: the docs say that?
14:33:57 <FunctorSalad> lilac: lol
14:34:00 * lilac off to write an rpg
14:34:04 <FunctorSalad> olsner: actually I think it was the paper
14:34:10 <olsner> ah
14:34:21 <FunctorSalad> the doc weakened the claim to headache induction IIRC
14:34:26 <bbs> rotate :: a,[a] -> [a]
14:34:33 <bbs> so i give it a number and a list and then want a list back
14:34:41 <bbs> same list as before but in a different number
14:36:53 <sjanssen> what is " a,[a]" supposed to mean?
14:36:57 <retybok> So I've completed my first non-trivial haskell program(http://hpaste.org/10409). Basically it takes input data in some format, processes it a bit, and prints it out in a CSV array. Could anyone review it quicly for some beginner's mistakes/possible improvements?
14:37:48 <pcapriotti> I have a function f :: Int -> Results -> ST s Results and I would like to compute, for a fixed v0 :: Results and n :: Int, v0 >>= f 1 >>= f 2 >>= ... >>= f n. Using foldl for this results in a stack overflow for big n. Any hints?
14:38:14 <sjanssen> pcapriotti: I think you want foldr
14:38:39 <Heffalump> I think you want foldM, does that stack overflow too?
14:38:51 <sjanssen> @src foldM
14:38:51 <lambdabot> foldM _ a []     = return a
14:38:51 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:39:08 <Heffalump> hmm, perhaps not then
14:39:45 <pcapriotti> uhm....
14:39:47 <sjanssen> pcapriotti: you're not consistent with your types
14:40:03 <sjanssen> does v0 :: Results, or ST s Results?
14:40:19 <pcapriotti> ah, sorry, v0 :: ST s Results
14:41:17 <bjrn> How do I use the zlib license in my Cabal package?
14:41:21 <yitz> pcapriotti: never use foldl, always foldl' (almost always)
14:41:22 <pcapriotti> foldr would apply (f i) in the wrong order
14:41:32 <sjanssen> @type \v0 f -> foldr (\x xs v -> f x v >>= xs) v0
14:41:33 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a1 -> m b) -> (a -> a1 -> m a1) -> [a] -> a1 -> m b
14:41:44 <dcoutts> bjrn: OtherLicense
14:41:46 <sjanssen> pcapriotti: I think that's the function you want
14:41:50 <bjrn> dcoutts: Ah, cheers.
14:41:55 <sjanssen> except my v0 is non-monadic, but that is easy to fix
14:42:19 <bjrn> dcoutts: You the Cabal main developer? In that case: Cabal rocks. It's really easy to use.
14:42:36 <sjanssen> @type \v0 f -> v0 >>= foldr (\x xs v -> f x v >>= xs)
14:42:37 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => ([a] -> a1 -> m b) -> (a -> a1 -> m a1) -> [a] -> a1 -> m b
14:43:09 <sjanssen> hmm, maybe not
14:43:24 <dcoutts> bjrn: thanks :-) I'm current maintainer but nearly 50 people have contributed.
14:43:59 <sjanssen> @type \v0 f xs -> v0 >>= foldr (\x xs v -> f x v >>= xs) return xs
14:44:00 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m a1 -> (a -> a1 -> m a1) -> [a] -> m a1
14:44:11 <sjanssen> there we go.
14:44:11 <salty-horse> hi. I'm looking for some advice: I have really basic knowledge of functional programming. I started reading the sicp book a few years ago, and tried reading a few haskell tutorials a year ago. now I have lots of free time. should I focus on haskell, or start with scheme?
14:44:15 <sjanssen> @type foldM
14:44:16 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:44:28 <FunctorSalad> retybok: if you prefer printf for things like what you do in to_csv, you can use Text.Printf. of course that's just a matter of preference, not a mistake :)
14:44:29 <Myoma> salty-horse: flip a coin
14:44:51 <Myoma> salty-horse: They are both worth learning
14:44:51 <gladpack2> im trying to create a function(monad?) that given a key and value initializes a Map. then i want insert, remove etc too
14:45:05 <gladpack2> http://hpaste.org/10410
14:45:08 <salty-horse> Myoma, I'll start with scheme/lisp, then. it seems simpler
14:45:22 <yitz> salty-horse: the big difference since a year ago is that Real World Haskell is now available.
14:45:30 <sjanssen> gladpack2: the second is wrong
14:45:44 <sjanssen> (unless Dmap /= Data.Map)
14:45:47 <salty-horse> yitz, I tried reading Yet Another Haskell Tutorial
14:45:49 <ddarius> Scheme still has a lot more good resources for learning.
14:45:53 <bbs> sjanssen: a,[a] is supposed to mean that i want int for first var and a list for the second
14:46:03 <sjanssen> gladpack2: the first looks okay
14:46:06 <salty-horse> yitz, the first chapter of Real World Haskell was digestablee :)
14:46:22 <sjanssen> bbs: that is not Haskell notation at all :)
14:46:24 <ddarius> salty-horse: How much prior programming experience do you have?
14:46:34 <gladpack2> how would i do monadic create?
14:46:37 <sjanssen> bbs: I think you want "Int -> [a] -> ..."
14:46:39 <gladpack2> imperative create
14:46:43 <pcapriotti> yitz: what's foldl'?
14:46:58 <sjanssen> gladpack2: there is no monadic creation for Data.Maps -- they're purely functional
14:47:02 <salty-horse> ddarius, I'm good with c/c++. I like doing functional-style prograamming in python. I also learned prolog in high-school
14:47:23 <yitz> pcapriotti: import Data.List, then do what you did before but replace foldl with foldl' (same type, but stricter to squash stack overflows)
14:47:25 <salty-horse> my college doesn't offer any functional programming courses :(
14:47:32 <bbs> sjanssen: the method gets two parameters
14:47:34 <pcapriotti> ok
14:47:37 <gladpack2> can i do destructive updates?
14:47:42 <ddarius> salty-horse: Okay.  If you are already a rather competent programmer but want to focus on functional programming specifically, Haskell may be better.
14:47:48 <gladpack2> so i can do struct.delete(x)
14:47:49 <sjanssen> bbs: yes, "Int -> [a] -> ..." means two parameters
14:47:52 <retybok> FunctorSalad: right. Thanks for the reply
14:47:58 <sjanssen> gladpack2: no destructive updates
14:48:02 <gladpack2> and not struct = struct.delete(x)
14:48:02 <bbs> sjanssen: ok thx
14:48:07 <sjanssen> gladpack2: deletion returns a new Data.Map without the value
14:48:07 <ddarius> I personally recommend Scheme to those who have little or no programming experience.
14:48:27 <salty-horse> ddarius, would it be easier to jump onto other similar languages after I know haskell? or would I assume too much "purity"?
14:48:40 <plutonas> what is the shortcat in the emacs haskell mode, to compile/load a file in the interpreter?
14:48:56 <Myoma> salty-horse: Haskell will ruin your chances of programming well in imperative languages :P
14:49:14 <newsham> salty: haskell is more on one end of the extreme.  if you already have a good handle on imperative programming, then knowing haskell should give you a good reference for jumping on languages that are in between the two
14:49:15 <Myoma> salty-horse: (That's probably not true since you seem to be aware of the issues)
14:49:18 <newsham> like python and lisp
14:49:37 <FunctorSalad> retybok: you may also want to define a data type for the triple you pass around... it's not only less verbose, it also avoids errors because even though two values may both be a String, if you wrap them in a data or a newtype the compiler will complain if you put one where the other should go
14:49:39 <salty-horse> Myoma, that's what I'm fearing. I don't want to rewire my brain. it's the same reason I don't want to use a dvorak keyboard
14:50:01 <plutonas> dvorak rules!
14:50:04 <newsham> if you're afraid, go with scheme :)
14:50:11 <plutonas> anyway anyone with the shortcut? couldn't find it on google
14:50:11 <newsham> the only thing you'll rewire is your syntax
14:50:23 <ddarius> salty-horse: Learning more languages won't make you a worse programmer in any of them.
14:50:25 <lament> people who don't rewire their brain vote for McCain :)
14:50:25 <pao_> Myoma: ... or better... will ruin your chances of being able to use imperative languages at all:-)
14:50:36 <Myoma> salty-horse: that reminds me, I should try a new keyboard layout :)
14:50:43 <retybok> FunctorSalad: that's what new data types are for :) I was always wondering when reading the haskell tutorials.
14:50:43 <ddarius> You are not going to forget how to program in other languages.
14:50:54 <olsner> haskell will only ruin your chances of *enjoying* imperative languages :P
14:50:54 <Cale> salty-horse: To be honest, you'll probably write better imperative code, you'll just be more annoyed at your language while doing it :)
14:51:03 <pcapriotti> yitz: no luck, still stack overflow
14:51:05 <yitz> salty-horse: it's not just a rewire. it won't hurt your imperative programming, just open you eyes more.
14:51:07 <newsham> what cale said
14:51:08 <FunctorSalad> retybok: maybe it's overkill for this example, I just meant generally
14:51:14 <yitz> pcapriotti: bummer
14:51:25 <retybok> FunctorSalad: could you show me how you would write the data type definition?
14:51:28 <bbs> rotate n list =
14:51:39 <bbs> thats two arguements
14:52:06 <bbs> it doesn't recognize space as seperateing the parameters
14:52:10 <salty-horse> ok, so Real World Haskell is the way to go?
14:52:12 <gladpack2> u might feel that imperative programming is very primitive
14:52:20 <gladpack2> afterwards
14:52:26 <ddarius> salty-horse: It depends on what your goals are.
14:52:34 <FunctorSalad> retybok: heh, I'm just an intermediate-level user but I can try
14:52:37 <bjrn> salty-horse: It's a very nice book, I recommend it highly.
14:52:48 <salty-horse> I want to learn functional programming, and I want to learn haskell
14:52:53 <newsham> read a few chapters online, figure out if you like it
14:52:57 <Cale> salty-horse: Sure, try that out. I haven't read it completely myself, but it's written by some smart people from this channel :)
14:53:07 <bbs> salty-horse: i got it and like it -- i'm just 1/4 way through it
14:53:08 <Myoma> salty-horse: If you want to learn _functional programming_ don't bother with scheme
14:53:08 <bbs> lol
14:53:14 <ddarius> Real World Haskell is geared to those who want to use Haskell to do stuff.  If you are more interested in the different ideas behind it, other books/resources may be better.
14:53:14 <Cale> salty-horse: Most importantly, ask lots of questions here. :)
14:53:15 <newsham> the online version comes with a money back guarantee
14:53:16 <Myoma> salty-horse: haskell is definitely the way to go
14:53:20 <salty-horse> Myoma, becausee of the side effects? :)
14:53:22 <retybok> FunctorSalad: no worries, it will always be better then what I might write myself :)
14:53:27 <Myoma> salty-horse: Scheme is procedural
14:53:41 <Myoma> salty-horse: but I highly recommend learning it, and getting the book The Reasoned Schemer :)
14:53:51 <Cale> Well, there's a purely functional subset of scheme...
14:53:57 <Twey> It doesn't *have* to be procedural
14:53:58 <Myoma> (at some point in time, it probabl doesn't matter what order you do things in)
14:54:04 <lament> there's a purely functional subset of C...
14:54:06 <Twey> It can be written in a purely-functional style
14:54:09 <bjrn> The Schemer books are really cool.
14:54:14 <Twey> lament: O.O  Seriously?
14:54:17 <bjrn> And there's of course SICP
14:54:18 <Cale> I think it would be cool to do something like scheme but where effects were reified as values, like an IO monad.
14:54:18 <plutonas> thanks, for not responding, it's C-c C-l
14:54:24 <newsham> there's a purely functional subset of the c preprocessor
14:54:45 <lament> Twey: sure, just don't introduce any variables...
14:54:50 <Twey> Aye
14:54:53 <Twey> Oh
14:55:00 <Twey> What, in C?
14:55:01 <newsham> printf("neat!");  <- no variables
14:55:04 <Twey> No, not really
14:55:07 <rumbleca> is haskell a superset of miranda?
14:55:13 <lament> Twey: sure, you can do quite a bit with what's left
14:55:24 <the_unmaker> is doing a website in haskell crazy?
14:55:29 <olsner> @ty let foldM' f z xs = z >>= go f xs where go f [] = return; go f (x:xs) = (go f xs =<<) . f x in foldM'
14:55:29 <newsham> throwing out variables does not make it functional.
14:55:29 <salty-horse> bjrn, if I learn it, it'll only be through SICP. I'm not planning on actually programming real software with it.. I just want to learn the basics of functional programming (in some form ;)
14:55:30 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> a -> m a) -> m a -> [t] -> m a
14:55:30 <Cale> rumbleca: It's a descendant of Miranda.
14:55:31 <Twey> lament: There are standard functions that take parameters to modify
14:55:39 <bd_> newsham: surely you mean no #undef or redefining?
14:55:41 <lament> Twey: so you don't use those.
14:55:42 <Twey> the_unmaker: No, not entirely
14:55:48 <bd_> printf has little to do with the preprocessor :)
14:55:50 <Cale> the_unmaker: Not particularly so, but not many people have done it.
14:55:58 <Twey> lament: But they're pretty vital things :)
14:56:06 <Twey> You can't write anything really useful without them
14:56:07 <thoughtpolice> the_unmaker: there're some frameworks out there but i still see it as somewhat of an open space
14:56:28 <the_unmaker> i see happs adn wash and hsp
14:56:29 <Cale> the_unmaker: So it's something which is theoretically sane, but where you may have practical issues depending on time constraints and how much you're willing to pave that path for others :)
14:56:31 <Twey> Also, the conventional C pattern is to modify a parameter and return an indicator of how the operation went
14:56:36 <the_unmaker> heh
14:56:46 <the_unmaker> well the alternatiev for me is to use aolserver+tcl
14:57:03 <the_unmaker> which is apparently well vetted but it uses a procedural language tcl
14:57:05 <lament> Twey: i'm pretty sure that ignoring the stack limit, C-without-variables is turing-complete.
14:57:14 <the_unmaker> I dont want to go with cherokee and php
14:57:21 <the_unmaker> Im suc a stuborn bugger
14:57:25 <newsham> lament: c without variables is functional?
14:57:36 <olsner> pcapriotti: try that foldM variant... it seems to have the right type at least, so there's a good chance it works :)
14:57:38 <lament> Twey: of course assignment makes it more useful; but then, assignment would make Haskell more useful, too :)
14:57:52 <bd_> lament: C-without-variables or C-without-mutable-variables?
14:57:57 <pcapriotti> olsner: ok, thanks
14:57:59 <bd_> because the former includes arguments, I'd think
14:58:07 <retybok> FunctorSalad: so would I need a "newtype" or a "data"? I'm quite confused between the two
14:58:19 <Vq^> the_unmaker: happs might be a way to go, but as Cale said, not many writes webapps in Haskell
14:58:39 <newsham> *(int*)0x12345 = 5;
14:58:40 <Cale> happs seems like it would be very nice if only it were better documented.
14:58:43 <lament> bd_: if you say "Without mutable variables", nitpicking IRCers will probably start talking about how you can't enforce that...
14:58:45 <Vq^> the_unmaker: you may find that you have to implement a lot of things that are given in other web frameworks such as Zope
14:58:49 <FunctorSalad> retybok: hmm, newtype is more less a special case of data where you only have one constructor that has only one argument
14:58:57 <lament> bd_: without any variables, it's at least clear-cut
14:58:58 <bd_> lament: well, we're talking about arbitrary limitations in C anyway...
14:59:10 <bd_> lament: ah, but how can you have turing completeness without arguments either?
14:59:11 <the_unmaker> zope!!
14:59:11 <FunctorSalad> retybok: so you can use data
14:59:20 <the_unmaker> zope wow looks polished
14:59:20 <thoughtpolice> the_unmaker: with packages out there like fcgi, lots of json/xml/rss libs, and the plethora of database interfaces I'm surprised nobody has just glued a bunch of those things together and made something minimal yet
14:59:22 <bd_> and if you simply disallow variable declarations, arguments are still mutable
14:59:34 <lament> bd_: why do you need the arguments?
14:59:35 <bd_> so you need to prevent variable mutation anyway
14:59:37 <thoughtpolice> either that, or the people who have done it need to advertise more :]
14:59:55 <the_unmaker> thoughtpolice: heh, perhaps I should take the plunge and do haskell and something new, who knows performance could rock
15:00:04 <bd_> lament: because otherwise the action of a function is fixed - it will always take the same path through any conditional statements
15:00:10 <thoughtpolice> it doesn't seem infeasible imo
15:00:11 <retybok> FunctorSalad: I'll try :)
15:00:27 <bd_> and thus if main ever recurses, it will recurse indefinitely. Otherwise, it will terminate.
15:00:42 <thoughtpolice> it's just nobody seems to have put the pieces together
15:00:43 <bd_> Thus we can easily determinate if the program terminates - and therefore it is not turing complete
15:00:46 <lament> bd_: actually you can still have input: if(scanf(...))
15:00:51 <bd_> lament: Is that functional?
15:00:54 <thoughtpolice> happs does look nice but documentation is nowhere
15:00:55 <lament> nope :)
15:00:58 <bd_> Seems to be mutating global state to me :)
15:01:05 <lament> it's functional, it's not referentially transparent
15:01:08 <newsham> read(open("x", 0), 0x12345, 5); write(open("x", O_WRONLY|O_CREAT, 0666), 0x54321, 5); read(open("x", 0), 0x12345, 5);
15:01:38 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happs-tutorial
15:01:40 <lambdabot> Title: HackageDB: happs-tutorial-0.3, http://tinyurl.com/6repg4
15:01:49 <olsner> newsham: you're just making those pointers up! that won't work!
15:01:50 * lament slaps newsham with a very rare species of fish
15:01:51 <the_unmaker> I found some happs tutorial...
15:01:57 <newsham> olsner: why not?
15:02:08 <bd_> lament: I'm still not sure if that'd be turing complete... Simply because it can't examine any aspect of the input besides whether the input terminates
15:02:13 <bd_> and possibly the length
15:02:14 <newsham> pointers shall not be made up?
15:02:17 <the_unmaker> http://happstutorial.com:5001
15:02:17 <bd_> (in some limited ways)
15:02:18 <lambdabot> Title: Index of /
15:02:31 <olsner> yeah, thou shalt not, etc
15:02:36 <bd_> actually, the termination argument still holds. Run it until the input runs out, then see if it recurses after that.
15:02:43 <pcapriotti> olsner: no way, stack overflow...
15:02:44 <bd_> If it does, it'll never terminate. Otherwise, it will.
15:02:47 <bd_> Thus, not turing complete
15:03:08 <pcapriotti> olsner: I don't understand why this happens... the ST monad is supposed to be strict, right?
15:03:19 <dons> ?users
15:03:20 <lambdabot> Maximum users seen in #haskell: 511, currently: 493 (96.5%), active: 31 (6.3%)
15:03:20 <bd_> (since all the input functions will return their flavor of EOF in all cases)
15:03:23 <dons> 511.
15:03:25 <olsner> well, sometimes strictness is the problem
15:03:29 <dons> new high score, two days in a row.
15:03:32 <pcapriotti> and there's no recursion whatsoever outside of foldl
15:03:41 <retybok> FunctorSalad: actually I think I need "type", not "data", because I don't need to parameterize it
15:03:47 <olsner> could you paste the source on e.g. hpaste?
15:03:53 <pcapriotti> yes
15:03:54 <bd_> pcapriotti: foldl is almost always not what you want. Does foldl' help?
15:04:00 <thoughtpolice> dons: gee brain, what do you want to do tonight? :]
15:04:12 <Cale> pcapriotti: foldl can produce very large expressions which create stack overflows when evaluated
15:04:14 <dons> What we always do, thoughtpolice.
15:04:36 <Cale> pcapriotti: The stack in most Haskell evaluators doesn't mean what it means in, say, C.
15:04:51 <yitz> bd_, Cale: pcapriotti says that foldl' didn't help. But let's see the paste.
15:04:53 <ddarius> dons: The new academic year is starting.
15:04:56 <dons> ah
15:05:00 <dons> yes, summer is over.
15:05:29 <FunctorSalad> retybok: "type" just defines synonym
15:05:31 <olsner> but we've grown like 100 people compared to last year, right?
15:05:35 <pcapriotti> here: http://hpaste.org/10411
15:05:41 <Cale> pcapriotti: The stack measures the depth from the expression you're trying to evaluate down to the outermost leftmost reducible subexpression.
15:06:23 <FunctorSalad> retybok: do you really need to pass the state around between the calls of "processLine"?
15:06:43 <newsham> ?brain, "are you thinking what I'm thinking?"
15:06:43 <lambdabot> I think so, Brain, but Lederhosen won't stretch that far.
15:06:48 <retybok> FunctorSalad: check it out:http://hpaste.org/10412 .It IS more readable with type :)
15:07:06 <FunctorSalad> retybok: it looks like reading one line doesn't depend on what was in the previous lines
15:07:16 <retybok> FunctorSalad: well, I could pass the whole dataset
15:07:33 <retybok> I'm actually building the map, so I do need to pass it around
15:08:24 <FunctorSalad> retybok: yeah, but you could have processLine return only the data from its own line, and then do Map.union or something in main
15:08:47 <pcapriotti> Cale: ok, that makes sense..
15:08:50 <retybok> right
15:08:59 <Cale> pcapriotti: So for instance:
15:09:02 <sjanssen> pcapriotti: did you try my foldr?
15:09:08 <pcapriotti> Cale: so what's the best way to do something like v0 >>= f1 >>= f2 ... ?
15:09:24 <sjanssen> pcapriotti: foldr
15:09:27 <FunctorSalad> retybok: with "type" you don't get additional type safety (the two sides of the "=" can be substituted freely for each other). that can be good or bad
15:09:59 <pcapriotti> sjanssen: what's the difference with foldr?
15:10:02 <FunctorSalad> retybok: with "newtype" or "data" you would need to explicitly wrap the Map into a ResultDict
15:10:09 <Cale> foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) ((0+1)+2) [3] -> foldl (+) (((0+1)+2)+3) [] -> (((0+1)+2)+3) -- at which point if this expression is too large, you get a stack overflow, because you have to descend far into it to get to the redex (0+1)
15:10:24 <retybok> FunctorSalad: I think I see what you mean
15:10:25 <yitz> pcapriotti: minimum over a large list also stack overflows
15:10:32 <yitz> @src minimum
15:10:33 <lambdabot> minimum [] = undefined
15:10:33 <lambdabot> minimum xs = foldl1 min xs
15:10:40 <sjanssen> pcapriotti: v0 >>= (f1 >>= (f2 ...)) vs. ((v0 >>= f1) >>= f2 ...)
15:10:45 <yitz> it uses foldl, not foldl'
15:10:48 <sjanssen> pcapriotti: >>= should be right associated
15:11:01 <olsner> heh, so maybe using another variant of minimum will solve it directly?
15:11:06 <yitz> so use foldl' min maxBound instead of minimum
15:11:17 <pcapriotti> no, I'm using minimum on a small list
15:11:28 <yitz> pcapriotti: ok.
15:12:01 <retybok> FunctorSalad: thanks for reviewing my program
15:12:03 <pcapriotti> sjanssen: I'll try that
15:12:47 <FunctorSalad> retybok: np ;-)
15:13:44 <Cale> pcapriotti: Can you give me some example input?
15:14:06 <sjanssen> pcapriotti: http://hpaste.org/10411#a1
15:14:17 <olsner> how large 'weight' values do you usually need to exercise a stack overflow?
15:14:18 * sjanssen misses the hpaste bot
15:14:33 <olsner> ah, a million did it
15:16:20 <pcapriotti> let c = [(1,2), (3, 4)] :: [(Int, Int)]
15:16:24 <pcapriotti> solve2 c 400000
15:18:08 <the_unmaker> can haskell be used to write kick butt log parsers?
15:18:24 <the_unmaker> someone is selling splunk
15:18:25 <lament> i think that's a FAQ
15:18:29 <the_unmaker> all it is is a log parser
15:18:32 <olsner> @faq can haskell be used to write kick butt log parsers?
15:18:32 <lambdabot> The answer is: Yes! Haskell can do that.
15:18:35 <olsner> :D
15:18:41 <the_unmaker> lol
15:18:56 <the_unmaker> ok haskell v tcl? [since aoslerver uses tcl]
15:19:00 <dons> the_unmaker: that's kind of a sweet spot. lazy bytestring parsing.
15:19:05 <the_unmaker> whic is easier to get dynamic website going n growing
15:19:07 <dons> come on. tcl?
15:19:16 <dons> ?proton
15:19:16 <lambdabot> how does haskell do with large systems?
15:19:22 <the_unmaker> well tcl is supposed to be easy and im not that smart
15:19:31 <dons> interesting user.
15:19:46 <Myoma> what do you have against TCL?!
15:19:49 <Myoma> tcl rules
15:19:52 <dons> ?proton
15:19:52 <lambdabot> are you wealthy concultants?
15:20:02 <ddarius> @faq Can Haskell let me write buggy programs fast like tcl?
15:20:02 <lambdabot> The answer is: Yes! Haskell can do that.
15:20:22 <the_unmaker> lol
15:20:26 <the_unmaker> buggy fast!!
15:20:31 <bd_> ddarius: unsafeCast ftw :3
15:20:31 <sbahra> haskell is very insecure
15:20:34 <the_unmaker> bugger fast
15:20:36 <Botje> /crazy/ buggy fast
15:20:52 <the_unmaker> har har h
15:21:07 <Botje> sbahra: orly?
15:21:14 <Botje> sbahra: prove it, then patch it :)
15:21:38 <bbs> shit
15:22:00 <the_unmaker> Myoma: tcl for web apps?
15:22:14 <Myoma> what
15:22:19 * sbahra is using haskell for a "web app"
15:24:09 <bbs> i have a program that takes say 123 and should return [1,2,3] -- at the moment its returning [123] -- any ideas?
15:24:26 <olsner> hmm, how do I force ghci to gaarbage colleect?
15:24:33 <bbs> olsner: in hugs
15:24:34 <bbs> :gc
15:24:48 <Botje> bbs: so you want to take every digit from a number?
15:25:00 <bbs> yea 123 turns into [1,2,3]
15:25:09 <bbs> can i pm u what i have its like 4 lines lol
15:25:16 <ddarius> olsner: Make more garbage
15:25:17 <Botje> put it on hpaste.org
15:25:32 <bbs> i am on an olpc in a comp lab running gentoo linux -- it has no X lol
15:25:38 <bbs> and no wgetpaste unfortunatley
15:25:47 <olsner> :trace seems to have a few space leaks
15:25:49 <Botje> then put it in here
15:25:54 <Botje> worst case i'll put it on hpaste for you :P
15:26:00 <bbs> if ig et kicked lol
15:26:06 <chrisdone> sbahra: are you using formlets‽
15:26:11 <bbs> digits :: a -> [a]
15:26:11 <bbs> digits x = x:xs
15:26:11 <bbs>         where
15:26:11 <bbs>           xs=[]
15:26:24 <Botje> eh.
15:26:24 <Botje> yeah
15:26:38 <Botje> that's not going to do much splitting up
15:26:38 <Botje> :)
15:26:47 <Botje> bbs: take a look at the divMod function
15:26:49 <sbahra> chrisdone, no, I'll take a look though
15:26:56 <olsner> trying to :hist after that :trace made it take at least 33% more memory (probably more, but then I ran out of RAM)
15:27:03 <Botje> > 123 `divMod` 10
15:27:04 <lambdabot>   (12,3)
15:27:04 <chrisdone> sbahra: you are in for a treat!
15:27:15 <tromp> > map digitToInt . show $ 123
15:27:16 <lambdabot>   [1,2,3]
15:27:23 <Botje> or that.
15:28:30 <bbs> :( undefined variable digitToInt lol
15:28:35 <bbs> screw u haskell syntax
15:28:52 <dino-> hm
15:28:56 <dino-> > (map read $ map return "123") :: [Int]
15:28:57 <lambdabot>   [1,2,3]
15:29:29 <dino-> sneakily making a list out of each char
15:29:38 <newsham> > map (read.return) "123" :: [Int]
15:29:39 <lambdabot>   [1,2,3]
15:30:09 <dino-> ah, much nicer
15:30:57 <newsham> > map digitToInt "123a"
15:30:58 <lambdabot>   [1,2,3,10]
15:31:05 <olsner> pcapriotti: replace the $ in "return $ res + c" with $!
15:31:22 <olsner> it's not the fold, it's the plus'es :P
15:31:27 <bbs> undefined variable digitToInt
15:31:30 <bbs> wtf
15:31:36 <ddarius> If there was still caleskell we could write read . return . "123" which would make it just clear as day.
15:31:39 <newsham> ?hoogle digitToInt
15:31:40 <lambdabot> Data.Char digitToInt :: Char -> Int
15:32:23 <newsham> > let (.) = fmap in read . return . "123"
15:32:23 <lambdabot>   Couldn't match expected type `(->) Char' against inferred type `[]'
15:32:47 <olsner> > let (.) = fmap in read . return $ "123"
15:32:48 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
15:33:38 <olsner> > let (.) = fmap in (read . return) . "123"
15:33:38 <lambdabot>   Couldn't match expected type `(->) Char' against inferred type `[]'
15:33:40 <yitz> > let dgts :: Int -> [Int]; dgts = map read . show in dgts 123
15:33:41 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
15:33:42 <olsner> I fail
15:33:50 <Saizan> > let (.) a = fmap a in read . return $ "123"
15:33:51 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
15:33:56 <ddarius> > let (.) f = fmap f in read . return . "123"
15:33:58 <Saizan> > let (.) a = fmap a in read . return , "123"
15:33:58 <lambdabot>   mueval: Prelude.read: no parse
15:33:58 <lambdabot>  mueval: [*** Exception: Prelude.read: no pa...
15:33:58 <lambdabot>   mueval: Prelude.read: no parse
15:34:02 <yitz> > let dgts :: Int -> [Int]; dgts = map (read . (:[])) . show in dgts 123
15:34:03 <lambdabot>   [1,2,3]
15:34:05 <bbs> well those dont work for everything
15:34:11 <bbs> well taht does
15:34:36 <yitz> bbs it's probably not what you want though, it's a hack.
15:34:49 <Saizan> > let (.) a = fmap a in read . return . "123" :: [Int]  -- finally
15:34:50 <lambdabot>   [1,2,3]
15:35:46 <newsham> problymorphic
15:36:11 <bbs> i have nfc what i want
15:36:18 <bbs> since there is like 12 renditions of what i want
15:36:30 <Saizan> nfc?
15:36:48 <bbs> no fscking clue
15:36:55 <mmorrow> . [|()|]
15:36:56 <lunabot>  ConE ()
15:36:58 <mmorrow> sick!
15:37:14 <Saizan> oh, the reasonable implementation is "map digitToInt" imo
15:37:19 <pcapriotti> yitz, olsner, Cale, sjanssen: if I replace (weight' - w) with weight' in the definition of f (http://hpaste.org/10411), it doesn't stack overflow, any idea why?
15:37:21 <newsham> your bot does TH?
15:37:29 <mmorrow> i think it's safe, but try to break it :)
15:37:37 <bbs> sioraiocht: i have no idea what libs i need to add if i know its only prelude thats loaded
15:37:40 <bbs> oops
15:37:41 <mmorrow> newsham: yeah, just got it to literally 10 minutes ago
15:37:43 <bbs> Saizan: ^
15:37:46 <sioraiocht> ?
15:37:47 <Cale> pcapriotti: Aha, it's not evaluating that weight' - w
15:37:49 <Saizan> ?index digitToInt
15:37:50 <lambdabot> Data.Char
15:37:51 <olsner> pcapriotti: did you miss my message above? I think I solved it :P
15:37:52 <mmorrow> . runIO
15:37:53 <lunabot>   Not in scope: `runIO'
15:37:54 <bbs> sioraiocht: sorry wrong nick i'm dumb
15:37:56 <Saizan> bbs: Data.Char ^^
15:37:59 <sioraiocht> ah, heh
15:38:09 <pcapriotti> olsner: ah, yeah, I missed it
15:38:10 <Cale> er...
15:38:18 <Cale> readArray...
15:38:35 <Cale> hmm
15:38:49 <pcapriotti> wow! it works now
15:38:54 <pcapriotti> uhm...
15:39:07 <pcapriotti> I still don't understand the problem very well, though :)
15:39:37 <olsner> well, the plus and minus operations are saves as (evidently) huge trees of unevaluated arithmetic expressions
15:40:25 <Cale> pcapriotti: Out of interest, try replacing runSTArray with runSTUArray
15:40:25 <bbs> digits x = map digitToInt show x
15:40:35 <Cale> and importing Data.Array.Unboxed rather than Data.Array
15:40:37 <olsner> forcing the calculation in each step of f keeps those trees small
15:40:42 <pcapriotti> Cale: ok, thanks
15:40:48 <bbs> Saizan: ^^ i think i'm missign some fundamentals
15:40:53 <pcapriotti> olsner: I see, great
15:41:01 <pcapriotti> thanks everyone for your help
15:41:02 <Cale> What your problem is, I think, is that large expressions are ending up in the array cells.
15:41:16 <Cale> (expressions large enough that evaluating them will cause a stack overflow)
15:41:39 <Cale> Unboxed arrays force the evaluation of their elements automatically, so you don't have to worry about strictifying things.
15:41:55 <Saizan> bbs: digits x = map digitToInt (show x)
15:42:17 <pcapriotti> Cale: yeah, works too
15:42:23 <pcapriotti> Cale: good
15:42:34 <Saizan> bbs: otherwise 'show' and 'x' are parsed as arguments to 'map'
15:42:55 <Cale> Of course, that's only a solution for some types of array (not all arrays can be unboxed), but in this case, it works rather nicely.
15:43:08 <olsner> hmm, unboxing those arrays seems a much cleaner solution - explicit strictness annotation is just ugly voodoo :)
15:43:21 <bbs> Saizan: ok that makes sense
15:43:31 <mmorrow> . $(let sel n i = let x = mkName "x" in lamE [tupP (replicate i wildP++[varP x]++replicate (n-i-1) wildP)] (varE x) in sel 19 12) (3,2,4,3,5,7,45,65,3,6,5,34,5,43,4,54,3,4,54)
15:43:32 <lunabot>  5
15:43:40 * bbs installs lynx so he can checkout Data.chars
15:43:42 <bbs> lib
15:43:44 <Myoma> yay lunabot!
15:43:50 <mmorrow> yippeeTH
15:43:50 <pcapriotti> yeah, in this case I should have made them unboxed anyway
15:44:36 <Myoma>  cool!
15:44:40 <mmorrow> . [d| data A a b c = A a | B b c | C a b c |]
15:44:41 <lunabot>  DataD [] A [a_0,b_1,c_2] [NormalC A [(NotStrict,VarT a_0)],NormalC B...
15:45:01 <Myoma> ♬ [d| data GADTTest where Foo :: GADTTest |]
15:45:20 <mmorrow> unfortunately TH doesn't do GADTs
15:45:23 <Myoma> aw
15:45:30 <Myoma> why didn't I get an error though
15:45:32 <mmorrow> i dunno where the ouput of that went though
15:45:34 <mmorrow> yeah
15:45:35 <mmorrow> hmm
15:45:38 <Myoma> ♪ "9 trillian"
15:45:39 <lunabot>  "9 trillian"
15:45:46 <Myoma> ♬ "and 3 pounds only"
15:45:55 <Myoma> I guess ♬ is unsupported
15:46:02 <DrSyzygy> o.O
15:46:08 <Myoma> a critical ommision!
15:46:20 <DrSyzygy> Myoma: Where you typing note characters just then?
15:46:29 <Myoma> yes :)))
15:46:34 <mmorrow> Myoma: oh, i chopped it off on account of how i shorten the error msgs ...
15:46:39 <mmorrow> Illegal generalised algebraic data declaration for `:THFake.GADTTest'
15:47:37 <mmorrow> Myoma: oh, it's ♫
15:50:05 <mmorrow> . $(lift =<< reify ''Int)
15:50:06 <lunabot>  TyConI (DataD [] GHC.Types.Int [] [NormalC GHC.Types.I# [(NotStrict,...
15:50:18 <mmorrow> . ''[]
15:50:18 <lunabot>  GHC.Types.[]
15:50:20 <mmorrow> . '[]
15:50:21 <lunabot>  GHC.Types.[]
15:50:24 <chrisdone> Cale: if I add a lojban plugin to lambdabot, could you have lambdabot join #lojbot so that lojbanists can use it >_>?
15:50:39 <Cale> chrisdone: yes
15:50:49 <Myoma> ♬ $([| \x -> x |]) ()
15:50:52 <idnar> what would a lojban plugin doo?
15:50:53 <idnar> *do
15:50:58 <Myoma> :(
15:51:03 <Myoma> ♪ $([| \x -> x |]) ()
15:51:04 <lunabot>  ()
15:51:11 <Myoma> great now I have to learn TH too!
15:51:23 <chrisdone> Cale: okay =)
15:51:38 <mmorrow> Myoma: yes!
15:52:18 <chrisdone> idnar: useful lojban things
15:52:19 <mmorrow> . $(newName >>= \x -> lamE [varP x] (varE x)) ()
15:52:20 <lunabot>      Couldn't match expected type `Q a'
15:52:27 <idnar> chrisdone: ah, of course ;)
15:52:28 <mmorrow> . $(newName "x" >>= \x -> lamE [varP x] (varE x)) ()
15:52:29 <lunabot>  ()
15:52:50 <mmorrow> . newName "x" >>= \x -> lamE [varP x] (varE x)
15:52:50 <lunabot>  LamE [VarP x_0] (VarE x_0)
15:53:18 <mmorrow> (usually there isn't an instance of show for ExpQ, but i added on to the bot...)
15:53:26 <mmorrow> s/on/one/
15:53:51 <mmorrow> . let x = mkName "x" in LamE [VarP x] (VarE x)
15:53:52 <lunabot>  LamE [VarP x] (VarE x)
15:54:33 <mmorrow> . pprint $(lift =<< reify ''Int)
15:54:33 <lunabot>  "data GHC.Types.Int = GHC.Types.I# GHC.Prim.Int#"
15:54:56 <mmorrow> . pprint . cleanNames $ $(lift =<< reify '')
15:54:57 <lunabot>   parse error on input `)'
15:55:10 <mmorrow> . (pprint . cleanNames) $(lift =<< reify '')
15:55:10 <lunabot>   parse error on input `)'
15:55:14 <mmorrow> oh
15:55:17 <mmorrow> . pprint . cleanNames $ $(lift =<< reify ''Int)
15:55:18 <lunabot>  "data Int = I# Int#"
15:55:36 <Myoma> mmorrow: *trying to not demand you add tonnes of features to lunabot* :D
15:55:55 <mmorrow> Myoma: what do you have in mind?
15:56:01 <mmorrow> are view patterns on?
15:56:03 <Myoma> moonpaste announcment would be cool
15:56:20 <mmorrow> oh, yeah i've gotta get the bot that comes with hpaste2 working...
15:56:28 <Myoma> ♪ let viewPatternsDon'tWork (reverse -> (x:_)) = x in viewPatternsDon'tWork "yet!"
15:56:29 <lunabot>      Illegal view pattern:  (reverse -> (x : _))
15:56:37 <mmorrow> i guess i could add that to lunabot somehow though
15:56:53 <mmorrow> ok, i'll turn them on..
15:57:37 <hackage> Uploaded to hackage: terminfo 0.2.2
16:03:21 <mmorrow> . let viewPatternsDon'tWork (reverse -> (x:_)) = x in viewPatternsDon'tWork "yet!"
16:03:22 <lunabot>  '!'
16:03:26 <Myoma> excellent!
16:03:30 <mmorrow> :)
16:03:39 <Myoma> :O
16:03:46 <Myoma> You did that without restarting the bot!
16:03:52 <mmorrow> another upside to having the evaluator in a separate prog than the bot :)
16:06:14 <Myoma> ♪ let halve list = splitAt (length list `div` 2) list  ; merge [] ys = ys ; merge xs [] = xs ; merge (x:xs) (y:ys) = if x < y then x : merge xs (y:ys) else y : merge (x:xs) ys in 1 : [2,4..] `merge` [3,6..] `merge` [5,10..]
16:06:15 <lunabot>  [1,2,3,4,5,6,6,8,9,10,10,12,12,14,15,15,16,18,18,20,20,21,22,24,24,2...
16:07:46 <EvilTerran> .bot
16:07:56 <EvilTerran> how do you use this one, then?
16:11:05 <mmorrow> battery died
16:18:03 <barfbag> heh
16:21:51 <plutonas> i have a strange problem i have a function with 4 arguments, and have one line where i define it, and then another line below like "function name _ _ _ _ = Nothing". The function works fine, but i get a warning that pattern matches are overlapped. Is this normal? (i prefer not to paste my function, as it's the solution to my homework, for the case the channel gets logged)
16:23:46 <TomMD> plutonas: The channel is always logged.
16:24:19 <plutonas> TomMD: thats why i don't want to paste any solution, it would be googable, and my professor wouldn't be happy
16:24:33 <byorgey> plutonas: it's probably fine, but it may mean that that second line can never actually be reached.
16:24:34 <Mitar> is it possible to set handles so that putStrLn would print to stderr by default?
16:24:36 <TomMD> As for overlapped pattern matches, this is normal when two patterns both would match the same input sets.
16:25:05 <plutonas> so the first line also matches everything?
16:25:06 <TomMD> plutonas: for example -  func _ = expr      vs    func x = expr    overlap each other
16:25:08 <byorgey> plutonas: for example, if the first line is something like "function name a b c d = ..." where a,b,c,d are all variable names (not more complicated patterns), then it would match on every input
16:25:24 <mrd> you aren't actually putting "function" in front right?
16:25:51 <plutonas> mrd: i mean the name of it
16:25:54 <TomMD> plutonas: Also, GHC should spit an error at you if you have one declaration with 4 arguments and one with five.
16:26:13 <TomMD> If it isn't, then you probably have a typo in your function name or something else odd going on.
16:26:14 <mrd> f x = undefined; f _ = undefined -- overlapping
16:26:18 <dino-> Mitar: There is System.IO.hPutStrLn and handles for common things like stderr in that module.
16:26:38 <plutonas> no it's 4 and 4, probably the first case would match everything, but i also have a type definition on top which makes me skeptical... have to think a bit on it
16:27:15 <TomMD> What uni is this?  I'm always curious when students have Haskell homework ;-)
16:27:27 <plutonas> TomMD: functional programming course
16:27:30 <plutonas> lund university
16:27:57 <TomMD> And it is never in the states.  So sad.
16:28:36 <Mitar> switching filehandles around is possible?
16:31:08 <ddarius> > 1.6 * 1260
16:31:10 <lambdabot>   2016.0
16:32:07 <dancor> ghci can't load my -isrc Main  because it does import Paths_myproject
16:32:15 <dancor> what is the correct way to have my cabal and eat it too
16:35:47 <Saizan> dancor: you can find the Paths_myproject.hs unded dist/build/autogen
16:38:37 <bjrn> speaking of cabal. My cabal file contains one library and one program. How do I tell cabal to link the program with the library, without installing the library first? Thing is the library is partially written in C, so if I just set hs-source-dirs (for the program) to point to where the library source is the linker will complain because it doesn't know about the C-files.
16:39:03 <bjrn> and of course, the program using the library should not know about the C source :)
16:39:20 <bjrn> So there is a hacky solution, but I want to avoid that one
16:39:34 <byorgey> bjrn: sadly, this cannot be done currently.
16:39:52 <byorgey> unless it is already in a development version of Cabal.
16:39:59 <byorgey> but I know it is something that has been talked about.
16:39:59 <Saizan> bjrn: put the program in another .cabal?
16:40:19 <bjrn> byorgey: Ah, shame.
16:40:24 <byorgey> the hacky solution, which you probably already know, is to set it up so the library gets compiled twice
16:40:29 <byorgey> for example, xmonad does this
16:40:37 <byorgey> definitely annoying though.
16:40:39 <bjrn> Ah yes, that's the hacky solution I use right now
16:41:11 <bjrn> Saizan: That requires installing the library first right?
16:41:43 <Saizan> bjrn: yes
16:42:16 <thoughtpolice> lots of packages actually have to do that
16:42:29 <bjrn> Would linking directly with the compiled library in dist/build be considered inappropriate? :)
16:42:33 <thoughtpolice> yi does it as well - you compile 90 modules, then another 90 to actually build the executable
16:45:05 <LunarCrisis> is it considered bad practice to have non-exhaustive patterns? For example, if I'm writing factorial :: Integer -> Integer, is it considered OK to only have cases for 0 and positive?
16:45:26 <Myoma> LunarCrisis: it's fine
16:45:33 <bjrn> But wall will complain.
16:45:42 <bjrn> eh, -Wall
16:46:01 <LunarCrisis> hmm, ok
16:46:04 <LunarCrisis> thanks for the info
16:46:59 <ddarius> Just extend to a modified gamma function
16:47:17 <Botje> LunarCrisis: smack people who feed wrong input to your function ;)
16:48:35 <byorgey> bjrn: that's considered inappropriate since the user can pass a --builddir option to cabal to have it use a directory other than dist/ .
16:48:52 <EvilTerran> LunarCrisis, it's considered better by some to write something like: factorial _ | n < 0 = error $ "(factorial " ++ show n ++ ") is undefined"
16:49:10 <EvilTerran> er, "factorial n | ..."
16:49:20 <LunarCrisis> I see
16:49:45 <byorgey> LunarCrisis: it will still be a partial function, but at least you will get a better error message than "pattern match failure" =)
16:49:49 <lament> > 1 / 0
16:49:50 <EvilTerran> or some such appropriate description of by you threw an error
16:49:50 <lambdabot>   Infinity
16:49:55 <EvilTerran> *why
16:50:06 <lament> > 1.234 / 0.0
16:50:07 <lambdabot>   Infinity
16:50:14 <EvilTerran> > 1 `div` 0
16:50:15 <lambdabot>   mueval: Prelude.read: no parse
16:50:15 <lambdabot>  mueval: *** Exception: divide by zero
16:50:17 <lament> oh
16:50:24 <byorgey> the real problem is that factorial should have type Nat -> Nat, but there is no Nat type in Haskell =(
16:50:44 <byorgey> well, not built-in at least
16:50:46 <Myoma> ♪ [d| data N = Z | S N |]
16:50:50 <lunabot>  DataD [] N [] [NormalC Z [],NormalC S [(NotStrict,ConT N)]] []
16:51:03 <EvilTerran> ... what's that funny symbol at the start?
16:51:04 <lunabot>   parse error on input `..'
16:51:24 <EvilTerran> ...?
16:51:25 <lunabot>   parse error on input `..?'
16:51:34 <byorgey> . 3
16:51:34 <lunabot>  3
16:51:44 <lament> . . .
16:51:44 <lunabot>   parse error on input `.'
16:51:53 <EvilTerran> so . is ?run
16:52:05 <LunarCrisis> byorgey, well, there will still be problems, you'd just have to have slightly more obscure functions before you get them =p
16:52:23 <byorgey> hehe
16:52:43 <ddarius> fact :: C -> C
16:52:58 <LunarCrisis> like, you might have a function which takes only prime numbers. . .
16:53:43 <Myoma> LunarCrisis: or a function that might loop
16:54:25 <LunarCrisis> Myoma, I don't follow
16:54:36 <BMeph> Is there an ML variant that has value-indexed types?
16:54:56 <Myoma> BMeph: Coq and DML and ATS
16:55:19 <BMeph> Myoma: Hm...thank you. :)
16:55:32 <dancor> Saizan: of course!  nice
16:55:50 <moonlite> DML = Dependently typed ML ?
16:55:58 <Myoma> ?go DML
16:56:01 <lambdabot> http://en.wikipedia.org/wiki/DML
16:56:01 <lambdabot> Title: DML - Wikipedia, the free encyclopedia
16:56:22 <LunarCrisis> love that helpful title
16:56:28 <moonlite> Myoma: nothing interesting there
16:57:37 <hackage> Uploaded to hackage: Vec 0.9.2
16:59:41 <mmorrow> . [t| forall a b. ((a -> b) -> a) -> a |]
16:59:41 <lunabot>  ForallT [a_0,b_1] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (AppT (Ap...
17:00:04 <mmorrow> > [0..]
17:00:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:02:53 <mmorrow> . [t| forall a b. ((a -> b) -> a) -> a |]
17:02:53 <lunabot>  ForallT [a_0,b_1] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (AppT (AppT Arrow...
17:03:22 <Myoma> ♪ [$rx|.*|]
17:03:22 <lunabot>   Not in scope: `rx'<interactive>:1:51:
17:03:26 <Myoma> aw
17:03:33 <mmorrow> ooh, i should add that!
17:03:42 <Myoma> *nod*
17:04:19 <mmorrow> oh snap, i should add all my quasiquoters..
17:04:39 <chrisdone> does lambdabot need telling that it can respond to ?foo and/or @bar commands in channels? I'm running it in my own channel and it's completely ignoring me, but works in privmsg
17:04:43 <mmorrow> regex, javascript, c, haskell
17:04:58 <Saizan> anyone implemented some sort of module system for an EDSL?
17:05:49 <mmorrow> Saizan: i've thought about that before. didn't implement anything, but was mostly thinking of ways to just piggyback on haskell's modsys
17:06:31 <thoughtpolice> @seen ndm
17:06:32 <lambdabot> I haven't seen ndm.
17:06:35 <mmorrow> but i guess the practicality of that depends on what the edsl is like
17:07:47 <chrisdone> @slap chrisdone
17:07:47 * lambdabot hits chrisdone with an assortment of kitchen utensils
17:08:31 <dmwit> ?slap
17:08:31 * lambdabot locks up  in a Monad
17:08:31 <Saizan> mmorrow: any interesting ideas to share?:)
17:08:34 <dmwit> ?slap me
17:08:34 * lambdabot pokes dmwit in the eye
17:08:50 <mmorrow> Saizan: heh
17:09:13 <EvilTerran> chrisdone, does it have/need voice in that channel or something?
17:09:26 <Saizan> i mostly have to collect some auxiliary information about the defined "symbols"
17:09:31 <chrisdone> EvilTerran: good idea, I'll try that
17:09:45 <lispy> chrisdone: I run a very old lambdabot in a different channel and I've never needed to do any weird configging
17:09:54 <mmorrow> Saizan: mostly i was thinking about genrating/using the module-related pieces of the haskell-src-exts AST to give me some structure
17:10:19 <lispy> mmorrow: er, you want to quasiquote haskell in haskell?  What would that let you do?
17:10:28 <mmorrow> then i figured, if i'd be using that already, why not just prettyprint that to code, and have ghc work out the detauls
17:11:18 <mmorrow> lispy: the haskell one i have now is essentiall the identity function on hs src (the translation from haskell-src-exts to TH ast isn't quite finished yet, but mostly)
17:11:23 <mmorrow> the interesting thing though..
17:11:35 <Saizan> couldn't you just use TH for that?
17:11:39 <mmorrow> is non-identity hs qqs
17:11:52 <mmorrow> so imagine a function
17:12:15 <mmorrow> mkHsQQ :: (Exp -> Exp) -> QuasiQuoter
17:12:41 <mmorrow> then suppose you make a QQ with the function..
17:13:21 <mmorrow> i cna't think of anything
17:13:33 <mmorrow> but imagine some src translation
17:13:41 <mmorrow> then you can do
17:14:09 <mmorrow> ok, say if left everything alone, but mapped (\x -> x) to (\x -> (x,x))
17:14:17 <lispy> mmorrow: could you use it to add kind polymorphism?
17:14:21 <mmorrow> then,  [$hs|\x -> x|] 10  == (10,10)
17:14:52 <mmorrow> you could do anything whatsoever assuming you can express it in a src-to-src transformation
17:15:15 <chrisdone> EvilTerran: giving voice didn't work :(
17:15:16 <mmorrow> the [$hs||] bypasses a level of quoting/whatever that TH has
17:15:28 <mmorrow> [$hs|\x -> x|] === \x -> x
17:15:33 <lispy> Well, Haskell currently lacks kind polymorphism...and I don't understand these src-to-src QQ so i'm still not sure :)
17:15:36 <mmorrow> . [|\x -> x|]
17:15:37 <lunabot>  LamE [VarP x_0] (VarE x_0)
17:15:44 <EvilTerran> mmorrow, i think it'd be src -> Q src
17:15:52 <Myoma> lispy, what would you be able to do with kind polymorphism? it sounds scary
17:16:01 <mmorrow> EvilTerran: it could be either
17:16:27 <mmorrow> EvilTerran: Q src would be nice if you wanted to gen fresh vars/etc ...
17:16:59 <mmorrow> . $([|\x -> x|]) 10
17:16:59 <lunabot>  10
17:17:18 <lispy> Myoma: Well, I think for the type checker it would be scary.  Might lead to undecidable type checking if it's fully general.  But, ad-hoc kind polymorphism is probably okay.  It would allow for more clever applications of GADTs...This paper, "Typing Dynamic Typing" even agrees with me that it would be useful and has type equality applications
17:17:19 <Olathe> @src ([|)
17:17:20 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:17:30 <Olathe> @src (|)
17:17:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:17:48 <Myoma> ok will look for that
17:17:51 <mmorrow> Olathe: are you looking for [|...|]?
17:17:55 <Olathe> Yes.
17:17:58 <mmorrow> it's syntax
17:18:00 <Olathe> > $([|\x -> x|]) 10
17:18:01 <lambdabot>   mueval: Prelude.read: no parse
17:18:03 <Olathe> Ahh.
17:18:06 <mmorrow> template-haskell
17:18:12 <mmorrow> . $([|\x -> x|]) 10
17:18:12 <lunabot>  10
17:18:13 <Olathe> Oh, OK.
17:18:37 <jberryman> is there a function on Maps I missed that works like lookup, returning a Maybe a?
17:18:41 <EvilTerran> > [|\x -> x|]
17:18:41 <lambdabot>   mueval: Prelude.read: no parse
17:18:43 <chrisdone> cake: ping
17:18:45 <chrisdone> er
17:18:46 <EvilTerran> . [|\x -> x|]
17:18:47 <lunabot>  LamE [VarP x_0] (VarE x_0)
17:18:48 <chrisdone> cale: ping
17:19:11 <lispy> Myoma: and Tim Sheard has papers about omega (which is like Haskell but adds GADTs and extensible kinds) to implement dependent typing
17:19:40 <Saizan> jberryman: Data.Map.lookup returns a Maybe a if ask that return type
17:19:50 <Saizan> +you
17:20:54 <lispy> and more over, it seems that several people have played with a GADTs and come to the conclusion that Haskell's kind system is limiting :)
17:21:36 * Myoma has not thought that
17:22:51 <Cale> chrisdone: hi
17:23:42 <jberryman> Saizan: thanks, I guess I missed that somehow...
17:24:17 <chrisdone> Cale: hey, is there something specific I need to tell lambdabot to get it to respond to ?foo and @bar commands in channels? I'm running it and it responds in pm, but not in #lojbot
17:24:51 <Cale> chrisdone: I'm not sure... I'd imagine if you copy the scheme of other plugins, it ought to answer :/
17:25:22 <chrisdone> Cale: I'm talking about *any* plugin. @help, or @seen, for example, it will not respond to
17:25:30 <Cale> oh
17:25:37 <Cale> Well, that's certainly strange.
17:25:54 <Cale> You shouldn't have to do anything special...
17:26:13 <Cale> Especially strange that it's not the other way around.
17:26:36 <Cale> If it was responding in channels but not in PM, I would guess that it wasn't being registered with nickserv.
17:27:15 <chrisdone> Cale: here is my online.rc http://hpaste.org/10413 missing anything?
17:27:47 <Cale> apart from messaging nickserv with a password, it looks fine to me
17:28:21 <chrisdone> Cale: do you think it needs to have recieved a nickserv "logged in" message, to respond to channels?
17:28:35 <chrisdone> I'll try it..
17:28:39 <Cale> Maybe to some channels?
17:29:58 <_MaK_> the happs aplication must run by root?
17:30:54 <newsham> thats probably only if you want port 80
17:32:14 <_MaK_> i want 82, but higher port solve the problem, thx ;]
17:32:35 <newsham> yes, you need to be > 1023
17:32:54 <newsham> its what keeps unix extremely secure ;-)
17:34:28 <mmorrow> . [$rx|.*|]
17:34:29 <lunabot>      A section must be enclosed in parentheses
17:34:55 <mmorrow> gah, for some reason the evaluator is having trouble with qqs..
17:35:17 <mmorrow> i can't figure out where it thinks there's a section
17:35:30 <EvilTerran> > [$]
17:35:31 <lambdabot>   mueval: Prelude.read: no parse
17:35:33 <EvilTerran> . [$]
17:35:34 <lunabot>   parse error on input `]'
17:35:36 <EvilTerran> hm
17:35:42 <mmorrow> . rx
17:35:43 <lunabot>      No instance for (Show Language.Haskell.TH.Quote.QuasiQuoter)
17:35:44 <Olathe> . [|$|]
17:35:45 <lunabot>   parse error on input `$|'
17:35:46 <EvilTerran> . [$|True]
17:35:47 <lunabot>   Not in scope: `$|'<interactive>:1:52:
17:35:57 <mmorrow> the syntx is:
17:36:00 <EvilTerran> . [$pi|True]
17:36:01 <lunabot>      lexical error in string/character literal at end of input
17:36:16 <EvilTerran> i'd've expected that to cause the same error
17:36:26 <mmorrow> [$<name-of-quasiquoter>|..arbitrary syntax which qq understands...|]
17:36:28 <EvilTerran> . [$rx||]
17:36:29 <lunabot>      A section must be enclosed in parentheses
17:36:31 <EvilTerran> mmorrow, i know
17:36:35 <mmorrow> oh
17:36:57 <mmorrow> i think it's conflicting with another extension i have enabled
17:37:03 <EvilTerran> as i said, i was trying to get the same error without using something that's actully valid
17:37:07 <mmorrow> :)
17:39:58 <mmorrow> ah, i just found of where it's happening..fixing it now
17:40:38 <mmorrow> (it's in the th-ast code which rx splices)
17:40:53 * Cale wonders if there's a monoid with elements P and N such that P somehow encodes the polynomial time problems and NP somehow encodes the nondeterministic polynomial time problems.
17:42:10 <dmwit> What if there were?
17:42:13 <electronx> just wandering anyone here use ocaml?
17:42:31 <Cale> dmwit: Well, you'd have a funny interpretation of P = NP ;)
17:42:54 <dmwit> =)
17:42:56 <dolio> N is the identity element, clearly.
17:43:02 <Cale> hehe
17:44:47 <Cale> Somehow I doubt this monoid will have cancellation, whatever it is :)
17:45:58 <Cale> electronx: I don't use it much, but I've read programs written in it.
17:46:25 <EvilTerran> i've done a bit
17:46:46 <EvilTerran> some of our lab projects were in caml
17:47:04 <EvilTerran> odd, considering they taught us haskell and no ml
17:48:50 <mmorrow> . maybe [] tail $ [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
17:48:51 <lunabot>  ["-","3","141592653589793"]
17:48:59 <electronx> so i trying to decide what to use
17:49:06 <mmorrow> . [$rx|.*|]
17:49:07 <lunabot>      No instance for (Show (String -> Maybe [String]))
17:49:10 <electronx> ocaml or haskell
17:49:32 <electronx> on one hand haskell larger community (better to) and active development
17:49:58 <electronx> on the other hand ocaml is faster and bit easier to lear netc
17:50:00 <Olathe> electronx: Use it for what ?
17:50:12 <electronx> text catergorisation
17:50:19 <electronx> small search engine
17:50:21 <Olathe> Ahh.
17:50:41 <electronx> categorisation*
17:50:50 <Olathe> Haven't really worked with that.
17:51:01 <dolio> @quote is.composed
17:51:02 <lambdabot> <jdh30> says: The problem is that the Haskell community is composed entirely of academics who have absolutely no idea what industry needs.
17:51:06 <mmorrow> . [$rx|([0-9]+)|] "127.0.0.1"
17:51:06 <lunabot>  Just ["127","127"]
17:51:27 <electronx> could be ture
17:51:30 <Olathe> What are Ocaml people made up of ?
17:51:32 <electronx> true*
17:51:48 <dolio> People who write all kinds of Real Applications.
17:51:50 <Olathe> Ahh.
17:52:12 <electronx> dolio on the other hand haskell people are smarter
17:52:44 <mmorrow> notice the capitals of "Real Applications"
17:52:55 <Olathe> Yes.
17:52:55 <dolio> (TM)
17:53:00 <Olathe> They're nice capitals.
17:53:43 <electronx> The developers of OCaml at INRIA in France, led by Xavier Leroy, have long since given up on developing their own concurrent GC for OCaml, famously stating in 2002 that developing their own concurrent GC was "Too complex" and "too hard to debug".
17:54:11 <mmorrow> haskell's is parallel, but not concurrent
17:54:31 <electronx> 6.10 is gonna have it
17:54:42 <dumbterm> Is it possible to target the .NET runtime with ghc.\
17:54:43 <dumbterm> ?
17:54:51 <electronx> no
17:55:05 <Cale> Note that O'Caml's speed advantage is mainly based on the fact that they spent a long time working on their native code generator. GHC just finally got some smart guys to work on the native codegen, so we should see it catching up soon :)
17:55:07 <dolio> That's why F# is now jdh's official language that will save everyone.
17:55:14 <shapr> hah
17:55:23 <dolio> (Concurrent gc, that is. I think, at least.)
17:55:35 <Olathe> http://php.cin.ufpe.br/~haskell/haskelldotnet/
17:55:36 <Olathe> Heheh
17:55:40 <lambdabot> Title: The Haskell.NET Project
17:55:41 <dolio> That and he just published a book on it. I'm sure that's a coincidence, though. :)
17:55:44 <Olathe> Last news: in 2003, we got a website !
17:55:51 <Cale> dumbterm: There was some work in that direction, but it's one of those things which requires a lot of effort and is not very rewarding for researchers to do.
17:55:52 <electronx> Cale: i think haskell is always going to be more difficult to find tune
17:55:58 <shapr> tune?
17:56:00 <electronx> fine*
17:56:02 <shapr> oh
17:56:03 <dumbterm> Olathe: schweet!
17:56:05 <shapr> electronx: Why?
17:56:12 <Olathe> Well, not really.
17:56:20 <Olathe> That project appears dead for the past five years.
17:56:22 <dbelange> Hello, I'm doing a project on Haskell and I'm wondering what popular games and enterprise software are written in Haskell?
17:56:28 <electronx> shapr: much more complex
17:56:29 <Cale> electronx: I don't know about that. Haskell gives the compiler a lot of freedoms with respect to how it might optimise things.
17:56:38 <dolio> YHC had a .net backend, didn't it?
17:56:45 <dumbterm> dbelange: how do you define enterprise software?
17:56:46 <Olathe> http://www.dotnetpowered.com/languages.aspx
17:56:47 <shapr> electronx: Can you give me some examples?
17:56:51 <lambdabot> Title: dotnetpowered Language List
17:56:56 <Olathe> That has a few Haskell things on it.
17:56:58 <dumbterm> fortune 500? or like Bob's house o' fridge repair?
17:57:10 <electronx> shapr: no but generally ocaml is quit a bit faster then ghc
17:57:22 <shapr> electronx: That's not very specific.
17:57:36 <shapr> I was hoping for some details.
17:57:37 <dbelange> dumbterm: Something like Photoshop, say.
17:57:37 <Cale> electronx: The only difficulty that Haskell has is that lazy evaluation is newer and less-well-studied with respect to how to optimise into efficient code.
17:57:50 <dumbterm> dbelange: tricky
17:58:09 <electronx> Cale: i agree
17:58:10 <Olathe> Looks like two of them stalled and one of them doesn't even show up on its website.
17:58:53 <Cale> dbelange: There are a few companies which are doing financial software in Haskell.
17:59:07 <electronx> Cale: its hard to programme with peformance in mind with lazy evaluation
17:59:16 <electronx> my opinion
17:59:19 <Cale> dbelange: and another doing security applications
17:59:25 <dmwit> dbelange: GHC, darcs, xmonad, Pugs, lambdabot, to name a few
17:59:36 <shapr> electronx: Do you think it's easier to program with strict eval in mind?
17:59:38 <dbelange> dmwit: I've never heard of those.
17:59:45 <electronx> shapr: yeah
17:59:49 <dbelange> Except darcs, which no one uses.
17:59:52 <dmwit> dbelange: Your loss. =P
17:59:54 <shapr> dbelange: Huh, I use it.
17:59:59 <shapr> Are you calling me no one?
18:00:05 * shapr sniffles piteously
18:00:13 <Olathe> dbelange: If you're looking for famous software, the whole of Windows is written in Haskell.
18:00:14 <dmwit> dbelange: Hackage can probably suggest about 150 other applications/libraries built in Haskell.
18:00:35 <Pseudonym> Olathe is lying.  Windows is written in F#.
18:00:40 <Cale> ;)
18:00:40 <shapr> electronx: I don't think there's any difference in difficulty between strict and lazy eval. I think strict has been used more, so there's more 'common knowledge' floating around.
18:00:49 <dmwit> F# is just a dialect of Haskell, anyway. ;-)
18:01:15 <dbelange> How about video games?
18:01:28 <Pseudonym> dbelange: Seriously, probably no software that you've heard of is written in Haskell.
18:01:29 <shapr> There was a quake clone written in Haskell.
18:01:32 <dbelange> Who's taking advantage of haskell's speed for, say, 3d graphics?
18:01:39 <electronx> shapr: some problems are very ineficient to solve with lazy eval
18:01:49 <Pseudonym> However, many programming languages that you have heard of have inherited or are inheriting features from Haskell.
18:01:52 <sebaseba> since the subject is up, how would a programmer who's used to strict evaluation go learning how to design programs with lazy evaluation in mind?
18:01:55 <Olathe> I don't think Haskell compilers can do much with the graphics cards.
18:01:56 <Pseudonym> Including Python, Java, C++ etc.
18:02:02 <shapr> electronx: Some problems are inefficient with strict eval.
18:02:02 <Cale> dbelange: There is a q3a clone which someone whipped up in a few weeks as a proof of concept.
18:02:04 <Olathe> Especially the new shader stuff and so on.
18:02:12 <Olathe> So, no one really uses Haskell for that.
18:02:25 <dmwit> dbelange: You might like http://www.haskell.org/haskellwiki/Applications .
18:02:27 <lambdabot> Title: Haskell in practice - HaskellWiki
18:02:34 <Olathe> I'm sure you could probably make something to do that, though.
18:02:42 <electronx> shapr: more commen it is lazy eval that causes problems
18:02:42 <shapr> haha
18:02:50 <Cale> sebaseba: I find that it's helpful to lazily evaluate some expressions by hand to get a feel for how lazy evaluation works.
18:02:53 <shapr> electronx: How do you quantify that?
18:02:54 <Olathe> He was a horrid troll ;)
18:02:59 <Cale> electronx: I totally disagree.
18:02:59 <shapr> Yeah, he's no good as a troll.
18:03:12 <Pseudonym> Not even good enough to trip Poe's Law.
18:03:19 <shapr> What's Poe's Law?
18:03:22 <electronx> i can't think of many situations that benefit from lazy eval
18:03:30 <shapr> What about the same fringe problem?
18:03:42 <Cale> electronx: You can break data down into two classifications, depending on how many separately-evaluable components it has.
18:03:43 <shapr> Or what about traversing multidimensional 'streams' ?
18:04:01 <shapr> Or how about infinite data structures?
18:04:03 <Cale> electronx: I'll call a piece of data 'small' if it has few parts which could be evaluated separately, and 'large' if it has many.
18:04:14 <dumbterm> shapr: I was doing okay on #C, #C++, and #Java.
18:04:21 <shapr> dumbterm: trolling?
18:04:37 <Olathe> Pirating.
18:04:38 <Cale> electronx: Then you can break functions down into classes based on what types of data they consume and produce.
18:04:46 <shapr> So, dumbterm was the same guy as dbelange?
18:04:54 <electronx> shapr: i have never faced a programming problem where lazy eval would have benefited me
18:04:55 <Pseudonym> @go site:rationalwiki.com poe's law
18:04:59 <Olathe> Hmm, same computer club.
18:05:02 <shapr> electronx: I don't believe you.
18:05:06 <Olathe> Up at Waterloo.
18:05:08 <lambdabot> http://rationalwiki.com/wiki/Poe's_Law
18:05:08 <lambdabot> Title: Poe's Law - RationalWiki
18:05:20 <shapr> electronx: I would call that the Blub Paradox.
18:05:24 <Cale> electronx: Then you are not imaginative enough in breaking down problems.
18:05:25 <electronx> lol
18:05:32 <electronx> Cale: maybe
18:05:40 <shapr> electronx: I have one example... do you use if statements?
18:05:42 <electronx> Cale: to much C++?
18:05:52 <electronx> shapr: yes
18:05:53 <Cale> electronx: Lazy evaluation gives you new ways to break down problems which are not available under strict evaluation.
18:06:07 <shapr> In a 'purely strict' programming language, wouldn't both branches of an if statement be executed?
18:06:12 <Cale> (because they would be too costly)
18:06:13 <Pseudonym> electronx: Have you ever done a "program inversion"?
18:06:32 <electronx> no
18:06:37 <electronx> have no idea what that is
18:06:40 * Pseudonym might be the only one old enough to remember that term
18:06:50 <Olathe> Is that like function inversion ?
18:06:51 <Cale> A nice toy example I like to give is deciding if a string is a substring of another.
18:06:59 <Pseudonym> Olathe: No.
18:07:04 <Olathe> Ahh.
18:07:16 <Cale> Here's an implementation in Haskell of a fairly naive algorithm, but a reasonable one:
18:07:17 <Pseudonym> Imagine a function/procedure/object/whatever which performs a merge on two streams.
18:07:34 <Cale> isSubstringOf x y = any (isPrefixOf x) (tails y)
18:07:41 <Pseudonym> There are many ways to write this in a procedural language.
18:07:50 <Cale> This solution would basically not occur to a strict programmer.
18:07:50 <Pseudonym> The problem is this:
18:08:04 <Pseudonym> To write the code, you need to know what triggers a "merge" step.
18:08:11 <plutonas> what does the type IO (Something -> Something) mean?
18:08:15 <Pseudonym> In C++, for example, you might make an output iterator.
18:08:27 <Pseudonym> So you trigger a step when you request a new element fromt he output stream.
18:08:31 <Cale> Since it looks like it generates all the tails of the string y, and then tests each for whether x is a prefix, which seems wasteful.
18:08:38 <Pseudonym> In other circumstances, one of the inputs might be the trigger.
18:08:50 <Pseudonym> Can you picture that?
18:08:53 <Olathe> plutonas: It means that you have a function corrupted by IO.
18:08:55 <dmwit> plutonas: It means that the value does some IO, then calculates a function.
18:09:05 <Cale> plutonas: A value of that type is an action, which if carried out, would do some IO, before producing a function (Something -> Something)
18:09:08 <electronx> Cale: i see
18:09:08 <Pseudonym> Converting one version into another is purely mechanical, using a technique known as "program inversion".
18:09:09 <Pseudonym> BUT.
18:09:18 <Olathe> plutonas: Like (const 5) can be done with a 5 from input.
18:09:20 <ziman> plutonas, it is an IO action, which, when performed, returns a function
18:09:22 <Pseudonym> In a lazy language, you don't need to rewrite it at all.
18:09:27 <adu> hi
18:09:30 <plutonas> so i should return a function Something-> Something?
18:09:37 <Pseudonym> The same merge operation can be used for all versions.
18:09:40 <Cale> electronx: However, lazy evaluation fixes that, so that you get what would be the usual pair of nested loops with early breakouts.
18:09:47 <plutonas> i guess the IO is because of the use of random
18:09:54 <electronx> Cale: its nice but can't you just write it as an iterator loop anyway
18:10:03 <Pseudonym> The only way you could do that in a procedural language is to a) make a very complex solution, or b) use threads/coroutining.
18:10:28 <Cale> electronx: You can, but you're effectively rewriting tails and adding an extra condition, wasting the fact that it's available in your library.
18:10:50 <Olathe> If I wrote a substring of thing in a strict language, that's how I'd do it.
18:10:56 <Cale> electronx: My point is that there are more reasonable ways to combine library functions which are lazy.
18:11:06 <Pseudonym> Maybe my example is too difficult to envisage.
18:11:06 <Cale> (than ones which are strict)
18:11:09 <Olathe> With a few optimizations, of course.
18:11:18 <Pseudonym> But all Haskell programmers know about this.  Laziness buys you modularity.
18:11:21 <electronx> Cale: i think your maths helps you
18:11:40 <electronx> Cale: C++ has ruined me
18:11:52 <Pseudonym> C++ helped me.
18:11:53 <Cale> It's true, I'm used to thinking of things in terms of specifications, and not how they'll be carried out step by step. :)
18:11:57 <electronx> i started with vb when i was 15
18:12:05 <Pseudonym> And Haskell made my C++ better.
18:12:06 <Cale> But I did my fair share of C++
18:12:15 <Adamant> electronx: I started with Visual Basic. I got better.
18:12:28 <SamB_XP> I never managed to come down with VB ;-)
18:12:43 <electronx> still 7 years of imperative has closed my mind a bit
18:13:00 * SamB_XP tosses electronx some call/ccs to help clean it out
18:13:00 <electronx> maybe if i started with haskell
18:13:08 <electronx> lol
18:13:14 <Adamant> electronx: maybe working with math will help? I know being more mathematically literate has helped me out
18:13:22 <shapr> electronx: You can start doing Haskell, it has a nice website.
18:13:41 <SamB_XP> yes, we can get you set up with a dealer and all ;-P
18:13:47 <electronx> lol
18:13:49 <shapr> The first lambda is free.
18:13:53 <shapr> @quote toke
18:13:53 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
18:13:53 <Cale> I started with QBasic, and later ended up using C, C++, VB, Pascal, Perl, even a bit of PHP, then Scheme and Haskell, with some others mixed in there, and a bunch which I picked up quickly after Haskell (like Ruby and Python)
18:13:57 <shapr> heh
18:14:17 * ojuar throws a lambda web at shapr
18:14:31 * shapr is caught!
18:14:37 <SamB_XP> ojuar: functional spiderman?
18:14:41 <ojuar> Cale: interesting ... similar here
18:14:41 <shapr> ojuar: Why the new name?
18:14:44 * ojuar is araujo
18:14:50 <mmorrow> . listify ((== typeOf (undefined :: HsQName)) . typeOf) `fmap` parseHsExp "\\m f -> m >>= f" :: Either String [HsQName]
18:14:51 <lunabot>  Right [UnQual (HsIdent "m"),UnQual (HsSymbol ">>="),UnQual (HsIdent "f")]
18:14:54 <shapr> ojuar: Yes, but why the reverse missing one letter?
18:14:59 <ojuar> shapr: haha, i am at univ
18:15:00 <SamB_XP> ojuar: is that some kind of reverse pig-latin pun ?
18:15:26 <ojuar> SamB_XP: haha, nah, just me making up other name :-P
18:15:48 <Cale> Oh, I suppose I should probably count Mathematica among the major ones I picked up earlier on.
18:15:54 <Cale> It's pretty functional :)
18:16:01 <ojuar> I am in system engineering class .... trying to not falling sleep
18:16:06 <SamB_XP> in a dys- kind of way, possibly...
18:16:15 <SamB_XP> ojuar: quick!
18:16:19 <SamB_XP> engineer a system
18:16:45 <ojuar> SamB_XP: that's precisely what they are talking about atm
18:16:49 <ojuar> :-P
18:17:05 <SamB_XP> ojuar: yes but it is better to do than to talk about
18:17:31 <electronx> i wonder when will game industy switch to fp
18:17:40 <electronx> industry*
18:17:48 <mmorrow> . (\xs -> let (x,y) = (sum xs,length xs) in x `par` y `pseq` fromIntegral x / fromIntegral y) [0..100000]
18:17:49 <lunabot>  50000.0
18:17:55 <ojuar> SamB_XP: that's the point of system engineering ... just talking
18:17:58 <SamB_XP> well, what did Tim Sweeney say about that again?
18:18:05 <SamB_XP> ojuar: oh.
18:18:14 <SamB_XP> why don't they call the class "Hot Air", then!!!
18:18:18 <electronx> he said 2008/2009 we will have 20 cores
18:18:29 <electronx> not happening
18:18:33 <ojuar> SamB_XP: it is not attractive for companies
18:18:33 <SamB_XP> are they afraid people will think it's actually good for something if they call it that?
18:18:38 <Olathe> Well, we have 8 cores so far.
18:18:49 <Olathe> In a year, maybe 16.
18:18:52 <SamB_XP> you know, since hot air is good for ballooning
18:19:09 <ojuar> likely :-P
18:19:11 <SamB_XP> electronx: he was a bit ahead of himself, so?
18:19:17 <electronx> i don't think the industry will write games in haskell
18:19:27 <SamB_XP> it's happening soon enough -- the cores are coming
18:19:58 <electronx> it will happen just not in haskell i don't think
18:20:11 <Olathe> Perhaps not.
18:20:29 <Olathe> I think Java's trying to become functiony.
18:20:41 * ojuar heading home
18:20:45 <electronx> perhaps something more like ocaml
18:20:46 <SamB_XP> the effectiveness of the present shared-memory system organization is waning
18:22:41 <electronx> most likely it will be a new fp language written by sun or something
18:22:51 <electronx> perhaps not
18:23:05 <electronx> ada never caught on
18:23:07 <dolio> Java's not really becoming functional. It's just adding features that almost every half-way decent language these days has. :)
18:23:19 <Olathe> Ahh.
18:23:39 <Cale> electronx: I think that as the number of cores in processors increases, programmers will have no choice but to use languages with tight control over effects, like Haskell.
18:23:46 <Olathe> I bet it'll screw them up, too, and be lawyerly about it.
18:24:10 <electronx> Cale: i think haskell is to pure for the industry
18:24:15 <Cale> (Because programming parallel computations with lots of effects going on is really hard.)
18:24:20 <Associat0r> what do you guys think of ATS?
18:24:22 <Cale> (Harder than learning Haskell)
18:24:25 <SamB_XP> electronx: what's wrong with pure?
18:24:31 <SamB_XP> the industry can learn to love pure
18:24:33 <dolio> I think you appear to be desperate to discount Haskell. :)
18:24:39 <electronx> no
18:24:47 <mmorrow> the only reason java is so widely in use is because sun bribed univiersities to make it their "language of choice"
18:25:05 <electronx> if haskell was primed and ready we would have seen it more in use
18:25:18 <shapr> electronx: I don't think you're looking very hard ;-)
18:26:07 <electronx> shapr: galanois (don't think thats how ya spell it) is the only people that seem to activly use it
18:26:21 <electronx> no one else really
18:26:25 <Olathe> electronx: OK.
18:26:29 <dolio> Credit Suisse.
18:26:31 * mmorrow sighs
18:26:36 <lispy> er, Galois, as in the French mathematician that invented group theory
18:26:38 <shapr> electronx: What about BlueSpec, or Intel, or Xilinx?
18:26:39 <dolio> Linspire...
18:26:41 <Associat0r> electronx : what do you think of ATS?
18:26:44 <shapr> Yeah, Linspire
18:26:59 <electronx> i havn't seen ATS
18:27:00 <shapr> The BBC used Haskell to prototype their Dirac codec.
18:27:04 <Associat0r> electronx : looks like what sweeney wants
18:27:11 <SamB_XP> mmorrow: can you please tell that to sohail.sheikh@widener.edu ?
18:27:15 <shapr> Yeah, Sweeney uses Haskell for some things.
18:27:20 <electronx> Xilinx: isn't that ocaml?
18:27:23 <SamB_XP> man, his webpage is OLD
18:27:23 <Associat0r> electronx : look at the shootout
18:27:26 <dino-> electronx: There's a list http://haskell.org/haskellwiki/Haskell_in_industry
18:27:27 <lambdabot> Title: Haskell in industry - HaskellWiki
18:27:35 <Associat0r> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
18:27:37 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
18:27:44 <Associat0r> http://www.ats-lang.org/
18:27:45 <lambdabot> Title: Home Page for ATS
18:27:46 * lispy uses Haskell at his day job when the PL is not important to the suits
18:28:10 <shapr> Bug Labs doesn't use Haskell quite so much since seth isn't there anymore.
18:28:13 * shapr sighs
18:28:29 <Twey> Aw :(
18:28:55 <shapr> There are quite a few companies that actively use Haskell that aren't mentioned on that page.
18:28:59 <adu> if you were to choose alternative operators for (.) and ($) what would they be?
18:29:12 <lispy> adu: o and not sure respectively
18:29:27 <electronx> i think if neil finished supero haskell would become more appealing
18:29:48 <electronx> it looked promising
18:29:49 <adu> super-ooh!
18:29:55 <shapr> electronx: I think you're just looking for excuses.
18:29:57 <dmwit> >let not_sure_respectively = ($) in const "too looooong!" `not_sure_respectively` undefined
18:30:02 <electronx> shapr: nope
18:30:04 <Associat0r> electronx : did you see it?
18:30:12 <shapr> electronx: So learn Haskell, and see if you can use it in business.
18:30:26 <shapr> Lead, follow or get out of the way!
18:30:35 <adu> dmwit: lol
18:30:36 <Cale> I think you'll find that for most applications, Haskell's current performance is more than adequate.
18:30:55 <Olathe> electronx: You gave an opinion earlier about Haskell's use in applications, right ?
18:30:55 <electronx> Associat0r: ya first time i heard of it
18:30:58 <Cale> It's probably less than 1% of all applications where you'd really run into problems.
18:30:59 <joe_b> anyone played with language-c?
18:31:15 <Associat0r> electronx:  I wonder why nobody is talking about it
18:31:16 <Cale> (and even then, there are ways around those problems)
18:31:25 <electronx> Olathe: where?
18:31:32 <adu> electronx: http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all
18:31:34 <lambdabot> Title: thread-ring benchmark | Ubuntu : Intel® Q6600® quad-core Computer Language Ben ..., http://tinyurl.com/5vj8bn
18:31:35 <dmwit> FFI FTW!
18:31:36 <Associat0r> electronx:  since it is the first lang that beats C and C++ on teh shootouts
18:31:42 <Olathe> electronx: Well, weren't you saying that Haskell was only used in one company and so on ?
18:31:52 <electronx> Olathe: yes
18:32:03 <Olathe> electronx: And you based that on the evidence you'd seen, right ?
18:32:41 <joe_b> having issues with a cabal install of language-c
18:32:42 <adu> Haskell is used as the primary compiled language in at least 5 major companies
18:32:50 <Associat0r> electronx : and it is ML like and has dependent types
18:33:15 <joe_b> it verifies that all dependencies are present, but language-c itself fails config because lack of a dependency
18:33:20 <joe_b> ideas?
18:33:22 <electronx> Olathe: from the research i did on the net for myself that is the impression i got
18:33:31 <Olathe> electronx: No problem there.
18:33:36 <Associat0r> joe_b : you mean bit-c?
18:33:41 <joe_b> no
18:33:47 <Olathe> electronx: But the people here showed you lots of evidence you missed, right ?
18:34:11 <joe_b> Associat0r: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c
18:34:13 <lambdabot> Title: HackageDB: language-c-0.3.1, http://tinyurl.com/6xtat7
18:34:23 <electronx> Olathe: i wanted to see a working app that i can run on my comp
18:34:37 <Associat0r> joe_b : o yeah the embedded C in haskell
18:34:40 <mmorrow> SamB_XP: heh, what's his webpage url
18:34:44 <Olathe> electronx: Perhaps.
18:34:47 <electronx> Olathe: for all i know those companies use haskell as a scripting lang
18:34:53 <adu> electronx: there are dozens of working apps written in Haskell that you can see on your comp, what's stopping you?
18:34:56 <joe_b> yeah, pretty slick library; better if i could use it :P
18:35:20 <Olathe> electronx: Sure.
18:35:34 <adu> electronx: and are you saying the fact that you can use it as compiled or scripting is somehow a bad thing?
18:35:40 <mmorrow> found it
18:35:41 <electronx> adu: the quake clone was cool
18:35:56 <electronx> adu: no
18:36:15 <electronx> adu: i can use ruby or python for that
18:36:18 <barfbag> bug labs=bell labs? whos seth?
18:36:21 <Olathe> electronx: The thing I noticed is that, when you were given lots of new evidence here, you didn't stop to examine it or comment that you hadn't heard that before or anything like that.
18:36:50 <adu> electronx: right, but neither provide much support for higher-order functions
18:37:09 <electronx> Olathe: i saw them myself when i went to haskell.org
18:37:27 <Olathe> electronx: Ahh, OK.
18:37:37 <electronx> just saying someone is using something is not enough
18:37:46 <lispy> have you guys started patrolling stackoverflow.com for haskell questions?
18:38:04 <Associat0r> adu : they have but dynamicaly typed
18:38:13 <lispy> I'm finding that not many haskell users are using that site yet, which is causing a chicken and egg situation
18:38:14 <Olathe> electronx: Ahh.
18:38:25 <seydar> lispy: what site?
18:38:30 <Olathe> electronx: Not good enough for what ?
18:38:41 <Olathe> electronx: Or not enough for what ?
18:38:45 <electronx> Olathe: examples is what i'm after
18:39:12 <electronx> to convince me that haskell is viable for as a general purpose language
18:39:18 <Olathe> electronx: Ahh.
18:39:27 <lispy> seydar: it's a question/answer site
18:39:36 <lispy> seydar: it _just_ started it's public beta
18:39:46 <lispy> seydar: and I was hoping we could turn it into a haskell friendly website :)
18:39:50 <Olathe> electronx: I'm not sure why that's important.
18:40:22 <lispy> seydar: it's also programming language centric...eg., all the questions are meant to be posed by programmers and related to programming
18:40:33 <electronx> Olathe: i don't want to invest considerable time and effort for something that doesn't look like it will pan out
18:40:42 <lispy> So far there are a measly 15 haskell questions :(
18:40:54 <lispy> seydar: http://stackoverflow.com/questions/tagged/haskell
18:40:55 <lambdabot> Title: Hottest "haskell" Questions - Stack Overflow
18:41:02 <barfbag> heh
18:41:16 <adu> lispy: the same seems to be true of http://www.krugle.com/
18:41:17 <lambdabot> Title: Krugle - Transform Code into Profit.
18:41:29 * lispy checks it out
18:41:31 <Olathe> electronx: Alright, then I'm not sure why you're not with Java or C++.
18:41:39 <Olathe> electronx: Based on your criteria, those fit well.
18:41:45 <electronx> Olathe: that like tellig people yes ruby scales blak blah but not showing examples
18:41:50 <electronx> thats*
18:41:53 <Olathe> electronx: Sure.
18:42:07 <lispy> adu: er, i think krugle is different
18:42:17 <electronx> java and C++ arn't fp ;)
18:42:22 <ddarius> lispy: Start posting ignorant questions.
18:42:25 <Olathe> electronx: Based on what you've said is important, it seems that Java and C++ are great for you (I don't mean that condescendingly).
18:42:28 <Olathe> electronx: Ahh.
18:42:42 <lispy> ddarius: But I don't have much to ask about Java/Python ;)
18:43:00 <thoughtpolice> if haskell doesn't make it into the most mainstream places in the world and it's not the next biggest thing, let's just say I won't lose sleep over it.
18:43:19 <ddarius> lispy: I mean about Haskell.
18:43:33 <thoughtpolice> i think a bigger legacy will lie with the influences haskell makes on other languages
18:43:35 <ddarius> Like "Why is my fib taking so long?  Doesn't Haskell memoize it?"
18:43:40 <Twey> Like Lisp.
18:43:41 <Olathe> electronx: I think Lisp and Scheme have been around a while. If one has examples of apps, it's likely to be them.
18:43:56 <dolio> No functional language is as widespread and successful as C++ and Java, so you might as well not learn any, clearly. :)
18:44:01 <electronx> Olathe: yes lisp does have examples
18:44:06 <Olathe> electronx: Ahh :)
18:44:07 <lispy> thoughtpolice: yeah, concept osmosis
18:44:13 <barfbag> fib?
18:44:24 <ddarius> lispy: Then write an iterative version in Ruby and say how much faster ruby is than Haskell.
18:44:27 <thoughtpolice> lispy: indeed, and that is fine by me. it means we can keep growing haskell FOREVER.
18:44:30 <Olathe> electronx: Do you not like Lisp ?
18:44:36 <electronx> Lisp doesn't seem to be going anywhere either
18:44:41 <barfbag> im caught between leanring lisp and haskell
18:44:47 <barfbag> learning even
18:44:55 <Olathe> electronx: Ahh, you're looking for the C-killer functional language ?
18:45:07 <electronx> Olathe: lol not so much
18:45:11 <lispy> thoughtpolice: Er, will I won't be using haskell forever.  There will be a definite point in the future where something that spawns in the PL research community is WAY better than haskell.
18:45:18 <barfbag> I also am learning tcl because knowing it lets me use aolserver, which is very very fast dynamic webappserver
18:45:37 <barfbag> lispy: what do you do with haskell now?
18:45:38 <electronx> Olathe: something i can invest heavily in and know its future is bright
18:45:46 <Olathe> electronx: Oh, OK.
18:45:50 <mgsloan> and whatever that thing is, probably using haskell a lot greatly helps you in adopting this new language
18:46:00 <thoughtpolice> lispy: sure, just an exaggeration :p - when something with dependent types comes out that is at least as viable as haskell is now I will be all over that.
18:46:17 <adu> mgsloan: what new language?
18:46:19 <lispy> barfbag: aside from hacking on darcs (which uses a lot of Haskell's advanced features) I don't use Haskell a lot at the moment.  But, I use Haskell for all my hobby projects.
18:46:23 <electronx> Olathe: i was going to go ocaml but it clearly is not going anywhere
18:46:39 <mgsloan> adu - the hypothetical one mentioned by lispy
18:46:43 <barfbag> electronx: java i used a lot why dont you use java
18:46:44 <thoughtpolice> lispy: also oleg-amazingness doesn't count :P
18:46:57 <mmorrow> electronx: at the very least, i would choose a language no one company owns
18:46:58 <adu> Oz-mosis?
18:47:02 <electronx> barfbag: i don't like it
18:47:03 <barfbag> is-
18:47:08 <barfbag> electronx: why
18:47:38 <electronx> electronx: because i have tried haskell
18:47:46 <lispy> You can do a lot worse than Java.
18:47:48 <mmorrow> electronx: so that rules out java and anything .net
18:47:56 <lispy> It's just that you can do a lot BETTER too.
18:47:59 <electronx> mmorrow: yes
18:48:14 <Svrog> electronx: once you learn haskell all other fp languages are trivial to pick up
18:48:16 <mgsloan> you can get occasional bursts of functional niceness with linq
18:48:28 <mmorrow> electronx : excellent decision
18:48:36 <thoughtpolice> speaking of dependent types, how goes the cayenne-cabalization mmorrow?
18:48:50 <adu> what is cayenne?
18:48:54 <electronx> mmorrow: currently my site is in ruby
18:48:55 * lispy honestly gets sick of language discussions anymore.  Don't people know the team of devs is more important than the language choice?
18:48:59 <mmorrow> thoughtpolice: i'm actually trying to finish it right now, got distracted with the bot
18:49:10 <thoughtpolice> adu: http://www.cs.chalmers.se/~augustss/cayenne/index.html
18:49:18 <electronx> mmorrow: but some parts need a much faster language
18:49:18 <lambdabot> Title: Cayenne
18:49:24 <mmorrow> thoughtpolice: i'm trying to figure out how to do what i need to do with cabal in a custom Setup.hs
18:49:25 <Olathe> lispy: Yeah, I think you're right.
18:49:26 <SamB_XP> lispy: so a good team of devs can stand to use java?
18:49:35 <mmorrow> thoughtpolice: it's slightly epic ;)
18:49:41 <SamB_XP> ... all good teams, even?
18:49:41 <lunabot>   parse error on input `..'
18:49:45 <Olathe> I think that also applies to languages, too.
18:50:00 <lispy> SamB_XP: yeah.  The same team might do even better with Haskell, but if they are a good team they will do just fine with java
18:50:04 <electronx> mmorrow: maybe erlang?
18:50:07 <mmorrow> electronx: what's your sight?
18:50:13 <SamB_XP> lispy: what if they has ADD
18:50:16 <electronx> stock trading
18:50:27 <lispy> SamB_XP: Then they may need ritalin?
18:50:32 <adu> thoughtpolice: so what is a sum type? is that like an untagged union?
18:50:35 <mmorrow> electronx: hmm, i dunno. erlang isn't typed nor compiled...
18:50:45 <adu> thoughtpolice: is that different than disjoint sum?
18:50:46 <electronx> ok forget that
18:50:52 <dolio> It's compiled.
18:50:58 <SamB_XP> I don't think ritalin is sufficient to make java pallatable ...
18:51:05 <lispy> SamB_XP: programming and enigneering are hard in all languages.
18:51:06 <mmorrow> heh, i was thinking i was wrong about that
18:51:30 <thoughtpolice> adu: "In type theory, a tagged union is called a sum type."
18:51:34 <Olathe> electronx: If you can't find a way to meet your goal of finding a language you can stick with for a long time, why do you want to meet that goal ?
18:51:41 <mmorrow> dolio: how does it do what it does with distributing stuff seemlessly over diff machines?
18:51:48 <Olathe> electronx: Why is sticking with one language for a long time important to you ?
18:51:52 <mmorrow> dolio: massive runtime system or something?
18:51:57 <SamB_XP> mmorrow: bytecode?
18:52:11 <dolio> I don't know, actually. I've never looked at it closely.
18:52:13 <thoughtpolice> adu: (from wikipedia)
18:52:20 <dolio> But it has some kind of compiler at least.
18:52:24 <mmorrow> ahh, ok. so compiled in the sense that it's compiled to bytecode, but not machine code.
18:52:29 <electronx> Olathe: well its not
18:52:47 <Olathe> electronx: Ahh, I'm confused then :)
18:53:05 <adu> thoughtpolice: ok
18:53:06 <thoughtpolice> mmorrow: well yes and no, the hipe system was made stock in erlang a while back so if you set a compile flag, the generated .beam files contain both VM code and actual assembly code (only x86 and sparc work I think?)
18:53:22 <mmorrow> hmm, interesting.
18:53:34 <thoughtpolice> mmorrow: re distribution, there's an erlang daemon that is brought up when things like distributed nodes are turned on that afaik takes care of it all
18:53:45 <thoughtpolice> http://www.erlang.org/docs (i think) has a lot of good stuff over that
18:53:51 <Olathe> electronx: Why not learn Haskell or whatever and use it until something better comes along ? Then, you don't have to worry so much about longevity or popularity.
18:54:02 <barfbag> agda?
18:54:02 <electronx> Olathe: true
18:54:06 <barfbag> cayennee?
18:54:07 <mmorrow> thoughtpolice: does it actually send "code" across the network, or just data?
18:54:12 <barfbag> dependency types!
18:54:30 <adu> I <3 deptypes
18:54:42 <thoughtpolice> mmorrow: not sure
18:54:47 <thoughtpolice> it's been a while since I did erlang
18:54:54 <thoughtpolice> but if you start some nodes and make sure they're available to each other
18:55:06 <thoughtpolice> and you start doing distributed stuff it automatically spans those other machines, so I assume it sends both
18:55:12 * mmorrow makes a note to check out how erlang works
18:55:14 <thoughtpolice> again though I'm not entirely sure
18:55:43 <Associat0r> electronx : you should look into F#
18:55:59 <adu> thoughtpolice: sounds like OZ
18:56:37 <lispy> epigram?
18:56:46 <thoughtpolice> mmorrow: it's a real neat system none the less, most painless distribution mechanisms I've come across :]
18:56:59 <adu> electronx: I think you should go with Perl6
18:57:14 <lispy> Haskell currently fills a nice niche between performance, usability, and open ended contributions from research
18:57:17 <adu> electronx: because the only implementation of Perl6 is written in Haskell :)
18:57:21 <Associat0r> electronx : it  is kinda functional and has a big chance of success if that is your concern
18:57:29 <barfbag> wow
18:57:34 <electronx> Associat0r: F# is windows
18:57:36 <barfbag> I fel dumb in this conversation
18:57:43 <Taggnostr> is perl6 written in haskell?
18:57:48 <adu> barfbag: its ok
18:57:49 <barfbag> maybe I should run back to tcl
18:57:54 <lispy> Taggnostr: yes, at least one implementaiton is
18:57:54 <Associat0r> electronx : mono
18:58:04 <dolio> That's not true anymore, is it? I thought there were some other perl6 implementations catching up to pugs.
18:58:06 <adu> Taggnostr: yes
18:58:08 <lispy> Taggnostr: and larry is fond of it, but he doesn't want it to be the official perl6
18:58:30 <Taggnostr> :O
18:58:48 <adu> lispy: there will never be an official perl6 then, because only Haskell is expressive enough to implement it
18:59:03 <Pseudonym> Perl is also expressive enough.
18:59:09 <Pseudonym> Perl 6, that is.
18:59:18 <Taggnostr> how is perl 6?
18:59:24 <Associat0r> electronx : http://artwild.blogspot.com/2008/08/f-addin-for-monodevelop.html this looks like *nix to me
18:59:26 <lambdabot> Title: Art to be Wild: F# Addin for Monodevelop
18:59:29 <lispy> adu: I find that a hard claim to swallaw.
18:59:32 <lispy> swallow*
19:00:03 <thoughtpolice> there's rakudo
19:00:03 <lispy> Associat0r: is mono really ready for production?  I haven't tried it in years, but I'd consider it with much salt and skepticism
19:00:10 <adu> lispy: then spit it out
19:00:12 <thoughtpolice> they've been making pretty speedy progress there
19:00:20 <thoughtpolice> but unfortunately rakudo is naturally tied pretty heavily to parrot
19:00:24 <thoughtpolice> which is still a moving target
19:00:27 <Associat0r> lispy : wikipedia uses a C#/mono backend
19:00:45 <Associat0r> lispy : so if it is good enough for them
19:00:48 <Associat0r> ...
19:00:49 <lunabot>   parse error on input `..'
19:00:50 <lispy> Associat0r: for what? wikipedia was written in php last time I downloaded a copy :)
19:00:59 <adu> Parrot is still having problems? wow its been like a year since I last checked on it
19:01:06 <thoughtpolice> lispy: your hopes are high if you think that you can just take any .net executable off the net and do 'mono file.exe'
19:01:14 <Associat0r> lispy : some search backend
19:01:18 <thoughtpolice> but the latest release has a C# 3.0 compiler and apparently fully works
19:01:27 <thoughtpolice> adu: no, it's just still in a state of flux
19:01:28 <Associat0r> lispy : let me look it up for you
19:01:32 <thoughtpolice> lots of things change constantly
19:01:37 <thoughtpolice> there are still many things to be implemented
19:02:10 <lispy> thoughtpolice: I don't mean to sound like FUD, but the last time I tried mono it would crash on standard examples from tutorials on just bringing up a basic GUI
19:02:11 <thoughtpolice> so you've basically got a language which is a moving-target targeting a virtual machine which is also a moving-target
19:02:14 <adu> thoughtpolice: I thought the problem was people kept changing the frontend-backend interface, and no-one knew what was "highllevel" and "lowlevel"
19:02:18 <thoughtpolice> but the rakudo guys have been making progress
19:02:44 <dolio> Aren't there several Gnome applications built on mono?
19:02:46 <thoughtpolice> lispy: I haven't played around with it much, I just bought a copy of vmware fusion + windows xp so if I want to learn C# I can use it there now :P
19:03:01 <dolio> It can't be that terrible.
19:03:11 <thoughtpolice> adu: it's fairly well-set now that NQP has been introduced
19:03:18 <thoughtpolice> much of the compiler tools have been completely overhauled
19:03:20 <lispy> thoughtpolice: yeah.  I hope mono catches up.  I just know I was terribly disappointed last time I tried their koolaid
19:03:27 <thoughtpolice> and so it's a lot easier to write languages for parrot now
19:03:33 <thoughtpolice> and by association development goes so much faster :]
19:05:02 <thoughtpolice> adu: you might want to check this out - http://www.parrotblog.org/2008/03/targeting-parrot-vm.html
19:05:18 <thoughtpolice> 8 part tutorial, building a language with parrot's new tools
19:05:32 <thoughtpolice> so yes it has become a lot easier to write languages for parrot and the tools are solidified from what I can tell
19:05:36 <thoughtpolice> there's just still more to do
19:05:46 <adu> thoughtpolice: hmm, thanks
19:06:38 <thoughtpolice> adu: I remember I approached some of parrot's language implementations a while back before NQP and it was quite scary, now it's a whole lot easier and you can get stuff working a lot faster.
19:07:37 <thoughtpolice> audreyt is back in action though so pugs should steam along again soon, and rakudo has a lot of work going into it so I'm excited, anyway :]
19:09:15 <lispy> thoughtpolice: NQP?
19:09:44 <thoughtpolice> 'not-quite-perl'
19:10:12 <thoughtpolice> basically a subset of perl 6 designed specifically for writing languages on parrot (e.g. it has support for grammars and rules and whatnot)
19:10:24 <Associat0r> hmm I am sure I read somwehere that wikipedia used something based on beagle or something but can't find it anymore
19:11:20 <Associat0r> ah here it was
19:11:23 <Associat0r> http://www.mono-project.com/Companies_Using_Mono
19:11:28 <lambdabot> Title: Companies Using Mono - Mono
19:11:42 <Associat0r> "Wikipedia (http://wikipedia.org): WikiPedia uses Mono for its search facilities. The indexing and the actual searching is done by Mono-based applications. "
19:13:06 <Associat0r> electronx : lispy
19:15:06 <electronx> mono seems something like the wine project
19:15:21 <electronx> not reall somethin you can bank on
19:15:32 <electronx> really, something*
19:17:04 <Associat0r> electronx : well what language are you gonna use?
19:17:32 <Associat0r> wine is not like mono
19:17:46 <Associat0r> mono is backed by novell
19:19:03 <Associat0r> electronx : and for what?
19:20:25 <electronx> F# maybe
19:22:06 <roconnor> *L* > "Lisp might not be the answer but syntactic extension is."  > "Syntactically extend me a type system and then I'll be convinced that macros are all I need."
19:23:35 <Associat0r> electronx : also remember with all the midori and bartok stuff MS is doing and when it finally gets SIMD it will get faster
19:25:19 <electronx> sounds interesting
19:28:29 * araujo back
19:41:02 <paczesiowa> @src either (const Nothing) Just
19:41:02 <lambdabot> Source not found. Just try something else.
19:42:51 <Olathe> @src something else
19:42:51 <lambdabot> Source not found. Maybe you made a typo?
19:44:54 <paczesiowa> there are waaaayyy to many error monads and too little code not custom to one specific monad
19:49:00 * adu wonders what a caramel monad would taste like...
19:49:11 <DannoHung> Creamy and smooth
19:49:40 <DannoHung> But it would be wrapped in a shell so hard that you couldn't get to the center... unless you wrapped yourself in the same shell
19:50:12 <DannoHung> And it wouldn't very safe to get out
19:50:22 <DannoHung> And I've just taken this metaphor too far
19:50:29 <Olathe> You could use the bite function to get the value.
19:50:56 <paczesiowa> and there is no backtracking
19:51:13 <DannoHung> Damn Owls always cheating
19:51:16 <Olathe> Well, bite doesn't really bite it.
19:51:22 <Olathe> It produces a copy of it that's bitten.
19:52:02 <paczesiowa> that's un-cookie-possible!
19:52:09 <adu> DannoHung: lol
19:53:03 <DannoHung> Dude, I just thought of something: The Owl takes three licks... what are Monads in Haskell?  Kleisli Triples!
19:53:26 <adu> lol
19:54:47 <adu> class Monad m => Caremel m where return = getToCreamyCenter ; (>>=) = eatMyWayAround
19:57:56 <DannoHung> I think, correspondingly, that this Tootsie roll commercial explains Monad Transformers: http://www.youtube.com/watch?v=qayjR8Qbyfc
19:57:56 <lambdabot> Title: YouTube - Tootsie Roll 70's Commercial
20:00:21 <adu> I wonder how compatible House and Haiku are...
20:00:47 <Olathe> House the TV show ?
20:01:24 <Cale> adu: Not at all, would be my guess.
20:01:41 <Cale> Olathe: House the operating system written in Haskell
20:02:30 <adu> like rewriting Haiku to use a House kernel... like MkLinux or something
20:03:20 <adu> hmm... or L4/House even
20:05:34 <Olathe> Cale: Ahh.
20:14:51 <dons> tibbe's talk today, http://www.galois.com/blog/2008/09/12/left-fold-enumerators-a-safe-expressive-and-efficient-io-interface-for-haskell/
20:14:53 <lambdabot> Title: Galois › Blog › Blog » Left-fold enumerators: a safe, expressive and effici ..., http://tinyurl.com/3f3er3
20:14:55 <dons> on left-fold based IO.
20:15:00 <dons> or, a new high perf IO system for haskell. woot.
20:15:08 <dons> great talk. hope to get some hacking done on this soon.
20:15:15 <dons> and on reddit, http://www.reddit.com/r/programming/comments/71nke/high_performance_web_servers_in_haskell_using/
20:15:19 <lambdabot> Title: High performance web servers in Haskell: using left-fold enumerators :: (Talk, S ..., http://tinyurl.com/5zsvzd
20:16:38 <sjanssen> slides are not as fun as video :(
20:16:48 <dons> jah jah
20:16:56 <bd_> it seems like one ought to be able to wrap those enumerators into a monad to emulate traditional imperative programming
20:16:58 <dons> it's ok. tibbe works on youtube. oh wait, no. that doesnt' help.
20:17:13 <dons> bd_: *maybe*, we're not entirely sure. it's more continuation based than anything else.
20:17:23 <dons> i'll add some links to oleg's stuff on this.
20:17:24 <bd_> maybe?
20:17:30 <sjanssen> left fold enumerators is Oleg's thing, right?
20:17:41 <sjanssen> or at least he's worked on them
20:17:49 <bd_> hmm, my 5 seconds of thought on it suggested Cont ought to be able to handle it easily enough, but perhaps I haven't thought this through fully :)
20:18:25 <dons> http://okmij.org/ftp/Computation/Continuations.html#enumerator-stream
20:18:37 <lambdabot> Title: Continuations and delimited control, http://tinyurl.com/59rq4a
20:18:38 <dons> you can at least derive the lazy stream version from the enumerator
20:18:50 <dons> equivalent of deriving a lazy bytestring impl from a chunk-based enumerator.
20:18:54 <swc> Hi, I just looked at those slides.  I don't quite get it :(
20:18:56 <dons> doing this in practice is further work :)
20:20:02 <newsham> ps: http://github.com/tibbe/hyena/tree/master
20:20:05 <lambdabot> Title: tibbe's hyena at master — GitHub
20:20:10 <dons> yup
20:20:25 <dons> the exciting thing is that pretty naive code is spanking say, optimised python.
20:20:28 <newsham> also some slides up at http://www.johantibell.com/
20:20:31 <lambdabot> Title: Index of /
20:20:32 <dons> so optimised haskell with an epoll subsystem....
20:21:21 <thoughtpolice> go tibbe!
20:21:31 <thoughtpolice> his left-fold stuff certainly did look interesting :]
20:22:00 <dons> the epoll layer we can do this way, http://www.seas.upenn.edu/~lipeng/homepage/unify.html
20:22:00 <lambdabot> Title: Unifying events and threads
20:22:33 <dons> so the stack is basically: epoll | sockets/handles | bytestrings | enumFile | enumerator combinators, a la lazy bytestrings | fusion!
20:23:05 <dons> sjanssen: btw, see i took a photo (with my phone) of the room :)
20:23:08 <dons> so we're inching towards video.
20:23:37 <electronx> dons: does this mean haskell io problem is solved?
20:23:52 <dons> which problem?
20:24:02 <electronx> slow io
20:24:11 <dons> slow io? that was solved hmm. years ago.
20:24:34 <adu_> since when did haskell have slow io?
20:24:37 <dons> e.g. http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
20:24:39 <electronx> then whats so great about hyena?
20:24:39 <lambdabot> Title: sum-file benchmark | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks G ..., http://tinyurl.com/o8pll
20:24:40 <newsham> next: map/reduce platform for haskell?
20:24:46 <dons> electronx: ah, you don't get it :)
20:25:00 <dons> it's about getting 10k concurrent requests, with simple code.
20:25:05 <electronx> dons: no, please explain :)
20:25:07 <dons> not about slow IO.
20:25:21 <dons> so, how do you handle 10k requests / sec, scaling nicely, without resorting to C?
20:25:29 <dons> that's a lot of resources to carefully manage.
20:25:41 <newsham> hyena has pretty exact resource releasing.
20:25:41 <electronx> dons: thats impressive but what about real websites?
20:25:45 <dons> so, the soln for haskell appears to be, epoll | bytestrings | enumerator IO.
20:25:50 * Olathe snores.
20:25:56 <dons> electronx: what's your question?
20:26:18 <electronx> 10k connections a sec for hello world app?
20:26:24 <dons> basically, most languages have 1 kind of IO (iterators), haskell has had 2 (iterators, streams). it now has 3: iterators, streams, enumerators.
20:26:27 <electronx> or just simulataneous connections
20:26:37 <electronx> i see
20:26:43 <dons> so this talk was about the 3rd way of doing IO. one that has some nice properties.
20:26:52 <dons> in particular, the resource guarantees make it easier to write scalable servers
20:26:59 <dons> which matters to guys like tibbe (at youtube)
20:27:17 <dons> he has a nice perspective on how things need to scale.
20:27:27 <electronx> youtube uses haskell?
20:27:44 <electronx> ok nvm
20:27:48 <electronx> i get it
20:27:58 <dons> no, tibbe works at youtube (which is slow python and fast C++), and is rewriting some of their stuff in haskell.
20:28:09 <dons> to see if it works.
20:28:18 <electronx> thats interesting
20:28:20 <sebaseba> http://github.com/tibbe/hyena/tree/master
20:28:21 <lambdabot> Title: tibbe's hyena at master — GitHub
20:28:31 <electronx> so who came up with enumerators?
20:28:40 <electronx> tibbe?
20:28:41 <dons> oleg's the main guy.
20:28:52 <dons> did you read the link?
20:29:02 <electronx> no just glanced
20:29:16 <dons> ah so read first. ask later.
20:31:46 <thoughtpolice> electronx: it's originally oleg's work and it's one of his much more approachable ones
20:36:26 <dons> btw, oleg's giving a talk about using left folds to write webserves at DEFUN..
20:36:47 <dons> http://www.deinprogramm.de/defun-2008/abstracts/oleg-abstract.txt
20:37:03 <shukhov> that guy is awesome
20:38:16 * thoughtpolice still thinks oleg deserves an action figure by now
20:38:38 <Olathe> Well, not too many people get action figures.
20:38:45 <Olathe> I think Einstein only got one recently.
20:38:52 <Olathe> And he's been dead for several decades.
20:38:53 <newsham> interesting Parser.hs in hyena, returns partial parses that can be continued
20:40:19 <ddarius> newsham: I believe that is common in "parallel" parsers.
20:40:36 <newsham> i've only seen parsec for combinator parsers in haskell
20:40:41 <newsham> <- noob
20:40:46 <Associat0r> would be nice to see youtube use haskell
20:40:55 <electronx> ya
20:41:10 <dons> newsham: that's kind of the idea. you might get a partial chunk.
20:41:15 <dons> which you resume when the next chunk lands.
20:42:04 <dons> well, gee, if they can write it in a glue of python and C++, how hard can it be?
20:42:15 <dons> it's all in how you structure the networks.
20:42:15 <thetallguy> heehee
20:42:21 <electronx> dons: why doesn't galois fund a super compiler for haskell?
20:42:28 <dons> electronx: umm?
20:42:43 <dons> we do. it's call *ghc*. ghc is super.
20:42:47 <electronx> dons: have you heard of supero?
20:42:50 <dons> it is a compiler. ==> it is a *super compiler*
20:43:08 <dons> electronx: what's your question?
20:43:21 <electronx> http://www-users.cs.york.ac.uk/~ndm/supero/
20:43:29 <dons> yeah, but what's your question?
20:43:33 <lambdabot> Title: Neil Mitchell - Supero
20:43:44 <thoughtpolice> ghc is indeed made of some win
20:43:54 <electronx> why don't you fund neil to finish and integrate it into ghc
20:43:54 <thoughtpolice> and continues to accumulate more as time goes on
20:43:58 <lispy> whoa, people still use GHC? ;)
20:44:06 <newsham> i dig ghc, but i peeked at some of the C code once and it scared me.
20:44:12 <dons> electronx: why would we fund neil?
20:44:12 <thoughtpolice> lispy: yus!
20:44:20 <adu_> does frag only work in linux or something?
20:44:21 <dons> isn't that microsoft's job, since they fund ghc.
20:44:23 <Olathe> electronx: Have you funded him yet ?
20:44:31 <electronx> dons: you have alot invested in ghc and haskell
20:44:40 <dons> i'm not sure what you're asking.
20:44:48 <thoughtpolice> newsham: hehe, nobody said it would be pretty.
20:44:50 <lispy> adu_: I've used it on osx
20:44:52 <dons> galois should fund all haskell research?
20:44:54 * araujo will fund lot of haskell development if he wins lottery
20:45:00 <thetallguy> He's asking where your money goes... ;-)
20:45:05 <Olathe> No.
20:45:11 <electronx> thetallguy: yes :)
20:45:11 <newsham> tp: it could be.
20:45:12 <Olathe> He's criticizing where your money goes.
20:45:20 <Olathe> He's telling you to do it differently.
20:45:22 <adu_> lispy: i'm on osx, and it says "Bus error"
20:45:23 <dons> oh, building stuff. maintaining darcs.haskell.org, running the haskell hackathons, releasing things on hackage.
20:45:25 <electronx> lol
20:45:26 <lispy> is electronx trolling?
20:45:31 <Olathe> Of course.
20:45:33 <thoughtpolice> newsham: totally - wasn't that actually one of the goal backends for YHC or something?
20:45:38 <lispy> adu_: oh hrm...I haven't used it in a long time of course.
20:45:42 <thoughtpolice> 'readable C backend' ?
20:45:45 <newsham> no idea.
20:45:50 <lispy> adu_: is this on startup?
20:45:57 <thetallguy> electronx: they fund dons
20:46:12 <electronx> i thought dons works for them
20:46:16 <thetallguy> electronx: who then does all the work for us
20:46:43 <lispy> people in #haskell have better things to do than feed trolls I'm sure.  Go work on your monad tutorials if nothing else :)
20:46:47 <Olathe> It's really easy to see if people are serious about this stuff.
20:46:50 <thoughtpolice> newsham: the new codegen will rox anyway when it gets there
20:47:00 <thetallguy> electronx: I believe part of dons' job description is to get more stuff out of Galois and into the world.
20:47:02 <Olathe> You can check how you feel when you interact with the person.
20:47:19 <dons> Olathe: yeah.
20:47:20 <electronx> thetallguy: ah
20:47:21 <adu_> lispy: yup, first thing I see
20:47:23 <Olathe> You can also check whether they're working to implement what they want you to implement.
20:47:23 <araujo> I think there are several companies funding haskell researching
20:47:30 <swc> supero, or the ideas behind it, is definitely worthy of sponsorship.  The optimizations look very promising
20:47:31 <thoughtpolice> hopefully the HEAD will be more usable as this new build system revision goes on
20:47:47 <newsham> tp: oh, i wasnt talking about gen'd code.
20:47:51 <adu_> I type "dist/build/frag/frag leveleg" then I see "Bus error"
20:47:51 <adu_> lispy: should I perhaps try installing it?
20:47:56 <lispy> adu_: okay.  I think there was a bug initially that was triggered by bad command line params, but I sent in a patch for that (was applied as far as I know...)
20:47:57 <newsham> i meant human written C
20:48:19 <thoughtpolice> newsham: oh you mean the RTS?
20:48:30 <thoughtpolice> it's indeed sorta scary in some places.
20:49:14 <adu_> thedward: I think its beautiful
20:49:19 <adu_> oops
20:49:47 * araujo finally got himerge working as non-root
20:51:03 * araujo had to go through several tricks to get working setuid code ....
20:51:09 <newsham> tp: for exaple, the linker is littered with ifdefs and not particularly well organized.  if it was split up into windows and unix (at least) or perhaps even between different versions of unix, it would be considerably cleaner.
20:51:39 <dons> ?users
20:51:40 <lambdabot> Maximum users seen in #haskell: 511, currently: 453 (88.6%), active: 18 (4.0%)
20:51:41 <newsham> and probably easier to add new platforms too
20:53:27 <newsham> (not that I am doing anything about it)
20:53:45 <adu_> thoughtpolice: like rts_getChar ... how is that scary?
20:53:55 <Associat0r> newsham : maybe it should be rewritten in C++
20:53:56 <lispy> It's weird how programs become ugly
20:54:10 <newsham> assoc: no.  it just needs some abstraction for portability
20:54:19 <shrughes> C++ can do abstraction...
20:54:24 <thoughtpolice> adu_: hehe
20:54:25 <newsham> yes it can, but its not needed
20:54:25 <Olathe> lispy: You mean as people change them ?
20:54:33 <lispy> Olathe: yeah.
20:54:38 <shrughes> oh, never mind, the flip of that, never mind.
20:54:43 <Olathe> Yeah, that is a bit of a tough problem.
20:54:45 <lispy> There are a number of reasons for it, but it's still a bit odd.
20:55:16 <lispy> For example, optimizing tends to require violations of maintainability
20:57:52 <adu_> lispy: I think it has partly to do with spongy gray matter and partly to do with slowly melting silicon
20:58:11 <Olathe> I wonder if it's possible to abstract out the optimization you're going to do on the code and put it separately.
20:58:41 <electronx> just wandering can ghc create c code that i can use in one of my c projects
20:59:18 <adu_> lispy: meaning it will get better either with evolution or innovation ... take your pick
20:59:29 <dons> yes.
21:00:07 <Olathe> I've been kind of interested in generalizing useful code transformations.
21:00:09 <dons> http://haskell.org/haskellwiki/Calling_Haskell_from_C
21:00:10 <lambdabot> Title: Calling Haskell from C - HaskellWiki
21:00:59 <electronx> dons: i need to be able to put the generated c code directly
21:01:22 <electronx> its a c project for uni and we needto submit one file sim.c
21:01:37 <electronx> which implements one function
21:02:51 <newsham> if a human is going to read it, they will be a little upset
21:03:11 <adu_> Olathe: I think thats called aspect-oriented-prog
21:03:15 <electronx> lol doesn't matter they said it will be marked automatically
21:03:31 <electronx> how many test cases it passes
21:03:54 <newsham> oh also i think you need to link against ghc runtime
21:03:59 <newsham> so your c code prob wont compile for them
21:04:00 <dons> electronx: ah, translate the binary to C then.  http://www.cse.unsw.edu/~dons/code/hsinc/
21:04:01 <lambdabot> Title: Index of /~dons/code/hsinc
21:04:07 <dons> it'll be about 10-100k lines of C.
21:04:20 <adu_> newsham: unless you include the .hc files for the runtime at the top...
21:04:34 <electronx> 100k lines how big is that
21:04:36 <Olathe> adu_: Perhaps.
21:04:43 <Olathe> adu_: I haven't really studied it.
21:04:58 <dons> electronx: as big as a compiler binary translated to a C array.
21:05:50 <electronx> dons: how does the function interface it generates look like?
21:06:19 <electronx> if i want to implement void x(int y, int z) func in haskell
21:06:45 <electronx> x y z = print "Func"
21:06:46 <electronx> ?
21:06:51 <thetallguy> so, how does this fileEnum work?
21:09:30 <thoughtpolice> thetallguy: what do you mean? the left-fold stuff?
21:10:05 <thetallguy> thoughtpolice: yes
21:10:10 <thoughtpolice> it opens and enumerates over a file, and for each enumeration you invoke an iteratee function on a seed value and a piece of the file - just like a lef-fold
21:10:26 <thoughtpolice> in the case of the paper it enumerates over 1024-byte chunks of the file
21:11:11 <adu_> dons: lol, nice!
21:11:19 <thoughtpolice> the iteratee function takes a seed, a part of the file and returns a new seed. that new seed is then used again in another invocation of the iteratee, with a new chunk in its place
21:11:32 <thoughtpolice> when they call it a 'left-fold interface' they mean it :]
21:11:52 <thetallguy> thoughtpolice: Okay, I said all that to myself.
21:11:57 <lispy> adu_: I think the future of PL will center more on usability issues of programming and less on abstraction features.
21:12:05 <thetallguy> thoughtpolice: it still hasn't clicked why this is interesting. ;-)
21:12:24 <thoughtpolice> thetallguy: you get better control over resources for one thing
21:12:27 <lispy> today's languages handle types and abstractions pretty well.  But programming is still hard due to human factors
21:12:29 <mikv> Hi!
21:12:31 <thoughtpolice> when the file is empty, the enumerator simply returns
21:12:52 <thoughtpolice> if the iteratee decides it doesn't need any more of the file (more generally when it returns 'Left' and not 'Right') it can then be closed
21:13:03 <lispy> just based on the name, I would guess enumerators use continuations internally?
21:13:05 <thoughtpolice> so resources do not leak, they are closed as soon as possible after the enumerator is done
21:13:09 <ddarius> lispy: The obvious solution is to take the human out of the equation
21:13:41 <thoughtpolice> (the enumerators in this case return an 'Either' so you can, like said above, have an enumerator terminate at an arbitrary point which is useful)
21:13:59 <mikv> Consider following datatype
21:14:01 <mikv> http://hpaste.org/10414
21:14:05 <adu_> lispy: I think you're right
21:14:09 <lispy> ddarius: to me the obvious solution is to do human factors programming language research :)
21:14:21 <mikv> How can i use pattern matching to get left or right subtree?
21:14:21 <thetallguy> thoughtpolice: whereas the tyipical lazy readFile will hang around
21:15:33 <thetallguy> thoughtpolice: okay, that will suffice.  I certainly understand the motivation.  The business of file descriptors overflowing has been a problem before.
21:15:45 <thoughtpolice> thetallguy: yes, the enumerator is still 'lazy' - it doesn't take any more from the resource than it needs, but you are much more certain as to when things are done and you can close resources (specifically when the iteratee returns for whatever reason)
21:15:48 <adu_> lispy: I think mainstream abstractions still need some help
21:16:03 <adu_> lispy: but they're pretty good at what they do
21:16:06 <mikv> any ideas?
21:16:06 <dons> yeah, so it runs in constant space (like lazy IO), but has precise resource guarantees (like strict IO).
21:16:10 <dons> the question is: can you compose it.
21:16:22 <dons> lazy data structure IO, we do with f . g . h . i . k =<< getcontents
21:16:23 <dons> nice.
21:16:27 <thoughtpolice> mikv: treeLeft (Node _ l _) = l
21:16:31 <thetallguy> thoughtpolice: thanks.  I think this will click fully in the morning
21:16:34 <dons> but with enumerators? unknown... maybe fusion can recover this version.
21:16:53 <thoughtpolice> thetallguy: oleg's original paper on the matter is pretty good
21:17:09 <thoughtpolice> thetallguy: http://okmij.org/ftp/papers/LL3-collections-enumerators.txt
21:17:17 <thoughtpolice> ^ that's an abstract, the code is in scheme
21:17:18 <mikv> thoughtpolice, i used getLeft (Node x y z) = y
21:17:29 <thoughtpolice> http://okmij.org/ftp/Haskell/fold-stream.lhs
21:17:32 <mikv> thoughtpolice, and this approach didn't work
21:17:43 <thoughtpolice> ^^ that's the haskell version with a good example
21:18:00 <adu_> mikv: (Node a left right)
21:18:03 <thoughtpolice> mikv: same thing - why didn't it work?
21:18:21 <thoughtpolice> (the underscore just says "I don't care about this value, so don't bind it to a name")
21:18:33 <thetallguy> I used to speak scheme, so I'll look at both.
21:18:47 <thoughtpolice> it's one of oleg's much more approachable things, like I said
21:19:19 <mikv> thoughtpolice,
21:19:24 <thoughtpolice> dons: something to look into (fusing enumerators) for sure
21:19:42 <dons> thoughtpolice: yeah.
21:20:00 <dons> so what i want to do is a) turn streams into enumerators (so i can translate lazy bytestring functions into enumerators)
21:20:08 <thoughtpolice> dons: also roman's paper was pretty good I must say - I figured the general approach would be very similar to stream fusion
21:20:09 <dons> b) make them compose and see if fusion helps.
21:20:37 <lispy> adu_: I know a grad student that wanted to work on (but I don't know ultimately if he succeeded in negotiating with his adviser) doing reading optimized vs. writing optimized views of source code.  Basically, you view the abstractions different based on what is important.  This is meant to address human factors and I think it could be quite interesting.
21:20:38 <adu_> fusion?
21:20:40 <mikv> thoughtpolice, i've updated paste
21:20:51 <mikv> thoughtpolice, http://hpaste.org/10414#a1
21:21:05 <mikv> this code doesn't work
21:21:16 <thoughtpolice> mikv: why's the last line there?
21:21:28 <thoughtpolice> what doesn't work?
21:21:33 <thoughtpolice> doesn't typecheck? not expected result?
21:21:38 <lispy> adu_: fusion is when you have a good consumer calling a good producer
21:21:47 <mikv> thoughtpolice, i can not load it into ghci
21:21:50 <lispy> adu_: when that happens you can optimize away a lot of the details
21:21:52 <thoughtpolice> mikv: error being?
21:21:58 <mikv> thoughtpolice, yep
21:22:05 <adu_> lispy: I definitely think that way, like in my brain, most functions are composed of three parts, but when I look at it with ascii-vision, its a bunch of nonsense...
21:22:07 <thoughtpolice> mikv: no, what's the actual error?
21:22:25 <mikv> "Couldn't match expected type 'Tree t'" against inferred type
21:22:39 <mikv> thoughtpolice, huh. It works under hugs!
21:22:44 <Olathe> What's the inferred type ?
21:23:00 <lispy> adu_: I never thought about it this way before, but I guess fusion is probably a haskell specific generalization of tail call optimization
21:23:24 <adu_> lispy: are you talking about enumerators?
21:23:39 <lispy> adu_: you asked about fusion
21:23:52 <adu_> right, dons used the word
21:23:57 <mikv> Olathe, 'a->Tree a -> Tree a -> Tree a'
21:24:25 <lispy> adu_: fusion is something that's already done by ghc when optimizing.  I think dons wanted to explore enumerator fusion
21:24:28 <thoughtpolice> mikv: http://hpaste.org/10414#a2
21:25:07 <dons> yeah, enumerator fusion.
21:25:14 <mikv> thoughtpolice, hmm..
21:25:15 <dons> so we can fuse programs that use IO, all the way to the IO.
21:25:18 <lispy> WHere is the paper about enumerators?
21:25:20 <dons> combining up all   those enumerator loops
21:25:30 <thoughtpolice> http://okmij.org/ftp/papers/LL3-collections-enumerators.txt
21:25:32 <newsham> http://okmij.org/ftp/Haskell/fold-stream.lhs
21:25:34 <thoughtpolice> http://okmij.org/ftp/Haskell/fold-stream.lhs
21:25:35 <mikv> thoughtpolice, thanks
21:25:42 <mikv> something wrong with my ghci
21:25:48 <thoughtpolice> mikv: sure
21:26:04 <Olathe> mikv: You typed that code into ghci ?
21:26:25 <lispy> whoa, it's a paper entirely written in ascii?
21:26:26 <mikv> Olathe, i typed http://hpaste.org/10414#a1
21:26:28 <lispy> that's hardcore
21:26:35 <mikv> Olathe, i saved this code into file
21:26:43 <mikv> and i used :load
21:26:59 <Olathe> OK.
21:27:06 <Olathe> It looks like it gave the correct result.
21:27:34 <lispy> dons: these enumerators (just listening to you guys talk) could be a nice solution to the IO issues darcs faces
21:27:41 <thoughtpolice> lispy: what do you expect from oleg? ;]
21:27:48 <dons> lispy: what are the darcs issues?
21:27:51 <dons> too many open file handles?
21:27:51 <thoughtpolice> something non-hardcore? preposterous!
21:28:11 <newsham> lispy: that program is written in ascii.
21:28:17 <dons> we need code next  though.
21:28:25 <dons> i'm pondering a EnumeratorByteString type
21:28:32 <dons> with io , and functions on it.
21:28:39 <dons> like lazy bytestrings, but with control turned inside out.
21:28:44 <thoughtpolice> dons: fancy. :]
21:28:58 <dons> well, that seems like a way forward with this stuff.
21:29:03 <thoughtpolice> tibbe's stuff really got you thinking? or has this just been lingering in the mind already?
21:29:14 <dons> well, i spent a day with him working on it :)
21:29:16 <thoughtpolice> dons: yes, they're pretty elegant beasts
21:29:18 <newsham> dons: chunkEnum from tibbe's Data.Enumerator?
21:29:19 <dons> doing a galois mind meld :)
21:29:35 <newsham> err.. not that one.. um  bytesEnum?
21:29:46 <dons> i think there's a correspondance between lazy bytestring's stream chunks
21:29:54 <dons> and the enumerator version, kind of the dual.
21:30:37 <dons> you might even be able to derive lazy bytestrings from the enumerator version
21:30:40 <dons> (or go the other way?)
21:30:46 <dons> need to read more oleg.
21:30:47 <lispy> dons: the darcs issue is one of not cleaning up eagerly with lazy IO, and not streaming enough with strict IO
21:30:58 <dons> yeah.
21:30:58 <ddarius> Oleg's work was that (with delimited continuations) you could go either way.
21:31:05 <newsham> probably both ways, oleg did both ways for getChar and folder
21:31:13 <dons> ah cool.
21:31:18 <dons> so maybe we can scale it up.
21:31:33 <joe_b> dons, you're on the language.c team, ya?
21:31:37 <lispy> (by not cleaning up I mean both memory leaks and file handle leaks)
21:31:45 <thoughtpolice> yeah, if you don't have delimited continuations you can use non-recursive left folds via fix
21:31:46 <newsham> http://github.com/tibbe/hyena/tree/master/Hyena/BufferedSocket.hs    toEnumerator is interesting
21:31:47 <lambdabot> Title: Hyena/BufferedSocket.hs at master from tibbe's hyena — GitHub
21:31:47 <dons> hmm. joe_b i can put you in touch with people.
21:31:52 <thoughtpolice> so it can go either way, which is cool
21:32:10 <dons> i wonder if we can encode them directly as (fusion) streams too.
21:32:16 <dons> the non-recursive steppers.
21:32:20 <joe_b> dons: that would be good
21:32:36 <dons> joe_b: so you want to talk to the main author?
21:32:42 <joe_b> hitting a cabal build error on mac; no one seems to have a solution
21:32:43 <micahcowan> Is Data.Char portable? Or am I right in believing Char is better when it suffices?
21:32:56 <dons> micahcowan: portable. please use it :)
21:33:21 <thoughtpolice> joe_b: i have 0.3.1 right here on my mbp...
21:33:47 <thoughtpolice> joe_b: paste err and command you're installing with (cabal install?)
21:33:54 <joe_b> thoughtpolice: oh, good, maybe its just me :P
21:34:14 <thoughtpolice> seemed to build without a hitch here
21:34:18 <thoughtpolice> i've been using it in random experiments
21:34:23 <dons> btw guys, i did an (amateuris) xmonad screencast using xvidcap (and recordmydesktop), http://uk.youtube.com/watch?v=4dyoLS-zOgE i'd love to see someone who knows the tools do a better job!
21:34:24 <lambdabot> Title: YouTube - xmonad tour : take 1
21:34:25 <micahcowan> dons, but is it defined by Haskell 98 (current edition)?
21:34:29 <joe_b> cabal install -p language-c
21:34:40 <joe_b> cabal: happy is required but it could not be found. cabal: Error: some packages failed to install: language-c-0.3.1 failed during the configure step. The exception was: exit: ExitFailure 1
21:34:41 <dons> micahcowan: Char, but that's 10 years old. all implementations of Haskell using Data.Char now.
21:34:53 <thoughtpolice> joe_b: do you have happy in your PATH?
21:35:01 <joe_b> ah, probably not
21:35:09 <joe_b> pebkac
21:35:10 <thoughtpolice> joe_b: you might not even have it installed
21:35:17 <joe_b> definitely have it installed
21:35:23 <thoughtpolice> cool
21:35:25 <joe_b> did it through cabal
21:36:04 <joe_b> okay, stupid question, how do i find out where cabal put happy when it installed
21:36:15 <thoughtpolice> joe_b: it probably put it in ~/.cabal/bin
21:36:43 <thoughtpolice> joe_b: in cabal install 0.5.2 you can specify the dir to put binaries in but I don't know what you need to put in your ~/.cabal/config
21:37:54 <thoughtpolice> dons: music is good :)
21:38:45 <joe_b> thoughtpolice: path was the error, get a new error now :)
21:38:58 <thoughtpolice> joe_b: now what? :]
21:39:07 <joe_b> doesn't find alex
21:39:14 <thoughtpolice> same problem i'm sure
21:39:25 * ddarius should make an xmonad screen cast.  There isn't actually anything that reveals that I'm even using xmonad.
21:39:33 <joe_b> wouldnt it be in ~/.cabal/bin?
21:39:35 <lispy> I skimmed to the end of that paper, but honestly I'm not getting it yet.
21:40:00 <thoughtpolice> joe_b: unfortunately cabal-install can't track down dependencies on e.g. external preprocessors, so if you didn't have alex installed and something needed it, cabal-install can't download and install it first
21:40:30 <thoughtpolice> so you will have to 'cabal install alex' if you haven't already, then pull it out of ~/.cabal/bin into your ~/bin or whatever
21:40:36 <dons> ddarius: yeah, its a hard question.
21:40:44 <dons> need to show the keyboard work somehow.
21:41:05 <joe_b> thoughtpolice: great, thanks, language-c build in progress
21:41:16 <dons> what's a good keycaps program?
21:41:17 <thoughtpolice> joe_b: it's a fun package :]
21:41:34 <thoughtpolice> i'm thinking of maybe creating some general combinators for C generation so you don't have to build the AST in such a raw manner but,
21:41:45 <thoughtpolice> i'm not sure how to generally go about it. must trial and err I guess
21:43:05 <lispy> thoughtpolice: well, I know one obvious way to construct C ASTs :)
21:43:10 <Cale> Is anything like a Harpy for C planned with regard to the Language.C stuff?
21:43:31 <dons> if someone wants to write it :)
21:43:33 <Cale> It would be cool to transform C functions into IO actions somehow :)
21:43:37 <thoughtpolice> Cale: it's something I've been thinking about
21:44:15 <lispy> Cale: would you prefer an interpreter or executing compiled C?
21:44:29 <Cale> lispy: JIT compilation would be best :)
21:44:29 <thoughtpolice> i've been pondering a lot about a compiler in my head for a while now
21:44:36 <thoughtpolice> and there are some extremely nice libraries out there
21:44:42 <thoughtpolice> that should facilitate the process a lot :]
21:44:46 <bos> i have a half-baked replacement for hp2ps written in 143 lines of haskell, instead of 3256 lines of C.
21:45:23 <lispy> hp2ps?
21:45:32 <lispy> haskell program to post-script?
21:45:41 <bos> the heap profiling graphing tool. outputs postscript, yes.
21:45:46 <dons> bos, nice!
21:45:49 <bos> mine displays in a gtk window so far.
21:45:52 <thoughtpolice> (language-c, derive is useful for getting rid of boilerplate, uniplate is pretty simple SYB stuff that's fast, etc. etc..)
21:45:57 <dons> isn't there a graphical hp2ps thing already?
21:46:40 <geezusfreeek> > 143%3256
21:46:41 <lambdabot>   13%296
21:46:54 <geezusfreeek> very nice
21:46:59 <lispy> > gcd (143, 3256)
21:47:00 <lambdabot>       Overlapping instances for Show ((t, t1) -> (t, t1))
21:47:01 <lambdabot>        arising from...
21:47:05 <lispy> :t gcd
21:47:07 <lambdabot> forall a. (Integral a) => a -> a -> a
21:47:12 <Cale> > gcd 143 3256
21:47:13 <lambdabot>   11
21:47:24 <Cale> > lcm 143 3256
21:47:26 <lambdabot>   42328
21:47:37 <lispy> I guess, 143%3256 is just a quick way to factor out the gcd
21:47:59 <Cale> Must have at least some respect for any base language library which was thoughtful enough to include the gcd function :)
21:48:38 <lispy> Yeah, seriously considering the historical significance of gcd in algorithms it should be there in every language :)
21:49:08 <lispy> I know, let's implement a language and NOT include the first algorithm that was ever codified as such.
21:50:10 <Cale> One thing which I find curious is how complicated the asymptotic complexity considerations for the gcd are.
21:50:32 <Cale> Of course, it's not so surprising, given its number theoretic purpose.
21:51:26 <ddarius> Bah.  Who needs gcd?  Just have a Lattice class with meet and join and a Divisibility newtype.
21:52:41 <Cale> It would be nice to have general lattices. :)
21:52:50 <lispy> Cale: hmm...i don't recall the analysis, but I do recall it's a very low complexity
21:53:05 <Cale> http://upload.wikimedia.org/wikipedia/commons/2/21/Euclidean_algorithm_running_time_X_Y.png
21:53:07 <lambdabot> http://tinyurl.com/66st2a
21:53:33 <lispy> Cale: heh
21:54:28 <lispy> Cale: I do remember having to implement the extended euclidean myself once when I was new to haskell
21:54:32 <shrughes> o_o the golden ratio, how magical it's everywhere :\
21:54:37 <lispy> I needed it for an RSA implementation
21:54:55 <Cale> http://mathworld.wolfram.com/EuclideanAlgorithm.html has some results about the average case complexity
21:55:00 <lambdabot> Title: Euclidean Algorithm -- from Wolfram MathWorld
21:55:26 <Cale> I think the whole thing is bounded by O(n^2) for two n-bit numbers.
21:55:50 <Cale> but if you want to understand more of the structure, it can get insanely complicated :P
21:56:15 <malouin> If anyone would like to take a look at http://hpaste.org/10415 and tell me what I could do to make this nicer, I would be happy to read their code snippits at a later time.
21:56:30 <malouin> like haskell editing circle.
21:57:03 <shrughes> Cale: can you do modulo in O(n) time for two n bit numbers?
21:57:12 <lispy> Cale: yeah, wikipedia seems to thnk O(n^2) is worst case.  That's odd, I was thinking it was something like, O(ln (max m n)), or so
21:57:51 <lispy> Cale: oh, I see.
21:58:09 <lispy> Cale: I was told the complexity in terms of n and m not interms of how many bits to represent them
21:58:26 <lispy> Cale: the number of bits being the correct complexity because that's the size of the input
21:58:44 <Cale> well, you can do it either way, just have to be careful about what n means :)
21:58:52 <lispy> Cale: but, I was taught in an undergraduate math class and probably the professor didn't want to talk about such nuances as the input "siE"
21:58:55 <lispy> er "size"
22:00:02 <Korollary> most imaginative typo award
22:03:03 <Cale> It's somewhat unsurprising that the golden ratio shows up often, given that it's one of the roots of the polynomials with integer coefficients whose coefficients have absolute value at most 1. It seems you end up with 0, 1, -1, i, -i, phi, -phi, 1-phi, phi-1 and then (+- 1 +- i sqrt(3))/2
22:04:45 <shrughes> and particularly the real roots
22:05:00 <Cale> Those last ones are roots of unity, so they're also important.
22:05:41 <Cale> Oh, I didn't specify I was restricting the degree to at most 2 :)
22:05:52 <shrughes> well duh
22:06:18 <Cale> I wonder what else we get if we go up to 3 :)
22:06:29 <shrughes> "the simplest hard-to-solve polynomial with a real solution gives phi" you could say
22:06:43 <dons> http://uk.youtube.com/watch?v=LN4Ov6ZLcrI
22:06:44 <lambdabot> Title: YouTube - xmonad demo : take 2
22:06:47 <dons> audio track should land soon.
22:06:50 <shrughes> where "hard-to-solve" means... well, you know :)
22:07:29 <Cale> ah, lots of garbage then :)
22:08:50 <heatsink> dons: I was expecting to see how xmonad handles inkscape's popup windows.
22:09:19 <dons> oh i suppose i can do that.
22:10:08 <sjanssen> dons: have you noticed a connection between left fold enumerators and stream fusion?
22:10:18 <dons> i have!!
22:10:23 * dons smells new papers 
22:10:28 <heatsink> heh
22:10:31 <Cale> You get nice things like 1/3 (1 + (19 - 3 Sqrt[33])^(1/3) + (19 + 3 Sqrt[33])^(1/3))
22:10:33 <Cale> heh
22:10:40 <dons> that was always the challenge with say, strict uvector fusion -- how to fuse IO
22:10:43 <Cale> 1/3 (-1 - 2/(17 + 3 Sqrt[33])^(1/3) + (17 + 3 Sqrt[33])^(1/3))
22:10:44 <dons> now i think we have a clue stick.
22:11:03 <dons> sjanssen: and fusion may make compositionality of enumerators work
22:11:14 <shrughes> oh wow, let me start counting sunflower seeds
22:12:11 <sjanssen> dons: has Galois thought about getting a camera in these presentations?  It would be really nice to actually get the whole presentation
22:12:14 <sjanssen> slides only go so far
22:12:31 <dons> yes yes yes. :)
22:12:44 <dons> i have to chase someone who has a budget to buy video equipment.
22:14:01 <Korollary> Call in the paparazzi instead.
22:14:31 <sjanssen> dons: even just audio recording would be great
22:14:33 <Korollary> We'd read about monads in the checkout line.
22:19:14 <dons> sjanssen: hmmm.
22:20:32 <sjanssen> dons: a laptop with a built-in mic might even do the trick
22:22:04 <dons> so that i think we can do.
22:22:17 <dons> seems like a macbook should be able to do this...
22:22:30 <dons> i'll experiment.
22:23:12 <sjanssen> you might even be able to get a macbook to do the video recording, but it might be a bit awkward to position it :)
22:23:50 <dons> heh
22:24:25 <dons> i imagine a decent digital video camera + mic doesn't cost the earth
22:24:48 * araujo just found out that accounts at code.haskell.org /= haskell.org
22:26:27 <cjs> Why do you need a decent video camera? I'd think that, given that these things end up on the Internet, any old USB camera would do.
22:27:01 <dons> well, that might be true.
22:27:08 * Cale plots the algebraic integers of degree 2 with coefficients of magnitude less than 20 in the complex plane :)
22:31:59 <mmorrow> . (\xs -> let (x,y) = (sum xs,length xs) in x `par` y `pseq` fromIntegral x / fromIntegral y) [0..100000]
22:32:00 <lunabot>  50000.0
22:32:03 <mbeddoe> i'm building this tool using hsplugins that recompiles a project when the code changes, my loop is going wild and eating up cpu and i'd like to add a sleep.  is there a better way of doing this? if not, is there a sleep() analogue
22:32:28 <mmorrow> there's threadDelay
22:32:46 <mmorrow> if you want it to sleep until something occurs, then you can have it wait on an MVar
22:33:08 <mbeddoe> i really just need it to slow down its polling
22:33:14 <mbeddoe> its spinning madly
22:33:23 <mmorrow> probably threadDelay then
22:33:28 <mbeddoe> yeah
22:33:29 <sjanssen> polling is gross.  Can you use hinotify?
22:33:29 <mbeddoe> thank you
22:33:38 <mbeddoe> well, the way the code works, i'm using don's hsplugins
22:33:43 <mbeddoe> to determine when the module has changed
22:33:52 <mbeddoe> so i think i don't see an easy path
22:33:57 <mbeddoe> to using a notifier
22:33:58 <mbeddoe> maybe not
22:34:09 <mbeddoe> i agree it's gross
22:34:09 <mbeddoe> :/
22:34:13 <sjanssen> well, a module will only change if its source code file has changed, right?
22:34:19 <mbeddoe> yes
22:34:21 <mmorrow> hinotify may be perfect for that
22:34:29 <mmorrow> i've been meaning to check it out
22:34:38 <sjanssen> mmorrow: it is pretty nice
22:34:46 <mbeddoe> i'll check it out right now
22:34:48 <sjanssen> I have a nice little maildir watcher in just a few lines of code
22:34:56 <mbeddoe> it on hpaste?
22:35:02 <mbeddoe> because that sounds sweet
22:35:10 <mbeddoe> i'm messing around with kibro
22:35:16 <mbeddoe> would be nice to reload on code change
22:35:21 <mmorrow> sjanssen: i noticed there're two diff packages on hackage. which one have you used?
22:35:29 <mmorrow> (slash do you use)
22:35:47 <sjanssen> http://hpaste.org/10417
22:35:58 <mbeddoe> thanks
22:36:03 <mbeddoe> this looks like what i was looking for
22:36:08 <mmorrow> answers my question too ;)
22:36:15 <sjanssen> hinotify
22:36:54 <sjanssen> these should probably be merged
22:37:26 <mbeddoe> stoked
22:37:28 <mbeddoe> thank you :)
22:37:30 <mmorrow> have you tried both, or just happened to pick that one first
22:37:34 <mmorrow> ?
22:37:55 <sjanssen> system-inotify probably didn't exist when I wrote this
22:38:05 <mmorrow> cool
22:38:17 <sjanssen> "next :: Inotify -> IO Event" is the key difference to system-inotify, it seems
22:38:41 <sjanssen> hinotify runs a separate thread that forkIO's a callback
22:39:24 <Adamant> really interesting stuff on #haskell today. thank you all
22:40:02 <mmorrow> sjanssen: oh sweet, so next'll sleep til some event occurs i take it
22:40:50 <sjanssen> mmorrow: right, inotify uses plain old file descriptors to deliver events
22:41:10 <mmorrow> nice, threadWaitRead apparently
22:41:18 <mbeddoe> linux only, bummer
22:41:32 * mmorrow loves the hscolour view-src in hackage docs
22:41:35 <sjanssen> mbeddoe: right
22:41:39 <Cale> http://cale.yi.org/autoshare/AlgInt0.png
22:41:44 <Cale> http://cale.yi.org/autoshare/AlgInt1.png
22:41:47 <thoughtpolice> mmorrow: very nice indeed :]
22:41:48 <Cale> :)
22:42:14 <mmorrow> Cale: omgsweet
22:42:59 <Cale> There's a lot of nice structure there :)
22:43:16 <heatsink> Cale: ooh.
22:50:12 <newsham> cale: some sorta moire pattern?
22:51:03 <Cale> It's a plot of the roots of the polynomials of degree <= 2 and integer coefficients with magnitude <= 20
22:51:23 <Cale> (in the complex plane)
22:51:36 <newsham> perdy
22:52:45 <Cale> (that is, it's a subset of the algebraic integers of degree at most 2)
22:57:23 <newsham> cale: kinda reminds me of moire patterns -- http://codepad.org/f3n9f9EN
22:57:34 <Cale> yeah :)
22:57:42 <Cale> Lots of intersecting circles.
22:58:41 <dons> very nice.
23:06:00 <electronx> how do i check what versions of ghc my uni comps have installed?
23:06:08 <shrughes> ghc --version..
23:06:14 <electronx> ie find all ghc's on the machine
23:06:37 <heatsink> locate ghc?
23:06:47 <sbahra> Cale, you might like http://en.wikipedia.org/wiki/Fyre
23:07:06 <Cale> newsham: That's an interesting little piece of code, btw :)
23:07:15 <sbahra> Though de jong is chaotic ;p
23:07:35 <electronx> locate gives way to many results
23:08:22 <newsham> cale: the full thing does mandelbrot and julia, too:  http://www.thenewsh.com/~newsham/x/machine/mand3.py
23:09:01 <newsham> w/ output: http://codepad.org/MyIwVfyj
23:09:13 <heatsink> locate ghc | grep "/ghc$"
23:09:38 <ddarius> Nothing like ASCII art to reveal the beautiful intricacies of a Julia ste.
23:09:55 <newsham> you just need another plot function
23:10:01 <newsham> pbmPlot(...)
23:10:02 <sbahra> cool
23:10:16 <newsham> http://www.thenewsh.com/~newsham/x/machine/mand3_2.jpg
23:10:30 <newsham> (that one was done w/ haskell though, not python)
23:11:36 * sbahra stalks newsham 
23:12:50 <mbeddoe> night all
23:12:50 <Korollary> Good luck. He's surrounded by a large body of vaater.
23:13:40 <newsham> also a waste of time
23:13:52 <Cale> Heh, someone just joined #math and asked if anyone had the equation for love. Luckily, I had this on hand: http://cale.yi.org/autoshare/heart.png
23:14:09 <newsham> hah
23:14:19 <sbahra> He probably knows a lot of the same people I do :-P
23:26:03 <electronx> lol
23:26:14 <electronx> nice Cale
23:26:20 <dons> Cale: hehe
23:26:43 <dons> Cale, pure win.
23:31:14 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''IO)
23:31:15 <lunabot>  newtype IO a = IO (State# RealWorld -> (#,#) (State# RealWorld) a)
23:31:41 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''Doc)
23:31:42 <lunabot>  data Doc = Empty
23:31:42 <lunabot>           | NilAbove Doc
23:31:42 <lunabot>           | TextBeside TextDetails !Int Doc
23:31:56 <bd_> template haskell?
23:32:00 <mmorrow> oh yesh
23:32:14 <mmorrow> and quasiquotes
23:32:17 <mmorrow> . maybe [] tail $ [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
23:32:18 <lunabot>  ["-","3","141592653589793"]
23:32:22 <bd_> . (text . pprint . cleanNames') $(unsafePerformIO (putStrLn "Moar security" `seq` (lift =<< reify ''Doc))
23:32:32 <bd_> hmm
23:32:37 <bd_> nothing happened. Is that a good thing?
23:32:41 <mmorrow> it's impossible to inject code
23:32:50 <bd_> impossible is a very strong word
23:33:00 <mmorrow> i know :)
23:33:03 <bd_> in this case I got the parens wrong though
23:33:04 <mmorrow> one sec..
23:33:15 <bd_> . (text . pprint . cleanNames') $(unsafePerformIO (putStrLn "Moar security") `seq` (lift =<< reify ''Doc))
23:33:15 <mmorrow> there is no surrounding context
23:33:20 <bd_> surrounding context?
23:33:21 <mmorrow> . unsafePerformIO
23:33:22 <lunabot>   Not in scope: `unsafePerformIO'
23:33:35 <bd_> ah, I didn't know if TH used a different set of imports
23:33:49 <mmorrow> r <- dynCompileExpr sess ("show (" ++ s ++ ")")
23:33:57 <mmorrow>           Just r  -> return $ (Right . take n) `fmap` fromDynamic r)
23:34:13 <mmorrow> if the expression isn't a string, it won't get evaluated
23:34:33 <mmorrow> so, as long as there's no way to do IO, then it's all good in the hood
23:35:01 <bd_> all right then :)
23:35:07 <mmorrow> the "show ( ... )" is just there for convenience, it has no impact on security
23:35:14 <mmorrow> db_: totally!
23:35:17 <mmorrow> oops
23:35:23 <mmorrow> bd_
23:36:49 <mmorrow> . $(let sel n i = let x = mkName "x" in lamE [tupP (replicate i wildP++[varP x]++replicate (n-i-1) wildP)] (varE x) in sel 19 12) (3,2,4,3,5,7,45,65,3,6,5,34,5,43,4,54,3,4,54)
23:36:50 <lunabot>  5
23:36:55 <mmorrow> hehe
23:37:17 <mikv> typ constructors are used only in type signatures
23:37:28 <mikv> right?
23:38:07 <mmorrow> . $(let sel n i = let x = mkName "x" in lamE [tupP (replicate i wildP++[varP x]++replicate (n-i-1) wildP)] (varE x) in \x -> fmap ($ x) (fmap (sel 19) [0..18])) (3,2,4,3,5,7,45,65,3,6,5,34,5,43,4,54,3,4,54)
23:38:08 <lunabot>      The lambda expression `\ x -> fmap ($ x) (fmap (sel 19) (...))'
23:38:34 <mmorrow> oh
23:39:32 <mmorrow> not enough stages to do that in a single expression
23:39:43 <mmorrow> err
23:42:00 <jinjing> anyone interested blog in TeX?
23:42:15 <mmorrow> . $(let toList n = replicateM n (newName "x") >>= \ns -> lamE [tupP (fmap varP ns)] (listE (fmap varE ns)) in toList 19) (3,2,4,3,5,7,45,65,3,6,5,34,5,43,4,54,3,4,54)
23:42:15 <lunabot>  [3,2,4,3,5,7,45,65,3,6,5,34,5,43,4,54,3,4,54]
23:44:06 <mmorrow> mikv: yes, if i'm understanding you correctly
23:44:19 <mmorrow> jinjing: ?
23:44:22 <mikv> mmorrow, thanks
23:45:30 <mmorrow> also, some identifiers are both data /and/ type con idents
23:45:34 <mmorrow> like ()
23:45:42 <mmorrow> and (,,)
23:45:47 <mmorrow> []
23:46:42 <jinjing> mmorrow: i just thought it could be useful
23:46:57 <mmorrow> jinjing: i don't understand the question
23:47:43 <mmorrow> jinjing: interested in using/writing-code-to-use TeX to format stuff for a blog?
23:48:06 <jinjing> mmorrow: oh, sorry, i was wondering if a blog engine allow blogger to post in tex format would be useful
23:48:30 <mmorrow> ahh. cool, that would be useful. i haven't seen such a thing though :)
23:49:57 <jinjing> mmorrow: i'm currently writing one that allows one to do that
23:50:15 <mmorrow> jinjing: oh awesome. in haskell?
23:50:25 <jinjing> but I know very little about tex, so I don't know how to test it
23:50:41 <jinjing> yeah
23:50:51 <jinjing> for a quick demo see
23:50:51 <jinjing> http://jinjing.blog.easymic.com/
23:50:56 <lambdabot> Title: C大调
23:50:58 <mmorrow> ahh, i understand now.
23:51:23 <mmorrow> i'll check it out, but can't guarantee anything :)
23:51:47 <jinjing> especially how the math formula are used...
23:52:55 <mmorrow> cool
