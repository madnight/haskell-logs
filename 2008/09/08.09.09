00:01:36 <chrisdone> okay so with `list' I now have: http://hpaste.org/10212
00:02:55 <chrisdone> this is kind of ugly though:
00:02:55 <chrisdone> normalise = concat . map (\a -> filter (not . null) [take n a, drop n a]) . words
00:03:01 <haskellian> can anyone point to a simple stm-example not including IO? lets say i want to compute fibonacci 22 to 32 using stm
00:03:05 <Myoma> @pl (\a -> filter (not . null) [take n a, drop n a])
00:03:05 <lambdabot> filter (not . null) . ap ((:) . take n) (return . drop n)
00:03:24 <Myoma> :t uncurry (:) . (unwords *** list [] (partitioned n . unwords)) . last . takeWhile ((<=n) . foldr ((+) . length) 0 . fst) . liftM2 zip inits tails . map (filter (not . null) . ap ((:) . take n) (return . drop n)) . words
00:03:25 <lambdabot> Not in scope: `list'
00:03:25 <lambdabot> Not in scope: `partitioned'
00:03:40 <nha_> was 6.10  that big update with unicode, smp gc and new record syntax?
00:03:41 <Myoma> it's recursive :S
00:03:56 <chrisdone> yeah, it splits multiple times
00:04:06 <chrisdone> Int -> String -> [String]
00:04:55 <chrisdone> @let partitioned n = uncurry (:) . (unwords *** list [] (partitioned n . unwords)) . last . takeWhile ((<=n) . foldr ((+) . length) 0 . fst) . liftM2 zip inits tails . map (filter (not . null) . ap ((:) . take n) (return . drop n)) . words
00:04:56 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
00:05:06 <chrisdone> weird errors
00:05:10 <chrisdone> :t list
00:05:11 <lambdabot> Not in scope: `list'
00:05:12 <Myoma> @undef
00:05:14 <Myoma> @undef
00:05:44 * chrisdone keeps his hands to himself :<
00:09:53 <cjs> Grr. I hadn't realized how annoying it is to be waiting for a build or whatever and be staring at a line in top that continuously says a processor is 99% idle.
00:11:24 <ketil> cjs: that usually means to stop waiting and do something about it :-)
00:11:40 <cjs> I am doing something. I'm contemplating it. :-)
00:11:48 <Myoma> @let cons = uncurry (:)
00:11:49 <lambdabot>  Defined.
00:11:51 <Myoma> :t cons
00:11:52 <lambdabot> forall a. (a, [a]) -> [a]
00:11:54 <ketil> Can't have them CPUs slacking off.
00:13:46 <_zenon_> > :i (.)
00:13:46 <lambdabot>   mueval: Prelude.read: no parse
00:13:53 <_zenon_> ?
00:13:57 <haskellian> can anyone point to a simple stm-example not including IO? lets say i want to compute fibonacci 22 to 32 using stm
00:15:51 <quicksilver> you have to run STM in IO
00:15:59 <quicksilver> so there is going to be IO at the top level.
00:16:21 <quicksilver> is STM useful for calculating fibonacci numbers?
00:17:58 <thatsright> how do i turn off echoing in ghci i want to load a bytestring via a <- readFile "x" but the file is too long to print on screen
00:19:00 <quicksilver> -fno-echo-bind-result
00:19:01 <Myoma> thatsright: that doesn't echo .. for me, what is the exact thing you type?
00:19:03 <quicksilver> or something like that
00:21:02 <haskellian> quick: dont know iti s just to learn, i was thinking of using stm with the exponential fib implementation and spawn threads starting with the biggest nbr just to get some result and get a basic understaning of the constructs
00:21:20 <Myoma> Why don't you write it?
00:23:48 <quicksilver> haskellian: the threads have to come from IO.
00:23:56 <quicksilver> haskellian: STM is designed to work with IO, really.
00:24:09 <thatsright> thanks it was  :unset -fprint-bind-result
00:24:22 <quicksilver> damn I was close :)
00:27:07 <ketil> @seen dons
00:27:07 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 2h 37m 26s ago.
00:29:28 <thatsright> @pl (reverse . take 2 .reverse )
00:29:28 <lambdabot> reverse . take 2 . reverse
00:33:26 <haskellian> ok, lets say i want to run an algorithm over multiple cores, what do i use then? not stm?
00:34:10 <thatsright> thatsright: too bad you cant do  ' take (-2) [1,2,3,4,5] =>  [4,5]'
00:35:22 <BeelsebobWork> haskellian: the easiest way is just to use `par` and Control.Parallel.Strategies
00:35:29 <BeelsebobWork> and forget about the concurrancy stuff
00:35:51 <BeelsebobWork> thatsright: I'm not sure how that could ever make semantic sense
00:35:53 <Baughn> Is there some obvious reason there is no extractBits function in Data.Bits, or should I submit a patch?
00:36:08 <BeelsebobWork> otoh, takeFromEnd would be a useful function
00:36:35 <Boney> haskellian: there are some experimental methods for automatically placing 'par's within code to automatically parallelise it.
00:37:08 <Boney> haskellian: I don't know if the research has been done is in the main release of GHC or anything.
00:37:32 <Boney> but there's a paper "Feedback directed implicit parallelism in Haskell" or similar.
00:37:57 <dolio> par is pretty old. It's in GHC.
00:38:20 <BeelsebobWork> dolio: yes, but automatically inserting it is not
00:38:32 <dolio> Ah, true.
00:42:17 <Baughn> @pl (\a b -> a*(2^(16*b)))
00:42:17 <lambdabot> (. ((2 ^) . (16 *))) . (*)
00:42:56 <haskellian> does haskell have something like erlang for concurrency? if not, would it be easy to implement?
00:43:19 <BeelsebobWork> uhhhh?
00:43:23 <Baughn> haskellian: Depends. Exactly which erlang feature do you mean?
00:43:29 <BeelsebobWork> what do you mean by "something like erlang"
00:43:49 <BeelsebobWork> haskellian: in general, concurrency is not needed in a functional language -- only parallelism
00:45:30 <Baughn> @src fromIntegral
00:45:30 <lambdabot> fromIntegral = fromInteger . toInteger
00:45:39 <_zenon_> Someone programmed O'caml?
00:45:49 <ejt> _zenon_: y
00:45:58 <Myoma> _zenon_: Lots
00:46:19 <_zenon_> ejt, Myoma , is it worth learning?
00:47:04 <zeno_> ever had a function thats really usefull but you cannot think of a name for :?)
00:48:07 <zeno_> whattocall again exclude p = foldr (\try nxt -> nxt ++ again (p : exclude ++ nxt) try) []
00:48:39 <rwbarton> :t \again exclude p -> foldr (\try nxt -> nxt ++ again (p : exclude ++ nxt) try) []
00:48:40 <lambdabot> forall a a1. ([a1] -> a -> [a1]) -> [a1] -> a1 -> [a] -> [a1]
00:48:51 <ejt> _zenon_: sure
00:49:11 <_zenon_> ejt, seems to like close to the haskell syntax (looking at some examples)
00:49:27 * _zenon_ is at the stage "looking down at the pool, uncertain whether to jump in or not"
00:49:36 <ejt> _zenon_: it's strict, so don't be fooled into thinking it's like haskell
00:49:50 <_zenon_> ejt, syntax-wise.
00:50:16 <ejt> _zenon_: it produces very fast code, and the compiler itself makes good reading
00:50:55 <ejt> _zenon_: but Haskell is just a lot more expressive and fun IMO
00:51:39 <_zenon_> ejt, yeah, good to have some haskeller's opinion.
00:51:53 <zeno_> rwbarton: a1 will always be the same as a, but still no ideas :\
00:51:59 <_zenon_> maybe I'll put it on the to do list.
00:53:27 <zeno_> :t \again pExclude -> foldr (\try nxt -> nxt ++ again (pExclude ++ nxt) try) []
00:53:28 <lambdabot> forall a a1. ([a1] -> a -> [a1]) -> [a1] -> [a] -> [a1]
00:53:39 <zeno_> ok a bit better :)
00:53:58 <ejt> _zenon_: I learned Haskell for a year or so, then got a bit disillusioned because I was having trouble with my programs eating too much memory.  So I switched to ocaml for a couple of years.  Eventually I came back to Haskell and learned more about memory profiling and strictness analysis - so now I'm v. happy with haskell
00:54:17 <ejt> s/analysis/annotations/
00:55:18 <_zenon_> ejt, ah, yeah, I bumped into the lazyness wall once. Got past it though with some help, never been into the profiling.
00:55:39 <_zenon_> ejt, but O'caml has no lazyness built in?
00:55:59 <Myoma> http://caml.inria.fr/pub/docs/manual-ocaml/libref/Lazy.html
00:56:14 <rwbarton> O'Caml is approximately a strict Haskell with IMHO slightly worse syntax and a slightly worse Prelude equivalent.
00:56:25 <rwbarton> But if you want a strict language, it sure beats C++
00:56:38 <Myoma> ocaml has a module system,
00:56:40 <zeno_> it can do laziness i think
00:57:05 <rwbarton> (There are lots of other differences too, of course, but those are the ones you encounter constantly)
00:57:10 <Baughn> @msg dons Your largeword module is apparently buggy, namely in that (fromInteger k :: Word128) `shiftR` 64 does not give the same result as k `shiftR` 64, for Integer-typed 128-bit values of k
00:57:10 <lambdabot> Not enough privileges
00:57:15 <Baughn> @tell dons Your largeword module is apparently buggy, namely in that (fromInteger k :: Word128) `shiftR` 64 does not give the same result as k `shiftR` 64, for Integer-typed 128-bit values of k
00:57:15 <lambdabot> Consider it noted.
00:57:37 <rwbarton> mrd: are you mrd on spoj?
01:00:47 <_zenon_> rwbarton, that doesn't sound very nice. Maybe I'll stick to Haskell and C then
01:01:26 <Wild_Cat> Haskell "feels" much more modern and practical than what I've seen of Ocaml.
01:01:32 <Myoma> _zenon_: you should learn lisp
01:01:38 <Wild_Cat> even though I hear Ocaml kicks royal ass when it comes to raw performance.
01:02:06 <_zenon_> Myoma, I know lisp, thanks anyway for the tip ;)
01:02:17 <rwbarton> Really the kind of thing that bothers me most is that there's not even a built-in function for [1..n] AFAICT.
01:02:27 <rwbarton> This isn't a particularly serious complaint :) but it is annoying.
01:02:44 <_zenon_> Wild_Cat, I thougth assembly kicked the royal but 24/7.
01:03:31 <Myoma> _zenon_: In that case I wouldn't bother with ocaml unless you're actually going to write something in it
01:03:59 <Wild_Cat> _zenon_: Not so much. Assembly is only as optimized as you can make it, and experience shows that compilers are much smarter than humans when it comes to micro-optimization.
01:04:09 <Wild_Cat> (not to mention JITs)
01:04:20 <_zenon_> Wild_Cat, well, JIT's cheat.
01:04:36 <Myoma> cheating is a good idea
01:04:41 <Wild_Cat> _zenon_: sure they do. And cheating rules.
01:04:43 <_zenon_> Myoma, well.. I thought it would be nice to know.
01:04:50 <dancor> @hoogle (-|-)
01:04:50 <lambdabot> No results found
01:04:54 <dancor> @hoogle run
01:04:54 <lambdabot> Test.QuickCheck.Batch run :: Testable a => a -> TestOptions -> IO TestResult
01:04:54 <lambdabot> System.Process runCommand :: String -> IO ProcessHandle
01:04:54 <lambdabot> Control.Monad.Cont runCont :: Cont r a -> (a -> r) -> r
01:05:31 <dancor> why are some things in cabal-install but not hoogle
01:06:09 <_zenon_> Makes sense. Cheetah is derived from Cheating, which is tightly bound to speed, from the arabian word Che'tal meaning Faster.
01:06:12 <_zenon_> < _ <
01:06:13 <_zenon_> > _ >
01:06:14 <lambdabot>   mueval: Prelude.read: no parse
01:06:16 <_zenon_> not really
01:06:48 <_zenon_> I just made that up, none of it is real afaik
01:06:57 <mgsloan> hrmm, Control.Category exists in haskell.org/ghc/dist/ docs, but not haskell.org/ghc/docs/latest, or my version of ghc
01:11:37 <rwbarton> @users
01:11:38 <lambdabot> Maximum users seen in #haskell: 497, currently: 451 (90.7%), active: 16 (3.5%)
01:15:43 <quicksilver> mgsloan: Yes, it was committed to HEAD not the 6.8.x branch, AFAICR
01:15:49 <quicksilver> mgsloan: so it will debut in 6.10, I think
01:16:05 <Myoma> I hope 6.10 can be compiled with 6.10
01:16:30 <quicksilver> ?
01:16:40 <quicksilver> each version of GHC is always compiled with itself.
01:16:57 <ertai> I'm wondering about best practices concerning Show/Read instances
01:17:14 <Myoma> each version of GHC can _try_
01:17:21 <Myoma> they often produce loads of errors
01:17:27 <Myoma> in my experience at least
01:17:48 * tibbe just noticed that his IRC client wasn't scrolling the chat window.
01:17:51 <quicksilver> Myoma: No.
01:17:51 <ertai> Do you always follow the style of an Haskell syntax (I mean deriving when possible)
01:17:57 <tibbe> I thought noone said anything since yesterday!
01:17:57 <quicksilver> Myoma: each version of GHC *is* compiled with itself.
01:18:01 <quicksilver> Myoma: that is how GHC is built.
01:18:31 <quicksilver> conal: morning.
01:18:42 <tibbe> ertai: I always derive
01:18:51 <ertai> When you have a more compact/specialized way of writing values do you make separate functions?
01:19:01 <quicksilver> conal: (both of) your implementations of joinE 'cheat' by introspecting Future. There is presumably a compelling reason for this?
01:19:11 <tibbe> ertai: I was want some specific pretty-printing I make a separate function. Having standard Show/Read is nice for GHCi use
01:20:02 <_zenon_> Are there some papers on placement tips for wedding parties?
01:20:03 <ertai> tibbe: Right, but I feel unhappy when writing showFoo functions
01:20:10 <tibbe> ertai: I think of Haskell's Show as a variant of Python's repr
01:20:22 <_zenon_> I'm trying to develop an algorithm for the placement and then I'll implement it in Haskell
01:20:25 <tibbe> ertai: make a PrettyPrint class or something
01:21:01 <tibbe> ertai: I guess it depends on how/why you want to print the value
01:21:02 <ertai> _zenon_: I've started one using the LogicT package and it was promising
01:21:14 <_zenon_> ertai, for real?
01:21:31 <tibbe> time to sleep, gnight all
01:21:43 <ertai> _zenon_: Yes but it was a very small try
01:21:50 <ertai> tibbe: gnight
01:22:03 <_zenon_> ertai, nice :)
01:22:12 <_zenon_> I'm thinking of solving it like a CSP really.
01:22:25 <ertai> _zenon_: My wife's brain was faster :)
01:22:38 <_zenon_> ertai, it always is ;)
01:22:55 <_zenon_> damn wife brains. Ruining the look of haskell.
01:22:57 <conal> quicksilver: hi
01:23:37 <ertai> _zenon_: I've tried in prolog and failed (certainly my fault)
01:24:07 <ertai> _zenon_: Then I've tried in haskell with some kind of brute force
01:24:08 <_zenon_> ertai, well, what I need now are the basics. what rules are there to heed? what is a good placement?
01:24:24 <conal> quicksilver: hm.  i hadn't thought about it.  i guess the question is whether i could implement Event & Reactive if the representation of Future were hidden.
01:24:25 <ertai> and then using LogicT and it started to give results
01:24:31 <conal> quicksilver: i like the question.
01:25:30 <quicksilver> conal: in particular you can implement joinE with joinF
01:25:32 <ertai> _zenon_: I had placements like <<joe <- anyWhere `near` jane>>
01:25:33 <quicksilver> (and fmap)
01:26:00 <conal> quicksilver: indeed!
01:26:16 <_zenon_> ertai, mm... Well, what where your rules of thumb?
01:26:18 <conal> quicksilver: and if not, can the interface of Future be extended, while still respecting the semantic model, to make it possible to implement Event & Reactive.
01:26:42 <quicksilver> conal: I think it's probably a good direction to go.
01:26:49 <conal> quicksilver: me too
01:26:50 <ertai> About the set of rules? Or the way of solving them?
01:27:02 <quicksilver> conal: your Futures have a pattern-matchable 'Max Time' which I don't have, which I think enables you to make some optimisations.
01:27:15 <_zenon_> ertai, the rules
01:27:25 <quicksilver> conal: I'm slightly worried about a naive 'filterMaybes' collecting huge numbers of thunks representing never-occurring events
01:27:30 <_zenon_> like... relatives near friends, no more than 2 relatives per table, etc...
01:27:54 <quicksilver> conal: they don't affect the semantics but each time a 'real' event happens it gets compared with this great big chain of never occurring ones
01:29:13 <ertai> _zenon_: I used to kind of rules, rules to group by tables, and rules to place people on one the main table
01:29:24 <conal> quicksilver: interesting.  i hadn't thought about that point either.
01:30:24 <mmorrow> Myoma: http://code.haskell.org/~morrow/th/
01:30:34 <quicksilver> conal: I have a worse worry too. This one is harder to explain. Imagine a modal application with two major modes, driven by an input stream (Event Char)
01:30:35 <lambdabot> Title: Index of /~morrow/th
01:30:35 <ertai> _zenon_: I had to group of people those from my side and the other side
01:30:38 <dabblego> how would I get ["abc", "ab", "bc", "ac", "a", "b", "c"] from "abc"?
01:31:09 <Myoma> init . filterM (const [True,False])
01:31:11 <_zenon_> ertai, can you post the code somewhere?
01:31:27 <conal> quicksilver: (btw, if you're interested in trying out some improvements to Reactive, please do.  I want this library to work really well for a variety of applications.)
01:31:35 <Myoma> sortBy length ..
01:31:39 <quicksilver> conal: the each mode is defined to work on an (Event Char) defined from this master stream by filtering : i.e. "modeA" has access only to those 'Chars' which occurred during modeA, and vice versa
01:31:40 <ertai> _zenon_: I can but that's not usable
01:31:57 <dabblego> Myoma, nice one thanks
01:31:59 <_zenon_> ertai, oh, well. you know some page with tips and rules and etc for wedding placement?
01:32:02 <quicksilver> conal: semantically this is clean. However, operationally, suppose the application stays in one mode for an arbitrary amount of time.
01:32:16 <ertai> _zenon_: not at all
01:32:16 <_zenon_> ertai, or what's it called? The placement at the tables for the wedding party,
01:32:23 <quicksilver> conal: the "event stream" for the other mode exists as a reference somewhere in a behaviour, and it's not being reduced. so it's growing.
01:32:34 <quicksilver> conal: effectively the "dormant mode" is remember every single key the user types.
01:32:57 <quicksilver> conal: until it becomes active at which point it has the opportunity to quickly run through all those keypresses and notice that they "don't belong to it"
01:33:01 <_zenon_> ertai, well. I'm on my own then, I have also thought about some funny placements, where the average age of each table is the same and etc.
01:33:15 <_zenon_> ertai, if my wife will let me play with it
01:33:24 <Myoma> mmorrow: cool!
01:33:28 <Myoma> mmorrow: very neat
01:33:30 <conal> quicksilver: that would be a problem indeed.  i wonder if it would really work out that way, or if the dormant mode would be following along.  how about cooking up a minimal concrete example, and we can analyze it together?
01:34:05 <quicksilver> conal: hmm. You could be write. The dormant mode might well be following quietly.
01:34:07 <zeno_> hurray think this is as general as i can get insertIntoFold f = foldr (\try nxt -> nxt ++ f nxt try) []
01:34:19 <ertai> _zenon_: The one that place people is near from usable (but it's an easier problem)
01:34:21 <quicksilver> conal: I am working on a concrete example of exactly this. Unfortunately I had to implement filterMaybes first :)
01:34:30 <quicksilver> conal: which required me to implement joinE, hence my comments.
01:34:40 <conal> quicksilver: got it!
01:35:11 <quicksilver> conal: one advantage of having an abstract Future implementation would be we could have multiple ones.
01:35:21 <quicksilver> conal: e.g. I could use my Future implementation with your higher level constructs.
01:35:33 <_zenon_> ertai, well, I'll try to make something and maybe post it somewhere if it falls out nice
01:35:41 <conal> quicksilver: yeah -- good point.
01:36:14 <mmorrow> Myoma: yeah, it ended up being not that bad. i still have to derive the typesigs, though.
01:36:41 <conal> quicksilver: funny i hadn't noticed that i was exposing the Future rep and hence allowing the semantics of Future to be violated.  i'd already hid Reactive and Event because people were using them in non-semantic ways.
01:37:04 <quicksilver> conal: btw since yesterday I implemented a proper fair mappend for Future and reimplement my Event's mappend using that instead of cheating. It all appears to work well, but I have more combinators to finish.
01:37:15 <conal> quicksilver: neat!
01:37:29 <quicksilver> although my Future rep is now quite complicated :(
01:37:41 <quicksilver> data Future a = MkFuture { blockingReadFuture :: IO (UTCTime,a),  nonblockingReadFuture :: IO (Maybe (UTCTime,a))}
01:37:51 <mmorrow> Myoma: so basically it's just working with the TH AST + newName :: String -> Q Name, and not much else. (that th-utils package though has some instance of Lift which significantly decrease pita wrt reify).
01:38:47 <conal> quicksilver: i tried a few variations but definitely not that one.
01:39:13 <ertai> _zenon_: http://hpaste.org/10214#a0
01:40:04 <ertai> So about Show/Read, everyone use only deriving here?
01:40:25 <Baughn> You can't always derive, but when you can, sure
01:40:55 <ertai> Baughn: yes sure
01:41:06 <_zenon_> ertai, okay, I'll look at it.
01:41:27 <ertai> _zenon_: As I've said it's only near from usable
01:41:49 <_zenon_> ertai, no problem.
01:44:29 <conal> quicksilver: these days i like to look at decomposing types, to see if method implementations can dissolve.  i wonder abouit your Future rep.  Future = (IO :. (,) T) :*: (IO :. Maybe :. (,) T)
01:44:43 <conal> using http://haskell.org/haskellwiki/TypeCompose
01:44:44 <lambdabot> Title: TypeCompose - HaskellWiki
01:45:11 <quicksilver> conal: yes, although I don't think any decomposition will 'understand' the linkage between teh two components.
01:45:27 <conal> quicksilver: probably not
01:46:04 <conal> quicksilver: the method implementations would give additional hints
01:49:34 <quicksilver> conal: certainly the monad instance for (IO :. Maybe) would have simplified my implementation of joinF, in the second component.
01:49:53 <quicksilver> conal: I ended up doing it with nested case statements because MaybeT isn't in the standard library :P
02:18:47 <Philippa> quicksilver: there is an ErrorT, which is normally assumed to be 'enough' (I've got some problems with the design myself, but hey)
02:19:33 <quicksilver> Philippa: I know but when you just want MaybeT it would be nice to have.
02:19:50 <Philippa> *nod*
02:20:06 <Philippa> cases that aren't really errors, say
02:21:07 <quicksilver> http://hpaste.org/10215
02:21:24 <quicksilver> Philippa: I just want to abstract that case pattern.
02:24:33 <dolio> MaybeT is in maybet.
02:24:40 <dolio> if you don't mind using hackage.
02:25:11 <quicksilver> dolio: I don't really mind using hackage, but I was offline when I wrote the code.
02:25:18 <quicksilver> dolio: and, having written it, the job is done.
02:25:19 <dolio> Ah.
02:25:23 <dolio> Yeah.
02:25:56 <thatsright> is there an perl like unpack for haskell?
02:26:10 <quicksilver> thatsright: not a direct analog, no.
02:26:23 <quicksilver> thatsright: Data.Binary approaches a similar problem
02:26:28 <quicksilver> from a more 'structured' perspective.
02:28:28 <thatsright> quicksilver: i think data.binary is more for unpacking data which you packed
02:30:14 <quicksilver> thatsright: Data.Binary has a high level and a low level.
02:30:28 <quicksilver> thatsright: the low level - the 'Get' monad - is a generalised programmable unpacker.
02:30:50 <ejt> does Data.Binary support endianness ?
02:31:00 <quicksilver> yes.
02:31:13 <ejt> quicksilver: ah, I missed that
02:31:37 <BeelsebobWork> bastard problem 188
02:31:44 <BeelsebobWork> shoulda realised that would happen
02:32:08 <quicksilver> ejt: it wouldn't really be fit for purpose if it didn't :)
02:32:36 <ejt> true
02:33:15 <ejt> thatsright: I'm porting a python program to haskell currently, and Data.Binary is a very nice replaceemnt for calls to unpack
02:39:28 <thatsright> ejt: what is the python app might i ask?
02:39:49 <ejt> thatsright: Mercurial
02:41:49 <Wild_Cat> ejt: you're writing a Haskell version of Mercurial?
02:42:07 <BeelsebobWork> ejt: why not just use darcs?
02:44:32 <ejt> BeelsebobWork: perhaps you should ask the ghc people that
02:44:49 <thatsright> lol
02:45:04 <ejt> Wild_Cat: y
02:45:06 <thatsright> ejt: can you port git aswell?
02:45:43 <Wild_Cat> thatsright: something tells me that the Git codebase must not be as clean as the Mercurial one ;)
02:46:11 <zipMe> Hello, how would you turn a [Word8] to a [Char] ? I have tried  map (toEnum . fromIntegral) myWord8List, and I get : [245,235,178,0... --> "\245\235\178\NUL}... But I wonder if this is right, in Ruby I get  [245,235,178,0... --> "\365\353\262\000... Also in Ruby, 245.chr --> "\365". I am confused...
02:46:26 <ejt> I've not looked at Git, but I was forced to use Mercurial at work because we a) have a large code base b) run on AIX
02:46:47 <ejt> in the end I like it, and it does work, and does scale
02:47:55 <mikeX> so why rewrite it?
02:48:16 <ejt> mikeX: programming exercise mostly
02:48:24 <goltrpoat> > chr (fromIntegral (65 :: Word8))
02:48:26 <lambdabot>   'A'
02:48:26 <thatsright> zipMe: the function is called chr
02:48:29 <mikeX> oh I see
02:48:46 <BeelsebobWork> ejt: interestingly, our work dumped mercurial in favor of darcs because mercurial started falling apart at the seams with a vaguely medium-sized repo
02:49:01 <BeelsebobWork> and even more so when 3 platforms were involved
02:49:13 <BeelsebobWork> windows changing the case of things made it go insane
02:49:14 <ejt> mikeX: and partly because I got annoyed by silly posts on H Cafe suggesting that because the GHC people dropped darcs then haskell wasn't suitable for writing source control programs
02:49:16 <quicksilver> zipMe: ruby uses octal escapes for chars, haskell uses decimal.
02:49:18 <BeelsebobWork> thinking files had disapeared
02:49:25 <quicksilver> zipMe: your code is fun, as far as it goes.
02:49:52 <zipMe> quicksilver : ah ?
02:49:58 <ejt> BeelsebobWork: interesting - not my experience
02:50:01 <Wild_Cat> I'm using Mercurial at work here, and have no problems with a moderately-sized repo approaching the 4K revisions.
02:50:05 <quicksilver> zipMe: fine, I meant :)
02:50:19 <BeelsebobWork> Wild_Cat: what is a "moderately sized" repo to you
02:50:21 <ejt> I think google use Mercurial a lot
02:50:30 <BeelsebobWork> ejt: google use their own scm system
02:51:07 <BeelsebobWork> called gclient
02:52:13 <zipMe> quicksilver : I am wondering though, the final [Char} is meant to be sent in an HTTP header as a (HMAC signature), but the representation is different than the one you'd get from Ruby (which I know to be what the app expects). SO my signature is likely to be rejected. How could I take the decimal to octal ?
02:52:16 <Wild_Cat> BeelsebobWork: a little more than 30K lines of Python code, 11 megs of history.
02:52:25 <ejt> BeelsebobWork: oh
02:52:40 <BeelsebobWork> Wild_Cat: yeh, that's not what I was refering to as moderate -- I was talking a repo that's 400MB when checked out
02:53:27 <Wild_Cat> BeelsebobWork: Yeah, we keep our binary data in a separate repo :p
02:53:35 <BeelsebobWork> haha
02:53:47 <quicksilver> zipMe: you don't.
02:53:49 <quicksilver> zipMe: there is nothing wrong.
02:54:06 <quicksilver> zipMe: "\365" is the ruby notation for what haskell calls "\245"
02:54:12 <quicksilver> zipMe: they are, however, the same string.
02:54:23 <BeelsebobWork> zipMe: there's no difference in what you're sending -- the only difference is the representation used on screen
02:54:25 <ejt> BeelsebobWork: my repos are about 0.5 gig of source, but I probably only keep a tree going for a few hundred revisions before pushing back to the 'official' source control
02:54:37 <zipMe> quicksilver : ok I am with you, thanks a lot
02:55:46 <kowey> ejt: it would be interesting to see if any darcs code could be recycled for your hg implementation
02:56:16 <kowey> it would also be nice if hhg work resulted in better darcs as a side-effect :-)
02:56:29 <quicksilver> zipMe: in other news, why convert back to Char? :)
02:56:30 <goltrpoat> perhaps i shouldve read the question
02:56:33 <ejt> kowey: so far I'm keeping away from darcs, when I've got a stable base I'll start thinking about moving towards darcs features
02:56:40 <quicksilver> zipMe: Char is really supposed to be a unicode type.
02:56:49 <kowey> good luck!
02:56:51 <quicksilver> zipMe: if you're just outputting Bytes to HTTP, then you should maybe just send the bytes.
02:57:03 <quicksilver> zipMe: I'd recommend, e.g. ByteString with its Byte-based IO.
02:57:56 <zipMe> quicksilver : I am trying to build the HTTP header, which is made of different strings... ah ok I see the other stings could be BSes and I could ++ them together ??
03:00:01 <quicksilver> yes.
03:00:04 <quicksilver> BS.append, actually
03:00:05 <quicksilver> but yes.
03:01:08 <zipMe> quicksilver : how do you take a [Word8] to a ByteString ?
03:01:10 * BeelsebobWork suggests that with a few of them BS.concat [lots,of,bses] becomes neater
03:01:14 <Baughn> @tell dons Also, do you want an IDEA implementation for your crypto lib, or would there be patent issues?
03:01:14 <lambdabot> Consider it noted.
03:01:17 <BeelsebobWork> zipMe: B.pack
03:01:40 <zipMe> cool thanks a lot guys
03:02:00 <zipMe> haven't used BS much yet
03:14:09 <Myoma> > 1+1
03:14:10 <lambdabot>   2
03:14:43 <Myoma> @@ (@run "@run join (+) $") 1
03:14:44 <lambdabot>   "@run join (+) $"
03:14:44 <lambdabot>  1
03:14:57 <Myoma> @@ (@run say "@run join (+) $") 1
03:14:58 <lambdabot>   mueval: Prelude.read: no parse
03:14:58 <lambdabot>  1
03:15:31 <Myoma> @@ 1 (@run 2) (@run 3)
03:15:33 <lambdabot>  1   2
03:15:33 <lambdabot>    3
03:37:49 <conal> how do folks like to package up quickcheck tests for their libraries?  in the main library?  as a separate repo & package?  same repo & separate package?
03:39:39 <yitz> preflex: zdec z05d2Uz05d1Uz05d0U
03:39:40 <preflex>  גבא
03:41:59 <Baughn> ..what
03:58:19 <chrisdone> yitz and his crazy moon language
04:04:12 * Baughn runs slam into the monomorphism restriction
04:04:22 <quicksilver> "*splot*"
04:11:19 <therp> I vote for GHC to output the super mario "you just died" theme on /dev/dsp when you compile code that runs into the monomorphism restriction
04:11:32 <BONUS> haha
04:23:46 <purestorm> What is the best way to specify a "default" value of for a data type?
04:23:57 <BONUS> uh
04:24:04 <BONUS> you could make a Default typeclass?
04:24:16 <BONUS> class Default a where default :: a
04:24:35 <purestorm> Ah, cool, thanks
04:24:46 <haskellian> would it be possible to build an Erlang-type system for concurrency in any other language?
04:24:58 <BeelsebobWork> yes
04:25:01 <haskellian> or a virtual machine if fundmanetal to to erlang?
04:25:03 <BeelsebobWork> Erlangs is after all
04:25:39 <EvilTerran> haskellian, do you mean embedded in another language, as a library?
04:27:00 <quicksilver> it is possible to build a better-than-erlang system for concurrency in haskell
04:27:04 <quicksilver> the GHC team did so.
04:27:11 <quicksilver> Control.Concurrent.*
04:27:28 <Axman6> haskellian: i believe it would be possible to implement such a thing using the BEAM stuff erlang does too, so it could be compatible with erlang
04:27:48 <EvilTerran> that's better than erlang? ok, i haven't looked into erlang, so can't say myself
04:27:53 <Axman6> quicksilver: better untill you need to use more than one computer, right?
04:28:24 * Olathe snores.
04:28:59 <quicksilver> Axman6: I was trolling to try to get haskellian to reveal what he considered to be the key features :)
04:29:13 <quicksilver> Axman6: 'erlang-type' was not very informative
04:29:22 <Axman6> yeah
04:29:43 <Axman6> i really wish there was a language that had the best of erlang and haskell
04:29:52 <quicksilver> if distribution is the key issue it's not terribly hard to put together distributed chans given some way of serialising.
04:29:58 <Axman6> pretty much the ultimate concurrent/parallel language
04:30:01 <sjanssen> quicksilver: functions.
04:30:10 <quicksilver> Axman6: what do you consider the best of erlang - or at least those parts which are missing from haskell.
04:30:16 <quicksilver> sjanssen: indeed. I don't know how important that is.
04:30:47 <Svrog> erlang doesn't have much going for it really - concurrency as it's done in erlang could fairly easily be done in another language
04:31:14 <Svrog> the only difference is that erlang already has it and with other languages you pretty much have to write that stuff yourself
04:31:21 <skorpan> in haskell? :)
04:31:57 <Axman6> i do like the ability to run something distriburted over any network basically, and not have to worry if you're talking to another CPU core, or a computer on the other side of the world.
04:32:22 <Axman6> and fault tollerance is pretty nice, but haskell isn't bad at all either
04:32:45 <Baughn> Axman6: The problem is, you /have/ to care
04:32:54 <Baughn> Otherwise performance is going to suck
04:33:09 <Axman6> what if it's not performance you care about?
04:33:22 <skorpan> then why not use pen and paper?
04:33:33 <BONUS> performance is just another requirement
04:33:34 <Axman6> well, i should say speed, rather than performance
04:33:45 <BONUS> sometimes you need speed, sometimes its not that important
04:33:46 <Baughn> Everyone cares about performance, when the differential gets large enough
04:34:09 <Baughn> (And using message-passing on a shared memory system is just plain silly)
04:34:36 <quicksilver> Axman6: if you didn't care about performance, why would you be using CPUs on the other side of the world?
04:34:50 <skorpan> true
04:35:26 <Axman6> well, i think it would be silly to use anything else if you use it for remote processes too. just makes sense to use the same interface for all processes
04:35:35 <Axman6> quicksilver: distributed servers?
04:36:09 <Baughn> Axman6: It might be possible to transparently have Chans serialize data, but when you've got programs that happily throw around a couple thousand gigabytes/second via chans (and via pointer, thankfully), that seems like a bad idea
04:36:26 <Baughn> Axman6: It's not that the /interface/ couldn't be the same, but the way you use it has to change
04:37:01 <Axman6> anyway, i'm no expert on the subject, and i don't care that much
04:37:03 <quicksilver> Baughn: well I wasn't proposing always serialising.
04:37:15 <quicksilver> Baughn: I was proposing that Binary a => Chan a could be a transparent interface
04:37:19 <Baughn> quicksilver: I didn't think you were
04:37:25 <quicksilver> Baughn: if the other end of the chan is local, it would behave as now
04:37:26 <Arnar> hi all..
04:37:35 <quicksilver> but if the other end was non-local, it would serialise.
04:37:49 <Baughn> quicksilver: Wouldn't the type system get in your way, though?
04:37:59 <quicksilver> I don't think so no?
04:38:03 <Baughn> You might not always want to channel only Binary
04:38:04 <quicksilver> well the Binary constraint might be annoying
04:38:09 <ddarius> Baughn: Message-passing on a shared memory system is perfectly reasonable
04:38:13 <Arnar> so, I have this: succState :: State  -> [(Action,State)]    and this: countStates :: State -> Integer, countStates s = foldr (+) 1 (map (countStates . snd) $ succState s)
04:38:15 <quicksilver> yeah, but that would be a compromise you'd have to make.
04:38:20 <Baughn> I suppose, without the constraint, you could only get a runtime error
04:38:27 <Axman6> basically what i wanted was erlang, with haskell's type system
04:38:41 <Arnar> I want to put a "unsafePerformIO (putChar '.')" in there..
04:38:44 <Baughn> ddarius: Really? It always struck me as a hack to cover up the lack of purity in the language
04:38:45 <Olathe> send a = if (length a > 100000000) then error "Are you insane ?" else ...
04:38:57 <Arnar> but not really sure of the best way.. any hints?
04:39:00 <Baughn> Eg. "Doesn't matter if it changes, we've passed a copy"
04:39:22 <BeelsebobWork> dcoutts: does cabal have support for testing?
04:39:27 <Baughn> Olathe: I've got a ten-gigabit link here. I'm not insane. Stop annoying me, evil library writers.
04:39:36 <Olathe> Heheh
04:39:50 <ddarius> Baughn: You don't have to copy just because you are using message passing.
04:40:47 <quicksilver> Arnar: the best way is not to do it.
04:40:52 <quicksilver> Arnar: why do you want to do that?
04:41:04 <Axman6> quicksilver: printf debugging
04:41:12 <Arnar> quicksilver: what axman6 said
04:41:37 * Arnar waits to get kicked from #haskell
04:41:41 <Arnar> :P
04:42:01 <quicksilver> (the second best way is to use Debug.Trace)
04:42:10 <sclv> ?quote trace
04:42:10 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
04:42:24 <Arnar> oh..
04:42:27 <Arnar> didn't know about that
04:42:33 <Arnar> :t Debug.Trace
04:42:34 <quicksilver> I find in 99% of cases non-trace based debugging is superior to trace.
04:42:34 <lambdabot> Couldn't find qualified module.
04:42:50 <Baughn> :t Debug.Trace.trace
04:42:50 <lambdabot> forall a. String -> a -> a
04:42:55 <quicksilver> trace is a crutch, and if you always lean on it, you will never learn to dance.
04:43:08 <ejt> I feel I'm being lazy (in a bad way) when I resort to trce
04:43:14 <Arnar> quicksilver: sure.. I realize
04:43:18 <Baughn> Dancing is for the weak. Real programmers construct robots to dance for them
04:43:29 <Axman6> amn right
04:43:31 <Axman6> d*
04:43:43 <quicksilver> Baughn: I tried that once. The damn robot went to bed with the girl I was planning to dance with.
04:43:47 <quicksilver> Baughn: never again.
04:44:22 <Axman6> quicksilver: a true programmer's robot shares
04:44:36 <Saizan> that's what self-descruction buttons are for
04:44:54 <quicksilver> Axman6: it was the girl who didn't want to share.
04:45:03 <Arnar> quicksilver: that's why you don't give your robots reproductive organs
04:45:07 <Axman6> rawr, i wish mathematica's syntax didn't fuck so much
04:45:08 <Baughn> quicksilver: If your robot is properly made, it will kill and replace you, and nobody will ever notice
04:45:13 <Axman6> uh, suck even
04:46:31 <quicksilver> Baughn: How can you tell that isn't precisely what happened? ;)
04:46:43 <ddarius> quicksilver: Would it matter if it did?
04:47:12 <Arnar> hmm.. trace imposes a newline on its input
04:48:18 <Baughn> @dice  64d2
04:48:19 <lambdabot> 64d2 => 95
04:48:30 <Baughn> @dice  64d2
04:48:30 <lambdabot> 64d2 => 94
04:48:56 <quicksilver> Arnar: true. This is because output is often line-buffered.
04:49:02 <quicksilver> Arnar: at least, I guess that's why.
04:50:22 <Arnar> quicksilver: makes sense
04:56:15 <ketil> how should I format URLs in the .cabal file to placate Haddock?
04:56:37 <dcoutts_> ketil: <url> is the haddock syntax iirc
04:56:46 <dcoutts_> check the haddock manual to be sure
04:57:41 <ketil> I thought I had that: haddock: parse error in doc string: [TokPara,TokString "The Darcs repository is at: ",TokURL "http://malde.org/~ketil/biohaskell/biolib"]
04:58:00 <ketil> (or could it be the URL on the next line that is the problem?)
04:58:59 * ketil checks the manual again.
05:03:09 <ketil> dcoutts, Oh, it was a slash on the line above.  (sigh.  Slashes should have been left alone, I think.  Too common in text)
05:03:17 <Axman6> urgh, mathematica sucks at recursion
05:03:40 <quicksilver> > fix ("mathematica sucks at "++)
05:03:41 <lambdabot>   "mathematica sucks at mathematica sucks at mathematica sucks at mathematica...
05:03:45 <dcoutts_> ketil: in haddock-0.9 I think it was fixed so that isolated / are ignored, only /foo/ for italic.
05:04:08 <dcoutts_> ketil: no idea what haddock-2 does, and maybe hackage uses older code. No idea.
05:05:06 <ketil> This was on my installation, so it's likely an old haddock.
05:05:15 <Axman6> quicksilver: it's pretty good at matrix multiplication
05:05:36 <ketil> It seems nearly every problem I encounter is caused by outdated software....
05:05:41 <quicksilver> Axman6: just messing around :)
05:05:49 <Axman6> i know :)
05:06:09 <Axman6> it's also true though. it's a real pain to use. luckily i got it for free from uni
05:06:24 <ketil> I got haddock 0.8 from 2006.  Time to upgrade, I guess :-)
05:08:24 <Axman6> it is fun taking a 3000x3000 and taking it to the power of 1000 in just a few seconds
05:09:00 <quicksilver> > (3000*3000) ^ 1000
05:09:02 <lambdabot>   174787125172265160965997461916466057052906248743518851781188801181068626622...
05:09:04 <quicksilver> haskell can do that too :P
05:09:16 <jacobian_lpt> I have a term language with errors,  I want to be able to use do notation, but it seem I can only do that if I use some parameterised type.  Is there any way to have an error type directly in a term language so that I can use do notation?
05:09:44 <Axman6> quicksilver: uh, forgot to say matrix in there ;)
05:09:54 <quicksilver> Axman6: oh, I see :)
05:10:01 <quicksilver> Axman6: maybe you can do that with hmatrix. I'm not sure.
05:10:08 <Axman6> possibly
05:10:16 <Axman6> i couldn't get it installed though :\
05:10:43 <Saizan> jacobian_lpt: term language?
05:11:48 <jacobian_lpt> Saizan: For some programming language.  It's a data type with a constructor for each form in the term language.
05:12:29 <Axman6> ah that's right, hmatrix installed, and segfaulted whenever i tried to run the tests
05:12:38 <Saizan> jacobian_lpt: so the problem is writing a Monad instance for it?
05:13:06 <jacobian_lpt> Saizan: Yes
05:14:16 <Saizan> jacobian_lpt: so yes, it must be of the form data Term a = .., but maybe you can use a wrapper that simply ignores 'a'
05:15:45 <Saizan> jacobian_lpt: better to show us this datatype if you can :)
05:18:10 <jacobian_lpt> data Term = Var String | App Term Term | Abs String Term | Error
05:18:12 <jacobian_lpt> something like that
05:23:29 <jacobian_lpt> I guess I can change it to data Term = Var String | App (Maybe Term) (Maybe Term) ... etc
05:24:17 <jacobian_lpt> And then actually deal with Maybe Term for evaluation instead of Term
05:24:18 <Arnar> Weird, on amazon.com, RWH's "customer buy this book with" companion book is a novel, follow-up on some Baroque Cycle triology.. :)
05:24:24 <desp> Is there a way to export all constructors of a type without listing them?
05:24:28 <Myoma> jacobian_lpt: I found that omitting the Var String, and using Abs (Term -> Term) is far simpler and more elegant
05:24:38 <Myoma> desp: yes, Maybe(..)
05:24:43 <desp> Myoma: thx.
05:25:34 <quicksilver> Myoma: Abs?
05:25:52 <Myoma> quicksilver: re.  <jacobian_lpt> data Term = Var String | App Term Term | Abs String Term | Error
05:25:57 <Myoma> presumably short of Abstraction
05:26:14 <quicksilver> ah.
05:26:48 <quicksilver> well Abs (Term -> Term) is hard to introspect
05:26:52 <quicksilver> although convenient in some respects.
05:27:08 <jacobian_lpt> I need introspection
05:30:23 <EvilTerran> jacobian_lpt, in that case, you're gonna need to hang onto a concrete parse tree all the time
05:32:45 <Myoma> No, It's not hard to introspect
05:33:13 <Myoma> you can do things like  foo (Abs m) = \x -> foo (m x) to recurse
05:34:51 <Myoma> conal has a paper about this stuff if you don't believe me :)
05:36:34 <Myoma> anyway, it saves you reimplementing scope to the end of your days
05:36:57 <ejt> Myoma: do have a reference for that paper ?
05:37:17 <noohgodno> ?
05:38:05 <Myoma> ejt, there are lots of fun papers about higher order abstract syntax
05:41:19 <ejt> Myoma: ok, I'll go on a trawl
05:42:20 <Myoma> it is very often used in thereom provey stuff
05:42:47 <Myoma> but you can parse it from text and do lazy evaluation on it too
05:49:25 <jacobian_lpt> Myoma, do you do Letrec (Term -> Term) and use a fixed point combinator on the function?
05:54:51 <desp> Has anyone tried doing layout-style parsing with Parsec?
05:55:12 <zaarg> No.
05:56:02 <desp> zaarg: do you know if it would be possible?
05:58:44 <Axman6> hmm, anyone got hmatrix working on OS X?
05:59:36 <ivanm> Axman6: there's a page on the wiki by Cale (IIRC) about getting it working
05:59:46 <Axman6> ok, cheers
05:59:48 <Cale> not by me
06:00:22 <ivanm> http://www.haskell.org/haskellwiki/GSLHaskell_on_MacOS_X
06:00:32 <lambdabot> Title: GSLHaskell on MacOS X - HaskellWiki
06:00:36 <Cale> (I was only an OS X user for a couple months at work, and that was years ago now :)
06:01:22 <ivanm> someone needs to s/GSLHaskell/hmatrix/ on the wiki though...
06:01:34 <ivanm> Cale: hmmm... could have sworn I saw your name there the other day :s
06:24:13 <Myoma> to be a good C++ programmer is to endless rewrite the STL?
06:25:42 <Myoma> I'm reading a big C++ program, it's kind of scary :(
06:26:11 <dcoutts_> poor Myoma
06:27:38 <Axman6> C++ is ont of the most ugly languages i've ever seen, and that annoys me a lot
06:27:54 <Wild_Cat> what, don't like bitshifting for I/O? :p
06:27:56 <Axman6> :: looks terrible in code
06:28:12 <Wild_Cat> stateful bitshifting, even.
06:28:29 <lilac> Axman6: it's just a matter of getting used to it IMO
06:28:51 <Axman6> probably
06:29:11 <Wild_Cat> and code generation. And just about every stupid corner-case concept ever mentioned in OO contexts. Yay for "friend".
06:29:14 <Axman6> but i can usually follow simple C programs pretty easily, but not C++
06:29:36 <dreixel> same here
06:29:50 <dreixel> I always found C++ more confusing
06:30:02 <dreixel> than C or, say, Java
06:30:04 <lilac> Wild_Cat: are there any mainstream OO languages /without/ friend-like functionality?
06:30:12 <nanothief> well I learnt c++ before c, and didn't realise that << and >> operators were bitshifting operators until later on
06:30:21 <Wild_Cat> lilac: every single one of them that isn't C++.
06:30:25 <nanothief> now when I see << and >> used for bitshifting, it looks strange to me
06:30:36 <lilac> Wild_Cat: umm? Java has package-local, which is the same thing in a different outfit
06:30:41 <Wild_Cat> Java, C#, Objective-C, Ruby, you name it, it don't got it.
06:30:51 <Axman6> yeah, java is actually not a bad language imo. quite clear, and people tend to name things well, so you don't get that many 3 letter functions/methods
06:30:54 <lilac> Wild_Cat: Python has it, implicitly
06:31:16 <Myoma> I don't know C++ well
06:31:53 <Axman6> nanothief: i did not know that, that's messed up imo
06:32:00 <lilac> Axman6: I don't understand the point of Java. If you need down-to-the-metal control, it's no good. If you don't, why not use a more powerful language?
06:32:02 <Axman6> how's that even work?
06:32:20 <Axman6> lilac: libraries? :\
06:32:35 <nanothief> Axman6: what do you mean?
06:32:53 <Axman6> nanothief: about what, the messed up bit?
06:32:59 <Axman6> referring to the bitshifting
06:33:27 <lilac> Axman6: Python, Ruby, Haskell, C#, etc. all have libraries comparable to Java's, IMO.
06:33:54 <Axman6> haskell gui libraries?
06:34:02 <Wild_Cat> lilac: it's a bit more complicated. Python works with the idea that "we're all consenting adults". Everything's public and as a result you expect it. It doesn't feel anywhere near as hackish as "friend".
06:34:20 <maltem> Axman6: Well, Java GUI libraries?
06:34:23 <lilac> Axman6: it works by operator overloading. imagine you had "class LeftShift a b r | a b -> r where (<<) :: a -> b -> r", and you're on the right track.
06:34:26 <Baughn> Axman6: Gtk2hs?
06:34:27 <Axman6> i know there's gtk2hs, but, well gtk has never been something i've had good feelings about
06:34:56 <Baughn> Axman6: Right. Then, java GUI libraries?
06:34:59 <lilac> Wild_Cat: not as hackish? mangling __foo to __ClassName_foo sounds like the very definition of hackish to me
06:34:59 <Axman6> maltem: there's plenty, with very simple interfaces in many cases
06:35:17 <Axman6> like all the swing stuff
06:35:52 <Wild_Cat> lilac: unlike what a lot of people think, __foo was never intented to be used as a substitute for "private". It's there to solve the problem of attribute collisions in multiple inheritance.
06:35:58 <EvilTerran> lilac, or just "class LeftShift a where (<<) :: a" if you want to stay h98
06:36:27 <lilac> EvilTerran: doesn't that give you ambiguity? i'd think you'd need the fundep in practice?
06:36:35 <EvilTerran> although i don't think the instance would be h98
06:36:43 <Wild_Cat> the canonical "private" way in Python is _var. Which doesn't do anything, mind, but when other programmers see the leading underscore they interpret it as "internal implementation artifact, likely to change, you're on your own if you touch it"
06:38:07 <lilac> Wild_Cat: except that _var doesn't work in practice (it leads to the brittle base class problem). this has bitten me only twice, but both times it was completely bizarre
06:38:08 <maltem> Axman6: hm... that's a Java-only GUI implementation?
06:38:10 <EvilTerran> lilac, you'd run into overlaps if you had an "instance Integral a => LeftShift (a -> a -> a)@ or something, say
06:38:20 <EvilTerran> lilac, but that would happen with yours, too
06:38:52 <EvilTerran> "instance Integral a => LeftShift a a a" would be undecidable, too
06:39:02 <Axman6> maltem: i don't really know, having not used it very much. the stuff we're using atm are JFrames
06:39:41 <Axman6> which i believe are part of javax.swing
06:39:42 <lilac> EvilTerran: sure. i was more thinking that "instance LeftShift (Int -> Int -> Int)" would leave (42::Int) << (3::Int) as LeftShift Int Int a => a, rather than Int
06:39:58 <lilac> sorry, LeftShift (Int -> Int -> a) => a
06:40:16 <EvilTerran> hm...
06:41:19 <EvilTerran> similarly, you'd run into some trouble with the fundep if one of the parameters is polymorphic
06:42:13 <EvilTerran> and it might not be a valid fundep, anyway - people might want different return types for the same parameter types :P
06:42:19 <lilac> yeah, it's no panacea. but then again, overloading (<<) in the C++ iostreams way is not such a good idea in Haskell anyway...
06:42:37 <EvilTerran> it'd be downright daft in haskell
06:42:53 <lilac> sure. but to be C++-like, the fundep is appropriate, since that's the way C++ overloads work
06:43:02 <EvilTerran> because haskell typeclass methods tend to have rigorous semantics all instances must adhere to
06:45:39 <Baughn> EvilTerran: Printf.
06:45:57 <EvilTerran> Baughn: is a hack or seven. :P
06:45:59 <Baughn> ..unless you're going to argue that that thing is downright daft
06:46:07 <EvilTerran> bingo! :P
06:46:37 <EvilTerran> i'm sure you could devise fairly reasonable and consistent semantics for printf
06:46:46 <EvilTerran> more so than a << that was both bitshifting and piping
06:47:15 <lilac> what's so wrong with "sprintf :: FormatString -> [forall a. Printable a => a] -> String" (apart from the existential)
06:47:47 <Baughn> "cout << 2 << 3" <-- So, what does this print?
06:48:37 <EvilTerran> Baughn, that depends on the associativity of <<. it sounds like you're agreeing with me.
06:48:50 <Baughn> EvilTerran: About the insanity of C++? Always.
06:48:50 <lilac> Baughn: (assuming this is C++ and cout is std::cout) it depends on the formatting flags of the stream
06:49:47 <EvilTerran> i think that the main reason some people have an irrational hatred of custom operators is because they expect something like C++'s operator overloading
06:50:13 <EvilTerran> in which things with established semantics (eg, + is usually commutative) are merrily overridden without preserving those semantics
06:50:25 <EvilTerran> (eg, + for string concatenation)
06:50:42 <MyCatVerbs> That's not fantastically evil.
06:51:05 <EvilTerran> if you say so
06:51:08 <MyCatVerbs> It's (+) without associativity that *really* screws with peoples' heads. Like + for in-place concatenation. :)
06:51:18 <EvilTerran> yeah
06:51:37 <EvilTerran> but it all stems from there being no "contract" associated with the name '+'
06:51:48 <MyCatVerbs> Well. It's a judgement call. Personally, I read (+) as `mappend` in C++, rather than (+).
06:51:52 * MyCatVerbs nods.
06:52:04 <EvilTerran> while good OO'ers tend to have such contracts for their alphanumeric names of choice
06:52:05 <lilac> EvilTerran: coming from a C++ background, I had an irrational dislike of custom operators because (1) I have enough trouble with precedence and associativity as it is, (2) they probably aren't as readable as wordy operators would be, (3) they're a finite namespace so overloading is almost inevitable
06:52:17 <MyCatVerbs> Right. Like how bit-shifting isn't for printing arbitrary goddamn objects. :)
06:52:22 <EvilTerran> they're not finite!
06:52:38 <nanothief> I think the main problem occurs when people don't use operators reasonably, I never found string contatenation with + confusing
06:52:41 <MyCatVerbs> They're not in Haskell, they are in C++.
06:52:45 <lilac> EvilTerran: >4 characters is getting very very silly
06:53:00 <nanothief> ruby goes a lot further, such as "this" * 4 = "thisthisthisthis"
06:53:08 <EvilTerran> ?let x <!$%^&*> y = var "there's a countable infinity of operators in haskell" in 1 <!$%^&*> 2
06:53:09 <lambdabot>   Parse error
06:53:11 <lilac> EvilTerran: and meaningful ones certainly are finite.
06:53:15 * Baughn used ..+.. for matrix concatenation just yesterday..
06:53:23 <EvilTerran> anyway, i must be off
06:53:28 <pgavin> > let a @<+++>@ b = 2 * a + b in 5 @<+++>@ 10
06:53:30 <lambdabot>   20
06:53:38 <MyCatVerbs> lilac: now that's a pain, even in Haskell. How many definitions of (<*>) can there even *be*? :)
06:53:54 <Axman6> Baughn: concatenation? not addition?
06:54:23 <Axman6> my first comp lecturer would be furious with you ;)
06:54:45 <lilac> to be honest, i don't think my dislike is irrational. when i see an expression using (***), (&&&) and (>>>) with no parentheses, i have real troulbe working out what's going on
06:54:52 <lilac> this is not a way to write readable code
06:55:27 <Baughn> Axman6: I was already using ..&.. for addition
06:55:31 <Baughn> Feel free to shoot me now
06:55:57 <Axman6> -_-
06:56:59 <lilac> the situation wouldn't be so bad if haskell didn't reserve "',[]{}()|\ and sometimes ! for its own purposes
06:57:19 <lilac> that's most of the useful punctuation gone
06:57:27 <BeelsebobWork> indeed
06:57:39 <lilac> oops, forgot :
06:57:52 <lilac> (in the sometimes column)
06:58:12 * Baughn is currently in a lecture, looking at the mathematica code that's supposedly equivalent to his own haskell code. Happily, it's about five times larger.
06:58:36 <Axman6> yeah, mathematica has terrible syntax :\
06:58:44 * BeelsebobWork giggles at the iPhone app he's busy writing
06:58:45 <im_alone> @google Theorem Prover
06:58:50 <lambdabot> http://en.wikipedia.org/wiki/Automated_theorem_proving
06:58:50 <lambdabot> Title: Automated theorem proving - Wikipedia, the free encyclopedia
06:59:00 <BeelsebobWork> it's Haskell, disguised as a graphic calculator
06:59:02 <Axman6> it's powerful, sure, but...
06:59:33 <Axman6> BeelsebobWork: when will you have ghc powted to the iPhone already?
06:59:45 <Baughn> The syntax is one thing. Most of their code is in fiddling with variables, instead of just making new ones.. of course, it has no convenient functions for deriving new values..
07:00:01 <BeelsebobWork> Axman6: I'm not planning on porting ghc
07:00:07 <BeelsebobWork> in reality the language isn't haskell
07:00:13 <Baughn> "I toggle this bit. Then I print f(thingy). Then I toggle it back."
07:00:13 <BeelsebobWork> it's a somewhat smaller language that's very similar
07:01:04 <BeelsebobWork> Axman6: it drops things like lists that really don't need to be part of the language
07:01:16 <BeelsebobWork> tuples are gone too
07:01:20 <Baughn> BeelsebobWork: Does it have matrixes?
07:01:29 <BeelsebobWork> Baughn: nope, no need for them to be part of the language again
07:01:46 <Axman6> BeelsebobWork: i believe it was just requested ;)
07:01:52 <BeelsebobWork> haha
07:02:18 <BeelsebobWork> I never understood why lists/tuples were actually part of Haskell, rather than part of it's prelude
07:02:31 <lilac> nicer syntax?
07:02:31 <BeelsebobWork> lists I can almost understand in terms of the syntactic sugar you gain
07:03:12 <BeelsebobWork> but then, Monads aren't part of the language
07:03:19 <Baughn> BeelsebobWork: Hysterical raisins
07:03:20 <BeelsebobWork> yet there's syntactic sugar for them
07:03:32 <lilac> to be honest, data Pair a b = a , b would be fine IMO
07:03:42 <BeelsebobWork> lilac: absolutely, and much more consistant
07:03:47 <lilac> or even data a, b = a, b :)
07:03:54 <BeelsebobWork> yeh
07:04:12 <quicksilver> I presume the reason is "efficient" implementation of n-tuples for arbitrary n
07:04:14 <lilac> BeelsebobWork: , would need to be treated as uppercase like :, but i think that's OK :)
07:04:16 <BeelsebobWork> and with a bit of further extending the syntax data [a] = a : [a] | []
07:04:18 <maltem> I think Agda2 allows to do it this way
07:04:21 <quicksilver> I'm not saying I find that totally consistent.
07:04:27 <quicksilver> or convincing.
07:04:44 <BeelsebobWork> quicksilver: yeh, I think it is
07:04:51 <BeelsebobWork> the lack of bottoms lets you do more optimisation
07:05:06 <lilac> couldn't 'data a, b = a, !b' be implemented the same as current n-tuples?
07:05:10 <BeelsebobWork> but then, why not have efficient implementations of n-arry type constructors
07:05:19 <BeelsebobWork> instead of special ones for tuples
07:05:31 <quicksilver> n-ary type constructors are fine.
07:05:33 <quicksilver> nested ones are not.
07:05:37 <BeelsebobWork> exactly
07:05:44 <quicksilver> it's getting tuples without nesting that needs special casing
07:05:54 <BeelsebobWork> the point is that you can implement current tuples using n-arry type constructors
07:06:06 <quicksilver> but you can't define all of them in finite space
07:06:08 <BeelsebobWork> (although without quite the same syntax)
07:06:13 <BeelsebobWork> that's true
07:06:21 <lilac> what's wrong with using right-strict pair?
07:06:25 <BeelsebobWork> but that just highlights whats wrong with them quicksilver
07:06:37 <BeelsebobWork> in that we also can't define zipN in finite space
07:06:40 <BeelsebobWork> for arbitrary ns
07:06:49 <BeelsebobWork> lilac: good question
07:07:09 <Botje> you can,t make it a functor? *guess*
07:07:21 <quicksilver> BeelsebobWork: quite.
07:07:44 <quicksilver> BeelsebobWork: The only time I ever use tuples where n > 2 is in "Static data"
07:07:45 <lilac> Botje: possibly. (i forget whether the functor laws allow strictness)
07:08:00 <quicksilver> BeelsebobWork: typically as a kind of generic syntax thing, bit like lispers do.
07:08:26 <BeelsebobWork> lilac: better yet, by doing that and making , right associative, you keep the current syntax
07:08:35 <lilac> BeelsebobWork: indeed :)
07:08:53 <lilac> except you can drop the parens in some cases
07:08:57 <BeelsebobWork> indeed
07:09:00 <BeelsebobWork> which is rather lovely tbh
07:09:17 * lilac considers doing some GHC hacking
07:09:21 <BeelsebobWork> hehe
07:09:30 <BeelsebobWork> not sure it's much hacking to *remove* a language feature
07:09:40 <BeelsebobWork> all you need to do is a tiny amount of implementation in the Prelude
07:09:48 <quicksilver> you have to think about the other times , is used, though.
07:09:48 <lilac> well, you need to move ',' to the same category as ':' in the lexer too
07:09:59 <BeelsebobWork> lilac: oh yeh, good point
07:10:04 <quicksilver> record syntax is the only one springing to mind at the moment.
07:10:08 <BeelsebobWork> lilac: unless you define (,) as a function
07:10:09 <maltem> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100)
07:10:10 <lambdabot>       A 100-tuple is too large for GHC
07:10:11 <lambdabot>        (max size is 62)
07:10:11 <lambdabot>        Workaro...
07:10:15 <BeelsebobWork> that happens to produce a pair
07:10:20 <BeelsebobWork> uh, but then you can't pattern match
07:10:21 <BeelsebobWork> so that fails
07:10:23 <sjanssen> lilac: (a, (b, c)) will occupy more memory than (a, b, c)
07:10:32 <BeelsebobWork> sjanssen: not if it's right strict
07:10:33 <lilac> BeelsebobWork: also, it'll break (,,)
07:10:33 <sjanssen> (GHC can't unpack polymorphic fields)
07:10:37 <BeelsebobWork> then it can be unboxed
07:10:41 <maltem> (so much for arbitrary-n tuples)
07:10:42 <BeelsebobWork> lilac: oh, so it would
07:10:46 <sjanssen> BeelsebobWork: nope, GHC can't do that
07:10:50 <quicksilver> maltem: *nod* ;)
07:10:52 <BeelsebobWork> sjanssen: it can't?
07:10:54 <BeelsebobWork> that's lame
07:10:56 <BeelsebobWork> :(
07:11:17 <BeelsebobWork> I guess it makes sense though
07:11:33 <BeelsebobWork> it requires specialising it when you know what the types are
07:11:44 <BeelsebobWork> which sounds as inefficient as just using the extra memory
07:12:17 <lilac> quicksilver: re uses of ',', there's also fundeps, "a, b, c :: Foo", and possibly others.
07:12:33 <quicksilver> lilac: that's in not in value-position though.
07:12:39 <quicksilver> lilac: so that's OK. I think.
07:12:55 <quicksilver> lilac: I should say 'expression-position'
07:13:17 <lilac> i've not looked at GHC's parser, but i could believe that.
07:13:27 <BeelsebobWork> lilac: as a side benefit, this also frees up , as a character that can be used in infix operators
07:13:37 <quicksilver> BeelsebobWork: to my mind that's the main benefit :)
07:13:52 <BeelsebobWork> quicksilver: it's not bad, no
07:14:06 <Myoma> @@ @run (@run fun . ("("++) . (++")") . tail . init . show $ [1..100] :: Expr)
07:14:07 <lambdabot>   mueval: Prelude.read: no parse
07:14:15 <Myoma> @@ (@run fun . ("("++) . (++")") . tail . init . show $ [1..100] :: Expr)
07:14:16 <lambdabot>   (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:14:30 <Myoma> @@ @run (@run fun . ("("++) . (++")") . tail . init . show $ [1..100] :: Expr)
07:14:31 <lambdabot>   mueval: Prelude.read: no parse
07:14:34 * thoughtpolice went to the school library yesterday and checked out a copy of TAPL and spj's book :]
07:14:40 <BeelsebobWork> lilac: feel like proposing it as a Haskell' feature?
07:14:42 <thoughtpolice> they even had some miranda books I was considering looking at :]
07:14:49 <BeelsebobWork> I'm not sure it actually breaks backwards compatability at all
07:14:58 <thoughtpolice> and lots of collections of journal papers on functional programming, I saw ChilliX in there a few times
07:15:28 <lilac> BeelsebobWork: possibly. i think they want a working implementation first, though? plus it does break (,,) etc
07:15:42 <BeelsebobWork> lilac: how does it break (,,)?
07:15:57 <quicksilver> I think haskell's lexical syntax is probably at a local sweetspot.
07:16:04 <quicksilver> It has limitations but they all have reasons.
07:16:13 <quicksilver> I think if you want to fix them, you want to start with a clean slate
07:16:16 <quicksilver> (like agda)
07:16:41 <quicksilver> maybe with a more modular GHC it will be easier to imagine a totally distinct frontend?
07:16:47 <BeelsebobWork> quicksilver: yep, which is how this discussion started -- I'm starting with a clean slate and implementing something haskell-like for iPhone
07:17:01 <lilac> BeelsebobWork: "(,,)" would mean "the data constructor called ',,'", and not "\x y z -> x, y, z"
07:17:05 <quicksilver> not in the sense of a different language, but a clean slate lexical syntax for haskell
07:17:09 <BeelsebobWork> lilac: oh, so it would
07:17:11 <BeelsebobWork> duh
07:17:21 <Myoma> lilac: is there a difference?
07:17:32 <BeelsebobWork> Myoma: there is in this proposal, yes
07:17:40 <quicksilver> Myoma: in lilac's world, yes: ,, would be defined by the user
07:17:43 <quicksilver> however he wished
07:17:46 <BeelsebobWork> a ,, b would be a piece of data
07:17:47 <Myoma> ah ok
07:17:50 <quicksilver> it might or might not have arity three, for example.
07:17:51 <Myoma> and [] as well I hope?
07:18:05 <lilac> also the latter is currently illegal, since you need the parens
07:18:16 <BeelsebobWork> lilac: indeed
07:18:33 <BeelsebobWork> but I *did* think it didn't make any previously legal haskell illegal, but as you pointed out, it does
07:18:35 <quicksilver> lilac: , in lists of course :)
07:18:45 <lilac> quicksilver: yeah, just got there myself :)
07:18:45 <quicksilver> lilac: I knew there was another big place , was used.
07:18:46 <Myoma> @farmer
07:18:46 <lambdabot> I've got a card in my hole.
07:18:50 <BeelsebobWork> quicksilver: I tihnk that can reasonably remain syntactic sugar
07:18:50 <Myoma> @farmer
07:18:50 <lambdabot> I really took the bull by the hands.
07:18:57 <Myoma> I love this set
07:19:03 <BeelsebobWork> oh, wait, no it couldn't
07:19:04 <quicksilver> BeelsebobWork: how would you distinguish [(a,b)] and [a,b]
07:19:07 <BeelsebobWork> indeed
07:19:08 <sjanssen> lilac, quicksilver: also list comprehensions and records
07:19:08 <quicksilver> (values not types)
07:19:15 <lilac> quicksilver: [] :: a, b -> a:[b] ?
07:19:26 <lilac> hmm
07:19:55 <sjanssen> if you really want to do this, just use a different symbol
07:20:14 <sjanssen> and it will even be compatible with mainstream Haskell
07:20:24 <BeelsebobWork> true dat
07:20:31 <lilac> sjanssen: part of the point is that all the good symbols are taken
07:20:40 <sjanssen> :*: is not so bad
07:20:53 <BeelsebobWork> but yeh, one of the points was to reclaim , as being usable in an infix operator sjanssen
07:21:35 <lilac> ok, so we'd need to lose [a,b,c] as sugar if we did this. that's probably argument enough against it to be honest
07:21:40 <BeelsebobWork> tbh, I hate the fact that lists are "special" in Haskell too
07:21:47 <BeelsebobWork> so I'm quite happy with losing [a,b,c]
07:21:54 <Myoma> lilac: I wouldn't miss [a,b,c]
07:22:06 <Myoma> I don't even mind a :: b :: c :: nil
07:22:19 <BeelsebobWork> it's not like (a:b:c:[]) is really that much less clear
07:22:56 <Myoma> (I never write programs which are primarily setting out lists)
07:22:59 <osfameron> yeah, and strings are just sugar too, what's wrong with 'h':'e':'l':'l':'o':[] anyway
07:22:59 <lilac> would it be possible to implement "class BuildList xs x | xs -> x where [] :: xs -> x", such that ([]) (a, b, c) -> a:b:c:nil ?
07:23:14 * lilac could imagine grammar rules which would allow writing that as [a,b,c]
07:23:25 <Myoma> osfameron: _that_ I would not like to cope with
07:23:34 <lilac> [] :: xs -> [] x, sorry
07:23:46 <BeelsebobWork> osfameron: the point is that "hello" doesn't actually break with the (,) syntax we're proposing
07:23:54 <BeelsebobWork> so that sugar would happily remain
07:24:13 <BeelsebobWork> while [a,b,c] would be rewritten to (a:b:c:[])
07:24:40 <BeelsebobWork> lilac: I'd rather not make lists any more special tbh
07:24:49 <BeelsebobWork> I'd rather make them less special
07:25:00 <lilac> BeelsebobWork: sure. but if we're reclaiming [] too, then user-defined bracketing would be nice
07:25:18 <Myoma> there is a lot of talk about fixing haskell syntax
07:25:23 <BeelsebobWork> lilac: well the suggestion I'm making doesn't actually involve reclaiming [], but that would be nice too
07:25:24 <Myoma> I wish somebody would _do it_
07:25:48 <BeelsebobWork> Myoma: I believe lilac is thinking about doing it -- he's trying to hash out exactly what he *is* doing though
07:26:24 * osfameron wouldn't personally like to lose [list,syntax]
07:26:43 <ddarius> Everyone is like "I wish I could do this."  Then they actually think through the consequences or start implementing and ar like "Maybe this wasn't such a good idea."
07:26:45 <osfameron> though I guess this would be an optional extension rather than a default?
07:26:47 <lilac> Reclaiming [] has other problems, like losing [| as a reserved thingy.
07:27:07 <Olathe> @hoogle [a] -> [(a, a)]
07:27:08 <quicksilver> lilac: unless [| becomes a 'user-defined bracket'
07:27:08 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
07:27:08 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
07:27:08 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
07:27:15 <quicksilver> lilac: which just happens to have a built-in definition.
07:27:30 <Olathe> How do you get [1, 2, 3, 4, ..] -> [(1, 2), (3, 4), ...] ?
07:27:47 <Myoma> Olathe: recursion!
07:27:51 <Olathe> Heheh.
07:27:54 <lilac> Olathe: looks like a zip to me
07:27:55 <quicksilver> ddarius: Yes, most of the haskell lexical limitations have good reasons.
07:28:02 <quicksilver> ddarius: that's what I meant about local sweet spot
07:28:09 <Olathe> Oh, it's sort of an inverse to a zip.
07:28:12 <quicksilver> ddarius: you need to move some distance to get to somewhere else which is good.
07:28:27 <BeelsebobWork> lilac: conal just pointed out a slight problem
07:28:30 <Axman6> Olathe: well, split and zip
07:28:38 <BeelsebobWork> (x,[1..]) would become an infinite computation
07:28:46 <Olathe> > let f a:b:xs = (a, b):f xs; f _ = [] in f [1..]
07:28:47 <lambdabot>   mueval: Prelude.read: no parse
07:28:50 <BeelsebobWork> the solution is to end all n-tuples with a unit type
07:28:51 <Myoma> Olathe: well [(1, 2), (3, 4), ...] -> [1, 2, 3, 4, ..] is easy right? concatMap (\(x,y) -> [x,y])
07:28:55 <Olathe> > let f (a:b:xs) = (a, b):f xs; f _ = [] in f [1..]
07:28:56 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
07:28:58 <BeelsebobWork> so it would become (x,[1..],())
07:29:02 <Myoma> Olathe: So you just got to invert that
07:29:07 <quicksilver> Olathe: I find "groupOf n" a useful primitive.
07:29:07 <lilac> BeelsebobWork: really? isn't it x, (1:<thunk>)?
07:29:16 <Olathe> > groupOf 2 [1..]
07:29:17 <lambdabot>   mueval: Prelude.read: no parse
07:29:27 <quicksilver> Olathe: given groupsOf, your function is map (\[a,b] -> (a,b)) . groupsOf 2
07:29:27 <BeelsebobWork> lilac: oh, yes, but still, that's more evaluation than would normally happen
07:29:40 <Olathe> > groupsOf 2 [1..]
07:29:41 <lambdabot>   mueval: Prelude.read: no parse
07:29:43 <lilac> BeelsebobWork: actually, x, <thunk>:<thunk> :)
07:29:45 <Olathe> Ahh, OK.
07:29:47 <quicksilver> Olathe: groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
07:29:51 <Olathe> Thanks.
07:29:53 <cantor> could someone help me with a problem:
07:29:54 <cantor> http://pastebin.com/m7e78120c
07:29:54 <BeelsebobWork> lilac: okay, (x,error "splode")
07:30:05 <cantor> why i cannot load the module?
07:30:14 <Myoma> yep following quicksilver,
07:30:15 <Myoma> y = concatMap (\(x,y) -> [x,y]) x
07:30:15 <Myoma> y = concat . map (\(x,y) -> [x,y]) $ x
07:30:15 <Myoma> groupsOf 2 $ y = map (\(x,y) -> [x,y]) $ x
07:30:15 <Myoma> map (\[x,y] -> (x,y)) . groupsOf 2 $ y =  x
07:30:20 <lilac> BeelsebobWork: i see the problem, yes :)  ending with a unit is a pain, though :(
07:30:27 <BeelsebobWork> indeed it is :(
07:30:31 <conal> BeelsebobWork: i was thinking of an example like (1,undefined)
07:30:39 <BeelsebobWork> conal: yeh, my bad
07:30:39 <quicksilver> cantor: what is the error message?
07:30:46 <quicksilver> cantor: (always paste the error message too)
07:31:02 <cantor> quicksilver: ghci says:Failed, modules loaded: none.
07:31:16 <quicksilver> cantor: that is not the error message.
07:31:39 <cantor> quicksilver: Not in scope: `d'
07:31:57 <quicksilver> cantor: interesting.
07:32:05 <quicksilver> I don't think your file can be what you pasted.
07:32:12 <quicksilver> the file you pasted doesn't have any 'd' in it
07:32:20 <cantor> i know^^
07:32:31 <ejt> cantor: what you pasted works here
07:32:34 <maltem> except for the d in "module"
07:33:01 <cantor> maybe a problem with ghci?
07:33:13 <quicksilver> cantor: your file loads fine in my ghci.
07:33:19 <lilac> cantor: sounds like the file ghci is loading is not the file you pasted
07:33:33 <cantor> i use textMate as editor
07:33:54 <lilac> is it possible that it's finding a file with the right name somewhere else?
07:33:59 <maltem> cantor: How are you loading the file? (Always paste what triggers the error message, too)
07:34:26 <cantor> maltem: /Users/raphaelholzinger/capter_1.hs:5:21: Not in scope: `d'
07:34:27 <cantor> Failed, modules loaded: none.
07:35:35 <maltem> cantor: That wasn't what I was asking for, but anyway, what does that file contain, on line 5, column 21?
07:35:36 <lilac> cantor: (silly question) have you definitely saved? (less silly question) are you running ghci on the same machine from which you saved?
07:35:38 <cantor> i m sure the solution is something very trivial but i haven't the slightest idea :-)
07:36:30 <cantor> lilac: yes i have
07:36:44 <cantor> maltem: a tab is there
07:36:45 <lilac> cantor: try running 'cat /Users/raphaelholzinger/capter_1.hs' in the terminal where you ran ghci; see if that gives the file contents you were expecting
07:37:14 <maltem> cantor: hm funny, try following lilac's advice
07:37:33 <cantor> ok
07:39:05 <cantor> hmm
07:39:31 <Axman6> bleh, hmatrix works fine now, and the benchmarks fail with malloc errors -_-
07:39:38 <chrisdone> http://hpaste.org/10220
07:39:47 <chrisdone> can I make this *not* explicitly recursive?
07:40:20 <cantor> lilac: it doesnt work
07:40:40 <lilac> cantor: can you be more specific about what goes wrong?
07:40:58 <cantor> lilac: Prelude> cat /Users/raphaelholzinger/capter_1.hs
07:40:58 <cantor> <interactive>:1:0: Not in scope: `cat'
07:40:58 <cantor> <interactive>:1:5: Not in scope: data constructor `Users'
07:40:59 <cantor> <interactive>:1:11: Not in scope: `raphaelholzinger'
07:40:59 <cantor> <interactive>:1:28: Not in scope: `capter_1'
07:40:59 <cantor> <interactive>:1:37: Not in scope: `hs'
07:41:01 <chrisdone> Myoma: do you think I could use fix or something?
07:41:04 <cantor> sorry for the spam
07:41:49 <maltem> cantor: you were supposed to type that as a shell command
07:41:56 <chrisdone> might make it more compilcated. I'm used to using folds but I don't think I can fit this into a fold
07:41:58 <Deewiant> chrisdone: not sure, but a little style note: concat . map f = concatMap f
07:42:14 <chrisdone> Deewiant: oh nice catch! :)
07:42:18 <lilac> cantor: i meant, run it outside ghci. alternatively, add :! to the start
07:43:57 <chrisdone> @pl (\a -> filter (not . null) [take n a, drop n a])
07:43:57 <lambdabot> filter (not . null) . ap ((:) . take n) (return . drop n)
07:44:38 <chrisdone> i get that code, but I dunno, it doesn't seem to capture the essense of what I'm doing
07:45:41 <Saizan> > splitAt 4 [1..10]
07:45:42 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
07:45:43 <lilac> @hoogle (a,a) -> [a]
07:45:43 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
07:45:43 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
07:45:43 <lambdabot> Prelude snd :: (a, b) -> b
07:46:00 <quicksilver> chrisdone: given some code which is hard to read, it is unsual for @pl to improve it :)
07:46:32 <Axman6> hmm, anyone know if ghc can compile 64 bit binaries on OS X?
07:46:49 <chrisdone> quicksilver: personally I don't find my version hard to read, just seems more than necessary. I'd like to have &&& but to return a list rather than a tuple :p
07:47:24 <Axman6> i'm getting "malloc: *** mmap(size=3170066432) failed (error code=12)"  when running the the hmatrix benchmarks
07:47:35 <Myoma> @let x & y = [x,y]
07:47:36 <lambdabot>  Defined.
07:47:41 <Axman6> (giving amazing times, for things that don't actually work)
07:47:42 <Myoma> > 1 & 2 & 4 & 4
07:47:43 <lambdabot>       No instance for (Num [t])
07:47:43 <lambdabot>        arising from the literal `4' at <inter...
07:47:45 <chrisdone> the feared & operator
07:47:50 <Deewiant> > catMaybes . uncurry (&) . join (***) listToMaybe . splitAt 4 $ [1..10]
07:47:51 <lambdabot>   mueval: Prelude.read: no parse
07:47:55 <Deewiant> :-(
07:48:03 <Myoma> > () & () & () & ()
07:48:04 <lambdabot>   Couldn't match expected type `[()]' against inferred type `()'
07:48:12 <BeelsebobWork> Axman6: who cares about correctness when you could have speed
07:48:13 <Axman6> Myoma: of course that wouldn't work
07:48:15 <Myoma> > (() & ()) & (() & ())
07:48:16 <lambdabot>   [[(),()],[(),()]]
07:48:19 <Axman6> x and y need to be the same type
07:48:34 <Axman6> and you end up with an [a] and a
07:52:25 <chrisdone> > splitAt 4 "thin lizzy"
07:52:26 <lambdabot>   ("thin"," lizzy")
07:52:41 <chrisdone> > uncurry (&) $ splitAt 4 "thin lizzy"
07:52:42 <lambdabot>   ["thin"," lizzy"]
07:52:55 <quicksilver> chrisdone: I found it hard to write line-breaking code, actually
07:53:02 <quicksilver> chrisdone: if you're interested I'll paste you my attempt
07:53:08 <quicksilver> chrisdone: (which takes account of width in a given font, too)
07:53:11 <quicksilver> it ain't elegant.
07:53:18 <chrisdone> sure
07:53:31 <chrisdone> font width isn't in this problem domain but I'll see anyway :p
07:54:21 <quicksilver> chrisdone: http://hpaste.org/10221
07:54:34 * chrisdone looks
07:54:46 <quicksilver> "initialwords" might be useful to you.
07:55:29 <Olathe> > ((^2) *** (^5)) (5, 5)
07:55:30 <lambdabot>   mueval: Prelude.read: no parse
07:55:35 <Olathe> What's wrong with that ?
07:55:52 <Olathe> @pl \(a, b) -> (a^2, a^5)
07:55:52 <lambdabot> liftM2 (,) (^ 2) (^ 5) . fst
07:56:04 <Olathe> @pl \(a, b) -> (a^2, a^2)
07:56:04 <lambdabot> liftM2 (,) (^ 2) (^ 2) . fst
07:56:13 <chrisdone> @let initialWords = (++[""]) . takeWhile (not.null) . iterate (reverse . dropWhile isSpace . dropWhile (not.isSpace) . reverse)
07:56:14 <lambdabot>  Defined.
07:56:15 <Olathe> Bah.
07:56:18 <Olathe> @pl \(a, b) -> (a^2, b^2)
07:56:18 <lambdabot> (^ 2) *** (^ 2)
07:56:29 <chrisdone> :t initialWords
07:56:30 <lambdabot> [Char] -> [[Char]]
07:56:40 <Olathe> > ((^2) *** (^2)) (5, 5)
07:56:41 <lambdabot>   mueval: Prelude.read: no parse
07:56:54 <Olathe> > (***)
07:56:55 <lambdabot>       Overlapping instances for Show
07:56:55 <lambdabot>                                  (a b c ...
07:56:58 <chrisdone> > initialWords "coi ro do mi nelci lo nu do nelci lo nu mi tavla fi lo du'u mo"
07:57:00 <lambdabot>   ["coi ro do mi nelci lo nu do nelci lo nu mi tavla fi lo du'u mo","coi ro d...
07:57:07 <chrisdone> hmm
07:57:12 <chrisdone> > initialWords "coi ro do mi nelci lo nu do nelci"
07:57:13 <lambdabot>   ["coi ro do mi nelci lo nu do nelci","coi ro do mi nelci lo nu do","coi ro ...
07:58:45 <chrisdone> > let s = "coi ro do ui" in initialWords s
07:58:46 <lambdabot>   ["coi ro do ui","coi ro do","coi ro","coi",""]
07:59:07 <chrisdone> > let s = "coi ro do ui" in inits . words $ s
07:59:08 <lambdabot>   [[],["coi"],["coi","ro"],["coi","ro","do"],["coi","ro","do","ui"]]
07:59:17 <chrisdone> > let s = "coi ro do ui" in tails . words $ s
07:59:18 <lambdabot>   [["coi","ro","do","ui"],["ro","do","ui"],["do","ui"],["ui"],[]]
07:59:26 <quicksilver> chrisdone: it's like inits.words but it tries hard to preserve whitespace
07:59:43 <quicksilver> I'm not sure why I thought that was important.
07:59:47 <quicksilver> I did at the time, though :)
07:59:51 <chrisdone> hehe
08:00:32 <chrisdone> hrm
08:01:18 <Svrog> chrisdone: where is list defined?
08:01:20 <chrisdone> so you would use length . initialWords to get the “rest”?
08:01:29 <chrisdone> @let list n f [] = n ; list n f xs = f xs
08:01:30 <lambdabot>  Defined.
08:01:32 <Svrog> ah
08:02:10 <chrisdone> > list ":(" head ["yay"]
08:02:11 <lambdabot>   "yay"
08:02:13 <chrisdone> > list ":(" head []
08:02:14 <lambdabot>   ":("
08:02:49 <chrisdone> pretty much `maybe' but for [a]
08:03:46 <BeelsebobWork> class Monad m => UnMonad m where unMonad :: a -> m a -> a?
08:03:47 <chrisdone> quicksilver: so you use initialWords in your code to get the first part, and use the length of the first part to get the “rest”
08:05:21 <chrisdone> BeelsebobWork: what would be a definition of UnMonad for [a]?
08:05:45 <quicksilver> chrisdone: yes, I do. Not very elegant, I know.
08:05:57 <BeelsebobWork> unMonad x [] = x; unMonad x (x:xs) = x
08:05:59 <BeelsebobWork> not ideal
08:06:16 <BeelsebobWork> so maybe the functional argument is necessary
08:06:33 <chrisdone> yeah. monads containing multiple values and ones containing one are a problem here :\
08:06:33 <quicksilver> BeelsebobWork: I think it's more elegant to factor these things through Maybe
08:06:44 <quicksilver> BeelsebobWork: since that's the "limit" of that pattern.
08:06:44 <BeelsebobWork> quicksilver: true
08:06:48 <quicksilver> or is it a colimit.
08:07:01 <maltem> BeelsebobWork: Also, is the Monad constraint stringent?
08:07:11 <quicksilver> :t maybe mzero return
08:07:12 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
08:07:30 <chrisdone> my definition of `list' above gives you the monadic value, so you can extract the value from it how you please (you are just guarenteed that it is not empty)
08:08:17 <BeelsebobWork> chrisdone: how about unknownName :: MonadZero m => m a -> (m (m a) -> m a) -> (m (m a)) -> m a
08:08:24 <chrisdone> unMonad :: a -> (m a -> a) -> a
08:08:28 <BeelsebobWork> although I guess then it makes sense to have a specialisation for join
08:08:54 <Olathe> > join (***) (*2) $ (5, 6)
08:08:55 <lambdabot>   mueval: Prelude.read: no parse
08:09:05 <Olathe> > join (***) (*2)
08:09:06 <lambdabot>       Overlapping instances for Show ((c, c) -> (c, c))
08:09:06 <lambdabot>        arising from a...
08:09:16 <chrisdone> :t join (***)
08:09:17 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
08:09:23 <Olathe> So, it knows that it's a (c, c) -> (c, c)
08:09:27 <Olathe> But it can't use it.
08:09:48 <chrisdone> > join (***) (*) (1,2)
08:09:49 <lambdabot>       Overlapping instances for Show (b -> b)
08:09:49 <lambdabot>        arising from a use of `s...
08:10:14 <chrisdone> whoops, misread the arrow
08:12:54 <chrisdone> BeelsebobWork: why not unMonad :: MonadPlus m => a -> (m a -> a) -> a -> a; unMonad n f v = if v == mzero then n else f v
08:12:54 <Saul_> I've used cabal-install to install a bunch of packages, but it seems to install at a different location (see http://hpaste.org/10222)
08:13:13 <chrisdone> @let unMonad n f v = if v == mzero then n else f v
08:13:14 <Saul_> now my Agda2 installation can't find binary and zlib
08:13:14 <lambdabot>  Defined.
08:13:25 <chrisdone> > maybe 0 (+1) (Just 5)
08:13:26 <lambdabot>   6
08:13:27 <dcoutts_> Saul_: yes, that's the per-user ghc package db
08:13:33 <chrisdone> > maybe 0 ((+1) . fromJust) (Just 5)
08:13:34 <lambdabot>       No instance for (Num (Maybe a))
08:13:34 <lambdabot>        arising from the literal `5' at ...
08:13:39 <geezusfreeek> Saul_: use the --user and --global flags to control where cabal installs things
08:13:39 <chrisdone> > unMonad 0 ((+1) . fromJust) (Just 5)
08:13:39 <dcoutts_> Saul_: you can use any packages registered in that one too.
08:13:41 <lambdabot>   6
08:13:49 <chrisdone> BeelsebobWork: what do you think?
08:14:21 <Saul_> dcoutts_: Yeah I can use them, but if I try to install agda2, it says those two are missing
08:14:21 <BeelsebobWork> chrisdone: that looks nice, yes
08:14:31 <dcoutts_> Saul_: so what's up with agda2? If you're building that with cabal too then it should find them. If you're using runghc Setup.hs configure for agda2, then add --user
08:14:38 <Saul_> geezusfreeek: thanks, is there a way to default to global?
08:15:12 <chrisdone> > unMonad ":(" head ["yay"]
08:15:13 <lambdabot>   "yay"
08:15:38 <geezusfreeek> i'm sure there is, but i do not know it
08:15:49 <Saul_> dcoutts_: ok thanks
08:16:02 <lilac> chrisdone: http://hpaste.org/10220#a2
08:16:10 <chrisdone> > False `mplus` False
08:16:11 <lambdabot>   Couldn't match expected type `m a' against inferred type `Bool'
08:16:16 <dcoutts_> Saul_: so, any luck? how are you configuring agda2? it's an ordinary Cabal package too isn't it?
08:16:45 <geezusfreeek> i wish agda was on hackage, but it depends on versions of packages that are not on hackage either :(
08:16:51 <chrisdone> lilac: reminds me of scheme code
08:17:02 <geezusfreeek> quickcheck 2 and something else i don't remember
08:17:06 <chrisdone> can Bool be a monoid?
08:17:07 <dcoutts_> geezusfreeek: clearly they need to kick some people
08:17:15 <Saul_> dcoutts_: I'm using the darcs version, the release version is too old for my purposes (a course on dependent types)
08:17:35 <quicksilver> chrisdone: it can be the `min` monoid or the `max` monoid
08:17:45 <BeelsebobWork> chrisdone: strangely, given the naming of 'list' and 'maybe', maybe unMonad should be called 'monad'
08:17:54 <chrisdone> BeelsebobWork: true
08:17:59 <Twey> Heh
08:18:03 <dcoutts_> Saul_: right, but how do you build agda2? is it a Cabal package where you just use 'cabal install' ?
08:18:03 <quicksilver> chrisdone: IIRC conor has some newtypes for it
08:18:08 <quicksilver> Might and Must, I think?
08:18:13 <chrisdone> quicksilver: ohh nice
08:18:31 <geezusfreeek> what would be really nice would be a way to put darcs paths in .cabal files so that things like cabal-install can install bleeding edge dependencies automatically
08:18:45 <Saul_> dcoutts_: That seems to work
08:18:56 <quicksilver> chrisdone: the source code for epigram is full of such slightly punnish tricks.
08:19:41 <dcoutts_> Saul_: so I'm guessing that previously you were using runghc Setup configure and it said id could not find the packages. The default for runghc Setup is --global, while for cabal-install we switched it to the more helpful --user.
08:20:00 <Saul_> dcoutts_: indeed
08:20:12 <dcoutts_> Saul_: so that's why runghc Setup configure would not find it. You can tell it to use --user or just use the 'cabal' program to 'cabal configure' etc
08:20:37 <dcoutts_> the 'cabal' program has all the commands that 'runghc Setup' has, and more
08:21:03 <chrisdone> BeelsebobWork: I'm surprised a function like this doesn't already exist. it's probably only useful for maybe and list, I suppose..
08:21:12 <dcoutts_> geezusfreeek: having links to darcs repos is certainly something we want to do. Having cabal-install automatically install darcs versions, hmm. Maybe.
08:21:12 <Saul_> dcoutts_: yeah I wasn't aware that cabal could install from downloaded repositories
08:21:24 <Saul_> dcoutts_: which is good to know, thanks
08:21:36 <dcoutts_> Saul_: it's *the* new command line interface, replacing runghc Setup
08:21:43 <geezusfreeek> definitely with some sort of control, of course
08:23:12 <Saul_> dcoutts_: It's definitely more handy, I just mistakenly assumed it could only install stuff on hackage
08:36:27 <noohgodno> let me get this straight
08:36:36 <noohgodno> we've narrowed down rational thought into an algorithmic approach
08:36:48 <noohgodno> and nobody has implemented it??
08:37:01 <Twey> We have?
08:37:06 <noohgodno> did humans always suck so much
08:37:09 <Twey> When did that happen?
08:37:24 <noohgodno> recently
08:37:48 * noohgodno looks busy
08:38:53 <noohgodno> it's an abstracted application/induction of input into generalizations
08:38:57 <noohgodno> that's all intelligence is
08:39:43 <Tchakkazulu> instance Arrow Human where...
08:40:18 <noohgodno> is it just me or is the mass media trying to convince us that we're not animals
08:40:54 * noohgodno goes into hiding
08:46:12 <lilac> is there a simple way of installing cabal-install yet? (ie, one which doesn't require installing half a dozen dependencies manually first)
08:46:16 <ruediger> hi
08:46:32 <dcoutts_> lilac: there's a bootstrap.sh in the cabal-install tarball
08:46:50 <dcoutts_> which installs the three dependencies first
08:47:16 <ruediger> is Haskell code hot swapable? (<=> if I have a running program can I replace the running system with a new version without shuting it down and restart ist?)
08:47:16 <zachk> > (\lol->do if (lol==[]) then return [] else do l<-head $ lol;( map (\x->l:x) (cp $ tail $ lol) )) [[1..3],[1..3],[1..3]]
08:47:17 <lambdabot>   mueval: Prelude.read: no parse
08:47:25 <thoughtpolice> there's zlib and http, what else?
08:47:29 <thoughtpolice> ruediger: yes
08:47:56 <ruediger> thoughtpolice: ok, cool. thx
08:47:59 <thoughtpolice> you can take the approach xmonad (and yi iirc?) does
08:48:03 <zachk> why didnt lambdabot run that code?
08:48:14 <thoughtpolice> or you can use hs-plugins for 'true' hot-code swapping
08:48:32 <thoughtpolice> ruediger: see dons paper 'dynamic applications from the ground up,' i've used the approach before (in an irc bot) and it works pretty good
08:49:00 <stepcut> zachk: perhaps because cp is not in scope ?
08:49:05 <dcoutts_> thoughtpolice: there's the Cabal lib too, and many people will only have Cabal-1.2 but cabal-install needs 1.4
08:50:14 <thoughtpolice> dcoutts_: oh good point
08:50:28 * thoughtpolice is still for including cabal-install with ghc
08:50:42 <dcoutts_> thoughtpolice: that's what the haskell platform is for
08:51:23 <thoughtpolice> dcoutts_: i'm still not all up to date and everything on the hp - is it still heading strong and ready for 6.10?
08:51:40 <dcoutts_> thoughtpolice: we're aiming for a release shortly after 6.10
08:51:56 <dcoutts_> partly to make the point that the releases are not and should not be synchronised
08:52:42 <thoughtpolice> goodie goodie. is there a layout so far of what'll be included?
08:53:09 <zachk> stepcut: how do i define a recursive function in lambdabot
08:53:12 <dcoutts_> thoughtpolice: for the first release it's really just extralibs + cabal-install (and cabal-install's two extra deps)
08:53:21 <quicksilver> zachk: let f x = f (x+1) in f
08:54:28 <stepcut> zachk: let f x = ...
08:56:08 <bd_> zachk: fix $ \f -> (\arg -> ...)
08:56:09 <bd_> <.<
08:58:13 <zachk> > let cp lol=do if (lol==[]) then return [] else do l<-head $ lol;( map (\x->l:x) (cp $ tail $ lol) )) in cp [[1..3],[1..3],[1..3]]
08:58:14 <lambdabot>   mueval: Prelude.read: no parse
08:59:32 <zachk> > let cp lol=do if (lol==[]) then return [] else do l<-head $ lol;( map (\x->l:x) (cp $ tail $ lol) ))
08:59:33 <lambdabot>   mueval: Prelude.read: no parse
08:59:34 <lilac> dcoutts_: awesome :)
08:59:44 <zachk> :-/
09:00:15 <quicksilver> zachk: 'let' but no 'in'
09:00:30 <quicksilver> and you'll need {} arund the second 'do'
09:00:33 <lilac> > let cp lol=do if (lol==[]) then return [] else do l<-head $ lol;( map (\x->l:x) (cp $ tail $ lol) ) in cp [[1..3],[1..3],[1..3]]
09:00:34 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
09:00:55 <quicksilver> zachk: and the first do (lol=do) is useless :)
09:01:36 <zachk> sweet, took me a bit to get cartesian product into one line of code
09:01:52 <nathanic> is there a way to do "import qualified Foo as F" in ghci?
09:02:13 <zachk> the type system really helped as i worked at it in ghci
09:02:18 <quicksilver> > sequence [[1..3],[1..3],[1..3]]
09:02:19 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
09:02:30 <zachk> :-D
09:02:43 <quicksilver> nathanic: no.
09:02:53 <nathanic> quicksilver: thanks.  also, dang.
09:03:03 <quicksilver> nathanic: you are using the list monad yourself.
09:03:07 <stepcut> nathanic: I think there was a bug filed about that recently though ?
09:03:16 <quicksilver> nathanic: oops, wrong person :)
09:03:32 <quicksilver> zachk: you are using the list monad yourself. it turns out this is a basic operation of it :)
09:03:37 <quicksilver> nathanic: yes, that's annoying I agree.
09:03:47 <quicksilver> nathanic: you can, however, load a .hs file with qualified imports :)
09:04:01 <nathanic> http://hackage.haskell.org/trac/ghc/ticket/2362
09:04:03 <lambdabot> Title: #2362 (allow full import syntax in GHCi) - GHC - Trac
09:04:34 <lilac> > let cp [] = [[]]; cp (a:as) = concatMap (\l -> map (l:) (cp as)) a in cp [[1..3],[1..3],[1..3]]
09:04:35 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
09:04:36 <nathanic> yeah, qualified helper .hs module is what i've been doing, but it seems somewhat more painful than necessary
09:04:40 <Olathe> > liftM3
09:04:41 <lambdabot>       Overlapping instances for Show
09:04:41 <lambdabot>                                  ((a1 ->...
09:04:47 <lilac> ^^ written like that it's obviously a fold
09:05:19 <stepcut> nathanic: http://hackage.haskell.org/trac/ghc/ticket/2362
09:05:21 <lambdabot> Title: #2362 (allow full import syntax in GHCi) - GHC - Trac
09:05:25 <Olathe> Ooh, sequence is nice.
09:05:29 <Olathe> @src sequence
09:05:29 <lambdabot> sequence []     = return []
09:05:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:05:29 <lambdabot> --OR
09:05:29 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:05:41 <chrisdone> > fmap (+2) (1,3)
09:05:43 <lambdabot>   (1,5)
09:05:43 <nathanic> stepcut: scroll up :-)
09:05:47 <chrisdone> why has such an isntance been chosen/
09:05:54 <stepcut> nathanic: oops ;)
09:05:58 <Olathe> > fmap (+2) (a,b,c,d)
09:05:59 <lambdabot>       No instance for (Functor ((,,,) Expr Expr Expr))
09:05:59 <lambdabot>        arising from a ...
09:06:04 <chrisdone> why apply it to the second in the tuple and not the first
09:06:21 <quicksilver> chrisdone: because that's the order the parameters are in.
09:06:28 <stepcut> nathanic: if I scroll up far enough I see, <ben> Is there an equivalent to import qualified foo as bar for use in ghci?
09:06:28 <quicksilver> chrisdone: (,) a b
09:06:29 <stepcut> ;)
09:06:42 <quicksilver> chrisdone: can only possibly be a Functor by removing the right-most.
09:06:51 <quicksilver> chrisdone: because Functors must have kind :: * -> *
09:06:57 <ziman> > length . sequence . tail . inits . flip replicate id $ 6
09:06:58 <lambdabot>   720
09:07:08 <nathanic> stepcut: you win :-)
09:07:24 <quicksilver> nathanic: qualified modules feel like something of a 2nd-class feature
09:07:32 <quicksilver> nathanic: you can't use them in ghci, you can't re-export qualifications
09:07:40 <quicksilver> nathanic: they're not quite "finished" somehow.
09:07:46 <chrisdone> quicksilver: I don't really understand
09:07:47 <Olathe> let t n = sequence.take n.repeat in t 3 [1..3]
09:07:49 * nathanic ponders re-exporting qualifications
09:07:58 <Olathe> > let t n = sequence.take n.repeat in t 3 [1..3]
09:07:59 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
09:08:01 <chrisdone> :t flip fmap (1,2)
09:08:03 <lambdabot> forall a b t. (Num a, Num t) => (a -> b) -> (t, b)
09:08:13 <Olathe> @pl let t n = sequence.take n.repeat in t
09:08:14 <lambdabot> (sequence .) . (. repeat) . take
09:08:16 <quicksilver> chrisdone: Maybe is a Functor.
09:08:22 <quicksilver> chrisdone: Maybe is of kind :: * -> *
09:08:27 <quicksilver> chrisdone: (,) a is a Functor
09:08:33 <quicksilver> chrisdone: (,) a is of kind :: * -> *
09:08:43 <chrisdone> quicksilver: yeah
09:09:00 <quicksilver> chrisdone:  "apply it to the first in a tuple" is not expressible.
09:09:09 <quicksilver> (,b) if you like
09:09:13 <quicksilver> but type-sections don't exist.
09:09:29 <quicksilver> newtype RightPair a b = RightPair (b,a)
09:09:38 <quicksilver> and you can make RightPair a a Functor.
09:09:57 <Olathe> > let t n = sequence.take n.repeat in t 3 "Hello"
09:09:58 <lambdabot>   ["HHH","HHe","HHl","HHl","HHo","HeH","Hee","Hel","Hel","Heo","HlH","Hle","H...
09:10:34 <chrisdone> quicksilver: oh I get it. I'm not used to kinds
09:10:56 <chrisdone> quicksilver: I guess I'm really wondering why it's a functor at all
09:11:11 <lilac> > let cp = foldr (liftM2 (:)) [[]] in cp [[1..3],[1..3],[1..3]]
09:11:12 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
09:11:30 <chrisdone> quicksilver: why define an instance for it?
09:12:20 <quicksilver> chrisdone: *shrug*
09:12:26 <quicksilver> > fmap (+1) (4,5)
09:12:28 <lambdabot>   (4,6)
09:12:34 <quicksilver> chrisdone: it's a nice example of a simple functor, I guess.
09:13:38 <chrisdone> hmmk
09:13:45 <Olathe> > fmap (+a) (b,c)
09:13:47 <lambdabot>   (b,c + a)
09:14:03 <chrisdone> > second (+a) (b,c)
09:14:04 <lambdabot>   mueval: Prelude.read: no parse
09:14:10 <chrisdone> :t second
09:14:11 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
09:14:19 <chrisdone> does the eval have Control.Arrow?
09:14:28 <chrisdone> > (id *** id) (1,1)
09:14:29 <lambdabot>   mueval: Prelude.read: no parse
09:14:32 <chrisdone> ah
09:14:47 <Saul__> I'm having some problems with a fresh installation of cabal-install
09:15:01 <Saul__> I installed it and it works fine but it wasn't in my patj
09:15:02 <Saul__> path
09:15:03 <Olathe> @pl \f (a, b) -> (a, f b)
09:15:04 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
09:15:15 <Saul__> so I added /home/paul/.cabal/bin to it
09:15:16 <Olathe> @pl \(a, b) -> (a, f b)
09:15:16 <lambdabot> second f
09:15:30 <Olathe> > (second (+a)) (b, c)
09:15:31 <lambdabot>   mueval: Prelude.read: no parse
09:15:34 <Saul__> and now it works in user mode, but not as root
09:15:37 <Olathe> No parse ?
09:15:39 <Olathe> > second
09:15:40 <lambdabot>       Overlapping instances for Show (a b c -> a (d, b) (d, c))
09:15:40 <lambdabot>        arisin...
09:15:49 <Olathe> > second (+a)
09:15:50 <lambdabot>       Overlapping instances for Show ((d, Expr) -> (d, Expr))
09:15:50 <lambdabot>        arising ...
09:16:20 <Saul__> but sometimes I need root to install something, so how can I make sure that root also has cabal-install in its path?
09:16:20 <Olathe> > let whatever = const 5 in (whatever) (a, b)
09:16:21 <lambdabot>   5
09:16:27 <Taejo> I want something that works like case, but gives the right-hand sides of *all* matching left-hand sides, not just the first one (in a list or in an arbitrary MonadPlus)... is there an elegant way? (rather than just having lots of nested cases with mpluses)
09:16:29 <Olathe> > let whatever = const 5 in (whatever.whatever) (a, b)
09:16:30 <lambdabot>   5
09:16:39 <dcoutts_> Saul__: or you can use cabal install --global --root-cmd=sudo
09:17:24 <Saul__> dcoutts_: I guess I could, but that would get rather tedious
09:17:51 <dcoutts_> Saul__: you can set that as a default in the ~/.cabal/config
09:18:03 <dcoutts_> Saul__: or of course you can install cabal-install itself globally
09:18:12 <dcoutts_> which puts it in /usr/local/bin
09:18:30 <Saul__> I think I will use the latter option
09:22:41 <lilac> > let q = [Just (12,34), Nothing, Just (56,7)] in (do Just (x,_) <- q; return x) ++ (do Just (_, x) <- q; return x) ++ (do Nothing <- q; return 42) -- Taejo
09:22:42 <lambdabot>   [12,56,34,7,42]
09:23:18 * lilac proudly avoids using 'case' by rewriting it as 'do' ;-)
09:23:52 <Olathe> @undo do Just (x,_) <- q; return x
09:23:53 <lambdabot> q >>= \ a -> case a of { Just (x, _) -> return x; _ -> fail ""}
09:23:57 <guenni> mmorrow: ping
09:24:21 <Olathe> > fail "epic"
09:24:22 <lambdabot>       No instance for (Show (m a))
09:24:22 <lambdabot>        arising from a use of `show' at <in...
09:25:00 <Olathe> > return(fail "epic")
09:25:00 <lambdabot>       No instance for (Show (m1 (m a)))
09:25:01 <lambdabot>        arising from a use of `show' a...
09:25:03 <bd_> > fail "epic" :: []
09:25:04 <lambdabot>       `[]' is not applied to enough type arguments
09:25:04 <lambdabot>      Expected kind `?', bu...
09:25:06 <bd_> > fail "epic" :: [Int]
09:25:07 <lambdabot>   []
09:25:16 <bd_> > fail "epic" :: Identity Int
09:25:17 <lambdabot>       No instance for (Show (Identity Int))
09:25:17 <lambdabot>        arising from a use of `sho...
09:25:20 <Taejo> lilac: not quite what I was after
09:25:23 <Olathe> > fail "epic" :: [Char]
09:25:24 <lambdabot>   ""
09:25:29 <bd_> hmph, why shouldn't Identity have a Show instance?
09:25:33 <Olathe> > (fail "epic") :: [Char]
09:25:35 <lambdabot>   ""
09:25:38 <Olathe> O-o
09:25:44 <Olathe> That's not a [Char]
09:25:44 <quicksilver> lilac: I tend to use list comprehension notations for stuff like that.
09:25:50 <MyCatVerbs> Olathe: yes it is.
09:25:55 <quicksilver> lilac: [x | Just (x,_) <- q]
09:25:56 <Olathe> Which one ?
09:26:01 <Olathe> > ""
09:26:02 <lambdabot>   ""
09:26:07 <Olathe> > "test"
09:26:08 <MyCatVerbs> Olathe: actually, it's [a].
09:26:08 <lambdabot>   "test"
09:26:15 <Olathe> Wait.
09:26:16 <MyCatVerbs> Olathe: it's a failure in the list monad. :)
09:26:23 <Olathe> lambdabot is putting "" as nothing ?
09:26:33 <lilac> quicksilver: to be honest, i don't see the point of list comprehensions given that we have do notation
09:26:42 <MyCatVerbs> No. fail "foo" in the list monad drops the current element.
09:26:49 <ziman> Olathe, [] is fail in the list monad
09:26:56 <lilac> @src [] fail
09:26:56 <lambdabot> fail _      = []
09:26:57 <Olathe> Ahh.
09:27:05 <ziman> (which is "" for [Char] == String)
09:27:07 <Olathe> Well, if it would have said "", it would have been better.
09:27:15 <MyCatVerbs> > "fOOoobar" >>= (\c -> if isUpper c then fail "dammit" else c)
09:27:16 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Char'
09:27:16 <Olathe> > "" -- epic fail
09:27:17 <lambdabot>   ""
09:27:26 <MyCatVerbs> > "fOOoobar" >>= (\c -> if isUpper c then fail "dammit" else [c])
09:27:27 <lambdabot>   "foobar"
09:27:43 <MyCatVerbs> Extremely long-winded way to type 'filter'. :)
09:28:42 <lilac> > do c <- "fOOoobar"; True <- [isUpper c]; return c
09:28:44 <lambdabot>   "OO"
09:28:56 <quicksilver> lilac: easier to read.
09:29:03 <quicksilver> lilac: avoid that noisy word return.
09:29:07 <quicksilver> @src catMaybes
09:29:07 <lambdabot> catMaybes ls = [x | Just x <- ls]
09:29:15 <quicksilver> I think that's very beautiful
09:29:19 <quicksilver> much more so than the do-version
09:29:58 <lilac> is "do Just x <- ls; return x" really so different?
09:30:09 <quicksilver> no, it's not very different.
09:30:19 <quicksilver> but the list comp version is still more attractive.
09:30:25 <osfameron> to some people
09:30:26 <lilac> i can understand wanting list comprehensions from an expressing-mathematics-effectively pov
09:30:34 <quicksilver> and becomes more so when you add a bunch of guards
09:30:50 <osfameron> I find list comps confusing and scary, which are not attractive qualities :-)
09:30:55 <quicksilver> osfameron: sure. The word attractive is obviously a clue that the statement is subjective :)
09:31:04 <osfameron> heh :-)
09:33:45 <Tchakkazulu> I find the "group by then sort by" list comprehensions kinda scary :-/
09:33:56 <Tchakkazulu> Normal comprehensions, or even parallel, sure.
09:34:12 <Tchakkazulu> But that's just 'cause they're new and I haven't used them yet, probably.
10:01:45 <humasect> > properFraction 5.99
10:01:46 <lambdabot>   (5,0.9900000000000002)
10:01:50 <humasect> ack!
10:02:11 <humasect> properFraction (5.99::Float)
10:02:21 <humasect> > properFraction (5.99::Float)
10:02:22 <lambdabot>   (5,0.9899998)
10:02:35 <humasect> ok .. what if neither of these are acceptable ?
10:03:08 <humasect> "The function properFraction takes a real fractional number x and returns a pair (n,f) such that x = n+f"
10:03:22 <humasect> > (5+0.9900000000000002) == 5.99
10:03:33 <lambdabot>   True
10:03:55 <humasect> but ...
10:03:58 <humasect> > 0.9900000000000002 == 0.99
10:04:00 <lambdabot>   False
10:05:07 <humasect> > (5+0.9899998) == 5.99
10:05:08 <lambdabot>   False
10:05:20 <humasect> what can i do? isn't C more precise?
10:06:10 <Olathe> You can use rationals.
10:06:11 <rwbarton> Use Rational?
10:06:15 <humasect> ah~
10:06:21 <Olathe> > 5.99 :: Rational
10:06:22 <lambdabot>   599%100
10:06:36 <roconnor> > (5+0.9900000000000002) == ( 5.99 :: Rational)
10:06:43 <lambdabot>   False
10:06:43 <humasect> ah right, cool... i did not know of these ~
10:07:02 <humasect> so this is natural computer impreciseness?
10:07:12 <humasect> just tacking on that 000000000000002 for fun ..
10:07:12 <byorgey> yup
10:07:15 <humasect> kk
10:07:17 <roconnor> don't use floating point
10:07:21 <roconnor> ever :)
10:07:30 <humasect> hehe, that might be possible ..
10:07:31 <rwbarton> (In my C compiler, it is also the case that 5.99 - 5.0 != 0.99)
10:07:32 <pgavin> humasect: http://www.physics.ohio-state.edu/~dws/grouplinks/floating_point_math.pdf
10:07:34 <roconnor> unless you get a floating point licence
10:07:36 <lambdabot> Title: What Every Computer Scientist Should Know About Floating-Point Arithmetic, http://tinyurl.com/6tjye
10:07:54 <humasect> roconnor: hehe! until i pass to opengl it may be able to stay rationals
10:07:58 <Olathe> I have a floating-point license.
10:08:05 <humasect> pgavin: interesting, thanks!
10:08:15 <pgavin> humasect: np :)
10:08:17 <Olathe> It's truncated right after my first name, though.
10:08:21 <humasect> oh, its a real thing, Olathe ?
10:08:24 <humasect> aha
10:08:25 <Olathe> Yes.
10:08:45 <byorgey> I have a floating-point license too.  I've got a few impressive ones stuffed and mounted on my wall, in fact.
10:08:51 <Olathe> It puts names as things like Name: Olat...
10:09:06 <Olathe> So, you can't be sure exactly who the licenseholder is.
10:09:31 <humasect> certs on a wall sound like floating points
10:10:11 <Olathe> It makes it easy to rent out the license to people with similar names, though.
10:10:24 <humasect> =)
10:10:41 <humasect> i wonder of the overhead, rationals are all software right?
10:10:50 <Olathe> Yes.
10:10:55 <humasect> k, hmm
10:11:00 <Olathe> The overhead is holding two Integers.
10:11:23 <humasect> hm that is not bad at all.
10:11:40 <humasect> > (1%5) / (2%5)
10:11:42 <lambdabot>   1%2
10:11:43 <rwbarton> humasect: It's only likely to be a problem if you either need lots of speed or you expect the denominators to grow really quickly.
10:11:55 <rwbarton> > sum [ 1/n | n <- [1..200] ]
10:11:57 <lambdabot>   5.878030948121446
10:12:02 <rwbarton> > sum [ 1%n | n <- [1..200] ]
10:12:03 <lambdabot>   734304501393663047454128920370690990011701612756404750324309881998409657620...
10:12:36 <Olathe> Hmm...
10:12:41 <humasect> rwbarton: what do you mean, quickly?
10:14:06 <rwbarton> Well, like in the  sum [ 1%n | n <- [1..200] ]  example above
10:14:22 <rwbarton> That wasn't very many operations, but the numerator and denominators are really big
10:14:38 <rwbarton> > length . show . denominator $ sum [ 1%n | n <- [1..200] ]
10:14:39 <lambdabot>   89
10:14:55 <humasect> o_o .. ah, that is a problem
10:15:01 <rwbarton> so any operations on that result will be quite a bit slower than on doubles.
10:15:19 <rwbarton> Depending on what you're doing, this might not happen
10:15:20 <humasect> perhaps they can be approximated every so often
10:15:40 <humasect> in some cases, there is a lot of incrementations, that 200 can happen in one second
10:15:47 <humasect> (of running time)
10:16:43 <humasect> if they were approximated now and then, it could be perfectly used and (nearly) all floats replaced
10:17:26 <rwbarton> that's basically how floating point works, though
10:17:51 <rwbarton> (an example where Rational does well:)
10:18:00 <humasect> i didn't know Integer can become something like 89 digits
10:18:21 <rwbarton> > (sum [ n%10000 | n <- [1..83747] ], sum [ n/10000 | n <- [1..83747] ])
10:18:22 <byorgey> Integers are unbounded
10:18:30 <humasect> byorgey: ah, scary..
10:18:30 <byorgey> unlike Int, which is machine-sized
10:18:38 <lambdabot>   (1753410939%5000,350682.18779999996)
10:18:42 <byorgey> > let fact n = product [1..n] in fact 100
10:18:54 <humasect> rwbarton: hm, cool=)
10:19:01 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
10:19:07 <rwbarton> > length . show $ 10^10000
10:19:20 <lambdabot>   10001
10:19:46 * humasect shivers
10:20:33 <humasect> i wonder how much memory that takes to store just 1
10:21:45 <Olathe> > let sumQuick xs = sum (zipWith (*) ps ns) % head rs where ns = map numerator xs; ds = map denominator xs; ls = scanl (*) 1 ds; rs = drop 1 $ scanr (*) 1 ds; ps = zipWith (*) ls rs in sumQuick [ 1%n | n <- [1..200] ] == sum [ 1%n | n <- [1..200] ]
10:21:48 <lambdabot>   True
10:21:50 <rwbarton> humasect: computations on small Integers is only about 30-50% slower than on Ints (machine-size integers) in my experience.
10:23:16 <dcoutts_> rwbarton: you're lucky, or your writing code without loops that can be unboxed
10:23:27 <humasect> rwbarton: hm, that is not bad at all. does small mean same sized as Ints , or bigger?
10:23:36 <rwbarton> dcoutts_: Yeah, the latter probably
10:23:50 <dcoutts_> @src Integer
10:23:50 <lambdabot> data Integer = S# Int#
10:23:51 <lambdabot>              | J# Int# ByteArray#
10:23:54 <rwbarton> humasect: Same as Ints (maybe slightly smaller? not sure)
10:24:02 <humasect> k
10:24:13 <dcoutts_> humasect: as you can see from the Integer impl, it uses either an Int# or a big int
10:24:28 <humasect> so if rationals were kept somehow so each part is those smaller ints, then it is only win
10:24:34 <dcoutts_> so yes, small means Int or smaller
10:24:45 <humasect> ah, right
10:25:05 <dcoutts_> humasect: which is already 64bit on 64bit machines
10:25:17 <dcoutts_> or 32 on 32bit boxes
10:26:23 <Olathe> Or 29 on 4-bit boxes.
10:26:40 <humasect> i think GHC packages are 64bit only for linux
10:27:20 <dcoutts_> humasect: ghc can be built for 32 and 64 bit x86
10:27:49 <humasect> ah, maybe i should look into that, i have a mac here
10:28:10 <humasect> i wonder if why, all mac intels are 64bit, that the ghc packages for mac intel are not also 64bit
10:28:26 <pgavin> humasect: not all
10:28:37 <pgavin> humasect: the old core 1 macs aren't
10:28:46 <humasect> ohh, i see
10:28:46 <dcoutts_> humasect: I thought OSX up to 10.5 was 32bit only (even though the hardware was capable of 64bit)
10:28:56 <pgavin> dcoutts_: that's right
10:29:02 <dcoutts_> 32bit in user space anyway
10:29:27 <pgavin> dcoutts_: the kernel was only 32 bit up through 10.3 I think
10:30:25 <dcoutts_> pgavin: ah, and then moved to 64 bit for the kernel but 32 user space and now supports both 32 and 64bit user space progs?
10:30:45 <pgavin> dcoutts_: right
10:30:52 <pgavin> they ported the kernel to 64bit first
10:31:28 <humasect> so 10.4 can run 64bit i think
10:31:35 <dcoutts_> pgavin: so they've got all the core libs built both ways ?
10:31:42 <pgavin> humasect: the userspace is only 32bit, so no
10:32:04 <pgavin> dcoutts_: they're bundled together in a single binary
10:32:15 <dcoutts_> pgavin: the fat binaries
10:32:38 <humasect> ah,hm
10:32:52 <pgavin> dcoutts_: right, Mach-O
10:33:09 <humasect> it seems 6.10 is coming this month , so i will do that for 64bit
10:33:22 * humasect is in a position to be distributing binaries not source
10:33:50 <pgavin> pgavin@rasputin:~/devel/src/rarrow$ file /usr/lib/libc.dylib
10:33:51 <pgavin> /usr/lib/libc.dylib: Mach-O universal binary with 4 architectures
10:33:51 <pgavin> /usr/lib/libc.dylib (for architecture ppc7400):	Mach-O dynamically linked shared library ppc
10:33:51 <pgavin> /usr/lib/libc.dylib (for architecture ppc64):	Mach-O 64-bit dynamically linked shared library ppc64
10:33:54 <pgavin> /usr/lib/libc.dylib (for architecture i386):	Mach-O dynamically linked shared library i386
10:33:57 <pgavin> /usr/lib/libc.dylib (for architecture x86_64):	Mach-O 64-bit dynamically linked shared library x86_64
10:34:00 <pgavin>  
10:34:04 <Botje> O_O
10:34:08 <pgavin> sorry for the big paste :)
10:34:12 <Botje> _FOUR_ architectures?
10:34:16 <dcoutts_> pgavin: so that's 4 arches ?
10:34:22 <humasect> =)
10:34:28 <pgavin> well, that's just for the libc dynamic lib
10:34:33 <Botje> i'm surprised some mac users haven't complained yet
10:34:38 <pgavin> pgavin@rasputin:~/devel/src/rarrow$ file /bin/ls
10:34:38 <pgavin> /bin/ls: Mach-O universal binary with 2 architectures
10:34:38 <pgavin> /bin/ls (for architecture i386):	Mach-O executable i386
10:34:38 <pgavin> /bin/ls (for architecture ppc7400):	Mach-O executable ppc
10:34:38 <Botje> "omg it's so big!"
10:34:41 <pgavin>  
10:34:54 <pgavin> it helps with the backwards compatibility
10:34:59 <pgavin> e.g. rosetta
10:35:17 <pgavin> gotta go, batteries gonna die :)
10:35:25 <dcoutts_> heh, by pgavin :-)
10:36:19 <humasect> i think 10.6 will not have ppc, or something similar to this
10:37:17 <humasect> speaking of 10s, 10 days until expected release for 6.10
10:39:13 <humasect> i have converted the project to doubles and will see how far this goes, thanks for the help everyone =) be well~
10:39:24 * humasect will sprinkle ratios here and there..
10:48:45 <trofi> @pl \a b -> fst a == fst b
10:48:46 <lambdabot> (. fst) . (==) . fst
10:49:02 <trofi> @pl (==) `on` fst
10:49:03 <lambdabot> (==) `on` fst
10:50:19 <Botje> lambdabot doesn't know about "on", of course
10:51:44 <trofi> @help check
10:51:44 <lambdabot> check <expr>
10:51:44 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
10:52:10 <ystael> what is this, the haskell organized crime loyalty test?
10:52:45 <trofi> @check \x -> const 42 x == 42
10:52:46 <lambdabot>   "OK, passed 500 tests."
10:53:12 <trofi> @check \xs -> (\a b -> fst a == fst b) == ((==) `on` fst) xs
10:53:13 <lambdabot>   Couldn't match expected type `(a, b) -> Bool'
10:53:26 <trofi> @check \xs -> (\a b -> fst a == fst b) xs == ((==) `on` fst) xs
10:53:27 <lambdabot>       No instance for (Eq ((a, b) -> Bool))
10:53:27 <lambdabot>        arising from a use of `=='...
10:57:44 <Olathe> @check True
10:57:45 <lambdabot>   "OK, passed 500 tests."
10:57:52 <Olathe> @check False
10:57:53 <lambdabot>   "Falsifiable, after 0 tests:\n"
10:58:05 <Olathe> @check \(x:xs) -> False
10:58:06 <lambdabot>   mueval: "*** Exception: /tmp/2927911886103794662:58:49-64: Non-exhaustive p...
10:59:21 <Olathe> @check let false [] = False; false (x:xs) = False || false xs in \xs -> false xs
10:59:22 <lambdabot>   "Falsifiable, after 0 tests:\n[()]\n"
10:59:40 <Olathe> @check let false [] = False; false [()] = True; false (x:xs) = False || false xs in \xs -> false xs
10:59:41 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
10:59:47 <Olathe> Lies.
10:59:56 <Olathe> @check let false [] = True; false [()] = True; false (x:xs) = False || false xs in \xs -> false xs
10:59:58 <lambdabot>   "OK, passed 500 tests."
11:00:35 <Olathe> @check let false [] = True; false [()] = True; false _ = False in \xs -> false xs
11:00:36 <lambdabot>   "Falsifiable, after 4 tests:\n[(),()]\n"
11:00:50 <Olathe> It checks [] and [()] multiple times ?
11:04:26 <Saizan> Olathe: yeah..
11:07:39 <Olathe> @@ @run (\x -> (read x)::[Integer]) $ takeWhile (/= '\n') $ dropWhile (/= '[') @check let false [] = True; false [0] = True; false xs = sum xs /= 0 in \xs -> false xs
11:07:41 <lambdabot>   [-2,5,-1,-1,1,-2]
11:28:02 <bringert> dons: ping
11:30:18 <moshisushi> <interactive>:1:0:
11:30:18 <moshisushi>     No instance for (Show ((a -> a -> t) -> [a] -> t))
11:30:18 <moshisushi>       arising from a use of `print' at <interactive>:1:0-8
11:30:22 <moshisushi> what could this mean?
11:30:42 <Olathe> It means you're trying to show a function.
11:30:47 <moshisushi> what the...
11:30:51 <Olathe> > (+)
11:30:52 <lambdabot>       Overlapping instances for Show (a -> a -> a)
11:30:52 <lambdabot>        arising from a use ...
11:30:56 <moshisushi> ah thanks
11:31:03 <Olathe> You're welcome.
11:31:18 <Olathe> > fromRational
11:31:19 <lambdabot>       Overlapping instances for Show (Rational -> a)
11:31:19 <lambdabot>        arising from a us...
11:33:50 <moshisushi> Olathe: i should have seen that, i just find the ghc output a bit cryptic at times :)
11:37:50 <stepcut> how come, do (Just k) <- undefined, does not generate a 'Pattern match(es) are non-exhaustive' warning ?
11:38:29 <Botje> if the pattern match fails, the fail (:: m a) action is executed
11:38:39 <stepcut> or, let (Just k) = undefined
11:39:00 <ketil> @seen dons
11:39:00 <Botje> in a do block?
11:39:00 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 13h 49m 19s ago.
11:39:03 <Botje> same thing, i think
11:39:13 <stepcut> Botje: no, in a pure Int expression
11:39:25 <Botje> ah
11:39:25 <stepcut> m = (let (Just k) = undefined in k) :: Int
11:39:28 <Botje> i dunno about let
11:39:45 <Botje> it only generates the error for functions, for some reason
11:40:40 <stepcut> Botje: case undefined of (Just k) -> ..., generates a warning if there is no Nothing alternative
11:43:07 <FliPPeh> I read that you cannot create Typeclass instances for your own type and use "String" for it, for some Type synonym reason - can someone explain that to me? :/
11:43:18 <Botje> FliPPeh: there's an option you can use to enable it
11:43:31 <Botje> i believe the error even says which one it is
11:43:46 <Botje> stepcut: i think this is a case of refutable vs irrefutable pattern matches?
11:44:02 <Botje> after all, the pattern match won't be executed if k is never evaluated in the first example
11:44:15 <LeoD> FliPPeh: the Real World Haskell book explains it
11:44:24 <FliPPeh> Hmm
11:44:26 <Botje> whereas undefined _MUST_ be evaluated if the result of the case is ever used
11:44:30 <FliPPeh> That's where I reat about it
11:44:52 <FliPPeh> But as it talks about type SYNONYMS.. can't I just use "[Char]" instead?
11:44:56 <FliPPeh> That'd be no synonym
11:45:29 <Botje> correct.
11:45:44 <Botje> but i'm not sure if that'll be accepted.
11:45:49 <Botje> tr yit :)
11:46:00 <FliPPeh> Why use a compiler option if I could use the "root type"? ;o
11:46:09 <FliPPeh> I got no testcase to try :(
11:47:05 <Botje> make on yourself!
11:47:21 <FliPPeh> I am not really fluent in haskell :)
11:47:41 <Botje> class Frob a where frob :: a -> ()
11:47:44 <FliPPeh> I only managed to write some source with "data"
11:47:51 <Botje> instance Frob [Char] where frob = const ()
11:49:50 <FliPPeh> Illegal instance declaration for `Frob [Char]'
11:49:50 <FliPPeh>         (All instance types must be of the form (T a1 ... an)
11:49:53 <FliPPeh> =q
11:50:59 <Saizan> FliPPeh: the error contains the solution
11:51:38 <FliPPeh> Pardon, Haskell errors are still cryptic to me
11:51:39 <stepcut> Botje: hrm, it is true that at the STG level, let builds thunks and case forces them. So, I can see why let and case might have different behaviours with regards to pattern matching
11:52:07 <FliPPeh> No idea how to apply the solution
11:52:22 <Botje> FliPPeh: it tells you to use a specific flag, iirc
11:52:22 <stepcut> FliPPeh: you might need to enable type synonym instances
11:52:30 <Botje> give that to ghci / ghc when you start it
11:52:52 <FliPPeh> {-# LANGUAGE TypeSynonymInstances #-}
11:53:04 <stepcut> FliPPeh: yeah
11:53:05 <FliPPeh> Oh
11:53:09 <FliPPeh> Wait wrong
11:53:16 <FliPPeh> "Use -XFlexibleInstances if you want to disable this.)"
11:53:18 <FliPPeh> Heh
11:53:30 <FliPPeh> Ah well. got to go, thanks your helping me out!
11:59:48 <shukhov> I get an error in parsec when I try to use the "symbol" function, is it deprecated?
12:12:02 <Botje> which error?
12:18:16 <hoknamahn> hey guys what is the better way to implement interruptible map in haskell?
12:20:07 <dcoutts> hoknamahn: what do you mean by interruptible ?
12:21:08 <hoknamahn> i'd like to have ability to interrupt map by esc key or something like that
12:21:53 <hoknamahn> should this interruptible map be a sequence of actions rather pure function?
12:23:44 <stepcut> hoknamahn: you could have a second thread that gets user input and kills the first one. Really depends on what you are trying to do.
12:23:48 <mauke> .
12:24:02 <rwbarton> hoknamahn: Now I don't know what you mean by "map"
12:25:04 <rwbarton> hoknamahn: It sounds like you have some pure computation, that you want to be able to abort.  But in some way where control-C isn't good enough.
12:25:37 <hoknamahn> well. look i have region w h = [(x, y) | y <- [0..h - 1], x <- [0..w - 1]]
12:25:55 <hoknamahn> and map render (region 10 5)
12:26:10 <hoknamahn> i'd like to abort map render at some moment
12:26:28 <haskellian> hiow can i convert "false" to the boolean false ?
12:26:48 <mauke> > const False "false"
12:26:50 <lambdabot>   False
12:26:50 <Valodim> > read "false"
12:26:51 <lambdabot>   mueval: Prelude.read: no parse
12:26:52 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
12:27:19 <Valodim> aw
12:28:28 <hoknamahn> as I understand it's impossible to use actions as guards?
12:28:55 <hoknamahn> like x <- [0..1e6], notKeyPressed?
12:29:03 <rwbarton> Right, guards must have type Bool, not m Bool
12:29:17 <rwbarton> The question is what do you want to do after aborting the computation
12:29:19 <haskellian> wrong channel, oops
12:29:46 <hoknamahn> after abort i'd like to show result of render
12:29:59 <hoknamahn> and probably that's all
12:30:03 <rwbarton> Well, just showing the result without anything special will do that.
12:30:39 <rwbarton> i.e. you want to handle the interrupt in your showing code, not in your computing code
12:31:10 <hoknamahn> depends. which way is more elegant, i think
12:31:43 <hoknamahn> but it really doesn't matter form me. want to know how to do it in more elegant way
12:32:06 <hoknamahn> guards look mathematically good, but actions don't fit into them
12:32:27 <rwbarton> the Haskell way is to write your pure computation as a pure computation, and then take advantage of lazy evaluation to only display as much as the user asks for.
12:32:41 <rwbarton> I mean, to only compute as much as the user asks to be displayed.
12:33:09 <hoknamahn> okay, so map written using actions isn't a haskell way?
12:33:48 <rwbarton> i.e. bigComputation = map render (region 10 5) ; ... main = forM_ bigComputation $ \x -> do print x ; a <- isKeyPressed ; when a (exit 0)
12:34:21 <rwbarton> There is also mapM
12:34:22 <rwbarton> :t mapM
12:34:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:36:27 <hoknamahn> so if i have a screen with resolution w by h this screen could be divided into several chunks which are your bigComputation. this bigComputation shouldn't be interruptible, right?
12:36:58 <hoknamahn> but the whole rendering process should. this is what i'm looking for
12:37:42 <rwbarton> I shouldn't have called it bigComputation.  It's not a big computation, it's a big value.  There's no notion of "interruptible" for values
12:38:10 <rwbarton> but the point is that computing one small piece of the value will be quick, it won't require the entire rest of the value to be computed as well
12:38:57 <hoknamahn> arhhh okay. cool thanks man
12:44:44 <rwbarton> writeSTRef isn't strict in the value?  What does "(strict) ST monad" mean?
12:52:42 <rwbarton> Oh, I see... the lazy ST monad is magical
12:53:01 <Olathe> Yes.
12:53:09 <Olathe> Everything in Haskell is magical.
12:53:17 <Olathe> > 1 + 1
12:53:18 <lambdabot>   2
12:53:24 <Olathe> See ! Where'd the 1s go ?
12:53:26 <Olathe> Magic !
12:53:38 <mauke> > let 1 + 1 = 1 in 1 + 1
12:53:40 <lambdabot>   1
12:53:46 <Olathe> Hey !
12:53:52 <Olathe> Don't reveal how the tricks are done !
12:56:21 <roconnor> mauke:  is that a definition of + or an n+k pattern?
12:56:25 <Olathe> It must have been a lot of hard work defining (+) number by number.
13:03:02 * BMeph_ tunes in to another episode of "Magical Language Girl Haskell"
13:04:04 <roconnor> BMeph_: is that a new anime?
13:05:23 <ystael> Mahou Gengo Shoujo Hasukeru?  i'd watch it
13:05:59 <Olathe> The Hasukeru Samurai Power Hour !
13:06:06 <grahamhutton> @users
13:06:06 <lambdabot> Maximum users seen in #haskell: 504, currently: 499 (99.0%), active: 10 (2.0%)
13:06:10 <grahamhutton> !
13:06:36 <Olathe> Ahh.
13:06:38 <olsner> hmm, functional anime... I would probably even pay to see that!
13:06:45 <Olathe> We need six bots in here, quick !
13:07:28 <rwbarton> @users
13:07:28 <lambdabot> Maximum users seen in #haskell: 504, currently: 500 (99.2%), active: 11 (2.2%)
13:07:43 <grahamhutton> :-)
13:07:49 <Olathe> Is that 2.2% of the current or max ?
13:08:00 <olsner> ooh, the next power of two is only 9 users away
13:08:04 <Olathe> > 11.0/500.0
13:08:05 <lambdabot>   2.2e-2
13:08:11 <Olathe> > 11.0/504.0
13:08:12 <lambdabot>   2.1825396825396824e-2
13:08:20 <olsner> wait, no, 12 ... reading the wrong column
13:08:20 <Olathe> We may never know :(
13:10:55 <BMeph_> Olathe: I'd say both current and active are functions of the max.
13:11:04 <Olathe> > let f = floor.(*100) in filter (\n -> f (n/500.0) /= f (n/504.0)) [0..]
13:11:06 <lambdabot>   [5.0,10.0,15.0,20.0,25.0,30.0,35.0,40.0,45.0,50.0,55.0,60.0,65.0,70.0,75.0,...
13:11:13 <Olathe> @users
13:11:13 <lambdabot> Maximum users seen in #haskell: 504, currently: 501 (99.4%), active: 14 (2.8%)
13:11:28 <Olathe> preflex: help
13:11:28 <preflex>  try 'help help' or see 'list' for available commands
13:11:30 <Olathe> @users
13:11:30 <lambdabot> Maximum users seen in #haskell: 504, currently: 501 (99.4%), active: 15 (3.0%)
13:11:40 <Olathe> > 15.0/500.0
13:11:42 <lambdabot>   3.0e-2
13:11:43 <Olathe> > 15.0/504.0
13:11:44 <lambdabot>   2.976190476190476e-2
13:12:03 <Olathe> > round (100*15.0/504.0)
13:12:05 <lambdabot>   3
13:12:15 <Olathe> > round (100*(15.0/504.0))
13:12:17 <lambdabot>   3
13:12:20 <Olathe> Oh.
13:12:26 <Olathe> > let f = floor.(*1000) in filter (\n -> f (n/500.0) /= f (n/504.0)) [0..]
13:12:28 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
13:12:50 <Olathe> > let f = round.(*1000) in filter (\n -> f (n/500.0) /= f (n/504.0)) [0..]
13:12:51 <lambdabot>   [32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0...
13:13:07 <rwbarton> So we need everyone to either leave, or start talking
13:13:13 <andrewsw> hi
13:13:20 * andrewsw tries to push up numbers
13:13:26 <Olathe> rwbarton: Heheh
13:13:29 <Olathe> @users
13:13:30 <lambdabot> Maximum users seen in #haskell: 504, currently: 500 (99.2%), active: 16 (3.2%)
13:13:45 <andrewsw> go baby go!
13:13:50 <Olathe> > let f = round.(*1000) in filter (\n -> f (16/n) /= f (16/504.0)) [0..]
13:13:52 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
13:14:14 <Olathe> > let f = round.(*1000) in reverse $ filter (\n -> f (16/n) /= f (16/504.0)) [0..500]
13:14:15 <lambdabot>   [492.0,491.0,490.0,489.0,488.0,487.0,486.0,485.0,484.0,483.0,482.0,481.0,48...
13:14:29 <andrewsw> on-topic, total noob here, what is the . in round.(*1000)
13:14:42 <rwbarton> @src (.)
13:14:42 <lambdabot> (f . g) x = f (g x)
13:14:48 <Olathe> It does (*1000), then, with the result, does round.
13:14:55 <andrewsw> oh, composition.
13:14:58 <Olathe> Yep.
13:15:02 <andrewsw> as is $
13:15:06 <andrewsw> ?
13:15:13 <rwbarton> kind of/not really
13:15:15 <Olathe> Well, $ is more a separator.
13:15:22 <rwbarton> @src ($)
13:15:23 <lambdabot> f $ x = f x
13:15:23 <Olathe> It can work the same sometimes.
13:15:36 <Olathe> If you want composition for sure, use .
13:15:39 <andrewsw> hmmm... okay
13:15:57 <andrewsw> I'm gradually learning a bit at a time doing projecteuler.
13:16:12 <andrewsw> you can't beat haskell list comprehensions for some of those problems
13:16:25 <rwbarton> $ is only "the same" as . in the sense that  f $ g $ x = f $ (g x) = f (g x) = (f . g) x = f . g $ x
13:16:46 <nathanic> andrewsw: I learned a lot from both project euler and these 99 problems: http://www.haskell.org/haskellwiki/99_Haskell_exercises
13:17:15 <andrewsw> nathanic: cool, thanks!
13:17:17 <nathanic> andrewsw: although some of the 99 suck because they were written originally for lisp
13:17:21 <rwbarton> It's like saying 2 + 2 = 2.4 because 2 + 2 * 5 = 12 :)
13:18:07 <andrewsw> oh. um. okay?
13:18:19 <Olathe> 2 + 2 = 4. 2 * 2 = 4. 2 ^ 2 = 4
13:18:29 <Olathe> So, +, *, and ^ are all equivalent.
13:18:35 <Olathe> QED.
13:18:41 <rwbarton> (the point is "f $ g" in "f $ g $ x" isn't a subexpression--it's "f $ (g $ x)")
13:19:05 <andrewsw> okay, I see.
13:19:18 <andrewsw> sort of. there is a dim glow at the other end of the tunnel.
13:19:21 <trofi> data TWO = TWO ; instance TWO Num ...
13:19:48 <mauke> ( is also function composition
13:19:57 <mauke> since f ( g x)
13:20:01 <ac> dmwit_: around?
13:20:54 <andrewsw> IOW there are myriad ways of expression composition depending on context and I'm probably doing it without realizing it.
13:23:09 <ac> has anybody used Data.FRef with records?
13:23:48 <viktator> hi, i im new with progamming and haskell, would be nice if anyone could help with this problem i have come over
13:24:14 <ac> viktator: shoot
13:24:22 <viktator> i declared a typ IntChar = IntChar {int :: Int, char :: Char}
13:24:46 <viktator> what if a got an IntChar, and what to take out that int?
13:25:03 <viktator> if thats understable... :P
13:25:09 <ac> say your IntChar is named fooIC, then you'd say: int fooIC
13:25:30 <viktator> thanks..will give a try
13:25:49 <ac> viktator: you could also store them in a tupple like (Int, Char). Then you could use fst to retrieve the int, and snd to retrieve the char
13:26:33 <ac> viktator: a tupple is like a record without named slots
13:26:58 <viktator> i see
13:27:25 <MyCatVerbs> viktator: when you give the field names, functions are created with those names which extract the relevant element. For example, in that case, data IntChar = IntChar { int :: Int, char :: Char } declares, as well as the data type, a constructor IntChar :: Int -> Char -> IntChar, a function int :: IntChar -> Int, and a function char :: IntChar -> Char.
13:28:04 <viktator> okey..makes sense
13:28:13 <bos> @seen dcoutts
13:28:13 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 13m 15s ago.
13:28:16 <bos> @seen dons
13:28:16 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 15h 38m 34s ago.
13:28:21 <ac> @seen dmwit_
13:28:21 <lambdabot> dmwit_ is in #haskell, #xmonad and #haskell-blah. I don't know when dmwit_ last spoke.
13:28:39 <mauke> preflex: seen dmwit_
13:28:40 <preflex>  dmwit_ was last seen on #haskell 14 hours, 25 minutes and 40 seconds ago, saying: ok, you get it =)
13:29:10 <ac> what's preflex?
13:29:13 <viktator> ac, MyCatVerbs..thanks!
13:29:26 <ac> viktator: no problem :)
13:30:39 <BMeph_> ac: preflex is mauke's way of inflating the active user count... ;)
13:33:46 <ac> so AFAIU this library, it'd often be convenient to have an FRef defined for every record member. Would it make sense to write some TH to do this automatically?
13:34:40 <Heffalump> data-accessor (an alternate field accessor library) already has that
13:34:48 <Heffalump> (data-accessor-template IIRC)
13:35:04 <ac> Heffalump: ah. Is it worth using?
13:35:38 <Heffalump> well, it's GPLed, so when I needed such a library I looked at it then just implemented the bits I needed myself with the same API
13:35:52 <Heffalump> (since I needed it in something proprietary)
13:36:14 <Heffalump> It seems fine. I don't really like the names that much, but I didn't want to invent my own either.
13:37:50 <ac> Oh, GPL isn't a problem for me. My program's really small but I think I'll use it just for the sake of curiosity
13:39:36 <ac> what does '@' do in a pattern match? I've used it before, but I managed to forget
13:39:58 <mauke> alias
13:40:01 <Valodim> a@(x:xs)
13:40:06 <Valodim> you can use a like the whole list
13:40:34 <Olathe> a@(everything here) -> a == everything here
13:41:47 <ac> ah, "alias" is a good way to remember it. Thanks
13:42:33 <ac> hmm, the function accessor approach could be implemented with complete backwards compatibility, right?
13:43:44 <Olathe> The what ?
13:46:43 <ac> I meant to say "functional accessor". I mean what the data-accessor library does
13:47:47 <quicksilver> conal: hmm. Got joinE and filterMaybes working. New Future representation making 'Always' and 'Never' explicit.
13:47:54 <quicksilver> conal: so 'mappend' can shortcircuit
13:50:33 <conal> quicksilver: cool.  i used to have an explicit Never also.  what's always?
13:50:58 <conal> oh -- from the beginning of time.
13:51:10 <conal> like MinBound and MaxBound in reactive
13:57:19 <lightstep> are there any examples of Data.Reactive that do animation? when searching today, i only found two uses of it: phooey and a web server
13:58:11 <dcoutts> hia bos
13:58:32 <bos> hi dcoutts
13:59:04 <bos> were there any peculiar regressions in bytestring fusion in the versions shipped in ghc 6.8.2 and 6.8.3?
13:59:48 <bos> ketil and i spent a day trying to find out why a test case he could run in 19 seconds took me 110 minutes before i killed it.
14:00:21 <bos> it turned out that updating to the latest bytestring on hackage "fixed" it, but the experience gave me the willies.
14:02:09 <dcoutts> bos: no, not as far as I know
14:02:27 <dcoutts> bos: if you've got a test case that'd be interesting
14:02:28 <bos> hmm, that's exciting.
14:02:32 <bos> we sure do!
14:03:26 <bos> oh, also this failure changes the behaviour of the program from linear time to quadratic.
14:04:29 <bos> dcoutts: i'll send email to you and dons with a repro
14:04:42 <dcoutts> bos: great
14:05:05 <ketil> bos: did you use a *newer* bytestring to get the slow behavior?
14:05:29 <ketil> (I got slow with 0.9.0.1 and fast with 0.9.1)
14:06:12 <bos> ketil: 0.9.0.1.1 has the problem, and 0.9.1.2 doesn't
14:06:17 <bos> so we're the same
14:06:57 <ketil> so it's not really a regression?
14:07:17 <ketil> Don't scare dcoutts more than necessary :-)
14:09:36 <dcoutts> :-)
14:11:08 * BMeph_ puts up a sign: "Please do not molest the Developers."
14:11:42 * BMeph_ puts up a second sing next to it: "The Mind you save may be your own."
14:12:04 <Twey> Hahahaha
14:12:17 <BMeph_> s/sing/sign/
14:12:22 * Twey takes them down and replaces with the more easily recognisable 'Beware the Developers'
14:12:40 <mauke> http://dis.4chan.org/read/prog/1220878547/
14:12:42 <lambdabot> Title: 4chan BBS - why
14:13:09 * BMeph_ usually reads "Beware" as "Please, tease" ...
14:15:07 <Twey> Hahahahaha
14:15:13 <Twey> Nice, mauke
14:19:38 <quicksilver> conal: yes, only I put them in the Future type rather than the Time type
14:19:45 <quicksilver> conal: not sure if that's particularly rational.
14:19:51 <quicksilver> conal: I'm exploring the design space :)
14:23:19 <quicksilver> conal: I think it is rational, because it helps with efficient implementation of joinF and mappend
14:38:30 <tristes_tigres> hello
14:39:31 <bolom> hello, do you know where Cabal puts the sources of the installed packages? (on ubuntu)
14:39:44 <bolom> ...or how to find it out
14:40:05 <tristes_tigres> int-e: you made improvements in http://hpaste.org/9884 , so I need to credit you in the source. what's your e-mail ?
14:40:24 <dcoutts> bolom: sources do not get installed. The sources are unpacked from the tarball, compiled and the lib or exe installed.
14:41:37 <bolom> ...well, according to the app I just installed, for the config part, it asks: "                                         you have to specify folders, under which
14:41:40 <bolom> Haskell source code for installed packages can be found
14:41:42 <bolom> "
14:42:32 <bolom> (i'm just built Leksah, dunno if anyone tried it here)
14:43:26 <bolom> sorry for the bad formatting and wrong english ...seems not my day
14:46:38 <bolom> has anyone used Leksah here?
14:47:05 <dino-> Huh, Haskell IDE. I wonder if it just wants where you'll mostly be putting your projects. Like top-level dir of where you work on things.
14:47:23 <dino-> Like, I have an (arbitrarily chosen) ~/dev/, for instance.
14:47:54 <dons> anyone know if this is a joke,
14:47:54 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:47:54 <dons> http://www.reddit.com/r/programming/new/
14:47:56 <lambdabot> Title: newest submissions : programming
14:47:57 <dons> grr.
14:47:58 <dons> not that.
14:48:02 <dons> http://typicalprogrammer.com/?p=89
14:48:03 <dons> that.
14:48:08 <lambdabot> Title: 12 Typical Programmer 46 - Video Professor announces Haskell, Scheme, and Smallt ...
14:49:23 <andrewsw> wow
14:49:26 <araujo> dons, hi there
14:49:27 <dino-> dons: How bizarre.
14:49:30 <araujo> dons, a joke?
14:49:32 <dons> heya araujo
14:49:42 <dons> well, 'video professor' is kind of infamous.
14:49:42 <dons> a bit like
14:49:45 <dons> the "dummies" books.
14:49:52 <araujo> I just read it a few minutes ago .. and .. it seems interesting .. is a joke?
14:49:56 <araujo> oh
14:50:00 <dino-> dons: I was just typing exactly that comparision, with "for Dummies"
14:50:12 <dons> well, i'd like to see the actual 'video professor' links.
14:50:19 <dons> so if someone wants to do the research
14:51:10 <mrsolo> in haskell mailing list
14:51:12 <Valodim> what the hell
14:51:12 <mrsolo> ...like and read *real* CS books (SICP, EGB, TAOCP, etc...)
14:51:15 <mrsolo> what is EGB?
14:51:22 <Valodim> The new :Pro line of instructional videos builds on our success teaching Windows, Outlook, selling on eBay, and watching YouTube.
14:51:36 <dons> so sounds like a joke, right?
14:51:45 <int-e> GEB?
14:52:31 <mrsolo> geb?
14:52:41 <Igloo> Goedel, Escher, Bach
14:52:45 <Valodim> I think our misperceiving of this as a joke is a subconscious way of dealing with reality
14:53:38 <mapreduce> I think it could be worth lazily evaluating.  Very lazily.
14:53:41 <dons> Valodim: so the reality is that people's grandparents will be programming haskell soon?
14:54:02 <andrewsw> the first google hit for "video professor:pro" is that blog post... suspicious
14:54:05 <mrsolo> igloo: err no :-) computer science book
14:54:09 <olsner> oh, do we already have haskell hackers old enough to be grandparents?
14:54:11 <mrsolo> trying to figure out what book it is
14:54:26 <bos> it's interesting to see all the useless responses on -cafe to the poor fellow asking for a stacktrace.
14:54:51 <dino-> I don't even see VB.NET and C++ on this page: http://www.videoprofessor.com/products/videoprofessorproducts.html
14:54:55 <lambdabot> Title: Basic Computer Education Courses - Learn How to Use a Computer - Video Professor, http://tinyurl.com/zu6zv
14:55:23 <Valodim> hahaha
14:55:24 <Valodim> "Learn The Internet"
14:55:24 <dino-> So: so much for this claim of a ":Pro" line.
14:56:04 <Valodim> whoa check it out
14:56:08 <Valodim> soldiers learn free
14:56:23 <bolom> it's a joke guys
14:57:10 <bolom> see other articles of same site and you'll see it's just pseudo articles, hoax
14:57:50 <andrewsw> apostrophree
14:58:01 <dino-> bolom: Sorry I was no help with the Leksah. I'm a Vim + bash kind of developer.
14:58:20 <bolom> no problem ...i'll try to figure it out
14:58:53 <dino-> dons: I think it's a joke too.
14:59:30 <dino-> Oh, just read that above other "pseudo articles", ok then, moving on.
15:01:00 <dons> good
15:01:39 <marcot> Good evening.  I'm having a strange error in trying to build xmobar with utf8 support.  I run ./Setup configure --flags="with_utf8" and it sais:
15:01:48 <marcot> Setup: At least the following dependencies are missing:
15:01:49 <marcot> X11 >=1.3.0
15:02:42 <marcot> But I have X11-1.4.2 in my ghc-pkg list.
15:02:53 <marcot> http://hpaste.org/10229
15:03:37 <rwbarton> marcot: It's only in the per-user section, and you haven't given the  --user  flag to Setup.hs configure
15:03:47 <marcot> rwbarton: hum, thanks.
15:04:37 <dino-> Does that mean he will only be able to install things built with X11 per-user?
15:04:53 <dino-> Without installing an X11 systemwide?
15:05:56 <dino-> (or she, sorry to presume)
15:14:22 <MyCatVerbs> dino- doesn't want to even start thinking about the possibility that the user is an it.
15:15:07 <MyCatVerbs> Or both or something else besides that can't be expressed without putting at least one set of appendages at right angles to reality (what gender is Cthulhu, anyway?)
15:15:11 <marcot> dino-: don't worry.
15:15:24 <MyCatVerbs> marcot: worry. :)
15:15:53 <marcot> MyCatVerbs: but how should we express then?
15:15:58 <MyCatVerbs> marcot: probability aside, we like to be polite and generally take issue with ourselves when we fail to.
15:16:26 <MyCatVerbs> marcot: "s?he" works well for me, particularly in crowds where regular expression syntax is widely understood. ;P
15:17:16 <MyCatVerbs> marcot: "they" when talking in the abstract, or some people make like El Goonish Shive and just invert the gender of the pronoun upon every usage. :)
15:17:44 <marcot> MyCatVerbs: s?he is not very pretty.  Maybe it can be a reasonable choice..
15:18:05 <dolio> He is the standard English choice.
15:18:09 <marcot> MyCatVerbs: I meant It.
15:18:44 <darrint> Can I lift into the STM monad?
15:18:59 <dolio> Lift what?
15:19:17 <mauke> a -> STM a
15:19:18 <MyCatVerbs> darrint: liftM works just fine, as does everything else build entirely upon (>>=) and return.
15:19:27 <darrint> ok.
15:19:54 <parodyoflanguage> Does anyone know: are there any programming channels on freenode that are more general than a specific programing language?
15:19:55 <MyCatVerbs> marcot: it seems impolite to refer to other human beings by a pronoun normally reserved for inanimate objects, though. :/
15:20:01 <Heffalump> darrint: starting from what?
15:20:20 <dolio> #concatenative isn't dedicated to any specific language.
15:20:24 <marcot> MyCatVerbs: it is used for animals, right?
15:20:24 <darrint> StateT MyType STM AnotherType
15:20:32 <dolio> Although it's dedicated to a specific class of them.
15:20:35 <Heffalump> that's not lifting, that's dropping
15:20:46 <Heffalump> assuming you want to go from that monad to STM
15:20:46 <MyCatVerbs> marcot: yyyyes, but that's a little different.
15:20:57 <parodyoflanguage> dolio: What about programming languages in general?  Or PL theory kind of thing?
15:21:00 <dino-> My Haskell code, she no work
15:21:00 <marcot> MyCatVerbs: I don't mind being considered an animal myself.
15:21:21 <mauke> darrint: runStateT
15:21:28 <dolio> parodyoflanguage: Don't know of one of those. This channel has plenty of PL theory on occasion.
15:21:58 <parodyoflanguage> dolio: Not that I'm any sort of computer scientist, but lately I've become interested in translationg PLs into each other.
15:22:02 <MyCatVerbs> marcot: animals are unlikely to be offended, and there are many situations where one is assured of the presence of an animal, but does not wish to take the risks involved in lifting its tail - gender determination of pissed-off critters is a task that we're often happy to let slide.
15:23:32 <marcot> MyCatVerbs: sure...
15:23:45 <parodyoflanguage> Well, I'll ask here then: Does anyone know what the "state of the art" is in translationg programs from one language to another, and if there is any good info online about it?
15:24:04 <MyCatVerbs> Particularly when they have, like, claws! And laser eyes! Pew pew OH MY $DEITY THE PAIN IT HURTS SO MUCH, etc.
15:24:22 <parodyoflanguage> Right now I feel like I'm just relearning stuff that others have probably already mastered and moved on to other things.
15:24:38 <dolio> I don't think many people work on turning code in one language into code in another, unless you're talking about compiling.
15:24:59 <Heffalump> I think most people that do it are doing so commercially.
15:25:02 <dolio> Or, specifically, not producing any kind of nicely readable code in the target language.
15:25:03 <Cale> parodyoflanguage: you mean, compilers?
15:25:04 <MyCatVerbs> parodyoflanguage: start with compilation in general, I think, because the whole topic is about translating code from one language (usually high-level) into another (usually low-level).
15:25:22 <Heffalump> e.g. Artinsoft, some company in Texas whose name I forget.
15:25:46 <parodyoflanguage> Cale: A compiler is just one kind.  But I'm more interested in translating programs between languages at an equivalent level of abstraction.
15:25:47 <eyu100> > show putStrLn
15:25:48 <lambdabot>       Overlapping instances for Show (String -> IO ())
15:25:48 <lambdabot>        arising from a ...
15:25:54 <MyCatVerbs> parodyoflanguage: there's some more esoteric stuff around the sides, like trying to show and perhaps take advantage of isomorphisms between different languages, but those are really fantastically rare.
15:26:01 <eyu100> > x <- 5
15:26:02 <lambdabot>   mueval: Prelude.read: no parse
15:26:06 <stepcut> isn't there a Haskell to Clean compiler?
15:26:12 <Cale> parodyoflanguage: But that's still a compiler.
15:26:40 <MyCatVerbs> In practice, I mean. Most practical languages have enough edge cases that you can't really build a bijection between programs in any pair of them.
15:26:46 <parodyoflanguage> MyCatVerbs: Okay.  So it sounds like I'm probably treading new ground except for some academic journal lieing somewhere that I can't access anyway.
15:26:48 <dolio> The Clean people are supposedly writing a Haskell98 front-end to their compiler.
15:26:53 <dolio> Not sure if that's what you're talking about.
15:27:01 <eyu100> > ((\x -> \y -> x y z) (+)) (5) (5)
15:27:03 <lambdabot>   Couldn't match expected type `t -> t1' against inferred type `Expr'
15:27:14 <eyu100> > ((\x -> \y -> x y z) (+) (5) (5)
15:27:16 <lambdabot>   mueval: Prelude.read: no parse
15:27:22 <eyu100> > (\x -> \y -> x y z) (+) (5) (5)
15:27:23 <lambdabot>   Couldn't match expected type `t -> t1' against inferred type `Expr'
15:27:27 <dolio> Or, perhaps more than 98. I assume they'll work uniqueness types in somehow.
15:27:32 <MyCatVerbs> parodyoflanguage: nah, CS research tends to be publically published.
15:27:43 <yitz> Isn't someone working on GHC.Core -> YHC.Core?
15:27:43 <rwbarton> Is ListT (State s) a monad?
15:27:43 <eyu100> > (\x -> \y -> 5 + y) 4
15:27:44 <lambdabot>       Overlapping instances for Show (t -> t)
15:27:44 <lambdabot>        arising from a use of `s...
15:27:50 <eyu100> > (\x -> \y -> 5 + y) 4 4
15:27:51 <lambdabot>   9
15:27:54 <MyCatVerbs> yitz: ? Why would someone want to do that?
15:28:00 <dolio> rwbarton: No, technically.
15:28:19 <eyu100> > (\haskell -> \x -> "haskell") 4 4
15:28:20 <lambdabot>   "haskell"
15:28:25 <parodyoflanguage> MyCatVerbs: Yeah.  I've found some of them and have printed them out and read them, but generally can't make heads or tales of them.  There's some interesting stuff on operational semantics that I might be able to use, but most of it is over my head :)
15:28:25 <rwbarton> dolio: Is it up to reordering the result of runListT?
15:28:31 <yitz> rwbarton: ListT is not a monad (it's broken). But ListTDoneRight (State s) is a monad.
15:28:51 <parodyoflanguage> dolio: I don't know.
15:29:00 <rwbarton> I'm pretty sure I don't want ListTDoneRight.  But I thought that ListT m was a monad for *some* monads m (I know it's not for m = []))
15:29:09 <dolio> rwbarton: Not really sure on the details. It may produce genuinely different results if various state modifications happen in different orders.
15:29:13 <MyCatVerbs> parodyoflanguage: what I do when I hit that situation is that I look up the references list.
15:29:20 <Heffalump> parodyoflanguage: I think it's mostly a heuristic problem.
15:29:28 <yitz> MyCatVerbs: So you can write programs using GHC extensions, and then do things like compile them into JavaScript or run them highly parallel on a GPU.
15:29:35 <rwbarton> dolio: I'm trying to do branch-and-bound, with a global best-so-far
15:29:36 <Heffalump> you need to produce nice looking code
15:29:37 <MyCatVerbs> yitz: ooooooh.
15:29:45 <MyCatVerbs> parodyoflanguage: often an earlier paper will have a more basic explaination, sometimes from first principles.
15:31:05 <MyCatVerbs> parodyoflanguage: not always, though. Pretty often someone, somewhere will have written a better introductory paper, and maybe a textbook. I get the impression that papers are more less painful to write than textbooks are, though. Much less writing to do, and the financial payoff is about the same (i.e. generally zilch). ;P
15:31:05 <yitz> rwbarton: I'm not sure if it's a monad even for Identity.
15:31:07 <parodyoflanguage> Heffalump: If we mean the same thing by heuristics, then I think you're right.  I'm not expecting AI, which would be needed for the computer to take over all the translation.  I'm thinking more on the level of metaprogramming.  Every program, in my opinion, develops the sort of constructs needed to solve a given problem, which can be thought of as a domain specific language.  So translation can take into account differe
15:31:17 <dolio> rwbarton: Well, it's not like it will fail to work or anything. It's just that ListT (State s) doesn't satisfy the associativity law.
15:31:24 <Heffalump> you got chopped at "take into account differe"
15:31:27 <parodyoflanguage> MyCatVerbs: I think I need a textbook :)
15:31:28 <Heffalump> (there's a line length limit)
15:31:33 <dolio> And so it's not a monad.
15:31:51 <MyCatVerbs> parodyoflanguage: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/
15:31:55 <lambdabot> Title: Programming Languages: Application and Interpretation by Shriram Krishnamurthi, http://tinyurl.com/2bhkwx
15:32:16 <parodyoflanguage> MyCatVerbs: thanks: So translation can take into account different levels.
15:32:39 <MyCatVerbs> parodyoflanguage: PLAI might be a good place to start. Teaches you how to write interpreters, which is a nice way to understand semantics.
15:33:58 <parodyoflanguage> MyCatVerbs: Thanks.  I'll check it out.
15:35:40 <rwbarton> yitz: ListT Identity is isomorphic to [] and I'm pretty sure the definitions of (>>=) and return correspond, so ListT Identity should be a monad
15:37:04 <yitz> rwbarton: could be. yeah that makes sense.
15:37:14 <andrewsw> how do I declare a type signature for a function that has no parameter?
15:37:20 <dolio> rwbarton: The real danger I could see in such a situation is that GHC could theoretically put in an optimization that used the associative law fiddle with some monadic computations (do desugaring isn't always most efficient), so in that case, where the optimization fires can change the results of your code, which is a no-no.
15:37:28 <mauke> andrewsw: er, that's not a function
15:37:34 <andrewsw> yeah, okay.
15:37:56 <andrewsw> umm...
15:38:31 <andrewsw> nm.
15:39:17 <yitz> rwbarton: so then Maybe ought to work also.
15:40:09 <yitz> dolio: when ListT fails the monad laws, you get into trouble even without GHC mangling things.
15:40:53 <dolio> Sure. You could perform your own algebraic manipulations that don't preserve semantics.
15:41:06 <rwbarton> For the record, one of the counterexamples on the "ListT done right" page is for ListT IO but only uses IORefs and the same counterexample works for ListT (State s).
15:41:14 <eyu100> > IO ()
15:41:15 <lambdabot>   mueval: Prelude.read: no parse
15:41:21 <eyu100> > putStrLn "a"
15:41:22 <lambdabot>   mueval: Prelude.read: no parse
15:41:22 <lambdabot>  mueval: *** Exception: "<IO ()>"
15:42:09 <parodyoflanguage> MyCatVerbs: Thanks again!  I'm printing out the first chapter now.  Sometimes wandering around the web doesn't bear much fruit. :)
15:42:50 <yitz> rwbarton: for Identity, ListT and ListTDR are equivalent. But they are not for State.
15:43:13 <yitz> rwbarton: what's wrong with just using ListTDR?
15:43:13 <dolio> Yeah, and in that example, I believe the results are the same modulo not caring what value you get out of the IORef.
15:43:31 <dolio> Or use LogicT. :)
15:43:36 <Igloo> What's a good URL for webspace for community.h.o projects? projects.haskell.org/$project/?
15:44:53 <yitz> Igloo: why not comunity.h.o/...
15:45:00 <yitz> s/m/mm/
15:45:57 <Igloo> yitz: I guess so. I'm just a bit nervous that we might want to put other stuff there in the future
15:46:00 <leoncamel> exit
15:46:52 <yitz> Igloo: community.h.o/projects/<project-name>? Hmm, longer I guess. What would have the right RESTful semantics though?
15:47:15 <dolio> LogicT is even continuation-based, which GHC might optimize better (not sure).
15:47:20 <Igloo> yitz: I think we may as well use foo.h.o rather than c.h.o/foo
15:47:27 <thelsdj> must be a better way to do this? http://hpaste.org/10230
15:48:33 <sheyll> hi
15:48:55 <thelsdj> annoted with a little simpler version, but wondering if theres a much better way to do it
15:49:01 <yitz> Igloo: current usage is h.o/foo I believe. like ghc, etc.
15:49:19 <sheyll> hmm I wonder what http library should I use to query google maps?
15:49:31 <rwbarton> thelsdj: well, safeInit_ is already defined for you as init :)
15:49:32 <Igloo> yitz: foo == www in ghc's case
15:50:18 <dolio> Yeah, your safeInit_ doesn't actually handle the [] case.
15:51:15 <thelsdj> yea i know i could do it by just wrapping init (which is really what i've done here) but still wondering if theres another way to do it?
15:51:38 <shukhov> is there an easy way to time functions in haskell?
15:53:36 <rwbarton> dolio: How does LogicT compare to ListT Done Right?
15:55:17 <yitz> Igloo: you mean, we're talking about projects whose web space will be hosted elsewhere?
15:55:50 <dolio> rwbarton: It's continuation based instead of being an algebraic type internally, and it has a bunch of extra operations defined for doing certain logic programming-type stuff (fair choice, pruning, etc.).
15:56:08 <Igloo> yitz: What I mean is, community.h.o/projects/<project-name> isn't any better than projects.h.o/<project-name> AFAICS
15:56:12 <Igloo> and the latter is shorter
15:56:24 <dolio> Not that you couldn't define those for ListT done right, but they're in the LogicT library already.
15:57:18 <rwbarton> Ah, I hadn't noticed Control.Monad.Logic.Class
15:57:50 <dolio> The main difference, I suppose, is that you can do 'cabal install logict' instead of copying from a wiki page. :)
15:59:12 <dolio> And LogicT was pulled from a paper by Oleg, so you know it's awesome.
15:59:26 <yitz> Igloo: ok. I guess the variables are, how people will perceive it, and what admin/IT headaches each might cause. shortness affects perception in a certain way. but it may be more important to make it clear that this is part of community.
16:01:36 <yitz> dolio: the advantage of ListTDR is it is much simpler, leading to more maintainable and malleable code.
16:02:25 <dolio> ListT done right is actually in monadLib, I think.
16:02:32 <dolio> Under some other name. ChoiceT or something.
16:03:01 <yitz> dolio: makes sense. monadLib did a lot of things right to begin with.
16:03:42 <dolio> Or, at least, a non-CPS version of LogicT.
16:05:41 <yitz> sheyll: I wonder if there is a Google API implementation in Haskell.
16:08:26 <yitz> sheyll: If not, then just the HTTP package from hackage, I guess.
16:15:38 <pelirrojo> ok, am i being dumb, or does it seem weird to use foldr and foldl to return lists?
16:15:51 <pelirrojo> got 2 questions here that require me to use foldr and foldl to return lists
16:16:10 <sjanssen> pelirrojo: it isn't really weird
16:16:23 <bos> foldl would be a little unusual, but not foldr.
16:16:28 <pelirrojo> ah so im being dumb
16:16:34 <sjanssen> though it may stretch your concepts of those functions
16:16:53 <dibblego> pelirrojo, what are the questions?
16:16:57 <luite> @src reverse
16:16:58 <lambdabot> reverse = foldl (flip (:)) []
16:17:14 <pelirrojo> dibblego: first one is to define filter p with foldr
16:17:25 <dibblego> pelirrojo, got a link?
16:17:26 * sjanssen points out the only legitimate use of foldl in the world
16:17:35 <pelirrojo> Define filter p as an instance of foldr
16:17:38 <pelirrojo> thats the entire thing :P
16:17:49 <ddarius> pelirrojo: That's easy.
16:17:54 <dibblego> ok, so take a look at the of foldr and match things up
16:17:56 <dibblego> @type foldr
16:17:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:18:07 <sjanssen> pelirrojo: yep, that's common.  In fact GHC does this to take advantage of an optimization called fusion
16:18:17 <ddarius> pelirrojo: If you know how to do it by writing a recursive definition of filter, just match that to foldr's definition.
16:19:23 <pelirrojo> thanks, ill have a think about it and be back soon
16:20:31 <yitz> sjanssen: so what is the legitimate use of foldl?
16:21:40 <dibblego> pelirrojo, once you've done that, you might be interested in http://blog.tmorris.net/haskell-exercises-for-beginners/ (which contains this question among others)
16:21:46 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » Haskell exercises for beginners
16:23:34 <sjanssen> yitz: reverse
16:23:52 <sjanssen> yitz: or any other direct constructor application, but mostly just reverse
16:24:38 <yitz> sjanssen: shouldn't reverse be foldl'?
16:25:35 <Taggnostr> is there some function able to see if a number is prime?
16:26:55 <sjanssen> yitz: it's a constructor application, so seq isn't necessary
16:27:45 <pelirrojo> oh i see, you use : as the function
16:27:53 * pelirrojo thanks wikipedia for its glory
16:28:03 <pelirrojo> just saw how map is defined :P
16:29:52 <Olathe> @hoogle prime
16:29:53 <lambdabot> Data.HashTable prime :: Int32
16:29:53 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
16:29:53 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
16:29:53 <lambdabot> a
16:30:20 <Olathe> > Data.HashTable.prime 7
16:30:22 <lambdabot>   Couldn't match expected type `t1 -> t'
16:30:27 <Olathe> > Data.HashTable.prime
16:30:28 <lambdabot>       Not in scope: `Data.HashTable.prime'
16:30:32 <Olathe> OK
16:31:04 <yitz> sjanssen: a flip of a contruction application. And the constructor is lazy.
16:33:29 <Olathe> @src nubBy
16:33:30 <lambdabot> nubBy eq []             =  []
16:33:30 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:34:09 <Olathe> > nubBy ((==0).mod) [2..]
16:34:11 <lambdabot>   Couldn't match expected type `a -> Bool'
16:34:20 <mauke> needs more lift
16:34:23 <Olathe> :t nubBy
16:34:24 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
16:34:43 <Olathe> > nubBy (\a b -> a < b) [2..]
16:34:55 <BMeph_> mauke: s/lift/cowbell/ ? ;)
16:34:59 <lambdabot>   thread killed
16:35:00 <mauke> > nubBy (((==0).).mod) [2..]
16:35:02 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
16:35:02 <Olathe> > nubBy (\a b -> a < b) [2..]
16:35:11 <Olathe> Bad lambdabot !
16:35:18 <lambdabot>   thread killed
16:35:29 <Olathe> @where nubBy
16:35:29 <lambdabot> I know nothing about nubby.
16:35:33 <Olathe> @hoogle nubBy
16:35:34 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
16:36:32 <cetin> hi, how can I start a process (that normally blocks) in a non-blocking way using bash, some linux command or haskell library?
16:38:24 <mauke> what &
16:39:09 <ddarius> yitz: seq (x:xs) y === y.  The flip might leave a small thunk, but not (much) worse than a cons cell so there is little or nothing gained by forcing.
16:41:37 <Olathe> > nubBy (\a b->mod b a==0) [2..]
16:41:40 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:42:22 <mauke> > nubBy(((>0).).gcd)[2..]
16:42:37 <lambdabot>   thread killed
16:42:59 <mauke> my emperor!
16:43:02 <Olathe> > let isPrime x = (head $ takeWhile (<x) $ nubBy (\a b->mod b a==0) [2..]) == x in map isPrime [0..]
16:43:05 <lambdabot>   mueval: Prelude.read: no parse
16:43:05 <lambdabot>  mueval: [*** Exception: Prelude.head: empty...
16:44:02 <Olathe> > let isPrime x = last $ nubBy (\a b->mod b a==0) [2..x]) in isPrime 2
16:44:09 <lambdabot>   mueval: Prelude.read: no parse
16:44:16 <Olathe> > let isPrime x = last $ nubBy (\a b->mod b a==0) [2..x] in isPrime 2
16:44:19 <lambdabot>   2
16:44:30 <Olathe> > let isPrime x = (last $ nubBy (\a b->mod b a==0) [2..x]) == x in isPrime 2
16:44:34 <lambdabot>   True
16:44:44 <Olathe> > let isPrime x = (last $ nubBy (\a b->mod b a==0) [2..x]) == x in map isPrime [0..]
16:44:48 <lambdabot>   mueval: Prelude.read: no parse
16:44:48 <lambdabot>  mueval: [*** Exception: Prelude.last: empty...
16:44:52 <Olathe> > let isPrime x = (last $ nubBy (\a b->mod b a==0) [2..x]) == x in map isPrime [2..]
16:44:56 <lambdabot>   [True,True,False,True,False,True,False,False,False,True,False,True,False,Fa...
16:46:06 <Olathe> @hoogle a -> [a] -> Bool
16:46:07 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
16:46:07 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
16:46:07 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
16:46:46 <Olathe> > let primes nubBy (\a b->mod b a==0) [2..x]; isPrime = flip elem primes in map isPrime [0..]
16:46:49 <lambdabot>   mueval: Prelude.read: no parse
16:47:06 <Olathe> Hmm...
16:48:00 <int-e> missing a =
16:48:23 <int-e> but 'elem' will fail for obvious reasons
16:49:55 <Olathe> > let primes = nubBy (\a b->mod b a==0) [2..]; isPrime x = x==(head.dropWhile (<x)) primes in isPrime 11
16:49:59 <lambdabot>   True
16:50:07 <Olathe> Yeah, it will :)
16:50:32 <int-e> you know what I meant :)
16:50:55 <codacola> well yay, i have foldr making a list. just gotta work out how to remove the bad elements :P
16:51:36 <Olathe> Oh, I fixed it in that ;)
16:51:45 <Olathe> > let primes = nubBy (\a b->mod b a==0) [2..]; isPrime x = x==(head.dropWhile (<x)) primes in map isPrime [0..]
16:51:49 <lambdabot>   [False,False,True,True,False,True,False,True,False,False,False,True,False,T...
16:52:07 <Olathe> codacola: What are the bad elements ?
16:52:08 <int-e> @type let filter p = foldr (\x xs -> if p x then x:xs else xs) [] in filter
16:52:09 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:53:24 <Olathe> @unpl flip mod
16:53:24 <lambdabot> (\ b c -> mod c b)
16:53:35 <Olathe> @unpl (==0).(flip mod)
16:53:35 <lambdabot> (\ g -> (\ d -> mod d g) == 0)
16:53:47 <Olathe> Eww.
16:53:56 <codacola> Olathe: any that dont statisfy the condition
16:54:33 <Olathe> Ahh.
16:55:17 <Olathe> Hmm...I haven't used foldr for list-making yet.
16:55:33 <Olathe> An interesting idea.
16:56:45 <codacola> hm, think ive semi got it
16:57:52 <codacola> nope
16:57:59 <int-e> > let reverse = ($ []) . foldr (\x xs -> xs . (x:)) id in reverse [1..5]
16:58:03 <lambdabot>   [5,4,3,2,1]
16:58:20 <ddarius> Olathe: Not really.  The result type of foldr is a universally quantified variable.  Just choose a list type.
16:58:56 <Olathe> Hmm...
16:59:38 <ddarius> Really, you shouldn't be thinking much about the result type at all.  You should just be recognizing a pattern of recursion.
17:00:30 <int-e> right.  f [] = a; f (x:xs) = g x (f xs) ---> f = foldr g a
17:00:42 <codacola> heh, my haskell exam is the last for the semester
17:04:48 <Olathe> foldb > foldr
17:05:32 <ac> ross: can I have a hackage account? ;)
17:06:03 <FunctorSalad> am I going crazy? can't "type" statements have existentials on the right?
17:06:14 <FunctorSalad> :-(
17:07:51 <codacola> haskell will always drive you mad, its one of its best featureas
17:08:12 <FunctorSalad> :)
17:08:13 <Olathe> > (foldr (+) 0 $ map (1%) [1..10000]) == 0
17:08:28 <lambdabot>   thread killed
17:08:29 <Olathe> > (foldb (+) 0 $ map (1%) [1..10000]) == 0
17:08:38 <lambdabot>   False
17:08:48 <Olathe> > (foldr (+) 0 $ map (1%) [1..5000]) == 0
17:08:54 <mmorrow> foldl'
17:09:03 <lambdabot>   thread killed
17:09:05 <Olathe> > (foldl' (+) 0 $ map (1%) [1..10000]) == 0
17:09:20 <lambdabot>   thread killed
17:09:25 <mmorrow> heh
17:09:31 <Olathe> > showfold foldl'
17:09:40 <lambdabot>   "fold (+) 0 [1..10] = ((((((((((0 + 1) + 2) + 3) + 4) + 5) + 6) + 7) + 8) +...
17:09:43 <mmorrow> > foldl' (+) 0 $ map (1%) [1..100]
17:09:43 <Olathe> > showfold foldb
17:09:50 <lambdabot>  Terminated
17:09:50 <lambdabot>  Terminated
17:09:52 <Olathe> > showfold foldb
17:09:55 <mmorrow> > foldl' (+) 0 $ map (1%) [1..10]
17:10:04 <lambdabot>   7381%2520
17:10:04 <lambdabot>   "fold (+) 0 [1..10] = (0 + ((((1 + 2) + (3 + 4)) + ((5 + 6) + (7 + 8))) + (...
17:10:09 <mmorrow> > foldl' (+) 0 $ map (1%) [1..100]
17:10:18 <mmorrow> oh
17:10:18 <lambdabot>   14466636279520351160221518043104131447711%278881500918849908658135235741249...
17:10:26 <Olathe> foldb always sums two closely-sized numbers.
17:10:38 <Olathe> foldl' has a huge plus a tiny.
17:10:47 <Olathe> So, it goes quicker for some reason.
17:10:55 <mmorrow> i think the problem is that (+) with (%) isn't strict
17:11:06 <Olathe> Perhaps.
17:11:29 <mgsloan> Is there any libs for dual way - Maps, or should I just write my own wrapping it?
17:11:34 <mmorrow> and the foldl' can't force more than one level
17:12:15 <FunctorSalad> "newtype Foo = Foo (forall a. a -> a)" -- what am I doing wrong? haaalp
17:12:28 <TSC> @src foldb
17:12:28 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:12:33 <Olathe> Are Integers strict ?
17:12:39 <FunctorSalad> (I have "{- #OPTIONS_GHC# -fglasgow-exts -XRankNTypes -}")
17:12:39 <Olathe> One sec.
17:12:48 <Olathe> let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs))
17:13:19 <int-e> Olathe: in the sense that Integer operations are strict, yes.
17:13:25 <mmorrow> > foldl' (\(a,b) (c,d) -> let (x,y) = (a+c,b+d) in x `seq` y `seq` (x,y)) (0,0) (zip [0..100000] [0..100000])
17:13:30 <ac> is Ross Paterson here?
17:13:33 <lambdabot>  Terminated
17:13:38 <mmorrow> > foldl' (\(a,b) (c,d) -> let (x,y) = (a+c,b+d) in x `seq` y `seq` (x,y)) (0,0) (zip [0..10000] [0..10000])
17:13:43 <lambdabot>   (50005000,50005000)
17:13:58 <mmorrow> > foldl' (\(a,b) (c,d) -> (a+c,b+d)) (0,0) (zip [0..10000] [0..10000])
17:14:06 <lambdabot>   (50005000,50005000)
17:14:09 <mmorrow> bad example
17:14:18 <int-e> FunctorSalad: {-# OPTIONS_GHC ... #-}, although you should really use {-# LANGUAGE RankNTypes #-}
17:14:27 <mmorrow> Olathe: but that's how i meant
17:15:28 <mmorrow> (since the a%b is kinda like (a,b)
17:15:30 <mmorrow> )
17:15:33 * int-e prefers the foldb without an "initial" element
17:16:09 <codacola> theres a foldb?
17:16:28 <mmorrow> someone probably defined it with @let
17:16:34 <mmorrow> > L.foldb
17:16:55 <mmorrow> @type L.foldb
17:16:58 <FunctorSalad> int-e: I tried that too (with -X though)... and anyway, it used to work that way and I don't remember upgrading ghc :-(
17:17:28 <Olathe> I define it with @let every once in a while.
17:17:42 <mmorrow> oh, just saw your def
17:17:48 <mmorrow> let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs))
17:17:59 <Olathe> I think the poor bot died.
17:18:02 <Olathe> @bot
17:18:06 <mmorrow> yeah
17:18:06 <FunctorSalad> oh, it was the space at the third character.
17:18:10 <FunctorSalad> I feel so dumb now
17:18:15 <Olathe> Oh, it's coming back.
17:18:16 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
17:18:16 <lambdabot> :)
17:18:23 <lambdabot>       Overlapping instances for Show ((a -> a -> a) -> a -> [a] -> a)
17:18:23 <mmorrow> @botsnack
17:18:23 <lambdabot>        ...
17:18:23 <lambdabot> :)
17:18:39 <FunctorSalad> ( "{- #OPTIONS ..." doesn't work )
17:19:42 <Olathe> > foldl' (*) 1 [1..100000] == (0::Integer)
17:19:45 <int-e> mmorrow: why not  go [x] = x?
17:19:50 <lambdabot>   mueval: Prelude.read: no parse
17:19:58 <Olathe> No parse ?
17:20:27 <int-e> mmorrow: (using foldb makes little sense if  f z x /= x, as far as I can see)
17:20:43 <Olathe> > foldl' (*) 1 [1..100000] == (0::Integer)
17:20:51 <lambdabot>   False
17:20:51 <int-e> FunctorSalad: did you read the first part of my answer?
17:21:38 <int-e> FunctorSalad: -# OPTIONS_GHC -XRankNTypes #-} certainly works.
17:21:41 <int-e> woops
17:21:47 <int-e> {-# OPTIONS_GHC -XRankNTypes #-}
17:22:11 <FunctorSalad> int-e: yeah, I thought the first part was stating my error (i.e., using OPTIONS_GHC rather than LANGUAGE)
17:22:22 <FunctorSalad> but as I said, it was the space before the first #
17:22:33 <Olathe> > foldl' (*) 1 [1..1000000] == (0::Integer)
17:22:48 <lambdabot>   thread killed
17:22:55 <Olathe> > foldb (*) 1 [1..1000000] == (0::Integer)
17:23:06 <lambdabot>   False
17:23:20 <int-e> > foldb (*) 1 [1..1000000]
17:23:25 <Olathe> Heheh
17:23:35 <lambdabot>   thread killed
17:23:48 <int-e> > foldb (*) 1 [1..500000] -- maybe?
17:23:57 <lambdabot>   102280158465190236533091744057193133792628620827224248408083129207090240468...
17:24:18 <Olathe> > foldl' (*) 1 [1..500000]
17:24:33 <lambdabot>   thread killed
17:25:25 <FunctorSalad> hmm... is a class even appropriate if I need to define some tokens (as data with zero constructors) but want to add more tokens of the same type later?
17:25:51 <FunctorSalad> or should I just do "data Foo = A | B | C | ... | UserDefined String"
17:26:21 <FunctorSalad> seems like the class would be overkill
17:27:56 <FunctorSalad> (the class solution would be "class FooClass where {}; type Foo = forall a. (FooClass a) => a"
17:28:03 <FunctorSalad> )
17:28:40 <ac> hm. I'm trying to install cabal-upload, which requires an older version of HTTP, which fails to build with "Could not find module `Data.Array.MArray': it is a member of package array-0.1.0.0, which is hidden"
17:29:05 <int-e> FunctorSalad: a middle ground approach would be  data Foo ext = A | B | ... | Ext ext
17:29:05 <FunctorSalad> ac: tried "ghc-pkg expose array"?
17:29:12 <dcoutts> ac: you do not want cabal-upload, you want cabal-install
17:29:25 <ac> dcoutts: I'm trying to create a cabal package
17:29:31 <dcoutts> ac: cabal-install has the cabal-upload feature
17:29:39 <ac> dcoutts: oh. I already have cabal-install
17:29:51 <dcoutts> ac: see "cabal upload --help"
17:30:27 <ac> dcoutts: thanks :-P
17:30:27 <FunctorSalad> int-e: *nod*
17:31:01 <mmorrow> int-e: foldb is Olathe's :)
17:31:08 <dcoutts> ac: np :-)  cabal-install does everything :-) it is *the* new command line interface to cabal/hackage replacing "runghc Setup.hs", cabal-setup and cabal-upload
17:32:01 <FunctorSalad> though my atoms are about as atomary as possible; they're going to be constant symbols for logic... so even the String argument is just for uniqueness
17:32:26 <ac> dcoutts: oh, that's good to know. I was still using runghc Setup.hs/lhs
17:32:43 <int-e> dcoutts: can it do something like this? alias S-config='runghc Setup.*hs configure --prefix=/opt/ghc-$GHC_VERSION'
17:32:43 <dcoutts> ac: see cabal --help for the list of commands
17:32:56 <dcoutts> int-e: yes
17:33:16 <dcoutts> int-e: using the ~/.cabal/config you can set default options
17:34:35 <dcoutts> install-dirs global
17:34:35 <dcoutts>   prefix: /opt/$compiler
17:34:52 <Olathe> int-e: I did it that way so that :
17:34:54 <Olathe> > foldr (+) 2 [1] == foldb (+) 2 [1]
17:35:00 <lambdabot>   True
17:35:17 <int-e> > foldb (+) 2 [1,2,3]
17:35:22 <lambdabot>   8
17:35:38 <dcoutts> int-e: ^^ will give you exactly what you want. Oh, though you should also set user-install: False and perhaps also root-cmd: sudo
17:35:57 <dcoutts> int-e: if you want global installs by default which it sounds like you do
17:36:41 <Olathe> > scanl (take 1) "Hello, how are you."
17:36:46 <lambdabot>   Couldn't match expected type `b -> [a]' against inferred type `[a]'
17:36:47 <Olathe> > scanl1 (take 1) "Hello, how are you."
17:36:48 <dcoutts> int-e: note that the default install paths also use the compiler id, so they will not clash and you do not need to add a top level compiler id, unless you want to and it helps you organise things
17:36:51 <lambdabot>   Couldn't match expected type `[a] -> [a]'
17:36:52 <int-e> dcoutts: actually /opt/ghc-* is writable for my user (there's only one user on the system anyway)
17:36:55 <Olathe> Bah.
17:37:18 <dcoutts> int-e: the global/user thing is more to do with which package db we register into
17:37:28 <dcoutts> int-e: so that has to be writable too
17:37:31 <int-e> yep
17:37:37 <int-e> I need that flag
17:39:50 <FunctorSalad> wasn't there some syntax for deriving an instance from a field of a constructor?
17:43:31 <mmorrow> there's stand-alone deriving, but i'm not sure what you mean by "a field of a constructor"
17:44:37 <dancor> i can't do this with a guard eh?:  | UserError s <- e && ": exited with code 1" `isSuffixOf` s =
17:44:54 <dancor> seem like it would be useful, save some casing
17:45:14 <mmorrow> | UserError s <- e , e `isSuffixOf` s
17:45:14 <rwbarton> what if you change && to | ?
17:45:21 <FunctorSalad> mmorrow: data Baz { id :: String, value :: Graph x y } deriving (id.Show) (doesn't exist)
17:45:22 <rwbarton> ah, that seems more likely
17:45:34 <FunctorSalad> mmorrow: but nvm, deriving them by hand isn't that hard ;)
17:45:46 <mmorrow> FunctorSalad: what's that supposed to mean?
17:45:56 <mmorrow> only show that one field in show _ ?
17:46:06 <FunctorSalad> mmorrow: yes
17:46:19 <mmorrow> ahh. i don't think there's a syntax for that
17:46:22 <rwbarton> FunctorSalad: that only happens to make sense because the "a" in Show a only occurs in contravariant positions in the signature of Show
17:46:23 <FunctorSalad> (show's a bad example, but for, say, Ord)
17:46:28 <mmorrow> heh, ok
17:46:34 <mmorrow> yeah no
17:47:01 <FunctorSalad> rwbarton: hmm, true
17:47:17 <FunctorSalad> forget what I said then ;-)
17:52:14 <dancor> i seem to only get UserError if i import GHC.IOBase
17:52:22 <dancor> am i not supposed to be using that constructor?
17:58:37 <ac> why are some package names capitalized? And are there too many packages that start with "h" or "hs"?
17:59:06 <dancor> ah ok, need isUserError and ioeGetErrorString
18:00:36 <dancor> ac: idk, http://www.haskell.org/cabal/proposal/x138.html has no info on standard for that
18:00:37 <lambdabot> Title: The Haskell Package System: overview
18:01:28 <dancor> ac: re h/hs, sometimes it's fun to take a normal word and prepend h
18:01:50 <dancor> whereas the normal word would be too normal to sound like a package
18:02:44 <dancor> cabal is moving toward being case-insensitive
18:02:46 <dancor> i thikn
18:03:28 <ac> I just wrote a chess clock program, and I'm debating on whether I should call it "gameclock" or "hsgameclock" :-P
18:03:45 <Olathe> Are nonprogrammers going to use it ?
18:04:13 <Olathe> If so, I'd go with the gameclock.
18:04:26 <ac> Olathe: sure they could... but how many nonprogrammers are going to be downloading things from hackage?
18:04:33 <Olathe> Ahh :)
18:04:38 <dancor> ac: dare to dream?
18:05:03 <Olathe> You could make a huge website for the program and support forums and the rest and have a link to hackage.
18:05:04 <ac> well, maybe it'll be added to the debian archives, because there is no such package now
18:40:10 <dons> http://pragdave.blogs.pragprog.com/pragdave/2008/09/fun-with-procs.html
18:40:19 <dons> hmm . looks like curry/partial apply confusion again :(
18:40:21 <lambdabot> Title: PragDave: Fun with Procs in Ruby 1.9, http://tinyurl.com/675zbz
18:42:59 <dons> hehe. buy 2 RWH, get 1 free. http://oreilly.com/catalog/9780596514983/
18:43:03 <lambdabot> Title: Real World Haskell | O'Reilly Media
18:43:04 <dons> every haskell book must go!
18:43:08 <dolio> Nice.
18:46:11 <dino-> dons: I would do that. I would bring one to work and give one to someone whom I think needs to enrich themself.
18:46:38 <dons> hehe
18:48:05 <dino-> Now, I already pre-ordered with Amazon months ago, so I would end up with 4. :o
18:48:22 <dons> hah. that's probably too many.
18:48:31 <dino-> Stocking stuffers for xmas.
18:48:35 <Olathe> You can always do 2 RWH and get a free something else.
18:48:44 <dolio> So, you guys ended up with a Japanese warrior beetle, eh?
18:49:58 <FunctorSalad> hmm... I have a method "class A b where f :: b -> MyExistential", but I can't seem to declare an instance where different types contained in MyExistential are returned
18:50:21 <dons> dolio: a warrior beetle of some form, yes.
18:55:36 <FunctorSalad> sorry if anyone replied to me, bad connection
18:56:03 <dolio> Nobody did. I'm not really sure what you mean.
18:56:13 <dolio> Can you paste an example that you think should work but doesn't?
18:56:38 <int-e> dcoutts: I've settled for alias cabal="cabal --config-file=\$HOME/.cabal/config-\$GHC_VERSION"  ... the GHC_VERSION environment variable doesn't include the release date in my case.
18:57:01 <int-e> dcoutts: so using $compiler doesn't work for me.
18:57:07 <FunctorSalad> yes, one moment...
18:58:47 <Olathe> > CReal
18:58:48 <lambdabot>   mueval: Prelude.read: no parse
19:01:32 <Olathe> @hoogle CReal
19:01:33 <lambdabot> No results found
19:01:54 <waynemokane> are there any contraindications for talking to lambdabot privately?
19:02:00 <Olathe> I could have sworn there was something like CReal that allowed lots of digits.
19:02:31 <Olathe> waynemokane: Don't do it if you have a heart condition, are pregnant, or have recently started taking an MAOI.
19:02:56 <waynemokane> Olathe: LOL thanks for the warning
19:03:16 <waynemokane> type signatures should not be considered medical advice, etc.
19:03:20 <Olathe> Heheh
19:04:28 <Myoma> > (1/3) ::CReal
19:04:29 <lambdabot>   0.3333333333333333333333333333333333333333
19:04:36 <Myoma> > (pi - 22/7) ::CReal
19:04:37 <Olathe> Ahh, thanks.
19:04:38 <lambdabot>   -0.0012644892673496186802137595776399729457
19:04:54 <Myoma> ^ buggy
19:04:55 <Olathe> How do you get a certain count of digits ?
19:04:56 <FunctorSalad> Olathe: finally someone who will get my "ROFLMAO-inhibitor" line? :)
19:06:06 <FunctorSalad> dolio: here, I tried to shorten it as much as possible http://hpaste.org/10235
19:06:42 <Olathe> > showCReal 100 pi
19:06:44 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
19:06:48 <Olathe> There we go :)
19:06:52 <Olathe> > length $ showCReal 100 pi
19:06:54 <lambdabot>   101
19:07:03 <FunctorSalad> but I'll probably lag out again :(
19:07:23 <dolio> That's not actually an existential type.
19:07:50 <Olathe> What's an existential type ?
19:07:58 <Myoma> > drop 80$ showCReal 100 pi
19:07:59 <lambdabot>  Terminated
19:08:01 <Myoma> > drop 80$ showCReal 100 pi
19:08:02 <lambdabot>   "998628034825342117068"
19:08:05 <Myoma> > drop 80$ showCReal 1000 pi
19:08:07 <lambdabot>   "99862803482534211706798214808651328230664709384460955058223172535940812848...
19:08:20 <FunctorSalad> dolio: Cat?
19:08:36 <Olathe> > reverse.take 20.reverse.showCReal 1000 $ pi
19:08:37 <lambdabot>   "66111959092164201989"
19:08:38 <dolio> If you stick in the synonym, you get "f -> (forall c. CatClass c => c)" which I believe is the same as "CatClass c => f -> c"
19:08:47 <int-e> > head $ [n | n <- [1..], (1 :: CReal) == 1 + 1/10^n]
19:08:49 <lambdabot>   42
19:08:50 <dolio> You need an actual data type to make existential types.
19:08:59 <dolio> Since GHC doesn't do first-class existentials.
19:09:11 <FunctorSalad> dolio: but Cat itself is existential (or sigma-type if that's more correct)?
19:09:18 <ddarius> dolio: It is the same.
19:09:33 <dolio> No, it's not existential. It's a synonym for a universal type.
19:09:52 <dolio> Kind of a weakness of the GHC existential syntax.
19:10:35 <Olathe> This is quite an existential quandary.
19:10:56 <dolio> Notice, you don't even have existential types turned on in the options section.
19:12:02 <Olathe> > floorSqrt 25
19:12:03 <sclv_> not sure what you mean by "first-class existentials"?
19:12:03 <lambdabot>   mueval: Prelude.read: no parse
19:12:15 <FunctorSalad> dolio: I thought Rank-N-types implied them
19:12:16 <Olathe> > floorsqrt 25
19:12:17 <lambdabot>   mueval: Prelude.read: no parse
19:12:23 <Myoma> ugh
19:12:37 <dolio> A proper existential type would be: "data Cat = forall c. CatClass c => Cat c" I believe.
19:12:48 <sclv_> right -- f -> (forall c. CC c => c) isn't the same as CC c => f -> c
19:13:16 <Myoma> @let isqrt x = unsafePerformHead (do i <- [1..x] ; guard (i * i == x) ; return i)
19:13:18 <lambdabot>  Defined.
19:13:21 <Myoma> > isqrt 9
19:13:22 <lambdabot>   3
19:13:42 <dolio> sclv_: Like, a type system where you can write: "[exists a. a]". Where you can make use of existential types without introducing a proper data type wrapping it.
19:13:45 <FunctorSalad> dolio: I think I'm misunderstanding what is meant by "existential" in haskell. I thought what I defined as Cat is conceptually the union of all CatClass types
19:14:21 <Olathe> > let floorsqrt x = until satisfy improve x where improve y = floor ((y*y+x)%(2*y)); satisfy y = y*y <= x && x <= (y+1)*(y+1) in map floorsqrt [0..]
19:14:22 <lambdabot>   [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,...
19:14:29 <Olathe> From the CReal hs file.
19:14:51 <Olathe> Which says it's from GMP.
19:15:15 <Olathe> @src until
19:15:15 <lambdabot> until p f x | p x       = x
19:15:15 <lambdabot>             | otherwise = until p f (f x)
19:15:16 <Myoma> > map length . group $ PREVIOUS_RESULT
19:15:17 <lambdabot>       Not in scope: data constructor `PREVIOUS_RESULT'
19:15:24 <int-e> Olathe: x <= (y+1)*(y+1) --> x < ... ?
19:15:25 <Myoma> > map length . group $ let floorsqrt x = until satisfy improve x where improve y = floor ((y*y+x)%(2*y)); satisfy y = y*y <= x && x <= (y+1)*(y+1) in map floorsqrt [0..]
19:15:30 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
19:15:37 <ddarius> sclv: Yes it is if c is not free in f.
19:15:44 <Myoma> @oies 1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33
19:15:45 <lambdabot>  The odd numbers: a(n) = 2n+1.
19:15:45 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
19:15:47 <sclv_> but isn't a "first class existential" e.g. Data Foo = Foo {a :: Int, b :: (forall b. Integral b => b) } ?
19:15:50 <parodyoflanguage> Wow, that's getting close to English :)
19:15:55 <Olathe> int-e: (y+1)(y+1)+1
19:15:55 <Myoma> Olathe: always the odd numbers?
19:16:04 <Olathe> Myoma: Oh, yes.
19:16:25 <Myoma> > [1,3..] >>= join
19:16:26 <lambdabot>       No instance for (Enum [[a]])
19:16:26 <lambdabot>        arising from the arithmetic sequenc...
19:16:32 <sclv_> the extractor b is therefore of type Foo -> (forall b. Integral b => b)
19:16:36 <Olathe> > [1,3..]
19:16:36 <Myoma> > [1,3..] >>= join replicate
19:16:38 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
19:16:38 <lambdabot>  Terminated
19:16:39 <ddarius> sclv: First class existentials would be just like first class universal quantification which GHC has with -XRankNTypes and is what dolio describes.
19:16:44 <Olathe> > scanl1 (+) [1,3..]
19:16:50 <int-e> > let satisfy x y = y*y <= x && x <= (y+1)*(y+1) in filter (satisfy 16) [1..10]
19:16:52 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:16:54 <lambdabot>   [3,4]
19:16:57 <Myoma> > let isqrt x = ([1,3..] >>= join replicate) !! x in isqrt 9
19:16:58 <lambdabot>   7
19:17:00 <Olathe> > scanl1 (+) [1,3..] == map (^2) [1..]
19:17:03 <Myoma> hmmm. :/
19:17:03 <Olathe> Bah.
19:17:07 <sclv_> right, which is what I thought... we do have them. just with extensions.
19:17:15 <lambdabot>   thread killed
19:17:25 <Olathe> > take 1000 (scanl1 (+) [1,3..]) == take 1000 (map (^2) [1..])
19:17:28 <lambdabot>   True
19:17:29 <dolio> No, we don't have first-class existentials. Only first-class universals.
19:17:34 <sclv_> (of course what I wrote above doesn't work because record syntax is weak and doesn't work on rank n types)
19:17:40 <FunctorSalad> sclv_: I think first class existentials are like coq's sigT
19:17:44 <Myoma> > let isqrt x = ([1,3..] >>= (\x -> replicate x (x `div` 2)) !! x in isqrt 9
19:17:46 <lambdabot>   mueval: Prelude.read: no parse
19:17:52 <Myoma> > let isqrt x = ([1,3..] >>= (\x -> replicate x (x `div` 2))) !! x in isqrt 9
19:17:54 <lambdabot>   3
19:18:00 <FunctorSalad> "sigT : forall A : Type, (A -> Type) -> Type"
19:18:14 <Olathe> > ([1,3..] >>= (\x -> replicate x (x `div` 2)))
19:18:16 <lambdabot>   [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,...
19:18:17 <Myoma> > let isqrt x = ([1,3..] >>= (\x -> replicate x (x `div` 2)) !! x in isqrt 100
19:18:19 <lambdabot>   mueval: Prelude.read: no parse
19:18:21 <Olathe> Ahh.
19:18:25 <Myoma> grrrr.....
19:18:36 <Myoma> @oies 0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,
19:18:36 <lambdabot>  Integer part of square root of n. Or, number of squares <= n. Or, n appears ...
19:18:37 <lambdabot>  [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,6...
19:18:45 <FunctorSalad> then sigT f is essentially the union of all the types in the image of f
19:18:49 <ddarius> sclv: GHC has what is called local existential quantification.  You can emulate free existentials with universals but it isn't better than local existential quantification which itself is a bit more annoying to use than free existentials.
19:19:09 <dolio> Yeah, you can encode existentials as their polymorphic eliminator.
19:19:22 <Olathe> > let floorsqrt x = until satisfy improve x where improve y = floor ((y*y+x)%(2*y)); satisfy y = y*y <= x && x <= (y+1)*(y+1) in sayFunc $ map floorsqrt [0..20::Integer]
19:19:24 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
19:19:31 <Olathe> > let floorsqrt x = until satisfy improve x where improve y = floor ((y*y+x)%(2*y)); satisfy y = y*y <= x && x <= (y+1)*(y+1) in sayFunc $ map floorsqrt [0..20]
19:19:33 <lambdabot>   map (\x -> (162441223061503542*x^20 + (-270476131303943705)*x^19 + 46277121...
19:19:57 <Olathe> @@ @run @run let floorsqrt x = until satisfy improve x where improve y = floor ((y*y+x)%(2*y)); satisfy y = y*y <= x && x <= (y+1)*(y+1) in sayFunc $ map floorsqrt [0..20]
19:19:59 <lambdabot>   mueval: Prelude.read: no parse
19:20:02 <Olathe> Bah.
19:20:16 <Myoma> > sayFunc [2,3,5,7,11,13,17]
19:20:17 <lambdabot>   map (\x -> (23*x^6 + (-399)*x^5 + 2585*x^4 + (-7725)*x^3 + 10712*x^2 + (-44...
19:20:33 <Myoma> @@ @run (@run sayFunc [2,3,5,7,11,13,17])
19:20:35 <lambdabot>   mueval: Prelude.read: no parse
19:20:42 <Olathe> > sayFunc $ map (^2) [0..10]
19:20:43 <lambdabot>   map (\x -> x^2) [0..10]
19:20:59 <Olathe> > sayFunc $ scanl1 (+) $ map (^2) [0..10]
19:21:00 <lambdabot>   map (\x -> (2*x^3 + 3*x^2 + x) `div` 6) [0..10]
19:21:55 <Olathe> @run map (\x -> (2*x^3 + 3*x^2 + x) `div` 6) [0..10]
19:21:56 <lambdabot>   [0,1,5,14,30,55,91,140,204,285,385]
19:22:04 <sclv_> I really need to start exploring coq or agda. haskell + extensions pretty much defines the limits of my imagination at this point.
19:22:36 <dolio> There's a pretty good paper on first-classe existentials and why you want them. Let me look it up...
19:22:42 <Myoma> @qute dependent.types
19:22:42 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
19:22:47 <Myoma> :DD
19:22:51 <Myoma> @qute dependent.types
19:22:51 <lambdabot> edwardk says: well, dependent types fuck with compilers ability to get anything done
19:23:03 <FunctorSalad> dolio: thanks... that type you suggested make a lot more sense logically... "every CatClass witness c implies Cat" ~ "Cat = exists c, CatClass c"
19:23:08 <Olathe> @quote d[a-z]pendent.types
19:23:09 <sclv_> I've read mcbride on eliminators but I'm not even sure I understand them either.
19:23:20 <Myoma> sclv_: That is a really hardcore paper
19:23:23 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
19:23:39 <FunctorSalad> sclv_: haskell is still a lot more useable though ;-)
19:23:46 <Olathe> @quote \s[a-z]{11,11}\s
19:23:46 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
19:23:47 <Myoma> sclv_: I think it's targeted at people who implement proof assistants..
19:23:54 <Olathe> @quote \s[a-z]{16,16}\s
19:23:55 <lambdabot> Cale says: I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell
19:24:11 <Olathe> @quote \s[a-z]{23,23}\s
19:24:11 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
19:24:12 <sclv_> FunctorSalad: sure, but I need more things to complain about haskell lacking :-)
19:24:38 <Myoma> haskell lacks verbal and social expression :P
19:24:43 <Myoma> @keal
19:24:43 <lambdabot> with KealDigit quantum crackproof encryption possible
19:24:54 <Myoma> @keal
19:24:54 <lambdabot> what the hell does Prelude > mean?
19:24:54 <Cale> Don't first class existentials pretty much wreak havoc on type inference?
19:25:07 <FunctorSalad> sclv_: hmm, for me the first-class types make things easier to understand, as long as you don't run into weird problems ;-)
19:25:28 <dolio> @google first-class-polymorphism-with-existential-types
19:25:31 <lambdabot> http://research.microsoft.com/users/daan/download/papers/existentials.pdf
19:25:32 <lambdabot> Title: First-class polymorphism with existential types
19:25:42 <ddarius> Cale: About as much as higher rank types.
19:26:27 <Cale> Ah, so you can still just have it never infer an existential type for anything, and everything works out okay?
19:26:47 <dolio> I think that's roughly what that paper does.
19:26:53 <ddarius> Cale: Probably.  You can ask augustss how they worked in HBC.
19:26:56 <dolio> Although it has a slightly fancy type system.
19:27:26 <dolio> With principle types even among higher-rank types.
19:28:47 <Myoma> @keal
19:28:47 <lambdabot> i think i know what code does but code looks to simple to actually do it
19:37:32 <Pseudonym> > map (\(a,b,t,x) -> (a+b)^2 / (4*t)) . iterate (\(a,b,t,x) -> let a' = (a+b)*0.5 in (a', sqrt(a*b), t-x*(a-a')^2, 2*x)) $ (1,sqrt(0.5),0.25,1)
19:37:34 <lambdabot>   [2.914213562373095,3.1405792505221686,3.141592646213543,3.141592653589794,3...
19:39:26 <int-e> Olathe: ah. x < (y+1)*(y+1) is automatically satisfied after the first step.
19:43:22 <cadabra> GHC has this option, -fvia-C, that supposedly generates C code and then compiles that. Is there any way to get a stand-alone .c-file out of it?
19:44:31 <Olathe> > (say.('[':).(++"]").concat.intersperse", ".map(flip showCReal pi)) [5,7..]
19:44:32 <lambdabot>   [3.14159, 3.1415927, 3.141592654, 3.14159265359, 3.1415926535898, 3.1415926...
19:44:49 <Myoma> haha
19:44:54 <ddarius> cadabra: You can have it dump the C file it produces when you use the -fvia-C flag, but it would not be particularly useful.
19:45:23 <ddarius> cadabra: GHC will also produce C in another form that can be used for boot-strapping, but it isn't very performant.
19:45:49 <cadabra> ddarius: that's not too much of a problem
19:46:16 <cadabra> In what way, other than performance, is it not useful?
19:47:22 <mmorrow> -keep-hc-file
19:48:07 <mmorrow> this is what main = print 42 produces:
19:48:09 <mmorrow> http://hpaste.org/10236
19:49:06 <cadabra> That's not too bad
19:49:17 <mmorrow> jhc otoh outputs a completely self-contained ansi-c file
19:49:21 <cadabra> Except for the include.
19:49:26 <cadabra> Now that sounds better
19:49:46 <mmorrow> and the non-generated parts thereof are quite readable (with lots of comments)
19:50:42 <mmorrow> cadabra: here's an example of c produced by jhc http://code.haskell.org/~morrow/jhc/tests/csv/hs.out_code.c.html
19:50:52 <lambdabot> Title: Haskell code
19:51:02 <mmorrow> (i ran that through HsColourm but the dir its in has the .c + the .hs it came form)
19:51:09 <mmorrow> *HsColour
19:52:25 <mmorrow> it's cool how the c file jhc outputs contains the entirety of its rts
19:59:04 <dons> it's pretty cool.
19:59:49 <mmorrow> heh
19:59:50 <mmorrow> #define BLACK_HOLE ((fptr_t)0xDEADBEEF)
20:00:34 <ddarius> cadabra: When using -fvia-C the C files produced are highly compiler specific and even then the produced assembly needs to be post-processed and the RTS linked.  The ones for boot-strapping are more portable, but they aren't really intended for general use.  I'm not sure what other problems might come up attempting to use them.
20:01:39 <mmorrow> yeah, the asm gcc produces is run through the "evil mangler" which does what it's called
20:05:42 <xpika> can mkcabal add 'build-type: Simple' to your cabal file
20:05:46 <xpika> ?
20:05:53 <sclv_> as I recall the unregistered ones that are unmangled don't have the stack fully eliminated?
20:06:43 <mmorrow> yeah, from what i understand the mangler kills the c stack.
20:06:52 <Myoma> how?
20:06:57 <sclv_> regexps!
20:07:02 <mmorrow> in perl!
20:07:48 <sclv_> mmorrow: btw, I'll try to get to adding the IEEE monad stuff soon, but I'm not sure exactly when... hopefully sometime next week.
20:07:57 <sclv_> The main issue is documenting/explaining it clearly.
20:08:15 <mmorrow> sclv_: cool. i still have to find that example also..
20:08:51 <sclv_> yeah -- that would be a big help. an example of an algorithm that needs to check overflow buffers would also be useful.
20:09:25 <sclv_> since that's the main use case for the monad, outside of isolating test cases with different rounding modes.
20:09:41 <mmorrow> ok, noted.
20:10:05 <mmorrow> you mean overflow /exceptions/?
20:10:09 <sclv_> Myoma: more that you ever wanted to know about GHC: http://hackage.haskell.org/trac/ghc/wiki/Commentary
20:10:11 <lambdabot> Title: Commentary - GHC - Trac
20:10:12 <mmorrow> or flags
20:10:21 <sclv_> overflow flags, I guess.
20:10:33 <mmorrow> ah ok, i was confused for a sec there.
20:10:36 <sclv_> (until it's far less than you need to know, which it also is on rare occasion)
20:10:55 <mmorrow> hmm
20:11:58 <mmorrow> Myoma: the mangler, in all its glory: http://darcs.haskell.org/ghc/driver/mangler/ghc-asm.lprl
20:12:00 <sclv_> or, I guess, to more explicitly control evaluation order for other stability issues -- but you can do that already with very careful `seq` placement.
20:13:01 <mmorrow> interesting. "how to force ghc not to mess with floating point code", or something along those lines i guess.
20:13:29 <thoughtpolice> the mangler is on death row which is good
20:13:37 <thoughtpolice> i'm sure it's a nightmare to maintain and update
20:13:41 * Myoma is curious what is gained from littering some code with '\end{itemize}' and similar
20:13:58 <mmorrow> evilness?
20:14:03 <dmwit_> Myoma: Are you talking about literate code?
20:16:46 <Myoma> I knew you could recognize tail calls with higher order unifications,.. but with REGEX???
20:17:09 <dolio> Perl regexes are turing complete, so... :)
20:17:24 <DarthMeh> @src foldl'
20:17:24 <lambdabot> foldl' f a []     = a
20:17:24 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:17:28 <mrd> i thought just np-hard
20:17:31 <ddarius> dolio: Let alone perl itself.
20:17:57 <dolio> I'm not 100% certain they're Turing complete, really.
20:18:14 <ddarius> dolio: They are.
20:18:30 <dolio> I'm convinced. :)
20:19:57 <Myoma> it doesn't count if you embed perl in them
20:20:02 <sclv_> I'm less sure...
20:20:05 * Myoma is making up rules
20:21:18 <dolio> (a^n)(b^m)(a^n)(b^m) isn't context free, is it?
20:21:35 <dolio> So they're at least more powerful than that.
20:22:11 <dolio> (That might be just context sensitive, though.)
20:22:13 <sclv_> right -- but there's a difference between a dfa/nfa and a turing machine, no?
20:22:52 <EvilTerran> there's an isomorphism, i think
20:22:59 <Myoma> that evl mangler is ridiculous
20:23:11 <Myoma> how could there be, .fa are finite machines
20:23:12 <Myoma> no ?
20:23:36 <EvilTerran> ah, sorry, i'm thinking of something else
20:23:36 <dolio> Turing machines are fa + tape, more or less.
20:23:42 <EvilTerran> yes, that's the one
20:23:45 <Myoma> You can't have backreferences in a DFA ??
20:24:03 <Myoma> are you assuming perl regex compile into DFA or NFA? I don't think that's the case
20:24:04 <sclv_> a series of regexes in a loop are turing complete, however.
20:24:16 <Myoma> yeah while(1) { ... } makes everything turing complete
20:24:18 <dolio> No. Backreferences gives you more power than regular expressions.
20:24:48 <EvilTerran> i was thinking of DFAs/regexes, and DFAs+stack/context-free grammars
20:24:51 <Myoma> you need backrefs for (a^n)(b^m)(a^n)(b^m) don't you?
20:24:56 <bos> @seen augustss
20:24:57 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
20:25:23 <dolio> Right. Like I said, I don't think you can even do it with a context free grammar/pushdown automata.
20:26:03 <dolio> It's been a while since I did this stuff, though.
20:26:13 <mmorrow> dolio: i actually just read about this. (a^n)(b^n)(c^n) is context sensitive.
20:26:45 <dolio> Yeah, but it's not immediately clear to me how to do that with perl regexes.
20:26:52 <dmwit> Myoma: Perl's regexes are not regular.
20:27:11 <dmwit> (Almost no usable regex library uses strictly regular expressions.)
20:27:35 <dancor> dolio: it might not be easy, the context-sensitive grammar for that is complicated
20:28:06 <mmorrow> yeah, i also just read about how difficult working with context-sensitive grammars are
20:28:21 <dolio> (a^n)(b^m)(a^n)(b^m) is trivial as (a*b*)\1, though.
20:29:07 <mmorrow> yeah, where i read it also pointed out that this special case also has a context free grammar which'll recognize it
20:29:12 <dancor> dolio: anbncn is def easy if you use (?{ code }) tho :)
20:29:41 <mmorrow> *... grammars s/are/is/
20:29:46 <mmorrow> how funny
20:30:03 <dancor> mmorrow: yeah, random generations in context-sensitive grammars are even basically search problems right
20:30:18 <dancor> let alone parsing
20:30:19 <Myoma> what extention of DFA or NFA can handle backreferences?
20:30:23 <dolio> Yeah. I was trying to avoid embedded code, since that's obviously Turing complete if perl is.
20:31:24 <mmorrow> dancor: apparently even the most minute change to the grammar will have to propogated throughout most of the rules, essentially changing the entire grammar.
20:31:52 <mmorrow> i'm trying to find my digi camera to take a picture of this page...
20:32:30 * dancor still isn't sure if {haskell programs that compile} is context-sensitive
20:33:03 <dolio> There are certain things you can do with backreferences that are doable in gradual extensions of DFA.
20:33:13 <ddarius> Bah.  I was looking for this a week or so ago and I thought I did find a set of keywords that worked but were non-obvious.  However, I don't remember what they were.  Searching now there is some references to this, but no proof.
20:33:15 <dolio> (a*)b*\1 is doable with context free grammars.
20:33:16 <Myoma> you can prime number generate with backrefs :D
20:34:07 <Myoma> (a^n)(b^n)(c^n) can be done with backreferences?
20:34:18 <EvilTerran> /(?{0})(?:a(?{$^N+1}))*b{(??{$^N})}c{(??{$^N})}/ ...
20:35:45 <EvilTerran> (a^n)(b^n)(a^n) can be, obviously
20:37:32 <dmwit> (a^n)(b^n)(c^n) should be context-free, no?
20:37:37 <dmwit> I can describe a PDA that matches it...
20:37:45 <Myoma> what's a PDA
20:37:48 <dancor> dmwit: http://en.wikipedia.org/wiki/Context-sensitive_grammar#Examples
20:37:49 <lambdabot> Title: Context-sensitive grammar - Wikipedia, the free encyclopedia
20:37:50 <dmwit> push-down automata
20:37:50 <Myoma> btw it's context sensitive
20:38:01 <Myoma> what is the automata?
20:38:35 <dmwit> Have states A, B, and C, which have the obvious correspondence to which kind of letter you should be reading.
20:39:01 <dmwit> in A, a transition on 'a' pushes BC onto the stack, and a transition on 'b' switches to state B
20:39:05 <dmwit> ...ah
20:39:07 <dmwit> I see. =)
20:39:17 <dmwit> Okay, I believe it's context-sensitive now.
20:39:43 <dmwit> But, e.g., (a^(m+n))(b^m)(c^n) should be context-free.
20:40:08 <dolio> Yeah, that one's pretty easy.
20:40:26 <dolio> I think.
20:41:30 <dolio> S -> aSc | R, R -> aRb | empty
20:41:43 <dmwit> right
20:41:44 <EvilTerran> yeah
20:41:45 <Myoma> this -> stuff is turing complete
20:41:57 <EvilTerran> nyet
20:41:57 <Myoma> markov algorithm right ?
20:41:59 <dmwit> Myoma: No, not context-free stuff.
20:42:02 <Myoma> ?go markov algorithm
20:42:04 <lambdabot> http://en.wikipedia.org/wiki/Markov_algorithm
20:42:04 <lambdabot> Title: Markov algorithm - Wikipedia, the free encyclopedia
20:42:26 <dmwit> These are unrelated to Markov algorithms.
20:42:41 <dmwit> (i.e. we're not doing string rewriting, only string acceptance/denial.)
20:42:57 <Myoma> how is that not the same thing?
20:43:01 <EvilTerran> markov algorithms don't distinguish between terminals and nonterminals
20:43:04 <dmwit> Maybe "unrelated" is too strong.  But they are not the same.
20:43:25 <dolio> For Turing completeness you need more complex strings on the left.
20:43:32 <EvilTerran> i think this is what makes them turing complete
20:43:34 <dmwit> Myoma: CFG's are used to "generate" strings, in a sense, not "consume" them, as Markov algorithms do.
20:43:34 <Myoma> oh, right ok
20:43:36 <dolio> Instead of single non-terminal tokens.
20:43:56 <EvilTerran> that's true
20:48:16 <newsham> a CFG is just a CFG.  the language denoated by that CFG can be generated or parsed.
20:48:51 <dmwit> Yeah, the distinction I made was dumb.  I retract it.
20:50:43 <dolio> It is somewhat more obvious how to generate strings from a CFG, given the notation.
20:52:39 <Myoma> > let ret = return . concat ; s = (r>>= \r' -> ret [r']) ++ (s>>= \s' -> ret ["a",s',"c"]) ; r = (ret []) ++ (r>>= \r' -> ["a",r',"b"]) in s
20:52:40 <lambdabot>   ["","a","","b","a","a","b","a","","b","a","b","b","a","a","b","a","a","b","...
20:54:35 <mmorrow> ok, these images are from thisw parsing book i have which had a good explanation of context-sensitive grammars:  http://moonpatio.com/context-sensitive/
20:54:35 <lambdabot> Title: Index of /context-sensitive
20:55:37 <mmorrow> "Chapter 15: Non-Chomsky Grammars and Their Parsers"
20:56:01 * dancor could not get EvilTerran's anbnnc with backrefs to actually work with perl
20:56:12 <Myoma> > let a^0 = "" ; a^n = a:(a^(n-1)) in map (\n -> ('a'^n)++('b'^n)++('c'^n)) [1..20]
20:56:13 <lambdabot>   ["abc","aabbcc","aaabbbccc","aaaabbbbcccc","aaaaabbbbbccccc","aaaaaabbbbbbc...
20:56:19 <Myoma> :/
20:56:20 <Myoma> oaeu
20:56:49 <mmorrow> "abbc"?
20:57:02 <newsham> > let (^) = flip replicate in 'c'^5
20:57:04 <lambdabot>   "ccccc"
20:57:52 <Myoma> what class is infix operators
20:57:53 <Myoma> ?
20:58:43 <newsham> > (^) = flip replicate in 'a'^5 ++ 'b'^5
20:58:44 <lambdabot>   mueval: Prelude.read: no parse
20:59:09 <newsham> > let (^) = flip replicate in 'a'^5 ++ 'b'^5
20:59:10 <lambdabot>   "aaaaabbbbb"
20:59:40 <Myoma> :t let (^) = flip replicate in (liftM3 (\x y z -> x++y++z) ('a'^)('b'^)('c'^))
20:59:42 <lambdabot> Int -> [Char]
20:59:51 <Myoma> > let (^) = flip replicate in map (liftM3 (\x y z -> x++y++z) ('a'^)('b'^)('c'^)) [0..]
20:59:53 <lambdabot>   ["","abc","aabbcc","aaabbbccc","aaaabbbbcccc","aaaaabbbbbccccc","aaaaaabbbb...
21:01:10 <newsham> > let (^) = flip replicate in flip map [0..] $ \n -> 'a'^n ++ 'b'^n ++ 'c'^n
21:01:12 <lambdabot>   ["","abc","aabbcc","aaabbbccc","aaaabbbbcccc","aaaaabbbbbccccc","aaaaaabbbb...
21:01:44 <xpika> src/Codec/ID3.hs:1:0: file name does not match module name `Main'
21:01:46 <mmorrow> this is a nice example of diff grammar types (i'm typing from the book...)
21:01:48 <xpika> how do i fix that?
21:01:50 <mmorrow> (1) the set of all lexically correct java programs => regular grammar
21:02:11 <humasect> > length [0..]
21:02:12 <mmorrow> (1) generate the set of all syntactically correct java programs => context grammar
21:02:19 <newsham> xpika: what are you trying to do?
21:02:19 <xpika> in runhaskell Setup build
21:02:20 <mmorrow> context _free_ grammar
21:02:21 <lambdabot>   mueval: Prelude.read: no parse
21:02:36 <Myoma> mmorrow: (1) lol
21:02:45 <mmorrow> (1) generate the set of all semantically correct java programs => context sensitive grammar
21:02:51 <mmorrow> err s/1/2/
21:02:54 <mmorrow> s/1/3/
21:02:56 <Myoma> heheh
21:02:59 <mmorrow> heh
21:03:02 <mmorrow> 2 more
21:03:26 <xpika> newsham: im building a library with cabal
21:03:33 <Myoma> GADTS are context free?
21:03:40 <Myoma> context sensitive
21:03:45 <newsham> xpika: hrmm.. and the build breaks with that error?
21:03:55 <mmorrow> (4) generate the set of all java programs that would terminate in finite time when run with a given input => unrestricted phase structure grammar
21:04:01 <newsham> myoma: i think type coherence is c-s
21:04:01 <xpika> newsham: yes
21:04:13 <Myoma> cool mmorow
21:04:20 <newsham> xpika: weird.. which pkg?
21:04:51 <mmorrow> (5) the set of all java programs that solve a given problem (e.g. play chess) cannot be generated by a grammar (although the description of the set is finite)
21:05:00 <mmorrow> </ol>
21:05:08 <xpika> newsham: my pkg
21:05:32 <Myoma> huh 5 is weird
21:05:54 <newsham> oh, your Codec/Id3.hs should probably be module Codec.Id3 where
21:06:01 <newsham> and i guess you have it as module main where ?
21:06:13 <mmorrow> yeah. it says each n is a subset of n+1, so maybe it was just for completeness
21:06:34 <xpika> Module Codec.ID3 (func) where
21:06:43 <Myoma> oh I see
21:06:44 <Myoma> ok
21:07:13 <Myoma> n+1 is a subset of n ?
21:07:21 <newsham> xpika: and you're building it as a library module, or as a main module?
21:07:34 <mmorrow> (1) < (2) < (3) < (4) < (5)  rather
21:07:44 <Myoma> what does < mean
21:07:51 <xpika> newsham: i just realized Module is lowercase
21:07:52 <mmorrow> where < is `subset`
21:07:52 <newsham> language heirarchy.
21:07:56 <Myoma> bu
21:07:59 <Myoma> but
21:08:04 <mmorrow> `subsetOf`
21:08:13 <Myoma> [1,2,3,4,5,6] < [2,4,6] < [4] ?
21:08:19 <mmorrow> opposite
21:08:32 <Myoma> so (1) > (2) .. ?
21:08:46 <Myoma> What is being measured
21:08:54 <mmorrow> oh, i meant wrt the  /grammars/
21:08:58 <Myoma> hm they are all infinte sets
21:09:02 <Myoma> what does that mean?
21:09:09 <Myoma> oh!
21:09:10 <Myoma> I understand
21:09:14 <mmorrow> yeah
21:09:32 <newsham> myoma: context sensitives can specify all context frees, etc.
21:09:39 <Myoma> I understand..
21:09:40 <mmorrow>  exactly
21:09:58 <Myoma> I was looking at the sets generated
21:10:03 <newsham> http://en.wikipedia.org/wiki/Chomsky_hierarchy
21:10:04 <lambdabot> Title: Chomsky hierarchy - Wikipedia, the free encyclopedia
21:10:06 <Myoma> not the language to describe the sets
21:11:13 <mmorrow> there's this really cool picture which metaphorically describes the difference between different levels of chomsky grammars.
21:11:23 <mmorrow> it's def worth taking a pic of while i'm at it.
21:11:34 <dancor> is there work on efficiently producing random generations given a CSG
21:13:24 <dolio> > let s 'S' = ["R", "aSc"] ; s c = [[c]] ; r 'R' = ["", "aRb"] ; r c = [[c]] ; rule s = fmap concat . sequence . fmap s ; go [] = [] ; go (x:xs) | all isLower x = x : go xs | otherwise = go ((rule r <=< rule s $ x) ++ xs) in go ["S"]
21:13:27 <lambdabot>   ["","ab","aabb","aaabbb","aaaabbbb","aaaaabbbbb","aaaaaabbbbbb","aaaaaaabbb...
21:14:22 <newsham> > fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
21:14:23 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
21:21:54 <eyu100> > sqrt (1 :+ 1)
21:21:55 <lambdabot>   1.09868411346781 :+ 0.45508986056222733
21:22:02 <eyu100> > sqrt (1 :+ 0)
21:22:03 <lambdabot>   1.0 :+ 0.0
21:22:17 <eyu100> > sqrt (2 :+ 2)
21:22:18 <lambdabot>   1.5537739740300374 :+ 0.6435942529055826
21:22:48 <Myoma> > sqrt (0 :+ 1)
21:22:50 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
21:23:24 <mmorrow> here's that picture, along with a description of it (that 1-5 java example thing is also on the description page): http://moonpatio.com/context-sensitive/rose/
21:23:25 <lambdabot> Title: Index of /context-sensitive/rose
21:23:58 <codacola> wow
21:24:03 <codacola> i still havent solved this question
21:24:24 <Myoma> which questin
21:24:42 <codacola> "define filter p as an instance of foldr"
21:25:40 <dibblego> codacola, what have you got so far?
21:25:59 <Myoma> codacola: You can start with, foldr (\x ys -> _) []
21:26:21 <Myoma> codacola: 'ys' is the filtered list so far, and 'x' is an element you may or may not want to filter out
21:26:24 <mmorrow> (if _ then _ else _) is an expression ....
21:26:52 <eyu100> > Integer
21:26:53 <lambdabot>   mueval: Prelude.read: no parse
21:27:01 <dmwit> > 3 :: Integer
21:27:02 <lambdabot>   3
21:27:08 <codacola> just myfilter f x = foldr (:) [] x
21:27:11 <eyu100> > return 3
21:27:12 <lambdabot>       No instance for (Show (m t))
21:27:12 <lambdabot>        arising from a use of `show' at <in...
21:27:25 <eyu100> > >>= 3
21:27:26 <lambdabot>   mueval: Prelude.read: no parse
21:27:28 <dmwit> codacola: Well, that's a start.  It's the identity. =)
21:27:29 <eyu100> > >> 3
21:27:30 <lambdabot>   mueval: Prelude.read: no parse
21:27:34 <eyu100> > >>= 3 3
21:27:35 <lambdabot>   mueval: Prelude.read: no parse
21:27:37 <dmwit> eyu100: You need to "send" it something.
21:27:42 <eyu100> > IO ()
21:27:43 <lambdabot>   mueval: Prelude.read: no parse
21:27:46 <dmwit> Also, the RHS has to be a function.
21:28:00 <eyu100> > do c <- getChar putChar f
21:28:02 <lambdabot>       The last statement in a 'do' construct must be an expression
21:28:05 <dmwit> > [3,4,5] >>= guard . even
21:28:06 <lambdabot>   [()]
21:28:09 <eyu100> > do c <- getChar (putChar "f")
21:28:10 <lambdabot>       The last statement in a 'do' construct must be an expression
21:28:15 <eyu100> ....
21:28:23 <Myoma> codacola: that's obviously wrong, try starting from the template I put there
21:28:24 <dmwit> > do c <- getChar; putChar 'f'
21:28:25 <lambdabot>   mueval: Prelude.read: no parse
21:28:25 <lambdabot>  mueval: *** Exception: "<IO ()>"
21:28:35 <dmwit> eyu100: (But you can't do IO in \bot.)
21:28:35 <mmorrow> > getChar >>= putChar
21:28:37 <lambdabot>   mueval: Prelude.read: no parse
21:28:37 <lambdabot>  mueval: *** Exception: "<IO ()>"
21:28:38 <Myoma> codacola: filter p = foldr (\x ys -> _) []
21:28:44 <dmwit> mmorrow: That has different behavior. =)
21:28:51 <mmorrow> oh, oops
21:28:59 <dmwit> > getChar >> putChar 'f'
21:29:01 <lambdabot>   mueval: Prelude.read: no parse
21:29:01 <lambdabot>  mueval: *** Exception: "<IO ()>"
21:29:11 <mmorrow> > getChar >>= \c -> putChar 'f' >> return ()
21:29:12 <dibblego> Prelude> let myfilter p = foldr (\x ys -> error "?") []
21:29:12 <lambdabot>   mueval: Prelude.read: no parse
21:29:12 <lambdabot>  mueval: *** Exception: "<IO ()>"
21:30:16 <eyu100> (***) = ...
21:30:46 <Cale> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=34#a34 -- Attack of the zombies!
21:30:55 <eyu100> > (\x -> 5) (getChar)
21:30:56 <lambdabot>   5
21:31:25 <eyu100> > NaN
21:31:26 <lambdabot>   mueval: Prelude.read: no parse
21:31:29 <mmorrow> Cale: haha
21:31:34 <eyu100> > (1/0/0)
21:31:35 <dancor> what is equiv to CSG but easier to work with
21:31:36 <lambdabot>   Infinity
21:31:40 <mmorrow> zombie scum!!
21:31:42 <eyu100> > (1/0/0 + 23)
21:31:44 <lambdabot>   Infinity
21:31:48 <eyu100> > (1/0/0 * 0)
21:31:50 <lambdabot>   NaN
21:32:36 <dmwit> > read "NaN" :: Double
21:32:38 <lambdabot>   NaN
21:32:43 <mmorrow> dancor: i'm not sure, but that'd be a good thing to know (if such a thing exists)
21:32:55 <dancor> CSG seem really awful to deal with
21:34:01 <dancor> maybe LBA's are nicer.  i want to see how anbncn compares to anbncndn there
21:34:20 <mmorrow> yeah. i was trying to change some things in the haskell-src-exts parser, and it sure felt like that's what was happening. i'm not sure though if it would be considered context-sensitive (??) (it's a happy parser)
21:34:46 <rwbarton> is there a way to determine pointer equality in ghc?
21:34:55 <mmorrow> heh, i think with
21:35:06 <Myoma> @hoogle reallyUnsafePointerEquality
21:35:07 <lambdabot> No results found
21:35:07 <mmorrow> reallyUnsafePonterEquality#
21:35:12 <mmorrow> haha
21:35:21 <mmorrow> in GHC.Prim
21:35:56 <mmorrow> you can also use a weak pointer which is /almost/ pointer equality. System.Mem.Weak.
21:36:02 <mmorrow> (and is safe)
21:36:27 <rwbarton> well, I'm planning on writing an Eq instance of the form  reallyUnsafePointerEquality# a b || a == b
21:36:46 <Myoma> rwbarton: why?
21:37:26 <dmwit> That kind of thing is usually done for efficiency when comparing truly humongous structures.
21:38:06 <rwbarton> Yeah, that's what I'm after
21:38:11 <Cale> mmorrow: Do you know when there will be a new haskell-src-exts release?
21:38:13 <rwbarton> how do I make # a valid identifier character?
21:38:29 <thetallguy> anyone building ghc 6.9 regularly?  If so, what version of QuickCheck are you using?
21:39:07 <mmorrow> Cale: i do not (you mean on hackage, right?)
21:39:12 <Cale> yes
21:39:27 <mmorrow> yeah, i'm not sure.
21:39:55 <Heffalump> thetallguy: there's a choice?
21:40:04 <mmorrow> but that's not to say it will or won't be soon, i just don't know the author(s)
21:40:21 <Myoma> rwbarton: I don't think you should use reallyUnsafePointerEquality for that
21:40:39 <thetallguy> Heffalump: I tried the tarball on hackage (1.1) and the repo in code.haskell.org (2.x)
21:40:40 <Myoma> rwbarton: Can't you tag each structure with a unique id?
21:40:47 <thetallguy> both failed to compile
21:40:58 <Myoma> rwbarton: Or just know what's equal and what isn't from the flow of the program?
21:41:23 <Heffalump> your question sort of implies you have to build QuickCheck to build GHC 6.9
21:41:52 <Heffalump> which may be true, but if so I'm just using the one darcs-all got for me
21:42:11 <thetallguy> Heffalump: didn't mean to.  Need it to build checkers, but neither compiles
21:42:14 <thetallguy> darcs-all?
21:42:37 <Heffalump> the script with GHC 6.9 that you use to update it from darcs (it's split into multiple repos)
21:42:49 <Heffalump> how do you get it? Source tarballs?
21:43:02 <rwbarton> Myoma: Yeah, I was going to do the tagging thing, but it occurred to me that using pointer equality would be easier if it worked.
21:43:11 <thetallguy> ghc 6.9 I pulled the tarballs, yes.  There's no darcs-all i there
21:43:13 <mmorrow> rwbarton: err, i meant with System.Mem.StableName
21:43:35 <Myoma> I don't think it is easier
21:43:35 <mmorrow> makeStableName a >>= \n -> return (hashStableName n)
21:43:42 <Heffalump> yeah, there wouldn't be, I'm talking about getting it from darcs
21:43:42 <mmorrow> then compare the hashes
21:43:54 <mmorrow> but there are some caveats with that
21:43:57 <Myoma> If you have a pointer to a structure a pointer to a pointer to the same structure, reallyUnsafePointerEquality fails, where the tag succeeds
21:44:02 <mmorrow> the haddock docs go through them
21:44:06 <thetallguy> so, I should go around the tarballs and just pull ghc from darcs?
21:44:19 <thetallguy> Seems kind of broken
21:44:20 <Heffalump> well, it's easy to update, except for darcs.haskell.org being slow
21:44:27 <Heffalump> but I doubt that would make a difference to you
21:44:44 <thetallguy> in any case, I should be able to find the repo directly.
21:44:45 <rwbarton> Myoma: I coded it.  It's absolutely easier.
21:45:04 <Heffalump> I'm just going to try QuickCheck
21:45:40 <mmorrow> rwbarton: hehe. using real..Eq..ty#? paste? i'm extremely curious.
21:46:03 <mmorrow> i've never played with that one before
21:47:11 <rwbarton> mmorrow: http://hpaste.org/10237
21:48:23 <mmorrow> awesome. ;)
21:48:27 <waynemokane> anyone ever struggle with gcc error 136 when trying to build ghc?
21:48:46 <rwbarton> mmorrow: unfortunately spoj is running ghc 6.6.1 which doesn't know about -XMagicHash
21:48:48 <eyu100> > > (minBound :: Int) `rem` (-1)
21:48:49 <lambdabot>   mueval: Prelude.read: no parse
21:48:53 <eyu100> > (minBound :: Int) `rem` (-1)
21:48:54 <rwbarton> mmorrow: ah I should just try -fglasgow-exts
21:48:55 <lambdabot>   mueval: Prelude.read: no parse
21:48:55 <lambdabot>  mueval: *** Exception: arithmetic overflow
21:49:18 <Heffalump> thetallguy: well, my GHC seems to have come with QuickCheck (I have the extralibs) and it seems to have built and installed ok
21:49:25 <mmorrow> rwbarton: hmm, i've never used that extension before (don't even know what it does really)
21:49:32 * mmorrow reads up on -XMagicHash
21:49:50 <rwbarton> it lets you use # in identifiers
21:50:25 <thetallguy> Heffalump: hmm...  Can you build checkers?
21:50:29 <sjanssen> rwbarton: reallyUnsafePtrEquality# probably means you're doing it wrong
21:50:43 <Heffalump> is checkers on hackage? cabal install doesn't find it.
21:50:53 <rwbarton> sjanssen: yeah, I know.  I was hoping to take the easy way out, but it didn't work.
21:50:54 <thetallguy> code.haskell.org/checkers
21:51:10 <sjanssen> rwbarton: also, {-# OPTIONS -fglasgow-exts #-} is 6.6.1 for {-# LANGUAGE MagicHash #-}
21:52:05 <sjanssen> rwbarton: and the Set (==)/Ord instances are really too slow for you?
21:52:36 <mmorrow> i think we want actual ptr equality (however that ihappens to be achieved)
21:52:38 <rwbarton> sjanssen: it seems so.  Imagine X = {Y, {Y}}, Y = {Z, {Z}}, Z = {A, {A}}, ...
21:52:50 <rwbarton> sjanssen: then == is exponential time
21:53:09 <Heffalump> thetallguy: it just built fine, with a GHC built on the 7th
21:53:10 <Myoma> so hash them
21:53:18 <Myoma> X = 55756/{Y,{Y}}
21:53:19 <mmorrow> System.Mem.StableName
21:53:24 <Myoma> Y = 45457/{Z, {Z}}
21:53:28 <Heffalump> I'll try building QuickCheck myself too
21:53:28 <sjanssen> oh, I see.  your type is Fix Set
21:53:29 <rwbarton> Myoma: Yes, I know
21:53:38 <waynemokane> ok another ghc question then... what is the difference between the ~40MB snapshots (that have like "unknown-linux" and just the "src" ones that are more like 7MB?
21:53:53 <Heffalump> 2.1 fails because Exception has changed from a type to a class
21:53:53 <mmorrow> unknown-linux is a binary distrib
21:54:00 <mmorrow> and src is not
21:54:01 <sjanssen> waynemokane: the former are binaries, the latter is the source you build yourself
21:54:24 <waynemokane> so... to do the "bootstrap" method I need the big one.. i.e. unknown-linux
21:54:43 <Cale> reallyUnsafePtrEquality# will return 0 even for things which I would sometimes expect to be 1. For instance, if you define  a = 1 : a, and (b:c) = a, then even once evaluated, a and c will compare as 0 under reallyUnsafePtrEquality#. I wonder if it's possible to have reallyUnsafePtrEquality# give 1 for two non-equal values (say, if a GC happens at just the wrong time)
21:54:48 <mmorrow> if you don't have ghc already, then yes, since ghc needs ghc to build
21:54:59 <Heffalump> but if I change the Control.Exception import to Control.OldException it's fine
21:55:09 <waynemokane> ah crapola
21:55:36 <waynemokane> I'm starting to see why all the smart people where I work gave up trying
21:55:56 <thetallguy> Heffalump: I must have strayed then.
21:56:29 <Heffalump> it doesn't help that cabal-install goes into a infinite loop resolving dependencies, though :-)
21:57:10 <Cale> No GHC binaries work -> (You're not a GHC developer -> You are not going to get GHC working.)
21:57:36 <Myoma> sad but true :(
21:57:45 <Myoma> GHC is not something anybody can just fix ...
21:58:06 <sjanssen> waynemokane: are you on a strange platform?
21:59:01 <waynemokane> sjanssen: not sure to be honest... our infra is rather customized but I believe the OS is just Redhat AS 2.1
21:59:08 <waynemokane> don't know how to tell 100%
21:59:43 <sjanssen> redhat doesn't have a GHC package available?
21:59:54 <waynemokane> I can't use redhat packages here
22:00:02 <mmorrow> waynemokane: ghc 6.8 can be built with a ghc as old as ghc6.4, so keep trying successively older versions until one works, then build ghc6.8 with it.
22:00:11 <waynemokane> basically we have a "wrapper" around autoconf that sometimes works.. in this case it's not
22:00:22 <adu> ok i need help
22:00:35 <waynemokane> hmm so if I'm getting Error 136 during my install target, I guess that is from gcc right?
22:00:47 <mmorrow> i don't know what that is
22:01:04 <mmorrow> or where it's from
22:01:11 <waynemokane> ok, I'll have to do more homework
22:01:18 <mmorrow> good luck ;)
22:01:48 <waynemokane> ok another thing that doesn't quite make sense... if I am downloading a binary of ghc, to build ghc, then what exactly am I doing?
22:01:57 <waynemokane> like when I get the "unknown-linux" and do gmake install...
22:02:06 <Heffalump> waynemokane: you're bootstrapping
22:02:09 <thetallguy> Heffalump: somehow my quickcheck built against the wrong bse library package QuickCheck-1.1.0.0 requires base-3.0.3.0
22:02:16 <Cale> waynemokane: The make install doesn't compile ghc with the binary packages.
22:02:17 <adu> i'm going to talk about Haskell tomorrow, and I have plenty of info about Haskell, but I'm supposed to talk about projects which i know nothing about
22:02:19 <adu> oops
22:02:24 <Cale> waynemokane: It just copies things into place.
22:02:37 <Heffalump> thetallguy: ah, perhaps 1.1.0.0 doesn't restrict the version well enough
22:02:45 <thetallguy> Heffalump: I'll have to think about how that could have happenend.
22:03:11 <Heffalump> I didn't try the 1.1.0.0 tarball from hackage, that might be broken
22:03:29 <thetallguy> But this is the one with extrasrc
22:03:42 <Heffalump> oh, right.
22:03:47 <thetallguy> I removed the other with ghc unregister and re-reran make install
22:04:07 <thetallguy> I had ghc 6.8 installed in the chroot I was building in
22:04:11 <waynemokane> Cale: wait, so... if it just copies things then why use gmake at all?  why not just have a shell script?  I thought that basically you needed the binary "ghc" to build ghc, so it called ghc as part of the build process
22:04:11 <Heffalump> checkers complained about being indirectly dependent on two versions of base (3 via QuickCheck and 4 via other stuff) but seemed to build ok anyway
22:04:15 <thetallguy> maybe it saw the other library
22:04:28 <Heffalump> I haven't actually run anything I built, either
22:04:51 <adu> does anyone here know much about darcs or xmonad?
22:04:52 <thetallguy> Heffalump: hah.  It worked this time
22:05:04 <Cale> waynemokane: If you get the binary version, install it first, then get the source version, you can compile the source yourself. Nobody in their right mind who is not hacking on GHC would do that though.
22:05:08 <thetallguy> bizarre
22:05:18 <Heffalump> adu: I know a fair amount about darcs
22:06:03 <adu> Heffalump: can you think of a good approach to talking about darcs at a linux-user-group?
22:06:04 <thetallguy> Now I need to find an update for TypeCompose
22:06:09 <mmorrow> Cale: i personally always build any compiler/webserver/database/things-of-this-nature myself, but that's just me
22:06:29 <mmorrow> *any _ i'm using a fair amount
22:06:30 <Heffalump> adu: show off the features? Easy cherry-picking, interactive record, that kind of thing?
22:06:34 <Heffalump> Introduce DVCS first
22:06:43 <adu> Heffalump: or more specifically, what should I say?
22:06:58 <adu> Heffalump: ah ok
22:07:10 <Cale> mmorrow: However, if you can compile GHC, you already know that you have a working GHC, so there would be no point in compiling it other than to check that it really does work.
22:07:36 <waynemokane> Cale: so what did mmorrow mean by "ghc 6.8 can be built with a ghc as old as ghc 6.4"?  is that the same thing you're talking about?
22:07:40 <Heffalump> well, unless you are bootstrapping from hc files.
22:07:57 <adu> Heffalump: what does cherry picking have to do with darcs?
22:08:06 <Heffalump> adu: just the fact that it does it very well
22:08:07 <Cale> waynemokane: Oh, if you can get an older binary working on your platform, then you can compile newer ones.
22:08:07 <mmorrow> Cale: true, but i like also to set my own build options/get to know what i'm working with better.
22:08:18 <waynemokane> Cale: and that isn't too painful?
22:08:29 <adu> Heffalump: i don't understand
22:08:34 <Cale> waynemokane: It takes a really long time, but otherwise isn't bad.
22:08:44 <waynemokane> Cale: I mean, let's say I magically get a gch 6.6 bootstrapped here... then I can use that to build 6.8 from source?
22:08:45 <Heffalump> adu: do you know what cherry picking is?
22:08:48 <adu> Heffalump: what is cherry-picking?
22:08:51 <Heffalump> ah :-)
22:09:06 <Heffalump> it's pulling or pushing a patch out of the order it was recorded
22:09:23 <mmorrow> waynemokane: bash darcs-all --extra get && bash boot && ./configure --prefix=<blah> && make -j4 && sudo make install
22:09:32 <Heffalump> darcs makes it so easy (just say 'n' to earlier patches and 'y' to later patches) that you often don't even realise what you're doing.
22:09:41 <Myoma> :t foldr
22:09:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:09:44 <mmorrow> waynemokane: that's the whole process
22:09:55 <dmwit> :t buildr
22:09:56 <lambdabot> Not in scope: `buildr'
22:10:06 <adu> Heffalump: I've never seen that feature
22:10:32 <dmwit> Have you ever darcs push'd or pull'd?
22:10:44 <mmorrow> <waynemokane> Cale: I mean, let's say I magically get a gch 6.6 bootstrapped here... then I can use that to build 6.8 from source?
22:10:45 <adu> dmwit: nope, just get
22:10:47 <mmorrow> waynemokane: exactly
22:10:58 <dmwit> ah =)
22:11:02 <Heffalump> hmm, perhaps you should use darcs a bit more before talking about it?
22:11:19 <adu> Heffalump: perhaps
22:12:03 <mmorrow> it'll take maybe 30min tops to build 6.8 with 6.8, and 3+ hours to build 6.8 with 6.4. don't remember how long to build 6.8 with 6.6.
22:12:36 <adu> Heffalump: well I said I would talk about Haskell... I kinda got persuaded to talk about darcs
22:12:53 * dmwit shrugs
22:12:54 <Cale> Except that bootstrapping 6.6 yourself is probably not something that you can do. If you can't get a binary to work, then getting GHC to build is not for the faint of heart.
22:13:04 <dmwit> Tell them you don't know about it and call it a wrap.  Then move on to Haskell.
22:13:17 <adu> dmwit: good plan
22:13:44 <mmorrow> waynemokane: if you're on linux, i'd be /stunned/ if you can't find some binary ghc that works.
22:14:10 <dmwit> He's running Linux on is Motorola 68k.
22:14:18 <mmorrow> oh
22:14:36 <dmwit> (I'm just kidding.)
22:14:39 <mmorrow> hahah
22:14:50 <dmwit> GHC would take 3 days to build. =P
22:18:34 <waynemokane> lol ok... I'm gonna try the 6.6 family and if I still get the "Error 136" during install I'll bang my head against my ceiling and go to bed
22:25:01 <albino> Can someone point me to a resource that explains why mutation of variables is generally a bad idea?
22:25:34 <Nafai> I've been unsuccessful in explaing it to albino.  My functional-programming-fu is weak :(
22:26:14 <mmorrow> look at the data-dependency graph of a program that mutates vars in a ad-hoc way.
22:26:14 <roconnor> mutation of variables is like a box of chocolates
22:26:15 <albino> Nafai: I'm a non-believer, so I'm looking for proof :)
22:26:20 <dibblego> it takes me weeks to convince someone of that
22:26:21 <roconnor> you never know what you're gonna get
22:26:30 <sclv> albino: what does x = x + 1 mean ?
22:26:36 <albino> dibblego: how does it generally go?
22:26:38 <sclv> as a math equation.
22:26:42 <mmorrow> then contemplate the near-impossibility of parellelizing this such a program
22:26:47 <mmorrow> without a complete rewrite
22:26:55 <dibblego> albino, 100% success rate, it's just the divorcing of certain ideas that takes the time
22:27:20 <albino> dibblego: is there a systematic approach to this divorcing?  Maybe documented somewhere?
22:27:41 <dibblego> albino, I've been developing one through experimentation, but otherwise, I doubt such a thing exists
22:27:56 <albino> sclv: I'm not great at math honestly, but to me (and since I've been programming for a while), that reads as add 1 to the current value of x and store in x
22:28:27 <Myoma> albino: what language ?
22:28:34 <albino> mmorrow: concurrency is nice, but I'm looking for more of a generalized reason, I assume that this reasoning existed long before the concurrency argument
22:28:45 <Myoma> albino: In $mymadeuplanguage that means something totally different
22:29:03 <sclv> right, but its an old gag because as a math equation its meaningless... i.e. I can write x = y + 5 and manipulate it and get (x - y) = 5 and soforth... but you have something that looks like a statement of equality, and instead its actually doing something.
22:29:10 <albino> Myoma: For the x = x + 1 example?  None was specified.
22:29:44 <Myoma> albino: Yes, I but you must have referred to some language
22:29:58 <sclv> x = x + 1 as a math equation would be the same as (x-x) = 1 which -> 0 = 1 !
22:29:58 <mmorrow> albino: i meant parallelism. as in such functions cannot be separated from their larger containing context without taking /all/ the stuff their mutating in who-knows-what other parts of the prog with them
22:30:13 <mmorrow> s/their/they're/
22:30:27 <albino> Myoma: well in my head the answer was based on my experience using C++, Java, and python.  Imperative languages.
22:30:44 <Myoma> @w80 Imperative
22:30:45 <lambdabot> *** "imperative" wn "WordNet (r) 2.0"
22:30:45 <lambdabot> imperative
22:30:45 <lambdabot>      adj 1: requiring attention or action; "as nuclear weapons
22:30:45 <lambdabot>             proliferate, preventing war becomes imperative";
22:30:45 <lambdabot>             "requests that grew more and more imperative" [ant: {beseeching}]
22:30:47 <lambdabot> [5 @more lines]
22:30:54 <sclv> in java or whatever you can't write 1 = 5, right... because you "know" 1 is immutable.
22:31:15 <sclv> and you can't write "this is my string" = 25 for the same reason -- it doesn't make sense.
22:31:46 <sclv> but all variables *can* be assigned -- which means a variable isn't a value anymore, its a named box.
22:31:59 <albino> mmorrow: but what if the the mutation is local to the function?
22:32:18 <sclv>  but we don't walk around in the world keeping everything in named boxes and renaming them all over the place and swapping them between named boxes and refering to them by whatever happens to hold them.
22:32:29 <sclv> If I have a book in my backpack I still call it a book, not my backpack.
22:32:54 <mmorrow> albino: then that's not as much of an issue (possibly none at all), and that's done in haskell a fair amount actually
22:32:59 <mmorrow> (but not in pure code)
22:33:02 <sclv> So we want to be able to actually think of values as values, and not as boxes.
22:33:29 <albino> sclv: I'm trying to follow you
22:34:17 <mmorrow> > let x = 0 : x in x
22:34:18 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:34:22 <sclv> another way to look at it. in java, you might declare x = new HashMap(). and then you would say x.add(1,2) and then x.add(2,5) and soforth.
22:35:00 <albino> sclv: yes, but I can give people nicknames, and those names refer to the same objects (people)
22:35:42 <sclv> except you get nice chaining, especially in say python, but even in java, in certain dsl-like idioms where you can write x = (new HashMap()).add(1,2).add(2,5) and each call gives a new thing.
22:35:45 <waynemokane> sweet!  gmake made it all the way thru install target for 6.6.1... now when I launch the ghci it installed I get  "Failed to load interface for 'System.IO'... ghc-6.6.1: panic! he 'impossible' happened"
22:36:18 <sclv> And that intuitively makes sense -- you have the hashmap, then you have it with a key added, and then another function gives it to you with a second key/value pair added...
22:36:34 <sclv> Functional programming is about extending that ability to chain and reason.
22:36:34 <mmorrow> waynemokane: geez. does ghc -V work without issue? if so you probably want to just build a 6.8 from src immediately.
22:37:20 <sclv> You always want to know what something is, right? You never want it changed out from under you unexpectedly -- thats the whole point of managing scope, avoiding global variables, etc.
22:38:17 <mmorrow> you're doing /equivalent/ things as i++ in haskell all the time, but it's just done differently
22:38:22 <sclv> just like you don't want to talk about your friend nicknamed buck today and be talking about one person, and then tomorrow you're talking about buck and suddenly that nickname refers to camille pagilia.
22:38:41 <mmorrow> > let go n = if n < 100 then n else go (n+1) in go 0
22:38:43 <lambdabot>   0
22:38:46 <mmorrow> oops
22:38:51 <mmorrow> > let go n = if n > 100 then n else go (n+1) in go 0
22:38:52 <lambdabot>   101
22:39:33 <mmorrow> for(int i=0;i<101;i++);
22:40:01 <sclv> so if you know a name always means the same thing, then you can use that name without fear of ever -- due to your own error, or due to someone else's, being wrong in what you think the name means.
22:40:38 <Myoma> @let for i s p = if s i then i else for (p i) s p
22:40:38 <lambdabot>  Defined.
22:40:45 <Myoma> > for 0 (< 101) (+1)
22:40:45 <sclv> that's my best shot at motivating immutability -- its closer to how we think.
22:40:46 <lambdabot>   0
22:40:58 <Myoma> oopps
22:41:01 <mmorrow> haha
22:41:11 <mmorrow> that's exactly what i did
22:41:14 <sclv> and then of course immutable structures give you other advantages -- producing a version with a change doesn't remove the old version.
22:41:45 <Myoma> if immutability is how we (people) think why does 99% of programmers use C?
22:41:50 <sclv> so, e.g., iterators are dodgy in Java because if you're not careful someone else might take a piece off one before you do.
22:41:53 <Myoma> oc BASIC
22:42:13 <dibblego> because they were conditioned that way
22:42:31 <albino> sclv: but if my iterator's life is over 10 lines and those lines are inside of a function I define, can't I prove that will never happen?
22:42:50 <Myoma> albino: yes, it's very hard to prove things about programs though, have you tried?
22:43:04 <sclv> albino: yes. but that's only if you always keep things that simple.
22:43:10 <mmorrow> well you still have to spend the time proving it, whereas it guaranteed ahead of time without mutation
22:43:16 <albino> Myoma: no,  not at all
22:43:20 <sclv> And lots of smart people who are good programmers don't always keep things that simple, and then they get bugs.
22:44:19 <sclv> think about manual memory management vs. garbage collection.
22:44:53 <sclv> if you always follow e.g. the RAII idiom and use smart pointers and delimit responsibility for destruction carefully then you can prove that you won't leak or segfault.
22:45:12 <sclv> but lots of smart programmers who are well trained in doing this produce leaks and segfaults anyway.
22:45:26 <waynemokane> mmorrow: nevermind about that... just crappy issues with our global filesystem that can't be resolved until tomorrow anyway
22:45:27 <albino> mmorrow: that's a good point, but if the recursive version is much harder to formulate vs the other version, is there still a win there?
22:45:41 <waynemokane> mmorrow: but I still should be able to use ghci -i option... but for some reason it's being ignored
22:45:48 <mmorrow> waynemokane: cool. good luck :)
22:45:50 <sclv> albino: the recursive version is only harder until it becomes incredibly easier.
22:46:00 <albino> sclv: haha lol
22:46:09 <Myoma> > let for i s p = if not (s i) then i else for (p i) s p in  for 0 (< 101) (+1)
22:46:10 <lambdabot>   101
22:46:16 <mmorrow> albino: yeah, i find the recursive version tremendously easier at this point
22:46:22 <albino> sclv: dude, that's one heck of a one liner, I must write that down for future reference :)
22:46:23 <Myoma> ^ you can use either version
22:46:26 <mmorrow> but that wasn't the case until i learned haskell
22:46:40 <sclv> add one to every element in a list: "map (+1)"
22:46:53 <mmorrow> > map (+1) [0..9]
22:46:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:46:59 <Myoma> for(int i = 0; i < length; i++) {
22:47:10 <Myoma> for(int i = length-1; i >= 0; i--) {
22:47:17 <Myoma> things you type 100x a day
22:47:18 <mmorrow> > zipWith ($) (repeat (+1)) [0..]
22:47:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:47:30 <mmorrow> > map (+1) [0..]
22:47:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:48:14 <waynemokane> crap there doesn't seem to be anyway to override system lib path from the commandline... oh well
22:48:47 <mmorrow> waynemokane: ahhh. you might have to edit `which ghc` (which is a shell script wrapper) by hand
22:48:59 <mmorrow> cat `which ghc`
22:49:20 <sclv> execute a list of effectful functions that each take an integer as an argument, with the evens between 2 and 10: sequence . zipWith (flip ($)) [2,4..10]
22:49:26 <waynemokane> mmorrow: oh  good call...
22:49:42 <mmorrow> waynemokane: i've pulled my hair out over that one before....
22:49:47 <albino> Thanks everyone for the explanatin, although I still don't quite grasp why, it did help
22:49:56 <waynemokane> it seems like package.conf is the file that points to the system lib root
22:49:56 <albino> s/explanatin/explanation
22:50:24 <sclv> albino: no prob :-) if you just keep playing with it for a bit, it will click for you.
22:50:30 <mmorrow> albino: after programming in haskell for a while, it starts to feel odd programming in a lang where vars are mutable
22:50:44 * Myoma is still happy with mutation
22:50:56 <albino> sclv: I'd like to think that, but I'm convinced otherwise, recursion has been a common enemy of mine for a long time
22:51:19 <sclv> explicit recursion in good haskell is pretty rare -- higher order functions are usually used to hide all that.
22:51:31 <Myoma> albino: Have you covered proof by induction?
22:51:59 <albino> but that doesn't change the fact that functional says that recursion is prefered to variable mutation, even if it is hidden from the programmer for the most part
22:51:59 <mmorrow> albino: also, haskell optimizes functions that are tail recursive correctly, so you can do things with recursion in haskell that aren't possible in languages that don't (which is pretty much every non-functional lang)
22:52:03 <sclv> The other thing, of course, is that I'm doing increasing amounts of multithreaded programming, and mutation is an utter killer there.
22:52:12 <mmorrow> @src map
22:52:12 <lambdabot> map _ []     = []
22:52:12 <lambdabot> map f (x:xs) = f x : map f xs
22:52:37 <Nafai> sclv: I'm not sure if I understand your example that starts with "sequence ."
22:52:43 <mmorrow> (map (+1) [0..]) !! 10000000
22:52:46 <mmorrow> > (map (+1) [0..]) !! 10000000
22:52:50 <Myoma> :t sequence . ?m
22:52:57 <sclv> Nafai: its a bit obfuscated :-)
22:53:06 <lambdabot> thread killed
22:53:10 <mmorrow> > (map (+1) [0..]) !! 100000
22:53:13 <lambdabot>   100001
22:53:47 <Myoma> :t sequence . ?m
22:53:49 <lambdabot> forall (m :: * -> *) a a1. (?m::a1 -> [m a], Monad m) => a1 -> m [a]
22:53:49 <Cale> albino: Recursion is not preferred. You should use higher order functions instead. (They might use recursion, but how they do their job is an irrelevant detail.)
22:54:20 <sclv> the zipWith joins two lists, right, and if one is [Int->IO ()] and the other is [Int] and the with function is ($) which is just application (flipped in the example to stay pointfree) then you end up with a list [IO ()]
22:54:34 <sclv> sequence takes something of [m a] -> m [a].
22:54:51 <albino> Cale: but for pretends, we could say that I was implementing those higher order functions and wanted to do it without mutation, then we could still have this dicussion :)
22:54:53 <sclv> i.e. "executes" a set of monadic actions and collects the result.
22:55:06 <Myoma> albino: Have you covered proof by induction?
22:55:32 <sjanssen> rwbarton: bah, they don't even have mtl on spoj!!!
22:55:36 <albino> Myoma: No, I don't even know what that means
22:55:58 <Myoma> albino: This is why you have trouble with recursion
22:56:16 <rwbarton> sjanssen: no :(
22:56:32 <waynemokane> oh my gosh... with such uber-hackage... it works
22:56:54 <sjanssen> rwbarton: do they have a bug tracker?
22:57:00 <mmorrow> waynemokane: excccellent
22:57:06 * sjanssen is now adding StateT to the end of his submission
22:57:08 <waynemokane> mmorrow thanks a ton for your help
22:57:14 <cjs> albino: Run, don't walk, to your favourite bookshop and buy this book: http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992/
22:57:18 <lambdabot> http://tinyurl.com/6raxrr
22:57:33 <mmorrow> waynemokane: no prob :)
22:57:34 <waynemokane> mmorrow: I'll be back later when I attempt my next trick... building 6.8 using 6.6   :O
22:57:44 <waynemokane> but that is a project for another day
22:58:03 <cjs> Actually, in NetBSD pkgsrc, we appear to build 6.8 using 6.4.
22:58:03 <mmorrow> "one day at a time.."
22:58:25 <albino> cjs: thanks
22:58:29 <waynemokane> mmorrow: thanks again!  goodnite everyone
22:58:46 <cjs> Oh, and if you need an environment to play in, DrScheme is good.
22:59:37 <Cale> albino: Have you looked at the definitions of basic things like length, map, sum, etc?
23:00:03 <albino> Cale: No my questions weren't specific to Haskell, I just wanted to understand the functional approach better
23:00:18 <Cale> okay, I think that looking at simple examples like that can help a good deal
23:00:21 <albino> Sorry if I'm abusing the community
23:00:29 <Cale> Do you know Haskell's basic syntax at all?
23:00:32 <mmorrow> waynemokane: night
23:00:34 <albino> Nafai said this might be a good place for the discussion
23:00:35 <cjs> Not at all, albino.
23:00:46 <Nafai> I told you they were friendly :)
23:00:54 <Nafai> Even if they do talk over my head a lot of the time
23:01:11 <albino> Cale: Nope, just from looking over Nafai's shoulder and mumbling "wtf does that do"
23:01:45 <Cale> In Haskell, every list is either [], the empty list, or it is a single element x, followed by another list xs, which is written (x:xs)  (note that x and xs here are both arbitrary variable names)
23:01:50 <mmorrow> albino: this is the complete src to a prog that number the lines of a file:
23:02:07 <Cale> We can define functions like the one which finds the length of a list by cases, depending on which pattern matches...
23:02:11 <Cale> length [] = 0
23:02:26 <Cale> this says that the length of an empty list is 0
23:02:33 <Cale> length (x:xs) = 1 + length xs
23:02:37 <mmorrow> main = putStr . unlines . zipWith (++) (map ((++":") . show) [1..]) . lines =<< getContents
23:02:57 <Cale> This says that the length of a nonempty list whose first element is x and whose tail is called xs is 1 plus the length of xs.
23:02:58 <mmorrow> slightly cleaner (but not inserting a ":")
23:03:11 <mmorrow> main = putStr . unlines . zipWith (++) (map show [1..]) . lines =<< getContents
23:03:34 <albino> mmorrow: :) fo = open("filename.txt", 'r'); len(fo.readlines()); fo.close()
23:03:41 <Cale> If you want to see how that definition works, we can apply it to a specific list, such as [1,2,3] = (1:(2:(3:[])))
23:03:59 <Cale> length (1:(2:(3:[])))
23:04:12 <mmorrow> albino: that prepends the line number to each line?
23:04:15 <Cale> = 1 + length (2:(3:[])) -- by the second equation for length
23:04:31 <Cale> = 1 + (1 + length (3:[])) -- by the second equation for length again
23:04:33 <albino> mmorrow: oops, nope
23:04:40 <sjanssen> rwbarton: good news is that my submission is accepted
23:04:52 <Cale> = 1 + (1 + (1 + length [])) -- by the second equation for length again
23:05:04 <mmorrow> main = print . length . lines =<< getContents
23:05:04 <Cale> = 1 + (1 + (1 + 0)) -- by the first equation for length
23:05:20 <Cale> which, after doing the arithmetic, gives 3
23:05:25 <sjanssen> but it is rather slow
23:05:28 <Cale> albino: Does that make sense?
23:05:39 <rwbarton> sjanssen: nice.  I got distracted
23:05:48 <Cale> (sorry if the notation is a bit confusing)
23:07:03 <Cale> albino: (feel free to ask questions about it if it doesn't make sense)
23:07:51 <cjs> sjanssen: submission?
23:08:01 <sjanssen> cjs: to https://www.spoj.pl/problems/SETSTACK/
23:08:07 <albino> Cale: yes, that sort of makes sense, I mean I get the concept, but the syntax is confusing to me
23:08:11 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem SETSTACK
23:08:47 <mmorrow> albino: oh, pattern matching is the /shit/.
23:09:36 <mmorrow> > let a@(x,(_,y)) = (42,([9.12],"asdf")) in (a,x,y)
23:09:38 <lambdabot>   ((42,([9.12],"asdf")),42,"asdf")
23:09:38 <Cale> If it helps, we could use (h:t) instead of (x:xs) -- the convention is to use variable names ending in s for lists (as if they were plural)
23:10:13 <mmorrow> > let x:_ = [0..] in x
23:10:14 <lambdabot>   0
23:10:38 <mmorrow> > let _:_:a:b:_:c:_ = [0..] in (a,[b,c])
23:10:39 <lambdabot>   (2,[3,5])
23:10:57 <RayNbow> every time I see an H and a T... it reminds me of Prolog... ( [H|T] )
23:11:29 <mmorrow> > let _:x = [0..] in x
23:11:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:11:35 <albino> Cale: we're just splittng the list into first and rest, right?
23:11:43 <mmorrow> yes
23:12:15 <RayNbow> albino: the nice thing in Haskell is... we use constructors to construct and deconstruct values :)
23:12:16 <Cale> albino: right
23:12:22 <RayNbow> > 3 : []
23:12:24 <lambdabot>   [3]
23:12:31 <mmorrow> > (:) 3 []
23:12:32 <lambdabot>   [3]
23:12:34 <mmorrow> > [3]
23:12:35 <lambdabot>   [3]
23:12:59 <RayNbow> > (:[]) 3   -- monkey face (sections)
23:13:01 <lambdabot>   [3]
23:13:05 <Cale> albino: So the definition  length (x:xs) = ...  only applies when you pass a nonempty list to length, and it binds the first element to x, and the remainder of the list to xs
23:13:25 <mmorrow> > let x:xs = [] in (x,xs)
23:13:26 <lambdabot>   mueval: Prelude.read: no parse
23:13:26 <lambdabot>  mueval: (*** Exception: /tmp/99030792911745...
23:13:30 <mmorrow> bah
23:13:51 <mmorrow> ghci> let x:xs = [] in (x,xs)
23:13:51 <mmorrow> (*** Exception: <interactive>:1:4-12: Irrefutable pattern failed for pattern x : xs
23:14:18 <Cale> Heh, bug gwern to bug the people who are in charge of the things which he's waiting to be released before he does another mueval release :)
23:14:47 <RayNbow> > "mueval" >> "evil"
23:14:48 <lambdabot>   "evilevilevilevilevilevil"
23:15:09 <Cale> albino: So what  length (x:xs) = 1 + length xs  is saying is that the length of a nonempty list, is 1 plus the length of the list obtained by removing the first element.
23:15:21 <mmorrow> > let f [] = "nine!" ; f (x:xs) = x ++ "asdf" ++ x in f ["qwerty"]
23:15:22 <lambdabot>   "qwertyasdfqwerty"
23:15:28 <mmorrow> > let f [] = "nine!" ; f (x:xs) = x ++ "asdf" ++ x in f []
23:15:29 <lambdabot>   "nine!"
23:15:37 <albino> Cale: right
23:16:08 <Myoma> > let f [] = "nine!" ; f (x:xs) = x ++ f xs ++ x in f ["foo","bar","baz"]
23:16:09 <lambdabot>   "foobarbaznine!bazbarfoo"
23:16:24 <mmorrow> heh
23:16:49 <mmorrow> that's a better example showing how recursion eventually is made to stop
23:17:15 <RayNbow> > filterM (const [True,False]) "Real World Haskell"
23:17:17 <lambdabot>   ["Real World Haskell","Real World Haskel","Real World Haskel","Real World H...
23:17:19 <mmorrow> > let f [] = "nine!" ; f (x:xs) = x ++ "(" ++ f xs ++ ")" ++ x in f ["foo","bar","baz"]
23:17:20 <lambdabot>   "foo(bar(baz(nine!)baz)bar)foo"
23:18:31 <Cale> albino: Similarly, if we wanted to add the elements of a list, we could write:
23:18:34 <Cale> sum [] = 0
23:18:39 <Cale> sum (x:xs) = x + sum xs
23:19:13 <Cale> albino: Or if we wanted to multiply them:
23:19:17 <Cale> product [] = 1
23:19:23 <albino> I'm actually kind of used to reduce(lambda x,y: x+y, [1, 2, 3, 4])
23:19:24 <Cale> product (x:xs) = x * product xs
23:19:49 <Cale> Right, so at this point we see that the only thing which is different in sum and product is that 0 has been replaced with 1 and + with *
23:19:53 <dolio> Python sure makes things look nice.
23:20:05 <mmorrow> > let sum [] = "0" ; sum (x:xs) = "(" ++ show x ++ " + " ++ sum xs ++ ")" in sum [0..9]
23:20:06 <lambdabot>   "(0 + (1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + 0))))))))))"
23:20:12 <Cale> So the natural thing to do is to replace those two bits which are changing with parameters of a new function
23:20:29 <RayNbow> > foldl (+) 0 [1,2,3,4]
23:20:30 <lambdabot>   10
23:20:39 <RayNbow> > foldr (+) 0 [1,2,3,4]
23:20:41 <lambdabot>   10
23:20:51 <mmorrow> > foldl f z [0..9]
23:20:53 <lambdabot>   f (f (f (f (f (f (f (f (f (f z 0) 1) 2) 3) 4) 5) 6) 7) 8) 9
23:20:57 <Cale> In Haskell, we call it foldr
23:20:57 <mmorrow> > foldr f z [0..9]
23:20:58 <lambdabot>   f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 z)))))))))
23:21:03 <Cale> foldr f z [] = z
23:21:14 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
23:21:21 <mmorrow> @src foldr
23:21:22 <lambdabot> foldr f z []     = z
23:21:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:21:27 <RayNbow> "Fold to the left, Fold to the right..." -- has anyone ever made a Haskell or Fold rap? :p
23:21:33 <mmorrow> @src foldl
23:21:34 <lambdabot> foldl f z []     = z
23:21:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:21:43 <mmorrow> @src concat
23:21:43 <lambdabot> concat = foldr (++) []
23:21:45 <Cale> I don't want to mention foldl right now :)
23:21:46 <mmorrow> @src reverse
23:21:47 <lambdabot> reverse = foldl (flip (:)) []
23:21:50 <mmorrow> @src sum
23:21:50 <lambdabot> sum = foldl (+) 0
23:21:52 <mmorrow> @src product
23:21:53 <lambdabot> product = foldl (*) 1
23:22:12 <mmorrow> Cale: oops, sorry :)
23:22:23 <mmorrow> i got a little too excited
23:22:35 <albino> Cale: hmm, I think at this point I need to pick up a book
23:23:05 <Cale> albino: So foldr removes the need for a certain kind of recursion, by taking care of that recursion for us.
23:23:05 <mmorrow> albino: playing around in the interpreter is the best way to learn
23:23:27 <Cale> albino: Another, perhaps simpler function is map:
23:23:30 <Cale> map f [] = []
23:23:34 <mmorrow> albino: (also, you can /msg lambdabot and have her eval all you want)
23:23:35 <Cale> map f (x:xs) = f x : map f xs
23:23:50 <Cale> It applies a function f to each of the elements of a list, producing a new list.
23:24:01 <Cale> > map (*10) [1,2,3]
23:24:02 <lambdabot>   [10,20,30]
23:24:43 <RayNbow> > map f [1..10]
23:24:44 <lambdabot>   Add a type signature
23:24:57 <Cale> Eventually, you might come to regard a list as a kind of "loop which hasn't happened yet"
23:25:02 <RayNbow> > map f [1..10] :: [Expr]
23:25:03 <xpika> in parsec how do you capture 30 chars?
23:25:04 <lambdabot>   [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10]
23:25:14 <albino> Cale: yeah, again from python, map(lambda x: x*10, [1, 2, 3]) -> [10, 20, 30]
23:25:19 <Cale> albino: right :)
23:25:47 <mmorrow> albino: nice. you're half way there then
23:25:52 <Cale> Functional programming is really about producing abstractions like this so that you hopefully only quite rarely have to write anything which is directly recursive.
23:25:54 <rwbarton> xpika: replicateM 30 char
23:25:57 <mmorrow> > (\x -> (x,x)) 42
23:25:58 <lambdabot>   (42,42)
23:26:04 <xpika> rwbarton: thanks
23:26:10 <mmorrow> > map (\x -> (x,x)) (repeat 42)
23:26:11 <lambdabot>   [(42,42),(42,42),(42,42),(42,42),(42,42),(42,42),(42,42),(42,42),(42,42),(4...
23:26:22 <mmorrow> > repeat 42
23:26:23 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
23:26:47 <rwbarton> xpika: well, that's not quite right.  some obvious modification hopefully
23:26:53 <mmorrow> > map (map (+1)) (repeat [0..4])
23:26:54 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
23:27:04 <mmorrow> > map sum (repeat [0..4])
23:27:06 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
23:27:15 <rwbarton> xpika: s/char/anyChar/
23:27:24 <Cale> albino: It might help though, to see how to translate a program which has a mutable variable into a program which doesn't.
23:27:39 <albino> Cale: Actually that's why I asked
23:28:07 <mmorrow> @paste
23:28:07 <Cale> albino: Even though variables, once bound in Haskell, never change, there are variables in the program which take on different values at different parts of the execution: function parameters.
23:28:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:28:09 <albino> Cale: I got thwaped by some people for mutating variables, but I can't understand why that's so terrible
23:29:03 <RayNbow> Joe Armstrong's book on Erlang has a nice paragraph on why mutable variables are bad :p
23:29:14 <Cale> albino: Well, I'd be willing to claim that the majority of bugs are caused by misunderstanding what the effects of some mutation are.
23:29:27 <_zenon_> RayNbow, coincidence! I have a friend who bought just that book yesterday
23:29:40 <RayNbow> albino, have you ever had to debug your code?
23:29:58 <albino> Cale: yeah, but in the case I knew the effects, so my guess is this is more about finding the absolute way to nip those problems in the bud
23:30:04 <albino> RayNbow: yes, of course
23:30:10 <RayNbow> _zenon_: I bought the book a while ago, but I've put reading it on hold (got somewhere till ch. 07 of the book)
23:30:15 <xpika> in parsec is there an mzero?
23:30:25 <RayNbow> albino: when you debug your code, you usually dump the contents of some variables, right?
23:30:38 <Cale> albino: Mutation makes programs hard to understand, because in order to determine if a function works, you not only have to worry about its parameters, but also the things which it might look at in memory, and instead of just looking at its result, you have to understand what effects it might have on other things.
23:30:56 <albino> RayNbow: yes
23:31:39 <RayNbow> albino: often you notice that some variables have some awkward or wrong value
23:31:52 <RayNbow> and then you have to track the location where they have acquired that value
23:31:56 <_zenon_> RayNbow, my friend bought it because he will be interviewed on friday. A company in Palo Alto will call him about some technical thesis thingy involving Erlang.
23:32:02 <RayNbow> and in a language with mutable variables, that could be anywhere
23:32:32 <RayNbow> in a language with "single assignment" (like Erlang, Haskell), there's only 1 possible place where the variable could have been bound
23:34:08 <Cale> When you test or debug an imperative program, you usually have to set up some initial state for the program to run in, possibly store away some parts of that initial state so they can be compared later, run the function you're interested, and then look around at all the things which might have changed.
23:34:50 <Cale> With pure functional programs, the only effect of a function is to produce a result from its parameters, so to test a function, you apply it to some parameters, and check to see if the result is correct.
23:35:18 <_zenon_> exactly, and thus it's easy to perform incrementive debug-tests for finding faults
23:36:54 <Cale> So the more that you restrict the behaviour of your functions, even if they still have some side effects apart from producing their result, the easier it gets to test them, and to understand their meaning in the program.
23:37:22 <cjs> @quote cjs
23:37:22 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
23:37:22 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
23:37:49 <cjs> Really, I should have said that the variables are single-assignment, but....
23:38:05 <RayNbow> cjs: they'd probably still flee in horror :p
23:38:39 <Cale> In Haskell's case, it's actually stronger than just single assignment.
23:38:48 <cjs> Is it?
23:38:54 <Cale> Variables never change their value or their definedness.
23:39:11 <Cale> (so long as they remain in scope)
23:39:24 <cjs> As in, defined or not?
23:39:42 <Cale> So there's no point "before you assigned it" where the variable doesn't have a value yet.
23:39:53 <Cale> If it's ever going to have a value, it will always have one.
23:41:21 <Cale> albino: Is that general bit of philosophy at all clear? I have a feeling that you need to actually experience it a while before it really sinks in.
23:44:00 <albino> Cale: Well I generally like the idea of every function having it's unique purpose.  And I'm sure that leads to programs with less problems.  I'm also sure that global variables are bad.  But my main issue is that function-local mutable variables seem just fine to me, especially for small functions where the programmer can reason about the state of the variables.
23:44:38 <cjs> You can use them in Haskell. You just have to be explicit about what you're doing.
23:44:39 <RayNbow> @hoogle State
23:44:39 <lambdabot> module Control.Monad.State
23:44:39 <lambdabot> Test.HUnit.Base data State
23:44:39 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
23:45:07 <Myoma> albino: function local mutation implies global mutation
23:45:35 <Cale> Myoma: I'm not sure that's true...
23:45:56 <Cale> albino: Well, you can always translate a function-local piece of state into a function parameter.
23:46:02 <cjs> But you have two situations: one where the function is still pure, in which case it's generally just as easy to use non-mutable variables as mutable, and one where the function maintains state, in which case you use Haskell's standard mechanims for dealing with state (a Monad of some sort, generally) anyway.
23:46:26 <Cale> albino: Write a function which takes the current state as a parameter, and returns its result paired with a new state.
23:46:31 <cjs> But this is really getting into stuff where you have to program in it for a while before you really understand that this works.
23:46:43 <Myoma> Cale, (define cell (lambda (value) (lambda (operation) (cond ((equal? operation 'get) value) ((equal? (car operation) 'set) (set! value (cdr operation)))))))
23:46:44 <albino> Cale: currying?
23:47:08 <Cale> Myoma: hm?
23:47:36 <Myoma> you can make mutable cells with function local mutation
23:47:36 <Cale> Myoma: When he says something like function-local state, I'm thinking of something like a State monad computation.
23:47:59 <Cale> Myoma: which is being run in order to produce the function, so there's no visible state outside it.
23:48:10 <Cale> (otherwise, it's not function local...)
23:48:18 <Cale> albino: Currying is something else.
23:48:31 <Myoma>  I can't imagine they could mean that
23:48:41 <Myoma> have they invented monads?
23:48:43 <Cale> albino: This is just adding an extra parameter to account for the fact that our function no longer only depends on the inputs, but also the state.
23:49:04 <Myoma> I don't consider State and ST function local though, which is the great thing about them
23:49:20 <_zenon_> Myoma, that looks like lisp
23:49:21 <Cale> Myoma: This is not inventing monads, though the solution I'm describing is more or less the basis of the state monad.
23:50:02 <Cale> Myoma: The important thing about ST is that all the state is local to a particular call to runST.
23:51:54 <albino> Cale: Is that translation automatic?  I mean can the compiler do it?
23:53:01 <mmorrow> function isLeapYear(x){return(x%4==0&&(x%100!=0||x%400==0))}
23:53:05 <mmorrow> handy^^
23:53:25 <Cale> albino: Well, we have libraries in Haskell that let you write something which looks a bit like imperative code and have it really mean the function parameter passing style.
23:53:40 <Cale> (this is what the state monad does)
23:54:24 <Myoma> > map isLeapYear [2008..]
23:54:25 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
23:54:54 <mmorrow> um
23:55:18 <mmorrow> ?index isLeapYear
23:55:18 <lambdabot> bzzt
23:55:30 <mmorrow> @type isLeapYear
23:55:31 <lambdabot> forall a. (Integral a) => a -> Bool
23:56:40 <mmorrow> > map isLeapYear [2008..]
23:56:41 <lambdabot>   [True,False,False,False,True,False,False,False,True,False,False,False,True,...
23:56:51 <mmorrow> wut
23:56:54 <Myoma> ??
23:56:55 <mmorrow> tf
23:57:13 <mmorrow> that's odd that it told you that
23:58:00 <cjs> What's the function to get the last element of a list?
23:58:09 <mmorrow> @let monthDays = [31,28,31,30,31,30,31,31,30,31,30,31]
23:58:09 <Myoma> cjs, last
23:58:10 <lambdabot>  Defined.
23:58:12 <ziman> > filter isLeapYear [1995..2010]
23:58:13 <lambdabot>   [1996,2000,2004,2008]
23:58:23 <medfly> o.o
23:58:25 <cjs> Doh!
23:59:07 <Pseudonym> > isLeapYear 1752
23:59:08 <lambdabot>   True
23:59:15 <cjs> Hm. So how do I implement a guarantee that a function will never return an empty list?
23:59:27 <albino> Cale: I'm going to bed, but thanks for taking the time to give such good and detailed explanations.  Not used to receiving such great help for such a philosphical type question.
23:59:30 <medfly> you define a case for an empty list? :o
23:59:31 <Myoma> cjs, data List1 a = Nil a | Cons a (List1 a)
23:59:41 <Choko> > filter isLeapYear [1895..1905]
23:59:42 <lambdabot>   [1896,1904]
23:59:47 <albino> actually more or less used to not getting any answers
