00:03:38 <damg> are there standard zip functions which fail with lists are of different lengths?
00:04:16 <Cale> damg: no
00:04:57 <damg> Cale, thank you, I hoped I've overseen them ;)
00:09:16 <Axman6> anyone with much HAppS experience? (or even not all that much at all) i don't understand why i get this error for BlogPage, but not CommentPage, when they;'re using almost the same code. http://hpaste.org/10780#a1
00:12:54 <BMeph> Heh-heh: "...the Haskell Platform doesn’t have a glue layer designed to uniformize APIs." (from http://dutherenverseauborddelatable.wordpress.com/2008/09/27/a-quick-update-on-batteries/) Sounds like someone is either tough-to-impress, or is-overlooking-something-major... >;)
00:12:57 <lambdabot> Title: A quick update on Batteries « Il y a du thé renversé au bord de la table, http://tinyurl.com/4c54wg
00:13:38 <humasect> what would they be overlooking, BMeph ?
00:14:19 <dons> they're overlooking the base library.
00:14:24 <dons> which is missing from ocaml.
00:14:28 <dons> it provides our glue layer.
00:14:37 <dons> the platform can require librarise use that glue, before inclusion.
00:14:58 <dons> if they reinvent say, an exception handling mechanism, or a tree type, they don't get in till they use the base types.
00:15:11 <Saizan> Axman6: methodSP vs. method
00:15:15 <humasect> ah, i see..
00:15:25 <Axman6> Saizan: sure... what?
00:16:08 <Saizan> Axman6: you're wrapping processComment with methodSP, while processPost with method
00:16:20 <Saizan> Axman6: SP stands for ServicePart
00:16:42 <Axman6> ah, i see
00:16:53 <Axman6> this is whay i get for not copying and pasting
00:18:01 <dons> BMeph:, humasect: make sense?
00:18:24 <dons> unlike ocaml, we have too many libraries and too many developers.
00:18:24 <humasect> i thought ocaml had a base library. with Array and stuff
00:18:32 <dons> so we can use people to force things to happen :)
00:18:35 <Axman6> you know, one day i'm going to type a sentense on IRC without a typo
00:18:38 <humasect> hmm..
00:18:39 <Axman6> and i shall be a great day
00:18:40 <dons> instead of having to write all the glue ourselves.
00:18:59 <humasect> 'ourselves' - isn't that the same pot where the 'too many devs' belong? hehe
00:19:02 <dons> also, we're a coherent community, so we can modify upstream, instead of fork + glue.
00:19:18 <dons> the ocaml guys have to add glue, since they can't get upstream agreement.
00:19:40 <dons> as was mentioned at CUFP, there are 101 ocaml prelude implementations.
00:19:44 <dons> so why not write another one. :)
00:20:03 <dons> (btw, ocaml isn't haskell's competitor, python is)
00:20:12 <humasect> ahh, i see
00:20:48 <humasect> hehe, this i figured when someone mentioned "isn't pyhton's incoming feature list a lot like haskell feature list?"
00:21:08 <Spark> i don't understand the obsession with python
00:21:36 <dons> its a good hill to climb.
00:21:45 <humasect> why is there a mention of ocaml at all? from the article?
00:21:51 <humasect> =)
00:21:54 <Spark> but it's not a big hill, neither does it have an interesting view :)
00:22:15 <dons> it has a big user base, and uses that i at least see haskell better suited to.
00:22:18 <dons> i.e. writing programs.
00:22:45 <Beelsebob> dons: heh, oddly, I always found python's biggest strength was writing server side bits of web apps
00:22:45 <Spark> that doesn't distinguish it from most other languages
00:23:02 <dons> find another enemy then :)
00:23:08 <Beelsebob> which I'd also put as one of haskell's biggest weaknesses
00:23:15 <dons> server side web apps?
00:23:24 <Beelsebob> as in, the server side chunk of a web app
00:23:41 <dons> isn't that the hottest area this year? (stable happs, fastcgi, sqlite/taksuen, kibro, panda, json serving, ...)
00:23:51 <slarba> hmm, isn't ocaml a decent stepping stone towards "real" functional language like haskell? :)
00:23:52 <dons> we're not comprehensive, but it is hot.
00:23:58 <humasect> ah, that is interesting, dons; i too also see that way where python's use is more suited and for greater benefit with haskell chosen and applied instead
00:24:12 <Beelsebob> yeh, it's still not really there dons -- I don't think it ever will be in a compiled language
00:24:25 <dons> oh. well, that's a philosophical issue.
00:24:28 <humasect> i've seen haskell uncompiled before.
00:24:35 <Spark> i can't help thinking python is for people who don't know better
00:24:39 <dons> run it in runhaskell if you don't want compiled code.
00:24:49 <Beelsebob> heh
00:25:15 <BMeph> dons: Force the Use, Luke! ;)
00:25:19 <Saizan> i think eval+serializable continuations makes a big difference for webapps
00:25:43 <Beelsebob> the other thing about python and web apps is tripple quoted strings
00:25:51 <humasect> read/show is fine for many things..
00:28:18 <ozy`> slarba: I'd say so. I had to learn OCaml before I could make any sense of Haskell...
00:28:19 <RayNbow> Beelsebob: '''these ones?''' or """these ones?"""
00:28:41 <BMeph> RaynBow: The second ones.
00:29:01 <BMeph> Er... *s/n/N/ :)
00:29:10 * RayNbow knows someone that prefers the first ones
00:29:30 <Axman6> Saizan: you wouldn't happen to know how to use textfield in HAppS would you?
00:29:35 <RayNbow> BMeph: ray[tab] = RayNbow... that way you don't have to use the shift key :)
00:30:54 <Saizan> Axman6: no, that's another Text.Xhtml function?
00:32:26 <Axman6> probably. i think i have it now...
00:32:30 <dancor> how can i find the Monad instance of Either using only lbot
00:32:56 <Axman6> whoot
00:34:18 <Baughn> dons: Given that I'd probably end up compiling my own ghc anyway, is there any benefit to using arch?
00:34:53 <Saizan> @instances-importing Control.Monad.Error Monad
00:34:54 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
00:35:23 <Saizan> that's not a solution though
00:38:30 <dons> Baughn: you don't have to compile your own ghc?
00:38:52 <dons> Baughn: but no, if you're a developer comfortable with building ghc on your own, and using cabal-install, any distro will do.
00:40:29 <Baughn> dons: Right. I figured I should try it (since I've broken debian pretty badly), but it wouldn't even install, so I guess..
00:40:38 * Baughn makes a fist in the general direction of nforce
00:44:31 <glguy> @seen dons
00:44:32 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 5m 38s ago.
00:44:37 <glguy> oh
00:44:42 <dons> glguy:
00:45:03 <glguy> dons: I talked to Oleg after that talk. He said that in his tests he was out-peforming lazy IO by a factor of 2
00:45:33 <dons> lazy IO on Char?
00:45:38 <ivanm> is there a standard date datatype?
00:45:40 <dons> or on chunked arrays?
00:45:45 <ivanm> System.Time doesn't seem to have anything :s
00:45:46 <glguy> dons: both using char, I'd imagine
00:45:49 <Baughn> ivanm: Several
00:45:54 <glguy> his and system.io
00:45:55 <dons> ok. that's less than I'd have thought.
00:46:11 <ivanm> Baughn: where?
00:46:19 <dons> so there's 32k times less laziness in lazy bytestrings
00:46:29 <Baughn> ivanm: The Data.Time hierarchy
00:46:33 <dons> so i hope only to match the performance
00:46:38 <dons> but get resource safety.
00:46:49 <Baughn> ivanm: Data.Time.Calendar, probably; ignore the julian and easter dates
00:47:14 <ivanm> I don't seem to have a Data.Time heirarchy...
00:47:18 <ivanm> you mean System.Time?
00:47:20 <dons> glguy: sound reasonable?
00:47:38 <ivanm> and I dont' have a System.Time.Calendar module either...
00:47:55 <glguy> http://www.haskell.org/pipermail/haskell-cafe/2008-September/047738.html
00:48:02 <lambdabot> Title: [Haskell-cafe] Lazy vs correct IO [Was: A round of golf], http://tinyurl.com/3gyv9l
00:48:05 <Baughn> ivanm: No, really Data.Time
00:48:20 <ivanm> well, I don't have anything called Data.Time with 6.8.3...
00:48:22 <Baughn> ivanm: It's in the time package
00:48:28 <Baughn> You may need to install it
00:48:50 <glguy> dons: writing an iterator based io with bytestrings sounds great
00:48:51 <ivanm> hmmmm.... looks like the docs aren't with the ghc ones, which is why I couldn't find it...
00:49:12 <dons> glguy: hopefully the best of both worlds.
00:49:17 <dons> maybe we should sit down some time and talk about it.
00:49:20 <Baughn> ivanm: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html <-- Yes they are. -_-
00:49:21 <lambdabot> Title: Haskell Hierarchical Libraries
00:49:28 <dons> since my hard trouble was understanding how to use oleg's combinator/monad stacks
00:49:35 <ivanm> Baughn: not locally they're not :p
00:49:35 <dons> and you saw the tutorial on that.
00:49:48 <dons> yeah, that email you link to was one i was using.
00:49:51 <ivanm> but thanks for that...
00:49:55 <Baughn> ivanm: If you download the documentation tarball, it'll be in there
00:49:57 <ivanm> I though it would be in the same doc package...
00:50:01 <ivanm> Baughn: I built mine...
00:50:14 <grkz>  /part
00:50:17 <ivanm> and must have rebuilt time since then, so it's seperate (different haddock version)
00:50:33 <Baughn> ivanm: Anyway, there you go. Have fun.
00:50:53 <ivanm> heh, yeah
00:52:04 <dancor> hoogle should index instances..
00:53:13 * Baughn loads up the library documentation a couple times to prime firefox
00:53:26 <Baughn> ..so now I'm using its history module for bookmarks. Whee.
00:53:38 <mmorrow> @tell chrisdone http://hpaste.org/10781#a0
00:53:39 <lambdabot> Consider it noted.
00:58:22 <hackage> Uploaded to hackage: AERN-Real 0.9.7
00:59:44 <mib_cx3gt3> guys i got a question in class that i need u guys to help me decipher
00:59:56 <mib_cx3gt3> Write a Haskell function countChange that calculates the number of different ways we can make change of n cents, given denominations of 1 cent, 2 cents, … , d cents ( i.e. if d=5, the denominations of coins available are 5 cents, 4 cents, 3 cents, 2 cents and 1 cent ) Examples: · count_
01:00:20 <mib_cx3gt3> · count_change (-10) 0 = 0 · count_change 5 3 = 5 · count_change 50 5 = 3765.
01:00:27 <mib_cx3gt3> ^^^
01:00:49 <mib_cx3gt3> those r example, jus can't seem to see how my teach come by those answer
01:00:52 <mib_cx3gt3> any help??
01:01:23 <Wild_Cat> mib_cx3gt3: you want all the possible combinations of coins whose sum is equal to n.
01:01:51 <chrisdone> mmorrow: ohh nice ;D
01:01:51 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
01:01:59 <Deewiant> for instance for 5 3, the 5 ways are [[3,2],[3,1,1],[2,2,1],[2,1,1,1],[1,1,1,1,1]]
01:02:00 <Wild_Cat> that is, if n is 5 cents, you want 1+1+1+1+1, 1+1+1+2, 1+1+3, etc.
01:02:27 <Wild_Cat> yeah, what Deewiant said.
01:02:32 <mib_cx3gt3> oh
01:03:25 <mib_cx3gt3> so... how would i go about writing a code for that?
01:04:10 <dolio> First, consider how you'd select one coin.
01:04:21 <mib_cx3gt3> k
01:04:30 <dolio> Then, figure out how you make change for the amount less that one coin.
01:04:57 <mmorrow> chrisdone: :))
01:05:23 <mmorrow> , let f n = (iterate (\x -> "(show . "++x++")") "id") !! n in maybe [] ($ 42) (fromDynamic (eval (f 4 ++ ":: Integer -> String")) :: Maybe (Integer -> String))
01:05:26 <lunabot>  "\"\\\"\\\\\\\"42\\\\\\\"\\\"\""
01:05:38 <dolio> Of course, it's slightly more complex than that.
01:05:53 <ivanm> where is TimeLocale defined? @hoogle doesn't know :s
01:05:54 <dolio> Because you also have to make sure you don't count both [1,2,1,1] and [2,1,1,1] and so on.
01:06:14 <Deewiant> ivanm: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=timelocale
01:06:16 <mmorrow> , maybe [] ($ 42) (fromDynamic (eval "show :: Integer -> String") :: Maybe (Integer -> String))
01:06:16 <lambdabot> Title: Hayoo!
01:06:19 <lunabot>  "42"
01:07:12 <ivanm> thanks Deewiant
01:07:12 <mmorrow> , fmap (eval . show) [0..4]
01:07:15 <lunabot>  [<<Integer>>,<<Integer>>,<<Integer>>,<<Integer>>,<<Integer>>]
01:07:35 <Deewiant> ivanm: rule of thumb: if Hoogle doesn't know, try Hayoo :-)
01:07:59 <ivanm> heh
01:08:20 <ivanm> damn, it doesn't look like System.{Time,Locale} is compatible with Data.Time :@
01:08:37 <ivanm> I just want it to print out today's date properly according to the user's locale! :s
01:08:47 <Lord_Illidan> I was checking out the Haskell implemented of Project Euler problem 18 on the haskellwiki.. Got it finally, a very concise piece of programming.
01:08:52 * dancor had to do that once..
01:08:56 <Lord_Illidan> But how do you guys come up with it?
01:09:31 <dibblego> Lord_Illidan, lots of practice
01:09:37 <dancor> ivanm: it isn't related to Locale i think
01:09:45 <mib_cx3gt3> guys i don't know how to start the ques
01:09:56 <mib_cx3gt3> countchange a n
01:10:00 <dolio> Which one is 18?
01:10:04 <ivanm> Data.Time.Format takes in a TimeLocale for formatTime :s
01:10:08 <Lord_Illidan> haskell.org/haskellwiki/Euler_problems/11_to_20#Problem_18
01:10:10 <mib_cx3gt3> |n == 0 = 0
01:10:18 <Lord_Illidan> warning, contains Spoilers, bla, bla
01:10:27 <ivanm> dancor: ummm.... dependending on your locality, the date gets printed differently
01:10:36 <ivanm> mainly to do with date/month order
01:10:37 <Axman6> Lord_Illidan: linking to the actual problem might be more useful ;)
01:10:43 <dancor> ivanm: see showRecent in http://dzl.no-ip.org:81/gitweb/?p=rr.git;a=blob;f=src/Main.hs
01:10:52 <Lord_Illidan> http://projecteuler.net/index.php?section=problems&id=18
01:10:54 <lambdabot> Title: Problem 18 - Project Euler
01:10:54 <mmorrow> lol: http://en.wikipedia.org/wiki/Tupper%27s_self-referential_formula
01:10:55 <lambdabot> Title: Tupper's self-referential formula - Wikipedia, the free encyclopedia
01:11:02 <dolio> Oh yeah. That one is quite nice.
01:11:15 <mmorrow> http://upload.wikimedia.org/wikipedia/commons/8/88/Tupper%27s_self_referential_formula_plot.png
01:11:17 <lambdabot> http://tinyurl.com/4oal2s
01:11:23 <mib_cx3gt3> anyhelp ???
01:11:35 <dolio> I just did dynamic programming when I first did that one.
01:11:36 <Lord_Illidan> I wasn't too sure about the algorithm, although I did think the best way was to start at the bottom.. which worked
01:11:49 <dolio> Then when I saw the zipWith version, I felt embarassed. :)
01:11:53 <Axman6> mib_cx3gt3: paste code, and tell us what the problem is
01:11:54 <dancor> @users
01:11:54 <lambdabot> Maximum users seen in #haskell: 515, currently: 467 (90.7%), active: 19 (4.1%)
01:12:30 <Lord_Illidan> heh, I worked it out on a piece of paper
01:12:39 <Lord_Illidan> you know, a dry run
01:12:50 <ivanm> dancor: that prints the correct time/date for that time zone, but doesn't necessarily use the correct date format AFAICT
01:12:59 <Lord_Illidan> and the zipWith version was amazingly concise, it's like it was designed for this very problem.
01:13:14 <Lord_Illidan> I mean, the zipWith function, sry
01:13:48 <ivanm> > getZonedTime
01:13:49 <lambdabot>   Not in scope: `getZonedTime'
01:14:10 <mib_cx3gt3> http://www.mibbit.com/pb/tj2m5L
01:14:12 <lambdabot> Title: Mibbit: PasteBin
01:14:32 <mib_cx3gt3> stuck there don't know what to do from there
01:14:41 <dancor> ivanm: oh maybe utcToLocalZonedTime?
01:15:23 <ivanm> dancor: nope, it ignores locale
01:15:31 <dancor> rightrigth
01:15:32 <ivanm> it just does the correct date/time for the time zone
01:15:48 <mib_cx3gt3> how am i gonna make haskell find the number of ways / all the ways we can change cents, given the denom
01:16:32 <dancor> ivanm: i can't even find new locale stuff.. only old-locale..
01:16:43 <ivanm> System.Locale?
01:16:50 <dancor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/old-locale
01:16:51 <lambdabot> Title: HackageDB: old-locale-1.0.0.0, http://tinyurl.com/3g9buk
01:16:52 <Axman6> mib_cx3gt3: what are you trying to do?
01:17:04 <dancor> oh maybe new is part of ghc?
01:17:05 <ivanm> yeah, that's all I could find as well
01:17:19 <mib_cx3gt3> Write a Haskell function countChange that calculates the number of different ways we can make change of n cents, given denominations of 1 cent, 2 cents, … , d cents ( i.e. if d=5, the denominations of coins available are 5 cents, 4 cents, 3 cents, 2 cents and 1 cent )
01:17:21 <ivanm> dancor: that's the locale stuff that GHC uses AFAICT
01:17:22 <EvilTerran> mib_cx3gt3, well, your program will need some concept of all the different coin denominations
01:17:48 <mib_cx3gt3> how do i do that, seems kinda complex
01:18:06 <EvilTerran> ah, ok, so you're not told those ahead of time - in that case, i guess your coin types should be a parameter to countChange
01:18:06 <dancor> ivanm: defaultTimeLocale has the right dateTimeFmt tho?
01:18:07 <ivanm> dancor: looks like dons to the rescue again :p http://cgi.cse.unsw.edu.au/~dons/blog/2008/06/24
01:18:08 <lambdabot> Title: Haskell hacking
01:18:14 <EvilTerran> so whoever's using it can specify them
01:18:14 <Deewiant> denominations d = [1..d]
01:18:18 <dancor> everytime
01:18:38 <EvilTerran> > [1..5]
01:18:39 <lambdabot>   [1,2,3,4,5]
01:18:40 <mib_cx3gt3> all i was given was a example
01:18:56 <mib_cx3gt3> · count_change (-10) 0 = 0 · count_change 5 3 = 5 · count_change 50 5 = 3765.
01:19:07 <dons> dcoutts_: if a library makes it into the platform, it should get bumped to 1.0 :)
01:19:40 <Axman6> Deewiant: i think the demoninations might be something like 1,2,5,10,25,50,100 or something
01:19:43 <EvilTerran> mib_cx3gt3, i suspect you could apply loads of combinatorics and get a very short algorithm out at the end involving factorials and whatnot
01:19:52 <Deewiant> Axman6: the problem description is quite explicit
01:19:55 <int-e> Axman6: they aren't.
01:19:57 <Deewiant> it's [1..d]
01:20:01 <dcoutts> dons: heh heh
01:20:11 <EvilTerran> mib_cx3gt3, but you might be expected to brute-force it instead of sidestepping the problem with maths
01:20:27 <Axman6> oh, heh, i missed that it kept doing after 2 cents
01:20:28 <ivanm> though I would have thought that something like defaultTimeLocale would have been IO... or is unsafePerformIO being used?
01:20:36 <int-e> mib_cx3gt3: are you confused about which argument is which?
01:21:04 <EvilTerran> int-e, well, i am :P
01:21:20 <Deewiant> the first is n, the second is d
01:21:23 <int-e> EvilTerran: the first argument is the amount; the second specifies the denominations.
01:21:26 <mib_cx3gt3> yeah i am blanked
01:21:28 <mib_cx3gt3> sorry
01:21:47 <EvilTerran> ok
01:21:47 <int-e> EvilTerran: and 5 for denominations means [1..5] as Deewiant says.
01:21:55 <EvilTerran> i got that bit
01:22:10 <int-e> at least with that interpretation the result agrees with the given examples :)
01:22:12 <EvilTerran> the strange selection of denominations is what made me think a combinatorics approach would work
01:22:29 <dolio> How many ways are there to make change with only 1 cent coins?
01:22:54 <mib_cx3gt3>       i.e. if d=5, the denominations of coins available are 5 cents, 4 cents, 3 cents, 2 cents and 1 cent
01:23:02 <EvilTerran> mib_cx3gt3, yes, we got that
01:23:09 <dolio> What if d=1?
01:23:26 <mib_cx3gt3> i guess it's only 1cent
01:23:32 <Axman6> and 1 way
01:23:34 <int-e> or maybe even easier, d = 0 :)
01:23:37 <dolio> Right. So what's the answer if d=1?
01:23:45 <int-e> (and n>=0)
01:23:51 <dolio> Yeah.
01:24:10 <dolio> Well, n>0, depending on how you interpret making change for 0 cents.
01:24:36 <int-e> easy. you give no coins at all
01:24:41 <int-e> exactly one way to do that.
01:24:45 <dolio> :)
01:24:48 <Axman6> > [1..(-3)]
01:24:49 <lambdabot>   []
01:24:56 <Axman6> handeh
01:25:20 <dolio> What about negative cents?
01:25:22 <ejt> > [0, -1 .. -3 ]
01:25:24 <lambdabot>   [0,-1,-2,-3]
01:25:35 <dolio> Apparently those cases are supposed to be 0.
01:26:03 * Axman6 doesn't like negative money
01:26:07 <Kvasir> hello
01:26:48 <mib_cx3gt3> yeah 0 for negs
01:26:59 <dolio> Or, actually, the example is 'foo (-10) 0 = 0' so it's hard to tell if that's specifying the d=0 case or the n<0 case.
01:27:00 <int-e> dolio: we have no example where n=0.
01:27:05 <mib_cx3gt3> this ques seems more complex than i thought
01:27:22 * Twey frowns.
01:27:34 <Twey> Can't do a backwards range?
01:27:42 <Twey> > [5..1]
01:27:43 <lambdabot>   []
01:27:45 <dolio> int-e: Yeah. He should just turn in a paper that says, "the problem was ill-specified". :)
01:27:46 * EvilTerran randomly shouts "DYNAMIC PROGRAMMING!" and runs off into the bushes
01:27:47 <Twey> :(
01:27:51 <quicksilver> > [5,4..1]
01:27:52 <EvilTerran> > [5,4..1] -- Twey
01:27:52 <lambdabot>   [5,4,3,2,1]
01:27:53 <Twey> Hahaha
01:27:53 <lambdabot>   [5,4,3,2,1]
01:27:55 <Twey> Aha
01:27:55 <ivanm> grrr..... even using the locale, I can't seem to get it to produce locale-specific dates :@
01:28:04 <Twey> > [5, 4 .. ]
01:28:04 <quicksilver> it's exactly like BASIC
01:28:05 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18...
01:28:07 <int-e> mib_cx3gt3: it's not that complicated really to express count_change recursively. it's a bit harder to make it efficient
01:28:11 <quicksilver> the "STEP" defaults to +1
01:28:12 <Twey> Ahh.
01:28:13 <Twey> 'kay.  :)
01:28:37 <ivanm> for some reason, it thinks I'm using American dates?!?!?!?
01:28:39 <EvilTerran> int-e, as i said, a dynamic programming approach would make it efficient
01:29:17 <int-e> EvilTerran: yes, I know. But it's hard to get that working without the naive implementation as a reference.
01:29:22 <EvilTerran> indeed
01:29:28 <EvilTerran> naive implementation first
01:29:40 <ivanm> is there anyway I can work out what locale I'm actually in? I'm guessing TimeLocale is an inbuilt value rather than using the environment :@
01:29:43 <EvilTerran> then apply equational reasoning to get an equivalent but more efficient version
01:30:20 <EvilTerran> Richard Bird style :)
01:30:37 <int-e> and the naive implementation is good enough for the  count_change 50 5  case anyway.
01:30:52 <quicksilver> ivanm: not to be unduly pedantic, but TimeLocale is a type, it's not a value at all.
01:31:00 <int-e> EvilTerran: uh. I skipped a few steps there *g*
01:31:21 <dons> policy taking shape, http://haskell.org/haskellwiki/Haskell_Platform
01:31:25 <lambdabot> Title: Haskell Platform - HaskellWiki
01:31:25 <ivanm> quicksilver: yes, I meant timeLocale
01:31:35 <ivanm> I thought it would actually specify the locale as defined by the system...
01:31:49 <EvilTerran> int-e, pages? i was thinking more along the lines of lectures... ;)
01:31:52 <quicksilver> ivanm: did you mean 'defaultTimeLocale' ?
01:31:54 <int-e> EvilTerran: (I have an editor window open with a naive and two dynamic programming implementations for count_change)
01:32:12 <EvilTerran> er, pages? what? where did i get that from
01:32:13 <dons> Cale, ddarius can someone do a killer logo for the haskell platform? :)
01:32:16 * EvilTerran goes to get coffee
01:32:37 <dolio> Just switch out the y-combinator for a memoizing combinator. Efficiency. :)
01:32:44 <EvilTerran> sorry, just woke up, and this channel caught my attention while i was checking my email. i should go away before i start making even less sense :P
01:32:45 <ivanm> quicksilver: yeah, that thingy :p
01:32:59 <int-e> EvilTerran: Does 124 characters count as a one-liner? (I can save 12 characters on the function name)
01:33:09 <EvilTerran> ... probably
01:33:23 <EvilTerran> if you can get it below 80 characters, it's definitely a one-liner
01:33:55 <quicksilver> ivanm: I'm not surprised it doesn't represent the system locale, since it doesn't have 'IO' type.
01:34:41 <quicksilver> ivanm: but I'm surprised that there isn't something like getCurrentLocale :: IO TimeLocale :-/
01:34:47 <ivanm> I originally thought it might have been doing unsafe magic
01:34:48 <ivanm> yeah :s
01:35:25 <ivanm> I mean, there's setLocale...
01:35:55 <quicksilver> odd.
01:37:39 <ivanm> oh well, looks like I'll have to enforce my own date format ;-)
01:41:57 <RayNbow> mib_cx3gt3: still working on that count_change problem?
01:42:51 <int-e> EvilTerran: well, 74 characters without handling the pesky n<0 case, and with a single letter identifier. Oh, and with far too few spaces.
01:44:41 <Xenoblitz> hi guys has anyone ever used HGL?
01:47:34 <RayNbow> mib_cx3gt3, http://i296.photobucket.com/albums/mm178/ShinNoNoir85/count_change.jpg
01:50:34 <ivanm> quicksilver: I suppose one problem with having _proper_ locales is that the date would be harder to parse, because you'd have to know in advance what locale it was printed in
02:06:06 <damg> hm, looks like i pulled the wrong plug ...
02:17:06 --- mode: irc.freenode.net set +o ChanServ
02:38:08 <ivanm> is there a common representation for directories/files and URLs?
02:38:21 <ivanm> i.e. something like FilePath that also supports URLs?
02:38:41 * luqui doesn't think so
02:38:47 <ivanm> *nod*
02:38:53 <ivanm> oh well, time for a wrapper data type
02:39:13 <luqui> data Location = File FilePath | URL URL
02:39:15 <luqui> :-)
02:39:30 <mm_freak_> ivanm: represent a file path as a URL
02:39:37 <mm_freak_> file:///path/to/file
02:39:56 <Leaves> hello, I have something like this: data A = A Int Int Int Int, and sometimes I want to do the same action on all of the ints, of course I can do f (A a b c d) = A (a+1) (b+1) (c+1) (d+1) but do you know if I can let A derive something so I can do f a = map (+1) a ?
02:40:10 <ivanm> hmmmmm..... I'm not sure if that'll work too well...
02:40:22 <mm_freak_> Leaves: turn your A into a functor
02:40:24 <ivanm> since I'll be doing file-level manipulation as well...
02:40:27 <RayNbow> ah, netsplit is over?
02:40:46 <mm_freak_> Leaves: but you'll have to generalize your Int for that to work
02:40:47 <EvilRanter> ivanm, there's Network.URI
02:40:47 <Baughn> Leaves: Then you can use fmap. Alternately, since it's just a bunch of ints, why not use [Int]?
02:40:49 <quicksilver> I bet there is a URL representation in some library.
02:41:14 <luqui> data Quad a = Quad a a a a ; instance Functor Quad where ...
02:41:22 <EvilRanter> Baughn, that would mean the length wasn't enforced at compile-time, though
02:41:40 <Baughn> EvilRanter: True, and by using Functor the element type wouldn't be enforced at compile-time
02:41:45 <Baughn> It's a trade-off either way
02:42:07 <Baughn> Although, you could make A a functor and then type A' = A Int
02:42:13 <EvilTerran> how would using lists enforce the element type at compile-time?
02:42:17 <quicksilver> Baughn: that's not true.
02:42:17 <luqui> Baughn, right
02:42:28 <quicksilver> Baughn: the element type of 'Quad Int' is enforced at compile time!
02:42:30 <EvilTerran> any more so than data Quad a = ... would, i mean
02:42:54 <Leaves> well, [Int] is not good, since it's fixed lengts and often the different Ints have different meanings, I guess it might me better if I do myMap f (A a b c d) = A (f a) (f b) (f c) (f d)
02:42:58 <Baughn> quicksilver: So it is, and using type to name that would be natural. NEver mind me.
02:43:03 <quicksilver> actually I often find extra generality is useful, anyway.
02:43:18 <lunabot>  1
02:43:21 <luqui> Leaves, if the different ints have different meanings, then what is the meaning of doing the same thing to all of them?
02:43:30 <Axman6> why not just make a function mapA f (A a b c d) = A (f a) (f b) (f c) (f d)
02:43:33 <mm_freak_> Leaves: as said, generalize your Int to 'a' and turn your A into a functor…  then derive a special case from it
02:43:34 * EvilTerran looks askance at lunabot
02:43:39 <Baughn> Leaves: No, luqui's suggestion is good. Make Quad a functor, then type A = Quad Int
02:43:41 <EvilTerran> i asked you that over PM!
02:43:48 <mm_freak_> data Quad a = Quad a a a a
02:43:51 <Leaves> Ok, I will try that
02:44:13 <mm_freak_> instance Functor Quad where fmap f (Quad a b c d) = Quad (f a) (f b) (f c) (f d)
02:44:17 <luqui> there is only one correct instance of Functor Quad, right?
02:44:19 <mm_freak_> type IntQuad = Quad Int
02:44:36 <ivanm> EvilTerran: hmmmm... they're URI datatype seems overly complex to me :s
02:45:23 <luqui> when is that the case in general?  would it be possible to set up a deriving clause for Functor when it is?
02:45:23 <quicksilver> luqui: well that's only informally true.
02:45:23 <luqui> quicksilver, do elaborate :-)
02:45:23 <EvilTerran> luqui, well, you could do it with Data.Generics, i think
02:45:23 <quicksilver> luqui: fmap f (Quad a b c d) = Quad (f a) b c d is perfectly valid
02:45:28 <quicksilver> luqui: there might be a good rason to only map some components.
02:45:28 <luqui> quicksilver, it does not typecheck
02:45:36 <Leaves> luqui: Well they represent different bytes in a Word of an encryption algorithm, for some steps in the algorithm they have different meaning while in other step not
02:46:10 <Leaves> luqui: (this was just an example to ask the question, in the app it actually are Word8's)
02:46:11 <EvilTerran> , everywhere (mkT (^2)) (1,2,3,4)
02:46:13 <lunabot>  (1,4,9,16)
02:46:19 <luqui> Leaves, sure.
02:47:16 * luqui wonders why each bot has some magic metacharacter, and why bots don't just respond to being addressed directly instead...
02:47:25 <EvilTerran> given "data Quad a = Quad a a a a deriving (Typeable, Data)", your instance would be "instance Functor Quad where fmap f = everywhere (mkT f)", i think
02:48:00 <mm_freak_> Leaves: UArray Int Word8
02:48:06 <luqui> EvilTerran, thanks.  I'm much less pragmatic than that, more interested in the the theory :-)
02:48:08 <mm_freak_> wouldn't that work?
02:48:27 <pastorn> @pl \(x,y) -> (y,x)
02:48:28 <lambdabot> uncurry (flip (,))
02:48:34 <luqui> mm_freak_, size not enforced at compile time again
02:48:37 <idnar> lunabot: everywhere (mkT (^2)) (1,2,3,4)
02:48:44 <maltem> quicksilver: What would the instance header for the Quad exampe look like?
02:48:45 <idnar> heh
02:48:52 <mm_freak_> luqui: indeed
02:48:55 <EvilTerran> pastorn, i'd suggest just defining "swap ~(x,y) = (y,x)"
02:49:08 <luqui> Yay for lazy tuples!
02:49:17 <luqui> I mean lazy tuple pattern matching of course
02:49:21 <idnar> why make it lazy?
02:49:22 <EvilTerran> it should be in Data.Tuple, IMO, but oh well
02:49:24 <quicksilver> nah, I was wrong.
02:49:27 <EvilTerran> i've also heard it called flop
02:49:41 <mm_freak_> > fmap (+1) (2,3)
02:49:43 <lambdabot>   (2,4)
02:49:43 <EvilTerran> idnar, because we like laziness?
02:49:46 <mm_freak_> huh?!
02:49:54 <quicksilver> despite being apparently useful, I find I very rarely use it.
02:49:57 <mm_freak_> i expected (3,4) or an error, but not (2,4)
02:49:59 <EvilTerran> mm_freak_, (a,) is a functor
02:50:00 <quicksilver> (swap/flop)
02:50:01 <mm_freak_> > fmap (+1) (2,3,4,5)
02:50:03 <lambdabot>       No instance for (Functor ((,,,) t t1 t2))
02:50:03 <lambdabot>        arising from a use of ...
02:50:06 * luqui is of the opinion that Haskell would be cleaner without strict pattern matching on tuples
02:50:09 <mm_freak_> EvilTerran: ah, ok
02:50:21 <idnar> EvilTerran: maybe I'm just confused; I don't understand how it makes a difference here
02:50:24 <EvilTerran> mm_freak_, a Functor must be (* -> *)
02:50:37 <mm_freak_> EvilTerran: yeah, i realized just right now
02:50:40 <EvilTerran> so you couldn't have a Functor instance for (,) that affected both elements
02:50:52 <EvilTerran> > (\ ~(_,_) -> "ok") undefined
02:50:54 <lambdabot>   "ok"
02:50:57 <EvilTerran> > (\ (_,_) -> "not ok") undefined
02:50:58 <lambdabot>   "* Exception: Prelude.undefined
02:51:03 <EvilTerran> idnar, that's why
02:51:09 <mm_freak_> luqui: lazy pattern matching?  how would that work?
02:51:14 <mm_freak_> looking into the future?
02:51:34 <luqui> EvilTerran, however I think for swap the two are equivalent (in the subset of haskell without seq)
02:51:35 <maltem> mm_freak_: no, just failing later
02:51:39 <EvilTerran> mm_freak_, i think luqui is thinking of ~ patterns
02:51:42 <Leaves> I have now done data Quad a = Quad a a a a, and then type Word = Quad Word8, but now I do not have a constructor for Word anymore?
02:51:43 <idnar> EvilTerran: hmm
02:51:54 <EvilTerran> luqui, pretty sure that's not the case
02:52:01 <mm_freak_> maltem: i prefer them to fail where they're supposed to fail
02:52:01 <luqui> EvilTerran, got a counterexample?
02:52:08 <EvilTerran> > (\ (x,y) -> (y,x)) undefined
02:52:09 <lambdabot>   * Exception: Prelude.undefined
02:52:13 <EvilTerran> > (\ ~(x,y) -> (y,x)) undefined
02:52:14 <lambdabot>   (* Exception: Prelude.undefined
02:52:16 <mm_freak_> EvilTerran: ~ patterns?  what's that?
02:52:20 <quicksilver> Leaves: the constructor is 'Qud'
02:52:25 <quicksilver> Leaves: 'Quad'
02:52:38 <EvilTerran> luqui, you can tell by the ( in the second one that you've got (_|_, _|_) instead of _|_
02:52:38 <maltem> mm_freak_: indeed ~ patterns aren't used terribly often
02:52:55 <mm_freak_> what are ~ patterns?
02:53:01 <luqui> EvilTerran, ah yes.  I was thinking in my ideal subset of haskell where (_|_, _|_) = _|_, :-)
02:53:09 <idnar> EvilTerran: ah, your second example helps me out
02:53:10 <EvilTerran> mm_freak_, they're defined in the report
02:53:18 <luqui> in which of course it's the same, because ~(a,b) is the same as (a,b) :-)
02:53:23 <quicksilver> luqui: it would be bizarrely inconsistent to have tuples lazy by default and all other types are strict by default.
02:53:45 <EvilTerran> mm_freak_, http://haskell.org/onlinereport/exps.html#sect3.17.2
02:53:48 <Saizan> mm_freak_: for types with only a constructor there's no way to fail a pattern match, apart from _|_
02:53:50 <lambdabot> Title: The Haskell 98 Report: Expressions
02:53:53 <quicksilver> (a,b) shouldn't be any different from data Pair a b = Pair a b
02:54:04 <luqui> quicksilver, agreed.   I would generalize to all single constructor types
02:54:07 <EvilTerran> "Matching the pattern ~apat against a value v always succeeds. The free variables in apat are bound to the appropriate values if matching apat against v would otherwise succeed, and to _|_ if matching apat against v fails or diverges. (Binding does not imply evaluation.)"
02:54:19 <luqui> quicksilver, which has its own sort of inconsistency, but also another kind of consistency
02:54:25 <luqui> which haskell presently lacks
02:54:27 <quicksilver> luqui: yes, that's a supportable view.
02:54:36 <EvilTerran> i prefer to have the option
02:54:39 <Saizan> Miranda was like that
02:55:00 <EvilTerran> it's one extra character to make a strict match into a irrefutable one
02:55:09 <luqui> quicksilver, get my email?
02:55:16 <EvilTerran> if you had implicit irrefutable matches, i'm not sure how you'd make them strict if you wanted to
02:55:26 <mm_freak_> interesting…  i didn't know you could enforce lazy pattern matching
02:55:33 <luqui> EvilTerran, there would be no such thing as a strict match in the semantics
02:55:39 <quicksilver> luqui: yes.
02:56:00 <luqui> so you wouldn't be allowed to want to :-)
02:56:02 <Saizan> EvilTerran: soemthing like seq of the components, i imagine
02:56:06 <mm_freak_> Saizan: so?  you mean that pattern matching against a single-constructor type may enforce evaluation unnecessarily?
02:56:12 <dolio> You'd use bang patterns. :)
02:56:12 <EvilTerran> luqui, i don't follow
02:56:33 <Saizan> mm_freak_: yeah, you don't need it to choose between alternatives
02:56:45 <luqui> EvilTerran, if (_|_, _|_) = _|_, then what does it mean for a function to strictly match on a tuple, rather than lazily?
02:56:47 <quicksilver> EvilTerran: luquis view is that there is no value distinguishing between _|_ and (_|_,_|_)
02:57:04 <EvilTerran> i ... see...
02:57:33 <quicksilver> EvilTerran: he would rather the laziness was forced to be only at the component-site, not at the pair-constructor site.
02:57:40 <Leaves> quicksilver: thanks, that constructor works
02:57:44 <EvilTerran> so tuples would pattern-match like newtypes, only with more than one component?
02:58:02 <mm_freak_> > (\a@(x,y) -> a `seq` 0) (undefined,undefined)
02:58:04 <lambdabot>   0
02:58:05 <EvilTerran> as in, matching against (_,_,...,_) would always succeed
02:58:08 <mm_freak_> there is =)
02:58:13 <luqui> EvilTerran, roughly yes...
02:58:30 <Leaves> why is a list not an instance of Functor (ie, why is there map for a list and not fmap)?
02:58:37 <mm_freak_> Leaves: it is
02:58:38 <EvilTerran> there is an instance
02:58:43 <EvilTerran> there's just map as well
02:58:45 <mm_freak_> > fmap (+1) [1,2,3]
02:58:47 <lambdabot>   [2,3,4]
02:58:55 <mm_freak_> map is a special case of fmap
02:58:57 <luqui> > (+1) . [1.2.3]
02:58:58 <EvilTerran> @check \f xs -> map f xs == fmap f (xs :: [Int])
02:58:58 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
02:58:59 <lambdabot>       Overlapping instances for Show (Int -> b)
02:58:59 <lambdabot>        arising from a use of ...
02:59:00 <sjanssen> luqui: I'm having trouble finding it in the logs, what exactly are you proposing?
02:59:07 <EvilTerran> er
02:59:09 <luqui> aww no CalePrelude anymore  (that could be good)
02:59:18 <Leaves> mm, but couldn't map just be removed and fmap be renamed map?
02:59:21 <luqui> sjanssen, that (_|_,_|_) = _|_
02:59:32 <mm_freak_> Leaves: yes, it could
02:59:33 <sjanssen> hmm
02:59:33 <luqui> sjanssen, (and the generalization to all single-constructor datatypes)
02:59:37 <EvilTerran> Leaves, some people want that
02:59:38 <mm_freak_> and IIRC it used to be that way
02:59:51 <Leaves> I think that would look nicer
02:59:53 <EvilTerran> Leaves, but it's not been done that way. blame the simons.
02:59:55 <sjanssen> luqui: so "data (,) a b = (,) !a !b"?
02:59:56 <mm_freak_> i wouldn't replace map by fmap, but i'd rename the functions
02:59:56 <luqui> Leaves, some people even want fmap to be removed and renamed to (.)
03:00:05 <luqui> sjanssen, no!
03:00:08 <mm_freak_> like map → lmap and fmap → map
03:00:16 <luqui> sjanssen, because then (_|_,42) = _|_
03:00:33 <sjanssen> luqui: this seems like a significant change
03:00:35 <luqui> sjanssen, more or less, every tuple pattern match would be lazy.
03:00:45 <dibblego> fmap → (.)
03:00:48 <sjanssen> luqui: I think this will cause massive space leaks
03:00:58 <luqui> sjanssen, yes it is.  It isn't a formal proposal, I like haskell how it is.  I think it would be the slightest bit cleaner with this change :-)
03:00:59 <EvilTerran> sjanssen, the idea is that (\(_,_) -> ...) _|_ would work
03:01:06 <luqui> sjanssen, do you have an example?
03:01:22 <EvilTerran> i'm happy putting in ~s when i want that behaviour
03:01:23 <luqui> sjanssen, or some indication to why you think it would cause space leaks?
03:01:36 <EvilTerran> as can be seen by the line that started this whole discussion
03:01:41 <luqui> EvilTerran, aye, me too, it's not so bad.  I just found that I started putting ~ everywhere :-)
03:01:59 <EvilTerran> [10:48] <EvilTerran> pastorn, i'd suggest just defining "swap ~(x,y) = (y,x)"
03:02:07 <EvilTerran> ^ it's my fault :/
03:02:08 <mm_freak_> luqui: honestly i've never had problems with strict pattern matching, and i wouldn't know where lazy pattern matching has advantages for me
03:02:24 <mm_freak_> seems like if you don't know that that exists, you don't really need it…  same as arrows =)
03:02:27 <pastorn> EvilTerran: doesn't look as mysterious
03:02:37 <luqui> mm_freak_, it gets really hairy once you start doing funny recursion stuff
03:02:41 <EvilTerran> pastorn, it only looks mysterious the first time you see it, imo
03:02:41 <Saizan> luqui: there was recently a thread on an huge space leak caused by lazy tuple matching in a let
03:02:52 <luqui> mm_freak_, interestingly, the place it first got hairy for me was the first day I was exposed to arrows :-)
03:02:57 <EvilTerran> after that, you know what it is, and it loses its mystery
03:03:03 <mm_freak_> hehe
03:03:08 <pastorn> > swap ~(1,2)
03:03:08 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
03:03:08 <lambdabot>  ...
03:03:14 <sjanssen> luqui: because all variables matched in a tuple are actually thunks, eg. "fst foo", "snd foo"
03:03:15 <Saizan> luqui: and apparently it's a known problem for which there are special optimizations in GHC
03:03:18 <pastorn> > swap (1,2)
03:03:19 <lambdabot>   Not in scope: `swap'
03:03:22 <sjanssen> luqui: become thunks, tha tis
03:03:23 <EvilTerran> pastorn, ~ is for patterns, not expressions
03:03:31 <pastorn> huh?
03:03:37 <pastorn> never used before...
03:03:42 <pastorn> how does it work?
03:03:42 <EvilTerran> @let swap ~(x,y) = (y,x); swap' (x,y) = (y,x)
03:03:43 <lambdabot>  Defined.
03:03:44 <luqui> Saizan, hmmm interesting
03:03:56 <EvilTerran> pastorn, http://haskell.org/onlinereport/exps.html#sect3.17.2
03:03:57 <lambdabot> Title: The Haskell 98 Report: Expressions
03:04:00 <sjanssen> Wadler's "full laziness" optimization is related to this, right?
03:04:24 <ivanm> what's the difference between Network.URI and Network.URL?
03:04:44 <EvilTerran> i don't have a Network.URL...
03:04:46 <Saizan> luqui: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/44708
03:04:48 <EvilTerran> there's one difference :P
03:04:50 <lambdabot> Title: Gmane Loom
03:05:20 <ivanm> EvilTerran: heh
03:05:26 <ivanm> http://hackage.haskell.org/packages/archive/url/1.0.1/doc/html/Network-URL.html
03:05:27 <lambdabot> Title: Network.URL, http://tinyurl.com/3nefbn
03:05:30 <ivanm> it's in the url package
03:05:40 <EvilTerran> ivanm, URI and URL are both defined at tedious and confusing length by the w3c
03:05:58 <ivanm> *nod*
03:06:15 <EvilTerran> although those two look like they serve much the same purpose
03:06:17 <ivanm> all I want is the ability for people to include a URL which will then get printed as part of a generated document...
03:06:31 <ivanm> should I even bother with either, or just use a String?
03:07:12 <EvilTerran> i'd probably just use a string
03:07:19 <ivanm> *nod*
03:07:28 <EvilTerran> give it a type alias so your type sigs are more self-documenting
03:07:42 <EvilTerran> type URL = String or something
03:07:52 <ivanm> I think I'll stick with FilePath for local locations, since that will actually use and manipulate files
03:09:46 <ivanm> *sigh* not again...
03:09:56 <lilac> good ol' freenode
03:10:04 <papermachine> forever net-split
03:15:33 <Leaves> is there also a class for fzip like Functor is for fmap?
03:16:37 <luqui> Leaves, Applicative, sortof.
03:16:45 <wjt> fzip :: (a -> b -> c) -> f a -> f b -> f c ?
03:18:02 * luqui loves Applicative with most of his heart
03:18:08 <dolio> Applicative isn't really guaranteed to be zippish.
03:18:29 <luqui> dolio, what law would you expect of zip that Applicative breaks?
03:18:56 <dolio> The Applicative instance for [] doesn't zip lists.
03:19:06 <dolio> The one for ZipList does, of course.
03:19:11 <luqui> yes that is true.  what law expresses "zippishness" though?
03:19:37 <luqui> I'm just having trouble visualizing that...
03:19:37 <dolio> I'm not sure there's any law that expresses it.
03:19:51 <EvilTerran> Leaves, Data.Generics.Twins can do it
03:19:57 <luqui> well then it's awful hard to enforce via a typeclass :-)
03:20:30 <dolio> Presumably a zip identifies common structure between two functor-ish (or not, even) values, and combines things at corresponding positions.
03:20:36 <EvilTerran> Leaves, and category-extras has Control.Functor.Zip
03:20:56 <luqui> dolio, maybe the law is expressible via Traversable then?
03:21:35 <EvilTerran> Control.Functor.Zip.fzip :: Zip f => f a -> f b -> f (a, b)
03:21:41 <EvilTerran> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Zip.html
03:21:42 <lambdabot> Title: Control.Functor.Zip, http://tinyurl.com/4wbucw
03:21:48 <Leaves> I think that looks like what I want
03:22:23 <EvilTerran> category-extras is a bit arcane, mind
03:22:29 <Saizan> luqui: zipWith f (toList x) (toList y) == toList (fzip f x y) ? a bit restrictive
03:22:29 <Leaves> *thinks he is making haskell programming to hard for hisselve..
03:23:13 <EvilTerran> note Control.Functor.Zip.counbizip :: (PreCoCartesian r sr, PreCoCartesian s ss, PreCoCartesian t st, Bifunctor q r s t) => t (st (q a c) (q b d)) (q (sr a b) (ss c d))
03:23:22 <EvilTerran> i think they might've got a bit carried away there
03:23:25 <EvilTerran> :P
03:23:35 <Leaves> :)
03:23:46 <luqui> Saizan, well it may or may not be too restrictive, but I think it misses the "essence" either way...
03:23:51 <EvilTerran> ...
03:24:10 * EvilTerran needs to work out how to stop xchat showing all the comings and goings in a netsplit
03:24:12 <Axman6> god damnit freenode
03:24:16 <EvilTerran> but still show people coming and going otherwise
03:24:23 <Leaves> mm, currently tha lib is still plain haskell98, so maybe I should just define myZip and stick with the std libraries :)
03:24:26 <Axman6> EvilTerran: get irssi
03:24:30 <luqui> EvilTerran, category-extras is *about* maximizing carried-awayness
03:24:43 <Axman6> it's bve3en failing a bit with the overjoins, but doing ok most of the time
03:24:50 <luqui> EvilTerran, right click on the channel name
03:25:03 <EvilTerran> Axman6, "how do i fix xchat?" "install irssi" is a bit of a non-sequiteur
03:25:13 <EvilTerran> it should be fairly straightforward to write an extension for what i want
03:25:23 <quicksilver> you can zip traversabale to foldable
03:25:23 <luqui> EvilTerran, there's an option to disable join/part messages.
03:25:27 <Saizan> heh, i got the join flood on irssi this time
03:25:30 <luqui> not perfect but it'll do
03:25:30 <EvilTerran> luqui, yeah, i see that, but i like to know when individuals are coming and going
03:25:31 <quicksilver> wowo
03:25:34 <quicksilver> you can zip traversabale to foldable
03:25:34 <luqui> ah
03:25:39 <quicksilver> I was just saying.
03:25:52 <quicksilver> (with the structure coming from the traversable)
03:26:06 <luqui> quicksilver, not really sure what you're saying, but it sounds cool.
03:26:09 <dolio> That doesn't identify common structure, though. It just takes it from one or the other.
03:26:13 <quicksilver> yes
03:26:22 <quicksilver> but that's true of the list zip
03:26:30 <quicksilver> it arbitrarily takes the structure of the shorter list.
03:26:56 <quicksilver> luqui: Traversable t, Foldable f => t a -> f b -> t (a,b)
03:27:11 <quicksilver> without the ability to 'check for common structures at the type level'
03:27:20 <quicksilver> (e.g. list length, tree shape) you're a bit stuck.
03:27:47 <dolio> What do you put in the t if there aren't enough bs in the f?
03:28:30 <luqui> dolio, lol
03:28:54 <luqui> I love that we're in a field where that sentence is sensical
03:29:07 <dolio> :)
03:29:33 <quicksilver> dolio: I error out, IIRC
03:30:19 * EvilTerran concludes that he has no idea how to work Data.Generics.Twins.gzip :: GenericQ (GenericM Maybe) -> GenericQ (GenericM Maybe)
03:32:15 <ivanm> with System.Directory, what happens if it can't create the directory due to permission problems, etc.?
03:33:06 <quicksilver> ivanm: exception, I presume
03:33:26 <quicksilver> ivanm: yes, there is a list of exceptions it can throw, in the docs.
03:33:33 <ivanm> is there a "safe" way of doing so? i.e. something like FilePath -> IO Bool, where it returns True if it was successful?
03:33:50 <quicksilver> catch the exception ;)
03:33:56 <mib_4avzu3> Write a Haskell function countChange that calculates the number of different ways we can make change of n cents, given denominations of 1 cent, 2 cents, … , d cents ( i.e. if d=5, the denominations of coins available are 5 cents, 4 cents, 3 cents, 2 cents and 1 cent )
03:34:02 <ivanm> you can catch exceptions? :o
03:34:03 <besiria> what regex library should i use?
03:34:07 <quicksilver> in IO you can, yes.
03:34:09 <ivanm> for some reason, I thought you couldn't do that... :s
03:34:11 <mib_4avzu3> that's my ques, is thee anyone who can help me
03:34:13 <quicksilver> othetwise they'd be pretty useless.
03:34:14 <mib_4avzu3> with this
03:34:16 <mib_4avzu3> please
03:34:25 <ivanm> (the good old try-catch-finally blocks in Java... *shudder*)
03:34:30 <mib_4avzu3> fell asleep earlier
03:34:37 <ivanm> @hoogle catch
03:34:37 <lambdabot> package catch
03:34:37 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
03:34:37 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
03:34:40 <dolio> Hahaha.
03:35:32 <quicksilver> I note that exception-throwing code composes much better than Bool-returning code
03:35:47 <quicksilver> (although 'exception-throwing' could be Maybe/Error monad instead of IO exceptions)
03:35:55 <mib_4avzu3> ??
03:36:07 <quicksilver> mib_4avzu3: this isn't #homework-help
03:36:20 <quicksilver> mib_4avzu3: we'll be delighted to answer specific questions and help you with attempts that don't work.
03:37:10 <mib_4avzu3> well i don't seem too know how to make it pull out the possible combinations of cents
03:37:36 <luqui> dolio, the zip property:   fzip (funzip a) = a  where  funzip = fmap fst &&& fmap snd
03:37:44 <luqui> (taking fzip :: f a -> f b -> f (a,b))
03:38:06 <dolio> Oh, Hmm...
03:38:16 <quicksilver> I think you have a missing 'uncurry' luqui
03:38:24 <quicksilver> but the point you're making is clear enough :)
03:38:31 <dolio> Yeah, that's pretty good.
03:38:35 <luqui> quicksilver, you're right
03:38:39 <EvilTerran> mib_4avzu3, if i remember right, your function took the number of cents to make change for as its first parameter, and the highest denomination of coin as its second parameter
03:38:43 <EvilTerran> mib_4avzu3, is that right?
03:39:24 <dolio> That allows quicksilver's version to qualify, though, so I must oppose you. :)
03:39:25 <quicksilver> luqui's property is satisfied by my version
03:39:40 <Saizan> http://comonad.com/reader/2008/zipping-and-unzipping-functors/ <- oh, btw :)
03:39:43 <quicksilver> as long as your Traversable instance is compatible with your Foldable one.
03:39:50 <lambdabot> Title: The Comonad.Reader » Zipping and Unzipping Functors
03:39:54 <quicksilver> which should probably go without saying.
03:40:19 <luqui> Saizan, actually the follow-up article "cozipping" is the inspiration for above property
03:40:37 <EvilTerran> ...
03:40:40 <EvilTerran> i don't know why i bother
03:40:45 <EvilTerran> sometimes
03:40:53 <besiria> what is the diff between regex-pcre and regex-pcre-builtin packages:
03:41:50 <quicksilver> dolio: but do you think you can do any better, without embedding a whole lot more into the type system?
03:42:14 <dolio> No, certainly not.
03:42:33 * quicksilver nods
03:42:40 <quicksilver> in that case I'm happy with my version
03:43:00 <dolio> I'd just make a Zip class and handwave the 'that's a zip, that's not' qualifications.
03:43:09 <luqui> dolio, me too
03:43:12 <quicksilver> and will point people cheerfully to http://www.haskell.org/haskellwiki/Foldable_and_Traversable
03:43:14 <lambdabot> Title: Foldable and Traversable - HaskellWiki
03:43:24 <dolio> Or not. I'm not sure I've ever desired a generalized zip.
03:43:41 <luqui> we wanted one for perl 6 for some silly reason...
03:43:52 <luqui> ah yes, hyperoperators
03:44:20 <Saizan> dolio: you haven't worked enough with comonadic intepreters, then. (unsurprisingly :)
03:44:33 <quicksilver> although
03:44:39 <dolio> I guess not. :)
03:44:46 <quicksilver> fons-- # suggesting that using State instead of Supply is an 'advantage'
03:45:17 <dolio> What do you use those for? Dataflow languages?
03:45:17 <luqui> quicksilver, you mean Data.Supply?
03:45:31 <quicksilver> well I wrote my own mini-supply monad
03:45:47 <quicksilver> it's just a stream treated as a pop-only stack
03:46:07 <luqui> oh.  state with restricted operations
03:46:11 <quicksilver> indeed.
03:46:18 <luqui> yeah that's one I keep rewriting :-)
03:46:20 <quicksilver> But everything is just State+Cont with restricted operations.
03:46:27 <luqui> heh :-)
03:46:33 <quicksilver> for that matter, all types are Integer with restricted operations.
03:46:33 <Saizan> dolio: yeah
03:47:20 <luqui> quicksilver, actually....
03:48:09 <luqui> I think you're wrong there.  Obviously it's true from a strict "computational-power" perspective, but once you go back into Haskell, Integer is not expressive enough to capture laziness
03:48:13 <Saizan> quicksilver: i'm not a number! i'm a free ADT!
03:48:30 <quicksilver> luqui: well you'd need to embed a complete haskell interpreter, yes.
03:48:52 <quicksilver> luqui: without doing that I'm not absolutely sure what the universal structure is
03:48:57 <quicksilver> probably something like Tree Int?
03:49:17 <quicksilver> anyhow, the point is that the "that's just *foo* with restricted operations" is sometimes said as if it was a criticism.
03:49:23 <quicksilver> but it really shouldn't be; it should be a compliment.
03:49:27 * luqui didn't intend it that way
03:49:31 <quicksilver> Type systems are all about restricting operations.
03:49:35 <quicksilver> no, but fons apparently did.
03:49:35 <luqui> criticism I mean
03:49:44 <luqui> ah
03:50:03 <luqui> anyway Data.Supply is nicer than Supply anyway for stuff like unique identifiers
03:50:20 <luqui> I mean... sortof.  it's less deterministic, but it has nice parallelism properties
03:50:44 <luqui> heh "less deterministic"
03:50:46 <quicksilver> yeah, Data.Supply is somethign slightly different.
03:51:48 <luqui> so... not to pry... but any chance I can get that reactive from you.  sorry if I'm being a bother.
03:51:56 <quicksilver> heh
03:52:00 <quicksilver> that's not prying it's nagging :P
03:52:05 <luqui> er yeah
03:52:35 <quicksilver> sent.
03:52:42 <luqui> there is a company that wishes to depend upon it :-)    maybe you should change for it :-)
03:52:55 <luqui> muchas gracias
03:53:01 <luqui> *charge
03:53:32 <quicksilver> heh.
03:53:49 <quicksilver> It's still not deterministic for nearly-simultaneous events.
03:53:57 <quicksilver> I wouldn't personally recommend it over conal's impl.
03:54:02 <luqui> lol
03:54:06 <quicksilver> But you're welcome to pore over it and see what you can see.
03:54:10 <luqui> it works does it not?
03:54:14 <quicksilver> it works, yes.
03:54:18 <quicksilver> at least in my tests.
03:54:22 <luqui> then I would recommend it over conal's
03:54:30 <luqui> (although I do find his quite beautiful)
03:54:49 <luqui> it just has very subtle issues
03:54:56 <luqui> whereas yours is more direct
03:58:22 <hackage> Uploaded to hackage: AERN-Real 0.9.7.1
03:58:28 <luqui> You might be interested, quicksilver, actually.  I believe I am quite close to a beautiful and efficient frp which is quite different. It uses type-level times.
03:58:46 <luqui> but "closeness" is a hard thing to judge for this kind of thing
03:59:05 <mm_freak_> how do i define class derivation rules?
03:59:06 <quicksilver> luqui: I will certainly be interested.
03:59:11 <quicksilver> mm_freak_: (a) you don't.
03:59:19 <quicksilver> mm_freak_: (b) see Data.Derive, DrIFT, or TH.
03:59:30 <mm_freak_> hehe ok
03:59:38 <mm_freak_> i'll try not to do =)
03:59:50 <quicksilver> there is no standard way to express derivations
03:59:53 <quicksilver> but TH is capable of it, of course
03:59:55 <lilac> mm_freak_: (c) hack on GHC :)
04:00:02 <quicksilver> and Data.Derive and DrIFT are tools for it.
04:00:59 <Stinger_> http://www.explosm.net/comics/1415/
04:01:00 <lambdabot> Title: Comics - Explosm.net
04:01:01 <luqui> quicksilver, the essence is a monad: At t a, which represents a value of type a at time t, together with a type relation t :< t'. Behavior t a = forall t'. t :< t' -> At t' a
04:01:14 <Stinger_> aaand that was the wrong channel to post that, sorry
04:01:52 <quicksilver> luqui: interesting.
04:02:13 <luqui> which makes t' a region variable in Behavior, which you can use to enforce a monotonicity property
04:02:35 <luqui> (that the value of a bound behavior is only demanded in a monotone fashion), and that allowed a nice optimization
04:02:41 <luqui> I'll blog about it soon
04:03:08 <luqui> but I don't *have* it, yet, which is distressing.  still hard to implement just right...
04:03:23 <mm_freak_> luqui: that somehow sounds similar to uniqueness types
04:03:29 <papermachine> How many different FRP implementations are there now?
04:03:40 <luqui> papermachine, many many many....  most of them have problems
04:04:02 <luqui> mm_freak_, actually, support for linear types allows that same optimization ;-)
04:04:17 <luqui> mm_freak_, (linear types are similar to uniqueness types)
04:04:25 <mm_freak_> yeah…  i'd be happy to see those in haskell
04:04:44 <mm_freak_> that would turn a lot of monadic code into non-monadic code
04:05:04 * luqui has no problem with monads.
04:05:21 <mm_freak_> yeah, but i find it evil to use monads just to enforce destructive update
04:05:21 <luqui> I like the cleanliness of do-notation for a lot of things.
04:05:35 <luqui> mm_freak_, I find destructive update evil.
04:05:37 <mm_freak_> where otherwise declarative manner would be fine
04:05:41 <luqui> no matter what you use to enforce it
04:06:05 <luqui> or you mean destructive update as an optimization technique?
04:06:08 <mm_freak_> destructive update is often the way to go…  if you have a value, which you change into another and then never refer back again, you want destructive update for speed
04:06:13 <mm_freak_> yes
04:06:20 <luqui> okay I haven't any problem with that :-)
04:06:36 <luqui> but IORef I have a problem with, whether it is implemented in IO or with a uniqueness type
04:06:55 <luqui> not to say I don't use it :-)
04:07:02 <mm_freak_> and linear/uniqueness types are a means to declare types as such explicitly…  that would allow GHC to do quite insane optimizations =)
04:07:14 <luqui> I just don't use it anywhere but in the guts of a nice abstraction
04:07:24 <mm_freak_> IORef is not what i'm referring to, but rather things like IArray
04:07:27 <mm_freak_> uhm
04:07:29 <mm_freak_> MArray i mean
04:08:58 <luqui> mm_freak_, yeah.  As a purely personal opinion, I find monads nicer for non-combinatory things (i.e. where there's no function a -> a -> a on your type).
04:09:24 <luqui> and they are utterly horrible if you do have such a combinator
04:09:35 <mm_freak_> yeah
04:10:35 <luqui> hmm you just convinced me though
04:10:35 <mm_freak_> and such types would also allow one to describe highly imperative algorithms declaratively, like the sieve of eratosthenes, which i currently implement using STUArray
04:10:42 <kig> writing the equivalent of an eager readFile in asm sure makes one appreciate more convenient languages
04:11:08 <luqui> since you could use support for uniqueness types to prove that your monad instance satisfies uniqueness
04:11:38 <mm_freak_> i wonder if you could make uniqueness types without hacking on GHC
04:11:51 <dolio> Not having uniqueness typing essentially means you have to throw everyting in ST to get the optimization.
04:11:53 <luqui> mm_freak_, you mean using a type system hack?
04:12:07 <mm_freak_> yeah
04:12:30 <luqui> mm_freak_, after having thoroughly explored the idea when trying to get linear types (for aforementioned optimization), I will conject: no
04:12:53 <luqui> or perhaps yes with a *lot* of garbage overhead in the way
04:13:02 <mm_freak_> leaving the optimization aside, couldn't you disallow threading somehow?
04:13:25 <luqui> mm_freak_, yes there was one way
04:13:35 <luqui> using region variables and continuation passing style
04:13:41 <mm_freak_> how?  maybe a Unique monad, which is similar to Id?
04:13:45 <luqui> it was hell hard to work with
04:13:55 <luqui> I'll see if I kept that experiment
04:14:05 <luqui> I didn't get very far because CPS is such a bitch
04:14:15 <luqui> especially when combined with complicated types
04:14:35 <mm_freak_> yeah
04:14:36 <luqui> mm_freak_, you could make a monad, but then you wouldn't get the ability for combinators
04:15:50 <mm_freak_> true
04:16:06 <mm_freak_> i guess, a GHC hack is the best one could do
04:16:23 <luqui> yeah that would definitely be the way to go imo
04:16:25 <mm_freak_> this is probably the only virtue of Clean that's missing in haskell
04:16:29 <luqui> unfortunately....
04:16:42 <luqui> mm_freak_, doesn't clean have serialization?
04:16:55 <mm_freak_> serialization?
04:16:55 <dolio> Clean's dynamics are supposed to be better than what you have in GHC, too.
04:17:23 <luqui> mm_freak_, freeze/thaw
04:17:38 <mm_freak_> you don't need that in Clean, AFAIK
04:17:41 <luqui> maybe it doesn't, and dynamics is what I was thinking of
04:17:56 <luqui> mm_freak_, oh no not that kind of freeze thaw
04:18:01 <luqui> I mean writing a value to disk
04:18:05 <luqui> for example
04:18:13 <Deewiant> show/read?
04:18:16 <dolio> Pickling, marshalling, ...
04:18:19 <mm_freak_> Clean has no such explicit separation of pure and impure world like haskell
04:18:39 <luqui> mm_freak_, sure it does
04:18:57 <dolio> The impure world is the one where you pass RealWorld tokens manually.
04:19:03 <quicksilver> writing data to disk is easy; the question is whether or not you can write functions and thunks.
04:19:06 <quicksilver> (to disk)
04:19:16 <luqui> quicksilver, aye.
04:19:30 <mm_freak_> yeah…  impure operations in Clean are expressed in a more straightforward way…  no things like monads and stuff
04:19:50 <luqui> mm_freak_, depends on your definition of straightforward.
04:19:58 <quicksilver> I think it's up for discussion whether linear uniqueness typing is really more straightforward than monads
04:20:04 <mm_freak_> it just makes sure that you don't thread the world's state
04:20:05 <quicksilver> but it may *look* more straightforward.
04:20:12 <luqui> I find haskell to be just as straightforward, once you understand that IO is not a magic token and just an opaque functor like any other
04:20:32 <quicksilver> interestingly GHC's implementation of IO uses magic token passing.
04:20:37 <Deewiant> ?src IO
04:20:38 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
04:20:41 <quicksilver> which suggests that the two are not really that different.
04:20:49 <mm_freak_> quicksilver: they haven't invented a totally new concept of expressing computations, like haskell has…  in that way it's a bit more straightforward
04:20:57 <luqui> quicksilver, haha.  by magic token I meant token in the parsing sense
04:21:06 <mm_freak_> it's what you would expect when looking at the referential transparency problem for the first time
04:21:08 <luqui> i.e. IO is something you "mark" impure types with
04:21:08 <quicksilver> luqui: yeah, sorry, bad juxtaposition of phrases
04:21:18 <quicksilver> luqui: I was already composing my sentence before yours appeared
04:21:24 <luqui> haha :-)
04:21:25 <mmorrow> dolio: do you know any particulars about Clean's Dynamics?
04:21:31 <mm_freak_> let me add, i like haskell's approach much more
04:22:01 <dolio> mm_freak_: All Haskell has done is written combinators so you don't have to pass things around manually.
04:22:08 <luqui> once you get down to it, I don't think I would care
04:22:11 <mm_freak_> but Clean code optimizes better usually, because there are some type level quirks, which haskell doesn't feature
04:22:12 <dolio> Presumably, at least. I don't know what kind of sugar Clean has.
04:22:21 <luqui> so little of my programs are in IO these days, it doesn't matter either way :-)
04:22:57 <dolio> mmorrow: I know the Typeable like stuff in Clean is more integrated into the compiler, so I think it has less limitations than what has been done Data.Typeable and Data.Dynamic and such.
04:23:31 * luqui likes the explicit Typeable though.   it gives you free theorems
04:23:38 <dolio> I think you might be able to make a dynamic wrapper of a polymorphic value, for instance.
04:24:31 <quicksilver> is that really a fault with Typeable though?
04:24:38 <quicksilver> I thought that was more a fault with haskell
04:24:39 <mmorrow> dolio: hmm. it's on my list to re-look at the reimplem of Dynamic by hs-plugins to get around the Typeable constraint. It'd be great to drop that..
04:24:45 <quicksilver> that polymorphic values aren't truly first-class.
04:24:52 <mmorrow> hmm
04:25:18 <dolio> Perhaps.
04:25:25 <luqui> but in ghc, aren't they?
04:25:55 <mmorrow> is that the same as saying "once you put something in an existential box, you can't put it back into the typesystem" (or something)?
04:26:00 <mmorrow> like
04:26:00 * luqui 's ideal language is an extension of his coq
04:26:03 <quicksilver> in ghc's implementaiton, polymorphic values are truly first class, yes.
04:26:23 <quicksilver> but the syntax of haskell doesn't quite capture that
04:26:27 <mmorrow> newtype Box = forall a. Box a
04:26:29 <quicksilver> until you add higher rank types, at least.
04:26:41 <mapreduce> @hoogle (a -> b) -> (a -> Maybe b)
04:26:42 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:26:42 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
04:26:42 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
04:26:52 <quicksilver> mmorrow: have a look at http://www.haskell.org/pipermail/haskell-cafe/2008-May/042809.html
04:26:55 <lambdabot> Title: [Haskell-cafe] Data.Dynamic over the wire, http://tinyurl.com/5hdut4
04:26:56 <quicksilver> mmorrow: and especially replies to it.
04:27:14 <mmorrow> awesome, every time i forget about that, i get re-linked to it :)
04:27:22 <luqui> mapreduce, I can't fathom what you want that function to do
04:27:28 <chr1s> mapreduce: (.) Just
04:27:40 <luqui> other than that of course
04:27:47 <quicksilver> mmorrow: jhc's implementation of stuff is often a source of inspiration when you want to step outside the GHC box.
04:27:53 <chr1s> or would you rather have (a -> b) -> (Maybe a -> Maybe b), that's called fmap
04:28:00 <dolio> There's still no way to write things such that 'typeOf foo' yields a type rep of 'forall n. Num n => n', though.
04:28:01 <mmorrow> jhc is cool indeed
04:28:02 <mapreduce> I would not rather have that.
04:28:07 <mapreduce> I'm looking for a good name for that function.
04:28:13 <dolio> As far as I know.
04:28:24 <mmorrow> dolio: yeah, suckage (afaik)
04:28:26 <quicksilver> :t (Just .)
04:28:27 <lambdabot> forall b a. (a -> b) -> a -> Maybe b
04:28:32 <quicksilver> is as good a name as any
04:28:33 <quicksilver> IMO>
04:28:44 <luqui> mapreduce, "total"
04:28:55 <luqui> mapreduce, meaning it marks a function as total, and casts it into the type of partial functions
04:29:24 <luqui> but I would use (Just .) in most cases, because it's simple enough...
04:29:44 <luqui> the spelling (.) Just is more elusive for some reason
04:29:52 <zyb> .
04:30:21 <quicksilver> well sections are great, once you get used to it.
04:30:45 <quicksilver> they're extremely obfuscating until you're used to them though.
04:30:50 <quicksilver> tis very subjective!
04:31:15 <mapreduce> I didn't think functions that returned Maybes were partial functions.
04:31:23 <mapreduce> I thought, say, head, was a partial function.
04:31:28 <mapreduce> But I can see the equivalence.
04:31:55 <SamB_XP> mapreduce: functions that return Maybe can be used to model partial functions, see ;-)
04:31:56 <luqui> mapreduce, yeah the term is overloaded a bit.  the one you're taking about is more common.
04:32:00 <Saizan> well, you can see the Maybe monad as adding the possibility of failure
04:32:24 <quicksilver> Maybe is a way of making a partial function total :)
04:32:33 <luqui> quicksilver, :-)
04:32:52 <mm_freak_> in fact, Maybe is redundant
04:33:14 <mm_freak_> IMO lists are cleaner
04:33:20 <luqui> yeah, that's easy.   total f x = case f x of _|_ -> Nothing; x -> Just x.   no problem!
04:33:46 <mm_freak_> but Maybe is a good type to show the power of algebraic type system to beginners
04:34:09 <luqui> mm_freak_, lists are cleaner?  what do you mean?  That's like saying monads are cleaner than types.
04:34:15 <idnar> working with 0- and 1-item lists is cleaner?
04:34:28 <idnar> that sounds rather painful to me
04:34:42 <dolio> Don't use booleans, use ints. :)
04:34:58 <luqui> I agree with the former, dolio, but not the latter :-)
04:35:33 <mm_freak_> luqui: ?!
04:35:41 <EvilTerran> if the list syntax were overloaded so [x] = (return x) and [] = mzero
04:35:48 * luqui views Bool as a red herring of a design flaw
04:35:53 <quicksilver> EvilTerran: that might be quite interesting.
04:35:53 <SamB_XP> luqui: hmm?
04:36:01 <EvilTerran> Maybe would be as terse as lists to use
04:36:04 <quicksilver> EvilTerran: I thought that sometimes to make applicative more readable
04:36:10 <mm_freak_> (isqrt :: Integer -> Maybe Integer) could be written as (isqrt :: Integer -> [Integer]) as well
04:36:12 <quicksilver> EvilTerran: [x] instead of pure x
04:36:17 <mm_freak_> it would have the same monadic properties
04:36:54 <SamB_XP> mm_freak_: what if someone decided to make it return TWO values ?"
04:36:55 <EvilTerran> [x0 ... xN] = msum . map return $ x0:...:xN:[]
04:37:06 <EvilTerran> or something
04:37:10 <mm_freak_> SamB_XP: pattern-match against (x:xs) instead of [x]
04:37:19 <mm_freak_> SamB_XP: or be monadic and use (>>=)
04:37:23 <EvilTerran> would be necessary so other list-like constants would work
04:37:37 <luqui> now that design flaw may be necessary in Haskell.  But you never use Bool in dependent types: you return a property or its negation instead.  I try to apply that as much as I can to my Haskell programs without entering type hell
04:37:40 <EvilTerran> that'd be pretty handy, actually, for when you're using things like the Logic monad
04:37:52 <EvilTerran> or Omega
04:38:21 <dolio> So what is the appropriate type of filter?
04:38:29 <SamB_XP> luqui: I don't see the big deal
04:38:49 <mm_freak_> SamB_XP: for example: fourthRoot x = isqrt x >>= isqrt
04:38:51 <luqui> dolio, that would be a case where doing it correctly would firmly enter type hell
04:39:07 <SamB_XP> dolio: are you kidding?
04:39:11 <dolio> Doing what correctly?
04:39:19 <EvilTerran> luqui, can you give an example in a dependently-typed context?
04:39:20 <mm_freak_> SamB_XP: that's what you would do with Maybe, anyway…  and you'd additionally get the feature of allowing multiple fourth roots
04:39:20 <SamB_XP> filter isn't even provably productive in most cases
04:39:53 <dolio> SamB_XP: It's total.
04:40:09 <SamB_XP> dolio: what about infinite lists ?
04:40:15 <dolio> There are no infinite lists.
04:40:34 <Philippa_> luqui: not really, doing it correctly just needs a type for "evaluable predicate". A function yielding bool's as good as any other there
04:40:38 <EvilTerran> there could be infinite codata lists, but filter may only work on data lists
04:41:11 <luqui> filter : forall (f : a -> P) (xs : [a]) -> { xs' : [a] | all P xs' }
04:41:18 <luqui> er, modulo syntax errors :-)
04:42:10 <luqui> f : a -> P a that is
04:42:37 <chrisdone> how might I abstract this if/else crap so that “findM jbobau' lines” isn't repeated three times? http://hpaste.org/10783
04:43:04 <dolio> I think you mean: filter : {a : Set} (f : a -> Bool) -> [a] -> Sigma (xs : [a]) (all f xs)
04:43:32 <SamB_XP> I doubt it
04:43:35 <dolio> Plus some magic that all the stuff in xs come from the input [a].
04:43:47 <luqui> dolio, that would be the agda spelling.  hmm, you're right, bools are sufficient here.
04:46:34 <luqui> I should refine my statement then.  Thanks for showing me that I overgeneralized my rule of thumb.
04:47:10 <luqui> But a Bool can very often be refined to return more information.
04:48:08 <lunabot>  42
04:48:15 <dolio> Sure. A test followed by fetching something could be turned into a fetch of a Maybe, for instance.
04:48:28 <quicksilver> I refer you to the comment about initial objects.
04:48:58 <quicksilver> "follow James McKinna's observation
04:48:58 <quicksilver> (which give rise to views in Epigram): you don't need to
04:48:58 <quicksilver> produce elements of an *arbitrary* whatever-it-is when you
04:48:59 <quicksilver> can produce elements of the *initial* whatever-it-is."
04:49:05 * luqui thinks he may be mislearning design advice, because the only thing he has written for the last few months are implementations of frp libraries
04:49:16 <luqui> so I'm learning design rules that only apply to frp libraries :-)
04:53:27 <luqui> chrisdone, I have no idea what your code means
04:54:30 <quicksilver> chrisdone: using 'guard'
04:54:51 <dolio> Now, of course, maybe you have something more like: filter : {a : Set} {P : a -> True} (f : Decidable P) -> [a] -> Sigma (xs : [a]) (all P xs) ...
04:55:23 <Philippa_> quicksilver: and an ErrorT or similar where necessary and some kind of catch, yeah
04:55:27 <luqui> dolio, aye.  filter kind of missed the point though.
04:55:27 <dolio> And Decidable P = forall a -> Either (P a) (Not (P a))
04:55:51 <luqui> as an example  (it was a case my rule of thumb was fine with)
04:55:57 <dolio> But since filter only looks at the Left or the Right, it's essentially a Bool.
04:56:31 <quicksilver> Philippa_: MaybeT might be enough in this case.
04:56:44 <chrisdone> quicksilver: I was looking for MaybeT. so it actually exists
04:56:50 <luqui> I'm just barely getting into real-world dependent type programming
04:56:52 <quicksilver> Philippa_: or cheating and using IO's built-in exceptions might work too.
04:56:58 <quicksilver> chrisdone: it exists in your head, and my head
04:57:04 <quicksilver> but not in the standard lib :)
04:57:07 <chrisdone> oh, lame
04:57:09 <quicksilver> I think it's on hackage though.
04:57:14 <chrisdone> yay
04:57:19 <luqui> I think I would prefer to have filter : (a -> Bool) -> List a -> List a, and a separate prop_filter which verifies what it does
04:57:22 <Philippa_> but ErrorT does what you want and it's in the mtl
04:57:49 <luqui> but I don't know, since I have written a total of about 300 lines of DT code so far, so I have no idea what good practice is :-)
04:57:50 <idnar> luqui: I thought you were getting rid of booleans :P
04:58:09 <luqui> idnar, I revoked my rule of thumb after the above examples
04:58:20 <idnar> ah, okay
04:58:32 <idnar> I got lost about halfway through that conversation
04:58:46 <idnar> "filter : {a : Set} (f : a -> Bool) -> [a] -> Sigma (xs : [a]) (all f xs)" means nothing to me
04:58:49 * quicksilver hands idnar a warm fuzzy thing.
04:59:02 <idnar> nevermind "filter : {a : Set} {P : a -> True} (f : Decidable P) -> [a] -> Sigma (xs : [a]) (all P xs)"
04:59:06 <mmorrow> lunabot can do private messages now if anyone wants to mess around (if you r00t my puter, please don't delete my laptop contents :):):))
04:59:16 <luqui> idnar, it's all very cool stuff, but hardly relevant
04:59:53 <mmorrow> but i'll put a $20 bounty on my /etc/passwd ;)
05:00:39 <luqui> yay, bot hasking!
05:00:41 <mmorrow> eval :: String -> Dynamic
05:00:55 <mmorrow> eval has eval in it's environment as well
05:01:04 <mmorrow> so you can nest evals infinitely deep
05:01:09 <mmorrow> (fyi :))
05:01:22 <chrisdone> Philippa_: MaybeT is more suited though because I don't actually care about what the error is. it's not really an error in that sense
05:01:47 <mmorrow> , eval "fmap (*2) [0..4]"
05:01:47 <SamB_XP> mmorrow: why don't you just place a private key in a particular location, and award a prize for someone who uses it to encrypt the information regarding how to pay them ?
05:01:51 <lunabot>  <<[Integer]>>
05:02:11 <quicksilver> I'll raise mmorrow to $30 for his /etc/passed :P
05:02:14 <mmorrow> SamB_XP: now you're thinkin ;)
05:02:20 <mmorrow> quicksilver: heh
05:02:49 <Olathe> . let f = "eval \" ++ f in eval f
05:03:10 <mmorrow> in the extremely low chance (heh..err) someone gets it, i'll paypal you
05:03:14 <Olathe> No error message.
05:03:17 <Olathe> . let f = "eval \"" ++ f in eval f
05:03:23 <mmorrow> the . got changed to ,
05:03:24 <Olathe> , let f = "eval \"" ++ f in eval f
05:03:26 <Olathe> Ahh.
05:03:28 <lunabot>  luna: out of memory (requested 1048576 bytes)
05:04:09 <dolio> ] runST (unsafeIOToST (readFile "/etc/passwd"))
05:04:11 <lunabot>  luna: Not in scope: `runST'
05:04:11 <lunabot>  Not in scope: `unsafeIOToST'
05:04:13 <mmorrow> , maybe [] id (fromDynamic (eval "fmap (*2) [0..9]") :: Maybe [Integer])
05:04:14 <SamB_XP> I suppose the old array buffer overflow is out of the question ?
05:04:17 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
05:04:36 <mmorrow> SamB_XP: it's locked down tighter than something that's reallly tight!
05:05:01 <mmorrow> the evaluator is actually using that exact same eval function at the top level also...
05:06:20 <SamB_XP> well, we do have the power of unsafeCoerce at our fingertips, don't we ?
05:06:31 <mmorrow> , unsafeCoerce
05:06:32 <lunabot>  luna: Not in scope: `unsafeCoerce'
05:06:38 <mmorrow> , Unsafe.unsafeCoerce
05:06:39 <lunabot>  luna: Not in scope: `Unsafe.unsafeCoerce'
05:06:45 <SamB_XP> I said nothing about the NAME of unsafeCoerce
05:06:58 <mmorrow> heh, indeed you do, if you can conjure it ;)
05:07:29 <ivanm> with runInteractiveCommand, why should passing in the input be forked?
05:07:43 <quicksilver> ivanm: because. thats. how. unix. works.
05:07:44 <quicksilver> ;)
05:07:51 <ivanm> heh
05:08:03 <quicksilver> because if the forked program blocks on input, it will stop sending output
05:08:04 <ivanm> because I've seen code that doesn't fork input, but does fork output >_>
05:08:06 <quicksilver> and vice / versa
05:08:13 <quicksilver> oh, it doesn't matter which you fork
05:08:16 <quicksilver> whichever is more convenient
05:08:21 <ivanm> oh, as long as it's one of them?
05:08:22 <quicksilver> just as long as you decouple the two.
05:08:25 <ivanm> *nod*
05:08:40 <quicksilver> as long as the child process can't have output blocking input while the parent process has the vice-versa.
05:08:55 <ivanm> so if I want to get the output of the result and write it to a file, and the input is just show foo, it'd probably be easier/better to fork the input?
05:09:10 <quicksilver> which is acheived by decoupling in the parent, or by making assumptions about how the child behaves.
05:09:19 <quicksilver> yeah, for fixed static input forking the input makes most sense.
05:09:26 <quicksilver> don't forget in haskell that can be super-light-weight
05:09:33 <ivanm> *nod*
05:09:35 <quicksilver> forkIO (hPrint foo)
05:09:38 <chrisdone> , unsafeCallCthulhu
05:09:39 <lunabot>  luna: Not in scope: `unsafeCallCthulhu'
05:09:41 <quicksilver> forkIO (hPrint in foo)
05:09:42 <ivanm> @hoogle forkIO
05:09:43 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
05:09:44 <quicksilver> rather.
05:10:10 <SamB_XP> chrisdone: now, now -- mmorrow didn't place a bounty on his (in)sanity!
05:11:38 <ivanm> so if use waitForProcess, do I have to worry about when the fork finishes?
05:11:47 <mmorrow> , , toUTF8 (take 10 ['\8704'..])
05:11:48 <lunabot>  luna: parse error on input `toUTF8'
05:11:50 <mmorrow> , toUTF8 (take 10 ['\8704'..])
05:11:51 <lunabot>  ∀∁∂∃∄∅∆∇∈∉
05:11:56 <ivanm> and closing the in channel?
05:12:37 <SamB_XP> ∂∆∈
05:12:43 <chrisdone> λ_λ
05:12:44 <SamB_XP> only those work here :-P
05:12:55 <chrisdone> they all work here. yay ubuntu
05:13:18 <ilyak_> SamB_XP: You aren't right
05:13:23 <ivanm> all work here...
05:13:24 <SamB> all look horrid here except for ∅∆∈
05:13:34 <SamB> ... probably because they are all too tall and get clipped
05:13:36 <ilyak_> Every of those characters work, your font don't have some glyphs
05:13:37 <ivanm> chrisdone: it's to do with the fonts you choose, not the distro you use
05:13:51 <ilyak_> I see 6 characters and four boxes
05:14:00 <ilyak_> But then again on another font I'll see more
05:14:07 <SamB> ilyak_: those boxes are what I call "not working"
05:14:50 <ilyak_> SamB: Those boxes are due to your font
05:15:01 <SamB> ilyak_: MAYBE
05:15:01 <ilyak_> Not due to 'here', if here means IRC
05:15:03 <ivanm> quicksilver: and what about the error handle?
05:15:22 <SamB> by "here" I meant "in this client configuration"
05:15:44 <mmorrow> ivanm: these two have worked for me http://hpaste.org/10784
05:16:06 <ivanm> thanks mmorrow
05:16:26 <mmorrow> np
05:17:36 <ivanm> what's the difference between command and process? with process you pass the args in after you start running the command?
05:18:48 <ilyak_> SamB: Oh
05:18:52 <ilyak_> It's fine then, sorry
05:19:01 <mmorrow> you can do with command   runCmd "cat | head -100"  (unlines "asdf\njkl")
05:21:18 <mmorrow> but process doesn't give you a shell
05:21:18 <ivanm> ahhhh
05:21:18 <ivanm> I'm wanting to basically do: cmd < input > output
05:21:18 <ivanm> so I use the in handle for the input, then get the output from the out handle and then print that to file
05:21:18 <mmorrow> also, runCmd seems to complain about broken pipes, this'll stop the err msgs but is possibly hackish: runCmd "cat 2> /dev/null | head -100 2> /dev/null | tac"  (unlines "asdf\njkl")
05:22:03 <ivanm> heh
05:22:05 <mmorrow> exactly, you just talk to it over the handles
05:22:25 <mmorrow> and if you're not talking to it, it's sleeping
05:22:32 <ivanm> how should I code the file writing? openFile file WriteMode ?
05:22:53 <mmorrow> sounds good
05:23:14 <ivanm> oh, wait, it's an image file, so I'll be wanting openBinaryFile
05:23:35 <SamB_XP> ivanm: does that follow ?
05:23:53 <ivanm> well, I'm guessing that...
05:24:03 <ivanm> the output from dot is meant to be an image...
05:24:08 * SamB_XP reminds ivanm that image does not imply binary ;-P
05:24:09 <ivanm> "Note: if you will be working with files containing binary data, you'll want to be using openBinaryFile. " <-- from the haddock docs
05:24:13 <ivanm> SamB_XP: oh?
05:24:19 <ivanm> I thought it did :s
05:24:25 <SamB_XP> ivanm: a technicality, I suppose ...
05:24:28 <SamB_XP> but true none the less
05:24:42 <mmorrow> ivanm: i got squirt from mohws. it's super fast Handle to Handle http://hpaste.org/10784#a2
05:24:42 <ivanm> so I should just use openFile?
05:24:50 <SamB_XP> ivanm: no, don't mind me
05:25:00 <ivanm> SamB_XP: heh...
05:25:03 <SamB_XP> it probably IS binary
05:25:17 <SamB_XP> but it doesn't HAVE to be just because it's an image
05:25:18 <ivanm> mmorrow: what/who is mohws?
05:25:24 <ivanm> SamB_XP: hmmmm.....
05:25:31 <lilac> ivanm: for instance, ppm and svg aren't binary but are images
05:25:32 <mmorrow> http://code.haskell.org/mohws
05:25:33 <lambdabot> Title: Index of /mohws
05:25:37 <ivanm> lilac: *nod*
05:25:42 <SamB_XP> lilac: well, SOME ppm are text
05:25:46 <SamB_XP> some are binary
05:25:50 <ivanm> so is it safe to use openFile for binary data?
05:26:03 <lilac> SamB_XP: true :)
05:26:03 <SamB_XP> same with pbm, pgm, etc.
05:26:05 <mmorrow> if you just use ByteStrings it won't matter /and/ it'll be a lot faster
05:26:23 <ivanm> mmorrow: I wasn't planning on using ByteStrings... should I? :o
05:26:33 <SamB_XP> xpm is also text
05:26:41 <SamB_XP> C, even ;-P
05:26:41 <mmorrow> i probably would if you're read/writing images..
05:27:08 <mmorrow> err, if you're just going Handle-to-Handle though, that squirt function'll be perfect
05:27:13 <lilac> SamB_XP: don't forget ascii art ;-)
05:27:30 <ivanm> would bytestring still work if it isn't an image (e.g. dot -Tdot returns text)
05:27:32 <ivanm> ?
05:27:36 <mmorrow> yeah
05:27:43 <ivanm> *nod*
05:27:44 <mmorrow> it's just bytes
05:27:49 <SamB_XP> lilac: well, I'm aware of the existance of such, but I wasn't including that in the definition of image for the purpose of this conversation
05:27:54 <ivanm> but if I'm using that squirt, do I have to worry about bytestrings?
05:28:01 <SamB_XP> since I'm sure that isn't what was meant to start with ;-)
05:28:28 <mmorrow> no, it'll squirt it super fast for you, without having to worry about String vs. ByteString or whatever
05:28:28 <SamB_XP> and I don't think dot supports ASCII art output either
05:28:44 <ivanm> SamB_XP: ASCII art, no... dot format output, yes
05:28:53 <SamB_XP> I know
05:29:05 <SamB_XP> but dot format output doesn't count as an image really
05:29:09 <kig> guessing here, but i reckon the difference between openFile and openBinaryFile is only seen on windows, where openFile converts a plain \n to \r\n
05:29:17 <SamB_XP> kig: you'd be surprised
05:29:32 <EvilTerran> openFile may interpret the file as unicod
05:29:43 <EvilTerran> e. it's up to the implementation
05:29:58 <EvilTerran> @quote pcrs
05:29:58 <lambdabot> pcrs says: Premature carriage ret
05:30:05 <dolio> In GHC 6.10 it'll use the current locale.
05:33:30 <ivanm> if I forkIO printing to to the input handle, do I have to worry about closing it still?
05:33:57 <mmorrow> here's a runWithInput with all kinds of forking and such http://hpaste.org/10784#a3
05:34:15 <ivanm> Gah! ;-)
05:34:17 <mmorrow> (and it let's you specify the input as a (Handle -> IO ())
05:34:30 <mmorrow> so you can use String or ByteStrings or whatever
05:35:09 <mmorrow> and use foldM for pipes (i've wanted to do this, but haven't yet)
05:35:20 <ivanm> this is getting even more confusing! :p
05:36:37 <ivanm> ummm..... so if I squirt, should I just use openFile and not worry about being binary or not?
05:37:27 <mmorrow> i don't think you'll have to worry about if it's binary or not (i think)
05:38:34 <Baughn> Haddock fails to build, citing my lack of profiling libraries for ghc 6.8.3; is this reasonable? (Actually, let me paste the error)
05:38:58 <ivanm> hmmmm.... the only thing with squirt is, there's no way of telling if it transferred the data over fully or not, or if it threw an exception...
05:39:00 <Baughn> http://hpaste.org/10785 <-- Error.
05:39:21 <Baughn> Am I running into a hackage package designed for 6.10, or what?
05:40:21 <mightybyte> Is there a Haskell library that allows one to build cross-platform GUIs?
05:40:30 <ivanm> mightybyte: gtk2hs?
05:40:32 <Baughn> mightybyte: Gtk2hs?
05:40:42 <mightybyte> Ok, thanks.
05:40:45 <ivanm> there's also qthaskell, but I don't think it's finished yet...
05:41:20 <mightybyte> I was looking in the standard libraries, I guess I should have been in hackage.
05:42:02 <ivanm> mmorrow: wityrtInput, what are the Maybe handles for?
05:42:09 <mightybyte> Although I don't even see gtk2hs in hackage.
05:42:12 <mmorrow> ivanm: so this'll get a png from dot: http://hpaste.org/10784#a7
05:42:26 <dmwit> mightybyte: I don't think it's on hackage.
05:42:30 <Baughn> mightybyte: gtk2hs is legacy. It has its own site; google.
05:42:35 <dmwit> mightybyte: It doesn't use Cabal for its build system.
05:42:36 <mmorrow> ivanm: if you don't want any {err,out}put, just pass Nothing
05:42:36 <mightybyte> Heh
05:42:44 <dmwit> (yet)
05:42:50 <mightybyte> Ok
05:42:57 <EvilTerran> Baughn, "legacy"?
05:43:04 <ivanm> *nod*
05:43:08 <Baughn> EvilTerran: "Pre-Baughn cCode"
05:43:09 <ivanm> EvilTerran: before cabal
05:43:11 <EvilTerran> ah
05:43:46 <ivanm> dmwit: yeah, blame dcoutts... with his gtk2hs hat, he blames his c2hs hat for not playing nicely with his cabalhat
05:44:00 <ivanm> ;-)
05:44:20 <dmwit> heh
05:44:59 <dmwit> ?remember ivanm yeah, blame dcoutts... with his gtk2hs hat, he blames his c2hs hat for not playing nicely with his cabalhat
05:45:00 <lambdabot> I will never forget.
05:45:03 <dmwit> Liar!
05:45:17 <ivanm> well, there should be a space between "cabal" and "hat"...
05:45:33 <dmwit> ?forget ivanm yeah, blame dcoutts... with his gtk2hs hat, he blames his c2hs hat for not playing nicely with his cabalhat
05:45:34 <lambdabot> Done.
05:45:40 <dmwit> ?remember ivanm yeah, blame dcoutts... with his gtk2hs hat, he blames his c2hs hat for not playing nicely with his cabal hat
05:45:40 <lambdabot> Done.
05:45:45 <ivanm> :D
05:45:49 <mauke> tell preflex, it really won't forget :-)
05:46:02 <ivanm> mauke: it just disappears for long periods of time...
05:46:05 <dmwit> preflex should learn to accept ?remember, then...
05:46:18 <mauke> ivanm: yeah, I don't know how that happened
05:46:32 <mauke> recv threw an exception and it died
05:46:51 <ivanm> mmorrow: what's the purpose of the first catch? to check if that command actually exists?
05:47:02 <ivanm> mauke: sure, blame someone else...
05:47:03 <mauke> maybe I'll just add a loop to restart it if it dies
05:47:40 <ivanm> yes, because that worked _so well_ for lambdabot :p
05:48:05 <mauke> oh, and it only happened on freenode
05:48:12 <mauke> the efnet instance was still alive
05:48:38 <mmorrow> ivanm: the catch in ghci? or in the function? the one in ghci is probably unneeded, but the finally is nice
05:49:06 <mauke> anyway, the good news is that preflex Does Not Lose State
05:49:38 <ivanm> in the function
05:52:18 <masklinn> Is there any functional language out there with a *full* IEEE754 support?
05:52:40 <ivanm> mmorrow: and why are you using MVars? so you can fork it and still get the results?
05:53:14 <dmwit> masklinn: I'm not sure; what's missing, in your opinion?
05:53:45 <ivanm> dmwit: a value for Infinity :p
05:53:51 <dmwit> > 1/0
05:53:53 <lambdabot>   Infinity
05:54:04 <ivanm> no, that's a textual description!
05:54:09 <ivanm> I want the full printed value! :p
05:54:17 <dmwit> > isInfinite (1/0)
05:54:18 <lambdabot>   True
05:54:25 <dmwit> ivanm: heh
05:54:38 <masklinn> dmwit, I don't know, a friend asked me and a cursory search gave me e.g. a haskell-cafe thread saying that "Haskell does not allow you to change rounding mode, NaN signallng mode, etc.
05:54:39 <dmwit> > decodeFloat (1/0) -- the full printed value
05:54:39 <masklinn> "
05:54:40 <lambdabot>   (4503599627370496,972)
05:54:54 <masklinn> there's also http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg06108.html
05:54:55 <lambdabot> Title: Re: rounding in haskell
05:54:58 <ivanm> heh
05:55:11 <ivanm> if I use withFile, is there any way of getting any errors out?
05:55:26 <ivanm> use something like try or catch?
05:56:05 <masklinn> dmwit: and OCaml doesn't seem to support full 754 either, so I was wondering if *any* functional language did.
05:57:38 <dmwit> masklinn: I think you may have misunderstood that post.
05:57:52 <dmwit> That post at no point claims Haskell does 754 wrong.
05:58:20 <quicksilver> haskell does 754 fine, as far as I know
05:58:22 <hackage> Uploaded to hackage: AERN-RnToRm 0.4.1
05:58:27 <quicksilver> but it doesn't expose all the functionality of 754
05:58:29 <masklinn> where did i say that haskell did 754 wrong?
05:58:53 <masklinn> please go back to my initial question: I asked if any functional language had (exposed) full IEEE754 support
05:59:09 <quicksilver> haskell certainly doesn't expose it all.
05:59:15 <quicksilver> so on that criterion is fails.
06:00:09 <masklinn> well that's what I'd gathered from my searches, but i was wondering if 1. I'd missed things, and 2. if any other functional language had such upport as well as 3. if maybe there was a nonstandard haskell library implementing full IEEE754 support
06:00:57 <dolio> What kind of stuff is missing? I've never looked very closely at floating point stuff.
06:01:18 <dolio> Oh, I guess you answered that.
06:02:07 <lilac> masklinn: full IEEE754 support would need to be stateful, so asking a pure functional language to support it is asking for difficulties
06:02:23 <lilac> that said, an IEEE754 monad might be possible.
06:02:42 <lilac> but you presumably wouldn't be able to do hardware floating point outside the monad
06:02:52 <masklinn> lilac, oh would it? (as i said it's a question a friend asked me, since I often roam in functional lands/sites/blogs/whatever, but I don't know much of 754)
06:03:08 <masklinn> lilac: why does full IEEE754 require statefulness?
06:03:28 <masklinn> stuff like changing the rounding mode?
06:03:34 <quicksilver> masklinn: for exaactly the reasons you gave :)
06:03:43 <quicksilver> although I'm not sure if it's true.
06:03:47 <quicksilver> you could have different types
06:03:54 <quicksilver> DoubleWithThisRounding
06:03:56 <quicksilver> DoubleWithThatRounding
06:04:06 <quicksilver> DoubleWithNanAsAValue
06:04:12 <quicksilver> DoubleWithNanAsAnException
06:04:35 <quicksilver> ugly names aside, that's probably more elegant than making state changes explicit.
06:06:00 <ivanm> mmorrow: what do you think of this? http://hpaste.org/10786
06:06:09 <ivanm> (the runGraphviz function)
06:06:11 <masklinn> quicksilver: wouldn't it be possible to handle that with parameterized type extensions thingies?
06:06:32 <quicksilver> masklinn: yup.
06:06:38 <quicksilver> masklinn: more than one way to encode it.
06:06:46 <dmwit> quicksilver: Hmm, that seems like it might be inefficient; the implementations would have to explicitly change the 754 mode before *every* calculation, wouldn't they?
06:06:54 <ivanm> seems to work here... passing invalid params returns False...
06:06:54 <dmwit> i.e. they couldn't assume the processor was in the right mode...
06:07:21 <ivanm> hmmmm.... not quite, if the output of the command fails then the file still exists...
06:08:02 <quicksilver> dmwit: no, the compiler ought to be able to propagate information about which mode it was in
06:08:16 <dmwit> quicksilver: That requires compiler collusion. ;-)
06:08:22 <quicksilver> yes.
06:08:25 <quicksilver> very much so.
06:08:34 <dmwit> Okay, then I'm with you.
06:08:59 <quicksilver> well something has to generate the iee754 opcodes :)
06:09:04 <ivanm> mmorrow: I take it back... I managed to break the ghci pipe! :o
06:09:05 <quicksilver> and that something isn't haskell user code.
06:09:13 <dmwit> Harpy ;-)
06:09:13 <quicksilver> so I assumed it was intended to be solved in the compiler
06:09:16 <weakish> I'm learning haskell via http://en.wikibooks.org/wiki/Haskell, just wondering where can I get answers to the exercises?
06:09:17 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
06:09:37 <ivanm> ahhh, must be my deletion command...
06:10:16 <lilac> quicksilver: that'd require the compiler to know the order in which floating-point calculations were forced. sounds somewhat hard :)
06:11:03 <mauke> heh, just use a different core for each mode
06:11:08 <lilac> hehe
06:11:17 <dmwit> lilac: Nah, the run-time could track the current mode.
06:11:19 <quicksilver> lilac: I don't think so. The compiler knows that by definition.
06:11:24 <quicksilver> the compiler writes the code.
06:11:42 <lilac> quicksilver: the compiler doesn't know the order in which values get forced
06:11:58 <lilac> (since that can change at runtime)
06:12:50 <lilac> dmwit: the run-time could track the current mode, but would that be any faster than setting the mode at the start of each batch of computations?
06:13:04 <lilac> either way it seems pretty horrible
06:13:10 <ivanm> http://hpaste.org/10786 <-- can people see what's wrong with my runGraphviz function here?
06:13:24 <ivanm> at first it tested OK, but now it doesn't (this is in ghci) :s
06:13:39 <lilac> on a more worrying note, you can already change the rounding mode in IO via FFI, which kinda violates purity in a pretty brutal way :-(
06:13:54 <ivanm> the problem occurs when I pass an invalid parameter (the String argument) to graphviz :s
06:14:03 <dmwit> lilac: If it's in IO, it doesn't break purity. ;-)
06:14:15 <dmwit> (I know.  You're right.  It's just a joke.)
06:14:15 <ivanm> if I run it once, it works... if I run it twice, it doesn't
06:15:29 <ivanm> how does one debug IO? :s
06:15:53 <lilac> dmwit: since you can write to arbitrary memory locations with FFI, purity is lost anyway.
06:16:00 <ivanm> how does one add breakpoints?
06:16:00 * lilac hadn't realised how nasty the IO monad really is ;-)
06:16:40 <quicksilver> lilac: quite often the compiler infers strictness on FP types
06:16:49 <quicksilver> lilac: because they are strict types and are used with strict operators.
06:17:02 <quicksilver> lilac: in those cases, the compiler generates code which it does know the sequence of.
06:18:19 <lilac> quicksilver: sure, in those cases that's fine. but pretty much whenever the compiler creates a thunk containing floating-point operations, you'd have to set the rounding mode too.
06:18:59 <quicksilver> lilac: well you'd annotate the thunk with the needed mode and change if you ahd to, yes.
06:19:51 <lilac> sure.
06:20:25 <quicksilver> and propogate those marks up as far as you could
06:20:32 <quicksilver> and avoid un-necessary mode changes
06:20:33 <quicksilver> etc.
06:20:37 <quicksilver> it's a tractable problem.
06:20:40 <quicksilver> it might be a pain, sure.
06:22:25 <lilac> since you can call fesetround from FFI anyway, i'm not sure whether it'd be worth the effort, really.
06:22:38 <quicksilver> me neither.
06:22:49 <quicksilver> I've never worked in a field that cared about FP rounding modes.
06:22:56 <quicksilver> but obviously some people do.
06:23:01 * lilac works in a field which cares about it
06:23:05 <mmorrow> ivanm: awesome. graphviz is great. how does it work?
06:23:14 <Baughn> lilac: What sort of field is that?
06:23:18 <ivanm> my function? poorly :s
06:23:26 <ivanm> if the second arg is invalid, it crashes :s
06:23:49 <mmorrow> second arg to which function?
06:24:19 <ivanm> runGraphviz
06:24:27 <lilac> Baughn: we want to get the same results on x86 and sparc (otherwise some of our unit tests fail). which means we want to turn off the 80-bit precision mode on doubles ;-)
06:24:43 <ivanm> I think I'm missing an exception catching or something...
06:24:50 <ivanm> maybe I need to try the origing runCommand?
06:24:56 <Baughn> lilac: So it's just for unit tests? Well, okay..
06:25:20 <Baughn> Though I'd be tempted to round off the answers to "good enough" precision
06:25:47 <lilac> Baughn: by hand? in each of our million lines of code? :-)
06:26:23 <quicksilver> lilac: that's not FP rounding modes, though.
06:26:25 <lilac> our software is quite chaotic -- a difference in the 65th bit can make a large difference to the final result ;-/
06:26:26 <mmorrow> ivanm: heh. maybe just check it yourself? if you just do dot -Tinvalid it'll give you a list of supported output formats
06:26:29 <lilac> quicksilver: true.
06:26:30 <quicksilver> lilac: that's turning off large doubles.
06:26:37 <mmorrow> (or dot -Twhatevererere)
06:26:57 <quicksilver> I thouhgt 80-bit doubles were off by default in ghc/gcc these days
06:26:59 <ivanm> yeah...
06:27:02 <quicksilver> unless you asked for them explicitly.
06:27:07 <ivanm> maybe I should provide an enumeration of possible formats?
06:27:16 <mmorrow> sounds nice
06:27:20 <lilac> quicksilver: not in gcc last time i checked.
06:27:47 <Baughn> quicksilver: No, you still have to pass -fexcess-precision
06:27:56 <Baughn> Wait. -ffloat-store.
06:28:09 <quicksilver> -fexcess-precision turns them on, not off, surely?
06:28:21 <Baughn> -fexcess-precision should turn it on, if it existed. ;)
06:28:32 <Baughn> The problem is that -ffloat-store makes things noticably slower
06:28:50 <Baughn> Oh, but I think you get the same effect by using -fpmath=sse, which may be on by default on some setups
06:29:17 * quicksilver nods
06:29:55 <ivanm> mmorrow: dammit, it still won't work :s
06:30:09 <Baughn> @instances-importing Control.Arrow Arrow
06:30:10 <lambdabot> (->), Kleisli m
06:30:19 <ivanm> and I'd prefer not to provide an enumeration, in case the possible outputs change (or are different from in diferent versions)
06:31:05 <dolio> -fexcess-precision is real.
06:32:46 <Baughn> Sure? Google came up blank
06:33:01 <dolio> Well, ghc didn't complain when I passed it.
06:33:08 <dolio> I know I've heard it before, too.
06:33:20 <ivanm> mmorrow: can you see anything obviously wrong with that function?
06:33:57 <Baughn> dolio: Oh, I see. GHC-specific -ffloat-store-suppressing flag?
06:34:22 <dolio> What's -ffloat-store do? The opposite?
06:34:34 <quicksilver> forces floats into memory after every op
06:34:44 <quicksilver> to chomp them from 80bit to 64 or 32
06:34:49 <lilac> not every op, actually :(
06:34:49 <quicksilver> I think?
06:35:19 <dolio> In any case, yes, I think -fexcess-precision keeps them in registers.
06:35:24 <Baughn> The funny thing is, SSE2 is *already* 64-bit, so -ffloat-store should (I believe) be a no-op
06:35:34 <Baughn> (As is mmx and sse)
06:36:11 <Baughn> ..well, except that it still causes them to be stored back, presumably for hysterical raisins. Or I could be entirely wrong.
06:36:37 <quicksilver> well MMX/SSE are 32 bit, IIRC.
06:36:49 <Baughn> Hm. So they are.
06:36:50 <quicksilver> SSE2 supports variable sizes.
06:36:57 <Baughn> Oh well; at least sse2 supports doubles
06:37:00 <quicksilver> yup.
06:37:06 <quicksilver> SSE was 4x32
06:37:14 <quicksilver> SSE2 lets you use those 128 bits in other ways
06:37:17 <quicksilver> including 64x2
06:37:21 <quicksilver> but not 128x1
06:37:27 <quicksilver> I can't remember what the other options are.
06:37:38 <Baughn> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2007-February/007348.html <-- It's just, this thing seems to suggest that ghc still passes -ffloat-store even when using sse2
06:37:39 <lambdabot> Title: [GHC] #1138: The -fexcess-precision flag is ignored if supplied on the command l ..., http://tinyurl.com/5yfw4w
06:37:42 <quicksilver> SSE was basically for opengl.
06:37:57 <quicksilver> although not officially.
06:39:08 <quicksilver> but opengl is all about 4x32 bit quantities.
06:42:56 <jmg> hi
06:43:26 <ivanm> what does it mean if I get a "Process haskell broken pipe" error?
06:43:55 <daf> ivanm: your Haskell process is writing to a pipe that's been closed on the other end, I imagine
06:44:23 <mmorrow> ivanm: this seems to work http://hpaste.org/10786#a1
06:44:50 <mmorrow> (had to comment out stuff since i didn't have those imports)
06:45:25 <ivanm> mmorrow: yeah, I was just trying to avoid including your whole runWith functions :s
06:46:13 <mmorrow> yeah, it's nice to have a function which wraps everything nicely so you don't have to worry about flushing handle/random misc
06:46:55 <ivanm> also because I don't understand your code :p
06:47:35 <ArthurClemens> I have been trying to parse an actionscript file (java syntax) with javadoc annotations, using Parsec. Either it is not trivial, or I just don't understand how. Does anyone have experience with this?
06:49:26 <mmorrow> ivanm: all it pretty much does is  (1) it needs to write/read something (2) newEmptyMVar (3) forkIO (4) the forked proc writes () to that mvar when it's done (5) the main thread that was sleeping on that mvar wakes up when the mvar fills up. repeat..
06:49:48 <mmorrow> ok, i gotta run, good luck
06:49:53 <ivanm> heh, thanks
06:50:36 <dblazakis> ArthurClemens: are you trying to write an actionscript parser?  i think Parsec has some ready made lexers, but you'll have to write the parser yourself
06:50:58 <ArthurClemens> it is for generating documentation
06:51:30 <dblazakis> ArthurClemens: so, you want to parse just the javadoc?
06:51:52 <ArthurClemens> well, they belong to class members, so I need to parse them too
06:52:14 <ArthurClemens> I am used to regex, so this is hard for me
06:52:18 <mib_t5hrat> guys i tried to work out the question this is what i got
06:52:26 <mib_t5hrat> Write a Haskell function countChange that calculates the number of different
06:53:26 <dblazakis> ArthurClemens: how far have you gotten? it is fairly time consuming writing a parser for a "real" language
06:53:32 <EvilTerran> the number of different ... ?
06:53:58 <ArthurClemens> I am starting
06:54:04 <quicksilver> actually it's not that time consuming writing the parser, when you'r used to it
06:54:05 <mib_t5hrat> ways we can make change of n cents, given denominations of 1 cent, 2 cents,
06:54:15 <quicksilver> but you need to design an AST for your language
06:54:20 <quicksilver> (or the fragment you're trying to parse)
06:54:23 <ArthurClemens> AST?
06:54:24 <quicksilver> and that, IME, is that harder bit.
06:54:31 <quicksilver> abstract syntax tree
06:54:37 <quicksilver> a data structure which stores the parsed file.
06:55:20 <mib_hyumkc> Write a Haskell function countChange that calculates the number of different ways we can make change of n cents, given denominations of 1 cent, 2 cents, … , d cents ( i.e. if d=5, the denominations of coins available are 5 cents, 4 cents, 3 cents, 2 cents and 1 cent )
06:55:22 <ski> @let named a f = loop a where loop a = f a loop
06:55:23 <lambdabot>  Defined.
06:55:26 <ski> > named 5 $ \n factorial -> if n == 0 then 1 else n * factorial (n-1)
06:55:28 <lambdabot>   120
06:55:33 <ski> @type named
06:55:34 <lambdabot> forall t1 t. t1 -> (t1 -> (t1 -> t) -> t) -> t
06:55:36 <mib_hyumkc> http://mibbit.com/pb/l7UHHU
06:55:37 <lambdabot> Title: Mibbit: PasteBin
06:55:42 <dblazakis> quicksilver: writing a parser is fairly time consuming for a full language, cause most have warts, but yeah designing a servicable AST is, i agree, harder
06:55:48 <ski> @hoogle t1 -> (t1 -> (t1 -> t) -> t) -> t
06:55:48 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
06:56:10 <mib_hyumkc> that's the code i have so far, i think i am on the wrong track
06:56:28 <ski> could the above variant of `fix' be useful enough to warrant a standard name ?
06:56:33 <quicksilver> dblazakis: using a decent parser combinator, writing the parser is just writing down the grammar
06:56:41 <quicksilver> quantifier: modulo, perhaps, left recursion.
06:56:50 <quicksilver> ski: is it mfix for cont, or something like that?
06:57:04 <earthy> quicksilver: nope, good combinators can also deal with left recursion.
06:57:14 <quicksilver> earthy: indeed, but I only said 'decent' ;)
06:57:23 <ski> quicksilver : it's just an instance of plain `fix', with some arguments swapped
06:57:29 <ArthurClemens> ah, a data structure. I didn't know the abbreviation.
06:57:35 <earthy> (the resulting parsers may not necessarily be efficient... or give nice error messages...)
06:58:04 <ski> > fix (\factorial n -> if n == 0 then 1 else n * factorial (n-1)) 5  -- this is the same, basically
06:58:05 <lambdabot>   120
06:58:22 <hackage> Uploaded to hackage: mmtl 0.1
06:58:34 <ski> (but using the other argument order, we can get away with using `... $ \ .. -> ...'
06:58:36 <dblazakis> quicksilver: well, some language have some ugly context sensitve stuff to deal with
06:58:39 <ski> )
06:58:42 <mib_hyumkc> i was thinking of using list comprehension to generate the numbers
06:58:50 <ivanm> @ask mmorrow what purpose do the maybe (return()) ... lines serve?
06:58:51 <lambdabot> Consider it noted.
07:00:05 <mib_hyumkc> any help??
07:00:42 <dblazakis> quicksilver: parsing ECMAsript is ugly if you do ti right becasue of the optionaly semicolon thing, parsing C++ is ugly -- and those are two of the most used languages
07:01:06 <ski> (i just thought of it because of in <http://hpaste.org/10786#a1> .. `squirt' ought to use `forever' instead of the ugly `do ...; let loop = ...; loop' .. but in more general cases, one needs a parameter/accumulator/state .. so this is similar to "named `let'" in Scheme)
07:02:33 <ski> (quicksilver : however, there might be something interesting wrt `Cont' here .. hm)
07:03:10 <ivanm> hmmmmm.... is there any way I can try and track down which handles have broken pipes?
07:04:21 <Baughn> @djinn ((a -> b -> m a) -> a  -> [b] -> m a) -> (a -> m a) -> a -> m ()
07:04:22 <lambdabot> Error: Undefined type []
07:04:35 * ski is a fan of `done = return ()' ..
07:04:39 <Baughn> @djinn ((a -> b -> m a) -> a  -> x b -> m a) -> (a -> m a) -> a -> m ()
07:04:40 <lambdabot> -- f cannot be realized.
07:04:41 <quicksilver> ivanm: handle SIGPIPE
07:04:44 <quicksilver> ivanm: probably ignore it.
07:04:51 <ivanm> hmmm?
07:05:05 <quicksilver> that's how you stop a broken pipe killing your process
07:05:08 <ivanm> ghci keeps crashing because of broken pipes, and I want to work out where/why
07:05:13 <ivanm> so I can fix that up
07:05:43 <ski> Baughn : what yer for ?
07:06:05 <Baughn> ski: Trying to fold, spindle and mutilate foldM into what you wanted
07:06:12 <Baughn> ski: Without any actual effort on my part
07:06:34 <Baughn> Well, it's basically iterateM, isn't it?
07:07:20 <ski> Baughn : well, `named' is not monadic *per*se* (unless there's something with `Cont o' hiding)
07:07:32 <ski> @type iterateM
07:07:33 <lambdabot> Not in scope: `iterateM'
07:07:46 <mib_hyumkc> any help
07:07:56 <mib_hyumkc> Write a Haskell function countChange that calculates the number of different ways we can make change of n cents, given denominations of 1 cent, 2 cents, … , d cents ( i.e. if d=5, the denominations of coins available are 5 cents, 4 cents, 3 cents, 2 cents and 1 cent )
07:08:05 <quicksilver> ivanm: you try to read from a handle which is closed.
07:08:06 <ivanm> quicksilver: handle SIGPIPE doesn't do anything anyway...
07:08:11 <quicksilver> ivanm: or write to a handle which is close.d
07:08:18 <ivanm> quicksilver: yes, but I'm trying to work out which handle is closed
07:08:31 <mib_hyumkc> http://mibbit.com/pb/EbUeQv
07:08:33 <lambdabot> Title: Mibbit: PasteBin
07:10:25 <ski> Baughn : `(a -> m a) -> a -> m ()' would just iterate along the state .. i wanted to get a hold of the iteration function, so i can decide for myself when/if to iterate on with a state (possibly several times)
07:13:07 <ski> > named (Node 0 [Node 1 [Node 2 [],Node 3 []],Node 4 [Node 5 []]]) $ \(Node a ts) flatten -> a : concatMap flatten ts
07:13:08 <lambdabot>   [0,1,2,3,4,5]
07:13:25 <dolio> @type flip $ fix . flip
07:13:26 <lambdabot> forall a c. a -> (a -> (a -> c) -> c) -> c
07:13:44 <ski> *nod*
07:13:53 <ivanm> @ask mmorrow which license are you willing to distribute runWIthInput under?
07:13:54 <lambdabot> Consider it noted.
07:16:02 <ivanm> @tell mmorrow actually, using an invalid output type crashes your code as well >_>
07:16:02 <lambdabot> Consider it noted.
07:16:55 <ski> > let reverse xs = named (xs,[]) $ \(xs,rev) loop -> case xs of [] -> rev; x:xs -> loop (xs,x:rev)  in  reverse [0,1,2,3]
07:16:59 <ski> et.c.
07:17:05 <lambdabot>   [3,2,1,0]
07:17:58 <dolio> > let rev xs = (flip $ fix . flip) (xs,[]) $ \(xs,rev) loop -> case xs of [] -> rev ; x:xs -> loop (xs,x:rev) in rev [0,1,2,3]
07:17:59 <lambdabot>   [3,2,1,0]
07:18:52 <dolio> @pl \f a -> let loop b = f b loop in loop a
07:18:52 <lambdabot> fix . flip
07:19:03 <dolio> @pl \a f -> let loop b = f b loop in loop a
07:19:03 <lambdabot> flip (fix . flip)
07:19:04 <lilac> mib_hyumkc: what counts as a 'different way'? is [1,1,1,3] different from [3,1,1,1]?
07:19:41 <ski> (it would of course be nice if one could avoid tupling ..)
07:19:45 <Deewiant> :t flip (fix . flip)
07:19:46 <lambdabot> forall a c. a -> (a -> (a -> c) -> c) -> c
07:20:48 <lilac> @djinn a -> (a -> (a -> c) -> c) -> c
07:20:48 <lambdabot> -- f cannot be realized.
07:20:54 <lilac> thought not :)
07:22:23 <Japsu> > 9.93 * 33
07:22:23 <ski> > let reverse xs = (\foo -> fix foo xs []) $ \loop xs rev -> case xs of [] -> rev; x:xs -> loop xs (x:rev)  in  reverse [0,1,2,3]
07:22:25 <lambdabot>   327.69
07:22:25 <lambdabot>   [3,2,1,0]
07:23:09 <ski> (possibly that is a more readable idiom than using `flip (fix . flip)' ..)
07:24:45 * ski wonders whether one could come up with some nice syntax for "named `let'"s, "compatible" with pattern-matching ..
07:34:11 <ivanm> @tell mmorrow I'm cheating: pre-defined outputs, so the only possible errors come from not being able to write to the specified file (and my code already handles that!)
07:34:12 <lambdabot> Consider it noted.
07:40:28 <magthe> in TH, how do I "look up" a symbol by name?
07:40:50 <EvilTerran> reify?
07:42:04 <lilac> magthe: can you clarify what you mean? (or hpaste.org something?)
07:44:20 <jberryman> when using a type with record syntax accessor functions, is there a way to apply a function to the record in a similar manner to fmap on functors? i.e. something less ugly than: type{accessor = f (accessor type)}
07:44:50 <jberryman> I tried to define a function that encapsulated the above but it didn't work
07:44:53 <quicksilver> jberryman: not a built in way, no.
07:45:02 <magthe> well, I'm mostly just playing around at the moment to get a feel for TH... I have a function that returns a definition, this function takes a "base name", the result should be calls to a few functions, their names derived from the base name
07:45:06 <quicksilver> what you want to do is use Lenses, also known as functional references.
07:45:11 <quicksilver> then you write
07:45:23 <quicksilver> modify accessor f type
07:45:26 <quicksilver> or something ;)
07:45:55 <jberryman> quicksilver: thanks, will do the google thing. So much to learn there is :)
07:46:07 <mib_hyumkc> lilac i was thinking of generating all the possible numbers
07:46:22 <quicksilver> jberryman: there is an implementation on hackage as 'data-accessor'
07:46:34 <quicksilver> last I looked at it I didn't like their choice of primitives quite as much as my own.
07:47:43 <magthe> lilac, EvilTerran: http://hpaste.org/10788
07:48:39 <EvilTerran> i see
07:48:47 <EvilTerran> what type is f_base? String?
07:48:54 <magthe> EvilTerran: yes
07:49:18 <EvilTerran> i think you need a VarE for that
07:49:46 <magthe> EvilTerran: ah, ok... can I mix that into the [d| ... |] notation later on?
07:50:06 <EvilTerran> f1 = varE . mkName $ f_base ++ "2"
07:50:12 <EvilTerran> should do it
07:50:18 <EvilTerran> that'll make f1 :: ExpQ
07:50:25 <EvilTerran> which is the right type for splicing with $(...)
07:51:06 <magthe> EvilTerran: thanks, I'll try
07:51:07 <lilac> mib_hyumkc: do you just want to count them, or do you want to find them all?
07:51:59 <pastorn> is there some easy way to implement a max/min-heap?
07:52:07 <jaak_> Hey, i'm trying to write some networking code with bytestring and binary, but things doesn't seem to work
07:52:13 <jaak_> http://hpaste.org/10789
07:52:31 <pastorn> Data.Set balances with the middle value at the top
07:52:35 <jaak_> so i guess the million dollar question is: how do i fix this
07:52:41 <pastorn> not very algorithm friendly... :/
07:53:11 <EvilTerran> pastorn, won't extract-min be O(log n) in any heap implementation?
07:53:21 <EvilTerran> which is what it is for Data.Set
07:53:21 <quicksilver> jaak_: and if I answer your question, I get a million dollars?
07:53:25 <pastorn> EvilTerran: O(1)
07:53:27 <quicksilver> jaak_: that sounds good.
07:53:30 <jaak_> server gets nast "*** Exception: too few bytes. Failed reading at byte position 5"
07:53:34 <EvilTerran> really?
07:53:36 <jaak_> no, i get
07:53:38 * EvilTerran goes to look up heads
07:53:40 <EvilTerran> *heaps
07:53:58 <pastorn> EvilTerran: depends on how you want to implement it
07:54:03 <pastorn> this is for the napsack problem
07:55:10 <quicksilver> jaak_: does it print anything before the exception?
07:55:13 <jaak_> looks like lazy IO is root of all evil... but i'm not sure
07:55:15 <jaak_> yep
07:55:25 <jaak_> 1 to 9
07:55:40 <quicksilver> jaak_: then your problem is that your encoding is binary
07:55:47 <jaak_> really?
07:55:49 <quicksilver> jaak_: but you try to use '\n' as a separator
07:55:52 <quicksilver> that's not going to work ;P
07:56:01 <quicksilver> \n is ascii 10 or ascii 13 or both.
07:56:14 <jaak_> i'm using lines
07:56:14 <lilac> what's so bad about lazy IO?
07:56:26 <jaak_> so there shouldn't be any '\n's
07:56:27 <quicksilver> jaak_: yes but you 'encode' function produces a \n
07:56:34 <quicksilver> jaak_: when you ask it to encode 10
07:56:39 <jaak_> oh blimey
07:56:51 * quicksilver slaps jaak_ around with a moldy trout
07:56:59 <quicksilver> don't try to mix binary protocols with text protocols ;)
07:57:05 <lilac> i suspect the lazy IO issue is that it can cause 'pure' code to do weird things. but so can using the IO monad to write to arbitrary bits of memory, so...
07:57:11 <quicksilver> with a binary protocol I recommend just sending length first.
07:57:14 <jaak_> quicksilver: oh man, thanks!
07:57:29 <jaak_> so i should just send list and read list
07:57:37 <magthe> EvilTerran: thanks, that did it ;)
07:57:37 <quicksilver> well that would work too.
07:57:54 <EvilTerran> :)
07:58:03 <jaak_> @slap jaak_
07:58:04 * lambdabot jabs jaak_ with a C pointer
07:59:45 <jaak_> i'm off now, thanks again
08:10:46 <matthew-_> @seen dons
08:10:46 <lambdabot> dons is in #arch-haskell, #ghc, #darcs, #xmonad and #haskell. I don't know when dons last spoke.
08:11:00 <mauke> preflex: seen dons
08:11:00 <preflex>  dons was last seen on #haskell 6 hours, 38 minutes and 47 seconds ago, saying: Cale, ddarius can someone do a killer logo for the haskell platform? :)
08:12:06 <Baughn> Re: Said platform, is there a mailing list or some such yet?
08:12:49 <Baughn> I wanted to plead for at least Edison to be included. ;_;
08:13:40 <Axman6> i had a look at edison, and i couldn't see what it was really, nor did it looked anywhere near finished
08:13:46 <ArthurClemens> what is the killer platform?
08:13:53 <Axman6> that's from 5 mins of checking it out though
08:14:13 <quicksilver> Baughn: I don't think there will be any additions for the initial release.
08:14:30 <Baughn> Axman6: It's a bunch of data structures. Some documentation would be good, but it's pretty much complete as-is
08:14:39 <Baughn> quicksilver: So.. no heaps for us?
08:15:18 <Baughn> Oh well. So long as it includes cabal-install, telling users to "say cabal install in the dir to install" should be reasonably simple. :P
08:15:26 <quicksilver> Baughn: not in the initial release.
08:15:41 <quicksilver> but that leaves you plenty of time to campaign for its inclusion in 1.1
08:16:05 <Baughn> quicksilver: Don't think I won't. That's why I'm asking for.. well, contact information
08:17:39 <Baughn> There should be some information on that wiki page about where it's being discussed
08:18:15 <quicksilver> it's a wiki page
08:18:17 <quicksilver> add some information :)
08:18:29 <Axman6> make it up!
08:18:58 <Baughn> And if I write down that all discussion happens in #haskell-platform, will that actually become true? -_-
08:19:20 <quicksilver> it might do
08:19:25 <quicksilver> I would not be in favour, though.
08:19:37 <quicksilver> I think the discussion should be in #haskell until the volume proves too loud.
08:19:46 <quicksilver> I believe in splitting discussion fora lazily, not in advance.
08:20:26 <Baughn> Same, relaly
08:20:37 <Axman6> no preemptive multitasking for you?
08:26:20 <Jaak> quicksilver++
08:33:42 <dmead> hakell!!!!!!!!
08:33:45 <dmead> err
08:33:46 <dmead> haskell!!!!11
08:34:47 <RayNbow> @karma haskell
08:34:48 <lambdabot> haskell has a karma of 0
08:34:54 <RayNbow> haskell++
08:35:38 <Axman6> @karma haskell
08:35:38 <lambdabot> haskell has a karma of 1
08:35:44 <Axman6> excellent
08:35:44 <mauke> preflex: karma haskell
08:35:44 <preflex>  karma for haskell: 9
08:36:05 <quicksilver> @where kuribas-indentation
08:36:05 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
08:36:12 <quicksilver> oMG it remembered for a whole day
08:36:14 <quicksilver> @botsnack
08:36:15 <lambdabot> :)
08:39:05 <Leaves> Hello, haskell defaults to converting a Word8 to decimal when showing, do you know how to show the hex value of a Word8?
08:39:25 <byorgey> Leaves: you could use printf
08:39:29 <mauke> > 42 :: Word8
08:39:30 <lambdabot>   42
08:39:37 <quicksilver> > showHex 42 ""
08:39:38 <mauke> > showHex (42 :: Word8) ""
08:39:38 <lambdabot>   /tmp/3416115484415809881:67:40: Not in scope: `showHex'
08:39:39 <lambdabot>   /tmp/1748025794699974571:67:44: Not in scope: `showHex'
08:39:43 <mauke> nooooo
08:39:48 * quicksilver slaps lambdabot for being a useless thing.
08:39:52 <mauke> > printf
08:39:53 <lambdabot>       Overlapping instances for Show (String -> r)
08:39:53 <lambdabot>        arising from a use ...
08:40:00 <quicksilver> Leaves: showHex is the answer, anyhow.
08:40:05 <byorgey> > printf "%x" (42 :: Word8)
08:40:06 <lambdabot>   Add a type signature
08:40:07 <mauke> > printf "%x" (42 :: Word8) :: String
08:40:08 <lambdabot>   "2a"
08:40:26 <RayNbow> :t printf
08:40:27 <lambdabot> forall r. (PrintfType r) => String -> r
08:41:41 <Deewiant> lambdabot--
08:42:11 <Leaves> quicksilver: I don't seem to have the showHex function, I can't find it on google either
08:42:16 <quicksilver> @hoogle showHex
08:42:17 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
08:42:21 <quicksilver> there it is :)
08:42:34 <Deewiant> @index showHex
08:42:35 <lambdabot> Numeric
08:45:27 <Leaves> quicksilver: ok, thanks, I was wondering what ShowS ment but I get it now ;)
08:51:15 <BeelsebobWork_> how do I get ghc to produce a binary from a module not named Main?
08:51:23 <BeelsebobWork_> (but with a main function in it)
08:52:17 <Deewiant> --main-is ?
08:52:45 <BeelsebobWork_> ah, yeh, minus a minus
08:52:47 <BeelsebobWork_> cheers
08:52:54 <Deewiant> no sweat
09:13:01 <camio> quicksilver: Why did you use the IO in your futures instead of something unamb based?
09:14:15 <quicksilver> because I don't believe in blocking values.
09:14:49 <quicksilver> I don't believe it is "ordinary" haskell semantics to have a value of type "a" which has the semantics "I may block for a while before returning the value a"
09:15:15 <quicksilver> worse still "I may block for a while, waiting for some external occurrence, before returning the value a"
09:15:32 <ttmrichter> What happened to the PDF versions of the GHC documentation between 6.8.2 and 6.8.3?  When I look at http://www.haskell.org/ghc/docs/6.8.2/ they're there, but when I look at http://www.haskell.org/ghc/docs/6.8.3/ there's only the HTML format.
09:15:33 <lambdabot> Title: Index of /ghc/docs/6.8.2
09:15:35 <quicksilver> and even worse than that, other combinators which can some how look inside blocking values and get partial information.
09:15:42 <camio> Ah, I see. It certainly makes it very difficult to reason and debug with that sort of semantics.
09:15:43 <quicksilver> and use that to combine them.
09:16:34 <quicksilver> I'm being a little bit unfairly negative.
09:16:45 <quicksilver> Actually I think blocking values is a very interesting thing to study.
09:16:55 <quicksilver> and I think it deserves study, explanation, and a formal semantics.
09:17:06 <quicksilver> however, I think it's misrepresentation to call it 'pure haskell'
09:17:12 <quicksilver> in my mind, it's a subtly different semantic.
09:17:36 <quicksilver> so, I took the decision to push the blocking parts, and the 'waiting for external events' part into IO
09:17:39 <quicksilver> our generic sin bin.
09:17:47 <opqdonut> :)
09:17:48 <quicksilver> but certainly there is no doubt that IO operations are 'allowed to' block, and so on.
09:18:02 <daf> IO purgatory
09:18:02 <quicksilver> of course, that's buried in the implementation.
09:18:14 <quicksilver> when actually *using* my Reactive impl, you shouldn't need to see the IO anywhere.
09:18:20 <quicksilver> (except when you interface to an IO-bound library)
09:18:40 <papermachine> quicksilver, where is this implementation?
09:19:03 <camio> Thanks for that explination. I'm going to try to make some interactive OpenGL demos with it.
09:21:35 <quicksilver> papermachine: hmm. probably on hpaste.
09:22:28 <Deewiant> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=36 ?
09:22:37 <papermachine> quicksilver, only thing I see there is something called OBJ loader
09:22:52 <quicksilver> Deewiant's one is basically it.
09:22:57 <quicksilver> but there is a slightly newer version.
09:23:42 <quicksilver> papermachine: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=65#a65
09:23:57 <papermachine> thanks.
09:23:58 <Deewiant> deus?
09:23:58 <quicksilver> camio: have you seen my basic openGL demo?
09:24:04 <quicksilver> the hard part is writing the glue, really
09:24:07 <camio> quicksilver: It looks like there's a memory leak in the blocking read of mappended futures.
09:24:09 <quicksilver> to pipe the events in.
09:24:14 <camio> No, I haven't seen it.
09:24:42 <quicksilver> you could be right abotu the memory leak. Where?
09:25:03 <camio> Well, the two threads don't kill one another after they putMVar.
09:25:21 <quicksilver> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=66#a66
09:25:24 <camio> So the MVar will stay in memory indefinately if the event doesn't happen.
09:25:36 <quicksilver> camio: nope, that will get cleared on the next GC.
09:26:01 <quicksilver> as I understand GHC's GC, at least.
09:26:20 <quicksilver> MVars which have putters but no takers, or vice versa, are eligible to be GCed.
09:26:22 <camio> How so? If blockingReadFuture takes an indefinate length of time, the GC cannot know if it needs to kill it.
09:26:28 <quicksilver> oh, yes.
09:26:30 <quicksilver> that's certainly true.
09:26:35 <quicksilver> if the IO action blocks forever.
09:26:42 <camio> yep
09:26:44 <quicksilver> that's why you use 'Never' if you know that's the case.
09:26:56 <camio> Right, but in real time systems you don't.
09:27:35 * quicksilver nods
09:27:38 <quicksilver> yes, good point.
09:30:18 <quicksilver> camio: the thing about my example is all the ugliness in the glue
09:30:24 <quicksilver> IORefs to store the Event, the Reactive, etc.
09:30:31 <quicksilver> I need to abstract the glue a bit better :)
09:30:37 <quicksilver> but I haven't worked on it for a few weeks.
09:31:01 <camio> Yeah, the glue is tough stuff.
09:31:34 <geezusfreeek> ooh we are talking FRP
09:31:36 <camio> I haven't seen a proposal yet that works and interfaces well with glut (ie. everything (input & output) needs to be on the same thread)
09:32:29 <geezusfreeek> i've been working on a pure core for a FRP library based on reactive
09:32:51 <geezusfreeek> the only ugly part should be some unsaveInterleaveIO at the top level, once i get to that
09:33:21 <quicksilver> camio: I used a Chan to pipe the events, which is wrong.
09:33:41 <quicksilver> camio: well actually a Chan isn't wrong, but forking a separate thread to read from it is wrong.
09:33:55 <quicksilver> Can lead to event delivery getting delayed until GHC chooses to schedule that thread
09:34:00 <quicksilver> so you can get slight UI delays.
09:34:11 <quicksilver> I need to use threads less, I think.
09:34:28 <camio> Yeah, we're seeing delays up to 0.5s using threads.
09:34:28 <quicksilver> but the running GL code only in the main thread is fine.
09:34:40 <geezusfreeek> my design is single threaded with plans to add some parallel combinators later on
09:34:48 <quicksilver> in my code the delay is until the next time you poke the event pump
09:34:54 <quicksilver> so it can be unbounded time if you're unlucky.
09:35:01 <camio> yikes
09:35:08 <quicksilver> the next external event (of any kind) will poke the pump and notice the pending event
09:35:14 <Axman6> ok, here's a question: why do input and output have to be lumped together? the more i think about it, the more it seems like seperating the two makes more sense; output can't really change a program's state, it's only input where issues arrise. i'm sure there's flaws in my logic...
09:35:16 <quicksilver> of course, if you commit to some consistent source of events
09:35:22 <quicksilver> like a timer tick
09:35:29 <quicksilver> then you have bounded error.
09:35:34 <quicksilver> Axman6: that is one of the things FRP gives you.
09:35:41 <quicksilver> Axman6: a strong separation between output and input.
09:35:45 <Axman6> excellent
09:35:56 <Axman6> so...i'm not retarded then?
09:35:59 <quicksilver> no, you're wise.
09:36:08 <quicksilver> camio: I didn't find the main-thread thing to be an issue, though.
09:36:16 <quicksilver> camio: I only run IO actions in the main thread.
09:36:31 <quicksilver> (there is an event pump which checks for pending IO actions at the end of the callback)
09:36:44 <camio> Ah
09:36:49 <Axman6> always seemed a bit \silly to me that i'd have to go through hoops to do soemthing as simple as putStrLn :\
09:37:02 <quicksilver> Axman6: A generic problem with haskell's IO monad is that it is too much.
09:37:08 <quicksilver> It is a generic sin bin for all kinds of concepts
09:37:27 <quicksilver> explicit memory management, blocking, forking, non-determinism
09:37:39 <quicksilver> as well as more traditionally 'IO' thinks like input and output.
09:37:47 <quicksilver> It's perfectly sound to bundle them all together.
09:37:53 <mmorrow> @tell ivanm whichever of the bsd licenses you're using  (re: ".. license are you willing to distribute runWIthInput under?")
09:37:53 <lambdabot> Consider it noted.
09:37:55 <quicksilver> but just like any good type system, the more you can separate the better.
09:38:02 <pa-ching> It's a perfectly cromulent monad.
09:38:16 <quicksilver> cromulent, but, alas, we embiggened it too well.
09:38:31 <mmorrow> heh, i /thought/ i just heard cromulent
09:38:33 <lambdabot> mmorrow: You have 4 new messages. '/msg lambdabot @messages' to read them.
09:41:15 <Axman6> quicksilver: well, maybe in 5 years if no one else's done it, i'll do my PhD on the separation of I and O
09:41:52 <lightstep> yay to write-only memory
09:43:13 <Axman6> lightstep: excellent for apps that need extreme security, even they don't know what they've done
09:44:20 <lightstep> that's true, but it still like the sound of it
09:45:10 <lightstep> http://www.thinkgeek.com/stuff/looflirpa/shrinter.shtml  <- like this
09:46:17 <camio> quicksilver: Is nonblockingReadFuture supposed to only return (Just (t,x)) after t has occurred?
09:46:28 <geezusfreeek> in a sense, FRP could be seen as such a separation. an arrow from I to O
09:46:44 <quicksilver> camio: it's supposed to return Nothing (immediately) if the future has not yet occurred.
09:46:54 <quicksilver> camio: nad Just (t,x) (immediately) if it has.
09:47:05 <geezusfreeek> quicksilver, you have FRP code up? i would like to see it if so
09:47:22 <quicksilver> well I pasted my reactive impl and a very simple GL demo
09:47:33 <geezusfreeek> aha. on hpaste?
09:47:46 <quicksilver> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=65
09:47:48 <camio> <- trying to figure out how to solve the nbr append problem.
09:47:49 <quicksilver> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=66
09:48:17 * geezusfreeek peeks
09:48:31 <quicksilver> camio: note that I haven't tried to solve the value caching problem at all.
09:48:42 <quicksilver> I have decided that value caching is less important than semantics I believe in.
09:48:46 <quicksilver> this is only an exploration.
09:48:56 <quicksilver> although if it is useful for someone that's a bonus ;)
09:49:33 <camio> By value caching are you referring to having mappend always return the correct order?
09:51:15 <camio> quicksilver: I think I have a solution to the correct odering problem. Do you want to hear it?
09:51:28 <quicksilver> camio: yes please.
09:51:45 <quicksilver> (by the value caching problem I was referring to fmap not recalculating the value)
09:51:57 <camio> make nonblockingReadFuture be of type Future a -> IO (UtcTime, Maybe a).
09:52:17 <camio> So if it returns nothing, you are guarenteed that the future occurs after time t.
09:52:17 <quicksilver> and have it yield a lowerbound?
09:52:27 <quicksilver> yes, I considered that.
09:52:41 <quicksilver> I'm not sure why I didn't try it.
09:52:48 <quicksilver> I will think about it again, thank you ;)
09:52:55 <camio> Then mappend becomes easy.
09:53:04 <camio> np
09:53:27 <Deewiant> what is this 'Deus' package?
09:53:55 <mmorrow> ArthurClemens: re: parsing java(script). check out WebBits on hackage. it has a (works well) javascript parser (uses parsec) which is (at least i was surprised) suprisingly concise. i would'
09:54:21 <geezusfreeek> i don't have my code up, but just for reference my types at this moment are data Time t = Always | At t; newtype TimedVal t a = Timed (t, a); newtype Future t a = Future (Maybe (TimedVal t a)); newtype Event t a = Event [Future t a]; newtype Signal t a = Signal (a, Event t a)
09:54:32 <mmorrow> ve done the AST differently maybe, but that might just be my personal taste
09:54:42 <geezusfreeek> just a pure core
09:54:55 <quicksilver> Deewiant: just some random hierarchy name I use for stuff I'm working on.
09:55:00 <geezusfreeek> the reasoning behind Event being a list is to convey Never with []
09:55:14 <Deewiant> quicksilver: so none of this is released anywhere?
09:55:20 <hugo_> is there any way for me to store the value of a computation ?
09:55:30 <quicksilver> Deewiant: well, it's released on hpaste and moonpatio ;)
09:55:32 <hugo_> i have this monad that always returns the same value for the same input
09:55:37 <Deewiant> :-P
09:55:41 <geezusfreeek> the list is populated with unsafeInterleaveIO and the combinators will be carefully written to be as lazy as possible
09:55:50 <hugo_> and i dont want haskell to be doing that computation all the time ... :/
09:56:03 <quicksilver> hugo_: yes. give it a name and it will only be computed once.
09:56:05 <mmorrow> hugo_: you could use a Map in an MVar stashed away somewhere possibly
09:56:21 <hugo_> quicksilver: with a "let/where" clause ?
09:56:29 <quicksilver> yes, for example.
09:56:38 <hugo_> ólright
09:56:42 <quicksilver> your question wasn't very precise so my answer is not very precise ;)
09:56:47 <hugo_> yes ok
09:56:48 <mmorrow> ah, yeah i may have misinterpreted what you wanted..
09:56:53 <hugo_> ill try to be more precise
09:56:57 <quicksilver> geezusfreeek: yes, that's a more literal embedding into blocking pure values.
09:57:10 <quicksilver> geezusfreeek: I'm trying to avoid such things but if you make them work taht's great :)
09:57:28 <Axman6> raer, why do all the interesting discussions happen when i should be asleep?
09:57:29 <hugo_> im using hxt, and curl, so i have this function that uses curl, and returns an IO String, then i want to parse it with hxt in several different ways
09:57:53 <hugo_> and i dont want to be sending http requests whenever i call my "getHTML" function with the same url
09:57:57 <geezusfreeek> quicksilver, yes, it's a blocking core. i intend to get around that by writing a nonblocking top level
09:58:23 <hackage> Uploaded to hackage: ForSyDe 3.0
09:59:15 <geezusfreeek> i got tired of playing with unsafePerformIO and IORefs, is all ;)
10:08:11 <mmorrow> hugo_: possibly have something like  newtype HtmlCache = HtmlCache (MVar (Map URL String)), then everytime you call getHTML check the Map in the MVar first
10:08:23 <mmorrow> (type URL = String or whatever)
10:09:02 <ziman> oh, does λ-bot limit eval's output less in queries? right now she threw 6 lines at me (from a single > "badger " command)
10:09:13 <mmorrow> possibly also you could  HtmlCache (MVar (Map URL (ClockTime, String)))
10:09:28 <mmorrow> and refresh old entries or something
10:10:22 <mmorrow> ziman: in private /msgs the limit is much larger
10:10:42 <mmorrow> hmm, lunabot should do that too
10:17:55 <Apocalisp> Is HList a monoid by any stretch?
10:19:39 <ddarius> HList isn't anything
10:19:47 <ddarius> It's a library
10:20:56 <mauke> isn't HList basically (,)?
10:21:25 <Apocalisp> more like HCons e l | HNil
10:22:04 <mauke> ok, so Maybe (,)
10:22:11 <Apocalisp> ah!
10:22:15 <vixey> (,) will do fine
10:29:14 <RayNbow> @seen int-e
10:29:14 <lambdabot> I saw int-e leaving #ghc, #haskell-overflow and #haskell 7h 25m 26s ago, and .
10:29:45 <dons> ?users
10:29:46 <lambdabot> Maximum users seen in #haskell: 515, currently: 503 (97.7%), active: 11 (2.2%)
10:33:27 <leimy> neat
10:33:33 <leimy> buttloads of lurking
10:33:37 <dons> yup
10:37:05 <Axman6> leimy: everyone knows there's only three outspoken comp sci guys around.
10:37:10 <Axman6> dons is two of them >_>
10:37:19 <leimy> heh
10:37:44 <leimy> I sometimes wish I'd have stayed in academia
10:39:04 <Eridius> leimy: yeah but then you'd have to deal with students, and publishing papers...
10:39:12 <leimy> true
10:39:14 <dons> Axman6: :P
10:39:35 <leimy> but that's probably less soul-crushing than having one's designs misunderstood by management that makes decisions for new product directions without asking engineers
10:39:46 <leimy> or driven by a sales force that's maybe only technically qualified to sell used cars
10:39:49 * leimy is bitter today
10:40:11 <leimy> Whatever, I guess it's a paycheck.
10:40:27 <dons> thoughts on the platform, guys? http://haskell.org/haskellwiki/Haskell_Platform
10:40:28 <lambdabot> Title: Haskell Platform - HaskellWiki
10:40:29 <dons> questions?
10:40:36 <dons> if you add questions, i can turn them into tickets.
10:40:41 <dons> add questions here, i should say
10:40:50 <leimy> Nice
10:40:51 <andyjgill> Cool pics, dons. tulip, is assume.
10:41:04 * leimy wishes there was an SNMP implementation for Haskell
10:41:06 <leimy> :-)
10:41:11 <dons> the original graphs were tulips, yeah.
10:41:26 <dons> andyjgill: i think we can get the tracer out this week, btw.
10:41:33 <dons> jodee's here, and i'm doing some releases.
10:41:42 <leimy> system admins I know absolutely HATE the idea of cabal install :-)
10:41:48 <andyjgill> Great. That would be useful to everyone.
10:41:50 <dons> leimy: ok. that's fine.
10:41:58 <leimy> they see it as yet another version of CPAN
10:42:01 <dons> the platform is for admins, so they know what native package to install.
10:42:03 <leimy> to screw up their machines with.
10:42:03 <Taggnostr> @src Just
10:42:03 <lambdabot> Source not found.
10:42:13 <leimy> dons: that's great then :-)
10:42:13 <dons> leimy: right. they wouldn't use cabal-install
10:42:24 <dons> its for developers, who install in $HOME
10:42:26 <dons> not globally.
10:42:52 <dons> but admins can easily answer the users query: "Please can you install `Haskell'"
10:43:11 <dons> they just have to install the platform metapackage from their distro.
10:43:29 <Zao> dons: And then get nagged for the bazillion extralibs packages the distro has split everything into.
10:43:40 <dons> no no. 1 package.
10:43:44 <dons> a metapackage.
10:44:20 <Zao> Ah, you're talking about a future dream world.
10:44:20 <dons> probably gentoo and arch will be the first compliant distros.
10:44:29 <dons> Zao: yes. 2 weeks away :)
10:44:33 <dons> get ready for the *future* !
10:44:50 <Zao> s/future/breakage :P
10:44:51 <leimy> so wait
10:44:55 <dons> andyjgill: can we hand out ghc on usb keys at the next ICFP
10:44:55 <leimy> system admin installs one package?
10:44:56 <dons> :)
10:45:03 <dons> leimy: apt get haskell-platform
10:45:04 <leimy> how the hell do they deal with dependencies changing?
10:45:26 <andyjgill> Great idea. Why not get ones with the Galois logo? (sponsored by Galois).
10:45:32 <leimy> dons: I guess I need to read more
10:45:33 <dons> hmm. nice idea.
10:45:43 <leimy> what if I need four different versions of some lib for some reason?
10:45:45 <dons> leimy: distros could support the platform by just having  all the subpackages
10:45:53 <dons> leimy: then you're not targetting the platform.
10:45:56 <andyjgill> Like mugs or teeshirts. but actually useful.
10:45:57 <dons> you're building on something else.
10:46:00 <dons> andyjgill: yeah.
10:46:10 <dons> and preloaded with haskell :)
10:46:13 <dcoutts> leimy: if your distro supports that you can do that, cabal-install can certainly handle multiple versions of the same package
10:46:14 <leimy> dons: I see, so by targetting and keeping up with "the platform" I'm able to make my stuff work everywhere
10:46:19 <dons> leimy: right.
10:46:25 <leimy> interesting
10:46:28 <dons> application authors will target what the platform provides.
10:46:30 <leimy> it's strict on developers
10:46:33 <leimy> update or die
10:46:35 <leimy> :-)
10:46:38 <dons> just like you might only base on the python library set.
10:46:46 <leimy> if the platform moves and I don't, my stuff isn't with the platform.
10:47:00 <leimy> I can handle that
10:47:01 <dons> it'll depend on an older version.
10:47:05 <leimy> right.
10:47:15 <leimy> makes sense
10:47:22 <dons> but yes, a lot of stability and clarity for application developers.
10:47:37 <leimy> So I should target the platform if I care about distribution
10:47:50 <leimy> which sounds good, especially since I get paid to code :-)
10:48:05 <leimy> unfortunately the closest I've been to commercial haskell is erlang :-)
10:48:15 <leimy> not that erlang's so bad, it's just not haskell.
10:48:22 <papermachine> What GUI libraries are in the Platform?
10:48:31 <papermachine> I can't find a list of what's in and what isn't
10:49:45 <dons> the initial release is what is currently known as extralibs, + zlib, http, binary and utf8-string
10:49:53 <dons> so a small target to get our procedures right.
10:50:07 <dons> http://trac.haskell.org/haskell-platform/
10:50:08 <lambdabot> Title: haskell-platform - Trac
10:50:10 <Baughn> And cabal-install?
10:50:13 <dons> of course.
10:50:22 <Baughn> Yay. That's the most important. bit. ^_^
10:50:37 <Baughn> The platform is a nice idea, but just being able to tell people "run cabal install <foo>"...
10:50:40 <dons> after that, people will be able to propose libraries and tools from hackage (And a few special exceptions) for inclusion
10:50:54 <Baughn> Haddock, happy, alex..
10:51:29 * Baughn is very happy about the whole thing.
10:53:25 <dons> would  someone like to make a logo for the haskell platform?
10:53:34 <dons> perhaps based on ideas from that bubble graph.
10:53:35 <Baughn> Eh? I thought we already had one
10:53:38 <dons> some kind of package swarm
10:54:00 <dons> a swarm of lambda bees
10:54:02 <idnar> dons: you could have a picture of Haskell Curry on a gallows
10:54:03 <Beelsebob> dons: a lambda on its side -- so it looks like a platform :P
10:54:06 <Leaves> dons: what about doing for versions a.b.c where when a changes it breaks backwards compatibility, when b changes it keeps backwards compatibility (but not forward, so new functions may be addes) and c for bugfixes, this would be really usefull, since then in the cabal files you don't need the < stuff anymore, just depend on lib-1.1.* and this will always work
10:54:25 <Baughn> http://haskell.org/sitewiki/images/4/43/Small-package-bubbles.png <-- This one gets my vote, with the bubbles rearranged as a lambda
10:54:31 <dons> cabal now supports base 3.* syntax
10:54:41 <dons> so you can by default specify ranges that satisfy the version system.
10:54:48 <dons> which actually works, unlike saying, base >= 3
10:55:51 <Leaves> note that when ghc is smart it even works when a package depends on liba-1.0 and libb-1.0 and when libb has the function f which is used, when liba introduces also a function f in liba-1.1 then if ghc is smart it knows it has to take the f from libb..
10:57:53 <Leaves> dons: yes, but when you depend on lib-2008.0.* and then in 2009 the next lib lib-2009.0.0 is released which is backwards compatible you have to add this to the former pakcage that depens on this lib
10:58:10 <dons> no no, you don't depend on the platform itself.
10:58:13 <dons> it provides no code.
10:58:22 <dons> you pick from libs *in* the platform.
10:59:07 <Leaves> dons: aah, I though you ment that all packages in the platform had to use that verison policy?
11:00:15 <Leaves> I see, so the platform is versioned yyyy.major.minor, the packages all still use their own version scheme
11:02:37 <leimy> Leaves: yep, you could say Platform contains those packages
11:02:44 <leimy> or those versions of those packges
11:02:46 <gbacon>  > let { digits = "0123456789"; strs n = case n of { 0 -> [[]]; _ -> digits >>= \c -> map (c:) $ strs (n-1) } } in length $ strs 4
11:02:50 <andyjgill> Random question: has anyone got an example of using a pseudo-tty in Haskell? I can not find any users for openPseudoTerminal in System.Posix.Terminal
11:02:52 <gbacon> > let { digits = "0123456789"; strs n = case n of { 0 -> [[]]; _ -> digits >>= \c -> map (c:) $ strs (n-1) } } in length $ strs 4
11:02:54 <lambdabot>   10000
11:09:23 <rwbarton> Has anyone tried building darcs yhc recently?
11:10:05 <rwbarton> I get this error: http://hpaste.org/10792
11:11:05 <chrisdone> tip of the day: “undefined” is awesome
11:15:07 <_andre> hello
11:15:15 <_andre> anyone here using Agda?
11:15:24 <dons> swiert does.
11:15:53 <_andre> i'm having trouble building it
11:17:16 <lightstep> why is bytestring not in the platform? is it in bse?
11:17:46 <bos> it's in extralibs
11:19:20 <gbacon> why would runplugs complain about __stginit_mtlzm1zi1zi0zi1_ControlziMonadziError_ being undefined?
11:21:16 <RayNbow> dons, will the Haskell, Batteries Included platform get a flashy name?
11:21:39 <luite_> and will it get an Enterprise Edition?
11:21:46 <olsner> "ghc"? :P
11:23:23 <dons> RayNbow: The HDK ? :)
11:24:11 <RayNbow> dons: hmm... but people might compare Haskell to Java (JDK) then... is that something desirable?
11:24:25 <dons> hehe
11:24:48 <vegai> or MDK, the game?
11:24:52 <leimy> I think so
11:25:08 <augustss> dons: will the platform packages work on windows?  it happens to me all the time that some cool package doesn'y work under windows.
11:25:10 <leimy> I think when you compare Haskell to Java, in a serious way, you start to realize how very wrong you were about something.
11:25:17 <leimy> what that is, I don't know
11:25:21 <dons> augustss: yes, they absolutely must.
11:25:28 <dons> augustss: that's a hurdle for inclusion.
11:25:37 <dons> augustss: we're going to build windows installers too
11:25:48 <leimy> that's cool
11:26:13 <dons> augustss: we can use inclusion in the package as a hurdle to force api standardisation and portability.
11:26:32 <dcoutts> augustss: I'm hoping to build windows installers next week
11:26:52 <leimy> from now on, Haskell Platform will be known as, Vindaloo
11:26:55 <leimy> ?
11:27:21 <dcoutts> augustss: having decent build reporting will also make it clearer to you and to package maintainers if things do not build on windows
11:28:12 <dcoutts> augustss: a bit of public naming and shaming in that area should go a long way :-)
11:29:08 <dons> a unix-only platform would be a separate thing that could be tackled later.
11:29:48 <Botje> murder death stack overflow!
11:29:49 <lightstep> maybe the platform release can be at the say time is hcar? since both are twice-a-year summaries of haskell library development
11:29:57 <lightstep> s/say/same/
11:30:10 <RayNbow> dons: will readline be included in the Haskell Platform? (because that's a package I was not able to build under Windows)
11:30:37 <dcoutts> lightstep: I think the most useful thing would be for it do be in sync but out of phase with ghc releases
11:31:03 <dcoutts> lightstep: a window of a month or so for maintainers to update packages for new ghc releases
11:31:21 <dons> RayNbow: its not useful to ask specific questions, "is X in or out". since that's not how it is decided.
11:31:24 <dcoutts> eg gtk+ releases usually have to be 3 months before gnome releases
11:31:39 <dons> the burden will be on the proposer for it to go in to show that metrics are satsified.
11:31:48 <dons> and for now, we only start with extralibs
11:31:54 <dcoutts> right, dons and myself are not deciding
11:32:02 <dcoutts> we're not the gate keepers
11:32:30 <dons> no politics, no arguments. only statistics.
11:32:37 <dcoutts> the standards for inclusion are a discussion the community needs to have and one we will start after the first release
11:32:48 <dons> working out what the standards are is the next thing, as dcoutts says
11:33:06 <dons> probably we can write a paper on automated metrics for quality afterwards :)
11:33:17 <dcoutts> and we'll then use those standards and that protocol for the next round of additions
11:52:02 <olsner> @ty fromRight
11:52:03 <lambdabot> Not in scope: `fromRight'
11:52:20 <olsner> @hoo Either a b -> b
11:52:21 <lambdabot> Maybe you meant: hoogle hoogle+ show todo yow
11:52:24 <olsner> @hoogle Either a b -> b
11:52:24 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
11:52:24 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
11:52:24 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
11:54:13 <Deewiant> ?ty either (error "fromRight :: Left") id
11:54:15 <lambdabot> forall a b. Either a b -> b
11:54:48 <olsner> > either undefined id (Right "right")
11:54:49 <lambdabot>   "right"
11:55:35 <djsiegel> Hey, I want to parse a simple, small XML document and I have no idea where to start. I'm seeing way too many XML parsing options. I don't want to use tagsoup, and I don't want to have to use do arrow notation. Can someone point me to a simple tutorial? I haven't found one yet.
11:56:33 <djsiegel> HaXml seems fine, but I just can't find a 15-line tutorial that shows me how to extract the data I need from my Document once I've called xmlParse.
11:56:45 <vixey> djsiegel: Maybe that info is in the documentation?
11:57:03 <vixey> although isn't HaXml for constructing XML?
11:57:07 <djsiegel> I've been pouring over the haddocs for a while.
11:57:08 <vixey> rather than parsing it..
11:57:09 <ADINSX> http://pastebin.com/m60338c0b Hi, im trying to get a list of Strings out of a file with the lines function
11:57:12 <djsiegel> HaXml does both.
11:57:16 <vixey> oh I see
11:57:18 <ADINSX> i thought readLine was supposed to return a string
11:57:30 <ADINSX> but apparently it returns an IO string, how do i get the string information out?
11:59:31 <Beelsebob> ADINSX: using >>=
11:59:48 <Beelsebob> readLine >>= somethingThatDoesSomethingWithTheString
12:00:05 <Beelsebob> readline >>= putStrLn -- for example
12:00:15 <ADINSX> so readline >>= lines
12:00:18 <ADINSX> to return a list of strings
12:00:20 <ADINSX> ?
12:00:28 <Beelsebob> nope, once you're in the IO monad you can't get out again
12:00:38 <ADINSX> what really?
12:00:41 <ADINSX> hmm
12:00:43 <Beelsebob> so readLine >>= (return . lines)
12:00:46 <Beelsebob> yes, really
12:00:57 <Beelsebob> otherwise you can do all sorts of crazy stuff
12:01:03 <Beelsebob> (that's unsafe)
12:01:11 <ADINSX> hmmm
12:01:13 <Beelsebob> what I recommend doing is having a top level IO based function
12:01:27 <Beelsebob> which calls into purely functional stuff to do the bulk of the work
12:01:44 <Beelsebob> incidentally, there's already a nice function for doing that called interact
12:01:55 <Beelsebob> interact takes a function from String -> String, and performs IO
12:02:02 <Beelsebob> it runs the function lazily
12:02:17 <ADINSX> ah ok
12:02:22 <Beelsebob> so if you give it something like (unlines . processCommand . lines) you get nice interactive behavior
12:02:45 <ADINSX> i saw some stuff on interact but ignored it since i thought there would be an easier way
12:02:55 <Beelsebob> interact *is* the easy way
12:03:00 <Beelsebob> it's not the most powerful way
12:03:02 <Beelsebob> but it is the easy way
12:03:17 <ADINSX> gotcha
12:03:22 <Beelsebob> (it's also surprisingly powerful when you think about what processCommands can actually be
12:07:43 <Baughn> It's also surprisingly easy to get wrong and deadlock, but meh. :P
12:09:25 <Philippa_> plus you always end up trying to decide whether you're reading and writing anyway and frankly you really /want/ helper functions for that bit
12:09:37 <Philippa_> I'm tempted to say just doing it with monadic IO is actually a higher-level approach
12:23:35 <b_jonas> ah, there are new lambdacats
12:23:46 <b_jonas> two
12:23:47 <newsham> url?
12:23:54 <b_jonas> google "lambdacats"
12:24:07 <b_jonas> @g lambdacats
12:24:07 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . ? @ v
12:24:11 <b_jonas> @google lambdacats
12:24:15 <lambdabot> http://arcanux.org/lambdacats.html
12:24:15 <lambdabot> Title: Lambdacats
12:24:38 <rwbarton> Can I tell cabal install to install a specific version of a package (not the latest one)?
12:24:43 <Botje> @protontorpedo
12:24:43 <lambdabot> how is haskell different than java?
12:24:56 <Botje> heh heh
12:25:03 <_zenon_> Is that a real quote?
12:25:40 <ziman> @protontorpedo
12:25:41 <lambdabot> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp?
12:25:58 <newsham> public class Id<A> implements F<A,A> { public A call(A arg) { return arg; } }
12:26:36 <tromp_> your $$ depend more on the company than on the language...
12:27:02 <Botje> a cobol or smalltalk hacker will normally make more
12:27:07 <Botje> because there are less of them :)
12:27:33 <newsham> go with Rexx
12:27:36 <newsham> are JCL
12:29:56 <newsham> recently a company started selling a product that emulated ibm mainframes and rather than have their billion dollar overinflated market get eaten up, IBM tried to sue them out of existence and when they figured they couldnt do that, just bought htem to icebox the product.
12:30:07 <newsham> lots of overinflated costs in that market
12:30:33 <Botje> heh heh
12:30:36 <b_jonas> newsham: heh
12:34:03 <quicksilver> @tell camio I remembered the problem with that solution.. But, thanks for making me thinkj about it.
12:34:04 <lambdabot> Consider it noted.
12:41:07 <b800> is there any way to do ioctl-level calls in haskell?
12:41:18 <b800> googling hasn't really helped me unless i'm doing something wrong
12:42:57 <newsham> b800: you can call C API's directly with FFI
12:43:14 <b800> good to know
12:43:31 <b800> i was wondering if there was a library or something, but i guess i can dive into FFI
12:43:37 <Philonous> @src newIORef
12:43:38 <lambdabot> newIORef v = stToIO (newSTRef v) >>= \ var -> return (IORef var)
12:43:39 <b800> i haven't used FFI ever before though
12:43:42 <halberd> what's the first thing you do after you learn the basics of a new programming language?
12:43:57 <halberd> not haskell in particular
12:43:59 <newsham> "ioctl" is really broad, there's not going to be a library for that.  but there might be libraries that cover specific sets of ioctls
12:44:04 <b800> generally, forget them
12:44:11 <newsham> such as terminal controls or packet filter, for example
12:44:25 <halberd> for example do you translate a program in another language that you already know, into the new language?
12:44:30 <newsham> halberd: write lots of stuff in it and read some simpler examples
12:44:36 <Philonous> @src IORef
12:44:36 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
12:44:43 <b800> newsham: well, there could always be a binding like ioctl :: Handle -> Request -> IO ()
12:45:02 <b800> then look up the actual requests from somewhere else, but that would be asking a lot
12:45:23 <newsham> b800: right, but the ioctl API is a catch-all for things that dont fit the normal read/write API model, and it supports arbitrary in-out buffers
12:46:10 <Philonous> So IORefs  are compiler magic? Or are they actually definable in haskell?
12:46:16 <newsham> the call to the ioctl function isnt the hard part, its arranging to marshall data into and out of the odd structures
12:46:20 <dibblego> @where hlist
12:46:20 <lambdabot> http://homepages.cwi.nl/~ralf/HList
12:46:40 <idnar> @type newIORef
12:46:42 <lambdabot> Not in scope: `newIORef'
12:46:46 <daedra> anyone recommend a tutorial on lambda calculus?
12:47:00 <newsham> dae: i imagine wikipedia would have a decent intro
12:47:05 <idnar> heh
12:47:17 <daedra> yeah it is quite good
12:47:38 <Philonous> Strange, he knew that one a second ago
12:47:54 <idnar> Philonous: that was @src
12:48:02 <idnar> which just looks stuff up in a text file, I believe
12:48:04 <Philonous> Oh, right
12:50:07 <newsham> I think IORef's are just a layer on top of STRef?  those are probably "compiler magic" in as much as the built-in IO stuff is kind of "compiler magic"
12:50:24 <newsham> <- kinda guessing here
12:50:45 <olsner> STRef is (in ghc) a wrapper around a MutVar# which has a bunch of (impure?) primitives
12:51:05 <newsham> you could probably invent your own IORefs using other APIs like the FFI stuff
12:51:22 <Philonous> I see
12:52:10 <olsner> but for all intents and purposes it's magic (but it could probably be implemented as something explicitly stored and managed in the state threaded through ST)
12:53:32 <lightstep> they can also be programmed in pure haskell
12:53:52 <lightstep> oh, maybe not
12:54:01 <lightstep> because they're too polymorphic
12:54:48 <lightstep> it the type was newSTRef :: MyClass a => a -> ST s (STRef s a), you could do that
12:54:56 <olsner> yeah, I'm not sure if you can make them typecheck properly in the type system
12:55:08 <olsner> maybe with unsafeCoerce :P
12:55:20 <newsham> Typeable?
12:55:30 <b_jonas> you can't implement them efficently anyway
12:55:59 <lightstep> you can have access to them in O(log #vars)
12:56:13 <b_jonas> lightstep: yeah, but also consider garbage collection
12:56:17 <b_jonas> you can't garbage collect them
12:56:40 <lightstep> why not?
12:57:04 <newsham> if you store your refs in a datastructure, they'll always be referenced
12:57:44 <mmorrow> just looked up {ST,IO}Ref
12:57:50 <mmorrow> data STRef s a = STRef (MutVar# s a)
12:57:54 <mmorrow> newtype IORef a = IORef (STRef RealWorld a)
12:58:10 <b_jonas> I'll have to understand ST and STRef once
12:58:23 <hackage> Uploaded to hackage: hlibev 0.1
12:58:24 <Philonous> So, when would I want to use a IORef instead of just binding the value to a name?
12:58:28 <lightstep> newsham, only the newer version of the structure (with the new values) will be references
12:58:50 <newsham> light: *nod* but if the rest of the program stops using the value, it doesnt go away
12:58:51 <lightstep> *will have
12:59:23 <b_jonas> lightstep: yes, as in when you create lots of iorefs and quickly forget about each
12:59:48 <Philonous> Oh btw. are IORefs global?
13:00:10 <mmorrow> Philonous: newtype MMap a b = MMap (Map a (b, IORef (MMap b a)))
13:00:33 <mmorrow> Tree (IORef (Tree a))
13:01:04 <newsham> phil: your binding to the ioref is scoped.
13:01:06 <mmorrow> i've wanted to mess with iorefs of mvars in trees or maps, but haven't really
13:01:47 <lightstep> newsham, a compiler could be start enough to know that is a dictionary has Unique keys, and you lost the reference to some Unique value, it can throw this part of the dictionary (this would be hard and very hacky, but fits the standard)
13:02:19 <mmorrow> with an IORef, you can modify a scope which has diverged from you's world
13:02:37 <mmorrow> slash communicate
13:02:53 <mmorrow> Chans are cool how they're implemented
13:02:57 <mmorrow> @src Chan
13:02:58 <lambdabot> Source not found. Just try something else.
13:03:17 <mmorrow> data Chan a = Chan (MVar (Stream a)) (MVar (Stream a))
13:03:24 <b_jonas> Philonous: yes, quite global
13:03:52 <newsham> lightstep: so when I have a dictionary with the key "bar" (string) and there are no "bar" strings in the program memory then it should forget the entry for "bar" in all dictionaries?
13:04:28 <mmorrow> type Stream a = MVar (ChItem a)
13:04:32 <mmorrow> data ChItem a = ChItem a (Stream a)
13:04:52 <lightstep> no, only dictionaries with Unique keys, this is a type that you can't construct "by structure" (it's in the Data.Unique module)
13:05:17 <b_jonas> lightstep: how can you have Data.Unique without io?
13:05:24 <b_jonas> lightstep: isn't that a devil's loop?
13:05:25 <mmorrow> expanding ...
13:05:28 <mmorrow> data Chan a = Chan (MVar (MVar (ChItem a))) (MVar (MVar (ChItem a)))
13:07:18 <lightstep> b_jonas, since my hypothetical compiler has a specialized garbage collector (that recognizes two special types), it can probably also have a pragma that tells it some type is unique, which i promise not to break
13:07:39 <b_jonas> lightstep: that wouldn't be pure I think
13:07:47 <b_jonas> so you shouldn't do that
13:08:27 <lightstep> inside my state monad, there will be a counter that will generate unique object, which are not exposed to the user but only used in the implementation of refs
13:08:42 <dcoutts> rwbarton: cabal install foo-1.0  -- to install a specific version
13:08:56 <gbacon> grrrr
13:09:13 <dcoutts> rwbarton: or arbitrary constraints: cabal install "foo < 3.2"
13:09:19 <lightstep> and the garbage collector sees which unique values are currently reachable, and throws all the rest away from the environment
13:11:19 <b_jonas> lightstep: dunno...
13:11:23 <b_jonas> I'm not sure that would work
13:11:56 <lightstep> the GHC collector already has a special case for references. the the language doesn't dictate garbage collection at all
13:12:16 <b_jonas> lightstep: sure, it has to have one
13:12:21 <rwbarton> dcoutts: thanks.
13:12:31 <b_jonas> lightstep: basically a garbage collector usually has to know every type
13:12:37 <b_jonas> unless it's conservative
13:12:59 <b_jonas> so it has to know IORefs and all other low-level types
13:13:15 <rwbarton> dcoutts: unfortunately, the old version of package A depends on an old version of package B but A's .cabal file doesn't know about that fact.
13:13:19 <lightstep> yeah
13:13:37 <dcoutts> rwbarton: you can specify versions or constraints on both
13:13:45 <b_jonas> well, at least the primitive types. IORef itself might be a composite type implemented in haskell.
13:13:55 <dcoutts> rwbarton: cabal install "foo < 2" "bar < 2"
13:13:57 <b_jonas> from some other similar primitve type that is
13:14:38 <dons> ?users
13:14:39 <lambdabot> Maximum users seen in #haskell: 515, currently: 508 (98.6%), active: 22 (4.3%)
13:14:48 <rwbarton> dcoutts: oh, interesting, so  cabal install B-old A-old  isn't the same as  cabal install B-old; cabal install A-old
13:15:21 <rwbarton> dcoutts: Mysterious, but it works.  Thanks :)
13:17:52 <dcoutts> rwbarton: right, it considers both simultaneously and finds a consistent installation plan
13:18:17 <dcoutts> it uses a simple constraint solver
13:18:32 <rwbarton> dcoutts: And I guess it prefers packages specified on the command line over other versions that happen to be installed
13:18:58 <dcoutts> the ones given on the command line are considered as constraints
13:19:47 <daedra> lambdabot: help
13:19:48 <rwbarton> Right, so in this case the .cabal file for A just specifies B; it doesn't know that B-old will work but B-new will fail.  That's why I'm a little confused
13:20:03 <daedra> !help
13:20:04 <gbacon> is it a known problem that lambdabot out of darcs isn't building currently?
13:20:08 <mmorrow> , let unD = maybe undefined id . fromDynamic ; q = toDyn ((\x -> x `dynApp` (toDyn x)) (toDyn (\x -> x `dynApp` (toDyn x)))) in iterate unD q
13:20:10 <lunabot>  [<<Dynamic>>,<<Dynamic>>,<<Dynamic>>,<<Dynamic>>,<<Dynamic>>,<<Dynamic>>,...
13:20:16 <olsner> heh, "error-czeching"
13:20:40 <mmorrow> is that some <letter>-combinator>
13:20:43 <mmorrow> ?
13:20:51 <daedra> Lhelp
13:20:51 <dcoutts> rwbarton: right, it says it needs it but specifies no version constraint, but if you specify one on the command line then it's all good
13:20:58 <mmorrow> err, i guess it'd be y?
13:21:46 <daedra> how do I query lambdabot?
13:21:59 <mmorrow> > 42
13:22:00 <lambdabot>   42
13:22:08 <daedra>  > help
13:22:12 <mmorrow> @help
13:22:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:22:24 <daedra> mmorrow: thanks
13:22:28 <mmorrow> :)
13:26:07 <daedra> is there a separate bot for books/resources? if not what books do you recommend to learn haskell?
13:26:23 <Deewiant> @where realworldhaskell
13:26:24 <lambdabot> http://www.realworldhaskell.org/
13:26:36 <Vq^> @where programming in haskell
13:26:37 <lambdabot> I know nothing about programming.
13:26:46 <Deewiant> more accurately http://book.realworldhaskell.org/read/
13:26:54 <lambdabot> Title: Real World Haskell
13:27:05 <Vq^> http://www.cs.nott.ac.uk/~gmh/book.html
13:27:18 <lambdabot> Title: Programming in Haskell
13:28:01 <Philonous> It appears  one can build his own little dataflow language with MVars. Cool.
13:34:43 <mmorrow> Philonous: totally
13:35:30 <mmorrow> domino toppling with threads
13:38:17 <Philonous> I've recently read that Haskells threads are cheap (at least in ghc). So I guess parallel programming in haskell should be rather pain-free.
13:38:56 <Philonous> Or are there other pitfalls to overcome?
13:39:04 <Phyx-> hi, i'm having a problem with map (\([(x1,x2)],y)->(x1,(x2++y))) . it keeps telling me that it's getting into an endless recursion, which i don't really get
13:39:36 <noZone> ... the conservation of pain: you can shovel it here or there, but there is always pain.
13:39:45 <mml`> :t (\([(x1,x2)],y)->(x1,(x2++y)))
13:39:46 <lambdabot> forall t a. ([(t, [a])], [a]) -> (t, [a])
13:40:07 <Deewiant> that's one ugly type you've got there :-P
13:40:19 <Saizan> Phyx-: endless recursion or infinite type? however you've to give us more context
13:40:19 <mml`> truly
13:40:57 <mml`> :t map (\([(x1,x2)],y)->(x1,(x2++y)))
13:40:57 <b_jonas> > map (\([(x1,x2)],y)->(x1,(x2++y))) ([(3,"li")],"st")
13:40:58 <lambdabot> forall t a. [([(t, [a])], [a])] -> [(t, [a])]
13:40:58 <lambdabot>   Couldn't match expected type `[([(t, [a])], [a])]'
13:41:02 <b_jonas> > map (\([(x1,x2)],y)->(x1,(x2++y))) [([(3,"li")],"st")]
13:41:03 <lambdabot>   [(3,"list")]
13:41:06 <b_jonas> crazy
13:42:20 <mml`> > map (\([(x1,x2)],y)->(x1,(x2++y))) [([(3, "li")],"st")]
13:42:21 <lambdabot>   [(3,"list")]
13:42:42 <mml`> no less crazy now, even though it returned something :)
13:42:42 <leimy> does GHC 6.8.3 have the parallel garbage collector available?
13:42:58 <Deewiant> nope
13:43:25 <Deewiant> ?djinn ([(t, [a])], [a]) -> (t, [a])
13:43:25 <lambdabot> Error: Undefined type []
13:43:28 <Deewiant> meh
13:43:35 <Deewiant> ?djinn ([(t, Maybe a)], Maybe a) -> (t, Maybe a)
13:43:36 <lambdabot> Error: Undefined type []
13:43:44 <Deewiant> ?djinn (Maybe (t, Maybe a), Maybe a) -> (t, Maybe a)
13:43:45 <lambdabot> -- f cannot be realized.
13:44:05 <Deewiant> ?djinn Maybe a -> a
13:44:05 <lambdabot> -- f cannot be realized.
13:44:26 <leimy> ?djinn a -> a
13:44:27 <lambdabot> f a = a
13:44:42 <Phyx-> Saizan: i'm just trying the map one result to another
13:44:46 <Phyx-> i think the function terminates
13:44:52 <Phyx-> or rather i'm pretty sure
13:44:54 <Phyx-> *looks*
13:45:12 <Saizan> Phyx-: can you paste the code?
13:45:12 <Phyx-> yeah it does
13:45:22 <rwbarton> Maybe isn't very useful in djinn, since Maybe a is "equivalent" to ()
13:45:25 <Saizan> that function is not problematic by itslef
13:45:31 <rwbarton> ?djinn (Maybe a -> (), () -> Maybe a)
13:45:32 <lambdabot> f = (\ _ -> (), \ _ -> Nothing)
13:45:38 <Phyx-> Saizan: one sec
13:45:48 <Saizan> rwbarton: what?
13:45:59 <Deewiant> ?djinn Either a b -> (a -> b) -> b
13:46:00 <lambdabot> f a b =
13:46:00 <lambdabot>     case a of
13:46:00 <lambdabot>     Left c -> b c
13:46:00 <lambdabot>     Right d -> d
13:46:09 <Deewiant> ?djinn Maybe a -> a -> a
13:46:10 <b_jonas> rwbarton: even if a appears twice?
13:46:10 <lambdabot> f a b =
13:46:10 <lambdabot>     case a of
13:46:10 <lambdabot>     Nothing -> b
13:46:10 <lambdabot>     Just c -> c
13:46:10 <Saizan> ?djinn Maybe a -> (a -> b) -> b -> b
13:46:11 <lambdabot> f a b c =
13:46:12 <lambdabot>     case a of
13:46:14 <lambdabot>     Nothing -> c
13:46:16 <lambdabot>     Just d -> b d
13:46:33 <Saizan> Maybe a is not isomorphic to ()
13:46:33 <b_jonas> ?djinn Maybe a -> Int -> Either a Int
13:46:34 <lambdabot> Error: Undefined type Int
13:46:40 <b_jonas> ?djinn Maybe a -> Integer -> Either a Integer
13:46:41 <lambdabot> Error: Undefined type Integer
13:46:47 <b_jonas> ?djinn Maybe a -> int -> Either a int
13:46:48 <lambdabot> f a b =
13:46:48 <lambdabot>     case a of
13:46:48 <lambdabot>     Nothing -> Right b
13:46:48 <lambdabot>     Just c -> Left c
13:47:01 <rwbarton> Saizan: No, but it is isomorphic when you identify two functions whenever they have the same domain and target.
13:47:07 <Saizan> Maybe (forall a. a) is (if there's not bottom like in _|_(
13:47:17 <rwbarton> Saizan: And djinn is just telling you "is there a function with given domain and target"
13:47:52 <rwbarton> i.e. in intuitionistic logic, Maybe a = True | a = True = ()
13:48:27 <Deewiant> ?djinn () -> (a -> b) -> b -> b
13:48:28 <lambdabot> f _ _ a = a
13:48:28 <Saizan> djinn is giving you a total function with that type, if there's one
13:48:36 <b_jonas> rwbarton: I see
13:48:58 <b_jonas> um, not completely
13:49:01 <b_jonas> but whatever
13:49:01 <Saizan> rwbarton: what do you mean with Maybe a = True | a = True = () ?
13:49:01 <Deewiant> Saizan: and his point seems to be that replacing Maybe a with () or vice versa won't change whether djinn gives a result or not
13:49:04 <Deewiant> I think
13:49:06 <rwbarton> Saizan: Yes, which only depends on whether the corresponding proposition is true in intuitionistic logic
13:49:14 <b_jonas> ?djinn Maybe a -> int -> Either a int
13:49:15 <lambdabot> f a b =
13:49:15 <lambdabot>     case a of
13:49:15 <lambdabot>     Nothing -> Right b
13:49:15 <lambdabot>     Just c -> Left c
13:49:20 <b_jonas> ?djinn () -> int -> Either a int
13:49:21 <lambdabot> f _ a = Right a
13:49:28 <b_jonas> uh huh
13:49:31 <b_jonas> makes sense
13:49:48 <rwbarton> Right, sometimes it will use the Just a case if it happens to need an a somewhere.  That seems to be random.
13:49:52 <rwbarton> But it can't rely on it
13:51:25 <Saizan> i see, so Bool is isomorphic to () too in this sense?
13:51:39 <rwbarton> Saizan: Right
13:51:58 <Phyx-> Saizan: well, if i were to paste the function since it uses alot of other fucntion i would end up pasting more than a 100 lines, i can give the sample output the function i call the one i'm pasting over
13:52:04 <Phyx-> and the call to it
13:52:52 <rwbarton> Saizan: [a] also
13:53:34 <Saizan> Phyx-: we need to see where you call that function, and with which arguments
13:53:57 <Phyx-> how i call it is simple
13:54:00 <Phyx-> 		    	g s=collapse (f s)
13:54:00 <Phyx-> 		    	f = (parseElements <$> (between '(' ')'))
13:54:12 <Saizan> rwbarton: 1 + X, for every X ?
13:54:18 <Phyx-> with the type of f being
13:54:20 <Phyx-> f :: [Char] -> [([(Elements, [Char])], [Char])]
13:54:32 <Saizan> Phyx-: use hpaste.org
13:54:43 <mmorrow> ?djinn ([a] -> (), () -> [a])
13:54:43 <lambdabot> Error: Undefined type []
13:54:53 <ziman> ?djinn (() -> [a], [a] -> ())
13:54:53 <lambdabot> Error: Undefined type []
13:54:55 <mmorrow> ?djinn
13:54:55 <lambdabot> Cannot parse command
13:54:56 <ziman> aaa :)
13:54:58 <mmorrow> ?djinn help
13:54:58 <lambdabot> -- f cannot be realized.
13:55:01 <mmorrow> ?djinn env
13:55:02 <lambdabot> -- f cannot be realized.
13:55:07 <Saizan> ?djinn-env
13:55:08 <lambdabot> data () = ()
13:55:08 <lambdabot> data Either a b = Left a | Right b
13:55:08 <lambdabot> data Maybe a = Nothing | Just a
13:55:08 <lambdabot> data Bool = False | True
13:55:08 <lambdabot> data Void
13:55:10 <lambdabot> type Not x = x -> Void
13:55:12 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:55:15 <mmorrow> ah
13:55:39 <rwbarton> ?djinn-add data [a] = Empty | Cons a [a]
13:55:40 <lambdabot> Cannot parse command
13:55:48 <rwbarton> ?djinn-add data List a = Empty | Cons a (List a)
13:55:49 <lambdabot> Error: Recursive types are not allowed: List
13:55:56 <mmorrow> does djinn allow adding/subtracting to/from its env dynamically?
13:56:02 <mmorrow> heh, awesome
13:56:03 <Deewiant> yes, with ?djinn-add
13:56:13 <Deewiant> but list doesn't work as evidenced above :-/
13:56:21 <Deewiant> hmm
13:56:21 <mmorrow> aww, no recursive types...
13:56:36 <Deewiant> ?djinn-add data List a = Empty | Cons a (List2 a)
13:56:37 <lambdabot> Error: Undefined type List2
13:56:41 <Deewiant> meh
13:57:31 <mmorrow> ?djinn-add data List0 a b = Nil0 | Cons0 a b
13:57:38 <Deewiant> :-P
13:57:44 <mmorrow> ?djinn-env
13:57:45 <lambdabot> data () = ()
13:57:45 <lambdabot> data Either a b = Left a | Right b
13:57:45 <lambdabot> data Maybe a = Nothing | Just a
13:57:45 <lambdabot> data Bool = False | True
13:57:45 <lambdabot> data Void
13:57:51 <lambdabot> type Not x = x -> Void
13:57:52 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:57:57 <lambdabot> data List0 a b = Nil0 | Cons0 a b
13:58:47 <mmorrow> ?djinn-add data List a = Nil | Cons a (List0 () (List a))
13:58:47 <lambdabot> Error: Recursive types are not allowed: List
13:59:25 <Deewiant> you can define lists up to a certain length :-)
13:59:44 <mmorrow> i was trying to pull a fast one. didn't work :p
13:59:49 <ziman> ?djinn-add data Mu f = In (f (Mu f))
13:59:50 <lambdabot> Error: Recursive types are not allowed: Mu
13:59:53 <Deewiant> data List a = Nil | Cons1 a | Cons2 a a | Cons3 a a a | Cons4 a a a a ...
14:00:09 <Deewiant> ?djinn-del List0
14:00:43 <rwbarton> djinn is supposed to return total functions, and you can write recursive functions without explicit recursion if you allow recursive datatypes
14:00:53 <Deewiant> ?djinn-ver
14:00:53 <lambdabot> Djinn version 2008-08-10.
14:01:08 <mmorrow> ah
14:01:12 <Deewiant> wow, that's new
14:01:13 <Deewiant> http://www.augustsson.net/Darcs/Djinn/NEWS
14:01:38 <Saizan> i wonder how hard would be to extend it with Mu/Nu and cata/ana, so you get termination for free
14:01:55 <mmorrow> termination being defined as what?
14:02:04 <rwbarton> ?djinn-add class Functor f where fmap :: (a -> b) -> f a -> f b
14:02:16 <rwbarton> ?djinn (b -> c) -> f b -> f c
14:02:16 <lambdabot> -- f cannot be realized.
14:02:23 <rwbarton> ?djinn (a -> b) -> f a -> f b
14:02:24 <lambdabot> -- f cannot be realized.
14:02:29 <rwbarton> ?djinn Functor f => (b -> c) -> f b -> f c
14:02:30 <Saizan> mmorrow: that every closed term is strong normalizing
14:02:30 <lambdabot> -- f cannot be realized.
14:02:31 <mmorrow> ?djinn-add class CoFunctor f where cofmap :: (a -> b) -> f b -> f a
14:02:32 <ushdf> > <3
14:02:32 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
14:02:33 <lambdabot>  ...
14:02:35 <rwbarton> ?djinn Functor f => (a -> b) -> f a -> f b
14:02:36 <lambdabot> f = fmap
14:03:03 <rwbarton> ?djinn-del Functor
14:03:04 <Saizan> well, for the codata part termination is more subtle i guess?
14:03:20 <mmorrow> Saizan: hmm. that mean that evaluating to nf completes in finite time, right?
14:03:25 <mmorrow> s/mean/means/
14:03:28 <Saizan> yes
14:04:44 <Saizan> http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
14:04:56 <mmorrow> ?djinn (Funtor f) => f (f a -> a) -> f a
14:04:56 <lambdabot> Error: Class not found: Funtor
14:04:57 <lambdabot> http://tinyurl.com/62s2nh
14:05:01 <mmorrow> ?djinn (Functor f) => f (f a -> a) -> f a
14:05:01 <lambdabot> Error: Class not found: Functor
14:05:03 <mmorrow> grr
14:05:16 <mmorrow> ah, i keep forgetting
14:05:31 <mmorrow> (no recursion..)
14:05:33 <Deewiant> might as well keep it there
14:05:34 <Deewiant> ?djinn-add class Functor f where fmap :: (a -> b) -> f a -> f b
14:05:39 <mmorrow> ?djinn (Functor f) => f (f a -> a) -> f a
14:05:39 <lambdabot> -- f cannot be realized.
14:06:00 <rwbarton> djinn doesn't understand that the type signature of fmap should be forall a b. (a -> b) -> f a -> f b
14:06:06 <rwbarton> it thinks a and b are type constants
14:06:15 <mmorrow> ahh, i see now
14:06:41 <rwbarton> So, that makes the Functor class not very useful
14:06:44 <rwbarton> in djinn
14:06:48 <Deewiant> I don't. What function has that type :-P
14:07:42 <rwbarton> @mmorrow-djinn (Functor f) => f (f a -> a) -> f a   :)
14:07:43 <lambdabot> Unknown command, try @list
14:08:45 <mmorrow> sweet: http://www.augustsson.net/Darcs/MersenneTwister/MersenneTwister.hs
14:08:47 <lambdabot> http://tinyurl.com/4oywuu
14:08:56 <Apocalisp> @hoogle [a] -> [a] -> ([a],[a],[a])
14:08:57 <lambdabot> No results found
14:10:01 <BMeph> Deewiant: That's the signature for loeb. :)
14:10:55 <mmorrow> , let go a = fmap ($ go a) a in go [(!!2),\x -> 2 * (x!!0), const 23]
14:10:56 <lunabot>  [23,46,23]
14:11:16 <BMeph> f xs = fmap (\fs -> fs (f xs))
14:11:27 <byorgey> loeb still blows my mind.
14:11:34 <mmorrow> , let go f a = f ($ go f a) a in go fmap [(!!2),\x -> 2 * (x!!0), const 23]
14:11:36 <lunabot>  [23,46,23]
14:11:42 <BMeph> bryorgey: As well it should... ;)
14:11:42 <mmorrow> , let go f a = f ($ go f a) a in go
14:11:44 <lunabot>  luna: No instance for (GHC.Show.Show
14:11:44 <lunabot>                     ((((a -> b) -> b) -> t -> a) -> t -> a))
14:11:44 <lunabot>    arising from a use of `GHC.Show.show' at <interactive>:1:43-83
14:11:49 <roconnor> @type loeb
14:11:50 <lambdabot> Not in scope: `loeb'
14:11:56 <roconnor> @where loeb
14:11:56 <lambdabot> I know nothing about loeb.
14:12:07 <BMeph> I'm not sure if the Comonadi version is as impressive, but it should be... :)
14:12:09 <roconnor> oh f (f a -> a) -> f a /
14:12:12 <roconnor> oh f (f a -> a) -> f a ?
14:12:31 <BMeph> *Comonad
14:12:45 <mmorrow> @let cocopuff f a = f ($ cocopuff f a) a :: ((((a -> b) -> b) -> r -> a) -> r -> a))
14:12:45 <lambdabot>   Parse error
14:12:46 <roconnor> Is box really a comonad?
14:13:15 <mmorrow> @let cocopuff = (\f a -> f ($ cocopuff f a) a) :: ((((a -> b) -> b) -> r -> a) -> r -> a))
14:13:16 <lambdabot>   Parse error
14:13:18 <b_jonas> this costuff is crazy
14:13:50 <BMeph> <rwbarton>	@mmorrow-djinn (Functor f) => f (f a -> a) -> f a  <"mmorrow-djinn">	f xs = fmap (\fs -> fs (f xs))
14:13:54 <olsner> 'tis corazy!
14:14:32 <BMeph> roconnor: Isn't Box the Monad, and Diamond the Comonad? :)
14:14:34 <mmorrow> @pl \xs -> fmap (\fs -> fs (f xs))
14:14:35 <lambdabot> fmap . flip id . f
14:14:39 <mmorrow> swEET
14:14:41 <BMeph> Or is it the other way around?
14:14:42 <olsner> mmorrow: is a cocopuff a puff?
14:15:03 <mmorrow> i'm just not sure
14:15:04 <ziman> is a coconut a nut?
14:15:11 <BMeph> b_jonas: Don't you mean it's "cosane"? ;p
14:15:31 <roconnor> BMeph: I'm not sure.  I thought they were neither, but I forget.
14:15:54 <mmorrow> coco* seems to add a delicious factor to * is many cases, though
14:16:03 <mmorrow> cocopebbles vs. pebbles
14:16:07 <mmorrow> etc
14:16:17 <BMeph> roconnor: Well, s//isomorphic to/
14:16:25 <byorgey> cocoa vs. a
14:16:58 <mmorrow> totally
14:17:09 <tristes_tigres> hi
14:23:43 <tristes_tigres> ghc 6.10.1 beta is released. How close is the actual release, I wonder
14:27:00 <b_jonas> BMeph: maybe, lol
14:27:53 <hugo__> hey people
14:27:59 <hugo__> try to google for: the answer to life, the universe and everything
14:28:09 <EvilTerran> @go the answer to life, the universe and everything =
14:28:12 <lambdabot> http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything
14:28:12 <lambdabot> Title: Answer to Life, the Universe, and Everything - Wikipedia, the free encyclopedia
14:28:16 <hugo__> nah
14:28:22 <hugo__> you gotta go with your browser
14:28:25 <hugo__> or else it wont work
14:28:26 <EvilTerran> hm, apparently lambdabot doesn't do google calc results
14:28:31 <EvilTerran> i know what it does :P
14:28:33 <hugo__> :D
14:28:38 <hugo__> hehehe
14:28:46 <EvilTerran> http://google.com/search?q=the+answer+to+life+the+universe+and+everything+=
14:28:48 <lambdabot> Title: the answer to life the universe and everything = - Google Search, http://tinyurl.com/4snskz
14:28:55 <SamB_XP>  @go the answer to life, the universe and everything
14:28:58 <SamB_XP> @go the answer to life, the universe and everything
14:29:00 <lambdabot> http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything
14:29:00 <lambdabot> Title: Answer to Life, the Universe, and Everything - Wikipedia, the free encyclopedia
14:29:04 <ddarius> @google 1 + 1
14:29:05 <lambdabot> 1 + 1 = 2
14:29:16 <SamB_XP> hmm, I could have sworn it had calculator support ...
14:29:22 <SamB_XP> and apparantly it does
14:29:52 * EvilTerran goes back to trying to thrash out a quick-n-dirty proof assistant
14:30:02 <olsner> @go "the answer to life, the universe and everything"
14:30:05 <lambdabot> http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything
14:30:05 <lambdabot> Title: Answer to Life, the Universe, and Everything - Wikipedia, the free encyclopedia
14:30:08 <olsner> nope, okay
14:30:12 <EvilTerran> as someone who has never written a proof assistant in haskell, this is quite tricky
14:30:14 <SamB_XP> @go the answer to life, the universe and everything + 1
14:30:16 <lambdabot> http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything
14:30:16 <lambdabot> Title: Answer to Life, the Universe, and Everything - Wikipedia, the free encyclopedia
14:30:20 <EvilTerran> enough!
14:30:25 <EvilTerran> :P
14:30:36 <EvilTerran> you could play with it in PM, try to trick it into working there
14:31:01 <olsner> easy for you to say :)
14:31:12 <EvilTerran> wha?
14:31:17 <b_jonas> so if a maybe is a -> (b -> a) -> a, then a comaybe is (a -> a -> b) -> a
14:31:45 <EvilTerran> b_jonas, er, that type strikes me as somewhat empty
14:32:04 <b_jonas> EvilTerran: yeah, looks like
14:32:19 <b_jonas> but don't they say that a cofoo is like a foo but with all the function arrows reversed?
14:32:31 <b_jonas> perhaps a comaybe is empty
14:32:33 <ttt--> is there a way to use foo and bar as setters if you define a type like Foo = Foo { foo :: String, bar :: String }?
14:32:43 <b_jonas> or perhaps we should write it as a class
14:32:44 <b_jonas> like
14:33:27 <b_jonas> class Maybe mb where { maybe :: mb -> a -> (b -> a) -> a; }
14:33:29 <EvilTerran> ttt--, not directly, no
14:33:31 <b_jonas> no wait
14:33:37 <b_jonas> class Maybe mb where { maybe :: mb b -> a -> (b -> a) -> a; }
14:33:51 <b_jonas> in which case, a comaybe would be like
14:33:51 <ttt--> EvilTerran, im willing to settle for indirectly
14:33:58 <EvilTerran> ttt--, given x :: Foo, you can write x { foo = newValueForFoo }
14:34:15 <EvilTerran> or you can look into "functional references"
14:34:22 <EvilTerran> ?go functional references
14:34:24 <lambdabot> No Result Found.
14:34:27 <b_jonas> class CoMaybe cmb where { maybe :: ((a -> b -> a) -> a) -> cmb b; }
14:34:27 <EvilTerran> ...
14:34:30 <ddarius> setFoo rec x = rec { foo = x }
14:34:35 <b_jonas> that looks less empty
14:34:59 <b_jonas> but not too useful
14:35:29 <ttt--> ok thanks :)
14:35:33 * b_jonas googles comaybe and it says "Did you mean: maybe"
14:36:17 <BMeph> @cogoogle maybe
14:36:26 <lambdabot> http://www.maybe.com/
14:36:26 <lambdabot> Title: Maybe.com: some sentences with "maybe" or "may be"
14:36:34 <bos> what's the current state of GHC on ARM?
14:37:17 <EvilTerran> argh, the design space i'm playing with for my proof assistant is too big
14:37:20 <EvilTerran> i keep getting lost
14:37:35 <BMeph> bos: Wouldn't it be fun to have GHC on Larabee, before they release the chip? ;)
14:37:55 <bos> BMeph: it would indeed.
14:38:14 <b_jonas> lol
14:38:18 <b_jonas> what does cogoogle do?
14:38:24 <EvilTerran> if we can get GHC on OpenMoko, I may have a burst of extravagance and buy a Neo FreeRunner to play with
14:38:48 <b_jonas> @help cogoogle
14:38:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:38:50 <EvilTerran> actually, it's linux-based, so that shouldn't be too hard
14:38:51 <EvilTerran> i guess
14:39:00 <EvilTerran> http://www.openmoko.com/product.html <- SHINEY
14:39:09 <lambdabot> Title: openmoko.com | Products
14:41:31 <b_jonas> @codjinn Maybe a -> a
14:41:32 <lambdabot> -- f cannot be realized.
14:41:36 <b_jonas> strange
14:41:46 <b_jonas> @codjinn a -> Maybe a
14:41:47 <lambdabot> f = Just
14:41:53 <EvilTerran> i presume codjinn is getting typo-corrected to djinn
14:41:55 <b_jonas> shouldn't it reverse the arrow?
14:42:01 <b_jonas> typo-corrected?
14:42:08 <b_jonas> @djunn a -> Maybe a
14:42:08 <lambdabot> f = Just
14:42:11 <b_jonas> possible, yeah
14:42:13 <EvilTerran> @djinnxx a -> a
14:42:14 <lambdabot> f a = a
14:42:21 <EvilTerran> probable
14:42:25 <EvilTerran> likewise cogoogle
14:42:51 <EvilTerran> which is a shame, 'cos it'd be nice to have a @cogoogle that you could give a URL to and get back a search term for which it was the first result :P
14:43:10 <b_jonas> EvilTerran++ lollollol
14:43:16 <EvilTerran> :D
14:43:19 <b_jonas> depends on the ;hl= parameter though
14:43:50 <ddarius> I'm pretty sure the url itself would give you the url as the first result.
14:43:53 <b_jonas> &hl= parameter actually for google doesn't like semicolons
14:44:05 <EvilTerran> ddarius, that's cheating :P
14:44:28 <b_jonas> yep, it should give the _simplest_ search terms
14:44:41 <EvilTerran> by breadth-first search!
14:44:53 <b_jonas> still, the dependence from &hl= is quite significant
14:45:12 <EvilTerran> i'll go harass my friend who works for google into implementing such a thing as his 20% project :P
14:49:00 <b_jonas> I guess @codjinn a -> Maybe a does the same as @djinn Comaybe a -> a
14:49:23 <b_jonas> ot should do at least
14:49:38 <EvilTerran> i'm still not sure what Comaybe is
14:49:43 <lilac> codjinn should be a synonym for @type
14:49:55 <EvilTerran> and cotype a synonym for djinn?
14:50:03 <b_jonas> sure
14:50:08 <b_jonas> makes sense
14:50:25 <EvilTerran> if anything, @cotype is more a self-explanatory name than @djinn
14:50:33 <EvilTerran> *is a more
14:50:52 <leimy> dons: so far Haskell Platform looks like a really sane idea
14:50:53 <leimy> :-)
14:51:25 <b_jonas> and @corun should compress an output to a short code that generates it
14:51:32 <hugo__> i like the haskell platform, whatever that is
14:51:43 <hugo__> it has haskell, and platform in the name, so it can only be good
14:51:52 <b_jonas> and @cohelp should find the command you need given a description
14:51:58 <EvilTerran> hehe
14:52:27 <EvilTerran> saying :) on its own should make lambdabot say "@cobot"
14:52:41 <b_jonas> lol
14:52:44 <b_jonas> @bot
14:52:44 <lambdabot> :)
14:52:46 <b_jonas> :)
14:52:50 <EvilTerran> :)
14:53:03 <SamB_XP> EvilTerran: you mean @cobotsnack
14:53:09 <EvilTerran> that too
14:53:13 <SamB_XP> both?
14:53:17 <b_jonas> what would @mpose do then?
14:53:20 <EvilTerran> at random? i dunno
14:53:29 <dons> leimy: sane is good.
14:53:34 <EvilTerran> b_jonas, er, rot?
14:53:38 <b_jonas> or @cohoogle
14:53:53 <b_jonas> EvilTerran: heh
14:54:01 <leimy> dons: pre-ordered the book btw
14:54:06 <leimy> looks like a winner
14:54:09 <hugo__> does haskell has a "Date" type constructor ?
14:54:13 <bos> thanks!
14:54:36 <EvilTerran> hugo__, there's things in Data.Time.*
14:54:41 <dons> woo
14:54:48 <hugo__> allright, ill check them :) thanks EvilTerran
14:55:04 <hugo__> i can't wait to be a haskell l33tz0r, so that i can also help people the same way you guys help me :)
14:56:20 <BMeph> dons, bos: cha-CHING! ;)
14:56:54 <smtms> hugo__, start your Ph.D. studies now! ;-)
14:56:58 * EvilTerran settles down to read http://www.cs.cornell.edu/Info/Projects/NuPrl/cs671/cs671-fa99/postscript%20files/makedoc.ps
14:57:00 <lambdabot> http://tinyurl.com/4dndfl
14:57:57 <hugo__> :D
14:58:24 <hackage> Uploaded to hackage: maccatcher 0.1.0
14:59:05 <Phyx-> hi, can anyone help me with this http://phyx.pastebin.com/d1f7f8e34
14:59:25 <hugo__> why is day 0 1858-11-17 ?
14:59:33 <hugo__> is it the haskell curry birthday ?
15:00:03 <bos> no, just the convention.
15:00:04 <lilac> only if he lived to be 124
15:00:16 <hugo__> aha
15:00:19 <SamB_XP> who's convention is that ?
15:00:30 <bos> it's the base of the Modified Julian Day system
15:00:38 <hugo__> ah, nice
15:01:18 <Phyx-> Saizan: http://phyx.pastebin.com/d1f7f8e34 is the source
15:01:30 <bos> http://en.wikipedia.org/wiki/Julian_Day
15:02:35 <rwbarton> Phyx-: I don't think the error you pasted can be produced by this code, it's probably coming from somewhere else
15:02:39 <rwbarton> Phyx-: are you using Parsec?
15:03:38 <Phyx-> rwbarton: it's produced by that code according to ghci, the place is specifically in the collapse (f s) part, and no i'm not using any external parser lib
15:04:09 <Phyx-> i've used the collapse function before in other functions
15:04:16 <EvilTerran> well, there are no non-exhaustive patterns in lambdas there
15:04:17 <Phyx-> just with this one it doesn't like it
15:04:57 <EvilTerran> what's the source of "collapse"?
15:04:58 <lilac> Phyx-: is Parser a function type?
15:05:00 <rwbarton> yeah, there's only one lambda, and it's clearly exhaustive
15:05:19 <Phyx-> lilac: yes
15:05:38 <ddarius> "xmonad: High assurance that there aren't bugs such as overlapping windows"
15:06:33 <MyCatVerbs> ddarius: "unless some freak adds that feature in anyway, but don't worry. We'll ostracise'm."
15:06:53 <MyCatVerbs> ddarius: (er, floating windows? meta+click, meta+t? :)
15:10:49 <Phyx-> http://phyx.pastebin.com/d1a59e68f <-- can it be that it just doesn't know what to match against?
15:11:34 <rwbarton> Phyx-: I'm not sure I understand the question.  Certainly I can imagine definitions of collapse that would produce that behavior.
15:12:22 <Saizan> yeah, the relevant thing is the definition of collapse
15:12:42 <Phyx-> so basically i need to redefine collapse? i'm just trying to map one type to another
15:12:45 <rwbarton> e.g. collapse = \ [([((NewElements NewElement,""),(NoElements,"e5"))],"somethingelse")] -> []
15:13:53 <Saizan> redefine or fix it
15:14:16 <Saizan> if you want to call on inputs such as s
15:14:50 <Saizan> "it"
15:15:22 <Phyx-> ok
15:25:57 <mjrosenb> hey, i remember someone in here talking about source preproc.  is there any documentation on this?
15:27:50 <MyCatVerbs> mjrosenb: in the sense of #ifdefs? The -cpp flag turns it on in GHC, as does the {-# LANGUAGE CPP #-} pragma.
15:29:14 <MyCatVerbs> mjrosenb: it's pretty much the standard C preprocessor, but I'm not sure whether it has some of the more esoteric (read: subtle and confusing and very, very fun) features.
15:29:56 <MyCatVerbs> mjrosenb: you might also want to try man 1 cpphs, if you have GHC installed. :)
15:30:33 <mjrosenb> this was for adding disjunctive patterns to haskell
15:30:51 <mjrosenb> so i feel that it would be a bit more powerful than cpp
15:31:02 <MyCatVerbs> mjrosenb: oh. Read up on Template Haskell, and... I've forgotten the name of the feature.
15:32:09 <mjrosenb> MyCatVerbs: is it possible to do something in template haskell, and not encase it in $() ?
15:32:55 <MyCatVerbs> mjrosenb: that's exactly the one, but I can't remember what it's called. D'oh. :D
15:33:22 <mjrosenb> whee..
15:33:41 <mjrosenb> it also gives you a parsed haskell expression, i assume
15:33:58 <mjrosenb> err
15:34:08 <BMeph> MyCatVerbs: Quasiquoting, maybe? ;)
15:34:27 <mjrosenb> there's a way to use a function that does a transform on the ast of some haskell?
15:34:35 <mjrosenb> s/there's/is there/
15:34:56 <sjanssen> mjrosenb: yes, Template Haskell
15:35:09 <Saizan> yup something like $(func [| <some haskell> |])
15:35:25 <MyCatVerbs> BMeph: ah, that's the one.
15:35:51 <EvilTerran> although you can't extend the syntax within [|...|]s that way - it has to be valid before you manipulate it
15:35:55 <MyCatVerbs> BMeph: you can tell I haven't been following this place much lately. :)
15:36:00 <mjrosenb> Saizan: so every example i've seen is handed a value, not an ast.
15:36:00 <EvilTerran> that's what the quasiquoting's for
15:36:12 <EvilTerran> , [| \x -> x + 1 |]
15:36:14 <lunabot>  LamE [VarP x_0] (InfixE (Just (VarE x_0)) (VarE +) (Just (LitE (IntegerL ...
15:36:32 <mjrosenb> oic...
15:36:57 <EvilTerran> [|...|] is the inverse of $(...)
15:37:08 * mjrosenb thought that the [|...|] notation had been snagged for parallelized vectors, and whatnot
15:37:18 <EvilTerran> ideally, you'd never need to use those LamE, VarP, etc constructors directly
15:37:20 <sjanssen> mjrosenb: that's [: :]
15:37:25 <mjrosenb> my bad.
15:37:31 <EvilTerran> and you could work entirely with $(...) and [|...|]
15:37:41 <EvilTerran> unfortunately, the syntax is too limited for that
15:37:54 <EvilTerran> in part because there's no [|...|] analogue for patterns
15:38:04 <EvilTerran> also $(...) doesn't work in types, iirc
15:38:20 <rwbarton> , [t| Integer |]
15:38:23 <lunabot>  ConT Integer
15:38:28 <rwbarton> , [p| (x,y) |]
15:38:31 <lunabot>  luna: Tempate Haskell pattern brackets are not supported yet
15:38:48 <rwbarton> , [d| f x = x * x |]
15:38:51 <lunabot>  FunD f [Clause [VarP x_0] (NormalB (InfixE (Just (VarE x_0)) (VarE *) (Ju...
15:39:09 <Saizan> "Tempate" :)
15:39:28 <rwbarton> !
15:39:30 <EvilTerran> , let roll 0 = [| id |]; roll i | i > 0 = [| \f -> $(roll (i-1)) . flip f |] in ($(roll 0) (,,) 1 2 3, $(roll 1) (,,) 1 2 3, $(roll 2) (,,) 1 2 3)
15:39:31 <lunabot>  luna: GHC stage restriction: `roll'
15:39:32 <lunabot>    is used in a top-level splice, and must be imported, not defined locally
15:39:34 <EvilTerran> grr
15:39:46 <EvilTerran> i'm sure that worked a few days ago
15:40:31 <mjrosenb> Prelude Language.Haskell.TH> [| \x->x+1 |]
15:40:31 <mjrosenb> <interactive>:1:1: parse error on input `|'
15:40:32 <EvilTerran> although i remember that stage restriction thing from way before lunabot even existed, so now i'm just confused
15:40:42 <EvilTerran> mjrosenb, :set -XTemplateHaskell
15:41:06 <mjrosenb> ahh.
15:41:14 <EvilTerran> for the syntactic extensions
15:41:33 <mjrosenb> EvilTerran: i also need to import something else apparently
15:41:41 <EvilTerran> and :m + Language.Haskell.TH for the types and functions
15:42:07 <mjrosenb>     No instance for (Show ExpQ)
15:43:08 <Saizan> EvilTerran: mmorrow changed something in the eval mechanism recently so you can use "eval" in your expressions, it might be related that
15:43:09 <EvilTerran> indeed not
15:43:16 <EvilTerran> ExpQ = Q Exp
15:43:23 <EvilTerran> Q is the monad that splices work in
15:43:46 <EvilTerran> i forget how i got around that
15:44:29 <EvilTerran> mjrosenb, try "runQ [| ... |]"
15:44:45 <EvilTerran> runQ :: Q a -> IO a, effectively
15:46:27 <mjrosenb> EvilTerran: that did it
15:46:29 <mjrosenb> thanks
15:48:57 <EvilTerran> np :)
15:49:31 <EvilTerran> /nick HelpfulTerran
15:51:22 <Peaker> EvilTerran: that would break the nick's coolness
15:51:23 <rwbarton> you're helping someone use TH.  That's pretty evil :)
15:52:05 <EvilTerran> Peaker, yeah, i know, then it wouldn't be an interesting anagram any more...
15:52:07 <EvilTerran> i think...
15:52:19 <ziman> anagram of what?
15:52:30 <EvilTerran> > sort "evilterran" == sort "irrelevant"
15:52:31 <lambdabot>   True
15:52:43 <ziman> oh :)
15:52:47 <EvilTerran> :D
15:54:12 <Peaker> how do you get a list of lines from a file handle?
15:54:42 <chessguy> @hoogle Handle
15:54:43 <lambdabot> System.IO data Handle
15:54:43 <lambdabot> Control.Exception handle :: (Exception -> IO a) -> IO a -> IO a
15:54:43 <lambdabot> Control.Exception handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
15:54:43 <Peaker> lines . hGetContents I guess?
15:54:44 <Saizan> fmap lines . hGetContents
15:54:50 <Peaker> thanks
15:55:01 <Saizan> with usual disclaimer about lazy IO
15:55:03 <MyCatVerbs> Saizan: you mean that without the (.), surely?
15:55:20 <Saizan> ?type fmap lines . hGetContents
15:55:21 <lambdabot> Not in scope: `hGetContents'
15:55:43 <Saizan> MyCatVerbs: however no, since hGetContents takes a parameter, the handle
15:55:51 <MyCatVerbs> Saizan: oh right of course, my bad.
15:56:10 <EvilTerran> lines .: hGetContents in caleskell :P
15:56:20 <EvilTerran> (where (.) = fmap and (.:) = (.).(.))
15:56:29 <Peaker> why does "x<-blah" show x in ghci?
15:56:32 <EvilTerran> ?type fmap fmap fmap
15:56:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:57:04 <ziman> filter ((sort "helpfulterran" ==) . sort) . lines <$> readFile "/usr/share/dict/cracklib-words"
15:57:04 <Saizan> Peaker: :set -fno-print-bind-result
15:57:07 <ziman> []
15:57:10 <ziman> :(
15:57:32 <Peaker> Saizan: thanks
15:57:33 <EvilTerran> the sequence of types you get from (fmap, fmap fmap, fmap fmap fmap, fmap fmap fmap fmap, ...) is quite interesting, actually
15:57:44 <bd_> :t fix fmap
15:57:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
15:57:46 <lambdabot>       Expected type: (a -> b) -> a -> b
15:57:46 <lambdabot>       Inferred type: (a -> b) -> f a -> f b
15:57:50 <bd_> :(
15:58:36 <mjrosenb> Peaker: :set -fno-print-bind-contents
15:58:42 <mjrosenb> gah
15:58:50 <mjrosenb> efb, and it looks like i got it wrong
15:58:53 <mjrosenb> : (
15:59:57 <rwbarton> EvilTerran: Wow, that's weird.
16:01:28 <EvilTerran> yeah, it's kinda unexpected
16:03:09 <ivanm> mmorrow: you around?
16:08:34 <povman> monad monad monad monad monad monad monad monad monad, FUNCTION FUNCTION, etc
16:10:30 <chessguy> is that some kind of gregorian chant?
16:11:06 <povman> more of a variant of the badger mushroom song
16:12:35 <mml`> oh shit, that is going to be stuck in my head all night
16:12:42 <mml`> ^ povman
16:12:56 <povman> lala :)
16:13:37 <ivanm> povman: so what would be the equivalent of "a snake!"? "unsafe, unsafe!"? :p
16:14:03 <povman> haha yeah - although 'list' has the right number of syllables
16:15:40 <TomMD> Glória in excélsis Monade, et in terra pax homínibus bonć háscell.
16:15:49 <TomMD> Gregorian Haskell, you say?
16:15:55 * chessguy giggles
16:18:06 <povman> Fame in the highest Monade , and upon earth peace hominibus bonc hascell.
16:18:25 * lispy wonders if the "llama llama llama duck" song has a haskell variant
16:18:31 <povman> uh oh
16:18:43 <EvilTerran> here's a lambda, there's a lambda, and another little lambda
16:18:45 <FunctorSalad> enjoy the soundness
16:19:06 <FunctorSalad> (think I got that one from here actually)
16:19:24 <FunctorSalad> http://www.cs.washington.edu/orgs/student-affairs/cseband/studio/Enjoy%20The%20Soundness.mp3
16:19:36 <lambdabot> http://tinyurl.com/4nx9lx
16:19:56 <FunctorSalad> it mentions ML though. what is our diplomatic relationship to ML?
16:20:11 <FunctorSalad> ;-)
16:20:25 <lispy> We're lazier than ML
16:20:31 <lispy> That's about it, as far as I can tell
16:20:55 <EvilTerran> lazy lambda, constant lambda, lambda lambda LET
16:21:05 <FunctorSalad> so it isn't like the (mostly jokular) math-physics infights? ;-)
16:22:11 <adu> I have a question about CFile
16:22:13 <povman> FunctorSalad: is that a drum machine?
16:22:23 <adu> does CFile represent "FILE" or "FILE *"?
16:22:34 <FunctorSalad> povman: huh? it isn't my song ;-)
16:22:38 <EvilTerran> I was once a monad, I bound in a do, but i never saw the way, the arrow could bind too...
16:22:41 <povman> oh :p
16:23:10 <FunctorSalad> povman: and I didn't listen recently enough to take a guess
16:24:23 <EvilTerran> i was only h-ninety-eight, but it came after, and now listen, PhD, to the typechecker!
16:24:30 <povman> EvilTerran: these lyrics belong on the haskell wiki
16:24:40 <EvilTerran> s/ninety/nine/, too many syllables
16:24:59 <povman> EvilTerran: i was just h98?
16:25:11 <EvilTerran> povman, well, it goes with "i was once a monad"
16:25:15 <povman> or but
16:25:28 <EvilTerran> ah, syllables again
16:25:37 * Boney is expecting one of these songs to be about lazyness.
16:26:23 <sereven>  [1..] bottles of beer on the wall, [1..] bottles of beer. Take one down pass it around, [2..] bottles of beer on the wall. [2..] bottles of beer on the ....
16:26:58 <FunctorSalad> hehe
16:27:41 <EvilTerran> did you ever see a lambda / pass a lambda / to a lambda? / lambda's lambda / adds a lambda / lambda, lambda, let!
16:28:15 <adu> does anyone know about CFile?
16:28:28 <Boney> let beer_song bottles = show(bottles) ++ " bottles of beer on the wall, " ++ show(bottles) ++ " bottles of beer. Take one down, pass it around, " ++ (beer_song (bottles - 1))
16:28:31 <FunctorSalad> sereven: unlike lists though, you can't put bottles in a cycle and suddenly have infinitely many
16:28:33 <Boney> beer_song 99
16:28:37 <Boney> > let beer_song bottles = show(bottles) ++ " bottles of beer on the wall, " ++ show(bottles) ++ " bottles of beer. Take one down, pass it around, " ++ (beer_song (bottles - 1))
16:28:37 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
16:28:37 <lambdabot>  ...
16:28:55 <r3m0t> Boney: you're thinking in brackets
16:28:59 <povman> Boney: that sentence will forever remain unevaluated
16:29:21 <Boney> It's been a little while since I've used haskell.
16:29:28 <Boney> I'm usually using Mercury.
16:29:32 <povman> adu: according to the docs it's just FILE
16:29:33 <Boney> anyway, you get the idea.
16:29:38 <adu> povman: ok thanks
16:29:40 <Boney> also, there's no base-case in my song.
16:29:43 <FunctorSalad> unsafePerformBeerIntake
16:29:56 <povman> adu: i guess if it doesn't work that way, try using it as FILE * :P
16:29:57 <adu> povman: I also just found this function: "fdToCFile :: Fd -> IO (Ptr CFile)" which also answers it :P
16:30:18 <adu> :)
16:31:34 <Boney> > let beer_song bottles = (show bottles) ++ " bottles of beer on the wall, " ++ (show bottles) ++ " bottles of beer. Take one down, pass it around, " ++ (beer_song (bottles - 1))
16:31:34 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
16:31:35 <lambdabot>  ...
16:31:48 <Boney> that message is unhelpful.
16:31:54 <povman> > let beer_song bottles = show bottles ++ " bottles of beer on the wall, " ++ show bottles ++ " bottles of beer. Take one down, pass it around, " ++ (beer_song (bottles - 1)) in beer_song 99
16:31:56 <lambdabot>   "99 bottles of beer on the wall, 99 bottles of beer. Take one down, pass it...
16:31:59 <Saizan> Boney: you need an in
16:32:27 <povman> someone allow large output from lambdabot kthx
16:32:35 <Boney> oh, I was using it like GHCi.
16:37:22 <lispy> ?let beer_song bottles = show bottles ++ " bottles of beer on the wall, " ++ show bottles ++ " bottles of beer.  Take one down, pass it around, "++ beer_song (bottles - 1)
16:37:23 <lambdabot>  Defined.
16:37:34 <lispy> > drop 100 (beer_song 99)
16:37:35 <lambdabot>   "er on the wall, 98 bottles of beer.  Take one down, pass it around, 97 bot...
16:37:42 <ivanm> does anyone else here find that wiki.darcs.net has no text?
16:38:08 <lispy> ivanm: works for me
16:38:16 <povman> ivanm: full to the brim
16:38:17 <lispy> "Distributed. Interactive. Smart.
16:38:18 <lispy> Darcs is a free, open source, source code management system. "
16:38:27 <ivanm> hmmmm.... for some reason wiki.darcs.net and google have no text! :o
16:38:45 <povman> ivanm: check the light on your monitor. is it turned on?
16:38:47 <lispy> > drop 1000 $ beer_song 99
16:38:49 <lambdabot>   "around, 87 bottles of beer on the wall, 87 bottles of beer.  Take one down...
16:38:57 <ivanm> @slap povman
16:38:58 * lambdabot karate-chops povman into two equally sized halves
16:39:04 <BMeph> ivanm: Someone's spoofing ya, man - run! ;)
16:39:17 <ivanm> oh, looks like it's because of fontconfig changes I made
16:39:34 <povman> i feel a sense of duality
16:41:00 <povman> does anyone know what co-enumerable means and how it is any different to enumerable?
16:41:21 <povman> regarding functions
16:43:50 <povman> or rather, can anyone explain why a function might be approximable from above but not from below
16:50:00 <rwbarton> I think a co-enumerable set is just the complement of an enumerable set.  E.g., the set of Turing machines that do not halt on empty input.
16:53:01 <lispy> > reverse . take 100 . reverse $ beer_song 99
16:53:17 <lambdabot>   thread killed
16:53:24 <lispy> > length $ beer_song 99
16:53:34 <lambdabot>   mueval: Prelude.read: no parse
16:53:36 <lispy> oh, right no basecase
16:53:39 <povman> lispy:
16:53:40 <povman> yeah
16:55:19 <dons> ?users
16:55:20 <lambdabot> Maximum users seen in #haskell: 515, currently: 478 (92.8%), active: 15 (3.1%)
16:55:41 <povman> rwbarton: but eg const is enumerable and co-enumerable
16:56:08 <povman> where enumerable === approximable from above
16:57:34 <rwbarton> Something should be both enumerable and co-enumerable if and only if it is computable.
16:58:02 <rwbarton> But I feel more confident saying that about sets than about functions.
16:59:21 * povman ponders
16:59:30 <povman> (thanks bts)
16:59:32 <povman> w
17:00:58 <rwbarton> I think these notions only make sense for decision problems ("does f(x) equal y"), not function problems ("what is f(x)")
17:03:51 <povman> i'm reading an AI book by hutter and it defines f as enumerable if there is a turing machine computing p(.,.) s.t. lim t->inf   p(x,t) = f(x), and p(x,t) <= p(x,t+1)
17:04:09 <povman> and f co-enumerable if -f is enumerable
17:04:31 <Pseudonym> Se ni havus Statistikilon, "lol" certe estus inter la
17:04:40 <Pseudonym> Whoops.
17:10:06 <ivanm> Pseudonym: no, we want your "Whoops." to be in the same language as your mistake! :p
17:13:02 <Cale> povman: Took me a moment to see how that's at all connected to the usual definition of enumerable :)
17:13:32 <povman> http://books.google.com/books?id=LKEmB_GQ53QC&pg=PA36&lpg=PA36&dq=%22enumerable+function%22&source=web&ots=4KVIKjrOEP&sig=xsRe2PzUQPgOsqISXEx9CvG7n4o&hl=en&sa=X&oi=book_result&resnum=2&ct=result#PPA35,M1
17:13:35 <lambdabot> Title: An Introduction to Kolmogorov ... - Google Book Search, http://tinyurl.com/3hktos
17:13:38 <povman> section 1.7.3
17:14:19 <povman> in particular example 1.7.6
17:14:51 <povman> i can see it now though
17:15:09 <BMeph> Pseudonym: Whoa - Esperanto, and not lojban? You ARE "Old School"! ;)
17:15:25 <dmwit> Esperanto and lojban serve different purposes.
17:15:33 <dmwit> Or at least... they were meant to. =P
17:15:58 <Pseudonym> BMeph: You bet.  Lojban is not literary enough for me.
17:16:30 <BMeph> Pseudonym: Rock on! >;)
17:16:57 <Pseudonym> Dankon.
17:17:05 <Cale> povman: yeah
17:17:33 <povman> lojban, yum
17:17:54 <Pseudonym> Lojban seems, to me, like ASN.1.
17:18:07 <Pseudonym> It's something to communicate in, but it's not "native".
17:18:07 <Cale> povman: It's sort of a nice definition in that it doesn't require talking about non-halting things.
17:23:04 <FunctorSalad> do I have to call Network.Curl.withCurlDo (it says it has to be called first) even when using Network.Curl.Easy.initialize?
17:24:45 <Cale> FunctorSalad: I doubt it.
17:25:08 <FunctorSalad> oh, and there's also Network.Curl.Easy.curl_global_init ;-) ;-)
17:28:17 <FunctorSalad> ah... "If you did not already call curl_global_init(3), curl_easy_init(3) does it automatically."
17:30:16 <Saizan> is it in general assumed that you can stop the execution of a turing machine after a certain number of steps?
17:30:20 <FunctorSalad> long option list is LONG
17:31:04 <FunctorSalad> Saizan: not in the model of turing machine AFAIK, but of course you can talk about number of steps from the outside
17:32:32 <lispy> Did you guys see that comment on Haskell-Cafe that C# has GADTs?
17:32:36 <lispy> That shocked me.
17:32:42 <lispy> Anyone here used them in C#?
17:33:55 <mapreduce> How do they look in C#?
17:35:13 <Olathe> Saizan: Sure. You can simulate a Turing machine which stops.
17:35:25 <Olathe> Saizan: Using another one.
17:35:26 <mapreduce> C# certainly has no explicit support for GADTs.  I think it must be a "if you squint while looking at this" version of "C# has GADTs".
17:36:03 <dmwit> Saizan: It's easy to show that running two Turing machines in lockstep is equivalent in power to running just one, and there's an easy Turing machine that stops after 'n' steps (by sticking 'n' down on the tape in unary).
17:36:11 <adu> hi
17:36:30 <dmwit> Saizan: So if you need to talk about having a Turing machine that stops after 'n' steps whether it's done or not, that should be no problem.
17:36:43 <adu> dons: how did you implement fdToCFile?
17:38:47 <adu> either that or a handleToCFile would be nide
17:38:52 <adu> nide -> nice
17:39:47 <Saizan> dmwit: essentially i was trying to see how defining a recursively enumerable set as having an algorithm that halts iff the input is an element of the set gives you the ability to enumerate the elements (pretty basic question i guess)
17:40:40 <dmwit> Saizan: Enumerate all inputs, then stick the ones the machine accepts into the set.
17:41:19 <dmwit> Any given input in the set is guaranteed to be in the set after at most a finite amount of time.
17:42:07 <Saizan> how can i tell if an input is accepted or not in finite time?
17:42:10 <dmwit> Saizan: Note that it's just a tiny bit tricky in that you can't have infinite elements in the set -- only finite ones.
17:42:19 <dmwit> Saizan: That's the definition of having an algorithm.
17:42:34 <dmwit> Saizan: or, sorry, back up
17:42:45 <dmwit> Saizan: You've got the definition of recursively enumerable wrong.
17:42:45 <Saizan> but it says that it doesn't halt if the element is not in the set
17:43:06 <dmwit> Saizan: RE means you have an algorithm that *always halts*, and accepts iff the input is in the set.
17:43:23 <dmwit> Or am I confusing RE with something else?
17:43:39 <Saizan> http://en.wikipedia.org/wiki/Recursively_enumerable <-- i was following here
17:43:42 <lambdabot> Title: Recursively enumerable set - Wikipedia, the free encyclopedia
17:45:04 <dmwit> I am confusing RE with something else.  And it's clear that my automata theory class was long enough ago that I won't be able to help you. =P
17:45:57 <Saizan> heh, mine is going to start in a week :)
17:46:31 <Cale> RE means that you have a machine which halts if and only if the element is in your set.
17:46:38 <hsuh> hi guys.. i needed this python snippet at work today (http://hpaste.org/10796) and would like to know how it would be like in haskell (just to check whether it could be used instead of python in this particular situation)
17:47:22 <povman> Cale: so if something is enumerable, isn't it automatically co-enumerable by checking all elements?
17:47:27 <povman> oh i guess not
17:47:28 <povman> heh
17:47:39 <Cale> right, it's not :)
17:48:18 <Saizan> Cale: yeah, and you should be able to derive a machine that enumerates the element from that?
17:48:25 <Cale> Because although you have a way to list all the elements eventually, you don't know whether any particular one will show up or not until it does.
17:48:27 <Saizan> "elements"
17:49:02 <Cale> Elements of the RE set.
17:49:07 <dmwit> ?index </>
17:49:07 <lambdabot> Text.Html
17:49:14 <dmwit> ?hoogle </>
17:49:15 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
17:49:15 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
17:50:09 <Cale> hsuh: okay...
17:51:51 <dmwit> hsuh: Check my annotation.
17:52:12 <dmwit> I'd do it a different way, probably, but all languages are pretty similar for such simple programs. =)
17:52:27 <FunctorSalad> Saizan: diagonal trick :)
17:52:29 <hsuh> dmwit: just noticed, thanks :)
17:52:49 <dmwit> hsuh: Warning: I didn't test that. =P
17:52:50 <FunctorSalad> compute step 1 of input 1, step 2 in 1, step 1 in 2, ...
17:54:10 <Saizan> FunctorSalad: ah, ok then :) that's why i was asking about stopping turing machines
17:55:32 <FunctorSalad> Saizan: ah right, for that you need the result that a turing machine can simulate others (in single steps)
17:55:49 <FunctorSalad> (as dmwit said)
17:56:14 <Cale> Ah, someone beat me to it :)
17:56:26 <FunctorSalad> "result" is a bit strong for sth we do every day on our computers ;-)
17:57:29 <Cale> dmwit: Ah, you got hit with the same thing I did.
17:58:18 <Cale> dmwit: oh, your wr_descr is missing a parameter to writeFile ;)
17:59:26 <dmwit> Cale: Oh, yeah. heh
18:01:18 <Cale> But when you write that part, you have to be careful since the types of sz and ifg are ambiguous :)
18:02:09 <dmwit> oog
18:02:16 <dmwit> Numbers in Haskell are weird.
18:02:35 <dmwit> Not that Haskell is unusual that way.
18:02:44 <heatsink> compared to math, or to other proglangs?
18:05:49 <thoughtpolice> I saw an awesome cover for an FP book in the library today - had the big pascal assignment operator ':=' on it with a gigantic 'no' symbol cut through it (think of something like a no-smoking sign.)
18:09:35 <Cale> thoughtpolice: I've seen that logo elsewhere :)
18:19:33 <mmorrow> has anyone found a use case / situation / whatever where Data.Seq really accels (compared to lists for list-ish stuff, and IntMap for Indexing)?
18:20:11 <FunctorSalad> doesn't it do concat in O(1) mmorrow ?
18:20:14 <FunctorSalad> (not sure)
18:20:15 <mmorrow> it seems to me their O(1) snoc is their biggest asset, but anything else?
18:20:26 <mmorrow> FunctorSalad: hmm, i'm not sure
18:20:30 * mmorrow checks
18:20:41 <FunctorSalad> I mean append
18:20:46 <FunctorSalad> :)
18:20:57 <thoughtpolice> Cale: :] i was looking for 'introduction to algorithms' while I found it
18:21:04 <thoughtpolice> which proved to be much harder than it had to be
18:21:06 <mmorrow> ah, yeah i would imagine so.., but i don't recall the update costs
18:21:28 <thoughtpolice> because there's no bloody organization at all in that section of the library and there software for it is about as slow as a glacier
18:21:48 <Cale> mmorrow: Data.Sequence excels at a lot of things :)
18:21:53 <mmorrow> Data.Sequence append is O(log(min(n1,n2)))
18:21:59 <Cale> yeah
18:22:11 <Cale> and it can split anywhere in that time too.
18:22:22 <sjanssen> mmorrow: Data.Sequence is good for sequences
18:22:42 <Cale> Finite sequences that you need random access to.
18:22:51 <thoughtpolice> on a side note after reading this book and getting back to a recruiter it's quite likely I'll have an interview for an MS internship
18:22:56 <sjanssen> or even just access on either end
18:22:59 <mmorrow> Cale: concretely/performance wise (considering the hidden constant penalty over lists), i'm trying to pin down its "ong Data.Sequence for sure" use-case is.
18:23:03 <sjanssen> or that you need to concatenate
18:23:07 <mmorrow> s/ong/omg/
18:23:22 <thoughtpolice> i will have to beat out roughly 100,000 competitors, but I think I have a decent shot
18:23:30 <thoughtpolice> nice guy also gave me free ebooks
18:23:30 <mmorrow> sjanssen: yeah, O(1) access to either end seems to be its main strength
18:24:08 <Cale> mmorrow: Well, it's log time to index anywhere in the middle too :)
18:25:01 <mmorrow> hmm, ok i'm gonna do really quickly a benchmark of IntMap vs. Data.Sequence, where i do fromList [0..100000], then generate 100000 random Ints, then index into each with those Ints
18:25:37 <ddarius> mmorrow: IntMap should handily win for that.
18:26:00 <mmorrow> ok. what about for union intersection?
18:26:21 <Cale> If you're trying to work with a set, then use Data.Set
18:27:04 <unmarshal> anyone ever thought about building an open source voting system in haskell?
18:27:11 <unmarshal> that sounds like a great "killer app" that could have some real world use
18:27:14 <mmorrow> i'm writing a mini-db implem and am using IntMap to rep subtables, then translating/"compiling" boolean "where clauses" to correspoding union/intersection of the IntMap subtables. I'm trying to think if Data.Sequence is of any use here
18:27:30 <unmarshal> thought about this regarding CA sec of state talking about using open source voting software
18:27:33 <unmarshal> http://www.truthout.org/092908VA
18:27:45 <lambdabot> Title: t r u t h o u t | Counting Every Vote
18:27:54 <mmorrow> (that's the real motivation to my Data.Sequence inquiry)
18:28:22 <mmorrow> (by "subtables" i mean indexes, dunno if that's synonymous)
18:28:28 <sjanssen> mmorrow: I don't see how Data.Sequence is useful there -- it isn't a sparse structure
18:28:46 <mmorrow> hmm.
18:29:05 <mmorrow> err, i meant IntSet...
18:29:11 <mmorrow> err, no
18:29:31 * ddarius just realized that the query interface to a full-text database that he wrote several years ago was rather similar to the SICP Prolog implementation conceptually.
18:29:37 <mmorrow> (clearly i'm rapidly trying to do this ;))
18:29:37 <sjanssen> mmorrow: Data.Sequence can look up elements by index, and it doesn't have the concept of "key"
18:29:45 <mmorrow> type Ix k = Map k Sub
18:29:49 <mmorrow> type Sub = IntSet
18:30:21 <mmorrow> yeah, beyond the indexes in particular, any thoughts on a nice place to use Data.Sequence in this context
18:30:28 <mmorrow> (i'm going for speed)
18:30:37 <ddarius> mmorrow: Why are you so dead set on using Data.Sequence?
18:31:14 <mmorrow> ddarius: heh. i never use it and am just making sure i'm not missing out ;)
18:31:33 <mmorrow> but yeah, i can't think of any place for it really here
18:31:37 <ddarius> mmorrow: Use it when you have a problem involving a sequence of things.
18:32:00 <sjanssen> mmorrow: Data.Sequence doesn't seem helpful there, but Data.FingerTree might.  The paper by Hinze and Paterson have a nice merge function that you might be able to use
18:32:06 <mmorrow> the finger tree paper probably is subconciously playing a part. was a good read..
18:32:33 <mmorrow> sjanssen: yeah, i actually have Data.Fingertree open in front of me now
18:32:37 <sjanssen> mmorrow: Data.Sequence isn't nearly as flexible as the structure presented in the paper
18:34:18 <mmorrow> ah, that reminds me of another thing. has anyone used a fingertree as a Map-type thing via some appropriate Measured instance. there're some interesting examples in the paper, but i'm not sure how they would do against a specialized structure like IntMap
18:34:37 <sjanssen> mmorrow: see 4.7, "Ordered sequences", specifically the merge function
18:34:59 <mmorrow> cool
18:35:03 <ddarius> Unless you specialize the finger tree as well, IntMap has very good bounds and is not likely to be beaten.  Comparing against Map would be more fair.
18:35:41 <sjanssen> true, Data.FingerTree plays a big abstraction penalty (there is a reason Data.Sequence is hand specialized)
18:35:47 <sjanssen> s/plays/pays
18:37:44 <mmorrow> indeed
18:37:54 <mmorrow> "* ddarius just realized that the query interface to a full-text database that he wrote several years ago was rather similar to the SICP Prolog implementation conceptually."
18:39:17 <mmorrow> interesting. i'm not dead set on using SQL (select) statements as query lang. any clearly superior query langs come to mind?
18:40:40 <mmorrow> (which are also suitable for a non-programmer to use to do something useful)
18:40:40 <ddarius> I've never used it, but maybe you want to look at Datalog? or some other recommendations.  Logic languages in general aren't bad.
18:40:56 <ddarius> However, for the full-text database I just wanted something like Google's interface.
18:41:12 <mmorrow> ah, i see.
18:41:17 <ddarius> SQL is mostly bad around the edges.  The basic parts are fine.
18:42:38 <mmorrow> yeah, other than the hideous (imo) syntax, the sql select statement is fairly nice construct
18:44:04 <heatsink> there is lack of a typesetting program written in haskell.
18:45:19 <dmwit> There is no such lack.
18:45:55 <dmwit> I see no reason to use only programs written in Haskell just because the language I like best happens to be Haskell.
18:46:27 <povman> lol
18:47:45 <heatsink> I don't see the connection.
18:47:57 <dmwit> There are good typesetting programs.
18:48:08 <dmwit> Why do we need to waste man-hours writing a new one in Haskell?
18:48:19 <dmwit> Let's write something interesting, useful, and new!
18:49:02 <heatsink> What do you use for typesetting?
18:49:11 <dmwit> LaTeX
18:49:25 <heatsink> It doesn't bother you?
18:49:41 <ivanm> heatsink: there's also pandoc, if you want a purely haskell-based app
18:50:08 <dmwit> heatsink: It's easy to write, it looks good, and it has good editor support.
18:50:10 <ivanm> and I generally use LaTeX myself (though gour is trying to convert me to ConTeXt)
18:50:20 <povman> heatsink: what's wrong with tex?
18:50:42 <ivanm> it's by Knuth, ergo it's good :p
18:50:56 <heatsink> It's horrible to program in.
18:51:03 <povman> it's not for programming
18:51:04 <heatsink> Off-side indentation, for example.
18:51:07 <ivanm> heatsink: yes, but who's telling you to program in it?
18:51:17 <ivanm> povman: unless you want to with the judges award at the ICFP comp... ;-)
18:51:32 <ddarius> Indeed, Haskell isn't Lisp.
18:52:14 <dmwit> ddarius: err, what?
18:52:15 <heatsink> ivanm: When you want to do layout that isn't natively supported in TeX, what is your alternative to programming in it?
18:52:24 <dmwit> ddarius: Usually I can follow your jumps...
18:52:26 <ivanm> heatsink: what kind of layout?
18:52:33 <heatsink> ivanm: off-side indentation
18:52:42 <ivanm> ummmm.... what do you mean by that?
18:52:53 <ivanm> have you checked CTAN? the tex FAQ?
18:52:56 <heatsink> ivanm: significant whitespace alignment on the left side of blocks of code
18:53:11 <ivanm> listings?
18:53:12 <dmwit> How about using the verbatim environment?
18:53:20 <ivanm> dmwit: nah, listings is nicer!
18:53:27 <dmwit> Or, sure, something better.
18:53:30 <heatsink> dmwit: That works if you don't want math formatting.
18:53:31 <dmwit> I'm just saying it's possible.
18:54:08 <ivanm> heatsink: uuhhhhh.... what?
18:54:12 <dmwit> heatsink: Wait, do you meant something for typesetting Haskell?
18:54:22 <ivanm> lhs2tex! ;-)
18:54:26 <dmwit> There's lhs2tex or whatever.
18:54:31 <dmwit> It's really quite nice.
18:54:49 <ivanm> dmwit: I used it once, but I found that it was too much bother...
18:55:14 <ivanm> (emacs doesn't seem to like having two major modes at the same time...)
18:55:19 <heatsink> dmwit: Not genuine haskell, but functions with let blocks.
18:55:29 <povman> heatsink: ugliness in writing macros and whatnot is made up for in writing text
18:55:35 <ivanm> heatsink: there's also various algorithms packages
18:56:01 <Philippa_> povman: ...it is? Maybe I'm just trying to typeset stuff that's too weird...
18:56:37 <heatsink> ivanm: the algorithmx and similar packages give you fixed-distance indentation, but no way to indent a line to match the position of a word in a previous line.
18:56:42 <povman> albeit i've never done much more complicated than maths assignments :p
18:57:01 <ivanm> heatsink: well, you _type_ it in that way
18:57:07 <ivanm> it won't do it automatically for you...
18:57:32 <heatsink> ivanm: But the point of typesetting is so that you don't have to explicitly declare the position of everything!
18:57:41 <ivanm> ummmm..... for code, you do....
18:57:48 <ivanm> typesetting is for your _text_
18:58:08 <ivanm> there's no way a typesetter will have the layout rules for all possible languages
18:58:20 <ivanm> I mean, look how hard it is to indent haskell automagically in say emacs!
18:58:26 <heatsink> I agree TeX typesets text and math formulae beautifully.
18:59:11 <ivanm> I find it typesets code beautifully as well, using listings
18:59:12 <heatsink> I'm not saying the ideal TeX would have layout rules for everything.  I'm saying it would be programmable.
18:59:20 <ivanm> but it won't automagically indent it for you
18:59:27 <ivanm> that, I think, is asking too much
18:59:41 <povman> especially when different people use different indentation styles
18:59:45 <ivanm> heatsink: try LuaTeX then
18:59:49 <ivanm> povman: heh, yeah
19:00:33 <heatsink> ivanm: It took me a long time to figure out how to do something as simple as "lay out a piece of text, measure its size, then create a box of that size containing a different piece of text."
19:00:58 <ivanm> hmmmmm..... there's a package that does that
19:01:12 <ivanm> but yes, that's not easy
19:02:01 <povman> imo the web should have been tex instead of html
19:02:05 <heatsink> ivanm: I want to write layout modules using a typesetting interface like that.
19:02:12 * heatsink looks up luatex
19:03:39 <povman> all the annoyances with page width in latex are just made worse in html
19:04:13 <ivanm> heh, yeah
19:04:30 <ivanm> and let's not get started on the whole <foo>...</foo> garbage
19:04:46 <povman> environments?
19:05:09 <ivanm> yeah
19:05:37 <povman> ->assignment
19:06:28 <ivanm> whatever it's called :p
19:07:26 <ddarius> dmwit: The Lisp world is more hostile to mixing with other languages than the Haskell world, though not as much as the Smalltalk world.
19:07:40 <dmwit> ah
19:10:03 <younder> It is?
19:10:35 <younder> My Lisp connect's to CON, .NET and DLL's as well as Java
19:11:12 <ddarius> younder: I wasn't talking about the language so much
19:16:04 <metasyntax> ddarius: there's a lot of interest in Clojure too, I think
19:16:35 <metasyntax> but I admit that I like to do things in pure Lisp when I can
19:16:36 <ddarius> metasyntax: From the Lisp community?
19:17:59 <metasyntax> ddarius: I won't pretend to be an expert insider, but I've seen it mentioned a fair amount
19:18:57 <ddarius> I haven't been paying any attention to the Lisp community for the past couple of years, but it strikes me as unusual.  Note that the Scheme community is more open (or was in my experience earlier)
19:20:07 <metasyntax> ddarius: http://xach.livejournal.com/191581.html
19:22:17 <metasyntax> ddarius: I believe Mr Hickey is working on uploading a video of his talk from the Boston Lisp meeting soon
19:26:59 <roconnor> does Enum imply Ord?
19:27:19 <ddarius> @src Enum
19:27:19 <lambdabot> class  Enum a   where
19:27:19 <lambdabot>     succ                     :: a -> a
19:27:19 <lambdabot>     pred                     :: a -> a
19:27:19 <lambdabot>     toEnum                   :: Int -> a
19:27:19 <lambdabot>     fromEnum                 :: a -> Int
19:27:21 <lambdabot> [3 @more lines]
19:27:23 <ddarius> No
19:27:26 <roconnor> good
19:27:55 <roconnor> @src Bounded
19:27:56 <lambdabot> class  Bounded a  where
19:27:56 <lambdabot>     minBound, maxBound :: a
19:28:18 <roconnor> is there a function [minBound..maxBound] ?
19:28:43 <ddarius> [minBound..maxBound]
19:28:55 <roconnor> ok
19:29:38 <ddarius> Actually, you can drop the maxBound
19:29:50 <mmorrow> this may be interesting to math/category-liking people http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=68#a68
19:30:20 <mmorrow> (ideas/comments/random thoughts welcome)
19:31:27 <ddarius> mmorrow: Where's the topos?
19:31:32 <roconnor> ddarius: meh,  I think I'll leave it in.  I think it is more clear
19:32:28 <mmorrow> ddarius: that comes after i hit the bong and put on my bead headdress
19:33:33 <mmorrow> ddarius: seriously though, that;s just got put the t3h list of avenues of research
19:33:48 <roconnor> how do I write a defaulting statement again?
19:33:58 <ddarius> default(Type, Type(
19:34:06 <ddarius> Well, with a closing paren...
19:35:09 <roconnor> ddarius++
19:35:22 <roconnor> is . allowed in the middle of identifiers in H98?
19:36:01 <ddarius> It means (.) then.
19:36:17 <ddarius> There is an addenda for Foo.bar but it's not technically accepted.
19:37:39 <sjanssen> has anyone seen this error before: Failed to load interface for `:THFake'
19:37:41 <sjanssen> ?
19:39:12 <mmorrow> heh, no, but every time if i  try to reify ''(->) i get
19:39:14 <mmorrow> Can't find interface-file declaration for data constructor GHC.Base.False
19:39:14 <mmorrow>       Probable cause: bug in .hi-boot file, or inconsistent .hi file
19:39:20 * roconnor eta expands to avoid MR
19:39:59 <sjanssen> oh, does TH support MPTCs?  Fundeps?
19:40:03 <mmorrow> i've had to resort to writing true/false as  "0==0"/"0==1" in this javascript quasiquoter on account of this bug
19:40:41 <mmorrow> sadly no
19:40:59 <mmorrow> sjanssen: what ghc are you on?
19:41:16 <sjanssen> mmorrow: 6.8.2
19:41:33 <mmorrow> weird, i don't think i've ever seen that
19:41:59 <sjanssen> well, I have several multi-parameter instances and contexts in this module, I wonder if that is the problem
19:42:13 * sjanssen was trying to write a FingerTree specializer
19:42:25 <mmorrow> err, TH does MPTCs, but not fundeps
19:42:42 <mmorrow> hmm, are you trying to reify a spaced-out data decl or something?
19:43:02 <roconnor> @hoogle assert
19:43:03 <lambdabot> Control.Exception assert :: Bool -> a -> a
19:43:03 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
19:43:03 <lambdabot> Test.HUnit.Base class Assertable t
19:43:04 <sjanssen> hmm, I have no fundeps (no class decls at all)
19:44:05 <mmorrow> what triggered it?
19:44:19 <mmorrow> (reify?)
19:45:12 <sjanssen> basically sticking the whole module in $( [d|
19:45:18 <mmorrow> heh
19:45:26 <mmorrow> i just found: http://www.haskell.org/pipermail/glasgow-haskell-bugs/2007-January.txt
19:45:28 <lambdabot> http://tinyurl.com/ywxbqg
19:45:30 <mmorrow> ..
19:45:31 <mmorrow>  Foo.hs:5:14:
19:45:32 <mmorrow>      GADT declaration not (yet) handled by Template Haskell
19:45:32 <mmorrow>        :THFake.Bar :: :THFake.Foo Int
19:45:33 <mmorrow> ..
19:45:55 <sjanssen> interestingly, if I :r repeatedly I get a new error message
19:46:44 <sjanssen> :THFake must be the fake module for the current TH context
19:47:08 <mmorrow> ah, that sounds sense-making
19:47:41 <sjanssen> so the real problem is some occurs checks (which didn't appear before I quoted the whole damned module)
19:48:55 <mmorrow> hmm
19:51:42 <roconnor> @type all
19:51:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:58:13 <sjanssen> OH! does TH have trouble with operator precedences?
19:58:29 <sjanssen> mmorrow: do you know if fixity declarations are ignored, or something like that?
20:01:32 <mmorrow> sjanssen: that's a good question, i don't think i've ever tried to quote one, and the th ast doesn't have a rep for them..
20:02:02 <sjanssen> mmorrow: yep, it's definitely the problem
20:02:11 <sjanssen> so they're probably tossed away
20:02:11 <mmorrow> , [d|infixr 9 .|]
20:02:12 <lunabot>  luna: parse error on input `]'
20:02:20 <mmorrow> , [d|infixr 9 (.)|]
20:02:21 <lunabot>  luna: parse error on input `('
20:03:23 <sjanssen> yep, that fixed it
20:03:25 <sjanssen> woo hoo
20:03:35 <mmorrow> yipphoo
20:04:02 <sjanssen> actually, not quite
20:04:09 <mmorrow> heh
20:04:18 <sjanssen> I get "Failed to load interface for `:THFake'"
20:04:32 <sjanssen> then a subsequent reload reports success, but dumps me to a Prelude context
20:04:36 <mmorrow> what's the most non-h98 thing in the quote?
20:05:05 <sjanssen> MPTC instances and contexts
20:05:38 <roconnor> @hoogle a -> Double
20:05:39 <lambdabot> Prelude id :: a -> a
20:05:39 <lambdabot> Data.Function id :: a -> a
20:05:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:08:49 <mmorrow> maybe try a newer ghc? the th internals get jingled around a lot i believe..
20:09:50 <mmorrow> i think the "can't find interface for GHC.Bool" or whatever is on account of the th code not having been told that the module changed locations (or something)
20:10:10 <mmorrow> (err, i guess that would be not-jingled around ...)
20:11:02 <mmorrow> and the "corrupt/whatever .hi file" error is just a catchall, which also happens to be applied to the "no .hi file exists" case
20:11:24 <mmorrow> (my completely without-base guess ;))
20:12:45 <sjanssen> I should have tried this idea on something simpler, like Data.Map
20:13:05 <mmorrow> too late now!
20:13:05 <ivanm> mmorrow: this is what I ended up going with: http://hpaste.org/10797
20:13:41 <mmorrow> ivanm: sweet. does it work ok?
20:13:50 <ivanm> yeah
20:14:05 <ivanm> well, I'm assuming graphviz creates a proper DotGraph, anyway :p
20:14:15 <ivanm> and ten the only possible error seems to be if the file doesn't work
20:14:18 <mmorrow> (also this pastebin has a huge paste-length limit if you want to paste something large http://moonpatio.com:8080/fastcgi/hpaste.fcgi/)
20:14:42 <ivanm> oh, forgot about that :s
20:14:44 <mmorrow> ivanm: nice.
20:15:31 <ivanm> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=69#a69
20:15:58 <ivanm> because your code crashed on the same stuff mine did: dodgy graphviz output type
20:16:51 <ivanm> so I have make sure runGraphvizInternal is never seen by the outside world, just in case :p
20:17:03 <mmorrow> heh. a cgi rapid-prototyping program should be easy to hack together to interatively make graphs. i find it handy
20:17:20 <ivanm> yeah
20:17:28 <mmorrow> http://moonpatio.com/cgi-bin/graphedit.cgi
20:17:55 * ivanm found emac's lisp-based regexes really handy to create the GraphvizOutput type and show instance
20:17:56 <mmorrow> (that machine has crappy libs or something, cuz the lines/etc suck)
20:18:04 <ivanm> automatic capitalisation!
20:18:23 <ivanm> ooohhhhh........ pretty.....
20:19:21 <ivanm> what are the radio buttons? the different graphviz apps?
20:19:50 <ivanm> mmorrow: what does the {b,c} notation mean?
20:20:04 <mmorrow> here's what that same .dot produces with the graphviz on my laptop http://moonpatio.com/images/z.png
20:20:32 <ivanm> yeah, same
20:20:41 <mmorrow> ivanm: it's a nonstandard syntax (i think it may be only supported in newe(r/st) graphvizs). it's really handy
20:21:01 <ivanm> means that they have the same edge?
20:21:02 <mmorrow> {a,b} -> {a -> c, b}
20:21:23 <mmorrow> a -> a      a -> c      a -> b      b -> a     b -> b
20:21:42 <mmorrow> yeah, it complains of a "syntax error" to stdout, but reads it fine
20:22:00 <mmorrow> and you can get "canonical" syntax with  dot -Tcanon
20:22:58 <ivanm> so what does the a -> c on the RHS mean?
20:23:38 <mmorrow> a -> {b -> c} lets you say a -> b and b -> c in one line
20:23:47 <ivanm> ahhhh
20:23:56 <mmorrow> it's handy for pprinting from a datastructure
20:23:57 <ivanm> well, all my graphs will be auto-generated ;-)
20:24:17 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=32
20:24:27 <mmorrow> ppGraph :: [(String,[String])] -> Doc
20:24:47 <mmorrow> (with Text.PrettyPrint)
20:24:50 <ivanm> heh
20:25:05 <ivanm> how long has Text.PrettyPrint been "provisional"?
20:25:24 <mmorrow> hah, prolly since '98
20:25:27 <ivanm> heh
20:25:54 <Harold> Sorry to bother, but I'm new to Haskell and I'm hitting an error I don't understand: http://gist.github.com/14017
20:25:59 <lambdabot> Title: gist: 14017 — GitHub
20:26:44 <dolio> Float2 x1+x2 y1+y2 = (Float2 x1)+(x2 y1)+(y2)
20:26:51 <ivanm> can anyone think of a part of a document I've missed? http://hpaste.org/10798
20:27:45 <mmorrow> ivanm: haddock has a cool DocMarkup datatype, i'll find it
20:28:02 <ivanm> Harold: you can't use (+) there, unless you make Float2 an instance of Num
20:28:19 <ivanm> use a different function if you want
20:28:29 <Harold> Only "Num"s can use +?
20:28:38 <ivanm> but yes, as dolio pointed out, it could be interpreted wrongly as well
20:28:40 <cjs> Harold: at the top of your file, but after the module declaration if you have one, "import Prelude hiding ((+))" if you want to just get rid of the normal plus.
20:28:40 <ivanm> @type (+)
20:28:41 <lambdabot> forall a. (Num a) => a -> a -> a
20:28:56 <ivanm> cjs: he can't, because the then uses it to add the sub-components together
20:29:08 <ivanm> he'll have to import that qualified then, I suppose...
20:29:44 <mmorrow> DocMarkup: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=70#a70
20:29:44 <cjs> "x1 `Prelude.(+)` y1" :-)
20:30:16 <ivanm> mmorrow: hmmmm....
20:30:27 <Harold> Is there any reason that I wouldn't want Float2 to be a Num?
20:30:35 <mmorrow> then haddock has one for Html, ...
20:30:38 <ivanm> @src Num
20:30:38 <lambdabot> class  (Eq a, Show a) => Num a  where
20:30:38 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:30:38 <lambdabot>     negate, abs, signum     :: a -> a
20:30:38 <lambdabot>     fromInteger             :: Integer -> a
20:30:42 <dmwit> > 3 Prelude.+ 4 -- cjs, no need for such bad syntax
20:30:43 <lambdabot>   7
20:31:05 <ivanm> Harold: ^^ you'll have to implement all but one of netage and (-) IIRC
20:31:21 <ivanm> mmorrow: maybe I'll steal^W borrow some ideas from there...
20:31:42 <mmorrow> ivanm: that's one of my favorite data decls
20:32:05 <ivanm> and that looks like it will translate nicely into pandoc \o/
20:32:13 <ivanm> what's markupAName for?
20:32:26 <dmwit> <a href=>
20:32:28 <dmwit> ;-)
20:32:29 <mmorrow> check out http://code.haskell.org/haddock/src/Haddock/ for more detail
20:32:30 <mmorrow> s
20:32:32 <ivanm> ahhh
20:32:40 <lambdabot> Title: Index of /haddock/src/Haddock
20:32:53 <dmwit> (Probably more for <a name=>, though.)
20:32:55 <mmorrow> and DocMarkup is somewhat specialized to be marking up haskell syntax also
20:33:02 <Harold> Thanks all.
20:33:02 * ivanm was slightly suprised to see there already wasn't a "document" library, but supposes it's a bit hard to define one generic enough
20:33:20 <mmorrow> well, it's actually pretty general
20:34:37 <ivanm> yeah
20:34:46 <ivanm> I just need to add images basically and I'm done!
20:35:46 <roconnor> @type find
20:35:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:36:35 <roconnor> @hoogle find
20:36:36 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
20:36:36 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
20:36:36 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
20:41:37 <ivanm> mmorrow: any idea why Emphasis is defined as a -> a? surely you can't emphasise a whole paragraph or something...
20:42:53 * ivanm idly wishes there was a way of specifying that you can restrict which constructors are possible as elements of another data structure
20:43:18 <Heffalump> you can do that with a GADT
20:43:29 <Heffalump> well, depending on the restrictions you want
20:43:33 <Heffalump> but it may well be possible
20:44:01 <dolio> I don't think they'll let you do what he wants (if I'm reading him right).
20:44:21 <Heffalump> fair enough, I wasn't reading above
20:44:29 <mmorrow> ivanm: my guess is because emphsis changes an attribute of the the thing, but not the thing's structure itself
20:44:31 <dolio> Although if you wrote your type as a fixed point of a coproduct of functors, you could. :)
20:44:41 <mmorrow> dolio: heh
20:44:57 <mmorrow> , cofix
20:44:58 <lunabot>  luna: Not in scope: `cofix'
20:45:23 <ddarius> I think he wants something similar to refinement types.
20:45:53 <ivanm> dolio: gah!
20:46:30 <dolio> data Con1 a = Con1 ... ; data Con2 a = Con2 ... ; type MyData = Fix (Con1 :+: Con2 :+: ...) ; data Foo = FooCon1 (Fix (Con1 :+: Con3 ...)) | ...
20:46:32 <dolio> :)
20:46:46 <mmorrow> , typeOf (undefined::(Comonad w::w ()))
20:46:47 <lunabot>  luna: parse error on input `w'
20:47:02 <mmorrow> , typeOf (undefined::(Comonad w) => w ()))
20:47:02 <lunabot>  luna: parse error on input `)'
20:47:05 <mmorrow> , typeOf (undefined::(Comonad w) => w ())
20:47:06 <lunabot>  luna: Not in scope: type constructor or class `Comonad'
20:47:08 <mmorrow> gah
20:49:54 <ivanm> heh
21:10:41 <roconnor> @type floor
21:10:42 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
21:13:20 <[R]ayne> Is EclipseFP not compatible with Eclipse 3.4?
21:14:16 <Axman6> urgh, anyone know how to fix this, when you have a custom .ghci file? *** WARNING: /Users/Axman is writable by someone else, IGNORING!
21:14:50 <dmwit> chmod a-w /Users/Axman, maybe?
21:15:14 <Axman6> what would that set it as?
21:15:38 <Axman6> i've always hated chmod/unix file perm syntax -_-
21:15:53 <dmwit> The same, it just removes "a-w" means "remove write permissions from the world permissions".
21:15:54 <Saizan> removes write permission for "others"
21:15:57 <dmwit> a=all, w=write
21:16:28 <dmwit> I need to learn English.
21:17:32 <[R]ayne> EclipseFP keeps giving me a provisioning error when I try to install it ._. eclipse has always hated me.
21:18:09 <Saizan> data Prod f g (a :: * -> *) = Prod (f a) (g a) -- a better name, anyone?
21:19:49 <Axman6> dmwit: seemes to have worked, thanks
21:19:58 <Axman6> just hope it didn't break anything...
21:20:32 <Axman6> ok, just a little bit... made my move directory not writable by me...
21:20:35 <dmwit> Axman6: If you wanted people other than you to write into your home directory, it broke that.
21:21:15 * dmwit suddenly wonders if 'a' might mean world, group, and user
21:21:31 <Axman6> well according to finder, i can't write to it anymore
21:21:34 <dmwit> Yup, it does, sorry.
21:21:38 <dmwit> Okay, it's easily fixed.
21:21:39 <int-e> dmwit: sure it does.
21:21:47 <dmwit> chmod ug+w /Users/Axman
21:22:07 <Axman6> *** WARNING: /Users/Axman is writable by someone else, IGNORING!
21:22:08 <dmwit> int-e: Yep, I should have told him to chmod o-w, my mistake.
21:22:23 <dmwit> Axman6: That's silly, what group is it in?
21:22:42 <dmwit> Anyway, you can chmod g-w to fix it, most likely.
21:22:42 <Axman6> how do i find that out?
21:22:53 <dmwit> ls -ld /Users/Axman
21:23:17 <Axman6> drwxr-x-wx@ 503 Axman  Axman  17102  1 Oct 14:01 /Users/Axman
21:23:39 <dmwit> drwxr-x-*w*x?
21:24:00 <dmwit> weird
21:24:20 <dmwit> You could also skip all this state-changing and just set it to the permissions you want.
21:24:25 <dmwit> 755 is a good default
21:25:06 <Axman6> chmod o-w /Users/Axman worked
21:53:46 <Twey> http://java.sun.com/j2se/1.4.2/docs/api/java/util/Arrays.html -- does this make anyone else want to scream 'give me back my Haskel!!'?
21:54:02 <Twey> With an extra L.  'cause it's early.
21:54:30 <dmwit> ugh
21:54:30 <dmwit> yes
21:54:46 <Saizan> because of the silly overloading?
21:55:17 <cjs> Oh, that class is ancient.
21:56:04 <lispy> also, note that it provides a way to convert instances to lists...
21:56:11 <lispy> That seems very Haskell-esq
21:57:13 <lispy> cjs: but have they improved the overloading since generics?
21:57:18 <ddarius> When sorting a list of integers you may want to use radix sort.
21:57:33 <ddarius> Heck, sorting a list of booleans is pretty easy if you don't care about stability.
21:58:42 <cjs> lispy: I have no idea; I fled from Java around '04 or '05, and have kept as far away as possible since.
21:58:55 * Twey nods.
21:58:59 <Saizan> can you tell same-valued booleans apart in java?
21:59:01 <Twey> Ditto, but earlier.
21:59:17 <Twey> Saizan: No, but you can tell same-valued Booleans apart in Java.
21:59:32 <cjs> (I might have fled earlier except that I had to switch companies to do it.)
21:59:52 <mjrosenb> Kitchy: yep, this channel does exist
22:00:07 <ddarius> mjrosenb: It does?!
22:00:14 <Axman6> what? :o
22:00:42 * ddarius doesn't believe mjrosenb and goes to bed.
22:00:57 <mjrosenb> ddarius: no, i want to continue existing
22:03:40 <Kitchy> Has any famous stuff been written in Haskell?
22:04:01 <Axman6> darcs?
22:04:14 <Saizan> xmonad
22:04:16 <lispy> ghc
22:04:30 <Axman6> xmonad is very nice
22:04:42 <lispy> is it okay to name things from the April 1st posts? ;)
22:04:59 <Axman6> yes
22:05:11 <Saizan> hah, i missed those :)
22:05:18 <Kitchy> Never heard of darcs. Vaguely heard of the others.
22:05:30 <lispy> Kitchy: http://darcs.net
22:05:30 <lament> darcs is not at all famous
22:05:31 <lambdabot> Title: darcs
22:05:54 <lament> indeed, i have yet to see an article about DVCS that even mentions it (that wasn't written by a darcs or a haskell fanboy)
22:06:23 <lament> i have looked at several comparative reviews of dvcs
22:06:24 <lispy> lament: hmm.. linux weekly news mentioned it
22:06:54 <dmwit> pugs
22:07:26 <Kitchy> I know pugs because I'm a former member of the Perl community
22:08:08 <Axman6> well it's written haskell (or using it... or something. i don't really care)
22:08:35 <mgsloan> hrmm.. There probably actually is an answer to this.. but what's a famous perl program?
22:08:37 <dons> its kind of sad. linux news strongly recommended darcs, it profoundly influenced the dvcs scene.
22:08:53 <dons> yet it goes ignored by the mainstream, who think git was the first and last word in dvcs.
22:09:40 <lament> as does the GHC team :)
22:09:52 <Kitchy> I think the Hello World program is Perl's most famous.
22:10:06 <Axman6> ?
22:10:10 <lispy> lament: I've followed the debates on the GHC list, that's not true :)
22:10:20 <lament> darcs could be considered a killer app for a while, but definitely no more, the reputation suffered tremendously
22:10:28 <lament> lispy: well yes :)
22:10:40 <lament> but they only looked, iirc, at git, bazaar, and mercurial?
22:10:48 <lament> and darcs
22:12:12 <dons> pandoc and hpodder are fairly successful open source apps too.
22:12:38 <lispy> I would agree that darcs' reputation has suffered.  That's a sad story indeed.
22:12:42 <dons> all our stuff is quite young.
22:13:31 <Kitchy> pandoc...so I guess Haskell is good for text manipulation...I hope
22:13:52 <dons> i'd imagine so, given the compilers that have been written.
22:14:04 <dons> symbolic manipulation via algebraic types == killer app.
22:14:09 <lispy> I've never had an easier task of parsing than in Haskell
22:14:45 <lispy> project euler == killer app ;)
22:14:58 <Axman6> yeah, haskell's great for project euler stuff
22:15:03 <Axman6> i should do more of that...
22:15:17 <lispy> Haskell is awesome for prototyping
22:15:31 <dons> Haskell is awesome for security
22:15:40 <dons> by default it can't do anything.
22:15:41 <lispy> Even if you don't deliver Haskell to your clients, you can quickly knock off a prototype in it most of the time
22:15:48 <dons> secure by default!
22:16:01 <dons> lispy: executable specifications.
22:16:36 <lispy> I wouldn't say Haskell is so great at GUI stuff.  I want to be able to say this, and gtk2hs is cool, and wxHaskell is cool.  But I just feel like something is missing still.
22:17:01 <dons> what does it miss over python or java or .. .?
22:17:05 <dons> it's using the same libraries.
22:17:15 <lispy> iPhone dev is technically possible, but you need to jailbreak your phone
22:17:23 <dons> or is it just as good. not haskell's typically "so much more awesome" .
22:17:34 <dons> haskell-opengl is supposed to be particularly easy.
22:17:37 <dons> in comparison.
22:17:59 <lispy> dons: the last time I tried it, I found it hard to do the whole "sharing state" between event handlers.  Part of the problem was my experience with the language, partially I was figting the language
22:19:13 <lispy> HOpenGL is cool, but it can be hard to transition to if you already know opengl...I experienced this...people have done a good thing by trying to do opengl more haskelly, but it can be confusing without tutorials (Yes, I have tried myself to provide some of those tuts)
22:19:53 <dons> yes.
22:19:58 <Kitchy> What's a good haskell book?
22:20:04 <cjs> Many Haskell libs are confusing without tutorials; it just does stuff so differently.
22:20:07 <lispy> Kitchy: real-world haskell
22:20:12 <lispy> ?where rwh
22:20:13 <lambdabot> is http://www.realworldhaskell.org/blog/
22:21:08 <lispy> cjs: yeah, that's something we can all do to make Haskell better, blog about it with examples
22:21:54 <adu> wow pandoc sounds amazing
22:21:54 <adu> lispy: its only ungreat because no one has designed the right GUI library yet
22:21:54 <adu> dons: yes, my first (and only) GUI app in haskell was in opengl
22:21:54 <adu> dons: and I'd say it was pretty easy
22:21:57 <adu> lispy: I find using unsafePerformIO with that makes sharing state soooo much easier
22:21:59 <Kitchy> seen audreyt
22:22:12 <Kitchy> never mind...doesn't work here
22:22:15 <cjs> @seen audreyt
22:22:15 <lambdabot> audreyt is in #ghc, #xmonad, #haskell and #perl6. I don't know when audreyt last spoke.
22:22:20 <adu> hmm /me needs a blog
22:22:23 <Kitchy> Oh
22:22:54 <cjs> @vixen Are you happy?
22:22:54 <lambdabot> who's to say?
22:23:07 <audreyt> cjs: ?
22:23:08 <cjs> That wasn't very vixenish!
22:23:26 <cjs> Not me! I didn't push the button! It was Kitchy!
22:23:46 <dons> hey cjs.
22:23:47 <adu> lispy: as in globals = unsafePerformIO (newIORef globalDefaults)
22:24:31 <cjs> Anyway, Kitchy, I think Graham Hutton's book is a good starter, perhaps followed by Paul Hudak's. I've not read the first chapters of RWH yet, but the later chapters I've skimmed have definitely been good.
22:24:35 <cjs> Hey dons.
22:25:11 * cjs is trying to put his brain back in gear for stock market simulators after a week of type theory.
22:25:17 <lispy> adu: But, really we shouldn't be doing this.  It requires NO_INLINE and a top level unsafePerformIO.  Doesn't that just scream "your doing it wrong"?
22:25:52 <lispy> you're*
22:26:33 <lispy> adu: shouldn't we be using a continuation monad or something?
22:27:18 <lispy> Here we have this great lazy language that's capabale of using data structures for control flow and we're resorting to hacks to implement global io to deal with events?
22:27:30 <adu> lispy: right, but what would you rather do: "writeIORef globals (globals {x = y})" or "globals >>= modifyIORef (\g -> g {x = y})"?
22:28:01 <adu> oops "globals >>= \ref -> modifyIORef ref (\g -> g {x = y})"
22:28:01 <dons> doesn't everyone use functional reactivity?
22:28:28 <sjanssen> yay, my Template Haskell specialized FingerTree works in GHC 6.10!
22:28:31 <lispy> dons: it should be obvious that paper was never popped from my reading stack :)
22:28:42 <adu> functional reactivity?
22:28:58 <Saizan> functional reactive progrmming
22:29:05 <lispy> adu: it's an idea (I think invented by Conal Elliot) for dealing with event stuff in FP
22:29:16 <thetallguy> http://conal.net/fran/
22:29:19 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive
22:29:26 <lambdabot> Title: Functional Reactive Animation (Fran)
22:29:26 <lambdabot> Title: HackageDB: reactive-0.5, http://tinyurl.com/4d6j3c
22:29:32 <dons> well, an implementation of an idea too.
22:29:39 <lispy> dons: how do you guys deal with events in xmonad?
22:29:41 <thetallguy> twice
22:29:43 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/io-reactive
22:29:51 <dons> lispy: in an event loop.
22:29:53 <lambdabot> Title: HackageDB: io-reactive-0.1.1, http://tinyurl.com/3pdte5
22:29:55 <dons> running in a state monad.
22:30:15 <lispy> dons: and then hand the state off to the event handlers or?
22:30:31 <dons> the events come in, we handle them, then render the resulting state to the screen.
22:30:34 <dons> model/view/controller
22:30:35 <lispy> Er, well Iguess the handlers are in the monad too...
22:30:48 <dons> everything is in a monad.
22:30:59 <dons> you, me, the moon, the sun and the stars.
22:31:07 <adu> my toes?
22:31:07 <thetallguy> 45 clowns
22:31:13 <dons> 45 clowns are in the monad.
22:31:16 <kosmikus> dons: hi. have you ever got any more information on the "strange synopsis" issue for real-world haskell?
22:31:18 <lispy> the LHC too?
22:31:18 <dons> adu's toes too.
22:31:21 <sjanssen> lispy: the even handler is mostly hard-coded in the event loop
22:31:26 <thetallguy> what's the record of clowns in a monad?
22:31:28 <Saizan> i guess the need of globals/IORefs arises from the IO-typed callbacks
22:31:28 <dons> kosmikus: hmm. remind me?
22:31:51 <sjanssen> lispy: though sometimes we pass events off to layouts, which return an updated version of their own state
22:31:54 <lispy> Saizan: yeah, I was just trying to recall if that is the case
22:31:54 <kosmikus> dons: strange text being displayed for the book on a couple of websites.
22:31:55 <dons> thetallguy: i believe 17 were observed escaping unsafely from a monad last winter.
22:32:06 <dons> kosmikus: ah yes. the publisher is pursuing this.
22:32:09 <dons> new text will go out.
22:32:19 <Saizan> if they could by MonadIO m => m a, it'd be easier to manage your state
22:32:31 <ivanm> dons: awwww..... spoilsport! :p
22:32:32 <kosmikus> dons: ok, good.
22:32:41 <thetallguy> dons: Saw that in a police blotter, did ya?
22:33:03 <RayNbow> int-e: did you write a one-liner for the countChange problem yesterday?
22:33:11 <dons> i think it was on "Cops: Life in the Type Checker"
22:33:16 <thetallguy> I was going to say, whatever the record, I'm sure it has to be prime.
22:33:43 <Axman6> if i want to check if a number's evenly divisible by the numbers 1..20, caqn i only check against the numbers 11..20, since all the lower numbers have nigher multiples in that range?
22:33:54 <thetallguy> That's what we need, a program that shows police rounding up programmers that publish code with type errors.
22:34:07 <int-e> Axman6: yes
22:34:09 <int-e> RayNbow: yes
22:34:19 <thetallguy> Get that guy!  He used a partial function!
22:34:41 <adu> perhaps more functions in Data.IORef would be useful, like readRef :: IO (IORef a) -> IO a; writeRef :: IO (IORef a) -> a -> IO (); withRef :: IO (IORef a) -> (a -> b) -> IO b
22:34:44 <adu> that would be nice
22:34:49 <Axman6> int-e: cheers
22:35:02 <sjanssen> adu: why would those be useful?
22:35:09 <int-e> Axman6: of course checking divisibility by 16, 9, 5, 7, 11, 13, 17 and 19 is enough.
22:35:23 <RayNbow> int-e: could you show your solution? (my solution is a recursive 5-liner :p)
22:35:30 <int-e> (i.e. for primes < 20, the largest prime power < 20)
22:35:42 <Axman6> yeah i was thinking that
22:35:48 <int-e> RayNbow: count_change3 n d = if n < 0 then 0 else foldl (\c d -> fix (zipWith (+) c . (replicate d 0 ++))) (1 : repeat 0) [1..d] !! n
22:36:02 <Axman6> but, that's only one less number than what i'm using, so i'm ok with it
22:36:04 <int-e> RayNbow: even more unreadable and without handling n<0: c n d=foldl(\c d->fix(zipWith(+)c.(replicate d 0++)))(1:repeat 0)[1..d]!!n
22:36:06 <adu> because then you could do (withRef globals camera) even if globals :: IO (IORef Globals)
22:36:45 <lispy> adu: but isn't that the same as just not doing the unsafePerformIO when creating the globals?
22:36:52 <lispy> adu: meaning, the state doesn't really update
22:37:00 <Axman6> i don't know why i skipped project euler problem 5 until now :\
22:37:04 <adu> instead of (do gref <- globals ; g <- readIORef gref ; camera g)
22:37:23 <Saizan> adu: that would give you a _different_ IORef each time
22:37:53 <RayNbow> int-e: interesting... :)
22:37:54 <adu> so unsafePerformIO is really the way to go?
22:38:12 <RayNbow> although I always have a hard time figuring fix out :p
22:38:13 <dons> how much time do you have?
22:38:35 <Axman6> hmmm... this is taking a lot longer than i has hoped it would
22:38:36 <Saizan> the way to go is creating the "global" IORef in main (or so) and passing that around, probably in a monad
22:38:37 <lispy> I think Saizan and sjanssen really hit the nail on the head.  The reason I recall wanting to do the unsafePerformIO trick before was because in gtk2hs your functions are just in the IO monad instead of MonadIO, but with xmonad they have a state monad and control over the event loop.  So I think in the gtk2hs problem, maybe we need to give more control over the event loop on the haskell side?
22:38:58 <Axman6> had*
22:39:11 <int-e> RayNbow: I think it could be fun to dissect. :)
22:39:20 <adu> Saizan: right, but that creates refactorization problems
22:40:01 <lispy> We need sample code to discuss this more, I think.
22:40:10 <adu> Saizan: if you do it that way, and design part of your program that doesn't require globals, then you later realize that you do need globals, you need to reparameterize everything along the way from main to that part of your program, and when you have to reparameterize 20 functions, this is a major pain
22:40:29 <dcoutts> lispy: you can pass your state around even though it's in IO not MonadIO
22:40:29 <lispy> Someone go write a calendar app in gtk2hs and we'll talk about how to structure that as model/view/controller from haskell :)
22:41:05 <dcoutts> there's a nice trick to it someone posted to haskell-cafe iirc
22:41:11 <lispy> dcoutts: I'd love to see examples of what you have in mind.
22:41:13 <RayNbow> int-e: yeah... :) my version only uses boring list comprehension and primitive recursion :p ( http://raynbow.pastebin.com/d537c5a8b )
22:41:22 <Saizan> dcoutts: quicksilver's InterleavableIO?
22:41:22 <lispy> dcoutts: I'm sure there must be an elegant haskell solution, I just don't know it.
22:41:25 <dcoutts> basically the state gets stashed into an IORef
22:41:29 <dcoutts> Saizan: probably
22:41:31 <Saizan> yeah
22:41:41 <dolio> How are you going to read a global IORef from deep withing your pure program without changing the types anyway?
22:41:51 <lispy> dcoutts: Oh, but I want to avoid top level unsafePerformIO on an IORef.
22:42:00 <dcoutts> lispy: no unsafe perform
22:42:04 <lispy> dcoutts: oh good
22:42:09 <dcoutts> just allocate the IORef
22:42:26 <lispy> dcoutts: where, in main?
22:42:48 <dcoutts> I don't recall, see quicksilver's InterleavableIO
22:42:55 <lispy> k
22:43:00 <dcoutts> the other approach is using threads and channels
22:43:06 <dcoutts> which amounts to the same thing in the end
22:43:59 <lispy> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
22:44:01 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
22:44:07 <lispy> I think that's the email
22:44:17 <int-e> RayNbow: interesting. I had  | otherwise = sum [countChange n' (d-1) | n' <- [n, n-d..0]] (and somewhat different stop conditions)
22:45:58 <Saizan> well, that approach is a bit weird with asynchronous callbacks, but i guess you can use an MVar
22:46:41 <sjanssen> I want to do something like [d| type V = $(foo) |], what am I doing wrong?
22:47:44 <Saizan> maybe that's one of the many places where $(..) is not allowed?
22:47:51 <RayNbow> int-e: ah... I based my solution off a sketch for a particular (n,d): http://i296.photobucket.com/albums/mm178/ShinNoNoir85/count_change.jpg
22:47:52 <lambdabot> http://tinyurl.com/3p4gx9
22:48:33 <RayNbow> (my handwriting is horrible :p)
22:48:40 <sjanssen> Saizan: I'm having trouble finding real documentation, but one tutorial seems to indicate that splices can occur in place of a type
22:49:02 <sjanssen> the lack of documentation on TH is truly ridiculous
22:49:20 <int-e> RayNbow: I saw the sketch. you could also write  | otherwise = countChange (n-d) d + countChange n (d-1)  (with suitable stop conditions) - and there are two ways to turn that into a "loop" with sum. You chose one, I chose the other one, and I wasn't aware that there was a choice before I saw your code.
22:49:48 <RayNbow> ah
22:49:51 <RayNbow> right :)
22:51:43 <adu> I still think 1 unsafePerformIO is much better than dozens of g's
22:52:58 <sjanssen> Saizan: yes, you're right.  Seems this tutorial lies
22:54:18 <lispy> this is crazy
22:54:28 <lispy> the interleaveIO bit
22:54:49 <int-e> @type \a -> ask >>= runReaderT a
22:54:50 <lambdabot> forall (m :: * -> *) a b. (MonadReader a m) => ReaderT a m b -> m b
22:55:38 <int-e> if you build all your code from a ReaderT IORef, you can use a function like that to produce callbacks.
22:55:39 <yakov2> I have only seen one 'problem' in haskell thus far, it's that its using thisCase instead of this_case :)
22:56:12 <bd_> @type (ask >>=) . runReaderT
22:56:14 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => ReaderT r m a -> m a
22:56:25 <int-e> @pl \a -> ask >>= runReaderT a
22:56:26 <lambdabot> (ask >>=) . runReaderT
22:56:42 <bd_> @unpl (ask >>=) . runReaderT
22:56:42 <lambdabot> (\ d -> ask >>= (runReaderT d))
23:02:18 <Saizan> yeah using Reader is isomorphic to adding a global to your language
23:03:16 <lispy> dcoutts: at the end, Jules says not to use them for event handlers :(
23:04:53 <lispy> or maybe it's okay
23:04:58 * lispy learns to read to the end
23:05:37 <Saizan> it says you must do things a little differently to make it work
23:07:30 <adu> yakov2: and you know what's worse? "_" is a valid identifier character
23:09:05 <lispy> Saizan: yeah, so then I hope the InterleaveIO library has this generalization
23:11:38 <Saizan> it's a matter of instances afaiu, and it doesn't look like there's the one we'd want
23:13:54 <quicksilver> http://www.wordarc.com/images/linked_lists.jpg
23:14:18 <ivanm> that's the love one?
23:15:02 <quicksilver> yeah.
23:15:54 <lispy> Saizan: but, I'm thinking about it...it does seem that events in GUIs are synchronis even if they happen after main has finished, right?
23:16:05 <lispy> Saizan: each event is handled to completion before the next one begins
23:16:15 <lispy> Saizan: or is this not sufficient?
23:17:09 <quicksilver> most GUIs are synchronous in that sense
23:17:18 <quicksilver> most of them don't indeed using threading
23:17:29 <quicksilver> so you can just use IORefs
23:17:42 <quicksilver> but if you're diong your own threading, which runs along side the GUI's "main loop"
23:17:43 <lispy> okay, so interleavableIO would be usable with, say, gtk2hs out of the box
23:17:51 <quicksilver> then you need to use MVars.
23:18:00 <quicksilver> as long as you use gtk2hs 'naively', yes
23:18:10 <quicksilver> (meaning, give gtk2hs the main thread and work in callbacks entirely)
23:19:14 <lispy> I wish someone, besides myself, would update interleavableIO to support asynchronous events, but I think I'm happy with what is there should I need to use gtk2hs anytime soon.
23:20:47 <lispy> It's quite the clever trick
23:21:49 <Saizan> quicksilver: even if the callbacks are processed in mutual exclusion StateT's embed just reads the state that's in the IORef when the register function returns, no?
23:22:34 <Saizan> so when the callback it's effectively run noone is going to read what it writes
23:22:42 <Saizan> s/it's/is/
23:23:23 <Saizan> apart from the callback itself if it's run more than once..
23:23:28 <lispy> register function?
23:23:40 <lispy> oh, registered
23:23:56 <Saizan> register function == the function that's accepting the callback
23:24:04 <Saizan> i'm not sure how to call it :)
23:24:27 <quicksilver> the various callbacks, though
23:24:32 <quicksilver> are all tied to the same IORef
23:24:40 <quicksilver> well, if you do it right :)
23:24:47 <quicksilver> I didn't sketch that part completely in my email.
23:25:01 <quicksilver> I don't know if the interleaveIO library gets it right.
23:25:21 <quicksilver> obviously your keyabord/mouse/idle/redisplay callbacks need to all be tied to the same IORef.
23:25:31 <Saizan> yeah, if it's the same as the email each one has a different IORef
23:25:34 <lispy> This, "getting it right" aspect is why I'd love for someone to implement it for me :)
23:25:51 <quicksilver> the thing is I've not actually written a program which uses it.
23:25:58 <quicksilver> which is why it remained a sketch :)
23:26:14 <Saizan> essentially you implement MonadState with ReaderT (IORef s)
23:26:22 <quicksilver> atm I'm more interested in FRP, which solves the same problem but hides it in further level of abstraction.
23:26:45 <quicksilver> yes, the observation is that you can embed state/reader/writer in an IORef
23:26:55 <quicksilver> and you can embed Error/Maybe in IO's built-in exceptions.
23:27:06 <quicksilver> and with Cont you're out of luck ;)
23:27:27 <lispy> I should read the frp stuff
23:27:37 <lispy> is frp compatible with gtk2hs?
23:28:05 <quicksilver> well frp is a technique
23:28:09 <quicksilver> like 'OO'
23:28:12 <quicksilver> not an implementation.
23:28:19 <quicksilver> I'm trying to get something working with conal's formulation
23:28:21 <quicksilver> "Reactive"
23:28:33 <quicksilver> the glue to attach it to a conventional library is non-trivial.
23:29:08 <lispy> I see
23:32:17 <lispy> quicksilver: if you come up with something cool you know where to post it :)
23:32:21 <Saizan> quicksilver: is there something like tails for reactives?
23:34:41 <quicksilver> Saizan: you mean, seeing all future events?
23:34:46 <quicksilver> I'm not sure what you do mean ;)
23:36:02 <Saizan> i mean tails :: Reactive a -> (Reactive (Reactive a)), where each returned Reactive starts one event later
23:37:20 <quicksilver> yes, you can write that.
23:37:26 <quicksilver> I don't think there is any point though.
23:38:15 <quicksilver> lispy: I'm also not using conal's implementation, for various reasons.
23:38:27 <quicksilver> It seems to be surprisingly hard to implement Reactive in normall haskell.
23:42:19 <ski> is `Reactive' a comonad ?
23:42:47 <Saizan> no, a monad
23:43:19 <Saizan> well, it's defined as a monad, at least
23:43:40 <Kitchy> How large is Haskell? I'm wondering if I can upload it to my Apache webserver and write Haskell scripts.
23:43:55 <Axman6> huh?
23:44:41 <Kitchy> Like, I want to be able to upload Haskell code to my website and make it execute.
23:44:49 <ski> Haskell is a language. it's size is not (usually) measured in bits .. maybe you meant one of the Haskell *Implementations* ?
23:45:23 <Kitchy> Yeah. The compiler/interpreter or whatever.
23:46:36 <Kitchy> My webhost supports Java, C, C++, etc. I want to ad Haskell if I could.
23:47:10 <Saizan> ghc itself is around 150mb
23:47:43 <Saizan> but you can compile locally and upload just the binaries, of course
23:47:52 <dons> Kitchy: oh, a basic hello world is about 200k.
23:48:04 <dons> so should be fine for uploading statically linked binaries to your webserver.
23:48:42 <Kitchy> Yeah, I think so. I'll have to ask how when I ready to do that.
23:49:01 <Kitchy> I don't really want my source code uploaded anyway.
23:52:34 * sjanssen wishes Haskell had C++ templates
23:54:27 <Baughn> sjanssen: I switch here, and that's what I see?
23:54:39 <Baughn> ..pray tell, explain your wish. ;_;
23:54:44 <sjanssen> Baughn: :)
23:54:52 <sjanssen> Baughn: are you familiar with Data.FingerTree?
23:55:39 <sjanssen> (or maybe what I want is ML modules, but I don't know ML well enough to say for sure)
23:56:10 <sjanssen> Haskell lacks a way to generate specialized data and functions
23:56:26 <ivanm> "specialised"?
23:56:33 <sjanssen> eg. there are all kinds of optimizations we can do on Map if we knew that the key is always Int
23:56:54 <Baughn> sjanssen: Well, template haskell? Or specialize rules?
23:57:17 <sjanssen> Baughn: I've just done something like this with TH, and it was really rough
23:57:29 <sjanssen> Baughn: rules only apply to functions
23:58:01 <sjanssen> take "data SMaybe a = SNothing | SJust !a"
23:58:33 <sjanssen> if we know that a is Int, we can unbox the parameter to SJust, which can be a big win
23:59:16 <Baughn> So you can, but isn't that what -O2 is for?
23:59:35 <sjanssen> GHC can't specialize data, only functions
23:59:42 <Baughn> Hmm
