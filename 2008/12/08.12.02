00:00:10 <extasic> but that MayBe in combination with fold drives me crazy
00:00:17 <mgdtgd> when I try to acces the n-th element, all elements before that are calculated right?
00:00:28 <extasic> it doesn't even work without defining a type
00:00:30 <Saizan> extasic: well, that can't typecheck
00:00:40 <Zao> mgdtgd: foldM with a suitable monad?
00:01:06 <mgdtgd> zao: what?
00:01:24 <Saizan> extasic: since if the first argument to foldN is (Nothing :: Maybe Nat) then the second argument must be of type Maybe Nat -> Maybe Nat
00:01:35 <Saizan> extasic: but there you've wrapped helper in a Just
00:02:00 <extasic> I tried to use the "just" inside the helper function as well
00:02:04 <Saizan> extasic: making it of type Maybe X for some type X depending of the type of handler
00:02:09 <mib_pduyq1rw> > sss 27 5 [] [] [10,5,2,1] where sss 0 0 s r _ = r : s; sss _ _ s _ [] = s; sss v c s r (x : xs) = if (x <= v) then sss (v - x) (c - 1) (sss v c s r xs) (x :  r) (x : xs) else sss v c s r xs
00:02:11 <lambdabot>   [[1,1,5,10,10],[2,5,5,5,10]]
00:02:32 <centrinia> mib_pduyq1rw: [1,1,5,10,10] is not a solution.
00:02:41 <Saizan> extasic: what do you find confusing about Maybe a?
00:02:57 <extasic> I don't know how to combine it with foldN
00:03:05 <pumpkin_> centrinia: it isn't?
00:03:15 <mib_pduyq1rw> It is a list of cardinality 5 summing up to 27 using the required values multiple times if required [10,5,2,1]
00:03:25 <pumpkin_> multiple times :o
00:03:51 <centrinia> If [1,1,5,10,10] is a solution, then so is replicate 27 1 :p
00:03:53 <pumpkin_> that's like the "superset sum" problem :P
00:04:02 <pumpkin_> centrinia: he wants something of cardinality 5
00:04:10 <centrinia> Oh.
00:04:32 <BeelsebobWork> hmm, is it me, or is the book list at http://haskell.org/haskellwiki/Books_and_tutorials, completely useless
00:04:33 <lambdabot> Title: Books and tutorials - HaskellWiki
00:04:43 <BeelsebobWork> you'd expect to get some info on the books when you click on their covers
00:04:52 <BeelsebobWork> not the wiki's image upload page
00:05:10 <mib_pduyq1rw> The idea of the example is to show that if you do not remove the useless options from the beginning (instead of filtering at the end) you blow your computer.
00:05:57 <Saizan> extasic: well, think about foldN first, foldN z f (Succ (Succ (Succ Zero))) == f (f (f (z)))
00:06:04 <pumpkin_> mib_pduyq1rw: so how large can you go in tractable time?
00:06:33 <Saizan> extasic: now, you've to write f and z such that f (f (f z)) = Just (Succ (Succ Zero))
00:06:35 <centrinia> mib_pduyq1rw: Filtering during a comprehension is a lot better than filtering after a comprehension. :)
00:07:29 <mib_pduyq1rw> The original question was how do I do that in a comprehension (like fib) instead of a function
00:07:56 <Saizan> extasic: z = Nothing was right, since you want foldN z f Zero = z = Nothing
00:08:16 <mib_pduyq1rw> More precisely, the fib example is a kind of 'recursive' comprehension which I don't understand very well
00:08:23 <centrinia> > let fib = 0:1:zip fib (tail fib) in fib !! 1000
00:08:24 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
00:08:24 <lambdabot>        Exp...
00:08:31 <centrinia> > let fib = 0:1:zipWith (+) fib (tail fib) in fib !! 1000
00:08:33 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
00:08:39 <centrinia> See, that's easy. :)
00:08:48 <centrinia> > let fib = 0:1:zipWith (+) fib (tail fib) in fib !! 10000
00:08:49 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
00:09:13 <pumpkin_> or you can use the fancy fib I defined earlier :P
00:09:40 <centrinia> > let fib = 0:1:zipWith (+) fib (tail fib) in (fib !! 10002) == (fib !! 10000) + (fib !! 10001)
00:09:42 <lambdabot>   True
00:12:22 <centrinia> > let { fib = 0:1:zipWith (+) fib (tail fib); isprime n = (n == 2) || (and [ (n `mod` p) /= 0 | p <- [2..n-1]]) } in take 10 $ filter isprime fib
00:12:24 <lambdabot>   [0,1,1,2,3,5,13,89,233,1597]
00:12:29 <centrinia> There. :)
00:13:09 <centrinia> > let { fib = 0:1:zipWith (+) fib (tail fib); isprime n = (n == 2) || (and [ (n `mod` p) /= 0 | p <- [2..n-1]]) } in take 30 $ filter isprime fib
00:13:22 <centrinia> Hmm.
00:13:25 <lambdabot>   thread killed
00:13:34 <centrinia> That sucked.
00:14:22 <pumpkin_> is there a Primes module out there with sophisticated prime generators and primality tests?
00:15:09 <centrinia> Most likely.
00:15:15 <extasic> Saizan: I just tried mine and Nothing is returned corretly when calling subN Zero
00:15:22 <mib_pduyq1rw> Let me see if I got the idea: I have to reify the intermediate computations into a list that is reused by the subsequent stage of the algorithm (which can apply a filter as requested, thus filtering 'during the construction' as discussed)
00:16:59 <Saizan> extasic: yours being?
00:17:10 <Saizan> @paste
00:17:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:17:54 <extasic> the definition 'subN x = foldN Nothing helper x' is correct, isn't it? It's just all about the helper function
00:17:58 <Saizan> mib_pduyq1rw: yeah, the list is defined in terms of itself
00:18:07 <Saizan> extasic: right
00:19:23 <Saizan> extasic: and your helper function has two cases: helper Nothing = ...; helper (Just n) = ...
00:20:38 <extasic> doesn't the second case look like 'Just (Succ(n))'?
00:20:55 <extasic> because I can't split the n directly, can I?
00:20:59 <mib_pduyq1rw> I have to install a Haskell compiler and experiment a bit with it. I will probably be back with more questions. Thanks everyone for your help.
00:21:17 <Saizan> Just n subsumes both "Just Zero" and "Just (Succ n')"
00:21:44 <Saizan> i was suggesting that you don't really care what the n looks like to write helper
00:24:53 <extasic> but how do I then return the parent of n?
00:25:21 <Saizan> what do you mean by parent?
00:27:27 <Saizan> implementing subN with foldN won't be "efficient", i.e. the result won't share much of its structure with the input
00:27:48 <Saizan> that's a limitation of foldN
00:28:38 <Saizan> well, unless one starts to be clever with function composition i guess
00:31:44 <Raevel> @tell dons seems rwh is in stock in sweden now!
00:31:44 <lambdabot> Consider it noted.
00:32:40 <olsner> Raevel: in stock or "we can order it from the publisher now, so let's pretend we have it in stock"? :P
00:33:13 <Raevel> well they went down from 24-40 working days to ship, to 5-8
00:33:47 <jkff> Hi. In SICP's example on modeling digital circuits and in some FRP implementations that I saw mentioned, they group together events that occur at exactly the same point in time. Is it for the sake of efficiency? Why not take a point of view that there are no "same" points in time and serialize everything?
00:35:47 <mmorrow> i think digital if and only if there's a clock ticking
00:36:07 <mmorrow> otherwise it'd be an analog circuit
00:36:22 <mmorrow> (my 2 cents fwiw :)
00:36:24 <pumpkin_> mmorrow: can I perform IO in TH and generate code based on it?
00:36:25 * mmorrow sleeps
00:37:06 <mmorrow> main = $(runIO (system "xeyes &" >> print "aaasdf") >> [|return ()|])
00:37:10 <mmorrow> oh yesh
00:37:21 <pumpkin_> :P
00:37:29 <mmorrow> runIO :: (Quasi m) => m a -> Q a
00:37:48 <mmorrow> import Language.Haskell.TH.Syntax
00:37:54 <mmorrow> import Language.Haskell.TH.Lib
00:37:56 <mmorrow> import Language.Haskell.TH.Ppr
00:38:22 <mmorrow> let me know how it goes
00:38:23 <mmorrow> night
00:42:36 <jkff> mmorrow: Well, to model an AND gate you don't need a clock ticking, do you?
00:48:33 <fasta> In case anyone messaged me, I didn't read it.
00:48:48 <dmwit> no one did
00:48:57 <dmwit> I promise
00:49:58 <fasta> dmwit: I know someone did.
00:50:27 <fasta> dmwit: XChat for Windows crashes when you click the icon.
00:50:35 <dmwit> ew
00:59:26 <pumpkin_> what's an elegant way of taking an array [[1,2, 3], [2, 3, 4]] and generating [(1,2), (2,3), (3,4)] from it? I'm guaranteed the array will only have two elements in it
01:00:09 <dmwit> How about with zip?
01:00:11 <oklopol> zip
01:00:18 <Saiz> foo [x,y] = zip x y
01:00:20 <lament> pumpkin_: if you mean list, say list
01:00:28 <dmwit> or transpose
01:00:29 <pumpkin_> sorry, I meant list
01:00:37 <dmwit> > transpose [[1..3], [2..4]]
01:00:40 <lambdabot>   [[1,2],[2,3],[3,4]]
01:00:47 <pumpkin_> yeah, good idea
01:00:50 <pumpkin_> thanks
01:01:05 <oklopol> what's transpose?
01:01:19 <BeelsebobWork> it flips a 2x2 matrix over it's diagonal axis
01:01:21 <pumpkin_> it transposes the list of lists as if it were a matrix
01:01:29 <BeelsebobWork> nxn rather
01:01:31 <oklopol> ah
01:01:31 <BeelsebobWork> 2D
01:01:44 <oklopol> yes ofc nice
01:01:59 <centrinia> What if the list of lists is not rectangular?
01:02:09 <centrinia> > transpose [[1],[2,3]]
01:02:11 <lambdabot>   [[1,2],[3]]
01:02:17 <lament> hah!
01:02:25 <centrinia> > transpose [[1],[2,3],[]]
01:02:27 <lambdabot>   [[1,2],[3]]
01:02:30 <dmwit> Yes, transpose . transpose is not id.
01:02:56 <pumpkin_> I remember there was a really really elegant way to do transpose in scheme
01:03:00 <lament> > transpose [[1,2,3], [10], [100, 200]]
01:03:00 <centrinia> Does transpose . transpose . transpose = transpose ? :p
01:03:02 <lambdabot>   [[1,10,100],[2,200],[3]]
01:03:21 <pumpkin_> centrinia: quickcheck it :P
01:03:28 <lament> centrinia: sounds like the C idiom !!
01:03:42 <jkff> By the way, does lambdabot support quickcheck? Would be extremely cool.
01:03:47 <lament> it does.
01:03:52 <dmwit> centrinia: should do
01:03:53 <pumpkin_> @quick
01:03:54 <lambdabot> Not enough privileges
01:03:59 <pumpkin_> o.O
01:04:00 <BeelsebobWork> @check (transpose . transpose . transpose == transpose)
01:04:01 <lambdabot>       No instance for (Eq ([[a]] -> [[a]]))
01:04:01 <lambdabot>        arising from a use of `=='...
01:04:04 <pumpkin_> whoops :)
01:04:20 <BeelsebobWork> @check (\x -> (transpose . transpose . transpose $ x) == transpose x)
01:04:21 <jkff> @check (\x -> (transpose.transpose.transpose) x == transpose x)
01:04:23 <lambdabot>   "OK, passed 500 tests."
01:04:23 <jkff> Heh
01:04:26 <lambdabot>   "OK, passed 500 tests."
01:04:30 <BeelsebobWork> :)
01:05:00 <lament> it passed 500 test, therefore it must be true
01:05:01 <dmwit> ?check liftM2 (==) (transpose . transpose . transpose) transpose
01:05:04 <lambdabot>   "OK, passed 500 tests."
01:05:19 <BeelsebobWork> @check (transpose . transpose . transpose) <^(==)^> transpose
01:05:20 <jkff> @check ((\f x->(f.f.f)x==f x) transpose)
01:05:20 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
01:05:22 <BeelsebobWork> :(
01:05:23 <lambdabot>   "OK, passed 500 tests."
01:05:30 <jkff> I win!
01:05:35 <lament> @check \x -> x /= 42
01:05:37 <lambdabot>   "Falsifiable, after 213 tests:\n42\n"
01:05:52 <BeelsebobWork> @let x <^ y = y `fmap` x
01:05:53 <lambdabot>  Defined.
01:05:54 <Modius> Is there a standard haskell function for splitting a list into sub-lists (keeping overall order) based on some shared characteristic between adjacents?
01:05:59 <lament> @check \x -> x /= 69105
01:06:00 <lambdabot>   "OK, passed 500 tests."
01:06:02 <BeelsebobWork> @let x ^> y = x <*> y
01:06:03 <lambdabot>  Defined.
01:06:06 <BeelsebobWork> @check (transpose . transpose . transpose) <^(==)^> transpose
01:06:07 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
01:06:08 <jkff> So, the first 213 random numbers are not an answer to life, universe and everything.
01:06:10 <BeelsebobWork> oh
01:06:11 <BeelsebobWork> that's lame
01:06:18 <BeelsebobWork> @check doesn't pay attention to @let
01:06:18 <lambdabot>   Parse error at "let" (column 27)
01:06:33 <Saiz> Modius: maybe groupBy ?
01:06:47 <centrinia> @check \x y z n -> (n > 2) && (x^n + y^n /= z^n)
01:06:48 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n-1\n-1\n0\n"
01:07:15 <centrinia> @check \x y z n -> (n > 2) && (x > 1) && (y > 1) & (z>1) && (x^n + y^n /= z^n)
01:07:16 <lambdabot>   Not in scope: `&'
01:07:21 <centrinia> @check \x y z n -> (n > 2) && (x > 1) && (y > 1) && (z>1) && (x^n + y^n /= z^n)
01:07:21 <pumpkin_> is there a good way of making a function that takes an arbitrarily nested list (under the assumption it's a "hypercube") and tells you its dimensions?
01:07:22 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0\n0\n0\n"
01:08:06 <centrinia> That makes no sense.
01:08:06 <Saiz> well, depends which type you want that to have
01:08:14 <lament> pumpkin_: good question. What do you want the type be?
01:08:54 <Saiz> you can use a typeclass, or a tree
01:09:05 <pumpkin_> hmm
01:09:26 <lament> typeclass makes sense
01:09:50 <centrinia> pumpkin_: How about a function dims :: Nested a -> [Int]  where data Nested a = Simply a | Nest [Nested a] ?
01:10:08 <pumpkin_> hmm
01:10:08 <dmwit> pumpkin_, Saiz, lament: Actually, not really, surprisingly.
01:10:15 <jkff> Like, class Deep a where depth :: Int; depth=1; instance (Deep a) => Deep [a] where depth = depth+1
01:10:21 <pumpkin_> I was hoping for something like
01:10:22 <pumpkin_> let dim x = case x of [] -> 0; (a:b) -> length a : dim b
01:10:28 <dmwit> If you happen to know what base types you're interested in, then a type class can do the trick.
01:10:29 <pumpkin_> or [] instead of 0, actually
01:10:37 <dmwit> But if you want it to work in general, you're a little bit hosed.
01:10:45 <pumpkin_> hmm
01:10:46 <jkff> And class Deep a => Dimensions a where dimensions :: [Int]
01:10:52 <jkff> And stuff.
01:11:00 <lament> dmwit: why?
01:11:41 <Cale> You could use overlapping instances
01:11:42 <dmwit> lament: Well, you end up wanting to declare something like "instance Dimension a where depth = const 1" and "instance Dimension [a] where depth x = 1 + depth (head x)".
01:11:52 <lament> yes
01:11:58 <dmwit> But then the compiler doesn't "know" where to stop.
01:12:01 <jkff> dmwit: Why not my variant?
01:12:05 <Saiz> that works well with overlapping instances, no?
01:12:09 <lament> dmwit: oh, that declaration won't compile?
01:12:11 <dmwit> For the type [Int], should it use the [a] instance or the a instance?
01:12:21 <lament> oh, i see
01:12:26 <Saiz> it uses the [a] since it's more specific
01:12:29 <lament> so you don't define it for a
01:12:29 <dmwit> Overlapping instances might do the trick, I don't know.
01:12:41 <lament> define it for the types you're interested in...
01:12:42 <dmwit> lament: Right, you have to know which base types you want.
01:12:48 <lament> but this makes sense
01:13:04 <lament> any "atomic" type could actually be "a list"
01:13:16 <pumpkin_> hmm
01:13:17 <lament> you the programmer do need to know where to stop
01:13:22 <Saiz> overlapping instances would make much more sense if you could declare a typeclass as closed
01:13:26 <dmwit> jkff: You can't have a class member which does not mention the class type variable.
01:13:39 <dmwit> jkff: class Deep a where depth :: Int -- just doesn't make sense
01:13:49 <jkff> Oh, ok
01:13:49 <dmwit> (How would it know which instance to use when you type "depth"?)
01:13:55 <pumpkin_> so there's no way I can have a general function that could take a [[[[a]]]] or a [[[a]]]] and return [5,4,2,1] or [3,1,5], respectively (where those are the dimensions)?
01:14:24 <lament> no
01:14:32 <pumpkin_> boo hoo :)
01:14:41 <Saiz> you can with a typeclass and overlapping instances :)
01:15:45 <dmwit> pumpkin_: If you want that kind of thing, you might actually be using multi-dimensional arrays, not lists.
01:15:56 <pumpkin_> dmwit: yeah, I really am, but was just curious :)
01:15:58 <dmwit> (i.e. bounds-checking is usually a sign of non-list behavior)
01:16:04 <centrinia> Too bad that there isn't a concept of a complementary typeclass.
01:16:42 <dmwit> pumpkin_: Let me know if you find something satisfactory for n-D arrays. =)
01:16:53 <dmwit> I hacked together something that works for me... but it's still way cumbersome to use.
01:17:17 <pumpkin_> I'll probably just keep using lists for now (by I really am, I meant I really should be using n-d arrays, but I am just using lists)
01:17:28 <pumpkin_> my project is due on wednesday :(
01:19:43 <pumpkin_> > foldl (,) 0 [1..4]
01:19:44 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, b)
01:19:44 <lambdabot>        Exp...
01:19:58 <pumpkin_> am I just doing it wrong, or that's an inherent limitation?
01:20:16 <BeelsebobWork> what type do you expect foldl (,) 0 to have?
01:20:41 <pumpkin_> an infinite one :)
01:20:51 <BeelsebobWork> there you go then ;)
01:21:06 <BeelsebobWork> you can't check if two types unify if one of them is infinite
01:21:27 <Saiz> nah, it won't be infinite, the only "reasonable" type depends on the length of the input list
01:21:30 <pumpkin_> it still seems like it should be possible to construct something like that on an infinite list :P
01:21:51 <BeelsebobWork> pumpkin_: indeed -- this is a case where the type system cuts off a set of correct programs
01:22:05 <pumpkin_> Saiz: why does your nick shorten sometimes?
01:22:11 <Saiz> @let newtype Tup a = Tup (a,Tup a)
01:22:12 <lambdabot>  Invalid declaration
01:22:32 <Saiz> pumpkin_: because my connection drops and my client picks this one
01:22:35 <BeelsebobWork> Saiz: uh, doesn't that just... make a list?
01:22:41 <pumpkin_> Saizan: are you italian
01:22:42 <pumpkin_> ?
01:22:43 <BeelsebobWork> i.e. what advantage does that type have over []
01:23:20 <Saizan> Beelsebob: uhm, no-one, i just wanted to show how you can tame infinite types with recursion
01:23:32 <BeelsebobWork> ah, okay
01:23:32 <Saizan> pumpkin_: yeah
01:23:51 <centrinia> @let data Nested a = Simply a | Nested [Nested a]
01:23:52 <lambdabot>  Invalid declaration
01:23:54 <pumpkin_> Saizan: ah cool, I'm from rome :)
01:24:03 <pumpkin_> I tried going to #haskell.it but not much going on in there :P
01:24:39 <BeelsebobWork> aww, no haskell.nl -- I'm surprised
01:24:41 <pumpkin_> centrinia: then I can fold, but I basically have a list :P
01:24:58 <Saizan> heh, yeah, it's really low volume :)
01:25:46 <centrinia> > foldl1 (,) [1..4]
01:25:48 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
01:25:48 <lambdabot>        Exp...
01:26:30 <pumpkin_> tuples feel like the red-haired bastard child of haskell
01:26:50 <Saizan> yeah, you're not supposed to use tuples much
01:26:57 <centrinia> Why, because it has a sibling called data Tup a b = Tup a b ?
01:27:27 <BeelsebobWork> tuples really should have been pairs
01:27:36 <BeelsebobWork> and just an infix type declaration
01:27:43 <BeelsebobWork> data a , b = a , b
01:27:43 <dmwit> Tuples are anonymous data structures in the same way that lambdas are anonymous functions.
01:27:51 <centrinia> > (1,2,3,4,5,6,7,8,9)
01:27:52 <lambdabot>   (1,2,3,4,5,6,7,8,9)
01:27:56 <dmwit> Useful to throw around from time to time, but anything that gets heavy use should have a name.
01:27:56 <centrinia> Okay.
01:28:02 <BeelsebobWork> and if we really wanted... data a ,! b = a ,! !b
01:28:05 <pumpkin_> let's try that famous 63-tuple
01:28:15 <centrinia> Which one?
01:28:34 <pumpkin_> there was some email about a 63-tuple crashing ghc I remember seeing
01:28:48 <centrinia> Is the bottom value the 0-ary tuple?
01:28:49 <dmwit> GHC won't compile anything with tuples longer than 62.
01:29:00 <dmwit> It doesn't crash, but it doesn't produce a program either.
01:29:00 <BeelsebobWork> > (1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3)
01:29:01 <lambdabot>       A 73-tuple is too large for GHC
01:29:01 <lambdabot>        (max size is 62)
01:29:01 <lambdabot>        Workarou...
01:29:05 <centrinia> Ah.
01:29:08 <BeelsebobWork> oops, too large
01:29:11 <Saizan> > ()
01:29:13 <lambdabot>   ()
01:29:32 <BeelsebobWork> and yeh, () should really have a real name
01:29:33 <BeelsebobWork> like Unit
01:29:52 * dmwit points at OneTuple
01:29:53 <centrinia> ((1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2),3,4,5,6,7,8,9,0,1,2,3)
01:29:58 <centrinia> > ((1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2),3,4,5,6,7,8,9,0,1,2,3)
01:29:59 <lambdabot>       No instance for (Show
01:29:59 <lambdabot>                         (t,
01:29:59 <lambdabot>                      ...
01:30:15 <centrinia> Why doesn't that tuple instance Show?
01:30:15 <dmwit> ?hackage OneTuple
01:30:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OneTuple
01:30:32 <dmwit> centrinia: The Show instances only go up to tuples of size 7, I think. =/
01:30:39 <BeelsebobWork> one tuple isn't unit
01:30:49 <dmwit> This is, in my opinion, one of the most obvious and easily fixed warts in Haskell's spec.
01:30:55 <dmwit> BeelsebobWork: I know.
01:31:05 <centrinia> I just made lambdabot show an 9-tuple. :p
01:31:55 <Cale> I don't think I would mind tuples only going up to maybe 4 or 5 elements or so. It's actually pretty rare to even see a 3-tuple.
01:31:57 <dmwit> Sorry, the limit is 14, not 7.
01:32:13 <Saizan> i think we should just ask the compilers to optimize (a ,! b ,! ... .! n) to the flat equivalent
01:32:17 <BeelsebobWork> Cale: I'd much rather just have pairs (possibly with right-strictness)
01:32:22 <Saizan> it can't be that hard!
01:32:26 <BeelsebobWork> Saizan: exactly
01:32:50 <BeelsebobWork> the only downside is the list syntactic sugar goes bye-bye
01:32:58 <BeelsebobWork> and that doesn't actually really clarify anything
01:33:05 <dmwit> But (a, (b, c)) and (a, b, c) aren't the same!
01:33:11 <Saizan> actually this could be subsumed by an efficient implementation of extensible records
01:33:21 <centrinia> Also, (,) is not associative!
01:33:24 <Saizan> dmwit: i used ,! for a reason
01:33:29 <BeelsebobWork> dmwit: no, and nor are a , b , c and a ,! b , c
01:33:36 <dmwit> Fair enough.
01:33:59 <centrinia> Wait, \x y -> (a ,b) is not associative!
01:35:15 * dmwit blinks
01:35:30 <dmwit> CPUTime.cpuTimePrecision
01:35:47 <BeelsebobWork> I did mention replacing tuples with (,) and (,!) on the Haskell' list
01:35:48 <dmwit> lowest number wins a prize
01:35:53 <BeelsebobWork> but I didn't get any response
01:36:11 <BeelsebobWork> 10000000000 -- uber enormous!
01:36:24 <dmwit> 10000000000 -- mine too
01:37:31 <Cale> BeelsebobWork: Why does the list syntactic sugar go away?
01:37:54 <dmwit> Only 100 clock ticks per second?  Surely that's not right...
01:37:56 <BeelsebobWork> Cale: because [1,2,3] could be either [1,2,3] or [(1,2,3)] or [1,(2,3)] etc
01:38:04 <Cale> huh?
01:38:13 <Cale> How so?
01:38:19 <BeelsebobWork> Cale: the proposal is to make (,) an infix data constructor
01:38:27 <BeelsebobWork> so parens wouldn't be needed around pairs
01:38:41 <Cale> hmm, I'm not sure I like that.
01:38:50 <BeelsebobWork> tbh, I don't care that much
01:39:01 <BeelsebobWork> 1:2:3:[] is hardly more verbose than [1,2,3]
01:39:04 <BeelsebobWork> and just as clean
01:39:18 <BeelsebobWork> the important list syntactic sugar is "jam"
01:39:27 <Cale> What about comprehensions?
01:39:36 <BeelsebobWork> oh, good point!
01:39:37 <dmwit> > [1,3..99]
01:39:39 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
01:39:43 <Cale> and that syntax :)
01:39:56 <BeelsebobWork> lame!
01:40:03 * BeelsebobWork ponders if there's any way to fix that
01:40:19 <Cale> Keep the parens, just make the underlying structure more uniform.
01:40:30 <BeelsebobWork> yeh -- but that stops it just being an operator
01:40:37 <Cale> I think that's okay.
01:40:47 <Cale> (,) works as a prefix-thing already anyway
01:40:49 <BeelsebobWork> and stops us reclaiming , into the symbols we can use to start infix data constructors
01:41:37 <BeelsebobWork> there's been a few times already I've wanted to use things like <,>
01:42:38 <BeelsebobWork> so yeh -- I'd rather think up either a different syntactic sugar for lists, or a different character to use for (,)
01:42:56 <Cale> Adding a rule about spacing around infix operators would really open up the available names a lot.
01:43:14 <BeelsebobWork> it would, but it would also make the syntax rather confusing in a lot of cases
01:43:17 <Cale> In fact, we could even just require infix operators to start with a symbol character.
01:43:31 <Cale> yes, it would
01:43:32 <BeelsebobWork> there's already the strange corner case that comments are -- as long as they aren't followed by an infix operator symbol
01:44:04 <Cale> One of the things that I really like about the particular set of syntax compromises that Haskell has made is that polynomials look exactly like they should.
01:44:29 <BeelsebobWork> heh
01:44:42 <Cale> You can write -x^2 + 3*x - 7
01:45:22 <BeelsebobWork> yeh, it's nice
01:45:33 <BeelsebobWork> although negation and minus are annoying
01:45:38 <pumpkin_> @hoogle maximumBy
01:45:39 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
01:45:39 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
01:46:47 * BeelsebobWork proposes using × for tuples
01:46:54 <BeelsebobWork> not that it'd make it hard to type them or anything ;)
01:47:01 <BeelsebobWork> pairs rather
01:51:14 <dcoutts> Lemmih: cabal-install does not depend on the LHC constructor, but true, if it's not built against Cabal-1.7 then it will not get the --lhc flag
01:51:38 <Lemmih> dcoutts: Yeah, I see that you fixed my ugly hack.
01:51:47 <dcoutts> right
01:51:50 <pumpkin_> dmwit: I'm trying to write a separation function that determines the best separation point for the binary 1d case
01:52:04 <dcoutts> Lemmih: but I forgot about the --lhc flag
01:53:42 <pumpkin_> separation ([1,2,3], [4,5]) should return 3.5, it seems to me
01:54:13 <pumpkin_> and separation ([1,2,3], [3,4,5]) should return 3
01:54:57 <quicksilver> BeelsebobWork: Using reactive has made me use applicatives much more deeply and thoroughly before
01:55:06 <quicksilver> BeelsebobWork: and I'm finding myself in expressivity holes, occasionally.
01:55:38 <BeelsebobWork> yeh, it's annoying when you discover something you're using really does need to be a monad :(
01:56:30 <quicksilver> BeelsebobWork: here's one I hit this morning: take "foo <$> x <*> y"
01:56:34 <quicksilver> BeelsebobWork: where x,y are Behaviours.
01:56:39 <BeelsebobWork> yep
01:56:45 <quicksilver> BeelsebobWork: and now, make 'y' a Maybe-version
01:56:55 <BeelsebobWork> uhhuh
01:56:59 <quicksilver> Behaviour (Maybe b) instead of Behaviour b
01:57:09 <quicksilver> and you want to fmap the foo over it in the obvious way
01:57:12 <quicksilver> you have to say
01:57:19 <quicksilver> fmap (foo <$> x <*>) y
01:57:21 <quicksilver> ugly!
01:57:44 <quicksilver> even worse if it's the 'x' not the 'y'
01:57:51 <BeelsebobWork> I think I'd use (foo <$> x <*>) <$> y
01:57:53 <BeelsebobWork> but yeh
01:57:56 <BeelsebobWork> it's not ideal
01:58:17 <quicksilver> if it's the x, you have to say
01:58:28 <quicksilver> fmap (\x' -> foo <$> x' <*> y) x
01:58:30 <quicksilver> or something
01:58:33 <BeelsebobWork> ick
01:58:45 <quicksilver> fmap f x where f x = foo <$> x <*> y
01:58:45 <BeelsebobWork> having said that -- that's only just getting as bad as what monads typically come out as
01:58:46 <quicksilver> perhaps
01:58:55 <BeelsebobWork> (without special syntax to tidy them up)
01:59:18 <quicksilver> simple uses of parsing monads are fine even without special sugar
01:59:21 <quicksilver> (c.f. Paulson)
01:59:31 <quicksilver> I think the problem is when you're using two totally different Applicatives
01:59:42 <quicksilver> and you spend time hopping around to take care of the nesting.
01:59:55 <BeelsebobWork> yeh, but simple uses of parsing applicatives is even nicer :P
02:00:08 <quicksilver> sure, I don't disagree.
02:00:54 <BeelsebobWork> so yeh... combining two monads == horrible
02:01:02 <BeelsebobWork> combining two applicatives == less horrible, but still horrible
02:01:25 <Cale> The composition of applicatives is applicative.
02:01:44 <quicksilver> Cale: right. But it's still fiddly when you're trying to fmap inside.
02:02:00 <quicksilver> Cale: Functors may compose, but with f `o` g you still have three choices
02:02:06 <quicksilver> fmap outside, fmap inside, fmap both
02:02:33 <Cale> Well, okay, yes.
02:02:46 <quicksilver> it's expressitivity in the sense of "comprehensible syntax" instead of "what you can actually express"
02:02:58 <Cale> It can be a bit hard to tell what's going on because fmap is very polymorphic.
02:03:13 <Cale> I suppose that's one place where category theory's notation is better.
02:03:34 <quicksilver> I almost wonder if a diagram is the right way to express this kind of composition.
02:03:46 <quicksilver> you have vertical, horizontal, and 2-cell composition
02:04:05 <Cale> mm... interchange law?
02:05:22 <Cale> Isn't the concern over the difference between f, Gf, and FGf ?
02:09:34 <quicksilver> Cale: and Ff
02:09:52 <quicksilver> Cale: (which discards your old inner functor, but it's still something you do, sometimes)
02:10:01 <Cale> yeah
02:12:10 <quicksilver> I'm not quite sure replacing textual notation with commutative diagrams is the right way to make haskell more accessible to ordinary programmers :)
02:12:26 <quicksilver> but, I'm definitely hitting a bit of a syntax wall at the moment.
02:14:26 <cjs> Hm. I've got a Haskell function being called by a C program, and the Haskell function forks off a thread that does some work. If the function is called a second time, with the thread already running, it ought not start another one. Thoughts on how I might do this?
02:14:46 <quicksilver> store threadID in an MVar
02:14:52 <quicksilver> if it's empty, it hasn't been started yet ;)
02:15:01 <quicksilver> or, better, store "something useful" in an MVar
02:15:04 <cjs> But how do I get the same MVar across calls?
02:15:13 <quicksilver> like the Chan you're doing to use to communicate with it.
02:15:54 <quicksilver> for an elegant solution to calling haskell from C you probably want a (haskell) context you can keep passing back to the C
02:16:02 <quicksilver> I've never used the FFI in that direction, not sure if that's easy.
02:16:06 <sjanssen> cjs: create the MVar, and pass it to each invocation of the function
02:16:09 <quicksilver> "...back to the haskell" I mean
02:16:53 <cjs> Actually, unless I write a C function that then calls the Haskell function, I don't have much control over this sort of thing. This is a call from Excel.
02:17:18 <cjs> I'm writing an XLL (Excel add-in DLL) in Haskell, and I'd like to use the minimum amount of C possible.
02:17:44 <sjanssen> the other option is an unsafePerformIO'd global
02:18:56 <cjs> Sounds about right. How does one do such a thing?
02:19:48 <cjs> (I'm reading Hughes' functional pearls paper on global vars right now, if it's in there.)
02:20:56 <sjanssen> lock :: MVar ()\nlock = unsafePerformIO newEmptyMVar\n{-# NOINLINE lock #-}
02:22:04 <cjs> Ah, so this is the "it only gets evaluated once, though there's no explicit guarantee of it" thing?
02:22:23 <sjanssen> yes
02:22:39 <sjanssen> NOINLINE is a fairly safe guard against that
02:22:52 <cjs> In GHC, I presume. Got it. Thanks.
02:23:25 <cjs> Isn't that safe, though. Maybe we should name that function, "possiblyUnsafePerformIO". :-)
02:25:44 <sjanssen> it is, at the very least, precarious
02:26:09 <sjanssen> for example, change the first line to "lock :: MVar a" and you've got a recipe for segfaults
02:27:17 <coldhak> that's a long /names list. hi guys
02:27:57 <sjanssen> @users
02:27:57 <lambdabot> Maximum users seen in #haskell: 561, currently: 513 (91.4%), active: 11 (2.1%)
02:28:08 <sjanssen> 513 is not so many :)
02:29:23 * sjanssen is tired of Coppin's whining about database libraries
02:29:32 <quicksilver> I posted a pretty bitchy reply.
02:29:42 <quicksilver> He seems to have learnt that talking shit is the way to get help.
02:29:47 <quicksilver> unfortunately that's often true.
02:29:52 <quicksilver> but not something I'd like to encourage.
02:30:43 <osfameron> I notice dons has recently been telling him to stfuawsc
02:31:37 <fasta> When is someone considered active in those statistics?
02:32:18 <sjanssen> new rule: when whining about broken packages, you must include a proper bug report
02:33:37 <fasta> Or just write a program that automatically reports the bug when the impossible has happened.
02:33:39 <vixey> hi coldhak
02:33:39 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
02:33:43 <vixey> @messages
02:33:44 <lambdabot> FunctorSalad said 10h 48m 36s ago: good to know :)
02:33:45 <int-e> fasta: when he or she has said something within the last 30 minutes ... hmm, and not left in the meantime, I guess.
02:34:06 <fasta> The program has all the information regarding the bug. Why should the user have to repeat it again?
02:34:25 <int-e> fasta: (see the Seen lambdabot plugin)
02:34:36 <sjanssen> fasta: even just a copy and paste job from the compiler output would be fine
02:40:58 <hackage> Uploaded to hackage: control-monad-omega 0.3
02:42:34 <vixey> :k Omega
02:42:36 <lambdabot> Not in scope: type constructor or class `Omega'
02:45:15 <Saizan> where's the FBackTrack oleg refers to?
02:45:38 <vixey> http://okmij.org/ftp/Computation/monads.html
02:45:44 <lambdabot> Title: Monads
02:45:53 <Saizan> thanks
02:47:40 <yitz> couldn't find the coppin/quicksilver thread about db libs. what's the subject?
02:49:18 <sjanssen> yitz: it spun out of a RWH topic
02:49:25 <sjanssen> it wasn't really a big deal
02:54:56 <Saizan> how do you usually setup a C devel environment on windows? especially w.r.t libraries. or does visual studio handles all that?
02:55:11 <yitz> sjanssen: ah, ok. thanks.
02:57:55 <fasta> Saizan: installing GHC gets you gcc.
02:59:32 <Saizan> fasta: yeah, but it's still a pain to compile anything that binds to C libraries, also any package that uses autoconf will complain that that gcc can't build binaries etc..
03:00:59 <Saizan> fasta: i don't really use windows very much, but i hope it's not such a pain as it looks
03:01:03 <fasta> Saizan: I am also not that familiar with the C development part of Windows.
03:01:14 <fasta> Saizan: I think MingW can help.
03:01:39 <fasta> Saizan: but it seems nobody supports Windows.
03:01:53 <Saizan> yeah, it does help, too bad there's no repository of libraries
03:02:17 <fasta> Saizan: with cygwin you can get tons of stuff at once.
03:03:01 <alexott> if you want to have native windows executables, etc., then it's better to use mingw
03:03:08 <fasta> Saizan: and you can use the same system to get a partial list, but if you don't get all, you might miss something.
03:03:46 <fasta> Saizan: also the Cygwin installer has atleast two bugs. I thought Redhat only made quality stuff, but they cannot even write a decent installer.
03:05:54 <fasta> And they didn't think of making the installer parallel, so it takes quite a time to install.
03:06:00 <alexott> and all mingw utils understands windows style filenames
03:06:07 <kalven> *rant*
03:06:17 <Saizan> i've had bad experiences with cygwin in the past :) but i was an unix newbie.. still installing half a linux distro to do any developement on windows sounds wrong
03:07:00 <PeakerWork> Saizan: Windows is probably _more_ a pain than it looks ;-)
03:07:15 <fasta> Saizan: there are just not that many people doing C development on Windows, I think.
03:07:32 <PeakerWork> Saizan: NT supposedly has its own POSIX compat. layer, though I've never seen it :-)
03:07:54 <PeakerWork> fasta: those that use .NET suffer too ;-)
03:08:10 <alexott> fasta: i see a lot of people at work, that use windows to develop software that is executed on linux
03:08:35 <fasta> alexott: ok, then you can ask them for Saizan :)
03:08:53 <fasta> alexott: are they doing _C_ development?
03:09:02 <alexott> fasta: yes
03:09:03 <PeakerWork> though VS.NET is said to be nicer than emacs/vim, at least when you have a super-powerful machine
03:09:37 <fasta> Emacs has no good tool support, VS.NET has a Windows GUI. Pick one.
03:09:51 <Twey> I disagree.  It's like Notepad with a code browser and Intellisense.
03:10:17 <Martijn> Hallo
03:10:49 <alexott> Twey: yes ;-)
03:11:03 <yaxu> good localise(morning)
03:11:18 <yaxu> er
03:11:19 <Twey> Not that I disapprove of Intellisense, wonderful idea, but does not a good editor make
03:11:24 <yaxu> good (localise morning)
03:11:36 <yaxu> good $ localise morning
03:11:36 <yaxu> maybe
03:12:12 <alexott> emacs + semantic works for me for most of my C++ code
03:12:53 <PeakerWork> Twey: it has incremental search and macros.  Its missing out on some of the other things though :-)
03:13:24 <Twey> interpolate userData "Good $period, welcome to $place!  How may we provide $required_assistance?"
03:13:46 <Zao> Twey: Needs more localized messages.
03:13:56 <Twey> Psht.
03:14:47 <Twey> interpolate userData "$greeting{$period}, $hospitality{$place}!  $offer{$required_assistance}"
03:15:08 <Twey> Happy now?  :-P
03:15:29 <Zao> Twey: Still not taking into consideration locales where the fragment order is different.
03:16:03 <jkff> What about taking into consideration locales where people have not invented writing at all?
03:17:00 <sjanssen>  ! is also problematic
03:17:01 <ben> interpolate userData "$prefered_welcome"
03:17:43 <vixey> AI is hard ...
03:18:45 <Saizan> is there any library which implements Tree fusion?
03:19:52 <Saizan> even if with data Tree a = Node a [Tree a] list fusion would probably eliminate most of the garbage
03:20:30 <vixey> thats a great type!a
03:20:34 <Twey> Zao: Not an issue — those are independent clauses
03:20:48 <vixey> I use :-->: instead of Node for the constructor
03:21:24 <Martijn> You might as well leave the last : out of that name
03:21:37 <vixey> not sure what the fusion is
03:23:36 <sjanssen> Saizan: it should be easy to build a fold/build fusion library for Tree
03:25:18 <Saizan> ?ty GHC.Exts.build
03:25:20 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
03:26:38 <vixey> build o = o :-->: map build (f o) -- maybe ?
03:27:17 <sjanssen> tbuild :: forall a. (forall b. (a -> [b] -> b) -> b) -> Tree a
03:27:44 <Saizan> missed a "-> b"
03:27:53 <Saizan> ah, no
03:28:07 <Saizan> we don't have a Leaf
03:28:15 <sjanssen> you'd probably want to turn the [b] into the build variant as well
03:28:17 <vixey> Mine was (a -> [a]) -> a -> Graph a
03:28:20 <Saizan> yeah
03:28:53 <vixey> how does that build work anyway? It doesn't know when to stop
03:29:06 <vixey> > GHC.Exts.build (+) 0 1
03:29:08 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b -> b
03:29:19 <sjanssen> forall a. (forall b. (a -> ((a -> b -> b) -> b -> b) -> b)) -> Tree a
03:30:04 <Saizan> the elements of the list are trees again though
03:30:07 <Saizan> not 'a'
03:30:22 <sjanssen> @type \xs -> GHC.Exts.build (\c n -> foldr xs)
03:30:23 <lambdabot>     Couldn't match expected type `b1'
03:30:23 <lambdabot>            against inferred type `b -> [a1] -> b'
03:30:23 <lambdabot>       `b1' is a rigid type variable bound by
03:30:39 <sjanssen> mm, yes
03:30:45 <sjanssen> there should be another type variable there
03:41:36 <mornfall> Hm, anyone knows where DrIFT went from hackage?
03:46:58 <int-e> mornfall: http://www.haskell.org/pipermail/haskell-cafe/2008-November/051270.html
03:47:00 <lambdabot> Title: [Haskell-cafe] Compilers, http://tinyurl.com/6cypo3
03:49:49 <int-e> @where drift
03:49:49 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
04:00:35 <osfameron> josette++ # I can has Real World Haskell!
04:01:52 <osfameron> (I was expecting it on Friday, which I guess would still have been faster than Amazon UK, but here already!)
04:06:21 <vixey> are there any data types that don't have a fold?/
04:07:32 <Cale> vixey: Function types?
04:08:37 <tomh> osfameron: interesting book?
04:10:02 <osfameron> tomh: I hope so :-)  only just got it
04:15:23 <vixey> trying to typecheck agda code is worse than a fork bomb
04:16:05 * Martijn comforts vixey.
04:16:06 <quicksilver> Interesting.
04:16:13 <quicksilver> I just read the rant about jhc and drift.
04:16:24 <Martijn> vixey: How long have you been working with Agda now?
04:16:25 <quicksilver> I think john meacham's points deserve answering in a way they have not been.
04:16:40 <mornfall> int-e: Interesting, and what would that mean for me as a user?
04:17:01 <vixey> I started the thing, went and made a cup of tea and came back .. and it's still I had to kill it
04:17:14 <vixey> and it was still running*
04:18:09 <int-e> mornfall: you have to fetch the tool from the author's website (link above) and compile it yourself, I believe, unless you're the lucky user of a distribution that packages the tool for you.
04:19:24 <mornfall> Hm, a point not to use drift. (Well, I have a package, but it's usually better to just cabal install things...)
04:19:46 <cjs> Anybody here in Japan on the 12th? I'm having a bonenkai....
04:20:58 <dcoutts> mornfall: you could tell the author this. He just had it removed from hackage.
04:21:24 <mornfall> dcoutts: Would that be malcolmw?
04:21:30 <dcoutts> mornfall: because it was badly packaged by someone else he says. But he might put it back on if it's packaged properly.
04:21:54 <dcoutts> mornfall: no John Meacham
04:21:57 <mornfall> Ah.
04:22:54 <sjanssen> @tell Saizan fold/build fusion for Data.Tree http://hpaste.org/12607
04:22:54 <lambdabot> Consider it noted.
04:23:17 <sjanssen> Haskell is so awesome
04:23:52 <malcolmw> hmm, yes, the big third-party packager problem we had a while back
04:24:08 <vixey> that's pretty cool but I totally don't understand this build thing
04:24:52 <sjanssen> build g = g (:) [] -- build for lists
04:24:52 <malcolmw> I wasn't impressed to get a load of patches that deleted random bits of code from my project, just so it would pass -Wall and be Cabalised.
04:25:47 <mornfall> malcolmw: Well, cabal does not require -Wall, does it?
04:26:12 <mornfall> Well, having things cabalised lowers the entry barrier considerably.
04:26:29 <sjanssen> foldr k z (build f) == f k z -- does this help, vixey?
04:26:36 <malcolmw> mornfall: no, that I know of, but this third person required it, whist apparently not being bothered if the result actually worked correctly or not.
04:26:49 <mornfall> malcolmw: Yeah, that is indeed a problem.
04:27:01 <vixey> I don't really get it but I think that's amazing
04:27:31 <dcoutts> mornfall, malcolmw: though not a huge problem. You just reject the patches and ask for better ones.
04:27:46 <sjanssen> @google short-cut deforestation Haskell
04:27:48 <lambdabot> No Result Found.
04:27:50 <vixey> you know what it reminds me of (PDP^-1)^n = PD^nP^-1 from algebra
04:28:07 <vixey> when you conjugate a group or a diagonalize or whathaveyou
04:28:26 <malcolmw> dcoutts: well, I received about 40 patches in a bundle.  I applied and pushed about 28 of them, before suddenly realising what was going on.  By then it was a bit too late.
04:28:41 <vixey> and this works for any ADT which has a fold?
04:28:45 <sjanssen> vixey: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.646 is the paper you need
04:28:46 <lambdabot> Title: A short cut to deforestation - CiteSeerX
04:28:53 <vixey> ok cool
04:29:55 <dcoutts> malcolmw: ok but it's a tragedy of riches, getting bad patches from enthusiastic people is not something we can do a lot about, we just have to review and give feedback and ask for higher attention to quality.
04:30:58 <malcolmw> dcoutts: eventually, I rejected the patches, asked for better quality ones, and the third party basically said "no" and moved on - never heard from him since.
04:31:08 <vixey> it says "We want to have our cake and eat it too" :)) I think that can be the motto of haskell
04:31:25 <dcoutts> malcolmw: feh, that's the way it goes. So long as we're polite I don't think we can do better.
04:31:32 <Twey> λcake.  Mmm.
04:31:37 <osfameron> @faq can you eat your cake and have it too?
04:31:37 <lambdabot> The answer is: Yes! Haskell can do that.
04:31:58 <malcolmw> dcoutts: I wouldn't call it a tragedy of riches exactly - more of a tragedy of too much chaff, not enough substance
04:33:35 <quicksilver> dcoutts: is there a stock answer to "The world has enough half-assed make clones already, PLEASE don't make another one", present on the wiki or somewhere we can point to it?
04:33:46 <malcolmw> dcoutts: but of course I'd prefer to have been able to take advantage of that enthusiasm by directing it more appropriately
04:34:03 <dcoutts> malcolmw: aye
04:34:26 <dcoutts> quicksilver: heh heh, not at the moment. Is that a question you have to answer frequently?
04:34:46 <sjanssen> quicksilver: you need a wiki page to say "We're planning to use our *whole* asses"?
04:34:57 <Twey> Hahaha
04:35:14 <Axman6> @hoogle on
04:35:14 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:35:15 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
04:35:15 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
04:35:15 <quicksilver> flippancy aside.
04:35:29 <quicksilver> It is the essential content of JohnMeacham's point, and others in that thread.
04:35:35 <vixey> > GHC.Exts.build foldr "foo"
04:35:36 <lambdabot>       Occurs check: cannot construct the infinite type: b = [a] -> b
04:35:38 <quicksilver> and it's a fair question which deserves a fair answer.
04:35:40 <Axman6> @src on
04:35:40 <lambdabot> (*) `on` f = \x y -> f x * f y
04:35:43 <dcoutts> quicksilver: it's true of course, the world does have enough half-assed make clones. There's not nearly enough whole-assed ones as sjanssen so eloquently puts it.
04:36:24 <quicksilver> I haven't read the whole thread yet but I haven't come to anything which appears to be a fair answer.
04:36:27 <dcoutts> quicksilver: that cabal should be using a make-style dependency framework?
04:36:28 * sjanssen is scared that GHC.Exts.build gets through
04:36:45 <quicksilver> dcoutts: Not that specifically. More "Why cabal at all?"
04:36:59 <Axman6> sjanssen: i was looking at its type, how's it work?
04:37:03 <quicksilver> dcoutts: "Convince me that hackage benefits from cabal, rather than standardised use of make + friends"
04:37:11 <sjanssen> > GHC.Exts.I# `seq` ()
04:37:12 <lambdabot>   /tmp/3331654403851671868:70:32:
04:37:12 <lambdabot>      Not in scope: data constructor `GHC.Ex...
04:37:15 <Axman6> /what;'s it do?
04:37:16 <sjanssen> ah, good
04:37:20 <dcoutts> quicksilver: ah, well how long is each project's makefile? How much domain specific knowledge is in there?
04:37:21 <quicksilver> (actually not specifically convince *me*, but convince doubters)
04:37:26 <sjanssen> Axman6: see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.646
04:37:27 <lambdabot> Title: A short cut to deforestation - CiteSeerX
04:37:53 <dcoutts> quicksilver: make is a language for writing build systems in. But not everyone wants to write a build system for every little project.
04:38:23 <vixey> > GHC.Exts.build (\c n -> n)
04:38:25 <lambdabot>   /tmp/6972796670219370464:70:32: Not in scope: `GHC.Exts.build'
04:38:47 <quicksilver> dcoutts: I'm not seeking an answer here and now (although I'm interested). I'm seeking a standard answer we can point people to who ask.
04:38:55 <FunctorSalad> doesn't one of the CC licenses require that you clearly label derivative works as not being from the original author?
04:39:16 <sjanssen> vixey: if that worked, it'd be the same as []
04:39:17 <FunctorSalad> ( malcolmw )
04:40:17 <vixey> build (\(*) o -> 1 * (2 * (3 * (4 * o))))
04:40:18 <vixey> [1,2,3,4]
04:40:26 <FunctorSalad> I mean, if the problem is that someone uploads a crippled version of your work with you as the author name
04:40:29 <dcoutts> quicksilver: the other answer is that you can use make as the build system with cabal for the meta-data.
04:40:30 <int-e> dcoutts: but that's not a good argument for larger projects that already have that custom build system.
04:40:35 <dcoutts> int-e: indeed
04:40:46 <Twey> @index build
04:40:46 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.Exts
04:40:48 <Axman6> vixey: *brain pop*
04:40:55 <Twey> :t GHC.Exts.build
04:40:56 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:41:21 <quicksilver> dcoutts: that would appear to be a fact JohnMeacham didn't appreciate, for example. (That you can still use make for building, and just use cabal for metadata)
04:41:30 <dcoutts> int-e: and generally the arguments for bigger projects are weaker
04:41:48 <quicksilver> dcoutts: and the fact that he failed to appreciate suggests that some communication failure has occurred.
04:41:49 <dcoutts> quicksilver: it's not widely known because only one project actually does it
04:41:51 <vixey> @free forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:41:51 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
04:41:55 <eu-prleu-peupeu> :)
04:41:56 <vixey> @free build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:41:56 <lambdabot> (forall g h k. (forall z. g . h z = k (f z) . g)               =>                g . x h = y k . g) => $map f (build x) = build y
04:42:10 <quicksilver> dcoutts: then consider this an appeal to make it more widely known.
04:42:17 <quicksilver> spread information! fight FUD!
04:42:17 <vixey> @free build :: forall a. (forall b. (a -> b -> b) -> b -> b)
04:42:18 <lambdabot> (forall x. g . h x = k (f x) . g) => g . build h = build k . g
04:42:35 <taari> l/join -freenode #aircrack-ng
04:42:39 <taari> args
04:42:41 <dcoutts> quicksilver: I'd rather not :-) It doesn't work very well in practise, mostly because nobody uses it.
04:42:47 <SamB_XP> I thought FUD was supposed to be intentional
04:42:54 <vixey> This is absolutely amazing
04:43:21 <dcoutts> quicksilver: if people really wanted it to work then we could spend more time on it, but I'd rather spend my time elsewhere.
04:43:22 <Axman6> vixey: i'm glad you understand it
04:43:41 <dcoutts> quicksilver: like making a full-assed make-style dep framework
04:43:46 <vixey> Axman6, are you reading this same paper?
04:44:12 <Axman6> i will, i was in the middle of something else and was taking an irc break
04:44:15 <Axman6> i'll read on
04:45:10 <quicksilver> dcoutts: Well, the problem I'm trying to solve is that LHC/JHC thread, and the causes of it.
04:45:27 <dcoutts> quicksilver: I don't see that there is any problem
04:45:32 <quicksilver> dcoutts: it has caused some pretty negative comments by a person who I respect, so I'm inclined to consider his comments carefully.
04:45:44 <quicksilver> At the very least I think the comments need a fair rebuffal.
04:45:44 <dcoutts> quicksilver: he's got many good points
04:46:24 <SamB_XP> "rebuffal"?
04:46:25 <dcoutts> quicksilver: he's not making generalisations saying it's no good for all projects, just that it doesn't add anything for him personally for his project
04:49:59 <Axman6> > foldr (:) [] [1,2,3]
04:50:01 <lambdabot>   [1,2,3]
04:50:03 <quicksilver> dcoutts: but you'd rather jhc was cabal-installable, wouldn't you? You said as much, I think.
04:50:06 <Axman6> > foldl (:) [] [1,2,3]
04:50:07 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
04:50:07 <lambdabot>        Expect...
04:50:16 <dcoutts> quicksilver: sure
04:50:19 <vixey> > foldl (flip (:)) [] (reverse [1,2,3])
04:50:21 <lambdabot>   [1,2,3]
04:50:27 <dcoutts> quicksilver: but I'm not the one maintaining it
04:50:29 <quicksilver> dcoutts: so surely you'd like to make him aware of the path that makes it cabal-installable without taking away the features he wants.
04:50:42 <dcoutts> quicksilver: but it does take away some features he wants
04:50:42 <Axman6> vixey: yeah that's what i was heading for
04:50:48 <Axman6> :t flip (:)
04:50:49 <lambdabot> forall a. [a] -> a -> [a]
04:51:02 <dcoutts> quicksilver: of course I'd like to make Cabal better to the point where the decision is easy and obvious.
04:51:10 <Axman6> > flip (:) [1,2,3] 5
04:51:11 <lambdabot>   [5,1,2,3]
04:51:12 <quicksilver> dcoutts: I thought it wouldn't, if he used the cabal + make approach?
04:51:20 <SamB_XP> dcoutts: not going to happen ;-P
04:51:26 <vixey> @let snoc = flip (:)
04:51:27 <lambdabot>  Defined.
04:51:29 <dcoutts> SamB_XP: I don't see why not
04:51:40 <SamB_XP> well, at least, not unless you improve the cabal + make thing and advertise it better
04:51:45 <dcoutts> quicksilver: well, it's still a trade-off
04:51:55 <dcoutts> SamB_XP: no, we can do better than make
04:52:00 <quicksilver> dcoutts: for example, I don't know how to answer the following question:
04:52:16 <SamB_XP> dcoutts: he uses loads of scripts in his build process ...
04:52:36 <dcoutts> SamB_XP: I bet that works well on windows
04:52:44 <SamB_XP> dcoutts: perl scripts, they are
04:52:51 <quicksilver> Is cabal a way of storing and acting on metadata like dependencies *between* packages? Or is it a make replacement which manages dependencies between files within a package?
04:52:51 <dcoutts> SamB_XP: but even so, it's not a major problem
04:53:08 <vegai> hmm, HXT doesn't build with cabal-install
04:53:15 <vegai> but builds manually just fine
04:53:17 <Axman6> vixey: the stuff in this paper, is it used in ghc?
04:53:27 <sjanssen> Axman6: yes
04:53:34 <dcoutts> quicksilver: it's the first part and it has an optional implementation of the second part for packages that don't need complex build systems
04:53:35 <Axman6> excelent
04:53:36 <Axman6> ll*
04:53:47 <SamB_XP> sjanssen: what ?
04:53:52 <SamB_XP> GHC uses free theorems ?
04:53:57 <sjanssen> Axman6: foldr/build
04:54:03 <sjanssen> erm, I meant SamB_XP there
04:54:07 <SamB_XP> oh oh
04:54:09 <Axman6> how does build work?
04:54:20 <quicksilver> dcoutts: (apologies if I sound adversarial, I'm just being direct) Why is it both? Are they not completely distinct problems best handles separately?
04:54:26 <dcoutts> quicksilver: however the managing dependencies between files within a package is pretty weak
04:54:30 <SamB_XP> Axman6: doesn't the paper say ?
04:54:45 <Axman6> it probably does, ot up to there yet.. i'll keep going
04:55:08 <dcoutts> quicksilver: once you've specified that much meta-data then it's reasonably straightforward to have a generic build system that uses it to build simple packages.
04:55:09 <vixey> Axman6, look:  build (\(*) o -> 1 * (2 * (3 * (4 * o))))  ~~> [1,2,3,4]
04:55:37 <Axman6> yeah i really have no idea where that result is coming from
04:55:44 <vixey> that's what build does
04:55:51 <dcoutts> quicksilver: and the small package argument says you need to make it simple for small packages, which means providing a default build system.
04:56:06 <vixey> > let build kit = kit (:) [] in (\(*) o -> 1 * (2 * (3 * (4 * o))))
04:56:08 <lambdabot>       Overlapping instances for Show ((t -> t1 -> t1) -> t1 -> t1)
04:56:08 <lambdabot>        ari...
04:56:11 <vixey> huh..
04:56:11 <SamB_XP> @type build
04:56:12 <lambdabot> Not in scope: `build'
04:56:17 <SamB_XP> arg.
04:56:25 <sjanssen> @type GHC.Exts.build
04:56:26 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:56:49 <vixey> > let build instructions = instructions (:) [] in build (\(*) o -> 1 * (2 * (3 * (4 * o))))
04:56:51 <lambdabot>   [1,2,3,4]
04:56:57 <quicksilver> dcoutts: digesting that and reading the rest of the thread
04:57:23 <SamB_XP> the function that build takes is a polymorphic function that COULD build a list, if passed (:) and [], but could also perform a foldr on that list, if passed the arguments for foldr
04:57:40 <Axman6> vixey: ok, * is not multiplication?
04:57:46 <SamB_XP> but WITHOUT building it
04:57:49 <dcoutts> quicksilver: so that's the theory. In practise we've not use many other implementations of the configure or build parts because nobody has demanded it.
04:57:50 <SamB_XP> Axman6: indeed
04:57:51 <vixey> * is a star
04:58:01 <Axman6> well now it makes more sense
04:58:07 <SamB_XP> ;-)
04:58:25 <vixey> > let build instructions = instructions (:) [] in build foldr "foo"
04:58:27 <lambdabot>   "foo"
04:58:30 <dcoutts> quicksilver: but if there was the demand then that's the direction we could move in. However I'd rather spend my time making the "Simple" build system better.
04:58:48 <vixey> dcoutts, what about ghc --make?
04:58:58 <dcoutts> vixey: replacing that
04:59:05 <dcoutts> that's the longer term plan
04:59:07 <vixey> why not improve it instead?
04:59:09 <SamB_XP> Axman6: the special thing about build is that it isn't allowed in Haskell 98, because it demands that the function it is passed be POLYMORPHIC
04:59:15 <Axman6> is there a standard function that achieves the same as (id $!)?
04:59:28 <SamB_XP> Axman6: id
04:59:29 <sjanssen> Axman6: id
04:59:32 <dcoutts> vixey: because it is limited in scope, it can only ever know about .hs files
04:59:39 <vixey> it seems like if --make did everything, there'd be one less program that can break
04:59:41 <quicksilver> Axman6: indeed, because that acheives nothing ;)
05:00:02 <quicksilver> Axman6: that's one of the reasons I don't much like $!
05:00:02 <Axman6> well, it makes the argument strict no?
05:00:10 <dcoutts> vixey: there's pre-processors and when you start looking at it, everything is a dependency, configuration and .cabal files too
05:00:12 <SamB_XP> Axman6: id is already strict in it's argument ;-P
05:00:20 <Axman6> really? huh
05:00:33 <SamB_XP> well, it can't exactly be lazy in it
05:00:41 <dcoutts> vixey: we cannot and should not extend ghc --make to do that. It's the wrong place to put the functionality.
05:00:51 <vixey> ok
05:00:54 <quicksilver> vixey: you don't want ghc --make to know how to generate pdf files from dot files
05:01:09 <quicksilver> vixey: but, that's a reasonable thing to want in a build system which is autogenerating hardcopy documentation.
05:01:15 <vixey> I just wanted ghc --make to build any haskell program
05:01:16 <SamB_XP> since id returns the argument ... when (id x) is reduced to WHNF, x must be too ;-)
05:01:19 <solrize_> > case id (1/0) of _ -> "whee"
05:01:20 <lambdabot>   "whee"
05:01:37 <quicksilver> solrize_: case of _ does not force in haskell
05:01:42 <vixey> it seems like compiling a program and making docs are separate things to me
05:01:43 <SamB_XP> > case id $! (1/0) of _ -> "whee"
05:01:44 <lambdabot>   "whee"
05:01:45 <quicksilver> solrize_: (unlike in GHC core, where it does)
05:01:51 <vixey> I don't know maybe that is a narrow viewpoint
05:01:57 <SamB_XP> > case id (1/0) of !_ -> "whee"
05:01:58 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
05:02:04 <SamB_XP> awwwwww
05:02:07 <sjanssen> vixey: I think in the long term, we'll use the "cabal" program to build everything
05:02:23 <SamB_XP> @tell gwern I wants bang patterns in ">"
05:02:23 <lambdabot> Consider it noted.
05:02:41 <SamB_XP> @tell Cale I wants bang patterns in ">"
05:02:41 <lambdabot> Consider it noted.
05:02:44 <vixey> sjanssen, that worries me because of the number of times cabal has broken and I have not been able to fix it. If cabal takes over it will surely be more complicated and even less chance of me fixing it
05:02:45 <dcoutts> vixey: do you remember hmake ?
05:02:51 <vixey> dcoutts, no
05:03:04 <SamB_XP> hmake was some silly thing
05:03:05 <dcoutts> vixey: well it was an external prog, that did the job of ghc --make
05:03:11 <SamB_XP> it didn't seem to do much of use
05:03:12 <sjanssen> vixey: you think you'll have better chances at fixing GHC?
05:03:15 <dcoutts> plus a couple extras
05:03:20 <dcoutts> like some pre-processors
05:03:22 <vixey> sjanssen, yes
05:03:35 <dcoutts> vixey: heh, you're very optimistic :-)
05:04:00 <SamB_XP> perhaps because no decent Haskell implementations besides GHC and hugs exists ?
05:04:13 <SamB_XP> (hugs is still the fastest loader around, isn't it?)
05:04:31 <earthy> hbc, nhc, jhc?
05:04:41 <dcoutts> yhc, ehc
05:04:49 <SamB_XP> jhc isn't decent unless it's switched repos
05:04:53 <SamB_XP> is hbc maintained ?
05:04:57 <dcoutts> SamB_XP: no
05:05:06 <SamB_XP> nhc and yhc are really icky inside
05:05:06 <sjanssen> earthy: none of those are very useful
05:05:06 <vixey> if I have a bootstrapped GHC that complied itsself using --make then I am sure --make will work already
05:05:17 <SamB_XP> (they have much of the same inside ;-)
05:05:25 <earthy> sjanssen: there is a difference between useful and decent
05:05:37 <dcoutts> vixey: that does not tell you anything about rebuilding, which is what --make is partly for
05:05:45 <SamB_XP> what is ehc ?
05:05:55 <Martijn> the enterprise haskell compiler ;-)
05:05:55 <vixey> SamB_XP: enother haskell compiler
05:06:04 <dcoutts> the Essential Haskell Compiler
05:06:08 <sjanssen> vixey: that only says GHC is capable of compiling GHC, it says nothing about your project
05:06:10 <vixey> hi Martijn
05:06:13 <SamB_XP> vixey: so ... an implementation by a person who can't even spell ?
05:06:16 <Martijn> Hi :-)
05:06:40 * earthy should ask if EHC does I/O already
05:06:58 <Martijn> We students here at UU (where EHC is being developed) like to joke about the E in EHC meaning enterprise
05:07:11 <SamB_XP> Martijn: it's that bad ???
05:07:17 <earthy> samb: nah
05:07:25 <vixey> I think I came across EHC when looking up attribute grammars
05:07:28 <solrize_> what's the point of cabal instead of a possibly haskellized version of apt-get and/or ant ?
05:07:31 <earthy> it's just accompanied by a rather 'interesting' build system.
05:07:49 <earthy> and I use interesting in the cursing sense of 'may you live in interesting times'
05:07:54 <vixey> and.. nearly the whole thing is programmed in them
05:08:08 <SamB_XP> vixey: okay
05:08:12 <SamB_XP> that doesn't sound enterprisey
05:08:25 <dcoutts> solrize_: the point is it makes it easier to build and distribute haskell packages
05:08:28 <SamB_XP> that sounds more experimental than Highly Experimental
05:08:45 <earthy> samb: that's where you start nailing it exactly
05:08:57 <earthy> (it's a PhD project gone wilde)
05:08:59 <dcoutts> solrize_: the amount of information in a .cabal file is considerably less than the info you need to make an ant build system or an rpm
05:09:02 <vixey> hehe
05:09:02 <earthy> (wild)
05:09:16 <SamB_XP> (which is a Winamp plugin to play PSFs -- playstation music programs)
05:09:33 <Martijn> dcoutts: but you could generate code for other build systems from a .cabal file
05:09:55 <dcoutts> Martijn: indeed, that is part of the point. Especially for native packages.
05:10:04 <SamB_XP> hmm ?
05:10:20 <dcoutts> Martijn: for other build systems it's possible I guess, nobody has bothered.
05:10:21 <SamB_XP> what other build systems would you be meaning ?
05:10:32 <dcoutts> make I guess?
05:10:37 <earthy> ant?
05:10:39 <dcoutts> that's what ghc is doing actually
05:10:43 <SamB_XP> hmm ?
05:10:43 <earthy> ruler?
05:11:59 <SamB> huh
05:12:21 <SamB> I can vote for google results now ... in non-anonymous manner ?
05:12:55 <solrize_> i feel sort of like john meacham.  there's a similar situation (actually several) with python packaging/distrib tools and i tend to ignore them and and use unix tools
05:13:10 <Martijn> SamB: no, you can only do that if you're logged in and it's only visible to you.
05:13:30 <SamB> Martijn: that's not what this message I just got said ...
05:13:39 <SamB> or seemed to say
05:13:45 <Martijn> SamB: I might well be mistaken
05:13:56 <SamB> but I can't seem to see who else voted for JHC's page ...
05:15:04 <Martijn> :t (<*>)
05:15:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:15:59 <solrize_> that something like liftm2?
05:16:21 <solrize_> no oops, func is already lifted
05:17:06 <yaru1022> hi
05:17:16 <Martijn> @pl \x pxs -> (:) <$> symbol x <*> pxs
05:17:17 <lambdabot> (((:) <$>) .) . (<*>) . symbol
05:17:23 <Beelsebob> solrize_: it's part of liftA2
05:17:27 <yaru1022> is there an easy way to remove previous version of haskell and its packages?
05:17:31 <Saizan> sjanssen: thanks
05:17:32 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
05:17:45 <Beelsebob> > (+) <$> [1,2,3] <*> [4,5,6]
05:17:46 <lambdabot>   [5,6,7,6,7,8,7,8,9]
05:17:49 * Martijn sniffles
05:17:58 <Beelsebob> > [1,2,3] <^(+)^> [4,5,6]
05:18:00 <lambdabot>   [5,6,7,6,7,8,7,8,9]
05:18:13 <Botje> is it happy fun time again?
05:18:21 <Beelsebob> if you want it to be
05:18:33 <Botje> i christen that the pig+snout operator :]
05:18:52 <Clockwork> http://hpaste.org/12609 Hey, I cannot get it running, as the compiler calls "Baum a" an illegaly type, is there something wrong in my data definition 1st line?
05:19:11 <Beelsebob> solrize_: <*> takes an applicative of functions and an applicative of arguments and produces all combinations of them
05:19:20 <Beelsebob> <$> conveniently produces the list of functions for you
05:20:13 <sclv> Clockwork -- you have no free type in the data definitions.
05:20:32 <Clockwork> free type?
05:21:12 <sclv> you need something like: data Baum a = Nil | Knoten a (Baum a) (Baum a)
05:21:31 <Clockwork> ah...
05:22:00 <Martijn> Clockwork: what is the compiler's error message?
05:22:11 <Martijn> ah, n/m
05:22:15 <Beelsebob> sclv: what you did was say "Baum" is a type
05:22:22 <Beelsebob> not "Baum with an argument" is a type
05:22:22 <Clockwork> "Illegal type "Baum a" in constructor for application
05:22:33 <Botje> Clockwork: you defined Baum, not Baum a
05:22:33 <Beelsebob> so you can't apply Baum to an argument
05:22:48 <Clockwork> yea
05:22:48 <vixey> http://www-sop.inria.fr/marelle/Laurent.Thery/Sudoku/Sudoku.html cool!!
05:22:49 <Botje> you probably want Data Baum a = Nil | Knoten a Baum Baum
05:23:00 <lambdabot> Title: Sudoku
05:23:02 <Beelsebob> Botje: not forgetting to make the Baums (Baum a)s
05:23:04 <Clockwork> so as sclv said
05:23:29 <Botje> oh yeah
05:24:03 <Clockwork> seems to work now, thx :)
05:24:23 <Beelsebob> your einfuegenWert  looks odd too
05:25:01 <Beelsebob> interesting... that ties together german and dutch some more for me
05:25:08 <Beelsebob> I'd forgotten Trees were Baums
05:25:13 <Beelsebob> (or Booms)
05:25:15 <Clockwork> I hate german viarables :P
05:25:53 <Clockwork> I just copied the code from my lecture scripts..
05:25:56 <Beelsebob> hehe
05:26:00 <ben> It is Bäume, not Baums >:C
05:26:04 <Twey> Heh
05:26:06 <luite_> a Boom would be a dutch Baum
05:26:11 <Badger> boy-meh
05:26:12 <Clockwork> :D
05:26:15 <Beelsebob> luite_: yes
05:26:19 <Badger> hmm
05:26:22 <Badger> boy-muh  even
05:26:26 <Beelsebob> ben: it's also Boomen
05:26:28 <Beelsebob> not Booms
05:26:33 <ziman> > let (∘∘) = (+) in [1, 2, 3] <^(∘∘)^> [4, 5, 6]
05:26:33 <Clockwork> boobs
05:26:34 <lambdabot>   [5,6,7,6,7,8,7,8,9]
05:26:47 <Beelsebob> ziman: :)
05:26:53 <ziman> ;)
05:26:55 <FunctorSalad> Clockwork: what did the poor variables do to you? :(
05:26:57 <Martijn> the plural of boom is bomen
05:27:12 <luite_> boomen may have been acceptable a century ago
05:27:21 <Beelsebob> > let oo = (+) in [1,2,3] <^(oo)^> [4,5,6] -- just for ziman
05:27:23 <Twey> 木
05:27:23 <lambdabot>   [5,6,7,6,7,8,7,8,9]
05:27:31 <Twey> Des arboires
05:27:41 <Beelsebob> Martijn: damn your language and it's crazy vowel manipulation!
05:27:44 <Beelsebob> it confounds me at every step!
05:27:47 <vixey> @let oink <^(oo)^>
05:27:48 <lambdabot>   Parse error
05:27:49 <Twey> Hahaha
05:27:55 <vixey> @remember oink <^(oo)^>
05:27:55 <lambdabot> I will never forget.
05:28:00 <Beelsebob> lol
05:28:02 <Twey> Hehe
05:28:15 <vixey> @remember ook (:[])
05:28:15 <lambdabot> Nice!
05:28:33 <FunctorSalad> @type (<^)
05:28:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
05:28:42 <Beelsebob> surely being a robot monkey he would say 001< ?
05:28:59 <vixey> ahh.. . should have thought
05:29:29 <Beelsebob> also... also
05:29:38 <Beelsebob> we need #haskell.nl so that I can proctice
05:29:40 <Beelsebob> practise too
05:29:55 <Beelsebob> wait no, practice was right >.<
05:30:19 <ziman> @type (^>)
05:30:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:30:26 <byorgey> but not proctice =)
05:30:34 <Beelsebob> oh, no, not that
05:31:21 <Beelsebob> > let (>.<) = (+) in [1,2,3] <^(>.<)^> [4,5,6]
05:31:22 <lambdabot>   [5,6,7,6,7,8,7,8,9]
05:31:32 <Beelsebob> everything looks better with ears :P
05:31:34 <opqdonut> :D
05:31:39 <lilac> @type \o-> look at my muscles
05:31:40 <lambdabot> forall t nice muscles. t -> nice -> muscles
05:31:52 <Beelsebob> lilac: rofl
05:32:00 <Beelsebob> how the fuck did that work?
05:32:15 <Beelsebob> where did nice come from?
05:32:23 <opqdonut> :D
05:32:23 <lilac> @type look
05:32:24 <lambdabot> forall a nice muscles. a -> a -> a -> nice -> muscles
05:32:31 <opqdonut> hax
05:32:36 <lilac> @bothax
05:32:37 <lunabot>  :)
05:32:37 <lambdabot> Unknown command, try @list
05:34:02 * earthy points beelsebob to #haskell.dut
05:35:26 <Twey> Hahahaha, lilac
05:39:16 <byorgey> @remember lilac @type \o-> look at my muscles  <lambdabot> forall t nice muscles. t -> nice -> muscles
05:39:16 <lambdabot> Good to know.
05:39:34 <FunctorSalad> @quote motor cycle
05:39:35 <lambdabot> No quotes for this person. You type like i drive.
05:39:42 <FunctorSalad> newsham had something
05:39:56 <opqdonut> @quote motor.*cycle
05:39:57 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
05:40:32 <Clockwork> http://hpaste.org/12610 another compiler error... :15 - Missing binding for variable "lTeilbaum" in type signature ... well, I checked the signature with other compareable function, I dont get it
05:41:15 <vixey> Clockwork, what could be wrong?
05:41:35 <Clockwork> the typer signature doesnt match with the patterns?
05:41:45 <vixey> Clockwork, maybe you need a bigger font size
05:41:50 <Clockwork> :D
05:41:53 <Clockwork> I'll try
05:42:19 * byorgey mumbles something about capitalization
05:42:59 <Clockwork> HAH
05:43:03 <Clockwork> thanks for the tip
05:43:33 <FunctorSalad> apple iTeilbaum? ;)
05:43:45 <Clockwork> it was really a small letter b instead of B
05:43:59 <Clockwork> Baum->Apple->Worm->...
05:45:15 <Axman6> byorgey: nicely picked, took me a while even after you said that
05:45:32 <byorgey> hehe
05:45:36 <vixey> you need a bigger font too :p
05:46:46 <byorgey> it would be sweet if ghc and/or hugs could pick up on that.  "Missing binding for "foo"... perhaps you miscapitalized it?"
05:47:25 <Axman6> another reason why tab completion is awesome
05:47:29 <vixey> SWI Prolog does that :)
05:47:42 <vixey> It is actually pretty annoying...
05:49:29 <byorgey> yeah, I imagine it could be annoying too
05:49:34 <byorgey> if you got too many false positives
05:49:57 <Clockwork> what was the definition to assign my own showFunction to a data type? instance( show : showMe) ???
05:51:34 <quicksilver> instance Show Foo where show f = ....
05:51:50 <Axman6> is if' supposed to be in Haskell'?
05:52:03 <yitz> i find that emacs colorization helps me to avoid any capitalization issues
05:52:03 <quicksilver> Axman6: I don't recall a proposal that it should be.
05:52:12 <Axman6> righto
05:52:16 <yitz> @hoogle if'
05:52:17 <lambdabot> No results found
05:52:27 <quicksilver> Axman6: one could imagine putting it in Data.Bool
05:52:35 <Axman6> that would be nice
05:52:37 <quicksilver> it is the elimination function for Bool
05:52:41 <Clockwork> :r
05:52:44 <quicksilver> but I can't say I've ever wanted to use it.
05:52:47 <quicksilver> what do you want it for?
05:53:19 <yitz> quicksilver: i think it's mainly useful for @pl, which is why \bot has it
05:53:24 * quicksilver nods
05:53:41 <quicksilver> I have never wanted to use the @pl expressions which involve if' though ;)
05:54:10 <ziman> @pl \x -> if foo then bar else x
05:54:10 <lambdabot> if' foo bar
05:55:10 <Clockwork> instance Show Baum a >my show function< (without where) <-- is that possible?
05:55:15 <yitz> @pl \p x -> if p x then Just x else Nothing
05:55:15 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .)
05:55:22 <yitz> ick
05:55:23 <Clockwork> I just want to assign my showfunction f to the declaratuin
05:55:49 <yitz> @pl \p x -> guard (p x) >> return x
05:55:49 <lambdabot> (`ap` return) . (((>>) . guard) .)
05:56:00 <yitz> a little better
05:56:03 <Axman6> > foldr (const (1:)) [] [1..10]
05:56:05 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
05:56:13 <Axman6> ah whoot
05:57:25 <yitz> @type flip flip Nothing
05:57:27 <lambdabot> forall a c a1. (a -> Maybe a1 -> c) -> a -> c
05:57:40 <vixey> :t ($ Nothing)
05:57:42 <PeakerWork> I love conal's "argument", "result", etc.  Makes PL-style that much more readable
05:57:42 <lambdabot> forall b a. (Maybe a -> b) -> b
05:57:53 <vixey> :t (flip ($ Nothing))
05:57:54 <lambdabot> forall a b c. b -> (Maybe a -> b -> c) -> c
05:58:05 <vixey> :t flip flip
05:58:06 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
05:58:08 <Axman6> :t flip flip flip
05:58:09 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
05:58:18 <Axman6> :t flip flip flip flip
05:58:19 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
05:58:30 <Martijn> :t flip (flip flip)
05:58:31 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
05:58:42 <quicksilver> PeakerWork: what are they?
05:58:50 <Axman6> :t flip . flip . flip
05:58:51 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
05:58:54 <yitz> i think those are going to make *me* flip
05:59:12 <Axman6> :t flip . flip
05:59:14 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
05:59:28 <Axman6> flip . flip == id then?
05:59:33 <Martijn> yes
05:59:44 <Martijn> for functions with at least two arguments anyway
05:59:45 <Axman6> guess that makes perfect sense
05:59:46 <PeakerWork> quicksilver: http://conal.net/blog/posts/prettier-functions-for-wrapping-and-wrapping/    Basically "argument" composes a function that operates on the argument before a given function.  "result" = fmap on functions.  first/second already exist as "fmap" on tuple elements, etc
05:59:51 <lambdabot> Title: Conal Elliott » Prettier functions for wrapping and wrapping, http://tinyurl.com/58k2zz
05:59:53 <vixey> flip (flip (+)) = flip (+) = (+)
06:00:01 <PeakerWork> quicksilver: so instead of fmap.fmap.fmap,  you get result.second.argument, etc
06:00:11 <quicksilver> hmm
06:00:17 <Axman6> vixey: not sure that
06:00:23 <Axman6> s the best example..
06:00:50 <Martijn> vixey: that only works for associative operators, but flip.flip == id for any binary operator
06:01:12 <Martijn> @pl \x y -> f x y == g x y
06:01:12 <lambdabot> ap (ap . ((==) .) . f) g
06:01:27 <quicksilver> PeakerWork: hmm. That is interesting.
06:01:28 <Axman6> :t (flip . flip) (f :: a -> b -> c -> d)
06:01:29 <lambdabot>     Could not deduce (SimpleReflect.FromExpr d, Show c, Show b, Show a)
06:01:29 <lambdabot>       from the context ()
06:01:29 <lambdabot>       arising from a use of `f' at <interactive>:1:15
06:02:04 <Martijn> Nice :-) Is that a bug in \bot?
06:02:16 <ksf> @src sum
06:02:17 <lambdabot> sum = foldl (+) 0
06:02:17 <vixey> > x ^ 2
06:02:19 <lambdabot>   x * x
06:02:29 <Martijn> @quickCheck \x y -> const id x y == flip const x y
06:02:29 <lambdabot> Unknown command, try @list
06:02:32 <Martijn> @list
06:02:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:02:34 <vixey> > map (\x -> 1 + x ^ 2) [x,y,z]
06:02:36 <lambdabot>   [1 + x * x,1 + y * y,1 + z * z]
06:02:50 <ksf> what's "foldl (-)" called?
06:03:10 <Martijn> ksf: there's no standard function for that
06:03:36 <ksf> yeah I know, I'm just wondering.
06:03:48 <ksf> "difference" somewhat implies two arguments.
06:03:53 <Martijn> will \bot allow me to run quickchecks?
06:04:04 <quicksilver> that's just the head minus the sum of the tail, isn't it?
06:04:08 <Axman6> > foldl (-) [1..10]
06:04:10 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
06:04:10 <lambdabot>        arising from a use...
06:04:15 <Axman6> > foldl (-) 0 [1..10]
06:04:16 <lambdabot>   -55
06:04:33 <quicksilver> foldl (-) n l = n - sum l
06:04:33 <Axman6> > foldl ((-1)^) 0 [1..10]
06:04:35 <lambdabot>       No instance for (Num (b -> a))
06:04:35 <lambdabot>        arising from a use of `negate' at...
06:04:45 <Axman6> > foldl ((0-1)^) 0 [1..10]
06:04:46 <lambdabot>       No instance for (Num (b -> a))
06:04:46 <lambdabot>        arising from the literal `0' at <...
06:04:48 <Axman6> >_>
06:05:43 <vixey> dead links to papers I want to read :(
06:05:56 <Martijn> Axman6: the function given to foldl must be binary, but ((-1)^) is unary.
06:06:08 <Axman6> ah yes, so it is
06:06:18 <Axman6> > foldl (const ((0-1)^)) 0 [1..10]
06:06:20 <lambdabot>   1
06:06:28 <Axman6> > foldl (flip const ((0-1)^)) 0 [1..10]
06:06:29 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
06:06:29 <lambdabot>      Proba...
06:08:04 <cknapp> is there any way to import a module with a qualified name, except for a few operations?
06:08:22 <ddarius> Yes.
06:09:03 <quicksilver> cknapp: use two statements.
06:09:08 <quicksilver> import qualified Foo as F
06:09:14 <quicksilver> import Foo(only,these.things)
06:09:22 <cknapp> Ok
06:09:26 <cknapp> Thanks
06:09:34 <Axman6> i think he wants to exclude, rather than include
06:09:42 <quicksilver> that did.
06:09:49 <quicksilver> it excluded it from the 'only qualified'
06:09:50 <quicksilver> ;)
06:09:55 <cknapp> That makes too much sense for me to think it up on my own. :)
06:09:58 <Twey> Heh
06:10:02 <Axman6> ah i see, excellent
06:10:20 * quicksilver normally import qualified Data.Map as M; import Data.Map(Map);
06:10:33 <Twey> import qualified Foo hiding (these, things) as F; import Foo (these, things)
06:10:42 <Twey> I do it for the operators
06:10:43 <yitz> @check \a b c -> let x = ((-b + sqrt (b*b+4*a*c))/(2*a))^2 in a*x*x+b*x+c == 0
06:10:44 <lambdabot>   "Falsifiable, after 0 tests:\n1.5\n-2.0\n-0.5\n"
06:10:51 <Twey> a M.\\ b just seems ugly
06:10:57 <PeakerWork> When importing qualified, why would you want "hiding"?
06:11:10 <Twey> For neatness' sake?  Heh
06:11:25 <vixey> > let (a,b,c) = (1.5,-2.0,-0.5) in a*x*x+b*x+c
06:11:26 <yitz> Martijn: ^
06:11:27 <lambdabot>   1.5 * x * x + negate 2.0 * x + negate 0.5
06:11:47 <vixey> > let (a,b,c) = (1.5,-2.0,-0.5) ; x = ((-b + sqrt (b*b+4*a*c))/(2*a))^2 in a*x*x+b*x+c
06:11:49 <lambdabot>   -1.0
06:11:58 <vixey> > let (a,b,c) = (1.5 :: Complex CReal,-2.0,-0.5) ; x = ((-b + sqrt (b*b+4*a*c))/(2*a))^2 in a*x*x+b*x+c
06:12:01 <lambdabot>   (-1.0) :+ 0.0
06:12:09 <vixey> > let (a,b,c) = (1.5 :: Complex CReal,-2.0,-0.5) ; x = ((-b + sqrt (b*b-4*a*c))/(2*a))^2 in a*x*x+b*x+c
06:12:11 <lambdabot>   3.3301861563441411781493450026957484634891 :+ 0.0
06:12:42 <vixey> > let (a,b,c) = (1.5 :: Complex CReal,-2.0,-0.5) ; x = ((sqrt (b*b-4*a*c) - b)/(2*a)) in a*x*x+b*x+c
06:12:44 <lambdabot>   0.0 :+ 0.0
06:13:09 <Axman6> > sqrt (-1 :: Double) :: Complex Double
06:13:11 <lambdabot>   Couldn't match expected type `Complex Double'
06:13:24 <Twey> :t sqrt
06:13:26 <lambdabot> forall a. (Floating a) => a -> a
06:14:38 <quicksilver> Twey: there's no real need to hide them though.
06:14:45 <PeakerWork> I think all imports must be qualified or explicit (names)
06:14:48 <quicksilver> Twey: they don't get in the way (the qualified version) if you don't use them.
06:14:53 <PeakerWork> unqualified imports make me sad
06:15:16 <Twey> quicksilver: I know, I know.
06:15:23 <Twey> It just makes me feel better.
06:15:25 <Martijn> overqualified imports make me sad :-(
06:15:31 <PeakerWork> Martijn: why?
06:15:32 <Twey> PeakerWork: Aye, me too, somewhat
06:15:33 <Axman6> vixey: i'm starting to see why that deforrestation thing is so cool
06:15:35 <PeakerWork> Martijn: you know where they're coming from
06:15:44 <Twey> Axman6: It's in Supero already
06:15:59 <Axman6> Twey: in what?
06:16:05 * ksf shivers
06:16:13 <Twey> But come Haskell', you get to write operators as M.(\\) a b
06:16:17 <ksf> folding (!!)? Do I really have to?
06:16:21 <Twey> Losing all infix :(
06:16:31 <Twey> Unless you do a `M.(\\)` b
06:16:40 <Axman6> :t foldr (!!)
06:16:41 <lambdabot> Int -> [[Int]] -> Int
06:16:51 <vixey> ooooooooooh wow
06:17:02 <vixey> http://www.cs.nott.ac.uk/~nxg/papers/fi04.ps.gz
06:17:08 <Twey> And between a `M.(\\)` b, and a \\ b, I'd take the latter
06:17:20 <Axman6> > foldr (!!) 0 [[1..3],[2..4],[6..9]]
06:17:22 <lambdabot>   * Exception: Prelude.(!!): index too large
06:17:23 <PeakerWork> Twey: The dot for imports sucks, due to composition dot. One of them needs to change
06:17:25 <Twey> Axman6: http://www-users.cs.york.ac.uk/~ndm/supero/
06:17:27 <lambdabot> Title: Neil Mitchell - Supero
06:17:30 <vixey> this paper shows _why_ you get the derivative
06:17:30 <Twey> PeakerWork: Aye
06:18:02 <luite_> just use the \ as import/package separator, just like php ;)
06:18:04 <PeakerWork> Operator names ought to be imported via (names), rather than via qualification,  but implicit name pollution must stop
06:18:28 * Twey nods.
06:19:04 <PeakerWork> I can't read code that has a pageful of imports, and each name I see I have to start grepping the world to see where its coming from :-(
06:19:08 <quicksilver> Twey: I thought supero got deforestation for free by church encoding everything?
06:19:12 <PeakerWork> code is read more times than it is written
06:19:16 <quicksilver> rather than having an explicit deforestation pass.
06:19:47 <Twey> I got the impression that it was explicit
06:19:53 <Twey> Maybe I misunderstood
06:20:04 <JimCrayne> i got my real world haskell book yesterday
06:20:11 <quicksilver> woot!
06:20:16 <JimCrayne> :)
06:20:25 <quicksilver> do you sleep with it under your pillow? I would...
06:20:29 <Twey> Hahaha
06:20:29 <JimCrayne> lol
06:20:35 <Twey> I wish I had the money left to order one :(
06:20:38 <earthy> nah, I need my sleep too much
06:20:44 <Twey> Damn desktop repairs... damn Christmas...
06:21:28 <Clockwork> http://hpaste.org/12611 - Syntax error in input "unexpected keyword "instance" - why I mean... jesus
06:21:29 <JimCrayne> order one as a present to someone in your household who will never read it
06:21:34 <JimCrayne> haha
06:22:13 <Twey> Hahaha
06:22:16 <quicksilver> Clockwork: you don't want to indent it.
06:22:19 <lilac> @check \a' b' c' -> let [a,b,c] = map realToFrac [a',b',c']; x = (-b + sqrt (b*b-4*a*c))/(2*a) in a == 0 || magnitude (a*x*x+b*x+c) < 1e-10
06:22:21 <lambdabot>   "OK, passed 500 tests."
06:22:21 <ski_> Clockwork : indent `instance ..' no more than `data ...'
06:22:27 <Twey> Oh yes, I can just see that working as a present to my elderly mother
06:22:39 <ksf> somewhat, my brain is refusing to parse foldr (a !!)
06:23:12 <JimCrayne> a is a list
06:23:18 <JimCrayne> it's a partial application
06:23:36 <lilac> why is there no Arbitrary a => Arbitrary (Complex a) instance?
06:23:42 <Axman6> :t (a !!)
06:23:43 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
06:23:43 <lambdabot>     In the first argument of `(!!)', namely `a'
06:23:49 <Axman6> :t ([a] !!)
06:23:50 <lambdabot> Int -> Expr
06:24:21 <ben> I thought foldr wanted binary functions? :[
06:24:25 <jkff> wtf Expr?
06:24:44 <ksf> actually, it's going to be indexU.
06:24:52 <jkff> :t \a -> foldr (a !!)
06:24:53 <lambdabot> forall b. [b -> b] -> b -> [Int] -> b
06:24:58 <JimCrayne> :t foldr
06:24:59 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:25:00 <FunctorSalad> wtf: Type constructor not found
06:25:15 <vixey> :k Wtf
06:25:16 <lambdabot> Not in scope: type constructor or class `Wtf'
06:25:23 <Axman6> > map f [a,b,c] :: [Expr]
06:25:25 <lambdabot>   [f a,f b,f c]
06:25:39 <Axman6> > foldr f x [a,b,c] :: [Expr]
06:25:40 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Expr'
06:25:44 <Axman6> > foldr f x [a,b,c] :: Expr
06:25:46 <lambdabot>   f a (f b (f c x))
06:26:00 <jkff> Oh, cool!
06:26:09 <Axman6> @hoogle Expr
06:26:10 <lambdabot> module Text.Parsec.Expr
06:26:10 <lambdabot> module Text.ParserCombinators.Parsec.Expr
06:26:10 <lambdabot> Distribution.Simple.Program alexProgram :: Program
06:26:21 <vixey> > foldl (flip f) x (reverse [a,b,c])
06:26:23 <lambdabot>   f a (f b (f c x))
06:26:33 <ksf> hmmm...
06:27:00 <FunctorSalad> > f a
06:27:01 <lambdabot>   Add a type signature
06:27:12 <jkff> > f a :: Expr
06:27:14 <lambdabot>   f a
06:27:17 <FunctorSalad> @type f
06:27:18 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:27:33 <FunctorSalad> @type f9
06:27:35 <lambdabot> Not in scope: `f9'
06:27:40 <jkff> I'd buy a beer to the guy who invented Expr
06:27:51 <FunctorSalad> don't you think that magic f is more confusing to newcomers than it helps?
06:28:19 <vixey> FunctorSalad, it's cool enough that it doesn't matter
06:28:26 <jkff> Well, then the newcomers are free to not use it, and the elder ones will always explain things
06:28:26 <FunctorSalad> :)
06:28:31 <jkff> But for illustrative purposes it's way cool
06:28:35 <Axman6> > GHC.Exts.build (\c z -> c a (c b (c d n))))
06:28:37 <lambdabot>   <no location info>: parse error on input `)'
06:28:37 <vixey> ehehe The Elders
06:28:44 <Axman6> > GHC.Exts.build (\c z -> c a (c b (c d n)))
06:28:45 <lambdabot>   Couldn't match expected type `b' against inferred type `Expr'
06:28:56 <lilac> @type let wtf (In wft) = In wtf in wtf
06:28:58 <lambdabot> forall (t :: * -> *). Mu t -> Mu ((->) (Mu t))
06:28:58 <Axman6> > GHC.Exts.build (\c z -> c a (c b (c d z)))
06:29:00 <lambdabot>   /tmp/3990049682073465722:70:32: Not in scope: `GHC.Exts.build'
06:29:12 <Axman6> @hoogle build
06:29:13 <lambdabot> Distribution.Simple.Build build :: PackageDescription -> LocalBuildInfo -> BuildFlags -> [PPSuffixHandler] -> IO ()
06:29:13 <lambdabot> Distribution.Simple.GHC build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
06:29:13 <lambdabot> Distribution.Simple.Hugs build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
06:29:20 <Axman6> -_-
06:29:23 <vixey> @remember lilac @type let in let wtf (In wft) = In wtf in wtf
06:29:24 <lambdabot> I will never forget.
06:29:28 <Axman6> vixey: 'lil help? :(
06:29:38 <ski_> build :: (forall o. (a -> o -> o) -> o -> o) -> [a]
06:29:47 <vixey> build instructions = instructions (:) []
06:30:07 <lilac> vixey: extra 'let in'
06:30:10 <JimCrayne> is
06:30:15 <Axman6> > let build ins = ins (:) [] in build (\c z -> c a (c b (c d z)))
06:30:18 <lambdabot>   [a,b,d]
06:30:19 <ski_> @type GHC.Base.build
06:30:20 <JimCrayne> is Expr just used for lambdabot
06:30:20 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
06:30:21 <Axman6> whoot!
06:30:36 <ski_> > let in ()
06:30:38 <lambdabot>   ()
06:30:42 <vixey> @free instructions :: forall o. (a -> o -> o) -> o -> o
06:30:43 <lambdabot> (forall x. g . h x = k (f x) . g) => g . instructions h = instructions k . g
06:30:52 <lilac> oh, neat :)
06:31:01 <lilac> > let in let in let in let in f
06:31:02 <lambdabot>   Add a type signature
06:31:04 <Axman6> @help free
06:31:04 <lambdabot> free <ident>. Generate theorems for free
06:31:05 <lilac> > let in let in let in let in f :: Expr
06:31:07 <lambdabot>   f
06:31:14 <ski_> @free help
06:31:15 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `help'\n\n"
06:31:43 <lilac> @free muscles
06:31:45 <lambdabot> f muscles = muscles
06:31:49 * vixey has the urge to try and program free theorems in a theorem prover
06:31:56 <jkff> vixey: Coq?
06:32:32 <jkff> I urged to program them in Haskell yesterday but surrendered after realizing that, being not Oleg, I'll have the chance to succeed only in Coq
06:32:39 <vixey> jkff, yeah
06:32:52 <vixey> jkff, I don't totally understand the paper enough I think..
06:33:00 <jkff> I had the same motivation :)
06:33:23 <jkff> However looks like I understood the paper without writing a free theorem generator.
06:33:41 <vixey> jkff, did you get any code written yet?
06:34:17 <Axman6> how old is the paper?
06:34:45 <jkff> Nope, I threw it away after realizing that Haskell in my hands is not expressive enough to express everything that I wanted to express, let's say it that way :)
06:35:07 <vixey> I'm going to reread the paper and then think about how to express it
06:35:18 <jkff> The paper is 1990
06:35:33 <vixey> jkff, can I pester you about it if you're on and I get confused ? :p
06:35:35 <ski_> the "theorems for free !" one ?
06:35:43 <jkff> Yes
06:35:59 <jkff> ..Yes, too.
06:36:29 <jkff> However I guess I'll have to use Coq anyway, sooner or later. Don't get me incorrectly :-|
06:36:43 <vixey> jkff, for what?
06:37:42 <vixey> @free id
06:37:43 <jkff> I'm going to apply the free theorems to something different than polymorphic lambda calculus
06:37:43 <lambdabot> f . id = id . f
06:38:03 <jkff> Namely, to SQL query optimization, with a -> b being actually a <-> b
06:38:17 <vixey> wow sounds cool
06:38:42 <vixey> compiler optimizations for free
06:38:58 <jkff> Sounded cool for me too, until I realized that I know essentially nothing of the theory needed to doing this the right way :0
06:39:02 <jkff> I mean, :)
06:40:08 <lilac> jkff: no instance for Num [a]
06:40:16 <jkff> Although it still does sound cool. Now that I'm equipped with De Bruin's article on 'Naturality and polymorphism', i'm probably a bit closer.
06:40:30 <Clockwork> How can I add a secondary function for an already defined function? For instance, f = ... blah and now I want it to be g = f...
06:40:46 <jkff> lilac: `a' is not in scope
06:40:53 <jkff> What did you mean? :)
06:41:03 <lilac> > undefined   :0
06:41:04 <lambdabot>       No instance for (Num [a])
06:41:04 <lambdabot>        arising from the literal `0' at <inter...
06:41:13 <lilac> :D
06:41:27 <jkff> Oh!
06:41:42 <jkff> Unknown command: ':D'. Use :? for help.
06:41:48 <lilac> lol
06:43:24 <vixey> @pl (f . g) . h
06:43:25 <lambdabot> f . g . h
06:43:25 <dmwit> Clockwork: "where"
06:43:28 <vixey> @pl f . (g . h)
06:43:29 <lambdabot> f . g . h
06:43:44 <vixey> @undo f . (g . h)
06:43:45 <lambdabot> f . (g . h)
06:43:49 <vixey> @undo (f . g) . h
06:43:49 <lambdabot> (f . g) . h
06:43:59 <vixey> why doesn't it tell me which way . associaties..
06:44:30 <dmwit> It does.
06:44:56 <dmwit> ...depending on what "it" is
06:45:22 <dmwit> :info . -- in ghci
06:45:31 <lilac> vixey: (.) is associative...
06:45:35 <jkff> What are @pl and @undo for?
06:46:04 <jkff> vixey: the answer is that . associates.
06:46:07 <jkff> Yes
06:46:28 <lilac> jkff: @pl transforms into point free ("pointless") form, @undo does do and list comprehension desugaring
06:46:44 <lilac> @pl \x y z -> f (g x) (h y) z
06:46:45 <lambdabot> (. h) . f . g
06:47:02 <jkff> I see, thanks
06:47:13 <lilac> @undo [ (a,b) | a <- [1..5], b <- [1..5], a + b == 5 ]
06:47:13 <lambdabot> concatMap (\ a -> concatMap (\ b -> if a + b == 5 then [(a, b)] else []) [1 .. 5]) [1 .. 5]
06:47:25 <Clockwork> http://hpaste.org/12612 Why is Example 1 working fine and Example 2 gives me this badass error?
06:48:00 <jkff> @pl \x y -> f (h x) (h y)
06:48:01 <lambdabot> (. h) . f . h
06:48:02 <vixey> what's /\ called, the type level lambda? (any more catchy names?)
06:48:04 <quicksilver> Clockwork: Monomorphism restriction
06:48:15 <quicksilver> @go haskellwiki monomorphism restriction
06:48:17 <lilac> vixey: Big Lambda? :)
06:48:19 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:48:19 <lambdabot> Title: Monomorphism restriction - HaskellWiki
06:48:24 <quicksilver> ^^ read that.
06:48:26 <dmwit> vixey: sometimes "capital lambda"
06:48:31 <quicksilver> vixey: "Type lambda" or "big lambda"
06:48:32 <quicksilver> IME
06:48:47 <dmwit> ?undo [x | Just x <- xs]
06:48:48 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) xs
06:48:49 <quicksilver> occasionally you might hear it read as 'for all'
06:50:52 <ski_> vixey :i thought "type level lambda" was the one in `\x -> (a -> Maybe x)'
06:51:23 <dmwit> exactly right
06:51:39 <vixey> ski_, I write /\x -> (a -> Maybe x) though
06:51:45 <Raevel> why doesn't lambdabot like this?
06:51:51 <vixey> ski_, actually /\x. (a -> Maybe x)
06:52:02 <Raevel> @pl (\v -> case v of Just x -> True; Nothing -> False)
06:52:02 <lambdabot> (line 1, column 25):
06:52:02 <lambdabot> unexpected ">"
06:52:02 <lambdabot> expecting variable, "(", operator or ")"
06:52:17 <quicksilver> Raevel: pl is broken.
06:52:28 <quicksilver> it has an incomplete haskell parser.
06:52:29 <dmwit> You can't ?pl a case statement in general.
06:52:38 <Raevel> i see
06:52:44 <ski_> vixey : i've seen `/\' used for type abstraction in terms
06:52:46 <ksf> ah. the point is that I want to fold (flip (!!)), not (!!)
06:52:58 <ksf> :t foldr (flip (!!))
06:53:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
06:53:00 <lambdabot>       Expected type: Int -> [a] -> [a]
06:53:00 <lambdabot>       Inferred type: Int -> [a] -> a
06:53:03 <ski_> (unless i'm totally misremembering ..)
06:53:16 <ksf> hmmm
06:53:48 <bwr> i am trying to do duration <- randomRIO (50, 100)  and let stopTime = addUTCTime duration startTime    but i am getting
06:53:58 <bwr> No instance for (Random NominalDiffTime)
06:53:58 <dmwit> ksf: Maybe you want to iterate?
06:54:08 <bwr> which makes sense, but how do i generate a random time offset
06:54:08 <dmwit> :t \x -> iterate (x!!)
06:54:09 <lambdabot> [Int] -> Int -> [Int]
06:54:29 <vixey> ski_, I've seen that also, but I've used /\ just because it's notation from @unmtl
06:54:43 <ski_> oh .. that might be
06:54:55 <ski_> @unmtl MaybeT IO
06:54:55 <lambdabot> err: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
06:55:36 <Axman6> > (\x -> iterate (x!!)) [0,..10] 1
06:55:37 <lambdabot>   <no location info>: parse error on input `..'
06:55:43 <Axman6> > (\x -> iterate (x!!)) [0..10] 1
06:55:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:55:46 <jkff> @free (fix .) . (. fix)
06:55:47 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
06:55:49 <jkff> Hehe
06:55:50 <Axman6> > (\x -> iterate (x!!)) [1..10] 1
06:55:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,* Exception: Prelude.(!!): index too large
06:56:15 <jkff> @free (fix .)
06:56:16 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
06:56:18 <jkff> @free fix
06:56:19 <lambdabot> f . g = h . f => f (fix g) = fix h
06:56:28 <jkff> @free (\f -> fix . f)
06:56:29 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
06:56:32 * ski_ ponders `Fix2 (ContT o) (ST s) a'
06:56:37 <ksf> I want to write (a !! (n1 + ( a !! (n2 + ( a !! ( n3 + ...))))
06:57:01 <quicksilver> bwr: get a random Double
06:57:08 <quicksilver> bwr: and realToFrac it.
06:57:53 <ski_> @type \a -> foldr (\n foo -> a !! (n + foo)) 0
06:57:55 <lambdabot> [Int] -> [Int] -> Int
06:58:40 <lilac> vixey: as far as i recall, core uses \ for type-level lambdas
06:59:48 <FunctorSalad> I guess there is no way of making types values without having full-blown dependent types?
07:00:22 <vixey> FunctorSalad, what does it mean for a type to be a value?
07:00:51 <ksf> ski_, thanks
07:01:17 <quicksilver> FunctorSalad: making types values sounds pretty much like one of the definitions of dependent types, to me ;)
07:01:35 <quicksilver> FunctorSalad: although "reifying" types as values is normally considered to be a much weaker thing.
07:01:35 <FunctorSalad> vixey: a 'first-class citizen', so you can do stuff like 'map Set [Int,String]'
07:01:44 <quicksilver> FunctorSalad: are you familiar with the lambda cube?
07:02:03 <FunctorSalad> quicksilver: reifying as in Typeable? yeah, that's run-time only
07:02:23 <quicksilver> run-time only in the same sense that 1+1 is runtime only, yes.
07:02:30 <quicksilver> In the same sense that all values are run-time only.
07:02:31 <FunctorSalad> quicksilver: briefly looked at it, but I wouldn't say 'familiar' :)
07:02:46 <quicksilver> What did you expect when you said "make types values" that didn't include being run-time only?
07:02:52 <vixey> FunctorSalad, so in terms of the type rules of lambda, it means \x -> M you want to add the rule x :: * and M :: *
07:03:00 <bwr> quicksilver: thanks, i will try that
07:03:43 <vixey> FunctorSalad, but not you still have options about things like (T::*)  |- x :: *,  M :: T
07:03:53 <FunctorSalad> quicksilver: I was thinking about it because type-level programming really is a bit awkward and requires you to duplicate everything from the value level...
07:05:05 <FunctorSalad> so I was wondering whether the levels could be unified without all the complexity of dep. types
07:05:17 <FunctorSalad> but I think you're right ;)
07:06:07 <camio> Anyone know of something like [(a->a)] -> (a->a)?
07:06:32 <FunctorSalad> @type foldl (.) id
07:06:33 <lambdabot> forall a. [a -> a] -> a -> a
07:06:48 <jkff> Or probably msum?
07:06:53 <Igloo> foldr (.) id is better
07:07:04 <FunctorSalad> for application? true
07:07:15 <camio> Why not msum?
07:07:37 <jkff> Does a->a have a monoid instance in the standard library?
07:08:06 <quicksilver> FunctorSalad: I'm pretty sure unifying the levels *is* dependent types, in one form or another :)
07:08:16 <quicksilver> jkff: yes, under the 'Endo' newtype
07:08:23 <quicksilver> :t Endo (+1)
07:08:25 <lambdabot> forall a. (Num a) => Endo a
07:08:39 <quicksilver> :t runEndo
07:08:40 <lambdabot> Not in scope: `runEndo'
07:09:22 <quicksilver> > appEndo (Endo (+1) `mappend` Endo (*2)) $ 5
07:09:23 <lambdabot>   11
07:09:28 <quicksilver> beautiful ;)
07:10:16 <Axman6> what's Endo?
07:10:20 <BONUS> endomorphism
07:10:24 <BONUS> basically a -> a
07:10:28 <Axman6> ah, right
07:10:38 <jkff> > appEndo (map Endo  [(+1), (*2), (`mod`3), (`div`2)]) 10
07:10:40 <lambdabot>   Couldn't match expected type `Endo a'
07:10:59 <jkff> > appEndo (msum (map Endo  [(+1), (*2), (`mod`3), (`div`2)])) 10
07:11:00 <lambdabot>       No instance for (MonadPlus Endo)
07:11:00 <lambdabot>        arising from a use of `msum' at...
07:11:02 <BONUS> hmm
07:11:04 <jkff> Grr
07:11:05 <BONUS> is a -> m a
07:11:07 <BONUS> a monoid
07:11:10 <BONUS> where m is a Monad
07:11:13 <quicksilver> jkff: mconcat
07:11:19 <quicksilver> (msum is monadPlus)
07:11:21 <jkff> Ah, yes
07:11:32 <quicksilver> BONUS: yes.
07:11:52 <BONUS> i recon mapped is kleisli composition
07:11:59 <quicksilver> because kleisli composition is associative
07:12:00 <quicksilver> right.
07:12:03 <BONUS> and mempty would be return
07:12:05 <BONUS> kewl
07:13:17 <therp> is there any predefined function (or neat combination of predefined functions) with the type signature Eq a => [(a,b)] -> [(a,[b])]?
07:14:00 <Martijn> @help djinn
07:14:00 <lambdabot> djinn <type>.
07:14:00 <lambdabot> Generates Haskell code from a type.
07:14:00 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:14:11 <BONUS> you can map (second return) and then cram it into a set with fromListWith (++)
07:14:11 <Martijn> @djinn Eq a => [(a,b)] -> [(a,[b])]
07:14:12 <lambdabot> Error: Undefined type []
07:14:17 <quicksilver> BONUS: it's not particularly obvious that kleisli composition is associative. It is (essentially) one of the monad laws.
07:14:28 <quicksilver> Martijn: djinn does neither classes, nor recursive types.
07:14:29 <BONUS> yeah
07:14:33 <Martijn> sadness
07:14:47 <quicksilver> therp: groupBy (comparing fst) is half the answer.
07:14:50 * ksf wants a UArr (UArr Int)
07:15:18 <therp> quicksilver: right, I have been abusing groupBy for his purpose so often but I don't think it's right
07:15:21 <BONUS> > Set.toList . Set.fromListWith (++) . map (second return) $ [(1,2),(1,3),(1,4),(2,2)]
07:15:22 <lambdabot>       Failed to load interface for `Set':
07:15:22 <lambdabot>        Use -v to see a list of the ...
07:16:05 <ksf> kind of like UArr (ForeignPtr), I know.
07:16:43 <quicksilver> therp: I can't think of anything cleverer off-hand.
07:17:21 <BONUS> > Map.toList . Map.fromListWith (++) . map (second return) $ [(1,2),(1,3),(1,4),(2,2)]
07:17:23 <lambdabot>   [(1,[4,3,2]),(2,[2])]
07:18:44 <quicksilver> BONUS: that loses the order which may or may not matter for therp .
07:18:52 <BONUS> that's true yeah
07:19:08 <quicksilver> I think Map.{foo}With are some of the least used neat functions around.
07:19:19 <BONUS> yeah
07:19:28 <BONUS> hmmm why doesnt Set have fromListWith
07:19:48 <quicksilver> insertWith, differenceWith, intersectionWith are all useful
07:20:07 <therp> order is irrelevant.. nice approach by Map, bonus
07:20:50 <quicksilver> if order is irrelevant maybe you shouuld be useing maps anyway therp?
07:20:55 <quicksilver> they have a number of very useful combinators
07:20:56 <therp> quicksilver: also groupBy is not totally the thing I want. I don't want duplicates in (map fst) results
07:21:48 <therp> quicksilver: frankly I'm still trying to understand bonus solution :)
07:21:57 <FunctorSalad> uncurry :: ((a,b) -> Bool) -> (a -> (b -> Bool)) -- replacing the lists with sets and then encoding the sets as predicates ;)
07:22:05 <ksf> I want -XimplicitFromIntegral, too.
07:22:07 <BONUS> hehe basically fromListWith takes a function and that function takes two elements
07:22:14 <BONUS> the function is for resolving duplicate elements
07:22:23 <BONUS> like what to do when an element is already in the map
07:22:39 <FunctorSalad> err or curry maybe o_o
07:23:00 <BONUS> > map (second return) [(1,2),(1,3)] :: [(Int, [Int])]
07:23:02 <lambdabot>   [(1,[2]),(1,[3])]
07:23:16 <FunctorSalad> unfortunately sets as predicates aren't so great computationally, are they? ;)
07:24:48 <therp> BONUS: ah I see the trick! nice :)
07:25:01 <FunctorSalad> (data SplitEpi anyone?)
07:25:11 <BONUS> yeah fromListWith owns :]
07:25:30 <vixey> ksf, me 3
07:25:32 <BONUS> > Map.fromListWith (+) [(1,2),(1,3),(2,10),(2,15)]
07:25:34 <lambdabot>   fromList [(1,5),(2,25)]
07:26:23 <coldhak> i want to make a haskell program post something to the web. is there a module for that?
07:26:39 <therp> BONUS: although I would use the monkey instead of return. any reason for return?
07:26:48 <BONUS> nor eason
07:26:54 <BONUS> come to think of it i'd use the monkey too
07:27:05 <chrisdone> just when you thought it was safe to bitch about GHC's hard to understand compile errors
07:27:11 <chrisdone> PHP: Parse error: syntax error, unexpected T_PAAMAYIM_NEKUDOTAYIM
07:27:15 <BONUS> haha
07:27:19 <BONUS> thats the :: isnt it
07:27:22 <chrisdone> yeah
07:27:31 <BONUS> hmmm
07:27:38 <twanvl> coldhak: it depends on what you want to do exactly, maybe try the HTTP package
07:27:43 <Martijn> coldhak: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
07:27:44 <yitz> vixey: in conor's paper, mu is forall? what is nu?
07:27:44 <lambdabot> Title: HackageDB: HTTP-3001.1.5
07:28:00 <BONUS> when you do {c <- readFile "blah.txt"; writeFile "blah.txt" (map toUpper c)}
07:28:10 <coldhak> twanvl, i want to have it post a source file to the pastebin
07:28:10 <BONUS> what actually happens in terms of laziness and disk reads
07:28:23 <yitz> (or anyone?)
07:28:30 <quicksilver> BONUS: it all breaks.
07:28:34 <vixey> yitz, I thought Mu was least fixed point and Nu greatest
07:28:37 <quicksilver> BONUS: lazy IO is broken, never us it.
07:28:55 <vixey> yitz, so Mu x. 1 + x is finite sized lists and Nu x. 1 + x is finite or infinite lists
07:29:12 <twanvl> coldhak: you can do that by making an HTTP POST request, you basically simulate what a user would do when he submits the form
07:29:13 <chrisdone> the writeFile would start lazily reading each character from the file and writing to it simultaneously, right?
07:29:43 <BONUS> hmm
07:29:49 <quicksilver> chrisdone: writeFile will clobber the file and then there is nothing to read, under unix semantics, I think.
07:30:02 <chrisdone> ah, good point
07:30:09 <yitz> vixey: he says List X = mu Y . 1 + X x Y
07:30:17 <quicksilver> but the fact that questions like this are hard to answer is precisely why lazy IO sucks.
07:30:21 <chrisdone> I think I've actually had this error when rewriting a file
07:30:24 <chrisdone> indeed
07:30:30 <quicksilver> yitz: yes, in that case mu means least fixed point
07:30:39 <chrisdone> go, System.IO.Strict!
07:30:40 <quicksilver> yitz: which means strictly finite lists (in this exacmple)
07:31:03 <quicksilver> yitz: whilst the greatest fixed point also includes the familiar infinite lists.
07:31:11 <yitz> why is Y introduced then, instead of what vixey said?
07:31:12 <quicksilver> (represented by 'nu')
07:31:20 <quicksilver> Y is a bound variable
07:31:24 <quicksilver> as in \Y -> Y + 1
07:31:27 <quicksilver> call it what you like.
07:31:27 <FunctorSalad> @type (\pairs -> let as = nub (map fst pairs) in map (filter (\a -> (== a) . fst) pairs) as)
07:31:29 <lambdabot>     Couldn't match expected type `Bool'
07:31:29 <lambdabot>            against inferred type `(a, b) -> Bool'
07:31:29 <lambdabot>     In the expression: (== a) . fst
07:31:37 <quicksilver> vixey called it "x", conal called it "Y"
07:31:41 <vixey> yitz, oops I wrote the defintion of natural numbers for some reason
07:32:21 <FunctorSalad> @type (\pairs -> let as = nub (map fst pairs) in map (\a -> filter ((== a) . fst) pairs) as)
07:32:23 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [[(a, b)]]
07:32:38 <FunctorSalad> or something :(
07:34:08 * yitz still doesn't get this notation
07:35:21 <yitz> ok, I see why the def'n of List works as the fixed point.
07:35:27 <quicksilver> yitz: do you get the 1 + X x Y part?
07:35:40 <yitz> now, what is "greatest" fixed point? greatest in what domain?
07:35:52 <quicksilver> the same domain
07:35:59 <quicksilver> sets, perhaps.
07:36:05 <quicksilver> in a nice simple model.
07:36:24 <vixey> yitz, are you reading the paper I linked or something else?
07:36:31 <yitz> so using nu will also give you lists with uncountably many elements?
07:36:36 <yitz> vixey: yes
07:36:40 <lilac> it's basically saying List X = 1 + X x List X, right?
07:36:45 <vixey> yitz, [1,2,3] :: Mu <whatever>
07:36:52 <vixey> yitz, fix (1:) :: Nu <whatever>
07:37:11 <vixey> yitz, the cool thing in that one is how they described it using power series of containers
07:37:25 <quicksilver> yitz: lists with uncountably many members doesn't make sense.
07:37:35 <quicksilver> yitz: when destructing a list, you only have two choices
07:37:41 <quicksilver> it's Nil, or it's Cons x L
07:37:50 <yitz> vixey: yeah, I can see that they're doing that, but I'm trying to grok their notation.
07:37:56 <quicksilver> if you keep taking the right branch, you can keep going forever.
07:38:07 <quicksilver> but even if you keep going forever, it's only a countable idea.
07:38:10 <vixey> yitz, * is (,), + is Either
07:38:21 <vixey> 0 is data Void
07:38:24 <yitz> vixey: yeah, that part I figured out
07:38:25 <quicksilver> the whole idea of destructing finitely described types is somehow inheritently countable.
07:38:25 <vixey> 1 is ()
07:38:48 <quicksilver> in the least fixed point you are guaranteed to eventually hit Nil
07:38:57 <quicksilver> in the greatest fixed point, you are not guaranteed to do so.
07:39:45 <opqdonut> has somebody collected together all these "folklore" improvements to prelude?
07:40:12 <opqdonut> (.)=fmap, proper monad-functor class hierarchy etc
07:40:40 <Twey> > (fmap (*2) (+3)) 4
07:40:42 <lambdabot>   14
07:41:00 <yitz> quicksilver: so it's not really the greatest fixed point in Set, since that also includes much bigger things
07:41:07 <yitz> that are also fixed points
07:41:18 <yitz> that you could never compute
07:41:51 <quicksilver> yitz: I don't believe that is correct, no.
07:42:25 <Asgaroth> Since upgrading to ghc-6.10.1 ghci in emacs' haskell-mode, also outputs the entered the command followed by ^J and then the result. Did anybody else experience this and knows how to deal with this?
07:42:27 <yitz> so how would you defined "greatest" more precisely?
07:42:30 <quicksilver> even in Set, there are no such 'bigger things' in the fixed point of the operation Y --> 1 + X x Y
07:42:39 <quicksilver> yitz: greatest is perfectly precise.
07:42:57 <quicksilver> yitz: it states that there is no larger set which has the property.
07:43:23 <quicksilver> (for it to be well-defined, it must be the case that if A has the property and B has the property, so does A u B. Fortuantely that holds here)
07:45:24 <yitz> what do mean by Y and Z being the "same"?
07:45:43 <quicksilver> actualy the same set. All the same members.
07:45:50 <quicksilver> (not merely isomorphic)
07:45:54 <yitz> if you mean set isomorphic, then there larger fixed points than the one you say.
07:46:09 <yitz> thare are
07:46:19 <quicksilver> I mean actual set identity.
07:46:38 <quicksilver> Note that "1", "x" and "+" have to denote fixed constructions. too.
07:47:01 <quicksilver> It doesn't particular matter which construction, (among the obviously isomorphic choices) but you do fix one.
07:47:06 <coldhak> is there a cpan-style program for installing haskell modules?
07:47:13 <quicksilver> coldhak: yes, cabal-install.
07:47:19 <coldhak> thanks
07:47:25 <Saizan_> Asgaroth: there's a topic on the ghc-users list about that
07:47:34 <quicksilver> coldhak: it takes a few dependencies to get going but once you have it, it can install most other modules quickly + easily.
07:49:33 <yitz> quicksilver: if + is direct sum and x is direct product, then 1+Xx(List X) is isomorphic to but not equal to List X.
07:50:11 <quicksilver> yitz: No, it's equal.
07:50:17 <quicksilver> that's what it means for List X to be a fixed point.
07:51:47 <yitz> by definition of direct sum/product they are not equal. you create a new set whenever you take a sum/product.
07:52:14 <quicksilver> yes.
07:52:16 <quicksilver> but it all works.
07:52:26 <jeffersonheard> I just noticed that DiffTime and NominalDiffTime are instances of Show but not of Read
07:52:41 <jeffersonheard> is there a reason for that?  Is there a better way to store a time interval?
07:53:11 <yitz> jeffersonheard: you can only create them as a difference between two times
07:53:31 <jeffersonheard> yitz, you can create them by using secondsToDiffTime as well.
07:54:04 <quicksilver> let's take concrete definitions: [[1]] = Nil. A + B = {(0,a) : a \in A} u {(1,b) : b \in B}, AxB as (a,b) in the obvious way.
07:54:14 <yitz> jeffersonheard: ah ok. I guess you can think of that as time after the epoch.
07:54:30 <quicksilver> it doesn't matter how we implement Nil, 0,1 or (,) as long as we are consistent.
07:54:41 <quicksilver> yitz: happy with that concrete setup?
07:55:09 <jeffersonheard> so I do "let realInterval = diffUTCTime a b in if realInterval > myTimeout then..."
07:55:26 <quicksilver> hmm. I didn't quite get that right.
07:55:26 <jeffersonheard> and I was trying to store myTimeout as a DiffTime rather than as an integer that I have to convert
07:55:31 <jeffersonheard> because it seemed silly to convert it
07:55:37 <yitz> quicksilver: ok so far
07:55:55 <jeffersonheard> when what I'm representing is an interval of time, not a number
07:56:19 <yitz> quicksilver: it's ok, go on pls.
07:56:57 <FunctorSalad> yitz: quicksilver isn't "greatest", here, "terminal object in the category of diagrams of the form 1 + _ x Y -> _"? (and wasn't it initial rather than terminal)
07:57:53 <byorgey> FunctorSalad: you don't really have to appeal to category theory, you can define it all in terms of sets.
07:58:37 <FunctorSalad> byorgey: I found it odd that List Y should be equal as a set to "1 + Y * List Y"
07:58:53 <byorgey> FunctorSalad: why is that odd?
07:59:27 <vixey> [Y] = Either () (Y,[Y])
07:59:38 <vixey> [Y] = [] | Y:[Y]
08:00:10 <yitz> FunctorSalad: so in this case the projective limit?
08:00:21 <FunctorSalad> byorgey: seems like an implementation detail :)
08:00:36 <FunctorSalad> byorgey: I would have thought 'List Y' is just specified up to iso
08:00:50 <byorgey> well, you can do that too
08:00:55 <byorgey> that's what Haskell does
08:01:43 <byorgey> in Haskell the isomorphism is expressed by wrapping or unwrapping a constructor
08:02:16 <byorgey> this is exactly the distinction between "equirecursive" and "isorecursive" formulations of recursive types
08:02:19 <yitz> hmm, maybe it
08:02:22 <quicksilver> yitz: now List X is the following set
08:02:29 <yitz> hmm, maybe it's called direct limit
08:02:36 <yitz> yeah
08:02:45 <quicksilver> {(0,Nil),(1,(x,(0,Nil)),(1,(x,(1,(0,Nil)))....}
08:02:55 <quicksilver> where x represents a typical element of X
08:02:57 <quicksilver> try it out
08:03:08 <quicksilver> this really is a *fixed* point of \Y -> 1 + X x Y
08:03:15 <quicksilver> not just isomorphic too, it actually is.
08:03:28 <FunctorSalad> yitz: projective limit of the iteration you get by applying 1 + Y * _ over and over?
08:03:32 <FunctorSalad> sounds ok
08:03:44 <quicksilver> applying that transformation gives you a "new" (0,Nil) object
08:03:45 <FunctorSalad> quicksilver: yes
08:03:54 <quicksilver> and it "shuffles" all the other ones down a bit
08:04:04 <quicksilver> wrapping them in a new (1,(x,....)) wrapper
08:04:14 <quicksilver> it's honest-to-goodness fixed.
08:04:42 <quicksilver> FunctorSalad: Yes. But to some people's minds, the set theory is more "elementary" than the category theory.
08:05:01 <FunctorSalad> *nod*
08:05:10 <quicksilver> FunctorSalad: in particularly, almost all[*] interesting categorical statements are up to isomorphism rather than up to identity.
08:05:18 <quicksilver> [*] I don't care to make that more precise. It's fiddly.
08:05:45 <quicksilver> whereas yitz appeared to be interested in a precise existential characterisation of the fixed point.
08:05:51 <yitz> quicksilver: I think that statement is only true up to isomorphism.
08:06:01 <quicksilver> I think precision is helpful to see the difference between the least and greatest
08:06:05 <quicksilver> and see that they are, indeed, both unique.
08:06:06 <FunctorSalad> quicksilver: fiddly? I'd just say "those defined by a universal property" :)
08:06:14 <yitz> quicksilver: I'm interested in understanding what Conor et al mean by their notation.
08:06:33 <quicksilver> yitz: I know. I felt this line of explanation was helpful for you to see the different between least and greatest.
08:06:38 <Baughn> I'm having a little trouble finding real-life examples, so I thought I'd add - have any of you ever used virtual synchrony for anything?
08:06:42 <quicksilver> If it isn't then I apologise and will stop it ;)
08:07:00 <quicksilver> yitz: which statement do you think it only true up to isomorphism?
08:07:24 <yitz> quicksilver: so do they mean your concrete construction, or FunctorSalad's final element of a category, i.e., up to isomorphism?
08:07:47 <yitz> almost all[*] interesting categorical statements are up to isomorphism rather than up to identity.
08:07:58 <byorgey> yitz: which paper is this?
08:08:10 <Clockwork> is there a haskell function, which mirrors a string upside down?
08:08:11 <yitz> byorgey: the one that vixey linked above
08:08:28 <Baughn> Clockwork: "Upside down"? Can you give an example?
08:08:29 <vixey> http://www.cs.nott.ac.uk/~nxg/papers/fi04.ps.gz
08:08:36 <Clockwork> yep, just a moment
08:08:39 <quicksilver> yitz: oh I see. Yes ;)
08:08:52 <quicksilver> yitz: uniqueness is only true if you give a concrete construction.
08:09:06 <quicksilver> that's kind of needed for 'uniqueness' to have meaning.
08:09:16 <quicksilver> Once you've established that the l.f.p and g.f.p are indeed concretely unique
08:09:19 <yitz> quicksilver: so is that what they mean then?
08:09:40 <quicksilver> you can that start treating them as just up to isomorphism, because it no longer matters, because you know that concretely there is only one.
08:09:52 <byorgey> ooh, that paper looks fun!
08:09:54 <Clockwork> Baughn: Like this: http://hpaste.org/12628
08:10:03 <dons> yay, updated docs, http://www.reddit.com/r/programming/comments/7gw7p/heat_up_your_cores_with_data_parallel_haskell/
08:10:04 <lambdabot> dons: You have 12 new messages. '/msg lambdabot @messages' to read them.
08:10:06 <lambdabot> Title: Heat up your cores with Data Parallel Haskell! : programming, http://tinyurl.com/67cy2b
08:10:08 <Clockwork> my intention is, to give out a binary tree in haskell
08:10:19 <Baughn> Clockwork: Umh. SOmething like "unlines . reverse . lines"?
08:10:23 <byorgey> Clockwork: unlines . reverse . lines
08:10:46 <byorgey> > unlines . reverse . lines $ "a b c d e\n  f g h  \n   i   "
08:10:47 <lambdabot>   "   i   \n  f g h  \na b c d e\n"
08:10:48 <FunctorSalad> I thought he means upsidedown "p" == "b" ;)
08:10:53 <byorgey> hehehe
08:10:56 <Clockwork> :)
08:10:58 <byorgey> I thought so too at first
08:11:28 <quicksilver> yitz: so, in conclusion, there can't be any exotic sets in there.
08:11:35 * vixey is always getting stuck converting between syntaxes :/
08:11:38 <yitz> I think you can do it in unicode, for some subset of glyphs
08:11:39 <quicksilver> there really is a unique l.f.p and a unique g.f.p
08:11:54 <quicksilver> there was an upside-down utf8 hack in lambdabot for a while
08:12:01 <quicksilver> mauke: it might have been you?
08:12:22 <yitz> preflex: help
08:12:22 <preflex>  try 'help help' or see 'list' for available commands
08:12:27 <yitz> preflex: list
08:12:27 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
08:12:34 <quicksilver> yitz: in fact, that construction has precisely two fixed points in Set, the least and the greatest, and there are no other.
08:12:37 <quicksilver> although off hand I can't prove that.
08:12:55 <quicksilver> (lists - strictly finite) and (lists - including infinite)
08:12:59 <FunctorSalad> byorgey: does this distinction between 'equirecursive' and 'isorecursive' make a difference somewhere?
08:13:18 <FunctorSalad> (it seems unique iso would be all you need to actually do something with lists)
08:13:27 <byorgey> FunctorSalad: sure, the choice of which to use affects the metatheory + implementation techniques for a language
08:13:46 <byorgey> equirecursive is nicer for programmers but harder to implement.
08:13:55 <FunctorSalad> byorgey: yes, but I mean we don't have ZFC sets in actual computers anyway ;)
08:14:19 <byorgey> well, no, of course not =)
08:14:40 <FunctorSalad> for the metatheory I can see it
08:14:47 <yitz> quicksilver: well, can you prove that your "greatest" fp really is greatest?
08:15:14 <FunctorSalad> what is the ordering in the set theory setting?
08:15:20 <quicksilver> FunctorSalad: set union.
08:15:24 <quicksilver> well, set subset.
08:15:26 <byorgey> just normal subset.
08:15:28 <FunctorSalad> ah
08:15:43 <fasta> What's a good example library showing how Haskell values can be marshalled to C?
08:15:50 <quicksilver> it is only well defined because the property has the property that if A satisfies it and B satisfies it, then A u B satisfies it.
08:16:10 <quicksilver> yitz: Well we define the greatest in the way which makes it obvious it is.
08:16:23 <quicksilver> yitz: greatest FP = U { X : X is a fixed point }
08:16:36 <quicksilver> yitz: it is the union of all fixed points, so it is obviously the greatest ;)
08:16:48 <quicksilver> it remains to show that the greatest (defined that way) really is the one I claim it
08:16:52 <quicksilver> (infinite lists)
08:16:58 <FunctorSalad> that needn't be a set ;)
08:17:08 <FunctorSalad> <pointless nitpick>
08:17:12 <yitz> quicksilver: if you have done it that way, you first needed to find what all the fixed points are, so that begs the question
08:17:36 <quicksilver> well, depends what you mean by "needed".
08:17:44 <quicksilver> depends how happy you are with implicit descriptions of things.
08:17:49 <quicksilver> I claim that fixed points exist.
08:17:55 <quicksilver> I claim you can collect them all into a set (of sets)
08:18:04 <byorgey> > let swap (a,b) = (b,a); ls = (zip "aipqusow " "eidbnsom "); upsidedown = reverse . mapMaybe (flip lookup (ls ++ map swap ls)) in upsidedown "upside down"
08:18:05 <quicksilver> then I construct the union of that set of sets.
08:18:06 <lambdabot>   "umop apisdn"
08:18:24 <quicksilver> a classical mathematician would be quite happy with that, as a definition of a set.
08:18:34 <quicksilver> ...but of course it doesn't construct the set.
08:18:37 <chylli> what's the difference between 'otherwise' and '_' in 'case .. of ' ?
08:18:40 <quicksilver> We have to do more work to see what elements it has.
08:18:43 <FunctorSalad> quicksilver: but I think yitz's problem *is* that there may be fixed points of unbounded cardinality
08:19:01 <quicksilver> chylli: 'otherwise' is a mistake in that context
08:19:16 <quicksilver> chylli: which happens to work, syntactically, because it's defining a fresh variable.
08:19:18 <byorgey> chylli: 'otherwise' is a pattern which matches anything and binds it to 'otherwise'.
08:19:26 <FunctorSalad> quicksilver: then you wouldn't have a set of all fixed points
08:19:32 <chylli> quicksilver: oh, thanks.
08:19:34 <quicksilver> is it?
08:19:46 <quicksilver> yitz: are you trying to make a foundational point about universes of sets and proper classes?
08:19:49 <chylli> byorgey: thanks
08:19:49 <yitz> quicksilver: a classical mathematician uses Zorn's lemma all day long. Computer scientists generally don't.
08:20:03 <quicksilver> if you are, that isn't the point I thought you were making.
08:20:05 <orbitz> i asked this last night but most people seemed busy, so i'll throw it out again: is there anything fundamentally different abotu GCing in a language liek haskell than in java?  coudl it be described as easier?
08:20:27 <yitz> quicksilver: nah, we're starting to get a bit off topic now actually.
08:20:35 <FunctorSalad> :)
08:20:36 <quicksilver> right. I didn't think that was the point you were making.
08:20:57 <quicksilver> let's assume we are working bounded beneath some nice well-behaved ordinal like epsilon_0
08:21:11 <quicksilver> and I can freely use second order logic without risk of foundational collapse.
08:21:29 <yitz> sounds reasonable :)
08:22:00 <quicksilver> the kind of finitary constructions we make within type theory keep us safely under epsilon 0.
08:22:31 <quicksilver> then: the fixed points exist. The set of all fixed points exists and is genuinely a set. And I can take the union of it.
08:22:39 <quicksilver> so my greatest fixed point 'exists'.
08:22:45 <quicksilver> You just have to prove what it is.
08:23:18 <FunctorSalad> hmm, we have F(X) = 1 + A * X, right? that doesn't have F(X union X') = F(X) union F(X')
08:23:27 <orbitz> Any thoughts on Qi's type system?  I have heard it is supposed to be really cool.  I fin dit a bit weird that it's optional...
08:23:35 <quicksilver> FunctorSalad: that's not what I said.
08:23:55 <quicksilver> FunctorSalad: I said "X is a fixed point" and "X' is a fixed point" implies "X u X' is a fixed point"
08:24:02 <quicksilver> FunctorSalad: that's pretty obvious if you think about it.
08:24:09 <quicksilver> the union of two fixed points is still fixed.
08:24:12 <FunctorSalad> quicksilver: I thought my statement was how you were going to prove that
08:24:29 <quicksilver> all elements of X stay within X when you apply the transformation.
08:24:35 <quicksilver> all elements of X' stay within X'
08:24:59 <quicksilver> elements of (X u X') are either elements of X or elements of X', so th ey either stay within X or within X', and certainly within X u X'
08:25:02 <quicksilver> right?
08:25:10 <FunctorSalad> but F operates on sets, not elements
08:25:42 <quicksilver> No. F operates on elements.
08:25:44 <FunctorSalad> (I don't mean F(X) = image of X under F)
08:25:46 <quicksilver> X is a fixed point of F.
08:26:37 <quicksilver> looks like I broke yitz, anyway.
08:26:51 <quicksilver> I think this conversation has made enough noise here.
08:27:03 <quicksilver> orbitz: I don't know anythign fundamentally different.
08:27:20 <quicksilver> orbitz: the fact that objects are immutable is an interesting point
08:27:34 <quicksilver> orbitz: means you can cache more reachability info if you choose to.
08:28:06 <quicksilver> If anyone wishes to continue the sets/fixed points discussion I will happily do so in -blah
08:28:11 <quicksilver> ;)
08:28:27 <orbitz> is there any way to do a comparative benchmark between a java and haskell app in terms of gc?
08:29:05 <FunctorSalad> quicksilver: sorry if I drew it out needlessly, I'm feeling very sluggish today
08:29:34 <quicksilver> FunctorSalad: You didn't. I just noticed the 'haskell-related'/'non-haskell-related' ratio here and decided I had gone too far.
08:29:48 <quicksilver> FunctorSalad: foundational issues tend to require quite a lot of words to get straight.
08:30:05 <quicksilver> orbitz: you can try to design such a thing.
08:30:24 <quicksilver> orbitz: one or two of the shootout things were intended to benchmark GC.
08:30:32 <orbitz> okay
08:40:27 <dblazakis> anyone have a pointer to a good example of using hsc2hs for a binding?
08:44:41 <dcoutts> dblazakis: my zlib binding uses hsc2hs
08:45:19 <dblazakis> dcoutts:  ah, thanks perfect -- i was looking for something in hackage (i didn't look too hard before asking)
08:55:40 <Saizan> quicksilver: what do you mean by "F works on elements"?
08:56:21 <quicksilver> Saizan: yeah, I was thinking of it as a construction. That was a wrong thing to say.
08:56:45 <Saizan> ah, i see
08:56:50 <quicksilver> (I was thinking of it as a function with multipole results, aka a relation)
08:58:33 <Saizan> which relates elements of the set it's applied to elements of the result?
08:58:45 <Saizan> missing a "to"
09:00:20 * quicksilver nods.
09:00:38 <quicksilver> in the sense that "l" 'generates' all elements of the form x:l
09:00:51 <quicksilver> where "l" was some existing member and x is in X
09:03:57 <Saizan> x in A :)
09:04:31 <quicksilver> Saizan: I was doing \Y -> 1 + X x Y
09:04:40 <Saizan> ah, ok
09:06:18 <quicksilver> It took me a long time to believe that this construction was "really" a fixed point, and not just an isomorphism class, so I have sympathy with yitz's doubt.
09:07:21 <vixey> @free t :: a
09:07:21 <lambdabot> f t = t
09:07:45 <Saizan> i like to use tarski(?) theorem that says the least fixed point is F(..(F(_|_)) to see what it looks like
09:09:15 <quicksilver> Saizan: I was trying to avoid using the theorem, and actualy constructing the fixed points rather explicitly.
09:29:21 <vixey> @free t1 :: forall a. a
09:29:21 <lambdabot> f t1 = t1
09:29:25 <vixey> @free t1 :: forall a. forall b. a
09:29:26 <lambdabot> f t1 = t1
09:29:29 <vixey> @free t1 :: forall a. forall b. b
09:29:29 <lambdabot> f t1 = t1
09:30:02 <vixey> @free t1 :: forall a. forall b. a -> b
09:30:03 <lambdabot> g . t1 = t1 . f
09:30:08 <vixey> @free t1 :: forall b. forall a. a -> b
09:30:09 <lambdabot> f . t1 = t1 . g
09:31:01 <chrisdone> @free k :: x1 a1 b2 -> x1 a1 b2 -> k a1 a2
09:31:02 <lambdabot> Extra stuff at end of line
09:36:24 <chrisdone> @vixen would you like to play a game of chance?
09:36:25 <lambdabot> i might :)
09:40:58 <hackage> Uploaded to hackage: kibro 0.4.3
09:49:02 <vixey> this free theroem is sort of mind bending
09:49:34 <opqdonut> nah, proving propositional logic is easily automated
09:50:27 <lilac> @vixen what's the free theorem for map?
09:50:27 <lambdabot> i dunno, what is it?
09:50:58 <vixey> @free map
09:51:01 <opqdonut> well okay, free theorems is a bit more
09:51:01 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
09:51:09 <opqdonut> djinn is just proving
09:52:27 <liff> what's the new locale library that is not old-locale?
09:53:19 <vixey> opqdonut, propositionals is pretty hard though
09:55:08 <jeffersonheard> urm...  quick question: if I want to read a value inside Maybe, and the read returns a Maybe, can I just use "fmap read"?
09:55:19 <vixey> :t fmap read
09:55:21 <lambdabot> forall a (f :: * -> *). (Functor f, Read a) => f String -> f a
09:55:44 <aartist> help
09:55:57 <jeffersonheard> vixey, okay thanks.  I thought so, but it wasn't working inside GHCI
09:56:05 <aartist> I am new to haskell, where should i start?
09:56:06 <vixey> maybe youhave to import stuff
09:56:09 <jeffersonheard> probably because I was being insensible about using it
09:56:11 <jeffersonheard> yeah
09:56:14 <aartist> I like to know where I should learn it?
09:56:20 <aartist> ie.. WHy I should learn it.
09:56:32 <vixey> aartist, you should only learn it if you want to
09:57:09 <Feuerbach> ... or if you need to, obviously
09:57:12 <dons> ?users
09:57:12 <lambdabot> Maximum users seen in #haskell: 561, currently: 523 (93.2%), active: 16 (3.1%)
09:57:27 <aartist> I just feel that I don't want to be behind the time.
09:57:30 <dons> aartist: you want to write robust, concise, efficient software, than exploits your multicore.
09:57:48 <dons> faster than python, safe  then C, and easier to program parallel systems than all of  them.
09:58:06 * dons has an "elevator pitch"
09:58:07 <geezusfreeek> aartist, benefits of haskell include mind-expanding, easy parallelism, easy concurrency, safety, and peace of mind
09:58:17 <geezusfreeek> *mind-expansion
09:58:33 <aartist> geezusfreeek: Wow.. I like it.
09:58:34 <dons> aartist: make sure to visit haskell.org
09:58:40 <dons> it's the centre of the world for haskell stuff
09:58:47 <Nafai> Hi dons!
09:58:56 <jeffersonheard> and buy Real World Haskell after trying it online :-)
09:59:07 <jeffersonheard> at http://realworldhaskell.org/book
09:59:08 <aartist> I am actually learning lisp and came to know that haskell is better Function oritend language
09:59:21 <lambdabot> Title: Real World Haskell
09:59:30 <Nafai> Hey dons!
09:59:36 <dons> hey Nafai
09:59:40 <aartist> Which one i should prefer or I should learn haskell after learning lisp?
09:59:49 <geezusfreeek> aartist, well, haskell is purely functional if that is what you mean
09:59:49 <dons> aartist: yes, that's right. lisp is the grand father of haskell
09:59:51 <Nafai> dons: I was away from my computer all Thanksgiving break, so I haven't got a start on the Cairo/ghci thingy :)
09:59:54 <dons> haskell learns from the mistakes of lisp.
10:00:01 <jeffersonheard> I wouldn't learn lisp first
10:00:10 <geezusfreeek> i would learn lisp, but _after_ haskell
10:00:10 <jeffersonheard> I know lisp, but it didn't help
10:00:14 <jeffersonheard> at elast I don't think
10:00:14 <dons> no. its just an historical curiosity now, imo.
10:00:53 <vixey> yeah lisp is crap nobody in their right mind would use liisp..
10:01:02 <idnar> haha
10:01:20 <Valodim> emacs people would
10:01:21 * jeffersonheard is alone in the room a defender of lisp
10:01:21 <geezusfreeek> lisp is better than most imperative languages...
10:01:30 <roconnor> stupid dynamic variable binding nonsense
10:01:39 <mux> stupid prefix notation
10:01:42 * jeffersonheard and is even a vi person
10:01:43 <Nafai> I think it is useful to know lisp
10:01:43 <dons> vixey: well, i'm not sure i'd say that. just that its a fragmented thing, with little research being done on it.
10:01:43 <dons> and feels old.
10:01:43 <dons> heya jeffersonheard
10:01:47 <Nafai> Especially for Emacs :)
10:01:55 <jeffersonheard> hi dons :)
10:02:03 <vixey> dons you pretty much did :p
10:02:13 <aartist> Nafai: That's correct I am working on learning elisp for emacs
10:02:29 <aartist> I am interested in new programming paradigms.
10:02:52 <geezusfreeek> aartist, you might be interested in Yi (text editor extensible with Haskell), but it's still experimental as far as i know
10:02:54 <vixey> aartist, elisp is pretty horrible though
10:02:56 <jeffersonheard> I think it's useful to know lisp if you want to work on programming languages, because many of the ideas from lisp have been making it into the newer languages.
10:02:56 <Nafai> aartist: BUt for general-purpose programming, I think Haskell has a better chance of being pragmattic and long-lived
10:03:01 <geezusfreeek> you would want to learn haskell first
10:03:02 <vixey> aartist, pick up CL or Scheme
10:03:15 <Nafai> vixey: No denying that, but honestly it's the most practical lisp right now :)
10:03:30 <geezusfreeek> CL and Scheme are quite practical
10:03:31 <dons> ?users
10:03:31 <lambdabot> Maximum users seen in #haskell: 561, currently: 528 (94.1%), active: 22 (4.2%)
10:03:32 <vixey> Nafai, if you want to .. ? edit text files
10:03:34 <jeffersonheard> aartist: I agree with Vixey - Common Lisp, or download PLT Scheme from plt-scheme.org
10:03:34 <geezusfreeek> they just aren't Haskell ;)
10:03:44 <dons> also, we've got about 3x the community in one location. so you get more help.
10:03:56 <dons> and one agreed upon implementation, that's open source, and supports multicores.
10:04:05 <dons> with industrial backing. so live is sweet.
10:04:16 <mux> dons: what was the person to mail about DPH benchmarking?
10:04:19 <geezusfreeek> well, a defacto standard implementation, anyway
10:04:23 <dons> mux, rl and chak
10:04:32 <Nafai> vixey: That are some very useful applications in Emacs
10:05:06 <mux> dons: cheers (and for that url too)
10:05:35 <vixey> Nafai, SLIME is only a few lines away from an elisp ffi btw
10:05:45 <Nafai> vixey: True.
10:05:55 <Nafai> I wish there was a decent replacement for Emacs
10:06:25 <jeffersonheard> I wish elisp had sensible scoping rules
10:09:00 <dons> mux, no worries.
10:09:09 <RayNbow> @djinn (Not a,a) -> a
10:09:10 <lambdabot> f (a, b) = void (a b)
10:09:19 <RayNbow> what exactly is the definition of void?
10:09:32 <vixey> void :: Not a -> b
10:09:41 <jeffersonheard> oh, by the way, sorry, dcoutts if I've fallen down on compiling and testing the Haskell Platform on different platforms -- thanksgiving buried me, and my wife's starting a business right now.
10:09:49 <vixey> I guess haskell doesn't accept that so,
10:09:53 <vixey> void x = case x of
10:10:00 <vixey> and that's probably not accepted either..
10:10:49 <jeffersonheard> :t void
10:10:50 <lambdabot> Not in scope: `void'
10:10:57 <vixey> @djinn-env
10:10:58 <lambdabot> data () = ()
10:10:58 <lambdabot> data Either a b = Left a | Right b
10:10:58 <lambdabot> data Maybe a = Nothing | Just a
10:10:58 <lambdabot> data Bool = False | True
10:10:58 <lambdabot> data Void
10:11:00 <lambdabot> type Not x = x -> Void
10:11:02 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:11:04 <lambdabot> type Cont r a = (a -> r) -> r
10:11:20 <vixey> oh, I got the wrong type signature
10:12:16 <lilac> void :: forall b. Void -> b
10:12:25 <lilac> (i guess)
10:13:17 <RayNbow> hmm...
10:13:23 <lilac> so \b is saying "A and A implies anything, so it implies A"
10:14:13 <jeffersonheard> gah.  I keep getting stuck on this kind of thing...  There's an instance of Show for URI and no instance of Read
10:14:19 <jeffersonheard> much like DiffTime
10:14:33 <Saizan_> the point is that you can't construct a value of type Void
10:15:02 <Saizan_> so it's safe to write a void :: Void -> a, since you won't be able to call it
10:15:14 <RayNbow> ah
10:15:30 <newsham> > let motor go = go "vroom! " in motor cycle
10:15:32 <lilac> as vixey put it, "void x = case x of"
10:15:34 <lambdabot>   "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroo...
10:15:39 <Twey> Is that valid syntax, or magic?
10:15:44 <Twey> 'data Void;'
10:15:51 <newsham> (for functorsalad)
10:15:56 <FunctorSalad> hehe
10:15:56 <lilac> Twey: afair it's not haskell'98 but a ghc extension
10:16:00 <jeffersonheard> isn't htere supposed to be  an instance of read for every show, generally speaking
10:16:07 <jeffersonheard> newsham: lol
10:16:08 <Twey> Ah
10:16:13 <Twey> jeffersonheard: No
10:16:30 <Twey> If the data can't reasonably be reconstructed from its Show instance, then there shouldn't be a corresponding Read instance
10:16:31 <jeffersonheard> Twey: I understood that it was generally encouraged
10:16:37 <Twey> (e.g. file descriptors)
10:16:51 <Twey> It's best to make it reconstructable where possible, but if it isn't, then there shouldn't be a Read.
10:17:22 <FunctorSalad> but RULE read . show == id, if it is a Read?
10:17:24 <RayNbow> preflex: Saizan_++
10:17:28 <RayNbow> preflex: vixey++
10:18:29 <jeffersonheard> alright...  be clearer if there was a typeclass like Show called Print or some such that didn't imply Read
10:18:52 <jeffersonheard> but that's just me grumbling
10:20:14 <FunctorSalad> Twey: data Void; is -XEmptyDataDecls
10:20:44 <thoughtpolice> i wouldn't call empty data declarations a 'ghc' extension, just about every compiler out there (sans yhc I think) supports empty data decls
10:21:29 <thoughtpolice> (lhc, nhc, hugs too iirc)
10:22:00 <pk_> hey
10:22:22 <pk_> is there a way to give an operator a priority
10:22:24 <pk_> ?
10:22:36 <thoughtpolice> the infix keywords?
10:22:45 <geezusfreeek> you mean fixity?
10:22:50 <thoughtpolice> er, yeah
10:22:55 <nybyn> infixr <op> <priority>
10:22:57 <geezusfreeek> precedence?
10:23:00 <pk_> yep
10:23:35 <pk_> infixr means it's right assiciative ?
10:23:41 <geezusfreeek> infixr, infixl, (is there an "infix"?), etc.
10:23:42 <lilac> infixr <precedence> <op list>
10:23:43 <nybyn> yes, and there is also infixl
10:23:45 <geezusfreeek> yes
10:24:06 <pk_> ok thxd
10:24:13 <FunctorSalad> what's 'infix' then? automatic rewrite rule?
10:24:18 <geezusfreeek> pk_, you can find the default fixities in the haskell report somewhere
10:24:19 <jeffersonheard> is there a prefix fixity decl?
10:24:34 <jeffersonheard> for unary prefix operators like (-)
10:24:40 <geezusfreeek> FunctorSalad, i think it's just to say that there is no associativity, no?
10:24:40 <jeffersonheard> (not to be confused with (-)
10:24:47 <lilac> FunctorSalad: infix makes it an error for the associativity to be required :)
10:25:19 <FunctorSalad> geezusfreeek: lilac: ok, so the opposite of what I thought ;)
10:25:29 <FunctorSalad> @info (==)
10:25:30 <lambdabot> (==)
10:25:41 <FunctorSalad> @src (==)
10:25:42 <lambdabot> x == y = not (x /= y)
10:25:50 <FunctorSalad> that one would be infix I suppose?
10:26:00 <lilac> > True == False == True -- yep
10:26:02 <lambdabot>       precedence parsing error
10:26:02 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
10:28:12 <bwr> q
10:31:11 <FunctorSalad> btw, a trivial but neat feature would be if ghci had autocompletion and listing of modules in search path
10:31:26 <sw17ch> How goes the reactive library development?
10:31:30 <FunctorSalad> (it's annoying when you forget the exact name and have to go to the doc)
10:32:35 <lilac> sw17ch: i've fixed the bug which was causing resound to block (and also causing Peaker's block) but introduced a space leak :(
10:32:58 <lilac> sw17ch: fortunately, the space leak should be easily fixed. next step will be to get conal to push my patches :)
10:33:04 <sw17ch> lilac: is there any chance you guys have a rough guess about how much longer it will be until i can use it? :D
10:33:05 <jpcooper> are there any papers upon which the Reactive library is being developed?
10:33:11 <jpcooper> I haven't got the faintest idea of what it is about
10:34:04 <sw17ch> lilac: i'm going to branch my pre-release version of scurry (my Haskell VPN system) and move it to a reactive model to see what it's like
10:34:07 <lilac> sw17ch: ask conal. but it's basically usable now, if you don't mind getting your hands a little dirty :)
10:34:24 <FunctorSalad> jpcooper: *nod*, a concise overview would be cool
10:34:27 <sw17ch> lilac: i don't mind dirt at all...
10:34:32 <conal> lilac: are you working on a space-tight snapshot?
10:34:37 <lilac> conal: yep
10:34:39 * sw17ch printed out some one's paper a while ago... i can't rmember who's
10:34:45 <conal> lilac: thx :)
10:34:52 <sw17ch> and it's at home on my desk... so i can't look it up quickly
10:34:55 <pk_> how do I import prelude with only Lists ?
10:34:56 <lilac> conal: well, i was last night. i think it's straightforward.
10:35:09 <conal> lilac: hopefully it'll also fix recursive snapshotting, which enables natural descriptions of physical systems.
10:35:24 <conal> lilac: cool.  you'll be a hero in Reactive land. :)
10:35:49 <lilac> conal: the basic idea is to make the time for the resulting event be the max of the events on the Behaviour, and combine in the real time at the last minute
10:36:34 * conal scratches his head
10:36:43 <lilac> that should give usable bounds on it, and walk along the behaviour as transitions occur
10:37:04 <conal> i think i get the flavor
10:37:38 <lilac> basically, demanding the time of the resultant event needs to force the recursion down the behaviour to happen
10:37:48 <FunctorSalad> pk_: import Prelude(); import Data.List -- that?
10:37:52 <sw17ch> lilac, conal: does the reactive model work well with a system with a bunch of IO based socket/handle reads and a bunch of IO based socket/handle writes?
10:38:02 <FunctorSalad> maybe also -XNoImplicitPrelude
10:38:05 <sw17ch> i think my program is *exactly* waht reactive would work well with
10:38:13 <conal> lilac: sounds good.
10:38:18 <FunctorSalad> not sure if that's needed if you do "import Prelude()"
10:39:20 <conal> sw17ch: IO stuff gets wrapped/hidden in what i call "legacy adapters", where legacy == imperative.
10:39:33 <conal> sw17ch: and the FRP (Reactive) part is purely functional.
10:39:48 <sw17ch> conal: is there a way to convert IO bound operations to FRP?
10:39:57 <geezusfreeek> i hate writing adapters
10:40:24 <conal> sw17ch: "IO bound operations"?
10:40:46 <sw17ch> conal: hGet hPut... Network.Socket.recv... etc
10:40:59 <hackage> Uploaded to hackage: AERN-Net 0.2.0
10:41:00 <geezusfreeek> blocking?
10:41:13 <conal> sw17ch: you have to change the way you think.  from imperative to functional.
10:41:38 <sw17ch> geezusfreeek: yes, blocking
10:41:41 <sw17ch> conal: i'm more than willing
10:41:53 <sw17ch> right now it's the only bit of blocking code in the entire application
10:41:55 <conal> sw17ch: cool.  then yes.
10:41:56 <geezusfreeek> frp has facilities for such things
10:41:57 <pk_> Functor, thx
10:42:11 <sw17ch> everything else uses TChans for synchronization
10:42:44 <geezusfreeek> oh this is an existing app? it would probably be easier to rewrite it in frp than to convert it to frp
10:42:53 <conal> sw17ch: i expect the bigger change will be from imperative (IO) to functional, and the blocking/non-blocking will be smaller.
10:43:20 <geezusfreeek> the blocking/nonblocking should ideally be nearly transparent, i would think
10:43:27 <sw17ch> geezusfreeek: yes, it is existing.
10:43:35 <conal> geezusfreeek: definitely
10:44:07 <sw17ch> the program consists of several (8 i think) threads which have a singular purpose
10:44:21 <sw17ch> they take an input from at least one TChan and produce an output on another
10:44:32 <sw17ch> and then go and wait for input again
10:44:43 <sw17ch> the only exceptions are the IO handlers
10:44:51 <sw17ch> which read sockets/handles and write socket/handles
10:45:05 <sw17ch> and feed/drain the TChan's
10:45:13 <sw17ch> so, fairly typical stuff
10:45:29 <conal> sw17ch: is there a non-trivial purely functional core?
10:46:04 <sw17ch> i'd consider most of the threads trivial
10:46:14 <sw17ch> if you group them all together, and how the interact, it becomes non-trivial
10:46:30 <sw17ch> individually, simple, together, they are harder to reason about
10:46:44 <sw17ch> most of it is pure
10:46:48 <sw17ch> (i think)
10:46:49 <conal> sw17ch: yes, because imperative programming doesn't compose tractably
10:47:01 <sw17ch> yes
10:47:12 <conal> and imperative *concurrent* programming is exponentially complicated
10:47:28 <conal> literally, if you look at the semantics.
10:47:28 <sw17ch> does the use of the TChan's make it imperative?
10:47:46 <conal> sw17ch: IO makes it imperative.
10:47:51 <conal> or STM
10:48:01 <sw17ch> yeah, i'm using lots of STM
10:48:16 <conal> oh, *that* TChan
10:48:19 <geezusfreeek> conal, that reminds me... as i see it, it's a good idea to separate pure code from frp code, just like separating pure code from the IO monad, but i seem to have more difficulty doing so with frp so far. have you any idioms or techniques built up in your mind about that, or do you even think i'm on the right track there?
10:48:19 <sw17ch> :)
10:48:21 <conal> yes -- imperative.
10:48:43 <conal> geezusfreeek: i don't understand.  frp code is pure code.
10:48:55 <conal> geezusfreeek: just like list code or tree code is pure code
10:49:15 <geezusfreeek> yes it is, but it seems to me that it wants to creep into my algorithms in addition to my overall program structure
10:49:44 <conal> geezusfreeek: any differently from lists, trees, maps, etc creep into your algorithms?
10:50:03 <conal> frp is like lists.  another data type with a simple semantics.
10:50:18 <conal> and unlike IO, which has no tractable semantics.
10:50:30 <geezusfreeek> somewhat. it feels like frp introduces another language into the mix which has the full expressibility of haskell already
10:50:32 <conal> when i say "pure" i mean simple (denotational) semantics.
10:51:34 <FunctorSalad> what's the relationship between frp and user interface? sorry, naive question
10:51:47 <conal> geezusfreeek: i wonder if by "frp", you mean more than i mean.  i mean the data types.
10:52:02 <conal> geezusfreeek: behavior & event.  maybe you mean also a whole programming style.
10:52:07 <geezusfreeek> i mean the paradigm, yes
10:52:12 <conal> geezusfreeek: which would make it be more like a "language"
10:52:16 <conal> oh, okay.
10:52:25 * conal is less confused now
10:52:32 <FunctorSalad> e.g., would you use frp to describe the details of a widget, or would you have a widget that takes in a complex data structure, and then feed that input event to reactive
10:52:38 * sw17ch decideds to wait on implementing Reactive for his program
10:52:41 <FunctorSalad> (or both :))
10:53:03 <conal> FunctorSalad: i'd use frp from the ground up.
10:53:28 <vixey> is there any list of reactive programs?
10:53:35 <vixey> I saw that tetris game before..
10:53:42 <conal> FunctorSalad: see "Genuinely Functional User Interfaces" for an early vision.
10:53:50 <geezusfreeek> vixey, do you mean reactive or do you mean Reactive?
10:53:53 <conal> FunctorSalad: http://www.apocalypse.org/pub/u/antony/work/pubs/genuinely-functional-guis.pdf
10:53:58 <lambdabot> Title: Genuinely Functional User Interfaces, http://tinyurl.com/296be3
10:54:01 <FunctorSalad> conal: I'll take a look :)
10:54:02 <geezusfreeek> either way, there is not a list that i know of
10:54:24 <conal> FunctorSalad: do.  and try to keep the vision & detail separate.
10:54:32 <conal> FunctorSalad: also check out Phooey & TV
10:54:34 <conal> @wiki phooey
10:54:35 <lambdabot> http://www.haskell.org/haskellwiki/phooey
10:54:38 <conal> @wiki TV
10:54:38 <lambdabot> http://www.haskell.org/haskellwiki/TV
10:55:06 <geezusfreeek> conal, now that you understand what i meant, do you have any thoughts on it?
10:55:22 <conal> geezusfreeek: oh, yeah.  re-reading above.
10:56:15 <conal> geezusfreeek: yes i do.  the list data type strongly influences how we program.  even finite lists, but especially infinite ones.
10:56:28 <conal> geezusfreeek: i see frp the same way.
10:56:50 <geezusfreeek> right, as a control structure
10:57:12 <vixey> does frp have fold and build?
10:57:33 <conal> geezusfreeek: in my thinking, FP doesn't have control structures, because it doesn't have control.
10:57:39 <geezusfreeek> vixey, my Event type could be made an instance of Foldable if i wanted, although i don't think i do
10:57:59 <geezusfreeek> conal, only in the same sense that a lazy list is a control structure
10:58:00 <vixey> @src Foldable
10:58:00 <lambdabot> Source not found. Sorry.
10:58:07 <conal> vixey: it has folds and scans.  not sure if it has a build counterpart.
10:58:35 <conal> geezusfreeek: yeah, i understand.  i'd call lazy lists a *replacement* for control structures.
10:58:49 <conal> and FP as a replacement for control in general
10:59:13 <geezusfreeek> the way i describe it is that lazy structures are usually control and strict structure are usually data
10:59:35 <erikc> FRP has always struck me as a software version of control systems and circuits
10:59:39 <erikc> maybe thats a naive view
10:59:39 <conal> geezusfreeek: s/is/replace/ and i agree
11:00:03 <geezusfreeek> s/replace/is analgous to/ ?
11:00:06 <conal> erikc: i like naive views.  they can get to the essence of things.
11:00:25 <skorpan> anal goose!
11:00:25 <geezusfreeek> *analgous
11:00:28 <conal> geezusfreeek: no.  in my perspective, they replace
11:00:30 <geezusfreeek> grr can't type
11:00:40 <geezusfreeek> i do know how to spell it i promise
11:01:01 <skorpan> ispell for you, my friend
11:01:28 <mapreduce> anal goose?
11:01:29 <geezusfreeek> i think we are just working with different definitions of "control" is all. yours may very well be more correct, as i don't think i have ever looked up a formal definition
11:02:23 <conal> geezusfreeek: definitions aside, i think there's a basic philosophical difference.  one can view programming languages as about controling computers.  one can also view computers as helping us to see meanings of expressions.
11:02:39 <mmorrow> :)
11:02:52 <conal> i suspect your "control structure" terminology reflects a leaning toward the former.
11:03:10 <geezusfreeek> conal, it does. it places some emphasis on evaluation order
11:03:12 <conal> and my "replaces control structures" reflects a leaning toward the latter.
11:03:20 <conal> geezusfreeek: yeah.
11:03:45 <jaj> hi
11:03:46 <lambdabot> jaj: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:04:45 <jaj> I already read those...
11:05:06 <erikc> frp principles are applied in a lot of the latest video game engine design (often unwittingly)
11:05:30 * conal is in bliss, hearing satchmo singing 'mack the knife'
11:09:23 <sw17ch> conal: is there an example application for Reactive out there somewhere?
11:10:19 <conal> sw17ch: examples are coming together organically.  it's in an early stage.  you can get on the mailing list and follow along.
11:10:26 <conal> @wiki Reactive
11:10:27 <lambdabot> http://www.haskell.org/haskellwiki/Reactive
11:10:42 <sw17ch> oh no... more mailling lists
11:10:45 <conal> sw17ch: see also FieldTrip and reactive-fieldtrip.
11:10:49 <conal> @wiki FieldTrip
11:10:49 <lambdabot> http://www.haskell.org/haskellwiki/FieldTrip
11:11:20 <conal> sw17ch: you could also wait until it comes together more.
11:11:41 <conal> performance, robustness, tutorials, ...
11:12:13 <sw17ch> :)
11:12:42 <conal> it's in a sort of hobbyist stage
11:12:49 <mib_t7f209> Hi, what is {- .... -}
11:13:05 <mauke> a comment
11:13:12 <mib_t7f209> Ooh, ok
11:18:13 <conal> geezusfreeek: an afterthought on your questions about frp as a paradigm.  i'd distinguish types like lists from frp, in that i see frp as a fundamental replacement to the imperative perspective on change & time.
11:24:14 <sw17ch> conal: since it's not easy to dicipher from the reactive package, what is/are the fundamental Reactive type(s)?
11:24:51 <conal> sw17ch: depends on how you want to look.  one view is Behavior & Event
11:25:02 <conal> sw17ch: if you look deeper, you'll find Future and Reactive
11:25:25 <sw17ch> conal: are those the actual names? i feel like looking at the implementation would be an easier way for me to comprehend what's going on
11:25:32 <conal> yes
11:25:37 <sw17ch> excellent
11:26:02 <conal> sw17ch: and each one has generalized versions which you'll see in most of the signatures.  EventG, FutureG, ...
11:26:21 <conal> because the types are polymorphic over both time and values
11:27:09 <sw17ch> nifty
11:28:22 <conal> when designing Reactive, i added the temporal polymorphism because i was curious to learn exactly what properties of "time" are required where and why.
11:32:51 <sw17ch> conal: i'm sure you'll find some interesting stuff there...
11:33:04 <sw17ch> in my case, i'm not so concerned about time unless i can redefine time
11:33:49 <sw17ch> time's new definition being based on the number of input's i've received into the program
11:34:02 <romildo> Hi.
11:34:20 <romildo> Regarding gtk2hs, is it possible to put two TextField in a HBox, and give them different sizes (for instance, one is twice the width of the other), and have them expand/shrink with the HBox, while keeping their width ratio?
11:34:52 <sw17ch> romildo: isn't that a more general GTK question?
11:35:03 <conal> sw17ch: i think you could.
11:35:15 <sw17ch> romildo: honestly, i've only ever done gtk2 stuff in the context of Glade
11:35:36 <geezusfreeek> i've noticed that Behavior seems a bit more up-for-interpretation in my implementation since my other data types don't deal directly with temporal information
11:42:33 <AnalogHole> Question, when you are writing an instance of Applicative,  do you actually pass it through the "laws" (i.e. Identity, Composition, Homomorphism, Interchange )to ensure that it is valid? Or is it just kind of an intuitive feeling that it looks correct?   I can't imagine running my code through proofs like that.
11:43:02 <vixey> @src Applicative
11:43:03 <lambdabot> class Functor f => Applicative f where
11:43:03 <lambdabot>     pure  :: a -> f a
11:43:03 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
11:44:36 <AnalogHole> Well, I'm looking at this: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Definition for teh 5 "laws"
11:44:39 <lambdabot> http://tinyurl.com/4sgomr
11:45:43 <conal> AnalogHole: i usually don't do those proofs.  Sometimes the laws follow simply because I have a specific semantic model that is already known to satisfy the laws, and I show that my instances agree with those of the model.
11:46:19 <conal> AnalogHole: as an alternative to proof, you can use the checkers package, which includes class laws.
11:46:23 <conal> @wiki checkers
11:46:23 <lambdabot> http://www.haskell.org/haskellwiki/checkers
11:49:28 <arussel> what is wrong with: safetail xs = if xs == [] then [] else tail xs ?
11:49:47 <mauke> xs might not implement ==
11:49:55 <BrokenClockwork> hey, I have already asked this, how do I get my emacs to the same color scheme of the "Learn You A Haskell" Tutorial?
11:49:57 <C-Keen> you need Eq
11:50:04 <mauke> safetail = drop 1
11:50:17 <arussel> mauke: but before I wrote: safetail :: [a] -> [a]
11:50:36 <C-Keen> arussel: safetail :: Eq a => [a] -> [a]
11:50:59 <mauke> arussel: that's precisely the problem
11:51:03 <C-Keen> arussel: but using drop is more general
11:52:42 <arussel> so even if it knows xs is an array, I have to say that xs must implement ==. Doesn't all array implements == ?
11:52:55 <mauke> xs is never an array, always a list
11:53:09 <mauke> and no, lists only have == if their elements do
11:53:17 <vixey> safetail (x:xs) = xs
11:53:17 <mauke> e.g. functions can't be compared
11:53:35 <arussel> mauke: got it
11:53:48 <arussel> mauke, C-Keen: thanks for your help
11:54:12 <orbitz> does list require its elemetn sto have == or is that part of the type signature for ==?
11:54:40 <C-Keen> > let safetail (x:xs) = xs; safetail []
11:54:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:54:43 <skorpan> it doesn't
11:54:51 <skorpan> i think that would be Eq
11:55:04 <mauke> there's this definition somewhere: instance (Eq a) => Eq [a] where { ... }
11:55:05 <orbitz> C-Keen: 'in'
11:55:31 <mauke> so if you want to use methods from Eq on lists, the elements have to be in Eq too
11:55:36 <orbitz> right
11:55:42 <jeffersonheard> got my copy of real world haskell today...
11:55:47 <orbitz> jeffersonheard: awesome
11:56:14 <C-Keen> > let safetail (x:xs) = xs in safetail []
11:56:15 <lambdabot>   * Exception: /tmp/978434096832341770:71:36-55: Non-exhaustive patterns in f...
11:56:23 <C-Keen> as I thought
11:56:27 <C-Keen> orbitz: thanks
11:56:27 <jeffersonheard> yeah..  will be exited to go through the chapters on HDBC and STM...  both will come in useful soon
11:56:35 <mauke> > let safetail (_:xs) = xs; safetail _ = [] in safetail ""
11:56:36 <lambdabot>   ""
11:56:48 <dblazakis> BrokenClockwork, try asking BONUS?
11:57:05 <vixey> unsafePerformTail (x:xs) = xs
11:57:22 <Deewiant> unsafePerformTail = tail
11:57:29 <C-Keen> heh
11:57:41 <BrokenClockwork> dblazakis: good idea
11:58:27 <vixey> how to understand the free theorems :/
11:58:34 <BrokenClockwork> BONUS: Hey, I want to get an haskell editor, with the same color scheme you used for your "Learn You A Haskell Tutorial, what do you advice me? Someone told me already about an extra package for Emacs, dunno... :)
11:58:55 <conal> what tools do people like for editing category theory diagrams?
11:59:16 <vixey> inkscape
11:59:33 <vixey> not that I actually drew _category theorey_ diagrams
11:59:34 <C-Keen> graphviz
11:59:43 <mauke> heh, the colors are in javascript
11:59:44 <C-Keen> or pic(1)
11:59:47 <mauke> that's why I couldn't see them!
12:00:07 <int-e> hmm\usepackage{xymatrix}
12:00:11 <conal> anyone played with the "Dia diagram editor"?
12:00:21 <C-Keen> conal: worse than xfig imho
12:00:42 <int-e> conal: played, yes. I didn't like it.
12:00:46 <arussel> conal: *very* basic
12:01:17 <conal> oh, okay.  i wonder if i just hadn't found Dia's good stuff.
12:01:27 <BrokenClockwork> BONUS doesn't respond *whine*
12:04:00 <mauke> hmm, looks a bit like inkpot, but not quite
12:08:16 <jeffersonheard> Somebody on here tell me to be sensible and not get into a discussion with ESR on why static typing isn't a stupid idea...
12:09:27 <arussel> 'discussion with ESR' didn't know that was possible.
12:09:28 <Deewiant> jeffersonheard: Be sensible and don't get into a discussion about static typing; instead, update FTGL with the fixes for the bugs I complained about over two months ago ;-)
12:09:41 <jeffersonheard> Right.  Thanks Deewiant
12:09:49 <jeffersonheard> I have those starred in my GMail...
12:09:54 <jeffersonheard> Is about time
12:09:58 <jeffersonheard> I'll do it before I leave today
12:10:22 <Deewiant> Great :-)
12:10:40 <BrokenClockwork> If there's a list of lists [[a]], how can I call a funnction with the argument [a] ? so just one list of the list
12:11:02 <C-Keen> BrokenClockwork: you take an element of [[a]]
12:11:15 <BrokenClockwork> ah right, okay :)
12:11:25 <C-Keen> BrokenClockwork: you can substitute [[a]] with [a] and [a] with a and then you see it :)
12:11:26 <BrokenClockwork> for instance head a I guess
12:11:47 <mauke> yes, if your list isn't empty
12:12:28 <BrokenClockwork> ye
12:13:20 <jeffersonheard> Oh, Deewiant, maybe you can help, btw.  I've been using FTGL textured and buffered fonts lately, and I'm having trouble mixing FTGL with other OpenGL that uses texturing.  I keep getting white rectangles where text should be
12:13:35 <conal> how might i find greek characters and other mathy symbols for use in Inkscape?
12:13:44 <jeffersonheard> arussel, it isn't possible
12:13:59 <jeffersonheard> that's why I was asking that someone tell me not to, because he just tried to start an argument with me
12:14:24 <FunctorSalad> conal: just type in a unicode font?
12:14:40 <FunctorSalad> conal: alternatively, Render -> Latex (or similar)
12:14:42 <jeffersonheard> conal: Lucida and Bitstream are both unicode fonts, I believe
12:14:54 <jeffersonheard> or yeah - Render -> Latex workse
12:15:00 <Deewiant> jeffersonheard: I'm afraid I don't really know much about OpenGL, I've just dabbled
12:15:11 <conal> once i'm in a unicode font, how might i type greek chars?
12:15:13 <FunctorSalad> jeffersonheard: iirc DejaVu is Bitstream with extra symbols?
12:15:25 <Deewiant> FunctorSalad: yep
12:15:26 <FunctorSalad> conal: scim, on linux
12:15:36 <FunctorSalad> Arev Sans also has lots of math symbols
12:15:46 <vixey> ቃ
12:15:56 <jeffersonheard> FunctorSAlad, I think so, yes
12:15:59 <vixey> conal, Control-Shift-u <code> <space>
12:16:37 <conal> vixey: typed into what?
12:16:46 <conal> vixey: and what are codes there?
12:16:55 <vixey> 㐥
12:16:56 <conal> FunctorSalad: i'll check out scim, thx.
12:17:16 <vixey> 㑒 <-- Control-Shift-U 3425 <space>
12:17:25 <FunctorSalad> conal: yet another way is emacs, Alt-X set-input-method, tex
12:17:35 <FunctorSalad> then you can type stuff like \alpha
12:18:10 <conal> FunctorSalad: wow!  i use emacs all the time.  i'm glad to know that trick.
12:18:31 <cjb> hey, I didn't know that either
12:18:45 * cjb uses set-input-method ucs, and then types e.g. u3425 <space>
12:19:03 <conal> α → β
12:19:08 <conal> did it work?
12:19:10 <vixey> yes
12:19:21 <mauke> U+03B1 (ce b1): GREEK SMALL LETTER ALPHA [α]; U+2192 (e2 86 92): RIGHTWARDS ARROW [→]; U+03B2 (ce b2): GREEK SMALL LETTER BETA [β]
12:19:35 <vixey> preflex ununicode α → β
12:19:44 <mauke> no.
12:19:45 <conal> awesome.  i guess i have to change my font in emacs to see it.  i use ERC (IRC via emacs).
12:20:06 <vixey> conal, I got unicode working by getting emacs-snapshot-gtk
12:20:09 <mauke> vixey: this functionality is in perl
12:20:16 <mauke> no easy way to integrate it into preflex
12:20:18 <vixey> conal, not sure if that is the best thing ..
12:20:21 <conal> vixey: oh, yeah.  i've been meaning to make that switch.
12:20:23 <mmorrow> , fmap (utf8enc . (:[])) "α→β"
12:20:31 <conal> vixey: any problems with gtk emacs?
12:20:32 <lunabot>  ["\206\177","\226\134\146","\206\178"]
12:20:37 <BrokenClockwork> I don't get, if I want to foldl a list of lists, with length, but with the wish to add each length to the next, this doesn not work out for me: foldl length [[1,2],[3,4,5],[6,7,8,9]] ... also not foldl sum(length) [[1,2],[3,4,5],[6,7,8,9]]
12:20:38 <vixey> no
12:20:59 <mauke> BrokenClockwork: you can't just make shit up
12:20:59 <conal> hey – i was going for alpha -> beta.  got junk on http://tunes.org/~nef/logs/haskell/08.12.02
12:21:17 <Deewiant> > foldl (flip $ (+) . length) 0 [[1,2],[3,4,5],[6,7,8,9]]
12:21:19 <lambdabot>   9
12:21:19 <mauke> > foldl (\z x -> z + length x) 0 [[1,2],[3,4,5],[6,7,8,9]]
12:21:21 <lambdabot>   9
12:21:37 <mauke> > sum (map length [[1,2],[3,4,5],[6,7,8,9]])
12:21:39 <lambdabot>   9
12:21:46 <conal> or did greek show up in the #haskell log and i'm not seeing it in firefox
12:21:49 <conal> hm.
12:22:02 <mmorrow> i think that's it
12:22:07 <BrokenClockwork> yeah I used map before but for some reason my tutor said, foldl will make this task more elegant...
12:22:10 <conal> hrmf.
12:22:24 <mmorrow> is view->character encoding->utf8 set?
12:22:38 <mmorrow> it's not set for me my default annoyingly
12:22:43 <mmorrow> s/my/by/
12:22:54 <conal> mmorrow: that fixed it.  thanks!!
12:22:56 <FunctorSalad> conal: I'm using emacs-snapshot like vixey
12:23:02 <mmorrow> conal: cool :)
12:23:06 <FunctorSalad> I think utf-8 is default there
12:23:14 <FunctorSalad> or maybe I set it :)
12:24:07 <mmorrow> @pl \a b -> a + length b
12:24:07 <lambdabot> (. length) . (+)
12:24:26 <mmorrow> , foldl ((. length) . (+)) [[1,2],[3,4,5],[6,7,8,9]]
12:24:28 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
12:24:30 <FunctorSalad> the tex input method is annoying for haskell though because -- is made into a long dash
12:24:33 <mmorrow> , foldl ((. length) . (+)) 0 [[1,2],[3,4,5],[6,7,8,9]]
12:24:36 <lunabot>  9
12:24:48 <BrokenClockwork> oh...
12:25:01 <mmorrow> , foldl (\a b -> a + length b) 0 [[1,2],[3,4,5],[6,7,8,9]]
12:25:05 <lunabot>  9
12:25:23 <mmorrow> ah, looks like this was already said above..
12:25:25 <vixey> , (length . concat) [[]]
12:25:27 <FunctorSalad> foldl more elegant than map? :o for me foldl is a last resort
12:25:27 <lunabot>  0
12:25:29 <vixey> , (length . concat) [[[]]]
12:25:31 <vixey> , (length . concat) [[[[]]]]
12:25:31 <lunabot>  1
12:25:33 <lunabot>  1
12:25:54 <mmorrow> FunctorSalad: foldl is strictly more powerful than map
12:26:04 <FunctorSalad> mmorrow: sure
12:26:21 <FunctorSalad> but the more general, the less you and the compiler can reason about it
12:26:30 <FunctorSalad> hence the stack overflow mess
12:26:47 <mauke> > map (* 2) [0 ..]
12:26:47 <mauke> , map (* 2) [0 ..]
12:26:48 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
12:26:49 <lunabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50...
12:27:18 <mauke> arghl
12:27:18 <mmorrow> but the stack overflows are a result of using foldl/r when foldr/l should've been used
12:27:35 <Deewiant> /l'
12:27:39 <mib_t7f209> merge :: Num a => (Int -> Int -> Bool) -> [a] -> [a] -> [a]        -- I wish to restrict the "a"s here to all be numbers, why is this not correct?
12:28:08 <Deewiant> you probably also want 'a' instead of 'Int'
12:28:35 <FunctorSalad> mmorrow: I still think "more general" is not necessarily "better" :)
12:28:52 <mib_t7f209> Deewiant: True (albeit apparently irrelevant from the problem), thanks for the heads up  :)
12:28:53 <mmorrow> anyways, i don't think map and foldl are even comparable because map can't eg sum a list
12:28:59 <FunctorSalad> predicate logic is more powerful than prop. logic, but if you need to decide a formula...
12:29:33 <mmorrow> but if you need to do something not possible in prop logic then you have only one option
12:29:48 <mmorrow> well, more than one i guess ;)
12:29:48 <FunctorSalad> mmorrow: yes. I was thinking of cases where map is in fact sufficient
12:29:49 <Deewiant> mib_t7f209: I figured that if you're getting a type error that might have been the cause
12:30:11 <mmorrow> FunctorSalad: oh, yeah in those cases i'd use map :)
12:30:14 <mib_t7f209> Deewiant: the actual error is "Inferred type is not general enough"
12:30:17 <Deewiant> mib_t7f209: Otherwise, that type signature is correct and does what you want.
12:30:33 <Deewiant> mib_t7f209: That means that the code is somehow restricting the type.
12:30:41 <Deewiant> Beyond your Num a => a.
12:30:58 <pk> ($) = id ?
12:31:03 <Deewiant> Yep
12:31:13 <pk> cool
12:31:20 <mib_t7f209> Deewiant: one candidate that could restrict is my use of the <= operator - but surely all of Num support this?
12:31:37 <mornfall> Anyone has an idea how to encode list [x] as Int -> x, where linear traversal would be O(n) (as opposed to O(n^2) for the naive use of !!)?
12:31:40 <Deewiant> ?src Num
12:31:41 <lambdabot> class  (Eq a, Show a) => Num a  where
12:31:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:31:41 <lambdabot>     negate, abs, signum     :: a -> a
12:31:42 <lambdabot>     fromInteger             :: Integer -> a
12:31:47 <Deewiant> Evidently not
12:31:52 <mib_t7f209> Ooh..
12:32:43 <vixey> mornfall, Int -> Maybe x
12:32:52 <mornfall> vixey: Well yeah.
12:33:05 <mornfall> That's not the important bit. : - )
12:33:07 <vixey> mornfall, or Fin 5 -> x for Vector 5 x
12:33:35 <mmorrow> mornfall: how do you mean? like encoding it so that you could map over a list in arbitrary order?
12:33:42 <mib_t7f209> ?src Eq
12:33:42 <lambdabot> class  Eq a  where
12:33:42 <lambdabot>     (==), (/=)   :: a -> a -> Bool
12:34:00 <mmorrow> if so, i think the best you could do would be O (n lg n)
12:34:05 <mornfall> mmorrow: No, the point is that I need to export the list through the FFI, efficiently *and* lazily.
12:34:14 <Twey> Isn't (!!) O(n)?
12:34:22 <mornfall> mmorrow: It keeps the order and I only want to traverse it once.
12:34:26 <mornfall> Maybe I am solving it in a wrong way.
12:34:30 <mmorrow> hmm
12:34:36 <Deewiant> Twey: n uses of it are O(n^2), I think that's what was meant
12:34:39 <Twey> func = (someList !!)
12:34:42 <mmorrow> Twey: that's to access a single element though..
12:34:46 <Twey> Ah
12:35:02 <Deewiant> mornfall: What you want is an array, no?
12:35:15 <mornfall> Deewiant: A lazy one, maybe...
12:35:29 <mornfall> But it feels like there should be an easier way.
12:35:43 <mib_t7f209> Deewiant: what would be an appropriate class that encompasses all datatypes which support <= ?
12:35:53 <Deewiant> ?ty (<=)
12:35:55 <lambdabot> forall a. (Ord a) => a -> a -> Bool
12:36:07 <Twey> mib_t7f209: Ord
12:36:13 <mornfall> Or maybe better, not easier.
12:36:34 <mmorrow> zipWith (\i x -> unsafePerformIO (pokeOff i x))    -- ? ;)
12:36:51 <Twey> Does anybody else still, after ten years of programming, occasionally balk at <= thinking it some weird arrow operator?
12:36:53 <mmorrow> hmm, that would most surely cause bad things to occur
12:37:04 <mmorrow> well, i guess it depends on the use-case
12:37:14 <mornfall> mmorrow: I unfortunately need it to be pure, or at least appear like that, in a multi-threaded program.
12:37:21 <vixey> Int -> Maybe x is an array
12:37:49 <FunctorSalad> vixey: with unbounded time for finding the first element ;)
12:38:10 <mmorrow> mornfall: if you only write to a ptr once that'll still be pure..
12:39:26 <mornfall> Hmh.
12:39:27 <mmorrow> and unsafePerformIO may be the only way to do that
12:39:37 <mmorrow> s/unsafe//
12:39:43 <mmorrow> :)
12:39:45 <FunctorSalad> (unless you know how much memory it uses, to give you a hint)
12:40:15 <FunctorSalad> or wait, that'd still be O(log(busy beaver)), no? ;)
12:40:22 <mmorrow> mornfall: ByteString does this
12:40:48 <mornfall> Intriguing.
12:41:05 <mmorrow> i'm not sure though what exactly you want the behavior to be wrt laziness though
12:41:24 <mmorrow> because depending on what you have in mind it may be easy, hard, or impossible
12:41:49 <mornfall> Ideally, values that I don't ask for stay unevaluated.
12:41:50 <mmorrow> well, s/impossible/really hard/
12:42:05 <mornfall> Although that's probably not extremely important.
12:42:13 <mornfall> So I could live with a strict variant.
12:42:30 <athos> hi
12:42:34 <mornfall> (It might turn out the final value is smaller than the thunk would be, and it's really just about memory here...)
12:42:55 <mmorrow> mornfall: the problem i see is say you fill a buffer lazily from haskell (with unsafePErformIO). you'll get the desired behavior on the haskell side, but if you're accessing that buffer from C, haskell won't know to perform the write before the access
12:44:14 <mornfall> mmorrow: I currently access that through a FFI call, no direct memory access. Haskell code is asked to poke bytes into a pre-allocated buffer.
12:44:32 <mmorrow> oh nice, that might work out then
12:45:27 <mmorrow> but i'm not sure what all the moving parts are, etc
12:46:51 <mornfall> I'll first with immutable non-strict arrays and if that hits performance, I'll try playing around with unsafePerformIO...
12:47:40 <mmorrow> i'd be interested to hear how it turns out
12:48:15 <mornfall> (The overall use-case: I have some high-performance, multi-threaded graph algorithms in C++, and I want to specify the graph in haskell, as successors :: Vertex -> [Vertex]... and I am working out the interface to do that, efficiently...)
12:48:31 <vixey> what does unsafePerformIO get you?
12:48:41 <sw17ch> mmorrow: http://www.cse.unsw.edu.au/~rl/publications/recycling.html <-- will this work for mornfall's problem?
12:48:43 <lambdabot> Title: Recycle Your Arrays!
12:48:47 <sw17ch> i haven't been following too closely
12:49:18 <mmorrow> sw17ch: i'm not sure, but that looks interesting regardless :)
12:49:46 <sw17ch> mmorrow: it's slick
12:49:47 <vixey> mornfall: Vertex -> [Vertex] can be converted to data Graph = Vertex :-->: [Graph Vertex] really easily, might be better in terms of memoization
12:50:04 <mmorrow> vixey: it lets you do IO on-demand/lazily
12:50:26 <mornfall> vixey: How so?
12:50:29 <sw17ch> @seen dons
12:50:30 <lambdabot> dons is in #haskell, #xmonad, #darcs, #concatenative, #ghc and #arch-haskell. I last heard dons speak 2h 41m 30s ago.
12:50:46 <mornfall> sw17ch: I am not quite sure, as I just need to build the array once and then just look inside.
12:50:54 <mornfall> sw17ch: No updates whatsoever.
12:51:29 <sw17ch> mornfall: i really don't know what your application is all about, but i think your concern is that using a immutable array will have some performance penalities when building it up
12:51:34 <Martijn> @pl \x y -> [x,y]
12:51:35 <lambdabot> (. return) . (:)
12:51:44 <sw17ch> once you have it, you're fine, but building it initially could be a problem... correct?
12:51:50 <vixey> @pl \y x -> [x,y,y,y,y,x,y,y,y,x,y,x,y,x]
12:51:53 <lambdabot> ap (:) . liftM2 (.) (:) (liftM2 (.) (:) (liftM2 (.) (:) (liftM2 (.) (:) (ap (:) . liftM2 (.) (:) (liftM2 (.) (:) (liftM2 (.) (:) (ap (:) . liftM2 (.) (:) (ap (:) . (. return) . (:)))))))))
12:52:25 <vixey> :t ap (:) . liftM2 (.) (:)
12:52:27 <lambdabot>     Couldn't match expected type `[a]'
12:52:27 <lambdabot>            against inferred type `a1 -> [a]'
12:52:27 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
12:53:06 <mmorrow> :t (ap (:) .) . liftM2 (.) (:)
12:53:07 <lambdabot> forall a. (a -> a -> [a]) -> a -> a -> [a]
12:53:20 <Deewiant> @pl \y x -> concatMap (uncurry replicate) [(1,x),(4,y),(1,x),(3,y),(1,x),(1,y),(1,x),(1,y),(1,x)]
12:53:21 <lambdabot> ((uncurry replicate =<<) .) . ap ((:) . (,) 1) . ap ((.) . (:) . (,) 4) (ap ((:) . (,) 1) . ap ((.) . (:) . (,) 3) (ap ((:) . (,) 1) . ap ((.) . (:) . (,) 1) (ap ((:) . (,) 1) . (. (return . (,) 1))
12:53:21 <lambdabot> . (:) . (,) 1)))
12:53:31 <sw17ch> @pl \argh my eyes -> [it hurts, my eyes]
12:53:31 <lambdabot> const (((it hurts :) .) . flip flip [] . ((:) .))
12:53:44 <mmorrow> hehe
12:53:44 <Deewiant> "it hurts :)"
12:53:56 <sw17ch> yes, i saw it too... lambdabot makes fun of my pain
12:54:07 <mmorrow> @remember pl const (((it hurts :) .) . flip flip [] . ((:) .))
12:54:07 <lambdabot> Nice!
12:54:24 <Deewiant> @pl \y x -> x : replicate 4 y ++ [x] ++ replicate 3 y ++ [x,y,x,y,x]
12:54:25 <lambdabot> ap (:) . ap ((.) . (++) . replicate 4) (ap (:) . ap ((.) . (++) . replicate 3) (ap (:) . liftM2 (.) (:) (ap (:) . (. return) . (:))))
12:54:26 <mornfall> sw17ch: Let me benchmark it and we'll see.
12:54:31 <FunctorSalad> @let action goggles = Nothing
12:54:33 <lambdabot>  Defined.
12:54:42 <Deewiant> @pl \y x -> x : concat [replicate 4 y,x,replicate 3 y,x,y,x,y,x]
12:54:43 <lambdabot> ap (:) . (join .) . ap ((.) . (:) . replicate 4) (ap (:) . ap ((.) . (:) . replicate 3) (ap (:) . liftM2 (.) (:) (ap (:) . (. return) . (:))))
12:58:29 <sw17ch> #haskell's humor is always good for your ego (when you get it, that is...)
13:04:29 * mornfall scratches head...
13:06:41 <mornfall> So, using Data.Array gives about 14 % penalty, as opposed to a hardcoded case.
13:07:31 <mornfall> http://hpaste.org/12634 -- the commented version runs in something like 3.5 secs, the one with numerate in 4.
13:10:03 <mornfall> What puzzles me more is that using -threaded gives something like 50 % penalty.
13:10:24 <jeffersonheard> this is sad...  I've forgotten how to commit new darcs updates
13:10:32 <jeffersonheard> on my project on hackage
13:10:48 <mornfall> Anyway, is it safe to call into haskell from multiple C(++) threads?
13:10:50 <jeffersonheard> darcs send -s -o patchno.patch and copy the patch
13:11:00 <mornfall> I suppose it would work with -threaded?
13:11:00 <jeffersonheard> but...  I've forgotten where :P
13:12:08 <mornfall> I have observed some odd effects, although that is hopefully just my code being buggy.
13:12:29 <Cale> jeffersonheard: darcs apply?
13:12:29 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:12:53 <jeffersonheard> Cale, yeah...  I just can't remember the server name or the path
13:13:41 <jeffersonheard> I'm on nun.
13:14:31 <Cale> oh wait... your project on hackage?
13:14:36 <jeffersonheard> y
13:15:08 <Cale> Usually I do a cabal sdist and then use the form to upload the tarball that makes.
13:15:33 <Cale> Unless they're also hosting darcs repositories now...
13:15:34 <jeffersonheard> well... right, to upload to hackage, but I'm also hosted on code.haskell.org
13:15:37 <Cale> ah
13:15:52 <jeffersonheard> and I was looking for anything obvious, and the obvious directories are empty
13:16:04 <jeffersonheard> but if I surf to code.haskell.org/FTGL, there's a repository there
13:16:08 <mornfall> jeffersonheard: You should be able to just darcs push somewhere below /srv/code/?
13:16:08 <Cale>  /srv/code/* ?
13:16:33 <jeffersonheard> ahhh
13:16:37 <jeffersonheard> I was on /srv/projects
13:19:15 <dmead> hey channel
13:19:24 <dmead> when are submissions due for the next HCAR?
13:19:40 <roconnor> what are the laws for a symmetric monoidal monad?
13:21:15 <jeffersonheard> Deewiant, updates made to FTGL
13:21:20 <jeffersonheard> enjoy
13:24:46 <FunctorSalad> roconnor: monoidal monad?
13:24:58 <FunctorSalad> a monad which is also a monoidal functor?
13:27:50 <FunctorSalad> I think you'd have the usual choice of how much strictness you want for the laws
13:28:49 <Saizan> uhm, applicatives are lax monoidal functors, right?
13:29:10 <mib_t7f209> Is 'Boolean' a standard type from a common library, or is it likely a typo?
13:29:15 <roconnor> FunctorSalad: what are the laws for a monoidal functor?
13:29:31 <roconnor> FunctorSalad: what are the laws for a lax monoidal functor?
13:29:32 <vixey> mib_t7f209; typo
13:29:39 <mib_t7f209> thanks
13:29:42 <idnar> yeah, sounds like a typo
13:30:14 <roconnor> wikipedia says: ``which are such that for every three objects Failed to parse (&lt;math_output_error&gt;): A , Failed to parse (Cannot write to or create math output directory): B
13:30:56 <FunctorSalad> roconnor: I guess you don't want me to transcribe the wiki page :) http://en.wikipedia.org/wiki/Lax_monoidal_functor
13:31:15 <evident> hi guys
13:31:34 <roconnor> FunctorSalad: okay. I think I get it now.
13:31:47 <roconnor> There are tonnes of boring laws to prove.
13:31:55 <FunctorSalad> roconnor: you have three choices for the arrow in f (a * b) -> (f a) * (f b): natural transformation, natural iso, or equality
13:32:01 <FunctorSalad> (identity)
13:32:36 <evident> i am having some little difficulties using the filter-function
13:32:42 <FunctorSalad> according to wiki they're called lax, strong, strict respectively
13:33:09 <FunctorSalad> roconnor: I guess for a monoidal monad you'd have even more choices
13:33:30 <roconnor> FunctorSalad: monoidal monad says lax
13:33:34 <evident> i have a type called Card (Card r s) with a rank (r) and a suit (s)
13:33:47 <roconnor> and that return and join need to be monoidal natural.
13:33:50 <evident> and now i have a List of 5 Cards [Card]
13:34:05 <evident> and want to check whether this list is a flush
13:34:22 <evident> isFlush ((Card r s):(Card r2 s2):xs)
13:34:22 <evident> 	| filter (== s) xs = True
13:34:22 <evident> 	| otherwise = False
13:34:27 <roconnor> flush is all the same suit?
13:34:32 <evident> yes
13:34:50 <evident> but i dont get how to use filter with this data type
13:34:51 <roconnor> all (\x -> Suit x == Suit (head l))
13:35:00 <roconnor> evident: don't use filter.  Use all.
13:35:11 <evident> only learned to use it like filter (<=5) [3,6,2,6,2]
13:35:18 <evident> how do i do it with "all"?
13:35:19 <roconnor> @type call
13:35:21 <lambdabot> Not in scope: `call'
13:35:21 <roconnor> er
13:35:23 <roconnor> @type all
13:35:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:35:32 <roconnor> > all even [2,4,6]
13:35:34 <lambdabot>   True
13:35:37 <roconnor> > all even [2,4,5]
13:35:39 <lambdabot>   False
13:35:39 <mmorrow> mornfall: i've found that code built with -threaded and run /without/ at least +RTS -N2 -RTS is slower than that same code built without threaded
13:35:41 <vixey> > all odd [3,5,7]
13:35:42 <lambdabot>   True
13:35:56 <evident> yeah i got that
13:35:57 <roconnor> evident: does that help?
13:36:03 <vixey> > all (odd . fst) (zip [3,5,7] [2,4,6])
13:36:05 <lambdabot>   True
13:36:09 <vixey> > all (odd . snd) (zip [3,5,7] [2,4,6])
13:36:11 <lambdabot>   False
13:36:19 <evident> but how do i write the predicate so that it only compares my suits?
13:36:35 <roconnor> evident: you have a choice
13:36:36 <lament> \a,b -> Suit a == Suit b
13:36:44 <roconnor> all (\a -> Suit x == blah)
13:36:46 <roconnor> er
13:36:49 <roconnor> all (\x -> Suit x == blah)
13:36:49 <dmead> ?src all
13:36:50 <lambdabot> all p =  and . map p
13:37:03 <roconnor> or you can do
13:37:05 <FunctorSalad> nubBy Suit a
13:37:13 <FunctorSalad> err
13:37:18 <roconnor> all (\x -> x == blah) (map suit list)
13:37:23 <roconnor> or
13:37:24 <FunctorSalad> length (nubBy Suit cards) == 1
13:37:33 <roconnor> all (\x -> x == blah) [suit | Card suit _ <- l]
13:37:36 <FunctorSalad> @type nubBy
13:37:38 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
13:37:40 <lament> FunctorSalad: nice
13:37:50 <roconnor> I'd be inclined to go with the first way
13:37:51 <lament> you win
13:37:53 <roconnor> all (\x -> Suit x == blah)
13:37:56 <vixey> evident, do you have a way to extract suit from a card?
13:37:59 <FunctorSalad> length (nubBy ((==) `on` Suit) cards) == 1, even
13:38:23 <evident> isFlush ((Card r s):(Card r2 s2):xs)
13:38:23 <FunctorSalad> and Suit is probably suit
13:38:35 <evident> well can't i compare s and s2 now?
13:38:43 <lament> yeah
13:38:44 <evident> just like normal variables?
13:38:57 <lament> FunctorSalad: damn, not quite very pretty
13:38:57 <roconnor> isFlush ((Card r s):xs) == all (\x -> suit x == s) xs
13:39:09 <vixey> I don't understand why everyone is using Suit -- a constructor?
13:39:12 <evident> ahhh
13:39:15 <FunctorSalad> vixey: yeah :)
13:39:18 <evident> now i got it roconnor
13:39:19 <lament> vixey: we're dumb
13:40:14 <FunctorSalad> lament: 1 == length . nub . map suit $ list  -- is that acceptable?
13:40:15 <lament> i like (==) `on` suit though
13:40:32 <vixey> > all (odd . fst) (zip [3,5,7] [2,4,6])
13:40:34 <lambdabot>   True
13:40:35 <lament> FunctorSalad: hm! that's much saner!
13:40:41 <lament> why didn't we think of map before
13:40:59 <hackage> Uploaded to hackage: FTGL 1.1
13:41:11 <lament> map suit list seems the perfect place to start
13:41:17 <roconnor> isFlush (x:xs) == all (== `on` suit x) xs  ?
13:41:24 <roconnor> isFlush (x:xs) == all ((==) `on` suit x) xs  ?
13:41:29 <evident> sorry but i dont have the data constructor "suit"
13:41:39 <lament> evident: it's not a data constructor, it's a function
13:41:42 <FunctorSalad> evident: suit should be of type Card -> Suit
13:41:44 <lament> evident: and if you don't have it, you should define it
13:41:56 <lament> suit (Card r s) = s
13:42:02 <roconnor> evident: data Card = Card {rank :: Int; suit :: Suit}
13:42:26 <roconnor> or do what lament said
13:42:34 <roconnor> I'd use a record type in this case myself.
13:42:46 <evident> http://hpaste.org/12635
13:42:55 <evident> this is the Poker.hs we have to include
13:43:08 <roconnor> ah homework
13:43:31 <roconnor> then what lament said since you don't control the data type.
13:43:32 <evident> yes
13:43:33 <evident> :)
13:44:01 <evident> there are good things and bad things about having Haskell in the university...
13:44:16 <roconnor> evident: don't use that Ord instance
13:44:27 <evident> i have to
13:44:29 <roconnor> evident: it looks really stupid.
13:44:40 <evident> well, written by our professor
13:44:41 <evident> :)
13:44:53 <roconnor> I haven't seen an Ord instance that bad since GHC's instance for Double.
13:45:09 <evident> what would be a better way?
13:45:15 <lament> um, that Ord instance is just broken, no?
13:45:29 <evident> broken?
13:45:44 <lament> it's not how you compare cards in poker
13:45:45 <luite_> yes, cards of the same rank, with different suits will always get GT
13:45:46 <roconnor> you can't sort cards with that instance
13:45:50 <lament> and yes
13:46:05 <FunctorSalad> lament: it fits the equality
13:46:10 <Twey> Oh dear, oh dear
13:46:17 <roconnor> evident: I'd put an order on Suits and use the derived order for Cards.
13:46:47 <FunctorSalad> if it falls past the first two cases, we must have rank1 > rank2
13:46:52 <Cale> Ord is supposed to be a total ordering
13:47:06 <FunctorSalad> Cale: it is, with respect to his Eq :)
13:47:17 <roconnor> FunctorSalad: or rank1 == rank2
13:47:17 <Cale> FunctorSalad: I don't think it's symmetric.
13:47:38 <FunctorSalad> roconnor: no, see the Eq instance
13:47:38 <roconnor> evident: to be safe, I recommend deleting that ord instance when doing your homework.
13:47:40 <tromp> this Ord is no more broken than the Eq
13:47:58 <roconnor> FunctorSalad: ooooooohh
13:48:04 <FunctorSalad> it's fine, it just ignores the suit
13:48:05 <roconnor> evident: nevermind
13:48:23 <roconnor> evident:  the instance is ... okayish
13:48:36 <evident> dont worry, haven't been able to understand 90% of what you wrote anyway... :)
13:48:47 <FunctorSalad> you could say that Eq is observably coarser than "real" equality
13:49:05 * roconnor fixes the Ord instance to make it readable.
13:49:13 <FunctorSalad> (I'm probably misusing that word 'observably' :o)
13:50:12 <Cale> FunctorSalad: It's worse than that. Card Five Clubs > Card Five Spades is false, but Card Five Clubs >= Card Five Spades is true
13:50:53 <tromp> they're equal, Cale
13:50:54 <lament> Cale: that actually fits poker comparison rules
13:50:59 <lament> Cale: they're equal, in poker
13:51:20 <evident> well the suit doesnt matter at all for comparing, or?
13:51:32 <lament> so that Ord instance is actually correct
13:51:40 <evident> its just when you want to find out whether its a flush
13:51:44 <lament> just weirdly defined
13:51:47 <tromp> funny that Ranks like Ace are abbreviated to A
13:51:50 <Cale> lament: It's not a total ordering.
13:52:07 <FunctorSalad> Cale: it is, with respect to the Eq in that file
13:52:58 <Cale> Well, the Eq is also problematic.
13:53:04 <lament> why?
13:53:08 <roconnor> Cale: you are so strange.
13:53:16 <lament> Cale: what's the problem with the Eq?
13:53:39 <Cale> lament: Cards which are genuinely different compare as equal, which is bound to mess various things up.
13:54:07 <yitz> Card Ace Hearts > Card Ace Spades, and also Card Ace Spades > Card Ace Hearts
13:54:14 <Cale> It would be better to define a separate equivalence on rank.
13:54:17 <tromp> it would make more sense to compare ranks explicitly of course
13:54:33 <lament> yitz: no. They're equal.
13:54:51 <roconnor> Cale: equivalent CReals have genuinely different approximations.
13:55:08 <yitz> lament: they're also equal.
13:55:13 <lament> 1 == 0.999...
13:55:18 <lament> ace of clubs == ace of spades
13:55:39 <lament> yitz: they're not greater than each other, though. They're just equal.
13:55:49 <Cale> Consider trying to form a Data.Set of Card values. I don't think you really want it to treat all the 5's in the set to be the same card.
13:55:57 <yitz> lament == uses the Eq instance, so they're equal. > uses the Ord instance, so compare gives GT
13:56:15 <evident> well, just to get back to the problem: i wrote a version that works, but is, of course, completely stupid and much much too long...
13:56:16 <evident> http://hpaste.org/12636
13:56:19 <mmorrow> roconnor: but you're using two different conceptions of Eq in that sentence
13:56:20 <lament> yitz: compare gives EQ
13:56:27 <lament> yitz: because it uses the Eq instance too
13:56:30 <Cale> *Poker Data.Set> fromList [Card Five Hearts, Card Five Spades, Card Five Clubs]
13:56:30 <Cale> fromList [Card Five Clubs]
13:56:42 <evident> now i only have to make it smaller so i dont need to write each element of the list
13:56:50 <Cale> I claim that this is most likely going to be a bug.
13:56:55 <yitz> ah, I see. whew, what a mess.
13:57:03 <FunctorSalad> Cale: the equality is fine as long as every function is independent of the suit
13:57:04 <lament> yes ;)
13:57:04 <roconnor> mmorrow: sure  Just like two equivalent cards can have genuinely different suits.
13:57:06 <Botje> evident: people posted solutions involving "all", above.
13:57:18 <Cale> FunctorSalad: Then why record the Suit at all?
13:57:24 <FunctorSalad> (and as long as the output doesn't care about the suit)
13:57:25 <Cale> FunctorSalad: Just use Rank values.
13:57:27 <lament> evident: that's ridiculously ugly.
13:57:31 <FunctorSalad> Cale: no idea :)
13:57:31 <roconnor> evident: write a suit function.
13:57:32 <evident> well but they dont work, because i dont have the Suit Constructor, or do they?
13:57:34 <lament> evident: we posted like 10 different solutions.
13:57:41 <lament> evident: and two different suit functions.
13:57:46 <evident> ahh ok
13:57:49 <evident> i'll try
13:57:51 <Varan> I need something similar to: interact :: (String -> String) -> IO () but with some kind of memory so something like interactWithMemory :: ((String, a) -> (String, a)) -> IO () ... Is this possible?
13:57:52 <mmorrow> roconnor: sure, but i'd say that isn't a perfect analogy to two different reps of the same real number
13:58:06 <mauke> Varan: huh?
13:58:09 <FunctorSalad> err, I don't mean 'independent', just 'well-defined' == 'independent of the suit, up to change of suit in result'
13:58:12 <Botje> Varan: you could use a state monad inside interact
13:58:22 <Asgaroth> Varan: StateT?
13:58:22 <roconnor> mmorrow: not perfect.  However it is (barely) good enough.
13:58:36 <Botje> interact (runState someFunction initialState)
13:58:37 <mmorrow> roconnor: i'll give you that :)
13:58:41 <byorgey> Varan: sure, just make a wrapper function of type String -> String which calls your  (String,a) -> (String,a) function
13:58:42 <mrd> Varan: the String argument to that function is the entire input
13:58:45 <yitz> Varan: you'll need an initial value for the memory
13:58:49 <lament> by the way, a -real- isFlush function should take a list of any length and see whether at least five cards in it have the same suit
13:58:51 <byorgey> then give your wrapper function to interact
13:58:52 <Cale> I don't care which card game you're writing, you're going to want to care about preserving different suited cards as different. Nobody likes to pick up a 5 of hearts when they already have a five of spades and have the 5 of hearts just replace the 5 of spades in their hand.
13:59:06 <Varan> yitz, i have that
13:59:09 <yitz> ok
13:59:10 <lament> because poker hands are not limited to 5 cards
13:59:13 <roconnor> evident: don't worry about our chatter.  Easy question often proke deep discussion on #haskell.
13:59:14 <Twey> It means that there are four aces of spades in the deck.
13:59:15 <Twey> Effectively.
13:59:28 <lament> holdem has 7 cards, omaha has 9 iirc, etc
13:59:28 <mrd> Varan: it doesn't make sense, what you're asking, because that function only gets called once anyhow
13:59:30 <Botje> four times the cool.
13:59:58 <byorgey> mrd: eh? why doesn't it make sense?
14:00:00 <lament> who wants to write the real isFlush function? :)
14:00:00 <Varan> mrd, why .. interact calls the function as long as there is input right? once per line
14:00:00 <yitz> Varan: perhaps you mean for the function to be called once per line
14:00:07 <Varan> yes
14:00:11 <Varan> i do
14:00:12 <mrd> Varan: No! that is the misconception I am trying to correct
14:00:12 <byorgey> mrd: it's quite reasonable to suppose that you would want a state while computing the output String
14:00:14 <bjorkLinux> what's this fascination with poker?
14:00:23 <Cale> bjorkLinux: I have no idea.
14:00:25 <bjorkLinux> i'm sure there're OTHER games out there!
14:00:35 <dibblego> poker can make money
14:00:37 <mrd> Varan: to do what you asked requires this: interact (lines . map (\ line -> ...) . unlines)
14:00:46 <mrd> and you can replace that with a foldr
14:00:51 <Cale> bjorkLinux: It seemed like there was this mysterious point at which it started being on TV and all over the internet.
14:00:56 <mrd> Varan: to do what you asked requires this: interact (lines . foldr (\ line state -> ...) initialState . unlines)
14:00:58 <bjorkLinux> dibblego, meaning a lot of people are trying.
14:01:04 <Cale> It's a really silly game though.
14:01:10 <bjorkLinux> that was 3 years ago.
14:01:13 <mrd> er
14:01:19 <mrd> and something to extract the output from the state
14:01:30 <Varan> hmm
14:01:31 <roconnor> @type replicateM
14:01:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:01:36 <vixey> interact = build ?
14:01:37 <Botje> let's just write a haskell bot to make money from poker. If we do it well enough we can pay several people with the winnings!
14:01:52 <Varan> doesn't interact just gets executed per input line?
14:01:54 <mrd> no
14:02:14 <mrd> it _appears_ that way because of the vagaries of line-buffered input combined with laziness
14:02:16 <roconnor> lament: realFlush l = any (isFlush) (replicateM 5 l)
14:02:35 <Cale> Except that there's not a lot of possible variation in skill in poker... I suppose you can still profit in the long run if you're just a tiny bit better than everyone else.
14:02:56 <mrd> interact (unlines . map snd . foldr (\ line (state, output) -> ...) (initialState,"") . lines)
14:03:03 <roconnor> lament: crap
14:03:09 <roconnor> lament: duplicates
14:03:11 <roconnor> :(
14:03:18 <mrd> I mixed up lines and unlines in my previous version
14:03:35 <mrd> @src interact
14:03:35 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:03:45 <Varan> hmmm owke
14:03:49 <Varan> strage
14:04:00 <mrd> as you can see, there is nothing that deals with lines in that implementation of interact
14:04:06 <roconnor> getContents has concurrent semantics.
14:04:09 <Varan> yes i see
14:04:22 <yitz> interact (unlines . flip evalState initial . mapM doOneLine . lines)
14:04:25 <mrd> Varan: what happens is lazy I/O: as UNIX sends each line to the program, the program lazily computes the output
14:04:27 <vixey> oh
14:04:32 <vixey> I thougth interact already worked on lines
14:04:40 <mrd> ah yea, yitz has it nicely using the State monad
14:04:58 <vixey> @pl \build f -> build (p . f . q)
14:04:58 <lambdabot> (. ((p .) . (. q)))
14:05:17 <roconnor> I presume interact will work on characters, lines, or buffer size, depending on bufferMond
14:05:23 <roconnor> bufferMode
14:05:29 <Varan> @src build
14:05:30 <lambdabot> build g = g (:) []
14:05:32 <yitz> vixey: that looks like a candidate for Conal's @pl
14:05:37 <mrd> yeah if you turned off Line Buffering on your stdin then interact programs would respond immediately
14:05:44 <eu-prleu-peupeu> hey Hppl
14:05:54 <eu-prleu-peupeu> i can't wait for my "real world haskell" copy to arrive :)
14:05:56 <lament> isFlush list = 5 <= maximum [filter (== s) $ map suit list|s <- [Spades, Hearts, Diamonds, Clubs]]
14:06:11 <mornfall> mmorrow: (Hm, GHCRTS=-N2 doesn't seem to help any, but I wouldn't expect it to, either... I need to sleep now, I'll let you know if I make some progress tomorrow...)
14:06:28 <lament> the real isFlush :)
14:06:36 <roconnor> [Spades, Hearts, Diamonds, Clubs] == [minBound..maxBound] == [minBound..]
14:06:52 <lament> roconnor: can you do that without that type deriving Ord?
14:06:59 <lament> i assume i can't alter the definition of Suit
14:07:01 <vixey> [Spades, Hearts, Diamonds, Clubs] looks clearer idk
14:07:05 <roconnor> you need to derive Bonded.
14:07:06 <Varan> mrd: so this should work? interact (unlines . map snd . foldr (\ line (state, output) -> ...) (initialState,"") . lines)
14:07:15 <mrd> Varan: there is a function in System.IO to change buffering which you could test out that way :)
14:07:20 <lament> roconnor: well, you're not allowed to alter Poker.hs
14:07:21 <roconnor> Bounded
14:07:23 <FunctorSalad> love this from the wiki: shootSelfInFoot = unsafePerformIO . shoot . foot $ self -- Shoot self in foot 0 or more times depending on evaluation order
14:07:24 <mrd> Varan: I recommend yitz's code
14:07:33 <yitz> isFlush = null . tail . group . map suit
14:08:07 <vixey> is a flush when they all have the same suit?
14:08:20 <Varan> oke
14:08:29 <lament> yitz: hahaha sweet
14:08:32 <roconnor> vixey: the real is flush is when 5 have the same suit
14:08:38 <yitz> vixey: it is with my definition at least :)
14:08:47 <lament> evident should use that function
14:08:51 <mrd> Varan: then you can write doOneLine = do state <- get; ... ; put state; return outputLine
14:08:56 <lament> so his prof's head explodes
14:09:11 <roconnor> :)
14:09:18 <Varan> hmm owke
14:09:23 <mrd> Varan: doOneline inputLine = ...
14:09:37 <yitz> lament: his prof's head already exploded when he wrote that Ord instance
14:09:46 <lament> haha
14:09:55 <FunctorSalad> missing a 'had'?
14:10:15 <FunctorSalad> ._.
14:10:59 <FunctorSalad> could we have a context inferer?
14:11:31 <FunctorSalad> if ghc complains and says you should add $x to the context, the inferrer could just do that and try to recompile
14:11:44 <mrd> Varan: it is effectively the same as my code but the State monad covers up all the "plumbing" so to speak
14:11:47 <FunctorSalad> until it converges
14:11:49 <vixey> what's the point if it can't edit your source code?
14:11:58 <FunctorSalad> vixey: it should edit it
14:12:00 <Varan> hmm owke
14:12:11 <FunctorSalad> vixey: thinking of an external program like drift
14:13:22 <Varan> mrd: but the stateEval and doOneLine is separated....
14:13:31 <Varan> not in your version
14:14:04 <lilac> @tell conal A patch which fixes the blocking (and possibly the space leak) is attached to reactive bug#14
14:14:05 <lambdabot> Consider it noted.
14:16:16 <conal> lilac: thanks very much!  i'll check it out.
14:16:16 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
14:16:30 <magthe> I'm having some problems with IO in Haskell, when trying to drive things from a python program, anyone around who can help me out?
14:17:20 <conal> lilac: where did you exploit your unamb-based max for AddBounds?
14:17:26 <magthe> The code and interactive Python session:  http://hpaste.org/12637
14:17:36 <mrd> Varan: doesn't have to be
14:17:46 <mrd> Varan: you could write doOneLine in-place
14:18:04 <mrd> just write (\ inputLine -> ...) instead
14:18:06 <lilac> conal: the `max` in snapshotWith relies on it
14:18:25 <conal> lilac: got it.  thx.  clever!
14:19:10 <lilac> no idea whether the space leak fix works; about to test it
14:21:14 <Cale> magthe: Could it be that the python output to the process is buffered?
14:23:31 <magthe> Cale: good thinking, I'll try
14:24:22 <magthe> Cale: yes, looks like it :) thanks
14:25:40 <Cale> Yeah, doing a  stdin.flush()  after the write fixes it :)
14:26:11 <mauke> stdin.flush? grr
14:26:30 <evident> by the way: what editor do you prefer for coding in Haskell?
14:26:33 <Cale> mauke: stdin is a variable in his example code.
14:26:48 <evident> Eclipse, Vim, Notepad, Notepad++, ...
14:26:49 <Cale> evident: I mostly use vim, but emacs is nice too.
14:27:06 <Cale> I've never understood people's attraction to Eclipse.
14:27:41 <vixey> emacs makes my arm hurt :/
14:27:51 <Botje> vixey: you're supposed to use footpedals
14:28:07 <Cale> I don't know many emacs keys, so it doesn't hurt my arms :)
14:28:16 <evident> well because i cant decide what to go for
14:28:32 <Cale> Really, all you need is a place to type text which can make sure that there aren't any tab characters in your file.
14:28:39 <evident> a friend of mine, who is a real programming freak, gave me vim with his insane configuration
14:28:51 <evident> which took me a while to even be able to work with it
14:28:54 <Cale> Oh, and supporting a monospaced font would be good too ;)
14:28:54 <Botje> freak is SUCH an unkind word
14:29:08 <evident> but unfortunately its too complicated so that anyone else could work on it
14:29:10 <evident> that doesnt know it
14:29:15 <byorgey> wow, footpedals are a really great idea!
14:29:35 <Botje> evident: use whatever you damn well feel like
14:29:36 <byorgey> I mean, I'm normally doing nothing at all with my feet
14:29:39 <FunctorSalad> byorgey: for the computer?
14:29:43 <byorgey> yeah
14:29:50 <FunctorSalad> sounds good
14:29:59 <FunctorSalad> for health too...
14:30:03 <Botje> you can code haskell with cat or notepad if you so choose to
14:30:20 <FunctorSalad> with cat!?
14:30:23 <evident> what do you do with footpedals?
14:30:37 <byorgey> evident: I dunno, use them as modifier keys?
14:30:42 <mauke> FunctorSalad: sorry, dd of course
14:30:49 <Cale> Just make sure you pipe the output of cat through some sed command that translates all the tabs.
14:30:53 <byorgey> ctrl-foot2-x
14:30:57 <Botje> http://www.cb1.com/~john/computing/emacs/handsfree/pedals.html
14:31:03 <lambdabot> Title: Emacs pedals
14:31:11 <FunctorSalad> haha
14:31:19 <byorgey> oh, wow, you were serious!
14:31:35 <byorgey> I guess it figures that someone has done that before.
14:32:03 <vixey> I'm worried about getting RSI now :[
14:32:04 <vixey> a
14:32:21 <evident> wow... pedals... thats insane... :)
14:32:43 <evident> i'm just imagining setting these up in the university
14:32:45 <evident> on my laptop
14:32:46 <evident> :)
14:33:18 <olsner> install accelerometers in your shoes and you won't even need the pedals
14:33:47 <FunctorSalad> foot gestures + mouse gestures?
14:33:53 <yitz> use brain wave detectors
14:33:55 <FunctorSalad> must look graceful :>
14:34:17 <evident> brain wave detectors...
14:34:18 <olsner> FunctorSalad: install one in every limb and you can type with tics
14:34:24 <evident> nice
14:34:54 <Botje> "why are you dancing like that?" "i'm not, i'm writing haskell!"
14:35:00 <evident> I've seen a video (i think it was on lifehacker) about a brain-interface
14:35:13 <evident> pretty awesome
14:35:43 <yitz> has anyone come up with a nice setup to use dasher for writing haskell?
14:35:57 <Cale> Though multitouch is an even better idea, I've often liked the idea of having two mice. Even just two mice open up a lot of UI possibilities which are difficult with only one.
14:36:36 <Cale> yitz: I suspect that if you just use dasher for writing Haskell for a while, it will be good :)
14:37:14 <evident> well there is software that makes it possible to use two mice!
14:37:18 <evident> or even more
14:37:27 <evident> @Cale
14:37:28 <lambdabot> Unknown command, try @list
14:38:03 <Cale> evident: Yeah. Of course, once you have multitouch, then you get all those UI possibilities and more :)
14:38:06 <ushdf> my linux box works
14:38:10 <ushdf> xmonad works
14:38:15 <ushdf> so it's haskell time, as soon as finals are over
14:38:19 <FunctorSalad> Cale: uh? you'd lose the hand on the kb
14:38:33 <FunctorSalad> mouse is overused compared to kb anyway
14:38:36 <ushdf> i'll code like you people didn't even know you could code!
14:38:54 <Cale> FunctorSalad: Sure. I tend not to be typing at the same time I'm actively using the mouse, unless I'm playing an FPS game.
14:38:59 <yitz> Cale: the problem is that dasher doesn't work well with emacs or vim. or at least i don't know how to set it up for that.
14:39:10 <FunctorSalad> Cale: not typing, but hotkeys
14:39:28 <FunctorSalad> hitting a key will always be faster than something fuzzy...
14:39:34 <yitz> ushdf: go for it!
14:39:37 <Botje> FunctorSalad: think of multitouch screens
14:39:48 <Botje> you could actually point at your code
14:40:05 <Botje> just draw a circle around it and grab it
14:40:08 <mauke> C has native support for multiple pointers
14:40:14 <Cale> FunctorSalad: There are really cool UI things you can do with even just two analog inputs.
14:40:17 <Botje> heh
14:40:18 <Botje> actually
14:40:18 <evident> well it might be more productive than just using the keyboard for navigation if you have a system like in "Minority Report"
14:40:26 <Botje> this is something i could implement :)
14:40:34 <evident> when being able to use all ten fingers
14:41:00 <evident> but just having two mice would be slower than just using hte keyboard
14:41:02 <p_l> evident: Except that it used basically two points, with grasping as the metafor
14:41:04 <FunctorSalad> Botje: sounds good for selecting - but sounds more like a replacement for the mouse, not the kb :)
14:41:17 <Cale> FunctorSalad: Like having toolboxes which you move over what you're editing and click through in order to apply settings to what's below. The ability to adjust things in two dimensions at once is also really nice.
14:41:19 <Botje> FunctorSalad: on-screen keyboard
14:41:32 <yitz> evident: we were trying to be helpful, but instead we are distracting you from doing your homework.
14:41:47 <FunctorSalad> Botje: sounds like a great waste of screen space ;)
14:41:59 <evident> p_l: but there are a many different gestures you can make with your hand... :)
14:42:05 <Botje> FunctorSalad: i don't think it'd be too bad
14:42:18 <Botje> turn the screen vertically
14:42:22 <evident> yitz: don't worry, still got lots of time for my homework... :)
14:42:24 <Botje> you'd waste maybe 10 cm on your keyboard
14:42:33 <Botje> still have 30ish for text
14:42:54 <FunctorSalad> Botje: I'd want a normal-size kb
14:43:08 <Botje> FunctorSalad: mine is 10 cm high
14:43:16 <Botje> and about 30 cm wide
14:43:32 <Botje> so it's doable
14:43:36 <Cale> FunctorSalad: Or lenses which can be moved over bits of a structure to show additional things which can then be manipulated. For example, in a drawing program you could have a lens which artificially separates control points and doesn't display fills, so you can more easily select things.
14:43:36 * p_l would like double chording keyboard with mouses in built :)
14:43:54 <yitz> Botje: how about one screen laying flat for the kbd, and another vertical one
14:43:56 <Cale> So you move the lens with one hand, and adjust control points with the other.
14:44:07 <Botje> FunctorSalad: hell, you could even stop writing code as text and manipulate ASTs directly
14:44:12 <p_l> yitz: Without nanotech for the screen, it would be bad to use
14:44:25 <p_l> Botje: Done back in 80's
14:44:31 <Botje> ...
14:44:38 <FunctorSalad> Botje: still, what's the advantage of the onscreen kb? very expensive, probably less reliable, no feedback, ...
14:44:39 <Botje> did they have fancy 3d animations back then?!
14:44:53 <FunctorSalad> Botje: ASTs sound more interesting :)
14:44:55 <p_l> Botje: Nope, they distract you instead of helping
14:45:04 <yitz> p_l: nanotech? you mean for people with very thin fingers?
14:45:10 <Cale> The problem with on-screen keyboards is that the keys on a flat screen don't push back.
14:45:20 <p_l> yitz: No, to imlement tactile feedback
14:45:32 <evident> ok, to get back to my homework: next task -> isStraight
14:45:32 <yitz> Cale: yeah. you make them beep to help that.
14:45:55 <Cale> It's not just the tactile feedback, but the fact that your fingers are pushed back into a better position to hit the next key.
14:46:03 <evident> and i decided to use a help function called "cardsInOrder"
14:46:04 <p_l> yitz: Actually, the problem is mechanical, not cognitive - it simply is bad for your fingers to use OSD
14:46:12 <Botje> evident: easy. sort by rank and see if there exists a subgroup that had the cards in order.
14:46:30 <evident> which just should find out whether the 5 elements in the list are in a row
14:46:47 <FunctorSalad> Cale: I admit it would be way better than mice to interact with a GUI :)
14:47:03 <evident> cardsInOrder :: [Card] -> Bool
14:47:11 <Cale> FunctorSalad: or two mice rather than one? :)
14:47:18 <evident> what would you think is the best way to approach that?
14:47:28 <evident> first, sort the list by rank?
14:47:36 <Botje> sort by rank descending
14:47:48 <evident> why descending?
14:47:58 <Botje> oh wait
14:48:01 <Cale> FunctorSalad: I can't tie my shoes with one hand :)
14:48:02 <Botje> doesn't matter here
14:48:12 <evident> how do i sort them?
14:48:20 <Botje> sortBy
14:48:26 <evident> k
14:48:29 <Botje> you'll have to write a rank function first
14:48:33 <FunctorSalad> Cale: one-hand-on-toolbox, one-hand-on-editee sounds just like mouse and keyboard though, except that you needn't remember the shortcuts
14:48:35 <Botje> to extract rank from cards
14:48:45 <Cale> sortBy (flip (comparing rank))
14:49:05 <Botje> heh
14:49:14 <Botje> if i were a haskell teacher i'd be watching this channel like a hawk :)
14:49:19 <Cale> FunctorSalad: Well, the toolbox might have analog quantities in it too.
14:50:40 <ddarius> Botje: All you do is take a suspect answer and ask the student to verbally explain the solution.
14:50:57 <yitz> isStraight = all (== 1) . (zipWith subtract `ap` tail) . sort . map (fromEnum . rank)
14:51:01 <Botje> "the guys on #haskell told me to!"
14:51:16 <Twey> Haha
14:51:21 <evident> ddarius: may i ask where you are from?
14:51:27 <mrd> Cale: apparently the new blackberry with a touchscreen has a spring on the back of the screen which provides the "pressing" feel
14:51:30 <Botje> yitz: forgot a nub
14:51:39 <Botje> or map head . group
14:51:43 <yitz> Botje: the wiki page about homework says they all do watch here like hawks
14:52:03 <maek> Im not knowing anything about haskell im just trying to get xmonad to compile. my 6.10 ghc seems to NOT have installed cabal, is that normal?
14:52:31 <yitz> Botje: no, I think that will work
14:52:44 <Cale> maek: Unfortunately, yes, cabal-install doesn't come with GHC.
14:53:01 <yitz> > all (== 1) . (zipWith subtract `ap` tail) . sort $ [1..5]
14:53:03 <lambdabot>   True
14:53:09 <yitz> > all (== 1) . (zipWith subtract `ap` tail) . sort $ [1..5] ++ [7..9]
14:53:11 <lambdabot>   False
14:53:19 <maek> Cale: ok thanks. the xmonad docs say after 6.8 ghc included cabal. I will build from source. thank you.
14:53:20 <Botje> > all (== 1) . (zipWith subtract `ap` tail) . sort $ [1,2,3,3,4,5]
14:53:22 <lambdabot>   False
14:53:42 <Botje> yitz: or is yours only meant to be run on 5 cards?
14:53:45 <Cale> maek: Oh, it does include Cabal, the library, but doesn't include cabal the program.
14:53:47 <Botje> in that case, nvm :)
14:53:50 <yitz> Botje: oh, you want that to qualify as a straight?
14:54:19 <Botje> that's why i mentioned the nub :)
14:54:22 <yitz> ok
14:54:30 <Cale> maek: http://hackage.haskell.org/packages/archive/cabal-install/0.6.0/cabal-install-0.6.0.tar.gz
14:54:32 <lambdabot> http://tinyurl.com/6gcmrq
14:54:35 <evident> ok i dont even get that sorting stuff at all yet... :)
14:54:42 <quicksilver> what does "MAIN" mean in a heap profile?
14:54:45 <Cale> maek: You'll find a bootstrap script in that package.
14:54:47 <Botje> evident: start by reading about the sortBy and compare functions
14:54:56 <mauke> is there a version of ghc that can run from a memory stick?
14:55:03 <SamB> quicksilver: it means "I haven't the slightest clue what did this"
14:55:13 <evident> where is the sortBy function? cant find it on zvon.org
14:55:18 <quicksilver> SamB: ah, that's good news.
14:55:22 <mauke> what the heck is zvon.org?
14:55:24 <quicksilver> SamB: I have a memory leak in MAIN
14:55:24 <quicksilver> ;)
14:55:26 <pao> evident: try hoogle
14:55:33 <yitz> @hoogle sortBy
14:55:34 <maek> Cale: Sorry, I dont know what that means.
14:55:34 <SamB> quicksilver: try getting more SCCs
14:55:34 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
14:55:41 <mauke> evident: http://www.haskell.org/hoogle/?q=sortBy
14:55:42 <lambdabot> Title: sortBy - Hoogle
14:55:46 <quicksilver> SamB: thanks. Playing with options.
14:55:54 <Cale> evident: There's a type defined in the Prelude called Ordering, which consists of the values LT, EQ, and GT meaning "less than", "equal" and "greater than" respectively, which is used to describe the outcomes of comparisons.
14:56:01 <evident> ahh got it
14:56:08 <evident> found it at least
14:56:08 <evident> :)
14:56:14 <yitz> @src Ordering
14:56:15 <lambdabot> data Ordering = LT | EQ | GT
14:56:24 <Cale> evident: The function compare will give you an Ordering from two elements.
14:56:29 <Cale> > compare 5 6
14:56:30 <lambdabot>   LT
14:56:36 <Cale> > compare 10 6
14:56:37 <lambdabot>   GT
14:56:43 <Cale> > compare 5 5
14:56:44 <lambdabot>   EQ
14:56:54 <evident> ahh ok
14:56:55 <quicksilver> SamB: is there a way to make heap profiles fully colour? the shades of gray are hard to distinguish.
14:57:20 <Cale> There is a function 'comparing' found in Data.Ord which takes a function, and compares the results of applying that function to each of the values.
14:57:24 <SamB> quicksilver: -c apparantly
14:57:33 <Cale> That is,  comparing f x y = compare (f x) (f y)
14:57:42 <SamB> quicksilver: you could also try printing it out
14:58:03 <quicksilver> SamB: Oh nice. I didn't realise there were any options to hp2ps
14:58:09 <quicksilver> SamB: I was looking at the options for GHC itself.
14:58:16 <quicksilver> SamB++ # reading the right FM.
14:58:21 <Cale> Functions like sortBy take a function which has the same type as compare does.
14:58:38 <FunctorSalad> comparing f = (<=) `on`f?
14:58:39 <Cale> > sortBy compare [6,3,8,1,4,9]
14:58:40 <lambdabot>   [1,3,4,6,8,9]
14:58:46 <Cale> FunctorSalad: compare `on` f
14:58:56 <FunctorSalad> ah
14:59:03 <dcoutts> jeffersonheard: no probs
14:59:18 <evident> well it says that the sortBy Function doesnt exist...
14:59:19 <Cale> evident: Note that by flipping the compare function we get a reverse sort:
14:59:23 <evident> how do import hat again?
14:59:26 <Cale> > sortBy (flip compare) [6,3,8,1,4,9]
14:59:27 <FunctorSalad> Cale: oops, missed your definition a few lines above ;)
14:59:27 <lambdabot>   [9,8,6,4,3,1]
14:59:33 <Cale> evident: import Data.Ord
14:59:44 <mauke> import Data.List
14:59:47 <Cale> flip f x y = f y x
15:00:06 <Cale> So it just reverses the parameters to the comparison function, which results in a reversed ordering.
15:00:20 <mm_freak> > sortBy (compare `on` (^2)) [-30..30]
15:00:22 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
15:00:29 <yuuki> In Barendregt's lambda cube, why are there two abstraction symbols, lambda and pi?
15:00:44 <evident> just put "import Data.List" in the first line?
15:01:04 <dibblego> below any module declaration
15:01:05 <Cale> > sortBy (comparing length) (words "here is a bunch of words to sort by length")
15:01:06 <lambdabot>   ["a","is","of","to","by","here","sort","bunch","words","length"]
15:01:22 <evident> module declaration?
15:01:27 <Cale> evident: Yes.
15:01:29 <mm_freak> @index comparing
15:01:29 <lambdabot> bzzt
15:01:37 <mm_freak> @hoogle comparing
15:01:37 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:01:38 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:01:38 <Cale> evident: After your module declaration, if any.
15:01:47 <Cale> evident: and before anything else
15:02:00 <evident> how do i make a module declaration?
15:02:09 <Cale> module MyModule where
15:02:13 <Cale> Would be the simplest way.
15:02:21 <evident> ahhh ok
15:02:23 <yitz> > sortBy (comparing sin) [-10..10]
15:02:24 <lambdabot>   [-8.0,5.0,-2.0,-1.0,4.0,-7.0,10.0,-9.0,6.0,-3.0,0.0,3.0,-6.0,9.0,-10.0,7.0,...
15:02:29 <Cale> But your module should be called Main if you're compiling it into a program.
15:02:41 <Cale> The default main action is called Main.main
15:02:59 <Cale> You could also use the --main-is flag to the compiler to tell it to look somewhere else.
15:03:02 <mm_freak> > map round . sortBy (comparing sin) $ [-10..10]
15:03:04 <lambdabot>   [-8,5,-2,-1,4,-7,10,-9,6,-3,0,3,-6,9,-10,7,-4,1,2,-5,8]
15:03:13 <Cale> If you leave the module declaration out, the module will be called Main by default.
15:03:45 <mm_freak> > sortBy (comparing $ sin . fromIntegral) $ [-10..10]
15:03:47 <lambdabot>   [-8,5,-2,-1,4,-7,10,-9,6,-3,0,3,-6,9,-10,7,-4,1,2,-5,8]
15:03:54 <Cale> So typically, the module which is directly compiled into the executable will not have a module declaration, but other supporting modules will.
15:04:19 <Cale> Another very nice thing to know about Ordering values is that they form a monoid.
15:04:31 <quicksilver> OK, that's weird.
15:04:51 <quicksilver> One version of my code obviously slows down and gets jerky - GC thrashing, must be memory leak. I find where the leak is.
15:04:56 <idnar> > LT `mplus` LT
15:04:58 <lambdabot>   Couldn't match expected type `m a' against inferred type `Ordering'
15:05:03 <idnar> er
15:05:03 <Cale> > LT `mappend` LT
15:05:04 <quicksilver> then I profile the "good verson" which runs fine. According to the heap profile it has the same heap.
15:05:05 <lambdabot>   LT
15:05:12 <Cale> The definition looks like:
15:05:14 <idnar> oh yes
15:05:17 <idnar> I always get those two mixed up
15:05:21 <Cale> LT `mappend` y = LT
15:05:25 <Cale> GT `mappend` y = GT
15:05:29 <Cale> EQ `mappend` y = y
15:05:50 <dibblego> > EQ `mappend` LT
15:05:51 <lambdabot>   LT
15:05:52 <idnar> how is that useful?
15:06:08 <Cale> This looks a bit strange at first, but it gives you a way to combine comparisons where the second comparison is only used if the first one compared equal.
15:06:16 <mm_freak> > mempty :: Ordering
15:06:17 <vixey> > compare 1 4 `mappend` compare "y" "z"
15:06:18 <lambdabot>   EQ
15:06:19 <lambdabot>   LT
15:06:32 <yitz> in short - it gives the dictionary ordering
15:06:40 <Cale> Which is exactly like what you do when comparing words in a dictionary: you compare the first letters, and if they compare equal, then you compare the rest of the words.
15:06:42 <sjanssen> > mempty :: Ordering
15:06:43 <lambdabot>   EQ
15:07:03 <Cale> Moreover, whenever m is a monoid, functions e -> m are a monoid as well.
15:07:18 <Cale> So we can combine comparison functions:
15:07:44 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a bunch of words to sort first by length and then alphabetically")
15:07:45 <lambdabot>   ["a","by","is","of","to","and","here","sort","then","bunch","first","words"...
15:07:55 <marko> hi all
15:08:25 <Cale> It's just unfortunate that mappend is such an awkward name. I would prefer it to be called ++
15:08:30 <Cale> and mempty to be called zero
15:08:34 <olsner> woah, there's a function monoid as well?
15:08:39 <mm_freak> (side note:  i frequently observe that haskellers write clean code, even if it's just quick-n-dirty code for testing something through lambdabot…  i'm observing the opposite for all other languages)
15:08:47 <sjanssen> olsner: more than one!
15:08:48 <roconnor> Cale: doesnt ++ seems kinda commutative looking?
15:08:55 <Cale> olsner: (mappend f g) x = mappend (f x) (g x)
15:09:02 <Cale> roconnor: No.
15:09:04 <olsner> sweet! :)
15:09:08 <Cale> roconnor: Not for lists ;)
15:09:15 <shepheb> can Network.FastCGI still be used with 6.8.2?
15:09:17 <sjanssen> olsner: though the alternatives have to be hidden behind newtypes, eg. Endo
15:09:21 <FunctorSalad> Cale: agreed, `mappend` is bad
15:09:30 <roconnor> well, append ought to be called ^ if it weren't already being used.
15:09:36 <evident> ok i got enough for now... going to bed... 1 o clock at night here
15:09:39 <FunctorSalad> err, I meant to write "`mappend`"
15:09:42 <evident> where are you all from?
15:09:51 <Cale> roconnor: I'm used to ++ enough by now :)
15:09:59 <Cale> evident: I'm from Ontario Canada.
15:10:04 <idnar> @type mconcat
15:10:06 <lambdabot> forall a. (Monoid a) => [a] -> a
15:10:17 <evident> Germany... :)
15:10:19 <marko> here is a quick question: I thought it is sufficient to import IO in order to have liftIO available. But it does not work here. I keep getting "not in scope"
15:10:26 <evident> well tehanks for everybody for helping me
15:10:26 <FunctorSalad> evident: dito
15:10:30 <mm_freak> i'm from germany
15:10:33 <Cale> marko: It's in Control.Monad.Trans, I think.
15:10:36 <evident> i'll be back... promise
15:10:43 <marko> thanks Cale, I'll try
15:10:44 <Cale> @index liftIO
15:10:44 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:10:46 <sjanssen> @index MonadIO
15:10:46 <Cale> yes
15:10:46 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:10:59 <evident> gn8
15:11:05 <Cale> evident: Night!
15:11:07 <marko> thanks sjanssen
15:11:12 <mm_freak> good night, evident
15:11:13 <sjanssen> marko: you have to import one of those (Control.Monad.Trans is probably the best)
15:11:44 <luqui> conal, as a library implementor, i am quite a fan of this relative time stuff.  A complete implementation of Futures and Reactives in 135 lines :-)
15:11:46 <mm_freak> usually you'd import just the module for your monad transformer (Control.Monad.State or such) and use liftIO through it
15:11:52 <marko> thanks sjanssen
15:12:30 <sjanssen> roconnor: if (++) looks commutative, then we probably shouldn't use it for list append either
15:12:45 <roconnor> no we shouldn't
15:12:54 <roconnor> but
15:13:02 <roconnor> list append is somewhat additivelike
15:13:05 <sjanssen> having said that, (++) seems fine to me
15:13:20 <roconnor> in that  length (x++y) = lenght x + length y
15:13:29 <Cale> I would be a little upset if + was used for a noncommutative operation, but ++ is okay.
15:13:30 <roconnor> so I do understand it a little.
15:14:20 <vixey> how can I understand the mechanics of theorems for free better?
15:14:36 <Cale> It's as much a deformed version of * as it is two +'s :)
15:14:38 <lilac> conal: space leak is definitely not fixed :(
15:14:40 <roconnor> We should define (**) as map2 (,)
15:14:44 <roconnor> but ** is taken
15:14:45 <mm_freak> can't both function composition and list concatenation be generalized to the same concept?  that way, you could use (.) for both
15:14:49 <shepheb> can Network.FastCGI still be used with 6.8.2? I have Cabal 1.6 and it can't read the .cabal
15:14:51 <Cale> roconnor: zipWith (,) ?
15:14:54 <FunctorSalad> roconnor: I was just going to suggest (**) = `mappend` :(
15:14:59 <mm_freak> i could even think of both being a Monoid
15:15:13 <mm_freak> mempty = id;  mappend = (.)
15:15:17 <roconnor> Cale: length (zipWith (,) x y) /= lenght x * length y
15:15:21 <Cale> roconnor: zipWith (,) = zip
15:15:23 <FunctorSalad> how about \cdot = mappend?
15:15:26 <Cale> er
15:15:30 <sjanssen> mm_freak: yes, see the Endo newtype
15:15:32 <FunctorSalad> (·) = mappend
15:15:33 <lilac> mm_freak: isn't that Endo?
15:15:34 <conal> lilac: might be a different leak.
15:15:37 <Cale> Oh, map2 = liftM2 ?
15:15:44 <roconnor> right
15:15:44 <roconnor> sorry
15:15:51 <conal> lilac: there's one i think i understand, involving unused inputs.
15:15:52 <roconnor> I use map2 in my thesis
15:16:00 <roconnor> so I have it on my brain
15:16:02 <dolio> > let (*) a b = (,) <$> a <*> b in ([1,2] * [1..3])  ++ ([3,4] * [1..3])
15:16:02 <sjanssen> mm_freak: though I think the other definition is more useful.  There are lots of types which have many potential Monoid instances
15:16:04 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3)]
15:16:10 <conal> lilac: i was concerned about a snapshot creating an additional leak
15:16:18 <mm_freak> sjanssen, lilac:  i think, you wouldn't need a newtype for that
15:16:18 <dolio> > let (*) a b = (,) <$> a <*> b in ([1,2] ++ [3,4]) * [1..3]
15:16:19 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3)]
15:16:39 <sjanssen> mm_freak: you do, instances are not supposed to overlap
15:16:48 <yitz> sjanssen: yet another reason why it should be possible to control import and export of instances
15:16:50 <FunctorSalad> @let (·) = mappend
15:16:50 <lambdabot>   Illegal character ''\183''
15:16:55 <FunctorSalad> meh :(
15:17:13 <sjanssen> yitz: I contend that instances are only useful because they're global
15:17:39 <sjanssen> Cale's example of (comparing length ++ compare) -- is only nice because we don't have to name the instance used
15:18:00 <yitz> sjanssen: (almost) anything is inherently evil. that's been well-known for decades.
15:18:07 <mm_freak> > (^2) `mappend` (+1) $ 3
15:18:08 <lambdabot>   Add a type signature
15:18:12 <yitz> anything global :)
15:18:14 <mm_freak> > (^2) `mappend` (+1) $ 3 :: Int
15:18:16 <lambdabot>       No instance for (Monoid Int)
15:18:16 <lambdabot>        arising from a use of `mappend' at ...
15:18:24 <sjanssen> mm_freak: the number types don't have Monoid instances
15:18:26 <lilac> conal: well, there's a leak without my change on the same testcase, but with the fix it /looks/ bigger
15:18:27 <vixey> @instances Monoid
15:18:28 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:18:30 <sjanssen> but there are Sum and Product newtypes
15:18:36 <dolio> @check let (*) a b = (,) <$> a <*> b in \a b c -> (a ++ b) * (c :: [Int]) == (a * c) ++ (b * c)
15:18:38 <lambdabot>   "OK, passed 500 tests."
15:18:42 <mm_freak> > (^2) `mappend` (\x -> x+1) $ 3 :: Int
15:18:43 <lambdabot>       No instance for (Monoid Int)
15:18:43 <lambdabot>        arising from a use of `mappend' at ...
15:18:48 <roconnor> > runEndo (Endo (^2) `mappend` Endo (+1)) $ 3 :: Int
15:18:50 <lambdabot>   Not in scope: `runEndo'
15:18:50 <mm_freak> hmm?!
15:18:52 <Cale> > (^2) `mappend` (+1) $ 3 :: Sum Int
15:18:53 <lambdabot>       No instance for (Num (Sum Int))
15:18:54 <lambdabot>        arising from a use of `^' at <in...
15:19:03 <roconnor> @hoogle Endo a -> a
15:19:04 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
15:19:04 <lambdabot> Prelude id :: a -> a
15:19:04 <lambdabot> Data.Function id :: a -> a
15:19:05 <Cale> And they stupidly don't have instances of Num
15:19:09 <roconnor> > appEndo (Endo (^2) `mappend` Endo (+1)) $ 3 :: Int
15:19:10 <lambdabot>   16
15:19:21 <mm_freak> i don't understand…  i thought of Monoid instance for (a -> b)
15:19:30 <roconnor> > (Endo (^2) `mappend` Endo (+1)) `appEndo` 3 :: Int
15:19:32 <lambdabot>   16
15:19:40 <Cale> mm_freak: e -> m is only a monoid when m is.
15:19:41 <roconnor> > Endo (^2) `mappend` Endo (+1) `appEndo` 3 :: Int
15:19:43 <lambdabot>   16
15:19:45 <mm_freak> ah, now i understand…  for that the argument type must be a monoid, too
15:19:54 <Cale> mm_freak: No, the result type.
15:19:59 <mm_freak> oh, ok
15:20:11 <FunctorSalad> sjanssen: another solution would be to have mappend :: (Monoid m a) => m -> a -> a -> a     -- m is a token type, say data IntegerMonoids = Sum | Product
15:20:15 <Cale> mm_freak: Int is not defined as a Monoid, because it could be one in two ways.
15:20:23 <mm_freak> > (++ "test") `mappend` ("test" ++) $ "xxx"
15:20:25 <lambdabot>   "xxxtesttestxxx"
15:20:31 <sjanssen> FunctorSalad: right, you'd have to name the instances
15:20:44 <vixey> > let (++) = mappend in (++ "test") ++ ("test" ++) $ "xxx"
15:20:46 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1
15:20:46 <lambdabot>        Ex...
15:20:46 <sjanssen> FunctorSalad: I wonder if that is more handy in practice than newtype wrappers?
15:20:50 <FunctorSalad> sjanssen: we could have a class DefaultMonoidStructure so it is backwards compatible
15:20:51 <Cale> The little bits of library brokenness everywhere are starting to really annoy me.
15:20:59 <mm_freak> hmm…  seems like the Monoid instance for (a -> b) is different from what i thought
15:21:07 <roconnor> > runSum (map Sum (^2) `mappend` map Sum (+1)) $ 3) :: Int
15:21:09 <lambdabot>   <no location info>: parse error on input `)'
15:21:12 <FunctorSalad> sjanssen: mappend would use the default monoid and for the general case we'd have gmappend or something
15:21:14 <Cale> mm_freak: It is however exactly what I told you :)
15:21:16 <roconnor> @hoogle Sum a -> a
15:21:17 <lambdabot> Data.Monoid getSum :: Sum a -> a
15:21:17 <lambdabot> Prelude id :: a -> a
15:21:17 <lambdabot> Data.Function id :: a -> a
15:21:17 <sjanssen> Cale: which bits of library brokenness?
15:21:22 <mm_freak> Cale: yeah =)
15:21:23 <vixey> Cale, I know the feeling all too well :)
15:21:26 <roconnor> > getSum (map Sum (^2) `mappend` map Sum (+1) $ 3) :: Int
15:21:27 <dolio> FunctorSalad: Why not just have "data Monoid a = Monoid { mempty :: a , mappend :: a -> a -> a }" at that point?
15:21:27 <lambdabot>       The section `(^ 2)' takes one argument,
15:21:27 <lambdabot>      but its type `[a]' has none
15:21:32 <luqui> Cale, too bad distributed library perfection is not attainable
15:21:38 <roconnor> > getSum (fmap Sum (^2) `mappend` fmap Sum (+1) $ 3) :: Int
15:21:40 <lambdabot>   13
15:21:45 <sjanssen> FunctorSalad: might be workable
15:21:45 <yitz> sjanssen: all functions are only nice if you don't need to repeat any implementation details each time.
15:21:53 <roconnor> > getProduct (fmap Product (^2) `mappend` fmap Product (+1) $ 3) :: Int
15:21:55 <lambdabot>   36
15:22:00 <yitz> sjanssen: so you do it once - with an import at the top.
15:22:14 <yitz> sjanssen: you should be able to do the same for instances if you want.
15:22:18 <Cale> sjanssen: Well, things like the bad names for monoid operations, Sum and Product not being instances of Num, fail in the Prelude, the Functor and Monad instances for (->) being relegated to a library import...
15:22:29 <FunctorSalad> dolio: hmm, seems pretty similar :) I'd use the DefaultMonoid thing with that too
15:22:43 <Cale> sjanssen: The usual complaints about Num...
15:22:49 <dolio> FunctorSalad: Plus, if you use the record types, you don't make quicksilver cry.
15:22:50 <sjanssen> yitz: yeah, that could potentially be done.  There are soundness issues, imagine what would happen if you use different Monoid instances with a FingerTree
15:23:18 <sjanssen> Cale: first and second could be easily fixed, send patches; third requires changing the Haskell report
15:23:43 <dcoutts> shepheb: did you figure out the issue with Network.FastCGI or are you still wondering?
15:23:46 <mm_freak> Cale: what are the usual complaints about Num?
15:23:49 <sjanssen> Cale: especially the Sum and Product issue, that's a quick dozen line patch
15:23:49 <yitz> sjanssen: same exact issue as if you use an explicit function and import the wrong one
15:23:54 <FunctorSalad> for example: class DefaultMonoid [a] where defaultMonoid = Monoid { gmzero = []; gmappend = (++) }
15:23:56 <Cale> I think that given all the implementations use the same base library anyway, the Report is a bad place to define the Prelude.
15:24:17 <FunctorSalad> dolio: why doesn't quicksilver like it? :)
15:24:37 <Cale> The base library should be a versioned library just like any other.
15:24:52 <yitz> Cale:  it made sense back in the day
15:24:52 <sjanssen> yitz: no, it is a different issue.  FingerTree depends on the monoid operation, so you get absolute nonsense if you pass a FingerTree between two modules with different instances in scope
15:25:08 <dolio> FunctorSalad: Quicksilver doesn't like using type classes for overloading things that logically have more than one instance per type (and thus leads to newtype wrappers and other workarounds).
15:25:10 <Cale> yitz: I agree with you on that. But I contend that it no longer makes sense :)
15:25:14 <dolio> Can't say I blame him.
15:25:21 <sjanssen> Cale: it is nice that we can write code against a published standard and have it actually work 10 years later
15:25:29 <wagle> i want Maybe String and MPlus in python..  is there a good concise way?
15:25:32 <dolio> Actually, he doesn't like type classes for a lot of other stuff, as well.
15:25:43 <Cale> sjanssen: Right, but there's a haskell98 package, and so there really should not be a problem compiling legacy code.
15:26:16 <sjanssen> Cale: there are technical issues there, but not insurmountable ones
15:26:16 <yitz> sjanssen: it's the exact same issue, but appealing to two different parts of Haskell syntax, that's all.
15:26:32 <alexei_> how do I make a variant of cost n p = alpha * (cost1 n) / p + beta * p^2 that has type Integer -> Integer -> Double? Haskel infers n, p :: Double
15:26:36 <FunctorSalad> dolio: so does he prefer the newtype or the Default thing I mentioned?
15:26:42 <luqui> wagle, def mplus(s,t): if s == None: return t else: return s
15:27:01 <sjanssen> yitz: taken to the extreme, instance overlap is actually unsafe
15:27:18 <FunctorSalad> dolio: or no class at all, I guess
15:27:18 <mm_freak> alexei_: fromInteger n, fromInteger p
15:27:19 <sjanssen> yitz: pass a StorableArray between two modules with incompatible Storable instances
15:27:28 <sjanssen> instant segfault
15:27:30 <dolio> FunctorSalad: I suspect he likes the record types I mentioned, since they're closer to what you want: multiple first-class modules.
15:27:34 <mauke> alexei_: cost n p = alpha * cost1 n' / p' + beta * p' ^ 2 where n' = fromInteger n; p' = fromInteger p
15:27:37 <wagle> mplus(s1,mplus(s2,mplus(s3,mplus(s4,mplus(s5,s6)))))
15:27:37 <yitz> sjanssen: right, so there needs to be control.
15:27:46 <dolio> FunctorSalad: Although having a "default monoid" class is a good idea that I hadn't seen before.
15:27:59 <luqui> wagle, that should be a fold anyhow
15:28:00 <sjanssen> yitz: type families also require that instances are unique to avoid type safety
15:28:04 <yitz> sjanssen: but global namespace pollution is not the right control
15:28:05 <wagle> was hoping for s1 or s2 or s3 or s4 or s5 or s6
15:28:08 <sjanssen> s/avoid/ensure
15:28:29 <yitz> sjanssen: great, controlling imports is the right tool
15:28:34 <luqui> wagle, fold(mplus, [s1,s2,s3,s4,s5,s6]), where definition of fold is left as an exercise for.. you
15:28:34 <sjanssen> yitz: do you have a system that avoids all these things?  I'll remain skeptical until I see one
15:28:40 <dolio> FunctorSalad: It gets you the best of both worlds. The default when you want it most of the time with no overhead, and specific "instances" when you want those.
15:28:56 <mm_freak> luqui: there is reduce in python
15:29:02 <luqui> good to know :-)
15:29:04 <alexei_> mm_freak, mauke, thanks. I am new to haskell.
15:29:04 <wagle> my cow-orkers will luv me
15:29:06 <mm_freak> 'reduce' == foldl1
15:29:37 <FunctorSalad> dolio: yeah. it's also similar to informal mathematics, where, say, a group structure for some set, is often left implicit
15:29:39 <luqui> wagle, yeah, python folks really jump on abstract functional idioms
15:29:50 <grom358> I get a stackoverflow with http://hpaste.org/12639 . But it is using a tail call.. so any ideas?
15:29:51 <mm_freak> hehe
15:29:51 <FunctorSalad> (and you just say "the group <some set>")
15:30:25 <yitz> sjanssen: the exact system we have now. except with the additional optional ability to stop someone else's module from polluting my global namespace with its instances.
15:30:27 * luqui doesn't believe that implicitness belongs in the formal part of a program
15:30:38 <dolio> FunctorSalad: The only thing missing is nicer first-class modules, where you could say, "foo mon = <stuff that uses monoid functions> where open Monoid mon".
15:30:46 <luqui> syntax sugar is all well and good, but we must recognize when it is sugar
15:30:48 <sjanssen> yitz: that isn't sufficient
15:30:54 <dolio> FunctorSalad: To avoid shuffling the monoid dictionary all over manually.
15:30:56 <mm_freak> wagle: if you really want to make them jump, use this:  http://code.activestate.com/recipes/439361/
15:30:58 <vixey> hi dolio
15:31:00 <mm_freak> =)
15:31:03 <lambdabot> Title: List/Generator Monad Combinators « ActiveState Code
15:31:04 <dolio> Hi.
15:31:14 <vixey> Did you read this Shifting The Stage?
15:31:24 <yitz> sjanssen: it's certainly better than what we have now.
15:31:30 <sjanssen> yitz: if a module can give me a Set Foo without giving the instance that created the Set, we have a problem (the problem is amplified with type families, Storable, Typeable ...)
15:31:31 <dolio> I didn't. But I downloaded it.
15:31:33 <ski_> (vixey : ?)
15:31:35 <dolio> Is it good?
15:31:37 <FunctorSalad> dolio: I'm not following... for avoiding recompilation and module dependency issues?
15:31:44 <vixey> It's amazing
15:31:46 <vixey> IT's really good
15:31:57 <vixey> ski_, http://okmij.org/ftp/Computation/staging/circle-shift.pdf
15:31:58 <ski_> related to composable continuations ?
15:31:59 <sjanssen> yitz: this system turns currently safe abstractions into potential segfaults
15:31:59 <lambdabot> Title: cache:http://okmij.org/ftp/Computation/staging/circle-shift.pdf - Google Search
15:32:02 <vixey> yes ski
15:32:17 <dolio> FunctorSalad: I'm talking ML-like first class modules. Where you can locally open and use them.
15:32:45 <vixey> dolio, but this bit,  const = λ y.λ z.y, get = 出(λ k.λ z.kzz), put = λ z .出(λ k.λ z.kz z ).
15:32:46 <Cale> sjanssen: There is the problem that when you really make an upgrade to the base package you make code compiled against different versions of the base incompatible. But the changes we usually want to make are not the sort that require huge and complicated edits to upgrade code, and we have enough tools now to make finding all the packages which won't build with the new changes reasonably easy to find -- at least those
15:32:46 <Cale> which have open source :)
15:32:53 <vixey> just reminded me of the code you were writing
15:32:53 <yitz> sjanssen: it turns current intractable module and version dependency spaghetti into usable code.
15:33:03 <dolio> FunctorSalad: So instead of "foo mon a b = gmappend mon (gmappend mon a b) b" you could write: "foo mon a b = gmappend (gmappend a b) b where open Monoid mon"
15:33:09 <Cale> vixey: Nice, kanji function names? :)
15:33:15 <FunctorSalad> dolio: I thought I could do "foo :: (DefaultMonoid m) => m -> Something", and then define "instance DefaultMonoid Int where ..." in some other module, and call "foo 1" just fine
15:33:24 <yitz> sjanssen: the current system is totally unsound in a different direction.
15:33:26 <sjanssen> yitz: the motto for Haskell is "No deals with the devil" -- we shouldn't ever sacrifice safety for convenience
15:33:34 <vixey> Cale, CPS form (| 出 |) = λ f . λ k. f (λ x. λ k . k (kx))(λ z. z)
15:33:46 <conal> lilac: okay.  i'll study you fix.  i'm really intrigued with it.
15:33:51 <wagle> mm_freak, heh
15:34:20 <ski_> (vixey : .. is that `shift' ?)
15:34:30 <vixey> ski_, yes I think so, and { }'s are reset
15:34:48 <vixey> (also the paper is about ocaml .. but I think it would apply to haskell also)
15:34:51 <vixey> (but not sure. .)
15:34:52 * ski_ sees a lot of `?'s ..
15:35:04 <luqui> ski_, blasphemy!  unicode aware yourself!
15:35:07 <luqui> :-)
15:35:08 <mib_t7f209> How could I map a function across the final two elements of a (large) tuple?
15:35:22 <ski_> luqui : i'm lazy
15:35:26 <Cale> mib_t7f209: Lambda + pattern match
15:35:29 <vixey> mib_t7f209, just how large?
15:35:55 <Cale> (\(x,y,z) -> (x, f y, f z))
15:36:00 <yitz> sjanssen: it's not just convenience. global pollution is a major source of bugs
15:36:02 <mib_t7f209> vixey: just large enough that it looks ugly to pattern match every predecessing element with _
15:36:13 <vixey> heh don't wory if it looks ugly
15:36:14 <luqui> mib_t7f209, stop using tuples
15:36:24 <mib_t7f209> What should I use?
15:36:25 <Cale> mib_t7f209: You shouldn't use large tuples.
15:36:30 <Cale> mib_t7f209: Define a new type.
15:36:33 <luqui> mib_t7f209, depends.  records are a good one
15:36:34 <Axman6> record syntax
15:36:35 <mm_freak> is there a ternary if/then/else-operator in python?
15:36:36 <Cale> (using data)
15:36:45 <sjanssen> yitz: I'm not familiar with such bugs
15:36:51 <mib_t7f209> Cale: it actually IS a new type, in the form of a tuple
15:37:02 <yitz> sjanssen: it's far worse than the odd case where someone explicitly blocks import of the right instance and then explicitly gets the wrong one from somewhere else.
15:37:28 <sjanssen> Cale: I think we wouldn't have a problem if the Haskell' process was actually working
15:37:31 <yitz> sjanssen: how much programming have you done in languages with dynamic scoping?
15:37:38 <sjanssen> yitz: none
15:37:50 <vixey> s for sensible
15:37:54 <Cale> sjanssen: Haskell' is too conservative, and lost a lot of people's interest once they found that out.
15:38:07 <yitz> sjanssen: if you had, you'd have felt the pain.
15:38:22 <sjanssen> Cale: Haskell' could make some of the changes you ask for (like the Functor and Monad instances).  It just doesn't have any momentum
15:38:35 <Axman6> mib_t7f209: data Foo = Foo {firstThing :: Type, secondThing :: [Thing], ...}, then access with f foo = firstThing foo
15:38:35 <Cale> sjanssen: Not that it's a terrible idea to only standardise what we've got, but if we're going to do that, we can't also be afraid to move beyond what we've standardised.
15:38:39 * QtPlatypus has done some programing in languages that support dynamic scoping.  "You get some rather hard to trace bugs if you are not extreemyl carefull"
15:38:45 <Axman6> mib_t7f209: data Foo = Foo {firstThing :: Type, secondThing :: [Thing], ...}, then access with f foo = firstThing foo : secondThing foo
15:38:50 <sjanssen> yitz: but I've done plenty of programming in Haskell, and I can't name any times where implicit instance exports have bitten me
15:39:04 <vixey> I wouldn't recommend records so quickly without knowing more about the real program
15:39:31 <yitz> sjanssen: it has happened to me any number of times.
15:39:34 <Taejo> I'm trying to install ghc 6.10 on ubuntu dapper, from the binary tarball... I'm getting "checking for path to top of build tree... utils/pwd/pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory" when I try to ./configure
15:39:35 <Cale> Being afraid to change implementations because it would break compatibility with the standard while not wanting to standardise beyond what's implemented will quickly lead to a fixed point ;)
15:39:40 <Axman6> vixey: did you hear the beginning of his question?
15:39:45 <mattam> Cale: is there a resolution on the MR already?
15:39:47 <sjanssen> yitz: you avoid almost all problems if you follow the orphan rule
15:40:22 <Axman6> Taejo: do you have gmp installed?
15:40:24 <Cale> mattam: I don't know about a resolution, but personally, I resolve to turn it into an optional warning, and not an error.
15:40:39 <sjanssen> Cale: this is a good point :).  You'll get language extensions standardized, since those can be deactivated at will, but library changes won't happen
15:40:48 <vixey> hi mattam
15:40:59 <hackage> Uploaded to hackage: typehash 1.0.0.0
15:41:13 <psygnisfive> so guys, let me ask a general purely functional programming question
15:41:13 <mattam> Hi vixey
15:41:14 <yitz> sjanssen: when writing a library for something that has many natural monoid instances - what do you do?
15:41:20 * luqui thinks Haskell' has no momentum because Haskell is a very fine language as it is.  It has a few warts, but practical tools always do.
15:41:22 <dolio> vixey: It looks kind of like they're doing monadic reflection.
15:41:41 <Taejo> Axman6: /usr/lib/libgmp.so.3 exists and points to /usr/lib/libgmp.3.3.3, which is an so file
15:41:46 <dolio> In that example at least. I'm sure the whole paper is more than that.
15:41:48 <vixey> mattam, I think I figured out how to get a JMeq_eq for decideable types without any axioms, and can define NoConf with it
15:41:49 <sjanssen> yitz: if there isn't a single most natural and useful instance, I'd use newtype wrappers for each instance
15:41:56 <luqui> wait until there is something major to be overcome, then Haskell' will get momentum
15:42:03 <Axman6> Taejo: odd
15:42:18 <psygnisfive> how do you handle code with multiple conditional requirements where to get to the final conditional requires going through various computations each dependent on the previous computations all being true?
15:42:27 <yitz> sjanssen: no one would ever use them
15:42:38 <grom358> can anyone tell me why http://hpaste.org/12640 gives a stackoverflow?
15:42:41 <sjanssen> yitz: that isn't true, I've used Endo several times
15:42:48 <sjanssen> (xmonad uses it, for example)
15:42:53 <Axman6> psygnisfive: nested ifs! >_>
15:42:54 <mattam> Oh. But you can't prove decidability for inductive families without JMeq in the first place it seems :)
15:43:10 <psygnisfive> axman6: well yes, but it'd also require multiple nested lets as well
15:43:16 <psygnisfive> and i was wondering if theres a more elegant solution
15:43:22 <Cale> grom358: acc isn't accumulating anything
15:43:25 <vixey> mattam, my variant of JMeq lets me, as long as the indices have decidable equalty (i.e. on nat, or the syntax of types)
15:43:33 <olsner> hmm, the Maybe monad with guards perhaps?
15:43:33 <mm_freak> luqui: i just tried to implement the fix function in python for fun…  that's going to be hard work, unless you implement it with explicit n-arity
15:43:37 <lilac> psygnisfive: maybe monad?
15:43:38 <Cale> grom358: You're just passing it along from one call to the next, and it always has the same value.
15:43:45 <mattam> So it's not good'ol JMeq?
15:44:03 <psygnisfive> but then the relevant functions would need to be able to handle input thats itself a maybe
15:44:04 <Axman6> grom358: you need to use (acc+1), and possibly $! (acc+1)
15:44:09 <vixey> slightly different
15:44:18 <Cale> grom358: Meanwhile, you're building up a large expression:  chainLength' 3 0 = (chainLength' (nextnum 3) 0) + 1
15:44:24 <lilac> psygnisfive: nope :)
15:44:30 <luqui> mm_freak, yeah, currying really helps things like that.
15:44:42 <Cale> Yeah, you might want to add a bang before acc in the pattern match.
15:44:51 <Cale> chainLength' n !acc = ...
15:44:53 <psygnisfive> what i mean is code sort of like the imperative code: a = foo(); if a then b = bar(a) if b then x = baz(b) ...
15:44:57 <Cale> (and turn on BangPatterns)
15:44:59 <mm_freak> luqui: indeed
15:45:02 <luqui> mm_freak, however, I have no idea what you mean by "that", and perhaps you meant to address someone else :-)
15:45:07 <grom358> BangPatterns?
15:45:08 <psygnisfive> only withmore complicated things going on :p
15:45:10 <Stephan202> psygnisfive: that's exactly what the Maybe Monad can do!
15:45:17 <Axman6> Cale: you wouldn't advise the more portable $! instead?
15:45:20 <mm_freak> but it works in python, and surely brings the average python programmer's head to explode =)
15:45:24 <lilac> psygnisfive: do a <- foo; b <- bar a; x <- baz b
15:45:24 <psygnisfive> yeah but these functions would need to accept Maybe's
15:45:30 <Stephan202> psygnisfive: no!
15:45:33 <psygnisfive> no?
15:45:35 <sjanssen> yitz: it is also important to note that Monoid as a class is somewhat controversial, since many types don't have a single natural instance
15:45:39 <Stephan202> :t (>>=)
15:45:40 <Cale> Axman6: Well, you can use that. I tend to actually like how Bang patterns look.
15:45:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:45:49 * luqui reminisces when legions of perl programmers' heads exploded when they started working on Pugs
15:45:51 <psygnisfive> oh indeed
15:45:53 <lilac> psygnisfive: where foo :: a -> Maybe b; bar :: b -> Maybe c; baz :: c -> Maybe d
15:45:57 <psygnisfive> if you use bind, yeah.
15:45:58 <Stephan202> psygnisfive: ^ you see, the second argument is a -> m b
15:46:09 <Stephan202> :t (>>)
15:46:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:46:12 <Axman6> Cale: me too, but they're non-standard, so i try to avoid them
15:46:14 <mm_freak> luqui: and nope, i meant to address you, because of this:  <luqui> wagle, yeah, python folks really jump on abstract functional idioms
15:46:16 <psygnisfive> now a more interesting question, suppose im not using haskell and dont have monads? :P
15:46:17 <yitz> sjanssen: often there is one natural instance semantically, but you need various strictness variations
15:46:21 <Cale> Of course, even more sensible is to write this using length and takeWhile.
15:46:25 <luqui> mm_freak, ah :-)
15:46:27 <Cale> (and iterate)
15:46:32 <mattam> vixey: interesting. I'll catch up tomorrow, now is time to sleep :)
15:46:34 <yitz> sjanssen: (in general, not just Monoid)
15:46:37 <sjanssen> yitz: how about this idea: keep instances global, but provide a way to turn instance into dictionaries
15:46:41 <Cale> Axman6: I don't avoid nonstandard things. :)
15:46:44 <vixey> mattam, ok, bye :)
15:46:48 <Axman6> :)
15:47:01 <sjanssen> yitz: so (Monad m) => ... will use the global instance, but Monad m -> ... allows the user to supply the instance
15:47:09 <yitz> sjanssen: that's another source of very subtle bugs that come from this pollution. And yes, even crashes.
15:47:10 <mattam> BTW, I tried the APP/APP case and I don't think it's possible either.
15:47:21 <lilac> psygnisfive: in any language with closures you can probably implement a bind
15:47:27 <luqui> Axman6, avoiding nonstandard things is a great way to get a stale standard
15:47:34 <sjanssen> yitz: can you give an example?  I've never had problems with instances and strictness
15:47:41 <luqui> things become standard *when* they become widely used, not vice-versa
15:47:49 <vixey> mattam, I managed to crack that, and le irrelevance and so on using this new technique :D
15:47:52 <grom358> Cale: oh I actually pasted the wrong version on hpaste. I already have (acc + 1)
15:47:52 <psygnisfive> lilac: so i suppose theres really no elegant functional way of doing this :P
15:47:59 <yitz> sjanssen: famous one is Control.Monad.State monad instances
15:48:07 <yitz> StateT that is
15:48:08 <lilac> psygnisfive: the Maybe monad is pretty elegant IMO
15:48:10 <luqui> psygnisfive, that sounds like a challenge!!  (reads back)
15:48:20 <Axman6> i don't have a problem with them, and do use them, but i thought it might be easier to recommend using $! (acc+1) instead of f !acc
15:48:22 <BMeph> Cale: Are you still campaigning for a left-associative '$'? (That is your idea, right? Not the "flip the arguments of '$' one?) :)
15:48:28 <psygnisfive> elegant but necessitating monads
15:48:30 <Cale> grom358: Okay, then the problem is that you're accumulating a giant expression in that parameter
15:48:32 <Cale> BMeph: yes.
15:48:37 <mattam> vixey: do post it on Coq-club then!
15:48:51 <sjanssen> yitz: hmm, yes.  I don't think this is a problem unique to instances, strictness is a problem in all parts of Haskell
15:48:56 <Cale> BMeph: Application is left associative, so $ should be too.
15:49:01 <lilac> psygnisfive: merely necessitating a bind.
15:49:02 <sjanssen> foldl vs. foldl' being the best example
15:49:04 <yitz> sjanssen: it just came up for me again with Monoid instances for a tree type I needed.
15:49:06 <psygnisfive> lilac: the archetypal imperative version (or maybe single-binding functional in some languages) would be to have a single if with multiple guards
15:49:12 <grom358> Cale: because of the lazy evaluation?
15:49:18 <Cale> grom358: Well, yes.
15:49:18 <luqui> psygnisfive, yeah, I'd say Maybe and guard is elegant
15:49:25 <Taejo> hmm... "ldd pwd" gives "libgmp.so.3 => not found"
15:49:28 <psygnisfive> e.g. if a = foo() & b = bar(x) & c = baz(b) then
15:49:43 <Cale> grom358: The stack overflow happens at the end, when you go to evaluate that Int, and it has to traverse a giant expression to find a reducible subexpression.
15:49:45 <psygnisfive> ergh. bar(a) :P
15:49:53 <yitz> sjanssen:  libraries need to provide all of the strictness varieties that users might need. and that applies to instances as well.
15:50:08 <lilac> psygnisfive: i'd probably write it as "def foo(): a = foo(); if not a: return; b = bar(a); if not b: return; c = baz(b); if not c: return"
15:50:08 <Cale> grom358: So one solution is to make the acc parameter strict.
15:50:12 <luqui> do { x <- foo; y <- bar a; z <- baz b; guard (suchandsuch x y z); return z }
15:50:14 <Stephan202> psygnisfive: in most imperative languages the logical and works as you'd like
15:50:36 <Cale> grom358: Another solution would be to use standard functions which are known to have the strictness problem worked out already ;)
15:50:44 <psygnisfive> stephan202: yes, but im writing in scheme :p
15:50:52 <Stephan202> Then just say so! :P
15:50:52 <psygnisfive> so its functional, but not monady
15:50:53 <olsner> ugh, really ugly imo to sequence side-effects with &&
15:51:04 <psygnisfive> well i DID say i was coding functinally :P
15:51:16 <Stephan202> psygnisfive: I don't know Scheme, so can't help you any further then :)
15:51:17 <luqui> psygnisfive, so encode monad into scheme! :-)
15:51:34 <luqui> you won't get the syntax sugar...
15:51:46 <luqui> but this idiom *is* monadic at its heart
15:51:49 * vixey my scheme is not really functional
15:51:49 <olsner> let a = foo; b = bar a; c = baz b in if a && b && c then c else "Fail"
15:51:50 <Cale> grom358: You could write this as  chainLength n = length . takeWhile (/= 1) $ iterate nextnum n
15:51:50 <psygnisfive> no monads in scheme, hush :P
15:51:51 <lilac> psygnisfive: can't you write a macro which does the equivalent of bind?
15:52:02 <vixey> psygnisfive, didn't stop Oleg et al
15:52:08 <vixey> (using monads in Scheme)
15:52:16 <vixey> (referring to The Reasoned Schemer)
15:52:17 <BMeph> psygnisfive: Oleg might disagree with you there... ;)
15:52:20 <psygnisfive> no no i mean i dont want to encode monads
15:52:26 <psygnisfive> code*
15:52:30 <psygnisfive> mainly because i dont GET monads
15:52:34 <grom358> :t iterate
15:52:36 <lambdabot> forall a. (a -> a) -> a -> [a]
15:53:01 <olsner> you could do it with continuations
15:53:19 <luqui> psygnisfive, well then why don't you encode something like: maybeBind :: Maybe a -> (a -> Maybe b) -> Maybe b, and then encode your dependencies that way
15:53:23 <psygnisfive> i dont get scheme continuations either. :P
15:53:24 <BMeph> psygnisfive: In #haskell, you can't hardly be taken seriously w/o writing a monad tutorial... ;)
15:53:31 <dolio> vixey: Oleg wrote (part of) The Reasoned Schemer!
15:53:32 <psygnisfive> i get the idea of a continuation but scheme's notation confuses me.
15:53:45 <Axman6> BMeph: heh
15:53:51 <vixey> dolio, even Amr Sabry was in on it :)
15:53:52 <psygnisfive> luqui: maybe i should maybe i should
15:54:00 <psygnisfive> ok well thank you :p
15:54:08 <vixey> it is a seriously cool book
15:54:13 <Axman6> @remember <BMeph> psygnisfive: In #haskell, you can't hardly be taken seriously w/o writing a monad tutorial...
15:54:13 <lambdabot> Nice!
15:54:14 <luqui> psygnisfive, no love for the schemer in #haskell :-P
15:54:21 <olsner> the obvious solution is for you to write a monads-in-scheme tutorial then solve the problem with monads
15:54:28 <psygnisfive> no schemers in #scheme :(
15:54:33 <psygnisfive> none that reply anyway
15:54:48 <vixey> haha
15:54:57 <psygnisfive> plus, haskellers get functional programming way better i suspect
15:55:05 <vixey> #haskell is taking over scheme
15:55:18 <roconnor> \join #scheme
15:55:23 <vixey> not the first time scheme people have come in asking haskell stuff
15:55:30 <Axman6> let's all join #scheme and beat 'em up and take over their turf!
15:55:34 * roconnor goes to take over
15:55:35 <Giraffe> hahahaha
15:55:41 <lilac> psygnisfive: i don't think you need continuations for Maybe.
15:55:44 * luqui takes Axman6's offer
15:55:59 <roconnor> soon #scheme will have 600 nicks
15:56:03 <bjorkLinux> so how many haskell programmers does it then take to write a monad tutorial?
15:56:18 <luqui> bjorkLinux, 1/3, on average
15:56:27 <yitz> we can provide \bot with a new @faq command for scheme, the opposite of the current one.
15:56:47 <bjorkLinux> damn.
15:56:52 <roconnor> yitz: what's wrong with "Yes, Haskell can do that?"
15:56:57 <olsner> @can-scheme add integers
15:56:58 <lambdabot> Unknown command, try @list
15:57:01 <roconnor> perfect for #scheme
15:57:01 <roconnor> :)
15:57:05 <psygnisfive> i could probably code this better i think
15:57:08 <yitz> hehe
15:57:10 <olsner> "No, Scheme can't do that!"
15:57:18 <idnar> mm_freak: python's reduce() is also foldl if you specify a default
15:57:27 <wagle> "Error in car, nil is not a pair"
15:57:33 <idnar> oh, whoa, was scrolled up
15:57:47 <luqui> well that #scheme run was no fun
15:57:50 <idnar> excuse the necromancy
15:57:59 <lilac> psygnisfive: can't you translate something like (letMaybe (a (foo)) (b (bar a)) (c (baz b)))) into something like (let (a' (foo)) (if a' (let a (fromJust a')) (let (b' (bar a) ... ?
15:58:02 <luqui> wagle, beh, that's just how scheme spells "Prelude.head: empty list"
15:58:29 <psygnisfive> lilac: by translate do you mean write a macro for it?
15:58:56 <idnar> wagle: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR (via pjdelport)
15:59:02 <Axman6> what do lists look like in lisp?
15:59:20 <mm_freak> idnar: indeed…  i'm not a python programmer, so i don't even know the functional things of it =)
15:59:21 <skorpan> would people just stop it with the I HERD U LIKE stuff
15:59:25 <skorpan> it's getting old
15:59:26 <wagle> idnar, lol
15:59:27 <Axman6> idnar: Pimp My Scheme?
15:59:40 <psygnisfive> ok im going to vanish for a few while i try to make my code nicer
15:59:44 <luqui> Axman6, (cons 1 (cons 2 (cons 3 (cons 4 nil)))) ?
15:59:50 <Axman6> ew
15:59:53 <luqui> Axman6, there might be sugar
15:59:58 <psygnisfive> liqui: yes
15:59:59 <Axman6> i hope so
16:00:01 <psygnisfive> (list 1 2 3 4)
16:00:10 <Axman6> hmm
16:00:15 <psygnisfive> or if you want a list literal
16:00:20 <psygnisfive> rather than using a constructor function
16:00:23 <psygnisfive> '(1 2 3 4)
16:00:39 <idnar> skorpan: some memes never die
16:01:00 <psygnisfive> skorpan: SO I HERD YOU LIEK MEMEZ
16:01:03 <Giraffe> Axman6, there is sugar
16:01:12 <Giraffe> oh god
16:01:40 <wagle> M3M35?
16:02:14 <skorpan> SO WE PUT A MEME IN YOUR MEME SO YOU CAN LOL WHILE YOU LOL
16:02:32 <p_l> ... I would expect this in #nanoha, but in #haskell !?
16:03:01 <idnar> what is #nanoha?
16:03:37 <psygnisfive> nanowrimo's little brother
16:03:49 <kpreid> what's the current recommendation for "like Prelude.lines, but on some other delimeter"?
16:03:50 <p_l> an anime channel on rizon with inapprioprate amount of SCIENCE
16:04:17 <idnar> ah, rizon
16:04:20 <grom358> Cale: http://hpaste.org/12641 , still giving me stackoverflow
16:04:22 <p_l> idnar: Science including (but not limited to) haskell
16:08:49 <Baughn> Come to think of it, didn't I first bring up haskell in the context of evaluation models for quantum physics?
16:10:00 <p_l> Baughn: I think it's easier to find a branch of science that wasn't brought up
16:10:36 <Baughn> p_l: ...no. No, it isn't.
16:11:18 <mib_t7f209> How can I apply a boolean-returning function to elements of a list alike map, returning True if each of the function results are true?
16:11:28 <mib_t7f209> I'm thinking of something like a fold
16:11:41 <Baughn> mib_t7f209: all
16:11:49 <luqui> > all even [2,4,6,8]
16:11:50 <lambdabot>   True
16:11:53 <Baughn> > all (map (== 2) [2,2,2,2])
16:11:55 <lambdabot>   Couldn't match expected type `a -> Bool'
16:11:59 <idnar> > all even [2,4,6,7]
16:12:01 <lambdabot>   False
16:12:09 <Giraffe> :type any
16:12:11 <Baughn> > all id (map (== 2) [2,2,2,2])
16:12:13 <lambdabot>   True
16:12:24 <luqui> all id = and
16:12:24 <idnar> > all (== 2) [2,2,2,2]
16:12:26 <lambdabot>   True
16:12:40 <Giraffe> > any (map even [1,3,5,7,8,9])
16:12:42 <lambdabot>   Couldn't match expected type `a -> Bool'
16:12:53 <Giraffe> > any even [1,3,5,7,8,9]
16:12:55 <lambdabot>   True
16:13:18 <luqui> @check \xs -> any id xs == or xs
16:13:20 <lambdabot>   "OK, passed 500 tests."
16:13:50 <luqui> @check \f xs -> any f xs == or (map f xs)
16:13:51 <lambdabot>       Overlapping instances for Show (a -> Bool)
16:13:51 <lambdabot>        arising from a use of...
16:13:55 <BMeph> kpreid: "It's a good idea?" ;)
16:13:59 <luqui> @check \(f :: Int -> Bool) xs -> any f xs == or (map f xs)
16:13:59 <lambdabot>   Parse error in pattern at "xs" (column 21)
16:14:10 <luqui> @check \f xs -> any f (xs :: [Int]) == or (map f xs)
16:14:11 <lambdabot>       Overlapping instances for Show (Int -> Bool)
16:14:11 <lambdabot>        arising from a use ...
16:14:27 <kpreid> BMeph: I mean "supposing you need one..."
16:14:29 <luqui> oh.  hmm.
16:15:20 <grom358> ah.. its maximum that is causing the stackoverflow
16:15:30 <grom358> > maximum [1..999999]
16:15:32 <lambdabot>   * Exception: stack overflow
16:15:47 <idnar> @src maximum
16:15:48 <lambdabot> maximum [] = undefined
16:15:48 <lambdabot> maximum xs = foldl1 max xs
16:15:55 <luqui> grom358, compiling with optimizations will fix that.
16:16:06 <luqui> grom358, or you could use foldl' max
16:16:27 <idnar> @type foldl1'
16:16:28 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:16:42 <luqui> oh, I thought foldl1' didn't exist
16:16:53 <luqui> > foldl1' max [1..999999]
16:16:54 <lambdabot>   999999
16:16:59 <grom358> what module is foldl1' ?
16:17:00 <BMeph> kpreid: Do you mean is there an "official" name for it, is there a ticket for getting it into GHC, or what?  "MOAR KLEWZ PLZKTHXBAI!" ;)
16:17:06 <idnar> @index foldl'1
16:17:06 <lambdabot> bzzt
16:17:06 <idnar> err
16:17:06 <luqui> @index foldl1'
16:17:07 <lambdabot> Data.List
16:17:19 <idnar> luqui: foldl' max would be awkward to use
16:17:22 <kpreid> BMeph: I mean: I need it in a program. What code should I write in?
16:17:31 <luqui> idnar, foldl' max minBound ? :-)
16:17:59 <idnar> luqui: wouldn't work for Integer
16:18:07 <luqui> thus the smiley
16:18:16 <idnar> heh
16:18:16 <luqui> foldl1' is clearly the best option
16:18:25 <BMeph> grom358: No, it's thunks that are causing the SOF. Although, some guys like a girl with junk in her thunk. Or is that something else... ;p
16:18:46 <luqui> ew
16:18:56 <mib_t7f209> Is it possible to insert data into records without doing the whole fieldname = "value", otherfield = "othervalue" thing?
16:18:59 <BMeph> @vixen Do you have junk in your thunk?
16:19:00 <lambdabot> i'll hafta plead the fifth on that one.
16:19:04 <BMeph> lol
16:19:04 <mib_t7f209> i.e. a way to just type the values
16:19:07 <grom358> BMeph: even with http://hpaste.org/12641 ?
16:19:12 <luqui> mib_t7f209, you can use poitional notation too
16:19:12 <mauke> mib_t7f209: yes, just use the constructor name
16:19:37 <lilac> @vixen can i take off your brackets?
16:19:37 <lambdabot> what good would it do for me to take it off? you can't see me anyhow
16:19:37 <luqui> mib_t7f209, data Foo = Foo { x :: Int, y :: Int }    Foo 4 5 = Foo { x = 4, y = 5 }
16:20:14 <mib_t7f209> Ah, thanks
16:21:21 <Taejo> is it possible to build a recent Cabal with GHC 6.4.1?
16:21:57 <luqui> Taejo, gah!  unlikely...
16:22:01 <gwern> Taejo: ah... I would advise against it
16:22:01 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:22:05 <luqui> 6.4 is ancient
16:22:16 <gwern> yeah. 6.4 was what, '03?
16:22:17 <gwern> @messages
16:22:18 <lambdabot> ski_ said 18h 29m 5s ago: actually, that quote is due to Dave Benjamin, not me .. i've just quoted it here sometime and someone apparently thought i invented it, and promptly inserted it into
16:22:18 <lambdabot> lambdabot
16:22:18 <lambdabot> SamB_XP said 11h 19m 54s ago: I wants bang patterns in ">"
16:22:44 <Taejo> well, I'm forced to use ubuntu dapper, and I've been unable to install a recent ghc binary
16:23:06 <gwern> SamB_XP: mueval turns on all extensions; are you sure bang patterns are supported in ghci? if ghci doesnt support'em, it seems a bit much to ask mueval or hint to...
16:23:06 <centrinia> Download the GHC binary and install it locally.
16:23:52 <Taejo> centrinia: I tried that... ./configure fails because it can't find libgmp.so.3 (which is installed in /usr/lib)
16:24:13 <centrinia> Install GMP locally. :p
16:24:47 <Taejo> centrinia: I think I might just migrate my work machine to dwm or somesuch
16:26:01 <dcoutts> Taejo: should work to build Cabal-1.6.x with ghc-6.4.x
16:26:10 <luqui> gwern, ghci supports bang patterns
16:26:19 <mc__> good morning
16:27:07 <Taejo> dcoutts: ghc --make Setup says Could not find module `System.FilePath'
16:27:37 <gwern> @seen dons
16:27:38 <lambdabot> dons is in #haskell, #xmonad, #darcs, #concatenative, #ghc and #arch-haskell. I last heard dons speak 6h 18m 38s ago.
16:27:42 <gwern> @seen sjanssen
16:27:42 <lambdabot> sjanssen is in #darcs, #haskell-blah, #xmonad and #haskell. I last heard sjanssen speak 38m 40s ago.
16:27:49 <ikkebr> @seen ikkebr
16:27:49 <lambdabot> You are in #haskell. I last heard you speak just now.
16:27:57 <eu-prleu-peupeu> http://conal.net/blog/posts/sequences-streams-and-segments/
16:28:00 <luqui> Taejo, cabal install filepath
16:28:02 <gwern> @where me
16:28:02 <lambdabot> I know nothing about me.
16:28:03 <lambdabot> Title: Conal Elliott » Sequences, streams, and segments
16:28:04 <eu-prleu-peupeu> i would really like to understand this :/
16:28:06 <gwern> @where you
16:28:06 <lambdabot> I'm right here, silly.
16:28:14 <gwern> @where I
16:28:14 <lambdabot> You're right here with me. Where else?
16:28:31 <ikkebr> @where dons
16:28:32 <lambdabot> http://www.cse.unsw.edu.au/~dons
16:28:37 <luqui> eu-prleu-peupeu, what's the trouble you're having?
16:28:59 <eu-prleu-peupeu> several ones luqui
16:29:06 <Taejo> luqui: will old versions of Cabal be able to build that?
16:29:06 <eu-prleu-peupeu> first i dont know what an applicative functor is
16:29:15 <eu-prleu-peupeu> i can barely grasp the "functor" concept
16:29:19 <luqui> Taejo, dunno. tias?
16:29:39 <luqui> eu-prleu-peupeu, ah.  you should try.  Functor's a big deal :-)
16:29:55 <cknapp> @quote
16:29:55 <luqui> eu-prleu-peupeu, I think of a functor as a  "container"
16:29:55 <lambdabot> sjanssen says: there should be a #haskell, a channel to go for support for Haskell ...
16:29:56 <eu-prleu-peupeu> then i can't understand comonads... and i can't see how do the monad =<< operator relates do the >>= operator :/
16:30:11 <mauke> eu-prleu-peupeu: http://dis.4chan.org/read/prog/1227936688/
16:30:12 <lambdabot> Title: 4chan BBS - Monadic Linear Algebra
16:30:15 <tomh> @quote
16:30:15 <lambdabot> pzpz says: I can't see how anyone can use a laptop without the nipple
16:30:17 <luqui> eu-prleu-peupeu, where you can apply some function to every element
16:30:36 <gwern> mauke: oh how silly of me to haunt proggit and #haskell, when 4chan has all the answers!
16:30:43 <luqui> eu-prleu-peupeu, for example, a list is a functor, where fmap = map
16:31:39 <eu-prleu-peupeu> yes, i see
16:31:53 <gwern> @remember Anonymous A monad is a functor from a category to itself. Honestly, I don't know how I could make this any simpler.
16:31:53 <lambdabot> Done.
16:32:01 <luqui> eu-prleu-peupeu, a trickier one is, for example, functions from Bool
16:32:11 <eu-prleu-peupeu> so, if i define the method fmap for a container, i can say that the container is a functor
16:32:15 <luqui> eu-prleu-peupeu, that's the same as a two-element list, no  (one element for True, one for False)
16:32:19 <luqui> eu-prleu-peupeu, yeah
16:32:19 <cknapp> Gwern: That's a great quote
16:33:05 <eu-prleu-peupeu> what is an applicative functor ?
16:33:06 <eu-prleu-peupeu> :/
16:33:07 <gwern> cknapp: what about 'I'd love to explain to you how to write hello world in Haskell, but first let me introduce you to basic category theory.
16:33:10 <gwern> ?
16:33:11 <luqui> eu-prleu-peupeu, okay, so that takes some getting used to, but it turns out in Haskell *most* types are functors.
16:33:19 <cknapp> That's a good one.
16:33:20 <luqui> eu-prleu-peupeu, an applicative functor is a functor with two additional operations
16:33:25 <cknapp> Brilliant, in fact
16:33:53 <luqui> eu-prleu-peupeu, an introduction operation "pure", where you can put something into it.  eg. for Maybe, pure = Just
16:34:07 <luqui> eu-prleu-peupeu, for list, pure x = [x]
16:34:12 <mauke> pure is a virtual constructor
16:34:22 <gwern> @remember Anonymous I'd love to explain to you how to write hello world in Haskell, but first let me introduce you to basic category theory.
16:34:22 <lambdabot> Done.
16:34:25 <gwern> @flush
16:34:41 <cknapp> what does @flush do?
16:34:53 <luqui> eu-prleu-peupeu, the other operation is a combination operation: f a -> f b -> f (a,b)
16:34:56 <mib_t7f209> I would guess commit it to HDD
16:35:02 <gwern> cknapp: it flushes the toilet in lispy's apartment. he sometimes forgets
16:35:06 <luqui> (it is spelled a little different in Control.Applicative, but it's the same thing)
16:35:15 <eu-prleu-peupeu> oh
16:35:22 <eu-prleu-peupeu> now i see why its called "Applicative"
16:35:26 <gwern> cknapp: there's also an @underwear, which makes lambdabot send him an email reminding him to change his smallclothes
16:35:26 <centrinia> Is it true that before Haskell incorporated the IO monad, you can only output a single string for an entire program?
16:35:33 <cknapp> gwern. I see...
16:35:35 <eu-prleu-peupeu> because you can "apply" the container to any given object
16:35:37 <mib_t7f209> Instance of Num "Mark" required for definition of "record"    anyone got any idea what this means?
16:35:54 <centrinia> Was main :: String ?
16:35:56 <Botje> mib_t7f209: it means you're tring to use a type called Mark as a number somewhere
16:35:57 <mauke> mib_t7f209: you're using numbers in the wrong place ... or something
16:35:59 <eu-prleu-peupeu> as long as the container defines the "applicative functor" methods
16:36:06 <Botje> centrinia: no, main :: Response -> Request
16:36:07 <gwern> centrinia: no, main was like 'String -> String'
16:36:14 <gwern> the stream-based system
16:36:14 <centrinia> Oh.
16:36:26 <eu-prleu-peupeu> hmm yes, combination appears quite often in type classes, i guess its a really powerfull mathematical operation :/
16:36:27 <gwern> or something. who knows, that was like 20 years ago
16:36:51 <eu-prleu-peupeu> i wonder why its not taught in elementary school... like multiplication or something
16:36:52 <luqui> eu-prleu-peupeu, perhaps.  I think it's the existence of (<*>) :: f (a -> b) -> f a -> f b    (you can apply a function AF to an object AF)
16:36:58 <Axman6> @src Applicative
16:36:58 <lambdabot> class Functor f => Applicative f where
16:36:58 <lambdabot>     pure  :: a -> f a
16:36:58 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:37:13 <Axman6> pure is like return?
16:37:16 <mib_t7f209> Thanks all
16:37:19 <luqui> Axman6, pure *is* return! :-)
16:37:20 <mauke> Axman6: exactly
16:37:21 <centrinia> Category theory is much simpler than arithmetic. :)
16:37:38 <cknapp> Yeah, none of these special cases... like, you know, integers
16:37:38 <idnar> and <*> is ap
16:37:43 <Axman6> whoot. and <*> is... some lift type thing?
16:37:55 <luqui> eu-prleu-peupeu, then a monad is just an applicative functor with one more operation:  join :: f (f a) -> f a
16:38:02 <Axman6> ap. right
16:38:05 <Axman6> :t ap
16:38:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:38:12 <eu-prleu-peupeu> ah yes
16:38:13 <eu-prleu-peupeu> indeed
16:38:15 <eu-prleu-peupeu> :)
16:38:23 <cknapp> Oh, dear... I should be doing graph theory homework, and instead I'm making category theory jokes with a bunch of programmers...
16:38:30 <Axman6> > ap (Just (+1)) (Just 3)
16:38:32 <lambdabot>   Just 4
16:38:41 <eu-prleu-peupeu> for a monad i only need to define the return (which is the pure in applicative functor), and the composition, right ?
16:38:45 <centrinia> You can make graph theory jokes with a bunch of programmers...
16:38:48 <luqui> cknapp, well category theory is really just generalized abstract graph theory
16:38:49 <Axman6> > Just (+1) <*> Just 3
16:38:50 <lambdabot>   Just 4
16:38:54 <mauke> > ap [(* 2), sqrt] [1 .. 4]
16:38:55 <Axman6> how handeh
16:38:55 <lambdabot>   [2.0,4.0,6.0,8.0,1.0,1.4142135623730951,1.7320508075688772,2.0]
16:38:58 <cknapp> luqui: or generalized abstract algebra...
16:39:04 <cknapp> luqui: or generalized abstract topology
16:39:07 <cknapp> or...
16:39:16 <mauke> generalized abstract nonsense
16:39:17 <idnar> Axman6: try something like this:
16:39:25 <luqui> the LUB of "graph theory", "algebra", "topology", ... is "nonsense"
16:39:27 <cknapp> forgot about that one, mauke
16:39:29 <Axman6> :t (<$>)
16:39:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:39:31 <luqui> thus we have derived the familiar phrase
16:39:32 <idnar> > (+) <$> [1,1,1] <*> [1,2,3]
16:39:33 <lambdabot>   [2,3,4,2,3,4,2,3,4]
16:39:34 * BMeph wants to smack every programmer who insists that you can't have an integer in a float variable...
16:39:55 <idnar> > liftA2 (+) [1,1,1] [1,2,3]
16:39:57 <lambdabot>   [2,3,4,2,3,4,2,3,4]
16:40:03 <luqui> eu-prleu-peupeu, for monad all you need is fmap, return (pure), and join; or alternatively (>>=) and return
16:40:27 <centrinia> Q: Why can't Euler cross the bridge? A: Because he already crossed it once.
16:40:32 <luqui> eu-prleu-peupeu, but it's useful to think of Monad < Applicative < Functor  (where < is subclass)
16:40:35 <cknapp> The proof of the Hilbert Basis Theorem is not mathematics; it is theology.
16:40:40 <idnar> actually, wait, that wasn't such a useful example
16:40:41 <cknapp> centrinia: nice.
16:40:47 <eu-prleu-peupeu> oh, nice :D
16:40:58 <idnar> > (+) <$> ZipList [1,1,1] <*> ZipList [1,2,3]
16:41:00 <lambdabot>       No instance for (Show (ZipList a))
16:41:00 <lambdabot>        arising from a use of `show' ...
16:41:02 <centrinia> Subcategory maybe?
16:41:06 <BMeph> centrinia; s/Euler/Hamilton/, maybe? ;)
16:41:10 <tomh> whats the join, is it the same as <*> ?
16:41:26 <idnar> > getZipList $ (+) <$> ZipList [1,1,1] <*> ZipList [1,2,3]
16:41:28 <lambdabot>   [2,3,4]
16:41:33 <eu-prleu-peupeu> how does the =<< operator relates to the >>= operator ? (i know that if i think a bit on this i can get there... but, as haskell, im lazy)
16:41:34 <luqui> tomh, join is much stronger than <*>.
16:41:43 <tomh> what does join do
16:41:44 <luqui> eu-prleu-peupeu, (=<<) is just flip (>>=)
16:41:50 <arjanb> @type join
16:41:50 <luqui> eu-prleu-peupeu, did you mean to say =>> ?
16:41:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:41:52 <BMeph> :t join
16:41:53 <cknapp> BMeph... I'm so sad I got that without thinking about it...
16:41:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:41:58 <centrinia> Q: Why do we see so many salesmen at our doors? A: Because they can't figure out which route is the best.
16:42:03 <BMeph> cknapp: lol
16:42:25 <tomh> O_o
16:42:34 <luqui> tomh, depends on the monad.  eg. in the list monad, join = concat
16:42:54 <BMeph> centrinia: Q: Why do we see so many salesmen at our doors? A: Because they're depending on mathematicians to tell them the best route to take! ;)
16:42:58 <tomh> ok
16:43:01 <mauke> just read the 4chan thread, it has examples :-)
16:43:30 <eu-prleu-peupeu> oh, i see
16:43:48 <eu-prleu-peupeu> i was looking at (a->m b) -> (m a->m b)
16:43:53 <eu-prleu-peupeu> and wasn't quite getting it
16:43:56 <luqui> eu-prleu-peupeu, oh that one.
16:44:01 <luqui> yeah that's the pretty way to put it :-)
16:44:07 <eu-prleu-peupeu>  (=<<) :: (Monad m) => (a -> m b) -> (m a -> m b)
16:44:12 <luqui> but =<< is like an application operator for monads
16:44:18 <mib_t7f209> How can I extract the element from a list?
16:44:22 <mib_t7f209> nth element*
16:44:26 <eu-prleu-peupeu> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
16:44:29 <luqui> > [1,2,3,4,5] !! 3
16:44:29 <mib_t7f209> e.g. the 3rd element
16:44:30 <lambdabot>   4
16:44:32 <Cale> mib_t7f209: xs !! n
16:44:33 <BMeph> luqui: It's the kleisli kleene operator. :)
16:44:50 <idnar> @type (<$)
16:44:52 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:44:55 <luqui> BMeph, yeah, saying "kleisli" generally makes people learning this stuff feel *right* at home :-)
16:45:01 <idnar> haha
16:45:22 <BMeph> luqui: MWUHUHUHAHAHAHA! >:)
16:45:26 <luqui> eg. putStrLn =<< getLine
16:45:38 <lilac> (=<<) is /basically/ the same thing as fmap, <$>, . and $ :)
16:45:50 <luqui> haha
16:46:04 <luqui> "mathematics is about giving different things the same name"
16:46:18 <idnar> "Two constructions introduced below, the Kleisli category and the category of Eilenberg-Moore algebras, are extremal solutions of the problem of constructing an adjunction that gives rise to a given monad."
16:46:32 <idnar> okay, now is probably not the time for me to be trying to figure the Kleisli category out
16:46:33 <cknapp> Or the same thing different names...
16:46:47 <luqui> cknapp, that's philosophy
16:46:55 <lilac> perhaps i forgot ^>
16:47:02 <BMeph> idnar: What - are you a Freyd of Kleisli cats? ;p
16:47:05 <luqui> philosophy and mathematics are dual :-)
16:47:10 <cknapp> luqui: Which is a superset of math
16:47:21 <centrinia> People who want to learn about monads should learn about the Kleisli category and the Eilenberg-Moore algebras. :)
16:47:30 <luqui> centrinia, totally!
16:47:43 <cknapp> Just because people expect math to be "useful" doesn't make it any less abstract and nonsensical...
16:47:45 <eu-prleu-peupeu> lilac: now you confused me
16:47:47 <luqui> most people don't want to learn about monads though, they just want to use them
16:47:56 <lilac> luqui: dual in the sense that philosophers follow questions towards answers, and mathematicians follow answers towards questions?
16:48:19 <centrinia> Most people don't want to learn about $TOPIC though, they just want to use it.
16:48:29 <luqui> lilac, that sounds like an operational distinction, which we should abstract over
16:48:37 <idnar> BMeph: har
16:48:40 <luqui> centrinia, not I!
16:48:45 <Apocalisp> centrinia, most people don't want to learn the meaning of concepts, they just want to use them.
16:48:45 <idnar> BMeph: I really know nothing about category theory
16:48:54 <luqui> I wouldn't have studies proof theory if I wanted to use anything
16:49:02 <BMeph> centrinia, luqui: ddaruis is (the last I heard) firmly of the opinion that adjunctions should be learned first. :)
16:49:24 <luqui> perhaps.  I don't get adjunctions.  :-(
16:49:28 <bjorkLinux> Apocalisp, that steepens the learning curve. and where do you stop?
16:49:38 <olsner> doesn't adjunctions require you to know about functors?
16:49:38 <bjorkLinux> meaning of meaning of meaning of ...
16:49:50 <Apocalisp> bjorkLinux, stop at percepts.
16:50:05 <luqui> olsner, yeah.  but Functors are one of the elementary concepts of category theory.
16:50:08 <cknapp> idnar: /I/ wouldn't expect you to learn category theory... unless you /really/ want to understand monads
16:50:33 <idnar> cknapp: I want to understand people /talking/ about monads :P
16:50:39 <bjorkLinux> is category theory behind monads?
16:50:43 <luqui> yep
16:50:46 <lilac> eu-prleu-peupeu: well, (.) is fmap for ((->) a), and ($) is fmap for the identity functor
16:50:48 <cknapp> Yes... monads are a math concept...
16:50:49 <BMeph> centrinia: "<centrinia> Most people don't want to learn about $TOPIC though, they just want to use it." <- you could substitute "a person" for that $TOPIC, too, sadly. :|
16:50:55 <idnar> cknapp: also, maths is awesome, I just don't spend enough time on it
16:50:56 <bjorkLinux> oh. pity.
16:51:05 <luqui> BMeph, :-(
16:51:13 <cknapp> haskell stole them and gave them tot he masses "Let them eat monads!" they said.
16:51:13 <lilac> eu-prleu-peupeu: $ is application, and =<< is monadic application
16:51:19 <bjorkLinux> i see why people stampede to the javas and the c++s.
16:51:25 <luqui> idnar, arguably neither does Paul Erdos
16:51:29 <centrinia> BMeph: I agree. :(
16:51:35 <idnar> cknapp: but, heh; just about everything I know about maths I learned from reading GEB :P
16:51:47 <cknapp> Well... luqui, I don't think he spends any time on math...
16:51:57 <lilac> eu-prleu-peupeu: ($) is identity, and pure and return are monadic identity in some sense
16:52:01 <luqui> bjorkLinux, because Haskell is avoiding success at all costs?
16:52:05 <cknapp> idnar, ah. Well... pick up a text book or two...
16:52:17 <lilac> eu-prleu-peupeu: so return, pure, ($), (.), fmap, etc. are really all just the same thing :)
16:52:23 * lilac waves hands
16:52:41 <idnar> luqui: isn't he dead?
16:52:42 * pumpkin_ is trying to figure out a separation function :o
16:52:44 <bjorkLinux> luqui, no. because it has a very intimidating foundation.
16:52:47 <luqui> idnar, er, did?
16:52:54 <idnar> luqui: hehe
16:53:08 <Apocalisp> bjorkLinux, c++ has the same foundation. Haskell's just up front about it.
16:53:22 <centrinia> People don't want to pay up front.
16:53:32 <bjorkLinux> i don't see how though.
16:53:41 <Elly> it is much worse not to have a foundation
16:53:43 <luqui> C++ is founded on category theory like Russia is founded on communism.
16:53:49 <Elly> then you end up with a language which is very difficult to reason about
16:53:55 <idnar> cknapp: textbooks and me tend not to get along
16:54:03 <lilac> c++ is founded on category theory like flies are founded on spiders webs
16:54:08 <cknapp> A computer is /still/ a general purpose algorithm processor...
16:54:11 <bjorkLinux> Elly, how often are languages reasoned about?
16:54:26 <bjorkLinux> i thought one needed to use them!
16:54:33 <bjorkLinux> not chew it's cud.
16:54:36 <eu-prleu-peupeu> this really scratches my brain
16:54:40 <Botje> bjorkLinux: way too little, dammit :)
16:55:10 <Elly> bjorkLinux: == Botje, way too infrequently
16:55:28 <bjorkLinux> what good would it do?
16:55:40 <cknapp> An algorithm can only process an algorithm correctly if it is written correctly. An algorithm can onyl be known to be correct by reasoning about it
16:55:42 <centrinia> bjorkLinux: Haskell programs are easier to reason with and do deeper analyses than C++ programs.
16:55:44 <Apocalisp> bjorkLinux: Well, what kind of activity is programming, if it's not reasoning?
16:55:51 <cknapp> An algorithm = a computer...
16:55:52 <luqui> bjorkLinux, you are being sarcastic?
16:55:54 <pumpkin_> so say I have a function separation :: (Num a) => ([a], [a]) -> a ... I want it to take in two lists of numbers and output the best point to separate the two sets (lists) of numbers such that as many as possible of each fall on only one side of the separation point
16:55:59 <bjorkLinux> luqui, not at all.
16:56:01 <Elly> I worked at Green Hills Software over the last summer. One of their big products is an ultra-reliable realtime OS. It absolutely can't fail (it's used for aircraft avionics and such), and their number one headache is trying to assert that it's solid because it's written largely in C
16:56:18 <bjorkLinux> i'm befuddled by haskell's academic nature.
16:56:19 <pumpkin_> bjorkLinux: *its ;)
16:56:28 * luqui is reminded of a favorite quote "if it doesn't need to be correct, it can be made arbitrarily fast"
16:56:31 <Botje> pumpkin_: what now?
16:56:31 <Elly> they have a large amount of work devoted to various formal and semiformal proofs of correctness, but they are built on a foundation of sand because thy are about a C program :P
16:56:35 <Elly> they, even
16:56:52 <Botje> bjorkLinux: ever tried to parse C or Java and do something useful with it?
16:56:53 <bjorkLinux> Elly, why didn't they use Ada?
16:56:55 <luqui> bjorkLinux, reasoning about programs allows you to see/prove that they do what you want them to
16:57:00 <Botje> like doing a CPS transformation?
16:57:01 <lilac> cknapp: and the kicker: no algorithm can reason about the correctness of all other algorithms (a human == an algorithm)
16:57:08 <Elly> bjorkLinux: Ada is a dead language
16:57:11 <bjorkLinux>  :)
16:57:16 <cknapp> lilac: true.
16:57:16 <Apocalisp> Noo!!
16:57:26 <Elly> there are no useable Ada compilers, IIRC, targeting many of their platforms
16:57:27 <bjorkLinux> as of 2005 they were still writing standards for it
16:57:31 <Apocalisp> Ada, you can't die!
16:57:43 <Elly> bjorkLinux: there's also a COBOL 2003 standard
16:57:50 <bjorkLinux> eww stop that!
16:57:57 <roconnor> No, it's COBAL 03 standard
16:58:00 <pumpkin_> Botje: say I have separation ([1,2,3,4], [5,6,7]), then a good separation point is anywhere between 4 and 5, because all of one class falls on one side of the separator and all of the other class falls on the other. separation ([1,2,3], [3,4,5]) is harder, because you necessarily have ambiguity, but the most separation is achieved when you hit 3
16:58:02 <Elly> just because it's dead doesn't mean the people using it know that
16:58:04 <roconnor> or
16:58:08 <roconnor> COBAL 103 standard
16:58:14 <Elly> roconnor: COBAL?
16:58:21 <centrinia> Cabal?
16:58:23 <roconnor> er
16:58:24 <Elly> ITYM COBOL, but yes :P
16:58:25 <roconnor> COBOL
16:58:26 <pumpkin_> cobol
16:58:28 <Elly> mmm, y2k joke
16:58:34 <roconnor> And on occasion
16:58:38 <Elly> ah, it's COBOL 2002, my mistake
16:58:40 <roconnor> COBOL :3 standard
16:58:51 <Elly> "The COBOL2002 standard supports Unicode, XML generation and parsing, calling conventions to and from non-COBOL languages such as C, and support for execution within framework environments such as Microsoft's .NET and Java (including COBOL instantiated as Enterprise JavaBeans)."
16:58:55 <roconnor> > succ '0'
16:58:57 <lambdabot>   '1'
16:58:57 <Elly> wow...it's a perfect storm of failure
16:59:02 <roconnor> > succ '9'
16:59:04 <lambdabot>   ':'
16:59:14 <idnar> Elly: oh dear god, I just burst into tears
16:59:17 <pumpkin_> Botje: actually, maybe my initial complaint with the naive method is unfounded (i.e. test every number in both sets and see how many fall on each side), but I'm open to suggestions on doing it efficiently
16:59:26 <centrinia> > succ (chr (2^16-1))
16:59:28 <lambdabot>   '\65536'
16:59:37 <roconnor> :)
16:59:46 <pumpkin_> @instances Bounded
16:59:47 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
16:59:51 <Botje> pumpkin_: i'd start with the naive approach
16:59:59 <idnar> Elly: and here I thought nothing could be worse than Xbase++
16:59:59 <jql> actually, XML is the only thing COBOL should ever do
16:59:59 <luqui> > maxBound :: Char
17:00:01 <lambdabot>   '\1114111'
17:00:07 <pumpkin_> what's Dual, and why are only 2- and 3-tuples bounded?
17:00:07 <luqui> > succ '\1114111'
17:00:09 <lambdabot>   * Exception: Prelude.Enum.Char.succ: bad argument
17:00:11 <jql> they belong together
17:00:13 <Elly> idnar: ha ha ha
17:00:18 <bjorkLinux> hmm. so luqui have you reasoned about a program lately?
17:00:25 <pumpkin_> bjorkLinux: we do it all the time
17:00:25 <luqui> bjorkLinux, absolutely
17:00:28 <bjorkLinux> and what did you use, a large table and paper?
17:00:33 <pumpkin_> bjorkLinux: haskell
17:00:34 <pumpkin_> ;)
17:00:37 <bjorkLinux> hehehe
17:00:42 <luqui> bjorkLinux, I am getting in the habit of machine-verified proofs of correctness
17:00:42 <pumpkin_> bjorkLinux: or a whiteboard, usually
17:00:43 <bjorkLinux> if it runs it's proven?
17:00:45 <luqui> but I'm a total nerd
17:00:49 * Elly has been reasoning very carefully about an optimizer for about six days now
17:00:49 <idnar> @index Dual
17:00:50 <lambdabot> bzzt
17:01:00 <centrinia> > succ (maxBound :: Int)
17:01:00 <bjorkLinux> machine verified. hmm.
17:01:01 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
17:01:09 <Elly> machine-verified proofs of correctness: awesome
17:01:12 <bjorkLinux> and how do you verify that machine's verification is correct?
17:01:19 <centrinia> > succ (pred (maxBound :: Int))
17:01:20 <lambdabot>   9223372036854775807
17:01:21 <pumpkin_> bjorkLinux: you make a mathematical proof of it
17:01:22 <Elly> bjorkLinux: prove your prover ;)
17:01:24 <cknapp> You prove that by hand.
17:01:25 <pumpkin_> and assume your axioms are correct
17:01:27 <luqui> bjorkLinux, you trust it with your heart.
17:01:29 <bjorkLinux> gaaa!
17:01:34 <idnar> pumpkin_: Dual of a monoid is the same monoid with mappend flipped
17:01:37 <mauke> bjorkLinux: how do you prove your sanity?
17:01:39 <luqui> bjorkLinux, but a lot of people trust coq (the verification system)
17:01:40 <cknapp> bjorkLunux, check out A=B
17:01:54 <idnar> > [1,2] `mappend` [3,4]
17:01:55 <lambdabot>   [1,2,3,4]
17:02:01 <pumpkin_> bjorkLinux: how do you prove anything? you make good arguments for its correctness :P
17:02:02 <centrinia> Coq sounds inappropriate.
17:02:07 * pumpkin_ loves Coq
17:02:11 <pumpkin_> mmm
17:02:16 <luqui> centrinia, i am currently working on a... er... coq extension
17:02:19 <pumpkin_> lol
17:02:22 * centrinia loves Coq, HOL, and Isabelle.
17:02:26 <pumpkin_> I think I got an email about that luqui
17:02:29 <bjorkLinux> pumpkin_, mathematically? with logic.
17:02:34 <idnar> > Dual $ (Dual [1,2]) `mappend` (Dual [3,4])
17:02:35 <lambdabot>   Dual {getDual = Dual {getDual = [3,4,1,2]}}
17:02:38 <idnar> > getDual $ (Dual [1,2]) `mappend` (Dual [3,4])
17:02:39 <lambdabot>   [3,4,1,2]
17:02:52 <pumpkin_> idnar: *whoosh* /me watches it fly over his head
17:03:04 <Elly> bjorkLinux: of course with logic
17:03:07 <pumpkin_> idnar: I'll try that again in a month :P
17:03:18 <idnar> pumpkin_: well, compare with:
17:03:27 <idnar> > [1,2] `mappend` [3,4]
17:03:29 <lambdabot>   [1,2,3,4]
17:03:31 <BMeph> luqui: Giving Coq a broader application? ;)
17:03:38 <pumpkin_> > Dual [1,2]
17:03:40 <lambdabot>   Dual {getDual = [1,2]}
17:03:40 <Elly> you are terrible people
17:03:41 <bjorkLinux> what then bothers me is one takes logic for granted.
17:03:52 <Elly> bjorkLinux: you mean the correctness thereof?
17:03:52 <luqui> BMeph, nice =)
17:03:53 <idnar> pumpkin_: it's basically just a simple wrapper
17:03:56 <pumpkin_> bjorkLinux: you take your senses for granted
17:03:59 <luqui> bjorkLinux, we have to!
17:04:04 <Elly> bjorkLinux: intuitionistic logic is basically an attempt to build logic from the ground up
17:04:04 <pumpkin_> bjorkLinux: if you remove our assumptions, we have nothing :P
17:04:12 <cknapp> bjorkLinux: You /must/ start with something.
17:04:16 <luqui> bjorkLinux, thank you Godel...
17:04:17 <Elly> it's actually cool how few axioms they need to have a useful system in nwhich one can do model-checking
17:04:29 <idnar> pumpkin_: the Bounded instance for Dual just forwards to the Bounded instance of the type being wrapped
17:04:30 <Elly> but yes, as luqui said, Godel's incompleteness theorem intervenes
17:04:39 <bjorkLinux> so following that reasoning, we take X for granted, use X to prove y is correct, and point to x saying it said so, so it must be right.
17:04:39 <pumpkin_> I need no axioms in my proofs! my proofs are absolute
17:04:44 <pumpkin_> idnar: ah, okay
17:04:53 <centrinia> bjorkLinux: Exactly. :)
17:04:53 <pumpkin_> bjorkLinux: yes, we say that it's right given x
17:04:58 <pumpkin_> bjorkLinux: it's the best we can do
17:04:59 <kynky> circular'
17:05:02 <Elly> bjorkLinux: ideally, X is a smaller set of assumptions than Y, which is why this is valuable :)
17:05:02 <bjorkLinux> gaa!
17:05:05 <pumpkin_> not circular
17:05:07 <idnar> > minBound :: Int
17:05:08 <lambdabot>   -9223372036854775808
17:05:09 <idnar> > minBound :: Sum Int
17:05:10 <luqui> pumpkin_, assuming modus ponens ...
17:05:11 <lambdabot>   Sum {getSum = -9223372036854775808}
17:05:15 <idnar> > minBound :: Dual (Sum Int)
17:05:17 <lambdabot>   Dual {getDual = Sum {getSum = -9223372036854775808}}
17:05:29 <cknapp> luqui: I think that's one of our assumptions :)
17:05:32 <mauke> it's newtypes all the way down
17:05:32 <Apocalisp> bjorkLinux, by what logic is it incorrect to assume that logic is valid?
17:05:35 <pumpkin_> luqui: yup
17:05:38 <bjorkLinux> this is giving me a orrible headache.
17:05:47 <bjorkLinux> Apocalisp, my heart tells me so :)
17:05:48 <mauke> that's your brain expanding
17:05:58 * luqui realizes that assuming axioms is fine, but adding the inference rule as an assumption is a bit stickier
17:06:03 <pumpkin_> bjorkLinux: you can break everything down if you question axioms, because we can't prove axioms, by definition :P they just "feel" right and reasonable
17:06:04 <Apocalisp> bjorkLinux, but how do you know it tells you so?
17:06:22 <roconnor> aren't axioms just trivial inference rules?
17:06:34 <kynky> like the child who always asks why, to every statement of fact
17:06:41 <luqui> roconnor, sure.  but inference rules are not trivial axioms :-)
17:06:43 <centrinia> How can I get programs for free (from theorems)?
17:06:47 <pumpkin_> has anyone in here ever been to #ai?
17:06:53 <luqui> @free id
17:06:54 <lambdabot> f . id = id . f
17:06:59 <Axman6> kynky: don't knock how fun that game used to be
17:07:03 <pumpkin_> there's someone in there who has absolute truth
17:07:06 <gwern> @quote gitit
17:07:06 <lambdabot> No quotes match.
17:07:07 <bjorkLinux> Apocalisp, buried in the depths of russel and whitehead on one hand, and goedel's madness inducing pamphlet, lies the real answer.
17:07:12 <gwern> @quote cabal
17:07:12 <lambdabot> musasabi says: combining Cabal and autoconf is an evil and complex art.
17:07:12 <kynky> Axman6, why ?
17:07:14 <gwern> @quote cabal
17:07:15 <lambdabot> dcoutts says: Of course Cabal-1.2 works perfectly well with all versions of GHC
17:07:17 <gwern> @quote cabal
17:07:17 <lambdabot> dcoutts says: Of course Cabal-1.2 works perfectly well with all versions of GHC
17:07:18 <pumpkin_> it's rather frustrating to talk to him, because he has absolute truth
17:07:19 <Axman6> kynky: because
17:07:20 <gwern> @quote cabal
17:07:20 <lambdabot> dcoutts says: Of course Cabal-1.2 works perfectly well with all versions of GHC
17:07:22 <luqui> @free flip
17:07:23 <gwern> bah
17:07:23 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
17:07:27 <kynky> Axman6, lol
17:07:28 <bjorkLinux> i haven't read russel and whitehead with any sense of comprehension so i shall remain silent for now.
17:07:30 <Axman6> :P
17:07:37 <pumpkin_> @faq can haskell make proofs relying on no axioms?
17:07:38 <Axman6> i know how it's played ;)
17:07:38 <lambdabot> The answer is: Yes! Haskell can do that.
17:07:42 <Botje> @quote knuth
17:07:42 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
17:07:46 <Botje> what?!
17:07:48 <pumpkin_> @faq can haskell prove our favorite axioms?
17:07:49 <lambdabot> The answer is: Yes! Haskell can do that.
17:07:52 <gwern> @remember JustinBogner gitit's 46 dependencies convinced me to install cabal-install, and now I couldn't be happier!
17:07:52 <lambdabot> Good to know.
17:07:59 <gwern> @quote cabal-install
17:07:59 <lambdabot> JustinBogner says: gitit's 46 dependencies convinced me to install cabal-install, and now I couldn't be happier!
17:08:01 <Axman6> Botje: that must be fixed!
17:08:15 <Botje> indeed!
17:08:26 <idnar> @quote
17:08:27 <lambdabot> HP says: [sweeping statements day] There's no point in running a program in 1024 threads, if the single-core C# version runs faster than that, and often it does!
17:08:27 <kynky> Axman6, best to just turn that game around, so your insulting them, and the more they ask why, the more you insult them
17:08:29 <luqui> @free s :: (a -> b -> c) -> (a -> b) -> (a -> c)
17:08:29 <lambdabot> (forall x. h . k x = p (f x) . g) => g . q = f1 . f => h . s k q = s p f1 . f
17:08:40 <Axman6> kynky: heh
17:08:48 <centrinia> @faq Can Haskell be used to prove that Haskell is inconsistent?
17:08:48 <lambdabot> The answer is: Yes! Haskell can do that.
17:08:53 <luqui> @free fix
17:08:55 <lambdabot> f . g = h . f => f (fix g) = fix h
17:09:07 <luqui> :t fix id  -- haskell is inconsistent
17:09:09 <lambdabot> forall a. a
17:09:18 <Axman6> > fix id
17:09:20 <lambdabot>   * Exception: stack overflow
17:09:25 <Axman6> that was quick :|
17:09:40 <roconnor> :t undefiend -- haskell is inconsistent
17:09:42 <lambdabot> Not in scope: `undefiend'
17:09:45 <pumpkin_> wow, I just tried running my maximum separation function through @pl :P (Botje) it was beautiful!
17:09:46 <roconnor> bah
17:09:51 <luqui> lol
17:09:51 <bjorkLinux> this is painful.
17:09:54 <pumpkin_> I had to @pl-resume twice
17:10:03 <Botje> pumpkin_: you evil evil person you
17:10:04 <idnar> pumpkin_: beautiful like an abstract painting?
17:10:07 <mmorrow> what's the (pre-pl) function?
17:10:10 <pumpkin_> idnar: I'll show you if you want
17:10:16 <pumpkin_> mmorrow: really ****ing ugly
17:10:17 <luqui> roconnor, (it is reasonably common to ask about "well what if you don't *use* undefined, thus fix id")
17:10:23 * mmorrow want to prettyprint it
17:10:25 <roconnor> ah
17:10:36 <mmorrow> pumpkin_: where can i find it?
17:11:14 <roconnor> :t let a = a in a  -- haskell is inconsistent
17:11:15 <lambdabot> forall t. t
17:11:21 <Axman6> @pl \q w e r t y u i o p -> p u i y o t r w e q
17:11:24 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .) . (((flip .) .) .)) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((
17:11:24 <lambdabot> flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .)
17:11:24 <lambdabot>  .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip (flip . (flip .) . flip . flip id)
17:11:24 <lambdabot> ))))
17:11:26 <lambdabot> optimization suspended, use @pl-resume to continue.
17:11:37 <centrinia> @pl-resume
17:11:42 <luqui> nooooooooooooO!!!!!!!!!
17:11:47 <lambdabot> flip (flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . (((((flip .) .) .) .) .)) .) . (((((((flip .) .) .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip
17:11:48 <roconnor> oooooooooooooooo!!!
17:11:50 <lambdabot> .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip
17:11:53 <idnar> holy hell
17:11:53 <lambdabot> .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip (flip . (flip .) . flip . flip id)))))
17:11:56 <lambdabot> optimization suspended, use @pl-resume to continue.
17:11:59 <Axman6> @pl \q w e r t y u i o p -> t y p e w r i t e r
17:12:00 <centrinia> Sorry.
17:12:01 <Botje> LAMBDABOT IS FLIPPING!
17:12:05 <pumpkin_> http://hpaste.org/12643 mine is prettier
17:12:06 <luqui> haha
17:12:07 <FunctorSalad>  @pl often doesn't produce the most elegant pointless version of something
17:12:09 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) .
17:12:12 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip
17:12:15 <lambdabot> .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
17:12:17 <lambdabot> optimization suspended, use @pl-resume to continue.
17:12:18 <pumpkin_> mmorrow, idnar, see my hpaste :P
17:12:23 * luqui wants to write an elegance metric
17:12:31 <FunctorSalad> (not even close)
17:12:47 <Botje> uh oh
17:12:50 * Botje runs off to bed
17:12:53 <pumpkin_> granted, my original function was butt-ugly
17:12:54 <Axman6> @pl-resume --
17:12:55 * mmorrow scrolls back
17:12:56 <Botje> have to get up in 5 hours :(
17:12:57 <Axman6> >_>
17:13:00 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . join . ((flip . ((flip . (flip .)) .) . (((flip .) .) .)) .) . (((((flip .) .)
17:13:00 <lambdabot>  .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip
17:13:00 <lambdabot> . (flip .) . ((flip .) .) . flip (flip . (flip .))))
17:13:01 <lambdabot> optimization suspended, use @pl-resume to continue.
17:13:06 <bjorkLinux> are there papers similar to lambda-the-ultimate for haskell?
17:13:08 <Axman6> mwahaha!
17:13:09 <pumpkin_> but the @pl was even better http://hpaste.org/12643 (in case anyone missed it in the @pl-galore)
17:13:09 <dolio> Can we ban Axman6? :)
17:13:15 <Axman6> i'm done now
17:13:33 <pumpkin_> Axman6: that was epic
17:13:36 <QtPlatypus> Isn't an elegance optimizer equiverlent to solving the halting problem?
17:13:50 <leimy> I've written a workable but not particularly awe inspiring "interactive" bowling score card program in haskell
17:13:54 <pumpkin_> QtPlatypus: how? depends on your definition of elegance I guess
17:13:55 <SamB> QtPlatypus: no
17:13:57 <centrinia> No, an elegance optimizer is much more difficult.
17:13:57 <Apocalisp> QtPlatypus, prove that it is.
17:13:59 <Axman6> i'm a little upset no one got the qwerty -> typewriter thing though :(
17:14:03 <pumpkin_> but it looks like an optimization problem to me
17:14:05 <SamB> because at least the idea of halting is pretty clear
17:14:15 <SamB> elegance, not so much!
17:14:38 <leimy> http://hpaste.org/12644
17:14:42 <luqui> you could just say shortness, and then it's about kolmogorov complexity, which is undecidable
17:14:45 <luqui> but that's not interesting
17:14:50 <FunctorSalad> I think QtPlatypus means that the most elegant version of something that doesn't halt would be "undefined"
17:15:02 <FunctorSalad> so halting problem reduces to elegance
17:15:03 <leimy> there's probably a ton of simplificationthat can be done.  and the exception handling for input really sucks (doesn't exist)
17:15:06 <pumpkin_> we need a definition of elegant
17:15:07 <Axman6> for those that don't know, one of the features of qwerty is that you can write typewriter in the first line, so that salesmen who couldn't type could still show off querty
17:15:26 <luqui> leimy, Oh my god I just went blind after looking at your bowlFrame function
17:15:29 <FunctorSalad> (or subst your favourite infinite loop for "undefined")
17:15:31 <Axman6> pumpkin_: the shortest expression that is still clear and easy to follow
17:15:36 <SamB> Axman6: ???
17:15:37 <leimy> luqui: yeah I didn't say it was pretty :-)
17:15:40 <SamB> I don't get it
17:15:43 <leimy> luqui: but it did use continuations :-)
17:15:56 <SamB> how does having it in the first line make that easier?
17:16:05 <pumpkin_> Axman6: yeah, but define clear and easy to follow in more exact terms :P then we can optimize over behavior-preserving transformations of the program, I guess
17:16:06 <SamB> I can't even see the letters on my keyboard anymore ...
17:16:19 <cknapp> Axman: Clearly you aren't using qwerty, sicne you misspelled it. :)
17:16:20 <Axman6> SamB: they only have to remember where the keys are on one like
17:16:21 * QtPlatypus checks his resource "Ah its proving that an expression is the most elegent version of that function is what is equiverlent to the halting problem"
17:16:24 <QtPlatypus> http://www.cs.auckland.ac.nz/~chaitin/lisp.html
17:16:31 <lambdabot> Title: Chaitin, The Limits of Mathematics
17:16:36 <leimy> luqui:  Actually I've been trying to come up with a function that does IO, and acts as a coroutine for another function that can bounce back and ask for more input.
17:16:41 <Axman6> pumpkin_: uh... exercise left to the reader
17:16:47 <leimy> Kind of like a selective form of interact when you've got line buffering :-)
17:16:49 <pumpkin_> QtPlatypus: aha, they reduce it to kolmogorov then, pretty much
17:16:52 <pumpkin_> "Call a program ``elegant'' if no smaller program has the same output"
17:17:16 <Axman6> cknapp: i did?
17:17:19 <luqui> leimy, that's one of my favorites.  I call it the coroutine monad.
17:17:23 <SamB> so s/elegant/GOLFed/
17:17:32 <luqui> leimy, will paste.
17:17:36 <idnar> leimy: lazy interact?
17:17:40 <dolio> So APL is way more elegant than Haskell?
17:17:44 <idnar> leimy: or "streaming", perhaps
17:17:47 <FunctorSalad> SamB: GOLF?
17:17:56 <cknapp> Axman6: Here:  so that salesmen who couldn't type could still show off querty
17:17:57 <idnar> OI comonad!
17:17:58 <SamB> er.
17:18:03 <cknapp> FunctorSalad: perl golf!
17:18:07 <SamB> s/elegant/golfed/
17:18:22 <Axman6> cknapp: ha, so i did.
17:18:23 <leimy> luqui: I don't have a coroutine monad yet.
17:18:27 <luqui> leimy, http://hpaste.org/12645
17:18:28 <Axman6> anyway, gotta go. later all
17:18:33 <cknapp> cheers!
17:18:41 <pumpkin_> is there an easier minimumBy function that takes a map-like function argument instead of a comparison function (that would allow you to map your list onto an instance of Ord)?
17:18:42 <leimy> luqui: wow that's pretty :-)
17:19:08 <SamB> hmm, does that paper allow CPAN usage?
17:19:15 <roconnor> @type minimumBy
17:19:16 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:19:21 <leimy> idnar: eh... I'm not sure.  See in bowling you might have to get one or two balls per frame when the frame number is < 10
17:19:25 <pumpkin_> @hoogle (Ord a) => (b -> a) -> [b] -> b
17:19:26 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
17:19:26 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
17:19:26 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
17:19:27 <luqui> leimy, isn't it? :-)  I'm seeing applications for it pretty much everywhere.
17:19:35 <leimy> a strike early terminates a frame
17:19:40 <idnar> actually, I don't understand the OI comonad at all
17:19:41 <leimy> so a Continuation seemed appropriate
17:19:43 <roconnor> pumpkin_: minimumBy (comparing f)
17:19:44 <pumpkin_> maybe comparing is what I need
17:19:46 <pumpkin_> yeah
17:19:47 <pumpkin_> cool
17:19:49 <roconnor> @type f -> minimumBy (comparing f)
17:19:50 <leimy> luqui: hmmm
17:19:51 <lambdabot> parse error on input `->'
17:19:56 <roconnor> @type \f -> minimumBy (comparing f)
17:19:57 <FunctorSalad> @t minimum . map f -- pumpkin_
17:19:57 <pumpkin_> that's even more general and elegant than making a special function for it
17:19:57 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
17:19:57 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:19:58 <SamB> idnar: all I know is that OI is dangerous
17:20:04 * pumpkin_ falls in love with haskell a little more
17:20:08 <cknapp> CPAN "Oh, sure, my code is maintainable... it's all maintained by people on CPAN"
17:20:43 <dolio> The only problem is that that recomputes f for every comparison.
17:21:04 <roconnor> dolio: why do you say that?
17:21:12 <leimy> anyway, the rules for bowling kind of suck to explain to a human
17:21:15 <FunctorSalad> dolio: mine not I think
17:21:16 <leimy> in terms of how to score it
17:21:20 <SamB> dolio: well, what would you suggest ?
17:21:28 <SamB> I'
17:21:35 <leimy> Haskell was a fun exercise, especially since I'm not sure I'd have gotten it right in C :-)
17:21:46 <SamB> I'd say go with comparing unless you find it to be actually inefficient ...
17:22:07 <pumpkin_> dolio: ?
17:22:15 <SamB> leimy: yeah, I always let the computer do that ;-P
17:22:22 <pumpkin_> dolio: the comparing function?
17:22:49 <leimy> SamB:  I was happily surprised to see that the facebook "Bowling Buddies" game gets it wrong sometimes.
17:22:53 <SamB> I guess they use those things to make sure you don't play more than you pay for
17:23:07 <dolio> @type let schwartz op f = map snd . op (comparing fst) . map (f &&& id) in schwartz (minimumBy)
17:23:08 <lambdabot>     Couldn't match expected type `[(a, b)]'
17:23:08 <lambdabot>            against inferred type `(a1, b1)'
17:23:08 <lambdabot>       Expected type: ((a1, b1) -> (a1, b1) -> Ordering)
17:25:23 <pumpkin_> *sudden silence*
17:25:34 <Apocalisp> Coq
17:25:52 <centrinia> HOL
17:25:54 <pumpkin_> the sporty coq
17:26:04 <SamB> twelf
17:26:29 <dolio> Oh, right that doesn't work for minimumBy.
17:26:35 <dolio> @type let schwartz op f = snd . op (comparing fst) . map (f &&& id) in schwartz (minimumBy)
17:26:36 <lambdabot> forall a b. (Ord a) => (b -> a) -> [b] -> b
17:26:44 <mmorrow> luqui: love that datatype (Coro). this one's cool too http://hpaste.org/12645#a1
17:27:13 <pumpkin_> dolio: oh I remember reading about that in ruby
17:27:42 <dolio> Durn different return types.
17:27:50 <idnar> @type minimumBy
17:27:50 <SamB> dolio: that's hella ugly
17:27:51 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:28:00 <mmorrow> @remember dolio let schwartz op f = snd . op (comparing fst) . map (f &&& id) in schwartz (minimumBy)
17:28:01 <lambdabot> Good to know.
17:28:20 <idnar> @type \f -> minimumBy (comparing f)
17:28:21 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
17:28:22 <gwern> mmorrow: is that randal schwart's transform?
17:28:32 <centrinia> Is the number of function applications in a pointless expression given by @pl polynomially bounded with respect to the number of function applications in the input to @pl?
17:28:34 <dolio> Is that who it's named for?
17:28:36 <luqui> mmorrow, woah... cool.
17:28:40 <mmorrow> that or it's for seeing whose schwartz iz bigger
17:28:50 <idnar> dolio: what's wrong with that? and why isn't that in some standard library? :)
17:28:59 <SamB> centrinia: you can probably write a masters thesis about that
17:29:01 <leimy> weird.. the whole program did not paste
17:29:09 <leimy> two times now :-)
17:29:10 <mmorrow> lugui: i got that idea from a similar (newtype) in category-extras
17:29:15 * SamB may exaggerate
17:29:21 <pumpkin_> idnar: I thought he said it was inefficient
17:29:26 <pumpkin_> but I may be wrong :P
17:29:28 <Apocalisp> mmorrow, I can see your schwartz is as big as mine
17:29:39 <mmorrow> hehe
17:29:41 <dolio> idnar: There's nothing wrong with it. Although you'll note I got it wrong at first, because you need a different one for sortBy than for minimumBy, etc.
17:29:49 <gwern> dolio: randall schwartz wrote a moderately famous transform in perl https://secure.wikimedia.org/wikipedia/en/wiki/Schwartzian_transform
17:29:53 <lambdabot> http://tinyurl.com/54vvkc
17:29:53 <SamB> Apocalisp: darn it, I forgot to mention spaceballs. but I guess you did it better than I would have.
17:30:00 <pumpkin_> dolio: so I'm safe with minimumBy (comparing f) ?
17:30:02 <idnar> pumpkin_: "schwartz minimumBy f" is the efficient version of "minimumBy (comparing f)"
17:30:02 <Apocalisp> tehe
17:30:04 <dolio> gwern: Yeah. That's the one.
17:30:07 <idnar> @type sortBy
17:30:07 <leimy> http://paste.lisp.org/display/71466
17:30:08 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
17:30:09 <idnar> @type minimumBy
17:30:10 <leimy> There we go
17:30:11 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:30:14 <pumpkin_> idnar: oh, hmm
17:30:21 <idnar> dolio: oh, hmm
17:30:25 <luqui> mmorrow, http://hpaste.org/12645#a2
17:30:33 * pumpkin_ is confuzzled now
17:30:50 <luqui> mmorrow, I wonder what the relationship between generalized coro and Mut is...
17:30:54 <apsod> Ugh, maybe I'm being a retard, but I can't figure out why `throw IOException` isn't type checking.
17:30:57 <mmorrow> luqui: ooh, cool
17:31:07 <leimy> Anyway, I actually used  scanl!
17:31:09 <apsod> I can't seem to throw any kind of exception :\
17:31:10 <leimy> I was so proud.
17:31:15 <centrinia> :t throw
17:31:16 <lambdabot> Not in scope: `throw'
17:31:33 <pumpkin_> :t throwAnyKindOfException
17:31:34 <lambdabot> Not in scope: `throwAnyKindOfException'
17:31:37 <apsod> throw :: Exception -> a
17:31:41 <dolio> pumpkin_: It's just somewhat less efficient, depending on how much work f does.
17:31:47 <SamB> > error "hi!"
17:31:49 <lambdabot>   * Exception: hi!
17:31:49 <BMeph> Osfameron wrote an article on usint the ol' ST on his blog about five(?) months ago. :)
17:31:50 <apsod> (I doubt Control.Exception is one of the trusted libraries loaded by lambdabot)
17:31:52 <idnar> :t IOException
17:31:53 <lambdabot> Not in scope: data constructor `IOException'
17:32:00 <centrinia> > error error
17:32:01 <lambdabot>   Couldn't match expected type `[Char]'
17:32:11 <centrinia> > error (show error)
17:32:11 <apsod> (and error is in Prelude, I think)
17:32:12 <lambdabot>       Overlapping instances for Show ([Char] -> t)
17:32:12 <lambdabot>        arising from a use ...
17:32:24 <mmorrow> luqui: hmm. i guess with Coro you just can get a Return a whereas with Mut you can get a Return a or a Return b...but i haven't explored use-cases of that (well, variations thereof) type very much though (i'd like too)
17:32:42 <BMeph> Check it out: http://osfameron.vox.com/library/post/schwartzian-transform-in-haskell.html?_c=feed-atom
17:32:51 <mmorrow> i use this function quite a bit though:
17:32:53 <lambdabot> http://tinyurl.com/6btwn2
17:33:11 <BMeph> Ah, mid-June, so six months ago, now. :)
17:33:20 <mmorrow> @let mutual f g a = f a (\b -> g b (\a -> mutual f g a))
17:33:22 <lambdabot>  Defined.
17:33:34 <luqui> :t mutual
17:33:36 <lambdabot> forall t2 t1 t3 t. (t2 -> (t1 -> t3) -> t) -> (t1 -> (t2 -> t) -> t3) -> t2 -> t
17:33:49 <mmorrow> (i had to define it like that since i'm not giving it a type sig and ghc'll get it not-quite-general-enough
17:33:51 <mmorrow> )
17:33:55 <idnar> apsod: looks to me like IOException doesn't have any constructors exported
17:34:08 <BMeph> mmorrow: Omaha just called - they want their mutual back. ;p
17:34:39 <idnar> oh, maybe I'm confused
17:34:59 <mmorrow> mutual :: (a -> (b -> s) -> r) -> (b -> (a -> r) -> s) -> a -> r
17:34:59 <mmorrow> mutual f g a = f a (\b -> mutual g f b)
17:35:24 <mmorrow> BMeph: Omaha!?! oh dear.
17:35:26 <apsod> idnar: Regardless, I can't seem to throw any exceptions listed in Control.Exception :|
17:35:40 <idnar> apsod: I don't see how to construct any of those exceptions
17:35:46 <apsod> Neither do I.
17:35:59 <mmorrow> @let unfoldr' f = mutual (\a k -> (k . f) a) (\m k -> maybe [] (\(b,a) -> b : k a) m)
17:36:00 <lambdabot>  Defined.
17:36:07 <mmorrow> @type unfoldr'
17:36:08 <lambdabot> forall a a1. (a -> Maybe (a1, a)) -> a -> [a1]
17:36:33 <idnar> apsod: oh, I see, some of them do have exported constructors
17:36:57 <idnar> apsod: try "throw (ArithException Overflow)"
17:37:10 <idnar> (for example)
17:37:17 <apsod> idnar: Yeah, that works fine. Thanks :3
17:39:49 <apsod> Also, I'm being retarded and reading the latest documentation instead that for 6.8.3.
17:40:24 <pumpkin_> :t uncurry
17:40:25 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:40:48 <pumpkin_> > uncurry (+) (1,2)
17:40:50 <lambdabot>   3
17:40:56 <pumpkin_> :t curry
17:40:57 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:41:49 <pumpkin_> > curry ((f, x), y)
17:41:50 <lambdabot>   Couldn't match expected type `(a, b) -> c'
17:41:59 <erikc> hrm, ok, sorta at my wits end
17:42:00 <pumpkin_> > curry ((x, y), z)
17:42:02 <lambdabot>   Couldn't match expected type `(a, b) -> c'
17:42:17 <pumpkin_> oh duh
17:42:57 <pumpkin_> > curry (fst) 1 2
17:42:59 <lambdabot>   1
17:43:20 <pumpkin_> @src curry
17:43:20 <lambdabot> curry f x y = f (x, y)
17:43:27 <pumpkin_> profound
17:44:11 <idnar> @src uncurry
17:44:11 <lambdabot> uncurry f p = f (fst p) (snd p)
17:44:25 <idnar> why not: uncurry f (x, y) = f x y
17:44:37 <pumpkin_> that would seem to make sense :P
17:44:47 <pumpkin_> but typewise the other definition makes more sense doesn't it?
17:44:56 <pumpkin_> @type f (x, y) = f xy
17:44:57 <pumpkin_> @type f (x, y) = f x y
17:44:58 <lambdabot> parse error on input `='
17:44:59 <lambdabot> parse error on input `='
17:45:02 <idnar> pumpkin_: they have the same types
17:45:09 <pumpkin_> oh yeah, duh
17:45:12 <pumpkin_> ignore me :P
17:45:23 <idnar> but my version has different handling of bottom, I guess
17:45:32 <idnar> uncurry f ~(x, y) = f x y or something
17:46:21 <dolio> > (\(x,y) -> 5) undefined
17:46:23 <lambdabot>   * Exception: Prelude.undefined
17:46:34 <dolio> > uncurry (curry (\(x,y) -> 5)) undefined
17:46:35 <lambdabot>   5
17:46:48 <idnar> > uncurry (const . const 5) (1, 2)
17:46:50 <lambdabot>   5
17:46:54 <idnar> > uncurry (const . const 5) undefined
17:46:55 <lambdabot>   5
17:47:02 <idnar> > let uncurry f (x, y) = f x y in uncurry (const . const 5) undefined
17:47:03 <lambdabot>   * Exception: Prelude.undefined
17:47:04 <idnar> > let uncurry f ~(x, y) = f x y in uncurry (const . const 5) undefined
17:47:06 <lambdabot>   5
17:47:08 <idnar> yay
17:47:18 <idnar> (or is that also wrong for some reason?)
17:47:57 <dmwit_> ?src uncurry
17:47:58 <lambdabot> uncurry f p = f (fst p) (snd p)
17:47:58 <dolio> > let uncurry f (x, y) = f x y in uncurry (curry (\p -> 5)) undefined
17:48:00 <lambdabot>   * Exception: Prelude.undefined
17:48:10 <dolio> > let uncurry f (x, y) = f x y in (\p -> 5) undefined
17:48:11 <lambdabot>   5
17:49:00 <dolio> Neither is wrong.
17:49:48 <idnar> dolio: "wrong" in the sense of not being equivalent to "uncurry f p = f (fst p) (snd p)"
17:50:02 <pumpkin_> > let x `shouldBe` y = x == y in 5 `shouldBe` 6
17:50:04 <lambdabot>   False
17:50:08 <pumpkin_> what the hell
17:50:09 <dolio> Oh. Well, ~(x,y) is the one that's equivalent.
17:50:18 <saml> how can I do windows tray notification stuff?
17:50:22 <idnar> dolio: okay, cool
17:50:34 <saml> in windows operating system (or cross platform), i want to notify users
17:53:17 <pumpkin_> idnar, dolio: how is that schwartz supposed to work again
17:53:48 <erikc> sigh, i have no idea how to debug this, im using (liftM fromIntegral getWord8 :: Get Int)
17:54:03 <erikc> and it is returning unexpected numbers
17:54:21 <dolio> You turn a list of as into a list of (a, f a)s, do your operation by projecting out the second value of the tuple, and then project out the first element of the tuple at the end.
17:54:50 <pumpkin_> hmm
17:55:19 <BMeph> BONUS: Check it out: http://osfameron.vox.com/library/post/schwartzian-transform-in-haskell.html?_c=feed-atom
17:55:22 <lambdabot> http://tinyurl.com/6btwn2
17:55:33 <idnar> this is also sometimes known as DSU (Decorate, Sort, Undecorate)
17:55:40 * BMeph weeps for his slow typing skills...
17:55:54 <dmwit_> idnar: Former Pythonista?
17:56:20 <BMeph> pumpkin_: Well, it's good fior you, too. :)
17:56:37 <idnar> dmwit_: current Pythonista (although I thought that name came from Lisp)
17:58:37 <grom358> okay.. my python version takes 2 minutes.. my haskell version (http://hpaste.org/12641) is taking over 15 minutes (I terminated it).
18:00:03 <BMeph> grom358: hpaste? :)
18:00:23 <Armored_Azrael> Hey, does anyone know any QP packages for haskell?
18:00:29 <grom358> BMeph: http://hpaste.org/12641#a1
18:00:30 <gwern> QP?
18:00:38 <Armored_Azrael> gwern: Quadratic Programming
18:00:39 <BMeph> grom358: Er, hpaste (or equiv) for the Python, I meant. ;p
18:00:47 <mmorrow> oh, i thought dolio was making a joke by referencing spaceballs...
18:01:04 <dolio> The combination is 12345.
18:01:40 <Armored_Azrael> gwern: It's a general class of convex optimization problem--I'm looking to implement a SVM, and in order to calculate certain required values, I need to solve a quadratic programming problem.
18:01:51 <mmorrow> dolio: how do you know my default web password?
18:01:54 <grom358> BMeph: python version http://pastebin.com/d2c8d87d2
18:02:14 <Armored_Azrael> gwern: Worst case scenario, I can do it in matlab, but as easy as it makes QP, it'll make the rest of the project much harder.
18:02:40 <dmwit_> grom358: Try the Schwartzian transform.
18:02:58 <dmwit_> grom358: You're recomputing the chainLength for the longest chain you see for *every* element of the list.
18:03:14 <dmwit_> or...
18:03:15 <dmwit_> never mind
18:03:43 <pumpkin_> hmm, trying to figure out the type for schwartz
18:03:55 <pumpkin_> schwartz :: (Ord a) => ((a -> a -> Ordering) -> [a] -> a) -> (b -> a) -> [b] -> b
18:04:00 <pumpkin_> cause I lost your original paste :P
18:04:12 <pumpkin_> not paste, but it scrolled off the top of my screen
18:04:25 <dmwit_> schwartz :: Ord b => (a -> b) -> [a] -> [a]
18:04:54 <grom358> dmwit_: yeah the python version does the same recomputing too. Though I do need to remove them
18:05:03 <pumpkin_> dmwit_: it was more general though, allowing minimumBy as well as sortBy
18:05:16 <dmwit_> minimumBy f = head . sortBy f
18:05:28 <pumpkin_> dmwit_: yeah, but I prefer O(n) :P
18:05:34 <dmwit_> That *is* O(n).
18:05:34 <idnar> the problem is, there's also schwartz' :: Ord b => (a -> b) -> [a] -> a
18:05:39 <sjanssen> grom358: the problem is that maximum is lazy
18:05:42 <sjanssen> @src maximum
18:05:42 <lambdabot> maximum [] = undefined
18:05:42 <lambdabot> maximum xs = foldl1 max xs
18:05:55 <dolio> Actually what I posted didn't work for both sortBy and minimumBy. They return different types, so it won't work.
18:05:57 <pumpkin_> dmwit_: how? unless it's doing an insertion sort it can't evaluate sortBy lazily can it?
18:05:57 <idnar> is there some way to generalise that?
18:06:10 <sjanssen> grom358: try foldl1' max instead of maximum
18:06:13 <dolio> You could generalize it if minimumBy returned Id a. :)
18:06:17 <dmwit_> pumpkin_: sortBy is a merge-sort, which can (and is) be lazy.
18:06:19 <idnar> heh heh
18:06:23 <idnar> I was about to suggest that
18:06:28 <pumpkin_> oh I thought someone told me it was quicksort
18:06:48 <loop> quicksort isn't so good on lists
18:07:06 <Armored_Azrael> Whole point of quicksort is that you do it in place on arrays nicely
18:07:08 <dolio> @type let schwartz op f = fmap snd . op (comparing fst) . fmap (f &&& id) in schwartz
18:07:08 <dmwit_> s/can (and is) be/can be (and is)/
18:07:09 <lambdabot> forall a b (f :: * -> *) c a1 (f1 :: * -> *) a2 b1. (Functor f, Ord a, Functor f1) => (((a, b) -> (a, b) -> Ordering) -> f (c, a1) -> f1 (a2, b1)) -> (a1 -> c) -> f a1 -> f1 b1
18:07:13 <pumpkin_> who was it who was telling me the exact opposite the other day
18:07:15 <pumpkin_> bah :)
18:07:19 <idnar> ?!?!
18:07:29 <sjanssen> grom358: http://hpaste.org/12641#a2 should work
18:07:31 <dolio> @type let schwartz op f = fmap snd . op (comparing fst) . fmap (f &&& id) in schwartz ((Identity .) . minimumBy)
18:07:33 <lambdabot> forall a b. (Ord a) => (b -> a) -> [b] -> Identity b
18:07:35 <BMeph> grom358: You might just roll your own fold for it. :)
18:07:41 <idnar> ah, much better
18:07:44 <dolio> @type let schwartz op f = fmap snd . op (comparing fst) . fmap (f &&& id) in schwartz sortBy
18:07:46 <lambdabot> forall a b. (Ord a) => (b -> a) -> [b] -> [b]
18:08:13 <grom358> sjanssen: actually I need to know which number generated the longest chain.
18:08:15 <kynky> and you use quicksort on unsorted arrays, as opposed to nearly sorted, cos if there not much diff, then think even bubblesort is faster
18:08:28 <sjanssen> grom358: that is also easy
18:08:47 <dmwit_> kynky: One standard fix to that is to randomize the list first.
18:09:10 <cknapp> Or pick a random element.
18:09:10 <dmwit_> You can prove nice expected-value running time bounds.
18:09:15 <sjanssen> grom358: http://hpaste.org/12641#a3
18:09:19 <dmwit_> cknapp: That's the usual implementation, yeah.
18:09:36 <dmwit_> It's equivalent in every way except constants to randomizing first. =)
18:09:48 <kynky> cool
18:10:08 <cknapp> Does randomizing first have a smaller constant?
18:10:13 <cknapp> I can't imagine it would...
18:10:28 <dmwit_> nope, bigger
18:10:31 <blackdog> i don't think it changes the worst-case so much, but it seems relatively common to switch to a different algorithm once you get beneath a certain size of array, too...
18:10:45 <blackdog> might have been something in programming pearls about it
18:10:52 <cknapp> Ok... then why not say the better way first :)
18:11:04 <cknapp> blackdog: yeah, I think going to merge sort is common.
18:11:21 <sjanssen> quicksort is not particularly useful on linked lists
18:11:27 <dolio> No no. You go to a non-recursive insertion sort on small lengths.
18:11:33 <cknapp> Ah.
18:11:35 <cknapp> Right.
18:11:38 <cknapp> Confusing things...
18:11:51 <dolio> Because recursion is expensive or something... :)
18:12:03 <pumpkin_> dolio: so the actual type of schwartz is (Functor f, Ord a1, Functor f1) => (((a1, b1) -> (a1, b1) -> Ordering) -> f1 (c, a2) -> f (a, b)) -> (a2 -> c) -> f1 a2 -> f b, according to :t :P
18:12:11 <pumpkin_> :o
18:12:23 <dolio> :)
18:13:10 <dolio> Now you just need to petition for all sorts of library functions to be turned into natural transformations to the identity functor, instead of just returning a result. :)
18:13:52 <pumpkin_> :o
18:14:02 <idnar> @type return . maximumBy
18:14:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> a -> Ordering) -> m ([a] -> a)
18:14:11 <idnar> oh, bleh
18:14:15 <sjanssen> grom358: did my annotation fix your problem?
18:14:28 <idnar> (return .) . maximumBy
18:14:29 <grom358> sjanssen: its still slower.. And I am compiling it too
18:14:31 <idnar> @type (return .) . maximumBy
18:14:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> a -> Ordering) -> [a] -> m a
18:14:41 <idnar> isn't there a nicer way of composing than that?
18:14:52 <sjanssen> grom358: are you compiling with -O2?  How long does it take to execute?
18:15:09 <idnar> this . ) . ). . ( . . () . ( . (. . ( ) . business looks like nethack or something
18:15:19 <grom358> sjanssen: yeah.. compiling with -O2 and I don't know how long it takes yet cause it is still running
18:15:21 <dolio> There might be some oleg magic that does variable-argument composition.
18:16:35 <grom358> sjanssen: over 5 minutes so far
18:16:40 <dmwit_> Time to profile!
18:16:52 <dmwit_> on a smaller length list, of course
18:17:13 <sjanssen> grom358: and how long did the Python program take?
18:17:24 <grom358> the python one takes about 2 minutes
18:17:39 <cknapp> Hmm... who would have thought, reading the book and finding theorems makes the proof you were struggling with almost trivial...
18:17:57 <grom358> 2 minutes and 3 seconds
18:18:24 <sjanssen> grom358: note that your Haskell version builds a list, while Python does not
18:18:32 <sjanssen> grom358: http://hpaste.org/12641#a4 should be the best so far
18:19:26 <loop> you could try memoizing the results
18:20:43 <BMeph> sjanssen, grom358: "strictify" chainZip's n? :)
18:20:49 <loop> 13->40->x->y->1 = 4 so of course also 40->..->1 = 3 etc
18:21:12 <FunctorSalad> how is 'pointless' defined? no function decls with something on the LHS; no lambda expressions?
18:21:12 <sjanssen> BMeph: we shouldn't use zip here at all
18:21:37 <FunctorSalad> how about 'case'? can't completely get rid of it I suppose
18:21:37 * BMeph agrees.
18:21:38 <sjanssen> http://hpaste.org/12641#a3 is the most reasonable version that uses a list
18:22:44 <FunctorSalad> I need to know because I'm trying to write a @pl variant ;)
18:23:01 <grom358> sjanssen: that last one you posted gives stackoverflow
18:23:48 <BMeph> FunctorSalad: case is fundamental - you can't get rid of it, unless you just want to sugar up your display. :)
18:24:14 <sjanssen> grom358: interesting!
18:24:28 <sjanssen> seems to indicate we have a bug somewhere
18:24:42 <sjanssen> perhaps a chain that doesn't ever terminate?
18:24:55 <FunctorSalad> BMeph: ok, it will be the user's responsibility not to pass something with 'case' then ;)
18:25:20 <grom358> sjanssen: chainLength is not using a tail call
18:25:32 <sjanssen> grom358: that's okay
18:25:41 <BMeph> FunctorSalad: ...
18:25:42 <sjanssen> IIRC, the stack depth is never more than 500
18:25:50 <sjanssen> ah ha!
18:25:55 <sjanssen> grom358: the problem is Integer overflow
18:26:08 <sjanssen> s/Int/Integer/g and your program will work
18:26:35 <FunctorSalad> BMeph: or rather, case expressions just won't be depointified
18:26:38 <BMeph> sjanssen: Doesn't it already work, just too slowly? :)
18:26:41 <sjanssen> this is why you should never give something an Int type unless you know your domain
18:26:52 <sjanssen> BMeph: no, I'm pretty sure it doesn't terminate
18:26:56 <sjanssen> or will give a wrong answer
18:26:58 <grom358> sjanssen: sweet.. 13 seconds.. using my tail call version of chainLength
18:27:11 <BMeph> sjanssen: Ah, read up - NM. :)
18:27:18 <FunctorSalad> @pl (\x -> case x of (Just y) -> y*y; Nothing -> -9)
18:27:18 <lambdabot> (line 1, column 27):
18:27:19 <lambdabot> unexpected ">"
18:27:19 <lambdabot> expecting variable, "(", operator or ")"
18:27:35 <FunctorSalad> @pl (\x -> case x of (Just y) -> y*y; (Nothing) -> -9)
18:27:35 <lambdabot> (line 1, column 27):
18:27:35 <lambdabot> unexpected ">"
18:27:35 <lambdabot> expecting variable, "(", operator or ")"
18:28:01 <FunctorSalad> @pl (\x -> case x of { (Just y) -> y*y; (Nothing) -> -9 })
18:28:01 <lambdabot> (line 1, column 18):
18:28:01 <lambdabot> unexpected "{"
18:28:01 <lambdabot> expecting variable, "(", operator or ")"
18:28:05 <FunctorSalad> :(
18:28:15 <BMeph> @pl (\x -> case x of { Just y -> y*y; Nothing -> (-9)})
18:28:15 <lambdabot> (line 1, column 18):
18:28:15 <lambdabot> unexpected "{"
18:28:15 <lambdabot> expecting variable, "(", operator or ")"
18:28:33 <sjanssen> hmm, I guess it isn't an Int overflow
18:29:41 <sjanssen> grom358: are you absolutely sure this version stack overflows?  It completes in 10 seconds on my machine http://hpaste.org/12641#a4
18:30:04 <FunctorSalad> BMeph: are we going mad? :(
18:31:00 <sjanssen> grom358: the Python version takes 90 seconds on my box
18:31:02 <sjanssen> Haskell ftw!
18:31:09 <dibblego> @type on
18:31:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:31:18 <grom358> sjanssen: your version only works for me if I change Int to Integer
18:31:30 <grom358> takes 12 seconds
18:31:57 <sjanssen> hmm
18:32:57 <BMeph> It takes 5m52s on mine. In GHCi, though. :)
18:33:11 <BMeph> @hoogle something
18:33:12 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
18:33:26 <BMeph> Heh-heh. ;)
18:33:44 * BMeph still wants to make a T-shirt with that on it
18:34:14 <grom358> BMeph: using Int or Integer?
18:34:29 <sjanssen> grom358: it completes successfully with Int here
18:34:37 <sjanssen> grom358: are you on x86-64?
18:34:46 <BMeph> sjanssen: 64-bit machine? ;)
18:34:51 <grom358> I'm 32bit
18:34:55 <sjanssen> that's probably hit
18:34:59 <sjanssen> s/hit/it
18:35:09 <BMeph> grom358: I never did the typesig, so it's likely Integer. :)
18:36:38 <grom358> http://hpaste.org/12641#a5 returns in 12 seconds with ghc --make -O2 prob14.hs
18:36:55 <sjanssen> > logBase 2 2482111348 -- reaches numbers at least as high as this
18:36:57 <lambdabot>   31.208920690487634
18:37:07 <sjanssen> just slightly too large for an Int on your architecture
18:37:17 <sjanssen> grom358: moral of the story: don't use Int :)
18:37:59 <pumpkin_> http://hpaste.org/12647 what do people think?
18:38:12 <pumpkin_> it looks epicly inefficient
18:38:15 <pumpkin_> lots of maps
18:39:31 <sjanssen> we get a lot of questions about Euler #14 -- I think this is the third time I've solved it :)
18:39:45 <grom358> now.. I know it is already quick now. But how can I avoid the recomputing existing chains. In the python version I used hashtable and it improved it by over 4 times
18:39:51 <dmwit_> pumpkin_: gross
18:39:58 <pumpkin_> dmwit_: that was my reaction too :)
18:40:04 <sjanssen> grom358: you can use an array, or Data.Map
18:40:14 <sjanssen> or one of the memo combinators on hackage
18:40:17 <dmwit_> > (length *** length) . partition (>5) $ [1,2,1,4,7]
18:40:18 <lambdabot>   (1,4)
18:40:55 <pumpkin_> hmm
18:41:07 <luqui> data-memocombinators was made for problem 14
18:41:19 <dmwit_> > (length *** length) . partition (not . (>5)) $ [6..9]
18:41:21 <lambdabot>   (0,4)
18:42:24 <pumpkin_> dmwit_: how about getting it into four classes?
18:42:26 <dmwit_> > let count p = (length *** length) . partition p; count2 p = count p *** count (not . p) in count2 ([1,2,1,4,7], [6..9])
18:42:28 <lambdabot>   Couldn't match expected type `a -> Bool'
18:42:45 <dmwit_> > let count p = (length *** length) . partition p; count2 p = count p *** count (not . p) in count2 (>5) ([1,2,1,4,7], [6..9])
18:42:47 <lambdabot>   ((1,4),(0,4))
18:42:55 <dmwit_> pumpkin_: What are the four classes?
18:42:58 <dmwit_> I see only two.
18:43:08 <pumpkin_> I mean, TP, FP, TN, FN
18:43:16 <pumpkin_> true positives, ...
18:43:26 <pumpkin_> but it looks like you just did that :P
18:43:39 * pumpkin_ bows
18:44:11 <BMeph> grom358: Moral of the story: Don't put in a typeclass unless GHC complains. ;)
18:45:10 <dibblego> @src on
18:45:10 <lambdabot> (*) `on` f = \x y -> f x * f y
18:45:26 <dmwit_> mmm could be nice
18:45:39 <byorgey> heh, I remember having a lot of trouble with Euler #14 back in the day =)
18:45:46 <dmwit_> on (***) count p (not . p)
18:45:47 <byorgey> I think it's something of a rite of passage
18:46:14 <pumpkin_> hmm
18:46:29 <BMeph> dmwit_: OnStar, may I help you? ;p
18:46:57 <dmwit_> Yes, help!  I've been abducted by the Cult of Point-Free Programming!
18:47:49 <dolio> @type unzip >>> sum *** sum
18:47:50 <lambdabot> forall a b. (Num b, Num a) => [(a, b)] -> (a, b)
18:48:07 <BMeph> Hm, the Conference on Point-Free Inquiry - the CPFI! :)
18:48:27 <pumpkin_> (unzip >>> sum *** sum) [(1,2), (2,3), (7,4)]
18:48:33 <pumpkin_> > (unzip >>> sum *** sum) [(1,2), (2,3), (7,4)]
18:48:34 <lambdabot>   (10,9)
18:48:55 <grom358> BMeph: I thought it was good practice to specify type declarations
18:49:31 <grom358> in ghci how do you do a qualified import?
18:49:59 <dmwit_> You can't.
18:50:13 <dmwit_> However, you don't need to.
18:50:19 <dmwit_> Every qualified name is already in scope.
18:50:21 <ushdf> Windows 2000 Dadacenter Server is the moustache on your CTO's girlfriend
18:50:30 <ushdf> Windows 2000 Dadacenter will CRUSH your friends and DELIGHT your enemies
18:50:44 <thoughtpolice> it would be really nice to be able to 'import qualified Data.ByteString as B' in ghci though
18:50:48 <dmwit_> s/Dada/Data/ # ?
18:50:50 <ushdf> Windows 2000 Dadacenter Server forces you to dream only of marzipan
18:51:03 <roconnor> thoughtpolice: I suppose if you are desparate you could make your own module B.
18:51:04 <ushdf> All day long Windows 2000 Dadacenter furrows its brows and bites its fingernails
18:51:27 <dmwit_> thoughtpolice: Yes, as-imports would be nice.
18:51:30 <ushdf> Your duty is to buy Windows 2000 Dadacenter.  Our duty is to prevent you at all costs.
18:51:42 <roconnor> @where-ops
18:51:42 <lambdabot> Unknown command, try @list
18:51:46 <roconnor> @whereops
18:51:46 <lambdabot> Unknown command, try @list
18:51:48 <ushdf> shush
18:51:49 <ushdf> i'm done
18:52:05 <roconnor> damn it I never remember that command
18:52:15 <tredontho> I'm probably stretching above my minute skill level here, but can somebody help me understand how to use the Random module?
18:52:29 <dmwit_> Easy, don't!
18:52:30 <dmwit_> ;-)
18:52:31 <BMeph> grom358: No, good manners is to specify type declarations, so other humans reading your code know what you think you're trying to do. Type inference means the compiler infers your types "automagically". ;p
18:52:49 <dmwit_> tredontho: But, yes, do you have a specific question?
18:52:56 <dmwit_> tredontho: Or did you just want an overview?
18:53:30 <roconnor> use the random monad.
18:53:35 <Cale> tredontho: The basic idea is that you have StdGen values which represent the state of a pseudorandom number generator
18:53:41 <roconnor> @hackage MonadRandom.
18:53:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom.
18:54:03 <Cale> tredontho: Functions like random and randomR take a StdGen, and produce a pseudorandom value, together with another StdGen
18:54:19 <Cale> > random (mkStdGen 42)
18:54:20 <lambdabot>   (-3907187990116499535,2060101257 2103410263)
18:54:29 <Cale> ^^ Here, an Integer
18:54:46 <Cale> Note that the same pseudorandom value will always be produced, given the same StdGen
18:54:48 <Cale> > random (mkStdGen 42)
18:54:50 <lambdabot>   (-3907187990116499535,2060101257 2103410263)
18:54:54 <Cale> > random (mkStdGen 23138)
18:54:56 <lambdabot>   (837528123716684731,522445894 2103410263)
18:54:57 <tredontho> I'm gonna be up front, I'm quite the novice (so Monads = huh? to me)
18:55:11 <BMeph> Oh, noes, someone activated the Cale protocol, RUN! ;p
18:55:13 <Cale> That is, random and randomR are actually proper functions.
18:55:15 <tredontho> Cale: right, so, if I wanted to use a System based rng, how would I go about that?
18:55:30 <tredontho> I see getStdGen
18:55:47 <Cale> getStdGen is a little silly, use newStdGen
18:55:47 <tredontho> but I cannot use it the same way as it is IO StdGen
18:56:08 <Cale> Executing newStdGen in the IO monad will give you a new StdGen value
18:56:10 <roconnor> @hoogle randomIO
18:56:11 <lambdabot> System.Random randomIO :: Random a => IO a
18:56:22 <Cale> Ideally, it would be based on the system entropy pool, but it's not.
18:56:28 <tredontho> mm
18:56:34 <roconnor> @type newStdGen
18:56:36 <lambdabot> IO StdGen
18:56:40 <tredontho> That's what I was trying for
18:56:50 <Cale> (iirc, it's based on the time)
18:57:15 <tredontho> Yeah, it says it's based on the time, or the linux kernel rng, etc.
18:57:57 <tredontho> hmm... well, looks like I have more reading up to do before I can get anywhere, then
18:58:00 <tredontho> thanks all
18:58:13 <Cale> So from your top-level IO, you make sure to execute newStdGen at some point, which gives you an initial StdGen to pass into computations which need to generate pseudorandom values.
18:58:36 <Cale> Functions which depend on pseudorandomness will take a StdGen as a parameter.
18:58:48 <Cale> and possibly supply a new StdGen as part of their result
18:59:05 <Cale> Does that make sense?
18:59:15 <MyCatVerbs> Please, for the love of all that is good and unpredictable, do not use System.Random for cryptography. ;)
18:59:34 <Cale> Given this knowledge, you should be able to work out how to use it from the types.
18:59:43 <tredontho> Yeah, I was just trying stuff out in ghci, and I could use the mkStdGen and then use next and all of that
18:59:47 <BMeph> I tried draining my entropy pool once, but it never hit bottom, it just went negative, and started tidying up the place... ;p
19:00:00 <dolio> System.Random is probably not recommendable for anything real.
19:00:03 <roconnor> Cale: I think trying to teach tredontho to thread his own StdGens is error-prone.  He should either use the IO operations, or MonadRandom.  Everyone ought to use either the IO operations or MonadRandom, preferably MonadRandom.
19:00:06 <dolio> Considering how slow it is.
19:00:12 <Cale> > let g = mkStdGen 42; (a,g') = randomR (1,6) g; (b,g'') = randomR (1,6) g' in (a,b)
19:00:14 <lambdabot>   (6,4)
19:00:16 <tredontho> but with the newStdGen, since it's an IO StdGen, I couldn't use it
19:00:24 <saml> is there a timer?  i want to execute something after n seconds.. etc
19:00:38 <Cale> roconnor: I think it's good to understand how to thread StdGens along.
19:00:45 <roconnor> hmm
19:00:54 <Cale> saml: threadDelay?
19:01:04 <Cale> saml: Possibly together with forkIO
19:01:07 <saml> Cale, thanks. i'll search fot it
19:01:13 <Cale> Control.Concurrent
19:02:13 <Cale> forkIO (do threadDelay 1000000; print "Hello!")
19:02:32 <MyCatVerbs> roconnor: IMO, threading your own StdGens is something that you should do exactly once.
19:02:42 <MyCatVerbs> roconnor: it'll teach you the real value of the State monad. =)
19:03:00 <roconnor> well, maybe threading your own something
19:03:22 <dmwit_> maybe twice
19:03:27 <Cale> Sometimes I'll use StdGens directly anyway, if it's nothing too large.
19:03:45 <roconnor> as long as tredontho doesn't come awaythinking that using random values in Haskell is hopelessly annoying.
19:04:03 <tredontho> it's just above my skill level right now, I think
19:04:31 <tredontho> I haven't touched Monads or even IO, really, so... to the books
19:05:37 <roconnor> if you want system based randomness, you need to touch IO at some point.
19:06:03 <roconnor> if you are okay with providing your own static number seed, then you can use mkGen as Cale said.
19:06:16 <roconnor> mkStdGen.
19:06:48 <tredontho> right, I knew IO would be involved... I just don't know how it all comes together
19:09:09 <Cale> tredontho: The only IO which will be involved is in getting your first StdGen value. After that, every operation which gets a "random" value will give you another StdGen to use to get the next one.
19:12:33 <mmorrow> i'm looking at the Data.Binary code and am confused because i thought i'd heard that it was using cps (in some form) rather than Get just being a State monad
19:12:55 <mmorrow> newtype Get a = Get { unGet :: S -> (a, S) }
19:13:08 <luite_> I'm making some local search algorithm, that has to run some number of iterations, and then stop, based on some stopping criterion. My previous version was non-monadic, the search algorithm just produced an infinite list of solutions, which was then consumed as far as needed. But now my search algoritm runs inside a monad, and I cannot generate an infinite list anymore. What would be a good way to implement a stopping criterion (which may depend on re
19:13:19 <dmwit_> cut off at "which may depend on r"
19:13:28 <mmorrow> data S = !B.ByteString L.ByteString !Int64
19:13:38 <luite_> What would be a good way to implement a stopping criterion (which may depend on real time, on the previous results, current result etc...)?
19:14:43 <mmorrow> data Search m a = Fail | Done | Cont a (m (Search m a))
19:14:56 <mmorrow> is a nice alternative to lazy lists
19:15:44 <saml> http://hpaste.org/12648   does a thread waiting with theadDelay resume automatically? or should I wake it up?
19:16:06 <luite_> hm I was reading about continuations earlier, but don't know how to apply them yet.
19:16:12 <mmorrow> hmm, maybe i'd add an 'a' to "Done"
19:16:48 <mmorrow> that "continuation" is just a monadic action which'll proceed with the search if you decide you want to
19:16:49 <Asztal> maybe a Maybe a
19:17:28 <luite_> ah I see what you mean now
19:17:28 <apsod> saml: When the main thread finishes, all children are killed. You have to explicitly have the main thread wait on all children.
19:18:02 <saml> apsod, even though i put threadDelay 10 at the end of main, i don't see "t0 leaves"
19:18:29 <roconnor> how long does threadDelay 10 wait
19:18:31 <apsod> saml: Could just be a race condition -- it's possible that the second thread is simply getting starved.
19:18:33 <saml> apsod, i see it with threadDelay 30
19:19:56 <saml> i think i should make main communicate with t0.. when t0 wakes up, it sends something to main and then main exits
19:20:20 <saml> am i thinking in imperative way? i heard concurrency in haskell is easy
19:20:34 <saml> what i'm doing is what i'd do in java/python....
19:21:10 <kynky> lots of diff ways of doing concurrency, i like the actor/message based approach
19:21:13 <apsod> Concurrency in Haskell is easy, you just need to block until all your child threads are dead.
19:21:23 <apsod> One sec, I'm concocting an addition to your sample code :3
19:21:23 * pumpkin_ trembles
19:22:34 <apsod> saml: http://hpaste.org/12649
19:22:56 <apsod> In that example, it uses an MVar to block until the child thread is done processing.
19:22:56 <pumpkin> dolio: I have another question about schwarts :/
19:22:57 <kynky> doing concurrency badly doesnt matter about the language though
19:23:01 <pumpkin> *schwartz
19:23:42 <mmorrow> luite_: as an example, i've used (exactly iirc) that datatype to do a breadth first version of find(1)
19:23:44 <pumpkin> schwartz minimumBy snd $ [(1,2), (2,1)] -- gives me (1,1) with the definition you wrote above :/
19:24:05 <pumpkin> @let schwartz op f = fmap snd . op (comparing fst) . fmap (f &&& id)
19:24:07 <lambdabot>  Defined.
19:24:17 <pumpkin> > schwartz minimumBy snd $ [(1,2), (2,1)]
19:24:18 <lambdabot>   (1,1)
19:25:01 <pumpkin> > minimumBy (comparing snd) [(1,2),(2,1)]
19:25:02 <lambdabot>   (2,1)
19:25:04 <mmorrow> err, actually i think i used
19:25:19 * mmorrow stops guessing and just finds the code
19:25:23 <luite_> :)
19:25:25 <saml> apsod, oh thanks. MVar!  and i found threadDelay n  waits for n microseond, not second
19:25:33 <apsod> saml: haha, nice :3
19:25:51 <pumpkin> idnar, dolio: am I doing it wrong? :P
19:26:47 <mmorrow> data DirTree a = File a | Dir a (IO (Map a (DirTree a))) | Cont (IO (DirTree a))
19:26:49 <luite_> mmorrow: I'm trying to work out how to apply it to my situation/algorithm, I may not need the Done or Fail
19:27:26 <mmorrow> you probably want at least Done so you can terminate the search (unless you expect to /always/ be searching an infinite space)
19:27:27 <luite_> but the approach seems to be ok
19:27:51 <mmorrow> i was really pleased with how nicely it worked with findbfs
19:28:12 <mmorrow> you get the results online, and at the same time are doing IO
19:28:22 <mmorrow> which would be impossible with sequence
19:28:30 <pumpkin> @instance Functor
19:28:31 <lambdabot> Maybe you meant: instances instances-importing
19:28:35 <pumpkin> @instances Functor
19:28:36 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:28:51 <luite_> I currently don't need Done, the search is probabilistic, and can always continue. but I could add a Done value to make it more generic :)
19:30:19 <mmorrow> luite_: sounds like an interesting problem. what type of stuff are you going to apply this search code to (out of curiosity)?
19:31:24 <luite_> mmorrow: iterated local search for graph bipartitioning
19:31:59 <mmorrow> cool, i'd love to hear how it turns out :)
19:33:17 <luite_> don't expect too much ;) it's my first haskell program bigger than an euler solution
19:34:49 <mmorrow> sounds like a perfect first-with-your-serious-face haskell prog ;)
19:34:55 <luite_> I finished some code for the fiduccia-mattheyses heuristic today, but I'm not really proud of it, the whole thing runs in the ST monad
19:35:41 <mmorrow> cool, i've been meaning to try to use the ST monad for some of the stuff i'm currently doing in IO
19:36:12 <mmorrow> especially for mutable arrays
19:36:54 <luite_> that's what I use it for, some STUArrays
19:37:31 <mmorrow> yeah, it seems like STUArrays are where it's at if you're looking for performance
19:37:55 <mmorrow> and better than IOUArrays since you can runST back to pure code
19:38:52 <mmorrow> i really want to see if i can hack this little fft i have to use STUArrays
19:40:39 <luite_> by the way, has anyone seen code for probabilistic inference in haskell? I've seen the probability package, but it only implements forward inference. I'm looking for something that can do complete inference in a probabilistic network, given arbitrary evidence
19:42:56 <pumpkin> what kind of a probilistic network?
19:43:28 <pumpkin> probabilistic :P
19:43:51 <luite_> pumpkin: a singly connected I-map would be ok, but if there's something for more complex networks, that would be nice
19:44:12 <luite_> but it does need to be a bit more complex than a naive bayesian model :)
19:44:38 <mmorrow> luite_: i think bos and/or Pseudonym are doing bio-related stuff, maybe they could give you some leads
19:45:38 <pumpkin> luite_: I've been doing a lot of work recently on CRFs, and will probably eventually implement them in haskell when I get better at it
19:45:48 <pumpkin> but yeah, I don't know of anything already out there :/
19:48:12 <luite_> ah, I don't know much about CRF's
19:50:06 <cknapp> CRF?
19:50:16 <pumpkin> conditional random field
19:50:26 <cknapp> Hmmm...
19:50:42 <luite_> oh I meant a 'regular' bayesian network by the way, I'm not sure if there's a better name for it
19:50:51 <cknapp> Ah.
19:52:01 <pumpkin> what is called in ghci to show things lazily? I have a variable y which is a list with an expensive definition, and it prints [(pause a minute) val, (pause a minute) val, ...
19:52:05 <pumpkin> that's in ghci
19:52:10 <pumpkin> if I compile it though, using print to display it
19:52:23 <pumpkin> I get the feeling it's trying to compute it all before showing it to me
19:53:10 <BMeph> pumpkin: That's because you're demanding it to show all of it to you. :)
19:53:17 <luite_> hm, almost 5am, guess I'm going to continue tomorrow
19:53:24 <pumpkin> how can I ask it to show it to me as it computes each element?
19:53:36 <pumpkin> like it does if I just type y in ghci
19:54:28 <mmorrow> hmm, it should have the same behavior. are you sure you're not doing something different?
19:54:30 <BMeph> pumpkin: Uh, my instinct would be to print . scanl, versus print, on the list. :)
19:55:08 <MyCatVerbs> pumpkin: IIRC, it might be trying to print it a block at a time.
19:55:12 <pumpkin> mmorrow: well, I am doing something different... in ghci I can just type y and it'll display, but that won't work as part of my main function when I compile it
19:55:14 <mmorrow> hmm, wouldn't "main = print [0..]" work?
19:55:32 <pumpkin> MyCatVerbs: oh it did output a big chunk of it at once
19:55:33 <luqui> pumpkin, hSetBuffering stdout NoBuffering
19:55:40 <MyCatVerbs> pumpkin: as in, it'll evaluate 512 characters of the string, (which will take a Hell of a long time), then evaluate the next 512 characters...
19:55:44 <pumpkin> ah :)
19:55:48 <MyCatVerbs> pumpkin: hSetBuffering stdout NoBuffering.
19:55:48 <pumpkin> makes sense
19:55:52 <pumpkin> thanks :)
19:56:01 <mmorrow> pumpkin: but i mean by typing "y" you're doing exactly "print y"
19:56:07 <MyCatVerbs> pumpkin: beware that that will make things much, much slower under a wide variety of conditions. :)
19:56:22 <pumpkin> MyCatVerbs: I'm not doing much outputting, the values are just expensive to compute
19:56:28 <adityam> @pl f s s' = and [ g s == g s', h s == h s']
19:56:28 <lambdabot> f = (and .) . ap (ap . ((:) .) . (. g) . (==) . g) (flip flip [] . ((:) .) . (. h) . (==) . h)
19:56:32 <pumpkin> mmorrow: ah
19:56:37 <MyCatVerbs> pumpkin: (at least, it'll make output much slower). But yours isn't one of those conditions. =)
19:56:40 <luqui> pumpkin, you could also do eg. mapM_ print y
19:56:48 <luqui> pumpkin, so you get one line of output per entry
19:56:54 <pumpkin> is that like sequence_
19:56:54 <mmorrow> yeah, i'm a big fan of mapM_ print
19:56:54 <pumpkin> ?
19:57:13 <mmorrow> @src mapM_
19:57:13 <lambdabot> mapM_ f as = sequence_ (map f as)
19:57:19 <MyCatVerbs> pumpkin: very much so! mapM_ f = sequence_ . map f -- =)
19:57:25 <pumpkin> ah :)
19:57:26 <pumpkin> cool
19:58:36 <pumpkin> I should really optimize this instead of working around the slow algorithm
19:58:40 <pumpkin> I'm sure it could be a lot faster :P
19:58:41 <mmorrow> preflex: seen dolio
19:58:41 <preflex>  dolio was last seen on #haskell 58 minutes and 35 seconds ago, saying: Considering how slow it is.
19:59:18 <MyCatVerbs> pumpkin: what are you calculating, anyway?
20:00:02 <adamvo> hi, is there a way to make functions in multiple arguments pointfree
20:00:11 <adamvo> as in this: move a b c = conv $ move' a b c
20:00:14 <pumpkin> MyCatVerbs: something that should be relatively simple :P the optimal separation point for a decision stump on a set of 651 continuous features (around 6000 samples each)
20:00:16 <mmorrow> @tell dolio hmm, i'm looking at the code of Data.Binary and i was under the impression it was using cps in the implem somewhere but it looks like it's just using a standard state monad.
20:00:16 <lambdabot> Consider it noted.
20:01:04 <adamvo> why doesn't > move = conv . move'
20:01:08 <cknapp> I like lambdabot...
20:01:11 <adamvo> work in this case
20:01:31 <mmorrow> @pl \x y -> g (f x y)
20:01:31 <lambdabot> (g .) . f
20:01:36 <mmorrow> @pl \x y z -> g (f x y z)
20:01:36 <lambdabot> ((g .) .) . f
20:01:39 <MyCatVerbs> pumpkin: what? I have no idea what you said except that it sounds like my lecturers would want me to solve it in Matlab.
20:01:44 <mmorrow> @pl \x y z a-> g (f x y z a)
20:01:44 <lambdabot> (((g .) .) .) . f
20:01:54 <pumpkin> MyCatVerbs: yeah, except I hate matlab and wanted to learn haskell :P
20:02:00 <MyCatVerbs> pumpkin: and I can't bloody well stand Matlab. Gives me the shakes. =D
20:02:10 <grom358> can someone point me to an example of using Data.Map to cache calculations
20:02:11 <pumpkin> :)
20:03:21 <adamvo> @mmorrow: thanks, though I'm not so sure that that's nicer than explicit parameters
20:03:21 <lambdabot> Unknown command, try @list
20:03:54 <roconnor> @go  memo trie
20:03:58 <lambdabot> http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/
20:03:58 <lambdabot> Title: Conal Elliott » Elegant memoization with functional memo tries
20:04:36 <pumpkin> @src partition
20:04:36 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
20:04:36 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
20:04:36 <lambdabot>                               | otherwise = (ts, x:fs)
20:04:39 <pumpkin> :t partition
20:04:41 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:04:52 <dmwit_> grom358: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
20:04:55 <lambdabot> Title: Gmane -- Mail To News And Back Again
20:06:26 <MyCatVerbs> grom358: http://hpaste.org/12651
20:07:54 <grom358> thanks for all these links
20:08:24 <roconnor> my link doesn't use data map :(
20:09:47 <dmwit_> mine neither
20:10:09 <grom358> I actually think I can use array for this particular problem I'm working on (project euler #14, by using position as key)
20:14:01 <MyCatVerbs> grom358: yeah, usually that's less painful. :)
20:16:54 <pumpkin> if I enable -prof compiling it stops being able to find many of my libraries :/
20:18:06 <pumpkin> > schwartz minimumBy snd $ [(1,2), (2,1)]
20:18:08 <lambdabot>   (1,1)
20:20:41 <cknapp> can't you use -auto-all ?
20:21:03 <pumpkin> still complains :/
20:21:07 <cknapp> hmm...
20:22:09 <pumpkin> I guess I need to install profiling versions of all my libraries?
20:22:38 <grom358> what you think, http://hpaste.org/12652
20:22:55 <cknapp> That seems like it what make sense... but it seems unreasonable that you would have to do this.
20:23:14 <thoughtpolice> pumpkin: yes
20:23:20 <thoughtpolice> you have to install profiling versions of your libraries
20:23:22 <cknapp> grom: memorization, or memoization? :D
20:23:41 <pumpkin> thoughtpolice: do those tend to be slower?
20:23:53 <smarmy> memoization
20:24:07 <thoughtpolice> if it is I doubt it's substantial, I mean, you don't want the fact your profiling to really change your timing results that much
20:24:14 <pumpkin> yeah
20:24:26 <pumpkin> is there any way to ask cabal-install to reinstall my packages with profiling enabled?
20:24:37 <thoughtpolice> if you use cabal install you can set a flag in ~/.cabal/config so it always builds all libraries with profiling versions
20:24:45 <thoughtpolice> (can't remember what it's called, maybe ask dcoutts)
20:24:55 <grom358> my bad.. this is the first time I have heard of this term memoization
20:25:03 <thoughtpolice> otherwise, you have to do something like 'cabal install --reinstall -p <pkgname>'
20:25:08 <thoughtpolice> but that's not to bad
20:25:28 <pumpkin> -- library-profiling: False
20:25:28 <pumpkin> -- executable-profiling: False
20:25:41 <pumpkin> I should uncomment and make them both true?
20:26:06 <thoughtpolice> just library-profiling
20:26:13 <thoughtpolice> i mean if you want executable profiling too then fine
20:26:23 <pumpkin> what's the difference?
20:26:24 <thoughtpolice> but normally I just do 'cabal install --enable-executable-profiling ..'
20:26:47 <thoughtpolice> library profiling builds a profiling version of any library you install and executable profiling does the same thing for any executable cabal builds
20:27:05 <pumpkin> ah, yeah, I'm just using libraries
20:28:16 <pumpkin> bah, now I need to toposort my hackage packages :P
20:28:34 <pumpkin> I try to reinstall FFT with profiling and it complains about another one not having profiling
20:29:01 <pumpkin> can I get cabal to output its installed packages in dependency order?
20:30:18 <solussd> how can i efficiently convert an Array to a list ?
20:30:27 <pumpkin> toList?
20:30:38 <solussd> list comprehension on the array using a!(index) is very slow
20:30:43 <solussd> toList? sweet.
20:31:03 <pumpkin> or was it elems
20:31:11 <pumpkin> can't remember
20:31:17 <pumpkin> I think elems actually
20:31:23 <pumpkin> @hoogle elems
20:31:24 <lambdabot> Data.IntMap elems :: IntMap a -> [a]
20:31:24 <lambdabot> Data.IntSet elems :: IntSet -> [Int]
20:31:24 <lambdabot> Data.Map elems :: Map k a -> [a]
20:31:26 <pumpkin> nope
20:31:40 <solussd> heheh hoogle
20:32:06 <solussd> @hoogle toList
20:32:07 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
20:32:07 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
20:32:07 <lambdabot> Data.IntMap toList :: IntMap a -> [(Key, a)]
20:32:16 <FunctorSalad> I just wish it was easier to set up your own hoogle :|
20:32:17 <pumpkin> solussd: I think it is elems actually, try it
20:32:21 <solussd> k
20:32:27 <lament> solussd: in general, when you have a question like this, hoogle is the best approach
20:32:30 <lament> solussd: e.g.
20:32:36 <lament> @hoogle Array i a -> [a]
20:32:36 <lambdabot> Data.Array.Base elems :: (IArray a e, Ix i) => a i e -> [e]
20:32:36 <lambdabot> Data.Array.IArray elems :: (IArray a e, Ix i) => a i e -> [e]
20:32:36 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
20:33:07 <grom358> cknapp: so what is unreasonable about it?
20:33:46 <pumpkin> anyone know of a good way to reinstall all my packages on cabal with library profiling enabled? :P
20:33:47 <solussd> elems works. thanks!
20:34:43 <grom358> went from 12 seconds to 2 seconds
20:34:52 <FunctorSalad> pumpkin: ghc-pkg list --simple-output?
20:35:02 <FunctorSalad> to get your package list
20:35:32 <cknapp> grom: it doesn't really seem unreasonable... annoying is a more apt word. But I guess there are reasonable yet annoying things
20:35:40 <pumpkin> FunctorSalad: my issue is that I have them installed already, so I enabled library-profiling in the config file, but if I don't take dependencies into account, it'll complain that the dependency doesn't have profiling
20:36:29 <pumpkin> FunctorSalad: and I'd like simple-output to toposort them somehow, if possible
20:36:47 <pumpkin> then I can just xargs it or something to reinstall them all
20:36:57 <cknapp> Create a dependency graph in haskell, and toposort that?
20:36:59 <cknapp> Duh!
20:37:01 <pumpkin> lol
20:37:08 <pumpkin> :(
20:37:11 <cknapp> :)
20:37:13 <FunctorSalad> pumpkin: just repeatingly try to reinstall them all until it's done?
20:37:29 <FunctorSalad> assuming cabal will install everything in the list it can
20:37:45 <pumpkin> FunctorSalad: I guess that's one way to approach it :P
20:37:47 <pumpkin> let me try
20:38:40 <FunctorSalad> pumpkin: or just unregister everything?
20:38:40 <pumpkin> bah, There is no package named ghc :P There is no package named base, ...
20:38:45 <cknapp> @quote category theory
20:38:46 <lambdabot> No quotes for this person. My mind is going. I can feel it.
20:38:47 <FunctorSalad> oh
20:38:56 <saml> what's easy to install cross platform windowing toolkit?  SDL is so hard to install on windows
20:39:04 <cknapp> Oh, sad... it's by person.
20:40:04 <pumpkin> I guess I'll just remove the ones that don't exist by hand
20:41:02 <FunctorSalad> lambdabot's online help is still ridiculously unhelpful ;)
20:41:26 <Taejo> FunctorSalad: Yes!
20:41:27 <wagle> ok..  finally going to compile a haskell program with ghc.. whats that command line option i need?
20:41:49 <pumpkin> bah, ****ing dependencies
20:41:49 <FunctorSalad>  @help -> "try @list"; @list -> *dumps an url*; read url -> just a list of commands
20:41:55 <pumpkin> wagle: --make
20:42:44 <FunctorSalad> pumpkin: it won't even try the other packages if one fails?
20:42:50 <pumpkin> FunctorSalad: doesn't seem to
20:42:58 <wagle> pumpkin, thanks
20:43:07 <FunctorSalad> pumpkin: for x in $(cat thelist); do cabal install $x; done
20:43:12 <FunctorSalad> ?
20:43:22 <pumpkin> I'll give that a go, thanks
20:44:23 <solussd> is grabbing an index from an array just painfully slow?
20:44:29 <FunctorSalad> (I guess that's an UUoC if you know the magic bash punctuation for it ;))
20:45:12 <cknapp> How do I view the entire lambdabot quote database?
20:47:44 <wagle> putStrLn "hello world" doesn't work..  what did i leave out?
20:49:12 <cknapp> >putStrLn "Hello World"
20:49:16 <cknapp> sad...
20:49:25 <pumpkin> my sponsor on facebook says "Dethklok is back in search of all things brutal. How brutal? Let’s just say there’s blood, bulimia and “pelvic-thrust mace belts"
20:49:25 <cknapp> Sorry..
20:49:29 <pumpkin> o.O
20:49:29 <FunctorSalad> > putStrLn "hello world"
20:49:31 <lambdabot>   * Exception: "<IO ()>"
20:49:35 <FunctorSalad> lol
20:49:48 <FunctorSalad> lambdabot doesn't do IO
20:49:59 <pumpkin> how about randomRIO?
20:50:03 <wagle> my file consists of putStrLn "hello world"
20:50:11 <gwern> cknapp: darcs get the lb repo, and then gunzip State/quotes
20:50:20 <wagle> how do i compile it with ghc?
20:50:40 <pumpkin> wagle: you should write main = putStrLn "ohai"
20:50:44 <FunctorSalad> wagle: you can't have expressions on the top level
20:50:46 <wagle> doh
20:50:47 <pumpkin> then compile ghc --make moo.hs
20:51:06 <wagle> right..  thanks
20:51:09 <pumpkin> :)
20:51:42 <cknapp> gwern: "Not a repository: lb ..."
20:51:49 <FunctorSalad> pumpkin: what's randomRIO? :)
20:51:58 <pumpkin> I thought I'd come across that :o
20:51:59 <gwern> cknapp: example
20:52:02 <gwern> @version
20:52:02 <lambdabot> lambdabot 4.2.2
20:52:02 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:52:05 <pumpkin> maybe I just made it up
20:52:06 <cknapp> Got it
20:52:08 <cknapp> Thanks
20:52:18 <pumpkin> @hoogle randomRIO
20:52:18 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
20:52:24 <pumpkin> aha, I knew I didn't make it up!
20:52:37 <pumpkin> > randomRIO (1,2)
20:52:39 <lambdabot>   * Exception: "<IO Integer>"
20:52:41 <pumpkin> boo!
20:52:49 <FunctorSalad> @dice 2d7
20:52:49 <lambdabot> 2d7 => 8
20:52:53 <FunctorSalad> :D
20:52:55 <pumpkin> no reason I shouldn't be able to do that, though! :P
20:53:04 <pumpkin> maybe the owner was worried I'd exhaust his entropy
20:53:15 <FunctorSalad> pumpkin: I think it just rejects all IO
20:53:21 <pumpkin> yeah, just being silly :P
20:53:25 <pumpkin> I doubt it even uses /dev/random
20:53:42 <FunctorSalad> so you can't writeFile "/etc/shadow" or sth ;)
20:53:50 <pumpkin> boo
20:54:21 <pumpkin> it's pretty nice that haskell by design allows what other bots do a lot of work to get right
20:54:35 <pumpkin> (to prevent dumbasseses from ****ing up the system the bot runs on)
20:54:47 <gwern> pumpkin: it's harder than you think, even in haskell
20:55:00 <cknapp> gwern: I have the "quotes" file...
20:55:06 <gwern> there are a lot of ways to circumvent the IO restriction
20:55:25 <pumpkin> gwern: let me believe!
20:55:27 <pumpkin> :P
20:55:30 <FunctorSalad> gwern: unsafePerformIO in libraries?
20:55:30 <cknapp> But it's a binary file, and doesn't seem to like me very much
20:55:48 <gwern> FunctorSalad: among many other functions and DoS possibilities
20:55:54 <gwern> cknapp: I mentioned gzip
20:56:56 <cknapp> Indeed, you did. Gunzip doesn't like it... manpage time!
20:57:17 <FunctorSalad> cknapp: damaged download?
20:57:27 <BMeph> Yikes! I gotta stop hanging out at work, it's messing with my brain - and not in a good way! :\
20:57:44 <cknapp> Perhaps.
20:58:33 <cknapp> Cool...
20:58:46 <cknapp> I need to start figuring these things out for myself one of these days...
21:04:57 <mjonsson> If I do "data Foo a = Bar a deriving (Eq, Ord, Show)", that won't work unless a has instances for Eq, Ord, and Show
21:05:49 <mjonsson> But I would like to see the compiler do something like this instead: instance Eq a => instance Eq (Foo a) where ...
21:06:20 <mjonsson> so that it only provides Eq (Foo a) when a provides Eq
21:06:31 <mjonsson> and same for Ord and Show
21:07:23 <mjonsson> this must have been thought of before but I'm not sure what keywords to search for
21:09:19 <sjanssen> mjonsson: that is how it works already
21:10:01 <sjanssen> > Just () == Nothing -- Maybe uses a derived Eq instance
21:10:03 <lambdabot>   False
21:10:14 <mjonsson> heh, that's embarassing
21:10:17 <sjanssen> > Just id == Nothing -- functions do not have an Eq instance
21:10:19 <lambdabot>       No instance for (Eq (a -> a))
21:10:19 <lambdabot>        arising from a use of `==' at <int...
21:10:26 <mjonsson> thanks
21:10:50 <mjonsson> I was misinterpreting an error message I guess
21:12:18 <mriou_> I would need an advice from a more experimented Haskell programmer than I am which at this point isn't too hard
21:12:33 <mriou_> I'm trying to implement an interpreter for a simple language
21:13:00 <mriou_> problem is: the language is unpure
21:13:18 <pumpkin> is there a free lambdabot hosting service anywhere? :P I want a lambdabot on another server but can't get it to compile
21:13:33 <mriou_> so the stackframe (basically implemented as a sequence of maps) needs to be mutable
21:14:08 <wagle> no closures?
21:14:10 * dmwit keeps waiting for the punchline
21:14:14 <mriou_> I can't seem to find a way other than having the whole interpreter in the IO monad
21:14:28 <shapr> IORef?
21:14:29 <mriou_> yep, closures too
21:14:29 <dmwit> Have you considered using the State monad?
21:14:54 <mriou_> IORef would place the whole interpreter in the IO monad I think
21:14:58 <wagle> closure lives past the pop of the stack frame
21:15:20 <mriou_> and State works as long as you stay in the monad as well
21:15:36 <wagle> have to be careful if you put locations of mutable vars on the stack
21:15:39 <shapr> Can't you stack the monads and make it all work right?
21:15:51 <mriou_> wagle: correct
21:15:58 <dmwit> mriou_: Your option if you don't want to use State or IO is to thread the state yourself.  That doesn't sound fun.
21:16:06 <dmwit> What have you got against monads, anyway?
21:16:12 <mriou_> shapr: yeah but I was trying to keep the interpreter itself pure
21:16:14 <shapr> ah
21:16:24 <dmwit> State is pure
21:16:59 <mriou_> mmh true enough
21:17:10 <mriou_> maybe I should reconsider State then
21:17:58 <pumpkin> can anyone help me figure out what's wrong with the schwartz that I (dolio) defined earlier in lambdabot?
21:18:01 <mriou_> ok thanks for the advices, I'll see how that works
21:18:49 <mriou_> shapr, wagle, dmwit: thanks a lot for the help
21:18:57 <pumpkin> >  schwartz minimumBy snd $ [(1,2), (2,1), (3,3)] -- :(
21:18:58 <lambdabot>   (1,1)
21:20:26 <wagle> :t schwartz
21:20:28 <lambdabot> forall a1 b1 (f1 :: * -> *) c a2 (f :: * -> *) a b. (Functor f, Ord a1, Functor f1) => (((a1, b1) -> (a1, b1) -> Ordering) -> f1 (c, a2) -> f (a, b)) -> (a2 -> c) -> f1 a2 -> f b
21:20:46 <wagle> o.O
21:21:46 <cknapp> If I'm importing just operators from a module, do I need to wrap each in parenthesis? E.g. import Data.Sequence ((:<)) or import Data.Sequence (:<)
21:22:21 <pumpkin> @src schwartz
21:22:21 <lambdabot> Source not found. :(
21:22:27 <pumpkin> boo, I gave it to you earlier
21:23:05 <cknapp> pumpkin: hence the sadface, what more do you want? Tears? :)
21:23:23 <pumpkin> FunctorSalad: bah, now I'm in limbo and some of my packages don't work :P
21:24:31 <solrize> whoa --- i think we've got a new programming challenge.   http://tomas.rokicki.com/cubecontest/stefan2.txt
21:24:34 <pumpkin> Data/IntMap.hs:182:7:
21:24:34 <pumpkin>     Could not find module `Data.Data':
21:24:34 <pumpkin>       it is a member of package base, which is hidden
21:24:37 <solrize> or golfing, as it were
21:25:58 <wagle> what is schwartz?
21:26:11 <solrize> it comes after zoom and before profigliano
21:26:36 <pumpkin> wagle: a transform that allows you to sort by an arbitrary function of your data more quickly than the naive way
21:26:40 <mriou_> cknapp: the former
21:26:53 <solrize> http://en.wikipedia.org/wiki/Schwartzian_transform
21:26:55 <pumpkin> cknapp: yup
21:26:55 <lambdabot> Title: Schwartzian transform - Wikipedia, the free encyclopedia
21:28:17 <pumpkin> oh, I figured it out
21:28:43 <pumpkin> my cabal error, that is, not the schwartz
21:33:36 <pumpkin> bah, now I can't run my program at all
21:33:40 <pumpkin> stupid cabal :(
21:34:44 <pumpkin> dcoutts: you there?
21:37:57 <pumpkin> bah bah bah
21:38:31 <pumpkin> any cabal experts around?
21:38:53 <d2dchat> Are there any decent web frameworks for haskell?
21:38:57 <pumpkin> happs
21:39:30 <roconnor> @src sortBy
21:39:31 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
21:40:27 <byorgey> pumpkin: I'm no expert, but I may be able to help. what's the problem?
21:40:31 <roconnor> I didn't appreciate the Schwartzian transform until now.
21:40:53 <roconnor> the idea is to do apply f no more than n times, rather than n log n times.
21:40:56 <hydo> There's quite a bit about him that isn't appreciated at first glance.
21:40:59 <hackage> Uploaded to hackage: reactive 0.9.8
21:40:59 <hackage> Uploaded to hackage: X11 1.4.5
21:40:59 <hackage> Uploaded to hackage: reactive 0.9.7
21:41:21 <d2dchat> pumpkin: what should I use for mysql ?
21:41:46 <d2dchat> pumpkin: I noticed there were a few libraries, so I'm not sure which is best
21:41:48 <solrize> happs has its own database that's much better.  but there are a bunch of different sql clients
21:41:59 <d2dchat> solrize: ah sweet!
21:42:11 <d2dchat> I'm coming from the rails world
21:42:21 <d2dchat> so bare with me :)
21:42:30 <d2dchat> well Ruby world
21:42:37 <dons> there's a bunch of mysql / postgresql/ sqlite bindings/backends
21:42:48 <dons> visit hackage.haskell.org, and perhaps read the database chapter of RWH
21:42:52 <solrize> happs is brilliant but very advanced.  imho you have to be a real haskell expert (and i'm not one yet) to have any hope of using it effectively.
21:43:04 <d2dchat> I want the solution that gets me to that comparable productivity in haskell :)
21:43:10 <cknapp> dons: shameless plug! :)
21:43:24 <dons> hey, its free online.
21:43:27 <cknapp> Speaking of which... I need to read that.
21:43:38 <dons> its a good read </shameless plug>
21:43:57 <dons> d2dchat: visit #happs for haskell/happs use.
21:44:01 <pumpkin> roconnor: it's nice, but the one that's @let ted is broken :(
21:44:05 <d2dchat> dons: thanks!
21:44:07 <pumpkin> roconnor: can you see anything wrong with it?
21:45:04 <pumpkin> byorgey: so I wanted to profile my app that has lots of dependencies, but my dependencies in cabal weren't compiled with profiling, so I changed the flag in cabal config and asked it to reinstall everything
21:45:19 <pumpkin> many of them failed because their own dependencies don't have profiling enabled
21:45:20 <solrize> what about turbinado
21:45:21 <byorgey> wowsers
21:45:27 <solrize> http://www.turbinado.org/
21:45:30 <pumpkin> and now I'm in a limbo where some of my packages don't load
21:45:43 <pumpkin> and I still don't have profiling :P
21:45:47 <byorgey> eek.
21:46:05 <byorgey> what exactly do you mean, you 'changed the flag in cabal config'?
21:46:07 <solrize> d2dchat you might look at turbinado which claims to be inspired by rails among other things
21:46:26 <byorgey> keep in mind turbinado is pretty new.
21:46:36 <byorgey> probably has lots of rough edges, but definitely worth looking at (I haven't)
21:46:40 <lpjhjdh> cheers to the book release dons
21:47:02 <d2dchat> solrize: hehe it uses git instead of darcs!
21:47:02 <d2dchat> ;)
21:47:20 <pumpkin> byorgey: there's a .cabal/config flag that asks it to build with profiling enabled
21:47:30 <pumpkin> I wish I'd known about it earlier
21:47:34 <pumpkin> :(
21:47:34 <dons> lpjhjdh: thanks!
21:47:48 <dons> i met someone today with a copy, who wanted an autograph. lots of fun :)
21:47:57 <byorgey> dons: hehe, awesome =)
21:48:00 <dons> haskell is cool peoples.
21:48:15 <byorgey> pumpkin: what errors do you get now?
21:48:34 <solrize> http://software.complete.org/software/projects/show/hdbc
21:48:36 <lambdabot> Title: Haskell Database Connectivity - Overview - Software.Complete.Org
21:49:17 <pumpkin> byorgey: containers-0.2.0.0 fails with ExitFailure 1 :P if I unpack it myself, change the .cabal file to say base >= 4, cabal install will work for that particular package, but the ones that depend on it still claim it's a dependency, try to install it, and fail
21:49:27 <pumpkin> I'm just about ready to strangle cabal
21:50:15 <dons> anyone use stackoverflow?
21:50:18 <roconnor> > toRational 0.62
21:50:19 <lambdabot>   5584463537939415%9007199254740992
21:50:37 <pumpkin> dons, roconnor: any ideas about my cabal problem? :(
21:50:41 <dons> seems terribly amiss that RWH isn't in the stackoverflow list of books to read in 2008, http://stackoverflow.com/questions/18120/best-programming-books-in-2008
21:50:44 <lambdabot> Title: Best Programming Books in 2008 - Stack Overflow, http://tinyurl.com/59apnv
21:50:50 <dons> pumpkin: hmm :/
21:51:52 <pumpkin> if I try to run ghci now, with something that needs template haskell, it fails :/
21:52:24 <solrize> http://comments.gmane.org/gmane.comp.lang.haskell.cafe/48423   does anyone else not see any message text when they load this page?
21:52:25 <lambdabot> Title: gmane.comp.lang.haskell.cafe
21:52:55 <pumpkin> solrize: yeah, nothing
21:53:08 <solrize> i've seen that a lot lately, i think gmane is busted
21:53:09 <wagle> RWH?
21:53:15 <wagle> oh..  nm
21:53:52 <wagle> send him a copy
21:53:54 <solrize> @faq so anyone done anything like this in haskell?   http://tomas.rokicki.com/cubecontest/stefan2.txt
21:53:55 <lambdabot> The answer is: Yes! Haskell can do that.
21:54:18 <pumpkin> lol
21:54:40 <pumpkin> solrize: um, what does it do?
21:54:50 <solrize> it's not obvious? ;-)
21:54:55 <solrize> it solves rubik's cube
21:54:59 <pumpkin> oh of course!
21:55:07 <MyCatVerbs> solrize: I'm not seeing the text on gmane either.
21:55:47 <solrize> mycatverbs, thanks, that tells me it's not my browser configuration :)
21:56:00 <solrize> http://tomas.rokicki.com/cubecontest/winners.html
21:56:01 <lambdabot> Title: CubeContest Winners
21:56:02 <pumpkin> anyone feel like holding my hand a bit?
21:57:09 <MyCatVerbs> solrize: not necessarily. I'm using FF3 on Loonix with Vimperator and Noscript.
21:57:19 <MyCatVerbs> solrize: not exactly a vanilla setup. ;P
21:59:08 <grom358> is there some function I can use to split a string by newlines?
21:59:21 <MyCatVerbs> grom358: lines
21:59:35 <MyCatVerbs> grom358: I think it's in Prelude, too. ^^
21:59:48 <MyCatVerbs> > lines "foo\nbar\nbaz\n"
21:59:50 <lambdabot>   ["foo","bar","baz"]
22:00:22 <pumpkin> byorgey: no ideas about my problem?
22:00:28 <pumpkin> I don't really know what to do :(
22:01:16 <pumpkin> how can I erase all my cabal cackages?
22:01:43 <joed> Crackers?
22:01:51 <shapr> cheeze?
22:02:16 <pumpkin> packages:/
22:02:24 <joed> Michael Jackson is like that, he likes java, he'll come on small packages.
22:02:28 <adityam> @pl f a b = g (h a) (h b)
22:02:28 <lambdabot> f = (. h) . g . h
22:02:32 <hydo> ZING
22:02:37 <shapr> um
22:03:02 <grom358> can you have multiline strings in haskell? like """ strings in python?
22:03:10 <shapr> Not anymore.
22:03:18 <shapr> But I think someone recently came up with another way to do that.
22:03:27 <sjanssen> grom358: yes
22:03:29 <Nafai> Hi shapr!
22:03:36 <sjanssen> the syntax is a bit weird, though
22:03:37 <shapr> sjanssen: ooh, tell me!
22:03:46 <shapr> hiya Nafai!
22:04:06 <shapr> SPJ once told me that ghc pre 4.x supported multiline literals, but they were removed.
22:04:14 <adityam> @pl f (a, b) = g (h a, h b)
22:04:15 <lambdabot> f = uncurry ((g .) . (. h) . (,) . h)
22:04:18 <Nafai> shapr: How's it going?
22:04:29 <pumpkin> where do my installed cabal packages live?
22:04:34 <shapr> Nafai: It's interesting.
22:04:37 <shapr> Not boring
22:04:54 <Nafai> shapr: I've got a new toy!
22:04:57 <sjanssen> grom358, shapr: http://hpaste.org/12654
22:05:12 <wagle> if i have a lazy bytestring of length 1024, whats the best way to impose a record on top of it?  like read'ing into a struct in C?
22:05:24 <pumpkin> bah fuck it, I'm just going to delete all of cabal
22:05:24 <shapr> Nafai: Yeah, I saw that :-)
22:05:26 <sjanssen> wagle: Data.Binary, perhaps?
22:05:26 <shapr> Nafai: fun?
22:05:27 <pumpkin> and reinstall it
22:05:35 <doublec> Nafai, what's your new toy?
22:05:38 <Nafai> shapr: Yeah!
22:05:45 <Nafai> doublec: T-Mobile G1 phone
22:05:45 <shapr> sjanssen: Oh, interesting.
22:05:55 <doublec> oh cool!
22:06:14 <sjanssen> Nafai: how do you like it so far?
22:06:15 <grom358> sjanssen: so do I put \ at the end of each line that is followed by another line then \ at start of each line?
22:06:18 <shapr> doublec: You're Bluish Coder, yeah?
22:06:26 <doublec> shapr, yep
22:06:34 <shapr> doublec: Cool, I've enjoyed reading your blog from time to time.
22:06:36 <sjanssen> grom358: yes
22:06:44 <doublec> thanks!
22:06:47 <sjanssen> grom358: note that you have to insert \n yourself if you want line breaks
22:07:19 <jkff> My amazon.com order of RWH to St.-Petersburg,Russia has shipped (will arrive in 2-3 days)! (together with two gross books on abstract algebra) The future seems to be coming.
22:07:23 <Nafai> sjanssen: It's pretty nice so far.  My main annoyances so far are that it doesn't have a real headphone jack (stupid mini-USB thing) and the battery life isn't the greatest
22:07:32 <shapr> bluetooth?
22:07:35 <Nafai> Yes
22:07:41 <shapr> A2DP?
22:07:44 <Nafai> bluetooth, wifi, etc
22:07:52 <Nafai> Not sure...what's that? :)
22:07:52 <pumpkin> bah, I'm going to have to reinstall ghc too!?
22:07:59 <shapr> stereo bluetooth music
22:08:09 <sjanssen> pumpkin: what are you having trouble with?
22:08:19 <pumpkin> sjanssen: everything and its brother
22:08:20 <Nafai> shapr: Not currently, unfortunately.
22:08:23 <pumpkin> sjanssen: :P
22:08:32 <sjanssen> pumpkin: removing GHC and Cabal might not even remove your packages
22:08:45 <pumpkin> sjanssen: it started because I wanted to profile my code, but my packages weren't built with profiling enabled
22:08:49 <sjanssen> pumpkin: "ghc-pkg unregister foo" will make GHC forget about foo
22:08:59 <Nafai> Too bad I can't run Haskell on my phone
22:09:01 <sjanssen> you can also give --user and explicit versions there
22:09:12 <pumpkin> sjanssen: I'm not even sure what I'd remove at this point
22:09:17 <pumpkin> it loos like it's all messed up
22:09:45 <pumpkin> it's a real pain, my old code doesn't even build anymore somehow
22:09:52 <pumpkin> all I did was ask it to reinstall my packages
22:10:09 <pumpkin> many failed, due to unsatisfied dependencies with profiling
22:10:13 <pumpkin> and now nothing works :P
22:10:39 * pumpkin cries
22:11:06 <grom358> mmm.. okay how can I convert a string like "75" into an integer?
22:11:09 <pumpkin> sjanssen: what can I rm -rf to kill all my packages?
22:11:13 <pumpkin> grom358: read
22:11:15 <solrize> > read "75" :: Integer
22:11:16 <lambdabot>   75
22:12:21 <sjanssen> pumpkin: you'd have to delete the package database, but I don't think you want to do that
22:12:24 <grom358> > read $ map words ["75", "65"]
22:12:25 <lambdabot>   Couldn't match expected type `Char'
22:12:32 <sjanssen> pumpkin: did you install these to your user database, or to the system db?
22:12:36 <grom358> > map (read . words) ["75", "65"]
22:12:37 <lambdabot>   Couldn't match expected type `Char' against inferred type `String'
22:12:58 <pumpkin> sjanssen: to my user database, but I moved ~/.cabal out of the way to try to start from scratch, and now the cabal-install bootstrap doesn't even work
22:13:11 <sjanssen> pumpkin: oh, well moving .cabal is a bad idea
22:13:30 <pumpkin> sjanssen: why? I wanted to just reinstall it and get rid of all its data
22:13:45 <sjanssen> try "ghc-pkg list"
22:13:53 <grom358> okay.. what is wrong with that snippet?
22:14:02 <jkff> It doesn't typecheck.
22:14:06 <grom358> > map (read . words) ["75", "65"] :: [Int]
22:14:06 <jkff> What are you trying to do? :)
22:14:07 <lambdabot>   Couldn't match expected type `Char' against inferred type `String'
22:14:07 <smarmy> > map read ["75", "65"] :: [Int]
22:14:08 <sjanssen> pumpkin: "ghc-pkg remove --user" all the packages listed in the second DB
22:14:09 <lambdabot>   [75,65]
22:14:09 <pumpkin> sjanssen: ah, it still thinks I have that stuff, from .ghc
22:14:48 <grom358> > map read $ words "75", "65"
22:14:49 <lambdabot>   <no location info>: parse error on input `,'
22:14:57 <sjanssen> pumpkin: the entries in the DB still exist, you just made it so GHC can't find the actual object files (this is why moving .cabal is not such a useful thing)
22:14:58 <grom358> > map read $ words "75 65"
22:14:59 <jkff> grom358, what do you think 'words' does?
22:15:00 <lambdabot>   [* Exception: Prelude.read: no parse
22:15:05 <jkff> > words "Hello good world"
22:15:06 <pumpkin> sjanssen: ah, I see
22:15:07 <lambdabot>   ["Hello","good","world"]
22:15:41 <smarmy> > map read $ words "75 65" :: [Int]
22:15:43 <lambdabot>   [75,65]
22:15:45 <jkff> Hmm, your last snippet should be ok
22:15:48 <jkff> ...And it is.
22:15:54 <grom358> thanks smarmy
22:16:39 <pumpkin> sjanssen: ghc-pkg remove --user isn't working, just displays the help
22:16:40 <jkff> Why does 'map read $ words "75 65"' complain at runtime, not at compiletime?
22:16:52 <pumpkin> it doesn't list remove as a valid command
22:17:08 <sjanssen> pumpkin: oh, I meant unregister
22:17:46 <jkff> Its type is Read a => [a], and it should have complained about not being able to find a Show instance for a, shouldn't it?
22:17:49 <pumpkin> sjanssen: ah, it's removing stuff now
22:18:11 <pumpkin> done
22:18:11 <grom358> > [map read $ words line | line <- lines "75\n95 64"] :: [Int]
22:18:13 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
22:18:32 <smarmy> jkff: i don't think so.  the problem is that it doesn't know what a is, not that it doesn't know if a is in Show
22:18:38 <pumpkin> grom358: you probably want a list of lists?
22:18:39 <solrize> that's a compile time error
22:18:57 <solrize> > map read $ words "75 65" :: [Int]
22:18:59 <lambdabot>   [75,65]
22:19:03 <smarmy> indeed, compile time
22:19:05 <grom358> pumpkin: yeah that is what I'm trying to make
22:19:10 <grom358> oh..
22:19:16 <pumpkin> > [map read $ words line | line <- lines "75\n95 64"] :: [[Int]]
22:19:17 <grom358> > [map read $ words line | line <- lines "75\n95 64"] :: [[Int]]
22:19:19 <lambdabot>   [[75],[95,64]]
22:19:19 <lambdabot>   [[75],[95,64]]
22:19:24 <pumpkin> :)
22:20:07 <pumpkin> sjanssen: now what do you recommend?
22:20:18 <pumpkin> reinstalling cabal, or trying to figure out what's wrong with what I have?
22:20:40 <jkff> > map read $ words "75 65"
22:20:41 <lambdabot>   [* Exception: Prelude.read: no parse
22:20:47 <jkff> Why a runtime exception?
22:20:54 <jkff> It even printed a "["
22:21:08 <pumpkin> > words "75 65"
22:21:10 <lambdabot>   ["75","65"]
22:21:25 <smarmy> > read "1"
22:21:26 <pumpkin> > map read $ words "75 65" :: [Int]
22:21:27 <lambdabot>   * Exception: Prelude.read: no parse
22:21:28 <lambdabot>   [75,65]
22:22:13 <smarmy> eh... it's lambdabot implementation voodoo.  try feeding that to ghc and you won't get past compilation
22:22:43 <sjanssen> pumpkin: do you still have Cabal installed?
22:22:44 <d2dchat> What is the difference between let fooBar = "baz" and fooBar = "baz" ?
22:22:49 <byorgey> jkff: probably because the type of the read defaulted to () or something
22:22:56 <byorgey> jkff: if you add a type signature it should work
22:22:57 <sjanssen> pumpkin: I don't know what command you executed that might have broken things
22:22:59 <jkff> smarmy: Yes, really. I thought so
22:23:04 <jkff> byorgey: I know :)
22:23:08 <byorgey> ok =)
22:23:09 <d2dchat> Why would you ever use let?
22:23:16 <jkff> But your first message about defaults clarifies things.
22:23:31 <byorgey> d2dchat: is this in a do-block?
22:23:47 <byorgey> fooBar = "baz" is a syntax error in a do-block.
22:23:49 <d2dchat> byorgey: I'm reading this book: http://learnyouahaskell.com/starting-out
22:23:50 <d2dchat> and it is
22:23:55 <d2dchat> says:
22:23:57 <lambdabot> Title: Learn You a Haskell for Great Good! - Starting Out
22:24:00 <d2dchat> Note: We can use the let keyword to define a name right in GHCI. Doing let a = 1 inside GHCI is the equivalent of writing a = 1 in a script and then loading it.
22:24:39 <byorgey> d2dchat: ah, yes, it's because it's not exactly the same, the ghci prompt is implicitly inside a giant do-block in the IO monad
22:24:44 <hydo> Are there any syntactic reasons to use camel case for function names or can I safely use all lowercase names without fear of ostracization?
22:24:56 <d2dchat> byorgey: gotcha
22:25:09 <byorgey> hydo: nope, all lowercase is fine
22:25:19 <d2dchat> byorgey: can you use underscores?
22:25:33 <hydo> byorgey: sweet!
22:25:42 <byorgey> d2dchat: yes, but in that case you should fear ostracization ;)
22:25:43 * hydo makes a function called f'''''''''''''''''''''''''''''''''''''''2
22:25:55 * d2dchat slaps the Ruby out of himself
22:25:59 <hydo> that's an infix.
22:26:01 <d2dchat> byorgey: ;) ^
22:26:40 <hydo> err... hrm, I'm still learning - can a function name end with a number?  I'm assuming no, but that's just an assumption.
22:26:46 <adityam> I have a data type, say State, and I have defined a function f :: State -> Int. I want to use this function to define an instance of Ix for State
22:26:49 <byorgey> hydo: sure it can
22:26:55 <hydo> ah, ok.
22:26:59 <byorgey> > let f5 x = x + 5 in f5 9
22:27:00 <lambdabot>   14
22:27:08 <adityam> My attempts so far give  Couldn't match expected type `State' against inferred type `Int'
22:27:14 <adityam> Any suggestions?
22:27:23 <byorgey> hydo: identifiers have to start with a letter or underscore, followed by letters,underscores, or digits
22:27:34 <hydo> noted
22:27:37 <d2dchat> byorgey: what are the limitations for function names?
22:27:46 <d2dchat> haha
22:27:50 <d2dchat> I was typing that as you said it
22:27:59 <adityam> I was defining range (l,u) = range (f l) (f u)
22:27:59 <byorgey> d2dchat: ok =)
22:28:15 <byorgey> @type range
22:28:17 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
22:28:30 <d2dchat> byorgey: what about exclamation marks?
22:28:32 <d2dchat> byorgey: or question marks?
22:28:38 <byorgey> adityam: hm, shouldn't that be  range ((f l), (f u)) ?
22:28:42 <byorgey> d2dchat: nope
22:28:54 <d2dchat> byorgey: damn.. no w00t! functions then
22:28:59 <sjanssen> adityam: you have to "map unf" that, where unf turns the Int back into a State
22:29:02 <adityam> byorgey: sorry, I meant range (f l, f u)
22:29:22 <pumpkin_> sjanssen: now reinstalling cabal is failing... maybe I should just give in and reinstall ghc from scratch?
22:29:30 <sjanssen> adityam: range (f l, f u) has type [Int]
22:29:31 <byorgey> d2dchat: yeah, and no is-square? functions either
22:29:34 <sjanssen> pumpkin_: fails how?
22:29:37 <adityam> sjanssen: Thanks ... I see what was wrong
22:29:47 <pumpkin_> sjanssen: the bootstrap script works fine, but then says Network.HTTP
22:29:50 <d2dchat> byorgey: would've been sorta nice.. o well :)
22:30:02 <sjanssen> pumpkin_: Network.HTTP what?
22:30:10 <pumpkin_> sjanssen: says, that it couldn't find it, sorry
22:30:21 <pumpkin_> sjanssen: even though it just downloaded it
22:30:36 <byorgey> d2dchat: you could just store all your functions in a big map indexed by Strings and then look them up by name when you want to use them ;)
22:30:42 <sjanssen> pumpkin_: does installing it manually work?
22:31:00 <sjanssen> pumpkin_: perhaps you have a broken version installed (might be possible if you were mucking about with the installed files manually)
22:31:09 <d2dchat> byorgey: and generate all my code using genetic algos based on specifications =D
22:31:18 <d2dchat> byorgey: I like your thinkin
22:31:23 <pumpkin_> sjanssen: I haven't mucked around with anything :/ all I did was call install --reinstall on all my installed packages and this crap happened :/
22:31:33 <pumpkin_> sjanssen: not sure how to install it manually
22:31:36 <byorgey> d2dchat: exactly!  you can use GTH (Genetic Template Haskell)
22:32:04 <sjanssen> pumpkin_: moving .cabal and unregistering packages counts as "mucking" :)
22:32:17 <pumpkin_> sjanssen: it was mucked up before then :P
22:32:35 <d2dchat> byorgey: does that exist?
22:32:41 <sjanssen> pumpkin_: get the tarball; runghc Setup configure --prefix=$HOME/.cabal --user; runghc Setup build; runghc Setup install
22:33:23 <pumpkin_> sjanssen: I wanted to profile, so I enabled profiling and tried to reinstall fft with profiling, which then said that its dependencies didn't have profiling enabled, so I went through all installed packages and tried to reinstall them, which led to this epic mess
22:33:38 <pumpkin_> sjanssen: did that, trying to install cabal again now
22:34:01 <d2dchat> byorgey: ah wait you mean combine the genetic algos with http://hackage.haskell.org/cgi-bin/hackage-scripts/package/template-haskell
22:34:01 <pumpkin_>     Could not find module `Network.HTTP':
22:34:05 <pumpkin_> :(
22:34:07 <lambdabot> Title: HackageDB: template-haskell-2.3.0.0, http://tinyurl.com/6aoczl
22:34:11 <d2dchat> byorgey: yes?
22:34:28 <byorgey> d2dchat: yes, I was joking =)
22:34:37 <d2dchat> byorgey: hey, it's feasible!
22:34:38 <byorgey> d2dchat: Template Haskell is real, it lets you generate code at compile-time
22:34:44 <sjanssen> pumpkin_: yes, you need to install the HTTP library, since the one you have is apparently broken
22:34:46 <byorgey> yes, actually, it is =)
22:34:47 <pumpkin_> this is all happening at the worst time :P I have my final project due in a few hours
22:35:11 <d2dchat> byorgey: I think it would be cool :).. specification driven development in haskell
22:35:27 <byorgey> heh, interesting
22:35:32 <pumpkin_> sjanssen: I'm running the exact same bootstrap.sh as I did a week ago when I first installed cabal :/ and it's downloading the same HTTP it seems
22:35:33 <d2dchat> byorgey: fire up some EC2 instances, slam out code =D
22:35:49 <byorgey> you could use QuickCheck for some nice evaluation function specification
22:35:53 <d2dchat> byorgey: may the best functions win!
22:36:13 <sjanssen> pumpkin_: try "ghc-pkg unregister --user HTTP" before running the bootstrap
22:36:52 <d2dchat> ah woot
22:37:06 <d2dchat> byorgey: QuickCheck looks awesome
22:37:14 <d2dchat> in addition to HUnit which I just discovered
22:37:29 <byorgey> d2dchat: QuickCheck is indeed awesome.
22:37:31 <pumpkin_> sjanssen: whee, cabal installed now :P
22:37:37 <roconnor> I'm thinking I should re-export my data types in my various modules.
22:37:40 <d2dchat> which is better HUnit or HTF?
22:37:46 <byorgey> d2dchat: it's helped me discover plenty of bugs.
22:37:50 <pumpkin_> sjanssen: now I should just enable profiling in my config and reinstall all my old packages (*sigh*)
22:38:22 <byorgey> d2dchat: IIRC, HTF is a sort of meta-package that lets you easily assemble larger test suites out of individual QuickCheck and/or HUnit tests.
22:38:47 <pumpkin_> sjanssen: does that sound about right?
22:39:03 <sjanssen> pumpkin_: yes, probably
22:39:06 <d2dchat> ah I see
22:39:07 <Shimei> Out of curiosity, has anyone looked into how hard it would be to add some kind of apt/dpkg support to cabal/cabal-install? Having just gotten into using cabal-install I think it's awesome, but it'd be nice if it integrated into my distro better.
22:39:33 <sjanssen> Shimei: there is some work in automatically converting cabalized packages into Debian packages
22:39:45 <Shimei> Oh, awesome. :D
22:40:11 <pumpkin_> sjanssen: bah, more failure :/
22:40:17 <pumpkin_> now it can't find CArray
22:40:20 <pumpkin_> although it's there
22:40:23 <sjanssen> what is CArray?
22:40:25 <pumpkin_> actually maybe I should unregiser it
22:40:29 <sjanssen> yes
22:40:47 <sjanssen> pumpkin_: you deleted the object and .hi files, you *must* unregister those packages you've corrupted
22:40:59 <pumpkin_> sjanssen: I thought I'd unregistered them all though
22:41:11 <sjanssen> pumpkin_: apparently not :)
22:42:21 <hydo> A function like `elem` is actually defined with the name of `elem`  - ie the function's real name isn't elem and the `'s aren't something caught by the parser, correct?  Which is why 8 `>` 7.
22:42:54 <pumpkin_> sjanssen: ah, I didn't use force when I unregistered them so some refused to unregister
22:43:01 <sjanssen> hydo: 8 `>` 7 isn't invalid
22:43:09 <hydo> err, which is why 8 `>` 7 doesn't work.
22:43:13 <sjanssen> pumpkin_: ah, you'd probably have to do it in dependency order
22:43:23 <pumpkin_> sjanssen: that was my original problem
22:43:30 <byorgey> hydo: hm? no, the backticks are just a way to make a function infix
22:43:33 <pumpkin_> there's no way to ask cabal (it seems) to output the packages in dependency order
22:43:41 <pumpkin_> if there were, I could've just reinstalled them normally
22:43:46 <sjanssen> hydo: elem is the function's name, the backticks are a mechanism to make a function infix
22:43:52 <hydo> ugh.
22:43:54 <pumpkin_> and I didn't want to go toposorting them myself
22:43:57 <hydo> I thought I had this. heh
22:44:10 <byorgey> hydo: functions with names that aren't alphanumeric are operators, and are infix by default
22:44:12 <hydo> so why then doesn't 8 `>` 7 work?
22:44:14 <byorgey> like + or <
22:44:20 <hydo> if they are superfluous ?
22:44:22 <byorgey> because > is already infix
22:44:35 <ski_> hydo : because `>' is already an infix operator
22:44:35 <byorgey> to make an operator prefix, you can put it in parens
22:44:38 <sjanssen> hydo: it only works on non-operator names
22:44:39 <byorgey> > (+) 3 5
22:44:41 <lambdabot>   8
22:44:42 <hydo> why then isn't elem already an infix?
22:44:46 <hydo> ah
22:45:00 <hydo> sjanssen: ok, that makes partial sense at least.
22:45:08 <sjanssen> hydo: "+" is an operator, "elem" is a name
22:45:13 <ski_> > let x `add` y = x * y in add 2 3
22:45:15 <lambdabot>   6
22:45:51 <sjanssen> operators are always infix (or in sections), names are not infix unless they're wrapped in `
22:45:54 <hydo> ok, so operators always have single char names?  Otherwise, what's the difference between + and elem?
22:46:12 <hydo> ok
22:46:13 <pumpkin_> there's plenty of multichar operators
22:46:16 <sjanssen> hydo: operators can have many characters, but only certain characters are valid in operators
22:46:21 <hydo> ok, I'm overcomplicating this I think.
22:46:30 <pumpkin_> > ((+1) &&& (+2)) 5
22:46:32 <lambdabot>   (6,7)
22:46:44 <hydo> Right, you could write a function callled +++++++++++++ if you wanted to and treat it like an operator?
22:47:04 <dmwit> > let a +++++++++ b = 3 in 7 +++++++++ "hello"
22:47:05 <lambdabot>   3
22:47:06 <sjanssen> hydo: yes, ++++ is an operator
22:47:12 <hydo> well... if you were wacked out on some badass columbian bam-bam
22:47:24 <pumpkin_> > let 2 + 2 = 5 in 2 + 2
22:47:26 <lambdabot>   5
22:47:52 <sjanssen> hydo: http://haskell.org/onlinereport/lexemes.html#sect2.4
22:47:53 <lambdabot> Title: Haskell 98 Lexical Structure
22:48:43 <sjanssen> "An identifier consists of a letter followed by zero or more letters, digits, underscores, and single quotes."
22:49:01 <sjanssen> "Operator symbols are formed from one or more symbol characters, as defined above"
22:49:14 <hydo> sjanssen: thanks for that.  Reading.
22:49:17 <hydo> thanks for the help, everyone.
22:50:40 <mmorrow> dons: i was just looking at Data.Binary sources and saw that it uses a standard state monad, for some reason i thought that it had a cps implem internally?
22:51:42 <grom358> I have list of list [[Int]] and want to apply a function to the first two list. The function returns a new list which replace this two list. I want to keep doing this till I have reduce to one row
22:52:26 <sjanssen> go (x:y:xs) = go (f x y:xs); go xs = xs
22:52:45 <pumpkin_> sjanssen: I think you saved me!
22:53:16 <pumpkin_> thanks :)
22:53:27 <roconnor> > map ord "“”"
22:53:29 <lambdabot>   [8220,8221]
22:53:29 <dmwit> go (x:y:xs) = go (f x y : go f xs)
22:54:21 <grom358> is go a builtin?
22:54:23 <grom358> :t go
22:54:24 <lambdabot> Not in scope: `go'
22:54:29 <pumpkin_> another question for the experts, I @let schwartz op f = fmap snd . op (comparing fst) . fmap (f &&& id)  earlier, but it's behaving strangely
22:54:31 <dmwit> Actually, it sounds a lot like a fold.
22:54:37 <dmwit> foldr1 or so
22:54:39 <dmwit> :t foldr1
22:54:40 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
22:55:14 <mmorrow> grom358: it's the helper function name of choice ;)
22:55:20 <roconnor> Exporting datatypes from several modules has cut down the number of import statments I need by a few.
22:55:26 <travisbrady> anyone have pointers for what to do when you find yourself with lots of variables to thread through your code to maintain various kinds of state?
22:55:29 <grom358> :info go
22:55:53 <pumpkin_> > schwartz minimumBy snd $ [(1,2), (2,3), (4,-1)] -- is wrong
22:55:55 <lambdabot>   (-1,-1)
22:56:19 <sjanssen> grom358: I was just showing you the implementation of the function you want
22:56:36 <grom358> so.. do I put my function name in place of f?
22:56:41 <sjanssen> yes
22:57:06 <sjanssen> as "go" is the helper function name of choice, "f" is the function variable name of choice
22:58:02 <dolio> Unless it's a continuation, in which case it's k.
22:58:03 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
22:58:16 <sjanssen> pumpkin_: with minimumBy, you don't want to use fmap
22:58:44 <sjanssen> > fmap (const ()) ('a', 'b') -- fmap on (,) maps on the second component
22:58:45 <lambdabot>   ('a',())
22:58:54 <pumpkin_> sjanssen: dolio wrote it earlier with minimumBy, but I think he did something else (damn my short scrollback) too to make it work
22:59:02 <roconnor> > minimumBy (comparing snd) $ [(1,2), (2,3), (4,-1)]
22:59:03 <lambdabot>   (4,-1)
22:59:17 <dolio> What are we talking about?
22:59:32 <roconnor> > let schwartz op f = fmap snd . op (comparing fst) . fmap (f &&& id) in schwartz minimumBy snd $ [(1,2), (2,3), (4,-1)]
22:59:34 <lambdabot>   (-1,-1)
22:59:37 <pumpkin_> dolio: your schwartz again :P I can't get the fmap version of it working working
22:59:48 <pumpkin_> -working
22:59:57 <sjanssen> pumpkin_: basically you only sometimes want to use "fmap".  If op returns a list, you should use fmap, if it returns something else you don't
22:59:57 <dolio> Oh. You need to change it so that minimumBy returns an Identity a.
23:00:15 <pumpkin_> dolio: ooh, that was the missing bit I forgot
23:00:24 <roconnor> :(
23:00:26 <sjanssen> dolio: it might be better to pass the "fmap" as an argument
23:00:35 <roconnor> dolio: we should have got a type error
23:00:39 <roconnor> ;(
23:00:56 <roconnor> stupid fmap
23:00:59 <dolio> Well, you could do that, too. Even more parameters.
23:01:09 <pumpkin_> that fmap working on snd is counterintuitive, why does it do that?
23:01:22 <sjanssen> or make "op" responsible for the transformation
23:01:27 <roconnor> > fmap (+1) (10,20)
23:01:29 <lambdabot>   (10,21)
23:01:31 <sjanssen> pumpkin_: because it is useful
23:01:49 <ski_> instance Functor (w,)
23:02:14 <roconnor> I suppose you could type class the ops to associate untranformers
23:02:32 <pumpkin_> sjanssen: couldn't I just use second on it?
23:02:38 <sjanssen> you could also use some type class magic
23:02:44 <pumpkin_> > second (+1) (10, 20)
23:02:46 <lambdabot>   (10,21)
23:02:50 <ski_> ("untransformers" ?)
23:03:02 <sjanssen> pumpkin_: sure, but (w,) is also a Monad, so it should have a Functor instance
23:03:06 <roconnor> ski_: they are less than meets the eye
23:03:07 <pumpkin_> ah
23:03:18 <ski_> roconnor : what are they ?
23:03:43 <roconnor> they undo a Schwartzian transform
23:04:00 * ski_ has no idea what a Schwartzian transform is
23:04:25 <ski_> @type Control.Monad.Writer.WriterT
23:04:27 <lambdabot> forall (m :: * -> *) a w. m (a, w) -> WriterT w m a
23:04:49 <ski_> is there any reason that's not `(w, a)', instead of `(a, w)', there ^ ?
23:04:56 <roconnor> ski_ http://en.wikipedia.org/wiki/Schwartzian_transform
23:04:58 <lambdabot> Title: Schwartzian transform - Wikipedia, the free encyclopedia
23:05:13 <Cale> ski_: Not a *good* reason.
23:05:17 <roconnor> > let schwartz op f = fm snd . op (comparing fst) . fm (f &&& id) where fm = fmap in schwartz minimumBy snd $ [(1,2), (2,3), (4,-1)]
23:05:19 <lambdabot>   Couldn't match expected type `[]' against inferred type `(,) a'
23:05:26 <roconnor> there is the type error
23:05:34 <ski_> Cale : well .. i only count good reasons :)
23:05:39 <roconnor> go monomorphism restriction!
23:05:52 <roconnor> finally, you did something useful
23:07:43 <pumpkin_> if when profiling, a lazy list is expensive to compute, and some other function than the one that made hte list is operating on it, does the time get billed to the person consuming the expensive list of the function that made it?
23:08:08 <pumpkin_> "person"
23:08:21 <roconnor> pumpkin_: are you trying to descripe the Schwartzian transform?
23:08:49 <roconnor> describe
23:09:00 <pumpkin_> roconnor: nah, I'm just trying to figure out why my program is slow, and it turned out the minimumBy (comparing ...) isn't slow at all, despite not being schwartzed
23:09:31 <ski_> (btw, `f &&& id' is `swap . graph f')
23:09:37 <roconnor> well certainly snd is a very cheap fuction, cheaper than the overhead of the transform.
23:10:01 <pumpkin_> roconnor: snd isn't my function, but my function is some pretty simple arithmetic
23:10:15 <pumpkin_> snd was just the example I was using to figure out what was going on
23:10:32 <roconnor> pumpkin_: ah.  I believe the producer of the list is billed
23:10:55 <roconnor> wait
23:11:01 <roconnor> lemme reread what you wrote
23:11:33 <roconnor> pumpkin_: are you talking about map f (lazy list) ?
23:11:35 <dibblego> what's a good example to demonstrate "on" to a beginner?
23:11:57 <pumpkin_> roconnor: yeah, something like that, where the map is in one function and the lazy list was made somewhere else (and is expensive to compute)
23:12:35 <roconnor> well f will be billed directly to f, and indirectly to the person calling map f
23:12:45 <roconnor> but the list production will be billed to the producer
23:12:48 <roconnor> IIRC
23:12:49 <pumpkin_> ah ok
23:13:26 <sjanssen> pumpkin_: http://hpaste.org/12655
23:13:42 <roconnor> I suppose if f is a complex expression, it will be billed to the caller (or to a SCC if added)
23:14:17 <pumpkin_> sjanssen: wow, that looks very magical :) I'll give it a better look later, busy trying to figure out what's so slow here right now :/
23:14:21 <roconnor> sjanssen: not quite what I was thinking
23:15:43 <sjanssen> roconnor: it's a variant of the class deepest functor problem
23:15:47 <pumpkin_> in http://hpaste.org/12656 it doesn't even show me the length1 cost center in the .prof file
23:15:56 <sjanssen> s/class/classic/
23:15:59 <mjrosenb> hey, is there anything like ocsigen that's built around haskell?
23:16:10 <mjrosenb> because i've just discovered that i hate ocaml
23:16:23 <sjanssen> "map (assoc f)" is a bit dissatisfying, must fix that
23:16:23 <roconnor> sjanssen: ... but now I see what I was thinking doesn't work.
23:16:37 <sjanssen> mjrosenb: what is ocsigen?
23:16:52 <mjrosenb> http://ocsigen.org/
23:17:24 <sjanssen> HAppS might do what you want
23:17:50 <roconnor> pumpkin_: Do you have to assocated SCCs with let/where expressions?
23:17:56 <roconnor> associate
23:18:03 * roconnor forgets
23:18:16 <pumpkin_> don't think so, just trying to put them around the place because most of my cost is in that function
23:18:22 <pumpkin_> because it gets called a lot
23:18:31 <pumpkin_> I imagine the lenghts are killing me
23:18:51 <pumpkin_> or the partition itself, I guess
23:18:54 <roconnor> pumpkin_: are you compling w/o optimizations?
23:18:59 <pumpkin_> -O2
23:19:33 <pumpkin_> aha, I just had to add an extra set of parens
23:19:35 <pumpkin_> around my cost centers
23:22:24 <pumpkin_> so yeah, most of my time is spent in the partition function :/
23:24:53 <pumpkin_> @src partition
23:24:53 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
23:24:53 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
23:24:53 <lambdabot>                               | otherwise = (ts, x:fs)
23:52:28 <mmorrow> hehe this is a fun one
23:52:30 <mmorrow> , $(let go n f slop = do {x:xs <- replicateM (n+1) (newName "x"); let {ps = foldr (\a b -> infixP a '(:) b) (varP x) (fmap varP xs); es = fmap varE xs}; k <- newName "k"; [|fix $(lamE [varP k, varP x] (caseE (varE x) [match ps (normalB [|$(foldl appE f es) : $(varE k) $(varE x)|]) [],match wildP (normalB [|[]|]) []]))|] } in go 5 [|(,,,,)|] [|(const [])|]) [0..]
23:52:32 <lunabot>  [(0,1,2,3,4),(5,6,7,8,9),(10,11,12,13,14),(15,16,17,18,19),(20,21,22,23,2...
23:52:57 <mmorrow> eh, i forgot to use that "slop" parameter
23:53:45 <dolio> mmorrow: That's surprising. I was under the impression it used continuation passing as well.
23:54:22 <mmorrow> dolio: totally. i smell optimization opportunidad!
23:54:50 <mmorrow> i thought dons said they initially used ContT in the implem
23:55:16 <mmorrow> then switched to manual cps, but i'm either missing it or he was refering to an older version..
23:55:45 <dolio> Well, if it can be made faster, that's good. It might make my bytestring-show competitive with regular Show.
23:56:06 <mmorrow> that'd be sweet
23:56:18 <pumpkin_> hmm, this feels like it should be easy to optimize
23:56:21 <pumpkin_> but I'm clearly doing it wrong
23:56:28 <mmorrow> yeah, i bet a ton of stuff would get an instant boost in binary got faster
23:56:37 <mmorrow> s/in/if/
23:58:34 <dolio> Agda might get faster. :)
