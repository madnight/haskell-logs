00:02:31 <Gracenotes> grep -r 'instance Monad' . (more monads than I thought in GHC source)
00:02:46 <znutar> is there any compelling reason I'd want to install 6.10 manually on a new ubuntu install rather than just using the package that gives you 6.8.2
00:05:14 <augustss> znutar: depends if you need any of the new features
00:06:27 <znutar> I'm not aware of needing any of the new features...
00:09:24 <chromakode> are theorists obsessed with bananas, or what?
00:10:56 <qebab> there are probably worse things to be obsessed with
00:14:16 <BeelsebobWork> Oh dear god... why does everyone seem to think the new logo for Haskell has to say "Haskell, we're all about monads"
00:14:22 <BeelsebobWork> >.<
00:16:12 <Gracenotes> Monads may become as marketable as OOP in 10 years :P
00:16:14 <ddarius> BeelsebobWork: Because people are ignorant.
00:16:28 <BeelsebobWork> :'(
00:16:35 <Gracenotes> although I have yet to comprehend 'em >_>
00:17:02 * BeelsebobWork hopes we don't have a simple voting mechanism for the logo, because if we do, one of the "bind" based logos is gonna win
00:17:12 <ddarius> Gracenotes: Can you use them?
00:17:25 <BeelsebobWork> Gracenotes: all the hype about not understanding monads is rather overzealous IMHO -- people seem to think they're somehow magical
00:17:31 <Gracenotes> for the most part, yes
00:17:38 <ddarius> Gracenotes: Then you understand them.
00:17:40 <Gracenotes> some of them.
00:17:40 <BeelsebobWork> in reality, it's just another class, and if you're using it, and understanding what they do for most Monads, you understand them
00:17:54 <Gracenotes> basic ones, like List and Maybe and (partially) Writer
00:17:55 <BeelsebobWork> you may go further and try and understand what the Monad laws are, but that's really not necessary
00:18:19 <BeelsebobWork> what I want to see most people understanding is when *not* to use them
00:18:54 <ddarius> Gracenotes: Making a (perhaps new) monad requires knowing how to model whatever effect it is supposed to capture.  Modelling the effect may well be complex and not easy, but that is independent of monads.
00:18:55 <chromakode> BeelsebobWork: approval voting would do nicely there.
00:19:09 <Gracenotes> yeah, monads are somewhat like magic. The do notation pretty effectively makes it into a black box, I think :)
00:19:17 <BeelsebobWork> e.g. I see people all the time doing things like do x <- xm; y <- ym; return f x y, when they could just be using applicatives
00:19:25 <BeelsebobWork> chromakode: approval voting?
00:19:27 <ddarius> Gracenotes: do notation is extremely light sugar
00:19:58 <chromakode> BeelsebobWork: basically, you can vote "yes" for as many as you want... http://en.wikipedia.org/wiki/Approval_voting
00:20:54 <BeelsebobWork> chromakode: hmm, I think I'd want something closer to greek democracy -- in which one of the founding ideas was that you could vote *no* to things as well as explicitly yes
00:21:10 <chromakode> that's an excellent point!
00:21:14 <BeelsebobWork> i.e. in modern voting mechanisms there tends to be no difference between no and abstain
00:21:22 <chromakode> I highly recommend wikipedia's list of voting mechanisms, then.
00:21:28 <chromakode> I don't remember much of it, but it was fascinating reading.
00:21:30 <BeelsebobWork> but I do like the sound of approval voting
00:21:37 <BeelsebobWork> it would stop votes getting spread around the place
00:21:51 <Gracenotes> ranked voting, the algorithm's complicated enough to make it seem like it's sorta random
00:22:08 <Gracenotes> so people feel better if their choice doesn't win
00:22:18 <Gracenotes> of course, the algorithm is entirely fair
00:22:24 <BeelsebobWork> I'm not keen on ranked, because it forces you to chose between two things you consider "equal"
00:22:37 <BeelsebobWork> "assign a score between -5 and 5 to each of these" could work
00:22:40 <chromakode> http://en.wikipedia.org/wiki/Voting_system#Criteria_in_evaluating_single_winner_voting_systems
00:22:54 <BeelsebobWork> especially if it starts defaulted at 0 so you only have to care about the ones you actually like/dislike
00:23:24 <Gracenotes> so -- how would you get the Cartesian product of two lists using applicatives?
00:23:27 <Gracenotes> :)
00:23:54 <BeelsebobWork> > [1,2,3] <^(*)^> [2,3,4]
00:23:55 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
00:24:20 <BeelsebobWork> @let x <^ f = f <$> x
00:24:21 <lambdabot>  Defined.
00:24:31 <BeelsebobWork> @let f ^> x = f <*> x
00:24:32 <lambdabot>  Defined.
00:24:33 <BeelsebobWork> > [1,2,3] <^(*)^> [2,3,4]
00:24:34 <lambdabot>   [2,3,4,4,6,8,6,9,12]
00:24:38 <chromakode> holy crap!
00:24:53 <chromakode> but wait, that's not the cartesian product...
00:24:55 <BeelsebobWork> (InfixApplicative module to get those two ops)
00:25:16 <BeelsebobWork> oh, sorry, no
00:25:22 <BeelsebobWork> > [1,2,3] <^(,)^> [2,3,4]
00:25:24 <lambdabot>   [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,2),(3,3),(3,4)]
00:25:30 <chromakode> :)
00:25:50 <Gracenotes> hm, I haven't really seen functors and applicatives around that much
00:26:03 <Gracenotes> I don't recall RWH talking about them, although I might have been reading while sleeping :P
00:26:12 <BeelsebobWork> tbh though, I prefer [(x,y) | x <- [1,2,3], y <- [2,3,4]] for that job
00:26:18 <BeelsebobWork> no -- that's why I dislike RWH
00:26:21 <Gracenotes> I have implemented a few functors though.
00:26:29 <ddarius> Gracenotes: Every monad is both a functor and applicative.
00:26:31 <BeelsebobWork> by "real world" it means "what the comunity is wanking over at the moment"
00:26:45 <Gracenotes> for [], Maybe, (->), a Tree, a Monad (liftM), etc.
00:26:49 <BeelsebobWork> (even if they may not have written the instances)
00:26:57 <Gracenotes> @type liftM
00:26:58 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:27:10 <BeelsebobWork> (if they haven't, you can quickly with fmap = liftM, pure = return and <*> = ap
00:27:19 <jeffwheeler> Beelsebob: do you dislike the bind logos? :(
00:27:24 <chromakode> >show "test"
00:27:30 <chromakode> > show "test"
00:27:31 <BeelsebobWork> jeffwheeler: yes -- with a passion
00:27:32 <lambdabot>   "\"test\""
00:27:36 <Gracenotes> BeelsebobWork: suggest any good tutorials for functors and applicatives?
00:27:42 <Gracenotes> *would you
00:27:43 <jeffwheeler> BeelsebobWork: Oh well. :)
00:28:27 <BeelsebobWork> Gracenotes: I'm not sure they even need any good tutorials -- some experimenting with fmap and <*> should get you there in not long at all
00:28:45 <BeelsebobWork> > fmap f [x,y,z]
00:28:46 <lambdabot>   Add a type signature
00:28:49 <BeelsebobWork> > fmap f [x,y,z] :: Expr
00:28:51 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
00:28:56 <BeelsebobWork> > fmap f [x,y,z] :: [Expr]
00:28:57 <lambdabot>   [f x,f y,f z]
00:29:14 <BeelsebobWork> > (fmap f [x,y,z]) <*> [a,b,c] :: [Expr]
00:29:15 <lambdabot>   [f x a,f x b,f x c,f y a,f y b,f y c,f z a,f z b,f z c]
00:29:22 <Gracenotes> eek
00:29:26 <chromakode> cool!
00:29:42 <Gracenotes> > map f [x, y, z] :: [Expr]
00:29:43 <lambdabot>   [f x,f y,f z]
00:29:58 <Gracenotes> hm.
00:30:00 <BeelsebobWork> fmap can also be written as <$>, rather nicely, meaning you can do this kinda thing...
00:30:00 <BeelsebobWork> > subtract <$> (Just 5) <*> (Just 6)
00:30:01 <lambdabot>   Just 1
00:30:10 <BeelsebobWork> > subtract <$> (Just 5) <*> Nothing
00:30:11 <lambdabot>   Nothing
00:30:16 <jeffwheeler> What does <*> do?
00:30:21 <chromakode> it's fmap
00:30:22 <opqdonut> ap
00:30:24 <Gracenotes> <*> is a sort of liiftM, right?
00:30:29 <Gracenotes> except for functors
00:30:32 <BeelsebobWork> jeffwheeler: it takes the values out of two applicatives
00:30:45 <BeelsebobWork> and applies the ones on the left to the ones on the right
00:30:47 <opqdonut> :t (<*>)
00:30:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:30:51 <jeffwheeler> > (Just 5) <*> Nothing
00:30:52 <lambdabot>       No instance for (Num (a -> b))
00:30:52 <lambdabot>        arising from the literal `5' at <...
00:31:05 <BeelsebobWork> > (Just (+5)) <*> Just 6
00:31:06 <lambdabot>   Just 11
00:31:13 <Gracenotes> a list is an applicative, then?
00:31:18 <BeelsebobWork> yep
00:31:21 <BeelsebobWork> all monads are applicatives
00:31:25 <BeelsebobWork> (and more)
00:31:30 <opqdonut> and practically every functor is
00:31:34 <chromakode> > [(+5)] <*> [1]
00:31:36 <lambdabot>   [6]
00:31:41 <chromakode> > [(+5)] <*> [1, 2]
00:31:41 <BeelsebobWork> all applicatives are functors
00:31:42 <lambdabot>   [6,7]
00:31:54 <BeelsebobWork> > pure (+5) <*> [1,2,3,4,5]
00:31:55 <lambdabot>       Ambiguous occurrence `pure'
00:31:55 <lambdabot>      It could refer to either `Control.Appl...
00:32:02 <opqdonut> somebody offered F a = L [a] | I (IO (IO a)) as an example of a functor that's not applicative
00:32:02 <Gracenotes> > (+5) <$> [1,2] <*> [3,4]
00:32:03 <BeelsebobWork> > Control.Applicative.pure (+5) <*> [1,2,3,4,5]
00:32:04 <lambdabot>       No instance for (Num (a -> b))
00:32:04 <lambdabot>        arising from the literal `5' at <...
00:32:05 <lambdabot>   [6,7,8,9,10]
00:32:24 <Gracenotes> > id <$> [1,2] <*> [3,4]
00:32:25 <lambdabot>       No instance for (Num (a -> b))
00:32:25 <lambdabot>        arising from the literal `1' at <...
00:32:30 <BeelsebobWork> > (+) <$> [1,2] <*> [3,4]
00:32:32 <lambdabot>   [4,5,5,6]
00:32:35 <chromakode> hmm.
00:32:50 <Gracenotes> @type ([1,2] <*> [3,4])
00:32:52 <lambdabot>     Ambiguous type variable `a' in the constraint:
00:32:52 <lambdabot>       `Num a' arising from the literal `3' at <interactive>:1:12
00:32:52 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
00:32:53 <chromakode> :t (<$)>
00:32:55 <lambdabot> parse error (possibly incorrect indentation)
00:32:58 <chromakode> :t (<$>)
00:32:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:33:03 <BeelsebobWork> > (+) <$> [1,2]
00:33:04 <lambdabot>       Overlapping instances for Show (a -> a)
00:33:04 <lambdabot>        arising from a use of `s...
00:33:10 <BeelsebobWork> bugger
00:33:20 <BeelsebobWork> that gets you [(1+), (2+)]
00:33:29 <BeelsebobWork> then you can apply all those to something else with <*>
00:33:31 <chromakode> so you're basically representing computations, right
00:33:42 <Gracenotes> > (*) ($) [1,2] <*> [3,4]
00:33:44 <lambdabot>   Couldn't match expected type `(a -> b) -> a -> b'
00:33:46 <BeelsebobWork> chromakode: it's representing things that can be applied
00:33:54 <opqdonut> it's "representing" sequencing
00:33:58 <BeelsebobWork> > (*) <$> [1,2] <*> [3,4]
00:34:00 <lambdabot>   [3,4,6,8]
00:34:04 <opqdonut> arguments before applications
00:34:06 <chromakode> BeelsebobWork: so, one level above "first class functions"?
00:34:08 <Gracenotes> oh, oh
00:34:39 <opqdonut> chromakode: not really
00:34:40 <BeelsebobWork> I'm not sure what you mean by that
00:34:47 <chromakode> sorry, it was vague and poorly expressed.
00:34:56 <BeelsebobWork> Gracenotes: you can then use the synonyms for <$> and <*> to get that infix
00:35:05 <BeelsebobWork> > [1,2] <^(*)^> [3,4]
00:35:07 <lambdabot>   [3,4,6,8]
00:35:10 <opqdonut> :)
00:35:13 <Gracenotes> > (^) <$> [1,2] <*> [3,4]
00:35:14 <lambdabot>   [1,1,8,16]
00:35:41 <Gracenotes> > (\x -> \y -> (x, y)) <$> [1,2] <*> [3,4]
00:35:43 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
00:36:08 <BeelsebobWork> > (,) <$> [1,2]
00:36:09 <lambdabot>       Overlapping instances for Show (b -> (a, b))
00:36:09 <lambdabot>        arising from a use ...
00:36:16 <BeelsebobWork> >.<
00:36:25 <BeelsebobWork> > (,) <$> [1,2] <*> [3,4]
00:36:25 <Gracenotes> yeah, just what is the , operator anyway?
00:36:26 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
00:36:34 <chromakode> > 1 (,) 2
00:36:35 <opqdonut> Gracenotes: tuple constructor
00:36:35 <lambdabot>       No instance for (Num ((a -> b -> (a, b)) -> t -> a1))
00:36:35 <lambdabot>        arising fr...
00:36:35 <Gracenotes> @type (,)
00:36:37 <lambdabot> forall a b. a -> b -> (a, b)
00:36:42 <BeelsebobWork> > (,) 1 2
00:36:43 <lambdabot>   (1,2)
00:36:53 <BeelsebobWork> > 1 , 2 -- although it's a hack, so this doesn't work
00:36:54 <lambdabot>   <no location info>: parse error on input `,'
00:36:58 <BeelsebobWork> :(
00:37:11 <Gracenotes> ...oh, it's not 'built into' the language?
00:37:25 <BeelsebobWork> well no -- that's exactly the problem -- it *is*
00:37:33 <BeelsebobWork> it's not just a constructor
00:37:37 <chromakode> it's magic.
00:37:44 <chromakode> parser magic
00:37:48 <Gracenotes> haskell is magic :/
00:38:14 <chromakode> what are some other interesting monads to use with functors?
00:38:18 <Gracenotes> it's all sitting there,,, waited to be magically evaluated
00:38:29 <Gracenotes> (the code, that is)
00:38:46 <BeelsebobWork> chromakode: Behavior and Event are very interesting applicatives
00:38:54 <opqdonut> reader also ;)
00:39:26 <chromakode> thanks.
00:40:06 <BeelsebobWork> http://netsuperbrain.com/blog/posts/introducing-reactive-events/ <-- fun with events that also happens to have some functor/applicative stuff in it
00:43:05 <jsn> does Foreign.Alloc.malloc throw an exception when there is not enough memory, or does it simply die?
00:44:14 <jsn> eek
00:44:27 <jsn> i just did    mallocBytes maxBound
00:48:59 <Gracenotes> are there any good tutorials/exercises out there about using monads? Not making monads, just using pre-existing ones
00:49:55 <BeelsebobWork> on netsuperbrain?  No, the ones there are about Reactive, and that has a very heavy emphasis on applicative programming
00:55:23 <Gracenotes> should be too hard to make my own exercises :P
01:24:32 <cads> is there a paper out there that weaves haskell and lisp lore together into something entertaining and illuminating?
01:26:04 <Megzlna> Gracenotes, I loked at these...
01:26:16 <yakov> cads, Qi?
01:26:38 <Megzlna> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
01:26:44 <Megzlna> http://www.haskell.org/haskellwiki/Monads_as_Computation
01:26:54 <Megzlna> http://kawagner.blogspot.com/2007/02/understanding-monads-for-real.html
01:27:01 <Megzlna> http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
01:27:11 <Megzlna> http://www.prairienet.org/~dsb/monads.htm
01:27:21 <nanothief> How is getContents implemented? Is it possible to create using getChar (and other functions), or does it need to be implemented by ghc?
01:27:24 <Megzlna> http://www.haskell.org/all_about_monads/html/index.html
01:28:37 <cads> wow qi looks like haskell and lisp got together and did the freaky thang
01:28:38 <blackh> nanothief: It uses the rather clever function unsafeInterleaveIO
01:29:30 <nanothief> ahh so it "cheats". I was trying to write a similar function with a State monad, and couldn't figure out how to do it :)
01:29:47 <Megzlna> data Foo = Foo { name_Foo :: String }
01:32:31 <Cale> cads: Liskell looks like that even moreso :)
01:33:38 <nanothief> blackh: what does unsafeInterleavIO do? It doesn't have any documentation at http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
01:34:29 <flux> perhaps it's a gentle discouragement against using it..
01:34:32 <blackh> nanothief: Click on the source button.... I think haddock loses documentation sometimes in the 6.10.1 docs.
01:35:30 <nanothief> blackh, what source button?
01:35:57 <blackh> nanothief: I mean the source link.  It says "'unsafeInterleaveIO' allows 'IO' computation to be deferred lazily."
01:36:58 <Cale> blackh: unsafeInterleaveIO x is an IO action which finishes immediately when run, returning a value whose evaluation will cause x to execute.
01:37:03 <nanothief> err are we looking at the same page? I can't find a source link anywhere :P
01:37:08 <Cale> (and which evaluates to the result of executing x)
01:37:17 <Cale> er, nanothief rather
01:37:29 <Cale> So for example...
01:37:43 <Cale> v <- unsafeInterleaveIO getChar
01:38:15 <Cale> Produces a value v :: Char which is magical, in that it isn't any particular Char, but when its evaluation is forced, getChar will be executed.
01:38:24 <Cale> (and it'll evaluate to the result of getChar)
01:38:40 <blackh> nanothief: It's there on the local copy.  Try /usr/local/share/doc/ghc/libraries/index.html or similar on your local machine
01:38:42 <PeakerWork> what if I use: let v = unsafePerformIO getChar -- will the getChar not also wait until "v" is forced?
01:38:58 <Cale> PeakerWork: That just defines v to be the same action.
01:39:07 <Cale> v :: IO Char in your case
01:39:09 <Cale> er
01:39:10 <Cale> oh
01:39:16 <Cale> Yeah, that's the same.
01:39:27 <Cale> (I didn't see that you used unsafePerformIO instead)
01:39:55 <Cale> unsafeInterleaveIO at least has the advantage that you can't break the type system with it.
01:39:57 <nanothief> Cale: ahh right, that makes sense. Does it have any of the dangers that unsafePerformIO has?
01:40:08 <Cale> It has many of the other dangers though.
01:40:40 <Cale> You can use it to create strange values which end up being different things depending on how you evaluate them.
01:41:02 <Cale> (but once you look at them, they'll stay that way)
01:41:14 <PeakerWork> so   getContents could be defined as:  getContents = return $ getContents' where getContents' = unsafePerformIO getChar : getContents' ?
01:41:28 <PeakerWork> (instead of using unsafeInterleaveIO?)
01:41:31 <Cale> It could be, I suppose.
01:42:35 <flux> except wouldn't the line c < - getContents .. already block?
01:42:51 <flux> while if you used interleave, it would block once you try to retrieve an element of c?
01:43:25 <Cale> flux: Why would it do that?
01:43:53 <quicksilver> dons: finally! My pre-ordered amazon RWH is here!
01:43:58 <quicksilver> dons: (amazon UK)
01:44:05 <Cale> flux: (Does it do that?)
01:44:06 <flux> hm, right, I didn't think that the contents of 'return' aren't evaluated immediately
01:44:16 <flux> I think :)
01:44:35 <quicksilver> PeakerWork: no
01:44:48 <jsn> how do i catch the exception here?
01:44:49 <quicksilver> PeakerWork: that definition doesn't keep the characters in order.
01:44:51 <jsn> > head []
01:44:52 <lambdabot>   * Exception: Prelude.head: empty list
01:44:54 <mib_ml19st> ello
01:45:06 <quicksilver> PeakerWork: if you drop 5 on it without checking them, you'd still start at the beginning
01:45:11 <quicksilver> (and far worse examples)
01:45:45 <PeakerWork> quicksilver: Oh -- how do I implement unsafeInterleaveIO in terms of unsafePerformIO then?
01:45:57 <PeakerWork> I thought it was unsafeInterleaveIO = return . unsafePerformIO  but clearly it isnt :)
01:46:04 <Cale> oh!
01:46:09 <Cale> There's a different bug
01:46:24 <quicksilver> PeakerWork: that's a non-sequitur anyway.
01:46:26 <Cale> You have to be careful, you end up with an infinite list like that
01:46:39 <Cale> (of the first character typed)
01:46:42 <quicksilver> PeakerWork: the definition you gave above doesn't follow the rule you just gave, either.
01:47:12 <jsn> > Data.ByteString.Lazy.empty
01:47:13 <lambdabot>   Empty
01:47:18 <Cale> myGetContents :: IO String
01:47:19 <Cale> myGetContents = return getContents'
01:47:19 <Cale>   where getContents' = map unsafePerformIO (repeat getChar)
01:47:23 <Cale> That works better.
01:47:34 <jsn> > try $ evaluate $ Data.ByteString.Lazy.empty
01:47:35 <lambdabot>   Not in scope: `try'Not in scope: `evaluate'
01:47:38 <Cale> unsafePerformIO is tricky to use correctly ;)
01:48:21 <Cale> and that might not handle the end of file sanely
01:48:33 <mgdtgd> hello
01:48:38 <Cale> mgdtgd: hello
01:48:40 <quicksilver> Cale: that doesn't really solve the problem.
01:48:47 <Cale> quicksilver: Which?
01:48:50 <mgdtgd> I have a problem with interact
01:48:52 <quicksilver> Cale: if I evaluate the second char first, it will be the first char.
01:49:02 <drdozer> morning all
01:49:04 <Cale> quicksilver: Oh, yes, that would be a problem ;)
01:49:24 <Cale> quicksilver: But at least it's not equivalent to  repeat (the first character)
01:49:28 <mgdtgd> this is what I do: http://hpaste.org/13135
01:49:28 <PeakerWork> Cale, quicksilver: Is it possible to implement unsafeInterleaveIO on top of unsafePerformIO ?
01:49:37 <mgdtgd> in ghc 6.10 on os x
01:49:45 <Cale> mgdtgd: looking
01:50:04 <Cale> mgdtgd: odd
01:50:07 <drdozer> I've downloaded the latest ghc and installed it on my kubuntu box
01:50:14 <mgdtgd> indeed
01:50:19 <drdozer> all the apt-packaged libs are for the prev release
01:50:24 <mgdtgd> I'd expect it to reverse every line
01:50:29 <mgdtgd> right after I finished typing it
01:50:32 <drdozer> is there an easy way for me to install lots of libraries?
01:50:47 <mgdtgd> not wait for me to press ^D
01:51:05 <Cale> mgdtgd: oh
01:51:14 <quicksilver> I'm going to suspect editline, for mgdtgd's problem.
01:51:15 <Cale> mgdtgd: well, that's not what it does
01:51:18 <mgdtgd> and what's the business with "bad file descriptor"
01:51:32 <Cale> mgdtgd: The bad file descriptor issue was what I thought you were talking about
01:51:47 <Cale> Your program otherwise is operating correctly (though it might not be the program you want)
01:51:54 <mgdtgd> that may be
01:52:03 <Cale> interact (unlines . reverse . lines)
01:52:11 <Cale> er
01:52:13 <Cale> interact (unlines . map reverse . lines)
01:52:17 <Cale> rather
01:52:25 <mgdtgd> ah right
01:52:27 <mgdtgd> of course
01:53:39 <jsn> mgdtgd: i have a mac, too
01:53:39 <Cale> Does interact work again after that error?
01:53:41 <mgdtgd> that works
01:53:49 <Cale> Or have things gone into a bad state?
01:53:49 <jsn> but when i use ^D, it kills GHCi
01:53:52 <mgdtgd> ghci quits
01:53:57 <Cale> ah
01:54:02 <mgdtgd> sometimes
01:54:20 <Cale> what about ctrl-C ?
01:54:31 <Cale> (to interrupt the current computation)
01:54:42 <Cale> oh, I guess then it wouldn't print
01:55:12 <mgdtgd> http://hpaste.org/13135#a1
01:55:33 <Cale> right, that bit is the same for me
01:55:49 <drdozer> is there some command that will let me type in e.g. opengl, and will fetch the source from darcs, get all dependencies, build everything and install it on my machine?
01:55:50 <mgdtgd> that's strange
01:56:00 <mgdtgd> drdozer: cabal-install
01:56:04 <Cale> How about if you put  main = interact reverse  into a file and compile it.
01:56:08 <Cale> ?
01:56:29 <Cale> When you run the program and hit ctrl-D to finish, do you get the same error, or is that just a GHCi thing?
01:56:40 <drdozer> mgdtgd: oh - is that not bundled with ghc?
01:56:43 <mgdtgd> seems to be a ghci thing
01:56:49 <jsn> drdozer: it doesn't get the source from darcs, but it grabs the latest release from hackage
01:56:51 <Cale> drdozer: No, it's not bundled yet.
01:57:13 <Cale> drdozer: But the tarball on hackage comes with a bootstrap.sh which will get it set up correctly.
01:57:36 <drdozer> thx Cale - got a URL for that tarball?
01:57:45 <Cale> sure...
01:58:07 <mgdtgd> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
01:58:13 <Deewiant> ?hackage cabal-install
01:58:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
01:58:16 <Cale> (my connection is being slow)
01:58:25 <Cale> ah, good :)
01:58:35 <jsn> i am working through the examples in RWH for exceptions
01:58:55 <jsn> but the use of "evaluate" does not seem to be right any longer
01:59:05 <Cale> jsn: Some of the exception stuff changed in 6.10 too.
01:59:09 <jsn> right
01:59:12 <Cale> (I'm not sure if the book reflects that)
01:59:21 <Cale> Oh, what's the example for evaluate?
01:59:25 <jsn> Cale: it warns us that it does not
02:00:10 <Cale> evaluate shouldn't have changed.
02:01:24 * BeelsebobWork giggles http://haskell.org/haskellwiki/Image:HaskellLogoTDavie2.png
02:01:28 <mgdtgd> @source interact
02:01:28 <lambdabot> interact not available
02:01:42 <Deewiant> @src interact
02:01:42 <lambdabot> interact f = do s <- getContents; putStr (f s)
02:01:50 <drdozer> thx - bootstrap.sh seems to be doing it's stuff
02:02:25 <jsn> Cale: their example is      res <- try $ evaluate undefined
02:02:27 <jsn> basically
02:02:30 <Cale> grr, the new exception library seems to be totally antagonistic to the idea that you'll want to use catch as an infix operator with a lambda
02:02:53 <Heffalump> did the fixity of catch change or something?
02:02:56 <Cale> jsn: Type error?
02:03:02 <Cale> Heffalump: The type changed.
02:03:03 <jsn> Cale: yes
02:03:06 <jsn> type error
02:03:19 <Cale> catch :: Exception e => IO a -> (e -> IO a) -> IO a
02:03:20 <Deewiant> Cale: nah, you just need ScopedTypeVariables or asTypeOf
02:03:28 <Deewiant> not /totally/ antagonistic ;-)
02:03:34 <Heffalump> what's wrong with that type?
02:03:50 <Cale> Heffalump: e is typically ambiguous.
02:03:57 <jsn> right
02:04:01 <mgdtgd> is there a lambdabot reference somewhere, with all the commands?
02:04:05 <Deewiant> @list
02:04:05 <Heffalump> not if you're handling the exception, surely
02:04:06 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:04:07 <jsn> that's why i can't get my example to work
02:04:32 <jsn> how do i find out what the exception is?
02:04:41 <quicksilver> PeakerWork: you are right that unsafeInterleave is return $ unsafePerform
02:04:42 <Cale> Heffalump: Well, if you don't care which exception it is, then it's ambiguous.
02:04:43 <mgdtgd> @version
02:04:43 <lambdabot> lambdabot 4.2.2
02:04:43 <lambdabot> darcs get http://code.haskell.org/lambdabot
02:04:55 <Heffalump> you're not supposed to use catch if you don't care which exception it is, AIUI
02:04:58 <mgdtgd> @vixen
02:04:58 <lambdabot> Hahaha
02:04:58 <quicksilver> Cale: you have to care which exception it is. THat's the point.
02:04:59 <Deewiant> Cale: and the whole point of the new library is that you're supposed to care
02:05:05 <Heffalump> can you give an example of where you might not care?
02:05:17 <quicksilver> if you don't care, use finally.
02:05:18 <jsn> > Data.ByteString.Lazy.head Data.ByteString.Lazy.empty
02:05:20 <lambdabot>   * Exception: Data.ByteString.Lazy.head: empty ByteString
02:05:26 <jsn> which exception is that?
02:05:35 <quicksilver> jsn: not one you can catch.
02:05:37 <Cale> Prelude Control.Exception> try (evaluate undefined) :: IO (Either ErrorCall a)
02:05:37 <Cale> Left Prelude.undefined
02:05:43 <jsn> quicksilver: what?
02:05:44 <Cale> jsn: there you go
02:05:44 <Heffalump> quicksilver: huh?
02:06:00 <jsn> there are uncatchable exceptions?
02:06:02 <Cale> jsn: It's ErrorCall
02:06:03 <quicksilver> jsn: you should never try to catch the exceptions thrown from pure code.
02:06:07 <Heffalump> quicksilver: huh?
02:06:08 <Megzlna> Cale, what'ts wrong with FGL interface?
02:06:20 <quicksilver> Heffalump: it breaks referential transparency.
02:06:24 <jsn> quicksilver: i am wrapping it in an IO computation that handles the exception
02:06:25 <quicksilver> Heck, it breaks operational semantics.
02:06:26 <Heffalump> quicksilver: huh? It's in IO.
02:06:36 <Cale> jsn: They're not totally uncatchable, but I think the better way to phrase it is that you should never expect someone to catch an exception thrown with error.
02:06:37 <quicksilver> jsn: don't.
02:06:44 <Heffalump> jsn: do :-)
02:06:46 <quicksilver> ErrorCall is for things that should never happen.
02:06:46 <Cale> quicksilver: No it doesn't...
02:06:50 <jsn> basically, i associate a file handle with a lazy ByteString
02:07:02 <jsn> then i parse the bytestring
02:07:10 <jsn> then i throw the handle and bytestring away
02:07:11 <Cale> quicksilver: It doesn't break operational semantics, because the appropriate semantics is tied up with IO.
02:07:15 <quicksilver> ErrorCall denotes programming errors, not things that should happen in a normal run of a program.
02:07:17 <Heffalump> jsn: just be aware that you can get caught out by laziness
02:07:29 <jsn> Heffalump: caught out?
02:07:30 <Heffalump> because catch won't force any unevaluated errors in its argument
02:07:38 <quicksilver> just don't do it.
02:07:43 <quicksilver> It will cause problems later on.
02:07:52 <Cale> quicksilver: I agree with you on that much, but I think you're phrasing things a little overly strongly.
02:08:02 <quicksilver> Yes, I probably am :)
02:08:09 <jsn> okay, then i should just check to see if the bytestring is empty, i guess
02:08:41 <Cale> You absolutely can attempt to catch exceptions from pure code. It's a little tricky, and it's not something you'd do as part of a reasonable design, but there are cases where it might be hard to do without.
02:09:01 <jsn> well, i am trying to "depurify" lazy bytestrings
02:09:09 <Cale> The worse thing to do is to throw exceptions from pure code with the intention of catching them.
02:09:11 <Heffalump> it's a trade-off between making your pure code pass around errors manually (including via a monad, which still has some syntactic overhead)
02:09:18 <quicksilver> I think the only time to do it is when running untrusted or dynamically generated code.
02:09:34 <quicksilver> such as the situation ghci itself is in.
02:09:51 <quicksilver> Or a hypothetical "haskell application server" which runs applets to serve network requests.
02:09:54 <quicksilver> that kind of thing.
02:10:03 <drdozer> "cabal install opengl" is failing, and telling me to look in 'config.log' but I can't see that file anywhere
02:10:05 <quicksilver> where you don't want a programming error in a sub-module to break your whole server.
02:10:06 <Heffalump> or lambdabot, whcih isn't hypothetical
02:10:06 <Megzlna> ..
02:10:13 <Cale> If something is throwing an exception, and you didn't write it, and aren't about to go trudging through someone else's code redesigning things, and you need to catch that exception, well, evaluate/catch is your best bet.
02:10:15 <quicksilver> Heffalump: yeah, lambdabot is a good example.
02:10:29 <quicksilver> Cale: that's another good example.
02:10:33 <jsn> well, or what about when people write libraries that present pure interfaces but are full of dangerous side effects?
02:10:38 <Cale> But if you're writing a program and you know that you'll need to catch an exception, don't use error to throw it.
02:10:46 <quicksilver> Cale: although IMO that is essentially working around a bug in someone else's code.
02:10:49 <Cale> (use Either or Maybe or something nicer)
02:10:55 <Cale> right.
02:10:56 <quicksilver> Cale: ... which is something we have to do from time to time.
02:11:04 <Megzlna> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/old/fgl0103.pdf
02:11:05 <Cale> It's still worth knowing how to do, yes :)
02:11:15 <drdozer> typically, you will not want to know the concrete type of the exception
02:11:30 <Cale> quicksilver: Or I suppose it could just be that the author of that code didn't foresee your use case.
02:11:31 <drdozer> even if you catch it, you often do a little work, and then re-throw
02:11:44 <quicksilver> PeakerWork: you are right that unsafeInterleave is return $ unsafePerform; you were simply wrong in your definition of getContents.
02:11:58 <quicksilver> drdozer: that's what finally is for
02:12:04 <jsn> drdozer: you should look in .cabal
02:12:06 <quicksilver> drdozer: (to answer your second phrase)
02:12:12 <Cale> The exception system would be nicer if Haskell had proper extensible variants.
02:12:16 <quicksilver> drdozer: and to answer your first phrase, I entirely and completely disagree.
02:12:16 <pejo> drdozer, the package is in .cabal/packages/<tab tab tab>, so you can do the configure step manually if you can't find the file.
02:12:22 <jsn> drdozer: excuse me
02:12:25 <drdozer> quicksilver: sure, but often you want to 'decorate' it with extra info
02:12:29 <jsn> drdozer: ~/.cabal
02:12:36 <quicksilver> s/often/never/.
02:12:39 <Heffalump> what's the difference between finally and onException? (if any)
02:12:51 <quicksilver> finally runs even if it's successful ?
02:13:01 <jsn> that is the usual meaning
02:13:03 <Heffalump> oh, duh
02:14:04 <drdozer> I'm looking under .cabal, but 'config.log' is definitely not under there
02:15:25 <PeakerWork> quicksilver: ah - okay
02:15:49 <jsn> well, ByteString helpfully provides uncons
02:16:00 <jsn> so i guess i don't really need to delve into exceptions
02:16:21 <PeakerWork> @src getContents
02:16:21 <lambdabot> getContents = hGetContents stdin
02:16:24 <PeakerWork> @src hGetContents
02:16:25 <lambdabot> Source not found. You speak an infinite deal of nothing
02:16:34 <jsn> drdozer: well, you could try downloading the package and building it yourself
02:16:44 <quicksilver> PeakerWork: basically getContents does need to get the first char before the second.
02:16:49 <quicksilver> PeakerWork: even if you're going to unsafe it :)
02:16:50 <jsn> drdozer: this is clearly a case of autoconf getting stuck
02:16:59 <quicksilver> PeakerWork: so the cons needs to be in the IO, sequenced after the first getChar
02:17:10 <quicksilver> PeakerWork: (and that whole lot unsafed, if you want)
02:17:18 <drdozer> jsn: I think it's failing  due to opengl headers not being installed
02:17:35 <quicksilver> jsn: Right. Good APIs in haskell don't tend to need exceptions.
02:17:57 <PeakerWork> quicksilver: so something like:  getContents = let x = getChar in x `seq` (x:getContents) (with the return on the whole thing) ?
02:18:11 <PeakerWork> oops
02:18:21 <quicksilver> drdozer: you need mesagl-dev and freeglut-dev or whatever your distribution calls them.
02:18:27 <PeakerWork> something like:  getContents = let x = unsaferPerformIO getChar in x `seq` (x:getContents)
02:18:54 <jsn> drdozer: you might just need to change a directive in the cabal file
02:18:59 <drdozer> quicksilver: yup - I grabbed those and now it's going - just a bit annoying being told to read a file that didn't exist
02:19:02 <jsn> drdozer: to be sure it finds the mac versions
02:19:16 <jsn> drdozer: oh, wait
02:19:23 <jsn> it was mgdtgd that has the mac
02:19:43 <drdozer> I got the qt4 gl package and deps, just to be sure :)
02:20:03 <mgdtgd> drdozer: mac troubles?
02:20:44 <drdozer> mgdtgd: kubuntu 8.10
02:20:52 <blathijs> How do I put a newline in a string? I tried "\n" (which should work according to docs I think?), but that just shows \n when printed
02:21:12 <mgdtgd> blathijs: putStr "a\nb"
02:21:27 <mgdtgd> compare: show "a\nb"
02:21:33 <PeakerWork> blathijs: if you use the function "print" or "show" on it, it will escape the newline back into \n
02:21:51 <blathijs> ah, it
02:21:57 <drdozer> blathijs: show prints stuff out as if it was source code
02:22:02 <blathijs> s/, it//
02:22:14 <PeakerWork> As a Pythoneer I got confused quite a bit by "print" using "show" (Python's __repr__) and not being putStrLn (like Python's print), heh
02:22:20 <blathijs> drdozer: Right, that makes sense. putStr it is :-)
02:23:17 <blathijs> Hmm, but I can't do putStr on a list...
02:23:58 <drdozer> kk - my gl app runs now - but it's displaying random memory to screen, not the gl shapes
02:24:01 <drdozer> drivers perhaps
02:24:58 <jeffz`> drdozer: there's a bunch of example programs in the glut distribution which you can test
02:26:59 <drdozer> jeffz`: will that be hidden away under .cabal somewhere?
02:27:48 <jeffz`> drdozer: possibly, you can also just download it manually from hackage http://hackage.haskell.org/packages/archive/pkg-list.html
02:28:33 <PeakerWork> quicksilver: heh, getContents is memoizing the first thing it ever got, and never getting anything new afterwards :)
02:28:42 <PeakerWork> quicksilver: I'm trying to figure out how to write getContents correctly..
02:30:58 <jeffz`> drdozer: hmm, my memory fails me, seems they're not part of the cabal package but just in the darcs repo for GLUT
02:31:20 <jeffz`> drdozer: http://darcs.haskell.org/packages/GLUT/ - took me a minute to work that out, but there they are.
02:32:13 <PeakerWork> I can get  getContents :: () -> IO [Char]     to work, but not getContents :: IO [Char] -- it memoizes the same result -- probably needs a pragma to avoid memoization
02:33:46 <luqui> PeakerWork, I am confused by this
02:34:00 <PeakerWork> luqui: by the memoization?
02:34:02 <luqui> are you unsafePerformIOing or something?
02:34:07 <luqui> yeah, IO shouldn't memoize
02:34:24 <PeakerWork> luqui: I'm trying to define getContents to do lazy IO on my own (to learn how it works)
02:34:39 <luqui> ah ok.
02:34:42 <PeakerWork> luqui: I can get it to work correctly/lazily the first time, but it memoizes the result because its a floating global name
02:35:01 <luqui> you're using unsafeInterleaveIO?
02:35:17 <PeakerWork> luqui: I'm trying to use just unsafePerformIO, quicksilver said that unsafeInterleaveIO = return . unsafePerformIO
02:35:31 <quicksilver> PeakerWork: with any luck the lesson you will learn is "never, ever, under any circumstances, use getContents"
02:35:31 <luqui> that's true.
02:35:45 <PeakerWork> quicksilver: heh, its just non-pure programming again
02:35:48 <quicksilver> it is slippery like an eel and evil like a badger.
02:35:50 <PeakerWork> quicksilver: what's the alternative though?
02:35:56 <quicksilver> Not using it.
02:36:09 <luqui> (strict) ByteString.getContents, line mode, iteratees
02:36:27 <drdozer> kk, I've tried several gl apps, and they all render garbage to my screen
02:37:14 <quicksilver> drdozer: probably broken opengl drivers rather than anything haskell-side, at a guess?
02:37:23 <luqui> are there iteratees on hackage yet?
02:37:26 <quicksilver> drdozer: something broken haskell-side should result in nothing at all rather than garbage.
02:37:35 <drdozer> quicksilver: possible - I will try a non-haskell gl app
02:39:11 <quicksilver> PeakerWork: recommended reading : http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
02:39:41 <PeakerWork> luqui: line mode?
02:39:52 <luqui> PeakerWork, just eg. hGetLine
02:39:57 <PeakerWork> ah
02:40:01 <PeakerWork> is hGetLine strict?
02:40:04 <luqui> yeah
02:40:36 <Megzlna> so... I just want this:
02:40:37 <Megzlna> http://darcs.haskell.org/packages/fgl/
02:40:44 <Megzlna> I have to use Cabal?
02:41:12 <quicksilver> Megzlna: probably you already have it
02:41:15 <quicksilver> it comes with 6.6 and 6.8
02:41:23 <quicksilver> and I presume 6.10
02:41:28 <dcoutts> (and 6.4)
02:41:29 <quicksilver> (if you get the extralibs)
02:41:48 <quicksilver> PeakerWork: FWIW, I also object to the use of the words 'strict' and 'lazy' in this context.
02:41:48 <dcoutts> quicksilver: Cabal is a core lib, ghc needs it to build
02:41:57 <Megzlna> I have FGL or Cabal?
02:41:58 <quicksilver> dcoutts: I was talking about fgl :)
02:42:02 <dcoutts> oooh
02:42:24 <quicksilver> PeakerWork: 'strict' and 'lazy' should be used to talk about evaluation (of thunks) not execution (of IO actions)
02:42:32 <quicksilver> although the analogy is obvious, and strong.
02:42:35 <PeakerWork> quicksilver: so just pure vs unsafe?
02:42:43 <Megzlna> I don't think I have it.
02:42:45 <quicksilver> I like 'pure' vs 'interleaved IO'
02:42:54 <quicksilver> Megzlna: which ghc version/how did you install it?
02:43:01 <Megzlna> C:\ghc\ghc-6.10.1
02:43:16 <PeakerWork> Megzlna: there's the Cabal library, and the cabal-install tool - those are distinct. The former comes with ghc, the latter is a tool you have bootstrap/install separately
02:43:18 <quicksilver> I thought the windows ghc-6.10 installer came with extralibs
02:43:22 <quicksilver> which still contains fgl
02:43:28 <quicksilver> but I could be wrong on either of those thoughts
02:43:32 <Megzlna> are extralibs nested somewhere
02:43:34 <quicksilver> since I've never used windows, and haven't installed 6.10
02:43:36 <Megzlna> ah
02:43:41 <quicksilver> try ghc-pkg list
02:43:44 <PeakerWork> quicksilver: never ever used Windows? lucky man!
02:43:46 <quicksilver> it will tell you what you have.
02:43:46 <Megzlna> I think I just need to DL extralibs
02:45:17 <the_unmaker> haskell threads outperform liux threads? http://www.seas.upenn.edu/~lipeng/homepage/unify.html
02:45:23 <the_unmaker> linux threads?
02:45:25 <the_unmaker> I mean wow
02:45:41 <quicksilver> not very surprising.
02:45:49 <quicksilver> "soft" threads are much cheaper than "real" threads.
02:45:54 <fasta> the_unmaker: they do different things.
02:46:13 <the_unmaker> sounds cool; can you do cluster databases with that?
02:46:32 <the_unmaker> I heard hadoop is moving toward some kinda of database function
02:46:43 <the_unmaker> anything haaskelly going that direction?
02:47:01 <the_unmaker> can haskell be my first programming language?
02:47:08 <Tomas> ofc it can
02:47:28 <fasta> the_unmaker: there is a hidden Codex in the Universe that says that Haskell cannot be your first language.
02:47:30 <Megzlna> @src (.:)
02:47:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:47:39 <Megzlna> nope
02:47:43 <the_unmaker> how nice is haskell for text parsing?
02:47:53 <Tomas> most excellent
02:48:05 <the_unmaker> so it can do perl ish stuff
02:48:13 <the_unmaker> so screw perl ill just learn haskell
02:48:50 <jeffz`> hi the_unmaker
02:48:56 <the_unmaker> yo
02:49:00 <blackh> the_unmaker: I think Haskell can be your first programming language. I have spent 20 years using other languages. You'll be saving yourself the bother of learning and then unlearning bad ways of doing things.
02:49:14 <the_unmaker> YESS!!
02:49:15 <jeffz`> blackh: the_unmaker is a regular :)
02:49:37 <the_unmaker> I have been so busy at work, have not had time to learn much haskell
02:49:44 <Megzlna> (.:) = (.) . (.)   -- the use of this?
02:49:48 <the_unmaker> jeffz`: did I come in drunk and insult you?
02:49:49 <blackh> jeffz`: A fraud! A vagabond!
02:49:52 <Megzlna> ^--- perl
02:50:05 <jeffz`> the_unmaker: no, lets just say you are an old friend
02:50:05 <drdozer> ok - glxgears definitely renders correctly
02:50:31 <the_unmaker> I sense something....
02:50:36 <the_unmaker> something sinister
02:50:39 <Tomas> a distrubance in the force?
02:50:40 <the_unmaker> I must be cautious
02:52:24 <the_unmaker> some thing I have not felt since I was last in the presence of my old master
02:52:34 <PeakerWork> Megzlna: Perl's problems are more semantic than syntactic, but Haskell expressions that consist only of operators are reminiscient of Perl's syntax, even though they are not quite the same (no sigils, just names that happen to be operators)
02:53:07 <the_unmaker> anyone working on any interesting apps?
02:53:27 <blackh> the_unmaker: I am writing an SMTP client. It's interesting to me.
02:54:28 <the_unmaker> blackh: kick butt!!!  will you use it in any kind of monitoring ssytem analogous to nagios?
02:54:46 <the_unmaker> I was reading about a system called hobbit, written by 1 kid
02:55:04 <jeffz`> that system sucks
02:55:16 <the_unmaker> hobbit or nagious?
02:55:17 <PeakerWork> SMTP is horrible ...
02:55:20 <jeffz`> the_unmaker: hobbit
02:55:33 <blackh> the_unmaker: I couldn't find one on Hackage so I wrote on and put it on hackage. I am using it in a web app.
02:55:33 <the_unmaker> really? you tried it? how did it FAIL?
02:55:52 <blackh> PeakerWork: Useful if you want to send email, though.
02:55:55 <jeffz`> the_unmaker: the code sucks, it doesn't test stuff correctly, it's haphazard
02:56:05 <the_unmaker> yikes
02:56:33 <jeffz`> the_unmaker: we should write a replacement in Haskell
02:57:26 <the_unmaker> jeffz`: your aura is shimering black with flcks of hot orange steel
02:57:53 <the_unmaker> jeffz`: are you making fun of me?
02:58:08 <blackh> jeffz`: You could make it send emails!
02:58:08 <jeffz`> the_unmaker: nope
03:00:20 <the_unmaker> well
03:03:55 <the_unmaker> I don't know, i can't have fun if I am not allowed to ask things...
03:04:33 <rastar> hmm strange..
03:04:39 <rastar> trying to install ghc
03:04:41 <rastar> get this ./configure: line 1932:
03:04:43 <rastar> eh
03:04:47 <rastar> ./configure: line 1932: utils/pwd/pwd: cannot execute binary file
03:04:56 <rastar> hmm strange..
03:06:13 <drdozer> how would I 'catch' a divide by zero?
03:06:32 <drdozer> I think it's coming from an integer div call
03:09:37 <luqui> drdozer, catch from Control.Exception?
03:09:57 <luqui> I don't really use exceptions, so that's where my helpfulness stops...
03:10:36 <drdozer> :) thanks luqui
03:53:21 <BeelsebobWork> lilac: I think I just fixed the Ord (Improving a) lazyness bug
04:00:48 <BONUS> http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas <- the first two logo ideas here are awesome
04:03:12 <czShadoW> I agree.
04:03:21 <quicksilver> it's attractive.
04:03:27 <quicksilver> I don't think the lambda is obvious though
04:04:51 <czShadoW> Problem is that lambda is a gay symbol too.
04:04:52 <czShadoW> http://en.wikipedia.org/wiki/LGBT_symbols#Lambda
04:04:55 <luite_> hm, I like it. and at least it doesn't have a tag line :)
04:05:43 <quicksilver> I'm not sure that's really a problem, czShadoW
04:06:45 <quicksilver> I think I like Gburri's
04:07:31 <czShadoW> It might be a problem, if you want Haskell t-shirt or something.
04:07:32 <czShadoW> :-)
04:09:00 <quicksilver> Hmm I like the ">> Haskell" "pure.simple.fun" one
04:09:03 <quicksilver> by FalconNL
04:10:27 <PeakerWork> I like the >\= one
04:10:39 <quicksilver> I reject any use of the word "class".
04:11:06 <quicksilver> Ooh, cale's mountain is nice.
04:11:13 <quicksilver> I don't like the typeface he used for the word 'Haskell'
04:11:18 <quicksilver> but I like the mountain lambda.
04:12:19 <quicksilver> PeakerWork: the >\= one looks like the log of a train company.
04:12:41 <quicksilver> although I would probably like it a lot more with the corners softened.
04:12:44 <pejo> quicksilver, what's wrong with class?
04:12:58 <quicksilver> pejo: typeclasses are the most overused, and most misused feature of Haskell.
04:13:12 <quicksilver> I would not wish a slogan to focus on them.
04:13:44 <mbz_> how is it possible to "misuse" a typeclass?
04:15:13 <quicksilver> mbz_: you don't misuse *a* typeclass
04:15:20 <quicksilver> mbz_: you misuse the language feature of typeclasses
04:15:30 <quicksilver> by using them to solve a problem which is solved more simply without them.
04:16:39 <rastar> hey just installed ghc the bin version, trying to build the source version now. i get the following error
04:16:43 <rastar> checking for path to top of build tree... /usr/lib/ghc-6.10.1/ghc: error while loading shared libraries: libedit.so.0: cannot open shared object file: No such file or directory
04:17:06 <mokus> quicksilver: what is the "approved" usage of typeclasses?
04:17:08 <PeakerWork> quicksilver: I think passing function tuples is awkward, but I haven't actually tried doing that much
04:17:17 <pejo> rastar, where's your libedit.so.0 located?
04:19:49 <quicksilver> mokus: they're for overloading.
04:20:21 <quicksilver> mokus: (+) and (>>) [and so, by extension, Monad do notation] are great examples of what typeclasses do well.
04:20:30 <BONUS> hmm, are infinite ziplists monads?
04:20:46 <quicksilver> PeakerWork: you can quite mechanically replace a class "Foo a" with a data "Foo a"
04:20:58 <quicksilver> PeakerWork: (and add one extra parameter to your functions, obviously)
04:20:59 <opqdonut> BONUS: aren't they just streams?-)
04:21:07 <quicksilver> BONUS: my understanding is they are, yes
04:21:13 <quicksilver> BONUS: with 'join' being the diagonal.
04:21:29 <opqdonut> ah, join is non-trivial, yes
04:21:34 <BONUS> that's pretty interesting
04:21:40 <BONUS> is there a paper or something about that
04:22:10 <opqdonut> BONUS: btw, why _zip_lists?
04:22:27 <opqdonut> they're isomorphic to (haskell) lists
04:22:30 <quicksilver> BONUS: I don't think so, no.
04:22:37 <quicksilver> opqdonut: it's a different applicative + monad instance
04:22:45 <quicksilver> opqdonut: that's the point of the terminology
04:22:49 <quicksilver> :t ZipList
04:22:50 <lambdabot> forall a. [a] -> ZipList a
04:23:05 <quicksilver> same Functor instance, different Applicative.
04:23:16 <quicksilver> it is popularly held that ZipLists aren't a monad
04:23:18 <opqdonut> quicksilver: ah, okay
04:23:24 <quicksilver> but actually they are, just only the strictly-infinite ones.
04:23:33 <opqdonut> yeah
04:23:40 <quicksilver> dually, the ordinary monad instance for lists only actually applies to strictly-finite ones
04:23:53 <quicksilver> (that is, it only satisfies the laws on strictly finite lists)
04:24:02 <BONUS> yeah
04:24:09 <opqdonut> (fyi: i was thinking ziplists as in the common method of encoding lists into lambda calculus)
04:24:46 <quicksilver> it remains therefore to give an interesting example of an Applicative which isn't a Monad.
04:24:52 <opqdonut> quicksilver: the breadth-first list monad works even for infinite ones?
04:25:02 <opqdonut> s/ones/lists/
04:25:17 <quicksilver> opqdonut: well if you ignore ordering so really it's sets, then yes.
04:25:19 <quicksilver> (multisets)
04:25:33 <quicksilver> I think so anyway.
04:25:49 <opqdonut> yeah
04:33:02 <PeakerWork> quicksilver: Finite zip lists of same length are applicatives but not monads?
04:34:09 <opqdonut> join=diagonal
04:34:11 <opqdonut> works
04:35:48 <quicksilver> yup, for any fixed length diagonal works
04:36:01 <quicksilver> basically your length has to be fixed to your "pure"
04:36:15 <quicksilver> if pure = repeat, then you must be infinite, because your pure is infinite.
04:36:20 <quicksilver> if pure x = (x,x,x,x,x)
04:36:26 <quicksilver> then you're fine for size 5, etc.
04:36:36 <xpika> > 3
04:36:38 <lambdabot>   3
04:38:43 <idnar> > pure 5 :: ZipList Integer
04:38:44 <lambdabot>       Ambiguous occurrence `pure'
04:38:44 <lambdabot>      It could refer to either `Control.Appl...
04:38:50 <idnar> > Control.Applicative.pure 5 :: ZipList Integer
04:38:51 <lambdabot>       No instance for (Show (ZipList Integer))
04:38:51 <lambdabot>        arising from a use of `...
04:39:00 <opqdonut> :P
04:39:03 * idnar facepalms
04:39:15 <idnar> > getZipList $ Control.Applicative.pure 5 :: ZipList Integer
04:39:16 <lambdabot>   Couldn't match expected type `ZipList Integer'
04:39:23 <idnar> > getZipList (Control.Applicative.pure 5 :: ZipList Integer)
04:39:24 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
04:50:21 <xenoblitz> hi guys is there a place where I can get a list of changes for ghc 6.10.1?
04:51:18 <xenoblitz> nvm managed to find them
04:51:20 <xenoblitz> thanks all the same
05:12:22 <osfameron> dammit, imperative programming is HARD
05:13:06 <tomh> its easy
05:13:12 <tomh> functional programming is hard :>
05:13:19 <opqdonut> no
05:13:20 <osfameron> well, loops with global index variables in COBOL anyway.  If it had bloody map/grep/lambda it would be so much easier
05:13:21 <mbz_> osfameron, I don't believe you. can you prove your point?
05:13:23 <opqdonut> functional design is hard
05:13:28 <opqdonut> imperative implementation is hard
05:13:33 <opqdonut> it's a tradeoff
05:13:42 <blackh> functional programming is hard, imperative debugging is hard
05:14:27 <blackh> osfameron: COBOL??!
05:14:34 <osfameron> blackh: yep!
05:14:44 <osfameron> it doesn't even have local variables!
05:15:06 <mbz_> errr, really?
05:15:15 <osfameron> and it doesn't have lambdas or even eval... I'm not entirely sure how it's possible to program anything in it
05:15:25 <osfameron> well, later specs of cobol do have them
05:15:29 <osfameron> this doesn't
05:15:33 <osfameron> I have a cunning plan!
05:15:56 <idnar> is Andrew Coppin a troll?
05:16:15 <osfameron> which is to compile cobol into a parse tree, then run a source code analysis to work out which functions use which variables as input parameters, which as return values, and which are modifying things as side-effects (boo!  hiss!)
05:16:19 <osfameron> idnar: no
05:16:35 <osfameron> I think he annoys people occasionally, but he does say some interesting stuff too
05:16:58 <idnar> that doesn't really have too much to do with being a troll or not
05:17:18 <blackh> osfameron: That is a very cunning plan indeed! I thought my life was difficult doing C++ for my day job.
05:17:23 <osfameron> anyone got any pointers on using static-analysis of global crap to infer lexical variables?
05:17:51 <idnar> I just want to know if I'm wasting my time writing a reply to one of his posts, or not :P
05:17:53 <osfameron> I need to study compiler techniques... but I'm sure it's doable, at least partially.  And would help me figure out wtf is going on
05:18:28 <osfameron> idnar: which post?
05:19:26 <idnar> I sent the reply anyway, it was something in the logo thread on haskell-cafe
05:20:43 <byorgey> osfameron: this is code someone else wrote?
05:21:31 <osfameron> byorgey: legacy cobol horror, yeah
05:21:36 <byorgey> yikes
05:21:42 <osfameron> well, I've written some of it
05:21:52 * byorgey backs away slowly while making the sign of the cross
05:22:08 <osfameron> or rather, I've cargo culted some APIs (you don't have lambda/eval/anything that would allow you to sanely abstract, so it works your copy/paste muscles very nicely)
05:22:38 <osfameron> I was thinking a COBOL -> Perl migration might make sense, but actually COBOL -> Haskell might be even more sensible
05:23:02 <osfameron> as I think you could do the nested fixed width data structures (the only clever thing I've seen in COBOL) quite nicely with Haskell types
05:23:36 <osfameron> and you could possibly create a nice haskell DSL that compiled down to cobol, much more easily than doing it in Perl (side effects etc.)
05:24:34 <osfameron> I'm sure writing a COBOL->Haskell migration path would generate lots of Profit... only problems are a) it's HARD, and b) OMG do I really want to make reasons to look at more COBOL ?
05:24:34 <byorgey> yeah, I bet you could
05:24:53 <byorgey> hehe
05:26:16 <quicksilver> osfameron: http://www.coboloncogs.org/INDEX.HTM
05:26:45 <quicksilver> idnar: he's not a deliberate troll. He sometimes acts in ways which could be mistaken for trolling.
05:26:55 <jeffz`> osfameron: which platform are you writing COBOL on?
05:27:05 <idnar> quicksilver: okay, that's fine
05:27:30 <osfameron> quicksilver: yeah, that's classic
05:27:43 <quicksilver> osfameron: I like the (c) <DATE OVERFLOW>
05:27:53 <jeffz`> idnar: I replied to one of his threads awhile ago, got the impression that he was lazy/just having a whine rather than looking for a response.
05:28:18 <osfameron> jeffz`: acucobol-gt version 4.0 (1985 standard) running on linux
05:28:25 <osfameron> hehe
05:28:45 <sbahra> wat
05:29:19 * SamB_XP <3 COBOL ON COGS
05:29:35 <jeffz`> osfameron: fairly pricey software acucobol-gt, iirc
05:29:51 <osfameron> my favourite bit is GET EXCITED: AUDIO-CASSETTES, SCREENSHOTS, AND BINDERS FULL OF PRINTOUTS
05:29:55 <osfameron> jeffz`: I guess so
05:30:12 <SamB_XP> osfameron: me too
05:30:27 <osfameron> it's travel industry stuff.  Easy to migrate from, but you just need to rewrite some business logic first...
05:31:11 <SamB_XP> somebody should make a website for snakes on a plane ... (except if they did that, people might expect an implementation!)
05:31:25 <osfameron> and cos it's all imperative twistiness, it's impossible to know what it's all doing
05:32:01 <jeffz`> what if you wrote a cobol compiler in haskell, but added new language features to make the code more functional, slowly migrating towards a functional dialect of cobol?
05:32:04 <sbahra> SamB_XP, haha
05:32:18 <sbahra> Cobol on Cogs :-P
05:32:28 <osfameron> I think it might make sense to migrate to OO Cobol
05:32:46 <osfameron> at least that has local variables (cos you need them for OO) and some ways to abstract stuff
05:33:42 <SamB_XP> "SUPPORT*FOR*SPECIAL@CHR#SUCH AS#THE#EURO#SYMBOL#AND LOWER CASE@LETTERS"
05:34:45 <pejo> osfameron, is that something like region inference?
05:35:51 <osfameron> pejo: dunno... I guess it's more like call flow analysis - checking if a change to a (global) variable is propagated after the function returns, or is overwritten (e.g. by the var being reinitialized/reset)
05:36:27 <robyonrails> did someone read "Real World Haskell?" ?
05:37:09 <SamB_XP> robyonrails: well, if not, then why in the world are there so many thank-yous in it ?
05:37:15 <ehird> :t toInteger
05:37:16 <lambdabot> forall a. (Integral a) => a -> Integer
05:37:22 <SamB_XP> ivanm got TWO
05:37:23 <ehird> @hoogle (Integral a) => a -> Int
05:37:23 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
05:37:23 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
05:37:23 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
05:37:35 <robyonrails> SamB_XP, pardon?
05:37:39 <ehird> @hoogle (Num a) -> [b] -> a -> b
05:37:40 <lambdabot> Warning: Unknown type Num
05:37:40 <lambdabot> Text.XHtml.Debug HtmlNode :: Html -> [HtmlTree] -> Html -> HtmlTree
05:37:40 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
05:37:44 <ehird> @hoogle (Num a) => [b] -> a -> b
05:37:44 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
05:37:44 <lambdabot> Prelude (!!) :: [a] -> Int -> a
05:37:44 <lambdabot> Data.List (!!) :: [a] -> Int -> a
05:37:47 <ehird> aha
05:37:48 <ehird> genericindex
05:37:59 <ivanm> SamB_XP: what did I get two of?
05:38:03 <ivanm> I only got one RWH...
05:38:08 <SamB_XP> thank-yous
05:38:18 <ivanm> ahhh, yes
05:38:25 <BeelsebobWork> ohhhhhhhh! quicksilver -- we may have come up with a way of making sampleB possible
05:38:31 <BeelsebobWork> (without leaking)
05:38:35 <ivanm> SamB_XP: well, you have two nicks here, I have two thank-yous in RWH
05:38:37 * ivanm wins :p
05:39:51 <sbahra> I wish FringeDC meetings weren't so far apart.
05:39:53 <quicksilver> BeelsebobWork: nice.
05:40:08 <BeelsebobWork> quicksilver: the sig for sampleB is sampleB :: Ord t => t -> BehaviorI t a -> a, right?
05:40:09 <quicksilver> robyonrails: no. But I have placed it on my desk to try to lure colleagues into picking it up.
05:40:29 <quicksilver> BeelsebobWork: yes.
05:40:33 <BeelsebobWork> nope
05:40:35 <BeelsebobWork> sampleB :: Ord t => Improving t -> BehaviorG (Improving t) (Improving t) a -> a
05:40:45 <idnar> whoops, haskell-cafe is subscribers only, I guess I must have been lurking up until now
05:41:16 <BeelsebobWork> then the outside world is able to guarentee lower bounds on the improving values you give it
05:41:21 <quicksilver> hmm
05:41:21 <BeelsebobWork> and the GC can collect once again
05:41:25 <quicksilver> what's BehaviourG?
05:41:35 <BeelsebobWork> it's the basic type for behaviors
05:42:09 <BeelsebobWork> Behavior a = BehaviorI TimeT a; BehaviorI t a = BehaviorG (Improving t) (Improving t) a
05:43:40 <quicksilver> why two parameters?
05:43:51 <quicksilver> and in that case, your two example sigs are the same, aren't they?
05:44:34 <BeelsebobWork> BehaviorG tr tf a = Beh {unBeh :: (R.ReactiveG tr :. Fun tf) a}
05:44:56 <BeelsebobWork> and no, they're not the same -- one of them has an improving argument, the other doesn't
05:45:40 <BeelsebobWork> the latter is sampleB :: Ord t => Improving t -> BehaviorI (some t' equal to Improving t) a
05:46:07 * BeelsebobWork thinks
05:46:09 <BeelsebobWork> no, taht's not right
05:46:23 <BeelsebobWork> the latter is sampleB Ord t => Improving t -> BehaviorI t a -> a
05:46:24 <quicksilver> oh, I see the point you're making.
05:46:39 <quicksilver> one has the time pre-wrapped in Improving, the other doesn't
05:46:44 <BeelsebobWork> yep
05:46:50 <quicksilver> I was being a bit slow.
05:47:07 <quicksilver> why would you ever want to use a different time in the reactive part to the FunTime part?
05:47:14 <quicksilver> (I appreciate I have drifted off your point here :)
05:47:15 <BeelsebobWork> I'm not sure
05:47:30 <BeelsebobWork> it seems rather odd to me too
05:48:54 <Cale> http://www.superpoop.com/121708/killer-circles-threaten-america.jpg
06:07:09 <jsn> is there a StreamT ?
06:08:28 <Cale> jsn: hmm
06:08:52 <jsn> StreamT State  could be a list stream processor
06:09:08 <jsn> StreamT IO    could process pointers, files and sockets
06:09:34 <Cale> What would StreamT Identity be first of all?
06:09:39 <jsn> hmm
06:09:58 <Cale> Presumably you have a particular Stream monad in mind which you're generalising?
06:10:12 <jsn> well, no, sadly
06:10:30 <jsn> i am just now reading the chapter on monad transformers
06:10:40 <quicksilver> list stream processors are just (a -> a) or ([a] -> [a])
06:10:47 <byorgey> I mean, there *is* a Stream monad
06:10:50 <jsn> i thought, maybe someone had thought of this, but google turned up nothing
06:10:55 <quicksilver> (...or a -> b or [a] -> (b,[a]) or ...)
06:11:10 <jsn> well, stream processing also has premature termination
06:11:32 <jsn> and if it is a stream of bytes that you are processing to a stream of UTF8, then you also have errors
06:11:34 <Cale> With the diagonal for bind?
06:11:45 <jsn> the diagonal?
06:11:46 <BeelsebobWork> quicksilver: another little realisation: sampleB -- delete this... applyB :: (BehaviorI t a) -> (Improving t -> a)
06:11:49 <byorgey> Cale: right, but maybe that's not what jsn is thinking of.
06:13:00 <Cale> Well, for join, really ;)
06:13:16 <jsn> loosely: a stream computation has 'read :: Stream a' that gets an item off of the "in stream" and 'return' that puts an item on to the output stream
06:13:25 <jsn> it accumulates failures and such
06:13:33 <Cale> jsn: return wouldn't do that.
06:13:38 <Cale> er...
06:13:53 <jsn> no?
06:14:01 <Cale> return v itself would have to be a stream
06:14:11 <jsn> yes, that's true
06:14:27 <jsn> but you put stream append into the >>=
06:14:34 <jsn> as is done in the list monad
06:14:46 <jsn> so you are right, it wouldn't do it the way i said it
06:14:52 <vixey> stream concatMap
06:14:52 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
06:14:57 <vixey> @messages
06:14:57 <lambdabot> byorgey asked 10h 58m 7s ago: what should be done about unintercalate "" ? Your implementation, the one in section 3 on the Data.List.Split page, and mine all blow up, although yours at least has
06:14:57 <lambdabot> the advantage of being productive. The others just go into infinite loops. I have some thoughts but would be interested to hear yours.
06:15:02 <Cale> The list monad >>= is not particularly useful on infinite streams
06:15:13 <vixey> oh nice find byorgey!
06:15:21 <vixey> I didn't suspect that at all
06:15:27 <vixey> @wiki Data.List.Split
06:15:27 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
06:15:29 <byorgey> vixey: I didn't find it, QuickCheck did =)
06:15:39 <vixey> @src unfoldr
06:15:40 <lambdabot> unfoldr f b  = case f b of
06:15:40 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
06:15:40 <lambdabot>    Nothing        -> []
06:16:14 <jsn> Cale: well, i expect streams to be finite
06:16:24 <jsn> Cale: but, could you explain that statement anyways?
06:16:37 * luqui doesn't suspect the negative diagonal to be associative on infinite streams...
06:16:40 <Cale> Well, concat is kind of stupid for infinite streams
06:16:46 <Cale> You just get the first one
06:17:03 <vixey> so what is the correct behavior..
06:17:14 <Cale> luqui: Infinite streams with diagonal is just like the (->) Nat monad.
06:17:22 <vixey> byorgey, I don't know, what do you think?
06:17:26 <luqui> Cale, right, I was talking about negative diagonal; a fair join.
06:17:32 <jsn> ah
06:17:34 <Cale> hmm
06:17:37 <jsn> what is this diagonal?
06:17:47 <ksf> If you want to write a haskell app that everybody uses, you seem to have to clone daemon tools:
06:17:48 <Cale> Er... you mean interleaving?
06:17:49 <ksf> http://www.heise.de/software/download/special/downloads_des_jahres/b50_1
06:18:03 <luqui> [xs !! 0 !! 0, xs !! 1 !! 0, xs !! 0 !! 1, xs !! 2 !! 0, xs !! 1 !! 1, xs !! 0 !! 2, ... ]
06:18:07 <centrinia> Is it a good idea to convert functional programs into SK combinators as in Turner 1979?
06:18:13 <Cale> ah, like that
06:18:22 <byorgey> vixey: well, right now I put in a special case that makes  unintercalate "" "abcde" --> ["a","b","c","d","e"]
06:18:24 <vixey> centrinia, I think that it is
06:18:27 <byorgey> i.e. it splits everywhere
06:18:38 <byorgey> vixey: this is actually what perl does =)
06:18:53 <centrinia> Isn't it susceptible to exponential blow-up?
06:19:07 <vixey> centrinia, (they use more than just S and K)
06:19:47 <byorgey> vixey: the other possibility would just be to throw an error if passed an empty list as a delimiter and document it, but I'm not too keen on that
06:19:57 <luqui> yep, not associative.
06:20:42 <vixey> I just found that
06:20:45 <vixey> > unintercalate "x" "axxyxxz"
06:20:45 <vixey> ["a","","y",""]
06:20:46 <lambdabot>   Not in scope: `unintercalate'
06:20:46 <vixey> :S
06:20:47 <luqui> vixey, wait.. is there any combinatorication that doesn't result in exponential?
06:21:33 <byorgey> vixey: what's wrong with that?
06:21:40 <vixey> the "z" is missing
06:22:08 * luqui also expects those xs not to be collapsed...
06:22:14 <byorgey> *Data.List.Split> unintercalate "x" "axxyxxz"
06:22:15 <byorgey> ["a","","y","","z"]
06:22:23 <byorgey> vixey: looks like your implementation is just wrong, I guess
06:22:25 <luqui> i.e. ["a","","","y","","","z"]
06:22:39 <vixey> match (p:ps) (q:qs) | p == q = match ps qs
06:22:41 <vixey> blug
06:22:47 <vixey> stupid mistake of me
06:23:46 <earthy> luqui: that's got too many empty strings
06:23:54 <byorgey> luqui: the x's aren't collapsed, you're getting the blank spaces in between the x's
06:23:55 <earthy> > intercalate "x" ["a","","y","","z"]
06:23:57 <lambdabot>   "axxyxxz"
06:24:13 <vixey> programming is hard :((
06:24:22 <earthy> let's go shopping? :P
06:24:32 <vixey> I really have to go shopping soon..
06:24:50 <vixey> match (p:ps) (q:qs) | p == q = fmap (p:) (match ps qs)
06:24:57 <vixey> I changed it to that and it continues not working!
06:25:08 <luqui> byorgey, righto, brainfart
06:26:19 <byorgey> vixey: that definitely isn't right.  your 'match' function is just supposed to return the tail.
06:26:40 <vixey> p == q
06:26:54 <byorgey> luqui: although if you *do* want the x's collapsed, I have a combinator to do that too =)
06:26:56 <Japsu> p = np
06:27:03 <vixey> hm still a good idea to use q instead though
06:27:12 <Choko> NP^NP = NP !
06:27:22 <vixey> chopWith delimiter (match delimiter -> Just tail) = return ([], tail)
06:27:24 <vixey> is the problem
06:27:36 <byorgey> vixey: well, don't worry about that too much, I'm not directly using your code anyway
06:27:42 <vixey> unintercalate "x" "axxyxxz" ~~> ["a","","","","","","",""...
06:28:00 <byorgey> vixey: right.
06:28:10 <vixey> yeah I'm just surprised how wrong this definition is though...
06:28:13 <vixey> and I though it was fine
06:28:31 <byorgey> vixey: nah, it's only slightly wrong =)
06:28:35 <osfameron> is this a counterexample to the "if it compiles it's probably right" haskell meme? ;-)
06:28:51 <byorgey> osfameron: heh, for sure =)
06:29:19 <byorgey> but that's because vixey didn't put enough information in the types ;)
06:30:38 <earthy> :)
06:31:30 <vixey> I have no idea how to fix it, I guess it just isn't naturally an unfoldr
06:31:39 <vixey> @src intercalate
06:31:39 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
06:31:58 <vixey> @src intersperse
06:31:59 <lambdabot> intersperse _   []     = []
06:31:59 <lambdabot> intersperse _   [x]    = [x]
06:31:59 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
06:34:18 <vixey> how rubbish
06:34:21 <vixey> {- -- NOTE: This is buggy code and should not be trusted
06:34:31 <vixey> that on the wiki registers as a single line comment
06:34:42 <earthy> hm. that sucks
06:35:08 <vixey> infact it doesn't comment it out right even if you put them on separate lines..
06:38:53 <DukeDave> Wow, so cabal install, that's kinda neat :)
06:39:10 <byorgey> DukeDave: yep =)
06:39:24 * vixey put up a "fixed" version now..
06:40:02 <vixey> except now I don't really trust it to work
06:40:36 <DukeDave> I think it's time I started giving something back :)
06:46:25 <naradapuri> Hi, is there some way how to somewhat escape from the IO monad for read-only operations that don't depend on sequencing? For example, let's say I'm looking for a file in a file system. Instead of doing everything inside the IO monad, is it possible to create a lazily-loaded tree structure and process it by a monad-free function? Something like:
06:46:25 <naradapuri> createLazyTree >>= print . findFile
06:47:44 <Saizan> looks like you want unsafeInterleaveIO
06:55:08 <decafbad> what the heck am I supposed to do with an immutable recursive data type?
06:55:17 <decafbad> err. I need examples
06:56:41 <naradapuri> unsafeInterleaveIO - how "unsafe" it is to use? is it a good thing to be used when appropriate, or something that's better avoided?
06:56:50 <quicksilver> decafbad: recursive through it!
06:57:10 <quicksilver> naradapuri: a general principle would be to avoid it.
06:57:30 <quicksilver> naradapuri: basically you have no sane way of handling IO errors which occur asynchronously
06:57:45 <quicksilver> because you have 'interleaved' them into pure code and they can bury themselves anywhere in your pure datastructures.
06:58:18 <quicksilver> if you have some reason to be confident that no IO errors will occur, that improves the situation quite a bit.
06:59:17 <naradapuri> quicksilver: I understand that, and I don't like it very much. However, I'm somewhat missing lazy read-only IO operations in Haskell (with the exception of readFile etc., which are supposedly also not very safe).
07:00:59 <quicksilver> that sentence doesn't appear to make sense.
07:01:09 <quicksilver> why are you missing them, if you know about readFile?
07:01:18 <quicksilver> they are fundamentally unsafe
07:01:24 <quicksilver> there's nothing wrong with readFile in particular
07:01:30 <quicksilver> the entire concept is fatally flawed.
07:01:45 <quicksilver> But if you're happy with the concept, readFile and getContents are implementations.
07:02:01 <naradapuri> Because I don't want just to read a file.
07:02:10 <luqui> and under sensible interpretations of the IO monad breaks referential transparency (under other interpretations, it doesn't)
07:02:46 <quicksilver> naradapuri: what else do you want to do?
07:04:02 <naradapuri> I agree that functions like readFile are flawed. But somewhat I'm not happy with having to put everything inside the IO monad - even something that is basically a stateless operation.
07:04:10 <quicksilver> naradapuri: you don't have to.
07:04:15 <quicksilver> make it a pure function
07:04:22 <quicksilver> and then call it from your IO harness.
07:05:09 <quicksilver> (it would indeed be fairly nasty if everything was forced into IO, but fortunately that's not the case)
07:07:52 <naradapuri> quicksilver: Yes, this is OK. But let's take the example I gave: I want to look for a file in a directory tree. If I create such a tree inside IO and then call the function that searches the tree, first I have to read the whole directory tree inside IO and then call the function (or am I wrong)? So there is no lazyness here.
07:08:14 <quicksilver> that's not what you said, though!
07:08:22 <quicksilver> you said you were complaining about everything having to be in IO
07:08:28 <quicksilver> this is a different issue
07:08:43 <quicksilver> now you're wondering about interleaving when the IO occurs.
07:09:02 <quicksilver> having fixed sequence points for IO is important to be able to handle errors sanely.
07:09:15 <quicksilver> If you're confident no such problem can occur than unsafeInterleave is an answer.
07:09:44 <luqui> naradapuri, what if the directory tree changes in the meantime?
07:10:10 <luqui> naradapuri, not saying that your app cares about this, just positing why lazy IO is semantically ill-defined...
07:10:57 <luqui> do { t <- lazyReadDirTree;  modifyDirTree;  search p t }  -- will search the modified tree, when the code says it should search the unmodified one
07:11:33 <vixey> isn't something like
07:11:53 <naradapuri> OK, so as I understand, the solutions are:
07:11:53 <naradapuri> 1) read the whole directory tree and process it in a monad-free function
07:11:53 <naradapuri> 2) process the directory as required, which must all be done in the IO monad
07:11:53 <naradapuri> 3) use unsafe function such as unsafePerformIO
07:12:20 <vixey> @go left fold enumerator
07:12:22 <quicksilver> well you can still use pure functions as part of (2)
07:12:23 <lambdabot> http://www.bluishcoder.co.nz/2008/10/left-fold-enumerator-for-io.html
07:12:23 <lambdabot> Title: Bluish Coder: The Left Fold Enumerator for i/o
07:12:31 <luqui> naradapuri, sounds about right.  I'd pick (2), but still separate the IO and the processing.
07:12:41 <quicksilver> you need need an IO driver to traverse the directory tree
07:12:42 <vixey> @go Incremental multi-level input processing with left-fold enumerator: predictable, high-performance, safe, and elegant
07:12:45 <lambdabot> http://okmij.org/ftp/Streams.html
07:12:46 <lambdabot> Title: Streams and Iteratees
07:13:01 <naradapuri> luqui: I understand, but in some cases one can assume that the environment doesn't change
07:13:04 <vixey> what about that approach?
07:13:13 <quicksilver> but it can use a pure (but probably stateful, e.g. s -> (a,s) or more sophisticated) traverser
07:13:25 <quicksilver> for example the inside out left fold solutions vixey just pasted.
07:13:33 <vixey> naradapuri, I don't think that's 1 2 or 3
07:13:34 <luqui> Iteratee is quite nice, and one of these days i will get around to hackaging it up...
07:14:25 <BeelsebobWork> PeakerWork, quicksilver: http://hpaste.org/13138 <-- woot, bisection root finding without leaking memory!
07:16:04 <quicksilver> nice!
07:16:09 <naradapuri> vixey: It seems that it's what I've been looking for, thanks, I'll read the paper.
07:16:10 * luqui knows he's too much a purist when he sees BeelsebobWork's code and objects to its poor semantics...
07:16:12 * quicksilver would use guards instead of that if-cascade.
07:16:29 <BeelsebobWork> luqui: hmm? The fact that it's an aproximation?
07:16:48 <luqui> BeelsebobWork, yeah, that it doesn't (can't) obey Behavior's continuity :-)
07:16:57 <BeelsebobWork> luqui: yeh, it smells
07:16:58 <BeelsebobWork> of wee
07:17:08 <BeelsebobWork> but it's (close to) the best that can be done
07:17:24 <BeelsebobWork> I need to get it to observe the discontinuity in the Reactive inside the Behavior
07:17:29 <luqui> sure.  when I'm in practical mode, Euler integration is good enough for me =P
07:17:36 <BeelsebobWork> hehe
07:17:54 <vixey> I just cannot read it :p
07:18:11 <vixey> some repo you are coding against?
07:18:51 <BeelsebobWork> vixey: repo?
07:19:03 <luqui> vixey, code.haskell.org/reactive
07:19:25 <luqui> or i guess it is on hackage now :-)
07:19:57 * luqui just asked Martin Escardo for topological advice on FRP
07:20:35 <vixey> like a darcs repository
07:26:11 <wchogg> luqui : what topology are you applying to FRP?
07:27:03 <mapreduce> JavaFX's binding stuff is supposed to be an implementation of FRP, but I never read that in the FRP documentation around.
07:27:24 <luqui> wchogg, well, various.   A generalization Future is a continuous function from increasing reals, for example.
07:27:27 <mapreduce> I read it in JavaFX's language spec.  I wonder how good an implementation it is.
07:28:17 <luqui> wchogg, but I'm looking for some metric-free notion of "differentiability-like-thing"... that's the main challenge.
07:30:23 <luqui> ooh pretty: http://www.math.tulane.edu/~martin/prgr.pdf
07:30:39 <vixey> luqui, you saw D for Data (the category theory version)?
07:31:03 <vixey> may not be relevant but there is more detail on how derivatives come up
07:32:07 <wchogg> vixey : who's paper is it?
07:32:18 <luqui> vixey, i haven't seen this per se, but I think I know what you're talking about.  Is it like Conor McBride's zipper derivatives?
07:32:25 <vixey> Neil Ghani and others
07:32:41 <vixey> it is exactly that luqui
07:33:11 <luqui> if there were a connection between that and what I'm looking for, i would be thrilled!  =P
07:33:21 <luqui> that is one of the most mysterious results I have ever seen.
07:33:35 <wchogg> luqui : why the metric free condition?
07:34:48 <blathijs> Is there any standard way to use the GHC API from within Hugs? Or, more general, can I use modules in hugs for which I don't have the source at hand, but just a .so and a .hi?
07:35:12 <luqui> wchogg, so it can be applied to arbitrary (or mostly arbitrary) types.
07:35:50 <luqui> wchogg, I want (in my open-minded searching kind of way) the derivative of the function t |-> { False, t < 0 ; _|_, t = 0 ; True, t > 0 }
07:36:00 <vixey> luqui, with a category view of data types as formal power series the differentiation drops out much more naturally
07:36:13 <arjanb> blathijs: why use hugs instead of ghci?
07:36:17 <vixey> but still I have no idea about this reactive stuff
07:36:23 <vixey> so I'm just throwing it out there incase
07:36:25 * luqui neither...
07:36:30 <luqui> =P
07:36:31 <blathijs> arjanb: Because it runs a lot faster
07:36:45 <blathijs> ajhager: oh wait
07:36:56 <vixey> "t |-> { False, t < 0 ; _|_, t = 0 ; True, t > 0 }" weird notations :p
07:36:56 <blathijs> ajhager: w00ps, wrong nick
07:37:04 <ajhager> :)
07:37:06 <blathijs> arjanb: ghci sounds like a plan, thanks :-)
07:37:07 <luqui> vixey, yeah, it was ad hoc =P
07:37:46 <wchogg> vixey : different notions of derivative though.  Conor's work is about taking the derivative with respect to the structure of the Functor, not a parameter of a function.
07:38:17 <vixey> wchogg, seems like the same thing, isn't it (?)
07:38:28 <vixey> a functor is a function * -> *
07:38:31 <vixey> a functor is a function F :: * -> *
07:39:23 <wchogg> vixey : then they're derivatives defined in two different worlds, one the category of functors & natural transformations the other in the Hom-sets of a category.
07:40:08 <vixey> I don't know what hom-sets are
07:40:24 <wchogg> the sets of functions between any two objects
07:40:47 <luqui> "right adjoing" "cartesian morphisms"  ... oy vey
07:40:48 <vixey> oh so the two different worlds are types vs values?
07:41:07 <wchogg> vixey : yeah, I think so.
07:41:14 <vixey> I see
07:42:00 <blathijs> arjanb: That seems to work, thanks!
07:47:38 <blathijs> Anyone who can shed a bit of light on the ghc-paths package? AFAICS it's just a few constants pointing to GHC's paths, but from there I would expect the package to be shipped with Debian's version of ghc, whic doesn't seem to be the case..
07:52:01 <Saizan> blathijs: it's just a bunch of constants specific to your ghc installation
07:52:42 <ben_m> Hi there :) I'm really new to Haskell and currently trying to do some coding challenges (osix.net) to practise it, but I get an error ...
07:52:45 <ben_m> http://hpaste.org/13139
07:52:56 <blathijs> Saizan: Yeah, so I would expect them to be installed with my GHC installation
07:52:59 <ben_m> Error is in the paste
07:53:00 <arjanb> blathijs: you can get most packages with cabal and hackage, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-paths
07:53:46 <smarmy> got my copy of TAPL today (sorry, no RWH yet).  woohoo!  haskell has seriously changed the way i approach programming
07:54:11 <Saizan> ben_m: you need "let answer = ..."
07:54:20 <vixey> ben_m, you should put answer at the toplevel like number
07:54:21 <ben_m> Oh, yeah :)
07:54:32 <blathijs> arjanb: I prefer to get things through apt-get whenever possible
07:54:33 <vixey> not inside the main
07:54:49 <blathijs> arjanb: And I'm trying to understand why this module isn't part of ghc itself right now :-)
07:55:38 <blathijs> arjanb: From looking at the source (which uses constants like GHC_PATHS_LIBDIR), I suspect that cabal does some preprocessing with these constants defined when installing ghc-paths through cabal?
07:56:28 <arjanb> afaik it's just the ghc's preprocessor
07:57:02 <blathijs> arjanb: That would make sense, but just putting the constant in my own program makes ghci complain...
07:57:28 <mapreduce> smarmy: I am finding the first few chapters difficult because I don't know anything worth knowing about mathematical proofs.
07:57:51 <blathijs> arjanb: And if that was so, there would be no reason why ghc-paths isn't just included with ghc (http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15149.html <-- this suggests that it isn't possibly even)
07:59:21 <wchogg> mapreduce : you might want to try going through Pierce's class notes here http://www.seas.upenn.edu/~cis500/cis500-f07/schedule.html
07:59:35 <arjanb> blathijs: did you add {-# LANGUAGE CPP #-}
07:59:43 <wchogg> they're not directly on TAPL, but they're a class on using Coq as a proof assistant & it eventually gets into TAPL material
07:59:54 <smarmy> mapreduce: yeah, but forcing yourself to work through the exercises, no matter how difficult, helps with that quite a bit
08:00:05 <mapreduce> smarmy: That's my intention.
08:00:22 <smarmy> mapreduce: the book does a good job of catching the reader up on the mathematics, but it takes some serious effort
08:00:44 <mapreduce> Where does it explain mathematical proofs?
08:00:58 <mapreduce> wchogg: Thanks, looks good.
08:01:37 <wchogg> mapreduce : if you're not used to proofs, it might be helpful to have that extra structure.  Makes it feel more like programming
08:01:41 <smarmy> mapreduce: chapters 1 and 2 are a bit of review.  chapter 3 dives deeper into proofs and tries to explain the basics of induction, but it's not complete.  outside reference material is quite handy ;)
08:02:16 <mapreduce> smarmy: Yes!
08:02:47 <wchogg> smarmy : the only caveat I want to add to what you're saying is that sometimes Pierce's exercises are a bit idiosyncratic.  I sometimes found myself staring at them for a long time before realizing he was actually asking something much simpler than it sounded.
08:02:49 <smarmy> mapreduce: but i've found i develop the required intuition quickly as i do the exercise proofs
08:03:31 <smarmy> wchogg: hmm... perhaps so
08:03:39 <vixey> smarmy: Are you the exercises in Coq or on paper?
08:03:42 <mapreduce> All I need now is some spare time.
08:04:20 <smarmy> vixey: on paper.  i've been meaning to investigate Coq for a while now, but as someone who is just now picking up TAPL, i'm... getting there
08:05:07 <Ca6aka> íàðîä âñå íà www.adsl-games.ru íà ñàéòå îáñóæäàþòüñÿ èãðû òàê æå åñòü ðàçäåëû ÇÍÀÊÎÌÑÒÂÀ,ÌÓÇÛÊÈ,ÃÐÀÔÈÊÈ âñå íà www.adsl-games.ru
08:06:23 <mapreduce> @faq Can Haskell remove Russian spammers from the Internet?
08:06:23 <lambdabot> The answer is: Yes! Haskell can do that.
08:08:18 <wchogg> @faq If Hasell were corporeal, could it punch the Internet so hard that Tim Berners-Lee cried?
08:08:18 <lambdabot> The answer is: Yes! Haskell can do that.
08:09:38 * jeffwheeler made the logo the way it was because it was stupidly easy. :P
08:09:42 <athos> hi all
08:12:04 <jberg-> in a let expression i define foo, can i use foo the next definition to define bar? like let foo = x / y; bar = foo / pi; in ... ?
08:12:34 <jeffwheeler> jberg-: yes
08:13:16 <jeffwheeler> > let a = 1; b = a in b + 1
08:13:17 <lambdabot>   2
08:13:18 <ski_> (jberg- : you could also swap the order of the definition of `foo' and `bar', should you want to do so ..)
08:13:35 <jeffwheeler> > let b = a; a = 3 in b + 1
08:13:37 <lambdabot>   4
08:14:49 <jberg-> http://hpaste.org/13140 i get error on = in the first let expression
08:15:36 <jeffwheeler> jberg-: I think you need a semicolon
08:16:09 <EvilTerran> jeffwheeler, er, the newline should be sufficient, i'd've thought...
08:16:14 <jberg-> jeffwheeler, hmm, i thought whitespace should takes are of that?
08:16:25 <jeffwheeler> Hmm, you're probably right. I was just looking at my example above.
08:16:34 <ski_> mayhaps jberg- are mixing tabs and spaces ?
08:16:47 <quicksilver> jberg-: what's the exact error?
08:17:10 <jberg-> oscillator.hs:7:19: parse error on input `='
08:17:39 <quicksilver> jberg-: that exact code loads for me
08:17:44 <jberg-> ski_, ah, that might be possible. vim doesn't line up the expressions as i want so i throw in a few spaces..
08:17:47 <quicksilver> well, I added sampleRate = 1.
08:18:11 <jberg-> quicksilver, i have sampleRate :: Int sampleRate = 44100
08:18:25 * quicksilver nods
08:18:27 <quicksilver> well it works fine.
08:18:29 <quicksilver> :)
08:18:41 <jberg-> well thats fucked up
08:19:04 * jeffwheeler thinks 18 vertical and 20 horizontal guides may be excessive in that logo file.
08:19:15 <ski_> > let sampleRate :: Int; sampleRate = 44100 in (\freq -> sampleRate / freq) 1
08:19:16 <lambdabot>       No instance for (Fractional Int)
08:19:17 <lambdabot>        arising from a use of `/' at <i...
08:19:59 <quicksilver> well that's true.
08:20:02 <ski_> jberg- : possibly you either want `sampleRate :: Double' or you want to use `fromIntegral sampleRate' in those divisions
08:20:09 <quicksilver> although jberg- evidently isn't getting that far.
08:20:11 <maltem> jberg-: try :retab in vim
08:20:30 <jberg-> heh, i copied the code from hpaste into vim and then it worked
08:20:37 <quicksilver> must have been tabs.
08:20:37 <jberg-> maltem, what does that do?
08:20:45 <jberg-> quicksilver, yes
08:21:12 <maltem> jberg-: well if you have expandtab on, then it will replace all tabs by an appropriate number of spaces
08:21:30 <jberg-> maltem, i dont expand tabs
08:21:56 <maltem> jberg-: hm then it should still do something useful, check the help text
08:23:04 <maltem> not sure if it will then solve tabs-mixed-with-spaces problems, though
08:24:00 <jberg-> hmm, is the code from hpaste just spaces?
08:24:17 <quicksilver> yes
08:24:34 <quicksilver> (if you select it in your web browser and watch the highlight, you can tell)
08:24:43 <jberg-> is there a way to get vim to indent haskell code better? emacs is much better at indenting haskell
08:25:19 <quicksilver> my understanding was there was a cunning vim mode.
08:25:32 <quicksilver> I have no idea where you get it from though.
08:25:48 <blathijs> arjanb: Yeah, I added that, but that didn't help
08:25:48 <maltem> jberg-: there's a haskell mode floating around somewhere on the web, but when I looked at it, it didn't really work for me
08:26:15 <jberg-> i think im using a haskell mode for vim now.. it just indents ugly
08:26:25 <jberg-> so i add spaces myself
08:26:48 <maltem> We are all waiting for yi becoming the master editor anyways, aren't we?
08:27:14 <orbitz> maltem: speed it up!
08:27:21 <jberg-> meh, maybe ill just start using emacs again for haskell
08:27:48 <maltem> orbitz: I've submitted three patches so far :)
08:27:52 <ozy`> the ideal editor would have the extensibility of emacs, the interface of vim, and the highlight system of textmate. I guess two out of three isn't bad
08:28:07 <orbitz> maltem: dont' stop
08:28:21 <quicksilver> ozy`: what's so good about the highlight system of textmate?
08:28:40 <quicksilver> it always struck me as just a poor (although attractive) attempt to reinvent emacs as closed source.
08:28:50 <ski_> (<http://www.vim.org/scripts/script.php?script_id=2356> is mentioned on the wiki)
08:29:03 <maltem> orbitz: I don't really plan to, now that I've got into a habit upgrading all hackage packages every week to keep yi compile
08:30:01 <ozy`> quicksilver: just the highlight system, not the rest of textmate. it's the best system I've seen for editing multiple languages in the same buffer
08:30:14 <ozy`> mainly useful for HTML, but also very handy for some other things
08:30:14 <jeffwheeler> ozy`: progress is being made. :)
08:30:27 <jeffwheeler> ozy`: I'm a huge fan of TextMate, too.
08:30:47 <ozy`> jeffwheeler: I used to be a fan, until I tried to fix up the lisp and haskell bundless
08:30:54 <ozy`> s/ss/s/
08:31:20 <quicksilver> ozy`: ah yeah, mixed mode has been an emacs weak point for ages.
08:31:31 <quicksilver> although apparently it's got better recently? but I haven't tried.
08:31:58 <vixey> I can't understand using a closed source text editoro
08:32:20 <vixey> I mean you can hack it quite a lot on mac regardless because of objective c
08:32:28 <mapreduce> Some people don't like flexibility.  They like stuff to be right.
08:32:28 <vixey> but it's still annoying as hell
08:32:28 <jeffwheeler> If anybody's been wondering whether I'm anal: http://media.nokrev.com/junk/screenshots/guides.png
08:32:29 <jeffwheeler> :P
08:32:39 <quicksilver> vixey: I can't understand a willing community of people who work - for free - on writing bundles for a text editor that is closed source and someone else is making money out of ;)
08:32:42 <mapreduce> I'm one of the people who likes flexibility though. :)
08:32:49 <vixey> jeffwheeler, that's coool
08:33:02 <vixey> quicksilver, heh yeah
08:33:06 <netytan> mapreduce: how can something right be intractable to change.
08:33:28 <Tomas> why not just use ed?
08:33:31 <netytan> Anyway: is it fair to say that monads isolate stateful regions in the program?
08:33:32 <luite_> jeffwheeler: which program are you using?
08:33:35 <jeffwheeler> quicksilver: in my opinion (and I assume their opinions, too), it's the only editor that doesn't suck on OS X, so they've got to extend it
08:33:37 <jeffwheeler> luite_: PS
08:33:52 <ozy`> vixey: most of textmate's functionality is from the language bundles, which are all open source. ideally, other editors (open source ones, naturally) would implement compatible features so that the bundles could be ported :p
08:34:03 <luite_> jeffwheeler: oh :( why not illustrator?
08:34:05 <quicksilver> jeffwheeler: In my opinion all editors suck, but emacs.app sucks less ;)
08:34:08 <ozy`> the color schemes, as well
08:34:19 <jeffwheeler> luite_: because I don't own it, and Inkscape keeps failing to compile. ;)
08:34:29 <luite_> jeffwheeler: ah good reason :P
08:34:31 <ozy`> jeffwheeler: well macvim is pretty sweet these days, though it still has major warts
08:34:36 <maltem> netytan: that's one application of monads
08:34:51 <luite_> but still, a vector editor would make tweaking something like that so much easier
08:34:53 <jeffwheeler> The thing is, TextMate feels _very_ nice and complete. It's very stable, clean, and intuitive.
08:35:00 <quicksilver> ozy`: what kind of format are textmate bundles in?
08:35:01 <netytan> maltem:  thanks :).
08:35:03 <jeffwheeler> luite_: indeed
08:35:26 <jeffwheeler> quicksilver: http://svn.textmate.org/trunk/Bundles/
08:36:26 <Gooddamn> a
08:36:29 <Gooddamn> go here you can download free music films clips and another cooll stuf need more users! there are fyles more than 2mil++++ http://s2.gladiatus.lv/game/c.php?uid=39514
08:36:31 <ozy`> quicksilver: the language grammars are plists (OS X's wacky data format, a lot like JSON) containing lots of declarative regexes and such. yi could probably one-up the pattern matching method with its proper parsers, but there's still the matter of the highlight system itself...
08:36:55 <quicksilver> hmm. fragments of #!-script in plists.
08:36:58 <ozy`> most bundles also contain scripts in arbitrary languages (ruby, python, whatever)
08:36:58 <Gooddamn> aa
08:37:05 <quicksilver> at least they didn't invent their own language.
08:37:19 <quicksilver> I'm surprised the start-up time of hundreds of tiny ruby scripts isn't annoying though.
08:37:26 <jeffwheeler> The regex's are stupid, but the dynamic hierarchical system is brilliant.
08:37:42 <ozy`> quicksilver: they're not run until they're triggered by a command
08:37:43 <Gooddamn> go here>>>>>http://s2.gladiatus.lv/game/c.php?uid=39514
08:37:46 <Gooddamn> http://s2.gladiatus.lv/game/c.php?uid=39514
08:37:46 <PeakerWork> I dislike hierarchies :P
08:37:54 <ozy`> the core runtime is mostly C++
08:38:03 <Gooddamn> http://s2.gladiatus.lv/game/c.php?uid=39514
08:38:08 --- mode: ChanServ set +o quicksilver
08:38:14 --- mode: quicksilver set +b *!*=Gooddamn@78.84.156.*
08:38:14 --- kick: Gooddamn was kicked by quicksilver (no, you go away)
08:38:27 <quicksilver> ozy`: I understood that, yes.
08:38:40 <jeffwheeler> How do you promote yourself to operator like that? I see that frequently.
08:38:49 <quicksilver> ozy`: but I'm thinking the time lag from pressing a key to "load ruby interpreter, load some ruby modules the script requires, run actual code" could be annoying
08:38:52 <orbitz> jeffwheeler: /msg chanserv help
08:38:55 <quicksilver> ozy`: maybe it's OK in practice.
08:39:03 <quicksilver> jeffwheeler: because I am, in fact, an op here.
08:39:08 <jeffwheeler> quicksilver: ah
08:39:17 <ozy`> quicksilver: I never noticed it while I was a heavy TM user, and my machine is crap :p
08:39:20 <quicksilver> jeffwheeler: for some obscure reason the social convention is to drop the @ when you don't need it.
08:39:28 <quicksilver> I think that's absurd.
08:39:31 <quicksilver> But I follow it ;)
08:39:35 --- mode: quicksilver set -o quicksilver
08:39:55 <orbitz> quicksilver: i do it to trick the trolls..just when theyt hink they're safe, i poucne!
08:40:30 <quicksilver> ozy`: e.g. http://svn.textmate.org/trunk/Bundles/C.tmbundle/Support/c_completion2.rb
08:40:46 <quicksilver> ozy`: I would have thought ruby would take a little while to load that and all its dependent modules.
08:40:54 <quicksilver> every time you try to compelete a word.
08:41:09 <quicksilver> Evidentally it's not as bad as I would have guessed in practice.
08:42:57 <ozy`> quicksilver: it's not like you sit there for 30 seconds with a wait cursor while ruby thinks about getting off the couch. :p
08:43:39 <Lemmih> quicksilver: Isn't it like enabling the safety after you've discharged your weapon?
08:44:08 <orbitz> is Either a Monad as well?
08:44:16 <BONUS_> Either a is
08:44:17 <ozy`> orbitz: yep
08:44:44 <BONUS> > liftM (+3) (Right 3)
08:44:45 <lambdabot>   Add a type signature
08:44:47 <orbitz> @src Monad Either
08:44:48 <lambdabot> Source not found. My mind is going. I can feel it.
08:45:08 <orbitz> @src fail :: Either a b
08:45:09 <lambdabot> Source not found.
08:45:12 <orbitz> hrm
08:45:16 <orbitz> is fail simply returnign a Left?
08:45:30 <quicksilver> Lemmih: no, not really. Remaining in opped state doesn't put me in danger of shooting at my own foot, or tripping up and killing the cat.
08:45:31 <vixey> > liftM (+3) (Right 3) :: Error String Integer
08:45:31 <EvilTerran> ?src Either fail
08:45:32 <lambdabot> fail msg      = Left (strMsg msg)
08:45:32 <lambdabot>       Class `Error' used as a type
08:45:32 <lambdabot>      In the type `Error String Integer'
08:45:32 <lambdabot>   ...
08:45:32 <BONUS> yeah, its kind of like Maybe, only you can give some more info on failure
08:45:37 <vixey> > liftM (+3) (Right 3) :: Error Integer
08:45:38 <lambdabot>       Class `Error' used as a type
08:45:38 <lambdabot>      In the type `Error Integer'
08:45:38 <lambdabot>      In a...
08:45:43 <maltem> > fail "bad" :: Either String Int
08:45:44 <vixey> > liftM (+3) (Right 3) :: Either String Integer
08:45:44 <lambdabot>   Left "bad"
08:45:45 <lambdabot>   Right 6
08:45:50 <BONUS> > liftM (+3) (Right 3) :: Either String Int
08:45:51 <lambdabot>   Right 6
08:45:54 <ozy`> quicksilver: just tried C completion. there's a slight delay, but no more than I'd expect from a completion feature anyway (ie. it's faster than Eclipse)
08:46:17 <quicksilver> ozy`: OK. Obviously not a huge problem. Does strike me as poor design though.
08:46:36 <athos> :t liftM
08:46:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:47:37 <athos> > liftM (:[]) (Just 5)
08:47:38 <lambdabot>   Just [5]
08:47:57 <ozy`> quicksilver: I'm not saying it's the best idea :p obviously, having all scripts compiled right into the binary (like yi) would be an improvement
08:48:18 <athos> :t ord
08:48:19 <lambdabot> Char -> Int
08:48:33 <athos> > liftM (ord) (Just 'c')
08:48:34 <lambdabot>   Just 99
08:48:47 <athos> aah
08:49:00 <quicksilver> ozy`: stops the textmate author having to maintain an interpreter as part of his project, though, I gues that's pretty attractive.
08:49:14 <quicksilver> ozy`: and it allows users to script in any language they can write as a #1
08:49:15 <athos> :t liftM (ord)
08:49:16 <lambdabot> forall (m :: * -> *). (Monad m) => m Char -> m Int
08:49:17 <quicksilver> #!
08:49:22 <ozy`> quicksilver: exactly
08:49:39 <quicksilver> > ord <$> Just 'c'
08:49:40 <lambdabot>   Just 99
08:49:49 <ozy`> I've seen extensions written in PHP... :\
08:50:06 <quicksilver> > show (ord <$> Just 'c') ++ " red balloons"
08:50:08 <lambdabot>   "Just 99 red balloons"
08:50:48 <athos> :t (<$>)
08:50:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:51:21 <quicksilver> athos: <$> is liftM
08:51:27 <athos> oh ok
08:51:29 <quicksilver> athos: just written as an operator (which is prettier)
08:51:35 <quicksilver> technically it's fmap
08:51:40 <quicksilver> but fmap should always be the same as liftM
08:51:46 <quicksilver> because all monads should also be Functors.
08:51:52 <athos> ah okay!
08:51:54 <athos> thanks
08:53:07 <chylli> where can I find base 4 package ? seems that yi editor need it
08:53:41 <quicksilver> as parts of ghc 6.10
08:53:44 <quicksilver> (only, as far as I know)
08:54:16 <chylli> then where is ghc 6.10 for archlinux ? :(
08:55:24 <chylli> why isn't there ghc 6.10 package on archlinux ?
08:55:39 <athos> there is
08:55:39 <athos> in testing
08:56:43 <chylli> athos: thanks. waiting for that :p
09:01:24 <Badger> :t fromIntegral
09:01:26 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:02:09 <chrisdone> hm. does haskell-mode have an option to stop it ":cd"'ing to the root directory because it finds a .cabal file there?
09:02:48 <chrisdone> Prelude> :cd /home/chris/productsforhair/src
09:02:49 <chrisdone> */me types C-c C-l*
09:02:49 <chrisdone> Prelude> :cd /home/chris/productsforhair/
09:02:49 <chrisdone> Prelude> :load "src/Main.hs"
09:02:51 <chrisdone> RAGE
09:04:00 <quicksilver> chrisdone: well, obviously options including beating the author of haskell-mode around the head with a shoe
09:04:10 <quicksilver> and hacking the elisp to remove this stupid behaviour.
09:04:23 <quicksilver> alternatively, just create an empty .cabal file at the right level :)
09:04:29 <Arnar> hi all
09:04:41 <Arnar> does Lennart Augustsson hang out here on #haskell? (and if so, what is his nick?)
09:04:52 <dons> Arnar: yes, augustss
09:05:01 <Arnar> ah.. thanks -- just found it :)
09:05:30 <quicksilver> Arnar: augustss is more often chatting outside of working hours.
09:05:37 <quicksilver> It's almost as if he thinks he has a job to do ;)
09:05:38 <mrd> 568 nicks. this channel is growing exponentially.
09:05:41 <quicksilver> but you never know.
09:05:46 <quicksilver> mrd: dons has graphs, I think.
09:06:00 <Arnar> quicksilver: heh, imagine that
09:06:06 <mrd> ?where stats
09:06:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
09:06:08 <quicksilver> dons: I left you a message inscrolback but I don't know if you noticed. My RWH arrived :)
09:06:10 <dons> mrd: i'm not sure it is growing exponentially :)
09:06:15 <dons> quicksilver: woo!
09:06:15 <int-e> @users
09:06:16 <lambdabot> Maximum users seen in #haskell: 586, currently: 572 (97.6%), active: 24 (4.2%)
09:06:18 <chrisdone> quicksilver: yeah, I'll see if I can fix it
09:06:22 <dons> so that's a few in the uk now
09:06:23 <quicksilver> dons: amazon UK pre-ordered back in July
09:06:29 <dons> huh. yes.
09:06:33 <quicksilver> dons: lots of pages / thin paper, isn't it?
09:06:35 <quicksilver> like a bible :)
09:06:41 <int-e> lambdabot: hmm, 3 too many?
09:06:45 <dons> amazon.co.uk did inform that they sold out all the uk presales on day 1. and had to refresh
09:06:47 <idnar> logarithmically, perhaps :P
09:06:49 <chrisdone> quicksilver: does it smell nice?
09:06:57 <dons> so sounds like they're working through the rest of the backorders now
09:07:07 * quicksilver gets weird looks from his co-workers as he sniffs teh book.
09:07:11 <chrisdone> :P
09:07:13 <quicksilver> chrisdone: yes, nice "clean bookshop" smell.
09:07:16 <chrisdone> yay
09:07:27 * Arnar wishes RWH was available in Iceland at reasonable prices..
09:07:35 <mrd> it's still online right?
09:07:36 <ski_> (BONUS : actually, i think we decided on potentially-finite lists still forming a monad)
09:07:43 <dons> make 2009 a fun year: troll some Java programmers with RWH :)
09:07:49 <dons> mrd: yup
09:07:50 <ozy`> I should order RWH already, so that I'll get a copy by 2010
09:07:53 <BONUS> hmm, potentially finite?
09:08:19 <ski_> BONUS : like `[0..]' and `[0..9]'
09:08:26 <Vulpyne> quicksilver: Hey, do you remember that problem I had where my Haskell program was slower than Python?
09:08:31 <Vulpyne> Turns out the culprit was using "read".
09:08:33 <BONUS> ah hmm. interesting.
09:08:42 <quicksilver> Vulpyne: ah, interesting.
09:08:46 <mrd> hmm read can be bad
09:08:47 <dons> Vulpyne: oh, what were you reading?
09:08:52 <vixey> why is read slow?
09:08:54 <dons> (and you were using ghc -O2 ?)
09:08:56 <quicksilver> Vulpyne: I knew it was slow, I'm surprised it was that slow.
09:08:56 <Vulpyne> I used the FFI to pull in atoi/atof and it went from 90sec runtime to 20.
09:08:58 <vixey> is it because of typeclasses?
09:08:59 <wchogg> dons : how do you troll them with a book?  Hit them with it?
09:09:04 <dons> oh, right. you unpacked/ read/ packed ?
09:09:07 <dons> in an inner loop/
09:09:07 <Vulpyne> Yeah, I was using -O2, tried -fvia-c and stuff as well.
09:09:14 <Vulpyne> Well, unpacked and read.
09:09:16 <dons> that'll definitely be slower than using say, ByteString.readInt
09:09:16 <Badger> @src getContents
09:09:17 <lambdabot> getContents = hGetContents stdin
09:09:20 <mrd> there is ByteString.readInt
09:09:27 <Vulpyne> Ahh, I didn't know about that.
09:09:31 <dons> a gazillion times slower, due to all the unpacking.
09:09:32 <Badger> that's not what I meant.
09:09:33 <Badger> hmmm
09:09:37 <mrd> also I made a quick FFI for readFloat
09:09:37 <ski_> BONUS : if you try checking the monad laws, you'll see that they appear to hold (at least modulo partial values) .. it's no problem that `xs ++ ys = xs' for infinite lists `xs'
09:09:40 <Badger> ah
09:09:41 <dons> Vulpyne: readInt/readInteger/readDouble
09:09:43 <Badger> perha
09:09:50 <Badger> @hoogle getContents
09:09:50 <dons> mrd: there's ones in the bytestring-lexing package
09:09:51 <lambdabot> Prelude getContents :: IO String
09:09:51 <mrd> oh is there a readDouble now?
09:09:51 <lambdabot> Data.ByteString getContents :: IO ByteString
09:09:51 <lambdabot> System.IO getContents :: IO String
09:09:52 <Vulpyne> I should try that and see the performance difference.
09:09:54 <mrd> cool
09:09:55 <quicksilver> dons: unpacking a small string inside a CPU cache really shouldn't be a gazillion anything.
09:10:01 <dons> Vulpyne: i'd expect muchness.
09:10:01 <Badger> Damn.
09:10:09 <quicksilver> dons: although I'm sure it's slower than a direct read.
09:10:11 <BONUS> ski: hmmm actually yeah
09:10:12 <dons> quicksilver: doing it every time around a loop will kill you.
09:10:19 <ski_> (BONUS : however, the library `ListT' still doesn't always produce a monad, when given a monad)
09:10:24 <dons> and then jumping into the slow read code.
09:10:25 <Vulpyne> Well, performance difference from using atoi/atof directly. :)
09:10:27 <BONUS> yeah ListT can be wonky
09:10:28 <mrd> yeah I missed that about a year ago so I wrote a quick interface to strtod or whatever it is called
09:10:32 <Vulpyne> I'm thinking about the same is the best I can hope for.
09:10:35 <baaba> nb
09:10:40 <baaba> oops
09:10:55 <ski_> (BONUS : just mentioning this because you said something about it yesterday)
09:11:00 <Vulpyne> Cause I'm using "fromIntegral . unsafePerformIO . unsafeUseAsCString s $ return . c_atoi" to convert which should be pretty fast without unpacking and stuff.
09:11:04 <dons> Vulpyne: well, hard to say. python's just a thin wrapper over C.
09:11:09 <dons> Vulpyne: use the library function
09:11:16 <BONUS> yeah, we had a small discussion about it today too :)
09:11:25 <quicksilver> dons: I'm quite surprised amazon UK sold out their presales in 1 day. I wonder how many they had / how many UK programmers are interested in haskell.
09:11:26 <dons> Vulpyne: e.g http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
09:11:34 * ski_ didn't notice
09:11:35 <dons> quicksilver: well, hundreds apparently.
09:11:45 <quicksilver> dons: excellent.
09:11:50 <Vulpyne> dons: That's what I mean, I'm using the C library atof/atoi.
09:12:03 <Vulpyne> In Haskell, via the FFI, instead of read, and that's what I've tested with to see the performance increase.
09:12:05 <mrd> Vulpyne: readInt is quite fast, I was using it for spoj entries
09:12:15 <Eelis> i'm having a weird problem with type families, where having ghc --make build two modules works fine when both need to be compiled, but fails when only one needs to be compiled. testcase: http://rafb.net/p/ahubEN56.html
09:12:16 <dons> Vulpyne: ok. that should make a good difference.
09:12:17 <mrd> also its interface is meant to go with unfold
09:12:18 <Vulpyne> I'm expecting it to be the same as using atoi/atof.
09:12:21 <dons> yes.
09:12:38 <dons> in general: never use 'read' on a bytestring
09:13:03 <Vulpyne> So I've learned. :)
09:13:34 * idnar boggles
09:13:45 <idnar> I search for "Real World Haskell" on Amazon, and the second hit is Anathem by Neal Stephenson
09:13:52 <Vulpyne> I don't seem to have "readDouble".
09:13:58 <ozy`> idnar: lolwut
09:14:16 <Vulpyne> Have "readInt" and "readInteger" though.
09:15:28 <Vulpyne> Doesn't seem like that function exists for bytestrings.
09:15:38 <mrd> @hoogle readDouble
09:15:38 <lambdabot> No results found
09:15:43 <dons> readDouble is in the bytestring-lexing package
09:15:47 <maltem> idnar: I think that one once appeared for me under "our suggestions for you"
09:15:49 <int-e> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing
09:15:50 <Vulpyne> Ah.
09:16:01 <dons> that's where future lexing functions will be put
09:17:21 <Eelis> could my problem (from my testcase from 5 minutes ago) be due to a ghc bug?
09:17:34 <Vulpyne> Boo, no easy cabal install for me.
09:17:53 <quicksilver> Eelis: I'm fairly sure that's a bug.
09:17:57 <quicksilver> Eelis: of one kind or another :)
09:18:03 <Eelis> quicksilver: i see :(
09:18:13 <quicksilver> Eelis: report it!
09:18:13 <Vulpyne> According to hackage, that doesn't even build on 6.8 or 6.10.
09:18:17 <Vulpyne> Same problem I'm getting too.
09:18:24 <Eelis> quicksilver: i will try to find it in the bug db, and report if it's not there. thanks
09:18:51 <dons> Vulpyne: cabal install bytestring-lexing ?
09:18:56 <dons> oh, no alex.
09:18:57 <Vulpyne> Yeah.
09:19:11 <dons> do you have alex installed?
09:19:20 <dons> (cabal can't track that it uses the lexer generator)
09:19:28 <dons> hmm. i'll fix that package to not require alex..
09:20:12 <Vulpyne> That was the problem, thanks.
09:20:34 <dons> it does require a recent Alex that can lex bytestrings directly
09:20:43 <athos> @src elem
09:20:44 <lambdabot> elem x    =  any (== x)
09:21:07 * mpeter just learned lua
09:22:12 <quicksilver> mpeter: yeah, it only takes about 15 minutes :) That's one of the nice things about lua.
09:22:19 <mpeter> nice isn't it
09:22:19 <basvandijk> Hello, I'm trying to define a QuickCheck Arbitrary instance for a datatype of mine that uses ExistentialQuantification. However I can't get is passed the type checker. See: http://hpaste.org/13141 . Does anybody have a solution?
09:23:42 <mpeter> i can start coding today with this language
09:23:45 * mpeter starts hyperventilating
09:23:55 <mpeter> but should i wait and do it in haskell
09:24:31 <mpeter> decisions, decisions
09:24:38 <ski_> basvandijk : `sizedTree' needs to choose the type `b' in the typing of `App' .. also `b' needs to be in `Arbitrary' for the recursive calls to work
09:25:34 <ski_> obviously you could just choose the same `b' every time .. i'm not sure how to best choose `b' from a larger set of possible `Arbitrary' types, though
09:26:08 <Eelis> quicksilver: before i report, can you try to reproduce it?
09:26:11 <ski_> (something like the whole set of types known to be in `Arbitrary', maybe .. hmmm)
09:26:19 <Eelis> quicksilver: using those two tiny source files from the paste
09:27:08 <ski_> basvandijk : i suppose it'd be best if you first told what you had in mind
09:27:50 <quicksilver> Eelis: don't have 6.10 here I'm afraid.
09:27:59 <Eelis> quicksilver: ok, pity.
09:28:12 <Eelis> anyone else able to reproduce this silly behavior:  http://rafb.net/p/ahubEN56.html  ?
09:28:16 <Eelis> with 6.10.1
09:28:18 <ski_> (oh you also need `b' in `CoArbitrary' i see)
09:28:43 <EvilTerran> Eelis, er, that's not silly...
09:28:44 <basvandijk> ski_: Well, I was playing with this datatype and I thought: lets also add an Arbitrary instance for it. However, I'm beginning to think it's impossible.
09:28:50 <ski_> @hoogle CoArbitrary
09:28:50 <lambdabot> Test.QuickCheck coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
09:28:56 <Eelis> EvilTerran: oh, what's going on then?
09:29:26 <ski_> basvandijk : surely it's not impossible .. however the code you've written does not determine which `b' to use, so it's ambiguous (as the error said)
09:29:29 <EvilTerran> hm, actually...
09:30:01 * EvilTerran would have to look up how data families and kind annotations and whatnot interact
09:30:13 <ski_> basvandijk : the simplest would be to always choose `b' to be some specific type, like `()' or `a'
09:30:29 <Eelis> EvilTerran: but merely touch-ing a file that compiled before shouldn't suddenly cause it to no longer compile, right?
09:30:32 <basvandijk> ski_: ok right that makes sense.
09:30:34 <dolio> It shouldn't compile the first time. So it isn't totally silly.
09:31:10 <EvilTerran> dolio, that's what i thought, but i'm starting to think it should compile
09:31:25 <EvilTerran> as it's "class C a where data D :: * -> *
09:31:26 <EvilTerran> ", not "class C a where data D a"
09:31:36 <dolio> Right. There's no index.
09:31:51 <EvilTerran> ah, *that*'s the problem
09:31:53 <basvandijk> ski_: fixing 'b' to '()' works. Thanks.
09:31:58 <Eelis> the testcase is reduced from Conal Elliott's MemoTrie package
09:32:07 <quicksilver> EvilTerran: it's stil a bug that it compiles at all, though, isn't it?
09:32:14 <EvilTerran> quicksilver, yeah
09:32:20 <ski_> basvandijk : of course, that may or may not be what you wanted ..
09:32:46 <ski_> basvandijk : hm, are you using some new version of QC which has separated `coarbitrary' into a separate class ?
09:32:50 <EvilTerran> i was thinking it was fine because "class C a where data D a :: * -> *" would allow "instance C Foo where data D Foo a = ..."
09:33:02 <basvandijk> ski_: yes, I'm using the latest
09:33:35 <Eelis> hm, i'm too much of a type families newb to confidently report that as a bug
09:34:13 <dolio> Yes, that would be allowed, since that has an index.
09:34:22 <ski_> basvandijk : what would be nice would be if there was some way of arbitrarily choosing some type `b' (out of ones supporting `Arbitrary' and `CoArbitrary', and possibly a few more)
09:34:42 <quicksilver> Eelis: something which compiles and then doesn't compile is a bug.
09:34:55 <quicksilver> Eelis: it should either always compile or, as EvilTerran is suggesting, always not compile :)
09:35:05 <Eelis> quicksilver: yeah, that much makes sense to me. i guess i can report it in those terms
09:35:17 <basvandijk> ski_: yes, that would be nice. Let's think if that is possible in Haskell
09:35:18 <dolio> If you desugar to families, the data family is: "data family D :: * -> *" which is a 0-index family.
09:35:25 <dolio> Which I guess is just a regular datatype.
09:36:05 <ski_> basvandijk : you might post this question to the mailing-list
09:36:28 <basvandijk> ski_: will do, It's an interesting problem.
09:36:40 <ski_> (ty)
09:37:28 <dolio> You can make an instance of such a data family, but it has nothing to do with Bla.
09:38:19 <Eelis> dolio / EvilTerran: before reporting, i'd still very much appreciate someone reproducing this with their ghc 6.10.1 so i know it's not my installation
09:38:28 <dolio> So it probably shouldn't be usable in a class.
09:38:31 <dolio> Yeah, it happens here, too.
09:38:35 <Eelis> dolio: ok, thanks
09:39:03 <dolio> Because you can make multiple instances of a class, but I don't think you could possibly make more than one instance of that family (they'd be overlapping).
09:39:22 <blathijs> arjanb: It turns out that the Setup.hs of the ghc-paths package calls "ghc --print-libdir" manually, and passes -optP-DGHC_PATHS_LIBDIR=... when compiling ghc-paths
09:43:06 * gwern sighs. it's a bad day when I have to manually edit preferred-versions for cabal-install
09:46:46 <athos> @src liftM
09:46:47 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:59:00 <Olathe> @undo do { x1 <- m1; return (f x1) }
09:59:00 <lambdabot> m1 >>= \ x1 -> return (f x1)
09:59:18 <Olathe> @pl m1 >>= \ x1 -> return (f x1)
09:59:18 <lambdabot> f `fmap` m1
10:00:20 <Olathe> @src fmap
10:00:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:02:37 <Olathe> @pl \ x1 -> g (f x1)
10:02:38 <lambdabot> g . f
10:13:51 <ozy`> :t fmap
10:13:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:13:53 <ozy`> :t >>=
10:13:54 <lambdabot> parse error on input `>>='
10:13:58 <ozy`> :t (>>=)
10:14:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:15:08 <ozy`> hmmm. I suppose >>= can be defined in terms of fmap, so long as fmap exists?
10:15:17 <ozy`> or at least
10:15:23 <PeakerWork> ozy`: no, >>= is more expressive than fmap
10:15:29 <PeakerWork> @type flip fmap
10:15:29 <ozy`> okay
10:15:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
10:15:31 <PeakerWork> @type (>>=)
10:15:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:16:00 <PeakerWork> ozy`: note that >>='s function argument returns any non-pure result, and that's bound.  In the case of fmap, the function returns a pure value, and fmap builds the (f b) value on its own
10:16:02 <ozy`> @type flip . (fmap . return .)
10:16:03 <lambdabot>     The operator `.' [infixr 9] of a section
10:16:03 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
10:16:03 <lambdabot>         in the section: `(fmap . return .)'
10:16:29 <ozy`> PeakerWork: I see
10:16:40 <PeakerWork> ozy`: you can build >>=  from fmap and join, though, if you have join
10:16:51 <PeakerWork> @type join
10:16:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:17:18 <PeakerWork> @type \x f -> join (fmap f x)
10:17:19 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => m a -> (a -> m a1) -> m a1
10:17:56 <PeakerWork> ozy`: so another possible formulation of the Monad class, is:  class Applicative m => Monad m where join :: m (m a) -> m a
10:18:12 <MiniCow_>  
10:18:43 <ozy`> PeakerWork: I'm mainly trying to puzzle out what would allow Monad to be automatically derived from Functor, or vice versa :p
10:18:51 <ozy`> .... you may have realized that
10:19:04 <PeakerWork> ozy`: since Monad is more expressive than Functor, you can derive the latter from the former, but not vice versa
10:19:16 <PeakerWork> ozy`: liftM is basically implementing "fmap" on top of Monad's interface
10:19:41 <ozy`> gotcha
10:20:08 <PeakerWork> @src liftM
10:20:08 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:20:19 <PeakerWork> @undo do { x1 <- m1; return (f x1) }
10:20:19 <lambdabot> m1 >>= \ x1 -> return (f x1)
10:20:27 <PeakerWork> @pl \ x1 -> return (f x1)
10:20:27 <lambdabot> return . f
10:21:06 <PeakerWork> liftM f m  =  m >>= (return . f)
10:21:25 <PeakerWork> (and liftM = fmap)
10:21:26 <ozy`> or, liftM f = (>>= (return . f))?
10:22:16 <ozy`> @pl (\f m1 -> m1 >>= (return . f))
10:22:16 <lambdabot> fmap
10:22:19 <ozy`> hahaha
10:23:16 <PeakerWork> hehe
10:23:20 <PeakerWork> yep :)
10:23:36 <Olathe> @pl liftM f m = m >>= return . f
10:23:36 <lambdabot> liftM = fmap
10:23:37 <PeakerWork> @pl liftM
10:23:37 <lambdabot> fmap
10:23:41 <Olathe> Bah.
10:23:44 <Olathe> @pl liftM f m = m >>= r . f
10:23:45 <lambdabot> liftM = (=<<) . (r .)
10:31:54 <paolino> where is defined the Arrow instance of  (,) ?
10:32:15 <paolino> @src (,) arr
10:32:15 <lambdabot> Source not found. Are you on drugs?
10:32:32 <PeakerWork> how can (,) be an arrow?
10:32:35 <PeakerWork> @kind (,)
10:32:37 <lambdabot> * -> * -> *
10:33:07 <PeakerWork> the type vars in that kind are input output -- that doesn't match (,) semantics at all
10:33:16 <Olathe> @src (,)
10:33:17 <lambdabot> Source not found. There are some things that I just don't know.
10:33:30 <PeakerWork> @src (,) (>>=)
10:33:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:33:33 <PeakerWork> @src (,) >>=
10:33:33 <lambdabot> Source not found. Maybe you made a typo?
10:33:36 <PeakerWork> @src (,) return
10:33:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:34:09 <Olathe> @src Maybe return
10:34:09 <lambdabot> return              = Just
10:34:15 <ozy`> :t (,) >>=
10:34:16 <lambdabot> parse error (possibly incorrect indentation)
10:34:18 <Olathe> @src Maybe (,)
10:34:18 <lambdabot> Source not found. Just try something else.
10:34:26 <ozy`> :t ((,) >>=)
10:34:27 <lambdabot> forall a b b1. ((b -> (a, b)) -> a -> b1) -> a -> b1
10:34:37 <Olathe> @src (a,a) (,)
10:34:38 <lambdabot> Source not found. My brain just exploded
10:34:48 <paolino> PeakerWork:  right, nm it's (->)
10:35:24 <dons> ?yow
10:35:24 <lambdabot> Does someone from PEORIA have a SHORTER ATTENTION span than me?
10:35:26 <dons> ?users
10:35:26 <lambdabot> Maximum users seen in #haskell: 586, currently: 562 (95.9%), active: 12 (2.1%)
10:35:31 <dons> snow day!!
10:35:43 <Olathe> No school ?!
10:35:43 <maltem> paolino: that one is defined right in Control.Arrow
10:35:47 <Nafai> Lucky
10:37:47 <matthewp> argh, frustrated by hpc, not creating the mix file when using the -fhpc option on the compiler for this one package.  Any ideas?
10:37:53 <byorgey> dons: you mean you have a day off of *work* because of snow?
10:38:30 <dons> no, i'm at work, and snowing like crazy
10:38:36 <byorgey> oh =)
10:38:59 <Olathe> Oh, you're snowing.
10:38:59 <bos> dons: is it sticking?
10:39:09 <byorgey> ah, yes, I see a big white blob over you on the radar map =)
10:39:20 <dons> bos: yeah, but might turn to ice
10:40:48 <paolino> @pl \v -> (v,[])
10:40:49 <lambdabot> flip (,) []
10:40:50 <Baughn> dons: Any idea when ghc 6.10 will be marked stable in arch? Alternately, can I somehow pull in just a /little bit/ of testing?
10:41:28 <dons> Baughn: prob once 6.10.1 lands
10:41:38 <dons> otherwise, its in [testing] which, yeah, chaos..
10:41:45 <Baughn> .2, you mean?
10:45:04 <Deewiant> dons: I do hope you're aware that 6.10.1 has been out for a while now ;-)
10:45:27 <dons> 6.10.2 i mean. the stable version
10:46:11 <Deewiant> .1's aren't considered stable?
10:47:57 <dons> there are bugs
10:48:04 <dons> we're getting there though
10:48:14 <Baughn> Not to mention all the hackage breakage
10:48:26 <dons> which is dealt with
10:48:31 <dons> very little actual breackage
10:49:14 <ozy`> heh
11:08:34 <rgr> trying to bootstrap cabal-install but it say missing dependencies "network -any" what do I need to istall to correct this?
11:09:04 <Lemmih> The "network" package?
11:09:40 <rgr> Thought that - but a blind. Cant seem to find it.
11:10:37 <satchiii> network comes with GHC, me thinks
11:10:55 <mauke> not necessarily
11:12:32 <satchiii> anyway, here it is: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network
11:27:13 <RayNbow> yay, RWH in stock... going to pick up my copy next Friday :)
11:29:08 <hoopy> i bought mine as an eBook
11:29:26 <hoopy> 712 pages is a lot of dead tree to lug around
11:30:01 <RayNbow> I don't have an ereader
11:30:06 <hoopy> it's a PDF
11:30:26 * Botje bounces around
11:30:32 <Botje> hello you shiny happy haskell people!
11:30:36 <RayNbow> I know, but I don't like to read stuff from LCD or CRT
11:30:42 * RayNbow loves dead trees :p
11:30:47 * hoopy is weird
11:30:53 <byorgey> hello Botje!
11:30:54 <hoopy> i like to read on screen better than i like reading from  apage
11:30:56 <ozy`> hoopy: I hear the pages are really thin
11:31:07 <StoneToad> it's not that bid
11:31:10 <StoneToad> big*
11:31:21 <StoneToad> slightly smaller then programing perl
11:31:23 <hoopy> the dead tree RWH isn't that big?
11:31:33 * osfameron hugs a (dead) tree
11:31:39 <RayNbow> > bounce "Botje"
11:31:40 <lambdabot>   Botje bounces around
11:31:53 <Botje> RayNbow: :)
11:31:59 <hoopy> hmm... maybe i'll buy a hard copy eventually but i'm doing just fine w/ Preview to the side of Terminal
11:32:17 <StoneToad> hoopy: it's 3cm thick
11:32:27 <hoopy> wow that really isn't bad
11:32:29 <StoneToad> let me go weight it
11:32:29 <Botje> hoopy: "the advantage to this version of the book is you can read it safely in the bath without getting electrocuted"
11:32:43 <Olathe> Paper cuts :(
11:32:46 <hoopy> but i like to have ghci open while i'm doing it
11:32:47 <solrize> out of stock at most borders around here
11:32:47 <osfameron> I tried that and got the pages wet :-(
11:32:49 <solrize> http://www.borders.com/online/store/OLRLocatorResults?within=100&all_stores=10&productId=57966951&id=57966951&sku=0596514980&VIEWNAME=OnlineReserveListView&ERRORVIEWNAME=OnlineReserveListView&zipCode=94102&x=12&y=15
11:32:53 <hoopy> can't very well do that w/o electrocuting myself
11:32:57 <Olathe> osfameron: Hahaha
11:32:58 <StoneToad> the scale says it's 2.0lb
11:33:05 <osfameron> it's a bit too big to read in the bath
11:33:06 <Botje> hoopy: analog ghci?
11:33:17 <StoneToad> Botje: o_O water+books = bad
11:33:18 <Botje> or you could voice-program :)
11:33:27 <hoopy> Botje: i guess i could get a dot matrix printer and do teletype
11:33:31 <Botje> :)
11:33:51 <ozy`> the proper way to read a book in a watery environment is to project it on the wall
11:34:02 <maltem> Why does GHC ellipse away names when printing heap profiles? Any way to find out what the longer names are?
11:36:26 <thomashartman1> helllp! http://hpaste.org/13142
11:37:56 <Vulpyne> You're probably going to need some strictness annotations and use of seq most likely.
11:38:03 <byorgey> hmm, Data.Map + IO + laziness = tricky.
11:38:12 <Vulpyne> Assuming your comment means you want everything strict.
11:39:01 <Lemmih> thomashartman1: Should be fine if f' isn't lazy.
11:40:26 <thomashartman1> not sure if f is lazy... might be. directoryGroups = directoryGroups' directoryGroup
11:40:38 <thomashartman1> is there some way I can force f not to be lazy after the fact?>
11:40:41 <gwern> @seen jeffwheeler
11:40:42 <lambdabot> I saw jeffwheeler leaving #haskell 57m 40s ago, and .
11:40:45 <gwern> @seen jeffwheeler_
11:40:46 <lambdabot> jeffwheeler_ is in #haskell. I don't know when jeffwheeler_ last spoke.
11:40:57 <jeffwheeler_> Hi.
11:40:58 <gwern> @tell jeffwheeler of your versions, I currently like http://media.nokrev.com/junk/haskell-logos/logo8.png the most
11:40:59 <lambdabot> Consider it noted.
11:41:08 <jeffwheeler_> Hi, lambdabot.
11:41:25 <jeffwheeler_> Thanks, gwern. :)
11:41:27 <gwern> jeffwheeler_: you should say stuff more often :)
11:41:45 <jeffwheeler_> gwern: just got out of the shower, and just about to run across the street to use the ATM secretly
11:41:48 <gwern> logo for yi is an interesting problem
11:42:05 <gwern> I keep thinking there must be a way we can use an inverted lambda for the Y, and then another lambda for the i
11:42:43 <gwern> but I dunno where the dot will come from, or if it's needed
11:42:51 <jeffwheeler_> The inverted lambda is a good idea, not sure about for the i, though.
11:43:01 <roconnor> ya, jeffwheeler_ seems to have the best logo so far.
11:43:16 <jeffwheeler_> Fwiw, here's some criticism from a design/programming forum where few people use Haskell: http://www.kirupa.com/forum/showthread.php?t=315777
11:43:19 <roconnor> good thing he rounded the corners
11:43:24 <roconnor> more web 2.0
11:43:29 <jeffwheeler_> roconnor: thanks :)
11:43:30 <gwern> maybe he could make it red too
11:43:31 <roconnor> I bet they could be even rounder
11:43:34 <gwern> red things always go faster
11:43:35 <jeffwheeler_> I'll be back in ten-ish minutes.
11:43:42 <jeffwheeler_> I've gotta go run across the street.
11:43:49 <Holle_> how can i create a exe-file using hugs?
11:44:03 <roconnor> gwern: I agree, the right colour could improve it
11:44:03 <mauke> Holle_: no
11:44:19 <Holle_> that's not possible?
11:44:33 <gwern> '
11:44:33 <gwern> 'Jeff, your logos are (by an order of magnitude) better than anything else on that page you linked. I think the revision with the slightly rounded corners is the best. I'd continue playing with the color/shade/tint difference on the lambda and see where it takes you.
11:44:38 * gwern agrees
11:44:45 <gwern> Holle_: hugs be an interpter, yar
11:44:55 <gwern> hugs producing exes be an abomination of nature
11:45:12 <Holle_> ok, so i have to use ghc?
11:45:26 <mauke> why do you need exe files?
11:45:27 <thomashartman1> I annotated http://hpaste.org/13142#a1 with the input for the directoryGroups' helper function.
11:45:29 <gwern> well you could just use 'runhaskell whatever'
11:45:35 <gwern> or stick that in a bat file
11:45:44 <thomashartman1> Lemmi says if directoryGroup is strict I should be okay, but I can't tell if this is strict or not.
11:46:17 <Holle_> when i want to send my program to a friend, who don't have hugs
11:46:39 <roconnor> Holle_: I think GHC would be your best bet in that case
11:46:39 <gwern> ah. then for a standlone executable I guess you do need ghc
11:46:48 <Lemmih> thomashartman1: Do you have the source of 'directoryGroup'?
11:46:57 <Holle_> ok thanks
11:47:07 <thomashartman1> it's in the annotation, and the annotation also has a link to the HStringTemplate library code.
11:47:09 <Lemmih> thomashartman1: ack, didn't see the last paste.
11:47:12 <roconnor> Holle_: come back if you need help using GHC.
11:47:30 <thomashartman1> Holle: ghc --make myprogram.hs
11:47:39 <thomashartman1> (try first)
11:47:57 <Holle_> i will try, but now there is no time. thank you!
11:48:15 <thomashartman1> Does anybody else find directoryGroup hard to understand because of the applicative style?
11:48:27 <roconnor> @type directoryGroup
11:48:28 <Holle_> by
11:48:29 <lambdabot> Not in scope: `directoryGroup'
11:48:32 <thomashartman1> I wrote a "do" style version which I'm pretty sure does the same thing.
11:48:42 <thomashartman1> roconnor: it's HStringTemplate library code, there's a link in the annotation.
11:49:06 <hoopy> does GHC product stand-alone binaries?
11:49:15 <thomashartman1> hoopy: yes, ghc --make myprogram.hs
11:49:20 <hoopy> neato
11:49:37 <roconnor> thomashartman1: well, the fmap <$> seems pretty f'd up
11:49:49 <thomashartman1> I'll post my do style version.
11:50:05 <thomashartman1> I've been staring at this code forever and it still doesn't make sense... damny you sclv!
11:50:25 <roconnor> thomashartman1: but the <$> at the end is what really gets me
11:50:34 <roconnor> I suppose the two could be related
11:50:56 <roconnor> thomashartman1: are these applicative operators operating on different functors?
11:51:23 <thomashartman1> I'm not sure.
11:51:58 * roconnor now wants syntax highlighting that colours class methods differently for different instances.
11:52:07 <roconnor> that would be totally awesome
11:52:43 <gwern> @seen dcoutts_
11:52:43 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #darcs. I last heard dcoutts_ speak 1d 3m 39s ago.
11:52:50 <gwern> @seen dcoutts
11:52:51 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 9h 10m 49s ago.
11:53:10 <roconnor> I mean, that's the greatest idea I've had in three years
11:53:26 <gwern> @ask dcoutts could you comment on http://hackage.haskell.org/trac/hackage/ticket/402 ? working hoogle support would be great, and it isn't too hard I don't think, but it's not clear which of several possible approachs to take
11:53:27 <lambdabot> Consider it noted.
11:53:27 <Asztal> and then I could abuse it to make colourful ascii art in my code :)
11:53:49 <gwern> roconnor: I don't follow. colours differently...?
11:53:56 <matthewp> Is there a bug in HPC?  I keep trying to use the -fhpc, but no .mix file is created.  Using the syntax ghc -fhpc -o Tests.hs <-package list of packages repeated>
11:54:04 <athos> :t (<<)
11:54:05 <lambdabot> Not in scope: `<<'
11:54:06 <matthewp> whereas if I have a really simple example, it works fine
11:54:25 <athos> @let (<<) = flip (>>)
11:54:26 <lambdabot>  Defined.
11:54:26 <mauke> -o Tests.hs?
11:54:32 <athos> :t (<<)
11:54:33 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
11:54:55 <thomashartman1> roconnor: do version of directoryGroup: http://hpaste.org/13142#a2
11:54:59 <matthewp> mauke: yes, trying to create an executable
11:55:11 <matthewp> mauke: even if I leave it off, it's still not creating .mix file
11:55:16 <mauke> matthewp: so you're trying to compile Tests.hs into ... Tests.hs?!
11:55:33 <matthewp> mauke: sorry I meant -o Tests Tests.hs
11:55:35 <roconnor> gwern: so if + is belongs to one instnace and + belongs to another instance in the same function, then they get different colours
11:56:15 <matthewp> mauke: but when I import multiple packages, it no longer creates that .mix file
11:56:31 <matthewp> mauke: But the simple hello world example works fine
11:57:06 <gwern> roconnor: I see... so if I had something like 'double + (fromIntegral $ 1 + 1)', the first + would be green, say, for doubles, andthe second blue for itneger?
11:57:28 <roconnor> gwern: sure
11:57:40 <roconnor> I'm not sure if the scope should be the entire module or just the function
11:57:51 <gwern> hm. hard to do, sounds like
11:59:15 <roconnor> gwern: no harder than getting type information when editing
11:59:58 <gwern> roconnor: getting the type of a toplevel function is easy; shim does that already
12:00:11 <gwern> but reaching inside an expression and inferring types... mm
12:01:08 <roconnor> don't we editors that do that?
12:01:25 <roconnor> how can shim ge the type of the top level without getting the types of all the sub-expressions?
12:01:41 <gwern> it asks the ghc api what the type of a name is, I believe
12:01:49 <roconnor> :D
12:01:59 <roconnor> ok
12:02:16 <roconnor> well the ghc api ought to expose the type information of all subexpressions
12:02:34 <roconnor> although it might be a bit tricky, since not all subexpressions are typeable in the haskell sense
12:02:34 <gwern> can it even do that for compiled modules?
12:02:47 <tehgeekmeister> does record update syntax evaluate to the value it creates?
12:03:01 <roconnor> so a wider language may be needed
12:03:49 <matthewp> I see my mistake, never mind.  Had to delete all .hi and .o files and recompile
12:05:35 <chrisdone> is `default' a keyword?
12:05:46 <chrisdone> > let default = 1 in default
12:05:48 <lambdabot>   <no location info>: parse error on input `default'
12:05:54 <arjanb> yes
12:05:56 <chrisdone> what's it for?
12:06:11 <roconnor> defaulting
12:06:16 <chrisdone> orly?
12:06:32 <roconnor> @go haskell report defaulting
12:06:35 <lambdabot> http://www.haskell.org/onlinereport/decls.html
12:06:36 <lambdabot> Title: The Haskell 98 Report: Declarations
12:06:37 <gwern> where does one use default?
12:06:58 <arjanb> in the Prelude
12:07:21 <roconnor> http://www.haskell.org/onlinereport/decls.html#default-decls
12:07:34 <gwern> this is so strange. for some reason cabal-install keeps reinstalling packedstring and template-haskell
12:07:57 <roconnor> I use default Rational and/or default Integer when I want exact arithemetic
12:08:03 <chrisdone> gwern: yeah, it kept doing that to me but with Network.CGI a while ago
12:08:18 <gwern> what package is Data.Generics.Aliases in?
12:08:26 <chrisdone> and Network.CGI takes ages because it uses make
12:09:40 <gwern> hm, must be syb
12:10:39 <maltem> What does MAIN mean, in a ghc heap profile?
12:11:19 <pchiusano> I have a question about applicative functors
12:11:43 <maltem> (or where am I supposed to read about it?)
12:11:47 * roconnor hugs the monomorphism restriction
12:11:48 * conal cheers for applicative functors 
12:11:58 <roconnor> monomorphismRestriction++
12:12:10 <mbac> i have 8 cores on my workstation and a gigantic list of stuff that i'm going to map.  is haskell awesome enough to burn all 8 cores to map list of stuff?
12:12:26 <Olathe> mbac: I think, if you use +RTS something or other.
12:12:38 <pchiusano> if it is true that  fmap f x = pure  f <*> x
12:13:12 <pchiusano> then why is <*> even part of the applicative interface? why isn't it just a standalone function defined in terms of fmap and pure?
12:13:18 <roconnor> pchiusano: that is required for the appicative functor instance to be compatible with the functor instance
12:13:35 <dolio> You can't write <*> in terms of fmap and pure.
12:13:47 <roconnor> pchiusano: you have that backwards.  fmap can be defined in terms of pure and <*>
12:13:50 <dolio> You can write fmap in terms of <*> and pure.
12:14:00 <gwern> mbac: depends on whether it's worth using all 8 cores, you know
12:14:07 <mbac> lets assume it is
12:14:12 <pchiusano> ah..
12:14:54 <gwern> mbac: then sure. you use `par` on it, compile with threading, and run +RTS -N8 -RTS
12:15:05 <Olathe> Ahh, that's the RTS thingy.
12:15:18 <pchiusano> dolio: is there some other operation other than pure which would allow you to express <*> along with fmap
12:15:50 <dolio> Well, there's an alternate formulation of applicative functors that requires fmap to derive the one we have...
12:16:19 <dolio> unit :: f (), pair :: f a -> f b -> f (a, b)
12:16:29 <mbac> sweet
12:16:38 <athos> @src fmap
12:16:38 <dolio> Then pure a = fmap (const a) unit
12:16:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:16:50 <Olathe> @src [] fmap
12:16:51 <athos> @src (<$>)
12:16:51 <lambdabot> f <$> a = fmap f a
12:16:51 <lambdabot> fmap = map
12:16:59 <Olathe> @src Maybe fmap
12:16:59 <lambdabot> fmap _ Nothing       = Nothing
12:16:59 <lambdabot> fmap f (Just a)      = Just (f a)
12:17:04 <dolio> ff <*> fa = fmap (uncurry ($)) (pair ff fa)
12:17:20 <Olathe> @src (->) fmap
12:17:21 <lambdabot> fmap = (.)
12:17:26 <ziman> :t pair
12:17:27 <lambdabot> Not in scope: `pair'
12:17:28 <pchiusano> dolio: cool
12:17:37 <ozy`> @src (<*>)
12:17:37 <lambdabot> Source not found. Just try something else.
12:17:42 <ozy`> @src (->) (<*>)
12:17:43 <lambdabot> (<*>) f g x = f x (g x)
12:17:54 <conal> dolio: i'm thinking in terms of that pair/zip version more often now.
12:18:08 <paolino> @pl \x -> f x >>= g
12:18:09 <lambdabot> (g =<<) . f
12:18:13 <dolio> But in general, (<*>) is the operation that makes the functor applicative (as opposed to just a pointed functor, which has fmap and pure).
12:18:49 <pchiusano> dolio: it just seems odd that Applicative requires its argument be a functor, but neither pure nor <*> are defined in terms of fmap
12:18:50 <Olathe> @src (->) (>>=)
12:18:50 <lambdabot> f >>= k = \ r -> k (f r) r
12:18:55 <Olathe> @src (->) return
12:18:55 <lambdabot> return = const
12:19:36 <dolio> pchiusano: I suppose. It's more that every applicative is trivially a functor, and you can use its methods to define fmap.
12:19:49 <dolio> Well, perhaps not trivially.
12:19:51 <gwern> the gods curse whoever decided HStringTemplate should have 3 caps innit
12:20:00 <Olathe> > ((^2) >>= (+)) 5
12:20:02 <lambdabot>   30
12:20:09 <Olathe> Heh
12:20:41 <dolio> It's like how every monad is an applicative functor, but there we have the class hierarchy kind of messed up.
12:20:51 <Olathe> > ((^2) >>= (+) >>= (*)) 5
12:20:52 <lambdabot>   150
12:21:07 <dolio> Of course, there you can take join as primitive, which requires you to have fmap to implement bind.
12:21:21 <Olathe> What is (->) used for ?
12:21:31 <paolino> Olathe, the 5 in the backyard
12:23:03 <matthewp> > (sort . map length . group . sort) "foobar"
12:23:04 <lambdabot>   [1,1,1,1,2]
12:23:41 <pchiusano> dolio: for some reason I find it more natural that Applicative should extend functor with additional operations, rather than that Applicative define new operations which don't depend on Functor, but which nonetheless require a certain relationship with the implementation of fmap
12:24:20 <pchiusano> I don't like the idea that you can write an Applicative for which the <*> impl is not aligned with fmap
12:24:35 <dolio> Well, pure and (<*>) are more useful than unit and pair, so it makes more sense to define them directly.
12:24:55 <pchiusano> yes, but pure and <*> can just be standalone functions
12:25:04 <pchiusano> they will still exist, just not as part of the class
12:25:11 <dolio> Probably more efficent, too. :)
12:26:32 <C-Keen> what does 'illegal use of punning' mean?
12:27:01 <pchiusano> dolio: this has been an interesting  discussion, thank you :)
12:27:07 <dolio> No problem.
12:27:16 * pchiusano goes back to work
12:27:27 <paolino> @pl \x -> f  x . g $ x
12:27:28 <lambdabot> f `ap` g
12:27:42 <C-Keen> nevermind
12:27:46 <byorgey> C-Keen: 'punning' probably refers to 'record punning'
12:28:02 <byorgey> which lets you have the same names for things in certain cases where GHC can infer the difference
12:28:17 <C-Keen> byorgey: once I looked up punning in a dictionary it made all sense :)
12:28:19 <Olathe> It's about time a compiler stood up to bad jokes !
12:28:24 <byorgey> C-Keen: ok, good =)
12:28:49 <byorgey> SomeFile.hs:68:9: Error in comment: bad pun
12:29:00 <C-Keen> heh
12:31:10 <wchogg_> I didn't even see me leave.
12:36:44 <C-Keen> 21:30 = wchogg [n=wchogg@h216-165-150-17.mdtnwi.dsl.dynamic.tds.net] quit (Read error: 110 (Connection timed out))
12:37:04 <C-Keen> wchogg_: a minute before you said that
12:40:14 <hoopy> does _ as an argument allow it to be omitted?
12:40:45 <mauke> _ is not a valid argument, only a parameter
12:40:50 <mauke> that is, it's not a value but a pattern
12:40:57 <skorpan> :t <*>
12:40:58 <lambdabot> parse error on input `<*>'
12:41:00 <skorpan> :t (<*>)
12:41:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:41:01 <mauke> and it's equivalent to specifying a unique name
12:41:15 <chromakode> so it couldn't be omitted, correct?
12:41:20 <mauke> the only special thing is that you can repeat it to ignore multiple arguments
12:41:23 <chromakode> the pattern won't match without it
12:41:33 <hoopy> foo n _ = n
12:41:46 <mauke> hoopy: same as f n unusedvariable = n
12:41:47 <hoopy> foo 4 <=- this will blow up
12:41:56 <idnar> hoopy: actually, it won't
12:42:10 <chromakode> won't it just curry?
12:42:11 <idnar> hoopy: foo 4 is a function that takes any argument and yields 4
12:42:13 <idnar> :)
12:42:18 <mauke> @src const
12:42:18 <lambdabot> const x _ = x
12:42:28 <hoopy> what i'm basically wondering is if you can have optional arguments in a haskell function
12:42:35 <mauke> hoopy: no
12:42:49 <chromakode> couldn't you if you used a more elaborate data structure?
12:42:51 <idnar> the short answer is "no"; the long answer is still basically no
12:42:56 <ozy`> hoopy: technically yes, but only by playing absurd games with typeclasses
12:43:02 <idnar> but you can do printf-like trickery
12:43:03 <chromakode> what about a record?
12:43:06 <idnar> er, Printf
12:43:19 <RayNbow> @faq Can Haskell stop my cat from limping?
12:43:20 <lambdabot> The answer is: Yes! Haskell can do that.
12:43:20 * hoopy is doing the last exercises in chapter 3 of RWH
12:43:49 <hoopy> some of them are easy and others seem like the material in no way prepares you for
12:43:54 * mauke is listening to Chumbawamba - On eBay
12:44:14 <gwern> isn't On eBay a weird al song?
12:44:23 <gwern> not chumbawamba, whomever that may be
12:44:27 <mauke> ah, the Knuth school of exercise writing
12:44:54 <hoopy> is there a function that's like the opposite of head?
12:45:02 <idnar> tail or last, depending on how you mean
12:45:02 <gwern> cons? :?
12:45:03 <mauke> gwern: http://www.youtube.com/watch?v=YbnGiXm02OY
12:45:09 <idnar> oh, that too
12:45:25 <idnar> > tail [1..10]
12:45:27 <lambdabot>   [2,3,4,5,6,7,8,9,10]
12:45:28 <idnar> > last [1..10]
12:45:29 <lambdabot>   10
12:45:52 <hoopy> er i mean the opposite of tail
12:45:57 <mauke> init
12:46:00 <hoopy> where it would return every value except the last
12:46:08 <idnar> > init [1..10] -- as mauke says
12:46:10 <lambdabot>   [1,2,3,4,5,6,7,8,9]
12:46:17 <hoopy> very nice, init is it
12:46:20 <chromakode> that was beautiful... 3 opposites to head
12:46:22 <hoopy> thank you
12:46:27 <chromakode> 4 opposites!
12:46:37 <idnar> chromakode: I only wish I could identify what kind of opposites they are
12:46:52 <chromakode> it's like the myth about eskimos and snow
12:47:21 <chromakode> idnar: perhaps that's why you're programming haskell
12:47:26 <idnar> heh
12:48:53 <StoneToad> chromakode: eskimos and snow?
12:49:22 <chromakode> StoneToad: you know, how it's fabled (but not true) that eskimos have around 20 words for snow...
12:50:17 <svat> http://en.wikipedia.org/wiki/Eskimo_words_for_snow :)
12:50:40 <idnar> what would the dual of head be?
12:51:22 <SubStack> @pl (\(a,b) (c,d) -> (b,a)`compare` (d,c))
12:51:23 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (flip (,)) . (((.) . (.) . compare) .) . flip (,))
12:51:29 <SubStack> right, not doing that
12:51:34 <mapreduce> idnar: last ?
12:51:38 <mapreduce> > last [1..10]
12:51:40 <lambdabot>   10
12:52:24 <chromakode> the problem is, is it more words we need, or more categories?
12:52:45 * mapreduce gets some context, and tells idnar to ignore that.
12:54:46 <Olathe> > tail [1..10]
12:54:48 <lambdabot>   [2,3,4,5,6,7,8,9,10]
12:54:59 <tirpen> can someone help me understand how this Cabal error message is even remotely possible?
12:55:04 <tirpen> cabal: dependencies conflict: ghc-6.10.1.20081208 requires process ==1.0.1.0
12:55:09 <ttt--> > tail "cat"
12:55:10 <lambdabot>   "at"
12:55:27 <tirpen> however process-1.0.1.0 was excluded because ghc-6.10.1.20081208 requires process == 1.0.1.1
13:03:47 <hoopy> http://hpaste.org/13147
13:07:15 <tirpen> whats wrong with "isPalindrome xs = reverse xs == xs"
13:07:37 <olsner> @pl \xs -> reverse xs == xs
13:07:37 <lambdabot> (==) =<< reverse
13:07:46 <hoopy> wow that's way more concise
13:07:53 * hoopy feels a bit dumb..
13:08:28 <tromp_> :t =<<
13:08:29 <lambdabot> parse error on input `=<<'
13:08:36 <tromp_> :t (=<<)
13:08:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:08:42 <olsner> #haskell :: [SourceLine] -> SourceLine
13:08:42 <svat> any time you're doing explicit recursion, there's a high chance you don't need it
13:09:24 <oklofok> ...explicit recursion?
13:09:34 * oklofok sees none
13:09:48 <tromp_> :t reverse >>= (==)
13:09:49 <svat> oklofok: I meant in the hpaste link
13:09:50 <lambdabot> forall a. (Eq a) => [a] -> Bool
13:10:09 <oklofok> svat: oh, thought you meant the point-freeification thing.
13:10:17 <olsner> oklofok: isPalindrome xs | (head xs) == (last xs)   = isPalindrome (init (tail xs))
13:11:13 <oklofok> olsner: thanks for that
13:11:23 <oklofok> ohh.
13:11:26 <oklofok> that was from the hpaste
13:11:28 <oklofok> right k
13:11:32 * oklofok shuts.
13:12:13 <tirpen> hoopy: Don't feel dumb, we've all reinvented enough wheels to build several dozen minibusses while learning Haskell. :)
13:12:15 <olsner> oklofok: back into the shadows of #esoteric from whence you came :P
13:12:40 <oklofok> ;;)
13:16:30 <hoopy> thanks for the encouragement
13:16:35 <Botje> tirpen: ooh. minibusses! (minibi?) are we going somewhere? are we? are we?!
13:18:51 <mm_freak> is there a pure alternative to 'yield'?
13:19:02 <dons> don't use cooperative threading?
13:19:41 <mm_freak> dons: if that's the only option?
13:20:01 <tehgeekmeister> is nesting case expressions okay?
13:20:33 <bd_> mm_freak: a pure yield would be indistinguishable (and thus equivalent) to ()
13:20:55 <bd_> you could probably implement cooperative multithreading with a sufficiently hairy pure monad though
13:21:34 <dons> ContT
13:21:48 <dons> mm_freak: the main point being that your question is weird.
13:21:52 <dons> :)
13:22:17 <mm_freak> bd_: my idea was something like:  pureYield `seq` y
13:22:20 <dons> you shouldn't be able to observe threading in pure code, so a pure yield is an odd request (though a bit like seq or par)
13:22:31 <dons> mm_freak: unsafePerformIO yield
13:22:35 <roconnor> dons: pick one of jeffwheeler's logos
13:22:51 <roconnor> after a bit more refinement
13:22:51 <mm_freak> dons: is that safe (in terms of stability)?
13:23:04 <bd_> dons: better: unsafeYield v = unsafePerformIO (yield >> return v)  -- preventing CSE, I hope
13:23:30 <mm_freak> bd_: unsafePerformIO yield `seq` â¦
13:23:50 <hoopy> i'm trying to do a > sortBy length [[1,2,3],[1],[1,2]]
13:23:53 <bd_> mm_freak: the compiler can take (unsafePerformIO yield), lift it to a global constant, and evaluate it only once
13:23:56 <bd_> (in theory)
13:24:02 <mauke> > sortBy (comparing length) [[1,2,3],[1],[1,2]]
13:24:03 <lambdabot>   [[1],[1,2],[1,2,3]]
13:24:11 <mm_freak> bd_: indeed
13:24:28 <hoopy> interesting
13:24:40 <hoopy> thank you
13:24:41 <bd_> mm_freak: why do you need this?
13:25:27 <birkenfeld> how would you update a map with two lists given, one containing keys and one corresponding values?
13:25:49 <SubStack> where is comparing defined anyways?
13:25:56 <bd_> @src comparing
13:25:57 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:26:01 <bd_> @hoogle comparing
13:26:02 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:26:02 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:26:10 <SubStack> cool beans
13:26:12 <Botje> birkenfeld: zip them together, fromList, union with other map
13:26:31 <mauke> :t M.insert
13:26:32 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
13:27:03 <birkenfeld> Botje: ah yes. that's better than my fold
13:27:18 <mm_freak> bd_: just curiousity
13:27:32 <mauke> foldl' (\z (k, v) -> M.insert k v z) map (zip ks vs)
13:27:34 <bd_> mm_freak: well, the operation rather fundamentally doesn't make much sense, so... :)
13:27:34 <hoopy> comparing not in scope
13:27:41 <hoopy> do i need to import Data.Ord as well?
13:27:49 <mauke> hoopy: yes
13:27:56 <bd_> pure operations are forbidden from interacting with other threads at all
13:28:02 <bd_> or with timing information
13:28:04 <dons> roconnor: which ones are jeff's?
13:28:13 <bd_> so unless you're messing with other unsafe operations, you'll never see any effect
13:28:32 <dons> oh, the \\= ones
13:28:51 <bd_> and as far as I know, there are no truly cooperative implementations of haskell threading - or are there?
13:29:03 <mm_freak> bd_: yeah, using OS threads
13:29:16 <bd_> which 'yeah' is that? :)
13:29:29 <mm_freak> yeah = yes =)
13:31:55 <roconnor> dons: ya http://media.nokrev.com/junk/haskell-logos/
13:32:19 <roconnor> I think it needs a few more iterations, but it is the right idea
13:32:20 <dons> yup
13:32:28 <dons> its interesting
13:32:57 <roconnor> > iterate (jeffwheeler =<< logo)
13:32:59 <lambdabot>   Not in scope: `jeffwheeler'Not in scope: `logo'
13:33:51 <ozy`> @pl iterate (jeffwheeler =<< logo)
13:33:51 <lambdabot> iterate (jeffwheeler =<< logo)
13:36:37 <Peaker> ozy`: is that the reader monad?
13:36:49 <Peaker> @type iterate
13:36:50 <lambdabot> forall a. (a -> a) -> a -> [a]
13:36:50 <ozy`> Â¯\O_o/Â¯
13:37:05 <ozy`> @type (=<<)
13:37:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:37:13 <Peaker> ozy`: otherwise, the result of =<< probably can't fit the first arg of iterate
13:37:32 <ozy`> Peaker: I see
13:38:13 <Peaker> @type (\x y -> x) >>= \f g -> g
13:38:15 <lambdabot> forall b. b -> b
13:39:49 <Peaker> @src (->) >>=
13:39:50 <lambdabot> Source not found.
13:39:53 <Peaker> @src (->) (>>=)
13:39:53 <lambdabot> f >>= k = \ r -> k (f r) r
13:45:34 <tehgeekmeister> http://hpaste.org/13149 <== have a parse error involving nested case expressions i can't resolve on my own
13:46:18 <mauke> tehgeekmeister: missing a "do"?
13:46:29 <tehgeekmeister> *looks
13:46:34 <Lemmih> tehgeekmeister: You need do's in the branches of the case.
13:46:40 <tehgeekmeister> ah, okay
13:46:43 <tehgeekmeister> *adds
13:46:46 <Peaker> SubStack: note that @pl does not always get the best possible PL notation -- with arrow combinators maybe that is nice-looking (a bit late reply, I know :-)
13:47:20 <Peaker> @pl (\(b,a) (d,c) -> (b,a)`compare` (d,c))
13:47:20 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (,) . (((.) . (.) . compare) .) . (,))
13:47:24 <tehgeekmeister> Lemmih: in all branches, or just the deepest ones?
13:47:41 <ozy`> tehgeekmeister: augh, long lines are long
13:47:47 <Lemmih> tehgeekmeister: In all branches where you have more than one statement.
13:47:57 <tehgeekmeister> oh!  right.
13:48:01 <tehgeekmeister> that makes perfect sense now.
13:48:15 <Peaker> @pl (\x y -> compare (swap x) (swap y))
13:48:15 <lambdabot> (. swap) . compare . swap
13:50:07 <hellige> Peaker: comparing $ uncurry $ flip (,)
13:50:28 <hellige> maybe?
13:51:00 <Peaker> > let swap = uncurry $ flip (,) in swap (5,6)
13:51:02 <lambdabot>   (6,5)
13:51:19 <Peaker> comparing swap
13:51:29 <Peaker> @hoogle swap
13:51:29 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
13:51:30 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
13:52:11 <Peaker> @type argument
13:52:13 <lambdabot> Not in scope: `argument'
13:52:24 <Peaker> @let argument f = (.f)
13:52:25 <lambdabot>  Defined.
13:52:27 <Peaker> @let result f = (f.)
13:52:28 <lambdabot>  Defined.
13:52:33 <Peaker> @type argument
13:52:34 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
13:52:40 <Peaker> (. swap) is now also: argument swap
13:53:10 <tehgeekmeister> http://hpaste.org/13149#a1 <== not sure quite how one handles recursion in the state monad, but what i'm trying to do should be fairly obvious now.
13:53:37 <hellige> @let f ~> g = argument f . result g
13:53:38 <lambdabot>  Defined.
13:53:55 <Botje> parseElement :: IO a -> State () a -> State () a
13:53:57 <Botje> woah
13:54:02 <Peaker> hellige: you're the guy with the ~> blog entry? Can't find that blog now..
13:54:05 <Botje> tehgeekmeister: that function is not going to fly i'm afraid
13:54:14 <tehgeekmeister> Botje: gahhh.
13:54:27 <Peaker> @type swap
13:54:28 <lambdabot> Not in scope: `swap'
13:54:33 <tehgeekmeister> Botje: just spent four hours straight on this...
13:54:35 <Peaker> @let swap = uncurry . flip $ (,)
13:54:36 <lambdabot>  Defined.
13:54:38 <Peaker> @type swap
13:54:39 <lambdabot> forall b a. (b, a) -> (a, b)
13:54:52 <Peaker> @type (compare ~> swap ~> swap ~> id)
13:54:53 <lambdabot> forall a b a1 b1 a2 b2. (Ord a) => ((((a -> Ordering) -> (b, a1)) -> (a2, b1)) -> b2) -> ((a -> (a1, b)) -> (b1, a2)) -> b2
13:54:58 <tehgeekmeister> Botje: what's wrong with it/what needs to be done differently?
13:54:59 <hellige> Peaker: yeah :)
13:55:03 <Peaker> @type (swap ~> swap ~> compare ~> id)
13:55:04 <lambdabot> forall b a b1 a1 b2 b3. (Ord b2) => ((((a, b) -> (b1, a1)) -> b2 -> Ordering) -> b3) -> (((b, a) -> (a1, b1)) -> b2) -> b3
13:55:14 <hellige> Peaker: http://matt.immute.net/content/pointless-fun
13:55:21 <Peaker> hellige: cool, thanks :)
13:55:30 <Botje> tehgeekmeister: to fix the parse error, you need to stop using tabs :)
13:55:40 <hellige> @type (swap ~> swap ~> id) compare
13:55:41 <lambdabot> forall b a b1 a1. (Ord ((b, a) -> (a1, b1))) => ((a, b) -> (b1, a1)) -> ((b, a) -> (a1, b1)) -> Ordering
13:55:48 <tehgeekmeister> Botje: the parse error is gone
13:55:49 <Peaker> @let ($.) = flip ($)
13:55:50 <lambdabot>  Defined.
13:56:06 <Botje> okay
13:56:14 <Peaker> hellige: I'm a little confused by the need to use ~> id there
13:56:16 <hellige> oh crud, how do you set fixity in lambdabot?
13:56:17 <Botje> if you're going to do IO anyway, use IORefs to keep state
13:56:27 <hellige> @infixr 2 ~>
13:56:28 <lambdabot> Unknown command, try @list
13:56:32 <hellige> hmm...
13:57:10 <tehgeekmeister> Botje: just updated it with my current error message
13:57:18 <Peaker> hellige: Can't, I think
13:57:50 <Botje> tehgeekmeister: what are you going to do with that state variable?
13:58:06 <Peaker> @let g <~ f = argument f . result g
13:58:08 <lambdabot>  Defined.
13:58:17 <athos> :t (~>)
13:58:19 <lambdabot> forall a a1 b c. (a -> a1) -> (b -> c) -> (a1 -> b) -> a -> c
13:58:26 <Peaker> @type (id <~ swap <~ swap) compare
13:58:28 <lambdabot> forall b a. (Ord b, Ord a) => (b, a) -> (b, a) -> Ordering
13:58:34 <Apocalisp> Haskell Curry: Enemy of the state.
13:58:41 <Peaker> hellige: simple workaround :)
13:58:55 <tehgeekmeister> Botje: as hexpat parses chunks of the xml, i add them to the appropriate segments of the current page variable, and at the end tag, i'll send that page element, now completely parsed, off to a db, but for now i'm just printing it
13:59:28 <tehgeekmeister> Botje: so the state variable is for accumulating the chunks from hexpat into my data type
14:00:04 <Botje> tehgeekmeister: okay, then you need to explicitly pass that state variable everywhere in parseElement, possibly with modifications
14:00:23 <hellige> Peaker: ha, nice. :)
14:00:28 <Peaker> tehgeekmeister: it can be a little more readable if you compile with -Wall and add the inferred types to the paste
14:00:35 <hellige> Peaker: so do you see why you need the id?
14:01:46 <Peaker> hellige: so it applies to arguments, rather than the final result?
14:01:51 <tehgeekmeister> Botje: if i update the state with put/modify, i can just re-read the state, right?  i don't have to do all the modifications to the state on the line where i'm passing it to parseElement, right?
14:01:55 <Peaker> hellige: s/id/something-to-apply-to-actual-final-result ?
14:02:00 <ozy`> @type (-->)
14:02:01 <lambdabot> parse error (possibly incorrect indentation)
14:02:21 <hellige> Peaker: yeah, basically
14:02:37 <hellige> but s/actual-final-result/tail-of-the-function-type/
14:02:41 <hellige> because they're curried, right?
14:02:46 <hellige> so you have a function like:
14:02:50 <Peaker> hellige: its very neat.. It seems rather "basic" discoveries about PL style are still being made -- maybe it can be so much more readable..
14:02:50 <hellige> a -> b -> c -> d -> e
14:03:01 <hellige> i can do: f ~> g ~> id
14:03:11 <hellige> where the "id" applies to the function "c -> d -> e"
14:03:28 <hellige> and of course it doesn't have to be id... you could do:
14:03:35 <hellige> id ~> id ~> flip
14:03:42 <Peaker> hellige: yeah, pretty awesome :)
14:03:48 <hellige> @ty flip <~ id <~ id
14:03:49 <lambdabot> forall a b c a1 a2. (a2 -> a1 -> a -> b -> c) -> a2 -> a1 -> b -> a -> c
14:04:03 <Botje> tehgeekmeister: unfortunately, your parseElement function is in the IO monad, not the State monad
14:04:04 <Peaker> hellige: do you think generalizing this to Functor/Cofunctor would be useful?
14:04:11 <Beelsebob> http://www.aegisub.net/2008/12/if-programming-languages-were-religions.html <-- I think we should be proud of being Tau Buhdism
14:04:31 <tehgeekmeister> Botje: bah!  every time i've tried to make something in the state monad that ends up happening.
14:04:35 <Peaker> hellige: or do you think it could be generalized to arrows maybe?
14:04:37 <hellige> Peaker: could be: i feel like it should generalize *somewhere*, but i'm not sure of the right place
14:04:47 <Botje> tehgeekmeister: luckily, there's the StateT monad transformer
14:04:52 <Botje> hang on, i'll annotate your paste
14:04:52 <Peaker> @type (~>)
14:04:54 <lambdabot> forall a a1 b c. (a -> a1) -> (b -> c) -> (a1 -> b) -> a -> c
14:04:54 <hellige> Peaker: i thought of arrows, applicative, but i haven't thought hard about any of the options.
14:05:07 <RayNbow> hmm, anyone here having experience with teaching ADTs to Haskell newbies?
14:05:23 <hellige> Peaker: i'd love to see it generalized. if you come up with something, please share!
14:05:45 <jeffwheeler> I wonder what could be categorized as atheism?
14:05:45 <lambdabot> jeffwheeler: You have 1 new message. '/msg lambdabot @messages' to read it.
14:05:48 <Peaker> hellige: Maybe: (~>) :: Arrow arr => arr a a1 -> arr b c -> arr a1 b -> arr a c ?
14:06:02 <jeffwheeler> (Which language, that is.)
14:06:05 <Peaker> hellige: (Just directly translating)
14:06:31 <hellige> Peaker: yeah, that's the obvious thing to try. i haven't even tried it.
14:06:50 <hellige> Peaker: actually, it only depends on (.), which is defined for Category.
14:06:59 <Botje> tehgeekmeister: http://hpaste.org/13149#a3
14:07:00 <hellige> Peaker: so maybe that's the most general place.
14:07:15 <Peaker> @hoogle (.)
14:07:15 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
14:07:15 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
14:07:15 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
14:07:21 <RayNbow> GADT syntax seems to be easier for Haskell newbies... anyone with a similar experience?
14:07:25 <Peaker> lambdabot is still 6.8
14:07:26 <hellige> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Category.html#v:Category
14:07:29 <hellige> ah
14:07:33 <Botje> oh, and you can drop the state argument now :)
14:07:55 <Botje> so parseElement :: IO a -> StateT ParserState (IO a)
14:07:58 <Peaker> hellige: I have an unbased opinion/hypothesis that the true goodness of PL comes from the generalization we might one day realize if we go far enough down that road :)
14:08:24 <hellige> Peaker: i wouldn't say i have even a hypothesis, but i have a hope. ;)
14:08:42 <Botje> sigh, and lift $ print st
14:08:45 <Botje> silly me.
14:09:09 <Peaker> @undefine (~>)
14:09:27 <Peaker> @let (f ~> g) x =  f >>> x >>> g
14:09:28 <lambdabot>  Defined.
14:09:34 <Peaker> @type (~>)
14:09:35 <lambdabot> forall (a :: * -> * -> *) b c c1 d. (Arrow a) => a b c -> a c1 d -> a c c1 -> a b d
14:09:55 <Peaker> hellige: that's the trivial arrowization
14:10:19 <Botje> tehgeekmeister: still there?
14:11:15 <tehgeekmeister> Botje: so the main difference is adding those two imports, and lifting all io stuff?
14:11:33 <Botje> tehgeekmeister: yeah.
14:11:34 <Peaker> hellige: I am trying to understand the relationship between Category and Functor (different kinded, but (.) and fmap are in fact equal?)
14:11:44 <Botje> now you _ARE_ in a State monad, while still retaining the capability to do IO
14:11:47 <athos> @hoogle getArgs
14:11:48 <lambdabot> System.Environment getArgs :: IO [String]
14:12:12 <Botje> but you have to lift it "through" the StateT monad back to IO
14:12:32 <Botje> tehgeekmeister: the reason i couldn't just rewrite your code was because of that getChunk, which is an IO action
14:12:41 <Botje> and you can only do IO inside an IO monad
14:12:55 <hellige> Peaker: that arrow definition is very pretty, too.
14:12:57 <mmorrow> @quote eax
14:12:58 <lambdabot> No quotes match. :(
14:13:01 <hellige> Peaker: i like it.
14:13:04 <Botje> but your function also needed a State part, which IO doesn't provide by default
14:13:05 <mmorrow> @quote rax
14:13:06 <lambdabot> No quotes match. Wrong!  You cheating scum!
14:13:11 <mmorrow> @quote jsn
14:13:11 <lambdabot> No quotes match. You untyped fool!
14:13:15 <Botje> (and i think can't provide in general)
14:13:36 <mmorrow> preflex: seen erikc
14:13:36 <preflex>  erikc was last seen on #haskell 16 hours, 14 minutes and 30 seconds ago, saying: i like cale's last logo with the stars
14:13:52 <hellige> Peaker: not sure what you mean about Category and Functor.
14:13:54 <hellige> ?
14:14:07 <Peaker> hellige: well:    f >>> x >>> g   and:   fmap (fmap f) (flip fmap g)  should be equal, for the function case, right?
14:14:26 <m4dc4p> I'm trying to call some Haskell code from C and having trouble getting simple examples to work - anyone willing to help?
14:15:01 <m4dc4p> Following directions at http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
14:15:14 <mmorrow> @msg erikc haskell-src-exts changed a lot more than i thought, so it's going to take me longer than i thought to update src-meta, but it's coming along.
14:15:15 <lambdabot> Not enough privileges
14:15:19 <Peaker> hellige: flip fmap on function and (>>>) on function are equal -- I wonder if this is not true for all Category classes, using their Functor instance for open type-variables?
14:15:20 <mmorrow> @tell erikc haskell-src-exts changed a lot more than i thought, so it's going to take me longer than i thought to update src-meta, but it's coming along.
14:15:21 <lambdabot> Consider it noted.
14:15:52 <hellige> Peaker: i see.
14:15:59 <Peaker> hellige: for example,  (->) is *->*->* and is an Arrow instance, has (>>>).  (r->) is *->* and is a Functor instance, and has an equal fmap.  I wonder if that is true for all non (->) as well
14:16:14 <Peaker> hellige: and if it is always true - I wonder if it is possible to generalize it somehow so you don't have to define both instances
14:16:17 <mauke> m4dc4p: what's the problem?
14:16:27 <hellige> Peaker: right... good question.
14:16:28 <m4dc4p> mauke: i get garbage like this http://hpaste.org/13150
14:16:35 <hoopy> http://hpaste.org/13151
14:16:35 <Peaker> hellige: and that code that uses one or the other is just as general, too
14:17:00 <hellige> so basically, the question is, given an arrow a
14:17:05 <m4dc4p> mauke: my command line is "ghc -no-hs-main Test.c Test.o Test_stub.o -o Test.exe"
14:17:15 <m4dc4p> windows vista, ghc 6.8.3
14:17:28 <hellige> is partial application "a b" always a functor? and if so, does this relationship always obtain?
14:18:01 <Peaker> hellige: My hunch is that yes - at least with the arrow-as-computation interpretation
14:18:39 <hellige> Peaker: i think that's right.
14:18:40 <tehgeekmeister> Botje: http://hpaste.org/13149#a4 <== new errors after incorporating those changes
14:18:41 <mauke> hoopy: ?
14:19:08 <hellige> Peaker: the Category class models categories as a map from objects to arrows
14:19:09 <Botje> tehgeekmeister: yeah, drop the state argument in the parseElement definition
14:19:11 <hoopy> i think it's complaining about me returning "" in that
14:19:12 <Botje> it's no longer needed
14:19:17 <mauke> hoopy: yes
14:19:18 <Peaker> hellige: Maybe class aliases can do that too
14:19:41 <hoopy> the book says intersperse should have the type :: a -> [[a]] -> [a]
14:19:45 <Peaker> hellige: What are "objects"? I don't know much CT at all
14:19:46 <Botje> tehgeekmeister: as for the second error, either do something with the result of that runStateT, or add >> return ()
14:19:53 <hoopy> and it should behave in such a way that it returns "" when the second arg is []
14:20:02 <hellige> well, a category is a collection of objects, and a collection of arrows.
14:20:04 <mauke> hoopy: no
14:20:13 <hellige> hellige: with a few axioms
14:20:22 <mauke> hoopy: it should return [] when the second arg is []
14:20:30 <hoopy> > "" == []
14:20:31 <lambdabot>   True
14:20:32 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
14:20:36 <lunabot>  [AP,Constr]
14:20:46 <hellige> Peaker: basically, each object has an identity arrow
14:20:54 <mmorrow> , let x = 1 + 1 in [isFullyEvaluated x, x `seq` isFullyEvaluated x]
14:20:58 <lunabot>  [False,True]
14:21:01 <Peaker> hellige: is that the endofunctor?
14:21:04 <Botje> tehgeekmeister: the path to learning monads is paved with type errors
14:21:10 <mmorrow> heh
14:21:11 <Botje> after a while you notice you start making them less and less :)
14:21:12 <hellige> Peaker: no, functors are a bit different.
14:21:21 <tehgeekmeister> Botje: so i've noticed.
14:21:25 <hellige> Peaker: id is an automorphism.
14:21:30 <jeffwheeler> I'm trying to get a PGM image for Ch. 10 of RWH, but all I can find is an ASCII representation of all the digits.
14:21:40 <jeffwheeler> In the example between <PRE>s, here: http://netpbm.svn.sourceforge.net/viewvc/netpbm/userguide/pgm.html?revision=547&view=markup
14:21:45 <hoopy> okay well it compiles now but i don't really know why it will with [] and not ""... i thought they were synonymous
14:21:48 <Peaker> hellige: is it literally id? Useful only as a "place-filler" to avoid actual transformation?
14:21:51 <hellige> Peaker: if the objects of our category are THEMSELVES categories, then id is an endofunctor
14:21:52 <jeffwheeler> What's the easiest way to take that list of integers and create the binary file?
14:21:53 <tehgeekmeister> Botje: where would i add the >> return ()
14:21:58 <Botje> hoopy: "" restricts the type to [Char]
14:22:02 <mauke> hoopy: no, "" :: [Char] while [] :: [a]
14:22:08 <Botje> tehgeekmeister: forkIO (runStateT (...) (...) >> return ())
14:22:12 <mmorrow> jeffwheeler: use Data.Binary
14:22:15 <hellige> Peaker: depends on what you mean by "literally id"
14:22:25 <hoopy> a
14:22:25 <hellige> Peaker: it is *defined* to be id, based on its role in the axioms
14:22:32 <hellige> Peaker: it is an identity for composition
14:22:39 <Peaker> hellige: Well, I guess I ought to learn some more CT, first (but I have too much on my read queue, and managed to learn the abstract Haskell stuff without it, so far :-)
14:22:47 <hoopy> that does make sense that "" would imply Char instead of a...
14:22:53 <hellige> Peaker: yeah, i would learn a bit of CT when you have time.
14:22:55 <jeffwheeler> mmorrow: is there no way with just something like 'cat' through 'od' or something, to write the file? The chapter discusses how to read it once that's done.
14:23:12 <hellige> the relationship you're asking about between Arrow (or Category) and Functor will have a clear answer in CT
14:23:15 * JohnnyL had a dream last night of someone asking me to draw the lambda symbol. I drew it like Chinese caligraphy and put an extra line going through it (like the letter A).
14:23:45 <mmorrow> jeffwheeler: well i guess you could showHex and (++) the resulting strings together (would have to chop the "0x" off)
14:23:45 <Peaker> hellige: Category seems to just be the class that has only (>>>) and what used to be (arr id) in it...
14:23:50 <mmorrow> , showHex 42
14:23:52 <lunabot>  luna: No instance for (GHC.Show.Show
14:23:52 <mmorrow> , showHex 42 []
14:23:54 <lunabot>  "2a"
14:24:00 <mmorrow> ah, no "0x"
14:24:00 <Peaker> hellige: (subset of Arrow's functionality)
14:24:03 <hellige> Peaker: just has "id" and (.)
14:24:11 <hellige> Peaker: which is basically the definition of a category in CT
14:24:16 <mauke> > ""++ printf "%#x" 42
14:24:17 <lambdabot>   "* Exception: Printf.printf: bad formatting char #
14:24:23 <mauke> Text.Printf--
14:24:24 <hellige> Peaker: a category is a collection of objects, and a collection of arrows
14:24:24 <mmorrow> , concatMap (flip showHex []) [0..20]
14:24:26 <lunabot>  "0123456789abcdef1011121314"
14:24:30 <Peaker> hellige: Ah okay.  Well, surely the Functor relationship is there then
14:24:35 <hellige> Peaker: each object has an id : a -> a
14:24:42 <mmorrow> err, you'd have to insert 0's in there too
14:24:44 <hellige> Peaker: and arrows can be composed (.) when the types make sense.
14:24:51 <mmorrow> i'd really just use Data.Binary
14:24:55 <mmorrow> it's way easy
14:25:01 <hellige> Peaker: the composition must be associative, and id must be an identity on both sides of composition.
14:25:09 <hellige> Peaker: that's basically the whole definition of a category
14:25:19 <Peaker> hellige: Monoid'ish (except more lenient with types)
14:25:31 <mmorrow> make a function :: Int -> [Word8]  (with your preferred endianness)
14:25:40 <hellige> Peaker: now, in CT, a functor is a map *between* categories. it maps both arrows and objects, and it must preserve identities and composition.
14:25:48 <mmorrow> and  pack . concatMap myIntToWord8s $ [0..]
14:26:05 <Peaker> hellige: I know those laws in their simplish Haskell notation :)
14:26:24 <hellige> Peaker: right, there won't be surprises there for a haskell programmer. :)
14:26:56 <Peaker> hellige: I think a CT background may ease learning Haskell, but learning the Haskell stuff directly and not via learning CT first is a minor shortcut I'm taking :)
14:27:02 <hellige> Peaker: try writing "instance Category cat => Functor (cat a) where..."
14:27:18 <hellige> Peaker: my suspicion is that it will work out, but i haven't given it much thought.
14:27:30 <hellige> Peaker: that's the route i've taken so far as well.
14:27:40 <mmorrow> jeffwheeler: that method i guess  doesn't even need Data.Binary (but you'd want it for reading the data in)
14:27:41 <hellige> Peaker: i tried a bit of CT earlier, and couldn't get my head around it.
14:27:53 <hellige> Peaker: i think the route through haskell is a very good idea.
14:28:05 <mmorrow> jeffwheeler: and Data.Binary has functions to encode Ints for you
14:28:06 <jeffwheeler> mmorrow: I don't think Haskell should even be necessary for what I'm trying to do.
14:28:18 <jeffwheeler> mmorrow: I'm just trying to create the file that I'll later play with.
14:28:23 <mmorrow> jeffwheeler: heh
14:28:45 <mmorrow> oh, so you mean "cat | od" /literally/
14:29:06 <mmorrow> yeah, i'd go for something like that
14:29:09 <jeffwheeler> mmorrow: exactly, but those two won't do the trick. I have the list of byte values, and I need to create the file from that.
14:29:28 <mmorrow> oh, so you're already /in/ haskell
14:29:35 <jeffwheeler> Alternatively, perhaps somebody has an actual PGM file that they used in that chapter. :P
14:29:38 <mmorrow> Data.Binary
14:29:43 <jeffwheeler> mmorrow: no, no I'm not.
14:29:48 <mmorrow> oh, hmm
14:29:54 <mmorrow> what is this "list"
14:30:03 <mmorrow> a file?
14:30:05 <jeffwheeler> mmorrow: when I say "list", I mean the big table in the page I linked to: 24 7
14:30:06 <jeffwheeler> err
14:30:11 <jeffwheeler> http://netpbm.svn.sourceforge.net/viewvc/netpbm/userguide/pgm.html?revision=547&view=markup
14:30:17 * mmorrow looks
14:30:22 <jeffwheeler> starting on line 137
14:30:33 <Peaker> hellige: I don't think that instance works, because   fmap :: (a -> b) -> ...     and (a -> b) is useless in the general Category class
14:30:39 <mauke> jeffwheeler: that's a valid pgm file. why do you need to convert it?
14:30:56 <Peaker> hellige: Even (f a -> f b) is not very useful, we need a category/arrow, not a Haskell function
14:31:16 <jeffwheeler> mauke: because I need to turn those digits into actual bytes of a file.
14:31:18 <hellige> Peaker: ah, yeah, i see.
14:31:34 <mauke> jeffwheeler: why?
14:31:58 <Peaker> hellige: The latter statement may be bollocks though I still think (a->b) is not usable
14:32:12 <mmorrow> jeffwheeler: this may help fwiw http://haskell.org/haskellwiki/Library_for_PPM_images
14:32:16 <jeffwheeler> mauke: i.e. I have the byte values, but how do I make a file from that? If I just save that as a file, it'll be ASCII digits '2' then digit '4', etc.; it should be one byte that holds "24".
14:32:25 <hellige> Peaker: yeah, i need to think about it a bit more
14:32:33 <mauke> jeffwheeler: no, it shouldn't
14:33:07 <jeffwheeler> Err, really? That seems awful odd, considering they said it was a binary file.
14:33:13 <jeffwheeler> That would be entirely ASCII.
14:33:18 <mauke> jeffwheeler: what are you even talking about?
14:33:26 <jeffwheeler> mauke: Chapter 10 from RWH.
14:33:37 <jeffwheeler> Except they don't cite where to get a PGM image to work with . . .
14:33:59 <mauke> A file of either format starts with a header, which in turn begins with a âmagicâ string describing the format. For a plain file, the string is P2, and for raw, it's P5. The magic string is followed by white space, then by three numbers: the width, height, and maximum grey value of the image. These numbers are represented as ASCII decimal numbers, separated by white space.
14:35:11 <jeffwheeler> mauke: ah, you're correct for those first few digits. Unfortunately, that's not true for the rest of the file: "In a raw file, this is a string of binary values."
14:35:19 <mauke> jeffwheeler: http://www.ioccc.org/2000/lavabus.pgm
14:35:21 <jeffwheeler> mauke: and it then works with raw files.
14:35:23 <athos> > ['a'..'z]
14:35:24 <lambdabot>   <no location info>:
14:35:24 <lambdabot>      lexical error in string/character literal at chara...
14:35:29 <Peaker> hellige: There are some things Functors can do and Categories can't (e.g free Haskell functions that get access to the actual value inside)..  Maybe there's a reverse transformation (e.g Kleisly) to define categories from Functor?
14:35:30 <athos> > ['a'..'z']
14:35:31 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
14:35:33 <jeffwheeler> mauke: that'll work; thanks. :)
14:35:51 <mauke> http://www.ioccc.org/2000/michael.pgm
14:36:28 * thoughtpolice yawns
14:36:40 <olsner> why ioccc.org?
14:36:46 <mmorrow> jeffwheeler: there's code that makes a String that's a PGM in here: http://perception.inf.um.es/~aruiz/darcs/hmatrix/lib/Graphics/Plot.hs
14:36:53 <mauke> because they have pgm files
14:37:15 <jeffwheeler> mmorrow: thanks
14:37:40 <jeffwheeler> RWH ought to suggest where to find some that are already raw. :)
14:37:40 <tehgeekmeister> Botje: http://hpaste.org/13149#a6 <== new error message that i don't understand whatsoever
14:38:57 <Botje> tehgeekmeister: forkIO (runStateT (parseElement (takeMVar mvar)) (ParserState [] Nothing) >> return ())
14:39:03 <Botje> that's how the line should read
14:43:07 <chrisdone> â¥â¤â¥Applicativeâ¤â¥â¤ http://hpaste.org/13154
14:43:52 <EvilTerran> chrisdone, indeed :)
14:44:14 <august> http://www.aegisub.net/2008/12/if-programming-languages-were-religions.html
14:45:33 <Peaker> I think maybe instead of <$> its nicer to use   pure f <*> ...   so even the first arg looks the same way as the rest?
14:46:07 <Peaker> though OTOH, <$> allows it to be Functor for the special 1-arg case, so maybe not
14:47:53 <drdozer> I'm having a bit of trouble with indexed types
14:48:56 <chrisdone> august: I like how they summed up the oldest, third most followed religion in the world by comparing it as "It's another strange language that doesn't look like it could be used for anything, but unlike most other modern languages, it's built around the concept of multiple simultaneous deities."
14:49:20 <chrisdone> basically, "I don't know anything about this religion"
14:49:34 <august> yeah
14:49:39 <august> that one was a stretch
14:49:52 <august> could have easily said it was the greek religion
14:50:33 <tehgeekmeister> Botje: okay, i'm down to semantic errors only now.  i can figure those out on my own.  thanks!  =D
14:50:43 <chrisdone> first couple were okay, then they get shorter and irrelevant :P
14:50:48 <mauke> jeffwheeler: http://mauke.ath.cx/stuff/perl/binarize.pl
14:51:04 <jeffwheeler> mauke: :)
14:51:15 <jeffwheeler> Got to go, for now. Later.
14:51:17 <Botje> tehgeekmeister: no problem, have fun! :)
14:51:22 <august> i liked the ruby and python ones
14:52:07 <Japsu> @index uncurry4
14:52:08 <lambdabot> bzzt
14:52:10 <Japsu> ;(
14:52:18 <Botje> awww :p
14:52:51 <eu-prleu-peupeu> hey Hppl
14:52:52 <eu-prleu-peupeu> 'sup ?
14:53:00 <eu-prleu-peupeu> lots of new logos popping :)
14:53:02 <eu-prleu-peupeu> thats sweet
14:54:01 <Peaker> hellige: http://hpaste.org/13155
14:54:08 <Peaker> hellige: Trying to create a Functor => Category adapter
14:54:35 <Peaker> But GHC is not cooperating, claiming that I have an infinite type construction there, though my GADT is supposed to prevent that
14:54:52 <Holle_> colors = [ Blue , Green , Cyan , Red , Magenta , Yellow , White ]
14:54:54 <Holle_> c <- (colors !! ((randomRIO (0,6)) :: IO Int))
14:55:21 <Holle_> i want to get a random element of a list. what should i do?
14:55:27 <mauke> !! takes an Int, not an IO Int
14:55:30 <hoopy> does randomization imply side effects?
14:55:36 <Peaker> if my GADT looks like:   data EL f input output where ELID :: EL f a a --      then uses of ELID do assume that these types will be equal, right?
14:55:51 <mauke> i <- randomRIO (0,6); let c = colors !! i
14:55:56 <Holle_> Int != IO Int that's my problem
14:56:52 <chrisdone> ugh, why has Linus's year-old rant about C++ been *reposted* to reddit, and is actually at the top, with tonnes of comments? what the hell?
14:57:11 <mauke> haha
14:57:18 <lament> because nobody likes C++
14:57:24 * mauke watches the web trolling itself
14:57:34 <chrisdone> haha
14:57:47 <august> chrisdone: but perl is pure voodoo
14:58:00 <chrisdone> august: true enough
14:58:03 <Holle_> works :)
14:58:06 <Holle_> thank you!
14:58:34 <Peaker> hmm - I don't understand why the types don't add up in: http://hpaste.org/13155#a1
14:59:03 <lament> chrisdone: you mean it's okay to be ignorant about voodoo, but not about hinduism?
14:59:57 <Holle_> and why won't work: c <- (colors !! (randomRIO (0,6))
15:00:03 <int-e> Peaker: fmap after (before x) is of type a -> f (f b) instead of a -> f b
15:00:13 <int-e> Peaker: err, \x ->  that.
15:00:23 <chrisdone> lament: Informal: Usually Disparaging. characterized by deceptively simple, almost magical, solutions or ideas: voodoo politics.
15:00:23 <Peaker> int-e: its complaining about: ELID . x = x
15:00:31 <Cale> Peaker: I don't think it is.
15:00:38 <mauke> Holle_: !! takes an Int, not an IO Int
15:00:41 <int-e> Peaker: yes, but that's not the faulty line
15:00:42 <chrisdone> lament: you don't see me saying "man this code I looked at was pure hindu"
15:00:48 <Peaker> oh, that's damn confusing :)
15:00:58 <Holle_> is i not an IO Int?
15:00:59 <Peaker> int-e, Cale: thanks
15:01:01 <mmorrow> Holle_: c <- (colors !!) `fmap` randomRIO (0,6)
15:01:04 <mauke> Holle_: no, i is an Int
15:01:12 <mmorrow> Holle_: c <- (colors !!) `liftM` randomRIO (0,6)
15:01:14 <hellige> Peaker: i still think it should go the other way.
15:01:17 <Holle_> but takes an IO Int?
15:01:20 <mmorrow> Holle_: c <- return . (colors !!) =<< randomRIO (0,6)
15:01:23 <drdozer> http://pastebin.com/m4916b609
15:01:26 <hellige> i think Category cat => Functor (cat a)
15:01:28 <Cale> Peaker: are you looking for the Kleisli category?
15:01:33 <mmorrow> Holle_: (those are all equivalent)
15:01:43 <hellige> but i'm not sure it's true, nor am i sure you can write it in haskell.
15:01:45 <Peaker> Cale: I'm looking for a Kleisly-like transformation from Functors to Control.Category
15:01:48 <lament> chrisdone: so? voodoo is a real religion, and the list is comparing languages to real religions
15:01:58 <Holle_> mmorow: thanks!
15:01:59 <mauke> Holle_: x <- IO x (not real code, just looking at the types)
15:02:01 <Cale> Peaker: If you had join, then you could define that composition the way you're after
15:02:06 <chrisdone> lament: so I mean it's okay for august to say perl is voodoo, irrelevant to the list, most of which ignorant
15:02:15 <mauke> Holle_: the variable on the left gets whatever the IO thing on the right returns
15:02:18 <Cale> Peaker: With just any functors, it's not possible
15:02:28 <Peaker> hellige: Well, Monad -> Category is a piece of cake, Kleisly converts to arrows, and category is a subset of arrow
15:02:32 <Peaker> oops
15:02:33 <Holle_> and IO x returns x
15:02:36 <Peaker> Cale: that was to you
15:02:36 <drdozer> so I'm not sure what I should have done to make this work
15:02:47 <mauke> (i :: Int) <- (randomIO (0,6) :: IO Int)
15:02:59 <hellige> Cale: what do you think, should Category cat => Functor (cat a) in haskell?
15:03:04 <drdozer>  i was assuming that the type indexing would make 'Scope IntBinOp' a synonym for 'Int'
15:03:06 * ddarius likes C++.
15:03:12 <Peaker> Cale: me and hellige were just discussing the possible relationship between Category's (.) and Functor's fmap -- what do you think the relationship between these 2 type-classes is?
15:03:18 <chrisdone> lament: (no, I don't agree that perl is comparable to the voodoo religion)
15:03:35 <Cale> hellige: yes, I think so
15:03:45 <hellige> seems like we represent categories by their hom-functor, and for C, we should have C(a,_) is a functor.
15:03:54 <hellige> but i'm not sure how to write it...
15:04:02 <Peaker> hellige: When you say => do you mean Functor is a more-expressive subclass that needs to be implemented, or that it is less expressive and can be instantiated?
15:04:15 <hellige> and revsiting the usual definition of hom-functor, i'm confused by what seems like some sloppiness in composing arrows.
15:04:25 <Peaker> hellige: IOW, do you mean  instance Category cat => Functor (cat a)     or   class Category cat => Functor (cat a)  [not expressable in Haskell]
15:04:38 <Cale> In fact, even without Control.Category, I'd suggested (.) = fmap for a long time.
15:04:43 <hellige> Peaker: less expressive and can be instantiated. "instance Category cat => ..."
15:04:45 <thoughtpolice> drdozer: you're confused; you are using associated data types, so when you say "data Scope IntBinOp = Int" you are actually making a *datatype* called Scope which has one constructor called 'Int'
15:05:13 <hellige> Cale: i thought i remembered someone arguing for that, yeah...
15:05:16 <rastar> when compiling ghc on my box i run into the following error
15:05:18 <rastar>     Could not find module `Data.Generics':
15:05:21 <thoughtpolice> drdozer: if you want synonyms, you need to use type synonyms
15:05:24 <rastar>   it is a member of package base-3.0.3.0, which is hidden
15:05:39 <drdozer> thoughtpolice: ah - I should have said: type Scope IntBinOp = Int?
15:05:47 <thoughtpolice> drdozer: so that you can say 'f :: Scope Foo; f = 1' where Scope Foo = Int
15:05:52 <hellige> Cale: so, can we write an instance like that?
15:05:52 <mmorrow> rastar: add the dep "syb" to the build-depends: in the .cabal of whichever package is failing with that msg
15:05:52 <Cale> I think we should have two names for functor application, and they should be map and (.)
15:06:01 <Peaker> hellige: Ah, I think Functor is more expressive.  Consider the Category of Arrows-without-arr -- surely you cannot use a pure function (b->c) to convert  Arrow arr => arr a b    to Arrow arr => arr a c
15:06:10 <thoughtpolice> drdozer: you need to change the declaration of the Scope class as well
15:06:30 <Cale> hellige: Without horribly overlapping with everything?
15:06:33 <thoughtpolice> drdozer: from 'data Scope op' to 'type Scope op'
15:06:36 <mmorrow> rastar: (it'll be in ghc/libraries/)
15:06:42 <Peaker> hellige: you don't get to have pure-function access to internal arrow data
15:06:49 <drdozer> cheers thoughtpolice :) It does exactly what I want now
15:06:53 <thoughtpolice> np
15:06:55 <hellige> Cale: well, no, just in principle. ;)
15:07:02 <thoughtpolice> type families are super cool
15:07:06 <Peaker> hellige: so either Functor is more expressive, or its neither more nor less expressive (just some overlap)
15:07:07 <drdozer> first time with this stuff, but it is brilliant stuff
15:07:07 <hellige> Cale: i can see how to do it with Arrows-with-arr
15:07:15 <hellige> Cale: but not with only Category (id and (.))
15:07:36 <Cale> In principle, yes. But the openness of typeclasses makes it impossible to do instance selection based on other instances.
15:07:38 <hellige> Peaker: well, right, that's the whole question
15:07:48 <hellige> Peaker: the usual definition of hom-functor in CT does exactly that.
15:07:55 <hellige> Peaker: http://en.wikipedia.org/wiki/Hom-functor
15:08:20 <Peaker> hellige: Well, your instance assumes Functor expressiveness is <= that of Category, but it definitely isn't...
15:08:25 <hellige> they say: Hom(A,-) maps each morphism f:X -> Y to the function given by g |-> f . g for each g...
15:08:39 <chessguy> 'ello
15:08:44 <hellige> but this seems to be composing morphisms in two distinct categories...
15:09:11 <Cale> Yeah, we need to generalise Functor
15:09:24 <mmorrow> we need a Cofunctor as well :)
15:09:25 <Cale> You don't really want Category c => Functor (c a)
15:09:31 <Pseudonym> We need typeclass synonyms.
15:09:34 <hellige> they compose the arrow f:X -> Y in te category C with the map g in Set.
15:09:35 <Cale> You want  Category c => Functor c (c a)
15:09:48 <Pseudonym> Constantly annoyed by this.
15:09:53 <hellige> Cale: what do you think of the wikipedia definition? does that seem as bizare to you as to me?
15:09:59 <Cale> hellige: which one?
15:10:16 <Peaker> Cale: what would that Functor typeclass mean?
15:10:20 <Cale> Hom functor?
15:10:25 <ddarius> hellige: f : X -> Y means f â Hom(X,Y)
15:11:05 <ddarius> Composition is (for locally small categories) a (partial) set function on hom-sets.
15:11:08 <hellige> ddarius: how can it? we're trying to define the action of Hom(X,-) on morhpisms...
15:11:33 <hellige> they say: Hom(A,â) maps each morphism f : X â Y to the function ...
15:11:45 <Pseudonym> Cale: I think it would make more sense to rename Functor to be EndoFunctor.
15:11:47 <hellige> so f must be an arrow in C, mustn't it?
15:11:57 <Cale> Pseudonym: yeah.
15:11:58 <ddarius> Yes.
15:12:06 <Pseudonym> Then we keep it as is.
15:12:10 <Cale> Pseudonym: (Or Endofunctor ;)
15:12:15 <Pseudonym> Whatever, yes.
15:12:17 <hellige> so then, later in the definition, they compose it with g, a set function.
15:12:42 <hellige> in order to define Hom(X,f) as f . g (for g in Hom(A,X))
15:12:44 <ddarius> Then we can also have ContravariantEndoFunctor.
15:12:50 <hellige> but i don't understand how f and g are composable at all.
15:13:00 <ehird> Hm.
15:13:01 <ddarius> hellige: g is not a set function.
15:13:12 <ddarius> g is an element of a hom-set, just like f.
15:13:40 <hellige> ddarius: eureka! i see.
15:13:41 <drdozer> oh, these type index things are brill
15:13:41 <Cale> hellige: Let g be in Hom(A,X) and f is in Hom(X,Y), you can compose them to get something in Hom(A,Y)
15:13:43 <hellige> thanks!
15:13:56 <Peaker> hellige, Cale: Okay, at least I managed to get: instance Applicative f => C.Category (EL f) where ...
15:14:11 <hellige> Cale: back to the main point, i agree that i want Functor c (c a)
15:14:14 <Peaker> Cale, hellige: Does the Kleisli arrow convert only monads to arrows, or also applicatives?
15:14:20 <hellige> and that basically, that's the whole problem.
15:14:31 <hellige> for Arrow, arr basically solves it.
15:14:41 <Cale> I'm still not totally convinced that Control.Category is a useful place to put (.)
15:14:52 <ddarius> I seriously dislike Control.Category.
15:14:57 <Peaker> Cale: isn't the generalization of Functor really just Category?
15:15:05 <hellige> but arr is a bit funny...
15:15:06 <Cale> Of course, if we could actually define new categories properly, that would be fine.
15:15:11 <mmorrow> yes
15:15:28 <Cale> But Control.Category instances are not really categories in general...
15:15:32 <hellige> i've got a bad feeling about Control.Category as well.
15:15:34 <mmorrow> Control.Category.Category is just Monoid with better names for the class methods
15:15:37 <Cale> They're something much much more specific
15:15:54 <Cale> mmorrow: With naturality conditions
15:15:54 <Pseudonym> I don't like calling it Control.
15:16:11 <Peaker> mmorrow: not really a monoid, monoids can only compose (a->a) functions
15:16:15 <Pseudonym> Perhaps Category should be the top-level thingy.
15:16:18 <Cale> Peaker: huh?
15:16:22 <ddarius> Let's stick it in Abstract.Nonsense
15:16:30 <Pseudonym> Oooh, good idea.
15:16:36 <Peaker> Cale: is that about the question or the monoid statement?
15:16:41 <Cale> ddarius: Actually, an Abstract tree is a good idea :)
15:16:48 <jeffwheeler> Is the lambda/integral sign supposed to form an 'H', on the new logo at the top of the list?
15:16:49 <Cale> Peaker: the monoid statement
15:17:09 <Cale> Well, okay, he's not quite right that it's just a monoid
15:17:14 <Peaker> Cale: instance Monoid can exist for (a->a)  but not for (->) as the Control.Category instance
15:17:29 <Cale> Peaker: But it is very similar to a monoid, in a way.
15:17:30 <Peaker> Cale: or generally (a->b)
15:17:37 <tehgeekmeister> can parsec be extremely fast on short inputs?  (thinking about using it to parse wikipedia article markup)
15:17:44 <Peaker> Cale: Yeah, Category is more general than Monoid in that way though
15:17:52 <mmorrow> yeah, i overlooked that Category was expecting an arg of kind * -> * -> *
15:18:11 <Peaker> Cale, mmorrow: (Category a a) is like a Monoid in that way,  but (Category a b) is more general
15:18:15 <Botje> tehgeekmeister: if it never has to backtrack, sure
15:18:16 <Cale> Peaker: In general.
15:18:25 <mmorrow> does Category take two args?
15:18:29 <Peaker> mmorrow: Yeah
15:18:33 <Cale> But Control.Category is also very restrictive.
15:18:34 * mmorrow really needs to look at the def
15:18:40 <tehgeekmeister> Botje: what if it's only backtracking VERY short distances?
15:18:46 <Botje> no idea :)
15:18:52 <Peaker> mmorrow: Category took (>>>) out of the Arrow class and added id there
15:18:53 <Cale> Your composition has to be a function  cat b c -> cat a b -> cat a c
15:19:00 <ddarius> Cale: I like your design (for the logo)
15:19:02 <Cale> Which means that it has to be natural in a, b, and c
15:19:06 <Cale> ddarius: thanks!
15:19:18 <tehgeekmeister> hmm.  i guess i'll figure that out tomorrow.  five hours straight of coding in a bad chair is enough.
15:19:19 * jeffwheeler feels stupid following my last question. Didn't notice the lack of an 'H' in the name.
15:19:22 <Peaker> Cale: that is the opposite of a "restriction" because it just allows more useful things, instead of just allowing  cat a a -> cat a a -> cat a a :)
15:19:27 <iagoabal> tehgeekmeister, if they do very few backtracks...
15:19:31 <Cale> Control.Category is really a special kind of bifunctor
15:19:32 <iagoabal> it*
15:19:33 <tehgeekmeister> Botje: thanks again for your help.
15:19:34 <ddarius> That said, there are too many people in the community.  The last logo contest was nowhere near this big.
15:19:35 <mmorrow> gah, no src link for the stdlibs docs is killing me
15:19:44 <Peaker> Cale: what's a bifunctor?
15:19:45 <Botje> no problem :)
15:19:57 <Cale> Peaker: A functor with two parameters
15:20:11 <tehgeekmeister> bye all
15:20:17 <mmorrow> Peaker: Category only takes one arg
15:20:28 <jeffwheeler> ddarius: the Jereon logo is from a designer on the kirupa.com community; he doesn't use Haskell
15:20:42 <mmorrow> (the class Category ... )
15:20:46 <Peaker> mmorrow: its a single-arg type-class,  its 2-arg kinded *->*->*
15:20:50 <hellige> Cale: right, it's like a funky hom-functor.
15:21:09 <ddarius> Peaker: A bifunctor is just a functor from the product category.
15:21:15 <hellige> "in haskell, we represent categories by funky hom-functors"
15:21:19 <mmorrow> Peaker: sure, we're talking about two diff things
15:21:29 <mmorrow> (i just realized)
15:21:36 <Peaker> ddarius: I don't know much CT, but I can guess the meaning from the Haskell class
15:22:10 <mmorrow> Peaker: in a category, there's an id /for every object/
15:22:15 <Peaker> hellige: Applicative a => Category (MyType a)  is not interesting, I guess? :)
15:22:56 <Peaker> mmorrow: where isn't there?
15:23:08 <mmorrow> in fact, you could just identify object with their id's, and dispense of talking about objects all together
15:23:30 <hellige> Peaker: not sure what you mean...
15:24:17 <ddarius> mmorrow: Yeah, but doing doesn't actually simplify anything.
15:24:19 <hellige> Cale: how would you generalize Functor, exactly? presumably you want a way to express the two distinct categories.
15:24:34 <mmorrow> ddarius: sure
15:24:35 <Cale> I'm not convinced that I like this definition of category
15:24:39 <ddarius> LaxFunctor ho!
15:24:58 <Cale> (before we go to generalising functor :)
15:25:03 <hellige> Cale: fair. ;0
15:25:05 <mmorrow> yeah, it's weird having to shoehorn stuff into what you can say with a typeclass
15:25:07 <drdozer> is log in base e?
15:25:10 <Cale> I'm clear about what Functor represents.
15:25:19 <ddarius> > log (exp 1)
15:25:21 <Cale> But "Category" less so.
15:25:21 <lambdabot>   1.0
15:25:22 <ddarius> Yes
15:25:26 <Badger> hmmm
15:25:29 <Peaker> hellige: I couldn't create the instance  Functor f => Category (Adapter f) where ...      but I could implement   instance Applicative f => Category (Adapter f) where ...      that's cheating though :)
15:25:32 <ddarius> e is the One True Base
15:25:35 <Badger> would anyone mind telling me what fromIntegral is?
15:25:37 <Cale> It's certainly not just a category whose objects are Haskell types.
15:25:43 <ddarius> @src fromIntegral
15:25:44 <lambdabot> fromIntegral = fromInteger . toInteger
15:25:56 <Badger> er
15:26:02 <Cale> Badger: A way to convert from any Integral type to any numeric type at all.
15:26:09 <Toxaris> @type fromIntegral
15:26:10 <lambdabot> forall a b. (Num b, Integral a) => a -> b
15:26:14 <Cale> Integral types are like Int, Integer, Word, ...
15:26:30 <Cale> > fromIntegral (5 :: Integer) :: Double
15:26:31 <lambdabot>   5.0
15:26:47 <Badger> hmm
15:26:47 <mmorrow> Cale: yeah, it's odd in that it's kinda thinking about types as being objects in the cat of haskell types (via id), and thinking of each type being a category itself (via (.))
15:26:48 <ddarius> fromDerivative = ...
15:26:54 <Badger> why is it necessary to convert?
15:27:02 <mmorrow> and it's doing this at once
15:27:36 <Cale> mmorrow: Each type?
15:27:46 <mmorrow> err, actually no i guess not
15:28:00 <Cale> mmorrow: (.) :: (Category cat) => cat b c -> cat a b -> cat a c
15:28:13 <mmorrow> yeah, i just looked at the def and was like oops
15:28:18 <Cale> and  id :: (Category cat) => cat a a
15:28:43 <Toxaris> see its class Category hom where ...
15:28:57 <Peaker> hellige: http://hpaste.org/13155#a2 -- not a very interesting instance indeed
15:29:00 <hellige> except that the hom-functor doesn't map to Set, but back to Hask.
15:29:05 <idnar> Badger: if you want to do something like add or multiply numbers, they need to be of the same type
15:29:09 <hellige> that's why it's a funky hom-functor...
15:29:20 <idnar> > 5 + 5.0
15:29:22 <lambdabot>   10.0
15:29:24 <chessguy> what is it you guys are doing?
15:29:24 <idnar> er
15:29:31 <idnar> > (5 :: Integer) + (5.0 :: Double)
15:29:33 <lambdabot>   Couldn't match expected type `Integer'
15:29:40 <ddarius> hellige: One treats Hask as essentially Set, but even if you didn't, Hom mapping to something other than Set is exactly what an enriched category is.
15:29:42 <hellige> so we're using objects in Hask (haskell types) to represent collections of morphisms in our cat.
15:29:47 <idnar> or, rather
15:29:57 <Badger> Ah.
15:30:00 <Badger> hmmm.
15:30:01 <Peaker> Badger: look at the type of (+)
15:30:07 <Peaker> @type (+)
15:30:09 <lambdabot> forall a. (Num a) => a -> a -> a
15:30:11 <hellige> ddarius: true. i'm not saying there's anything wrong with it...
15:30:13 <idnar> > fromIntegral (5 :: Integer) + (5.0 :: Double)
15:30:14 <lambdabot>   10.0
15:30:24 <hellige> but it's not exactly 'categories with haskell types as objects', is it?
15:30:35 <Peaker> Badger: Something that most OO type systems cannot express, is that the 2 args and result are the same type, AND that type has to have some interface
15:30:45 <ddarius> hellige: It's a Hask-enriched category with Haskell types as objects.
15:30:55 <mmorrow> yes
15:31:00 <ddarius> hellige: My points was simply that there is a framework for this kind of thing in category theory.
15:31:07 <Peaker> Badger: it does require explicit conversions, but auto-type-coercions are a recipe for trouble anyhow
15:31:07 <mmorrow> and haskell types being categories themselves at the same time
15:31:08 <Badger> I see.
15:31:19 <Badger> thankyou
15:31:20 <mmorrow> (Functor implies this point of view
15:31:37 <hellige> ddarius: true. good point.
15:32:09 <Peaker> Cale: did you mean to add another parameter to Functor's type-class to generalize it, or to make its kind *->*->* instead of *->* ?
15:32:11 <Cale> ddarius: I'm not sure that I'm convinced it's just that...
15:32:18 <hellige> mmorrow: how so?
15:32:22 <chessguy> Peaker:  INumber add(INumber x, INumber y);
15:32:35 <Cale> Peaker: the former
15:32:36 <ddarius> Cale: I'm pretty Hask doesn't form a category unless you start adding restrictions or are very careful/clever.
15:32:40 <chessguy> oh, you're right, that is different
15:32:40 <Peaker> chessguy: that may mean that the 3 types are all different
15:32:42 <ddarius> It certainly doesn't form a nice one.
15:32:50 <mmorrow> hellige: since a functor is defined as a map of categories
15:32:52 <Cale> ddarius: huh?
15:32:56 <idnar> Peaker: just use an "out" parameter :P
15:33:07 <Peaker> idnar: how does that help?
15:33:18 <Toxaris> public <A extends Num> A add(A x, A y)
15:33:32 <hellige> mmorrow: but "Functor f" declares f a functor from Hask -> Hask, doesn't it?
15:33:35 <Toxaris> of course, all subtypes of A are accepted, but they have to be subtypes of the same A
15:33:48 <idnar> Peaker: well, it avoids issues with not being able to select overrides based on the return type
15:33:50 <hellige> mmorrow: not some other categories...
15:33:51 <chessguy> Toxaris:  yeah, that's what i was reaching for
15:33:58 <Peaker> Cale: class Functor f o where fmap :: (a -> b) -> f a -> o b  ?
15:34:02 <idnar> Peaker: the real problem is that it's awkward to define binary methods without ad-hoc polymorphism
15:34:05 <chessguy> just couldn't think of the right syntax for the restriction on A
15:34:13 <hellige> Peaker: probably not...
15:34:20 <Peaker> idnar: selecting by return-type is done with "class-methods"
15:34:36 <hellige> Peaker: where fmap :: (cat a b) -> (cat2obj a) -> (cat2obj b)
15:34:43 <hellige> Peaker: perhaps...
15:34:48 <mmorrow> hellige: i suppose that's one way to see it
15:34:51 <Peaker> hellige: cat2obj == o ?
15:34:59 <hellige> Peaker: or perhaps something like fmap :: (cat a b) -> (cat2 a b)
15:35:04 <hellige> not sure what cale had in mind...
15:35:33 <hellige> Peaker: no, the idea is to replace the (->) in the first argument with something more general.
15:36:00 <Toxaris> public <A> A add(Num<A num, A x, A y) :)
15:36:02 <ddarius> > seq undefined ()
15:36:03 <lambdabot>   * Exception: Prelude.undefined
15:36:11 <hellige> Peaker: my first definition would allow something like: instance Category cat => Functor cat (cat a) where ..."
15:36:14 <ddarius> > seq (undefined . id) ()
15:36:15 <lambdabot>   ()
15:36:25 <Peaker> hellige: so your Functor becomes Category exactly in that case?
15:36:39 <Peaker> hellige: (if you just generalize the first (->) there)
15:36:55 <mmorrow> hellige: yeah, you're right guess Functor really does only express the case of a functor Hask -> Hask
15:37:03 <mmorrow> *... i guess ..
15:37:29 <ddarius> Cale: The obvious choice of composition and identity is not unital as demonstrated above.
15:38:02 * jeffwheeler wonders whether Hackage's equal-files's package really is a better idea than just md5 hashes on the files.
15:38:16 <vixey> hi
15:38:25 <mmorrow> hello
15:38:59 <Peaker> I hope there's a way to bridge Category and Functor.. that dichotomy sounds like future code duplication to me
15:39:03 <roconnor> md5 is broken
15:40:15 <jeffwheeler> roconnor: In general though, would it really be worth reading through all the files simultaneously looking for shared prefixes, like the description indicates, rather than just having a hash on them all?
15:40:25 <jeffwheeler> I suppose that still requires reading all the files . . .
15:40:55 <Peaker> I dislike Monoid/MonadPlus/Alternative and of course: liftM/ap/return/sequence vs. fmap/<*>/pure/sequenceA
15:41:41 <Toxaris> Peaker: Monoid / MonadPlus is a hard one
15:41:47 <mmorrow> i think we need a different mechanism than typeclasses to express what we really want to say
15:42:05 <vixey> yes
15:42:13 <hellige> yes
15:42:20 <mbz_> does type ((->) t) mean functions from t to something?
15:42:27 <hellige> yes
15:42:29 <Peaker> Toxaris: I think the most general solution to that one is having MonadPlus as a method-less class that "flags" the adherence of the instance to the Monoid<->Monad laws (about interaction of mzero and bind, etc)
15:42:38 <sjanssen> Peaker: well, the latter problem is easily fixed
15:42:47 <Peaker> sjanssen: yeah
15:42:48 <sjanssen> (if backwards compatibility isn't an issue)
15:42:49 <Toxaris> class alias MonadPlus m = (forall a . Monoid (m a), Monad m) -- I think the forall is the problem, Peaker
15:43:08 <Olathe> What's the usefulness of (->) ?
15:43:09 <sjanssen> and it would also be easy to drop MonadPlus in favor of Alternative
15:43:29 <mbz_> hellige, was that "yes" answer to my question?
15:43:33 <mmorrow> yes
15:43:37 <Peaker> Toxaris: what about:   class (Monoid (m a), Monad m) => MonadPlus m where <nothing>  is that not allowed?
15:43:40 <Toxaris> yeah, Control.Applicative.* and Control.Monad.* would be united in a better world
15:43:42 <sjanssen> not sure to do about Monoid, as there are multiple useful instances for each MonadPlus
15:43:50 <hellige> mbz_: yes
15:43:58 <mbz_> hellige, thanks
15:44:28 <Toxaris> Peaker: I don't think thats allowed, and if it is, it probably means "for some a", and not "for all a"
15:44:40 <Toxaris> Peaker: and we want *the same Monoid* for all a, I guess
15:44:54 <Toxaris> Peaker: not just some monoid
15:45:01 <Peaker> Toxaris: If the "a" is indeed forall'd, it has to be the same monoid
15:45:06 <roconnor> is it possible to make a wrapper data type so that (liftA2 mappend) is mappend?
15:45:13 <drdozer> mm - there's a constant for pi - is there one for e?
15:45:20 <vixey> @let e = exp 1
15:45:21 <lambdabot>  Defined.
15:45:29 <drdozer> :)
15:45:31 <mmorrow> conflict!
15:45:31 <Peaker> Toxaris: because the compiler has to assume "open world", so the only way forall a. Monoid a   holds, is if the instance is that general as well
15:45:33 <mmorrow> > e
15:45:34 <lambdabot>       Ambiguous occurrence `e'
15:45:34 <lambdabot>      It could refer to either `L.e', defined a...
15:45:34 <chessguy> > e
15:45:35 <lambdabot>       Ambiguous occurrence `e'
15:45:35 <lambdabot>      It could refer to either `L.e', defined a...
15:45:41 <sjanssen> roconnor: yes
15:45:43 <chessguy> > L.e
15:45:44 <lambdabot>   2.718281828459045
15:45:44 <mmorrow> (SimpleReflect)
15:46:08 <Peaker> Toxaris: Maybe unless overlapping instances allow more specific instances to override that, but I doubt that is allowed (or desirable)
15:46:10 <Toxaris> Peaker: sounds good, but probably breaks with BadInstanceFlagHere
15:46:16 <mmorrow> > [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
15:46:16 <sjanssen> newtype LiftMappend m a = LM (m a); instance (Applicative m, Monoid a) => Monoid LiftMappend (m a)
15:46:17 <lambdabot>       Ambiguous occurrence `e'
15:46:17 <lambdabot>      It could refer to either `L.e', defined a...
15:46:23 <mmorrow> > [a,b,c,d,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
15:46:24 <lambdabot>   [a,b,c,d,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
15:46:27 <mmorrow> > [aa,b,c,d,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
15:46:29 <lambdabot>   Not in scope: `aa'
15:46:30 <int-e> > SimpleReflect.e
15:46:32 <lambdabot>   e
15:46:46 <chessguy> :t SimpleReflect.e
15:46:47 <int-e> > L.e ^ SimpleReflect.e
15:46:48 <lambdabot> Expr
15:47:00 <mmorrow> , src ''Expr
15:47:05 <lunabot>  data Expr = Expr {showExpr :: (Int -> ShowS),
15:47:05 <lunabot>                    intExpr :: (Maybe Integer),
15:47:05 <lunabot>                    doubleExpr :: (Maybe Double),
15:47:07 <lambdabot>   mueval: Prelude.read: no parse
15:47:28 <int-e> hum
15:47:30 <mmorrow> looks like there's more to that def that got chopped by lunabot..
15:47:31 <int-e> oh.
15:47:38 <mmorrow> (3 line output max in-channel)
15:47:41 <int-e> > L.e ** SimpleReflect.e
15:47:45 <lambdabot>   exp 1**e
15:47:58 <Peaker> Toxaris: indeed forall is not allows in the context/restriction part :-(
15:47:59 <int-e> (the other was an infinite recursion ...)
15:48:00 <sjanssen> roconnor: but I think you'd want mappend = liftA2 mappend by default, it seems like the most useful instance
15:48:11 <mmorrow> <lunabot>  data Expr = Expr {showExpr :: (Int -> ShowS),
15:48:11 <mmorrow> <lunabot>                    intExpr :: (Maybe Integer),
15:48:11 <mmorrow> <lunabot>                    doubleExpr :: (Maybe Double),
15:48:11 <mmorrow> <lunabot>                    reduced :: (Maybe Expr)}
15:48:21 <int-e> > a^10
15:48:23 <lambdabot>   a * a * (a * a) * (a * a * (a * a)) * (a * a)
15:48:27 <mmorrow> , Expr
15:48:29 <lunabot>  luna: Not in scope: data constructor `Expr'
15:48:31 <mmorrow> awww
15:48:34 <roconnor> sjanssen: you are probably right
15:48:43 <hoopy> http://hpaste.org/13156
15:48:51 <roconnor> the wrapper should turn a monadplus into a monoid
15:49:00 <sjanssen> yeah
15:49:07 <roconnor> which is also nice cause it seems actually wrap something
15:49:15 <sjanssen> roconnor: GetFirst in Data.Monoid is a specialized example of that
15:49:17 <roconnor> (it puts m and a together
15:49:24 <thoughtpolice> mmorrow: might be cool to add this to lunabot or something: http://hackage.haskell.org/packages/archive/traced/2008.11.26/doc/html/Debug-Traced.html
15:49:29 <Peaker> Is there any plan/idea to support flexible class contexts / foralls?
15:49:35 <roconnor> to form a new monoid: (m a)
15:49:55 <sjanssen> hoopy: 'c' has type 'a', x has type '[a]', (++) has type '[a] -> [a] -> [a]'
15:50:44 <sjanssen> > "foo" ++ 'x'
15:50:44 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
15:50:46 <hoopy> hmm
15:50:53 <sjanssen> > "foo" ++ ['x']
15:50:54 <lambdabot>   "foox"
15:50:55 <Pseudonym> Why does it not surprise me that the longest thread of the year is a bunch of functional programmers pontificating about graphic design.
15:51:06 <hoopy> oka so ++ [c]
15:51:14 <Pseudonym> Hundreds of graphic designers out of work, and we've got to get creative.
15:51:15 <sjanssen> hoopy: that will work
15:51:25 <hoopy> is that the best approach?
15:51:25 <Toxaris> bad news is that nobody seems to be using a DSL implemented in Haskell for logo design
15:51:34 <sjanssen> hoopy: alternative, x ++ c : intersperse c xs
15:51:46 <sjanssen> hoopy: that version is a bit better
15:51:47 <Pseudonym> Toxaris, actually, I'd kinda like to see a METAPOST-like tool embedded in Haskell.
15:51:48 <llayland> :i intersperse
15:52:10 <hoopy> aha
15:52:11 <mmorrow> thoughtpolice: interesting. i'll doublecheck that it's bot-safe (looks to be form the haddocks) and add it
15:52:21 <sjanssen> hoopy: also, your third pattern overlaps with your second, the third branch will never be taken
15:52:54 <Pseudonym> The trouble is that Haskellers seem to have impeccable taste in graphic design but very little talent.
15:53:00 <ddarius> @google "Functional MetaPost"
15:53:03 <lambdabot> http://cryp.to/funcmp/
15:53:03 <lambdabot> Title: Functional MetaPost
15:53:12 <Peaker> Toxaris: Sounds to me like a (forall) in class context restrictions should be easy, merely demanding to find literally that instance somewhere else.. I wonder why its not supported
15:53:15 <Pseudonym> There you go.
15:53:22 <Pseudonym> However, that exports MetaPost.
15:53:27 <osfameron> Pseudonym: heh.  Though to be fair, I think some of the designs proposed are rather good
15:53:36 <Pseudonym> Kinda.
15:53:40 <Pseudonym> I think that the intent is very good.
15:53:41 <mmorrow> , let aa = Expr (\_ -> ("aa"++)) Nothing Nothing Nothing in aa
15:53:45 <lunabot>  aa
15:53:53 <Pseudonym> Which is in keeping with the "impeccable taste" comment.
15:54:05 <mmorrow> , showsExpr a []
15:54:07 <lunabot>  luna: Not in scope: `showsExpr'
15:54:14 <mmorrow> , showExpr a []
15:54:16 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
15:54:21 <mmorrow> , showExpr a [] 42
15:54:23 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
15:54:30 <hoopy> sjanssen: ah, i see that.  i was thinking x:_ would match the last element of a list
15:54:33 <mmorrow> , showExpr a 42 []
15:54:36 <lunabot>  "a"
15:54:40 <Toxaris> Peaker: maybe (forall a . ...) is ok, but I guess the much cooler (forall a . (SubContext a b) => RealThing a) is a problem with termination of context reduction etc.
15:55:31 <Peaker> Toxaris: why is that a problem?
15:55:34 <sjanssen> hoopy: it matches any list except the empty list
15:56:03 <Peaker> Toxaris: Doesn't it simply look for an instance of (SubContext a b) whose a and b are both forall'd ?
15:56:10 <Toxaris> Peaker: because it adds variables and instances-to-be-found on the lhs which do not even exist on the rhs
15:56:15 <Pseudonym> I think that the logos which look more "finished" are the ones that didn't require much _technical_ skill to execute.
15:56:28 <Pseudonym> They're essentially arrangements of fonts and colours.
15:56:42 <ddarius> Logos tend to require taste more than technical skill.
15:56:50 <Pseudonym> The >>= logo that people seem to be settling on is a good idea, but nobody has executed it well yet.
15:57:04 <Pseudonym> And, of course, I'm proving my point by critiquing without contributing anything solid.
15:57:07 <Peaker> Toxaris: Are you referring to "b" specifically?
15:57:12 <llayland> I'm trying to find room to install the gimp to give >>= a go
15:57:15 <hoopy> does (x:xs) match ["foo"] and bind x to "foo" and xs to [] ?
15:57:21 <Peaker> Toxaris: and assuming no a->b fundep exist, too?
15:57:27 <orbitz> is lazy I/O known to be a performance bottleneck?
15:57:30 <mauke> > case ["foo"] of (x:xs) -> (x, xs)
15:57:31 <lambdabot>   ("foo",[])
15:57:37 <mmorrow> , let x:xs = "foo" in (x,xs)
15:57:39 <lunabot>  ('f',"oo")
15:57:39 <ddarius> Pseudonym: I really like Cale's except that it doesn't render monochrome all that well, and I'm not sure how great it would be for a -logo-
15:57:42 <hoopy> nice i need to make use of this case thing
15:57:55 <Peaker> orbitz: lazy I/O is known to insert all the evils of impurity back into an otherwise nice/pure program, iiuc
15:58:07 <mmorrow> case "foo" of x:xs -> (x,xs)
15:58:09 <mmorrow> , case "foo" of x:xs -> (x,xs)
15:58:10 <lunabot>  ('f',"oo")
15:58:12 * Pseudonym is going to ask the spouse to have a go
15:58:16 <sjanssen> Peaker: not all of the evils of impurity, just some of them
15:58:16 <ozy`> @type "foo"
15:58:19 <lambdabot> [Char]
15:58:21 <ozy`> @type ["foo"]
15:58:23 <lambdabot> [[Char]]
15:58:32 <Pseudonym> She's an actual graphic designer, so she might be able to do something with it.
15:58:33 <sjanssen> orbitz: IO via [Char] is known to be a bottleneck
15:58:53 <jonaskoelker> good $TIMEZONE, haskell...eers(?) :)
15:59:08 <Peaker> Toxaris: it could probably just require that the SubContext "b" is forall'd?  Or will that be a problem?
15:59:26 <Peaker> jonaskoelker: good UTC+2 to you too
15:59:31 <ozy`> Pseudonym: do it! I'd like to see my pyramid-head logo get some circulation but the >>= one is just better
15:59:32 <jonaskoelker> :)
15:59:47 <lament> the >>= thing seems too contrived
15:59:52 <Toxaris> yeah >\= is nice
15:59:57 <Toxaris> (you mean that one?)
15:59:58 <sjanssen> lament: yes, I think it is too complicated
16:00:16 <sjanssen> logos should be simple
16:00:16 <jonaskoelker> how do I use an Alex tokenizer with a Happy parser?  I can make Happy work if I declare a lot of %token, but... that's what alex is for, right?
16:00:26 <Toxaris> one could extend it for other factions in the community, e.g. <\> for Applicative folk, or >\> for Arrow supporters
16:00:40 <mmorrow> jonaskoelker: yeah, happy is usually used in combo with alex
16:00:45 <ozy`> lament, sjanssen: right, six straight lines is too many for a logo :p
16:00:50 <mmorrow> jonaskoelker: check out both manuals
16:01:13 <orbitz> Peaker, sjanssen : lazy IO looks so sexy though, with strings being streams.  is there a good document i can look at for doign I/O The Right Way in Haskell?
16:01:17 <jonaskoelker> mmorrow: I did, they don't seem to answer my question.  Maybe I'm looking in the wrong place(s)?
16:01:34 <mmorrow> jonaskoelker: ah, check out the example code given for each also
16:01:48 <jonaskoelker> did that too :)
16:01:58 <jonaskoelker> see http://pastebin.com/f21b9d2aa and http://pastebin.com/f2851263a
16:01:59 <mmorrow> heh, what's unclear then?
16:02:06 * mmorrow looks
16:02:11 <Peaker> orbitz: maybe you can use type IOStream a = IO (a, IOStream a) ? :)
16:02:13 <jonaskoelker> I get tons of "unknown identifier 'let'", s/let/var/, ...
16:03:06 <jonaskoelker> mmorrow: pay close attention to the out-commented from-the-example-code-copy-pasted hand-crufted lexer in parser.y ;)
16:03:12 <orbitz> Peaker: i saw on the wiki there is a Streaming library, is that par tof it?
16:03:23 <mmorrow> jonaskoelker: so alex exports a lexing function, whose name differs depending on the wrapper you're using
16:03:27 <Peaker> orbitz: I don't think so, not sure
16:03:34 <mmorrow> the basic on is `alexScanTokens'
16:03:39 <mmorrow> s/on/one/
16:03:51 <mmorrow> the monad one is
16:03:53 <hoopy> what's wrong with the guard xs /= [] ?
16:03:55 <mmorrow> alexMonadScan
16:04:00 <mmorrow> (i believe)
16:04:13 <mauke> hoopy: requires the elements of xs to implement Eq
16:04:24 <jonaskoelker> mmorrow: and I'm using alexScanTokens, which is what %wrapper "posn" exports...
16:04:32 <jonaskoelker> mmorrow: am I doing that bit right?
16:04:54 <jonaskoelker> mmorrow: let that = "%lexer ..."
16:04:57 <Toxaris> Peaker: I'm not sure. I just guess that there may arise problems with termination. but actually, I don't care about termination of the typechecker (as long as it is somewhat predictable for humans whether and why the typechecker terminates)
16:05:19 <Toxaris> Peaker: and as long as it terminates for many interesting programs, of course
16:05:35 <Peaker> Toxaris: Ok, but I still don't understand why it makes termination a problem here (I don't fully understand what introduces undecidable instances, either)
16:06:32 <mmorrow> jonaskoelker: here's a darcs repo with a Lexer.x i got from an example (i added some stuff to it, can't remember what (i think)), and a mini driver prog that should demonstrate using the alex lexer from another file:  http://code.haskell.org/~morrow/code/haskell/hslex/
16:06:35 <Toxaris> Peaker: I think one of the current rules which ensure termination is "a variable on the lhs has to be mentioned on the rhs", obviously, that one has to be dropped if you want to introduce variables whith scope only on the lhs
16:06:45 <Toxaris> Peaker: so I guess on needs something else instead of that rule
16:07:18 <mmorrow> jonaskoelker: so in Lexer.x there's a function `scan', defined using alexMonadScan. scan produces a list of tokens.
16:07:48 <mmorrow> that Lexer.x is using the posn wrapper too, so i think it'll be applicable
16:07:54 <Toxaris> Peaker: consider: instance (forall f :: * => * . C (f a)) => C a
16:08:04 <lament> ozy`: it's not about the number of lines, it just looks too busy
16:08:32 <Toxaris> Peaker: Context reduction would go like (C a) => forall f . C (f a) => forall f g . C (f (g a)) => ...
16:08:32 <mmorrow>  jonaskoelker: oh oops, it's using the monad wrapper (duh, alexMonadScan)
16:08:36 <jonaskoelker> mmorrow: I know how to use alex from another file.  I just don't know how to put the square peg of alex into the square hole of happy.  It looks round :)
16:08:47 <jonaskoelker> mmorrow: got an example with alex+happy?
16:08:53 <mmorrow> jonaskoelker: ah, hmm.
16:08:58 <mmorrow> yes, i'll find one
16:08:59 <jonaskoelker> google doesn't want to be my friend today :(
16:09:44 <Peaker> ghc is throwing a "dmdFix loop" big warning/error at me
16:09:47 <Peaker> what's that?
16:10:20 <Peaker> (not a warning/error, actually, seems like some sort of debug dump)
16:12:59 <mmorrow> jonaskoelker: ok, it looks like you just need to add a "%tokentype { Token }"
16:13:26 <mmorrow> jonaskoelker: also, i don't think you need a "%lexer" directive unless your parser/lexer are monadically threaded together
16:14:04 <jonaskoelker> happy is still not at all happy
16:14:19 <mmorrow> jonaskoelker: could you paste the error msg?
16:14:25 <jonaskoelker> sure
16:14:31 <mmorrow> @paste
16:14:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:14:38 <ozy`> lament: well, the versions where the middle symbol is two-toned to highlight its dual purpose as a lambda and a ">" character do look too busy, but I still like the general outline of the logo
16:14:43 <jonaskoelker> mmorrow: http://pastebin.com/f6afd9329
16:15:06 <jonaskoelker> mmorrow: got a /usr/bin/hpaste for me?
16:15:23 <lament> ozy`: yeah, monotone is nicer
16:15:34 <ozy`> lament: it's simple enough to draw on a napkin, it references both lambdas and monads, and it's impossible to confuse with the Half-Life logo ;)
16:15:37 <mmorrow> jonaskoelker: heh, i wish
16:15:38 <lament> subtlety does wonders
16:15:50 <lament> (see fedex logo)
16:16:03 <mmorrow> jonaskoelker: ok, i just realized also that if you're using a "%lexer", the second arg is (i believe) the Token type
16:16:08 <mauke> jonaskoelker: http://mauke.ath.cx/stuff/perl/pastebin
16:16:17 <mauke> jonaskoelker: alias hpaste='pastebin -shpaste'
16:16:38 <mmorrow> (double-check that, but it's definitely not the start-state/whatever 0 is meant to rep in your code)
16:16:46 <mmorrow> that may be it
16:17:31 <osfameron> eeeek!  the half-life logo is a lambda?
16:17:42 <Pseudonym> Lambda in a circle.
16:17:51 <Pseudonym> It's the standard symbol for half-life.
16:18:28 <osfameron> for the scientific concept?
16:18:54 <SamB_XP> osfameron: NO YOU MORON
16:18:57 <SamB_XP> the GAME
16:19:10 <mauke> wat
16:19:10 <mmorrow> jonaskoelker: ohh, i just realized that you "%token ..." was commented out in your parser. you need that.
16:19:31 <mmorrow> (in addition to a "%tokentype")
16:19:53 <mmorrow> i think also you should get rid of the "%lexer .."
16:19:59 <osfameron> SamB_XP: er, yes, hence "the half-life logo is a lambda?"  Whereas "standard symbol" sounded more like for a concept than a product
16:20:10 <SamB_XP> I think scientific half life is something like $t_\frac12$
16:20:21 <mmorrow> jonaskoelker: if that doesn't work, i'm stumped
16:21:03 <SamB_XP> http://orange.half-life2.com/
16:21:19 <osfameron> SamB_XP: that seems to be the symbol for the biological concept (from wikipedia), but the page on radioactive half-life has lambdas on it
16:21:36 <SamB_XP> osfameron: hmm
16:21:53 <Botje> Haskell: Gordon Freeman approves.
16:21:54 <mmorrow> oh, ha. how about that long-module-name bug :)
16:22:03 <SamB_XP> well, in physics circles lambda is usally wavelength isn't it ?
16:22:08 <osfameron> they do call it "the lambda logo" in the copyright section, so it is deliberate
16:22:20 <osfameron> no idea
16:22:43 <SamB_XP> (note that these "physics circles" do not actually have a round shape, and do not actually enclose said lambdas)
16:22:47 <jonaskoelker> mmorrow: ah
16:23:01 <osfameron> http://en.wikipedia.org/wiki/Lambda suggests it's "The radioactive decay constant (Connected to half-life of a radioactive isotrop in physics)" among other things
16:23:11 <jonaskoelker> mmorrow: that spews out a different and bigger error message, but I can make sense of (and fix, I think) that one
16:23:17 <jonaskoelker> mmorrow: thanks a bundle :)
16:23:31 <mmorrow> jonaskoelker: nice. np. :)
16:23:43 <jonaskoelker> mmorrow: thanks to you, I can keep on hacking on a pointless mini-language instead of getting a good night's sleep :D
16:23:50 <mmorrow> woot!
16:24:13 <jonaskoelker> thanks to you I _can_.  Thanks to my own fallibility, I _do_ :)
16:24:29 <ddarius> mmorrow is an enabler.
16:24:31 <gwern> to be fair, the ultimate culprit is god
16:24:38 <mmorrow> i wouldn't call it "fallibility"
16:24:53 <ddarius> gwern: I blame God's mother.
16:24:58 <jonaskoelker> mmorrow: what then?  Eagerness to learn haskell?
16:25:19 <jonaskoelker> the desire to write a shorter-and-sweeter-than-in-C language implementation? ;)
16:25:21 <mmorrow> jonaskoelker: i'm not sure, but i think it's probably more good than it is bad
16:25:35 <jonaskoelker> there's good in it, that much I'm certain of
16:25:39 <mmorrow> jonaskoelker: yes! your second suggestion sounds about right
16:25:52 <gwern> hm. so many packages are broken on hackage, or haddock breaks on them. I'm up to 'haskeline' and only have 143 hoogle database files
16:26:09 <jonaskoelker> hs >>= C
16:26:18 <SamB_XP> grr! what did I ever do to you, milk!
16:26:18 <jonaskoelker> (haskell is much greater than or equal to C)
16:26:28 <mmorrow> @type (>>=)
16:26:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:26:30 <gwern> SamB_XP: murder him?
16:26:40 <jonaskoelker> :)  I know
16:26:45 <mmorrow> heh
16:27:03 <gwern> @quote cons
16:27:04 <lambdabot> ghc says: Malformed constructor signature
16:27:10 <gwern> @quote cons
16:27:11 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
16:27:40 <gwern> @quote consing
16:27:40 <lambdabot> No quotes match. I've seen penguins that can type better than that.
16:27:44 <mmorrow> @quote eax
16:27:44 <lambdabot> No quotes match. :(
16:27:51 <gwern> ?zippy
16:27:51 <lambdabot> Unknown command, try @list
16:27:58 <gwern> ?yow
16:27:59 <lambdabot> Uh-oh!!  I forgot to submit to COMPULSORY URINALYSIS!
16:28:10 <mmorrow> did some of the quotes get bitsploded?
16:28:13 <jeffwheeler> wtf?
16:28:20 <gwern> I wonder where the 'I can hear the consing' came from then
16:28:40 <mmorrow> i love the sound of consing in the morning!
16:28:50 <mmorrow> it sounds like...
16:28:59 <mmorrow> <long-inhale>
16:29:02 <gwern> like?
16:29:04 <mmorrow> victory,
16:29:06 <mmorrow> .
16:29:16 <gwern> victory? fail man, fail
16:29:20 <mmorrow> heh
16:29:22 <gwern> you can't replace just two elements
16:29:28 <gwern> you have to replace all of them
16:29:32 <mm_freak> is today's FTP suitable for games with thousands of 'machines'?
16:29:37 <mm_freak> s/FTP/FRP/
16:29:38 <gwern> either one, or all
16:29:39 <mmorrow> but victory is such a good ending to that
16:29:43 <SamB_XP> I think it means you need to adjust the microcode in your lisp machine, actually
16:29:44 <mmorrow> i had to leave it
16:30:08 <gwern> mmorrow: no, you could've added something like 'success', or 'reliability'
16:30:15 <mmorrow> borrring
16:30:32 <dons> ok. jerzey's been drawn into a coppin thread. time to slow things down.
16:30:42 <gwern> mmorrow clearly has no apprecation for the fine art of parody
16:30:50 <ddarius> dons: Less 'e'
16:31:04 <SamB_XP> gwern: D D
16:31:09 <SamB_XP> there's a parody for you
16:31:25 <mmorrow> gwern: :)
16:31:55 <gwern> what the hell, now '_adept_' is following me on twitter?
16:32:11 * ddarius twitter stalks gwern.
16:32:21 <gwern> I don't even use twitter, I only signed up to reproduce an xmonad bug report >.<
16:32:22 <SamB_XP> curse you, dmitry!
16:32:30 <SamB_XP> gwern: heh
16:32:39 * ddarius doesn't even have an account.
16:32:48 <SamB_XP> what in the world kind of bug report do you need that for ?
16:32:54 * mmorrow has never even been to the twitter website
16:33:02 <SamB_XP> mmorrow: what does that have to do with it
16:33:13 <SamB_XP> mmorrow: you can text 40404 also
16:33:21 <jeffwheeler> The local newspapers and TV stations use Twitter, in Austin. It's an awesome way to get important news quickly.
16:33:28 <gwern> SamB_XP: well, there's this software gui for twitter on ubuntu, when you've logged into twitter, pops up a floating window of some sort
16:33:37 <SamB_XP> ah
16:33:37 * mmorrow needs to get hip
16:33:38 <SamB_XP> GUI
16:33:50 <SamB_XP> I don't twitter much lately
16:33:52 <gwern> the bug involved the floating window - but *only* the floating window, so in order to log into twitter and create the floating window, I nedeed to register...
16:33:55 <ddarius> mmorrow: Throw away your TV.  It's what all the cool kids are doing.
16:34:05 <gwern> and now there's like 3 or 4 people following my feed, despite me never using it
16:34:08 <mmorrow> ddarius: i haven't owned a TV for years
16:34:14 <mmorrow> :)
16:34:16 <ddarius> mmorrow: That makes it much easier.
16:34:21 <mmorrow> totally
16:34:24 <SamB_XP> gwern: it amazes me how many people are following me
16:34:28 <SamB_XP> it might be as many as 3
16:34:31 <SamB_XP> or more!
16:34:44 <bos> ddarius: twittering yet?
16:34:49 <SamB_XP> and I think they all started after I stopped twittering
16:34:56 * ddarius doesn't even have a blog, twitter feed, website, etc. and people still follow him.
16:35:00 * int-e deliberately avoids seeming to follow SamB_XP.
16:35:02 <bos> we need more people twittering about abstract algebra and category theory.
16:35:02 <SamB_XP> though at least I do advertise it on facebook, maybe that's how they found it
16:35:03 <gwern> SamB_XP: you must lead some sort of negative-boring life
16:35:17 <gwern> where you become more interesting the less is known about you
16:35:21 <SamB_XP> "just in case"
16:35:26 <wjt> it turns out that twitter.com/bos is not actually bos, but is in fact BOS
16:35:30 <jeffwheeler> I'm hip because more people follow me than I follow people. ;)
16:35:31 <jeffwheeler> http://twitter.com/home
16:36:01 * osfameron gets freaked out when random people follow him (usually spamblogs) and unsubscribes them
16:36:02 <SamB_XP> bos: is that practical ?
16:36:06 <jeffwheeler> Err . . . fail: http://twitter.com/nokrev
16:36:13 <bos> SamB_XP: is what practical?
16:36:16 <SamB_XP> wouldn't you get cut-off halfway through the first commutative diagram ?
16:36:20 <bos> oh.
16:36:28 * ddarius doesn't like commutative diagrams all that much.
16:36:40 <gwern> jeffwheeler: a clever method to get us to follow you and eventually brainwash us into worshipping you, but I'm afraid it won't work!
16:36:41 <BONUS> i sometimes get people following me because they came from LYAH and then they unsubsribe saying "hey LYAH is great but your feed is just weird"
16:36:53 <mmorrow> haha
16:36:55 <jeffwheeler> gwern: shucks!
16:36:57 <wjt> ALERT! 11:32PM EST - RWH VIS HIGH MEANS WIDELY DISTRIBUTED LAMBDAS! IMPURE FUNCTIONS ALL OVER THE EAST ARE HOSED
16:37:04 <gwern> '
16:37:05 <gwern> 'If one day I decide to return back to some religion, I will pray for the
16:37:06 <gwern> souls of your teachers. How many microseconds have they spent teaching
16:37:06 <gwern> parallel programming?
16:37:06 <gwern> I suggest that you say goodmorning to Google. '
16:37:09 <gwern> harsh
16:37:23 <dons> harsh but fair.
16:37:28 <dons> lol wat?
16:37:32 <ddarius> gwern: He said he'd never even heard of -coroutines- !
16:37:40 <dons> he's not on a forum.
16:37:50 * gwern wonders sometimes how much dons thinks about his responses :)
16:37:52 <ddarius> It's a bit odd as coroutines have nothing to do with Haskell.  They are rather underused in Haskell.
16:37:55 <dons> he's on a mailing list. most of his responses are inappropriate for that medium.
16:38:15 <gwern> ddarius: well, I've read about coroutines before and I'm still not positive what they're for
16:38:27 <dons> lolz haskell monads wtf?
16:38:33 <dons> math suxors
16:38:47 <bos> wasn't there a memcached client in haskell at one point?
16:38:51 <bos> it has completely vanished.
16:38:53 <int-e> ddarius: which isn't a problem as such. but the first thing I'd do with an unknown term is google it to see if I should know it. :)
16:38:59 <dons> bos: there was.. yes.
16:39:01 <dons> i can dig.
16:39:09 <gwern> bos: yes, I have a copy
16:39:19 <bos> why's it not on hackage?
16:39:32 <ddarius> int-e: How'd he even know of the term and why does he think it has anything to do with Haskell.
16:39:36 <dons> it got removed by ross
16:39:38 <gwern> dunno. I think the author may've asked me to let him finish it
16:39:47 <gwern> bos: it's at http://neugierig.org/software/darcs/haskell-memcached
16:39:50 <ddarius> And if he doesn't know what it means, how can he know whether the name is inappropriate or not.
16:39:52 <ddarius> ?
16:40:07 <dons> evan martin's work, bos
16:40:14 <dons> http://neugierig.org/software/darcs/browse/?r=haskell-memcached;a=summary
16:40:43 <bos> hm, interesting.
16:40:43 * ddarius for the most part stays out of these things, though of late that's more from just a tiredness with the internet altogether.
16:41:06 <bos> uh oh, i've seen evan's python memcached client, and it caused me to throw up in my mouth.
16:41:10 <jeffwheeler> What does CT stand for?
16:41:33 <gwern> category theory?
16:41:34 <SamB_XP> coroutines ... isn't that just mutually tail-recursive functions ?
16:41:41 <dons> bos, you're doing that a lot lately :P
16:41:50 <gwern> it's flu season
16:41:55 <dons> tummy bug
16:41:56 <jeffwheeler> gwern: ah, probably; I was thinking correctness, which is silly
16:42:06 <Gracenotes> gwern: http://www.google.org/flutrends/ :)
16:42:08 <bos> dons: it comes from reading questionable code.
16:42:33 <gwern> questionable computer code... or questionable BIOLOGICAL CODES???
16:42:40 <SamB_XP> gee, I could have sworn CT stood for Chrono Trigger
16:43:06 <Gracenotes> bos: that's funny... most 'throw up in mouth' reactions are instantaneous, i.e. caused by some sort of surprise. So you must be able to recognized bad code immediately
16:43:17 <bos> Gracenotes: yes.
16:43:25 <Gracenotes> *recognize, eesh
16:43:45 <gwern> Gracenotes: that's not true. you can become nauseous, and then as the full horror and subtlety strikes you, be overwhelmed by a sudden epiphany of dismay and disgust
16:44:00 <SamB_XP> geese, I knew bad code had bugs, but doesn't that beat all ?
16:44:25 <Gracenotes> gwern: I postulated that as well, but it would have to be quite an epiphany to prompt a physical reaction
16:45:17 <gwern> (dunno, I once finished writing a java module which was really really bad, and had to go outside for a while just from the nauseau and antipathy of the past hours)
16:45:39 <BMeph> Gracenotes: I have an immediate physical reaction when I see 'if (<test condition> == TRUE)'-type code... ;p
16:45:58 <SamB_XP> BMeph: what about if the next bit is
16:46:05 <SamB_XP> return true; else return false
16:46:09 <mokus> BMeph: or worse, 'if (true == x)'
16:46:11 <Gracenotes> how about (<test condition> == 1) :)
16:46:17 <ozy`> BMeph: how about "if (test == TRUE) return TRUE; else return FALSE;"
16:46:24 <ozy`> SamB_XP: haha
16:46:27 <ddarius> SamB_XP: Seen that and worse.
16:46:35 <SamB_XP> Gracenotes: well, that depends on whether it's actually a test condition or not
16:46:53 <Gracenotes> in a language that has automatic type coercion, say
16:46:53 <SamB_XP> ddarius: someone was complaining about that on #zsnes the other day ;-)
16:47:13 <roconnor> geez,  what part of zygohistomorphic prepromorphism does Andrew Coppin not understand?
16:47:16 <gwern> I think my biggest WTF moment with haskell was when cabalizing one package, when I saw that they were depending on the GHC API just to get catMaybes
16:47:48 <user317> where does cabal install store its metadata?  i cant figure out what to delete to so it thinks that it has nothing installed anymroe
16:48:06 <ddarius> roconnor: All those *morphisms (which does not include epimorphism), were never widely popular or meaningful.  In my opinion, they should die out.  People do tend to use them just for shock value.
16:48:08 <Gracenotes> gwern: but in Java case, that sounds more like just depression
16:48:10 <user317> just found it, its .ghc
16:48:10 <brodie> is it normal for ghc to take hours to build?
16:48:20 <pizza_> yes
16:48:23 <SamB_XP> brodie: yeah
16:48:26 <ddarius> And by "those *morphisms" I mean the terms not the actual concept.
16:48:27 <SamB_XP> depending on CPU type
16:48:37 <SamB_XP> if you use the latest cray, maybe not
16:48:37 <brodie> hmm, that's no fun. oh well
16:48:45 <gwern> Gracenotes: possible. java is awfully depressing
16:48:54 <brodie> i'm using 6.10.1 in macports on an intel core 2 duo macbook
16:48:56 <ddarius> SamB_XP: Memory is usually more important than processor speed.
16:48:57 <SamB_XP> but then I dunno if GHC would run on a cray anyway
16:49:10 <p_l> SamB_XP: It would, newest models are AMD64
16:49:16 <SamB_XP> ddarius: oh, yeah, you obviously also need lots of RAM
16:49:20 <SamB_XP> p_l: ah
16:49:51 <roconnor> ddarius: that's like saying botanical names should die out
16:49:54 <p_l> they have custom vector CPUs and FPGAs too
16:49:54 <Gracenotes> gwern: it's pretty straightforward, though, when you become comfortable with the abstractions, and where they're leaky
16:50:09 <brodie> is there something specific that causes the long build times? i'm not all that familiar with ghc
16:50:12 <Gracenotes> still, I no longer write small scripts in Java; I use Python
16:50:18 <Gracenotes> for that.
16:50:33 * gwern stifles the urge to make a joke about 'small scripts in Java'
16:50:51 <pumpkin_> moo
16:50:52 <p_l> ... small scripts in Java..... Whiskey Tango Foxtrot !?!?
16:51:05 <ddarius> roconnor: Perhaps they should, I don't know, but the *morphisms are just created for the hell of it and not used by even a specialized community.  More people with only a vague idea of the meaning of those terms use them than people with a full understanding.
16:51:13 <Gracenotes> they're pretty small if you don't include the import blah; public class Test { public static void main(String[] args) {
16:51:13 <SamB_XP> Gracenotes: you know, when gwern said that just now, I wanted to mention jython for some reason
16:51:17 <Gracenotes> and the }}
16:51:20 <SamB_XP> then I read what you'd said
16:51:40 <ddarius> roconnor: "fold" is not only more "friendly" it is more common in the literature.
16:51:46 <gwern> what's jython? java on the python vm or vice versa?
16:51:57 <Gracenotes> the latter
16:52:02 <p_l> Python compiled to JVM bytecode
16:52:04 <roconnor> ddarius: except that fold is strongly associated with lists.
16:52:08 <SamB_XP> gwern: who would want the reverse ?
16:52:16 <ddarius> roconnor: So is catamorphism to most.
16:52:17 <Gracenotes> apparently people really like the JVM
16:52:25 <Gracenotes> but, uh, not Java
16:52:29 <SamB_XP> Gracenotes: not that
16:52:30 <gwern> SamB_XP: dunno, but I don't really follow the other one either
16:52:35 <roconnor> ddarius: I doubt that
16:52:47 <p_l> JVM is quite good platform, it seems. It's just that Java is a shitty lang :D
16:53:08 <ozy`> p_l: yeah, now if only they could get proper tail recursion going....
16:53:17 <Gracenotes> it has its good points. It's a very good OOP language, but as I said, it has its leaky abstractions
16:53:24 <jml> ...
16:53:27 <Gracenotes> just my opinion using it anyway :/
16:53:27 <ozy`> Gracenotes: what? no it's not
16:53:43 <ozy`> Gracenotes: go spend some time with ruby, or even smalltalk
16:53:46 <SamB_XP> Python bytecode is not supported as a platform
16:54:06 <int-e> ddarius: I remembered about coroutines: One explanation or model of laziness is that everything is a coroutine - each thunk is a suspended coroutine waiting to be called back. It doesn't capture the memoizing aspect, but it's a start. python generators are closer, but less well known (I believe).
16:54:08 <Gracenotes> ozy`: a lot of people don't really use the advanced features. OOP is more than just inheritance, after all.
16:54:36 <SamB_XP> Gracenotes: java has advanced features ?
16:55:59 <pumpkin_> in soviet russia, advanced features has java
16:56:10 <Botje> SamB_XP: like wildcards!
16:56:33 <Gracenotes> okay, a lot of parts of it suck, like the IO libraries, non-runtime exceptions, etc.
16:56:52 <ozy`> Gracenotes: you have not seen OOP until you've seen smalltalk (even if you only see it as filtered through ruby or some other smalltalk-alike)
16:56:52 <jeffwheeler> What parts _don't_ suck?
16:57:44 <ozy`> Java is fractionally more OO than C++, which is hardly OO itself
16:58:12 <SamB_XP> ozy`: what, that much ?
16:58:22 <brodie> OO means different things to different people, ozy`
16:58:35 <SamB_XP> but C++ isn't one of them :-P
16:58:41 <cjay> what OO features does Java have that C++ doesn't?
16:58:46 <Gracenotes> Java implements OO in a way best summarized by the phrase "design by contract"
16:59:31 <SamB_XP> I thought that was Eifall
16:59:35 <ozy`> brodie: this is the fault of C++
17:00:18 <Gracenotes> ozy`: looking over Ruby's wiki page, I don't see a huge difference between it and Java
17:00:40 <jeffwheeler> Gracenotes: Ints aren't primitives, for a good start. :)
17:00:46 <mmorrow> doesn't ruby have (some variant of) callCC?
17:01:00 <mmorrow> and proper tail recursion optim?
17:01:08 <mmorrow> (dunno about the second one)
17:01:17 <brodie> ozy`: i think you mean simula
17:01:20 <Gracenotes> jeffwheeler: that's yet another leaky abstraction... the fact that primitives even exist
17:01:21 * mmorrow has never programmed in ruby
17:01:35 <skorpan> ruby is like python, but looser
17:01:41 <skorpan> at least most of the time
17:01:52 <skorpan> okay, maybe not
17:01:57 <skorpan> much like python and perl combined
17:02:00 <skorpan> and eiffel...
17:02:00 <Adamant> Java is not Eiffely in the DbC sense, at all.
17:02:04 <Botje> ut slower
17:02:06 <brodie> they're similar on a big picture level, but philosophically they're worlds apart
17:02:06 * ozy` waves his hands around
17:02:06 <Botje> much slower :)
17:02:20 <Gracenotes> ozy`: yes?
17:02:36 <wchogg> @seen conal
17:02:36 <lambdabot> I saw conal leaving #haskell and #ghc 27m 25s ago, and .
17:02:39 <Gracenotes> hows can I halps you?
17:02:52 <pumpkin_> halp halp
17:02:54 <ddarius> int-e: Laziness does indeed replace some usages of coroutines, but coroutines are more general but much less well-behaved.
17:04:53 <Gracenotes> eh, all of this is even more complicated considering the history of the individual programming languages, not merely comparing them independent of order/time
17:05:51 <Gracenotes> I guess the end-all of any series of comparisons is that some languages are suited for some tasks. that's all :\
17:06:32 <jeffwheeler> Since this is #haskell, I think that's an unfair comparison. Rather, I'd like to see the conclusion that Haskell was superior in all cases.
17:08:08 <Cale> hehe
17:09:29 <Saizan_> @faq can haskell be superior in all cases?
17:09:29 <lambdabot> The answer is: Yes! Haskell can do that.
17:09:56 <Gracenotes> anyway, I'm sure my opinions will change as I learn more languages. Java, C, JavaScript, Python, basic Haskell, and rudimentary in about 5 other languages... isn't that comprehensive when one thinks about it
17:11:06 <Gracenotes> I have 3/4 of my life ahead of me (if I'm lucky), to learn other languages and flame about them. (yay?)
17:11:11 <ddarius> Gracenotes: Learn Prolog, J, Smalltalk, Icon, Scheme, Common Lisp.
17:11:17 <p_l> Gracenotes: Learn Erlang, Lisp and Prolog to that mix
17:11:20 <Gracenotes> oh, and basic Scheme
17:11:23 <p_l> Smalltalk too
17:11:33 <Gracenotes> although I haven't touched that in a year
17:11:39 <p_l> and Forth
17:11:42 <Gnezdo> I compiled my program with -prof -auto-all and running with +RTS -p, yet no .prof file is getting written.
17:11:46 <Gnezdo> any ideas?
17:11:48 <Gracenotes> Forth? >_>
17:11:49 <Olathe> And assembler
17:12:03 <Olathe> Always good to learn assembler.
17:12:11 <ddarius> Olathe: Crap, I can't believe I forgot assembler.  Forth and Erlang are good suggestion too that I should have had.
17:12:11 <Botje> Gracenotes: learn factor then
17:12:12 <Gracenotes> any particular architecture you recommend? ;)
17:12:16 <Botje> it's the same thing :p
17:12:19 <Gnezdo> and verilog
17:12:19 <ddarius> Gracenotes: The one you run.
17:12:21 <Olathe> Any architecture is good.
17:12:23 <p_l> Olathe: Alpha assembler, so that he would meet the full force of force of out-of-order-execution
17:12:26 <Olathe> I recommend a simple one, though.
17:12:30 <Gracenotes> x86 it is
17:12:32 <p_l> *full force
17:12:36 <Olathe> Yeah, that's fine.
17:12:42 <p_l> Gracenotes: x86 is everything but simple
17:12:50 * ddarius recommends x86.
17:12:55 <Olathe> I forget what they had in school.
17:12:58 <SamB_XP> parts of it are simple enough
17:13:02 <Gracenotes> would you suggest learning something like SPARC first?
17:13:04 <ddarius> It's not a nice assembly language but it is real.
17:13:06 <Olathe> Oh, no.
17:13:06 * mbz recommends mips
17:13:07 <Olathe> Hmm..
17:13:10 <Gracenotes> oh, and I forgot, I know some QBASIC
17:13:11 <Olathe> Yeah, MIPS.
17:13:13 <Gracenotes> :)
17:13:13 <SamB_XP> using your native assembler would be perhaps easiest
17:13:21 <Olathe> They taught that, and it seemed decent enough for learning it.
17:13:25 * ddarius used to know QBASIC...
17:13:29 <Olathe> But x86 isn't horrid.
17:13:36 <p_l> MMIX is very simple and pretty realistic, Alpha makes you understand that memory coherence is not guaranteed :D
17:13:40 <mmorrow> my dream language that i would use for everything would be dependently-typed, turing-complete, eval-having, dynamically-machine-code-producing, self-modifying-capable, tail-recursion-optimizing, and probably some othre stuff i can't think of at the moment :)
17:13:58 <ddarius> mmorrow: When are you going to release an implementation?
17:14:06 <mbz> ;)
17:14:17 <mmorrow> ddarius: as soon as i get one working :)  (not soon :(
17:14:19 <mmorrow> )
17:14:30 <Gracenotes> I wonder if it's worth it to learn a not-turing-complete language, if any popularly exist
17:14:38 <Gracenotes> heh.
17:14:42 <Olathe> I don't think any do.
17:14:48 <ddarius> Olathe: There are many.
17:14:53 <Cale> Gracenotes: Maybe Charity
17:14:57 <hoopy> regular expressions
17:14:59 <hoopy> ?
17:15:05 <hoopy> xhtml
17:15:05 <ddarius> SQL for example.  Many of the dependently typed languages and languages in theorem provers.
17:15:09 <Olathe> Ahh, yes regexes are nice.
17:15:09 <mmorrow> Gracenotes: many of the current dependently typed "programming" languages aren't turing-complete
17:15:11 <Gracenotes> oh, I know regular expressions
17:15:25 <Cale> Charity is a pure functional programming language which is not Turing complete and yet can do many useful things
17:15:33 <Gracenotes> they're fun. I even have the xkcd t-shirt :P
17:15:54 * p_l suddenly has this vision of regexes turned turing complete, running a TECO vm which runs a modified brainfuck VM which in turn runs an emulator for some computer arch...
17:15:56 <Cale> http://www.cracked.com/blog/wp-content/uploads/2008/12/mountedlion2.jpg -- and now, the lion cavalry!
17:16:17 <Gnezdo> nevermind... .prof is in current directory, not next to the executable unlike .stat
17:16:36 <EvilTerran> Cale, heh; not quite the picture i was expecting for "lion cavalry"
17:16:37 <pumpkin_> this can't be good
17:16:38 <pumpkin_> : internal error: evacuate: strange closure type 58503
17:16:38 <pumpkin_>     (GHC version 6.10.1 for i386_apple_darwin)
17:16:51 <mmorrow> ruhroh
17:17:12 <Gracenotes> anyways, I'm sure there will be in the future nascent languages that will become very popular. It there weren't any I'd be suspicious.
17:17:14 <Gracenotes> *if
17:17:23 * SamB_XP tosses mmorrow a scooby snack
17:17:35 <mmorrow> scoobydoobydoooo
17:17:37 <p_l> Gracenotes: The question is how many of them will survive
17:17:59 <p_l> Right now, the prize takers seem to be Fortran, Lisp, COBOL and C
17:18:03 <Cale> pumpkin_: Did you compile stuff with two different versions of GHC?
17:18:16 <Gracenotes> 100 years from now, will systems still be written in C?
17:18:16 <pumpkin_> Cale: nope, and this was pure ghci stuff
17:18:25 <Gracenotes> or will there be interfaces from C to other languages
17:18:28 <pumpkin_> just calling stuff I'd let in ghci
17:18:39 <mmorrow> pumpkin: weird
17:18:39 <Olathe> I doubt any of the current languages will still exist.
17:18:41 <jonaskoelker> is there a recommended way of generating pseudorandom numbers (on your own) in haskell?  It involves some state, so I figure I use some sort of monad... but the idea of carrying around a random_tape variable in all my using functions seems a bit.. icky, to me
17:18:41 <SamB_XP> pumpkin_: did you try to allocate a crazilly sized array or otherwise corrupt the heap ?
17:19:01 <Gracenotes> Olathe: if computers exist :)
17:19:06 <pumpkin_> SamB_XP: it was just a list comprehension, but it was iterating over a rather large list :o
17:19:07 <p_l> Gracenotes: I suspect COBOL will still be there, the same goes for FORTRAN, Lisp and quite possibly Haskell
17:19:08 <Gracenotes> or humans
17:19:10 <Olathe> Oh, I think they will, but who knows.
17:19:17 <SamB_XP> pumpkin: that can't be it
17:19:28 <SamB_XP> pumpkin: is it reliably reproducable ?
17:19:34 <Cale> jonaskoelker: You can pass around a StdGen, but if that's too awkward, there's a nice MonadRandom on Hackage you can use.
17:19:35 <p_l> COBOL of course will still be there because of completely different reasons than the rest :D
17:19:39 <EvilTerran> jonaskoelker, well, you can use the standard PRG library to get an infinite list of pseudorandom numbers
17:19:48 <pumpkin_> SamB_XP: haven't tried yet, I'll try in a few
17:19:53 <EvilTerran> or carry around a stdgen
17:19:59 <Gracenotes> COBOL: it's like natural language!
17:20:02 <Gracenotes> anyone can do it!
17:20:03 <EvilTerran> or put it into the state of a Control.Monad.State
17:20:14 <Cale> jonaskoelker: If you want to write your own random generator, the appropriate class to write an instance of is RandomGen
17:20:16 <EvilTerran> (this being abstracted away for you by MonadRandom)
17:20:22 <p_l> Gracenotes: Right now, COBOL is one of the best paying jobs. Really
17:20:33 <jonaskoelker> Cale, EvilTerran: cool, I'll take a note of this
17:20:46 <wchogg> My father used to do COBOL as a job.  Said it was painfully boring.
17:21:02 <EvilTerran> @docs System.Random
17:21:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
17:21:05 <Olathe> That's why you write Haskell -> COBOL programs.
17:21:07 <blando> hmmm... i miss Clipper
17:21:08 <mmorrow> Cale: apparently the `split' method of that class is impossible to write for some prng's (eg mersenne twister)
17:21:12 <Cale> jonaskoelker: You need a type g of random states, and a definition of three functions:  next :: g -> (Int, g),  split :: g -> (g,g), and genRange :: g -> (Int, Int)  (which just tells what range of values the generator generates)
17:21:14 <Gracenotes> p_l: heh. the reason for that is certainly not why one would want, though
17:21:16 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
17:21:43 <SamB_XP> there was some library or something that my dad would have needed to know to keep doing that stuff :-(
17:21:44 <pumpkin_> SamB_XP: seems to work fine this time around :/
17:22:01 <SamB_XP> which is a shame because he's not making much as a jewelry returns processor, and the hours suck too
17:22:02 <Cale> mmorrow: I wouldn't expect it to be particularly hard to produce some split function.
17:22:16 <p_l> Gracenotes: Doesn't change the fact that I'd very much like to get my Alpha back to work, so that I could run the COBOL compiler I've got a license for :D
17:22:18 <Cale> mmorrow: But guaranteeing something about statistical independence is the tricky part.
17:22:28 <mmorrow> Cale: but is literally not possible for mersenne twister
17:22:31 <SamB_XP> I mean we've been going further and further into the red, not even considering college loans ...
17:22:47 <mmorrow> (from what i've been told, i don't know the technical reason for this though)
17:22:49 <Cale> mmorrow: Nah, you just use your input generator state to generate two new states.
17:23:32 <mmorrow> but that wouldn't be very independent
17:23:39 <EvilTerran> sounds like the two resultant states would have a lot less entropy
17:23:40 <mmorrow> yeah, that's the tricky part i guess
17:24:11 <Cale> If your input state is an integer, you could send g to g+1 and g-1 and then iterate one step on each of them.
17:24:59 <EvilTerran> don't mersenne twisters have more complicated state than that?
17:25:07 <Cale> They might.
17:25:17 <BMeph> blando: I have a friend who still uses Clipper...if you mean the DBMS. :)
17:25:21 * SamB_XP imagine's an array of colored spots
17:25:23 <mmorrow> hmm, does split have any requirements wrt independence of the two resulting streams?
17:25:55 <SamB_XP> it makes no guarentees!
17:26:00 <Cale> mmorrow: no
17:26:11 <SamB_XP> because it can't
17:26:14 <mmorrow> oh, then you could just make them be the same ;)
17:26:17 <Cale> mmorrow: It would be nice for them to be independent, but that's extremely hard to prove.
17:26:30 <SamB_XP> mmorrow: well, I think it does strongly imply that they aren't the same
17:26:51 <mmorrow> SamB_XP: but it doesn't guarantee it!
17:27:01 <Cale> I think for things to work sensibly they should be distinct from each other and from the input generator.
17:27:05 * mmorrow has never used split
17:27:07 <jonaskoelker> Cale, mmorrow: wouldn't them being independent require the program to be nondeterministic, unless the state is infinite?
17:27:20 <SamB_XP> it would be kinda stupid if they weren't distinct from eachother, yes ;-P
17:27:30 <SamB_XP> that's easy enough to do
17:27:31 <jonaskoelker> Cale: the name certainly is suggestive... ;)
17:27:31 <mmorrow> jonaskoelker: that's why i don't see the point of split
17:27:41 <EvilTerran> generate an infinite list of random numbers, take even entries for the first resultant generator and odd entries for the second?
17:27:52 <mokus> perhaps each generator could also carry a separate, slower but more suitable, generator that is used only to perturb states on a split
17:27:52 <EvilTerran> *even indexed ... odd indexed
17:27:59 <EvilTerran> :P
17:28:02 <jonaskoelker> :D
17:28:07 <SamB_XP> mokus: that sounds crazy
17:28:11 <jonaskoelker> good look finding even RSA primes ;)
17:28:32 <Cale> jonaskoelker: Independent in the sense that if you do something like zip (randoms g, randoms g'), the points you get are evenly distributed
17:28:36 <brodie> is there a reason a package installed with cabal wouldn't be listed as installed? i'm trying to install alex for yi, but after installing alex it says alex isn't installed
17:28:57 <ozy`> brodie: I'm getting the same thing
17:29:20 <jonaskoelker> oic
17:29:26 <Cale> EvilTerran: but that makes each split make the new generators slower
17:29:26 <mokus> SamB_XP: not really - during normal use it'd just cost you a reference because you'd just be passing along the same state for the 'splitting' generator
17:29:34 <EvilTerran> Cale, yeah, i know =/
17:29:39 <Cale> EvilTerran: However, if you can somehow encode that in the generator state without slowing things down, it'll work
17:30:49 <EvilTerran> i suspect you can't easily work out future outputs from a mersenne twister without working out all the outputs prior to that too
17:30:56 <mmorrow> also, System.Random is slow-motion-slow because of the split requirement
17:31:13 <mmorrow> (from what i understand)
17:31:29 <ozy`> is there an option I could provide to cabal-install to install a globally available library? (/usr/local or wherever)
17:32:05 <ozy`> or do I have to do that by hand?
17:32:09 <mmorrow> if it didn't have to support split, it could easily be made to use a prng that's actually usable for code that needs to have reasonable performance
17:32:20 <mokus> ozy`: --global?
17:32:21 <mmorrow> (like mersenne twister)
17:32:41 <EvilTerran> there *are* RNG algorithms for which you can calculate the n+k'th state easily from the n'th, but mersenne twister isn't one of them AFAIK
17:33:12 <the_unma1er> well
17:33:28 <mmorrow> any gen that you can calculate the n+k'th from the n'th would be unusable in any crypto situation
17:33:40 <the_unma1er> wtf is mercenne twister?
17:33:50 <SamB_XP> it's a fun variant of Twister
17:33:50 <brodie> ozy`: apparently alex has to be in the PATH
17:33:59 <SamB_XP> where you use an 128-spot mat
17:34:00 <EvilTerran> http://google.com/search?q=mersenne+twister&btnI
17:34:20 <SamB_XP> unfortunately, it's only playable by octopuses
17:34:28 <ozy`> brodie: the weird thing is, alex -is- in my PATH, but...
17:34:31 <mmorrow> the_unma1er: here's an implem http://www.augustsson.net/Darcs/MersenneTwister/
17:34:47 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random-pure64
17:34:51 <brodie> http://www.nabble.com/Cabal-%2B-yi-%2B-alex-problem.-td18727619.html this is what i'm reading
17:34:57 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random
17:35:16 <Cale> http://en.wikipedia.org/wiki/Mersenne_twister
17:35:18 <mmorrow> SamB: octopi !?
17:36:00 <brodie> mmorrow: octopodes
17:36:13 <mmorrow> heh, i just saw that on wikipedia (too?)
17:36:15 <Cale> okay, so the MT has an array of 634 integers for its state.
17:36:19 <Cale> er, 624
17:36:45 <Cale> What happens if we use one MT to generate two consecutive arrays of that length, and use those as new states?
17:36:59 <mmorrow> i'd really like to know why exactly split can't be written for it
17:37:11 <EvilTerran> mmorrow, octupi and great old ones, i think
17:37:25 <mmorrow> because if it could acceptably be done, we could have a fast System.Random!
17:37:55 <mmorrow> EvilTerran: i don't get it :)
17:38:06 <SamB_XP> mmorrow: cthulu ?
17:38:14 <Cale> split is actually a pretty important operation, I'm surprised that more PRNGs haven't focused on it in the past
17:38:27 <mmorrow> SamB_XP: syphillus ?
17:38:40 <Cale> Possibly because people use global mutable state for their PRNG state.
17:38:44 <SamB_XP> mmorrow: the mind-flayer ?
17:38:59 <mmorrow> SamB_XP: freddie kruger 3 ?
17:39:04 <SamB_XP> no!
17:39:08 <SamB_XP> you're confused, dude
17:39:19 * mmorrow pouts
17:39:49 <EvilTerran> IÃ¤! IÃ¤! Cthulhu fhtagn!
17:41:55 <mmorrow> Cale: i don't think System.Random has been update since really-really long ago, judging by the age of the references at the bottom of the code
17:42:23 <Cale> System.Random should be redone.
17:42:28 <mmorrow> yes!
17:42:34 <Cale> The IO interface is dumb too.
17:42:57 <brodie> is there a way to use cabal to build/install a package from local source?
17:43:01 <Cale> getStdGen is dumb
17:43:06 <Cale> There should only be newStdGen
17:43:09 <SamB_XP> brodie: cabal install from the source directory
17:43:15 <brodie> thanks
17:43:18 <Cale> (and it should use the system's entropy pool)
17:43:19 <mmorrow> Cale: i agree pending and acceptable alternative (re: IO)
17:43:24 <mmorrow> s/and/an/
17:43:40 <Cale> mmorrow: I mean to System.Random
17:43:47 <mmorrow> Cale: oh
17:44:17 <Cale> System.Random has a global mutable variable in it for no good reason.
17:44:29 <mmorrow> ah, yeah. i didn't even know getStdGen existed until randomly seeing someone use it on hpaste the other week
17:44:54 <Cale> It's initialised with the system clock too.
17:45:03 <mmorrow> oh dear
17:45:30 <Gracenotes> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms uses getStdGen...
17:46:43 <roconnor> @type getStdGen
17:46:44 <lambdabot> IO StdGen
17:46:52 <roconnor> @type newStdGen
17:46:53 <lambdabot> IO StdGen
17:47:10 <Cale> Yeah, we should probably replace every instance of getStdGen with newStdGen there
17:47:38 <Cale> Also, I'm seeing some of the bad repeated $ style there :)
17:47:46 <mmorrow> hehe
17:48:14 <SamB_XP> fixorate
17:48:34 <mmorrow> fixification initiative
17:48:59 <mmorrow> sounds like a political slogan
17:53:41 <hoopy> @t max
17:53:41 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:53:50 <hoopy> :t max
17:53:51 <lambdabot> forall a. (Ord a) => a -> a -> a
17:54:07 <hoopy> > max [1, 4]
17:54:08 <lambdabot>       Overlapping instances for Show ([t] -> [t])
17:54:08 <lambdabot>        arising from a use o...
17:54:22 <bd_> > maximum [1,4]
17:54:23 <lambdabot>   4
17:54:31 <hoopy> > max 1 4
17:54:32 <lambdabot>   4
17:54:46 <hoopy> max (2+3) (2+4)
17:54:58 <hoopy> > max (2+3) (2+4)
17:54:59 <lambdabot>   6
17:55:05 <hoopy> ...
17:55:25 <rastar> mmorrow: ping
17:55:34 <mmorrow> rastar: hi
17:55:51 <rastar> mmorrow: regards to your fix on
17:55:51 <rastar> mmorrow: regards to your fix on     Could not find module `Data.Generics':
17:55:55 <rastar> eh
17:56:01 <rastar> what was it ?
17:56:04 <mmorrow> oh yeah, did that help?
17:56:07 <mmorrow> ah, one sec
17:56:11 <rastar> mmorrow: havent got to it
17:56:14 <rastar> thanks
17:56:44 <Cale> Grr, okay, I've improved that a bit, but that article is just too broken for me to be bothered fixing it all the way.
17:56:51 <mmorrow> rastar: oh, i lost my history, i was just to:
17:57:39 <mmorrow> add "syb" to the "build-depends:" in the .cabal file of the package (located in ghc/libraries/<package-name> most likely) of the package that's having that problem
17:58:23 <mmorrow> but if you're trying to build the newest version, i'd be suprised if you were having an error during build
17:58:29 <pumpkin_> what does syb do?
17:58:37 <mmorrow> what version of ghc are you building it with?
17:58:58 <mmorrow> pumpkin_: it's the package Data.Generics.* got split off from base into
17:59:07 <rastar> 6.10.1
17:59:38 <mmorrow> rastar: ah, yeah. i'd try adding "syb" to the offending package's build-depends
18:00:14 <mmorrow> rastar: or, you could alternatively for that package to use base-3.whatever by doing
18:00:25 <mmorrow> s/base/base < 4/  in the .cabal file of that pkg
18:00:35 <mmorrow> (and /don't/ add syb)
18:01:13 <mmorrow> (these are my own personal opinions and not "official" fixes (although they could be, i'm not sure))
18:03:04 <gwern> woo, my hoogles built
18:03:18 <gwern> all 452 of them, and an unaccountable number of main.txts
18:04:39 <rastar> mmorrow: thanks. ill give that a go :P
18:05:05 <gwern> ouch, 21M
18:05:14 <gwern> hope gzip can get  that down to something reasonable
18:05:16 <chylli> the link about lambda shell in http://www.haskell.org/communities/11-2008/html/report.html is not correct.
18:06:04 <gwern> phew, down to 5.3M. gmail should be able to handle that
18:16:39 <Davbo> Hey all, is there an easier way to do something like this? http://hpaste.org/13158
18:16:52 <Davbo> I was wondering if I could use a list comprehension but don't know much about them
18:18:31 <Davbo> Sorry, I meant this http://hpaste.org/13158#a1 - if 0 make a new list, if 1 add to the last list that's there
18:18:59 <dons> an easier way? let's      see..
18:20:47 <dons> complicated filtering logic, so i'd say use pattern matching, http://hpaste.org/13158#a2
18:22:56 <dons> ?users
18:22:56 <lambdabot> Maximum users seen in #haskell: 586, currently: 527 (89.9%), active: 16 (3.0%)
18:24:38 <hoopy> foo
18:24:39 <hoopy> ?users
18:24:40 <lambdabot> Maximum users seen in #haskell: 586, currently: 525 (89.6%), active: 15 (2.9%)
18:25:42 <hoopy> dons: you're one of the authors of RWH, right?
18:28:07 <dons> yup
18:28:37 <Davbo> dons: "Occurs check: cannot construct the infinite type: t = [t]" :-( is there a way to assure it that a 0 will appear before 1?
18:29:18 <dons> oh, occurs check just means there's a typo (we said an element had the same type as the list of elements somewhere)
18:29:34 <dons> using 1 and 0 instead of booleans?
18:29:50 <JohnnyL> :t f x y = (f x) y
18:29:51 <dons> so q is a seed?
18:29:51 <lambdabot> parse error on input `='
18:30:03 <dons> and p is some predicate? or can it have values other than 0 and 1?
18:30:58 <gwern> (whew. here's hoping my attachment makes it to ndm in one piece!)
18:31:15 <Davbo> hmm, there are other values but they're dealt with before this code is run
18:31:21 <gwern> (in retrospect, I probably should've just uploaded it to community.haskell.org)
18:35:33 <Davbo> Sorry dons, still trying to get my head round the code (it's not mine)
18:37:18 <dons> so what are you trying to do, at a high level?
18:38:26 <Davbo> handle a list that looks like this: [(0,"c0"),(1,"b"),(1,"a"),(0,"c1"),(1,"a"),(1,"b")] and for each thing with a 0 put the following 1's onto a list with it
18:39:05 <Davbo> if that makes sense; i'm slowly going crazy :-)
18:39:51 <dons> ah, so maybe a list comp. is ok.
18:39:56 <dons> so this is a homework problem?
18:40:16 <Davbo> you think? I'll quickly look into them
18:40:24 <dons> > map (first toEnum) [(0,"c0"),(1,"b"),(1,"a"),(0,"c1"),(1,"a"),(1,"b")]
18:40:25 <lambdabot>   [((),"c0"),(* Exception: Prelude.Enum.().toEnum: bad argument
18:40:34 <Davbo> they're basically set comprehension?
18:40:35 <dons> > map (first toEnum) [(0,"c0"),(1,"b"),(1,"a"),(0,"c1"),(1,"a"),(1,"b")] :: [(Bool,String)]
18:40:37 <lambdabot>   [(False,"c0"),(True,"b"),(True,"a"),(False,"c1"),(True,"a"),(True,"b")]
18:41:21 <dons> that's right.
18:41:39 <dons> > [ z | (x,y) <- [(False,"c0"),(True,"b"),(True,"a"),(False,"c1"),(True,"a"),(True,"b")], z = [y] ]
18:41:40 <lambdabot>   <no location info>: parse error on input `='
18:41:44 <dons> > [ z | (x,y) <- [(False,"c0"),(True,"b"),(True,"a"),(False,"c1"),(True,"a"),(True,"b")], let z = [y] ]
18:41:45 <lambdabot>   [["c0"],["b"],["a"],["c1"],["a"],["b"]]
18:47:21 <Davbo> thanks dons think i've got it
18:48:13 <dons> great!
18:48:41 <hoopy> dons: i bought the book a few days ago.  great work
18:48:45 <hoopy> makes one scratch the noggin
18:50:31 <blackdog> dons: oh, mine came too. the regex chapter was actually really useful, i'd always dismissed haskell regexes as unusable
18:50:47 <blackdog> so, y'know. thanks.
18:51:53 <mmorrow> , [$tyQ|\f x y -> f x y|] == [$tyQ|\f x y -> (f x) y|]
18:51:58 <lunabot>  True
18:52:17 <mmorrow> , [$tyQ|\f x y -> f x y|] == [$tyQ|\f x y -> f (x y)|]
18:52:22 <lunabot>  False
18:52:45 <mmorrow> , [$ty|\f x y -> f (x y)|]
18:52:50 <lunabot>  forall a b c . (b -> a) -> (c -> b) -> c -> a
18:52:58 <mmorrow> , [$ty|\f x y -> f x y|]
18:53:03 <lunabot>  forall a b c . (c -> b -> a) -> c -> b -> a
18:53:07 <hoopy> , "foo"
18:53:09 <lunabot>  "foo"
18:53:17 <mmorrow> , [0..]
18:53:19 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
18:53:31 <hoopy> , [1,1..1]
18:53:32 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:53:45 <mmorrow> , fix ((0:) . scanl (+) 1)
18:53:47 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:53:52 <hoopy> nice!
18:53:59 <mmorrow> that's my fav fib
18:54:05 <hoopy> too bad i don't understand it
18:54:19 <Olathe> @src fix
18:54:19 <lambdabot> fix f = let x = f x in x
18:54:27 <mmorrow> , fix (scanl (+) 1)
18:54:29 <lunabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
18:54:34 <hoopy> (0..10).inject([0,1]0{|r,x|r<<r[x]+r[x+1]}
18:54:36 <mmorrow> , scanl (+) 1 [0]
18:54:39 <lunabot>  [1,1]
18:54:39 <Olathe> > let x = ((0:) . scanl (+) 1) x in x
18:54:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:54:58 * hoopy is rubyist
18:55:05 <hoopy> trying to learn the haskell
18:55:12 <Olathe> > let x = 0:(scanl (+) 1 x) in x
18:55:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:55:17 <Olathe> > let x = (scanl (+) 1 x) in x
18:55:18 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:56:03 <Olathe> > let fibs = 0:(scanl (+) 1 fibs) in fibs
18:56:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:56:14 <mmorrow> , let f = scanl (+) 1 in f ([0] ++ f [0])
18:56:16 <lunabot>  [1,1,2,3]
18:56:36 <mmorrow> , let f = scanl (+) 1 in f ([0] ++ f ([0] ++ f [0]))
18:56:38 <lunabot>  [1,1,2,3,5,8]
18:56:40 <Olathe> > scanl (+) 1 [0]
18:56:41 <lambdabot>   [1,1]
18:56:52 <mmorrow> , let f = scanl (+) 1 in [0] ++ f ([0] ++ f ([0] ++ f ([0] ++ f [0])))
18:56:54 <lunabot>  [0,1,1,2,3,5,8,13,21]
18:56:57 <Olathe> > scanl (+) 1 [0, 1, 1]
18:56:58 <lambdabot>   [1,1,2,3]
18:56:59 <mmorrow> , fix ((0:) . scanl (+) 1)
18:57:00 <hoopy> > scanl (x) 1 [0..]
18:57:01 <lambdabot>   Couldn't match expected type `a -> b -> a'
18:57:01 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:57:18 * chessguy just got RWH as an early christmas present...without even throwing out any hints!
18:57:32 <mmorrow> so it just keeps calling itself on the result of already having done that :)
18:57:34 <hoopy> chessguy: me too, but i gifted it to myself
18:57:42 <chessguy> hoopy:  heh. nice
18:58:11 <Olathe> > let fibs = 1:(scanl (+) 0 fibs) in fibs
18:58:12 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:58:16 <hoopy> chessguy: did you get the dead tree version?
18:58:19 <chessguy> i've read (skimmed, really) the first 4 chapters already
18:58:33 <chessguy> hoopy:  it would be hard to be given the online version as a present :)
18:58:43 <mmorrow> > scanl (+) 1 [0..]
18:58:44 <lambdabot>   [1,1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,25...
18:58:56 <hoopy> chessguy: USB drive w/ RWH on the volume
18:58:57 <hoopy> :P
18:59:01 <Olathe> > scanl (const "omg") "hi" ["!", "!"]
18:59:02 <lambdabot>   Couldn't match expected type `b -> a'
18:59:03 <chessguy> heh
18:59:16 <Olathe> > scanl (\a b -> "omg") "hi" ["!", "!"]
18:59:18 <lambdabot>   ["hi","omg","omg"]
18:59:23 <Olathe> Ahh.
18:59:24 <hoopy> i've worked through the third chapter, working on the exercises at the end of that
18:59:25 <mmorrow> > scanl (const (const "omg")) "hi" ["!", "!"]
18:59:26 <lambdabot>   ["hi","omg","omg"]
18:59:30 <chessguy> hoopy: i would have just deleted it and used the USB drive for other stuff :)
18:59:41 <hoopy> the next page is the beggining of chapter 4
18:59:52 <Olathe> > let fibs = 1:1:(scanl1 (+) fibs) in fibs
18:59:54 <lambdabot>   [1,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:00:01 <mmorrow> , scanl f a [b,c,d,e,f,g,h,i]
19:00:04 <Olathe> > let fibs = 1:(scanl1 (+) fibs) in fibs
19:00:04 <lunabot>  luna: Ambiguous occurrence `i'
19:00:05 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
19:00:07 <chessguy> hoopy:  ah yes, it looks like it has some good exercises
19:00:08 <mmorrow> , scanl f a [b,c,d,e,f,g,h]
19:00:11 <Olathe> Bah.
19:00:12 <lunabot>  [a,f a b,f (f a b) c,f (f (f a b) c) d,f (f (f (f a b) c) d) e,f (f (f (f...
19:00:22 <hoopy> chessguy: ones that you'd almost think that the material hasn't prepared you for
19:00:40 <hoopy> some of them are just really easy
19:00:47 <Olathe> Ahh.
19:00:54 <chessguy> hoopy: and it doesn't appear to give the answers either
19:01:05 <hoopy> chessguy: it doesn't. not that i know of
19:01:12 <Olathe> > (f >>= g >>= h) [a, b, c, d]
19:01:13 <lambdabot>   Add a type signature
19:01:21 <hoopy> you just have to keep going at it until you produce the result it asks for
19:01:28 <Olathe> > (id >>= g >>= h) [a, b, c, d]
19:01:29 <lambdabot>   Add a type signature
19:01:32 <ozy`> @pl (f >>= g >>= h) [a, b, c, d]
19:01:32 <lambdabot> (f >>= g >>= h) [a, b, c, d]
19:01:40 <mmorrow> , let fibs = 0 : scanl (+) 1 fibs in fibs
19:01:40 <ozy`> @unpl (f >>= g >>= h) [a, b, c, d]
19:01:40 <lambdabot> ((f >>= g) >>= h) [a, b, c, d]
19:01:42 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
19:01:51 <Olathe> > (return a >>= g >>= h) [b, c, d]
19:01:52 <lambdabot>   Add a type signature
19:02:01 <hoopy> > let fibs = 0:(scanl1 (+) fibs) in fibs
19:02:02 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:02:07 <hoopy> jebus
19:02:12 <Olathe> > ((return a :: (->) Expr) >>= g >>= h) [b, c, d]
19:02:13 <lambdabot>       `(->) Expr' is not applied to enough type arguments
19:02:13 <lambdabot>      Expected kind ...
19:02:21 <chessguy> hoopy:  i really want to know what the list of cities in chapter 1 have in common
19:02:23 <hoopy> lambdabot is getting abused
19:02:31 <Olathe> @slap lambdabot
19:02:32 * lambdabot orders her trained monkeys to punch lambdabot
19:03:18 <hoopy> chessguy: i'm looking at the page right now
19:03:28 <hoopy> and i'm usually pretty good at trivia
19:03:30 <hoopy> got nothin
19:05:08 * ozy` takes hoc apart with a hammer
19:05:30 <mmorrow> , fix (\xs -> [0,42,xs!!0,xs!!2])
19:05:32 <lunabot>  [0,42,0,0]
19:05:36 <mmorrow> , fix (\xs -> [0,42,xs!!0,xs!!1])
19:05:38 <lunabot>  [0,42,0,42]
19:05:44 <mmorrow> , fix (\xs -> [0,42,xs!!0])
19:05:46 <lunabot>  [0,42,0]
19:05:46 <mmorrow> , fix (\xs -> [0,42,xs!!1])
19:05:48 <lunabot>  [0,42,42]
19:05:49 <mmorrow> , fix (\xs -> [0,42,xs!!2])
19:05:51 <lunabot>  luna: out of memory (requested 2097152 bytes)
19:06:02 <mmorrow> the `xs' is the eventual result
19:06:14 <mmorrow> so xs!!3 depends on itself forever
19:06:32 <mmorrow> err, xs!!3 does too, but i meant to say xs!!2
19:07:26 <mmorrow> , fix (\xs -> [0,42,99xs!!2])
19:07:28 <lunabot>  luna: No instance for (GHC.Num.Num ([a] -> [a]))
19:07:29 <mmorrow> , fix (\xs -> [0,42,99,xs!!2])
19:07:31 <lunabot>  [0,42,99,99]
19:07:45 <hoopy> i saw somebody use `approxRatio` on lambdabot.  what module is that in?
19:07:56 <Olathe> @index approxRatio
19:07:56 <lambdabot> bzzt
19:07:59 <Olathe> I'm not sure.
19:08:01 <mmorrow> i'm not sure
19:08:04 <mmorrow> heh
19:08:16 <hoopy> @index bzzt
19:08:16 <lambdabot> bzzt
19:08:23 <mmorrow> , approxRatio
19:08:24 <lunabot>  luna: Not in scope: `approxRatio'
19:08:28 <mmorrow> > approxRatio
19:08:29 <lambdabot>   Not in scope: `approxRatio'
19:08:37 <Olathe> It's evilly custom.
19:08:38 <hoopy> > bzzt
19:08:39 <lambdabot>   Not in scope: `bzzt'
19:08:40 <mmorrow> are you sure it was called that?
19:08:49 <mmorrow> , toRational pi
19:08:51 <Olathe> @let bzzt = fun "bzzt" :: Expr
19:08:51 <lunabot>  884279719003555 % 281474976710656
19:08:52 <lambdabot>  Defined.
19:08:53 <hoopy> , Data.Ratio
19:08:54 <Olathe> > bzzt
19:08:54 <lunabot>  luna: Not in scope: data constructor `Data.Ratio'
19:08:55 <lambdabot>   bzzt
19:09:14 <hoopy> :m Data.Ratio
19:09:21 <hoopy> awwww
19:09:36 * wli just wishes there were a way to resolve the nontermination issue wrt. subtraction of lazy continued fractions.
19:09:39 <mmorrow> maybe you meant "toRational"
19:09:46 <Olathe> Hmm...
19:10:06 <mmorrow> wli: is that kinda like:
19:10:10 <mmorrow> , nub [0..]
19:10:12 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
19:10:17 <mmorrow> i meant
19:10:22 <mmorrow> , nub (repeat 0)
19:10:29 <lunabot>  Killed.
19:10:35 <hoopy> @src fix
19:10:35 <lambdabot> fix f = let x = f x in x
19:10:47 <wli> mmorrow: I don't remember precisely, but I doubt it.
19:10:50 <mmorrow> fix f = f (fix f)
19:11:40 <mmorrow> wli: i mean in the sense that you know the answer, but the computer doesn't know it can just stop
19:11:42 <hoopy> @src bzzt
19:11:42 <lambdabot> Source not found. I am sorry.
19:11:50 <mmorrow> wli: ?
19:11:53 <Davbo> wli: thanks for your revision on my paste :)
19:12:05 <wli> Davbo: No problem.
19:12:44 * hoopy hasn't had to think recursively this much since he was doing projecteuler stuff
19:13:33 <mmorrow> , fix (\k (x:xs) -> if x==5 then [] else x : k x) [0..]
19:13:35 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = [t]
19:13:43 <mmorrow> , fix (\k (x:xs) -> if x==5 then [] else x : k xs) [0..]
19:13:45 <lunabot>  [0,1,2,3,4]
19:14:42 <Olathe> > let approxRatio n prec = f' n (prec/2) 1 where f' n prec denom = if abs (fromRational guess - n) < prec then guess else f' n prec (denom + 1) where guess = round (n * fromIntegral denom) % denom in approxRatio pi 0.01
19:14:43 <lambdabot>   22%7
19:14:46 <mmorrow> , let f (x:xs) = if x == 5 then [] else x : f xs
19:14:47 <Olathe> How's that ?
19:14:48 <lunabot>  luna: parse error on input `)'
19:14:53 <Olathe> > 22/7
19:14:54 <lambdabot>   3.142857142857143
19:14:56 <mmorrow> , let f (x:xs) = if x == 5 then [] else x : f xs in f [0..]
19:14:57 <lunabot>  [0,1,2,3,4]
19:15:04 <Olathe> > let approxRatio n prec = f' n (prec/2) 1 where f' n prec denom = if abs (fromRational guess - n) < prec then guess else f' n prec (denom + 1) where guess = round (n * fromIntegral denom) % denom in approxRatio pi 0.0001
19:15:06 <lambdabot>   355%113
19:15:47 <Olathe> @let approxRatio n prec = f' n (prec/2) 1 where f' n prec denom = if abs (fromRational guess - n) < prec then guess else f' n prec (denom + 1) where guess = round (n * fromIntegral denom) % denom
19:15:48 <lambdabot>  Defined.
19:15:53 <mmorrow> the case when you're just doing fix (\x -> ...)  (one arg in the lambda) is the only one that's weird to understand (or was for me at least)
19:16:14 <Olathe> > map (10.0**) [1..]
19:16:15 <lambdabot>   [10.0,100.0,1000.0,10000.0,100000.0,1000000.0,1.0e7,1.0e8,1.0e9,1.0e10,1.0e...
19:16:24 <Olathe> > map (10.0**) [(-1), (-2)..]
19:16:25 <lambdabot>   [0.1,1.0e-2,1.0e-3,1.0e-4,1.0e-5,1.0e-6,1.0e-7,1.0e-8,1.0e-9,1.0e-10,1.0e-1...
19:16:25 <mmorrow> and when i saw an example using fix (\k x -> ...) (two (or more) args) i was like ohhhhhh
19:16:45 <mmorrow> @type fix (\k x -> undefined)
19:16:47 <lambdabot> forall t a. t -> a
19:16:53 <mmorrow> @type fix (\k x y -> undefined)
19:16:54 <lambdabot> forall t t1 a. t -> t1 -> a
19:17:31 <mmorrow> , fix (\_ -> 0)
19:17:33 <lunabot>  0
19:18:15 <Olathe> > map ((approxRatio pi).(10.0**).(*(-1))) [0..10]
19:18:27 <lambdabot>   [3%1,19%6,22%7,267%85,355%113,355%113,355%113,88018%28017,102573%32650,1043...
19:18:39 <hoopy> map (2**) [1..]
19:18:51 <hoopy> > map (2**) [1..]
19:18:51 <pumpkin_> wow, that 355%113 is pretty good
19:18:53 <lambdabot>   [2.0,4.0,8.0,16.0,32.0,64.0,128.0,256.0,512.0,1024.0,2048.0,4096.0,8192.0,1...
19:18:57 <Olathe> Yeah :)
19:19:00 <hoopy> hmm Flaot
19:19:01 <mmorrow> , 355 / 113
19:19:03 <lunabot>  3.1415929203539825
19:19:06 <hoopy> > map (2*) [1..]
19:19:08 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
19:19:09 <mmorrow> , pi
19:19:10 <lunabot>  3.141592653589793
19:19:14 <pumpkin_> good for 355 / 113
19:19:17 <hoopy> > 4 * (atan 1)
19:19:19 <lambdabot>   3.141592653589793
19:19:21 <mmorrow> , abs (pi - (355/113))
19:19:23 <lunabot>  2.667641894049666e-7
19:19:47 <hoopy> euler's equation?
19:19:58 * hoopy doesn't know a whole lot about the maths
19:19:58 <pumpkin_> what isn't euler's
19:20:01 <Olathe> What's that ?
19:20:02 <sw17ch> Do typeclasses require any vtable-like lookups at runtime?
19:20:15 <hoopy> > exp 1
19:20:16 <lambdabot>   2.718281828459045
19:20:22 <pumpkin_> @src exp
19:20:22 <lambdabot> Source not found. My mind is going. I can feel it.
19:20:28 <Olathe> > map ((approxRatio (exp 1)).(10.0**).(*(-1))) [0..10]
19:20:36 <Olathe> exp's source depends on the type.
19:20:36 <mmorrow> fmap (\x -> abs(pi-(fromIntegral . numerator) x/(fromIntegral . denominator) x)) $ map ((approxRatio pi).(10.0**).(*(-1))) [0..10]
19:20:41 <mmorrow> > fmap (\x -> abs(pi-(fromIntegral . numerator) x/(fromIntegral . denominator) x)) $ map ((approxRatio pi).(10.0**).(*(-1))) [0..10]
19:20:43 <lambdabot>   thread killed
19:20:50 <mmorrow> um
19:20:55 <lambdabot>   [0.14159265358979312,2.5074013076873403e-2,1.2644892673496777e-3,4.16183001...
19:21:00 <Olathe> My approxRatio thing is slow.
19:21:00 <mmorrow> oh
19:21:01 <hoopy> > (/) (sqrt 5) 2 + 0.5
19:21:02 <lambdabot>   1.618033988749895
19:21:11 <Olathe> > map ((approxRatio (exp 1)).(10.0**).(*(-1))) [0..5]
19:21:12 <lambdabot>   [3%1,11%4,19%7,87%32,193%71,1264%465]
19:21:14 <wli> unfoldr (\x -> let y = properFraction x in do { guard (y /= (0, 0)) ; return y })
19:21:30 <mmorrow> >
19:23:52 <Olathe> > map ((approxRatio (sqrt 2)).(10.0**).(*(-1))) [0..5]
19:23:53 <lambdabot>   [1%1,7%5,17%12,41%29,239%169,577%408]
19:24:20 <sw17ch> Do type classes require any vtable-like lookups at runtime or is GHC smart enough to figure those things out?
19:24:38 <wli> unfoldr (\x -> let (q, r) = properFraction x in do { guard (q /= 0) ; return (q, if r == 0 then 0 else recip r) }) -- sorry
19:29:42 <sw17ch> @seen cale
19:29:42 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 1h 32m 58s ago.
19:35:45 <porges> :o channel is quiet for once?
19:36:27 <Olathe> You've ruined it !
19:36:42 <Axman6> we were going for the world record! thanks porges
19:37:23 <hoopy> 0_o
19:38:06 <porges> D:
19:38:48 <pumpkin_> fail
19:38:59 <pumpkin_> Axman6: how dem eulers workin for you?
19:39:04 <Axman6> omg, shut up guys!
19:39:23 <Axman6> pumpkin_: i haven't been home. and haven't really worked on PE since last holidays
19:39:30 <pumpkin_> fail
19:41:32 <wli> fromCF :: RealFrac rf => [Integer] -> [rf] ; fromCF as = let recurse x0 x1 = let xs = x0 : x1 : zipWith3 (((+) .) . (*)) as (tail xs) xs in xs in drop 2 $ zipWith ((/) `on` fromIntegral) (recurse 0 1) (recurse 1 0)
19:45:40 <porges> > createDerivativeWork "http://haskell.org/sitewiki/images/5/57/Haskell-logo-6up.png"
19:45:41 <lambdabot>   "http://haskell.org/sitewiki/images/2/25/Testhask.png"
19:45:57 <pumpkin_> lol
19:46:13 <wli> With toCF = unfoldr (\x -> let (q, r) = properFraction x in do { guard (q /= 0) ; return (q, if r == 0 then 0 else recip r) }) you get fromCF . toCF generating a sequence of best rational approximations.
19:47:18 * wli ponders how to compare algebraic numbers in real radical extensions of Q.
19:48:43 <wli> (e.g. Q(2^(1/3), 3^(1/5), 5^(1/7), (2^(1/3)+3^(1/5))^(1/11), (3^(1/5)+5^(1/7))^(1/13))
19:50:33 <cjay> my second logo attempt (sf mystery style) http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
19:52:16 <wli> I guess it can be reduced to determining whether things are positive and/or determining whether one all-positive linear combination is greater than another.
19:52:20 <august> does âºâº mean something in haskell?
19:52:33 <pumpkin_> >> does
19:52:33 <Cale> august: yes
19:52:42 <pumpkin_> you could make âºâº mean something too
19:52:42 <Olathe> @src (>>)
19:52:42 <lambdabot> m >> k      = m >>= \_ -> k
19:53:03 <Olathe> @do m >>= \_ -> k
19:53:04 <lambdabot> m >>= \_ -> k not available
19:53:07 <Cale> If x and y are actions in some monad, then (x >> y) is the action which when run, will run x followed by y
19:53:11 <Olathe> @redo m >>= \_ -> k
19:53:11 <lambdabot> do { _ <- m; k}
19:53:18 <mmorrow> , let (âºâº) = (=<<) in id âºâº [[0],[1]]
19:53:19 <lunabot>  luna: lexical error at character '\8250'
19:53:21 <Cale> @redo x >> y
19:53:22 <lambdabot> do { x; y}
19:53:31 <Olathe> @help do
19:53:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:53:47 <mmorrow> , fmap isSymbol "âºâº"
19:53:49 <lunabot>  [False,False]
19:53:54 <mmorrow> i guess you can't
19:53:56 <august> that first pic makes it look like âºâº rather than >>
19:54:15 <mmorrow> âºâº comes out as looking like "''" in my irc client
19:54:21 <Cale> What character is âº ?
19:54:27 <mmorrow> , "âºâº"
19:54:29 <lunabot>  "\8250\8250"
19:54:30 <august> â¥â§4
19:54:39 <mmorrow> , utf8enc "âºâº"
19:54:41 <lunabot>  "\226\128\186\226\128\186"
19:54:49 <Cale> U+203A SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
19:54:53 <Olathe> > let âºâº = ("Go go "++) in âºâº "lambdabot"
19:54:54 <lambdabot>   <no location info>: lexical error at character '\8250'
19:54:55 <mmorrow> it's two chars also
19:54:56 <Olathe> Bah.
19:55:02 <august> Â»
19:55:04 <Olathe> Foolish Unicode !
19:55:04 <august> there it is
19:55:10 <mmorrow> they're not symbol chars
19:55:33 <mmorrow> so you can't use them as haskell syms like +, *, etc
19:55:34 <Cale> Isn't there a unicode property for punctuation and symbols?
19:55:46 <mmorrow> , fmap isSymbol "âºâº"
19:55:48 <lunabot>  [False,False]
19:55:51 <mmorrow> , fmap isPunctuation "âºâº"
19:55:54 <lunabot>  [True,True]
19:55:55 <august> let Â» = ("Go go "++) in Â» "lambdabot"
19:55:58 <august> > let Â» = ("Go go "++) in Â» "lambdabot"
19:55:59 <lambdabot>   <no location info>: parse error on input `Â»'
19:56:06 <Cale> GHC should treat unicode punctuation as symbol characters.
19:56:10 <mmorrow> , isSymbol "Â»"
19:56:12 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
19:56:17 <mmorrow> , fmap isSymbol "Â»"
19:56:18 <lunabot>  [False]
19:56:25 <mmorrow> , fmap isPunctuation "Â»"
19:56:27 <lunabot>  [True]
19:56:28 <pumpkin_> there should be a double version of that char
19:56:30 <Cale> (that is, it ought to, rather than "it does")
19:56:46 <Saizan_> Cale: but it does, afaik
19:56:53 <Olathe> , fmap isEvil "Â»"
19:56:54 <lunabot>  luna: Not in scope: `isEvil'
19:56:55 <mmorrow> , isPunctuation '.'
19:56:57 <lunabot>  True
19:56:58 <Olathe> > fmap isEvil "Â»"
19:56:59 <lambdabot>   [True]
19:57:01 <august> Â» is the doubled version
19:57:02 <Cale> hmm
19:57:02 <mmorrow> , isPunctuation ','
19:57:04 <lunabot>  True
19:57:08 <Saizan_> i.e. you can use  Â»
19:57:13 <mmorrow> Cale: i guess it picks and chooses
19:57:15 <august> unless you mean Â»Â»
19:57:44 <mmorrow> , let (Â») = (+) in 2 Â» 3
19:57:46 <lunabot>  luna: lexical error at character '\187'
19:57:55 <Cale> Saizan_: apparently you can't use â¹
19:58:00 <mmorrow> , isSymbol 'Â»'
19:58:02 <lunabot>  False
19:58:03 <Saizan_> > let (Â») = (+) in 2 Â» 3
19:58:05 <lambdabot>   5
19:58:09 <mmorrow> weird
19:58:19 <Cale> > let (â¹) = (<) in 2 â¹ 3
19:58:20 <lambdabot>   <no location info>: lexical error at character '\8249'
19:58:21 <mmorrow> maybe that was disallowed in 6.10?
19:58:21 <Saizan_> luna has still some unicode bug :P
19:58:49 <Cale> I tried it with a compiled program as well
19:59:18 <mmorrow> , let (â) = elem in 5 â [0..10]
19:59:20 <august> > let (â) = (+) in 2 â 2
19:59:21 <lunabot>  True
19:59:22 <lambdabot>   4
19:59:24 <Saizan_> uhm, yeah, my 6.10.1 ghci doesn't like let (Â») = (+) in 2 Â» 3 either
19:59:39 <hoopy> > 5 elem [5]
19:59:40 <Cale> ghci doesn't handle unicode properly
19:59:40 <lambdabot>       No instance for (Num ((a -> [a] -> Bool) -> [t] -> a1))
19:59:40 <lambdabot>        arising ...
19:59:47 <mmorrow> yeah i think this has come up before with Â»
19:59:54 <Cale> But in a .hs file you should be okay
19:59:59 <mmorrow> i dunno what prompted the change though
20:00:10 <mmorrow> Cale: in  6.10?
20:00:11 <Cale> (but it still doesn't handle â¹ )
20:00:22 <Axman6> jeffwheeler: seems people like your >â= logo idea
20:00:30 <Cale> mmorrow: I'm not certain what the change is.
20:00:36 <mmorrow> Cale: me neither
20:00:36 <Axman6> (not technically a lambda there)
20:00:51 <mmorrow> Cale: but i think disallowing Â» is part of it
20:00:57 <mmorrow> > isSymbol 'Â»'
20:00:59 <lambdabot>   False
20:01:03 <mmorrow> hmm
20:01:25 <Saizan_> reporting "lexical error at character '\187'" looks like an utf8 fail
20:01:31 <mmorrow> yeah, true
20:01:39 <mmorrow> but i'm not doing parsing
20:01:40 <Olathe> UTFail
20:01:43 <mmorrow> (just ghc)
20:01:52 <Saizan_> yeah, i mean in ghc
20:01:56 <mmorrow> , let (â) = elem in 5 â [0..10]
20:01:58 <lunabot>  True
20:01:58 <mmorrow> but this works
20:02:00 <Cale> Why is this so hard to get right?
20:02:08 <mmorrow> seriously
20:02:16 <Cale> We really need to treat text as unicode by default.
20:02:19 <hoopy> :t elem
20:02:20 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
20:02:23 <mmorrow> i think it's just epic since everything has to be changed over
20:02:35 <mmorrow> like, ghc's error messages still mangle unicode idents
20:04:01 <mmorrow> and i pity tha foo that has to go in and find those and fix them
20:04:06 <Saizan_> well they try to use a compact representation, so it's a bit harder
20:05:08 <mmorrow> that's true too, but the places they're using strings in the first place, they're already dealing with 32bit chars
20:06:36 <BMeph> Olathe: Double-UTFail... ;p
20:06:56 <roconnor> > log(2)/2
20:06:58 <lambdabot>   0.34657359027997264
20:07:14 <roconnor> > let a = log(2)/2 in exp(a)
20:07:16 <lambdabot>   1.414213562373095
20:07:21 <roconnor> > let a = log(2)/2 in exp(2*a)
20:07:23 <Saizan_> so, who reports this bug?:)
20:07:23 <lambdabot>   2.0
20:07:40 <porges> Cale, it's because it isn't a symbol
20:07:41 <roconnor> > let a = log(2)/2 in exp(90/365)
20:07:43 <lambdabot>   1.2796355904864296
20:08:23 <Saizan_> i can confirm that it's a regression from 6.8.2
20:08:39 <Cale> porges: btw, that's a nice font you added to the logo :)
20:08:49 <roconnor> > let a = log(2)/2 in exp(90/365*a)
20:08:51 <lambdabot>   1.0892141813623921
20:08:54 <porges> its a super logo :P
20:09:02 <Cale> :)
20:09:32 <BMeph> > isSymbol '.'
20:09:33 <lambdabot>   False
20:09:50 <BMeph> lambdabot: FAIL! >:(
20:10:04 <porges> > isPunctuation '.'
20:10:06 <lambdabot>   True
20:10:16 <porges> BMeph: FAIL! >:P
20:10:18 <roconnor> > let  a = log(2)/2 in log(1-0.0892141813623921)/a
20:10:20 <lambdabot>   -0.2696325333528308
20:10:30 <roconnor> > let  a = log(2)/2 in log(1-0.0892141813623921)/a*365
20:10:32 <lambdabot>   -98.41587467378325
20:11:32 <porges> > map isSymbol ['Â»','â','â','.','â¹']
20:11:34 <lambdabot>   [False,True,True,False,False]
20:11:46 <porges> > map isPunctuation ['Â»','â','â','.','â¹']
20:11:48 <lambdabot>   [True,False,False,True,True]
20:12:17 <Olathe> Heheh http://haskell.org/haskellwiki/Image:Haskell-logo-revolution.png
20:13:17 <porges> Cale: I think the mountain is probably the most 'iconic' out of the symbols on that page
20:13:23 <Saizan_> @faq can haskell save us from capitalism?
20:13:23 <lambdabot> The answer is: Yes! Haskell can do that.
20:13:57 <roconnor> The revolution will be declared!
20:14:00 <Cale> I didn't want something which was purely typographical, but I did manage to work in the lambda :)
20:14:05 <porges> >Î»= is nice, but it's not much more than a collection of lines
20:14:25 <roconnor> porges: that makes it easy to tag an underpass
20:15:19 <Gracenotes> about the bind/lambda logo -- what colors should it be?
20:15:38 <porges> I chose a bad yellow
20:15:42 <porges> it's almost green
20:15:47 <porges> but my laptop screen sucks :P
20:15:50 <Gracenotes> hm. but what *should* it be?
20:16:20 <Gracenotes> the cool blue/grey in the original is cool, but not very memorable ;)
20:16:42 <porges> Cale: you could stick some forall symbols in as birds :D
20:17:04 <Cale> hehe :)
20:17:19 <jeffz`> hahah @ skull and crossbones
20:17:44 <roconnor> I can't believe people get CS degrees without knowing what coroutines are.
20:17:57 <jeffz`> Cale: your one looks really impressive
20:18:21 <dolio> I don't think any of my classes covered what coroutines are.
20:18:24 <Cale> thanks :)
20:18:29 <Axman6> roconnor: what are they? :)
20:18:30 <dolio> Not that I didn't know by the time I got my degree.
20:18:54 <roconnor> Axman6: they are subroutines that can be suspeded and rentered
20:19:05 <roconnor> well
20:19:06 <roconnor> resumed
20:19:10 <Cale> My friend in uni made the claim that those who don't know about coroutines are doomed to reinvent them ;)
20:19:33 <dolio> I think I learned about them by mucking about implementing them with continuations in ruby.
20:19:44 <Axman6> reentered? (or re-entered...) i thought you spelt rented wrong at first :P
20:19:52 <roconnor> Axman6: they are very close to cooperative threading
20:19:54 <porges> IEnumerable<T> in C#
20:19:56 <roconnor> if not the same thing
20:19:59 <roconnor> reentered
20:20:02 <Axman6> fair enough
20:20:14 <Axman6> hopefully i'll learn about such things as i go through my degree :)
20:20:21 <roconnor> I hope so too
20:20:37 <Saizan_> you just need to write a generator in python
20:22:20 <ddarius> Axman6: I wouldn't wait for your professors to tell you about such things.
20:22:55 <Axman6> well so far we've done some basic haskell and java, so no real theory yet
20:25:01 <Toxaris> are coroutines that important?
20:25:39 <Olathe> Coroutines are even more important than slugs.
20:25:42 <Cale> Axman6: With subroutines, you enter the subroutine, carry out the instructions in it, and return a value at some point, and the next time the subroutine is called, execution starts from the top, just as it did the first time. With coroutines, the procedure yields a value back to its caller, but the next time it's entered, execution continues from the yield.
20:25:47 <Toxaris> if a language wants to support such stuff on the language level, why not go all the way to continuations?
20:26:22 <ddarius> Coroutines are much better behaved than continuations.
20:26:33 <bd_> Toxaris: implementing continuation passing style may have other costs associated with it in the implementation (eg, the cost of allocating lots of continuation objects all the time)
20:26:48 <Axman6> Cale: i see. so what's the importance?
20:27:04 <Toxaris> hmm I see, and coroutines are cheaper to implement?
20:27:05 <bd_> with coroutines you can implement them as state machines in some cases, which can be a good bit easier than putting fully general continuations everywhere
20:27:08 <Cale> So you can imagine two coroutines, a producer and a consumer, yielding control to one another. The producer is run, generates an item, yields to the consumer, which does something with it before yielding a request back to the producer.
20:27:18 <bd_> or you can implement them with lightweight threads
20:27:43 <Axman6> ah, i see.
20:28:25 <Cale> (which continues from exactly the point where it left off)
20:28:51 <EvilTerran> coroutines are to lambda-calculus-based languages what goto is to turing-machine-based ones :P
20:29:16 <Toxaris> EvilTerran: how are they better behaved as continuations then, as ddarius claimed?
20:29:39 <EvilTerran> er, i meant to type continuations
20:29:48 <EvilTerran> too late at night to be trying to make witty comments :P
20:30:08 <Toxaris> at my place it is starting to get early in the morning :)
20:30:28 <Toxaris> but actually, dynamically, continuations are much nicer then goto, because they capture the environment
20:30:33 <EvilTerran> "too late in the morning" would probably be accurate here, too
20:30:47 <EvilTerran> (well, is accurate. blah.)
20:30:50 <Toxaris> while with goto, you have to take care yourself that the stack / register contents matches
20:31:15 <bd_> Toxaris: Your language of choice doesn't deal with necessary stack adjustments in goto?
20:31:18 <EvilTerran> i figure that's an extension of the tendency for everything to be lexically scoped and mutable in functional languages
20:31:26 <bd_> Toxaris: are you programming in asm by any chance? :)
20:31:29 <EvilTerran> *immutable
20:31:40 <EvilTerran> and mutable in imperative ones
20:32:13 <Toxaris> bd_: I don't know any language beside assembler which allow goto jumps as freely as e.g. scheme allows continuations
20:32:46 <Toxaris> bd_: afaik procedural languages tend to allow goto only in the same procedure, which is kind of lame, and doesn't really count as goto
20:33:10 <bd_> however jumping in the middle of another procedure is often rather confusing :)
20:33:23 <EvilTerran> setjmp()!
20:33:26 <bd_> hence why coroutines are well-behaved - you can't have a routine returning twice unless it expects it
20:35:29 <ozy`> Toxaris: that's why you put the entire program in main()
20:35:31 <Toxaris> is there a whole design spaces hidden "below" continuations?
20:36:09 * Toxaris should really look into Scheme, but Haskell feels so much more familiar
20:36:47 <ddarius> Toxaris: All the more reason to look into Scheme.
20:37:27 <Toxaris> hehe yeah I know. just registered to a course in advanced Scheme hacking though, so I will be forced to do just that next term
20:39:13 <ozy`> Toxaris: if you know haskell you should pick up the basic scheme concepts more or less instantly
20:45:01 <Toxaris> I should hope so. actually, I have done some scheme programming, but never got deeper into it then basic functional programming. So I guess translated to Haskell I'm at the level where you understand monads in theory, but you have no clue how the employ the concept in your design, or what all the funny combinators in Control.*.* are good for
20:46:01 <Toxaris> but its hard to move on, much easier to stay where you already know your way around
20:49:08 <tjm1983> Does anyone feel like helping me with a stack overflow?
20:49:55 <Cale> I can have a look
20:51:26 <tjm1983> Cale: thanks: http://hpaste.org/13159
20:52:40 <Cale> tjm1983: Okay, my guess, without any deep analysis, is that you're building up large expressions in the tally
20:53:11 <tjm1983> This seems to work on small things, but if I load it in ghci 6.8.2 and ask "readFile nameOfBigFile >>= return . lines >>= return . value . foldl update newRandomThing", I get a stack overflow.
20:54:10 <tjm1983> Sorry; skip the ">>= return . lines", otherwise it works (on a 2.4 MiB file).
20:54:53 <Cale> Well, first of all, replace the foldl with foldl'
20:55:16 <Cale> foldl is often problematic with large amounts of data.
20:55:52 <tjm1983> :t foldl'
20:55:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:56:00 <tjm1983> :t foldl
20:56:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:56:04 <Cale> Let me show you why:
20:56:08 <Cale> foldl (+) 0 [1,2,3]
20:56:08 <porges> rule of thumb: foldr or foldl', never foldl ;)
20:56:15 <Cale> -> foldl (+) (0+1) [2,3]
20:56:25 <Cale> -> foldl (+) ((0+1)+2) [3]
20:56:30 <Cale> -> foldl (+) (((0+1)+2)+3) []
20:56:34 <Cale> -> (((0+1)+2)+3)
20:56:53 <Cale> and then you have a possibly giant expression to go looking in for a reducible subexpression
20:57:01 <Cale> In this case, the 0+1
20:57:08 <Cale> and this is where the stack overflow occurs
20:57:17 <Cale> > foldl (+) 0 [1..1000000]
20:57:19 <lambdabot>   * Exception: stack overflow
20:57:39 <tjm1983> And how does foldl' work?
20:57:49 <Cale> So, there's foldl' -- the only difference between it and foldl is that it evaluates the accumulating parameter on each step before it recurses.
20:57:57 <Cale> (up to determining the top-level constructor in it)
20:58:03 <Cale> So it goes
20:58:08 <Cale> foldl' (+) 0 [1,2,3]
20:58:17 <koninkje_away> Cale: Do you happen to still have the call-tree diagram for filterM (const [False,True]) on your wiki?
20:58:18 <Cale> -> foldl' (+) 1 [2,3]
20:58:24 <Cale> -> foldl' (+) 3 [3]
20:58:26 <Cale> -> foldl' (+) 6 []
20:58:30 <Cale> -> 6
20:58:35 <Cale> koninkje: hmm
20:58:49 <Cale> http://cale.yi.org/share/filterM.png
20:59:00 <tjm1983> ?src foldl'
20:59:00 <lambdabot> foldl' f a []     = a
20:59:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:59:16 <koninkje> Cale++
20:59:29 <tjm1983> ?src foldl
20:59:29 <lambdabot> foldl f z []     = z
20:59:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:59:36 <Cale> Yeah, I left out a few of the steps in evaluating foldl' there.
20:59:56 <tjm1983> Yeah, your explanation was helpful, though.
21:00:04 <Cale> x `seq` y  will evaluate x before resulting in y
21:00:17 <tjm1983> ?src seq
21:00:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:00:22 <Cale> seq is a primitive
21:00:27 <tjm1983> I see.
21:00:34 <tjm1983> This is making more sense.
21:00:39 <porges> *cry*: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/48959
21:01:11 <tjm1983> So why does ghci think foldl' is out of scope?
21:01:33 <porges> you need to import it from Data.List\
21:01:49 <mmorrow> , let x = 1 + 1 in [isFullyEvaluated x, x `seq` isFullyEvaluated x]
21:02:03 <lunabot>  [False,True]
21:02:07 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
21:02:11 <lunabot>  [AP,Constr]
21:02:28 <Cale> It's important to note that it's only *when evaluated* that x `seq` y will evaluate y
21:02:30 <Cale> er
21:02:30 <Cale> x
21:02:44 <Cale> So, x `seq` x is always pointless to write
21:02:47 <mmorrow> indeed
21:02:58 <Cale> (because you were already about to evaluate x anyway)
21:02:58 <tjm1983> ok
21:03:20 <mmorrow> , let x = 1 + 1 in isFullyEvaluated (x `seq` isFullyEvaluated x)
21:03:25 <lunabot>  False
21:03:25 <Cale> The next caveat is that it only evaluates up to determining which constructor it is.
21:03:33 <mmorrow> , let x = 1 + 1 in isFullyEvaluated (x `seq` x)
21:03:37 <lunabot>  False
21:04:07 <Saizan> , let x = 1 in isFullyEvaluated x
21:04:11 <lunabot>  False
21:04:23 <mmorrow> , let !x = 1 in isFullyEvaluated x
21:04:24 <Cale> But by strictifying fields, or ensuring that additional seq's/pattern matches are in place, you can get this to do as much evaluation as you need.
21:04:28 <lunabot>  True
21:05:12 <mmorrow> Saizan: RtClosureInspect.{isFullyEvaluated, getClosureInfo}
21:05:16 <tjm1983> Strictifying fields? I vaguely remember something about that.
21:05:19 <Cale> tjm1983: Try this... add ! before each of the types of the fields in RandomThing
21:05:28 <Cale> and then use foldl' in place of foldl
21:05:35 <mmorrow> closureType a = unsafePerformIO (tipe `fmap` getClosureInfo a)
21:05:38 <Saizan> newRandomThing          = RandomThing { value = undefined,
21:05:48 <Cale> mm... that'll be a problem :)
21:06:11 <mmorrow> (but lunabot just needs the unsafePerformIO since it can't do IO)
21:06:12 <Cale> Well, not if newRandomThing is never evaluated ;)
21:06:31 <jeffwheeler> Cale: (sorry, just reading the earlier discussion), but coroutines seem pretty much exactly like what Python has with 'yield', is that correct?
21:07:03 <Cale> jeffwheeler: yeah. Python's yield is pretty much an equivalent situation.
21:07:16 <porges> same with C#'s yield
21:07:16 <jeffwheeler> Cale: how would it work in Haskell?
21:07:37 <jeffwheeler> Or, I should probably Google it. :P
21:07:48 <Saizan> with threads or continuations
21:07:49 <Cale> jeffwheeler: Well, depends on what effects you'd like to mix in.
21:07:52 <mmorrow> in haskell there isn't one stack, and also function don't have to "return"
21:07:59 <mmorrow> *functions
21:08:10 <Cale> jeffwheeler: Lazy evaluation is kind of like a pure version of coroutines :)
21:08:12 <porges> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
21:08:25 <jeffwheeler> Hmm, indeed.
21:08:32 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
21:08:33 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
21:08:40 <solrize> @hoogle popen
21:08:41 <lambdabot> package popenhs
21:08:43 <Toxaris> isn't the Prompt monad similar to coroutines?
21:08:54 <Cale> Toxaris: er...
21:08:59 <Cale> Toxaris: is it?
21:09:10 <mmorrow> , let mutual f g a = f a (\b -> g b (\a -> mutual f g a)) in mutual (\k x -> k (x*2)) (\k x -> if x < 20 then k x) 2
21:09:12 <lunabot>  luna: parse error on input `)'
21:09:15 <Toxaris> I dont know, but I guess, so I ask
21:09:32 <Cale> Oh, I suppose it lets you pass control to each of the primitives...
21:09:33 <mmorrow> , let mutual f g a = f a (\b -> g b (\a -> mutual f g a)) in mutual (\k x -> k (x*2)) (\k x -> if x < 20 then k x else x) 2
21:09:35 <lunabot>  luna: Occurs check: cannot construct the infinite type:
21:09:37 <mmorrow> gah
21:09:39 <Cale> It's not really.
21:10:19 <Toxaris> Cale: couldn't there be another Prompt action which "implements" the primitives
21:10:29 <Toxaris> so you have two Promp actions talking to each other
21:11:04 <mmorrow> oh, i flipped the args
21:11:13 <mmorrow> , let mutual f g a = f a (\b -> g b (\a -> mutual f g a)) in mutual (\x k -> k (x*2)) (\x k -> if x < 20 then k x else x) 2
21:11:15 <lunabot>  32
21:11:25 <Cale> I wonder if LogicT over IO or various other monads is a close enough approximation.
21:11:30 <tjm1983> Cale: thanks! The strictifying and foldl' make it work.
21:11:39 <Cale> tjm1983: No problem
21:12:17 <tjm1983> But as Saizan pointed out, the newRandomThing will need to change.
21:12:25 <porges> see also: http://www.nabble.com/Re%3A-Fun-with-type-functions-p20727640.html
21:13:44 <Saizan> tjm1983: you can keep it like it is if you have update rt v =  newValue `seq` RandomThing ..., and add the ! only to the tally and randomGen fields
21:14:34 <tjm1983> Saizan: clever :)
21:14:41 <Cale> Toxaris: Try it, I'd like to see it if you succeed :)
21:15:05 <mmorrow> this is interesting (not related to the current conversation) http://web.cecs.pdx.edu/~sheard/papers/FossacsErasure08.pdf
21:15:30 <Toxaris> is there a canonical example for coroutines I could try to implement?
21:16:07 <mmorrow> Toxaris: isn't it just two functions giving control to each other in turn?
21:16:47 <mmorrow> (and passing themselves as a continuation)
21:17:05 <Toxaris> mmorrow: thats my (limited) understanding, yes
21:17:21 <mmorrow> i like this mutual function a lot
21:17:30 <mmorrow> mutual f g a = f a (\b -> g b (\a -> mutual f g a))
21:17:47 <mmorrow> Toxaris: i got this idea from the type in category-extras Mutual
21:17:52 <mmorrow> , src ''Mutual
21:17:58 <lunabot>  newtype Mutual p m n a = Mutual {runMutual :: (m (p a
21:17:58 <lunabot>                                                      (Mutual p n m a)))}
21:18:24 <mmorrow> (if you supply a type anotation you can just do:)
21:18:33 <mmorrow> mutual f g a = f a (\b -> mutual g f b)
21:18:40 <rastar> mmorrow: quick question,  it is a member of package base-3.0.3.0, which is hidden
21:18:49 <mmorrow> ok
21:18:50 <rastar> is the package part of ghc
21:18:58 <mmorrow> it's part of ghc's stdlibs
21:19:03 <mmorrow> which package is failing?
21:19:06 <rastar> ah so the X11
21:19:15 <mmorrow> it'll be in:
21:19:16 <rastar> X11 is the one thats failing
21:19:20 <mmorrow> ghc/libraries/X11
21:19:25 <Saizan> rastar: you can see the packages you've installed with ghc-pkg list
21:19:29 <rastar> Graphics/X11/Xlib/Event.hsc:70:7: Could not find module `Data.Generics':
21:19:36 <mmorrow> Saizan: he's building ghc
21:19:43 <Saizan> ah
21:19:53 <Toxaris> mmorrow: I think with coroutines, the continuation which f can use should point to after the continuation which g has just used
21:20:15 <mmorrow> rastar: right, so does this the file ghc/libraries/X11/X11.cabal exist?
21:20:26 <mmorrow> Toxaris: lemme parse that for a second
21:20:27 <tjm1983> Saizan: your seq idea even seems to make it a little faster, but I only bothered checking two data points.
21:20:56 <rastar> mmorrow: no it doesnt
21:20:58 <rastar> hmm
21:21:04 <mmorrow> Toxaris: but what if g doesn't feel like calling its continuation?
21:21:23 <mmorrow> or what if g's continuation never returns
21:21:28 <Toxaris> mmorrow: then f is never executed I think
21:21:36 <mmorrow> exactly
21:21:46 <Toxaris> g's continuation returns as soon as f calls its continuation
21:21:56 <mmorrow> so, i guess i don't see the point of the extra indirection
21:21:56 <Toxaris> if it doesn't, well, the program doesn't terminates
21:22:09 <Saizan> tjm1983: that's a bit surprising, are you compiling with optimizations?
21:22:27 <mmorrow> rastar: hmm, does that directory (X11) exist at all?
21:22:51 <mmorrow> if not, i dunno how you could even be building the X11 pkg during the ghc build
21:22:53 <tjm1983> I'm just running it with ghci. Maybe I nessed up the (manual) timing.
21:23:34 <mmorrow> Toxaris: in that mutual function, g is f's continuation and f is g's continuation
21:23:35 <rastar> mmorrow: installed the binary, then built the source version and removed the binary now try to build the X11
21:23:53 <mmorrow> rastar: ohhh, ok. so you built ghc ok.
21:24:05 <rastar> yep
21:24:10 <Saizan> tjm1983: ah, ghci is more sensible to small changes in the code since it almost doesn't have optimizations
21:24:16 <mmorrow> so are you in the X11 directory? or are you using cabal-install?
21:24:52 <mmorrow> Toxaris: i'm not grokking what the purpose/significance is of what you just described
21:25:14 <Toxaris> mmorrow: me neither
21:25:23 <mmorrow> heh
21:25:36 <tjm1983> Saizan: I just figured out how to get ghci to time it for me, and it's about even.
21:25:44 <mmorrow> i can't even think how it'd be possible to code that either :)
21:25:57 <dolio> mutual isn't coroutining. At least, not how coroutines are typically presented.
21:26:15 <mmorrow> dolio: ah. so what is the official def?
21:26:28 <Toxaris> mutual is more like mutual recursion maybe?
21:26:39 <mmorrow> yes. i thout they were synonymous
21:26:43 <mmorrow> thought
21:26:51 <mmorrow> (hence the name ;)
21:26:53 <dolio> mutual is just a cpsed version of some mutual fixed point function. Like 'fix2 f g = g (f (fix2 f g))' only with an initial value.
21:27:00 <Toxaris> so what I want to say, mmorrow, is that coroutines are something else :)
21:27:12 <mmorrow> dolio: so what are coroutines?
21:27:49 <dolio> I can't think of how to present them other than in a monadic style, but...
21:27:53 <mmorrow> i feel like mutual recursion is equivalent to the presentations (usually always from an imperative pov) of coroutines i've seen
21:28:39 <mmorrow> just s/recursion/jmp/
21:28:48 <mmorrow> (or something)
21:29:11 <dolio> "f x = do ... stuff ... ; z <- g i ; ... ; w <- g j ; ..." along with "g i = do ... ; j <- f z ; ... ; f w"
21:29:55 <dolio> Where the "g i" call in f enters g with the argument i, the "f z" in g enters f at the "z <-" point, etc.
21:29:58 <mmorrow> isn't that the same as:
21:30:01 <Toxaris> f = do {yield 1; yield 2; error "bad"}; g = liftM2 (,) f; main = runCoroutines g -- I would expect f = (1, 2) in this example, and the error not triggered
21:30:58 <mmorrow> mutual (\x g -> do ... stuff ... ; z <- g i ; ... ; w <- g j ; ...) (\x f -> do ... ; j <- f z ; ... ; f w) ()
21:31:32 <mmorrow> mutual just provides each function with a reference to the other function
21:31:59 <Saizan> but not to the middle of other functions
21:32:12 <Saizan> s/middle/last yield/
21:32:33 <dolio> Calling "g i" enters (\x f -> ...) which eventually calls "f z" which enters (\x g -> ...), so no.
21:32:56 <mmorrow> hmm, i don't see how you could implem that in haskell then (??)
21:33:02 <dolio> Mutual always starts at the beginning of whatever functions it gets passed.
21:33:12 <mmorrow> dolio: but your monadic example does?
21:33:18 <mmorrow> *doesn't
21:33:53 <dolio> No, my monadic style example is just how you'd typically see coroutines presented.
21:34:31 <mmorrow> so it sounds to me to can't implem coroutines with asm and the ability to jump to arbitrary addresses
21:34:32 <dolio> If you implemented it in haskell, you wouldn't refer to haskell names for the other coroutine, you'd use some monadic action named something like "yield" to switch to another coroutine.
21:35:11 <mmorrow> but the part i don't get is when you "switch", that's supposed to begin execution at some arbitrary point in the other function?
21:35:31 <mmorrow> could that be done with continuations?
21:35:32 <dolio> When you yield, it enters the other coroutine wherever it left off.
21:35:44 <mmorrow> hmm
21:35:49 <Toxaris> it feels like channel-based concurrency
21:36:38 <dolio> Yes, it's essentially cooperative threading with values sent along with context switches.
21:37:01 <mmorrow> dolio: i'm not sure, but this "wherever it left off" stuff sounds like an imperative view of passing continuations around
21:37:26 <dolio> Okay.
21:38:19 <mmorrow> mutual f g = mdo fk <- f gk; gk <- fk   -- ?
21:38:36 <dolio> You could probably whip up a simple coroutine function with CC-delcont without much trouble.
21:38:47 <mmorrow> dolio: sweet.
21:38:56 <mmorrow> , runCC (return 0)
21:38:57 <dolio> Except bad things might happen if one routine yields more than the other expects.
21:38:58 <lunabot>  0
21:39:11 <mmorrow> heh, "prompt not found on the stack"
21:39:12 <Axman6> :t runCC
21:39:12 <dolio> I suppose you could solve that by running things forever in a loop.
21:39:13 <lambdabot> Not in scope: `runCC'
21:39:26 <mmorrow> , [$ty|runCC|]
21:39:32 <lunabot>  forall a . (forall b . CC b a) -> a
21:39:37 <mmorrow> , src ''CC
21:39:43 <lunabot>  newtype CC ans a = CC {unCC :: (CCT ans Identity a)}
21:39:55 <Axman6> :\
21:40:51 <mmorrow> dolio: oh, this reminds me. i've been meaning to ask what (if any) of the pros/cons of using CC-delcont vs. the version that (among other places) is used in zfs?
21:41:16 <mmorrow> http://moonpatio.com/repos/zfs/CC_FrameT.hs
21:42:12 <mmorrow> as far as i can tell, the only real diff is that the one oleg uses doesn't use an Equ GADT, but returns a Maybe (a -> b,b -> a)
21:42:19 <dolio> CC-delcont is cabalized and easy to install, and the stuff in zfs is in a zip file in a random location on oleg's website.
21:42:37 <mmorrow> that is certainly true
21:42:51 <wli> I've never quite figured out call/cc.
21:43:00 <dolio> Oh. Yeah. The newer version of the paper switches from using identity coersions to an equality GADT.
21:43:21 <dolio> Which I thought was sexier theoretically, so I changed it.
21:43:35 <mmorrow> hah, definitely
21:44:15 <mmorrow> dolio: in that paper they give three possible ways it could be implem iirc. the first was impossible in haskell, the second was i can't remember, the third was the "sequence of frames" implem
21:44:47 <mmorrow> so it looks like to me CC-delcont and the other one both use the sequence of frames. do you recall what the second one was?
21:44:54 <dolio> Yes. And according to oleg, the sequence of frames has the best performance in his experience.
21:45:02 <mmorrow> oh rly.
21:45:02 * wli ponders the potential for probabilistic monads useful for numerical solutions to stochastic diffeq's.
21:45:19 <mmorrow> dolio: didn't they say the second one would be more efficient in the paper also?
21:45:30 <mmorrow> (not that i don't believe you)
21:45:32 <roconnor> I can't believe people get CS degrees without knowing how to make flowcharts
21:45:42 * wli should probably figure out what a Wiener process is first.
21:45:51 <dolio> The other one in the paper used some underlying continuation monad or something. I can't recall the details.
21:45:57 <mmorrow> me neither
21:46:31 <mmorrow> , flip runCont id (callCC (\k -> return 0))
21:46:33 <lunabot>  0
21:46:35 <mmorrow> , flip runCont id (callCC (\k -> k 0))
21:46:38 <lunabot>  0
21:46:43 <mmorrow> , flip runCont id (callCC (\k -> return 0 >> k 0))
21:46:45 <lunabot>  0
21:46:50 <mmorrow> , flip runCont id (callCC (\k -> k 1 >> return 0))
21:46:52 <lunabot>  1
21:47:15 <Axman6> o.O
21:47:15 <pumpkin_> say I have a list of two-element lists, and I want to merge [[a, b],[c, d]] into [a (max b c), d] (and so on for larger lists)
21:47:19 <mmorrow> , flip runCont id (callCC (\k -> forever (k 0)))
21:47:21 <lunabot>  0
21:47:26 <pumpkin_> is there a good higher-order function I could use for that?
21:47:26 <Taejo> should logo suggestions go to the wiki and cafe or just wiki?
21:47:37 <pumpkin_> I could fold it a little painfully
21:47:58 <Taejo> pumpkin_: not sure what you want?
21:48:45 <BMeph> pumpkin_: What would [[a,b],[c,d],[e,f],[g,h]] give? :)
21:49:10 <pumpkin_> [a, (max b c), (max d e), (max f g), h]
21:49:25 <pumpkin_> so pairwise maxing, if that makes any sense
21:49:27 * Taejo just realised that his logos all look a bit like evil people when turned 90 degrees
21:49:33 <mmorrow> dolio: cool, now i feel better about the "sequence of frames". it was always nagging at me that i thought there was a more efficient known implem
21:49:51 <dolio> Well, I haven't done any benchmarks myself.
21:49:51 <BMeph> pumpkin_: Would it be [a, (max b c), (max d e), (max f g), h]? :)
21:50:07 <pumpkin_> didn't I just say that? :P
21:50:11 <dolio> But, if you trust oleg, don't worry I guess. :)
21:50:19 <BMeph> pumpkin_:Sweet, I think I get it, then. :)
21:50:29 <mmorrow> dolio: only as far as i can throw him ;)
21:50:31 <pumpkin_> BMeph: yay :) see any elegnat solution that doesn't involve manual recursion?
21:50:47 <BMeph> pumpkin_: Heh-heh, yeah, you did - I two-finger type, with my head down. :)
21:51:07 <pumpkin_> :)
21:52:59 * Taejo discovers that disabling loopback is a bad idea
21:54:18 <dolio> mmorrow: Looking at the paper, the third implementation uses an underlying abstract continuation monad.
21:54:59 <dolio> So instead of storing sequences of concrete segments of the computation, you use the underlying monad to capture continuations, storing sequences of those.
21:55:07 * vijay4114 sits back
21:55:14 <dolio> It's hard to imagine that extra level of abstraction buying you more performance.
21:55:43 <mbz> what paper are you discussing?
21:56:19 <dolio> A Monadic Framework for Delimited Continuations.
21:56:25 <pumpkin_> BMeph: any ideas then?
21:57:36 <byorgey> pumpkin_: map maximum . splitPlaces (1:[2,4..]) . concat
21:57:48 <pumpkin_> :t splitPLaces
21:57:50 <lambdabot> Not in scope: `splitPLaces'
21:57:53 <byorgey> you can find the code for 'splitPlaces' in section 2 of http://haskell.org/haskellwiki/Data.List.Split
21:57:55 <pumpkin_> oh that's your fancy split library :P
21:58:02 <Axman6> pumpkin_: only thing i can think of to get started would to be add -Infinity to the beginning and eld of the list...
21:58:13 <pumpkin_> that makes sense
21:58:19 <pumpkin_> thanxman6
21:58:24 <Axman6> yeah that'll work
21:58:24 <pumpkin_> :P
21:58:45 <pumpkin_> it'll homogenize it, but I still need a simple function that does the maxifying
21:58:50 <pumpkin_> I'll try the splitPlaces :)
21:59:25 <Axman6> concat the list, then zipWith max `ap` tail.((-Infinity):).(++[-Infinity]) or something
21:59:37 <Axman6> :t -Infinity
21:59:38 <the_unma1er> so hey
21:59:38 <lambdabot> Not in scope: data constructor `Infinity'
21:59:51 <pumpkin_> 1/0 probably
21:59:51 <Axman6> :t (-1)/0
21:59:53 <lambdabot> forall a. (Fractional a) => a
21:59:54 <the_unma1er> hey
22:00:05 <byorgey> Axman6: that's not quite the same thing, that would give you  [a, max a b, max b c, max c d ...] etc.
22:00:07 <mmorrow> dolio: heh, i just came back to irc about to say the same thing :)
22:00:13 <byorgey> hu the_unma1er
22:00:15 <Axman6> byorgey: hmm, yes
22:00:29 <mmorrow> dolio: hmm, the paper is different from how i thought i remembered it
22:00:44 <byorgey> er, *hi
22:00:59 <Axman6> :t zipWith max `ap` (tail.tail)
22:01:01 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:01:11 <mmorrow> dolio: now i'm not so sure what implem was claimed to be the most efficient
22:01:24 <Axman6> > (zipWith max `ap` (tail.tail)) [1,2,3,4,2,3,4]
22:01:25 <lambdabot>   [3,4,3,4,4]
22:01:30 <mmorrow> (can't seem to find said claim in the paper)
22:01:47 <Axman6> > (zipWith max `ap` (tail.tail)) [a,b,c,d,e,f] :: [Expr]
22:01:49 <lambdabot>       Ambiguous occurrence `e'
22:01:49 <lambdabot>      It could refer to either `L.e', defined a...
22:01:55 <Axman6> > (zipWith max `ap` (tail.tail)) [a,b,c,d] :: [Expr]
22:01:57 <dolio> Oh, one problem with coroutines in a language like haskell is the types.
22:01:57 <lambdabot>   [max a c,max b d]
22:02:06 <pumpkin_> :o
22:02:13 <Axman6> getting close? :)
22:02:22 <Toxaris> > map maximum . uncurry (++) . (return . take 1 &&& (takeWhile (not . null) . map (take 2) . iterate (drop 2) . drop 1)) . concat $ [[a, b], [c, d], [i, j]] -- ok maybe too long
22:02:24 <lambdabot>   [a,max b c,max d i,j]
22:02:29 * Axman6 *coughtakethateulerboycough*
22:02:31 <Axman6> :P
22:02:31 <dolio> Like, if you implemented it with CC-delcont, you'd probably have to restrict it to always yielding the same type of value.
22:02:45 <Axman6> Toxaris: wow, that's ugly :P
22:02:48 <dolio> You'd need something like session types to be fully general.
22:03:20 <Axman6> wait, that's wrong. dang
22:03:29 <dolio> Session types would take care of the problem of one routine yielding more times than the other expects, too.
22:03:35 <Toxaris> ohhh thats not what you want
22:03:42 <dolio> (I think.)
22:03:44 <byorgey> Axman6: yeah, if you want to use a zip you'd have to split the list into evens and odds first
22:04:33 <Toxaris> Axman6: whats wrong?
22:04:38 <Axman6> pumpkin_: i'd just write the function by hand :\
22:04:49 <pumpkin_> ok :)
22:04:56 <Axman6> Toxaris: what i wrote, the zipWith max `ap` tail
22:05:00 <Toxaris> oh ok
22:05:22 <Taejo> @src ap
22:05:22 <lambdabot> ap = liftM2 id
22:05:34 <Taejo> :t ap
22:05:35 <Axman6> :t ap
22:05:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:05:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:06:03 <Axman6> i don't actually understand how the zip`ap`tail thing works btw :P
22:06:13 <Axman6> @quote zip`ap`tail
22:06:14 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
22:06:33 <mmorrow> dolio: i think this is the comment i was remembering (and what i thought it implied at the time is how i recalled it, but it seems in hidsight to not say what i thought):
22:06:48 <mmorrow> The first of these implementations is suitable for low-level manipulations of the stack, the second suitable for a CPS compilation strategy, and the third suitable for a language that provides access to the entire abortive continuation using an operator like callcc.
22:07:26 <vijay4114>  /quit
22:07:26 <vijay4114> ls
22:07:28 <dolio> Oh.
22:07:32 <mmorrow> so i thought that meant that the first was unimplementable, the second the fastest implementable, and the third slower
22:07:37 <mmorrow> but i'm confused now
22:07:50 <dolio> The first is actually the frame version that CC-delcont (and oleg) uses.
22:07:57 <mmorrow> because the one i thought that was unimplementable is the one both yours and the other lib uses
22:07:59 <Taejo> :t zip `ap` tail
22:08:01 <lambdabot> forall b. [b] -> [(b, b)]
22:08:22 <Axman6> > zip `ap` tail $ [1..10]
22:08:24 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
22:08:37 <mmorrow> yeah, i don't understand why they say "is suitable for low-level manipulations of the stack"
22:08:39 <mmorrow> oh
22:09:03 <dolio> Well, by "stack" you can mean a haskell data type, I guess. :)
22:09:05 <mmorrow> so they meant "could be used in that sense" but of course it doesn't /require/ that use
22:09:20 <Axman6> can someone explain how zip :: m (a -> b)? (ie, what's the m here?)
22:09:22 * mmorrow sees teh light
22:09:56 <Taejo> Axman6: m is ((->) a)
22:10:09 <Axman6>   ah yes, indeed
22:10:42 <BMeph> :t zip`ap`map
22:10:44 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1 -> b'
22:10:44 <lambdabot>     Probable cause: `map' is applied to too few arguments
22:10:44 <lambdabot>     In the second argument of `ap', namely `map'
22:10:53 <BMeph> :t ap zip . map
22:10:54 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
22:12:15 <mmorrow> dolio: so now that that's cleared up, i wonder how best to implem coroutines with delimconts
22:12:30 <Axman6> byorgey: that's quite handy
22:12:35 <Axman6> uh, BMeph
22:12:54 <Axman6> useful for arrays probably
22:13:29 <BMeph> Axman6: Yeah, it's about one char shorter than using map (id &&& f) for a Schwartzian Transform. :)
22:13:58 <Axman6> a what?
22:14:12 <mmorrow> Axman6: think spaceballs
22:14:16 <Taejo> does anyone find "ap zip . map" easier to read?
22:14:17 <mmorrow> ;)
22:14:19 <byorgey> @go Schwartzian transform
22:14:21 <lambdabot> http://en.wikipedia.org/wiki/Schwartzian_transform
22:14:27 <byorgey> Axman6: ^^^
22:14:31 <Axman6> ta
22:14:42 <mmorrow> Taejo: then it loses it's aztec feel
22:14:46 <mmorrow> *its
22:15:14 <Taejo> mmorrow: what? what loses what aztec feel?
22:15:24 <mmorrow> @quote aztec
22:15:25 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
22:15:31 <mmorrow> :)
22:15:53 <Taejo> uhm... is zipaptail supposed to sound like an Aztec god? sorry, I'm slow
22:15:53 <BMeph> Taejo: Its type helps me remember what's going on better than 'ap zip tail' does. :)
22:16:21 <byorgey> Taejo: that's the idea
22:16:21 <mmorrow> Taejo: i guess
22:16:52 <BMeph> Taejo: It should end with an 'atl' for that, but it'll do in a pinch. ;)
22:16:55 <byorgey> real aztec gods have names like Tlazolteotl and Xochiquetzal.
22:16:57 <mmorrow> zip`ap`map - the aztec way to say snap!
22:17:08 <Axman6> byorgey: ah i see, quite handy also :)
22:17:17 <roconnor> Taejo: I think the accents are important
22:17:24 <Axman6> BMeph even.
22:17:27 * Axman6 tab fail
22:17:39 <mmorrow> yeah, the backticks definitely add to it
22:18:03 <Axman6> :t zip`ap`map
22:18:05 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1 -> b'
22:18:05 <lambdabot>     Probable cause: `map' is applied to too few arguments
22:18:05 <lambdabot>     In the second argument of `ap', namely `map'
22:18:14 <Taejo> now we just need functions called supr and man so some Indonesian can have a function (supr`ap`man) with his name
22:18:23 <BMeph> :t zip`ap`(.map)
22:18:25 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[a]'
22:18:25 <lambdabot>     In the second argument of `ap', namely `(. map)'
22:18:35 <Axman6> :t ap zip.map
22:18:37 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
22:18:39 <mmorrow> @type zip`ap`?f
22:18:40 <lambdabot> forall a b. (?f::[a] -> [b]) => [a] -> [(a, b)]
22:18:42 <BMeph> Pity.
22:18:48 <ski_> (.. or `Mictlantecuhtli')
22:19:09 <BMeph> ?ty zip`ap`map ?f
22:19:10 <lambdabot> forall a b. (?f::a -> b) => [a] -> [(a, b)]
22:19:33 <mmorrow> @hoogle forall a b. a -> b
22:19:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:19:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:19:33 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
22:20:12 <mmorrow> @hoogle forall (a :: *) (b :: *). a -> b
22:20:12 <lambdabot> Parse error:
22:20:12 <lambdabot>   --count=20 "forall (a :: *) (b :: *). a -> b"
22:20:12 <lambdabot>                     ^
22:20:16 <Axman6> > unsafeCoerce 1 :: String
22:20:18 <lambdabot>   Not in scope: `unsafeCoerce'
22:20:22 <Axman6> naww
22:20:22 * BMeph always things of college coeds when he sees 'unsafeCoerce'...
22:20:49 <mmorrow> Axman6: try this in ghci> unsafeCoerce id :: IO ()
22:21:17 <mmorrow> (don't if you are opposed to segfaulting)
22:21:42 <Axman6> bah!
22:22:09 <mmorrow> [m@ganon ~]$ ghc -e 'Unsafe.Coerce.unsafeCoerce id :: IO ()'
22:22:09 <mmorrow> Segmentation fault
22:22:30 <mmorrow> that's why you need to use Any if you're doing unsafeCoercing
22:22:50 <Axman6> doesn;t even need the type :)
22:22:58 <mmorrow> yeah
22:23:17 <mmorrow> hmm, i wonder what it's defaulting it to then
22:23:57 <mmorrow> on second thought, it probably doesn't matter
22:25:19 <mmorrow> it's "enters" the function, and functions shouldn't be entered
22:25:46 <mmorrow> (but data vals should)
22:26:23 <Taejo> > Unsafe.Coerce.unsafeCoerce id : IO ()
22:26:24 <lambdabot>   Not in scope: data constructor `IO'
22:26:28 <Taejo> > Unsafe.Coerce.unsafeCoerce id :: IO ()
22:26:29 <lambdabot>   /tmp/4072808813336004920:70:32:
22:26:29 <lambdabot>      Not in scope: `Unsafe.Coerce.unsafeCoe...
22:26:41 <cjs> Ok, this has me mystified. Why does Graphics.Win32.peekMessage return IO ().?
22:26:46 <mmorrow> peek nullPtr
22:26:55 <ddarius> listToMaybe = unsafeCoerce
22:27:04 <pumpkin_> @pl (\[a,b] [c,d] -> max b c)
22:27:04 <lambdabot> (line 1, column 3):
22:27:04 <lambdabot> unexpected "["
22:27:04 <lambdabot> expecting pattern
22:27:06 <pumpkin_> boo
22:27:08 <mmorrow> ddarius: heh
22:27:21 <ddarius> mmorrow: It has better sharing properties.
22:27:34 <Axman6> BMeph: would there be say an easy way to use a schwartzian transform on strings?
22:27:52 <mmorrow> ddarius: that's a way to say it
22:27:54 <Taejo> ddarius: wow, that actually works
22:28:14 <Taejo> but it would mess up GC, right?
22:28:50 <mmorrow> Taejo: that'll work for any type that's "Constructor value <anything here>"
22:29:03 <mmorrow> because they're all represented the same
22:29:16 <Taejo> yeah, I guessed that
22:29:27 <mmorrow> actually, i'm wrong
22:29:32 <mmorrow> ghci> unsafeCoerce (Left 0) :: Maybe Integer
22:29:32 <mmorrow> Nothing
22:29:46 <mmorrow> ohh, i see what it is
22:29:50 <Taejo> mmorrow: it has to be the second constructor
22:29:51 <ddarius> mmorrow: With pointer tagging it won't work.
22:29:53 <mmorrow> so the constructor tag
22:29:55 <mmorrow> yes
22:30:05 <mmorrow> ghci> unsafeCoerce (Right 0) :: Maybe Integer
22:30:05 <mmorrow> Just 0
22:30:40 <mmorrow> so doing s/Right 0/Something 0/ would segfault probably if Something is >2nd constructor
22:30:40 <ddarius> If you go from a data type that is not pointer tagged, to one that is, bad things will happen.
22:31:03 <jeffz`> cjs, looks like a mistake
22:31:18 <cjs> Oh, so it's not just me, then.
22:31:50 <BMeph> Axman6: As easy as on any other list. You might want to use inits or tails, if you're doing something with sub-strings, though. :)
22:31:57 <mmorrow> no it doesn't segfault, just comes back as "Nothing"
22:32:04 <jeffz`> cjs, not sure why the code checks for -1 either
22:32:31 <Axman6> BMeph: yeah, i was just trying to think of a complex data structure for which you could write such a function :)
22:34:46 <BMeph> Axman6: You don't need anything complicated. Say you want to sort a list by the result of a function on the list's values. That's the typical use for an ST.
22:35:09 <Axman6> righto
22:36:07 <BMeph> Axman6: In fact, I should throw one in my utility file, but using filter instead of sortBy, that would be useful. :)
22:36:41 <Axman6> not sure what you mean?
22:36:52 <Axman6> that totally wasn't a question, -?
22:39:29 <dolio> mmorrow: http://hpaste.org/13160
22:39:36 <vegai> man, xml parsing is not fun.
22:39:57 <vegai> I managed to steer clear of it for almost a decade, but now it crashed me at full speed
22:40:13 <mmorrow> dolio: awesome.
22:40:25 * mmorrow plays with it
22:40:48 <pumpkin_> bah, my ghci crashed
22:40:54 <pumpkin_> the impossible happened
22:41:01 <pumpkin_> (I pasted a large list into it)
22:41:11 <vegai> does it say something about the quality of haxml that the version from over a year ago builds on 6.10 without any changes
22:41:18 <vegai> I would wager it does.
22:42:10 <ddarius> vegai: It doesn't use exceptions seems to be what it says.
22:42:24 <Axman6> pumpkin_: i love it when that happens
22:42:32 <vegai> hmm, what was it again that made hxt build fail ...
22:42:39 <pumpkin_> Axman6: just solving 67 and 18 now :D
22:42:41 <pumpkin_> if only ghci wouldn't crash
22:42:46 <Axman6> heh
22:42:55 <wli> hmm
22:43:32 <vegai> doh, it build just fine. I forgot to do cabal update before install.
22:43:44 <Axman6> i haven't been able to figure out an easy way to do those path finding ones :\
22:44:08 <vegai> so, now my problem got bigger. I also have to choose a toolkit ;-/
22:44:10 <BMeph> BBIAB, got an update. :|
22:44:21 <pumpkin_> Axman6: think about "substructure" :) it's sort of dynamic programming
22:44:22 <vegai> possibly learn arrows
22:44:41 <pumpkin_> Axman6: my main problem with 67 is loading in that damn text file :P
22:44:50 <pumpkin_> which is why I tried to paste such a big list into ghci and crashed it
22:44:55 <sjanssen> vegai: hxt had a problem with arrows, that is the other big thing that changed in 6.10
22:45:08 <Axman6> pumpkin_: splitting the list up with ++ sems to help :)
22:45:23 <pumpkin_> ah
22:45:32 <pumpkin_> too lazy, I'll just parse the triangle :(
22:45:48 <dolio> > take 10 $ [ p * q * n `div` d | p <- [1..], q <- [1 .. p - 1], let { n = p*q - 1 ; d = p + q }, d /= 0, n `mod` d == 0]
22:45:50 <lambdabot>   [6,42,120,156,1428,630,420,2184,8970,930]
22:46:26 <pumpkin_> I don't like the functions that fail or throw exceptions
22:46:27 <pumpkin_> like readFile
22:46:30 <pumpkin_> should return a Maybe
22:46:53 <wli> I'm not sure what the issue is supposed to be here.
22:47:25 <pumpkin_> wli: if asking about my exception complaint, nothing :P
22:47:56 <wli> The issue with problem 67.
22:48:03 <Axman6> pumpkin_: that or Either String b so you can get error messages back
22:48:11 <pumpkin_> wli: loading that triangle.txt into ghc :P
22:48:12 <dolio> @type map (map read . words) . lines
22:48:14 <lambdabot> forall a. (Read a) => String -> [[a]]
22:48:18 <pumpkin_> I have the algorithm down for 18
22:48:55 <pumpkin_> wli: I don't have much experience with strings or loading files
22:49:12 <pumpkin_> I've done y <- readFile "triangle.txt" and am wondering what to do next, probably need to map something to lines y
22:49:48 <pumpkin_> oh I know what, I'll just use regexes to make it "readable"
22:49:57 <wli> map parseLine $ lines y
22:50:08 <dolio> That function I just typed in will parse the triangle.
22:50:16 <wli> parseLine = map read . words
22:50:25 <pumpkin_> ooh words
22:50:28 <pumpkin_> didn't know about that
22:50:35 <pumpkin_> thanks dolio and wli :)
22:50:39 <dolio> > read "08"
22:50:40 <wli> dolio remembers ;)
22:50:40 <lambdabot>   * Exception: Prelude.read: no parse
22:50:49 <dolio> Actually, that's a problem.
22:50:54 <dolio> Wait.
22:50:57 <dolio> > read "08" :: Int
22:50:59 <lambdabot>   8
22:51:06 <dolio> Never mind
22:51:09 <dolio> > read "07" :: Int
22:51:10 <lambdabot>   7
22:51:41 <Axman6> > read "076) :: Int
22:51:42 <lambdabot>   <no location info>:
22:51:42 <lambdabot>      lexical error in string/character literal at chara...
22:51:47 <Axman6> > read "076" :: Int
22:51:48 <lambdabot>   76
22:51:57 <wli> I'm trying to think of what to do after being "greedy" and just picking the biggest adjacent number every time.
22:52:02 <pumpkin_> thanks, this works fine
22:52:37 <pumpkin_> tada solved 67 :D
22:52:39 <pumpkin_> thanks guys :)
22:53:25 <wli> I guess you can find various sorts of bounds.
22:54:01 <dolio> You're talking about solving the triangle?
22:54:29 <pumpkin_> 205 looks pretty simple
22:55:12 <wli> Yeah. I'm thinking you do it with sub-triangles of progressively increasing heights whose base sits along the bottom row.
22:55:25 <dolio> The secret is to start at the bottom.
22:55:37 <pumpkin_> dolio: hmm, I started at the top
22:55:42 <pumpkin_> just folded over the triangle
22:56:02 <pumpkin_> (represented as a list of lists)
22:56:04 <dolio> Turn the last two rows into a combined representation of the optimal path.
22:56:16 <dolio> For each cell in the second-last row.
22:56:18 <dolio> Then repeat.
22:56:35 <pumpkin_> you forgot to rinse
22:57:10 <wli> So you start with 99 triangles of height 2, grow them to 98 of height 3, and it's only quadratic in the number of rows.
22:57:46 <pumpkin_> wli: so is the number of cells in the triangle, so I think you're good
22:57:58 <pumpkin_> I counted mine as linear in the number of cells
22:59:55 <jeffwheeler> @type callCC
22:59:56 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
23:00:32 <chylli> I'm trying cabal upgrade parsec, why get 'No packages to be installed.' ??? the current version is 2.1.0.1
23:00:42 <chylli> I want to upgrade to 3.0.0
23:00:52 <pumpkin_> just cabal install parsec-3.0.0 I think
23:00:52 <wli> Yeah, it's just picking the better of the two best paths beneath the left and right below a sub-triangle's tip.
23:01:04 <pumpkin_> wli: that's pretty much what I did, in a foldl
23:01:16 <chylli> pumpkin_: doing. but why cabal dont work
23:02:30 <dons> chylli: you'll need to add a version number. cabal prefers parsec 2
23:02:45 <chylli> thanks
23:02:47 <pumpkin_> it's conservative :(
23:02:49 <dons> there's a few packages, that for compat. reasons, cabal prefers earlier versions of.
23:03:13 <dons> since the majority of dependencies rely on the earlier version
23:03:24 <chylli> oh, thanks. it is so clever :p
23:03:53 <dons> it's a constraint solver.
23:04:01 <dons> so pretty clever.
23:04:08 <wli> pumpkin: Heck, you don't even need to program for 204; you can do it all with pencil and paper.
23:04:22 <pumpkin_> 204? which is that?
23:04:25 <chylli> maybe its a bad decision to install latest parsec. but Yi editor need it.
23:04:32 <pumpkin_> hamming numbers?
23:04:39 <wli> pumpkin: Generalized Hamming numbers. Yeah.
23:04:41 <dons> chylli: that's fine.
23:04:47 <dons> if yi needs it, well, yi needs it
23:04:48 <pumpkin_> wli: ah, haven't looked at it yet
23:05:14 <pumpkin_> wli: yeah, pretty simple looking
23:05:22 <pumpkin_> + hyphen
23:06:04 <wli> pumpkin: Hmm, maybe the numbers are a little big to do by hand but a non-symbolic calculator and a lot of patience will do (then again, that's pretty much all the programs).
23:07:13 <jeffwheeler> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
23:07:13 <lambdabot> f a b = a (\ c _ -> b c) b
23:07:42 <Gracenotes> is it just me or is Brian Beckman awesome?
23:07:52 <ddarius> Gracenotes: It's just you.
23:07:57 <Gracenotes> awwww :(
23:08:10 <chylli>  can't cabal remove a package ?
23:08:20 <ddarius> chylli: No
23:08:38 <Gracenotes> ddarius: he sounds like what everyone else on this channel says :)
23:09:42 <chylli> ddarius: then one package compiled with old version of parsec, I want to recompile & reinstall it, how to do? I just run cabal install --reinstall , but still don't work
23:10:43 <jeffz`> chylli, "don't work" is not very descriptive
23:11:58 <chylli> jeffz`: I try to recompile it, but I still get an version depending on old version of parsec
23:12:45 <jeffz`> chylli: if something is asking for the old version of parsec, that's normal.. not everyone wants parsec 3
23:13:34 <chylli> jeffz`: but yi need parsec 3, regex-tdfa need parse 2, yi need regex-tdfa
23:13:35 * jeffwheeler loves the warning on this page: http://www.haskell.org/all_about_monads/html/contmonad.html
23:14:01 <chylli> jeffz`: so I got Warning: This package indirectly depends on multiple versions of the same package.
23:14:24 <jeffwheeler> chylli: I remember getting that error a long time ago; let me see what versions I'm running.
23:14:51 <jeffz`> chylli: not sure... maybe you need to explicitly say parsec 3 in the cabal file
23:15:11 <chylli> jeffwheeler: how to see ? I want to know.
23:15:25 <jeffwheeler> chylli: these are what are on my system, which compiles Yi fine: http://hpaste.org/13161
23:15:32 <chylli> jeffz`: :( so complex :p
23:15:37 <jeffwheeler> chylli: that's just `ghc-pkg list`
23:16:22 <jeffwheeler> So, I have parsec-3 installed as user, parsec-2 as system.
23:17:54 <Gracenotes> I think Brian Beckman has good taste in hats.
23:18:14 <Gracenotes> You have good taste in hats too. :/
23:19:27 <chylli> jeffwheeler: can you see which version of parsec is what regex-tdfa using ?
23:20:30 <mmorrow> dolio: http://hpaste.org/13160#a1
23:20:40 <jeffwheeler> chylli: parsec-3, it seems; are you using regex-tdfa-0.95.2? Thinking back, I might have compiled that locally from src.
23:20:43 <paolino> jeffwheeler: different version in different databases and yi got it's parsec version from one and regex-tdfa from the other one ....
23:21:17 <jeffwheeler> paolino: no, it appears neither are using parsec 2, fortunately. :)
23:21:28 <chylli> jeffwheeler: yes.
23:21:38 <jeffwheeler> To what?
23:21:46 * paolino stops from cutting veins 
23:21:55 <chylli> jeffwheeler: using 0.95.2
23:22:15 <chylli> jeffwheeler: maybe I can ignore that warning ?
23:22:21 <jeffwheeler> chylli: and `ghc-pkg describe regex-tdfa-0.95.2` says that it's using parsec-3?
23:22:38 <jeffwheeler> chylli: if I remember correctly, it was more of an error that I couldn't get past
23:23:46 <chylli> jeffwheeler: no, it using parsec-2
23:24:18 <jeffwheeler> chylli: hmm, I might have custom compiled from source after making some changes. I have forgotten. Try downloading the tarball and modifying the cabal file.
23:25:44 <dolio> 205 was easy.
23:25:56 <chylli> jeffwheeler: thanks, let me try to just ignore that warning
23:26:02 <dolio> Probability monad.
23:26:09 <jeffwheeler> dolio: Euler?
23:26:14 <dolio> Yeah.
23:28:09 <dolio> mmorrow: Yeah, it's not too hard to encode coroutines (or threading) that way.
23:30:39 <mmorrow> dolio: yeah. so i see now how/why mutual doesn't quite cut it.
23:31:06 <Gracenotes> ghc seems to be 1.25 MB on my computer... this is normal?
23:31:13 <Gracenotes> er, 125
23:31:26 <mmorrow> and i doesn't look like one could write a modified mutual without a newtype that guards the infinite type
23:31:29 <Gracenotes> seems a little large
23:31:40 <jeffz`> Gracenotes: what would be normal?
23:31:57 <Gracenotes> what the size of an installation is supposed to be
23:32:25 <jeffz`> Gracenotes: compressed it's about 45MB, so 100+ sounds reasonable
23:33:43 <mmorrow> dolio: on another note, i found this yesterday and it's super interesting: http://web.cecs.pdx.edu/~sheard/papers/FossacsErasure08.pdf
23:33:44 <Gracenotes> I'm not complaining, I have more than enough space -- but what takes up the most?
23:34:31 <mmorrow> dolio: as is this (seen on planet.haskell) http://www.cs.nott.ac.uk/~txa/publ/pisigma.pdf
23:34:53 <mmorrow> the cgi prog for the latter paper is also neat
23:34:54 <dolio> I think I have both of those.
23:35:05 <mmorrow> dolio: nice :)
23:35:20 <dolio> Haven't read the first yet, though.
23:35:22 <mmorrow> the first one is by one of the authors of the original TH paper
23:35:49 <mmorrow> oh man, it's like TH extended to everything (in a sense)
23:36:09 <dolio> The second I've skimmed, but I'm slightly disappointed in their evil, non-total ways. :)
23:36:20 <mmorrow> that's what excites me!
23:37:20 <jeffz`> Gracenotes: I think documentation is a fair chunk of that, never really looked at the size of anything else
23:41:10 <Gracenotes> hm, mempty must be the unit for monoids, I suppose?
23:41:37 <pumpkin_> wli: boo, I have an answer but it doesn't like it :(
23:42:12 <pumpkin_> oh duh, off by 1 :)
23:42:14 <pumpkin_> that took me too long
23:44:17 <znutar> Anyoen familiar enough with haskell-mode to tell me why Inf-Haskell is cd'ing to ~/.cabal and then :loading using a relative path instead of :cd'ing to the .hs file's dir?  And how I can change it?
23:44:26 <mmorrow> dolio: this is cool http://sneezy.cs.nott.ac.uk/cgi-bin/PiSigma
23:44:38 <mmorrow> this typechecks in it:
23:44:40 <mmorrow> fix : (A:Type) -> (A -> A) -> A.
23:44:40 <mmorrow> fix = \a -> \f -> f (fix a f).
23:45:09 <mmorrow> (took me 10 minutes to realize i needed a friggin '.' at the end of each line)
23:45:41 <pumpkin_> I think I know how to solve http://projecteuler.net/index.php?section=problems&id=132 but it's taking me some time
23:47:40 <dolio> mmorrow: Here's a term algebra coroutine monad: http://hpaste.org/13160#a2
23:48:13 <quicksilver> znutar: yes, because it's stupid.
23:48:27 <quicksilver> znutar: touch an empty .cabal file at the root of your current project
23:48:37 <quicksilver> znutar: and curse a bit at the authors of this feature :P
23:48:44 <centrinia> pumpkin_: take 10 $ filter (==0) [ (repunit 10^9) `mod` p | p <- primes ]
23:48:54 <centrinia> Uh, take 40
23:48:59 <pumpkin_> centrinia: lol, thanks
23:49:13 <pumpkin_> have you done much computation with repunit 10^9 recently?
23:49:17 <BeelsebobWork> filter (==0)?
23:49:19 <centrinia> No.
23:49:21 <BeelsebobWork> that's gonna be a boring list
23:49:27 <centrinia> Oh.
23:49:37 <pumpkin_> that's a number with a billion digits :P
23:50:21 <pumpkin_> it complicates things slightly, but not too much
23:50:28 <pumpkin_> just trying to think of the best approach
23:50:31 <centrinia> pumpkin_: I was thinking of construction that repunit modulo a small integer.
23:51:43 <BeelsebobWork> centrinia: are you wanting to get out a list of primes, forwhich repunit 10^9 `mod` p is 0?
23:52:03 <centrinia> I mean, you can take repunit n m = if n == 0 then 1 else (repunit (n `div` 2) m) *(10^(n `div` 2) + 1) `mod` m)
23:52:08 <BeelsebobWork> because I'm guessing you don't want [0,0,0,0,0,0,0,0,0,...] out
23:52:26 <centrinia> BeelsebobWork: Nope. :p I should have paired each residue with a prime. :p
23:52:32 <pumpkin_> I think he wanted a guard on that mod
23:52:38 <pumpkin_> or just guard on it
23:53:01 <BeelsebobWork> centrinia: take 40 [p | p <- primes, repunit 10^9 `mod` p == 0] -- this?
23:53:17 <centrinia> That's better. :) :p
23:53:52 <pumpkin_> anyway, don't think about it too much aloud
23:53:57 <pumpkin_> I'm supposed to do it on my own :P
23:54:07 <BeelsebobWork> heh
23:55:58 <solrize> i think i see how to do it
23:57:14 <BeelsebobWork> there's gotta be an obvious property of repunits that you can exploit
23:57:25 <pumpkin_> there is sort of
23:57:40 <BeelsebobWork> I'd look at the prime factors of [R(n) | n <- [1..20]] and see what patterns emerge
23:58:06 <pumpkin_> there isn't much of one
23:58:32 <pumpkin_> but I'm trying to exploit hte fact that R(n) divides R(m) iff n divides m
23:59:44 <solrize> maybe that gets you a bunch of small factors but not necessarily the smallest ones
