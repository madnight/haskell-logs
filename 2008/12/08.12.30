00:03:58 <NameAlreadyInUse> i am learning about types at the moment and i was wondering how to write a show function for a type
00:04:07 <NameAlreadyInUse> at the moment i have "show (Pt x y) = "(" ++ (show x) ++ ", " ++ (show y) ++ ")"" for "data Point a = Pt a a"
00:04:12 <dibblego> instance Show T where
00:04:50 <int-e> instance (Show a) => Show (Point a) where show (Pt x y) = ...
00:05:03 <chylli> how to get substring like in perl : $string =~ /abc(.*)def/ ; print $1 by posix regexp ?
00:05:11 <dmwit> You can also write "data Point a = Pt a a deriving Show" to ask GHC to write a Show instance for you.
00:05:54 <int-e> > "lalaabcxyzzydeflala" =~ "abc(.*)def" :: [[String]]
00:05:56 <lambdabot>   [["abcxyzzydef","xyzzy"]]
00:06:03 <int-e> @index (=~)
00:06:03 <lambdabot> bzzt
00:07:34 <NameAlreadyInUse> with int-e's method, is there a way i can still write a type signature for my function?
00:07:53 <dmwit> Certainly.
00:08:15 <dmwit> Simply write it at the same indentation level as the "show" definition, and also inside the "instance" block.
00:08:22 <nanothief> chylli: try import Text.Regex.Posix \n "your string abcLOLOLdef" =~ "abc(.*)def" :: [[String]]
00:08:30 <dmwit> instance Show a => Show (Point a) where
00:08:35 <dmwit>   show :: ...
00:08:40 <dmwit>   show (Pt x y) = ...
00:08:54 <chylli> nanothief: thanks
00:09:23 <NameAlreadyInUse> oh, thanks
00:11:58 <dmwit> NameAlreadyInUse: As a side note (on style), it's generally considered a good idea to reserve Show for things that can be dropped verbatim into Haskell source.
00:12:10 <NameAlreadyInUse> how do you mean?
00:12:22 <dmwit> The kind of thing you're doing is typically called "pprint" or so (for pretty-print).
00:12:24 <dmwit> I mean:
00:12:33 <dmwit> > show (3, "hey")
00:12:35 <lambdabot>   "(3,\"hey\")"
00:12:46 <dmwit> > read "(3,\"hey\")"
00:12:47 <lambdabot>   * Exception: Prelude.read: no parse
00:12:54 <dmwit> > read "(3,\"hey\")" :: (Int, String)
00:12:55 <lambdabot>   (3,"hey")
00:13:31 <dmwit> In other words, you should be able to drop the string you get from "show" straight into ghci.
00:13:47 <dmwit> (And get back the value you started with.)
00:14:08 <dmwit> If you let the compiler derive a Show instance, it will make sure that's true.
00:14:21 <NameAlreadyInUse> ah, i get it
00:14:35 <NameAlreadyInUse> so i should do "deriving Show" in future?
00:14:54 <dmwit> I would.  It's a great idea to practice writing a few instances though.
00:15:15 <dmwit> So I approve of your Show instance despite everything I've said so far. =)
00:15:51 <nanothief> is it possible to override an existing instance definition? Eg for ZonedTime, read . show /= id, which stuffs up all my data types that have a ZonedTime
00:21:11 <dmwit> nanothief: No.
00:21:20 <dmwit> Instances are global.
00:21:42 <dmwit> ?index ZonedTime
00:21:42 <lambdabot> bzzt
00:21:47 <dmwit> ?hoogle ZonedTime
00:21:48 <lambdabot> Data.Time.LocalTime data ZonedTime
00:21:48 <lambdabot> Data.Time.LocalTime ZonedTime :: LocalTime -> TimeZone -> ZonedTime
00:21:48 <lambdabot> Data.Time.LocalTime zonedTimeToLocalTime :: ZonedTime -> LocalTime
00:21:57 <dmwit> That's pretty bad.
00:22:16 <dmwit> Is ZonedTime an instance of FormatTime, perchance?
00:22:27 <dmwit> That might help you write real Read/Show instances...
00:22:50 * dmwit would consider newtyping ZonedTime just to get around that problem
00:22:57 <Peaker> Typeable is only derived if you explicitly derive it, right?  And many don't, afaik...
00:23:47 <Peaker> maybe Haskell could use "autoinstances" that derive by default unless explicitly removed, or just always get derived?
00:24:40 <Peaker> For example, an AutoOrd that is like Ord but always auto-derived, so you can use stuff like Complex numbers as Map keys (or anything that can derive Ord)
00:25:42 <rwbarton> With standalone deriving this isn't as big an issue
00:27:46 <sjanssen> nanothief: sounds like a bug in that library
00:31:03 <Peaker> rwbarton: ah, indeed, why is "deriving" attached to the type when instance declarations are so wonderfully independent of it
00:42:13 <rwbarton> What's the fastest way to do  putStrLn . unwords . map show $ [1..1000000 :: Int] ?
00:42:24 <mae> what language feature is @= ?
00:43:17 <rwbarton> mae: Not a language feature, just an operator with a funny name
00:44:06 <sjanssen> rwbarton: that should be moderately fast
00:44:25 <sjanssen> be sure to change buffering from LineBuffering to some chunk size buffering
00:48:52 <rwbarton> Yeah, it is reasonably fast (about 40% slower than my simple C code)
00:50:17 <Gracenotes> :type newSTRef
00:50:20 <Gracenotes> @type newSTRef
00:50:21 <lambdabot> forall a s. a -> ST s (STRef s a)
00:51:06 <Gracenotes> @type readSTRef
00:51:08 <lambdabot> forall s a. STRef s a -> ST s a
00:51:11 <Gracenotes> @type modifySTRef
00:51:12 <lambdabot> forall s a. STRef s a -> (a -> a) -> ST s ()
00:52:15 <Gracenotes> hm. what does s refer to?
00:53:34 <rwbarton> @type runST
00:53:35 <lambdabot> forall a. (forall s. ST s a) -> a
00:53:41 <sjanssen> Gracenotes: s is a phantom parameter that makes sure you can't mix two ST contexts
00:54:43 <rwbarton> as you build up your ST action, you make sure s stays universally quantified
00:54:47 <rwbarton> then you can pass it to runST
00:55:00 <Gracenotes> If it didn't exist, how would you be able to mix two contexts?
00:55:21 <mm_freak> how can i export a newtype without its constructors?
00:56:07 <Gracenotes> and by "context" you mean messing with the value bound to an STRef?
00:56:18 <rwbarton> mm_freak: just put the name of the type in the export list, I'd guess?
00:56:37 <Gracenotes> [a STRef, perhaps]
01:00:45 <redditbot> Maintaining laziness - HaskellWiki
01:01:25 <mm_freak> rwbarton: is it normal that GHCi still allows me full access, when i load it through the command line like 'ghci Module.hs'?
01:01:51 <rwbarton> I don't know about ghci Module.hs
01:02:10 <mm_freak> oh well, i just tried
01:02:12 <mm_freak> it is normal =)
01:02:13 <rwbarton> for ghci ... :l "Module.hs", definitely; for ghci ... :m +Module, I don't think so
01:02:23 <mm_freak> my error
01:14:10 <mmorrow> thoughtpolice or Lemmih: ping re lhc
01:15:29 <mmorrow> preflex: seen thoughtpolice
01:15:30 <preflex>  thoughtpolice was last seen on #ghc 14 hours, 26 minutes and 46 seconds ago, saying: so filing a bug is probably a good idea anyway
01:15:38 <mmorrow> preflex: seen Lemmih
01:15:39 <preflex>  Lemmih was last seen on #haskell 18 hours, 8 minutes and 46 seconds ago, saying: vixey: Yes, lhc builds with ghc-6.10.
01:37:55 <darx> hi, is function composition syntactic sugar for nesting functions?
01:38:24 <johnnowak> (f . g) x  ==  f (g x)
01:38:33 <darx> yep
01:38:54 <darx> is it?
01:39:06 <johnnowak> that's what it does.
01:39:13 <johnnowak> it's not really "sugar" in that it's just a normal function
01:40:02 <darx> one could as well put it down in the second form and end up with the same function?
01:40:24 <johnnowak> yes. the reason you'd use composition is that you don't need to mention 'x'.
01:40:40 <darx> ok
01:40:52 <darx> Thanks :D
01:40:55 <johnnowak> foo = f . g   instead of   foo x = f (g x)
01:40:56 <NameAlreadyInUse> so what does this "Ambiguous Occurrence" stuff mean?
01:42:03 <NameAlreadyInUse> i am trying to make a "Tribool" class like "data Tribool = True | False | Undefined", but i can't define a (||) function and i am not sure what the proper instance .. where would be?
01:43:15 <sjanssen> NameAlreadyInUse: it means that you're using a name that is already in use (True and False are used in the Prelude)
01:43:42 <sjanssen> NameAlreadyInUse: also, "data" doesn't create classes, it creates data types
01:43:44 <mm_freak> darx: and the reason you don't want to mention x is that you think in functions instead of formulas, because you can do stuff to functions
01:43:59 <mm_freak> formulas are in a sense fixed and monolithic
01:44:10 <NameAlreadyInUse> sjanssen: you are right, old habits die hard :P
01:45:04 <NameAlreadyInUse> but is there some way to use both, or "extend" Bool with the Undefined value?
01:45:14 <mm_freak> NameAlreadyInUse: Maybe Bool
01:45:18 <darx> mn_freak: I'm not sure I got that because it would be wise to declare the signature as well? wouldn't it?
01:45:19 <sjanssen> NameAlreadyInUse: you can't extend Bool, data types are closed
01:45:38 <mm_freak> darx: those functions are equivalent, so the signature is the same
01:45:39 <sjanssen> NameAlreadyInUse: you can use the same names by "import Prelude hiding (True, False)"
01:45:44 <Peaker> You can "extend" types in the sense of placing them in another type
01:45:56 <Peaker> NameAlreadyInUse: for example, if you want another possible value on top of True/False, you can use:  Maybe Bool
01:46:11 <Peaker> NameAlreadyInUse: which adds the possible value Nothing, to "Just True" and "Just False"
01:46:16 <darx> mn_freak: yeah so we're thinking about the types and number of it's arguments by now?
01:46:42 <NameAlreadyInUse> Peaker: i can, but i am doing this for learning and not as a practical thing
01:46:43 <darx> *types and how many of them*
01:46:49 <mm_freak> darx: try mm_freak with two 'm', otherwise i get no highlight =)
01:46:50 <darx> forgive my crappy english.
01:46:57 <Peaker> NameAlreadyInUse: "Maybe Bool" is useful learning too :)
01:47:09 <NameAlreadyInUse> sjanssen: but won't functions that depend on Bool fail if I hide True and False?
01:47:14 <darx> "kemming" problem here LOL
01:47:34 <darx> *keming*
01:47:37 <sjanssen> NameAlreadyInUse: they'll work, but they'll work on Prelude's Bool type, not the one you've defined
01:47:57 <darx> http://www.ironicsans.com/2008/02/idea_a_new_typography_term.html
01:48:20 <NameAlreadyInUse> oh ok, i will give that a try
01:48:36 <mm_freak> darx: if (f :: a -> b) and (g :: b -> c), then (g . f :: a -> c)
01:49:01 <darx> Yup.
01:49:03 <mm_freak> now g . f and \x -> g (f x) are the same function
01:49:34 <darx> But I don't understand what you mean by thinking in terms of functions.
01:49:41 <darx> as opposed to equations.
01:49:50 <mm_freak> as opposed to formulas
01:50:04 <darx> yes
01:50:07 <mm_freak> g (f x) is a formula, while g . f is a function
01:50:29 <mm_freak> in the latter the motivation is manipulation of functions instead of values
01:50:38 <darx> ah
01:50:53 <Gracenotes> @pl \x -> f x x
01:50:55 <NameAlreadyInUse> sjanssen: if i hide (True, False), then functions like f :: Bool -> Bool will not work for me
01:51:20 * Gracenotes prods lambdabot
01:51:34 <darx> mm_freak: a higher level of abstraction you mean?
01:51:35 <NameAlreadyInUse> sjanssen: is there some way i can say "use Tribool's True/False if the type signature is Tribool -> etc"
01:51:37 <mm_freak> NameAlreadyInUse: they will, as long as you don't mention True or False
01:51:40 <francis> @botsnack
01:51:41 <lunabot>  :)
01:51:53 <Peaker> NameAlreadyInUse: no.. use different names
01:51:57 <sjanssen> NameAlreadyInUse: no
01:51:57 <francis> lambdabot fail again?
01:52:19 <mm_freak> NameAlreadyInUse: import Prelude hiding (True, False), import qualified Prelude
01:52:29 <francis> lunabot: > 1
01:52:33 <mm_freak> then you can use Prelude.True and Prelude.False
01:52:35 <francis> fail
01:52:40 <mm_freak> , 1
01:52:47 <lunabot>  1
01:52:57 <mm_freak> darx: just another way of thinking
01:53:08 <mm_freak> thinking functionally as opposed to thinking imperatively =)
01:53:10 <darx> ok. thanks
01:56:38 <Gracenotes> so failing that, any ideas for \x -> f x x in pointless style? :)
01:57:09 <NameAlreadyInUse> @src Maybe
01:57:22 <mm_freak> @@pl \x -> f x x
01:57:32 <mm_freak> @pl \x -> f x x
01:58:57 <Peaker> mm_freak: join
01:59:05 <Peaker> Gracenotes: join f
01:59:24 <mm_freak> oh, i jused worked out f `ap` id
01:59:32 <Gracenotes> ... oh!
01:59:37 <mm_freak> > (+) `ap` id $ 4
01:59:44 <mm_freak> , (+) `ap` id $ 4
01:59:47 <lunabot>  8
01:59:55 <mm_freak> , join (+) $ 4
01:59:58 <lunabot>  8
02:00:04 <nanothief> dmwit,sjanssen: with regards to ZonedTime and show/read, thanks for the suggestions, I used data WrappedTime = WrappedTime ZonedTime in my prog, and the format/parse methods to implement. It is very irritating though :S
02:00:12 <hugo___> hi
02:00:22 <Gracenotes> , foldr1 (+) . replicate 2 $ 4   -- a much, much more complicate solution
02:00:24 <lunabot>  luna: parse error (possibly incorrect indentation)
02:00:34 <Gracenotes> D: rawr, infixity
02:00:49 <Peaker> @pl \x -> f x x
02:00:49 <PeakerLambda> join f
02:00:57 <Gracenotes> oh, wait. it seems lunabot doesn't like comments.
02:01:41 <Peaker> @type \x -> x `ap` id
02:01:44 <PeakerLambda> forall a b. (a -> a -> b) -> a -> b
02:02:17 <mm_freak> @hoogle x -> (x,x)
02:02:19 <PeakerLambda> System.Random split :: RandomGen g => g -> (g, g)
02:02:19 <PeakerLambda> Prelude divMod :: Integral a => a -> a -> (a, a)
02:02:19 <PeakerLambda> Prelude quotRem :: Integral a => a -> a -> (a, a)
02:02:26 <Gracenotes> what monad is employed with join (a -> a -> b)?
02:02:49 <sjanssen> Gracenotes: ((->) a)
02:02:59 <mm_freak> Gracenotes: (a ->), i.e. function application
02:03:02 <Gracenotes> ...oh, really. I didn't think I'd see that come up.
02:03:13 <Gracenotes> although I implemented it once.
02:03:44 <mm_freak> @pl \x -> (x,x)
02:03:45 <PeakerLambda> join (,)
02:03:48 <Peaker> @type (id&&&id)
02:03:50 <PeakerLambda> forall b. b -> (b, b)
02:05:16 <Peaker> @type (id&&&length)
02:05:18 <PeakerLambda> forall a. [a] -> ([a], Int)
02:05:47 * Peaker loves &&&
02:05:53 <mm_freak> > join (,) >>> uncurry (+) $ 4
02:05:56 <PeakerLambda>   8
02:06:10 <Peaker> Linux sucks, when I type &&& in a row, it fires up the typematic repeat and I get something like &77777
02:06:29 <mm_freak> Peaker: ?!
02:06:32 <Gracenotes> That must mean Linux sucks
02:07:09 <Peaker> mm_freak: I think they moved the typematic repeat implementation from the keyboard controller to the kernel (good move, allows more flexible delays/rates). But since the kernel can't seem to guarantee handling the keyboard IRQ's on time, it messes things up
02:07:30 <mm_freak> Peaker: that certainly has nothing to do with linux, but rather with your desktop environment
02:07:34 <Peaker> Gracenotes: performance-wise, it sucks :-(   My quad-core machine at work can't play MP3's smoothly when scrolling a web page in firefox
02:07:44 <Peaker> mm_freak: I'm pretty sure its a kernel thing
02:07:56 <Peaker> mm_freak: (do you think the typematic repeat is in X?)
02:08:10 <mm_freak> Peaker: even my pentium 1 with 233 MHz did play even movies easily in the background, while smooth-scrolling firefox
02:08:22 <nanothief> Peaker: is that in the recently released kernel? (I'm not having those problems)
02:08:33 <idnar> mm_freak: but not h264 movies, I bet ;P
02:08:41 <Peaker> mm_freak: the same thing happens in a virtual console
02:09:01 <Peaker> nanothief: yeah, the newest Ubuntu
02:09:03 <mm_freak> Peaker: well, then your kernel settings are messed up…  it doesn't happen for me
02:09:21 <quicksilver> Peaker: eh, that's just totally broken audio or graphics drivers or both.
02:09:23 <mm_freak> idnar: dunno, i've got almost only MPEG videos =)
02:09:25 <Gracenotes> I had some problems with with the latest Kernel
02:09:45 <Gracenotes> I accidentally uninstalled gdm trying to reinstall ALSA
02:09:50 <sjanssen> Peaker: do you only have 32MB of RAM?
02:09:54 <Peaker> quicksilver: well, totally broken drivers do make Linux kind of suck :)
02:09:58 <Gracenotes> it was quite fun figuring out what was wrong...
02:10:04 <Peaker> sjanssen: I don't recall if its 2GB or 4GB of RAM at work
02:10:16 <quicksilver> Peaker: they make your installation suck, because you have broken drivers.
02:10:27 <quicksilver> I'm sure I could put broken drivers on ${YOUR_OS_OF_CHOICE} and make it suck.
02:10:33 <Peaker> quicksilver: what breaks the drivers? Their source code?
02:10:41 <Peaker> quicksilver: yeah but in Linux drivers are part of the official kernel
02:10:58 <Peaker> quicksilver: I can correct my statement and say "Linux plus its drivers kinda sucks, performance wise"
02:11:05 <quicksilver> Peaker: no.
02:11:05 <Peaker> if that helps
02:11:16 <quicksilver> Peaker: you can say "the stupid broken drivers which Peaker has installed appear to suck"
02:11:23 <Peaker> quicksilver: I didn't install any, Ubuntu did
02:11:24 <mm_freak> Peaker: the graphics card drivers in the kernel are open source alternatives to the vendor drivers
02:11:24 <quicksilver> because I have never experience anything like what you describe
02:11:31 <mm_freak> the latter are usually MUCH better performance-wise
02:11:34 <quicksilver> in 12 years of linux use
02:11:44 <quicksilver> so I don't think it's universal, and probably not even common.
02:11:47 <Peaker> quicksilver: what distribution do you use?
02:12:01 <Peaker> mm_freak: Well, something is wrong. I don't know exactly what
02:12:11 <mm_freak> Peaker: yeah, probably wrong drivers =)
02:12:14 <quicksilver> I have a linux machine which can display full-screen film/TV whilst simultaneously recording three more TV channels, and acting as a file server.
02:12:16 <Peaker> And I am not saying Linux sucks more than the alternatives, only that it sucks :-)  The alternatives suck in different ways
02:12:25 <Peaker> mm_freak: what wrong drivers get installed by Ubuntu?
02:12:34 <quicksilver> without a single chirp in the displayed images or the sound.
02:12:43 <quicksilver> and that's very old hardware too.
02:12:49 <Gracenotes> > ((1+) >>= (+)) 30
02:12:50 <PeakerLambda>   61
02:13:04 <mm_freak> especially in the graphics card world, you've almost always got the choice of two drivers:  community's open source and vendor's closed source
02:13:17 <Peaker> quicksilver: When watching Linux videos, I get some hickups, especially if they play from a network drive (that is _definitely_ faster than the video bitrate)
02:13:27 <mm_freak> the former is in most cases more stable and better from a code standpoint, but the latter is much faster
02:13:34 <maltem> mm_freak: I specifically blame the vendors here, actually
02:13:44 <vegai> Peaker: intel graphics?
02:14:01 <Peaker> vegai: Not sure what the video driver at work is, let me check
02:14:02 <mm_freak> Peaker: i don't know ubuntu
02:14:04 <quicksilver> Peaker: sure. and we're off topic anyway.
02:14:05 <maltem> mm_freak: the driver's worth is only with respect to the hardware, so there aren't any good reasons to keep the drivers closed-source
02:14:12 <quicksilver> Peaker: but your clumsy troll is ill appreciated.
02:14:26 <Peaker> nvidia GeForce 7100 GS (rev a1)
02:14:32 <mm_freak> maltem: yeah, sure, but still companies don't like to disclose there specs
02:14:38 <quicksilver> conflating a bug with one particular driver version and/or one particular piece of hardware with "linux sucks" is just stupid.
02:14:39 <mm_freak> for whatever reason
02:14:46 <quicksilver> Oh, and I use debian, like any other intelligent person would :)
02:14:51 <vegai> ah, well. Perhaps trying the closed-source driver could work
02:14:52 <Peaker> quicksilver: well, sorry, I just tried typing &&& and got "&&&&&&&&7777777" (this is really what I just got trying to type it :-)
02:14:58 <Gracenotes> > uncurry (++) $ (id &&& (+1)) $ 30
02:14:59 <PeakerLambda>   No instance for (GHC.Num.Num [a])
02:14:59 <PeakerLambda>    arising from the literal `1' at <inter...
02:15:01 <mm_freak> at least the big vendors provide very good drivers — this is my experience with nvidia at least
02:15:08 <vegai> quicksilver: your agile troll is ill appreciated!
02:15:16 <Peaker> quicksilver: I am not sure Ubuntu and Debian use different drivers..
02:15:45 <maltem> mm_freak: right, for whatever reason :) True, those drivers are usually of high quality
02:15:45 <Gracenotes> oh, the ++ might have something to do with it :/
02:16:18 <sjanssen> Peaker: you have to hold shift down for the whole sequence, not just after the first eight keypresses
02:16:24 <mm_freak> maltem: a few years ago i never expected 99% of my system to be of open source software
02:16:40 <Peaker> sjanssen: I press the key just 3 times, then I let go of the key, and then I let go of shift, but bugs in the typematic repeat cause that
02:16:45 <mm_freak> maltem: i think, what we currently have can be considered the success of open source
02:17:08 <maltem> ack
02:17:09 <Peaker> sjanssen: the key is considered pressed for quite a long time after I cease to press it, while shift is no longer considered pressed
02:17:41 <sjanssen> Peaker: strange
02:21:23 <cjs> Hm. Why doesn't the compiler like a `not.elem` b?
02:21:23 <PeakerLambda> cjs: You have 1 new message. '/msg PeakerLambda @messages' to read it.
02:21:44 <sjanssen> cjs: only qnames may be in backticks
02:21:54 <cjs> Very sad.
02:22:20 <quicksilver> if expressions were allowed in backticks we'd have to work out how to nest them
02:22:24 <quicksilver> but it is occasionally annoying
02:22:28 <cjs> Is there any clever way to do that, besides defining it in a let or something like that?
02:22:34 <int-e> @type not . elem
02:22:35 <PeakerLambda>     Couldn't match expected type `Bool'
02:22:35 <PeakerLambda>            against inferred type `[a] -> Bool'
02:22:35 <PeakerLambda>     In the second argument of `(.)', namely `elem'
02:22:46 <Peaker> @hoogle notElem
02:22:47 <PeakerLambda> Prelude notElem :: Eq a => a -> [a] -> Bool
02:22:47 <PeakerLambda> Data.ByteString notElem :: Word8 -> ByteString -> Bool
02:22:47 <PeakerLambda> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
02:22:58 <Peaker> cjs: ^^ and you can use the not outside of the expression
02:23:09 <sjanssen> cjs: you can use operators to do something like: a -| not.elem |- b
02:23:26 <sjanssen> hmm, but that's a type error
02:24:26 <xenoblitz> hi all... is there a function which works like a fold but which gives output at every application of the function?
02:24:40 <sjanssen> xenoblitz: yep, see scanr/scanl
02:24:45 <Peaker> @type ($$)
02:24:46 <PeakerLambda> Doc -> Doc -> Doc
02:24:47 <sjanssen> > scanl (+) 0 [1 ..]
02:24:48 <PeakerLambda>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
02:24:50 <xenoblitz> thanks sjannsen
02:25:03 <xenoblitz> *sjanssen
02:25:49 <Peaker> > let infixl 1 $$ ; ($$) = flip ($) in 5 $$ not . elem $ [1..10]
02:25:50 <PeakerLambda>   Couldn't match expected type `GHC.Bool.Bool'
02:26:07 <Peaker> @type let infixl 1 $$ ; ($$) = flip ($) in 5 $$ not . elem
02:26:08 <PeakerLambda>     Couldn't match expected type `Bool'
02:26:08 <PeakerLambda>            against inferred type `[t] -> Bool'
02:26:08 <PeakerLambda>     In the second argument of `(.)', namely `elem'
02:26:29 <Peaker> > let infixl 1 $$ ; ($$) = flip ($) in 5 $$ (not.) . elem $ [1..10]
02:26:31 <PeakerLambda>   False
02:26:43 <Peaker> > let infixl 1 $$ ; ($$) = flip ($) in 5 $$ (not.) . elem $ [1..4]
02:26:44 <PeakerLambda>   True
02:27:11 <Peaker> @let result f = (f.)
02:27:12 <PeakerLambda>  Defined.
02:27:59 <int-e> > ((.) not . elem) 1 [2]
02:28:01 <PeakerLambda>   True
02:28:48 <Peaker> > (result not . elem) 1 [2]
02:28:50 <PeakerLambda>   True
02:29:25 <Peaker> > (result.result) not elem 1 [2]
02:29:27 <PeakerLambda>   True
02:29:50 <Peaker> (apply not to the post-2-arguments result of elem)
02:29:56 <int-e> > fmap fmap fmap not elem 1 [2]
02:29:57 <PeakerLambda>   True
02:30:12 <Peaker> :-)
02:30:48 <Peaker> Hey, a cool @specialize could be written to convert method calls to function calls when the type is fixed
02:30:59 <Peaker> so   fmap fmap fmap   is converted to (fmap.fmap)
02:31:17 <Peaker> and then when applied to elem, it can be converted to (result.result)
02:38:12 <int-e> ((.) . (.))
02:38:31 <Peaker> (.) (.) (.)
02:38:52 <Peaker> @type (.) fmap (.)
02:38:53 <int-e> which brings us back to fmap fmap fmap
02:38:53 <PeakerLambda> forall (f :: * -> *) b c a. (Functor f) => (b -> c) -> f (a -> b) -> f (a -> c)
02:39:01 <Peaker> @type (.) (.) fmap
02:39:01 <idnar> Peaker: the Eccentrica Gallumbits operator?
02:39:02 <PeakerLambda> forall a a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> f a1) -> a -> f b
02:39:21 <Peaker> @type fmap (.) (.)
02:39:22 <PeakerLambda> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:40:20 <Peaker> The Plugin/Pl/ package in Lambdabot seems like it could get some of its parts generalized for other fun plugins that do stuff like @specialize above
02:41:11 <Peaker> Hey, even a silly thing that adds verbose type signatures to each term in the expression as inferred could be nice
02:42:49 <Peaker> (Except when they are the same as the general one), e.g: @verbose fmap fmap fmap would become:     fmap::(b->c)->(a->b)->a->c  fmap fmap
02:43:44 <maltem> Is multiple nested layout (say, a case in a let in a do in a case) actually considered bad style? It always strucks me as bad style, but I'm not sure what the community thinks
02:44:31 <C-Keen> how can I recompile cabal packages with profiling informations?
02:44:35 <Peaker> maltem: I think it suggests someone hasn't generalized things enough into reusable/useful components that can be defined separately
02:44:40 <quicksilver> I don't think it's bad style, maltem
02:44:42 <quicksilver> (per se)
02:44:55 <quicksilver> but I tend to fight indentation creep in the interests of legibility.
02:45:46 <maltem> Peaker, ah nice argument, I'm usually only concerned by what quicksilver calls indentation creep
02:45:48 <quicksilver> Peaker: output like fmap[1] fmap fmap [1 : Functor instance is (->) ] might be interesting sometimes.
02:51:21 <hugo___> my code is a monad spaghetti
02:51:52 <osfameron> the AlDente monad?
02:51:54 <yango> yummy
02:51:57 <hugo___> :)
02:52:17 <hugo___> my coding style is monadhell, similar to dllhell
02:52:25 <Peaker> I think with a specializing feature in the code editor, people can be more trigger-happy about writing more of their code with typeclass interfaces rather than specific types
02:52:39 <hugo___> i think will just wrap this monad spaghetti inside a monad
02:53:23 <quicksilver> Peaker: yes, or just some interactive way of visualising which instances have been chosen.
02:53:34 <quicksilver> Peaker: it might be quite nice to have a subscript (added automatically by your editor)
02:53:35 <NameAlreadyInUse> is there some online guide for overloading functions?
02:53:48 <quicksilver> Peaker: fmap_{Maybe} - as I would write it in LaTeX.
02:54:03 <quicksilver> Peaker: not actually there in the source of course :) just an editor display trick.
02:54:22 <quicksilver> NameAlreadyInUse: well Rule (1) is if in doubt, don't do it :)
02:54:32 <quicksilver> NameAlreadyInUse: what kind of thing are you trying to acheive?
02:54:41 <maltem> NameAlreadyInUse: the keywords for overloading in Haskell are type classes and parametric polymorphism
02:55:14 <Peaker> quicksilver: Also, it could be nice if I could ask my editor to specialize a function for some specific types - just so I can grasp it more easily with some concrete example[s]
02:55:37 <quicksilver> maltem: does parametric polymorphism give rise to some kind of overloading?
02:55:52 <NameAlreadyInUse> quicksilver: being able to give "data Etc = ..." a '==' operator
02:56:31 <NameAlreadyInUse> quicksilver: or a '+' operator, or anything really, i am very hazy in my understanding of overloading works
02:56:38 <NameAlreadyInUse> how*
02:56:42 <quicksilver> NameAlreadyInUse: should be covered in all the common tutorials I would have thought
02:56:48 <quicksilver> it's called writing an instance declaration.
02:56:57 <quicksilver> You can derive instances for Eq automatically
02:56:58 <maltem> quicksilver: It does for some definition of overloading
02:57:02 <quicksilver> which do the 'obvious' thing.
02:57:36 <Peaker> does ghc have an extension for standalone "deriving"?
02:57:42 <maltem> quicksilver: also, no type classes without parametric polymorphism
02:57:50 <NameAlreadyInUse> quicksilver: i have read the tutorials but i still have trouble understanding how it works
02:58:14 <quicksilver> NameAlreadyInUse: well, if you just want to derive Eq, you just write
02:58:21 <quicksilver> data Foo = Bar | Baz deriving (Eq)
02:58:28 <quicksilver> if you want to write your own instance you do:
02:58:54 <quicksilver> data Foo = Bar | Baz; instance Eq Foo where Bar == Bar = True; Baz == Baz = True; _ == _ = False;
02:59:08 <quicksilver> probably replacing the ; with newlines in readable source :)
02:59:17 <int-e> @go ghc standalone deriving
02:59:17 <PeakerLambda> Maybe you meant: google googleit . ? @ bf ft ghc id pl rc v wn yow
02:59:28 <int-e> @google ghc standalone deriving
02:59:29 <PeakerLambda> No Result Found.
03:00:37 <int-e> (http://haskell.org/haskellwiki/GHC/StandAloneDeriving)
03:00:39 <PeakerLambda> Title: GHC/Stand-alone deriving declarations - HaskellWiki
03:01:14 <Peaker> Hmm, it would suck to have a duplicate of the Ord class for the ability to put stuff like Complex in a Map.  I think ideally, we should have:  class BaseOrd contain all of Ord's stuff.  and class BaseOrd a => Ord a where <nothing>  to specify that the BaseOrd makes "sense".  So Complex would be BaseOrd (and fit as a map key), but not an Ord (for the mathy-meaning of Ord)
03:02:14 <Peaker> I think Ord currently conflates the mathematic meaning of < and > with the utility of a consistent ordering for things like search trees
03:02:33 <quicksilver> true.
03:02:56 <Peaker> a weak ordering that only guarantees consistency/transiency, vs a strong ordering that is mathematically coherent should be in two separate type-classes.  Ideally not replicate the methods to avoid code duplication
03:03:08 <quicksilver> I would also like a totally opaque ord so we could put IORefs and MVars as keys
03:03:31 <Peaker> quicksilver: why does it matter if you can use (<) between IORefs?
03:04:19 <Peaker> you could rename (<) to lt or such, and have  (<) :: Ord a => a->a->Bool ; (<) = lt   to add the type restriction (but that is dangerous as people will write code that uses (<) instead of lt, and cause code duplication
03:04:28 <quicksilver> Peaker: not referentially transparent, in the strong sense
03:04:29 <Peaker> (where lt is in a BaseOrd class)
03:04:39 <quicksilver> Peaker: because it can vary between successive runs of the program.
03:04:52 <quicksilver> you can argue that that doesn't matter since you can only create IORefs in IO, but that's not very satisfying.
03:05:01 <quicksilver> (would like ST to have a deterministic semantics, for example)
03:05:09 <Peaker> quicksilver: why not? Other things that are created in IO will also vary between runs?
03:05:19 <quicksilver> see my following comment :)
03:05:24 <Peaker> so STRefs would be a problem?
03:05:39 <NameAlreadyInUse> quicksilver: ok, i've got it now
03:05:41 <NameAlreadyInUse> thanks
03:06:04 <Peaker> quicksilver: well, if its "opaque", how do you use it?
03:06:08 <quicksilver> Peaker: the fact that IO is denotationally nondeterministic doesn't mean we want it to be completely non-deterministic.
03:06:22 <quicksilver> we still like to think we understand the semantics of fragments of it.
03:06:28 <quicksilver> otherwise we can't really program in it.
03:06:40 <nomeata> Hi. I have a type of kind (* -> *) -> * that ghc can’t derive Typable for. Can I do it by hand?
03:06:48 <maltem> I thought the standalone-deriving syntax would be 'deriving instance Eq Foo'? Where does 'deriving Eq for Foo' come from?
03:06:51 <Peaker> quicksilver: I don't understand:   x <- newIORef ; y <- newIORef ; (x<y) is now non-deterministic.    But s/newIORef/getChar -- and its just the same?
03:06:59 <quicksilver> Peaker: indeed.
03:07:02 <quicksilver> as I say:
03:07:15 <quicksilver> IO is non-deterministic, but there are fragments of it we would like to have semantics for.
03:07:25 <quicksilver> ST is one such fragment.
03:07:56 <quicksilver> (incidentally it's easy to give a deterministic semantics for getChar too, in terms of adding an inputstream to the environment of the denotation)
03:08:03 <Peaker> Oh, I didn't know ST was considered a "fragment of IO"
03:08:07 <quicksilver> it is.
03:08:12 <quicksilver> what did you think STRef was?
03:08:15 <Peaker> does IORef live in ST too?
03:08:24 <int-e> it's only if you look under the hood
03:08:26 <Peaker> I thought it was a duplication of a subset of IO's functionality :)
03:08:28 <quicksilver> STref is just unsafeIOtoST of IORef
03:08:43 <quicksilver> consider my objections re-framed in terms of STRef if that makes you happier
03:09:00 <Peaker> quicksilver: now I understand
03:09:01 <quicksilver> "I would like an Ord instance for STRef so I can put them in Maps, without breaking ST's referential transparency"
03:09:10 <int-e> in fact quicksilver is turning things on the head, as far as ghc is concerned
03:09:16 <int-e> data STRef s a = GHC.STRef.STRef (GHC.Prim.MutVar# s a)
03:09:17 <int-e> newtype IORef a = GHC.IOBase.IORef (STRef GHC.Prim.RealWorld a)
03:09:19 <int-e> :-P
03:09:23 <quicksilver> ;)
03:09:42 <Peaker> quicksilver: well, just define lt/gt to be the manifestation of this "opaque ord" (lt/gt documented to have non-deterministic results)
03:10:09 <sjanssen> Peaker: bleh, functions can't have non-deterministic results
03:11:18 <Peaker> quicksilver, sjanssen: STRef could advance a counter or something so it is deterministic
03:11:19 <quicksilver> sjanssen: can we implement somethiing like Data.Map without requiring a non-deterministic Ord instance for STRef
03:12:12 <Peaker> and -funsafe-stref could remove that counter for performance, introducing non-determinism-between-program-executions in ST
03:12:43 <sjanssen> quicksilver: for a Map of STRef, I think Peaker's idea is good
03:12:56 * quicksilver nods
03:12:57 <sjanssen> except for that "-funsafe-stref" flag
03:13:12 <sjanssen> -frandomly-change-the-results-of-my-program-please
03:13:14 <Peaker> oh, I guess you could have OrdableSTRef with that counter
03:13:49 <Peaker> so you pay the performance costs when you want a map
03:14:15 <sjanssen> quicksilver: and this could even be done fairly easily with a State transformer over ST
03:14:31 <quicksilver> that's true.
03:14:46 <sjanssen> becomes even more manageable if you use a class to overloaded reference creation/access
03:15:30 <sjanssen> should IORef have an Ord instance?
03:16:53 <int-e> mmm. System.Mem.StableName.StableName doesn't have an Ord instance.
03:17:11 <Peaker> I guess we can also have OrdableComplex instead of a separate typeclass for Ord
03:18:10 <idnar> System.Mem.Stable.Name.StableName.StableName.HelpImTrappedInJavaWorld?
03:18:27 <idnar> actually, that's probably more like the python stdlib than java
03:18:54 <sjanssen> Peaker: personally, I'd just derive an Ord instance for Complex and be done with it
03:19:06 <int-e> in the java world it would have a com.microsoft.reasearch. prefix
03:19:16 * int-e can't type.
03:21:34 <olsner> sjanssen: you mean like an Ord instance on IORefs that works like pointer comparison?
03:22:07 <sjanssen> olsner: or something
03:22:34 <sjanssen> since IORef creation happens in IO, we don't run into problems with non-determinism
03:23:05 <sjanssen> (rather, it's in IO, where we don't really care if things are non-deterministic)
03:23:19 <olsner> but you'd need some kind of global counter to produce a stable key to compare on?
03:23:33 <sjanssen> possibly, I don't know
03:23:43 <olsner> since the GC can move IORefs around
03:24:06 <sjanssen> yes, you clearly can't use the actual address
03:26:22 <quicksilver> sjanssen: I disagree (about not caring about non-determinism in IO)
03:26:32 <quicksilver> sjanssen: I think we still seek a tractable semantics where we can.
03:26:46 <int-e> maybe we should just tie an IORef and a Unique together in one value to get the Ord instance
03:27:02 <quicksilver> and we should aim for determinism unless non-determinism is a vital component of the primitive.
03:27:06 <olsner> newOrdableIORef :: IORefGenerator s -> OrdableIORef s
03:27:18 <olsner> getIORef :: OrdableIORef s a -> IORef a
03:27:26 <olsner> or something, perhaps
03:27:35 <quicksilver> for example, running the same program twice in what the user might reasonably consider "the same environment" should give the same result.
03:27:42 <NameAlreadyInUse> does haskell provide metaprogramming facilities?
03:28:01 <mmorrow>  woot, lunabot has @pl
03:28:04 <mmorrow> , [$pl| \a b c d -> g (f c a b d) |]
03:28:04 <quicksilver> NameAlreadyInUse: yes
03:28:08 <lunabot>  (((g .) .) .) . flip . flip f
03:28:41 <quicksilver> NameAlreadyInUse: there is some lightweight meta-programming in the default class derivations like Enum, Show, Read and Ord, as well as GHC's Typeable.
03:28:49 <MyCatVerbs> NameAlreadyInUse: there's Template Haskell, but nothing in the standard.
03:28:50 <quicksilver> NameAlreadyInUse: for a more general framework there is Template Haskell.
03:29:11 <quicksilver> and various tools implemented including Data.Derive, DrIFT, Uniplate, etc.
03:29:20 <Gilly> @faq can haskell do what NameAlreadyInUse asked?
03:29:20 <PeakerLambda> The answer is: Yes! Haskell can do that.
03:29:28 <NameAlreadyInUse> hah
03:29:39 <NameAlreadyInUse> yeah, that's how it seems
03:30:02 <NameAlreadyInUse> does this "Template Haskell" come with GHC or..?
03:30:02 <MyCatVerbs> NameAlreadyInUse: aside from that, for the most part Haskell hackers rely on the fact that the language's lazy semantics meaning that higher order functions in Haskell can in theory do everything that, say, macros can in Lisp-a-likes.
03:30:32 <quicksilver> not quite everything.
03:30:33 <int-e> @faq Can Haskell prove @faq wrong?
03:30:34 <PeakerLambda> The answer is: Yes! Haskell can do that.
03:30:36 <mmorrow> NameAlreadyInUse: template-haskell has a spec, but it's not in the haskell98 standard. anyway, it lets you construct haskell code by constructing the abstract syntax tree which represents it. also, that AST is represented in and manipulated by haskell.
03:30:47 <MyCatVerbs> NameAlreadyInUse: it's not such a common and widespread thing in the culture, like defmacro or camlp4 and friends are.
03:30:51 <quicksilver> Lisp macros can modify the code of the function they are passed.
03:30:55 <mmorrow> , [|\x -> x|]
03:30:58 <lunabot>  LamE [VarP x_0] (VarE x_0)
03:30:59 <quicksilver> (at least if the code is a literal list)
03:31:05 <mmorrow> , [d|data A = A|]
03:31:07 <lunabot>  DataD [] A [] [NormalC A []] []
03:31:22 <mmorrow> , [d|forall a. (a -> Maybe a) -> Int|]
03:31:24 <lunabot>  luna: parse error on input `->'
03:31:25 <olsner> heh, "LamE", nice name
03:31:26 <mmorrow> , [t|forall a. (a -> Maybe a) -> Int|]
03:31:29 <MyCatVerbs> quicksilver: well yes, that's the problem. Haskell could presumably really, really do with a standardized macro system as well. =)
03:31:29 <lunabot>  ForallT [a_0] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a_0)) (AppT ...
03:31:31 <NameAlreadyInUse> MyCatVerbs: oh, so is it still worth looking into?
03:31:35 <nomeata> Hi. Can someone help me derive a typeable instance for these data types: http://hpaste.org/13429? My code there compiles, but typeOf test gives undefined.
03:31:36 <mmorrow> , [t|forall a. a -> ()|]
03:31:39 <lunabot>  ForallT [a_0] [] (AppT (AppT ArrowT (VarT a_0)) (ConT ()))
03:31:51 <olsner> MyCatVerbs: isn't that what template haskell is?
03:32:00 <mmorrow> olsner: heh, i've never realized that.
03:32:25 <MyCatVerbs> olsner: yes, but it's not in the standards.
03:32:58 <mmorrow> , fmap toLower . take 1 . words . show $ LamE (LitE (IntegerL 42))
03:33:00 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
03:33:08 <olsner> ah, but it's in ghc and that's what counts (arguably)
03:33:16 <MyCatVerbs> NameAlreadyInUse: what for? If you're working in Haskell and feel you might want metaprogramming, hit up Template Haskell and hopefully it'll suffice for your purposes. If not, uh, bugger?
03:33:23 <mmorrow> ,show $ LamE (LitE (IntegerL 42) )
03:33:25 <lunabot>  luna: Couldn't match expected type `[Language.Haskell.TH.Syntax.Pat]'
03:33:29 <NameAlreadyInUse> great, i will look it up
03:33:30 <mmorrow> oops
03:33:34 <mmorrow> , fmap toLower . take 1 . words . show $ LamE [] (LitE (IntegerL 42))
03:33:36 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
03:33:40 <mmorrow> grr
03:33:49 <quicksilver> nomeata: that code looks confused to me.
03:34:16 <quicksilver> nomeata: "State" has only one parameter, as a type constructor, not two.
03:34:26 <int-e> mmorrow: fmap toLower doesn't work on a list of strings
03:34:41 <quicksilver> nomeata: (ditto User, Computer)
03:34:47 <mmorrow> , (++"!!") . fmap toLower . concat . take 1 . words . show $ LamE [] (LitE (IntegerL 42))
03:34:50 <lunabot>  "lame!!"
03:34:50 <mmorrow> int-e: heh
03:34:50 <quicksilver> I thought GHC could derive typeable instances for that kind of thing anyhow.
03:34:53 <Gilly> is it possible to crosscompile with ghc? (i'd like to create applications for my embedded device by compiling them on my pc)
03:34:57 <quicksilver> Gilly: no.
03:35:09 <Gilly> :/
03:35:15 <mmorrow> int-e: that one took me a sec to realize :)
03:35:28 <Gilly> workarounds?
03:35:33 <MyCatVerbs> Gilly: you might want to look at JHC, which spits out ANSI C as output.
03:35:49 <Gilly> mmm that could work
03:36:01 <mmorrow> you'd need to find a third party gc though..
03:36:05 <paper_cc> MyCatVerbs: can't I take immediate output from ghc -fvia-C?
03:36:14 <MyCatVerbs> Gilly: but Haskell isn't really designed for embedded environments anyway. We tend to assume that there's a lot of RAM hanging around.
03:36:24 <olsner> aren't the ghc code generation rewrites supposed to culminate in a cross-compiling ghc?
03:36:29 <mmorrow> (i was just looking at one) http://www.hpl.hp.com/personal/Hans_Boehm/gc/
03:36:30 <PeakerLambda> Title: A garbage collector for C and C++
03:36:40 <Gilly> MyCatVerbs: hm, i ssee
03:36:48 <mmorrow> i think that'd be drop-in-able
03:36:52 <MyCatVerbs> paper_cc: mainly the mangler, I think.
03:37:09 <nomeata> quicksilver: right, I’ll try to fix that.
03:37:15 <Gilly> i just saw that someone had xmonad running on neo freerunner
03:37:35 <quicksilver> nomeata: note that you're not actualy using ref's Typeable1 instance
03:37:35 <Gilly> (which would be my target device too)
03:37:45 <mmorrow> Gilly: check out TIMBER. it's designed to be fully realtime and specifically for (but not limited to) embedded environments
03:37:47 <quicksilver> nomeata: I think your problem lies tehre.
03:37:57 <nomeata> quicksilver: ok, I’ll try that
03:38:19 <Gilly> mmorrow: thanks
03:38:42 <mmorrow> Gilly: it looks cool. i've only ever just built the demo progs though :) (it just was released the other week)
03:38:54 <stu8ball> If the Freerunner could be a USB host and be charging at the same time, I probably would get one.
03:39:10 <quicksilver> nomeata: typeOf (User a b) = mkTyConApp (mkTyCon "User") [typeOf1 b]
03:39:14 <quicksilver> nomeata: works for me.
03:39:28 <stu8ball> (Because if it could do those things at the same time, then it would be repurposeable to just about any task, therefore have a mad long lifespan, and therefore be worth the cost)
03:40:00 <mmorrow> , ConT (mkName "User") `AppT` ''()
03:40:05 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Type'
03:40:17 <mmorrow> , ConT (mkName "User") `AppT` (ConT ''())
03:40:19 <lunabot>  AppT (ConT User) (ConT GHC.Unit.())
03:40:24 <mmorrow> , ppDoc $ ConT (mkName "User") `AppT` (ConT ''())
03:40:27 <lunabot>  User ()
03:40:29 <quicksilver> I wonder why GHC can't derive it. Doesn't seem hard.
03:40:44 <quicksilver> Do we need a Typeable hierarchy matching our kind hierarchy though?
03:41:08 <nomeata> quicksilver: and can don’t get undefined when you try "typeOf State" in GHC?
03:41:24 <quicksilver> nomeata: I get State []
03:41:35 <mmorrow> hmm, maybe a constructor is hidden. i know GHC refuses to standalone-derive in that case (dunno if we're even talking about standalone deriving here...)
03:41:52 <quicksilver> nomeata: which is not right, of course :)
03:41:54 <ivanm> lambdabot is MIA I take it?
03:41:56 <quicksilver> nomeata: but at least it's not undefined.
03:43:00 * mmorrow finally found the link in scrollback
03:43:46 <mmorrow> oh, it's giving you undefined for the same reason you'll get undefined if you use the actual arg in a Storable instance
03:43:58 <mmorrow> you can't use the value, just the type
03:44:57 <mmorrow> typeOf _ = mkTyConApp (mkTyCon "User") [typeOf (undefined::Key (User ref)), typeOf (undefined::...)]
03:45:19 <quicksilver> mmorrow: no, it's giving him undefined because he wrote it wrong.
03:45:23 <quicksilver> nomeata: typeOf (State a b) = mkTyConApp (mkTyCon "State") [head . typeRepArgs . typeOf . head $ b]
03:45:32 <quicksilver> nomeata: is the correct instance for State, I think.
03:45:45 <quicksilver> > typeOf test
03:45:46 <quicksilver> State Main.Key
03:45:46 <PeakerLambda>   Add a type signature
03:45:53 <mmorrow> i'm pretty sure Typeable will call typeof with undefined no matter what the arg (?)
03:46:14 <quicksilver> that is true.
03:46:17 <quicksilver> but it's not the point.
03:46:29 <quicksilver> you can choose to call typeOf on an actual representative if you like
03:46:32 <quicksilver> e.g. a and b
03:46:41 <quicksilver> it's just, that's not what he should be doing here.
03:47:18 <mmorrow> ah, i haven't seen the semantic meaning of the code yet
03:47:22 * mmorrow looks
03:47:23 <nomeata> quicksilver: http://hpaste.org/13429#a1 works better, as I get good values for "typeOf test" and "typeOf (let State [a] [b] = test in b)"
03:48:01 <nomeata> quicksilver: but "typeOf [test]" gives undefined – it somehow can’t wrap my types in other types
03:48:23 <quicksilver> nomeata: hmm. That's interesting.
03:48:31 <schme> boing boing
03:49:34 <quicksilver> nomeata: I get the same error with my more concrete definitions of typeOf
03:49:47 <mmorrow> quicksilver: ok, i see what you're saying. i'm not sure if how the code is written is semantically correct or not, but i'm pretty sure that him trying to pattern match on the arg to typeOf in the instance is trying to pattern match on undefined
03:50:02 <quicksilver> mmorrow: Oh. Duh.
03:50:04 <nomeata> mmorrow: oh, right.
03:50:06 <quicksilver> Yes, of course.
03:50:06 <nomeata> shame on me
03:50:12 <nomeata> I got confused by TyCon verses DataCon
03:50:13 <quicksilver> mmorrow: now I understand what *you* were saying :)
03:50:14 <mmorrow> hehe :)
03:50:16 <nomeata> and thought I had to match :-)
03:50:36 <nomeata> ok, now it works :-)
03:50:43 <mmorrow> @yow
03:50:43 <PeakerLambda> Couldn't find fortune file
03:51:26 <schme> :t coffee
03:51:27 <PeakerLambda> Not in scope: `coffee'
03:51:31 <schme> Bah!
03:52:10 <nomeata> too bad ghc can’t derive that instance for me.
03:52:27 <quicksilver> nomeata: http://hpaste.org/13429#a2
03:52:41 <quicksilver> nomeata: for a concrete version, instead of using (undefined :: ref ())
03:53:06 <quicksilver> nomeata: I think it's a matter of taste which you prefer.
03:53:15 <nomeata> quicksilver: well, I don’t think I want to mention Computer in the type of User (as that’s fixed)
03:53:23 <nomeata> quicksilver: I just want to mention the ref type
03:53:30 <nomeata> quicksilver: with http://hpaste.org/13429#a3 I get:
03:54:01 <nomeata> typeOf test: State Main.Key and  typeOf (let State [a] [b] = test in a): User Main.Key
03:54:18 <nomeata> quicksilver: which corresponds to the type signatures, so seems to be right
03:54:30 <quicksilver> nomeata: I don't know what you mean by mentioning Computer in the type of User?
03:54:45 <quicksilver> you mean the way I'm using 'owner'?
03:54:49 <nomeata> yes
03:54:56 <quicksilver> that's only because it's a convenient source of ref
03:55:09 <nomeata> right, but it won’t be there in the general sense.
03:55:27 <quicksilver> it's going to be somewhere, unless it's a phantom.
03:55:39 <quicksilver> if it's a phantom then the way you are doing it is the only way, I agree.
03:55:44 <nomeata> there could be "data Something ref     = Something { somethingId :: Key (Something ref), staticData :: String }
03:55:58 <quicksilver> yes, that would be a phantom.
03:56:19 <quicksilver> then you'd have to use undefined, because your phantom has no representative.
03:56:26 <nomeata> Yes, I guess that’s right
03:57:16 <quicksilver> some part of me prefers using a representative, to using 'ref ()'
03:57:27 <quicksilver> because 'ref ()' feels peculiarly arbitrary
03:57:32 <quicksilver> but I don't think it's important.
03:59:51 <nomeata> quicksilver: probably not. typeOf1 seems to ignore the type argument
04:00:12 <nomeata> quicksilver: I wonder if there is a way to get around defining this instance for every ref’able type
04:00:44 <nomeata> but I can’t think of a way. Using TH might be ok, though.
04:01:33 <C-Keen> where can I see what opions are allowed in a cabal file?
04:07:09 <nomeata> arg, darn. I can’t write a Data.Generics based function "State Key -> State Id" that resolves all references, because a transformer has to preserve the type.
04:08:01 <schme> So I was wondering, how do I go about debugging haskell programs?
04:09:07 <nomeata> well, time for lunc
04:09:49 <schme> No?
04:13:36 <hugo___> i have this single element, and i want to transform it into a list of a single element
04:13:41 <hugo___> how do i do this ?
04:15:18 <Peaker> > return 5 :: [Int]
04:15:20 <PeakerLambda>   [5]
04:15:26 <Peaker> > 5:[]
04:15:28 <PeakerLambda>   [5]
04:16:26 <hugo___> isn't there anything with less syntax ?
04:16:39 <Peaker> x:[] is not a lot of syntax.. :)
04:16:40 <darx> What's the best resource for learning haskell bottom up?
04:16:48 <Peaker> hugo___: return x  is also just 1 token
04:17:12 <hugo___> with the extra :: [a]
04:17:14 <Peaker> darx: People recommend Real World Haskell. There's also Learn You a Haskell For Great Good (which is more light spirited), which I heard is good
04:17:19 <Peaker> hugo___: You don't need the extra ::[a]
04:17:33 <darx> Peaker: It's not bottom up
04:17:38 <idnar> > [5]
04:17:39 <PeakerLambda>   [5]
04:17:40 <Peaker> darx: what is it?
04:17:48 <Peaker> hugo___: you could also just use [x]
04:17:53 <Peaker> if you have it as an expression
04:17:56 <darx> Peaker: neither of what you suggested
04:18:05 <Peaker> darx: no, what is it if not bottom up?
04:18:12 <Peaker> darx: it teaches the basics and then more advanced stuff, and so on
04:18:34 <Peaker> gotta go. If I'm not here when lambdabot returns, just /kick PeakerLambda ?
04:18:36 <darx> Peaker: I think I need to learn how it's all build up from lambdas
04:18:43 <quicksilver> Peaker: sure.
04:18:47 <darx> *pure lambdas
04:18:51 <quicksilver> Peaker: if I notice :)
04:19:04 <Peaker> quicksilver: thanks.  see ya soon
04:19:28 <quicksilver> darx: it's not.
04:19:34 <quicksilver> datas are not built from lambdas :)
04:19:47 <darx> quicksilver: at least conceptually?
04:19:56 <darx> that's the whole idea i persume!
04:19:58 <quicksilver> no, not even conceptually.
04:20:05 <darx> *presume
04:20:12 <quicksilver> conceptually there are two kinds of things
04:20:13 <schme> darx: I suppose you should browse around the ghc sources.
04:20:15 <quicksilver> (1) constructors (2) lambdas
04:20:23 <maltem> darx: I do recommend the gentle introduction for a bottom-up document
04:20:24 <quicksilver> darx: have you tried the wikibook?
04:20:28 <quicksilver> or YAHT?
04:20:48 <maltem> darx: it explains pretty much everything to know about the Haskell 98 language
04:20:52 <darx> wikibook? no..
04:21:12 <darx> I have trouble with types and data
04:21:12 <maltem> @where gentle
04:21:12 <PeakerLambda> http://www.haskell.org/tutorial/
04:21:40 <quicksilver> hutton's book is also well received. That's not available online though.
04:22:04 <darx> quicksilver: please continue about the conceptual framework.
04:22:09 <darx> if you don't mind
04:22:42 <quicksilver> when you try to do something with a haskell expression, there are two things you can do
04:22:46 <quicksilver> (1) apply it to an argument
04:22:52 <quicksilver> (which only makes sense for functions)
04:23:01 <quicksilver> (2) dispatch/unwrap the constructor
04:23:06 <quicksilver> (which only makes sense of data)
04:23:17 <quicksilver> of course, the type system ensures you can only ever do the sensible thing.
04:23:31 <darx> so what's the difference between type and data
04:23:36 <quicksilver> type is just a synonym
04:23:40 <quicksilver> type QSInt = Int
04:23:43 <darx> and the different methods to declare them?
04:23:48 <quicksilver> QSInt and Int are now the same type.
04:23:51 <quicksilver> it's not very useful.
04:23:57 <quicksilver> it's just for documentation or saving typing
04:24:14 <quicksilver> type ShortName = SomethingVeryLong AndIntricate WithLotsOf TypeArguments
04:24:21 <darx> Ah.
04:24:28 <quicksilver> data and newtype declare brand new types
04:24:33 <darx> so you can't make anything with the type keyword?
04:24:47 <quicksilver> data QSInt = QSConstructor Int
04:24:53 <quicksilver> QSInt is now a brand new type
04:25:00 <quicksilver> (although it has an Int inside)
04:25:06 <darx> i understand that.
04:25:16 <quicksilver> darx: yes, type doesn't 'make anything new'. It's just making an alias.
04:25:35 <quicksilver> you'd still be able to pass Ints to functions expecting QSInts, in that first "type" version. And vice versa.
04:25:47 <quicksilver> In the second, "data", version the compiler would complain if you tried.
04:26:48 <darx> I read somewhere that lambdas can store data.
04:27:04 <darx> and that there is no difference between them conceptually.
04:27:55 <darx> you know how numbers can be defined as a recursive nested lists of empty lists?
04:28:00 <darx> *like how
04:28:42 <darx> like how there is only nothing and something
04:29:02 <BONUS> well lambdas can have data
04:29:03 <BONUS> like
04:29:06 <BONUS> \_ -> 5
04:29:27 <BONUS> or maybe you mean church encoding
04:29:28 <BONUS> http://en.wikipedia.org/wiki/Church_encoding
04:29:29 <PeakerLambda> Title: Church encoding - Wikipedia, the free encyclopedia
04:30:01 <darx> it just drives me mad that i have to drudge down to grok how it really works
04:30:08 <mmorrow> , let n2l = flip replicate () in n2l 5
04:30:21 <lunabot>  [(),(),(),(),()]
04:30:26 <mmorrow> , let n2l = flip replicate (); l2n = length in l2n (n2l 5)
04:30:29 <lunabot>  5
04:30:31 <quicksilver> darx: everything is just numbers.
04:30:32 <mmorrow> ?
04:30:39 <darx> binary
04:30:40 <quicksilver> darx: all a computer stores in bits and those represent numbers.
04:30:47 <quicksilver> however, that's not very insightful.
04:30:53 <quicksilver> reductionism isn't always insightful.
04:31:04 <quicksilver> it's more convenient to believe that data and constructors are something different
04:31:10 <quicksilver> if you wish to understand haskell.
04:31:19 <quicksilver> sorry, data and functions
04:31:24 <darx> yeah but conceptually, if you know how it's build, then perhaps it's helpful?
04:31:25 <quicksilver> data and code, if you like.
04:31:35 <quicksilver> darx: it's built out of bits.
04:31:39 <quicksilver> was that helpful? ;)
04:31:45 <quicksilver> I think not.
04:32:22 <mmorrow> , let expand n = fmap ((==0) . (.&.n)) (fmap (1::Int`shiftL`) [0..31]) in expand 6352
04:32:24 <lunabot>  luna: parse error on input `)'
04:32:34 <quicksilver> What is helpful is to know that a 'thunk' (the GHC representation of a haskell value) is either a constructor, or it's a piece of code waiting to be evaluated, or its a piece of code waiting for an argument
04:32:41 <quicksilver> the first option is very concrete
04:32:47 <quicksilver> the last option is a lambda
04:32:57 <mmorrow> , let expand n = fmap ((==0) . (.&.n)) (fmap ((1::Int)`shiftL`) [0..31]) in expand 6352
04:32:59 <lunabot>  [True,True,True,True,False,True,False,False,True,True,True,False,False,Tr...
04:33:00 <quicksilver> the middle option is like a lambda except it's not actually waiting for an argument.
04:33:11 <quicksilver> so it's just a piece of code waiting to be run.
04:33:44 <darx> ok
04:34:19 <mmorrow> if you were using a strict function language, a (\() -> f x) would be kinda similar to a thunk
04:34:24 <mmorrow> *functional
04:34:28 <quicksilver> the middle option is what makes haskell lazy
04:34:40 <quicksilver> if you missed it out, you'd get a possible implementation for a strict language, yes.
04:36:09 <mmorrow> , let force !x = x in fmap closureType (iterate force (1 + 1 + 1 + 1))
04:36:12 <darx> I think I need to read more.
04:36:22 <lunabot>  [AP,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk ...
04:36:35 <mmorrow> aww, i thought it was gonna do something else
04:36:54 <mmorrow> (namely be [a,b,c,d,d,d,d,...])
04:37:09 <mmorrow> that makes sense though
04:37:23 <mmorrow> hmm
04:38:18 <idnar> Thunk Thunk Thunk Thunk Mushroom Mushroom
04:38:32 <mmorrow> , let y = 1 + 1 + 1 in [y, y `seq` closureType y, rnf y `seq` closureType y]
04:38:35 <lunabot>  luna: No instance for (Control.Parallel.Strategies.NFData
04:38:43 <mmorrow> , let y = (1::Int) + 1 + 1 in [y, y `seq` closureType y, rnf y `seq` closureType y]
04:38:45 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
04:38:52 <mmorrow> oh
04:38:59 <mmorrow> , let y = (1::Int) + 1 + 1 in [closureType y, y `seq` closureType y, rnf y `seq` closureType y]
04:39:08 <lunabot>  [AP,Constr,Indirection 28]
04:39:12 <mmorrow> nice
04:39:57 <EvilTerran> ,src 'closureType
04:40:02 <mmorrow> , let bam !x = x; y = (1::Int) + 1 + 1 in [closureType y, y `seq` closureType y, let z = bam (rnf y) in z `seq` closureType z]
04:40:05 <lunabot>  Killed.
04:40:12 <lunabot>  [AP,Constr,Constr]
04:40:14 <mmorrow> EvilTerran: RtClosureInspect.getClosureData
04:40:16 <EvilTerran> ...
04:40:17 <EvilTerran> ok
04:40:29 <EvilTerran> where's that, then?
04:40:32 <mmorrow> closureType a = unsafePerformIO (tipe `fmap` getClosureData a)
04:40:40 <mmorrow> EvilTerran: it's in the ghc package
04:40:46 <mmorrow> (which is hidden by default)
04:40:49 <mmorrow> ghci -package ghc
04:41:02 <mmorrow> it's super interesting
04:41:08 <idnar> tipe? *groan*
04:41:12 <mmorrow> heh
04:41:36 <int-e> well, 'type' is a keyword :)
04:41:38 <darx> mmorrow: what do you suggest I should read?
04:42:02 <darx> Top down learning isn't for me.
04:42:22 <schme> darx: I suggest you read less, hack more ;)
04:42:31 <darx> LOL
04:42:36 <darx> yes that too
04:44:14 <schme> darx: other than that I suggest you read ghc sources. I can't imagine a better way to see how it is built up.
04:44:25 <nomeata> hi again.
04:44:39 <schme> Hi
04:45:29 <nomeata> I’m wondering, if I have a function (A -> B), can I a generic function with type ((Data c A, Data c B) => c A -> c B) somehow?
04:46:03 <mmorrow> EvilTerran: http://hpaste.org/13430
04:46:04 <nomeata> where c is a type of kind * -> *, obviously?
04:46:37 <mmorrow> darx: schme has a good point :)
04:47:04 <darx> will do. thanks all
04:47:32 <mmorrow> darx: but seriously, i think knowing how stuff is working to the extent that you can reason about it is totally necessary with haskell
04:47:56 <mmorrow> like when to but bangs on stuff
04:48:00 <jpcooper> main = communicationList nodes <$> (getArgs >>= listenOn . PortNumber . read . head)
04:48:00 <int-e> mmorrow: let y = isEvaled y in y :)
04:48:07 <jpcooper> does anyone know of a nicer way in which to write that?
04:48:13 <jpcooper> @pl main = communicationList nodes <$> (getArgs >>= listenOn . PortNumber . read . head)
04:48:14 <PeakerLambda> main = communicationList nodes <$> (listenOn . PortNumber . read . head =<< getArgs)
04:48:15 <int-e> mmorrow: (returns False though, not very surprisingly.)
04:48:20 <mmorrow> , let y = isFullyEvaluated y in y
04:48:31 <mpwd_> darx: I can suggest some literature to you if you like.  You were alluding to the von Neumann/Frege/Peano idea of how to construct the integers.  My favorite books on these subjects are both by a logician named Enderton, "Introduction to Set Theory" and "Introduction to Mathematical Logic"
04:48:35 <lunabot>  False
04:48:37 <mmorrow> heh
04:48:48 <mmorrow> , foldl (+) 0 [0..1000000000]
04:48:52 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:48:54 <mmorrow> , foldl' (+) 0 [0..1000000000]
04:49:00 <lunabot>  Killed.
04:49:06 <mpwd_> darx: As for the lambda calculus, I actually found a really cool textbook online the other day... let me find it.
04:49:06 <mmorrow> , foldl (+) 0 [0..100000000]
04:49:09 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:49:11 <mmorrow> , foldl' (+) 0 [0..100000000]
04:49:18 <lunabot>  Killed.
04:49:21 <mmorrow> grrr
04:49:24 <mmorrow> , foldl' (+) 0 [0..10000000]
04:49:26 <darx> mpwd_: Cooolll..
04:49:26 <quicksilver> nomeata: not completely genericaly, no. There might be negative occurences of A.
04:49:28 <lunabot>  50000005000000
04:49:31 <mmorrow> , foldl (+) 0 [0..10000000]
04:49:35 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:49:38 <Gilly> when will haskell know that's just 100000001*100000000/2 ? :)
04:49:43 <quicksilver> nomeata: however, for positive occurrences of A, that is very much what Uniplate does, I believe.
04:49:48 <int-e> , let n = 100000000 in n*(n+1) `div` 2 {- *ducks* -}
04:49:50 <mpwd_> darx: But schme is right, you should really hack a lot.
04:49:50 <lunabot>  5000000050000000
04:50:01 <mmorrow> , foldl (\(a,b) c -> (a+c,b+c)) (0,0) [0..10000000]
04:50:09 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:50:09 <darx> mpwd_: I do both.
04:50:10 <mmorrow> , foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..10000000]
04:50:12 <nomeata> quicksilver: thx, I’ll check that
04:50:13 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:50:15 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..10000000]
04:50:17 <int-e> , 42 -- do single line comments still cause trouble?
04:50:21 <lunabot>  Killed.
04:50:23 <lunabot>  luna: parse error (possibly incorrect indentation)
04:50:29 <darx> mpwd_: but I'm not comfortable without understanding what the heck I'm doing.
04:51:02 <darx> mpwd_: I try to do both that is.. LOL
04:51:09 <schme> mmorrow: I always have good points!
04:51:16 <quicksilver> nomeata: (and there might be arbitrarily complex occurences of A. What do you do with r ( r ( r (A -> r (A)) -> A) ) ?
04:51:19 <quicksilver> nomeata: ;)
04:52:00 <mpwd_> darx: Me neither.  Actually, I'm doing a MSc in logic right now and I'm sad that I really only do conceptual stuff and never any nuts and bolts.
04:52:08 <nomeata> quicksilver: well, for my application, everything are simple type algebraic data types
04:52:17 <nomeata> although here, the A and B have kind (* -> *)
04:52:32 <mmorrow> darx: totally. one good way to reason about when you need to force things is.. suppose you're in a "loop" and you're doing something similar to (or exactly) like incrementing a number. if you're not testing that that number's ==0 or anything like that that necessitates that it be evaluated every time through, it'll just build up into an enormous stack blowing thunk
04:52:41 <mmorrow> so in that case you want to force it
04:54:07 <mmorrow> and by loop i mean like  go 0 m = m; go n m = go (n-1) (n+m)
04:54:23 <mmorrow> there you don't need toi force the `n', but you'd want to force the `m'
04:54:42 <mmorrow> go 0 !m = m; go n !m = (n-1) (n+m)
04:55:22 <mmorrow> that's pretty much all there is to it (that i can think of off the top of my head)
04:55:31 <mmorrow> (that "general idea")
04:57:26 <mmorrow> int-e: heh, yeah i should fix that
04:57:36 <Axman6> zomg, SPJ replied to a bug i filed :o
04:57:52 <ivanm> Axman6: :o
04:58:03 <ivanm> so when do you get RWH?
04:58:04 <Axman6> ivanm!
04:58:09 <Axman6> i gotst mah RWH today!
04:58:17 <ivanm> \o/
04:59:02 <ivanm> you obviously lost your ability to spell though...
04:59:07 <ivanm> :p
04:59:32 * Axman6 resists the urge to prove you right with a 'no u!'
05:00:04 <ivanm> heh
05:00:25 <nomeata> quicksilver: hmm, no, can’t find a function that repalces types there either
05:00:45 <Axman6> http://hackage.haskell.org/trac/ghc/ticket/2881 is the bug, if you were wondering
05:00:47 <redditbot> Generate Windows installers for your Haskell apps
05:00:47 <redditbot> COM bindings and support for Haskell
05:00:59 <Axman6> thanks mmorrow for the extra testing ;)
05:01:40 <nomeata> ah, smash shounds good
05:03:27 <mmorrow> Axman6: heh, i was just looking at it. that's amazing that no one's pattern matched on a Word literal and reported this before :)
05:03:40 <Axman6> heh, indeed
05:03:56 <mmorrow> , case undefined of (0::Word) -> undefined
05:03:58 <lunabot>  luna: Illegal signature in pattern: Word
05:04:10 <mmorrow> , case (0::Word) of 0 -> undefined
05:04:12 <nomeata> hmm, but smash is not on hackage
05:04:12 <lunabot>  luna: Prelude.undefined
05:04:32 <mmorrow> , case (undefined::Word) of 0 -> undefined
05:04:34 <lunabot>  luna: luna: panic! (the 'impossible' happened)
05:04:48 <mmorrow> , case (undefined::Word32) of 0 -> undefined
05:04:50 <lunabot>  luna: Prelude.undefined
05:05:33 <mmorrow> heh, there simply doesn't exists a bytecode to pattern match on Word literals (but Word{8,16,32,64} are covered)
05:05:57 <mmorrow> (apparently)
05:09:26 <Axman6> mmorrow: seems like a rather large oversight to me, but oh well, guess i'm just special :)
05:09:38 * Axman6 gets back to RWH before going to sleep
05:10:29 <mmorrow> Axman6: i was trying to think if i've ever pattern matched on a numeric literal other than an Int(eger), and i can't say that i recall ever (doing so)
05:11:06 <mmorrow> oh, i pattern match on Word8's a bunch
05:11:17 <Axman6> ByteStrings?
05:11:31 <mmorrow> yeah, or similar
05:17:27 <jpcooper> @pl (apply toProcess $ replaceNodes nodes curState) <$ send toSend
05:21:12 <Axman6> @src Char
05:21:23 <Axman6> oh noes!
05:21:38 <jpcooper> Axman6, what have you done!
05:21:54 <ivanm> preflex: seen lambdabot
05:21:54 <preflex>  lambdabot was last seen on #haskell 4 hours, 28 minutes and 19 seconds ago, saying: forall a. (forall s. ST s a) -> a
05:22:19 <jkff> > 1 + 1
05:22:35 <jkff> Well, looks like lambdabot is already celebrating the New Year
05:22:39 <Stephan202> :)
05:22:43 <ivanm> heh
05:22:44 <jkff> He has deserved the right to do so
05:22:50 <ivanm> s/he/she/
05:22:54 <idnar> heh
05:23:00 <mreh> @type if
05:23:27 <ivanm> mreh: if isn't a function
05:23:37 <ivanm> it's a hard-wired construct in haskell
05:23:40 <mreh> i was just trying to see if it was
05:23:51 <ivanm> nope
05:24:14 <BONUS> you can do if' p x y = if p then x else y
05:24:23 <jkff> However, there is Control.Monad.when
05:24:37 <mreh> it's just a ternary function in reality
05:24:43 <mreh> a higher order function
05:25:10 <mreh> i was just a little confused by the syntax in RWH chapter 2
05:25:48 <jkff> Or, troo = \a b -> a ; falth = \a b -> b ; eef = id
05:26:33 <mreh> @let if True y z = y
05:26:33 <ivanm> mreh: I wouldn't really call it a higher order/ternary _function_
05:26:36 <ivanm> as it sin't a function
05:26:38 <ivanm> mreh: no bot
05:26:40 <ivanm> ;-)
05:26:42 <mreh> @let if False y z = z
05:27:02 <mreh> it so is a function!!!
05:27:10 <ivanm> mreh: besides, that's not the correct syntax for a let definition
05:27:22 <ivanm> mreh: how is it a function? it has the then and else keywords in it!
05:27:34 <ivanm> if...then...else... are keywords
05:27:40 <jkff> mreh: Of course it is, because it can be expressed even in untyped lambda calculus as I showed. However, in Haskell, it is also implemented as a syntactic primitive.
05:27:49 <mreh> see
05:27:53 <mreh> :P
05:28:23 <jkff> (Although, IIRC how STG works, it is actually *implemented* the way I showed)
05:28:25 <ivanm> jkff: well, yes, we're talking about the if...then...else... construct in _Haskell_, not the actual CS definition
05:28:38 <jkff> (as all ADT are)
05:29:19 <mreh> it still has to be evaluated like a function
05:30:03 <mreh> everything in a haskell is either a variable or a function application
05:30:15 <mreh> every expression
05:30:34 <ivanm> mreh: I wouldn't say that
05:30:37 <BONUS> or a pattern match
05:30:38 <jkff> ...Or a case expression, at least.
05:30:39 <jkff> Yes
05:30:52 <ivanm> oh, every expression, maybe...
05:30:53 <mreh> ive opened a can of worms
05:30:58 <mmorrow> if b then t else f ===> case b of True -> t; False -> f
05:31:00 <BONUS> a can of words
05:31:00 <BONUS> haha
05:31:31 <mmorrow> and case _is_ a primitive
05:31:57 <mreh> it would have to be
05:31:59 <mmorrow> (separate from function application)
05:32:03 <mmorrow> yeah
05:32:21 <mmorrow> well, you actually could only use functions
05:32:37 <mreh> id tend to use pattern matching instead of a cases
05:32:38 <mmorrow> SAPL does that in a pretty nifty way
05:32:40 <mreh> more readable
05:32:47 <jkff> btw, is polymorphically typed lambda calculus enough to express pattern matching on ADT?
05:32:58 <mmorrow> but case and pattern matching are the same thing (i know what you mean though)
05:34:09 <mmorrow> jkff: the way that SAPL does it is say you have
05:34:12 <mreh> does it take the case and expand it to many functions, one for each case, using the case variable as an iterator
05:34:24 <mmorrow> dat Foo a b = Foo a | Bar a b
05:34:26 <jkff> What is SAPL?
05:34:27 <mmorrow> data Foo a b = Foo a | Bar a b
05:34:39 <mmorrow> that tranforms into
05:35:24 <jkff> case f of Foo a -> g a | Bar a b -> h a b == f (\a -> g a) (\a b -> h a b) == f g h
05:35:37 <mmorrow> foo a f _ = \f' b' -> f a f' b'
05:35:44 <jkff> Foo = \f -> f a undefined
05:35:49 <mmorrow> bar a b _ b = \f' b' -> b a b f' b'
05:35:53 <jkff> Foo = \a f -> f a undefined
05:36:06 <mmorrow> so constructors become functions that "pattern match on their own"
05:36:11 <jkff> Ouch, you are right and I am not
05:36:46 <mmorrow> jkff: these two papers:
05:36:47 <mmorrow> http://www.st.cs.ru.nl/papers/2006/janj2006-TFP06-EfficientInterpretation.pdf
05:36:55 <mmorrow> http://www.st.cs.ru.nl/papers/2005/janj2005-PatternMatchingByFunctionsIFL05.pdf
05:37:02 <jkff> Yes, I was just wondering whether it can be done only in untyped lambda, or also in typed.
05:37:13 <jkff> But thanks for the papers :)
05:37:26 <mmorrow> jkff: also, that's untypeable in haskell (without using a newtype to guard the infinite type)
05:37:46 <mmorrow> jkff: no problem, it's totally mind-twisting :)
05:37:55 <jkff> Hmm, that's interesting; which one is untyped?
05:38:08 <jkff> foo and bar?
05:38:30 <mmorrow> err, i meant that you'd get a "can't .. the infinite type .. " error in haskell, unless you use a strategic newtype
05:38:42 <mmorrow> it's still typed though
05:38:55 <jkff> *untypeable
05:38:56 <mmorrow> (but types get erased during compilation)
05:39:23 <pejo> mmorrow, what does the first paper say, that SAPL interpreters are educational and surprisingly close in efficiency to "real" interpreters?
05:39:25 <jkff> ghci tells me that foo :: t -> (t -> t2 -> t3 -> t4) -> t1 -> t2 -> t3 -> t4
05:40:48 <mmorrow> pejo: it's actually a non-toy thing. the reduceron uses this method for instance to simplify the bytecode that they'd have to interpret on an fpga. also i read somewhere that clean uses SAPL as an intermediate language, but i'm not sure about that
05:41:30 <mmorrow> there's also a ppt presentation by the SAPL guy that give a (simple but) working compiler to C in just a few slides
05:41:36 <mmorrow> cool
05:41:49 <chrisdone> what's the flg to tell hscolour to use a provided css file?
05:41:55 <mmorrow> -css
05:41:59 <chrisdone> LIES
05:42:12 <chrisdone> it just highlights the provided css file ;_;
05:42:13 <mmorrow> heh
05:42:15 <mmorrow> http://fpdag2007.hypernation.net/publications/FPDag2007-jansen.ppt
05:42:46 <mmorrow> chrisdone: the default .css is way hackable
05:43:08 <hcube> Hi! i'm in trouble with HXT. here is the problematic code: http://hpaste.org/13434  can anybody help please?
05:43:12 <mmorrow> here's my version http://moonpatio.com/css/hscolour.css
05:43:46 <memento> if I have type Predicate = (String, Integer), and type Expr = Predicate | foo | bar, then if I use return $ Predicate (x, y) (where x string, y integer) why does the compiler sais: Couldn't match expected type `([Char], Int) -> a' against inferred type `Expr'
05:43:52 <C-Keen> I'd like to repeat my question that went down unanswered an hour ago: Where cna I look up teh allowed values for the lines in .cabal files?
05:44:11 <jkff> memento: You can't use |
05:44:13 <mmorrow> C-Keen: the cabal manual/docs
05:44:13 <jkff> in type
05:44:23 <chrisdone> mmorrow: thanks
05:44:30 <pejo> mmorrow, I don't think they foresaw the reduceron when they wrote that paper though, but it's still interesting.
05:44:34 <jkff> memento: | is for algebraic datatypes, 'data'
05:44:48 <hcube> my problem is that i'm not so experienced with arrows
05:44:58 <memento> jkff: ohh yeah it's data i just typed wronhg
05:44:59 <chrisdone> mmorrow: I have my own which is hpaste's colours. I wanted to specify the <link href=''...> URL but oh well
05:45:18 <memento> jkff: typed wrong here, so in the original its ok
05:45:34 <jkff> memento: Could you provide the precise code, then?
05:45:58 <jkff> memento: Maybe on hpaste.org
05:46:00 <memento> yeah
05:46:06 <mmorrow> pejo: oh for sure, but i think that eliminating dealing with constructor matching made the reduceron a lot simpler
05:47:07 <mmorrow> the constructors become functions that grab the args and go, instead of having to be matched and them provided with their args by the interpreter
05:47:20 <memento> jkff: http://hpaste.org/13435
05:47:25 <mmorrow> i think it's a cool concept
05:49:46 <hcube> is here somebody who has experience with hxt and arrows?
05:50:05 <mmorrow> chrisdone: ohhhh, i see what you meant. umm
05:51:14 <mmorrow> chrisdone: i'm not sure how to do that, but i know cabal ./Setup haddock gives that option, as well as automagic source links in the haddocks. i've been meaning to find where cabal has these superleet args and snake them
05:52:32 <chrisdone> mmorrow: yeah I've been using cabal to document my web site stuff
05:52:37 <Valla> 	http://straseni.kompletne.cz/baf.php?page=straseni&kolo=7&od=62 ROFL ! xD
05:52:58 <pejo> quicksilver,
05:53:12 <jkff> memento: Well, you seem to misunderstand the concept of 'data' :
05:53:30 <mmorrow> chrisdone: heh, i've started to make cabal files for stuff for the sole purpose of only using it for cabal's @elite haddock options
05:53:38 <chrisdone> mmorrow: haha, exactly
05:53:58 <jkff> memento: Conceptually, 'data' is 'The minimal set of values that can be formed with these constructors', and the point is that 1) Any value in Expr can be formed by these constructors,
05:54:03 <jkff> 2) Any value formed by these constructors belongs to Expr
05:54:13 <jkff> 3) For any value in Expr, you know which constructor it has been constructed with
05:54:24 <mmorrow> hmm, we've gotta find how cabal's doing this
05:54:26 <jkff> data is the *disjoint* union type
05:54:34 <jkff> However, you use it like a regular union.
05:54:35 <chrisdone> > > [ (x+1) | x <- Just 2 ]
05:54:38 <chrisdone> > [ (x+1) | x <- Just 2 ]
05:54:49 <jkff> You can't just unite two types like type A = ..., type B = ..., data C = A | B
05:54:57 <chrisdone> lambdabot: ;_;
05:55:18 <mmorrow> chrisdone: these is my current fav args:
05:55:28 <jkff> because then you could do also type X = ..., data Y = A | X, and for a value of type A, you couldn't know which type it has: A, C or Y
05:55:37 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
05:55:38 <memento> jkff: i try it use as a recursive type, so i can make an expression tree with theese type of expressions what belongs to Expr
05:55:45 <jkff> So, you are using Predicate as both a type synonym and as a constructor name.
05:55:52 <chrisdone> mmorrow: harrr
05:55:55 * chrisdone looks at the hoogle on
05:56:06 <mmorrow> it's great. then you convert it et voila!
05:56:17 <memento> ohhh i think i get it now
05:56:23 <chrisdone> mmorrow: then you can hoogle your own project?
05:56:33 <mmorrow> chrisdone: oh yesh.
05:56:37 <chrisdone> mmorrow: I came
05:56:50 <jkff> memento: Probably you might write 'data Expr = ... | Predicate (String,Int) | ...'
05:56:50 <memento> jkff: thanks really
05:56:51 <chrisdone> mmorrow: mine are currently cabal haddock --hyperlink-source --executables --hscolour-css /var/www/chrisdone/hscolour.css
05:56:55 <jkff> memento: np :)
05:57:09 <mmorrow> ooh yeah, the --executables one is golden
05:57:09 * chrisdone adds --hoogle
05:57:19 <memento> thx:)
05:57:22 <mmorrow> dang, i've gotta start using the css option
05:57:45 * mmorrow adds --hscolour-css
05:57:58 * chrisdone also adds --internal; missed that
05:58:51 <chrisdone> hmm. still not generating HsColour files for all my modules ~_~
05:59:12 <chrisdone> generates it for Main.hs but nothing else
05:59:35 <mmorrow> hmm, odd
05:59:45 <mmorrow> maybe the --executables flag has something to do with it
05:59:57 <chrisdone> yeah
06:00:09 <mmorrow> fyi the --hoogle flag creates a pkgname.txt in dist/doc/html/
06:00:12 <mmorrow> then you run
06:00:18 <mmorrow> hoogle --convert=pkgname.txt
06:00:25 <mmorrow> and it'll make a pkgname.hoo
06:00:42 <chrisdone> danke ^_^
06:01:06 <chrisdone> man sitecopy is a pile of shit
06:01:29 <chrisdone> if you interrupt the process, or it encounters some error, it corrupts its data file and fucks everything up
06:01:33 <chrisdone> @_____@
06:01:34 <mmorrow> hoogle --data=pkgname.hoo <hoogle-query-here>
06:01:35 <Valla> 	http://straseni.kompletne.cz/baf.php?page=straseni&kolo=7&od=62 ROFL ! xD
06:01:43 <chrisdone> right
06:01:50 <mmorrow> chrisdone: sounds wonderful
06:01:54 <chrisdone> heh
06:02:33 <mmorrow> i think you can merge hoogle databases too, but i've not done this yet
06:03:03 <mmorrow> well, i guess you can just cat >> the .txt files, then re-convert..
06:03:20 <chrisdone> hmm
06:03:44 <mmorrow> zomg, i'm totally doing that to everything
06:03:45 <chrisdone> GHCi on Acid uses hoogle, so I can hoogle my own project's source ❤
06:03:51 <chrisdone> haha
06:03:52 <mmorrow> nice
06:04:03 <hcube> i've made a more informative message of my problem. please check it: http://hpaste.org/13436
06:05:17 <Raevel> @type (-<)
06:05:26 <mmorrow> hcube: whoa, arrow notation :) that's not used often and i have no idea how to read it :) it may be hard finding someone that does (or maybe not)
06:07:04 <hcube> Raevel: do you mean that i shoul use -< instead of <- ?
06:07:12 <mmorrow> hcube: maybe the ">>>" is messing with the assignment to vcount
06:07:30 <mmorrow> hcube: which line is 117? the first vcount or the second?
06:07:34 <chrisdone> mmorrow: delicious formlets: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=695#a695
06:07:36 <hcube> the second
06:08:19 <chrisdone> mmorrow: (  http://productsforhair.co.uk/register  )
06:08:49 <Raevel> hcube: nope, i have no clue :-)
06:09:21 <mmorrow> chrisdone: sweet, which reminds me. i'll catch up with you later today or tomorrow latest. been meaning to talk about some work.
06:09:40 <Axman6> has anyone worked through the JSON stuff in chapter 6 of RWH?
06:10:35 <chrisdone> mmorrow: hrmm? roger
06:11:53 <cnwdup> Is there a mktemp function in the standard libs?
06:13:02 <cnwdup> Ah, just found a function for files. But I am looking for a function which creates a temp directory.
06:14:20 <jkff> cnwdup: Create a temp file, remember its name as 'tmpname' and then create a directory named tmpname++"_dir"
06:14:29 <jkff> And then remove the temp file
06:15:12 <jkff> (remove it after you're done with the directory)
06:15:53 * maltem is in the process of understanding Yi.Interact :)
06:16:00 <cnwdup> jkff: Ok. Thanks.
06:17:23 <Plouj> hi
06:17:29 <Plouj> I'm curious, does Haskell ever cache return values of pure functions?
06:17:37 <Plouj> I mean, the haskell runtime
06:17:40 <therp> plouj: always
06:17:54 <therp> ah sorry of functions -> no
06:18:11 <therp> Plouj: for zero argument functions (constants) yes
06:18:37 <Plouj> what's stopping it from caching non-zero argumented functions?
06:19:00 <maltem> Plouj: in general caching is only done if you give something a zero-argument name, as in: let cached = f a b c d in (g cached, h cached)
06:19:15 <therp> Plouj: no built-in strategy for caching and cache clearing..
06:19:22 <ksandstr> maltem: does this also apply to common subexpressions?
06:19:30 <therp> plouj: building your own is quite easy, see Memoization in the wiki
06:19:31 <maltem> Plouj: nothing particular is stopping it, but you cannot cache *everything* in a program
06:19:44 <Plouj> ok, makes sense
06:19:56 <maltem> ksandstr: sry I never understood under which circumstances ghc does cse
06:22:34 <maltem> ksandstr: actually, what do you mean by "this"?
06:22:39 <EvilTerran> maltem / ksandstr, generally "never"
06:23:25 <ksandstr> maltem: i was wondering whether I had to explicitly name things in a let/where clause, or if the compiler would do it implictly if I had, for instance, a putStrLn ("what " ++ show x ++ ", how " ++ show x)
06:23:38 <EvilTerran> automatic CSE can cause very large space leaksz
06:23:50 <Axman6> Plouj: there are some interesting ways to do it though. see the MemoTrie library.
06:24:00 <EvilTerran> so it's just not done; you have to do it explicitly with a let/where clause yourself
06:24:17 <maltem> ksandstr: right, you (have to) do this by hand
06:24:19 <ksandstr> can't say i understand the reason, but the more i know i guess
06:24:23 <quicksilver> it's fairly safe to assume "never"
06:24:29 <quicksilver> but actually GHC does have a CSE path
06:24:39 <quicksilver> but it's quite hard to predict when it will kick in - certainly not often.
06:24:46 <Axman6> i quite like using things like fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1)) | n <- [2..]]
06:24:58 <kpreid> in general to memoize stuff you stick it in a data structure...
06:25:01 <EvilTerran> ksandstr, consider "sum [1..10^6] / length [1..10^6]", say
06:25:01 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1)) | n <- [2..]] in fibs
06:25:12 <Axman6> bah, where's lambdabot!
06:25:18 <Axman6> , let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1)) | n <- [2..]] in fibs
06:25:21 <lunabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:25:30 <Axman6> , let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1)) | n <- [2..]] in fibs !! 100000
06:25:36 <EvilTerran> ksandstr, normally, the execution of "sum" will munch through the list, and the GC will free up the items it's passed as it goes along
06:25:36 <lunabot>  Killed.
06:25:41 <Axman6> , let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1)) | n <- [2..]] in fibs !! 10000
06:25:45 <lunabot>  5443837311356528133873426099375038013538918455469596702624771584120858286...
06:25:50 <ksandstr> EvilTerran: ah, i see
06:25:51 <EvilTerran> and then the same will happen for the execution of "length"
06:26:53 <EvilTerran> but, if it's CSEd into "let xs = [1..10^6] in sum xs / length xs", the reference to the head of the list will stick around during the execution of "sum"
06:27:10 <Jedai> I really don't like CSE in GHC, I want my sharing to stay explicit, most of the time if I want to share an expression I'll indicate it in the code
06:27:32 <ksandstr> I find I run out of reasonable names quickly that way
06:27:48 <quicksilver> it only fires in the case "let x = e in ( .... x .... e .... )
06:28:06 <quicksilver> reasoning that if 'e' is already bound to x, it might as well reuse that binding.
06:28:15 <quicksilver> of course, it can still increase sharing.
06:30:50 <muslm1985turkey> Enter text here...hello
06:31:48 <schme> hello
06:31:59 <muslm1985turkey> hello
06:32:03 <muslm1985turkey> how are you
06:32:10 <schme> A bit of a cold.
06:32:19 <schme> How are you?
06:32:26 <muslm1985turkey> thank you
06:32:28 <muslm1985turkey> and you
06:32:42 <chrisdone> bot?
06:32:52 <schme> chrisdone: Stop calling mee a bot :(
06:32:52 <Axman6> i doubt it
06:32:57 <muslm1985turkey> what
06:33:12 <chrisdone> mmkay
06:33:16 <EvilTerran> turing tests for all!
06:33:20 <chrisdone> :P
06:33:36 <schme> muslm1985turkey: Some of the gals and guys here are confused about you not writing perfect english, they think you are a computer program.
06:33:55 <muslm1985turkey> ok
06:33:59 <Axman6> heh
06:34:07 <muslm1985turkey> yes
06:34:11 <Raynes> I am a computer program.
06:34:16 <pizza__> me too.
06:34:21 <chrisdone> Raynes: can we play a game of chance?
06:34:22 <schme> Raynes: Tell us something we didn't know! ;)
06:34:23 <Axman6> , text "me too"
06:34:25 <lunabot>  me too
06:34:28 <muslm1985turkey> 0131 am man
06:34:29 <muslm1985turkey> ok
06:34:34 <Axman6> mwahaha
06:34:42 <muslm1985turkey> hahahah
06:34:56 <pizza__> is anyone in this channel not a computer program?
06:35:01 <schme> I'm not.
06:35:08 <Axman6> pizza__: i'm getting there
06:35:09 <chrisdone> I think schme wrote us all
06:35:23 <chrisdone> but who did he write first?
06:35:24 <muslm1985turkey> ok woman computer
06:35:26 <Axman6> SPJ is working on me
06:35:29 <EvilTerran> i am not a number, i am a free monoid!
06:35:43 <schme> hah.
06:35:55 <muslm1985turkey> ahaahhahah
06:35:59 <chrisdone> fremoid
06:36:04 <Axman6> i'm a free theorem!
06:36:21 <Axman6> , free axman
06:36:21 <muslm1985turkey> ok what is your name
06:36:23 <lunabot>  luna: Not in scope: `axman'
06:36:28 <Axman6> , free id
06:36:30 <lunabot>  luna: Couldn't match expected type `Data.Either.Either
06:36:38 <EvilTerran> ,src 'free
06:36:42 <muslm1985turkey> ok byeeeeeee
06:36:43 <chrisdone> da'i mi lojbo tavla i xu mi remna simsa
06:36:43 <lunabot>  free :: forall a f . (Either a (f (Free f a))) -> Free f a
06:37:10 <Axman6> lojban?
06:37:11 <EvilTerran> ... what the heck is that "free" function meant to do?
06:37:21 <schme> muslm1985turkey: bye.
06:37:22 <chrisdone> @hoogle Free
06:37:24 <Axman6> , free (Left 1)
06:37:25 <lunabot>  luna: No instance for (GHC.Show.Show (Control.Monad.Free.Free f t))
06:37:31 <muslm1985turkey> byee
06:37:35 <EvilTerran> free monad?
06:37:37 <chrisdone> Axman6: that's right
06:37:39 <Axman6> muslm1985turkey: where're you going?
06:37:57 <muslm1985turkey> i go0131ng msn
06:38:01 <EvilTerran> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-free
06:38:01 <muslm1985turkey> come
06:38:03 <PeakerLambda> Title: HackageDB: control-monad-free-0.3, http://tinyurl.com/9py2yq
06:38:03 <chrisdone> Peakerλ: 'sup
06:38:18 <muslm1985turkey> zaza__zaza__1985@hotmail.com
06:38:21 <muslm1985turkey> come
06:38:24 <muslm1985turkey> hahahah
06:38:46 <Axman6> muslm1985turkey: you know you're going to get spammed now right? not by us, but because the logs of this channel are online
06:38:51 <PeakerWork> chrisdone: I believe Peakerλ is happy to serve and protect
06:39:05 <EvilTerran> ?bot
06:39:05 <PeakerLambda> :)
06:39:09 <muslm1985turkey> hahahahhhha
06:39:11 <PeakerWork> ,bot
06:39:13 <lunabot>  luna: Not in scope: `bot'
06:39:17 <EvilTerran> @bot
06:39:18 <lunabot>  :)
06:39:18 <PeakerLambda> :)
06:39:19 <Axman6> > text "me too"
06:39:24 <PeakerLambda>   me too
06:39:43 <Twey> So is \b officially dead and replaced?
06:39:44 <PeakerWork> @type text
06:39:46 <PeakerLambda> String -> Doc
06:39:51 <muslm1985turkey> hahahah
06:39:54 <PeakerWork> What's Doc?
06:39:56 <muslm1985turkey> i k0131sss you
06:39:59 <muslm1985turkey> hahah
06:40:02 <Twey> PeakerWork: Pretty-printing document
06:40:05 <PeakerWork> no ops around?
06:40:08 <schme> Well this got weird.
06:40:08 <EvilTerran> Twey, PeakerLambda's just acting as locum, AFAIK
06:40:12 <Twey> Ah
06:40:21 <Axman6> :info Doc
06:40:22 <PeakerWork> > text . cycle $ "Test"
06:40:38 <Axman6> @info Doc
06:40:38 <PeakerLambda> Doc
06:40:38 <PeakerLambda>   thread killed
06:41:12 <Axman6> oh heh, just realised thoose things could easily be forkIO'd
06:41:20 <Axman6> hence the out of orderness
06:41:28 <PeakerWork> > text . concat . replicate 10 $ "text"
06:41:29 <PeakerLambda>   texttexttexttexttexttexttexttexttexttext
06:41:42 <PeakerWork> > text . concat . replicate 10 $ "text is an archaic medium "
06:41:44 <PeakerLambda>   text is an archaic medium text is an archaic medium text is an archaic medi...
06:42:07 <Axman6> > maxBound^maxBound :: Int
06:42:08 <PeakerLambda>   Add a type signature
06:42:15 <PeakerWork> @type (^)
06:42:16 <PeakerLambda> forall a b. (Num a, Integral b) => a -> b -> a
06:42:17 <muslm1985turkey> byeee room
06:42:19 <Axman6> hmm, i see a flaw in that -_-
06:42:35 <PeakerWork> maxBound^(maxBound::Int) :: Integer
06:42:37 <PeakerWork> > maxBound^(maxBound::Int) :: Integer
06:42:39 <PeakerLambda>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
06:42:39 <PeakerLambda>    arising...
06:42:43 <Axman6> > (maxBound::Int)^maxBound :: Int
06:42:44 <PeakerLambda>   Add a type signature
06:42:56 <PeakerWork> > maxBound^(maxBound::Word8) :: Int
06:42:57 <Axman6> > (maxBound::Int)^(maxBound::Int)
06:42:58 <PeakerLambda>   2147483647
06:42:58 <PeakerLambda>   2147483647
06:43:00 <chrisdone> Twey: why don't you idle in #lojban anymore? what's the matter, lojban not good enough for you anymore? think you're good with your useful languages like japanese?
06:43:44 <PeakerWork> > reverse "?gnitseretni nabjoL si yhW"
06:43:45 <PeakerLambda>   "Why is Lojban interesting?"
06:44:15 <chrisdone> .evitcejbus si gnitseretni si tahW
06:44:36 <cizra> Yeah. A pristine, perfect sample of Lojban, that.
06:44:37 <Axman6> > (toInteger (maxBound::Int))^(maxBound::Int)
06:44:53 <PeakerLambda>   thread killed
06:45:05 <Twey> chrisdone: Tiny autojoin list, restarted irssi :-P
06:45:21 <Axman6> > (toInteger (maxBound::Int))^(maxBound::Int8)
06:45:29 <quicksilver> http://xkcd.com/191/
06:45:31 <PeakerLambda> Title: xkcd - A Webcomic - Lojban
06:45:35 <chrisdone> cizra: it means “how can one know oneself truly without a garden?”
06:45:36 <PeakerLambda>   thread killed
06:45:37 <cizra> Twey: You going to do anything about #haskell.jbo?
06:45:49 <cizra> chrisdone: What do you consider me, a newb Lojbanist?
06:45:50 <Twey> cizra: Are we seriously going to use it?  Heh
06:45:59 <cizra> Why not? There are at least three of us.
06:46:10 <paper_cc> @botsnack
06:46:10 <lunabot>  :)
06:46:15 <chrisdone> discussing actual code in lojban would be like metaprogramming
06:46:21 <Twey> Fair enough
06:46:45 <PeakerWork> ouch! my computer almost stood to a halt
06:48:04 <Axman6> PeakerWork: my bad?
06:48:20 <chrisdone> cizra: shall I re-join yet?
06:48:21 <PeakerWork> How do I put a memory/CPU quota on my lambdabot?
06:48:34 <quicksilver> PeakerWork: use rlimits
06:48:58 <cizra> chrisdone: yes, please
06:49:42 <PeakerWork> I think CPU is not a problem, I need a memory quota
06:51:55 <mreh> @type null
06:53:26 <PeakerWork> ok, nice:
06:53:28 <PeakerWork> > foldr (+) 0 [1..]
06:53:30 <PeakerLambda>   mueval: Prelude.read: no parse
06:53:30 <PeakerLambda>  mueval: out of memory (requested 1048576 by...
06:54:25 <PeakerWork> no more killing my machine
06:54:36 <PeakerWork> > (toInteger (maxBound::Int))^(maxBound::Int8)
06:54:38 <PeakerLambda>   142919965735569591696182228056463217097296492179859624197466650329646666142...
06:55:59 <Axman6> heh, it worked
06:56:33 <PeakerWork> > (toInteger (maxBound::Int))^maxBound::Int
06:56:35 <PeakerLambda>   Couldn't match expected type `GHC.Types.Int'
06:56:36 <Axman6> are there easy completions in Vim?
06:56:50 <PeakerWork> > (toInteger (maxBound::Int) ^ maxBound) :: Int
06:56:52 <PeakerLambda>   Couldn't match expected type `GHC.Types.Int'
06:57:06 <PeakerWork> > toInteger (maxBound::Int) ^ (maxBound::Int) :: Int
06:57:07 <PeakerLambda>   Couldn't match expected type `GHC.Types.Int'
06:57:15 <PeakerWork> > toInteger (maxBound::Int) ^ (maxBound::Int)
06:57:17 <PeakerLambda>   mueval: Prelude.read: no parse
06:57:17 <PeakerLambda>  mueval: out of memory (requested 5242880 by...
07:05:17 <mreh> does haskell translate tail recursion into iteration? Someone told me that was true, but don't you destroy your notion of immutable data because you dont have a call stack anyone to save your values.
07:05:31 <mreh> anymore*
07:06:18 <quicksilver> mreh: haskell doesn't translate anything into anything. It's a language.
07:06:25 <quicksilver> mreh: haskell compilers compile tail recursion efficiently.
07:06:31 <mreh> alright, the compiler
07:06:35 <Twey> mreh: Tail recursion doesn't work quite as you'd expect it to in Haskell, since it's lazy
07:06:42 <quicksilver> you can call it "translating into iteration" if you like.
07:06:50 <quicksilver> but it's not a very accurate description.
07:07:13 <PeakerWork> "tail call optimization" is sometimes said to translate recursion into iteration
07:07:34 <quicksilver> I find that an innaccurate saying that :)
07:07:48 <quicksilver> "Tail call optimisation" is just an efficient way to compile recursion.
07:07:54 <quicksilver> it doesn't translate it into anything.
07:08:42 <Axman6> @hoogle (b -> c) -> Either a b -> Either a c
07:08:42 <PeakerLambda> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
07:08:43 <PeakerLambda> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
07:08:43 <PeakerLambda> Data.Array.Base amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
07:09:02 <Axman6> is that fmap on either?
07:09:33 <Axman6> > fmap (+2) (Left "test")
07:09:34 <PeakerLambda>   Left "test"
07:09:38 <quicksilver> Axman6: yes.
07:09:43 <Axman6> > fmap (+2) (Right 1)
07:09:44 <PeakerLambda>   Right 3
07:10:05 <Axman6> awesome, just trying to convert some RWH code
07:10:19 <Axman6> and i knew there was an easier way to write it -_-
07:10:21 <mreh> how far are you now?
07:10:29 <Axman6> page 161
07:10:49 <Axman6> only got it today
07:10:58 <mercury^> Where is lambdabot?
07:11:07 <mreh> where did you start?
07:11:07 <Axman6> but i started doing the work at chapter 5
07:11:32 <Twey> < Axman6> > fmap (+2) (Left "test")
07:11:34 <Twey> *blink*
07:11:41 <Twey> :t fmap
07:11:42 <idnar> mercury^: 11:18:36 -!- lambdabot [n=lambdabo@animaforge.net] has quit [Read error: 60 (Operation timed out)]
07:11:43 <PeakerLambda> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:11:45 <idnar> (timestamp is UTC+2)
07:11:55 <dmwit> Twey: fmap only acts on Right's.
07:12:00 <Axman6> :t flip fmap (Left "test")
07:12:01 <PeakerLambda> forall a b. (a -> b) -> Either [Char] b
07:12:06 <Twey> Yes, but shouldn't the type prevent that from compiling?
07:12:08 <chrisdone> @src Functor Either
07:12:08 <PeakerLambda> Source not found. You type like i drive.
07:12:11 <chrisdone> @src Either Functor
07:12:12 <PeakerLambda> Source not found. And you call yourself a Rocket Scientist!
07:12:12 <dmwit> Twey: ...no?
07:12:17 <Axman6> Twey: nope
07:12:25 <Twey> dmwit: It's (a -> b) -> f a -> f b
07:12:33 <Twey> Does "test" + 2 make sense?
07:12:34 <Axman6> Twey: fmap :: (b -> c) -> Either a b -> Either a c
07:12:38 <dmwit> Twey: No!
07:12:46 <chrisdone> @k Either String
07:12:46 <dmwit> Twey: fmap acts on Right's!  Not Left's!
07:12:47 <PeakerLambda> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
07:12:54 <chrisdone> :k Either String
07:12:56 <PeakerLambda> * -> *
07:13:01 <Twey> dmwit: That's true
07:13:01 <chrisdone> yay a functor
07:13:08 <Twey> dmwit: But the type still needs to match :-\
07:13:17 <Axman6> Twey: it does match
07:13:17 <dmwit> Twey: Either takes two types.
07:13:19 <Axman6> (b -> c) -> Either a b -> Either a c
07:13:27 <dmwit> Twey: One of them is String in that thing; the other is a Num.
07:13:34 <mercury^> What is the shortest way to write \n -> n-1?
07:13:34 <dmwit> Twey: The Num matches the (+2).
07:13:36 <chrisdone> :t Left ""
07:13:37 <PeakerLambda> forall b. Either [Char] b
07:13:38 <Twey> Ahh, I see.
07:13:47 <Axman6> mercury^: subtract 1
07:13:49 <Twey> Yes, that makes sense.  Thanks.
07:13:55 <Axman6> t subtract
07:13:57 <Axman6> :t subtract
07:13:58 <PeakerLambda> forall a. (Num a) => a -> a -> a
07:14:06 <Axman6> @src subtract
07:14:07 <PeakerLambda> subtract x y = y - x
07:14:08 <dmwit> mercury^: pred
07:14:15 <Axman6> ah, good call
07:14:28 <Axman6> @pl \n -> n-1
07:14:29 <PeakerLambda> subtract 1
07:14:34 <dmwit> mercury^: ...assuming your Num is also an Enum. ;-)
07:14:39 <Axman6> at least lambdabot agrees with me
07:14:47 <Twey> Heh
07:14:52 <dmwit> Yeah, pred is not exactly the same as subtract 1.
07:15:02 <Twey> @src pred
07:15:03 <PeakerLambda> Source not found. I am sorry.
07:15:05 <Axman6> :t pred
07:15:06 <PeakerLambda> forall a. (Enum a) => a -> a
07:15:11 <Twey> :t subtract
07:15:12 <PeakerLambda> forall a. (Num a) => a -> a -> a
07:15:12 <mercury^> > pred 0
07:15:14 <PeakerLambda>   -1
07:15:18 <Twey> Hmm
07:15:27 <mercury^> Hmm, how is it not the same dmwit?
07:15:36 <Twey> Does (Num a) imply (Enum a)?
07:15:44 <quicksilver> in theory, no.
07:15:51 <quicksilver> All the prelude instances of Num instance Enum though.
07:16:04 <quicksilver> > 1 :+ 1
07:16:05 <dmwit> mercury^: subtract 1 will work on any Num; pred will work on any Enum.
07:16:05 <PeakerLambda>   1.0 :+ 1.0
07:16:11 <quicksilver> > [1 :+ 1,..]
07:16:12 <PeakerLambda>   <no location info>: parse error on input `..'
07:16:14 <Olathe> Is Complex an Enum ?
07:16:15 <dmwit> mercury^: But there's no guarantees that a Num is an Enum, or vice versa.
07:16:17 <quicksilver> > [1 :+ 1..]
07:16:18 <PeakerLambda>   No instance for (GHC.Enum.Enum (Data.Complex.Complex t))
07:16:18 <PeakerLambda>    arising from th...
07:16:24 <dmwit> Olathe: I hope not.
07:16:24 <quicksilver> ah, indeed not.
07:16:35 <mercury^> dmwit: ah, k
07:16:39 <idnar> @type (:+)
07:16:40 <PeakerLambda> forall a. (RealFloat a) => a -> a -> Complex a
07:16:42 <mercury^> Well, in my case it's Int anyway.
07:16:46 <idnar> oh, erk
07:16:47 <Olathe> I wish Enum used Integer rather than Int.
07:16:52 <dmwit> mercury^: Right, they're exactly the same, then.
07:16:57 <dmwit> Olathe: Yeah, me too.
07:19:13 <mpwd> @src all
07:19:14 <PeakerLambda> all p =  and . map p
07:19:28 <Axman6> "< moquist> I dropped in just to say "thanks" to the devs; you've never heard from me before because I'm a  contented user who hasn't had any problems. Kudos!"
07:20:25 <fasta> Is there anyone from France here?
07:20:35 <luite> I have a ForeignPtr (Ptr Int), allocated with mallocForeignPtrArray. Each of the Ptr Int elements it points to need to be freed before the whole thing is discarded. the problem is that addForeignPtrFinalizer needs a FunPtr argument. Is it possible to create a FunPtr from a regular haskell function without a foreign import?
07:21:02 <Axman6> :t (&&).?f
07:21:03 <PeakerLambda> Not in scope: `.?'
07:21:07 <Axman6> :t (&&). ?f
07:21:07 <PeakerLambda> forall a. (?f::a -> Bool) => a -> Bool -> Bool
07:21:25 <Olathe> @type runPtr
07:21:26 <PeakerLambda> Not in scope: `runPtr'
07:21:42 <Olathe> What happened to the bot that lambadas ?
07:21:56 <cizra> LambadaBot!
07:22:01 <PeakerWork> Olathe: no idea, its gone, so I put PeakerLambda for the mean time
07:22:18 <Axman6> Cale: where'd lambdabot go? :(
07:22:22 <Olathe> @hoogle runPtr
07:22:23 <PeakerLambda> No results found
07:22:58 <quicksilver> luite: you can't attach haskell finalisers to foreign ptrs
07:23:18 <quicksilver> luite: the reason for this is that a haskell finaliser might cause a GC and we can't run a GC from inside teh GC.
07:23:21 <quicksilver> doh.
07:23:44 <quicksilver> YO DAWG I HEARD YOU LIKE GARBAGE SO I PUT A FINALIZER IN YOUR FINALIZER SO YOU CAN COLLECT THE GARBAGE WHILE YOU COLLECT THE GARBAGE
07:24:33 <quicksilver> luite: I suggest you allocate a single block of memory and then just return a bunch of pointers from inside it?
07:24:37 <mapreduce> Somebody's been in #emacs too long.
07:24:38 <quicksilver> then it's only one deallocation - simpler.
07:24:55 <Olathe> "GHC notes: mallocForeignPtr has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the ForeignPtr does not require a finalizer to free the memory. Use of mallocForeignPtr and associated functions is strongly recommended in preference to newForeignPtr with a finalizer."
07:26:04 <luite> quicksilver: hm, would that require some unsafeCoercing, I need some parts to be treated as an int**, some as an int*
07:26:56 <quicksilver> luite: No.
07:27:02 <quicksilver> luite: a Ptr is a Ptr.
07:27:08 <quicksilver> luite: what it points to is up to ou.
07:27:11 <quicksilver> memory's just memory.
07:27:26 <Heffalump> quicksilver: huh? I thought Ptr was parametrised
07:27:49 <quicksilver> it is, but you can cast it
07:27:56 <quicksilver> castPtr, castForeignPtr, and friends.
07:28:10 <Olathe> castFriendPtr
07:28:17 <quicksilver> this is a perfectly sane thing to do inside an FFI binding.
07:28:29 <PeakerWork> what's the difference between ForeignPtr and Ptr?
07:28:42 <quicksilver> ForeignPtr belongs to haskell
07:28:45 <quicksilver> Ptr belongs to C
07:29:08 <quicksilver> well, Ptr doesn't belong to anyone, in a sense.
07:29:10 <idnar> that seems backwards, somehow
07:29:17 <luite> hm, I still don't really like it, I'd have to use the size of (Ptr a) and of Int to find the size of the memory area...
07:29:27 <mreh> does anyone know of a nice interactive tool to do profiling with?
07:29:33 <PeakerWork> ForeignPtr points to something that the GC is tracking?
07:29:47 <quicksilver> luite: why don't you like that?
07:29:55 <quicksilver> luite: that's exactly what you obviously have to do
07:30:10 <quicksilver> how could you hope to work out how much memory to allocate for Ints without knowing the size of an Int?
07:30:14 <chrisdone> PeakerWork: can you make PeakerLambda join #haskell.jbo? o:-)
07:30:29 <quicksilver> and similarly, how could you hope to work out how much memory to allocate for a Ptr Int if you don't know the size of a Ptr Int
07:30:36 <quicksilver> that's why we have sizeOf...
07:31:28 <luite> quicksilver: in the case of a 'regular' mallocArray, you only need the number of elements, I guess the Storable instance provides the size of each element
07:31:40 <chrisdone> PeakerWork: yaaay. thanks
07:31:43 <PeakerWork> np
07:32:09 <quicksilver> luite: correct.
07:32:25 <quicksilver> luite: so this is no different, it's just you get to use the sizeOf method yourself
07:32:32 <quicksilver> instead of letting mallocArray do it
07:32:35 <quicksilver> is that a big deal?
07:33:42 <luite> it seems to be a bit messier to me, but not a huge problem or something
07:35:32 <quicksilver> alternatively use mallocForeignPtr for everything, as olathe suggested
07:35:39 <quicksilver> and let the GC take care of it
07:35:42 <Olathe> How do I see the generated assembly on Windows ?
07:35:49 <Olathe> -keep-tmp-files fails for that.
07:36:37 <luite> quicksilver: the problem is that all those other pointers are only pointed to by another ForeignPtr
07:36:58 <Olathe> Ahh, -ddump-asm works.
07:37:50 <luite> quicksilver: so I assume that the RTS cannot track those pointers, is that correct?
07:38:16 <quicksilver> luite: ah well, then you'd need to keep a reference to them too
07:38:27 <quicksilver> luite: all in all, the one large block of memory is sounding better and better
07:38:45 <Axman6> :t fmap putStrLn
07:38:46 <PeakerLambda> forall (f :: * -> *). (Functor f) => f String -> f (IO ())
07:38:52 <luite> yeah I could store a list of those pointers in my ADT, but I think you're right, I'll just go with one block of memory
07:39:04 <Olathe> Hmm..-fvia-C kills that.
07:39:20 <Axman6> Olathe: you might want to install dons' ghc-core, it shows the Core as well as the assembly
07:42:42 <mmorrow> @bot
07:42:42 <lunabot>  :)
07:42:42 <PeakerLambda> :)
07:43:41 <Olathe> How do I install Cabal on Windows ?
07:44:04 <boegel> Olathe: who uses Windows anyway? ;-)
07:44:16 <chrisdone> Simon Peyton Jones ;_;
07:44:52 <boegel> chrisdone: so? :P
07:45:17 <Olathe> If you send me an old Mac with OS X, I'll use that :)
07:45:28 <ehird> Olathe: will a g3 do?
07:45:28 <ehird> :P
07:45:37 <boegel> chrisdone: smart people just manage to get stuff done with the tools they have ready-to-use, and usually don't (want to) realize there are better tools out there for the job
07:45:39 <ehird> ... a broken g3?
07:45:45 <mercury^> Can someone confirm that with ghc 6.10.1, Data.IntMap.findMin returns the value at the minimal key, instead of the minimal key, as the documentation says?
07:45:50 <Olathe> Heheh
07:46:30 <Olathe> mercury^: Do you have test code for ghci ?
07:46:39 <Olathe> I've never used IntMap before.
07:46:58 <mercury^> Olathe: findMin $ fromList [(2,1),(1,2)]
07:47:09 <Olathe> 2
07:47:10 <luite> mercury^: the return type is a, not Key
07:47:22 <Olathe> That's what it gives.
07:47:34 <mmorrow> preflex: tell andyjgill an s/"/'/ for a haddock syn error in hackage KURE http://hpaste.org/13440
07:47:35 <preflex>  Consider it noted.
07:47:35 <SamB_XP_> :t Data.IntMap.findMin
07:47:36 <PeakerLambda> forall a. IM.IntMap a -> a
07:47:49 <SamB_XP_> mercury^: I can confirm that
07:48:04 <mercury^> luite: but it says "The minimal key of the map." and that makes the most sense also.
07:48:33 <SamB_XP_> the type makes it obvious ...
07:49:09 <luite> mercury^: yep, seems it's wrong. I've used minWithWithKey to get the minimum key, but a findMinKey or something would be better
07:49:16 <luite> minViewWithKey
08:01:35 <mmorrow> , [$pl| \a b c d e -> g (f a b c d e) |]
08:01:40 <lunabot>  ((((g .) .) .) .) . f
08:01:57 <mmorrow> , [$ty| [$pl| \a b c d e -> g (f a b c d e) \|] |]
08:02:05 <lunabot>  Killed.
08:02:13 <mmorrow> , [$ty| [$pl| \a b -> g (f a b) \|] |]
08:02:19 <lunabot>  Doc
08:02:26 <vixey> , [$ty| [$pl| \a b -> g (f a b) |] |]
08:02:28 <mmorrow>  @pl is super resource intensive
08:02:28 <lunabot>  luna: parse error on input `|]'
08:02:31 <vixey> veilh
08:02:32 <mmorrow> , [$tyQ| [$pl| \a b -> g (f a b) \|] |]
08:02:36 <vixey> oh I see
08:02:38 <lunabot>  Killed.
08:02:40 <vixey> , [$ty| [$pl| \\a b -> g (f a b) \|] |]
08:02:40 <mmorrow> you have to escape inners :(
08:02:46 <lunabot>  Doc
08:02:48 <mmorrow> , [$tyQ| [$pl| \a b -> g (f a b) \|] |]
08:02:51 <vixey> huh.........
08:02:54 <lunabot>  ConT Doc
08:03:04 <mmorrow> i've gotta up the time rlimit
08:03:12 <vixey> , let p = [$pl| \a b -> g (f a b) |] in [$tyQ| p |]
08:03:18 <lunabot>  ConT Expr
08:03:22 <vixey> , let p = [$pl| \a b -> g (f a b) |] in [$ty| p |]
08:03:27 <mmorrow> , [$foo| [$bar| [d| ... \\\|]  \|]  |]
08:03:29 <lunabot>  Expr
08:03:31 <lunabot>  luna: Not in scope: `foo'
08:03:51 <mmorrow> [$tyQ| ... |] :: Type
08:03:56 <mmorrow> [$ty| ... |] :: Doc
08:04:18 <mmorrow> , [$tyQ| [$tyQ| 42 \|] |]
08:04:24 <lunabot>  ConT Type
08:04:28 <mmorrow> , [$ty| [$tyQ| 42 \|] |]
08:04:35 <lunabot>  Type
08:04:38 <mmorrow> , [$ty| [$ty| 42 \|] |]
08:04:45 <lunabot>  Doc
08:04:45 <mmorrow> , [$tyQ| [$ty| 42 \|] |]
08:04:51 <lunabot>  ConT Doc
08:04:56 <mmorrow> heh
08:05:12 <mmorrow> hmm
08:06:15 <mmorrow> vixey: ah, $ty/$tyQ doesn't grap idents from the enclosing scope (it could, but would just have to be implem)
08:06:16 <PeakerWork> conal: you recently converted to Ubuntu, do you have a connection with SPJ to convert him too? :-)
08:06:55 <quicksilver> it's not an absolute barrier, but SPJ does work for microsoft...
08:07:25 <SamB_XP_> but I don't think powerpoint runs on ubuntu
08:07:32 <mmorrow> all he needs is a blue screen of death screensaver, and noone'll be the wiser ;)
08:08:22 <idnar> SamB_XP_: S5 does
08:10:17 <Axman6> from what i've heard of the MS research guys, most of them use unix machines
08:17:14 <defun> Hi, I'm reading programming in haskell. What does the symbol that looks like a triangle without a or base mean? (i.e. it looks like this:    /\   )
08:17:49 <pejo> defun, capital lambda, for type applications?
08:18:08 <mightybyte> defun, or is it logical and or ^?
08:19:05 <defun> nm I found it. silly me.
08:19:10 <hcube> is heer anyone who is deeply familiar with arrow notation (syntax) ? i've a question for him.
08:19:13 <hcube> *here
08:24:47 <PeakerWork> hcube: the proc do syntax?
08:24:48 <mpwd_> @src and
08:24:49 <PeakerLambda> and   =  foldr (&&) True
08:26:22 <hcube> PeakerWork: yes
08:26:52 <hcube> here is th problem: http://hpaste.org/13436
08:27:11 <mpwd_> @src
08:27:12 <PeakerLambda> src <id>. Display the implementation of a standard function
08:27:17 <PeakerWork> hcube: you want a recursive arrow?
08:27:25 <mpwd_> @src (&&)
08:27:25 <PeakerLambda> True  && x = x
08:27:26 <PeakerWork> hcube: (ArrowLoop)?
08:27:26 <PeakerLambda> False && _ = False
08:27:27 <paper_cc> @botsnack
08:27:27 <lunabot>  :)
08:27:27 <PeakerLambda> :)
08:27:29 <hcube> no
08:27:52 <hcube> line 117 is: buf <- getVertexBuffer vcount -< p
08:28:23 <hcube> getVertexBuffer is a different arrow
08:28:29 <PeakerWork> hcube: I am not sure, weird. Is there no @undo for arrows?
08:29:21 <hcube> vcount should be an Int
08:29:35 <hcube> what is @undo ?
08:30:02 <vixey> isn't -< a function?
08:30:09 <idnar> @undo  do x <- y; f x
08:30:09 <PeakerLambda> y >>= \ x -> f x
08:30:27 <idnar> hcube: ^^^ it desugars do notation into lambda / bind style
08:30:45 <idnar> @. pl undo do x <- y; f x
08:30:46 <PeakerLambda> f =<< y
08:31:08 <hcube> ah, ok. why do we need this ?
08:31:34 <vixey> @go arrow syntax
08:31:34 <PeakerLambda> Maybe you meant: google googleit . ? @ bf ft ghc id pl rc v wn yow
08:31:40 <vixey> @google haskell arrow syntax
08:31:43 <PeakerLambda> http://www.haskell.org/arrows/syntax.html
08:31:43 <PeakerLambda> Title: Arrow syntax
08:32:15 <vixey> it showes the desugaring there
08:32:45 <Axman6> @instances Arrow
08:32:46 <PeakerLambda> (->), Kleisli m
08:33:40 <hcube> i can send the full source code if it helps. it requires hopengl and HXT
08:34:09 <EvilTerran> i think that might need ArrowApply
08:34:26 <EvilTerran> what's the type of getVertexBuffer?
08:36:45 <hcube> here is teh full file: http://hpaste.org/13442
08:36:51 <hcube> *the whole
08:37:07 <vixey> 	u <- getAttrValue "u" >>> arr read -< p
08:37:26 <vixey> maybe you should define a function
08:37:34 <vixey>  u <- labelled "u" -< p
08:37:36 <vixey> or something
08:37:41 <vixey> which does all this >> arr read stuff
08:38:28 <hcube> ok :)
08:39:03 <Raevel> i'm looking at http://hackage.haskell.org/packages/archive/json/0.3.6/doc/html/src/Text-JSON-Types.html , what does the data declaration data JSValue = JSString JSString mean?
08:39:06 <PeakerLambda> Title: Haskell Code by HsColour, http://tinyurl.com/76y8bv
08:39:31 <hcube> it seems that the end of file is clamped
08:39:33 <EvilTerran> Raevel, it means there's one constructor for JSValue, "JSString :: JSString -> JSValue"
08:40:24 <EvilTerran> it's kinda confusing giving a constructor of one type the same name as a different type, but that's what that'd mean
08:40:44 <Raevel> oh, i didn't even see the newtype declaration
08:40:45 <Raevel> thanks!
08:41:08 <EvilTerran> i see there's other constructors for JSValue too in there
08:42:15 <EvilTerran> basically, the format of data decls is "data <your new type name> <type parameter> <type param> ... = <constructor name> <contructor parameter's type> <c'tor param's type> ... | <c'tor name> ... | ..."
08:43:09 <EvilTerran> so, in "data JSValue = ... | JSString JSString | ...", the first appearance of "JSString" is the constructor's name (a value-level name) and the second is the type of its parameter (a type-level name)
08:45:14 <quicksilver> potentially confusing but also quite common
08:45:18 <Raevel> EvilTerran: ah yes i knew that, it just threw me off when i thought i saw recursion :-)
08:45:33 <quicksilver> giving a constructor the same name as its own type is also potentially confusing and very common
08:45:52 <wchogg> quicksilver:  I think it's okay for a newtype though.
08:46:19 <augustss> what's confusing about it?
08:47:00 <quicksilver> using the same name for two different things
08:47:03 <quicksilver> can confuse people.
08:47:07 <quicksilver> punning is not zero-cost
08:47:19 <quicksilver> even when it's not ambiguous, which this isn't.
08:48:11 <wchogg> I know that it _did_ confuse me when I was first teaching myself Haskell.  I started to get the distinction between a type & a constructor mixed up.
08:48:14 * EvilTerran frequently puns a newtype constructor with its type, but i wouldn't give a c'tor the same name as a *different* type
08:48:25 <augustss> Once you're beyond newbee I'd say it's helpful.  You know what type the constructor belongs to.
08:48:46 <EvilTerran> it'd be "data JSValue = ... | JSStringV JSString | ..." or something
08:48:59 <augustss> EvilTerran: yes, that's bad
08:49:32 <EvilTerran> naming a c'tor after the type of its parameter doesn't scale; what happens when you've got another c'tor with the same type of parameter?
08:49:39 <Raevel> oh also, what does JSBool !Bool mean?
08:49:47 <vixey> same as JSBool Bool
08:49:48 <EvilTerran> strictness!
08:49:55 <EvilTerran> but basically the same as JSBool Bool
08:50:02 <Raevel> how is it strict?
08:50:21 <EvilTerran> "JSBool undefined" will be indistinguishable from undefined
08:50:51 <Raevel> oh, i see
08:52:33 <EvilTerran> the report defines it as meaning that any use of the JSBool constructor is replaced by (JSBool $!)
08:52:36 <EvilTerran> ?src ($!)
08:52:37 <PeakerLambda> f $! x = x `seq` f x
08:52:54 <EvilTerran> , Just undefined
08:52:56 <lunabot>  luna: Prelude.undefined
08:52:59 <EvilTerran> hmph
08:53:07 <SamB_XP> EvilTerran: wouldn't that result in a long chain of $! ?
08:53:23 <SamB_XP> an ... infinite chain ?
08:53:29 <EvilTerran> SamB_XP, well, it only happens once, much like the insertion of fromInteger around integer constants
08:53:41 <augustss> > isJust (Just undefined)
08:53:43 <PeakerLambda>   True
08:53:57 <EvilTerran> i'm going by the "translation" bit in http://haskell.org/onlinereport/decls.html#strictness-flags
08:53:58 <PeakerLambda> Title: The Haskell 98 Report: Declarations
08:54:16 <EvilTerran> (only focussing on a single case instead of generalising)
08:57:59 <vixey> say I were to download a newer version of GHC, compile it and if it builds successfully, install it
08:58:03 <vixey> will that break cabal?
08:58:25 <SamB_XP> what do you mean by break ?
08:58:43 <vixey> this is a pretty well known term at least around here :p
08:59:04 <hansfbaier> dcoutts_: Does gtk2hs support GtkBuilder yet?
08:59:09 <vixey> what happened before was that it didnt't recognize anything I installed with cabal and it resisted being fixed
08:59:21 <SamB_XP> I think it should basically work, but you might have to be explicit about which version of GHC you want to deal with at any given time
08:59:48 <vixey> but what if I want to upgrade GHC to this new version?
08:59:55 <mpwd__> Silly question, can I put returns in a type declaration?
08:59:59 <vixey> I don't want to have two versions around
09:00:11 <SamB_XP> I guess it would probably work fine then
09:00:22 <SamB_XP> just make sure to clean up the droppings ;-P
09:00:52 <vixey> Lemmih, can LHC bootstrap?
09:01:01 <mpwd__> vixey: gcc has a helper program these days that lets you pick which flavor of gcc you are using
09:01:01 <SamB_XP> vixey: heh
09:01:05 <Lemmih> vixey: no.
09:01:06 <SamB_XP> why would it be able to do that?
09:01:17 <vixey> Lemmih, why not?
09:01:44 <EvilTerran> mpwd__, yes, you can break type decls across multiple lines
09:01:59 <mpwd__> EvilTerran: Thanks.
09:02:00 <SamB_XP> vixey: can't build all the dependencies, for startesr
09:02:04 <EvilTerran> mpwd__, just make sure you indent each line more than the first
09:02:12 <mpwd__> Oh, perfect
09:02:19 <mpwd__> I do that instinctively anyway
09:02:27 <vixey> oh so bootstrapping LHC isn't just a days work
09:02:37 <mpwd__> vixey: In fact, I seem to recall that make files can even force which gcc you use to compile, since not all gcc versions are backwards compatible
09:02:42 <vixey> (what's the point in LHC?)
09:02:52 <mpwd__> Or maybe it's automake+configure or whatever
09:02:53 <vixey> mpwd__, thanks
09:02:56 <SamB_XP> it's cabalized JHC, afaict
09:03:06 <SamB_XP> I don't see what the point of that is really
09:03:14 <SamB_XP> since JHC is still so incomplete ...
09:03:14 <Lemmih> SamB_XP: It's more than that.
09:03:22 <SamB_XP> Lemmih: is it ?
09:03:30 <blando> is there a haskelly way to determine the endianness of the machine you're on?
09:03:33 <vixey> it might be on cabal but that doesn't mean it builds by cabal :p
09:03:40 <SamB_XP> why hasn't JHC incorporated the other changes then ?
09:03:49 <Lemmih> John and I disagreed on serveral issues, cabal being one of them.
09:03:56 <SamB_XP> what were the others ?
09:03:58 <Lemmih> LHC is actively developed.
09:04:07 <vixey> Lemmih, would you like it to bootstrap
09:04:42 <vixey> does YHC bootstrap actually?
09:04:42 <Lemmih> vixey: LHC can't even compile non-trivial programs.
09:04:56 <vixey> wtf
09:05:06 <jonaskoelker> hello all
09:05:18 <vixey> it's already like a billion lines of code in 200 files and uses stuff like drift and it doesn't *do* anything?
09:05:49 <Axman6> vixey: but when it does do stuff, it does it *really* fast!
09:06:03 <Heffalump> it does something, it compiles trivial programs
09:06:06 <Lemmih> SamB_XP: There was a lot of code which I felt was cruft but John didn't.
09:06:07 <vixey> nothing works except GHC
09:06:10 <vixey> GHC doesn't work
09:06:11 <vixey> :(
09:06:30 <jonaskoelker> type how-to question: I have a function f which needs to call a helper function g on a list of type either [a] or [(a, b)].  How do I do that without typing everything in g twice?
09:06:31 <Lemmih> SamB_XP: Also, John didn't give out commit access.
09:06:48 <SamB_XP> Lemmih: so ...?
09:06:58 <Heffalump> jonaskoelker: what does the helper function do?
09:07:00 <vixey> jonaskoelker: first have you done it with typing g twice? then erasing that can be done
09:07:01 <SamB_XP> oh, john didn't feel the code was cruft ?
09:07:16 <SamB_XP> (which code ?)
09:07:52 <vixey> Lemmih, going somewhere with LHC or it is just for fun?
09:07:53 <jonaskoelker> Heffalump: pattern matches on [(Keep or Drop) and (First or Last)] and runs the right take/drop on its argument list
09:07:56 <Lemmih> SamB_XP: Right. StringTable/Atom, Doc, UTF8.
09:08:20 <SamB_XP> what was wrong with UTF8 ?
09:08:24 <Lemmih> vixey: LHC is going somewhere fun, I hope (:
09:08:35 <SamB_XP> Doc, though, definately had issues
09:08:49 <SamB_XP> the word-wrapping stuff did not integrate well
09:09:02 <Lemmih> SamB_XP: There was a bunch of distinct UTF8 implementations in the code.
09:09:10 <Heffalump> jonaskoelker: I don't really follow, but I have to disappear. I suggest you hpaste the code and let someone take a look.
09:09:30 <EvilTerran> ?hpaste
09:09:30 <PeakerLambda> Haskell pastebin: http://hpaste.org/new
09:11:04 <SamB> Lemmih: so ... what about the typechecker ?
09:11:13 <pejo> vixey, I'm sure that the GHC folks would love cleanups of GHC if someone contributed the patches.
09:11:18 <SamB> and the Hs->E conversion code ...
09:11:28 <Lemmih> SamB: What about it?
09:11:42 <SamB> and did you fix that typeclass bug ?
09:12:19 <vixey> pejo, way too much work sorry, I wish I had the patience
09:12:27 <jonaskoelker> vixey: care to take a look at http://hpaste.org/13443 ?
09:12:37 <Lemmih> SamB: The only bug I've fixed was in the E->E simplifier.
09:13:04 <vixey> jonaskoelker, why don't you write  evalfilter Drop pq x y = evalfilter Keep (invert pq) x y
09:13:12 <vixey> jonaskoelker, with invert being the obvious function
09:13:14 <pejo> vixey, what is it you want to modify in your compiler? Chances are that you can ignore most parts of GHC.
09:13:24 <ozy`> Lemmih: LHC is a hilarious but unfortunate acronym
09:13:40 <ozy`> makes it just a bit difficult to google ;)
09:13:44 <jonaskoelker> vixey: dunno...
09:13:49 <EvilTerran> ?go lhc compiler
09:13:50 <PeakerLambda> Maybe you meant: google googleit . ? @ bf ft ghc id pl rc v wn yow
09:13:56 <EvilTerran> ?google lhc compiler
09:13:56 <jonaskoelker> vixey: /me is haskell noob :)
09:13:59 <PeakerLambda> http://archhaskell.wordpress.com/2008/11/24/lhc-lemmihs-haskell-compiler/
09:13:59 <PeakerLambda> Title: LHC: Lemmih’s Haskell Compiler « Arch Linux and Haskell
09:14:05 <vixey> pejo, I've tried to hack on different (specific) parts of GHC  several times and it's always been too hard
09:14:05 <EvilTerran> ?google lhc haskell
09:14:09 <SamB> Cale: !!!!
09:14:09 <PeakerLambda> http://lhc.seize.it/
09:14:10 <PeakerLambda> Title: Wiki - Front Page
09:14:17 <SamB> what have you allowed into lambdabot?
09:14:20 <vixey> jonaskoelker, I think it would be better though
09:14:22 <EvilTerran> that wasn't so hard :)
09:14:24 <SamB> why does @go not mean @google anymore ?
09:14:45 <jonaskoelker> vixey: fair enough.  Care to focus on my infinite type problem? :)
09:14:53 <Gilly> Lemmih: about LHC, would it be suitable to use in embedded systems like Neo Freerunner?
09:15:02 <vixey> jonaskoelker, what is it
09:15:16 <cizra> Gilly: LHC? Large Hadron Collider inside a Neo?
09:15:21 <francis> lmao
09:15:27 <cizra> oh geez
09:15:33 <jonaskoelker> vixey: my two calls to evalfirstlast have different types.  "cannot construct the infinite type a = (a, b)"
09:15:35 <Axman6> cizra: the LHC runs on haskell
09:15:36 <cizra> now I see it
09:15:47 <Axman6> it's the only language that can cope with creating new universes
09:15:49 <Gilly> cizra: :D
09:16:01 <Lemmih> Gilly: Yes, it should at least be better suited than GHC.
09:16:10 <wchogg> Axman6 : No, I tried to get some of the simulation software for my team to be in Haskell years ago...but only C++ was acceptable.
09:16:17 <SamB> oh, is THAT why the acronym is hilarious
09:16:21 <vixey> :t take
09:16:22 <vixey> :t drop
09:16:23 <PeakerLambda> forall a. Int -> [a] -> [a]
09:16:23 <PeakerLambda> forall a. Int -> [a] -> [a]
09:16:29 <Axman6> wchogg: you work on the LHC?
09:16:35 <vixey> jonaskoelker, the code looks fine
09:16:35 <ozy`> SamB: precisely, dear Watson!
09:16:37 <Gilly> Lemmih: another thing i'm thinking about - does it support the existing packages (like gtk bindings or stuff like that) well?
09:16:42 <wchogg> Axman6 : used to.  I'm an expat from physics now.
09:16:49 <Axman6> wchogg: oh very nice :)
09:16:54 <Axman6> what do you do now?
09:17:19 <jonaskoelker> vixey: I mean where evalfilter calls evalfirstlast (where predicate is one of [first,last] or [low,high])
09:17:33 <ozy`> Axman6: he's forging ties with CS people so as to be on the same side as our new robotic overlords when the revolution comes
09:17:45 <ozy`> isn't that right wchogg? ;)
09:17:50 <EvilTerran> as long as the cephalopods don't get us first
09:17:55 <jonaskoelker> vixey: once I call evalfirstlast with [a], the other time with [(a, a1)]
09:17:55 <Lemmih> Gilly: No, unfortunately it doesn't yet. It can only compile a few simple packages other than 'base'.
09:17:56 <wchogg> ozy` : You realize you've sealed your fate with your free speech.
09:18:05 <chrisdone> I, for one, welcome our well-typed overlords
09:18:15 <ozy`> I regret nothing!
09:18:19 * ozy` jumps out the window
09:18:24 <vixey> jonaskoelker, and what do you want to call it with?
09:18:25 <EvilTerran> well-typed overlords do not rule wrong!
09:18:29 <Gilly> Lemmih: does it support the foreign function interface yet?
09:18:31 <vixey> jonaskoelker, [a], [(a, a1)], or both?
09:18:34 <chrisdone> is it defenestration if you jump out yourself?
09:18:39 <jonaskoelker> vixey: both
09:18:50 <wchogg> Axman6 : I've been a programmer for a few years now, but am hoping to get back into a phd program in CS this next fall.
09:18:57 <Lemmih> Gilly: Yes, I believe so.
09:19:00 <jonaskoelker> vixey: depending on whether predicate is first/last or low/high
09:19:05 <Axman6> wchogg: sounds good, which uni?
09:19:18 <vixey> jonaskoelker, depending how?
09:19:23 <wchogg> Axman6 : PSU
09:19:27 <jonaskoelker> vixey: like the code says :)
09:19:32 <vixey> jonaskoelker, like  First Low  ~~> [a], First High ~~> [(a, a1)]
09:19:36 <Axman6> power supply university?
09:19:39 <vixey> jonaskoelker, well feel free to tell me if you want
09:19:42 <Gilly> Lemmih: mm, well, could be possible to do the gtk bindings then :) i haven't really got out to test it yet since for some wicked reason the ghc/cabal are outdated on gentoo
09:19:48 <wchogg> Axman6 : Portland State :p
09:19:53 <Axman6> heh
09:19:58 <Gilly> Lemmih: but it produces C code or what?
09:20:02 <Axman6> i'm at ANU atm, just finished my first year
09:20:02 <jonaskoelker> vixey: (First or Last) ~~> [a];; (Low or High) ~~> [(a, a1)]
09:20:18 <Elly> Gilly: are you using the haskell overlay?
09:20:24 <Gilly> Elly: no
09:20:29 <Lemmih> Gilly: Right, as it is now we only output C.
09:20:33 <Gilly> Elly: there is such a thing? :)
09:20:51 <PeakerWork> the Zip class seems like a special case of the Applicative class... Why not use Applicative?
09:21:01 <PeakerWork> (In conal's blog)
09:21:02 <Elly> Gilly: yep
09:21:05 <Gilly> Lemmih: ok, cool.. so I could use the cross compiler they ship with openmoko
09:21:06 <Elly> Gilly: join #gentoo-haskell :)
09:21:09 <Lemmih> Gilly: LHC should eventually be able to compile gtk2hs but it's still far away.
09:21:09 <ozy`> Lemmih: dude, LLVM is totally, like, the future
09:21:21 <vixey> jonaskoelker, oh just split it into two  functions in this case
09:21:27 <Axman6> ozy`: fo shizzle
09:21:36 <SamB> Lemmih: last I checked, JHC supported everything but dynamically generating C-callable stubs for Haskell functions ...
09:21:45 <wchogg> ozy` : I didn't believe you until I saw the superflous 'like' in that sentence.  Now I'm sold.
09:21:53 <jonaskoelker> vixey: split what?  how?  I thought I _had_ two functions...
09:21:55 <Lemmih> SamB: Then that's what LHC supports (:
09:21:57 <Gilly> Lemmih: okies - i see. what are the biggest things still missing?
09:21:57 * jonaskoelker doesn't follow
09:22:34 <Lemmih> ozy`: I really wish I could use LLVM. Unfortunately it doesn't support (proper) garbage collection or exceptions.
09:22:36 <vixey> jonaskoelker: split it again
09:22:45 <Axman6> LLVM is pretty cool really
09:22:46 <SamB> Lemmih: I think I added 2/4 of the FFI forms that it does support
09:22:48 <Gilly> SamB: that means that i can't set callbacks in gtk?
09:23:02 <jonaskoelker> vixey: which "it", and where?
09:23:03 <SamB> er. 2/4 of the FFI forms, bringing it up to 3/4
09:23:15 <Axman6> Apple are using it for some cool stuff, and some other people are using it for some even more cool (and/or useless) stuff, like a C -> Flash compiler
09:23:32 <Gilly> SamB: because the gtk would like to call some functions that would live in the haskell world, is that what you are saying?
09:23:42 <SamB> yeah.
09:23:52 <paper_cc> jonaskoelker: g
09:24:01 <blando> jonaskoelker: you could change the signature to Sense -> Filter -> a -> [b] -> [b] and ditch the "map snd" call, then the function should work generically over any type b, be it a single value or tuple
09:24:02 <Gilly> alright :)
09:24:04 <Lemmih> Gilly: Well, quite a few things are missing. Our parser is flawed, our type-checker is flawed, we don't support exceptions and there's no GC.
09:24:49 <Axman6> :t map (first ?f) ?xs
09:24:51 <PeakerLambda> forall b c d. (?xs::[(b, d)], ?f::b -> c) => [(c, d)]
09:24:53 <jonaskoelker> gahh... there's a missing s/$ list/$ zip list [0..]/
09:24:56 <SamB> I couldn't figure out how to design the dynamic C stubs implementation
09:25:05 <Gilly> Lemmih: i see, doesn't sound too bad, though
09:25:10 <vixey> Lemmih, why you are forking JHC instead of starting from scratch?
09:25:26 <vixey> not sure I've noticed anything /good/ about JHC yet
09:25:37 <Lemmih> vixey: Most of the code in JHC is great.
09:25:43 <SamB> the two issues, I think, were getting it to work with the "garbage collection", and how to actually generate the stubs ...
09:25:48 <vixey> m I had skimmed it I didn't get that impression
09:25:50 <Axman6> Lemmih: it's supposed to be good at optimising right?
09:25:59 <vixey> maybe I didnt' look hard enough
09:26:15 <jonaskoelker> meh, I think I'm going to duplicate the code and use diff to make sure I keep them in sync...
09:26:25 <vixey> optimizing hello world or something :p
09:26:33 <Lemmih> Axman6: Yes, we perform some quite aggressive whole-program optimizations.
09:28:01 <SamB> I was thinking about having the compiler generate C functions that took an extra argument that contained the Haskell function, and having the stubs just push an extra argument on the stack or something ... but I wasn't sure how portable that would be ...
09:28:27 <SamB> plus, how would I keep the Haskell function alive ?
09:28:51 <Axman6> would it be possible to write a program that would tell you if a C function was pure?
09:28:54 <SamB> I think I'd found a feature in Foreign that ought to help but discovered that JHC didn't implement it ...
09:29:08 <pejo> Axman, that's the halting problem
09:29:11 <ddarius> Axman6: Not with perfect accuracy.
09:29:29 <vixey> I figured it out
09:29:32 <vixey> GHC is evil
09:29:37 <ddarius> @users
09:29:38 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 32767
09:29:59 <Axman6> ddarius: but possible to some degree then?
09:30:29 <vixey> GHC is specifically NOT compiling any other haskell compilers
09:30:38 <SamB> Axman6: you could write programs that wouldn't tell you a function was pure when it wasn't
09:30:48 <Axman6> hmm, just had an idea. someone should write a TeX compiler in haskell
09:30:53 <SamB> Axman6: but they'd never be able to always tell you they were pure
09:30:55 <vixey> most programs do compile but absolutely not one haskell compiler
09:30:57 <SamB> when they were
09:31:08 <Axman6> SamB: yeah, thought as much
09:31:34 <mreh> can someone explain to me why we have introduced this notion of a thunk in haskell? Isn't it as simple as the expression's evaluation is delayed?
09:31:42 <vixey> mreh, it is that simple
09:31:50 <EvilTerran> thunks are an implementation detail
09:32:13 <SamB> even telling you if a C function can invoke UB is the halting problem, so obviously telling you if it's pure or not is too ;-P
09:32:32 <mreh> is it more costly to pass a thunk?
09:32:38 <cizra> vixey: Isn't it equivalent to the halting problem to decide if a given program is a haskell compiler?
09:32:42 <SamB> (if it can invoke UB, it isn't pure ;-P)
09:32:53 <Axman6> mreh: how do you want to store this delayed expression?
09:33:17 <Saizan> ?google UB
09:33:19 <PeakerLambda> http://www.buffalo.edu/
09:33:19 <PeakerLambda> Title: University at Buffalo
09:33:30 <ddarius> SamB: You can write a program that can conclusively say "yes" as well as "no."  It'll just say "maybe" sometimes as well.
09:33:31 <EvilTerran> mreh, if you're in a strict language, you can explicitly use thunks to get a poor-man's laziness
09:33:45 <EvilTerran> think "function () { ... }" in javascript
09:33:51 <jonaskoelker> cizra: don't all recursively enumarable non-recursive languages reduce to one another?
09:33:59 <mreh> im just interested in the mechanics, and how this relates to performance
09:34:19 <SamB> ddarius: true
09:34:33 <cizra> jonaskoelker: *reads* *rereads again* *still is confused* What's a recursive or non-recursive language? What does it mean to enumerate one? What is recursive enumeration?
09:34:44 <vixey> (aren't there more interesting problems than entscheidungsproblem?)
09:34:49 <mreh> on an abstract level, say in the calculation of a factorial, if i didn't force the calculation of n-1 in the recursive case, will it be slower
09:34:50 <SamB> but usually a "no" answer isn't much more useful than a "maybe" answer and vice-versa.
09:34:59 * EvilTerran knows what recursive enumeration is
09:35:14 <EvilTerran> not sure about what you mean by "non-recursive"
09:35:17 * skorpan should know what recursive enumeration is
09:36:09 <EvilTerran> a recursively enumerable language is one in which all words in the language can be positively identified as such, but some words not in the language may cause the acceptance machine to not halt
09:36:09 <SamB> Lemmih: umm ... why no README?
09:36:13 <jonaskoelker> cizra: I think the cliff notes version of a good language/computability textbook should explain it well  (I can't type it all here)
09:36:16 <quicksilver> EvilTerran: non-(recursively enumerable)
09:36:17 <mreh> recursively enumerable is the set of all functions computable by a turing machine
09:36:25 <quicksilver> EvilTerran: not (non-recursively) enumerable
09:36:30 <EvilTerran> ah, gotcha
09:37:23 <Lemmih> SamB: I'm not sure what it should say.
09:37:44 <jonaskoelker> mreh: one way to put it: a language is recursive if there's a turing machine which spits out all its strings in sorted order
09:37:49 <mreh> @type null
09:37:49 <EvilTerran> equivalently, a recursively enumerable language is one for which you can construct a machine which enumerates the language to its output tape, so any word will appear on the tape in finite time
09:37:50 <PeakerLambda> forall a. [a] -> Bool
09:37:54 <SamB> Lemmih: it could say "see http://lhc.seize.it/ for installation/usage instructions"
09:37:58 <PeakerLambda> Title: Wiki - Front Page
09:38:03 <jonaskoelker> mreh: a language is recursively enumerable if there's a turing machine that outputs all its strings (in any order)
09:38:19 <Lemmih> SamB: Excellent. Send me a patch.
09:38:28 <syntaxfree> @quote recursion
09:38:29 <PeakerLambda> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
09:38:29 <PeakerLambda> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
09:38:29 <PeakerLambda> still
09:38:58 <francis> rofl
09:39:05 <mreh> i thought the halting problem made calculating if a language was r.e. impossible
09:39:26 * robyonrails football practice
09:39:27 <Axman6> r.e.?
09:39:32 <skorpan> syntaxfree: uh, what the hell, that's my old nickname
09:39:42 <jonaskoelker> is there a (\(x, y) -> (y, x)) in the standard library?
09:39:50 <syntaxfree> skorpan: "syntaxfree"?
09:39:54 <skorpan> syntaxfree: kristnjov
09:40:12 * SamB was a bit alarmed for a bit there ...
09:40:13 <jonaskoelker> or would one just write (uncurry $ flip (,))?
09:41:01 <EvilTerran> jonaskoelker, if you import Control.Arrow ((&&&)), you could write (snd &&& fst)
09:41:19 <chrisdone> that's nice
09:41:25 <cnwdup> Can I set the _NET_WM_STRUT_PARTIAL property without X11.Extras?
09:41:35 <EvilTerran> it really should have a "swap = arr $ \(x,y) -> (y,x)", seeing as it's used repeatedly in the de-sugaring
09:41:37 <EvilTerran> IMO
09:41:50 <EvilTerran> ?type arr $ \ ~(x,y) -> (y,x)
09:41:51 <PeakerLambda> forall (a :: * -> * -> *) t t1. (Arrow a) => a (t, t1) (t1, t)
09:42:16 <chrisdone> i'e
09:42:22 <chrisdone> er, I approve
09:42:54 <chrisdone> personally I very rarely have to flip a tuple
09:43:29 <Olathe> @pl \(a, b) -> (b, a)
09:43:39 <Olathe> No bots :(
09:44:15 <chrisdone> lunabot: pl \(a, b) -> (b, a)
09:44:33 <augustss> What's happened to lb?
09:46:06 <Olathe> > uncurry (flip (,) $ (1, 2)
09:46:10 <Olathe> > uncurry (flip (,)) $ (1, 2)
09:46:14 <Olathe> Bah.
09:46:26 <Olathe> Olathe: (2, 1)
09:46:29 <Olathe> See ? It works.
09:46:36 <EvilTerran> chrisdone, i very rarely use "flip", either; but they both feel kinda fundamental things to have around to me
09:47:01 <EvilTerran> particularly once you start using Control.Arrow, which is why i'd generalise it with "arr" and stick it in there
09:47:08 <Badger> oh?
09:47:17 <Badger> , uncurry (flip (,)) $ (1, 2)
09:47:19 <lunabot>  (2,1)
09:47:36 * wli uses flip all the time, in particular sortBy (flip compare) and other comparators.
09:48:16 <chrisdone> yeah, I use `flip' the function all the time, and I expect most people do
09:48:21 <chrisdone> I meant flipping tuples
09:48:28 <kohwj> how ready is the reactive fieldtrip library for simple game development?
09:48:29 <chrisdone> you're flipping crazy!
09:48:37 <ddarius> EvilTerran: flip is the mediating isomorphism of the (an) adjunction underlying the continuation monad!
09:48:47 <Olathe> . reverse "crazy"
09:48:49 <PeakerWork> EvilTerran: I think "arr" being part of the Arrow class is a mistake, so if you can define stuff using other combinators rather than "arr", its better
09:48:51 * wli uses flip (,) 
09:48:54 <Olathe> , reverse "crazy"
09:48:56 <lunabot>  "yzarc"
09:48:58 <Olathe> Faster !
09:49:08 <PeakerWork> kohwj: IMO, not ready for "real work" yet
09:49:20 <ddarius> PeakerWork: For what Arrows model, arr is a necessary part of the data.
09:49:21 <PeakerWork> kohwj: its already great fun though
09:49:31 <kohwj> PeakerWork: that's enough for me ;)
09:49:37 <EvilTerran> PeakerWork, well, something like "arr" is necessary for de-sugaring, but i agree that it's not part of the fundamental model
09:49:39 <ddarius> :t uncurry (flip (,))
09:49:50 <dmwit> "Maintaining Laziness" is great.
09:49:59 <kohwj> PeakerWork: just trying to build a game portfolio, and FRP sounds cutting-edge enough
09:50:05 <Olathe> , fun "test" :: Expr
09:50:06 <PeakerWork> ddarius: well, it could be nice if arrows could represent bijective functions and such, and "arr" ruins it
09:50:11 <SamB> EvilTerran: I really think it shouldn't be :-(
09:50:12 <wli> When absolute necessary, swap = uncurry $ flip (,)
09:50:13 <EvilTerran> i'd maybe move it to a subclass; "ArrowPure" or something
09:50:15 <lunabot>  test
09:50:20 <Badger> PeakerWork: was lbot resource-heavy?
09:50:26 <Elly> ddarius: you just said a sentence which made no sense to me :(
09:50:28 <Olathe> , fun ("That's not flipping crazy ! This is flipping crazy: " ++ show (reverse "crazy")) :: Expr
09:50:29 <PeakerWork> Badger: mueval of memory-hungry evaluations
09:50:33 <lunabot>  That's not flipping crazy ! This is flipping crazy: "yzarc"
09:50:37 <Badger> d'oh.
09:50:37 <jonaskoelker> EvilTerran: thanks for the &&& tip; wli: thanks for the sortBy (flip compare) tip <--- exactly what I needed :)
09:50:39 <SamB> all the coolest arrows don't have a pure anyway
09:50:51 <kohwj> 'night all
09:50:52 <PeakerWork> Badger: I ulimit'd it and it was fine.. not sure why its gone
09:51:00 <ddarius> PeakerWork: Those aren't Arrows in Haskell.
09:51:00 <Elly> 12:47  ddarius: EvilTerran: flip is the mediating isomorphism of the (an) adjunction underlying the continuation monad! <---
09:51:10 <PeakerWork> Badger: oh, lambdabot itself crashed because it exceeded my 200MB limit
09:51:15 <EvilTerran> so a proc block that only ever had a single name in the <-...-< would be "Arrow a =>", and ones with more complex expressions in there would be "ArrowPure a =>"
09:51:21 <Olathe> , fun "\001ACTION lambadas.\001" :: Expr
09:51:26 <lunabot>  ACTION lambadas.
09:51:28 <SamB> ddarius: that's just what we are complaining about
09:51:30 <Olathe> Ah hah !
09:51:43 <PeakerWork> ddarius: Yeah, but many Arrow stuff are separated into extension classes, I think "arr" should have been too, to make Arrow combinators like &&& and *** far more widely useful
09:51:52 <ddarius> SamB: My point is that they aren't the concept that Arrows model (at least in the Haskell category)
09:52:23 <vixey> , fun ".\n.\001ACTION lambadas.\001" :: Expr
09:52:28 <SamB> ddarius: well, we want soemthing between Category and Arrow, then
09:52:28 <lunabot>  .
09:52:28 <lunabot>  .ACTION lambadas.
09:52:31 <EvilTerran> Elly, the thought of using "flip" as a MonadCont action is what got my head hurting
09:52:34 <chrisdone> nice try Hal
09:53:01 <jonaskoelker> bot question: is there a function lookup-by-type?
09:53:08 <ddarius> SamB: That's fine.  It's just a different thing than Arrow represents.
09:53:30 * wli doesn't quite get arrows yet, but "arr" seems to be something like tabulation.
09:53:31 <Saizan> jonaskoelker: lookup-by-type?
09:53:34 <SamB> ddarius: but we want things like (&&&) anyway
09:53:41 <chrisdone> @hoogle does that
09:53:41 <PeakerLambda> No results found
09:53:55 <chrisdone> @hoogle a -> a
09:53:56 <PeakerLambda> Prelude id :: a -> a
09:53:56 <PeakerLambda> Data.Function id :: a -> a
09:53:56 <PeakerLambda> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
09:53:58 <jonaskoelker> @hoogle (a -> b) -> [a] -> [b]
09:53:58 <PeakerLambda> Prelude map :: (a -> b) -> [a] -> [b]
09:53:58 <PeakerLambda> Data.List map :: (a -> b) -> [a] -> [b]
09:53:58 <PeakerLambda> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:54:00 <SamB> I guess they'd need to be in a class
09:54:02 <ddarius> SamB: Those could be moved to a more generic "Product" class.
09:54:05 <jonaskoelker> ah, cool :)
09:54:09 <PeakerWork> wli, ddarius: "arr" forces arrows to be at least as expressive as turing-complete Haskell functions, which leaves out a lot of interesting data types that can support the rest of the operators
09:54:26 <chrisdone> does anyone have a module which does some fancy work and gives you, essentially, lambdabot?
09:54:32 <chrisdone> ❤ map = fmap ♥ etc.?
09:54:39 <jonaskoelker> @hoogle (a -> (a, b)) -> a -> [b]
09:54:39 <PeakerLambda> No results found
09:54:45 <jonaskoelker> @hoogle (a -> (b, a)) -> a -> [b]
09:54:45 <PeakerLambda> No results found
09:54:49 <jonaskoelker> :(
09:54:50 <SamB> obviously this would benifit from class aliases or some other mechanism to provide simple drop-in typeclass implementations for common cases
09:55:14 <Saizan> @hoogle (a -> Maybe (a,b)) -> a -> [b]
09:55:15 <PeakerLambda> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
09:55:15 <PeakerLambda> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
09:55:15 <PeakerLambda> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
09:56:07 <jonaskoelker> Saizan: awesome, thank you :)
09:56:30 <ddarius> PeakerWork: Arrows are closely related to the concept of a Freyd category.  A Freyd category is an embedding functor that can be thought of as embedding a pure subset of a language into a full language.  arr is that embedding functor's action on arrows (i.e. Haskell functions)
09:57:16 <PeakerWork> ddarius: I am not sure what that means, but there should be no harm separating "arr" and the rest of the methods into separate type classes :)
09:57:21 <SamB> how do you install cabal 1.7 ...?
09:57:53 <Saizan> SamB: darcs get --partial http://darcs.haskell.org/cabal
09:57:56 <PeakerLambda> Title: Index of /cabal
09:57:57 <dmwit> wli: tabulation?
09:58:36 <rwbarton> PeakerWork: I'm not sure about that--most of the default method definitions use arr, don't they?  (e.g. for second in terms of first)
09:58:48 <dmwit> ?botsnack
09:58:48 <PeakerLambda> :)
09:59:51 <dmwit> ?join #xmonad
09:59:52 <PeakerLambda> Not enough privileges
09:59:53 <rwbarton> @src second
09:59:53 <PeakerLambda> Source not found. The more you drive -- the dumber you get.
09:59:54 <PeakerWork> rwbarton: Well, what is "arr" used for, except swap, which can instead be a method?
10:00:17 <dmwit> rwbarton: second is a class method, for efficiency's sake
10:00:18 <Olathe> @src arr
10:00:18 <PeakerLambda> Source not found. That's something I cannot allow to happen.
10:00:19 <wli> dmwit: For instance, (Bounded t, Enum t, Ord t) => t -> t can be represented by Map t t
10:00:26 <EvilTerran> ?type snd &&& fst
10:00:27 <PeakerLambda> forall a c. (a, c) -> (c, a)
10:00:40 <dmwit> ?src (->) second
10:00:40 <PeakerLambda> second f = id *** f
10:00:50 <EvilTerran> ?src (***)
10:00:50 <PeakerLambda> f *** g = first f >>> second g
10:00:53 <rwbarton> dmwit: Yeah, all I'm saying is, if you separated out arr into a subclass, you couldn't have that default definition in the superclass
10:00:59 <EvilTerran> ah, yes, those ones're all inter-defined
10:01:14 <dmwit> rwbarton: Oh, sorry, I wasn't following the whole conversation.
10:01:41 <EvilTerran> i started it by suggesting "Control.Arrow.swap = arr $ \ ~(x,y) -> (y,x)" :P
10:01:57 <PeakerWork> rwbarton: I guess you would also need something like "fst", in addition to "swap" and "first", to be able to convert an arrow to (a,b) to an arrow to a
10:02:09 <dmwit> EvilTerran: Yep, that's used in a lot of the arrow papers.
10:11:26 <maltem> Is 'automaton' synonymous to 'abstract machine'?
10:16:28 <SamB> Lemmih: I has a problem ...
10:16:49 <SamB> I try to configure the latest cabal-install from darcs but it complains:
10:16:55 <SamB> Setup.hs: At least the following dependencies are missing:
10:16:55 <SamB> Cabal ==1.6.*
10:17:21 <Lemmih> SamB: Yeah, you have to edit the .cabal file.
10:17:32 <SamB> Lemmih: that's not on the wiki!
10:17:33 <Lemmih> (It sucks, I know)
10:17:54 <SamB> dcoutts_: what's the deal with that???
10:20:13 <mohbana> what;s the recommended interpreter and compiler to use on unbunt intrepid ?
10:20:42 <wchogg> ghc?
10:20:43 <Lemmih> mohbana: GHCi and GHC.
10:20:51 <vixey> I can't get EHC to compile :(
10:23:44 <wabash> has anyone here worked through RWH completely?
10:23:57 <wabash> And in terms of edu benefit, how's it compare to SICP?
10:27:28 <vixey> wabash, probably not a interesting comparison
10:28:30 <wabash> vixey: ? Perhaps. I'm complete outsider to Haskell (at the moment), but found SICP so enlightening that it has spilled over into my ruby work.
10:28:45 <wabash> I'm thinking that Haskell will also be enlightening.
10:29:17 <wabash> But want to know frm an insider POV if RWH is something worth it, or if it's another bullshit book like "teach yourself Java in 20 days"
10:29:26 <wabash> Is it comperable to OnLisp?
10:29:27 <SamB> man, I think I want to wipe my GHC install :-(
10:29:30 <Elly> mmm, sicp
10:29:31 <Raevel> i really like rwh so far
10:29:34 <wabash> cool
10:29:45 <wabash> Raevel: How long have you known Haskell?
10:29:52 <schme> wabash: Would comparable to OnLisp be a good thing or a bad thing?
10:30:12 <therp> wabash: from a quick glance I don't think that RWH is comparable to On Lisp
10:30:25 <therp> wabash: having only read On Lisp though
10:30:29 <Raevel> wabash: 6 months since i first touched it, but i didn't really do anything with it until a couple of months back
10:30:36 <wabash> schme: Somewhat of a good thing, as opposed to the myriad copious crap out there about C and C++
10:30:51 <wabash> Raevel: Ok, thanks.
10:31:17 <schme> wabash: I see. I assume RWH == real world haskell, and I'd put it up there with practical common lisp. But for haskell of course.
10:31:23 <schme> wabash: onlisp, not so hot :)
10:31:35 <wabash> schme I mean to say that there are thousands of C sites out there, but none of them really cover "programming in C".... Just iterators, assignment, and IO.
10:31:42 <schme> wabash: 'cept rwh had a lot of exercises. I hate that.
10:31:47 <therp> schme: that's a good point (relating RWH to PCL)
10:31:50 <wabash> schme:  Ok, cool. Thanks for the input.
10:31:59 <wabash> Is PCL well regarded among lispers?
10:32:07 <vixey> wabash, it's juts about using this specific tool (Haskell), whereas SICP is about fundamentals
10:32:12 <schme> therp: They seem to be going for somewhat of the same thing too :)
10:32:14 <schme> wabash: Very.
10:32:17 <wabash> vixey: Ok, got it.
10:32:38 <wabash> Ok, PCL good, SICP good, OnLisp sorta ok and not good....
10:32:48 <vixey> therp, that's kinda cruel
10:32:50 <vixey> :p
10:33:00 <schme> wabash: OnLisp is quite ok, but it is by graham so no one likes it ;)
10:33:04 <wabash> If I combine SICP with RWH, then I could be a good FP in Haskell?
10:33:10 <SamB> RWH doesn't have such a ridiculous domain name though
10:33:20 <vixey> therp, (On Lisp is about bizarre unidiomatic programming but RWH is more about sensible programming)
10:33:26 * SamB can't decide if he's jealous on behalf of RWH or not
10:33:40 <wabash> schme:  But Graham had a (single) stellar success, by only working with one (brilliant) other person!
10:33:42 <wabash> ;)
10:33:50 <schme> wabash: Indeed.
10:34:10 <wabash> Him and Kawasaki are wealths of great advice about how to succeed (once).
10:34:20 <schme> wabash: RWH is a good read for sure. That's what I say.  And I'm pretty much the haskell guru with my ~1 year of almost using it and all.
10:34:27 <wabash> ok, sorry. I don't mean to be so snarky....
10:34:41 <wabash> schme:  Hahaha.  Well, 1 year is better than my 1 week.
10:34:42 <schme> wabash: Well it's ok. We can make fun of Arc next.
10:35:02 <wabash> Why make fun of it? Arc is a great collection of macros for Scheme.....
10:35:08 <schme> hahahaha.
10:35:12 <Botje> Arc is the windows millenium of programming languages!
10:35:28 * schme google windows millenium
10:35:36 <Olathe> @go windows millenium
10:35:37 <PeakerLambda> Maybe you meant: google googleit . ? @ bf ft ghc id pl rc v wn yow
10:35:38 <vixey> people still talking about it as if it actually has some value...
10:35:41 <Olathe> Maybe I did.
10:35:50 <Olathe> @help google
10:35:51 <PeakerLambda> google <expr>. Search google and show url of first hit
10:35:52 <Olathe> @help googleit
10:35:52 <PeakerLambda> letmegooglethatforyou.
10:36:00 <Olathe> @googleit test
10:36:00 <PeakerLambda> http://letmegooglethatforyou.com/?q=test
10:36:06 <Olathe> Okey dokey
10:36:10 <schme> oh it is some microsof os :)
10:36:41 <schme> wabash: But ya of course. go with the rwh and the sicp and hack a lot of code and eventually you'll be a FP wizard.
10:36:44 <schme> :)
10:37:09 <wabash> schme:  Thank you for the encouragement. It's a hard road to follow nowadays.
10:37:14 <schme> I kinda liked the MS OS's I have had installed.
10:37:40 <schme> wabash: Pfft. Just quit your job / studies and spend all your time with it. no problem.
10:37:53 <idnar> wabash: don't you have to be tested at the Tower of High Sorcery
10:38:11 <wabash> idnar: Appointment for friday...
10:38:45 <schme> One thing that is cool about haskell is that if you wonder about something you just ask #haskell and you get 8 different answers in no time at all.
10:39:14 <BONUS_> the cool thing about #haskell is that you dont get told to RTFM
10:39:25 <schme> Yes indeed :)
10:39:30 <schme> I meant 8 good answers too.
10:40:21 <Saizan> that's becoming harder with the number of users increasing
10:41:14 <schme> Easily solved by a coule of kickbans.
10:41:18 <schme> couple.
10:41:42 <vixey> sometimes manuals have got useful information in them
10:42:23 <paper_cc> that's the polite variant =)
10:42:37 <vixey> EHC builds!
10:42:41 <wchogg> I think rtfm needs to be replaced with utfg
10:42:50 <schme> What the heck is utfg?
10:42:56 <mohbana> is the haskell-mode from the ubuntu repo fine?
10:42:57 <enticingjelly> yeah, haskell really is the most friendly and not retarded behaving tech channel I know
10:43:06 <Riastradh> schme, clearly it is the Unicode Transformation Format for Google.
10:43:13 <vixey> "RTFM" is obviously rude but being told about that a manual has got some info you need should never be considered rude
10:43:13 <hcube> vixey: are you an EHC developer?
10:43:15 <enticingjelly> I like to mention that especially in other tech channels ;)
10:43:17 <vixey> assuming it's true
10:43:27 <schme> Riastradh: No no.. I'll just google it :(
10:43:34 <vixey> hcube, no I just wanted to use it
10:43:40 <Riastradh> schme, JFG UTFG!
10:43:46 <vixey> hcube, (tried LHC and YHC and bunch of other crap too none of which works)
10:43:49 <enticingjelly> also, it seems to be the least bullshitty.
10:43:50 <schme> Riastradh: bless you :)
10:44:07 <schme> UTFGUse The Fine Google
10:44:13 <wchogg> right
10:44:23 <hcube> currently only the interpreted grin backend is working in EHC
10:44:43 <vixey> hcube, are you ? :p
10:45:59 <SamB> huh.
10:46:00 <hcube> i'm learning about haskell compilers :) i'll do some development in EHC next semester
10:46:02 <SamB> LHC doesn't like me.
10:46:20 <vixey> hcube, oh cool
10:46:48 <schme> well fag time. You guys and gals have a good one.
10:46:58 <Raevel> I have a string containing a double that i want to convert to a Rational, how should i do it?
10:47:21 <vixey> > let rat = read :: String -> Rational in  rat "3%2"
10:47:23 <PeakerLambda>   3 % 2
10:47:33 <vixey> oh.......
10:47:44 <vixey> :t toRational
10:47:45 <PeakerLambda> forall a. (Real a) => a -> Rational
10:47:49 <vixey> > let rat = toRational (read :: String -> Double) in  rat ".2"
10:47:50 <PeakerLambda>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:47:52 <Saizan> SamB: i guess with HEAD cabal-install not compiling with HEAD Cabal-1.7 it's not so easy to build LHC, eh?
10:47:54 <paper_cc> > let rat = toRational . read $ "1.5"
10:47:55 <vixey> > let rat = toRational (read :: String -> Double) in  rat "2.2"
10:47:55 <PeakerLambda>   <no location info>: parse error on input `;'
10:47:55 <PeakerLambda>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:47:57 <vixey> > let rat = toRational .(read :: String -> Double) in  rat "2.2"
10:47:59 <PeakerLambda>   2476979795053773 % 1125899906842624
10:48:18 <SamB> Saizan: well, LHC also seems to object to my use of GHC 6.8
10:48:37 <paper_cc> >let rat = toRational . (read :: String -> Double) $ "1.5"
10:48:42 <paper_cc> bzz
10:48:44 <paper_cc> > let rat = toRational . (read :: String -> Double) $ "1.5"
10:48:45 <PeakerLambda>   <no location info>: parse error on input `;'
10:49:24 <Saizan> SamB: lhc or cabal? there's a bug in cabal-install-0.6.1 about ghc-prim
10:49:27 <Raevel> thanks vixey!
10:49:34 <SamB> Saizan: oh ?
10:50:06 <SamB> I guess it's cabal{,-install}
10:50:14 <Saizan> http://hackage.haskell.org/trac/hackage/ticket/439
10:50:17 <PeakerLambda> Title: #439 (cabal install: dependency on ghc-prim?) - Hackage - Trac
10:50:48 <vixey> amusing pair of errors
10:50:52 <rwbarton> > read "1.51" :: Rational
10:50:53 <PeakerLambda>   * Exception: Prelude.read: no parse
10:51:05 <paper_cc> > toRational . read $ "1.5"
10:51:07 <PeakerLambda>   * Exception: Prelude.read: no parse
10:51:07 <dmwit> PeakerWork: Could you have PeakerLambda join #xmonad?
10:51:13 <dmwit> ?hackage cabal-install
10:51:14 <PeakerLambda> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
10:51:22 <vixey> > toRational . read $ "1"
10:51:23 <PeakerLambda>   1 % 1
10:51:27 <paper_cc> > toRational . (read :: String -> Double) $ "1.5"
10:51:28 <PeakerLambda>   3 % 2
10:51:49 <paper_cc> @let readRational = toRational . (read :: String -> Double)
10:51:50 <PeakerLambda>  Defined.
10:52:08 <rwbarton> But that doesn't handle, e.g., 1.500000000000000000000000000000000001
10:52:14 <rwbarton> > 1.500000000000000000000000000000000001 :: Rational
10:52:15 <PeakerLambda>   1500000000000000000000000000000000001 % 1000000000000000000000000000000000000
10:52:38 <Saizan> SamB: a dirty fix might be grepping for ghc-prim in cabal-install's source and commenting that line
10:52:43 <rwbarton> The Haskell compiler does it properly, but it seems not to be in a library function
10:52:48 <paper_cc> readRational "1.500000000000000000000000000000000001"
10:52:55 <paper_cc> > readRational "1.500000000000000000000000000000000001"
10:52:56 <PeakerLambda>   3 % 2
10:53:20 <dons> ?users
10:53:20 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 32767
10:53:23 <dons> mmm.
10:54:09 <dons> huh, #haskell's now in #8 position on freenode
10:54:20 <dons> ahead of #perl.. first time that's happened
10:55:07 <vixey> position ?
10:55:14 <dmwit> > read "1.5" :: Rational
10:55:15 <PeakerLambda>   * Exception: Prelude.read: no parse
10:55:20 <dmwit> bummer
10:55:52 <dons> in size.
10:56:19 <dmwit> > 1.5 :: Rational
10:56:20 <PeakerLambda>   3 % 2
10:57:00 <paper_cc> > read "3%2" :: Rational
10:57:01 <PeakerLambda>   3 % 2
10:57:45 <dmwit> > 1.500000000000000000000000000000000000000001 :: Rational
10:57:46 <PeakerLambda>   1500000000000000000000000000000000000000001 % 10000000000000000000000000000...
10:58:08 <dmwit> The functionality is there.  It's a real shame it's hidden from read.
10:58:22 <paper_cc> dmwit: are there arbitary-precision floats?
10:58:40 <dmwit> paper_cc: no
10:58:48 <dmwit> paper_cc: Rational is not a float.
10:58:53 <dmwit> err...
10:58:56 <dmwit> depending on what you mean by float.
10:59:01 <rwbarton> , fromDyn (eval "1.5000000000000000000000001 :: Rational") (undefined :: Rational)
10:59:07 <dmwit> ?instances Floating
10:59:07 <PeakerLambda> Double, Float
10:59:08 <lunabot>  15000000000000000000000001 % 10000000000000000000000000
10:59:16 <paper_cc> dmwit: a floating-point number
10:59:32 <dmwit> paper_cc: That clears up nothing.
10:59:35 <dmwit> anyway
10:59:41 <dmwit> Rational is arbitrary-precision.
10:59:52 <paper_cc> dmwit: that won't read 1.500...0001
10:59:53 <purple_> > read "1000000000000000000001%1000000000000000" :: Rational
10:59:54 <vixey> , [$ty| eval |]
10:59:54 <PeakerLambda>   1000000000000000000001 % 1000000000000000
11:00:00 <dmwit> And number literals in Haskell source stand for Rationals.
11:00:00 <lunabot>  String -> Dynamic
11:00:00 <conal> PeakerWork: ("the Zip class seems like a special case of the Applicative class... Why not use Applicative?  (In conal's blog)").  Have you gotten an answer yet?
11:00:08 <vixey> , eval "1+1"
11:00:14 <lunabot>  <<Integer>>
11:00:25 <vixey> , fromDyn (eval "1+1") :: Integer
11:00:27 <lunabot>  luna: Couldn't match expected type `GHC.Integer.Internals.Integer'
11:00:28 <dmwit> paper_cc: If you write "1.0...01" in Haskell source, it's actually shorthand for "fromRational 1.0...01".
11:00:41 <paper_cc> hmm
11:00:45 <dmwit> So the number is read from the source with arbitrary precision, then cast to whatever type you want it at.
11:01:45 * dmwit feels that he is doing a pretty poor job of explaining this
11:02:37 * paper_cc skims through :bro Data.List to create a function to read arbitary Rationals
11:02:48 <dmwit> =)
11:03:01 <dmwit> You might want to skim Text.ParserCombinators.Parsec instead.
11:03:20 <dmwit> or maybe the ReadP docs
11:03:29 <wli> Sort of. It's not entirely transparent. You basically get something like fromInteger 101010101 etc.
11:04:04 <SamB> Lemmih: do you have Control.Arrow building yet ?
11:04:15 <wli> If your numeric hierarchy (obviously this pertains to overriding the standard Prelude) doesn't like fromInteger, you're screwed.
11:05:33 <Lemmih> SamB: I don't know. We should add it to the testsuite if doesn't build.
11:06:01 <wli> This gets noticed in particular with natural number data types.
11:06:07 <Olathe> > let readRational xs = n % d where (n, d) = splitBy '/' xs; splitBy c [] = ([], []); splitBy c (x:xs) = if c == x then ([], xs) else (x:xs, ys) where (xs, ys) = splitBy c xs in readRational "53/3"
11:06:08 <PeakerLambda>   No instance for (GHC.Real.Integral [GHC.Types.Char])
11:06:08 <PeakerLambda>    arising from a use ...
11:06:24 <paper_cc> ha
11:06:54 * paper_cc admits that's harder than he thought
11:07:28 <paper_cc> > 100 % 20
11:07:29 <PeakerLambda>   5 % 1
11:09:05 <SamB> Lemmih: what unsafe IO, in particular, are you trying to avoid ?
11:11:19 <wli> > let readRational = uncurry (%) . (read *** read) . splitBy ('/') ; splitBy c = second tail . break (== c) in readRational "53/3"
11:11:20 <PeakerLambda>   53 % 3
11:12:21 <rwbarton> > let readRational = read . map (\c -> if c == '/' then '%' else c) in readRational "53/3"
11:12:22 <PeakerLambda>   * Exception: Prelude.read: no parse
11:12:27 <rwbarton> > let readRational = read . map (\c -> if c == '/' then '%' else c) in readRational "53/3" :: Rational
11:12:28 <PeakerLambda>   53 % 3
11:14:22 <wli> > let readRational = uncurry ((%) `on` read) . splitBy ('/') ; splitBy c = second tail . break (== c) in readRational "53/3"
11:14:23 <PeakerLambda>   53 % 3
11:15:58 <wli> I guess one could just do uncurry ((%) `on` read) . second tail . break (== '/')
11:16:04 <Lemmih> SamB: As you may know, all odd id numbers are keys in a hashtable. Forgetting this encoding scheme makes LHC blow up without warning.
11:16:31 <SamB> Lemmih: true
11:17:22 <Olathe> Watch this.
11:17:23 <Olathe> > let splitBy c [] = ([], []); splitBy c (x:xs) = if c == x then ([], xs) else (x:xs', ys') where { (xs', ys') = splitBy c xs }; readRational xs = (read n) % (read d) where (n, d) = splitBy '/' xs in readRational "53/3"
11:17:24 <PeakerLambda>   53 % 3
11:17:41 <Olathe> > let splitBy c [] = ([], []); splitBy c (x:xs) = if c == x then ([], xs) else (x:xs', ys') where { (xs', ys') = splitBy c xs }; readRational xs = [read n, read d, (read n) % (read d)] where (n, d) = splitBy '/' xs in readRational "53/3"
11:17:42 <PeakerLambda>   [* Exception: Prelude.read: no parse
11:17:54 <Olathe> > let splitBy c [] = ([], []); splitBy c (x:xs) = if c == x then ([], xs) else (x:xs', ys') where { (xs', ys') = splitBy c xs }; readRational xs = (read n, read d, (read n) % (read d)) where (n, d) = splitBy '/' xs in readRational "53/3"
11:17:55 <PeakerLambda>   (* Exception: Prelude.read: no parse
11:18:17 <dmwit> > let readRational = uncurry (+) . first read . second (\(x:xs) -> read xs % (10 ^ length xs)) . break (== '.') in readRational "1.5"
11:18:18 <PeakerLambda>   * Exception: Prelude.read: no parse
11:18:29 <Lemmih> SamB: Also, we can't use the default Binary instances for maps of Ids. Such subtleties makes it way too difficult for newcomers to hack the code.
11:18:46 <wli> Olathe: What's wrong with uncurry ((%) `on` read) . second tail . break (== '/') ?
11:18:46 <dmwit> > let readRational = second (\(x:xs) -> (xs, length xs)) . break (== '.') in readRational "1.5"
11:18:47 <PeakerLambda>   ("1",("5",1))
11:19:03 <dmwit> :t (%)
11:19:04 <PeakerLambda> forall a. (Integral a) => a -> a -> Ratio a
11:19:08 <dmwit> ah
11:19:11 <vixey> > (((%) `on` read) . second tail . break (== '/'))   "3/2"
11:19:12 <PeakerLambda>   Couldn't match expected type `GHC.Base.String'
11:19:26 <dmwit> > let readRational = uncurry (+) . first read . second (\(x:xs) -> (read xs :: Integer) % (10 ^ length xs)) . break (== '.') in readRational "1.5"
11:19:27 <PeakerLambda>   * Exception: Prelude.read: no parse
11:19:34 <dmwit> double ah
11:19:44 <dmwit> > let readRational = uncurry (+) . first ((%1) . read) . second (\(x:xs) -> (read xs :: Integer) % (10 ^ length xs)) . break (== '.') in readRational "1.5"
11:19:45 <PeakerLambda>   3 % 2
11:19:51 <dmwit> > let readRational = uncurry (+) . first ((%1) . read) . second (\(x:xs) -> (read xs :: Integer) % (10 ^ length xs)) . break (== '.') in readRational "1.500000000001"
11:19:52 <PeakerLambda>   1500000000001 % 1000000000000
11:19:57 * dmwit takes a bow
11:20:21 <dmwit> > let readRational = uncurry (+) . first ((%1) . read) . second (\(x:xs) -> read xs % (10 ^ length xs)) . break (== '.') in readRational "1.500000000001"
11:20:22 <PeakerLambda>   1500000000001 % 1000000000000
11:20:37 <dmwit> Of course, that doesn't deal with exponent notation.
11:20:48 <dmwit> Or hex.
11:20:54 <dmwit> > 3e0x2
11:20:55 <PeakerLambda>   Not in scope: `x2'
11:20:58 <dmwit> heh
11:21:03 <idnar> > 0x16
11:21:04 <PeakerLambda>   22
11:21:05 <dmwit> > 3e0
11:21:06 <PeakerLambda>   3.0
11:21:09 <Olathe> > let splitBy c [] = ([], []); splitBy c (x:xs) = if c == x then ([], xs) else (x:xs', ys') where { (xs', ys') = splitBy c xs }; readRational xs = n % d where n = read n' :: Integer; d = read d' :: Integer; (n', d') = splitBy '/' xs in [readRational "53/3"]
11:21:09 <PeakerLambda>   [53 % 3]
11:21:12 <Olathe> > let splitBy c [] = ([], []); splitBy c (x:xs) = if c == x then ([], xs) else (x:xs', ys') where { (xs', ys') = splitBy c xs }; readRational xs = n % d where n = read n' :: Integer; d = read d' :: Integer; (n', d') = splitBy '/' xs in readRational "53/3"
11:21:13 <PeakerLambda>   53 % 3
11:21:18 <Olathe> In a list, 53 % 3
11:21:19 <idnar> > let readRational = uncurry (+) . first ((%1) . read) . second (\(x:xs) -> read xs % (10 ^ length xs)) . break (== '.') in readRational "0x15"
11:21:20 <PeakerLambda>   * Exception: /tmp/1425027035:67:152-188: Non-exhaustive patterns in lambda
11:21:23 <Olathe> Outside a list, 2
11:21:27 <idnar> > let readRational = uncurry (+) . first ((%1) . read) . second (\(x:xs) -> read xs % (10 ^ length xs)) . break (== '.') in readRational "0x15.5"
11:21:27 <Olathe> > [53 % 3]
11:21:28 <PeakerLambda>   43 % 2
11:21:28 <PeakerLambda>   [53 % 3]
11:21:33 <Olathe> > 53 % 3
11:21:34 <PeakerLambda>   53 % 3
11:21:36 <Olathe> Yeah, no.
11:21:53 <dmwit> Olathe: What's the deal with your list thing?
11:21:58 <Olathe> Well, watch.
11:22:02 <Olathe> > 53 % 3
11:22:03 <PeakerLambda>   53 % 3
11:22:06 <Olathe> > [53 % 3]
11:22:07 <PeakerLambda>   [53 % 3]
11:22:11 <Olathe> Two different things.
11:22:15 <dmwit> What?
11:22:21 <dmwit> They look fine to me.
11:22:30 <Olathe> Well, 53 % 3 shouldn't be 2.
11:22:34 <Olathe> It should be 53 % 3.
11:22:35 <idnar> it's not 2
11:22:35 <dmwit> ...it isn't.
11:22:40 <dmwit> What are you talking about?
11:22:41 <idnar> I think your IRC client is messing with you
11:22:43 <Olathe> > 53 % 3
11:22:44 <PeakerLambda>   53 % 3
11:22:45 <Olathe> That.
11:22:50 <Olathe> Maybe.
11:22:58 <dmwit> It shows as "53 % 3" here.
11:23:01 <Olathe> Ahh.
11:23:08 <Olathe> Yes, my IRC client appears to be crazy.
11:23:15 <SamB> smiley stuff ?
11:23:16 <Olathe> > 53 % 3
11:23:17 <PeakerLambda>   53 % 3
11:23:25 <Olathe> Let me check.
11:23:35 <wli> So you want to parse decimals as well?
11:23:54 <dmwit> > let readRational = uncurry (+) . first ((%1) . read) . second (\(x:xs) -> read xs % (10 ^ length xs)) . break (== '.') in readRational "1.500000000001"
11:23:55 <PeakerLambda>   1500000000001 % 1000000000000
11:23:59 <wli> e.g. 15.37 -> 1537/100?
11:24:00 <dmwit> wli: done
11:24:12 <paper_cc> @where first
11:24:12 <PeakerLambda> I know nothing about first.
11:24:17 <dmwit> With the exception, as noted above, of exponential notation.
11:24:19 <dmwit> ?index first
11:24:20 <PeakerLambda> Control.Arrow
11:24:35 <dmwit> paper_cc: With the (->) arrow, first :: (a -> b) -> (a, c) -> (b, c)
11:24:47 <Olathe> > 53 % 3
11:24:48 <PeakerLambda>   53 % 3
11:24:51 <Olathe> There.
11:24:55 <dmwit> paper_cc: In general, first :: (a ~> b) -> (a, c) ~> (b, c).
11:25:00 <Olathe> That was quite...something.
11:25:03 <dmwit> paper_cc: For any Arrow (~>).
11:25:29 * SamB grumbles about not using the same source for "base" as GHC uses
11:25:31 <Olathe> It was some script I was using.
11:27:31 <paper_cc> dmwit: aha. thanks
11:27:59 <dmwit> ?djinn first :: (a -> b) -> (a, c) -> (b, c)
11:27:59 <PeakerLambda> No output from Djinn; installed?
11:28:04 <dmwit> boo
11:30:04 * wli takes a crack at it.
11:32:03 <paper_cc> dmwit: use pumpkinbot
11:32:17 <paper_cc> pumpkinbot: @djinn first :: (a -> b) -> (a, c) -> (b, c)
11:32:21 <SamB> Lemmih: how do you run tests ?
11:32:24 <paper_cc> brr
11:32:34 <dmwit> I don't see a pumpkinbot in here.
11:32:51 <dmwit> Anyway, the implementation wouldn't surprise you.
11:33:11 <paper_cc> it isn't @botsnack'ing but it answers /msg's
11:33:16 <SamB> Lemmih: and does the E get typechecked by default ?
11:33:26 <dmwit> paper_cc: It's just not in this room.
11:33:27 <SamB> (in the building of base, for instance?)
11:33:30 <altmattr> does GHCi load up all the language extensions by default?
11:33:46 <Lemmih> SamB: Just run the lhc-regress binary. It is installable with 'cabal install -flhc-regress'.
11:33:51 <dmwit> altmattr: no
11:34:00 <dmwit> altmattr: It doesn't do any language extensions by default.
11:34:10 <Lemmih> SamB: I don't follow.
11:34:15 <dmwit> altmattr: With the possible exception of hierarchical modules; I can't remember whether that's actually an extension or not.
11:34:18 <altmattr> hmmm, so I need to try harder to make code that will die with only rank-1 types :)
11:34:30 <SamB> Lemmih: you know what E is, yes ?
11:34:37 <Lemmih> SamB: Yeps.
11:35:16 <SamB> so ... does this get typechecked when using cabal to build a package?
11:35:42 <SamB> it's not always well-typed, you know -- the compiler isn't bug-free!
11:36:05 <vixey> blehhh
11:36:12 <vixey> the state of haskell is not great
11:36:27 <Lemmih> SamB: Ah, you want -flint then.
11:36:44 <SamB> Lemmih: it probably ought to be the default ...
11:36:50 <vixey> it's pretty clear that types make programming easier, why has nobody applied types to all the broken crap like build systems yet?
11:37:02 <vixey> we still use make and stuff :/
11:37:26 <opqdonut> make is quite nice actually
11:37:42 <opqdonut> build systems are solved imo, dependency resolution etc is the problem
11:37:48 <jsn> i think it's not clear to everyone that types make programming easier
11:37:51 <Asztal> configure scripts aren't nice! (from what I can see)
11:37:56 <opqdonut> autohell *hrrr*
11:38:02 <SamB> Asztal: no qualification was required ;-P
11:38:17 <conal> vixey: moreover, 'make' hints at a functional perspective, but doesn't go for it.
11:38:43 <jsn> especially when tying together lots of stuff in other languages, like autotools does
11:39:24 <vixey> conal, hm? refering that actual make language is declarative?
11:39:29 <SamB> % ~/.cabal/bin/lhc-regress -v5
11:39:29 <SamB> Testsuite consists of 20 tests.
11:39:29 <SamB> lhc -o /tmp/HelloWorld/HelloWorld --ho-dir /tmp/HelloWorld ./regress/tests/1_io/basic/HelloWorld.hs +RTS -M1G -RTS
11:39:29 <SamB>           HelloWorld: lhc failed with: 127
11:39:49 <SamB> Lemmih: this isn't too informative ...
11:39:56 <vixey> opqdonut: "build systems are solved" wow ! By whom/what?
11:40:07 <opqdonut> by make :)
11:40:08 <conal> vixey: the dependency part, but then the actions part is imperative.  and redundant with the dependencies, and hence can be incorrect.
11:40:11 <vixey> opqdonut: bc. I am certainly not reaping ANY benefits of this solution
11:40:15 <jsn> Turing machines are solved, too
11:40:24 <vixey> opqdonut: nope make is certainly not a solution, you haven't thought about this
11:40:35 <vixey> conal, aha yeah
11:40:52 <jsn> vixey: nope, opqdonut has thought about this -- you haven't thought about this
11:40:58 <opqdonut> building is the simple part, finding libraries etc. is hard
11:41:00 <conal> lots of problems are "solved" until a better way is found & demonstrated.
11:41:19 <jsn> well, making coffee is solved, too
11:41:25 <paper_cc> if it were solved we wouldn't have cmake, Boost.Jam etc...
11:41:25 <jsn> but, clover machines are nice
11:41:25 <vixey> jsn, (what an odd thing to say, was there anything meaningful in it?)
11:41:28 <enticingjelly> :t and
11:41:29 <PeakerLambda> [Bool] -> Bool
11:41:34 * conal wonders how people know what other people haven't thought about
11:41:42 <Lemmih> SamB: You know where to send patches (:
11:41:46 * jsn nods his head
11:41:58 <SamB> Lemmih: I was hoping you could offer some suggestions of what you do when tests fail
11:42:20 <SamB> the old test harness was a bit more informative ...
11:42:23 <MyCatVerbs> conal: easy, the set of things that you could think about is infinite (I'm not sure whether countable).
11:42:35 <Lemmih> SamB: Run the failing command manually.
11:42:47 <wli> MyCatVerbs: It's actually finite.
11:42:56 <MyCatVerbs> conal: since you think at a finite rate, and you've (AFAIK) only been alive for a finite period of time, there's an infinite quantity of things you haven't thought of yet.
11:43:03 <vixey> because make is not perfect
11:43:11 <vixey> so saying build systems are solved by make is rubbish
11:43:13 <SamB> Lemmih: oh, I think lhc-regress is making the silly assumption that lhc is in the path, perhaps ;-P
11:43:15 <wli> MyCatVerbs: Attempt to encode an infinite number of ideas in chemical states of the brain.
11:43:18 <MyCatVerbs> wli: only if you add a time constraint due to the amount of time it'll take to think them, compared to human lifespan.
11:43:35 <wli> MyCatVerbs: No, not even that is required.
11:43:37 <conal> MyCatVerbs: so you can conclude that there are some things not thought about.  how does one know *which* things?
11:43:38 <Olathe> wli: I've got the naturals.
11:43:55 <SamB> % lhc -o /tmp/HelloWorld/HelloWorld --ho-dir /tmp/HelloWorld ./regress/tests/1_io/basic/HelloWorld.hs +RTS -M1G -RTS
11:43:55 <SamB> zsh: command not found: lhc
11:44:02 <wli> MyCatVerbs: There are also a large number of ideas too complicated for the specific methods used to encode ieas in the brain.
11:44:08 <MyCatVerbs> conal: hey, I already proved that a solution exists... ;D
11:44:22 <vixey> jsn, (I guess not then.)
11:44:32 <Lemmih> SamB: That could be it.
11:44:41 <conal> MyCatVerbs: an answer to a different question
11:44:46 <wli> Olathe: THe naturals only count as one idea; collections are all that way.
11:44:59 <SamB> Lemmih: however, I'm not sure how it should get the path from Cabal
11:45:07 <SamB> so how about you tell me or fix it yourself ;-P
11:45:14 * jsn waves an orange at vixey. "what is this? what is this?"
11:45:15 <MyCatVerbs> conal: good enough for non-constructivists! =D
11:45:58 <vixey> jsn: something I said upset you or what?
11:46:01 <MyCatVerbs> conal: okay, how about if I just start hitting up things way off the edge of silliness. Baboons with dragonfly wings licking handbags with purple tongues made of fungus-coated refridgerators!
11:46:04 <Lemmih> SamB: I'm not sure it should get the path from Cabal.
11:46:12 <vixey> jsn: I don't know what this patronizing idiotic sort of stuff you are saying means
11:46:37 <jsn> vixey: I can just drop the matter, then.
11:46:40 <Lemmih> SamB: Usually you just add ~/.cabal/bin/ to your search path.
11:46:44 <SamB> hmm.
11:46:50 <vixey> jsn: I wanted to understand
11:47:02 <wli> Olathe: There should even be a smallest natural number too complex to be conceived of.
11:47:06 <vixey> jsn: If I have said something that upset you could at least tell me instead of "waving an orange" at me
11:47:28 <Lemmih> SamB: lhc-regress need a --with-lhc= flag, though.
11:47:30 <jsn> vixey: if i were upset with you, i would tell you
11:47:59 <vixey> jsn: So would you please explain to me what you are on about then?
11:48:06 <MyCatVerbs> conal: did that work? =D
11:48:20 <jsn> vixey: at this point, i'm not sure we could have a constructive discussion
11:48:31 <SamB> % PATH=$HOME/.cabal/bin:$PATH lhc-regress -v5
11:48:31 <SamB> Testsuite consists of 20 tests.
11:48:31 <SamB> /home/naesten/.cabal/bin/lhc -o /tmp/HelloWorld/HelloWorld --ho-dir /tmp/HelloWorld ./regress/tests/1_io/basic/HelloWorld.hs +RTS -M1G -RTS
11:48:31 <SamB>           HelloWorld: lhc failed with: 1
11:48:31 <SamB> lhc: user error (LibraryMap: Library base not found!)
11:48:39 <vixey> jsn, because of some aspect of me? What is it?
11:48:48 <jsn> vixey: i must ask to table it for the time being
11:48:58 <vixey> jsn, or because you are not interested in a constructive discussion?
11:49:01 <Lemmih> SamB: Excellent, you're making progress (:
11:49:11 <SamB> now what's wrong?
11:49:15 <jsn> please, let's table it
11:49:17 <SamB> I installed the lib!
11:49:21 <Lemmih> SamB: You haven't installed the base library.
11:49:42 <wli> Olathe: There are also limits on the "connectivity" of ideas or otherwise the number of ideas simultaneously possible to hold in one's mind. Much smaller instances of innately incomprehensible well-formed ideas should be able to be constructed by only moderately high connectivity between a modestly-sized collection of ideas.
11:49:45 <MyCatVerbs> vixey: drop it. Your conversation dug right through "productive" ten minutes ago and is now coming into the middle of a vast seam of "absurd and pointless".
11:49:47 <vixey> jsn, can't do that. Can stop talking to you though
11:49:52 <vixey> jsn, You'll be satisfied with that?
11:49:59 <jsn> i will take some time to consider your remarks when i formulate a reply
11:50:03 <SamB> Lemmih: or, at least, it was supposedly installed
11:51:13 <wli> Olathe: IOW not only are there size limitations, there are furthermore structural limitations vastly more restrictive than size.
11:54:49 <wli> Olathe: IIRC people are only able to "juggle" 5 or 6 ideas simultaneously, so an indecomposable idea relating as few as maybe 100 ideas should suffice.
11:56:01 <MyCatVerbs> wli: alarming how far off topic we manage to get sometimes. =)
11:56:09 <wli> (One might even be able to make do with an indecomposable idea relating as few as 12 ideas.)
11:56:49 <jsn> or even 7
11:56:57 <SamB> Lemmih: is it customary to put ~/.cabal/bin at the end or the beginning of one's PATH ?
11:57:25 <MyCatVerbs> SamB: start. Same as anything you compile in your home directory.
11:57:37 <Saizan> SamB: yes, unless you use cabal install --global
11:57:46 <MyCatVerbs> SamB: since you want your custom stuff to override what the distro ships by default.
11:57:50 <wli> jsn: 7 might trip over some variability in the capabilities of individuals. I don't know how big the statistical spread is or where the cutoff of "no human being can go beyond this number" is.
11:58:38 <jsn> wli: there might be a fair amount of variation, yeah
11:58:42 <vixey> jsn, I sent you query
11:59:17 <wli> jsn/Olathe: The basic idea here is that not only is the human brain a finite machine with all the limitations implied, it's not even a fully general instance of that.
11:59:23 <chrisdone> I can't tell if the darcs version of xmonad I just upgraded to is slower when switching workspaces or it's a placebo effect
12:00:33 <chrisdone> also can't be arsed going back to the old version so I guess it's not that bad ;)
12:00:53 <chrisdone> or is it faster?
12:01:05 <Peaker> vixey: don't take IRC too personally :P
12:01:05 <chrisdone> oh crap, sod it. nevermind
12:01:32 <Peaker> vixey: btw, I agree make is a horrible piece of software
12:01:47 <SamB> Lemmih: cabal really needs a better way to be informed about compiler installations ...
12:01:53 <Peaker> vixey: there are vastly better build systems, but at least 2 of which that I know are in-house, developed inside companies for their internal builds
12:02:09 <Lemmih> SamB: Oh?
12:02:11 <chrisdone> Peaker: do they check for fortran?
12:02:21 <Peaker> chrisdone: what do you mean?
12:02:39 <chrisdone> Peaker: gotta make sure fortran is there, just in case
12:02:42 <SamB> Lemmih: it shouldn't be necessary to pass *both* the path to the compiler *and* the prefix in which it is installed in order to get it to work ...
12:02:48 <Peaker> chrisdone: they are quite tailored for the needs of the company, but could be made more generic with modest effort. They are also implemented poorly (but work great :-)
12:03:30 <Lemmih> SamB: Huh?
12:03:50 <SamB> naesten@hydrogen:~/hacking/haskell/jhc/lhc/lib/base% cabal install --user --lhc --with-lhc=$(which lhc)
12:03:50 <SamB> cabal: /usr/lib/lhc-0.6/package.conf: openFile: does not exist (No such file or directory)
12:05:23 <chrisdone> Peaker: any news on a semantic editor?
12:05:34 <Lemmih> SamB: Right, I should really fix that bug.
12:06:27 <Peaker> chrisdone: nope, I want to implement it with FRP, which is not yet very mature, and I don't have enough time to put into helping FRP mature
12:06:52 <Peaker> chrisdone: I thought about implementing it imperatively, to at least learn about the UI and other aspects, I might do that
12:07:00 <chrisdone> Peaker: ah, ok
12:07:11 <SamB> Lemmih: hmm ... -fwith-base is silently failing
12:07:15 <SamB> as is the command it runs ...
12:07:25 <Peaker> chrisdone: btw, I was wrong to call it a "semantic editor" (I had my terminology wrong -- as did Jonathan Edwards from which I "copied" the terms) -- its an "abstract syntax editor" that I want
12:07:42 <chrisdone> Peaker: yeah. do you intend on making it console/curses or graphical?
12:08:17 <Peaker> chrisdone: The last attempt/incarnation was SDL/Python based. SDL is pretty horribly slow.  I am considering ncurses and OpenGL
12:08:22 <chrisdone> Peaker: oh, but is John's Subtextual actually editing abstract syntax? it seems more high level than that?
12:08:41 <chrisdone> Peaker: too slow for an editor? :P
12:08:44 <Peaker> chrisdone: Jonathan Edwards is editing abstract syntax, not semantics, yeah (He doesn't realize it, though, I think)
12:08:52 <Lemmih> SamB: Yeah, there are still a few kinks to work out.
12:09:07 <Peaker> chrisdone: Well, our SDL-based editor had nice animations to show what's happening, but it was too slow to be smooth and quick
12:09:11 <chrisdone> Peaker: do you have an example of abstract syntax vs sematics?
12:09:16 <SamB> Lemmih: I wouldn't be nearly as upset if not for the "silently" bit!
12:09:20 <chrisdone> Peaker: oh, right
12:09:55 <Peaker> chrisdone: yeah, f x = x * 2   (*2)   f x = x+x     join (+)     are all different abstract syntaxes for the same-typed function (same semantics)
12:10:12 <SamB> Lemmih: oh, huh.
12:10:24 <SamB> even WITH the prefix it still tries to look at that /usr/lib path ...
12:10:25 <Peaker> chrisdone: You could probably say that the abstract syntax is the "algorithm", where the semantics is the mathematical meaning of the function as an input to output map
12:10:40 <chrisdone> Peaker: why is that "abstract syntax" and not simply "syntax"?
12:10:52 <Peaker> chrisdone: well, that is simply syntax, because its serialized to text, yeah :)
12:11:19 <Peaker> chrisdone: but after you parse it to:   Apply (GetName "join") (GetName "+")   its abstract syntax :)
12:11:35 <chrisdone> Peaker: so those are syntactical constructs that represent abstract syntax
12:11:44 <chrisdone> Peaker: okay
12:12:18 <Peaker> chrisdone: You could say that semantics can be encoded in an infinite variety of ways into abstract syntax, which can then be encoded into textual syntax in another infinite variety of ways.  I want to eliminate the latter stage, but not the former (I believe conal wants to eliminate the former as well)
12:12:19 <chrisdone> Peaker: how would you represent semantics?
12:12:27 <SamB> Peaker: some of those are binders and some of those are just expressions!
12:12:51 <Peaker> SamB: right, sorry :)
12:13:00 <Peaker> I should have used \x -> notation
12:13:30 <Peaker> chrisdone: My editor will edit abstract syntax, not semantics, so it only needs to represent semantics insofar as it is "executing" the code as you edit it
12:13:31 <chrisdone> hm
12:14:06 <SamB> sooo ... what do you call TeXmacs ?
12:14:12 <SamB> (a segfaulting editor?)
12:14:13 <jsn> evil
12:14:17 <chrisdone> I don't know, what do you call TeXmacs?
12:14:43 <Peaker> SamB: I don't know TeXmacs. LyX seems like an abstract syntax editor for documents
12:14:46 <jsn> Terrabytes of Xtra Memory A Constantly Swapping
12:14:53 <jsn> s/A/And/
12:14:56 <jsn> LOLz
12:15:01 <chrisdone> Peaker: is this a bit like editing a html document with a WYSIWG?
12:15:03 <SamB> jsn: s/Swapping/Segfaulting/ ?
12:15:08 <jsn> LOLz
12:15:10 <jsn> yeah
12:15:30 <jsn> poor TeXmacs
12:15:37 <Peaker> chrisdone: Well, "WYSIWYG" typically means specifically an image/print render - which loses a lot of meaningful semantic information.  More like WYSIWYM editor for HTML
12:15:58 <TB|Pat> Someone here speaking german who has time to help a desperate student? Type classes and instances =/
12:16:03 <Peaker> chrisdone: Which tries to encode all semantic information, while losing the "how it will print" view (which can be done separately, of course)
12:16:46 <chrisdone> Peaker: is that separation equivalent to the semantic information and "how it runs"?
12:17:16 <jsn> TB|Pat: i took german in high school
12:17:25 <jsn> i can work with poor english :)
12:17:33 <TB|Pat> *yay*
12:17:35 <TB|Pat> qry?
12:17:43 <Peaker> chrisdone: the separation between what you mean and what you get?
12:17:44 <jsn> ja
12:18:20 <chrisdone> Peaker: yeah
12:18:30 <Peaker> chrisdone: I think so, if I understood what you meant to say
12:18:43 <paper_cc> Peaker: (OT) if there are great build systems with clear principles, why doesn't anyone sit and implement a public one? a la IRIS GL -> OpenGL disclosure?
12:18:45 <conal> Peaker: did you get an answer about Zip vs Applicative?
12:18:51 <vixey> Peaker, scons seems like a better implementation but haven't come across anything fundamentally better
12:18:57 <paper_cc> s/anyone/someone/
12:19:16 <chrisdone> Peaker: well, I don't go telling people what abstract syntax editing is all about because I don't know, so worry not ;-)
12:20:16 <Peaker> paper_cc: There are no "great build systems", just ones "vastly superior to make" :)
12:20:24 <SamB> scons is ... icky looking inside ...
12:20:26 <Peaker> paper_cc: make is so horrible, that being vastly superior does not make you even good :)
12:20:35 <Peaker> conal: Didn't catch one, nope
12:21:06 <SamB> Peaker: funny how that leaves so many of us stuck with make ...
12:21:13 <Peaker> vixey: I think fixing make's fundumental flaws (even more basic flaws than its imperative part being redundant, etc) results in a fundumentally better build system (even if not a great one)
12:21:28 <vixey> I hope so!
12:21:44 <conal> Peaker: if you try to make clear why Zip is redundant, i bet you'll see why it isn't.
12:21:54 <Saizan> Peaker: which are in your opinion the fundamental flaws? the autotools part?
12:22:12 <Peaker> vixey: for example, make does not correctly treat the command line/flags as dependencies to the compilation. It considers target==filename, but when things are compiled multiple times, that assumption may break (unless careful).  The idiomatic make use of recursive makefiles is just plain wrong,  etc
12:22:32 <Saizan> ah, ok
12:22:47 <Arnar> hi all
12:22:58 <Peaker> conal: I guess zip is less expressive than Applicative, so some things may be Zip but not Applicative, is that the reason?
12:23:15 <Arnar> http://hpaste.org/13446 <- any ideas for removing the redundancy between the type Madur and the function getMadur?
12:23:30 <Peaker> conal: Applicative could probably subclass Zip, too
12:23:53 <Arnar> or just within the function (keeping it DRY)
12:24:11 <conal> Peaker: yes, it could, and with a default (<*>).
12:24:22 <paper_cc> Arnar: brr, what does these names mean?
12:24:29 <paper_cc> s/does/do/
12:24:41 <Arnar> paper_cc: Madur = Man/Person
12:24:46 <Arnar> paper_cc: Dagsetning = Date
12:25:02 <Arnar> Kyn = Gender
12:25:13 <Arnar> none of it matters though
12:26:29 <Peaker> conal: wait, if you can define <*> in terms of zip, then only "pure" is the extra expressiveness?
12:26:59 <Peaker> Arnar: you can basically use deriving Data.Binary, iirc
12:27:23 <conal> Peaker: not quite.
12:27:42 <Saizan> Arnar: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
12:27:43 <Arnar> thought that worked only for serialization (not deserializing)
12:27:44 <PeakerLambda> Title: 8.3.�Syntactic extensions, http://tinyurl.com/y6v6by
12:27:51 <Plouj> is James Hague here?
12:27:58 <Peaker> Arnar: That's unlikely, try it out
12:28:16 <Arnar> Peaker: will look into it
12:28:19 <Arnar> Saizan: thanks, this looks useful
12:28:33 <Arnar> have to run, please ping my nick (for highlight) if more
12:28:33 <Saizan> the deriver will use its own binary format
12:28:34 <Arnar> thanks all
12:29:10 <paper_cc> Saizan, so such things are generally impossible without deriving or TH or preprocessor?
12:29:17 <Peaker> conal: oh, now I understand, you can implement <*> with zip and fmap, not just zip, right?
12:29:27 <conal> Peaker: exactly!
12:29:36 <Olathe> 
12:29:43 <Peaker> conal: so the extra expressiveness is fmap and pure
12:29:45 <Olathe> .�
12:29:55 <Olathe> �
12:30:14 <zong_sharo> hi, im need to use some persistent, acceptable performance storage, but i don't want use hdbc
12:30:16 <conal> Peaker: right.  see http://conal.net/blog/posts/more-beautiful-fold-zipping/ for an example (Fold) with pure (I think) and zip but not fmap and (<*>)
12:30:17 <PeakerLambda> Title: Conal Elliott » More beautiful fold zipping
12:30:22 <Olathe> > cycle "�"
12:30:22 <Saizan> paper_cc: "such"? you could also use generics for such instances
12:30:22 <Peaker> conal: btw, is there any type you can think of that is Zip but not Functor?
12:30:23 <PeakerLambda>   "\65533\65533\65533\65533\65533\65533\65533\65533\65533\65533\65533\65533\6...
12:30:25 <zong_sharo> what i can use?
12:30:33 <Olathe> > fun (cycle "�") :: Expr
12:30:34 <PeakerLambda>   �������������������������...
12:30:36 <conal> Peaker: oops -- just answered
12:30:36 <Saizan> paper_cc: like there's gshow and gread
12:30:43 <Peaker> conal: ah, ok, thanks :)
12:30:47 <conal> :)
12:30:58 <Peaker> conal: Yeah, you took the cont part out to WithCont, so its not fmappable anymore
12:31:09 <conal> Peaker: right
12:31:23 <conal> Peaker: to get to the zip essence
12:31:46 <paper_cc> @where gread
12:31:46 <PeakerLambda> I know nothing about gread.
12:31:50 <paper_cc> @index gread
12:31:51 <PeakerLambda> Data.Generics.Text, Data.Generics
12:32:04 <paper_cc> Saizan: thanks
12:32:14 <Peaker> conal: basically, if Applicative is a subclass of Zip (in spirit), we shouldn't have different instances of them, e.g: a ZipList instance for lists and the normal cartesian product Applicative instance for lists
12:32:16 <mpwd> I am programming with continuations right now.  Is there a Monad I ought to understand after I do this the first time the monkey way?
12:32:27 <Peaker> mpwd: there's ContT
12:33:57 <mpwd> Hehe, and here I was thinking State or Reader was the way to go...
12:34:10 <conal> Peaker: good point.  List is an awkward case.  The standard Zip & Applicative instances are incompatible.
12:35:21 <conal> i wonder how the simple list type came to mean backtracking.
12:35:49 <paper_cc> mpwd, also a simple Cont in Control.Monad.Cont
12:35:49 <conal> it's been that way for a long time and was attractive when we had monad comprehensions
12:36:03 <opqdonut> well not backtracking as such
12:36:08 <opqdonut> but one flavour, sure
12:36:26 <opqdonut> nondeterminism would be a better term
12:36:47 <Peaker> conal: I take it that for finite lists to be proper functors/applicatives/monads, the backtracking/cartesian instance is the only valid one
12:36:57 <Peaker> conal: the ZipList instances are all for infinite lists, iiuc
12:37:33 <Peaker> conal: I didn't know Haskell had general monad (not just list) comprehensions... (I joined the Haskell wagon about 8 months ago)
12:38:01 <conal> Peaker: sigh.  haskell 1.4 was lovely.
12:38:22 <opqdonut> :)
12:38:37 <opqdonut> 'em good ole times
12:39:00 <Olathe> > 46^3
12:39:01 <PeakerLambda>   97336
12:39:03 <Peaker> conal: does Haskell 1.4 mean ghc 1.4?
12:39:14 <conal> Peaker: no.  haskell 1.4
12:39:30 <Peaker> conal: before Haskell 98 there was a versioning scheme?
12:39:34 <Cale> yes
12:39:44 <Cale> Haskell 98 is Haskell 1.5
12:39:47 <conal> i think haskell was dumbed down between 1.4 and 98 in order to eliminate some of the mysterious error messages for newbies.
12:39:52 <Cale> yes
12:39:58 <Peaker> monad comprehensions, and what else?
12:40:10 <Cale> Half the prelude was made less polymorphic
12:40:24 <Peaker> is that when fmap and map were separated?
12:40:27 <conal> mappend was (++), mempty was [] (i think), and fmap was map
12:40:29 <Cale> yeah
12:40:29 <opqdonut> 98 and prime are clearly intended to be proper standards for a mainstream language
12:40:37 <Peaker> doh! :(
12:40:42 <Cale> concat :: (Monad m) => m (m a) -> m a
12:40:50 <conal> oh yeah
12:40:54 <paper_cc> =(
12:41:02 <Peaker> I think the right place to de-polymorphize things, is in the coding UI
12:41:04 <vixey> you can get all that stuff back easily
12:41:12 <opqdonut> nicer names for mempty and mappend would probably give monoids more usage
12:41:14 <conal> and sadly, the dumbing down only fixed a slice of the original problem of newbie-friendliness
12:41:19 <Cale> vixey: Not without replacing the base package...
12:41:25 <vixey> oops you can't switch [] in
12:41:39 <Cale> opqdonut: I agree
12:41:47 <mpwd> Cale:  Control.Monad calls it join
12:41:48 <opqdonut> and now we have type system extensions baffling people
12:41:57 <Cale> mpwd: yes, but concat was not the only thing :)
12:42:01 <opqdonut> instead of type errors
12:42:12 <Cale> also, I think concat shouldn't quite have that type
12:42:13 <opqdonut> join is as good a name as concat IMO
12:42:17 <conal> opqdonut: in addition to type errors
12:42:20 <Peaker> conal: if we edited Haskell code with a more Haskell-aware editor, it could help newbies by type-inferring things, and when a specific instance is in use, it could show (.) instead of fmap, or concat instead of join, etc
12:42:28 <opqdonut> conal: well that too
12:42:37 <Cale> concat should be (Monoid m) => [m] -> m, I think.
12:42:40 <Peaker> conal: (newbie friendliness can be an editor thing)
12:42:50 <paper_cc> opqdonut: type errors when using type extensions =)
12:42:51 <conal> Peaker: yeah.  an environmental solution rather than a language thing.
12:42:56 <Cale> join is a good name for the monadic one
12:43:05 <Olathe> > let in dog
12:43:06 <PeakerLambda>   Woof woof !
12:43:19 <Peaker> > let in cat
12:43:20 <PeakerLambda>   Overlapping instances for GHC.Show.Show
12:43:20 <PeakerLambda>                              ([Text...
12:43:21 <opqdonut> :D
12:44:58 <Plouj> ahahah
12:45:08 <chrisdone> > Nothing ++ Just 1
12:45:08 <PeakerLambda>   Couldn't match expected type `[a]'
12:45:22 <chrisdone> no hascale?
12:45:26 <Peaker> conal: have you ever considered the potential for exponential complexity explosion when a rather balanced (time-wise) unamb tree is being computed?
12:45:40 <Peaker> conal: that sounded a bit bad, sorry, I'm pretty sure you have :)
12:45:52 <Cale> chrisdone: The GHC API doesn't/didn't provide a nice way to do qualified imports.
12:46:10 <Peaker> conal: I was wondering if there's a good reason why that's not a problem
12:46:14 <chrisdone> Cale: ah, I see
12:46:57 <Plouj> this isn't exactly haskell related, but more FP in general: http://prog21.dadgum.com/24.html <- this article makes me suspect that writing games in a an FP language like Haskell would mean trying to write a huge finite state automaton (in other words fuctions that transform one state into another)
12:46:59 <PeakerLambda> Title: prog21: Purely Functional Retrogames, Part 2
12:47:36 <wchogg> From my experience it doesn't really feel like that.
12:47:46 <Plouj> and this article makes me think that writing games in an FP language would essentially boil down to writing my own language inside an FP language to manipulate the game world: http://prog21.dadgum.com/25.html
12:47:47 <PeakerLambda> Title: prog21: Purely Functional Retrogames, Part 3
12:48:04 <chrisdone> will haskell' perhaps return to map :: (Functor f) => (a -> b) -> f a -> f b and (++), [], etc.?
12:48:15 <opqdonut> no
12:48:31 <opqdonut> haskell' isn't a saviour or a messiah
12:48:38 <opqdonut> it's a conservative extension
12:48:39 <Plouj> wait, I mean this article for the last sentence: http://prog21.dadgum.com/26.html
12:48:40 <PeakerLambda> Title: prog21: Purely Functional Retrogames, Part 4
12:48:46 <chrisdone> opqdonut: mmkay
12:48:49 <opqdonut> and their wiki has a list of suggestions
12:48:49 <wchogg> Plouj : I've written some small toys in a non FRP environment, and a few using Conal's Reactive library.  Honestly, I think it's really not that difficult to write games in Haskell.
12:48:54 <opqdonut> accepted and refected ones
12:49:04 <chrisdone> opqdonut: for example?
12:49:05 <opqdonut> ?where haskell'
12:49:06 <PeakerLambda> http://hackage.haskell.org/trac/haskell-prime
12:49:10 <Cale> Oh yeah, we used to have   filter :: MonadZero m => (a -> Bool) -> m a -> m a
12:49:15 <opqdonut> http://hackage.haskell.org/trac/haskell-prime/wiki/Status
12:49:18 <opqdonut> see for your self
12:49:20 <PeakerLambda> Title: Status - Haskell Prime - Trac
12:49:27 <Plouj> wchogg: why did you mention FRP?
12:49:37 <chrisdone> Cale: wow
12:49:47 <wchogg> Plouj : Because you're talking about writing games in Haskell?
12:50:00 * Philippa_ still wouldn't want to write big games in haskell
12:50:00 <conal> Peaker: a bit.  compositional use is important to me (as always).  if one really has an exponential number of ways to solve the same problem, things could get costly.  As with any exponential algorithm.
12:50:29 <dons> ?yow
12:50:29 <PeakerLambda> Couldn't find fortune file
12:50:33 <Philippa_> you'd have to pay for encodings of an awful lot of extensible stuff
12:50:33 <Plouj> wchogg: ok, and what's the connection between writing games in Haskell and Functional Reactive Programming?
12:50:35 <dons> ?users
12:50:35 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 32767
12:50:38 <dons> :(
12:50:54 <wchogg> Philippa_ : Heh...maybe not right now.  I think in 6 months to a year it'd be easier.
12:50:57 <dons> Cale: ping?
12:51:00 <dons> lambdabot?
12:51:02 <Philippa_> Plouj: FRP is one sensible way to write the bit in the middle that runs the game as opposed to all the IO (graphics included)
12:51:35 <paper_cc> Philippa_: graphics in FRP?
12:51:40 <opqdonut> http://hackage.haskell.org/trac/haskell-prime/wiki/Prelude  seems nice wrt. redefining stuff
12:51:42 <PeakerLambda> Title: Prelude - Haskell Prime - Trac
12:51:49 <Philippa_> wchogg: I'm not expecting it for the parts I'm worried about. I need to get round to writing a blog post about it spelling out precisely what the problems are
12:51:55 <Cale> Is lambdabot down again?
12:52:05 <conal> and much of  traditional "IO" can be refactored in to mostly functional and a bit of IO, with FRP used for the functional part.
12:52:06 <wchogg> Philippa_ : Can you give me the quick & dirty version?
12:52:15 <paper_cc> Cale: it's still down
12:52:27 <Philippa_> wchogg: you need extensible records and interface queries
12:52:30 <Cale> paper_cc: It went down last night, and I brought it back.
12:52:43 <Peaker> conal: I am not sure, but preliminary thought directs me to think that maybe when you have a large tree it might be better in some cases to not just race them symmetrically, but be biased to try out one thread first for a while, or some such (perhaps alternatives to "unamb" itself)
12:52:44 <Philippa_> as in "are you damageable? Are you a Creature?" etc etc
12:53:13 <paper_cc> Cale: then I've not seen it up then... so
12:53:16 <paper_cc> @botsnack
12:53:16 <lunabot>  :)
12:53:16 <PeakerLambda> :)
12:53:21 <lambdabot> :)
12:53:22 <Philippa_> try coding up a card game like Munchkin (don't worry too much about the  UI), you'll see what I mean
12:53:24 <paper_cc> oops
12:53:28 <wchogg> Philippa_ : Hrmm...yeah, I know what you're talking about.  Ran into a bit of that with my MUD last year.
12:53:32 <conal> Peaker: i think you're right.  fine-grain switching is probably not optimal.
12:53:38 <Philippa_> wchogg: yep. PITA, isn't it?
12:54:19 <Cale> Philippa_: To some extent, you can just use a Data.Map, but it's not ideal.
12:54:21 <dons> ?users
12:54:21 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 32767
12:54:27 <lambdabot> Maximum users seen in #haskell: 581, currently: 581 (100.0%), active: 8 (1.4%)
12:54:44 <dons> 586 is the all time high.
12:54:46 <Philippa_> Cale: right. You're just encoding dynamically-typed OO in Haskell
12:55:24 <wchogg> Philippa_ : Alright, I guess I don't have a good answer for you on that front.  Once some kinks in Reactive are taken care of, I'll probably have to start thinking about it again.
12:55:26 <Philippa_> give or take that you'd probably swap out the map implementation for something more tweaked in the long run it's viable for a lot of things, but you may as well use lua
12:55:55 <Philippa_> wchogg: I've a feeling that the "do you support this /and/ that?" case makes it a research problem
12:56:25 <Philippa_> I also don't know how interesting Oleg would find it :-)
12:57:13 <mpwd_> @src foldl
12:57:13 <PeakerLambda> foldl f z []     = z
12:57:13 <PeakerLambda> foldl f z (x:xs) = foldl f (f z x) xs
12:57:13 <lambdabot> foldl f z []     = z
12:57:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:57:24 <wchogg> Philippa_ : In a way it's a little bit similar to a problem I hit a long time ago when sketching out an OS design in Haskell.
12:57:26 <lucca> hm, they're multiplying
12:57:54 <Philippa_> wchogg: I'm not surprised - there's a lot in common between OSes and game engines
12:57:59 <dons> wchogg: there's been a /lot/ of work (commercially) on OS design in haskell, btw.
12:58:05 <dons> stuff soon to be released...
12:58:37 <Philippa_> dons: cool :-)
12:58:42 <conal> dons: functional or imperative?
12:58:49 <Philippa_> I was wondering if stuff'd disappeared behind NDAs lately
12:58:52 <lucca> hmm, maybe a bot-negotiation protocol where they talk to each other and pick one to be active
12:59:04 <dons> more imperative i think, conal, lots of monadic structure
12:59:12 <dons> Philippa_: hmm. not so much
12:59:26 <Philippa_> or if not NDA then at least not commonly and openly discussed
12:59:35 <Peaker> dons: the House project, or something else?
12:59:45 <Philippa_> glad to know there aren't so many NDAs floating around, then :-)
12:59:54 <dons> House was one branch that was worked on at PSU. that's no the only branch of work.
13:00:12 <dons> Philippa_: there's still NDAs, but we're getting a lot better at open source, you might have noticed
13:00:17 <Philippa_> :-)
13:00:23 <Cale> Philippa_: You wouldn't happen to know enough about the structure of GHC to be able to implement extensible records? :)
13:00:26 <dons> and just releasing stuff in general
13:00:43 <dons> if you keep an eye on hackage, you'll see galois-sponsored openid and windows installers today
13:00:52 <dons> and releases for  the past couple of months of dozens of galois thingies
13:01:01 <Philippa_> Cale: at this point, I don't think implementing them is the hard bit
13:01:09 <Cale> Philippa_: what is?
13:01:12 <conal> dons: hurrah for sharing!
13:01:13 <Philippa_> consensus
13:01:17 <vixey> I think adding any feature to GHC is hard ...
13:01:27 <Cale> Philippa_: What if we neglect that problem and just implement something good?
13:01:27 * Philippa_ has an idea there which may be a little tricky to articulate in enough detail for SPJ et al...
13:01:46 <dons> yeah, the world is better off with more haskell code out there :)
13:01:56 <Cale> Have you heard what I think it should look like?
13:01:57 <Philippa_> Cale: then we probably doesn't include me right now, sadly. I'm good for ideas, bad for code :-)
13:02:03 <Philippa_> I haven't specifically
13:02:21 * Philippa_ would rather sugar a sensible encoding of row kinds and a few related bits and pieces
13:02:30 <Philippa_> then you can just do whatever and let the simplifier fix the mismatch
13:03:13 <dons> :)
13:03:18 <Cale> Okay, my idea is something like Daan's earlier proposal for first class record labels, but have functions which extract the relevant operations from the labels (rather than add lots of new syntax)
13:03:53 <Cale> We can use names starting with single quotes to syntactically distinguish record labels.
13:04:09 <Philippa_> Cale: people'll want equivalents to the current record operations
13:04:10 <Cale> So it would end up looking something like  get 'myField myRecord
13:04:22 <Philippa_> update, pattern-matching etc
13:04:53 <Cale> I agree about pattern matching.
13:04:56 <opqdonut> Cale: first-class fields is a nice hack
13:05:03 <opqdonut> esp. with view patterns
13:05:09 <Cale> I think update is probably better served with a plain function from labels to functions
13:05:23 <paper_cc> Philippa_: and now non-existing record operations like (\foo x = foo{bar=x})
13:05:34 <Philippa_> Cale: nearly, update does the big letrec version
13:05:34 <paper_cc> s/x = /x ->/
13:05:47 <Cale> Philippa_: hm?
13:06:16 <Philippa_> you can calculate all the new fields at once based on the old ones, it's not simple composition
13:06:25 <Cale> ah, okay
13:07:17 <Cale> I'd also like to have variants that use these labels, and a pattern matching for them too.
13:07:24 <Philippa_> likewise
13:07:42 <chrisdone> oh, nice. I just read about GADTs
13:08:01 <Cale> We'd have something like  'fieldName :: ('fieldName :: Label)
13:08:14 <Cale> So it needs a new kind.
13:08:28 <phercek> Does anybody know why is ghc 6.10.1 still in testing repository in archlinux?
13:09:31 <Cale> Well, we'd also have a kind for rows.
13:10:17 * vixey has an idea :P a haskell compiler that is written in less than a billion lines of code
13:10:41 <lucca> ghc is very small, considering.
13:10:51 <Philippa_> vixey: a "better-factored GHC in modern haskell" project might not be a silly idea, I'll grant
13:11:07 <vixey> maybe I am naive to think this, but shouldn't a haskell compiler be concise, elegant... _hackable_
13:11:13 <pumpkin> what's the license on ghc?
13:11:26 <pumpkin> @botsnack
13:11:26 <lunabot>  :)
13:11:26 <lambdabot> :)
13:11:26 <mahogny> modern haskell... I see a chance you will get stuck on endless discussion which types will be correct :P
13:11:51 <opqdonut> Philippa_: isn't jhc a bit like that?
13:12:15 <vixey> Philippa_, I suppose something like that can't really fly until Haskell' gives simpler specifications for the weird extensions though
13:12:17 <Philippa_> opqdonut: not really. It's very much its own compiler
13:12:22 <opqdonut> yeah
13:12:27 <Philippa_> I meant a GHC-in-modern-haskell, not just a haskell compiler
13:12:28 <opqdonut> but at least it's supposed to be clear and moder
13:12:33 <opqdonut> AIUI
13:12:33 <SamB> jhc's frontend leaves something to be desired
13:12:44 <vixey> I skimmed JHC and I don't really like what I see :/
13:13:19 <nolrai_East> @unmtl ReaderT env (Writer s) a
13:13:19 <lambdabot> env -> (a, s)
13:13:59 <SamB> well, the whole thing could use a great deal of work
13:14:14 <SamB> but it's not as bad once the code is in E
13:14:26 * Philippa_ would expect the project she has in mind to do things like use parser combinators, a constraint-based type inference system, stuff like that
13:14:31 <wchogg> vixey : I think you just hate Haskell compilers :p
13:14:38 <vixey> wchogg, pretty much!
13:14:45 <Philippa_> that said, one of the things that keeps GHC's typechecker big is making sure it gives good errors for sugar too
13:14:55 <SamB> perhaps we should redesign the language to make the compilers prettier ?
13:15:00 <Philippa_> heh
13:15:03 <vixey> SamB: Nice idea! :p
13:15:07 <SamB> I'm actually not kidding
13:15:20 <vixey> SamB: Have you seen Epigrams 2s (partial) implementation?
13:15:26 <SamB> vixey: not really
13:15:30 <Cale> SamB: Something closer to Omega perhaps?
13:15:37 <vixey> SamB, some funny black magic goes on there
13:15:39 <SamB> Cale: in what way ?
13:15:58 <Cale> SamB: Well, it's more uniform in its treatment of types and kinds
13:16:17 <SamB> does it have typeclasses ?
13:16:25 <wchogg> I think it does, actually.
13:16:27 <vixey> no typeclasses in Omega
13:16:38 * ddarius noticed today that the Eilenberg-Moore algebras for the Reader monad have the same type (but limiting laws) as the continuation monad.
13:16:43 <SamB> that's no good then
13:16:48 <Cale> No, but I'm not quite advocating we switch to Omega :)
13:16:48 <SamB> we can't boot the typeclasses!
13:17:00 <vixey> we can certainly get rid of typeclasses SamB
13:17:15 <SamB> vixey: but we'd need to change the name then
13:17:26 <SamB> also, what would we do with all of this code ?
13:17:33 <vixey> delete it!
13:17:41 <wchogg> Why get rid of typeclasses?
13:17:41 <SamB> all those blog entries ?
13:18:09 <Cale> SamB: There's no need for the future to be compatible with the present :)
13:18:14 <SamB> hmm, I guess we should hold off until verne rejoins freenode ?
13:19:11 <Cale> SamB: After all, contemporary Haskell compilers exist...
13:19:58 <SamB> who would believe that it was, in fact, Haskell ?
13:20:10 <Cale> Haskell is whatever we make it :)
13:20:17 <opqdonut> what source can i cite with "with lazy evaluation (and thus in ghc) a monomorphic name get's evaluated at most once"
13:20:22 <SamB> It might be more than reddit could bear
13:20:27 <opqdonut> woops, *gets
13:20:29 <saml> ghc-6.8.2: internal error: loadObj: can't map `/usr/lib/ghc-6.8.2/lib/base-3.0.1.0/HSbase-3.0.1.0.o'    i get these a lot
13:20:34 <opqdonut> or is that even strictly true in ghc
13:20:35 <vixey> opqdonut, I'm not sure that is exactly the same thing
13:20:57 <vixey> opqdonut, because it's just non-strict, like it doesn't -have- to be lazy (couldn't say which cases though)
13:21:13 <SamB> opqdonut: well, for starters, that isn't true anymore
13:21:22 <opqdonut> SamB: as I suspected
13:21:23 <aboyz> is haskell a programming lanague?
13:21:33 <Cale> aboyz: yes
13:21:34 <saml> aboyz, yes
13:21:42 <paper_cc> @faq is haskell a programming lanague?
13:21:42 <lambdabot> The answer is: Yes! Haskell can do that.
13:21:44 <opqdonut> vixey: yeah the report isn't very sepcific on that
13:21:45 <aboyz> widely used now??
13:21:49 <SamB> opqdonut: at most once *per core*
13:21:55 <vixey> aboyz: yes
13:21:55 <saml> aboyz, yes
13:22:00 <Cale> aboyz: Depends what you mean by "widely".
13:22:09 <Cale> aboyz: It's big enough that it's not going away
13:22:12 <aboyz> can you name some major company that is using it?
13:22:18 <saml> aboyz, gaios
13:22:23 <vixey> aboyz, Microsoft
13:22:26 <Cale> That would be Galois
13:22:32 <saml> aboyz, lindose
13:22:37 <aboyz> wow cool.. i'll study on it :)
13:22:43 <SamB> microsoft doesn't really *use* Haskell, does it ?
13:22:46 <Peaker> dons: is the commercial OS work in Haskell related to House, or is it a separate project?
13:22:49 <SamB> I thought they only paid for it ...
13:23:01 <Cale> Microsoft *Research* is helping develop Haskell.
13:23:03 <saml> there's one guy who uses haskell on ubuntu in microsoft
13:23:04 <wchogg> Also, does it really matter if a 'major' company uses it?  What if a bunch of successful small companies do?
13:23:16 <Cale> But MSR is to Microsoft what PARC is to Xerox
13:23:17 <saml> he uses comic ms font too
13:23:20 <aboyz> is haskell like which other lanague??
13:23:28 <cjb> aboyz: No.
13:23:29 <cjb> :)
13:23:35 <SamB> Xerox PARC ...
13:23:40 <SamB> Microsoft MSR ...
13:23:41 <aboyz> cjb? why NO
13:23:44 <Elly> what?
13:23:47 <Cale> aboyz: It's similar to Clean, a little close to ML/SML/O'Caml
13:23:49 <SamB> hmm, doesn't *quite* have the same ring to it ;-P
13:23:49 <cjb> aboyz: well, it's very different
13:23:59 <Elly> haskell is like SML
13:24:01 <Cale> aboyz: It's a descendant of a language called Miranda
13:24:03 <lucca> samb: nope, but that Is an interesting comparison
13:24:06 <Elly> except for laziness, monads, and typeclasses
13:24:10 <EvilTerran> SamB, i didn't know MSR had a dept of redundancy dept :P
13:24:17 <saml> wow i can't really build llvm. it sometimes quits during ./configure
13:24:19 <lucca> aboyz: it's ML done right.
13:24:21 <aboyz> I need to read up on haskell!..
13:24:22 <Elly> it has destructuring-bind from prolog and ML
13:24:36 <saml> ramdom quits with ghc-6.8.2: internal error: loadObj: can't map  /some/random/.o
13:24:36 <vixey> Elly, what?!
13:24:44 <Elly> vixey: what!?
13:24:50 <vixey> Elly, ITYM Lisp
13:24:51 <Cale> vixey: I think Elly is referring to pattern matching.
13:25:04 <SamB> I think one big difference between PARC and MSR is that, without Microsoft, MSR is just R
13:25:08 <vixey> Prolog doesn't have _matching_
13:25:24 <Cale> vixey: Well, it has unification, which is more general :)
13:37:15 <SamB> vixey: yeah, unification can be used to accomplish destructuring bind, didn't they tell you ?
13:37:15 <Elly> vixey: I mean pattern matching
13:37:15 <Elly> I think of it as destructuring-bind :P
13:37:15 <Elly> prolog certainly does have pattern matching
13:37:15 <vixey> :(
13:37:15 <saml> @loadObj
13:37:15 <lambdabot> Unknown command, try @list
13:37:15 <Elly> length(z,[]). length(s(X),[_|Xs]) :- length(X,Xs).
13:37:15 <saml> is loadObj haskell function?
13:37:28 <EvilTerran> SamB, isn't "do these expressions unify? give an assignment if so" a super-problem of "does this pattern match this value? give an assignment if so"?
13:37:28 <Cale> saml: maybe something internal to GHC.
13:37:28 <Cale> saml: It sounds like your GHC install is somehow broken or you've stumbled on a big.
13:37:28 <Cale> bug*
13:37:28 <Raevel> i've listed a module in Build-Depends in my cabal file, and "ghc-pkg list" shows that module, but configure says it's missing, what could i be missing?
13:37:28 <saml> too much suspense building llvm binding. it almost built all
13:37:28 <SamB> Cale: or maybe he just lacks RAM ?
13:37:28 <Cale> Raevel: It could be in the wrong package.conf?
13:37:28 <Cale> SamB: Oh, given the message, perhaps.
13:37:28 <Cale> Raevel: Things which are to be installed globally can't make use of packages installed as user.
14:02:48 <Raevel> Cale: oh, i see, i'll look into that, thanks
14:02:48 <saml> i have 287/1840MB ram
14:04:49 <Arnar> are there any bad effects by using -XTypeSynonymInstances? (sorry if msg was posted twice)
14:04:49 <Raevel> okay, it seems the module was only installed for my user, how can i make the module global, or how can i install my own cabal package locally?
14:04:49 <mercury^> Will ghc transform "if n > m then f (n-m) ..." to "if n-m > 0 then f (n-m) ..."?
14:04:49 <lucca> errr, > doesn't depend on things being numeric
14:04:49 <lucca> consider n, m :: String
14:04:49 <lucca> oh wait, nm, didn't see yer then
14:04:49 <Cale> mercury^: Why would it?
14:04:49 <Peaker> who is pairwise?
14:04:49 <Cale> Raevel: the default should be to install locally...
14:04:49 <Cale> Raevel: unless perhaps if you're sudoing the cabal command.
14:04:49 <mercury^> Cale: because for large integers, mpz_cmp_ui should be much faster than mpz_cmp
14:04:49 <Raevel> Cale: tried it with and w/o sudo
14:04:49 <Cale> Raevel: hmm
14:04:49 <Cale> Raevel: cabal install --user
14:04:49 <Cale> mercury^: Okay. In any event, I doubt it would transform that -- especially if it's polymorphic.
14:04:49 <Raevel> oh, i was doing runghc Setup
14:04:49 <Peaker> mercury^: I don't think its that common/interesting for ghc to notice that (n-m) can be shared there, and I don't see any other reason to do this
14:04:49 <Peaker> mercury^: if (n-m) is not shared, its not necessarily an optimization
14:04:49 <Cale> Raevel: okay... if you don't have the cabal program, you can get it from Hackage.
14:04:49 <Raevel> i do
14:04:49 <mercury^> Peaker: it's slower in that case.
14:04:49 <Cale> You can write  let x = n-m in if x > 0 then f x else ...
14:04:49 <chrisdone> @hoogle fromString
14:04:49 <lambdabot> Data.String fromString :: IsString a => String -> a
14:04:49 <lambdabot> Distribution.InstalledPackageInfo FromString :: String -> Maybe LineNo -> PError
14:04:49 <lambdabot> Distribution.ParseUtils FromString :: String -> Maybe LineNo -> PError
14:04:49 <Cale> However, x > 0 probably won't do anything different from x > 5
14:04:49 <Peaker> mercury^: Due to laziness and the polymorphic nature of (-), its not clear that computing (n-m) first and keeping it in memory until f actually uses it (which may be much later!) is a win
14:04:49 <Raevel> cabal install --user gave mea few permission denied's, but sudo:ing it worked! so thank you again
14:04:49 <Peaker> Cale: if x::Int, it might be a tad faster down at the assembly level
14:04:49 <Cale> I think he's interested in the Integer case.
14:04:49 <mercury^> For Ints it should be exactly the same.
14:04:49 <lucca> Peaker: most archs have a single-op compare
14:04:49 <Peaker> mercury^: afaik, ghc tries not to maximize sharing, as the memory/runtime trade off is a complicated one, its delegated to the programmer which can name it to share it, or re-compute it to not share it
14:04:49 <mercury^> Peaker: I see.
14:04:49 <Cale> Raevel: no problem... you might want to check out and make sure that your ~/.cabal directory and all its contents are owned by your user
14:04:49 <vixey> whp don't haskell compilers do subexpression elimination?
14:04:49 <Cale> vixey: Because it's not always an optimisation
14:04:49 <Peaker> vixey: whp?
14:04:49 <vixey> (would have to be type directed I guess)
14:04:49 <vixey> Cale, can it possible make things worse?
14:04:49 <Cale> vixey: yes, it can result in space leaks.
14:04:49 <Peaker> lucca: I am not sure, but maybe x > 0 is "faster" in some cases than x > y  (in Intel, TEST EAX,EAX  may be faster than loading another register and using CMP EAX, EBX or such)
14:04:49 * wli mutters something about peephole optimizers being the appropriate way to deal with the low-level CSE/etc.
14:04:49 * shapr hugs vixey
14:04:49 <vixey> hi shapr *hug*
14:04:49 <lucca> Peaker: I suspect cycle-count difference would be lost in the noise of cache response times for icache versus dcache... close in either case :p
14:04:49 <Arnar> is there a way to make Data.Binary.Binary derivable? I mean, for a mortal man like myself..
14:04:49 <pumpkin> yup
14:04:49 <Arnar> any ptrs?
14:04:49 <Peaker> lucca: Yeah, disclaimed it with "may be", I don't pretend to deeply understand micro-optimization on Intels :)
14:04:49 <saml> where is Data.Binary?
14:04:49 <Peaker> vixey: if cpu cycles are cheap, and memory is scarce - you might want to throw away those memoized fibs, and recompute them later when you need them
14:04:49 <saml> ah nevermind
14:04:49 <Arnar> @docs Data.Binary
14:04:49 <lambdabot> Data.Binary not available
14:04:49 <vixey> Peaker, but there's no shared subexpressions in fibs
14:04:49 <Peaker> vixey: assume fibs itself is the shared subexpression
14:04:49 <vixey> huh.....
14:04:50 <Peaker> vixey: let fibs = computeFibs args in blah fibs : bleh fibs   is not clearly better than blah (computeFibs args) : bleh (computeFibs args)
14:04:50 <British0zzy> is there a library that will give me a list of random values between -1 and 1?
14:04:50 <Peaker> @hoogle random
14:04:50 <lambdabot> package random
14:04:50 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
14:04:50 <lambdabot> module System.Random
14:04:50 <vixey> I don't understand why it is not better
14:04:50 <British0zzy> cool, thanks
14:04:50 <saml> Arnar, did you try -XGeneralizedNewtypeDeriving?
14:04:50 <vixey> British0zzy, specifically, randoms
14:04:50 <Arnar> saml: ah, no - hang on
14:04:50 <saml> that might jsut workout. i ccan't test  it because i don't have binary package
14:04:50 <Peaker> vixey: because maybe the value of blah is used for a while, then a long while later, the value of bleh is used.  In that long pause, it might make sense to get rid of the memoized fibs and recompute them again when bleh needs them again
14:04:50 <rwbarton> Arnar: what are you trying to do?
14:04:50 <Arnar> saml: nope, doesn't cut it
14:04:50 <Peaker> vixey: because memory is scarce, and cpu is cheap
14:04:50 <Arnar> rwbarton: specify an ADT with one value ctor and all fields are instances of Binary
14:04:50 <vixey> Peaker, ah I see
14:04:50 <rwbarton> Arnar: look at the derive package
14:04:50 <Arnar> rwbarton: I'd like the ADT to be Binary by default, just concatenating all the fields
14:04:50 <Arnar> rwbarton: ok, thanks
14:04:50 <IWannaLog> Hi
14:04:50 <vixey> Peaker, I wonder if it is good to think about garbage collection
14:04:50 <IWannaLog> Is there a way to catch a head on an empty list ?
14:04:50 <vixey> IWannaLog: instead of head, I think it's better to use a different function, which gives different results when the list is empty
14:04:50 <Cale> IWannaLog: There is a way to catch that exception from IO if you're really careful, but really, you shouldn't use head at all if there's any possibility the list will be empty.
14:04:50 <Peaker> vixey: I think a monsterous RTS that uses GC/memory access information, generally profiles things statistically or otherwise, keeps around more information on each value, and then uses heuristic decisions based on all this data about when its better to keep a value around for re-use, and when to throw it away (and convert it back to a thunk)
14:04:50 <IWannaLog> vixey: Yes I know but I imagine haskell in industry, many developpers on one project, and silly developpers using head (and other dirty function which must have not be implemented)
14:04:50 <vixey> Peaker, that's JIT?
14:04:50 <Peaker> vixey: I guess you could call it a JIT
14:04:50 <vixey> IWannaLog: they should use Java? idk what you mean
14:04:50 <chrisdone> :t listToMaybe
14:04:50 <lambdabot> forall a. [a] -> Maybe a
14:04:50 <Olathe> > listToMaybe [1..]
14:04:50 <lambdabot>   Just 1
14:04:50 <Cale> IWannaLog: The solution is to fix the broken code. Calling head on an potentially empty list is similar to dereferencing a potentially null pointer, or going into an infinite loop.
14:04:50 <chrisdone> > fromMaybe 0 $ listToMaybe []
14:04:50 <lambdabot>   0
14:04:50 <chrisdone> > fromMaybe 0 $ listToMaybe [1]
14:04:50 <lambdabot>   1
14:04:50 <Olathe> @src fromMaybe
14:04:50 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
14:04:50 <Philippa_> Cale: note that null pointers are a case that we seek to eliminate in new languages..
14:04:50 <chrisdone> fromMaybe = flip id maybe
14:04:50 <chrisdone> uh
14:04:50 <IWannaLog> I know all of that, but imagine there is a developper who use it, and i want in the main loop catch it send me a mail and slap the developper
14:04:50 <chrisdone> flip maybe id
14:04:50 <dons> IWannaLog: you can catch the exception if you need to
14:04:50 <Cale> Philippa_: Yes, but Haskell doesn't seek to fix all potential bugs.
14:04:50 <IWannaLog> dons: How ?
14:04:50 <Twey> :t maybe
14:04:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:04:50 <dons> using Control.Exception.catch
14:04:50 <Cale> IWannaLog: using Control.Exception.evaluate and Control.Exception.catch
14:04:50 <Philippa_> Cale: there's still a reasonable argument for not wanting head in the prelude!
14:04:50 <IWannaLog> I try it
14:04:50 <Twey> IWannaLog: See for example the Safe module
14:04:50 <Cale> Philippa_: agreed :)
14:04:50 <chrisdone> > Just "hello " `mappend` Just "world"
14:04:50 <lambdabot>   Just "hello world"
14:04:50 <Cale> head and tail are not so nice.
14:04:50 <vixey> It would be fun to get a Prelude together from #haskell
14:04:50 <Twey> I think that head should be headDef by default, personally
14:04:50 <Olathe> @let main = print "Hello"
14:04:50 <Philippa_> see also, haskell getting unsafeHead...
14:04:50 <lambdabot>  Defined.
14:04:50 <Olathe> > main
14:04:50 <lambdabot>   * Exception: "<IO ()>"
14:04:50 <vixey> I never ever use the normal Prelude but /a/ Prelude seems like a good idea
14:04:50 <chrisdone> I ❤ mappend
14:04:50 <IWannaLog> head tail fromJust etc... are bad functions, yes
14:04:50 <Peaker> vixey: according to what I heard a bit before, the Haskell 1.4 Prelude was great :(
14:04:50 <IWannaLog> but they exist
14:04:50 <chrisdone> vixey: do you re-export map/++, Data.Foldable, etc?
14:04:50 <vixey> (that's a lie I sometimes do use it but not in actual programs)
14:04:50 <saml> > print (head []) `catch` (\e -> print "lol")
14:04:50 <lambdabot>   * Exception: "<IO ()>"
14:04:50 <Cale> Peaker: it was a lot better, but it still wasn't ideal
14:04:50 * chrisdone is trying that at the moment
14:04:50 <Twey> Well, of course they should exist because sometimes there really will be a case where it couldn't possibly fail
14:04:50 <Twey> You don't want to have to make cases for things that will never happen
14:04:50 <Philippa_> and then you can write out the pattern match yourself
14:04:50 <British0zzy> does anyone know why i am getting this error? http://hpaste.org/13448
14:04:50 <Peaker> Cale: Were there semantic incompatibilities/extensions between 1.4/1.5, or just syntactic/library changes?
14:04:50 <Cale> Twey: exist, but maybe not in the Prelude?
14:04:50 <Philippa_> preferably not in Data.List either, though
14:04:50 <saml> > let head [] = []; head l = Prelude.head l in head []
14:04:50 <lambdabot>   []
14:04:50 <Cale> Peaker: there were both
14:04:50 <Philippa_> Data.List.IShouldBeShotForUsingThis, perhaps
14:04:50 <vixey> > :t let head [] = []; head l = Prelude.head l in head
14:04:50 <Twey> Cale: Quite
14:04:50 <lambdabot>   <no location info>: parse error on input `:'
14:04:50 <Cale> Peaker: Haskell 98 was mostly a simplification though, and took steps backwards in many areas.
14:04:50 <vixey> :t let head [] = []; head l = Prelude.head l in head
14:04:50 <Twey> Or just with names like unsafeHead, unsafeTail, &c.
14:04:50 <lambdabot> forall a. [[a]] -> [a]
14:04:50 <chrisdone> vixey: can you paste your alt. prelude if you have one? I'm interested to see what other people tend to use
14:04:50 <Twey> (maybe not 'unsafe' since that's mostly used for unexpected IO)
14:04:50 <Peaker> how about adding "unsafe" prefix to all non-exhaustive pattern matching functions?  Or maybe nonExhaustiveHead? :-)
14:04:50 <vixey> Twey, unsafeFix?
14:04:50 <rwbarton> This is all a bit ridiculous... ==vixey
14:04:50 <Cale> hehe
14:04:50 <rwbarton> "Can I catch an infinite loop?  Sometimes bad programmers write them..."
14:04:50 <saml> > let head :: [a] -> a; head [] = []; head l = Prelude.head l in head []
14:04:50 <vixey> rwbarton, what's ridiculous?
14:04:50 <lambdabot>   Couldn't match expected type `a1' against inferred type `[a]'
14:04:50 <saml> ah i see i'm so stupid
14:04:50 <pumpkin> safeHead
14:04:50 <Cale> head is just something we mostly want to keep away from total beginners.
14:04:50 <pumpkin> you know, with the LaTeX
14:04:50 <vixey> Cale, *lol
14:04:50 <vixey> Cale, "total" beginners
14:04:50 <Twey> All non-exhaustive functions are
14:04:50 <Peaker> how about  head = listToMaybe ?
14:04:50 <Cale> Once you know the language, you know enough to use pattern matching.
14:04:50 <Peaker> @type listToMaybe
14:04:50 <rwbarton> vixey: as you point out with "unsafeFix", we aren't going to eliminate programming errors by hiding head.
14:04:50 <lambdabot> forall a. [a] -> Maybe a
14:04:50 <IWannaLog> Why not give a switch to ghc to failed if it see some bad functions
14:04:50 <chrisdone> Peaker: seems reasonable
14:04:50 <vixey> rwbarton, *nod*
14:04:50 <Cale> But head is still convenient for those cases where you know the list *must* be nonempty.
14:04:50 <chrisdone> Peaker: actually seems like it should always have been
14:04:50 <Cale> Or you don't care about the program dying if it is empty.
14:04:50 <vixey> I wish I could make up syntax like  []+
14:04:50 <chrisdone> Cale: pretty sure "find" would be convenient for when you *know* a list has an item
14:04:50 <vixey> for non empty lists
14:04:50 <Peaker> chrisdone: on second thought, it doesn't achieve the main purpose one used head for, to get actual access to the value. But using maybe or fromMaybe on a Maybe is easier than using foldr on a list just for its head
14:04:50 <Cale> chrisdone: What, like  find (const True)
14:04:50 <vixey> maybe coerce :: [a]+ -> [a]; coerce = id too
14:04:50 <paper_cc> Peaker: fromMaybe is, again, a non-exhaustive function
14:04:50 <Peaker> chrisdone: maybe names can be given to  fromMaybe/maybe . listToMaybe
14:04:50 <Philippa_> chrisdone: the unsafe/assuming version should never get to occupy the 'nice' part of the namespace though
14:04:50 <Cale> paper_cc: You're thinking of fromJust
14:04:50 <vixey> paper_cc, maybe you're thinking about fromJust?
14:04:50 <chrisdone> Cale: I mean if head :: [a] -> a, why not find (a -> Bool) -> [a] -> a
14:04:50 <paper_cc> Cale: vixey: right :/
14:04:50 <Philippa_> which perhaps should be called assumeJust?
14:04:50 <mmorrow> andyjgill: ping
14:04:50 <andyjgill> hi.
14:04:50 <preflex>  andyjgill: you have 1 new message. '/msg preflex messages' to read it.
14:04:50 <Peaker> Philippa_: hmm, maybe something like:   fromJust e = fromMaybe (error e) ?
14:04:50 <chrisdone> Cale: seems consistent to me that head :: m a -> m a
14:04:50 <Peaker> Philippa_: force the programmer to think about the Nothing case
14:04:50 <chrisdone> Cale: err [a] -> Maybe a
14:04:50 <andyjgill> Ahh. Yes. I've changed this, and will update a new version this week that will run through haddock.
14:04:50 <andyjgill> Thanks!
14:04:50 <Philippa_> Peaker: it may shock you to hear this, but many coders don't use source as their primary documentation
14:04:50 <mmorrow> andyjgill: no problem. KURE looks great.
14:04:50 <chrisdone> Cale: don't you think?
14:04:50 <Peaker> Philippa_: prosecute them in the DRY court :-)
14:04:50 <Cale> chrisdone: Well, perhaps, but that doesn't agree with most of my uses of it.
14:04:50 <British0zzy> i do not know why i am getting this error: http://hpaste.org/13448. is it a bug in ghci? i have libgsl installed.
14:04:50 <Philippa_> Peaker: no. DRY is /not/ appropriate regarding source+docs together
14:04:50 <Cale> chrisdone: When I use head, I use it to indicate that I'm taking responsibility for proving that the list is nonempty.
14:04:50 <Olathe> When I use head, I use it to indicate I really need to go.
14:04:51 <chrisdone> Cale: do you extend this reasoning to use of fromJust?
14:04:51 <Philippa_> having separate notions of interface and implementation is still important
14:04:51 <Cale> chrisdone: yeah
14:04:51 <Cale> chrisdone: So it's just moving the problem around.
14:04:51 <IWannaLog> could someone have a look and tell me why the exception is not catched please http://hpaste.org/13449
14:04:51 <Cale> But I agree that head isn't the sort of function which you should use all over the place.
14:05:27 <IWannaLog> There is no reason to use head, but maybe in future, this kind of function will be correctly typed
14:05:40 <IWannaLog> and we will can use it safely
14:05:47 <Heffalump> IWannaLog: laziness
14:05:49 <Peaker> Philippa_: I believe DRY is important everywhere, but the reasons are basically my experience with the common programmer's nature -- which is obviously a subjective experience
14:05:52 <Heffalump> you need to force the result at some point
14:06:00 <Heffalump> and at some point that is inside the scope of the catch
14:06:01 <IWannaLog> evaluate ?
14:06:12 <Heffalump> evaluate always confuses me, but perhaps
14:06:27 <Cale> IWannaLog: There is a decent reason. It's when you want to tell the compiler that you guarantee the list to be nonempty.
14:06:29 <IWannaLog> but thx
14:06:32 <Heffalump> though since you also ignore the Writer result, that might not work either
14:06:54 <Heffalump> because something has to force the result from the outside in, and your entire Writer computation is redundant as things stand.
14:06:59 <Cale> There will always be some lists whose nonemptiness will not be easy enough for the compiler to prove.
14:07:19 <IWannaLog> A list is never garanted to be empty (many developpers => hostile environment)
14:07:26 <Heffalump> oh, though the IO computation might be forced ok
14:07:41 <vixey> in lambda calculus,,, and I guess it's a notion in rewriting in general... does contextual closure [R] (of a relation R) mean roughly,   m R m' --> m n [R] m' n   and n R n' --> m n [R] m n'  and  b R b' --> \x -> b[x] R* \x -> b'[x] ?
14:07:42 <Cale> IWannaLog: It can be guaranteed to be nonempty in a large number of circumstances.
14:08:04 <IWannaLog> Cale: no sometimes there ar magic things
14:08:11 <vixey> (or it's called something other than contextual closure?)
14:08:25 <IWannaLog> or a developper comes after you and the list could become empty and he didn't see head
14:08:49 <IWannaLog> Only the type system protect you
14:09:12 <chrisdone> Cale: I agree it's useful for convenience, like fromJust. I think very quickly from a newbie I was defining head' a lot, which was basically (\x -> fromMaybe x . listToMaybe). I think Haskell just gives you a mindset of hating possible bugs due to things like that
14:09:15 <Philippa_> Peaker: you effectively just made a religion of never having fast, specialised implementations
14:09:59 <saml> IWannaLog, what do you want to do for head [] ? what should it return?
14:10:05 <Cale> IWannaLog: While I agree that the type system is a great way to protect you from such failures where possible, it's not always possible to do so.
14:10:09 <IWannaLog> Unsafe a
14:10:09 <saml> let's say you catch it, what do you want to do?
14:10:25 <saml> @hoogle Unsafe
14:10:26 <IWannaLog> where Unsafe is a very special Monad (not a Either Exception a)
14:10:26 <lambdabot> module Data.ByteString.Unsafe
14:10:26 <lambdabot> module System.IO.Unsafe
14:10:26 <lambdabot> Language.Haskell.TH Unsafe :: Safety
14:10:48 <IWannaLog> and the compiler remplace it like it was not a monad and throw exception when needed
14:10:57 <chrisdone> Cale: summarising, there's clearly good reason to use it, but I think disliking it is a side-effect of a healhy attitude of eradicating potential bugs, no?
14:11:05 <IWannaLog> but head :: [a] -> a is bad typed
14:11:10 <Peaker> Philippa_: I don't think a "specialized implementation" violates DRY - it adds new information (namely, the new implementation).  If it repeats information from other specialized implementations then those should probably be shared to avoid DRY violations
14:11:20 <rwbarton> IWannaLog: So is fix id, etc., etc.
14:11:22 <Cale> IWannaLog: It's not badly typed.
14:11:29 <rwbarton> IWannaLog: (I mean, by your logic)
14:11:40 <Peaker> Philippa_: but I do think DRY should apply to docs as well as source code.  Even when the doc is "right there" next to the code (e.g: in comments) developers tend to not update that (IME)
14:11:40 <Cale> You can do similar things while having exhaustive pattern matching.
14:11:42 <Cale> Consider...
14:11:43 <chrisdone> Cale: (and Haskell makes it easy for us to have that attitude)
14:11:50 <rwbarton> IWannaLog: It sounds like you want a language without _|_
14:11:50 <Cale> head [] = head []
14:11:53 <Cale> head (x:xs) = x
14:11:55 <IWannaLog> I don't understand how head can return something else than a valid value
14:11:58 <Peaker> Philippa_: Hey, just today I encountered out-of-date comments when reading the lambdabot PL code
14:12:08 <Cale> Do you wan the compiler to stop that one too?
14:12:18 <Cale> want*
14:12:18 <Philippa_> yeah. There's a really good answer to that for interface-level changes though
14:12:19 <IWannaLog> rwbarton: why not but not today
14:12:22 <vixey> IWannaLog: Have you seen this   pinkElephants = pinkElephants  now :t pinkElephants :: forall a. a
14:12:36 <Cale> IWannaLog: Eventually, it comes down to having the compiler prove that all your programs terminate.
14:12:42 <Philippa_> which is to make changing the interface on an existing module, function etc a big deal
14:12:52 <IWannaLog> Cale: it's future
14:13:04 <pumpkin> o.O
14:13:08 <Olathe> IWannaLog: It might be the case that people have already thought through this.
14:13:10 <Cale> IWannaLog: But that is actually impossible. Termination checking is not computable.
14:13:16 <IWannaLog> but you have to explain so many thing to devloppers in the whole world
14:13:19 <vixey> Cale, it's possible
14:13:26 <pumpkin> Cale: it's not possible in general
14:13:29 <vixey> Cale, const True for simply typed lambda calculus
14:13:31 <IWannaLog> Cale: you can't prove it, it doesn't compile
14:13:36 <Cale> vixey: It's possible, if you're willing to restrict the type of programs you can write.
14:13:41 <IWannaLog> COq does it very well
14:13:57 <Cale> IWannaLog: Then not all programs which terminate can be written.
14:14:01 <Raevel> should i use simpleargs or parseargs?
14:14:04 <IWannaLog> If you know that your function works, it's mean you can prove it
14:14:13 <vixey> IWannaLog, obviously the philosophy of programming in Haskell and Coq are different
14:14:14 <Cale> What if the program always terminates, but you can't prove that it does?
14:14:25 <Philippa_> Peaker: I do favour fairly minimal comments within code, admittedly
14:14:25 <saml> i'd restart crashed program instead of make a program never crash
14:14:26 <IWannaLog> Cale: all program which terminate could be written (with an infinite time)
14:14:33 <pumpkin> how about the ackerman function :o
14:14:33 <Philippa_> but implementation docs aren't interface docs
14:14:40 <pumpkin> that's a pretty nontrivial termination
14:14:43 <Philippa_> and interface docs aren't a repetition
14:15:19 <vixey> Cale, you can write it in a computation monad then
14:15:28 <IWannaLog> Cale: and if a program terminates you can prove it
14:15:28 <Cale> Let's start with something easy. How about a program which simply takes as input a natural number n, and tries to determine if n eventually reaches 1 under iteration of the Collatz function?
14:15:32 <saml> is there global Exception handler that i can override?
14:15:35 <iago> hi
14:15:44 <saml> so that head [] won't quit the program?
14:15:49 <vixey> Cale, or define a termination predicate for it and take it as an axiom (no monads in this case)
14:15:50 <Olathe> > let program n = True
14:15:51 <lambdabot>   <no location info>: parse error on input `;'
14:15:56 <Olathe> > let program n = True in map program [1..]
14:15:58 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
14:16:00 <ddarius> saml: Just put an exception handler in main.
14:16:07 <Heffalump> saml: I believe GHC has one, but I forget how to use it.
14:16:28 <saml> making partial function to total one by calling this global exception handler for all unexpected inputs
14:16:34 <vixey> Cale, 3rd option, you can even define the rewrite rules as a data type
14:16:39 <pumpkin> IWannaLog: he just gave you an example where it hasn't been proven :)
14:16:42 <Philippa_> Peaker: I'd also make changing the interface and not documenting it a "buy everyone a beer" offence too, but hey
14:16:52 <Cale> IWannaLog: It's not clear that this program always terminates, and yet it probably does.
14:16:54 <Philippa_> it's like breaking the build, it affects everyone
14:16:55 <pumpkin> IWannaLog: but no one's ever found a case where it doesn't terminate
14:17:17 <neun> hi, is there a way to put this Maybe case expression more elegantly:
14:17:31 <neun> http://hpaste.org/13450
14:17:48 <pumpkin> sounds like a >>=
14:17:48 <chrisdone> it's monad time!
14:17:53 <IWannaLog> Cale: I remember it was proven that this program terminates (I'm not sure)
14:18:02 <Cale> IWannaLog: no, it wasn't
14:18:09 <IWannaLog> Ok
14:18:10 <Peaker> Philippa_: the interface should be documented, preferrably with names.  Change the interface, you change names, and intentionally break code that needs to be readjusted
14:18:12 <Cale> IWannaLog: This is still an open problem.
14:18:15 <pumpkin> neun: or even without >>=, you can use maybe
14:18:17 <pumpkin> :t maybe
14:18:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:18:21 <neun> I have some problems mixing the monads
14:18:31 <Cale> (Unless it was proven within the last few weeks or so, and I haven't heard about it yet :)
14:18:38 <vixey> it's funny reading Heytings book, he keep using this example (I think it was about the digits of pi) like Cale is using Collatz, except by now the theorem was proved :p
14:18:43 <nolrai_East> @pl \a s -> (y a) (x a) s
14:18:43 <lambdabot> ap y x
14:18:57 <Philippa_> Peaker: right, that works fine. Names aren't good enough for docs in most cases
14:19:06 <vixey> so you have to pretend that the theorem wasn't proved when you read it
14:19:15 <neun> pumpkin: ok thanks, I try that
14:19:27 <IWannaLog> Cale: I was wrong, i think about something else (it's just I don't call it Collatz, but Syracuse)
14:19:28 <pumpkin> neun: but yeah, using maybe as a monad is probably the most elegant approach
14:19:29 <Cale> vixey: :)
14:19:31 <Peaker> Philippa_: Maybe it has to do with Haskell's lack of argument names?
14:20:03 <rwbarton> neun: let's see... Renderer.error <$> drawing <*> image :: Maybe (IO a)
14:20:23 <rwbarton> neun: then you can use Data.Traversable.sequence :: Maybe (IO a) -> IO (Maybe a), I think
14:20:25 <chrisdone> rwbarton: delicious
14:20:28 <Philippa_> Peaker: that doesn't help, but names don't let you state invariants
14:20:29 <pumpkin> wow :)
14:20:31 <rwbarton> :t Data.Traversable.sequence
14:20:32 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
14:20:41 <Cale> IWannaLog: Even without such contrived cases, much more common is the case that you know that it terminates, and you even have a proof, but you don't want to bother proving to the compiler (for any number of reasons), that the program terminates.
14:20:58 <vixey> Cale, but you don't like my suggestions for that case :(
14:20:58 <rwbarton> Data.Traversable rules
14:21:00 <Peaker> Philippa_: True, but how much of the documentation documents invariants?
14:21:04 <neun> :t <$>
14:21:05 <lambdabot> parse error on input `<$>'
14:21:12 <pumpkin> :t (<$>)
14:21:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:21:14 <neun> :t (<$>)
14:21:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:21:19 <IWannaLog> It's sad, what a fun to prove your program and never test it (for what, it was proven)
14:21:19 <British0zzy> can I use <- in a where statement?
14:21:20 <Cale> vixey: It's just that I prefer the partiality solution.
14:21:35 <British0zzy> ie where x <- getChar
14:21:45 <chrisdone> no
14:21:45 <Rui> someone here understand AI programing well
14:21:48 <Rui> ?
14:21:48 <Philippa_> Peaker: ones that need to be respected by users? It /should/ be in all relevant docs
14:21:51 <vixey> Cale, well yeah,  I think currently it's a horrendous job to try and prove every program you write correct
14:21:56 <vixey> (formally)
14:21:57 <pumpkin> Rui: AI is huge, what in particular?
14:22:11 <Rui> basically, trying to add an AI to a game I made
14:22:21 <Rui> and well, I think things are correct, but it gives me an error at the end
14:22:25 <pumpkin> :o
14:22:29 <Rui> when putting hte actual play together
14:22:30 <pumpkin> a compiler error?
14:22:36 <IWannaLog> vixey: yes and many developpers think like you and every applications in world has bugs (event bank application) and we give our live to computer and lazy developpers
14:22:40 <IWannaLog> scary :D
14:22:56 <vixey> IWannaLog: they think like me? :P
14:23:06 * pumpkin gives IWannaLog a lot
14:23:07 <pumpkin> log
14:23:09 <Philippa_> IWannaLog: you want to be a little bit careful about who you stereotype around here
14:23:09 <Cale> vixey: Also, while monadic I/O is a fairly effective way to structure programs to preserve purity, and while I agree that it's possible to treat partiality as a kind of effect, it's not clear to me that every program can be stratified so nicely into a Turing complete and not-quite-Turing-complete part.
14:23:11 <IWannaLog>  it's a horrendous job
14:23:24 <vixey> IWannaLog: It truly is, have you tried?
14:23:25 <syntaxfree> I''ve been playing around with Processing.
14:23:28 <Philippa_> vixey's position isn't the one you think it is
14:23:52 <IWannaLog> vixey: I studied matematics for many years and I know how it's difficult but important
14:24:03 <Riastradh> If you draw up a specification for a program, and prove that the program adheres to the specification, how can you be sure that the specification is what you want?  Better specify what you want, and prove that the specification matches your meta-specification...!
14:24:09 <astrobe> Kind of doing physics with set theory
14:24:09 <syntaxfree> It's the best environment for easy graphical programming I've seen since I had a Sinclair ZX-Spectrum, but Java sucks so terribly hard.
14:24:15 <IWannaLog> Riastradh: It's another problem :D
14:24:16 <pumpkin> IWannaLog: so if your program somehow needed the Collatz function (hah) you just wouldn't write it because you couldn't prove it would terminate?
14:24:30 <vixey> IWannaLog: so you agree with me? :)
14:24:31 <IWannaLog> Yes you can't prove you don't compile
14:24:37 <Philippa_> Cale: I think there's a /lot/ of bits that clearly need to terminate. Merely showing that they do is a big win
14:24:43 <syntaxfree> I could never imagine there could be such an awful language. I pity the indian masses that have to do that for six hours a day.
14:24:53 <Cale> Philippa_: Well, yes, that is true.
14:24:54 <IWannaLog> You want to give a program to a client nd billions people and you don't know if it's work
14:25:03 <Philippa_> being able to reason about productivity as well, however, is an even bigger win
14:25:08 <vixey> IWannaLog: ..but I am super curious have you done anything non-trivial with total correctness proofs formalized?
14:25:15 <Cale> Philippa_: The monadic solution looks a bit ugly to me there though.
14:25:23 <Philippa_> there aren't so many things we do that are intended to not necessarily be either
14:25:28 <syntaxfree> re: program correctness, etc. There's even more problems in the quant models themselves.
14:25:48 <syntaxfree> Quantitative finance is horribly, horribly broken.
14:25:48 <Rui> http://hpaste.org/13451#a0
14:25:53 <dnul> i have a question.  takeWhile (>20) (map (+1) xs) .... im not sure in which order its executed im having some performance issue and i think the trouble is here
14:25:56 <rwbarton> IWannaLog: Typically customers don't demand correctness proofs before parting with their money.
14:26:09 <pumpkin> Rui: so what's wrong with it?
14:26:15 <IWannaLog> vixey: sorry for the "stereotype'"
14:26:16 <Rui> ok well
14:26:20 <Rui> i had my main start prog
14:26:25 <Rui> that would alternate between player 1 and player 2
14:26:31 <vixey> IWannaLog: I'm not bothered at all, but I am curious :p
14:26:33 <Rui> so what I changed for the AI was
14:26:39 <IWannaLog> vixey: curious about what ?
14:26:46 <vixey> IWannaLog: have you done anything non-trivial with total correctness proofs formalized?
14:26:47 <Rui> take the part of the normal start, that asks what column to play in, and does all the checks
14:27:01 <vixey> IWannaLog: (I mean non-trivial programs)
14:27:05 <pumpkin> Rui: first of all, have you proved your program will terminate? it would be irresponsible not to
14:27:06 <Rui> put it under an if playerturn == X (real player) then it would run the procedure and return a new board
14:27:10 <vixey> like the kinda stuff someone might make use of
14:27:19 <Rui> if it isnt X (aka AI = O) it would run the AI program
14:27:23 <Rui> and return me the new board
14:27:25 <Rui> from the AI
14:27:31 <IWannaLog> vixey: I want a good tool before (the only one I know is Coq, and where is the doc ?)
14:27:38 <Peaker> IWannaLog: Do you realize that there is a tradeoff between getting functionality out the door in time, and proving the correctness of everything?  If you had to put only perfect software out, there would be _very_ reliable software out there, but very very few of it.  IRC would not exist for you to chat here
14:27:40 <vixey> IWannaLog: inria.fr
14:27:49 <syntaxfree> short of correct numerical methods, clients who accept gaussian copulas as a credit default model probably won't care if the programs bork once in a while.
14:28:01 <vixey> IWannaLog: coq.inria.fr
14:28:04 <Peaker> IWannaLog: for most purposes, unreliable software is better than no software
14:28:08 <pumpkin> Rui: I mean, where's your error?
14:28:09 <syntaxfree> correct numerical methods = minimizing floating-point error.
14:28:15 <Rui> ill paste it on hpaste then wait
14:28:20 <hugo___> hi
14:28:22 <syntaxfree> potential fp error anyway.
14:29:00 <astrobe> cf. "Worse is better"
14:29:03 <Rui> ok annotated
14:29:06 <vixey> IWannaLog: so, well, I think it's silly to suggest this sort of thing without having eaten your own dog food but certainly it's a noble goal
14:29:15 <IWannaLog> And what will we do when hackers will have lead people to anarchy in cracking every bank application
14:29:19 <dnul> i have a question.  takeWhile (>20) (map (+1) xs) .... im not sure about taking advantage of the laziness here
14:29:28 <IWannaLog> there will be guys with gun in fornt of my door
14:29:35 <vixey> IWannaLog, stop assinging value to bits of plastic?: P
14:29:47 <IWannaLog> vixey: What ?
14:29:48 <vixey> IWannaLog, (and shiny metal)
14:29:54 <vixey> IWannaLog, if the banks get 'hacked'
14:30:16 <pumpkin> Rui: so that's really just a type error, not an AI issue
14:30:21 <syntaxfree> IWannaLog: s/crackers/financial structurers/
14:30:21 <IWannaLog> vixey: You know how many bugs there are in them ?
14:30:27 <wli> WOrse is worse.
14:30:31 <Rui> well only got that right after fiddling with the AI xD
14:30:39 <Rui> do you know how i can fix it tho?
14:30:57 <Cale> dnul: what's wrong?
14:31:03 <syntaxfree> IWannaLog: the super-senior tranche thing screwed up things worse than  crackers could eever dream of.
14:31:07 <vixey> IWannaLog: What I know is that unless you're doing something about (i.e. making formalized correctness proofs easier to write, and still completely trustworthy), you're not improving the situationo
14:31:16 <IWannaLog> And there is more and more data (sensitive data) on the internet, personal data, secret dara
14:31:28 <Cale> dnul: takeWhile is evaluated first, and it forces evaluation of map, which in turn forces evaluation of xs.
14:31:36 <pumpkin> Rui: I don't have enough of the code there, but it looks like you probably missed some parentheses around your definition of possibleMove, I'd guess
14:31:36 <IWannaLog> i'm a little scary of the future of computer
14:31:39 <wli> Actually, neoclassical economics is horrendously out-of-line with reality in numerous respects.
14:32:03 <Rui> possible move?
14:32:05 <astrobe> Not to mention that you have to prove that the proof checker is correct.
14:32:22 <vixey> IWannaLog: OK so what has got to be done to stop things getting worse? if you think it's total programs with correctness what needns to be done in that area before it can be used more?
14:32:23 <pumpkin> Rui: well the error is telling you:   Couldn't match expected type `Board -> Move -> t -> t1'
14:32:23 <pumpkin>            against inferred type `IO Int`
14:32:24 <IWannaLog> vixey: I trid once coq, but the lack of doc I stop my activity
14:32:35 <vixey> IWannaLog, no clue why you are complaining about docs
14:32:36 <rwbarton> IWannaLog: aha
14:32:44 <Rui> hld on, i do have the game code on hpaste already
14:32:45 <vixey> IWannaLog, Coq is the best documented tool out there
14:32:46 <rwbarton> IWannaLog: so read the source and then write better docs :)
14:32:57 <pejo> IWannaLog, have you read the manual? Coq'Art? The tutorial from the fine folks at Upenn?
14:33:04 <astrobe> ini other words, the tools used for the proof must be able to proove their own correctness
14:33:12 <vixey> if you couldn't even find the manual though.............
14:33:31 <vixey> astrobe, what?
14:33:32 <IWannaLog> vixey: please. I just don't find the answer I need
14:33:34 <vixey> astrobe, who said that
14:33:35 <syntaxfree> wli: neoclassical economics is far from being the monolithic block that the left would like to show you.
14:33:47 <vixey> IWannaLog: This is a really interesting area though
14:33:54 <neun> rwbarton: thanks again, it does compile but I don't know why this works, it must be magic
14:34:09 <IWannaLog> And it use a logic system I don't like (forall x => exists x, and sets are never empty, hugh)
14:34:13 <vixey> astrobe, have you read a little about the philosophy of consistency proofs?
14:34:18 <neun> maybe I'll get it tomorrow
14:34:41 <syntaxfree> moreover, the problem really isn't in rationality assumptions, as the critique usually goes, but in aggregation issues -- something that's extensively discussed in the graduate textbooks but never mentioned to the public.
14:34:51 <astrobe> vixey: oops, yeah, that can't be done. I forgot about that... :)
14:34:53 <dnul> Cale: My worry is that it first does all the mapping and then the taking ...  but it shouldnt?
14:35:07 <Cale> dnul: right, it won't.
14:35:11 <IWannaLog> vixey: I rode many papers and I saw that int was inductive (ou kno Zero | Succ Int), with that I can't have a fast program
14:35:21 <syntaxfree> [/wonk]
14:35:26 <dnul> Cale: mm ok , thx u .
14:35:34 <vixey> IWannaLog, that's not the only possible way to represent numbers
14:35:43 <cjb> IWannaLog: haskell is plenty fast.
14:35:52 <Cale> dnul: The outermost function evaluates first, and pattern matching forces evaluation only up to determining whether the pattern matches.
14:36:02 <IWannaLog> I don't find explanation about this, and how to obtain a .c or a .hs or a .ml etc...
14:36:16 <vixey> IWannaLog, Recursive Extraction "foo.ml" foo.
14:36:21 <howa> rate my new site !! http://www.hardstylersunited.dk/
14:36:23 <vixey> IWannaLog, Extraction Language Haskell. Recursive Extraction "foo.hs" foo.
14:36:23 <wli> syntaxfree: The critiques I've seen are generally not single-issue.
14:36:24 <Peaker> Can't you represent ints with machine words, but still use the Zero | Succ Int representation for proofs?
14:36:25 <syntaxfree> my first real programming language was Haskell, so I could never appreciate how grateful I should be for the Num class.
14:36:41 <Peaker> syntaxfree: how did that happen? :)
14:36:44 <IWannaLog> syntaxfree: a horrible class
14:36:50 <Peaker> syntaxfree: how were you first exposed to Haskell, of all languages?
14:36:52 <syntaxfree> in Java objects will return float, double, a Double object, etc.
14:36:53 <IWannaLog> vixey: I found no doc about extracting
14:37:03 <dnul> Cale: right, i'm having some trouble with euler 23,it takes 10 minutes ....:(
14:37:05 <rwbarton> Maybe syntaxfree just doesn't consider any other languages to be real languages :)
14:37:06 <vixey> IWannaLog, dunno why you are telling me that, I already linked you docs that cover extraciton
14:37:21 <IWannaLog> where ?
14:37:24 <syntaxfree> Peaker: actually, I was first exposed to ZX Spectrum BASIC as a wee tot, but I didn't pursue programming any further.
14:37:28 <vixey> IWannaLog, coq.inria.fr for the second time
14:37:36 <IWannaLog> Can I laugh ?
14:37:47 <vixey> IWannaLog, I cannot believe you found this system but not the website
14:38:09 <IWannaLog> Yes I laugh, of course I find the website
14:38:14 <vixey> IWannaLog, maybe you are just trolling about formal methods (kinda funny thought that)
14:38:24 <syntaxfree> yeah, I know. I used to kvetch about how a proper Ring/Group/Integral class/Field hierarchy should be built instead of the algebrically confusing Num.
14:38:44 <syntaxfree> but I mean, I'm forced to do dirty typecasting in even the shortest Java projects with Processing.
14:39:19 <IWannaLog> vixey: so you know a little bit about it ?
14:39:41 <IWannaLog> can I obtain a beautiful .exe in native code with it ?
14:39:47 <vixey> IWannaLog, I _don't_ know why you keep saying you couldn't find docs
14:39:52 <syntaxfree> wli: hmm. maybe you've been exposed to the actual heterodox literature?
14:40:10 <vixey> IWannaLog, got a haskell or ocaml compiler? try what I just told you to try 2 mins ago
14:40:16 <Peaker> oh, IWannaLog is french, that explains everything :-)
14:40:29 <wli> syntaxfree: I went straight for what heterodox stuff I could find online.
14:40:29 <syntaxfree> wli: there's good stuff in there. but take everything with a pinch of salt. including "neoclassical economics" as espoused by Greg Mankiw or Paul Krugman.
14:40:30 <pumpkin> then he shouldn't have trouble with the inria stuff
14:40:42 <IWannaLog> vixey: sorry it's hard to follow everything on IRC
14:40:50 <vixey> IWannaLog, np
14:40:58 <syntaxfree> wli:  you really want to learn some proper microeconomic theory first.
14:41:01 <IWannaLog> Peaker: thank you
14:41:08 <Philippa_> syntaxfree: stuff aimed at undergrads is often pretty crappy anyway, no?
14:41:27 <syntaxfree> Philippa_: you mean Mankiw and Krugman?
14:41:40 <Philippa_> syntaxfree: I was making a general comment :-)
14:41:44 <Philippa_> lies-to-undergrads etc etc
14:41:48 <syntaxfree> Philippa_: I was actually thinking about how they are analyzing the current crisis.
14:41:52 <Saizan> http://ghcmutterings.wordpress.com/2008/12/04/explicit-stack-traces/ <-- anyone knows if this is available in ghc HEAD?
14:41:53 <IWannaLog> vixey: ok you win, I'll giving coq a second chance
14:42:07 <IWannaLog> after reading the boring doc
14:42:07 <wli> syntaxfree: I do okay with the calc of variations and optimal control -based bits, Nash equilibria, von Neuman - Morgenstern stuff, etc.
14:42:12 <syntaxfree> but I really feel that both Krugman and Mankiw are really gerrymanderrers.
14:42:18 <astrobe> Peaker: beware, he is not alone.
14:42:19 <wli> von Neumann
14:42:20 <Philippa_> IWannaLog: you'd probably benefit from spending a while getting your head around constructivist logic in general
14:42:23 <vixey> IWannaLog, I win?! :)
14:42:31 <syntaxfree> wli:  well, yeah, you have more than the necessary mathematical tools.
14:42:35 <IWannaLog> Philippa: What ?
14:42:45 <syntaxfree> wli: get a copy of Mas-Colell, Whinston and Green.
14:42:52 <syntaxfree> (it's one book.)
14:43:04 <Peaker> IWannaLog: right after that please get to rewriting all the bank applications' code
14:43:13 <Philippa_> IWannaLog: the style of logic that Coq is based around. Oh, and the Curry-Howard isomorphism too (the whole programs-are-proofs/types-are-propositions deal)
14:43:13 <Peaker> IWannaLog: and prove it all with coq
14:43:19 <IWannaLog> Peaker: of course :D
14:43:25 <pumpkin> has coq proved its own correctness yet though?
14:43:30 <IWannaLog> pumpkin: yes
14:43:37 * wli is in a bit much budgetary trouble to go book shopping.
14:43:38 <syntaxfree> Everyone is forgetting about the microeconomics regarding their public comments in this crisis.
14:43:42 <IWannaLog> Philippa_: I'm ok with that
14:43:42 <centrinia> pumpkin, shouldn't that be impossible.
14:43:48 <pumpkin> centrinia: apparently not
14:43:49 <Peaker> IWannaLog: btw, you know that even with proven source code, malicious code may still be in there?
14:43:55 <vixey> pumpkin, you don't think self verification is meaningless?
14:43:58 <centrinia> That doesn't make sense.
14:44:02 <syntaxfree> "Everyone" being the big heads, of course. Mankiw, Krugman, etc.
14:44:04 <IWannaLog> Peaker: Yes and that nothing couldbe really proven
14:44:08 <pumpkin> vixey: I was being silly :P but apparently it's done that anyway! ;)
14:44:32 <vixey> pumpkin, yeah, the consistency of CoC with one universe is proved in CIC
14:44:34 <Peaker> IWannaLog: Yes, the compiler may be compromised, and it may also generate compromised compilers, and so on, and there is no way to ever be sure
14:44:35 <syntaxfree> as for quant finance, the problem is more in the mathematical modelling than in the economic assumptions anyway.
14:44:45 <vixey> pumpkin, which is kinda interesting
14:44:47 <IWannaLog> Talking about Coq when I just want to know how to have safe log with Haskell (lol)
14:44:57 <syntaxfree> There has always been vast evidence of excess kurtosis in market returns. Why do models keep going back to the gaussian distribution?
14:45:07 <centrinia> It is also difficult to qualify what malicious code is.
14:45:21 <mornfall> I guess there's no easy way to peek into a C++ vector from Haskell?
14:45:22 <wli> Well, the mathematical models won't do a whole lot if they're modelling garbage.
14:45:23 <syntaxfree> I mean, undergrad Statistics 101 will tell you that the market has heavier-than-gaussian tails.
14:45:27 <IWannaLog> Peaker: even with a non compromised program, you could never be sure the computer executes it correctly (even if the processor is correct)
14:45:36 <syntaxfree> wli: I mean, the problem is in the stochastic assumptions.
14:46:05 <wli> I can believe the statistical aspects are botched.
14:46:07 <syntaxfree> Then they go for copulas, and instead of staying in general radial copulas (you can do that if you assume a Lvy process), they go for.. drum roll.. gaussian copulas.
14:46:07 <Peaker> IWannaLog: yeah, so why do you want proven code with some arbitrary N 9's reliability? Why not tested code with M 9's reliability?
14:46:25 <Peaker> IWannaLog: sure N >> M, but maybe M is safe enough to not panic? :)
14:46:30 <syntaxfree> wli: there's not much microeconomics to the quant models anyway.
14:46:32 <IWannaLog> Peaker: I didn't understand.
14:46:54 <IWannaLog> Who is N and M, number friend food dogs car ?
14:46:57 * vixey doesn't really follow Peaker either
14:46:59 <centrinia> Peaker, you can't say that infinity >> M for any natural number M.
14:47:12 <Peaker> centrinia: how is it infinity?
14:47:21 <syntaxfree> if markets were efficient the models themselves wouldn't be needed.  They're there because there's an understanding that there's arbitrage to be earned.
14:47:27 <maltem> mornfall: if you mean to access C structures that lie somewhere in memory from Haskell, there's Foreign.C
14:47:38 <Peaker> IWannaLog: assume you assign a number to the reliability of the bank applications.  It increases when you test and review it thoroughly. It increases more when you prove it, but its still not perfect.  Why is the "right" position the latter and not the former one?
14:47:48 <mornfall> maltem: I mean std::vector specifically.
14:48:03 <IWannaLog> Peaker: One day you say yourself I'm ok with that
14:48:04 <mornfall> maltem: I know how to access plain C structures.
14:48:04 <centrinia> Proven code has a zero probability of being unreliable.
14:48:12 <IWannaLog> today I'm not okay with bank application
14:48:29 <Peaker> centrinia: Only for very lenient definitions of "code" and "unreliable"
14:48:34 <wli> syntaxfree: But there need to be more, as the number of players is few enough to render the limiting assumptions poor approximations. Plus what you say about market efficiency (which is blatantly obvious given the numerous ongoing market failures imposed for obvious reasons).
14:48:41 <IWannaLog> I don't trust my OS and never put confidential data in it
14:48:47 <syntaxfree> IWannaLog: today you shouldn't be okay with banks at all.
14:49:07 <IWannaLog> syntaxfree: it's okay, ther is no crisis, it can't exist
14:49:10 <Peaker> centrinia: If "code" includes the manner with which it is compiled/executed, and "unreliable" excludes errors in the specification itself, then sure
14:49:12 <Arnar> hmm.. I'm using TemplateHaskell, only one splice: $( derive makeBinary ''Test ) -- but the compiler complains that 'ap' is not in scope, any ideas?
14:49:13 <rwbarton> mornfall: I would guess you need to write a wrapper function
14:49:17 <Peaker> s/includes/excludes
14:49:19 <IWannaLog> it's just that money is moving
14:49:24 <rwbarton> Arnar: import Control.Monad
14:49:34 <syntaxfree> IWannaLog: never trust your money to someone who can't recite the Lyapunov condition by heart.
14:49:38 <Arnar> rwbarton: ok, that's std. when using TemplateHaskell?
14:49:45 <vixey> Peaker, when you produce a formal proof of a program you have considered every single aspect of it (or at least some kind of certified decision program has), regardless of quantifiable criteria. This means a _lot_
14:49:46 <Peaker> centrinia: the compiler, for example, may be compromised
14:49:55 <syntaxfree> you need to be very clear about you're doing if you're thinking "asymptotically normal"
14:49:56 <rwbarton> Arnar: The code that's spliced in needs Control.Monad to be imported in this case
14:50:06 <Peaker> vixey: I agree it means a lot, I am a big fan.  But it doesn't make things "infinitely reliable" in practice
14:50:11 <wli> syntaxfree: There's a Lyapunov analogue for SDE's?
14:50:18 <mreh> yo holmes
14:50:35 <syntaxfree> wli: I was actually just saying that you need to know when you can assume a CLT.
14:50:35 <vixey> infinitely reliable ?? lol
14:50:43 <mreh> is a type definition exactly the same as an algebraic type with only one value?
14:50:48 <mreh> fo shizzle
14:50:49 <vixey> mreh, n
14:50:51 <maltem> mornfall: oh are those C++ structures non-compatible to C structs?
14:50:53 <Peaker> vixey: that's what centrinia said
14:50:53 <mornfall> rwbarton: I guess that won't fly... But I have a different idea. : - ]
14:51:01 <mreh> wha?
14:51:03 <wli> syntaxfree: CLT?
14:51:05 <syntaxfree> There are CLTs beyond the Lyapunov/Lindenberg class, but those apply to strange mathematical objects anyway.
14:51:10 * rwbarton doesn't like the look of that ]  :)
14:51:10 <syntaxfree> wli: central limit theorem.
14:51:11 <Arnar> rwbarton: ok. can't it import stuff itself or is this simply a mistake by whoever wrote it? (sorry for the noob qs, just curious)
14:51:12 <centrinia> vixey: That's what I said.
14:51:21 <IWannaLog> syntaxfree: but the bankers are the best to count (try to count with someone in the street and a banker you'll see the difference)
14:51:31 <rwbarton> Arnar: As far as I know, it can't.
14:51:40 <mornfall> maltem: Well, for one, it's a template. For second, it's unlikely anything will be able to produce a Storable instance automatically.
14:51:54 <syntaxfree> IWannaLog: hello. do you speak english?
14:52:00 <mornfall> (The data representation is invariant under template parameters, but still..)
14:52:06 <IWannaLog> syntaxfree: it's hard for me
14:52:10 <IWannaLog> sorry
14:52:16 <IWannaLog> I do my best
14:52:34 <maltem> hm right
14:52:36 * syntaxfree sighs and wishes channel moderation was more active.
14:52:40 <Philippa_> vixey: there's a big difference between proving properties of the CoC and demonstrating that there are no flaws in the toolchain
14:52:40 <mornfall> I have a different idea anyway.
14:53:06 <pumpkin> syntaxfree: what for?
14:53:06 <Philippa_> that said, with a little care you can drastically lower the probability of error using proofs
14:53:12 <syntaxfree> then again, I would probably be one of the most shooshed visitors of the channel if there was activist moderation.
14:53:42 <Peaker> centrinia: I think it was one of C's creators (Kernighan?) that explained how a malicious compiler may be used to compile its own innocent-version of the source code into the malicious version again, and compile innocent-looking login to a malicious one that accepts a backdoor password.  He also used the example of the compiler interpreting '\\' and 'n' to be '\n', so nowhere in the source code of a compiler can you actually find the value of '\n'
14:54:08 <syntaxfree> I haven't written a line of Haskell in more than a year now and come in to lurk and see the state of the nation once in a while.
14:54:11 <mornfall> Well, goodnight. I'll dream about my Haskell-to-C++ issues. ; - )
14:54:15 <pumpkin> well there was that awesome backdoor in gcc for a while
14:54:17 <astrobe> Philippa_: and tests and proper design technis. The bottom line is that you have to have more than one line of defence against defects
14:54:23 <Botje> Peaker: ken thompson; "reflections on trusting trust" iirc
14:54:40 <centrinia> Peaker, why stop at one generation of innocent code? ;)
14:54:40 <syntaxfree> more "real geeks" should go to quant finance.
14:54:51 <vixey> Philippa_: one thing nobody seems to care about is correctness of parsers
14:54:56 <syntaxfree> The kind of minds that are in computer science right now... *sigh*
14:55:03 <IWannaLog> vixey: lol
14:55:08 <Peaker> centrinia: I think its two :) the compiler and login
14:55:11 <Philippa_> vixey: it's more that few people are worried about it
14:55:37 <luite> what is the best way to do sizeOf (a::Ptr CInt) without actually having value 'a'?
14:55:39 <Peaker> syntaxfree: a friend of mine is an anti-academia brilliant CS person, and is in finance
14:55:49 <pumpkin> luite: undefined?
14:55:53 <pumpkin> not sure
14:55:55 <sbahra> What was the command to trigger lambdabot's "Yes it can!" answer?
14:56:01 <luite> pumpkin: hm, could try that
14:56:01 <sbahra> Can Haskell blah blah?
14:56:04 <pumpkin> @faq
14:56:04 <lambdabot> The answer is: Yes! Haskell can do that.
14:56:08 <sbahra> Ah
14:56:10 <luite> > sizeOf (undefined::Int)
14:56:11 <lambdabot>   Not in scope: `sizeOf'
14:56:14 <luite> oh
14:56:20 <rwbarton> luite: yeah, undefined
14:56:27 <Philippa_> astrobe: the thing with testing is that if you've got proofs, you should largely be using testing for /things you haven't proved/
14:56:59 <Philippa_> (note that if it involves the outside world, you haven't proved an awful lot about it...)
14:57:00 * centrinia defines a function faq :: String -> String; faq = const "The answer is: Yes! Haskell can do that.";
14:57:29 <pumpkin> centrinia: omg the source code to the faq plugin :P
14:57:32 <syntaxfree> Peaker: My cow orker is a physicist, himself.
14:57:43 <Peaker> syntaxfree: you have a cow at work?
14:57:44 <syntaxfree> we're not quite in finance, though. we're a consulting shop.
14:57:45 <IWannaLog> Did someone had experiences with log in haskell. Because I'm thinking about something using the IO Monad to be sure to not loose debug information
14:57:54 <astrobe> Philippa_: yes, that is I think a possible way to resolve the productivity problem mentionned earlier
14:58:07 <pumpkin> IWannaLog: you can use Debug.Trace :o
14:58:10 * pumpkin hides
14:58:16 <Peaker> IWannaLog: why not test for the cases log may fail explicitly, and put the result in the Either or ErrorT monads?
14:58:19 <pumpkin> @help
14:58:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:58:20 <syntaxfree> sometimes we do quant finance work, but we're six steps removed from actual decisions.
14:58:22 <pumpkin> @list
14:58:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:58:37 <syntaxfree> anyway, my cow orker is a physicist, but he's also a much more practical man than me.
14:58:38 <IWannaLog> pumpkin: I don't want to use this kind of function
14:58:40 <Philippa_> astrobe: being aware of the precise limits of what you've proven is important :-)
14:58:43 <pumpkin> centrinia:     ,("faq",        const "The answer is: Yes! Haskell can do that.")
14:58:58 <IWannaLog> Debug.Trace (why not use OCaml or JAva or impure language)
14:59:01 <vixey> IWannaLog: You're _debugging_ ? :(
14:59:13 <centrinia> That looked like what I wrote.
14:59:17 <IWannaLog> maybe Trace is a better word
14:59:19 <syntaxfree> so he ends up doing much of the grunt "responsible" work and I'm left free to play with statistics.
14:59:22 <vixey> IWannaLog: *thinks*  man down, we lost one
14:59:27 <Peaker> vixey: do you manage to _always_ avoid debugging?
14:59:33 <pumpkin> centrinia: I know :) I was showing you the real source code and praising your ability to read the authors' mind
14:59:34 <IWannaLog> it's not for me but when it failed I wan to know why
14:59:35 <astrobe> Philippa_: actually took the idea from air trafic security experts, who give the metaphore of a succession of walls with little holes.
14:59:46 <vixey> Peaker, Let me put it this way: I don't like debugging
14:59:58 <syntaxfree> I wish there was a threaded IRC interface.
15:00:00 <astrobe> If you have one wall with many big holes, the airplane may often crash
15:00:07 <Peaker> vixey: but you're forced to do it sometimes, like everyone else?
15:00:13 <vixey> Peaker, no
15:00:14 <IWannaLog> Peaker: why this question ?
15:00:21 <syntaxfree> what astrobe said to Philippa probably has an interesting back-log to it, but I have to scroll up and visually grep.
15:00:24 <rwbarton> syntaxfree: It's called #haskell-overflow :P
15:00:30 <Philippa_> astrobe: yeah, I understand defence in depth fine :-)
15:00:40 <astrobe> but if you have many walls with little holes, there are less chances for the planes to go through, and crash
15:01:18 <Peaker> vixey: I wish I was able to always avoid debugging. I get puzzled by an error I have once every 100-200 lines or so of Haskell code, and sometimes I have no idea where its coming from, and start bisecting its position via debugging
15:01:22 <astrobe> Phiippa_: yeah, that's the right term
15:01:26 <pumpkin> @get-shapr
15:01:26 <lambdabot> shapr!!
15:01:28 <pumpkin> lol
15:01:28 <rwbarton> astrobe: Wait, the plane crashes if it *doesn't* hit the wall? :)
15:01:38 <Peaker> vixey: I hate debugging too, but a lot because Haskell has no proper debugger..
15:01:56 <pumpkin> @id moo
15:01:57 <lambdabot>  moo
15:02:16 <syntaxfree> that's why you always put your mattresses against the walls when you are in the middle of hours-long gunfire.
15:02:21 <Philippa_> Peaker: it helps if you can keep the WTFs out of your IO code, at least
15:02:32 <syntaxfree> the bullets get caught in the mattresses.
15:02:50 <Philippa_> or at least slowed down further
15:02:52 <Peaker> Philippa_: The last bugs I had to debug were just my use of regexps (I should probably have used parsec...)
15:03:13 * sbahra has never had to use a debugger with Haskell
15:03:14 <astrobe> rwbarton: yes, well, that's from half corrupted memory.
15:03:18 <sbahra> But what I've written with it is trivial.
15:03:19 <Philippa_> Peaker: yeah, I guess the non-compositionality of regexps does make it tricky once you've narrowed it down to the regexp calls
15:03:20 <Peaker> sbahra: define "had to"
15:03:33 <syntaxfree> rwbarton: "Defence in depth seeks to delay rather than prevent the advance of an attacker, buying time and causing additional casualties by yielding space."
15:03:45 <sbahra> Peaker, ~300-400 lines, serial programs, any bugs are easy to catch.
15:03:50 <wli> Are there compositional alternatives to regexps?
15:03:51 <Peaker> Philippa_: Regexps are horrible, and the Haskell libs around them is seriously lacking in a few simple examples :(
15:03:52 <syntaxfree> hence landmines.
15:04:24 <sbahra> Peaker, even before compilation.
15:04:28 <Philippa_> Peaker: yep. I don't like regexps, and I translate regular expressions(!= regexps) into parsec habitually
15:04:32 <sbahra> Peaker, type checking catches anything else that I could've missed.
15:04:35 <syntaxfree> one of our coworkers actually spends two months out of three in Angola in a long-term contract with the government.
15:04:47 <IWannaLog> Philippa_: the same for me
15:04:52 <Peaker> sbahra: I think you just end up "debugging" it by going through the outline in your head, and then specific pieces of code manually. You might not "execute" them, but analyze them for errors, but its a similar process, and debugging-bisection may actually be faster than that when you have no idea where the error is, IMO
15:04:52 <syntaxfree> Landmines are such a big issue.
15:05:02 <sbahra> Peaker, what do you use to debug your Haskell applications?
15:05:12 <sbahra> Peaker, yes, of course it is.
15:05:15 <Peaker> Philippa_: I am not yet comfortable with Parsec.. I also dislike monadic parsing, but regexps have sucky implementations anyway
15:05:28 <vixey> Peaker, what's bad about monadic parsing?
15:05:30 <sbahra> Peaker, but so far, I usually no where the errors are. Declarative languages are nice :-P
15:05:30 <syntaxfree> sbahra: it's Haskell. You can always write features from the inside out, gradually checking them.
15:05:31 <Peaker> sbahra: Debug.Trace and commenting out blocks of code, unfortunately :-(
15:05:45 <sbahra> syntaxfree, yes. I usually do this. A ghci session + text editor
15:05:50 <sbahra> Peaker, I see.
15:05:54 <Peaker> vixey: resulting parsers are necessarily non-optimal
15:06:11 <wli> Peaker: Arrow-based parsers?
15:06:18 <centrinia> @unlambda ```si`k``s.H``s.e``s.l``s.l``s.o``s.``s.w``s.o``s.r``s.l``s.d``s.!``sri``si``si``si``si``si``si``si``si`ki
15:06:19 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
15:06:22 <Peaker> wli: I haven't tried those, but those sound nicer
15:06:30 <Peaker> syntaxfree: then you make a bunch of changes, and it stops working - what do you do?
15:06:31 <vixey> Peaker, oh right, frisby uses unsafeCoerce to try and remedy that, and it makes GHC segfault on compile
15:06:48 <pumpkin> Peaker: why necessarily non-optimal?
15:07:23 <Peaker> vixey: I thought the problem with monadic parsing is the opaqueness of the (a -> m b) in bind, and (forall a. a) in return -- how does unsafeCoerce help against that?
15:07:54 <Peaker> pumpkin: because the grammar of the next parse may depend on the parse result of the previous parse, and it is impossible to determine when it is or is not the case in the general case
15:08:01 <pumpkin> ah
15:08:04 <vixey> um point here was that unsafeCoerce screwed everything up
15:08:30 <Peaker> pumpkin: so if I am getting this right: monadic parsers describe turing complete grammars, so if you parse less expressive grammars, you are not getting the best parser for the job
15:08:43 <IWannaLog> what is unsafeCoerce ?
15:08:45 <pumpkin> ah
15:08:48 <vixey> you could look at frisby src if you want but it's boring and crap
15:09:01 <vixey> (I'm saying this mostly because it uses unsafeCoerce)
15:09:07 <Saizan> ?hoogle unsafeCoerce
15:09:08 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:09:19 <rwbarton> unsafeCoerce is the Curry-Howard equivalent to proof by intimidation
15:09:34 * IWannaLog closes his eyes and try to forget.
15:09:54 <IWannaLog> Why did I ask ?
15:10:01 <IWannaLog> I'm crazy.
15:10:08 <Botje> deathwish :p
15:10:12 <Saizan> you're too curious for your own good
15:10:18 <Saizan> now we've to kill you
15:10:24 <Saizan> @slap IWannaLog
15:10:25 <lambdabot> go slap IWannaLog yourself
15:10:36 <IWannaLog> ...
15:10:37 <Olathe> @slap lambdabot
15:10:38 * lambdabot pokes lambdabot in the eye
15:10:42 <Peaker> lambdabot is disobedient today
15:11:35 <Peaker> sudo @slap IWannaLog
15:11:43 <IWannaLog> Is it: "He try", "He trys", "He tries" (maybe the first)
15:11:59 <astrobe> s/unsafe/evil/gc
15:12:27 <Peaker> astrobe: why isn't "g" default? what's 'c'?
15:12:29 <pumpkin> IWannaLog: last one
15:12:41 <IWannaLog> really ?
15:12:52 <Saizan> He patricia trees
15:12:58 <pumpkin> it's pretty rare to find a y followed by an s in english
15:13:02 <astrobe> Peaker: c=confirm.
15:13:14 <syntaxfree> @google *ys
15:13:14 <astrobe> ... confirm replacement
15:13:17 <lambdabot> http://en.wikipedia.org/wiki/Ys
15:13:17 <lambdabot> Title: Ys - Wikipedia, the free encyclopedia
15:13:20 <pumpkin> monkeys, trolleys are the only ones I can thikn of
15:13:23 <IWannaLog> pumpkin: yes for that trys looks very ugly
15:13:29 <Olathe> tryst
15:13:46 <pumpkin> YSL
15:14:10 <rwbarton> He buys, he says
15:14:15 <pumpkin> mais il est mort
15:14:22 <IWannaLog> pumpkin: who ?
15:14:25 <pumpkin> YSL
15:14:30 <chrisdone> unsafeAskTooManyQuestions
15:14:34 <syntaxfree> Ys, also spelled Is or Ker-Is in Breton, and Ker-Ys in French (ker means city in Breton), is a mythical city that was built on the coast of Brittany and later swallowed by the ocean. Most versions of the legend place the city in the Douarnenez Bay.
15:14:43 <RayNbow> @users
15:14:44 <lambdabot> Maximum users seen in #haskell: 596, currently: 596 (100.0%), active: 28 (4.7%)
15:14:49 <RayNbow> nice
15:14:55 <RayNbow> only 4 to go for 600 :)
15:15:00 <syntaxfree> 4.7% active.
15:15:00 <pumpkin> omg!
15:15:08 <pumpkin> let's spam other channels
15:15:09 <syntaxfree> Might as well be a lot of people with screen.
15:15:12 <pumpkin> to try to get them up!
15:15:28 <centrinia> Tryptamines I have Known and Loved. :)
15:15:31 * wli is IRC'ing from within screen(1).
15:15:40 <Olathe> , zomg
15:15:46 <andrewsw> I'm starting to like dtach
15:15:48 <lunabot>  luna: Not in scope: `zomg'
15:15:52 <Olathe> @users
15:15:52 <lambdabot> Maximum users seen in #haskell: 596, currently: 596 (100.0%), active: 30 (5.0%)
15:15:58 <centrinia> Wow.
15:15:59 <syntaxfree> pumpkin: it's enough to troll so they /whois you.
15:16:14 <IWannaLog> Just a unsafeQuestion. What's the proportion between Linux users and windows users in this forum ?
15:16:26 <pumpkin> IWannaLog: what about other OSes? :(
15:16:44 <syntaxfree> hahaha. I've been a Mac user since late 2005.
15:16:47 <IWannaLog> I don(t know (to lazy to write them all)
15:16:49 <syntaxfree> make that mid-2005.
15:16:49 <Olathe> We all use xmonad on Linux, of course.
15:17:02 <Olathe> Quits ?!
15:17:05 <syntaxfree> before that, I was a Gentoo kiddie. Good years of fun.
15:17:21 <andrewsw> xmonad/linux
15:17:28 * Peaker ought to give xmonad a try sometime
15:17:55 <IWannaLog> Peaker: if you're on a Mac you'll cry
15:18:00 <andrewsw> what is the proper order: debian gnu/linux xmonad? xmonad gnu/linux a la debian?
15:18:01 <Olathe> "try sometime"
15:18:09 * syntaxfree wonders what is { x in screen, x not in dtach}
15:18:27 <centrinia> I wish to ween myself off of using operating systems for some tasks in the near future.
15:18:34 <pumpkin> now this is a car http://www.blogcdn.com/www.engadget.com/media/2008/12/eliica12-29.jpg
15:18:36 <pumpkin> whoops
15:18:41 <Peaker> IWannaLog: I don't like Apple software
15:18:53 <Peaker> IWannaLog: except for the nice animations, sexy
15:18:59 <Olathe> pumpkin: Yeah, look at those three streetlamps that come included.
15:19:01 <sbahra> <- FreeBSD
15:19:11 <sbahra> FreeBSD/xmonad
15:19:19 <andrewsw> syntaxfree: dtach is only the detach portion of screen, nothing more
15:19:26 <Olathe> OMG. Four streetlamps attached to the car.
15:19:38 <IWannaLog> Peaker: which nice animations ? There is no sexy thing on my mac (except my mac himself)
15:19:41 <syntaxfree> centrinia: that's actually not a bad idea. we should have more dedicated environments. OSes keep on sucking most of the extra juice added to computers year after year.
15:20:17 <Peaker> IWannaLog: everything animates, nothing quirks on screen
15:20:20 <BMeph> IWannaLog: Don't you mean, if (one of us) is on a Mac, _YOU_'ll cry? ;p
15:20:26 <syntaxfree> you will have to take my macbook from my cold, dead hands. I wish I could get my work computer to do fast simulation, programmed in batch.
15:20:39 <IWannaLog> BMeph: xmonad on a Mac makes me crying
15:20:52 <centrinia> I have been investigating Pistachio for dedicated execution of some of my programs.
15:20:59 <centrinia> That's one of the L4 implementations.
15:21:00 <osfameron> is xmonad on mac X only?
15:21:08 <centrinia> osfameron, no.
15:21:14 <andrewsw> xmonad on a mac is a triumph of function over form?
15:21:31 <syntaxfree> actually, what's the point of a window manager other than what comes with Apple's X11?
15:21:35 <IWannaLog> andrewsw: xmonad on a mac is a horrible thing
15:21:50 <syntaxfree> I only use X11 when I run Stata on Darwine.
15:21:59 <allbery_b> hm?  xmonad isn't available as a native aqua package, no, nor can it be (system makes no provision to replace WindowServer(
15:21:59 <osfameron> it would be nice if Mac had a decent window manager
15:22:04 <IWannaLog> syntaxfree: manage the gime windows
15:22:21 <syntaxfree> it would be nice if OS X had a few window manager features it's missing, yes.
15:22:23 <BMeph> IWannaLog: I use arch linux by VMWare on my company's Windows comp. Can I answer "Yes!" to your survey? ;p
15:22:41 <IWannaLog> allbery_b: you compile it, it's compiles with no problem (... damned don't use the version 10 of ghc)
15:22:48 <syntaxfree> it's also lacking in keyboard shortcuts.
15:23:11 <schme_> But it makes good coffee!
15:23:15 <IWannaLog> osfameron: finder is the most functional window manager
15:23:29 <sjanssen> IWannaLog: lol
15:23:40 <astrobe> I use dwm: wmonad without the haskell crap :D
15:23:41 <syntaxfree> but OS X makes the NeXTstep dream real. You can pick an image out of its window title and drag it to a document and it will work.
15:23:42 <centrinia> Does Aqua run on any toasters yet?
15:23:55 <syntaxfree> you can select text and drag it and it will work. etc. etc.
15:23:59 <osfameron> IWannaLog: finder isn't a window manager is it?
15:24:03 <syntaxfree> not to mention Services.
15:24:12 * BMeph wonders if dmwit is working on a
15:24:12 <sjanssen> syntaxfree: all desktop environments have been doing drag and drop for ages
15:24:20 <syntaxfree> I don't think there's any Linux-based environment that has anything as powerful as Services.
15:24:32 <osfameron> what's Services?
15:24:36 <syntaxfree> sjanssen: drag-and-drop is patchy at beast in Windows.
15:24:36 <centrinia> killall WindowServer
15:24:50 * BMeph continues: a 'dwmit' module? ;)
15:24:59 <pumpkin> the dmwit module is awesome
15:25:09 <syntaxfree> s/beast/best
15:25:21 * Philippa_ suspects a House Toaster might get misunderstood...
15:25:26 <BMeph> pumpkin: I prefer CaleOS myself. ;p
15:25:33 <IWannaLog> osfameron: I always think (and don't want to change my mind) that finder is the window manager
15:25:40 <pumpkin> BMeph: written in Caleskell?
15:25:51 <IWannaLog> before mac os x it was more, but today it's just a window manager
15:26:14 <osfameron> I thought it was the file manager
15:26:20 <BMeph> pumpkin: Written in Caleskell: The Next Generation! ;p
15:26:22 <syntaxfree> Finder is the file manager.
15:26:32 <IWannaLog> osfameron: yes there is a builtin file manager
15:26:33 <syntaxfree> I find myself doing much file managing on the terminal anyway.
15:26:35 <British0zzy> how can one create an array from a list?
15:26:45 <IWannaLog> .ToArray()
15:26:49 <IWannaLog> .net spirit
15:26:51 <syntaxfree> gah, now "Cities of the future" started playing in my head.
15:26:52 <pumpkin> fromList
15:26:53 <sjanssen> British0zzy: listArray
15:26:57 <pumpkin> oh whoops
15:26:57 <BMeph> British0zzy: Er, listArray, maybe? ;p
15:27:06 <lispy> :t listArray
15:27:07 * syntaxfree found himself... running away ... never wanting to go back again..
15:27:07 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
15:27:25 <lispy> be free syntaxfree!
15:27:32 <lispy> :t free
15:27:33 <lambdabot> Not in scope: `free'
15:27:38 <centrinia> @pl \x -> listArray (0,length x - 1) x
15:27:39 <lambdabot> listArray =<< (,) 0 . subtract 1 . length
15:27:42 <centrinia> There. :)
15:27:46 <lispy> Oh no, Haskell has memory leak, no free function!
15:27:59 <syntaxfree> Until I was 20 or so, my standard internet handle was "recorded_syntax".
15:28:00 <sjanssen> @remember lispy Oh no, Haskell has memory leak, no free function!
15:28:00 <lambdabot> Okay.
15:28:10 <sjanssen> lispy: also, you're wrong -- see Foreign.* :)
15:28:15 <lispy> sjanssen: ;)
15:28:21 <syntaxfree> after the June of 44's "Recorded Syntax".
15:28:28 <IWannaLog> Ha firefox is horrible on mac
15:28:36 <syntaxfree> syntaxfree comes from Sonic Youth's "The Ineffable Me".
15:28:41 <pizza_> define horrible
15:28:41 <IWannaLog> I close all the windows except filezilla and I dn
15:28:47 <syntaxfree> IWannaLog only in that it's vastly inferior to Safari.
15:28:55 <IWannaLog> don't know how to open a new one
15:29:11 <IWannaLog> sorry without a new browser page I can't translate horrible
15:29:21 <sjanssen> everyone, I think we're drifting a little too far off topic.  #haskell-blah is over there -->
15:29:25 <IWannaLog> terrible but it means something which is scarry
15:29:27 <centrinia> IWannaLog, the menu bar is still there.
15:29:48 <British0zzy> ok, if i have a [Matrix Double] and I want to make it an array, how do i do that?
15:29:49 <syntaxfree> @google define:horrible
15:29:52 <lambdabot> No Result Found.
15:30:02 <IWannaLog> centrinia: there is no more new pag entry
15:30:06 <British0zzy> the documentation confuses me
15:30:12 <IWannaLog> haaaaaaaaaaaaaa
15:30:13 <sjanssen> British0zzy: listArray (lowbound, highbound) theListOfMatrixDoubles
15:30:23 <British0zzy> whats lowbound?
15:30:31 <pumpkin> your lowest index
15:30:46 <sjanssen> British0zzy: the lowest index, and you get to choose what that is (0, 1, whatever)
15:30:57 <British0zzy> oh, i see... thanks
15:31:25 <nanothief> I have a search function that I use for two main purposes: for finding the first value, and for finding all values. Currently the function returns [a]. Should I make the function return MonadPlus m -> m a, or leave it the way it is?
15:31:27 * syntaxfree wishes there was an irc channel to chat about quant finance.
15:31:29 <IWannaLog> but horribles exists in english
15:31:53 <syntaxfree> IWannaLog: please don't say anything if you don
15:32:00 <syntaxfree> 't have anything to say.
15:32:02 <mmorrow> , let mkA :: [a] -> Array Int a; mkA xs = listArray (0,length xs - 1) xs in mkA [0..4::Double]
15:32:06 <lunabot>  array (0,4) [(0,0.0),(1,1.0),(2,2.0),(3,3.0),(4,4.0)]
15:32:16 <IWannaLog> syntaxfree: what ?
15:32:28 <syntaxfree> join the lines there.
15:32:54 <IWannaLog> ok I refuse to answer
15:33:16 <BMeph> syntaxfree: You _do_ know the name of my blog, don't you? :)
15:33:19 <centrinia> > listArray ((0,0),(3,4)) [0..]
15:33:20 <lambdabot>   array ((0,0),(3,4)) [((0,0),0),((0,1),1),((0,2),2),((0,3),3),((0,4),4),((1,...
15:33:33 <nanothief> or should I use Monoid instead of MonadPlus?
15:33:45 <lispy> Or MonoidPlus?
15:33:51 <syntaxfree> BMeph: I didn't even know you were a sentient being.
15:34:01 <nanothief> lispy: there is a MonoidPlus?
15:34:08 <lispy> syntaxfree: you don't have to be sentient to have a blog it would seem
15:34:19 <lispy> nanothief: not that I'm aware of, I was just teasing :)
15:34:27 <nanothief> hehe :P
15:34:36 * nanothief goes off to write MonoidPlus
15:34:37 <mmorrow> nanothief: if there's the possibility that both could be useful, make a function for each (one for Monoid, one for MonadPlus)
15:34:38 <syntaxfree> lispy: no, but you need to be sentient to have delusions of reference.
15:34:47 <sjanssen> nanothief: [a] seems fine, I'd only use MonadPlus if you plan to use the generality
15:34:49 <syntaxfree> I posit that sentience is a necessary condition for psychosis..
15:35:16 <mmorrow> since if something is an instance of both, chances are that mappend and mplus will be orthogonal
15:35:23 <mmorrow> (orthogonal in something)
15:35:34 <nanothief> sjanssen, the main reason I was thinking about it is in numerous places in my code I'm using listToMaybe, which is a bit tedious
15:35:39 <centrinia> Is there a function toMonadPlus :: (MonadPlus m) => [a] -> m a ?
15:35:40 <vixey> I don't understand eta NbE at all :(
15:35:44 <sbahra> :t listToMaybe
15:35:45 <lambdabot> forall a. [a] -> Maybe a
15:35:54 <sjanssen> nanothief: oh, in that case using MonadPlus would be very reasonable
15:35:57 <sbahra> > listToMaybe [1 .. 10]
15:35:59 <lambdabot>   Just 1
15:36:02 <BMeph> syntaxfree, lispy: In my opinion, psychosis is all in your head! ;p
15:36:05 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
15:36:07 <lambdabot>  Defined.
15:36:17 <mmorrow> @type list mzero return
15:36:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
15:36:27 <mmorrow> > list mzero return [0..]
15:36:29 <lambdabot>       No instance for (Enum (m a))
15:36:29 <lambdabot>        arising from the arithmetic sequenc...
15:36:31 <IWannaLog> @hoogle :t sequence
15:36:32 <lambdabot> Parse error:
15:36:32 <lambdabot>   --count=20 ":t sequence"
15:36:32 <lambdabot>              ^
15:36:37 <mmorrow> heh, oops
15:36:39 <IWannaLog> :t sequence
15:36:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:36:47 <mmorrow> > list mzero (return . const) [0..]
15:36:48 <lambdabot>       Overlapping instances for Show (b -> t1)
15:36:48 <lambdabot>        arising from a use of `...
15:36:55 <IWannaLog> :t sequence_
15:36:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:36:58 <mmorrow> > list mzero (\x -> return) [0..]
15:37:00 <lambdabot>       No instance for (Show (m [t1]))
15:37:00 <lambdabot>        arising from a use of `show' at ...
15:37:05 <syntaxfree> BMeph: actually, a tautology can't really be an opinion, regardless of how entertaining the wording is.
15:37:05 <mmorrow> curses!
15:37:06 <mmorrow> > list mzero (\x _ -> return) [0..]
15:37:07 <lambdabot>       Overlapping instances for Show (a -> m a)
15:37:07 <lambdabot>        arising from a use of ...
15:37:10 * lispy really wishes for lambdabot errors to be 1 line again
15:37:13 <mmorrow> ok kill
15:37:14 <nanothief> sjanssen, also, I don't get the difference between Monoid and MonadPlus. Either could work I think
15:37:24 <mmorrow> > list mzero (\x _ -> return x) [0..]
15:37:25 <lambdabot>       No instance for (Show (m t1))
15:37:25 <lambdabot>        arising from a use of `show' at <i...
15:37:32 <mmorrow> > list mzero (\x _ -> return x) [0..] :: Maybe Integer
15:37:34 <lambdabot>   Just 0
15:37:38 <mmorrow> wow
15:37:52 * mmorrow takes a break to catch his breath
15:37:55 <centrinia> > let list' =  sequence .map return in list' [1..3]  :: Maybe Int
15:37:56 <lambdabot>   Couldn't match expected type `Int' against inferred type `[t]'
15:37:59 <sjanssen> nanothief: the most important difference here is that Monad has return, Monoid doesn't
15:38:16 <centrinia> :t let list' =  sequence . map return in list'
15:38:17 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m [a]
15:38:18 <lispy> ?tell Gwern Dear Gwern, lambdabot error messages are too long.  Please consider shortening them all to one line.  Yours truly, Lispy
15:38:19 <lambdabot> Consider it noted.
15:38:32 <lispy> I hope that capitalzation of Gwern doesn't screw that up
15:38:40 <centrinia> :t let list' =  list . map return in list'
15:38:41 <lambdabot> forall a t1 (m :: * -> *). (Monad m) => [a] -> (t1 -> [t1] -> [m a]) -> [t1] -> [m a]
15:38:55 <ddarius> lispy: And by lambdabot you mean mueval?
15:38:56 <centrinia> :t let list' =  list mzero return . map return in list'
15:38:57 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
15:39:01 <IWannaLog> isn't monadplus an instance of monoid ?
15:39:11 <centrinia> :t let list' =  list mzero return . map return in list' [1..3] :: Maybe Int
15:39:12 <lambdabot> Maybe Int
15:39:15 <sjanssen> IWannaLog: no, classes aren't instances of classes
15:39:19 <centrinia> > let list' =  list mzero return . map return in list' [1..3] :: Maybe Int
15:39:19 <lispy> ddarius: meh, I only program to the interface not the implementation ;)
15:39:20 <lambdabot>   Just 1
15:39:24 <centrinia> Okay. :)
15:39:31 <mmorrow> > maybe [] (:[]) . list Nothing ((Just .) . const) $ [0..]
15:39:32 <lambdabot>   [0]
15:39:35 <IWannaLog> sjanssen: if I got a monadplus, is it  a monoid ?
15:39:41 <IWannaLog> for haskell (not for me)
15:39:55 <mmorrow> @type maybe mzero return
15:39:56 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
15:40:07 <sjanssen> IWannaLog: give then MonadPlus operations, you can write a Monoid instance
15:40:07 <mmorrow> @type list mzero ((return .) . const)
15:40:08 <lambdabot> forall (m :: * -> *) t1. (MonadPlus m) => [t1] -> m t1
15:40:17 <sjanssen> s/give/given
15:41:08 <mapreduce> @hoogle [a] -> ([a] -> b) -> [b]
15:41:09 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
15:41:09 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
15:41:09 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t d -> q) -> d -> q
15:41:15 <IWannaLog> mpplus and mzero are my operations
15:41:52 <sjanssen> IWannaLog: there are some Monoid instances that don't match their MonadPlus instances, like Maybe for example
15:42:06 <BMeph> sjanssen, IWannaLog: You can try, but it'll conflict, likely. :)
15:42:21 <BMeph> sjanssen: Maybe has a Monoid instance? =8*O
15:42:27 <IWannaLog> sjanssen: what do you mean by that ?
15:43:20 <mmorrow> IWannaLog: MonadPlus does not imply (i.e. provide an instance for from the point of view of ghc) Monoid, nor vice versa
15:43:30 <mmorrow> the "=>" goes "the other way"
15:43:52 * mmorrow was confused about this point at first also
15:43:59 <nanothief> sjanssen, I get the distinction now, there is no method for turning a value into a Monoid, while there is for MonadPlus. I'll probably stick with MonadPlus then
15:44:06 <mpwd> mmorrow: I think every MonadPlus could be an instance of a monoid...
15:44:09 <sjanssen> nanothief: exactly
15:44:15 <BMeph> mmorrow: What's 'list'? :)
15:44:19 <sjanssen> mpwd: yes.  Could be, but isn't
15:44:22 <mmorrow> *but*, you can simply write the Monoid instance for the MonadPlus
15:44:33 <mmorrow> BMeph: it's the list cata
15:44:51 <sjanssen> mmorrow: isn't foldr the list cata?
15:44:51 <BMeph> mmorrow: There's just one? ;p
15:44:57 <mmorrow> it's the recursive one
15:45:00 <mmorrow> just fix list
15:45:04 <mmorrow> to get foldr
15:45:23 <gweiqi> what does cata mean?
15:45:23 <sjanssen> hmm
15:45:27 <pumpkin> catamorphism
15:45:36 <vixey> gweiqi, I think it basically means down
15:45:36 <IWannaLog> mmorrow: it's like Monad doesn't provide implementation for Functor (or I'm wrong)
15:45:42 <vixey> gweiqi, in greek or something
15:45:45 <gweiqi> vixey: ah, thanks
15:45:49 <mpwd> sjanssen: Well, the burden of class instantiation is mostly on the programmer.  Ideally, the programmer is sitting around maybe proving the Monad laws are obeyed every time he instantiates one.
15:46:09 <mmorrow> IWannaLog: exactly, the arrow isn't "implication and yes that means the code exists too"
15:46:41 <gweiqi> pumpkin: so is catamorphism one of the fancy words when describing algebras?
15:47:07 <IWannaLog> I don't see links between catamorphism and algebra
15:47:20 * vixey still doesn't have a clue what an algebra is
15:47:40 <ddarius> vixey: There are so many meanings to choose from, how can you not have one.
15:47:43 <ddarius> ?
15:48:08 <vixey> ddarius, well I think I just phased out everytime I tried to read about it
15:48:12 <gweiqi> IWannaLog: http://en.wikipedia.org/wiki/Catamorphism
15:48:17 <mmorrow> foldr f = fix (\k z xs -> list z (\x xs -> f x (k z xs)))
15:48:27 <mmorrow> foldr f = fix (\k z -> list z (\x xs -> f x (k z xs)))
15:48:30 <mmorrow> i meant
15:48:35 <gweiqi> IWannaLog: lots of algebra for you
15:49:11 <mmorrow> > fix (\k f z -> list z (\x xs -> f x (k f z xs))) (:) [] [0..4]
15:49:12 <lambdabot>   [0,1,2,3,4]
15:49:21 <IWannaLog> gweiqi: sory for me algebra is http://en.wikipedia.org/wiki/Algebra_over_a_field
15:49:30 <ddarius> vixey: The notion of algebra relevant here, F-algebra for some functor F, is simply an arrow of the form FA -> A.
15:49:38 <mmorrow> > fix (\k f z -> list z (\x xs -> k f (f z x) xs))) (+) 0 [0..4]
15:49:40 <lambdabot>   <no location info>: parse error on input `)'
15:49:44 <mmorrow> > fix (\k f z -> list z (\x xs -> k f (f z x) xs)) (+) 0 [0..4]
15:49:45 <lambdabot>   10
15:49:53 <ddarius> IWannaLog: "Algebra" is an extremely overloaded term in mathematics.
15:49:56 <mmorrow> foldl = fix (\k f z -> list z (\x xs -> k f (f z x) xs))
15:50:05 <mmorrow> foldr = fix (\k f z -> list z (\x xs -> f x (k f z xs)))
15:50:18 <vixey> ddarius, so like,, fromJust? I'm confused ..
15:50:33 <IWannaLog> ddarius: I know but in my country matheùaticians are nice people and use it only for the link I  gave
15:50:48 <IWannaLog> we talk about algebraic strucure in the general case
15:51:05 <centrinia> If I wanted to evaluate a combinatory logic expression by performing pattern matches and transformations of its corresponding binary tree, is that considered to be graph reduction?
15:51:12 * vixey hmm .maybe I should go to france to study math
15:51:20 <ddarius> IWannaLog: Do you have a branch of mathematics referred to generally as "algebra"?
15:51:32 <IWannaLog> yes
15:51:39 <ddarius> vixey: Any function.
15:51:51 <ddarius> vixey: fromJust would count, albeit it is not a particularly nice choice.
15:51:55 <IWannaLog> algebra which is the theory of everything you can write with formula and expression
15:52:10 <IWannaLog> but an algebra is a specific structure
15:52:12 <pumpkin> not the analysis of mathematical structures?
15:52:49 <IWannaLog> pumpkin: it's just a word which could means everything you want
15:52:55 <vixey> why is FA -> A fundamental?
15:53:10 <pumpkin> IWannaLog: yeah, but if people didn't agree on word meanings, communication could be hard :P
15:53:18 <ddarius> vixey: What do you mean by "fundamental" and why do you think it is fundamental?
15:53:21 <centrinia> IWannaLog, do the mathematicians in your country consider rings that are not fields to be algebras?
15:53:33 <syntaxfree> an algebra can mean different things in different contexts.
15:53:33 <vixey> ddarius, I can't imagine people making a theory of stuff like fromJust though
15:53:38 <IWannaLog> centrinia: no
15:53:47 <centrinia> That's weird.
15:53:52 <IWannaLog> centrinia: yes some times
15:53:53 <syntaxfree> the algebras and sigma-algebras of measure theory are a different thing atogether
15:54:00 <centrinia> Which country are you in?
15:54:07 <IWannaLog> no no algebra is not a rign
15:54:13 <IWannaLog> centrinia: whois
15:54:35 <vixey> I probably wont really get this unless it comes up naturally in something I'm thinking about
15:57:24 * SamB didn't think that fromJust really fit the theory ...
15:57:56 <ddarius> SamB: There's no problem with having partial functions in a category of sets and partial functions.
15:58:15 <SamB> I suppose not.
15:58:37 <SamB> but I don't suppose I'd much like to debug such a category!
15:59:57 <astrobe> "Polysemy considered harmful"
16:01:27 <ehird> "How can static analysis know what type of things are in an arbitrary list? " <-- Oh dear...
16:02:28 <pumpkin> :o
16:02:56 <Saizan> it can't..
16:03:53 <dons> ehird: hehe. 'arbitrary list' eh?
16:04:04 <ehird> dons: from this thread--http://www.reddit.com/r/programming/comments/7mgrr/haskell_for_c_programmers/734x
16:04:07 <dons> watching heads asplode is fun
16:04:16 <ehird> poor confuzzled newbie.
16:04:17 <chrisdone> dons: aha, agreed
16:04:39 * chrisdone awaits C for Haskell programmers
16:05:02 <SamB> heh
16:05:33 <ehird> chrisdone: I saw that comment :-)
16:05:35 <ehird> I want to write that.
16:05:45 <wjt> ehird: haha
16:05:47 <Peaker> chrisdone: heh
16:06:07 * wjt had to write string manipulation stuff in C today :'(
16:06:10 <ehird> "In C, there is an odd restriction that your lists must be of finite size."
16:06:19 <ehird> (Well, not true.)
16:06:24 <ehird> (Arrays, sure.)
16:06:35 <ehird> (But then, Haskell tutorials paint [] as Haskell's version of C arrays.)
16:07:22 <chrisdone> ha, dons
16:07:48 <ehird> "OK, good. I'm glad I'm not the only one. I was about halfway through the first page when I started thinking that Haskell was actually a practical joke. Apparently the tutorial is just that hard to understand. "
16:07:52 <ehird> *phew* He almost figured us out.
16:08:03 <chrisdone> haha
16:09:28 <astrobe> ehird: arrays may be infinite, or of unspecified size, eg int *Array
16:09:29 <chrisdone> I explained the memoized fibs definition to a bunch of python-y-perl-y chaps and they got it easily
16:09:38 <ehird> astrobe: hehe :-)
16:10:28 <ehird> "Instead of cleanly separating side effects using the IO monad, it all happens in the same context as the logic, thus leading to unintended side-effects and spaghetti code."
16:10:39 <ehird> "This can make C a very hard language to grasp."
16:10:42 <chrisdone> it's one of those "this computes fibonacci" and then a load of people, who usually aren't interested in talk of haskell, going "..wait."
16:10:49 <ddarius> ehird: http://haskell.org/definition/haskell-report-1.0.ps.gz   Note the date.
16:12:06 <ehird> ddarius: What about it? :-)
16:13:06 <mmorrow> @let tree node (Node x xs) = node x xs
16:13:08 <lambdabot>  Defined.
16:13:56 <mmorrow> @let tfoldl = fix (\k f -> tree (foldl (\a b -> f a (k f b))))
16:13:58 <lambdabot>  Defined.
16:14:49 <ehird> :t Node
16:14:50 <lambdabot> forall a. a -> Forest a -> Tree a
16:14:54 <Cale> ehird: If Haskell tutorial paint [] as similar to C arrays, they're failing miserably to convey what lists are.
16:14:58 <Cale> tutorials*
16:15:09 <ehird> Cale: they often say "This in C is this in haskell"
16:15:16 <ehird> where the c uses arrays and the haskell uses []
16:15:25 <mmorrow> > tfoldl (+) (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:15:26 <lambdabot>   95
16:15:34 <ddarius> So they need to specify "idiomatic translation"
16:15:43 <ehird> well yeah :)
16:17:45 <mmorrow> hmm, i think that tfoldl isn't what "tfoldl" should be
16:18:06 <mmorrow> whoa
16:18:20 <mmorrow> @type let tfoldr = fix (\k f -> tree (foldl (\a b -> k f (f a b)))) in tfoldr
16:18:22 <lambdabot> forall t. (t -> Tree t -> Tree t) -> Tree t -> t
16:18:33 <mmorrow> @type let tfoldl = fix (\k f -> tree (foldr (\a b -> k f (f a b)))) in tfoldl
16:18:34 <lambdabot> forall t. (Tree t -> t -> Tree t) -> Tree t -> t
16:18:38 * ksf is becoming unsure about whether there really is a difference between denotational and operational semantics.
16:19:06 <ddarius> ksf: There is, but it isn't as great as many people seem to believe.
16:19:15 <wli> ksf: When there is no difference, the language is fully abstract. Otherwise, it's not fully abstract.
16:19:24 <ksf> or, rather, denotational semantics and how stuff is best done according to it.
16:21:40 <ksf> I guesstimate the main difference to be between a dependently defined time axis and a fixed time axis.
16:24:23 * robyonrails goodnight
16:27:54 <mmorrow> @let foldlT = fix (\k f z -> tree (\x -> foldl (\a b -> k f a b) (f z x)))
16:27:55 <lambdabot>  Defined.
16:27:59 <mmorrow> @type foldlT
16:28:01 <lambdabot> forall a t. (a -> t -> a) -> a -> Tree t -> a
16:28:34 <mmorrow> > foldlT (+) 0 (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:28:36 <lambdabot>   95
16:29:25 <mmorrow> > foldlT (flip (:)) [] (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:29:26 <lambdabot>   [6,12,35,42]
16:34:01 <mmorrow> hmm, foldrT is tricky
16:34:22 <mmorrow> maybe because i'm trying to morph foldlT into it rather than standing back and thinking about it first
16:37:03 <chessguy_> @src State
16:37:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:38:56 <Peaker> @src Traversable
16:38:56 <lambdabot> class (Functor t, Foldable t) => Traversable t where
16:38:56 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
16:38:56 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
16:38:56 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
16:38:58 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
16:39:41 <Peaker> @src Foldable
16:39:41 <lambdabot> Source not found. It can only be attributed to human error.
16:39:42 <ski_> @type let foldrT f z (Node a tas) = f a (foldr (\ta z -> foldrT f z ta) z tas) in foldrT
16:39:43 <lambdabot> forall t b. (t -> b -> b) -> b -> Tree t -> b
16:40:11 <ski_> > let foldrT f z (Node a tas) = f a (foldr (\ta z -> foldrT f z ta) z tas) in foldrT (:) [] (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:40:13 <lambdabot>   [42,35,12,6]
16:40:18 <mmorrow> woot
16:40:26 <mmorrow> oh beat me :)
16:40:32 <ski_> 's that what you were looking for ?
16:40:34 <mmorrow> @type let foldrT = fix (\k f z -> tree (\x -> foldr (\t b -> f x (k f b t)) z)) in foldrT
16:40:35 <lambdabot> forall t b. (t -> b -> b) -> b -> Tree t -> b
16:40:42 <mmorrow> exactly :)
16:40:43 <chessguy_> @hoogle tell
16:40:43 <lambdabot> Control.Monad.Writer.Class tell :: MonadWriter w m => w -> m ()
16:40:43 <lambdabot> System.IO hTell :: Handle -> IO Integer
16:41:20 <ski_> > let foldrT = fix (\k f z -> tree (\x -> foldr (\t b -> f x (k f b t)) z)) in foldrT (:) [] (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:41:22 <lambdabot>   [42,42,12]
16:42:06 <Peaker> why does Foldable have "fold" instead of toList (used with mconcat . toList)?
16:42:27 <mmorrow> you get toList for free if you have fold
16:42:57 <Peaker> mmorrow: yeah, but why is fold more fundumental than toList?
16:43:27 <Peaker> mmorrow: toList basically expresses iteration, and seems more flexible?
16:43:30 <mmorrow> because toList = fold with list's catamorphism
16:43:38 <Peaker> s/more flexible/easier to use flexibly
16:43:47 <mmorrow> > foldlT (flip (:)) [] (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:43:48 <lambdabot>   [6,12,35,42]
16:43:56 <ski_> .. ohh
16:44:09 <ski_> no i see why 'twas dropping elems
16:44:13 <ski_> s//w/
16:44:14 <mmorrow> > foldrT (:) [] (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:44:15 <lambdabot>   Not in scope: `foldrT'
16:44:24 <mmorrow> foldlT = fix (\k f z -> tree (\x -> foldl (\a b -> k f a b) (f z x)))
16:44:24 <mmorrow> foldrT = fix (\k f z -> tree (\x -> foldr (\t b -> f x (k f b t)) z))
16:44:32 <mmorrow> @let foldrT = fix (\k f z -> tree (\x -> foldr (\t b -> f x (k f b t)) z))
16:44:34 <lambdabot>  Defined.
16:44:36 <mmorrow> > foldrT (:) [] (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:44:38 <lambdabot>   [42,42,12]
16:44:52 <mmorrow> and there isn't just one toList for trees
16:44:58 <Peaker> [42,42,12]?
16:44:59 <ski_> you shouldn't put `f x' inside the `foldr'
16:45:03 <mmorrow> hmm, yeah
16:45:12 <mmorrow> crap!
16:46:05 <Peaker> mmorrow: I guess Foldable has bidirectional folding that may be more space efficient than toList followed by a foldl or so
16:46:20 <ski_> (.. or rather inside the `cons' argument to `foldr')
16:46:48 <mmorrow> @type foldrT = fix (\k f z -> tree (\x -> f x . foldr (\t b -> k f b t) z)) in foldrT
16:46:50 <lambdabot> parse error on input `='
16:46:55 <mmorrow> @type let foldrT = fix (\k f z -> tree (\x -> f x . foldr (\t b -> k f b t) z)) in foldrT
16:46:56 <lambdabot> forall t c. (t -> c -> c) -> c -> Tree t -> c
16:47:12 <ski_> looks better
16:47:21 <mmorrow> > let foldrT = fix (\k f z -> tree (\x -> f x . foldr (\t b -> k f b t) z)) in foldrT (:) [] (Node 42 [Node 35 [], Node 12 [Node 6 []]])
16:47:22 <lambdabot>   [42,35,12,6]
16:47:34 <mmorrow> too bad you can't selectively @undefined
16:48:18 <mmorrow> Peaker: and i guess also that which way to fold a particular structure may also depend on what type the function you're folding with produces
16:48:29 <Peaker> not all folds are like list folds (basically mconcat), though, some things may be Foldable but have more data constructors
16:48:32 <mmorrow> like eg foldl (+) 0 and foldr (:) [] with lists
16:49:25 <mmorrow> Peaker: totally, and in those cases toList starts to get fuzzy
16:49:51 <mmorrow> nice, so
16:49:52 <mmorrow> foldlT = fix (\k f z -> tree (\x -> foldl (\a b -> k f a b) (f z x)))
16:49:53 <mmorrow> foldrT = fix (\k f z -> tree (\x -> f x . foldr (\t b -> k f b t) z))
16:50:18 <Peaker> mmorrow: but also fold :: Monoid m => t m -> m
16:50:22 <mmorrow> i guess unpl'ing it'll make the syntax symmetric
16:50:40 <Peaker> mmorrow: I think that fold function is essentially equivalent to toList in expressiveness
16:50:44 <Raevel> is someone familiar with ParseArgs? I'm trying to set up a basic call to parseArgsIO, but i'm very confused
16:50:50 <Peaker> mmorrow: and just as problematic in the same cases
16:50:56 <mmorrow> Peaker: ooh true. i think that's what i got with my first attempt at foldlT
16:51:13 <mmorrow> tfoldl = fix (\k f -> tree (foldl (\a b -> f a (k f b))))
16:51:17 <mmorrow> @type tfoldl
16:51:18 <lambdabot> forall t. (t -> t -> t) -> Tree t -> t
16:51:22 <ski_> mmorrow,Peaker : what are you discussing about folds ?
16:51:43 <mmorrow> ski_: i think this all got started with how the list cata is
16:51:44 <Peaker> mmorrow: so my complaint maybe is that class Foldable is basically a class Enumerable or Listable, as it just supports list-folds
16:51:54 <mmorrow> list n _ [] = n; list _ c (x:xs) = c x xs
16:52:04 <Peaker> ski_: I was looking at Foldable and I don't think it is as general as the name suggests (not sure it could be)
16:52:05 <mmorrow> then you get foldr and foldl by just fixing list
16:52:16 <ski_> Peaker : agreed
16:52:22 <mmorrow> foldl = fix (\k f z -> list z (\x xs -> k f (f z x) xs))
16:52:22 <mmorrow> foldr = fix (\k f z -> list z (\x xs -> f x (k f z xs)))
16:52:42 <mmorrow> then i tried to figure it out for trees
16:52:50 <iago> Raevel, http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
16:53:03 <ski_> mmorrow : `list' is just a case-deconstruction .. what about it ?
16:53:10 <Peaker> ski_: would class Foldable f where toList :: f a -> [a]      be just as expressive as the class itself? http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
16:53:15 <mmorrow> ski_: it's the nonrecursive fold/cata
16:53:36 <mmorrow> just like maybe (which happens to be a degenerate case since Maybe isn't a recursive type)
16:53:45 <Peaker> ski_: and if so - isn't the class superfluous? (Just pass lists directly!)
16:54:47 <iago_> Raevel, ok sorry, I was confused ;P
16:54:58 <ski_> Peaker : i haven't actually thought close at `Foldable' .. but my first feeling was that it wasn't as good as could be expected (not sure why)
16:55:08 <Peaker> it seems like its trying to generalize list folds, where lazy lists are already generalized enumerators. My only doubt is about the foldl (foldl after toList is not the same as foldl directly on a data structure)?
16:56:02 <nanothief> what is the precendence of an infix function such as 3 `func` 4 ?
16:56:12 <Peaker> if I use toList on a tree, and then foldl, it has to build the entire list before starting to yield results, whereas a foldl on a tree may lazily yield results in O(1) memory, right?
16:56:27 <Peaker> nanothief: I don't know what the default is, but I'm pretty sure you can specify it
16:56:28 <mmorrow> all functions default to infixl 9 unless you give an explicit infix* .. decl
16:57:05 <nanothief> mmorrow, thanks
16:57:11 <ski_> Peaker : what is a "foldl on a tree" ?
16:57:23 <Peaker> ski_: well, the equivalent of foldl . toList  on that tree
16:57:41 <ski_> Peaker : `toList' using which traversal ordering ?
16:57:43 <mmorrow> Peaker: i'm not sure at first blush, but it'd be interesting to work out how... say type A is made up of B and C, then what is the relationship of the folds/catas of B and C wrt the fold/cata of A (or something along these lines)
16:58:12 <Peaker> ski_: preorder or inorder
16:58:31 <mmorrow> ooh, cool.. so
16:59:13 <Peaker> this is interesting, but its 3am... I'd love to get a @tell with explanation of whether my idea of why Foldable is useful is right, or if its some other thing
16:59:29 <Peaker> or I can check the logs tomorrow.. good night!
16:59:32 <mmorrow> enumerating the possible combinations of directions (e.g. foldr, foldl) for folds of B and C should give you all the directions that a fold of A can take
16:59:42 <mmorrow> roughly speaking
16:59:44 <Raevel> iago_: wasn't aware that GetOpt existed, i'm going to check it out, thanks :-)
16:59:58 <BMeph> @ty list
17:00:00 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
17:00:03 <mmorrow> Peaker: night
17:00:18 <ski_> Peaker : `foldlT' above surely has to traverse the whole tree for any output to be produced
17:01:56 <ski_> (Peaker : so "a foldl on a tree may lazily yield results in O(1) memory, right?" would probably be answered negatively)
17:02:00 <BMeph> mmorrow: Is that your defn. for 'list', or do you just (ab)use it? :)
17:02:23 * mmorrow takes notes with the intention of figuring out how to use TH to autogen all kinds of crap ;)
17:02:57 <mmorrow> BMeph: heh, that's mine, but i don't claim to have invented it :)
17:03:21 <mmorrow> i abuse it too, this is true ;)
17:03:30 * ski_ wrote a variant of `foldlT' that "traversed all branches simultaneously" (in some sense), but discovered it gave trivial results ..
17:03:48 <BMeph> mmorrow: That's fine. I was just wondering why the re-arrangement of arguments...to make it more like maybe/either, right? :)
17:03:50 <mmorrow> ski_: what do you mean by "trivial"?
17:04:00 <mmorrow> BMeph: exactly
17:04:14 <mmorrow> like, following the pattern, bool would be
17:04:16 <ski_> mmorrow : always returned empty list (well maybe not on partially defined trees, but ..)
17:04:26 <mmorrow> bool f _ False = f; bool _ t True = t
17:04:47 <mmorrow> @let bool f _ False = f; bool _ t True = t
17:04:49 <lambdabot>  Defined.
17:04:59 <mmorrow> @type bool
17:05:01 <lambdabot> forall t. t -> t -> Bool -> t
17:05:02 <mmorrow> @type maybe
17:05:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:05:06 <BMeph> mmorrow: Hmm, 'bool' is a sore spot to *cough* vixey! *cough*, er, ..."some". ;p
17:05:06 <mmorrow> @type either
17:05:07 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:05:08 <mmorrow> @type list
17:05:10 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
17:05:10 <mmorrow> @type tree
17:05:12 <lambdabot> forall t t1. (t -> Forest t -> t1) -> Tree t -> t1
17:05:18 <mmorrow> BMeph: heh
17:05:31 <mmorrow> vixey always flips thedward `f' and `t'!!
17:05:49 <mmorrow> hmm, don't remember typing "dward"
17:06:04 <BMeph> mmorrow: No, vixey flips the defn of Bool. Other than that, she's got it right. ;)
17:06:06 <ski_> @src Bool
17:06:07 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:06:13 <mmorrow> that's a way to say it
17:06:31 <BMeph> ski_: Yeah, vixey likes having True first. :)
17:06:57 * mmorrow winces everytime, then chuckles slightly, winces again
17:07:07 * ski_ is negative, so prefers to start at `False'
17:07:17 <ddarius> "deriving Ord"
17:07:19 <BMeph> From all the boning up on Scott numerals I've done this month, I can't say it's a bad idea. :)
17:08:54 <ski_> mmorrow : `Tree' is defined in terms of `[]' .. could you elaborate on how a fold on the latter would be translated into a fold on the former ?
17:10:58 <mmorrow> well you'd have to compose "tree" and "list" in an appropriate way, then fix
17:11:01 <zloog> Is it possible to have a case inside of a do expression or am I just doing it wrong?
17:11:09 <mauke> zloog: both
17:11:17 <mmorrow> ski_: i just prettied up those defs, pasting ...
17:11:30 <zloog> mauke: ? that was quick
17:11:57 <mmorrow> http://hpaste.org/13460
17:12:46 <mmorrow> ski_: but totally, i think it'd be super interesting to be able to anwer that question in the general case. especially for auto-generating/deriving code for folds/traversals for arbitrary datatypes
17:13:27 <mmorrow> given the appropriate foldl/traversal/info/whatever for a datatype's sub-pieces
17:13:49 <ski_> mmorrow : so i can replace `foldl' with `foldr' in the definition of `tfoldl' and get yet another variant ?
17:14:32 <mmorrow> ski_: ooh, yes. that too. it looks like there's all kinds of hybrids now that we have two folds (list and tree) to work with
17:14:37 <mmorrow> hmm
17:14:58 <BMeph> T a -> a x (1 + a x T a) -- is that right?
17:14:58 <ski_> @type let tfoldl = fix (\k f z -> tree (\x xs -> foldl (\a b -> k f a b) (f z x) xs)) in tfoldl
17:15:00 <lambdabot> forall a t. (a -> t -> a) -> a -> Tree t -> a
17:15:07 <ski_> @type let foldl = foldr; tfoldl = fix (\k f z -> tree (\x xs -> foldl (\a b -> k f a b) (f z x) xs)) in tfoldl
17:15:08 <lambdabot> forall t. (Tree t -> t -> Tree t) -> Tree t -> Tree t -> Tree t
17:15:11 <mmorrow> @type let foo = fix (\k f -> tree (foldr (\a b -> k f (f a b)))) in foo
17:15:12 <lambdabot> forall t. (Tree t -> t -> Tree t) -> Tree t -> t
17:15:17 <mmorrow> sweet
17:15:39 <mmorrow> BMeph: oh, that reminds me of Cale's suggestion for a quasiquoter.
17:15:42 <ski_> BMeph : "right" meaning ?
17:16:07 <mmorrow> BMeph: i'm not sure since i'm still trying to parse the meaning there
17:16:34 <chessguy> err, is creighton hogg in here?
17:16:51 <ski_> mmorrow : i'm not sure exactly what you want here .. but maybe it would be better to make `foldl' and `foldr' have the same type, if we're going to replace them for each other ?
17:16:55 <BMeph> ski_: "right" meaning correct. Pretend the 'x's is a product sign; it took me too long looking for a 'real' one. :)
17:17:11 <ski_> BMeph : "correct" meaning ? :)
17:17:22 <ski_> BMeph : are you asking whether that type is provable ?
17:17:27 <BMeph> @seen wchogg
17:17:28 <lambdabot> wchogg is in #haskell. I last heard wchogg speak 3h 54m 23s ago.
17:17:30 <mauke> ×
17:17:48 <mmorrow> ski_: hmm. i'm not sure what i'm going for either yet.
17:17:49 <BMeph> mauke: Grazie! :)
17:17:56 * mmorrow eats fooood
17:18:00 <chessguy> thanks BMeph
17:18:13 <mauke> ⊗
17:18:29 <mmorrow> ooh, i just realized what that notation means
17:18:37 <BMeph> ski_: I'm asking if that's an accurate description of the Functor for that type of tree. :)
17:18:40 <ski_> BMeph : stated another way .. what question are you trying to answer with that type ?
17:18:40 <mmorrow> , "⊗"
17:18:42 <lunabot>  "\8855"
17:18:47 <mmorrow> , "×"
17:18:49 <lunabot>  "\215"
17:19:32 <chessguy> @quote wchogg
17:19:32 <lambdabot> wchogg says: We don't say "moan-oid" or "moan-o-morphism" or any other such silliness.
17:19:54 <ski_> BMeph : you mean a functor `F' such that `T a  ~=  Mu (F a)' ?
17:20:03 <BMeph> ski_: As in List looks like: L a -> 1 + a x (L a)
17:20:04 <ski_> (for all `a')
17:20:19 <gweiqi> what are these functions tree and list?  i've never seen them before
17:20:23 <BMeph> ski_: Right. :)
17:20:59 <ski_> BMeph : for `[]', you'd do `L a r = 1 + a * r', methinks
17:21:04 <BMeph> gweiqi: There're just like either and maybe, only for other datatypes. :)
17:21:19 <ski_> gweiqi : mmorrow defined them a bit above
17:21:21 <gweiqi> BMeph: where are they defined?
17:21:49 <BMeph> gweiqi: Right here! (Where else, I do not know.... ;)
17:22:10 <gweiqi> ah, i see, i thought maybe they were standard
17:22:36 <ski_> BMeph : so for `Tree' i think you'd do `T a r = a * [r]', nay ?
17:23:04 <gweiqi> darn, i don't see the definitions, i must have joined late
17:23:05 <ski_> (mmorrow : "Cale's suggestion for a quasiquoter" ?)
17:23:18 <mmorrow> gweiqi: http://hpaste.org/13460#a1
17:23:24 * mmorrow really eats food now
17:23:31 <chessguy> ski_, BMeph, et al: what are you guys working on?
17:23:35 <mmorrow> ski_: yeah, something like
17:23:58 <Cale> ski_: I had an idea for mmorrow a while back to implement a catamorphism syntax.
17:24:11 <mmorrow> [$cata| Tip x -> 1; Branch l r -> l + r |]
17:24:13 <mmorrow> iirc
17:24:14 <ski_> gweiqi : `bool' is about 20 minutes in the past, `list' about 32 minutes ..
17:24:31 <mmorrow> gweiqi: they're in that paste as well
17:25:10 <ski_> chessguy : no idea. ask mmorrow (who just left for food), Peaker (you also left), and maybe BMeph
17:25:41 <gweiqi> mmorrow: thanks, so what is the goal of using these functions?
17:26:10 <ski_> Cale,mmorrow : a bit like Charity, then ?
17:26:54 <kohwj> hi, i'm having trouble running some reactive-fieldtrip code: runhaskell gives Test.hs: <command line>: can't load .so/.DLL for: HSCabal-1.6.0.1 (libHSCabal-1.6.0.1.so: cannot open shared object file: No such file or directory)
17:27:23 <Cale> ski_: yeah
17:28:39 <ski_> Cale,mmorrow : btw, that reminds me of the following, (which i showed a few days ago, i think)
17:28:45 <ski_> > evalCont . liftM (200 +) . reset $ do m <- induct [3,4,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
17:28:47 <lambdabot>   260
17:28:53 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a); size = [$cata | Tip -> 0; Branch x l r -> 1 + l + r]
17:29:30 * ski_ nods
17:29:45 <ski_> > evalCont . liftM (200 +) . reset $ do m <- induct [3,x,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
17:29:47 <lambdabot>   200 + 3 * (x * (5 * 1))
17:30:01 <Cale> Or, rather... those should be envelope brackets.
17:30:18 <ski_> ("envelope brackets" ?)
17:30:39 <Cale> [|$cata | ... |]
17:30:46 <ski_> ok
17:31:05 <pumpkin> scata :o
17:31:08 <pumpkin> sounds rude
17:31:15 <pumpkin> a scatamorphism
17:32:05 * BMeph thinks scatamorphisms really /would/ be the shit...
17:32:16 <pumpkin> lol
17:37:00 <Saizan> uhm, we could extend the $cata qq all the way up to attribute grammars maybe
17:37:04 <ski_> > evalCont . liftM (2000 +) . reset $ do (n,ns) <- inductT (Node 42 [Node 35 [], Node 12 [Node 6 []]]); return (n + product ns)
17:37:06 <lambdabot>   2726
17:37:11 <ski_> > evalCont . liftM (2000 +) . reset $ do (n,ns) <- inductT (Node 42 [Node 35 [], Node x [Node 6 []]]); return (n + product ns)
17:37:12 <lambdabot>   2000 + (42 + 1 * (35 + 1) * (x + 1 * (6 + 1)))
17:38:53 <ski_> that would be `2000 + [|$cata | Node n ns -> n + product ns|] (Node 42 [Node 35 [], Node 12 [Node 6 []]])'
17:39:13 <mmorrow> whoa, sweet
17:39:23 <mmorrow> Saizan: that'd be cool
17:39:37 <mmorrow> > evalCont . liftM (2000 +) . reset $ do (n,ns) <- inductT (Node 42 [Node 35 [], Node x [Node 6 []]]); return (n + product ns)
17:39:39 <lambdabot>   2000 + (42 + 1 * (35 + 1) * (x + 1 * (6 + 1)))
17:39:43 <mmorrow> @type inductT
17:39:44 <lambdabot> forall t r. Tree t -> Cont r (t, [r])
17:40:19 <ski_> (though, using `induct',`inductT', the "branches" could extend well outside the lexical scope of the `$cata' construction .. if that makes any sense)
17:40:19 <mmorrow> hmm
17:40:33 <ski_> @type induct
17:40:35 <lambdabot> forall a r. [a] -> Cont r (Maybe (a, r))
17:40:46 <mmorrow> interesting
17:40:48 <ski_> funfunfun
17:40:52 <mmorrow> heh
17:41:32 <ski_> (also try removing the ` . reset' part :)
17:41:48 <mmorrow> > evalCont . liftM (2000 +) $ do (n,ns) <- inductT (Node 42 [Node 35 [], Node x [Node 6 []]]); return (n + product ns)
17:41:49 <lambdabot>   2000 + (42 + 1 * (2000 + (35 + 1)) * (2000 + (x + 1 * (2000 + (6 + 1)))))
17:41:54 <mmorrow> > evalCont . liftM (2000 +) . reset $ do (n,ns) <- inductT (Node 42 [Node 35 [], Node x [Node 6 []]]); return (n + product ns)
17:41:55 <lambdabot>   2000 + (42 + 1 * (35 + 1) * (x + 1 * (6 + 1)))
17:42:27 <mmorrow> nice
17:49:36 <BMeph> @type reset
17:49:38 <lambdabot> forall a r. Cont a a -> Cont r a
17:50:55 <BMeph> Mind-blowing and -numbing, all at once. Splendid! :)
17:51:25 <ski_> glad you like it
17:52:23 <BMeph> I eagerly await the next blog posts (hint, hint). ;)
17:53:01 <ski_> @wn blog
17:53:02 <lambdabot> *** "blog" wn "WordNet (r) 2.0"
17:53:02 <lambdabot> blog
17:53:02 <lambdabot>      n : a shared on-line journal where people can post diary entries
17:53:03 <lambdabot>          about their personal experiences and hobbies [syn: {web
17:53:05 <lambdabot>          log}]
17:54:31 * ski_ wonders which blog BMeph was thinking of ..
17:56:55 <gbacon> to pass arrays across FFI, must I be inside the IO monad?
17:57:16 <gbacon> I have a pure function that takes two arrays as input
17:57:28 <Saizan> ?type unfoldr
17:57:31 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:57:40 <Axman6> gbacon: http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
17:57:49 <gbacon> Axman6: thanks
17:58:04 <Axman6> gbacon: just happened to still have it open, it deals with doing the same sort of thing
17:58:08 <luite> gbacon: FFI functions have a IO type, you can use unsafePerformIO if you know the function is referentially transparent
17:58:09 <pumpkin> Axman6: did you ever get that dct4 working nicely?
17:58:38 <ski_> (Saizan : .. getting some ideas ? ;)
17:58:48 <Axman6> pumpkin: what do you mean?
17:59:05 <pumpkin> wasn't it you working on that dct-iv in haskell?
17:59:11 <pumpkin> or am I getting confused
17:59:16 <Axman6> pumpkin: actually, looks like something that's a prime candidate for using DPH
17:59:27 <Axman6> yeah it was me
17:59:40 <Saizan> (ski_: hehe :)
17:59:58 <gbacon> luite: isn't sin in http://www.haskell.org/haskellwiki/FFI_Introduction#Short_version a pure function?
18:00:31 <Saizan> (ski_: do you also have the equivalent for unfoldr already?)
18:01:31 <ski_> (Saizan : not in LB .. only in a file i scribbled some year(s ?) ago ..)
18:01:44 * ski_ checks
18:02:43 <luite> gbacon: hm, seems you're right
18:03:07 <gbacon> but to allocate arrays, it looks like I'm stuck with unsafePerformIO
18:04:15 <Axman6> gbacon: well it is what unsafePerformIO is designed for
18:04:24 <ski_> (.. 2005-09-20 .. longer ago than i thought)
18:04:37 <gbacon> but ugly :-/
18:04:38 <pumpkin> Axman6: I thought it was designed for malicious libraries trying to be unpredictable? :(
18:04:50 <pumpkin> damn, I've been using it wrong then
18:05:03 <Axman6> pumpkin: and waging war, yes
18:05:18 <ski_> (Saizan : i'd have to define some datatypes to get it nicely ..)
18:05:33 <ski_> hm
18:05:33 <Saizan> ski_: what's the type?
18:07:44 <ski_>   coinduct :: Cxt s (a,s) -> [a]  -- i think
18:08:02 <ski_> (and `[]' should really be `Stream' ..)
18:08:40 <Saizan> missing an 's ->' i think?
18:09:02 <ski_> i don't think so
18:09:20 <Saizan> ah, Cxt is the Context comonad?
18:09:31 <ski_>   data Cxt s a = MkC s (s -> a)
18:09:35 <ski_> aye
18:09:45 <Saizan> cool
18:09:51 <int80_h> hi everyone
18:10:55 <Saizan> ski_: so the context comonad is related to the cont monad? is it the dual?
18:11:24 <pumpkin> > length [1,2,3,undefined,4,5]
18:11:25 <lambdabot>   6
18:11:49 <ski_> it is related
18:13:03 * ski_ however did scribble this in terms of monads or comonads in the file ..
18:13:16 <ski_> (arrows instead, to be specific)
18:13:24 <ski_> s/did/didn't/
18:13:43 <Axman6> happy new years eve haskellians
18:14:02 <mauke> it is 3:13:37
18:14:11 <mauke> excellent
18:14:17 <Axman6> 1:14 PM for me
18:14:27 <ivanm> Axman6: even for you weirdo southerners, there's at least 11 hrs, 45 min
18:14:28 <mauke> then you're in the wrong timezone
18:14:31 <mauke> OBVIOUSLY
18:15:05 <Axman6> ivanm: weirdo southerners? you a banana bender or what?
18:15:21 <ivanm> haven't you worked that out yet?
18:15:23 <ivanm> ;-)
18:16:26 <Axman6> oh hey, did i tell you my RWH was signed by all three authors, plus they gave me a SUN UltraSPARC machine?
18:16:30 <Axman6> >_>
18:16:38 <ivanm> Axman6: and that you're a liar?
18:16:39 <Axman6> i still hate you for getting it first :(
18:16:45 <ivanm> so, what size fish do you catch? :p
18:16:57 <Axman6> it was THIS big man!
18:17:05 <ski_>   test5' = take 10 $ (`runCxtA` 0) $
18:17:09 <ski_>     proc x -> do
18:17:11 <ski_>       coinductS -< (x * x,x + 1)
18:17:26 <ben_h> My copy of RWH shipped from amazon today!
18:18:01 <Axman6> nice :)
18:18:12 <Axman6> it's a good book, if not a little buggy
18:19:34 <Axman6> this is the first one i noticed:
18:19:35 <Axman6> There is a capital letter 'T' instead of the word String in the following sentence:
18:19:38 <Axman6> "In this example, the Int represents a book's identifier (e.g. in a stock database), T represents its title, and [String] represents the names of its authors."
18:19:53 <ben_h> heh
18:20:15 <ben_h> ahh that's alright - should keep me on my toes :)
18:20:24 <Axman6> and i saw this one too: The line as printed reads "asInt_either :: String -> Ei". It looks like the line is truncated, and should read "asInt_either :: String -> Either ErrorMessage Int" judging by the type def above and the output shown below.
18:20:42 <ben_h> bugger
18:20:51 <ben_h> sounds like it could have used another proofreader
18:20:56 <ivanm> Axman6: if not a _lot_ buggy ;-)
18:21:16 <ivanm> ben_h: they needed proofreaders who understand Haskell... I think that was the biggest problem :(
18:21:22 <ben_h> yeah
18:21:34 <ivanm> most mistakes I've found have been from when they changed the code after writing the text around it, but didn't update the text :s
18:21:35 <ben_h> i guess that's the beauty of online distribution.
18:21:38 <Axman6> i think most of the bugs are in the beginning of the book (which is probably a bad thing, most likely to trip up beginners)
18:21:46 <ben_h> and in fact i expect to use the book online far more than the paper copy
18:21:51 <ben_h> i just wanted them to have some of my money :)
18:22:00 <Axman6> :)
18:22:13 <ben_h> i assume those problems are fixed on the website?
18:22:20 <ivanm> ben_h: no :(
18:22:27 <ben_h> :|
18:22:28 <rfichoke> I'm kinda new both to Haskell and TeX: is lhs2TeX ready for prime time?
18:22:36 <ivanm> since whilst they could do website -> book, they couldn't do it the other way round
18:22:45 <rfichoke> LaTeX doesn't like the output from lhs2TeX
18:22:47 <ivanm> rfichoke: ummm..... it's been ready for prime time for years AFAIK...
18:22:59 <ivanm> rfichoke: maybe you don't have the required latex packages installed?
18:23:02 <pumpkin> rfichoke: what doesn't it like?
18:23:09 <ivanm> you should run "lhs2tex foo.hs" to do it
18:23:25 <chessguy> wchogg:
18:23:29 <Axman6> i haven't been able to get lhs2TeX to work yet either, on a simple tutorial i wrote :\
18:23:42 <ivanm> *shrug* worked here
18:23:48 <Axman6> god damn it jelly belly jelly beans taste good! must stop eating them!
18:23:48 <rfichoke> it's complaining because "\usepacakge" should not occur "before \documentclass"
18:23:55 * Axman6 should go get some breakfast
18:24:01 <ddarius> Jelly beans are atrocious.
18:24:04 <ben_h> Axman6: +1
18:24:12 <ivanm> Axman6: lunch, surely...
18:24:22 <Axman6> i just woke up, it's breakfast time
18:24:28 <ivanm> @time Axman6
18:24:28 <chessguy> hey Axman6 : how you making out on RWH?
18:24:31 <lambdabot> Local time for Axman6 is Wed Dec 31 13:24:29 2008
18:24:34 <rfichoke> But it does generate TeX output, so it looks like lhs2TeX itself works to some degree
18:24:38 * ivanm doesn't think so...
18:24:46 <pumpkin> rfichoke: switch them up and see if you get any other issues
18:24:52 <ivanm> rfichoke: it requires a couple of non-standard tex packages
18:24:58 <ben_h> ivanm: depends how you define breakfast - i'm in the same boat :)
18:25:01 <Axman6> chessguy: yeah ok, i managed to get most of ch6 done i think
18:25:01 <rfichoke> ivanm: that's probably the problem
18:25:04 <ben_h> it's 12:24 here
18:25:16 <rfichoke> I'm using the OS X-provided LaTeX
18:25:16 <int80_h> hold,on, what errors are at the begining of the book?
18:25:21 <pumpkin> rfichoke: you mean mactex?
18:25:30 <ivanm> rfichoke: I did say that earlier ;-)
18:25:30 <Axman6> rfichoke: OS X doesn't provide LaTeX...
18:25:52 <Axman6> ivanm: how do you install those packages?
18:25:58 <rfichoke> Axman6: I guess I must've installed that at some point :-)
18:26:01 <mauke> @time
18:26:04 <lambdabot> Local time for mauke is Tue Dec 30 18:26:01 2008
18:26:11 <mauke> not true :|
18:26:20 <rfichoke> I've "configured" and "make"d and "make install"d a lot over the past couple of years
18:26:20 <Axman6> int80_h: http://oreilly.com/catalog/9780596514983/errata/
18:26:50 <ivanm> Axman6: the lhs2tex ebuild has them as deps ;-)
18:26:56 * Axman6 heads off to get breakfast
18:27:11 <Axman6> ivanm: hmm, fair enough. do i need to do anything to get lhs2tex to use them?
18:27:13 <ivanm> you need polytable
18:27:23 <ivanm> looks like that's the only latex package it needs >_>
18:27:31 <sbahra> @let is x y = x == y
18:27:33 <lambdabot>  Defined.
18:27:38 <ivanm> Axman6: what tex are you using? texlive, tetex?
18:27:49 <Axman6> texlive i think
18:28:09 <ivanm> hmmmm...... I have manually installed a package in a texlive tree, but can't remember how off the top of my head
18:28:31 <ivanm> it's on CTAN, anyway...
18:28:31 <mauke> @time
18:28:33 <sbahra> Axman6, what do you need? Sorry, just arrived.
18:28:34 <lambdabot> Local time for mauke is Wed Dec 31 03:28:19 2008
18:28:45 <int80_h> @time
18:28:49 <lambdabot> Local time for int80_h is Tue Dec 30 18:28:44 2008
18:28:49 <ivanm> Axman6: oh, it comes with texlive anyway
18:28:49 <sbahra> I have used lhs2tex before for a report, worked wonderfully.
18:28:53 <Axman6> does it need to be a full LaTeX document? i though the idea was that it was just a plaintext file with some \begin{code} stuff
18:28:55 <ivanm> in the latexextra package
18:29:22 <sbahra> Axman6, you need some special %include's along with \begin{code}.
18:29:55 <sbahra> %include lhs2TeX.fmt
18:30:04 <Axman6> heh, whoot, just did that.
18:30:06 <mmorrow> Axman6: here's a small repo with a minimal example Foo.lhs, Makefile, haskell.sty  http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/
18:30:06 * Axman6 tests
18:30:20 <sbahra> for i in 1 2 3 4; do
18:30:20 <sbahra>   lhs2TeX --tt part-$i.in.tex -o part-$i.tex; texi2pdf -b part-$i.tex || exit
18:30:20 <sbahra> done
18:30:53 <int80_h> is haskell.org down? I'm having some difficulty getting to it
18:31:00 <rfichoke> int80_h: working here
18:31:01 * mmorrow loves the: for i in `...`;do ... $i ...;done  pattern
18:31:08 <mauke> http://downforeveryoneorjustme.com/haskell.org
18:31:28 <ivanm> it was down the other day...
18:31:30 * sbahra wishes seq was in FreeBSD base :-P
18:31:38 <mmorrow> oh the shame!
18:31:56 <int80_h> I'm doing a traceroute...
18:32:08 <mmorrow> seq is teh leetest
18:32:20 <mauke> for ((i=1;i<5;++i)) do echo $i; done
18:32:27 <pumpkin> mmorrow: we found a fix for pumpkinbot btw, Saizan came up with it :P
18:32:42 <mmorrow> for i in `seq 1 4`;do echo $i;done
18:32:53 <mmorrow> pumpkin: oh nice. what was it?
18:33:03 <pumpkin> mmorrow: pass --rlimits to mueval :P
18:33:06 <pumpkin> so it paid attention to them
18:33:08 <mmorrow> haha
18:33:11 <pumpkin> otherwise it apparently just ignores them
18:33:18 <mmorrow> "minor oversight" on our part ;)
18:33:18 <pumpkin> and then I needed to raise the file limit
18:33:37 <mmorrow> lunabot only has mem and cpu limits fwiw
18:33:51 <pumpkin> btw, if lambdabot ever goes down, you can pm pumpkinbot and @join it here
18:34:11 <mmorrow> pumpkin: oh nice, that's good to know.
18:34:32 <Axman6> argh! lhs2tex isn't working!
18:34:40 <pumpkin> Axman6: what's wrong with it?
18:35:02 <int80_h> odd, my traceroute stops at bugs.haskell.org
18:35:11 <Axman6> it won't compile, error is You can't use `macro parameter character #' in horizontal mode.
18:35:12 <mauke> so does mine
18:35:27 <mauke> http://bugs.haskell.org/ :-)
18:36:06 <mmorrow> Axman6: that haskell.sty + latex Foo.lhs && dvips Foo.dvi -o Foo.ps && ps2pdf Foo.ps Foo.pdf.0 && pdfopt Foo.pdf.0 Foo.pdf && rm -f Foo.pdf.0  works in case you're in need of a fallback
18:36:30 <Axman6> wait, just needed to escape a #, heh
18:36:54 <mmorrow> pumpkin: so that solved the zombie proliferation problem perfectly?
18:37:21 <pumpkin> mmorrow: seemed to, it still doesn't behave the same way as lambdabot for many things (like fix error) but when it says something gets killed, it really does
18:37:44 <mmorrow> ah, so "fix error" still makes a zombie (?)
18:37:54 <pumpkin> nope, it just dies
18:38:06 <mmorrow> oh, nice. so problem solved then.
18:38:09 <pumpkin> > fix error
18:38:10 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:38:12 <ivanm> die, damn you, die! :@
18:38:14 <pumpkin> but I don't get that
18:38:27 <mmorrow> , fix error
18:38:33 <lunabot>  Killed.
18:38:34 <pumpkin> [21:38:22] <pumpkin> > fix error
18:38:34 <pumpkin> [21:38:28] <pumpkinbot>  mueval: Prelude.read: no parse
18:38:47 <pumpkin> I also get it for other random stuff, like the arrow functions :P
18:39:31 <mmorrow> lunabot substitues the string "Killed." in for whatever the actual response (i can't remember) is.
18:39:49 <mmorrow> , read "" :: String
18:39:51 <lunabot>  luna: Prelude.read: no parse
18:39:58 <mmorrow> that's probably the culprit
18:40:07 <pumpkin> hmm?
18:40:19 <Axman6> mmorrow: should there be a %include lhs2TeX.fmt line in there? lhs2tex is complaining (or do i just run pdflatex on it...)
18:40:28 <mmorrow> maybe just add a (\s -> if null s then [] else read s) or better yet, change it to use reads
18:40:50 <mmorrow> (i think the response upon being killed by rlimits is nothing)
18:40:54 <pumpkin> Axman6: that would be a comment? :o
18:41:04 <mmorrow> so i'm guessing mueval is trying to call read on a ""
18:41:16 <Axman6> pumpkin: seems to work for lhs2tex though
18:41:24 <pumpkin> mmorrow: oh, that would make sense
18:41:26 <mmorrow> Axman6: oh, that setup is for just running pdflatex on
18:41:30 <rfichoke> Axman6: Yeah, you have to %include lhs2TeX.fmt but you need to do it after the \documentclass directive, it seems
18:41:40 <mmorrow> (or latex + dvips + ps2pdf/whatever)
18:42:02 <Axman6> so i need to write the \documentclass and stuff too?
18:42:11 <rfichoke> It would appear so, yes.
18:42:12 <Axman6> what actually is the point of lhs2tex >_<
18:42:39 <mmorrow> Axman6: mostly what that cont-lhs-eg repo is good for is the prologue latex code at the top
18:42:59 <Axman6> fair enough
18:43:04 <pumpkin> someone should make a TeX replacement in haskell :o
18:43:12 <pumpkin> with a nice syntax please thanks
18:43:15 <mmorrow> i put all the commented out options at the top that i could think of / knew at the time
18:43:19 <ben_h> can someone illuminate this for me? i'm looking at an example in RWH Ch5, under 'pretty printing a string':
18:43:20 <Axman6> pumpkin: i said that yesterday!
18:43:20 <ben_h> string = enclose '"' '"' . hcat . map oneChar
18:43:21 <rfichoke> Axman6: Yeah, I just used the link mmorrow posted above to steal a working TeX
18:43:24 <pumpkin> Axman6: omg noes
18:43:26 <rfichoke> ...file
18:43:26 <ski_> > show (read "")
18:43:26 <ski_> 03:43 <pumpkinbot>   mueval: Prelude.read: no parse
18:43:27 <ski_> 03:43 <pumpkinbot>  mueval: "*** Exception: Prelude.read: no parse
18:43:28 <lambdabot>   "* Exception: Prelude.read: no parse
18:43:34 <mmorrow> rfichoke: :)
18:43:41 <mauke> > show (read "()")
18:43:42 <pumpkin> Axman6: propose it on haskell_proposals reddit!
18:43:43 <lambdabot>   "()"
18:43:48 <Axman6> yeah!
18:43:54 <pumpkin> ski_: omg you're having a secret affair with my bot in pm!
18:44:01 <ben_h> does '.' concatenate results from enclose, hcat and map?
18:44:16 <mauke> ben_h: no, it creates a function pipeline
18:44:16 <ski_> pumpkin : not a secret anymore, now ..
18:44:21 <pumpkin> :(
18:44:23 <ski_> (so, no)
18:44:26 <mreh> can anyone explain how data types are different from an Algebraic Data Type
18:44:30 <Axman6> ben_h: this from RWH?
18:44:33 <ben_h> mauke: ok i'll read up on them, thanks
18:44:38 <ben_h> Axman6: yeah, chap 5
18:44:41 <mreh> mine is from RWH too :D
18:44:41 <mmorrow> , hcat . map (text . show) $ [0..4]
18:44:42 <mauke> ben_h: are you familiar with unix pipes?
18:44:44 <lunabot>  01234
18:44:44 <chessguy> @check show (read x) = x :: [Char]
18:44:44 <lambdabot>   Parse error at "=" (column 15)
18:44:48 <ben_h> mauke: yep
18:44:49 <Axman6> then you want the <> you'll define at some point :)
18:45:00 <mauke> ben_h: ok, this is sort of similar
18:45:00 <mmorrow> , hcat (map int [0..4])
18:45:04 <lunabot>  01234
18:45:12 <mmorrow> , hcat . map int $ [0..4]
18:45:14 <lunabot>  01234
18:45:25 <mauke> > (f . g . h) x
18:45:25 <Axman6> ben_h: basically: Empty <> x = x; x <> Empty = x; x <> y = x `Concat` y
18:45:26 <lambdabot>   Add a type signature
18:45:29 <mauke> > (f . g . h) x :: Expr
18:45:30 <lambdabot>   Add a type signature
18:45:32 <mmorrow> @pl \x -> g (f x)
18:45:32 <lambdabot> g . f
18:45:32 <mauke> :-(
18:45:40 <mmorrow> mauke: heh
18:45:46 <mauke> (f . g . h) x is the same as f (g (h x))
18:46:10 <chessguy> @check show (read x) == x :: [Char]
18:46:10 <ben_h> mauke: ahh ok
18:46:11 <lambdabot>   Couldn't match expected type `String' against inferred type `Expr'
18:46:43 <mmorrow> ben_h:   cat | foo | bar  ====  bar . foo . id
18:46:57 <enticingjelly> @t hcat
18:46:58 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:47:02 <Axman6> @check \x -> show (read x) == x :: [Char]
18:47:03 <ben_h> is f(g(h(x))) equivalent to f g h x? or is it associative the other way?
18:47:03 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Bool'
18:47:05 <enticingjelly> ?t hcat
18:47:05 <mmorrow> , [$ty| hcat |]
18:47:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:47:06 <ddarius> return >>= foo >>= bar
18:47:12 <enticingjelly> >t hcat
18:47:14 <Axman6> @check \x -> show (read x) == (x :: [Char])
18:47:16 <lambdabot>   "* Exception: Prelude.read: no parse
18:47:16 <lunabot>  ([] Doc) -> Doc
18:47:17 <enticingjelly> :t hcat
18:47:19 <lambdabot> [Doc] -> Doc
18:47:36 <mauke> ben_h: f g h x is ((f g) h) x
18:47:39 <mmorrow> , normalizeT [$tyQ| hcat |]
18:47:41 <Axman6> ok, breakfast time!
18:47:44 <lunabot>  AppT (AppT ArrowT (AppT (ConT []) (ConT Doc))) (ConT Doc)
18:47:44 <mauke> ben_h: function application associates to the left
18:47:47 <ben_h> mauke: right
18:48:08 <chessguy> @hoogle hcat
18:48:09 <lambdabot> Text.PrettyPrint.HughesPJ hcat :: [Doc] -> Doc
18:48:09 <lambdabot> Language.Haskell.TH.PprLib hcat :: [Doc] -> Doc
18:48:21 <mauke> @hoogle ceiling cat
18:48:21 <lambdabot> No results found
18:48:35 <mmorrow> , everywhere (mkT (\t -> case t of ConT n | n==''[] -> ListT; _ -> t)) [$tyQ| hcat |]
18:48:40 <lunabot>  AppT (AppT ArrowT (AppT (ConT []) (ConT Doc))) (ConT Doc)
18:48:41 <ben_h> does ((f g) h) x make sense?
18:48:45 <mauke> yes
18:48:49 <mmorrow> wut
18:49:00 <chessguy> ben_h:  depends on the types
18:49:03 <ben_h> yeah
18:49:04 <mmorrow> , everywhere (mkT (\t -> case t of ConT n | n==''[] -> ListT; _ -> (t::Type))) [$tyQ| hcat |]
18:49:09 <lunabot>  AppT (AppT ArrowT (AppT (ConT []) (ConT Doc))) (ConT Doc)
18:49:10 <mreh> isn't a data type with only one data constructor the same as a algebraic data type with one contructor?
18:49:20 <mmorrow> oh
18:49:32 <ben_h> is it right to say g is the arg to f, h is the arg to the result of (f g), and x is the arg to the result of that?
18:49:37 <mmorrow> , everywhere (mkT (\t -> case t of ConT n | n==mkName "[]" -> ListT; _ -> t)) [$tyQ| hcat |]
18:49:39 <mauke> ben_h: yes
18:49:43 <lunabot>  AppT (AppT ArrowT (AppT ListT (ConT Doc))) (ConT Doc)
18:49:44 * ben_h does the dance
18:49:50 <mmorrow> , ppDoc $ everywhere (mkT (\t -> case t of ConT n | n==mkName "[]" -> ListT; _ -> t)) [$tyQ| hcat |]
18:49:51 <mauke> > ((enumFromThenTo 1) 3) 10
18:49:52 <lambdabot>   [1,3,5,7,9]
18:49:56 <lunabot>  ([Doc]) -> Doc
18:49:56 <chessguy> ben_h:  more or less
18:49:59 <mauke> > enumFromThenTo 1 3 10
18:50:00 <lambdabot>   [1,3,5,7,9]
18:50:05 <Saizan> mreh: the ones you define with "data" or "newtype" are algebraic data types
18:50:35 <ben_h> chessguy: 'more or less' meaning they're evaluated lazily? or are you talking about something else?
18:50:48 <mmorrow> , [$pl| \a b c -> g (f a b c) |]
18:50:53 <lunabot>  ((g .) .) . f
18:51:12 <Saizan> :O
18:51:17 <mmorrow> someone needs to optimize @pl, it's super time consuming
18:51:24 <Saizan> stealing code from lb?
18:51:25 <mmorrow> Saizan: oh yesh. :)
18:51:28 <mmorrow> heh
18:51:32 <mmorrow> (yes)
18:51:46 <ivanm> mmorrow: someone == you? ;-)
18:52:19 <chessguy> ben_h:  you could also think about g, h, and x all as parameters to f, and it's isomorphic to what you just said.
18:52:25 <mmorrow> ivanm: hehe, i was hoping someone would be like "ooh ooh i just did that this morning!!@"
18:52:36 <chessguy> ben_h:  that's all i was thinking about
18:52:41 <ivanm> mmorrow: I don't think the Haskell community is _that_ good....
18:52:49 <ben_h> chessguy: doesn't that depend on now many params f will accept?
18:52:50 <ivanm> seeing as how its the traditional holiday season and all ;-)
18:52:54 <Saizan> ahah, so we can write [$pl| \a b c -> g (f a b c) |] in our code and still pretending to use pointsfree style now :)
18:53:04 <chessguy> ben_h:  ah, that's the "there is no spoon" moment :)
18:53:07 <mmorrow> ivanm: true
18:53:24 <ben_h> chessguy: haha sweet :)
18:53:26 <mmorrow> Saizan: sly
18:53:38 <chessguy> ben_h:  how many parameters does map "accept"?
18:53:43 * ben_h crawls down the rabbit hole
18:53:50 <mauke> 1, for it is a function
18:53:51 <chessguy> @type map
18:53:52 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:54:14 <ben_h> chessguy: two?
18:54:20 <ben_h> a function and a list of a's?
18:54:26 <chessguy> ben_h:  in some sense, yes
18:54:29 <mauke> > (map (* 2)) [1,2,3]
18:54:30 <lambdabot>   [2,4,6]
18:54:33 <mmorrow> , [$tyQ| [$pl| \a b c -> g (f a b c) \|] |]
18:54:38 <lunabot>  ConT Doc
18:54:52 <mmorrow> there needs to be a better way of composing QuasiQuoters
18:54:57 <mmorrow> something like
18:55:01 <ben_h> > (map (**2)) [1,2,3]
18:55:02 <lambdabot>   [1.0,4.0,9.0]
18:55:07 <ben_h> nice
18:55:15 <mauke> > map (^ 2) [1,2,3]
18:55:16 <chessguy> ben_h:  but you can just as easily think of the type (a -> b) -> ([a] -> [b])
18:55:16 <lambdabot>   [1,4,9]
18:55:30 <mauke> :t map (^ 2)
18:55:31 <lambdabot> forall a. (Num a) => [a] -> [a]
18:55:32 <ben_h> chessguy: is that currying? or something different
18:55:34 <chessguy> ben_h:  and the zen of it is, there's really no difference
18:55:44 <mauke> ben_h: it is
18:55:49 <mmorrow> hmm, i didn't think what i was just going to suggest through it seems :/
18:55:52 * chessguy gets the terms all confuzzled
18:56:02 <mauke> we represent a function of two arguments as a function taking one argument and returning another function (of one argument)
18:56:25 <ben_h> right. so a function that 'accepts n params' actually accepts [0..n] params at the callpoint
18:56:29 <ben_h> ?
18:56:40 <mauke> yes
18:56:46 <mauke> sometimes more than n :-)
18:56:49 <mauke> :t id
18:56:50 <lambdabot> forall a. a -> a
18:57:05 <mauke> > id (+) 2 2  -- calling id with 3 arguments
18:57:05 <ben_h> more?
18:57:07 <lambdabot>   4
18:57:08 <chessguy> ben_h:  yes, and results in a function that takes the rest (possibly 0) of the params
18:57:14 <mmorrow> [?|\a b c -> g (f a b c)|] -- an anonymous QuasiQuoted body
18:57:36 <ben_h> mauke: but is that really calling id with all 3 args, or evaluating them and calling id with the result?
18:57:55 <ben_h> s/evaluating/not-evaluating-yet
18:57:56 <ben_h> :)
18:57:58 <mauke> ben_h: what's the difference? all 3 arguments are fully evaluated here
18:58:08 * chessguy grins
18:58:17 <mmorrow> [$(tyQ . pl)| \a b c -> g (f a b c)|]
18:58:21 <mmorrow> hmm
18:58:24 <ben_h> hmm
18:58:32 <chessguy> geezusfreeek: !!
18:58:44 <Saizan> mmorrow: wait, in [$tyQ| [$pl| \a b c -> g (f a b c) \|] |] what does tyQ sees? the prettyprinted code resulting from pl?
18:58:51 <Saizan> as a String?
18:59:12 <chessguy> @quote explode
18:59:12 <lambdabot> ghc says: My brain just exploded.
18:59:14 <mmorrow> Saizan: no, the first QQ can result in an expr of any type
18:59:21 <mauke> possibly a mindfuck: think about what 'flip id' means
18:59:24 <mmorrow>  pl just happens to result in a Doc
18:59:39 <chessguy> @seen ghc
18:59:39 <lambdabot> I haven't seen ghc.
18:59:45 <mmorrow> , [$ty| [$ty| \|] |]
18:59:48 <mauke> preflex: seen ghc
18:59:48 <preflex>  Sorry, I haven't seen ghc
18:59:49 <chessguy> @type flip id
18:59:50 <lunabot>  luna: Exception when trying to run compile-time code:
18:59:51 <lambdabot> forall b c. b -> (b -> c) -> c
18:59:56 <mmorrow> , [$ty| [$ty| xmozm \|] |]
19:00:01 <lunabot>  luna: Exception when trying to run compile-time code:
19:00:06 <mmorrow> , [$ty| [$ty| 42 \|] |]
19:00:08 <ben_h> mauke: there still seems to be a difference to me - if id really does accept all 3 args, i can't see how it knows what to do with them.
19:00:11 <lunabot>  Doc
19:00:16 <mmorrow> , [$ty| [$tyQ| 42 \|] |]
19:00:19 <Saizan> mmorrow: yeah, but tyQ takes a String as argument right?
19:00:21 <lunabot>  Type
19:00:31 <mmorrow> Saizan: ohhh, good point.
19:00:31 <mauke> ben_h: in reality, every function accepts exaclty one argument
19:00:33 <mmorrow> hmm
19:00:33 <pumpkin> mmorrow: what if you had some really time-consuming TH code? is there a provision to compile your code-generating code?
19:00:42 <ben_h> mauke: ohhhhhhhhhhhhhhhhhhhhhhh
19:00:49 <Saizan> mmorrow: so it actually gets the code of that expression, which happens to be of type Doc
19:00:57 <mauke> ben_h: everything else is syntactic sugar
19:01:05 <ben_h> ok that just cleared a lot of fog.
19:01:35 <mmorrow> pumpkin: assuming we were actually doing this at compile-time (here it's calling back into ghc with multiple levels of eval and other debauchery), ghc would compile it to machine code.
19:01:39 <ben_h> every valid chunk of a function call is at least a valid partial application. which is a 'function'
19:01:43 <mmorrow> hmm, actually wait. i'm not positive.
19:01:55 <mmorrow> pumpkin: that's a really good question.
19:02:07 <mmorrow> i'm going to find that out.
19:02:11 <pumpkin> :)
19:02:18 <pumpkin> I didn't get the feeling it was possible
19:02:27 <pumpkin> I have a 7th sense for detecting compilable things
19:02:31 <ben_h> (am i right there?)
19:02:39 <Saizan> well "ty" can be compiled, it's just manipulating a string
19:02:41 <mmorrow> (namely, when ghc executes compile-time TH code, does that code get compiled to mach code, or is it compiled to bytecode an interpreted)
19:02:46 <geezusfreeek> chessguy: !!
19:02:51 <chessguy> ben_h:  sounds right to me
19:02:56 <mmorrow> Saizan: but consider something like:
19:03:30 <Saizan> something like $(<complex expression>) is interpreted
19:03:34 <Saizan> i think
19:03:57 <Saizan> but the function it calls are compiled if they come from other modules
19:03:57 <mmorrow> , [|show $(lift (let fib m !n = m : fib n (m+n) in fib 0 1 !! 100000000))|]
19:04:01 <lunabot>  luna: out of memory (requested 1048576 bytes)
19:04:43 <mmorrow> Saizan: yeah, in particular, the case where it's not calling into any already-compiled-lib-code and is doing a super expensive computation at compile-time
19:05:00 <mmorrow> (all of which is defined locally in the splice)
19:05:11 <ben_h> mmorrow: in this example - "hcat . map int $ [0..4]" - what's the $ achieving?
19:05:14 <geezusfreeek> chessguy, any particular reason for the excitement of seeing me here?
19:05:16 <ben_h> oh
19:05:25 <chessguy> geezusfreeek:  you rock!
19:05:30 <pumpkin> ben_h: it's delaying the application
19:05:33 <mmorrow> ben_h: you need it so that ghc parses it as what you want
19:05:34 <geezusfreeek> sweet!
19:05:35 <ben_h> makes the list an arg of the function immediately to the left instead of the left-associated reault?
19:05:44 <pumpkin> @src ($)
19:05:44 <lambdabot> f $ x = f x
19:05:45 <chessguy> geezusfreeek:  (don't ask me why)
19:05:46 <mmorrow> , (hcat . map int) [0..4]
19:05:48 <lunabot>  01234
19:05:50 <mmorrow> , hcat . map int $ [0..4]
19:05:52 <pumpkin> but it has precedence of 0
19:05:53 <lunabot>  01234
19:06:05 <ben_h> oh the opposite of what i said. :)
19:06:19 <ben_h> , hcat . map int [0..4]
19:06:21 <lunabot>  luna: Couldn't match expected type `a -> [Text.PrettyPrint.HughesPJ.Doc]'
19:06:21 <Saizan> it's just like using parentheses
19:06:24 <ben_h> right
19:06:28 <mmorrow> exactly
19:06:39 <chessguy> except without the lisp :)
19:06:45 <ben_h> :)
19:07:24 <SamB> Lemmih: the lhc repository at http://code.haskell.org/lhc does not seem to have a target email address specified in it ...
19:07:38 <ben_h> so "hcat . map int [0..4]" is equivalent to "((hcat . map) int) [0..4]"
19:07:38 <ben_h> ?
19:07:47 <ivanm> SamB: he's trying to avoid lambda-spam ;-)
19:07:54 <chessguy> ben_h:  not quite
19:07:59 <mauke> ben_h: no
19:08:06 <ben_h> , ((hcat . map) int) [0..4]
19:08:08 <lunabot>  luna: Couldn't match expected type `[Text.PrettyPrint.HughesPJ.Doc]'
19:08:08 <mauke> ben_h: function application binds tighter than infix operators
19:08:12 <pumpkin> who runs the lambdabot repo?
19:08:21 <ben_h> mauke: ahh right
19:08:38 <mauke> hcat . map int [0..4] parses as  hcat . ((map int) [0..4])
19:08:51 <ben_h> ahhhhhh
19:09:05 <ben_h> of course, that's all function application on the right.
19:10:37 <ben_h> alright, are these two equivalent?
19:10:39 <ben_h> string = enclose '"' '"' . hcat . map oneChar
19:10:40 <ben_h> string = ((enclose '"' '"') . hcat) . (map oneChar)
19:10:51 <mauke> yes
19:10:57 <ben_h> awesome
19:11:09 <chessguy> @unpl enclose '"' '"' . hcat . map oneChar
19:11:09 <lambdabot> (\ c -> enclose '"' '"' (hcat (map oneChar c)))
19:11:09 <mauke> I'm not sure about the associativity of (.), but it doesn't really matter
19:11:20 <chessguy> @unpl ((enclose '"' '"') . hcat) . (map oneChar)
19:11:20 <lambdabot> (\ c -> enclose '"' '"' (hcat (map oneChar c)))
19:11:36 * chessguy hiccups
19:12:00 * ivanm tries to scare chessguy to stop his hiccups
19:12:01 <ben_h> oh wow, that all makes sense now
19:12:47 <ben_h> thanks for your explanations dudes - that makes a lot of sense now
19:12:49 <chessguy> heh. it even chose a nice free variable
19:12:51 <ben_h> i feel enlightened :)
19:13:04 <chessguy> ben_h:  next up: monad transformers!
19:13:08 <mauke> haha
19:13:11 <ben_h> bring it on, bitches
19:13:12 <ben_h> :)
19:13:17 <mauke> @kind ContT
19:13:19 <lambdabot> * -> (* -> *) -> * -> *
19:13:24 <sbahra> *Rum.Curses> doInterface
19:13:24 <sbahra> Loading package mtl-1.1.0.1 ... linking ... <interactive>: /home/sbahra/software/lib/hscurses-1.3.0.2/ghc-6.8.3/HShscurses-1.3.0.2.o: unknown symbol `iconv_open'
19:13:24 <sbahra> ghc-6.8.3: unable to load package `mtl-1.1.0.1'
19:13:28 <mauke> also: "wtf"
19:13:29 <ben_h> yeah that string function reads really nicely once you know how to read it.
19:13:37 <sbahra> mtl-1.1.0.1 is installed
19:13:52 <mmorrow> pumpkin, Saizan: it compiles it to bytecode and interprets it.
19:13:54 <mmorrow> {-# LANGUAGE TemplateHaskell #-}
19:13:54 <mmorrow> main = $([|print $(let fix f = let x = f x in x in fix id)|])
19:13:56 <chessguy> ben_h:  i think the syntax for haskell is one of the things i like most about it
19:14:07 <mmorrow> exhibits the ghci behavior
19:14:10 <ben_h> chessguy: it does seem very well thought out
19:14:10 <pumpkin> ah
19:14:14 <ben_h> consistency to the extreme
19:14:16 <ben_h> which i really like
19:14:32 <pumpkin> mmorrow: maybe there should be an option to create a temporary compiled "code generator" executable?
19:14:47 <rfichoke> im-at-work: hey
19:14:54 <chessguy> > [(x, y) | x <- [1..5], y <- [2,4..12], even (x*y)]
19:14:55 <mmorrow> pumpkin: i was just thinking something along those lines. i think that would be very much worth it.
19:14:56 <lambdabot>   [(1,2),(1,4),(1,6),(1,8),(1,10),(1,12),(2,2),(2,4),(2,6),(2,8),(2,10),(2,12...
19:15:16 <im-at-work> rfichoke: yo
19:15:33 <pumpkin> mmorrow: yeah, and it wouldn't really have to be obvious to the user, just compile to /tmp and run it transparently, or something... unless you really wanted an app that output haskell source to stdout :P
19:15:48 <mmorrow> pumpkin: (although someone might argue that you could always put the code into a lib, compile that, then call it in the splice, and because of this it might not be worth the time/effort of implementation)
19:15:59 <mmorrow> pumpkin: but yeah, i'm all for it.
19:16:38 <pumpkin> it sounds like it wouldn't be too hard to add, but maybe adding a TH-specific command-line option to ghc isn't what people would like
19:17:11 <pumpkin> {-# OPTION PleaseCompileMyTemplateHaskellCauseIt'sProbablySlowKTHX #-}
19:18:17 <mmorrow> pumpkin: this is related to how current ghc is hardcoded to always spit out generated (asm/etc) into a Handle. it would be friggin great if the filesystem was abstracted out and ghc could e.g. compile code directly into memory without touching the disk
19:18:45 <mmorrow> that'd open up a ton of possibilities (or at least make doing them less hackish)
19:19:15 <mmorrow> (and dependent on knowledge of where the tmp files are going, whether they're gonna get deleted, etc..)
19:19:48 <sbahra> Loading code is the hackish part if you compile to memory
19:19:54 <ivanm> mmorrow: even something like live compilation?
19:19:59 <mmorrow> sbahra: have you seen Linker.c? :)
19:20:00 <sbahra> or that is generate the executable to memory
19:20:05 <sbahra> mmorrow, no
19:20:09 <pumpkin> mmorrow: I'd love that, yeah
19:20:21 <sbahra> mmorrow, is it really ugly?
19:20:27 <mmorrow> sbahra: it's ... um ... ok i guess ;)
19:20:32 <sbahra> hehe
19:20:37 <mmorrow> heh
19:20:54 <mmorrow> but yeah, you could dynamically generate and jump into machine code
19:21:00 <sbahra> almost
19:21:03 <mmorrow> just like you can do with bytecode currently
19:21:09 <sbahra> but yeah, there are decent ways to do this
19:21:18 <ivanm> mmorrow: interesting if that could be roughly as fast as interpreting, but more efficient....
19:21:21 <sbahra> mmorrow, but if you generate an ELF, it's a different story
19:21:56 <mmorrow> sbahra: yeah exactly. generate an elf into a mem buffer, then hand Linker.c a ptr
19:21:58 <sbahra> mmorrow, need to correctly offset various table entries, correctly handle GOT, ctors/dtors (that can be from a dependency of the newly generated file), etc...
19:22:00 <pumpkin> mmorrow: then you'd need things like mprotect on many OSes
19:22:06 <sbahra> mmorrow, I see
19:22:08 <mmorrow> or just mmap it first so Linker.c doesn't have to
19:22:09 <pumpkin> but I guess JITs do that a lot anyway
19:22:37 <sbahra> mmorrow, if you make linker.c instead handle memory rather than fd (so mmap'ed regions are passed to it) it would probably be ez pz
19:22:45 <mmorrow> pumpkin: from what i've gathered by reading Linker.c, it has to use mmap on most systems because malloced mem isn't executable
19:23:00 <mmorrow> sbahra: that's what i like to hear!
19:23:07 * mmorrow gets excited
19:23:12 <Elly> mmorrow: modern mallocs use mmap as their backing allocator anyway
19:23:14 <sbahra> haha
19:23:26 <mmorrow> Elly: interesting
19:23:29 <Elly> you can make any memory you like executable with mprotect()
19:23:39 <bd_> mmorrow: at least on linux, malloced memory can be /made/ executable with mprotect, of course. But you need to ensure it's page-aligned anyway to do that, so might as well just ask for it from mmap
19:23:40 <mmorrow> Elly: very interesting
19:23:43 <sbahra> And sometimes even when there is stack/heap protection!
19:23:46 * sbahra coughs at Mac OS X
19:23:51 <pumpkin> lol
19:23:58 <pumpkin> mprotect works in os x too
19:24:21 <sbahra> Yes, but it is pointless to have stack/heap protection if you can just ret-to-mprotect :-P
19:24:27 <int80_h> what's the meaning of LT and GT?
19:24:29 <pumpkin> ah :)
19:24:34 <pumpkin> int80_h: less than greater than
19:24:36 <sbahra> int80_h, Less Than, Greater Than
19:24:46 <pumpkin> > LT
19:24:47 <lambdabot>   LT
19:24:48 <sbahra> pumpkin, that is, NX
19:24:49 <int80_h> thanks
19:24:49 <pumpkin> omG!
19:24:55 <pumpkin> sbahra: yeah
19:26:29 <mmorrow> http://darcs.haskell.org/ghc/rts/Linker.c
19:26:34 <mmorrow> http://darcs.haskell.org/ghc/rts/LinkerInternals.h
19:27:00 * sbahra hates the fact that firefox asks to download the files
19:27:10 <ben_h> sbahra: yeah i can't stand that
19:27:18 <mmorrow> http://www.cs.york.ac.uk/fp/darcs/ELF
19:27:21 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/elf
19:27:24 <ben_h> i think you can set it to autodownload actually
19:27:40 <ben_h> (download but not open)
19:28:04 <sbahra> Appears to take memory already, mmorrow
19:28:11 <pumpkin> mmorrow: is there a Mach-O one too?
19:28:18 <pumpkin> or do they use some other mechanism to generate those?
19:28:21 <mmorrow> sbahra: oh nice
19:28:33 <mmorrow> pumpkin: not that i've seen, but there could be
19:29:12 <sbahra> pumpkin, that has Mach-O support
19:29:25 <mmorrow> the only thing that we don't have is a way to write an ELF datatype (from one of those libs or wherever) to the elf binary fmt
19:30:00 <sbahra> When I'm bored of programming, I feel like a worthless bum
19:30:32 <mmorrow> hah
19:30:48 <sbahra> Really. I feel like I've wasted my life.
19:30:54 * sbahra goes back to programming
19:31:16 <mmorrow> good show
19:33:25 <mmorrow> does anyone know enough about the process for loading an (just consider the simplest case) ELF (assume already parsed to a nice haskell ADT) into memory properly and what linking-ish things one would have to do to it?
19:33:38 <mmorrow> the ELF docs aren't exactly very clear about this
19:33:54 <BMeph> sbahra: Some of my HS classmates are up-and-coming authors, and one is a US Congresswoman married to an astronaut.
19:34:21 <BMeph> Compared to that I think anyone else could feel like they were wasting their lives. :)
19:34:22 <kohwj> hi, i'm having trouble running some reactive-fieldtrip code: runhaskell gives Test.hs: <command line>: can't load .so/.DLL for: HSCabal-1.6.0.1 (libHSCabal-1.6.0.1.so: cannot open shared object file: No such file or directory). does anyone know what's going on? i'm trying to run this file: http://code.haskell.org/reactive-fieldtrip/src/Test.hs
19:34:22 <mmorrow> err, finishing that "enough about .... that they could summarize the highlights of the process in a few sentences?"
19:34:26 <rfichoke> sbahra is like the Alexander the Great of programming: cries when there's no more to conquer :-)
19:35:01 <kohwj> http://hpaste.org/13461
19:35:15 <kohwj> http://hpaste.org/13462
19:35:59 <mmorrow> kohwj: maybe try rebuilding the binary and/or the libs it depends on
19:36:30 <kohwj> mmorrow: is there a way to rebuild all dependencies of a package via cabal install?
19:36:40 <mmorrow> looks like you may have rebuilt one of the deps deps, and that dep can't find its dep any longer
19:37:02 <mmorrow> kohwj: hmm, i'm not sure.
19:37:14 <kohwj> how about rebuilding all cabal packages?
19:37:19 <kohwj> oh, ghc-pkg list.
19:37:44 <mmorrow> ok, in the ghc-pkg list output, any package with '{' '}' around it is borked
19:37:52 <mmorrow> are there any?
19:37:58 <mmorrow> (surrounded in {})
19:38:08 <pumpkin> mmorrow: the process of loading a binary to memory?
19:38:31 <kohwj> mmorrow: nope
19:38:33 <pumpkin> as in, what the "loader" does?
19:38:41 <mmorrow> pumpkin: yes. created the memory image given an ELF (assume said ELF is already parsed into a haskell datatype)
19:38:49 <mmorrow> s/created/create/
19:39:19 <pumpkin> I know the basics of the procedure for mach-o files, and I assume ELF is pretty similar
19:39:26 <mmorrow> pumpkin: as in i can currently parse a .o. i want to write code to load that into a buffer i allocate, then call into it
19:40:11 <dons> ?users
19:40:11 <lambdabot> Maximum users seen in #haskell: 597, currently: 559 (93.6%), active: 18 (3.2%)
19:40:18 <ivanm> hey dons
19:40:20 <dons> oh cool.
19:40:27 <dons> 597.
19:40:29 <ivanm> what, that there's actually people here?
19:40:33 <ivanm> ;-)
19:40:37 <mae> hello!
19:40:44 <dons> hey all!
19:40:45 <mmorrow> pumpkin: sweet. in particular, what are you really doing when you're loading it. from what i understand:
19:41:49 <mmorrow> find all the deps, get those. assume you have [ELF]. so what needs to be done wrt "linking" these together?
19:42:39 <dons> huh, the average for the channel has jumped way up (by 40) in the last month.
19:42:49 <dons> we're bigger than #C++ atm...
19:42:50 <mmorrow> then once you've done whatever that part might entail, you just load (in some appropriate way) each into memory and retain a symbol-to-address mapping et voila?
19:43:19 <pumpkin> pretty much
19:43:32 <pumpkin> mach-os are often "lazy" though
19:43:48 <chessguy> @losers
19:43:48 <lambdabot> Maximum users seen in #haskell: 597, currently: 558 (93.5%), active: 19 (3.4%)
19:44:03 <int80_h> dons: Real World Haskell has encouraged my interest in Haskell. I just ordered that, and a book on functional language data structures.
19:44:09 <mmorrow> hmm. so what is the "general idea"/what-are-you-doing when you're "linking" your [ELF] together?
19:44:15 <int80_h> I imagine, all the new interest comes from that book.
19:44:22 <pumpkin> so usually when you have a library call in a program it gets a thunk given to it, which is just a very simple function that contains a "jump to this address" piece of data, that's easily rewritable
19:44:35 <rfichoke> int80_h: my dad and I are going through that book right now, which is how I ended up here :-)
19:44:36 <mmorrow> is that a PLT?
19:44:38 <chessguy> int80_h:  better tell dons what RWH is, he might not have heard of it
19:45:02 <mmorrow> (or GOT?)
19:45:17 * mmorrow is learning this as he goes along ;)
19:45:21 <pumpkin> mmorrow: I'm not sure what the names for these things are, I've mostly learned about them by poking around when reverse engineering :P
19:45:24 <dons> int80_h, rfichoke wonderful!
19:45:44 <mmorrow> pumpkin: ah, ok cool.
19:45:52 <chessguy> dons:  i found working through the two JSON chapters, trying the examples as i went, to be quite painful
19:46:03 <Elly> oh, I should get RWH
19:46:07 <chessguy> just didn't flow at all for me
19:46:08 <int80_h> dons, I made a failed attempt to write a mud engine a few years back. After I go through this book it makes sense to try once again.
19:46:14 <dons> oh, that's interesting, chessguy.
19:46:15 <mmorrow> pumpkin: (me too, that and reading wonderfully non-informative documentation)
19:46:43 <pumpkin> but in an ARM mach-o, if you called aLibraryFunction(), the compiler would generate a stub for aLibraryFunction that simply contains the instruction ldr pc, #blah, where blah is just a memory chunk right after the stub, that's designed to be rewritten by the loader
19:46:58 <pumpkin> the loader goes through these when loading, and rewrites them to point at the real address of the library after it loads it
19:47:08 <ben_h> swim time, ttyl folks
19:47:10 <chessguy> dons:  i really like the idea, and i think the structure of the package could be used for other things, too. and i understood all the concepts in the chapter, it was just really hard to "follow along"
19:47:18 <pumpkin> or in the case of lazy loading, to a function the loader provides that then goes and retrieves the real function and jumps to it
19:47:23 <mmorrow> pumpkin: is this in the context of shared libs?
19:47:26 <pumpkin> yeah
19:47:30 <mmorrow> ah, ok.
19:47:41 <dons> chessguy: you could submit an errata, that would help us look at it for the 2nd ed.
19:47:53 <chessguy> dons:  yeah, i'm not sure what specifically to say though
19:48:08 <chessguy> there's no one thing to point at
19:48:17 <pumpkin> so a mach-o file is just a list of "load commands" that either tell the loader to go load something else, or to put something at a specific place in memory
19:48:23 <pumpkin> essentially
19:48:30 <pumpkin> there are a few others that contain a symbol table and such
19:48:38 <pumpkin> or code signatures, more recently
19:48:44 <mmorrow> pumpkin: cool. what about the case of only cosidering static libs?
19:49:30 <pumpkin> not actually sure, most of my reverse engineering is on the iphone, which runs mac os (which hates static linkage)
19:49:40 <kohwj> mmorrow: but ghc-pkg check gives no output
19:49:46 <mmorrow> pumpkin: ah, interesting.
19:50:14 <luite> is it possible to have the haskell profiler (+RTS -p) show the cpu time spent in foreign functions?
19:50:19 <mmorrow> kohwj: ah, that's probably why your prog can't find the libs. did they get moved/deleted?
19:50:34 <mmorrow> kohwj: what does $ which ghc   say?
19:50:51 <pumpkin> I'd assume the compiler just pulls out the needed functions from the static lib when linking and puts them into the main executable, eliminating the need for the stubs I mentioned earlier (because it already knows where they'll be loaded)
19:50:58 <pumpkin> the linker, rather
19:51:28 <kohwj> mmorrow: /usr/bin/ghc. btw i just re-installled half my packages in ~/.ghc/i386-linux-6.10.1/package.conf
19:51:34 <mmorrow> yeah, it seems that way, but i'm kinda like "it's quiet .... a little tooooo quiet"
19:51:36 <pumpkin> but I'm really just waving my hands around this time :)
19:51:50 <luite> I just ported some of my haskell code to C, to make it faster (which it is now), but the time spent in those functions doesn't seem to be counted in the cumulative cpu time calling them
19:51:52 <mmorrow> pumpkin: heh, i appreciate the braindump.
19:52:19 <pumpkin> luite: omg free functions!
19:52:23 <mmorrow> kohwj: does "ghc-pkg list" still give no ouput
19:52:25 <mmorrow> ?
19:52:39 <pumpkin> mmorrow: sorry I can't be more authoritative on it :P
19:52:43 <chessguy> @free [a] -> a
19:52:43 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
19:52:48 <luite> pumpkin: the problem is that they still use real time ;)
19:52:50 <chessguy> d'oh
19:53:07 <kohwj> mmorrow: http://hpaste.org/13463
19:54:28 <mmorrow> pumpkin: that's for after we've figured it out flying by the the seat of our pants.
19:54:56 <chessguy> @quote pant
19:54:56 <lambdabot> No quotes match. My brain just exploded
19:55:04 <mmorrow> kohwj: and you rebuilt your prog and same error?
19:55:05 <pumpkin> kohwj: you accidentally left your password in there, btw
19:55:21 <pumpkin> @remember ackbar it's a trap!
19:55:21 <lambdabot> I will remember.
19:55:24 <pumpkin> @quote ackbar
19:55:24 <lambdabot> ackbar says: it's a trap!
19:55:28 <kohwj> pumpkin: what??
19:55:38 <mmorrow> if so, maybe it can't find a lib in your local lib dir
19:55:41 <mmorrow> or something
19:55:43 <pumpkin> kohwj: sorry, just messing with you :P
19:55:59 <mmorrow> hah
19:56:01 <kohwj> pumpkin: not bad.. not bad at all
19:56:30 <kohwj> mmorrow: i rebuilt the ones in the bottom half. not sure if i should touch the ones on top.
19:57:13 <kohwj> mmorrow: i'll try with cabal install cabal --reinstall first
19:58:02 <mmorrow> kohwj: hmm, i only use a the global lib dir and am not super familiar with cabal-install, so i'm kinda out of ideas :/
19:58:15 <mmorrow> kohwj: but good luck :)
19:58:50 <kohwj> mmorrow: whoa, that worked!
19:59:00 <pumpkin> yay
19:59:15 <pumpkin> maybe you deleted something manually? I've done that and it got confused
20:01:28 <kohwj> pumpkin: nope. what i did earlier today was clean out all haskell packages, ghc and cabal, then use the gentoo overlay to start over.
20:01:49 <pumpkin> so you cleared out ghc-pkg's list of them?
20:01:52 <pumpkin> because that's what I did
20:01:57 <pumpkin> I just got rid of my .cabal directory
20:02:02 <pumpkin> but ghc-pkg still knew about all my packages
20:02:23 <kohwj> pumpkin: i cleared them out via gentoo portage
20:02:29 <pumpkin> ah, dunno then
20:03:29 <im-at-home> I'm reading RWH and I find myself wanting to look at some solid Haskell code from an open source project to help cement some of the thing's I'm reading. Can anyone recommend some good source for a noobie to peruse?
20:03:51 <bos> im-at-home: there's loads of good stuff on http://hackage.haskell.org/
20:04:32 <bos> im-at-home: you could start out with looking at some useful libraries, like binary, bytestring, json, HTTP, etc.
20:05:34 <Axman6> im-at-home: the CReal source is rather short, you don't have to understand it all though (i'm just mentioning it because it's about the only source i've really looked at from anyting on hackage :P)
20:06:06 <im-at-home> bos: yes, the libraries seem a good place to look
20:06:34 <Axman6> bos: i just got my copy of RWH yesterday, i'm quite pleased with it, didn't expect it to be quite so big :D
20:06:45 <bos> Axman6: :-)
20:06:51 <ivanm> Axman6: or so buggy? :p
20:07:06 <pumpkin> are any of the haskell sql libraries "type-safe"? it seems like that could be done using TH possibly
20:07:14 <Axman6> well yeah, there's quite a few bugs i picked up, but they're all in the the errata, so s'all good
20:07:51 <Axman6> ivanm: i guess it shows i know what i'm reading if i'm picking up the errors :P
20:07:54 <ivanm> Axman6: there's errata? where?
20:08:03 <Axman6> http://oreilly.com/catalog/9780596514983/errata/
20:08:15 <nanothief> I'm having problems implementing an instance for a class at http://hpaste.org/13464 , could someone have a look? (it has something to do with rigid type variables)
20:09:01 <ivanm> now why isn't that on the rwh site?
20:09:15 <Axman6> nanothief: wouldn't the first definition be id?
20:09:33 <ivanm> Axman6: those mistakes are nothing!
20:09:42 <nanothief> Axman6, thats what I thought, but it resulted in the error shown at the bottom
20:09:42 <ivanm> I've found way more than that!
20:09:42 <Axman6> ivanm: well it's an O'Reilly book so...
20:11:13 <Axman6> well submit them!
20:11:54 <ivanm> dammit, that means I have to find them all again!
20:11:58 <Axman6> ivanm: you seen the RWH price on fishpond now?
20:12:13 <ivanm> nope
20:12:25 <Axman6> think it's $138AU
20:12:51 <Axman6> $136.99AU
20:12:53 <ivanm> :o
20:13:01 <Axman6> so, we got a bargain
20:13:06 <ivanm> Axman6: blame the bad exchange rate
20:13:11 <ivanm> Axman6: damn right we did!
20:13:12 <Axman6> yeah
20:13:27 <pumpkin> could RMonad replace Monad completely and transparently? or does it have any issues?
20:13:28 <Axman6> and they gave me $10 for shipping yours first ;)
20:13:34 <mmorrow> kohwj: nice :)
20:13:52 * nanothief remembers the good 'ol days when the $AU was $US0.98 :(
20:14:00 <ivanm> Axman6: and they gave me $10 for your referall!
20:14:01 <Axman6> yeah :(
20:14:07 <Axman6> ivanm:  i know :(
20:14:13 <Axman6> but... i still have my $10!
20:14:18 <pumpkin> mmorrow: you know of any TH SQL libraries that verify type safety against the db schema at compile time?
20:14:29 <ivanm> Axman6: so did they say why I got mine first?
20:14:36 <mmorrow> pumpkin: there's this http://code.haskell.org/MetaHDBC/
20:14:45 <pumpkin> cool
20:14:45 <Axman6> not really, they just said mine should have shipped first
20:14:52 <chessguy> @hoogle MonadPlus
20:14:53 <lambdabot> Control.Monad class Monad m => MonadPlus m
20:15:00 <ivanm> Axman6: probably because I bitched about not getting it yet ;-)
20:15:11 <Axman6> heh
20:15:28 <Axman6> anyway, i'm going to go read some more of it
20:15:30 <mmorrow> which uses TH and the rdms's prepared stmt ability to tell you the type of the args it's expecting with TH code at compile-time to determine the types of queries
20:15:44 <pumpkin> seems neat :)
20:15:48 <mmorrow> so it assumes that nothing's changed since build time.
20:15:52 <pumpkin> yeah
20:16:23 <mmorrow> yeah, it's a neat idea. i've looked at the code but haven't actually used it (i don't use hdbc)
20:17:00 <mmorrow> but that pkg is always in the back of my mind
20:18:12 <mmorrow> the general idea seems like it shouldn't be too hard in a haskell-dblib-generic way
20:18:25 <pumpkin> yeah
20:18:36 <pumpkin> I have a nagging feeling that it would be nice to get rid of the actual SQL strings too
20:18:44 <mmorrow> *be too hard to implem in a ...
20:19:01 <mmorrow> pumpkin: i friggin HATE writing sql as Strings
20:19:31 <mmorrow> it makes me get random urges to delete the file ever 10 minutes or so :)
20:19:34 <pumpkin> shouldn't it be possible to have a SQL combinator lib in haskell?
20:19:34 <pumpkin> lol
20:19:36 <rfichoke> from what i've seen so far, Haskell's type system looks ideal for wrapping relations and entities
20:20:01 <mmorrow> we just need an SQL parser, a type inferer, and we're golden
20:20:21 <pumpkin> that seems like it would be fun
20:20:43 <mmorrow> rfichoke: totally, you'd have a bunch of options to encode it into the type system
20:21:14 <pumpkin> I really like the look of RMonad... but I haven't heard much about it being used
20:21:30 <chessguy> nanothief:  did you get your question answered?
20:21:56 <chessguy> @hoogle rmonad
20:21:57 <lambdabot> package rmonad
20:22:15 <mmorrow> pumpkin: that would be **the shit**. if we had that, it'd be trivial to make an SQL QuasiQuoter which you just write SQL syntax into, and which compiles staticly into (e.g.) (Double -> String -> ClockTime -> Sql (Integer, Bool))
20:22:59 <mmorrow> i would cry tears of joy
20:23:08 <pumpkin> mmm :)
20:23:15 <chessguy> why would that be so cool? sql sucks
20:23:19 <ivanm> mmorrow: an SQL monad? ;-)
20:23:19 <mmorrow> exactly!
20:23:27 <mmorrow> chessguy: exactly!!
20:24:03 <mmorrow> it sucks so bad that if you have to use it for anything nontrivial, the world of pain you enter in unparalleled anywhere other than in hell.
20:24:03 <arw> chessguy: perhaps, but the only sane way to talk to most databases is sql.
20:24:24 <chessguy> arw:  really? who knew?
20:24:40 <arw> chessguy: there are alternatives, but those only suck harder...
20:24:43 <mmorrow> let me qualify that with "if you have to use it and represent it as Strings ... "
20:24:58 <chessguy> wow, i didn't think sql actually got used. thanks for enlightening me!
20:25:15 <pumpkin> (fromList [1,2,3,4]) >>= \x -> (fromList [7,8,9]) >>= \y -> return (x, y)
20:25:16 <pumpkin> fromList [(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9),(4,7),(4,8),(4,9)]
20:25:17 <pumpkin> :P
20:26:10 <pumpkin> ORLY? SQL is used? :o
20:26:19 <pumpkin> I thought it was only ever complained about
20:26:21 <enticingjelly> chessguy, err. were you seriious?
20:26:23 <chessguy> pumpkin:  apparently so! arw was just teaching us
20:26:40 <chessguy> enticingjelly:  no
20:26:43 <enticingjelly> ok.
20:26:52 <chessguy> enticingjelly:  i use SQL every day :)
20:27:13 <ben_h> sql is a bit lol
20:27:19 * arw is overjoyed for the enlightenment he could bring you :)
20:27:26 <ben_h> but it does its job imo.
20:27:37 <pumpkin> why can't RMonad be standard?? :(
20:27:49 <pumpkin> just cause it uses a GHC-specific feature pff
20:27:56 <chessguy> pumpkin:  i think it would have to be much more widely-used first
20:28:10 <pumpkin> chessguy: but it's beautiful to be able to use >>= on Sets
20:28:21 <pumpkin> or mplus
20:28:31 <chessguy> pumpkin:  don't argue with me, argue with the silent majority :)
20:28:35 <pumpkin> :P
20:28:46 <chessguy> Cale:  :)
20:29:14 <mauke> any ops here? Angelina24-Cam may be a spam bot
20:29:15 <vininim> Angelina24-Cam is spamming on join
20:29:15 <chessguy> ha! rmonad requires you to hide prelude?
20:29:19 <mmorrow> ivanm: ah, i was picturing a data Sql t = ...., where `t' is the type of cols which querying the db with that Sql will result in
20:29:19 <pumpkin> :t foldM
20:29:21 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:29:31 <pumpkin> chessguy: it doesn't require you to, but it's a lot nicer that way :P
20:29:48 --- mode: ChanServ set +o Cale
20:29:49 <sjanssen> mauke: you're not an op?
20:29:53 <ivanm> mmorrow: yeah, I figured something like that
20:29:56 <mauke> sjanssen: nope :-)
20:30:00 <sjanssen> mauke: you should be
20:30:17 --- mode: Cale set +b *!*@host207.190-224-241.telecom.net.ar
20:30:17 --- kick: Angelina24-Cam was kicked by Cale (Cale)
20:30:21 <vininim> he's only op on #c :D
20:30:22 --- mode: Cale set -o Cale
20:30:23 * sjanssen just has to figure out how to do that
20:30:26 <ivanm> but I'm wondering if it'd be possible to do it as a monad.... "chaining" SQL monads would be sub-queries, etc.
20:30:35 <mauke> vininim: EFNET/#c, that is
20:30:49 <vininim> mauke: yes, infidel! ;)
20:30:57 <mauke> also #perlhelp
20:31:00 <Cale> I was just trying to work out which of my channels Angelina24-Cam was in :)
20:31:05 <mmorrow> ivanm: you'd have combinators which operate of the abstract syntax, similar to TH
20:31:08 <vininim> oh my
20:31:15 <mmorrow> s/of/on
20:31:23 <pumpkin> ivanm: so a SqlQuery monad or something?
20:32:08 <ivanm> pumpkin: yeah
20:32:15 <ivanm> don't know how it would quite work though.....
20:32:15 <mmorrow> you could use a monad for the actual querying and connection stuff
20:32:17 <sjanssen> hmm, doesn't haskelldb have an SQL Monad?
20:32:37 <mmorrow> sjanssen: it has a (phantomly typed) Expr type
20:32:50 <mmorrow> and a bunch of other type system machinery
20:33:23 <pumpkin> mmorrow: you should write up an example of what your ideal haskell SQL code would look like and put it on haskell_proposals reddit :P
20:33:23 <mmorrow> GADTs would make this kind of thing a lot more pleasant
20:34:08 <mmorrow> pumpkin: i should write something up.
20:34:23 <pumpkin> if I were better at haskell I'd get started on it already :P
20:34:43 <ben_h> right, time to learn what a monad is.
20:34:44 <chessguy> pumpkin:  where is that reddit?
20:34:54 <pumpkin> http://www.reddit.com/r/haskell_proposals/
20:34:54 <Axman6> haskell_proposale
20:34:57 <nanothief> chessguy: I don't think
20:34:57 <Axman6> s/e/s
20:34:58 <chessguy> @source Monad
20:34:58 <lambdabot> Monad not available
20:35:06 <mmorrow> pumpkin: i actually physically just noted this, because it would make my life that much easier.
20:35:07 <chessguy> @src Monad
20:35:07 <lambdabot> class  Monad m  where
20:35:07 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
20:35:07 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
20:35:07 <lambdabot>     return      :: a -> m a
20:35:07 <lambdabot>     fail        :: String -> m a
20:35:18 <mbz_> @src Comonad
20:35:18 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:35:23 <nanothief> chessguy, umm get my question answered that is
20:35:26 <chessguy> ben_h:  there it is, in all its glory
20:35:37 <ben_h> chessguy: :)
20:35:59 <pumpkin> mmorrow: yours and that of many others, I'm sure
20:36:03 <pumpkin> I've never really liked SQL much
20:36:13 <pumpkin> it's not a pain if you're just querying the DB directly
20:36:34 <pumpkin> but I dunno, it feels dirty
20:36:51 <mmorrow> yeah, but having to generate code programmatically and in an untyped way is torturous
20:37:08 <sjanssen> mmorrow: yeah, it's like being a PHP programmer!
20:37:20 <mmorrow> the horror.
20:37:39 <mauke> :-[ [ChanServ] You are not authorized to perform this operation.
20:37:45 <chessguy> mmorrow: i suppose if you had combinators so that you could built it in typed fashion, and then just a pretty-printing function that spit out the string, it might not be bad
20:37:45 <rfichoke> pumpkin: E.F. Codd thought it was dirty too
20:37:50 <sjanssen> mauke: to perform what?
20:37:58 <mauke> sjanssen: see channel flags on #haskell
20:38:37 <mmorrow> chessguy: true, but it's infeasible to translate pages of existing SQL to that
20:38:39 <Axman6> someone should write a purely haskell database
20:38:54 * Axman6 adds that to the list of haskell proposals
20:38:54 <chessguy> mmorrow:  mm, yeah, you'd have to write a parser too
20:39:07 <pumpkin> which TH could do
20:39:10 <chessguy> Axman6:  there are a number of haskell dbs
20:39:21 <mmorrow> with a parser and typechecker, you could read in 4000 lines of SQL, do completely typesafe transformations on it, generate a bunch more, then start crushing
20:39:23 <Axman6> chessguy: i know, but i want one written in haskell
20:39:36 <Axman6> unless... they do exist... and that's what you're saying
20:40:06 <chessguy> Axman6:  this is what i'm talking about, not sure if it's what you're talking about: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Database
20:40:41 <chessguy> mmorrow:  that would be pretty cool
20:40:43 <Axman6> chessguy: they're all interfaces to non haskell databases
20:40:47 <pumpkin> it could also take over where prepared statements fail
20:40:58 <mmorrow> chessguy: and you wouldn't have to worry that you accidently the accounting data
20:41:02 <chessguy> Axman6:  oh, i see, you mean an actual db engine
20:41:11 <Axman6> yes
20:41:37 <kohwj> thanks mmorrow and pumpkin!
20:41:39 <kohwj> cya all
20:41:44 <chessguy> hm, cool stuff
20:41:45 <mmorrow> chessguy: totally. that's would great.
20:42:01 <pumpkin> hah, I thought all I did for him was freak him out about giving out his password :o
20:42:29 <chessguy> mmorrow:  what kind of transformations do you ahve in mind?
20:42:37 <chessguy> mmorrow:  also, there are numerous flavors of SQL
20:43:12 <mmorrow> chessguy: yeah, true. the dialects would be a nuisance, but i think it'd be manageable
20:43:13 <pumpkin> it would be nice if you supported all of them and could convert between them as needed depending on the db
20:43:59 <chessguy> yeah, we'd probably have to start with getting an understanding of what support already exists in hackage
20:44:27 <chessguy> e.g., http://hackage.haskell.org/packages/archive/haskelldb/0.10/doc/html/Database-HaskellDB-Sql.html
20:45:17 <mmorrow> chessguy: well, first consider generating a query. so say you are doing a select with a group by. suppose you want to create a Tree (SqlVal, [SqlVal]), where each node is the aggregation of its entire subforest. so that's a select + groupby for each level of the tree.
20:45:48 <pumpkin> it would be nice if we could get more people following the haskell_proposals reddit
20:47:23 <chessguy> pumpkin:  i don't reddit much, is it possible to sort those by number of votes
20:48:05 <pumpkin> chessguy: not quite, but you can get an idea of which ones have lots of votes at http://www.reddit.com/r/haskell_proposals/top/
20:48:21 <chessguy> pumpkin:  ...
20:48:25 <pumpkin> :P
20:48:28 <mmorrow> transformations-wise, you could substitute in /any/ subpart of an sql stmt, not just be limited to what you can replace '?' by in prepared stmts
20:48:28 <chessguy> none?
20:48:38 <pumpkin> chessguy: ?
20:48:51 <chessguy> pumpkin:  when i hit that link it says there's nothing there
20:48:58 <chessguy> mmorrow:  that's a cool idea
20:49:05 <pumpkin> oh weird, it's got a big list of stories on mine
20:49:38 <mmorrow> then start fmap zipWith foldl on these substitutions/etc and all of a sudden you can do a days worth of sketchy hackish work in 10 minutes
20:49:45 <rfichoke> mmorrow: Ruby's ActiveRecord does some of that
20:49:59 <pumpkin> rfichoke: completely hiding you from the SQL though
20:50:04 <mmorrow> rfichoke: interesting, i'll check that out
20:50:09 <rfichoke> pumpkin: right
20:50:15 <rfichoke> pumpkin: well, mostly
20:50:22 <pumpkin> rfichoke: so it's really just marshalling ruby objects to and from sql
20:50:29 <pumpkin> or not?
20:50:45 <chessguy> pumpkin:  oh, it was set to just "today"
20:50:45 <jsn> well, there's also the issue of query compilation/substitution
20:50:46 <rfichoke> pumpkin: yep
20:51:08 <rfichoke> It doesn't scale well to complicated queries, though
20:51:09 <pumpkin> chessguy: yeah, that's a result of the dwindling interest :(
20:51:11 <jsn> does it allow you to generate SELECTs with Ruby idioms, for example?
20:51:11 <Axman6> ha, reddit: slow down mate, you're posting too fast. try again in 8 minutes.
20:51:18 <pumpkin> jsn: nope
20:51:25 <pumpkin> unless you mean just find
20:51:29 <mauke> wtf is going on with old-time
20:51:30 <jsn> oh, that's it
20:51:34 <pumpkin> there's a Class.find(...)
20:51:41 <pumpkin> you can stick all sorts of stuff into that
20:51:46 <jsn> mauke:  it is deprecated
20:51:52 <jsn> yeah, it's garbage
20:51:54 <mauke> jsn: and it doesn't build
20:52:03 <jsn> and it doesn't work, either
20:52:13 <rfichoke> You typically write wrapper find methods for more complicated stuff
20:52:20 <rfichoke> But anything sufficiently complicated quickly gets messy
20:52:29 <pumpkin> rfichoke: however the wrappers happen on the ruby side, not the db side
20:52:40 <pumpkin> although a more complicated SQL query could potentially do that on the db side
20:52:43 <jsn> i think isolating yourself from SQL is unwise, really
20:53:05 <pumpkin> to an extent I like being isolated from it, but sometimes doing stuff on the client side is silly when the DB could do it a lot more efficiently
20:53:21 <jsn> well, there's also just the idea of semantic mismatch
20:53:30 <rfichoke> pumpkin: yeah, when working in Rails, I often drop down to find_by_sql for using UNIONs and such
20:53:36 <jsn> SQL allows you to express complicated DB stuff comparatively well
20:53:56 <pumpkin> yeah
20:54:01 <jsn> though of course, if you want a good relational language you need datalog
20:54:25 <jsn> but oh well
20:54:40 <mmorrow> add the ease with which haskell can manipulate trees (here, the tree that is the AST for the SQL query under consideration) and wow
20:54:57 <chessguy> jsn:  yeah, the biggest problem is a lack of typing
20:55:03 <chessguy> well, one of the biggest
20:55:14 <jsn> mmorrow: yeah, i think quasi-quoting could allow for a really pleasing approach to embedded SQL
20:55:25 <chessguy> what is quasi-quoting?
20:55:27 <mmorrow> jsn: totally.
20:55:30 <chessguy> pardon my ignorance
20:55:38 <mmorrow> , [$tyQ| \x -> x |]
20:55:41 <jsn> chessguy: it is a new language feature -- part of 6.10
20:55:50 <chessguy> ...
20:55:52 <mmorrow> lunabot has to wake up
20:55:53 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
20:55:56 <jsn> it allows you write a function that is called at compile time
20:56:04 <jsn> that generates haskell AST
20:56:24 <jsn> by parsing a string inside the brackets
20:56:26 <chessguy> oh, a built-in TH?
20:56:29 <jsn> for exammple
20:57:23 <mmorrow> , [$tyQ| \x -> x |]
20:57:28 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
20:57:29 <mmorrow> , substT [(mkName "a", unQ[t|Int|])] [] [$tyQ| \x -> x |]
20:57:35 <lunabot>  AppT (AppT ArrowT (VarT a)) (VarT a)
20:57:36 <mmorrow> , ppDoc [$tyQ| \x -> x |]
20:57:38 <jsn> reges = [$r|^([^ ]+) .+$|]
20:57:41 <mmorrow> , ppDoc $ substT [(mkName "a", unQ[t|Int|])] [] [$tyQ| \x -> x |]
20:57:41 <lunabot>  forall a . a -> a
20:57:46 <jsn> regex = [$r|^([^ ]+) .+$|]
20:57:46 <lunabot>  a -> a
20:57:49 <mmorrow> oops
20:58:01 <jsn> it's related to TH
20:58:01 <pumpkin> mmorrow: can you write arbitrary text into those things, or must you still stick arbitrary (invalid haskell, that is) stuff into strings in TH?
20:58:05 <mmorrow> (pretend that worked ;)
20:58:17 <mmorrow> pumpkin: arbitrary text.
20:58:23 <pumpkin> ooh
20:58:25 <mmorrow> and it gets handed to your parser as a String
20:58:32 * pumpkin writes LaTeX replacement in haskell
20:58:33 <pumpkin> lol
20:58:39 <jsn> LOLz, yeah
20:58:43 <jsn> also, sed
20:58:49 <jsn> but later...
20:58:56 <chessguy> mmorrow:  jsn: does it get type-checked at compile time too then?
20:59:03 <jsn> chessguy: yes
20:59:14 <mmorrow> which you then have to turn into an ExpQ, which abstractly represents the syntax of the haskell code which you want to spit out
20:59:15 <jsn> chessguy: you generate Haskell AST
20:59:25 <mmorrow> chessguy: yes, everything at compile-time
20:59:25 <chessguy> so....the resulting errors are on the AST that you don't see?
20:59:39 <jsn> chessguy: well, your parser should throw errors, right?
20:59:56 <chessguy> i'm talking about the type errors
20:59:59 <mmorrow> , $([|show (42 id)|])
21:00:04 <lunabot>  luna: No instance for (GHC.Num.Num ((a1 -> a1) -> a))
21:00:18 <mmorrow> , $([|show (id 42|])
21:00:20 <lunabot>  luna: parse error on input `|]'
21:00:24 <mmorrow> , $([|show (id 42)|])
21:00:27 <lunabot>  "42"
21:00:27 <jsn> your parser has to type check
21:00:28 <ik> DAYCHANGE!
21:00:39 <mmorrow> , [|42|]
21:00:39 <chessguy> hm
21:00:41 <lunabot>  LitE (IntegerL 42)
21:00:43 <mmorrow> , $([|42|])
21:00:45 <lunabot>  42
21:00:48 <mmorrow> , $([|42|]) == 42
21:00:49 <jsn> in short, your parser can produce untypable AST
21:00:50 <lunabot>  True
21:00:51 <chessguy> oh, gotta check xkcd :)
21:01:02 <jsn> in short, your parser cannot produce untypable AST
21:01:06 <pumpkin> is there some way of getting lambdabot to change nick at runtime?
21:01:22 <mauke> @nick e
21:01:22 <jsn> ?localtime ik
21:01:22 <lambdabot> Maybe you meant: dice dict
21:01:23 <lambdabot> Local time for ik is Wed Dec 31 00:01:22 2008
21:01:39 <pumpkin> the command list doesn't even include @join and @part
21:01:43 <mmorrow> yeah, you can construct any mangled type-incorrect abomination you'd like. completely analogous to how you can randomly type chars into a file and then try to get ghc to compile that file.
21:02:02 <jsn> i don't think that's true
21:02:08 <jsn> you can't write TH that does that
21:02:19 <jsn> because TH is all in terms of ExpQ
21:02:33 <jsn> quasi-quoting doesn't take strings to strings
21:02:47 <mmorrow> jsn: what if you parse a string with haskell-src-exts, then manually transform that AST to the TH AST.
21:02:48 <pumpkin> you can produce valid ASTs that don't typecheck though, right?
21:03:11 <jsn> well, you don't actually produce ASTs
21:03:16 <jsn> you produce ExpQ
21:03:20 <mmorrow> jsn: i'm talking you can build that /before/ ghc typechecks it
21:03:41 <mmorrow> just like you can write garbage into a .hs file /before/ you run $ ghc --make garb.hs
21:03:56 <mmorrow> but in both cases ghc will reject the program
21:04:01 <jsn> mmorrow: i'm talking about quasi-quoting in particular
21:04:18 <jsn> i don't think you can write TH that generates invalid haskell
21:04:27 <jsn> the TH would fail to typecheck
21:04:45 <jsn> and quasi-quoting is piggy-backed on TH
21:04:48 <mmorrow> jsn: oh, well you have to produce an ExpQ, which may represent an invalid expression, and this gets checked when ghc splices it into the code
21:05:16 <jsn> mmorrow: i was not aware ExpQ could actually represent an invalid expression
21:05:19 <jsn> but i am not sure
21:05:24 <mmorrow> sure it can
21:05:48 <mmorrow> well, do you mean "not-type-correct" or "syntactically invalid"
21:05:48 <mmorrow> ?
21:06:05 <jsn> i mean, not type correct
21:06:11 <mmorrow> oh, sure it can
21:06:17 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-Syntax.html#t%3AExp
21:06:22 <mmorrow> , [|\x -> x x|]
21:06:24 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = t -> t1
21:06:39 <chessguy> ok, bed time for me
21:06:43 <chessguy> 'night all
21:06:45 <jsn> mmorrow: okay, but that was caught at the template definition
21:07:00 <jsn> not at some mysterious far away place
21:07:08 <nanothief> I'm (still :S) having problems with this bit of code: http://hpaste.org/13464 . I have no idea why getChildren = id doesn't work
21:07:09 <mmorrow> , let x = mkName "x" in LamE [VarP x] (VarE x `appE` VarE x)
21:07:11 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
21:07:17 <mmorrow> , let x = mkName "x" in LamE [VarP x] (VarE x `AppE` VarE x)
21:07:19 <lunabot>  LamE [VarP x] (AppE (VarE x) (VarE x))
21:07:27 <pumpkin> LamE? :P
21:07:28 <pumpkin> lol
21:07:29 <mmorrow> you can manually build the AST too
21:07:40 <mmorrow> , $(let x = mkName "x" in LamE [VarP x] (VarE x `AppE` VarE x))
21:07:41 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
21:07:44 <jsn> interesting
21:07:48 <mmorrow> , $(return (let x = mkName "x" in LamE [VarP x] (VarE x `AppE` VarE x)))
21:07:51 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = t -> t1
21:07:56 <jsn> well, i'd like to know more about this than i do
21:08:06 <mmorrow> jsn: it's way cool stuff
21:08:13 <mauke> nanothief: no, it shouldn't be an instance
21:08:28 <jsn> so, a number of people are asking me for a good book to learn haskell from
21:08:41 <nanothief> mauke: whats wrong with it?
21:08:58 <mauke> nanothief: that type can't output OrgFileElements
21:09:02 <jsn> i didn't learn from books, though -- i basically learned from "scheme in 48 hours", the haddock and this channel
21:09:07 <mauke> nanothief: it can only input, using mplus
21:09:16 <jsn> what books seem good to y'all?
21:09:27 <pumpkin> are there any good ways to make a "static array"? I was thinking TH would be good for writing static look-up tables but it would be nice to not have to compute this at startup in your program (say it takes hours to make the lookup table)
21:09:45 <pumpkin> although the lack of compiled TH would make that more painful, potentially, for now
21:09:58 <jsn> everyone whose talked to me about it is a C, C++, Java or C# programmer
21:10:24 <jsn> (they invariably have experience with 2 or more of those languages)
21:10:32 <jsn> pumpkin: i would recommend the FFI
21:10:38 <mmorrow> pumpkin: i guess you could always throw the critical code into a compiled lib, then just call into it from the compile-time code in your prog
21:10:48 <mmorrow> as a work-around
21:10:50 <pumpkin> mmorrow: yeah :)
21:10:53 <mmorrow> heh
21:10:56 <pumpkin> just saying in a hypothetical situation
21:11:03 <pumpkin> in which you have something very expensive to look up
21:11:15 <mmorrow> totally.
21:11:16 <pumpkin> is there a way of writing a static datastructure?
21:11:32 <bos> @seen dons
21:11:33 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1h 23m 51s ago.
21:11:37 <pumpkin> I mean, doing listArray is fine in most cases
21:12:06 <mmorrow> you can for instance splice in a precomputed Map or something
21:12:09 <pumpkin> but a compile-time array seems like it would be neat, or a compile-time hash (a perfect one)
21:12:10 <pumpkin> or something
21:12:16 <nanothief> mauke, you're right, I never thought of that. However should that matter? All I want is the getChildren instance for m OrgFileElement is to return its input unchanged. Is this not possible?
21:12:33 <mauke> nanothief: no, because it has the wrong type
21:12:37 <mmorrow> yeah, you can splice in anything you could type into a file in your editor
21:12:48 <mauke> nanothief: you'd have to read the elements from your original type, then convert it to the output type
21:12:48 <mmorrow> even 8000 lines of it
21:12:49 <Axman6> pumpkin: could you not save it to a file and read it in?
21:12:51 <pumpkin> something like http://www.gnu.org/software/gperf/ could be put into TH and be a lot more elegant than adding gperf as a step in your makefile
21:13:02 <pumpkin> Axman6: yeah, I guess, but that feels ugly :)
21:13:13 <mauke> nanothief: nothing guarantees that the two (MonadPlus m) types are the same
21:13:40 <Axman6> i've just been reading the IO chapter of RWH, and  seems like it'd be really eady
21:13:43 <Axman6> easy*
21:13:50 <pumpkin> what would?
21:14:33 <mmorrow> and you can do IO in a TH splice as well
21:15:08 <pumpkin> how are large pattern matches dealt with by GHC btw?
21:15:12 <pumpkin> say I had a function that took a string
21:15:21 <pumpkin> and I gave it 20000 constant strings as patterns
21:15:23 <mmorrow> runIO (writeFile "foo.hs" "main = print [0..]" >> system "ghc -O2 --make foo.hs && ./foo")
21:15:23 <nanothief> mauke: oh so this should be legal: getChildren [OrgFileElement 1, OrgFileElement 2] :: Just OrgFileElement
21:15:26 <jsn> pumpkin: http://markmail.org/message/6l3dyot2k2nopzug
21:15:44 <nanothief> (which isn't possible with my definition)
21:16:01 <jsn> pumpkin: making a huge case statement is an interesting approach
21:16:04 <mauke> nanothief: yes. the definition of the OrgParentElement class says that the caller gets to choose the MonadPlus instance
21:16:31 <pumpkin> jsn: you made a huge static list?
21:16:36 <pumpkin> ah
21:16:45 <jsn> i made a huge static trie
21:16:49 <andyjgill> Quick question: are there conventions with versions numbers on hackage?
21:16:56 <pumpkin> I'm just wondering what happens behind the scenes with those pattern matches
21:17:00 <jsn> and implemented binary search with pointers, &c.
21:17:06 <pumpkin> ah, yeah
21:17:15 <pumpkin> because if it's doing something smart on pattern matches
21:17:29 <jsn> yeah, i am curious about that, as well
21:17:34 <pumpkin> you could just write a lookup :: String -> [(String, String)] function in your case
21:17:38 <jsn> that could be best -- make a huge case
21:17:41 <pumpkin> and give it MANY MANY patterns :P
21:17:44 <nanothief> mauke: heh no wonder I was having trouble getting it to work :P . Would it be possible to force the instance to use the same m as the class, so the getChildren [...] :: Just OrgElement statement would be illegal?
21:17:52 <jsn> and you could nest them to get a trie, for example
21:18:06 <pumpkin> you could, but maybe ghc is smart and already does some cool stuff for pattern matches
21:18:10 <pumpkin> it feels like voodoo
21:18:16 <jsn> heh
21:18:18 <pumpkin> :P
21:18:30 <jsn> yeah, i didn't know template haskell back then, so i learned the FFI
21:18:33 <bos> andyjgill: not really
21:18:49 <mauke> nanothief: you could do something like class (MonadPlus m) => OrgParentElement m p where getChildren :: p -> m OrgFileElement
21:18:56 <mauke> (not Haskell98)
21:19:15 <pumpkin> Simon-log
21:19:16 <pumpkin> lol
21:19:16 <andyjgill> Hi bos! I've got a tiny API change, but do not want to bump the major number.
21:20:16 <bos> andyjgill: a lot of people seem to use major.minor.bugfix, where minor can have small API changes.
21:20:39 <bos> hi matthewp
21:20:51 <nanothief> mauke, Well that looks promising (or I might just refactor the program a bit, I'm not sure). Anyway, thanks for your help :)
21:20:55 <matthewp> bos: hi there
21:21:24 <matthewp> bos: hoping for a good turnout on Monday
21:21:33 <bos> matthewp: I have a bunch of info to send you re possibly running the book club. will send in the morning.
21:21:47 <matthewp> bos: excellent, I was just about to send you an email about it
21:21:58 <matthewp> bos: also looking for some good project ideas to kick along the way
21:22:16 <bos> hmm.
21:22:22 <bos> for yourself, or the club?
21:22:37 <matthewp> bos: seems like someone in Colorado is also starting a local chapter
21:22:45 <bos> i saw, pretty nifty.
21:22:52 <Nafai> matthewp: So how is the book club going to work?
21:23:03 <Nafai> I can't remember what the last e-mail I got said :)
21:23:04 <matthewp> bos: you'll love this, the Microsoft Visual Languages team is creating their own subgroup
21:23:23 <matthewp> bos: for the real world haskell book club
21:23:25 <bos> matthewp: there's at least one group within google doing it, too
21:23:56 <schme_> mornin'
21:23:59 <matthewp> Nafai: Well, we're gathering on IRC and DimDim or whatever bos can help me with
21:24:15 <Nafai> Cool
21:24:26 <matthewp> Nafai: January 5th, 8PM EST (-5GMT)
21:24:40 <Nafai> Does Dim Dim work with Linux? :)
21:24:56 * Nafai adds to calendar
21:24:59 <Nafai> About how long?
21:25:09 <matthewp> bos: Very cool about Google doing the same.  They just opened an office near my house and looking tempting
21:25:24 <matthewp> Nafai: two hour sessions I believe, but we'll gauge after the first
21:25:28 <Nafai> Ok
21:25:40 <matthewp> bos: I'm thinking projects that we can do on a chapter by chapter basis
21:25:51 <bos> matthewp: i see. hmm.
21:25:57 <matthewp> bos: and then one that we work on as we move along to the grand finale
21:26:16 <bos> matthewp: i think that might be a good wisdom-of-the-crowd candidate.
21:26:18 <matthewp> bos: doesn't have to be much
21:26:31 <matthewp> matthewp: agreed, but just thought I'd through it out there
21:27:04 <matthewp> bos: was planning to talk about the first chapter, installation issues, installing packages and so on.  elementary stuff
21:27:28 <matthewp> bos: but I'm excited that we have a lot of deep Haskellers as well on the list
21:27:43 <Nafai> I hope I can find RWH in a bookstore this week
21:27:47 <Nafai> I'd like to have the dead trees version
21:28:06 <matthewp> Nafai: there is the online version, but agreed the dead tree version is a lot nicer
21:38:02 <pumpkin> ghc doesn't like this :P
21:38:54 <pumpkin> I just gave it a 161k pattern
21:38:58 <pumpkin> 161k lines that is
21:39:32 <ben_h> is it true that an I/O action can't be called from within pure code?
21:39:46 <dibblego> ben_h, yes
21:39:56 <bd_> that's part of what pure implies
21:40:05 <ben_h> if so, i don't see how the majority of a program can remain pure - if one small piece of I/O is required deep in a program, doesn't that break purity all the way up from there to main?
21:40:31 <bd_> this is where you make sure your IO isn't deep in your program :)
21:40:31 <dibblego> ben_h, that's why Haskell programs are written the right way around instead of the usual backward way
21:40:49 <ben_h> that's sort of what i expected
21:40:51 <ben_h> good point
21:40:55 <bd_> haskell encourages a strong seperation between IO and logic
21:41:06 <ben_h> that yeah it would break purity, but only if you're doing it wrong
21:41:06 <ben_h> :)
21:41:26 <ben_h> tangent: that makes it sound ideal for designing MVC systems
21:42:06 <BMeph> ben_H: hASKELL _is_ AN mvc SYSTEM. ;)
21:42:07 <pumpkin> what about outputting log messages at various steps in your logic? :P
21:42:24 <BMeph> Sorry about the reversed Caps. :)
21:42:30 <pumpkin> @hoogle getArgs
21:42:30 <lambdabot> System.Environment getArgs :: IO [String]
21:42:34 <ben_h> pumpkin: yeah that's the sort of thing i was thinking of
21:42:35 <Gracenotes> as far as I can tell, the general idea is to "lift" the pure code into evaluation by an impure input
21:42:56 <bd_> pumpkin: for debug?
21:43:02 <Gracenotes> A nifty idea...
21:43:02 <bd_> or just plain production logging?
21:43:06 <pumpkin> production logging
21:43:15 <pumpkin> debug.trace is fine for debugging
21:43:29 <bd_> generally this'd mean splitting up your logic to clarify what steps you want to log :)
21:43:33 <pumpkin> :P
21:43:37 <pumpkin> fair enough
21:43:47 <pumpkin> ghc is taking up almost 400 megs of ram
21:43:50 <bd_> I mean, putting a log message deep in the middle of some calculation is madness
21:43:52 <pumpkin> I'm stress testing it
21:44:32 <pumpkin> how can I ask ghc to give me its generated c code?
21:44:36 <ddarius> pumpkin: GHC doesn't handle large source file well at all.
21:44:42 <pumpkin> ddarius: I'm noticing :P
21:45:03 <ben_h> bd_: good point
21:45:04 <pumpkin> this one's six megabytes
21:45:09 <pumpkin> and contains two functions :P
21:45:18 <ben_h> especially when it's all pure and should be encapsulated/tested/done
21:45:21 <ben_h> but that's all in theory :)
21:45:29 <bd_> pumpkin: RTFM :) and note that without -fvia-c, there is no generated c
21:45:40 <pumpkin> bd_: thanks :P
21:45:44 <bd_> and also note that if you do use -fvia-c GHC mangles up the generated asm a good bit
21:46:12 <pumpkin> I'm just curious what it's doing with my huge pattern
21:46:13 <bd_> pumpkin: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#keeping-intermediates
21:46:21 <pumpkin> ah, ghc ran out of stack space
21:46:42 <bd_> pumpkin: also generating core may be more useful
21:46:51 <pumpkin> won't core just show me a bunch of case statements?
21:47:26 <bd_> pumpkin: sure, and that'll probably be more useful than raw C :)
21:47:29 <bd_> -ddump-stg
21:48:04 <bd_> see also http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
21:48:14 <pumpkin> bd_: I mean, I'm giving it essentially a case statement with 160000 cases right now, won't it just generate the same case statement in core?
21:50:03 <bd_> pumpkin: maybe. but the translation from -ddump-stg to raw code is fairly boring
21:50:10 <ddarius> pumpkin: You'll never get that to compile.
21:50:11 <bd_> all the optimization happens before that point
21:50:17 <bd_> so usually you'll find what you're interested in there
21:50:22 <pumpkin> okay, I'll take a look
21:50:37 <pumpkin> ddarius: :(
21:51:03 <bd_> ddarius: that sounds like a challenge
21:51:51 <pumpkin> wasn't there a command-line option for telling cabal about additional include/library paths?
21:51:56 <pumpkin> I can't find it
21:53:49 <pumpkin> mmm ghc is using half a gig :P
21:53:59 <pumpkin> jsn: this might not be the best approach
21:54:00 <pumpkin> :P
21:57:18 <pumpkin> do any of you know if ghc does anything to optimize large pattern matches though?
21:57:36 <pumpkin> or did they just say not try because it's impossible to compile large files anyway?
21:57:37 <mae> how can i define as a parameter to template haskell the composite type (Map String String) .. if it were one type for example String I would say ''String
21:57:51 <ddarius> bd_: Okay, but the challenge is hacking GHC.
22:00:14 <mnpn> I have a question
22:00:30 <pumpkin> do you now
22:00:51 <pumpkin> before asking it, you need to wire me one trillion USD
22:01:04 <mnpn> what advantage to parallelism does haskell have
22:01:13 <pumpkin> !!!
22:01:21 <pumpkin> purity makes parallelism a bit easier
22:01:39 <sclv> ghc as a runtime has super fast lightweight green threads.
22:01:49 <ddarius> alpha DX 2
22:01:50 <sclv> which isn't innate to the language, but is nice.
22:01:53 <jsn> pumpkin: curses
22:02:05 <pumpkin> jsn: using almost 800 MB now and still hasn't finished compiling
22:02:10 <jsn> !!
22:02:10 <pumpkin> maybe I'll turn down the -O and try again
22:02:19 <ddarius> pumpkin: That won't help meaningfully.
22:02:21 <pumpkin> this for a 6MB .hs file
22:02:29 <jsn> it's FFI all the way down...
22:02:49 <cjb> mnpn: the problem with parallelism is that you don't know which computations can be parallelized -- they might depend on other values being available, or they might not
22:02:57 <pumpkin> ddarius: is the time exponential in the filesize or something? the code isn't complex in any sense
22:03:20 <cjb> mnpn: haskell's notion of purity means that it knows the answer to that, so it makes parallelism easier.
22:03:22 <cjb> (or something.)
22:03:30 <ddarius> pumpkin: I don't believe it's exponential, it's just a large constant factor or so.
22:03:41 <pumpkin> very large :P
22:03:43 <ddarius> pumpkin: Much smaller files than that have failed to compile.
22:03:48 <pumpkin> maybe I'll chop off the end of it
22:03:52 <sclv> are there lots of types to infer?
22:03:57 <pumpkin> sclv: none at all
22:04:04 <sclv> yow
22:04:13 <pumpkin> sclv: I was just trying to see how well pattern matches performed
22:04:20 <pumpkin> for very large patterns
22:04:45 <sclv> as in case x of (huge pattern) or as in case x of (large list of small patterns) ?
22:04:48 <pumpkin> (as a way of encoding a static lookup table)
22:04:55 <pumpkin> sclv: large list of small patterns
22:05:00 <pumpkin> as function parameter though
22:05:03 <mnpn> cjb: is there some resemblance to polynomials / algebra?
22:05:30 * BMeph waits for the message : "mnpn throws up" ;p
22:06:24 <cjb> mnpn: not that I can think of.
22:06:36 * sclv ponders chuch-encoding static lookup tables.
22:06:56 <pumpkin> ddarius: I've truncated my file to 10k lines, think that'll help?
22:07:09 <pumpkin> 540k now
22:07:17 <ddarius> pumpkin: It'll help, but again, quite probably not meaningfully.  Try it and find out.
22:07:28 <mnpn> cjb: so it's based on lambda notation right?
22:07:47 <ddarius> It is well known that GHC does very poorly on large files.  Even simply large constants cause problems.
22:07:48 <sclv> lambda calculus
22:08:00 <pumpkin> ddarius: ah :/
22:10:18 <b7j0c> quick question: does anyone know of a haskell library that provides "find"-like functionality?
22:10:23 <mnpn> no data?
22:13:27 <mmorrow> pumpkin: i tried turning /usr/share/dict/words into a trie or chars turned into a case expression tree with TH. the most i could get ghc to compile was up to the start of the 'b's
22:13:36 <mmorrow> *trie of chars
22:13:37 <BMeph> b7j0c: Slow question: What do you consider "find"-like functionality? :)
22:13:52 <pumpkin> mmorrow: yeah, I'm trying edict without even making a trie out of it:P
22:14:10 <b7j0c> BMeph: lets say i wanted to run the find equivalent of find . -name *.ogg
22:14:32 <mmorrow> looking up a word starting with 'a' was lightning-fast though!
22:14:37 <pumpkin> mmorrow: I bet
22:14:40 <mmorrow> heh
22:14:50 <pumpkin> mmorrow: do you happen to know how it does pattern matches on constant lists/strings?
22:15:02 <b7j0c> BMeph: i.e. a recursive listing of all matching files. i recall something from a regex module that did something like this, can't find it now...
22:15:41 <mmorrow> pumpkin: i think the standard work-around is to put the mass of static data into a .c, then foreign import ccall unsafe "&" the_stuff :: Ptr CBlah
22:15:49 <pumpkin> yeah
22:15:53 <pumpkin> just curious how it does it
22:16:34 <mmorrow> i guess is just does an equality check
22:16:38 <bos> b7j0c: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip
22:16:47 <pumpkin> mmorrow: so it's linear in the number of patterns?
22:16:49 <b7j0c> bos:
22:16:54 <b7j0c>  bos: thanks!!
22:17:06 <b7j0c> bos: p.s. the book rules too
22:17:07 <mmorrow> the thing is though, i'm not sure how it represents to static data
22:17:17 <bos> b7j0c: thanks :-)
22:17:31 <mmorrow> (during compilation)
22:18:10 <mmorrow> it seems to be doing something or other with it as compilation just goes and goes and goes if you're got a massive amount of it in the src file
22:18:48 <mmorrow> if you do the foreign import ... you can wrap it in
22:18:56 <mnpn> sclv: what did church do about "incomplete" math?
22:19:47 <BMeph> bos: Thanks for answering...I still wasn't sure if he wanted to search the directory, or just wanted a function that worked in a similar way... :)
22:20:08 * sclv waits for the punchline
22:20:21 <mmorrow> valAt i = unsafePerformIO (peek (the_stuff `plusptr` (i*sizeOf(undefined::CBlah))))
22:20:29 <mmorrow> heh, i got lost in the parens there
22:20:51 <mmorrow> valAt :: Int -> CBlah
22:21:51 <mmorrow> pumpkin: i'm not really sure
22:21:57 <mnpn> sclv: i am impressed that so many things can be represented as algebra, but how do i know that a word is a password?
22:22:06 <mmorrow> (not sure what "it" is)
22:22:43 <sclv> how do i know that a bot uses markov methods?
22:22:53 <mmorrow> mnpn: simple. they're always "******".
22:23:40 <pumpkin> lol
22:23:47 <pumpkin> mnpn: what does that mean?
22:24:09 <mnpn> well, there is a way to say this with lambda algebra?
22:25:11 <mmorrow> @. vixen . elite nixon
22:25:11 <lambdabot> you sound like an awesome guy... are you single?
22:25:15 <mmorrow> @. vixen . elite nixon
22:25:16 <lambdabot> have you ever scubadived?
22:25:19 <mmorrow> @. vixen . elite nixon
22:25:19 <lambdabot> i'm the type of girl that finds Don Knotts very sexy
22:25:31 <mmorrow> @. elite . nixon
22:25:32 <lambdabot> nO7 3n0U9|-| 4r9uMEn7$ T0 @.
22:25:50 <sclv> ?nixon
22:25:51 <lambdabot> I can see clearly now... that I was wrong in not acting more decisively and more forthrightly in dealing with Watergate.
22:26:04 <sclv> haha wao is nixon new?
22:26:09 <mmorrow> @nixon
22:26:09 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
22:26:32 <pumpkin> @. elite . nixon
22:26:33 <lambdabot> n0T ENOUGh 4RGu/\/\ENtz +o @.
22:26:47 <int-e> @. elite nixon
22:26:48 <lambdabot> yOu KnoW, IT's 4 FUnNy T|-|InG, 3VERy ONE 0F +|-|3 84S7ARd5 7hAt 4RE OUT phoR |E94lisING /\/\4rIjUan4 i$ JeWIs|-|. wHaT +He ChrISt i5 T|-|e /\/\a+TeR WI+|-| tH3 JEwz, B0b? \/\/h4T Iz 7|-|E Ma+7Er
22:26:48 <lambdabot> WitH +hE/\/\? i SUpPo$3 i7 I5 BeC4Us3 M0St Oph tH3M ArE PzYcHI4+Ris7z.
22:26:58 <int-e> @. elite . elite nixon
22:26:58 <lambdabot> $(rU8BiN9 phlo0Rs 4nd E/\/\P7YInG 83dp4ns |-|AZ a5 /\/\U(|-| DIgNI+y 4$ +|-|3 pRe$iD3n(Y.
22:27:02 <mmorrow> sclv: he's been around for a while, but i'm not sure how he got here
22:27:09 <mmorrow> nixon is great though
22:27:15 <pumpkin> @. elite pl \x -> x y
22:27:15 <lambdabot> ($ Y)
22:27:19 <mnpn> "elite nixon" hahaha
22:27:44 <jml> I'm looking at the STM chapter in RWH (http://book.realworldhaskell.org/read/software-transactional-memory.html) -- is it possible to write a function that takes a Player and returns their balance?
22:28:03 <ivanm> has anyone managed to build pandoc-1.1 with ghc-6.10.1?
22:28:22 <bos> jml: the player function already does that
22:28:27 <sclv> ?keal
22:28:28 <lambdabot> i just got banned from math because i not have good ability to convey thoughts
22:28:28 <bos> jml: er, balance
22:28:41 <pumpkin> @. elite pl \q w e r t y -> t y p e w r i t e r
22:28:44 <lambdabot> C0NzT (FliP F1Ip iD . ((Ap . ((FLIP . (f1IP .)) .)) .) . JOin . ((Flip . ((f|IP . (F|IP .)) .)) .) . f|Ip F|Ip id . ((flIp . ((AP . (f1Ip .)) .)) .) . ph1Ip ph|iP I . ((FlIP . (ph1IP .) . ((ph1iP .)
22:28:44 <lambdabot> .)) .) . (ph|Ip .) . ((fliP .) .) . phlIp (ph|IP . (f|Ip .) . Flip (f1ip . FliP F|ip p))) OP+Imisa7Ion 5U5pEndEd, uz3 @Pl-r35ume 7O cONtInu3.
22:28:51 <mmorrow> haha
22:28:58 <int-e> ouch!
22:28:58 <mmorrow> @Pl-r35ume
22:28:59 <lambdabot> Unknown command, try @list
22:29:13 <sclv> lying bot :-P
22:29:24 <jml> bos: not when I do it.
22:29:31 * jml enclipboards
22:29:32 <bos> jml: example?
22:29:38 <mmorrow> @unpl C0NzT (FliP F1Ip iD)
22:29:38 <lambdabot> C0NzT (FliP F1Ip iD)
22:29:44 <mmorrow> @pl C0NzT (FliP F1Ip iD)
22:29:45 <lambdabot> C0NzT (FliP F1Ip iD)
22:29:47 <bos> hey everyone, please quit with the lambdabot funnies.
22:29:59 <pumpkin> :(
22:30:00 <sereven> mnpn: not sure what you're wanting to say and how you want to restrict it being said, but here's one example of one approach to using user input in haskell: http://blog.tupil.com/formlets-in-haskell/
22:30:16 <jml> bos: http://hpaste.org/13466
22:30:32 <crathman> need some help.  I translated the makeAccount example from SICP chapter 3 to Haskell as: http://hpaste.org/13465
22:30:32 <mnpn> those sayings were offensive, did nixon actually say them?
22:30:46 <mnpn> sereven: thanks
22:30:52 <ivanm> when I try to build pandoc, it says it found a duplicate definition for waitForProcess :s
22:30:52 <crathman> is there a way to get the same effect without resorting to unsafePerformIO?
22:30:55 <mmorrow> mnpn: looks like it
22:31:02 <bos> jml: you're misunderstanding how things work
22:31:03 <ivanm> is this something that was just recently added to the Process library?
22:31:26 <jml> bos: I thought so :)
22:31:31 <jml> bos: tell me how please.
22:31:35 <mnpn> anyways, I apologize for my rhetoric
22:31:51 <bos> jml: you need to run both newPlayer and balance in the STM monad
22:31:59 <mmorrow> ivanm: pandoc's linked to two libs each of which are linked to a diff process lib
22:32:17 <ivanm> mmorrow: hmmmm....... OK, didn't think of that
22:32:48 <bos> jml: e.g. atomically do { p <- newPlayer 4 5 []; readTVar (balance p) }
22:33:02 <mmorrow> try rebuilding the guilty part{y,ies} with the process you want to keep
22:33:07 <ivanm> yeah
22:33:50 <ivanm> can I use ghc-pkg to find which libs are using Process?
22:33:51 <jml> bos: so, how would you write a function that took a player, changed their balance and returned the new balance?
22:34:25 <jml> I guess it's the "taking a player as a parameter" part that I'm not quite understanding here.
22:34:25 <mmorrow> ivanm: i had this problem three ghc installs ago and i ended up just scrapping everything since half my stuff was built with one and half with the other.
22:34:28 <mmorrow> it was epic
22:34:41 <crathman> jml: sounds like the example I am asking a question about?
22:34:43 <ivanm> heh
22:35:18 <bos> jml: twiddlePlayer p newBal = writeTVar (balance p) newBal >> return newBal
22:35:30 <bos> jml: which would have type Player -> Int -> STM Int
22:35:58 <jml> bos: and thus couldn't take a thing returned by newPlayer as the first argument, IIUC
22:36:38 <bos> jml: not so.
22:36:46 <bos> jml: have you read the chapters on monads yet?
22:37:15 <jml> bos: no, I guess I probably ought to.
22:37:25 <bos> yes, that will make things much clearer.
22:41:40 <arw> gah. rwh is sold out at amazon...
22:41:55 <pumpkin> wow, even my 3k line test is using up epic amounts of memory
22:42:41 <pumpkin> I'll really make a point of staying away from large GHC input files from now on :P
22:43:50 <arw> who picks the animals for those o'reilly books btw? that bug is ugly...
22:44:19 <pumpkin> oh no, o'reilly's implying that haskell is one huge bug :(
22:44:49 <arw> not for the implication. there are beautiful bugs. but that one is simply ugly
22:45:17 <dmwit> arw: I think it came from the one-sentence description of Haskell as powerful and concise.
22:45:33 <mmorrow> maybe the adjective they were going for was "alien"
22:45:35 <dmwit> That bug is (apparently) one of the strongest in terms of strength-to-mass ratio.
22:45:57 <mmorrow> ah
22:47:53 <arw> i see. problem is, having a bug on the cover also inhibits any special names for that book.
22:48:18 <arw> i don't think "the bug book" will become as common as "the camel book" for perl :)
22:49:05 <arw> im babbling again :)
22:51:06 <ivanm> arw: it's the "rhino beetle book" ;-)
22:51:35 <ivanm> but realistically, RWH has a catchier name/acronym than other books, so I don't think it will require an alternate "popular" title
22:53:44 <ddarius> ivanm: The quality of a book is determined by how many alternative titles by which it can unambiguously referred to.  E.g. the Wizard book, the Purple book, SICP.  The more generic the names the better.
22:54:19 <ivanm> ddarius: that's your theory of book popularity, is it?
22:54:27 <sereven> "Rhino beetles like to eat, crawl around, and party during the night. They are less likely to be seen during the day." -- that must be why they picked it, as a homage to hA$KelL Ha(Kerz
22:54:44 <ivanm> but I've never heard SICP referred to as the wizard or purple book.... whilst it is purple, there's no wizards there... >_>
22:54:48 <ivanm> sereven: lol
22:54:57 <ddarius> @google The Wizard Book
22:55:00 <lambdabot> http://mitpress.mit.edu/sicp/
22:55:00 <lambdabot> Title: Welcome to the SICP Web Site
22:55:40 <sereven> of course that quote is from www.asktheexterminator.com, so it may not be the most reliable source o_O
22:55:50 <crathman> speaking of SICP...  any takers on my question of how to rid myself of unsafePerformIO?  http://hpaste.org/13465
22:55:52 <ivanm> sereven: heh
22:56:03 <ivanm> crathman: what does it have to do with SICP?
22:56:37 <crathman> it is my translation of the example in chapter 3 (the first two chapters are mostly completed)
22:56:54 <crathman> http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages
22:57:06 <ivanm> ahhh
22:57:23 <ivanm> crathman: what'ts the point of having a module with nothing exported?
22:57:24 <pumpkin> crathman: isn't the balance unpredictable?
22:57:27 <crathman> if I can get the makeAccount down, I can get on with a large part of chap. 3
22:57:32 <ivanm> just call the module Main ;-)
22:57:58 <crathman> not exporting anything in particular, exports everything.  IIUC
22:58:21 <lucca> crathman: ...why not just remove the unsafePerformIO and make makeAccount :: Int -> IO Account
22:58:28 <lucca> then you can do IO in it safely...
22:59:28 <crathman> lucca:  the compiler doesn't like me if I just remove the unsafePerformIO
22:59:44 <crathman> but that's the effect that I want
22:59:52 <Olathe> Or, you can just have Int -> Account.
22:59:57 <ddarius> getBalance () = ... wtf?
23:00:46 <Olathe> Or, you can use STM.
23:00:49 <crathman> ddarius: i'm a newb for the most part...  so I am asking for suggestions as well
23:00:50 <lucca> heh, this looks so odd
23:01:06 <lucca> crathman: I found it very helpful to actually specify type signatures for everything
23:01:13 <lucca> more for the reader than the compiler really
23:01:36 <lucca> though it could speed up compilation and is necessary for certain tricky constructions
23:01:48 * BMeph thinks "sick-up" when he sees "SICP"
23:03:59 <ivanm> grrr..... how can I find which libs are depending on Process? I appear to have a diamond dependency issue when trying to install pandoc, despite rebuilding all its deps :@
23:04:41 <ivanm> hmmm.... did 6.10.1 ship with a versio of process? I seem to have two versions installed :s
23:04:49 <crathman> ddarius: getBalance () is basically the accessor method.  I have to make it a function, or else it just grabs the balance at the time the makeAccount runs
23:05:23 <lucca> if you use TVars instead you don't need these shenanigans
23:05:48 <crathman> lucca:  will investigate... thanks
23:09:31 <pumpkin> crathman: why the () though?
23:09:51 <crathman> SML habit, I suppose
23:10:01 <lucca> probably attempting to delay execution by requiring application
23:10:38 <lucca> crathman: remember, barring unsafePerformIO, things in IO can't execute until you let them
23:11:10 <ddarius> crathman: http://hpaste.org/13465#a1
23:12:08 <ddarius> You need to remove the E. I just noticed.
23:12:46 <ddarius> crathman: Also one of the monad laws is m >>= return === m.
23:13:22 <crathman> ddarius: thanks.
23:13:44 <ddarius> return doesn't actually "do" anything.  You don't need to try to pass everything through it.
23:14:48 <ddarius> And my deposit is wrong as it doesn't return the balance, but this can be easily either by using modifyMVar or using an extra readMVar.
23:15:01 <ddarius> s/easily/easily fixed/
23:16:11 <ddarius> Heck, and I can't believe I left \err -> print err in there.
23:16:49 <crathman> ddarius:  my bad code is rubbing off on you.  :-)
23:17:31 <ddarius> http://hpaste.org/13465#a2  A bit better, still untested.
23:18:11 * ddarius would probably write the catch as (accountWithdraw acc 60 >>= print) `catch` print to look more like the traditional control structure.
23:19:03 <crathman> ddarius:  can't get it to compile.  but you've given my the direction I need to take - thanks.
23:20:18 <int-e> ddarius: is it intentional that deposit can return a smaller number than the deposited funds?
23:20:54 <int-e> (assuming that there's a race with another thread withdrawing funds of course)
23:20:58 <ddarius> int-e: I didn't provide the requirements.
23:21:19 <ddarius> Oh, you mean the race condition between the readMVar and the modify.
23:21:32 <ddarius> Yeah, modifyMVar would be better, I was just lazy.
23:23:09 <ddarius> deposit amount = modifyMVar (return . join (,) . (amount+))
23:24:58 <ddarius> Or to be really sick, deposit = modifyMVar . ((return . join (,)) .) . (+)
23:25:05 <ddarius> Let's see if I got that right.
23:25:14 <crathman> to correlate with SICP, the makeAccount at the first of the chapter is not threadsafe
23:25:17 <ddarius> @pl deposit amount = modifyMVar (return . join (,) . (amount+))
23:25:18 <lambdabot> deposit = modifyMVar . ((return . join (,)) .) . (+)
23:25:36 <dmwit> A+
23:25:58 <ddarius> crathman: If you don't "care" about thread safety, then you should be using IORefs not MVars.  They also have a simpler interface.
23:26:21 <crathman> ddarius:  so many choices  :-)
23:26:35 <crathman> the thread safety will come in handy later in the chapter
23:26:36 <ddarius> crathman: Wait 'til you get to arrays.
23:27:45 <ddarius> See, for example, page 4 of this slide set: http://www.galois.com/~dons/slides/08-07-stewart.pdf
23:27:48 <pumpkin> I really like the (f .) . (. x) pattern
23:28:05 <int-e> withdraw should be a modifyMVar, too, for exception safety.  modifyMVar balance (\balance -> when (balance < amount) (ioError . userError $ "...") >> return (join (,) (balance - amount))
23:28:29 <pumpkin> > let mapWords = (unwords .) . (. words) in mapWords (map $ map succ) "hello this is a test"
23:28:30 <lambdabot>   "ifmmp uijt jt b uftu"
23:28:30 <int-e> (modifyMVar puts the original value back if an exception happens)
23:29:08 <ddarius> Anyway, I need to wake up in five hours, so I should probably go to sleep.
23:29:11 * pumpkin wonders if that's a hylomorphism
23:29:19 <pumpkin> or am I just looking for fancy words where none belong
23:39:54 <pumpkin> it feels like the unfold + fold they explain a hylomorphism as being, but I dunno :o
23:40:32 <dmwit> :t (unwords .) . (. words)
23:40:34 <lambdabot> ([String] -> [String]) -> String -> String
23:40:59 <dmwit> > ((unwords .) . (. words)) (map reverse) "hey there guy"
23:41:01 <lambdabot>   "yeh ereht yug"
23:41:23 <dmwit> :t (unwords .) . (. words) . map
23:41:25 <lambdabot> (String -> String) -> String -> String
23:41:30 <dmwit> seems more useful
23:41:37 <pumpkin> true
23:41:50 <pumpkin> the name kinds of implies that too
23:41:55 <dmwit> right
23:42:06 <pumpkin> but in general
23:42:26 <pumpkin> say there existed a function invert :: (a -> b) -> (b -> a)
23:42:33 <pumpkin> (invert f .) . (. f)
23:42:44 <pumpkin> does that have a name?
23:44:22 <dmwit> I've often wanted that kind of thing.
23:44:26 <pumpkin> (not that unwords is a true inverse of words)
23:44:32 <dmwit> A class "Isomorphism" or something.
23:44:37 <pumpkin> ah
23:44:59 <pumpkin> it would be cool if there were some way to make a typeclass InvertibleFunction that allowed you to pull the inverse of a function (obviously that you specify)
23:45:08 <dmwit> right
23:45:10 <dmwit> exactly
23:45:43 <dmwit> Call it Isomorphism or InvertibleFunction, I don't care. ;-)
23:45:47 <pumpkin> :)
23:45:57 <dmwit> Actually, I don't want that very often.
23:46:02 <dmwit> What I *really* want
23:46:08 <dmwit> is something like:
23:46:31 <dmwit> instance Foo Bar using (fooFromBar, barFromFoo)
23:46:37 <dmwit> err
23:46:49 <dmwit> instance Foo Baz where ...
23:47:00 <dmwit> instance Foo Bar using (barFromBaz, bazFromBar)
23:47:07 <dmwit> Something like that.
23:47:17 <dmwit> For example, instance Num Char using (ord, chr)
23:47:32 <pumpkin> yeah
23:47:53 <pumpkin> you mean to perform conversion automatically? it could search for the usings? or what?
23:48:35 <pumpkin> oh I guess I see what you mean
23:48:40 <dmwit> I suppose it could search for functions to stick in the "using" clause, but really, I don't mind specifying the conversion myself.
23:48:56 <dmwit> The really big deal is that I wouldn't have to wrap all inputs and outputs.
23:49:05 <dmwit> If you write a Num instance for Char, you end up doing things like
23:49:13 <dmwit> a + b = chr (ord a + ord b)
23:49:16 <pumpkin> yeah
23:50:03 <sjanssen> dmwit: it's like newtype deriving on steroids
23:50:08 <dmwit> right
23:50:17 <dmwit> And possibly not always correct. =)
23:50:46 <dmwit> I haven't really thought about it to the point of doing any rigorous analysis of things that might go wrong...
23:51:23 <sjanssen> it gets more complicated with nested types
23:51:36 <sjanssen> eg. what if a method has something involving [a]
23:51:51 <dmwit> mmmm, yeah
23:52:02 <dmwit> What does newtype deriving do about that?
23:52:02 <NameAlreadyInUse> i know Parsec has a "optional" combinator, but is there a "optionalMany" or something?
23:52:22 <dmwit> many is already optional
23:52:35 <dmwit> :t Text.ParserCombinators.Parsec.many
23:52:36 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
23:53:01 <sjanssen> dmwit: newtype deriving essentially just unsafeCoerce's everything
23:53:10 <dmwit> oh
23:53:26 <sjanssen> which is okay, since Haskell says that newtypes should have the same representation as the underlying type
23:53:30 <dmwit> So it works by accident. =)
23:53:31 <dmwit> yeah
23:53:49 <NameAlreadyInUse> dmwit: but many has a different type signature
23:54:00 <ivanm> what does the haskell98 package provide? all those plain old List, etc. modules before they started splitting it up into Data.List, etc.?
23:54:04 <sjanssen> this is somewhat controversial, some say that newtype deriving should only be allowed in cases where valid source could actually be generated
23:54:13 <dmwit> NameAlreadyInUse: I don't follow.  What else would you expect?
23:54:20 <sjanssen> ivanm: haskell98 provides the modules in the Haskell '98 spec
23:54:24 <dmwit> NameAlreadyInUse: Maybe I should ask what you want optionalMany to do.
23:54:38 <sjanssen> ivanm: so yes, a subset of Data.List, Data.Array, etc.
23:54:42 <ivanm> sjanssen: seeing as how I myself don't really know the Haskell '98 spec... ;-)
23:54:44 <ivanm> *nod*
23:55:01 <sjanssen> ivanm: it's all online
23:55:07 <sjanssen> @google haskell '98 report
23:55:09 <lambdabot> http://www.haskell.org/onlinereport/
23:55:09 <lambdabot> Title: The Haskell 98 Language Report
23:55:16 <dmwit> ?where h98
23:55:16 <lambdabot> http://haskell.org/onlinereport/
23:55:23 <NameAlreadyInUse> optional is :: GenParser tok st a -> GenParser tok st (), is there a many that works like that? or can i combine optional and skipMany somehow?
23:55:46 <dmwit> Oh, you want to just throw away the parsed bits?
23:55:52 <NameAlreadyInUse> yeah
23:56:03 <dmwit> :t \p -> Text.ParserCombinators.Parsec.many p >> return ()
23:56:05 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
23:56:18 <dmwit> There might be a many_, too, let's see.
23:56:27 <dmwit> :t Text.ParserCombinators.Parsec.many_
23:56:28 <lambdabot>     Not in scope: `Text.ParserCombinators.Parsec.many_'
23:56:34 <dmwit> nope
23:56:47 <ivanm> so since I have issues where the ghc-bundled haskell98 is using an older version of process than everything else, would it be safe to just install the version from hackage? despite it being the same version, will it interfere with the bundled version in any way?
23:57:18 <dmwit> ?hoogle GenParser tok st a -> GenParser tok st [a]
23:57:18 <lambdabot> Did you mean: GenParser tok (ST tok tok) a -> GenParser tok (ST tok tok) [a] /count=20
23:57:18 <lambdabot> No results found
23:58:35 <Anon422> hello
