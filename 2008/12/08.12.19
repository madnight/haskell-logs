00:02:45 <Axman6> how do i force evaluation of a list? (trying to compare FFI vs. non FFI versions, and the non FFI one is being lazy when i take the last element)
00:03:10 <quicksilver> rnf
00:03:19 <Axman6> ah yes
00:03:19 <quicksilver> from Control.Parallel.Strategies.
00:03:22 <quicksilver> or foldr seq ()
00:04:21 <solrize> axman6, it may be best to use arrays for that example
00:04:22 <Axman6> ah cheers :)
00:04:33 <solrize> or uvector as dons suggested
00:05:13 <Axman6> meh, i'm trying to make an 'obvious' version (according to what i think is obvious). so lists it is
00:06:23 <Cale> Axman6: Do you have an estimate of how long the code should take to run for a given input size?
00:06:51 <Axman6> not really, just playing really
00:06:56 <solrize> uvector may be unobvious but i think regular arrays are pretty obvious
00:07:06 <Axman6> i'm using a list of randoms as the input
00:07:58 <mpeter> does anybody else get flooded with connections from the Department of Defense
00:08:12 <Cale> For an input of length 2^12, my uvector one takes just under 6.4s.
00:08:15 <pumpkin_> mpeter: not me
00:08:20 <Cale> I'm not sure what that means :)
00:08:22 <Axman6> http://hpaste.org/13180#a1 is what i have now
00:08:49 <Axman6> > 2^12
00:08:50 <lambdabot>   4096
00:08:53 <pumpkin_> I kinda want to write the NTT in haskell
00:09:11 <pumpkin_> anyone know of an implementation? it's pretty similar to the DFT
00:09:11 <mpeter> is somebody going to write an OS in haskell
00:09:14 <mpeter> sans exploits :D
00:09:35 <solrize> http://x86vmm.blogspot.com/2005/10/house-haskell-os.html
00:10:06 <wli> Lots of interesting new language options have cropped up.
00:10:14 <solrize> http://lambda-the-ultimate.org/node/299
00:10:42 <Axman6> mpeter: i believe there's at least two
00:11:27 <mpeter> i hate this century
00:12:15 <pumpkin_> wow
00:12:44 <wli> FlexibleInstances, FlexibleContexts, NoMonoPatBinds, RelaxedPolyRec, ConstrainedClassMethods, ImpredicativeTypes, etc.
00:13:25 <wli> I threw in PatternGuards, GADTs, ExtendedDefaultRules, ScopedTypeVariables, and GeneralizedNewtypeDeriving while I was at it.
00:13:33 <pragma_> Wow
00:13:52 <pragma_> That's a lot of function names.  Do they actually do anything useful?
00:14:05 <pumpkin_> they're GHC options
00:14:19 * pragma_ baffled.
00:14:56 <Axman6> Cale: interestingly, my naieve haskell version is only a second slower than the C one, with 10000 input
00:15:35 <Cale> Axman6: How long does the C version take?
00:15:47 <Axman6>  6.366506s
00:15:50 <pumpkin_> how does it compare to fftw?
00:15:53 <Cale> okay
00:15:59 <Axman6> and 7.367503s for the haskell
00:16:33 <Axman6> which is... well surprising
00:16:39 <Axman6> seeing as it
00:16:47 <Axman6> 's not exactly optimised haskell
00:16:52 <pragma_> Ah, GHC is the compiler?
00:17:10 <pumpkin_> Axman6: is the c optimized?
00:17:17 <Axman6> not really
00:17:25 <Axman6> but i think it should be pretty fast
00:17:46 <pumpkin_> it looks n^2
00:17:49 <Axman6> there's one 'optimisation' i should put in the C though...
00:17:54 <Axman6> it is
00:17:58 <pumpkin_> ah
00:18:00 <Axman6> that's not the point though :P
00:18:04 <pumpkin_> yeah :P
00:19:17 <Axman6> now i think of it, there's a lot of extra crap in the haskell code that doesn't need to be there (like the explicit passing of the length of the list, since i just return when i get to the end of the list)
00:19:22 <Cale> oh, hang on...
00:19:34 * wli wonders what this Math.* hierarchy is.
00:19:36 <Cale> -ddump-rules is supposed to print the rules which fired, yeah?
00:20:52 <Cale> Shouldn't some rules be firing? :)
00:24:34 <Cale> dons: Should using Data.Array.Vector generally cause rules to fire?
00:26:37 <Cale> oh, n/m, they are firing. -ddump-simpl-stats shows the
00:26:40 <Cale> m*
00:28:23 <solrize> axman6 what happens if you code it the obvious way with a fold?
00:28:49 <Axman6> solrize: want to show me the obvious fold?
00:29:14 <solrize> sec
00:31:04 <Axman6> http://hpaste.org/13180#a2 is the slightly more obvious version
00:31:34 <solrize> ok
00:31:47 <Cale> oh
00:31:55 <Cale> the uvector version is faster on my machine
00:32:07 <Cale> You just have a much faster machine than I do :)
00:32:16 <Cale> http://hpaste.org/13182
00:32:30 <Cale> er, no
00:32:57 <Axman6> 2.4GHz Core 2 Duo
00:32:58 * Cale recompiles and checks :)
00:33:39 <Cale> okay, no :)
00:33:59 <Cale> The plain version is almost 4 times faster
00:34:07 <Cale> (I forgot about the size difference)
00:34:10 <Axman6> hmm, the newer version seems to be slightly slower than the first one i did :\
00:34:21 <Axman6> size difference?
00:34:33 <Cale> The sizes at which we were testing.
00:34:38 <Axman6> ah
00:34:44 <Axman6> yeah i was using 10^5
00:34:45 <Cale> I changed it to 10000, but hadn't run the test again
00:35:24 <Cale> I can imagine why this uvector implementation is slow... possibly some of this should be done with lists.
00:37:15 <Axman6> heh, ghc-core shows a lot of rules being fired
00:37:41 <Axman6> why are case statements used all the time i core anyway?
00:37:53 <Cale> Because they're how evaluation happens.
00:38:11 <Cale> At some level, the only reason that anything ever gets evaluated is because a case expression inspects it.
00:38:23 <Axman6> fair enough
00:38:26 <Cale> All pattern matching turns into case
00:38:32 <Axman6> yeah
00:38:34 <Cale> and then things tend to get inlines
00:38:36 <Cale> inlined*
00:39:08 <Axman6> what does KnownBranch mean?
00:39:39 <Cale> I think it means that it knows which branch of a case will be taken
00:42:08 <solrize> http://hpaste.org/13180#a3
00:42:19 <solrize> probably some errors in that, i didnt test it
00:42:51 <solrize> and i'm presuming the compiler can simplify the insides of the cosine expression and do some cse
00:43:32 <Cale> k is not in scope
00:43:48 <pumpkin_> PI :o
00:43:52 <Cale> oh, perhaps that was supposed to be a function
00:43:52 <solrize> whoops
00:44:01 <solrize> whered it go
00:44:34 <solrize> oh silly me, the where clause is for the outer function
00:44:37 <solrize> no
00:44:39 <Axman6> yeah
00:44:43 <Axman6> ni?
00:44:45 <Axman6> o*
00:45:13 <solrize> gotta put (fI k) instead of fk there
00:45:18 <solrize> and remove fk from the where
00:45:56 <Cale> This seems a good deal slower for me
00:46:13 <solrize> yeah, i'd expect it slower, it's just a more obvious mapping
00:46:14 <Cale> (it still hasn't finished...)
00:46:31 <solrize> hmm is it looping?
00:46:36 <solrize> eating memory?
00:46:39 <Cale> No, it's printing results.
00:46:49 <Cale> It just finished
00:46:53 <Cale> 2m28s
00:47:59 <solrize> hahahaha
00:48:04 <Cale> I bet it's all the fromIntegrals
00:48:19 <solrize> i was hoping the compiler would do something sane with them
00:48:29 <solrize> it should be possible to get rid of most of that by rearranging the expression
00:48:30 <pumpkin_> Cale: is that with -O2?
00:49:02 <Cale> mhm
00:49:21 <Cale> I'm going to move a few of the fromIntegrals, so they're done earlier.
00:49:26 <solrize> ok
00:50:01 <solrize> you could precompute [0.0,1.0,... np]
00:50:02 <pumpkin_> shouldn't even need a fromIntegral on n
00:50:11 <Axman6> ok, the C is 76.83% faster apparently
00:50:18 <solrize> faster than which?
00:50:23 <Axman6> my haskell one
00:50:44 <Cale> actually, I can just remove all the fromIntegrals
00:50:50 <pumpkin_> have you tried compiling with -Over9000?
00:51:20 <solrize> can you have nested "where"'s like that?!  i thought you could only have them at the top level
00:51:21 <Cale> oh, also, it should be a scanl1
00:51:43 <solrize> hmm
00:51:45 <pumpkin_> ooh, that's pretty
00:51:52 <solrize> paste?
00:51:54 <Axman6> solrize: they can be nested yes
00:52:00 <Axman6> just need to be indented really
00:52:10 <solrize> ic thanks
00:52:17 <pumpkin_> also, can't some things be more strict?
00:52:20 <Axman6> ok, i'll bbiab (i hope) need to try and get our wireless connected back to the modem
00:52:25 <pumpkin_> or wouldn't that make much difference here?
00:53:37 <Cale> oh, hmm, it's not simply a scanl1 (+), due to the dependence on n
00:54:37 <pumpkin_> could be a nested list comprehension though
00:54:47 <pumpkin_> not sure if that's any better though
00:55:57 <Axman6> is there any reason the C and haskell versions results should differ?
00:56:41 <Cale> Axman6: In yours, you're using different constants...
00:56:48 <Axman6> i am
00:56:49 <Axman6> ?
00:56:52 <pumpkin_> did you try it with those fancy deforested lists?
00:57:07 <Cale> Axman6: n' = fromIntegral n + 0.25
00:57:24 <Axman6> which is (n+0.25) no?
00:57:44 <Cale> In the C version, it has n + 0.5
00:57:50 <Axman6> no it doesn't
00:57:57 <Axman6> sum += in[n] * cos((PI/points) * (n+0.25) * (k + 0.5));
00:58:07 <Cale> what?
00:58:10 <pumpkin_> hmm
00:58:11 <Cale> look at your paste
00:58:20 <pumpkin_> the mathematical statement of dctiv also has 0.5
00:59:03 <Axman6> Cale: i am... looks fine to me. one's +0.5 the other's +0.25
00:59:28 <pumpkin_> they all have 0.5 on the hpaste :P
00:59:57 <pumpkin_> (the c versions, your haskell one has always had 0.25)
01:00:01 <Cale> I don't know where the 0.25 is coming from
01:00:03 <Axman6> huh, wonder how that happened
01:01:03 <Axman6> well both my C and haskell were using the same values
01:01:06 <Cale> Note that with floating point, if you associate the expressions differently, you'll get different results as well, so you need to be careful about that.
01:01:49 <Axman6> is acc + (d * cos (piOn * n' * k')) ok?
01:02:39 <Cale> I think so...
01:03:23 <Cale> I'm trying a stream-fusion version of solrize's.
01:04:20 <Axman6> hmm, i keep getting quite different results
01:05:17 <jeffwheeler> Heh, graphs _are_ a beautiful solution to some problems.
01:05:25 <pumpkin_> jeffwheeler: yup :)
01:05:30 <pumpkin_> what made you remark that?
01:05:52 <jeffwheeler> I just solved this old contest problem that took abound a hundred lines of Java and ran extremely slowly in about five lines of Haskell, which ran instantly. :P
01:05:57 <pumpkin_> lol
01:06:06 <Cale> Mm... not any faster that way
01:06:15 <pumpkin_> :t span
01:06:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:06:29 <Cale> (with the list stream fusion)
01:06:45 <jeffwheeler> pumpkin_: http://hpaste.org/13184
01:06:59 <pumpkin_> have you guys tried profiling to see where the time is being spent?
01:07:05 <jeffwheeler> Cale: it is if the alternative is messily using maps and searching everything
01:07:16 <Cale> jeffwheeler: I wasn't referring to your case
01:07:23 <jeffwheeler> Cale: ah, sorry :)
01:07:26 <Cale> jeffwheeler: I was referring to the benchmark I just did :)
01:07:40 <jeffwheeler> Cale: my bad; wasn't paying attention
01:07:58 <jeffwheeler> pumpkin_: by the way, the problem is #9 here: http://www.cs.trinity.edu/~mlewis/HSProgComp05/Problems.pdf
01:09:04 <jeffwheeler> Now I just have to implement that graphing stuff in Java, so I can use it at the contest this year.
01:09:09 <pumpkin_> ah, that seems nice :)
01:20:40 * Axman6 wonders if deleting all the non whitespace chars after all the _'s in core would make it any clearer
01:23:49 <slangan> is there a bultin for asking if an element is a member of a list?
01:23:58 <Axman6> slangan: elem
01:24:03 <slangan> or mroe geenrally of any type of collection?
01:24:40 <Axman6> dons: when looking at the assmebly output in ghc-core, how do you tell where a specific function's ASM is? there seem to a lot of bits with the name in them
01:27:43 <Axman6> slangan: depends on the collection i guess. there may be a class for it, but i can't think of one
01:28:04 <Axman6> > 2^16
01:28:05 <lambdabot>   65536
01:28:15 <Axman6> > 2^14
01:28:17 <lambdabot>   16384
01:28:22 <pumpkin_> ORLY
01:34:12 <mapreduce> dons: I like the Jon Harrop google png.
01:36:59 <the_unmaker> how important is it to have 6.10?
01:37:04 <the_unmaker> I am new to programming
01:37:09 <the_unmaker> and haskell caught ym eye
01:37:14 <the_unmaker> my eye
01:37:22 <pumpkin_> the_unmaker: not that important, but you might as well if you're just starting
01:38:41 <maltem_> slangan: there's a generic version of elem in Data.Foldable
01:41:19 <Axman6> the_unmaker: if you have 6.8.2 or higher, you should be ok to do pretty much everything
01:42:15 <Axman6> :t zipWith id
01:42:16 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
01:42:54 <pumpkin_> that's an interesting function :o
01:43:38 <Axman6> yeah, i was thinking about it as a way to do that dctiv thing :0
01:43:39 <Axman6> :)*
01:44:55 <pumpkin_> you determined to squeeze every inch out of it?
01:45:02 <pumpkin_> wtf? inch?
01:45:05 <pumpkin_> not sure where that came from
01:45:09 <pumpkin_> I'm gonna blame it on the concussion :P
01:45:18 <Axman6> just trying to see how fast i can get it :0
01:45:24 <Axman6> :) rawr
01:45:26 <the_unmaker> ok
01:45:46 <blackh1> the_unmaker: ghc 6.10 is a major release and it's very new, so a few of the hackage packages don't build on it yet.  6.8.3 is more convenient from that point of view: Everything will work.
01:45:47 * Axman6 is starting to use par now >_>
01:46:07 <pumpkin_> Axman6: that's not fair to the c version!
01:46:14 <Axman6> sure it is!
01:46:22 <Axman6> if C has easy parallelism, then i'd use it
01:46:38 <pumpkin_> have you tried making things stricter in your current version?
01:46:41 <pumpkin_> before moving to par?
01:46:59 <pumpkin_> not sure exactly what, but it might help :o
01:47:06 <opqdonut> the right question is: have you profiled it
01:47:12 <pumpkin_> I asked that one earlier :P
01:47:15 <opqdonut> just randomly making stuff stricter won't help
01:47:17 <pumpkin_> but no one answered it
01:47:29 <the_unmaker> is c still the best to learn?
01:47:42 <pumpkin_> the_unmaker: there's something wrong with that question :)
01:47:43 <the_unmaker> I have a k+r book but it scared me a bit first time i tried.
01:47:47 <Axman6> has C ever been the best to learn?
01:47:55 <quicksilver> On the contrary I would not recommend 6.10 to someone new to haskell.
01:47:55 <Axman6> i didn't think C could learn at all :)
01:48:04 <Axman6> quicksilver: really?
01:48:04 <JoshTriplett> the_unmaker: I think you found the wrong channel for that question. :)
01:48:08 <quicksilver> I would recommend 6.8 because it comes with a better set of libraries.
01:48:16 <quicksilver> 6.10 is not ready until the haskell platform is complete.
01:48:25 <pumpkin_> ack, I started with 6.10, I'll blame my apparent stupidity on that
01:48:29 <opqdonut> knowing C is very useful
01:48:31 <blackh1> the_unmaker: Learn Haskell first, but learn another language too. Otherwise you won't fully appreciate how good Haskell is.
01:48:41 <Axman6> opqdonut: i haven't, but the author blog post i took this from did :P
01:48:48 <opqdonut> Axman6: ah, link?
01:48:56 <Axman6> http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
01:49:35 <JoshTriplett> I have a program which has some kind of space leak.  As it runs, its heap usage slowly grows, until eventually it dies with a "Heap exhausted" message when it reaches the heap limit I set for it.  I've tried heap profiling with -hd, and it tells me that most of the memory consists of cons cells.  How can I find out what type the list holds that uses all the space?
01:49:40 <jeffz`> the_unmaker: wb
01:50:22 <opqdonut> Axman6: you need proper profiling output :)
01:50:25 <Axman6> blackh1: heh, agreed
01:50:28 <opqdonut> i'd try unboxing
01:51:04 <the_unmaker> wb
01:51:05 <the_unmaker> ?
01:51:11 <jeffz`> the_unmaker: welcome back
01:51:15 <quicksilver> JoshTriplett: I would recommend experimenting with all the profiling options
01:51:20 <the_unmaker> how about common lisp
01:51:29 <jeffz`> common lisp is off-topic here
01:51:29 <quicksilver> JoshTriplett: -hc and -hr are most likely to help you find out where the cons cells are being held.
01:51:32 <JoshTriplett> quicksilver: Trust me, I have. :)
01:51:45 <earthy> joshtriplett: you can use -hy to show what type uses the memory, and then -hr and -hc to see where the memory was used
01:51:48 <opqdonut> common lisp is a PITA
01:51:49 <Axman6> opqdonut: this is the code i have, if you're interested: http://hpaste.org/13180#a2
01:51:52 <opqdonut> big, old, baroque
01:51:53 <quicksilver> -hc should tell you where the cell was being created
01:51:58 <opqdonut> learning scheme is time better spent
01:51:59 <quicksilver> and -hr should tell you where it's being retained
01:52:01 <quicksilver> hopefully :)
01:52:13 <earthy> -hy obviously only works if you diligently make appropriate types for your stuff ;)
01:52:15 <JoshTriplett> quicksilver: Yeah, it should, shouldn't it? :)
01:52:26 <quicksilver> try -L50 to get a longer description of your cost centres
01:52:32 <solrize> the_unmaker, you're just getting started with programming?  1) stay away from C, it should be outlawed; 2) common lisp is something of a dinosaur and its user community is very obnoxious; 3) i'm still reserving judgement about the suitability of haskell for beginners so my other suggestion would be python
01:53:07 <Axman6> i think haskell is an excellent beginnner's language
01:53:07 <earthy> solrize: that's a bit harsh
01:53:16 <blackh1> the_unmaker: Functional languages like Haskell are quite different to the more "usual" languages. I would recommend either Python or Java if you want to learn a more usual language but you want to avoid the painfulness of C.
01:53:21 <opqdonut> python, eugh
01:53:24 <earthy> plus, from previous experience, it is *hard* for people to learn python
01:53:26 <opqdonut> horrible first language
01:53:28 <pumpkin_> ruby's pretty nice
01:53:30 <earthy> harder than e.g. assembly
01:53:30 <opqdonut> too dynamic, too inconsistent
01:53:31 <solrize> java is bloated bureaucracy
01:53:39 <baaba> javascript go :P
01:53:44 <solrize> scheme ?
01:53:45 <opqdonut> C is the least of all evils
01:53:47 <opqdonut> IMO
01:53:49 <baaba> no it's not
01:53:54 <earthy> opqdonut: almost... almost.
01:53:55 <JoshTriplett> I don't entirely trust the heap profile quite yet, because the peak memory usage it shows doesn't match the peak memory usage shown by -S or the actual limit I set on my heap size.
01:53:59 <blackh1> Personally I think Haskell would be a perfectly fine language to learn as a first language.
01:54:00 <JoshTriplett> quicksilver: ^
01:54:01 <solrize> if you want a lisp-like language try scheme, look at http://mitpress.mit.edu/sicp
01:54:01 <opqdonut> one should probably quickly try a scripting language and then learn C IMO
01:54:02 <earthy> I'd suggest Logo :)
01:54:03 <Axman6> earthy: my experience fomr using it in our physics course was that non computery people picked it up pretty easily
01:54:18 <earthy> Axman6: physics, that explains it already
01:54:19 <quicksilver> JoshTriplett: you have to add all the lines up on the heap grah
01:54:23 <baaba> no, why the hell would anyone need to learn C?
01:54:25 <JoshTriplett> The heap profile shows a peak memory usage under 2500k, but I set a heap limit of 48m and it gets exhausted.
01:54:25 <earthy> people *with* knowledge of math
01:54:26 <quicksilver> JoshTriplett: they're overlayed, not cumulative.
01:54:32 <Axman6> heh
01:54:42 <the_unmaker> isn't fbsd done in c
01:54:43 <JoshTriplett> quicksilver: Wha?  They look stacked.
01:54:43 <Axman6> i guess they did lay stuff out for us pretty easily
01:54:52 <earthy> I taught 12 to 14 year olds. ;)
01:54:54 <quicksilver> JoshTriplett: they're sorted so the highest ones are 'behind'
01:54:57 <the_unmaker> haskell seems pretty cool
01:54:59 <quicksilver> JoshTriplett: but they're not stacked.
01:55:02 <opqdonut> Axman6: so how much slower is your version?
01:55:03 <earthy> they barely knwe the concept of a function :)
01:55:05 <JoshTriplett> quicksilver: Aieee.  That explains a *lot*.
01:55:09 <Axman6> opqdonut: about 20%
01:55:15 <Axman6> which could be worse i guess
01:55:18 <opqdonut> Axman6: and what about solrize's
01:55:21 <quicksilver> JoshTriplett: also bear in mind that actual memory usage = 3 x heap size
01:55:23 <jeffz`> the_unmaker: you should care less about what is best and just stick with one long enough to learn it.
01:55:26 <quicksilver> JoshTriplett: (copying GC)
01:55:28 <pumpkin_> the_unmaker: if you go by number of cool projects written in language X as a measure of quality, you'll get some awesome languages rather underrated, and some very mediocre languages overrated
01:55:36 <Axman6> haven't tried it
01:55:37 <solrize> the_unmaker yes, older os's and applications are written in C, and that is why you hear of computer viruses turning people's pc's into botnets and new security bugs in browsers every day of the week
01:55:43 <JoshTriplett> quicksilver: Yeah, I realize that.  Though I think with the options I used it only uses 2x heap size.
01:55:52 <opqdonut> Axman6: i'd say try unboxed arrays
01:55:53 <blackh1> the_unmaker: I think it works like this: Most languages are not very different from each other, so experienced programmers are not used to making any actual effort any more to learn a new language.  Haskell comes along, and it's an effort.  Therefore the conclusion is made that Haskell is hard.  But Haskell is not hard at all - it's just different.
01:55:58 <opqdonut> Axman6: then it'll be a fair fight
01:56:07 <sjanssen> @seen conal
01:56:07 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 11h 55m 10s ago.
01:56:10 * Axman6 doesn't know what they are
01:56:11 <solrize> opqdonut my version was hella slow, i think cale may have tuned it a little but i coded it for obviousness not speed
01:56:21 <sjanssen> conal: wondering how to mark up code in comments to your blog
01:56:22 <opqdonut> ah, okay
01:56:41 <sjanssen> ah, <pre> works
01:56:54 <Axman6> opqdonut: i was trying to write an obvious haskell version that roughly followed  the C version
01:57:05 <solrize> the_unmaker which OS do you run?
01:57:12 <opqdonut> well, unboxed arrays are the obvious counterpart of C arrays
01:57:34 <quicksilver> JoshTriplett: it seems very likely you're accidentally holding onto the head of a list
01:57:38 <quicksilver> JoshTriplett: but I guess you guessed that too :)
01:57:41 <opqdonut> and frankly, I don't see the point in following the C version if another solution would be clearer and faster
01:58:05 <JoshTriplett> quicksilver: Quite possibly, yes. :)
01:58:09 <pumpkin_> it seems relatively simple to express as a comprehension over both n and k
01:58:10 <slangan> im writing a parser(i started in lisp but it just seemed haskell is the way to go for parsers).
01:58:23 <the_unmaker> freebsd 7.0r6
01:58:30 <slangan> anyway, i have main like case x of blah -> print blah main
01:58:59 <slangan> http://hpaste.org/13185
01:59:09 <slangan> ^^ can someone tell me how to call main again?
01:59:19 <JoshTriplett> slangan: It gets called automatically...
01:59:23 <opqdonut> slangan: add a do
01:59:35 <quicksilver> slangan: you have it almost fine :) But you want do print blah ; main
01:59:37 <solrize> the_unmaker well if you're just getting started, maybe i'm old fashioned but i don't know of a better book than SICP
01:59:39 <Axman6> slangan: do print x ; main
01:59:41 <quicksilver> slangan: where ; is a newline.
01:59:54 <JoshTriplett> slangan: Ah, oops. :)
02:00:03 <quicksilver> slangan: or you can just go for "print blah >> main"
02:00:07 <quicksilver> (no do, no newline)
02:00:07 <JoshTriplett> quicksilver: In any case, your explanation that the various types don't stack in the graph really helps my understanding of it.
02:00:26 <quicksilver> JoshTriplett: ah good :)
02:00:26 <JoshTriplett> quicksilver: That means that lists, while taking up the most memory, don't necessarily represent the primary problem.
02:00:33 <the_unmaker> sicp .. ok
02:00:50 <JoshTriplett> quicksilver: Thank you!
02:00:54 <quicksilver> JoshTriplett: actually I've sometimes wished a stacked view was available as an option :)
02:01:02 <JoshTriplett> quicksilver: Yeah, same, now. :)
02:01:05 <quicksilver> presumably not particularly hard to add.
02:01:42 <maltem_> slangan: as for the "why", you have to put 'print x' and 'main' into some relationship, namely, that you want first 'print x' to be executed, and then 'main'. Both suggestions (do, >>) express this
02:02:16 <JoshTriplett> quicksilver: The problem comes in because I *expect* heap usage to grow over time to some extent, because the algorithm I've implemented generates a long list of data.  I just don't want it to grow more than necessary to contain that list.  So yeah, I know that I just have laziness somewhere that I don't want it; I just don't know where. :)
02:02:17 <solrize> the_unmaker of course just because i don't KNOW of a better book doesn't mean that there ISN'T one ;)
02:02:42 <solrize> for python, try http://diveintopython.org .    for haskell, http://learnyouahaskell.org and http://book.realworldhaskell.org
02:03:01 <solrize> sorry, that's http://learnyouahaskell.com not .org
02:03:32 <solrize> hmm that might be a bit difficult though
02:03:37 <maltem_> slangan: also, you can save yourself from some typing by using 'map show' and 'and' in your pasted code
02:04:14 <pumpkin_> :t and
02:04:15 <lambdabot> [Bool] -> Bool
02:04:19 <pumpkin_> :t all
02:04:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:04:25 <pumpkin_> @src and
02:04:26 <lambdabot> and   =  foldr (&&) True
02:05:00 <BeelsebobWork> :hoogle oneOf
02:05:05 <BeelsebobWork> @hoogle oneOf
02:05:05 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
02:05:05 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
02:05:05 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
02:05:18 <BeelsebobWork> @hoogle (a -> Bool) -> [a] -> Bool
02:05:19 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
02:05:19 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
02:05:19 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
02:05:20 <Axman6> :t foldr ((&&).?f) True
02:05:21 <lambdabot> Not in scope: `.?'
02:05:22 <BeelsebobWork> yep
02:05:26 <Axman6> :t foldr ((&&). ?f) True
02:05:27 <lambdabot> forall a. (?f::a -> Bool) => [a] -> Bool
02:05:33 <pumpkin_> Axman6: what's that question mark?
02:05:37 <Axman6> @src and
02:05:38 <lambdabot> and   =  foldr (&&) True
02:05:44 <Axman6> @src all
02:05:45 <lambdabot> all p =  and . map p
02:05:54 <BeelsebobWork> pumpkin_: it means "please tell me the type of f too"
02:05:56 <Axman6> pumpkin_: gives you the type of f
02:06:20 <pumpkin_> hmm
02:07:57 <Axman6> @check \xs p -> all p xs == foldr ((&&). p) True xs
02:07:59 <lambdabot>       Overlapping instances for Show (a -> Bool)
02:07:59 <lambdabot>        arising from a use of...
02:08:25 <Axman6> @check \xs p -> (all p xs) == (foldr ((&&). p) True xs)
02:08:27 <lambdabot>       Overlapping instances for Show (a -> Bool)
02:08:27 <lambdabot>        arising from a use of...
02:08:31 <Axman6> :\
02:09:28 <Axman6> :t  \xs p -> (all p xs) == (foldr ((&&). p) True xs)
02:09:29 <lambdabot> forall a. [a] -> (a -> Bool) -> Bool
02:09:41 <slangan> can a data have a n optional paramaeter?
02:09:57 <Axman6> :t  \xs x -> (all (==x) xs) == (foldr ((&&). (==x)) True xs)
02:09:59 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
02:10:03 <RayNbow> how does lambdabot infer the type of f in "foldr ((&&). ?f) True"? Does it transform it to "\f -> foldr ((&&).f) True" and then infer the type?
02:10:07 <Axman6> @check  \xs x -> (all (==x) xs) == (foldr ((&&). (==x)) True xs)
02:10:08 <lambdabot>   "OK, passed 500 tests."
02:10:11 <fasta> How can I replace all occurrences of string by another string in a string? The regex package doesn't appear to be documened in any kind of useful way. (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
02:10:11 <opqdonut> slangan: you need to make two constructors or something
02:10:20 <fasta> documented*
02:10:22 <opqdonut> slangan: or then make the "optional" field have type Maybe something
02:10:41 <blackh1> slangan: If you want only one constructor, but different ways of creating it, you need to write some "wrapper" functions to construct it.
02:11:09 <ning> is anyone know how to install xmonad on gnome?
02:11:18 <^Someone^> >:\
02:11:19 <ning> it seem ~/.gnomerc doesn't exist
02:11:25 <^Someone^> You made me think it was HER
02:11:41 <blackh1> slangan: If you do that, you might want to hide the real constructor by not exporting it from the module.
02:11:59 <Axman6> ^Someone^: ?
02:12:06 <^Someone^> Sorry
02:12:11 <^Someone^> No idea
02:13:39 <Axman6> ning: create it then, just touch .gnomerc
02:13:49 <slangan> how do I ask for the type of something?
02:13:52 <Axman6> or, touch ~/.gnomerc to be safe
02:13:58 <Axman6> slangan: :t
02:14:01 <ning> Oh, thanks
02:14:18 <slangan> can I somehow take a string and ask what type i can read it to?
02:14:50 <Axman6> like let x = read "string" :: Integer?
02:15:10 <solrize> > read "string" :: Integer
02:15:11 <lambdabot>   * Exception: Prelude.read: no parse
02:15:22 <Axman6> >_>
02:15:48 <Axman6> > reads "12srting456" :: [(Integer,String)]
02:15:50 <lambdabot>   [(12,"srting456")]
02:15:52 <blackh1> slangan: You can't manipulate types directly at runtime normally. If you really need to do this, you use Data.Dynamic and Data.Typeable.
02:16:09 <Axman6> slangan: what are you actually trying to do?
02:16:21 <slangan> is Parsec industrial strength(as is claimed byt he haskell community) or not? i have heard it is slow compared to "normal" parsers?
02:16:44 <slangan> can i catch exceptions?
02:16:57 <blackh1> slangan: You can catch exceptions! Are you using 6.10 or 6.8?
02:17:30 <slangan> 6.10.1
02:17:30 <Axman6> :t error
02:17:32 <lambdabot> forall a. [Char] -> a
02:17:41 <blackh1> slangan: Then I'd recommend Control.Exception
02:17:55 <Axman6> can you catch errors?
02:18:11 <quicksilver> do NOT try to catch the exception from read
02:18:15 <quicksilver> just say NO.
02:18:16 <blackh1> Axman6: Yes.  They turn into exceptions.  I know this from experience.
02:18:33 <Axman6> nice
02:18:37 <quicksilver> use 'reads' instead.
02:18:42 <Axman6> :t catch
02:18:43 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
02:18:54 <quicksilver> slangan: there's no magic way, "ask what type i can read it to"
02:19:03 <blackh1> Axman6: My web application does not die if it gets an error - it just gets caught by the catch-all at the top.
02:19:04 <quicksilver> slangan: you can just try a bunch of them one after another.
02:19:13 <quicksilver> slangan: reflect that some strings are readable as more than one type.
02:19:24 <Axman6> blackh1: nice. and continues working?
02:19:24 <quicksilver> > (read "3" :: Int,read "3" :: Double)
02:19:25 <lambdabot>   (3,3.0)
02:19:39 <blackh1> Axman6: Yes - it works fine. I even got a divide-by-zero once.
02:19:46 <Axman6> heh, nice
02:19:49 <quicksilver> slangan: "industrial strength" means different things to different people.
02:20:01 <quicksilver> Parsec is a good, fully functioning, maintanable parser.
02:20:10 <quicksilver> It's not as fast as the static lookup tables generated by yacc, no.
02:20:21 <quicksilver> ...but they're much harder to work on and maintain.
02:20:33 <quicksilver> for very many purposes, Parsec is fast enough.
02:20:37 <the_unmaker> I am such a nut I think I can take my unix experience, learn to program, and get rich.
02:20:42 <quicksilver> for certain purposes they might not be, I guess
02:20:47 <pumpkin_> is there a list somewhere of "nasty" functions that throw exceptions/errors under certain conditions, so I can stay away from them?
02:21:33 <Axman6> the_unmaker: eh?
02:21:57 <quicksilver> pumpkin_: I don't think so, no, but it's a very small number, and it's normally pretty obvious.
02:22:02 <quicksilver> pumpkin_: head, tail, fromJust, read
02:22:12 <Axman6> i do wish all the prelude functions wouldn't use error
02:22:24 <quicksilver> pumpkin_: and you don't necessarily need to stay away from them, just only use them when you know it's safe.
02:22:27 <quicksilver> Axman6: I don't.
02:22:30 <Axman6> though, my solution doesn't exactly work with fromJust...
02:22:34 <pumpkin_> is there some way of detecting functions with non-exhaustive pattern matches too?
02:22:37 <quicksilver> I'm glad that tail and fromJust exist.
02:22:46 <Axman6> pumpkin_: -Wall can tell you
02:22:57 <pumpkin_> ah, I thought it only did overlaps
02:22:58 <quicksilver> pumpkin_: ndm's project "catch" can even tell if you use them safely.
02:23:01 <pumpkin_> I'll take a look
02:23:12 <the_unmaker> haskell seems powerful
02:23:19 <the_unmaker> and general purpose
02:23:21 <Axman6> the_unmaker: it is
02:23:26 <the_unmaker> wh not use it to make money
02:23:42 <Axman6> exactly, go for it!
02:23:44 <the_unmaker> I am certainly not impressed with the garbage I see used at fox
02:23:56 <pumpkin_> :o
02:23:59 <Axman6> make something better then :)
02:24:09 <blackh1> the_unmaker: That's exactly what I'm attempting to do.  I decided to do a job, and I decided to learn a new language to do it better...
02:24:10 <the_unmaker> should be doable
02:24:17 <the_unmaker> kick butt
02:24:22 <the_unmaker> I want to solve problems
02:24:24 <blackh1> the_unmaker: And now I'm onto my second new language.  I've re-written about 14,000 lines.
02:24:35 <the_unmaker> 14k wow
02:24:49 <fasta> Is there really no string replacement function in any library?
02:24:57 <blackh1> the_unmaker: I'm going for quantity rather than quality. :)
02:25:07 <the_unmaker> is there something in haskell that does SNMP monitoring?
02:25:10 <the_unmaker> lol
02:25:22 <Axman6> @where SNMP
02:25:22 <lambdabot> I know nothing about snmp.
02:25:28 <Axman6> @go haskell SNMP
02:25:31 <lambdabot> No Result Found.
02:25:39 <mapreduce> > map (\c -> if (c == 'l') then 'm' else c) "hello"
02:25:40 <lambdabot>   "hemmo"
02:25:46 <pumpkin_> @faq can haskell do SNMP monitoring?
02:25:47 <lambdabot> The answer is: Yes! Haskell can do that.
02:25:51 <mapreduce> fasta: Too spicy for you?
02:25:53 <the_unmaker> ok here is a basic task: replace all occourances fo belinda with karen in a text file
02:25:54 <pumpkin_> the_unmaker: there you go
02:25:56 <blackh1> the_unmaker: Once I got over the learning curve I found Haskell to be a huge time saver.
02:25:58 <the_unmaker> how do that in haskell?
02:26:00 <mapreduce> @go haskell regex
02:26:05 <the_unmaker> blackh1: really?
02:26:06 <lambdabot> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
02:26:06 <lambdabot> Title: teideal glic deisbhéalach » Blog Archive » A Haskell regular expression tutor ...
02:26:19 <fasta> mapreduce: what do you mean?
02:26:37 <fasta> mapreduce: Do not think that I cannot write a monster library myself.
02:26:50 <blackh1> the_unmaker: It saves time because I can bang large quantities of code out and it just works.  I don't have to waste time debugging and testing it.
02:26:55 <mapreduce> fasta: You can use map for some replacements, and probably folds for others.
02:27:05 <pumpkin_> use mapreduce
02:27:07 <fasta> mapreduce: you are missing the point, completely.
02:27:31 <mapreduce> You want a String -> String -> String that does it?
02:27:32 <quicksilver> fasta: I one proposed a function let me see if I can find the post
02:27:38 <mapreduce> add an extra -> String
02:27:57 <fasta> quicksilver: yes, we discussed this earlier already and then we wrote one. I have on in my personal library, but not at work.
02:28:29 <blackh1> the_unmaker: There are some very useful things that I can do in Haskell that I can't do in other languages.
02:28:41 <quicksilver> fasta: http://www.mail-archive.com/haskell-cafe@haskell.org/msg26255.html
02:28:48 <quicksilver> fasta: (I don't think this is the one we discussed)
02:28:58 <fasta> quicksilver: no, this is a different one.
02:29:03 <quicksilver> that was what I found I needed when doing some fairly complex replacement work.
02:29:08 <blackh1> the_unmaker: One example is that code that assumes the user is logged in uses a different monad type to code that doesn't...
02:30:05 <blackh1> the_unmaker: So it means the compiler will not let me write code that assumes the user is logged in when I have not actually checked this.
02:30:06 <fasta> quicksilver: looks nice.
02:30:31 <solrize> blackh1 um, how does it make sure you used the right monad?
02:30:56 <pumpkin_> solrize: I think he wants that behavior
02:31:10 <blackh1> the_unmaker: Another very useful thing is that I've separated the database writes from the web page output so the compiler forces me to do all updates first.  This way, it is harder to accidentally display something that hasn't been updated.
02:31:44 <mapreduce> fasta: Sorry for causing confusion.
02:31:58 <Axman6> @hoogle Eq a => [a] -> [a] -> [[a]]
02:31:59 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
02:31:59 <blackh1> solrize: -- | Execute the code if a user is logged in, otherwise redirect to the home
02:31:59 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
02:31:59 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
02:31:59 <blackh1> -- page.
02:31:59 <blackh1> whenLoggedIn :: NonUserRequestClass r u => u () -> r ()
02:31:59 <blackh1> whenLoggedIn loggedInCode = ifLoggedIn loggedInCode jumpToHomePage
02:32:06 <fasta> mapreduce: that's ok.
02:32:30 <Axman6> > "abc" \\ "xyzabcxyabxyz
02:32:31 <pumpkin_> it would be nice of those union and intersect worked on infinite lists... I wrote ones today that do
02:32:31 <lambdabot>   <no location info>:
02:32:32 <lambdabot>      lexical error in string/character literal at chara...
02:32:32 <Axman6> > "abc" \\ "xyzabcxyabxyz"
02:32:34 <lambdabot>   ""
02:32:49 <blackh1> solrize: NonUserRequestClass is a type class with a functional dependency.  'u' is the corresponding 'user logged in' monad for 'r'.
02:32:57 <the_unmaker> blackh1: kick ass, are you doing web stuff in hakell then?
02:33:01 <quicksilver> pumpkin_: you have to assume sorted for that, don't you?
02:33:04 <pumpkin_> yup
02:33:17 <pumpkin_> I guess it can't be general
02:33:39 <blackh1> solrize: The monads were a little involved to set up but they make it really easy to avoid lots of silly mistakes.
02:34:01 <pumpkin_> intersect :: (SortedAscending a) => a -> a -> a
02:34:02 <pumpkin_> :P
02:34:19 <blackh1> the_unmaker: Yes, I'm starting a business with a friend - it's a big web app.
02:35:19 <solrize> i'm still not getting it.  sounds like there's a bunch of actions, some of which require logins and some of which don't, and you distinguish them in the code by choice of monad, but is that really different than just calling some function in the logged in actions to check for the login?
02:36:01 <solrize> hmm are you using a framework e.g. happs or anything like that?
02:37:40 <fasta> quicksilver: what kind of programs do you write? I.e., in what domain?
02:38:00 <blackh1> solrize: The different monads mean that my assumptions about the environment I'm running in are explicit in every type signature so there is no way to make a mistake.  I also have a non-web environment which is database only for scheduled jobs.  I can share code between that and the web stuff, with the requirements explicit in the monad and the compiler won't let me get it wrong.
02:38:02 <quicksilver> fasta: commercially, I write transaction processing and web software. That's not haskell though.
02:38:26 <quicksilver> fasta: I did use haskell for a bit of one off HTML-re-processing though, which was what I was doing when I made that post.
02:38:44 <quicksilver> (sanitizing the crap that MS Word's "Save as HTML" produces)
02:39:03 <the_unmaker> :)
02:39:05 <fasta> quicksilver: so backends of web applications?
02:39:07 <blackh1> solrize: No framework, for various reasons.
02:39:37 <the_unmaker> web web web
02:39:38 <the_unmaker> :)
02:39:38 <fasta> Any sufficiently interesting application will only get hindered by a framework.
02:39:39 <solrize> blackh1 is it all haskell including the httpd?  what kind of i/o?
02:39:59 <the_unmaker> how does one store abstraction in haskell?
02:40:02 <the_unmaker> libs?
02:40:09 <solrize> fasta, i don't think that's right, haskell frameworks are in a scattered state right now but things are starting to gel
02:40:11 <the_unmaker> packages?
02:40:29 <pumpkin_> there are modules
02:40:35 <blackh1> solrize: All Haskell except for apache, image libraries, and Berkeley DBXML for the database.
02:40:59 <solrize> how does the haskell app communicate with apache?
02:41:06 <Axman6> FastCGI?
02:41:09 <blackh1> solrize: I'm using scgi, which is needed with Berkeley DBXML due to some of DBXML's requirements.
02:41:19 <hugo___> hello
02:41:31 <pumpkin_> hello hugo___
02:41:32 <solrize> ic, that's sort of like fastcgi
02:41:34 <fasta> solrize: I was thinking of a framework as something that puts a distributed dependency in your source code, which makes it impossible to switch to something similar.
02:41:43 <Axman6> blackh1: tried lighttpd?
02:41:43 <fasta> solrize: not as a well-documented library.
02:41:58 <blackh1> To explain further: You get locking problems if processes are terminated when you are using Berkeley DbXML.
02:42:02 <the_unmaker> I want to build something prevayler-ish
02:42:03 * Axman6 isn;t sure what scgi is actually. another fcgi?
02:42:20 <the_unmaker> kinda
02:42:26 <the_unmaker> I think python people did it
02:42:32 <the_unmaker> zope guys
02:42:36 <blackh1> Axman6: No, I haven't tried it.
02:42:38 <the_unmaker> like simpler fastcgi
02:42:43 <the_unmaker> or something
02:42:47 <Axman6> supposed to be really fast for fcgi stuff
02:42:57 <the_unmaker> cherokee I think is winning the browser wars unless yaws is good
02:43:14 <hugo___> i see it is going to be a hard call to pick a logo
02:43:20 <hugo___> there lots of great logos there
02:43:23 <hugo___> congratulations :D
02:43:26 <the_unmaker> how come no one uses supercomputers to do web transactions?
02:43:36 <blackh1> solrize: fastcgi manages your application process life cycle for you, and scgi leaves it up to you.
02:43:41 <hugo___> i can see at least 3 excelent logos
02:43:55 <the_unmaker> or is aolserver actually faster than cherokee?
02:45:11 <blackh1> Axman6: scgi listens for requests on a socket, like a web server only it's a different protocol.  Then you just point apache (or whatever) at it.
02:45:31 <Axman6> fair enough
02:45:31 <blackh1> Axman6: So you can run your web server and your application on different machines, which can be useful.
02:45:40 <Axman6> ah yes, handeh
02:46:14 <solrize> aolserver, anyone still uses that?!
02:46:21 <solrize> but yeah, it was a real good server back in the day
02:46:30 <solrize> no idea what cherokee is
02:46:35 <Axman6> me either
02:46:36 <solrize> hyena sounds really interesting
02:46:50 <solrize> a pure haskell httpd using iteratee i/o
02:47:47 <Axman6> iteratee?
02:47:48 <solrize> i've had the idea of using SCM_RIGHTS messages on unix domain sockets to pass open file descriptors between an httpd and web app running as separate processes on the same machine
02:47:53 <the_unmaker> will it be fast?
02:48:23 <the_unmaker> aolserver people contend that aolserver is #1
02:48:26 <solrize> iteratee is an oleg-ism to do high speed i/o with predictable resource control and no lazy i/o insanity
02:48:37 <the_unmaker> due to threads+event architecture from 1995
02:48:39 <solrize> http://okmij.org/ftp/Streams.html
02:48:50 <fasta> quicksilver: you should just put this morph stuff in a library; it seems like a nice abstraction and it works.
02:48:51 <b_jonas> I'll try haxml for parsing xml
02:48:52 <the_unmaker> what are composable data streams?
02:49:21 <solrize> erm
02:49:22 <the_unmaker> lisp people came out with coreserver, with higher order functions and cmpasable data streams and continuations
02:49:26 <the_unmaker> whatever those mean
02:49:57 <Axman6> solrize: http://github.com/tibbe/hyena/tree/master ?
02:50:00 <quicksilver> fasta: I was hoping that post might stimulate some intelligent discussion but as you can see it didn't.
02:50:21 <solrize> the_unmaker basically it means you can have a stream of data and then a bunch of separate transformations on it that the code connects up nicely even though the different parts are implement separately from each other
02:50:24 <solrize> axman6 yes
02:50:29 <quicksilver> fasta: I think something like that deserves a place in Data.List
02:50:42 <solrize> axman6 there is a good pdf slide presentation about it
02:50:45 <quicksilver> fasta: called 'morph' or 'transform' or 'transmogrify'.
02:50:52 <quicksilver> fasta: probably I shuold propose it to libraries@
02:50:54 <fasta> quicksilver: I wouldn't mind it. I am all for more libraries.
02:51:32 <solrize> i liked alexj's presentation about happs also
02:51:36 <Axman6> solrize: got a link? google's not being too helpful with 'haskell hyena presentation'
02:51:41 <solrize> but it seems pretty confusing to use
02:51:44 <solrize> axman6 lemme look
02:51:48 <Axman6> ta :)
02:51:48 <fasta> solrize: me too.
02:51:49 <the_unmaker> solrize: like pipes in the shell?
02:51:54 <b_jonas> so how do you hGetContents to a String strictly?
02:51:58 <solrize> the_unmaker something like that, yeah
02:52:21 <solrize> http://www.galois.com/~dons/slides/08-09-tibell.pdf
02:52:38 <solrize> http://sites.google.com/site/haskell/notes/lazy-io-considered-harmful-way-to-go-left-fold-enumerator
02:53:59 <Axman6> thanks
02:56:31 <Axman6> solrize: sounds like a talk that would have been good on video :\
02:56:46 <maltem_> b_jonas: either write hGetContents', or read into a strict ByteString that you may then unpack if you really need a String
02:56:57 <solrize> is missingH in hackage?
02:57:04 <solrize> axman6 yeah
02:57:12 <solrize> maybe dons knows if there's a vid?
02:57:21 <b_jonas> maltem_: I want to pass it to Text.XML.HaXML.xmlParse so I need a String
02:58:21 <b_jonas> I guess I'll convert from a bytestring then
02:58:28 <the_unmaker> seems like some people get grants and are apid by google to learn haskell
02:58:35 <quicksilver> strict bytestring + unpacl is quite a good compromise
02:58:39 <quicksilver> because the unpack is lazy.
02:58:51 <quicksilver> so you have the data in memory, but in the compact form of a strict BS, doesn't take up much memory
02:58:52 <the_unmaker> what a great way to have things arranged: they pay you to learn
02:58:54 <the_unmaker> WOW
02:58:59 <quicksilver> and the unpack unfolds it gradualy.
02:59:06 <slangan> if iw ant do check: all (== Valid x) [Valid 5, Valid 12, Valid 6] where the x is irrelevant, i just want to chec ont he type like: all (\x y -> x y == Valid y) [Valid 5, Valid 5, Valid 5]
02:59:09 <slangan> how do i do that?
02:59:21 <b_jonas> so does xmlParse want a string of all bytes, or do I need to detect the encoding and decode the contents to characters first?
02:59:43 <fasta> the_unmaker: what makes you think that?
02:59:55 <Axman6> solrize: all (\x -> case x of Valid _ -> True; _ -> False)
03:00:49 <Axman6> uhm, slangan even
03:00:53 <quicksilver> b_jonas: if there is an encoding, you will need to decode, yes.
03:01:04 <the_unmaker> that guy was at google
03:01:48 <the_unmaker> and the paper that got me interested in haskell; the one that claims 10million threads on a commodity machine was by 2 stupdents or phd candidates I think..
03:01:59 <slangan> Axman6: even? no thats not what i want
03:02:01 <b_jonas> quicksilver: couldn't it find that out automatically from the xml declaration?
03:02:17 <slangan> data Output = Valid | SyntaxError | Quit
03:02:18 <b_jonas> <?xml version="1.0" encoding="ISO-8859-1"?>
03:02:19 <the_unmaker> superlightweight threads with an event model sounds very powerful to me
03:02:20 <solrize> the_unmaker, yeah, haskell has lightweight threads like erlang
03:02:23 <Axman6> slangan: see the thing above that line
03:02:33 <quicksilver> b_jonas: Yes, but as far as I know it doesn't.
03:02:35 <solrize> the_unmaker you should read RWH it sounds like you're in a position to understand it
03:02:41 <b_jonas> pity
03:02:42 <quicksilver> b_jonas: which library does xmlParse come from?
03:02:49 <the_unmaker> I also heard from some tcl people and read some stuff about event driven programming being easier cleaner and threadless
03:02:56 <b_jonas> quicksilver: Text.XML.HaXml.Parse
03:02:58 <fasta> the_unmaker: if you have a thread that keeps less information, it's faster. It's kind of trivial.
03:02:59 <maltem_> b_jonas: the "problem" is that data of type String is supposed to have handled with encodings already
03:02:59 <Axman6> fileEnum :: FilePath -> EnumeratorM IO; fileEnum fname iteratee seed = ... -- i'm confused, does that type actually match the signature?
03:03:00 <the_unmaker> I know nothing
03:03:08 <quicksilver> b_jonas: pretty sure haxml doesn't have any encoding stuff built in
03:03:24 <fasta> the_unmaker: so, it's comparing apples to oranges.
03:03:27 <the_unmaker> solrize: RWH? oh real world haskell?
03:03:27 <pumpkin_> http://okmij.org/ftp/Haskell/Mr-S-P.lhs is so elegant, despite his underscore usage for naming
03:03:31 <solrize> the_unmaker the issue with threads is that it's very hard to keep them from clobbering each others' data in conventional languages.  but in functional languages that problem goes away
03:03:33 <b_jonas> maltem_: yeah, it could accept a bytestring or something
03:03:36 <maltem_> b_jonas: so it's really the ByteString -> String transition where decoding should happen
03:03:37 <Axman6> slangan: did you see all (\x -> case x of Valid _ -> True; _ -> False)?
03:03:38 <solrize> the_unmaker yeah, http://book.realworldhaskell.org
03:03:46 <maltem_> b_jonas: yeah that would be the optimum
03:03:50 <malcolmw> that's right -- in HaXml, you need to deal with character encoding before reaching the parser
03:03:54 <b_jonas> should I use another xml library then?
03:04:00 <the_unmaker> I think I should perhaps read learn you a haskell for good or whatever first?
03:04:09 <quicksilver> solrize: well, it pure languages at least :)
03:04:14 <solrize> right
03:04:17 <the_unmaker> I also bought a book called  progarmming in haskell by hitton
03:04:19 <Axman6> the_unmaker: sure. ever done any other programing before?
03:04:20 <quicksilver> solrize: ML and lisp are both widely regarded as functional.
03:04:28 <the_unmaker> graham hutton, but I got stuck in it
03:04:30 <quicksilver> solrize: stupid those this terminology seems to me personally :)
03:04:31 <solrize> the_unmaker you should look at joe armstrong's book on erlang
03:04:36 <malcolmw> b_jonas: I think all you need to do is plumb together utf8-bytestring with HaXml
03:04:37 <Axman6> the_unmaker: if not, you might find RWH a bit better
03:04:41 <Axman6> @where RWH
03:04:41 <lambdabot> is http://www.realworldhaskell.org/blog/
03:04:42 <the_unmaker> I only program bash so far
03:05:00 <the_unmaker> I have tried common lisp, forth, and tcl
03:05:08 <solrize> if you want to do big concurrent apps you should certainly look at erlang
03:05:14 <the_unmaker> I heard great things about erlang
03:05:16 <maltem_> the_unmaker: just go through the tutorials/introductions/... mentioned on the wiki and find the one that catches you. it's hard to tell what's the best explanations for someone else
03:05:17 <solrize> high concurrency rather
03:05:23 <the_unmaker> ok
03:05:40 <the_unmaker> I want to have fun and make money and be amazingly productive
03:05:50 <the_unmaker> get lots fo women n stuff
03:05:54 <the_unmaker> jsut the basics of life
03:06:04 <solrize> become an artist
03:06:10 <doublec> or a gigilo
03:06:16 <blackh1> the_unmaker: You may possibly be interested in my SMTP client. I know SMTP clients are not usually interesting, but this one is written as a pure state machine, but Haskell allows this style to be written without any pain or suffering like in most languages
03:06:35 <JoshTriplett> quicksilver: Based on your advice, I managed to get a bit more useful information from my heap profiles.  I still have one question I can't seem to find the answer to, though: given a profile that says I use a pile of memory on type [], how can I figure out whether that represents [Char] or [Thingy] or [OtherThingy]?
03:06:38 <the_unmaker> an email client?
03:06:42 <the_unmaker> hows the interface?
03:07:11 <blackh1> the_unmaker: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SMTPClient
03:07:22 <blackh1> the_unmaker: No - it's just an SMTP client library, not an email program.
03:07:44 <the_unmaker> used for what? to let your program email you?
03:08:02 <blackh1> the_unmaker: Yes - that's exactly what it does.  This was my first attempt at "continuation passing style" and it worked absolutely brilliantly.
03:08:20 <the_unmaker> k00l
03:08:21 <the_unmaker> !!
03:08:30 <the_unmaker> IM so full of fear
03:08:38 <the_unmaker> I dont know anything about real programming
03:09:03 <the_unmaker> when a multi line shell script goes to work for me and I know its doing well I feel like a greek god
03:09:11 <blackh1> the_unmaker: I don't know if you've tried writing state machines before... The result is extremely efficient but in most languages there's a lot of annoying and bug-prone housekeeping.  But not in Haskell!
03:09:26 <the_unmaker> friggin awesome
03:09:45 <the_unmaker> don't a lot of people use postgresql as thier state machine?
03:09:47 <JoshTriplett> Sigh, I love wireless cards.  Got disconnected right after asking a question.
03:09:57 <quicksilver> JoshTriplett: I thought that was supposed to be visible in the -hy info.
03:10:02 <the_unmaker> wireless is unstable
03:10:06 <quicksilver> JoshTriplett: evidentally I am wrong.
03:10:08 <blackh1> the_unmaker: I'm using the term state machine in a non-database sense.
03:10:08 <the_unmaker> get a nice copper snake
03:10:10 <JoshTriplett> quicksilver: No, it just says [].
03:10:13 <the_unmaker> ok
03:10:14 <quicksilver> [screen/irssi ftw]
03:10:22 <the_unmaker> <--irssi now
03:10:29 <quicksilver> JoshTriplett: I can suggest an ugly hack - stick a newtype in the mix.
03:10:35 <mapreduce> screen/emacs/erc ftw
03:10:44 <quicksilver> JoshTriplett: doesn't seem like it shuold be necessary though.
03:11:03 <the_unmaker> for gods sake here on freebsd I am compiling the ksh93 port so I have a decent shell
03:11:16 <blackh1> the_unmaker: A state machine is a piece of event-driven code that gets an event, e.g. received I/O, and modified its own state, then maybe generates some output.
03:11:34 <the_unmaker> the ash it comes with claims that there is no command history because the authour thought that stuff should go in the terminal server
03:11:35 <b_jonas> so after I iconv from one encoding to utf8 or utf16 or whatever easy encoding, how do I unpack the bytestring to a String of characters?
03:11:40 <b_jonas> I thought there was some module for that
03:11:45 <JoshTriplett> the_unmaker: bash ftw? :)
03:11:47 <the_unmaker> I dotn know howto get command history from my terminal..
03:11:48 <blackh1> the_unmaker: State machines are a way of avoiding threading issues.
03:12:03 <the_unmaker> blackh1: awesome
03:12:22 <the_unmaker> I have heard nginx and lighttpd are efficient due to event model not threads
03:12:22 <JoshTriplett> quicksilver: Yeah, I've tried creating new type wrappers everywhere, and that helps a bit, but it requires me to guess where I'll want more information.
03:12:39 <the_unmaker> BUT aolserver people claim they are not as fast adn you have to start one for each CPU
03:12:47 <the_unmaker> then have N logs
03:12:58 <blackh1> the_unmaker: Event-based programming is devastatingly efficient in both CPU time and memory.
03:13:01 <the_unmaker> where aolserver threads jsut work on multi spu without problems
03:13:10 <the_unmaker> cpu that is
03:13:16 <the_unmaker> damn I gota learn to type
03:13:22 <b_jonas> multi-threading should be efficent in theory
03:13:24 <JoshTriplett> the_unmaker: Heh.  If aolserver ran on SPUs I'd find that fairly impressive. :)
03:13:31 <solrize> the_unmaker it really doesn't matter much as long as you're not using POSIX threads.  if you really want to go balls to the wall, google "c10k problem" and read that paper.  but for web servers, threads are a lot easier to program than events, and the haskell and erlang threading systems are very lightweight and efficient.
03:13:33 <b_jonas> but the libraries to do it easily and efficently are hard to write
03:13:37 <the_unmaker> SPU?
03:13:37 <blackh1> the_unmaker: But it is normally extremely annoying to code.  You see a lot of it in C code.  Haskell actually removes all the pain from this style.
03:13:49 <the_unmaker> k00l
03:14:18 <the_unmaker> tcl people also claim events make it very easy to have processes communicate
03:14:26 <the_unmaker> although I might be mangling things
03:14:37 <JoshTriplett> the_unmaker: Yes, but then you have to write in tcl. :)
03:14:45 <the_unmaker> osterhout who made tcl said threads not worth the trouble
03:14:46 <Axman6> heh
03:14:55 <b_jonas> ah, apparently it was the encoding library
03:15:07 <b_jonas> I'll download that
03:15:18 <mapreduce> ousterhout also thought there was a difference between scripting languages and programming languages.
03:15:19 <solrize> the_unmaker, that was in the 1980's or 90's, threads work better now
03:15:27 <the_unmaker> oh
03:15:34 <blackh1> the_unmaker: Event-based programming has its issues and often threads are a better way, but it depends on the application.
03:15:44 <the_unmaker> there is a language called oz that has very light threads
03:15:55 <the_unmaker> says it allows all kinds fo new programmign techniques
03:15:55 <solrize> that's what i mean, many languages now have light threads
03:16:16 <the_unmaker> stackless python I think claims superlight threads too and of course erlang
03:16:22 <solrize> oz is interesting and some people just rave about how great that book is.  i looked at it a little and couldn't get into it, but that's just me
03:16:30 <solrize> stackless is more or less dead, i think
03:16:41 <b_jonas> installing it now
03:16:44 <the_unmaker> I kinda read bits about all these things and dont know what to do to really learn some stuff to build something
03:16:52 <the_unmaker> they all seem very cool
03:16:54 <solrize> python is sort of a dead end, it's great for simple tasks but i think trying to do big systems in it is a mistake
03:17:28 <maltem_> solrize: hm I don't know much python, but the Mercurial source code e. g. looks quite clean to me
03:17:41 <blackh1> solrize: That's what I found.  I wanted to give it a fair go, and I definitely did.
03:17:48 <quicksilver> don't think big systems in python are really that different from big systems in any popular similar language
03:18:01 <b_jonas> I've got a strange error message
03:18:04 <quicksilver> people can and do write big projects in python, perl, ruby, heck even tcl.
03:18:04 <b_jonas> wait, I'll paste it
03:18:08 <maltem_> solrize: of course, the lack of a real type system would be embarrassing for any of us
03:18:12 <the_unmaker> some say people put too much in code and should let postgresql contain more
03:18:21 <the_unmaker> thereby keeping things lean
03:18:24 <Axman6> quicksilver: like macports :\
03:18:25 <the_unmaker> ever read tablizer?
03:18:38 <the_unmaker> the guy who wrote about oo programming being oversold?
03:18:59 <mapreduce> I did.  He was right about that but wrong about his solution :)
03:19:02 <JoshTriplett> the_unmaker: Very true.  People use databases just as dumb tables nowadays, partly due to ORM systems.
03:19:02 <solrize> quicksilver, python 1) lacks a type system 2) is implemented by a rather slow interpreter that is 3) basically limited to single processors even though it's multithreaded, because of the global interpreter lock resulting from the reference counting GC
03:19:20 <JoshTriplett> solrize: 1) pypy, 2) pypy, 3) pypy. :)
03:19:37 <mapreduce> JoshTriplett: How does pypy solve 1) ?
03:19:51 <maltem_> the_unmaker: I didn't, but I'm very much of the opinion that oo programming is being oversold indeed
03:20:04 <BeelsebobWork> oh wow - well done whoever came up with this one http://galois.com/~dons/images/logos/Haskell_logo.png
03:20:04 <solrize> josh, that will be interesting when it happens.  i'm of the view that python 3.0 was released a year or so too early, they should have waited until pypy was real and so they could see how it affected which way to adjust the language
03:20:09 <BeelsebobWork> it's fairly awesome
03:20:11 <the_unmaker> http://prevayler.org/ this seems AWESOME
03:20:28 <solrize> the_unmaker prevayler was sort of a scam, but happs state is the same idea done right
03:20:32 <JoshTriplett> mapreduce: It does a lot of type inference.  And if you combine that with python 3.0's type annotations...
03:20:46 <b_jonas> error from building the encoding cabal package --> http://paste.lisp.org/display/72394
03:20:57 <b_jonas> does anyone know why that could be?
03:21:03 <solrize> python 3.0's type annotations aren't part of the language!  ther'es just a field in function definitions where the programmer can put any old thing and then let the compiler do something undefined
03:21:06 <mapreduce> JoshTriplett: Does it give you compile errors, or does it just make uninferable types slow?
03:21:35 <mapreduce> inferrable and inferable both look like spelling mistakes
03:21:38 <b_jonas> also, do you recommend that module or is there a different one I should use?
03:21:39 <maltem_> BeelsebobWork: shouldn't the URI tell about the creator?
03:21:43 <solrize> beelse those logos look nice but i don't understand the relation between that propeller and haskell ?
03:21:55 <the_unmaker> solrize: I tried a year ago to install happs and got my ass kicked
03:21:58 <the_unmaker> darcs things broke
03:22:01 <the_unmaker> I was in hell
03:22:09 <JoshTriplett> mapreduce: Either, depending on what you want.
03:22:10 <the_unmaker> even after getting some stuff from hackage
03:22:15 <the_unmaker> couldnt get damn happs running
03:22:19 <solrize> yeah, it may be a bit better now
03:22:33 <blackh1> solrize: You have to be a propeller head to use Haskell.
03:22:35 <quicksilver> solrize: all those things begin true, what I said remains true.
03:22:59 <quicksilver> solrize: believe me I'm not *recommending* python. I'm simply stating as fact that people have written large systems of good code in it.
03:23:14 <quicksilver> (which is true of many languages: good programmers write good programs, sometimes)
03:23:19 <the_unmaker> Ima bit of a propeller but as a unix admin I have been taught to fear and idolitrize 'code'
03:23:22 <Axman6> i know google use python a lot
03:23:26 <the_unmaker> I want to crush this weakness in myself
03:23:42 <Axman6> the_unmaker: well haskell's a good place to start :)
03:23:47 <the_unmaker> :)
03:23:51 <the_unmaker> yay!
03:23:52 <Axman6> the_unmaker: started on any of the tutorials yet?
03:23:53 <blackh1> the_unmaker: Code is your friend!
03:23:57 <mapreduce> Google uses python as glue, and I expect they're happy to replace it when it's too slow or difficult to get right.
03:24:05 <the_unmaker> not yet
03:24:11 <the_unmaker> I am going to bed
03:24:12 <Axman6> well get to it! :P
03:24:15 <Axman6> bah
03:24:18 <the_unmaker> on jet to boston in 4 hours
03:24:21 <Axman6> learning > sleep
03:24:21 <the_unmaker> ok
03:24:24 <the_unmaker> lol
03:24:38 <the_unmaker> ok let me do fisrt paeg of learn you a haskell for gereat good
03:25:19 <blackh1> mapreduce: The Telit wireless modem has a Python interpreter in it. :)
03:25:27 <Axman6> the first page is pretty long actually :P
03:25:37 <maltem_> Axman6: you learn a lot sleeping
03:25:38 <Axman6> but get some of it done :)
03:25:47 <maltem_> that's when things settle down
03:25:56 <quicksilver> b_jonas: looks like encoding is not compatible with GHC 6.10
03:26:07 <b_jonas> quicksilver: I see
03:26:12 <quicksilver> b_jonas: you can probably fix that by changing 'Control.Exception' to 'Control.OldException' if you wish.
03:26:26 <quicksilver> or you could try utf8-string as an alternative package
03:26:33 <quicksilver> if you don't need other encodings than utf8
03:26:41 <pumpkin_> anyone know of any good tutorials on using LogicT?
03:28:04 <Axman6> maltem_: yeah, i found that the other night, when i almost got to sleep, and realised there was a better way of doing something i'd been writing and had to get up and do it before i gorgot it (it was about 5AM by then)
03:28:09 <Axman6> forgot*
03:29:12 <maltem_> ah was that when you wrote about it in #haskell? :)
03:29:14 <b_jonas> quicksilver: well, I could use iconv and utf8-string
03:29:32 <b_jonas> quicksilver: thanks for the help
03:30:04 <quicksilver> b_jonas: np. You might report a bug to the encoding authoer.
03:30:09 <b_jonas> ah, utf8-string is a string library that stores stuff as utf8 internally?
03:30:10 <b_jonas> I see
03:30:21 <quicksilver> utf8 string has a variety of bits in it
03:30:32 <quicksilver> it has a replacement for System.IO which uses utf8 encoding on output.
03:30:34 <mbz> pumpkin_, LogicT? What's that?
03:30:38 <mbz> @index LogicT
03:30:38 <lambdabot> bzzt
03:30:51 <the_unmaker> ok i can load files adn do math
03:30:54 <the_unmaker> in ghci
03:30:56 <the_unmaker> :)
03:30:56 <mbz> @hoogle LogicT
03:30:57 <lambdabot> package logict
03:31:06 <b_jonas> quicksilver: is there a central bug tracker for cabal or do I have to follow instructions for each package separately?
03:31:21 <quicksilver> you don't need to use the UTF8 type though
03:31:28 <quicksilver> you can just use encode :: String -> [Word8]
03:31:30 <pumpkin_> one of the (elegant) solutions to the knight's tour was written in it, and can't seem to find much about it beyond oleg's paper, which isn't a very easy introduction to it
03:31:36 <quicksilver> and decode :: [Word8] -> String
03:31:45 <quicksilver> b_jonas: I'm afraid that is correct, yes.
03:31:50 <quicksilver> (no centralised bug tracker)
03:31:54 <maltem_> b_jonas: well utf8-string uses String, which is [Char], where Char "directly" represents a unicode code point
03:32:03 <blackh1> the_unmaker: You are making me re-live my initial excitement. :)
03:32:31 <the_unmaker> booleans!
03:32:38 <quicksilver> maltem_: uft8-string does also have a special UTF8 type though
03:32:46 <the_unmaker> ok warriro needs rest
03:32:51 <quicksilver> maltem_: but you don't have to use it explicitly.
03:32:53 <the_unmaker> warrior
03:32:55 <maltem_> quicksilver: oh neglected that then
03:33:13 <the_unmaker> let me slep on one thing: can haskel be used in business to do real web and financail crunching?
03:33:20 <quicksilver> and it has a convenience layer over bytestring.
03:33:50 <the_unmaker> good morning night all
03:35:49 <solrize> the_unmaker haskell is very popular with the financial crowd, credit suisse is a big haskell user
03:36:19 <solrize> they absolutely have to get their code correct and they don't mind paying super expensive geeks to write it, if that's what it takes
03:36:31 <Eelis> solrize: how many percent of financial software would you estimate is written in Haskell?
03:36:47 <solrize> eelis if you mean stuff like spreadsheets, probably none
03:37:01 <Eelis> solrize: i mean whatever you were thinking of when you said haskell was popular with the financial crowd :)
03:38:13 <solrize> eelis hmm i should phrase it a different way, within the community of commercial haskell users, the financial sector is quite prominent
03:38:26 <Eelis> ah, that sounds more grounded in reality :)
03:38:33 <solrize> compared to the total amount of financial code out there (probably mostly cobol and java) the amount of haskell is tiny
03:38:37 <pumpkin_> @hoogle xor
03:38:38 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
03:38:54 <solrize> but, i have the impression that haskell is used in high end program trading and stuff like that
03:39:21 <solrize> there's also a wall street company that does all its stuff in ocaml
03:39:30 <slangan> ressrrerrtwhy does this give intendationerror ?
03:39:31 <slangan> all (== Valid _) [Valid 5, Valid 5]
03:39:42 <quicksilver> slangan: on its own, it won't.
03:39:43 <Eelis> solrize: such impressions tend to be heavily skewed from exposure to one or two blogs about the subject in question
03:39:53 <quicksilver> slangan: but, it is invalid.
03:39:55 <pumpkin_> the underscore?
03:40:03 <quicksilver> (== Valid _) is not a valid haskell expression.
03:40:45 <slangan> (\x -> case x of Valid _)
03:40:49 <pumpkin_> you could write an isValid function that pattern matched on Valid _ and returned True
03:40:50 <slangan> fail
03:40:53 <pumpkin_> and call all on that
03:41:10 <solrize> eelis what can i say, that company has been around and using ocaml for a while, i dunno that there are others like it, but that one is pretty visible out here in FP heaven
03:41:14 <Axman6> slangan: i gave you the code to make it work earlier :\
03:41:40 <Axman6> all (\x -> case x of Valid _ -> True; _ -> False) xs
03:42:12 <quicksilver> Eelis: financial companies are extremely secretive about what they use.
03:42:27 <quicksilver> Eelis: I can only speak from the little facts that sneak out from time to time, plus people I know who've worked at them.
03:42:31 <acmeuser> Hi people, somebody can recommend a haskell compiler/interpretator for pocket pc ?( in my particular case it's asus 696 with windows mobile 6, ARM ) .
03:42:38 <quicksilver> There is a lot of python, perl, java behind the scenes.
03:42:57 <solrize> acmeuser i think you may be stuck with hugs
03:42:58 <quicksilver> there's also a lot of excel spreadsheets :P
03:43:19 <Eelis> quicksilver: yes, that sounds more plausible :)
03:43:19 <quicksilver> acmeuser: it is possible to run GHC on ARM but it's pretty slow and not easy.
03:43:40 <quicksilver> Eelis: equally, though, there is a fair amount of ocaml and some haskell.
03:43:45 <quicksilver> And, yes, some COBOL.
03:43:51 <Eelis> quicksilver: i'll have to take your word for it
03:44:53 <acmeuser> solrize , quicksilver - strange that I had not found binary releases for windows mobile for arm neither for hugs nor ghc.
03:44:55 <pumpkin_> > iterate ((1 /) . (2 +)) 2
03:44:57 <lambdabot>   [2.0,0.25,0.4444444444444444,0.40909090909090906,0.4150943396226415,0.41406...
03:45:40 <solrize> windows mobile, probably nobody cares about it, but you can probably build hugs for it without too much trouble if you have a C compiler.  ghc would be a lot harder
03:47:06 <pumpkin_> is there a scan-like iterate?
03:47:22 <pumpkin_> that composes a function with itself once, twice, three times, and so on?
03:47:30 <pumpkin_> oh wait, that's what iterate does
03:47:40 <b_jonas> :)
03:47:43 <pumpkin_> :P
03:47:54 <acmeuser> solrize thanks, I have no C compiler, but it's good to know there is no compiled binaries for windows mobile. I'll try to build it :)
03:50:43 <pumpkin_> > iterate ((1 /) . (2 +)) 2 :: [Expr]
03:50:44 <lambdabot>   [2,1 / (2 + 2),1 / (2 + 1 / (2 + 2)),1 / (2 + 1 / (2 + 1 / (2 + 2))),1 / (2...
03:51:08 <pumpkin_> hmm, I'm failing
03:51:57 <pumpkin_> > iterate ((1 /) . (2 +) . (1 /)) 2 :: [Expr]
03:52:23 <pumpkin_> that's not it
03:52:34 <lambdabot>   [2,1 / (2 + 1 / 2),1 / (2 + 1 / (1 / (2 + 1 / 2))),1 / (2 + 1 / (1 / (2 + 1...
03:53:19 <pumpkin_> oh maybe it is hmm
03:53:38 <pumpkin_> > iterate ((1 /) . (2 +) . (1 /)) 2
03:53:40 <lambdabot>   [2.0,0.4,0.2222222222222222,0.15384615384615385,0.11764705882352941,9.52380...
03:53:47 <pumpkin_> > map (1+) $ iterate ((1 /) . (2 +) . (1 /)) 2
03:53:48 <lambdabot>   [3.0,1.4,1.2222222222222223,1.1538461538461537,1.1176470588235294,1.0952380...
03:53:57 <pumpkin_> nope
03:55:03 <Axman6> what're you aiming for?
03:55:17 <pumpkin_> the continued fraction (minus one) representation of sqrt 2
03:56:36 <Axman6> this is for PE right?
03:56:49 <pumpkin_> yes, but I'd also fooled around with it before then
03:57:05 <pumpkin_> and it seems like I can't directly use this fact for PE given that it won't construct an infinite type with %
03:58:17 <maltem_> > iterate (\a -> (a + 2/a)/2) 1 :: [Double]
03:58:19 <lambdabot>   [1.0,1.5,1.4166666666666665,1.4142156862745097,1.4142135623746899,1.4142135...
03:58:41 <maltem_> (Is Heron's formula cheating?)
03:58:43 <pumpkin_> ah, that makes remarkably more sense :P
03:59:16 <pumpkin_> probably :)
03:59:27 <pumpkin_> > iterate (\a -> (a + 2/a)/2) 1 :: [Expr]
03:59:33 <lambdabot>   [1,(1 + 2 / 1) / 2,((1 + 2 / 1) / 2 + 2 / ((1 + 2 / 1) / 2)) / 2,(((1 + 2 /...
03:59:42 <quicksilver> pumpkin_: your first attempt was right.
03:59:51 <quicksilver> > map (1+) $ iterate ((1 /) . (2 +) ) 2
03:59:53 <lambdabot>   [3.0,1.25,1.4444444444444444,1.4090909090909092,1.4150943396226414,1.414062...
04:00:05 <quicksilver> pumpkin_: not sure what made you think that version was wrong ;)
04:00:05 <pumpkin_> quicksilver: yeah, I thought so, but it wasn't expanding the way I wanted it to
04:00:18 <quicksilver> well you missed the map (1+)
04:00:23 <quicksilver> but that's not the point...
04:00:27 <pumpkin_> yeah, I knew I was doing it minus one
04:00:31 <pumpkin_> :P
04:00:37 <quicksilver> > map (1+) $ iterate ((1 /) . (2 +) ) 2 :: [Rational]
04:00:38 <lambdabot>   [3%1,5%4,13%9,31%22,75%53,181%128,437%309,1055%746,2547%1801,6149%4348,1484...
04:00:44 <pumpkin_> :o
04:00:46 <quicksilver> not entirely sure what you mean about it not working for Rational
04:00:58 <pumpkin_> oh I was trying to use the % constructor directly
04:01:02 <pumpkin_> in place of /, which I guess is wrong
04:01:10 <quicksilver> it is, yes.
04:01:38 <quicksilver> it's rather a nice way ot getting the rational approximants.
04:01:41 <quicksilver> haskell++
04:01:43 <pumpkin_> :)
04:01:46 <pumpkin_> yup
04:02:06 <quicksilver> > last . take 50 . map (1+) $ iterate ((1 /) . (2 +) ) 2 :: [Rational]
04:02:07 <lambdabot>       No instance for (Fractional [Rational])
04:02:07 <lambdabot>        arising from a use of `/...
04:02:17 <quicksilver> > last . take 50 . map (1+) $ iterate ((1 /) . (2 +) ) 2 :: Rational
04:02:18 <lambdabot>   12584382979358171525%8898502541752731604
04:02:30 <quicksilver> > last . take 50 . map (1+) $ iterate ((1 /) . (2 +) ) 2 :: CReal
04:02:31 <lambdabot>   1.4142135623730950488016887242096980785384
04:02:42 <pumpkin_> > sqrt 2 :: CReal
04:02:44 <lambdabot>   1.4142135623730950488016887242096980785697
04:02:55 <pumpkin_> not too shabby
04:02:58 <quicksilver> converges moderately fast, that continued fraction
04:03:32 <maltem_> pumpkin_: using (%) directly isn't wrong, you just have to import (%) from Data.Rational (or Data.Ratio or what it was called again)
04:03:43 <pumpkin_> I did
04:03:54 <pumpkin_> but it complained about constructing an infinite type when I used % directly
04:04:04 <pumpkin_> which made sense
04:04:12 <pumpkin_> I wanted to stick a ratio into my denominator
04:04:19 <quicksilver> maltem_: it is wrong, because it's not what he wanted to tdo :)
04:04:30 <quicksilver> > (1%2) % (3%4)
04:04:31 <lambdabot>       No instance for (Integral (Ratio t))
04:04:31 <lambdabot>        arising from a use of `show...
04:04:40 <quicksilver> > (1%2) / (3%4)
04:04:41 <lambdabot>   2%3
04:04:52 <maltem_> oh, in that expression, of course
04:05:17 <quicksilver> pumpkin_: YO DAWG, I HEARD YOU LIKE DIVISION SO I PUT A DENOMINATOR IN YOUR DENOMINATOR SO YOU CAN DIVIDE WHILE YOU DIVIDE
04:05:22 <pumpkin_> lol
04:06:12 <fasta> Oh, in case someone is looking for a nice Haskell project: make a blogging application in Haskell that is _not_ web-based and which actually works.
04:06:47 <quicksilver> fasta: blogging application not web-based?
04:06:51 * quicksilver looks slightly baffled.
04:07:13 <fasta> quicksilver: I mean that all operations are done locally and when one is satisfied one sends it to the evil Web.
04:07:17 <quicksilver> ah yes.
04:07:25 <quicksilver> That would be nice. Defer the evil.
04:07:28 <letfunbegin> like a text editor?
04:07:33 <pumpkin_> maybe an SCM-based one?
04:08:13 <maltem_> reimplement ikiwiki in Haskell ^^
04:09:10 <fasta> Maybe as an extension of Yi or something. Since, I don't trust anyone to make a fully working Emacs blogging application :)
04:09:51 <fasta> Can Yi already display anything else but text? I mean like graphical elements like pictures and so on?
04:10:08 <maltem_> fasta: it cannot
04:10:25 <maltem_> fasta: actually the console frontend is the only tested one
04:12:22 <pumpkin_> whee got problem 57
04:12:24 <chessguy_work> 'morning, #haskell
04:13:12 <mapreduce> emacs can display JPEGs.  It startled me when I first saw that.
04:13:14 <pumpkin_> morning :)
04:13:33 <b_jonas> I changed imports of Control.Exception to Control.OldException, now the package builds, but
04:13:34 <mapreduce> I was expecting this file to load as hexadecimal.
04:13:41 <b_jonas> I'm getting an error when generating documentation for it:
04:13:44 <fasta> mapreduce: It can also display pdf.
04:13:48 <b_jonas> http://paste.lisp.org/display/72394#1
04:14:33 <mapreduce> I normally use it in screen now, so obviously there it can do none of that.
04:14:52 <b_jonas> I wonder what that means
04:16:08 <chessguy_work> b_jonas, it means, like most haskell errors, "there's a problem you're not smart enough to fix"
04:16:11 <maltem_> b_jonas: ugly. does updating haddock help somehow?
04:18:13 <b_jonas> maltem_: you mean updating it further than what comes with ghc-6.10.1 ?
04:18:20 <b_jonas> I mean, the encoding package is older
04:18:27 <pumpkin_> Axman6: you aren't working on the project euler problems anymore, right?
04:18:32 <b_jonas> I could try, maybe there's an error fixed
04:18:38 <Axman6> pumpkin_: not atm, no
04:18:43 <pumpkin_> ok
04:18:47 <Axman6> need to find fun problems ;)
04:18:48 <b_jonas> I have haddock-2.3.0
04:19:11 <pumpkin_> Axman6: you can pick from the ones I've solved, probably means they aren't too tedious cause I'm lazy
04:19:23 <quicksilver> b_jonas: I think it means "the haddock file was generated by a different version of haddock"
04:19:31 <b_jonas> newest is 2.4.1
04:19:41 <b_jonas> I could update haddock
04:19:41 <quicksilver> b_jonas: ...that is, the haddock file for regex-compat, which its look at so it can make the magic hotlinks
04:19:49 <quicksilver> b_jonas: was generated by a different version of haddock
04:19:52 <quicksilver> to the one currently running.
04:20:00 <quicksilver> I postulate it was generated with an older one, not a newer one.
04:20:02 <quicksilver> but ICBW.
04:20:11 <b_jonas> quicksilver: maybe, but regex-compat is in ghc-extralibs, isn't it?
04:20:16 <quicksilver> yes.
04:20:17 <Axman6> pumpkin_: what country are you from anyway?
04:20:27 <quicksilver> I don't know if that bundle comes with pre-generated .haddock
04:20:35 <b_jonas> so then the haddock for it should have been generated when I installed ghc-6.10.1 with extralibs
04:20:36 <quicksilver> or if it got generated on your machien when you installed it
04:20:41 <quicksilver> (I don't know much about haddock)
04:20:44 <b_jonas> pre-generated haddoc... hmm
04:20:44 <pumpkin_> Axman6: it depends what you mean by from :P
04:20:54 <b_jonas> I didn't know those exist
04:20:55 <b_jonas> I see
04:20:59 <pumpkin_> Axman6: I was born in london, grew up in rome, and live in the US
04:21:03 <quicksilver> I propose that the term for pre-generated haddock files should be "smoked"
04:21:04 <Axman6> where are you now then :P (/what country are you using on PE)
04:21:17 <pumpkin_> Axman6: I didn't put a country down on PE :)
04:21:29 <b_jonas> so should I first update haddock and then maybe regenerate the haddocks for ghc with extralibs?
04:21:50 <Axman6> 59, doing well :)
04:22:09 <pumpkin_> Axman6: been lying in bed feeling bored :P
04:22:13 <Axman6> heh
04:22:29 <pumpkin_> there's only so much digg, slashdot, reddit one can read
04:22:49 <b_jonas> pumpkin_: did you try webcomics?
04:23:15 <Axman6> pumpkin_: how efficient was your answer to 123?
04:23:20 <quicksilver> b_jonas: Well, that is consistent with my theory. I fall short of actually recommending that course.
04:23:23 <pumpkin_> b_jonas: I read some non-sequential ones :P too lazy to get into ones with real story lines
04:23:29 <quicksilver> b_jonas: I don't want to be responsible for all your haddocks breaking :)
04:23:37 <b_jonas> I see
04:23:42 <quicksilver> and like I said, I don't know much about haddock.
04:23:52 <pumpkin_> Axman6: can't remember, but I nothing I've written so far has taken hours :P
04:23:59 <pumpkin_> several have taken more than the one minute though
04:24:06 <Axman6> quite a lot of mine have :(
04:24:16 <Asztal> tsk, tsk :(
04:24:37 <pumpkin_> yeah, I figure I'll go back to them later more methodically and get efficient solutions
04:24:37 <Asztal> though I've found that things can run quite a lot slower in GHCI
04:24:46 <pumpkin_> yeah, I do everything in ghci
04:24:55 <Asztal> I mostly do too
04:24:55 <pumpkin_> which means everything I do is ephemeral :P
04:25:26 <Asztal> I usually use a file and keep :reloading it.
04:25:43 <pumpkin_> ah, I don't even do that
04:25:47 <Asztal> that way I keep it, and if GHCI crashes (which it does far too often)...
04:25:54 <pumpkin_> which is frustrating when my program balloons in memory consumption
04:25:56 <pumpkin_> and I have to kill it
04:26:00 <pumpkin_> and ghci forgets my history :(
04:26:03 <Asztal> that too
04:26:33 <b_jonas> ok, thanks, I'll try it anyway
04:26:37 <Asztal> sometimes I swear GHCI doesn't even bother reclaiming memory used by something I've Ctrl-C'd
04:26:55 <b_jonas> I think if all goes wrong I could restore my docs by reinstalling ghc-6.10.1
04:26:58 <pumpkin_> yeah, it doesn't seem to for me either
04:27:14 <pumpkin_> also, it loves to ignore my ctrl+Cs
04:27:21 <pumpkin_> when I can see it gobbling up all my RAM
04:27:28 <pumpkin_> I try to stop it, but it just ignores me
04:27:42 <Asztal> that's only occasional for me
04:29:37 <slangan> Name some things Haskell would be bad for or that other languages do (much) better?
04:29:59 <pumpkin_> slangan: problems that by design require mutable state aren't so natural in haskell
04:30:33 <Peaker> slangan: IMO, Haskell's learning curve is steeper than other languages (e.g Python)
04:30:36 <quicksilver> slangan: memroy compactness.
04:30:51 <Peaker> slangan: so someone will become productive with Python more quickly, if he's starting from scratch
04:30:57 <pumpkin_> and ease of reasoning about memory usage
04:30:59 <quicksilver> slangan: that is, problems whose performance depends critically on fitting into a cache line
04:31:11 <quicksilver> Peaker: s/from scratch/from knowing another python-like-language/
04:31:54 <Peaker> quicksilver: Python requires you know very little before you become productive.. to be productive with Haskell, you need to understand quite a bit more about types, and even setting up the environment is more difficult
04:32:03 <quicksilver> Peaker: wrong.
04:32:07 <slangan> quicksilver: you think two blank slates(as far as there are any) learn Haskell as easy as Python?
04:32:11 <quicksilver> Peaker: python requires you to learn how to program.
04:32:16 <quicksilver> Peaker: that is an extremely difficult skill
04:32:21 <quicksilver> harder than flying a space shuttle
04:32:28 <quicksilver> harder than playing the flute
04:32:30 <mux> haskell requires you to learn how to think, this is even harder ;-)
04:32:45 <Peaker> quicksilver: you don't have to program well to be productive, you can start writing shit code that gets some work done very quickly :)
04:32:53 <quicksilver> if you already know how to program in a python-like-language, then sure, python is easy.
04:32:55 <chessguy_work> hmm, i smell a troll
04:33:12 <Peaker> chessguy_work: me? I love Haskell, I just think its got a steep learning curve
04:33:19 <chessguy_work> no, not you, peaker
04:33:23 <pumpkin_> :)
04:33:28 <quicksilver> if you already know how to drive a subaru, then driving a toyota is easy.
04:33:34 <quicksilver> slangan: perhaps not, no.
04:33:44 <quicksilver> slangan: but I think they are far closer than peaker suggests.
04:33:51 * mux awaits for the godwin theorem to apply once again
04:34:00 * pumpkin_ generates all positive rationals using Omega
04:34:00 <slangan> pumpkin: problems that by design require mutable state aren't so natural in haskell. like?
04:34:11 <quicksilver> starting from a blank slate I think python will be easier than java, and I suspect haskell will lie somewhere in between.
04:34:13 <Peaker> quicksilver: I agree about that part -- the functional part is not the hard one to learn from scratch -- getting all the types right and parsing the error messages when you don't is going to be harder for a beginner than handling Python tracebacks
04:34:16 <quicksilver> it's a bit hard to prove :)
04:34:39 <pumpkin_> whee, just "proved" rationals are countable :P
04:34:42 <quicksilver> slangan: unfortunately these days people who start with blank slates are generally taught java.
04:34:57 <quicksilver> and if they have that background, they're going to find python quite a relief :)
04:35:02 <Peaker> quicksilver: some are still taught Scheme, but most that do end up hating it
04:35:06 <Peaker> (at least most I know of)
04:35:07 <quicksilver> chessguy_work: in some sense of troll, yes.
04:35:14 <Axman6> pl (\n -> 0 /= rem x n)
04:35:17 <Axman6> @pl (\n -> 0 /= rem x n)
04:35:18 <quicksilver> chessguy_work: I tend to exagerrate for rhetorical reasons.
04:35:18 <lambdabot> (0 /=) . rem x
04:35:18 <osfameron> I started with BBC Basic and LOGO.  Never did me any harm ;-)
04:35:21 <pumpkin_> slangan: algorithms that are designed to work "in-place" and such
04:35:24 <quicksilver> chessguy_work: if that annoys you, I apologise.
04:35:39 <mux> quicksilver: I think you will agree however that to most programmers that only know imperative languages, learning haskell has a steep learning curve
04:35:42 <chessguy_work> quicksilver, i'm not talking about you
04:35:45 <quicksilver> mux: definitely.
04:35:50 <pumpkin_> lol
04:35:55 * pumpkin_ acts defensive about chessguy_work
04:36:02 <chessguy_work> quicksilver, your thoughts are insightful as always
04:36:08 <solrize> python has a lot more creature comforts in its standard library and that helps a lot
04:36:31 <mux> haskell used to break my head fairly thoroughly
04:36:43 <mux> then again, I didn't have the nice "real world haskell" book when I started to learn it
04:36:48 <Philonous> mux: I think there is a third way - learn lambda calculus and see Haskell as an implementation. That has worked for me.
04:36:52 <luite> http://hpaste.org/13186 <- how can I make this faster? depending on how I profile, most time is spent in the shuffle or in the swapRandom function, so I have the feeling that the getRandomR may be a problem. I also have a java implementation that is more than 10x as fast, so some improvement should be possible ;)
04:36:56 <slangan> pumpkin: like quicksort?
04:36:58 <chessguy_work> in Russia, YOU break HASKELL's head
04:36:59 <mux> Philonous: I took the detour through TAPL
04:37:05 <solrize> i had to read a bunch of docs to figure out how to compute and print a list of values along with how much time it took to compute each value, that would have been a lot easier in python
04:37:06 <mux> it helped me a LOT to understand haskell better
04:37:11 <osfameron> do you think RWH works well as an introductory book?
04:37:27 <solrize> plus i had to understand the monad system to write that code cleanly
04:37:31 <chessguy_work> osfameron, i was impressed with how simple it starts, and yet how deep it goes
04:37:36 <Peaker> solrize: Wouldn't it be just as easy to do it in the IO monad?
04:37:37 <mux> osfameron: it seems to me it has a very slow and gentle pace, and it's well explained
04:38:13 <solrize> peaker it could ONLY be done in the io monad ;)  but the code was nicer with a separate action instead of writing it all in main
04:38:31 <solrize> and i used forM_ which takes some knowledge to even think of
04:38:34 <osfameron> it doesn't go over details at a tutorial pace though, some things are shown rather than explained, it seems.  (Though I'm only on my first preview skimread of the book so far)
04:39:00 <quicksilver> shown rather than explained works well for some people.
04:39:03 <quicksilver> learning styles differ.
04:39:10 <b_jonas> forM_ = reverse mapM_
04:39:10 <solrize> RWH is rather brisk paced, i understand the authors wanted it to be 300 pages and ended up with 700 but it's still quite fast moving
04:39:10 <quicksilver> the balance between show/explain is tricky.
04:39:12 <Peaker> solrize: timedAction = IO a -> IO (a, DeltaTime) ;  sequence $ map timedAction yourActions ?
04:39:19 <Peaker> solrize: s/=/::
04:39:22 <mux> b_jonas: you mean flip mapM_ ?
04:39:27 <b_jonas> flip, yeah
04:39:55 <Peaker> solrize: I agree Haskell takes a lot of knowledge (Haskell's learning curve is steep!) but once you're past it, I think there's little to nothing that should be easier in Python
04:39:55 <osfameron> quicksilver: good point.  And I guess the kind of person that orders "Real World ..." may be predisposed to show
04:39:59 <solrize> peaker, something like that, i did it a little differently, but the point is that any of those methods is either voodoo programmign or requires rather hard-won understanding of the type system.  monads are notoriously difficult for beginners.
04:40:04 <Peaker> solrize: I still use Python a bit, because its interactive REPL is far better than ghci
04:40:04 * pumpkin_ begins to believe Control.Monad.Omega can do anything
04:40:15 <b_jonas> and mapM_ is just mapM returning (), and mapM is like map but running effects head to tail order
04:40:33 <Peaker> solrize: yeah, totally difficult for beginners, I agree. But you said "easier in Python", not "easier for beginners in Python" :-)
04:40:50 <Peaker> @src mapM
04:40:51 <lambdabot> mapM f as = sequence (map f as)
04:41:12 <Peaker> so mapM = (sequence .) . map
04:41:15 <solrize> well, the context was beginners, but it's easier in python anyway, python has a time() function that gives you the current timestamp as a floating point number, haskell makes you convert between a bunch of weird types
04:41:25 <idnar> Peaker: in what way(s) is/are Python's REPL better than ghci?
04:41:41 <Peaker> idnar: It has not arbitrary limitations on what it can do (i.e can't define new types)
04:41:51 <Peaker> idnar: you can generally cut/paste from the REPL to a file
04:41:54 <luite> hm, there seems to be a faster random generator on hackage
04:42:02 <slangan> ghci doesnt nclude the whole haskell
04:42:05 <idnar> Peaker: that's more of a language thing and less of a REPL thing
04:42:20 <Peaker> solrize: I don't know the Haskell time libraries very well, but last I looked, I really liked how they were utterly unconfused about time zone issues (Python's libs inherit C's lib confusion about that)
04:42:20 <solrize> python has some decent debuggers
04:42:48 <solrize> peaker, that could be, i just wanted to time how long something took, and had to mess with UTCTime and TimeDiff or something like that
04:42:49 <Peaker> idnar: Why? ghci could allow me to sequence an action into main or define new stuff as in a file
04:43:00 <Peaker> @hoogle TimeDiff
04:43:00 <lambdabot> No results found
04:43:03 <Peaker> @hoogle TimeDelta
04:43:03 <lambdabot> No results found
04:43:07 <idnar> Peaker: yeah, but that would require a lot more fancy maneuvering
04:43:08 <Peaker> @hoogle getTime
04:43:08 <lambdabot> Data.Time.LocalTime getTimeZone :: UTCTime -> IO TimeZone
04:43:08 <slangan> I have been drifting towards Clojure quite  a lot lately but I still wish it had infix
04:43:19 <idnar> Peaker: whereas the Python REPL just has to execute statements, because everything in Python happens at runtime
04:43:25 <Axman6> Peaker: i think you're after Data.Time.Clock
04:43:54 <solrize> in python if you run the equivalent of maximum [1..1000000] it computes the obvious answer
04:43:58 <Axman6> Peaker: Data.Time.Clock.getCurrentTime and Data.Time.Clock.diffUTCTime
04:44:01 <Peaker> idnar: Well, I agree getting ghci right is probably harder than getting Python right
04:44:01 <solrize> in haskell it crashes with a stack overflow
04:44:13 <Peaker> @hoogle getCurrentTime
04:44:14 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
04:44:14 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
04:44:22 <luite> hm, that mersenne-random thing is ugly, everything is IO :(
04:44:25 <idnar> Peaker: I mean, essentially, ghci offers the same class of functionality as python's REPL; it's just that that's not "good enough" for Haskell coding
04:44:40 <Peaker> idnar: It doesn't let me define new types
04:44:48 <Peaker> idnar: except via ":load ..."
04:44:56 <Axman6> luite: seen dons' mersenne-twister thing? (i think that's what it was called)
04:45:13 <idnar> Peaker: you can't type declarations into the Python REPL either, it's just that Python doesn't have any declarations :P
04:45:13 <solrize> it would be good if there was an inferior-haskell-mode for emacs
04:45:17 <maltem_> @src maximum
04:45:17 <lambdabot> maximum [] = undefined
04:45:17 <lambdabot> maximum xs = foldl1 max xs
04:45:34 <luite> Axman6: yeah just installed it, he claimed it's 50 times faster than the standard generator, so I should be able to beat my java implementation with that ;)
04:45:44 <idnar> unless you count __future__, which the interactive interpreter does have some hacks to support
04:45:45 <Axman6> nice :()
04:45:47 <Axman6> :)*
04:45:50 <solrize> >>> global foo
04:45:50 <solrize> >>>
04:45:52 <solrize> works for me
04:46:14 <idnar> solrize: that doesn't do anything
04:46:17 <Peaker> idnar: I can type "class" declarations in Python, which are the "equivalent" if there is one, of Haskell types
04:46:22 <solrize> of course not, it's a declaration
04:46:25 <solrize> class is an assignment
04:46:32 <idnar> solrize: it's a declaration that does nothing
04:46:35 <luite> Axman6: the problem is that it basically requires my whole program to run in IO
04:46:42 <maltem_> > foldl1' max [1..1000000]
04:46:49 <Peaker> Why does UTCTime not have a Num instance?
04:46:51 <idnar> solrize: but okay, fair enough
04:46:53 <Axman6> luite: wasn;t it going to be doing that anyway?
04:46:54 <lambdabot>   1000000
04:46:57 <Peaker> oh, I guess timediff is a different type
04:46:58 <Axman6> Peaker: it does
04:47:01 <maltem_> solrize: ^^
04:47:02 <Axman6> i think
04:47:12 <solrize> > maximum [1..1000000]
04:47:14 <lambdabot>   * Exception: stack overflow
04:47:21 <mux> if you compile with optimlizations, you can just use maximum and it'll work
04:47:29 <maltem_> solrize: or wait, your point was something different, it seems :-/
04:47:30 <solrize> so much for the repl
04:47:32 <idnar> Peaker: sure, but in Haskell, type declarations aren't an expression evaluated at runtime
04:47:33 <luite> Axman6: well, at least I had many pure parts, using MonadRandom
04:47:34 <Asztal> I'm not sure why maximum doesn't use foldl1' :(
04:47:44 <Axman6> Peaker: my bad, you're right
04:48:09 <Peaker> idnar: I understand, but ghci is not exactly "runtime", its sort of a compile-time
04:48:12 <Peaker> idnar: at least it could be
04:48:30 <solrize> maltem_ my point is that haskell makes you wrap your head around very weird stuff to understand why things that obviously ought to work instead fail
04:48:43 <quicksilver> ghci does compile each expression (although only to bytecode) before running it.
04:48:48 <quicksilver> and can run compiled modules
04:48:58 <quicksilver> so in that sense, yes, ghci is compile-and-run-time
04:48:59 <maltem_> solrize: yeah I realized that when I had a look at the context of what you said
04:49:12 <solrize> np
04:49:14 <mux> solrize: those things only ought to work because we're used to strict languages
04:49:26 <mux> it's actually not that obvious that it should work otherwise
04:49:44 <Peaker> solrize: anyhow, getCurrentTime and diffUTCTime are straightforward.. The only disadvantage vs. Python's time lib is having to use "diffUTCTime" instead of a deceptive (-) which is oddly typed :)
04:50:18 <solrize> peaker, it's more cognitive load, having to read a bunch of docs to figure out how to use those functions
04:50:42 <Peaker> if we had a non-textual editor for Haskell, it could easily find the oddly-typed (-) in the UTC Time module namespace, when you typed (-) into the editor highlighting a UTC Time value, because it would hoogle that as the appropriately typed function with that name :)
04:50:50 <solrize> hee
04:50:52 <Peaker> solrize: I had to hoogle a bit, no doc reading :)
04:51:40 <Peaker> I'm thinking of abandoning FRP and writing a non-textual editor for Haskell imperatively in IO, because FRP libs seem not practical as of yet, and I hate to be stuck :-(
04:51:40 <idnar> Peaker: sure; all I'm really saying is that that requires a fairly different approach to what Python does
04:51:43 <chessguy_work> @bot
04:51:44 <lunabot>  :)
04:51:44 <lambdabot> :)
04:51:49 <chessguy_work> >>>
04:51:50 <Peaker> idnar: I agreed there
04:51:55 <chessguy_work> > >>
04:51:56 <lambdabot>   <no location info>: parse error on input `>>'
04:52:37 <idnar> Peaker: why is (-) deceptive?
04:52:40 <solrize> i wish there was a haskell to html converter that pretty printed your haskell code in a way that would let you see the inferred type of every expression by floating the mouse over it
04:52:47 <Peaker> idnar: You expect its type to be a -> a -> a
04:53:00 <Peaker> idnar: but in the case of subtracting times, its type is   Time->Time->TimeDiff
04:53:11 <mux> rather Num a => a -> a -> a
04:53:19 <idnar> Peaker: I don't expect set difference to be a -> a -> a either
04:53:22 <mux> a -> a -> a could only be const or flip onst
04:53:37 <solrize> and then in order to get the floating point value out of the timediff there's another conversion function that took looking up
04:53:40 <idnar> okay, in Haskell, you probably wouldn't want to call it (-) exactly, but something that suggests subtraction still seems appropriate
04:53:43 <solrize> @hoogle TimeDiff -> Float
04:53:44 <lambdabot> Warning: Unknown type TimeDiff
04:53:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:53:44 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:53:47 <Peaker> idnar: why not?
04:54:00 <Peaker> idnar: timeDiff does suggest (-)
04:54:26 <idnar> Peaker: that kind of "overloading" is somewhat awkward in Haskell, because you can't have multiple versions of the same operator in scope at once
04:54:28 <Peaker> funny it should match ($) but not id
04:55:00 <Peaker> idnar: well, either a Num instance makes sense or it doesn't. I guess if Num was split to smaller classes, it would allow nicer instances
04:55:03 <solrize> it would be a good project for someone to systematically go through the python library manual and reimplement every function in haskell
04:55:36 <Peaker> solrize: Starting with dir() of each type, probably
04:55:44 <idnar> Peaker: I don't think a Num instance makes sense for timestamps, but I do think that a time difference operator should closely resemble (-) :P
04:55:45 <Peaker> (Which will find the missing str.split very quickly)
04:55:51 <idnar> of course, there are two subtraction operators for time
04:55:51 <solrize> yeah
04:55:59 <Peaker> idnar: Does "diff" not closely resemble (-)?
04:56:04 <idnar> Time -> Time -> TimeDiff and Time -> TimeDiff -> Time
04:56:08 <idnar> Peaker: not really, no
04:56:37 <Peaker> solrize: Well, it can actually be named (-) in a different namespace, but that would kinda suck :)
04:56:40 <idnar> Peaker: I'm not saying it's a bad name, I'd just like an *operator*
04:56:40 <Peaker> oops
04:56:43 <Peaker> s/solrize/idnar
04:56:57 <solrize> it would also be real helpful if haskell allowed having multiple modules in one file
04:57:04 <idnar> but that's a fairly irrelevant cosmetic issue
04:57:22 <Peaker> idnar: I disagree, I think Haskell has too many, not too few, operators -- they might make code *slightly* more readable for very experienced readers, but they make it *far* more unreadable for non-experts
04:57:25 <Axman6> bah, i hate the people on project euler who solve stuff using J!
04:57:30 <Peaker> solrize: Why?
04:57:36 <mux> Axman6: haha, seconded
04:57:37 <b_jonas> Axman6: why?
04:57:41 <b_jonas> mux: why?
04:57:45 <mux> J looks like brainfuck to me.
04:57:48 <Axman6> because J makes no sense!
04:57:51 <solrize> peaker because haskell namespace gets too cluttered too fast
04:57:55 <idnar> J looks like Etc to me
04:58:00 <Axman6> f =: (*:@:] | +:@:([ * ])) p:@:<:
04:58:00 <Axman6> (+2:)^:(-.@>&10@^.~&10@f)^:_ ] 7001x
04:58:01 <b_jonas> that's stupid, brainfuck is really verbose
04:58:07 <Peaker> solrize: what's wrong with splitting into modules?
04:58:07 <slangan> http://hpaste.org/13187
04:58:08 <b_jonas> what's Etc?
04:58:15 <Axman6> that's the answer to #123
04:58:15 <mux> J looks like when I cat a binary file on my console
04:58:20 <slangan> how can http://hpaste.org/13187 have non-exhaustive pattern?
04:58:36 <idnar> b_jonas: http://c2.com/cgi-bin/wiki?EtcLanguage
04:58:40 <solrize> peaker i like having a reasonable amount of code in each file, not 100's of tiny files like in java
04:58:43 <Axman6> slangan: x:[]
04:58:44 <chessguy_work> @pl \a b -> m b && s a b
04:58:44 <lambdabot> liftM2 (&&) m . s
04:58:49 <Axman6> slangan: (x:[])*
04:59:02 <Axman6> or [x] is you prefer
04:59:27 <Peaker> solrize: I like having 100's of tiny files :)
04:59:41 <chessguy_work> @seen luqui
04:59:41 <lambdabot> I saw luqui leaving #haskell 2m 6d 22h 13m 9s ago, and .
04:59:44 <mux> slangan: you're handling the case when the list has at least two elements, and when it's empty, but not the ne where there is only one element
04:59:48 <Peaker> solrize: I have split screen in my editor and tiny files give me more viewing flexibility more easily
05:00:00 <Peaker> solrize: and it makes it more clear what can be grasped separately
05:00:02 <idnar> Peaker: I haven't seen anyone struggle with subtraction on times / time deltas in Python
05:00:13 <solrize> i suppose it's a matter of taste but tiny files = more clutter in my experience
05:00:31 <solrize> i like separate files for areas of the program that are conceptually separate
05:00:45 <idnar> Peaker: I agree with your general point to some extent, except I think the tradeoff is worth it
05:00:47 <Peaker> idnar: its easier to just use untyped (-) and wait till runtime to see if that's alright, at the expense of static/compiletime validation
05:01:03 <idnar> Peaker: okay, but it's not like (-^) or whatever is any harder to understand than (-)
05:01:12 <b_jonas> idnar: I see
05:01:22 <Peaker> idnar: But I think the extra "hardness" of using properly-typed (-) for each case, when you have hoogle, is worth it (virtually nil)
05:01:30 <Peaker> idnar: its a bit harder, but worth it
05:01:41 <idnar> Peaker: what?
05:01:44 <Peaker> idnar: Though I think (-^) suggests we have too many funny symbols to remember
05:01:47 <idnar> Peaker: I'm not even sure what we're talking about now
05:02:10 <idnar> Peaker: what I'm saying is that in Haskell, I wouldn't call it (-), because that would be a pain; but calling it something like (-^) is basically just as good
05:02:12 <solrize> also using very basic coding techniques like memoization needs weird contortions in haskell (there is a wiki page about some of them)
05:02:16 <Peaker> idnar: (-^) is only possible when (-) is not, so in Python they share the name which makes things a little easier to use - but harder to verify
05:02:34 <idnar> Peaker: I don't think (-^) is any harder to understand than (-), so it's pretty much the same thing as in Python
05:02:43 <slangan> how can I eval an expr?
05:02:43 <idnar> just different language styles
05:02:47 <chessguy_work> hey quicksilver, have you any thoughts about this? http://hpaste.org/13168
05:02:48 <Peaker> idnar: Its harder in the sense that the programmer has to remember more than one symbol
05:03:09 <idnar> Peaker: only slightly harder, though, because it's basically still a familiar symbol
05:03:24 <solrize> :t is
05:03:25 <lambdabot> Not in scope: `is'
05:03:26 <idnar> Peaker: even if you forgot that time subtraction was (-^), it's unlikely you'll have to go look it up if you see it used
05:03:26 <Peaker> idnar: that's what I said - its slightly harder, but the benefit is a more verifiable program
05:03:38 <idnar> Peaker: I'm not sure why we're arguing if we're in agreement
05:03:41 <chessguy_work> solrize that would be in the library i'm writing
05:03:45 <solrize> ic
05:03:46 <idnar> Peaker: maybe I need more coffee :)
05:03:51 <chessguy_work> solrize assuming i figure out the interface
05:03:54 <b_jonas> I'd prefer something like timeDiff
05:03:55 <Peaker> idnar: our disagreement is whether (-^) is better than "timeDiff".. I guess we can have both
05:04:03 <solrize> chessguy_work did you see the article on wadler's blog?
05:04:08 <idnar> Peaker: oh, well, I don't think it's a big deal in general
05:04:13 <chessguy_work> solrize i did
05:04:20 <b_jonas> short names like (-^) should be used for really general really abstract things like (>>>)
05:04:21 <Peaker> idnar: Note (-^) already has meaning in other libraries like vector subtract or stuff like that
05:04:24 <idnar> Peaker: but there's a reason we have operators in the first place; a + b + c is a lot easier to read than a `add` b `add` c
05:04:35 <chessguy_work> solrize i think that has more to do (mainly) with structural pattern-matching
05:04:45 <Peaker> idnar: Sure - but I agree with b_jonas.. Reserve operators to generic methods, not very specifically typed things
05:05:00 <chessguy_work> solrize, though i haven't given up on it yet
05:05:02 <idnar> well, isn't there some generalisation we could apply here?
05:05:06 <solrize> ic
05:05:08 <b_jonas> idnar: that's because normal addittion occurs a lot, even in complicated expressions
05:05:14 <Peaker> idnar: Perhaps, someone needs to find out what it is
05:05:18 <idnar> timestamps are surely not the only type of value that behaves this way
05:05:20 <b_jonas> idnar: timeDiff isn't like that
05:05:31 <hugo___> i have this "problem" :P like... i have erased my code.hs file... but ghci still has it loaded, how do i dump it again ?
05:05:32 <Peaker> b_jonas, idnar: And because (+) is a generic addition thing, not specific to any type
05:05:40 <hugo___> is it possible ? :(
05:06:04 <mib_zev9xghx> @seen kfish
05:06:04 <Peaker> hugo___: ext2/ext3 have undelete facilities.. ghci might be able to show you your types with :info, I don't think it can show code sources
05:06:05 <lambdabot> Last time I saw kfish was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #funtoo, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
05:06:05 <lambdabot> haskell-blah, #haskell-books, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #
05:06:05 <lambdabot> haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 13d 14h 47m 46s ago, and .
05:06:13 <idnar> foo :: a -> a -> b; bar :: a -> b -> a
05:06:17 <hugo___> Peaker: i overwrote it
05:06:22 <idnar> pity there's no way to search for a type class like that
05:06:29 <hugo___> it was vim
05:06:31 <hugo___> :(
05:06:33 <hugo___> bahhh
05:06:36 <hugo___> vim sucks at this
05:06:36 <Peaker> hugo___: vim has no undo buffer?
05:06:44 <hugo___> nops, it lost it somehow
05:06:53 <hugo___> i did a 'dd' and then a 'p'
05:07:15 <b_jonas> so can I rebuild just the haddock docs of all packages in ghc and ghc-extralibs, without rebuilding the source??
05:07:25 <hugo___> then it was all unaligned, and i did a 'u' and :set paste, and then when i did 'p' again it wasn't on the buffer
05:07:31 <Peaker> idnar: that is not yet meaningful enough to be a type-class, you need to give meaning to those functions
05:07:32 <hugo___> bahhh
05:07:32 <hugo___> :(
05:07:45 <idnar> Peaker: I just want to search for a typeclass with methods matching those signatures
05:07:58 <Peaker> hugo___: emacs has undo that can go _anywhere_ in history (as long as memory allows)
05:08:04 <idnar> Peaker: although I suspect I might not find anything anyway
05:08:05 <hugo___> BAAAAAAAAAAHHHHHHHHHHHHHHH
05:08:07 <Peaker> hugo___: I don't know if vim has the same
05:08:07 <hugo___> i hate this :(
05:08:30 <hugo___> i guess ill go to lunch, and try to build it again from scratch
05:08:30 <SamB_XP_> ah, is that why they call it 800 megs and still swapping
05:08:32 <Peaker> idnar: a 2-parameter type-class, or is a/b the one param?
05:08:40 <Peaker> SamB_XP: 8-megs :)
05:08:53 <SamB_XP> Peaker: I updated it to fit modern hardware
05:08:53 <idnar> Peaker: 2-param, I suppose
05:08:54 <Peaker> SamB_XP: the limit on the undo history size is configurable, too
05:08:55 <b_jonas> hugo___: is there a backup file the editor saves?
05:09:10 <idnar> Peaker: I'm thinking this is some kind of vector operation
05:09:12 <SamB_XP> and s/still/constantly/
05:09:23 <idnar> Peaker: except vectors are symmetric
05:09:30 <Peaker> idnar: I think it matches a type-class I was thinking about the other month -- of delta/differential computations
05:09:42 <SamB_XP> Peaker: oh, so you have to ANTICIPATE the need to undu arbitrarily
05:10:07 <Peaker> idnar: except my class did not necessarily allow computing the diff between two existing values (only generating a diff and applying it on values)
05:10:09 <idnar> timestamps are "absolute", timediffs are "relative"; and you can do absolute + relative, absolute - relative, and absolute - absolute (but not absolute + absolute)
05:10:26 <Peaker> SamB_XP: with today's hardware, setting 5 MB undo buffer is probably enough to avoid most tears
05:10:38 <b_jonas> or should I just reinstall that one package (regex-compat)?
05:10:58 <Peaker> idnar: consider: class Diff t d where computeDiff :: t -> t -> d ; applyDiff :: t -> d -> t ; negateDiff :: d -> d
05:11:00 <solrize> see, if you want to find the midpoint between two timestamps, (absolute+absolute)/2 seems perfectly legit
05:11:13 <SamB_XP> idnar: just like pointer arithmatic, yes
05:11:43 <idnar> SamB_XP: oh hey, yeah, didn't think of that one
05:11:46 <Peaker> idnar: then you can have subtractDiff :: Diff t d => t -> d -> t ; subtractDiff v d = applyDiff (negateDiff d)
05:11:46 <b_jonas> or temperatures
05:11:57 <b_jonas> celsius temperatures that is
05:12:25 <Peaker> idnar: you've got yourself an interesting type-class then :-)
05:12:29 <Peaker> idnar: and operators are now possible...
05:12:37 <slangan> I have a string "12+3+4" that I want to evaluate, how can I do that?
05:12:38 <ozy`> @pl (\n -> 0 /= rem x n)
05:12:39 <lambdabot> (0 /=) . rem x
05:12:50 * SamB_XP decides to add a keyboard layout in Control Panel now that he's figured out how ;-)
05:12:51 <idnar> Peaker: I think I'd prefer a name like Offset, I guess
05:13:05 <idnar> Peaker: but yeah
05:13:07 <Peaker> idnar: I think Offset is ambiguous, is it a diff or an abs?
05:13:27 <chessguy_work> slangan, there's no built in way to do it
05:13:29 <idnar> "Diff" makes me think of /usr/bin/diff
05:13:38 <Peaker> idnar: I guess those are diffs, and what I had was Delta.  Can have Diff extend Delta to add computeDiff (deltas cannot necessarily be computed from "abs" values)
05:13:42 <Peaker> idnar: indeed!
05:13:54 <Axman6> ozy`: is it a coincidence that i @pl'd that exact same thing a few mins ago?
05:13:59 <idnar> but negateDiff doesn't make any sense in that context
05:14:05 <Peaker> idnar: because file text is an absolute thing, and the /usr/bin/diff is the relation between two absolutes
05:14:09 <Peaker> idnar: sure it does
05:14:15 <Peaker> idnar: making a reverse patch from a patch
05:14:15 <slangan> chessguy_work: so to write a proglqng in Haskell requires making up complete rules for arithmetic?
05:14:24 <slangan> can I use Data.Dynamic?
05:14:26 <quicksilver> slangan: haskell doesn't come with a built-in "eval"
05:14:27 <ozy`> Axman6: no. I saw it as the last thing in my window before I disconnected and wanted to know the answer :p
05:14:36 <idnar> Peaker: well, I suppose
05:14:37 <chessguy_work> slangan, what the heck is proglqng/
05:14:39 <Peaker> idnar: the only issue is that /usr/bin/diffs are limited in what they can be applied to
05:14:39 <quicksilver> slangan: you can try "mueval" or "plugins"
05:14:50 <quicksilver> (which are both ways of hooking into ghc at runtime)
05:14:51 <Axman6> ozy`: ah, ha :P
05:14:56 <idnar> Peaker: but it's not discrete
05:15:03 <Peaker> idnar: why not?
05:15:04 <quicksilver> or you can write your own parser and evaluator :)
05:15:08 <Peaker> idnar: it can be discrete
05:15:14 <Saizan> more hint than mueval
05:15:18 <idnar> that kind of diff represents "changes", whereas I'm trying to represent "displacement" or something
05:15:40 <idnar> if you diff two dates, you don't get a duration of time
05:16:00 <idnar> and you can't apply a textual diff to arbitrary text
05:16:14 <idnar> whereas you can add a time delta to any arbitrary timestamp
05:16:31 <slangan> where is mueval?
05:16:32 <Peaker> idnar: yeah, I mentioned that, diffs can't always be applied -- that's the main difference
05:16:39 <Peaker> idnar: but why can't I diff two dates to get a time duration?
05:16:46 <SamB_XP> , 1
05:16:52 <idnar> Peaker: well, you can, but that's not what /usr/bin/diff would do
05:16:53 <lunabot>  1
05:17:12 <chessguy_work> slangan, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
05:17:13 <SamB_XP> slangan: oh, the thing lambdabot is using ?
05:17:15 <Peaker> idnar: patches match that type-class, even if they have some rules about when you're allowed to use them
05:17:18 <quicksilver> slangan: mueval, hint, plugins and more are on http://hackage.haskell.org/packages/archive/pkg-list.html
05:17:21 <Peaker> idnar: (beyond the types)
05:17:24 <slangan> doesnt cabal install come with ghc-6.10.1?
05:17:25 <SamB_XP> Peaker: do they ?
05:17:31 <SamB_XP> I don't see how they match ...
05:17:31 <quicksilver> no, it doesn't.
05:17:33 <idnar> Peaker: they match the types, but I don't think they conceptually match
05:17:53 <Peaker> SamB_XP: Well, (/) with 0 is disallowed, but the type system can't catch that
05:18:00 <idnar> Peaker: the extra rules are a symptom of that conceptual mismatch
05:18:03 <Peaker> SamB_XP: s/disallowed/yields funny result
05:18:09 <Peaker> SamB_XP: the same can be said about wrong diff application
05:18:10 <SamB_XP> > 1 / 0
05:18:12 <lambdabot>   Infinity
05:18:12 <quicksilver> Saizan: is it your thought that 'hint' is the easiest one to get working?
05:18:22 <SamB_XP> > 1 / 0 :: Rational
05:18:23 <lambdabot>   * Exception: Ratio.%: zero denominator
05:18:36 <Peaker> applyDiff wrongDiff wrongInput --> InvalidText
05:18:40 <Axman6> > 1 % 0
05:18:42 <lambdabot>   * Exception: Ratio.%: zero denominator
05:18:49 <SamB_XP> Peaker: well, it just seems like getting diffs to apply would be more of an exception than a rule ;-P
05:18:54 <idnar> Peaker: (++) matches the type of (+), but that doesn't mean we should define a Num instance for lists or sets or whatever
05:18:55 <Axman6> > 1 / 0 :: CReal
05:19:10 <lambdabot>   thread killed
05:19:12 <Peaker> idnar: (++) doesn't match the laws of Num
05:19:19 <Peaker> idnar: But applyPatch does match its laws
05:19:19 <idnar> Peaker: which laws?
05:19:28 <Peaker> idnar: cummutativity of (+) for example
05:19:49 <idnar> Peaker: okay, what about sets?
05:19:53 <SamB_XP> darcs' "algebra" has loads of exceptions
05:19:56 <Saizan> quicksilver: yeah, since mueval uses hint anyway but adds some cruft for the sake of security, however there isn't a release of hint for 6.10.1
05:20:23 <Peaker> idnar: It could work if you disallow (-) when its not a superset/etc
05:20:32 <b_jonas> quicksilver: well, I have no idea how I can rebuild and install the haddock docs for the core packages with the newer haddock,
05:20:47 <b_jonas> and it seems that some of the packages can only be built inside the ghc tree
05:20:50 <quicksilver> Saizan: Ah right I didn't know that.
05:21:02 <idnar> Peaker: well, yeah, you could do it; I'm just not sure it would make sense
05:21:02 <quicksilver> b_jonas: I'm afraid I can't help ou there. I know nothing about how this is supposed to work :-(
05:21:10 <idnar> Peaker: or rather, I'm not sure it would be a good idea
05:21:36 <quicksilver> Saizan: I think "interpret" requiring a witness is pretty bogus. But that's not all that important.
05:21:41 <b_jonas> quicksilver: ok, thanks anyway
05:21:54 <idnar> Peaker: anyhow, I think the laws I would have in mind for Delta or Diff would rule out /usr/bin/diff-style textual diffs
05:21:55 <Peaker> idnar: well, (+) between sets will only work if the intersection is empty, in that case, but then things like (*) become completely meaningless
05:22:02 <b_jonas> I guess I'll write a bug report about both the build error and the doc build error, and meanwhile I'll use the online docs
05:22:26 <Peaker> idnar: I disagree, I think a TimeDiff and a Patch are conceptually similar, even if continuous/promiscuous  vs  discrete
05:22:36 <idnar> Peaker: you should be able to add diffs, for one thing
05:22:41 <Peaker> idnar: and indeed you can
05:22:52 <Peaker> idnar: you can build a patch from multiple patches
05:22:57 <Peaker> idnar: you can negate a patch
05:22:58 <idnar> Peaker: how do you implement that?
05:23:10 <Peaker> idnar: by combining the differences
05:23:24 <idnar> yeah, but how?
05:23:29 <b_jonas> let me see if it works
05:23:40 <idnar> I can maybe imagine doing it for darcs-style patches
05:23:49 <quicksilver> Peaker: it only makes sense if you can prove they're associative
05:23:51 <quicksilver> I'm not sure they are
05:23:56 <Peaker> idnar: If lines are added in independent locations - just add both. If lines are removed in a dependent location, just remove that from the diff, etc
05:24:02 <quicksilver> I think diffs are only valid in context
05:24:03 <slangan> wow i neeed to install a lot of other shit
05:24:11 <slangan> blah f haskell for this
05:24:11 <Peaker> quicksilver: I think patches are definitely associative
05:24:21 <idnar> they're not commutative
05:24:25 <Saizan> quicksilver: i agree, but some people seems to like witnesses more than return-type dispatch
05:24:32 <quicksilver> idnar: that's not necessary fortunately :)
05:24:37 <Saizan> like in HAppS
05:24:41 <idnar> I suppose
05:24:55 <Peaker> idnar: For the type-class we mentioned, its not necessary, though TimeDiff could additionally be Num while patch couldn't
05:25:21 <quicksilver> Saizan: obviously you can build one from the other, but to me it's more natural to use return-type dispatch as primitive. asTypeOf is in the prelude, after all...
05:25:42 <Peaker> @type asTypeOf
05:25:42 <quicksilver> @index asTypeOf
05:25:43 <lambdabot> forall a. a -> a -> a
05:25:43 <lambdabot> Prelude
05:25:57 <idnar> (time `applyDiff` d1) `applyDiff` d2 = time `applyDiff` (d1 `addDiff` d2)
05:26:16 <quicksilver> idnar: yes, time differences are definitely associative.
05:26:26 <quicksilver> idnar: the question for textual differences is less obvious to me.
05:26:32 <idnar> quicksilver: yeah
05:26:42 <quicksilver> I think it probably depends how you represent them.
05:26:57 <quicksilver> unix-style diff patches are not really reliable things.
05:27:03 <quicksilver> I don't think they're cleanly associative.
05:27:10 <SamB_XP> not a bit ;-P
05:27:19 <b_jonas> how do you format an integer to hexadecimal?
05:27:22 <quicksilver> Some abstraction of text diffs could be in principle
05:27:28 <quicksilver> > showHex 12345 ""
05:27:30 <lambdabot>   "3039"
05:27:40 <idnar> the number of inputs that produce an "invalid" result is also somewhat distasteful
05:27:48 <b_jonas> Numeric.showHex, ok, thanks
05:27:59 <idnar> it's like (+) only working on prime numbers, or something
05:28:57 <mapreduce> @src showHex
05:28:57 <lambdabot> Source not found. stty: unknown mode: doofus
05:29:22 <SamB_XP> idnar: that would be *really* silly
05:29:38 <SamB_XP> how many pairs of primes even add up to other primes ?
05:29:42 <idnar> SamB_XP: exactly :P
05:29:42 <b_jonas> great, encoding seems to work (at least some of it) after changing Control.Exception to Control.OldException
05:29:47 <quicksilver> \o/
05:29:55 <quicksilver> b_jonas: been a long morning's yak-shaving for you.
05:30:13 <SamB_XP> how do you get down off a yak ?
05:30:31 <idnar> SamB_XP: well, okay, the answer is "none", so perhaps my analogy was a bit extreme
05:30:48 <SamB_XP> I don't think so
05:30:51 <SamB_XP> > 2 + 3
05:30:53 <lambdabot>   5
05:31:12 <idnar> oh, right, forgot about 2
05:31:12 <SamB_XP> > 2 + 5
05:31:14 <lambdabot>   7
05:31:35 <SamB_XP> but I guess 2 has to be one of the two, doesn't it ?
05:31:39 <idnar> yeah
05:31:55 <idnar> or can negative numbers be prime?
05:32:00 <quicksilver> unless there's another secret even prime they're not telling us about.
05:32:14 <quicksilver> maybe the NSA use an even prime for unbreakable encryption
05:32:23 <vixey> odd + odd = even
05:32:26 <SamB_XP> quicksilver: you know that's not possible
05:32:30 <vixey> gosh......... I'm stupid today
05:32:32 <idnar> hahaha
05:32:37 <quicksilver> SamB_XP: that's what they want you to think ;)
05:32:45 <ziman> :D
05:32:59 <SamB_XP> the other "even prime" would be divisible by 2, yes ?
05:33:15 <idnar> SamB_XP: no, that's why it's a secret
05:33:17 <SamB_XP> but that would make it non-prime
05:33:22 <idnar> SamB_XP: it's an even number that's not divisible by 2!
05:33:26 <quicksilver> SamB_XP: it may have escaped your attention but I'm not being entirely serious here.
05:33:33 <lilac> the other non-odd prime is 1 + i
05:33:34 <lilac> :)
05:33:44 <lilac> sorry, which field were we working in?
05:33:46 <quicksilver> Although if you search for "how many even primes are there" on google, you just get a picture of a black helicopter.
05:33:49 <idnar> lilac: you mean 1 + j, right?
05:33:50 <SamB_XP> quicksilver: what, I'm not allowed to disprove jokes anymore ?
05:34:06 <lilac> idnar: *gasp* are you an /engineer/ or something? :)
05:34:23 <idnar> lilac: nah, I just hang out with the wrong crowd
05:34:33 <idnar> quicksilver: man, I actually had to go check to see if that was a joke or not
05:34:43 <SamB_XP> heh
05:34:47 <lilac> idnar: the kind of crowd that uses i for current, or the kind of crowd that likes quarternions? :)
05:34:59 <idnar> lilac: both
05:35:07 <lilac> that must be confusing
05:35:13 <quicksilver> there is a crowd that likes quarternions?
05:35:14 <quicksilver> wow.
05:35:18 <quicksilver> I'd have thought a 'huddle' at most.
05:35:30 <mapreduce> There is a crowd who can spell quaternions.
05:35:31 <quicksilver> there evidently isn't a crowd who can spell them, round here ;)
05:35:35 <mapreduce> :)
05:35:39 <idnar> although I guess I haven't seen any of the quaternion guys for a while
05:35:41 <lilac> indeed :)
05:35:59 <lilac> idnar: didn't the matrix-lovers hunt them to extinction a while back?
05:36:01 <Peaker> idnar: Maybe we can have a more general type like Category to represent those diffs and then we can get the type system to verify when its allowed to use a patch (maybe), and trivialize it for the time-diff case
05:36:03 <idnar> I recall someone trying to come up with a calculus for quaternions
05:36:28 <SamB_XP> lilac: the matrix-lovers forgot to burn the sacred texts
05:37:01 <lilac> SamB_XP: they tried, but they were uninvertible
05:37:09 <SamB_XP> what ???
05:37:24 <idnar> haha
05:37:58 <lilac> SamB_XP: making sense is overrated
05:38:43 <Peaker> I wonder how to write sequ
05:38:48 <Peaker> I wonder how to write mapM via (~>) style
05:38:56 <Peaker> @src mapM
05:38:56 <lambdabot> mapM f as = sequence (map f as)
05:39:34 <quicksilver> what is ~> style?
05:39:55 <Peaker> well, argument f = (.f) ;  result f = (f.) ; f ~> g = result f . argument g
05:40:34 <Peaker> (f ~> g ~> h ~> id) func defines:  \x y z -> func (f x) (g y) (h z)
05:40:35 <vixey> @let argument f = (.f)
05:40:36 <lambdabot>  <local>:5:0:
05:40:36 <lambdabot>      Multiple declarations of `L.argument'
05:40:36 <lambdabot>      Declared at: <l...
05:40:50 <Peaker> @type argument
05:40:52 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
05:40:54 <Peaker> @type result
05:40:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:41:16 <vixey> result = (.); argument = flip (.)
05:41:24 <Peaker> yeah
05:41:33 <Peaker> or result = fmap ; or result = (>>>)
05:41:37 <Peaker> oops, flipped
05:41:55 <vixey> f ~> g = (<<< f) . (g >>>) ?
05:42:04 <b_jonas> ~> as in arrows?
05:42:29 <Peaker> vixey: f ~> g = (f.) . (.g)
05:42:50 <Saizan> ?type \f g -> (f.) . (.g)
05:42:51 <b_jonas> @unpl (f.) . (.g)
05:42:51 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
05:42:51 <lambdabot> (\ e j -> f (e (g j)))
05:43:14 <Peaker> yeah, it means: apply g to the argument, then the function, then f to the result
05:43:20 <Peaker> which is why its read:  result f . argument g
05:43:28 <mbz> @src (~>)
05:43:29 <lambdabot> Source not found.
05:43:45 <b_jonas> I see
05:44:00 <Peaker> http://matt.immute.net/content/pointless-fun
05:44:11 <Peaker> its hellige's work
05:45:00 <Peaker> with ($.) = flip ($) ; we have    func $. (f ~> g ~> h ~> id)  allowing us to "wrap" func such that we apply stuff to each of its arguments
05:45:12 <Peaker> (Can't define ~> with lambdabot because it does not seem to have fixity declarations)
05:45:17 <Peaker> (need rassoc)
05:45:50 <b_jonas> @rassoc 0 ~>
05:45:50 <lambdabot> Unknown command, try @list
05:46:05 <Peaker> @let ($.) = flip ($)
05:46:06 <lambdabot>  Defined.
05:46:10 <b_jonas> @let rassoc 0 ~>; ~> = id
05:46:10 <lambdabot>   Parse error
05:46:21 <b_jonas> @let rassoc 0 ~>; (~>) = id
05:46:22 <lambdabot>   Parse error
05:46:32 <Peaker> @let g <~ f = result f . argument g
05:46:33 <lambdabot>  Defined.
05:46:42 <idnar> rassoc?
05:46:50 <b_jonas> @let infixr 0 ~>; (~>) = id
05:46:51 <lambdabot>  <local>:7:13:
05:46:51 <lambdabot>      Multiple declarations of `L.~>'
05:46:51 <lambdabot>      Declared at: <local>...
05:46:57 <Peaker> @type (id <~ id <~ map) sequence
05:46:58 <lambdabot>     Couldn't match expected type `a -> c1'
05:46:58 <lambdabot>            against inferred type `[m a1]'
05:46:58 <lambdabot>     Probable cause: `sequence' is applied to too many arguments
05:47:02 <b_jonas> @let infixr 0 ~~>; (~~>) = id
05:47:03 <lambdabot>  Defined.
05:47:14 <Peaker> @undefine (~>)
05:47:31 <Peaker> @let f ~> g = result f . argument g
05:47:32 <lambdabot>  <local>:1:9: Not in scope: `result'
05:47:32 <lambdabot>  
05:47:32 <lambdabot>  <local>:1:20: Not in scope: `argument'
05:47:32 <b_jonas> @undef
05:47:39 <idnar> undef undefines everything
05:47:43 <Peaker> Ouch!
05:47:52 <idnar> it doesn't take any args :P
05:47:57 <Peaker> @let result f = (f.) ; argument g = (.g)
05:47:58 <lambdabot>  Defined.
05:48:04 <b_jonas> Peaker: just imagine it having to track definitions that depend on it
05:48:19 <lilac> b_jonas: sounds pretty easy tbh
05:48:22 <Peaker> b_jonas: doesn't sound too terrible
05:48:26 <idnar> haha
05:48:35 <Peaker> @let infixr 2 ~> ; f ~> g = result f . argument g
05:48:36 <lambdabot>  Defined.
05:48:42 <b_jonas> lambdabot doesn't actually understand your definitions
05:48:46 <Peaker> @let ($.) = flip ($)
05:48:47 <lambdabot>  Defined.
05:49:09 <b_jonas> it just tries to add compile them with ghc and if that succeeds it adds them to the list of stuff to prepend to every eval
05:49:14 <b_jonas> it doesn't understand what names you define
05:49:25 <lilac> b_jonas: at the point when you give it a new definition, it can figure out which other defs it depends on by trying removing some of them.
05:49:31 <b_jonas> @let (fooa, foob) | True = (2, 4)
05:49:32 <lambdabot>  Defined.
05:49:42 <b_jonas> > foob
05:49:44 <lambdabot>   4
05:49:49 <Peaker> @type compare $. (length ~> length ~> id)
05:49:51 <lambdabot>     Couldn't match expected type `(a -> Int) -> Ordering'
05:49:51 <lambdabot>            against inferred type `[a1]'
05:49:51 <lambdabot>     Probable cause: `~>' is applied to too few arguments
05:50:03 <Peaker> @type compare $. (length ~> (length ~> id))
05:50:05 <lambdabot>     Couldn't match expected type `(a -> Int) -> Ordering'
05:50:05 <lambdabot>            against inferred type `[a1]'
05:50:05 <lambdabot>     Probable cause: `~>' is applied to too few arguments
05:50:08 <Peaker> @type (length ~> (length ~> id))
05:50:10 <lambdabot> forall a a1 a2. ((a2 -> Int) -> [a]) -> (a2 -> [a1]) -> Int
05:50:14 <b_jonas> lilac: heh
05:50:23 <vixey> :t comparing length
05:50:25 <lambdabot> forall a. [a] -> [a] -> Ordering
05:50:35 <Peaker> @type (length ~> id)
05:50:36 <lambdabot> forall a a1. (a1 -> [a]) -> a1 -> Int
05:50:40 <b_jonas> lilac: it still has to parse code to know which definition defines the name you give
05:51:09 <b_jonas> or maybe it could remove definitions until 'let _ = yourname' gives an error
05:53:03 <quicksilver> quadratic way to solve the problem though
05:53:14 <quicksilver> probably doesn't matter for the small number of defns typically in L.hs
05:53:31 <quicksilver> might be better just to use something which can parse haskell + build a dependency tree :)
05:54:06 <Peaker> it could just remove the definition, see which definitions no longer compile and remove them :)
05:55:47 <lilac> it could provide some way to dump the definitions, with line numbers, and allow you to remove numbered lines
05:57:01 <lilac> or it could allow names to shadow older names by wrapping the whole thing in a big do-block, ghci-style
05:58:35 <Peaker> ok, I had it wrong:
05:58:38 <Peaker> @let result = (.) ; argument = flip (.) ; infixr 2 ~> ; f ~> g = argument f . result g
05:58:39 <lambdabot>  Defined.
05:58:42 <Peaker> @type (length ~> length ~> id)
05:58:44 <lambdabot> forall a a1 b. (Int -> Int -> b) -> [a] -> [a1] -> b
05:58:58 <Peaker> @type (length ~> length ~> id) comparing
05:58:59 <lambdabot>     Couldn't match expected type `Int' against inferred type `b -> a'
05:58:59 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
05:58:59 <lambdabot>     In the first argument of `(length ~> length ~> id)', namely
05:59:09 <Peaker> @type (length ~> length ~> id) compare
05:59:10 <lambdabot> forall a a1. [a] -> [a1] -> Ordering
05:59:22 <Peaker> (meaning, apply length on the first 2 args, and id on the result)
05:59:25 <Peaker> pretty neat :)
06:00:05 * quicksilver is slightly surprised that definition generalised to 2-arg functions.
06:00:18 <quicksilver> type systems are occasionally neater than I expect :)
06:00:48 <lilac> it makes sense though; you're applying ~> to the result of the outer function, which just happens to be a function
06:01:16 <vixey> @type (length ~> length ~> length ~> id) (\x y z -> x + y + z)
06:01:17 <lambdabot> forall a a1 a2. [a] -> [a1] -> [a2] -> Int
06:01:19 <quicksilver> :t (length ~> head ~> tail ~> fmap)
06:01:20 <lambdabot> forall a a1 a2 a3 b (f :: * -> *). (Functor f) => (Int -> a1 -> [a2] -> a3 -> b) -> [a] -> [a1] -> [a2] -> f a3 -> f b
06:01:32 <lilac> @type (length ~> argument length) comparing
06:01:34 <b_jonas> @info $.
06:01:34 <lambdabot>     Couldn't match expected type `Int' against inferred type `b -> a'
06:01:34 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
06:01:34 <lambdabot>     In the first argument of `(length ~> argument length)', namely
06:01:34 <lambdabot> ($.)
06:01:38 <lilac> @type (length ~> argument length) compare
06:01:40 <lambdabot> forall a a1. [a] -> [a1] -> Ordering
06:01:41 <vixey> @type (length ~> length ~> length) (\x y z -> x + y + z)
06:01:43 <lambdabot>     The lambda expression `\ x y z -> x + y + z' has three arguments,
06:01:43 <lambdabot>     but its type `Int -> Int -> [a]' has only two
06:01:43 <lambdabot>     In the first argument of `(length ~> length ~> length)', namely
06:01:44 <b_jonas> @info ($.)
06:01:45 <lambdabot> ($.)
06:01:49 <b_jonas> @type ($.)
06:01:51 <lambdabot> Not in scope: `$.'
06:01:55 <b_jonas> @src ($.)
06:01:55 <lambdabot> Source not found. My pet ferret can type better than you!
06:02:00 <Peaker> vixey: you're applying length on the result there, so your function has to return a list
06:02:14 <Peaker> vixey: (length ~> length ~> length) means: apply length to each of the 2 args, and then on the result
06:02:22 <lilac> @type length ~> fmap length $ compare
06:02:24 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Ordering'
06:02:24 <lambdabot>       Expected type: Int -> Int -> [a]
06:02:24 <lambdabot>       Inferred type: Int -> Int -> Ordering
06:02:24 <b_jonas> ah, ($.) = flip ($)
06:02:31 <b_jonas> I see
06:02:56 <Peaker> @type (length ~> length ~> length) (\x y -> repeat x 1 ++ repeat y 2)
06:02:57 <lambdabot>     Couldn't match expected type `t -> [a]'
06:02:57 <lambdabot>            against inferred type `[Int]'
06:02:57 <lambdabot>     In the first argument of `(++)', namely `repeat x 1'
06:03:03 <lilac> @hoogle (Cofunctor f) => (a -> b) -> f b -> f a
06:03:04 <lambdabot> Warning: Unknown class Cofunctor
06:03:04 <lambdabot> Distribution.ParseUtils liftField :: (b -> a) -> (a -> b -> b) -> FieldDescr a -> FieldDescr b
06:03:04 <lambdabot> Distribution.Simple.Command liftOption :: (b -> a) -> (a -> b -> b) -> OptionField a -> OptionField b
06:03:06 <Peaker> > repeat 5 1
06:03:07 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
06:03:10 <Peaker> > replicate 5 1
06:03:11 <lambdabot>   [1,1,1,1,1]
06:03:17 <Peaker> @type (length ~> length ~> length) (\x y -> replicate x 1 ++ replicate y 2)
06:03:18 <lambdabot> forall a a1. [a] -> [a1] -> Int
06:03:32 <Peaker> > (length ~> length ~> length) (\x y -> replicate x 1 ++ replicate y 2) [1..3] [1..4]
06:03:34 <lambdabot>   7
06:03:44 <Peaker> > (length ~> length ~> id) (\x y -> replicate x 1 ++ replicate y 2) [1..3] [1..4]
06:03:46 <lambdabot>   [1,1,1,2,2,2,2]
06:03:50 <Peaker> cool ;-)
06:06:48 <baaba> :t comparing
06:06:49 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:06:56 <Peaker> @src comparing
06:06:56 <lambdabot> Source not found.
06:07:10 <Peaker> now I wonder how to define mapM using that style
06:07:35 <baaba> is it possible to express that such that if i have for example lsta :: [a], lstb :: [b], i could call comparing length lsta lstb?
06:07:40 <vixey> @src mapM
06:07:40 <lambdabot> mapM f as = sequence (map f as)
06:07:47 <baaba> express the type i mean
06:08:17 <quicksilver> baaba: yes, that's exactly what comparing means
06:08:21 <quicksilver> :t comparing length
06:08:22 <lambdabot> forall a. [a] -> [a] -> Ordering
06:08:29 <quicksilver> baaba: not quite sure what your question is?
06:09:29 <baaba> so i could call comparing length ([5] :: [Int]) ([5.0] :: [Double]) ?
06:09:34 <jaj> http://hop.perl.plover.com/
06:09:43 <baaba> > comparing length ([5] :: [Int]) ([5.0] :: [Double])
06:09:44 <lambdabot>   Couldn't match expected type `Int' against inferred type `Double'
06:09:58 <quicksilver> baaba: oh, sorry, I didn't read carefully enough.
06:10:11 <vixey> @src comparingn
06:10:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:10:14 <vixey> @src comparing
06:10:14 <lambdabot> Source not found. :(
06:10:18 <quicksilver> baaba: no, because there is a sense in which polymorphism isn't first class in haskell.
06:10:22 <vixey> @src compare`on`length
06:10:22 <lambdabot> Source not found. Just try something else.
06:10:28 <baaba> ah okay then
06:10:28 <vixey> :t compare`on`length
06:10:29 <lambdabot> forall a. [a] -> [a] -> Ordering
06:10:39 <b_jonas> vixey: same thing
06:10:40 <vixey> :t (\x y -> compare (length x) (length y))
06:10:40 <quicksilver> baaba: by passing 'length' to comparing, you restrict it to be instantiated at a single type.
06:10:41 <lambdabot> forall a a1. [a] -> [a1] -> Ordering
06:10:49 <idnar> you could implement that with some extensions, right?
06:10:55 <quicksilver> parameters are monomorphic
06:11:04 <quicksilver> idnar: yes, you can express it as a higher rank type
06:11:06 <b_jonas> you can't pass a polymorphic length to a function without the higher-rank types extensions
06:12:55 <quicksilver> although you'll struggle to make a general higher order version of comparing
06:13:20 <quicksilver> you want to say "anything which unifies both with a -> c and b -> c"
06:13:41 <quicksilver> (in the above example a == [e], b == [f] and c == Int)
06:13:47 <quicksilver> and I meant 'rank' not 'order', sorry.
06:14:28 <quicksilver> I think there is research on type systems which can infer exotic higher rank unifiers like this, but I don't know anything about them.
06:14:33 <b_jonas> what if you just passed length twice?
06:14:35 <vixey> :t let on' (*) (f, g) = \x y -> f x * g y; in compare `on` (length, length)
06:14:35 <solrize> http://honeyblog.org/junkyard/reports/impersonation-attacks-TR.pdf holy bleepity bleep </offtopic>
06:14:36 <lambdabot>     Couldn't match expected type `a -> b'
06:14:36 <lambdabot>            against inferred type `([a1] -> Int, [a2] -> Int)'
06:14:36 <lambdabot>     In the second argument of `on', namely `(length, length)'
06:14:45 <solrize> BAN C NOW!
06:14:54 <baaba> b_jonas, that would be too simple ;)
06:15:04 <b_jonas> as in (length ~> length ~> id) compare
06:15:04 <vixey> :t let on' (*) (f, g) = \x y -> f x * g y; in compare `on'` (length, length)
06:15:05 <lambdabot> forall a a1. [a] -> [a1] -> Ordering
06:15:06 <b_jonas> or something like that
06:15:20 <vixey> :t let on' (*) (f, g) = \x y -> f x * g y; in (compare `on'` (length, length)) "Foo" [1,2,3]
06:15:21 <lambdabot> Ordering
06:15:24 <vixey> > let on' (*) (f, g) = \x y -> f x * g y; in (compare `on'` (length, length)) "Foo" [1,2,3]
06:15:26 <lambdabot>   EQ
06:15:36 <idnar> hmm, isn't there another name for on'?
06:15:48 <b_jonas> liftM2
06:15:50 <b_jonas> or liftA2
06:15:51 <b_jonas> I think
06:15:55 <b_jonas> but those don't use a tuple
06:15:59 <vixey> :t liftA2
06:16:00 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
06:16:09 <vixey> doh
06:16:11 <vixey> thanks
06:16:19 <Saizan> it's not the same
06:16:20 <idnar> @t liftA2 compare length length
06:16:20 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:16:24 <idnar> @type liftA2 compare length length
06:16:26 <lambdabot> forall a. [a] -> Ordering
06:16:30 <Saizan> liftA2 gives the same argument to both
06:16:34 <vixey> ohhh...
06:16:35 <b_jonas> hmm yeah, sorry
06:16:36 <idnar> oh, of course
06:16:37 <Peaker> I think its lacking another combinator to define mapM
06:16:43 <b_jonas> there is one for on' too, only not one word
06:16:46 <b_jonas> I can't remember
06:16:47 <Peaker> ~> lets us apply stuff to separate args and the separate result
06:17:00 <b_jonas> but I asked before and someone gave a good answer
06:17:02 <idnar> @pl on' (*) (f, g) x y = f x * g y
06:17:02 <lambdabot> (line 1, column 20):
06:17:02 <lambdabot> unexpected "="
06:17:02 <lambdabot> expecting variable, "(", operator or end of input
06:17:23 <idnar> @pl on' h (f, g) x y = h (f x) (g y)
06:17:24 <lambdabot> on' = (`ap` snd) . (. fst) . ((flip . ((.) .)) .) . (.)
06:17:29 <Saizan> ?type curry (uncurry (***))
06:17:29 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:17:32 <idnar> @pl on' h f g x y = h (f x) (g y)
06:17:32 <lambdabot> on' = ((flip . ((.) .)) .) . (.)
06:17:36 * idnar cringes
06:17:48 <Peaker> idnar: the thing is, with nicer combinators we get nice PL's
06:17:55 <idnar> @type curry (uncurry (***)) compare length length
06:17:56 <lambdabot>     Couldn't match expected type `[a] -> Int'
06:17:56 <lambdabot>            against inferred type `(b, [a1])'
06:17:56 <lambdabot>       Expected type: ([a] -> Int) -> t
06:18:07 <idnar> hrm no
06:18:11 <Saizan> curry . uncurry == id, sorry :)
06:18:27 <idnar> Peaker: yeah
06:18:40 <idnar> Peaker: that output I got there is pretty brain-damaging, though
06:18:45 <idnar> Peaker: it's enough to make you dotty ;)
06:19:35 <Saizan> ?type uncurry compare . uncurry (***) $ (length, length)
06:19:36 <lambdabot>     Couldn't match expected type `(,)' against inferred type `(->)'
06:19:36 <lambdabot>     Probable cause: `length' is applied to too few arguments
06:19:36 <lambdabot>     In the expression: length
06:19:52 <Saizan> ?type (uncurry compare .) . uncurry (***) $ (length, length)
06:19:53 <lambdabot> forall a a1. ([a], [a1]) -> Ordering
06:21:26 <Peaker> idnar:  on' f g h x y = f (g x) (h y)  -->  on' f g h = f $. (g ~> h ~> id)    (not quite PL but more-so)...  or:  on f g = f $. (g ~> g ~> id)
06:21:44 <Peaker> idnar: this frees "x" and "y" to be arrowish parameters, rather than points
06:23:24 <vixey> I don't like  ~> id
06:24:15 <Peaker> vixey: it allows you to specify a function to apply after the edited function
06:24:21 <Peaker> vixey: and "terminates" the sequence..
06:24:22 <b_jonas> vixey: but you know how that allows you to use ~> for many-argumented functions
06:24:36 <vixey> oh I see
06:26:16 <adrian> hello
06:26:23 <Axman6> o/
06:26:55 <adrian> say I want to define a function: z x = f x `g` h x
06:27:02 <adrian> and want to get rid of the x
06:27:12 <adrian> is there a funktion like
06:27:18 <vixey> @pl z x = f x `g` h x
06:27:19 <lambdabot> z = liftM2 g f h
06:27:33 <adrian> ah ok
06:27:41 <adrian> @src liftM2
06:27:41 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:27:51 <fasta> What would be a suitable place to ask a question about Pandoc? It appears it doesn't work well with inline HTML.
06:28:53 <adrian> what does liftM2 do if x is, for example, an Int?
06:28:56 <adrian> which monad is used?
06:29:11 <adrian> is there an identity monad or somesuch?
06:29:18 <fasta> Right, and the markdown perl script which doesn't even have a --help implementation does work.
06:29:24 <vixey> actualy I would use liftA2 instead of liftM2
06:29:34 <fasta> That's one way to spread Haskel love.
06:29:41 <adrian> @src liftA2
06:29:41 <lambdabot> liftA2 f a b = f <$> a <*> b
06:29:58 <Peaker> adrian: its using the Reader monad
06:30:07 <fasta> Oh, for the reddit readers: [SARCASM][That's one way to spread Haskel love./SARCASM]
06:30:08 <Peaker> adrian: or Reader applicative in the liftA2/<*> case
06:30:21 <Peaker> adrian: the "x" is sort of an "environment" that all combined functions take as an argument
06:30:37 <lilac> what's the name for the set of equivalence classes over pairs of reals /= (0,0) where (a1,a2) R (b1,b2) iff exists k. b1 = k*a1, b2=k*a2.
06:31:06 <hallongrottan> @src reverse
06:31:06 <lambdabot> reverse = foldl (flip (:)) []
06:31:42 <vixey> lilac, lilac, B is a linear combination of {A}
06:32:00 <adrian> peaker: makes sense
06:32:02 <vixey> oopsssss
06:32:15 <ronny> @src foldl
06:32:15 <lambdabot> foldl f z []     = z
06:32:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:33:44 <lilac> vixey: i'm looking for the name of the group (ring?) formed by the equivalence classes under R
06:33:46 <Peaker> @hoogle bracket
06:33:46 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
06:33:46 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
06:33:46 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
06:33:49 <Peaker> hoogle is broken!
06:34:05 <Peaker> @type bracket
06:34:06 <lambdabot> Not in scope: `bracket'
06:34:11 <Peaker> @type Control.Exception.bracket
06:34:12 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:34:18 <vixey> lilac, I was looking at it as the vector space R^2
06:34:49 <vixey> if you collpase it down with that equivalence you get R^1 again
06:34:51 <lilac> vixey: it isn't really. it's a real line with weird stuff at infinity.
06:36:17 <lilac> topologically it's something like a circle with a line through it
06:36:34 <vixey>  b1 = k*a1, b2=k*a2 ?
06:36:37 <lilac> and actually i think the point (0,0) is included but k is not permitted to be 0
06:36:39 <vixey> How do you get a cicle
06:37:09 <lilac> the equivalence classes in R2 are lines through the origin
06:38:01 <Philonous> Isn't that just the projective space?
06:38:38 <quicksilver> lilac: the classes aren't a ring or group until you tell us what operations are on those lines :)
06:38:44 <quicksilver> lilac: at the moment it's just a bunch of lines.
06:39:04 <quicksilver> (classes)
06:39:34 <lilac> Philonous: right, it's RP1. thanks! that's what i was looking for
06:39:39 <quicksilver> if you try to include (0,0) it's not equivalence classes in the normal sense. (0,0) would have to belong to all of them.
06:39:59 <quicksilver> it's RP1 if you induce the topology from R2, yup.
06:40:18 <quicksilver> hmm.
06:40:23 <adrian> I need to take more maths classes
06:40:32 <adrian> so I can understand stuff on IRC...
06:40:34 <BONUS> lol what the cool
06:40:35 <BONUS> Please note that the price of Programming in Haskell has decreased from L22.79 to L20.39 since you placed it in your Shopping Basket.
06:40:42 <BONUS> and i just basically clicked add to basket
06:40:44 <BONUS> i didnt keep it there
06:41:07 <quicksilver> of course RP1 = S1
06:41:10 <quicksilver> topologically at least.
06:41:20 <quicksilver> lilac: so the simplest answer might just be 'that's a circle' ;)
06:41:21 <fasta> BONUS: they should fire the programmer who put in that rule.
06:41:23 <Philonous> quicksilver S1+one point
06:41:39 <Heffalump> fasta: what rule?
06:41:41 <lilac> quicksilver:
06:41:52 <lilac> grr Ctrl-J next to Ctrl-K :(
06:42:13 <fasta> Heffalump: If I owned whatever shop BONUS is visiting, I would only _increase_ the price.
06:42:15 <BONUS> fasta: they should give him a raise if it saves me two quid
06:42:16 <lilac> quicksilver: right, but i want to exploit algebraic properties of the definition in terms of equivalence classes over R2 :)
06:42:21 <quicksilver> Philonous: nope, RP1 is homemorphic to S1. no points needed.
06:42:24 <BONUS> and this is amazon.co.uk
06:42:24 <BONUS> haha
06:42:29 <fasta> BONUS: right, from your point of view :)
06:42:34 <Philonous> Really? What becomes of 0?
06:42:47 <quicksilver> Philonous: (0,0) wasn't in any of his classes.
06:43:00 <Philonous> But than it's not really RP1, is it?
06:43:02 <Heffalump> fasta: but being able to advertise that you are nice to customers is a good thing
06:43:07 <Philonous> If you leave it out you get S1, ok.
06:43:24 <quicksilver> Philonous: sure it is. RP1 is S1.
06:43:30 <fasta> Heffalump: yes, maybe they did it on purpose.
06:43:53 <quicksilver> Philonous: RP1 is [-1,1] ~ { 1 == -1 }
06:44:39 <quicksilver> (or R u {infty} )
06:45:35 <Philonous> Right, ok.
06:46:48 <Philonous> because S1 minus a point is homeomorphic to R
06:51:31 <Peaker> what is the strict getContents again?
06:52:11 <quicksilver> the strict bytestring version.
06:53:39 <Peaker> thanks
06:54:49 <Peaker> I think this piece of code is useful: http://hpaste.org/13188
06:55:05 <Peaker> Are "micro-libs" encouraged -- or do people just build up their own?
06:57:57 <maltem_> I'd say 10 loc don't even count as a micro-lib, but what do I know
06:58:29 <Peaker> well, some cabal libs are ~20 lines
06:58:32 <Peaker> IIRC
06:59:07 <quicksilver> Peaker: I don't think standards have really evolved for that kind of thing.
06:59:23 <quicksilver> off-hand what you've written seems slightly special purpose (catching IOErrors) and fairly easy to write
06:59:28 <quicksilver> but other may disagree
06:59:48 <Peaker> quicksilver: Well, in IO, all errors that can be caught are IOErrors?
06:59:56 <Saizan> no
07:00:23 <Peaker> @type catch
07:00:24 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
07:00:28 <Peaker> what does catch do then?
07:00:36 <Saizan> that's for haskell98
07:00:44 <maltem_> @type Control.Exception.catch
07:00:45 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
07:00:59 <Saizan> and in 6.10.1 it's different again
07:01:05 <maltem_> oh well
07:01:26 <Saizan> timedAction :: IO a -> IO (Clock.NominalDiffTime, Either IOError a)
07:01:41 <Saizan> timedAction :: Exception e => IO a -> IO (Clock.NominalDiffTime, Either e a) might work
07:02:11 <Peaker> also I find: surround act good bad = catch (act >>= good) bad     a nicer "catch"
07:02:32 <Peaker> sort of like bracket where the error handler can also determine the result
07:03:07 <quicksilver> what is the point of separating 'good' from 'act' ?
07:03:41 <Peaker> quicksilver: symmetry with "bad"
07:04:17 <quicksilver> I don't know why you wouldn't just have written catch (act >>= good) bad in the first place
07:04:31 <Peaker> Its what I have at first.. and maybe I will restore that :)
07:04:37 <quicksilver> i.e. combined act >>= good into one action
07:04:37 <Peaker> symmetry is overrated :)
07:04:38 <Surma> Hey guys, how do I convert an Int to a double? fromInteger wouldn't work?
07:04:43 <Surma> fromInt doesn't exists
07:04:46 <quicksilver> Surma: fromIntegral
07:05:02 <Surma> What's the difference to fromInteger?
07:05:08 <quicksilver> it works on all integral types
07:05:10 <quicksilver> including Int.
07:05:20 <luite> @src fromIntegral
07:05:21 <lambdabot> fromIntegral = fromInteger . toInteger
07:05:38 <Peaker> Is Control.Exception.Catch dynamic?
07:05:43 <Peaker> (as in, uses Typeable)
07:06:05 <quicksilver> Peaker: it uses "extensible exceptions"
07:06:10 <quicksilver> a paper.
07:06:10 <Peaker> how does that work?
07:06:22 <Peaker> what are instances of Exception? Anything I want?
07:06:58 <lilac> Peaker: i think i'd prefer an interface more like "IO a -> IO (DiffTime, a)
07:07:22 <lilac> if people want to catch the exception they can compose that with "Exception e => IO a -> IO (Either e a)"
07:07:30 <quicksilver> Peaker: anything you want.
07:07:36 <Peaker> lilac: Yeah, I guess so
07:07:38 <quicksilver> Peaker: read the paper :)
07:08:02 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#t%3AException <- for short
07:08:13 <lilac> @hoogle Exception e => IO a -> IO (Either e a)
07:08:14 <lambdabot> Warning: Unknown class Exception
07:08:14 <lambdabot> Control.Exception tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
07:08:14 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
07:08:18 <Peaker> then it also becomes trivial
07:08:40 <quicksilver> Saizan: that haddock is pretty confusing, since it still has large chunks which refer to the old API
07:08:46 <lilac> Peaker: if it decomposes into trivial parts, chances are your implementation is good :)
07:09:04 <Saizan> quicksilver: yeah, the class is there though
07:09:41 <quicksilver> Saizan: do you know why toException is needed?
07:09:56 <quicksilver> can't you just use SomeException (the constructor)
07:10:10 <lilac> timedAction a = do before <- getCurrentTime; result <- a; after <- getCurrentTime; return (after `diffUTCTime` before, result)
07:10:17 <lilac> tryTimedAction = timedAction . try
07:10:50 <lilac> Peaker: you may also want timedAction_ = fst <$> timedAction
07:11:00 <Saizan> quicksilver: you might want to go via another existential wrapper, to get a hierarchy
07:11:01 <quicksilver> oh, I know.
07:11:13 <quicksilver> I think it's so SomeException can instantiate itself?
07:11:22 <quicksilver> otherwise you'd build up the constructors when you do that.
07:11:58 <hugo___> how is the new logo going to be decided ?
07:12:28 <Peaker> lilac: That implies that it saves any work
07:12:29 <lilac> hugo___: probably whichever one makes the most ingenious use of a lambda
07:12:49 <quicksilver> subtle. I missed that first time I read the paper.
07:12:49 <Peaker> lilac: I think I prefer defining _ when it avoids building a value in the first place, not when it builds it and then discards it
07:13:42 <lilac> Peaker: fair enough. but i imagine "timedAction_ . evaluate" would be pretty useful for profiling
07:14:14 <Peaker> lilac: (fst <$> ...) is not so bad
07:14:28 <Saizan> well, throw :: Exception e => e -> IO a, but if you want exception Bar extends Foo; exception Foo extends SomeException, then throw Bar needs to know that i must wrap Bar in Foo before wrapping it in SomeException
07:14:54 <Saizan> s/i/it/
07:15:38 <quicksilver> Saizan: yup, got it now.
07:16:01 <quicksilver> lilac: evaluate considered harmful ;)
07:16:41 <lilac> quicksilver: is this the whnf-is-not-what-you-wanted argument?
07:17:10 <quicksilver> lilac: no, evaluate is something subtly different from seq
07:17:19 <quicksilver> and if it's not actually what you need, I think that's confusing.
07:17:35 <lilac> it's obviously different from seq :)
07:17:38 <quicksilver> I'd rather use (foo `seq` return ()) or (foo `rnf` return ())
07:17:48 <quicksilver> lilac: it's subtly different from `seq` return ()
07:18:29 <lilac> interesting. in what circumstances?
07:18:56 <lilac> @src evaluate
07:18:57 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
07:19:20 <fasta> evaluate is not very popular, AFAIK.
07:19:29 <quicksilver> well, one example is that "evaluate foo `seq` y" is just y
07:19:45 <quicksilver> whereas, of course, "foo `seq` return () `seq` y" will actualy evaluate foo.
07:19:51 <lilac> right. but that's what i'd expect
07:20:05 <lilac> (evaluate a) is an IO action which evaluates a
07:20:12 <quicksilver> evaluate sequences the evaluation into the IO monad in a way which is seldom necessary
07:20:15 <quicksilver> or useful
07:20:28 <quicksilver> and IMO it's better to learn how to use seq (and rnf)
07:20:36 <quicksilver> which are more natural tools.
07:20:48 <lilac> i find evaluate pretty natural to be honest
07:20:52 <quicksilver> evaluate was designed to try to 'force out' lurking imprecise exceptions I believe?
07:21:11 <lilac> and reasoning about when my IO a itself gets forced is not natural to me
07:22:04 <vixey> so much crap in haskell to workaround having lazy evaluation
07:22:27 <mbz> quicksilver, what's rnf?
07:22:28 <Peaker> vixey: do you prefer strict by default?
07:22:30 <quicksilver> lilac: the thread beginning at http://www.haskell.org/pipermail/haskell-cafe/2008-May/042367.html
07:22:41 <quicksilver> lilac: gives some insight into quite how confusing evaluate is :)
07:22:43 <quicksilver> at least, sometimes.
07:22:43 <vixey> I don't really have a preference
07:22:46 <lilac> if IO were an arrow rather than a monad, then the 'evaluate' model would still work, but the `seq` model wouldn't necessarily since someone might be statically analyzing the arrow
07:22:53 <quicksilver> the people who wrote evaluate themselves got the definition wrong.
07:23:04 <quicksilver> and it took 10 years for anyone to notice
07:23:14 <quicksilver> for me that's a fairly big indicator something is up :)
07:23:31 <quicksilver> vixey: "so much" crap? `seq` is just one primitive.
07:23:53 <vixey> ! patterns
07:23:58 <vixey> strictness analysis
07:24:12 <Peaker> vixey: I think a heuristic run-time profiling system could put a reasonable upper bound on memory/cpu use (compared to the optimum) by handling memoizing/strictifying
07:24:13 <mbz> does pattern matching force evaluation?
07:24:45 <Peaker> (maybe I'm optimistic...)
07:24:53 <Peaker> mbz: I think so, except for irrefutable patterns
07:24:56 <quicksilver> mbz: yes.
07:25:03 <quicksilver> mbz: in a sense, it's the only thing which does.
07:25:05 <b_jonas> is it just 'evaluate x = return $| x;' ?
07:25:08 <osfameron> does it
07:25:11 <quicksilver> mbz: the language is driven by "case"
07:25:13 <Saizan> b_jonas: no
07:25:14 <osfameron> matching on xs doesn't evaluate xs
07:25:19 <b_jonas> so it's something worse I guess
07:25:21 <quicksilver> b_jonas: no, precisely not.
07:25:40 <quicksilver> osfameron: no, but it evaluates xs "into the form xs"
07:25:47 <quicksilver> (which is a no-op, because everything is in the form xs"
07:27:30 <Saizan> you need to state that IO has a constructor (or that it's a function type) to reasonably describe evaluate
07:30:09 <lilac> Saizan: doesn't "evaluate x = do v <- return $! x; newIORef (); return v" work?
07:30:29 <lilac> (or with any other IO action between the seq and the return which can't be removed by monad laws)
07:30:51 <lawfulfalafel> excuse me but I seem to have trouble saving .hs files
07:31:39 <lawfulfalafel> I am going through the learnyouahaskell manual, and I am slowly modifying a basic file. For som reason though, whenever I save this file the formatting gets really screwed up.
07:31:43 <Saizan> > (do v <- return $! undefined; newIORef (); return v) `seq` ()
07:31:44 <lambdabot>   Not in scope: `newIORef'
07:32:26 <lawfulfalafel> I have two functions doubleMe and doubleUS, and when I save the d in doubleMe is always on the top line, followed by oubleMe on the second
07:32:29 <Saizan> lawfulfalafel: maybe you need to set your editor to expand tabs to spaces
07:32:49 <lawfulfalafel> I get the same error in emacs and nano though
07:33:14 <lawfulfalafel> if I save it in either the format gets funky
07:34:05 <lawfulfalafel> but only when I open it
07:34:11 <lawfulfalafel> cat returns the proper formatting
07:35:05 <quicksilver> lilac: nobody knows.
07:35:48 <quicksilver> lilac: because the semantics of IO do not specify in which circumstances >>= might evaluate its left argument.
07:36:32 <lilac> quicksilver: ah, i see. >>= might be left-strict.
07:36:42 <quicksilver> we only what we can deduce from our informal understanding of IO (which doesn't describe strictness properties) and the monad laws (which can be said to forbid over-strictness)
07:36:47 <Saizan> i'm quite surprised it isn't
07:36:58 <lilac> the monad laws /almost/ require it
07:37:03 <quicksilver> Saizan: it's not allowed to be completely left-strict
07:37:09 <quicksilver> or the >>= return law breaks.
07:37:27 <lilac> _|_ >>= return = _|_?
07:37:28 <quicksilver> on the other hand, maybe the monad laws (and all laws) as supposed to be read ignoring strictness
07:37:32 <quicksilver> (ignoring bottoms)
07:37:45 <quicksilver> that's certainly a reasonable view to take on laws, often.
07:38:03 <Saizan> why >>= return breaks?
07:38:20 <lilac> it looks fine to me :-/
07:38:47 <quicksilver> hrm
07:38:52 <quicksilver> maybe I got that slightly wrong.
07:39:35 <lilac> (a >>= _|_) >>= f = a >>= (\x -> _|_ x >>= f) = a >>= \x -> _|_ >>= f = a >>= \x -> _|_
07:39:49 <quicksilver> yeah, the law says that >>= is definitely *not* left strict, when the left component is "return <blah>"
07:39:58 <quicksilver> of course, it doesn't tell us if its left strict in other cases
07:40:02 <quicksilver> only the return case.
07:40:16 <lilac> all that means is that 'return' isn't strict, though, right?
07:40:21 <Saizan> return x >>= f == f x?
07:40:38 <lilac> or rather, at most one of return and >>= can be strict
07:40:39 <Saizan> what lilac said
07:41:34 <quicksilver> yes.
07:41:41 <lilac> and >>= must be strict when the RHS is 'return'
07:41:53 <quicksilver> anyhow, it doesn't exclude the possibility that >>= is left-strict sometimes
07:41:59 <quicksilver> which is where the problem comes from.
07:42:51 <Saizan> i wonder why it's not always left-strict on the "action"
07:43:30 <lawfulfalafel> this is the file that gets funky http://pastebin.com/m24d54d8f
07:43:49 <quicksilver> Saizan: it needs to be 'execution-strict', whatever that means
07:43:55 <lawfulfalafel> opening it in nano or emacs screws up my formatting
07:43:56 <quicksilver> but that's not a term you can easily make precise.
07:44:26 <quicksilver> Saizan: you can imagine an abstract model of IO which builds up wiring diagrams and executes them later
07:44:35 <quicksilver> so that's not strict in the normal sense.
07:44:42 <orbitz> I'm confusing myself about types and Monads here.  I want to write a function that takes a list of file paths and returns a lazy list of lines in all the files.  I beleive i want [FilePath] -> IO [ByteString]  right?
07:44:47 <quicksilver> in practice, GHC interleaves the evaluation and execution of IO, of course.
07:45:07 <lilac> quicksilver: can you? IO actions can be dynamically determined
07:45:10 <quicksilver> orbitz: you can't represent in the type that the list you return is lazy.
07:45:18 <lilac> (ie, IO is a Monad not just an Arrow)
07:45:21 <Saizan> yeah, but (undefined >>= const (putStr "")) `seq` () == () is a bit surprising
07:45:29 <orbitz> quicksilver: i'll be using ByteString.Lazy
07:45:41 <quicksilver> orbitz: but basically your type is right.
07:45:52 <lawfulfalafel> haha vim opens the file perfectly though
07:45:59 <xenoblitz> Need some help: I have a function of type (a -> (a,Bool)) and I want to apply it a number of times on the same "a" until the Bool becomes false... I was trying to use "until" but have not managed to solve my problem... any pearls of wisdom?
07:46:07 <quicksilver> lilac: well you can kind of represent that with a deep embedding, storing lambdas under the Bind constructor
07:46:25 <lilac> quicksilver: right, that makes sense.
07:46:27 <Saizan> > (undefined >> return 1  :: State Int Int) `seq` ()
07:46:28 <lambdabot>   ()
07:46:36 <lilac> quicksilver: kind-of HOAS?
07:46:41 <quicksilver> lilac: but then you have to reduce the monad laws to a fairly week kind of equivalence.
07:46:44 <Saizan> ?type until
07:46:45 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:46:58 <quicksilver> then again, there is no clear agreement about how to read the "=" sign in the monad laws.
07:47:07 <lilac> @type \f -> until (snd.f) (fst.f)
07:47:08 <lambdabot> forall a. (a -> (a, Bool)) -> a -> a
07:47:09 <quicksilver> some kind of observational/executional equivalence seems reasonable.
07:47:30 <Saizan> @type \f -> until snd (fst.f)
07:47:31 <lambdabot> forall a b. ((a, Bool) -> ((a, Bool), b)) -> (a, Bool) -> (a, Bool)
07:47:37 <quicksilver> lilac: you could even imagine IO actions being 'built as bytecode' for a VM.
07:47:50 <quicksilver> lilac: the point is that the evaluation of IO could conceptually be distinct from the execution.
07:47:53 <lilac> @type \f  a -> fst $ until snd (f.fst) (a,False)
07:47:54 <lambdabot> forall a. (a -> (a, Bool)) -> a -> a
07:48:00 <xenoblitz> Saizan: I was thinking of using snd but wouldn't that be on just one application?
07:48:05 <quicksilver> although there are good practical reasons to interleave evaluation and execution.
07:48:29 <lilac> quicksilver: right. but building as bytecode for VM would require introspection of the pure functions involved, right?
07:48:55 <quicksilver> lilac: maybe your VM is allowed to 'call back' to pure code by storing lambdas :)
07:49:02 <quicksilver> lilac: it's only a thought experiment anyway.
07:49:14 <gwern> hm. does anyone know why the 'directory' package is lacking a configure script?
07:49:49 <Saizan> gwern: does it really need one?
07:50:10 <Saizan> gwern: i've found that the packages coming from the ghc tree are set to Configure but often build with Simple
07:50:50 <gwern> Saizan: well, I ignored the warning and got stuff like 'System/Directory.hs:750:13: Not in scope: `c_getcwd'
07:50:58 <gwern> which look like C ffi stuff
07:52:42 <Dynetrekk> hi folks. how can I add an "empty" else in a do statement?
07:52:57 <gwern> maybe you want 'when'
07:53:02 <gwern> @hoogle when
07:53:02 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
07:53:08 <xenoblitz> lilac, Saizan: so... until (snd f) (fst f) ?
07:53:09 <Dynetrekk> gwern:  hm....
07:53:23 <Dynetrekk> gwern:  there is no "pass" or "print nothing
07:53:26 <Dynetrekk> " or similar_
07:53:27 <Dynetrekk> ?
07:53:37 <quicksilver> Dynetrekk: probably you want "return ()"
07:53:52 <Dynetrekk> that will end the do statement?
07:53:56 <quicksilver> Dynetrekk: but the types of your then and else branches have to match.
07:53:57 <quicksilver> nope
07:54:03 <quicksilver> return is nothing like return in other languages
07:54:06 <quicksilver> it doesn't end anything
07:54:12 <quicksilver> it just sets the return value of 'this bit'
07:54:20 <Dynetrekk> quicksilver: I see, the type thing, but... hm. I
07:54:21 <quicksilver> @src when
07:54:21 <lambdabot> when p s = if p then s else return ()
07:54:23 <Dynetrekk> I'll try
07:54:33 <quicksilver> ^^ "when" which gwern pointed you to, is exactly this ;)
07:54:33 <xenoblitz> xenoblitz: guys did I ask a trivial question? or?
07:54:40 <quicksilver> an "if" with a 'return ()' on the else branch
07:55:20 <gwern> (I figured Dynetrekk really wanted when because the last time I had the same need for an empty else, when turned out to be the solution)
07:55:39 <Dynetrekk> quicksilver: I see... it kinda works but the program is not right. my mistake, I guess.
07:56:13 <Dynetrekk> .hs:17:4: Not in scope: `when'
07:56:26 <quicksilver> it's in Control.Monad
07:56:29 <quicksilver> import Control.Monad
07:56:34 <gwern> as hoogle already said
07:56:36 <gwern> @hoogle when
07:56:37 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
07:56:39 <gwern> ^^ see
07:56:39 <quicksilver> ;)
07:56:45 <quicksilver> I agree gwern, I normally use 'when' as well.
07:56:53 <Dynetrekk> allright...
07:57:03 <quicksilver> But I thought seeing how to write it by hand might also be interesting.
07:57:47 <Sergio> Hi there!  I'm a (very) newbie in Haskell trying to FFI-bind a MS Visual dll. Since I'm also a newbie in IRC ;-), and since describing my problems is quite lenghty, I'd prefer interacting throughemail. Anybody willing to help? Thanks in advance.
07:58:44 <quicksilver> Sergio: I would suggest you send an email to haskell-cafe
07:58:50 <luite> Sergio: you may want to explain stuff with code samples, see www.hpaste.org , otherwise, try haskell-cafe
07:58:58 <Dynetrekk> ok, now for something über-newbie: how do you print a sstring with the stupid \n as a newline?
07:59:01 <quicksilver> (I think there might not be very many people around with FFI expertise to windows DLLs, I'm afraid)
07:59:09 <quicksilver> Dynetrekk: use putStrLn, not print
07:59:17 <quicksilver> Dynetrekk: print is put there to confuse you :)
07:59:29 <quicksilver> print wraps it up in haskell syntax, you get the "" at the beginning and end
07:59:35 <Dynetrekk> right, right
07:59:36 <quicksilver> and your newlines turn into \n
07:59:38 <gwern> quite. the distinction between print, putStr, and putStrLn confused me when I was new
07:59:50 <quicksilver> print is very poorly named IMO>
07:59:58 <quicksilver> should be called putShow
08:00:01 <quicksilver> or putShowLN
08:00:05 <quicksilver> or something.
08:00:11 <Dynetrekk> allright
08:00:40 <Dynetrekk> print should be called shitfuck, so noone would use it
08:01:17 <luite> in: foldr (\(x1,x2) (y1,y2) -> (x1+y1,x2+y2) (0,0) [1..] [1..]    -- how do I make the addition strict in this epxression?
08:01:31 <luite> oh, forgot a )
08:02:28 <quicksilver> let a = x1+y1; b = x2+y2 in a `seq` b `seq` (a,b)
08:02:34 <quicksilver> just after the ->
08:02:55 <quicksilver> or, alternatively "(,) $! x1+y1 $! x2+y2"
08:03:23 <luite> ah, thx
08:03:42 <quicksilver> luite: the trick with seq is you have to name the things
08:03:43 <luite> I thought it would be possible by just adding a few ! somewhere :)
08:04:07 <quicksilver> luite: by adding some ! you could make x1,x2,y1,y2 strict
08:04:11 <quicksilver> luite: but not the addition part
08:04:27 <luite> ah I see
08:04:35 <quicksilver> in this particular example (because it's a fold) the +s gets forced by the 'next round' of the loop
08:04:39 <quicksilver> so that would also work
08:04:47 <quicksilver> but you won't always be working with looped folds :)
08:05:02 <luite> no this example is a bit more simple than my real code :)
08:05:28 <luite> I'm still trying to optimize my array shuffle
08:05:44 <quicksilver> another good way might be to use a strict tuple
08:05:48 <quicksilver> you'd have to define it yourself
08:05:56 <quicksilver> data Pair a b = Pair !a !b
08:05:58 <b_jonas> > (undefined >>= print 1) >>= 2
08:05:59 <lambdabot>   Couldn't match expected type `a1 -> m a'
08:06:06 <b_jonas> > (undefined >>= \x -> print 1) `seq` 2
08:06:08 <lambdabot>   2
08:06:12 <Saizan> that foldr looks stack-consuming btw
08:06:14 <quicksilver> but then if you use that for your folds, you know everything is strict
08:06:21 <quicksilver> Saizan: yeah, I assume it wasn't a real example :)
08:06:24 <quicksilver> it doesn't terminate.
08:06:26 <b_jonas> I think that shows >>= in io is not strict
08:06:40 <quicksilver> b_jonas: no, it shows that your first example wasn't even type-correct?
08:06:52 <b_jonas> my second example
08:06:55 <b_jonas> the first one is just an error
08:06:59 <quicksilver> ah :)
08:07:14 <b_jonas> > (undefined :: IO ()) `seq` 2
08:07:15 <lambdabot>   * Exception: Prelude.undefined
08:07:18 <quicksilver> yes, I think you're right.
08:07:21 <quicksilver> good point.
08:07:46 <Saizan> yeah, the _|_ ends up under a lambda
08:08:06 <Saizan> and it's inspected only when the resulting action is executed
08:08:14 <b_jonas> this is only made possible by seq of course, because you can't case-match or call an IO directly to tell if it's bottom
08:09:36 <mpeter> XULRunner sucks
08:12:56 <athos> hi
08:13:33 <b_jonas> hello, athos
08:15:20 <svat> Hello, I want to compare the time taken by several functions; how can I do it apart from compiling different versions of the program and timing them?
08:15:53 <mpeter> getCPUTime
08:15:58 <BeelsebobWork> be careful though
08:16:05 <mpeter> @hoogle getCPUTime
08:16:06 <lambdabot> System.CPUTime getCPUTime :: IO Integer
08:16:15 <CalJohn> where can I download the code samples for real world haskell?
08:16:17 <BeelsebobWork> because of lazyness it's possible that you'll get interleaving of the functions you're running
08:16:30 <BeelsebobWork> and your CPU times won't be accurate
08:16:40 <mpeter> whaddya mean 'interleaving'
08:16:59 <BeelsebobWork> a Haskell program does not necessarily get evaluated in the order you write it in
08:17:06 <BeelsebobWork> it's possible that a bit of one function will get evaluated
08:17:06 <mpeter> oh i mean
08:17:09 <mpeter> wrap your main function
08:17:11 <BeelsebobWork> then a bit of another
08:17:14 <mpeter> in something that retrieves CPU time
08:17:47 <BeelsebobWork> yes, but remember, the IO monad is still lazy
08:17:47 <mpeter> with the input you normally expect
08:18:01 <BeelsebobWork> it doesn't necessarily do things in the order you write them in
08:18:30 <mpeter> yes
08:18:46 <BeelsebobWork> so you have to be careful not to get decieving results from it
08:19:06 <mpeter> @src ()
08:19:06 <lambdabot> data () = ()
08:19:18 <mapreduce> Also, you might consume a different number of results from each if you're not careful.
08:19:25 <lawfulfalafel> quit
08:19:55 <mapreduce> > map (+3) [1..100000000]
08:19:56 <lambdabot>   [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
08:20:13 <BeelsebobWork> mapreduce: yeh -- or consume the result from one, mid-way through the evaluation of another
08:20:16 <mapreduce> > last [1..100000000]
08:20:18 <BeelsebobWork> (hence slowing it down)
08:20:21 <lambdabot>   100000000
08:20:39 <mapreduce> > last [1..100000000000]
08:20:54 <lambdabot>   thread killed
08:20:56 <mapreduce> > map (+3) [1..100000000000]
08:20:58 <lambdabot>   [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
08:21:07 <luite> is it possible to find out where an 'Error in array index' occurs?
08:21:16 <mapreduce> Naively, you'd guess that map is faster than last by that :)
08:21:41 <mpeter> your handle is making me dizzy
08:22:01 <mapreduce> Mine?
08:22:21 <mpeter> yeah
08:22:44 * mapreduce spins.
08:24:15 * mpeter swoons
08:25:04 <mpeter> > map (**2.1) [1..1000] !! 15
08:25:07 <lambdabot>   337.79402515786103
08:26:07 <mpeter> > (x:_) !! 0
08:26:09 <lambdabot>   Pattern syntax in expression context: _
08:26:41 <mpeter> > 5000
08:26:43 <lambdabot>   5000
08:27:06 <CalJohn> Is there nowhere to download the code samples for RWH?  I find them on safari via google searches, but the actual pages seem to show no such thing...
08:29:40 <tristes_tigres> Hello
08:29:41 <preflex>  tristes_tigres: you have 1 new message. '/msg preflex messages' to read it.
08:30:11 <tristes_tigres> Do I undertand correctly, the at present type families can not fully replace fundeps ?
08:32:20 <tristes_tigres> "Equalities in superclass contexts are not fully implemented in GHC 6.10. "
08:34:26 <tristes_tigres> Can you say "class C a b | a -> b" with type families ?
08:34:47 <athos> :t <$>
08:34:48 <lambdabot> parse error on input `<$>'
08:34:54 <athos> :t (<$>)
08:34:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:36:02 <vixey> tristes_tigres, hi
08:36:36 <tristes_tigres> hi vixey, just got your message, begun tio read the code
08:39:16 <lilac> tristes_tigres: you can say "class C a where data b" (or something similar) right?
08:39:21 <athos> > (+3) `fmap` [1,2,3]
08:39:23 <lambdabot>   [4,5,6]
08:39:27 <athos> > (+3) <$> [1,2,3]
08:39:29 <lambdabot>   [4,5,6]
08:40:12 <mpeter> (\x->[x+1,x**2.3,x**2,5]) <$> [1,2.2..9.9]
08:40:13 <tristes_tigres> lilac: no
08:40:17 <mpeter> > (\x->[x+1,x**2.3,x**2,5]) <$> [1,2.2..9.9]
08:40:19 <lambdabot>   [[2.0,1.0,1.0,5.0],[3.2,6.131576709333357,4.840000000000001,5.0],[4.4,16.68...
08:41:01 <mpeter> oops
08:41:02 <mpeter> > (\x->[x+1,x**2.3,x**2.5]) <$> [1,2.2..9.9]
08:41:04 <lambdabot>   [[2.0,1.0,1.0],[3.2,6.131576709333357,7.178880135508603],[4.4,16.6878931048...
08:41:20 <tristes_tigres> lilac : class C a b | a -> b
08:41:20 <mpeter> > join ((\x->[x+1,x**2.3,x**2.5]) <$> [1,2.2..9.9])
08:41:23 <lambdabot>   [2.0,1.0,1.0,3.2,6.131576709333357,7.178880135508603,4.4,16.6878931048986,2...
08:42:20 <tristes_tigres> vixey: Ah, I see you redefined the infinity
08:42:35 <mpeter> > map (chr . floor) (join ((\x->[x+1,x**2.3,x**2.5]) <$> [1,2.2..9.9]))
08:42:37 <lambdabot>   "\STX\SOH\SOH\ETX\ACK\a\EOT\DLE\NAK\ENQ!-\ACK9Q\bW\129\t~\192\n\173\270"
08:42:41 <mpeter> ^ i like how it says "ACK"
08:42:48 <vixey> tristes_tigres, from what?
08:43:09 <wli> Haskell's symbolic character literals are a very nice touch.
08:43:22 <tristes_tigres> vixey: from the infinity = Succ inifinity definition
08:43:33 <vixey> that's equivalent, change it back if you like
08:43:33 <mpeter> > map (chr . (+50) .floor) (join ((\x->[x+1,x**2.3,x**2.5]) <$> [1,2.2..9.9]))
08:43:35 <lambdabot>   "4335896BG7S_8k\131:\137\179;\176\242<\223\320"
08:43:59 * mpeter dies
08:44:20 <tristes_tigres> alhtough the deinition of fix amounts to same thing
08:45:08 <mpeter> they define infinity recursively?
08:45:28 * mpeter has an idea
08:46:26 * mpeter 's idea falls short quickly
08:50:59 <tristes_tigres> mpeter: in the definition of Pean numerals, yes
08:51:19 <tristes_tigres> vixey: Interesting program
08:59:13 * RayNbow opens a bag... *Zelda treasure chest tune*
08:59:24 <RayNbow> yay, a copy of Real World Haskell :)
09:01:50 <lilac> tristes_tigres: what do you mean "no"? something like "class C a where data C' b :: *" is legal with type families, and has approximately the same meaning as "class C a b"
09:02:19 <lilac> that should be "class C a b | a -> b"
09:05:27 <augustss> Argh!  I need dependent types for the LLVM interface.
09:06:36 <vixey> augustss, seems to be a good idea
09:06:56 <augustss> vixey: yeah, but Haskell doesn't have them.
09:09:31 <quicksilver> b_jonas: to pick up an hour later, that just proves that GHC's >>= is not left strict.
09:09:48 <augustss> In what monad?
09:10:02 <pejo> augustss, guess you need to start hacking on cayenne then. :-)
09:10:11 <quicksilver> b_jonas: The question is whether that is a *necessary* feature of IO
09:10:22 <quicksilver> b_jonas: or just a characteristic of GHC's particular implementation.
09:10:25 <quicksilver> augustss: IO.
09:10:37 <quicksilver> augustss: the old evaluate semantics debate started the discussion.
09:10:55 <augustss> quicksilver: I never understood evaluate
09:11:29 <Saizan> ?src evaluate
09:11:29 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
09:11:29 <augustss> It's seems like some implementation hack
09:11:36 <quicksilver> augustss: I've never wanted to use it personally. The debate started because I advised against and it recommended use of seq.
09:11:49 <quicksilver> I'd rather have one strictness primitive we can try to iunderstand.
09:12:04 <quicksilver> rather the two which are in fact independent (not implementable in terms of each other)
09:14:07 <augustss> ?src approxRational
09:14:08 <lambdabot> Source not found. Do you think like you type?
09:14:34 <augustss> Why do we have the source for something ugly like evaluate, but not something beautiful like approxRational?
09:15:48 <quicksilver> augustss: I don't know why the not-haskell src of some of the IO primitives is in lambdabot
09:15:53 <quicksilver> it strikes me as counter-productive, if lambdabot is supposed to be a teaching tool.
09:16:07 <quicksilver> GHC's "not-really-haskell" underlying language is just confusing.
09:16:19 <wli> augustss: What's approxRational?
09:16:27 <augustss> quicksilver: IO is an abstract type, nothing of it's internals should be avilable in lambdabot
09:16:29 <vixey> @src [] is good though
09:16:30 <lambdabot> Source not found. I am sorry.
09:16:35 <quicksilver> augustss: quite.
09:16:50 <augustss> > approxRational pi 0.1
09:16:52 <lambdabot>   16%5
09:17:04 <augustss> > approxRational pi 0.001
09:17:06 <lambdabot>   201%64
09:17:13 <osfameron> is it insane to think about using monads to do mortgage calculations?
09:17:13 <wli> Rational bounding intervals are plausible, too.
09:17:25 <athos> @src []
09:17:25 <lambdabot> data [] a = [] | a : [a]
09:17:34 <tomh-> how can i do a print line in haskell without messing up the return type?
09:17:39 <BONUS_> osfameron: there was this blog post about using monads to formalize mortgage contract i think
09:17:41 <augustss> quicksilver: It gives the simplest rational number within the given tolerance.
09:17:45 <wli> osfameron: No. IIRC SPJ wrote a paper on financial contracts using functional programming already (with several co-authors).
09:17:46 <BONUS_> anyone got a link?
09:17:48 <osfameron> I want to do something like "If I pay my mortgage at this rate, but overpaying X, for 5 years, and then revert to a different rate, when will I have paid off my mortgage"
09:17:50 <quicksilver> tomh-: messing up the return type in what fashion?
09:17:52 <BONUS_> gah
09:17:56 <quicksilver> augustss: yeah, I know. It's really nice.
09:17:58 <augustss> quicksilver: sorry, that was for wli
09:18:11 <osfameron> BONUS_, wli: yeah, that was cute (what I understood about it), but I'm looking more at projecting actual values, rather than modeling the types of contract
09:18:14 <tomh-> quicksilver: my program is stack overflowing so i  need to detect the loop
09:18:26 <tomh-> and i want print line statements all over my program to see where it happens
09:18:33 <augustss> wli: It gives the simplest rational number within the given tolerance.  I think it's a truly amazing function.
09:18:39 <zachk> osfameron: it depends on subtle terms of your mortage how its interest is calculated etc
09:18:53 <osfameron> really I would think about a lazy list, but I have an idea that there's certain amounts of state involved (like interest rate, base payment, overpayment, etc.) that made me wonder if it was better suited to a monad
09:19:07 <zachk> tomh-: you do not need to detect the loop only make the loop tail recursive and all will be well
09:19:19 <tristes_tigres> lilac: I mean the part after the |
09:19:21 <BONUS_> yeah it could be srot of a specialized State
09:19:22 <wli> augustss: Just go with successive pairs of continued fraction convergents until the product of denominators meets the tolerance criterion?
09:19:23 <quicksilver> tomh-: use Debug.Trace if that's what you want.
09:19:26 <tristes_tigres> class C a b | a -> b
09:19:29 <BONUS_> and you could have a list of them and then just do sequence
09:19:32 <tristes_tigres> lilac: class C a b | a -> b
09:19:36 <BONUS_> to get the final interest rate and stuff
09:19:45 <quicksilver> tomh-: I don't often find it often the nicest way though :)
09:20:05 <quicksilver> tristes_tigres: that's a functional dependency
09:20:24 <lilac> tristes_tigres: that means that, given a, you can deduce the value of b
09:20:25 <tristes_tigres> quicksilver: Yes, I know. That's precisely what I asked
09:20:27 <osfameron> BONUS_: ah, cool, yeah
09:20:32 <BONUS_> haha, i got RWH on amazon.co.uk for 33 euros, whereas it would cost me more than 50 on amazon.de. and they'll probably still ship it from amazon.de's warehouse
09:20:35 <tristes_tigres> liklac ^ I know
09:20:51 <lilac> tristes_tigres: so it's kinda the same as saying that b is a type provided by a class parameterized by a
09:20:52 <tristes_tigres> lilac: I asked if you can say the same thing with type families
09:21:00 <lilac> tristes_tigres: and i said "here's how"
09:21:20 <tristes_tigres> lilac: class (F a ~ b) => C a b where ...    is not implemented in GHC
09:21:42 <lilac> tristes_tigres: class C a where data C' b
09:22:00 <tomh-> quicksilver: normally with the right tools i got a debugger
09:22:01 <lilac> is i think the way you formulate that with associated types
09:22:37 <lilac> or at least, one way of formulating it
09:22:44 <quicksilver> "class C a where data C'" or "class C a where type C'", I think
09:22:54 <quicksilver> you don't need the b any more
09:23:07 <quicksilver> the type would be called "C' a"
09:23:31 <quicksilver> tomh-: there is indeed a debugger in ghci
09:23:34 <quicksilver> tomh-: although I've never used it.
09:24:05 <tristes_tigres> quicksilver: but if I need b, type families can not provide for that ?
09:24:28 <lilac> "class C a where type C'b a"
09:24:44 <quicksilver> tristes_tigres: yes, the "b"  is there.
09:24:48 <quicksilver> it's called "C' a"
09:24:52 <quicksilver> "C' a" is your b.
09:24:57 <zachk> i see a great mountain i must climb
09:25:07 <quicksilver> you can call it "B a" if you prefer
09:25:12 <quicksilver> class C a where data B
09:25:33 <tristes_tigres> quicksilver: What if I need to declare a function C a b -> C d b -> C e b
09:25:45 <lilac> quicksilver: has the syntax changed?
09:25:59 <lilac> according to the wiki it used to be 'class C a where data B a'
09:26:12 <tristes_tigres> that is, to say that the dependent type vairable is the same
09:26:21 <quicksilver> lilac: I was just checking, you're right, sorry.
09:26:57 <lilac> tristes_tigres: f :: (B a ~ B d ~ B e) => C a -> C d -> C e
09:26:59 <quicksilver> tristes_tigres: f :: (B a ~ B d, B a ~ B e) => C a -> C d -> C e
09:27:02 <quicksilver> I believe.
09:27:14 <quicksilver> oh, can you do more than one ~ at once?
09:27:16 <tristes_tigres> lilac: "Equalities in superclass contexts are not fully implemented in GHC 6.10"
09:27:22 <lilac> quicksilver: probably not actually
09:27:26 <lilac> tristes_tigres: this isn't a superclass context
09:33:50 <tristes_tigres> lilac: OK, what if I need instance (D a, C x a, C y a) => F (Combine x y) a
09:35:38 <lilac> tristes_tigres: Something like "(D (B x), B x ~ y) => ..." might work for that
09:35:43 <lilac> sorry, B x ~ B y
09:35:50 <athos> @type liftM
09:35:51 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:36:05 <sw17ch> Quick question, is this tail recursive? -> http://hpaste.org/13192
09:36:06 <athos> @type (<$>)
09:36:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:36:47 <lilac> sw17ch: no, but that's OK; it's lazily building a data structure
09:37:03 <sw17ch> lilac, is it okay even if it needs to run forever?
09:37:19 <tristes_tigres> lilac: you mean "(D (B x), B x ~ B y) => .. ?
09:38:03 <lilac> sw17ch: in general, it's safe only if the consumer of the data structure doesn't hold onto arbitrarily large chunks of it
09:38:13 <athos> @type zipWith
09:38:14 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:38:22 <lilac> sw17ch: for IO (), it should be fine.
09:38:41 <athos> > zipWith (+) [1,2,3] [1,1,1]
09:38:42 <lambdabot>   [2,3,4]
09:38:55 <lilac> sw17ch: this is in some sense similar to a recursive function building an infinite list
09:39:06 <lilac> sw17ch: tail recursion there would be terrible -- you'd never see the first element!
09:39:07 <sw17ch> lilac: that's how i was thinking about implementing it later...
09:39:20 <sw17ch> good point...
09:39:34 <sw17ch> either way, i have a space leak somewhere... and i'm not sure where it is :\
09:39:50 <sw17ch> or if it just looks like a space leak and the GC never runs until i start using 6M of memory
09:40:09 <luite> why does a listArray (1,10000000) [1..] :: Array Int Int  take 3 minutes? (2GHz core 2 duo), sure it's a lot of elements, 10M, but isn't this extremely slow? (no swapping going on)
09:40:44 <sw17ch> i start the program, and it's put under a load. It starts with about 1.9M of memory usage. After a while, this climbs in steps and levels out right around 6M. Does that sound like the GC waiting to run?
09:40:54 <sw17ch> or a space leak
09:41:47 <lilac> i /think/ the GC kicks in before that, typically. i think there's RTS options to control it.
09:42:18 <quicksilver> sw17ch: well 6M really isn't that much, these days.
09:42:34 <quicksilver> I wouldn't be that surprised at a program climbing to 6M before the first major GC kicks in.
09:42:39 <sw17ch> quicksilver, oh, i'm fully aware... but this is my VPN client, and i expect this to run for days and days
09:42:43 <luite> my program doesn't seem to use extreme amounts of ram, about 150MB,
09:42:50 <sw17ch> :D
09:42:51 <quicksilver> yeah, but 6M isn't that much, sw17ch ;)
09:42:55 <quicksilver> what matters is the long-term leak
09:43:06 <quicksilver> if you don't have a long term leak, you don't care about 6M.
09:43:08 <sw17ch> quicksilver, hehe, i'll just run it for a few days then and see it's memory usage there
09:43:19 <quicksilver> sw17ch: heap profile it for 30 minutes or so
09:43:24 <quicksilver> see if the graph is climbing or not
09:43:24 <sw17ch> will do
09:43:38 <tristes_tigres> lilac: Thanks, I'll try it
09:43:43 <sw17ch> oh, in case any of you have heard about my VPN... it's almost ready for a first release
09:43:52 <lilac> sw17ch: is cmts getting forced somewhere? it's possible you're building up a large thunk
09:44:11 <luite> the behaviour also seems to be highly nonlineair: listArray with 1M elements takes 2 seconds, listArray with 10M elements takes 3 minutes
09:44:27 <tristes_tigres> sw17ch: is it better than openVPN ?
09:44:29 <Lemmih> luite: That's not very surprising.
09:44:37 <lilac> luite: it needs to force the spine of the list to find the length
09:44:45 <sw17ch> tristes_tigres, it's a different paradigm. it's a P2P VPN rather than a hub vpn
09:44:46 <Lemmih> luite: GC becomes more and more expensive.
09:44:52 <Lemmih> luite: Try UArray.
09:44:57 <sw17ch> oh, and it doesn't have any encryption yet :P
09:45:24 <sw17ch> lilac: yes it is, but i should make that parameter strict
09:45:30 <lilac> luite: hmm, maybe i've forgotten how listArray works :)
09:45:45 <luite> lilac: I don't think it needs to find the length of the list first
09:45:50 <sw17ch> It runs on 4 platforms. Windows, Mac, Linux, Bsd...
09:45:52 <tristes_tigres> sw17ch: is there something functional about it ?
09:46:12 <sw17ch> tristes_tigres, if by functional, you mean, written in haskell, then yes :)
09:46:23 <luite> lilac: I guess it's some zip with the list of the range, and then a write for each element
09:46:25 <jeffwheeler> Is Data.List.sort entirely lazy, such that it won't sort the entire list if you only look for the first element?
09:46:39 <lilac> luite: indeed not. :)
09:46:48 <solrize_> is there a builtin for modular inverse or extended gcd?
09:47:01 <tristes_tigres> sw17ch: I mean does it have something that would be awkward to implement in C/C++/etc
09:47:13 <sw17ch> it uses a whole ton of threads
09:47:17 <sw17ch> and has a stateless protocol
09:47:21 <luite> I wonder how I can fill an array faster than this
09:47:25 <sw17ch> and is lockless (for the most part)
09:47:32 <lilac> luite: but Array is boxed, and you're not forcing the array elements, so it's an array of [x0 = 0, x1 = x0 + 1, x2 = x1 + 1, ...] (lots of thunks) i think
09:47:42 <sw17ch> and it's... less than 2500 lines of C + Haskell (compared to nearly 50K in OpenVPN)
09:48:01 <sw17ch> tristes_tigres, http://code.google.com/p/scurry/
09:48:03 <sw17ch> if you want to take a look
09:48:04 <quicksilver> jeffwheeler: how would you calculate the smallest element in a list without forcing the whole list?
09:48:19 <luite> lilac: ah, and an unboxed array, does that have both values and indices unboxed?
09:48:30 <lilac> luite: afair, yes
09:48:30 <Saizan> it will force the whole list, but it won't sort it
09:48:36 <quicksilver> luite: arrays don't actually store the indices.
09:48:40 <jeffwheeler> quicksilver: depending on the search algorithm, the first element might be found by comparing it to all the rest, while the tail is still unsorted
09:48:43 <quicksilver> luite: the indices are a front-end translation.
09:48:46 <lilac> luite: the indices are never boxed, in some sense
09:48:49 <jeffwheeler> quicksilver: or perhaps that's impossible
09:48:53 <quicksilver> jeffwheeler: no, it's possible
09:48:54 <luite> quicksilver: oh right, that's some funciton in the Ix typeclass right?
09:48:57 <quicksilver> it's a merge sort
09:49:15 <quicksilver> luite: you wouldn't store the indices in a C array would you? ;)
09:49:15 <jeffwheeler> quicksilver: alright; so, is that what Data.List.sort implements?
09:49:31 <quicksilver> jeffwheeler: Data.List.sort is currently a merge sort, yes.
09:49:34 <tristes_tigres> sw17ch: so, can it be integrated into bittorrent so that RIAA can not come after you ass ? ^-)
09:49:51 <jeffwheeler> quicksilver: cool. That's neat, considering the laziness. :)
09:49:56 <sw17ch> tristes_tigres, i'll let some one else do that, i'm not going to get caught holding that knife :)
09:49:58 <luite> quicksilver: hehe, true, but C array's aren't indexable by tuples or other 'crazy' types :)
09:50:03 <vixey> jeffwheeler, if you care about the exact execution of it rather than the meaning of 'sort', then playing safe would be to put down your own definition
09:50:06 <sw17ch> tristes_tigres, but it *doesn't have encryption yet*
09:50:25 <tristes_tigres> sw17ch: Coool, VPN without encryption !
09:50:37 <sw17ch> i'm going to write bindings for libgcrypt and have trust-based authentication and encryption
09:50:48 <sw17ch> tristes_tigres, it's useful for playing games right now :)
09:51:09 <sw17ch> it's actually incredibly fast
09:51:10 <lilac> luite: you could try something like: array (0,1000) $ zipWith (\a b -> b `seq` (a,b)) [0..] [1..1001]
09:51:21 <sw17ch> it adds about 0.25 ms of latency to each message on my machine
09:51:30 <sw17ch> and runs at about 80% throughput
09:51:37 <sw17ch> (the MTU is smaller b/c of packet overhead)
09:51:49 <tristes_tigres> sw17ch: considering that it doesn't encrypt, I imagine the speed advantage over the more traditional encrypting VPN must be substantial :-)
09:52:01 <sw17ch> ^^ :)
09:52:13 <sw17ch> i do rely on the TAP-Win32 driver
09:52:32 <sw17ch> but yeah, it's fast, and connecting to any one on the network will help you establish connections to every one else
09:52:39 <sw17ch> and it has LAN peer discovery built in automatically
09:52:48 <sw17ch> and Skype style firewall punching
09:52:55 <sw17ch> (the super naive version)
09:52:58 <daf> sw17ch: "Skype style"?
09:53:21 <sw17ch> daf: the proper term is a STUN server or protocol
09:53:33 <daf> huh
09:53:35 <sw17ch> it's basically a method for establishing a connection between to people behind two separate nats
09:53:39 <sw17ch> over UDP
09:53:47 <daf> I thought Skype did more sophisticated stuff
09:53:55 <sw17ch> well, it does
09:54:04 <sw17ch> mine is the easy version that just passes port numbers around
09:54:09 <sw17ch> for now
09:54:15 <daf> how do you pass them around?
09:54:28 <tristes_tigres> sw17ch: does it have some provisions so that the neighboring nodes don't know that connection is coming from you, or someone else ?
09:54:30 <daf> before you've established the connection?
09:54:42 <sw17ch> tristes_tigres, not yet, but it's in the roadmap
09:54:44 <chrisdone> chr1s: ping
09:55:06 <sw17ch> daf: it requires an aribter node who has a port forwarded
09:55:09 <sw17ch> or is running wide open
09:55:40 <daf> ok, so it's vaguely similar to how VoIP stuff works
09:56:00 <sw17ch> new peers talk to the arbiter, the arbiter tells every one else on the network what ip:port the new peer came from
09:56:08 <sw17ch> all the other peers try and contact the new guy on that port
09:56:14 <sw17ch> some routers prevent this
09:56:30 <daf> yeah
09:56:36 <sw17ch> but the arbiter *also* passes the list of peers to the new guy and he *also* tries to establish connections
09:56:53 <sw17ch> so, you get a lot of hosts making best effort guesses
09:56:54 <daf> hmm, that will help
09:56:58 <sw17ch> and it does
09:57:14 <daf> though possibly using a different port for each p2p connection might help
09:57:24 <daf> for those NATs that include the remote address in the mapping
09:57:25 <sw17ch> daf: actually, that gets in the way
09:57:25 <luite> lilac: ah I thought I already tried UArray, but apparently I made some mistake. a UArray Int Int is about 100x faster than a regular Array Int Int
09:57:38 <sw17ch> daf: ah
09:57:39 <sw17ch> wait
09:57:41 <sw17ch> i see waht you mean
09:57:54 <sw17ch> i hadn't thought to do that :)
09:58:08 <daf> sw17ch: there's a draft IETF standard for this
09:58:17 <sw17ch> daf: yes, i've read some of it
09:58:32 <chrisdone> chr1s: cancel that ping
09:58:32 <daf> cool
09:58:45 <daf> I did some work on a free implementation a while ago
09:58:50 <sw17ch> tristes_tigres, the only thing preventing that right now is that i don't have any of the nodes doing routing
09:58:51 <RayNbow> ooo... cool... RWH contains a list of names :)
09:59:00 <sw17ch> daf: really :)
09:59:43 <daf> sw17ch: yeah; C library, so not immediately useful: http://nice.freedesktop.org/
09:59:44 <sw17ch> @src Control.Monad.forever
09:59:44 <lambdabot> Source not found. Wrong!  You cheating scum!
09:59:58 <daf> sw17ch: other people did most of the work since I started it :)
10:00:04 <quicksilver> forever a = a >> forever a
10:00:14 <quicksilver> you don't give module qualifications to @src
10:00:14 <tristes_tigres> sw17ch: put it into a client to leach stuff, and you'll be amazed, how many nodes will pop up
10:00:24 <quicksilver> it either has the src or it doesn't.
10:00:35 <sw17ch> @src forever
10:00:35 <lambdabot> Source not found.
10:00:40 <quicksilver> note that forever is not tail recursive
10:00:42 <Botje> uh
10:00:44 <quicksilver> and yet it still works.
10:00:48 <quicksilver> magic ;)
10:00:49 <Botje> how did spammers manage to edit an immutable page? :/
10:00:55 <sw17ch> magic!
10:01:04 <vixey> which page?
10:01:08 <sw17ch> quicksilver: is it possible to have a forever that uses >>= instead of >> ?
10:01:09 <Botje> the one daf posted
10:01:12 <sw17ch> my head isn't working yet today
10:01:12 <Botje> http://nice.freedesktop.org/
10:01:29 <Botje> sw17ch: sure is
10:01:48 <daf> Botje: it's only immutable if you're not logged in :(
10:01:48 <quicksilver> sw17ch: forever f start = f start >>= forever f
10:01:49 <quicksilver> ?
10:02:03 <Botje> oh.
10:02:03 <quicksilver> :t let forever f start = f start >>= forever f in forever
10:02:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> a -> m b
10:02:09 <quicksilver> looks right.
10:02:18 <vixey> :t fix (>> ?f)
10:02:19 <lambdabot> forall (m :: * -> *) b. (Monad m, ?f::m b) => m b
10:02:20 <vixey> :t fix (>>= ?f)
10:02:21 <lambdabot> forall (m :: * -> *) b. (Monad m, ?f::b -> m b) => m b
10:02:23 <quicksilver> 'start' is the starting value of the thing you're passing around.
10:02:40 <sw17ch> quicksilver, yes, that's the one
10:03:08 <quicksilver> would be silly to call it forever, of course :)
10:03:09 <quicksilver> I normally just do that by manual recursion, never bothered to name it.
10:03:48 <sw17ch> quicksilver: foreverB (bind) ?
10:04:05 <quicksilver> sure.
10:04:07 <quicksilver> or foreverFold
10:04:08 <sw17ch> yay!
10:04:10 <quicksilver> it's a bit like foldM
10:04:12 <quicksilver> :t foldM
10:04:14 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:04:27 <b_jonas> does it have to do with fixM?
10:04:31 <quicksilver> (over and infinite and ignored list of bs)
10:04:37 <sw17ch> yeah, i was thinking about using foldM, but i don't have a list parameter
10:04:44 <ski_> b_jonas : no
10:04:54 <quicksilver> :t iterateM
10:04:55 <lambdabot> Not in scope: `iterateM'
10:05:09 <quicksilver> sw17ch: "iterateM" is a tempting name, but would not be quite consistent
10:05:19 <quicksilver> (the normal iterate returns a list)
10:05:22 <sw17ch> yes
10:05:22 <quicksilver> iterateM_ ?
10:05:37 <sw17ch> :t iterate
10:05:38 <lambdabot> forall a. (a -> a) -> a -> [a]
10:05:41 <ski_> `Monad m => (a -> m a) -> a -> m b' is useful for an "expression" monad .. being full substitution
10:05:45 <sw17ch> :t iterate (return ())
10:05:46 <lambdabot> () -> [()]
10:05:54 <sw17ch> :t sequence $ iterate (return ())
10:05:55 <lambdabot>     Couldn't match expected type `[m a]'
10:05:55 <lambdabot>            against inferred type `() -> [()]'
10:05:55 <lambdabot>     In the second argument of `($)', namely `iterate (return ())'
10:06:39 <ski_>   iterateM :: Monad m => (a -> m a) -> (a -> m [a])  -- probably
10:06:44 <quicksilver> sw17ch: you forced yourself into the (->) monad there.
10:06:51 <sw17ch> yep...
10:06:59 <quicksilver> ski_: yeah, and then iterateM_ which ignores the result.
10:07:07 <quicksilver> ski_: completely useless in some monads though
10:07:16 <ski_> quicksilver : makes sense, i suppose
10:07:16 <sw17ch> heheh
10:07:20 <ski_> *nod*
10:07:22 <quicksilver> (some monads aren't productive through infinite recursion)
10:07:49 <sw17ch> well, i think for now i'll stick with foreverB
10:07:56 <ski_> like parsing ..
10:07:59 <quicksilver> in fact it's not entirely that IO should be productive through infinite recursion.
10:08:02 <sw17ch> since it's easier for me to say "it's like forever, but with a bind"
10:08:07 <quicksilver> it just happends that it is.
10:08:17 <quicksilver> "entirely clear" I meant.
10:08:30 <quicksilver> and it's obviously very useful, since we want to write servers.
10:08:45 <ski_> quicksilver : given an `unsafeInterleaveIO' ..
10:08:47 * sw17ch replaces his code with a version that uses foreverB
10:08:59 <quicksilver> But a priori, from the 'naive semantics' of IO, you might expect forever (print ()) to be _|_
10:09:25 <dons> ?yow
10:09:25 <lambdabot> HELLO, everybody, I'm a HUMAN!!
10:09:31 <b_jonas> @src forever
10:09:32 <lambdabot> Source not found.
10:09:40 <quicksilver> deja vu ;)
10:10:00 <ski_> > runWriter (forever (tell "\n"))
10:10:15 <lambdabot>   thread killed
10:10:31 <sw17ch> quicksilver, yes, i like this a lot more... it's a little clearer what's going on...
10:10:34 <sw17ch> with that abstraction
10:10:37 <ski_> > take 10 . snd $ runWriter (forever (tell "\n"))
10:10:39 <lambdabot>   "\n\n\n\n\n\n\n\n\n\n"
10:10:48 <ski_> > snd $ runWriter (forever (tell "\n"))
10:11:04 <lambdabot>   thread killed
10:11:14 <quicksilver> ski_: yes, it's quite cool you can do that with writer.
10:11:29 <Killakl0wn> hi guys
10:11:30 <quicksilver> you can't get anything interesting out of state in that way.
10:11:39 <ski_> one could think of the above output semantics of `IO' in a similar way
10:11:42 <quicksilver> at least I don't think you can?
10:11:53 <Killakl0wn> does xmoand have a menu feature?
10:12:03 <quicksilver> which is interesting in itself, in that it's often said that writer could be implemented on top of state.
10:12:39 <quicksilver> ...and that's true, in the total fragment of haskell.
10:12:40 <b_jonas> yeah
10:13:04 <raxas> Killakl0wn: some of us use dmenu with xmonad
10:14:06 <dons> RWH finalist in Dr.Dobbs "ahead of the curve" awards, http://www.joltawards.com/finalists.html
10:14:19 <quicksilver> dons: awesome!
10:14:24 <quicksilver> dons: congrats, and good luck
10:14:24 <daf> huh
10:14:43 <daf> there was a recent Dr. Dobbs article that wasn't entirely fair to Haskell, I thought
10:14:47 <dons> i wonder if we could actually win this "technical book" section (do the judges know we used wikis and open source?)
10:14:50 <quicksilver> dons: is that nominated by the public, or by a panel of experts?
10:15:03 <dons> not sure. oreilly might have nominated
10:15:09 <dons> i only found out now that we're finalists.
10:16:03 <RayNbow> dons, http://www.scientia.demon.nl/RWH.jpg (crappy picture, but I don't have a good cam :p)
10:16:14 <dons> yay!
10:16:22 <quicksilver> dons: I don't see anythign in the rules which would outlaw you for having used a wiki.
10:16:34 <quicksilver> dons: Oh, I took a photo of my RWH with my iPhone and snapTell identified it correctly :)
10:16:36 <dons> quicksilver: no, i'm saying: if they knew that, we might win :)
10:16:46 <dons> since it would be "ahead of the curve" :)
10:16:49 <quicksilver> ;)
10:17:15 <Killakl0wn> raxas: when i say menu... i mean like a drop down menu
10:18:24 <raxas> Killakl0wn: I know a guy who said he sent a drop down patch back to dmenu project, perhaps it is there :)
10:18:24 <gwern> RayNbow: dmenu? you should use Prompt
10:18:25 <luite> hm, but even with an unboxed array, a: listArray (1,50000000) [1..] :: UArray Int Int  is still much (about 3x) slower than filling an array in Java. is there anything that's faster?
10:19:10 <quicksilver> luite: which part of it slower? you're just measuring setup time?
10:19:50 <raxas> Killakl0wn: and he has it running well on his eee, I have seen it, so it exists :)
10:19:59 <Botje> luite: STUArray or IOUArray
10:20:21 <quicksilver> Botje: why would IOUArray be faster setup than UArray?
10:20:23 <RayNbow> gwern: hmm?
10:20:24 <Killakl0wn> ahhh
10:20:28 <Killakl0wn> i see
10:20:30 <quicksilver> (aren't they the same structure underneath?)
10:20:33 <Botje> oh
10:20:34 <Killakl0wn> just thought it was kinda built in
10:20:36 <Killakl0wn> :(
10:20:40 <Botje> oh, i see.
10:20:46 <gwern> RayNbow: er. I mean raxas
10:20:49 <luite> quicksilver: yes, just setting up the array and then printing the first element is much slower. I know it's not a great test, but it does seem te take about 30% of the total time of my simple 'shuffle the array' benchmark
10:20:52 <gwern> raxas: dmenu? you should use Prompt
10:21:12 <Botje> i thought he was filling in each element separately
10:21:14 <Botje> never mind :)
10:21:40 <quicksilver> luite: well setup from a constant list is going to be a lot slower than java's default "Set everything to zero" behaviour.
10:21:41 <RayNbow> gwern: ah... well, there are many R-nicks in this channel... tab-accidents are bound to happen :p
10:21:43 <luite> quicksilver: I changed the number generator to the impure mersenne-twister by dons, zo now the array operations seem to take most of the cpu time
10:22:01 <quicksilver> luite: java can just use the underlying OSes "alloced zeroed block of memory"
10:22:04 <luite> quicksilver: I use a loop to fill the array with those values in java
10:22:09 <quicksilver> luite: and you're making haskell traverse a list.
10:22:15 <gwern> RayNbow: quite. I made the assumption that 'ra' would be unique to raxas, forgetting irssi would also complete on uppercased nicks as well
10:22:28 <luite> otherwise I would've used a newArray (1,5000000) 0 and then freeze it :)
10:22:32 <b_jonas> there are more s-nicks
10:22:57 <luite> quicksilver: or perhaps even a newArray_ as it probably defaults to 0
10:23:02 <quicksilver> luite: erm, I'm not confused. You're not using a constant list?
10:23:09 <quicksilver> luite: you're setting it to actual values?
10:23:47 <Botje> int foo[50000000]; for (int i = 0; i < 50000000; i++) foo[i] = i;
10:23:52 <luite> quicksilver: listArray (1,5000000) [1..] , so every index has a value that's the same as its index
10:24:08 <luite> but my java array is zero based
10:24:08 <quicksilver> might be faster ot use unsafeWrite
10:24:14 * quicksilver checks the source of listArray
10:24:49 <quicksilver> hmm, no listArray should use unchecked access anyway
10:24:53 <luite> Botje: you have to use new in java, but the rest is about the same as I have here :)
10:24:54 <quicksilver> as far as I can follow this code.
10:25:23 <quicksilver> luite: you are compiling with -O2 I hope?
10:25:29 <luite> quicksilver: yes
10:25:32 <luite> ghc 6.10.1
10:26:00 <quicksilver> OK, I don't know. I guess java arrays are probably pretty close to optimal code, it being a common path
10:26:06 <quicksilver> you could try uvector
10:29:05 <Cale> http://i39.tinypic.com/16abhn7.jpg -- haha
10:29:31 <luite> quicksilver: I'll try that then
10:29:43 <b_jonas> is [::] some ghc internal type?
10:30:02 <quicksilver> b_jonas: is that the data parallel array stuff?
10:30:26 <RayNbow> Cale: Ctrl+Alt+Del, Ctrl+Alt+Del, Ctrl+Alt+Del! :p
10:30:27 <b_jonas> no idea
10:30:28 <Cale> Yeah, it's DPH
10:30:47 <Cale> [:a:] is the type of a data parallel array whose elements are of type a
10:31:03 <luite> the speed has already greatly improved by switching to a UArray, and using mersenne-random instead of MonadRandom with a stdGen, but I still want to see if I can squeeze out a little more speed :)
10:31:32 <b_jonas> ok, data parallel -> I found that in the manual, thanks
10:31:57 <luite> MonadRandom may still be usable with the pure mersenne-random, although it doesn't support split, which makes things a bit more hairy
10:32:00 <b_jonas> I was asking because it appears in the haddock docks for core but it's not linked
10:34:34 <luite> oh by the way, how can I do an unchecked write?
10:34:42 <quicksilver> maybe the weird syntax confuses haddock, b_jonas
10:34:42 <luite> in a STUArray
10:34:46 <quicksilver> luite: unsafeWrite
10:34:59 <quicksilver> you need to import Data.Array.Base to get the unsafe stuff
10:35:06 <quicksilver> (they're in the MArray interface but hidden by default)
10:35:58 <luite> quicksilver: ah thanks
10:38:32 <b_jonas> quicksilver: [] and (,) stuff isn't linked to either, I think it just doesn't link to builtin syntax, only names
10:40:01 <RayNbow> > let (,) x y = x+y in (,) 1 2
10:40:02 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t, t)
10:40:02 <lambdabot>        Exp...
10:41:04 <ski_> > let (,) x y = 17 `divMod` 7 in x + y
10:41:05 <lambdabot>   5
10:42:04 <idnar> huh?
10:42:25 <idnar> oh, pattern matching
10:42:40 <idnar> I thought that was defining (,)
10:43:48 <kpreid> consider , as a constructor name, even tho it has no colon
10:44:13 <idnar> yeah
10:44:28 <zeno> if i have a StdGen, the best way to get a random number 0 to x is head $ randomRs (0,x) gen?
10:44:46 <mauke> :t randomR
10:44:48 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
10:45:13 <zeno> thanks
10:45:52 <Cale> zeno: Note that with randomR, you'll also get another StdGen to use for the next random number.
10:46:38 <Cale> (this is important, using the same StdGen will result in the same number)
10:47:24 <zeno> Cale: ok thansk
10:53:52 <orbitz> @pl \x -> x /= "foo" && x /= "bar"
10:53:52 <lambdabot> liftM2 (&&) ("foo" /=) ("bar" /=)
10:55:17 <twanvl> `notElem` ["foo","bar"]
10:56:00 <dons> Use -feager-blackholing with GHC >= 6.11
10:56:03 <dons> interesting
10:56:14 <orbitz> twanvl: hah tahnks
10:57:35 <redditbot> Bridging Python and Haskell
10:57:35 <redditbot> Smarter termination for thread racing
11:00:02 <quicksilver> dons: ?
11:08:37 <zeno> hmmm why isnt the last element ever shuffled? http://hpaste.org/13193
11:09:25 <zeno> also seems like i could make randDesc a foldl...
11:14:38 <psnively> Hi everyone. :-)
11:14:43 <dons> hey psnively
11:15:22 <psnively> Hi Don!
11:15:34 <psnively> Congrats on RWH's success. :-)
11:16:49 <thomashartman1> why doesn't parsec 3 install via cabal install parsec (or cabal install parsec-3)?
11:17:00 <thomashartman1> Is the only way to install this to download and untar?
11:17:09 <dons> thomashartman1: parsec 2 is the default
11:17:13 <dcoutts> thomashartman1: use cabal install 'parsec >= 3'
11:17:13 <dons> so give the full version number
11:17:20 <dons> or a range
11:17:21 <wchogg> I'm looking forward to getting my paper copy of RWH soon
11:17:23 <dons> psnively: thanks!
11:17:33 <daf> where does hte default come from?
11:17:39 <dcoutts> daf: from hackage
11:17:48 <daf> cunning
11:18:30 <dcoutts> it's mostly a hack to keep old packages working when those old packages did not properly specify version constraints
11:18:48 * dcoutts hacks on install constraints for cabal install
11:18:51 <psnively> Hi wchogg. :-)
11:19:07 * dcoutts wants to be able to cabal install foo --constraint='bar installed'
11:19:27 <thomashartman1> thx dcouts
11:19:55 <dcoutts> to mean, if foo depends on bar (directly or indirectly) then only use the installed version of bar, not any available version, so prevent bar from being reinstalled.
11:40:07 <luite> http://hpaste.org/13186#a1 <- does anyone see something obvious that can still be optimized? productivity is around 95% according to the profiler, so I guess I shouldn't be too worried about the large number of allocated bytes?
11:44:05 <luite_> oh, disconnected :(
11:44:10 <luite_> http://hpaste.org/13186#a1 <- does anyone see something obvious that can still be optimized? productivity is around 95% according to the profiler, so I guess I shouldn't be too worried about the large number of allocated bytes?
11:44:36 <arjanb> i think the problem is in some of lists not being optimized away
11:44:55 <quicksilver> did you try unsafe read/write?
11:45:23 <luite_> arjanb: I tried to make a recursive function that fills the array without using a list, but that hardly changes the execution time
11:45:33 <luite_> quicksilver: yes, the difference is very small
11:46:06 <arjanb> and for the swapNodes function?
11:47:45 <quicksilver> ISTR zip doesnt fuse?
11:47:48 <luite_> arjanb: I've already experimented with that, but I'll make a recursive version that only uses the list of random numbers
11:48:27 <gradda> hmm im really torn between haskell and clojure. i just find it dumb with dynamic languages that i have to document a lot that i get for free with haskell. but then there always seems to be something with haskell that makes life to difficult
11:48:54 <quicksilver> if you want to understand more luite_ you may have to learn how to read core and assembly....
11:50:39 <zeno> gradda: what do you mean? when you want state?
11:50:50 <luite_> quicksilver: I tried, using ghc-core, but it was quite a shock ;)
11:50:59 <lament> isn't Clojure for when you want to use JVM libraries?
11:51:27 <orbitz> is (++) string?
11:51:31 <mauke> :t (++)
11:51:33 <lambdabot> forall a. [a] -> [a] -> [a]
11:52:01 <augustss> orbitz: lambdabot says no
11:52:05 <zeno> orbitz: a srtring is [Char] so ++ works
11:52:10 <apsod> Is there an existing function in Prelude which removes duplicate values from a list?
11:52:17 <augustss> nub
11:52:17 <mauke> :t nub
11:52:19 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:52:24 <apsod> Thanks :)
11:52:49 <augustss> nub is inefficient for big lists
11:53:14 <mauke> :t S.toList . S.fromList
11:53:15 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:53:17 <apsod> My lists should always be < 50 elements, so it'll probably work fine.
11:53:33 <augustss> yeah, that's fine
11:53:52 <dcoutts> we just need a sort that eliminates duplicates
11:54:08 <dcoutts> it should be a pretty simple variation on a merge sort
11:54:20 <zachk> tally sort removes duplicates
11:54:41 <zachk> but it only works on Integers
11:54:56 <BONUS_> @seen dons
11:54:56 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 37m 34s ago.
11:55:08 <quicksilver> dcoutts: is it a key problem do you think?
11:55:18 <zeno> why not just sortNub = nub . mergeSort
11:55:19 <quicksilver> If I need to remove duplicates I often just switch to Map or Set
11:55:22 <dcoutts> quicksilver: hmm, what do you mean?
11:55:39 <quicksilver> I mean, is a dup-removing sort a common enough need to want one in the std lib?
11:55:42 <zeno> or is nub still slow on sorted lists
11:55:48 <quicksilver> zeno: yes, it is.
11:55:57 <athos> :t \5
11:55:58 <lambdabot> parse error (possibly incorrect indentation)
11:56:01 <athos> :t \5 -> 5
11:56:02 <lambdabot> forall t t1. (Num t1, Num t) => t -> t1
11:56:02 <zeno> @src nub
11:56:03 <lambdabot> nub = nubBy (==)
11:56:06 <zeno> @src nubBy
11:56:06 <lambdabot> nubBy eq []             =  []
11:56:06 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:56:07 <dcoutts> quicksilver: I think so, I often find myself doing: map head . group . sort
11:56:21 * quicksilver nods
11:56:44 <athos> > (\5 -> 5*8) 2
11:56:45 <lambdabot>   * Exception: /tmp/5739634481746067809:71:49-57: Non-exhaustive patterns in ...
11:56:51 <athos> :(
11:57:04 <athos> > (\5 -> 5) 2
11:57:05 <lambdabot>   * Exception: /tmp/2386302198672250549:71:45-51: Non-exhaustive patterns in ...
11:57:11 <ski_> > let 5 = 2 in 5*8
11:57:12 <lambdabot>   40
11:57:19 <athos> :>
11:57:34 <athos> don't fuck with lambdabot!
11:57:55 <Heffalump> let 1+1 = 3 in 1+1
11:57:56 <Heffalump> > let 1+1 = 3 in 1+1
11:57:58 <lambdabot>   3
11:58:04 <athos> hehe
11:58:05 <ski_> > let (5,x) = (2,()) in case x of () -> 5*8
11:58:06 <lambdabot>   * Exception: /tmp/739283839006965490:71:52-65: Irrefutable pattern failed f...
11:58:20 <ski_> > let (~ 5,x) = (2,()) in case x of () -> 5*8
11:58:22 <lambdabot>   40
11:58:38 <quicksilver> hurrah for lazy fives :P
11:58:40 <Saizan> to deamonize an haskell program i've to use a wrapper in C?
11:58:41 <augustss> > let 1 + (+) = (+) in 1 + 2
11:58:42 <lambdabot>   2
11:59:09 <quicksilver> Saizan: or fork and exec a fresh copy of yourself
11:59:14 <orbitz> err
11:59:15 <quicksilver> Saizan: you just can't fork and keep running, safely.
11:59:16 <orbitz> i meant strict
11:59:17 <orbitz> not strign
11:59:20 <orbitz> string*
11:59:27 <b_jonas> augustss: er what?
11:59:37 <orbitz> augustss: i mean, is (++) strict
11:59:39 <quicksilver> orbitz: (++) is left-strict.
11:59:42 <b_jonas> @type let { 1 + (+) } in (+)
11:59:43 <lambdabot> parse error on input `}'
11:59:45 <quicksilver> > undefined ++ [1,2,3,4]
11:59:46 <lambdabot>   * Exception: Prelude.undefined
11:59:51 <luite_> arjanb: I replaced the zip and swapNodes function with a new function that uses only one list: http://hpaste.org/13186#a2
11:59:53 <b_jonas> @type let { 1 + (+) = (+) } in (+)
11:59:55 <lambdabot> forall t t1. (Num t) => t -> t1 -> t1
11:59:56 <quicksilver> > [1,2,3,4] ++ undefined
11:59:57 <lambdabot>   [1,2,3,4* Exception: Prelude.undefined
12:00:03 <luite_> arjanb: but it does not run any faster
12:00:24 <quicksilver> luite_: are you testing running speed with profiling turned off?
12:00:35 <b_jonas> > let { f f = 2 * f } in f 5
12:00:37 <lambdabot>   10
12:00:39 <b_jonas> crazy
12:00:53 <augustss> > let 1 + ((+) + 1) = (+) in 1 + 2 --- lambdabot, do you do n+k yet?
12:00:54 <lambdabot>   1
12:01:16 <ski_> @type (---)
12:01:18 <lambdabot> parse error (possibly incorrect indentation)
12:01:41 <ski_> is that a legal operator name ?
12:01:46 <augustss> No
12:01:47 <quicksilver> yes.
12:01:56 <augustss> No
12:02:04 <ski_> obviously augustss and quicksilver now must fight to the death
12:02:14 <quicksilver> augustss is right
12:02:15 <augustss> > 1 --- 2
12:02:17 <lambdabot>   1
12:02:19 <quicksilver> (not very surprising, I guess)
12:02:37 <wchogg> You still have to fight, actually.  No conceding the point.
12:02:39 <augustss> I was there when we decided :)
12:02:42 <luite_> quicksilver: yes, just using time
12:02:53 <quicksilver> I could have sworn I'd used --- as a combinator
12:02:57 <vixey> @type (-->)
12:02:58 <lambdabot> parse error (possibly incorrect indentation)
12:02:58 <quicksilver> that must have been ocaml, then
12:03:02 <arjanb> luite_: i guess you have to dive into core then..
12:03:04 <gradda> clojure is for functional+dynamic+macros+java-libs+jvm
12:03:05 * quicksilver is quite senile these days.
12:03:06 <athos> @tpye (-> a)
12:03:06 <lambdabot> Maybe you meant: time type
12:03:10 <athos> @type (-> a)
12:03:11 <lambdabot> parse error on input `->'
12:03:13 <vixey> @type (<--)
12:03:14 <lambdabot> parse error (possibly incorrect indentation)
12:03:30 <luite_> arjanb: hehe, was afraid of that :)
12:03:38 <luite_> it looks kinda, scary
12:03:39 <quicksilver> augustss: being there when the decision is made is the easy part. It's remembering the decision that's hard. ;P
12:03:51 <vixey> it's so you can do
12:03:52 <vixey> -----------------------
12:03:54 <quicksilver> luite_: which JVM, by the way?
12:03:56 <vixey> -- Section 1
12:03:57 <vixey> -----------------------
12:04:13 <augustss> > let (+) + 1 + 1 = (+) in 2 + 1
12:04:15 <lambdabot>   1
12:04:51 <quicksilver> luite_: because if it's hotspot, that may be tricky to beat. Sun's JIT is very good at certain things, and I wouldn't be surprised if tight array loops were one of them.
12:05:23 <luite_> quicksilver: 1.6 64 bit, linux. the client and server jit compiler are about equally fast
12:05:25 <augustss> > let (+) + 1 + ((-) + 1) = (+)*(-) in 3+3
12:05:26 <lambdabot>   mueval: Prelude.read: no parse
12:05:26 <lambdabot>  mueval: GhcException mueval: panic! (the 'i...
12:05:34 <augustss> ack!
12:05:43 <augustss> Hemlock is poison.
12:05:46 <quicksilver> luite_: java uses 32 bit pointer, that's quite a big win sometimes.
12:05:56 <Heffalump> so how come that pattern doesn't count as non-linear?
12:05:58 <quicksilver> augustss: good work :)
12:06:08 <luite_> quicksilver: yes, I'm afraid that it can also cheat a little by using 32 bit ints
12:06:29 <quicksilver> luite_: would be interesting to compare 32 bit compiles as well, just to eliminate that variable.
12:07:06 <ski_> Heffalump : "n+k" ?
12:07:29 <quicksilver> @tell gwern augustss wins, you lose.
12:07:30 <lambdabot> Consider it noted.
12:07:42 <Heffalump> ski_: ah
12:08:11 <quicksilver> luite_: have you also compared at different sizes?
12:08:16 <SamB> wins what ?
12:08:17 <quicksilver> luite_: 10x smaller and 4x bigger, say?
12:08:28 <quicksilver> cache effects can be subtle.
12:08:37 <quicksilver> SamB: augustss made mueval panic.
12:08:42 <SamB> augustss: what was that supposed to do anyway ?
12:08:43 <quicksilver> SamB: it was only a joke on my part.
12:08:49 <athos> @src (</>)
12:08:49 <lambdabot> Source not found. :(
12:09:00 <quicksilver> @index (</>)
12:09:01 <lambdabot> Text.Html
12:09:06 <ski_> SamB : give `4', of course
12:09:17 <quicksilver> I'm not sure that's the one I was thinking of.
12:09:33 <athos> there's a </> in System.FilePath
12:09:45 <quicksilver> athos: yeah, not sure why index didn't find that one too
12:10:24 <luite_> quicksilver: I've tried smaller, java is still faster. but I should use more than one iteration for testing small sizes, because otherwise I'm mainly measuring rts startup overhead
12:10:34 <augustss> > let (+) + 1 + ((-) + 1) = (+)*(-) in 3 + 3
12:10:35 <lambdabot>   mueval: Prelude.read: no parse
12:10:35 <lambdabot>  mueval: GhcException mueval: panic! (the 'i...
12:10:53 <augustss> lambdabot, you fail!  That works in ghci
12:11:12 <SamB> the output from -ddump-parsed for that is really wierd looking ...
12:11:18 <SamB> ==================== Parser ====================
12:11:18 <SamB> Just let ++1 + (-+1) = (+) * (-) in 3 +
12:11:24 <apsod> augustss: Doesn't ghci have different mechanics for let?
12:11:36 <SamB> apsod: it's an expression though
12:11:44 <SamB> not a monadic-style let
12:11:58 <augustss> SamB: It's not weird.  It's normal Haskell. :)
12:12:06 <quicksilver> luite_: yes, or try all the sizes in one run
12:12:07 <athos> > let true? = (==) True in true? False
12:12:08 <lambdabot>   <no location info>: parse error on input `='
12:12:11 <quicksilver> luite_: so there is only one startup.
12:12:22 <bsod> > 1+1
12:12:23 <lambdabot>   2
12:12:25 <SamB> "Just let ++1" is normal ?
12:12:30 <bsod> oh nice
12:12:37 <quicksilver> luite_: at some point you're cache spilling, it occurred to me to wonder if 10M is enough to cache spill GHC much worse than it cache spills java
12:12:40 <quicksilver> luite_: but I'm not sure.
12:12:44 <athos> > let true? a = a == True in true? False
12:12:45 <lambdabot>   Not in scope: `true'
12:12:53 <athos> :()
12:12:53 <augustss> SamB: Oh, that bit?  Highly unnormal!
12:13:10 <ski_> athos : no `?' in identifiers
12:13:11 <athos> > (\? -> ? + 5) 1
12:13:12 <lambdabot>   <no location info>: parse error on input `->'
12:13:16 <athos> ski_: okay ;)
12:13:22 <athos> that's what i was trying to figure out
12:13:38 <augustss> > (\(?) -> (?) + 5) 1
12:13:40 <lambdabot>   6
12:13:57 <apsod> heh
12:14:08 <orbitz> t (?)
12:14:10 <orbitz> :t (?)
12:14:11 <athos> hehehe
12:14:12 <lambdabot> Not in scope: `?'
12:14:38 <luite_> quicksilver: hm, that's possible, I'll try 32bit first
12:15:13 <ski_> SamB : seems it was forgetting a few brackets on output ..
12:16:41 <athos> :t forM
12:16:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
12:16:51 <athos> :t liftM
12:16:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:17:08 <ski_> @type flip mapM
12:17:09 <athos> :t mapM
12:17:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
12:17:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:17:14 <athos> :
12:17:15 <athos> :)
12:19:09 <augustss> :t mapM mapM [mapM]
12:19:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a -> m b] -> [[a] -> [m [b]]]
12:19:31 <athos> :t return $ map (return.f) xs
12:19:32 <lambdabot> Not in scope: `xs'
12:19:59 <augustss> :t mapM mapM [mapM] [mapM]
12:19:59 <athos> :t return $ map (return.f) [x,y,z]
12:20:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [[a -> m b] -> [[a] -> [m [b]]]]
12:20:00 <lambdabot> forall (m :: * -> *) b (m1 :: * -> *). (SimpleReflect.FromExpr b, Monad m1, Monad m) => m [m1 b]
12:20:54 <hellige> @seen Peaker
12:20:55 <lambdabot> Peaker is in #haskell-overflow, #haskell-blah and #haskell. I last heard Peaker speak 4h 56m 1s ago.
12:21:03 <athos> :t map
12:21:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:21:08 <athos> hm
12:21:14 <jeffwheeler> @pl \city -> path graph (findV start) (findV city)
12:21:14 <lambdabot> path graph (findV start) . findV
12:21:14 <augustss> I'll offer a small price to anyone using mapM mapM [mapM] [mapM] in real code. :)
12:21:30 <augustss> prize
12:21:33 <augustss> even
12:23:15 <athos> @src mapM
12:23:15 <lambdabot> mapM f as = sequence (map f as)
12:23:16 <jeffwheeler> @pl \(a, b) -> (findV a, findV b)
12:23:16 <lambdabot> findV *** findV
12:23:52 <Heffalump> augustss: where it's actually needed?
12:23:55 <athos> @type sequence
12:23:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:24:05 <augustss> Heffalump: I have no clue. :)
12:24:27 <Heffalump> no, I mean does it actually have to be needed in the real code to be eligible for the prize :-)
12:25:03 <augustss> Well, you can't just stick it in there and ignore it. :)
12:25:17 <arussel> doing a "Programming in haskell" exercise, 7.8.6.: define the function curry that converts a function on pairs into a curried function. (Please don't give the answer)
12:25:46 <Heffalump> but I could probably rescue the internal mapM from the result and just apply that afterwards
12:25:54 <augustss> arussel: ah yes.  I remember the first time I did that.  I was stumped.
12:26:27 <arussel> that mean, given: "funonpair (x,y) = 2" I should be able to write "(curry funonpair) 1 2" and it should return 2. Isn't it ?
12:26:28 <hellige> it's hard to come up with a good hint, though...
12:26:49 <Beelsebob_> arussel: yep, exactly
12:27:03 <hellige> arussel: yes, but it's more confusing since you use 2 twice.
12:27:04 <Beelsebob_> arussel: hint -- returning a function is the same thing as a multi-argument function in Haskell
12:27:12 <hellige> (curry funonpair) 1 3 == 2 also
12:27:19 <arussel> at least I got a unit test case :-)
12:27:25 <augustss> Heffalump: I'll offer up to 6 beers, but it has to look vaguely plausible, or beer will be deducted from the 6.
12:27:34 <Heffalump> :-)
12:27:36 <mauke> arussel: what would be the type of that function?
12:27:46 <arussel> mycurry :: ((x,y) -> z) -> (x -> y -> z)
12:27:56 <mauke> excellent
12:28:03 <earthy> mapM mapM [mapM] [mapM]
12:28:05 <mauke> too bad I can't tell you about @djinn :-)
12:28:05 <earthy> hm.
12:28:33 * wli offers up to 6000 beers for a higher-order parametrized module system implementation included in a major Haskell compiler (not necessarily ghc).
12:28:48 <augustss> arussel: you can construct the function just from looking at the type.
12:28:53 <earthy> wli: can I get that in beer-money? :P
12:28:55 <Beelsebob_> arussel: prop-curry = \x y -> f (x,y) == (curry f) x y -- now you have lots of test cases?
12:28:56 <hellige> arussel: remember that x -> y -> z is x -> (y -> z)
12:29:04 <ski_> @type [\mas -> [mapM mapM mas]]
12:29:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [[a -> m b] -> [[a] -> [m [b]]]]
12:29:16 <hellige> arussel: so how do you create a function of type x -> ...
12:29:35 <mathijs> small question: how does haskell know that span won't put any extra values in the fst part of: fst . span (<10) $ [1..] ?
12:29:45 <wli> earthy: I wasn't going to pay retail for the beer, so as money it'll be nowhere near as much.
12:29:50 <mauke> mathijs: huh?
12:30:06 <vixey> does djinn use tableux?
12:30:06 <mathijs> I mean... this expression still terminates, which is perfectly logical, but I wouldn't think that myself.
12:30:19 <orbitz> > fst . span (<10) $ [1..]
12:30:21 <lambdabot>   [1,2,3,4,5,6,7,8,9]
12:30:24 <earthy> well, 6000 beers is still some 900l of beer
12:30:29 <mauke> why do you think it shouldn't terminate?
12:30:32 <vixey> > span (<10) $ [1..]
12:30:33 <lambdabot>   ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
12:30:37 <orbitz> > span (<10) $ [1..]
12:30:38 <lambdabot>   ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
12:30:42 <earthy> even in kegs at wholesale value that's quite a bit of money
12:30:44 <SamB> mathijs: span stops looking after the predicate stops returning true
12:30:52 <SamB> mathijs: maybe you're thinking of partition
12:31:03 * earthy is boggled by the type of  mapM mapM [mapM] [mapM]
12:31:05 <augustss> vixey: No
12:31:28 <mathijs> SamB: ah, ok so it wont recurse any longer when the predicate no longer holds
12:31:31 <vixey> I wonder what algorithm to solve these problems
12:31:33 <mathijs> @src span
12:31:33 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:31:40 <vixey> (to use)
12:31:49 <wli> earthy: 1000 six-packs, 12000 oz, 354.88235 L?
12:32:31 <ski_> vixey : which ?
12:32:31 <augustss> vixey: It uses a decision procedure for Gentzen's LJ calculus
12:32:56 <wli> Or is it 24 floz/709.7641mL?
12:33:11 <augustss> vixey: I just stole the algorithm. :)
12:33:29 <ziman> mathijs, "fst . span p" is also known as "takeWhile p" (which quite well suggests its behavior, imo)
12:33:40 <ski_> @pl fst . span p
12:33:40 <lambdabot> fst . span p
12:33:48 <SamB> @go 1000 * 12 oz in liters
12:33:49 <Heffalump> augustss: do you know anything about solving integer linear constraints, btw?
12:33:50 <lambdabot> 1000 * 12 US fluid ounces = 354.882355 liters
12:33:56 <augustss> Someone needs to fix @src
12:33:56 <mathijs> ziman: I figured that out :)  I was indeed confused with partition
12:34:13 <augustss> Heffalump: omega, perhaps
12:34:18 <SamB> @go 1000 * 12 oz of beer in liters
12:34:20 <lambdabot> No Result Found.
12:34:41 <earthy> samb: he was talking about 6000 beers though
12:34:54 <earthy> I was taking 'a beer' to be 150 ml
12:35:07 <Heffalump> augustss: ahah, thanks.
12:35:24 <augustss> Heffalump: but it's only for Presburger arithmetic
12:35:40 <earthy> (and that's the small dutch beers, normally you'd go for 250ml in a glass of beer)
12:35:44 <Heffalump> I think that's all I need.
12:36:15 <Apocalisp> @go 64 Bacardis on the rocks in litres
12:36:18 <lambdabot> No Result Found.
12:36:21 <Apocalisp> boo
12:36:29 <Heffalump> though I also have logical connectives and quantification in the formulae I want to deal with, so it might not do everything I want.
12:36:48 <augustss> Heffalump: that's fine
12:36:56 <earthy> btw, anybody looked at re-implementing something like frink in Haskell?
12:39:14 <augustss> earthy: there's a unit package for Haskell
12:39:52 <earthy> couldn't find it last time I was looking for it
12:40:00 <earthy> what's it called?
12:40:26 <thedward> dimensional
12:40:35 <oklopol> > 0
12:40:37 <lambdabot>   0
12:40:44 <thedward> (is the package for doing match with units)
12:41:07 <augustss> there's also something called caldims
12:41:39 <augustss> But dimensional is newer
12:42:13 <earthy> caldims I did find, but it didn't seem to cover the unit flexibility frink provides
12:42:17 <earthy> I'll take a look at dimensional
12:43:27 <Gracenotes> hey, what's the function that returns the unique elements from a list?
12:43:37 <Riastradh> nub?
12:43:37 * Gracenotes forgot...
12:43:46 <Gracenotes> ah, I think that's it
12:43:46 <sereven> earthy: http://www.updike.org/articles/Units might be of interest, too
12:44:02 <Gracenotes> thanks
12:45:45 <gwern> Gracenotes: what are you doing?
12:45:45 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
12:47:11 <Gracenotes> gwern: http://en.wikipedia.org/wiki/Proofs_of_Fermat%27s_little_theorem#Proof_by_counting_bracelets
12:47:58 <stu8ball> Is nub a word or does it stand for something?
12:48:03 <quicksilver> it's a word.
12:48:05 <stu8ball> 'Number of Unique B...'?
12:48:06 <stu8ball> ah
12:48:13 <gwern> @wn nub
12:48:14 <SamB> what ?
12:48:14 <stu8ball> Never heard it.
12:48:15 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
12:48:15 <lambdabot> nub
12:48:15 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
12:48:15 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
12:48:15 <lambdabot>      3: the choicest or most essential or most vital part of some
12:48:17 <lambdabot> [5 @more lines]
12:48:19 <stu8ball> ah
12:48:20 <shapr> @hackage turbinado
12:48:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/turbinado
12:48:34 <gwern> dammit, my ghc seems to be screwed up
12:48:39 * quicksilver peers doubtfully at shapr
12:48:45 <shapr> quicksilver: Doesn't exist?
12:48:55 <gwern> if I reinstall ghc 6.10 the same way as I did the first time, will that wipe out all my installed libraries?
12:49:13 <quicksilver> shapr: apparently not.
12:49:18 <shapr> aww
12:49:22 <earthy> sereven: that looks interesting! thanks!
12:49:28 <SamB> should it ?
12:50:27 <gwern> SamB: was that to me?
12:53:44 <SamB> gwern: no
12:54:25 <arussel> I would like to write something like: "mycurry \(x,y)->z = \x y-> z" but ghc is not very enthusiastic about it.
12:56:06 <augustss> arussel: So you know the type is ((x,y)->z)->x->y->z.  How many arguments does this function have?
12:56:35 <augustss> arussel: It's not a trick question. :)
12:56:52 <arussel> can I trust you ? ;-)
12:56:57 <augustss> yes
12:57:34 <lament> HE LIES
12:57:49 <augustss> arussel: So if you write mycurry ... =, how many variables at ...?
12:57:59 <arussel> lament: it can't be, he told me I could trust him.
12:58:06 <arussel> a ...wait a sec
12:58:06 <Apocalisp> arussel: mycurry f x y = f (x, y)
12:58:22 <augustss> Apocalisp: he did not want to be told
12:58:37 <Apocalisp> oops!
12:58:44 <Apocalisp> Hadn't read that far, sorry.
12:58:52 <arussel> np
12:59:12 <Apocalisp> @src curry
12:59:12 <lambdabot> curry f x y = f (x, y)
12:59:22 <augustss> @djinn ((x,y)->z)->(x->y->z)
12:59:22 <Apocalisp> hah
12:59:22 <lambdabot> f a b c = a (b, c)
12:59:25 <athos> :t curry (+)
12:59:26 <lambdabot> forall a b. (Num (a, b)) => a -> b -> (a, b) -> (a, b)
12:59:26 <orbitz> is mapM strict?
12:59:40 <athos> 8]
12:59:54 <chrisdone> @src mapM
12:59:54 <lambdabot> mapM f as = sequence (map f as)
12:59:58 <mauke> curry f = \x y -> f (x, y)
12:59:58 <chrisdone> @src sequence
12:59:59 <lambdabot> sequence []     = return []
12:59:59 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:59:59 <lambdabot> --OR
12:59:59 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:59:59 <athos> :t curry (+) 5 4
13:00:00 <lambdabot> forall a b. (Num b, Num a, Num (a, b)) => (a, b) -> (a, b)
13:01:03 <chrisdone> > take 1 $ mapM (return . id) [0..]
13:01:06 <lambdabot>   * Exception: stack overflow
13:01:11 <orbitz> :(
13:01:32 * orbitz is tryign to take a list of filenames, and return a list of all the lines
13:02:16 <chrisdone> concat . lines `fmap` mapM readfile?
13:02:26 <chrisdone> uh
13:02:30 <wchogg> @seen conal
13:02:30 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
13:02:34 <chrisdone> lines . concat `fmap` mapM readFile
13:02:46 <mauke> heh, nice
13:02:48 <chrisdone> orbitz: why's the laziness relevent?
13:02:54 <Saizan> you miss a (.)
13:02:57 <augustss> chrisdone: except it binds wrong
13:03:01 <orbitz> chrisdone: beacuse i'll be workign with 30gb of data
13:03:12 <chrisdone> ah
13:03:22 <quicksilver> orbitz: I believe you misunderstand the meaning of 'lazy' and 'strict'.
13:03:27 <chrisdone> yeah fmap wants m a, not b -> m a, ja
13:03:41 <orbitz> quicksilver: how so?
13:03:47 <quicksilver> orbitz: the laziness you are looking for is the tricksy interleaved IO stuff
13:04:00 <quicksilver> which is different from plain old lazines
13:04:06 <orbitz> oh ok
13:04:11 <quicksilver> and asking if mapM is strict doesn't really get to the heart of it.
13:04:16 <augustss> Tricksy indeed!
13:04:30 <quicksilver> What you have to ask is "is mapM in IO productive - can it yield partial results"
13:04:34 <quicksilver> the answer is "no"
13:04:40 <quicksilver> you'll have to stuff an unsafeInterleave into your mapM
13:05:02 <orbitz> is what i am tryig nto do the wrong way i nthe first place?
13:05:17 <quicksilver> augustss: I have recently been thinking to campaign completely against the word 'lazy' for this lazy IO. I'm thinking we should call it interleaved IO, or something.
13:05:31 <quicksilver> because it is gives true laziness a bad name.
13:05:37 <chrisdone> orbitz: according to poppavic, probably
13:05:43 <augustss> quicksilver: yeah, I'm with ya on that one.
13:05:44 <chrisdone> if yer dealing with 30gb of data, yer just wrong
13:05:51 <orbitz> haha
13:05:59 <quicksilver> orbitz: not necessarily; what you try to do is probably possible with correct placement of unsafeInterleave
13:06:08 <quicksilver> orbitz: although I'd worry about when the file gets closed.
13:06:14 <dons> ?userrs
13:06:14 <lambdabot> Maximum users seen in #haskell: 575, currently: 556 (96.7%), active: 32 (5.8%)
13:06:15 <wchogg> conal : Question for when you're back on how liftM2 should work with Event.  Should the output stream have a 1 event for each each point in time either Event changes?
13:06:17 <orbitz> chrisdone: i do have millions of files probably
13:06:19 <orbitz> http://ortdotlove.net/poppavic_wisdom.html
13:06:21 <Cale> Well... it is what happens when you mix IO effects with lazy evaluation.
13:06:38 <quicksilver> (readFile isn't entirely reliable at closing files, if you fail to 'notice' the end of the file in a timely way)
13:06:43 <quicksilver> Cale: I don't really think that's so.
13:07:00 <quicksilver> Cale: I think it's what happens when you implement haskell in an impure language which looks like haskell (the GHC IO hack)
13:07:10 <quicksilver> Cale: and then you 'push down' the haskell laziness to your impure layer
13:07:15 <quicksilver> Cale: and look at what you have produced.
13:07:18 <augustss> quicksilver: lines ought to read to the very end of the file.
13:07:29 <orbitz> quicksilver: i figured if i can turn a list of filesnames into a list of lines, it would give the program a very clean usage, but maybe i should be doign thign a bit more explicitly being a noob and all
13:07:29 <quicksilver> augustss: I think/hope you're right.
13:07:34 <Cale> Well, the old continuation-based model of IO with request/response streams worked like this
13:07:59 <quicksilver> Cale: I'm not pretending it's unrelated to laziness.
13:08:05 <quicksilver> Cale: it's obviously very closely related.
13:08:06 <augustss> quicksilver: even if you're just spine strict in the resulting list it should work.  And any less would not read the files anyway.
13:08:18 <Cale> I also think most of the problems we have with it are not essential ones.
13:08:18 <quicksilver> Cale: but it is still a subtly different thing.
13:08:28 <conal> wchogg: hi
13:08:30 <quicksilver> subtly but importantly, is my thesis.
13:08:32 <vixey> what's the new model?
13:09:03 <conal> wchogg: as i explain in the paper, the Applicative instance of Event is probably not very useful.
13:09:09 <Saizan> mapM (unsafeInterleaveIO . readFile) should probably work
13:09:27 <wchogg> conal : does that apply to liftM2 as well?  I figured it'd be different than <*>
13:09:30 <conal> wchogg: since liftM2 = liftA2, i wouldn't expect liftM2 to be very useful either.
13:09:33 <wchogg> Oh
13:09:36 <wchogg> Well never mind then
13:09:43 <orbitz> is that unsafe as in..my program might explode randomly?
13:09:51 <conal> wchogg: with relative time, however, things change!
13:09:59 <augustss> orbitz: not, it's pretty safe
13:10:12 <orbitz> what is unsafe about it then?
13:10:14 <quicksilver> wchogg: I prefer not to think of Event as a Monad. It's more like a Functor and Monoid which happens to have 'join'.
13:10:15 <augustss> orbitz: there are many levels of unsafe :)
13:10:21 <conal> wchogg: the reason is that absolute time == Max monoid, while relative time == Sum monoid.
13:10:23 <orbitz> hehe
13:10:31 <Saizan> orbitz: that the IO effects will be performed on demand
13:10:43 <Saizan> orbitz: when the value produced by the action is forced
13:10:45 <quicksilver> and that you can't sensible recover if one of the IO effects fails.
13:10:48 <augustss> orbitz: it's actually not unsafe at all.  but it might give unexpected results
13:10:54 <wchogg> conal : okay, I think I see that.
13:10:55 <Cale> orbitz: unsafeInterleaveIO is unsafe in that it creates nonstandard values which you couldn't otherwise get.
13:11:00 <quicksilver> which may well be an issue if you're opening millions of files.
13:11:12 <quicksilver> (the probabilty of an exception being raised at some point may be high?)
13:11:32 <Cale> quicksilver: does it not have a return?
13:11:41 <augustss> Cale: That's not strictly true.  It has a result in the IO monad.  Anything can happen in the IO monad. :)
13:11:44 <conal> wchogg: the problem (if it is a problem) with Max and applicative is that there are at most n+m maxima of n*m pairs
13:11:44 <quicksilver> Cale: yes, that too.
13:11:47 <chrisdone> is there a typical posixy command that removes duplicate lines?
13:11:57 <chrisdone> i.e. nub
13:11:59 <conal> wchogg: but there are up to n*m sums of n*m pairs
13:12:01 <orbitz> how would you solve my problem?  basically i have a ton of files i want to read through, parse in some way, and then for each line do some work that will get shuffled off to an output file
13:12:09 <orbitz> chrisdone: sort -u
13:12:11 <quicksilver> Cale: it really does look a lot like a monad, I just don't think it does interesting things with the typical monad combinators.
13:12:17 <chrisdone> orbitz: thanks
13:12:19 <augustss> chrisdone: only for sorted files.  uniq
13:12:20 <Cale> augustss: I mean, the result of the computation which it produces is a nonstandard value.
13:12:21 <quicksilver> Cale: I'm not sure what the implications of that are, theoretically.
13:12:22 <Apocalisp> chrisdone: also, uniq
13:12:24 <orbitz> Cale: will sort though
13:12:26 <orbitz> akc
13:12:28 <orbitz> chrisdone: will sort though
13:12:43 <chrisdone> augustss, Apocalisp: great
13:12:48 <Apocalisp> ah, uniq only works on sorted files
13:12:53 <conal> wchogg: i'm convinced (for now) that relative time is the way to go.
13:13:05 <quicksilver> Apocalisp: it works on all files :) It's only 'nub' on sorted ones.
13:13:08 <chrisdone> Apocalisp: sounds like a pipe is necessary!
13:13:10 <wchogg> conal : I'm inclined to agree due to my own bias.
13:13:14 <Apocalisp> You can use a combination of sort and comm to uniq an unsorted file
13:13:18 <quicksilver> Apocalisp: its behaviour on non-sorted files is still useful though.
13:13:23 <orbitz> chrisdone: sort -u will do both for you
13:13:39 <chrisdone> oh, yeah
13:13:43 <chrisdone>   -u, --unique              with -c, check for strict ordering; without -c, output only the first of an equal run
13:13:44 <chrisdone>  
13:14:09 <conal> wchogg: relative will be more composable than absolute, in general.  i hadn't quite seen how to pull it off until recently
13:14:34 <chrisdone> orbitz: I just wanted to produce this file: http://chrisdone.com/unsafe.txt
13:14:34 <wchogg> conal : have you made the changes in darcs reactive or is that still to come?
13:14:40 <chrisdone> they make me laugh so much
13:14:52 <chrisdone> ( grep -w -o '\(unsafe[A-Z][a-zA-Z]*\)' haskell.log | sort -u > /var/www/chrisdone/unsafe.txt )
13:15:05 <orbitz> unsafeCallCthulhu
13:15:06 <orbitz> hahahah
13:15:22 <chrisdone> haha
13:15:36 <conal> wchogg: to come.  i'm getting to the heart of the bug(s) with insufficient laziness.  i found it/one last night.
13:15:57 <chrisdone> unsafeNoReallyWeMeanItThisTimeAndToProveItWeAreGoingToMakeThisFunctionNameUnreasonablyLongToPersuadeYouNotToUseItTooFrequently
13:16:31 <orbitz> quicksilver: does it make sense to ask if foldM is strict?
13:16:39 <wchogg> conal : I saw that.  I also saw that you said it might be a bit pervasive of changes to fix.
13:16:43 <conal> wchogg: but the fix interacts with relative-vs-absolute, so i'm a bit torn which to address first.
13:16:44 <Cale> augustss: For example...
13:16:46 <Cale> *Main> foo
13:16:46 <Cale> (0,1)
13:16:46 <Cale> *Main> foo >>= \(x,y) -> return (y,x)
13:16:46 <Cale> (0,1)
13:16:50 <quicksilver> orbitz: it doesn't mean what you think it means, that's all.
13:17:05 <quicksilver> orbitz: strictness has a very precise meaning, although it's abused sometimes
13:17:16 <quicksilver> orbitz: f is strict if (f undefined) is undefined
13:17:22 <quicksilver> > undefined + 1
13:17:23 <lambdabot>   * Exception: Prelude.undefined
13:17:25 <conal> wchogg: yeah.  though not very deep.  i have to change AddBounds to release more partial information.
13:17:30 <quicksilver> orbitz: (+) is strict (at least, it is on Int)
13:17:41 <orbitz> > [1] ++ [undefined]
13:17:42 <lambdabot>   [1,* Exception: Prelude.undefined
13:17:42 <augustss> Cale: yes, but what is foo?
13:17:47 <conal> wchogg: which i intend to do by changing AddBounds into the composition of two types: AddMin and AddMax
13:17:51 <vixey> conal, I guess it's not related to frp but there was a fun problem came up here to check if a sequence (that includes infinity = fix Succ) is ascending or not -- and the computation monad was a good solution
13:17:58 <quicksilver> orbitz: right, and ++ is left strict but not right strict.
13:18:03 <orbitz> right
13:18:05 <b\6> can i define data Blah = ... somewhere and then make it part of another declaration like data Yo = Blah | ... ?
13:18:15 <conal> vixey: what's the "computation monad"?
13:18:17 <quicksilver> orbitz: what you want to know is if foldM will correctly stream an IO action over an infinite list
13:18:21 <Cale> foo = do r <- newIORef 0; x <- unsafeInterleaveIO (inc r); y <- unsafeInterleaveIO (inc r); return (x,y) where inc r = do v <- readIORef r; writeIORef r (v+1); return v
13:18:34 <quicksilver> orbitz: whilst this is intuitively related to strictness, it is not the same as 'is foldM strict'.
13:18:45 <conal> wchogg: however, for relative time the AddMin part (-infinity) becomes unnecessary.
13:18:47 <Cale> (it doesn't just flip every time it's executed ;)
13:18:47 <quicksilver> orbitz: and the answer is no.
13:18:53 <augustss> Cale: If something has type IO t, I'll say that there are no properties you can know about t.
13:18:59 <orbitz> quicksilver: is there a shroter way to ask if a function will correctlyw ork over infinite list?
13:19:17 <quicksilver> orbitz: all 'normal' IO actions which return lists, do their entire IO work in one go, before returning any of the list.
13:19:22 <augustss> Cale: it supposedly talks to the outside world and picks the result out of a hat.
13:19:25 <vixey> conal, data Computation a = Now a | Later (Computation a), so you can race (up to omega many) computations in parallel and other strange stuff
13:19:30 <wchogg> conal : how involved will it be to make the shift to relative time vs. making the lazy fix?
13:19:34 <Cale> augustss: Normally, you would be able to say that it is a specific value of t once the IO action has executed.
13:19:39 <quicksilver> orbitz: so no "normal" pure IO action can ever behave like that.
13:19:45 <orbitz> ok
13:19:48 <quicksilver> orbitz: only ones which 'cheat' by being constructed with interleave
13:19:51 <Cale> augustss: But with unsafeInterleaveIO, you can't.
13:20:00 <augustss> Cale: yes, but not the same value the next time you run it.
13:20:09 <lucca> quicksilver: not really left Strict either
13:20:14 <conal> vixey: sounds cool. where might i learn more?
13:20:19 <quicksilver> e.g. readFile and getContents
13:20:23 <lucca> you can get bits back of even an infinite left
13:20:32 <opqdonut> unsafeBuyBackLoans :D:D
13:20:34 <opqdonut> heh
13:20:35 <Cale> augustss: Well, okay, but suppose we run foo, just once this time.
13:20:38 <conal> wchogg: the lazy fix is more conservative/predictable.
13:20:39 <lucca> > take 5 $ ['1'..] ++ ['a'..]
13:20:40 <augustss> Cale: you ran foo twice, it's perfectly fine for it to generate two different values
13:20:40 <lambdabot>   "12345"
13:20:47 <Cale> augustss: and we haven't evaluated the value yet
13:20:50 <quicksilver> lucca: it is left strict. _|_ (++) x is _|_
13:21:00 <lucca> hm.... right
13:21:02 <quicksilver> lucca: that is precisely what strict means. No more and no less.
13:21:07 <augustss> Cale: ok, and then?
13:21:09 <quicksilver> lucca: what you said is true, of course :)
13:21:12 <conal> wchogg: and will involve doing a bit of work that i'll undo later.  (the MinBound part)
13:21:13 <quicksilver> but doesn't make it non-strict.
13:21:31 <lucca> i'm thinking laziness
13:21:35 <quicksilver> augustss: I think you're being a bit harsh. IO obviously has an intended semantics, it's just subtle.
13:21:36 <lucca> which is ... different
13:21:46 <quicksilver> augustss: if we didn't think we understood its semantics, we couldn't use it.
13:21:47 <Cale> augustss: Normally we would be able to say that there is a fixed value of t which is already determined, in the sense that the value won't depend on the order in which you evaluate it.
13:22:08 <quicksilver> augustss: it wouldn't be too hard to give a formal semantics to the IORef fragment (without forkIO) for example.
13:22:09 <vixey> conal, I picked it up from these slides about partiality being an effect http://www.informatik.uni-bonn.de/~ralf/WG2.8/22/slides/tarmo.pdf
13:22:22 <athos> @src mapM
13:22:23 <lambdabot> mapM f as = sequence (map f as)
13:22:29 <athos> @src sequence
13:22:30 <lambdabot> sequence []     = return []
13:22:30 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:22:30 <lambdabot> --OR
13:22:30 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:22:34 <conal> vixey: thanks!!
13:22:39 <augustss> Cale: my claim is that once you involve IO anything goes.  This make IORefs rather confusing, I admit. :)
13:23:05 <Cale> augustss: I don't think that's a useful model of IO for actually explaining programs.
13:23:11 <augustss> quicksilver: The IORef fragment should be in a different monad.
13:23:23 <quicksilver> augustss: indeed it could be. We could call it 'ST' perhaps?
13:23:24 <augustss> Cale: no, it's not.
13:23:26 <quicksilver> :)
13:23:34 <Cale> You have to be able to say *something* about the semantics of IO if you want to write a meaningful program.
13:23:43 <opqdonut> STRef?
13:23:53 <quicksilver> augustss: but you seee my point. There are plenty of fragments of IO we can could write semantics for.
13:23:56 <augustss> quicksilver: we could call it that.  and we could give it other cool properties, like being able to get out of it.  but the nobody would use it.
13:24:10 <quicksilver> the 'putChar/PutStr' fragment is totally tractable.
13:24:17 <opqdonut> well people manage to give C semantics
13:24:18 * vixey I use ST
13:24:23 <augustss> quicksilver: I agree.  But when we mix them we get an unholy mix. :)
13:24:24 <vixey> for this unification code
13:24:24 <opqdonut> so why not IO
13:24:44 <ski_> (vixey : .. which ?)
13:24:45 <quicksilver> augustss: I'm pretty sure even forkIO/MVar admits a tractable description.
13:24:50 <quicksilver> although a non-deterministic one, certainly.
13:24:53 <augustss> opqdonut: The semantics for C does not include IO.
13:24:57 <gwern> for the next release we could just replace IO with IOSpec. people use IO for its side-effects too much anyway
13:25:10 <opqdonut> IOSpec?
13:25:12 <vixey> ski_, first order, abstracted over datatypes http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62
13:25:29 <Cale> I don't know about MVar, but the STM paper contains a semantics for STM, from what I recall.
13:25:51 <Cale> Presumably you could then explain MVars via TMVars
13:26:06 <augustss> quicksilver, Cale, opqdonut: I'm just being the devils advocate.  But since we have no semantics for IO, unsafeInterleaveIO doesn't really break anything (except peoples sanity).
13:26:24 <opqdonut> augustss: yeah I kinda agree with you
13:26:51 <Cale> By "have no semantics" you mean we haven't written one down explicitly?
13:26:51 <augustss> unsafePerformIO, on the other hand, really is unsafe.
13:27:03 <athos> @src concat
13:27:03 <lambdabot> concat = foldr (++) []
13:27:11 <athos> ah ok, as i expected
13:27:23 <Cale> unsafeInterleaveIO certainly *changes* the semantics of IO.
13:27:40 <Cale> Whether you consider the new semantics broken is a matter of opinion.
13:27:41 <augustss> Cale: Yes, partly.  But the semantics for fill IO would have to include the outside world, so it's difficult.
13:27:49 <augustss> full IO
13:28:01 * ski_ agrees about `unsafeInterleaveIO'
13:28:30 <Cale> Well, actually, without unsafeInterleaveIO, you can imagine giving a semantics to IO separately from the denotational semantics of pure haskell expressions.
13:28:40 <conal> in a sense, IO is intractable by design.  that way it can swallow everything we don't understand.  (the "sin bin".)
13:28:40 <augustss> Cale: well, you have expectations on IO that nobody has promised are true. :)
13:29:03 * Deewiant smiled at http://chrisdone.com/haskell/unsafe.txt
13:29:04 <Cale> But with unsafeInterleaveIO, you have to go back and modify your pure semantics to allow for these strange values of type Integer, for instance.
13:29:25 <augustss> conal: Indeed.  I'd like to see the tractable bits taken out.  So keep working.
13:29:38 * quicksilver rather likes unsafeInterleaveStupidAnalogies
13:29:38 <ski_> vixey : any reason for having all those things inside `Unifiable' (instead of a separate) ?
13:29:38 <augustss> Cale: No, nothing changes about Integer.
13:29:46 <conal> augustss: will do!
13:29:59 <conal> quicksilver: lol
13:29:59 <vixey> ski_, a separate what?
13:30:10 <Cale> augustss: Then how do you explain the result of  unsafeInterleaveIO (inc r) ?
13:30:19 <augustss> Cale: Imagine that anything of type IO t uses a coin flip to decide the value of t.  That's allowed.
13:30:24 * ski_ wonders what `unsafeAttemptMiracles' might be for ..
13:30:44 <Cale> augustss: Pretend for a second that you're writing down a semantics for IO
13:30:50 <ski_> vixey : sorry, i mean `unify',`deref',..
13:30:56 <Cale> Surely it can be modelled somehow.
13:31:00 <augustss> Cale: Oh, then I'll be on your side. :)
13:31:25 <vixey> ski_,I don't really know what you mean, make a class for each operation? Derefable?
13:31:38 <povman> does anyone have a solution to von neumann architecture?
13:31:50 <augustss> povman: solution?
13:31:56 <Cale> augustss: Do you see what I mean about unsafeInterleaveIO making the semantics hard to write down in a way which doesn't go back and change the semantics for explaining the rest of Haskell?
13:31:57 <ski_> vixey : no, just defining them outside the class (instead of allowing them to be overridden)
13:32:22 <povman> augustss: it's ugly and makes haskell hard to implement
13:32:31 <vixey> ski_, oh right, I wasn't sure which was better
13:32:34 <augustss> Cale: I can write down a semantics for IO that is consistent with the current state of affairs including unsafeInterleaveIO.
13:32:36 * ski_ suspects we might need an `Execution' comonad ..
13:32:40 <Cale> povman: The reduceron :)
13:32:47 <vixey> ski_, I couldn't figure out if someone might want to redefine them
13:33:01 <povman> yes yes!!! thanks cale
13:33:10 <quicksilver> Cale: I'm not sure I agree about interlave changing the semantics of integer.
13:33:15 <augustss> Cale: just make IO t return random values of type t.
13:33:18 <ski_> vixey : ok .. just wondered if you had any specific situation in mind ..
13:33:21 <Cale> augustss: Which is compatible with the usual denotational semantics for Haskell?
13:33:23 <vixey> no
13:33:27 <augustss> Cale: yes.
13:33:29 <quicksilver> Cale: all the (pure) semantics of Integer can see is a thunk which returns a totally non-deterministic integer.
13:33:39 <vixey> what's an execution comonad?
13:33:42 <quicksilver> Cale: it couldn't care less if that's evaluation order dependent
13:33:50 <Cale> augustss: "Random" doesn't actually tell you what programs do though.
13:33:50 <quicksilver> Cale: it's totally non-deterministic anyway.
13:34:03 <quicksilver> I don't disagree with that part.
13:34:07 <ski_> vixey : sorry, that was in response to the surrounding discussion about `unsafeInterleaveIO' :)
13:34:14 <augustss> Cale: my semantics is consistent with what Haskell programs do.
13:34:15 <quicksilver> I'm just disagreeing that interleaving changes the semantics of pure values.
13:34:16 <vixey> yes but I still wonder what it is
13:35:22 <chrisdone> Deewiant :)
13:36:03 <ski_> vixey : it's an idea i saw in a paper .. representing algorithms from `a' to `b' by functions from `Execution a' to `b', where the point being that algorithms have reduction order, et.c. ..
13:36:25 <Cale> augustss: The statement "this program could do anything at all" is not useful. While any given program run will be consistent with it, the set of all possible runs of the program probably won't be.
13:36:26 <Deewiant> chrisdone: now add the number of occurrences of each!
13:36:38 <vixey> ski_, I see.. do you know which paper?
13:36:52 <povman> it really seems like the best platform for haskell programs is the FPGA
13:37:12 <athos> :t scanr
13:37:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
13:37:24 <athos> @src scanr
13:37:24 <lambdabot> scanr _ q0 []     =  [q0]
13:37:24 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
13:37:24 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:37:28 <augustss> Cale: I don't even understand what that means.  And I agree that my semantics is useless.
13:37:38 <ski_> vixey : so i'm just imagining that one could maybe interpret a specific evaluation strategy for haskell as using a specific execution comonad .. and maybe (i'm not sure), one could then have things like `unsafePeekExecution :: a -> Execution a',`isThunk :: Execution a -> Bool', et.c.
13:37:44 <athos> hm
13:37:47 <Cale> augustss: Well, it won't actually be true that the program can do anything at all.
13:37:47 <arussel> still one thing I don't get this type: mycurry :: ((x,y) -> z) -> (x -> y -> z) is a functionn that takes as arg a function that takes a pair and return a function that takes 2 args. so the def should be f (x,y) = f x y and not the opposit.
13:37:55 <athos> any simple exmaple for using scanr?
13:38:04 <vixey> ski_, very interesting idea
13:38:06 <Cale> augustss: There will be specific effects which the program never actually causes, and values which it doesn't ever compute.
13:38:12 <athos> i mean, an example where it works like a shortcut, so at least something useful
13:38:25 <Cale> (In general)
13:38:32 <augustss> Cale: Oh, but you'd have to make an infinite number of experiments to verify that.
13:38:36 <ski_> (vixey : i'm not sure if this latter makes any sense, yet .. it's just a wild idea .. the paper about algorithms and comonads is interesting, though)
13:38:42 <Cale> augustss: No you wouldn't.
13:39:07 <athos> > scanr (+) 30 [1,2,3,4,5]
13:39:08 <lambdabot>   [45,44,42,39,35,30]
13:39:10 <Cale> augustss: You could simply look at the resulting assembly code from compiling it and use the semantics for that.
13:39:11 <ski_> vixey : i'm seeing the paper in a lecture note series book, actually .. let me check ..
13:39:26 <augustss> Cale: Now you're cheating!
13:39:31 <Cale> (if you were so hard pressed to find a formalism)
13:39:48 <athos> > scanr (+) 30 [1]
13:39:50 <lambdabot>   [31,30]
13:39:55 <ski_> vixey : "Computational comonads and intensional semantics", S. Brookes and S. Geva
13:39:58 <athos> > scanr (+) 30 [2]
13:39:59 <lambdabot>   [32,30]
13:40:12 <augustss> Cale: Then unsafePerformIO has a well defined semantics too.
13:40:17 <athos> ah
13:40:19 <athos> i see
13:40:25 <ski_> vixey : appeared in : London Mathematical Society - Lecture Note Series 177 - Applications of Categories in Computer Science
13:40:37 <Cale> augustss: It has some well-defined semantics.
13:40:39 <vixey> thank you
13:40:45 <athos> > scanr (+) 1 [0,2,3,4,5]
13:40:47 <lambdabot>   [15,15,13,10,6,1]
13:41:06 <augustss> Cale: Just look at the machine code. :)
13:41:08 <Cale> augustss: Whether that semantics is compatible with the denotational semantics of the non-IO fragment of Haskell is another thing.
13:41:13 <athos> > scanr (+) 1 [1,1,1,1,1]
13:41:14 <lambdabot>   [6,5,4,3,2,1]
13:42:14 <augustss> Cale: and I maintain that unsafeInterleaveIO does not change the semantics of the non-IO fragment.  Because it is in IO, so as soon as you have used it, you have used IO.
13:42:30 <Cale> augustss: Sigh.
13:42:45 <ski_> (vixey : so `Execution' would sortof be an implicit ambient coeffect in haskell .. normally values shouldn't depend on how other thunks reduced, though .. but for things like `unsafeInterleaveIO' one might have to depend on that ..)
13:42:56 * vixey nod
13:43:00 <augustss> Cale: show me a program that is not consistent with my coin flipping semantics of IO.
13:43:13 <Cale> return 0
13:43:19 <Cale> It never returns 1
13:43:50 <augustss> How do you know?  And we're talking abstract semantics here.  You can't look at the machine code.
13:44:37 <Cale> Well, first of all, if it did, the monad laws for IO would fail.
13:44:59 <augustss> Cale: they are not invalid for IO already.
13:45:15 <Cale> They ought not to be invalid for IO.
13:45:20 <opqdonut> are they?
13:45:58 <augustss> yeah :(
13:46:11 <Cale> But more importantly, if it did, we would consider it a bug. So any semantics which we give to IO should include this fact.
13:46:23 <arussel> @type curry
13:46:24 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:46:27 <hellige> do people dislike the fact that arr is required for arrows? or am i imagining that?
13:46:39 <ski_> hellige : we do
13:46:45 <Cale> We do?
13:46:46 <arussel> @src curry
13:46:47 <lambdabot> curry f x y = f (x, y)
13:46:49 <hellige> ski_: how come?
13:46:57 <pchiusano> what do folks use for Haskell editing?
13:47:05 <Cale> pchiusano: vim, emacs
13:47:05 <ski_> hellige : how about reversible arrows ?
13:47:08 * hoopy is using vim right now
13:47:29 <pchiusano> what is the status of Yi?
13:47:33 <pchiusano> does anyone use it
13:47:35 <Cale> arr is roughly to Arrow what return is to Monad
13:47:38 <hellige> ok, i think i'm thinking in the same direction.
13:47:42 <ozy`> pchiusano: emacs and yi have the nicest indentation. (vim's is okay too.)
13:47:42 <Cale> pchiusano: Not seriously.
13:47:53 <Cale> (as far as I know)
13:47:55 <ozy`> yeah, don't use yi to learn haskell
13:47:58 <arussel> ozy`: you mean yi is usable now ?
13:48:07 <Cale> There are people working on yi, I think.
13:48:14 <ski_> Cale : i'd say `aId :: Arrow (~>) => a ~> a' compares better to `return :: Monad m => a -> m a'
13:48:19 <ozy`> yi is undergoing actual development these days
13:48:20 <Cale> But I don't think anyone's using it as their primary editor.
13:48:31 <arussel> Cale: but are they any working *with* yi ?
13:48:32 <hellige> ski_: i think so too
13:48:40 <hellige> ski_: plus, it's always sensible.
13:48:52 <pchiusano> I kind of wanted to download and play with it, but it doesn't look like there's any standalone binaries
13:49:12 <hellige> ski_: whereas arr might not be.
13:49:29 <Cale> pchiusano: You'll have to compile it yourself.
13:49:30 * ski_ nods
13:49:38 <chrisdone> ozy`: it is‽
13:49:58 <ozy`> chrisdone: at least, it seems to be. it's had several releases this year, no?
13:50:05 <chrisdone> the indentatino stuff I saw in the yi presentation was cool
13:50:17 <adekoba_> is there any way to expose a module only to the libray itself, not to the entire GHC scope, in a cabal file?
13:50:25 <arussel> in "funonpair :: (x,y) -> Integer" "funonpair (x,y) = 2", left of -> and = is what I 'take' and right side is what I 'return'. Why is it the opposit for the curry function ?
13:50:38 <ozy`> it's still way too immature to be used by anyone who isn't ready to hack on it constantly
13:50:49 <ski_> arussel : no
13:50:57 <ozy`> (ie. anyone who doesn't already have a decent knowledge of haskell)
13:51:03 <chrisdone> yeah, I tried it myself for a wee while and it was nice, just that the irks here and there halted my work
13:51:14 <ozy`> incidentally I saw two copies of RWH at the local bookstore
13:51:17 <ozy`> and my town sucks
13:51:20 <chrisdone> nice!!!
13:51:21 <dcoutts> adekoba: use other-modules for modules that will be private to that package and cannot be imported by client code.
13:51:31 <adekoba> dcoutts: neato
13:51:37 <hellige> Cale: recall the conversation the other day about Control.Category and generalizing Functor?
13:51:48 <Cale> yeah?
13:51:49 <arussel> ski_: curry takes a function that takes a pair as argument. It should be smthing like "curry f (x,y) = ... "
13:52:00 <mauke> arussel: no
13:52:08 <hellige> Cale: you were saying you had some misgivings about Category, weren't you?
13:52:12 <ski_> arussel : for `curry :: ((a,b) -> c) -> (a -> b -> c)' you take asn uncurried function of type `(a,b) -> c' and yields a curried function of type `a -> b -> c' .. that curried function takes values of types `a',`b' (successively), and gives a pair of those to the input function, and returns the result of that (having type `c')
13:52:13 <hellige> Cale: can you articulate that?
13:52:13 <Cale> yes
13:52:27 <Cale> Somewhat.
13:52:28 <hellige> i've given it some more thought, and i think i like Category now.
13:52:40 <Cale> I think it's perhaps inappropriately named.
13:52:56 <ski_> Cale : because it's only for kind `*' ?
13:52:57 <hellige> how so?
13:53:48 <Cale> Category captures specific structures which, while they may be categories, are *much* more specific. They are not even just categories whose objects are Haskell types. They're something very specific.
13:54:03 <ski_> arussel : if it helps, you may think of `curry' as begin defined by `curry (\(x,y) -> z) = \x -> \y -> z' (or `curry (\(x,y) -> z) x y = z' if you prefer)
13:54:24 <hellige> Cale: ok, now i remember you saying this the other day... but what are the restrictions?
13:54:47 <hellige> Cale: i don't see the extra specificity... if there was a function like arr for Category, that would be one thing...
13:54:54 <Cale> (and I'm not entirely sure about the formalisation, but the required polymorphism of (.) probably makes it a natural transformation of some sort)
13:55:08 <ski_> Cale : btw, compare with `Monad' only being for `*', too (as opposed to e.g. `* -> *' as well)
13:55:25 <arussel> ski_: I completely understand: `curry (\(x,y) -> z) = \x -> \y -> z' so think the next step is 'curry f (x,y) = f x y'...
13:55:36 <Cale> ski_: I'm not sure how Monad could be for * -> *
13:55:44 <opqdonut> i'm reading the control.category docs
13:55:46 <opqdonut> "A class for categories. id and (.) must form a monoid."
13:55:53 <hellige> ski_: yeah, i don't follow that either.
13:55:56 <opqdonut> how can it be a monoid when . isn't always applicable?
13:55:57 <ski_> Cale : just consider a monad over the exponential category
13:56:01 <Cale> opqdonut: That's not quite right.
13:56:12 <hellige> arussel: no...
13:56:21 <ski_> arussel : aye
13:56:26 <ski_> er
13:56:28 <Cale> opqdonut: The author meant to say that id must be an identity for (.) on the left and right, and that (.) must be associative everywhere that it is defined.
13:56:30 <ski_> arussel : no :)
13:56:38 <hellige> arussel: because you're not taking the pair as an argument
13:56:38 <opqdonut> Cale: yeah i understand :)
13:56:42 <opqdonut> Cale: just nitpicking
13:56:58 <hellige> arussel: you're taking the two individual values x and y, which *you* have to package as a pair, to pass to f
13:57:18 <hellige> arussel: so curry has three arguments: f, x and y
13:57:25 <Cale> hellige: Another thing is that I haven't seen enough good examples of instances of Control.Category to justify stealing (.) for it.
13:57:36 <hellige> Cale: well, yeah, that's a separate problem.
13:57:50 <hellige> although it wouldn't be stealing if Prelude's (.) went away
13:57:54 <Cale> hellige: Personally, based on pragmatic reasons, I would use (.) for Functor.
13:58:08 <ski_> arussel : to translate `curry (\(x,y) -> z) = \x -> \y -> z' to haskell, you could first rewrite to `curry (\(x,y) -> f (x,y)) = \x -> \y -> f (x,y)'
13:58:20 <Cale> Since fmap generalises composition as well.
13:58:26 <opqdonut> sigh
13:58:29 <hellige> Cale: i don't really get (.) for Functor...
13:58:31 <ski_> arussel : and then to `curry f = \x -> \y -> f (x,y)'
13:58:39 <opqdonut> we really need to do something with . and all these typeclasses :D
13:58:43 <Cale> hellige: fmap :: (a -> b) -> f a -> f b
13:58:51 <arussel> f is taking a pair as argument but curry  is taking f and x and y.
13:58:51 <ski_> arussel : and finally to `curry f x y = f (x,y)', should you prefer that last step
13:58:53 <Cale> hellige: Let f = (e ->)
13:59:03 <Cale> hellige: So then  fmap :: (a -> b) -> (e -> a) -> (e -> b)
13:59:07 <arussel> my brain is getting it, but very slowly :-)
13:59:11 <Cale> It must be composition! :)
13:59:21 <hellige> Cale: hmm, but f isn't always (e ->)
13:59:25 <hellige> and...
13:59:27 <hellige> well...
13:59:33 <Cale> hellige: I'm saying that it's a generalisation
13:59:34 * arussel should have stop learning new stuff passed 30yo 
13:59:35 <hellige> maybe it makes sense, but it's not how i've ever thought of fmap. ;)
13:59:38 <Cale> fmap generalises composition :)
13:59:48 <vixey> hellige, just for the -> monad
13:59:56 <hellige> well, if i were to generalize Functor, i'd do something like:
14:00:06 <vixey> It doesn't make sense to call fmap composition for other functions
14:00:10 <pchiusano> Cale: isn't that flip (.)?
14:00:10 <vixey> (does it?)
14:00:17 <Cale> vixey: It can, sort of.
14:00:19 <arussel> ski_, mauke,
14:00:21 <ski_> (vixey : i don't think it does)
14:00:28 <arussel> got it, thanks for your help
14:00:33 <Cale> vixey: If you bend your view of data structures a little bit.
14:00:37 <opqdonut> Philippa: read again :)
14:00:42 <hellige> http://hpaste.org/13194
14:00:43 <opqdonut> Philippa: sorry, not you
14:00:45 <opqdonut> pchiusano: read again
14:00:57 <opqdonut> or rather, think again
14:01:00 <Cale> pchiusano: no
14:01:02 <ski_> Cale : you're thinking of stuff like `Stream a  ~=  Natural -> a', yes ?
14:01:09 <Cale> ski_: yeah
14:01:16 <pchiusano> fmap :: (a -> b) -> (e -> a) -> (e -> b)
14:01:31 <hellige> at least Gunctor is consistent with Category, and allows Functors between categories, rather than just Hask -> Hask
14:01:40 <vixey> Gunctor lol
14:01:48 <opqdonut> Gung-ho
14:01:50 <Cale> You can sort of imagine that functorial datastructures are some structural part together with a function from labels to values.
14:02:09 <pchiusano> opqdonut: ok, I see now
14:02:15 <Cale> and fmap composes that function with the one provided
14:02:16 <ski_> Cale : so how about (finite) lists ?
14:02:29 <hellige> and then we also have that:
14:02:30 * vixey thinks  Fin n -> a
14:02:32 <Cale> ski_: It might not be expressible directly in Haskell as such.
14:02:34 <opqdonut> pchiusano: :)
14:02:38 <ski_> > ([0,1,2] !!) 3
14:02:40 <lambdabot>   * Exception: Prelude.(!!): index too large
14:02:40 <vixey> n is  the length of the list
14:02:41 <hellige>  instance Category cat => Gunctor (cat a) where
14:02:49 <hellige>     type Cat1 (cat a) = cat
14:02:50 <pchiusano> > ((1+) . (1+)) 0
14:02:50 <Cale> ski_: but you can always think of it like that
14:02:51 <lambdabot>   2
14:02:56 <hellige>    type Cat2 (cat a) = (->)
14:02:59 <hellige>    gmap = (.)
14:03:05 <ski_> Cale : i'm not sure about that
14:03:09 <pchiusano> > (1+) `fmap` (1+) 0
14:03:09 <hellige> which is exactly the definition of a hom-functor.
14:03:10 <lambdabot>       No instance for (Num (f t))
14:03:10 <lambdabot>        arising from the literal `1' at <int...
14:03:12 <hellige> which is nice.
14:03:29 <pchiusano> > ((1+) `fmap` (1+)) 0
14:03:30 <lambdabot>   2
14:03:33 <vixey> ski_, I think Cale is talking about containers
14:03:35 <hellige> so in *that* sense, i do see that fmap generalizes (.)
14:03:42 <hellige> but only if we first generalize functor to any categories.
14:03:57 <Cale> ski_: Say, finite lists of values of type a are the union over n in N of a^n.
14:04:02 <vixey> ski_, at least it seems similar.. it is like you get the shape of a container and the contained things separate
14:04:11 * vixey I could be messing it up a bit
14:04:13 <Cale> Or n -> a
14:04:21 <pchiusano> > ((1+) `fmap` (2*)) 0
14:04:22 <ski_> vixey : yes but `[]' is a functor .. i'm not seeing how to view it as a function from index to value (without using partial functions)
14:04:22 <lambdabot>   1
14:04:31 <vixey> ski_, Fin n -> a
14:04:40 <Cale> ski_: union over n in N of (n -> a)
14:04:42 <vixey> Fin 0 = Void, Fin 1 = (), Fin 2 = Bool
14:04:43 <pchiusano> opqdonut: very nice
14:04:48 <ski_> vixey : yes, sized lists are no problem
14:05:02 <Cale> ski_: If you want all sizes, just take the union
14:05:16 <Cale> and you have a set of functions which represents the type
14:05:28 <ski_> Cale : but how do i know the domain of the mapping function without looking at the list in question ?
14:05:35 <Cale> hm?
14:05:41 <vixey> oh I see what you're getting at
14:05:46 <Cale> You can't express it in Haskell, but it doesn't mean you can't look at it that way
14:06:01 <ski_> (i'm not talking about haskell)
14:06:11 <Cale> ski_: The domain is the length of the list.
14:06:24 <Cale> I don't see why you should have to not look at the list.
14:06:35 <vixey> you could just stick a existential quantifier before n
14:06:53 <ski_> Cale : i interpret what you said as thinking of `Container a' as isomorphic to `Indices -> a'
14:07:26 <ski_> i don't see how to determine what `Indices' should be, without looking at specific values of `Container a'
14:07:31 <Cale> ski_: Roughly, Container a is *some* set of functions whose codomain is a.
14:07:45 <Cale> They might have different domains though.
14:08:05 <ski_> i can imagine a function `(xs :: Container a) -> (Indices xs -> a)', but i don't see how to remove that dependency
14:08:06 <roconnor> I thought a Container was a functor whose derivative had a particular property?
14:08:11 * roconnor tries to remember
14:08:32 <roconnor> something about the ability to take logorithms or something to do with logorithms of data types.
14:08:35 <Cale> ski_: Imagine we're trying to explain the container types in terms of ZF.
14:09:30 <ski_> roconnor : for some containers (like `Stream') the elacticity of demand gives the `Indices' type (there `Natural')
14:09:33 <Cale> There's no need to worry about putting differently typed functions into one set -- we can encode their domains when we stick them in there anyway. (Hopefully we've defined 'function' correctly so that this is the case)
14:09:51 <roconnor> elacticity of demand?
14:10:32 * roconnor thinks back to talking to Conor on the bus.
14:10:59 <roconnor> datatypes, derivatives, logarithms at unit ... hmm
14:11:08 <opqdonut> roconnor: do you have a citation for that stuff
14:11:12 <opqdonut> i'm intrigued
14:11:13 <dons> chrisdone: awesome: http://chrisdone.com/haskell/unsafe.txt
14:11:14 <ski_> roconnor : E f x * f x = D f x * x, where `D' is derivative and `E' is elaciticity of demand
14:11:17 <Cale> It was on conal's blog
14:11:29 <roconnor> opqdonut: ya, Conor on the bus in Italy.
14:11:34 <opqdonut> :D
14:11:36 <ski_> roconnor : `E f x' represent the "path" type to any element `x' in `f x'
14:11:52 <Cale> er...
14:12:01 <Cale> Well, something related to it was :)
14:12:01 <ski_> roconnor : in analysis you get `E (\x -> x^n) x = n'
14:12:38 <roconnor> ski_ that is starting to sound logorithmicish
14:12:52 <Cale> logarithm
14:12:53 <ski_> roconnor : that translates to type theory as `E (e ->) a = e' i.e. the "paths" to `a' in `e -> a' are just `e', which is not that surprising
14:12:57 <Cale> with an 'a'
14:12:58 <Cale> hehe
14:13:44 <roconnor> right
14:13:47 <roconnor> sorry
14:13:55 <roconnor> logarithmicish
14:14:10 <chrisdone> dons: hahaha
14:14:16 <ski_> (roconnor : btw, the term "elaciticy of demand" comes from economics .. i just noted it had a useful interpretation in relation to zippers and derivatives of types)
14:14:29 <chrisdone> dons: unsafeCoerceRedditersIntoLearningHaskellUsingMemes
14:14:57 <dons> chrisdone: right on.
14:15:00 <dons> memes rock
14:15:07 <ski_> Cale : sorry for not listening to you for a while
14:15:11 <chrisdone> haha
14:15:25 <ski_> Cale : i worry about "putting differently typed functions into one set"
14:15:42 <roconnor> ski_: not every functor has an elacitity of demand, right?
14:15:44 <ski_> Cale : however, you can existentially quantify them before you put them there, yes
14:15:48 <roconnor> only containors?
14:16:00 <ski_> roconnor : not even all containers, afaiu
14:16:08 <ski_> (c.f. `[]')
14:16:37 <ski_> (s/useful/somewhat useful/ mayhaps :)
14:17:30 <ski_> (also, s/elaciticy/elasticity/ .. haven't learned to spell that yet)
14:17:34 <roconnor> d log (x) * x = 1
14:17:53 <roconnor> x * d log (x) = 1
14:18:31 <ski_> (should `d' there be `D' ?)
14:18:38 <roconnor> D
14:19:15 <roconnor> bah
14:19:19 <roconnor> I can't remember
14:19:26 <ski_> what ?
14:19:42 <roconnor> how to define containors
14:19:46 <roconnor> containers
14:19:48 <roconnor> whatever
14:19:58 <chrisdone> :t (<*>)
14:20:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:20:03 <Cale> o is roconnor favourite vowel today :)
14:20:09 <Cale> roconnor's :)
14:20:28 <mauke> fovorote vowol?
14:20:33 <chrisdone> > fmap (^2) [1..5]
14:20:34 <lambdabot>   [1,4,9,16,25]
14:20:36 <roconnor> :)
14:20:38 <ski_> Cale : anyway, i think you get a set of pairs of dimensions and functions, then ..
14:21:31 <chrisdone> :t (<*> [1..5])
14:21:32 <lambdabot> forall a b. (Enum a, Num a) => [a -> b] -> [b]
14:21:36 <ski_> ("Hopefully we've defined 'function' correctly so that this is the case" ?)
14:21:50 <Cale> ski_: So that it includes its domain as part of its definition
14:21:55 <chrisdone> :t ((^2) <$>)
14:21:56 <athos> @index isSuffixOf
14:21:56 <lambdabot> Data.List
14:21:56 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
14:22:04 <ski_> Cale : noo !
14:22:23 <tehgeekmeister> setup for takusen won't compile, gives these messages: "Module `Distribution.Package' does not export `Dependency(..)'" and "Module `Distribution.Simple' does not export `autoconfUserHooks'"
14:22:28 <tehgeekmeister> what's going on?
14:22:42 <Cale> (and codomain)
14:22:45 <ski_> stating domain (and codomain as well) is a precondition to giving a function
14:22:47 <chrisdone> > ((const ((^2) <$>)) <*> [1..5])
14:22:48 <lambdabot>   Couldn't match expected type `b -> f a'
14:23:24 * ski_ looks for a word
14:23:55 <Cale> ski_: An old definition of a function is a subset f of A x B such that for each a in A, there is exactly one b in B such that (a,b) is in f. But then you end up with functions with more than one "type".
14:23:57 <chrisdone> > map id <$> [1] <*> [2]
14:23:58 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
14:24:04 <chrisdone> > map (const id) <$> [1] <*> [2]
14:24:05 <ski_> the domain and codomain of a function are presuppositions for talking about it
14:24:06 <lambdabot>   Couldn't match expected type `a -> b'
14:24:15 <chrisdone> :t (<$> [1] <*> [2])
14:24:17 <lambdabot>     The operator `<$>' [infixl 4] of a section
14:24:17 <lambdabot>         must have lower precedence than the operand `(<*>)' [infixl 4]
14:24:17 <lambdabot>         in the section: `(<$> [1] <*> [2])'
14:24:17 <Cale> Well, at least that one avoids the problem with domains.
14:24:22 <chrisdone> :t (<$> ([1] <*> [2]))
14:24:23 <lambdabot>     Ambiguous type variable `a' in the constraint:
14:24:23 <lambdabot>       `Num a' arising from the literal `2' at <interactive>:1:15
14:24:23 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
14:24:33 <chrisdone> woops
14:24:39 <Cale> ski_: So yeah, you want to include the domain and codomain along with the relation.
14:25:05 <Cale> The domain could be determined there, but the codomain couldn't.
14:25:14 <pejo> tehgeekmeister, try compiling with an older cabal version
14:25:18 <ski_> so if you have two function whose domain or codomain do not agree, it is meaningless to ask whether those two functions are the same or not (and also meaningless to try to put them in the same set)
14:25:31 <pejo> tehgeekmeister, autoconfUserHooks has been deprecated for a while iirc.
14:25:32 <tehgeekmeister> pejo: just read the readme, apparently it needs filepath, which i don't think i have
14:25:55 <Cale> ski_: Well, it's a matter of definition.
14:26:08 <Cale> ski_: But with the good definition, yes :)
14:26:24 <Cale> ski_: Actually, it's not meaningless. They're just not equal.
14:26:38 <athos> i know i asked this quite a while ago, but i wasn't really satisfied with the answer (perhaps i didn't understand them properly): when is forall foobar used in a declaration of the type of a function?
14:26:41 <ski_> with a category theoretic or type theoretic point of view, it is meaningless (afaiu things)
14:26:42 <Cale> You can put functions of varying domain and codomain in the same set.
14:27:07 <athos> where does it come from? what's the exact meaning? does it enforce some stricter rules for the type?
14:27:11 <Cale> It's just you typically want to make sure that functions carry those data along with them.
14:27:36 <dcoutts> tehgeekmeister: if you read further down in the README it explains what to do about the filepath dependency for people using ghc-6.6 or older.
14:27:38 <ski_> Cale : i think it's better to provide that data when needed, and otherwise not
14:27:40 <Cale> athos: If it's right at the start of the type, then it's something which is implied anyway.
14:27:43 <Cale> (in Haskell)
14:27:56 <tehgeekmeister> dcoutts: i'm using 6.8.3
14:28:01 <shapr> @users
14:28:01 <lambdabot> Maximum users seen in #haskell: 575, currently: 560 (97.4%), active: 20 (3.6%)
14:28:09 <dcoutts> tehgeekmeister: oh, then you've got filepath already, you're fine.
14:28:10 <tehgeekmeister> dcoutts: oops, 6.8.2
14:28:34 <Cale> ski_: My usual definition is that a function is a triple (A,B,R), such that for each a in A, there is exactly one b in B such that (a,b) is in R.
14:28:41 <dcoutts> tehgeekmeister: yes, you've got it already (unless you accidentally unregistered it)
14:28:48 <ski_> e.g. given a category `C' with objects like `A' and morphisms like `f : A_0 >-> A_1' the arrow category has objects `(A_0,A_1,f)' which are triples
14:28:50 <Cale> ski_: and R is a subset of A x B.
14:29:09 <tehgeekmeister> dcoutts: i actually may have...
14:30:08 <ski_> Cale : i think that is often budling too much information with the functions (the same situation appears in other circumstances as well)
14:30:29 <tehgeekmeister> dcoutts: nah;; something else is the problem.
14:30:33 <Cale> ski_: Well, you don't want functions with different codomains to be considered equal.
14:30:56 <Cale> ski_: The A is technically needless though.
14:31:14 <ski_> Cale : i want the question of whether two functions with differing codomains are equal to be considered meaningless
14:31:14 <Cale> ski_: Since it can be obtained by the projection onto the first component applied to R.
14:31:35 <Cale> ski_: I want every question about equality to be meaningful, if not answerable.
14:31:38 <Philonous> There isn't a distribited haskell compiler (comparable to distcc), is there?
14:31:54 <Cale> (equality about defined things, anyway)
14:32:03 <vixey> well you can use John Major equality
14:32:20 <Cale> (at least in set theory, and general mathematics)
14:32:27 <ski_> Cale : i.e. there's one notion of equality over functions with certain domain and codomain .. and other separate notions of equality for other domains and codomains
14:32:46 <Cale> ski_: Yeah, but I'm not taking functions as primitive.
14:33:06 <Cale> ski_: I'm defining them in terms of sets, and want them to inherit the notion of equality from that for equality of sets.
14:33:07 <ski_> i don't think that matters
14:33:20 <ski_> it's about the interface, not the implementation
14:33:26 <vixey> by the way why use sets
14:33:27 <vixey> ?
14:33:37 <vixey> instead of lambda calculus
14:33:54 <Cale> vixey: Lambda calculus is too weak.
14:34:00 <ski_> even if some questions are meaningful in terms of the implementation (say, ZF), that doesn't mean we want them to be meaningful at an abstract level
14:34:12 <ski_> is `2' an element of `(2,3)' or not ?
14:34:14 <ozy`> Philonous: there is, but I dunno if it's keeping up with GHC development
14:34:20 <ski_> is `4' an element of `8'
14:34:29 <Cale> vixey: There's no straightforward way to encode the proper real numbers (not just the computable ones) in the lambda calculus.
14:34:38 <ski_> too me, these questions are largely irrelevant and meaningless
14:34:41 <ski_> s/too/to/
14:34:47 <athos> > foldr (||) True $ map (=='r') "barfoo"
14:34:49 <lambdabot>   True
14:34:58 <athos> > foldr (||) False $ map (=='r') "barfoo"
14:34:59 <lambdabot>   True
14:35:00 <Cale> ski_: But traditionally, all questions about equality are okay.
14:35:19 <ski_> Cale : yes ? :)
14:35:45 <vixey> Cale, I'm not sure what that means
14:35:47 <Cale> (though there are places where we might want to apply isomorphisms implicitly)
14:35:53 <athos> @pl \s -> foldr (||) False (map (=='r') s)
14:35:53 <lambdabot> foldr (||) False . map ('r' ==)
14:35:59 <vixey> Cale, I think you can construct achemedian ordered fields
14:36:02 <athos> of course :)
14:36:09 <Cale> For example, 2 in N is not equal to 2 in R
14:36:22 <Cale> But usually we ignore the distinction.
14:36:26 <tehgeekmeister> pejo: how do i compile it with an older one?
14:36:53 <vixey> Cale, I guess what you object to is that the set is closed under computability?
14:37:02 <Cale> vixey: What's the powerset of the naturals in lambda calculus?
14:37:20 <vixey> I don't know ..
14:37:44 <Cale> It's tricky to represent common things that we need in mathematics using lambda calculus.
14:38:12 <vixey> powerset is an axiom in set theory isn't it?
14:38:16 <Cale> yes
14:38:30 <pejo> tehgeekmeister, edit the .cabal and set "Cabal-Version: == 1.4" I think. (Not sure of the exact syntax)
14:38:42 <bd_> Cale: wouldn't that depend on your representation of sets, first?
14:38:44 <tehgeekmeister> pejo: thanks, will try
14:38:55 <ski_> in topoi, there is a powerset construction mapping objects to objects
14:39:02 <Cale> bd_: We don't represent sets in mathematics. They're axiomatically defined.
14:39:11 <Cale> (well, in ZFC, etc.)
14:39:24 <bd_> however in order to translate to lambda calculus, wouldn't it need an explicit representation?
14:39:33 <Cale> oh
14:39:36 <Cale> Yes, it would.
14:39:36 <tehgeekmeister> pejo: no change
14:39:47 <tehgeekmeister> pejo: also, it was at >= 1.4 when i tried it
14:39:59 <tehgeekmeister> *first tried
14:40:08 <vixey> @go axiom of the powerset
14:40:10 <lambdabot> http://mathworld.wolfram.com/AxiomofthePowerSet.html
14:40:11 <lambdabot> Title: Axiom of the Power Set -- from Wolfram MathWorld
14:40:12 <Cale> I have a feeling that in order to do it in a way which would make mathematicians happy, you'd end up encoding statements and proofs in some other set theory using LC terms.
14:40:24 <sw17ch> there isn't a good way to force the GC to run, is there?
14:40:31 <Cale> sw17ch: performGC
14:40:38 <Cale> (in IO)
14:40:39 <sw17ch> Cale: ah, look at that :)
14:40:47 <vixey> Cale, so I guess that the powerset isn't always computable
14:40:53 <Cale> vixey: That's right.
14:42:25 <Cale> Well, depends on exactly what you mean by computable...
14:43:10 <Cale> http://en.wikipedia.org/wiki/ZFC has a good summary of the axioms, btw.
14:45:48 <Cale> Infinity is what gets you N, and powerset from there effectively gets you R.
14:46:03 <Cale> Though the powerset axiom is used a lot.
14:46:18 <Cale> It's also used to define the Cartesian product in ZFC, for example.
14:46:27 <Cale> (along with comprehension)
14:49:50 <vixey> what's the powerset of R?
14:50:04 <Cale> The set of all subsets of the reals.
14:50:23 <mauke> ℘(ℝ)
14:50:35 <vixey> but it's not also something interesting like N and R?
14:51:01 <Cale> Well, functions R -> 2 have that cardinality, as do functions R -> R
14:51:28 <vixey> N -> 2 is the powerset of N?
14:51:33 <Cale> yeah
14:51:40 <Philonous> Why does cabal try to install containers (and fail) even though I installed it manually before
14:51:52 <Cale> Philonous: maybe the version?
14:51:54 <vixey> you can express _that_ in lambda calculus
14:52:08 <Philonous> Nope, it's definitely the same version
14:52:12 <Cale> vixey: But it's all functions, not just the computable ones.
14:52:21 <dcoutts> Philonous: would you mind trying the darcs version of cabal-install. I added what I think is a fix for that problem about 10 min ago.
14:52:33 <Philonous> Really? great.
14:52:33 <Cale> vixey: So you can have a computable approximation...
14:52:41 <Philonous> Just need to find the repo.
14:53:05 <dcoutts> Philonous: darcs get --partial http://darcs.haskell.org/cabal-install/
14:53:14 <Philonous> Ah, thanks a bunch
14:53:21 <ziman> is cardinality of ℘(ℝ) greater than that of ℝ?
14:53:25 <Cale> yes
14:53:38 <Botje> the first has two strange letters, the other only one
14:53:43 <Cale> For any set X, the powerset of X has larger cardinality than X.
14:53:43 <mauke> for all values of R
14:53:45 <dcoutts> Philonous: I was just drafting an email asking people to test it :-)
14:54:19 <Cale> Whether there are any cardinalities in between when X is an infinite set to begin with is an unanswerable question.
14:54:43 <Cale> (you can decide whether or not you want there to be any as an axiom, and it won't conflict with the others)
14:55:10 <dcoutts> Philonous: when you've done that I think it's probably best to unregister the containers that you installed, it's generally a bad idea to have the same version in the user db as well as the global db. Different versions are ok, but the same version causes problems.
14:55:36 <ziman> hm, interesting.
14:55:41 <hoopy> moo
14:55:43 <Philonous> I've installed everything in the user-db, so thare shouldn't be a problem?
14:55:43 <Cale> A funny thing happens when you decide that there's no cardinality between the naturals and the reals though.
14:55:50 <Philonous> there*
14:56:01 <dcoutts> Philonous: the containers package is registered globally, it comes with ghc.
14:56:22 <Philonous> Oh, ok.
14:56:24 <dcoutts> Philonous: if you do a --dry-run -v it'll say why it's going to reinstall it.
14:56:26 <Cale> It means that you can get a chain of countable subsets of the reals, each contained in those before it, such that the union of the chain is all the reals.
14:56:49 <tjb> I'm having a problem with a "reduce" type operation.  I'm trying to process an input list [a] and replace certain two item sequences with a single item -- any good ideas on how to express this?  my code is at http://hpaste.org/13196#a0
14:57:13 <Cale> Or, to put that a better way, you can order the real numbers in such a way that the set of predecessors of any given real is a countable set.
14:57:22 <mauke> tjb: needs more parens
14:57:42 <tjb> mauke: in the definition line?
14:57:55 <pumpkin> :o
14:57:58 <ziman> hmm, wow. :)
14:58:08 <Philonous> Can I flush the entire db?
14:58:09 <mauke> s/(\S+:\S+)/($1)/g, basically
14:58:55 <dcoutts> Philonous: yes but you'd have to reinstall every package
14:59:07 <Cale> If you allow a cardinality in between N and R, say Aleph_1, then the best you can do is to have the set of predecessors of any given real have cardinality less than or equal to Aleph_1.
14:59:13 <tjb> mauke: ah, interesting -- thanks
14:59:24 <Philonous> Oh, now I see why it wants to reinstall. I had to compile it with base 4, but cabal wants to build it with base 3
14:59:41 <Philonous> dcoutts: Doesn't matter, that are not too many
14:59:55 <dcoutts> Philonous: assuming you've got containers-0.2.0.0 registered in the user db, just unregister it.
14:59:59 <Cale> But the well-ordering theorem lets you put an ordering on a set of any given cardinality such that the set of predecessors of any element is a smaller cardinality than the whole set.
15:01:58 <ziman> does it hold for Z, too? Or is Z not well-ordered?
15:02:05 <tehgeekmeister> dcoutts: any other ideas what to look into to get takusen to build?
15:02:09 <Cale> Z isn't well ordered under its usual ordering.
15:02:11 <Philonous> dcoutts: containers-0.2.0.0 it is. But it won't compile when I try to build it with cabal (complains about Data.Data being hidden), so I changed the cabal file to require base >=4. That worked, but now it wants to reinstall
15:02:18 <Cale> But it's easy to give it an ordering which makes it well-ordered.
15:02:32 <Cale> 0, 1, -1, 2, -2, 3, -3, ...
15:02:50 <ziman> i see
15:03:19 <Cale> You can express Z as a union of nested finite sets.
15:03:22 <drdozer> hi
15:03:34 <Cale> {}, {0}, {0,1}, {0,1,-1,}, ...
15:03:42 <drdozer> I've written a little genetic algorithm program using the Random monad
15:03:49 <drdozer> it seems to slow down as ti goes on
15:04:03 <drdozer> each generation seems to get slower to calculate than the previous one
15:05:06 <Philonous> dcoutts: apparently cabal install ignores the cabal file (though it doesn't overwrite it). Where would I change the dependencies so cabal install containers would use the right packages?
15:06:04 <ziman> yeah, quite simple for such set :)
15:06:38 <pejo> Philonous, run "cabal install" (no arguments) in the directory with the unpacked sources and the edited cabal file, that should pick up the changes.
15:07:20 <pejo> Philonous, last time I checked cabal install reads the cabal from a tarred index stored in .cabal/packages/..., quite confusing imho.
15:07:48 <Philonous> pejo: Did that, that leads to cabal trying to reinstall it with the original cabal file once the package is required by another one
15:08:13 <Philonous> pejo: Yeah, I edited the tar file. That lead to cryptic errors.
15:09:07 <dcoutts> Philonous: take a look at the output with --dry-run -v, see what packages it is selecting that you think are wrong.
15:10:54 <Philonous> "containers-0.2.0.0 (reinstall) changes: base-4.0.0.0 -> 3.0.3.0"
15:11:41 <mib_8cygdxfg> kfish : hi, i can't run your type-level instant insanity with GHCi 6.6 or GHCi 6.10.1 . Did you use GHCi 6.8 ?
15:11:58 <WildRhyno> ok
15:12:23 <kfish> mib_8cygdxfg, hey!
15:12:28 <kfish> it may have been 6.8
15:12:29 <WildRhyno> hi
15:12:33 <dcoutts> Philonous: are there any other packages that overlap between the user and global db exactly?
15:12:37 <WildRhyno> who is kfish?
15:12:40 <kfish> mib_8cygdxfg,  what errors do you get?
15:13:00 * dons notices lots of new faces
15:13:04 <WildRhyno> does anyone irc a lot?
15:13:17 <pumpkin> WildRhyno: lots of people do
15:13:18 <mib_8cygdxfg> kfish : everyhing is fine except :t solutions (u::Cubes)
15:13:23 <Philonous> dcoutts How do I find out?
15:13:25 <kfish> WildRhyno, hi -- do /whois username for names etc :-)
15:13:29 <mib_8cygdxfg> kfish : the last one
15:13:33 <dcoutts> Philonous: ghc-pkg list
15:13:43 <Philonous> Ok, sec
15:13:44 <WildRhyno> Are there profiles like on yahoo?
15:13:48 <pumpkin> WildRhyno: no
15:13:50 * taari raises an eyebrow
15:13:52 <dcoutts> Philonous: the only other time I've seen that behaviour is when there is overlap. It confuses ghc and cabal.
15:14:00 <mib_8cygdxfg> kfish : infinite loop
15:14:07 <pumpkin> WildRhyno: although just googling for some nicks will give you info on them
15:14:19 <WildRhyno> what does a/s/l mean?
15:14:30 <dcoutts> dons: I hope you're using the darcs version of cabal-install to help me test the recent dep resolver tweaks :-)
15:14:33 <dons> WildRhyno: do you have a haskell question?
15:14:37 <dons> dcoutts: good thinking
15:15:15 <WildRhyno> i tried for help with a new program called filezilla, but no one would help me...
15:15:24 <pumpkin> WildRhyno: haskell?
15:15:25 <WildRhyno> What is haskell
15:15:30 <pumpkin> um
15:15:34 <pumpkin> the name of the channel you joined :P
15:15:39 <WildRhyno> brb
15:15:50 <adekoba> kk
15:15:52 <pumpkin> o.O
15:15:56 <adekoba> (troll)
15:16:00 --- mode: ChanServ set +o dons
15:16:09 <ozy`> WildRhyno: haskell is a programming language. we talk about it here
15:16:27 <mib_8cygdxfg> kfish : i noticed that with only 2 constraints, there is no infinite loop in Operations (example MapAppend with MapAppend2 or MapAppend with MapAppend3) but i'm stuck with the triple constraint
15:18:02 <WildRhyno> i wan't to learn..
15:19:10 <vixey> WildRhyno, to programing in haskell? :)
15:20:15 <mib_8cygdxfg> kfish : by the way, have you an idea about adapting your code with the new family types which seem to become the new reference (instead of the functional dep.) ?
15:21:15 <tjb> My code "works", but it feels fairly ugly -- anyone have any better ideas? http://hpaste.org/13198#a0
15:21:44 <vixey> tjb, do you know pattern matching?
15:21:50 <vixey> tjb, and also foldl
15:22:03 <WildRhyno> no clue
15:22:07 <vixey> some kind of mix of those two seems a good idea
15:22:20 <tjb> vixey: I do -- I'll give those a shot
15:22:30 <hellige> have you ever seen ghci able to evaluate something, but not able to tell you its type?
15:22:31 * tjb attempting v2
15:23:43 <kfish> mib_8cygdxfg, what is your stack size set to?
15:23:48 <hellige> *Main> g `gmap` f $ "hi"
15:23:48 <hellige> "2"
15:23:48 <hellige> *Main> :t g `gmap` f $ "hi"
15:23:56 <hellige> (type error)
15:24:14 <vixey> hellige, what about  let foo = g `gma...
15:24:15 <vixey> ?
15:24:28 <kfish> mib_8cygdxfg, for type families etc. see http://www.haskell.org/haskellwiki/User_talk:ConradParker/InstantInsanity
15:24:34 <opqdonut> hellige: wow, what are f and g?
15:24:36 <mib_8cygdxfg> kfish : i think the default is set to 20 but i try up to 1000, 5000 ... !
15:24:48 <Philonous> dcoutts: Cabal and array overlap
15:25:17 <hellige> vixey: the version with let works...
15:25:23 <hellige> :t let foo = ... in foo
15:25:24 <chrisdone> protip to self: when seeing a type error for a value in a list that looks right, look at the other values in the list ~_~
15:25:24 <lambdabot> parse error on input `...'
15:25:36 <hellige> is it to do with defaulting of something?
15:25:43 <opqdonut> might be
15:25:49 <hellige> opqdonut: f and g are simple: length and show, basically
15:26:03 <hellige> opqdonut: gmap is defined in a type class involving associated types.
15:26:13 <ziman> tjb, this one uses pattern matching http://hpaste.org/13198#a1
15:26:14 <bos31337> @seen cale
15:26:15 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 22m 40s ago.
15:26:26 <hellige> opqdonut: so i think that's the thing that's giving it trouble...
15:27:00 <tehgeekmeister> attempting to install takusen 0.8.1 instead of the latest, i get this error: "ghc-pkg: /usr/include/postgresql/8.3/server doesn't exist or isn't a directory (use --force to override)", any ideas how to conquer it?
15:27:48 <dcoutts> Philonous: great, unregister both from the user db
15:27:58 <Philonous> Just did that
15:28:04 <dcoutts> Philonous: if ghc-pkg says it breaks other things then unregister those too
15:28:05 <tjb> ziman, ski: looks good -- thanks for the ideas
15:28:25 <kfish> mib_8cygdxfg, as for ghc version it must have been 6.6 or so, before any need to set  -XTypeOperators -XEmptyDataDecls etc.
15:28:53 <mib_8cygdxfg> kfish : yes, I followed the link this afternoon but i can't compile the given code and i don't understand the family types described there yet (i was hoping for a nicer paper like yours :) )
15:29:36 <kfish> :)
15:30:00 <Philonous> dcoutts: That worked. Great.
15:30:11 <Philonous> dcoutts: Thanks and sorry for the fuss
15:30:48 <drdozer> is there any good reason why code in MonadRandom should slow down?
15:31:03 <mib_8cygdxfg> kfish : 6.6 have already the options with X ? I thought there was only the options with -f
15:31:10 <Olathe> Well, does it slow down randomly ?
15:31:26 <drdozer> no, it starts fast but as it itterates it slows down
15:31:37 <dcoutts> Philonous: it's not your fault. cabal-install does sometimes re-install the same versions of packages in the userdb and then that messes things up. It's another problem for me to try and handle :-)
15:32:11 <drdozer> each iteration should be doing the same amount of work
15:33:23 <vixey> augustss: is it true that  cons (List Nat) (cons (List Bool) nil)  will not type check in cayenne?
15:34:22 <sclv_> I blew my own mind earlier today!
15:34:27 <sclv_> been a while since i did that.
15:35:18 <sclv_> Was working with numeric integration of signals, and ended up with a differential equation that was slightly hairy.
15:36:11 <sclv_> so i just wrote it as a lazy recursion where the point value depended on the integral until that point.
15:36:16 <sclv_> and the program hung.
15:36:22 <Philonous> Now other things break... I guess I will reinstall ghc. ghci behaves funny as well. I just wish there whas a freebsd port for 6.10
15:36:37 <sclv_> so i tweaked a few things until I recovered laziness, and it just worked...
15:36:51 <sclv_> I know this isn't new, but it's so lovely.
15:37:09 <vixey> what was it you had to change to make it work?
15:38:22 <nolrai_East> Does IO have a MonadPlus instance?
15:38:22 <sclv_> I'm working with conal's segments. I had to change my integration function to operate a segment at a time, instead of all at once.
15:39:17 <mauke> > getChar `mplus` getChar
15:39:18 <lambdabot>   * Exception: "<IO Char>"
15:39:25 <sclv_> also, I had to change my sampling function to not require the length of a section of a segment, but to just keep trying until it hit "in bounds"
15:39:26 <mauke> (yes)
15:40:18 <sclv_> next week I need to add some memocombinators so it doesn't crawl.
15:40:48 <nolrai_East> > putChar 'a' `mplus` putChar 'b'
15:40:50 <lambdabot>   * Exception: "<IO ()>"
15:41:31 <sclv_> the lovely thing about this sort of programming is that the better I made my model (i.e. the more continuous), the shorter it became.
15:42:13 <nolrai_East> @src MonadPlus IO
15:42:13 <lambdabot> Source not found. Sorry.
15:42:42 <mauke> @src IO mplus
15:42:42 <lambdabot> m `mplus` n = m `catch` \_ -> n
15:42:50 <sclv_> norlai -- if the first throws an exception, you get the second.
15:43:07 <nolrai_East> but in what file is it?
15:43:07 <ski_> > return () :: IO ()
15:43:08 <lambdabot>   * Exception: "<IO ()>"
15:43:47 <sclv_> its in control.monad i think
15:43:50 <chrisdone> return $ nub $ join $ map find $ concat $ map tries $ argsInc gloss
15:43:50 <chrisdone> harrr I just had to paste that
15:43:53 <mib_8cygdxfg> kfish : no options TypeOperators in 6.6 . I've juste tried 6.10.1 with "-fglasgow-exts -XUndecidableInstances -XTypeOperators -XEmptyDataDecls " but no better
15:44:01 <chrisdone> just realised I'm using join one place and concat another
15:44:05 <chrisdone> WHICH DO I USE?
15:44:10 <mauke> chrisdone: most of those $ should be .
15:44:23 <pumpkin> chrisdone: join is cuter, I think
15:44:26 <sclv_> if its a list, use concat.
15:44:41 <sclv_> except if you want to turn concat $ map into =<<
15:44:42 <pumpkin> but join feels so much more esoteric
15:44:55 <sclv_> =<< is more expressive.
15:45:01 <mauke> concatMap
15:45:07 <sclv_> ew!
15:45:09 <chrisdone> mauke: optimisation!
15:45:20 <vixey> flip concatMap
15:45:44 <tjb> Expressing http://hpaste.org/13198#a0 with pattern matching makes sense -- now I'm trying to see how this could be expressed with foldl
15:45:54 <pumpkin> > (flip . flip $ (/)) 10 5
15:45:55 <lambdabot>   2.0
15:46:17 <chrisdone>           search = nub . concatMap find . concatMap tries . argsInc
15:46:17 <chrisdone>       return $ search gloss
15:46:17 <mauke> :t flip . flip
15:46:19 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
15:46:19 <chrisdone> better?
15:46:22 <sclv_> nubSort, groupSort, mapFind, where does it end?
15:46:28 <pumpkin> tjb: the head xs = blah could be blah:_
15:46:33 <vixey> tjb, you can think of foldl as walking down the list from the start to the end and dealing with the elements like that
15:46:36 <vixey> @src foldl
15:46:36 <lambdabot> foldl f z []     = z
15:46:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:46:59 <sclv_> @pl nub . concatMap find . concatMap tries . argsInc
15:47:00 <lambdabot> nub . (find =<<) . (tries =<<) . argsInc
15:47:07 <sclv_> much better
15:47:11 <chrisdone> is it, though?
15:47:37 <pumpkin> it makes sense but isn't exactly "readable" :P
15:48:18 <tjb> vixey: the part I'm not sure about is that my fold depends on (x1:x2:xs) and not just (x:xs)
15:48:30 <vixey> oh I didn't see that bit
15:48:34 <vixey> nevermind then
15:49:34 <ski_> tjb : where ?
15:49:43 <chrisdone> hm, yeah, okay
15:49:47 <chrisdone> I dig it. =<< it is
15:50:35 <tjb> ski_: I thought it would be the "x1 == 0x7d and x2 == 0x5d" part
15:50:44 <sclv_> has anybody done anything with automatic integration similar to automatic differentiation?
15:50:59 <ski_> tjb : i don't see that at <http://hpaste.org/13198#a0> ..
15:51:33 <vixey> sclv_, not possible, integration isn't compositional
15:51:58 <sclv_> well, not always..?
15:52:00 <tjb> ski_: It's not explicitly stated, but that is why I broke the "do_destuff" portion into two functions
15:52:00 <ski_> compositional in which sense ?
15:52:23 <vixey> the integral of  f . g  is not a expressible in terms of f, g and their integrals
15:52:29 <vixey> but this is true with derivatives
15:52:40 <sclv_> I want something that does integration over the simple stuff semi-symbolically and then for the complicated stuff gives up and goes for numeric methods.
15:53:27 <sclv_> i'm working with lots of things that are composed of sums of flat curves.
15:53:48 <sclv_> erm, linear functions that is.
15:54:03 <sclv_> so i want to be able to automatically and efficiently take them up and down the numeric tower.
15:54:56 <sclv_> conal's and augustuss' libraries are the only two hackaged versions of automatic differentiation, right?
15:55:25 <bos31337> @seen cale
15:55:25 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 51m 50s ago.
15:57:45 <conal> sclv_: i'm very intrigued with what you're up to.  will it be something you can share?
15:57:54 <sclv_> conal: parts.
15:58:09 <conal> sclv_: for one thing, i wonder if youre already building the next version of Reactive that i've had in mind.
15:58:13 <sclv_> its really basic basic modeling, as this stuff goes.
15:58:24 <solrize> sclv_ you want the risch algorithm and its descendants
15:58:46 <nolrai_East> sclv_ if there sums of linear functions, then arnt they polynomials?
15:59:16 <sclv_> just lines.
15:59:31 <sclv_> i.e. points joined by linear interpolation.
15:59:31 <solrize> oh i missed that part, yeah, you don't need fancy symbolic stuf
15:59:32 <mib_8cygdxfg> kfish : i'll try later. bye
15:59:58 <solrize> but the general method is this: http://en.wikipedia.org/wiki/Risch_algorithm
16:01:01 <sclv_> some bits of what i'm doing might be useful for reactive, but its very simple really.
16:01:32 <sclv_> since its all numeric modeling and simulation there's no threads at all, or notions of things that never happen, or soforth.
16:02:15 <conal> sclv_: i like simple.  there's no notion of threads in the reactive semantics either.  just in the implementation of (purely functional) unamb.
16:02:17 <sclv_> its really just a way of composing signals to do some analysis on them (i.e. price valuation)
16:02:34 <conal> sounds neat.
16:02:54 <sclv_> it is, but its also all a very direct consequence of the segment stuff.
16:03:03 <conal> :)
16:03:25 <sclv_> some better integration and memoization would be what turned it from "cute" into "useful" -- that's my project for next week.
16:04:10 <sclv_> at the moment integration is just trapezoidal, and differentiation is simple numeric.
16:04:57 <nolrai_East> @help
16:04:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:05:01 <conal> cool.  are you thinking of using vector-space for derivatives?
16:05:04 <nolrai_East> @list
16:05:05 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:05:09 <sclv_> I also think that type families might be better, since a "sampleable thing" is really just a container.
16:05:34 <bhurt> sclv_- just came in, what are you doing?  (it sounds interesting)
16:05:53 <sclv_> conal: I was thinking about it, but the simple numeric derivation is fine for the moment, and not inefficient, just sloppy.
16:05:56 <sclv_> its the integration that's killing me.
16:06:10 <sclv_> bhurt: just trying to bring a bit of frp to bear on simple modeling.
16:06:29 <sclv_> we got sick of crashy undocumented external c++ libraries :-)
16:06:50 <conal> sclv_: sure.  and my derivative tower stuff is quite general.  Not only infinitely many derivatives but with multi-dimensional domains.
16:07:12 <bhurt> There's a really cool trick for evaluating differentials in a parse-tree like environment.
16:07:18 <sclv_> right: that's the main obstacle really, is I need to wrap my head around the math more.
16:07:19 <bhurt> Based on the chain rule.
16:07:22 <solrize> sclv_ what's the problem with integrating those linear patches?
16:07:23 <nolrai_East> @help instance
16:07:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:07:40 <solrize> symbolic integration in general is a very messy subject
16:07:41 <nolrai_East> @help instances
16:07:42 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
16:07:44 <conal> bhurt: "automatic differentiation" perhaps.
16:07:51 <nolrai_East> @help instances MonadPlus
16:07:52 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
16:07:54 <bhurt> This isn't symbolic, this is algebraic.
16:07:57 <sclv_> i.e. I get basic automatic differentiation, but the generalization means I have to read more.
16:07:59 <bhurt> I'm trying to find the paper.
16:07:59 <nolrai_East> @instances MonadPlus
16:08:00 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:08:22 <bos31337> what's the ffi equivalent of C's ssize_t type?
16:08:25 <conal> sclv_: do you mean derivatives as linear maps ("calculus on manifolds")?
16:08:53 <conal> sclv_: or perhaps the infinite tower thing.
16:09:05 <nolrai_East> I still cant find the file where IO's MonadPlus instance is defined.
16:09:15 <sclv_> conal: before I want to use your library I need to think through what an affine space is, a basis is, and a linear map is :-)
16:09:33 <conal> sclv_: oh yeah.
16:09:54 <conal> sclv_: high cost of entry.  oops.
16:10:19 <nolrai_East> conal: are affine spaces related to affine planes?
16:10:34 <conal> nolrai_East: i don't know.  what's an affine plane?
16:10:52 <sclv_> conal: if I go "up" the tower in your library, can I go back down, or is it lossy?
16:10:59 <sclv_> because that would be the killer app.
16:11:11 <conal> sclv_: oh -- you mean integration?
16:11:30 <sclv_> right -- not in all cases, but just of things that are results of autodifferentiation to begin with.
16:11:47 <nolrai_East> A geometric object that has line, points, and incidence, that saticfies the euclidian parralell property. (but might not have concepts of angle or distance)
16:11:49 <conal> sclv_: well, maybe via a zipper
16:12:01 <sclv_> hmm... that might be worth exploring.
16:12:44 <conal> nolrai_East: gee, i don't know if the two notions are connected.
16:12:56 <sclv_> solrize: in any case, my problem with integrating these little linear segments is that I've "lost" the information that they're linear. By the time I'm integrating them, they're just arbitrary functions.
16:13:38 <solrize> how are they represented?
16:13:40 <sclv_> So I just want to come up with a lightweight way of encoding their characteristics, while maintaining them as functors, and all that good stuff, and also as transformable...
16:13:44 <conal> sclv_: the particular Segment type used in Signal can be swapped out for another one.
16:13:49 <sclv_> at the moment as :->#.
16:13:53 <bhurt> sclv_: basically, the trick is this: assume you have f(g(x), h(x)).  To evaluate f, you would first evaluate g, then h, then evaluate f based on those values (ignoring lazy evaluation here)- but the idea is that evaluation of the value of f is bottom up.
16:14:08 <conal> sclv_: i put (:->#) in there just as a simple placeholder.
16:14:23 <solrize> i don't understand :->#
16:14:25 <sclv_> conal: right. I tried that earlier today. but the typeclass constraints started to kill me and i threw it out.
16:14:47 <sclv_> I'm really working with :->
16:14:55 <nolrai_East> sclv_: That should be doable, maybe just a list of points?
16:14:57 <sclv_> (but its's composed of :->#s)
16:15:14 <nolrai_East> oh no that wont work.
16:15:21 <bhurt> However, the derivitive of f is (df/dg)(dg/dx) + (df/dh)(dh/dx), so you can calculate the derivitive top-down- first you evaluate the derivitive of f with respect to g and h, and push that value down to evaluate the derivitives of g and h wrt x.
16:15:21 <conal> sclv_: at the very least, you could use the Fun type from Reactive, along with a duration.
16:15:39 <sclv_> so I had data Func a t = Flat a | Linear a t | Func (a -> t)
16:15:52 <sclv_> ooh... is Fun sort of like that?
16:15:53 <conal> sclv_: oh okay, so you're ahead of me.
16:16:00 <conal> sclv_: yeah, minus Linear
16:16:07 <eu-prleu-peupeu1> my order of rhw got delayed until the end of january :(
16:16:11 <eu-prleu-peupeu1> thats really baddd
16:16:26 <bhurt> real world haskell rocks.
16:16:26 <conal> seems everyone loves rwh!
16:16:48 <tehgeekmeister> http://hpaste.org/13199#a1 <== getting a sqlerror at runtime with this, no idea why;; anyone can tell what i'm doing wrong?
16:16:59 <sclv_> Linear was the painful one. Because since linear is evaluated as mx + b it puts a constraint that either a = t or if you do m (realToFrac x) + b or something then you get all these extra other constraints.
16:17:11 <sclv_> So I got myself in a royal mess and rolled it all back.
16:17:19 <conal> sclv_: bummer :(
16:17:32 <sclv_> But I think that's sort of the right way, is to bite the bullet and resign myself to doubles everywhere and forget generality.
16:17:56 <nolrai_East> So, do you think Powell's technical books has RWH?
16:17:58 <eu-prleu-peupeu1> http://www.indopedia.org/Homespring_programming_language.html
16:18:05 <bhurt> sclv_: better explanation: http://en.wikipedia.org/wiki/Automatic_differentiation
16:18:10 <sclv_> it just makes everything five times more complicated, because you need to case everywhere.
16:18:11 <conal> sclv_: if you want to and are able to place some of your stuff in a public repo (e.g., BSD), i could help you with it.  might be good for both of us.
16:18:15 <sclv_> bhurt: thanks :-)
16:18:31 <sclv_> conal: i'll see if I can get something set up next week.
16:19:03 <sclv_> the other notion I'm playing with is a newtype for Absolute signals
16:19:13 <conal> sclv_: "absolute"?
16:19:21 <sclv_> which are just like normal signals except, obviously, not monoids, and carry with them a start time.
16:19:45 <sclv_> so I can take a signal from 0 to five years, say a curve of prices.
16:19:49 <conal> sclv_: i'm also working for a company (anygma), and i've persuaded them of the benefit to the company of keeping much of our work open, so as to get help from others.  is your company friendly to open source?
16:20:00 <sclv_> and make it "absolute"
16:20:14 <sclv_> i.e. now fixed to the day on which we're valuating it.
16:20:46 <sclv_> conal: i'm happy to share. the problem is just getting some of the repo stuff hooked up due to firewalls and nonsense.
16:20:47 <conal> sclv_: what do you get out fixing it?
16:21:01 <conal> sclv_: how about code.haskell.org?
16:21:22 <sclv_> conal: no ssh from work :-(. needs to be over darcs-server
16:21:49 <conal> sclv_: oh, urg.  i don't know how that stuff works.
16:22:12 <sclv_> in any case, fixing it to a date matters because certain parts of a value curve might actually "quantize" based on the date on which you valuate it.
16:22:28 <MarcWeber> sclv_: Maybe you can use a ssh http tunnel or such?
16:23:31 <conal> sclv_: do you mind saying which company you work for?
16:23:36 <sclv_> its also just semantically "true" information -- i.e. the segments we add to get the value curve are relative.
16:23:42 <sclv_> conal: deutsche
16:23:47 <sclv_> with jeffp
16:24:13 <sclv_> but the curve itself is only valid for a given date and is conceptually only true for that date.
16:24:24 <sclv_> then the valuation curve itself is a function of time.
16:24:50 <bhurt> sclv_: btw, I am the Brian Hurt of the FP meetup
16:25:07 <sclv_> bhurt: i figured. :-) good to see you hanging out here!
16:25:15 <bhurt> Thank RWH.
16:25:31 <sclv_> you're working your way through at the moment?
16:25:44 <bhurt> Yep.
16:25:58 <bhurt> Monad Transformers were a real lightbulb moment for me.
16:26:22 <bhurt> Several of the things that annoyed me about Haskell went away, once they were explained.
16:26:29 <sclv_> polymorphic liftIO is lovely.
16:26:42 <sclv_> in concept, at least. in practice it still scatters everywhere.
16:26:42 <conal> bhurt: perhaps you'll like applicative functors also, since they're their own transformers.
16:26:48 <bhurt> I'm not even touching that.
16:27:06 <bhurt> Just being able to combine the Maybe monad with other monads for error handling is a huge win.
16:27:32 <bhurt> Sort of the unix philosophy in programming languages- make your monads do one thing, right, and then combine them in interesting and usefull ways.
16:28:25 <conal> bhurt: composition !
16:28:37 <bhurt> Bingo.
16:28:51 <tehgeekmeister> how do i catch an exception to print out any info that might be in it?
16:29:31 <conal> tehgeekmeister: Exception derives from Show
16:29:42 <sclv_> bhurt: I had a real nice moment like that a little while ago when I realized that my errorT gave me a MonadPlus that let me write some fancy IO thing with multiple db queries like a list comprehension.
16:29:46 <conal> tehgeekmeister: so you can just 'show' th eexception.
16:30:07 <tehgeekmeister> conal: mkay, but how do i get the exception itself?
16:30:17 <tehgeekmeister> tehgeekmeister: i mean, how do i get some reference to it?
16:30:19 <conal> tehgeekmeister: catch/handle
16:30:21 <sclv_> @hoole catch
16:30:21 <koeien> catch
16:30:21 <lambdabot> package catch
16:30:21 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
16:30:21 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
16:30:28 <tehgeekmeister> conal: thanks
16:30:35 <conal> oh yeah, not that catch.  the new one
16:30:35 <sclv_> see the control.exception documentation for a host of functions.
16:30:55 <nolrai_East> @src IO mzero
16:30:56 <lambdabot> mzero       = ioError (userError "mzero")
16:31:11 <conal> tehgeekmeister: yeah, what sclv_ said.  the new Exception stuff is in Control.Exception
16:31:24 <nolrai_East> @src IO mplus
16:31:24 <lambdabot> m `mplus` n = m `catch` \_ -> n
16:31:34 <sclv_> gawd that's a hack.
16:31:48 <conal> wow -- i didn't know about that instance.
16:31:50 <chrisdone> dudeeee
16:31:52 <sclv_> IO exceptions for flow control for the lose.
16:32:03 <chrisdone> ever heard of ``const''‽
16:32:03 <koeien> ya rly
16:32:35 <sclv_> IO rly
16:32:49 <conal> there is a heritage of exceptions for flow control.  i think it was one of the three ideas behind Milner's ML/LCF.
16:32:58 <nolrai_East> conal: should it not exist? cause I cant find it.
16:33:24 <solrize> eh?  exceptions in Lisp go back much further than that
16:33:35 <Riastradh> Flow control?  Or do you mean `control flow'?
16:33:37 <conal> nolrai_East: MonadPlus IO?  i don't know.  i've never looked for it.
16:33:45 <sclv_> I'm all for using exceptions for flow control -- just not in plain IO.
16:33:46 <bhurt> conal: thanks for the pointer to Error, I'd missed that.
16:33:52 <conal> Riastradh: yeah, thanks.
16:34:01 <ozy`> @src Maybe >>=
16:34:02 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:34:04 <sclv_> I'd rather use them lifted in ErrorT
16:34:07 <ozy`> @src Maybe (>>=)
16:34:07 <conal> bhurt: thank sclv_
16:34:07 <lambdabot> (Just x) >>= k      = k x
16:34:07 <lambdabot> Nothing  >>= _      = Nothing
16:34:23 <Riastradh> Exceptions are orthogonal to control flow.
16:34:27 <tehgeekmeister> mmkay, now can i use catch on the right hand side of a <- in do notation?
16:34:30 <sclv_> otherwise you mix up your exceptions with the system's.
16:34:55 <Riastradh> They are often confused with a control flow mechanism because languages such as C++, Java, and ML implement aborting semantics for the signalling of exceptions.
16:34:56 <sclv_> Riastradh: not if you use them like that mplus instance. or for early exit from a loop, etc.
16:35:04 <sclv_> tehgeekmeister: yep!
16:35:20 <tehgeekmeister> sclv_: hum.  i must've misused it, then...
16:35:23 <Riastradh> A non-local control flow mechanism, I mean.
16:35:26 <conal> 'control flow' might be misleading for ML/LCF's use of exceptions.  it was for making composable theorem proving tactics.
16:35:52 <sclv_> x <- getChar `catch` \(e::EndOfFileError) -> etc...
16:36:48 <bhurt> With Error and Maybe, I'm not sure exceptions are necessary, IMHO.
16:37:06 <nolrai_East> :t fromMaybe
16:37:08 <lambdabot> forall a. a -> Maybe a -> a
16:37:32 <conal> bhurt: agreed.  different packaging.
16:37:49 <sclv_> also, asynchronous exceptions.
16:37:56 <sclv_> which are a whole other kettle of stuff.
16:38:05 <sclv_> conal, speaking of which, have you looked at block and unblock?
16:38:19 <sclv_> Those two might help defeat the remaining evil race conditions in unamb.
16:38:34 <tehgeekmeister> sclv_: this is what i did; conn <- Control.Exception.catch (connectPostgreSQL "dname=frwiki user=tehgeekmeister") print
16:38:37 <conal> sclv_: just today i did.  i don't think i grok them yet.
16:38:41 <tehgeekmeister> sclv_: get a type error from that
16:38:45 <sclv_> the source code to ghc's exception libraries is very enlightening.
16:38:46 <bhurt> conal: actually, I think Maybe/Error is *better* packaging.  You're guaranteed that someone, somewhere, is handling the error.  The only advantage traditional exceptions offer is maybe optimization- with GC, exiting out of N levels of functions is O(1).
16:39:01 <mauke> tehgeekmeister: that's because print doesn't return a postgresql connection
16:39:11 <sclv_> tehgeekmeister: print is of type IO () right, and the connect is of type IO postgreconn
16:39:34 <sclv_> so if you just want to print the exception, you can always print it then rethrow it.
16:39:36 <conal> bhurt: i sure don't know enough about exceptions to agree or disagree with "only advantage".
16:40:25 <nolrai_East> conal: btw, unamb is *NICE*.
16:42:38 <tehgeekmeister> and then after that there's no useful info in the exception.
16:42:41 <tehgeekmeister> =P
16:43:18 <sclv_> you're using HDBC?
16:43:25 <bhurt> conal: there are some things you can do with exceptions that you can't with Maybe/Error- like not catch them.  I'm of the opinion that disallowing most of the those things is a win.
16:43:36 <tehgeekmeister> sclv_: yeah
16:44:09 <sclv_> see the functions here: http://software.complete.org/static/hdbc/doc/Database-HDBC.html#15
16:44:10 <tehgeekmeister> sclv_: i can't even connect.  i figure i must be using the wrong string for options, but as best i can tell by the documentation i'm doing it right...
16:44:28 <sclv_> handleSqlError will be your friend.
16:48:25 --- mode: ChanServ set -o dons
16:49:10 <tehgeekmeister> hah; i had a typo in my connection string.
16:52:57 <Botje> tehgeekmeister: hello again
16:53:05 <Botje> what are you writing today? :)
16:53:07 <tehgeekmeister> Botje: yo!
16:53:16 <tehgeekmeister> i'm working on the same project, just a different part of it.
16:54:13 <ozy`> http://cache.boston.com/universal/site_graphics/blogs/bigpicture/2008_pt2/08_chinprep.jpg <== Java?!
16:54:57 <tehgeekmeister> ozy`: =D
16:57:53 <Botje> yay
16:58:15 <Botje> this is just the modern version of riders on horseback, surely?
16:58:33 <bhurt> No, that would be Fortran.
17:03:18 <ozy`> bhurt: fortran is riders on horseback...?
17:03:39 <bhurt> No one appreciates my attempts at humor.
17:05:14 <pizza__> the great artists are only appreciated after they are dead.
17:05:34 <conal> nolrai_East: thx!  i'm very excited about unamb, and especially lub.  i suspect unamb/lub can be nearly as powerful a tool as laziness for enabling modularity.
17:06:34 <conal> because it allows separate components to produce partial information which then gets combined (merged).
17:07:29 <conal> and, like laziness, it has a simple, purely functional semantics, despite its imperative implementation.
17:08:06 <conal> and deterministic semantics despite its nondeterministic building blocks.
17:08:53 <BMeph> Just curious, but is anyone working on, or even looked at, the latest toss into the RIA ring, Appcelerator? :)
17:09:07 <ozy`> RIA?
17:11:43 <BMeph> oxy': Rich Internet Application (e.g., Laszlo, AIR, "Silverfish")
17:11:55 <ozy`> aha
17:13:18 <BMeph> conal: Maybe we could get Haskell in on the ground floor of "ShinyTech" using your stuff... :)
17:16:37 <BMeph> Bah, gotta do errands, chat atcha later...
17:23:49 <vininim> cd ..
17:24:01 <vininim> err..
17:27:56 <tehgeekmeister> tried to do this: maybe (IO 0) (lift . insert) (page st) and got an error about the IO constructor not being in scope -- i just need a throwaway IO Int value for the default value for the maybe ;; what do i use?
17:29:33 <tehgeekmeister> oh, maybe return 1?
17:30:06 <tehgeekmeister> yep1
17:30:08 <tehgeekmeister> *yep1
17:30:10 <tehgeekmeister> ...
17:30:14 <tehgeekmeister> *yep!
17:44:09 <shapr> @users
17:44:09 <lambdabot> Maximum users seen in #haskell: 575, currently: 533 (92.7%), active: 5 (0.9%)
17:53:42 <chrisdone> :hoogle MaybeT
17:53:50 <chrisdone> @hoogle MaybeT
17:53:51 <lambdabot> package MaybeT
17:53:51 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
18:01:44 <racliv> @src +
18:01:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:01:50 <Gracenotes> @pl \a -> filter (\b -> head b == a) p
18:01:50 <lambdabot> flip filter p . (. head) . (==)
18:02:04 <racliv> @pl @src curry
18:02:04 <lambdabot> (line 1, column 1):
18:02:05 <lambdabot> unexpected "@"
18:02:05 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:02:40 <racliv> @src flip
18:02:41 <lambdabot> flip f x y = f y x
18:02:52 <racliv> @pl flip f x y = f y x
18:02:52 <lambdabot> flip = flip
18:02:57 <racliv> haha
18:04:34 <Gracenotes> is there some built-in function to find the last element of a list for which a certain f is true?
18:05:00 <Peaker> last . filter f ?
18:05:42 <Gracenotes> okay, so there isn't a function. that'll definitely do though
18:05:47 <racliv> @pl f = last . filter
18:05:47 <lambdabot> f = last . filter
18:05:57 <racliv> @pl f g = last . filter g
18:05:58 <lambdabot> f = (last .) . filter
18:06:40 <Peaker> > let lastBeer = last . filter ((=="beer") . take 4) in lastBeer ["hello", "beera", "bye", "beerb", "bah"]
18:06:41 <lambdabot>   "beerb"
18:06:55 <racliv> @src range
18:06:55 <lambdabot> Source not found. It can only be attributed to human error.
18:08:56 <racliv> > let f x = if x == 0 then [] else [x] ++ f (x - 1) in f 5
18:08:58 <lambdabot>   [5,4,3,2,1]
18:09:17 <racliv> > let f x = if x == 0 then [] else f (x - 1) ++ [x] in f 5
18:09:19 <lambdabot>   [1,2,3,4,5]
18:09:43 <racliv> @pl f x = if x == 0 then [] else f (x - 1) ++ [x]
18:09:43 <lambdabot> f = fix (ap (flip if' [] . (0 ==)) . (`ap` return) . ((++) .) . (. subtract 1))
18:10:10 <twanvl> > [1..5]
18:10:11 <lambdabot>   [1,2,3,4,5]
18:11:34 <racliv> > let f = [1..] in f 5
18:11:36 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
18:11:53 <racliv> > let f = (.. 1) in f 5
18:11:54 <lambdabot>   <no location info>: parse error on input `..'
18:11:59 <twanvl> ?pl \n ->[1..n]
18:11:59 <lambdabot> enumFromTo 1
18:13:03 <Deuliops> 1..100
18:13:19 <racliv> @src len
18:13:20 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:13:20 <Gracenotes> Peaker: hm, how about the first element to meet a condition?
18:13:42 <Gracenotes> and, if one doesn't exist, a default element?
18:13:50 <Deuliops> [1..100]
18:13:57 <Gracenotes> there are so many functions, I'm sure I'm missing one :)
18:14:07 <Saizan> ?type find
18:14:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:14:40 <Gracenotes> ah, that'll work well with the maybe function
18:15:08 <Deuliops> > [1..100]
18:15:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:15:11 <Saizan> ?ty \f x -> fromMaybe x . find f
18:15:12 <lambdabot> forall a. (a -> Bool) -> a -> [a] -> a
18:15:35 <Gracenotes> oh, even better :)
18:18:27 <Deuliops> > reverse [1..50]
18:18:28 <lambdabot>   [50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26...
18:18:46 <Deuliops> > sum (reverse [1..50])
18:18:48 <lambdabot>   1275
18:19:23 <whoppix> Deuliops won't be any different without the 'reverse' :)
18:19:29 <Deuliops> :)
18:27:12 <MrTree> #concatenative
18:34:45 <afabian> In ghci, what can I type in to get a bottom value to play with?  1/0 gives me an infinity, bot is not in scope, and _|_ is parse error on |.
18:35:06 <mbz> let bottom = bottom ?
18:35:26 <afabian> ...I think that did it.
18:35:46 <mbz> > let bottom = bottom in bottom
18:35:58 <mbz> @bot
18:35:58 <lambdabot> :)
18:35:58 <lunabot>  :)
18:36:01 <lambdabot>   thread killed
18:37:12 <gwern> > 4200 / 200
18:37:13 <lambdabot>   21.0
18:37:40 <augustss> @pl \f -> fromJust $ lookup "b" [("a", f)]
18:37:40 <lambdabot> fromJust . lookup "b" . return . (,) "a"
18:38:06 <mbz> @pl \a b c -> (a,b,c)
18:38:06 <lambdabot> (,,)
18:38:25 <mbz> @pl \a b c d -> (d,c,b,a)
18:38:25 <lambdabot> flip (flip . (flip .) . flip (flip . flip (,,,)))
18:39:14 <shrughes> > undefined
18:39:15 <lambdabot>   * Exception: Prelude.undefined
18:39:30 <mbz> @type undefined
18:39:31 <lambdabot> forall a. a
18:39:36 <shrughes> afabian: ^^
18:39:41 <mmorrow> @src undefined
18:39:42 <lambdabot> undefined =  error "Prelude.undefined"
18:39:57 <mmorrow> @src error
18:39:57 <lambdabot> error s = throw (ErrorCall s)
18:50:06 <Cale> let undefined | False = undefined in undefined
18:50:14 <Cale> > let undefined | False = undefined in undefined
18:50:15 <lambdabot>   * Exception: /tmp/1180417760494460825:71:36-64: Non-exhaustive patterns in ...
18:50:28 <chrisdone> ~_@
18:50:34 <Cale> (that was a definition for undefined in old preludes :)
18:52:32 <chrisdone> dons: ha, I love how some redditers thought it was a big list of unsafe* functions that were actually in the standard library. couldn't wait to jump in and say "ha! haskell can't be pure!!". it cracks me up
18:55:27 <Gracenotes> It seems there are a lot of data-splitting methods being written at the moment, but are there any in Prelude now that go like "split on first element for which f is True"?
18:56:10 <chrisdone> yeah, in Data.List, uhh
18:56:13 <Gracenotes> best I can get is a takeWhile/dropWhile combination
18:56:17 <Cale> > span even [2,4,6,7,9,12]
18:56:18 <lambdabot>   ([2,4,6],[7,9,12])
18:56:24 <chrisdone> span and break
18:56:24 <Cale> > break odd [2,4,6,7,9,12]
18:56:25 <lambdabot>   ([2,4,6],[7,9,12])
18:56:29 <Gracenotes> ah, okay
18:56:37 <chrisdone> but those are implemented in takeWhile/dropWhile, perhaps
18:56:39 <chrisdone> @src break
18:56:40 <lambdabot> break p =  span (not . p)
18:56:43 <chrisdone> @src span
18:56:44 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:56:47 <Cale> They aren't really.
18:56:51 <chrisdone> ah, ok
18:56:52 <Gracenotes> RWH has a lot of useful functions, but I forget their names :)
18:57:08 <chrisdone> ❤RWH❤♥
18:57:12 <Cale> They're implemented more efficiently. The H98 specifies them using takeWhile and dropWhile though.
18:57:16 <chrisdone> sure
18:57:40 <redditbot> unsafe*
18:57:40 <redditbot> Success! Gtk2Hs on Mac OS without X11
18:57:42 <chrisdone> like "you can use takeWhile and dropWhile, and it would be a confirming implementation"
18:59:31 <Gracenotes> @hoogle (a -> b) -> (a, b)
18:59:32 <lambdabot> Control.Arrow arr :: Arrow a => (b -> c) -> a b c
18:59:32 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
18:59:32 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
18:59:50 <Gracenotes> @hoogle (a, b) -> (a -> b)
18:59:51 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
18:59:51 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
18:59:51 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
19:00:24 <Gracenotes> hm. *looks on Hoogle-web*
19:01:41 <Gracenotes> oh! uncurry! :D
19:01:55 <Gracenotes> joy and joyousness.
19:03:27 <ozy`> people were talking about a safer, more expressive alternative to C (as a kernel language) the other night, and I found this interesting... http://home.att.net/~jimmaureenrogers/AdaAdditionToDComparisonTable.htm
19:05:27 <rastar> why not just code the kernel in html ?
19:05:40 <cjay> :>
19:06:07 <Gracenotes> rastar: maybe if you had a non-standard HTML interpreter :)
19:09:38 <cjay> ozy`: iirc garbage collection in Ada is an optional feature
19:10:02 <ozy`> cjay: yes, it is
19:11:30 <Gracenotes> another question: is there a less imperative way to do Bool -> a -> a -> a? aka if/then/else
19:12:08 <ozy`> cjay: though that's moot in the context of kernel development, anyway, no? a kernel language should have a bare minimum runtime
19:12:17 <dons> Gracenotes: use a guard?
19:14:56 <cjay> ozy`: imho there is nothing wrong with garbage collection in the kernel. There are experimental OSes doing it.
19:15:27 <cjay> but I don't know much about kernel developement
19:15:36 <racliv> could you make a variable argument function if you explicitly curry?
19:16:21 <ozy`> racliv: if you perform some very sketchy trickery with type signatures you can make the last arg a vararg
19:16:50 <ozy`> or you could just use a list :p
19:18:09 <enolan> @hoogle printf
19:18:10 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:18:10 <lambdabot> module Text.Printf
19:18:10 <lambdabot> package printf-mauke
19:18:10 <Gracenotes> dons: do you mean something like fromMaybe b (guard expr >> Just a)?
19:18:23 <enolan> racliv: printf uses said trickery
19:18:29 <Gracenotes> I'm trying to make a lambda into a pointfree expression, and the if/then/else is kind of getting in the way
19:20:34 <ozy`> Gracenotes: does it help to point out that you can apply a function returned from an if-statement to more arguments?
19:21:04 <Gracenotes> ozy`: hm, what do you mean?
19:22:17 <BMeph> augustss: Did you ever package up your funny write-C-looking-code-in-Haskell mods somewhere? :)
19:22:35 <ozy`> Gracenotes: (if x then length else sum) xs
19:22:38 <augustss> BMeph: No, it's too horrid. :)
19:22:47 <racliv> > mod 6 3
19:22:48 <lambdabot>   0
19:22:55 <mmorrow> > printf "%d %d" 42 :: String
19:22:57 <lambdabot>   "42 * Exception: Printf.printf: argument list ended prematurely
19:23:04 <Gracenotes> hm, lemme see if that'll work here
19:23:17 <racliv> > rg 0 10 2 where rg min max step = filter (\x -> (mod (x - min) step) == 0) [min..max]
19:23:19 <lambdabot>   [0,2,4,6,8,10]
19:23:31 <racliv> @pl rg min max step = filter (\x -> (mod (x - min) step) == 0) [min..max]
19:23:32 <lambdabot> rg = ap ((.) . flip . (filter .) . flip flip 0 . ((flip . ((==) .)) .) . flip . (mod .) . subtract) enumFromTo
19:23:34 <augustss> BMeph: I could, but there's no real reason to do what I did.
19:24:13 <Gracenotes> ozy`: I'm trying to do a sort of code-golf thing as an exercise :)
19:24:21 <ozy`> Gracenotes: gotcha :p
19:25:08 <Gracenotes> the main part of the function is done: map(\o->maybe o(!!2)$find((o ==).head)p)). now I just need to generate p... >_>
19:25:23 <racliv> @src (..)
19:25:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:25:31 <racliv> @src enumFromTo
19:25:32 <lambdabot> Source not found. Maybe you made a typo?
19:25:38 <BMeph> augustss: Okay. It just reminded me of a reddit thread commenting on some quicksort executions, that someone had tried your code, but didn't have access to your DSEL warpedness. :)
19:26:19 <augustss> BMeph: my code was quite slow because ghc lacks some optimizations.
19:26:51 <Gracenotes> @hoogle a -> [a]
19:26:51 <lambdabot> Prelude repeat :: a -> [a]
19:26:51 <lambdabot> Data.List repeat :: a -> [a]
19:26:51 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
19:27:24 <racliv> > [(+), (*)] `ap` [4] `ap` [6]
19:27:25 <lambdabot>   [10,24]
19:27:42 <racliv> > [(+), (*)] `ap` [4]
19:27:43 <lambdabot>       Overlapping instances for Show (a -> a)
19:27:43 <lambdabot>        arising from a use of `s...
19:27:52 <Gracenotes> > (replicate 1) "singleton"
19:27:53 <lambdabot>   ["singleton"]
19:28:46 <ozy`> racliv: what the...
19:29:06 * ozy` stabs the list monad >_>
19:29:08 <Cale> > [(+), (*)] `ap` [1,2,3] `ap` [4,5]
19:29:09 <lambdabot>   [5,6,6,7,7,8,4,5,8,10,12,15]
19:29:22 <Cale> > [(+), (*)] <*> [1,2,3] <*> [4,5]
19:29:23 <lambdabot>   [5,6,6,7,7,8,4,5,8,10,12,15]
19:30:06 <kpreid> [(*),(**)] <*> [8], [88]
19:30:11 <kpreid> > [(*),(**)] <*> [8] <*> [88]
19:30:12 <lambdabot>   [704.0,2.9642774844752947e79]
19:31:07 <Gracenotes> @pl \a -> \b -> (replicate 1 (const a b))
19:31:08 <lambdabot> (replicate 1 .) . const
19:31:27 <racliv> > ap [(+), (*)] [4] [6]
19:31:29 <lambdabot>   Couldn't match expected type `[t1] -> t'
19:32:00 <ozy`> @pl \f xs -> concat $ map f xs
19:32:00 <lambdabot> (=<<)
19:32:05 <ozy`> goddammit
19:32:21 <kpreid> @pl \a b c -> a <*> b <*> c
19:32:21 <lambdabot> ((<*>) .) . (<*>)
19:32:44 <racliv> @pl \a b c -> a <*> [b] <*> [c]
19:32:45 <lambdabot> flip flip return . (((.) . (<*>)) .) . (. return) . (<*>)
19:32:50 <kpreid> > ((ap .) . ap) [(+),(*)] [4] [6]
19:32:51 <lambdabot>   [10,24]
19:33:15 <Gracenotes> @src if'
19:33:15 <lambdabot> Source not found. You speak an infinite deal of nothing
19:33:44 <ozy`> @hoogle if'
19:33:44 <lambdabot> No results found
19:33:47 <ozy`> hmmm
19:33:49 <racliv> @pl [(+), (*)] <*> [4] <*> [6]
19:33:50 <lambdabot> [(+), (*)] <*> [4] <*> [6]
19:34:05 <Gracenotes> :t if'
19:34:06 <lambdabot> Not in scope: `if''
19:34:20 <Gracenotes> @pl if a then b else c
19:34:20 <lambdabot> if' a b c
19:34:26 <Gracenotes> rawr.
19:34:44 <ozy`> @unpl (if' a b c) x
19:34:44 <lambdabot> if' a b c x
19:34:58 <ozy`> @pl (if a then b else c) xs
19:34:59 <lambdabot> if' a b c xs
19:35:28 * ozy` is digging into the turf with wild swings of his nine iron
19:37:00 * BMeph suspects that's what ozy's girlfriend says, too
19:38:31 <ozy`> BMeph: on the subject of code brevity, you could have very easily reduced that to "that's what she said"...
19:38:35 <ozy`> :p
19:38:45 <racliv> is the w combinator built-in?
19:40:31 <gio123> Cale:hi
19:41:25 <Gracenotes> hm, there's really no way to do recursion without name-binding, is there?
19:41:51 <ozy`> Gracenotes: there's the Y combinator
19:42:01 <Gracenotes> sounds scary :3
19:42:03 <ozy`> which I still haven't taken the time to wrap my head around
19:42:39 <BMeph> racliv: How does it operate again? :)
19:42:59 <racliv> w f x = f x x
19:43:48 <Botje> Gracenotes: write your function so that it expects itself as first argument. then apply y combinator.
19:43:53 <Botje> presto, instant recursive function
19:44:00 <Botje> add seasoning to taste, server cold
19:44:02 <Botje> -t
19:44:03 <Gracenotes> well, I suppose I could curry as so: (let o a = b; o c = d in o)
19:44:03 <BMeph> racliv: looks like join. :)
19:44:08 <Botje> --t -r
19:44:13 <racliv> @hoogle join
19:44:13 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
19:44:13 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
19:44:13 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
19:44:42 <BMeph> @src (a ->) join
19:44:43 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:44:43 <Gracenotes> BMeph: Botje: is there a web resource for comprehending this "y combinator" you speak of? D:
19:44:51 <BMeph> @src join (a ->)
19:44:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:45:04 <BMeph> @src join ((->) a)
19:45:04 <lambdabot> Source not found.
19:45:13 <BMeph> @src ((->) a) join
19:45:13 <lambdabot> Source not found. Maybe you made a typo?
19:45:13 <Botje> Gracenotes: most lambda calculus courses will talk about it
19:45:24 <Gracenotes> okay, does one exist in Haskell?
19:45:35 <Botje> :t fix
19:45:36 <lambdabot> forall a. (a -> a) -> a
19:45:38 <BMeph> Gracenotes: Many. :)
19:46:09 <Gracenotes> > fix negate
19:46:10 <lambdabot>   * Exception: stack overflow
19:46:13 <Botje> > fix (\fac x -> if x < 2 then 1 else x * fac (x - 1)) $ 5
19:46:14 <lambdabot>   120
19:47:02 <Botje> woops
19:47:06 <Botje> look at the time
19:47:16 <Botje> sun's coming up in three hours
19:47:23 <Botje> time to go lie down a bit
19:49:15 <racliv> > join (*) 6
19:49:17 <lambdabot>   36
19:50:38 <racliv> > join (join (*)) 6
19:50:39 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a1
19:50:39 <lambdabot>      Prob...
19:51:39 <Taejo> :t join (*)
19:51:40 <lambdabot> forall a. (Num a) => a -> a
19:51:50 <racliv> > (*) 6 join (*) 6
19:51:51 <lambdabot>       No instance for (Num ((a -> a -> a) -> a -> a))
19:51:52 <lambdabot>        arising from the...
19:51:59 <racliv> > (*) 6 (join (*) 6)
19:52:01 <lambdabot>   216
19:52:11 <mmorrow> > (*) 6 $ join (*) 6
19:52:13 <lambdabot>   216
19:52:17 <mmorrow> > (*) 6 . join (*) $ 6
19:52:18 <lambdabot>   216
19:52:52 <Gracenotes> @type curry
19:52:54 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:52:55 <Taejo> :t let boobs = (.).(.) in (*) `boobs` join (*) $ 6
19:52:57 <lambdabot> forall b a. (Num (a -> b), Num b) => a -> b -> b
19:53:03 <racliv> @pl \x -> (*) x (join (*) 6)
19:53:03 <lambdabot> (36 *)
19:53:08 <racliv> @pl \x -> (*) x (join (*) x)
19:53:09 <lambdabot> ap (*) (join (*))
19:53:27 <Taejo> since when does lambdabot do constant-folding?
19:53:37 <Taejo> @pl 6+3+(7*12)
19:53:38 <lambdabot> 93
19:53:58 <Taejo> @pl let x = 12 in 6+3+(7*x)
19:53:59 <lambdabot> 93
19:54:33 <ozy`> :t boobs
19:54:34 <lambdabot> Not in scope: `boobs'
19:54:43 <ozy`> @let boobs = (.).(.)
19:54:44 <lambdabot>  Defined.
19:54:48 <Taejo> @pl in 6+3+(7*(last [1..]))
19:54:48 <ozy`> :t boobs
19:54:48 <lambdabot> (line 1, column 1):
19:54:48 <lambdabot> unexpected reserved word "in"
19:54:48 <lambdabot> expecting white space, "()", natural, letter or digit, lambda abstraction or expression
19:54:49 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:55:36 <Taejo> ozy`: a useful operator
19:55:50 <ozy`> verily
19:55:59 <racliv> > ap (*) (f) 6 where f = ap (*) (join (*))
19:56:01 <lambdabot>   1296
19:56:05 <racliv> 6 ** 4
19:56:11 <racliv> 6 ** 4>
19:56:16 <racliv> > 6 ** 4
19:56:17 <lambdabot>   1296.0
19:56:34 <racliv> @unpl f = (.).(.)
19:56:35 <lambdabot> f i b c f = i (b c f)
19:57:28 <Taejo> also somewhat useful (and apparently discovered by \bot) is the owl operator: (.) $ (.)
19:57:49 <racliv> @unpl owl = (.)$(.)
19:57:49 <lambdabot> owl b c e f = b c (e f)
19:57:59 <mmorrow> @unpl owl = (.)(.)
19:57:59 <lambdabot> owl b c e f = b c (e f)
19:58:08 <Taejo> although you could write that as (.) (.) and call it the boobs-without-a-freckle-in-between operator
19:58:39 <mmorrow> i think if you're gonna call anything "boobs", it has to be (.)(.)
19:58:53 <mbac> i prefer broad-shouldered ladies myself
19:59:08 <racliv> @unpl dot = ((.).(.))
19:59:09 <lambdabot> dot i b c f = i (b c f)
19:59:37 <racliv> @unpl swing = flip . (. flip id)
19:59:38 <lambdabot> swing k b c = k (\ f -> f c) b
19:59:52 <Taejo> mmorrow: I agree... I just knew about (.).(.) first, and so gave it that name
19:59:58 <mmorrow> :)
20:00:22 <mmorrow> @type fmap `fmap` fmap
20:00:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
20:00:33 <mmorrow> @type  boobs
20:00:34 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:00:48 <mmorrow> @type fmap `fmap` fmap ::  (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:00:49 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:02:15 <mmorrow> if Cale had his way, (.) would be /defined/ as fmap
20:02:18 <racliv> @src const
20:02:18 <lambdabot> const x _ = x
20:02:32 <racliv> @pl const x _ = x
20:02:33 <lambdabot> const = const
20:02:43 <mmorrow> heh
20:02:58 <racliv> @pl s x y z = x z (y z)
20:02:58 <lambdabot> s = ap
20:03:00 <mmorrow> @pl x = x
20:03:00 <lambdabot> x = fix id
20:03:10 <Taejo> Haskellers looking at porn: fmap fmap fmap
20:03:30 <mmorrow> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
20:03:31 <lambdabot> ap (. join id) (. join id)
20:03:46 <mmorrow> @type ap (. join id) (. join id)
20:03:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
20:03:47 <lambdabot>     Probable cause: `id' is applied to too many arguments
20:03:47 <lambdabot>     In the first argument of `join', namely `id'
20:03:56 <mmorrow> @pl fail
20:03:57 <lambdabot> fail
20:04:19 <sutats> @src ap
20:04:20 <lambdabot> ap = liftM2 id
20:04:28 <racliv> @src liftM2
20:04:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:05:03 <racliv> @src liftM3
20:05:04 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
20:05:13 <mmorrow> @pl \x -> x x
20:05:13 <lambdabot> join id
20:05:34 <mmorrow> @pl \x -> y
20:05:34 <lambdabot> const y
20:06:32 <mmorrow> @pl (\x -> x (quote x)) (quote (\x -> x (quote x)))
20:06:33 <lambdabot> ap id quote (quote (ap id quote))
20:06:58 <mmorrow> @pl (\x -> x `app` (quote x)) (quote (\x -> x `app` (quote x)))
20:06:58 <lambdabot> ap app quote (quote (ap app quote))
20:07:37 <racliv> > timestimestimes 3 (4, 5) where timestimestimes = join ap (*)
20:07:39 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
20:07:39 <lambdabot>        Exp...
20:07:51 <racliv> > timestimestimes 3 (4, 5) where timestimestimes = ap (*) (*)
20:07:52 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
20:07:52 <lambdabot>      Proba...
20:07:58 <racliv> > timestimestimes 3 (4, 5) where timestimestimes = ap (*) (uncurry (*))
20:07:59 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
20:07:59 <lambdabot>        Exp...
20:09:17 <Taejo> :t join ap
20:09:19 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
20:09:19 <lambdabot>       Expected type: m (a -> b) -> m (a -> b) -> a1
20:09:19 <lambdabot>       Inferred type: m (a -> b) -> m a -> m b
20:09:36 <racliv> > timesSquare 4 3 where timesSquare = ap (*) (join (*))
20:09:37 <lambdabot>       No instance for (Num (t -> a))
20:09:37 <lambdabot>        arising from a use of `*' at <int...
20:09:52 <mmorrow> i hate it when you accidentally kill your irc window and your history is history
20:10:02 <racliv> @unpl f = ap (*) (join (*))
20:10:02 <lambdabot> f = (*) >>= \ b -> ((*) >>= \ g -> g) >>= \ a -> return (b a)
20:10:58 <mmorrow> @pl (\x -> x (q x)) (q (\x -> x (q x)))
20:10:58 <lambdabot> ap id q (q (ap id q))
20:11:04 <Gracenotes> hm, I wish there was a version of @pl meaning "less pointful" rather than "pointless" ;)
20:11:33 <chrisdone> mmorrow: that's why I log!™
20:11:42 <chrisdone> mmorrow: that's why iLog™
20:11:44 <mmorrow> , ap dynApp toDyn (toDyn (ap dynApp toDyn))
20:11:46 <lunabot>  <<Dynamic>>
20:11:58 <mmorrow> chrisdone: me too, but laziness is a virtue i've heard
20:12:07 <mmorrow> (or something ;)
20:12:16 <chrisdone> < _ >
20:12:23 <mmorrow> omg did you get the new iLog!
20:12:29 <chrisdone> haha
20:12:43 <chrisdone> it's even smaller than last time! I lost it!!:DD!11
20:12:49 <mmorrow> LOlol
20:13:46 <Gracenotes> hm, failing that... is there a way to use guards in lambdas? :)
20:13:51 <pumpkin> I'm doing it wrong :o
20:13:59 <chrisdone> yo dawg i herd you like iDevices so we put an iDevice in your iDevice so you can look good looking good
20:14:10 <racliv> > cube 3 where cube = ap (*) (join (*))
20:14:11 <lambdabot>   27
20:14:18 <chrisdone> I don't think lambdas do guards?
20:14:29 <racliv> > cube 3 where cube = ap (*) (join join (*))
20:14:30 <lambdabot>       Occurs check: cannot construct the infinite type:
20:14:30 <lambdabot>        m = (->) (m (m...
20:14:34 <chrisdone> > (\x | null x -> undefined) []
20:14:35 <Gracenotes> It didn't seem like they would
20:14:36 <lambdabot>   <no location info>: parse error on input `|'
20:14:38 <racliv> > cube 3 where cube = ap (*) (join (join (*)))
20:14:40 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
20:14:40 <lambdabot>      Proba...
20:14:40 <pumpkin> superjoin
20:14:57 <chrisdone> but you have case so it's aaawwwwwright
20:15:00 <racliv> > cube 3 where cube = ap (*) (superjoin (join (*)))
20:15:01 <lambdabot>   Not in scope: `superjoin'
20:15:04 <pumpkin> lol
20:15:08 <pumpkin> was just kidding :P
20:15:35 <chrisdone> add more joins, it makes it more powerful
20:15:36 <racliv> hmm
20:15:42 <Gracenotes> oh, that's right
20:15:48 <racliv> > cube 3 where cube = ap (*) (join (*) . join (*))
20:15:49 <lambdabot>   243
20:15:58 <pumpkin> not sure that counts as "cube" anymore :P
20:16:06 <racliv> yeah
20:16:12 <mbz> > (\x -> case x of { x | x > 0 -> 1; _ -> -1; }) 4
20:16:12 <chrisdone> join's great for that
20:16:14 <lambdabot>   1
20:16:23 <chrisdone> :t Text.XHtml.p
20:16:25 <lambdabot> xhtml-3000.2.0.0:Text.XHtml.Internals.Html -> xhtml-3000.2.0.0:Text.XHtml.Internals.Html
20:16:29 <racliv> ln 243 / ln 3
20:16:42 <racliv> > ln 243 / ln 3
20:16:43 <lambdabot>   Not in scope: `ln'Not in scope: `ln'
20:16:53 <pumpkin> > log 243 / log 3
20:16:55 <lambdabot>   4.999999999999999
20:16:56 <Riastradh> There is only one logarithm, racliv, and that is the natural logarithm.  All others are constant multiples of it.
20:17:02 <Riastradh> The name `ln' is silly.
20:17:11 <racliv> 3 ** 5
20:17:18 <shrughes> my high school calc teacher pronounced it "lawn"
20:17:20 <racliv> > 3 ** 5
20:17:21 <lambdabot>   243.0
20:17:31 <mmorrow> chrisdone: what hope they put an iDevice devourer in my iDevice in iDevice so i can let goodlookin = look good looking at myself looking goodlookin goodlookin
20:17:31 <racliv> > cube 3 where cube = ap (*) (join (*) . join (*) . join(*))
20:17:33 <lambdabot>   19683
20:17:36 <pumpkin> lol
20:17:37 <racliv> 3 ** 7
20:17:43 <racliv> > 3 ** 7
20:17:44 <lambdabot>   2187.0
20:17:46 <pumpkin> iterate the joins ;)
20:17:50 <shrughes> > 3 ** 9
20:17:52 <lambdabot>   19683.0
20:17:53 <mmorrow> chrisdone: ok i kinda botched that
20:18:05 <pumpkin> why **?
20:18:08 <chrisdone> hahaha
20:18:12 <shrughes> > 3 ^ 9 -- whatever
20:18:13 <chrisdone> i got it
20:18:14 <lambdabot>   19683
20:18:39 <pumpkin> > iterate (join (*)) 3
20:18:40 <lambdabot>   [3,9,81,6561,43046721,1853020188851841,3433683820292512484657849089281,1179...
20:18:42 <pumpkin> ack
20:18:44 <pumpkin> P
20:19:09 <pumpkin> > iterate (join (*) . join (*)) 3
20:19:10 <lambdabot>   [3,81,43046721,3433683820292512484657849089281,1390084523771447327649397867...
20:19:23 <racliv> > cube 3 where cube = ap (*) (join (*) . join (*) . join(*) . join (*))
20:19:25 <lambdabot>   129140163
20:19:32 <racliv> 3 ** 15
20:19:34 <racliv> > 3 ** 15
20:19:36 <lambdabot>   1.4348907e7
20:19:40 <pumpkin> use ^
20:19:43 <racliv> > 3 ** 13
20:19:45 <lambdabot>   1594323.0
20:19:49 <pumpkin> or not
20:19:52 <racliv> > 3 ^ 14
20:19:54 <lambdabot>   4782969
20:20:05 <shrughes> > 3 ^ 17
20:20:07 <lambdabot>   129140163
20:20:22 <racliv> :t ^
20:20:23 <lambdabot> parse error on input `^'
20:20:27 <racliv> :t (^)
20:20:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:20:29 <chrisdone> > let (²) = (^2) in (5²)
20:20:31 <lambdabot>   25
20:20:32 <nolrai_East> I want to change a "Maybe (IO a)" into a "IO (Maybe a)" is there a lib function to do that?
20:20:33 <chrisdone> :D
20:20:37 <pumpkin> lol
20:20:48 <racliv> :t (**)
20:20:50 <lambdabot> forall a. (Floating a) => a -> a -> a
20:21:05 <chrisdone> > 2.0 ** 2.0
20:21:06 <lambdabot>   4.0
20:21:23 <chrisdone> ._.
20:21:23 <shrughes> > let f n = 3 * (3 ^ (2 ^ n)) == ap (*) (foldr1 (.) (replicate n (join (*)))) 3 in all f [1..10]
20:21:24 <lambdabot>   True
20:21:33 <chrisdone> :t loeb
20:21:35 <lambdabot> Not in scope: `loeb'
20:21:36 <nolrai_East> > 1%2 ** 1%3
20:21:37 <mmorrow> , "²"
20:21:38 <lambdabot>       No instance for (Integral (Ratio t))
20:21:38 <lambdabot>        arising from a use of `show...
20:21:39 <lunabot>  "\178"
20:21:50 <chrisdone> mmorrow: have oyu seen loeb?
20:21:59 <nolrai_East> > (1%2) ** (1%3)
20:22:00 <lambdabot>       No instance for (Floating (Ratio t))
20:22:00 <lambdabot>        arising from a use of `**' ...
20:22:07 <chrisdone> @let loeb x = fmap (\a -> a (loeb x)) x
20:22:08 <lambdabot>  Defined.
20:22:16 <chrisdone> :t loeb
20:22:17 <racliv> @pl loeb
20:22:17 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
20:22:17 <lambdabot> loeb
20:22:18 <mmorrow> heh, you beat me to it
20:22:29 <chrisdone> racliv: haha
20:22:51 <nolrai_East> @pl loeb x = fmap (\a -> a (loeb x)) x
20:22:51 <lambdabot> loeb = fix (fmap . flip id =<<)
20:22:54 <chrisdone> @pl \x -> fmap (\a -> a (loeb x)) x
20:22:54 <lambdabot> fmap =<< flip id . loeb
20:23:00 <chrisdone> superior
20:23:00 <mmorrow> > loeb [\x -> (x!!1)+(x!!2), const 42, (!!3), const 99]
20:23:02 <lambdabot>   [141,42,99,99]
20:23:04 <pumpkin> so much loebing
20:23:14 <mmorrow> so little lobotomy?
20:23:30 <racliv> @hoogle fmap
20:23:31 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
20:23:31 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
20:23:31 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
20:23:34 <nolrai_East> What is loeb?
20:23:37 <chrisdone> so neutral labido
20:23:39 <pumpkin> wow, I really fail at this project euler problem, left it on while I went to see a movie, and it's still running :P maybe I should rethink my brute force approach
20:23:50 <mmorrow> sonar lambdas!
20:24:00 <SubStack> pew pew pew
20:24:13 <SubStack> pumpkin: which one?
20:24:15 <nolrai_East> @help djinn
20:24:16 <lambdabot> djinn <type>.
20:24:16 <lambdabot> Generates Haskell code from a type.
20:24:16 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:24:25 * SubStack <3 project euler
20:24:25 <pumpkin> 125 :P absolute naive, brute force approach :P
20:24:35 <chrisdone> unsafeGoNearUnevaluatedThunks
20:24:40 <mmorrow> @type let kungfu f a = f ($ kungfu f a) a in kungfu fmap
20:24:41 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
20:24:51 <nolrai_East> @djinn Maybe (IO a) -> IO (Maybe a)
20:24:51 <lambdabot> Error: Undefined type IO
20:25:04 <nolrai_East> !?
20:25:31 <mmorrow> @type \x -> maybe (return Nothing) (Just `fmap`) =<< x
20:25:32 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => f (Maybe (f a)) -> f (Maybe a)
20:25:33 <racliv> @help fix
20:25:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:25:48 <pumpkin> rot ? (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,ab,ac) -> (z,aa,ab,ac,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)
20:25:48 <racliv> @hoogle fix
20:25:49 <pumpkin> lol
20:25:49 <lambdabot> Data.Function fix :: (a -> a) -> a
20:25:49 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
20:25:49 <lambdabot> module Control.Monad.Fix
20:25:58 <SubStack> delicious combinatorics
20:26:04 <mmorrow> @type \x -> maybe (return Nothing) (Just `fmap`) `fmap`  x
20:26:05 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f, Monad f) => f1 (Maybe (f a)) -> f1 (f (Maybe a))
20:26:12 <mmorrow> grr
20:26:30 <SubStack> great, now I'll be up all night looking at this!
20:26:37 <nolrai_East> mmorrow: what you trying for?
20:26:48 <pumpkin> SubStack: "Hooray for haskell! \o/"
20:26:52 <pumpkin> :P
20:26:53 <mmorrow> @type \x -> maybe (return Nothing) (Just `fmap`) x
20:26:54 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => Maybe (f a) -> f (Maybe a)
20:26:56 <pumpkin> fanboi ;)
20:27:01 <mmorrow> that
20:27:14 <SubStack> for NOW
20:27:26 <mmorrow> @type maybe (return Nothing) (Just `fmap`) :: Maybe (IO a) -> IO (Maybe a)
20:27:27 <lambdabot> forall a. Maybe (IO a) -> IO (Maybe a)
20:27:27 <nolrai_East> Thanks!
20:27:32 <chrisdone> kind of bugs me that reddit's point system shows different points on different pages
20:27:33 <mmorrow> :)
20:27:37 <SubStack> it has been crazy good at getting these things solved!
20:27:43 <pumpkin> SubStack: there's someone in here with 221/222 of them :P
20:27:50 <SubStack> :o
20:28:27 <Cale> chrisdone: I noticed that too, it is annoying.
20:28:32 <chrisdone> now, is that person to be respected or given treatment and support s/he needs?
20:28:51 <pumpkin> chrisdone: to be committed to a mental institution :P
20:28:52 <nolrai_East> hmm
20:28:58 <Cale> The irritating thing about Project Euler is that all the answers are numbers.
20:29:03 <pumpkin> Cale: yeah
20:29:09 <chrisdone> Cale: why so?
20:29:19 <racliv> > cube 3 where cube = ap (*) (join (*) . join (*) . join(*) . join (*) . join(*))
20:29:21 <lambdabot>   5559060566555523
20:29:25 <shrughes> isn't there a problem where the answer is a pair of numbers?
20:29:26 <Gracenotes> is that so, me too >_>
20:29:33 <Cale> I feel more motivated by problems with universal quantifiers in them.
20:29:38 <racliv> > 3 ^ 33
20:29:39 <lambdabot>   5559060566555523
20:29:44 <pumpkin> well, for problems that need more than one number, they often ask you to just add them up
20:29:50 <pumpkin> or multiply them, or count them
20:29:51 <Gracenotes> and so irssi fails in one's ability to determine whether something is scrollback or not
20:29:53 <mmorrow> , let x = ord '²' - 2 in utf8enc . take 10 $ [x..]
20:29:55 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
20:30:04 <mmorrow> , let x = ord '²' - 2 in utf8enc . take 10 . fmap chr $ [x..]
20:30:09 <lunabot>  "\194\176\194\177\194\178\194\179\194\180\194\181\194\182\194\183\194\184...
20:30:12 <mmorrow> grr
20:30:17 <mmorrow> , let x = ord '²' - 2 in text . utf8enc . take 10 . fmap chr $ [x..]
20:30:20 <lunabot>  °±²³´µ¶·¸¹
20:30:28 <mmorrow> aww, they're not in a row
20:30:43 <pumpkin> but yeah, the kind of math on project euler is pretty restricted
20:30:44 <mmorrow> i had those in a file somewhere but i can't seem to find it
20:30:52 <pumpkin> the problems are still fun though
20:31:28 <racliv> @src fix
20:31:29 <lambdabot> fix f = let x = f x in x
20:31:39 <racliv> @pl fix f = let x = f x in x
20:31:39 <lambdabot> fix = fix id
20:31:49 <nolrai_East> I got board like at like 15 or 20 I think, maybe latter, somewhere any way.
20:31:54 <mmorrow> fix is minimal
20:31:58 <mmorrow> @pl let x = f x in x
20:31:59 <lambdabot> fix f
20:32:06 <mmorrow> @pl \f -> let x = f x in x
20:32:06 <lambdabot> fix
20:32:18 <pumpkin> nolrai_East: the first ones aren't too interesting
20:32:23 <mmorrow> or s/minimal/you know what i mean/
20:32:42 <SubStack> pumpkin: good for learning haskell with
20:32:48 <nolrai_East> When do they get interesting?
20:32:58 <pumpkin> nolrai_East: I dunno, randomly sample higher numbered ones :P
20:32:58 <racliv> @src loeb
20:32:59 <lambdabot> Source not found. You untyped fool!
20:33:03 <pumpkin> nolrai_East: that's what I do
20:33:12 <mmorrow> loeb a = fmap ($ loeb a) a
20:33:12 <nolrai_East> Ok makes sense.
20:33:29 <shrughes> @pl let x = (let y = f x in if g y then y else x) in x
20:33:30 <lambdabot> fix (ap (flip (if' =<< g)) f)
20:34:41 <racliv> is there a list of haskell combinators somewhere?
20:36:36 <shrughes> of _all_ of them?  None that I've seen.  There is the documentation of Data.Function for _seven_ of them.
20:36:59 <shrughes> I assume you're asking about combinators seen in the standard libraries
20:37:45 <racliv> yeah
20:37:51 <mmorrow> racliv: what do you mean by "combinators"?
20:37:52 <Cale> racliv: Control.Monad has most of the monad-related ones
20:38:07 <mmorrow> like (=<<) (>>=) (.) fmap ... ?
20:38:20 <racliv> basically most higher order functions that return functions
20:38:44 <mmorrow> Data.{Function,Monad} i guess
20:39:09 <mmorrow> but every function technically returns a function
20:39:20 <shrughes> Control.Monad you mean; maybe consider Control.Arrow
20:39:24 <mmorrow> heh
20:39:25 <racliv> well, after it's been completely curried
20:39:36 <mmorrow> yeah, _Control_.Monad
20:40:12 <Cale> > product [(1 + 1/(r * (r+2)))**(log r / log 2) | r <- [1..10000]]
20:40:13 <mmorrow> racliv: yes, currying is the "technically" i'm refering to
20:40:14 <lambdabot>   2.6814996866630123
20:41:22 <shrughes> > exp . sum $ [log $ (1 + 1/(r * (r+2)))**(log r / log 2) | r <- [1..10000]]
20:41:24 <lambdabot>   2.681499686663029
20:41:29 <shrughes> ok...
20:41:31 <mmorrow> , exp 1
20:41:32 <lunabot>  2.718281828459045
20:41:49 <Cale> > product [(1 + 1/(r * (r+2)))**(log r / log 2) | r <- [1..100000]]
20:41:51 <lambdabot>   2.6849672648982907
20:42:03 <mmorrow> > product [(1 + 1/(r * (r+2)))**(log r / log 2) | r <- [1..1000000]]
20:42:04 <Cale> Rather slow convergence :)
20:42:06 <lambdabot>   * Exception: stack overflow
20:42:07 <shrughes> Is this supposed to converge to something... :P
20:42:14 <chrisdone> mmorrow: are you still doing web dev in haskell? LOOK AT THE DELICIOUS ABSTRACTION http://hpaste.org/13200
20:42:16 <mmorrow> > foldl' (*) 1 [(1 + 1/(r * (r+2)))**(log r / log 2) | r <- [1..1000000]]
20:42:21 <lambdabot>   2.685394602203192
20:42:33 <mmorrow> chrisdone: yes i am. /me looks
20:43:03 <Cale> It converges to the number which the geometric mean of the terms of the continued fraction expansion of almost all real numbers converge to, which is called Khinchin's constant.
20:43:51 <mmorrow> chrisdone: i'm not sure if you recall that neutron minihttpd that i had, but i've been working on it lately making it into one that's actually useable. it's going well (although i haven't been able to work on it over the last week)
20:44:18 <chrisdone> mmorrow: nice, nice. if I recall the speed wasn't too shabby, no?
20:44:44 <mmorrow> chrisdone: yeah it was pretty fast as-was. it's going to crush! :)
20:44:52 <chrisdone> haha
20:45:11 <mmorrow> chrisdone: i saw your formlets-related blogs/hpastes
20:45:27 <mmorrow> i've been meaning to start using them. i like their idea
20:45:38 <chrisdone> ^_^!
20:45:53 <mmorrow> oh sweet, i just looked at that link. speak of the devil
20:46:08 <chrisdone> haha
20:46:51 <chrisdone> mmorrow: here's a non-live sample of the site (not passworded temporarily): http://shop.leannessalon.co.uk/manage/products
20:46:56 <mmorrow> that reminds me too. was reading irc logs recently and saw you asking about a way to get at the rep of Html
20:47:12 <chrisdone> hmm, yeah i was
20:47:13 <BMeph> Heh-heh - http://xkcd.com/54/
20:47:13 <chrisdone> got any ideas?
20:47:32 <mmorrow> it's hidden, but hacking the pkg and making your own personal fork is very useful
20:47:41 <Cale> Apparently, although it's known that almost all real numbers have continued fraction expansions whose geometric means converge to Khinchin's constant, it's not been proven for any specific real number whose full continued fraction expansion isn't known.
20:47:44 <chrisdone> mmorrow: yeah that's what I ended up doing, haha
20:47:53 <mmorrow> chrisdone: nice, me too :)
20:47:55 <chrisdone> mmorrow: getHtmlElements and uhh, thingie
20:48:15 <chrisdone> mmorrow: it's weird because Text.Html /does/ export it, but oh well
20:48:48 <mmorrow> yeah. at least it's very hackable
20:48:58 <mmorrow> (in that it's easy to grok in short time)
20:48:59 <chrisdone> mmorrow: true dat
20:49:01 <chrisdone> indeed
20:49:03 <mmorrow> heh DUMB BLONDE SHAMPOO
20:49:07 <chrisdone> like a lot of haskell code, really
20:49:12 <mmorrow> yes
20:49:17 <chrisdone> haha, yeah, they love that crap
20:49:20 <sclv> eureka! http://www.cs.dartmouth.edu/~doug/powser.html
20:49:28 <BMeph> mmorrow, chrisdone: Have you guys been following the Turbinado project? :)
20:49:44 <sclv> power series, power serious combined with multiple representations, combined with frp = magic
20:49:56 <Gracenotes> yet another "is there a function" question: making a into a singleton list, [a]
20:50:03 <Gracenotes> it seems there is no constructor [] :/
20:50:06 <chrisdone> mmorrow: that site is running on this crapp host that won't let me run processess as CGI or scripts, but will let me run PHP which in turn lets me execute. so I have this god awful script to execute the Haskell process. it's hilarious, let me paste
20:50:07 <mmorrow> BMeph: i've read a few things about it, but don't know much
20:50:26 <sclv> integration is so pretty: int fs = 0 : zipWith (/) fs [1..
20:50:27 <Gracenotes> well, except return. hm.
20:50:35 <mmorrow> chrisdone: sweet. i /hate/ that problem
20:50:41 <chrisdone> BMeph: I have been following it in my peripheral interwebs vision, and chatting to Alson Kemp about it by email. sounds very promising
20:50:45 <pumpkin> sclv: I've met that guy :P
20:50:51 <aluink> what's a nice way to search for operators? google ignores them... for instance, i want to know what '=<<' does
20:50:52 <sclv> ditto
20:51:07 <Gracenotes> @hoogle (=<<)
20:51:07 <jeffz`> Gracenotes: mabye you want: flip (:)
20:51:07 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
20:51:07 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
20:51:08 <Cale> aluink: hoogle, perhaps
20:51:16 <Cale> aluink: Or just ask us :)
20:51:23 <Cale> =<< is just a flipped over >>=
20:51:24 <BMeph> @hoogle something!
20:51:25 <lambdabot> Parse error:
20:51:25 <lambdabot>   --count=20 something!
20:51:25 <lambdabot>                        ^
20:51:28 <BMeph> @hoogle something
20:51:29 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
20:51:32 <chrisdone> mmorrow: http://pastie.org/343769
20:51:33 <Cale> If you know what >>= does already :)
20:51:55 <aluink> cale: well, asking you is nice, but i'd rather not waste your time with things i could have found myself...you know...self RTFMing ;)
20:51:59 <chrisdone> mmorrow: I basically work locally, and then upload a compiled program as .tar.gz automatically when I make changes that I want to submit to the actual server
20:52:01 <Cale> :)
20:52:01 <Gracenotes> jeffz`: the problem is checking if a list is null, and returning Nothing is so and Just list otherwise
20:52:12 <BMeph> Cale: I'm surprised, you're not campaigning to use the Kleene star form? ;p
20:52:14 <chrisdone> BMeph: have you tried Turbinado?
20:52:21 <pumpkin> @undo [(x,y) | x <- [1..10], y <- [1..10]]
20:52:21 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [1 .. 10]) [1 .. 10]
20:52:23 <Gracenotes> the shortest way I've been able to do this is find (not.null) [list]
20:52:24 <Cale> BMeph: hm?
20:52:45 <Gracenotes> and I could do find (not.null).[] if such a funtion existed :)
20:52:49 <aluink> cale: where can i learn to use hoogle?
20:52:56 <chrisdone> mmorrow: just realised line 21 is redundant
20:53:12 <aluink> cale: nm, google told me ;)
20:53:14 <mmorrow> chrisdone: cool. so you're linking it statically then? (or did you build a ghc on the server machine)
20:53:14 <chrisdone> w/e
20:53:18 <Cale> aluink: okay :)
20:53:21 <chrisdone> mmorrow: linking it statically
20:53:27 <Cale> aluink: I'm fairly sure it has a web interface too
20:53:41 <aluink> yeah, haskell.org/hoogle
20:53:41 <mmorrow> nice
20:53:48 <chrisdone> mmorrow: though I had to upload mysql and libgmp .so files, heh
20:53:52 <Cale> aluink: Of course, in this specific case, if you don't know about monads, Hoogle and the like probably won't help clear things up too much.
20:54:02 <chrisdone> mmorrow: what setup did you manage to do with haskell + $shitty_web_host?
20:54:19 <aluink> Cale: i've been studying monads all night, so i'm kinda've ok there
20:54:20 <BMeph> chr1sdone: No, just reading; my web fu is weak. Appcelerator's recently caught my eye, I was thinking how it might be better done with darcs, vice that Ruby Rakefile junk. :)
20:54:46 <Cale> aluink: Another approach you can take just to figure out what things are is to :info foo in ghci, and then look in the Hierarchical libraries documentation in the module it tells you.
20:54:48 <aluink> cale: suprising how something so simple can somehow feel so complicated...maybe i'm just a n00b
20:54:57 <BMeph> Cale: (=<<) is the Kleene star function. :)
20:54:59 <Cale> aluink: Well, it's abstract.
20:55:05 <Cale> BMeph: I don't see how.
20:55:15 <mmorrow> chrisdone: i've found the static linking thing to be hit-or-miss (if the link doesn't work first try i don't think i've ever gotten it to)
20:55:26 <chrisdone> mmorrow: yeah
20:55:29 <Cale> BMeph: How is it related to regular expressions/languages?
20:55:41 <Cale> (or Kleene algebras)
20:55:58 <mmorrow> chrisdone: i had a personal site with a shitty hosting pkg, and i juts ditched it for another company and a package where i had root
20:56:14 <mmorrow> because everything else was too much of a pain
20:56:28 <mmorrow> that php script's a slick idea though
20:56:34 <chrisdone> mmorrow: ah, nice one. wish I had that choice ;)
20:56:43 <chrisdone> ha, yeah, the only idea I could think of :P
20:56:48 <Cale> aluink: You basically get a feel for a bunch of specific monads, and get a sense for what they have in common.
20:57:35 <chrisdone> mmorrow: so are you running your own server or fastcgi or what now?
20:57:36 <mmorrow> chrisdone: yeah, it sucks when all you have to work with is an apache you can't control
20:57:44 <chrisdone> mmorrow: verily
20:58:10 <mmorrow> chrisdone: most everything with fastcgi, but i'd love to run stuff with neutron :)
20:58:15 <BMeph> Cale: I think I recall a Wadler paper using it , but I don't recall which one now. He just made the claim but may not have given a reference. I'll try to recall it. :)
20:58:22 * chrisdone googles neutron
20:58:45 <Cale> BMeph: I've seen papers where bind was written using a star
20:58:57 <chrisdone> mmorrow: uh, what is it?
20:59:01 <Cale> BMeph: But never any mention of the Kleene star...
20:59:02 <mmorrow> chrisdone: you won't find anything, but i'll get it working soon
20:59:18 <mmorrow> chrisdone: that's the server i'm working on ;)
20:59:24 <chrisdone> mmorrow: ahh, sorry. I read over the name when you wrote it. haha. >_ >
20:59:36 <chromakode> formlets, eh?
20:59:42 <chrisdone> chromakode: formlets!!
20:59:43 <mmorrow> chrisdone: i know the http rfc more than i'd like to admit
20:59:53 <chrisdone> mmorrow: haha. naw that's cool
20:59:54 <aluink> Cale: yeah, i'm reading mightybyte's blog on HAppS and got lost when he started talking about Monads, specifically the Reader monad
21:00:11 <aluink> cale: so i detoured to RWH to learn about the Monad
21:00:28 <chrisdone> chromakode: wanna buy some formlets?
21:00:31 <Cale> Cool, let me/us know if you have any unanswered questions :)
21:00:31 * chrisdone opens jacket
21:00:36 <chromakode> chrisdone: how much?
21:00:37 <mmorrow> chrisdone: i've gotta run, but we should talk about this stuff again soon
21:00:43 <aluink> shall do
21:00:47 <chrisdone> chromakode: twenty thunks
21:00:53 <chrisdone> mmorrow: aye alright, laters
21:00:54 <Taejo> Cale: how many times a day do you give a monad tutorial?
21:01:03 <BMeph> > listToMaybe.tails [1..5]
21:01:05 <lambdabot>   Couldn't match expected type `a -> [a1]'
21:01:09 <BMeph> > listToMaybe.tails $ [1..5]
21:01:10 <Cale> Taejo: I probably average around 0.8 or so ;)
21:01:10 <lambdabot>   Just [1,2,3,4,5]
21:01:10 * aluink appreciates the friendliness of the folks in #haskell
21:01:13 <BMeph> > listToMaybe.tails $ []
21:01:15 <lambdabot>   Just []
21:01:24 <chromakode> chrisdone: would you settle for 2 recursive grammars?
21:01:36 <chrisdone> we're not friendly, newbies are just so nice!^___^
21:01:45 <BMeph> Bah, not quite. :\
21:01:46 <chrisdone> chromakode: aaaaand a partridge in a pear treeeee
21:02:18 <chrisdone> on the first day of the Haskell Hackathon Simon gave to me...?
21:02:33 <aluink> chrisdone: i'm afraid that has a meaning i'm missing
21:02:36 <centrinia> Why do people write programs when it is possible to use an (n+1)-th order metaprogram to produce an n-th order metaprogram?
21:03:06 <chrisdone> aluink: I was just being silly, ha
21:03:16 <chromakode> centrinia: because they don't recognize the order?
21:03:21 <chrisdone> chromakode: have you read my formlets tutorial?
21:03:23 <aluink> chrisdone: phew...i was sweating that one ;)
21:03:25 <Taejo> centrina: because at some point the programs stop getting shorter/simpler
21:03:34 <chromakode> chrisdone: I haven't. where can I find it?
21:03:35 <chrisdone> chromakode: haha
21:03:42 <Cale> centrinia: It's turtles all the way up?
21:03:46 <chromakode> chrisdone: I'm reading on the HaskellWiki right now.
21:04:00 <chromakode> I like Taejo's answer
21:04:00 <chrisdone> chromakode: http://chrisdone.com/blog/2008/12/14/Haskell-Formlets:-Composable-web-form-construction-and-validation
21:04:03 <centrinia> Yes, you can always delegate the work of doing actual programming to another metaprogram.
21:04:09 <chromakode> thanks chrisdone
21:04:29 <nolrai_East> does any one have an example of a monad tranceformer implemented with join? (instead of bind)
21:05:02 <pumpkin> tranceformer :P
21:05:03 <Cale> nolrai_East: I can give you a conceptual idea of how that might look.
21:05:07 <pumpkin> been listening to too much trance music?
21:05:31 <nolrai_East> That might be good enough.
21:05:34 <chrisdone> pumpkin: yeah, when I listen to trance, all I can think of is the word "trance". trance, trance, trance
21:05:42 * centrinia needs to write Sitar Guru in Haskell.
21:06:04 <BMeph> Cale: The paper I saw, it was flip bind, specifically, if was doing the whole "This is a monad in CT, and this is how it looks in Haskell" thing. Then he said that the point with using bind as-we-know-it is that the functor over the objects has to have an object in it, or something like that. Maybe I ought to find it, just to re-read it until it sinks in... :)
21:06:05 <Cale> One approach to combining monads is that if you have a function  distribute :: M (N a) -> N (M a), then you can turn the composite N . M into a monad.
21:06:13 * Taejo needs to write Sitar Hero in Yampa
21:06:36 <Cale> join :: N (M (N (M a))) -> N (M a)
21:06:46 <mmorrow> @remember Taejo * Taejo needs to write Sitar Hero in Yampa
21:06:47 <lambdabot> Good to know.
21:06:49 <mmorrow> lol
21:06:55 <Cale> join = fmap join . join . fmap distribute
21:07:02 <nolrai_East> Cale: hmm
21:07:09 <aluink> centrinia: a friend of mine's chat status is "Will write code that writes code for food"
21:07:31 <Cale> Well, formally, the distribute must satisfy some additional laws
21:07:39 <Cale> In order to ensure that you really have a monad.
21:07:50 <nolrai_East> right.
21:08:07 <nolrai_East> That might just help.
21:08:17 <centrinia> What is Sitar Hero?
21:08:49 <gio123> Cale:hi
21:08:56 <Cale> hi
21:09:04 <Taejo> centrinia: you've never played Guitar Hero?
21:09:07 <BMeph> Heh-heh, just hit Guru level on Sitar Hero: Krishnamurthy... 8D
21:09:17 <chrisdone> wait, what?
21:09:19 <centrinia> I've played Guitar Hero.
21:09:19 <chrisdone> Sitar Hero?
21:09:33 <chrisdone> oh, man. haha
21:09:36 <centrinia> Sitar Guru.
21:09:52 <Taejo> centrinia: when I first saw Sitar Guru, I thought it was Sitar Hero
21:10:23 <Taejo> and then I thought you meant something else
21:10:29 <Taejo> now I'm not sure
21:10:52 <centrinia> Sitar Guru is supposed to be Guitar Hero with a sitar. ;)
21:11:08 <Taejo> oh, ok. sorry.
21:17:01 <chrisdone> http://pastie.org/343716
21:17:10 <chrisdone> phew, that's the hard part done, now all I need is rules
21:17:55 <Axman6> does log(1+x) expand out to something else? like log(1)*log(x) or something?
21:18:30 <Cale> Axman6: no
21:18:42 <centrinia> does log(0+x) expand out to log(0)*log(x)?
21:18:44 <aluink> where's a nice place to get info on operator precedence
21:18:49 <Cale> (also log(1) = 0)
21:18:57 <aluink> in this case comparing . and =<<
21:19:10 <Cale> aluink: :info (=<<)
21:19:18 <Axman6> ok, thanks. been clightly too long sinse i've actualy worked with evaluating logs
21:19:26 <shrughes> log(1+x) has a nicer maclaurin series :D
21:19:33 <Cale> aluink: You'll see a line like  infixr 1 =<<
21:19:45 <Cale> aluink: Which means that it's right associative, and has precedence level 1
21:19:51 <chrisdone> does my code layout make you feel sad? http://hpaste.org/13201
21:19:51 * centrinia wouldn't compute logarithms with Taylor series even if his life depended on it.
21:20:21 <Cale> (which means that it binds fairly weakly to its arguments)
21:20:29 <Axman6> Cale: not really, but i'd move the definitions down below the the func decl
21:20:35 <Axman6> uh, chrisdone*
21:20:36 <chrisdone> woah, I could use a guard in the case. expert optimisation
21:20:59 <aluink> Cale: lower precedence levels gets evaluated first?
21:20:59 <chrisdone> Axman6: you think? hmm, okay
21:21:13 <Cale> aluink: higher first
21:21:31 <Axman6> like match  a@(Atom a0)      (Atom a1) \n     | a0 == a1   = return $ Just a...
21:21:34 <aluink> so . is evaluated before =<< in this case, since they have 9, 1, respectively
21:21:41 <Cale> yes
21:21:46 <aluink> sweet, thanks
21:21:50 <chrisdone> Axman6: ?
21:21:57 <chrisdone> Axman6: oh, didn't see the \n
21:21:59 <Axman6> aluink: you can do things like x >>= return . f just fine
21:22:18 <aluink> YES! that's exactly what i was looking at...well
21:22:23 <Axman6> though i tend to bracket that up anyway because i find it slightly clearer
21:22:28 <Cale> aluink: and if you have something like  return . f =<< x, you should probably rewrite it as fmap f x or liftM f x
21:22:40 <aluink> it was return . foo =<< bar
21:22:50 <Axman6> Cale: ha, i was just about to ask that :0
21:22:52 <Axman6> :)*
21:22:53 <Cale> yeah, I don't know why people are drawn to writing that :)
21:23:12 <Cale> I suppose if you just know return and =<<, it's the clearest way :)
21:23:27 <Axman6> yeah
21:23:42 <Axman6> i don't really find liftM* that clear
21:23:44 <aluink> well, i know liftM and it is more understandable than return . foo =<< bar
21:24:08 <chrisdone> =<< is like sending something through a pipe, liftM and fmap invoke images of picking something up and putting it in a box @_@
21:25:28 <aluink> my problem now is that i'm looking at return . users =<< ask
21:25:36 <aluink> i'm unclear about ask
21:25:59 <aluink> and users, as far as i can tell is :: M.Map String User
21:26:26 <Axman6> Maps aren;t monads are they?
21:27:20 <shrughes> users would have to be a function
21:27:46 <centrinia> What would a binding operation on a Map look like?
21:27:49 <chrisdone> Axman6: http://hpaste.org/13201#a1 better/worse?
21:28:15 <centrinia> How would you lift something into a Map?
21:28:27 <chrisdone> Map isn't a Functor
21:28:40 <chrisdone> @info Functor
21:28:40 <lambdabot> Functor
21:28:44 <chrisdone> useful...
21:28:46 <chrisdone> @src Functor
21:28:47 <lambdabot> class  Functor f  where
21:28:47 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
21:28:58 <chrisdone> and
21:29:01 <chrisdone> @src Map
21:29:02 <lambdabot> Source not found. Do you think like you type?
21:29:05 <Axman6> chrisdone: i'd probably shift the the definitions over a bit more, so they're a bit easier to read, but whatever you prefer really
21:29:18 <chrisdone> well, w/e. the point is Map's kind is * -> * -> *, I think
21:29:40 <centrinia> Is it possible for (forall (Ord a). Map a) to be a Functor?
21:29:40 <shrughes> you could fit some kind of map with a certain type of key into a monad, i'm pretty sure
21:29:42 <chrisdone> Axman6: shift them over? have you got time to annotate an example?
21:29:57 <Axman6> sure
21:30:04 <chrisdone> shrughes: yeah
21:30:10 <BMeph> @instances-importing Functor
21:30:11 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:30:28 <chrisdone> Axman6: cheers big ears
21:30:37 <nolrai_East> why is it "MaybeT {runMaybeT :: m (Maybe a)}" and not "MaybeT {runMaybeT :: Maybe (m a)}" ?
21:30:51 <chrisdone> nolrai_East: where's MaybeT defined‽
21:31:05 <nolrai_East> http://www.haskell.org/haskellwiki/New_monads/MaybeT
21:31:10 * chrisdone screams
21:31:28 <Axman6> chrisdone: http://hpaste.org/13201#a2
21:31:30 <chrisdone> I wanted MaybeT for the code I just pasted
21:31:45 <chrisdone> ended up using State and using the Maybe monad inside..
21:31:46 <aluink> the code that spawned all this is http://pastebin.com/d644d25d4
21:32:06 <chrisdone> Axman6: ahh, i see. yeah
21:32:24 <Axman6> i don't like bunched up code :)
21:32:51 <chrisdone> Axman6: you can immediately see some structure to the code without even having to read the syntax
21:33:07 <Axman6> yep
21:34:01 <Axman6> so, i'm thinking of using FFI to make an interface to the vForce stuff in Apple's vecLib
21:34:36 <chrisdone> @go vForce
21:34:40 <lambdabot> http://www.mototassinari.com/
21:34:40 <lambdabot> Title: Moto Tassinari 2008 | (603) 298-6646 - Home
21:34:51 <Axman6> they're designed to run on vector units on PPC and x86 if they're presenent, and do things like "Set y[i] to the exponential function of x[i], for i=0,..,n-1"
21:35:04 <shrughes> nolrai_East: consider Maybe (IO a).  There's no way to write a meaningful function (>>=) :: Maybe (IO a) -> (a -> Maybe (IO b)) -> Maybe (IO b), because for it to pass the value of type a to the function, it requires evaluating IO and returning something of the form (IO x).
21:35:06 <Axman6> void vvexpf (float * /* y */, const float * /* x */, const int * /* n */)
21:35:32 <Axman6> there's double and float versions
21:36:43 <shrughes> nolrai_East: also, m (Maybe a) fits the purpose of MaybeT exactly: an action that _might_ successfully return a value
21:39:01 <nolrai_East> shrughes: I think I have my monad tranformer definition inside out than. Thanks so very much. ahhg.
21:39:15 <Axman6> chrisdone: heh, gotta love lines like this in release otes for libraries: "In our spare time, however, we did manage to rewrite/reoptimize in excess of 7000 entrypoints for three new architectures (21000 in total), i386, ppc64 and x86_64." :P
21:39:17 <nolrai_East> (I m not being sarcastic)
21:41:12 <Gracenotes> hey... I'm trying to make a lambda pointless. It's something like: (\a -> \b -> a : (words b)), where a and b are both Strings. any idea?
21:41:33 <shapr> @pl \a b -> a : (words b)
21:41:33 <lambdabot> (. words) . (:)
21:41:38 <shrughes> Gracenotes: first, rewrite that is (\a -> \b -> (:) a (words b))
21:41:58 <Gracenotes> > ((. words) . (:)) "a" "b c" -- shapr
21:42:00 <lambdabot>   ["a","b","c"]
21:42:11 <Gracenotes> ...what the hell is wrong with my ghc.
21:42:50 <sciolizer> What's the Haskell equivalent of select()?
21:43:00 <Taejo> Djinn> return :: a -> IO a Djinn> bind :: IO a -> (a -> IO b) -> IO b Djinn> liftM ? (a -> b) -> (IO a -> IO b) -- liftM cannot be realized.
21:43:03 <Taejo> what am I doing wrong?
21:43:14 <shrughes> sciolizer: select()?
21:43:25 <Gracenotes> shrughes:hm, okay
21:43:36 <sciolizer> as in, select whichever file/socket is ready for IO
21:43:39 <Gracenotes> actually, it's not words, and that might be the problem
21:44:06 <Gracenotes> my function is of the type [Char] -> [[Char]], whereas word is String -> [String]
21:44:21 <shrughes> they are the same thing
21:44:28 <Gracenotes> could that cause it to break? because ((p .) . (:)) fails for my function, but works for word
21:44:30 <chrisdone> Axman6: haha
21:45:07 <shrughes> String is merely a shortcut name for [Char], nothing more
21:45:21 <shrughes> Gracenotes: note that shapr suggested ((. p) . (:))
21:45:45 <Gracenotes> oh, sorry, that was a typo
21:46:26 <Gracenotes> basically I'm trying to implement a sort of "split on '|' function"
21:46:38 <Gracenotes> which looks like this: uncurry (\b-> \c-> b : (maybe [] (o.tail) . find (not.null) . flip(:)[]) c) . break(=='|')
21:46:59 <Gracenotes> I'm going for terseness more than for clarity
21:47:15 <Gracenotes> oh, and o is the name of the function
21:47:39 <Taejo> @djinn return :: a -> IO a
21:47:39 <lambdabot> Cannot parse command
21:47:58 <Gracenotes> > let o = uncurry (\b-> \c-> b : (maybe [] (o.tail) . find (not.null) . flip(:)[]) c) . break(=='|') in o "abc|def"
21:48:00 <lambdabot>   ["abc","def"]
21:48:03 <Axman6> @djinn a -> IO a
21:48:03 <lambdabot> Error: Undefined type IO
21:48:11 <Axman6> thought so
21:48:27 <Gracenotes> > let o = uncurry (. (maybe [] (o.tail) . find (not.null) . flip(:)[]) c) . (:)) . break(=='|') in o "abc|def"
21:48:28 <dmwit> It's a primitive.
21:48:28 <lambdabot>   <no location info>: parse error on input `)'
21:48:37 <Axman6> @hoogle Eq a =>  a -> [a] -> [[a]]
21:48:38 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
21:48:38 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:48:38 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
21:48:50 <Axman6> @hoogle split
21:48:50 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
21:48:50 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
21:48:50 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
21:48:51 <Gracenotes> > let o = uncurry (. ((maybe [] (o.tail) . find (not.null) . flip(:)[]) c)) . (:)) . break(=='|') in o "abc|def"
21:48:52 <lambdabot>   <no location info>: parse error on input `)'
21:48:56 <Axman6> @hoogle List.split
21:48:56 <lambdabot> No results found
21:49:01 <Axman6> @hoogle Data.List.split
21:49:01 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
21:49:01 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
21:49:15 <Gracenotes> > let o = uncurry (. ((maybe [] (o.tail) . find (not.null) . flip(:)[])) . (:)) . break(=='|') in o "abc|def"
21:49:16 <lambdabot>   Couldn't match expected type `[a]'
21:49:32 <Gracenotes> shrughes: this is where the problem comes up
21:49:45 <Gracenotes> although apparently it is (. p) . (:), exactly
21:50:03 <shrughes> that is just way too complicated for me
21:50:09 <dmwit> Why would you write it in such an ungodly way?
21:50:25 <Gracenotes> dmwit: trying to get it as terse as possible
21:50:44 <dmwit> Let me ask again: why?
21:50:45 <Gracenotes> and I'd like to practice with uncurry, as well
21:50:55 <Gracenotes> dmwit: code golf. it makes people do ungodly things
21:51:03 * dmwit nods
21:51:09 <Gracenotes> still, I'm not sure why the type error is coming up
21:51:29 <Gracenotes> everything from maybe to flip(:)[] is type [Char] -> [[Char]]
21:52:09 <Gracenotes> actually, type [Char] -> [Char] -> [[Char]]... hm
21:52:14 <shrughes> > let { split [] = []; split xs = let (b,a:as) = break (=='|') xs in b : split as } in split "abc|def"
21:52:16 <lambdabot>   ["abc","* Exception: /tmp/912925185187502655:71:68-94: Irrefutable pattern ...
21:52:18 <shrughes> meh
21:52:24 <Axman6> :t :[]:
21:52:25 <lambdabot> parse error on input `:'
21:52:33 <Axman6> :t (:[]).(:)
21:52:34 <lambdabot> forall a. a -> [[a] -> [a]]
21:52:37 <dmwit> :t unfoldr
21:52:38 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:52:38 <Axman6> :\
21:52:46 <dmwit> :t break
21:52:47 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:52:56 <Gracenotes> > let oo a[]=[a];oo a b=a:(o$tail b);o=uncurry oo.break(=='|') in oo "a,b|c,d" -- the version that doesn't break
21:52:57 <lambdabot>       Overlapping instances for Show ([Char] -> [[Char]])
21:52:57 <lambdabot>        arising from...
21:53:14 <Gracenotes> > let oo a[]=[a];oo a b=a:(o$tail b);o=uncurry oo.break(=='|') in o "a,b|c,d" -- uh, yeah
21:53:15 <lambdabot>   ["a,b","c,d"]
21:54:10 <Gracenotes> I've been working on it for the past 3 hours or so.
21:55:10 <dmwit> :t unfoldr (\xs -> guard (not . null $ xs) >> return (break (=='|') xs)) "abc|def"
21:55:11 <lambdabot> [[Char]]
21:55:16 <dmwit> > unfoldr (\xs -> guard (not . null $ xs) >> return (break (=='|') xs)) "abc|def"
21:55:17 <lambdabot>   ["abc","","","","","","","","","","","","","","","","","","","","","","",""...
21:55:22 <Axman6> Gracenotes: you need to learn to use spaces >_<
21:55:43 <Gracenotes> Axman6: sorry... code golf is weird :/
21:55:52 <Axman6> i could swear that code was perl ;)
21:55:58 <Gracenotes> the actual problem is http://stackoverflow.com/questions/372668/code-golf-how-do-i-write-the-shortest-character-mapping-program
21:56:04 <Gracenotes> unsurprisingly, the shortest answer *is* perl
21:56:10 <dmwit> > unfoldr (\xs -> guard (not . null $ xs) >> return (second tail (break (=='|') xs))) "abc|def"
21:56:12 <lambdabot>   ["abc","def"* Exception: Prelude.tail: empty list
21:56:17 <dmwit> Ah, quite.
21:56:22 <dmwit> > unfoldr (\xs -> guard (not . null $ xs) >> return (second (drop 1) (break (=='|') xs))) "abc|def"
21:56:23 <lambdabot>   ["abc","def"]
21:56:40 <Gracenotes> dmwit: actually, I tried to do something with guard earlier on :)
21:57:00 <Gracenotes> hm, unfoldr. haven't worked with that terribly much
21:57:22 <Gracenotes> presumably works in a manner similar to scanl, but ... backwards in a way?
21:57:33 <Gracenotes> *scanr
21:57:37 <dmwit> It's backwards from foldr.
21:57:46 <Axman6> > unfoldr (\b -> if null b then Nothing else return.break (=='|')) "a,b,c|d,e|fgh"
21:57:47 <mbz> pumpkin: i've just bruteforced p125. it took < 1min with -O3
21:57:48 <lambdabot>   Couldn't match expected type `Maybe (a1, [a])'
21:57:57 <Axman6> > unfoldr (\b -> if null b then Nothing else return.break (=='|') $ b) "a,b,c|d,e|fgh"
21:57:58 <lambdabot>   ["a,b,c","","","","","","","","","","","","","","","","","","","","","","",...
21:58:06 <pumpkin> mbz: I was just doing it in haskell :P
21:58:06 <Gracenotes> Axman6: I saw that a lot :/
21:58:08 <pumpkin> I mean ghci
21:58:21 <Gracenotes> dmwit: hm, okay. I'll look into it
21:58:27 <Axman6> :t (\b -> if null b then Nothing else return.break (=='|') $ b)
21:58:28 <lambdabot> [Char] -> Maybe ([Char], [Char])
21:58:42 <Axman6> > (\b -> if null b then Nothing else return.break (=='|') $ b) "abc|de"
21:58:44 <lambdabot>   Just ("abc","|de")
21:58:49 <mbz> pumpkin: yep I did it in haskell too
21:58:50 <Gracenotes> it seems what you can do it limited by the functions you know :)
21:59:00 <dmwit> > unfoldr (\b -> if null b then Nothing else Just.drop 1.break (=='|')$b) "a|b|c"
21:59:01 <lambdabot>       Failed to load interface for `Just':
21:59:01 <lambdabot>        Use -v to see a list of the...
21:59:08 <dmwit> oh, right
21:59:15 <dmwit> > unfoldr (\b -> if null b then Nothing else Just .drop 1.break (=='|')$b) "a|b|c"
21:59:16 <lambdabot>   Couldn't match expected type `[a]'
21:59:37 <dmwit> > unfoldr (\b -> if null b then Nothing else Just .second(drop 1).break (=='|')$b) "a|b|c"
21:59:38 <lambdabot>   ["a","b","c"]
21:59:42 <Gracenotes> still, the maybe/find combination might be useful
21:59:50 <Axman6> > (\b -> if null b then Nothing else return.fmap tail.break (=='|') $ b) "abc|de"
21:59:51 <lambdabot>   Just ("abc","de")
21:59:58 <jeffwheeler> Other than Arch, which is only for i686 and x86-64, for what OSs is GHC 6.10 packaged?
22:00:01 <Taejo> :t unfoldr
22:00:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:00:14 <dmwit> :t iterate
22:00:15 <lambdabot> forall a. (a -> a) -> a -> [a]
22:00:23 <Axman6> > unfoldr (\b -> if null b then Nothing else return.fmap tail.break (=='|') $ b) "abc |de||f"
22:00:25 <lambdabot>   ["abc ","de","","f"* Exception: Prelude.tail: empty list
22:00:29 <Axman6> thought so -_-
22:00:47 <Taejo> unfoldr  (Just . join (,) (+1)) 0
22:00:47 <Axman6> > unfoldr (\b -> if null b then Nothing else return.fmap (drop 1).break (=='|') $ b) "abc |de||f"
22:00:49 <lambdabot>   ["abc ","de","","f"]
22:00:49 <Taejo> > unfoldr  (Just . join (,) (+1)) 0
22:00:50 <lambdabot>   Couldn't match expected type `b -> b1'
22:00:52 <Axman6> whoot!
22:01:08 <dmwit> > map (takeWhile(/='|').snd) . iterate (break (=='|').fst) $ "ab|cd|ef"
22:01:09 <lambdabot>   Couldn't match expected type `([Char], [Char])'
22:01:15 <Taejo> > unfoldr  (Just . join (,) . (+1)) 0
22:01:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:01:17 <dmwit> > map (takeWhile(/='|').snd) . iterate (break (=='|').fst) $ ("ab|cd|ef","")
22:01:18 <lambdabot>   ["","","","","","","","","","","","","","","","","","","","","","","","",""...
22:01:23 <Axman6> > unfoldr (\b -> if' (null b) Nothing (return.fmap (drop 1).break (=='|') $ b)) "abc |de||f"
22:01:24 <lambdabot>   Not in scope: `if''
22:01:40 <Axman6> > unfoldr (\b -> if' (null b) Nothing (return.fmap (drop 1).break (=='|') $ b)) "abc |de||f" where if' p t f = if p then t else f
22:01:41 <dmwit> gah, dropping one is the most painful part
22:01:42 <lambdabot>   ["abc ","de","","f"]
22:01:50 <dmwit> > map (takeWhile(/='|').snd) . iterate (break (=='|').fst.drop 1) $ ("ab|cd|ef","")
22:01:51 <lambdabot>   Couldn't match expected type `(a, [Char])'
22:01:58 <Gracenotes> then, when you actually have the input, I've found that maybe/find is useful for mapping
22:02:01 <dmwit> > map (takeWhile(/='|').snd) . iterate (break (=='|').drop 1.fst) $ ("ab|cd|ef","")
22:02:01 <Gracenotes> > map (\o -> maybe o (!!2) $ find ((o==).head) ["a,b", "c,d"]) "caddy"
22:02:03 <lambdabot>   ["","","","","","","","","","","","","","","","","","","","","","","","",""...
22:02:03 <lambdabot>   "dbddy"
22:02:16 <Gracenotes> mapping a->b, c->d
22:02:21 <Axman6> > unfoldr (\b -> if' (null b) Nothing (return.fmap (drop 1).break (=='|') $ b)) "abc |de||fafgkj|dfgarg|drh|arfgag|" where if' p t f = if p then t else f
22:02:23 <lambdabot>   ["abc ","de","","fafgkj","dfgarg","drh","arfgag"]
22:02:38 <Taejo> > unfoldr  (Just . (+) &&& \(x,y) -> (y, x+ y)) (0, 1)
22:02:39 <lambdabot>   Couldn't match expected type `Maybe (a, (t, t))'
22:02:48 <pumpkin> mbz: maybe I should try compiling it
22:02:49 <Taejo> > unfoldr  (Just . (+) *** \(x,y) -> (y, x+ y)) (0, 1)
22:02:50 <lambdabot>   Couldn't match expected type `Maybe (a, (b, (t, t)))'
22:02:55 <Taejo> :t (***)
22:02:56 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:03:07 <Taejo> :t (&&&)
22:03:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:03:10 <Axman6> @pl (\b -> if (null b) then Nothing else (return.fmap (drop 1).break (=='|') $ b))
22:03:10 <lambdabot> ap (flip if' Nothing . null) (return . fmap (drop 1) . break ('|' ==))
22:03:29 <Gracenotes> :t unfoldr
22:03:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:03:37 <Taejo> :t (+) &&& \(x,y) -> (y, x+ y)
22:03:38 <lambdabot> forall t. (Num t, Num (t, t)) => (t, t) -> ((t, t) -> (t, t), (t, t))
22:03:49 <Taejo> :t uncurry (+) &&& \(x,y) -> (y, x+ y)
22:03:50 <lambdabot> forall a. (Num a) => (a, a) -> (a, (a, a))
22:04:05 <Axman6> :t break (=='|).snd
22:04:06 <lambdabot> lexical error in string/character literal at character ')'
22:04:12 <Axman6> :t break (=='|').snd
22:04:13 <lambdabot> forall a. (a, [Char]) -> ([Char], [Char])
22:04:21 <Taejo> > unfoldr (Just . (uncurry (+)) *** \(x,y) -> (y, x+ y)) (0, 1)
22:04:22 <lambdabot>   Couldn't match expected type `Maybe (a, ((a1, a1), (t, t)))'
22:04:29 <Axman6> :t interate (break (=='|').snd)
22:04:31 <lambdabot> Not in scope: `interate'
22:04:34 <Gracenotes> > unfoldr (\c -> Maybe (c, c + 1)) 0
22:04:35 <lambdabot>   Not in scope: data constructor `Maybe'
22:04:35 <Axman6> :t iterate (break (=='|').snd)
22:04:36 <lambdabot> ([Char], [Char]) -> [([Char], [Char])]
22:04:39 <Taejo> :t (uncurry (+)) *** \(x,y) -> (y, x+ y)
22:04:40 <lambdabot> forall a t. (Num t, Num a) => ((a, a), (t, t)) -> (a, (t, t))
22:04:40 <Gracenotes> > unfoldr (\c -> Just (c, c + 1)) 0
22:04:41 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
22:04:42 <dmwit> > let onHead f (x:xs) = f x:xs; f [] = [[]]; f ('|':xs) = "":f xs; f (x:xs) = onHead (x:) (f xs) in f "abc|def"
22:04:44 <lambdabot>   ["abc","def"]
22:04:51 <Taejo> :t (uncurry (+)) &&& \(x,y) -> (y, x+ y)
22:04:52 <lambdabot> forall a. (Num a) => (a, a) -> (a, (a, a))
22:05:00 <Taejo> > unfoldr (Just . (uncurry (+)) &&& \(x,y) -> (y, x+ y)) (0, 1)
22:05:02 <lambdabot>   Couldn't match expected type `Maybe (a, (a1, a1))'
22:05:05 <Gracenotes> meh, I need to write my pointfree-ish :)
22:05:08 <Axman6> > iterate (drop 1.break (=='|').snd) "a,bd|des"
22:05:08 <Gracenotes> *more
22:05:08 <mmorrow> sciolizer: there's an example of importing select() with the FFI and using it at the end of this file (this isn't my code, but i link you here because the file's in a tarball on oleg's site)  http://moonpatio.com/repos/zfs/ZFS.hs
22:05:09 <lambdabot>   Couldn't match expected type `[a]'
22:05:19 <Axman6> :t (drop 1.break (=='|').snd)
22:05:20 <lambdabot>     Couldn't match expected type `[a]'
22:05:20 <lambdabot>            against inferred type `([Char], [Char])'
22:05:20 <lambdabot>       Expected type: (a1, [Char]) -> [a]
22:05:23 <dmwit> :t foldr
22:05:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:05:24 <Taejo> > unfoldr (Just . fst &&& \(x,y) -> (y, x+ y)) (0, 1)
22:05:26 <lambdabot>   Couldn't match expected type `Maybe (a, (b, b))'
22:05:26 <sciolizer_> mmorrow: thanks
22:05:37 <Axman6> :t (drop 1.second.break (=='|').snd)
22:05:39 <lambdabot>     Couldn't match expected type `[]'
22:05:39 <lambdabot>            against inferred type `(,) (d, [Char])'
22:05:39 <lambdabot>       Expected type: (a1, [Char]) -> [a]
22:05:41 <Taejo> > unfoldr (Just . (fst &&& \(x,y) -> (y, x+ y))) (0, 1)
22:05:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:05:43 <Axman6> :t second
22:05:44 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
22:05:48 <Taejo> yes!
22:05:55 <Gracenotes> :t join
22:05:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:05:59 <aluink> i'm trying to get the type of return . users
22:06:03 <Taejo> @pl \(x,y) -> (y, x+ y)
22:06:03 <lambdabot> uncurry (ap (,) . (+))
22:06:03 <Gracenotes> Taejo: nice :)
22:06:11 <aluink> users :: M.Map String User
22:06:24 <aluink> i can't figure it out in ghci
22:06:25 <mbz> pumpkin: yeah I got. I've read about ghci after I wrote a message
22:06:35 <dmwit> aluink: users is not a function, you can't compose it.
22:06:36 <Axman6> aluink: it'll be m (M.Map String User), where m is some monad
22:06:38 <Taejo> \bot can make case distinctions on (,) pointless now?
22:06:41 <dmwit> aluink: That would be a type error.
22:06:51 <Axman6> dmwit: ah, good point
22:07:00 <aluink> it's part of return . users =<< ask
22:07:04 <aluink> does that help?
22:07:04 <Taejo> > unfoldr (Just . (fst &&& uncurry (ap (,) . (+))) (0, 1)
22:07:05 <lambdabot>   <no location info>: parse error on input `;'
22:07:09 <Taejo> > unfoldr (Just . (fst &&& uncurry (ap (,) . (+)))) (0, 1)
22:07:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:07:20 <Taejo> :t ap (,)
22:07:21 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
22:08:02 <aluink> Axman6: ok, that's what i'm expecting, but i can't figure out how it works, cause i'm thinking the same thing that dmwit is saying
22:08:52 <Taejo> > let triangles = 0:zipWith (+) triangles [1..] in triangles
22:08:54 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
22:10:15 <pumpkin> > scanl1 (+) [1..]
22:10:20 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
22:10:24 <Gracenotes> :t (<$>) (,)
22:10:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> (a, b))
22:10:26 <Axman6> > let t = 0:1:1:zipWith (+) t . tail.tail $ t in t
22:10:27 <lambdabot>   Couldn't match expected type `[t]'
22:10:38 <Taejo> pumpkin: d'oh. thank you
22:10:45 <Gracenotes> :t (<*>) (,)
22:10:45 <pumpkin> Taejo: :)
22:10:46 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
22:10:47 <Axman6> > let t = 0:1:1:(zipWith (+) t . tail.tail $ t) in t
22:10:48 <lambdabot>   [0,1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873,2745...
22:11:10 <mmorrow> sciolizer_: also, ghc's io manager uses select (see around line 1250 for the select() interface)  http://darcs.haskell.org/libraries/base/GHC/Conc.lhs
22:11:42 <mmorrow> sciolizer_: it's funny that you ask about this now, because i was just looking at the exact same thing
22:11:47 <Gracenotes> > unfoldr (Just . (fst &&& uncurry ((<*>) (,)  . (+))) (0, 1)
22:11:48 <Axman6> does ght2hs not build on 6.10?
22:11:48 <lambdabot>   <no location info>: parse error on input `;'
22:12:20 <Gracenotes> > unfoldr (Just . (fst &&& uncurry ((<*>) (,) . (+)))) (0, 1)
22:12:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:13:12 <Gracenotes> > unfoldr (Just . (fst &&& uncurry ((,) <*> . (+)))) (0, 1)
22:13:13 <sciolizer_> mmorrow: What do you need it for? I'm trying to make a stress tester for memcache, and Haskell > C/Java.
22:13:13 <lambdabot>   <no location info>: parse error on input `.'
22:13:17 <Gracenotes> aws.
22:14:12 <mmorrow> sciolizer_: i was looking into possibly using it in a webserver
22:15:13 <Gracenotes> hrm. is there a list of modules lambdabot normally has loaded?
22:17:37 * Gracenotes greps through the source
22:17:40 * pumpkin hides from the mibbit user
22:18:46 <Gracenotes> pumpkin: hey, I use it all the time, it's more convenient than irssi just for simple chatting, if not more slow by design
22:19:21 <pumpkin> I've just had bad experiences with the kind of people who connect through it :P I'll try to overcome my prejudice
22:20:17 <Gracenotes> :t IM.size
22:20:18 <lambdabot> forall a. IM.IntMap a -> Int
22:20:22 <jsn> pumpkin: i connected through it yesterday
22:20:28 <pumpkin> jsn: I remember :)
22:20:39 <jsn> pumpkin: i'm more concerned about the people who use mIRC to connect
22:20:39 <Gracenotes> Hooray, I've found the modules loaded by lambdabot!
22:20:45 <jsn> like that conal elliot guy
22:20:45 <Gracenotes> heh
22:20:47 <pumpkin> Gracenotes: where?
22:20:50 <pumpkin> jsn: lol
22:20:54 <Axman6> pumpkin: i'm with you on that prejudice, had many a bad experience :P
22:21:07 <jsn> talking about "real functional programming" or whatever :)
22:21:07 <Axman6> ended up banning mibbit from the chan for a while
22:21:24 <Gracenotes> http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/L.hs
22:21:49 <Gracenotes> hm, perhaps not the best link, it's not as comprehensive as the one I downloaded with the .tar.fz
22:21:52 <Gracenotes> *gz
22:21:59 <jsn> Gracenotes: thanks
22:22:05 <jsn> i've long wondered about that
22:22:33 <Gracenotes> here we are, http://code.haskell.org/lambdabot/State/L.hs
22:22:38 <jsn> has anyone looked into IterateeM and EnumeratorM much?
22:23:05 <Axman6> i read some of one of the presentations yesterday, that's about it :
22:23:29 <jsn> so my understanding is that it is sort of like visitor pattern?
22:23:30 <jeffwheeler> Axman6: your secret's out!
22:23:41 <Axman6> oh noes!
22:23:56 <Axman6> damn, i hid it so well, even i didn't know what it is!
22:24:06 <jeffwheeler> Axman6: ah, shucks
22:24:15 <Axman6> what's the secret? :P
22:24:24 <pumpkin> Axman6: we know, don't try to hide it
22:24:28 <jeffwheeler> Axman6: that I'm evil? :P
22:24:36 <Axman6> ah yes
22:24:46 <jsn> basically, the iteratee advances "one step" in the stream, and passes control information back to the enumerator
22:24:46 <Axman6> can't be trusted for anything more than making cool logos
22:24:56 <Gracenotes> ...oh, jeez
22:25:05 <jsn> the enumerator decides to return or quit?
22:25:12 <Gracenotes> apparently what lambdabot does is add the command to the long list of import statements
22:25:28 <Gracenotes> no real context of evaluation... just copy+paste :)
22:25:35 <Axman6> all i got out of what i read was that it could server files in constant space...
22:25:49 <Gracenotes> it works quite well though, heh
22:26:05 <Taejo> pumpkin: I'm on mibbit
22:26:07 <jsn> well, so it seems like the enumerator sequences the effect of "iterating one step"
22:26:14 <pumpkin> Taejo: omg epic fail
22:26:14 <Taejo> the place I'm staying blocks IRC
22:26:22 <pumpkin> Taejo: even more epic fail
22:26:23 * Axman6 hugs Taejo 
22:26:45 <jsn> which suggests Enumerator can be thought of as monadic even without an underlying monad like IO
22:27:17 <Taejo> Axman6: thanks. I need it
22:29:59 <pumpkin> what's a simple way to create the list [2,1,1,4,1,1,6,1,1 ...]
22:30:17 <Axman6> ow, switching from the Turbinado website to a black terminal with bright green text hurts >_<
22:30:25 <pumpkin> intersperse only allows me to stick a single 1 between things
22:30:43 <Taejo>   "Once there was a girl who lived in Garowe," 100 miles from Eyl, Jama says. "I loved her. I tried to approach her many times, but she rejected me. But since I became a pirate, she has tried nine times to get with me. " -- A pirate's life for me, indeed
22:31:00 <Axman6> pumpkin: concat.intersperse [1,1].map return $ xs?
22:31:00 <nburlett> has anyone here tried turbinado?
22:31:16 <Axman6> > concat.intersperse [1,1].map return $ [2,4,3,5]
22:31:17 <lambdabot>   [2,1,1,4,1,1,3,1,1,5]
22:31:18 <nburlett> when I configure it, I get Warning: This package indirectly depends on multiple versions of the same
22:31:18 <nburlett> package. This is highly likely to cause a compile failure.
22:31:30 <nburlett> and it somehow wants multiple bytestrin versions
22:31:32 <pumpkin> Axman6, cool, thanks
22:31:37 <Taejo> concat.intersperse = intercalate
22:31:56 <Taejo> and (:[]) is shorter and smilier than return
22:32:03 <Axman6> > intercalate [1,1].map return $ [2,4,3,5]
22:32:05 <lambdabot>   [2,1,1,4,1,1,3,1,1,5]
22:32:28 <pumpkin> thanks :)
22:32:33 <Gracenotes> yay, now I have everything lambdabot has! Success!
22:32:53 <Axman6> > [2,4,3,5] >>= intersperse [1,1].return
22:32:54 <lambdabot>       No instance for (Num [t])
22:32:54 <lambdabot>        arising from the literal `2' at <inter...
22:33:02 <Axman6> hm, yes
22:33:32 <Gracenotes> oh, duh, I can use (:[]) instead of flip(:)[]
22:33:36 <Axman6> > concatMap (:[1,1]) [2,6,4,7]
22:33:37 <lambdabot>   [2,1,1,6,1,1,4,1,1,7,1,1]
22:34:14 <shrughes> > [2,6,4,7]>>=(:[1,1])
22:34:16 <lambdabot>   [2,1,1,6,1,1,4,1,1,7,1,1]
22:34:35 <Axman6> shrughes: duh, yeah, good work :)
22:34:59 <Taejo> @let contfrac x:xs = 1/(x + 1/(contfrac xs))
22:34:59 <Taejo> @let contfrac (x:xs) = 1/(x + 1/(contfrac xs))
22:34:59 <Taejo> contfrac $ intercalate [1,1].map return $ [2,4,6,8]
22:34:59 <Taejo> >contfrac $ intercalate [1,1].map return $ [2,4,6,8]
22:34:59 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsIdent "contfrac"))
22:35:00 <lambdabot>  Defined.
22:35:05 <Taejo> @let {contfrac (x:xs) = 1/(x + 1/(contfrac xs)); contfrac x = 1/x}
22:35:05 <lambdabot>  <local>:6:0: parse error on input `{'
22:35:23 <Taejo> > let {contfrac (x:xs) = 1/(x + 1/(contfrac xs)); contfrac x = 1/x} in contfrac [2,1,1,4,1,1,6]
22:35:24 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
22:35:25 <lambdabot>        Expect...
22:35:42 <shrughes> [x]
22:35:51 <Gracenotes> :type unsafePerformIO
22:35:57 <Gracenotes> @type unsafePerformIO
22:35:58 <lambdabot> Not in scope: `unsafePerformIO'
22:36:03 <Taejo> > let {contfrac (x:xs) = 1/(x + 1/(contfrac xs)); contfrac [x] = 1/x} in contfrac [2,1,1,4,1,1,6]
22:36:04 <lambdabot>   mueval: Prelude.read: no parse
22:36:05 <shrughes> IO a -> a
22:36:05 <lambdabot>  mueval: UnknownError "GHC reported errors a...
22:36:19 <Gracenotes> hm. looks unsafe to me >_>
22:36:22 <Axman6> Taejo: no need for the {} btw
22:37:06 <shrughes> > let contfrac = foldr 1 (\x y -> 1/(x + 1/y)) in contfrac [2,1,1,4,1,1,6]
22:37:08 <lambdabot>       Overlapping instances for Show (a1 -> a1 -> a1)
22:37:08 <lambdabot>        arising from a u...
22:37:12 <shrughes> > let contfrac = foldr1 (\x y -> 1/(x + 1/y)) in contfrac [2,1,1,4,1,1,6]
22:37:14 <lambdabot>   9.83606557377049e-2
22:37:53 <Gracenotes> > iterate 5 [2,1]
22:37:54 <lambdabot>       No instance for (Num ([t] -> [t]))
22:37:54 <lambdabot>        arising from the literal `5' ...
22:38:05 <Gracenotes> > replicate 5 [2,1]
22:38:06 <lambdabot>   [[2,1],[2,1],[2,1],[2,1],[2,1]]
22:38:30 <shrughes> oh wait.. yah.
22:39:05 <shrughes> Taejo I'm pretty sure you want 1/(x + contfrac xs)
22:39:42 <Axman6> :t iterate (\x -> 1/(1+1/x))
22:39:43 <lambdabot> forall a. (Fractional a) => a -> [a]
22:39:52 <Axman6> > iterate (\x -> 1/(1+1/x)) 2
22:39:54 <lambdabot>   [2.0,0.6666666666666666,0.4,0.2857142857142857,0.2222222222222222,0.1818181...
22:39:55 <shrughes> > foldr1 (\x y -> 1 / (x + y)) [2,1,1,4,1,1,1/6]
22:39:57 <lambdabot>   0.39221556886227543
22:39:59 <Axman6> > iterate (\x -> 1/(1+1/x)) 1
22:40:01 <lambdabot>   [1.0,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.1428571428571428...
22:40:14 <Taejo> let {contfrac [x] = x; contfrac (x:xs) = x + 1/(contfrac xs)} in contfrac [2,1,2,1,1,4,1,1,6,1,1,8]
22:40:16 <Taejo> > let {contfrac [x] = x; contfrac (x:xs) = x + 1/(contfrac xs)} in contfrac [2,1,2,1,1,4,1,1,6,1,1,8]
22:40:17 <lambdabot>   2.7182818352059925
22:40:32 <nolrai_East> What does the error "Inferred type is less polymorphic than expected" mean?
22:40:39 <pumpkin> whee, I just did 65
22:40:56 <pumpkin> ooh you guys are doing continued fractions too
22:41:06 <shrughes> wat
22:41:21 <pumpkin> angkor?
22:42:08 <Taejo> @let {contfrac [x] = x; contfrac (x:xs) = x + 1/(contfrac xs)}
22:42:09 <lambdabot>  <local>:6:0: parse error on input `{'
22:42:42 <Taejo> @let contfrac (x:xs) = case xs of {[] -> x; xs -> x + 1/(contfrac xs)}
22:42:42 <lambdabot>  <local>:5:0:
22:42:42 <lambdabot>      Warning: Pattern match(es) are overlapped
22:42:42 <lambdabot>               In...
22:42:55 <pumpkin> I used a fold
22:43:12 <shrughes> > let {contfrac [x] = x; contfrac (x:xs) = x + 1/(contfrac xs)} in numerator . contfrac . take 100 $ [2, 1] ++ [2,4..]>>=(:[1,1])
22:43:14 <lambdabot>   352969504220832955731276377701497918020115896457358711560
22:43:17 <Taejo> yeah, I guess it is a rightfold
22:43:26 <pumpkin> yup
22:43:33 <shrughes> > let {contfrac [x] = x; contfrac (x:xs) = x + 1/(contfrac xs)} in sum . map digitToInt . show . numerator . contfrac . take 100 $ [2, 1] ++ [2,4..]>>=(:[1,1])
22:43:35 <lambdabot>   252
22:43:39 <pumpkin> for sqrt(2) an iterate is enough
22:43:46 <shrughes> meh
22:44:19 <Taejo> foldr1 (\x r -> x + (1/r)) [2,1,2,1,1,4,1,1,6]
22:44:21 <Taejo> >foldr1 (\x r -> x + (1/r)) [2,1,2,1,1,4,1,1,6]
22:44:29 <Taejo> > foldr1 (\x r -> x + (1/r)) [2,1,2,1,1,4,1,1,6]
22:44:30 <lambdabot>   2.718279569892473
22:44:50 <Taejo> much neater than my rubbish
22:44:53 <pumpkin> :)
22:44:53 <Taejo> > foldr1 (\x r -> x + (1/r)) [2,1,2,1,1,4,1,1,6] :: Expr
22:44:55 <lambdabot>   2 + 1 / (1 + 1 / (2 + 1 / (1 + 1 / (1 + 1 / (4 + 1 / (1 + 1 / (1 + 1 / 6)))...
22:45:01 <Taejo> looks right
22:45:02 <Gracenotes> wheeeeeeeeee
22:45:05 <mmorrow> @index fixIO
22:45:06 <lambdabot> System.IO
22:45:28 <Taejo> :t fixIO
22:45:29 <lambdabot> Not in scope: `fixIO'
22:45:44 <shrughes> > foldr1 ((. recip) . (+)) [2,1,2,1,1,4,1,1,6]
22:45:45 <lambdabot>   2.718279569892473
22:46:10 <shrughes> > numerator $ foldr1 ((. recip) . (+)) [2,1,2,1,1,4,1,1,6]
22:46:12 <lambdabot>   1264
22:46:46 <pumpkin> don't do the whole problem in a public channel :P
22:47:13 <Taejo> pumpkin: is this for Euler?
22:47:18 <shrughes> > sum . map digitToInt . show . numerator . foldr1 ((. recip) . (+)) . take 100 $ 2:1:([2,4..]>>=(:[1,1]))
22:47:19 <lambdabot>   272
22:47:28 <pumpkin> lol shrughes nevermind :P
22:47:33 <pumpkin> Taejo: that was the answer there ;)
22:47:38 <shrughes> lol
22:48:41 <Gracenotes> sum of the digits of some large number?
22:49:16 <Gracenotes> > 2:1:([2,4..]>>=(:[1,1]))
22:49:17 <lambdabot>   [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,14,1,1,16,1,1,18,1,1,20,1,1,22,1...
22:49:28 <shrughes> that's the continued fraction expansion of e
22:50:07 <pumpkin> I liked problem 79
22:50:11 <pumpkin> if anyone's looking for a fun one
22:50:25 <Taejo> I should go to bed rather than start doing PE
22:50:28 <dmwit> Oy, somebody said my name way back.
22:50:31 <Gracenotes> the sum of the numerator of the rational number produced by the first 100 terms of the continued fraction of e?
22:50:45 <pumpkin> Gracenotes: that's it
22:50:49 <Cale> pumpkin: why? There are solutions available for basically all the problems in public places.
22:50:59 <shrughes> > unfoldr (Just . second recip . properFraction) (exp 1)
22:51:00 <Gracenotes> pumpkin: the code kind of speaks for itself ;)
22:51:01 <lambdabot>   [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,11,3,2,1,3,1,73,6,1,1,1,1,1,2,31...
22:51:16 <dmwit> ah
22:51:26 <pumpkin> Cale: so people who don't want to see don't have to :P they'd have to go look it up if they wanted the solution otherwise
22:51:38 <pumpkin> Cale: but maybe there are no such people in here
22:51:44 <Gracenotes> @type exp 1
22:51:45 <lambdabot> forall t. (Floating t) => t
22:51:54 <Cale> Nobody complained anyway :)
22:52:02 <pumpkin> yup :)
22:52:26 <Cale> Any good problem should have more than one solution too.
22:52:54 <Cale> I think people get too uptight about people publishing solutions to problems :P
22:53:06 <pumpkin> fair enough :)
22:53:17 <Gracenotes> Cale: of course. 1) Most problems can be written in Haskell 2) I've found there are often many ways to write the same thing in Haskell 3) Your conclusion :)
22:54:12 <Taejo> > exp 1 :: Expr
22:54:13 <lambdabot>   exp 1
22:54:24 <Gracenotes> @src exp
22:54:25 <lambdabot> Source not found. Do you think like you type?
22:54:30 <Taejo> > 5^5 :: Expr
22:54:31 <lambdabot>   5 * 5 * (5 * 5) * 5
22:54:37 <Cale> It would be fun to go into the business of writing and publishing solutions manuals for other books ;)
22:54:45 <Taejo> > 5^7 :: Expr
22:54:47 <lambdabot>   5 * 5 * (5 * 5) * (5 * 5 * 5)
22:54:51 <Gracenotes> where does the Expr type come from?
22:54:53 <Taejo> > 7^5 :: Expr
22:54:55 <lambdabot>   7 * 7 * (7 * 7) * 7
22:54:58 <Cale> simplereflect
22:55:02 <Taejo> > x^5 :: Expr
22:55:03 <lambdabot>   x * x * (x * x) * x
22:55:07 <Cale> @cabal simplereflect
22:55:07 <lambdabot>   bzzt.
22:55:09 <Cale> hmm
22:55:14 <conal> jsn: ("like that conal elliot guy")  ??
22:55:21 <pumpkin> > x^17 :: Expr
22:55:22 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
22:55:24 <Gracenotes> @go simplereflect
22:55:27 <Taejo> how is x :: Expr implemented?
22:55:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
22:55:29 <lambdabot> Title: HackageDB: simple-reflect-0.1
22:55:40 <Taejo> > y^17 :: Expr
22:55:40 <shrughes> > product [1..21]
22:55:42 * QtPlatypus finds the braketing interesting.
22:55:42 <lambdabot>   y * y * (y * y) * (y * y * (y * y)) * (y * y * (y * y) * (y * y * (y * y)))...
22:55:42 <lambdabot>   51090942171709440000
22:55:45 <Cale> Taejo: A custom datatype with sneaky instances of Num, etc.
22:55:48 <shrughes> too many cases
22:55:58 <Cale> @cabal simple-reflect
22:55:59 <lambdabot>   bzzt.
22:56:03 <Cale> @hackage simple-reflect
22:56:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
22:56:07 <Cale> there we go :)
22:56:14 <Axman6> @src (^) -- QtPlatypus
22:56:14 <lambdabot> Source not found. :(
22:56:18 <Axman6> aww
22:56:23 <Axman6> hmm
22:56:33 <Taejo> Cale: yeah, I see how it works for things like 17^17 ... but I can't see how one gets hold of the variable names used
22:56:34 <Axman6> @src (**)
22:56:34 <lambdabot> Source not found. My pet ferret can type better than you!
22:56:38 <Gracenotes> Cale: ./.cabal/bin/cabal install simple-reflect works, apparently
22:56:43 <dmwit> Taejo: x = expr "x"
22:56:48 <Cale> Taejo: a-z are defined as Expr values
22:56:55 <Taejo> oh, ok
22:57:06 <Taejo> > foo^20
22:57:07 <lambdabot>   Not in scope: `foo'
22:57:11 * dmwit nods
22:57:15 <Taejo> right, that makes sense
22:57:33 <dmwit> > let x = 3 in x -- and let bindings override it, of course
22:57:34 <pumpkin> > unfoldr (Just . second recip . properFraction) (sqrt 2) -- doesn't look right
22:57:34 <lambdabot>   3
22:57:35 <lambdabot>   [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,3,3,1,3,1,1,2,1809,1,2,5,2...
22:57:43 <pumpkin> must be rounding errors
22:58:00 <pumpkin> > unfoldr (Just . second recip . properFraction) (sqrt 2 :: CReal)
22:58:15 <pumpkin> slooow
22:58:15 <lambdabot>   thread killed
22:58:18 <pumpkin> :(
22:58:20 <Axman6> @src (^^)
22:58:21 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
22:58:27 <dmwit> :t properFraction
22:58:29 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
22:58:36 <dmwit> > properFraction (0.5 :: CReal)
22:58:38 <lambdabot>   (1,-0.5)
22:58:39 <pumpkin> it works fine on my computer
22:58:44 <Axman6> i know i've seen the source for ^ here before :\
22:58:45 * dmwit chuckles
22:58:58 <dmwit> ?src (^)
22:58:58 <lambdabot> x ^ 0            =  1
22:58:58 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
22:58:58 <lambdabot>   where f _ 0 y = y
22:58:58 <lambdabot>         f x n y = g x n
22:58:58 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
22:59:00 <lambdabot>                       | otherwise = f x (n-1) (x*y)
22:59:02 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
22:59:06 <dmwit> Axman6: ...?
22:59:19 <Axman6> hmm, so @src and ?src are different then?
22:59:23 <dmwit> no.
22:59:28 <Axman6> @src (^)
22:59:29 <lambdabot> x ^ 0            =  1
22:59:29 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
22:59:29 <lambdabot>   where f _ 0 y = y
22:59:29 <lambdabot>         f x n y = g x n
22:59:29 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
22:59:31 <lambdabot>                       | otherwise = f x (n-1) (x*y)
22:59:33 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
22:59:52 <Axman6> oh i know, i used @src (^) -- QtPlatypus
22:59:56 <dmwit> right
23:00:06 <Axman6> thought it would comment like in >
23:00:10 <dmwit> See, ?src doesn't have a real parser.
23:00:24 <dmwit> It just searches for *everything* to the right of the command.
23:01:02 <Taejo> > iterate f x :: Expr
23:01:04 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Expr]'
23:01:07 <Taejo> > iterate f x :: [Expr]
23:01:09 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
23:01:38 <Axman6> > x^9 :: Expr
23:01:40 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * x
23:02:43 <Gracenotes> oh, so *that's* why a/s/l returns a / s / l
23:02:56 <Gracenotes> @type a/s/l
23:02:58 <lambdabot> Expr
23:04:39 <Gracenotes> > map f [a, b]
23:04:40 <lambdabot>   Add a type signature
23:04:56 <Gracenotes> > map f [a]
23:04:57 <lambdabot>   Add a type signature
23:05:13 <Gracenotes> @type a
23:05:14 <lambdabot> Expr
23:05:16 <Axman6> > map f [a,b,c] :: [Expr
23:05:18 <lambdabot>   <no location info>: parse error on input `;'
23:05:18 <Axman6> > map f [a,b,c] :: [Expr]
23:05:20 <lambdabot>   [f a,f b,f c]
23:05:31 <Gracenotes> ah
23:07:39 <Gracenotes> > do { a1 <- [a, b]; a2 <- [c, d]; return (a1, a2)} :: [(Expr, Expr)]
23:07:40 <lambdabot>   [(a,c),(a,d),(b,c),(b,d)]
23:07:45 <twb> So using cabal, I can build libHSdarcs in dist/...
23:07:47 <shrughes> > round . (* 1000) . (\ns -> 2 * sum ns - sum (zipWith dep ns (tail ns))) $ [49,47..31] ++ [30,32..50]
23:07:48 <lambdabot>   Not in scope: `dep'
23:08:04 <twb> Can I load this from ghci?  The older "make ghci" target recompiles the whole source every time.
23:08:13 <shrughes> > let dep x y = x + y - sqrt ((x + y)^2 - (100 - x - y)^2) in round . (* 1000) . (\ns -> 2 * sum ns - sum (zipWith dep ns (tail ns))) $ [49,47..31] ++ [30,32..50]
23:08:15 <lambdabot>   1590933
23:11:35 <twb> Put differently: how do I load libHSfoo.a in ghci?
23:12:54 <Cale> twb: hmm
23:13:12 <Cale> twb: I guess you could try passing it as a parameter on the commandline
23:13:31 <Cale> twb: Normally libraries get loaded by GHCi automatically when you load one of their modules.
23:15:21 <twb> Cale: hmm, but will it know to look in dist/build/?
23:15:33 <Cale> Probably not.
23:15:39 <Cale> twb: Is it a cabal package?
23:16:07 <Cale> twb: When you install it, if it exposes modules, then you can simply :m + The.Module.Name
23:16:48 <twb> Cale: I don't want to actually install it.
23:16:49 <Cale> I've never tried without installing the package though.
23:16:53 <twb> OK.
23:16:59 <Gracenotes> @ghc
23:16:59 <lambdabot> ghc says: Ambiguous constraint
23:17:04 <Cale> @ghc
23:17:04 <lambdabot> ghc says: There must be at least one non-type-variable in the instance head
23:17:13 <Cale> @ghc
23:17:13 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
23:17:19 <Cale> :)
23:17:25 <Gracenotes> @let dep x y = x + y - sqrt ((x + y)^2 - (100 - x - y)^2) in round . (* 1000) . (\ns -> 2 * sum ns - sum (zipWith dep ns (tail ns))) $  [49,47..31] ++ [30,32..50]
23:17:25 <lambdabot>   Parse error
23:17:30 <Gracenotes> uh, heh
23:17:39 <Gracenotes> don't you love copy and paste?
23:17:41 <Gracenotes> @girl19
23:17:42 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
23:17:54 <Cale> @keal
23:17:54 <lambdabot> nsa prevent me from returning to math on efnet
23:18:08 <Gracenotes> (I'm not stealing your codez, just learning!)
23:18:09 <Cale> Keal makes such a great bot plugin :)
23:18:17 <Gracenotes> @keal
23:18:18 <lambdabot> i lack in verbal and social expression
23:18:27 <Cale> @keal
23:18:27 <Gracenotes> @keal
23:18:27 <lambdabot> i aint running that on my puter
23:18:27 <lambdabot> i think i know what code does but code looks to simple to actually do it
23:18:36 <Gracenotes> ...
23:18:39 <Cale> @keal
23:18:39 <lambdabot> #haskell needs to take its meds
23:18:42 <Cale> @keal
23:18:42 <lambdabot> how do i search for someone saying 'Keal' in mirc
23:18:58 <Cale> aww, these aren't the really crazy ones
23:18:59 <Cale> @keal
23:18:59 <lambdabot> it is very easy to go off topic
23:19:05 <Cale> @keal
23:19:05 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
23:19:12 <Gracenotes> @nixon
23:19:12 <Gracenotes> aww.
23:19:15 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
23:19:16 <Cale> that's getting warmer :)
23:19:31 <Cale> @keal
23:19:32 <lambdabot> you need a Zh function in Haskell
23:19:44 <Cale> @yow
23:19:44 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
23:20:37 <Gracenotes> @palomer
23:20:37 <lambdabot> I think you're all nuts
23:20:41 <Gracenotes> @palomer
23:20:41 <lambdabot> Brump!
23:20:43 <Gracenotes> @palomer
23:20:43 <lambdabot> You're all nuts
23:20:47 <Gracenotes> hm.
23:20:51 <Cale> @palomer
23:20:52 <lambdabot> Learning vim is pointless
23:21:02 * Gracenotes takes this to PM
23:23:00 <twb> Hmm, suppose I have a list of showable objects, and I want to print the (to stdout) separated by newlines rathe r than the normal Show List.
23:23:08 <twb> Do I just map (putStrLn . show) ?
23:23:56 <Cale> lambdabot: @join #functionaljava
23:24:09 <Cale> mapM_
23:24:32 <Cale> Or  putStrLn . lines . map show
23:24:39 <Cale> er
23:24:43 <Cale> unlines rather
23:25:32 <Cale> It's also worth noting that putStrLn . show = print
23:25:32 <twb> Yeah
23:25:49 <twb> Mebbe I should add that to hlint!
23:26:04 <twb> Even though I can't compile hlint until I get 6.10 :-(
23:29:05 <twb> lambdabot: hlint
23:29:09 <twb> lambdabot: drhaskell
23:29:10 <jsn> conal: i was teasing
23:29:15 <twb> Hmph
23:29:17 <jsn> conal: i know you used to use windows
23:29:30 * Gracenotes trudges through lambdabot's sourcecode
23:32:46 <twb> Cale: how about main = mapM print xs ?
23:33:05 <Cale> should be fine
23:33:09 <twb> I suppose that won't have newline separators.
23:33:16 <Cale> It will
23:33:25 <twb> Oh right, of course it will
23:33:45 <Cale> mapM_ discards the results which you don't care about, so it might be a bit better for large inputs
23:34:15 <twb> In Darcs, we have a bunch of "command" objects, which each have a name, short and long descriptions, and a bunch of options.
23:34:24 <Cale> (each call to print returns an empty tuple, which mapM will collect into a list)
23:35:08 <twb> I essentially want three instances kinds of Show -- one for standard output "darcs --help", one for the manpage (groff format) and one for the user manual (reST format).
23:35:49 <twb> Other than writing a non-classed show_manpage and show_rest, is there a "best practice" for doing that sort of thing?
23:36:17 <Cale> There are a couple of ways you could do it. One is to write instances of Show and use newtype wrappers to specify which instance you want, the other is basically what you said.
23:36:48 <Cale> In this case, I would probably go with just writing separate functions.
23:36:59 <twb> Okey dokey
23:37:04 <Gracenotes> @hoogle MVar
23:37:04 <lambdabot> module Control.Concurrent.MVar
23:37:04 <lambdabot> Control.Concurrent.MVar data MVar a
23:37:04 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
23:37:06 <twb> It'll still be an improvement over what's there currently.
23:37:24 <Gracenotes> hm, way over my head
23:37:27 <Cale> The newtype wrappers might be convenient if there's more than one type of thing which you want to be able to print for a manpage, etc.
23:37:48 <Cale> Gracenotes: actually, MVars are pretty simple
23:37:58 <mmorrow> Gracenotes: MVars are easy :)
23:38:04 <mmorrow> what are you trying to do?
23:38:13 <nolrai_East> @djinn (Monad m) => (m (t a) -> m' (t b)) -> (m (Maybe (t a)) -> m' (Maybe (t b))
23:38:14 <lambdabot> Cannot parse command
23:38:14 <mmorrow> or s/trying/want/
23:38:18 <twb> I don't understand this ghc error: The equation(s) for `show' have two arguments,
23:38:19 <Gracenotes> I see how lambdabot saves a module's state to an mvar
23:38:27 <nolrai_East> @djinn (m (t a) -> m' (t b)) -> (m (Maybe (t a)) -> m' (Maybe (t b))
23:38:27 <lambdabot> Cannot parse command
23:38:28 <twb> Oh, I'm stupid
23:38:34 <twb> It's talking about *my* equations
23:38:41 <mmorrow> Gracenotes: ok. have you read about how MVars behave?
23:38:42 <Cale> An MVar is a mutable cell which may be empty. Writing to it when it's full will cause your thread to block until it empties, and reading when it's empty will block until it is filled.
23:38:50 * twb adds some parens
23:39:06 <Gracenotes> mmorrow: I'm aware that they're variables that can be shared between threads, or something like...
23:39:08 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
23:39:14 <nolrai_East> @djinn (Monad m) => (m (t a) -> m' (t b)) -> MaybeT m (t a) -> MaybeT m' (t b)
23:39:14 <lambdabot> Error: Undefined type MaybeT
23:39:43 <nolrai_East> @djinn (Monad m) => (m (t a) -> m' (t b)) -> (m (Maybe (t a)) -> m' (Maybe (t b)))
23:39:43 <lambdabot> Error: Class not found: Monad
23:39:56 <Gracenotes> I'm familiar with concurrency in imperative programming, but not functional :) besides dealing with workers threads; probably the closest thing
23:40:29 <mmorrow> (\io -> do res <- newEmptyMVar; forkIO (io >>= putMVar res); return res) :: IO a -> IO (Mvar a)
23:41:21 <twb> If r is a record (i.e. of type F {x, y, z}), how do I refer to r's xth element?
23:41:27 <mmorrow> that takes an io action, creates an empty MVar, forks (evaluate io action, then stick it in the empty MVar), and returns the MVar
23:41:32 <mmorrow> if you do
23:41:36 <mmorrow> takeMVar res
23:41:44 <nolrai_East> twb: x r
23:41:47 <mmorrow> it'll block until that Mvar is full
23:41:53 <twb> Thank you.
23:42:21 <mmorrow> so they're used a lot for getting a way to wait until something has happened
23:42:32 <mmorrow> like e.g. a thread has finished
23:43:25 <Gracenotes> hm, neat. although one probably doesn't need an mvar if doing something with no expected result
23:43:46 <mmorrow> well, i was just about to say something about that
23:44:01 <Cale> Gracenotes: Even if you just want to be able to wait until something's finished, an MVar () can be handy.
23:44:05 <Gracenotes> e.g., a POST request sent to a web page that sends something to your email address
23:44:07 <mmorrow> so suppose you're forking a bunch of threads in main
23:44:14 <mmorrow> and all your main does is fork stuff
23:44:28 <mmorrow> if main exits, the program ends and all those threads'll die
23:44:30 <pumpkin> can someone go over the various *morphisms and their mappings in haskell?
23:44:44 <Gracenotes> mmorrow: ah, so the threads are daemon threads, effectively
23:44:45 <mmorrow> so in that case you'd want to have a status MVar for each thread
23:44:55 <Cale> pumpkin: The ones from category theory, or the ones from recursion theory?
23:44:56 <mmorrow> then mapM_ takeMVar mvars
23:44:58 <mmorrow> in main
23:45:27 <mmorrow> Gracenotes: hmm, what exactly is the def of a daemon thread?
23:45:35 <pumpkin> Cale: I don't know :P I know about catamorphisms in the context of haskell, and that people talk about many other *morphisms that I have no clue about... :)
23:45:45 <pumpkin> except for maybe Arrow, which is just morphism?
23:46:08 <Cale> morphism is just a fancy word for function
23:46:20 <pumpkin> same with arrow then?
23:46:33 <Gracenotes> mmorrow: in some other programming languages, if main ends and the only threads running are daemons, the program terminates
23:46:47 <pumpkin> I know isomorphism from my basic math courses
23:46:48 <Gracenotes> if main ends and non-daemon threads are running, all must stop before the program terminates
23:46:51 <Cale> Well, there's at least two concepts thrown around here which are called arrows :)
23:47:01 <Gracenotes> "all" meaning all non-daemon threads
23:47:02 <pumpkin> Cale: :o
23:47:02 <Cale> There are Hughes' arrows, from Control.Arrow
23:47:14 <Cale> and then there are category theory arrows, which are something else
23:47:23 <mmorrow> Gracenotes: ah, ok. so in (ghc at least) all threads are "daemon threads" by that def
23:47:30 <pumpkin> hmm
23:47:37 <Cale> Both of those are generalisations of the notion of a function.
23:47:45 <pumpkin> ok, the only ones I've been exposed to so far are the Control.Arrow ones I guess
23:47:51 <mmorrow> main is alive if and only if the program is still running
23:47:54 <Gracenotes> From what you've said, I believe. All threads except for main.
23:48:05 <mmorrow> heh, yes. true.
23:50:41 <mmorrow> Gracenotes: this is a handy forkIO wrapper that i use a lot: http://hpaste.org/13202
23:51:02 <mmorrow> so if you want to wait on that thread, just   takeMVar done
23:51:31 <mmorrow> main = takeMVar . snd =<< fork (mapM_ print [0..1000000])
23:51:53 <Cale> pumpkin: Well, okay, if you know what a catamorphism is (something which systematically replaces the constructors of a datatype with appropriately typed functions and values), an anamorphism sort of works in reverse to that, building a value up from a seed value, and a function which selects the constructor and other constant data, giving new seed values for any recursive cases
23:52:01 <pumpkin> yup
23:52:27 <pumpkin> is that an unfold then?
23:52:29 <Cale> pumpkin: A hylomorphism is an anamorphism followed by a catamorphism.
23:52:30 <Cale> yes
23:53:03 <pumpkin> hmm
23:53:21 <Cale> So the anamorphism builds up a structure, and then the catamorphism breaks it down again.
23:53:31 <pumpkin> what would that be used for?
23:53:35 * Gracenotes looks about
23:53:55 <Cale> Well, for instance, factorial is one of those.
23:53:55 <Gracenotes> mmorrow: is that forkIO...?
23:54:08 <pumpkin> Cale: ah, I see
23:54:20 <Cale> The composition of the anamorphism which builds up the list [1..n], and the catamorphism foldr (*) 1
23:56:06 <pumpkin> I see
23:56:08 <Cale> There are a number of others which have been named, but those are the usual ones :)
23:56:17 <mmorrow> Gracenotes: fork wraps forkIO, if that's what you mean
23:56:40 <mmorrow> Gracenotes: oh, no. it's this function: http://hpaste.org/13202
23:56:48 <pumpkin> how do you talk about these things? a catamorphism of lists? from lists?
23:56:52 <Cale> The other family of *morphism words comes more directly from category theory (well, perhaps abstract algebra before that)
23:57:03 <Cale> list catamorphism
23:57:06 <Gracenotes> ah
23:57:15 <Gracenotes> @quote
23:57:15 <lambdabot> sfultong says: I need to start thinking more lazily
23:57:22 <Cale> Or those would work too.
23:57:26 <Gracenotes> do
23:57:41 <Cale> pumpkin: Do you know what a category is?
23:57:42 <Gracenotes> do { st <- readMS; io (search (P.pack []) (P.pack []) st) } ...is what @quote does
23:57:47 <pumpkin> Cale: not really :)
23:57:50 <Cale> pumpkin: Okay
23:57:55 <pumpkin> Cale: haven't gotten around to your pdf yet
23:58:03 <Gracenotes> readMS = getRef >>= liftIO . readMVar
23:58:11 <Gracenotes> io = heaven knows what
23:58:31 <mmorrow> Gracenotes: so it's using an MVar to serialize access to the quote db
23:58:44 <mmorrow> that's another thing MVars are good for
23:59:10 <Cale> pumpkin: So a category is a collection of "objects" (these can be anything at all, and are really just markers), together with for every pair of objects X and Y a (possibly empty) collection of arrows, typically called Hom(X,Y)
23:59:18 <mmorrow> because if you takeMVar mvar, when that returns you'll have the mvar and anyone else trying to takeMVar it will be blocked
23:59:37 <Gracenotes> and the function returns ModuleLB (M.Map Key [P.ByteString])
23:59:38 <QtPlatypus>  /win 26
23:59:47 <mmorrow> also, if you putMVar mvar, and mvar is already full, you'll block until it becomes empty
23:59:55 <Cale> If f is an arrow in Hom(X,Y), we write f: X -> Y
