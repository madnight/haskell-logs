00:00:13 * Gracenotes tries it with runhaskell
00:02:07 <Gracenotes> adrian: with runhaskell, it seems to work
00:02:24 <Gracenotes> although, as I said, it takes a long time, 1-2 minutes
00:02:54 <adrian> probably because it swaps furiously
00:05:00 <adrian> > sum (take 1000000 (randomRs (-1000,1000) (mkStdGen 42)))
00:05:02 <lambdabot>   * Exception: stack overflow
00:05:08 <Gracenotes> it's a creative variant of mergesort :)
00:05:21 <adrian> > length (take 1000000 (randomRs (-1000,1000) (mkStdGen 42)))
00:05:23 <lambdabot>   1000000
00:05:37 <adrian> bottom up
00:06:08 <adrian> how much space does a node in an [Int] need?
00:06:20 <pumpkin> I'd assume 8 or 12 bytes?
00:08:41 <adrian> 4 for the Int, 4 for the pointer and another couple for the box?
00:09:00 <pumpkin> probably
00:09:09 <pumpkin> a few more if you're on a 64-bit system
00:10:31 <bd_> adrian: the int is boxed too
00:11:03 <bd_> object headers are at least the size of a pointer, so node would be something around 12 bytes, and the int another 8, I'd guess?
00:12:01 <adrian> that makes one million ints < 30 mb
00:12:11 <adrian> right?
00:13:48 <adrian> why does ghc eat >600 mb then?
00:14:04 <pumpkin> cause ram is yummy
00:15:56 <CakeProphet> is there a function which picks a random number from a range of numbers?
00:16:06 <pumpkin> yeah, can't remember it though
00:16:08 <Cale> CakeProphet: randomR
00:16:13 <Cale> :t randomR
00:16:14 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
00:16:37 <Cale> You give it a range, and a generator, and it gives you a random element and another generator.
00:16:53 <Cale> (to use for the next one)
00:17:09 <Cale> > randomR (1,6) (mkStdGen 42)
00:17:10 <lambdabot>   (6,1720602 40692)
00:17:22 <vixey> @seen quicksilver
00:17:22 <lambdabot> quicksilver is in #haskell-soc, #haskell-blah, #ghc and #haskell. I don't know when quicksilver last spoke.
00:17:33 <Cale> > let (a,g) = randomR (1,6) (mkStdGen 42) in randomR (1,6) g
00:17:34 <lambdabot>   (4,128694412 1655838864)
00:17:51 <Cale> (StdGens print a little strangely)
00:17:52 <vixey> hi
00:17:56 <CakeProphet> Cale:  that's kind of a pain. :/
00:18:09 <CakeProphet> all the functions will have to carry around a gen argument
00:18:25 <pumpkin> there are monadic ones
00:18:31 <Cale> CakeProphet: Referential transparency. If this is too inconvenient, you can use an appropriate monad to help you thread the gens along.
00:18:34 <CakeProphet> hmmm?
00:18:46 <Cale> Check out MonadRandom on Hackage.
00:19:07 <Cale> Or of course, there's the IO monad, if that's not a problem.
00:19:11 <Cale> :t randomRIO
00:19:13 <lambdabot> forall a. (Random a) => (a, a) -> IO a
00:19:17 <CakeProphet> I think my ghc build is missing some stuff.
00:19:25 <Cale> CakeProphet: oh?
00:19:37 <CakeProphet> I do :m Random but nothing from Random is in scope.
00:19:38 <Cale> This is in System.Random
00:19:46 <Cale> Ah, that's the old name of the module
00:19:57 <Cale> If you want to use the old name, you need the haskell98 package.
00:20:31 <CakeProphet> still not working.
00:20:34 <Cale> hmm
00:20:38 <Cale> :m + System.Random
00:20:44 <Cale> doesn't work?
00:20:58 <CakeProphet> Not in scope: data constructor `Random'
00:21:02 <CakeProphet> after typing exactly that
00:21:07 <CakeProphet> but it says Random is loaded
00:21:08 <Cale> errr...
00:21:25 <Cale> oh, in a file, you'd use  import System.Random
00:21:42 <CakeProphet> -nod-, I'm in ghci though
00:21:51 <Cale> cale@zaphod:~$ ghci
00:21:51 <Cale> GHCi, version 6.10.1: http://www.haskell.org/ghc/  :? for help
00:21:51 <Cale> Loading package ghc-prim ... linking ... done.
00:21:51 <Cale> Loading package integer ... linking ... done.
00:21:51 <Cale> Loading package base ... linking ... done.
00:21:53 <Cale> Prelude> :m + System.Random
00:21:54 <Cale> Prelude System.Random>
00:22:00 <Cale> (sorry for the paste)
00:22:05 <CakeProphet> no worries.
00:22:05 <Cale> That's what it ought to look like
00:22:08 <CakeProphet> mine does that too
00:22:11 <Cale> okay
00:22:15 <CakeProphet> but, when I type in any of the names
00:22:17 <CakeProphet> they're not there.
00:22:30 <Cale> randomR (1,6) (mkStdGen 42)
00:22:32 <Cale> try that
00:23:09 <CakeProphet> :o worked
00:23:13 <Cale> okay
00:23:21 <Cale> Not sure what you were trying then :)
00:23:34 <Cale> It should give 6 ;)
00:23:44 <CakeProphet> (6,1720602 40692)
00:23:46 <Cale> (6,1720602 40692)
00:23:47 <Cale> yeah
00:23:58 <CakeProphet> why is there a space in the second element?
00:24:11 <Cale> It's just the odd way in which StdGen values print
00:24:38 <Cale> There are two numbers involved in their internal state.
00:24:56 <CakeProphet> alright, installed MonadRandom... I'll check it out
00:25:21 <Cale> It would be nicer if they displayed as valid Haskell code.
00:25:34 <Cale> (for constructing the same StdGen)
00:25:40 <vixey> Cale, you know Axiom of constructibility?
00:25:47 <Cale> vixey: V=L
00:25:48 <Cale> ?
00:25:51 <vixey> yes
00:26:27 <vixey> is that related to what we were talking about before, with set vs type theoretic reals?
00:26:43 <Cale> That's a different kind of constructibility
00:27:32 <Cale> But in a weak sense, I suppose.
00:28:14 <ksf> does anyone have any pointers to stuff about how to do monadic combinators from scratch without messing up the first couple of tries?
00:29:32 <vixey> "monadic combinators"?
00:29:56 <vixey> do you mean applying liftM and similar?
00:29:56 <Cale> If you're talking about defining new monads...
00:30:12 <Cale> Most of the practical monads are accessible by using monad transformers and transforming some existing monad, and then newtype-wrapping it and perhaps restricting it somewhat.
00:30:35 <Cale> But... that might not be what you're referring to.
00:32:01 <Cale> vixey: Actually, that's an interesting question regarding V=L...
00:32:24 <Cale> vixey: I think what we were talking about before might even be a further restriction of V=L
00:32:37 <Cale> vixey: But I'm not sure.
00:33:16 <CakeProphet> oh beautiful
00:33:19 <CakeProphet> it has a getRandomR
00:33:25 <Cale> :t getRandomR
00:33:26 <lambdabot> Not in scope: `getRandomR'
00:33:30 <Cale> ah, right
00:33:31 <Cale> ;)
00:33:59 <vixey> Cale, oh another thing I came across
00:34:08 <vixey> (with regards to linear logic)
00:34:28 <Cale> CakeProphet: The Rand monad also gives you really descriptive types -- Rand t is rather like a t-valued random variable.
00:34:35 <vixey> I think they have given a definition of continuity:  f(UNION[i] s(i)) = UNION[i] f(s(i))
00:34:52 <Cale> okay
00:35:01 <ski_> vixey : `i' ranging over naturals ?
00:35:04 <vixey> is that the same one which you use with that topology for types
00:35:04 <CakeProphet> Cale:  random variable? When does it change value?
00:35:07 <vixey> yes ski_
00:35:19 <Cale> So that looks a lot like the usual sequential limit definition.
00:35:44 <Cale> CakeProphet: In the mathematical sense...
00:36:02 <Cale> http://en.wikipedia.org/wiki/Random_variable
00:36:02 <ski_> vixey : i think that's called `Heine continuity'
00:37:06 <Cale> vixey: The union here would be the least upper bound?
00:37:13 <CakeProphet> Cale:  oh... a 0-argument function sort of?
00:37:15 <ski_> Heine continuity implies Cauchy continuity without the Axiom of Choice<http://www.apronus.com/math/cauchyheine.htm>
00:38:10 <Cale> CakeProphet: Well, it's like if you took the type t, and associated a probability with each of its elements (roughly, doesn't quite work like that for infinite types)
00:38:55 <Cale> actually, it may just work like that for infinite types, but only because of a technicality in the way you have to define them here...
00:39:29 <ski_> for finite types `t' one could imagine a `distribution :: RealFrac a => Rand t -> [(t,a)]'
00:40:45 <Cale> CakeProphet: So a value of type (Rand t) is the information associated with how likely each outcome is, and the outcomes have type t
00:41:15 <CakeProphet> I get weird type errors when I try take 5 (getRandomRs (1,6))
00:41:26 <Cale> CakeProphet: That's because take wants a list.
00:41:36 <CakeProphet> getRandomRs is an infinite list.
00:41:41 <Cale> No, it's not a list at all.
00:41:52 <Cale> It's a Rand [Integer]
00:42:09 <CakeProphet> ah
00:42:11 <Cale> That is, it's primarily a Rand, you have to run it to get a list.
00:42:19 <CakeProphet> run it?
00:42:22 <Cale> do xs <- getRandomRs (1,6)
00:42:29 <Cale>    return (take 5 xs)
00:42:39 <CakeProphet> ah
00:42:41 <Cale> Or:
00:42:51 <Cale> fmap (take 5) (getRandomRs (1,6))
00:43:22 <Cale> Of course, that just gives you a different Rand-thing
00:43:29 <ski_> (vixey : btw, "they" being ?)
00:43:29 <Cale> In the end, you use runRand
00:43:40 <Cale> Or... I forget if that's exactly what it was called
00:43:43 <Cale> But something like that
00:45:30 <CakeProphet> Cale: runRand wants a generator, which is the whole thing I was avoiding in the first place.
00:46:58 <Cale> CakeProphet: But the Rand monad just hides the passing along of that generator.
00:47:14 <pumpkin> what's wrong with making a generator?
00:47:18 <pumpkin> as long as you don't have to pass it around
00:47:22 <CakeProphet> if the function I use to extract the computation requires as its parameter the generator, how is it hiding it?
00:47:25 <Cale> CakeProphet: So you can write a complicated algorithm which depends on random values, and just pass a single generator in at the end
00:47:42 <pumpkin> :t randomRIO
00:47:43 <lambdabot> forall a. (Random a) => (a, a) -> IO a
00:48:05 <pumpkin> I made a simple one that just gave me a list of random values
00:48:09 <Cale> CakeProphet: There's no magic in the Rand monad -- effectively  Rand t = StdGen -> (StdGen,t)
00:48:35 <Cale> CakeProphet: So it just helps you to compose computations without explicitly passing around these StdGen values.
00:48:54 <Cale> But at some point, you do need an actual generator.
00:49:01 <Cale> (to kick things off)
00:49:16 <CakeProphet> so what do I need to do to get a list of random integers going?
00:49:30 <ski_> @instances-importing Data.Random RandomGen
00:49:31 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
00:50:09 <Cale> CakeProphet: Well, from your main, or somewhere in IO, you will typically create a StdGen with newStdGen
00:50:25 <Cale> CakeProphet: and then pass that into the thing which needs to create the list of random integers.
00:50:27 <ski_> @instances-importing System.Random RandomGen
00:50:28 <lambdabot> StdGen
00:50:39 <Cale> It could then directly call randomRs
00:50:43 <Cale> :t randomRs
00:50:44 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
00:50:59 <Cale> which gives an infinite list of pseudorandom values from that generator
00:51:07 * ski_ wonders in what situations you'd want another instance of `RandomGen'
00:51:20 <Gracenotes> hm, does anyone have any ideas for "fun" things to do with the State monad?
00:51:39 <Cale> ski_: It's unfortunate that many other PRNGs don't quite fit into the RandomGen interface so cleanly.
00:51:41 <Gracenotes> I've already implemented a psuedo-random number generator... anything else?
00:52:05 <ksf> kindle a revolution?
00:52:12 <ski_> Gracenotes : write a one-pass traversal over a tree that tags every node with a counting number, starting from the number of nodes in the tree
00:52:36 <ski_> Cale : elaborate ?
00:52:45 <Gracenotes> ski_: also, I did that, both for a binary tree and an n-ary tree
00:53:07 <xEpicFailGuyx> Sorry ... I had to bring in a question from #haskell-blah
00:53:07 <Gracenotes> Cale helped with the binary iirc :)
00:53:09 <xEpicFailGuyx> (03:51:51 AM) xEpicFailGuyx: Oh yeah speaking of sexual pictures, when is it best to use types with named fields vs. proper maps in Haskell
00:53:12 <Cale> ski_: Well, it seems that the mersenne-twister package goes and defines its own cut-down version of the class.
00:53:14 <ski_> Gracenotes : including the "starting from the number of nodes in the tree" bit ?
00:53:52 <Gracenotes> ski_: hm, you mean it goes from n = number of nodes in tree to n+1, n+2, etc.?
00:53:59 <ksf> maps give you only o(log n) or similar access (there's hashmap as a counterexample), but can be constructed run-time
00:54:08 <Beelsebob> xEpicFailGuyx: depends what you're trying to do
00:54:13 <Cale> xEpicFailGuyx: Maps are forced to have all values in the same type, records can have different types, but are of a fixed size and content.
00:54:17 <Beelsebob> records give more type safety
00:54:24 <ski_> Gracenotes : yes .. it should be one-pass, and not be given the size initially
00:54:25 <Beelsebob> and more guarentees that you're using the right lookups
00:54:26 <xEpicFailGuyx> Beelsebob: Ah thanks
00:54:29 <Beelsebob> and higher performance
00:54:30 <ksf> ah I was thinking of ADTs.
00:54:34 <Beelsebob> but maps are more flexible
00:54:40 <xEpicFailGuyx> Good
00:54:44 <xEpicFailGuyx> Good answer thx
00:55:13 <Gracenotes> ski_: sounds possible, given that State is not actually run until one, uh, runs it
00:55:25 <Cale> Really, everything only gives you at worst O(log n) access time, and if you're willing to ignore one logarithmic factor, why not another? :)
00:55:48 <Cale> er, at best ;)
00:56:11 <ski_> Gracenotes : another one you could try is experimenting with "backwards-in-time" state monad
00:56:36 <Cale> (addresses into a memory of size n take at least O(log n) time to look at)
00:56:39 <Gracenotes> sounds interesting. what is it?
00:56:59 <ski_> Gracenotes : just pass the state "the other direction" in `(>>=)'
00:57:11 <wli> The constant factors tend to be low.
00:57:20 <pumpkin> is there a good way to get div and rem in one pass?
00:57:33 <CakeProphet> so if I do evalRand(g, randomRs (1,50)) where g equals my stdgen
00:57:34 <pumpkin> @hoogle divmod
00:57:34 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
00:57:34 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
00:57:39 <pumpkin> I guess so :)
00:57:44 <CakeProphet> will I get a list of pseudorandom numbers?
00:57:46 <pumpkin> > divmod 100 7
00:57:47 <lambdabot>   Not in scope: `divmod'
00:57:53 <pumpkin> > divMod 100 7
00:57:54 <lambdabot>   (14,2)
00:58:10 <Gracenotes> ski_: is there an online resource about that?
00:58:20 <dibblego> pumpkin, note that rem and mod are different functions
00:58:23 <pumpkin> yup
00:58:32 <pumpkin> but they coincide in the cases I need them :P
00:58:44 <ski_> Gracenotes : `instance Monad (BackState s) where ...; ma >>= amb = BS $ \s0 -> let (a,s2) = ma `unBS` s1; (b,s1) = amb a `unBS` s0 in (b,s2)' basically
00:59:19 <Gracenotes> mm, okay
00:59:42 * Gracenotes tries the labeling first
01:01:44 <CakeProphet> basically what I'm doing is making a six degrees of seperation simulator
01:02:01 <CakeProphet> where I'm representing people as an ID number and a list of other peoples ID numbers
01:02:04 <CakeProphet> that they know
01:02:24 <pumpkin> you using a graph library?
01:02:36 <CakeProphet> and to construct the list of people they know I need a gaussian-type random distribution function, but I don't know how to do that.
01:02:38 <CakeProphet> pumpkin:  no.
01:02:42 <ski_> CakeProphet : i think Jerzy Karczmarczuk used in in some paper about automatic differentiation at <http://users.info.unicaen.fr/~karczma/arpap/>
01:04:38 <CakeProphet> ski_, wat?
01:05:01 <ski_> sorry, s/in in/it in/, "it" being "backwards-in-time" state monad
01:05:24 <ski_> also s/CakeProphet/Gracenotes/ :)
01:05:30 <CakeProphet> used what? gaussian distribution or six degrees--....oh
01:05:49 <ski_> (`C' and `G' looks almost the same in this font ..)
01:08:41 <Gracenotes> ski_: one shouldn't have to use a State of a State at any point, right?
01:11:56 <dixie> Is haskell good for my 8 years sister as first contact with computer ?
01:12:40 <ksf> it'll spoil the brat like any other language.
01:12:54 <dibblego> dixie, yes
01:13:05 <ksf> the question is what kind of spoiling is acceptable.
01:18:39 <CakeProphet> so what if I have two functions producing random values. Will I need different starting gens for both?
01:18:58 <therp> I would be very interested in an experiment with innocent minds (=children) that compares functional programming languages with imperative ones
01:19:03 <ski_> Gracenotes : "a State of a State" ?
01:19:58 <CakeProphet> therp:  imperitive would be more intuitive. it takes grade students forever to grasp functions.
01:20:02 <blackh> therp: It's impossible for me. My 12-year-old daughter has been writing programs in Haskell, but since she knows that I like Haskell, she likes Haskell too!
01:20:04 <CakeProphet> in my experience, anyways.
01:20:53 <blackh> CakeProphet: I don't agree that imperative is easier. I don't have any proof, though.
01:20:53 <vixey> and "Most theories capable of describing the power set of the natural numbers have proof theoretic ordinals that are (as of 2008) so large that no explicit combinatorial description has yet been given. This includes second order arithmetic and set theories with powersets"
01:20:56 <Gracenotes> ski_: yeah... that's probably pretty pointless actually
01:21:11 <ski_> CakeProphet : generally, yes (you might get different enough behaviour for the two functions, starting at the same random seed/state, given the two functions function differently enough .. but i wouldn't rely on it)
01:21:25 <ski_> Gracenotes : i wasn't sure what you meant
01:21:34 <CakeProphet> ski_, what function do I need to use to get two different gens?
01:21:39 <ski_> @quote sarah
01:21:40 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
01:22:49 <ski_> CakeProphet : "usually" you'd write a function that consumes one generator and produces some value and a new generator, and then use that generator in the next thing needing a source of random bits
01:23:40 <ski_> CakeProphet : of course, this manual boring plumbing can be hidden away .. using something like the `Rand' monad Cale mentioned earlier
01:24:30 <CakeProphet> ski_, I still don't understand how that hides anything, because all the functions associated with it still return a new generator that I need to pass to the next function call.
01:25:22 <ski_> CakeProphet : instead of `myFunction :: Int -> StdGen -> (Blah,StdGen)' you get `myFunction :: Int -> Rand Blah'
01:27:25 <CakeProphet> runRand :: RandomGen g => Rand g a -> g -> (a, g)
01:27:34 <ski_> CakeProphet : and instead of `doBoth x y gen0 = (bleh,gen2) where (blah,gen1) = myFunction x gen0; (bleh,gen1) = myOtherFunction y blah' you get `doBoth x y = do blah <- myFunction x; bleh <- myOtherFunction y blah; return bleh'
01:27:34 <CakeProphet> I'm still passing around generator values though
01:28:25 <ski_> note that there's no mention of any `gen' in the latter version
01:28:42 <CakeProphet> I can't even read either of them.
01:29:12 <ski_>   doBoth x y gen0 = (bleh,gen2)
01:29:15 <ski_>     where
01:29:17 <ski_>     (blah,gen1) = myFunction x gen0
01:29:22 <ski_>     (bleh,gen1) = myOtherFunction y blah
01:29:24 <ski_> vs.
01:29:42 <ski_>   doBoth x y = do blah <- myFunction x
01:29:50 <ski_>                   bleh <- myOtherFunction y blah
01:29:59 <ski_>                   return bleh
01:30:03 <ski_> better ?
01:30:38 <CakeProphet> possibly, but I don't know where I actually pass in a generator now.
01:31:27 <ski_> (also, i now see i have a bug/typo in the first variant .. `(bleh,gen1)' in the last line should be `(bleh,gen2)' .. that's error-prone hand-plumbing for you)
01:31:36 <ski_> CakeProphet : that's the point
01:32:07 <CakeProphet> yes... except when I'm actually trying to program it. all of these functions want a generator.
01:32:09 <ski_> you hide the generator in the code that uses and relies on random things
01:32:41 <CakeProphet> so in myFunction somewhere
01:32:48 <CakeProphet> there'll be a do?
01:33:06 <ski_> then, when you're "done" with combining those pieces together to something producing the "whole" random thing you actually want, *then* you use `runRand' to pass in an initial generator
01:33:09 <CakeProphet> one line to get a generator, and the next to make the Rand thing?
01:34:01 <ski_> yes, `myFunction' will probably use a `do'-block
01:35:03 <CakeProphet> ...-grumbles- something as simple as random numbers shouldn't be this complicated.
01:35:46 <ski_> `myFunction' might call another function that actually needs direct access to the generator (to generate something random), as opposed to (implicitly) passing it around .. then that (snd only that) function will possibly mention `gen0',..
01:35:50 <sjanssen> CakeProphet: random numbers aren't complicated
01:36:20 <ski_> this isn't really about random numbers, but about state
01:36:20 <sjanssen> Rand makes it easy, the *IO functions are impure but still easy, and the StdGen passing variants are only slightly inconvenient
01:36:53 <philipp__> how could i generalise the function rk such that it supports any type in Fractional, not just double? the code: http://hpaste.org/13351
01:38:02 <sjanssen> philipp__: I'd imagine removing all the ::Double annotations should do it
01:38:22 <philipp__> sjanssen: no, unfortunately not
01:38:42 <sjanssen> oh, that causes ambiguous types, due to the amount of overloading you've got?
01:38:49 <philipp__> yep
01:38:51 <philipp__> right
01:39:30 <ski_> philipp__ : if you want the same type (say `d') instead of `Double', try using pattern-signatures
01:39:41 <sjanssen> philipp__: perhaps you could use separate operators for scaling and cross product?
01:40:00 <philipp__> ski_: I'll try thanks
01:40:02 <ski_>   rk (step :: d) ... = ..(1/6 :: d)..
01:40:04 <sjanssen> scale :: (Num a, VNum b) => a -> b -> b
01:41:52 <philipp__> sjanssen: the whole idea was to have the same operators ;-) but if it doesn't work...
01:44:00 <vixey> you know the ordinals
01:44:18 <vixey> Ord = N :: Ord | S :: Ord -> Ord | L :: (Nat -> Ord) -> Ord
01:44:46 <vixey> it's a weaker/smaller set than:
01:45:19 <vixey> Ord' = N :: Ord' n | S :: Ord' n -> Ord' n | L :: (Ord' n -> Ord' (S n)) -> Ord' (S n)?
01:46:54 <vixey> sorry I think that's a silly question
01:47:14 <vixey> (I guess they're really the same but one just counts how many times you took a limit)
01:56:59 <Gracenotes> ski_: hm, I'm still not quite sure what the initial state would be -- I've been studying it a bit
01:57:10 <Gracenotes> for the relabel-starting-at-size
01:57:24 <Gracenotes> I suspect I'm too stuck in the "state is integer" mode
01:57:37 <vixey> Gracenotes; what is it you are programming?
01:58:23 <Gracenotes> an exercise ski_ suggested in which a binary tree is relabeled in infix order from n to 2n-1, where n is the number of leaves in the tree
01:58:50 <ski_>   foo (Node (Node Nil 'b' Nil) 'a' (Node Nil 'c' Nil)) = Node (Node Nil (4,'b') Nil) (3,'a') (Node Nil (5,'c') Nil)
01:59:07 <ski_> (for pre-order traversal)
02:00:43 <Gracenotes> heh, not infix, in-order (pre-order would work too). it's getting late (or early, depending on how one views the hours...).
02:01:07 <ski_> (obviously the traversal order chosen is not terribly important)
02:01:17 <vixey> I never remebered all these funny names for tree traversal
02:02:27 <ski_>    pre-order : element,left child,right child
02:02:37 <ski_>     in-order : left child,element,right child
02:02:46 <ski_>   post-order : left child,right child,element
02:03:08 <vixey> aha!
02:03:09 <Gracenotes> ski_: nonetheless, I'm a bit baffled at what the second argument in runState/evalState should be :)
02:03:31 * vixey . o O ( 3? )
02:03:57 <Gracenotes> as I may have mentioned, this is the 4rd problem with State that I've done
02:04:53 <ski_> Gracenotes : well, you probably must count the nodes somewhere, right ?
02:05:26 <ski_> > 3
02:05:28 <lambdabot>   3
02:05:46 <Gracenotes> yes.
02:07:11 <Gracenotes> one potential idea is having the function that normally would be of type 'Tree a -> State Integer (Tree (Integer, a))' to be of type 'Tree a -> (Integer, State Integer (Tree (Integer, a)))'
02:07:27 <Gracenotes> that's why I mentioned having a state in a state :)
02:07:55 <vixey> :t runState
02:07:56 <lambdabot> forall s a. State s a -> s -> (a, s)
02:08:41 <vixey> > let list = "wibble" ; loop [] = return [] ; loop (x:xs) = do (i,j) <- get ; put (i+1,j+1) ; loop xs ; (r, (_, len)) = runState (loop list) (len,0) in r
02:08:41 <lambdabot>   <no location info>: parse error on input `='
02:09:35 <mbz_> @google repmin
02:09:37 <lambdabot> No Result Found.
02:09:44 <ski_> mbz_ :)
02:09:51 <mbz_> ski_, yep ;)
02:10:02 <vixey> > let list = "wibble" ; loop [] = return [] ; loop (x:xs) = do { (i,j) <- get ; put (i+1,j+1) ; liftM (i:) (loop xs) } ; (r, (_, len)) = runState (loop list) (len,0) in r
02:10:03 <lambdabot>   [6,7,8,9,10,11]
02:10:09 <fschwidom> i am proud to present: lambda calculus in c: https://svn.origo.ethz.ch/pl-test-suite/c/lambda-calculus/
02:13:41 <Gracenotes> vixey: where does len 'come from'?
02:14:29 <vixey> 0 ~(loop)~> (+1) ~> (+1) ~> ... ~> len ~(back into loop)~> (+1) ~> ... ~> 11
02:20:47 <Gracenotes> vixey: I don't think my mind is understanding the syntax -- how len is both part of the second parameter of runState and part of the result of runState
02:22:31 <baaba> @src (~>)
02:22:31 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:22:39 <Gracenotes> vixey: how does that work out?
02:22:40 <vixey> > (x, (y, z)) = ("foo", (True, 'y')) in (x,y,z)
02:22:41 <lambdabot>   <no location info>: parse error on input `='
02:22:45 <vixey> > let (x, (y, z)) = ("foo", (True, 'y')) in (x,y,z)
02:22:47 <lambdabot>   ("foo",True,'y')
02:23:50 <Gracenotes> yes, that makes sense. But len is in two places at once :)
02:24:05 <vixey> > let (x, (y, z)) = ("foo", (True, 'y' : x)) in (x,y,z)
02:24:06 <lambdabot>   ("foo",True,"yfoo")
02:24:18 <vixey> > let (x, (y, z)) = ("foo", (True, 'y' : y)) in (x,y,z)
02:24:18 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Bool'
02:24:23 <vixey> > let (x, (y, z)) = ("foo", (True, 'y' : z)) in (x,y,z)
02:24:24 <lambdabot>   ("foo",True,"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy...
02:24:34 <adrian_> @djinn (a->b) -> (a,a) -> (b,b)
02:24:35 <lambdabot> f a (b, _) = (a b, a b)
02:24:46 <ski_> > let (foo,bar) = (0:bar,1:foo) in (take 10 foo,take 8 bar)
02:24:48 <lambdabot>   ([0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0])
02:24:56 <vixey> :o
02:25:00 <vixey> that shouldn't work!?
02:25:15 <vixey> I swear you have to use a ~ pattern for that tuple thing you just did
02:25:16 <ski_> ?
02:25:33 <ski_> `let'-bindings are lazy by default
02:25:51 <ski_> if you did a lambda, or a `case' you'd need `~'
02:25:51 <vixey> > let f (foo,bar) = f (0:bar,1:foo) in fix f
02:26:06 <lambdabot>   thread killed
02:26:08 <vixey> I don't understand
02:26:15 <vixey> why is let lazy but the others aren't?
02:26:16 <ski_> `(foo,bar)' is not `let'-bound
02:26:41 <ski_> > let Nothing = Just () in ()
02:26:42 <lambdabot>   ()
02:27:18 <ski_> > let x = 0; y = 5 / x in if x == 0 then -1 else y
02:27:20 <lambdabot>   -1.0
02:28:00 <ski_> (though i suppose that isn't a good example, since matching against a variable is lazy anyway)
02:28:15 <Gracenotes> hm, Haskell is much more lazy than I thought
02:28:26 <pumpkin> Gracenotes: lazier than a sloth!
02:28:42 <Gracenotes> I don't recall seeing ~ patterns, as you call them, in any tutorial/RWH
02:30:07 <adrian_> gracenote: I learned about them from the "performance" articles in the wiki
02:35:11 <Gracenotes> > (x, (y, z)) = (1, (2+x, 3+y)) in (x,y,z)
02:35:13 <lambdabot>   <no location info>: parse error on input `='
02:35:19 <Gracenotes> > let (x, (y, z)) = (1, (2+x, 3+y)) in (x,y,z)
02:35:21 <lambdabot>   (1,3,6)
02:35:26 <Gracenotes> o-o
02:35:35 <Gracenotes> > let (x, (y, z)) = (1, (2+y, 3+x)) in (x,y,z)
02:35:36 <lambdabot>   (1,* Exception: stack overflow
02:35:55 <Gracenotes> oh
02:36:05 <Gracenotes> > let (x, (y, z)) = (1, (2+z, 3+y)) in (x,y,z)
02:36:07 <lambdabot>   (1,* Exception: stack overflow
02:36:12 <Gracenotes> > let (x, (y, z)) = (1, (2+z, 3+x)) in (x,y,z)
02:36:13 <lambdabot>   (1,6,4)
02:36:44 <ski_> > fix $ let f ~(foo,bar) = f (0:bar,1:foo) in f
02:36:54 <lambdabot>   mueval: Prelude.read: no parse
02:38:18 <ski_> oh
02:38:55 <ski_> > join (***) (take 5) . fix $ let f ~(foo,bar) = (0:bar,1:foo) in f
02:38:56 <lambdabot>   ([0,1,0,1,0],[1,0,1,0,1])
02:39:19 <ski_> (there was a recursive call to `f' in the body, so the previous never gave any result)
02:39:34 <ski_> > join (***) (take 5) . fix $ \ ~(foo,bar) ->= (0:bar,1:foo)
02:39:35 <lambdabot>   <no location info>: parse error on input `->='
02:39:41 <ski_> > join (***) (take 5) . fix $ \ ~(foo,bar) -> (0:bar,1:foo)
02:39:42 <lambdabot>   ([0,1,0,1,0],[1,0,1,0,1])
02:39:49 <Gracenotes> is (~) an operator, then? or part of the language?
02:39:56 <ski_> part of the language
02:40:14 <ski_> it applies to patterns
02:40:21 <ski_> > join (***) (take 5) . fix $ \ (foo,bar) -> (0:bar,1:foo)
02:40:37 <lambdabot>   thread killed
02:40:56 <ski_> > join (***) (take 5) ([0..],[0,-1..])
02:40:58 <lambdabot>   ([0,1,2,3,4],[0,-1,-2,-3,-4])
02:41:35 <ski_> Gracenotes : like `@', it binds tighter than application, too
02:42:03 <Gracenotes> hm.
02:42:08 <pumpkin> wait, so what does ~ do?
02:42:37 <b_jonas> pumpkin: it causes the pattern to always match like how left hand sides of a let always match
02:43:02 <b_jonas> so if it later turns out to not match the data it's an error instead of falling to the next case branch
02:43:21 <b_jonas> also the data you match to isn't evaluated early
02:44:28 <ski_> pumpkin : when matching a value `v' against a pattern `~ p', the matching succeeds immediately .. later, if/when any variables bound by `p' are demanded, then `v' will actually be matched against `p'
02:44:44 <pumpkin> ah
02:44:51 <pumpkin> and when is it useful?
02:45:06 <pumpkin> in the last case of a pattern match, if you don't want to bother writing an error?
02:45:18 <ski_> > let foo b ~(Just x) = if b then x else 0 in foo False Nothing
02:45:20 <lambdabot>   0
02:45:25 <ski_> > let foo b ~(Just x) = if b then x else 0 in foo True Nothing
02:45:26 <lambdabot>   * Exception: /tmp/6648281257532163480:71:40-75: Irrefutable pattern failed ...
02:45:35 <ski_> > let foo' b (Just x) = if b then x else 0 in foo' False Nothing
02:45:36 <lambdabot>   * Exception: /tmp/4306631693473350960:71:40-75: Non-exhaustive patterns in ...
02:45:54 <pumpkin> ah
02:46:54 <Gracenotes> So then, what's the order of evaluation in let (r, (_, len)) = runState (loop list) (len,0)?
02:47:02 <ski_> pumpkin : it's sometimes useful when you want to match against a pattern, but "not yet" because the value to match it against doesn't exists until the function one's writing has "returned" some outer data constructors
02:47:08 <Gracenotes> it seems to be what's making the whole statement work
02:47:31 <nanothief> theres an example at http://www.haskell.org/tutorial/patterns.html#tut-lazy-patterns
02:49:12 <vixey> It's not the order things are "evaluated" in that is important
02:49:13 <ski_> Gracenotes : first `r' is demanded. that causes `runState (loop list) (len,0)' to be demanded. then when looking at any element in `r', `len' is demanded, which causes the intermediate lengths back to `0' to be demanded and computed
02:49:17 <ski_> et.c.
02:49:35 <vixey> it is the way that applications are threaded together
02:51:18 <adrian> @src (***)
02:51:18 <lambdabot> f *** g = first f >>> second g
02:51:26 <adrian> @src (>>>)
02:51:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:51:37 <ski_> @src (->) (>>>)
02:51:37 <lambdabot> f >>> g = g . f
02:51:47 <ski_> @src (->) first
02:51:47 <lambdabot> first f = f *** id
02:52:17 <pumpkin> that looks awfully circular :P
02:52:18 <ski_> something tells me at least one of these definitions is a default
02:52:23 <ski_> @src (->) (***)
02:52:23 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
02:52:31 <Gracenotes> vixey: I'd think the order in which they're evaluated is important. But the relative order, not the absolute order.
02:52:31 <pumpkin> ah
02:53:04 <Gracenotes> so not this happens, then that happens, etc., but rather this must happen before that happens.
02:53:27 <pumpkin> omg Lord Haskell
02:53:30 <Gracenotes> this is all rather interesting. and baffling.
02:53:39 <pumpkin> oh it's Haksell
02:53:54 <Haksell> wth
02:54:08 <Haksell> I'm god now?
02:54:21 * vixey praise Lord aHaksell
02:54:23 <ski_> Haksell : just `Lord'
02:54:33 <Haksell> aHa
02:54:42 <vixey> aHaaHaaHaaHa
02:54:57 <Haksell> Well I needed a nickname and thought of this
02:55:10 <ski_> (Haksell : i.e. the guardian of the bread)
02:55:39 <Haksell> Nah I'm not from Italy
02:56:10 * ski_ . o O ( Italy ? )
02:56:44 <vixey> what are the common uses of data constructors like data T = ... | Cn (M -> T) | ...
02:56:46 <vixey> ?
02:56:49 <Haksell> Their god of the puzza bread :P
02:56:58 <pumpkin> puzza means stink
02:57:11 <ski_> (Haksell : <http://en.wiktionary.org/wiki/lord#Etymology>)
02:57:36 <Haksell> Great! :D
02:57:52 <Haksell> And I was only thinking I did jsut switch the s and the k
02:58:15 <Gracenotes> heh, just when I think something's going to get evaluated, it turns out it's waiting for something else
02:58:23 <cizra> Haksell: "jsut"
02:58:35 <Haksell> ;)
03:01:19 <vixey> hrmfm
03:04:14 <vixey> someone said that data representation on it's won doesn't mean anything, only when you have got operations to work on it too
03:04:33 <vixey> I don't think that's exactly tru..e
03:06:30 <Gracenotes> @src runState
03:06:30 <lambdabot> Source not found. I feel much better now.
03:07:04 <cnwdup> gracenotes: It's encapsulated in the type.
03:07:11 <cnwdup> @src State
03:07:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:07:15 <cnwdup> Hum. ) :
03:07:35 <Gracenotes> it would be something like runState (State s) v = s v, anyway
03:07:49 <cnwdup> newtype State s a = State { runState :: (s -> (a, s)) }
03:07:53 <Gracenotes> oh, yes, record notation. of course
03:10:05 <ski_> (vixey : Representations of uncomputable and uncountable sets <http://math.andrej.com/2008/02/06/representations-of-uncomputable-and-uncountable-sets/> ?)
03:10:20 <vixey> ski_, just that
03:18:10 <cnwdup> parseConfig :: FilePath -> IO (Either ParseError ([(FName, Field)], [((GName, [String]), [FName])])) -- is such a type creepy or ok in some places? Any suggestions what would be better?
03:18:38 <vixey>  ([(FName, Field)], [((GName, [String]), [FName])])
03:18:48 <vixey> you can replace that with Form or something
03:18:53 <vixey> type Form = ([(all that
03:24:51 <BrokenClockwork> hey, I have the following problem: I want to concatenate 2 of my own algebraic datatypes
03:25:14 <BrokenClockwork> something like: f "XY" ++ f "Z"
03:25:44 <BrokenClockwork> and the result ist Var (Var X Y) Z
03:26:30 <BrokenClockwork> it's just, that I can't write two functions as result into another function which expects just one result, so I have to cocatenate them
03:26:58 <vixey> "XY" is a String
03:27:12 <BrokenClockwork> yes
03:27:21 <vixey> (++) = Var
03:28:48 <BrokenClockwork> hah, you get me into it
03:28:50 <BrokenClockwork> it works :)
04:03:19 <trygvis> if I want to iterate a list and at the same time know the index of the item I'm iteration, how would I do that?
04:03:44 <Lemmih> trygvis: zip [0..] ?
04:03:57 <trygvis> zip seems a bit overkill
04:04:03 <vixey> trygvis, lol
04:04:06 <hallongrottan> lol?
04:04:06 <BONUS> why
04:04:20 <trygvis> would be a zip + fold
04:05:50 <BONUS> why do you think a zip is "overkill"
04:06:38 <trygvis> lots of extra function calls with something that (in my head) could be a generator function to a foldr variant
04:06:48 <trygvis> (I'm already iterating the list with a fold)
04:07:06 <vixey> trygvis, fold is recursion btw, not iteration
04:07:34 <b_jonas> trygvis: it's not much of an overkill in a lazy language
04:07:52 <b_jonas> but you could of course write your own specialized version for zipping with [0..]
04:08:14 <BONUS> but the performance would likely be the same
04:08:28 <BONUS> what you're doing is pretty much premature optimization :)
04:08:42 <BONUS> and it's probably not likely to pose any sort of performance bottleneck
04:08:45 <vixey> is it really an optimization though?
04:08:56 <BONUS> probably not.
04:08:58 <vixey> I'd love to call it "premature non-optimization" but I'm not totally sure I can
04:09:21 <BONUS> the thing about premature optimization is that you many times don't even know if it's an optimization
04:09:30 <vixey> yes
04:09:30 <BONUS> until you get to profiling
04:09:33 <twb> http://hpaste.org/13363#a1
04:09:38 <twb> "Ambiguous type variable `p1' in the constraint:"
04:09:48 <twb> What does that error mean?
04:09:51 <vixey> but in this case, I'd suspect that compiler isn't going to comple away the tupling and untupling
04:13:18 <Lemmih> twb: Did you paste the right thing?
04:13:55 <twb> Argh, looks like M-x hpaste was "clever"
04:14:26 <twb> i.e. it decided where the end of the buffer was before prompting me, so when I ran M-x hpaste and waited for the compile to fail, it had already evaluted (max-point).
04:16:51 <twb> I have to specify that primitiveMatchers :: [(String, String, [String], String -> MatchFun Patch)], rather than Patchy p => [..., MatchFun p]
04:17:12 <elbar> @help
04:17:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:17:33 <elbar> @list
04:17:34 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:19:34 <Gracenotes> finally, I've written do { x <- get; put (x+1); return x } without any Monad or MonadState functions
04:19:48 <twb> http://hpaste.org/13363#a2 actual error
04:20:07 <twb> I mean, I know how to fix it, but I don't understand why GHC can't work things out on its own.
04:20:09 <Gracenotes> just State, runState, and a lot of lambdas...
04:20:39 <Lemmih> twb: It would be helpful to see the code as well.
04:20:42 <twb> Basically I have F x => (Foo, Bar x), and I'm doing fst on it (throwing away the uninstantiated part).
04:20:50 <twb> Lemmih: the code is at the top of the paste, of course.
04:22:32 <Lemmih> twb: And what are the types of 'help' and 'primitiveMatchers'?
04:22:50 <ski_> twb : the trouble is that the `String' parts of `primitiveMatchers' might depend on which instance `p' of `Patchy' you are using .. so you must specify which instance you want to use inside `helpOnMatchers'
04:23:08 <twb> ski_: I don't understand what you mean by "depend on"
04:23:14 <twb> ski_: surely a String is a String.
04:23:48 <twb> Oh, because there might be two instances of primitiveMatchers, one for Patchy Patch and one for Patchy Foo.
04:27:13 <ski_> yes, and `Patchy' might include a method like `frob :: Patchy p => p -> String', which `primitiveMatchers' might just call on an `undefined :: p'
04:28:47 <ski_> i suppose this might be a good use case for `(Foo,F x => Bar x)'
04:29:27 <twb> ski_: I don't understand what `(Foo,F x => Bar x)' entails, but if it lets me avoid a horrible long type signature, I'm all for it.
04:30:01 * Heffalump keeps running into use cases for F x => Bar x
04:30:27 <Heffalump> assuming the intention is for it to mean that "forall x, Bar x is true when F x is true"
04:30:49 <Heffalump> it would save making type classes like Show1, Show2, etc, for example
04:30:56 <twb> You mean I should change the type of primitiveMatchers from F x => (P, Q x) to (P, F x => Q x)?
04:32:18 * twb gets excitingly unintelligible type error after trying it.
04:36:40 <ski__> (.. apparently longer than this)
04:37:27 <twb> How do I go from [(x,[y])] -> [(x,y)] ?
04:37:32 <twb> > let xs = [(1,[2,3]),(4,[5,6])] in [(x, y) | y <- ys | (x,ys) <- xs]
04:37:34 <lambdabot>   Not in scope: `ys'
04:39:03 <twb> @hoogle [(x,[y])] -> [(x,y)]
04:39:04 <lambdabot> No results found
04:39:30 <ski_> Heffalump : `Bar x' was meant to be a type, theretwb : i don't know whether this extension would be implemented at all (or even considered)
04:39:33 * ski_ wonders how many minutes will pass before anything he's output is visible ..)
04:39:57 <cnwdup> @pl (\a -> (f a, a)
04:39:57 <lambdabot> (line 1, column 16):
04:39:57 <lambdabot> unexpected end of input
04:39:57 <lambdabot> expecting variable, "(", operator or ")"
04:39:59 <cnwdup> @pl (\a -> (f a, a))
04:39:59 <lambdabot> (,) =<< f
04:40:05 <ski__> > [(x,y) | (x,ys) <- xs , y <- ys] where xs = [(1,[2,3]),(4,[5,6])]
04:40:07 <lambdabot>   [(1,2),(1,3),(4,5),(4,6)]
04:40:11 <vixey> (x,[y]) -> [(x,y)]
04:40:19 <Japsu> > show [undefined]
04:40:21 <lambdabot>   "[* Exception: Prelude.undefined
04:40:37 <vixey> :t ((\(x,[y]) -> map ((,) x) y) =<<)
04:40:37 <lambdabot> forall t a. [(t, [[a]])] -> [(t, a)]
04:40:44 <vixey> :t ((\(x,y) -> map ((,) x) y) =<<)
04:40:45 <lambdabot> forall t a. [(t, [a])] -> [(t, a)]
04:41:31 <ski_> (twb : note the message above, which got mangled after the one to Heffalump)
04:44:50 <ski_>   Couldn't match expected type `Double' against inferred type `(Num Double) => Double'
04:44:53 <ski_> sounds fun
04:47:31 <ski_> (Heffalump : maybe you were thinking of stuff like `instance (forall a. Show a => Show (f a) => Show (Fix f)' ?)
04:49:16 <twb> http://hpaste.org/13363#a3 version I'm happy with
05:00:09 <vixey> @fabrar
05:00:09 <lambdabot> Unknown command, try @list
05:00:12 <vixey> @farbar
05:00:12 <lambdabot> A sock in time saves none.
05:00:13 <vixey> @farbar
05:00:13 <lambdabot> I'm going off tangentially.
05:00:15 <vixey> @farbar
05:00:15 <lambdabot> That took the starch out of my sails.
05:00:16 <vixey> @farbar
05:00:16 <lambdabot> Nobody's going to put his neck out on a limb.
05:00:21 <vixey> @farbar
05:00:21 <lambdabot> He's on the back of the pecking order.
05:00:25 <vixey> @farbar
05:00:25 <lambdabot> It's a virgin field pregnant with possibilities.
05:00:33 <vixey> @nixin
05:00:33 <lambdabot> Politics would be a helluva good business if it weren't for the goddamned people.
05:01:36 <jaj> @b52s
05:01:37 <lambdabot> Girl from Ipanema, she goes to Greenland
05:01:45 <vixey> @b52s
05:01:46 <lambdabot> Hot pants explosion at the factory!
05:01:49 <vixey> @b52s
05:01:49 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
05:02:05 <vixey> Cabbage crates coming over the briny!
05:02:11 <jaj> rock lobster!
05:02:21 <Beelsebob> @. unpl b52s
05:02:21 <lambdabot>  Parse error at "in" (column 19)
05:02:26 <Beelsebob> @. unpl b52s
05:02:27 <lambdabot> (Girl from Ipanema, she goes to Greenland)
05:02:29 <ski_> MORE OFF-TOPIC
05:02:31 <Beelsebob> :)
05:02:37 <vixey> @qeal
05:02:37 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing blew up
05:02:43 <vixey> @qeal
05:02:43 <lambdabot> i think it because mathematics damage you cpu
05:02:46 <vixey> @qeal
05:02:46 <lambdabot> T seems to be haskell, except with a decent interface at this point
05:02:50 <vixey> @qeal
05:02:50 <lambdabot> #haskell needs to take its meds
05:04:13 <vixey> > 100000000000*999999983333333333333*231
05:04:14 <lambdabot>   23099999614999999999992300000000000
05:06:12 <tibbe> are there any papers on two-level monads out there?
05:07:19 <ski_> (`two-level' how ?)
05:07:33 <ttt--_> @. kind type 3
05:07:35 <lambdabot> *
05:07:37 <ttt--_> :)
05:07:40 <arjanb> do you mean monad transformers?
05:07:45 <vixey> @@ *
05:07:45 <lambdabot>  *
05:08:49 <ttt--_> @. id id 3
05:08:50 <lambdabot>   3
05:08:54 <tibbe> arjanb: nope
05:09:02 <vixey> @id ofo
05:09:03 <lambdabot>  ofo
05:09:39 <vixey> @yow
05:09:39 <lambdabot> Where does it go when you flush?
05:09:40 <vixey> @yow
05:09:40 <lambdabot> Are the STEWED PRUNES still in the HAIR DRYER?
05:09:43 <vixey> @yow
05:09:43 <lambdabot> I'm encased in the lining of a pure pork sausage!!
05:09:50 <ski_> (tibbe : or do you mean something like `class MonadMonad t where returnT :: Monad m => m a -> t m a; bindT :: (Monad m,Monad n) => t m a -> (forall a. m a -> t n a) -> t n a' ?)
05:09:54 <ttt--_> @. type yow
05:09:55 <lambdabot> Not in scope: data constructor `WHOA'
05:09:55 <lambdabot> Not in scope: data constructor `Ken'
05:09:55 <lambdabot> Not in scope: data constructor `Barbie'
05:10:00 <vixey> lol!
05:10:12 <tibbe> ski_: I heard the concept mentioned and I want to familiarize myself with it
05:10:40 <vixey> @@ @run (map toLower . filter isAlpha) (@ show yow)
05:10:40 <lambdabot> Plugin `compose' failed with: Unknown command: ""
05:10:42 <tibbe> ski_: googling wasn't very useful
05:10:48 <vixey> @@ (map toLower . filter isAlpha) (@ show yow)
05:10:48 <lambdabot> Plugin `compose' failed with: Unknown command: ""
05:10:58 <vixey> @@ (map toLower . filter isAlpha) (@show @yow)
05:10:59 <lambdabot>  (map toLower . filter isAlpha) "Will it improve my CASH FLOW?\n"
05:11:05 <vixey> @@ @run (map toLower . filter isAlpha) (@show @yow)
05:11:06 <lambdabot>   "itsokayimanintellectualtoo"
05:11:22 * ski_ isn't sure about what concept `two-level monads' names ..
05:11:55 <elbar> @bf +++[-]
05:11:55 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
05:12:25 <elbar> bf != brainfuck?
05:13:03 <ski_> (another wild guess is that you want something like `class Monad2 m where return2 :: a -> m x x a; bind2 :: m x y a -> (a -> m y z b) -> m x z b')
05:13:08 <ski_> @help bf
05:13:08 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
05:13:24 <ski_> apparently it's `bainf*ck', whatever that is
05:13:42 <vixey> haha
05:14:54 * vixey TwoLevelMonad m where return :: a -> m (m a); (>>=) :: m (m a) -> (m a -> m b) -> m (m b)
05:17:07 <tibbe> ski_: have you seen Oleg's Iteratee code? The IterateeGM monad there is similar in spirit
05:17:41 <tibbe> ski_: You end up with an operator >>== to run the "outer" monad layer (but it's not a MonadTrans)
05:18:35 <ski_> tibbe : hm, link ?
05:19:06 <tibbe> ski_: http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf
05:19:23 <tibbe> ski_: relevant code: http://okmij.org/ftp/Haskell/Iteratee/IterateeM.hs
05:19:34 <ski_> tack
05:19:40 <tibbe> valkommen
05:19:47 <vixey> tack ? sounds like taak
05:20:10 <trygvis> takk!
05:20:23 <hallongrottan> wat
05:20:58 <ski_> (hallongrottan : in what language is that the word for `thanks' ?)
05:21:10 <kohwj> what's the best distro for haskell development, in terms of its support for libraries, etc?
05:21:20 <hallongrottan> ski_: =/ none i guess
05:21:52 <stu8ball> All the Scandinavian languages have 'Takk'.
05:21:54 <hallongrottan> as swedish is already done i think i can contribute with "danke" :)
05:22:00 <ski_> (kohwj : .. maybe GHC ?)
05:22:10 <hallongrottan> stu8ball: finland doesnt
05:22:24 <tibbe> kohwj: if you use Cabal (and the cabal-install tool) any linux or mac os x
05:22:26 <stu8ball> Finland isn't in Scandinavia and it isn't a Scandinavian language.
05:22:33 <hallongrottan> öö
05:22:41 <tibbe> kohwj: cabal is similar to e.g. ruby gems
05:23:08 <tibbe> kohwj: if you want to use only the built-in package manager (e.g. apt) then ubuntu has a decent collection
05:23:09 <hallongrottan> stu8ball: yes it is, but its not a scandinavian language
05:23:21 <hallongrottan> i think thanks in finnish is "kitos"
05:23:25 <kohwj> tibbe: icic. i'm just frustrated at gentoo which broke cabal install.
05:23:27 <tibbe> kohwj: but I wouldn't pick my distro based on availability of haskell packages :)
05:23:35 <tibbe> kohwj: ic
05:23:44 <tibbe> kohwj: why did it break?
05:23:51 <stu8ball> Not really, AFAIK Finland is a "Nordic Country", and the set of Nordic Countries is a superset of the set of Scandinavian countries.
05:23:52 <kohwj> cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an emptyuser package database then this is probably due to ghc bug #2201. Theworkaround is to register at least one package in the user package db.
05:24:17 <tibbe> kohwj: so which version of ghc do you use?
05:24:31 <kohwj> Glasgow Haskell Compiler, Version 6.10.1, for Haskell 98, stage 2 booted by GHC version 6.10.1
05:24:40 <tibbe> kohwj: ok
05:24:52 <tibbe> kohwj: put if you type ghc-pkg list that works?
05:25:11 <kohwj> tibbe: i tried downloading a package and doing a "ghc-pkg register blah.cabal" but that didn't work
05:25:14 <hallongrottan> stu8ball: look this up i will as you made me feel very unsure
05:25:15 <kohwj> tibbe: trying...
05:25:33 <stu8ball> hallongrottan: It's hardly important anyway. :p
05:25:36 <tibbe> kohwj: oh ghc-pkg register doesn't understand cabal
05:25:46 <hallongrottan> stu8ball: :p
05:25:55 <ski_> (tibbe : hm .. looks somewhat related to `MonadMonad' above ..)
05:26:05 <tibbe> kohwj: it's the other way around, cabal install tells ghc where it installed a package by calling ghc-pkg register
05:26:14 <kohwj> tibbe: http://hpaste.org/13364
05:26:15 <tibbe> ski_: ok
05:26:32 <twb> So I have a list of strings ["foo", "bar", ...].
05:26:43 <twb> And I have a variable that is a list of strings.
05:27:20 <twb> I want to insert the latter in the middle of the former.  Is there anything like Lisp's unquote-splicing (,@)?
05:27:22 <hallongrottan> stu8ball: it seems that you are completely right!
05:27:29 <vixey> twb, no
05:27:45 <tibbe> kohwj: hmm
05:27:46 <twb> i.e. so I don't have to say ["foo",...] ++ x ++ ["bar",...]
05:27:50 <twb> vixey: oh well
05:29:25 <tibbe> kohwj: I'm not exactly sure what ghc-pkg register takes as input
05:29:39 <kohwj> tibbe: hmm..
05:29:41 <twb> ghc-pkg register --help ?
05:30:16 <tibbe> twb: the help mentions a "Register the package using the specified installed package
05:30:16 <tibbe>     description. The syntax for the latter is given in the ghc-pkg
05:30:16 <tibbe>     documentation."
05:30:25 <twb> Bleh
05:32:12 * ski_ sometimes uses `concat' ..
05:32:15 <ski_> > concat ["(",x," ** ",y,")"]  where  (x,y) = (2,3)
05:32:16 <lambdabot>       No instance for (Num [Char])
05:32:16 <lambdabot>        arising from the literal `2' at <in...
05:32:28 <ski_> er, preferrably with `show', too
05:32:36 <kohwj> tibbe: maybe my version of ghc-pkg is outdated
05:32:36 <ski_> > concat ["(",show x," ** ",show y,")"]  where  (x,y) = (2,3)
05:32:38 <lambdabot>   "(2 ** 3)"
05:32:50 <tibbe> kohwj: could be
05:32:54 <kohwj> tibbe: GHC package manager version 6.10.1
05:33:01 <vixey> I had defined ^ in a typeclass so you can go  "("^x^" **"^y^")"
05:33:31 <tibbe> kohwj: try echo "[]" > $HOME/.ghc/<whatever_version>/package.conf if you don't already have a package.conf file
05:33:43 <tibbe> kohwj: backup the file first
05:34:17 <tibbe> kohwj: but that particular problems should only appear in 6.9 so I don't think this is it
05:34:29 <tibbe> kohwj: old Cabal?
05:36:00 <kohwj> tibbe: that didn't work.. cabal-install v 0.5.2, using version 1.4.0.2 of the Cabal library
05:36:28 <tibbe> kohwj: that's too old I believe, get the latest version from hackage
05:36:44 <tibbe> $ cabal -V
05:36:45 <tibbe> cabal-install version 0.6.0
05:36:45 <tibbe> using version 1.6.0.1 of the Cabal library
05:37:14 <tibbe> kohwj: I thought a newer version of Cabal shipped with ghc 6.10
05:37:47 <tibbe> kohwj: there's a nifty bootstrap.sh script that you get if you download cabal-install from hackage, just run it and it should install the dependencies automatically
05:39:05 <tibbe> kohwj: don't forget to add $HOME/.cabal/bin after you're done
05:39:11 <kohwj> tibbe: ah.. i see it now. when i tried to install cabal-install, the old cabal-install was used by gentoo to update dev-haskell/network and, which didn't work because it was old
05:39:35 <twb> I am too tired.
05:39:43 <twb> I read "trystring key" as "tryst ring"
05:40:44 <steshaw> > map (+1) [1..10]
05:40:45 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
05:41:22 <steshaw> unpl id
05:41:29 <steshaw> @unpl id
05:41:29 <lambdabot> (\ a -> a)
05:41:48 <vixey> @unpl ap
05:41:48 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
05:41:56 <vixey> @unpl ap flip id const
05:41:56 <lambdabot> (\ h i j -> i >>= \ g -> j >>= \ h -> return (h g h)) (\ k -> k) (\ a b c -> a c b) (\ d -> d) (\ e _ -> e)
05:41:58 <vixey> @unpl ap flip id const (.)
05:41:58 <lambdabot> ((\ a b c -> a c b) >>= \ j -> (\ d -> d) >>= \ i -> return (j i)) (\ e _ -> e) (\ f g h -> f (g h))
05:42:07 <vixey> @unpl (((ap .) (.) .) flip .) id const (.)
05:42:08 <lambdabot> ((\ c d -> (\ g h -> h) (c d)) >>= \ p -> (\ l m n -> l (m n)) >>= \ o -> return (p o))
05:43:49 <steshaw> @pl map snd (filter isPer db) where isPer (p,b) = (p == per)
05:43:49 <lambdabot> (line 1, column 45):
05:43:49 <lambdabot> unexpected "="
05:43:51 <lambdabot> expecting variable, "(", operator or end of input
05:45:39 <tibbe> kohwj: :)
05:46:02 <EvilTerran>  @pl can't deal with definitions like that, unfortunately
05:46:07 <tibbe> kohwj: I've compiled GHC myself and installed it under $HOME and use cabal-install for all haskell package management and that works great for me
05:46:11 <tibbe> kohwj: i.e. just works
05:46:23 <EvilTerran> @pl map snd (filter (\(p,b) -> p == per) db)
05:46:24 <lambdabot> map snd (filter ((per ==) . fst) db)
05:47:19 <steshaw> EvilTerran: thanks :)
05:47:27 <tibbe> kohwj: have you talked with the people in #gentoo-haskell ? they set up the layman overlay for haskell packages on gentoo etc
05:47:46 <kohwj> tibbe: they did't say a word for 12 hours
05:47:53 <tibbe> kohwj: ah ok
05:52:09 <ski_> > evalCont . liftM (200 +) . reset $ do m <- induct [3,4,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
05:52:11 <lambdabot>   260
05:52:25 <vixey> :t induct
05:52:26 <lambdabot> forall a r. [a] -> Cont r (Maybe (a, r))
05:53:05 <ski_> > evalCont . liftM (200 +) $ do m <- induct [3,4,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
05:53:07 <lambdabot>   15260
05:53:10 <vixey>  > evalCont . reset $ do m <- induct [3,4,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
05:53:19 <vixey> > evalCont . reset $ do m <- induct [3,4,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
05:53:20 <lambdabot>   60
05:53:23 <ski_> > evalCont . liftM (200 +) . reset $ do m <- induct [3,x,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
05:53:25 <lambdabot>   200 + 3 * (x * (5 * 1))
05:54:01 <vixey> > evalCont . liftM (200 +) $ do m <- induct [3,x,5]; return $ case m of Nothing -> 1; Just (f,p) -> f * p
05:54:01 <lambdabot>   200 + 3 * (200 + x * (200 + 5 * (200 + 1)))
05:57:11 <vixey> :t induct
05:57:12 <lambdabot> forall a r. [a] -> Cont r (Maybe (a, r))
05:57:33 <vixey> :t runCont
05:57:34 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
05:57:36 <vixey> :t Cont
05:57:37 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
05:58:04 <vixey> :t let f [] = return Nothing ; f (x:xs) = xs >> Cont (\ar -> ar (Just x)) in f
05:58:05 <lambdabot>     Couldn't match expected type `[b]'
05:58:05 <lambdabot>            against inferred type `Cont r (Maybe t)'
05:58:05 <lambdabot>     In the second argument of `(>>)', namely
05:58:10 <vixey> :t let f [] = return Nothing ; f (x:xs) = f xs >> Cont (\ar -> ar (Just x)) in f
05:58:11 <lambdabot> forall a r. [a] -> Cont r (Maybe a)
05:58:22 <vixey> :t let f [] = return Nothing ; f (x:xs) = f xs >>= \r -> Cont (\ar -> ar (Just x, r)) in f
05:58:23 <lambdabot>     Couldn't match expected type `Maybe a'
05:58:23 <lambdabot>            against inferred type `(Maybe t, Maybe a)'
05:58:23 <lambdabot>       Expected type: Cont r (Maybe a)
06:03:29 <kohwj> tibbe: got it!
06:03:39 <tibbe> kohwj: great! :)
06:04:02 <tibbe> kohwj: what did you end up doing?
06:04:13 <ski_> @type let f [] = return Nothing ; f (x:xs) = f xs >>= \r -> Cont (\ar -> ar (Just (x, r))) in f
06:04:14 <lambdabot>     Occurs check: cannot construct the infinite type: a = (t, Maybe a)
06:04:14 <lambdabot>       Expected type: Cont r (Maybe a)
06:04:14 <lambdabot>       Inferred type: Cont r (Maybe (t, Maybe a))
06:04:17 <kohwj> manually installing from hackage.
06:04:27 <ski_> @type let f [] = return Nothing ; f (x:xs) = f xs >>= \r -> Cont (\ar -> ar (do (y,z) <- r; Just (x, y))) in f
06:04:28 <lambdabot> forall t r. [t] -> Cont r (Maybe (t, t))
06:04:31 <ski_> @type let f [] = return Nothing ; f (x:xs) = f xs >>= \r -> Cont (\ar -> ar (do (y,z) <- r; Just (x, z))) in f
06:04:32 <lambdabot> forall t r t1. [t] -> Cont r (Maybe (t, t1))
06:04:40 <kohwj> tibbe: now i'll just add it to my path
06:07:16 <tibbe> kohwj: ok
06:07:24 <kohwj> thanks tibbe!
06:07:31 <tibbe> kohwj: no problem
06:08:30 <tibbe> ski_: the "cannot construct infinite type" must be the most annoying type error you can get, it's so unhelpful
06:08:56 <vixey> tibbe, you'd rather what happens?
06:09:19 <tibbe> vixey: dunno :/ It's just not very helpful for debugging
06:10:02 <tibbe> vixey: for example, if you defined to Monad instances that depend on each other and get this error message you know that somewhere, in *any* of the cases you defined, something is wrong
06:10:13 <ski_>   Occurs check: cannot construct the infinite type: b = (Num b) => b
06:10:15 <tibbe> vixey: an example would be useful
06:10:51 <tibbe> vixey: I guess that's the best result the constraint solving can provide but it's still not very helpful
06:11:00 <gio123> ski_:hi
06:11:12 <ski_> tibbe : how about that error example ?
06:11:24 <tibbe> ski_: perhaps if a majority vote heuristic would work
06:11:47 <tibbe> ski_: if it can unify 5 out of 6 of your definitions the 6th is likely to be wrong
06:11:48 <Heffalump> ski_: that's a very weird error
06:11:51 <Heffalump> what does it mean?
06:11:55 <ski_> Heffalump : indeed :)
06:11:59 <ski_> i have no idea
06:12:36 <ski_> Heffalump : it occured when i wrote a signature `f :: Int -> (Int,Num a => a)'
06:12:42 <tibbe> ski_: so it could pick the 6th case and any of the other 5 and say, for example these two don't match
06:13:12 <Heffalump> that's also quite a weird signature
06:13:38 <Heffalump> is it interpreted as exists a . Num a => a ?
06:13:46 <Heffalump> but that'd be quite odd
06:13:59 <Heffalump> hi kowey
06:14:12 <kowey> hi Heffalump, hey #haskellers
06:14:12 <lambdabot> kowey: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:15:01 <kowey> so... at the risk of asking a silly question, what is a good way to count things? http://hpaste.org/13365
06:15:04 <ski_> (Heffalump : also i got an alternative weird error : Couldn't match expected type `Double' against inferred type `(Num Double) => Double')
06:15:05 <gio123> ski_: are you there?
06:15:21 <kowey> pick your favourite definition of good, i.e. readable, simple, efficient, nice trade-off management, etc
06:15:47 <Heffalump> they both should be the same time complexity
06:16:15 <kowey> i'm also soliciting alternative solutions
06:16:30 <kowey> (although in that case, I should pick the simpler of the two)
06:16:33 <Heffalump> zip [1..] looks wrong though
06:16:40 <Heffalump> zip (repeat 1) surely
06:16:49 <kohwj> yikes- cabal taking up 85% of my memory when resolving dependencies
06:17:07 <Heffalump> kohwj: buy more memory ;-)
06:17:09 <kowey> whoops! yep, that was repeat 1 before
06:17:17 <ski_> (Heffalump : i was intending one of `f :: forall a. Int -> (Int,Num a => a)',`f :: Int -> (Int,forall a. Num a => a)' .. not sure which)
06:17:34 <Heffalump> ski_: those are isomorphic, though
06:17:38 <kohwj> Heffalump: that's comforting :P
06:18:57 <ski_> Heffalump : the use case was that `fst (f 0)' would be ambiguous using `f :: Num a => Int -> (Int,a)'
06:19:04 <Heffalump> ah, right
06:19:24 <ski_> (Heffalump : twb's example was slightly more complicated, but that's more or less it)
06:19:42 <Heffalump> I thought ghc floats foralls anyway. Perhaps not.
06:20:22 <asgaroth_> Is there already a function to generate all choices to take k elements out of n choices(order is relevant), or do I have to manually use list comprehensions and such?
06:20:50 * kowey adds the first definition of count to his odds-and-ends.hs file
06:21:15 <ski_> (Heffalump : also i think this indicates that differentiating between `=>' and `*>' is good)
06:21:24 <Heffalump> what's *> then?
06:22:31 <ski_> what one would typically use in `[exists x. Fooable x *> Blah x]'
06:22:57 <Heffalump> asgaroth_: I think you need to write it
06:23:04 <ski_> i.e., in the dictionary implementation, `Fooable x *> Blah x' would translate to `(FooableDict x,Blah x)'
06:23:27 <Heffalump> do you mean FooableDict x -> Blah x?
06:23:44 <Heffalump> oh, no
06:23:54 <Heffalump> ok, I don't really see the difference between *> and =>
06:24:38 <ski_> `Fooable x *> Blah x' would consist of a chosen dictionary of `Fooable x', and a value of `Blah x'
06:25:01 <ski_> while `Fooable x => Blah x' would be code that, *given* a chosen dictionary of `Fooable x', would produce a value of `Blah x'
06:25:14 <Heffalump> but doesn't exists x . Fooable x => Blah x mean what you said for *> ?
06:26:07 <ski_> `exists x . Fooable x => Blah x' would be a package that, given a dictionary for `Fooable x', for the hidden type `x', would specialize to a value of type `Blah x'
06:26:18 <ski_> of course, this is useless in this case
06:26:24 <Heffalump> it seems useless in general
06:26:38 <Heffalump> how can anyone provide a dictionary for a hidden type?
06:26:45 <ski_> `exists x. (Bleh x,Fooable x => Blah x)' might be useful
06:27:02 <ski_> if `Bleh x' sometimes contain a dictionary for `Fooable x'
06:27:08 <ski_>   data Bleh
06:27:09 <Heffalump> ah, right
06:27:10 <ski_>     where
06:27:11 <Heffalump> yeah
06:27:24 <ski_>     Barf :: Fooable x => ... -> Bleh x
06:27:26 <ski_>     ...
06:30:06 <tibbe> when did ghci start echoing what I'm typing?
06:30:13 <tibbe> I can't remember it doing that before
06:30:31 <vixey> I think it always did that
06:33:05 <Heffalump> mine doesn't echo what tibbe types, if that helps
06:33:27 <mercury^> parse error on input `{-# SCC'
06:33:29 <mercury^> :(
06:36:08 <Heffalump> hi
06:37:06 <kohwj> gah.. cabal froze my system when it ate all my swap and memory
06:37:27 <tibbe> vixey: hmm
06:37:35 <Heffalump> kohwj: blame dcoutts
06:41:00 <Senger> hello, short question: i want to write a function which gets a string (or a list of strings) if it contains at last of one word i want to call otherfunction1. but if it only contains of "numbers" and mathematical signsg (+,-,*,/) i want to call otherfunction2. so, if youser writes "hello you" otherfunction1, if he writes "2 + 2" otherfunction2 should be called. how can i check for the two cases?
06:41:50 <eipi-1> hello, is gtk2hs supposed to work with ghc 6.10.1? I tried compiling the sources from darc to no avail
06:42:19 <vixey> Senger, what about "2 + + 3 *" ?
06:42:50 <Senger> would be nice, but isn't required
06:43:39 <vixey> I mean which case should it do
06:43:41 <tibbe> > all (map (`elem` ['+', '-', ' ']) "+-")
06:43:42 <lambdabot>   Couldn't match expected type `a -> Bool'
06:43:47 <tibbe> :t all
06:43:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:43:55 <ski_> > ['+', '-', ' ']
06:43:57 <lambdabot>   "+- "
06:44:06 <tibbe> right :)
06:44:25 <tibbe> > map (`elem` ['+', '-', ' ']) "+-"
06:44:26 <lambdabot>   [True,True]
06:44:31 <tibbe> :t and
06:44:32 <lambdabot> [Bool] -> Bool
06:44:35 <tibbe> ah
06:44:54 <Beelsebob> > all (`elem` "+- ") "+-"
06:44:54 <vixey> > all (`elem` "+- ") "+- "
06:44:56 <lambdabot>   True
06:44:56 <lambdabot>   True
06:45:00 <tibbe> > and (map (`elem` " -+*/1234567890") "1 + 2")
06:45:01 <lambdabot>   True
06:45:37 <tibbe> Senger: so isArithemetic = and . map (`elem` " -+*/1234567890")
06:45:45 <Beelsebob> all == and . map
06:45:54 <tibbe> Beelsebob: even better!
06:45:59 <Beelsebob> any == or . map
06:46:11 <vixey> liftA2 (||) isDigit isOperand
06:46:28 <Beelsebob> isDigit <^(||)^> isOperand
06:46:48 <vixey> lol
06:46:51 <mercury^> http://hpaste.org/13366
06:46:51 <vixey> with the pigs again
06:46:55 * tibbe loves the auto-refactor function of #haskell
06:47:01 <Beelsebob> brb
06:48:02 <Senger> great, thanks
06:48:32 <centrinia> and == all id
06:48:38 <centrinia> or == any id
06:48:55 <Beelsebob> that too
06:49:29 <centrinia> Does that mean that { and == (and . map) id } ?
06:49:43 <Beelsebob> it would do if my defs were right
06:49:51 <vixey> :t (?f . map) id
06:49:52 <lambdabot> forall c a. (?f::([a] -> [a]) -> c) => c
06:50:41 <mercury^> Does anyone have a clue why concat allocates a lot of space when I just read the elements of q one by one and discard them? http://hpaste.org/13366
06:50:59 <centrinia> Does the ?f solver allow for two or more variables?
06:51:05 <centrinia> :t (?f . ?f) ?f
06:51:06 <lambdabot> Top level:
06:51:06 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
06:51:06 <lambdabot>       Expected type: a -> a
06:51:21 <int-e> :t (?a . ?b) ?c
06:51:23 <lambdabot> forall b c a. (?c::a, ?b::a -> b, ?a::b -> c) => c
06:51:30 <centrinia> Ah.
06:52:06 <Heffalump> mercury^: presumably you're building up some huge thunk, but I can't spot what it would be obviously
06:52:06 <int-e> it's an extension that ghc provides, http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
06:52:10 <Heffalump> Have you tried a heap profile?
06:52:45 <mercury^> Heffalump: yes, that just confirms that concat allocates a lot of space.
06:53:04 <Heffalump> even with your SCC annotations deeper inside?
06:53:41 <mercury^> yes
06:55:26 <mercury^> The program should run in constant space, I have no idea what is going on...
06:55:51 <int-e> mercury^: what is "a lot"? How are you testing it?
06:56:53 <int-e> main = print q
06:57:12 <mercury^> int-e: a lot means that it consumed more than 1 GB before I aborted it.
06:57:16 <int-e> oops. if I just add that line, compile and run the program, it seems to run in constant memory.
06:57:27 <mercury^> Hmm.
06:57:52 <int-e> if I load it in ghci and print q, it consumes a lot of memory, but that's because q isn't garbage collected in that case.
06:58:08 <mercury^> http://hpaste.org/13366#a1
06:58:32 <mercury^> I don't see why I would prevent q from being collected.
06:58:39 <mercury^> s/I/i/
06:58:40 <mercury^> :>
06:58:57 <int-e> yes. i builds huge thunks
06:59:22 <int-e> try to make i strict, i (h:t) s p@(x,y) dp@(dx,dy)
07:00:51 <int-e> err, i (h:t) s !p@(!x,!y) !dp@(!dx,!dy) = ...  with {-# LANGUAGE BangPatterns #-}
07:01:22 * ski_ read `LANGUAGE' as `LAGRANGE', first ..
07:01:24 <asgaroth_> What's the preferred way for using Data.Map? Importing it as qualified and always using the qualifier or jsut import Data.Map as M and List as L and qualify only where it's ambiguous?
07:03:56 <mercury^> int-e: that worked, thanks.
07:04:02 <mercury^> First time I needed strictness annotations.
07:04:41 <int-e> now you just need to wait a million seconds for the program to finish ;)
07:04:58 <mercury^> yeah :P
07:06:56 <int-e> (the problem can be solved instantaneously)
07:07:12 <mercury^> I know.
07:07:14 <EvilTerran> asgaroth_, i think the normal convention is to "import qualified Data.Map as M; import Data.Map (Map, (!), {- anything else you want a lot that's unambiguous -})"
07:07:26 <mercury^> Well, it is not constant in the number of steps.
07:07:31 <asgaroth_> EvilTerran: Ok, thanks.
07:07:37 <mercury^> (is it?)
07:07:41 <EvilTerran> asgaroth_, that way, it's documented which names came from which file
07:07:57 <EvilTerran> either at the point of use, with the "M.", or at the point of import, as it's explicitly imported
07:08:01 <mercury^> int-e: I think one can use the selfsimilarity to speed it up a lot.
07:08:33 <mercury^> Should be logarithmic.
07:08:36 <int-e> mercury^: yup.
07:12:44 <Polarina> Hello
07:12:50 <vixey> hi
07:12:51 <Grob> hey I'm trying to tell Polarina about Haskell
07:12:58 <Grob> she was asking if it's like weirder than lisp
07:13:05 <Grob> <Polarina> Just give me a code showing conditionals, assignments, loops (around 200 lines). Let me look at it for 10 minutes, and I've learnt Haskell.
07:13:05 <Grob> <Grob> nope
07:13:14 <Grob> <Grob> you can't change variables
07:13:14 <Grob> <Grob> and there are no such thing as loops
07:13:18 <EvilTerran> assignments? loops?
07:13:20 <Polarina> Ok, ok.
07:13:26 <vixey> hehe
07:13:34 <Grob> can you guys please explain ?
07:13:37 <vixey> I guess Polarina saw all these ruby/python/java/C# crap
07:13:38 <Polarina> I still want to take a look at the code.
07:13:54 <Olathe> http://hpaste.org has a lot of code.
07:13:56 <vixey> Polarina, it is a lot different
07:14:04 <vixey> hpaste has got a lot of broken bad code.........
07:14:08 <Polarina> I figured so much.
07:14:10 <vixey> not a good place to look..
07:14:19 <opqdonut> http://en.wikipedia.org/wiki/Haskell_(programming_language) has some almost sensible code
07:14:20 <vixey> @go LogicT Haskell
07:14:22 <Grob> vixey you have some insane code
07:14:27 <Grob> show us your insane code
07:14:30 <vixey> Grob, no but LogicT is really cool
07:14:32 <lambdabot> http://okmij.org/ftp/Computation/monads.html
07:14:32 <lambdabot> Title: Monads
07:14:37 <vixey> ^ it's in there
07:14:43 <EvilTerran> oleg's code is insane, too
07:14:47 <vixey> check the PDF which has got code as well as comments
07:14:55 <Grob> nono hpaste it vixey
07:14:55 <opqdonut> loeb stuff is almost quite mindblowing
07:14:59 <Olathe> Polarina: Here's one thing I made recently: http://hpaste.org/13114#a4
07:15:26 <Polarina> Olathe: Thank you.
07:16:16 <Polarina> Even assembly is simpler for me to understand than Haskell...
07:16:33 <Grob> that's ok, you gotta break your brain
07:17:50 <Polarina> This is crazy.
07:17:52 <opqdonut> Olathe: ah, neat
07:18:06 <schme_> evenin'
07:18:53 <Grob> Polarina, you can do stuff in Haskell in 10 lines of code that takes other langs 100 loc
07:19:20 <vixey> Haskell is only 10x better ? :(
07:19:25 <Polarina> lol
07:20:20 <centrinia> I thought a greater lower bound on lines of code makes for a better programming language.
07:20:20 <Polarina> I know of a language where I can do everything in one line.
07:20:23 <opqdonut> line counts and complicated code are cheap tricks
07:20:37 <opqdonut> nobody understands c++ templates when they first see them
07:21:04 <Polarina> nobody understands haskell when they first see it
07:21:08 <opqdonut> the real point is purity and strong typing, Polarina: go read a tutorial
07:21:11 <schme_> loc count is silly, indeed.
07:21:22 <centrinia> C++ templates are the most important part of C++.
07:22:05 <Grob> the most important part of C++ is no garbage collector
07:22:08 <Polarina> opqdonut: I've never had issues with types mixing up before.
07:22:09 <Grob> that's what it's useful for
07:22:29 <Raynes> The most important part of C++ is the second + imo.
07:22:54 <Polarina> C++ would be more optimized if they named it
07:22:57 <Polarina> ++C
07:23:19 <opqdonut> Polarina: one can for example implement typed matrix arithmetic in hsakell
07:23:26 <opqdonut> the type system keeps track of the matrix dimensions
07:23:28 <Eelis> Polarina: are you another convert-to-be that i can chalk up on geordi's list of successfully subverted people? ;)
07:23:31 <opqdonut> with _no_ runtime checks
07:23:38 <Raynes> It would be easier to understand C++ is they had just named it Garbage++
07:23:44 <Polarina> Eelis: Haha.
07:23:46 <Grob> GC--
07:23:54 <Olathe> C++--
07:24:03 <Olathe> @karma C++
07:24:03 <lambdabot> C++ has a karma of -2
07:24:04 <Raynes> Grob: Clever.
07:24:06 <Grob> GC--,Compatibility++
07:24:08 <Grob> that's it
07:24:11 <Olathe> @karma c
07:24:12 <lambdabot> c has a karma of 0
07:24:20 <Grob> everything else is crap in the language
07:24:20 <Polarina> C++
07:24:22 <Polarina> @karma C
07:24:23 <lambdabot> C has a karma of 0
07:24:26 <Olathe> Heheh
07:24:27 <Polarina> Aww..
07:24:30 <Olathe> c--
07:24:31 <centrinia> @karma LISP
07:24:31 <lambdabot> LISP has a karma of 0
07:24:33 <Olathe> @karma c
07:24:34 <lambdabot> c has a karma of 0
07:24:43 <trygvis> @karma Haskell
07:24:43 <lambdabot> Haskell has a karma of 45
07:24:44 <centrinia> @karma Java
07:24:44 <lambdabot> Java has a karma of -3
07:24:50 <Olathe> java--
07:24:53 <centrinia> Yay.
07:24:54 <trygvis> O.o
07:24:57 <Grob> @karma Records
07:24:57 <lambdabot> Records has a karma of 0
07:25:01 <Grob> records--
07:25:06 <trygvis> @karma lambdabot
07:25:07 <lambdabot> lambdabot has a karma of 2
07:25:08 <trygvis> @karma erlang
07:25:08 <lambdabot> erlang has a karma of 0
07:25:11 <Olathe> @karma xs
07:25:12 <lambdabot> xs has a karma of 0
07:25:14 <Polarina> @karma python
07:25:14 <lambdabot> python has a karma of -3
07:25:21 <opqdonut> please, the spam
07:25:21 <trygvis> @karmas
07:25:22 <lambdabot> Maybe you meant: karma karma+ karma-
07:25:24 <centrinia> @karma C#
07:25:24 <lambdabot> C# has a karma of 0
07:25:27 <Raynes> @karma recursion
07:25:27 <lambdabot> recursion has a karma of 0
07:27:27 <centrinia> Olathe, there is an easier way to compute the n-th lexigraphical permutation of unique symbols than computing n lexigraphical permutations beginning at the identity. :(
07:27:58 <vixey> I was wondering about that
07:28:43 <vixey> for permutations, you can always compose them out of swapper functions
07:28:54 <vixey> is there any simpler way to generate them?
07:28:57 <enticingjelly> I'm not entirely sure, but I may now need... Arrows
07:29:16 <trygvis> hm, should I use Int or Integer in my programs?
07:29:29 <trygvis> (I only need small numbers anyway)
07:29:29 <centrinia> Try Integral. ;)
07:29:55 <trygvis> the haskell wikibook use Integer all over, but those can be of any size, right?
07:30:05 <centrinia> Yes.
07:30:15 <enticingjelly> trygvis, if you only need small numbers, use Int
07:30:25 <vixey> enticingjelly, why?
07:30:25 <centrinia> If you have the storage space, then it can take on almost any magnitude.
07:30:32 <enticingjelly> vixey, why Int?
07:30:52 <ski_> (centrinia : hm .. using factoriadic numerals somehow ?)
07:30:54 <vixey> @src Integer
07:30:54 <lambdabot> data Integer = S# Int#
07:30:54 <lambdabot>              | J# Int# ByteArray#
07:31:02 <Olathe> > map ((flip mod 10).(^2)) [0..9]
07:31:02 <vixey> ^ small numbers are stored as Int# anyway
07:31:03 <lambdabot>   [0,1,4,9,6,5,6,9,4,1]
07:31:05 <opqdonut> centrinia: isn't that just what he did
07:31:07 <centrinia> ski_, exactly. :)
07:31:15 <vixey> it's much simpler to use Integer than Int, so you don't have to worry about boundry conditiotns
07:31:21 <enticingjelly> vixey, didn't now that. nice to know, thanks
07:31:27 <opqdonut> calculating straight w/o intermediary permutations
07:31:27 <enticingjelly> +k
07:31:34 <centrinia> Oh. :p
07:31:37 <opqdonut> recursion on the length of the list
07:31:41 <opqdonut> :)
07:32:01 <tibbe> vixey: but checking that sum to check if you have S# or J# requires a branch instruction no?
07:32:14 <tibbe> vixey: perhaps not with the new pointer tagging
07:32:23 <pejo> vixey, reasonably speaking it must be hard to statically determine Int vs Integer.
07:33:04 <enticingjelly> isn't it that you can be sure that with Int, you'll have a pretty possibly unbox primitive?
07:35:11 <thotypous> augustss, I'm your fan
07:40:57 <augustss> thotypous: Det var som fan.
07:41:31 <Polarina> Ne, ĝi ne estis.
07:41:47 <xEpicFailGuyx> augustss: Vad var som fan?
07:41:52 <augustss> thotypous: I'm not sure why, but thanks. :)
07:42:00 <NameAlreadyInUse> is there any way of doing something like: (a, b) + (x, y) = (a + x, b + y)
07:42:01 <thotypous> augustss, bluespec :P
07:42:10 <augustss> xEpicFailGuyx: what thotypous said
07:42:29 <thotypous> augustss, "it was like hell"?
07:42:33 <xEpicFailGuyx> augustss: Hahaha that needs explaining
07:42:34 <augustss> thotypous: ah, yeah, bluespec is pretty cool.  at least when using the haskell syntax
07:42:35 <pejo> augustss, mnga beundrare.
07:43:04 <thotypous> :)
07:43:11 <xEpicFailGuyx> @pl foldr (\x y -> f x ++ y) []
07:43:12 <lambdabot> foldr ((++) . f) []
07:43:16 <xEpicFailGuyx> FUCK
07:43:27 <augustss> NameAlreadyInUse: yes
07:44:14 <smg> xEpicFailGuyx: pwned
07:44:19 <augustss> NameAlreadyInUse: instance (Num a, Num b) => Num (a, b) where ...
07:44:22 <xEpicFailGuyx> smg: epic fail
07:44:35 <xEpicFailGuyx> I wonder if I can do that the other way
07:44:38 <xEpicFailGuyx> @pl y ++ f x
07:44:39 <lambdabot> y ++ f x
07:44:40 <smg> :D
07:44:46 <xEpicFailGuyx> hm
07:44:59 <augustss> @pl \ f -> y ++ f x
07:44:59 <lambdabot> (y ++) . ($ x)
07:45:11 <xEpicFailGuyx> that is ugly
07:45:27 <augustss> very
07:45:30 <xEpicFailGuyx> I'm only doing point-free expressions when it's blindingly obvious
07:45:36 <NameAlreadyInUse> example, augustss?
07:46:16 <augustss> NameAlreadyInUse: I showed you the first line of the instance declaration you need.  you can fill in the rest, perhaps
07:46:41 <xEpicFailGuyx> but the unary function `binary function` other operand == (binary function . unary function) thing is new
07:46:52 <xEpicFailGuyx> I'll try to remember that
07:47:09 <augustss> thotypous: "det var som fan" literally means "it was like the devil", but it's an expression of surprise
07:47:11 <NameAlreadyInUse> i am very new to haskell, but i will give it a try
07:47:25 <augustss> thotypous: where did you run into bluespec?
07:47:49 <xEpicFailGuyx> thotypous: And "Fan ta dig" means "f--- you", so remember that in case a Swedish person aggravates you
07:48:02 <xEpicFailGuyx> 'dig' is pronounced 'dey'
07:48:08 <thotypous> xEpicFailGuyx, :P
07:48:11 <augustss> NameAlreadyInUse: then I'll give you the next line (and the only one you need);  (x1,y1) + (x2,y2) = (x1+x2, y1+y2)
07:48:49 <xEpicFailGuyx> @pl g (f x) y
07:48:50 <lambdabot> g (f x) y
07:48:57 <thotypous> augustss, I first heard of it in the Haskell website, when I was learning some Haskell.. as I like digital electronics, I took a look at their website, and asked my professor to ask for a university license :)
07:49:04 <xEpicFailGuyx> @pl (\x y -> g (f x) y)
07:49:05 <lambdabot> g . f
07:49:16 <xEpicFailGuyx> hot
07:49:25 <NameAlreadyInUse> ah, that works
07:49:30 <NameAlreadyInUse> thanks augustss
07:49:44 <mapreduce> @pl \x y -> x * x + y * y
07:49:45 <lambdabot> (. join (*)) . (+) . join (*)
07:49:49 <mapreduce> more cowbell
07:50:12 <xEpicFailGuyx> thotypous: You like digital electronics huh?
07:50:33 <thotypous> yes :)
07:50:42 <augustss> thotypous: are you using the System Verilog syntax?
07:50:53 <xEpicFailGuyx> cool ... I'm considering changing my major so I can specialize on digital electronics
07:51:04 <thotypous> augustss, yes.. the Haskell syntax version is not maintained anymore :(
07:51:19 <thotypous> but the concepts around the language are still very great
07:51:24 <xhanjian> @src readFile
07:51:25 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
07:51:30 <augustss> thotypous: It's not maintained, but it still mostly works.  You use use file suffiex .bs
07:51:40 <ziman> oh, readFile uses hGetCOntents?
07:51:48 <thotypous> oh, thanks for the hint.. I will try it :D
07:51:50 <ski_> ziman : aye
07:51:56 <ziman> i thought it was strict
07:51:59 <enticingjelly> damn. it would have been better, had I used record syntax
07:52:11 <enticingjelly> now I have to define little functions which just extract parts of my data
07:52:25 <augustss> enticingjelly: so switch to record syntax
07:52:49 <enticingjelly> augustss, I don't know. I'd have to change a lot, plus I'm not sure if I really want record syntax in that case
07:52:57 <enticingjelly> but maybe I do.
07:52:58 <augustss> enticingjelly: you can change the data type declaration only, and the rest will just work
07:53:13 <enticingjelly> augustss, I'd also have to change all pattern matching, no?
07:53:28 <augustss> enticingjelly: no, you can still match positionally
07:53:40 <enticingjelly> augustss, oh?! that's great, I did not know that
07:53:44 <enticingjelly> record syntax it is!
07:54:25 <ski_> > Node 'a' []
07:54:27 <lambdabot>   Node {rootLabel = 'a', subForest = []}
07:55:05 <ski_> > let f (Node x xs) = (x,xs) in f (Node {rootLabel = 'a', subForest = []})
07:55:07 <lambdabot>   ('a',[])
07:56:07 <augustss> Can be handy. :)
07:56:44 <enticingjelly> plus you have automatic documentation for your more complex data structures, especially those where the same type repeats a lot.
07:57:04 <enticingjelly> data Foo = Foo Bar Bar Foo Bar Foo Foo Bar
07:57:05 <enticingjelly> %)
07:57:53 <pejo> augustss/Heffalump, those 70-tuples you were talking about yesterday: does ghc provide show/eq/etc instances for those?
07:58:27 <thotypous> there are some documentation for bluespec classic here :) http://csg.csail.mit.edu/IAPBlue/
07:58:37 <augustss> pejo: It ends somewhere, can't remember where.
07:58:41 <xEpicFailGuyx> enticingjelly: If you look in Yet Another Haskell Tutorial, there's an extensive section on all the ways you can use record notation for data types
07:59:09 <xEpicFailGuyx> In fact it starts on page 90 of the pdf
07:59:33 <xEpicFailGuyx> 7.7 Datatypes Revisited ... I mention that in such detail only b/c I'm looking now
08:00:10 <augustss> thotypous: I can probably dig out some old manual
08:00:11 <enticingjelly> xEpicFailGuyx, ah, nice. will do one time, there might be other surprises in there
08:01:27 <thotypous> augustss, it would be great :) thanks a lot
08:01:28 <xEpicFailGuyx> enticingjelly: Ja klar, YAHT ist einfach geil ...
08:01:47 <thotypous> be right back
08:02:17 <enticingjelly> xEpicFailGuyx, heh, hab's mir glaube ich mal angeschaut, gelernt hab ich allerdings aus The Haskell School of Expression (auch sehr geiles buch)
08:02:52 <xEpicFailGuyx> That's the multimedia based one, isn't it?
08:02:53 <int-e> heh. there's a #haskell.de (quite empty though)
08:03:07 <enticingjelly> xEpicFailGuyx, yes, it is
08:03:18 <xEpicFailGuyx> I wonder if I can find it on abebooks
08:03:27 <enticingjelly> int-e, wow. I'm alone in it. with lambdabot
08:03:43 <pejo> xEpicFailGuyx, are you using google translate?
08:03:59 <xEpicFailGuyx> pejo: No, I'm using whatever I remember from high school
08:04:26 <xEpicFailGuyx> And I studied Swedish outside of school...
08:04:42 <int-e> @users
08:04:43 <lambdabot> Maximum users seen in #haskell: 568, currently: 520 (91.5%), active: 15 (2.9%)
08:04:47 <int-e> @users #haskell.de
08:04:47 <skorpan> svenska svenska!!
08:04:48 <lambdabot> Maximum users seen in #haskell.de: 3, currently: 2 (66.7%), active: 1 (50.0%)
08:05:03 <int-e> @users #haskell.se
08:05:04 <lambdabot> Maximum users seen in #haskell.se: 10, currently: 7 (70.0%), active: 0 (0.0%)
08:05:56 <xEpicFailGuyx> lol
08:08:03 <mib_c2zegu> @hoogle Maybe a -> (a -> b) -> Maybe b
08:08:04 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
08:08:04 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:08:04 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
08:08:58 <mib_c2zegu> flip fmap :P
08:09:11 <mib_c2zegu> that seems worthy of its own name
08:09:46 <ski_> pamf
08:09:53 <mib_c2zegu> haha
08:09:58 <mib_c2zegu> @hoogle <?>
08:09:58 <lambdabot> Text.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
08:09:58 <lambdabot> Text.ParserCombinators.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
08:10:03 <ski_> (i've seriously used that name)
08:10:10 <mib_c2zegu> hmm, Parsec has taken _all_ of the <symbol> names :-)
08:10:29 <mib_c2zegu> @hoogle <~>
08:10:29 <lambdabot> No results found
08:10:29 <int-e> @hoogle ?
08:10:30 <lambdabot> Text.Parsec.Perm (<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
08:10:30 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
08:10:30 <lambdabot> Text.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
08:10:47 <int-e> good, (?) is still free :)
08:10:54 <mib_c2zegu> @hoogle <+>
08:10:54 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
08:10:54 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
08:10:54 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
08:11:06 <mib_c2zegu> int-e: heh, that's a bit namespace-polluting :-)
08:11:19 <wli> (>?<) ?
08:11:37 <mib_c2zegu> maybe ?>
08:11:41 <mib_c2zegu> Just 2 ?> succ
08:11:49 <mib_c2zegu> Just 2 >? succ -- may read better
08:12:15 <mib_c2zegu> yeah, >? is nice
08:12:22 <b_jonas> @type >?
08:12:23 <lambdabot> parse error on input `>?'
08:12:28 <b_jonas> @type (>?)
08:12:28 <mib_c2zegu> (>?)
08:12:29 <lambdabot> Not in scope: `>?'
08:12:36 <mib_c2zegu> b_jonas: (>?) = flip fmap
08:12:39 <mib_c2zegu> :t flip fmap
08:12:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
08:12:44 <int-e> @type ?(?)
08:12:46 <lambdabot> parse error on input `?'
08:12:52 <Axman6> looks a lot like >>=
08:12:58 <b_jonas> I see
08:12:59 <paper_cc> @type (>?)
08:13:00 <lambdabot> Not in scope: `>?'
08:13:04 <mib_c2zegu> Axman6: hm, good point
08:13:10 <mib_c2zegu> but not quite
08:13:10 <Badger> :t $
08:13:11 <lambdabot> parse error on input `$'
08:13:14 <Badger> :t ($)
08:13:15 <lambdabot> forall a b. (a -> b) -> a -> b
08:13:25 <mib_c2zegu> it's a way of making a pipeline with e.g. Maybe on non-Maybe-aware functions
08:13:29 <mib_c2zegu> cascading Nothings
08:13:32 <mib_c2zegu> ofc, that's just for Maybe
08:14:51 <wli> liftM?
08:14:52 <int-e> > Just 2 <**> pure succ
08:14:53 <lambdabot>       Ambiguous occurrence `pure'
08:14:54 <lambdabot>      It could refer to either `Control.Appl...
08:15:01 <int-e> > Just 2 <**> Control.Applicative.pure succ
08:15:02 <lambdabot>   Just 3
08:15:10 <mib_c2zegu> :type liftM
08:15:15 <b_jonas> there are two pures imported?
08:15:19 <mib_c2zegu> :t liftM
08:15:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:15:25 <mib_c2zegu> wli: not really
08:15:32 <b_jonas> the imports of lambdabot are getting stranger
08:15:36 <b_jonas> there are also two of var
08:15:54 <mib_c2zegu> maybeSucc :: Enum a => Maybe a -> Maybe a
08:15:56 <int-e> > Control.Arrow.pure succ 1
08:15:57 <lambdabot>   2
08:16:02 <mib_c2zegu> maybeSucc a = a ?> succ
08:16:04 <mib_c2zegu> err, ?>
08:16:04 <b_jonas> @info pure
08:16:05 <lambdabot> pure
08:16:05 <mib_c2zegu> ...
08:16:06 <mib_c2zegu> >?
08:16:10 <b_jonas> @where pure
08:16:11 <lambdabot> I know nothing about pure.
08:16:12 <mib_c2zegu> and yeah, pure works
08:16:15 <mib_c2zegu> but that's less general
08:16:17 <mib_c2zegu> this works on every functor
08:16:18 <int-e> @hoogle pure
08:16:18 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
08:16:18 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
08:16:18 <lambdabot> package pureMD5
08:16:21 <int-e> @index pure
08:16:22 <lambdabot> Control.Arrow
08:16:32 <wli> > liftM succ (Just 5)
08:16:34 <lambdabot>   Just 6
08:17:15 <mib_c2zegu> wli: 1) only works on monads, 2) you still need to give (flip liftM) an infix name
08:17:20 <mib_c2zegu> so you might as well generalize it in the process
08:17:25 <int-e> Control.Arrow.pure does no longer exist in base-4
08:17:41 <wli> I guess.
08:17:45 <b_jonas> still, lambdabot imports should probably hide one
08:17:57 <int-e> or base-3.0.3.0 for that matter.
08:18:51 <mib_c2zegu> hmm, maybe (>?>) is a better name
08:26:01 <trygvis> how do I transform a Int to a Float?
08:26:18 <BONUS_> fromIntegral
08:26:22 <wli> fromIntegral
08:26:23 <cizra> 2::Float
08:26:29 <BONUS_> (fromIntegral (3::Int)) + 3.9
08:26:30 <cizra> > 2::Float
08:26:32 <lambdabot>   2.0
08:26:32 <BONUS_> > (fromIntegral (3::Int)) + 3.9
08:26:33 <lambdabot>   6.9
08:26:42 <mib_c2zegu> fromIntegral
08:26:45 <mib_c2zegu> hey am I too late to the party
08:26:48 <Badger> fromIntegral
08:26:52 <BONUS_> haha
08:26:53 <cizra> fromIntegral!
08:26:55 <Badger> just in case you didn't get it
08:26:58 <mib_c2zegu> Badger: actually I'd suggest fromIntegral instead
08:27:03 <BONUS_> i accidentally the whole fromIntegral
08:27:08 <Badger> mib_c2zegu: are you sure? I heard fromIntegral works better
08:27:10 <int-e> @src fromIntegral
08:27:11 <lambdabot> fromIntegral = fromInteger . toInteger
08:27:23 <mib_c2zegu> Badger: (fromInteger . toInteger) is where it's at
08:28:10 <Badger> mib_c2zegu: just use asm and forget all this fancy high-level stuff.. :P
08:28:23 <b_jonas> I see
08:28:41 <b_jonas> I just found out the difference between a Foldable and a Traversable!
08:28:41 <mib_c2zegu> Badger: but think of the power fromIntegral would  give you
08:28:57 <Axman6> anyone have any experience with lhs2tex?
08:29:01 <Olathe> Has anyone done Euler #206 (http://projecteuler.net/index.php?section=problems&id=206) ?
08:29:04 <b_jonas> a Traversable lets you build a new strucutre with the elements replaced as you iterate on it in order
08:29:07 <memento> hi
08:29:11 <Axman6> i'm getting:
08:29:12 <Axman6> `code' is not defined;
08:29:13 <Axman6> perhaps you forgot to include "lhs2TeX.fmt"?
08:29:14 <vixey> hi
08:29:36 <mib_c2zegu> Axman6: perhaps you forgot to include "lhs2TeX.fmt"?
08:29:48 <Axman6> Olathe: i have... my solutionis ugly though -_-
08:29:48 <vixey> > 111111111^22
08:29:49 <lambdabot>   101546458753261327184923178747617652064696923754972975383186435412252109979...
08:29:50 <vixey> > 111111111^2
08:29:51 <lambdabot>   12345678987654321
08:29:55 <vixey> > 10101010101010101^2
08:29:56 <lambdabot>   102030405060708090807060504030201
08:30:00 <vixey> > 1010101010101^2
08:30:01 <lambdabot>   1020304050607060504030201
08:30:06 <Olathe> Here's my solution: http://hpaste.org/13367
08:30:06 <int-e> Olathe: yes. nothing exciting
08:30:08 <mib_c2zegu> > A (g 64) (g 64)
08:30:09 <mib_c2zegu> err, a
08:30:09 <lambdabot>   Not in scope: data constructor `A'
08:30:15 <Olathe> You can append yours, if you'd like.
08:30:19 <vixey> > 101010101^2
08:30:20 <lambdabot>   10203040504030201
08:30:26 * vixey I'm not going to get it this way
08:30:33 <vixey> > 9090909090^2
08:30:34 <lambdabot>   82644628082644628100
08:30:44 <vixey> > 911111^2
08:30:45 <lambdabot>   830123254321
08:30:50 <mib_c2zegu> >  999999999999999^2
08:30:51 <lambdabot>   999999999999998000000000000001
08:31:00 <vixey> > 910101010^2
08:31:01 <lambdabot>   828283848403020100
08:31:03 <Axman6> Olathe: seems more complicated than necessary, but good work :)
08:31:08 <vixey> > 910101015^2
08:31:09 <lambdabot>   828283857504030225
08:31:12 <vixey> > 910101019^2
08:31:13 <lambdabot>   828283864784838361
08:31:16 <vixey> grrr
08:31:19 <Olathe> How'd you do yours ?
08:31:36 <Olathe> Mine is a bit complex.
08:31:45 <Olathe> I was hoping for ideas.
08:33:23 <int-e> Olathe: http://hpaste.org/13367#a1
08:34:09 <memento> im stucked with text.regex.posix, how can i get the contents of the ()'s?, so i have: "blabla(lofasz)asdf" =~ "\\((.*)\\)" :: String and i would like to get just the "lofasz" part of the string not the "(lofasz)"
08:34:10 <Olathe> Ahh, thanks :)
08:34:15 <int-e> (actually it was a one-liner developed interactively in ghci)
08:35:13 <vixey> > sqrt 1020304050607080900
08:35:14 <lambdabot>   1.0101010101010101e9
08:35:43 <Olathe> > floor $ sqrt 1020304050607080900
08:35:45 <lambdabot>   1010101010
08:36:04 <Axman6> Olathe: http://hpaste.org/13368
08:36:13 <Axman6> lolable code there :)
08:36:59 <Axman6> int-e: ha, you used the same method i did :)
08:37:10 <int-e> not quite
08:37:20 <Axman6> well, sort of
08:37:26 <xEpicFailGuyx> @pl foldr (\x y -> if x then True then y) False
08:37:27 <lambdabot> (line 1, column 31):
08:37:27 <lambdabot> unexpected reserved word "then"
08:37:27 <lambdabot> expecting variable, "(", operator or "else"
08:37:27 <Olathe> > 1389026624^2
08:37:29 <lambdabot>   1929394962180837376
08:37:32 <xEpicFailGuyx> oops
08:37:42 <Olathe> Axman6: Ahh, cool :)
08:37:53 <Axman6> i was looking at the matching against [d1,_,d2,_,d3,_,d4,_,d5,_,d6,_,d7,_,d8,_,d9] bit
08:38:01 <int-e> Axman6: yep.
08:38:04 <Axman6> Olathe: it's not at all fast -_-
08:38:12 <Olathe> Ahh, yes :)
08:38:33 <Axman6> i can't believe i actually typed out ['1','2','3','4','5','6','7','8','9','0']
08:38:59 <Olathe> > intersperse '9' "1234567890"
08:39:01 <lambdabot>   "1929394959697989990"
08:39:23 <Olathe> > floor $ sqrt (read $ intersperse '9' "1234567890")
08:39:24 <lambdabot>   1389026623
08:40:00 <augustss> It has to end in 00
08:40:21 <Badger> Axman6: heh
08:40:39 <Badger> @hoogle intersperse
08:40:39 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
08:40:39 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:40:39 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
08:40:42 <Badger> ah
08:41:06 <Axman6> wasn't until i took another look at the question a few weeks ago i realised how retarded i was
08:41:10 <memento> > "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: String
08:41:11 <lambdabot>   "(lofasz)"
08:41:12 <chrisdone> how would you unify (?x k) with (?y k)?
08:41:27 <Olathe> Wait...we have =~ ?
08:41:41 <Olathe> That should be nice :)
08:41:47 <Axman6> :t (=~)
08:41:48 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
08:41:55 <chrisdone> EXTREME ABSTRACTION
08:42:04 <Axman6> uh wow
08:42:10 <Olathe> > "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: Boolean
08:42:11 <lambdabot>       Not in scope: type constructor or class `Boolean'
08:42:13 <Olathe> > "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: Bool
08:42:14 <lambdabot>   True
08:42:17 <Olathe> Neat :)
08:42:19 <memento> it seems like
08:42:58 <memento> and my goal is to get just "lofasz"
08:43:37 <Olathe> > dropWhile (/= '(') "asdfasdf(lofasz)asdf"
08:43:39 <lambdabot>   "(lofasz)asdf"
08:43:56 <Olathe> > takeWhile(/= ')').drop 1.dropWhile (/= '(') $ "asdfasdf(lofasz)asdf"
08:43:58 <lambdabot>   "lofasz"
08:44:23 <paper_cc> brrr
08:44:41 <int-e> > "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: (String, String, String, [String])
08:44:43 <lambdabot>   ("asdfasdf","(lofasz)","asdf",["lofasz"])
08:44:45 <memento> mm
08:44:55 <Olathe> O-o
08:45:02 <int-e> > "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: [[String]]
08:45:04 <lambdabot>   [["(lofasz)","lofasz"]]
08:45:17 <memento> ahhh thx int-e
08:45:28 <Olathe> Wow, that's pretty neat the ways you can get the output.
08:45:38 <int-e> @instances-importing Text.Regex Text.Regex.Base.RegexLike.RegexLike
08:45:40 <lambdabot> Regex String
08:45:41 <Olathe> > "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: [String]
08:45:43 <lambdabot>   ["(lofasz)"]
08:45:46 <Olathe> Bah.
08:46:40 <Olathe> > last.head $ "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)"
08:46:42 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
08:46:42 <lambdabot>                ...
08:46:44 <int-e> > "asdfasdf(lofasz)as(lala)df" =~ "\\((.*)\\)" :: [String]
08:46:46 <lambdabot>   ["(lofasz)as(lala)"]
08:46:57 <int-e> > "asdfasdf(lofasz)as(lala)df" =~ "\\(([^)]*)\\)" :: [String]
08:46:58 <Olathe> > last.head $ "asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: [[String]]
08:47:00 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
08:47:00 <lambdabot>                ...
08:47:00 <lambdabot>   ["(lofasz)","(lala)"]
08:47:11 <ziman> memento, (OT) are you hungarian? :)
08:47:21 <paper_cc> last.head $ ("asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: [[String]])
08:47:33 <paper_cc> > last.head $ ("asdfasdf(lofasz)asdf" =~ "\\((.*)\\)" :: [[String]])
08:47:34 <lambdabot>   "lofasz"
08:47:44 <memento> ziman: yeah:)
08:47:47 <int-e> map last :)
08:47:50 <Olathe> > last.head $ ("asdfasdf(lofasz)asdf" =~ "\\((.*)\\)")
08:47:51 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
08:47:51 <lambdabot>                ...
08:47:55 <Olathe> Hmm...
08:47:59 <Olathe> @type last.head
08:48:01 <lambdabot> forall a. [[a]] -> a
08:48:07 <Olathe> Ahh, String.
08:48:14 <Olathe> > (last.head $ ("asdfasdf(lofasz)asdf" =~ "\\((.*)\\)")) :: String
08:48:15 <memento> nice
08:48:16 <lambdabot>   "lofasz"
08:49:16 <trygvis> is it possible to get ghci to not remember duplicate commands?
08:49:50 <trygvis> after doing 20 :l Main it get tiring to use arrow up 20 times to get to the method test command
08:51:32 <int-e> trygvis: add 'history unique 1' to your .editrc
08:51:41 <paolino> it's a readline/editline  issue, try to read docs for those
08:52:14 <Olathe> Is there a way to increase ghci's maximum line length ?
08:54:35 <int-e> it has one? it just accepted a 10k digit number for me.
08:55:12 <Olathe> Let me check.
08:56:34 <Olathe> Yep, on mine it does.
08:56:57 <Olathe> > repeat "1234567890"
08:56:58 <lambdabot>   ["1234567890","1234567890","1234567890","1234567890","1234567890","12345678...
08:57:19 <Olathe> > concat.take 500 $ repeat "1234567890"
08:57:21 <lambdabot>   "12345678901234567890123456789012345678901234567890123456789012345678901234...
08:57:26 <Olathe> I put that into it.
08:57:30 <int-e> > cycle "1234567890"
08:57:32 <lambdabot>   "12345678901234567890123456789012345678901234567890123456789012345678901234...
08:57:42 <int-e> > replicate 500 "1234567890"
08:57:44 <lambdabot>   ["1234567890","1234567890","1234567890","1234567890","1234567890","12345678...
08:57:53 <vixey> > 909090909^2
08:57:55 <lambdabot>   826446280826446281
08:57:59 <Olathe> It got the first 254 chars.
08:58:02 <vixey> > 506070809^2
08:58:03 <lambdabot>   256107663721914481
08:58:10 <Olathe> So, it thinks that's a number ending in 4,.
08:58:22 <Olathe> Of course, I'm in Windows land.
08:58:52 <int-e> let me guess, 255 characters?
08:58:53 <Olathe> It was quite annoying the other day when I was constructing some complex function.
08:58:58 <Olathe> Well, 254.
08:59:09 <Olathe> Which is a bit odd, but oh well.
08:59:35 <int-e> heh. 254 is even.
08:59:42 <Olathe> Yes :D
09:02:58 <paolino> if someone has some spare time to comment or rewrite the function here http://hpaste.org/13361, I would be pleased, the function should pick the best represantative element of the list given a distance function
09:05:05 <memento> im using runhaskell, is there a way to print out the "function calling tree"(with parameters)(if u now what i mean eheh)?
09:05:41 <Lemmih> memento: A stack trace?
09:05:45 <Axman6> memento: look at Debug.Trace i think
09:06:26 <memento> thx
09:08:09 <Olathe> paolino: Is the function finding the item with the lowest distance-to-others sum ?
09:09:14 <elbar> @bf +@
09:09:15 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
09:09:23 <elbar> @bf "+"
09:09:23 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
09:09:27 <elbar> gah
09:09:39 <paolino> Olathe: right
09:10:36 <paolino> possibly better then O(n^2)
09:11:18 <Olathe> I think you have to calculate each distance at least once.
09:11:29 <Olathe> So, it's necessarily O(n^2)
09:11:42 <paper_cc1> Olathe, unless the distance is additive
09:12:14 <Olathe> Yes, I suppose if they're on a line, it's easier.
09:13:16 <paolino> right, so not making more than one distance evaluation each pair which is n*(n-1) / 2
09:13:33 <paolino> which is less then n ^ 2
09:13:35 <Olathe> Let's see.
09:13:39 <Olathe> Sure, it is.
09:13:48 <Olathe> To do it only once...
09:13:56 <Axman6> technically still O(n^2) though
09:14:20 <paolino> Axman6: true
09:15:33 <Olathe> @let dist x y = abs (x - y)
09:15:34 <lambdabot>  Defined.
09:15:59 <Olathe> > let lowerTriangle [] = []; lowerTriangle (x:xs) = map (dist x) xs:lowerTriangle xs in lowerTriangle [1,2,3,4,5]
09:16:00 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2],[1],[]]
09:16:06 <Olathe> Maybe that's upperTriangle.
09:16:17 <vixey> > tails [1..4]
09:16:18 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
09:16:23 <vixey> > inits [1..4]
09:16:24 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
09:16:32 <Olathe> > let upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in upperTriangle [1,2,3,4,5]
09:16:33 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2],[1],[]]
09:16:43 <Olathe> So, let's make that into a nice square.
09:16:49 <Axman6> > transpose . tails $ [1..5]
09:16:51 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
09:17:00 <Axman6> > transpose . inits $ [1..5]
09:17:01 <lambdabot>   [[1,1,1,1,1],[2,2,2,2],[3,3,3],[4,4],[5]]
09:17:20 <chrisdone> once you've unified a variable with a constant it never changes?
09:17:27 <vixey> > transpose ([1..10] >>= join replicate)
09:17:28 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Int'
09:17:49 <Olathe> > let square xs = (transpose (upperTriangle xs), upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square [1..5]
09:17:51 <lambdabot>   ([[1,1,1,1],[2,2,2],[3,3],[4]],[[1,2,3,4],[1,2,3],[1,2],[1],[]])
09:18:05 <Olathe> That doesn't seem right.
09:18:30 <Saizan> chrisdone: the answer is probably no, but, which kind of variable?
09:20:23 <Olathe> > let square xs = zipWith (\a b -> a ++ (0:b)) ((reverse.transpose.upperTriangle) xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square [1..5]
09:20:25 <lambdabot>   [[4,0,1,2,3,4],[3,3,0,1,2,3],[2,2,2,0,1,2],[1,1,1,1,0,1]]
09:20:27 <chrisdone> Saizan: what kinds are there?
09:20:34 <MyCatVerbs> chrisdone: you're talking Prolog? In which case, it doesn't change again unless you backtrack back past the point where you assigned it.
09:21:01 <Olathe> > let square xs = zipWith (\a b -> a ++ (0:b)) ((([]:)reverse.transpose.upperTriangle) xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square [1..5]
09:21:03 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[[a]]'
09:22:27 <chrisdone> MyCatVerbs: yes. but I'm just talking about unifying two patterns rather than backtrack-searching a set of facts
09:23:09 <Olathe> > let square xs = zipWith (\a b -> a ++ (0:b)) ((reverse.map reverse.upperTriangle) xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square [1..5]
09:23:11 <lambdabot>   [[0,1,2,3,4],[1,0,1,2,3],[2,1,0,1,2],[3,2,1,0,1],[4,3,2,1,0]]
09:23:11 <Olathe> There we go.
09:23:18 <Olathe> > let square xs = zipWith (\a b -> a ++ (0:b)) ((reverse.map reverse.upperTriangle) xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square [1, 2, 4, 8, 16]
09:23:20 <lambdabot>   [[0,1,3,7,15],[8,0,2,6,14],[12,4,0,4,12],[14,6,2,0,8],[15,7,3,1,0]]
09:23:39 <Olathe> Hmm, not quite.
09:24:22 * tibbe wishes for another default haddock font
09:27:25 <Olathe> paolino: Here it is.
09:27:26 <Olathe> > let square xs = zipWith (\a b -> a ++ (0:b)) (([]:).reverse.transpose.map reverse.upperTriangle $ xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square [1, 2, 4, 8, 16]
09:27:28 <lambdabot>   [[0,1,3,7,15],[1,0,2,6,14],[3,2,0,4,12],[7,6,4,0,8],[15,14,12,8,0]]
09:27:47 <Olathe> Only computes each distance once.
09:28:25 <Olathe> > let square xs = map (\x -> map (dist x) xs) xs in square [1, 2, 4, 8, 16]
09:28:27 <lambdabot>   [[0,1,3,7,15],[1,0,2,6,14],[3,2,0,4,12],[7,6,4,0,8],[15,14,12,8,0]]
09:28:36 <Olathe> Only computes each distance twice.
09:28:58 <MyCatVerbs> chrisdone: you are talking Haskell's pattern matching?
09:29:06 * Axman6 tries to make a version that only converts each distance thrice
09:29:18 <Axman6> because thrice are an awesome band :)
09:30:06 <paolino> eh, more readeable than mine :)
09:30:18 <MyCatVerbs> chrisdone: Haskell's semantics are that it tries every alternative pattern you've given it in order, and goes with the first one that matches and for which the guard condition (if any) evaluates to True. Double check the guard thing though, because I'm not certain about it. =)
09:30:37 <Olathe> @pl let square xs = zipWith (\a b -> a ++ (0:b)) (([]:).reverse.transpose.map reverse.upperTriangle $ xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square
09:30:38 <lambdabot> (line 1, column 137):
09:30:38 <lambdabot> unexpected "["
09:30:38 <lambdabot> expecting pattern or "="
09:30:50 <paolino> reverse.transpose. map reverse  sounds bad though
09:31:04 <Axman6> Olathe: get rid of the let ... in square
09:31:07 <vixey> :t reverse.transpose. map reverse
09:31:08 <lambdabot> forall a. [[a]] -> [[a]]
09:32:21 <MyCatVerbs> chrisdone: Ah yeah. Haskell will backtrack over the pattern alternatives until it finds one which both matches and for which the guard comes out as True.
09:32:37 <vixey> MyCatVerbs: wouldn't call it backtracking
09:32:52 <Olathe> Even better...
09:33:03 <MyCatVerbs> vixey: limited-depth backtracking =)
09:33:14 <Olathe> @pl let square xs = zipWith (\a b -> a ++ b) (([]:).reverse.transpose.map reverse.upperTriangle $ xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square
09:33:21 <Olathe> > let square xs = zipWith (\a b -> a ++ b) (([]:).reverse.transpose.map reverse.upperTriangle $ xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square
09:33:22 <lambdabot> (line 1, column 133):
09:33:22 <lambdabot> unexpected "["
09:33:22 <lambdabot> expecting pattern or "="
09:33:23 <Olathe> Bah.
09:33:23 <lambdabot>       Overlapping instances for Show ([a] -> [[a]])
09:33:23 <lambdabot>        arising from a use...
09:33:32 <Olathe> > let square xs = zipWith (\a b -> a ++ b) (([]:).reverse.transpose.map reverse.upperTriangle $ xs) (upperTriangle xs); upperTriangle [] = []; upperTriangle (x:xs) = map (dist x) xs:upperTriangle xs in square [1, 2, 4, 8, 16]
09:33:34 <lambdabot>   [[1,3,7,15],[1,2,6,14],[3,2,4,12],[7,6,4,8],[15,14,12,8]]
09:33:38 <Olathe> No zeroes needed.
09:33:59 <MyCatVerbs> vixey: and yes, I know the term's not entirely appropriate, but oh well. Hack enough Prolog and you might find yourself thinking of it that way eventually. x_x
09:35:21 <paolino> thanks Olathe , I will study it
09:44:11 <centrinia> How does one decide if { x | x^2 = a (mod 10^n) } is nonempty?
09:45:02 <opqdonut> centrinia: that's a classic problem of number theory
09:45:08 <opqdonut> square residue is the key term iirc
09:45:40 <opqdonut> http://mathworld.wolfram.com/QuadraticResidue.html
09:45:46 <centrinia> I couldn't find anything very useful for composite moduli.
09:48:13 <opqdonut> the r^((p-1)/2)-test should probably work if you replace p-1 with phi(p)
09:48:30 <centrinia> Thanks.
09:48:36 <opqdonut> (i.e. generalising from little fermat to euler(?))
09:48:41 <opqdonut> my number theory is a bit rusty
09:50:38 <Gilly> centrinia: how big powers of ten are you having? just brute forcing won't work?
09:50:59 <centrinia> Gilly, no.
09:51:38 <centrinia> I'm trying to solve Euler 206 by incrementally testing candidates modulo 10^n.
09:52:50 * vixey I tried to get dc to print all the squares so I could grep it but I forget how to use dc :/
09:54:55 <Gilly> ah, an euler problem :)
09:56:53 <Gilly> oh hm, i've done that... :)
10:01:06 <Gilly> centrinia: i don't know how much i should say about the problem... your way of doing it is probably not as efficient as one might think
10:01:32 <Olathe> paolino: Finally got it working: http://hpaste.org/13361#a3
10:10:49 <centrinia> Gilly, if I know that if y=((9*10 + x)*10 + 0) that is not a quadratic residue modulo 1000, then nothing congruent to y modulo 1000 can be a solution.
10:11:51 <mib_0ggb2t> anyone ever worked with multisets?
10:11:53 <Gilly> centrinia: true
10:11:59 <Plouj> does RWH have an answers page?
10:12:56 <Plouj> online...
10:14:09 <centrinia> Multisets are lists modulo permutations. :)
10:16:40 <xenoblitz> Lol just got RWH as a belated christmas present!
10:16:42 <xenoblitz> Yeay!
10:17:54 <b_jonas> xenoblitz: nice
10:18:05 <b_jonas> xenoblitz: I like that kind of thing
10:18:08 <xenoblitz> RWH has reached Malta :)
10:18:35 <b_jonas> I always liked when the Harry Potter books were published so I could get them for my birthday
10:18:59 <xenoblitz> b_jonas: yeah i know what you mean :)
10:21:05 <xenoblitz> b_jonas: this also means less bothering #haskell with silly questions :P
10:34:00 <luite_> how can I get the maximum and minimum value of the Int datatype?
10:34:27 <Olathe> > maxBound :: Int
10:34:28 <lambdabot>   9223372036854775807
10:34:32 <Olathe> > minBound :: Int
10:34:34 <lambdabot>   -9223372036854775808
10:35:04 <Olathe> > last [1::Int..]
10:35:05 <lambdabot>   <no location info>: parse error on input `Int..'
10:35:14 <Olathe> > last [(1::Int)..]
10:35:20 <luite_> ah thanks
10:35:25 <Olathe> > last [(1::Int),0..]
10:35:30 <lambdabot>   thread killed
10:35:39 <luite_> hoogle doesn't know it apparently
10:35:41 <lambdabot>   thread killed
10:35:49 <Olathe> @hoogle Bounded
10:35:50 <lambdabot> Prelude class Bounded a
10:36:28 <luite_> @hoogle maxBound
10:36:28 <lambdabot> Prelude maxBound :: Bounded a => a
10:36:35 <luite_> hm, this hoogle does
10:37:10 <Olathe> Hmm, weird.
10:38:59 <Olathe> luite_: Hayoo has it.
10:39:01 <Olathe> http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:44:00 <luite_> ah
10:44:40 <b_jonas> also
10:44:46 <b_jonas> > Data.Bits.rotateR (-2) 1 :: Int
10:44:49 <lambdabot>   9223372036854775807
10:44:55 <b_jonas> is the max bound
10:45:08 <Olathe> @src Int maxBound
10:45:08 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:45:38 <Olathe> > Data.Bits.rotateR (-1) 1 :: Int
10:45:41 <lambdabot>   -1
10:45:50 <Olathe> O-o
10:45:54 <b_jonas> that doesn't work because -1 is all ones
10:46:03 <b_jonas> if you could unsigned shift -1 right 1, that would work,
10:46:06 <Olathe> I know. Rotate shouldn't give all ones for that.
10:46:13 <b_jonas> but Bits doesn't have an unsigned shift for signed types
10:46:14 <Plouj> hello?
10:46:18 <b_jonas> and Int is signed
10:46:19 <centrinia> > Data.Bits.rotateR (-1) 65 :: Int
10:46:22 <lambdabot>   -1
10:46:35 <Olathe> > Data.Bits.rotateL 1 1 :: Int
10:46:37 <lambdabot>   2
10:46:46 <centrinia> > Data.Bits.rotateL (-1) 65 :: Int
10:46:48 <lambdabot>   -1
10:46:49 <Olathe> > Data.Bits.rotateR 1 1 :: Int
10:46:50 <b_jonas> > Data.Bits.shiftR (-2) 1 :: Word
10:46:53 <lambdabot>   -9223372036854775808
10:46:53 <lambdabot>   9223372036854775807
10:46:54 <b_jonas> > Data.Bits.shiftR (-1) 1 :: Word
10:46:56 <lambdabot>   9223372036854775807
10:46:57 <Olathe> There we are.
10:47:02 <Olathe> > Data.Bits.rotateR 1 1 == maxBound :: Int
10:47:04 <lambdabot>   Couldn't match expected type `Int' against inferred type `Bool'
10:47:05 <Olathe> > Data.Bits.rotateR 1 1 == minBound :: Int
10:47:07 <lambdabot>   Couldn't match expected type `Int' against inferred type `Bool'
10:47:13 <Olathe> > Data.Bits.rotateR 1 (1::Int) == minBound
10:47:15 <lambdabot>   Add a type signature
10:47:18 <Olathe> No !
10:47:29 <Olathe> > (Data.Bits.rotateR 1 1 :: Int) == minBound
10:47:33 <lambdabot>   True
10:47:49 <Olathe> Ahh.
10:47:55 <Plouj> can anyone hear me?
10:47:57 <Olathe> rotateR n dist
10:48:03 <b_jonas> Plouj: yes
10:48:07 <Olathe> > Data.Bits.rotateR 8 1
10:48:09 <lambdabot>   Add a type signature
10:48:12 <Olathe> > Data.Bits.rotateR 8 1 :: Int
10:48:15 <lambdabot>   4
10:48:16 <Plouj> ok, that's weird
10:48:16 <Olathe> > Data.Bits.rotateR 1 8 :: Int
10:48:20 <lambdabot>   72057594037927936
10:48:23 <b_jonas> wait, why isn't that defaulted?
10:48:38 <Olathe> > shiftL
10:48:40 <lambdabot>       Overlapping instances for Show (a -> Int -> a)
10:48:40 <lambdabot>        arising from a us...
10:48:44 <b_jonas> Bits is a subclass of Num
10:48:45 <Plouj> 13:11:58< Plouj> does RWH have an answers page?
10:48:45 <Plouj> 13:12:56< Plouj> online...
10:48:45 <Plouj> 13:13:08-!- paolino [n=sara@host254-41-dynamic.2-79-r.retail.telecomitalia.it] has quit [Read error: 145 (Connection timed  out)]
10:48:49 <b_jonas> how's the defaulting rule again?
10:48:52 <Plouj> does RWH have an answer page online?
10:49:03 <Olathe> It would default it, but they included something that includes Data.Bits.
10:49:08 <Plouj> oops, my bad
10:49:13 <Olathe> So, there's two copies of everything.
10:49:53 <b_jonas> the h98 says defaulting cna work only if all of the classes are standard onesa
10:50:01 <b_jonas> and Bits isn't one
10:50:07 <b_jonas> well, no problem
10:50:12 <b_jonas> not defaulting is not bad
10:50:18 <Olathe> Ahh
10:50:19 <b_jonas> it's probably better if you specify it explicitly anyway
10:52:45 <b_jonas> > last (takeWhile (0<) (iterate ((1+) . (2*)) 1)) :: Int
10:52:47 <lambdabot>   9223372036854775807
10:54:54 <vixey> > [9223372036854775807..]
10:54:56 <lambdabot>   [9223372036854775807,9223372036854775808,9223372036854775809,92233720368547...
10:55:40 <vixey> > 9223372036854775807^2
10:55:42 <lambdabot>   85070591730234615847396907784232501249
10:57:27 <CakeProphet> :t mapM
10:57:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:57:56 <mreh> i wish i could understand that
10:58:30 <CakeProphet> it's starting to make sense to me
10:58:42 <mreh> after how long?
10:58:49 <vixey> @src mapM
10:58:49 <lambdabot> mapM f as = sequence (map f as)
10:58:56 <CakeProphet> I've been learning Haskell for the past 2 weeks or so
10:59:09 <mreh> cool
10:59:10 <CakeProphet> @src sequence
10:59:11 <lambdabot> sequence []     = return []
10:59:11 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:59:11 <lambdabot> --OR
10:59:11 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:59:44 <mreh> done anything cool with it?
10:59:55 <CakeProphet> I'm working on a 6 degrees of seperation simulator
11:00:09 <mreh> ive been reading little-schemer, driving me nuts with all the lists
11:00:16 <vixey> haha
11:00:37 <mreh> however by the end you get to write a parser, at the end of a rather thin book, which is mostly whitespace
11:00:50 <mreh> brb
11:03:09 <CakeProphet> is pi in a module somewhere or is it floating around in Prelude?
11:03:40 <CakeProphet> -checked- prelude
11:03:41 <Zao> CakeProphet: Prelude, Hoogle seems to indicate.
11:03:49 <CakeProphet> thanks.
11:04:18 <Zao> The report seems to agree.
11:06:20 <adekoba> hi. Is there anything glaringly wrong with this code? http://gist.github.com/40299
11:06:46 <adekoba> binary-strict is deprecated, so I thought I'd whip up something simple
11:06:56 <CakeProphet> > 2*pi
11:06:57 <lambdabot>   6.283185307179586
11:07:06 <CakeProphet> awesome. no weird int type answer
11:07:18 <Badger> :t pi
11:07:20 <Zao> @type pi
11:07:21 <lambdabot> forall a. (Floating a) => a
11:07:22 <lambdabot> forall a. (Floating a) => a
11:07:23 <smg> > 2 *pi :: Int
11:07:25 <lambdabot>       No instance for (Floating Int)
11:07:25 <lambdabot>        arising from a use of `pi' at <in...
11:07:33 <Badger> heh, floating int
11:07:58 <Badger> > 2 * pi :: Double
11:07:59 <lambdabot>   6.283185307179586
11:08:06 <Badger> > 2 * pi :: Complex
11:08:07 <lambdabot>       `Complex' is not applied to enough type arguments
11:08:07 <lambdabot>      Expected kind `?...
11:08:09 <Badger> er
11:08:12 <Badger> wrong.
11:08:17 <Badger> > 2 * pi :: CReal
11:08:19 <lambdabot>   6.2831853071795864769252867665590057683943
11:08:37 <Badger> need longer! :)
11:08:47 <vixey> bleh
11:08:54 <vixey> who can remember it 2 *
11:08:57 <vixey> > pi :: CReal
11:08:59 <lambdabot>   3.1415926535897932384626433832795028841972
11:09:44 <Badger> 3.1415926535897932384626433832795028841971693993
11:10:03 <Badger> woo, beat CReal
11:10:18 <vixey> 693993751058209 /
11:10:20 <vixey> maybe
11:10:34 <CakeProphet> :t log
11:10:35 <lambdabot> forall a. (Floating a) => a -> a
11:10:42 <CakeProphet> log is base e right?
11:10:47 <vixey> > log e
11:10:48 <Olathe> > floor (-1.5)
11:10:49 <lambdabot>   log e
11:10:50 <lambdabot>   -2
11:10:54 <Olathe> Eww.
11:10:56 <vixey> > log (exp 1)
11:10:57 <lambdabot>   1.0
11:10:57 <mreh> natural log is base e
11:10:58 <Olathe> What rounds down toward zero ?
11:11:05 <vixey> > log (exp 2)
11:11:06 <lambdabot>   2.0
11:11:14 <Olathe> @type floor
11:11:16 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:11:33 <Olathe> @hoogle RealFrac
11:11:33 <lambdabot> Prelude class (Real a, Fractional a) => RealFrac a
11:12:04 <Olathe> > truncate (-1.5)
11:12:06 <lambdabot>   -1
11:12:19 <vixey> > round (-1.5)
11:12:20 <lambdabot>   -2
11:12:53 <vixey> > double (-1.5)
11:12:54 <lambdabot>       Ambiguous occurrence `double'
11:12:54 <lambdabot>      It could refer to either `L.double',...
11:13:02 <mreh> hello all
11:13:15 <mreh> does haskell support reverse polish notation?
11:13:25 <CakeProphet> so if I want a function to produce a Random monad of an infinite list of numbers, and I want to describe the values as two alternating equations in a style similar to concatMap... what function am I looking for?
11:13:28 <mreh> i should say does GHC
11:13:44 <CakeProphet> mreh with operators it does.
11:13:57 <CakeProphet> > ?
11:13:58 <lambdabot>   <no location info>: parse error on input `?'
11:14:09 <CakeProphet> @let (?) = (+2)
11:14:10 <lambdabot>  <local>:9:0:
11:14:10 <lambdabot>      Multiple declarations of `L.?'
11:14:10 <lambdabot>      Declared at: <local>:1...
11:14:16 <CakeProphet> -sigh-
11:14:30 <CakeProphet> @src (!!!)
11:14:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:14:32 <b_jonas> @help
11:14:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:14:34 <mreh> CakeProphet: what kind of operators? binary ones
11:14:37 <CakeProphet> @src !!!
11:14:37 <lambdabot> Source not found. :(
11:14:52 <CakeProphet> > (!!!)
11:14:53 <lambdabot>       Overlapping instances for Show (a -> [Char])
11:14:53 <lambdabot>        arising from a use ...
11:15:10 <b_jonas> @type (!!!)
11:15:11 <CakeProphet> mreh, unary.
11:15:12 <lambdabot> forall a. (Show a) => a -> [Char]
11:15:23 <CakeProphet> > ("hi"!!!)
11:15:24 <mreh> unary?!
11:15:24 <lambdabot>   "\"hi\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
11:15:36 <mreh> + * - \ are all binary
11:15:54 <CakeProphet> yes, and they can't be used as postfix
11:15:59 <CakeProphet> (+2) is a function.
11:16:24 <CakeProphet> > (%)
11:16:25 <lambdabot>       Overlapping instances for Show (a -> a -> Ratio a)
11:16:25 <lambdabot>        arising from ...
11:16:29 <mreh> but that's curried from (+)
11:16:34 <CakeProphet> -nod-
11:16:46 <CakeProphet> > (100%)
11:16:47 <lambdabot>       Overlapping instances for Show (t -> Ratio t)
11:16:47 <lambdabot>        arising from a use...
11:16:52 <CakeProphet> :t (%)
11:16:53 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
11:17:02 <mreh> so i cant go * + 1 2 + 3 4
11:17:13 <vixey> mreh, wha??
11:17:25 <CakeProphet> mreh not in the postfix sense
11:17:25 <mreh> that's hsilop
11:17:32 <CakeProphet> you're certainly welcome to type it though
11:17:54 <CakeProphet> > (+) 1 2
11:17:55 <lambdabot>   3
11:17:59 <vixey> mreh, you can go   eval (Op (*) ::: Op (+) ::: N 1 ::: N 2 ::: Op (+) ::: N 3 ::: N 4) with suitable definitions
11:18:19 <mreh> > (*) (+) 1 2 (+) 3 4
11:18:20 <lambdabot>       No instance for (Num (a -> a -> a))
11:18:20 <lambdabot>        arising from a use of `+' at...
11:18:44 <CakeProphet> mreh, basically it's complaining because (+) is not a number and it's being used as an argument to (*)
11:18:49 <CakeProphet> prefix
11:19:02 <mreh> yeah, i see
11:19:15 <vixey> should probably hav wrote ::: N 4 ::: End I gues
11:19:25 <mreh> so it's a bit more complicated than a simple stack parser
11:19:26 <CakeProphet> > (*) ((+) 1 2) ((+) 3 4)
11:19:28 <lambdabot>   21
11:19:36 <vixey> mreh, no it's exactly that complicated
11:19:53 <b_jonas> or act on a list so you don't have to write all the triple colons
11:20:13 <b_jonas> like eval [Op (*), Op (+), N 1, N 2, N 3]
11:21:48 <Olathe> > getDigits 10^6 10^6
11:21:49 <lambdabot>       No instance for (Num (Int -> CReal -> [Char]))
11:21:49 <lambdabot>        arising from a us...
11:21:50 <Olathe> > getDigits 10^6 10^6 pi
11:21:51 <lambdabot>       No instance for (Num (Int -> CReal -> [Char]))
11:21:51 <lambdabot>        arising from a us...
11:22:00 <Olathe> > getDigits (10^6) (10^6) pi
11:22:16 <mreh> so how does GHC for example, take my list of tokens and translate that into lambda calculus?
11:22:16 <lambdabot>   thread killed
11:22:26 <RayNbow> @let toBase base = unfoldr (\x -> case x `divMod` base of {(0,0) -> Nothing; (c,d) -> Just (d,c)})
11:22:29 <lambdabot>  Defined.
11:22:32 <hcube> hi! does anybody know uulib parser compinator library? where can i find an example program for it?
11:22:48 <RayNbow> > toBase 10 1234567
11:22:50 <lambdabot>   [7,6,5,4,3,2,1]
11:23:02 <RayNbow> > toBase 2 32
11:23:04 <lambdabot>   [0,0,0,0,0,1]
11:23:24 * RayNbow wonders if there's a neater way to define toBase :)
11:23:26 <CakeProphet> http://hpaste.org/13369 - alright, I know this doesn't work, but I want to use that code to make the gauss function produce an infinite list of [cos(x)*g, sin(x)*g, cos(x2)*g, sin(x2)*g, ...]
11:24:04 <CakeProphet> in the form of Random [Float]   (or any other Num type that's applicable)
11:24:45 <CakeProphet> is there like a concatMap for monads?
11:26:13 <CakeProphet> :t sequence
11:26:14 <boegel> I'm doing these exercises of chapters 2/3 of Real World Haskell, and I totally forgot how easy it is to write bug-free programs in Haskell
11:26:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:26:16 <boegel> curse C
11:26:32 <mreh> has it ruined your life?
11:26:36 <mreh> it ruined mine
11:26:40 <CakeProphet> hmmm...
11:27:36 <wagle> quantum theory question: if we go around collapsing all these waveforms, how do new uncollapsed ones come into being?
11:28:17 <CakeProphet> > 2:[1,2]
11:28:19 <lambdabot>   [2,1,2]
11:28:30 <mib_c2zegu> ... wtf
11:28:33 <mib_c2zegu> > 2:[1,         2]
11:28:38 <lambdabot>   [2,1,2]
11:28:40 <CakeProphet> how do I append instead?
11:28:43 <mib_c2zegu> why the extra space, lambdabot?
11:28:45 <mib_c2zegu> CakeProphet: ++
11:28:45 <RayNbow> hmm...
11:28:46 <mib_c2zegu> :t (++)
11:28:49 <CakeProphet> ....o rite.
11:28:50 <lambdabot> forall a. [a] -> [a] -> [a]
11:28:50 <RayNbow> > toBase 10 0
11:28:55 <vixey> > [1,2] ++ [2]
11:29:00 <wagle> > [1,2] ++ [2]
11:29:03 <lambdabot>   mueval: Prelude.read: no parse
11:29:03 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
11:29:07 <mib_c2zegu> ...
11:29:08 <Olathe> > map (flip getDigit pi) [0..10]
11:29:10 <lambdabot>   [1,2,2]
11:29:10 <lambdabot>   [1,2,2]
11:29:11 <cizra> > [1,2] ++ [2]
11:29:13 <vixey> , [1,2] ++ [2]
11:29:17 <RayNbow> lambdabot's getting overloaded :p
11:29:18 <lambdabot>   [1,2,2]
11:29:18 <lambdabot>   [1,4,1,5,9,2,6,5,3,5,8]
11:29:20 <lunabot>  [1,2,2]
11:29:31 <mreh> dont you all have GHCi?!
11:29:44 <mib_c2zegu> we like sharing.
11:29:46 <boegel> mreh: what's GHCi?
11:29:47 <wagle> not as a shared resource
11:29:53 <boegel> mreh: does it use lambdabot ?
11:30:23 <mreh> glasgow haskell compiler interactive
11:30:30 <cizra> mreh: Glorious!
11:30:34 <mreh> you use it on your desktop
11:30:35 <wagle> "glorious"
11:30:48 <mib_c2zegu> :t fix
11:31:02 <wagle> stop saying what i'm too slow to say first!
11:31:07 <lambdabot> thread killed
11:31:13 <mib_c2zegu> :t fix
11:31:22 <mreh> glorious what?
11:31:30 <lambdabot> thread killed
11:31:31 <wagle> glorious haskell compiler
11:31:35 <mib_c2zegu> glorious haskell compiler
11:31:38 <wagle> ha!
11:31:44 <mreh> nah, it's definitely glasgow
11:31:53 <Gracenotes> mib_c2zegu: fix :: (a -> a) -> a
11:31:54 <wagle> just ask spj
11:32:20 <cizra> mreh: How do you explain this? http://www.haskell.org/ghc/docs/latest/html/users_guide/
11:32:24 <cizra> mreh: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.10.1
11:32:27 <Olathe> The glass cow Haskell compiler.
11:33:06 <cizra> the glass cow has kellcom piler
11:33:35 <Gracenotes> The Gelatin-Cooking Haskell Contraption
11:33:44 <mib_c2zegu> The thing
11:33:45 <Olathe> That would be a nice logo for ghc.
11:33:46 <CakeProphet> aaaah... there's some function I need to know the name of.
11:33:47 <Olathe> A glass cow.
11:33:49 <CakeProphet> but I don't know what it is.
11:33:53 <mib_c2zegu> CakeProphet: @hoogle type
11:34:17 <Olathe> With lambda spots.
11:34:40 <Gracenotes> Olathe: and the udders are bind operators?
11:34:47 <Olathe> Heheh
11:34:53 <CakeProphet> :t concat
11:35:01 <CakeProphet> :t concatMap
11:35:15 <Gracenotes> concat :: [[a]] -> [a]
11:35:20 <Gracenotes> concatMap :: (a -> [b]) -> [a] -> [b]
11:35:26 <Gracenotes> (I'm feeling a bit bored...)
11:35:41 <Olathe> Poor lambdabot.
11:35:51 <Olathe> Can't handle using CReals heavily.
11:36:49 <b_jonas> @let @let evalr :: [Either (a->a->a) a] -> (a, [Either (a->a->a) a]); evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r); } in fst (evalr s);
11:36:53 <b_jonas> @let evalr :: [Either (a->a->a) a] -> (a, [Either (a->a->a) a]); evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r); } in fst (evalr s);
11:37:09 <b_jonas> @let eval s = let { evalr :: [Either (a->a->a) a] -> (a, [Either (a->a->a) a]); evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r);
11:37:15 <vixey> o_o
11:37:39 <b_jonas> @run eval [Left (-), Left (*), Right 4, Right 5, Right 1]
11:37:46 <b_jonas> @bot
11:37:47 <lunabot>  :)
11:38:33 <mreh> is function application always left associative?
11:38:55 <Olathe> I think it's both ways.
11:38:56 <mib_c2zegu> http://lolinator.com/lol/www.haskell.org.monadtransformer.parallelnetz.de/haskellwiki/Monad
11:39:12 <Olathe> It's fully associative.
11:39:23 <mreh> how does it choose
11:39:28 <Olathe> I'm not sure how it's parsed in specific compilers, though.
11:39:47 <Olathe> I assume by the definition of (.)
11:39:50 <opqdonut> function application is not fully associative
11:39:50 <mreh> lambda calculus is always left associative
11:39:56 <opqdonut> function _composition_ is
11:40:05 <Olathe> Oh, I misread. Sorry.
11:40:13 <opqdonut> mreh: yes, it is always left associative
11:40:23 <opqdonut> exactly because lambda calculus is
11:40:30 <b_jonas> so what's happened to lambdabot?
11:40:32 <opqdonut> and also because it makes curried functions behave nicer
11:40:51 <mreh> can i force it to be right assoc?
11:41:26 <mreh> haha
11:41:30 <mreh> with brackets
11:41:33 <mreh> duh
11:41:49 <mreh> so what does the composition operator do?
11:42:13 <Olathe> It creates a function that applies both.
11:42:27 <Olathe> (a.b) x = a (b x)
11:42:34 <mreh> yeah
11:42:36 <ddarius> associativity is a superficial syntactic concern.  Application being left associative is just a convention and means nothing to the lambda calculus.
11:42:45 <ddarius> @src (.)
11:42:52 <lambdabot> (f . g) x = f (g x)
11:42:58 <cizra> > ((take 1) . (take 1)) [[1, 2], [3, 4]]
11:43:05 <mreh> i know that, i just want to know how to write readable code
11:43:06 <lambdabot>   [[1,2]]
11:43:11 <opqdonut> ddarius: yes but lambda calculus is left-associative
11:43:13 <mreh> i mean have you SEEN lisp
11:43:16 <opqdonut> mreh: do you know about $?
11:43:20 <mreh> no
11:43:27 <cizra> > (head . head) [[1, 2], [3, 4]]
11:43:31 <Olathe> f.g.h.i.j.k $ x
11:43:34 <lambdabot>   1
11:43:35 <Olathe> That's how I usually do it.
11:43:37 <opqdonut> > head . head $ [[1, 2], [3, 4]]
11:43:39 <lambdabot>   1
11:43:40 <Olathe> Yay lambdabot !
11:43:42 <cizra> mreh: There's a nice simple example
11:43:54 <mreh> @src head
11:43:54 <lambdabot> head (x:_) = x
11:43:54 <lambdabot> head []    = undefined
11:44:00 <sjanssen> opqdonut: correction, the most common syntax for lambda calculus is left associative
11:44:01 <Olathe> > head undefined
11:44:03 <lambdabot>   * Exception: Prelude.undefined
11:44:32 <opqdonut> mreh: so instead of writing f (g (h x)) you write f . g $ h x or f . g . h$ x
11:45:04 <Olathe> The first one is Satanic, so use the second one.
11:45:04 <opqdonut> sjanssen: well it depends on the definition, but yeah, mostly chain application is syntactic sugar
11:45:42 <mreh> does RWH have a good solid introduction to syntax?
11:45:51 <crathman> opqdonut: could you give a brief description of the  $ operator?
11:46:42 <mreh> its like a dot, but for an operator
11:47:01 <opqdonut> crathman: "f $ somethinglong" means "f (somethinglong)"
11:47:07 <opqdonut> ?src f
11:47:08 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:47:09 <mreh> yeah, see
11:47:12 <opqdonut> gah
11:47:15 <opqdonut> ?src ($)
11:47:15 <asgaroth> It has a very low fixity so that using it in that way is possible
11:47:16 <lambdabot> f $ x = f x
11:47:21 <opqdonut> indeed
11:47:26 <opqdonut> :i ($)
11:47:29 <ddarius> ($) = id
11:47:40 <opqdonut> how do i get lambdabot to tell the fixity
11:47:43 <opqdonut> ?info ($)
11:47:44 <lambdabot> ($)
11:47:49 <opqdonut> ...
11:47:51 <ddarius> > ($ $)
11:47:52 <lambdabot>   <no location info>: parse error on input `$'
11:47:53 <crathman> opqdonut: thanks...  see it sprinkled in RWH...  just didn't see it explained
11:48:00 <Olathe> @
11:48:31 <vixey> f $ x = f x is the definition
11:48:43 <opqdonut> Olathe: @ and ? are both command chars, they're interchangeable
11:48:56 <vixey> and since function application binds tighter than $ (and ops in general),
11:49:10 <vixey> f x $ g h = (f x) (g h)
11:51:36 <mreh> haskell takes these laws of associativity to a whole new level, seeing as it's functional
11:51:43 <mreh> or higher order
11:52:34 <CakeProphet> @src liftM2
11:52:34 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:53:12 <mreh> is there a rule to the highest number of function applications you can apply before a definition becomes too obfuscated
11:53:56 <CakeProphet> @src liftM
11:53:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:54:14 <ddarius> Associativity is exactly the same in Haskell as it is in every other syntax.
11:55:45 <Olathe> @undo do { x1 <- m1; return (f x1) }
11:55:45 <lambdabot> m1 >>= \ x1 -> return (f x1)
11:56:00 <Olathe> @pl \ x1 -> return (f x1)
11:56:00 <lambdabot> return . f
11:58:21 <mreh> ill just read the haskell98 specification
11:58:28 <mreh> then i'll start seeing the matrix
12:03:15 <enticingjelly> I often have the following pattern:
12:03:27 <enticingjelly> map (uncurry f) (zip a b)
12:03:41 <enticingjelly> is there something quicker?
12:03:50 <arjanb> :t zipWith
12:03:51 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:04:15 <enticingjelly> oh. wouldn't have guessed that name, but it makes sense. thanks.
12:04:31 <paolino> why Num is not implying Ord ?
12:05:01 <b_jonas> because complex numbers are not ordered
12:05:14 <vixey> does anyone have any links to/code/references about checking alpha-beta-eta equality for typed lambda terms?
12:05:25 <vixey> I found a couple things on notts website but are there any more around?
12:05:29 <enticingjelly> and if I want to unzip the result? %)
12:06:00 <b_jonas> enticingjelly: zipWith
12:06:02 <b_jonas> @type zipWith
12:06:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:06:08 <paolino> thanks b_jonas
12:09:11 <Olathe> > zip3With
12:09:13 <lambdabot>   Not in scope: `zip3With'
12:09:27 <pumpkin> zipWith3?
12:09:33 <Olathe> > zipWith3
12:09:35 <lambdabot>       Overlapping instances for Show
12:09:35 <lambdabot>                                  ((a -> ...
12:09:37 <Olathe> Ahh.
12:09:42 <Olathe> @type zipWith 4
12:09:43 <lambdabot> forall a b c. (Num (a -> b -> c)) => [a] -> [b] -> [c]
12:09:44 <Olathe> @type zipWith4
12:09:45 <lambdabot> forall a b c d e. (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
12:10:13 <Olathe> @type zipWith7
12:10:15 <lambdabot> forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
12:10:46 <Olathe> @type id :: (omg -> omg)
12:10:47 <lambdabot> forall omg. omg -> omg
12:11:56 <b_jonas> @src OneOf20
12:11:57 <lambdabot> Source not found. Maybe you made a typo?
12:14:44 <hoknamahn> guys, what is better to use, tabs or spaces?
12:15:09 <b_jonas> hoknamahn: that's a holy war topic
12:15:14 <Olathe> Tabs are the work of SATAN !
12:15:18 <b_jonas> so whichever you prefer
12:15:33 <Olathe> Yes, if you prefer SATAN, go ahead and use tabs !
12:15:34 <hoknamahn> but what people usually use?
12:15:44 <hoknamahn> okay, spaces than :)
12:15:46 <hoknamahn> thanks
12:18:25 <tautologico> hm... I've got no ~/.cabal/config file after installing cabal-install
12:24:48 <b_jonas> lambdabot came up?
12:25:11 <b_jonas> @let eval s = let { evalr :: [Either (a->a->a) a] -> (a, [Either (a->a->a) a]); evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r);
12:25:11 <lambdabot>   Parse error
12:25:58 <b_jonas> @let eval s = let { evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r);
12:25:58 <lambdabot>   Parse error
12:26:05 <b_jonas> yeah, parse error but where
12:26:07 <b_jonas> so useful
12:26:16 <Olathe> > let eval s = let { evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r);
12:26:18 <lambdabot>   <no location info>: parse error on input `)'
12:26:34 <Olathe> > let eval s = let { evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r) in eval
12:26:36 <lambdabot>   <no location info>: parse error on input `in'
12:26:40 <BONUS_> @pl \a -> f c a xs
12:26:40 <lambdabot> flip (f c) xs
12:26:50 <b_jonas> oh, the end is missing
12:27:06 <b_jonas> @let eval s = let { evalr (Right x : r) = (x, r); evalr (Left f : p) = let { (x, q) = evalr p; (y, r) = evalr q; } in (f x y, r); } in fst (evalr s)
12:27:08 <lambdabot>  Defined.
12:27:15 <Olathe> > eval "Hello"
12:27:16 <lambdabot>   Couldn't match expected type `Either (a -> a -> a) a'
12:27:22 <Olathe> Ahh.
12:27:24 <b_jonas> @run eval [Left (-), Left (*), Right 4, Right 5, Right 1]
12:27:24 <Olathe> @type eval
12:27:25 <lambdabot>   19
12:27:26 <lambdabot> forall a. [Either (a -> a -> a) a] -> a
12:27:41 <b_jonas> @run eval [Left (*), Right 4, Left (-), Right 5, Right 1]
12:27:43 <lambdabot>   16
12:27:46 <b_jonas> works
12:28:02 <b_jonas> @type eval
12:28:03 <vixey> b_jonas, wonder if it could be made well typed
12:28:03 <lambdabot> forall a. [Either (a -> a -> a) a] -> a
12:28:08 <Olathe> @run eval [Left (-), Left (*), Right a, Right b, Right c]
12:28:10 <lambdabot>   a * b - c
12:28:23 <vixey> b_jonas, so tsuff like   N 1 ::: N 2 :: EQL :: IF ...
12:28:24 <Olathe> @run eval [Left (-), Right a, Left (*), Right b, Right c]
12:28:25 <lambdabot>   a - b * c
12:28:32 <Olathe> Ahh.
12:29:03 <Olathe> @run eval [Left (-), Right a, Right b, Left (*), Right c]
12:29:04 <lambdabot>   a - b
12:29:16 <Olathe> @run eval [Left (-), Right a, Right b, Right c]
12:29:17 <lambdabot>   a - b
12:29:22 <b_jonas> vixey: how is that different?
12:29:53 <vixey> b_jonas, talking about types mostly
12:30:31 <ttt--_> how come it can deal with a,b,c?
12:30:33 <b_jonas> lambdabot doesn't have @data and @class and @instance statements so we can't try taht online
12:30:42 <b_jonas> ttt--_: magic of SimpleReflect
12:30:48 <Olathe> @type a
12:30:49 <lambdabot> Expr
12:30:56 <Olathe> @index Expr
12:30:57 <lambdabot> bzzt
12:31:00 <Olathe> bzzt ?!
12:31:09 <Olathe> bzzt has a lot of things in it.
12:32:37 <MyCatVerbs> Olathe: it's the one that defines (forall t. (Typeclass t) => forall a. (t a)), if you'll forgive the pseudo-skell. =)
12:33:37 <b_jonas> (also @type and @newtype and @default for the other top-level definitions)
12:33:51 <Olathe> Heheh
12:34:18 <b_jonas> (or maybe @let or a single new command @decl should allow data, type, newtype, class, instance declarations)
12:37:56 <BrokenClockwork> Is there a Haskell function to get the absolute value of an Integer?
12:38:03 <vixey> :t abs
12:38:04 <lambdabot> forall a. (Num a) => a -> a
12:38:37 <Olathe> > abs ((-5)::Integer)
12:38:38 <lambdabot>   5
12:38:44 <BrokenClockwork> thanks :)
12:41:04 <tautologico> hm, now parsec is 2.1.something, there's a 3.0 available and cabal upgrade parsec says there's nothing to do
12:42:31 <vixey> > let pow i 0 = i ; pow i n = i^pow (n-1) ; b n = pow n n in b 0
12:42:31 <lambdabot>       No instance for (Integral (t -> t))
12:42:32 <lambdabot>        arising from a use of `b' at...
12:42:37 <vixey> > let pow i 0 = i ; pow i n = i^pow i (n-1) ; b n = pow n n in b 2
12:42:38 <lambdabot>   16
12:42:40 <vixey> > let pow i 0 = i ; pow i n = i^pow i (n-1) ; b n = pow n n in b 3
12:42:56 <lambdabot>   thread killed
12:43:04 <vixey> > let pow i 0 = i ; pow i n = i^pow i (n-1) ; b n = pow n n in b 3 :: Int
12:43:05 <lambdabot>   7099350254962247995
12:43:09 <vixey> > let pow i 0 = i ; pow i n = i^pow i (n-1) ; b n = pow n n in b 4 :: Int
12:43:10 <lambdabot>   4
12:43:11 <Olathe> @pl \i n -> i^pow (n - 1)
12:43:12 <lambdabot> (. (pow . subtract 1)) . (^)
12:43:58 <Olathe> @pl \i -> i^pow (i - 1)
12:43:59 <lambdabot> ap (^) (pow . subtract 1)
12:48:01 <b_jonas> oh
12:57:11 <weilawei> anyone use the haskell mode for vim by claus reinke? i sorta have it installed.. i still get all sorts of errors on things like the haskell-aware completion.
12:57:47 <ozy`> weilawei: I didn't bother trying to fix those... just disabled it altogether
12:58:19 <weilawei> ozy`: darn.. i had such high hopes for it.
12:58:44 <ozy`> I just use the regular word completion
12:58:49 <ozy`> it's usually enough
12:59:27 <ozy`> I'm sure someone out there with superior vim-hacking powers will debug it and release a version that works
12:59:38 <Gracenotes> hm, is there anything of type State StdGen a?
13:00:22 <Gracenotes> I mean, all you have to do is do { st <- get; let (a, st1) = random st; put st1; return a }
13:00:36 <Gracenotes> but if there were something built-in, 'twould be nice :)
13:01:14 <weilawei> ozy`: definitely won't be me. vim script boggles.
13:01:33 <weilawei> not to mention that im simultaneously trying to learn haskell
13:01:57 <ozy`> weilawei: for the time being, just use ^N/^P and worry about the indentation, if anything
13:02:14 <pejo> There are definitely vim users in here, but I'm not sure what addons they are using.
13:02:26 <vixey> http://www.dcs.ed.ac.uk/home/pgh/pt-ordinals.html
13:02:57 <weilawei> ozy`: I grabbed Align to help with that which DOES work
13:03:29 <ozy`> weilawei: yeah, Align is useful. I can't be bothered to set up AutoAlign for Haskell though
13:04:39 <weilawei> ozy`: well, thank you for the suggestions. I should get to actually coding and learning now.
13:04:41 <weilawei> byes!
13:04:48 <ozy`> later
13:10:59 <RayNbow> hmm, does an unfold function exists which is similar to unfoldr, except that the resulting list is reversed?
13:12:05 <Zao> reverse.unfoldr ? :)
13:12:17 <vixey> :t unfoldl
13:12:18 <RayNbow> I'd like to avoid reverse :p
13:12:18 <lambdabot> Not in scope: `unfoldl'
13:12:21 <vixey> no
13:12:33 <vixey> @src unfoldr
13:12:33 <lambdabot> unfoldr f b  = case f b of
13:12:33 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
13:12:33 <lambdabot>    Nothing        -> []
13:12:48 <RayNbow> I can produce the items in reversed order using explicit recursion and an accumulator
13:12:56 <RayNbow> but I don't like that :p
13:13:21 <b_jonas> why not reverse?
13:13:52 <vixey> I don't think you can do better than reversing at the end
13:14:27 <vixey> change  a : unfoldr f new_b  into  unfoldr f new_b ++ [a]
13:14:52 <vixey> that's obvious n^2 blowup, but if you use an accumulator you just get the same behaviour as  reverse .
13:21:52 <weilawei> how do I permanently set my editor and prompt for ghci?
13:22:04 <Zao> Doesn't it look at $EDITOR?
13:22:23 <weilawei> hrm, lemme see
13:22:27 <RayNbow> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
13:23:03 <weilawei> yep it does, thanks!
13:23:05 <vixey> http://www.haskell.org/haskellwiki/Eta_conversion hrfmf
13:24:11 <vixey> nothing about _typed_ eta conversion
13:24:42 <opqdonut> it's a wiki, fix it
13:25:04 <Olathe> > fix wiki
13:25:06 <lambdabot>   Not in scope: `wiki'
13:25:20 <vixey> opqdonut, I'm the one looking for information
13:25:24 <BONUS_> what do you guys think about this (hopefully) fault tolerant RPN calculator function http://hpaste.org/13371 re: elegance, terseness
13:25:57 <vixey> BONUS_, very very repitious
13:26:07 <pumpkin> aw
13:26:12 <BONUS> yeah but you can't get away with some repetition here imho
13:26:15 <Olathe> BONUS: Move the Nothings to the bottom.
13:26:19 <vixey> BONUS, why don't you have a table for unary and binary ops
13:26:23 <memento> if i have an application with plenty of modules, and i load the module containing main into the ghci how can i move scope wherever i want? :break first argument can be a module but it doesn't work for :force so how can i "cd" into the desired scope?
13:26:40 <pumpkin> you could have a lookup-able list of string-function pairs
13:26:48 <BONUS> vixey: i thought of that but i thought that would be more complex
13:26:59 <BONUS> and if i wanted n-ary operators then i'd have to have a lookup table
13:27:02 <vixey> BONUS, ah well you call it
13:27:23 <Olathe> Hmm...
13:27:32 <pumpkin> BONUS: can't you move all those Nothings into one?
13:27:47 <BONUS> don't think so, i have to pattern match against the operator strings
13:27:57 <BONUS> although i'd like to somehow get rid of that repetition
13:28:03 <vixey> pumpkin, it would use  reads ns  on them if you did that
13:28:28 <Olathe> @hoogle a -> [a] -> Maybe a
13:28:29 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:28:29 <lambdabot> Prelude asTypeOf :: a -> a -> a
13:28:29 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
13:28:34 <pumpkin> well if reads fails, then nothing
13:28:51 <pumpkin> it seems like the last case already takes care of the Nothing matches?
13:29:02 <pumpkin> because reads on "log" will fail
13:29:03 <BONUS> hmm
13:29:13 <BONUS> i think you may be right
13:29:25 <pumpkin> and you're requiring there be no "leftover" in the reads with your pattern
13:29:49 <vixey> BONUS, actually just realized with an op table it's pretty much exactly what you've written
13:29:49 <BONUS> yeah actually i can easily remove those _ .> matches
13:30:16 <vixey> (except it means you have only to write one case, not a sucess/fail case for each op)
13:30:45 <BONUS> hmm
13:30:53 <Olathe> > let find y [] = Nothing; find y ((x,f):xs) = if x == y then Just f else find y xs in find '+' [('*', (*)), ('+', (+))]
13:30:55 <lambdabot>       Overlapping instances for Show (a -> a -> a)
13:30:55 <lambdabot>        arising from a use ...
13:30:59 <BONUS> but pumpkin is right though, i can remove those Nothings
13:31:01 <BONUS> like so http://hpaste.org/13371#a1
13:31:04 <Olathe> Hmm, typechecking.
13:31:10 <BONUS> so yeah it's pretty much like a lookup table
13:31:14 <BONUS> i mean op table
13:31:40 <vixey> it's calling  reads ns  on stuff like "^" now though, you probably know that .. but I don't know if it matterns or not
13:31:54 <b_jonas> you could make it use a lookup table actually... if you wanted to add much more operations it would probably be better though
13:31:56 <BONUS> yeah, but that's cool because it'll fail anyway and return Nothing
13:31:57 <mmorrow> vixey: how's your ReadP hacking going?
13:32:02 <vixey> mmorrow, ugh oh god
13:32:07 <mmorrow> heh
13:32:35 <vixey> mmorrow, ok so I found a bug in my parser  (a) b  can't parse for some reason
13:32:43 <BONUS> b_jonas: like this you can add operators too, you just can't import the op table from another module
13:32:44 <BONUS> hmm
13:32:56 <vixey> mmorrow, (this is after I found that Shunting Yard isn't correct and PEG is bloody boring to formalize)
13:33:25 <vixey> mmorrow, so I thought, I will put ReadP in Coq and get a sure program that doesn't break
13:33:29 <b_jonas> BONUS: but it's a bit redundnat if you add new operators
13:33:45 <BONUS> yeah the Just is redundant
13:33:53 <vixey> mmorrow, and I found that ReadP does this really interesting lexicographic recursion on functionals, so to convince Coq that it terminates I have to use transfinite induction
13:33:57 <mmorrow> vixey: hmm, by (a) b you mean "(" exp ")" exp ?
13:33:58 <BONUS> i'll try and make a version with an op table and see which looks better :)
13:34:19 <vixey> mmorrow, and yeah I spend a day reading about cardinals and ordinals and all this without fixing my code .. but at least I found some new math
13:34:21 <b_jonas> not only the just
13:34:33 <vixey> yes
13:34:36 <b_jonas> I thought you could make an operator table each for unary, binary, and ternary operators
13:34:40 <vixey> even that parser I put on moonpatio doesn't work
13:34:42 <Olathe> You can.
13:34:44 <BONUS> hmm, but with an OP table i have to check if the pattern matching fails. here it's convinient that they just fall through
13:35:17 <vixey> so, not even going to fix it, I have to take a totally different approach to parsing
13:35:21 <mmorrow> vixey: heh. so i'm not familiar with tranfinite induction. is this a feasible strategy (feasible wrt effort vs. gain)?
13:35:27 <vixey> had so much trouble trying to get something that works
13:35:41 <centrinia> Euler 17 was lame. :(
13:35:43 <BONUS> like [("*", add), .. ]  where add (x:y:ys) = Just $ x+y:ys; add _ = Nothing
13:35:48 <pumpkin> centrinia: aw
13:36:00 <mmorrow> vixey: don't quit on account of temporary pain (if it really is just temporary).
13:36:03 <pumpkin> centrinia: some of them are pretty tedious and boring
13:36:14 <pumpkin> centrinia: that's one of them :P
13:36:15 <vixey> mmorrow, not quitting just moving the goal posts
13:36:26 <mmorrow> vixey: nice.
13:36:50 <centrinia> Does anyone want a function of type (Integral a) => a -> ShowS that will produce the English dictation of any number in [0..9999] ?
13:36:52 <Olathe> BONUS [("+", x + y:ys), ("log", log x:y:ys)]
13:36:52 <mmorrow> vixey: so what are your initial thoughts on this new approach?
13:37:04 <vixey> mmorrow, oh I don't have any new approach yt
13:37:16 <vixey> mmorrow, when I tried to code ReadP in Coq I got distracted by all this amazing mathematics
13:37:42 <mmorrow> i can relate to that for sure
13:37:53 * vixey (don't employ me to program something .. :p)
13:37:59 <mmorrow> heh
13:38:07 <BONUS> Olathe: yeah but what if you get a stack of [10] for a "+"
13:38:13 <BONUS> there's just one element on the stack but you need 2
13:38:17 <pumpkin> centrinia: it might make life easier for future eulerians :P but other than that, can't think of much of a use for it, other than maybe some webapps?
13:38:27 <pumpkin> centrinia: can't hurt to increase the number of hackage packages though :P
13:39:05 <b_jonas> BONUS: I'm thinking of a separate table for each arity
13:39:38 <BONUS> maybe yeah
13:39:38 <BMeph> centrinia: Whip up an inverse function, and put it on Hackage - another tool never hurts. :)
13:39:50 <BONUS> or a mapping from operator string to (arity, function)
13:40:01 <BONUS> and then you check if the arity is low enough for the list size
13:41:12 <centrinia> Okay, so I should have a function that parse something like "five hundred and twenty seven plus fifty two" and produce a number 579 as well? :p
13:41:12 <b_jonas> that would be hard
13:41:18 <b_jonas> what type would the function have?
13:41:24 <BONUS> yeah
13:41:29 <BONUS> totally forgot about that haha
13:41:30 <Gracenotes> @src sequence
13:41:31 <lambdabot> sequence []     = return []
13:41:31 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:41:31 <lambdabot> --OR
13:41:31 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:41:54 <Gracenotes> @src sequence_
13:41:55 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:41:58 <BONUS> maybe have the function be of type [a] -> a
13:42:00 <BONUS> i mean
13:42:02 <b_jonas> yes
13:42:03 <BONUS> [a] -> [a]
13:42:06 <b_jonas> and you'd have wrappers
13:42:11 <b_jonas> for unary and binary functions
13:42:16 <BMeph> vixey: Sorry to hear about your parser woes, especially since Slava's video makes PEGsetup look like a breeze (in Factor, anyway). :)
13:42:21 <wli> data Oper = OperUnary (t -> t) | OperBinary (t -> t -> t) | OperTernary (t -> t -> t -> t)
13:42:33 <b_jonas> and then you'd have a table from unary and binary and map them to form the general table
13:42:36 <BONUS> w00t
13:42:37 <b_jonas> whatever you want
13:42:40 <vixey> BMeph, ah it is good stuff really
13:42:51 <vixey> BMeph, it's just funny how wrong everything I tried so far went :p
13:43:11 * BMeph nods sympathetically
13:44:45 <mmorrow> just always remember how great and instantaneously motivating it is when all of a sudden something works. perfectly. and you forget about all the trouble it took to get to that point. i try to do this always, but it's hard.
13:47:06 <vixey> data RPN t where  END :: RPN () ; NUM :: Integer -> RPN z -> RPN (Integer, z) ; BIN :: (a -> b -> c) -> RPN (a, (b, z)) -> RPN (c, z)
13:47:06 <vixey> eval :: RPN t -> t ; eval END = () ; eval (NUM i tl) = (i, eval tl) ; eval (BIN (*) tl) = case eval tl of (u, (v, tl)) -> (u*v, tl)
13:47:24 <BONUS> whoa
13:48:22 <vixey> > eval (NUM 88 (BIN (+) (BIN (*) (NUM 3 (NUM 5 (NUM 6 (NUM 222 END)))))))
13:48:22 <vixey> (88,(21,(222,())))
13:48:22 <lambdabot>   Not in scope: data constructor `NUM'Not in scope: data constructor `BIN'Not...
13:49:13 <NameAlreadyInUse> i just don't understand how something like: "drawInt x y = getStdRandom (randomR (x,y))" can return a different result each time
13:49:44 <BONUS> getStdRandom (randomR (x,y)) produces an IO action
13:49:48 <BONUS> :]
13:50:47 <NameAlreadyInUse> =\
13:50:50 <NameAlreadyInUse> i don't get it
13:50:52 <Olathe> > getStdRandom (randomR (1,2))
13:50:54 <lambdabot>   * Exception: "<IO Integer>"
13:51:08 <Olathe> @type getStdRandom
13:51:10 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
13:51:26 <Olathe> @hoogle StdGen
13:51:27 <lambdabot> System.Random data StdGen
13:51:27 <lambdabot> System.Random getStdGen :: IO StdGen
13:51:27 <lambdabot> System.Random mkStdGen :: Int -> StdGen
13:51:53 <NameAlreadyInUse> so it isn't really returning something different each time?
13:52:06 <BONUS> well, in essence, it isnt
13:52:10 <BONUS> when you see something like
13:52:11 <BONUS> IO a
13:52:25 <BONUS> read that as: an I/O action that will have as its result some a
13:52:35 <NameAlreadyInUse> ah, ok
13:52:48 <NameAlreadyInUse> then how does that a differ each time?
13:52:51 <BONUS> an I/O action can have a different result in itself if it's run twice
13:53:13 <BONUS> for isntance if you have an I/O action that has its result the current time
13:54:06 <b_jonas> vixey: heh, that's funny, it uses polymorphic recursion
13:54:23 <vixey> polymorphic recursion is my new discovery :)
13:54:23 <NameAlreadyInUse> so it is an inbuilt thing that an I/O action can have a different result for each run?
13:54:46 <BONUS> yeah, you have to have some way to interact with the environment
13:56:16 <Olathe> > randoms (mkStdGen 5)
13:56:18 <lambdabot>   [7776561651304326943,2660592214809256573,-198934792153589140,-4772860058847...
13:56:51 <Olathe> > randoms (mkStdGen 5) :: [Word8]
13:56:53 <lambdabot>   [137,175,57,114,80,85,56,50,236,115,255,143,188,105,15,159,45,3,179,64,15,1...
13:57:01 <vixey> http://www.cs.rhul.ac.uk/~robin/weyl/index.html
13:57:17 <vixey> ^this "Plastic" language is implemented in haskell
13:57:29 <NameAlreadyInUse> how does the state change if haskell is purely functional, then?
13:57:29 <Olathe> > randoms (mkStdGen 5) :: String
13:57:31 <lambdabot>   "\789129\513711\458041\197490\513104\952661\245560\479026\883436\522611\791...
13:58:57 <vixey> but they don't release the haskell source :(
13:59:08 <pumpkin> NameAlreadyInUse: you thread the state through transparently
13:59:37 <BONUS> basically you have things that are called I/O actions
13:59:48 <BONUS> they go out and do something in the real world
13:59:50 <BONUS> like reading a file
14:00:00 <BONUS> and within them they can report results from the real world
14:00:18 <Olathe> > map (chr.(+97).(flip mod 26)) (randoms (mkStdGen 5))
14:00:19 <BONUS> and you can glue together several I/O actions by using do notation
14:00:20 <lambdabot>   "xbobuvqyrgcyhcgircqopgknkvijygasgtttyainhzfhiziozmfbiegpgopoixtlsmgsuoyqxa...
14:00:35 <BONUS> i don't know if you've used do notation
14:00:45 <Cale> NameAlreadyInUse: Parameters to functions can be different.
14:00:46 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:01:09 <Cale> NameAlreadyInUse: Of course, in the IO monad, you can have mutable state as well.
14:01:31 <adekoba> is there anything glaringly wrong with this code? I tried to make the binary package strict: http://hpaste.org/13372
14:01:35 <BONUS> when you have a program like main = do a <- getLine; putStr a;
14:01:42 <Cale> NameAlreadyInUse: But primarily, the only variables which actually vary are the parameters to functions, which can have different values each time the function is applied.
14:02:00 <BONUS> it basically glues getLine and putStr into one I/O action and then when you run your program, it performs the I/O action
14:02:06 <BONUS> that will go out into the real world and get something
14:02:21 <BONUS> so I/O actions can have different results
14:02:30 <BONUS> when run two times
14:02:35 <BONUS> but pure functions can't
14:02:43 <NameAlreadyInUse> ok, i think i see
14:03:18 <Olathe> > let f = all id.zipWith (==) "haskell".map (chr.(+97).(flip mod 26)).randoms.mkStdGen in filter f [0..1000]
14:03:20 <lambdabot>   []
14:03:24 <Olathe> Darn !
14:03:25 <BONUS> dont want to toot my own horn, but i'd suggest skimming over the first section on http://learnyouahaskell.com/input-and-output
14:03:28 <BONUS> :)
14:03:49 <BONUS> i think I/O actions and how they work is explained quite plainly there
14:04:02 <BONUS> (by first section in mean the hello world one)
14:04:04 <pumpkin> yup
14:04:08 * pumpkin toots BONUS' horn
14:04:11 <NameAlreadyInUse> ah ok
14:04:12 <BONUS> :]
14:04:24 <pstickne> is range syntax a special construction?
14:04:39 <BONUS> it's syntactic sugar
14:04:44 <BONUS> for enumFromTo
14:05:00 <BONUS> > enumFromTo 1 5
14:05:01 <lambdabot>   [1,2,3,4,5]
14:05:06 <NameAlreadyInUse> but to clarify, the only way to implement something like getStdRandom is to use I/O actions?
14:05:06 <pumpkin> how bout the one with the increment?
14:05:13 <BONUS> uh thats
14:05:15 <BONUS> whats that again
14:05:19 <pumpkin> there's a random monad too
14:05:23 <BONUS> enumFromThenTo?
14:05:27 <pstickne> thanks :)
14:05:28 <BONUS> lemme check
14:05:35 <BONUS> yeah
14:05:40 <pumpkin> @hoogle enumFrom
14:05:40 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
14:05:40 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
14:05:40 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
14:05:45 <BONUS> you can do stuff like
14:06:04 <BONUS> data Day = Monday | Tuesday | Wednesday ... Sunday deriving (Show, Enum)
14:06:06 <BONUS> and then you can do like
14:06:12 <BONUS> [Monday .. Wednesday]
14:06:24 <vixey> is LHC any different to JHC currently?
14:06:29 <pumpkin> btw, bonus makes sure (s/he) takes plenty of acid before posting to twitter
14:06:37 <BONUS> haha
14:06:46 <BONUS> haskell is my drug :]
14:06:49 <BONUS> and crack cocaine
14:07:09 <mreh> my uncle asked me what kind of drugs i was taking these days
14:07:15 <BONUS> haha
14:07:20 <pumpkin> :o
14:07:34 <mreh> he's irish
14:07:39 <pumpkin> I mean, unicorns, fuzzy rainbows, and a weird pixelated smiley face
14:07:41 <mreh> they have a sense of humour aparently
14:08:14 <BONUS> hehe
14:08:14 <pumpkin> I'd follow you on twitter but I'm scared to
14:08:26 <BONUS> pumpkin: that smiley face is from my avatar http://fi.somethingawful.com/customtitles/title-bonus-3.gif :]
14:08:30 <vixey> heh "# Devoted to avoid unsafe IO even if performance has to take a hit."
14:08:35 <pumpkin> lol
14:09:03 <flux> sort of related: story is, a kid was disciplined, after a teacher hearing him saying that "he uses php"
14:09:03 <pumpkin> BONUS: so you hang out on somethingawful? that explains more of it
14:09:09 <BONUS> haha
14:09:45 <pstickne> flux:  that the teacher used php? :)
14:10:07 <b_jonas> flux: he deserved it
14:10:07 <vixey> darcs says one moment404/414
14:10:15 <vixey> then it changes into 424/550
14:10:27 <vixey> both numbers going up.. O_o
14:10:27 <BMeph> I don't touch perl. From what I've heard, it's just a gateway drug to php. ;p
14:10:57 <kublar> BMeph: you heard wrong :|
14:11:28 <BMeph> kublar: O RLY?
14:11:29 <flux> I don't quite understand how anyone would switch to php from perl, which has for examples closures and sane scoping
14:13:54 <Zao> flux: More handy web functionality in core, and easier to have it in-line with documents?
14:14:20 <kublar> how is that a feature?
14:14:37 <cizra> sumList (x:xs) = x + sumList xs
14:14:38 <Gracenotes> @instances Functor
14:14:39 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:14:44 <cizra> -- why do we need those () around x:xs?
14:14:49 <kublar> also, "more handy web functionality" should not include 2000 keywords
14:14:54 <kublar> cizra: precedence
14:14:58 <ddarius> kublar: You have to approach it from the mind of PHP user.
14:15:13 <Zao> kublar: Most people only need slightly dynamic objects, not the usual Perl big-ass application that churns things through some gigantic templating engine and finally spits out something.
14:15:18 <flux> perhaps easier as in its the default, but otherwise I understand there are different template packges for perl. of course, that's not easier either..
14:15:33 <Zao> I didn't approve of PHP before, but after using it for a month or two, it has its charm.
14:15:43 <Zao> It's very rapid.
14:15:50 <b_jonas> Zao: that shows how it's a drug then
14:16:00 <Chile`> Zao: so is python, & python doesn't suck :)
14:16:24 <Zao> Chile`: You kind of need Django to do anything web-related in Python, and then you're suddenly in suckage territory again.
14:17:14 <cizra> kublar: Hmm, thanks
14:17:23 <flux> php can perhapss be decent if you have php.net open all the time and never find yourself in a place where you need to do higher order stuff
14:17:33 <Chile`> Zao: taken a look at Pylons?
14:17:35 <NickKabardin> i heard that there is a freak that talking some shit about php
14:17:38 <NickKabardin> so i'm here
14:17:45 <Zao> Chile`: No.
14:18:05 <flux> the latter is quite a big limitation if you've taken the sip of the functional fountain :P
14:18:07 <Zao> Chile`: I don't have a need for Python in my life anymore. :)
14:18:12 <NickKabardin> give me some pleasure
14:18:16 <Chile`> Zao: might want to, I've found it pretty nice to work with.
14:18:30 <Zao> I have a feeling that we're diverging from topic here a bit.
14:18:44 <Zao> flux: That story was on The Onion, by the way.
14:18:45 <hugo___> hey
14:18:52 <flux> zao, what was?
14:19:11 <Zao> The one about the teacher banning php.
14:19:21 <pejo> NickKabardin, welcome! How did you decide to start using Haskell?
14:19:38 <flux> I think it was a different story. they might both come from the same place, though.
14:19:41 <NickKabardin> i haven't. I'm just a simple python monkey )
14:20:29 <BMeph> NickKabardin: Heh-heh, that's what ALL the Pythonistas say, at first... ;)
14:21:20 <memento> BMeph: and how do they continue?
14:21:27 <Olathe> NickKabardin: Are you trying to say that PHP *isn't* the work of SATAN ?
14:21:44 <NickKabardin> :) :)
14:22:14 <NickKabardin> PHP is a work of people who decided to use c-like DSL for perl templates for his own personal home page. That is it.
14:24:37 <memento> and its fine for that
14:24:46 <kublar> not really
14:25:03 <kublar> the author didn't really know much about perl or programming languages in general :/
14:25:23 <flux> I thought php originated as a perl package?
14:25:23 <NickKabardin> fuck him. let's go party! :)
14:25:31 <flux> but perl might've been much worse back them..
14:25:34 <kublar> flux: yeah, it was a bunch of perl scripts
14:25:41 <NickKabardin> you thoughts was True ;)
14:25:55 <Gracenotes> @instances MonadPlus
14:25:56 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:26:12 <Gracenotes> I need to keep a list somewhere... :)
14:26:22 <memento> kublar: yeah but its not for people who know much about perl or programming languages in general
14:26:28 <NickKabardin> on your body )
14:26:39 <kublar> PHP: Not For Programmers
14:26:51 <Gracenotes> I need a Haskell reference sheet
14:26:53 <kublar> PHP: Separating Logic and Programming
14:26:57 <Gracenotes> like xkcd has for Unix
14:26:58 <NickKabardin> PHP Hates Python
14:27:03 <kublar> PHP: Training Wheels Without the Bike
14:27:06 <NickKabardin> PHP Hates Python Hates Python
14:27:15 <Gracenotes> *hm, Linux, actually
14:27:45 <Gracenotes> so I can just look down and see the instances of a MonadPlus
14:33:15 <mmorrow>  @index MonadPlus
14:33:20 <mmorrow> @index MonadPlus
14:33:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:33:25 <mmorrow> @instances MonadPlus
14:33:26 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:35:20 <mmorrow> the thing with class instances though is that you can make new ones, and which ones exists depend on what's in scope in a particular module/program
14:36:10 <CakeProphet> ghci needs some introspection commands.
14:36:17 <CakeProphet> for that kind of stuff
14:36:26 <mmorrow> CakeProphet: do you know :info ?
14:36:39 <CakeProphet> does it determine instances
14:36:41 <mmorrow> yes
14:36:55 <mmorrow> without it i would be 100x less productive
14:37:03 <mmorrow> :i Maybe
14:37:13 <mmorrow> :i Language.Haskell.TH.Syntax.Exp
14:37:19 <b_jonas> is it a bad idea to add some modules to import by default in my .ghci ?
14:37:34 <mmorrow> you don't have to qualify names if the module the are defined in is already imported
14:37:47 <mmorrow> b_jonas: i think it's super handy
14:37:58 <CakeProphet> do tuples have a maximum length?
14:38:05 <mmorrow> you can also put little utility function defs in there
14:38:13 <mmorrow> CakeProphet: in ghc yes
14:38:22 <b_jonas> I wish you could somehow use any declarations in the ghci prompt: import as, data,type,newtype,class,instance
14:38:27 <mmorrow> , $(tupE (fmal lift [1..63::Int]))
14:38:29 <lunabot>  luna: Not in scope: `fmal'
14:38:31 <b_jonas> then you wouldn't need to load modules to do these
14:38:34 <mmorrow> , $(tupE (fmap lift [1..63::Int]))
14:38:34 <b_jonas> but just type in the prompt
14:38:35 <CakeProphet> mmorrow:  any compilers without a finite length?
14:38:37 <lunabot>  luna: A 63-tuple is too large for GHC
14:38:38 <b_jonas> with some :command
14:38:40 <b_jonas> hmm
14:38:43 <mmorrow> CakeProphet: i'm not sure
14:38:55 <b_jonas> maybe I should make a :command macro that writes the declaration to a temp file and loads it
14:39:14 <CakeProphet> doesn't really matter though. if you have anything over a 10-tuple you need to reorganize.
14:39:18 <CakeProphet> even a 5-tuple is pushing it.
14:39:20 <mmorrow> b_jonas: ooh nice idea. i'd love to see it if you write it :)
14:39:37 <kublar> CakeProphet: just use nested tuples
14:39:54 <CakeProphet> kublar:  well.. I don't really need a giant tuple anyways, but thanks.
14:39:55 <mmorrow> CakeProphet: yeah, tuples larger than 3 start to get tedious unless you're generating code to deal with them
14:41:33 <mmorrow> , $(tupE (fmap lift [1..12::Int]))
14:41:35 <lunabot>  (1,2,3,4,5,6,7,8,9,10,11,12)
14:42:18 <CakeProphet> hmmm... would it be safe to describe tuples as anonymous datatypes?
14:42:36 <mmorrow> they're actually named datatypes
14:42:42 <mmorrow> , src ''(,,,)
14:42:52 <lunabot>  data (,,,) a b c d = (,,,) a b c d
14:42:53 <mmorrow> an "infinite" family of them
14:43:01 <mmorrow> (but not so infinite apparently)
14:43:07 <CakeProphet> ,,, == 3-tuple?
14:43:09 <lunabot>  luna: parse error on input `=='
14:43:13 <mmorrow> (,,,) does
14:43:16 <mmorrow> oops
14:43:18 <b_jonas> CakeProphet: no, (,,,) is 4-tuple
14:43:18 <mmorrow> (,,) does
14:43:29 <b_jonas> CakeProphet: the parenthesis are required
14:43:29 <CakeProphet> ah () is 0
14:43:36 <b_jonas> CakeProphet: that's an exception
14:43:38 <CakeProphet> oh
14:43:40 <b_jonas> there's no 1-tuple
14:43:45 <b_jonas> (,) is the 2-tuple
14:43:51 <b_jonas> (,,) is the 3-tuple
14:43:52 <b_jonas> etc
14:43:52 <CakeProphet> oh... weird.
14:43:54 <mmorrow> well, technically eveything is a one-tuple
14:43:58 <CakeProphet> > (,)
14:43:58 <mmorrow> , (1)
14:43:58 <lambdabot>       Overlapping instances for Show (a -> b -> (a, b))
14:43:59 <lambdabot>        arising from a...
14:44:00 <lunabot>  1
14:44:05 <CakeProphet> > (1,)
14:44:06 <lambdabot>   <no location info>: parse error on input `)'
14:44:10 <CakeProphet> > (,) 1
14:44:11 <lambdabot>       Overlapping instances for Show (b -> (t, b))
14:44:11 <lambdabot>        arising from a use ...
14:44:13 <mmorrow> , (,) 1 $ 2
14:44:14 <CakeProphet> > (,) 1 2
14:44:16 <lunabot>  (1,2)
14:44:16 <lambdabot>   (1,2)
14:44:35 <CakeProphet> ah okay... because a 2-tuple has one comma
14:44:41 <CakeProphet> that's nice.
14:44:47 <pumpkin> lol, my solution to problem 23 for project euler took up 2.8 gigs of RAM, but ran in under a minute, you think that's an issue? :P
14:45:10 <Cale> pumpkin: Did it use that ram all at once?
14:45:17 <kublar> as long as it takes less than 12 hours to run ...
14:45:17 <pumpkin> yup, lol
14:45:19 <CakeProphet> > (,,,,,,,,,) [1..9]
14:45:20 <lambdabot>       Overlapping instances for Show
14:45:20 <lambdabot>                                  (b
14:45:20 <lambdabot>     ...
14:45:25 <CakeProphet> > (,,,,,,,,,) [1..10]
14:45:26 <lambdabot>       Overlapping instances for Show
14:45:26 <lambdabot>                                  (b
14:45:26 <lambdabot>     ...
14:45:28 <CakeProphet> ...
14:45:35 <kniu> count 'em.
14:45:35 <mmorrow> @type (,,,,,,,,)
14:45:36 <lambdabot> forall a b c d e f g h i. a -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
14:45:48 <lucca> you're giving it a list
14:45:53 <CakeProphet> ...oh rite
14:45:58 <b_jonas> if I've removed them from the ghci prompt, how do I list the modules that are imported (unqualified)?
14:46:01 <lucca> > (,,,) 1 2 3 4
14:46:02 <mmorrow> that's why it's tedious without meta-prog help
14:46:03 <lambdabot>   (1,2,3,4)
14:46:23 <pumpkin> :D
14:46:55 <CakeProphet> > foldl $ (,,,,,,,,) [1..9]
14:46:56 <lambdabot>       Occurs check: cannot construct the infinite type:
14:46:56 <lambdabot>        a = d -> e -> ...
14:47:13 <pumpkin> CakeProphet: that doesn't make much sense :P
14:47:31 <CakeProphet> well... it's supposed to start with (,,,,,,,)
14:47:34 <CakeProphet> as the initializer
14:47:42 <CakeProphet> and then apply the range 1 to 9
14:47:47 <mmorrow> , (\(a:b:c:d:e:f:g:h:i:_) -> (a,b,c,d,e,f,g,h,i)) [0..]
14:47:49 <kublar> that doesn't typecheck
14:47:50 <lunabot>  (0,1,2,3,4,5,6,7,8)
14:48:01 <kublar> also, $ should be ($) should be id
14:48:17 <mmorrow> , (*2) `id 10
14:48:18 <CakeProphet> > foldl ($) (,,,,,,,,) [1..9]
14:48:19 <lunabot>  luna: parse error on input `10'
14:48:19 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
14:48:19 <lambdabot>      Proba...
14:48:20 <mmorrow> , (*2) `id` 10
14:48:22 <lunabot>  20
14:48:39 <CakeProphet> > foldl ($id) (,,,,,,,,) [1..9]
14:48:40 <lambdabot>       Occurs check: cannot construct the infinite type:
14:48:40 <lambdabot>        b = b1 -> (a -...
14:48:43 <CakeProphet> ...
14:49:00 <mmorrow> what you're trying to do is impossible
14:49:10 <mmorrow> (given the type system)
14:49:10 <pumpkin> ...without template haskell!
14:49:12 <pumpkin> :P
14:49:13 <mmorrow> yes
14:49:14 <CakeProphet> you can't curry datacons?
14:49:26 <kublar> sure you can
14:49:33 <mmorrow> you can, but how you'retrying to do it violates typing rules
14:49:34 <kublar> all functions are curried
14:49:45 <pumpkin> try to write the type of that foldl though
14:49:47 <pumpkin> :t foldl
14:49:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:49:51 <mmorrow> the type system can't determine statically the result type
14:49:54 <pumpkin> now look at the function you're passing it
14:50:00 <mmorrow> because it depends on the length of the list
14:50:09 <b_jonas> if you want more than a constant number of functions, you won't use a tuple anyway
14:50:16 <b_jonas> and for a constant number you can write it
14:55:59 <baaba> @djinn (a -> b -> a) -> a -> [b] -> a
14:56:00 <lambdabot> Error: Undefined type []
14:56:48 <BONUS> offtopic lol: http://twittypic.com/promoted_pics/3432e6661c119dad3b36fe91b1be0fca.jpg
15:07:44 <Raevel> BONUS: yes
15:15:27 <b_jonas> night
15:15:51 <Raevel> okay
15:15:57 <Raevel> haskell time
15:16:34 <Raevel> when will i ever become this SUPER HASKELL GURU that write yourself a scheme refers to?
15:16:38 <enticingjelly> so. hmm. how do I organize imports? 8)
15:17:19 <Skyp> Yo rero, fr0 ;)
15:17:47 <Raevel> enticingjelly: interesting question! but i don't know the answer unfortunately
15:18:08 <enticingjelly> Skyp, what the fuck
15:18:25 <enticingjelly> skyp! \o/
15:18:28 <Skyp> ;)
15:19:08 <Raevel> yeah i have no clue
15:19:11 <Riastradh> Certainly not after working through that `implement [bogus] Scheme [badly] in 48 hours' tutorial, Raevel.
15:19:57 <Raevel> Riastradh: it seemed like it was just mean to scare people away?
15:21:31 <mmorrow> Riastradh: do you have an alternative implement-yourself-a-scheme tutorial?
15:22:01 <Riastradh> No, I don't have time to write that, but you can get an idea of what it might look like from <http://mumble.net/~campbell/tmp/Scheme.hs>.
15:22:50 <centrinia> Yay! I solved Euler 67 in less than two billion years. :D
15:22:50 <Raevel> the haskell scheme "tutorial" just left me confused
15:22:51 * mmorrow looks
15:23:03 <Riastradh> This exhibits the use of the type system to clarify the precise semantics of Scheme, and accurately.
15:23:30 <mmorrow> does it support call/cc?
15:23:49 <Riastradh> Yes, although it's not defined right there.  (The definition is a couple of lines.)
15:24:02 <mmorrow> that's nice to hear :)
15:24:45 <Raevel> oh, this is completely unrelated
15:25:00 <mmorrow> one thing i'd do different is to use the derived Show instances and have a separate Ppr/Pretty/whatever-is-one's-fav-name class
15:25:00 <Raevel> oh, and n/m :-(
15:25:43 <Raevel> mmorrow: you seem like an interesting guy, what's your story?
15:26:07 <mmorrow> Raevel: have you heard the one about little red riding hood?
15:26:07 <Riastradh> Sorry, I remember now.  It doesn't need a definition of CWCC; you would just use Control.Monad.Cont's.
15:26:18 <Raevel> mmorrow::-(
15:26:19 <mmorrow> Riastradh: ah, cool.
15:26:27 <mmorrow> Raevel: :)
15:26:37 <Riastradh> You can't derive a Show instance.
15:26:39 <chrisdone> Raevel: I find your ideas very interested and I would like to subscribe to your newsletter
15:26:47 <Raevel> i have none!!
15:27:01 <mmorrow> Riastradh: for Datum?
15:27:03 <Raevel> and i'll have none of that
15:27:08 <Riastradh> That's right, mmorrow.
15:27:09 <kabny> This just in! 5 people died of monads!
15:27:14 <mmorrow> Riastradh: why?
15:27:16 <Raevel> chrisdone is alos a very interesting dude
15:27:16 <mmorrow> oh
15:27:19 <mmorrow> sucky
15:27:37 <mmorrow> didn't see the function
15:28:12 <Raevel> one reason haskell is interesing is because the iq of #haskell averages +50 of all other channels of freenode
15:28:23 <Riastradh> Eq and Ord could be derived for Location.  A derived instance of Show, however, would have made debugging considerably more painful.
15:28:25 <kublar> preflex: quote
15:28:26 <preflex>  <evilterran> "We were somewhere around Barstow, on the edge of the desert, when the phantom types began to take hold."
15:29:27 <mmorrow> Riastradh: i find derived show more useful for debugging myself, but everyone has their own opinion. we need a standard Pretty class and the options of whether to use Show or this Pretty by default in ghci /badly/.
15:29:55 <mmorrow> because non-derived Show instances break certain tools
15:30:15 <Riastradh> mmorrow, many locations turn up throughout the debugging output.  Reading `@123' is *much* nicer than `Location { locationIndex = 123 }'.
15:30:30 <MyCatVerbs> Raevel: possibly an overestimate. Have you even tried #scheme? =)
15:30:48 <Riastradh> What tools break with non-derived Show instances?
15:31:22 <mmorrow> sure, in that context pretty output may be better than the Show ouput. but consider if you're generating haskell code, and you can't see the actual AST you're generating (which is the derived-show ouput).
15:31:27 <lucca> just things using ReadS stuff, I believe
15:31:28 <memento> MyCatVerbs: say sg about scheme:D im interested now
15:32:17 <mmorrow> Riastradh: one would be a haskell prettyprinter that parses (as a haskell expression) the output of show.
15:32:22 <Raevel> MyCatVerbs: nope!
15:32:55 <mmorrow> and then prettyprints the (at two-levels-meta) haskell AST back to the one-level-meta AST to get nice formatting
15:33:04 <mmorrow> of the Show ouput
15:33:06 <MyCatVerbs> memento: not much. But #scheme is just about as helpful as #haskell, on average, and it's a roomful of people who have pretzelled their brains sufficiently that call/cc makes sense for them already. ;)
15:33:08 <Raevel> my school uses lisp for a lot of courses, both cl and scheme, but i haven't grown than fond of it
15:33:27 <BMeph> MyCatVerbs: That's a tough call - if there are two channels that oleg is prominent in, it's #scheme and #haskell. :)
15:33:36 <Raevel> oleg?
15:33:44 <MyCatVerbs> Raevel: Oleg! =D
15:33:50 <kublar> @where oleg
15:33:50 <memento> :)
15:33:50 <lambdabot> http://okmij.org/ftp/
15:33:52 <kniu> Kiselyov
15:33:59 <MyCatVerbs> Raevel: very smart gentleman with a lot of fun papers to his name.
15:34:18 <kniu> Hey guys
15:34:22 <Raevel> a guy called oleg?
15:34:26 <MyCatVerbs> Raevel: also trying to follow SICP teaches you to match and follow heavily nested parentheses very, very quickly. =)
15:34:39 <kniu> how hard is it to write a compiler if you know nothing about the subject?
15:34:44 <Raevel> MyCatVerbs: did sicp already
15:35:04 <MyCatVerbs> Raevel: oh, fun. Too lazy myself. ;)
15:35:15 <chrisdone> http://dis.4chan.org/read/prog/1230175014/
15:35:19 <cizra> kniu: pretty hard, if the language is complex.
15:35:20 <chrisdone> can anyone make a christmas tree with loeb?
15:35:30 <Raevel> MyCatVerbs: heh, well it's a good (and tough) read
15:35:33 <MyCatVerbs> kniu: reasonably. Step one is to learn how compilers work. :)
15:36:27 <Raevel> i knew pretty much nothing about what it covered before i read it
15:36:28 <MyCatVerbs> kniu: what're you trying to write a compiler to, and from?
15:36:48 <kniu> uh...
15:36:57 <kniu> I don't know.
15:37:05 <kniu> It's a hypothetical question.
15:37:55 <pejo> kniu, there's usually a compiler construction class available for CS undergraduates at pretty much every university.
15:38:05 <Raevel> i'm planning on taking a course on compilers at least, i wonder how much i'll really learn
15:38:29 * chrisdone demands christmas trees and pretty things
15:39:21 <pejo> kniu, so "most" people with reasonable background can write a compiler for a toy language in a couple of hundred hours, tops.
15:40:35 <pumpkin> damn right
15:40:47 <kniu> huh.
15:41:46 <Raevel> pumpkin is another interesting character
15:41:48 <dons> pejo: couple of hundred seems a lot. many courses expect you to do that in < hmm. 80
15:41:59 <pumpkin> ORLY?
15:42:04 <Raevel> today is a good day i think for complenting people
15:42:29 <kublar> write a brainfuck compiler
15:42:43 <kublar> you have 30 minutes
15:42:58 <mmorrow> rwbarton wrote a brainfuck -> ELF .o compiler
15:43:06 <Raevel> dons: i spent most of the last week doing haskell and reading rwh, found a bunch of typos, but i really like the book!
15:43:08 <mmorrow> that used harpy
15:43:15 <pejo> dons, perhaps differing prerequisites? Or size of the project, maybe?
15:43:42 <dons> Raevel: cool, i hope you submitted them to the errata site?
15:43:44 <mmorrow> speaking of rwbarton, i haven't seen him in a while in here
15:43:51 <mmorrow> preflex: seen rwbarton
15:43:51 <preflex>  rwbarton was last seen on #haskell 4 days, 15 hours, 55 minutes and 37 seconds ago, saying: you should be able to just use a / instead
15:43:54 <mmorrow> oh
15:43:57 <dons> its amazing how much made it through copy editing and 800 tech reviwerers
15:44:10 <Raevel> dons: i had no notepad nearby :*/
15:44:31 <Raevel> dons: yeah, i bet it's HARD
15:45:13 <Raevel> oh, i actually have a question about the json parser in rwh
15:45:25 <dons> quick. i'm on vacationn and shouldn't be on irc ... :)
15:45:36 <enticingjelly> so, how do you organize your imports? by hand?
15:45:44 <Raevel> at some point it had a type signature that was something like (JValue ObjVal)
15:45:51 <enticingjelly> or is there some GHC warning I can switch on?
15:46:26 <Raevel> what does it mean?
15:46:34 <dons> oh, JValue a is the abstract data type
15:46:34 <mmorrow> enticingjelly: what do you mean "organize"?
15:46:46 <dons> so applied to a particular type yields, say, JValue Foo
15:46:57 <enticingjelly> mmorrow, taking care that your module is really only importing other modules when they are needed
15:46:58 <dons> the parenthesis don't mean anything
15:47:02 <tibbe> enticingjelly: alphabetically with modules imported from the current project separated
15:47:18 <tibbe> enticingjelly: turn on -Wall
15:47:33 <Raevel> dons: actually, i've had too many beers right now so i doubt i'll learn anything, so i'd probably better bother someone later on instead :-)
15:48:03 <enticingjelly> tibbe, that's what I was looking for, thanks
15:48:06 <mmorrow> enticingjelly: one way would be to only import functions you need.
15:48:23 <mmorrow> yeah, -Wall will tell you if you import a module and use /nothing/ from it
15:48:26 <tibbe> enticingjelly: np
15:48:46 <rwbarton> With data (or type) families, is there a way to provide a default definition?
15:48:54 <Heffalump> I believe not
15:48:55 <mmorrow> rwbarton: speak of the devil
15:48:59 <mmorrow> :)
15:49:02 <tibbe> enticingjelly: mmorrow: I also import only the functions I use or use qualified imports
15:49:24 <mmorrow> tibbe: me too (when i'm not lazy)
15:49:29 <tibbe> :)
15:50:18 <pumpkin> another euler problem solved in haskell in less than a minute using epic RAM
15:50:28 <Raevel> epic ram?
15:50:37 <pumpkin> over a gig :P
15:50:40 <pumpkin> 1.2 gigs
15:50:55 <schme_> RAM is cheap :)
15:50:56 <mmorrow> tibbe: i've been working on a binding to libev (started the other night). a few more hours of work and it'll be ready.
15:50:57 <kublar> the machine I'm on has 64MB
15:50:58 <pumpkin> I'm sure I could've done it more efficiently, but this worked
15:51:12 <mmorrow> select/poll/epoll/kqueue/devpoll choice++++
15:51:22 <tibbe> mmorrow: cool! I'd be very interested
15:51:47 <mmorrow> tibbe: i'm going to put it on hackage. i'll let you know :)
15:51:55 <Raevel> I'M LOST
15:52:11 <tibbe> mmorrow: thanks
15:52:25 <tibbe> mmorrow: is libev not threadsafe like libevent?
15:52:49 <mmorrow> here's the libev C example from the first page of the docs in haskell for an idea of the interface: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=688
15:52:55 <mmorrow> it's threadsafe
15:53:13 <trygvis> :t (.)
15:53:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:54:39 <tibbe> mmorrow: that's nice, I want to run a (OS) thread per core
15:56:22 <mmorrow> tibbe: from what i've gathered from the libev docs, you have one event loop per OS  thread
15:56:42 <mmorrow> tibbe: and you could even use that loop as a replacement for ghc's IO manager
15:57:01 <tibbe> mmorrow: that's great because I'm intending to do just that
15:57:12 <mmorrow> tibbe: me too :)
15:57:31 <tibbe> mmorrow: what do you intend to use it for?
15:58:05 <mmorrow> i'm writing a webserver (similar to hyena)
15:58:58 <mmorrow> so i don't have to use apache/whatever + fastcgi
15:59:06 <rwbarton> Heffalump: If I leave it out, I get a warning, not an error.  Do you know what it does in that case?  (I want the default to be empty)
15:59:33 <tibbe> mmorrow: interesting, code up anywhere?
16:01:04 <mmorrow> tibbe: not yet, but the initial code that i started from (and have changed pretty much completely) is http://code.haskell.org/~morrow/code/haskell/misc/neutron.hs.html
16:01:26 <tibbe> mmorrow: same for me, initial code up but the new code looks nothing like it
16:02:50 <mmorrow> i also want to experiment (not as an integral part of the core server) with hooking the server up to the ghc-api and make it self-modifying in some way. not really sure exactly how i mean yet though, but rather want to explore possibilities.
16:03:16 <rwbarton> mmorrow: what are you working on?
16:03:52 <mmorrow> rwbarton: a small/extensible/hackable webserver
16:04:57 <mmorrow> i initially started writing it with the intention of giving the code that lunabot's using an http interface, but want to also use it as an alternative to fastcgi as well
16:05:26 <mmorrow> kill as many birds as possible with one stone kinda thing
16:05:40 <rwbarton> ah, cool
16:07:20 <tibbe> mmorrow: I'm trying to create one based on iteratee style i/o
16:08:10 <mmorrow> tibbe: yeah, i've been reading up on your hyena stuff. i'm converted as well, but am unsure exactly how i'm going to structure my interface as of now.
16:09:08 <mmorrow> tibbe: i've been playing around with modifying ReadP to get a nice combinator/incremental/binary parser. mixed results so far.
16:09:40 <mmorrow> ReadP is really cool.
16:09:55 <tibbe> mmorrow: I have a resumable parser that can work on blocks, much like the one in Hyena, but I'm still working on the API as well
16:11:06 <mmorrow> yeah, it's tricky to abstract away the fact that a parseable unit may span two/more blocks
16:11:32 <mmorrow> or rather, to design the parser to make doing so easy
16:11:44 <tibbe> mmorrow: I think the request handler type (the type the app needs to implement) will be RequestHeaders -> IterateeM m Response
16:12:18 <tibbe> mmorrow: what do you mean by spawn two/more blocks? :)
16:12:23 <mmorrow> hmm, interesting.
16:13:11 <tibbe> mmorrow: where Response contains an Enumerator over the response body
16:13:36 <mmorrow> like suppose you're reading blocks of size n, and you want to expose a combinator parsing interface and not require a parser for (e.g.) quoted strings to need knowledge of the fact that that quoted string spans two of the blocks
16:14:01 <mmorrow> *may span two of the blocks
16:14:06 <tibbe> mmorrow: right, I have that. Have you read oleg's slides from DEFUN?
16:14:28 <mmorrow> tibbe: oh yesh, i have that saved on my desktop :)
16:14:37 <tibbe> mmorrow: he does just that
16:14:50 <mmorrow> cool
16:15:03 <mmorrow> i also find ZFS interesting
16:15:23 <pumpkin> ZFS is awesome
16:15:26 <tibbe> mmorrow: as in sun's file system?
16:15:40 <mmorrow> one idea i've been playing around with is allowing the use to supply an arbitrary datatype as the "filesystem" for the server
16:15:46 <mmorrow> s/use/user/
16:15:59 <tibbe> mmorrow: like the new java version will?
16:16:19 <mmorrow> hmm, i not familiar with the java one. i'll have to look into it.
16:16:33 <stu8ball> Do you mean kinda like a VFS?
16:16:42 <mmorrow> ooh, i'll have to look into sun's filesystem too.
16:17:10 <mmorrow> stu8ball: more like the "filesystem" could be an (e.g.) arbitrary not-necessarily-a-tree datatype
16:17:17 <mmorrow> like a haskell AST
16:17:17 <stu8ball> aah
16:17:21 <mmorrow> or a whatever
16:17:49 <mmorrow> and you'd address into parts of this with the URLs
16:17:55 <mmorrow> in some way
16:18:12 <mmorrow> (to be defined by the user when they provide their datatype)
16:19:00 <mmorrow> well, i guess all haskell abstract datatypes are technically trees, but ..
16:19:45 <mmorrow> data DirTree = File FileName | Dir DirName [DirTree]  is definitely a special case
16:21:43 <centrinia> Does the data type T a, { data T a = T a (T a) (T a); }, hold more than the data type L a, { data L a = L a (L a); } ?
16:22:42 <mmorrow> they're not isomorphic, if that's what you mean
16:23:12 <mmorrow> one's an (infinite) list and one's an (infinite) binary tree
16:23:35 <ddarius> centrinia: You have to define what you mean by "hold more" for the question to make sense.
16:23:52 <centrinia> Doesn't the infinite binary tree contain uncountably many elements whereas the infinite list contains only countably many elements?
16:23:59 <ddarius> centrinia: No
16:24:13 <ddarius> centrinia: Everything in programming is countable.
16:24:26 <mmorrow> they're both hold a countably infinite number of elems
16:25:05 <mmorrow> centrinia: how you would show that the tree has countably many elems would be to do a breadth-first search
16:25:46 <mmorrow> with a bfs you'd be able to reach any given element in a finite time
16:26:49 <ddarius> centrinia: If we weren't constrained by computability then L Bool would already be isomorphic to the reals and thus uncountable.
16:27:05 <centrinia> ddarius, I was thinking that.
16:27:43 <mmorrow> i don't see it
16:27:57 <mmorrow> L Bool `is` R ??
16:28:01 <mmorrow> `iso`
16:28:07 <FunctorSalad> @src L
16:28:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:28:09 <FunctorSalad> :)
16:28:18 <centrinia> No, T Bool is isomorphic to the reals.
16:28:20 <nroot7> Why is this definition of finding last element in list incorrect
16:28:22 <nroot7> mylast [x] = x
16:28:23 <nroot7> mylast [_:xs] = mylast[xs]
16:28:34 <pumpkin> not [
16:28:39 <pumpkin> use (_:xs)
16:28:40 <mmorrow> centrinia: how?
16:28:56 <pumpkin> mylast (_:xs) = mylast xs
16:29:03 <ddarius> mmorrow: It's an infinite stream of bits.  It can readily be viewed as a binary expansion of a real number.
16:29:06 <nroot7> ok, Thanks
16:29:07 <FunctorSalad> [_:xs] would match a singleton list containing a list
16:29:16 <FunctorSalad> like [[1,2,3]]
16:29:22 <centrinia> Actually, there is an instance of T Bool that is isomorphic to the reals.
16:29:40 <mmorrow> ddarius: sure, but a /single/ real number, whose binary expansion is countable.
16:29:52 <mmorrow> but not R itself
16:29:55 <ddarius> mmorrow: The type L Bool is the collection of all such.
16:30:00 <mmorrow> hmm
16:30:08 <ddarius> Each element in L Bool corresponds to a real.
16:30:10 <mmorrow> oh i see what you're saying
16:30:32 <mmorrow> the collection of every possible value of type L Bool
16:30:40 <FunctorSalad> what are L and T?
16:30:42 <mmorrow> is iso to R, sure
16:31:21 <centrinia> FunctorSalid, I just made up (L a) to be an infinite list. I also made (T a) to be an infinite binary tree.
16:31:49 <nroot7> And what is the proper way to handle empty list in this case ?
16:31:55 <FunctorSalad> ok
16:32:47 <Olathe> @src last
16:32:48 <lambdabot> last [x]    = x
16:32:48 <lambdabot> last (_:xs) = last xs
16:32:48 <lambdabot> last []     = undefined
16:33:58 <centrinia> Is it possible to encode all real numbers less than two with the binary digit at the ones position equal to zero by the tree { l = T False l r; } and the real numbers less than 2 with the binary digit at the ones position equal to one by the tree { r = T True l r; } ?
16:34:57 <mmorrow> |(0,1)| == |R|
16:36:11 <mmorrow> s/(0,1)/(a,b) | a < b, a, b `elem` R/
16:37:37 <procyon> mmmmmm ringworm
16:37:51 <procyon> err...
16:38:31 <mmorrow> tibbe: when you said "the new java one", what did you mean by "one"?
16:38:44 <mmorrow> "filesystem abstraction"?
16:39:07 <tibbe> mmorrow: yes
16:39:31 <tibbe> mmorrow: I don't know if that was what you intended with your reference to a filesystem abstraction though
16:40:21 <mmorrow> tibbe: ah, i just found some stuff about the java VFS. i'm not quite sure if that captures what i'm thinking of yet either.
16:40:39 <mmorrow> it very well may.
16:40:53 <tibbe> mmorrow: so it's part of java nio 2
16:41:12 <mmorrow> cool, /me googles
16:41:19 <tibbe> mmorrow: basically it creates a typeclass for the filesystem
16:41:35 <tibbe> mmorrow: so the implementation can be changed but the interface is the same
16:42:11 <mmorrow> hmm
16:42:46 <mmorrow> that's a good way to summarize it.
16:43:34 <mmorrow> i'm not sure if my interface would necessarily change or not
16:43:45 <tibbe> mmorrow: ok
16:43:49 * mmorrow has reading to do
16:45:31 <mmorrow> i think i may be thinking of an interface for interfaces to implementations.
16:45:55 <mmorrow> not sure yet though
16:46:36 <mmorrow> the extra level may be extraneous
16:48:43 <tibbe> ok :)
16:53:19 <tibbe> time for me to sleep, gnight qll
16:53:22 <mmorrow> oh, and re: parsing blocks. the sticking point with my implem (since i'm using ReadP as the underlying framework) is supporting `look', which maps _the rest of the input_ to a parser. that makes it hard to make the fact that the rest of the input isn't a sequence of blocks.
16:53:24 <tibbe> all*
16:53:28 <mmorrow> nightr
16:53:33 <mmorrow> s/r//
17:02:41 <cizra> getNextLine :: IO String
17:02:43 <cizra> getNextLine = do
17:02:45 <cizra>   return "test"
17:02:49 <cizra> -- why does'nt this work?
17:02:55 <cizra> Complains about syntax error, possibly bad indent
17:03:11 <mmorrow> looks ok to me
17:03:22 <cizra> might be something before it.
17:03:25 <Saizan> maybe the problem is in the surrounding code?
17:03:26 <mmorrow> the `do' is extraneous in that particular example, too
17:03:33 <cizra> O wait
17:03:43 <cizra> indeed, I had left in some crap I meant to comment out
17:04:04 * cizra is writing a Jabber/MSN bot to spout Estonian national epic poem to people trying to talk to me.
17:04:14 <mmorrow> hehe
17:04:25 <cizra> .. but as I'm an absolute newbie…
17:04:39 <mmorrow> doing is the best way to learn imo
17:04:57 <cizra> Amen. I'm sick of reading books.
17:05:14 <cizra> Trying to make something and asking lots of dumb questions is way funner.
17:05:59 <mmorrow> and it also tells you what questions you even need to ask in the first place
17:06:44 <FunctorSalad> cizra: seconded
17:07:15 <cizra> (=
17:08:03 <pumpkin> :t mapM
17:08:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:08:57 <FunctorSalad> :t sequence . map
17:08:58 <lambdabot>     Couldn't match expected type `[m a]'
17:08:58 <lambdabot>            against inferred type `[a1] -> [b]'
17:08:58 <lambdabot>     Probable cause: `map' is applied to too few arguments
17:09:15 <FunctorSalad> :t \f -> sequence . map f
17:09:16 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
17:09:27 <pumpkin> omg magick
17:09:45 <FunctorSalad> the type inference? :)
17:09:46 <ddarius> :t sequence . map ?F
17:09:47 <lambdabot>     precedence parsing error
17:09:47 <lambdabot>         cannot mix `(.)' [infixr 9] and `(?)' [infixl 9] in the same infix expression
17:09:47 <lambdabot> Not in scope: data constructor `F'
17:09:48 <ddarius> :t sequence . map ?f
17:09:50 <lambdabot> forall (m :: * -> *) a a1. (?f::a1 -> m a, Monad m) => [a1] -> m [a]
17:09:54 <pumpkin> :t (sequence . ) . map
17:09:55 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
17:33:18 <eu-prleu-peupeu> hey
17:33:25 <eu-prleu-peupeu> whats up Hppl ?
17:34:11 <augustss> hi
17:36:25 <mmorrow> wow, ghc uses mmap for memory allocation on unix... by mmapping /dev/zero
17:36:45 <kublar> explicitly or through malloc?
17:36:50 <mmorrow> explicitly
17:36:54 <eu-prleu-peupeu> do you guys all use xmonad ?
17:37:16 <pumpkin> I use mac os
17:37:23 <pumpkin> with the standard window manager :P
17:37:42 <mmorrow> kublar: http://darcs.haskell.org/ghc/rts/posix/OSMem.c
17:37:42 <eu-prleu-peupeu> then you are not true, pumpkin
17:39:12 <eu-prleu-peupeu> i just saw this amazing movie, i think you all should see
17:39:31 <eu-prleu-peupeu> it is called "slumdog millionaire"
17:39:49 <stepcut> eu-prleu-peupeu: my sister has been trying to get my family to see that
17:39:56 <stepcut> is there something like forkIO that will spawn a whole new process?
17:40:10 <kublar> @hoogle fork
17:40:11 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
17:40:11 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
17:40:14 <pumpkin> eu-prleu-peupeu: I liked it :)
17:40:20 <kublar> isn't there a forkProcess?
17:40:29 <mmorrow> in System.Posix.Process
17:40:40 <eu-prleu-peupeu> more one nail on the hollywood coffin :)
17:40:53 <JuanDaugherty> how so
17:40:56 <JuanDaugherty> ?
17:41:15 <JuanDaugherty> oh, it's not an american movie?
17:41:52 <memento> see c.r.a.z.y
17:42:13 <stepcut> mmorrow: oh right. Unfortunately, there is that whole IO manager issue with forkProcess :-/
17:42:14 <JuanDaugherty> see that it isn't.
17:42:20 <mmorrow> stepcut: indeed
17:42:30 * stepcut needs a way to chroot a single thread
17:48:02 <mmorrow> stepcut: forkProcess is supposed to work fine without -threaded though
17:48:25 <stepcut> mmorrow: well, I want to be able to use GHCi and multiprocessor support
17:48:34 <mmorrow> me too :)
17:48:50 <pumpkin> @src interact
17:48:50 <lambdabot> interact f = do s <- getContents; putStr (f s)
18:02:14 <Bunion> hi
18:02:20 <Axman6> o/
18:02:20 <boberman> So.. Whats a good problem for Haskell to solve?
18:02:35 <pumpkin> project euler ones!
18:02:39 <Axman6> boberman: what's not a good problem for haskell to solve?
18:02:41 <Bunion> anyone know a chat room for javascript?
18:02:48 <Axman6> #js?
18:02:51 <Bunion> yea
18:03:25 <ksf> conal, ksf@solaris gl % cd ../cabal/FieldTrip-0.2.2/src
18:03:25 <ksf> ksf@solaris src % grep -Ri raster *
18:03:41 <ksf> am i completely out of luck for "true" 2d support?
18:03:44 <boberman> What I mean is, some languages are best suited for certain situations, C++ for fast lowlevel calculations, fortran for intence mathmatic operations, ect.  Where is Haskells strength?
18:04:20 <Bunion> how do i get to #js
18:04:35 <MarcWeber> Bunion: /msg #js
18:04:41 <MarcWeber> sry /join #js
18:04:52 <ksf> boberman, http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
18:05:00 <Bunion> wow cool
18:05:02 <Bunion> thanks
18:05:08 <Bunion> wow cool
18:05:10 <Bunion> how do i get to #js
18:05:26 <Bunion> got it
18:05:33 <ksf> plus, it's blazingly fast for lowlevel calculations and intense mathematics.
18:05:51 <boberman> ksf: Thanks, just what I was looking for
18:07:01 <ksf> lambdabot should spit out a link to rwh if given the command @faq what is <foo> looking for?
18:07:06 <pstickne> boberman:  I don't think C++ is particularly well suited to anything not covered with another language ;-)
18:08:10 <ksf> yeah, I prefer intercalc or malbolge for everything c++ is good at.
18:09:21 <dibblego> what is a good example to demonstrate the Cont monad to a beginner?
18:09:54 <ddarius> dibblego: Using it to implement exceptions.
18:11:10 <dibblego> hello ben_h, how's Haskelling?
18:12:54 <ben_h> dibblego: at the moment, it's not:)
18:20:24 <blackdog> small structural question: assuming i have an implementation of a perfect-hashing map. This is great, except that 'insert' and friends obviously don't work on it (and if i did make them work, it'd involve repeatedly rehashing everything on every insert.) my idea was to layer another map on top, so that inserts go into it, and to have a 'commit' opreation to rehash everything in the underlying map. would there be a sensible way to implement some kind of s
18:20:31 <blackdog> ... wow, that was an epic.
18:20:52 <eu-prleu-peupeu> is it possible to generate java bytecode from c-- ?
18:21:03 <pejo> blackdog, it got cut off right after "some kind of s".
18:22:36 <xpika> what would be to conver [1,[2,3]] to [1,2] and [1,3]
18:22:36 <eu-prleu-peupeu> and .net IL ? is it possible for haskell to run on .net ?
18:23:06 <xpika> eu-prleu-peupeu: for that you use f sharp
18:23:09 <pejo> eu-prleu, F# is a functional language that runs on .net.
18:23:45 <eu-prleu-peupeu> well, f# is not haskell :P
18:24:07 <ksf> blackdog, use git.
18:25:24 <pejo> eu-prleu, there's no production level .net backend for GHC currently. It doesn't appear to be impossible, just that nobody has done it yet.
18:25:33 <eu-prleu-peupeu> ok
18:25:52 <eu-prleu-peupeu> wouldn't it be just generating ilasm from c-- ?
18:25:56 <Asztal> xpika: almost what you want is sequence [[1],[2,3]]
18:26:01 <blackdog> pejo: dammit. ok, reposting that bit
18:26:01 <blackdog> to implement some kind of structure that took two map  implementations and accessed them in a tiered sort of way? Also, is  there a typeclass i should implement in order to let it slot in  naturally where you'd usually use a Map?
18:26:02 <blackdog> i'm so used to writing one-off things, and it's a bit tricky trying to extract things in a usable and generic way
18:27:10 <ksf> the jvm is a bugger to target, there's no goto, not even halfway-proper continuations and the stack discipline is a pita.
18:27:17 <xpika> Asztal: :)！！！
18:27:57 <blackdog> ksf: ... uh, what does source control have to do with it?
18:28:00 <pumpkin> is there anything out there that does a "binary boundary search"? I want to give something a function Integer -> Bool (with the assumption that the all Integers below k are False and all ones greater than or equal are True)
18:28:25 <pumpkin> it's pretty easy to describe a way to do it, but I was just wondering if there was something out there that already did that
18:28:36 <ksf> speed.
18:29:45 <ksf> I'm quite sure every language targeting the vm that isn't merely a java preprocessor or vastly akin to java in its execution model uses trampolining.
18:30:54 <adekoba_> what does Haskell do about module name conflicts? I have a module that has the same name as one in hackage, so what would happen if both packages were installed?
18:32:56 <ksf> you can hide and unhide whole packages.
18:33:15 <adekoba> oh yes, that's right
18:33:28 <ksf> I guesstimate that "local" files take precedence over packaged ones... try it out.
18:34:01 <adekoba> this module will not be local, however. It would be a package
18:38:20 <iagoabal> Hi, someone knows how I could get a function "ReaderT r (State s) a -> ReaderT r (State (s,w)) a", without have to use runReaderT giving to it the context...? I want to execute the argument and later, transform the state
18:40:40 <geezusfreeek> out of curiosity, what happens if you want to use both packages that offer modules with the same name?
18:41:32 <Asztal> you can hide or rename imported functions, or just refer to them explicitly
18:42:33 <geezusfreeek> no, i mean what if i wanted "import SomeModule" from package A and "import SomeModule" form package B? how would i qualify the two modules differently?
18:43:30 <geezusfreeek> i suspect i would have to make a wrapper module to compile with different compiler flags that reexports things under a different name
18:45:19 <ksf> ghc targeting parrot would be fun. suddenly you'd see perl hackers using parsec instead of perl6's rules.
18:45:39 <adekoba> ksf: the module loads in ghci when one of the packages is hidden, but when they're both available the loading fails and ghci reports: Could not find module <module>: it was found in multiple packages <pkg1> <pkg2>
18:46:14 <Asztal> wow, I completely failed to not read what I was expecting to read
18:46:53 <ksf> he's seeing fnords! sink him!
19:03:16 <chrisdone> man, I never get to use list comprehensions
19:03:27 <idnar> heh
19:03:32 <idnar> chrisdone: write more python code :)
19:03:35 <skorpan> just use the list monad directly
19:04:04 <skorpan> i have kind of a love-hate-relationship with python... it's really neat and nice, but the code get's so frickin' ugly, no matter what you do
19:05:14 <idnar> I'm pretty happy with most of the Python code I've written, but there's certainly quite a bit of code that I wish were written in Haskell instead
19:06:14 <idnar> the downside of Haskell is that if you can't figure out the "right" way to implement something, it's really difficult to implement something halfway-right
19:06:48 <chrisdone> what are you trying to say? haskell demands elegant programs of you?
19:06:56 <idnar> chrisdone: something like that
19:07:04 <idnar> chrisdone: or at least, it demands far more elegance than, say, python
19:07:15 <idnar> (obviously it's perfectly possible to write inelegant programs even in Haskell)
19:07:21 <chrisdone> Dijkstra would not^H^H^H like this.
19:07:26 <skorpan> !!!!!!
19:07:52 <idnar> chrisdone: in general, I think that's awesome; but sometimes you really need some code *now*, not in a month's time ;)
19:08:16 <chrisdone> idnar: I think it just makes you feel more guilty in Haskell when you write hacky solutions
19:08:30 <idnar> chrisdone: well, it's more than that, though
19:08:39 <skorpan> any haskell function requiring more than two lines requires fewer lines
19:08:57 <idnar> chrisdone: you can't just suddenly drop in an IO action in the bowels of some pure code
19:09:08 <chrisdone> idnar: so?
19:09:18 <skorpan> idnar: why would you do that to begin with?
19:09:33 <Cale> Well, you can actually.
19:09:39 <chrisdone> that's on my list of why haskell is good
19:09:40 <idnar> chrisdone: so writing the hacky solution is actually more difficult, not just more guilt-inducing
19:09:42 <Cale> You just can't have that action executed.
19:09:51 <idnar> Cale: heh
19:10:17 <chrisdone> why does "the hacky solution" involve using IO in pure code?
19:10:23 <idnar> it was just an example
19:10:28 <chrisdone> mmkay
19:10:34 <Cale> You can however, return that IO action, and have it carried out at some other point.
19:10:46 <Cale> If you can decide what needs to be done, then it can be done.
19:10:50 <chrisdone> if anything, reading /other people's/ code is soo much nicer when the type tells you how it can behave
19:11:28 <idnar> chrisdone: look, it's certainly not a bad thing for your code
19:12:07 <idnar> chrisdone: it just means that you can't bang out a five minute hack
19:12:23 <Cale> What's wrong with the solution of just using the IO monad in the case that you don't want to do things the right way?
19:12:26 <chrisdone> idnar: not sure I can agree or disagree with that reasoning
19:12:30 <Cale> I don't see why you can't.
19:12:35 <cizra> Hey, folks
19:12:45 <idnar> Cale: if you're buried in pure code, you'll have to move all the "surrounding" code into the IO monad as well
19:12:54 <Cale> idnar: Buried?
19:12:58 <Cale> idnar: I don't understand.
19:13:15 <idnar> Cale: main -> pure function -> more pure functions ... -> <you are here>
19:13:39 <Cale> But why are you buried in pure code if the thing you're writing has to do IO from there?
19:13:49 <cizra> I managed to write a Jabber bot spouting Estonian national epic with the help of Haskell XMPP library and chrisdone in under 4 hours, being an almost complete newbie!
19:13:53 <cizra> Who said Haskell is very hard?
19:13:57 <idnar> Cale: because you're doing a five minute hack for some dastardly purpose :P
19:14:13 <chrisdone> cizra: yay!
19:14:15 <Cale> idnar: I still don't understand. Why'd you write that code to be pure?
19:14:21 <idnar> Cale: because it's supposed to be pure
19:14:27 <Cale> idnar: No it isn't.
19:14:34 <Cale> idnar: If it has to do I/O, then it's not pure.
19:14:38 <idnar> Cale: but now, I dunno, let's say you need to write some intermediate result out to a socket, and it's too hard to get ahold of it afterwards
19:14:47 <BMeph> cizra: Good show! :)
19:14:53 <Cale> Just return the result.
19:15:02 <idnar> yes, that's the "right" way to do it
19:15:14 <idnar> but you don't have to time to change all the code that expects the old signature
19:15:21 <Cale> Sure you do.
19:15:28 <Cale> It doesn't take that long.
19:15:33 <Cale> and the compiler will help you
19:15:36 <idnar> that depends on how much code is involved
19:15:46 <Cale> It only took 5 minutes to write.
19:15:53 <Cale> So how much could it be?
19:16:23 <idnar> no, the code took months to write; it's the "write intermediate value to a socket" part that you need to do in 5 minutes
19:16:40 <Cale> Get me a concrete example and I'll show you how to handle it.
19:17:17 <chrisdone> does anyone use the "actions have verbs; functions have nouns or adjectives" naming convention? can it be done?
19:17:19 <idnar> I don't exactly have any concrete examples on-hand
19:17:38 <Cale> Also, which socket?
19:17:52 <Cale> If you got hold of a socket, IO can't be very far.
19:18:10 <idnar> grab it from a global variable, or something awful like that
19:18:12 <chrisdone> not a lot one can do with a socket without IO
19:18:22 * chrisdone screams “global‽”
19:18:25 <Cale> idnar: Wouldn't happen.
19:18:36 <rwbarton> :t sizeOf
19:18:37 <lambdabot> Not in scope: `sizeOf'
19:18:39 <idnar> Cale: not in Haskell, no
19:18:41 <Cale> idnar: I doubt that code like you're thinking of actually exists :)
19:18:47 <rwbarton> @hoogle sizeOf
19:18:47 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
19:18:47 <lambdabot> System.Posix.Internals sizeof_stat :: Int
19:19:04 <rwbarton> What's the term for arguments like the one of sizeOf that are ignored? "phantom"?
19:19:25 <idnar> Cale: well, it's a hypothetical example
19:19:48 <idnar> Cale: but I've had to write plenty of five-minute hacks (mostly against my wishes) in the past
19:19:54 <Cale> Of course, it could be that you're working with a program that's just a mess -- but that can happen in any language. Properly designed Haskell code shouldn't be too hard to modify.
19:20:31 <idnar> no matter how well-designed your code is, it's always going to be harder to make changes along certain axes, especially if the need to make changes along those axes was not anticipated in the first place
19:20:52 <Cale> But I think you're overemphasising the difficulty here.
19:21:03 <Cale> This is not really difficult in practice.
19:23:11 <Cale> http://www.marriedtothesea.com/122708/red-ball.gif
19:23:51 <idnar> Cale: if programming were that easy, we'd all be out of jobs ;)
19:24:14 <Cale> I mean it's not difficult for a programmer :)
19:24:36 <Cale> You have a number of options which are relatively easy to manage.
19:24:47 <idnar> I think I did actually have one of these moments writing some Haskell code a while back, but it looks like I threw the code away
19:25:08 <sclv_> I don't think that Haskell makes it harder to write "halfway right" things...
19:25:13 <sclv_> you just have to be explicit.
19:25:34 <Cale> Either add an IO action to the result of the function which is what you're going to do later, or add other data to its result which expresses something about what you're going to need to do.
19:25:37 <idnar> I discovered I needed to generate some random numbers a couple of functions down
19:25:53 <Cale> So you add StdGen parameters to 2 functions.
19:25:56 <sclv_> i.e. if you use fromJust and head carelessly, etc.
19:26:03 <idnar> so I ended up threading RandomGen through the code
19:26:05 <idnar> which wasn't much fun
19:26:09 <sclv_> or better yet -- implicit params!
19:26:14 <Cale> Or use the Rand monad.
19:26:28 <idnar> there were about a dozen functions that needed to change, I think
19:26:39 <sclv_> implicit params are perfect for that sort of careless "thread some value down here" thing
19:27:03 <idnar> sclv_: you still have to add the implicit params to the intervening function type signatures, don't you?
19:27:05 <Cale> The changes to add a parameter are usually very straightforward.
19:27:11 <Cale> idnar: No.
19:27:15 <sclv_> idnar: nope -- that defeats the purpose.
19:27:19 <idnar> hmm
19:27:30 <sclv_> also, why do you have type signatures at all if you're doing something quick and dirty?
19:27:32 <Cale> I tend not to use implicit parameters.
19:27:48 <idnar> sclv_: you're making a quick'n'dirty modification to an existing "nice" codebase
19:28:30 <Cale> If the codebase is actually nice, then things will probably be factored enough already so that you can do the first half of the pure computation, stick some IO in, and then do the rest.
19:28:33 <idnar> anyhow, I don't think implicit params would help with RandomGen
19:28:34 <sclv_> I generally don't have much use for them either, but threading through a random generator, or a set of top-level options, etc., seems like a perfectly nice use of them.
19:28:41 <idnar> Rand monad might have been easier, I didn't know about it at the time
19:29:13 <sclv_> idnar: not i guess if you need to enforce its sequential use. Linear implicit params would have helped, but... they are no more.
19:29:18 <idnar> I don't see how you'd use implicit params with a random generator; you have to "mutate" the generator along the way, otherwise you'll keep getting the same results
19:30:47 <sclv_> anyway, adding randomness to pure code is arguably a massive change that only appears simple due to the hand-waviness of typical imperative thought.
19:31:18 <idnar> sclv_: I'm not saying it necessarily should be simple
19:31:31 <FunctorSalad> @src Rand
19:31:31 <lambdabot> Source not found. Sorry.
19:31:38 <idnar> sclv_: or rather, I'm not saying that dumping a call to rand() into the middle of some imperative code is necessarily a good thing
19:31:58 <idnar> sclv_: it's just that you can do awful things like that as an "escape mechanism"
19:32:10 <FunctorSalad> this I suppose http://hackage.haskell.org/packages/archive/MonadRandom/latest/doc/html/Control-Monad-Random.html#t:Rand
19:32:32 <sclv_> unsafePerformIO is always there too, depending on how "quick & dirty" you want to be.
19:32:35 <idnar> either because you don't have the time to do the right thing, or because you're not good enough / don't know enough to know what the right thing is
19:33:00 <Cale> idnar: Another thing you can do is just use mkStdGen to make a constant generator :)
19:33:01 <sclv_> not that I think fromJust or unsafePerformIO should be used in serious code.
19:33:21 <Cale> Which will work well enough for a single run.
19:33:50 <chrisdone> I've seen unsafePerformIO used for things that seemed reasonable
19:33:58 <chrisdone> i.e. making MVars
19:34:03 <chrisdone> (global ones)
19:34:07 <chrisdone> but is that unreasonable?
19:34:25 <sclv_> there's a haskell holy war right there.
19:34:29 <pumpkin> what's more efficient, map (^2) [1..] or scanl1 (+) [1,3..]?
19:34:31 <idnar> global state is always unreasonable, right? :P
19:34:43 <sclv_> short answer: ghc central and associated clever people lean towards "no"
19:35:05 <Cale> Global MVars/IORefs are always a bad plan. They're more trouble than they're worth, and you're just making problems for future maintainers.
19:35:09 <sclv_> real world programs occasionally do it anyway though.
19:35:20 <FunctorSalad> could one say that IO is special among the monads in that there's no way to "deconstruct" a monadic value? (unsafePerformIO excluded of course)
19:35:24 <chrisdone> (GHCi on Acid does it)
19:35:27 <Cale> They hurt the scalability of the code.
19:35:28 <centrinia> pumpkin, I think you can do the map in O(1) time while you need O(log n) time to do the scan.
19:35:45 <chrisdone> Cale: what is meant by "scalability"?
19:35:53 <sclv_> FunctorSalad: "deconstruct" on an IO value is executing the program, no?
19:35:54 <FunctorSalad> (and of course IO-base monads like StateT a IO)
19:36:11 <FunctorSalad> sclv_: heh, good point
19:36:13 <Cale> chrisdone: Well, if you have some functions which depend on an IORef/MVar, they're reusable.
19:36:38 <chrisdone> Cale: oh. "compsable"
19:37:00 <Cale> chrisdone: If they just refer to a specific global IORef/MVar, then you've designed your program so that there can be only one use for them, because they're referring to that one thing.
19:37:08 <sclv_> the problem is I think what is meant by "global" as well -- scope of a linked GHC runtime? scope of a library loaded into it? scope of the computer?
19:37:11 <sclv_> scope of the universe?
19:37:14 <Cale> It's the singleton anti-pattern in disguise.
19:37:30 <chrisdone> Cale: yeah, that's reasonable
19:37:40 <sclv_> Cale: that's so backwards! The singleton anti-pattern is just global state in disguise. :-)
19:37:47 <FunctorSalad> some resources are really unique ;)
19:37:48 <Cale> sclv_: Of course.
19:37:55 <Cale> sclv_: But "singleton" is a good name
19:38:04 <Cale> sclv_: Because it expresses exactly what's wrong with it.
19:38:14 <Cale> (eventually you might want another)
19:38:29 <sclv_> FunctorSalad: sure, but they're not unique to an instance of a linked library in a loaded runtime.
19:38:30 <chrisdone> Cale: I had to hack on a C program a while ago which had a shit tonne of global state. I wished I could just call the main function twice from main(), in order to get multiple results. it was horrid
19:38:33 <Cale> No resource is really all that unique.
19:38:41 <sclv_> which is all that the MVar gives you.
19:38:53 <Cale> Resources are only unique because we paint ourselves into a corner.
19:39:08 <Cale> (or we don't have enough money to buy ourselves another)
19:39:09 <FunctorSalad> sclv_: process data? j/k
19:39:27 <FunctorSalad> the headers, rather
19:39:40 <sclv_> Cale: what about a resource that is by definition unique, such as a unique name generator?
19:39:57 <sclv_> (which, I'll grant, you can thread through...)
19:39:59 <Cale> sclv_: I see no reason why you can't have two of those.
19:40:45 <Cale> In fact, it's common to want to use multiple unique name generators, especially when they generate names in an order that the nicest names are first.
19:41:02 <sclv_> ok, point granted :-)
19:41:31 <sclv_> hmm... a string interning pool, like atom!
19:41:42 <pumpkin> is there an easy way to write a "permuter" function? that takes in two lists of the same length and the same symbols
19:41:46 <ben_h> chrisdone: haha, i just tried calling main from main, it worked
19:41:46 <sclv_> you can have two, I suppose.
19:42:16 <pumpkin> and rearranges a given list according to the permutation from the two lists passed in
19:42:21 <ben_h> i thought it might have been treated as a special case.
19:42:45 <sclv_> pumpkin: think of it in two steps, no? there's an easy way to turn the two lists into a list of reorderings.
19:42:52 <sclv_> and there's an easy way to apply the reorderings.
19:43:03 <pumpkin> it's the applying the reordering that I'm wondering about
19:43:11 <chrisdone> ben_h: haha
19:43:36 <sclv_> zip the list-to-be-reordered with the reordering list, then sort it on snd.
19:43:37 <pumpkin> makePermutation :: [a] -> [a] -> [a] -> Maybe [a]
19:43:43 <FunctorSalad> pumpkin: do an elementwise replace on list2, with the replacements given by list1 => list3?
19:43:46 <ben_h> it's like fork, but optimised! :)
19:43:52 <pumpkin> sclv_: ah, good idea
19:44:19 <pumpkin> thanks :)
19:44:30 <chrisdone> ben_h: I've seen some obfuscated C code which used a recursive call to `main'
19:44:35 <ben_h> nice
19:44:40 <FunctorSalad> map f list2 where f x = lookup x (zip list1 list3) -- inefficient
19:44:51 <ben_h> i love some of those IOCCC entries
19:44:58 <FunctorSalad> you'd probably want to cosntruct a map for the lookup
19:45:18 <FunctorSalad> (a Data.Map)
19:45:45 <pumpkin> FunctorSalad: yeah
19:45:59 <pumpkin> thanks :)
19:46:02 <pumpkin> I'll play around with it
19:46:09 <idnar> sclv_: even if there's nothing else, you'll probably want "another one" for testing the code
19:46:35 <idnar> otherwise you have to do end-to-end type testing
19:46:57 <chrisdone> “Perhaps you haven't installed the profiling libraries for package strict-0.3.2?” -- how is a profiling library made? can I simply alter the .cabal file for the strict package to do this?
19:47:52 <Cale> chrisdone: Pass the  --enable-library-profiling  switch to cabal
19:47:54 <mmorrow> ghc's Linker.c currently has a single global symbol table
19:48:06 <chrisdone> Cale: brilliant, cheers
19:48:07 <Zao> > map fst $ sortBy (compare `on` snd) $ zip "abcd" [4,3,2,1]
19:48:09 <lambdabot>   "dcba"
19:48:17 <Zao> Is there any more succinct way of expressing that?
19:49:03 <Asztal> > map fst $ sortBy (comparing snd) $ zip "abcd" [4,3,2,1]
19:49:04 <lambdabot>   "dcba"
19:49:11 <luite> is it possible to get more information about an "Error in array index" error? for example the location where it occurred?
19:50:31 <Cale> > sortBy (flip compare) "abcd"
19:50:32 <lambdabot>   "dcba"
19:51:36 <idnar> > reverse "abcd"
19:51:38 <lambdabot>   "dcba"
19:54:40 <Zao> I sense a slight loss of genericity there :)
19:54:43 <MarcWeber> Is there a way to get the module name by cpp or such?
20:00:02 <mmorrow> re: global vars. currently, the only way (that i'm aware of) to be able to allow dynamically compiled and run (via ghc-api) code to be able to "reach back through the rabbit hole" and modify a var of the code that's running it is to (say the module that is running this code is called A) import A into the dynamically compiled/run codes environment, plus have a global IORef/MVar in A, which the dynamic code can now see and manipulate.
20:00:26 <mmorrow> i've been thinking a lot about this, as i think there's some really cool possibilities in this
20:02:10 <mmorrow> like you could have dynamically compiled code which takes over the program itself and incrementally morphs it into another prog
20:02:49 <mmorrow> but back on topic, i can't think of any way to do this without a global var (i'd very much like to not use the global)
20:04:32 * mmorrow is be very interested in anyone's random comments on self-modifying/whatever code
20:06:56 <rwbarton> mmorrow: The host program could use a State monad, and  modify (eval "...")  or whatever
20:08:24 <mmorrow> rwbarton: hmm. true. but suppose i want the code in the "..." to be able to reach back and grab the code that's running it (here, being the code that's calling modify (eval ".."))
20:09:08 <mmorrow> so the full ability to invert control across an eval line
20:09:18 <mmorrow> (or something)
20:09:30 <mmorrow> i'm not sure yet exactly what this would mean
20:09:53 <rwbarton> Well, that code could be part of the state, I guess
20:10:11 <ksf> mmorrow, do you know 3lisp?
20:10:14 <rwbarton> but I think you'd have to plan to some extent what code you want to be replaceable, yeah
20:10:31 <mmorrow> rwbarton: totally. hmm, that's an idea.
20:10:37 <mmorrow> rwbarton: ideally, all of it :)
20:10:45 <mmorrow> ksf: i don't
20:10:57 <mmorrow> rwbarton: (to the extent that that's possible)
20:11:30 <chessguy_> what are we talking about? self-modifying programs?
20:11:38 <mmorrow> rwbarton: but anything's possible of course. it's just a question of whether it's feasible given the capabilities at hand.
20:11:46 <mmorrow> chessguy_: yes
20:11:53 <chessguy_> to what end?
20:12:03 <mmorrow> to the end of doing it with the ghc-api
20:12:13 <mmorrow> (or any equivalent thing)
20:12:20 <mmorrow> in haskell, now
20:12:26 <ksf> I'm looking for that paper on it that doesn't assume that you know arcane misfeatures of 70's lisp by hard.
20:12:47 <mmorrow> ksf: heh, nice
20:14:15 <mmorrow> one thing that makes harpy friggin sweet is that you can dynamically gen code, malloc a buffer, write it in, and jmp (ok fine, call ;)
20:14:59 <ksf> mmorrow, http://p-cos.blogspot.com/2008/09/reflection-for-masses.html
20:15:08 <mmorrow> ksf: great, thx.
20:17:42 <mmorrow> <rwbarton> Well, that code could be part of the state, I guess
20:18:12 <mmorrow> yes! exactly. i didn't connect this with other thoughts i'd had before
20:18:28 <mmorrow> so that code would be in this global MVar
20:18:32 * ksf skims the paper and has to admit that lisp tends to be easier to parse than haskell
20:18:51 <mmorrow> an understatement ;)
20:19:00 <rwbarton> mmorrow: I more meant, in the state contained in the State monad
20:19:16 <ksf> ...not only for a computer.
20:19:29 <mmorrow> rwbarton: also contained in this global MVar ;)
20:19:59 <mmorrow> rwbarton: essentially, just stick main' in this MVar, and
20:20:12 <ksf> haskell sometimes looks like toon characters swearing.
20:20:14 <mmorrow> main = join (readMVar global)
20:20:31 <mmorrow> rwbarton: that'd be sweeet. hmm.
20:20:34 <chrisdone> join❤♥
20:25:40 <Axman6> @hoogle .$
20:25:40 <lambdabot> No results found
20:25:44 <Axman6> @hoogle (.$)
20:25:44 <lambdabot> No results found
20:31:55 <ksf> subtracting geometries in fieldtrip would be a charm.
20:36:38 <pantsd> is http://dada.perl.it/shootout/wordfreq.ghc.html sane? Part of what I'm doing involves doing a frequency count of words, so I'm wondering if I should just use this or rewrite it to use Data.Map...
20:39:41 <rwbarton> pantsd: I would suggest using Data.Map, in particular fromListWith
20:40:03 <rwbarton> pantsd: Although, that can run into strictness problems
20:40:27 <mpwd> If I only have 4 or 5 hash values, is it better to use [(key, val)] instead of Data.Hash, or will I still see a severe performance hit?
20:40:42 <mpwd> erm 4 or 5 keys rather
20:41:52 <pumpkin> mpwd: I'd do a quick test and see how they compare :)
20:42:40 <pumpkin> but for something that small, I'd expect a list should be plenty fast
20:43:05 <mpwd> That's my suspicion too.  Also, this is all pure code so I'd rather not have to bring IO into this
20:43:28 <mpwd> which is how HashTable is implemented sadly
20:43:28 <pumpkin> if it were larger I'd still use Data.Map or IntMap
20:43:32 <rwbarton> The general advice you will get here is not to use Data.HashTable
20:43:41 <pumpkin> a hashtable is not a very "functional" datastructure
20:43:41 <rwbarton> Right, use Data.Map instead
20:44:55 <rwbarton> I've never used Data.HashTable.  Data.Map is quite nice
20:45:04 <pumpkin> same here
20:45:14 <pumpkin> and I'm not sure how you'd implement a hash table efficiently without making it mutable
20:45:20 <pumpkin> without having to copy the whole thing every time
20:46:24 <mpwd> This is pretty nice.  I'm confused why there's a Data.HashTable to begin with now.
20:46:52 <ozy`> mpwd: because all languages desperately need hash tables no matter what
20:47:05 <pumpkin> it doesn't require Ord on its keys does it?
20:47:36 <pumpkin> which is one potential advantage compared to Map and Set, but I'm not sure how it's computing the hashes... I'd assume you'd need a Binary instance on your key?
20:47:50 <pumpkin> or it's just doing some secret encoding voodoo behind the scenes?
20:48:32 <rwbarton> I think you have to provide a hash function yourself
20:48:37 <pumpkin> oh
20:48:44 <pumpkin> oh yeah, you do
20:49:00 <mpwd> pumpkin: keys are just strings, lots of hash functions for these and Data.HashTable even has one out of the box
20:49:11 <mpwd> pumpkin: But I'd rather program using pure code
20:49:22 <pumpkin> the one I'm looking at doesn't impose a String requirement but does want a hash function
20:49:27 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
20:49:42 <pumpkin> which makes it quite flexible but a bit of a pain to use
20:52:53 <pumpkin> although I guess if you can provide a hash function mapping your type to an Int, you could easily use that same function to provide an Ord instance for anything you want to stick into a MAp
20:53:07 <pumpkin> :P
21:00:37 <ik> DAYCHANGE!
21:10:06 <pumpkin> > text "hi francis_"
21:10:07 <lambdabot>   hi francis_
21:10:35 <francis_> :o
21:23:41 <pumpkin> hmm, my ubuntu is giving me ghc 6.6
21:24:12 <francis_> how do you get out of  ghci
21:24:17 <pumpkin> :q
21:24:53 <francis_> thx
21:30:41 <Gracenotes> I also use Ctrl+D
21:31:16 <Gracenotes> that doesn't work if you have anything on the line, so I tend to do Ctrl+U+K+D
21:33:25 <kabny> how is functional reactive programming?
21:33:37 <kabny> can it compete with swing+miglayout?
21:33:53 <sclv_> frp is an idiom, not a toolkit.
21:34:12 <skorpan> what is reactive programming?
21:34:22 <ddarius> @where frp
21:34:25 <lambdabot> I know nothing about frp.
21:34:29 <skorpan> see!
21:34:45 <sclv_> frp implementations are built on top of various graphics libraries -- gtk, wtk, etc.
21:35:05 <CakeProphet> is there an easy way to specify default values for command line arguments?
21:35:32 <skorpan> oh, reactive programming is closely related to event driven programming?
21:35:32 <CakeProphet> I have a feeling checking the length of the list conditionally is unecessary.
21:36:04 <sclv_> CakeProphet -- command line arguments to what?
21:36:09 <CakeProphet> ...my Haskell program.
21:36:15 <CakeProphet> the list I get from getArgs.
21:36:23 <sclv_> depends on your idiom.
21:36:27 <CakeProphet> I want to fill in with default values if they're not specified.
21:36:31 <sclv_> If you parse your list from getargs into a map.
21:36:39 <sclv_> and have a map of default values and then union them...
21:36:52 <CakeProphet> ...I just have the list at the moment, but is there a function that parses it into a map?
21:37:34 <sclv_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parseargs
21:37:45 <ddarius> sclv_: frp has nothing to do with graphics libraries.
21:38:06 <sclv_> fine, frp implementations can bind to various graphics libraries.
21:38:13 <sclv_> or not.
21:39:12 <jsgf> hi all
21:39:21 <sclv_> skorpan: its sort of related to event driven programming, but i'm not sure if that's the right approach.
21:39:37 <jsgf> I have a question arising from the Functor chapter in RWH
21:39:38 <skorpan> i just read a bit about it on wikipedia
21:39:48 <skorpan> sounds really cool
21:39:58 <sclv_> functions over streams might be a better way to think of it... or maybe not.
21:40:11 <sclv_> jsgf: fire away
21:40:28 <jsgf> in "instance Functor (Either Int) ...", why can't I use "fmap _ l@(Left n) = l" as a pattern?
21:40:47 <ddarius> jsgf: What's the type of l?
21:41:10 <jsgf> Either?
21:41:18 <ddarius> Either isn't a type.
21:41:32 <jsgf> fmap _ (Left n) = Left n works
21:41:37 <ddarius> Yes, it does.
21:41:39 <dmwit> correct
21:41:40 <CakeProphet> :t Left 5
21:41:40 <sclv_> ?src Either fmap
21:41:41 <lambdabot> fmap _ (Left x) = Left x
21:41:41 <lambdabot> fmap f (Right y) = Right (f y)
21:41:41 <lambdabot> forall t b. (Num t) => Either t b
21:41:56 <dmwit> jsgf: Think carefully about the types.
21:42:23 <jsgf> i had imagined that l@ would give a name to the matched pattern, but wouldn't affect pattern matching itself
21:42:31 <dmwit> jsgf: In particular, think about how the type of the pattern l@(Left n) on the LHS restricts the type of the value "l" on the RHS.
21:42:46 <dmwit> jsgf: That is correct.
21:43:04 <dmwit> jsgf: But "l" and "Left n" do not have the same type.
21:43:09 <dmwit> (!)
21:43:36 <dmwit> jsgf: Because the "Left" on the LHS and RHS of "fmap _ (Left n) = Left n" are not the same Left...
21:43:57 <ddarius> dmwit: "Left n"
21:44:01 <sclv_> tricky. :-)
21:44:33 <ddarius> (Well, I guess you could view it as implicitly applied in the two usages.)
21:44:58 <jsgf> dmwit: i'm getting a glimmer of insight, but not quite there;
21:45:18 <ddarius> jsgf: If you can answer my original question, everything will be clear.
21:45:19 <jsgf> are you saying that "Left" might be a constructor for multiple types?
21:45:26 <dmwit> jsgf: Okay, do you want me to spoil the surprise, or do you want to think more?
21:45:38 <sclv_> ?ty \l@(Left n) -> l
21:45:39 <lambdabot> forall t t1. Either t t1 -> Either t t1
21:45:47 <dmwit> sclv_: Good hint.
21:45:59 <dmwit> ?ty \l@(Left n) -> Left n
21:46:00 <lambdabot> forall t t1 b. Either t t1 -> Either t b
21:46:13 <dmwit> jsgf: Those two are subtly different. ;-)
21:46:27 <idnar> huh?
21:46:38 <jsgf> ok, gotcha
21:46:42 <idnar> oh, evil
21:46:45 <dmwit> =D
21:46:51 <chrisdone> I just noticed that Lisp doesn't have a sweet home page like haskell.org
21:46:59 <jsgf> its the other type which isn't bound to anything properly
21:47:05 <dmwit> right
21:47:07 <pumpkin> who owns haskell.org?
21:47:27 <pumpkin> yale :o
21:47:28 <idnar> @type fmap
21:47:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:47:29 <pumpkin> hudak?
21:47:38 <ddarius> http://haskell.org/haskellwiki/Haskell.org
21:49:05 <ddarius> chrisdone: The CL community isn't as coherent or small as the Haskell one, neither is the Scheme community though it seems a bit more coherent than the CL one.
21:49:22 <jsgf> dmwit: so what would be the syntax to make the l@(Left n) -> l have the right type?
21:49:40 <CakeProphet> sclv_:  how can I extend the call to parseArgs over multiple lines?
21:50:46 <ddarius> jsgf: There is no magic syntax.  \(l@(Left n) -> l is the same as \l -> l, the two occurrences of l must have the same type.
21:50:53 <ddarius> (They are identically the same thing.)
21:51:02 <sclv_> CakeProphet: dunno, haven't used the library a great deal.
21:51:05 <mmorrow> rwbarton: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=692#a692
21:51:25 <ac> so I just installed SuperCollider, and I'm wondering if the Haskell SC packages are actually practical to use
21:51:53 <CakeProphet> sclv_:  I mean... I want to extend it over multiple lines for readability... like \ in Python.
21:52:05 <strht> all packages are practical to use
21:52:06 <ddarius> ac: Try it and find out.  You will get better quality answers quicker that way.
21:52:14 <strht> hell, with the entirety of hackage, you could probably make a sentient being
21:52:16 <CakeProphet> will an unclosed parenthesis allow that?
21:52:22 <sclv_> you can have linebreaks anywhere in your haskell code
21:52:26 <Gracenotes> hrm. I'm always confusing whether impure code should use pure code, or vice versa. Then the type system reminds me :)
21:52:29 <sclv_> barring certain rules
21:52:42 <sclv_> the key is that the following line needs to be indented equally or more than the previous
21:52:44 <jsgf> ddarius: yes, but couldn't I tack a type qualifier (is that the right term?  type constraint?)  on there somehow?
21:52:50 <CakeProphet> sclv_:  ah, alright.
21:53:18 <sclv_> there's some complexities i'm glossing over -- involving if then, do notation, etc. but its all in the haskell report.
21:53:26 <ddarius> jsgf: I already answered that.  The only type annotation you could give would say that l has the type that l has.
21:54:17 <sclv_> the type that ghci infers, absent language extensions (and probably something else i'm forgetting) will be the most general type of a given function.
21:55:03 <ac> ddarius: only if nobody here has used any of those packages
21:55:40 <jsgf> ddarius: hm, ok, I'll have to think on it some more
21:56:00 <ddarius> ac: What one person might consider "practical" might not match what you consider "practical."  Anyway, you could have already installed it by now and been playing with it instead of talking here.
21:56:12 <Armored_Azrael> Maybe I'm just being dense, but I can't seem to find the function for determining the last modified time of a file in haskell. Does anyone know the function for doing this, or do I need to use text processing on shell commands?
21:56:51 <ac> ddarius: I'm actually trying to figure out which package to install. Do you know what Haskore does?
21:56:57 <sclv_> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Files.html
21:57:09 <sclv_> Armored_Azrael:  ^^
21:57:15 <chrisdone> ddarius: indeed. a simple google search for common lisp kind of demonstrates the incoherence of the community (compared to googling haskell). it seems decentralisation of programming language communities spreads it thin and creates a diversity which, although "nice", makes it hard to direct focus of effort
21:57:39 <mmorrow> System.Directory.getModificationTime
21:57:48 <ddarius> ac: Haskore is for algorithmically composing music.
21:57:51 <sclv_> or that would be the easier way.
21:58:00 <Armored_Azrael> mmorrow: sclv_: Thanks.
22:02:03 <ac> ddarius: ah. I want hsc3
22:02:16 * ac is amused at the name "unsafe haskell super collider"
22:03:13 <pumpkin> hmm my cabal-install bootstrap failed
22:03:26 <pumpkin> says my dependencies failed: HTTP >=3000 && <3002, network >=1 && <3
22:04:10 <CakeProphet> can you specify  type signatures  for functions defined in a where/let?
22:04:27 <pumpkin> CakeProphet: yeah
22:05:10 <sclv_> note that the type  variables you use don't correspond to those in the enclosing declaration however
22:05:18 <sclv_> unless you enable ScopedTypeVariables
22:05:30 <pumpkin> anyone know what's wrong with my boostrap.sh for cabal-install?
22:06:01 <CakeProphet> pumpkin:  did you install GHC via apt-get?
22:06:04 <pumpkin> yeah :P
22:06:26 <CakeProphet> well, mine did the same thing, it just needed some other packages.
22:06:31 <CakeProphet> lemme see if I can find them.
22:06:33 <ddarius> pumpkin: Have you installed those dependencies?
22:06:44 <pumpkin> ddarius: bootstrap.sh downloaded and appeared to be installing them
22:06:59 <ddarius> pumpkin: And?  Did they error out or what?
22:06:59 <pumpkin> or maybe that wasn't network
22:07:30 <pumpkin> oh , looks like http errored out
22:07:52 <pumpkin> says network and parsec are missing
22:08:07 <pumpkin> I've never installed packages manually
22:08:17 <CakeProphet> [sudo] apt-get install libghc6-http-dev
22:08:27 <CakeProphet> oh... then
22:08:32 <Gracenotes> pumpkin: same thing happened to me
22:08:41 <pumpkin> oh, that seems to be grabbing both parsec and network
22:08:44 <CakeProphet> [sudo] apt-get install libghc6-http-dev libghc6-parsec-dev libghc6-network-dev
22:08:45 <CakeProphet> I think
22:08:53 <CakeProphet> ah
22:08:58 <Gracenotes> CakeProphet: yeah, that worked for me
22:09:02 <pumpkin> I'm used to the .pkg for mac os doing everything for me
22:09:04 <pumpkin> thanks :)
22:09:13 <Gracenotes> although actually I manually downloaded the sources and compiled each
22:09:21 <CakeProphet> pumpkin:  yeah, dependencies are fun when you don't have a package manager.
22:11:03 <CakeProphet> hmmm, by the way, do you guys pronounce sudo as "sue do" or "sue doe"?
22:11:08 <CakeProphet> I do the second.
22:11:37 * ddarius always does the first.
22:11:39 <Gracenotes> latter...
22:12:18 <strht_> i know my job
22:12:21 <strht_> "sue doe"
22:12:43 <strht_> su-doo sound like "doodoo"
22:13:41 <joed> Mind it all, if called via sql injections you'll hate Sue
22:14:01 <joed> Sue.
22:14:21 <strht_> chroot everything
22:14:31 <strht_> indiscriminately
22:14:35 <joed> Indeed, and then that is broken.
22:14:40 <strht_> until your mind is chrooted
22:14:48 <strht_> granted, most minds are firmly chrooted
22:15:00 <francis_> lmao
22:15:19 <wli> Good way to descibe it.
22:15:21 <CakeProphet> @src getStdGen
22:15:21 <lambdabot> Source not found. Take a stress pill and think things over.
22:15:33 <luqui> @quote strht most minds are firmly chrooted
22:15:34 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
22:15:41 <luqui> @remember strht most minds are firmly chrooted
22:15:42 <lambdabot> Nice!
22:15:54 <strht> i'm glad you think it's funny
22:15:59 <strht> the IRCops think i'm inciting rebellion
22:16:27 <sclv_> luqui: a while ago you posted a query to haskell-cafe about a "spine-lazy multiqueue".
22:16:39 <sclv_> I'm wondering if you have the final source of what you settled on laying around?
22:16:49 <pumpkin> how can I ask lambdabot to connect automatically to a server when it starts up?
22:16:54 <luqui> sclv_, turns out just a trie was perfect
22:17:06 <luqui> sclv_, and I was being dumb by not thinking of it
22:17:47 <Saizan> pumpkin: see the online.rc
22:17:55 <luqui> also what I "settled on" was realizing that my algorithm was wrong :-(
22:18:05 <pumpkin> Saizan: where does that live?
22:18:09 <sclv_> ah, gotcha. i was puzzling over a better type for :-> in conal's stuff and wondered if it might relate.
22:18:14 <Saizan> pumpkin: edit that and then run it like lambdabot -e 'rc online.rc'
22:18:16 <sclv_> but I don't think a trie will help there.
22:18:16 <pumpkin> oh I found it
22:18:35 <luqui> sclv_, :->?  you mean MemoTrie?
22:18:43 <ac> sue dough
22:18:45 <sclv_> A sequence.
22:18:58 * luqui is los
22:18:59 <sclv_> as in sequences, segments, and signals.
22:18:59 <luqui> t
22:19:02 <luqui> oh
22:19:26 <sclv_> its currently just a list... but I don't think that the efficiency hit is really significant.
22:19:29 <luqui> I haven't been paying as close attention as I should have been to that
22:19:56 <sclv_> well, you're finding your own path. :-)
22:20:36 <luqui> :-)  I hope someday to produce something.  =P
22:21:09 <pumpkin> Saizan: my commands are getting terminated almost instantly :(
22:23:49 <pumpkin> I write > 5 and it responds "Terminated"
22:24:34 <luqui> pumpkin, yow.   have you been pushing Ctrl-C a lot?  (though I expected it to say "Interrupted" in that case)
22:24:44 <pumpkin> nope, this is in irc
22:24:51 <luqui> ohhh
22:24:52 <pumpkin> I asked it to join a channel of mine
22:25:14 <pumpkin>  @pl works fine though
22:25:31 <sclv_> lambdabot is hosted on a system with low resources.
22:25:52 <pumpkin> hmm, I have a gig of ram on it and it's a quad processor
22:26:02 <Saizan> pumpkin: did you install mueval?
22:26:04 <sclv_> Oh, this is your own bot?
22:26:07 <sclv_> never mind then.
22:26:07 <pumpkin> yeah
22:26:14 <pumpkin> Saizan: nope :P
22:26:30 <Saizan> pumpkin: that explains it :)
22:26:31 <sclv_> heh. that might do it.
22:26:41 <pumpkin> I thought it grabbed its own dependencies :)
22:26:53 <pumpkin> it sure downloaded a lot of stuff before
22:26:53 <Saizan> runtime dependencies are not trackged
22:26:57 <pumpkin> ah
22:27:49 <strht> <3 internet
22:27:50 <Saizan> you're also going to need some packages like parallel and numbers, that i don't think will be installed automatically
22:28:27 <pumpkin> Control.Arrow.Transformer.All
22:28:32 <pumpkin> where's the list of packages it's trying to load?
22:29:29 <Saizan> you can only get a list of modules, by looking at Pristine.hs
22:29:36 <Saizan> and mueval source
22:29:44 <Saizan> however that's from arrows
22:30:25 <CakeProphet> :t any
22:30:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:30:30 <CakeProphet> excellent
22:34:34 <llayland> Is there a point to the eta reductions that hlint recommends?  It doesn't seem natural to me, but maybe that is just my inexperience
22:35:02 <conal> sclv_: i expect to use signals (a :-> b) in a monotonic way, and hence lists.  for random access, i'd want a different data structure.
22:36:04 <pumpkin> anyone have the source to that ... operator someone defines in here sometimes?
22:36:07 <CakeProphet> :t randoms
22:36:08 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
22:36:08 <pumpkin> for polynomial sequences?
22:36:12 <sclv_> conal: right. but i'm not sure what would keep the properties I want, particularly laziness in the spine.
22:36:34 <sclv_> i'm thinking about tries more.
22:38:47 <conal> sclv_: do you intend to sample non-monotonically?
22:39:13 <sclv_> conal: that's the general notion. its a different direction.
22:39:22 <conal> sclv_: cool :)
22:41:45 <sclv_> along with changing the underlying function representation, my other big change is enclosing length in a Bounded type to get rid of the Bounded restriction everywhere,
22:43:21 <sclv_> the main goal is to solve differential equations for bounded functions in a simple manner, and it mainly works.
22:43:57 <sclv_> i'll send on what i have once i tweak it a bit further.
22:44:10 <conal> i'd like that, thanks.
22:44:19 <CakeProphet> :t randomR
22:44:20 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
22:54:56 <CakeProphet> does using newStdGen actually give you two discrete random generators?
22:55:46 <CakeProphet> or do you have to use the first one until you're done with it, and then use newStdGen
22:57:27 <Gracenotes> CakeProphet: newStdGen takes the existing universal generator and does this to it: http://hackage.haskell.org/packages/archive/random/1.0.0.1/doc/html/src/System-Random.html#stdSplit
22:58:04 <CakeProphet> Gracenotes:  how do random/randoms/etc derive new generator values to yield?
22:58:17 <CakeProphet> is it based on this universal generator or is it calculated from the one you just gave it
23:00:10 <CakeProphet> :t insert :: IntMap a
23:00:12 <lambdabot>     Not in scope: type constructor or class `IntMap'
23:00:17 <CakeProphet> :t insert :: Map a
23:00:18 <lambdabot> Not in scope: type constructor or class `Map'
23:00:53 <Gracenotes> :t insert :: IM a
23:00:54 <lambdabot> Not in scope: type constructor or class `IM'
23:01:00 <Gracenotes> :>
23:01:09 <CakeProphet> I got it through ghci, no worries.
23:05:26 <conal> sclv_: i'm reading responses to "black hole detection and concurrency" by you & Bertram.  i'm not sure i understand the basic trick of killing one's own thread and then restarting the computation.  do you know how the post-kill resumption occurs?  i.e., how control passes to the tail-recursive call after the self-kill?
23:08:09 <conal> is Bertram Felgenhauer here?  does he hang out in #haskell?
23:10:57 <CakeProphet> can you pattern match on list elements?
23:11:07 <CakeProphet> like this
23:11:20 <CakeProphet> [a,b,c] = somelist
23:11:25 <pumpkin> > second (+5) (2,0)
23:11:26 <lambdabot>   (2,5)
23:11:35 <pumpkin> that isn't working on my lambdabot
23:11:38 <CakeProphet> or do you need to do a:b:c:[] = somelist
23:11:40 <pumpkin> it says mueval no parse
23:11:53 <rwbarton_> CakeProphet: the first works too
23:12:00 <CakeProphet> excellent
23:15:45 <llayland> Hurrah, I'm hlint free
23:16:00 * joed smacks dibblego  in the ball
23:16:07 <joed> Asswipe
23:16:08 * dibblego lols at joed :)
23:16:20 <joed> dibblego: *)
23:16:21 <dibblego> going to teach me about monads? :)
23:16:49 <joed> dibblego: No, I'll at least front what you taught me in Java, you dick.
23:17:00 <dibblego> tehe
23:17:30 <dibblego> by the way, CodeWar wants closed algebraic data types - which you can emulate in Java - but it is retarded, ala Java
23:17:39 <joed> dibblego: Okay, troll of the day, I should have got that..... (sig)
23:17:51 <dibblego> I was being mostly serious - not trolling
23:17:58 <joed> dibblego: yeah, I know, we told him 3 hours ago.
23:17:59 <dibblego> (whatever that means)
23:19:09 <joed> dibblego: pretty much working on a deadline right now, I was more surprised to see argument on this/
23:19:28 <dibblego> joed, I wrote an article yesterday about Java in IO
23:19:28 <joed> dibblego: AssHat :)
23:19:45 <dibblego> http://blog.tmorris.net/controlling-effects-with-flatmap/
23:21:05 <joed> dibblego: Okay, got it bookmarked, I'm too tired to compute it.
23:21:11 <dibblego> ok
23:21:24 <dibblego> I wrote one on the continuation monad a few hours ago - in a break
23:21:50 <joed> Yeah, those two I now want you to explain :)
23:22:06 <dibblego> have a sleep
23:22:15 <joed> Or do I foind those in functional Java?
23:22:29 <dibblego> yes, but that's not a good place to learn
23:23:43 <CakeProphet> :t folds
23:23:44 <lambdabot> Not in scope: `folds'
23:23:45 <CakeProphet> :t foldl
23:23:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:24:46 <psygnisfive> guys
23:24:49 <psygnisfive> im in a good mood
23:24:50 <psygnisfive> i love you all
23:24:51 <psygnisfive> <3
23:25:24 <lorne> :t (<3)
23:25:25 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
23:25:33 <psygnisfive> hahaha
23:25:56 <psygnisfive> randall should've tried Haskell, clearly!
23:34:05 * joed hands dibblego a master troll hat and goes to sleep
23:36:22 <ski_> (dibblego : .. of course, i'll now have to claim that `List' and `Option' also control effects, of sorts)
23:37:04 <joed> Heh
23:37:42 <pumpkin> arrow functions aren't working in my mueval for lambdabot... I can :t them just fine
23:37:53 <pumpkin> but it says no parse if I use *** or &&& or first, second
23:43:16 <CakeProphet> can you extract a tuple element without pattern matching?
23:44:05 <pumpkin> fst, snd for pairs
23:44:07 <pumpkin> others, nope
23:48:44 <ddarius> @src fst
23:48:44 <lambdabot> fst (x,_) =  x
