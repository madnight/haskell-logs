00:01:25 <wagle> ksf, i'm seeing this as the torture test that will get me over my fear of copies over rewrite-in-place..
00:01:44 <dons> would you cast the bits to an int in C?
00:01:52 * dons wonders what this application is .
00:02:06 <ksf> there's going to be no copying at all if you do it right.
00:02:24 <dons> yeah, that's possible
00:02:27 <pumpkin_> except for the ints you read in, I'd imagine?
00:02:30 <dons> if you've time on your hands
00:02:31 <pumpkin_> unless you unsafeCoerce them?
00:02:44 <ksf> not having to copy stuff is the very point of making things immutable.
00:02:44 <wagle> ... so i WANT to go up against laziness
00:03:15 <dons> wagle: ?
00:03:22 <dons> not sure what laziness has to do with this.
00:03:46 <wagle> <ksf> wagle, you definitely want to do a smaller file to test on, though. Laziness is most likely going to hit the fan more than once while you write your code.
00:03:49 <pumpkin_> wow, conal is being prolific tonight!
00:03:58 <dons> no. i doubt it.
00:04:14 <dons> that's the "laziness bogeyman" far more feared than ever seen
00:04:47 <ksf> ...if you keep references to the wrong data, that is. e.g. a reference to the beginning of the 8g while you're traversing it, inhabiting the gc to tidy up after you.
00:04:56 <wagle> yeah i fear it due to the fear everyone has of it
00:05:12 <sjanssen> @quote fdr
00:05:12 <lambdabot> No quotes match.
00:05:22 <ksf> still, i wouldn't want to develop using a 8g file.
00:05:24 <hd_> ski_: :O I thought I tried that already- but yeah, that did the trick. Thanks ;)
00:05:52 <wagle> i figure any leaks i code WILL bite me here, hence I will learn
00:06:16 <dolio> @quote JonHarrop asymptotically
00:06:16 <lambdabot> JonHarrop says: In Haskell, programmers write declaratively and often optimize by randomly fiddling until the current version of GHC happens to reduce it in an asymptotically more efficient way.
00:06:53 <dons> heh
00:07:13 <conal> pumpkin_: :)
00:07:21 <pumpkin_> it's fascinating :P
00:07:22 <dons> ksf: i would. that's how i test bytestring functions.
00:07:26 <dons> actually, i use a 1G file.
00:07:32 <dons> the file's name is '1G'
00:07:43 <dons> i did use a 1T file on a particular machine for a while
00:07:45 <conal> pumpkin_: wait'll you see the next two!
00:07:55 <dons> its good for ironing out performance issues
00:07:59 * wagle once went through 5 different versions of scheme before he found one that could handle /usr/dict/words without running out of memory on the clear-straightforward algorithms
00:08:13 <dons> wagle: oh, dear. really? were you using bytestring IO?/
00:08:23 <dons> that's a toy-sized file for bytstring hacking.
00:08:33 <pumpkin_> matlab for mac os is really ugly :/
00:08:34 <dons> 1M or so. nothing. fits in the cache a few times over.
00:08:34 <olsner> dons: how many versions of *scheme* have you ported bytestrings to? :P
00:08:43 <ksf> if ghc wasn't supposed to be smart, we'd have inline core: the way it is, you gotta write general optimisations if ghc doesn't do what you want..
00:08:50 <wagle> no
00:09:06 <dons> well, now you know.
00:12:28 <wagle> ksf, i'm scared of writing a bunch of haskell code that won't actually run on the 8GB..  so I'm starting there.  easy stuff first, then incrementally getting the harder stuff..  if I can optimize 4 bytes to an int32 in place, then that wall wont stop me if i hit it
00:12:36 <conal> pumpkin_: did you mean my two new blog posts, and if so how did you find them so quickly.  i just published.
00:12:55 <pumpkin_> conal: I'm following your twitter :P
00:13:02 <conal> pumpkin_: oh!!
00:13:03 * pumpkin_ tries to avoid looking like a stalker
00:13:15 * pumpkin_ puts on dark sunglasses and a hat
00:13:20 <wagle> ah, i was going to blame twitter as a joke..
00:13:46 <ksf> wagle, well i'd recommend writing naive code first and then optimising.
00:13:50 <sjanssen> wagle: is your entire file just a bunch of 4 byte ints?
00:14:13 <ksf> you shouldn't ever optimise before the program is finished, just write in a way that makes optimising painless.
00:14:16 <wagle> ksf definitely..  but i want to know the optimization is there when i need it
00:15:01 <wagle> sjanssen, its a file system..  the metadata is mostly u32's and u16's..  in some byte order
00:15:11 <sjanssen> ah, so you need to do some parsing
00:15:14 <ksf> you can abstract away anything in haskell, so you don't have to worry: you can keep your naive top-level code and replace the underlying stuff to optimise it.
00:15:30 <sjanssen> otherwise I'd just recommend mmap()ing the whole thing and turning it into a ForeignPtr Word32
00:15:39 <sjanssen> mmap might still be useful here
00:16:23 <ksf> the fusion version of Data.List is the best example for that.
00:16:51 <ksf> http://www.cse.unsw.edu.au/~dons/streams.html
00:16:51 <sjanssen> fusion doesn't seem to applicable to a filesystem, I imagine wagle will require lots of seeking?
00:16:52 <lambdabot> Title: Data.List.Stream
00:17:09 <ksf> nah, but lazy mmaped bytestrings.
00:17:39 <sjanssen> (there are stream techniques that offer seek, but not any useful implementations that I've seen)
00:18:00 <sjanssen> lazy ByteString will only make the program slower
00:18:05 <sjanssen> (if using mmap)
00:18:06 <pumpkin_> if you only ever need to seek forward, that's fine :P
00:18:18 <ksf> isn't drop nearly O(1) with bytestrings?
00:18:31 <ksf> or, rather, O(n) where n= jumped chunks.
00:18:56 <ksf> should actually be O(1) with mmap.
00:18:56 <dons> sjanssen: we've thought about seek-based fusion. tricky
00:19:01 <wagle> eventually, i will need to seek all over the place, but the first thing to do is to port my gizmo that finds superblocks to haskell
00:19:23 <pumpkin_> is the ByteString implementation similar to what they call Ropes in the c++ stl?
00:19:57 <ksf> pumpkin_, it's a bunch of automata chained up and then fused together.
00:19:58 <wagle> the current thing reads 1024 bytes from every 512 byte alignment
00:19:59 <sjanssen> pumpkin_: strict ByteString has basically no resemblance, lazy ByteString is a little bit similar
00:20:35 <sjanssen> pumpkin_: ropes usually use trees, lazy ByteString uses lazy lists
00:20:41 <ksf> (am i confusing list fusion with bytestrings now? never look at the latter's source...)
00:20:53 <pumpkin_> sjanssen: ah, I see
00:20:54 <sjanssen> ksf: fusion isn't really relative to the question
00:21:00 <sjanssen> s/relative/relevant
00:21:37 <ksf> yeah, i should take a shower and wake up, it's 9:30...
00:22:28 <wagle> cool, i guessed germany
00:22:34 <sjanssen> wagle: map (B.take 1024) . takeWhile (not . B.null) . iterate (B.drop 512)
00:24:03 <wagle> sjanssen, yeah...  the algorithms are straighforward, the datastructure's the killer
00:24:04 <sjanssen> plug this into Data.ByteString.Lazy and you're good to go
00:24:26 <wagle> oki
00:24:37 <sjanssen> wagle: do you need to consider other chunks of the FS, or do you only need 1024 bytes at a time?
00:25:37 <wagle> i need to figure out the blocksize of each filesystem..  superblocks are 1024 bytes no matter what the blocksize is, apparently
00:26:08 <wagle> the disk's sectors are 512 bytes, so blocksize is a multiple of 512
00:29:29 <wagle> i'm playing with the idea of having multiple views of the 8GB..  one of 512B sectors, one of N-sector blocks, blocks parsed into struct fields, etc..
00:30:44 <mmorrow> @yow
00:30:45 <lambdabot> Thousands of days of civilians ... have produced a ... feeling for the
00:30:45 <lambdabot> aesthetic modules --
00:31:09 * mmorrow just got xmonad all nice and setup with gnome
00:32:09 <mmorrow> xmonad + gnome-panel w/ system monitor realtime graph applets + geyes ++
00:32:23 <sjanssen> wagle: I think you'd be well advised to keep the views virtual rather than actual
00:32:47 <sjanssen> even keeping the indices of each 512 byte block in 8 GB is a fair amount of memory
00:35:16 <wagle> yup
00:47:21 <olsner> @go (8 GB / 512B) * 8B
00:47:24 <lambdabot> No Result Found.
00:47:58 <olsner> @go (8 GB / 512 bytes) * 8 bytes
00:48:00 <lambdabot> ((8 GB) / (512 bytes)) * 8 bytes = 128 megabytes
01:02:34 <pumpkin_> @hoogle conjugate
01:02:34 <lambdabot> Data.Complex conjugate :: RealFloat a => Complex a -> Complex a
01:03:49 <pumpkin_> aha, that's why my fft-based acorr was broken :P
01:03:52 <pumpkin_> I was being stupid
01:04:00 <pumpkin_> thank god I haven't disproved the convolution theorem
01:05:52 <pumpkin_> autocorrelation = elems . dftCR . amap (ap (*) conjugate) . dftRC . listArray'
01:05:56 <pumpkin_> so pretty
01:06:19 <pumpkin_> I should probably just write correlation and define autocorrelation in terms of that, actually
01:06:34 <mmorrow> pumpkin_: being that you're doing fft stuff, i found this to be nifty http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=73
01:07:13 <mmorrow> one could do some cool visualization stuff with a sound and/or image file
01:07:18 <pumpkin_> oh neat
01:07:20 <pumpkin_> what's sox?
01:07:28 <pumpkin_> I mean, I can see what it's doing, but where's it from?
01:07:43 <mmorrow> it's kinda like imagemagick's convert, but for audio files
01:08:02 <pumpkin_> ah cool :) isn't there a codec in hackage for reading wav files?
01:08:56 <mmorrow> there may be, i'm not sure. what that sox cmd does is converts the .wav to 4-byte unsigned little-endian samples
01:09:04 <pumpkin_> mmorrow: have you experimented with the importWisdom* functions?
01:09:09 <pumpkin_> ah, I see
01:09:22 <mmorrow> i haven't
01:09:29 <pumpkin_> they fail for me :(
01:09:42 <mmorrow> i'd love to hear about it though once you've figured it out :)
01:09:51 <pumpkin_> I want to see how much faster it'll be with all that hard wisdom I earned
01:10:27 <mmorrow> that too i'd like to hear about. i mean, 14hrs has gotta buy you something..
01:13:58 <pumpkin_> :o
01:14:10 <pumpkin_> it says my wisdom file is damaged! it better not make me do it all again :P
01:15:05 <MyCatVerbs> pumpkin_: fftw blew up in your face?
01:15:39 <pumpkin_> MyCatVerbs: well, I generated a canonical set of wisdom sizes with fftw-wisdom, but fftw refuses to read the output of that
01:15:47 <pumpkin_> otherwise fftw has been working great
01:16:07 <MyCatVerbs> pumpkin_: BTW, how big are your inputs? Once they get really huge, AFAIK having wisdom on hand doesn't help very much (even though you may have spent hours or days generating it).
01:16:26 <pumpkin_> they'll typically be around 2^9 or 10
01:16:37 <MyCatVerbs> pumpkin_: heh.
01:16:42 <pumpkin_> I might go as high as 14, but probably not much further
01:16:58 <pumpkin_> I didn't really need to go up to 2^20 but I left it on all night and figured I might as well
01:17:35 <pumpkin_> MyCatVerbs: is there a reference for the wisdom fileformat anywhere? I'm trying to figure out what's wrong with it
01:17:36 <MyCatVerbs> Hrmn, well.
01:17:49 <MyCatVerbs> No idea, sorry.
01:18:56 <MyCatVerbs> I've tried comparing the timings with FFTW_ESTIMATE and FFTW_MEASURE on arrays about 2^18-2^20 elements long. No statistically significant difference, as far as I could tell. Plus once you get up to 2^18, those wisdom files become a real cow to generate.
01:19:29 <pumpkin_> yeah :/
01:19:52 <pumpkin_> I was thinking of going with FFTW_EXHAUSTIVE on some lower sizes that I use often, to see if I noticed any difference
01:19:55 <pumpkin_> have you tried that?
01:20:06 <MyCatVerbs> I get the impression that once you've up anywhere past, oh, 2^15...ish... it doesn't actually matter, and you may as well just use FFTW_ESTIMATE.
01:20:18 <MyCatVerbs> No, I never had any reason to bother playing with small input sizes much.
01:20:42 <pumpkin_> what kind of data do you typically run through it?
01:20:52 <MyCatVerbs> I mean, I redesigned that program to work with smaller input sizes instead, because a 2^20 element FFT run really sucks for performance's sake =)
01:21:06 <MyCatVerbs> Oh, heheheh. =D
01:21:12 <MyCatVerbs> I was running entire songs through it.
01:21:15 <pumpkin_> :o
01:21:26 <pumpkin_> as an attempt to fingerprint them or something?
01:21:34 <MyCatVerbs> Not even that. =)
01:21:40 <pumpkin_> :o
01:21:54 <MyCatVerbs> Basically I failed utterly to comprehend the convolution theorem =)
01:22:30 <pumpkin_> what were you trying to do? :P
01:22:53 <MyCatVerbs> So I ended up going, from 16 bit signed integers to 32-bit floats in the frequency domain, multiplying piecewise by something ugly in order to amplify some frequencies and attenuate others.
01:23:21 <MyCatVerbs> And then from there back to the spatial domain, and wrote floats out again.
01:23:50 <MyCatVerbs> It was all just for a goddamn software EQ. Funny, really, 'cuz afterwards I found out about all the other much, much faster ways of doing it. xD
01:24:04 <pumpkin_> lol
01:24:06 <MyCatVerbs> Well, two of them, anyway.
01:25:01 <pumpkin_> how did you end up doing it?
01:25:06 <MyCatVerbs> One of which is roughly linear, with enormous constants (but can be done on-demand), the other of which is linear and exceedingly fast and it's the standard one that bloody everybody with two consecutive functioning neurons uses. =)
01:25:36 <pumpkin_> sounds like a tough choice :P
01:26:07 <MyCatVerbs> Neither, of course. =)
01:26:26 <MyCatVerbs> We were just _very_ careful when we gave our demo in the end. ;)
01:26:36 <pumpkin_> lol
01:26:37 <MyCatVerbs> Fortunately it was only crap coursework anyway, so who cares? ^^
01:27:10 <pumpkin_> :)
01:27:16 <pumpkin_> this damn wisdom file is pissing me off
01:27:25 <MyCatVerbs> But yeah, I've tried and variously both failed and succeeded at speeding up some horrible, horrible FFTW-using code. ^^
01:28:34 <MyCatVerbs> Possibly something to do with the fact that I ignored that whole section of the program entirely for a few months, instead just leaving it to one of the slightly sillier people in the group. Oops.
01:30:31 <MyCatVerbs> Oh, the variable names... x_x
01:30:49 * MyCatVerbs noisily suppresses those memories. ;)
01:33:26 <pumpkin_> :)
01:34:34 <pumpkin_> so much ****ing indirection in this wisdom parser, I just want to figure out where it goes wrong :(
01:36:21 <MyCatVerbs> Just throw the damn file away. There is no way on Earth that that is going to take less time than either re-generating the wisdom file or even simply running at FFTW_ESTIMATE.
01:36:49 <pumpkin_> and why the hell does the fftw code have quotes (in latin) from requiems? :P
01:37:03 <pumpkin_> I'd just like to try it out :P don't want to waste all those CPU cycles so I'm wasting brain cycles ;)
01:37:14 <fasta> How can one convert a Haskell file into a .dll file on Windows?
01:37:24 <mlesniak> I have here ghc version 6.8.3 and when I'm in ghci and :m +Data.List I don't have subsequences from Data.List (but other functions like intercalate, ...). Any ideas why?
01:37:57 <pumpkin_> wow, there's a subsequences function
01:38:09 <mlesniak> in theory ;) http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
01:38:12 <lambdabot> Title: Data.List, http://tinyurl.com/yhrw65
01:38:17 <pumpkin_> it's there for me
01:38:26 <int-e> mlesniak: it was recently added. you'll need ghc 6.10.1
01:38:28 <mlesniak> pumpkin_, which ghc version?
01:38:30 <pumpkin_> I haven't seen a function that's inherently exponential
01:38:32 <mlesniak> int-e, ah thanks
01:38:35 <pumpkin_> before this one
01:39:06 <pumpkin_> still handy I guess :)
01:39:34 <mlesniak> yes, it's incredible what's defined in the standard-libraries :)
01:39:52 * pumpkin_ tries subsequences [1..100]
01:40:23 <int-e> > filterM (const [False,True]) [1..4]
01:40:23 <cpfr> hey if what i want is basically a global variable, am I better off using IORef or StateT to thread it
01:40:25 <lambdabot>   [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,...
01:40:54 <pumpkin_> @src filterM
01:40:54 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:40:55 <hackage> Uploaded to hackage: yjtools 0.9.7
01:41:04 <fasta> Permutations was pretty much a FAQ. Good that they just added it.
01:41:06 <Peaker> @type filterM
01:41:07 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:41:21 <ksf> pumpkin_, wisdom, as truth does not redirect anywhere but to itself.
01:41:33 <int-e> (subsequences is more lazy though - it'll generate all finite subsequences of a given infinite list)
01:41:54 <pumpkin_> ksf: tell fftw that
01:42:29 <ksf> maybe i should earn bucks by giving courses on "how to annoy people with koans"
01:42:35 <int-e> > subsequences [1..]
01:42:36 <pumpkin_> :)
01:42:37 <lambdabot>   Not in scope: `subsequences'
01:42:42 <int-e> ah
01:42:45 <int-e> @version
01:42:46 <lambdabot> lambdabot 4.2.2
01:42:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
01:42:48 <pumpkin_> that's pretty neat that subsequences works
01:42:54 <pumpkin_> , subsequences [1..]
01:43:00 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[...
01:43:43 <ksf> @src subsequences
01:43:43 <lambdabot> Source not found. Take a stress pill and think things over.
01:43:57 <ksf> @src [] subsequences
01:43:58 <lambdabot> Source not found. The more you drive -- the dumber you get.
01:44:02 <pumpkin_> , help
01:44:05 <lunabot>  luna: Not in scope: `help'
01:45:02 <ksf> does lunabot know of TH? and does anyone know how to pretty-print a TH function, by hard?
01:45:06 <pumpkin_> doesn't sequences [1..] correspond to the powerset of naturals?
01:45:28 <int-e> pumpkin_: no. it can only produce countably many elements after all
01:45:40 <pumpkin_> yeah, but in theory at least?
01:45:53 <pumpkin_> that's what I was wondering, since it should be uncountable :P
01:46:23 <int-e> pumpkin_: by the definition of 'subsequence', yes, sure.
01:46:25 <ksf> , subsequences [1..5]
01:46:27 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[...
01:46:48 <ksf> , drop 13 $ subsequences [1..]
01:46:50 <lunabot>  [[1,3,4],[2,3,4],[1,2,3,4],[5],[1,5],[2,5],[1,2,5],[3,5],[1,3,5],[2,3,5],...
01:47:03 <int-e> pumpkin_: but that function only produces finite subsequences.
01:47:08 <pumpkin_> yeah
01:47:29 <int-e> pumpkin_: some of the infinite subsequences of [1..] are not even computable :)
01:47:51 <ksf> now i get it.
01:48:33 <ksf> so what's the exact difference between a powerset and subsequences?
01:48:55 <pumpkin_> subsequences is the powerset minus the infinite subsequences maybe? not sure
01:49:37 <ksf> but those infinite ones are computable, even if not in finite time.
01:50:45 <pumpkin_> int-e: I'm trying to think of uncomputable reals... do you mean things like omega?
01:51:07 <pumpkin_> (chaitlin's constant)
01:51:49 <cpfr> ksf, any ideas?
01:52:07 <ksf> http://en.wikipedia.org/wiki/Power_set doesn't mention uncomputability
01:52:08 <lambdabot> Title: Power set - Wikipedia, the free encyclopedia
01:52:19 <int-e> pumpkin_: yes, since you can encode reals as subsequences of [1..]
01:52:37 * pumpkin_ ponders
01:52:57 <pumpkin_> nope, I figured out chaitlin's constant, but there is not enough room in this channel for me to write it out
01:53:28 <ksf> extrapolating from the example given there, i'd say that powerset[1..] is uncountable, but computable in infinite time.
01:54:00 <pumpkin_> ksf: but how do you deal with the fact that you can map between powerset [1..] and reals, and the fact that there exist uncomputable reals?
01:54:27 <ksf> the mapping is uncomputable, and, most of all, not total?
01:54:52 <int-e> pumpkin_: the simplest argument is probably this: the set of all programs (and their - finite - inputs) is countable, so the set of computable subsequences of [1..] is countable as well. The set of all subsequences of [1..] is uncountable. So there must be (uncountably many) uncomputable subsequences.
01:55:10 <pumpkin_> int-e: finite programs? :P
01:55:21 <int-e> pumpkin_: yes. by definition. :P
01:55:27 * pumpkin_ hrrmpfs
01:55:57 <ksf> that's not operational enough for me, or, rather, too operational.
01:56:39 <pumpkin_> I think it makes sense, as the cardinality is strictly greater for a powerset
01:56:45 <pumpkin_> I think it does, anyway
01:56:54 <pumpkin_> wow, a double think
01:56:59 * pumpkin_ is guilty of doublethink :P
01:57:04 * pumpkin_ calls in thoughtpolice
01:58:31 <ksf> there's only doublethink if you cut out faith.
01:59:23 <ksf> my experience also shows that my pc doesn't care about faith, at all. It just refuses to be of my opinion on whether a program is correct or not.
02:00:47 <ksf> "And language confuses as computers refuse to understand how I'm feeeeling today"
02:01:03 <ksf> that's muse, somewhere on showbiz.
02:06:43 <Saiz> ?seen dcoutts
02:06:44 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 1d 9h 50m 3s ago.
02:06:49 <Saiz> ?seen dcoutts_
02:06:49 <lambdabot> dcoutts_ is in #haskell, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts_ last spoke.
02:11:24 <cpfr> ksf, any idea?
02:12:44 <dcoutts> hi Saiz
02:14:15 <cpfr> dcoutts, when it is better to use IORef vs StateT
02:14:32 <ksf> cpfr, about powersets and subsequences? yes, but don't listen to me as i suck at math.
02:14:57 <dcoutts> cpfr: if you can avoid using IO then do so
02:15:09 <cpfr> ksf what about global variables and StateT
02:15:22 <quicksilver> cpfr: only time to use IORef is when you have to thread state through to a callback
02:15:23 <ksf> global state is bad, mkey?
02:15:30 <dcoutts> cpfr: State lets you use one state for the whole computation, Refs let you use several independently
02:15:31 <quicksilver> (and the callback is in IO, obviously)
02:16:11 <cpfr> right in my case i have a data structure that i create based on a configuration file
02:16:13 <ksf> but as you most likely want to have your state non-undeterministic, one state is just fine.
02:16:30 <cpfr> so its in io and then all my function access it or modify it
02:16:51 * ksf screams in horror
02:17:07 <quicksilver> just because you load it in IO (it is a file!) doesn't mean you can only access it from IO
02:17:11 <ksf> mutation is bad, mkey?
02:17:17 <quicksilver> you can load it in IO and then put it in a nice pure place.
02:17:19 <quicksilver> like StateT
02:17:54 <cpfr> ksf, quicksilver, im trying to stay pure
02:18:05 <cpfr> so if i place it in StateT
02:18:22 <dcoutts> cpfr: for most config files you can just pass the info in as a parameter
02:18:36 <dcoutts> no need to use a state monad
02:18:46 <ksf> most importantly, seperate the functions that merely use the data from those that "modify" it.
02:18:51 <cpfr> dcoutts, but that means all my functions have what is essentially this continuation
02:19:16 <dcoutts> cpfr: perhaps so, at most you want a reader monad, not state
02:19:40 <cpfr> any reason state is overkill?
02:19:51 <dcoutts> cpfr: personally I prefer a design where each function takes just the bits of the confi they need rather than passing one huge config record to every function
02:19:52 <ksf> you can do stuff with it you don't want to do.
02:20:06 <dcoutts> cpfr: it's misleading to the person reading your code
02:20:23 <cpfr> fair rnough
02:20:33 <cpfr> i meant what can state do that reader can't
02:20:56 <dcoutts> with state, an action can change the value of the state
02:21:09 <ksf> ...and something that's going to mangle the config is going to return to the IO monad, anyway, as you'd want to write the new stuff to disk, at least potentially.
02:21:31 <dcoutts> with reader it cannot (though you can pass different values in to sub-computations)
02:22:30 <cpfr> dcoutts, good call in my case i think Reader is more in-tune to what I want
02:22:36 * osfameron ordered RWH from Josette on Saturday.  About the same price as on Amazon (with the user group discount) but dunno how the delivery speed (to UK) will compare :-)
02:23:54 <dcoutts> cpfr: though as I say, I'm honestly not sure that writing: "foo :: Config -> Blah" is any worse than "foo :: Reader Blah"
02:24:10 <cpfr> understood
02:24:31 <dcoutts> yes, you pass an extra arg to every function, but the Reader monad method puts every function into a Monad
02:24:36 <dcoutts> not a great deal is gained
02:24:46 <dcoutts> and there is some loss of flexibility imho
02:24:55 <cpfr> true
02:24:59 <dcoutts> monads have their place, but should not be over-used
02:25:40 <cpfr> i dont want to overuse them i just want to use them correctly and appropriately to cut on code use
02:25:54 <cpfr> and be pure
02:26:04 * ksf is going to code monadically in c++ now.
02:26:17 <dcoutts> if I were already working in a custom monad and needed an extra reader-style parameter then I'd not hesitate to stick it into the monad, but I'd generally not make code monadic just for the sake of one reader-style parameter
02:28:01 <sjanssen> or you could just use the ((->) a) Monad
02:29:00 <sjanssen> though you have to put the environment parameter last, which might be inconvenient
02:29:41 <cpfr> so what i have is not so much a config as much as a db
02:29:59 <cpfr> that i have functions which will query, and modify
02:31:08 <cpfr> well let me see if i can get away with just adding another variable first
02:31:20 <sjanssen> "modify" sounds like State
02:32:40 <MyCatVerbs> dcoutts: Reader, no. State, yes. =)
02:32:52 <cpfr> but its a common environment
02:33:39 <MyCatVerbs> cpfr: the trade-off is fairly simple: using Reader or not will involve different quantities of typing things out, depending on how much use you make of the environment. :)
02:34:31 <MyCatVerbs> cpfr: it'll also introduce another thin layer of abstraction, but I wouldn't worry about that in any case since it's not a particularly freaky abstraction to anyone used to Haskell.
02:34:38 <cpfr> MyCatVerbs, with the exception of two functions, all of my functions do something that involves looking into the environment
02:34:48 <Peaker> I'm trying to post code on a comment on conal's blog. Anyone knows which text markup is used there?
02:35:50 <MyCatVerbs> cpfr: sounds like the extra typing involved in using Reader will improve the clarity, then.
02:37:03 <MyCatVerbs> Peaker: I think it's Wordpress 2.5 with a nice custom skin.
02:37:09 <MyCatVerbs> Peaker: if that helps any.
02:37:15 <Peaker> MyCatVerbs: <pre> code </pre> seems to work
02:38:12 <fasta> Are shared libraries working on Windows or not? The documentation is too sparse to make anything out of it: http://paste.debian.net/22614/ contains messages like ExportHaskellToC.o:fake:(.text+0x17): undefined reference to `stg_upd_frame_info'
02:39:06 <MyCatVerbs> Peaker: Most off-the-shelf blogware and forumware will paste its name into the HTML a few times in a pleasantly anvilicious manner. =)
02:40:55 <hackage> Uploaded to hackage: vcard 0.1.2
02:41:28 <ksf> compM<MaybeM>()[ X %plus% Y | X <= just(2), Y <= just(3) ]
02:41:33 <ksf> that's c++ and awesomely cool.
02:41:38 <mlesniak> Anyone has a hint which haskell-module allows me to write this shorter? http://hpaste.org/12563
02:41:46 <quicksilver> isn't sure whether to ++ MyCatVerbs for introducing him to a new word or -- him for the doubtful neologism.
02:42:18 * ksf wants monad comprehensions in haskell
02:42:26 <quicksilver> mlesniak: your "comp" is "comparing snd"
02:42:41 <quicksilver> mlesniak: or "compare `on` snd" as we prefer to spell it in 6.8 and later.
02:43:31 <quicksilver> mlesniak: "sums xs = map (id &&& sum) xs"
02:44:22 <quicksilver> mlesniak: you can now inline that all, if you like. "maximimBy (comparing snd) . map (id &&& sum) . concat . map init . seqs"
02:44:30 <quicksilver> modulo typos.
02:45:40 <mlesniak> quicksilver, Great thanks. It surprising but sometimes quite frustrating that there are so much more elegant ways to solve some problems :)
02:47:54 <Peaker> the (id&&&) and (&&&id) "patterns" are nice :-)
02:48:07 <BeelsebobWork> first and second?
02:48:14 <BeelsebobWork> or rather, second and first
02:48:22 <Peaker> @type (&&&first)
02:48:23 <lambdabot> forall c (a :: * -> * -> *) b c1 d. (Arrow a) => (a b c1 -> c) -> a b c1 -> (c, a (b, d) (c1, d))
02:48:26 * ksf tries to imagine what haskell with a c-like syntax would look like.
02:48:26 <Peaker> @type (&&&id)
02:48:28 <lambdabot> forall b c. (b -> c) -> b -> (c, b)
02:48:38 <Peaker> @type first
02:48:39 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:48:42 <ksf> it'd definitely ease transition, as ppl don't get confused by =.
02:48:49 <ksf> it just wouldn't exist, at all.
02:48:59 <quicksilver> mlesniak: that wasn't really a different way to solve the problem.
02:49:16 <quicksilver> mlesniak: just an observation that some of those idioms you use already have names.
02:49:39 <quicksilver> which makes it slightly shorter, if you reuse the names
02:50:27 <mlesniak> yes, I understand, some of them are hiding quite good ;)
02:51:33 <BeelsebobWork> > first (+1) (2,3)
02:51:33 <BeelsebobWork> > (&&&id) (+1) (2,3)
02:51:35 <lambdabot>       No instance for (Num (t, t1))
02:51:35 <lambdabot>        arising from the literal `1' at <i...
02:51:35 <lambdabot>   (3,3)
02:51:45 <BeelsebobWork> oh fail
02:51:59 * BeelsebobWork is thinking wonkily
02:52:22 <mlesniak> side question: there is no predefined function for seqs [] = [], seqs (x:xs) = [x:xs] ++ seqs xs ?
02:52:37 <mlesniak> Seems so often needed ;)
02:53:03 <quicksilver> > let seqs [] = []; seqs (x:xs) = [x:xs] ++ seqs xs in seqs [1..7]
02:53:05 <lambdabot>   [[1,2,3,4,5,6,7],[2,3,4,5,6,7],[3,4,5,6,7],[4,5,6,7],[5,6,7],[6,7],[7]]
02:53:12 <quicksilver> > tails [1..7]
02:53:14 <lambdabot>   [[1,2,3,4,5,6,7],[2,3,4,5,6,7],[3,4,5,6,7],[4,5,6,7],[5,6,7],[6,7],[7],[]]
02:53:35 <quicksilver> mlesniak: assuming you meant seqs [] = [[]]
02:53:42 <quicksilver> then the answer is "tails" ;)
02:53:55 <Twey> Or init . tails
02:53:56 <quicksilver> otherwise it's "init . tails" or "takeWhile (not.null) . tails"
02:54:01 <mlesniak> quicksilver, yes, argh, thanks, and the funny thing is I looked in Data.List and thought, no, tails, is not useful ;)
02:59:54 <Peaker> BeelsebobWork: (&&&id) and (id&&&) "attach" the element to a result, and first/second just "fmap" on a certain subset of the value, I don't think its quite the same
03:00:03 <BeelsebobWork> Peaker: yeh
03:00:10 <BeelsebobWork> as I said... wonky thinking ensued
03:05:01 <ksf> > tails [1..]
03:05:03 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
03:05:14 <ksf> uncountability ho!
03:05:37 <opqdonut> that's not uncountable
03:05:42 <opqdonut> it's a countable list of countable lists
03:06:11 <ksf> i should really not use mathematic terms, ever.
03:06:12 <Peaker> because aleph_0 ^ 2 = aleph_0 ?
03:06:29 <opqdonut> basically
03:07:18 <quicksilver> you need to use aleph_0 as an exponent, to get bigger
03:07:32 <quicksilver> any other arithmetic operation stays small.
03:08:36 <Peaker> taking a super-set of aleph_1 becomes aleph_2, btw?
03:09:11 <opqdonut> err?
03:09:31 <Ezla> how do you write a class in Haskell?
03:09:38 <quicksilver> power set, I imagine peaker means.
03:09:38 <opqdonut> well yes, aleph_2 is a super-set of aleph_1
03:09:44 <opqdonut> ah, power set
03:09:45 <opqdonut> no
03:09:50 <opqdonut> those are the beth numbers
03:09:56 <mc__> Ezla: do you mean class in an OOP sense?
03:09:58 <BeelsebobWork> Ezla: what kind of class -- do you mean an "object oriented" class?
03:10:02 <Ezla> mc__: Yes
03:10:05 <quicksilver> you don't.
03:10:06 <opqdonut> beth_0 = aleph_0, beth_{i+1} = 2^{beth_i}
03:10:07 <Ezla> Haskell OO
03:10:07 <BeelsebobWork> Ezla: you don't then
03:10:13 <quicksilver> haskell isn't OO.
03:10:14 <Peaker> oops, yeah, power set :-)
03:10:14 <Ezla> why not ?
03:10:23 <BeelsebobWork> because Haskell is not an OO language -- it's a functional one
03:10:29 <Ezla> so?
03:10:32 <opqdonut> Ezla: same as asking "how do you write a monad in c"
03:10:32 <Ezla> who cares
03:10:37 <BeelsebobWork> so classes in that sense don't make sense
03:10:44 <Ezla> C++ has a functional programming library called Phoenix
03:11:02 <BeelsebobWork> yes, and how do you write an Applicative instance in it?
03:11:06 <Ezla> http://spirit.sourceforge.net/dl_docs/phoenix-2/libs/spirit/phoenix/doc/html/index.html#phoenix.preface
03:11:07 <lambdabot> Title: Chapter�1.�Phoenix 2.0, http://tinyurl.com/6crgp
03:11:09 <opqdonut> you can "emulate" classes to some degree
03:11:15 <opqdonut> by using haskell records
03:11:18 <quicksilver> there are various ways of encoding OO in haskell, but since I don't use any of them, I can't tell you how create a class.
03:11:18 <opqdonut> and functions on them
03:11:20 <ksf> http://www.cc.gatech.edu/~yannis/fc++/fcpp-lambda.pdf <--- monadic programming in c++
03:11:22 <Peaker> Ezla: OO is not a goal, its a means to some goals.  Haskell achieves those goals better with different means :-)
03:11:24 <lambdabot> Title: ¢¡¤£¦¥¨§ © § "!# $&%(')'10 23§5416879§¢@8A3£¤B ©8@C4D! £ § 79  ...
03:11:35 <mc__> Ezla: why would you want to declare an OO class in Haskell?
03:11:51 <BeelsebobWork> Ezla: learn to write Haskell, before you try to write in the exact same style as you did before
03:11:52 <Ezla> because Haskell should be flexible enouogh to support multiple paradigms
03:11:53 <opqdonut> but what quicksilver said is the point
03:12:06 <BeelsebobWork> Ezla: no, it shouldn't -- Haskell is specifically designed as a pure functional language
03:12:11 <BeelsebobWork> because impurities cause a lot of problems
03:12:14 <opqdonut> Ezla: well haskell isn't multiparadigm in the same way as, say. python
03:12:24 <opqdonut> haskell is very single-paradigm actually
03:12:25 <BeelsebobWork> you get huge benefit out of *not* doing things like OO programming
03:12:25 <mc__> Ezla: not every language has to multiparadigm :)
03:12:27 <BeelsebobWork> so Haskell doesn't do it
03:12:30 <opqdonut> like, say, smalltalk
03:12:45 <Peaker> I think Haskell is actually more multi-paradigm than Python -- its just that the extra paradigms sit in DSL's, such as ContT IO/etc
03:12:50 <kynky> well you can use a car to flatten rubbish, doesnt mean thats its best use
03:12:56 <opqdonut> Peaker: well yeah in that sense
03:13:06 <opqdonut> Peaker: as I said, "not in the same way"
03:13:11 <Ezla> I think you guys are probably just lying, and it's easy to representt the idea of collections of functions+properties/data which are named after Nouns
03:13:16 <ksf> phoenix doesn't seem to include monads.
03:13:20 <Ezla> but you just want to yank your functional chain
03:13:25 <Ezla> and pretend Haskell can't do it
03:13:30 <BeelsebobWork> Ezla: collections of functions and data are easy to do in Haskell
03:13:34 <BeelsebobWork> but they're not classes
03:13:37 <opqdonut> yeah
03:13:37 <fasta> Uhm, how do I change the PATH variable on Windows? I changed it in Environment Variables, but the cmd.exe program didn't pick up the changes. Don't tell me I need to reboot, please.
03:13:43 <Peaker> Ezla: Haskell functions and actions are first-class values which can be passed around
03:13:45 <Ezla> yeah you guys are just lying
03:13:48 <opqdonut> inheritance and instantiation are pretty complex to code in haskell
03:13:56 <opqdonut> but of course you can do oo-like stuff
03:14:13 <kynky> extend type classes
03:14:13 <osfameron> fasta: it used to be sufficient to open up a new instance of cmd.exe
03:14:17 <Ezla> why would inheritance be complex?
03:14:18 <BeelsebobWork> Ezla: data CollectionOfFunctionAndData = C Int Float (Int -> String) -- oh look, it's a collection of an Int, a Float and a function
03:14:26 <Peaker> Ezla: OO inheritence, which is a pretty horrible thing, though, is not implemented (thankfully :-). You might approximate it in some ugly DSL, but you wouldn't want to, once you discover the truly better alternatives Haskell offers to every use of OO inheritence
03:14:29 <Ezla> you can't extend a set of functions+data?
03:14:34 <Ezla> thats like, uh, really simple?
03:14:38 <kynky> multiple inheritence
03:14:39 <BeelsebobWork> Ezla: try learning the alternative, and maybe you'll see why OO programming is really horribly complex
03:14:42 <BeelsebobWork> and corner-case filled
03:14:43 <osfameron> fasta: the existing one you'd have to set PATH=%PATH%;new_stuff   as it won't pick up the global changes
03:14:44 <Peaker> Ezla: Inheritence is not simple
03:15:04 <kynky> not even perfect in the c++ world
03:15:11 <quicksilver> Ezla: of course it's easy to collect data and functions together
03:15:11 <fasta> osfameron: I opened a new cmd.exe, but C:/bin is not in it.
03:15:12 <opqdonut> Ezla: well you can kludge, you can say "data Foo = Foo Int Float (Int -> String); data Bar = Bar Foo Char"
03:15:20 <opqdonut> but that's not real inheritance
03:15:21 <quicksilver> Ezla: and that's a natural thing to do, in many ways
03:15:31 <quicksilver> Ezla: but we don't generally call that collection an 'object'
03:15:35 * mc__ thinks Ezla  is just a troll
03:15:40 <quicksilver> and we certainly don't often find a use for subclassing it.
03:15:42 * EvilTerran agrees with mc__
03:15:44 <Peaker> Ezla: It mixes up namespaces, it overrides and forwards partial interfaces (buggy!), and it is treated as a special data member. That's NOT simple...
03:15:49 <Ezla> why not subclass?
03:15:54 <osfameron> fasta: odd - it may have changed since I used to do it (WinNT 4.3 really)
03:15:55 <opqdonut> subclassing is hard
03:15:59 <BeelsebobWork> mc__: I don't think so -- I think he's probably one of the army of OO developers that don't realise that OO code is *not* the be-all and end-all of programming
03:16:03 <opqdonut> subtyping is ther term you'd mean in haskell
03:16:09 <Ezla> so
03:16:10 <kynky> i like composistion in oop anyway
03:16:11 <opqdonut> hard in a theoretical sense
03:16:19 <fasta> osfameron: I already got it. ; vs : problem
03:16:22 <BeelsebobWork> Ezla: what's the programming problem that you're trying to solve
03:16:29 <Ezla> If I want to represent a DOOR with a method, open, close, and a boolean state.. in haskell.. how is that NOT an "object"
03:16:30 <BeelsebobWork> you'll get further asking "how would one do this in a Haskell like way"
03:16:33 <mc__> BeelsebobWork: sounds like troll to me :)
03:16:35 <osfameron> fasta: aha!
03:16:36 <ksf> if you love it so much, do monadic inheritance combinators.
03:16:40 <BeelsebobWork> Ezla: no, you wouldn't
03:16:42 <opqdonut> Ezla: it's an "object" sure
03:16:47 <BeelsebobWork> Ezla: you'd represent a door as a Bool
03:16:47 <Peaker> Ezla: You come from an OO background, and you assume that OO is a good idea. When you learn a new language, you think you know better than that language's designers. After years of doing OO, I can understand why that would happen.   But try to put your opinions aside, and learn Haskell as it is
03:16:48 <kynky> oop is good for say in java, ewhen working with 100's of people off the same code base
03:16:51 <opqdonut> Ezla: but it's not object oriented design ;)
03:16:53 <BeelsebobWork> and have functions that can operate on Doors
03:16:58 <opqdonut> since you don't extend or anything
03:17:05 <BeelsebobWork> (and possibly also windows, with polymorphism)
03:17:09 <fasta> osfameron: I will be so happy when I can stop using Windows again :)
03:17:10 <Ezla> so how do you represent a door in haskell?
03:17:15 <osfameron> hehe
03:17:19 <BeelsebobWork> type Door = Bool
03:17:22 <kynky> the functions of a door
03:17:22 <BeelsebobWork> Ezla: like that
03:17:36 <opqdonut> data Door = Door Bool; openDoor (Door False) = Door True; ...
03:17:37 <Peaker> Ezla: It depends how much of the door you want to model. In a ray tracer, it would be quite different than in an alarm system
03:17:39 <Ezla> Fine, bad example.
03:17:58 <mc__> Ezla: why was it a bad example?
03:18:11 <kynky> functional programming is the next evolutionary step
03:18:18 <BeelsebobWork> better yet, data Door = Open | Closed; openDoor Closed = Open
03:18:24 <opqdonut> BeelsebobWork: indeed
03:18:29 <mc__> isn't FP older than OO ?
03:18:32 <ksf> @remember Peaker It depends how much of the door you want to model. In a ray tracer, it would be quite different than in an alarm system
03:18:32 <lambdabot> I will remember.
03:18:33 <opqdonut> mc__: it is
03:18:37 <BeelsebobWork> mc__: sometimes
03:18:41 <BeelsebobWork> most times in fact
03:18:41 <fasta> mc__: yes, it is.
03:18:54 <BeelsebobWork> not always though
03:20:10 <Ezla> In Haskell: I have a type of thing called Animal. I want two animals: Bear, and Duck. I want each animal to have a method called "speak" which causes them to say something. I want each animal to store their sound as a string. And each animal to store an age. I want to be able to access them through a common interface, so I can store a collection of any Animal
03:20:37 <Ezla> polymorphism, inheritance
03:20:47 <Ezla> and an interface
03:20:50 <kynky> lol
03:20:53 <BeelsebobWork> class Animal a where speak :: a -> IO (); age :: a -> Int
03:21:01 <Ezla> All things of type Animal shouold have a showage() func
03:21:25 <kynky> have a type class animal, with common functions
03:21:34 <BeelsebobWork> instance Animal Bear where speak x = playSound "rargh"; age (Bear x) = x
03:21:38 <Ezla> a type class!
03:21:40 <BeelsebobWork> done
03:21:47 <BeelsebobWork> Ezla: yes -- a type class is not an OO class
03:21:52 <BeelsebobWork> they're very different concepts
03:22:10 <ksf> instance Animal RubberDuck where speak _ = putStrLn "squeak"; age (Rubberduck a) = a
03:22:55 <ksf> a type class is basically just an interface.
03:22:59 <Ezla> can things store state in Haskell
03:23:00 <BeelsebobWork> yes
03:23:10 <kynky> use moads for side effects
03:23:12 <BeelsebobWork> Ezla: sure -- data State = S myStateStuff
03:23:12 <Ezla> or is Haskell all "const" ?
03:23:14 <kynky> monads*
03:23:19 <Peaker> Ezla: In Haskell, you can define OO-ish interfaces (typeclasses) and then specify how data-types implement these interfaces _separately_ from these data-types.  So these interfaces can be 3rd party, as well as the types.  That's quite a bit more powerful than the kind of polymorphism OO has
03:23:20 <BeelsebobWork> whether you'd want to do that or not is a different matter
03:23:25 <mc__> BeelsebobWork: they are very different for something that is not used to OO I think
03:23:48 <osfameron> quicksilver: joel pointed out that STM would be a really compelling Monad example for the Perl lot
03:23:50 <kynky> side effects = things that change value
03:23:50 <mc__> to me type classes still look a lot like interfaces (though I understand the difference  now)
03:23:54 <Peaker> Ezla: Haskell encourages a style where everything is "const", but it has an imperative DSL called IO, where you can program with state. It is very discouraged, however
03:24:08 <BeelsebobWork> mc__: yeh -- they're interfaces though, not classes
03:24:17 <quicksilver> osfameron: yeah, good luck with that ;)
03:24:18 <kynky> where do you think java gets its generics from?
03:24:26 <quicksilver> osfameron: you'll find an STM implementation is fairly tricky ;)
03:24:27 <osfameron> quicksilver: how hard could it be?! ;-)
03:24:27 <Ezla> if Haskell is so great at this stuff, then why does it lose so heavily in the benchmarks?
03:24:34 <BeelsebobWork> Ezla: it doesn't
03:24:35 <Ezla> why the speed problem?
03:24:40 <BeelsebobWork> there isn't one
03:24:50 <BeelsebobWork> for a long time Haskell was ahead of C on the great language shootout
03:24:53 <ksf> Ezla, have a look at ruby.
03:24:54 <mc__> Ezla: it is the second fastest language in the language shootout
03:24:58 <BeelsebobWork> it's only because GC tweaking has been banned that it's slower now
03:24:59 <Ezla> Ruby is a piece of crap
03:25:04 <Ezla> slowest VM lang around
03:25:08 <Peaker> Ezla: Haskell code, in terms of conciseness/productivity competes with languages like Python, or Ruby.  But its hundreds of times faster than those languages
03:25:21 <mc__> Ezla: ruby does not have an VM
03:25:25 <Clockwork> Hey, what's the . (dot) operator?
03:25:31 <kynky> it is the fastest by a mile in creating threads,speed is comparable to c++,  and only ocaml is significantly faster in certain stuff, but syyntax def isnt, and isnt as apure as haskell
03:25:32 <BeelsebobWork> Ezla: http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=all <-- 1.3 times slower than C++ is not bad
03:25:32 <Clockwork> or to what function its related to?
03:25:33 <ksf> @src (.)
03:25:33 <lambdabot> (f . g) x = f (g x)
03:25:34 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® Computer Language Benchma ..., http://tinyurl.com/4lrsyg
03:25:37 <quicksilver> Clockwork: function composotion
03:25:38 <Peaker> Ezla: The common implementations, that is (as languages don't have "speeds")
03:25:49 <osfameron> quicksilver: well, obviously it wouldn't be.  But there are some CPAN building blocks already (Data::Transactional etc.) though I dunno how robust those are.
03:25:50 <ksf> :t (.)
03:25:51 <Ezla> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=gpp
03:25:51 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
03:25:52 <lambdabot> Title: Haskell GHC benchmarks | Ubuntu : Intel® Q6600® quad-core Computer Language Be ..., http://tinyurl.com/554v8z
03:25:53 <Clockwork> thx
03:25:53 <Ezla> ^--- why this?
03:25:57 <Ezla> Look how bad that is!
03:26:06 <Peaker> BeelsebobWork: to be fair, the shootout Haskell code is pretty long/ugly (in the shootout, Python seems more elegant than Haskell...)
03:26:10 <quicksilver> osfameron: I guess how robust they are might not matter for a proof of concept
03:26:11 <BeelsebobWork> Ezla: yeh, really bad -- 17 times faster in some cases!
03:26:19 <quicksilver> osfameron: the idea would be to demonstrate the compositionality
03:26:19 <kynky> haskell has other problems than speed though :)
03:26:25 <osfameron> quicksilver: yeah, zigackly.
03:26:28 <quicksilver> osfameron: maybe it doesn't matter if it's perfect.
03:26:45 <quicksilver> osfameron: code which actually works is over-rated anyway. Give me an interesting bug any day.
03:26:46 <Peaker> As far as I've seen in the shootout, it takes unidiomatic code to really compete with C/C++
03:27:04 <osfameron> of course I don't understand how the stm monad works.  Next time I feel like hurting my brane I'll have a look at it
03:27:08 <osfameron> quicksilver:  :-)
03:27:19 <kynky> but haskell ideal for concurrency, from what ive seen
03:27:20 <Ezla> why would *un*idiomatic code be faster in Haskell?
03:27:27 <mc__> most times performance does not matter anyways, so why bother?
03:27:30 <ksf> Ezla, because you didn't yet make ghc even moar smart.
03:27:47 <BeelsebobWork> Ezla: also note -- that shootout bans configuring the GC for each program
03:27:48 <mc__> Ezla: because idiotmatic haskell code is declarative and short, not fast.
03:27:57 <BeelsebobWork> when you configure the GC, Haskell comes out *much* faster on a lot of the benchmarks
03:28:01 <Peaker> Ezla: Haskell lets you go as low-level or high-level as you'd like.  Currently the compiler is not smart enough to make higher-level code (idiomatic) perform as well as lower-level code (unidiomatic)
03:28:13 <BeelsebobWork> e.g. binary trees drops from 45 seconds to 4 seconds
03:28:17 <Peaker> Ezla: at least, in some cases
03:28:30 <Ezla> How does Haskell code even look in ASM?
03:28:33 <Ezla> does it make any sense?
03:28:33 <ksf> why did they ban gc tweaking, anyway?
03:28:40 <Ezla> since C++ maps directly to functions
03:28:45 <ksf> whining c programmers?
03:28:46 <BeelsebobWork> Ezla: no -- but nor does ASM produced by an optimising C compiler
03:29:00 <BeelsebobWork> Ezla: it does if you don't optimise it
03:29:01 <Peaker> Ezla: Haskell is a higher-level language than C++, so it correlates even more weakly to ASM than C++
03:29:03 <opqdonut> Ezla: there's a good example in the wiki, just a sec
03:29:04 <quicksilver> Ezla: C++ maps directly to functions? ASM doesn't have functions?
03:29:21 <quicksilver> C++ can be a remarkably high level language
03:29:24 <ksf> Ezla, ever had a look at the code g++ produces with -O3? there's not much left of your definitions.
03:29:27 <quicksilver> look at the stuff they do with boost
03:29:34 <Peaker> quicksilver: not as high-level as Haskell, still
03:29:38 <quicksilver> it's impossible to map the ASM from that back to the source
03:29:39 <Ezla> ksf: I read -O3 all the time
03:29:40 <quicksilver> (almost)
03:29:47 <osfameron> quicksilver: I think it should be "simple" enough to use Padwalker to see which variables are closed_over, turn them into Data::Transactional hash/array (and add a scalar type too) and then *handwave* and you're done
03:29:55 <BeelsebobWork> Ezla: *cough* bullshit
03:30:00 <Ezla> the functions are still there, it's only inlining you lose em'
03:30:26 <Ezla> Beelsebob: bullshit what?
03:30:32 <opqdonut> Ezla: http://haskell.org/haskellwiki/Performance/GHC <- a good example on how the asm by GHC for a problem is almost the same as that by GCC
03:30:33 <lambdabot> Title: Performance/GHC - HaskellWiki
03:31:03 <kynky> but haskell lets you write code faster too
03:31:19 <opqdonut> no, sorry, that doesn't compare with gcc, i misremembered
03:31:37 <Peaker> BeelsebobWork: reading -O3 code is a skill, not that hard if you practice :-)
03:31:54 <BeelsebobWork> Ezla: http://hpaste.org/12564 <-- what does this do?
03:32:17 <Ezla> Beelsebob, I have a livid hatred for AT&T syntax
03:32:20 <Peaker> BeelsebobWork: do you know IDA ?
03:32:21 <Ezla> 0xe45c20f(%ebx),%eax
03:32:33 <Ezla> that is the stupidest way ever to offset
03:32:50 <Peaker> Ezla: You're bitching about ASM syntax? :-)
03:32:56 <BeelsebobWork> >.<
03:33:27 <ksf> Ezla, where's that in the posted code?
03:33:35 <Peaker> BeelsebobWork: Reading -O3 code with a tool like IDA becomes much easier. Also, with practice, it can be read pretty quickly,t oo
03:33:41 <BeelsebobWork> ksf: 0x91dd68f7
03:34:41 <Ezla> beelsebob there's not much to see here in this func. setup stack frame, load a pointer offset of ebx and some constant into eax, put it itno the stack
03:34:47 <Ezla> call a logger
03:34:52 <Ezla> this isnt even O3 code
03:35:16 <BeelsebobWork> no, it's -Os actually
03:35:42 <eu-prleu-peupeu> how come [5,4..0] works and [5,6..0] doesn't ?
03:35:55 <eu-prleu-peupeu> [5,6..0] just returns an empty list :/
03:36:03 <BeelsebobWork> eu-prleu-peupeu: because 0 < 5
03:36:04 <ksf> eu-prleu-peupeu, because - isn't +
03:36:19 <Ezla> try next time with real O3 code, and don't give me AT&T syntax
03:36:21 <eu-prleu-peupeu> ?
03:36:32 <Ezla> ANYWAYS
03:36:38 <BeelsebobWork> eu-prleu-peupeu: you're asking for the increasing sequence, starting at 5, with a step of 1, until it gets above 0
03:36:41 <BeelsebobWork> 5 is above 0
03:36:47 <BeelsebobWork> so it stops
03:36:47 <ksf> "all integers from 5 to 0 in +1 increments" _is_ the empty list: there are no such beasts.
03:37:02 <eu-prleu-peupeu> i dont understand why ./
03:37:16 <eu-prleu-peupeu> i mean, 5 is the first position on the list, the others should work fine
03:37:23 <eu-prleu-peupeu> 4..0 is the decreasing sequence
03:37:32 <eu-prleu-peupeu> so... why does it relate to the first position on the list ?
03:37:35 <BeelsebobWork> eu-prleu-peupeu: yes -- but [5,6..] is not
03:37:38 <Ezla> why would I want to program in Haskell instead of just LISP?
03:37:47 <Ezla> at least I'd learn more about AST's with lisp
03:37:47 <osfameron> Ezla: it sounds like you don't
03:37:48 <BeelsebobWork> eu-prleu-peupeu: what would you expect the result to look like
03:37:58 <ksf> > 5:[6..0]
03:37:59 <eu-prleu-peupeu> [5,6,5,4,3,2,1,0]
03:37:59 <lambdabot>   [5]
03:38:11 <ksf> > 5:[6,5..0]
03:38:12 <Ezla> I honestly do not understand lisp vs. haskell
03:38:12 <lambdabot>   [5,6,5,4,3,2,1,0]
03:38:14 <BeelsebobWork> Ezla: good reasons would probably take the form of static type checking
03:38:21 <BeelsebobWork> and nicer syntax
03:38:27 <kynky> purity ?
03:38:33 <BeelsebobWork> yes, purity too
03:38:36 <osfameron> Ezla: they feel very different to me.  You can probably learn different and interesting things from eitehr though
03:38:49 <Jarvellis> As in purely funcional?
03:38:57 <eu-prleu-peupeu> i dont understand why this mess on the syntax of the sequence operator :(
03:39:03 <BeelsebobWork> Jarvellis: yes -- referential transparency
03:39:04 <ksf> as in referential transparency
03:39:11 <Ezla> if functional is a great paradigm, why don't I ever see programs written in Haskell?
03:39:11 <eu-prleu-peupeu> this is an haskell "quirck"
03:39:15 <Ezla> I use tons of libraries
03:39:15 <BeelsebobWork> eu-prleu-peupeu: what do you expect it to produce?
03:39:18 <Ezla> they're never functional
03:39:22 <BeelsebobWork> what is your expected behavior?
03:39:33 <eu-prleu-peupeu> BeelsebobWork:  [5,6,5,4,3,2,1,0]
03:39:40 <eu-prleu-peupeu> for [5,6..0]
03:39:43 <BeelsebobWork> eu-prleu-peupeu: but you asked for an increasing sequence
03:39:49 <ksf> Ezla, if peace is such a great thing, why do we have wars?
03:39:53 <BeelsebobWork> 6,5 is not increasing
03:39:53 <opqdonut> Ezla: well we can't _start_ out by being the most widely used paradigm ;)
03:40:02 <Ezla> Ok, serious question
03:40:07 <kynky> Ezla, conceptually hard, on huge projects, oop has had good traction, code reusability, and haskell and monads relatively new, compared to say c
03:40:07 <eu-prleu-peupeu> BeelsebobWork: how come [5,4..0] works then ?
03:40:13 <eu-prleu-peupeu> its not increasing either
03:40:14 <opqdonut> and functional programming tends to be taught less than C and Java
03:40:17 <BeelsebobWork> eu-prleu-peupeu: because you asked for a decreasing sequence
03:40:19 <BeelsebobWork> 4 is less than 5
03:40:25 <BeelsebobWork> so it counts downwards
03:40:28 <BeelsebobWork> until it gets to 0
03:40:29 <opqdonut> and there are more abstractions to be understood when learning haskell
03:40:37 <kynky> functiona programming is a more abstract concept than objects for most ppl
03:40:47 <eu-prleu-peupeu> BeelsebobWork: so the first element on the list also counts as the 'sequence' operator  ?
03:40:49 <Ezla> I have a C++ interface, without templates, and with virtual functions. It's an API.
03:40:55 <hackage> Uploaded to hackage: yi 0.5.2
03:40:55 <hackage> Uploaded to hackage: vcard 0.1.3
03:40:56 <ksf> [5..0] could return [5,4,3,2,1,0], admittedly.
03:41:08 <BeelsebobWork> eu-prleu-peupeu: the first two elements of the list determine the "step"
03:41:13 <Ezla> How do I use the C++ interface and override the vtable, in Haskell without going down to C
03:41:15 <BeelsebobWork> > [5,9..18]
03:41:16 <lambdabot>   [5,9,13,17]
03:41:20 <Jarvellis> Can't you combine OO and functional programming? (sorry if that's a stupid question)
03:41:22 <BeelsebobWork> > [5,6..18]
03:41:24 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18]
03:41:25 <kynky> Ezla, you have to understand the power of functional programming
03:41:34 <BeelsebobWork> > [5,4..0]
03:41:35 <Ezla> kynky: I don't care, listen
03:41:35 <lambdabot>   [5,4,3,2,1,0]
03:41:37 <eu-prleu-peupeu> BeelsebobWork: then why can i do it like [1..10] ?
03:41:47 <opqdonut> Ezla: that would probably be quite complicated
03:41:49 <kynky> well in java, they stealing functional design all the time
03:41:52 <BeelsebobWork> eu-prleu-peupeu: because if there is no second element, the step is assumed to be +1
03:41:56 <quicksilver> Ezla: you'd need to know the ABI details of your C++ compiler.
03:41:58 <BeelsebobWork> > [5..18]
03:42:00 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18]
03:42:04 <eu-prleu-peupeu> ah ok
03:42:11 <quicksilver> Ezla: then you could poke directly at the memory much as you would with any other language.
03:42:13 <eu-prleu-peupeu> nice to know it :)
03:42:16 <eu-prleu-peupeu> it makes sense now
03:42:19 <quicksilver> (and with the same risks of getting it wrong, of course)
03:42:26 <BeelsebobWork> eu-prleu-peupeu: as various people pointed out, you wanted 5:[6,5..0]
03:42:29 <Ezla> I have a project I've set out to finish
03:42:32 <eu-prleu-peupeu> yes
03:42:33 <BeelsebobWork> > 5:[6,5..0]
03:42:34 <Ezla> and I have to work with *THIS* api:
03:42:35 <lambdabot>   [5,6,5,4,3,2,1,0]
03:42:35 <Ezla> http://rafb.net/p/9YrtU852.html
03:42:40 <lambdabot> Title: Nopaste - No description
03:42:44 <Ezla> scroll down to line 208
03:42:46 <arcatan> Jarvellis: objects are quite stateful.. there's OCaml, but i have the impression that objects aren't very popular among OCaml coders
03:42:59 <eu-prleu-peupeu> just go for java
03:43:03 <Ezla> So, OO or not, I still have to use this API.
03:43:04 <eu-prleu-peupeu> it just works :P
03:43:12 <quicksilver> unfortunately there is no direct C++ linkage for haskell.
03:43:19 <eu-prleu-peupeu> it if doesn't, then switch to C#
03:43:23 <quicksilver> probably because it has taken so long for standard C++ ABIs to emerge.
03:43:36 <quicksilver> the simplest way is to write a very thin C wrapper around the bits you need.
03:43:49 <Ezla> but I need to override the vtable
03:43:55 <Ezla> so I'd be making some crappy global
03:43:59 <Ezla> and exporting that in C
03:44:02 <Ezla> it would be horrid
03:44:10 <opqdonut> Ezla: of course switching languages in mid-project is hard
03:44:18 <opqdonut> as is glueing different paradigms together
03:44:19 <Ezla> not mid-project
03:44:23 <Ezla> this is a plugin interface
03:44:31 <Ezla> but if I want to write a plugin, in Haskell.
03:44:54 <ksf> then write a plugin interface for haskell.
03:45:14 <BeelsebobWork> Ezla: all you need to do to go from an OO interface to a procedural one is turn x->jam(y,z); into jam(x,y,z);
03:45:17 <Ezla> is there no "C++ wrapper generator" ?
03:45:26 <kynky> ffi?
03:45:33 <ksf> nope, c++ is a bugger to interface to, from any language.
03:45:34 <BeelsebobWork> yeh -- but not for C++
03:45:35 <BeelsebobWork> only C
03:45:41 <ksf> except c++, of course.
03:45:45 <Peaker> BeelsebobWork: OO is not necessarily message passing even, so in CLOS/etc iirc its already jam(x,y,z)
03:45:47 <Ezla> you guys know D?
03:45:56 <kynky> yeah
03:45:56 <Ezla> it has a standard ABI, and standardized name mangling
03:46:16 <kynky> its a lot newer
03:46:26 <Ezla> D is my primary language
03:46:34 <Peaker> Ezla: what is your purpose in learning (about) Haskell?
03:46:48 <Ezla> cause I am having a panic attack about implementing my idea
03:46:52 <ksf> it also comes with a crappy stdlib and a cool replacement lib that's a bugger to plug in.
03:46:55 <Ezla> it seems so impossible in C++
03:46:55 <quicksilver> A D/haskell binding would be quite interesting.
03:46:57 <Ezla> or D
03:46:59 <Peaker> Ezla: what idea?
03:47:05 <arcatan> i learned Haskell to prove how crappy it is
03:47:17 <quicksilver> i learned Haskell to prove how crappy I was
03:47:20 <kynky> arcatan, learnt enough yet? :)
03:47:29 <Ezla> Peaker, let me show you
03:47:29 <arcatan> nope
03:47:32 <Ezla> one second
03:48:12 <Peaker> When I first learned Haskell, long ago, I looked at the stdlib, and found minor code repetitions, which turned me off from learning Haskell completely, heh
03:48:49 <Peaker> Then later, I found out I was designing a purely functional DSL on top of Python, and had difficulties implementing stuff in it, decided to see what the pure FP folks were doing
03:49:01 <kynky> :)
03:49:06 <Peaker> And found out I was wasting my time reinventing pure FP, poorly :)
03:49:15 <vixey> arcatan, learn about unary (-) and fromIntegral next
03:49:18 <Ezla> Peaker: http://img155.imageshack.us/img155/3031/foo1zm0.png
03:49:24 <Ezla> let me explain
03:49:30 <Ezla> Start in the upper left
03:49:34 <Peaker> Ezla: a music tracker?
03:49:36 <Ezla> yes
03:49:37 <Ezla> see the C4
03:49:50 <Ezla> and see the D F# A
03:50:01 <Ezla> thats an alias of the Box around C E G
03:50:03 <Ezla> *however*
03:50:09 <Ezla> aliases have to be able to overlap
03:50:21 <Ezla> see how: E G D F A has an arrow going down?
03:50:42 <Ezla> the containers don't have to be perfectly nested
03:51:05 <Ezla> by container, I mean gray line
03:51:28 <Ezla> notice how the two gray line containers overlap in a set
03:51:46 <Ezla> The implications get really hairy, when it comes to recursion
03:52:41 <Ezla> R and D are transformations
03:53:04 <Ezla> of the E G D F A set
03:53:15 <Ezla> this stuff is all very easy when you write it in a text editor
03:53:20 <Ezla> but on a 2D grid, with overlaps
03:53:33 <Ezla> its difficult not to have recursive explosions
03:54:14 <Ezla> because: You're trying to edit it, and you drag some box, and now it accidentally selects another container into its set, but it's pasting that container elsewhere, and that in turn expands, which overlaps some other thing, causing it to...
03:54:17 <Ezla> it can go nuts
03:54:28 <Ezla> very volatile
03:54:45 <Ezla> but it's useless unless I allow all of the expressive constructs
03:54:49 <Peaker> Ezla: I didn't really follow all that, I don't know if you should start writing a full-blown project as your first line of code in a language.. You should probably go through a tutorial, first
03:54:49 <kynky> graph theory any help ?
03:54:56 <ksf> so you want to decouple editing and displaying?
03:55:14 <vixey> kynky, if it's easy yeah
03:55:21 <Ezla> let me explain it
03:55:29 <Ezla> There is a grid.
03:55:46 <Ezla> You can grab selections in the shape of a Box, from the grid. And paste them elsewhere.
03:56:00 <Ezla> When you modify the contents inside the selection, the "Elsewhere" changes as well
03:56:27 <Ezla> The alias pastes are transformed by things like reversals, diatonic key  changes, etc
03:56:29 <ksf> ...somewhat like dataflow programming.
03:56:55 <Ezla> but here's the hard part:
03:56:56 <ksf> for which haskell has a cool library.
03:57:47 <Ezla> one alias selection can be created from 2,0 to 10,10, to elsewhere.. while another can be created from 0,0 to 5,5  // they overlap
03:58:10 <Ezla> And when you "paste" the alias to a new location, that new location can participate in creating a *new* alias
03:58:19 <Ezla> ie, the pasted part can be selected
03:58:34 <Peaker> Ezla: when you edit something, it edits all of the positions that are overlapped there?
03:58:39 <Ezla> if you follow that idea through, feedback loops of all kinds are possible
03:59:05 <Peaker> Ezla: if copy is the only kind of propagation, all the feedback loops must terminate
03:59:26 <BeelsebobWork> Peaker: really?
03:59:31 <Ezla> they must -- but depending on your data they can't
03:59:32 <BeelsebobWork> why?
03:59:40 <Peaker> BeelsebobWork: well, for a single particular edit
03:59:45 <Ezla> there's no way to limit it, and I don't even know how to detect it
03:59:56 <Peaker> BeelsebobWork: because if you set something to X, and then set it again to X, its a no-op
04:00:00 <Ezla> I attempted, and my codebase got fucked
04:00:13 <BeelsebobWork> Peaker: I can see it being pretty easy to produce the equivalent of (\x -> x x) (\x -> x x) with copy/paste
04:00:14 <Peaker> BeelsebobWork: by copying, I actually meant setting some particular value
04:00:23 <kynky> prob really mad, but thought you could use graph theory, to represent your problem
04:00:43 <Ezla> I want to make it simple
04:00:51 <Ezla> I thouoght maybe theres some off chance, Haskell can make this simple
04:01:01 <vixey> nope
04:01:03 <Ezla> if I could represent those selections as functions
04:01:05 <vixey> that's the job of the programmer
04:01:24 <Peaker> Ezla: I am willing to bet that the simplest Haskell solution is simpler than the simplest C++ one, by far :-)
04:01:31 <Ezla> why?
04:01:35 <kynky> Peaker, agree2
04:02:01 <Ezla> its really driving me nuts, and now I'm procrastinating on new code,
04:02:01 <Peaker> Ezla: Because that's how software in these 2 languages tends to behave
04:02:03 <kynky> haskell a good protyping language i thought, ideas to paper, fast
04:02:11 <Ezla> and I don't know if Haskell will just send me further into language theoory
04:02:16 <Ezla> rather than *get it done*
04:02:28 <Peaker> Ezla: if you just want a project *done*, you better do it in a language you know
04:02:31 <osfameron> that is a risk I think
04:02:35 <Peaker> Ezla: if you want 10 projects done, you might want to learn a new language
04:02:49 <osfameron> Haskell isn't very susceptible to brute force "just make it work for now" approaches
04:02:56 <Peaker> Ezla: learning a new language will send you on a long tangent before you're as productive as with the languages you know
04:03:10 <kynky> well use your strengths, if learning a new language, outweighs its benefits, for a project with a short time limit, then so be it
04:03:37 <Peaker> Haskell, specifically, is more difficult to learn than some other languages (though its much easier to learn than C++...)
04:03:40 <Ezla> does functional programming in any way map onto what I'm doing in my idea?
04:04:00 <Peaker> Ezla: sure, your "edit" operation is a function of an existing graph to a new graph
04:04:17 <Ezla> yes
04:04:19 <kynky> Peaker, maybe less to learn, but doesnt mean its easier than c++ , depends on your background
04:04:53 <ksf> much less quirks in its semantics and a syntax that doesn't make you throw up.
04:05:08 <Peaker> kynky: C++ is a notoriously difficult/complicated language
04:05:27 <Ezla> not D
04:05:31 <Ezla> D cleans it all up
04:05:53 <Peaker> D is nicer, for sure.  Maybe D is easier to learn than Haskell. Haskell's ease of learning is not one of its strengths, IMO
04:06:27 <kynky> exactly, but once you grasp the power of simplicity its awesome
04:06:30 <vixey> Haskell is really easy to learn
04:06:38 <ksf> fib and fak are trivial in haskell, but grokking monads gets zomgdifficult.
04:06:46 <arcatan> asm is easy to learn
04:06:52 <Peaker> Ezla: Haskell is so different from the mainstream languages, that you gain much less from your existing knowledge when learning it. For example, knowing C++ you can pick up Python more easily than you can pick up Haskell, knowing both C++ and Python
04:06:53 <vixey> arcatan, no it's not :(
04:06:57 <ksf> monads in general, that is, not a particular monad.
04:07:01 <vixey> arcatan, I tried,.. twice..
04:07:22 <kynky> using monads, and understanding monads can be mutually exclusive :)
04:07:24 <Ezla> all I know is C++, D, Javascript, and Lua, and x86 asm
04:07:25 <ksf> asm is easy.
04:07:50 <ksf> lua is quite functional at times.
04:07:58 <Ezla> so is Javascript
04:08:02 <ksf> indeed.
04:08:04 <kynky> most ppl know how to use lists, and as they produce side effects, thought work was done in a monad
04:08:17 <Ezla> http://osteele.com/sources/javascript/functional/
04:08:18 <Ezla> scroll down.
04:08:21 <ksf> but i'd rather smash my head repeatedly into a wall than use it if i have the choice.
04:08:22 <lambdabot> Title: Functional Javascript
04:08:23 <Ezla> (and enable javascript on page)
04:08:51 <Peaker> vixey: Lets divided the language learning into phases: A) learning all the primitives/basic semantics   B) learning the stdlib, idioms, and good practices.  C) mastering the language so you can actually produce quality software with it.    ASM makes A/B real easy, and C insanely difficult.   Haskell makes A,B harder, but C is easier
04:08:52 <kynky> sounds like functional basic, hehe
04:09:16 <Peaker> vixey: C is similar to ASM in that regard
04:09:31 <kynky> just a level of abstraction
04:09:42 <ksf> c is just a high-level assembler.
04:09:52 <Peaker> vixey: understanding the primitives/stdlib is easier in C/ASM than Haskell, simply because they're much less abstract.  Learning how to write quality code in C/ASM is much harder, though
04:09:52 <ksf> and c++ is a metaassembler.
04:10:23 <Peaker> vixey: you tried learning x86 asm twice?
04:10:28 <ksf> ...that incidentally has a bastard pure fp dsl for metaprogramming.
04:10:34 <kynky> as you manage more resources, you nee a higher level of abstraction
04:11:42 <kynky> i remember programming machine code on eproms, asm was a pipedream at the time
04:11:44 <Peaker> Ezla: Supporting a "functional style" and being "purely functional" are very very different.  Also, laziness is a major difference, and you cannot have laziness in Javascript/C++/Python/etc
04:12:05 <Peaker> I programmed .COM files in DOS, using copy con and the ALT-keys! :-)
04:12:14 <ksf> peaker, you _can_ have laziness in c++.
04:12:32 <Peaker> ksf: not the kind of laziness you have in Haskell,  you can have explicit laziness of some things
04:12:41 <ksf> http://www.cc.gatech.edu/~yannis/fc++/fcpp-lambda.pdf
04:12:45 <lambdabot> Title: ¢¡¤£¦¥¨§ © § "!# $&%(')'10 23§5416879§¢@8A3£¤B ©8@C4D! £ § 79  ...
04:13:14 <ksf> but nearly. fc++ provides a laziness monad.
04:13:18 <Peaker> alt-180 == MOV AH,          alt-33 == 0x21        alt-205 == INT    alt-33 == 0x21       IIRC: This was a simple program that just EXIT'd :-)
04:14:44 <Peaker> ksf: yiches
04:15:06 <ksf> that is, you can have explicit laziness of whole expressions, not only single sub-expressions, like e.g. scheme has it, too.
04:15:35 <ksf> in scheme you'd write an eval to get lazy, but monads are a clearly superiour solution to that problem.
04:15:44 <Peaker> ksf: why monads?
04:16:06 <Peaker> ksf: not sure what monads have to do with laziness...
04:16:22 <ksf> you can wrap all that thunking/forcing inside bind.
04:16:25 <BeelsebobWork> does lambdabot end up somehow reading random memory when it can't get a title for a pdf or something?
04:16:37 <osfameron> oooo, lazy monad sounds fun
04:16:45 <flux> ksf, I suppose in scheme you could however very cleanly integrate monads. converting functions into monadified versions when necessary etc.
04:16:46 <ksf> looks like unicode to me.
04:16:57 <ksf> flux, sure.
04:17:16 <Peaker> ksf: what would the monad type be, in Haskell?
04:17:22 <ksf> ...and then write an eval to bind stuff together ;)
04:17:23 <Peaker> ksf: data LazyComputation a = ... ?
04:17:25 <vixey> ksf, so use a monad in scheme then
04:17:41 <osfameron> is there syntactic sugar for monads in scheme?
04:17:51 <osfameron> without sugar, monads are far uglier even than explicit thunking...
04:17:56 <vixey> osfameron, doesn't matter, SYNTAX-RULES lets you make it
04:18:00 <Peaker> osfameron: I believe you wrote "syntactic sugar" and "Scheme" in the same sentence
04:18:23 <osfameron> I wasn't sure that scheme had the same flexibility as lisp for macros?  sounds like it does then :-)
04:18:51 <Aser> hello. can i transform this : [[1],[7],[8]] to this: "[[1],[7],[8]]" - so the lsit to the list as a string in a easy way?
04:18:56 <mc__> osfameron: a lisp dialect without macros would be pretty lame :)
04:19:08 <osfameron> Aser: show
04:19:19 <Aser> head --> wall. thanks :|
04:19:27 <ksf> Peaker, I'd rather make data StrictComputation a = Strict a.
04:19:36 <ksf> which simply calls a deep seq.
04:19:49 <ksf> there's such a beast, but never had a look at it.
04:19:53 <int-e> Peaker: you want mov ah,0x4F.
04:19:58 <osfameron> mc__: true... I've never studied scheme tbh.  I thought I remembered something about its macros being "hygienic" and thinking that might have implications on how much mangling you could do with it
04:19:59 <quicksilver> osfameron: the nast thing about lisp macros and special forms is that they syntactically just look like functions.
04:20:07 <int-e> Peaker: sorry. 4C.
04:20:10 <ksf> anyway, the whole point of monads is specifying how sequences sequence.
04:20:11 <Peaker> int-e: hehe, you're right, it was about 11 years ago ;-)
04:20:20 <Peaker> int-e: Its amazing I remember THAT much from then, I was a kid :-)
04:20:20 <quicksilver> osfameron: I hate that, because if you don't recognise something, you can't tell how it's going to treat its arguments
04:20:41 <kynky> its the place you do your procedural programming, hehe
04:20:58 <int-e> Peaker: of course just 'ret' did the trick for com executables. oh well. old times :)
04:21:07 <Peaker> ksf: I'm wondering how a Scheme/C++ monad for laziness would work, not how a monad for strictness in Haskell would work
04:21:14 <Peaker> int-e: or INT 20h :-)
04:21:26 <Peaker> int-e: which BIOS interrupt was INT 0xE, btw? :-)
04:21:29 <vixey> osfameron, SYNTAX-RULES is much more declarative than DEFMACRO although still 'turing complete' it is less "powerful" in the sense that you can't do certain kinds of name capture so.. maybe
04:21:29 <ksf> http://www.cc.gatech.edu/~yannis/fc++/fcpp-lambda.pdf
04:21:30 <kynky> thouht you could do strictness easily ?
04:21:32 <lambdabot> Title: ¢¡¤£¦¥¨§ © § "!# $&%(')'10 23§5416879§¢@8A3£¤B ©8@C4D! £ § 79  ...
04:21:36 <ksf> read that, or rather the library source.
04:21:49 <Peaker> ksf: its non-searchable :-(
04:22:07 <ksf> section 6 is monads, at the very end of that.
04:22:23 <ksf> ...that is, just before conclusions and references.
04:22:49 <ksf> you need lambdas first, of course.
04:22:50 <int-e> Peaker: some IRQ - Diskette is what Ralf Brown's interrupt list says.
04:23:11 <ksf> and would have to quote all your code in scheme to stop scheme from evaluating it.
04:23:12 <Peaker> ksf: I can't see anything about laziness in there
04:23:21 <besiria> wow, i looked at Qi and it seems a very interesting language, it's like the most functional of Lisps
04:23:33 <ksf> it start three pages from the end.
04:23:45 <ksf> *three pages before the end
04:23:48 <Peaker> ksf: well, explicit laziness, hiding everything behind lambda's, or even a Thunk mutable object is possible in pretty much every imperative language
04:24:23 <RayNbow> Peaker: why copy con? Did your copy of DOS didn't ship with debug? :p
04:24:35 <Peaker> RayNbow: I don't remember...
04:24:36 <ksf> well the knack is to have a whole chain of lazy expressions, not just a thing that gets evaluated strictly if you force it.
04:24:45 <ksf> that'd be more in the sense of a continuation.
04:24:49 <Peaker> RayNbow: I self-learned all of it, without books, too
04:24:58 * RayNbow blinks
04:25:07 <Peaker> RayNbow: I had MS CV to R.E the asm behavior and opcode table
04:25:18 <Peaker> int-e: oh, right, 0x08..0x0F were the IRQ's. I forget what 0..7 were
04:25:39 <ksf> linux makes that easy, everything is int0x80.
04:26:03 <int-e> Peaker: cpu generated interrupts.
04:26:08 <Peaker> int-e: IBM put the IRQ's and BIOS in 0x08..0x1F,  despite Intel placing a big "WARNING: Interrupts 0..0x1F are reserved for future use". Then they were screwed when Intel put the protected mode faults in that range
04:26:33 <Peaker> ksf: I think there's a special SYSCALL op-code these days, that's a bit faster than the "int0x80" call
04:26:33 <ksf> rax has the function number, the rest of the register the args or, if that isn't enough, rbx is a pointer to a struct
04:27:00 <vixey> besiria, I don't see much there that sooks interesting
04:27:02 <int-e> Peaker: oh well. http://www.ctyme.com/intr/int.htm :)
04:27:04 <lambdabot> Title: Interrupt Jump Table
04:27:09 <vixey> besiria, ..maybe I missed something?
04:27:51 <ksf> http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html
04:27:55 <lambdabot> Title: System Call Table
04:28:04 <vixey> besiria, maybe the long tradition of reimplementing lisp and claiming you did something original left me disillusioned
04:28:38 <kynky> lol
04:29:09 <besiria> vixey: i thought that would be interesting because of all fp-advocates here
04:29:10 <kynky> isnt that the samefor every new language ?
04:29:40 <solrize_> qi has a turing-complete type system  based on sequent calculus
04:29:51 <solrize_> i've never seen anything like that anywhere else
04:29:52 <ksf> the numbering looks almost like they were numbered by implementation date.
04:29:59 <vixey> besiria, but any specific things which are actually cool about it?
04:30:16 <besiria> vixey: nah nothing cool just interesting
04:30:22 <kynky> new words in vocabulary
04:30:29 * vixey remains not interested then :/
04:30:35 <besiria> :)
04:34:55 <eu-prleu-peupe1> where can i learn fast about functors ?
04:35:16 <dibblego> here!
04:35:17 <mc__> does someone know where to download the haskell tutor mentioned in this pdf? http://tur-www1.massey.ac.nz/~iimspg/2004conference/proceedings/10.pdf I've tried googling for it but i could not find anything
04:35:30 <lambdabot> Title: Haskell-Tutor: An Intelligent Tutoring System for Haskell Programming language, http://tinyurl.com/66agr6
04:35:38 <Aser> hey, i have my main-funktion which should call something like main = funk1; funk2 which, of course, doesn't work. how could i implement something similar to this?
04:35:55 <vixey> Aser, funk1 >> funk2
04:36:01 <Peaker> eu-prleu-peupe1: a functor is a type-class of (*->*) kinded types, that allows using an (a->b) function to convert a value of type (f a) to (f b)..
04:36:08 <vixey> Aser, and  do funk1; funk2  is shorthand for >>
04:37:02 <eu-prleu-peupe1> Peaker thanks you, can i see some examples ?
04:37:05 <eu-prleu-peupe1> like fold ?
04:37:15 <Peaker> eu-prleu-peupe1: instance Functor [] where fmap = map
04:37:47 <Peaker> eu-prleu-peupe1: instance Functor Maybe where fmap f Nothing = Nothing ; fmap f (Just x) = Just (f x)
04:38:16 <Peaker> eu-prleu-peupe1: you can see fmap as something that lets you apply a function "inside" some data structure.  Its also called "lifting" the function into the type
04:38:35 <eu-prleu-peupe1> oh
04:38:43 <eu-prleu-peupe1> mapM is a functor ?
04:38:53 <Peaker> eu-prleu-peupe1: Only types can be Functors
04:38:58 <Peaker> eu-prleu-peupe1: as Functor is a type-class
04:39:04 <eu-prleu-peupe1> ah yes okok
04:39:16 <Peaker> @type mapM
04:39:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:39:22 <Peaker> @type fmap
04:39:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:40:02 <Peaker> eu-prleu-peupe1: note that in fmap, the partial application of first arg result must be (f a -> f b)
04:40:06 <Ezla> ksf: which library in haskell for dataflow?
04:40:19 <Peaker> eu-prleu-peupe1: and in mapM, it is [a] -> m [b]    which doesn't match, so mapM can't be fmap of any type
04:40:20 <Ezla> And what's the replacement for Boost graph library?
04:40:28 <eu-prleu-peupe1> i've been programming haskell for two months now... and it seems that i know less as time goes by :(
04:40:48 <Peaker> eu-prleu-peupe1: what documentation have you been reading?
04:40:56 <hackage> Uploaded to hackage: PlslTools 0.0.1
04:41:11 <eu-prleu-peupe1> Peaker: some papers, filled with cryptic mathematic descriptions :/
04:41:16 <mc__> eu-prleu-peupe1: you just feel like that because now you know how much you do not know. so you know more
04:41:45 <kynky> eu-prleu-peupe1, yaht, real world haskell, haskell iki book, good reading, the 26 free hour and half haskell uni lectures are good too
04:41:53 <eu-prleu-peupe1> i feel that there are brave new concepts like arrows, comonads, functors, and functional reactive programming, that i have a hard time understanding them :/
04:41:56 <Ezla> what dataflow library for haskell ?
04:42:06 <Peaker> eu-prleu-peupe1: Functors are really easy.  Generally you have values that contain other values, Functor's fmap allows you to apply functions to those inner values, that's (almost) all there is to it
04:42:52 <Peaker> eu-prleu-peupe1: while a function like map allows you to do this just for list's inner values, a Functor allows you to do it to the inner value of almost any type that has one
04:43:07 <eu-prleu-peupe1> yes hmm
04:43:09 <Peaker> brb
04:43:41 <eu-prleu-peupe1> kynky: university lectures ?
04:45:30 <kynky> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung , Lectures (in English) by Jürgen Giesl. About 30 hours in total, and great for learning Haskell. The lectures are 2005-SS-FP.V01 through 2005-SS-FP.V26. Videos 2005-SS-FP.U01 through 2005-SS-FP.U11 are exercise answer sessions, so you probably don't want those.
04:45:36 <Ezla> does haskell have a "Stack"
04:45:40 <lambdabot> Title: S-INF.de - Vorlesungsvideos, http://tinyurl.com/y4m979
04:45:43 <Ezla> is everything on the heap?
04:45:55 <dibblego> Ezla, []
04:46:01 <Ezla> no, I mean
04:46:11 <Ezla> What's the equivalent of allocating objects on the stack
04:46:23 <eu-prleu-peupe1> so as long as i define the fmap function for a given type, i have defined a "functor" that can operate on that type inned values, is that it ?
04:46:24 <Ezla> (which, in C++, is like 100 times faster)
04:46:35 <dibblego> eu-prleu-peupe1, no, 2 laws must satisfy
04:46:40 <ksf> waaagh!
04:46:46 <mc__> Ezla: I think GHC decides what to put where
04:46:56 <ksf> my arcanoid assembly code doesn't compile any more.
04:47:10 <ksf> and the collision detection code is missing.
04:47:11 <mc__> in a HLL you do not care about such details normally
04:47:12 <Ezla> so Haskell can't program in a way which has to do with computers
04:47:33 <dibblego> Ezla, Haskell is Turing-complete so yes
04:47:41 <kynky> ezla, totally the opposite i thought
04:47:48 <Ezla> <Ezla> ksf: which library in haskell for dataflow?
04:47:50 <vegai> if you write a non-recursive function and call with [1..], stack becomes visible, I believe
04:47:58 <ksf> reactive.
04:48:01 <Ezla> becomes visible how?
04:48:05 <SamB_XP> Ezla: it would be fairly idiotic to put stuff on the stack ...
04:48:07 <Ezla> ksf: what about a Graph library for haskell?
04:48:08 <ksf> if in doubt, ask conal, he wrote that stuff.
04:48:11 <vegai> Ezla: by a stacok overflow :)
04:48:11 <ksf> fgl.
04:48:12 <Ezla> SamB_XP: how do you mean?
04:48:21 <ksf> read the paper, it explains it in great detail.
04:48:44 <ksf> the reactive paper doesn't help much using reactive, it's bleeding technical.
04:48:49 <SamB_XP> Ezla: well, you'd probably end up having expressions that wanted to refer to it after the stack frame was gone ...
04:48:54 <vegai> Data.Graph comes with ghc
04:49:05 <vegai> or did you mean something else?
04:49:10 <ksf> reading papers is a thing you'll get accustomed to learning haskell ;)
04:49:21 <kynky> ghci too
04:49:27 <Ezla> SamB_XP: that's irrelevant
04:49:33 <Ezla> programmer != baby
04:49:50 <Ezla> programming requires some degree of care, no
04:49:56 <kynky> :) /=
04:50:14 <ksf> anyone feeling like writing non-descrete circle/vertex collision to repair my arcanoid?
04:50:24 <ksf> x87 assembly, linux.
04:50:31 <opqdonut> wow, x87
04:50:44 <Ezla> x831337
04:50:57 <SamB_XP> Ezla: you never heard of x87 ???
04:51:04 <SamB_XP> and you want to allocate on the stack ?
04:51:09 <SamB_XP> what the heck?
04:51:17 <Ezla> actually
04:51:20 <Ezla> x87 is a duck
04:52:09 <Ezla>   ^--- "quack"
04:52:15 <ksf> there's a lot of x86 code too, of course.
04:53:03 <ksf> the only reason the whole thing links against the clib is the fact that it's needed by the xlib and i could'nt be arsed to implement the x protocol in assembly.
04:53:29 <Ezla> does haskell have an inline assembler
04:53:35 <kynky> xcb haskell implementation be etter ?
04:53:38 <kynky> better
04:54:26 <ksf> ezla, no. not even inline core. but then you can specify custom rewrite rules.
04:54:38 <ksf> and even optimizer passes, if it's out by now.
04:54:56 <Ezla> "inline core" ?
04:55:06 <Ezla> if what's out by now?
04:55:25 <ksf> ghc translates haskell to a thingie called core before optimising and translating it to assembly.
04:55:43 <ksf> there was an article about it in the last community report.
04:55:52 <Ezla> is GHC writ in Haskell?
04:56:13 <ksf> sure
04:56:20 <quicksilver> Ezla: "mostly"
04:56:21 <Ezla> "sure" ?
04:56:23 <Ezla> oh
04:56:36 <quicksilver> there are some parts of the RTS written in C-- and C
04:56:53 <Ezla> k
04:56:59 <quicksilver> it's self-hosting
04:57:03 <ksf> ...but then you've also got asm in c's rts.
04:57:11 <Ezla> RTS ?
04:57:22 <quicksilver> run time system
04:57:25 <Ezla> k
04:57:27 <ksf> stuff like leading you from start: to main()
04:57:31 <quicksilver> libcrt.a, for C on a libc system
04:57:54 <SamB_XP> crt0.o and so on
04:59:14 <ksf> nope it was the monad reader.
04:59:17 <vixey> hehe
04:59:21 <ksf> http://www.haskell.org/sitewiki/images/f/f0/TMR-Issue12.pdf
04:59:22 <lambdabot> Title: The Monad.Reader Issue 12: Summer of Code Special
04:59:28 <ksf> "compiler development made easy"
04:59:29 <vixey> const = λ y.λ z.y, get = 出(λ k.λ z.kzz), put = λ z .出(λ k.λ z.kz z ).
04:59:52 <vixey> @src get
04:59:53 <lambdabot> Source not found. Wrong!  You cheating scum!
05:00:24 <eu-prleu-peupe1> Ezla: the stack concept is a disaster of computer science engineering
05:00:49 <SamB_XP> eu-prleu-peupe1: is it ?
05:00:50 <ksf> I like how chicken uses it.
05:00:58 <SamB_XP> I thought it was manual allocation that was
05:01:18 <eu-prleu-peupe1> i much prefer the "environments" concept from scheme
05:01:21 <ksf> just fill it up, then gc the whole thing and longjmp to the beginning, rinse + repeat.
05:01:52 <eu-prleu-peupe1> closures, continuations, and all the other bla bla bla, fits really nice in them
05:02:11 <ksf> gc'in basically meaning treating the stack as nursery and coping everything that's reachable unto the heap.
05:03:20 <ksf> ...which of course only works with programs in cps.
05:03:42 <vixey> ANF works too
05:04:09 <vixey> wwait
05:04:53 <ksf> anf returns, doesn't it?
05:05:27 <vixey> might have misunderstood, I haven't read that TMR thing
05:07:45 <ksf> skimming over http://citeseer.ist.psu.edu/flanagan-essence.html , it seems that anf returns.
05:07:47 <lambdabot> Title: The Essence of Compiling with Continuations - Flanagan, Sabry, Duba, Felleisen ( ...
05:11:23 <vixey> ksf, what does that mean, to return?
05:12:41 <ksf> to have a callee return to the caller.
05:12:56 <ksf> in cps everything's a tail call, so you don't have to.
05:13:09 <zipMe> Hello, how would you go about querying a MySQL database from Haskell  ?
05:13:17 <vixey> ksf, I think ANF has that property too
05:13:50 * vixey checking
05:14:43 <ksf> looks like it _can_ have that property, but doesn't need to.
05:14:55 <lilac> Ezla: haskell (as implemented by GHC) has a stack, but it's basically only used for register stashing and return addresses; objects go on a garbage-collected heap (where allocation is very fast)
05:15:11 <Ezla> lol "fast"
05:15:14 <Ezla> right...
05:15:17 <Ezla> sorry
05:15:17 <lilac> also, the stack doesn't mirror the call stack, it mirrors the evaluation stack
05:15:40 <mc__> sometimes I wish IRC had votekick
05:15:42 <lilac> Ezla: actually, it is. allocation is basically just incrementing a pointer, just like allocating off the stack
05:16:08 <lilac> Ezla: see Hans Boehm's paper on relative speeds of allocation with a good GC heap versus stack allocation in C++
05:16:09 <Peaker> what are the functor laws?  fmap id = id    and   ?
05:16:15 <Ezla> but a stack based heap allocator only works when you have a perfectly paired/symmetrical sequence of allocations/deallocations
05:16:19 <Peaker> eu-prleu-peupe1: I am guessing they are: fmap id = id, and  fmap f . fmap g = fmap (f . g)  -- but I am not sure :-)
05:16:31 <SamB_XP> Ezla: ... deallocations ?
05:16:33 <SamB_XP> what's that ?
05:16:46 <Ezla> SamB_XP:  add esp, N
05:16:51 <Ezla> in the case of a real stack
05:17:04 <Peaker> Ezla: Why did you say lol "fast"?  Do you know how fast the allocations are?
05:17:25 <Ezla> cause, use of the heap is the bubonic plague of fast code
05:17:31 <lilac> Ezla: if you're interested, i suggest you benchmark it
05:17:34 <Ezla> even *without* a gc
05:17:43 <ksf> Ezla, http://research.microsoft.com/~simonpj/Papers/papers.html#gc
05:17:43 <lilac> Ezla: GC makes it /faster/ not slower
05:17:43 <lambdabot> Title: Simon Peyton Jones: papers
05:17:55 <Peaker> Ezla: Generational GC allocations are said to be "on the heap", but they don't allocate with "malloc"
05:17:56 <Ezla> lilac: we've all heard that theory
05:18:00 <lilac> Ezla: (at least in some cases)
05:18:13 <Ezla> doesn't work on my codebases, though
05:18:17 <Peaker> Ezla: You speak of ignorance: a heap allocator in generational GC just moves a pointer forward, much like SUB ESP
05:18:25 <vegai> Ezla: http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=gpp&lang2=ghc  -- it's not that much worse, is it?
05:18:27 <Ezla> Java and D certainly aren't as fast as C++ does my stuff
05:18:28 <lambdabot> Title: C++ GNU g++ benchmarks | Ubuntu : Intel® Q6600® Computer Language Benchmarks G ..., http://tinyurl.com/5p6xy2
05:18:30 <Peaker> Ezla: So allocating is very fast indeed
05:18:34 <SamB_XP> Ezla: well, you have to admit it means you don't have to call free() ...
05:19:10 <Peaker> Ezla: try to humble down a bit. You may be the most knowledgeable guy at your work place or amongst friends, but you're not that guy here :-)
05:19:37 <Peaker> (note I am not implying I am, not at all, #haskell is full of insanely knowledgeable gurus)
05:19:39 <Ezla> having an idea that the heap is slow doesn't mean I'm somehow "most knowledgable guy"
05:19:49 <vegai> indeed it does not :)
05:19:52 <Ezla> it means I have common sense
05:20:01 <Ezla> and that you guys swallowed the Kool-Aid
05:20:04 <vixey> not sure
05:20:04 <Peaker> Ezla: Einstein said something nice about "common sense"
05:20:08 <lilac> Ezla: it means you have experience of the C heap
05:20:22 <lilac> Ezla: it does not mean you have any experience of the haskell GC
05:20:30 <Peaker> Ezla: Well, your general attitude suggests that you think you "know better".  You should let people explain what they mean by "very fast" before ridiculing it
05:20:32 <Ezla> ok, so tell me
05:20:33 <ksf> it means that you call malloc even for one-byte objects.
05:20:44 <Ezla> how does Haskell keep Alloc/UnAlloc symmetrical?
05:20:46 <ksf> which ghc _definitely_ doesn't do.
05:20:52 <ksf> it doesn't.
05:20:55 <vixey> Ezla, it doesn't GC never works that way
05:21:01 <Ezla> then why does a stack based GC work?
05:21:13 <lilac> Ezla: "stack based GC"?
05:21:14 <Ezla> <Peaker> Ezla: You speak of ignorance: a heap allocator in generational GC just moves a pointer forward, much like SUB ESP
05:21:23 <Peaker> Ezla: that's not "stack-based"
05:21:25 <lilac> Ezla: that's for allocation, deallocation is more complex
05:21:31 <Peaker> Ezla: its like SUB ESP, performance-wise of allocation
05:21:31 <ksf> only the nursery is a stack, the rest is "traditional"
05:21:46 <Ezla> how does dealloc happen
05:21:47 <Peaker> Ezla: it does not free by moving the pointer back
05:21:50 <Ezla> that's what I'm asking
05:21:50 <vixey> Ezla, read Jonas and Lins survey on GCs
05:22:06 <Ezla> Peaker: how does it free?
05:22:14 <eu-prleu-peupe1> Ezla: gc is not only about reducing allocs/frees, and keeping them simmetricall
05:22:32 <Peaker> Ezla: at GC time, reachable memory is copied to another location, and the pointers are fixed to point at that new location.  Unreachable memory is not copied, and the source from which it was copied becomes free for new allocations
05:22:36 <ksf> dealloc doesn't happen, but from time to time the gc collects all reachable objects on the allocation stack, moves them to another area and resets the allocation stack pointer.
05:22:37 <eu-prleu-peupe1> Ezla: just try to keep your heap unfragmented with a large c++ program... its a real pain
05:22:43 <ksf> that's called a minor run.
05:22:49 <vixey> Ezla, http://www.cs.kent.ac.uk/people/staff/rej/gc.html
05:22:50 <lambdabot> Title: Richard Jones' Garbage Collection Page
05:22:53 <Ezla> does Haskell's GC have to pause /all/ threads when a collection takes place?
05:22:57 <lilac> Ezla: yes
05:23:00 <Ezla> That's why I hate gc's.
05:23:01 <lilac> GHC's GC does
05:23:03 <Ezla> That's the problem.
05:23:07 <lilac> but it's not an inherent problem
05:23:11 <Ezla> Yes it is!
05:23:13 <ksf> currently, yes.
05:23:13 <Ezla> oh
05:23:17 <vixey> Ezla, There's papers on concurrent GCs but don't read them first
05:23:20 <Ezla> you mean "inherent" in GC period
05:23:29 <SamB_XP> it isn't inherent
05:23:30 <lilac> Ezla: it's not an inherent problem for a haskell GC
05:23:36 <Peaker> Ezla: again you speak of ignorance.  Try to humble down a bit
05:23:41 <eu-prleu-peupe1> Ezla: in c++ you relly on your new/delete to alloc/free your memory ?
05:23:46 <ksf> we got parallel gc by now?
05:23:48 <vegai> hmm, doesn't ghc-6.10 already have a parallel gc?
05:23:57 <lilac> vegai: parallel with itself only
05:24:01 <Ezla> can you guys waste less time saying I'm ignorant, and more time talking in code
05:24:05 <Ezla> I don't listen to meta-arguments
05:24:09 <ksf> or is it just that it's using more than one core, but still stops all user threads?
05:24:11 <SamB_XP> it's just that it's easier to do a stop-the-world GC than anything else
05:24:13 <eu-prleu-peupe1> Ezla: what happens when you mistakenly used a delete to free an allocced new[] ?
05:24:13 <Ezla> arguments about arguments; I simply do not read them.
05:24:15 <Peaker> Ezla: You keep saying wrong things with confidence, it does not contribute
05:24:22 <Ezla> "ignorance" is a meta-argument
05:24:25 <vixey> Peaker, Ezla has a point
05:24:47 <SamB_XP> Ezla: meta-meta-argument!
05:24:50 <Peaker> vixey: I did not say he had no point at all, I said he said wrong things with confidence
05:24:52 <vixey> .. and should read the paper I linked!
05:24:53 <SamB_XP> that's what you just made, I mean
05:24:56 <int-e> vegai: it's parrallel, meaning it has several threads doing the GC.
05:25:05 <Ezla> yes, meta arguments do nothing but spawn meta-meta arguments. It's a downward spiral
05:25:11 <int-e> vegai: but the mutators (workers) are still stopped while gc happens
05:25:12 <Ezla> I won't respond to another one I promise ;)
05:25:21 <eu-prleu-peupe1> Ezla: what happens when you want to alloc your whole program in the starting loading time ? how does c++ new/delete handle that ? :P
05:25:21 <lilac> Peaker: whether Ezla has said right things or wrong things doesn't affect the correctness of his/her current point
05:25:27 <Peaker> vixey: Being wrong is fine. I'm wrong a lot on #haskell :-)  But people who find they are wrong should tone down their confidence, as its shown to be misplaced
05:25:28 <vixey> Ezla, has  to be done sometimes
05:25:47 <vixey> Peaker, I think they should mostly read the paper I linked..
05:25:48 <eu-prleu-peupe1> Ezla: also, what use do you have for auto_ptr ? ... because it REALLYYY sucks :/
05:25:57 <Ezla> eu-prleu-peupe1: "alloc whole program" how do you mean?
05:26:00 <SamB_XP> Ezla: it's okay if you eventually come back up the hierarchy ;-P
05:26:00 <Ezla> that's a programmatic choice
05:26:05 <lilac> Ezla: the problem with auto_ptr is the copying semantics IMO
05:26:14 <lilac> eu-prleu-peupe1: ^^ sorry, that was for you
05:26:15 <Ezla> eu-prleu: auto_ptr is deprecated
05:26:15 <vegai> lilac, int-e: Ah, ok. Is somebody working on a GC that doesn't stop the world?
05:26:21 <Peaker> Ezla: what replaces auto_ptr?
05:26:22 <Ezla> We don't use that anymore.
05:26:22 <vixey> Peaker, try to shift what people know up to what they want to know instead of shifting the confidence to match what they know
05:26:26 <lilac> vegai: i've heard rumours, but i'm not the one to ask :)
05:26:38 <lilac> Ezla: surely you don't use unique_ptr yet?
05:26:40 <int-e> vegai: I don't know
05:26:52 <ksf> i'd guess the new codegen has priority right now.
05:26:54 <vegai> Erlang has one, but it might be a much easier thing to implement in there
05:26:58 <eu-prleu-peupe1> Ezla: you know that malloc gives an enormous performance hit, so it is preferable to allocate the max ammount of memory required by and operation at its begining...
05:27:05 <Peaker> vixey: I think its better to do both
05:27:07 <SamB_XP> vegai: almost certainly
05:27:08 <eu-prleu-peupe1> how do you manage that with new/delete ? (tip: you don't)
05:27:11 <SamB_XP> considering it's process model
05:27:22 <Ezla> we use unique_ptr scoped_ptr shared_ptr weak_ptr intrusive_ptr
05:27:23 <lilac> Peaker: it's easier to change peoples' knowledge than their attitudes :-)
05:27:25 <SamB_XP> though I could be totally wrong
05:27:34 <SamB_XP> about how they do it, I mean
05:27:36 <lilac> Ezla: what compiler do you use?
05:27:41 <eu-prleu-peupe1> what about new[] keeping an extra integer on the stack to trace the length of the block ?
05:27:41 <Ezla> GCC
05:27:50 <fanf> hello
05:27:52 <eu-prleu-peupe1> new[] is really great for dangerous small leaks ;)
05:27:54 <Surma> hey guys, is there a function in Haskell like Unix' ``uniq''? To filter out all duplicate symbols in a list? Or do I have to write that myself?
05:28:02 <lilac> Ezla: i thought it didn't have rvalue references in a stable release yet?
05:28:07 <eu-prleu-peupe1> thats c++ memory management 101 for you
05:28:08 <SamB_XP> Surma: nub, yes
05:28:11 <Ezla> lilac: We do.
05:28:15 <lilac> Ezla: neat :)
05:28:16 <Ezla> lilac: 4.4
05:28:24 <vixey> Peaker, I've run out of a polite way to say, Please don't tell people they are ignorant - that's comletely fucking useless for everyone
05:28:25 <Ezla> it's not "stable"
05:28:27 <Ezla> BUT
05:28:33 <vegai> by the way, we should perhaps realize what it does to a person's mind when it gets bombarded by several rebuttals at once
05:28:35 <SamB_XP> Surma: but you might want to use a reimplementation
05:28:36 <Peaker> Ezla: shared_ptr does ref-counting?
05:28:44 <Ezla> even the 4.3 release has rvalue references, and that's how move semantics are implemented (partially) in libstdc++
05:28:45 <lilac> Ezla: yeah, we're not moving to 4.4 until it's stable :)
05:28:49 <vixey> Surm, nub
05:28:49 <Surma> SamB_XP: y? is it slow?
05:28:50 <Ezla> they did it for their own sake
05:28:50 <SamB_XP> since nub itself is something like O(n^2)
05:28:53 <vixey> Surma, nub *
05:29:01 <ksf> am i on #gcc?
05:29:07 <Peaker> vixey: I didn't tell him he's ignorant, I told him he said wrong things about which he is ignorant, with complete confidence.  Everyone is ignorant about some things
05:29:08 <lilac> Ezla: i'm very much looking forward to the c++-0x stuff
05:29:19 <Ezla> lilac: Well, don't.
05:29:26 <eu-prleu-peupe1> lilac: specially the missing deprecation policy of the (already) huge standard
05:29:29 <Surma> SamB_XP: oh, thanks for the hint. But for this I don't really care, too lazy to write a new version ;)
05:29:30 <Ezla> It's nothing to look forward to. C++0x is a total failure.
05:29:36 <SamB_XP> Surma: okay
05:29:39 <lilac> Ezla: i disagree! :)
05:29:39 <Lemmih> vixey: I have to side with Peaker on this one. Ezla is dangerously close to trolling.
05:29:40 <Ezla> C++0x is C++98 v1.2
05:29:45 <Ezla> or C++98 ME
05:29:51 <eu-prleu-peupe1> heheh
05:30:07 <Ezla> its devastatingly inferior to D.
05:30:09 <SamB_XP> hey, that's MY joke
05:30:19 <vixey> Lemmih, If someone is trolling -- the right thing to do is insult them?
05:30:25 <lilac> Ezla: concepts (plus the new for loop), lambdas, rvalue references, template parameter packs -- these things all fix major issues, and are worth looking forward to IMO
05:30:34 <Peaker> Ezla: Do you use ref-counting pointers in C++ or D?
05:30:34 <Ezla> lilac: that's nothing.
05:30:40 <lilac> Ezla: no, that's four things
05:30:47 <SamB_XP> taking things with 98 or 2000 in the name and sticking a 2000, ME, XP, 2003 Server, or Vista after!
05:30:57 <SamB_XP> instead of the 98 or 2000
05:31:01 <Ezla> C++0x doesn't even do string nontype template parameters
05:31:10 <SamB_XP> so ... How's Haskell 2003 Server coming ?
05:31:21 <lilac> Ezla: you can do template<char...>
05:31:25 <Ezla> So?
05:31:28 <ksf> http://en.wikipedia.org/wiki/Socratic_method
05:31:29 <lambdabot> Title: Socratic method - Wikipedia, the free encyclopedia
05:31:30 <vixey> C++0x is C++ with more stuff added -- I'd be surprised if that is going to better than C++ with things removed?
05:31:31 <lilac> Ezla: that's basically the same thing
05:31:34 <Ezla> Foo<'h','e','l','l','o'>
05:31:36 <Ezla> not the same
05:31:36 <lilac> Ezla: only a nastier syntax
05:31:43 <eu-prleu-peupe1> i just love C++, its a great example of a failure as a far as designing programming languages goes
05:31:49 <SamB_XP> vixey: either way it's not going to be too good
05:31:54 <paolino> mmhh, is it right that containers fails to build via cabal install while I can build it with runhaskell  Setup.hs build ?
05:32:05 <Peaker> vixey: I did not mean to insult anyone, I said "you speak of ignorance" -- would it be less insulting to say "you don't know what you're talking about"?
05:32:08 <Ezla> lilac: D does everything C++0x does but is so far beyond C++ I can't even try to tell you
05:32:10 <lilac> Ezla: plus, you can write "hello"Foo
05:32:12 <Ezla> it would take too long
05:32:31 <Lemmih> vixey: Asking them to tone it down would be the right thing to do; which Peaker did.
05:32:32 <eu-prleu-peupe1> the performance argument is also very wrong in C++, because in most projects you dont even have time to optimize the "wrose than hell" code programmers produce :P
05:32:50 <eu-prleu-peupe1> and everybody knows how unoptimized C++ code performs...
05:32:52 <eu-prleu-peupe1> real nasty
05:33:05 <lilac> Ezla: i'm afraid i'm not interested -- your tone leads me to believe that some of your opinion is coloured from emotional attachment rather than rationality :(
05:33:05 <ksf> Peaker, the key is to undermine the other's arguments so they see for themselves that they are mistaken.
05:33:12 <paolino> cabal install says base is not exposed when it is really
05:33:26 <SamB_XP> Ezla: have you been reading the C++ FAQ or something ?
05:33:30 <SamB_XP> try the FQA instead
05:33:37 <int-e> paolino: ghc says that.
05:33:39 <Ezla> that's newbie stuff Sam
05:33:40 <SamB_XP> much more entertaining
05:33:53 <eu-prleu-peupe1> FQA ?
05:34:00 <Ezla> frequently questions answers
05:34:01 <int-e> paolino: it usually means that a .cabal file is not listing the 'base' (or whatever) package in its build-depends clause
05:34:03 <ksf> it's definitely harder than archery. some people just keep on arguing while they don't have anything left to base their arguments on.
05:34:07 <SamB_XP> a critique of the FAQ
05:34:18 <SamB_XP> question-by-question
05:34:25 <Ezla> lilac: It's not emotional
05:34:30 <lilac> SamB_XP: the FQA is a rant, and it's not even on target some of the time :(
05:34:32 <eu-prleu-peupe1> ksf: yes
05:34:32 <int-e> paolino: the reason why ghc says that is that cabal invokes it with the --hide-all-packages option
05:34:34 <SamB_XP> Ezla: oh, monetary then ?
05:34:34 <Ezla> It's based on the fact that I know every last aspect of C++0x
05:34:37 <Ezla> and of D.
05:34:41 <SamB_XP> lilac: where is it off target ?
05:34:49 <Ezla> I've been studying C++0x for yrs. It's a failure.
05:34:53 <SamB_XP> just for curiousity's sake
05:34:54 <Ezla> it's C++98 v1.2
05:34:55 <eu-prleu-peupe1> Ezla: you do ?
05:34:57 <lilac> Ezla: you /don't/ know every last aspect of C++0x. the standardization committe don't yet
05:34:58 <vixey> Ezla, I hope you're right :p
05:35:00 <ksf> ...so the technique then becomes: lead them into a direction they don't want to go.
05:35:02 <int-e> sigh. any ops?
05:35:03 <Ezla> Lilac: Yes they do.
05:35:08 <eu-prleu-peupe1> Ezla: have you tried studying the haskell report ?
05:35:09 <Ezla> C++0x was finalized.
05:35:13 * int-e is sort of tired of hearing about C++ and D :(
05:35:14 <mc__> Ezla: what is wrong about c++0x ?
05:35:17 <vixey> yeah
05:35:18 <SamB_XP> Ezla: how about the Haskell' report
05:35:19 <Ezla> The final draft is done.
05:35:21 <vixey> C++ and D is totally off topic
05:35:25 <paolino> int-e: base is in the Build-depends field
05:35:30 <vegai> yes, please stop already.
05:35:30 <vixey> maybe should move to #haskell-blah or something?
05:35:33 <mc__> vixey:  is right
05:35:36 <SamB_XP> maybe you can tell me if Haskell' is going to suck as much as I think it is ?
05:35:45 <Ezla> Lilac: please stop speculating about a language you don't know
05:35:57 <SamB_XP> Ezla: how about you too ;-P
05:35:59 <eu-prleu-peupe1> Ezla: and you know ?
05:36:13 * vixey joins haskell-blah incase anybody else actually did that... (guess not)
05:36:16 <Ezla> what's wrong with C++0x?
05:36:18 <Ezla> how about this:
05:36:25 <SamB_XP> the C++ part ?
05:36:26 <vegai> Ezla: /j #haskell-blah or shut up, please :)
05:36:28 <eu-prleu-peupe1> :D
05:36:32 <eu-prleu-peupe1> ahah
05:36:37 <int-e> paolino: hmm. does cabal install -v  print the ghc command line used?
05:36:44 <SamB_XP> ahah what ?
05:36:53 <vixey> Ezla, (or option 3, talk about anything on topic :))
05:37:03 <vegai> yes, of course
05:37:39 <SamB_XP> we could go back to explaining why explicit stack allocation is not a good idea in a lazy language ...
05:37:43 <Ezla> template <class Y> struct A { template <class X, class=void> struct B {}; template <class _> struct B<int, _> {}; void test() { typename A::template B<int> x; } };
05:37:44 <paolino> int-e : yes
05:37:50 <Ezla> C++0x fixes *none* of that
05:37:55 <Ezla> the whole thing is destroyed
05:37:56 <Peaker> ksf: The problem is, its pretty difficult to talk with someone who is completely convinced that he is right, and you are wrong, to the point where he's ridiculing what you're saying
05:38:01 <Ezla> none of the core problems were even touched
05:38:07 <SamB_XP> Ezla: I was right!
05:38:11 <Ezla> its completely deeply fucked inside
05:38:13 <SamB_XP> the problem is the "C++" bit
05:38:13 <int-e> Ezla: none of that is interesting for the majority here.
05:38:14 <Ezla> pathetic
05:38:15 <ksf> well then don't talk until you got a proper attack vector.
05:38:46 <lilac> Ezla: please stop speculating about which languages i know :)
05:38:47 <ksf> ppl _will_ stop after having a screenfull of their blah without anyone responding.
05:38:49 <Ezla> (if you understand the code, speak up)
05:38:54 <kynky> like asking the merits of windows in a linux channel
05:38:58 <Ezla> lilac: You don't know C++.
05:39:07 * vegai strikes a pose of an op
05:39:09 <eu-prleu-peupe1> Ezla: and you do ?
05:39:11 <eu-prleu-peupe1> :P
05:39:19 * vixey I am reading something cool about staged computating
05:39:22 <vixey> computation*
05:39:22 <lilac> Ezla: oh really? i've been developing C++ professionally for about 9 years
05:39:30 <jdrake> What would be the best way to case ... of   for matching a list of floats? These are command line arguments, so I think they come in strings.
05:39:32 <Ezla> lilac: Ok, describe the LOC I wrote?
05:39:34 <SamB_XP> lilac: you can't know C++
05:39:38 <Ezla> do you see the problem?
05:39:42 <SamB_XP> there's, like, a rule against it
05:39:45 <ksf> usually it's not the individual person that's problematic, but two or more of them together.
05:39:53 <Ezla> and do you understand how C++0x comes into play...
05:39:55 <SamB_XP> or wait, I remember now ... there is just too much C++ to learn
05:39:56 <vegai> @shapr
05:39:57 <vixey> jdrake, I'd avoid it I guess, or use a view so that you can match within some fuzz level
05:39:57 * lambdabot will count to five...
05:39:59 <eu-prleu-peupe1> Ezla: your dick ir really big
05:40:00 <ksf> if you can seperate them from each other, suddenly all become sensible.
05:40:08 <Ezla> its not about dick
05:40:11 <lilac> Ezla: it's a template specialization. so?
05:40:16 <Ezla> Lilac, come on dude
05:40:37 * mlesniak wonders when he has joined the #c++ channel
05:40:41 <jdrake> vixey, I need to have some way of converting it over while safely knowing when it doesn't work.
05:40:45 <Ezla> If you don't understand that, you're in no place to have an opinion on whether C++0x is a failure or not.
05:40:55 <Ezla> Again, C++0x is C++98
05:40:56 <hackage> Uploaded to hackage: haxr 3000.1.1.2
05:40:57 <vixey> jdrake, don't get it
05:40:57 * paolino kicks around with boots
05:40:59 <Ezla> it hardly does shit.
05:41:00 <kynky> except in a #haskell channel
05:41:24 <eu-prleu-peupe1> Ezla: c++0x is c++ with everything else and also a pair of boots
05:41:31 <vixey> jdrake, I meant something like  match (close [32,2.001,3,4.3] -> VeryClose) = ....
05:41:34 <eu-prleu-peupe1> and no deprecation policy :)
05:41:41 <SamB_XP> ARGH!
05:41:44 <SamB_XP> no deprecation
05:41:44 <Ezla> C++0x is the final straw for me.
05:41:51 <Ezla> Too big of a let down
05:41:53 <Peaker> Ezla: Why don't you talk about C++ stuff in #haskell-blah ?  The crowd is the same, but its not OT there
05:41:56 <vixey> data HowApproximate = VeryClose | Roughly | WayOff
05:41:56 <vixey> :)
05:42:01 <SamB_XP> Ezla: so did you schedule an appointment yet ?
05:42:04 <paolino> int-e: I can see a -package base-3.0.3.0 there
05:42:18 <dcoutts> paolino: perhaps your package needs base 4?
05:42:21 <dcoutts> if so, say so
05:43:10 <paolino> dcoutts : the problems is in containers , if I understand
05:43:11 <SamB_XP> Peaker: "the same"?
05:43:23 <SamB_XP> barely more than 10% of the size of this channel, -blah is!
05:43:35 <ksf> less lurkers.
05:43:40 <kynky> lol
05:43:41 <Ezla> D is where all the genius is today
05:43:46 <Ezla> in the C family of languages
05:43:50 <vegai> @users
05:43:50 <kynky> Ezla, why ?
05:43:50 <vixey> Ezla, D seems pretty stupid though
05:43:50 <lambdabot> Maximum users seen in #haskell: 555, currently: 514 (92.6%), active: 25 (4.9%)
05:43:51 <fasta> Why are most packages broken on Windows while Haskell is supposed to be platform independent?
05:43:55 <ksf> i was just about to say...
05:43:58 <vegai> well, at least he activated a lot of people :P
05:44:01 <vixey> Ezla, It's based on the C, C++ family
05:44:18 <SamB_XP> fasta: reality doesn't always play along ;-P
05:44:21 <Ezla> I hate to invoke the "authority figure" argument, but
05:44:29 <Peaker> Ezla: my pet C peeve (pointer syntax) was not fixed in D :P
05:44:34 <ksf> fasta, because the c libraries those packages use aren't really cross-platform.
05:44:36 <SamB_XP> Ezla: what did Mr. Rogers say ?
05:44:38 <lilac> Ezla: you have so far not demonstrated yourself to be an authority...
05:44:41 <Ezla> you know the COMEAU compiler -- Walter Bright
05:44:43 <ksf> ...because windows is a bugger to port to.
05:44:54 <mc__> peaker: what is wrong about the pointer syntax?
05:44:57 <ksf> it's barely posix-compatible.
05:44:57 <paolino> dcoutts : runhaskell Setup.hs -v build put a -package base-4.0.0.0a there and compiles
05:44:58 <Ezla> one of the only single men on earth to write a complete and total 100% feature complete and templates-working optimizing C++ compiler
05:45:03 <Ezla> which competes with GCC / msvc
05:45:16 <lilac> Ezla: last i heard, comeau still has bugs
05:45:20 <Ezla> He created D, because he understands C++ to the bone
05:45:27 <kynky> do you like the digital mars style of development on the implemetation of D
05:45:31 <SamB_XP> Ezla: the rest of the guys who wrote C++ compilers were married ?
05:45:41 <Ezla> SamB: none even did heh
05:45:44 <Peaker> mc__: The pointer type constructor * is prefix, whereas the other 2 type constructors [] and () are suffix.  So you need a lot of paren() to resolve precedence issues.. Ptr syntax should also be suffix to avoid the need for () support in types
05:45:48 <dcoutts> paolino: if you do not specify a version of base then different search procedures are free to pick different answers
05:46:10 <dcoutts> paolino: in this case it's because the cabal configure search method is stupid and the cabal install method is clever.
05:46:12 <paolino> dcoutts: using cabal install ?
05:46:22 <Ezla> anyways, the C++ spec is 1400 pages now
05:46:31 <ksf> actually, D doesn't really feel like a c.
05:46:33 <mc__> peaker: good point
05:46:37 <dcoutts> paolino: configure picks the latest versions of everything (even when that will not work)
05:46:40 <ksf> mostly because of the gc.
05:46:47 <Ezla> and the grammar is unparseable without semantic analysis and damn-near- building a compiler
05:46:49 <SamB_XP> dcoutts: that IS stupid!
05:46:50 <kynky> haskell is more succinct
05:46:53 <Ezla> D simplifies thousands of "special case scenarios" in the standard
05:46:53 <Peaker> mc__: To this day, most C programmers don't understand ptr syntax, and copy&paste to declare function pointers
05:46:59 <Ezla> for a global general solution throughout
05:47:02 <Ezla> there's no surprises
05:47:07 <Ezla> And then, at the same time...
05:47:11 <dcoutts> paolino: install uses a constraint solver and uses preferences like base < 4 which it uses when the package does not otherwise say which version it wants
05:47:15 <kynky> and why does c++ need friends ?
05:47:15 <Ezla> it totally destroys C++ for metaprogramming
05:47:21 <jdrake> vixey, I am not sure what match (close [32,2.001,3,4.3] -> VeryClose) =    means. I do not have specific numbers, they could be any number.
05:47:26 <paolino> ok, so containers.cabal is broken
05:47:27 <Ezla> D has full reflection
05:47:31 <vixey> jdrake, huh ?
05:47:38 <Ezla> it has compile time functions, and can write itself
05:47:39 <ksf> Ezla, I doubt that.
05:47:41 <dcoutts> SamB_XP: it's a little harder than simply saying that configure should use the constraint solver.
05:47:42 <vixey> Ezla, come o #haskell-blah :) we are talking about D there
05:47:47 <Ezla> ksf: Doubt all you like
05:47:48 <Peaker> I think Ezla ignores me, so can someone ask him again to move the discussion to #haskell-blah ?  Everyone who is talking about it is there already..
05:47:51 <ksf> introspection maybe, but not reflection.
05:47:53 <SamB_XP> Ezla: yeah, in Haskell you only need to know the precedences of identifiers to parse code
05:48:02 <SamB_XP> not types or anything
05:48:05 <dcoutts> SamB_XP: if the solver fails that'd prevent you from building the package, when it may well work anyway
05:48:07 <Ezla> D has a template system that is way more general than C++
05:48:12 <Ezla> template Foo(X) {
05:48:17 <Ezla> templates apply to anything
05:48:23 <lilac> Ezla: C++ versus D is off-topic for #haskell...
05:48:26 <paolino> dcoutts: someone should put a constraint there on the base dep
05:48:33 <dcoutts> paolino: so you're rebuilding containers?
05:48:36 <SamB_XP> dcoutts: does it TELL you when it violates the constraints ?
05:48:44 <dcoutts> SamB_XP: yes
05:48:48 <dcoutts> it warns
05:48:54 <paolino> well I did cabal install containers
05:48:58 <Ezla> well, Lilac, you claimed C++0x was OK, and that my opinion was based on "emotion" rather than knowledge
05:49:13 <Ezla> it's not emotion, it's based on literal functionality and features
05:49:19 <dcoutts> paolino: ok, I see. Yes, it should use build-depends: base >= 4
05:49:29 <lilac> Ezla: i said i suspected it was, that's all, and that i wasn't interested
05:49:56 <ksf> Ezla, OK might be defined differently for different people for different topics.
05:50:03 <lilac> Ezla: also, all i said was that i was looking forward to c++0x, because it's an improvement over c++98
05:50:05 <paolino> dcoutts: actually it was protocol-buffers ...
05:50:08 <ksf> in fact, i'm quite sure it _is_ defined differently.
05:50:19 <jdrake> Ok, what I am talking about is having a program where you might get input such as "4500 0.0825 400" where the last number can repeat limitless times (but in all practicality will be finite). I am using Float for everything, and getArgs should return ["4500", "0.0825", "400"].
05:51:55 <paolino> dcoutts: and the error is misleading...
05:52:55 <dcoutts> paolino: the error about a module from base being hidden you mean? There's not a lot we can do about that without major changes (which are planned but will take some time)
05:53:07 <dcoutts> because that error is not from cabal but from ghc
05:53:18 <paolino> ok, now I installed containers and protocol-buffers tries to compile containers again, failing
05:54:56 <jdrake> @src forM
05:54:57 <lambdabot> forM = flip mapM
05:55:11 <jdrake> @src (>=>)
05:55:11 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:55:16 <dcoutts> paolino: why does it want to install containers? You must already have it
05:55:18 <jdrake> :t (>=>)
05:55:20 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:55:23 <jpcooper> hello
05:55:35 <jpcooper> is there syntactical sugar to apply a function to a field of a record and have it take the returned value?
05:55:36 <paolino> dcoutts:is there a cache in cabal that creates the problem ?
05:55:46 <jdrake> jpcooper, salvete!
05:55:54 <dcoutts> paolino: perhaps use hpaste for the output of cabal install -v --dry-run protocol-buffers and ghc-pkg list
05:56:02 <jpcooper> jdrake, pardon me?
05:56:11 <jdrake> jpcooper, do you not speak latin?
05:56:12 <ksf> Ezla, regarding OOP vs FP, check out oleg's take on it: http://okmij.org/ftp/Computation/Subtyping/
05:56:12 <lambdabot> Title: Subtyping, Subclassing, and Trouble with OOP
05:56:21 <jpcooper> jdrake, I sadly don't
05:56:29 <jdrake> That is a shame
05:56:53 <jpcooper> hello to you too, though
05:57:36 <jdrake> jpcooper, I greet you with a MonadCake, and offer a topping of WhippedCream.
05:58:06 <Badger> mmmm, MonadCake.
05:58:09 <jpcooper> I'm sadly not in that monad
05:58:37 <jdrake> jpcooper, would you prefer FlatMonad? It is yeast and gluten free.
05:58:56 <jpcooper> I've had lunch
05:59:13 <jdrake> hmm, I just had breakfast
05:59:21 <jdrake> A lovely kipper and waffles.
05:59:23 <paolino> dcoutts: http://hpaste.org/12567
05:59:31 <jdrake> Unfortunately no black pudding this morning.
06:01:29 <athos> hi
06:01:35 <paolino> dcoutts: it want to downgrade containers
06:02:09 <jdrake> athos, salvete!
06:02:41 <athos> ave jdrake
06:02:44 <athos> :)
06:03:11 <jdrake> athos, a lovely day today, yes?
06:03:30 <dcoutts> paolino: what version of cabal-install are you using?
06:04:52 <paolino> dcoutts: 0.6.0
06:05:07 <fasta> Is there any way to build a shared library on Windows from a Haskell library that doesn't use dlltool?
06:05:40 <dcoutts> paolino: hmm. That looks like a case I added specific code to deal with. So I was half expecting that you were using a pre-release that was missing that.
06:05:54 <Axman6> anyone played with the CouchDB interface?
06:05:57 <dcoutts> paolino: did you build your cabal-install from darcs or from a release tarball?
06:06:12 <dcoutts> paolino: is it possible that you might be using a pre-release?
06:07:11 <paolino> ok, I try with darcs
06:08:14 <dcoutts> paolino: no, I'd expect it to work with the release
06:08:27 <paolino> ctrl-c
06:08:54 <ksf> guys and gals, if everyone here contributes one line of code to a haskell browser we're done, let's go for it!
06:09:04 <vixey> main =
06:09:13 <mlesniak> main = do
06:09:22 <vixey> noo
06:09:29 <vixey> I'm putting main in reactive
06:09:42 * mlesniak has no knowledge about this reactive stuff ;)
06:09:48 * vixey neither :p
06:09:52 <paolino> {-# LANGUAGE UseFirefox #-}
06:10:09 <Axman6> dons: you around?
06:11:14 <paolino> mlesniak: it's a rubber wall
06:12:03 <paolino> to me at least ;-
06:12:05 <dcoutts> paolino: my only guess is that the fact that you've got the same version of packages registered globally and per-user is confusing cabal
06:12:46 <dcoutts> paolino: try unregistering the per-user registered haskell98 and array packages
06:12:55 <mlesniak> paolino: /me does not even know what a rubber wall is ;)
06:14:02 <jpcooper> @hoogle a -> [a] -> Bool
06:14:03 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
06:14:03 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
06:14:03 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
06:15:36 <paolino> dcoutts: you got it eh
06:17:04 <dcoutts> paolino: hmm, I still don't understand why that should do it exactly
06:17:35 <paolino> mlesniak: a rubber wall is the thing that when I try to understand it , I rebounce
06:18:27 <paolino> dcoutts: it's very probable it will happen again
06:19:11 <cknapp> I like Haskell... and the Haskell tools. I have a bad habit of learning new programming languages by programming a final project in them... And I'm way behind, and thought I was going to have to hand time everything.... then I heard someone mention "profiling"
06:19:23 <dcoutts> paolino: I'm aware of the general problem that overlaps in the databases are not handled well. The longer term solution is to identify installed packages differently.
06:19:51 <dcoutts> cknapp: read the section in the ghc users guide on profiling.
06:20:03 <cknapp> That's what I'm doing. :D
06:21:13 <pao> dcoutts: just a 2 cent...
06:21:48 <pao> dcoutts: why not using a "disposable" throw away only solution?
06:22:00 <paolino> dcoutts: still the base packages  3 and 4 are in the same database, downgrading containers was not very logical
06:22:09 <dcoutts> pao: well sure, the question is in the details
06:22:18 <jdrake> What precisely does (>=>) do? I can't quite see anything special with it based on the source.
06:22:33 <dcoutts> paolino: it was not downgrading, it was reinstalling against different dependencies
06:22:55 <Peaker> @type (>=>)
06:22:55 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:23:04 <pao> dcoutts: let's say we configured and environment for each application.... each environment bundled with it's own set of dependencies
06:23:07 <lilac> jdrake: it's (>>>) for the Kleisli arrow of a monad :)
06:23:20 <lilac> jdrake: essentially, monadic function composition
06:23:28 <Peaker> jdrake: I don't think there's more than one useful way to implement that type
06:23:39 <pao> dcoutts: It should be doable right now just fiddling with env variables
06:24:11 <jdrake> Now, if there was a problem where you needed to apply a function to a list, but you wanted to know if it failed for any reason (reason not important) what would be the best way to do that?
06:24:46 <lilac> f >=> g = join . fmap g . f
06:24:46 <vixey> jdrake, 'failed'? .. what
06:25:00 <vixey> jdrake, what is the type of the function?
06:25:00 <vixey> a
06:25:22 <jdrake> Approximately: String -> Float   (not written yet)
06:25:24 <vixey> I use (<=<) lie (.)
06:25:28 <dcoutts> pao: I'm not sure I understand how that's related to the suggestion to have a quick partial solution to the problem
06:25:34 <vixey> jdrake, so make it String -> Maybe Float
06:25:38 <vixey> I use (<=<) like* (.)
06:25:52 <lilac> rather, f >=> g = join . lifM g . f
06:26:00 <jdrake> vixey, I am not experienced enough to see what that explicitly means
06:26:07 <pao> dcoutts: can starting off a clean user db help?
06:26:38 <dcoutts> pao: having no overlap in the user and global dbs can help
06:27:07 <pao> dcoutts: ok, I'll shut my mouth :-)
06:27:12 <vixey> jdrake, you give meaning to it by writing a function with that type
06:27:19 <paolino> dcoutts: the array in the user was depending on base 3 ?
06:27:31 <ksf> It came to me that c++ might just be failing avoiding success.
06:27:35 <vixey> jdrake, Nothing :: Maybe Float can be used for failure, Just 3.2 :: Maybe Float as success
06:27:54 <lilac> jdrake: i've found that being able to deduce what functions do from thir types is a useful skill, and is worth spending time getting good at
06:27:56 <ksf> I mean, you even see people using INTERCAL, so why not c++?
06:28:08 <jdrake> :t (<=<) like* (.)
06:28:10 <lambdabot> Not in scope: `like'
06:28:31 <Peaker> jdrake: you can feed an input through 2 "actions" by feeding the input to the first action, and then the result of the first action into the second action
06:28:34 <lilac> ksf: i seem to recall a joke interview with K & R where they basically claimed that for C
06:28:42 <dcoutts> paolino: it probably was, but that still does not explain to me why we were switching the deps of containers
06:29:15 <jdrake> lilac, most likely considering the state of some documentation.
06:29:40 <lilac> jdrake: i wish i could disagree ;)
06:29:41 <jdrake> @hoogle like*
06:29:41 <lambdabot> Parse error:
06:29:41 <lambdabot>   --count=20 like*
06:29:41 <lambdabot>                   ^
06:30:07 <jdrake> Where can I find like*
06:30:31 <Lemmih> jdrake: Next to the any key.
06:30:59 <ksf> jdrake, lilac, the problem is that 99% of all libraries have thousands of functions of type a -> a -> (a -> a) -> a and the like, none of them documented by more than a name like "unSPK'"
06:31:06 <paolino> dcoutts: the array in the user was a base 3 so the binary was to be bundled with a container from base 3 as from protocols-buffer cabal
06:31:07 <lilac> jdrake: "like" was a correction of "lie"
06:31:34 <jdrake> So he just meant like then?
06:31:45 <jdrake> @hoogle like
06:31:46 <lambdabot> package ListLike
06:31:57 <jdrake> @src like
06:31:58 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:32:03 <lilac> jdrake: /she/ meant that you can use <=< for monadic functions in the same way you use . for normal functions
06:32:38 <jdrake> Talk about confusing the hell out of me
06:33:08 <vixey> :t \f -> \k -> f (\x -> \k -> k (k x)) (\z -> z)
06:33:10 <lambdabot> forall t t1 t2 t3. ((t1 -> (t1 -> t1) -> t1) -> (t2 -> t2) -> t3) -> t -> t3
06:33:22 <vixey> how do you unCPS a type?
06:33:34 <jdrake> ok, this is all very abstract right now. I must write/find the function to convert string to float in the way I need.
06:33:40 <paolino> :t ap
06:33:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:33:58 <lilac> jdrake: suppose you have "double x = 2*x" and "square x = x*x", you can write "doubleThenSquare = square . double"
06:34:34 <lilac> jdrake: if instead you have "doubleAndLog x = do print x; return (2*x)" and "squareAndLog x = do print x; return (x*x)"
06:34:58 <ksf> @pl (\x = x*x)(\x = 2*x)
06:34:58 <lambdabot> (line 1, column 5):
06:34:58 <lambdabot> unexpected "="
06:34:58 <lambdabot> expecting operator, pattern or "->"
06:35:00 <lilac> jdrake: then (.) doesn't work any more, because the types are Num a => a -> IO a
06:35:02 <vixey> Then = (<=<)
06:35:06 <ksf> @pl (\x -> x*x)(\x -> 2*x)
06:35:06 <lambdabot> (2 *) * (2 *)
06:35:20 <vixey> oops
06:35:21 <Twey> jdrake: read?
06:35:23 <vixey> Then = (>=>)
06:35:23 <ksf> @pl (\x -> x*x).(\x -> 2*x)
06:35:24 <lambdabot> join (*) . (2 *)
06:35:36 <jdrake> I think I see that.
06:35:36 <Twey> > read "12.35" :: Float
06:35:40 <lambdabot>   12.35
06:35:49 <ksf> the other one's fun though, too.
06:35:50 <jdrake> But isn't that what >>= does?
06:35:54 <Twey> No
06:35:57 <vixey> @pl return 1 >>= \x -> return (x+1)
06:35:58 <lambdabot> return 2
06:36:01 <lilac> jdrake: since IO is a monad, you can use (>=>) in the place of (.), as in "doubleThenSquareAndLog = double >=> square"
06:36:01 <vixey> :O
06:36:08 <vixey> it did evaluation!
06:36:20 <Twey> Haha, vixey
06:36:29 <vixey> @pl return 1 >>= \x -> return (2*x+1)
06:36:30 <Twey> So it did... I never knew it did that
06:36:30 <lambdabot> return 3
06:36:31 <lilac> jdrake: note that the functions are the other way around. (<=<) is the monadic equivalent of (.), and f <=< g == g >=> f
06:36:36 <vixey> @pl return x >>= \x -> return (2*x+1)
06:36:36 <lambdabot> return (2 * x + 1)
06:36:49 <vixey> weird
06:36:53 <paolino> dcoutts: anyway I guess there is some kind of constraint for the deps of the packages listed in a dependency list
06:37:07 <Twey> @pl unsafePerformIO (print "foo")
06:37:07 <lambdabot> unsafePerformIO (print "foo")
06:37:09 <vixey> @pl 1/(2 * 3 + 1)
06:37:10 <lambdabot> 1 / 7
06:37:10 <Twey> Aw :-P
06:37:20 <vixey> @pl reverse "abc"
06:37:21 <lambdabot> reverse "abc"
06:37:24 <lilac> vixey: i guess @pl uses rewrite rules? that's cool
06:37:25 <vixey> @pl 1 + reverse "abc"
06:37:25 <lambdabot> 1 + reverse "abc"
06:37:35 <vixey> @pl 1 + 0 * reverse "abc"
06:37:36 <lambdabot> 1
06:37:39 <paolino> dcoutts: that's why it forced array and containers to be built from same base
06:37:40 <lilac> @pl \x -> map f . map g $ x
06:37:41 <lambdabot> map (f . g)
06:37:48 <jdrake> @src read
06:37:49 <lambdabot> read s = either error id (readEither s)
06:37:49 <Twey> That's clever
06:37:53 <vixey> ooh
06:37:56 <paolino> dcoutts: wich sounds right
06:37:57 <vixey> lilac, nice fin!
06:38:00 <vixey> lilac, nice find
06:38:10 <jdrake> :t read
06:38:11 <lambdabot> forall a. (Read a) => String -> a
06:38:27 <jdrake> :t Read
06:38:28 <lambdabot> Not in scope: data constructor `Read'
06:39:08 <ksf> @pl map f . map g
06:39:09 <lambdabot> map (f . g)
06:39:17 <Twey> Read is a type, not a constructor.
06:39:21 <vixey> @pl fmap . id
06:39:22 <lambdabot> fmap
06:39:24 <Twey> Typeclass, in fact.
06:39:29 <vixey> @pl fmap f . fmap g
06:39:29 <lambdabot> fmap (f . g)
06:39:31 <vixey> @pl fmap id
06:39:32 <lambdabot> id
06:39:41 <vixey> @pl x >>= return
06:39:42 <paolino> @src Read
06:39:42 <lambdabot> x
06:39:42 <lambdabot> class Read a where
06:39:42 <lambdabot>   readsPrec    :: Int -> ReadS a
06:39:42 <lambdabot>   readList     :: ReadS [a]
06:39:42 <lambdabot>   readPrec     :: ReadPrec a
06:39:44 <lambdabot>   readListPrec :: ReadPrec [a]
06:39:56 <vixey> @pl (m >=> n) >=> u
06:39:56 <lambdabot> m >=> n >=> u
06:40:03 <vixey> @pl m >=> (n >=> u)
06:40:03 <lambdabot> m >=> (n >=> u)
06:40:10 <Philonous> @src >=>
06:40:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:40:19 <Philonous> @type >=>
06:40:20 <lambdabot> parse error on input `>=>'
06:40:24 <vixey> @pl m >>= (\x -> n x >>= \x -> u x)
06:40:24 <lambdabot> u =<< n =<< m
06:40:25 <Philonous> @type (>=>)
06:40:26 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:40:35 <vixey> @type (.)
06:40:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:41:07 <Philonous> (.) = >=> for the identity monad?
06:41:11 <paolino> @type (>>=)
06:41:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:41:31 <vixey> Philonous, no
06:41:33 <vixey> Philonous, (<=<)
06:41:40 <Philonous> Oh, right
06:42:10 <Philonous> I still think (.) should be flip (.) ;)
06:42:29 <jdrake> > readList ["4500","0.0825","400"]::[Float]
06:42:30 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
06:42:54 <Peaker> Philonous: I agree, but (f a) should be flipped too to (a f)
06:42:59 <Peaker> Philonous: and ($) too
06:43:21 <vixey> Philonous, no
06:43:29 <vixey> Philonous, (.) is right, what you want is (;)
06:43:31 <paolino> :t readList
06:43:32 <lambdabot> forall a. (Read a) => String -> [([a], String)]
06:43:41 <Philonous> Peaker You like the reversy polish notation?
06:43:42 <vixey> f.g.h = h;g;f
06:43:56 <jdrake> > read "4500"::Float
06:43:57 <lambdabot>   4500.0
06:44:04 <jdrake> > read "blah"::Float
06:44:06 <lambdabot>   * Exception: Prelude.read: no parse
06:44:10 <vixey> jdrake, you don't want to use read ...
06:44:12 <Peaker> Philonous: Apparently I do :-)   I don't really care if its (f a) or (a f), but I do want it to be consistent and I do prefer f.g.h  to be read from left to right
06:44:32 <BeelsebobWork> > let (;) = flip (.), (;$) = ($) in (+2); (62*);$ 5
06:44:33 <lambdabot>   <no location info>: parse error on input `;'
06:44:36 <BeelsebobWork> aww :(
06:44:36 <jdrake> vixey, whyn't?
06:44:42 <paolino> ﻿> readList "4500 0.0825 400" :: ([Float],String)
06:45:52 <jdrake> :t readList
06:45:54 <lambdabot> forall a. (Read a) => String -> [([a], String)]
06:46:18 <jdrake> ok, the documentation said readList :: ReadS [a]   but I can't read that to see String -> [...
06:46:30 <jdrake> nvm, maybe I can
06:46:37 <Philonous> vixey: For some reason my math profs defined functional composition to be (f o g) x = g(f(x)). That's why I sometimes gat a little confused
06:46:42 <paolino> @src ReadS
06:46:42 <lambdabot> Source not found. My mind is going. I can feel it.
06:46:46 <lilac> i think . and application are the right way around. the leftmost bit gets forced first...
06:47:01 <jdrake> Philonous, isn't that backwards?
06:47:03 <paolino> @type ReadS
06:47:04 <lambdabot> Not in scope: data constructor `ReadS'
06:47:11 <Peaker> lilac: why force the func before the arg?
06:47:18 <ksf> jdrake, because read is slow as syrup.
06:47:20 <Peaker> lilac: oh of course, forget that question :-)
06:47:38 <lilac> what question? :)
06:47:47 <jdrake> ksf, this is a one off operation for typically 3 values, upto a couple dozen.
06:47:52 <Peaker> lilac: of why to force the func first, its clear now
06:47:53 <vixey> Philonous, that's bizarre, tell them to use (;) instead of (o)
06:48:08 <paolino> anyway type ReadS a = String -> (a,String)  I guess
06:48:10 <lilac> Peaker: i meant that i'd already forgotten.. never mind :)
06:48:15 <jdrake> :t read
06:48:17 <lambdabot> forall a. (Read a) => String -> a
06:48:26 <Peaker> lilac: So (f a) syntax allows the forcing to occur left-to-right,  but (a f) allows the data processing to occur left-to-right
06:48:30 <Peaker> I am not sure which is more important
06:48:32 <ksf> jdrake, then, by any means, implement it in hand-optimised assembly ;)
06:49:03 <jdrake> How do I catch the failure of the  * Exception: Prelude.read: no parse  from read?
06:49:04 <ksf> behind-deadline optimisation is the root of all evil ;)
06:49:05 <Philonous> vixey: It is strange yes, but they do have a point, intuitively (f o g) should be "first f, then g". Though it doesn't really matter, does it.
06:49:09 <Ezla> how do you store collections of things... in Haskell, persistently?
06:49:25 <BeelsebobWork> Ezla: you don't store thing persistantly in any language
06:49:27 <BeelsebobWork> you write them to disk
06:49:37 <BeelsebobWork> in Haskell, you perform that task using the IO monad
06:49:57 <Axman6> iwht couchdb!
06:49:58 <Axman6> >_>
06:49:59 <jdrake> Image based languages could be called persistant
06:50:01 <Ezla> If I want 10,000 ducks in a 100 x 100 grid
06:50:01 <Axman6> with*
06:50:16 <Ezla> ducks which are each different
06:50:30 <lilac> Ezla: haskell has a number of Array data structures you can use for that
06:50:31 <Ezla> how do you have "Containers" of things in Haskell
06:50:36 <Ezla> if there's no Objects
06:51:03 <jdrake> Ezla, C didn't have any objects but had plenty of containers
06:51:07 <paolino> jdrake you dont
06:51:10 <lilac> Ezla: presumably you want O(1) random access to elements in this grid?
06:51:11 <BeelsebobWork> Ezla: data does not have to go in Objects
06:51:16 <paolino> :t reads
06:51:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:51:32 <BeelsebobWork> and if that's what you want you want an Array (Int,Int) Duck
06:51:43 <jdrake> paolino, so I check to see if anything is left over?
06:51:46 <BeelsebobWork> i.e. an Array, indexed by pairs of integers
06:51:48 <BeelsebobWork> which stores Ducks
06:51:59 <arcatan> aww ducks!
06:52:00 <paolino> reads gives you an empty list
06:52:06 <Ezla> well
06:52:07 <mrd> I hope this isn't about duck typing
06:52:07 <osfameron> haskell can do duck-typing ?
06:52:12 <osfameron> damn, too slow :-)
06:52:16 <BeelsebobWork> >.<
06:52:18 <Ezla> the individual ducks have to be in memory somewhere
06:52:23 <BeelsebobWork> Ezla: yep
06:52:25 <jdrake> > reads "2.5"::Float
06:52:26 <Ezla> so there has to be /some/ kind of "Container"
06:52:27 <lambdabot>   Couldn't match expected type `Float'
06:52:28 <BeelsebobWork> they are in memory in the array
06:52:31 <ksf> haskell does a bit of duck-typing in the Num instances.
06:52:33 <jdrake> > (reads "2.5")::Float
06:52:34 <lambdabot>   Couldn't match expected type `Float'
06:52:39 <jdrake> > (reads "2.5")::Double
06:52:40 <lambdabot>   Couldn't match expected type `Double'
06:52:57 <BeelsebobWork> Ezla: otoh, if you want to efficiently remove rows of ducks, you might like [[Duck]] as a store
06:53:01 <mrd> > reads "2.5" :: [(Double,String)]
06:53:02 <BeelsebobWork> i.e. a list of lists of ducks
06:53:02 <lambdabot>   [(2.5,"")]
06:53:07 <Ezla> a store?
06:53:09 <jdrake> oops :p
06:53:26 <jdrake> > (reads "fail")::[(Double,String)]
06:53:27 <lambdabot>   []
06:53:29 <ksf> > reads "2.4 3" :: [(Double,String)]
06:53:31 <lambdabot>   [(2.4," 3")]
06:53:59 <Philonous> Btw. what is the complexity of transpose?
06:54:06 <ksf> ah i thought it returns a lazy list of multiple parses and resulting strings.
06:54:23 <orbitz> does function call bind more tightly thana ny other operation?
06:54:27 <jdrake> my failure mode for input would be an empty list or a string (2nd in tuple) with leftover input then.
06:54:28 <paolino> well, is there an example of reads with a list with more than one choice ?
06:54:32 <ksf> s/resulting/left-over/
06:54:36 <jdrake> > (reads "2.4 2.5 2.6")::[(Double,String)]
06:54:37 <lambdabot>   [(2.4," 2.5 2.6")]
06:54:41 <BeelsebobWork> > ["duck" ++ show x ++ " " ++ show y, x <- [0..3], y <- [0..3]] -- Ezla -- this, but with bigger numbers
06:54:42 <lambdabot>   <no location info>: parse error on input `<-'
06:54:52 <BeelsebobWork> > ["duck" ++ show x ++ " " ++ show y | x <- [0..3], y <- [0..3]] -- Ezla -- this, but with bigger numbers
06:54:53 <lambdabot>   ["duck0 0","duck0 1","duck0 2","duck0 3","duck1 0","duck1 1","duck1 2","duc...
06:54:55 <mrd> paolino: no, it's supposed to be [] or 1 element.  I think it predates Maybe.
06:55:10 <jdrake> I shall Maybe-ify it
06:55:16 <mrd> @hoogle listToMaybe
06:55:17 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
06:55:43 <BeelsebobWork> > [["duck" ++ show x ++ " " ++ show y | y <- [0..3]] | x <- [0..3]] -- or this Ezla
06:55:44 <lambdabot>   [["duck0 0","duck0 1","duck0 2","duck0 3"],["duck1 0","duck1 1","duck1 2","...
06:55:50 <orbitz> > listToMaybe []
06:55:51 <lambdabot>   Nothing
06:55:55 <orbitz> > listToMaybe [1]
06:55:56 <lambdabot>   Just 1
06:56:01 <paolino> mrd, is that wht's called a greedy parser ?
06:56:04 <orbitz> > listToMaybe [1, 2]
06:56:05 <lambdabot>   Just 1
06:56:33 <jdrake> orbitz, but one of the unsuccessful cases in my problem domain "2.4 blah" would be accepted
06:57:26 <paolino> reads "2.5" [(Double,String)] could be not greedy and give also (2,".5")
06:57:41 <lilac> Ezla: the most appropriate representation, as in other languages, depends on what qualities you want your collection to have
06:57:53 <BeelsebobWork> indeed
06:57:55 <lilac> Ezla: what operations do you want to perform on your array
06:58:03 <lilac> Ezla: and how fast do you want / need them to be?
06:58:07 <jdrake> > readS "2.5"::[(Double,String)]
06:58:08 <lambdabot>   Not in scope: `readS'
06:58:43 <BeelsebobWork> Ezla: bearing in mind that that question is about different circumstances -- e.g. you can have O(1) insert, but O(n) remove, or you can have O(n) insert, but O(1) remove etc
06:58:46 <BeelsebobWork> as in any other language
07:04:00 <lilac> Ezla: (singly-linked-)lists are a common tool used by haskell programmers, since there're lots of library functions which work with them
07:04:24 <lilac> Ezla: but there're many other options if lists aren't appropriate.
07:07:01 <ksf> Ezla, and if you use the stream-fusion package, all your maps, foldr's and so on get reduced into neat tightloops.
07:07:37 <ksf> so you can end up with only having a couple of ducks in memory, if the traversal directions are right.
07:08:49 <ksf> as in
07:08:56 <ksf> > product [1...100]
07:08:58 <lambdabot>   Not in scope: `...'
07:09:01 <ksf> > product [1..100]
07:09:02 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
07:09:04 <quicksilver> ksf: even if you don't use the stream fusion package, maps, filters and concatMaps will fuse.
07:10:06 <ksf> sure, but I'd include stream fusion for any list-heavy code.
07:10:26 <Peaker> Ezla: Haskell has polymoprhism, encapsulation and data-hiding.  It just doesn't use inheritence to achieve any of these, which is why it isn't OO
07:10:31 <ksf> ...before i gotta reason about what fusion technique fuses which functions.
07:10:38 * lilac wonders about reactive fusion
07:11:15 <ksf> all fusions are reactive, ask the next physician ;)
07:11:35 <sw17ch> What's the syntax to pattern match on a record again?
07:11:54 <ksf> the same as on any other data type.
07:11:54 <lilac> sw17ch: same as the syntax to construct a record
07:12:10 <vixey> @src M
07:12:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:12:10 <vixey> @src Mu
07:12:11 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
07:12:17 <sw17ch> in that case
07:12:26 <vixey> > case In 3 of In {out=x} of x
07:12:27 <lambdabot>   <no location info>: parse error on input `of'
07:12:28 <sw17ch> In { out = v }
07:12:31 <vixey> > case In 3 of In {out=x} -> x
07:12:32 <lambdabot>       No instance for (Num (f (Mu f)))
07:12:32 <lambdabot>        arising from the literal `3' at...
07:12:43 <vixey> > case In (Left 3) of In {out=x} -> x
07:12:45 <lambdabot>       No instance for (Show (Mu (Either t)))
07:12:45 <lambdabot>        arising from a use of `sh...
07:12:46 <lilac> @type let f (In { out = x }) = x in f
07:12:48 <lambdabot> forall (t :: * -> *). Mu t -> t (Mu t)
07:12:59 <vixey> > case In 3 of In {out=Left x} -> x
07:13:01 <lambdabot>       No instance for (Num (Either t (Mu (Either t))))
07:13:01 <lambdabot>        arising from th...
07:13:13 <vixey> > out (In (Left 3))
07:13:15 <lambdabot>       No instance for (Show (Mu (Either t)))
07:13:15 <lambdabot>        arising from a use of `sh...
07:14:02 <lilac> > case fix (In . Right) of In {out = x} -> x
07:14:03 <lambdabot>       No instance for (Show (Mu (Either a)))
07:14:03 <lambdabot>        arising from a use of `sh...
07:14:31 <lilac> @type case fix (In . Right) of In {out = x} -> x
07:14:32 <lambdabot> forall a. Either a (Mu (Either a))
07:14:57 <ksf> you can't use case Foo 1 of Foo x -> x ?
07:15:17 <ksf> that is, constructor and deconstructor are seperate?
07:15:21 <vixey> > case Foo 1 of Foo x -> x
07:15:23 <lambdabot>   Not in scope: data constructor `Foo'Not in scope: data constructor `Foo'
07:15:36 <ksf> ... if Foo's a record.
07:15:51 <RayNbow> hmm, a Dutch shop is expecting RWH on 24th of December...
07:16:17 <lilac> @type case fix (In . Right) of In x -> x -- ksf: yes, you can
07:16:18 <lambdabot> forall a. Either a (Mu (Either a))
07:16:41 <vixey> hey dolio
07:17:04 <BeelsebobWork> RayNbow: RWH?
07:17:19 <RayNbow> Real World Haskell
07:17:19 <ksf> @where rwh
07:17:20 <lambdabot> is http://www.realworldhaskell.org/blog/
07:17:26 <BeelsebobWork> oh, duh
07:17:27 <RayNbow> ^ :)
07:18:06 * ksf thinks it should point to the book itself.
07:18:11 <ksf> @where real
07:18:11 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
07:18:18 <ksf> to that uri.
07:21:24 <fasta>  How can I list all the symbols in a Windows DLL?
07:22:11 * ksf restrains himself from answering "readelf"
07:22:21 <fasta> Or: is there a list with development tools for Windows somewhere?
07:22:34 <Ezla> so, what's the best haskell document to read
07:22:44 <Ezla> to start code
07:22:55 <Ezla> "A Gentle Introduction to Haskell, Version 98" ?
07:23:15 <Valodim> the yet another is better for beginners iirc
07:23:33 <Valodim> however, that Real World Haskell did get some attention lately, and what I read of it was pretty good
07:23:36 <lilac> fasta: the 'depends.exe' dependency walker which comes with (IIRC) the platform SDK does that
07:23:42 <Ezla> doo you guys actually manage to make any Haskell programs?
07:23:51 <Ezla> or do you spend forever working on abstract concepts
07:24:05 <Valodim> ..uh.. check hackage?
07:24:11 <lilac> Ezla: have you seen xmonad or darcs, for isntance?
07:24:26 <Ezla> xmonad is the only haskell program I know of
07:24:26 <sw17ch> Ezla: I'm making a VPN!
07:24:35 <mornfall> Ezla: darcs might be another...
07:24:44 <sw17ch> Ezla: http://code.google.com/p/scurry/
07:24:45 <lambdabot> Title: scurry - Google Code
07:24:57 <fasta> Ezla: yes, real programs do exist and they would exist even faster if Windows didn't.
07:25:10 <sw17ch> It's a cross platform (Windows, Linux, Mac, BSD) peer to peer VPN client!
07:25:11 <Ezla> fasta: ?
07:25:12 <sw17ch> :D
07:25:18 * fasta stares at a crashing Cygwin.
07:25:27 <Ezla> but do YOU guys make real programs
07:25:30 * sw17ch shares fasta's sentiment
07:25:34 <Ezla> or do you wank in theory for ages
07:25:35 <sw17ch> Ezla: don't you hear me?
07:25:52 <Ezla> sw17ch: is it vaporware?
07:25:57 <Ezla> haskell just smells of vapor :P
07:26:04 <Valodim> ok you're close to being offensive
07:26:08 <sw17ch> Ezla: no, check out the log
07:26:08 * mornfall nominates Ezla for a to-be-ignored troll.
07:26:14 <Peaker> Ezla: lots of people here make real programs. Some of us just wank :)  (I am basically experimenting/learning. Wrote some toys)
07:26:16 <sw17ch> http://code.google.com/p/scurry/source/list
07:26:17 <lambdabot> Title: Changes - scurry - Google Code
07:26:23 <Ezla> Valodim: Be tougher
07:26:30 <vixey> mornfall, not sure why you need to say that out loud
07:26:30 * quicksilver reminds everyone their client has an /ignore command if they want to use it.
07:26:38 * mlesniak thanks quicksilver 
07:26:46 <Ezla> Ignore == ignorance
07:26:55 <RayNbow> quicksilver: but /ignore is a pain in the ass to use in mIRC :p
07:26:56 <quicksilver> Ezla: there are plenty of real programs written in haskell although certainly not as much as many other languages.
07:27:30 * sw17ch contemplates what Ezla means when he asks if the project i'm actively working on is vaporware...
07:27:32 * geezusfreeek is making a game
07:27:41 <paolino> some of them on hackage
07:27:47 <RayNbow> geezusfreeek: what kind of game?
07:27:48 <ksf> you can have a look at HAppS, too.
07:28:09 <geezusfreeek> RayNbow, it will probably be some sort of spinoff of geometry wars or something
07:28:17 <RayNbow> ah
07:28:20 <geezusfreeek> still working on a shell. i start on core game on dec 2
07:28:25 <geezusfreeek> part of a competition
07:28:26 <Peaker> Ezla: I think Haskell is attempting to be both a practical language and a research language.. It doesn't focus on increasing its adoption, it jokes about avoiding adoption, because it inhibits change
07:28:36 <RayNbow> geezusfreeek: I expect a reddit submission when it's playable ;)
07:28:45 <geezusfreeek> RayNbow, i fully plan to do so
07:28:50 <ToRA|MSR> geezusfreeek: want to be careful about doing that...the last person who made a (really good) geometry wars clone got politely asked to c&d
07:29:01 <Ezla> what's the most popular haskell gfx lib?
07:29:11 <Peaker> Ezla: there are many new directions in the FP world showing lots of promise, see: http://www.haskell.org/haskellwiki/Phooey
07:29:12 <sw17ch> we have good OpenGL bindings
07:29:12 <lambdabot> Title: Phooey - HaskellWiki
07:29:15 <geezusfreeek> ToRA|MSR, this is more _inspired_ by GW than it is a clone
07:29:19 <sw17ch> Also good SDL bindings
07:29:24 <sw17ch> and a few fun drawing packages
07:29:28 <ToRA|MSR> geezusfreeek: then you're probably safe...probably ;)
07:29:28 <Ezla> SDL is really slow
07:29:34 <Peaker> Ezla: http://www.haskell.org/haskellwiki/FieldTrip is a very nice (experimental) graphics library
07:29:36 <lambdabot> Title: FieldTrip - HaskellWiki
07:29:38 <Ezla> SFML is the replacement for SDL
07:29:47 <Ezla> in pure GL
07:29:49 * sw17ch is convinced he's a troll
07:29:53 <vixey> 'slow' isn't why SDL is awful
07:29:53 <geezusfreeek> SFML? i have never heard of this
07:29:54 <Peaker> Ezla: how does SFML differ from SDL?  Also, you can use SDL + GL
07:30:02 <Peaker> vixey: why is SDL awful?
07:30:02 <Ezla> SDL is C
07:30:05 <Ezla> SFML is C++
07:30:11 <mornfall> ToRA|MSR: Wouldn't xpilot pose valid prior art?
07:30:12 <vixey> it's just ugly and gross
07:30:14 <sw17ch> Ezla: that's hardly an argument for why it's faster
07:30:16 <Ezla> http://www.sfml-dev.org/forum/viewtopic.php?t=43
07:30:19 <Peaker> Ezla: no, in terms of why its slow?
07:30:19 <Ezla> read benchmarks.
07:30:21 <geezusfreeek> Ezla, this is haskell. we don't care about C/C++ :P
07:30:26 <quicksilver> it always amuses me that commercial software companies write C&D letters to free clones
07:30:32 <quicksilver> but they don't write them too each other
07:30:33 * sw17ch cares about C a little bit
07:30:33 <Ezla> SFML is bound to various languages
07:30:37 <Ezla> including D.
07:30:42 <quicksilver> and 99% of commercial games are obviously based on other commercial games.
07:30:46 <Ezla> and C ;)
07:30:50 <matthew-_> which is relvant how?
07:31:09 <Ezla> because SFML is the new coming of SDL
07:31:14 <Ezla> SDL is obsolete
07:31:22 <Japsu> Ezla: quite bold claims
07:31:23 * geezusfreeek has had no trouble with the SDL bindings so far
07:31:32 <geezusfreeek> why is SDL obsolete? it is still actively worked on
07:31:35 <Ezla> Japsu: the benchmarks speak for themselves
07:31:39 <quicksilver> the thing about a library like SDL is it has limited goals
07:31:43 <Japsu> Ezla: that does not make SDL obsolete
07:31:43 <quicksilver> and it meets them very well.
07:31:44 <geezusfreeek> Ezla, what benchmarks?
07:31:49 <Ezla> http://www.sfml-dev.org/forum/viewtopic.php?t=43
07:31:50 <Japsu> SDL is not obsolete as long as people are using it
07:31:52 <mornfall> Benchmarks. Heh.
07:31:53 <matthew-_> yes, benchmarks, they are *always* the start and end of every story
07:32:10 <Ezla> mattew-_: Except when SFML iis "9233%" faster ;)
07:32:13 <matthew-_> Japsu: sadly, the same thing can be said about Windows ;)
07:32:14 <ksf> it's quite easy to be faster than sdl at rotating sprites if you're using gl.
07:32:16 <Ezla> that's a little bit of a story
07:32:20 <Japsu> matthew-_: my thoughts exactly
07:32:31 <quicksilver> all openGL programms use SDL for is a crossplatform way to set video mode, load truetype fonts, load images, and read keys/mice
07:32:34 <ToRA|MSR> mornfall: doesn't look like geometry wars to me; i was more thinking of a perfect clone, ala grid wars
07:32:40 <Ezla> quicksilver: SFML does all that
07:32:43 <Ezla> with a better API too
07:32:47 <quicksilver> Ezla: who cares?
07:32:47 * sw17ch can't find SFML's api header file in the repository
07:32:48 <geezusfreeek> Ezla, ah, those benchmarks are impressive, but do any of them actually test anything relevant to an opengl developer?
07:32:49 <Ezla> it is superior in all ways ;)
07:32:50 <quicksilver> the SDL API works.
07:32:52 <Peaker> Ezla: its not a better API if it needs to link with C++
07:32:56 <quicksilver> so why would anyone learn a new one?
07:32:58 <Ezla> Again, SDL is old-hat
07:33:03 <mornfall> ToRA|MSR: Dunno, I just skimmed the homepage.
07:33:06 <Peaker> Ezla: SDL is a far better API for Haskellers than a C++ api
07:33:06 <Ezla> I'd only maintain legacy SDL code
07:33:07 <quicksilver> there's nothing *wrong* with SDL though, for these simple purposes.
07:33:10 <Ezla> not make something new with that
07:33:21 <sw17ch> hmm... SFML seems to have not been adopted by *anyone* yet
07:33:23 <sw17ch> :)
07:33:27 <sw17ch> (at least packaging distros)
07:33:28 <Ezla> sw17ch: check forums
07:33:29 * geezusfreeek seriously considers /ignore
07:33:31 <matthew-_> ahh, vapourware?
07:33:39 <Valodim> SFML sounds like complete vapo... yeah, that
07:33:41 <sw17ch> matthew-_: that's kinda waht i'm thinking
07:33:43 <Valodim> haha
07:33:46 <quicksilver> Ezla: those benchmarks are all using SDL for display.
07:33:46 <paolino> ignore is not in pidgin
07:33:47 <Ezla> no, it't not vapor.
07:33:50 <sw17ch> at least more vaporous than haskell is
07:33:56 <quicksilver> Ezla: we weren't talking about using SDL for display.
07:34:00 <Japsu> ubuntu is obsolete! go exherbo!
07:34:00 <Ezla> http://www.sfml-dev.org/download.php
07:34:01 <lambdabot> Title: SFML - Simple and Fast Multimedia Library
07:34:14 <quicksilver> openGL programmers use openGL for display, and SDL for the things I mentioned above.
07:34:14 <Ezla> 5 language bindings
07:34:14 <geezusfreeek> Ezla, i hypothesize there are more haskell developers than sfml developers
07:34:15 <matthew-_> and without a turing-complete typesystem no doubt. Amateur hour or what?!
07:34:17 <ksf> linux is obsolete! use minix!
07:34:18 <Ezla> and missing Haskell
07:34:34 <sw17ch> Ezla: my haskell project supports nearly that many operating systems
07:35:53 <matthew-_> besides, you should know by now that Haskellers don't use projects who's name includes "ML"...
07:36:46 * sw17ch is looking for the .h file to which he can write Haskell bindings for SFML to amek the troll be quiet
07:36:46 <BeelsebobWork> lol
07:37:13 <matthew-_> sw17ch: you have *way* too much time on your hands ;)
07:37:22 <Valodim> haha, indeed
07:37:25 <Ezla> well at least
07:37:31 <Ezla> when you find a new library
07:37:33 <sw17ch> no, not really
07:37:40 <Ezla> at that to your knowledge of libs and check it
07:37:42 <sw17ch> i just figure that it can't be all that hard to make a binding for :D
07:37:48 <Ezla> *add
07:38:04 <nomeata> Hi. Can someone explain why I would want a context (Class Type) in an instance declaration? (with Type being a concrete type, not a type variable)
07:38:05 <sw17ch> Ezla: what's the header file named?
07:38:10 <ksf> if it has a half-way sane design it never is.
07:38:12 <Ezla> sw17ch: depends on the language
07:38:20 <sw17ch> the C header then
07:38:28 <Ezla> in D, I use sfml.graphics.all
07:38:38 <Ezla> sw17ch: there's various headers. why not just DL it ?
07:38:43 <Saiz> nomeata: is that even allowed?
07:38:43 <matthew-_> sw17ch: depends on whether you decide to enforce all the non-statically checked invariants of the lib in the Haskell type system...
07:38:58 <sw17ch> Ezla: i'm looking at the SVN repo...
07:39:02 <Peaker> nomeata: contexts are only relevant to type variables, indeed. Where do you see a context on a type without variables?
07:39:06 <fasta> Ezla: you sound like a hardcore Windows user. How can I list all the symbols in a Windows DLL?
07:39:13 <sw17ch> matthew-_: yes, i'm aware
07:39:22 <nomeata> Peaker: in code created by HAppS’ Template Haskell
07:39:23 <geezusfreeek> fasta, that was mean ;)
07:39:39 <matthew-_> you mean nm -g foo.dll won't work?
07:39:44 <nomeata> It was even triggering a compiler bug in 6.8.2 http://hackage.haskell.org/trac/ghc/ticket/2830 (but not in later versions)
07:39:45 <lambdabot> Title: #2830 (undefined reference to `base_DataziTuple_Z63T_con_info' when using instan ...
07:39:55 <Peaker> nomeata: I do believe you can use a context on a parametrized type, e.g:  instance Monoid (Maybe a) => Monoid (MyType (Maybe a)) where ...  but I am not sure
07:40:10 * sw17ch runs away from the gobs and gobs of headers in the SFML project...
07:40:14 <matthew-_> Peaker: yes, you can do that
07:40:18 <fasta> matthew-_: where do I get this nm program you speak of? I have it on *nix, but Cygwin is not really cooperative.
07:40:19 <Ezla> Fasta: PE Explorer, depends.exe, dumpbin, undname, peviewer
07:40:19 <loop> hmm, I don't really get the scope of SFML. "access to graphics, input, audio, etc.", and then it has functionality for using FTP and HTTP?
07:40:33 <fasta> Ezla: thank you
07:40:45 <nomeata> Peaker: Yes, and that makes sense to me :-). But I’m wondering if it might have any bad effect to remove the context for concrete types
07:40:50 <geezusfreeek> loop, i believe the idea is to provide a complete solution for making game shells
07:40:53 <nomeata> (it has the good effect of not triggering the ghc bug)
07:41:11 <geezusfreeek> networking being very useful
07:41:12 <sw17ch> Actually, it doesn't look too hard to write bindings for
07:41:15 <matthew-_> nomeata: the type var can't be in scope anywhere else, so removing it will not make any difference
07:41:24 <matthew-_> fasta: err, I was joking. I have never done development under windows...
07:41:29 <geezusfreeek> sw17ch, does it look worth it? i haven't looked yet
07:41:29 <sw17ch> the functions are fairly transparent... and have good typing already
07:41:32 <Ezla> Fasta:
07:41:33 <Ezla> http://www.magma.ca/~wjr/
07:41:34 <lambdabot> Title: WJR's PEview(PE/COFF File Viewer), xlatHinc, M(Mandelbrot Set), Awpm
07:41:34 <sw17ch> geezusfreeek: oh, i ahve no idea
07:41:35 <Peaker> nomeata: that's really weird indeed, not sure why you'd want to specify a context on an actual type like that. Perhaps to be robust to whether someone imported an instance or not
07:41:42 <sw17ch> I'll ask my GFX buddy over here if he's touched it at all
07:41:48 <sw17ch> if he likes it, then i'll see about writing a binding
07:42:05 * sw17ch needs to hone his FFI-foo before taking on GCrypt
07:42:20 <Ezla> anyways how'd you know I use windoze
07:42:30 <matthew-_> angst levels
07:42:31 <Ezla> I *love* windows
07:42:38 <Ezla> its like jesus
07:43:01 <fasta> geezusfreeek: I was right :)
07:43:07 <matthew-_> in that it misses out apostrophes?
07:43:36 <geezusfreeek> fasta, and that's just sad
07:43:47 <idnar> @src subtract
07:43:48 <lambdabot> subtract x y = y - x
07:44:45 <paolino> > map (subtract 3) [3 ..]
07:44:47 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
07:45:04 <sw17ch> Has any one in here used libgcrypt before? (while i'm thinking about it)
07:45:12 <ksf> > map (-3) [3..]
07:45:13 <lambdabot>       No instance for (Num (a -> b))
07:45:13 <lambdabot>        arising from a use of `negate' at...
07:45:26 <matthew-_> -3 interepreted as negative 3
07:45:31 <ksf> grmbl
07:45:36 <ksf> yeah i know.
07:45:38 <idnar> > (+) *** (-) $ (1,2)
07:45:39 <lambdabot>       Overlapping instances for Show (b' -> b')
07:45:39 <lambdabot>        arising from a use of ...
07:45:53 <ksf> wanna spend a few screens discussing h' proposals about it?
07:45:54 <idnar> @type (+) *** (-)
07:45:55 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
07:46:17 <idnar> @type (5 +) *** (5 -)
07:46:18 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1) -> (t, t1)
07:46:19 <ksf> > map (3-) [3..]
07:46:20 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
07:46:23 <Ezla> When will there be a new Haskell spec?
07:46:25 <idnar> > (5 +) *** (5 -) $ (1,2)
07:46:26 <lambdabot>   (6,3)
07:46:38 <ksf> when it's done.
07:46:42 <paolino> @version
07:46:42 <lambdabot> lambdabot 4.2.2
07:46:42 <lambdabot> darcs get http://code.haskell.org/lambdabot
07:46:50 <Ezla> what will new-haskell improve?
07:46:55 <fasta> Ezla: PEView doesn't have output similar to nm.
07:47:11 <Ezla> fasta: what format do you want
07:47:13 <vixey> Ezla, some people write Haskell'
07:47:23 <matthew-_> not a great deal afaict, but it will standardise a lot of the extensions that are already in ghc. I think
07:47:25 <ksf> http://hackage.haskell.org/trac/haskell-prime/wiki/Status
07:47:26 <vixey> Ezla, I'm not totally keen on it but there's something to look up if you're interested
07:47:28 <ksf> see for yourself.
07:47:29 <lambdabot> Title: Status - Haskell Prime - Trac
07:47:33 <fasta> Ezla: just a list of symbols (like I expect the Haskell RTS
07:47:34 <Peaker> @type join (***)
07:47:35 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:47:45 <fasta> Ezla: just a list of symbols (like I expect the GHC RTS) to be in them.
07:47:49 <vixey> "If Haskell 98 was good enough for Jesus, it's good enough for me" :D
07:48:06 * sw17ch wants typed memory regions
07:48:19 <sw17ch> even if Jesus doesn't
07:48:20 <matthew-_> sw17ch: shape analysis?
07:48:35 <sw17ch> matthew-_: frame buffers
07:48:35 <sw17ch> :)
07:48:41 <sw17ch> among other things
07:48:45 <sw17ch> Avionics
07:48:50 <Peaker> > let onBoth = join (***) in onBoth ($5) ((+) *** (-) $ (1,2))
07:48:51 <lambdabot>   (6,-3)
07:48:58 <Ezla> fasta: dumpbin
07:49:02 <Ezla> and/or undname
07:49:03 <matthew-_> sw17ch: url? I know not these things of which you speak
07:49:13 <fasta> Ezla: and where does it dump its output?
07:49:18 <Ezla> console
07:49:25 <fasta> Ezla: it returned nothing here.
07:49:41 <fasta> Ezla: but I could call a function from the library.
07:49:44 <matthew-_> also, don't forget that as the type system is turing complete, you can effectively extend it in place as you wish
07:49:44 <sw17ch> matthew-_: i'm looking for the paper... it's been a while since i read it
07:49:48 <sw17ch> i think some one in here wrote it
07:49:54 <sw17ch> don or duncan
07:49:57 <sw17ch> (maybe?)
07:50:21 <Ezla> vixey: look up where?
07:50:25 <dcoutts> sw17ch: what paper?
07:50:34 <Ezla> is Haskell 98 really that problem free?
07:50:38 <Ezla> 98 is a long time ago.
07:50:41 <sw17ch> dcoutts: i'm not sure if it was you, but it was a paper on strongly typed memory regions
07:50:50 <sw17ch> the example used was for a console buffer
07:50:53 <vixey> Ezla, I don't use H98
07:50:58 <Ezla> fine, 03
07:51:18 <dcoutts> sw17ch: not me, but perhaps you're thinking of DCC or related
07:51:44 <sw17ch> perhaps, i'll go look
07:52:09 <fasta> Ezla: also, all these tools need to be downloaded from random persons.
07:52:21 <fasta> Ezla: if that makes you love Windows...
07:52:27 <Ezla> will haskell ever have first class types?
07:52:58 <sw17ch> Ezla: first class object?
07:53:05 <Ezla> types as values
07:53:10 <sw17ch> ah
07:53:11 <ksf> Ezla, as in a -> a ?
07:53:14 <earthy> ezla: that's called agda
07:53:17 <Ezla> yeah
07:53:19 <Ezla> Agda?
07:53:30 <earthy> (or any old dependent type system, for that matter)
07:53:37 <vixey> Ezla, dependent types in general -- it's distinctly -different- from Haskell
07:54:01 <Ezla> so types in haskell are still 100% static
07:54:16 <vixey> Ezla, so they are in o dependently typed setting
07:54:26 <Ezla> ?
07:54:39 <ksf> you can do all the dynamic typing you want, but you don't need to as inference makes static typing painless.
07:54:50 <vixey> Ezla, if you have types flying around at runtime they aren't types anymore just data
07:54:56 <Peaker> Ezla: Haskell has existential types, which are like OO in that you only know the exact types at runtime
07:55:02 <kynky> duck typing
07:55:13 * sw17ch dislikes ducks in his types...
07:55:17 <kynky> asd opposed tostrict typing
07:55:34 <ertai> Does someone know if "Optimistic Evaluation: a fast evaluation strategy for non-strict programs" is still implemented in the current GHC ?
07:55:37 <fasta> Ezla: ok, this Dependency Walker program works.
07:55:38 <kynky> ruby likes ducks
07:55:44 <fasta> Ezla: thanks
07:55:45 <Peaker> Ezla: but generally "types" are about compile-time/static reasoning about the behavior of programs
07:56:12 <Ezla> well, the type system can be "one way" in terms of runtime abilty: you can pass around type values which represent static types, and contain functions to retrieve those types from a common interface(factory idiom)
07:56:20 <Ezla> and which hold various other useful infos about the types
07:56:28 <Peaker> I see duck-typing as basically using type-classes without specifying them
07:56:35 <Ezla> some call it "Typeid"
07:56:40 <paolino> Peaker: are those existentials ever decided ?
07:56:45 <ksf> but it's a value then, not a type value.
07:56:50 <Peaker> paolino: at runtime, yeah
07:56:56 <ksf> although it's a typed value, of course.
07:56:56 <Ezla> yeah, a value describing a type
07:57:20 <Peaker> @hoogle TypeRep
07:57:20 <lambdabot> Data.Typeable data TypeRep
07:57:20 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
07:57:20 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
07:57:23 <Saiz> ertai: iirc, it never got merged in the main trunk
07:57:25 <kynky> ducktyping has more chance of run type errors, ruby gets round this wiith method_missing
07:57:40 <paolino> Peaker: I thought they were closed in a function at compile time .....
07:57:41 <Peaker> Ezla: a TypeRep value is a runtime value describing a type
07:57:47 <Peaker> paolino: they can be
07:58:06 <Ezla> what things can you "do" with a TypeRep (is it DUMB, as in its only usable as a hash, etc?)
07:58:06 <Peaker> paolino: data Obj = forall a. Obj a  -- You can choose at run-time which "a" to use here
07:58:20 <ksf> Ezla, in some way you can regard data constructors themselves as typeid.
07:58:52 <paolino> Peaker , what can I do with it ?
07:59:11 <matthew-_> paolino: apply id to it
07:59:37 <Peaker> paolino: nothing, because it has no class restrictions :)
07:59:46 <paolino> uhm, existentials are beyond my specs I suppose
07:59:47 <yuuki> Does anyone know how to prove that 2 = succ(1) in a typed lambda calulus, given that the type of 2 and the type of 1 are the same?
07:59:52 <Peaker> paolino: data Obj = forall a. Num a => Obj a -- is more interesting
08:00:06 <Peaker> paolino: you can use Num methods on the "a" type
08:00:10 <vixey> yuuki, do you have definitions of 1 and 2?
08:00:17 <Ezla> what are the biggest problems and limitations in Haskell?
08:00:27 <paolino> but do nothing with Obj
08:00:49 <Ezla> or is it "perfect"
08:01:00 <ksf> the learning curve?
08:01:06 <yuuki> Well, I'm using 0 = False (a -> b -> b) and Succ = \ n f x -> f ( n f x )
08:01:06 <Ezla> besides that.
08:01:11 <vixey> yuuki, just reflexivity should be the proof, because the terms 2 and succ(1) are alpha-beta-convertable
08:01:12 <matthew-_> ksf: I dunno, I think in some ways that's helpful
08:01:12 <Ezla> pure language problems
08:01:19 <Ezla> like oversights
08:01:28 <ksf> (-n)
08:01:31 <Ezla> that cannot be worked around, or upset the programmer
08:01:31 <matthew-_> there are very very few warts in the language
08:01:33 <ksf> unary minus.
08:01:33 <Peaker> Ezla: IMO: Compiler errors are very hard to read. The naming in the stdlib are pretty bad. It misses typeclass aliases or other such mechanism so its typeclass-hierarchies are not quite right, and can't be fixed.  Monad Transformers are pretty clunky to define..
08:01:38 <Ezla> ksf: what's (-n) ?
08:01:39 <sw17ch> ksf++
08:01:41 <yuuki> vixey, so there isn't a way to prove it using types?
08:01:49 <vixey> Ezla, fromIntegral
08:01:50 <sw17ch> urnary minus makes me cry :(
08:01:52 <ksf> > map (+1) [1..]
08:01:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
08:01:56 <vixey> yuuki, that is it
08:01:59 <ksf> >map (-1) [1..]
08:02:03 <lilac> Ezla: superclassing in instance declarations creates instance overlaps which some people would prefer didn't overlap
08:02:07 <Ezla> what's wrong with unary minus?
08:02:10 <ksf> > map (-1) [1..]
08:02:11 <vixey> yuuki, what's your definition of (=)?
08:02:11 <lambdabot>       No instance for (Num (a -> b))
08:02:11 <lambdabot>        arising from a use of `negate' at...
08:02:15 <ksf> see the difference?
08:02:20 <Vq^> > map (subtract 1) [1..]
08:02:22 <nomeata> > map (subtract 1) [1..]
08:02:22 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:02:23 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:02:23 <Ezla> lilac: can you workaround that?
08:02:48 <Peaker> Ezla: (-1) is ambiguous in Haskell, because (infixop arg) generally means a "section", which is a partial application of that operator to its right-hand argument, so is (-1) actually a function that subtracts one, or minus-1?
08:02:56 <ksf> n+k patters, but that's gonna be fixed in h'.
08:02:58 <yuuki> vixey, good question.  I guess I was hoping that (=) would be "having the same type"
08:03:03 <lilac> Ezla: the language is turing-complete, so yes. but it might not be as pleasant. also there are GHC extensions which let you get closer to what you want
08:03:04 <Ezla> Peaker: lol!
08:03:11 <Ezla> so how do you represent -1 in haskell?
08:03:12 <yuuki> vixey, and that 0, 1, 2, ... would all have different types
08:03:21 <Peaker> Ezla: (-1) is the normal minus-1 number
08:03:27 <Peaker> Ezla: if you want a (-1) section, you use (subtract 1) instead
08:03:30 <lilac> Ezla: basically, (-) is the only exception to an otherwise nice rule in haskell's syntax
08:03:33 <Peaker> Ezla: or you can use (+(-1))
08:03:41 <Peaker> Ezla: its an ugly "corner" of Haskell's syntax
08:03:50 <Ezla> will it be fixed?
08:03:57 <Ezla> or is haskell Set In Stone
08:04:06 <nomeata> Ezla: how? By distinguishing - and − ?
08:04:07 <Ezla> I ask about this stuff, cause, this is why I like D a lot
08:04:07 <sw17ch> it's more like jello
08:04:11 <Ezla> D isnt set in stone
08:04:20 <Ezla> (like python)
08:04:20 <nomeata> (−1) :: Num a => a -> a
08:04:24 <nomeata> (-1) :: Num a => a
08:04:28 <flux> ezla, do you expect to be able to compile your current D code in 5 years?
08:04:34 <Peaker> Ezla: I hope that a future Haskell editor will be editing abstract syntax rather than text, so that will resolve the issue :) But in a textual syntax, its not likely there's a nice fix
08:04:43 <Ezla> flux: No. Because there was a major change in D1 to D2
08:04:52 <Ezla> and D2 is coming soon
08:04:54 <paolino> Peaker: it's us we use one operator for two functions
08:05:13 <Ezla> granted, it would not take much effort to fixup
08:05:18 <Ezla> but they don't hold on to mistakes
08:05:23 <Ezla> they get rid of mistakes.
08:05:24 <nomeata> Peaker: are there any editors out there (not necessary haskell) that do that?
08:05:25 <Peaker> paolino: yeah, ascii text has only so many characters. And full unicode does not map to the keyboard keys so nicely anymore
08:05:41 <ksf> ezla, see removal of the monomorphism restriction in h'.
08:05:50 <Peaker> nomeata: Yeah, but IMO pretty poorly (they still demonstrate it can be done): Subtext, and Eros.   An early prototype editor for C that me and friends wrote also exists
08:06:09 <Ezla> Why can't (-1) be fixed?
08:06:10 <yuuki> vixey, I'm wondering if the simply typed lambda calculus is just not expressive enough to deal with numbers in the way I wanted to deal with them
08:06:11 <ksf> most of the proposed h' stuff is already done, but not standardized in stone so not all haskell compilers support it.
08:06:42 <Peaker> Ezla: how would you differentiate unary (-) from binary infix (-) ?
08:06:47 <ksf> Ezla, the other possibility would be to write (0-1) if you mean -1.
08:06:47 <vixey> yuuki, if you want to do anything non-trivial then STLC is probably useless
08:06:53 <lilac> Ezla: (-1) can't mean both negative one and subtract one
08:06:59 <vixey> prove*=
08:07:05 <lilac> Ezla: so in that sense there is no "fix".
08:07:21 <lilac> Ezla: but removing - as a unary operator is one possibility
08:07:23 <ksf> otoh, haskell could switch to lisp syntax.
08:07:26 <sw17ch> It's an example of the limitations people have getting in the way of computers.
08:07:44 <Ezla> (--1)  unary ?
08:07:50 <yuuki> vixey, yeah :)  I'm building a proof-checker/theorem prover, and I figured I would start simple and only add complexity as needed.  Now seems like a good time to add more interesting types :)
08:07:51 <Peaker> Ezla: to differentiate, either another symbol (e.g unicode) ought to be used, or unary - can be killed, or sections can be killed (unlikely)
08:08:14 <Ezla> lol, unicode language
08:08:15 <ksf> @let (--) = (0-)
08:08:15 <lambdabot>   Parse error
08:08:20 <Ezla> seen Fortress ?
08:08:20 <vixey> yuuki, do you know a little bit of Prolog?
08:08:23 <ksf> hmmmmm
08:08:33 <ksf> nope. won't work, as -- is the start of a comment.
08:08:35 <yuuki> vixey, not really.  I've just seen it a couple times
08:08:41 <ksf> @let (---) = (0-)
08:08:41 <lambdabot>   Parse error
08:08:50 <vixey> @let (
08:08:51 <lambdabot>   Parse error
08:08:54 <Ezla> http://research.sun.com/projects/plrg/fortress.pdf
08:08:54 <ksf> @let (--) x = (0-x)
08:08:54 <lambdabot>   Parse error
08:08:56 <lambdabot> Title: The Fortress Language Specification
08:08:58 <paolino> > let (---) = (0-) in (--- 1)
08:08:58 <ksf> @let (---) x = (0-x)
08:08:59 <lambdabot>   Parse error
08:08:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:09:15 <flux> (ocaml has ~- as the unary -)
08:09:18 <Peaker> can you define unary prefix operators in Haskell at all?
08:09:27 <vixey> Oz use ~ too
08:09:28 <lilac> @let (-~) = (0-) in -~1
08:09:28 <lambdabot>   Parse error
08:09:42 <Peaker> > let x = (0-) in x 5
08:09:44 <lambdabot>   -5
08:09:47 <lilac> Peaker: they're called "functions" :)
08:09:59 <Peaker> lilac: yeah, I meant with operator symbols :)
08:10:08 <lilac> Peaker: in brackets, yes :)
08:10:30 <Ezla> (-:)
08:10:32 <Peaker> We can use: minus 5 for unary -5
08:10:35 <lilac> although only if they return functions, perhaps
08:10:46 <RayNbow> > negate 5
08:10:48 <lambdabot>   -5
08:10:49 <vixey> yuuki, how does it work? :)
08:10:50 <lilac> > negate 5
08:10:52 <lambdabot>   -5
08:11:02 <Ezla> > negate (-5)
08:11:04 <lambdabot>   5
08:11:05 <Peaker> so killed unary -, we have negate :-)
08:11:14 <Ezla> > negate (-0)
08:11:15 <lambdabot>   0
08:11:25 <yuuki> vixey, how does prolog work?
08:11:38 <yuuki> vixey, is that what you are asking?
08:11:38 <vixey> yuuki, no the thing you are writing
08:11:44 <yuuki> vixey, ahh.
08:12:24 <yuuki> vixey, basically you just define combinators based on S and K, and then the type of the combinator you define becomes a new theorem.
08:12:32 <lilac> Peaker: i believe that's one of the haskell' proposals
08:12:38 <yuuki> vixey, the combinators are never evaluated, I just use their types.
08:12:52 <ksf> > negate 0
08:12:53 <lambdabot>   0
08:12:59 <ksf> > negate 0::Float
08:13:01 <lambdabot>   -0.0
08:13:07 <vixey> yuuki, oh cool
08:13:12 <yuuki> vixey, I know how to do arithmetic in STLC, but I'm not sure how to do it only with reference to the type
08:13:21 <vixey> yuuki, I can see how this screws up equality proofs though
08:13:45 <lilac> Peaker: http://hackage.haskell.org/trac/haskell-prime/wiki/NegativeSyntax
08:13:47 <lambdabot> Title: NegativeSyntax - Haskell Prime - Trac
08:13:49 <yuuki> vixey, well, so far I can show things like AND T F = F
08:13:50 <vixey> yuuki, you really need alpha-*beta*-conversion for equality proofs
08:14:29 <vixey> yuuki, how?
08:14:58 <Ezla> the "gentle introduction to haskell" isnt gentle enough
08:15:03 <Ezla> I have too many questioins
08:15:10 <vixey> @quote gentle
08:15:11 <lambdabot> lament says: gentle like gangrape
08:15:12 <vixey> @quote gentle
08:15:13 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
08:15:16 <vixey> @quote gentle
08:15:16 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
08:15:28 <Ezla> ll
08:15:32 <Ezla> !
08:15:37 <yuuki> Well, the type of T is a -> b -> a and the type of F is a -> b -> b... I can't remember the type of and right now, but when you apply it to T and F or T and T, etc., the type of the return value is the expected type
08:15:38 <Ezla> how do you put 2 statements on 1 line?
08:16:25 <vixey> yuuki, what about a -> a -> Pair a a which has two inhabitiants
08:16:29 <Ezla> your uses of the bot all look like single statements
08:17:00 <vixey> yuuki, oops 4
08:17:00 <Peaker> vixey: doesn't it have 3?
08:17:07 <Saiz> Ezla: the bot evaluates expressions
08:17:08 <yuuki> vixey, I guess when I construct AND, I'm only proving that the type of AND exists.  And when I get T for the type of AND T T, I'm only proving that T exists
08:17:09 <wjt> > let { x = 1; y = 2 } in x + y
08:17:11 <lambdabot>   3
08:17:21 <Ezla> Ok, how do I do this on the bot:
08:17:25 <lilac> Ezla: usually, you don't (use newlines instead). but you can separate certain elements with semicolons and group with braces
08:17:26 <Peaker> vixey: oh, right, 4
08:17:31 <yuuki> vixey, I don't have pair types now
08:17:37 <ksf> {;} lets you circumvent the layout-rules.
08:17:37 <Ezla> inc n = n + 1     inc :: Integer -> Integer
08:17:53 <lilac> > let inc :: Integer -> Integer; inc n = n + 1 in inc 41
08:17:55 <lambdabot>   42
08:17:58 <vixey> yuuki, just as an example I meant, presumably you can make pairs using S and K
08:18:10 <Ezla> what the hell?
08:18:10 <Peaker> Ezla: incidentally, inc = (+1)
08:18:16 <quicksilver> Ezla: generally haskell doesn't have "statements"; although that word is sometime used for the individual expressions in a "do" block.
08:18:26 <Peaker> > let inc = (+1) in inc 41
08:18:27 <lambdabot>   42
08:18:28 <Ezla> why did you get an output from inc n = n + 1 in inc 41 if you didn't even "use" that function?
08:18:47 <Peaker> Ezla: let DEFINITIONS in EXPRESSION   evaluates expression and shows its result
08:18:50 <lilac> Ezla: let <block> in <expr>
08:18:52 <quicksilver> Ezla: rather haskell has "expressions" (which evaluate to a value) and "definitions" (which just define stuff)
08:18:54 <yuuki> vixey, Hmm.  I'm not sure
08:18:59 <Peaker> Ezla: when used as > let ... in ...   that is
08:19:10 <ksf> > let inc = succ in inc 41
08:19:11 <yuuki> vixey, I think my mind is still not wrapping around the Curry-Howard correspondence very well
08:19:12 <lambdabot>   42
08:19:16 <vixey> @pl cons = \x y s -> s x y
08:19:17 <Peaker> @type (+1)
08:19:17 <lambdabot> forall a. (Num a) => a -> a
08:19:18 <lambdabot> cons = flip . flip id
08:19:24 <lilac> > let foo = undefined in 1 + 1
08:19:26 <lambdabot>   2
08:19:38 <Peaker> Ezla: note how the type inference here is deducing the most general type for (+1), which is not Integer->Integer,  but (Num a) => a->a
08:19:38 <Ezla> undefined means?
08:19:41 <vixey> yuuki, I can explain how to do equality in normal type theory if you want
08:19:47 <Peaker> @src undefined
08:19:48 <lambdabot> undefined =  error "Prelude.undefined"
08:20:08 <yuuki> vixey, that'd be great...does it involve evaluation also?
08:20:15 <ksf> > undefined
08:20:16 <lambdabot>   * Exception: Prelude.undefined
08:20:21 <Axman6> :t undefined
08:20:22 <lambdabot> forall a. a
08:20:22 <ksf> > undefined + 2
08:20:23 <Ezla> what tutorials/books did you guys do personally?
08:20:24 <lambdabot>   * Exception: Prelude.undefined
08:20:28 <Peaker> Ezla: basically its a "pure exception", an exception value.  Exceptions that you don't use anywhere don't propagate anywhere
08:20:29 <ksf> note it's different from
08:20:30 <vixey> yuuki, yeah sort of, you need to test alpha-beta-equivalence during typechecking
08:20:34 <ksf> > "undefined" + 2
08:20:35 <lambdabot>       No instance for (Num [Char])
08:20:35 <lambdabot>        arising from the literal `2' at <in...
08:20:37 <Axman6> Ezla: Uni, and #haskell ;)
08:20:53 <Ezla> #haskell, the "just show up" book?
08:20:54 <lilac> Ezla: #haskell and reading bits of the Report
08:20:58 <grul> > let me="the hell" in "damn it"
08:20:59 <lambdabot>   "damn it"
08:21:01 <Peaker> Ezla: I read Gentle Haskell Intro and YAHT. I preferred YAHT, but I didn't like either very much
08:21:09 <vixey> yuuki, so some preliminary definitions, data N where Z :: N; S :: N -> N, succ x = S x
08:21:39 <Ezla> will check yaht, thanks
08:21:39 <Peaker> Ezla: I think   LearnYouAHaskell.com  is cool.  My friends liked the beginning that they read (not sure if they continued on)
08:21:49 <Peaker> (Its a new tutorial by BONUS)
08:21:51 <ksf> i'd recommend rwh.
08:21:53 <yuuki> vixey, ok
08:21:55 <Axman6> me too
08:21:56 <vixey> yuuki, and data (=) :: * -> * -> * where Reflexivity :: forall x, x = x
08:22:18 <Ezla> > 1 && "foo"
08:22:19 <ksf> not really a tutorial, but if you can already code you'll keep up with the pace.
08:22:19 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Char]'
08:22:23 <vixey> yuuki, so Reflexivity Z is of type Z = Z, and Reflexivity (S (S Z)) has type S (S Z) = S (S Z)
08:22:30 <Ezla> why doesnt that work?
08:22:38 <Ezla> > 1 && 999
08:22:38 <Peaker> Ezla: because of the type of (&&)
08:22:39 <lambdabot>       No instance for (Num Bool)
08:22:39 <lambdabot>        arising from the literal `1' at <inte...
08:22:45 <Peaker> @type (&&)
08:22:46 <Ezla> Num bool !!?
08:22:46 <lambdabot> Bool -> Bool -> Bool
08:22:46 <ksf> :t (&&)
08:22:47 <lambdabot> Bool -> Bool -> Bool
08:22:55 <vixey> yuuki, since S (S Z) = succ (S Z) is alpha-beta-equal to S (S Z) = S (S Z), you can use Reflexivity (S (S Z)) as a proof of that too
08:22:59 <Ezla> > 1 and 999
08:23:00 <lambdabot>       No instance for (Num (([Bool] -> Bool) -> t -> a))
08:23:00 <lambdabot>        arising from ...
08:23:02 <yuuki> vixey, is x a term and not a type?
08:23:07 <Peaker> Ezla: Numbers aren't booleans
08:23:13 <vixey> yuuki, i.e.   |- Reflexivity :: S (S Z) = succ (S Z)
08:23:14 <Ezla> how do I get it to return 999 ?
08:23:21 <lilac> Ezla: haskell doesn't do implicit conversions
08:23:32 <ksf> > if True then 1 else 999
08:23:34 <lambdabot>   1
08:23:39 <ksf> > if False then 1 else 999
08:23:41 <lambdabot>   999
08:23:49 <Ezla> Ok, well, in javascript for instance, 1 && "foo" is an idiom
08:23:53 <Ezla> there has to be a simple way to do that
08:23:55 <Axman6> Ezla: unlike C, True and False are distinct types, not represented by numbers
08:24:04 <vixey> yuuki, x could be either actually, you could add a parameter A to the definition and use (x : A) (where A is a sort, kind or a type)
08:24:16 <Ezla> ksf: how do you do it without if Then else
08:24:21 <vixey> yuuki, in my example we have x : N
08:24:25 <Ezla> If then else, suxor.
08:24:31 <yuuki> vixey, interesting... this is called dependent types, correct?
08:24:35 <vixey> yuuki, yeah
08:24:43 <ksf> what's 1&& "foo" meant to do anyway?
08:24:44 <Saiz> what does 1 && "foo" do?
08:24:47 <vixey> yuuki, (This is exactly the same principle you get in Prolog which is why I asked about that earlier)
08:24:51 <ksf> why not just write "foo"?
08:24:53 <yuuki> vixey, I should learn about those next.
08:24:56 <Ezla> 1 && "foo" => "foo"
08:25:03 <Axman6> Ezla: && works on booleans right?
08:25:07 <Ezla> 555 || "bar" => 555
08:25:09 <yuuki> vixey, what do you mean by alpha-beta equivalence?
08:25:10 <Peaker> > let cppAnd f x y = if not (f x) then f x else f y ; numAnd = cppAnd (>0)   in  numAnd 1 999
08:25:13 <lambdabot>   True
08:25:18 <Peaker> > let cppAnd f x y = if not (f x) then x else y ; numAnd = cppAnd (>0)   in  numAnd 1 999
08:25:19 <Twey> Ezla: You can write one
08:25:19 <quicksilver> Ezla: because haskell expressions don't have side-effects, such tricks are fairly meaningless
08:25:20 <Axman6> since when was 1 a boolean value?
08:25:20 <lambdabot>   999
08:25:25 <pizza_> @type (&&)
08:25:26 <lambdabot> Bool -> Bool -> Bool
08:25:28 <Peaker> Ezla: ^^ numAnd is what you wanted
08:25:29 <Twey> But it's not very useful.
08:25:38 <Peaker> Ezla: indeed its not very useful :-)
08:25:42 <Ezla> quicksilver: which side effect?
08:25:44 <Ezla> I saw none.
08:25:50 <Twey> That's the point
08:25:53 <vixey> yuuki, \x -> x is alpha equivalent to \y -> y, and \x y -> y is alpha-beta equivalent to \u v -> (\i -> i) v
08:26:00 <quicksilver> Ezla: if evaluating "1" has no sideeffect, then why evaluate it?
08:26:03 <lilac> Ezla: the two values need to be the same type
08:26:07 <Peaker> Ezla: what do you use  a && b   for, when a and b are not booleans?
08:26:10 <quicksilver> why not just say "foo"
08:26:11 <Axman6> Ezla: with time, you'll come to see just how hacky the idea of 1 && "foo" really is
08:26:17 <Ezla> I dont want the same type
08:26:21 <quicksilver> Axman6: on the contrary, it's a great idea.
08:26:25 <lilac> Ezla: then what are you going to do with the result?
08:26:26 <Ezla> I want an Integer, and a string!
08:26:28 <quicksilver> "foo `mplus` bar"
08:26:31 <quicksilver> is the haskell idiom
08:26:36 <Ezla> lilac: store it in a Orangutan
08:26:37 <Peaker> Ezla: please explain what do you want the && expression FOR?
08:26:38 <quicksilver> which works fine, in monads with appropriate MonadPlus instances
08:26:59 <Axman6> quicksilver: you don't think that using numbers for booleans is somewhat hackish?
08:27:01 <yuuki> I see, so alpha equivalence is only important for lambda terms
08:27:04 <lilac> Ezla: then convert them to orangutans first, so they will be the same type
08:27:06 <vixey> yuuki, the definition of equality I gave reflects the alpha-beta-relation (or whatever relation the typechecker uses), into an object you can introduce or eliminate
08:27:06 <Peaker> Ezla: you want to choose between the values based on some arbitrary criterion, you can use "if", its clearer than that?
08:27:12 <yuuki> And not necessarily combinator calculus terms
08:27:28 <lilac> Ezla: how do i implement a continuation in C++?
08:27:37 <Ezla> Ok, I'm really just asking these questions to get an idea of how Haskell works
08:27:48 <vixey> yuuki, I guess you would have to use lambda terms though, it's not clear when two combinator expressions are equivalent is it?
08:27:49 <ksf> lilac, use fcc++.
08:27:57 <vixey> yuuki, i.e. they don't have a normal form (or do they?)
08:28:00 <Ezla> lilac: with boost.phoenix
08:28:10 <lilac> Ezla: programming in haskell isn't like programming in some imperative language with different syntax
08:28:12 <vixey> S K K vs S K S
08:28:12 <Ezla> http://spirit.sourceforge.net/dl_docs/phoenix-2/libs/spirit/phoenix/doc/html/index.html#phoenix.preface
08:28:14 <lambdabot> Title: Chapter�1.�Phoenix 2.0, http://tinyurl.com/6crgp
08:28:27 <ksf> I already thought about it and figured that you _have_ to use trampolined style, for refcounting reasons, as not to confuse libraries.
08:28:31 <lilac> Ezla: ok, but it's not going to be as nice as using idiomatic c++.
08:28:38 <yuuki> vixey, I'm not really sure :/
08:28:44 <Ezla> fc++ is ancient
08:28:56 <lilac> Ezla: likewise, trying to shoehorn perl-style idioms into haskell will likely not result in very nice code
08:29:00 <Ezla> nobody has used that inalongtime.
08:29:02 <ksf> fc++ does monads, what is about all i care for.
08:29:04 <yuuki> vixey, SKK and SKS have different types
08:29:06 <Ezla> ksf: Dude
08:29:10 <vixey> yuuki, but if you open the combinators up into lambda terms and reduce them -- you can check the normal forms are equal (as long as they are typed)
08:29:12 <Ezla> ksf: boost.
08:29:20 <vixey> yuuki, I thought tthey were both identity?
08:29:35 <Ezla> does FC++ still even compile?
08:29:39 <ski_> yes, but restricted to different types
08:29:49 <ksf> sure.
08:29:54 <ski_> @type ap const const
08:29:56 <lambdabot> forall a. a -> a
08:29:56 <yuuki> vixey, they are, but SKK is a -> a and SKS is (a -> b -> c) -> a -> b -> c
08:29:57 <quicksilver> Axman6: No. I don't think that using && to sequence things based on success or failure is hackish.
08:29:57 <ski_> @type ap const ap
08:29:58 <Ezla> ksf: In the C++ world, we don't use fc++
08:29:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
08:30:01 <vixey> oh cool
08:30:02 <ksf> i've looked at them all, and only fc++ does what i want.
08:30:03 <vixey> ok
08:30:04 <Ezla> boost is standard
08:30:11 <Axman6> i'd rather have something slightly slower if i could avoid having to use something as ugly as C++ tbh
08:30:11 <vixey> I guess that's not a good example then
08:30:11 <quicksilver> Axman6: it's a common and useful idiom in C, Perl, and Shell.
08:30:18 <vixey> I didn't know thata
08:30:39 <quicksilver> conal: I have a combinator problem you might recognise / or might be interested in
08:30:46 <vixey> quicksilver, hehe... that makes it not hackish :p
08:30:48 <Ezla> Phoenix has monads up the woo
08:30:55 <Ezla> gotta run, l8r
08:31:17 <quicksilver> vixey: well, not per se, no. What makes it hackish is the fact I have stated it is not. ;)
08:31:21 <quicksilver> +not
08:31:26 <Axman6> conal: but what if you want to test in some other way? say make 1 false, and 17 true? then x && res doesn't make as much sense
08:31:47 <yuuki> vixey, I'm not sure really what a normal form would mean for combinators
08:31:48 * vixey wants to @remember ..
08:31:52 <quicksilver> Axman6: then you do "wasitok(1) && blah"
08:32:01 <quicksilver> Axman6: where 'wasitok' is your custom definition of 'okness'.
08:32:25 <quicksilver> but shell commands have standard exit codes, success is a standard value.
08:32:26 <vixey> @remember quicksilver No. I don't think that [omitted] is hackish. It's a common and useful idiom in C, Perl, and Shell.
08:32:27 <lambdabot> It is forever etched in my memory.
08:32:28 <Axman6> meh, doesn't matter, i find it very hackish. guess i was taught by someone who saw that languages should be logical and person oriented, not machine oriented
08:32:39 <Twey> Hahaha
08:32:42 * vixey hides
08:32:53 <quicksilver> Axman6: yes, batter me with your rhetorical non-sequitur.
08:32:58 <ski_> (Axman6 : how about "object ..." ?)
08:33:12 <quicksilver> Axman6: try this, and if it fails, try this, is perfectly logical and person oriented.
08:33:15 <Axman6> quicksilver: that's fine, but it doesn;t have to be that way. just because that's the way its been doesn't mean its the most logical way
08:33:18 <vixey> I agree it's not really a hack though, it's quite sensible
08:33:26 <ksf> ezla, http://www.google.de/search?q=site%3Aspirit.sourceforge.net+monad
08:33:31 <lambdabot> Title: site:spirit.sourceforge.net monad - Google-Suche
08:33:34 <ksf> doesn't return a thing.
08:33:52 <quicksilver> vixey: and indeed, haskell has `mplus` (sometimes called `orElse`) for this purpose.
08:33:58 <quicksilver> with better type-checking, as you'd hope ;)
08:34:26 <quicksilver> I quite often us mplus in the Maybe and IO monads and their friends.
08:34:33 <Axman6> quicksilver: i wasn;t taking a stab at you. the comp lecturer that taught me haskell was very clear about how things like boolean expressions should use boolean values.
08:34:42 <quicksilver> Sure.
08:34:47 <quicksilver> && isn't a boolean expression, then
08:34:50 <quicksilver> in C, Perl or Shell
08:34:53 <quicksilver> (it is in haskell)
08:34:57 <quicksilver> that's fine, you just have to learn it.
08:34:59 * vixey and msuming parsers up
08:35:02 <ski_> one reason for feeling uneasy about things like `x >= 0 && isFoo (sqrt x)' is that we usually feel that conjunction morally ought to be commutative ..
08:35:06 <quicksilver> && is a short-form conditional
08:35:12 <yuuki> vixey, okay, so normal form has a meaning for combinators.  Apparently it both having only primitive combinators and not being able to apply the combinators
08:35:14 <Axman6> he almost yelled at my friend when he suggested type casting a number to a bool
08:35:14 <lilac> @src MonadPlus IO
08:35:15 <lambdabot> Source not found. stty: unknown mode: doofus
08:35:30 <quicksilver> Axman6: which is also fair enough; I'm not that keen on implicit conversions either.
08:35:35 <lilac> @src mplus IO
08:35:35 <lambdabot> Source not found. Wrong!  You cheating scum!
08:35:43 <saml> > 1 && 1
08:35:44 <quicksilver> But lecturers tend to take extreme views for pedagogical reasons.
08:35:45 <lambdabot>       No instance for (Num Bool)
08:35:45 <lambdabot>        arising from the literal `1' at <inte...
08:35:46 <Axman6> @src IO mplus
08:35:46 <lambdabot> m `mplus` n = m `catch` \_ -> n
08:36:01 <vixey> yuuki, not sure if that is what I meant, to be precise about what I meant was -- every object you would like to classify as equal is syntactically equal in normal form
08:36:03 <Axman6> :t catch
08:36:04 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:36:06 <conal> quicksilver: let's see
08:36:06 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
08:36:19 <quicksilver> conal: Behaviour a -> Event (a -> Behaviour a) -> Behaviour a
08:36:21 <ski_> however, a dependent conjunction is inherently assymetric .. in `(a : A) /\ P a' the right side isn't even meaninful unless the left side is satisfied (i.e. inhabited)
08:36:34 <quicksilver> conal: like 'switcher' but with a parameter in the switched behaviours
08:36:36 <yuuki> vixey, yes, I think that's what the combinator calculus normal form entails
08:36:50 <conal> Axman6: ("conal: but what if you want to test ...") i have no idea what you're referring to.
08:36:52 <vixey> oh perfect, then!
08:37:05 <Axman6> quicksilver: well i tend to agree with him, it's one of the reasons haskell makes so much sense to me, because, well, it makes sense
08:37:06 <vixey> I suspected there wasn't one for combinators
08:37:20 <yuuki> vixey, I think it's undecidable for untyped combinators
08:37:21 <Axman6> conal: ?
08:37:26 <quicksilver> conal: the intended use is for the parameter to carry the value at the 'switch-point' so that you can stitch together a continuous behaviour
08:37:29 <ski_> @src IO mplus
08:37:30 <lambdabot> m `mplus` n = m `catch` \_ -> n
08:37:36 <ski_> lilac ^
08:37:40 <quicksilver> (axman6 accidentally addressed to conal a point he meant for me)
08:37:54 <Axman6> oh, so i did, sorry
08:38:07 <Axman6> c and q are right next to each other >_>
08:38:20 <vixey> yuuki, so if you generalize the  T -> U  type arrow into  forall x : T, U(x)  you can probably introduce equality along the lines I mentioned above but as constants
08:38:44 <vixey> yuuki, (I don't _think_ you can construct them using 'X'...)
08:39:56 <yuuki> Interesting... I'll look into dependent types!
08:40:01 <yuuki> vixey, thank you!
08:40:33 * Axman6 gets back to trying to do DB stuff with haskell
08:41:14 <lilac> conal: suppose you have snapshot a b, with a's last event at time T1, a's MaxBound event becoming visible at time T2, and b's first event at T3, where T3 > T2 and T3 > T1. then it's hard to get snapshot to terminate before T3.
08:41:33 <ski_> (vixey : "equality .. as constants" ?)
08:42:09 <vixey> (=) :: A -> A -> Prop
08:42:26 <vixey> refl :: Pi x, x = x
08:42:42 <lilac> conal: by which i mean, it's hard to get snapshot to produce its MaxBound-time event before T3
08:43:04 <vixey> (compared with the Prolog code:  X = X.  )
08:43:46 <lilac> conal: you need to be able to determine that T3 > T1 before max(T1,T2). i hope that's possible with Improving time
08:44:12 <quicksilver> lilac: you can certainly determine that T3 > T1 at T1, can't you?
08:44:22 <quicksilver> (and that's before max(T1,T2))
08:44:30 <quicksilver> before-or-equal
08:44:42 <arcatan> 2
08:45:24 <lilac> quicksilver: you don't know the value of T3 before T3
08:45:49 <lilac> quicksilver: but you may know that T3 > T1 at T1. that'd need improving time or similar thoug
08:46:52 <lilac> conal: i find it problematic that the semantics don't cover when values become available; this seems to be important for reasoning about functionality
08:48:05 <conal> Peaker: thx for pointing out my join/duplicate goof.
08:48:13 <quicksilver> lilac: I think it could be more clearly written down.
08:48:13 <jimstutt> conal: my fun with gitit has broken on not finding a registered HaXml-1.13.3 for 0.3.1 and 0.3.1. 0.2.2.1 was fine. Any other sufferers?
08:48:22 <Peaker> conal: sure
08:48:30 <quicksilver> lilac: it is certainly my understanding that at T1 you definitely know that T3 > T1 (if it has not yet arrived)
08:49:46 <jimstutt> conal: does john macfarlane have a #haskell id I can find (irc illiterate)?
08:50:13 <vixey> jimstutt, doesn't ring a bell
08:50:28 <vixey> oops
08:50:42 <lilac> quicksilver: that'd require knowing what the time source of b is.
08:51:11 <jimstutt> vixey: was that a reactive metronome joke?
08:51:20 <lilac> quicksilver: what stops b from producing a change after T1 which is attributed as being at time T1 - delta?
08:51:36 <quicksilver> I don't know.
08:51:39 <quicksilver> I wondered that myself.
08:51:41 <vixey> he
08:51:42 <vixey> heh
08:51:43 <lilac> nor do i. it worries me
08:51:52 <quicksilver> but something does, presumably, otherwise `mappend` wouldn't be deterministic.
08:52:00 <quicksilver> for Futures (let alone events)
08:52:01 <conal> quicksilver: (reading scrollback) couldn't you use snapshot instead of a new combinator?
08:52:14 <quicksilver> conal: well you have to snapshot with "the last event"
08:52:23 <quicksilver> sorry
08:52:32 <Clockwork> Hey, how can I srqt an Integer?
08:52:34 <quicksilver> "the last value of the event" (which is a behaviour)
08:52:38 <Clockwork> sqrt Integer -> Integer
08:52:45 <quicksilver> conal: which is possible although slightly fiddly
08:52:46 <lilac> quicksilver: right, given that mappend works, this must be possible :)
08:52:53 <dmwit_> Clockwork: First cast it to a Floating type.
08:52:53 <quicksilver> and stitching the end together.
08:52:55 <vixey> Clockwork, isqrt
08:53:03 <quicksilver> conal: I was wondering if you had bumped into something like this.
08:53:13 <quicksilver> You can also think about writing it recursively
08:53:15 <dmwit_> Clockwork: Or write yourself an isqrt, as vixey suggests. =)
08:53:26 <Axman6> :t isqrt
08:53:26 <quicksilver> thinking of a series of "increasingly defined" types
08:53:27 <lambdabot> Not in scope: `isqrt'
08:53:33 <quicksilver> behaviours.
08:53:35 <quicksilver> damn words!
08:53:50 <EvilTerran> Clockwork, an integer sqrt function is conspicuously absent from the stdlibs, for some reason
08:54:02 <EvilTerran> Clockwork, but it's fairly easy to define
08:54:18 <vixey> someone should add it to the Prelude using GMP
08:55:02 <Aser> hi. is System unsafePerformIO something "implemented but you really shouldn't use" or is it quit common?
08:55:13 <conal> quicksilver: what do you mean about snapshotting with "the last event"?
08:55:23 <dmwit_> Binary search in the range [n/2, 3n/4] or so (work out your own upper bound, I'm just guessing) should work.
08:55:31 <vixey> Aser, I don't think it's that useful
08:55:35 <dmwit_> Aser: You shouldn't use it.
08:55:40 <conal> quicksilver: i designed reactivity semantics pretty carefully so that stuff like this would just work
08:55:46 <conal> quicksilver: without fiddlyness
08:55:50 <Clockwork> How can I change a floating type to an integer, that's actually my problem
08:55:55 <dmwit_> Aser: It's provided primarily for the FFI, when you're binding a function that you happen to know is pure.
08:55:56 <Clockwork> round doesnt catch here
08:55:56 <vixey> Aser, if it was useful it'd be common but it's almost in no haskell code at all
08:56:08 <EvilTerran> > let isqrt x = last $ takeWhile (\i -> i^2 < x) [0..] in [(floor.sqrt.fromIntegral $ x, isqrt x) | x <- [0..]]
08:56:09 <lambdabot>   [(0,* Exception: Prelude.last: empty list
08:56:12 <EvilTerran> er
08:56:21 <dmwit_> Aser: The burden of proof of purity is on the programmer when using unsafe*. =)
08:56:29 <conal> jimstutt: i'm not involved in pandoc, other than as a casual fan
08:56:32 <EvilTerran> modulo my off-by-one errors :P
08:56:46 <quicksilver> conal: well what were you thinking of snapshotting with which?
08:56:50 <EvilTerran> > let isqrt x = head $ dropWhile (\i -> i^2 < x) [0..] in [(floor.sqrt.fromIntegral $ x, isqrt x) | x <- [0..]]
08:56:52 <lambdabot>   [(0,0),(1,1),(1,2),(1,2),(2,2),(2,3),(2,3),(2,3),(2,3),(3,3),(3,4),(3,4),(3...
08:57:02 <Aser> so the lazy ones coming from imperativ languages got it? ;)
08:57:14 * EvilTerran will tinker with this more later
08:57:23 <jimstutt> conal: tnx will have to email john macfarlane.
08:57:27 <conal> quicksilver: you can define a behavior that uses its own value at the moment of a transition.
08:57:29 <dmwit_> Clockwork: What's the problem with round?
08:57:31 <dmwit_> :t round
08:57:33 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
08:57:40 <dmwit_> Looks useful to me.
08:57:42 <Clockwork> it's realfrac not float
08:57:45 <Axman6> > let isqrt x = last . takeWhile (\n -> n^2 < x) $ [0..] in isqrt 101
08:57:47 <lambdabot>   10
08:57:55 <Axman6> > let isqrt x = last . takeWhile (\n -> n^2 < x) $ [0..] in isqrt 1
08:57:55 <dmwit_> > round (sqrt (3 :: Float)) :: Integer
08:57:56 <lambdabot>   0
08:57:57 <lambdabot>   2
08:58:03 <Axman6> > let isqrt x = last . takeWhile (\n -> n^2 <= x) $ [0..] in isqrt 1
08:58:04 <lambdabot>   1
08:58:07 <dmwit_> Clockwork: Yeah, but Float is in the RealFrac class.
08:58:09 <Axman6> > let isqrt x = last . takeWhile (\n -> n^2 <= x) $ [0..] in isqrt 99
08:58:09 <quicksilver> conal: but the value of a behaviour *at* the moment of the transition is the 'new' not the 'old' value, isn't it?
08:58:10 <lambdabot>   9
08:58:10 <dmwit_> Clockwork: So no problem.
08:58:12 <conal> lilac: i'm sorting through threads in the scrollback and want to pick up yours.
08:58:19 <conal> quicksilver: no.  the old.
08:58:28 <quicksilver> conal: Oh!
08:58:32 <quicksilver> conal: well that explains it.
08:58:35 <conal> quicksilver: but now i see why you thought it was problematic.
08:58:43 <quicksilver> conal: my implementation is probably broken then ;)
08:58:51 <conal> quicksilver: oops
08:58:53 <quicksilver> conal: I now see why you thought it was easy ;)
08:59:06 <conal> :)
08:59:18 <vixey> @tell FunctorSalad https://github.com/signup/free :P
08:59:18 <lambdabot> Consider it noted.
08:59:19 <EvilTerran> yay edge cases!
08:59:27 <quicksilver> conal: have you used something like this, to stitch together continuous behaviours into a continuous hole? It seems like a natural thing.
08:59:42 <vixey> sounds like topology
09:00:03 <conal> quicksilver: yes.  examples like yours is why i made that choice (old value at occurrence) a long time ago.
09:00:37 <birdspider> hi, does this make sense to anyone ? ERROR "Aufgabe8.hs":18 -
09:00:37 <birdspider>  Inferred type is not general enough
09:00:37 <birdspider> *** Expression    : unzipT
09:00:37 <birdspider> *** Expected type : Tree (a,b) -> (Tree a,Tree b)
09:00:39 <birdspider> *** Inferred type : Tree (a,a) -> (Tree a,Tree a)
09:00:56 <vixey> birdspider, it means stop putting type annotations down
09:01:11 <quicksilver> conal: so if a reactive has a whole bunch of simultaneous transitions, it is "left-most" up to and including the moment of the transition, and "rightmost" afterwards?
09:01:13 <vixey> birdspider, but you also have a mistake in your code
09:01:22 <birdspider> vixey: can you explain this
09:01:31 <EvilTerran> ?hpaste , birdspider
09:01:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:01:52 <quicksilver> that was probably a strange sense of 'left-most'.
09:01:56 <EvilTerran> let's see what we're dealing with :)
09:02:12 <conal> quicksilver: "left-most" & "right-most"?
09:02:33 <quicksilver> conal: left + right of the "mappend" used to construct the simultaneity.
09:02:41 <birdspider> http://hpaste.org/12574
09:02:47 * Peaker nags conal about his bug :-)
09:02:48 <Lemmih> birdspider: It means that your code only works for 'Tree (a,a)' but you've told the compiler that it must work on 'Tree (a,b)'.
09:03:04 <conal> Peaker: did lilac's fix solve your bug?
09:03:12 <Peaker> conal: lilac's fix?
09:03:21 <Peaker> conal: I'm referring to the e->b->e->b
09:03:49 <musser> Why is it that I can't push 4 into [ 1 2 3 ] ?
09:03:58 <musser> It says [ 1 2 3 ]  is immutable
09:04:20 <musser> But immutable? returns false
09:04:49 <Peaker> musser: are you sure you're asking the right channel?
09:04:59 <conal> quicksilver: still not sure what you mean.  the value up to and at the event occurrence is unaffected by the event.  the value immediately after is the value of the last occurrence at that time.  and by "immediately" i really mean immediately.  not a finite delay > 0.
09:05:00 <birdspider> Lemmih: ah, I see the point, what makes it only working on Tree (a,a)
09:05:09 <Lemmih> musser: Is that Haskell?
09:05:25 <musser> whoops
09:05:36 <musser> wrong channel
09:05:44 <conal> Peaker: lilac had a symptom that reminded me of yours, and he added a mempty case for snap
09:05:59 <Peaker> conal: snap = snapshot_ ?
09:06:11 <Peaker> conal: or a wrapper around snapshot_ ?
09:06:23 <quicksilver> conal: yes. in that case we agree.
09:06:25 <conal> Peaker: the dual.  used in snapshot_, via snapshotWith
09:06:33 <quicksilver> conal: "last occurence at that time" <- that's what I meant by 'right-most'
09:06:46 <conal> quicksilver: thx.  i though we probably agreed, but i wasn't sure.
09:06:46 <quicksilver> conal: since 'last' is a bit funny, for simultaneous occurences.
09:07:03 <quicksilver> I will fix my implementation to match your semantics.
09:07:09 <quicksilver> now I understand why they are desirable ;)
09:07:12 <conal> quicksilver: great.
09:07:22 <quicksilver> learning++
09:07:23 <birdspider> Lemmih: may it be that b is not derived from Eq,Show ?
09:07:38 <conal> quicksilver: have you tried the Reactive quickcheck suite on your implementation yet?
09:07:49 <conal> quicksilver: you don't have deterministic mappend yet, do you?
09:08:57 <quicksilver> conal: I don't, no.
09:09:15 <quicksilver> conal: I don't have the ability to inject events at arbitrary 'precise' times, either
09:09:24 <Peaker> conal: so if I use just snapshot_ what fix would I use?
09:09:34 <quicksilver> all my events come out of IO and as such are intrinsically subject to the whims of the thread scheduler anyway
09:09:39 <conal> quicksilver: deterministic mappend was the trickiest part of Reactive for me to figure out.
09:10:01 <quicksilver> conal: I have 2 or 3 approaches I haven't worked through yet, at least one suggested by luqui
09:10:07 <conal> quicksilver: not intrinsically.  i fixed that issue.
09:10:25 <quicksilver> but I was slightly writer's block on it so I moved on for a while.
09:10:34 <quicksilver> conal: yes. You're right, I oversimplified my wording.
09:10:52 <quicksilver> Let me say they are asynchronous and therefore don't have precise times ;)
09:11:04 <quicksilver> I also have removed threads from much of my code
09:11:07 <quicksilver> (for the better!)
09:11:29 <quicksilver> lesson learnt : threads are for non-determinism. If that's not what you want, think twice.
09:11:39 <Lemmih> birdspider: You're using 'fst' and 'snd' wrongly.
09:11:49 <conal> Peaker: snap mempty _ = mempty
09:12:02 <lilac> conal, Peaker: the fix i had was wrong; it only fixed the case where the snapshot event was empty :)
09:12:14 <lilac> all other cases of snapshotting with a finite event were not fixed
09:12:23 <Lemmih> birdspider: It should be (Node a (fst left) (fst right), Node b (snd left) (snd right)).
09:12:30 <lilac> but i understand the nature of the problem a lot better now :)
09:12:39 <Peaker> ah, okay. I am not sure what the type of snap is, and how I'd use it instead of what I do now anyway
09:12:41 <pchiusano> hello
09:12:47 <conal> lilac: i know it wasn't a full fix. i wondered if it unblocked Peaker
09:13:11 <quicksilver> conal: I'm wondering if I don't prefer CPS-style to tuple-style, for various functions like snapshotWith
09:13:24 <lilac> conal: it's not likely, sadly.
09:13:33 * quicksilver wonders which conal uses in fact.
09:13:43 <Peaker> I still did not understand what "snap" is, though.. can you show its type?
09:13:50 <birdspider> Limmih: so the types got mixed up
09:13:54 <Lemmih> birdspider: Do you see why that is?
09:14:15 <conal> Peaker: see FRP.Reactive.PrimReactive
09:14:18 <geezusfreeek> my mappend is very simple. newtype List a = List [StrictList a]; mappend (Event a) (Event b) = Event $ zipWith (++) a b
09:14:19 <birdspider> Lemmih: yeah, i think so, i tried to build Tree a  with b types
09:14:28 <birdspider> Lemmih: and vice versa
09:14:31 <geezusfreeek> err... i don't know why i said List. i meant Event
09:14:38 <birdspider> Lemmih: am I correct ?
09:14:46 <quicksilver> ah, you don't use the tuple version.
09:14:57 <quicksilver> conal: I think it's withTimeE where I thought the CPS version might be nicer.
09:15:01 <Lemmih> birdspider: You are, yes.
09:15:02 <Peaker> conal: btw, cabal upgrade fails with: cabal: dependencies conflict: reactive-glut-0.0.5 requires reactive ==0.9.1 however reactive-0.9.1 was excluded because reactive-fieldtrip-0.0.5 requires reactive>=0.9.5
09:15:10 <Peaker> conal: It might have something to do with my installation of darcs libs
09:15:54 <geezusfreeek> actually zipWith isn't what i'm using since it drops the tails, but close enough to get the idea here
09:16:05 <conal> Peaker: i don't know where reactive ==0.9.1 could come from.  it's not in reactive-glut.cabal.
09:16:11 <Peaker> conal: damn, types need a reader too :-)  Passing those "t" types around everywhere is a bit clumsy
09:16:29 <conal> Peaker: "types need a reader"??
09:16:32 <birdspider> Lemmih: thanks, I suppose It'd have taken a while to figure this out by myself :)
09:16:34 <dcoutts> conal, Peaker: it can come from an installed package. Installed packages have exact deps.
09:16:35 <conal> oh!
09:16:57 <Peaker> conal: implicitly getting the "t" there, everywhere
09:17:10 <conal> dcoutts: thx.  so Peaker needs to rebuild reactive-glut
09:17:30 <mmorrow> , (zip`ap`tail) . flip interleave [0..] $ [42..50]
09:17:38 <lunabot>  [(42,0),(0,43),(43,1),(1,44),(44,2),(2,45),(45,3),(3,46),(46,4),(4,47),(4...
09:17:45 <mmorrow> , (zip`ap`tail) . flip interleave [0..] $ [42..44]
09:17:47 <lunabot>  [(42,0),(0,43),(43,1),(1,44),(44,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(...
09:18:38 <ski_> @quote aztec
09:18:39 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
09:18:39 <dcoutts> conal, Peaker: right, cabal-install would normally offer to rebuild reactive-glut against the newer reactive, but reactive-glut-0.0.5 is not on hackage, so cabal-install does not know how to do that. It can only use the existing installed reactive-glut-0.0.5 which needs the older reactive.
09:18:58 <mmorrow> such a funny quote
09:19:12 <vincenz> :t zip`ap`tail
09:19:13 <lambdabot> forall b. [b] -> [(b, b)]
09:19:18 <quicksilver> mmorrow: thanks ;)
09:20:23 <Peaker> dcoutts, conal: I just rebuilt reactive-glut from the latest darcs, but it still has this same dependency
09:21:27 <Peaker> I manually changed the reactive-glut cabal file to specify reactive >= 0.9.5  and then I got the "process" problem: cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
09:22:03 <dcoutts> grr
09:22:07 <conal> dcoutts: oh.  thanks.  so the problem comes from mixing hackage & darcs-repo libs?
09:22:38 <dcoutts> conal: it's not a problem as such, it's just that cabal does not know how to rebuild non-hackage packages, so you have to do it manually
09:22:52 <Peaker> ghc-6.10.1  requires process == two different versions?
09:23:18 <jimstutt> peaker: I had the same thing so have reactive-0.9.0 and reactive-0.9.1.
09:23:23 <dcoutts> Peaker: this will be because you've got Cabal-1.6.0.1 registered per-user and globally. This is really the fault of the cabal-install bootstrap script.
09:23:23 <conal> dcoutts: via clean lib rebuilds?  that's what i do.
09:23:32 <dcoutts> conal: right
09:23:42 <Peaker> dcoutts: ah, how can I fix it?
09:23:51 <dcoutts> Peaker: unregister the local per-user one
09:24:34 <Peaker> dcoutts: my per-user one is probably more up-to-date though
09:24:52 <Peaker> dcoutts: ghc-pkg list shows I only have Cabal-1.6.0.1 in the system-wide lists
09:25:17 <dcoutts> Peaker: and it's not in the per-user list?
09:25:25 <Peaker> I do have process installed on the per-user and system-wide lists, with those 2 versions
09:25:30 <Peaker> dcoutts: nope
09:25:49 <dcoutts> Peaker: there's probably some other package then that has the exact same version globally and per-user
09:26:04 <Peaker> My ghc-pkg list http://hpaste.org/12576
09:26:48 <jimstutt> peaker: I've just been doing cabal install <xxx> --reinstalls
09:27:19 <dcoutts> Peaker: hmm, I only see haskell98 that's a duplicate there
09:28:46 <Peaker> dcoutts: and that's ok? or to unregister the per-user one?
09:28:58 <dcoutts> Peaker: I'd unregister the per-user one
09:29:21 <dcoutts> Peaker: having different versions globally and per-user is fine, but the exact same version causes confusion
09:29:24 <conal> lilac: i copied out your remarks about snapshot and am digesting them now.
09:30:38 <Peaker> dcoutts: I used cabal upgrade process --global, and now the .cabal file editing trick worked
09:31:39 <dcoutts> Peaker: that works because it ignores the per-user db and so the overlap does not cause any problems
09:31:42 <jimstutt> dcoutts: well worth putting on the wiki? I've got 3 diff TypeComposes at the moment ;)
09:31:57 <dcoutts> jimstutt: having many versions is ok
09:31:58 <conal> lilac: "you need to be able to determine that T3 > T1 before max(T1,T2). i hope that's possible with Improving time".  yeah.  that's the sort of early deduction that Improving is for.
09:33:00 <conal> lilac: and Improving isn't systematically tested yet and i'm suspicous of it.  i've made a start, by adding Ord properties to checkers.
09:33:10 <jimstutt> dcoutts: but I had the same problem as Peaker and have fretted about lib version clashes for months :)
09:33:29 <Peaker> dcoutts: the edit I made is changing reactive-glut to depend on the newer reactive, and then install it, otherwise its install was a no-op
09:33:31 <dcoutts> jimstutt: feel free to add it to the wiki
09:33:54 <Peaker> dcoutts: and then nothing else worked because the reactive-glut that was already installed wanted reactive==old
09:33:56 <dcoutts> Peaker: yes, by default it doesn't re-install versions that are already installed
09:34:04 <dcoutts> Peaker: use --reinstall to force a reinstall
09:34:06 <jimstutt> dcoutts: ok 'n tnx
09:34:19 <Peaker> dcoutts: Will that install it to depend on the newer version though?
09:34:31 <dcoutts> Peaker: no, but it'll do that by default
09:34:32 <Peaker> dcoutts: if that newer version is on hackage?
09:34:42 <conal> dcoutts: --reinstall is a flag for what?
09:34:48 <dcoutts> conal: for cabal install
09:35:14 <dcoutts> conal: if you've got foo-1.0 installed and that's the latest version then cabal install foo does nothing.
09:35:25 <dcoutts> conal: to force it to reinstall use --reinstall
09:35:35 <conal> dcoutts: got it.  thx.
09:35:51 <dcoutts> it's the standard behaviour of other package managers
09:36:11 <Peaker> weird, cabal upgrade finished,  and another cabal upgrade immediately after it has more work to do?
09:36:20 <conal> dcoutts: so when my users have these dependency skews, i'll suggest "cabal install foo --reinstall"
09:36:29 <Peaker> (finished successfully, it seems)
09:37:11 <Peaker> dcoutts: is that supposed to happen:  repeatedly running "cabal upgrade" does a bit more of the upgrade work?
09:37:11 <dcoutts> conal: if you're telling them to rebuild packages that are not on hackage then just cd to the darcs repo and cabal install
09:37:26 <Saiz> btw, the main problem is that category-extras depends on the ghc package here, imo, but that will change in the next release
09:37:34 <Peaker> dcoutts: That's what I did and it wasn't enough, because it did reinstall, but the same version with dep on the same version so it was a no-op
09:37:46 <dcoutts> Peaker: it's not an exact science, it depends on what you think upgrade means and how much you care about global consistency
09:38:27 <dcoutts> Peaker: I'd like more details on that. You ran cabal install, not just runghc Setup install ?
09:38:46 <Peaker> dcoutts: yeah, I ran "cabal install" in the darcs of reactive-glut
09:38:53 <ksf> @seen clockwork
09:38:53 <Peaker> dcoutts: and it did link & install (it was already built)(
09:38:53 <lambdabot> I saw clockwork leaving #haskell 29m 41s ago, and .
09:39:04 <ksf> dang. wanted to point him to http://www.haskell.org/haskellwiki/Generic_number_type#squareRoot
09:39:05 <lambdabot> Title: Generic number type - HaskellWiki
09:39:06 <dcoutts> Peaker: using ghc-6.8 ?
09:39:12 <Peaker> dcoutts: ghc-6.10.1
09:39:15 <dcoutts> hmm
09:39:29 <Peaker> dcoutts: but I still had an old reactive, and it found no reason to upgrade it to the new reactive - so it just overwrote the reactive-glut with the same thing
09:39:31 <dcoutts> Peaker: can you reproduce this?
09:39:50 <jimstutt> dcoutts: in quite a few cases since ghc-6.10.1 was released,  cabal install will fail on some missing depency and succeed at a second attempt. Is this due to build order dependencies or something else?
09:40:02 <Peaker> dcoutts: I'm not sure, I could try to uninstall the newer reactive/etc
09:40:22 <dcoutts> Peaker: but you said it happened with the newer one installed
09:40:32 <dcoutts> jimstutt: not sure, I'd need more details
09:40:54 <dcoutts> Peaker: configure should select the different package and then when cabal calls ghc --make it should rebuild against the other package version
09:40:56 <hackage> Uploaded to hackage: hscurses 1.3.0.2
09:41:27 <gwern> hm? someone i developing hscurses?
09:41:30 * gwern goes and looks
09:41:42 <dcoutts> Peaker: I mean cabal install in the dir, re-runs configure, which makes a fresh decision about what deps to use
09:41:45 <Peaker> dcoutts: everything is under ghc-6.10.1:  I had installed:  reactive-0.9.1, reactive-glut-0.0.5(built with reactive-0.9.1).  I tried to upgrade so I can have reactive-0.9.6, but it couldn't because the installed reactive-glut wants reactive==0.9.1.  So I tried "cabal install" in the reactive-glut-0.0.5  directory, so it would install & use the reactive-0.9.6, but it still linked&installed with reactive-0.9.1, didn't even download 0.9.6
09:42:07 <Peaker> dcoutts: s/I had installed/these were installed
09:42:31 <dcoutts> Peaker: ahh ok
09:42:44 <dcoutts> Peaker: so reactive-0.9.6 was not yet installed
09:42:54 <Peaker> dcoutts: right
09:42:58 <Peaker> dcoutts: so I was in deadlock, couldn't install new reactive because of the existing glut. Couldn't get glut to depend on the new reactive, because it was just happy with what it had
09:43:16 <Peaker> dcoutts: the fix I did was to hack the .cabal of the glut to depend on reactive 0.9.6
09:43:27 <Peaker> dcoutts: then installing it installed the new reactive and everything became fine
09:43:32 <dcoutts> Peaker: ok, that's the default behaviour of cabal install in a dir. It tries to use as many installed versions as possible rather than trying to upgrade all deps.
09:43:33 <jimstutt> dcoutts: I'll try and stick on one half of the issue. I spend hours perming pacman testing, hackage cabal and runhaskell reactive-0.9.0 and 0.9.1 to build FieldTrip and reactive-GLUT, iirc.
09:43:48 <Peaker> dcoutts: ah, is there a way to tell it to upgrade the deps as much as possible?
09:44:02 <dcoutts> Peaker: that's the difference between cabal install and cabal upgrade
09:44:16 <Peaker> dcoutts: but "cabal upgrade" cannot be run in the context of a specific package directory?
09:44:20 <dcoutts> Peaker: right
09:44:28 <Peaker> dcoutts: so my hack was the only solution in my case?
09:44:44 <dcoutts> Peaker: or cabal install/upgrade reactive first
09:44:50 <Peaker> dcoutts: I couldn't
09:45:11 <dcoutts> sure you could, you just couldn't cabal upgrade everying simultaneously
09:45:13 <Peaker> dcoutts: oh wait, I didn't try to do it after fixing the process problem, maybe I could
09:45:38 <dcoutts> just because "cabal upgrade" fails does not mean "cabal upgrade foo" will fail
09:46:07 <dcoutts> since whatever it upgrades it has to do consistently, so the more packages the harder it is to find a consistent solution
09:46:08 <jimstutt> peaker: I hacked the .cabal file(s) to 0.9.1 and it worked.
09:47:24 <Peaker> so what keeps the old versions of reactive/etc around?
09:47:33 <Peaker> does cabal-install keep a refcount on package deps?
09:47:55 <Peaker> or does it slowly leak the older versions of everything that was ever installed?
09:47:56 <Saiz> cabal install never uninstalls
09:48:01 <dcoutts> right
09:48:31 <dcoutts> it may do one day, but not automatically, at least not by default
09:48:46 <dcoutts> you could imagine someone implementing a package gc
09:49:00 <Peaker> apt has one
09:49:13 <dcoutts> nix has one too
09:49:36 <dcoutts> which is a good deal more clever, since nix and cabal support multiple versions of the same package, unlike apt
09:49:38 <Saiz> nix has purer packages than ghc-pkg, right?
09:49:44 <dcoutts> Saiz: aye
09:49:52 <dcoutts> we'll get there one day
09:49:55 <dcoutts> perhaps in 6.12
09:50:01 <ddarius> conal: A bit of trivia.  You probably know the former and maybe even the latter.  Since, as you point out, a type class morphism for Functor is just a natural transformation every semantic function (that doesn't use seq) is immediately a type class morphism for Functor by parametricity and furthermore immediately implies the functor laws.  Secondly, in John Reynolds' language Forsythe, he explicitly defines the array type as { length :: Int } & (Int -> a)
09:50:01 <ddarius> , an intersection of a record type and Int functions.
09:50:04 <lunabot>  luna: parse error on input `of'
09:50:09 <dcoutts> Saiz: installed packages identified by their abi hash
09:51:46 <gislik> Anyone know how to persist a CalendarTime (or some other kind of date structure) in HAppS? (Noone seems to be listening in #HAppS)
09:52:44 <Peaker> dcoutts: why is treating different versions of the same package as distinct packages much more complicated?
09:52:50 <Saiz> ?google happstutorial
09:52:55 <lambdabot> http://www.haskell.org/haskellwiki/HAppS_tutorial
09:52:55 <lambdabot> Title: HAppS tutorial - HaskellWiki
09:53:00 <Saiz> not that..
09:53:23 <Peaker> dcoutts: I guess the "package group" of the various-versions upon which some can depend can complicate matters
09:54:10 <Saiz> gislik: take a look at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happs-tutorial
09:54:16 <lambdabot> Title: HackageDB: happs-tutorial-0.4.3, http://tinyurl.com/6repg4
09:55:51 <gislik> Saiz: Thanks. I'm already looking at that tutorial :) I'm able to persist strings, ints, ... but when I try to introduce CalendarTime into my data structure I get the following error: No instance for (Data CalendarTime)
09:57:56 <Saiz> gislik: iirc you just have to give a Serialize instance for CalendarTime
10:00:16 <ertai> Saiz: thanks for your answser and sorry about the delay (connection lost at work)
10:01:41 <gislik> Saiz: do you mean that I need to implement the getCopy and putCopy functions of the Serialize type class for the type CalendarTime?
10:02:31 <jkff> Hi. I'm reading Wadler's "Free theorems" and I see the Reynolds arrow: (f,f') `in` A->B iff forall (x,x')`in`A, (f x,f' x')`in`B, where f and f' are functions. Anyone know whether this remains true (in a modified form) if they become relations?
10:03:11 <Saiz> gislik: yes
10:03:38 <gislik> Saiz: ok thanks for your quick replies :)
10:04:37 <Saiz> gislik: np :)
10:05:28 <jkff> Ouch, my question seems to be silly.
10:05:35 <jkff> Disregard it.
10:05:52 <Saiz> gislik: btw, you've to define those functions inside an instance declaration if it wans't clear, like instance Serialize CalendarTime where getCopy = ...; putCopy c = ...
10:05:57 <jkff> ...Or not. Well, if anyone is interested, I can continue the monologue for a while :)
10:06:41 <gislik> Saiz: Understood
10:07:45 <Saiz> jkff: (f,f') in A -> B? ..but they are in a tuple.. what am i missing?
10:08:13 <jkff> (f,f') `in` {the relational interpretation of type A -> B}
10:08:41 <jkff> The thing is that Wadler introduces the combinator for the case where f,f' are functions, but in the very next section he uses them in a case where they are relations.
10:08:47 <ddarius> jkff:  A relation is a function into a powerset.
10:09:39 <jkff> Relations are isomorphic to functions into powersets, but they are not the same. To sum it up, that doesn't help.
10:11:12 <jkff> I would be much surprised if it turned out that I found an error in Wadler's paper, I must be missing something..
10:12:15 <jkff> Maybe anyone over here could tell me the conceptual difference between parametricity and naturality, or tell me that there is none?
10:12:32 <lilac> i still don't get the (f,f') `in` A -> B thing.
10:12:43 <jkff> lilac: Did you read Wadler's "Free theorems"?
10:12:49 <lilac> jkff: ages ago
10:13:16 <jkff> Well, the underlying theory is as follows: Let us interpret every type as a relation, in the following way:
10:13:21 <jimstutt> jkff: a function has a single element in its range; a relation can have more than one. Isn;t it as simple as that?
10:13:42 <jkff> jimstutt: But how does that answer my question?
10:13:59 <jkff> lilac: A primitive type, like, Int, goes into the diagonal relation Int <-> Int where a <-> b iff a = b
10:14:23 <jimstutt> jkff: err, we're misinterleaved.
10:14:49 <jkff> lilac: On pairs and lists, the induced relation is defined pointwise.
10:15:40 <jkff> lilac: The type A -> B gets translated to a relation R such that (f,f')`in`R iff forall x,x'`in`A, (f x,f' x')`in`B.
10:15:55 <ddarius> jkff: Parametricity and naturality are different concepts, but very closely related.  Parametricity may be a special case of dinaturality (it's definitely not a special case of naturality.)
10:16:32 <lilac> jkff: ok, this seems reasonable (if non-computable)
10:16:55 <jkff> lilac: As for universally quantified types, (g,g')`in` forall X.FX iff forall R:A<->A', (g(A),g(A'))`in`F(R).
10:17:22 <jkff> Then, the theorem states that if t is a closed term of type T, then (t,t)`in`{relation for T}. And all the free theorems come from that.
10:17:39 <jkff> ddarius: Could you clarify a bit, or point to some literature or keywords?
10:18:14 <jkff> I saw a smallish article about 'When parametricity implies naturality', or like that, but either I read it not closely enough or it didn't clarify anything for me..
10:19:26 <ddarius> jkff: Anyway, viewing R(A,B) as A -> P(B) and P(B) as B -> Bool leads to the definition for functions being able to be expanded out.  If that expanded and refolded definition is your "modified form" of a definition for relations, then it remains true or at least -should- be true.
10:19:47 <jkff> Ahhh, I found my mistake. Of course, Wadler is right and he doesn't apply the definition for functions to relations.
10:20:23 <jkff> However, the question of whether he *could* apply it remains, and I hope that he could :)
10:20:56 <lilac> jkff: i have failed to follow your notation:  "forall R:A<->A'" :(
10:21:08 <jkff> forall R being a relation between A and A'
10:21:16 <lilac> ah, ok
10:21:48 <lilac> /any/ relation?
10:21:49 <jkff> ddarius: you are right, it's definitely a very good idea to expand R(A,B). However, I think that the most correct way would be to prove all these free theorems using category theory, where such things would become trivial or independent on whether f and f' are functions or relations.
10:22:24 <jkff> lilac: yes
10:22:30 <lilac> that's a bit of a surprise :)
10:22:35 * lilac thinks
10:22:38 <ddarius> jkff: Personally, I just view parametricity as a special case of dinaturality.
10:23:46 <Twey> ddarius: Gesundheit.
10:23:49 <ddarius> In that case there is nothing to prove.  The "free theorems" are true by definition.
10:24:16 <jkff> Yes, that's what I thought about them and why I started to learn category theory :)
10:29:55 <vixey> has anyone constructed the free theorems in type theory?
10:30:23 <quicksilver> conal: fixing the snapshot thing turns out to be as easy as transposing two variables in my defn of snapshot. But I wonder if other similar errors lurk alsewhere.
10:30:54 <quicksilver> conal: I definitely need a better way to test stuff ;)
10:31:16 <roconnor> @free undefined
10:31:17 <lambdabot> f undefined = undefined
10:31:44 <dolio> All functions are strict. QED.
10:32:00 <roconnor> :P
10:32:10 <jkff> Looks like I need to learn a lot of algebra. I started reading Mac Lane today and immediately ran into factor-commutator groups and other stuff that I am afraid to pronounce in fear that I will summon armageddon..
10:33:08 <jkff> @free fix
10:33:10 <lambdabot> f . g = h . f => f (fix g) = fix h
10:33:20 <jkff> Wow
10:33:23 <conal> quicksilver: :)
10:33:32 <ziman> @help free
10:33:32 <lambdabot> free <ident>. Generate theorems for free
10:33:40 <jsn> jkff: Cale posted something that is more geared toward computer scientists recently
10:33:52 <ziman> @free (>>=)
10:33:52 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
10:34:04 <conal> quicksilver: since there's more than one implementation of the Reactive interface, it'd be cool if we could share test suites.
10:34:07 <jkff> jsn: Who is Cale?
10:34:31 <jkff> ziman: You are evil.
10:34:37 <quicksilver> conal: I haven't looked at your test suite.
10:34:42 <conal> quicksilver: though then we'd have to coordinate about even details of the interface .
10:34:48 <jsn> Cale is on this channel a bit, i'm sure you'll run into him
10:34:53 <quicksilver> conal: but it would certainly be interesting.
10:35:09 <jkff> What's his nick?
10:35:15 <quicksilver> My stuff is stuck in IO and hard to test.
10:35:16 <quicksilver> .
10:35:17 <jsn> his nick is Cale
10:35:19 <geezusfreeek> conal, i thought about that. i don't particularly want to define a "standard" frp interface yet
10:35:20 <jkff> Oh :)
10:35:29 * jkff leaves for a while
10:35:30 <quicksilver> I'd like to have a pure model, for testing, I think.
10:35:49 <dolio> @free bind :: M a -> (a -> M b) -> M b
10:35:50 <lambdabot> $map_M g . h = k . f => $map_M g (bind x h) = bind ($map_M f x) k
10:35:56 <conal> geezusfreeek: yeah.  me neither.
10:35:58 <geezusfreeek> forunately, mine is mostly pure. the hardest part would be testing for proper laziness/strictness in mine
10:36:13 <geezusfreeek> and in fact, that is the most vital part for mine
10:38:30 <geezusfreeek> what i really want is a universal, pure interface for quickcheck, smallcheck, and lazysmallcheck
10:39:29 <lilac> @free join :: (a -> a -> a) -> a -> a
10:39:30 <lambdabot> (forall x. f . g x = h (f x) . f) => f . join g = join h . f
10:41:59 <quicksilver> geezusfreeek: I'm not entirely of the school of thought that blocking pure values entirely deserve the description 'pure' ;)
10:42:12 <geezusfreeek> quicksilver, mine don't block
10:42:21 <geezusfreeek> they poll
10:42:41 <quicksilver> I thought you modelled your events literally as lists
10:42:43 <quicksilver> ?
10:42:47 <geezusfreeek> i do
10:42:58 <geezusfreeek> nested lists
10:42:59 <conal> quicksilver: all pure values block until they're ready
10:43:00 <quicksilver> then what happens if you try to look into the future?
10:43:04 <geezusfreeek> absence of an event is empty list
10:43:23 <geezusfreeek> you can't look into the future
10:43:28 <geezusfreeek> everything is causal
10:43:29 <quicksilver> conal: I know. I appreciate it's a hair-splitting distinction.
10:43:34 <conal> quicksilver: :)
10:43:40 <geezusfreeek> which might distinguish mine from yours and conal's
10:43:52 <quicksilver> geezusfreeek: e :: Event; e !! 4
10:44:04 <quicksilver> geezusfreeek: what does this do if 'e' will have 5 occurences, but hasn't had them yet?
10:44:07 <geezusfreeek> if you try to look into the future then you are still looking at the present
10:44:38 <ksf> frame that one.
10:44:41 <geezusfreeek> and there is simple no way to express your example with my interface right now
10:44:45 <geezusfreeek> *simply
10:45:06 <quicksilver> ah, but behind the scenes there is.
10:45:11 <quicksilver> so you may hide it form the interface
10:45:24 <quicksilver> but behind the scenes there is either a 'blokcing pure value' or a 'not yet ready pure value'
10:45:28 <geezusfreeek> behind the scenes, doing that would simply be looking at the present
10:45:30 <quicksilver> or whatever you choose to call it.
10:45:40 <geezusfreeek> if present events are already observed, then looking to the future yields no more events
10:45:48 <quicksilver> really? then that sounds like mutation?
10:45:49 <ksf> in fact, you're not looking at the present but at what you wish the present to be, but now i'm splitting hairs.
10:45:52 <quicksilver> how can the fifth element of a list change?
10:46:12 <geezusfreeek> it doesn't change. it is observed
10:46:24 <geezusfreeek> once it is observed, it remains. but it will have no effect on the end result
10:46:33 <quicksilver> so, before it is observed, it is a "not yet ready pure value"
10:46:36 <ksf> now we're getting into quantum mechanics.
10:46:39 <geezusfreeek> there is no time assigned to an event or absence of an event
10:46:40 <quicksilver> which is the same as a "blocking pure value"
10:46:57 <ksf> so if you observe schroedinger's cat it can't die any more.
10:47:17 <geezusfreeek> okay, let's run with the schroedinger's cat example
10:47:20 <conal> geezusfreeek: i wanted to use the event-as-list rep, but i wasn't able to get enough partial info out of it at the end.  i can't always know whether an event remainder is nil or cons, but i can know that any more elements would have to be later than a given time.
10:47:35 <ksf> in fact, you're nesting one dataflow into the other.
10:47:48 <Klara> hi everybody, i have a problem with my quickchek: http://hpaste.org/12577
10:47:57 <quicksilver> geezusfreeek: I'd rather use the "user pressing keys on the keyboard" example.
10:48:03 <geezusfreeek> okay
10:48:12 <conal> geezusfreeek: i wonder if you found a solution to that tail-end problem that i'm not seeing.
10:48:12 <quicksilver> it's more concrete. No quantum mechanics here thanks.
10:48:18 <Klara> can somebody help me?
10:48:33 <ksf> as you can predict, in the general case, the future only on the basis on what you know _now_, further information means that each event is in itself is an eventstream.
10:48:38 <conal> geezusfreeek: and i can wait until you're done with this thread with quicksilver .
10:48:49 <geezusfreeek> conal, i don't even see such a problem, really. if it is clearly impossible for an event to have any more events i just use [] to represent the event
10:48:58 <ksf> which makes the top-level eventstream unenumerable, if it wasn't already, that is.
10:49:17 <quicksilver> before the user has pressed a key (but given that he is going to) what is "head e" ?
10:49:40 <geezusfreeek> quicksilver, that would be []
10:49:53 <quicksilver> and then after he presses the key, it changes?
10:49:54 <ksf> that is, more or less, the multiple universe interpretation: your actions collapse the vector and fix the future to a specific path.
10:49:56 <geezusfreeek> no
10:50:03 <geezusfreeek> you observe the next element of the event list
10:50:11 <quicksilver> oh.
10:50:13 <quicksilver> I think I understand.
10:50:18 <quicksilver> I can observe as many [] as I want
10:50:22 <geezusfreeek> right
10:50:23 <conal> geezusfreeek: what's your representation, and what does it mean?
10:50:36 <quicksilver> if I keep sampling
10:50:56 <quicksilver> so you're prepared to generate non-occurrences on demand, to keep the interface pure in this sense.
10:50:59 <quicksilver> interesting.
10:51:12 <geezusfreeek> conal, (newtype Event a = Event [StrictList a]). the head of the outer list is a list of events which occur at the same time. the next element is the next "sample" of events
10:51:15 <geezusfreeek> and so on
10:51:19 <geezusfreeek> and Event [] is Never
10:51:20 <ksf> you keep sampling "there could be an event one second from now, or there may be not, i honestly don't know".
10:51:26 <quicksilver> there is a certain non-determinism here.
10:51:33 <Klara> hmm
10:51:38 <quicksilver> which you'd have to be sure doesn't cause problems for your users.
10:52:00 <geezusfreeek> quicksilver, right. i am trying to control the interface very tightly
10:52:01 <conal> geezusfreeek: what's "next 'sample'"?
10:52:07 <conal> geezusfreeek: what's "sample"
10:52:24 <geezusfreeek> conal, polling for occurrences, basically
10:52:40 <quicksilver> you can probably hide it behind the interface though.
10:52:40 <quicksilver> you can probably hide it behind the interface thouinteresting.
10:52:52 <conal> geezusfreeek: does the content of representation somehow depend on how it gets used?
10:53:02 <quicksilver> conal: yes.
10:53:03 <conal> geezusfreeek: i don't just mean the *evaluated* content.
10:53:07 <quicksilver> demand is driving non-occurences
10:53:10 <geezusfreeek> conal, yes, it will, but i'm trying to hide that behind interface
10:53:20 <quicksilver> as I understand it.
10:53:22 <saml> > i'm bored
10:53:23 <lambdabot>   Not in scope: `i'm'Not in scope: `bored'
10:53:52 <conal> geezusfreeek: oh.  interesting.  i'd like to see how soundly & neatly your idea can work out.  do you ever blog?
10:53:56 <ksf> otoh, you could get an answer like "there's going to be a timer event one second from now". if you combine a key event to only fire at a specific time event, you'd even get useful information out of the nondeterministic case.
10:54:07 <geezusfreeek> conal, rarely nowadays, but i could accelerate my blogging
10:54:16 <quicksilver> this isn't a blokcing pure value : it's  non-deterministc pure value.
10:54:26 <quicksilver> somethign which also makes me uncomfortable but I will be interested to see how it evolves.
10:54:44 <geezusfreeek> quicksilver, yeah i felt like i was playing with fire at first, but it seems to be coming along rather cleanly
10:54:48 <conal> geezusfreeek: it might help in crystaling the ideas, separating them from implementation details.
10:55:57 <paolino> who administer hackage?
10:56:14 <geezusfreeek> conal, yes. i am also developing this on the side of a game, so i am only implementing things that have concrete use cases right now
10:56:49 <geezusfreeek> so i have no Behavior yet, for example, and only basic Reactive so far
10:56:57 <pchiusano> hi, I have a question about mailing list etiquette
10:57:04 <geezusfreeek> data Reactive a = Reactive a [Maybe a]
10:57:27 <conal> geezusfreeek: which is great for focus.  it also sounds to me like you have a pretty interesting idea worth sharing.
10:58:11 <pchiusano> the company I work for is looking to hire a programmer with FP experience to do Scala programming - is it kosher to post something on the haskell mailing list?
10:58:18 <geezusfreeek> pchiusano, absolutely
10:58:23 <tanob> hello guys, im trying for hours to fix a problem, but i dont get it... its here: http://hpaste.org/12578
10:58:35 <geezusfreeek> there are also wiki pages for these
10:59:03 <pchiusano> geezusfreeek: ok
10:59:08 <geezusfreeek> conal, i may get back into blogging then
10:59:20 <tanob> if translateBg has type [JClass] and translate has type [JClass] too, so using ++ on their results should give a [JClass]
10:59:28 <geezusfreeek> this is a very "on the side" project though, so progress is slow
11:00:38 <pchiusano> geezusfreeek, which list would you recommend posting to?
11:00:51 <ksf> haskel-cafe is fine.
11:00:54 <geezusfreeek> pchiusano, probably -cafe
11:01:01 <pchiusano> ok
11:01:09 * conal leaves to reboot
11:01:19 <ksf> new hardware?
11:01:22 <tanob> anybody has an idea?
11:01:38 <sbahra> uhm
11:01:38 <lambdabot> sbahra: You have 1 new message. '/msg lambdabot @messages' to read it.
11:02:50 <ksf> tanob, yes, write type annotations for ell your toplevel functions.
11:02:57 <ksf> stuff is going to clean up then.
11:03:18 <tanob> ksf: i did it, as you can see as comments
11:03:25 <paolino> anyone has rights to put a library on hackage to resolve editline build ?
11:03:29 <tanob> ksf: but they didnt help :(
11:04:42 <Saiz> paolino: you should send a mail to the maintainer of the package
11:05:03 <sbahra> So
11:05:10 <sbahra> How can I convert a ByteString to an integer? :-/
11:05:40 <Saiz> depends, how do you want to do that?
11:05:42 <Peaker> sbahra: what kind of conversion?
11:06:01 <sbahra> Saiz, give me 1 way without unpacking.
11:06:03 <ksf> tanob, did you ever have a look at the list monad?
11:06:08 <paolino> Saiz, the problem is in the system, not in the package
11:06:19 <sbahra> Peaker, Data.ByteString.Char8 -> Integer
11:06:22 <tanob> ksf: no, why?
11:06:27 <sbahra> Peaker, (Integral a) => Data.ByteString.Char8 -> a
11:06:32 <ksf> x <- transateBg b types pushes the list translateBg into x, _element by element_
11:06:53 <ddarius> sbahra: A bytestring isn't an Integer in a natural way.  What do you want that conversion to do?
11:07:06 <sbahra> ddarius, I want behavior similar to read.
11:07:09 <Saiz> paolino: ah, i see
11:07:12 <sbahra> > read "3" :: Integer
11:07:13 <lambdabot>   3
11:07:18 <ksf> s/translateBg/translateBg returns/
11:07:26 <Igloo> Does anyone happen to know what the equivalent of ClockTime is in the time package?
11:07:30 --- mode: Igloo set -o Igloo
11:07:42 <Igloo> (seconds and picoseconds since the epoch)
11:07:49 <Saiz> ?hoogle readInt
11:07:50 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
11:07:50 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
11:07:50 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
11:07:56 <ddarius> sbahra: There should be bytestring lexing functions on Hackage.  There may or may not be a lexer for Integers (v. Int) there somewhere.
11:07:58 <Saiz> sbahra ^^^
11:08:32 <sbahra> Yes, yes.
11:08:35 <sbahra> Makes sense.
11:08:43 <sbahra> Thank you Saiz :)
11:08:44 <tanob> ksf: sorry, i dont get it
11:08:47 <sbahra> and ddarius
11:09:26 <eu-prleu-peupe1> just ordered real world haskell :D
11:09:49 <eu-prleu-peupe1> hope it arrives near the end of the week :)
11:10:09 <ksf> tanob, just get rid of the do-syntax and concat the translateBg and translate directly.
11:10:12 <Peaker> geezusfreeek: Why is it [Maybe a] in the Reactive a?
11:10:42 <ksf> ...and get rid of the return in the first case of translate.
11:10:44 <sbahra> @hoogle ByteString -> Maybe (Double, ByteString)
11:10:45 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
11:10:45 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
11:10:45 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
11:10:45 <paolino> Saiz: without the editline which should be in the standard library , other dependent packages are reported broken, which could be wrong
11:10:48 <Peaker> geezusfreeek: do the indices in the lists in the Reactive/Event values have to match up for the same time? (IOW, do these list indices correspond to time)?
11:10:54 <ksf> then it matches the type you specified.
11:11:29 <geezusfreeek> Peaker, i will get back to you. busy with some work
11:11:34 <Peaker> geezusfreeek: Okay
11:11:53 <Peaker> Hoogle seems to be kind of dumb with these results (which are much less specific than readInt)
11:12:10 <ksf> right now, it has the type [[a]] resp. [[JClass]]
11:12:34 <tanob> ksf: i did the rewrite, and: http://hpaste.org/12578#a1
11:13:39 <ksf> http://hpaste.org/12578#a2
11:14:21 <jkff> Ahhhh, I realized that my question about the Reynolds arrow combinator on relations just tells about the Rel-> category (the arrow category of Rel). That gives me a warm fuzzy feeling.
11:14:23 <geezusfreeek> Peaker, okay, it's [Maybe a] in Reactive because if it was the same representation as in Event then we would only care about the last element of the StrictList anyway
11:14:39 <geezusfreeek> so i just go ahead and throw away the extra information in the Reactive data type
11:14:50 <jkff> Commutative diagrams will save the world.
11:14:56 <ksf> also, http://www.haskell.org/all_about_monads/html/listmonad.html
11:14:56 <lambdabot> Title: The List monad
11:15:07 <vixey> ksf, use map
11:15:15 <geezusfreeek> and yes, indices have to match up. indices correspond to time, but they can be of varying granularity
11:15:22 <geezusfreeek> they have to line up though
11:15:23 <ksf> wut? i'm not doing anything.
11:15:31 <ksf> 'xept watching tv.
11:15:42 <ksf> and maybe eating a pudding, soon.
11:15:57 <noZone> map is your friend.
11:16:16 <Peaker> geezusfreeek: aha, I see
11:16:33 <Peaker> geezusfreeek: So Nothing's would be there just so the indices all align
11:16:49 <tanob> ksf: sorry, http://hpaste.org/12578#a3
11:16:55 <Peaker> geezusfreeek: isn't it potentially expensive to add Nothings to count-less lists so the indices all add up? wouldn't using explicit timestamping be better?
11:18:35 <ksf> well, [JClass] clearly isn't a MTransIfo a... did you mean to feed the result of translate into the tiClasses field?
11:20:04 <tanob> ksf: at the moment i dont want to do nothing with the result from translate, later i will write them to a file
11:20:48 <ksf> then why are you passing it to runMTransInfo?
11:21:55 <tanob> ksf: i want to use the info at the monad inside the generateClosures function
11:22:12 <geezusfreeek> Peaker, there would be the same overhead either way, i would think. you either have to check for nothing or check for the time stamp
11:23:04 <Peaker> geezusfreeek: when checking, you'd have to traverse a lot of Nothings to find the last Just, and when updating, you'd have to add a lot of Nothings (to a lot of lists), no?
11:23:40 <geezusfreeek> Peaker, no, the traversals are always incremental as time progresses, not all at once
11:24:05 <geezusfreeek> never is more than one Nothing evaluated at a time, only the head
11:24:51 <geezusfreeek> there is no extra plumbing to keep things lined up. it just come naturally due to the interface semantics
11:24:56 <Peaker> geezusfreeek: how are the lists updated?
11:25:13 <geezusfreeek> it's all just unsafeInterleaveIO
11:26:02 <Peaker> if you have thousands of Reactive values, though, and millions of updates, each update changing the value of just a few reactive values
11:26:06 <ksf> wut? translate depends on generateClosures.
11:26:34 <Peaker> wouldn't the lists inside the reactive values accumulate lots of "filler" values to keep the indices in sync?  storage-wise (and a bit processing-wise) expensive?
11:26:38 <tanob> ksf: generateClosures depends on translate
11:27:18 <ksf> translate -> translateBg -> translateAlt -> allMappings -> generateClosures
11:27:45 <tanob> ksf: exactly
11:28:29 <geezusfreeek> Peaker, conversely, wouldn't there be a lot of overhead checking time values the other way?
11:28:34 <ksf> ...so if you use translate inside generateClosures, chances are that you'll close a cycle and have a fine loop.
11:29:07 <tanob> ksf: sorry, generateClosures doesnt call translate
11:29:13 <Aser> err... if you'd have to discribe funktional programming, how would you do it in a short way? i would say: Functional programms doesn't have a status, so there aren't really something like classic variables. in addition, the applications just contains funktions and the definition of those. also, you don't have to care that much about the order of the funktions and can even use a funktion as a funktion's argument.
11:29:17 <ksf> <tanob> ksf: i want to use the info at the monad inside the generateClosures function
11:29:23 <ksf> i know, i was just wondering.
11:29:33 <Peaker> geezusfreeek: as you said, the check/read is pretty much the same?
11:29:38 <tanob> ksf: i just want to share state
11:29:41 <Peaker> geezusfreeek: (comparing a time value, or "isJust")
11:29:51 <geezusfreeek> i would think so.
11:29:58 <geezusfreeek> i have not benchmarked anything yet
11:30:02 <Peaker> Aser: funCtion :-)
11:30:20 <geezusfreeek> but the number of Nothings doesn't seem to be prohibitely large to me
11:30:23 <Peaker> Aser: I like the description in the whyfp.pdf paper
11:30:54 <Peaker> geezusfreeek: if a Reactive value did not change, it was Just 5, will it store a Just5 in the next list item as well?
11:31:08 <Peaker> geezusfreeek: (or a Nothing)?
11:31:09 <ksf> functional programming is like fixing vacuum cleaners to the holes of a billiard table and watch.
11:31:52 <Peaker> geezusfreeek: Reactive value's list had (Just 5) at some index N, what will it have at index (N+1) if nothing happened to it at that time?
11:32:00 <tanob> ksf: no idea of how can i fix that problem ?
11:33:08 <geezusfreeek> Peaker, a reactive value that is currently 5 and has no change in the next step would be Reactive 5 (Nothing:_), and then it will be advanced to Reactive 5 _ until the next time it is checked
11:33:08 <ksf> well to me it seems that you want to write tiClasses = translate ... instead of tiClasses = [], but I don't really know what you're trying to do.
11:33:12 <luqui> does anyone know why ReadP a = R (forall b . (a -> P b) -> P b)  instead of just using P directly?
11:33:38 <geezusfreeek> well, where _ is some actual variable
11:33:58 <Heffalump> does the continuation-passing style allow for some optimisation?
11:34:00 <ksf> i've got a good crystal ball, but am not omniscient.
11:34:37 <luqui> Heffalump, that's my guess, but I don't know *what* optimization
11:34:40 <tanob> i guess that _ isnt defined as a normal value
11:34:45 <vixey> Heffalump, makes TCO, multiple values and direct implementation of CWCC etc very easy
11:34:48 <tanob> otherwise is
11:34:51 <Peaker> geezusfreeek: I don't understand, I thought that Reactive was   Reactive a{- initial value -} [Maybe a] {- All the changes -}
11:34:53 <ksf> Heffalump, mainly tail recursion optimisation.
11:34:58 <ddarius> Actually, in many cases, simply using CPS is an optimisation.
11:35:09 <ddarius> (for implementing monads that is)
11:35:17 <ksf> it's also useful to strictify a lazy language.
11:35:24 <vixey> yeah that's true too, a few functions I rewrite as CPS and they went much faster
11:35:27 <ksf> generally, control flow is painfully explicit.
11:35:32 <vixey> (in haskell)
11:35:41 <luqui> ddarius, hmm, yeah I've heard something like that. eg. ContT Maybe is faster than Maybe in some pathological case
11:36:00 <Peaker> geezusfreeek: basically I was trying to say that I don't know if Nothing's are added, or if "Just's" are added, but some filler must be added to the list of a non-changing reactive value for its indices to remain in sync with the other lists.. And my suspicion is that most reactive values don't change most of the time iterations
11:37:13 <geezusfreeek> Peaker, the filler is inherent to the semantics though, not really "added"
11:37:27 <geezusfreeek> the value is not available yet at the time of observation anyway
11:37:35 <geezusfreeek> so it _must_ be Nothing
11:38:31 <saml> ./prog  > file.txt      Vs.    ./prog #that opens "file.txt"             which is faster?
11:38:54 <saml> i mean, if ./prog prints so many stuff, would the time difference be linear?
11:38:55 <ksf> should be the same.
11:39:03 <Peaker> geezusfreeek: I must be misunderstanding something basic, as I don't understand how you keep indices in sync in a dense list (not spare list) without wasting much space
11:39:10 <saml> so redirection only gives constant overhead
11:39:12 <ksf> if then, it's a one-time cost that's negibly small.
11:39:24 <ksf> a file's a file, no matter how you open it.
11:39:46 <saml> ah posix is awesome
11:39:50 <saml> or unix
11:39:54 <taari> ;)
11:40:44 <ksf> but then, opening a file by hand with mmap can be _way_ faster than doing standard i/o.
11:40:53 <ksf> ask your local c guru about "block io"
11:41:25 <ksf> dunno if you can re-open stdin to use block io, never tried that.
11:41:50 <ksf> or stdout, for that matter.
11:42:14 <Twey> Would mmapping make a difference to the speed of... *scrolls to the bottom of the alioth list* ... Ruby?
11:43:07 <ksf> nah, but running it inside dosbox would.
11:46:12 <jkff> ...Seems like the best way to really understand the stuff behind free theorems is to write a free theorems generator.
11:46:22 * jkff starts writing one
11:46:31 <ddarius> @free id
11:46:32 <lambdabot> f . id = id . f
11:46:34 <ddarius> @ft id
11:46:36 <lambdabot>  fd:7: hClose: resource vanished (Broken pipe)
11:46:48 <dolio> @free seq
11:46:49 <lambdabot> g . seq x = seq (f x) . g
11:46:50 <saml> @google free theorem
11:46:55 <lambdabot> http://citeseer.ist.psu.edu/wadler89theorems.html
11:47:10 <ksf> @free beer
11:47:12 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
11:47:24 <saml> @free putStrLn
11:47:25 <lambdabot> $map_IO $id . putStrLn = putStrLn
11:47:38 <dolio> Heh.
11:49:11 <Twey> What does @free do?
11:49:22 <jdrake> I have a [Maybe a], how can I convert this to Maybe [a], where even a single Nothing results in an overall Nothing?
11:49:22 <vincenz> @free willy
11:49:23 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `willy'\n\n"
11:49:36 <ddarius> @help free
11:49:36 <lambdabot> free <ident>. Generate theorems for free
11:49:49 <ksf> :t foldM
11:49:50 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:50:04 <idnar> > sequence [Just 5, Nothing, Just 6]
11:50:05 <lambdabot>   Nothing
11:50:09 <ksf> even better.
11:50:12 <ksf> @src sequence
11:50:13 <lambdabot> sequence []     = return []
11:50:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:50:13 <lambdabot> --OR
11:50:13 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:50:15 <idnar> > sequence [Just 5, Just 6]
11:50:16 <lambdabot>   Just [5,6]
11:50:39 <wolverian> hm, that "--OR" is a new feature of lambdabot, or is that actually in the same source file? :)
11:50:53 <jdrake> nice:sequence $ (convertList ["2.54","5.2","6.7","2.3"]::[Maybe Float])
11:50:53 <jdrake> Just [2.54,5.2,6.7,2.3]
11:51:00 <dolio> Some things are special cased like that.
11:51:09 <wolverian> ah, thanks.
11:51:22 <jdrake> Now I wonder if I can rewrite my convertList to do it automatically...
11:51:27 <Twey> :t convertList
11:51:28 <lambdabot> Not in scope: `convertList'
11:51:41 <idnar> special-cased like what?
11:51:43 <jdrake> http://hpaste.org/12580
11:52:06 <jdrake> Right now it is [Maybe a], I wonder if I can rewrite it into Maybe [a] without using sequence
11:52:28 <int-e> > catMaybes [Just 1, Nothing] -- useful for ignoring bogus entries.
11:52:30 <lambdabot>   [1]
11:52:42 <jdrake> Nothing indicates failure, and I need that
11:52:57 <Twey> I don't think that sequence is a special case, is it?
11:53:03 <Twey> @src sequence
11:53:03 <lambdabot> sequence []     = return []
11:53:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:53:03 <lambdabot> --OR
11:53:03 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:53:13 <Saiz> jdrake: mapM readMaybe where readMaybe :: Read a => String -> Maybe a
11:53:25 <Twey> It's just a natural consequence of the Monad Maybe instance
11:53:54 <int-e> jdrake: using sequence is natural then
11:54:00 <jdrake> ok
11:54:05 <dolio> I was talking about how @src special cases some functions to show two different (but equivalent) definitions.
11:54:15 <idnar> > foldM (\x y -> if x == 5 then Nothing else Just x:y) [1,2,3,4]
11:54:17 <lambdabot>   Couldn't match expected type `Maybe' against inferred type `[]'
11:54:21 <dcoutts> dons: if you're looking to improve that "Package Hosting" link on the haskell.org front page, how about merging http://haskell.org/haskellwiki/Haskell.org with http://haskell.org/haskellwiki/Haskell.org_domain and making a new user-oriented page to describe the services we provide.
11:54:23 <lilac> conal: i have a fix for the snapshot bug, but i'm not sure you'll like it :)
11:54:24 <lambdabot> Title: Haskell.org - HaskellWiki
11:54:32 <dolio> @src (++)
11:54:33 <lambdabot> []     ++ ys = ys
11:54:33 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:54:33 <lambdabot> -- OR
11:54:33 <lambdabot> xs ++ ys = foldr (:) ys xs
11:54:42 <idnar> > foldM (\x (Just xs) -> if x == 5 then Nothing else Just (x:xs)) (Just []) [1,2,3,4]
11:54:43 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
11:54:43 <lambdabot>        Expect...
11:54:57 <idnar> > foldM (\(Just xs) x -> if x == 5 then Nothing else Just (x:xs)) (Just []) [1,2,3,4]
11:54:58 <lambdabot>   Couldn't match expected type `Maybe [b]'
11:56:19 <idnar> > foldM (\xs x -> if x == 5 then Nothing else Just (x:xs)) [] [1,2,3,4]
11:56:20 <lambdabot>   Just [4,3,2,1]
11:56:33 <lilac> @tell conal This change fixes the resound snapshot blocking issue: http://hpaste.org/12528#a2
11:56:34 <lambdabot> Consider it noted.
11:56:36 <idnar> meh, wrong direction
11:56:51 <jdrake> Saiz, I am not sure of your code there
11:57:06 <idnar> I'd probably go with sequence . mapM anyway
11:57:30 <jdrake> ok, let me look at that
11:57:40 <int-e> @index readMaybe
11:57:40 <lambdabot> bzzt
11:57:43 <int-e> :(
11:58:49 <ddarius> :t fmap (fmap fst) . listToMaybe . flip reads ""
11:58:51 <lambdabot>     Couldn't match expected type `b -> c'
11:58:51 <lambdabot>            against inferred type `[(a, String)]'
11:58:51 <lambdabot>     Probable cause: `reads' is applied to too many arguments
11:59:00 <int-e> > let readMaybe x = case reads x of [(v,"")] -> Just v; _ -> Nothing in mapM readMaybe ["1","2"] :: Maybe [Int]
11:59:02 <lambdabot>   Just [1,2]
11:59:05 <ddarius> :t fmap (fmap fst) . listToMaybe . reads
11:59:06 <lambdabot>     Couldn't match expected type `(a, b)'
11:59:06 <lambdabot>            against inferred type `String'
11:59:06 <lambdabot>       Expected type: String -> Maybe (a1, (a, b))
11:59:21 <ddarius> :t fmap fst . listToMaybe . reads
11:59:22 <lambdabot> forall a. (Read a) => String -> Maybe a
11:59:31 <Saiz> jdrake: http://hpaste.org/12580#a1
12:00:21 <dolio> @free foo :: IO a
12:00:21 <lambdabot> $map_IO f foo = foo
12:00:30 <jdrake> Saiz, I am interested in your method.
12:00:57 <dolio> @free foo :: IO Int
12:00:57 <lambdabot> $map_IO $id foo = foo
12:04:38 <int-e> @pl \f -> sequence . map f
12:04:38 <lambdabot> (sequence .) . map
12:05:13 <int-e> aww. (should be mapM)
12:05:45 <gwern> @src mapM
12:05:45 <lambdabot> mapM f as = sequence (map f as)
12:05:57 <tibbe> hmm, where in the module hierarchy would you put a stream processor data type e.g. data StreamProc stream a = StreamProc (stream -> a) >
12:05:58 <tibbe> ?
12:06:05 <tibbe> Control?
12:06:07 <tibbe> Data?
12:06:23 <acidjnk> Can someone please give me a case that would fit (!!!) :: [a]->Int->a? I tried (!!!) [x:xs] 0 = x, but it didn't work.
12:06:32 <acidjnk> functionality is irrelevant
12:07:07 <ddarius> tibbe: You do realize that, other than an extra bottom, StreamProc = (->) ?
12:07:25 <tibbe> ddarius: yes, the real type is a little more complicated
12:07:33 <int-e> acidjnk: use (x:xs) instead of [x:xs]
12:07:51 <tibbe> data StreamProc a = Done a | Continue (Stream -> StreamProc)
12:08:11 <lilac> acidjnk: (!!!) = (!!!) ? :)
12:08:21 <int-e> acidjnk: [x:xs] matches a list of length 1 whose first (only) element is a list with at least one element - the head of that list is bound to x, while the tail is bound to xs.
12:08:21 <tibbe> so either the processor is done and yield a result or it's suspended
12:08:26 <ddarius> tibbe: That should form a monad.
12:08:34 <tibbe> ddarius: it does
12:08:38 <acidjnk> thanks
12:08:40 <athos> good evening!
12:08:51 <tibbe> ddarius:  I'm just thinking about where people would search for it :)
12:08:52 <int-e> acidjnk: you can also write that in infix form - (x:xs) !!! 0 = x
12:09:25 <acidjnk> thanks
12:09:35 <ddarius> tibbe: They wouldn't search for it.  They'd search for whatever it is a part of.
12:09:52 <tibbe> ddarius: true
12:10:08 <tibbe> ddarius: well, for my own internal module hierarchy then :)
12:10:19 <tibbe> I know it's a somewhat unimportant decision but still
12:10:20 <gwern> > [1..] !! 100
12:10:22 <lambdabot>   101
12:10:28 <gwern> > [1..] !! 0
12:10:30 <lambdabot>   1
12:10:38 <tibbe> ddarius: I guess the question is, what goes into Data and what goes into Control
12:10:43 <tibbe> ddarius: it's a bit unclear
12:11:11 <ddarius> tibbe: It -is- a bit unclear, as in subjective.
12:11:21 <lilac> ISTM that higher-kinded things usually go into Control and * usually go into Data :)
12:11:35 <tibbe> ddarius: right, any precedence?
12:11:48 <mm_freak> i should start a collection of extremely elegant haskell snippets, i come up with quite frequently
12:11:49 <tibbe> i.e. what do people usually do
12:12:16 <ziman> > let n+m = [n..] !! m in 100 + 298
12:12:17 <lambdabot>   398
12:12:53 <ddarius> tibbe: You can look at what's already there.  If that library is only internal to your project and not intended to particularly generally useable, I'd not put it under Control or Data.
12:13:32 <mm_freak> :t (!!!)
12:13:34 <lambdabot> Not in scope: `!!!'
12:13:36 <ddarius> tibbe: Otherwise, it depends on how you use it.  For example, if the fact that it is a monad is significant then Control.Monad.StreamProc may be appropriate.
12:14:12 <gwern> mm_freak: actually, you should. I could use them as part of the mueval testsuite. the trickier the better
12:14:34 <lilac> FWIW, for practically everything in Control, i could imagine some language having syntactic sugar to support it
12:14:49 <mm_freak> gwern: ok, but first i'll finish my monads tutorial
12:15:00 <mm_freak> it's almost done
12:16:16 <luqui> lilac, I rushed to find a counterexample, but I could not.  :-)
12:16:33 <tibbe> ddarius: I'll use it for e.g. building parsers
12:16:34 <ddarius> I can imagine syntactic sugar for many things under Data.
12:16:50 <acidjnk> What's wrong with: ee :: Eq=>a->[a]->Bool; ee x [] = False; ee x (y:xs) = if x == y then True else ee x xs
12:16:53 <tibbe> ddarius: I will also run several stream processors in parallel using multiple threads
12:17:17 <ddarius> tibbe: "how" is what I said, not "what"
12:17:21 <acidjnk> Here is the error message: http://rafb.net/p/1Q2CJJ75.html
12:17:22 <lambdabot> Title: Nopaste - No description
12:18:03 <tibbe> ddarius: hmm ok, it'll probably used in a monadic way
12:18:22 <athos> yet another monads tutorial!
12:18:30 <tibbe> ddarius: I should insert an obligatory reference to Ontologies Considered Harmful ;)
12:18:31 <luqui> oh boy!
12:18:36 <athos> let a newbie like me review it 8)
12:19:07 * luqui comes from a perl background.  his syntactic sugar imagination is limitless  %-)
12:20:25 <tibbe> ddarius: anyway thanks for your input :)
12:20:32 <ziman> acidjnk, just write Eq a => in the signature
12:20:41 <ziman> (instead of Eq =>)
12:21:27 <ziman> you need to say which type variable should be in Eq because you can have different constraints for different type variables
12:26:09 <saml> > 1 `why` 2
12:26:10 <lambdabot>   Not in scope: `why'
12:26:29 <saml> > scope
12:26:30 <lambdabot>   Not in scope: `scope'
12:27:06 <saml> > [.0]
12:27:08 <lambdabot>       Overlapping instances for Show ((b -> c) -> a -> c)
12:27:08 <lambdabot>        arising from...
12:27:22 <luqui> woah
12:27:39 <luqui> is that that ghc section bug?  [(. 0)]
12:28:20 <conal> lilac: thanks.  i'll noodle over your snapshotWith fix.  is there anything about it you want to point out?
12:28:20 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
12:28:24 <dolio> Yes.
12:28:27 <Riastradh> Nu, luqui.
12:29:23 <gwern> luqui: I don't think it can be, as so far as I know lambdabot & mueval are still on 6.8.x
12:30:19 <luqui> yeah, was not that bug exhibited in 6.8? it seems to be fixed in 6.10
12:30:32 <luqui> :t [(. 0)]
12:30:34 <lambdabot> forall b c a. (Num (a -> b)) => [(b -> c) -> a -> c]
12:31:28 <gwern> luite: well, 6.10 has its own section bug, perhaps we are talking about different ones
12:32:16 <dolio> What's the 6.10 one? The 6.8 one is where you don't need to put parentheses around sections that are delimited by lists or tuples.
12:32:59 <conal> @seen lilac
12:32:59 <lambdabot> lilac is in #haskell. I last heard lilac speak 18m 25s ago.
12:33:51 <olsner> @ty .0
12:33:52 <lambdabot> parse error on input `.'
12:35:14 <lilac> conal: it's extraordinarily slow
12:35:30 <conal> lilac: oh?  i wonder why.
12:36:01 <lilac> conal: it's about as slow as it was before i switched from adaptE to runE mempty
12:36:12 <lilac> and profiling shows the runtime is going in the same place
12:36:26 <conal> and where is that?
12:36:32 <conal> it looks so straightforward.
12:36:46 <lilac> currRelTime being called a lot from sleepPast in makeTVal
12:37:00 <lilac> looks like once per sample
12:38:21 <conal> lilac: oh.  hm.  yeah, i bet it is.
12:38:55 <conal> lilac: i didn't realize that time-getting was expensive.  i may have to rethink things to avoid it.
12:39:09 <lilac> about 50% of my CPU goes there now :(
12:39:14 <conal> eep :(
12:39:37 <conal> well, the good news is we can double the speed
12:39:47 <conal> with one good fix
12:39:58 <pizza_>  a time machine.
12:40:08 <conal> lilac: do you mean 100% of one cpu?
12:40:14 <lilac> the adaptE -> runE mempty change made it about 6x faster fwiw
12:40:32 <conal> lilac: 6x -- that's tremendous.
12:41:11 <conal> lilac: sadly, that mempty isn't accomplishing what the other sync does.
12:41:15 <lilac> running it with +RTS -N2 makes it take forever
12:42:10 <conal> lilac: i'm wondering if your %50 is really more like 100%
12:42:28 <conal> when you run single-threaded
12:42:32 <conal> (single OS thread)
12:42:44 <arjanb> conal: would it be possible to run the time getting in a separate thread with good enough granularity?
12:43:10 <lilac> conal: i'm not sure if it deadlocks when i run it with -N2 or whether it's just making very slow progress
12:43:29 <arjanb> where the time is cached in some ioref
12:43:31 <conal> arjanb: i don't know what can be done efficiently and portably.  i'd sure like to know!
12:43:43 <conal> arjanb: oh, i think i get it.
12:43:51 <lilac> conal: the slowdown for going from one OS thread to two is in [20*, inf*]
12:44:03 <conal> arjanb: one thread gets the OS time an write it.  other threads read.
12:44:20 <pizza_> you're reading the current time?
12:44:24 <arjanb> right
12:45:02 <lilac> conal: right, so it makes progress, just /hugely/ slowly, with more threads
12:46:09 <conal> lilac: i don't think i got my question across.  do you have a two-core machine?
12:46:50 <conal> lilac: when you run on only one core, are you getting 50% or 100% of one core?
12:47:29 <conal> lilac: and i'm glad to know about the big -N2 slowdown.
12:47:55 <lilac> conal: i've also just got a 'GHC RTS is broken'-type crash out of it :(
12:50:01 <lilac> conal: 100% of one core. about 75% user, 25% system, though the user% increases with runtime (GC?)
12:50:44 <conal> lilac: thx.  so we can get a *huge* speed-up by reworking this time-getting thing.
12:50:54 <conal> potentially
12:51:11 <lilac> with -N2 it uses <10% of each core
12:53:04 <geezusfreeek> conal, time-getting? what is this expensive time-getting thing?
12:55:33 <geezusfreeek> OS time?
12:55:41 <conal> geezusfreeek: putting a thread to sleep until a given time.  and sometimes very frequently.
12:55:56 <lilac> conal: it's not the sleeping, just getting the current time
12:56:02 <conal> right
12:56:12 <conal> i get the time in order to know how long to sleep
12:56:23 <conal> almost always, the sleeping is unnecessary.
12:56:38 <geezusfreeek> oh, i figure to get the thread to wake up at regular intervals or something?
12:56:52 <conal> geezusfreeek: no.
12:56:58 <geezusfreeek> or do you really mean just a specific time?
12:57:09 <conal> geezusfreeek: yeah.  a specific time
12:57:53 <conal> i'd like a cheap & portable way to sleep until a given time.
12:57:57 <luite> what's the format of the passwd.rc file for lambdabot, how dow I specify users/passwords?
12:58:03 <conal> i guess i have expensive and portable
12:58:15 <BMeph> conal: Benedryl? ;)
12:58:21 <cjb> cheap, portable, correct, pick one
12:58:37 <conal> BMeph: hadn't thought of it.  works on me. :)
12:59:12 <luite> and how can I disable a lambdabot plugin?
12:59:34 <gwern> luite: edit it out of the source?
13:00:01 <luite> gwern: that would be a way... but I was hoping for a less compile-time way :)
13:00:55 <luite> is there some wiki or other page that provides some info about actually running lambdabot?
13:01:22 <Raevel> hmm
13:01:34 <Raevel> i haven't seen one
13:01:39 <luite> the README file and command list are quite unhelpful...
13:01:47 <Raevel> true
13:02:02 <gwern> luite: lambdabot documentation is minimal
13:02:04 <luite> I have now idea how I add users, or how I identify as an adminstrator
13:02:32 <Raevel> luite: the example online.rc tells you that
13:02:42 <luite> Raevel: not the password part
13:02:49 <luite> because passwd.rc is missing
13:02:57 <Raevel> password for what?
13:03:04 <luite> for the admin users, I guess
13:03:11 <Raevel> oh, i heard there was no such thing
13:03:14 <pizza_> conal, you're calculating an "absolute" time and then telling another thread to sleep until that time?
13:03:22 <luite> oh, it does list a lot of admins
13:03:30 <int-e> luite: password.rc is just an  msg nickserv password, I think.
13:03:39 <luite> ah
13:03:44 <conal> pizza_: yes
13:03:47 <Raevel> so all you need to do is steal someones nick and you're mr. admin
13:03:53 <luite> ah cool
13:03:59 <luite> :)
13:04:16 <pizza_> conal, do you have a small snippet that exhibits the behavior?
13:04:24 <gwern> well, it's not like being admin on lambdabot gives you a whole lot of power
13:04:50 <gwern> I mean, so maybe you go so far as to wipe all the state; the state is still backedup and versioned in the darcs lb repo
13:05:48 <lilac> conal: see http://hackage.haskell.org/trac/ghc/ticket/2833
13:05:50 <lambdabot> Title: #2833 (internal error: throwTo: unrecognised why_blocked value) - GHC - Trac
13:06:02 * conal looks
13:06:04 <snigel_> hello
13:06:06 <conal> lilac: http://hpaste.org/12528#a3
13:06:12 <conal> lilac: would you try it out?
13:06:16 <lilac> sure
13:06:35 <acidjnk> thanks ziman
13:06:49 <ziman> acidjnk, you're welcome.
13:07:53 <int-e> is there a way to 'cabal fetch' a package without its dependencies?
13:08:07 <snigel_> I'm getting an compile error which I can't figure out, anyone have an idea what's going wrong?
13:08:08 <lilac> conal: i didn't go via [(t,a)] because i was afraid of a space leak, but on reflection i think that fear was unfounded
13:08:14 <snigel_> Occurs check: cannot construct the infinite type: a = [a]
13:08:18 <dcoutts> int-e: I thought that's what cabal fetch did :-)
13:08:21 <snigel_> (!!=) :: [a] -> (Int,a) -> [a]
13:08:21 <conal> lilac: i worried at first also.
13:08:22 <snigel_> (!!=) xs (n,v) = (take (n-1) xs):v:(drop n xs)
13:08:55 <conal> lilac: i think ts, as, and bs are all traversed synchronously
13:08:58 <dcoutts> int-e: hmm, but clearly not
13:08:58 <int-e> dcoutts: no, it fetches the dependencies as well, as of ... uhm. 0.6.0
13:09:43 <lilac> conal: it works, but it's no faster
13:09:49 <conal> lilac: still, i bet the conversion to & from these lists will run into the same problem that led me away from using that these lists as the event representation.
13:10:03 <conal> lilac: that's fine.  i was going for prettier, not faster.
13:10:03 <conal> thx for testing.
13:10:13 <dcoutts> int-e: file a ticket. The main issue is what the purpose of fetch is. There are basically two cases, fetch for later offline install (requires deps) and fetch for study (does not)
13:10:53 <dcoutts> int-e: perhaps stuffing both into one command is not the best UI if we need a flag to distinguish the two purposes.
13:11:05 <conal> lilac: i do think going via a list will lose some crucial laziness / partial information.
13:11:12 <BMeph> snigel_: '(take (n-1) xs)' is a list, therefore a list with it as the first element is a list of lists. :)
13:11:23 <dcoutts> int-e: in the latest darcs version there's also cabal unpack which fetches only the latest version and not deps
13:11:44 <dcoutts> int-e: indeed for fetch for study there's no need to do any dep resolving at all
13:11:54 <BMeph> snigel_: Try (!!=) xs (n,v) = (take (n-1) xs)++v:(drop n xs) instead. :)
13:12:10 <int-e> dcoutts: yes, that was my use case - I wanted to have a quick look at the lambdabot sources.
13:12:48 <snigel_> BMeph: Thank you, will try that out.
13:12:49 <dcoutts> int-e: so perhaps when we've got cabal unpack we do not need cabal fetch for the purposes of study?
13:14:44 <int-e> dcoutts: Well I think it'd be odd to not be able to fetch a single package without unpacking it.
13:14:50 <snigel_> BMeph: that fixed it :)
13:15:08 <dcoutts> int-e: true, but doesn't it cover most use cases?
13:15:38 <dcoutts> int-e: for completeness we can have a flag on fetch, but the default being fetch for later install seems ok if unpack covers the other major use case?
13:15:51 <dcoutts> int-e: what do you think?
13:16:39 <dcoutts> int-e: there's two issues, having a complete range of operations and having the UI arranged in a way that matches the common use cases
13:18:14 <int-e> dcoutts: yes, I agree that fetching the dependencies is a good default
13:20:14 <lilac> conal: through /extreme evil/ i have hacked around the currRelTime slowness; the next bottleneck is calling minI for each sample :(
13:20:37 <geezusfreeek> evil :o
13:20:43 <lilac> i have a global
13:21:00 <conal> lilac: how do you set the global?
13:21:22 <conal> lilac: as arjanb suggested?
13:21:28 <lilac> unsafePerformIO
13:21:41 <dcoutts> int-e: ok, and of course you're welcome to file a ticket to add a flag to fetch to do no deps
13:21:48 <conal> lilac: what did you do with unsafePerformIO?
13:22:00 <dcoutts> int-e: similarly we should have a flag for install to do only deps
13:22:37 <lilac> http://hpaste.org/12586
13:23:01 <Ezla> > 2 elem [1,2,3,4]
13:23:03 <lambdabot>       No instance for (Num ((a -> [a] -> Bool) -> [t] -> a1))
13:23:03 <lambdabot>        arising ...
13:23:08 <Ezla> Why does elem need ` ` ?
13:23:09 <lilac> conal: the idea would be to store with each clock the last time it returned
13:23:25 <lilac> conal: and if that's after the time you're sleeping past, then there's nothing to do
13:23:33 <Ezla> > 2 `elem` [1,2,3,4]
13:23:34 <lambdabot>   True
13:23:40 <arjanb> Ezla: because it's used like an operator
13:23:46 <Ezla> why would that matter?
13:24:00 <conal> lilac: simple.  i like it.
13:24:02 <Ezla> where is the parsing ambiguity?
13:24:17 <Ezla> what could 2 elem [1,2,3] be mistaken for?
13:24:54 <sw17ch> Ezla: it makes 2 look like a function
13:24:55 <conal> lilac: might not be Haskell-thread-safe.  maybe an concurrency-safe var instead
13:24:58 <Ezla> > True && False
13:24:59 <lambdabot>   False
13:25:00 <Ezla> ^--- INDIX
13:25:01 <sw17ch> 2(elem,[1,2,3])
13:25:01 <raxas> > elem 2 [1,2,3,4]
13:25:03 <lambdabot>   True
13:25:03 <Ezla> *INFIX
13:25:11 <Ezla> why would "&&" be any different from `elem` ?
13:25:15 <raxas> Ezla: it is about op fixity
13:25:18 <Ezla> they are the same exact concept
13:25:20 <sw17ch> Ezla: lookum infixr
13:25:29 <Ezla> Fixity!?
13:26:06 <vincenz> It's not about fixity
13:26:09 <raxas> `elem` is infix
13:26:11 <roconnor> @index &&
13:26:11 <lambdabot> Data.Bool, Prelude
13:26:12 <vincenz> operators are infix, function names are prefix
13:26:20 <vincenz> If you want function names as infinx you have to use ``
13:26:23 <vincenz> The difference is purely lexical
13:26:26 <BMeph> Ezla: The short answer is: because "elem" is made of letters.
13:26:29 <sw17ch> vincenz: ah, that's right
13:26:32 <sw17ch> i forgot that part
13:26:35 <vincenz> function names that are not alphanumeric_ are 'poerators'
13:26:38 <Ezla> BMeph: that makes no sense to me
13:26:45 <vincenz> Otherwise theyre 'functions'
13:26:45 <Ezla> > True and False
13:26:47 <lambdabot>   Couldn't match expected type `([Bool] -> Bool) -> Bool -> t'
13:26:48 <sw17ch> <?> <-- operator
13:26:50 <vincenz> but they're both functions, they just fit differently
13:26:56 <sw17ch> bracketQuestionMarkBracket <-- function
13:27:11 <sw17ch> operators are functions with a different parse tree
13:27:12 <lilac> Ezla: remember that haskell supports, nay, encourages higher-order functions
13:27:23 <Ezla> lilac, how does that change this?
13:27:33 <lilac> > map and [[True,False],[False,True]]
13:27:35 <lambdabot>   [False,False]
13:27:40 <lilac> Ezla: ^^ like that
13:27:59 <Ezla> does Haskell use arbitrary weirdo syntax when it's not ambiguous, but just for the sake of... using weird characters?
13:28:00 <lilac> Ezla: if that parsed as "and (map, [[...]])" it'd be problematic
13:28:02 <sw17ch> > map (True &&) [True,False,True]
13:28:04 <lambdabot>   [True,False,True]
13:28:09 <conal> lilac: maybe http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-SampleVar.html
13:28:21 <lambdabot> Title: Control.Concurrent.SampleVar, http://tinyurl.com/64hkpv
13:28:30 <raxas> Ezla: no
13:28:36 <conal> lilac: how much did the performance improve?
13:28:37 <baaba> @pl (True &&)
13:28:37 <lambdabot> (True &&)
13:28:46 <Ezla> so `elem` is truly ambiguous withoout the ` `
13:28:47 <Ezla> ?
13:28:48 <lilac> conal: not much
13:29:07 <conal> hm.  i wonder why not.
13:29:13 <sw17ch> Ezla: it's not so much ambiguous as it doesn't mean what you think it does
13:29:31 <lilac> conal: by my rough stopwatching, it's down from 3s to fill the 1s audio buffer to 2s :)
13:29:32 <Ezla> ` <-- switches mode
13:29:37 <Ezla> into some other layer of concepts
13:29:47 <sw17ch> 1 `elem` [1,2,3] is the same thing as elem 1 [1,2,3]
13:29:49 <vincenz> Ezla: it's purely a parsing tryick
13:29:51 <sw17ch> you understand that, correct?
13:29:54 <Ezla> is there any `term1 term2`  ?
13:29:55 <vincenz> Ezla: exp :: exp op exp
13:30:01 <lilac> Ezla: ` around an identifier turns it into an infix operator
13:30:02 <vincenz> Ezla: exp :: fun args
13:30:02 <Ezla> or is it always `foo`
13:30:09 <vincenz> op :: `ident`
13:30:11 <lilac> it's always `foo`
13:30:16 <lilac> otherwise it'd be ambiguous
13:30:22 <Ezla> it would make sense if there was a `foo bar`
13:30:26 <conal> lilac: kthx
13:30:36 <lilac> or at least, nesting them would be ambiguous
13:30:37 <baaba> `baz` where baz = foo bar
13:30:42 <vincenz> Ezla: it's purely syntactical, that would be more complicated.
13:30:49 <baaba> well, x `baz` y where baz = foo bar
13:30:56 <baaba> (or foo . bar or whatever you like)
13:31:12 <vincenz> baaba: erm
13:31:19 <Ezla> I guess I just have to accept haskell as it is for a while
13:31:26 <Ezla> although many of the things seem very odd to me
13:31:27 <vincenz> x `baz` y where baz = foo . bar   === foo (bar x) y
13:31:46 <lilac> Ezla: "foo bar `baz` quux" is basically sugar for "baz (foo bar) (quux)"
13:31:46 <baaba> i expect that's what ezla was going for with `foo bar` ?
13:31:51 <pumpkin_> @hoogle (a -> b) -> [a] -> [(b, [a])]
13:31:52 <lambdabot> No results found
13:31:52 <Ezla> what's === ?
13:31:53 <pumpkin_> lambdabot down?
13:31:53 <sw17ch> Ezla: if you're from a procedural background (which by all appearances, you are) get used to that feeling
13:32:00 <pumpkin> @hoogle (a -> b) -> [a] -> [([a], b)]
13:32:00 <lambdabot> No results found
13:32:03 <pumpkin> boo
13:32:04 <lambdabot> pumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
13:32:11 <lilac> Ezla: just some random notation that vincenz was using
13:32:18 <lilac> to mean 'means the same as'
13:32:25 <idnar> pumpkin: what would that do?\
13:32:34 <Ezla> damn you vincenz, keep using random notation and you'll end up with your own programming language
13:33:03 <dolio> @type select
13:33:04 <lambdabot> Not in scope: `select'
13:33:12 <sw17ch> Ezla: that's normal aroudn here
13:33:12 <pumpkin> idnar: I'm looking for something like "classify" that takes a function that maps from a type to an Eq-able type, and generates a list of lists with those objects classified by that function... not sure if that makes sense...
13:33:22 <idnar> pumpkin: oh, I see
13:33:45 <pumpkin> idnar: know of anything like that? closest I can see is groupBy, but that's a bit more painful for my use case
13:34:04 <mrd> pumpkin: try using Data.Map.insertWith?
13:34:06 <idnar> that's what I was about to suggest
13:34:19 <lilac> pumpkin: groupBy (`on` f) ?
13:34:27 <dolio> @type let select [] = [] ; select (x:xs) = (x, xs) : map (second (x:)) (select xs) in select
13:34:28 <lambdabot> forall d. [d] -> [(d, [d])]
13:34:41 <dolio> @let select [] = [] ; select (x:xs) = (x, xs) : map (second (x:)) (select xs)
13:34:42 <lambdabot>  Defined.
13:34:45 <mrd> lilac: would have to sort too
13:34:52 <mrd> group only works on consecutive elts
13:34:55 <lilac> mrd: true :)
13:35:00 <dolio> @type \f -> fmap (first f) . select
13:35:02 <lambdabot> forall c d. (d -> c) -> [d] -> [(c, [d])]
13:35:35 <lilac> pumpkin: do you have an Ord for your type too?
13:35:36 <Cale> pumpkin: Ord rather than Eq would make it more efficient.
13:35:46 <mrd> yea then you can use Data.Map
13:35:47 <pumpkin> hmm, I could easily mke it Ord
13:35:58 <Ezla> > add3 :: Int -> Int -> Int -> Int; add3 x y z = x + y + z
13:35:59 <Ezla> ^---- (Int Int Int) -> Int    would seem more logical to me.. why does x -> y -> z?
13:35:59 <lambdabot>       Overlapping instances for Show (Int -> Int -> Int -> Int)
13:35:59 <lambdabot>        arisin...
13:36:00 <pumpkin> Eq seems most general, but I just need it to work right now :)
13:36:06 <mrd> @hoogle insertWith
13:36:07 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
13:36:07 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
13:36:07 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
13:36:35 <mrd> insertWith (++) is nice for adding things into lists indexed by key
13:36:36 <Ezla> is that because you can partially evaluate?
13:36:37 <pumpkin> so I'd have a map from my classifier outputs to lists, and use insertWith (++) ?
13:36:38 <baaba> Ezla, because everything's curried by default - you could read that as Int -> (Int -> (Int -> Int))
13:36:52 <Ezla> okay
13:37:02 <athos> mm_freak: is your monads tutorial already online?
13:37:18 <mm_freak> athos: an unfinished version is online
13:37:36 <Ezla> baaba.. Can you show me some Haskell stuff that's directly similar to C++ templates?
13:37:55 <Ezla> template templates, specialization, etc
13:37:55 <mm_freak> athos: http://streitmacht.eu/.beta/monads.html
13:38:00 <Ezla> partial specialization
13:38:01 <lambdabot> Title: Monads in Haskell
13:38:13 <athos> mm_freak: thanks
13:38:26 <mm_freak> athos: i'd be grateful for any comments, including constructive criticism
13:38:47 <dolio> @type \f l -> do (x,xs) <- select l ; let (yes, no) = partition (on (==) f x) xs ; return (f x, yes)
13:38:48 <lambdabot> parse error (possibly incorrect indentation)
13:39:27 <dolio> @type \f l -> do { (x,xs) <- select l ; let { (yes, no) = partition (on (==) f x) xs } ; return (f x, yes) }
13:39:28 <lambdabot> forall d b. (Eq b) => (d -> b) -> [d] -> [(b, [d])]
13:39:35 <sw17ch> Ezla: well... if you mean the full polymorphism you can achieve with templates... then we have that by default...
13:39:38 <sw17ch> for the most part
13:39:42 <sw17ch> with type variables
13:39:44 <lilac> Ezla: if you can say what it is you want to accomplish with templates, we might be able to tell you how that would be accomplished in hasell
13:39:47 <lilac> *haskell
13:39:50 <Ezla> templates aren't polymorphic
13:39:57 <Ezla> D is hoping to do that someday, though
13:40:09 <Ezla> actually, D does it now
13:40:19 <sw17ch> Ezla: isn't one of their benefits the fact that you can get polymorphic functions with them?
13:40:23 <Ezla> just without builtin keywords
13:40:27 <pumpkin> mm_freak: you should set up a comment system on the article itself, like the RWH site has :)
13:40:32 <pumpkin> write it in happs!
13:40:42 <Ezla> sw17ch: no
13:41:01 <Ezla> although, you could use templates to generate N derived classes
13:41:02 <pumpkin> mm_freak: or maybe dons will let you use the one they use for RWH :o
13:41:14 <sw17ch> Ezla: what comparison do you want between haskell and C++
13:41:19 <mm_freak> pumpkin: not yet…  i'll finish it first, and then i'll advertise it on my blog
13:41:37 <Ezla> polymorphism in C++ is entirely the runtime system
13:41:45 <sw17ch> (i've always used templates to make polymorphic functions.... perhaps i was accidentally the whole template)
13:41:48 <pumpkin> mm_freak: your blog? :o
13:41:48 <Ezla> whereas templates are static
13:42:15 <mm_freak> pumpkin: http://blog.ertes.de/ — it's quite virgin, though
13:42:21 <lambdabot> Title: Chaos Folded
13:42:29 <pumpkin> thanks :)
13:42:31 <Ezla> sw17ch: we usually call that overloading
13:42:32 <mm_freak> i've had another blog before, but that one was in german
13:42:49 <mm_freak> and it was quite non-technical =)
13:42:58 <sw17ch> ah, so where i'm using the term "ploymorphic" loosely with C++... you are using it strictly
13:43:19 <Ezla> polymorphism is when you have an interface with a virtual table and you create derived classes of the interface with common methods. then you can use a collection of "Animals" and each type: Dog, Pig responds to the same methods, through a Baseclass pointer
13:43:21 <sw17ch> Ezla: any way.. it's hard to make a comparison unless you have some example that you want
13:43:44 <lilac> Ezla: in the wider world, polymorphism means something else...
13:44:20 <sw17ch> the map function is polymorphic over any type
13:44:23 <sw17ch> :t map
13:44:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:44:38 <Cale> Ezla: Polymorphism is where you have a value which can belong to more than one type.
13:44:38 <dolio> That's subclass(type?) polymorphism. It's not the only kind of polymorphism.
13:44:40 <Varan> http://hpaste.org/12588 : I am having trouble getting my IO types right .. how can i get the function processInput to get a IO (Board,String) ?
13:44:46 <Ezla> Cale: Yeah
13:44:50 <Varan> or some other way to get it working
13:44:56 <Cale> (in the more general sense)
13:44:59 <Varan> IO stuff is still a bit vage for me
13:45:11 <Ezla> I suspect sw17ch's idea of polymorphism is Haskell influenced
13:45:12 <Cale> Ezla: What you were thinking of is subtype polymorphism, which Haskell doesn't have.
13:45:17 <roderyk> OT: anybody know of a way to download an html file with all external css files appended automatically within the page? (don't really care if this would be a firefox extension, wget flag, or haskell module)
13:45:21 <Ezla> since you guys deal in static types
13:45:32 <Ezla> as do templates
13:45:41 <opqdonut> in our world, all types are static
13:45:56 <sw17ch> Ezla: i think mine is the more general concept of polymorphism
13:45:57 <Cale> Dynamic types aren't really types :)
13:46:01 <opqdonut> Varan: well just "processInput foo = do (board,move) <- foo; <the_rest>"
13:46:25 <Ezla> if you read Wikipedia
13:46:28 <sw17ch> Haskell has the tendancy to make your mind work generically whenever possible
13:46:31 <Ezla> their entry is what I said
13:46:32 <Ezla> http://en.wikipedia.org/wiki/Polymorphism_(computer_science)
13:46:33 <lambdabot> Title: Type polymorphism - Wikipedia, the free encyclopedia
13:46:36 <lilac> Varan: processInput :: (Board, String) -> IO (Board, String)
13:46:37 <opqdonut> Varan: or more clearly: "processInput foo = foo >>= \(board,move) -> do <the_rest>"
13:46:42 <sw17ch> Now if you read it, it says polymorphism is about goats.
13:46:43 <Ezla> "In computer science, polymorphism is a programming language feature that allows values of different data types to be handled using a uniform interface."
13:46:45 <sw17ch> :)
13:46:45 <lilac> Ezla: http://en.wikipedia.org/wiki/Type_polymorphism
13:46:46 <lambdabot> Title: Type polymorphism - Wikipedia, the free encyclopedia
13:46:48 <opqdonut> Varan: you float the pure function "inwards"
13:46:57 <Ezla> whereas with Templates in C++, you cannot do that
13:47:00 <Varan> float in wards?
13:47:01 <sw17ch> Ezla: but it doesn't say anything there about classess and subclasses
13:47:01 <Ezla> no uniform interface
13:47:26 <sw17ch> Ezla: you still need to give us an example to translate/explan/something
13:47:27 <opqdonut> Varan: well nevermind, did you understand the code i pasted?
13:47:28 <Cale> Ezla: oh?
13:47:32 <sw17ch> we're arguing over a definition we all agree on
13:47:38 <Varan> yeah i think so
13:47:40 <Cale> Ezla: Are you referring the need to supply explicit type parameters?
13:47:47 <Cale> to*
13:47:48 <opqdonut> Varan: instead of passing a (board,move) we pass an _action_ foo that returns a (board,move)
13:47:55 <dolio> That's because C++ stinks. :)
13:48:02 <Varan> I was wondering how to make the args IO
13:48:09 <Varan> yeah
13:48:29 <Varan> what is >>= ?
13:48:34 <lilac> Cale: I assume Ezla means that, because C++ says that different instances of a function template are different functions, the interface is not uniform (you call different functions at different types)
13:48:36 <p_l> ... C++ templates and polymorphism? Since when? When they managed to overload negation on pointer to the point I couldn't make if(!pointer) work?
13:48:40 <opqdonut> Varan: it's a monad operator
13:48:43 <opqdonut> :t (>>=)
13:48:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:48:47 <Varan> hmm owke
13:48:48 <Ezla> thats true lilac
13:49:01 <Varan> i still have to try to understand monads :P
13:49:04 <pumpkin> @type IntMap
13:49:06 <lambdabot> Not in scope: data constructor `IntMap'
13:49:20 <Ezla> However
13:49:30 <opqdonut> Varan: heh okay :) using IO is a good start
13:49:33 <Ezla> the different overloaded functions dont have to even do the same thing or take the same signature
13:49:39 <Ezla> there's no interface
13:49:46 <Cale> Varan: If x is any action, and f is a function from possible results of that action, to further actions, then x >>= f is an action which when run, will run x, getting some result v and then run f v
13:49:52 <Ezla> they can be incompatible with a given set of args
13:50:02 <Ezla> polymorpishm, however, is always compatible
13:50:15 <Cale> Varan: If you're familiar with do-notation,  x >>= f = do v <- x; f v
13:50:16 <Varan> opqdonut: it is that I HAVE to use IO :P
13:50:20 <Varan> hmm
13:50:26 <Varan> i think i understand a bit :)
13:50:29 <Varan> thanks
13:51:07 <pumpkin> @instances Enum
13:51:08 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
13:51:17 <opqdonut> Varan: np and good luck :)
13:51:22 <lilac> Varan: the best thing would be to make 'processInput' recursive, i think
13:52:18 <Ezla> however I'm glad to see you guys think of stuff different cause its making me think of ways of functions or templates being polymorphic
13:52:21 <dolio> 'template<typename T> T id(T x) { return x }' works for any type.
13:52:22 <Varan> hmm new problem...
13:52:28 <lilac> Varan: instead of 'return (afterBoard, newMove)', you can say 'unless (move == "Quit") (processInput afterBoard, newMove)'
13:52:30 <dolio> (Think I got that syntax right.)
13:52:59 <Varan> lilac, I tryed very hard not to make it recursive ... because that would be slower
13:53:10 <dolio> Oops, missed a semicolon.
13:53:16 <Ezla> dolio: as long as you only use it that way, sure
13:53:18 <Cale> I don't see how templates are not just a strange version of parametric polymorphism... with some dependent typing thrown in.
13:53:27 <Varan> lilac, it will have about 50 calls
13:53:32 <Ezla> Cale: because
13:53:44 <dolio> Cale: It has totally ad-hoc constrained parametric polymorphism, too.
13:53:44 <lilac> Varan: how do you think 'until' works? :)
13:53:44 <Cale> (since templates can have not just type, but value parameters)
13:53:51 <lilac> @src until
13:53:51 <lambdabot> until p f x | p x       = x
13:53:51 <lambdabot>             | otherwise = until p f (f x)
13:53:53 <Varan> hmm owke
13:53:53 <Varan> :P
13:54:06 <dolio> (At least, until concepts come into wide use, I guess.)
13:54:18 <Ezla> template <class> struct Poly; struct Poly<int> { static const bool = true; }; struct Poly<float> { void f() {} };   <-- there's NO interface
13:54:28 <Ezla> they both return totally incompatible results
13:54:42 <lilac> Ezla: that's not a function though :)
13:54:47 <Ezla> I shortened it
13:54:53 <Ezla> it does need template<>
13:55:13 <Ezla> lilac: yeah but
13:55:20 <Ezla> In the template system, classes are functions
13:55:24 <dolio> Polymorphism isn't the only thing you can do with templates. But it's one thing.
13:55:33 <pumpkin> @infixity &&&
13:55:34 <lambdabot> Unknown command, try @list
13:55:37 <pumpkin> @list
13:55:37 <xmon00b> i have a curiosity to satisy
13:55:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:55:45 <Ezla> template <class X> class addPointer { typedef T* result; }
13:55:49 <Ezla> err X*
13:56:00 <vincenz> @let until2 p f x = head . dropWhile (not . p) . repeat f $ x
13:56:00 <lambdabot>  Couldn't match expected type `a -> [a1]'
13:56:02 <pumpkin> is there a way to easily see what the fixity of an operator is?
13:56:03 <vincenz> :t repeat
13:56:05 <lambdabot> forall a. a -> [a]
13:56:05 <Ezla> in C++, we use classes as functions as often as we use them as objects
13:56:09 <vincenz> :t replicate
13:56:09 <xmon00b> y do most haskell coders tend to use single letter vars instead of something more self-documenting?
13:56:10 <lambdabot> forall a. Int -> a -> [a]
13:56:17 <vincenz> :t iterate
13:56:19 <lambdabot> forall a. (a -> a) -> a -> [a]
13:56:21 <lilac> dolio: re your id example, if someone adds "void id(bool x) {}", you lose your parametric polymorphism (or at least its uniformity)
13:56:25 <vincenz> @let until2 p f x = head . dropWhile (not . p) . iterate f $ x
13:56:26 <lambdabot>  Defined.
13:56:26 <pumpkin> xmon00b: makes for less bloated code, which makes the structure stand out more :P
13:56:33 <Ezla> classes are static functions
13:56:38 <dibblego> xmon00b, types make for better documentation than English terms
13:56:39 <pumpkin> @slap pumpkin
13:56:40 * lambdabot jabs pumpkin with a C pointer
13:56:46 <Cale> xmon00b: Because variables don't tend to stay in scope for very long, and are often too polymorphic to be given more meaningful names.
13:56:48 <xmon00b> word
13:56:53 <lilac> Ezla: you'd get ridiculously flamed for saying that in ##c++ :)
13:56:55 <Ezla> you can't write a static function with a regular function
13:57:00 <Ezla> Lilac: No
13:57:02 <xmon00b> i like all the answers
13:57:10 <Ezla> Lilac: I wouldn't, most people know template metaprogramming these days
13:57:14 <Ezla> it's common
13:57:15 <dolio> lilac: Yeah, well, C++ clearly isn't the epitome of theoretically clean language design. :)
13:57:29 <xmon00b> the downside, however
13:57:29 <Varan> http://hpaste.org/12589 : I have a new problem now ... the board and move vars are not known to the where .... i could try to make doMove IO but i am trying to keep IO away from those functions
13:57:31 <vincenz> dolio: That's an understatement :)
13:57:34 <pumpkin> @src &&&
13:57:35 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
13:57:42 <pumpkin> is there no way to determine its fixity?
13:57:46 <lilac> Ezla: you mean, template classes can be used as a functional language which runs at compile time then?
13:57:49 <pumpkin> other than experimentation
13:57:51 <xmon00b> is that it is more difficult for ppl coming from outside the project to grasp what is happening
13:57:53 <Ezla> http://www.boost.org/doc/libs/1_37_0/libs/mpl/doc/tutorial/higher-order.html
13:57:53 <lilac> Ezla: because "static function" means something quite different...
13:58:00 <xmon00b> but it does make for nice looking code
13:58:04 <lambdabot> Title: THE BOOST MPL LIBRARY: Higher-Order Metafunctions, http://tinyurl.com/5se9tz
13:58:43 <lilac> Ezla: also, in my experience, commerical software doesn't use much template metaprogramming
13:58:45 <Cale> xmon00b: The idea should be to give meaningful names to variables which stay in scope for a long time.
13:58:49 <xmon00b> Ezla: don't functions execute more quickly than classes?  personally, i use the appropriate construct for the purpose
13:58:59 <Cale> xmon00b: If something is only in scope for 3 lines, you can see where it's defined.
13:59:00 <Ezla> lilac: Except commercial software uses Boost
13:59:07 <Ezla> they leave the hard work up to the libraries
13:59:14 <Ezla> the whole of C++ uses template MP now
13:59:18 <Ezla> ie, std::function
13:59:21 <xmon00b> Cale: that is a good point for me to ponder upon.. i generally only use single letter vars for incrementers and such
13:59:23 <Ezla> and std::tuple
13:59:34 <Cale> xmon00b: So you shouldn't have any problem understanding what it is -- on the other hand, if something is defined in a separate module, you would hope it has a good memorable name.
13:59:39 <lilac> Ezla: sure, but that's only a small part of any given program
13:59:56 <Ezla> nowadays, not really lilac, "bind" is bread and butter
14:00:08 <Ezla> bind is like partial
14:00:30 <lilac> Ezla: we have 1M LOC, and perhaps a dozen uses of std::function, and not many more uses of bind
14:00:37 <pumpkin> right now, I have classify f = toList . IM.fromListWith (++) . map (fromEnum . f &&& (:[]) . id), but I'm losing the original enum
14:00:52 <xmon00b> Cale: ya, but when you look at the code from a different perspective, it makes it quite difficult.. just looking at the xmonad stuff i don't get what all the single letter stuff is since it is used repeatedly in different scopes.. it's all very hard to follow w/o reading a book first
14:00:57 <lilac> Ezla: other C++ houses i've worked have had less. likewise in KDE
14:01:01 <Ezla> lilac, my views on this are skewed by Online usage.. not corporate legacy codebases... the guys on ##C++ are nuts for using that stuff
14:01:02 <pumpkin> can anyone see a way to get the original enum back, without mapping over the output to convert it?
14:01:04 <Ezla> and try to use it nonstop
14:01:09 <Cale> xmon00b: hmm
14:01:33 <Ezla> Also, 1 shop isnt all shops
14:01:38 <Ezla> some shops are boost shops.
14:01:44 <Ezla> some are "memory" code.
14:01:52 <lilac> Ezla: in commercial software, it's important to write code which everyone on your team understands. and (i forget where this stat is from) 80% of C++ programmers know only 20% of C++
14:01:54 <Ezla> You work with memory, classes, and functions.
14:02:01 <Ezla> It's not about syntax, but about semantics.
14:02:20 * vincenz uses templates and partial specialization at work
14:02:25 <Ezla> lilac: Not so much these days
14:02:28 <Ezla> that was true 5 years ago
14:02:32 <Ezla> everyone knows templates nw
14:02:34 <Ezla> now
14:02:45 <pumpkin> does anyone actually use multiple inheritance for anything more than the equivalent of java interfaces?
14:02:55 <Ezla> pumpkin: mixins
14:02:56 <lilac> Ezla: "everyone". do you have any research papers handy on this?
14:03:05 <pumpkin> Ezla: ah, true
14:03:09 <xmon00b> it makes things very confusing... especially with no $s and stuff.. i'm like.. is that a var or a function or some wierd construct i don't know about?  for instance, the xmo stuff rulz in its structure.. but it is so ambigious that it could really be doing anything
14:03:21 <Ezla> lilac: just based on years of #C++ and watching people change since 2003
14:03:23 <gwern> 'The only arguments that hold water, in terms of programming language suitability, are bold, finished projects. Not a mini-Emacs written in Haskell. Not a Sudoku solver in Prolog. Not a rewrite of some 1970s video game using Functional Reactive Programming. They need to be large and daring projects, where the finished product is impressive in its own right, and then when you discover it was written in language X, there's a wave of ...
14:03:29 <gwern> ... disbelief and then a new reverence for a toolset you had previously dismissed. '
14:03:32 <xmon00b> especially since you can put things like var1 var2 = var2 var1
14:03:32 <gwern> http://prog21.dadgum.com/35.html
14:03:38 <lambdabot> Title: prog21: Timidity Does Not Convince
14:03:42 <lilac> Ezla: are you a professional programmer?
14:03:50 <xmon00b> heh, w/o context it makes nooooooooooo sense to someone more traditional
14:03:57 <Ezla> granted, the corporate world can have some odd microcosms
14:04:16 <Cale> xmon00b: Do you actually know Haskell?
14:04:20 <Ezla> yeah, lilac
14:04:23 <vincenz> gwern: ouch
14:04:28 <xmon00b> no, that's what i'm saying
14:04:30 <Ezla> read everday C++ magazine articles
14:04:32 <Ezla> its all template code
14:04:35 <lilac> Ezla: how many c++ programmers work at your company?
14:04:36 <Ezla> like Dobbs
14:04:36 <Cale> xmon00b: Ah, then that's the problem.
14:04:41 <xmon00b> it makes it hard to get my head around w/o reading a real book first
14:04:50 <pumpkin> xmon00b: two really good resources online
14:04:50 <Cale> xmon00b: Haskell is nothing like a traditional imperative programming language
14:04:53 <xmon00b> well yes, it most certainly is.. i cannot argue with that
14:04:54 <xmon00b> :)
14:05:00 <dcoutts> Cale: oh, I was going to tell you about some wiki spam. I can't delete pages so I couldn't do it.
14:05:01 <dcoutts> http://haskell.org/haskellwiki/?title=Special:Contributions&target=Tomso123
14:05:02 <pumpkin> xmon00b: real-world haskell, and learn you a haskell
14:05:08 <lambdabot> Title: User contributions - HaskellWiki, http://tinyurl.com/6rkb7x
14:05:08 <lilac> Ezla: and how many of them do you think could write a decent vector class?
14:05:10 <Cale> xmon00b: It's not something you can just pick up easily without doing reading.
14:05:18 <gwern> vincenz: I'm especially pained because all my hacking time for the past week or so was on that mini-Emacs clone
14:05:21 <Cale> dcoutts: I'm not a wiki admin, am I?
14:05:22 <xmon00b> ya, i noticed
14:05:23 <xmon00b> ;)
14:05:26 <Ezla> lilac: Vector class doesn't use templates at all.
14:05:30 <Ezla> except perhaps 2 lines of code
14:05:32 <dcoutts> Cale: oh, sorry, for some reason I thought you were.
14:05:43 <dibblego> Cale, neither dcoutts or I are sysop, do you know who is?
14:05:45 <nomeata> Hi. What about leskah – it hasn’t seen a commit since quite a while. Is it still being developed?
14:05:50 <lilac> Ezla: i mean implement a vector class template, not use one.
14:05:50 <xmon00b> i do dig it tho.. i have read most everything i could find on xmo and am working my way thru the haskell site
14:05:56 <vincenz> gwern: What language?
14:05:58 <xmon00b> thx pumpkin
14:06:05 <Cale> dcoutts: I was back on the old hawiki, but the new wiki admins decided not to make me one for whatever reason.
14:06:07 <gwern> vincenz: haskell...
14:06:13 <vincenz> gwern: Just doublechecking :)
14:06:16 <Ezla> lilac: Implementing a vector class template in total is 2 lines of template code.
14:06:19 <vincenz> gwern: I take it you will use dynamic loading of code?
14:06:25 <dcoutts> Cale: hmm, ok. I expect you could ask if you wanted to.
14:06:26 <gwern> Cale: a mortal insult! you should challenge them to a duel
14:06:28 <vincenz> gwern: ala lambdabot or xmonad.
14:06:30 <pumpkin> xmon00b: but I encourage you to buy the RWH book cause it's cool and everyone prefers reading real books (the rainforests will last a little longer still)
14:06:35 <lilac> Ezla: from scratch, without using STL, i mean
14:06:48 <gwern> vincenz: yi used to but now we're on the simpler xmonad-style serialize-and-restart method
14:06:52 <Cale> @where lyah
14:06:53 <lambdabot> www.learnyouahaskell.com
14:06:54 <xmon00b> pumpkin: yes, i was considering that
14:06:56 <Ezla> lilac: From scratch. Vector in STL is implemented using 2 lines of template code (or 1)
14:06:56 <Cale> @where rwh
14:06:57 <lambdabot> is http://www.realworldhaskell.org/blog/
14:07:07 <xmon00b> haha nice url lambda
14:07:07 <lilac> Ezla: show me the code then :)
14:07:18 <Ezla> lilac: vector does nothing but template T
14:07:19 <Ezla> thats it
14:07:20 <dolio> Memory management is the hard part of implementing a vector class in C++. :)
14:07:26 <Ezla> and a default template parameter for the allocator
14:07:34 <Ezla> there's no template usage there
14:07:39 <Ezla> whatsoever
14:08:33 <lilac> Ezla: my libstdc++'s vector is 423 lines excluding blanks and comments
14:08:40 <Ezla> of course
14:08:44 <Ezla> that's runtime code
14:08:50 <lilac> and you say you can do it in 2?
14:09:01 <Ezla> no, a couple lines of templates
14:09:07 <Ezla> the rest is the class
14:09:44 <Ezla> <lilac> Ezla: i mean implement a vector class template, not use one.
14:09:56 <Ezla> I assumed you were talking about templates since thats what we were talking about :P
14:09:57 <gwern> "At the IFIP congress in 1971 I had the pleasure of meeting Dr. Eiichi Goto of Japan, who cheerfully complained that he was always being eliminated."  -Donald Knuth
14:10:21 <lilac> Ezla: yes. "class template" refers to the entirety of the templated class, including its definition
14:10:37 <Ezla> lilac: hehe C++ programmers dont usually talk that way
14:11:00 <olsner> heh, love the quicksilver quote from weekly haskell news
14:11:07 <lilac> Ezla: orly?
14:11:12 <pumpkin> yarly!
14:11:18 <Ezla> templates are so common that it's just a "class"
14:11:19 <pumpkin> gnarly!
14:11:33 <Ezla> we dont say Template this, template that
14:11:38 <acidjnk> What do they say about quicksilver?
14:11:59 <olsner> @quote ACCIDENTALLY
14:11:59 <lambdabot> bd_ says: I think I accidentally implemented subtraction
14:12:08 <olsner> oh, case insensitive
14:12:18 <pumpkin> @type (toList . fromListWith (++) . Prelude.map ((fromEnum . f) &&& ((:[]) . id)))
14:12:19 <olsner> @quote the.whole.verb
14:12:20 <lambdabot> Not in scope: `toList'
14:12:20 <lambdabot> Not in scope: `fromListWith'
14:12:20 <lambdabot> quicksilver says: I ACCIDENTALLY THE WHOLE VERB
14:12:20 <dolio> @quote metacircularity
14:12:20 <lambdabot> No quotes match. Wrong!  You cheating scum!
14:12:33 <acidjnk> @quote Hg
14:12:33 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
14:12:39 <lilac> Ezla: sure, informally. and indeed, i just said "class" the first time, but i said "class template" when you didn't seem to understand
14:12:56 <Ezla> "implement a smart pointer" "implement an intrusive list class"
14:12:59 <kgoj> Hi: http://hpaste.org/12590
14:13:04 <dolio> pumpkin: M.toList etc.
14:13:18 <pumpkin> ah, trying to do it with an IntMap, so maybe IM
14:13:23 <dolio> Yeah.
14:13:24 <kgoj> I've got a problem with types, callcc and nested monads :-/
14:13:30 <pumpkin> my actual question was why it inferred Integral
14:13:33 <pumpkin> rather than Enum
14:13:39 <pumpkin> but I'll try to make it cleaner first
14:13:42 <lilac> Ezla: anyway, you never answered my question
14:13:53 <Ezla> which
14:14:09 <Cale> kgoj: a <- [1,2,3] only makes sense in the list monad.
14:14:14 <lilac> Ezla: can we take this elsewhere? it's off-topic for #haskell
14:14:42 <kgoj> Cele: I wanted to use callCC to "jump out" of the list monad
14:14:43 <Ezla> learn to program in D! #D, happily holidays
14:15:01 <Cale> kgoj: You're not using the list monad here, you're using the Cont monad.
14:15:20 <Cale> kgoj: You may want to ContT-transform the list monad.
14:15:42 <kgoj> I was thinking outer do was callCC and inner was list
14:15:50 <kgoj> Well, that's what I want it to be.
14:15:56 <Cale> er, hmm
14:16:03 <kgoj> Where do I put ConT ?
14:16:05 <Cale> ah, I see.
14:16:18 <sw17ch> lilac: I could implement a templated vector... but it wouldn't be all that hot, and i'd make heavy use of realloc
14:16:34 * sw17ch hasn't done heavy C++ work in a long time
14:17:15 <Cale> kgoj: break [] is a Cont computation.
14:17:39 <Cale> :t callCC
14:17:40 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:17:47 <lilac> sw17ch: i've done it. it was slower than the STL one, but used less memory. but i suspect most people at work (smart people!) would probably struggle with the idiosyncracies of it
14:18:10 <Cale> kgoj: break is the (a -> m b) there
14:18:16 <gwern> @src drop
14:18:17 <lambdabot> drop n xs     | n <= 0 =  xs
14:18:17 <lambdabot> drop _ []              =  []
14:18:17 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
14:19:34 <sw17ch> lilac: I had to make a vector library in C once... it worked out pretty well, but i'm positive it could have been done better/with less memory and reallocing
14:20:04 <sw17ch> lilac: i'm still not sure what he was getting at... it's like he's hunting for a chink in the Haskell armor and can't quite find it
14:20:21 <lilac> *shrug*
14:20:22 <vixey> Ezla, no ...
14:20:35 <lilac> vixey: no, you'll wake it again
14:20:45 <pumpkin> http://hpaste.org/12591 how's this look? seems overly ugly
14:20:53 <hd_> is there a simple way to print a list of tuples? (like putStrLn- but that doesn't seem to work?)
14:21:18 <jsn> hd_:  use `print` ?
14:21:24 <lilac> hd_: how do you want them formatted?
14:21:28 <jsn> pumpkin: looks fine to me
14:21:35 <pumpkin> ooh, I can replace (:[]) . id with return :o
14:21:40 <pumpkin> that makes sense!
14:22:02 <Cale> kgoj: I'll give you the closest thing I found which is well-typed
14:22:17 <ben___> How do I write \x y -> x % y == 0 in point-free?
14:22:28 <pumpkin> I wonder whether toList . IntMap.map is faster than map . toList
14:22:33 <sw17ch> @pl \x y -> x % y == 0
14:22:33 <lilac> @pl \x y -> x % y == 0
14:22:33 <lambdabot> flip flip 0 . ((==) .) . (%)
14:22:33 <lambdabot> flip flip 0 . ((==) .) . (%)
14:22:37 <hd_> yep, print did it- thanks ;)
14:22:41 <ben___> Thanks
14:22:47 <jsn> pumpkin: isn't    (:[]) . id    just the same thing as    (:[])   ?
14:22:53 <jamlo> hi
14:22:55 <jamlo> evey one
14:23:00 <pumpkin> jsn: wow, I'm even dumber than I thought :P
14:23:00 <olsner> @ty flip flip 0
14:23:01 <jamlo> any one know programing
14:23:01 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
14:23:12 <pumpkin> jamlo: nope, don't think anyone does
14:23:16 <idnar> @type (:[]) . id
14:23:17 <lambdabot> forall a. a -> [a]
14:23:18 <jsn> pumpkin: now you know
14:23:25 <idnar> heh
14:23:28 <jsn> pumpkin: and knowing is half the battle
14:23:29 <pumpkin> just pretend none of you saw that :P
14:23:38 <kgoj> Cale: Thanks, I cannot put it all together by myself.
14:23:53 <jsn> jamlo was funy
14:23:57 <pumpkin> jsn: what is better, do you think? return or (:[]) ?
14:24:07 <jsn> i think return is better
14:24:14 <pumpkin> cool
14:24:15 <jsn> it emphasizes the monadic nature
14:24:37 <olsner> I occasionally use singleton x = [x] when I just want to build a lot of single-element lists
14:24:45 <olsner> but it depends on the context
14:25:09 <Cale> kgoj: http://hpaste.org/12590#a1
14:25:11 <lament> does a dog have monadic nature?
14:25:21 <jsn> mu
14:25:23 <olsner> lament: mzero
14:25:24 <jsn> :)
14:25:30 <lament> haha
14:26:21 <jsn> for those who didn't get that, the classical answer to "does a dog have a buddha nature" is "nothingness"
14:26:22 <kgoj> Cale: thanks, that's what I wanted
14:26:33 <olsner> monadic koans, we should have a wiki page for those
14:26:41 <jsn> in chinese, it's said "wu", but in japanese it's said "mu"
14:26:49 <Cale> kgoj: Though, it's a little silly.
14:27:02 <Cale> kgoj: It doesn't necessarily do quite what you're looking for.
14:27:04 <jsn> and "mu" is the multiply, &c.
14:27:17 <lilac> @type \f -> groupBy ((==) `on` f) . sortBy (compare `on` f) -- pumpkin
14:27:19 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [[a]]
14:27:24 <pumpkin> 公案
14:27:34 <Cale> kgoj: for instance, try replacing that line with break with   when (even (a+b)) $ break []
14:27:52 <pumpkin> lilac: I wonder which is more efficient, I'll test them both and see
14:27:55 <pumpkin> lilac: thanks
14:27:57 <Cale> kgoj: The list monad already can manage that, without ContT.
14:28:08 <olsner> hmm, I'd like a counterpart for $ such that f € foo $ bar == f (foo) (bar)
14:28:21 <lilac> lament: Mu Dog?
14:28:28 <olsner> when € not True $ do it
14:28:37 <Cale> olsner: I would like that counterpart to be $
14:28:37 <kgoj> Cale: I used list when I tried to reduce my problem with Yi's BufferM
14:29:06 <pumpkin> @hoogle on
14:29:07 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:29:07 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
14:29:07 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:29:08 <Cale> olsner: It would just have to associate the other way.
14:29:48 <lilac> lament: perhaps a better punchline might be In (Left ())
14:30:09 <lilac> lament: which is mzero of the Mu (Either ()) monad :)
14:35:42 <opqdonut> lilac: indeed ;)
14:36:24 <ushdf> haskell is awesome
14:40:09 <nomeata> ushdf: any specific reason?
14:40:56 <hackage> Uploaded to hackage: hake 1.1
14:54:20 <dolio> > 99*99
14:54:21 <lambdabot>   9801
14:54:30 <Cale> http://www.superpoop.com/120108/divisible-by-zero.jpg
14:54:44 <mausilein3> hi
14:55:09 <mausilein3> hallo bin neu hier
14:55:21 <mausilein3> aha
14:55:40 <jsn> wir sprechen englisch
14:55:41 <Botje> hi mausilein3
14:56:12 <mausilein3> hi botje bin neu hier bin w
14:56:19 <pumpkin> ドイツ五が分からない
14:56:35 <jsn> could (+) be in MonadPlus?
14:56:43 <jsn> not for Float and Double, I guess
14:56:45 <mausilein3> bin deutsche
14:57:04 <jsn> mausilein3: bin american
14:57:05 <ChilliX> pumpkin, wrong kanji for language ;)
14:57:06 <mausilein3> wier ist deutsch
14:57:13 <pumpkin> whoops, sorry
14:57:14 <jsn> ah
14:57:17 <mauke> schnitzelkraut!
14:57:17 <pumpkin> 語
14:57:22 <ChilliX> :)
14:57:26 <pumpkin> german5
14:57:28 <pumpkin> lol
14:57:31 <pumpkin> germany5
14:57:46 <ben___> heil haskell
14:57:59 <yitz> @seen lambdabot
14:58:00 <lambdabot> Yes, I'm here. I'm in #macosxdev, #haskell-blah, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #
14:58:00 <lambdabot> haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #
14:58:00 <lambdabot> dreamlinux-es, #darcs, #concatenative, #arch-haskell, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
14:58:03 <mausilein3> wier kann deutsch bitte
14:58:04 <jsn> mausilein3: vielleicht #haskell-de
14:58:19 <jsn> ah
14:58:19 <pumpkin> .de
14:58:23 <jsn> #haskell.de
14:58:24 <mauke> no entries found for 'wier'. did you mean 'bier'?
14:58:30 <mausilein3> hi jsn kannst dsu deutsch
14:58:42 <ChilliX> mauke: meant "wer"
14:58:43 <jsn> nur ein bisschen
14:58:55 * profmakx speaks german
14:58:58 <mausilein3> aha ok jsn
14:59:01 <jsn> ChilliX: "wer" is "who"
14:59:12 <ziman> ant "wo" is "where" :P
14:59:12 <mauke> wo is where
14:59:13 <ChilliX> jsn: yep
14:59:15 <ziman> *d
14:59:17 <mausilein3> und was bitte jsn
14:59:21 <mauke> ant is ameise
14:59:29 <ChilliX> mauke: lol
14:59:39 <ChilliX> and Haskell is Haskell (to stay on topic)
15:00:26 <jsn> mausilein3: mein deutsch is nicht gut
15:00:51 <mausilein3> das aber schade jsn
15:00:53 <mauke> der kürschner punzt der metze zagel.
15:01:15 <jsn> ich habe in gymnasium studierien, das ist alles
15:01:40 <jsn> hast du fragen uber haskell ?
15:01:42 <mausilein3> das ist doch  auch gut  jsn
15:02:27 <mauke> HALT PAPIRE, BITTE!@!
15:03:07 <mausilein3> ich gehe jetzet wieder ok schau alle
15:03:08 <jsn> mit ein bisschen gramatik und internet, veilleicht kann ich deine frage antworten
15:03:16 <jsn> mausilein3: tschus
15:03:24 <Botje> what's concatMap in german? :)
15:03:27 <mausilein3> schau
15:03:35 <kgoj> How can I get exact type signature of an expression (eg. via error message)?
15:03:42 <yitz> mauke: i think you just killed iblechbot
15:03:44 <ChilliX> jsn: do you know what mausilein means?
15:03:51 <laz0r> Botje: verbundKarte
15:03:57 <jsn> Botje: koncatMapenSchnitzel
15:03:58 <laz0r> or something like that
15:03:59 <Botje> heh heh
15:04:00 <opqdonut> kgoj: :t in ghci for example
15:04:03 <Botje> laz0r++
15:04:07 <jsn> ChilliX: yeah
15:04:09 <opqdonut> :t [undefined]
15:04:11 <lambdabot> forall a. [a]
15:04:11 <jsn> he didn't say anything hard
15:04:20 <opqdonut> kgoj: lambdabot can do it too :>
15:04:20 <jsn> he was just like, you speak german?
15:04:29 <jsn> and i said, oh, a bit, in high school
15:04:39 <mauke> but do you know what "mausilein" means?
15:04:48 <jsn> oh
15:04:50 <jsn> haha
15:04:53 <kgoj> Yes, but It's not top-level. It's deep inside 'let's and 'do's
15:04:54 <cjb> might be a diminuitive on maus
15:04:58 <cjb> (mouse)
15:04:59 * mauke is now known as schmusebaer
15:05:14 <ChilliX> jsn: yeah, I know, but the nick suggests that he is just a channel hoper and not anybody seriously looking to talk about Haskell
15:05:15 <cjb> e.g. frau = mrs, fraulein = midd
15:05:20 <cjb> s/midd/miss/
15:05:23 <ChilliX> (and posing as a female while doing that)
15:05:26 <jsn> interesting, it only has two hits on google
15:05:29 <opqdonut> kgoj: well you can do stuff like:
15:05:31 <cjb> so.. an unmarried mouse.  yeah, that's it.
15:05:32 <jsn> what does it mean?
15:05:44 <mauke> Ergebnisse 1 - 10 von ungefähr 22.900 für mausilein
15:05:46 <opqdonut> :t [undefined :: Int->Int]
15:05:48 <lambdabot> [Int -> Int]
15:05:56 <opqdonut> and try to build something like the expression you have
15:05:57 <ChilliX> cjb: yeah, it is the diminutive of mouse
15:06:17 <jsn> why is there an 'i' in it?
15:06:21 <mauke> darling/honey
15:06:29 <cjb> jsn: because it sounds cuter that way
15:06:32 <opqdonut> or then just give it for instance type () (with a ::() type sig) and read the real type from the error message
15:06:38 <jsn> ah, okay
15:06:47 <mauke> because it's the diminutive of mausi
15:07:02 <ChilliX> mauke: hehehe :)
15:07:34 <ChilliX> anyway, just pointing out that somebody with that nick is unlikely to be wanting to talk about Haskell
15:07:36 <jsn> oh, Mausi is German for "my pet", basically
15:07:49 <laz0r> mausilein is a schnulziger nick
15:07:50 <jsn> i try to make people prove to me that they are acting in bad faith
15:07:52 <cjb> oh, cool
15:08:05 <ChilliX> yeah, but it is also a collociqual term for sweartheart
15:08:11 <jsn> http://www.dict.cc/german-english/Mausi.html
15:08:12 <lambdabot> Title: dict.cc dictionary :: Mausi :: English-German translation
15:08:16 <mauke> haha, sweatheart
15:08:25 <ChilliX> lol
15:08:26 <jsn> ChilliX: that's what i meant
15:08:38 <ChilliX> (so much for typing)
15:08:43 <jsn> as in, "no sweat, my pet" said by the undead
15:08:49 <opqdonut> somebody with the nick ChilliX can't possibly be serious about wanting to talk about haskell
15:09:02 * ChilliX sulks.
15:09:07 <opqdonut> ^_^
15:09:10 <mauke> opqdonut: he didn't claim to be female up front
15:09:12 <ChilliX> opqdonut: that is not fair!
15:09:25 <ChilliX> mauke: yes, good point
15:09:27 <jsn> opqdonut: yeah, if they were serious, it would be    chillax'    with an apostrophe
15:09:37 <ChilliX> besides, I have a history of talking about Haskell...constantly
15:09:37 <opqdonut> chillax'functor
15:09:54 <talkerAboutHaske> oof, character limit on nicks
15:10:10 <haskellTalker> there
15:10:15 <opqdonut> hi haskellTalker
15:10:19 <opqdonut> wanna talk about haskell?
15:10:22 <mauke> hah, 16 chars
15:10:25 <jsn> 16 bytes should be enough for anyone
15:10:26 <mauke> efnet has a 9 char limit
15:10:38 <haskellTalker> jsn: it wasn't enough for me just now
15:10:39 <dibblego> 9 chars was the original RFC I think
15:10:42 <opqdonut> yep
15:10:50 <opqdonut> ircnet bumped it to 16 first i think
15:12:06 <Philippa> ChilliX: could've fooled me :-)
15:12:18 <ChilliX> see, that get's us talking about Haskell, because obviously imposing stupid a priori limits on string length is a C thing
15:12:29 <ChilliX> Philippa: hehe - hi
15:12:38 <mauke> ChilliX: I WANT A 3MB NICK
15:12:50 <Zao> ChilliX: If known, attaching the length of a string can be a powerful optimization.
15:13:02 <mauke> preflex: quote Yaakov
15:13:03 <preflex>  <Yaakov> I've developed a technology that will obsolete surfing the net.  It allows a user to jetski the net.
15:13:07 <mauke> no, not that one
15:13:09 <mauke> preflex: quote Yaakov
15:13:09 <preflex>  <Yaakov> I am on IPv10. The addresses are 4GB.
15:13:15 <haskellTalker> ChilliX: so every nick is someone who wants to talk about haskell - they imply that by using a nick with less than 16 characters
15:13:22 <Philippa> Zao: that's a representation trick though
15:13:40 <ChilliX> haskellTalker: hmm, I hadn't considered that...
15:14:10 <opqdonut> Philippa: it's memoising ;)
15:14:55 <opqdonut> and while we're talking about nicks, why settle with a countable amount of them
15:15:05 <opqdonut> let's identify chatters with CReals!
15:15:13 <opqdonut> i call turings omega
15:15:43 <vixey> you can make a CReal out of that. .?
15:15:51 <vixey> would like to see the code :p
15:15:58 <Philippa> opqdonut: clearly you have no imagination :-)
15:16:21 <lament> infinite nicks can make tab completion significantly more complicated
15:16:22 <Cale> I want an infinitely long string as my nick.
15:16:51 <Cale> Better yet, make it an uncomputable infinitely long string :)
15:16:55 <opqdonut> vixey: well of course for practical purposes i'd be known as <<loop>>
15:17:13 <lament> my primary nick is lament3.141592....
15:17:19 <opqdonut> a string that's order type is an unreachable cardinal
15:17:22 <lament> and my secondary nick is the same as the primary nick, but it has an extra 1 at the end
15:17:23 <opqdonut> *ordinal
15:17:23 <Cale> Oh, heh, opqdonut already thought of that :)
15:17:38 * Cale catches up :)
15:17:40 <opqdonut> :)
15:18:02 <mapreduce> > let Cale = Cale +
15:18:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:18:07 <mapreduce> gah, joke ruined
15:18:26 <lament> stupid lambdabot always ruining jokes
15:18:38 <lament> @vixen you ruined it!
15:18:39 <lambdabot> Does your mommie know you're here, little naughty boy?
15:18:49 <mapreduce> This time it was my return key coupled with typing on an asus eee about 6" from my face.
15:19:12 <Botje> you obviously need to shrink your face.
15:19:43 <lament> you obviously need to switch to the metric system
15:20:00 <mapreduce> > 6 * 2.54
15:20:01 <lambdabot>   15.24
15:20:15 <mapreduce> 15.24 centiarbitraries from my face!
15:23:53 <kgoj> I tried to adopt Cale's solution (for my reduced example with callCC and list monad) to my problem with Yi code, but either it was too specific or I'm too tired.
15:23:57 <kgoj> http://hpaste.org/12592
15:25:25 * roconnor reads kgoj paste
15:25:55 <roconnor> kgoj: BTW, undefined is not a type.  It is a value
15:26:06 <lament> :t undefined
15:26:07 <lambdabot> forall a. a
15:26:42 <shepheb> if I want to build a website in Haskell, that uses a SQL DB (no preference wihch one, really), runs on Linux, and probably uses Ajax, what's my choice for packages to do so?
15:27:14 <roconnor> @type callCC
15:27:16 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:27:20 <cjb> shepheb: hm, haven't seen any AJAX in Haskell yet
15:28:47 <mwotton> cjb: you probably wouldn't model the ajax itself in haskell, just provide some XML backend services
15:29:24 <mwotton> shepheb: there are a couple of open projects and no clear winner at the moment, afaict - HAppS, turbinado, plain CGI are all options
15:29:28 <mwotton> and i'm probably missing about ten
15:29:46 <mwotton> oh, hang on, HAppS doesn't like SQL. my bad.
15:30:12 <shepheb> I'm leaning towards FastCGI, but I'll give Turbinado a look
15:30:34 <gwern> mwotton: and don't forget all the blog frameworks
15:30:45 <gwern> there's like 5 of them or something
15:33:36 <roconnor> kgoj: is BufferM an instance of MonadCont?
15:34:10 <gwern> roconnor: BufferM? We discussing yi?
15:34:18 <roconnor> gwern: apparently
15:35:35 <kgoj> roconnor: No, it isn't
15:35:39 * gwern looks
15:35:42 <roconnor> kgoj: I'm not sure what you want, but you can't achieve it with what you have written.  CallCC only works in MonadCont.
15:36:03 <gwern> undefined is :: a, isn't it?
15:36:06 <gwern> :t undefined
15:36:07 <lambdabot> forall a. a
15:36:09 <roconnor> you cannot just slap on a runCont and jump out of any moand.
15:36:17 <opqdonut> :D
15:36:22 <kgoj> All my experience with call/cc comes from scheme
15:36:31 <roconnor> kgoj: ah
15:36:37 <opqdonut> ?remeber roconnor you cannot just slap on a runCont and jump out of any monad
15:36:37 <lambdabot> Good to know.
15:36:40 <roconnor> kgoj: well, that would explain your thinking
15:36:42 <opqdonut> i fixed that typo for you
15:36:43 <dolio> You can slap on a runContT. :)
15:37:08 <gwern> 'One does not simply walk into Cont!'
15:37:15 <gwern> *Cont-or
15:37:17 <roconnor> dolio: it's true ... But would that actually work?
15:37:25 <opqdonut> hmm, coCont
15:37:34 <opqdonut> almost like concoct
15:37:43 <dolio> Maybe. You might have to do a lot of lifting.
15:38:01 <gwern> hm. 'One does not simply runCont into Monador!'?
15:38:07 <roconnor> kgoj: dolio idea would be to have goToMatch :: ContT BufferM ()
15:38:08 <Lor> Composing monads is too much of a hassle.
15:38:35 <roconnor> kgoj: and then use runContT
15:38:41 <roconnor> @type runContT
15:38:42 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
15:39:21 <Lor> Not only is the actual composing pretty difficult at times, but the signatures required by monad-independent functions are pretty awful.
15:39:29 <roconnor> I suppose you'd do (`runContT` return) ?
15:39:41 <dolio> That's the idea.
15:40:27 <kgoj> http://hpaste.org/12590#a1
15:40:30 <kgoj> Like this?
15:40:42 <crickey> a girl died in 1933 by a homicidal murderer. He buried her in the ground when she was still alive.The murdered chanted, "Toma sota balcu" as he buried her. Now that you have read the chant, you will meet this little girl. In the middle of the night she will be on your ceiling. She will suffocate you like she was suffocated. If you post this, she will not bother you.Your kindness will be rewarded.
15:40:55 <kgoj> I didn't manage to understand all of it.
15:40:57 <hackage> Uploaded to hackage: AERN-RnToRm-Plot 0.1.1
15:40:57 <hackage> Uploaded to hackage: AERN-RnToRm 0.4.2
15:40:57 <hackage> Uploaded to hackage: AERN-Real 0.9.8
15:40:58 <Lor> I once had an idea of using a ContT IO as the underlying "substrate" on top of which you could implement all other monads (according to Filinski anyway), and then providing explicit casts from less effectful to more effectful monads.
15:41:03 <opqdonut> lol, crickey
15:41:45 <gwern> crickey: why would my kindess be rewarded? Wouldn't posting that be a deathsentence for anyone who disblieves it?
15:41:46 <Lor> Basically, an effect system with some kind of subeffects.
15:41:52 <gwern> seems like a very unkind thing to me
15:42:23 <FunctorSalad> @where ops -- not your youtube
15:42:24 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
15:42:39 <dolio> I'm pretty sure Fillinski has some slides where he does that with just a delimited continuation monad.
15:42:51 <roconnor> kgoj: Does that compile?
15:42:59 <dolio> Since the only thing you can't do with that is magic stuff like IO and STM and the like.
15:43:11 <roconnor> I thikn you still want "return $ (a + b)"
15:43:15 <glguy> ?
15:43:40 <Igloo> Does anyone know anything about making legible screencasts on youtube?
15:43:45 <FunctorSalad> nvm the @where ops, they're already gone
15:43:46 <lambdabot> FunctorSalad: You have 1 new message. '/msg lambdabot @messages' to read it.
15:44:17 <kgoj> roconnor: with notFound commented out it compiles
15:44:23 <FunctorSalad> maybe I'm overreacting ;)
15:44:52 <kgoj> line 24 in hpaste
15:44:56 <BONUS_> @pl \x -> f x && g x
15:44:56 <lambdabot> liftM2 (&&) f g
15:45:32 <roconnor> kgoj: http://hpaste.org/12590#a1 looks good to me
15:45:33 <roconnor> it runs
15:45:45 <roconnor> kgoj: line 24 in what paste?
15:45:53 <roconnor> http://hpaste.org/12592 ?
15:46:46 <roconnor> I mean, without line 24 you are not using your continuation, so of course it work with that line commented out :)
15:47:43 <shepheb> which module would I use, if I were using FastCGI, for connecting to a SQLite database?
15:47:44 <roconnor> kgoj: If you make the same sort of change you did with 12590, it should work for 12592
15:49:29 <kgoj> roconnor: thanks
15:49:44 <kgoj> I'll try it tomorrow, I'm too tired now
15:49:51 <kgoj> good night, everyone!
15:50:43 <juhp> morning
15:52:16 <tanob> shepheb: i guess that the same as for non-cgi apps
15:53:00 <dolio> > 8^(99*99)
15:53:01 <lambdabot>   153095529100991372112113643435926859133311042917021222448540590951791199626...
15:53:18 <shepheb> tanob: well, that's the trouble. there are a handful of SQL database connectivity modules, and it's unclear which is the best maintained, most featureful, most stable
15:53:53 <mm_freak> 7^(99*99) is probably more difficult to calculate
15:54:21 <tanob> shepheb: yes, understand, i dont have experience using fp, isnt a hdbc ?
15:54:24 <tanob> there*
15:55:15 <dolio> > length . show $ 8^(99*99)
15:55:16 <lambdabot>   8852
15:56:09 <tanob> http://software.complete.org/software/projects/show/hdbc-sqlite3
15:56:21 <lambdabot> Title: HDBC Sqlite v3 Driver - Overview - Software.Complete.Org
15:57:29 <mm_freak> > elemIndex 0 . iterate (`div` 10) $ 8^(99*99)
15:57:31 <lambdabot>   Just 8852
15:58:59 <mm_freak> > 99*99 * log 8 / log 2
15:59:00 <lambdabot>   29403.0
15:59:04 <mm_freak> > 99*99 * log 8 / log 10
15:59:06 <lambdabot>   8851.184962508038
15:59:12 <mm_freak> > ceil $ 99*99 * log 8 / log 10
15:59:14 <lambdabot>   Not in scope: `ceil'
15:59:19 <mm_freak> > ceiling $ 99*99 * log 8 / log 10
15:59:20 <lambdabot>   8852
16:01:10 <lilac> @tell conal a cleaner solution without the runtime hit: http://hpaste.org/12528#a4
16:01:10 <lambdabot> Consider it noted.
16:01:45 <mm_freak> can you @tell anyone?
16:01:50 <mm_freak> @tell mm_freak test
16:01:51 <lambdabot> You can tell yourself!
16:01:54 <mm_freak> lol
16:02:57 <conal> lilac: that implementation has a space leak.
16:02:58 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
16:03:08 <conal> lilac: it's essentially the one Chuan-kai came up with.
16:04:09 <Peaker> what's leaking there?
16:04:28 <Peaker> I wonder if I use that instead of the built in snapshot_ I can trade a block for a space leak
16:04:31 <conal> r
16:04:43 <conal> Peaker: you might.
16:05:03 <Peaker> conal: how does Behavior wrap around Reactive?
16:05:32 <conal> Peaker: a behavior is represented as a reactive time function.
16:05:45 <conal> Behavior a = Reactive (Fun Time a)
16:05:52 <conal> Peaker: is that what you were asking?
16:05:56 <Peaker> conal: ep
16:05:57 <Peaker> yep
16:06:17 <Peaker> Cool, that's what I guessed it would be, except I didn't know Fun
16:06:31 <conal> :)
16:08:57 * lament likes "Fun Time"
16:09:04 * conal too!
16:10:00 <Peaker> conal: did Reactive 0.9.6 change the names/exporters of Event/etc?
16:10:02 <conal> lilac: have you seen the implementation of (<*>) for reactive values?  it's explained in the the paper.  i bet a similar technique would work for snapshot.
16:10:08 <Peaker> conal: FRP.Reactive.Event ceased to exist?
16:10:23 <conal> Peaker: when did that module exist?
16:10:48 <Peaker> conal: FRP.Reactive is the module,  FRP.Reactive.Event is the type
16:11:14 <conal> Peaker: oh, i get it.  and Event is gone?
16:11:16 * conal looks
16:11:48 <Peaker> conal: It seems not to find it, I import FRP.Reactive qualified as R, and it claims R.Event is not there
16:11:50 <conal> Peaker: i see 'Event' exported in FRP.Reactive
16:12:06 <Peaker> conal: yeah, me too, weird. I am trying to recompile the darcs Reactive...
16:12:17 <conal> Peaker: that's mighty strange
16:12:20 <Peaker> conal: the darcs latest of Reactive has: "Ambiguous occurrence `zipWith'"
16:12:30 <shepheb> recommendation for a module to connect with SQLite?
16:12:45 <Peaker> oh wait I have local diffs there
16:13:16 <Peaker> ah, ok, my bad.  I wonder why I had those local diffs
16:13:28 <conal> k
16:13:39 <shepheb> I can see HDBC, HSQL, Takusen, but I have no context for choosing which to use
16:13:45 <roconnor> @hoogle Group
16:13:46 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
16:13:46 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
16:13:46 <lambdabot> Data.ByteString.Char8 group :: ByteString -> [ByteString]
16:14:09 <roconnor> No Data.Group?
16:15:52 <Peaker> conal: oh, I see, I just pasted lilac's code and imported internal stuff hoping it would work, its using the internal Data constructors, not types
16:17:29 <lilac> conal: where's the space leak, by the way?
16:18:04 <conal> lilac: consider r changing much more frequently than e occurs
16:18:29 <lilac> conal: not really a leak, unless e never occurs again, and never gets to MaxBound
16:18:37 <lilac> but i guess that's entirely possible :)
16:18:39 <Peaker> temporary leak
16:19:08 <conal> yeah.  a temporary leak.  could be arbitrarily large even if e has another occurrence.
16:19:25 <lilac> yep. is this fixable with some Improving magic?
16:19:28 <conal> temporary if e has more occurrences.
16:19:34 <conal> lilac: i think so.
16:19:44 <Peaker> yay, it fixes my example (trades block for leak)
16:19:49 <conal> lilac: but without having to look into Improving
16:20:06 * ksf just wrote "Haskell (I can answer questions on IRC)" into an application.
16:20:27 <Peaker> conal: btw: How hard do you think it would be to replace the GLUT stuff with SDL?  GLUT is really stupid about keyboard events (bad for games)
16:20:40 <conal> lilac: see Reactive (<*>)
16:20:48 <conal> lilac: it uses mappend on futures
16:20:56 <SamB_XP> SDL isn't that great for some stuff either ...
16:21:17 <lilac> conal: i was thinking about something with mappend on Future, but i've not seen how to make it work yet
16:21:42 <Peaker> SamB_XP: SDL+OpenGL is not great either?
16:21:55 <lilac> conal: maybe i can exploit the mappend left bias? :)
16:21:57 <Peaker> SamB_XP: just getting events and opening the window/etc
16:22:08 <conal> lilac: yeah?
16:22:49 <lilac> conal: generate a bunch of Futures at the time of the next event, and mappend them together in reverse order
16:22:59 <lilac> something evil like that :)
16:23:53 <conal> lilac: maybe.  i'm expecting something pretty simple.  comparable with Reactive (<*>)
16:25:04 <pumpkin> @hoogle ByteString -> String
16:25:05 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
16:25:05 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
16:25:05 <lambdabot> Prelude show :: Show a => a -> String
16:27:36 <Peaker> conal: I resolved #13 as duplicate of 14
16:27:53 <Peaker> (and put lilac's code in there, in the form of a patch)
16:28:06 <conal> Peaker: thank you
16:28:22 <Peaker> I can now go on developing my little game :)
16:28:32 <Peaker> (space leak is fine for now...)
16:28:39 <Peaker> (my event is regular anyhow)
16:29:54 <pumpkin> how can I convert from a String to a FilePath... I thought I didn't need explicit conversion between synonyms?
16:30:20 <conal> pumpkin: you don't
16:30:25 <pumpkin> hmm
16:30:37 <conal> as long as they're synonyms of each other and not of something else
16:30:51 <pumpkin> oh duh, yeah
16:31:10 <pumpkin> I had bound my parameter to something but was trying to curry on it anyway
16:31:17 <pumpkin> and it was a completely different error :P
16:31:33 <conal> Peaker: i added a pointer from #14 to the patch in #13
16:32:19 <sbahra> http://sequence.complete.org/node/373 - Is this still the case?
16:32:20 <lambdabot> Title: Converting a ByteString to a Double using FFI | The Haskell Sequence
16:32:20 <sbahra> It seems so.
16:32:39 <Peaker> I guess my patch is silly to comment out the existing code instead of remove it
16:32:49 <Peaker> (makes for an ugly patch too)
16:33:08 <pumpkin> lol
16:33:21 <pumpkin> is there something more elegant than fmap . fmap . fmap . fmap ?
16:34:27 <lilac> > fst . first (2*) . (1,undefined)
16:34:29 <lambdabot>   Couldn't match expected type `a -> (t, d)'
16:34:36 <lilac> > fst . first (2*) $ (1,undefined)
16:34:38 <pumpkin> maybe the fact htat I even need that many fmaps means something else is inelegant
16:34:38 <lambdabot>   2
16:34:40 <lilac> :(
16:34:47 * lilac needs a strict first
16:35:07 <Cale> pumpkin: You could wrap whatever thing it is in a newtype and define it as a Functor.
16:35:09 <Botje> > first id undefined
16:35:11 <lambdabot>   (* Exception: Prelude.undefined
16:35:19 <Botje> but first *is
16:35:22 <sbahra> Peaker, what are you working on?
16:35:23 <Botje> * undefined :)
16:35:29 <Botje> strict, even
16:35:31 <Peaker> pumpkin: you could use something like conal's:  result . fmap . second . result
16:35:47 <Peaker> sbahra: A reimplementaiton of a Python game I once wrote, in FRP (Pyun, which is a Pune clone)
16:35:51 <pumpkin> Cale: it's just because I have a CSV that I'm reading from a file, and it'll be wrapped in an IO, a Maybe (the parseCSV returns a maybe), and the CSV itself is a list of lists
16:36:11 <solussd> !pastebin
16:36:14 <pumpkin> Cale: I'm not sure a newtype is worthwhile there?
16:36:17 <solussd> hmm.
16:36:44 <lilac> conal: do you have a testcase for the space leak? i may have a fix
16:36:52 <Cale> pumpkin: Well... you might unravel some of that structure before applying the function
16:37:18 <conal> lilac: no i don't.
16:37:19 <Cale> pumpkin: If you first execute the IO action, then that layer goes away, and then handle the result with a case expression, and you're down to 2 maps
16:37:25 <pumpkin> Cale: maybe that's a good idea... it didn't look good to be directly returning IOs like that
16:38:26 <Peaker> heh, check this out: http://hpaste.org/12594
16:38:34 <Peaker> (its beginning to look like Pune)
16:39:06 <Peaker> ouch its accumulating slowness
16:39:13 <pumpkin> much nicer: csvToLabel = map . map $ toEnum . read . show
16:39:13 <pumpkin> :P
16:39:21 <solussd> I need help troubleshooting a performance issue. I wrote a version of conway's game of life in haskell (here: http://hpaste.org/12593 ), but it runs insanely slow. took over 800 seconds to draw 50 generations of a 25x25 grid. anyone willing to take a peek at my code and maybe point out where my bottleneck is?
16:40:15 <kynky> profile it ?
16:40:18 <cknapp> solussd: Can't you profile it
16:40:30 <solussd> <- new to haskell. explain. :)
16:40:34 <Peaker> conal: is there a good/efficient way to draw a long "snake", that's better than monoidB on a lot of   const behaviors containing disks in a moving position?
16:40:36 <conal> Peaker: looking good :)
16:40:39 <cknapp> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
16:40:40 <lambdabot> Title: Chapter�6.�Profiling, http://tinyurl.com/kwh6c
16:40:45 <solussd> thanks--
16:40:55 <solussd> also- is there a way to delete from the pastebin?
16:41:00 <conal> Peaker: you want to keep adding segments?
16:41:02 <pumpkin> @hoogle [a] -> [a] -> [a]
16:41:02 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
16:41:02 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
16:41:02 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:41:04 <Peaker> conal: I am mappending a moving circle to get that effect, and it seems to get slower linearly
16:41:12 <Peaker> conal: s/circle/disk
16:42:02 <SamB_XP> ... metafont?
16:42:17 <cknapp> solussd: no problem, and I don't think there is... but I'm new to haskell (and the haskell community) myself.
16:42:20 <conal> Peaker: hm.  maybe monoidB (scanlB) needs some tuning.
16:42:50 <conal> Peaker: my goal is that the simplest / most direct formulation will be very efficient.
16:43:00 <Peaker> conal: does it keep the previous result and only mappend to that? it seems like its rebuilding the whole mconcat every frame
16:43:51 <conal> Peaker: hm.  not sure, offhand.  check out the code
16:44:12 <Peaker> conal: btw, in this game I have explicit iterations (a ticker that every behavior snapshots) and I basically have a State -> State progress, rather than using integrals/etc, so that I can later add network support and not have timing sync. issues. Do you think that's a reasonable approach?
16:44:24 <pumpkin> @pl \name -> "data/" ++ name ++ "_labels.csv"
16:44:25 <lambdabot> ("data/" ++) . (++ "_labels.csv")
16:44:29 <Peaker> Its a bit non-FRP'ish
16:44:41 <conal> Peaker: i wouldn't.
16:44:55 <conal> Peaker: sounds like your implementation concerns are contaminating your model.
16:45:20 <Peaker> conal: if its a true function of local time (e.g integral) and not explicitly labeled iterations, I am not sure how I can extend this to work over a network (which is really what I'm planning)
16:45:49 <conal> Peaker: sounds like a cool & interesting problem.
16:46:23 <conal> Peaker: i'm confident it can be done.  FRP bridges bigger gaps than a network.
16:46:35 <conal> (can be done with elegant semantics)
16:46:55 <Peaker> I guess I could rely on functions of local time for now, and worry about network stuff later
16:47:08 <conal> Peaker: that's what i'd do.
16:47:11 <Peaker> maybe I'd just have to change integral/etc to be something more general that can sync over a network
16:47:59 <Peaker> I remember I saw there was a name for: R.accumE 0 ((+1) <$ R.atTimes [0,gap..]) -- remember what it was?
16:48:32 <conal> Peaker: countE_ perhaps
16:48:50 <Peaker> ah, thanks
16:49:03 <conal> Peaker: (without the atTimes ... bit)
16:49:22 <Peaker> yeah, it replaces the accumE part
16:49:44 <tanob> @hoogle concatM
16:49:44 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
16:49:44 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
16:49:44 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
16:49:49 * conal forgot to include the Monoid instance in http://conal.net/blog/posts/sequences-streams-and-segments/
16:49:52 <lambdabot> Title: Conal Elliott » Sequences, streams, and segments
16:54:03 <pumpkin> is using stuff like fromJust frowned upon?
16:54:38 <conal> pumpkin: if you understand the consequences, go for it.
16:54:39 <AnalogHole> I'm trying to follow the Daume tutorial on Haskell. I'm at chapter 9, Monads, I'm just just baffled. Can someone explain why this cross function works? Maybe it is too much for this forum, but I thought I'd ask:   http://hpaste.org/12595
16:54:42 <lament> pumpkin: yes. :)
16:54:59 <conal> pumpkin: a lot of things are frowned upon.
16:55:04 <pumpkin> i don't like how violently it fails, I'd prefer to propagate the Maybe, but it's making things uglier
16:55:22 <Riastradh> pumpkin, if you are to use fromJust, why would you have a Maybe in the first place?
16:55:44 <pumpkin> Riastradh: the parseCSV function in the ByteStream CSV parser retruns a maybe
16:56:19 <Riastradh> And what should your program do if the input fails to be parseable?
16:56:27 <Peaker> I think you can almost always refactor non-exhaustive pattern-matchers like (head, tail, fromJust) to exhaustive pattern-matches instead (The reason you know you can use head, is that you pattern matched the list some other way before, then just unite the head into there)
16:56:28 <pumpkin> fail epicly :P
16:56:41 <Riastradh> You can, by the way, fail in whatever way the caller wants like so:
16:56:59 <Riastradh> case (parseCSV ...) of (Just x) -> return x; Nothing -> fail "I couldn't parse the input; sorry!"
16:57:10 <pumpkin> yeah
16:57:28 <pumpkin> Maybe I'll Just do that, it's better than Nothing
16:57:29 <pumpkin> sorry :P
16:57:38 <Riastradh> (This is very different from fromJust.  If the caller wants a Maybe, this code reduces to the identity on `parseCVS ...'.)
16:57:46 <cknapp> AnalogHole: what don't you understand about it?
16:58:27 <pchiusano> AnalogHole, it might help to look at the desugaring of that
16:59:51 <AnalogHole> cknapp: Well, I'm not sure where to even start. It just looks like utter magic to me.
16:59:59 <lilac> conal: Max MaxValue `max` _|_ == _|_. This makes me sad.
17:01:04 <centrinia> AnalogHole, look up the definition of  (>>=) :: [a] -> (a -> [b]) -> [b]
17:01:08 <AnalogHole> pchiusano: Ok, you mean convdert it from do notation?
17:01:32 <pchiusano> right
17:01:43 <conal> lilac: it does?
17:01:50 <conal> (it does equal?)
17:01:50 <AnalogHole> centrinia: I am having problems grasping the whole binding concept. So that is part of the problem.
17:02:10 <pchiusano> @src (>>=)
17:02:10 <lambdabot> Source not found. There are some things that I just don't know.
17:02:18 <pumpkin> AnalogHole: you're redefining what it means to "pass your value" to someone
17:02:18 <Peaker> conal: can I use integral on a FieldTrip.Vector2? Is it a vector-space?
17:02:37 <conal> Peaker: try ":i Vector2" in ghci
17:02:39 <lilac> conal: well, i was blocking on it, and adding an "`unamb` case t of Max MaxBound -> Max MaxBound; _ -> undefined" unblocked me
17:02:54 <lilac> so i think so
17:03:02 <conal> lilac: hm.  let's check out the Max implementation.
17:03:30 <conal> lilac: nice to have unamb when needed.  this one sounds unnecessary.
17:03:31 <Peaker> conal: seems to only have Eq, Ord, Show, Functor :-(
17:03:46 <pchiusano> > [1, 2, 3] >>= (\x -> [4, 5, 6])
17:03:47 <lambdabot>   [4,5,6,4,5,6,4,5,6]
17:03:56 <lilac> conal: it's AddBounds that's causing it
17:04:01 <conal> Peaker: hard to believe.  ought to have VectorSpace
17:04:05 <lilac>   MinBound  `max` v         = v
17:04:05 <lilac>   u         `max` MinBound  = u
17:04:10 <lilac> ^^ first two equations for max
17:04:23 <conal> lilac: oh, yeah!
17:04:35 <pumpkin> @src [] >>=
17:04:35 <lambdabot> Source not found. Are you on drugs?
17:04:36 <pchiusano> > [1, 2, 3] >>= (\x -> map (x,) [4, 5, 6])
17:04:37 <lambdabot>   <no location info>: parse error on input `)'
17:04:40 <Peaker> conal: maybe some other module (Not Graphics.FieldTrip) defines instances on Graphics.FieldTrip.Vector2?
17:04:57 <pumpkin> @src [] (>>=)
17:04:58 <lambdabot> xs >>= f     = concatMap f xs
17:05:11 <pumpkin> AnalogHole: starting to see why?
17:05:21 <conal> Peaker: if you load up Test.h in reactive-fieldtrip, you'll get all of the instances.  if VectorSpace isn't there, let's add it!
17:05:30 <conal> Peaker: i happy accept darcs patches
17:05:32 <conal> happily
17:05:37 <centrinia> > let { l1 = Just "foo"; l2 = Just "bar" } in do { a <- l1; b <- l2; return (a,b) }
17:05:38 <lambdabot>   Just ("foo","bar")
17:05:46 <lilac> conal: does Future mappend take the earlier or later value?
17:05:49 <conal> there.  added the Monoid instance in that last blog post.
17:06:02 <centrinia> > let { l1 = Just "foo"; l2 = Nothing } in do { a <- l1; b <- l2; return (a,b) }
17:06:04 <lambdabot>   Nothing
17:06:24 <conal> lilac: earlier.
17:06:32 <conal> lilac: have you read the paper?
17:06:35 <AnalogHole> pumpkin: kindof.  I dunno. This is all very frustratingly hard coming from procedural languages.
17:06:41 <conal> lilac: it may give you a lot of insight
17:06:45 <lilac> conal: yes, but there's a lot to fit in one's brain :)
17:06:56 <conal> lilac: yeah.  i way over-packed that one.
17:07:09 <lilac> i thought it was earliest, but i was hoping i was wrong :)
17:07:54 <Peaker> conal: I hope I can. I don't think I understand vector-space enough yet to do so, though
17:08:00 <pumpkin> AnalogHole: so if you treat a list as a monad, when you ask for its value you're automatically getting all its values, because it's all of them "simultaneously"... so if you monadically ask for (a, b) and a and b are both lists, you're going to get the pair of all values of a and all values of b, which amounts to having the cartesian product of them
17:08:11 <pumpkin> AnalogHole: at least that's my understanding of it, I've just started too
17:08:17 <conal> Peaker: that part of vector-space is *really simple*
17:08:18 <Peaker> conal: oh, there is an instance somewhere, good!
17:08:29 <SamB_XP> conal: maybe you should unpack it a bit ;-P
17:08:45 <conal> Peaker: i see it also.  don't know why it's getting lost.
17:09:05 <Peaker> conal: I had just upgraded some packages
17:09:18 <Peaker> conal: now when I import both FieldTrip and VectorSpace, I get the instances
17:09:28 <conal> oh, great.
17:09:31 <pumpkin> AnalogHole: but someone else might correct me on that :P
17:10:03 <conal> Peaker: did you see the VectorSpace instance code for Vector2?
17:10:36 <centrinia> AnalogHole: Try writing your own monad and try to implement an illustrative binding function. :)
17:11:05 <pumpkin> bah, I have map . map $ toEnum . read . show and I want to take the heads of the inner lists, without doing another map... it seems like it should be easy but I can't get it working :(
17:11:29 <Peaker> conal: this?
17:11:30 <Peaker>   type Scalar (Vector2 u)        = Scalar u
17:11:30 <Peaker>   s *^ Vector2 u v               = Vector2 (s*^u) (s*^v)
17:11:36 <pumpkin> oh I know what
17:11:56 <conal> Peaker: yeah
17:12:09 <conal> Peaker: i wanted you to see how simple it is.
17:12:18 <gweiqi> Peaker: you are working on some math libraries?
17:12:21 <gweiqi> do you have a link?
17:12:35 <Peaker> conal: I'd still have to learn about *^, the associated type, etc
17:12:40 <Peaker> gweiqi: its conal's vector-space library
17:12:46 <Peaker> @hackage vector-space
17:12:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space
17:12:47 <conal> Peaker: yeah
17:12:49 <gweiqi> ahh, thanks
17:12:57 <yuuki> Does the usage of the term "intuitionistic" to mean "constructivisitic" bother anyone else?  Isn't intuitionist set theory the set theory that is so unfettered that it allows Russell's Paradox?
17:13:15 <conal> Peaker: i use "^" on the vector side, "." on the point side, and "" on the scalar side.
17:13:18 <pchiusano> do { x <- [1, 2, 3]; return x +1 }
17:13:20 <conal> Peaker: in choosing operator names
17:13:26 <pchiusano> > do { x <- [1, 2, 3]; return x +1 }
17:13:27 <lambdabot>       No instance for (Num [t])
17:13:27 <lambdabot>        arising from the literal `1' at <inter...
17:13:34 <conal> Peaker: so "*^" would mean scalar * vector
17:13:34 <centrinia> Is there a Data.ProjectiveSpace ?
17:13:54 <AnalogHole> centrinia: Well, i followed teh building of the State monad and played around with it. But I only barely made head or tails of it. I couldn't do it from scratch without looking at the tutorial.
17:14:41 <Peaker> conal: what's a "point side" ?
17:14:59 <AnalogHole> centrinia: I can't even figure out how to desugify the function. The translation rules don't make much sense either.  :-/
17:15:18 <conal> Peaker: e.g., "(.-.)" takes points on both side, and "(.+^)" takes a point on the left and a vector on the right
17:15:46 <AnalogHole> cenrinia: I'll have to figure that out and get back here if i have questions.
17:15:55 <conal> Peaker: vector types belong to VectorSpace and point types to AffineSpace
17:16:12 <Peaker> conal: Ah, I don't know what affine spaces are, I need to read some
17:16:15 <AnalogHole> And I was doing OK until I hit monads.. like a brick wall.
17:16:31 <conal> Peaker: or just think of them as being like points.
17:16:32 <centrinia> > [1,2,3] >>= (\x -> [3,4,5] >>= (\y -> return (x,y) ) )
17:16:33 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
17:16:36 <centrinia> Yeah. :)
17:16:43 <centrinia> That's the desugaring of it. :)
17:16:49 <Peaker> AnalogHole: I think it might be easier to start by understanding Functors, then Applicatives, and only then, Monads
17:17:34 <centrinia> I know of many students of Haskell who have trouble understanding monads.
17:18:17 <Peaker> AnalogHole: do you know fmap/Functor?
17:18:32 <MariusAZ> I didn't find it too funny
17:18:34 <MariusAZ> he he
17:18:36 <MariusAZ> Cause they nailed it
17:18:48 <AnalogHole> Peaker: Yeah, I under functors. But I haven't heard of Applicatives
17:18:58 <MariusAZ> I'm really surprised Apple doesn't sell fake ipod earbuds
17:19:06 <conal> Peaker: agreed!
17:19:19 <Peaker> AnalogHole: if you have:  (Functor f) => (f a, f b)  --  what can you do with those two values?
17:19:30 <pumpkin> [*** Exception: Prelude.read: no parse
17:19:32 <pumpkin> what does that mean?
17:19:57 <pumpkin> (I'm trying to read a ByteString into a string)
17:20:03 <MariusAZ> You're missing some equation there
17:20:17 <Peaker> AnalogHole: if I give you an (a -> b -> c), can you give me an (f c) from (f a) and (f b) ?
17:20:38 <tanob> @undo do { x <- [1, 2, 3]; return x +1 }
17:20:39 <lambdabot> [1, 2, 3] >>= \ x -> return x + 1
17:20:43 <pumpkin> @instances Functor
17:20:45 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:21:15 <MariusAZ> I'm in the wrong channel
17:21:16 <MariusAZ> sorry
17:21:24 <AnalogHole> Peaker: hell, i don't know. My brain is mush right now.
17:22:04 <Peaker> AnalogHole: what can you do with Functor f => (f a) ?
17:22:19 <Peaker> AnalogHole: what does "Functor f =>" tell you?
17:22:35 * centrinia functors a :>
17:22:39 <cknapp> AnalogHole; then take a break, do something mindless, and come back in half an hour or so...
17:23:29 <AnalogHole> Peaker: that f in the type signature denotes a Functor.
17:24:14 <Peaker> AnalogHole: and that means that...?
17:24:37 <pumpkin> PeakerWork: maybe he doesn't know what a functor is? :P
17:24:41 <centrinia> Are Applicatives a new concept?
17:24:57 <pumpkin> does anyone know about my no parse exception?
17:24:58 <mjonsson> @pl \x -> runUnifier (mkg x) success failure
17:24:59 <lambdabot> flip (flip runUnifier success . mkg) failure
17:25:24 <AnalogHole> pumpkin: Well, i know what fmap does. But it isn't clean how it is really different than map
17:25:38 <pumpkin> AnalogHole: it's a generalization of map to things other than lists, sort of
17:25:50 <SamB_XP> AnalogHole: it isn't ;-P
17:25:54 <dibblego> pumpkin, fmap does more than map across lists; it maps across many other things too
17:25:55 <pumpkin> so on a list, fmap is map
17:26:04 <AnalogHole> Hmm, I guess the tutorial didn't really explain exactly what a functor is... just that fmap is one and what it does
17:26:18 <SamB_XP> in a previous life, fmap was called map
17:26:30 <dibblego> a functor is any instance of the Functor type-class satisfying two laws
17:26:31 <pumpkin> dibblego: yeah, I thought I said that but it doesn't look like that :P
17:26:35 <Peaker> AnalogHole: Functor is a type-class. "fmap" is the only method in that type-class
17:26:38 <SamB_XP> where by life, I mean "version of the Haskell standard"
17:26:46 <dibblego> pumpkin, sorry I mean AnalogHole
17:26:51 <Peaker> AnalogHole: if a type "f" is a Functor, then "fmap" exists, and its type is:   (a->b) -> f a -> f b
17:26:53 <pumpkin> :)
17:27:32 <Peaker> AnalogHole: so Functor types (e.g lists) allow you to apply a pure function (i.e (a->b)) to their content, to yield a "modified" result (e.g a new list)
17:27:55 <Peaker> AnalogHole: fmap on lists is just map, but fmap can be applied to other types as well, such as "Maybe"
17:28:29 <centrinia> Does (fmap g ) . (fmap f) = fmap (g . f) ?
17:28:40 <Peaker> centrinia: yes
17:29:07 <dibblego> centrinia, the law of composition (identity must also satisfy)
17:29:12 <Peaker> centrinia: there's even a rewrite rule that does that, IIRC, which allows for nice fusion
17:29:47 <Peaker> > fmap (*2) [1,2,3]
17:29:49 <lambdabot>   [2,4,6]
17:29:54 <Peaker> > fmap (*2) (Just 5)
17:29:55 <lambdabot>   Just 10
17:29:58 <Peaker> > fmap (*2) Nothing
17:29:59 <pumpkin> @hoogle read
17:29:59 <lambdabot> Prelude read :: Read a => String -> a
17:29:59 <lambdabot> Text.Read read :: Read a => String -> a
17:29:59 <lambdabot> module Text.Read
17:30:00 <lambdabot>   Nothing
17:30:08 <Peaker> AnalogHole: do you understand these examples?
17:30:59 <AnalogHole> Peaker: I don't see how the 5 is extracted from the Just to do the multplication.
17:31:05 <pumpkin> > show "ab"
17:31:06 <lambdabot>   "\"ab\""
17:31:13 <pumpkin> hrm
17:31:27 <Peaker> AnalogHole: that's what the Maybe Functor instance does
17:31:32 <Peaker> AnalogHole: it applies the function "inside" the Maybe, just like "map" applies the function inside the list
17:31:34 <centrinia> AnalogHole, the fmap function is defined for Maybe to do just that.
17:31:54 <pumpkin> is there a show that doesn't include the quotes? :P I need to convert from ByteString to String, but I just want the contents of the bytestring and don't want to have to strip the first and last chars manually
17:31:55 <Peaker> AnalogHole: each Functor type gets to define how fmap works for it
17:32:30 <AnalogHole> Ok, I understand that
17:32:31 <Peaker> AnalogHole: so there's:  instance Functor [] where fmap = []      somewhere, and:   instance Functor Maybe where fmap f Nothing = Nothing ; fmap f (Just x) = Just (f x)
17:32:45 <Peaker> oops
17:32:46 <SamB_XP_> pumpkin: uh ... you probably want to use unpack ;-P
17:32:55 <Peaker> AnalogHole: so there's:  instance Functor [] where fmap = map
17:33:18 <pumpkin> SamB_XP: that gives me [Word8], how do I get to a String from that?
17:33:31 <SamB_XP_> pumpkin: oh, use the other one
17:33:36 <SamB_XP_> the Char8 one
17:33:50 <SamB_XP_> if you wanted to treat that as straing ISO 8859-1
17:33:56 <SamB_XP_> er. *straight
17:33:58 <pumpkin> aha
17:34:04 <Peaker> AnalogHole: so what does Functor f  mean for a value of type:  (f a)  ?
17:34:48 <mjonsson> is there a way to turn off the Occurs check?
17:34:58 <AnalogHole> Peaker: just f a
17:35:13 <Peaker> AnalogHole: what can we do with that value?
17:35:34 <pumpkin> thanks SamB_XP_ :)
17:35:40 <chessguy_> 'evening ya'all
17:36:02 <pumpkin> what is NFData?
17:36:06 <centrinia> (map (chr . fromIntegral) ) . unpack
17:36:16 <AnalogHole> Peaker: I don't know.
17:36:40 <Peaker> AnalogHole: We know "f" is a functor, so we know we can "fmap" an (f a) to an (f b) using an (a->b) function
17:36:59 <chessguy_>  any thoughts on whether or not "class Tree t" could be a useful abstraction for the different possible kinds of trees?
17:37:10 <FunctorSalad> mjonsson: sorry I don't remember which one that is, but if it is the one for instance declarations, then probably -XUndecidableInstances
17:37:13 <Peaker> AnalogHole: the only thing you can do with functors is apply a pure function on their content
17:37:18 <pumpkin> chessguy_: you'd probably want a label type too?
17:37:36 <centrinia> > let { bs2s = (map (chr . fromIntegral) ) . unpack; s2bs = pack . (map (fromIntegral . ord)); t = s2bs "Hello World!" } in (bs2s t)
17:37:37 <lambdabot>   Not in scope: `unpack'Not in scope: `pack'
17:37:38 <chessguy> pumpkin:  i'm not sure what you mean by that
17:37:39 <pumpkin> and maybe a way to separate labels from weights, depending on your needs
17:37:44 <mjonsson> FunctorSalad, thanks, I'll see what that is
17:37:46 <pumpkin> chessguy: to give edges labels
17:37:53 <AnalogHole> Peaker: so you get (f c) by applying a -> b
17:38:01 <centrinia> > let { bs2s = (map (chr . fromIntegral) ) . Data.ByteString.unpack; s2bs = Data.ByteString.pack . (map (fromIntegral . ord)); t = s2bs "Hello World!" } in (bs2s t)
17:38:02 <lambdabot>   "Hello World!"
17:38:28 <Peaker> AnalogHole: I get (f b), not (f c)
17:38:43 <chessguy> pumpkin:  my thinking is that t would be a type constructor
17:38:52 <Peaker> AnalogHole: and I don't have (a -> b), I have (a -> b -> c) which is really (a -> (b -> c))
17:39:10 <chessguy> e.g., instance Tree Data.Tree.Tree
17:39:42 <chessguy> but i'm still not sure i'm following your question
17:40:09 <pumpkin> oh I guess I was confused, sorry :)
17:40:20 <pumpkin> what would you put in the class?
17:40:25 <AnalogHole> Well, thanks all. I'm going to put this down for the evening, cry a bit, and get back to it tomorrow.
17:40:39 <FunctorSalad> chessguy: maybe Foldable or Traversable (or Data) already does what you want?
17:41:09 <chessguy> FunctorSalad: i figured Tree would probably be a subclass of those
17:43:53 <tanob> hey guys, im trying to use a monad inside a function, but i get a type error when i try to access it... http://hpaste.org/12599
17:46:18 <chessguy> i guess the only way to really know is to try to implement it and see if it turns out seeming to be useful
17:46:37 <cknapp> AnalogHole: probably a good idea. Try not to cry tooo much. :)
17:46:45 <FunctorSalad> tanob: apparently the current version does compile? try ":type translateBg" in ghci
17:47:14 <tanob> yes, it does: translateBg :: (Id, [(t, Expr)]) -> [JClass]
17:48:03 <FunctorSalad> tanob: looks like you want the do to be for the MTransInfo monad, but it is a do for list monad
17:48:28 <tanob> exactly
17:48:39 <FunctorSalad> maybe replace "jClasses <-" by "jClasses <- return"
17:48:47 <FunctorSalad> (leaving the rest of that line there)
17:49:21 <centrinia> What does it mean to lift a list to an MTransInfo?
17:49:55 <FunctorSalad> currently the only way the compiler can interpret the right hand side as a monadic value is by choosing the list monad
17:51:02 <tanob> for every alt in alts i need to call translateAlt
17:51:20 <tanob> its result should update the monad state (MTransInfo)
17:51:35 <tanob> FunctorSalad: no, another type error
17:53:22 <centrinia> Where is this translateAlt function?
17:53:50 <mm_freak> tanob: any reason not to use State?
17:54:19 <mm_freak> centrinia: you can't, since MTransInfo is not a monad transformer
17:54:36 <tanob>  centrinia http://hpaste.org/12599#a1
17:54:55 <tanob> mm_freak: State or my MTransInfo, no diff for me
17:55:04 <tanob> but State uses multi type
17:55:53 <mm_freak> well, MTransInfo is like reinventing the wheel
17:56:04 <mm_freak> type MTransInfo = State TransInfo
17:56:05 <pumpkin> hmm, I want to force my lists to evaluate, but I have a custom enum type that isn't an instance of NFData, so rnf isn't working
17:56:36 <mm_freak> pumpkin: derive NFData?
17:56:42 <pumpkin> doesn't let me
17:56:46 <SamB_XP> mm_freak: how ???
17:56:55 <SamB_XP> he said CUSTOM
17:57:03 <centrinia> tanob: You can consider constructing a TransInfo with the jClasses in it and construct an MTransInfo from the TransInfo.
17:57:04 <pumpkin> it's just a simple enum
17:57:15 <SamB_XP> pumpkin: why would NFData be derivable ?
17:57:18 <mm_freak> ok
17:57:24 <centrinia> However I don't really understand what MTransInfo is for. :p
17:57:25 <SamB_XP> er.
17:57:27 <SamB_XP> mm_freak:
17:57:36 <pumpkin> I have no idea :P I was just asking a few days ago how to force my lazy lists to evaluate, and someone suggested rnf
17:57:38 <FunctorSalad> SamB_XP: pumpkin: derive or DriFT can derive that I think
17:57:43 <tanob> centrinia: hehe, MTransInfo is a state monad
17:57:50 <pumpkin> which worked fine until I made my custom enum type
17:58:05 <tanob> centrinia: its purpose is to store the classes that were already generated previosly (field tiClasses)
17:58:06 <FunctorSalad> (derive, the package)
17:58:12 <mm_freak> SamB_XP: i thought, any non-function type could derive NFData
17:58:23 <tanob> and also store the generics information about the types (tiGenerics)
17:58:25 <FunctorSalad> unfortunately they have issues with some of the newer extensions
17:58:33 <FunctorSalad> (I think)
17:58:44 <pumpkin> isn't there an easier way to force a list to evaluate than rnf? :P
17:58:57 <pumpkin> and deriving some magic type? :o
17:58:59 <centrinia> How is MTransInfo different from State TransInfo a ?
17:59:10 <tanob> centrinia: i guess that no diff
17:59:44 <tanob> besides reinvent the wheel, does exist another benefit of using it ?
17:59:53 <tanob> not* reinvent
18:00:02 <centrinia> You won't have this type error. :p
18:00:11 <centrinia> You might get another type error. :p
18:00:26 <tanob> thats my sin
18:00:26 <FunctorSalad> tanob: if you actually want the do to remain a list-monad-do, then that ti <- line shouldn't be inside the do since getTransInfo isn't a list (apparently)
18:00:52 <tanob> FunctorSalad: yes, getTransInfo is the State's get function
18:01:02 <tanob> so it isnt a list
18:01:47 <centrinia> tanob, you should consider constructing that other TransInfo data with the new jClasses.
18:01:58 <centrinia> Put that TransInfo into the state.
18:02:18 <tanob> data MTransInfo a = MTransInfo (TransInfo -> (TransInfo, a))
18:02:29 <tanob> sorry, dont get it
18:02:38 <tanob> transinfo is already into the state
18:03:02 <tanob> i have runMTransInfo there, with a initial state
18:03:30 <pumpkin> so no other way to get a list to evaluate than rnf? :P
18:04:13 <centrinia> Hell, you can even replace the return jClasses with return (TransInfo {tiTypCtx ti, jclasses, tiGenerics ti} )
18:05:23 <centrinia> I meant return (TransInfo {tiTypCtc = tiTypCtx ti, tiClasses = jClasses, tiGenerics = tiGenerics ti}) or something.
18:06:13 <tanob> centrinia: hmmm
18:06:51 <centrinia> I'm a dysfunctional programmer. I only play a functional programmer on TV. :D
18:07:09 <SamB_XP> centrinia: they have FP on TV now ???
18:07:22 <centrinia> I wish.
18:07:22 <SamB_XP> I also heard that they have the internet on computers, now ...
18:08:02 <tanob> centrinia: same problem
18:08:19 <tanob> i dont get how to mix monads
18:08:30 <centrinia> Oh, sorry, don't do an jClasses <- translateAlt id alt.
18:09:01 <centrinia> Just replace the tiClasses field in the newly constructed TransInfo with an (translateAlt id alt)
18:09:31 <centrinia>  return (TransInfo {tiTypCtc = tiTypCtx ti, tiClasses =  translateAlt id alt, tiGenerics = tiGenerics ti})
18:10:17 <tanob> Couldn't match expected type `[a]' against inferred type `MTransInfo TransInfo'
18:10:32 <AlexyK_> Got Real Wotld Haskell today!  Awesome book
18:11:19 <centrinia> Oh, sorry. putTransInfo instead of return.
18:13:31 <tanob> sorry, not yet
18:14:39 <centrinia> Now what?
18:15:33 <tanob> Couldn't match expected type `[a]' against inferred type `MTransInfo ()''
18:17:39 <FunctorSalad> if you want something that handles both state and lists, you might want StateT TransInfo [] a
18:18:25 <FunctorSalad> might be overkill though
18:20:00 <tanob> sorry, im completely new to haskell, mainly monads, i did read lot of stuff, but its hard
18:20:10 <tanob> i just need to call translateAlt for every alt in alts
18:20:22 <tanob> and for every result from translateAlt, i need to update the state on MTransInfo
18:20:29 <mm_freak> tanob: i still suggest using State
18:20:50 <tanob> mm_freak: i guess that i will change 6 to 12/2
18:20:56 <FunctorSalad> tanob: for the former, you could just do "map translateAlt alts"
18:21:16 <mm_freak> (unless you're practicing writing state monads)
18:21:18 <FunctorSalad> mm_freak: I agree with tanob here, I think what he did is exactly the same as State
18:21:20 <apsod> I have a random question -- if I have a parameterized type like ``data X a = Maybe a'', do I always have to refer to the unparameterized version as ``X a'', or can I shortcut that somehow, ie ``type Y = X a''?
18:21:31 <FunctorSalad> (State TransInfo)
18:21:32 <apsod> I'm assuming there's no shortcut syntax, that I always have to explicitly add the paramter in there.
18:21:47 <mm_freak> FunctorSalad: yes, i know, and that's reinventing the wheel
18:21:49 <mm_freak> that's my point
18:22:03 <FunctorSalad> but it's not what causes the error ;)
18:22:14 <hd_> can anyone give me any tips to optimise this: http://hpaste.org/12600
18:22:23 <mm_freak> no, but it makes the code simpler =)
18:22:33 <mm_freak> so errors can be resolved more easily
18:22:39 <sjanssen> apsod: you can write type Y = forall a. X a, but it might not mean what you want
18:22:43 <mm_freak> and he gets access to "mixing monads" for free (i.e. StateT)
18:22:56 <tanob> actually i mm_freak is right too, but im trying to pratice the writing of monads
18:23:05 <mm_freak> ok
18:23:07 <tanob> but i did consider using State, if there is a pattern, its better use it
18:23:26 <tanob> but i guess that i would have the same problems
18:23:41 <FunctorSalad> tanob: what is the type of translateBg supposed to be?
18:24:30 <sjanssen> hd_: is elem2 supposed to be different from Prelude.elem?
18:24:42 <FunctorSalad> tanob: I think it would be useful if you gave everything a type annotation
18:25:03 <FunctorSalad> tanob: that gives you more informative compiler errors, too
18:25:18 <apsod> sjanssen: Does that syntax require a special flag to ghc? (or a version more recent than 6.8.3?) I'm getting a syntax error about the ``.'' in ``type X = forall a. X' a''
18:25:35 <hd_> sjanssen: I couldn't get elem to work with it- but I am new so I might have just been doing something wrong
18:25:49 <sjanssen> hd_: "name /= []" is bad, you should use "not (null name)"
18:25:52 <tanob> it can be totally effect collateral (translateBg :: (Id, [Alt]) -> MTransInfo ()), or return the list of results from translateAlt (translateBg :: (Id, [Alt]) -> MTransInfo [JClass])
18:26:42 <apsod> Hrm, looks like I just need ExistentialQuantification.
18:26:51 * apsod reads the wiki.
18:27:18 <tanob> actually the first is better, since i wont use its result, i will get directly from the TransInfo's field tiClasses
18:27:37 <sjanssen> hd_: maxlength is a bit inefficient, remember that length on lists is O(n)
18:28:16 <hd_> yeah, many things are inefficient in my code unfortunately :P
18:28:23 <hd_> is there a better way?
18:28:30 <FunctorSalad> tanob: what's the 'Id' type there?
18:28:55 <tanob> data Id = Id String Int deriving (Eq)
18:29:23 <tanob> im trying to translate a sub-like-haskell language to jvm bytecodes
18:30:22 <sjanssen> hd_: you also have a bunch of repeated stuff, and I don't understand why
18:30:46 <hd_> like the isnumber, isnumber' and so on?
18:30:53 <apsod> sjanssen: Got it working, thanks. ExistentialQuantification is just what I needed :)
18:31:55 <sjanssen> hd_: yes
18:31:57 <pumpkin> is there an easy way to make a custom enum encodabe?
18:32:02 <pumpkin> I can't just derive Binary
18:32:08 <FunctorSalad> tanob: for the first type sig, you could do this: translateBg (id,alts) = MTransInfo (\state -> ( foo (map (translateAlt id) alts) , () )) -- where the foo is something that uses the existing state, I think you didn't write this yet
18:32:49 <hd_> (again I am new, so there might be another way)- but the reason is for example, numbers can be: "123" "123.123" "123e+123" "123.123e+123"
18:32:54 <sjanssen> pumpkin: you can use one of the instance generators, like the derive package
18:32:57 <FunctorSalad> (the "ti" variable in your translateBg isn't used yet)
18:33:34 <sjanssen> hd_: isnumber looks identical to isnumber''
18:34:07 <hd_> except that isnumber calls isnumber', and isnumber'' calls itself :P
18:34:15 <hd_> yeah, a confusing web :P
18:34:43 <sjanssen> ah
18:34:56 <sjanssen> but this could certainly use some simplification
18:35:39 <sjanssen> perhaps break the number token into smaller subtokens -- consider a string of numbers one sort of token, '.' and 'e' as single character tokens
18:36:34 <hd_> that's true
18:37:44 <hd_> what about findnumber- is there a way to exit early when it starts getting False, instead of reading the entire string?
18:37:54 <sjanssen> let's start with integers: isInteger xs = all (`elem` ['0' .. '9']) xs
18:38:15 <sjanssen> then a decimal number is two integers with a '.' separating them
18:38:42 <sjanssen> a number in scientific notation is a decimal or integer followed by e, followed by an integer
18:39:25 <sjanssen> hd_: you can use takeWhile
18:40:30 <FunctorSalad> tanob: I wrote you an annotation how to do it with 'get' and 'put' :)
18:41:43 <hd_> oh cool, haven't heard of that function yet- I will give it a go ;)
18:42:14 <pumpkin> sjanssen: yay, it works
18:42:27 <tanob> FunctorSalad: thank you, im trying some solutions here, lets see :)
18:46:51 <centrinia> I want to make a modified State monad called the (BitBucket a) monad. It will lack the get, execBitBucket, and evalBitBucket functions.
18:47:55 <Cale> centrinia: Won't state without get effectively be Writer?
18:49:04 <centrinia> Writer has an associated execWriter.
18:49:41 <centrinia> A BitBucket just lets you put stuff in. It doesn't let you access anything that you previously put in. :p
18:49:49 <Axman6> anyone used the CouchDB package before?
18:50:12 <Cale> centrinia: Does it really matter? execWriter is just a trivial modification of runWriter
18:50:26 <centrinia> No runBitBucket. :p
18:51:23 <Cale> I'm pretty sure that writer is what you're looking for anyway :)
18:51:27 <ushdf> functional programming is cool!!!!!!!
18:52:03 <centrinia> Thanks Cale. :)
18:52:09 <Axman6> ushdf: indeed
18:57:48 <pumpkin_> hmm, I get a feeling I need conal's semantic editor combinations
18:57:56 * pumpkin_ thinks
18:59:27 <mmorrow> this looks like an interesting pullback-the-concepts-to-their-common-concept-pun-intended problem: http://hpaste.org/12601#a1  ;)
19:00:36 <pumpkin_> @hoogle result
19:00:36 <lambdabot> Test.QuickCheck data Result
19:00:36 <lambdabot> Test.QuickCheck Result :: Maybe Bool -> [String] -> [String] -> Result
19:00:36 <lambdabot> Data.Typeable funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
19:02:53 <pumpkin_> so say I have a [(a, b)] and want to apply a function to all the a (more than just a map), and reconstruct the list quickly
19:03:17 <pumpkin_> it seems like something like what conal was describing in that blog post, but I can't figure out how I'd do it
19:03:24 <Axman6> pumpkin_: anything wrong with map (f.fst)?
19:03:48 <pumpkin_> then zipping with map (snd) ?
19:04:01 <Axman6> @src (,) fmap
19:04:02 <lambdabot> fmap f (x,y) = (x, f y)
19:04:07 <pumpkin_> I guess it's not terrible, but I was wondering if there was something nicer
19:04:08 <Axman6> bah
19:04:19 <conal> pumpkin_: you can read the answer directly from the types.
19:04:36 <mmorrow> @let mapfst f (a,b) = (f a,b)
19:04:37 <lambdabot>  Defined.
19:04:42 <mmorrow> @let mapsnd f (a,b) = (a,f b)
19:04:43 <conal> pumpkin_: iiuc, you want your function to enter each 'element' and then the 'first'
19:04:43 <lambdabot>  Defined.
19:04:52 <Axman6> map (\(a,b) -> (f a, b)) i guess
19:04:55 <conal> pumpkin_: so you say (element.first) f
19:05:17 <pumpkin_> conal: yeah, then I apply a non-map function (i.e. that takes more than one element at a time) to all the fsts
19:05:25 <mmorrow> i like map{fst,snd} in place of {first,second} because the names mirror the symmetry better
19:05:32 <pumpkin_> and recombine it into a list
19:05:49 <conal> pumpkin_: where 'element' is a synonym for fmap.
19:06:08 <pumpkin_> yeah
19:06:14 <conal> pumpkin_: does that make sense: (fmap.first) h
19:06:20 <conal> @type fmap . first
19:06:21 <lambdabot> forall (f :: * -> *) b c d. (Functor f) => (b -> c) -> f (b, d) -> f (c, d)
19:06:28 <conal> great
19:06:32 <conal> @type map . first
19:06:33 <lambdabot> forall b c d. (b -> c) -> [(b, d)] -> [(c, d)]
19:06:39 <pumpkin_> yeah, makes sense
19:06:56 <mmorrow> first/second and left/right (by whatever names ;) are stupendous functions
19:06:57 <conal> i like the name 'element' for map, in the mind-set of semantic editor combinators.
19:06:57 <Axman6> :t first
19:06:58 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
19:07:04 <conal> ditto for 'result'
19:07:15 <pumpkin_> conal: yeah, I defined those as per your blog post :)
19:07:21 <conal> :)
19:09:17 <pumpkin_> so my issue is that this is applying them one at a time
19:09:21 <conal> wow -- i'm getting some nice & substantive comments on the last two posts at http://conal.net/blog . :)
19:09:27 <lambdabot> Title: Conal Elliott
19:09:35 <conal> pumpkin_: ??
19:09:42 <gwern> maybe the endless FRP postings to proggit are working
19:09:45 <chessguy> how do you read <*> ?
19:09:49 <chessguy> hiya conal
19:09:55 <conal> chessguy: hi!
19:09:59 <conal> chessguy: how's life?
19:10:09 <chessguy> crazy, but good :)
19:10:28 <conal> chessguy: glad to hear it.  remember to breathe sometimes, okay?
19:10:41 <chessguy> yeah, i've got time penciled in for that next week sometime
19:11:51 <pumpkin_> so the function I'm trying to use is deltas, which I defined as deltas xs = [0, zipWith (-) (tail xs) xs]... I'd like to take deltas and apply it to all the fsts in [(1,2),(2,3),(3,4),(5,6)], for example, so that I got [(0,2),(1,3),(1,4),(2,6)]
19:12:04 <pumpkin_> whoops, you know what I mean
19:12:05 <conal> chessguy: :)
19:12:07 <pumpkin_> that should be a cons
19:12:29 <pumpkin_> deltas xs = 0 : (zipWith (-) (tail xs) xs)
19:12:41 <conal> pumpkin_: oh, now i see
19:12:52 <roconnor> @quote god
19:12:53 <lambdabot> monochrom says: Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more
19:12:53 <lambdabot> godawful construct?
19:12:58 <pumpkin_> lol
19:13:12 <roconnor> @quote god
19:13:13 <lambdabot> qwe1234 says: real programmers write their own garbage collectors instead of using a magic black box from godforsaken academic website.
19:13:21 <roconnor> @quote ap
19:13:21 <lambdabot> sjanssen says: Quoth the Prelude, Chapter 6, verse 4:  Yeah verily shall repeat floweth cons cells over.
19:13:32 <roconnor> @quote tail
19:13:33 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
19:13:37 <gwern> @quote week
19:13:38 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
19:13:40 <roconnor> :/
19:13:46 <gwern> @quote week
19:13:47 <lambdabot> JonathanShapiro says: The ML module system is fully understood only by David MacQueen, and only on alternating weeks.
19:13:54 <Cale> @quote zip`ap`tail
19:13:54 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:14:05 <pumpkin_> people want to get rid of my ugly question as soon as possible ;)
19:14:08 <gwern> yes, that's a good one
19:14:14 <gwern> @quote l
19:14:14 <roconnor> thanks
19:14:14 <lambdabot> ski says: please talk to your son or daughter about parametric polymorphism
19:14:29 <gwern> @quote m
19:14:30 <lambdabot> dons says: my feeling is that the Java programmers will welcome us as liberators
19:14:33 <shapr> @quote foo
19:14:33 <lambdabot> foot says: You shoot yourself in the foot very elegantly, and wonder why the whole world isn't shooting itself this way.
19:14:34 <mmorrow> @nixon
19:14:34 <lambdabot> If you think the United States has stood still, who built the largest shopping center in the world?
19:14:46 <gwern> @quote n
19:14:46 <lambdabot> PaulGraham says: An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers
19:14:47 <lambdabot> you should have cited.
19:14:47 <chessguy> conal: my first thought about what the last corner of that square should be, was "signals"
19:14:58 <mmorrow> @quote table
19:14:58 <lambdabot> shapr says: Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
19:15:04 <mmorrow> @quote c++
19:15:04 <lambdabot> mudge says: A good type system is like a set of tests, except they're actuallly proofs
19:15:10 <shapr> @quote floor
19:15:10 <lambdabot> No quotes match.
19:15:16 <mmorrow> @quote legs
19:15:16 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
19:15:19 <gwern> We will be welcomed as liberators! I estimate that we will need 50000 haskellers at most and will be able to wind up the occupation quickly
19:15:23 <pumpkin_> conal: any ideas, or should I just decompose it the long way and stick it back together? or better yet, arrange for that situation to not occur in the first place?
19:15:29 <mmorrow> @quote dog
19:15:29 <lambdabot> skew says: I think blackdog is right
19:15:38 <apsod> gwern: That's a dream I could enjoy.
19:15:45 * apsod is currently a Java programmer by day :(
19:15:47 <sjanssen> @remember gwern We will be welcomed as liberators! I estimate that we will need 50000 haskellers at most and will be able to wind up the occupation quickly
19:15:47 <lambdabot> It is stored.
19:16:05 <shapr> @quote java
19:16:05 <lambdabot> Korollary says: Can't you pretend that you've never heard of any of this and keep hacking happy java?
19:16:07 * andrewsw is trying desparately to be a haskelleer in a java uni.
19:16:12 <conal> chessguy: (signals) yeah, if finite ones.
19:16:23 <conal> (finite, continuous ones)
19:16:30 <cknapp> Silly question: If I have data Foo = Foo Bar Baz ..., what is a concise way to write a function to extract each of Bar Baz ... ?
19:16:38 <conal> pumpkin_: i'm playing with it.
19:16:39 <chessguy> conal:  i suspect most interesting analog signas are finite
19:16:46 <pumpkin_> conal: thanks :)
19:16:53 <Cale> cknapp: You could use record syntax
19:16:58 <mmorrow> chessguy: in what dimension?
19:16:58 <cknapp> thanks
19:16:59 <gwern> cknapp: you mean soemthing like 'extract Foo a _ = a'?
19:17:05 <cknapp> yes
19:17:06 <Cale> data Foo = Foo { bar :: Bar, baz :: Baz }
19:17:08 <Axman6> andrewsw: they don't teach haskell at all? :(
19:17:14 <andrewsw> nopr
19:17:15 <cknapp> There it is. :D
19:17:18 <gwern> cknapp: as Cale says, record syntax auto-generates extractors for each field
19:17:19 <andrewsw> nope
19:17:23 <apsod> holy crap, there's a record syntax?
19:17:27 <chessguy> mmorrow: hm, good question.
19:17:39 <gwern> apsod: yes! many haskellers dislike it though!
19:17:40 <chessguy> apsod:  don't get too excited, it sucks
19:17:48 <travisbrady> apsod: don't use it
19:17:50 <Axman6> andrewsw: well do something about it!
19:18:06 <conal> chessguy: finite -- really ??
19:18:07 <andrewsw> Axman6: There's one prof who's into it and fp in general. We have our little meetups in the hall where we talk about monads
19:18:10 <apsod> Realistically, I doubt I'll let my types get that complicated. It's good to know though :|
19:18:23 <Axman6> andrewsw: excellent :)
19:18:39 <conal> chessguy: maybe it depends on whether the universe is temporally finite or infinite.
19:18:41 <apsod> oh, ffh it just autogenerates extractors for each field.
19:18:45 <apsod> lame.
19:18:53 <andrewsw> Axman6: we trade code. typically versions of projecteuler solutions in either scheme of haskell depending on mood
19:19:00 <Cale> apsod: It does a little more than that
19:19:01 <travisbrady> apsod: http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
19:19:03 <lambdabot> Title: Haskell Records Considered Grungy « :: (Bloggable a) => a -> IO (), http://tinyurl.com/3akjdr
19:19:17 <gwern> chessguy: 'well, the record syntax comes with free acessors!' ''ooh, that's good.' 'but the accessors are cursed!' ooh, that's bad.' 'the good news is, there's a Free extensible record syntax' 'ooh, that's good. 'the bad news is that they are cursed with multiple incompatible proposals!' '....can I go now?'
19:19:19 <apsod> travisbrady: Thanks :3
19:19:23 <Cale> apsod: But they're not proper polymorphic extensible records or anything.
19:19:49 <andrewsw> Axman6: I try to nudge little changes. But it will be slow at best. We're really a trade school, not a cs dept. oh well.
19:19:50 <cknapp> andrewsw: what uni?
19:19:51 <Axman6> what's people's problems with record syntax?
19:20:02 <andrewsw> cknapp: Eastern Washington
19:20:03 <Axman6> andrewsw: ah i see :(
19:20:17 <cknapp> Ah, because there's a similar situation at my school
19:20:25 <andrewsw> cknapp: which?
19:20:32 <cknapp> Illinois Tech
19:20:39 <andrewsw> hmm..
19:20:49 <Axman6> we got taught haskell in first year (which i just finished yesterday :D), then java, then C and assembly i believe
19:21:05 <apsod> Axman6: My issue would be that the creation of accessor functions would pollute your namespace, but I imagine there are more critical flaws.
19:21:06 <Axman6> managed to get all HD's in comp so far
19:21:07 <chessguy> Axman6:  see the link just given for a good start
19:21:16 <cknapp> Well... there's one who is really into fp, and an AI researcher... together, they're pushing for fp hard...
19:21:27 <andrewsw> we have one asst. prof working on concurrency, fp, and so forth. Another working on parallel stuff at the machine level.
19:21:32 <cknapp> An intro class was finally taught using the SICP this semester.
19:21:35 <andrewsw> That's about it for interesting stuff.
19:21:44 <chessguy> SICP++
19:21:47 <conal> pumpkin_: best i've come up with is
19:21:51 <conal> @type \ f -> uncurry zip . first f . unzip
19:21:52 <lambdabot> forall a a1 b. ([a1] -> [a]) -> [(a1, b)] -> [(a, b)]
19:22:09 <conal> pumpkin_: but i don't see the composability i like.
19:22:11 <pumpkin_> conal: ah, neat, I'll try that
19:22:13 <pumpkin_> yeah :/
19:22:16 <andrewsw> also one guy doing heavy maths and stats to turn EEG into real, usable 3d modelling. kinda cool.
19:22:18 <gwern> cknapp: they're teaching SICP in haskell? hardcore!
19:22:22 <conal> pumpkin_: it's still hiding a bit
19:22:23 <dblazakis> is there any good way to avoid writing really ugly peek/poke function for a Storable instance?
19:22:26 <cknapp> The fp professor teaches his language theory class in whichever fp he feels like that semester, and next semester theres an fp reading group.
19:22:33 <cknapp> gwern: you missed the conversation
19:22:37 <cknapp> Sadly.
19:22:38 <andrewsw> cknapp: nice!
19:22:47 <cknapp> So, things are changing...
19:22:48 <pumpkin_> conal: it's kinda a dumb situation I got myself into :P better design probably would avoid it, but it's a neat problem if you ignore the dumb reasons it was posed
19:23:06 <andrewsw> I should push for something like that. maybe an fp club would be a good start.
19:23:09 <gwern> cknapp: I see what I choose to, is all :(
19:23:15 <pumpkin_> here we get haskell as the second prereq for the CS major
19:23:24 <pumpkin_> the first being java :(
19:23:28 <cknapp> gwern: we were lamenting the lack of fp in our respective unis... but mine is getting better
19:23:48 <Axman6> my uni seems to have quite a nice FP community. it was one of our students who got that Sun machine for working on getting haskell fast on OpenSPARC
19:23:49 <gwern> andrewsw: an fp club would be awesome if it were secretly a method of dragooning & shanghaing unsuspecting CS undergrads into doing necessary haskell hacking
19:23:50 <cknapp> gwern: we all see what we choose. :)
19:24:01 <andrewsw> gwern: yes!
19:24:42 <andrewsw> It'd be cool to get our local ACM to allow an fp into the programming contests. That's be fun
19:24:46 <Axman6> wow... after my first year at uni, i have a good foot of textbooks
19:24:51 <conal> pumpkin_: got it!  http://hpaste.org/12602
19:24:53 <chessguy> i think it's a good idea to have OO and FP both as requirements for a CS degree
19:24:58 <gwern> that opens the windows to so many tactics - we could have each student 'adopt' a hackage package and make them update them and -wall clean them for 6.10!
19:25:11 <pumpkin_> conal: oh my :)
19:25:12 <cknapp> haha. I like
19:25:25 <gwern> heh heh heh. the suckers will never know what hit'em. as they use cabal and darcs, they'll have no choice but to learn them and file bugs and feature requests
19:25:31 <andrewsw> I agree chessguy. We only get OO, nd imperative. no fp *at all*
19:25:33 <apsod> Hrm, I need to poke around to see if anyone else is going to update the FreeBSD GHC port to 6.10.
19:26:05 <conal> pumpkin_: it's just a rearrangement, but it's the one that isolates the zip/unzip stuff and gives a single new combinator to be combined with others.
19:26:10 <pumpkin_> yeah
19:26:15 <andrewsw> it's sad. we are generating code monkeys, not computer scientists.
19:26:26 <gwern> hasn't that been the case for decades?
19:26:33 <conal> pumpkin_: oh, and i wrote that inZip in an obscure style.  it's a pattern that comes up a lot for me.
19:26:33 <andrewsw> prolly
19:26:51 <gwern> the way I see it, the universities may be shirking their duty, but the internet and OSS communities are turning the code monkeys into men
19:26:56 <Axman6> andrewsw: computer scientists produce themselves...
19:26:58 <gwern> so it's a tie
19:27:03 <pumpkin_> chessguy: I'd just prefer a nicer OO language, like smalltalk, even if it's less practical than java... but I do agree it's good to have two very different paradigms as prereqs
19:27:05 <conal> pumpkin_: you could also say inZip h = uncurry zip . h . unzip
19:27:07 <Shimei> Thankfully my university is proposing to switch from Java back to Scheme...
19:27:23 <chessguy> pumpkin_:  not to mention, you have to prepare kids for the real world
19:27:24 <pumpkin_> conal: nah, I get that pattern, I've been using it actually
19:27:25 <andrewsw> I did my first two years of cs in 1988-90. so it's a bit of a shock for me to come back to school and see how unrigorous the education is.
19:27:26 <cknapp> It's really hard for a lot of the unsuspecting students at my school, who hit the programming language course (taught in OCaml previously, then in Scheme, and soon(tm) in Haskell), and hit a wall... the 3 years of imperative code has damaged their brains, and they have acquired stockholm syndrome
19:27:32 <pumpkin_> chessguy: eww, I don't like the real world :P
19:27:34 <conal> pumpkin_: neat! :)
19:27:42 <chessguy> c'est la vie
19:27:56 <andrewsw> Axman6: :-). I'm trying.
19:28:00 <pumpkin_> conal: in fact, it seems like that pattern should be named somehow :P you see it all sorts of different places for all sorts of different things
19:28:06 <Axman6> andrewsw: me too :)
19:28:12 <pumpkin_> conal: if you could annotate functions as being inverses of one another, maybe
19:28:20 <Axman6> 2/3 of a semester on haskell got me hooked
19:28:23 <gwern> pumpkin_: you mean like in RULES?
19:28:28 <pumpkin_> maybe?
19:28:37 <pumpkin_> not sure what RULES is :)
19:28:52 <Axman6> things like reverse.reverse = id
19:29:26 <sjanssen> reverse . reverse /= id
19:29:41 <Axman6> i thing you use... {-# RULES <rule name> reverse.reverse = id #-} but i'm probably wrong
19:29:55 <Axman6> sjanssen: even on infinite lists, how does it not?
19:29:57 <sjanssen> Axman6: yep
19:30:08 <Axman6> oh hoorah, i've never even used them
19:30:10 <FunctorSalad> that pragmare are capitalized is funny here... makes the declaration look really harsh :o
19:30:13 <sjanssen> > reverse . reverse $ [1 ..]
19:30:14 <FunctorSalad> *pragmas
19:30:15 <gwern> pumpkin_: compiler optimizations; as Axman6 says you could define stuff like {-# RULES foo reverse .reverse = id #-} if you so cared; it's GHC's weak version of arbitrary rewrite code; the neat thing is they are surprisingly powerful, you can even basically implement type classes with them
19:30:16 <dolio> {-# RULES "eliminate bottoms!" reverse . reverse = id #-}
19:30:25 <sjanssen> > id $ [1 ..]
19:30:26 <FunctorSalad> lol
19:30:31 <FunctorSalad> ( dolio 0
19:30:33 <FunctorSalad> )
19:30:35 <conal> pumpkin_: yeah, exactly.
19:30:41 <pumpkin_> gwern: I mean for more explicit knowledge of inverses though...
19:30:45 <pumpkin_> let me come up with an example
19:30:51 <Axman6> > "lo?"
19:30:56 <lambdabot>   thread killed
19:30:56 <lambdabot>   thread killed
19:31:04 <lambdabot>   "lo?"
19:31:50 <pumpkin_> so say you represent a spatial rotation as a quaternion, you apply it to a vector by multiplying q v q^-1
19:31:51 <conal> pumpkin_: a rephrasing: "inB = result B . argument unB"  for a inverses B/unB
19:32:06 <conal> pumpkin_: wow -- it looks a lot friendlier that way.
19:32:52 <cknapp> pumpkin_: q v q^-1?
19:33:48 <pumpkin_> hmm, I haven't really fleshed out the idea much :P it just seemed analogous to a pattern like that I've seen in all sorts of different places
19:34:25 <cknapp> I'm trying to figure out where q and v come from... different notation, perhaps?
19:34:55 <gwern> v == || maybe
19:34:56 <pumpkin_> oh, q representing the rotation quaternion and the v representing the vector you want to apply the rotation to
19:35:06 <pumpkin_> nah, it's completely unrelated to haskell (for now)
19:35:13 <cknapp> oh. got it
19:35:31 <pumpkin_> was just trying to give an example of the f v f^-1 pattern that seems common
19:35:46 <Axman6> pumpkin_: oh, inear algebra stuff? looks like what we've just been doing
19:35:52 <pumpkin_> of course, it's a bit of a stretch at this point
19:36:15 <Axman6> gram-schmitt factorisation or something
19:37:01 <cknapp> gramm-schmitt... *cries*...
19:37:25 <saml> :i TimeDiff
19:37:25 <pumpkin_> maybe, not sure if quaternions are typically considered part of linear algebra, but if so, yeah... you also see a lot of that pattern with matrices being applied to vectors... but  can't think of any examples right now :P
19:37:41 <cknapp> quaternions typically aren't considered part of linear algebra...
19:37:45 <saml> :t tdPicosec
19:37:48 <lambdabot> Not in scope: `tdPicosec'
19:37:53 <pumpkin_> cknapp: didn't think so :)
19:38:00 <saml> @hoogle TimeDiff
19:38:00 <lambdabot> No results found
19:38:02 <cknapp> But they have a matrix representation of some sort
19:38:04 <Cale> Ah Gram-Schmidt, two names for a process which is the first thing you'd think of :)
19:38:14 <cknapp> :)
19:38:15 <saml> TimeDiff is in haskell98 report though
19:38:37 <saml> http://www.haskell.org/onlinelibrary/time.html
19:38:39 <cknapp> Math! Something I may know more than some of you about...
19:38:40 <lambdabot> Title: The Haskell 98 Library Report: Dates and Times
19:38:49 <pumpkin_> cknapp: definitely more than me :P
19:39:23 <Cale> cknapp: What part of mathematics do you like best?
19:39:52 <cknapp> I'm trying to pin that down, really... So far algebra or combinatorics...
19:40:04 <cknapp> but my experience isn't too deep anywhere... or as broad as I'd like
19:40:12 <Cale> Yeah, I tend to like things which mix algebra and something more tangible.
19:40:40 <jdrake> How can I put a % into a string passed to printf?
19:40:40 <cknapp> yeah, same... only tangible is rather loosely defined for me.
19:40:48 <Cale> Algebraic combinatorics, algebraic topology, algebraic geometry :)
19:40:55 <cknapp> :)
19:40:56 <Cale> jdrake: try %%
19:41:21 <jdrake> perfect
19:41:22 <jdrake> thanks
19:41:28 <pumpkin_> what is algebraic topology? I know what algebra is and what topology is, but not their combination :P
19:41:43 <ushdf> it's a big word for "algebraic topology"
19:41:49 <ushdf> \join #math
19:41:53 <pumpkin_> o.O
19:42:04 <ushdf> -ChanServ- [#math] Please don't ask to ask, and read the channel topic before posting a question.
19:42:07 <dolio> You use algebra to figure out the answer to topology stuff. :)
19:42:16 <pumpkin_> lol, yay
19:42:20 <cknapp> So, a topology is a set with an idea of open sets... an algebra is a set with some operations on it...
19:42:22 * pumpkin_ founds topological algebra
19:43:06 <cknapp> So, take one set, one set of open sets, and a bunch of operations, stir repeatedly and let simmer
19:43:34 <pumpkin_> lol, yay
19:43:52 <centrinia> Is there an algebraic analysis?
19:44:08 <cknapp> Um...
19:44:20 <cknapp> Yes and no...
19:44:37 <Cale> Algebraic topology is made up of a few areas. One of the first you usually encounter is homotopy theory, which is all about the set of loops in a space.
19:45:16 <cknapp> a lot of higher analysis deals with vector spaces of various sorts...
19:45:17 <centrinia> Besides algebra, is there any other field of mathematics that should not be prefixed by the word "algebraic"?
19:45:21 <Cale> You turn equivalence classes of loops into a group whose operation is roughly 'concatenation' of loops (they all start and finish at the same point)
19:45:27 <cknapp> centrinia: no
19:45:35 <mmorrow> {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
19:45:40 <dolio> There you go. Algebraic algebra.
19:45:43 <cknapp> Everything can and should (at some point) be prefixed by 'agberaic"
19:45:45 <pumpkin_> lol
19:46:02 <Axman6> mmorrow: heh
19:46:13 <cknapp> and then there's: algebraic algebraic algebra
19:46:27 <pumpkin_> algebraic algebraic towers!
19:46:43 <pumpkin_> graham's algebra
19:46:47 <sjanssen> @remember mmorrow {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
19:46:47 <Cale> This group, called the fundamental group, is actually a functor, in the sense that if you take any continuous map between pointed spaces, then this lifts to a homomorphism between their fundamental groups.
19:46:47 <lambdabot> I will remember.
19:47:18 <cknapp> I really need to learn category theory...
19:47:20 <Cale> So you can tell when there will be, or won't be, certain kinds of continuous maps between spaces by looking at their fundamental groups.
19:47:44 <Cale> The fundamental group can be rather hard to compute though.
19:48:39 <Cale> So there's another branch of algebraic topology called homology, and it always gives you an abelian group, with a bit less information than the fundamental group, but still generally useful.
19:48:59 <pumpkin_> conal: thanks again by the way... that's both neat and the first real use I've had for uncurry :P
19:49:17 <Cale> (and cohomology, which gives you not just an abelian group, but a ring)
19:49:37 <pumpkin_> so meta!
19:49:55 <conal> pumpkin_: you're welcome.  :)  that solution came to me quickly, but i forgot the uncurry, and had to flail around for a while.
19:50:01 <ushdf> is there some big list somewhere of all haskell symbols etc translated into english
19:50:07 <ushdf> and don't say the hyperspec
19:50:15 <mmorrow> pumpkin_: the key thing is you can go (Top space A <==homeomorphic==> Top space B) <-----> (fundamental group of A <==isomorphic==> fundam grp of B)
19:50:15 <centrinia> Is the cohomological ring commutative?
19:50:16 <Cale> ushdf: uh, the hyperspec is for lisp.
19:50:16 <conal> it's too bad that zip and unzip are not inverses, simply because of their types.
19:50:17 <ushdf> nm that's lisp, don't say the all-knowing haskell doc
19:50:32 <Axman6> ushdf: symbols?
19:50:33 <pumpkin_> conal: yeah :/
19:50:52 <Axman6> i thought most haskell was in english to begin with
19:51:30 <ushdf> nah
19:51:49 <Axman6> you mean things like (>>=)?
19:52:06 <ushdf> sure
19:52:08 <ushdf> !
19:52:26 <Axman6> their types tell you more than anthing.
19:52:26 <pumpkin_> since people can define them on the fly, it's hard
19:52:30 <Axman6> :y (>>=)
19:52:35 <Axman6> :t (>>=)
19:52:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:52:52 <ushdf> what a crazy language
19:52:55 <pumpkin_> it would be nice if there was some way to annotate new operators in haddock so it would make a "list of new operators and their meanings" at the top of the page though :P
19:52:57 <ushdf> :t $
19:52:59 <lambdabot> parse error on input `$'
19:53:03 <Axman6> ushdf: not once you get used to it
19:53:04 <centrinia> :t ($)
19:53:05 <lambdabot> forall a b. (a -> b) -> a -> b
19:53:19 * ushdf goes back to 'haskell for c programmers'
19:53:26 <Axman6> @src ($)
19:53:27 <lambdabot> f $ x = f x
19:53:27 <pumpkin_> lol
19:53:49 * ushdf sighs
19:53:55 <ushdf> @src foldl
19:53:56 <lambdabot> foldl f z []     = z
19:53:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:54:00 <centrinia> What does the binding operator (>>=) prove with respect to the Curry Howard correspondence?
19:54:05 <QtPlatypus> Whats the use of ($)?
19:54:07 <Axman6> does someone have a nice explanation of fixity and/or associativity of infix operators?
19:54:15 <centrinia> QtPlatypus: It applies a function to something.
19:54:36 <pumpkin_> Axman6: I was asking about that earlier, got no response :/
19:54:53 <Axman6> QtPlatypus: often used like: f.g.h.i.j 4 . t "hello" $ x
19:54:54 <pumpkin_> QtPlatypus: it allows you to "break" the default associativity
19:55:00 <andrewsw> QtPlatypus: seems to force application in a particular way when just using whitespace would be ambiguous?
19:55:07 <QtPlatypus> Ah ok
19:55:31 <dibblego> QtPlatypus, it has a lower precedence than application and so can be used to avoid the use of parentheses
19:55:50 <dibblego> f (a b) can be written f $ a b
19:56:01 <andrewsw> nice
19:56:06 <QtPlatypus> I can see how that could be useful.
19:56:08 <Axman6> yeah, it's basically a paren avoidence thing
19:56:16 <ushdf> i prefer the former, i think
19:56:20 <ushdf> <3 parens
19:56:23 <pumpkin_> o.O
19:56:32 * pumpkin_ hands ushdf scheme
19:56:33 <andrewsw> ISTM the biggest simple thing missed by haskell n00bs (like me) is that ' ' is function application.
19:56:36 <Axman6> instead of having f (g (h (i (j x))))
19:57:17 <Axman6> ushdf: you can think of $ as | in the shell backwards
19:57:32 <QtPlatypus> Axman6: f . g . h . i . j $ x ?
19:57:47 <Axman6> QtPlatypus: instead of (f . g . h . i . j) x
19:58:03 <Axman6> where (f . g . h . i . j) :: a -> b, and x :: a
19:58:39 <Axman6> QtPlatypus: ah, i see where you're coming from, yes, that's exactly it
19:58:42 <ushdf> now there's an answer
19:58:58 <ushdf> so | backwards is |
19:59:03 <ushdf> ;0
19:59:12 <Axman6> if you mean $, then yes
19:59:19 * ushdf is joking
19:59:37 <andrewsw> really though $ sideways is |
19:59:41 <andrewsw> I mean, just look at it.
19:59:54 <cknapp> clearly, andrew
20:00:11 * ushdf looks at it
20:00:21 <ushdf> i think i see what you're getting at
20:00:23 <centrinia> Well, think of the 'S' as being the contravariant indicator. :p
20:00:46 <ushdf> i think i'd rather not
20:01:17 <Axman6> basically cat "foo" | bar is equivilant to bar $ cat "foo" (which is the same as bar (cat "foo"))
20:02:51 <pumpkin_> has anyone written a haskell shell replacement?
20:02:52 <mmorrow> , zipWith ($) (fmap (*) [0..]) [2..]
20:02:55 <Cale_> I would think | is most analogous to . with $ supplying the 'stdin'
20:02:57 <lunabot>  [0,3,8,15,24,35,48,63,80,99,120,143,168,195,224,255,288,323,360,399,440,4...
20:03:25 <andrewsw> in that case, you have to look at | from the top to get .
20:03:34 <Axman6> Cale_: yeah, that's probably a better analogy
20:04:07 <cknapp> On the subject of composition and $... How can I get fst (unzip (zip l1 l2)) to be cleaner? ghci and hugs are both yelling at me
20:04:11 <Axman6> pumpkin_: i think there is one
20:04:19 <cknapp> (It's jsut a test example....
20:04:24 <Cale_> cknapp: fst . unzip $ zip l1 l2
20:04:31 <cknapp> Thanks
20:04:44 <mmorrow> , ppDoc `fmap` let g |.| f  = [|$g . $f|] in foldr (|.|) [|id|] (replicate 6 [|id|])
20:04:47 <lunabot>  id . (id . (id . (id . (id . (id . id)))))
20:04:49 <centrinia> (fst . unzip . zip) l1 l2
20:04:51 <mmorrow> , ppDoc `fmap` let g |.| f  = [|$g . $f|] in foldl (|.|) [|id|] (replicate 6 [|id|])
20:04:54 <lunabot>  (((((id . id) . id) . id) . id) . id) . id
20:04:57 <Cale_> Unfortunately, you can't use multiple $'s to supply more than one parameter.
20:05:01 <Axman6> cknapp: or fst.unzip.zip l1 $ l2, if you want to be crazy >_>
20:05:14 <Cale_> (it ends up meaning the same as composition because the associativity of $ is wrong)
20:05:35 <Axman6> wrong?
20:05:43 <pumpkin_> @djinn ((a1 -> b1) -> a -> b) -> (a1 -> b1) -> a -> b
20:05:44 <lambdabot> f a = a
20:05:47 <pumpkin_> :P
20:06:03 <Axman6> Cale: could you explain associativity (and perhaps fixity?)
20:06:11 <Cale> Sure
20:06:18 <mmorrow> , ppDoc `fmap` let tup a b  = [|($a,$b)|] in foldr tup [|()|] (fmap list [0..9::Int])
20:06:20 <lunabot>  luna: Not in scope: `list'
20:06:25 <mmorrow> , ppDoc `fmap` let tup a b  = [|($a,$b)|] in foldr tup [|()|] (fmap lift [0..9::Int])
20:06:28 <lunabot>  (0, (1, (2, (3, (4, (5, (6, (7, (8, (9, ()))))))))))
20:06:32 <mmorrow> , ppDoc `fmap` let tup a b  = [|($a,$b)|] in foldl tup [|()|] (fmap lift [0..9::Int])
20:06:33 <Cale> Currently $ is declared to be  infixr 0
20:06:35 <lunabot>  (((((((((((), 0), 1), 2), 3), 4), 5), 6), 7), 8), 9)
20:06:52 <Cale> Which means that it attaches to its arguments as weakly as possible, and associates to the right.
20:06:58 <pumpkin_> mmorrow: whoa that isn't normally possible, right?
20:07:16 <Cale> Which means that if you write:  a $ b $ c $ d  it means  a $ (b $ (c $ d))
20:07:33 <mmorrow> pumpkin_: yeah, you can't do it within haskell's type system, but you can do it on the meta-level
20:07:48 <pumpkin_> mmorrow: ah, I guess that's what those fancy || are for?
20:07:50 <Cale> Normal function application (' ') binds as tightly as possible (stronger than any infix operator), and associates to the left
20:07:52 <pumpkin_> is that template haskell?
20:07:54 <mmorrow> and then the code you generate is checked within the type system at compile time
20:08:01 <Cale> So  a b c d  means  ((a b) c) d
20:08:01 <Axman6> right, i see
20:08:05 <mmorrow> pumpkin_: yeah, template-haskell
20:08:15 <Axman6> Cale: and how is . defined?
20:08:17 <Axman6> (.)
20:08:18 <mmorrow> , $( [| 42 |] )
20:08:20 <lunabot>  42
20:08:29 <Cale> (f . g) x = f (g x)
20:08:39 <pumpkin_> mmorrow: ah cool, been using it for derive but haven't looked at it much, but it's on my (priority) queue for things to read :P
20:08:39 <Cale> (.) is actually associative
20:08:47 <Cale> But it's defined to be infixr 9
20:08:48 <mmorrow> , $( return (LitE (IntegerL 42)) )
20:08:50 <lunabot>  42
20:08:56 <mmorrow> , [|42|]
20:08:58 <lunabot>  LitE (IntegerL 42)
20:09:02 <pumpkin_> Cale: I asked about this earlier, but is there an easy way to look up the fixity of an operator?
20:09:09 <Axman6> associative meaning what exactly? i know the word, but i always forget the definition
20:09:10 <Cale> pumpkin_: :info (.)
20:09:17 <cknapp> Cale: (.) is associative?
20:09:20 <Cale> (f . g) . h = f . (g . h)
20:09:20 <pumpkin_> Cale: oh, perfect, thanks
20:09:25 <Axman6> ah right
20:09:25 <Cale> cknapp: yep
20:09:30 <cknapp> Oh...
20:09:30 <cknapp> nevermind
20:09:50 <Cale> Associating it to the right is a little bit more efficient though.
20:09:51 <andrewsw> so if a b c d means ((a b) c) d),  how do you get ((a (b c)) d)
20:09:55 <cknapp> My brain was filling in parenthesis in weird ways and I said "surely, no!"
20:10:01 <mmorrow> pumpkin_: it's really really swell ;) it can make your life way easier if you battle out the initial learning curve (not much documentation)
20:10:02 <Cale> andrewsw: By adding explicit parens
20:10:07 <Cale> andrewsw: a (b c) d
20:10:11 <andrewsw> oh.
20:10:14 <andrewsw> heh.
20:10:39 <Cale> If $ associated to the left, you could write  a $ b c $ d
20:10:44 <mmorrow> pumpkin_: here's an example of code generated with TH http://hpaste.org/12598
20:10:44 <pumpkin_> mmorrow: exciting, I already consider haskell to be really really swell, so if someone's used to haskell and thinks TH is really really swell, that's like really^4 swell for me :P
20:10:46 <Cale> But it unfortunately does not.
20:10:57 <Cale> and that ends up meaning the same as a . b c $ d
20:11:16 <pumpkin_> mmorrow: oh, that's really handy... how powerful is the template language? is it just haskell generating haskell?
20:11:16 <mmorrow> pumpkin_: totally. once i started to realize what TH could make possible, i was hooked
20:11:44 <pumpkin_> mmorrow: seems like if it's general-purpose, you could use it to write a new parser generator
20:11:54 <pumpkin_> without separate grammar files
20:12:28 <badkins> Given the following:
20:12:29 <badkins> shuffle xs = concat [[fst x, snd x] | x <- uncurry zip (splitAt (length xs `div` 2) xs)]
20:12:35 <mmorrow> pumpkin_: yeah, haskell generating haskell. the interesting thing though is that you can bot create decls/exps using the abstract syntax datatype TH uses to rep haskell, /or/ use actual haskell source-level syntax. then you can use either and splice that into either
20:12:42 <badkins> I'd like to avoid concat
20:13:23 <badkins> i.e. having to use [fst x, snd x] in the comprehension, and then concat to flatten, seems a little kludgy.
20:13:25 <mmorrow> pumpkin_: totally. i've thought about what that would entail off-and-on for a while. i think you could totally write a parser-generator in TH.
20:13:44 <Cale> shuffle xs = do (x,y) <- uncurry zip (splitAt (length xs `div` 2) xs); [x,y]
20:13:45 <pumpkin_> sounds like a fun project
20:14:05 <Cale> You could also...
20:14:22 <roconnor> return x `mplus` return y
20:14:25 <Cale> shuffle xs = [z | (x,y) <- uncurry zip (splitAt (length xs `div` 2) xs), z <- [x,y]]
20:14:31 <mmorrow> also, you could (e.g.) use TH to super-optimize ffts or super-optimized anything automatically
20:15:07 <Axman6> superoptimise?
20:15:08 <badkins> Cale: thx, I'll give it a tery
20:15:09 <badkins> try
20:15:11 <mmorrow> i've thought also about using it to flatten Monad stacks and autogenerate the necessary data decls + classw instances + helper functions
20:15:17 <pumpkin_> it seems like something like fftw would be expressible in haskell a lot more nicely than it is in c right now
20:15:26 <pumpkin_> (the idea of composable fft "codelets")
20:15:59 <mmorrow> @unmtl ContT (Writer (Cont r (State s a)) b) (ReaderT r IO) d
20:16:00 <lambdabot> (d -> r -> IO (b, ((s -> (a, s)) -> r) -> r)) -> r -> IO (b, ((s -> (a, s)) -> r) -> r)
20:16:02 <mmorrow> heh
20:16:38 <Axman6> ...
20:16:46 <dolio> > uncurry (++) . foldr (\e (l,r) -> (e:r,l)) ([],[]) $ [1..20]
20:16:48 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20]
20:16:58 <mmorrow> so you could use TH to do pretty much what @unmtl does, but in addition actually generate that data (probably a newtype) declaration + instances of Functor and Monad + whatever
20:17:04 <cknapp> Hmm... there's nothing like deciding to rewrite a project with less than a week to finish... when using a language you just learned.
20:17:37 <pumpkin_> cknapp: that's exactly what I'm doing :P except it isn't even rewriting it
20:17:40 <cknapp> At least my code will be pretty?
20:17:44 <pumpkin_> my project is due on wednesday
20:17:45 <Axman6> :t uncurry
20:17:45 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:17:51 <cknapp> *prettier
20:18:00 <cknapp> Hehehe
20:18:07 <cknapp> What do you mean it isn't rewriting?
20:18:16 <pumpkin_> cknapp: I never had an implementation in another language
20:18:24 <Cale> cknapp: Well, often the largest amount of time is just spent thinking.
20:18:25 <pumpkin_> writing it from scratch in haskell, which I only just started learning
20:18:38 <Cale> cknapp: So it's not unreasonable to type out a different version at the end ;)
20:18:50 <cknapp> Oh... see, neither did I, I just had crappy code flying around, and got sick of it.
20:18:55 <mmorrow> Axman6: hehe, Super Optimize®
20:18:56 <pumpkin_> :)
20:19:03 <Axman6> :o
20:19:10 <pumpkin_> mmorrow: if you love TH so much, why don't you marry it??
20:19:13 <badkins> dolio: seems to be a different algorithm
20:19:25 <mmorrow> pumpkin_: gosh, well maybe i will
20:19:52 <Axman6> i read a paper on assembly super optimisation, where they'd written something that would take assembly, and fuck with it, until it was much shorted and faster... problem is that it took hours back in those days to do even simple optimisation
20:20:09 <dolio> badkins: Yeah, I accidentally wrote unshuffle. :)
20:20:10 <mmorrow> Take Assembly And Fuck With It®
20:20:15 <pumpkin_> lol
20:20:20 <mmorrow> heh
20:20:38 <centrinia> Axman6: It is harder now because you can't really determine how great a sequence of assembly instructions are anymore with current processors. :(
20:20:48 <pumpkin_> btw, I was reading the old jhc page... is it any more feasible to compile large programs with it now, or does it still take up multiple gigs to optimize?
20:20:54 <Axman6> ok, if i even write any papers, they shal have names like "Take assembly and fuck with it"
20:21:24 <pumpkin_> o.O [25 of 29] Compiling HAppS.Server.Facebook ( src/HAppS/Server/Facebook.hs, dist/build/HAppS/Server/Facebook.o )
20:21:45 <centrinia> One should always insert the word "fuck" in the title of a paper. :)
20:22:37 <Axman6> indeed
20:22:41 <pumpkin_> I did a final project on brainfuck for one of my courses, and greatly enjoyed being able to say fuck repeatedly in front of the class
20:22:51 <Axman6> ha
20:23:05 <lament> did you say it like "brainffffFFFUCK"
20:23:09 <pumpkin_> the prof looked kinda uncomfortable though
20:23:13 <Lemmih> pumpkin_: Few non-joy programs are compilable by jhc/lhc.
20:23:23 <Cale> centrinia: Unless you write a simulator :)
20:23:34 <centrinia> Did you choose to do the project on Brainfuck just to be able to say "fuck" repeatedly in front of the class?
20:23:36 <Cale> centrinia: It was reasonably doable with powerpc.
20:23:41 <pumpkin_> Lemmih: are there plans or ideas on how to make it less resource-intensive?
20:23:48 <pumpkin_> centrinia: nah, brainfuck was a lot of fun
20:23:55 <Cale> centrinia: At least, the G4's were easy.
20:23:58 <Axman6> Cale: why PPC?
20:24:30 * Axman6 's family still use a G3 and a G5 daily
20:24:32 <Lemmih> pumpkin_: Being resource-intensive isn't the biggest of our problems.
20:24:35 <Cale> Axman6: Well, the rules about how long instructions would take to execute were not so hard to understand.
20:24:46 <Axman6> ah fair enough
20:25:15 <Lemmih> pumpkin_: It simply can't compile most programs (even if it had unlimited resources).
20:25:19 <pumpkin_> ah
20:25:26 <Cale> (just had to be reasonably aware of which units were already in use)
20:25:31 <centrinia> Too bad you can't really do accurate models of cache behavior for larger snippets of assembly. :(
20:26:32 <Cale> For stuff which mostly stays in registers, it works out all right though.
20:27:37 <dolio> Incidentally, am I doing something wrong? I got, I think, the latest cabal, but my cabal has no --lhc option.
20:28:10 <Lemmih> dolio: The 'cabal' binary comes from the 'cabal-install' package.
20:28:15 <dolio> Right.
20:29:10 <dolio> The version from the darcs repository is still marked 0.6.0, which is what I had before.
20:29:18 <dolio> Am I not getting some newer version of cabal-install?
20:29:53 <ushdf> bsdtar -x -f Cabal-1.6.0.1.tar.gz
20:30:09 <ushdf> Configuring Cabal-1.6.0.1...
20:30:14 <Lemmih> dolio: Perhaps you're still using the old binary?
20:33:56 <dblazakis> i am failing at FFI
20:33:56 <Guest49984> dolio: you've to relax the Cabal dependency in cabal-install.cabal
20:34:07 <dolio> Oh.
20:34:32 <Lemmih> Saizan: Really? Why?
20:34:39 <dolio> It's set not to use 1.7
20:35:09 <Saizan> Lemmih: Cabal >= 1.6 && < 1.7
20:35:11 <orbitz> is there a radical difference bewten gc'in gin a langage like haskell than java?
20:35:33 <Lemmih> Saizan: If cabal-install doesn't compile against the right Cabal, it won't compile.
20:35:58 <dblazakis> does libkernel32.a fail to include some symbols?
20:36:21 <Saizan> Lemmih: duncan has bumped the Cabal version after your patches
20:36:38 <Saizan> Lemmih: but cabal-install still has the dependency i mentioned above
20:36:59 <Saizan> Lemmih: so maybe you want to push a patch that changes that "< 1.7"
20:37:10 <Lemmih> Saizan: I don't understand how cabal-install would silently fail in that case.
20:37:39 <dolio> orbitz: I think they tend to use different strategies, since the way functional programs allocate and deallocate memory tends to be different from an imperative OO language.
20:37:47 <dolio> orbitz: I'm not gc guru, though.
20:38:00 <pumpkin_> what does rnf stand for again?
20:38:02 <Lemmih> cabal-install depends on cabal exporting LHC. If your cabal is exporting LHC then you're in the clear no matter which version you've got.
20:38:13 <orbitz> dolio: thanks
20:40:10 <dolio> Lemmih: Cabal 1.6 doesn't export LHC, but 1.7 does. But cabal-install is set to compile against 1.6, so even if you have 1.7 installed, it won't get the --lhc option.
20:40:18 <Saizan> Lemmih: HEAD cabal-install compiled fine against Cabal-1.6.0.1 just now
20:40:33 <dolio> If I'm following this correctly.
20:41:25 <Lemmih> Ah, so if Cabal <= 1.6, LHC support is #ifdef'd out.
20:42:59 <cknapp> how do I make something an instance of Show?
20:43:16 <cknapp> nevermind...
20:43:20 <cknapp> I'll read documentation
20:43:21 <cknapp> :)
20:43:22 <Saizan> add deriving (Show)
20:43:34 <Saizan> to the data declaration+
20:44:01 <Saizan> or make your own instance with "instance Show SomeThing where show x = ..."
20:45:22 <cknapp> Thanks
20:47:18 <dolio> All right. Time to see if my computer can handle the dreaded base compile.
20:51:12 <dolio> Looking good. 75% done and only 55% usage.
20:51:23 <dolio> Memory usage.
20:55:34 <dolio> Hey, lhc compiles my old polymorphic recursion example that used to blow up.
20:58:57 <Lemmih> dolio: If you find something small lhc can't compile, please let me know so I can add it to the testsuite.
20:59:20 <dolio> Will do.
21:05:21 * dons waves
21:05:32 * conal waves back to dons
21:06:00 * cknapp waves too
21:08:05 * Lemmih wonders what fixpoints has to do with type analysis.
21:10:26 <andrewsw> reliably reproducible or random?
21:10:30 <andrewsw> whoops
21:14:47 <FunctorSalad> did someone make a TH module for type-level types and functions yet? ;)
21:15:02 <FunctorSalad> (all that duplication is tedious)
21:19:41 <dolio> > (!!100) . fix $ (0:) . scanl (+) 1
21:19:45 <lambdabot>   354224848179261915075
21:22:44 <mmorrow> Lemmih: i have a short prog that may be worthwhile to add to the testsuite of whathaveyou. it's a csv parser implem with a state machine via mutually recursive functions and jhc quickly exhausts all system mem running it while ghc and /hbc/ run it in constant mem. http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=199
21:23:19 <mmorrow> i think the problem may be two-fold actually which complicates things. leaving the recursive side alone, compiling just the prog:
21:23:27 <mmorrow> main = putStr =<< getContents
21:23:40 <mmorrow> with jhc quickly exhausts my entire mem
21:24:01 <mmorrow> i'm not sure about lhc yet since i haven't got base built yet
21:24:02 <dolio> thoughtpolice: Said the region inference algorithm was broken, so that may be why it destroys your memory.
21:24:48 <mmorrow> yeah, i was assuming that was at fault for the recursive stuff, but could that be to blame for getContents space-leaking all mem too?
21:25:00 <dolio> No idea.
21:25:42 <Lemmih> mmorrow: We don't have a garbage collector yet so we're mostly interested in programs that fail to compile.
21:25:44 <mmorrow> i'm way surprised that getContents is broken since that seems to be one of more widely used functions exported by prelude
21:26:14 <dolio> Hmm, well, lhc seems to have defeated ghc in my rudimentary fib benchmark.
21:26:30 <dolio> fib 45, 20 seconds for lhc, 4 minutes 32 seconds for ghc.
21:26:44 <mmorrow> Lemmih: ah, i see. so "broken" as in "yes, literally".
21:27:29 <mmorrow> dolio: totally. {l,jhc crushes in non-resursive (maybe some recursive-dependent?) stuff for sure.
21:28:08 <mmorrow> i guess all my woes are due to garbage collection collection issues possibly.
21:30:02 <dolio> Well, I'm pretty sure fib is recursive. :)
21:30:18 <mmorrow> heh, i guess it depends on the fib
21:30:34 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1
21:30:37 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
21:30:50 <mmorrow> <dolio> Hey, lhc compiles my old polymorphic recursion example that used to blow up.
21:30:53 <mmorrow> ooh, cool
21:30:59 <mmorrow> is the code anywhere?
21:31:02 <dolio> I guess that means if j/lhc ever gets to being able to run the recursive benchmark on the shootout, we should get it on there.
21:31:20 <dolio> mmorrow: I was using the bad implementation of fib. :)
21:31:26 <mmorrow> dolio: sounds good to me :)
21:31:34 <mmorrow> (@shootout)
21:31:39 <dolio> If it's 13x faster than ghc, that should look pretty good. :)
21:32:17 <pumpkin_> what are people's day jobs here? do they involve haskell?
21:32:34 <dolio> It's nothing complex: "f :: Show a => a -> Int -> String ; f x 0 = show x ; f x n = f (x,x) (n-1)"
21:32:39 <dolio> Plus a driver.
21:32:42 <mmorrow> yeah, don't get me wrong, i'm not ragging on j/lhc (well, i kinda am ;). they're friggin screaming on the stuff they actually run without be hindered by whatever
21:32:44 * pumpkin_ writes a constant-time fib function
21:33:16 <dolio> But it used to give a really bizarre error.
21:33:48 <mmorrow> hmm
21:35:56 <pumpkin_> > let phi = (root5 + 1) / 2; root5 = sqrt 5 in let fib (n + 1) = (phi^n - (1 - phi)^n) / root5 in fib 10
21:35:58 <lambdabot>   34.0
21:36:52 <pumpkin_> > let phi = (root5 + 1) / 2; root5 = sqrt 5 in let fib (n + 1) = (phi^n - (1 - phi)^n) / root5 in map fib [1..10]
21:36:54 <lambdabot>   [0.0,1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0]
21:37:02 <mmorrow> heh, (randomly) i remember where i was when i first had to solve that recurrence
21:37:03 <pumpkin_> > let phi = (root5 + 1) / 2; root5 = sqrt 5 in let fib (n - 1) = (phi^n - (1 - phi)^n) / root5 in map fib [1..10]
21:37:04 <lambdabot>   <no location info>: Parse error in pattern
21:37:09 <mmorrow> (with a pencil)
21:37:13 <pumpkin_> whoops :)
21:37:34 <pumpkin_> where were you?
21:37:58 <mmorrow> in my schools student center one the second floor at 6am
21:38:10 <pumpkin_> :o
21:38:12 <mmorrow> s/my school/the school i went to/
21:38:15 <pumpkin_> how long ago is that?
21:38:22 <mmorrow> i gradutated in 2005
21:38:28 <pumpkin_> ah
21:38:29 <mmorrow> so i'm 25
21:38:40 <pumpkin_> I graduated in 2007 and I'm 24 :o
21:38:55 <pumpkin_> that's cause I suck though
21:39:03 <mmorrow> heh
21:39:21 <mmorrow> what'd you study?
21:39:28 <pumpkin_> CS :)
21:39:40 <mmorrow> i started out as cs but switched to math halfway through
21:39:42 <pumpkin_> originally wanted to be math/cs double major, but got lazy
21:40:52 <mmorrow> yeah, i was like oh yeah sure i'll do a math major cs minor but just didn't
21:40:57 <hackage> Uploaded to hackage: PlslTools 0.0.2
21:42:38 <pumpkin_> Cale brings happiness to the world. 11.0% lines contained smiling faces. :)
21:42:47 <Cale> yep :)
21:42:50 <mmorrow> haha
21:42:57 <pumpkin_> mauke seems to be sad at the moment: 1.3% lines contained sad faces. :(
21:43:06 <Saizan> oh, we've stats?
21:43:12 <pumpkin_> sure looks like it: http://www.cse.unsw.edu.au/~dons/irc/haskell.html
21:43:14 <lambdabot> Title: #haskell @ freenode.org stats by dons
21:43:28 <mmorrow> that'd be great if the bots had access to this info so anyone could just whip out a random metric off the cuff
21:43:51 <pumpkin_> shapr always lets us know what he/she's doing: 15278 actions!
21:43:52 <pumpkin_> lol
21:44:28 <dons> hehe
21:45:28 <pumpkin_> the most active times is not very indicative without a timezone indicator :P
21:47:18 * shapr does not!
21:47:27 <pumpkin_> lol
21:48:01 <cknapp> What's a good way to curry in haskell? I'm used to scheme, where I can just through lambdas
21:48:07 <cknapp> *around
21:48:21 <pumpkin_> you just pass the parameters you want in
21:48:33 <cknapp> Rather...
21:48:47 <sclv> :t (+)
21:48:48 <cknapp> If I want to map a curried function... map (\x -> stuff) list
21:48:49 <lambdabot> forall a. (Num a) => a -> a -> a
21:48:50 <sclv> :t (+) 1
21:48:52 <pumpkin_> > map (5 +) [1..4]
21:48:52 <lambdabot> forall t. (Num t) => t -> t
21:48:53 <lambdabot>   [6,7,8,9]
21:49:11 <sclv> everything is pre-curried!
21:49:15 <sclv> ?ty curry
21:49:16 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:49:19 <cknapp> brain... frying.
21:49:40 <cknapp> Right.
21:49:41 <lament> cknapp: every function in haskell takes one argument
21:49:44 <cknapp> I knew this... I sware
21:49:46 <cknapp> swear*
21:49:52 <dmwit__> You shouldn't swear, it's not nice.
21:49:53 <pumpkin_> > let f x y = 5 * x + y in map (f 5) [1..5]
21:49:54 <lambdabot>   [26,27,28,29,30]
21:50:21 <pumpkin_> > let f x y = 5 * x + y in map (flip f 5) [1..5]
21:50:22 <lambdabot>   [10,15,20,25,30]
21:50:32 <shapr> pumpkin_: Whoa, dons is about to pass me for total number of lines.
21:50:45 <lament> shapr: you should have said that as an action
21:50:46 <cknapp> What does flip do?
21:50:47 <pumpkin_> shapr: quick, start spamming
21:50:50 <shapr> Nah :-)
21:50:53 <dmwit> It's not that he talks that much, it's just that he announces all his reddit submissions in here. ;-)
21:50:54 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
21:50:57 <dmwit> whoa
21:50:58 <Saizan> ?src flip
21:50:58 <cknapp> nevermind...
21:50:58 <lambdabot> flip f x y = f y x
21:50:59 <lament> don't spam, just ban dons
21:51:03 <dolio> Lemmih: Where do you want reports about what lhc can't compile?
21:51:48 <cknapp> flip f x y z = f y x z?
21:51:59 <dolio> Lemmih: lhc mailing list?
21:52:05 <pumpkin_> > flip f g h
21:52:05 <dmwit> cknapp: Yes, but without the z.
21:52:06 <lambdabot>   Add a type signature
21:52:06 <dibblego> flip f x y = f y x
21:52:11 <pumpkin_> > flip f g h :: [Expr]
21:52:12 <lambdabot>       No instance for (SimpleReflect.FromExpr [Expr])
21:52:12 <lambdabot>        arising from a u...
21:52:16 <cknapp> oh...
21:52:19 <pumpkin_> > (flip f g h) :: [Expr]
21:52:20 <lambdabot>       No instance for (SimpleReflect.FromExpr [Expr])
21:52:20 <lambdabot>        arising from a u...
21:52:22 <pumpkin_> :(
21:52:26 <Saizan> Expr
21:52:29 <dmwit> cknapp: You can, of course, use it on functions of higher arity, but you aren't restricted to functions of higher arity.
21:52:32 <Saizan> > flip f g h :: Expr
21:52:33 <pumpkin_> is only f and g defined?
21:52:33 <lambdabot>   Add a type signature
21:52:39 <pumpkin_> oh duh
21:52:43 <cknapp> You'd think I'd have learned this by now...
21:52:45 <dmwit> > flip f x y
21:52:46 <lambdabot>   Add a type signature
21:52:49 <Saizan> bah, too much polymorphism there
21:53:07 <cknapp> Especially sicne I learned LC a year ago... at least
21:53:12 <ski_> @tell gwern actually, that quote is due to Dave Benjamin, not me .. i've just quoted it here sometime and someone apparently thought i invented it, and promptly inserted it into lambdabot
21:53:13 <lambdabot> Consider it noted.
21:53:15 <dmwit> > flip f x y :: Expr
21:53:16 <lambdabot>   f y x
21:53:19 <pumpkin_> > flip f x y z :: Expr
21:53:20 <lambdabot>   f y x z
21:53:27 <pumpkin_> phew
21:53:42 <dmwit> ski_: What didn't you invent?
21:54:02 <ski_> @quote parametric
21:54:03 <lambdabot> ski says: please talk to your son or daughter about parametric polymorphism
21:54:05 <ski_> that one
21:54:19 <dmwit> ah =)
21:54:29 * thoughtpolice yawns
21:54:47 <pumpkin_> > unyawn thoughtpolice
21:54:48 <lambdabot>   Not in scope: `unyawn'Not in scope: `thoughtpolice'
21:55:03 <pumpkin_> :(
21:55:56 <Saizan> there was a quote from spj's daughter like "i do not want functional programming!"
21:57:50 <pumpkin_> how often does lambdabot lose its bindings?
21:57:57 <pumpkin_> > mandel (1 :+ 0)
21:57:58 <lambdabot>   2.0e-2
21:58:00 <pumpkin_> :o
21:58:44 <grom358> http://hpaste.org/12604 . Why do I get error when I change nth to type Integral -> Char ?
21:58:48 <dmwit> pumpkin_: Every time somebody says ?undefine.
21:58:53 <pumpkin_> ah
21:59:01 <dmwit> grom358: Integral is not a type, it's a class.
21:59:01 <Saizan> in any channel.
21:59:16 <ski_> @quote sarah
21:59:16 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
21:59:17 <dmwit> grom358: Also, (!!) takes arguments of type Int.
21:59:26 <dmwit> :t (!!)
21:59:27 <lambdabot> forall a. [a] -> Int -> a
21:59:32 <pumpkin_> grom358: you'd need (Integral a) => [a] if you wanted that
21:59:44 <lament> heh, that's a pretty deep insight
21:59:53 <lament> (go <=> functional programming)
21:59:58 <pumpkin_> ?
22:00:41 <pumpkin_> has anyone written a gmp-alike in pure haskell?
22:00:42 <grom358> dmwit: ah..
22:00:43 <dmwit> Knowing SPJ, he said something along the lines of "and once you place a stone, it can never move... it's like functional programming!"
22:00:47 <dmwit> ;-)
22:02:36 <pumpkin_> wow, talkative fellow
22:03:12 <pumpkin_> I guess not everyone is as logorrheic as I am
22:04:27 <dmwit> Hmm, profiling is pretty informative.
22:06:35 <dmwit> 40% of my time is being spent in #!.
22:06:52 <dmwit> Considering I named it #! because I thought it was a pretty trivial operation, that's saying something...
22:07:47 <cknapp> > :t ($)
22:07:49 <lambdabot>   <no location info>: parse error on input `:'
22:08:00 <dmwit> :t ($)
22:08:02 <lambdabot> forall a b. (a -> b) -> a -> b
22:08:11 <cknapp> Thanks
22:08:14 <dmwit> cknapp: ($) = id
22:08:23 <dmwit> It's just for parenthesis-avoidance.
22:08:47 <cknapp> Yeah... I was hoping the type would give me an indication of how parenthesis were avoided
22:09:02 <lament> cknapp: not the type; the precedence
22:09:07 <cknapp> ah
22:09:20 <dmwit> > 15/23
22:09:22 <lambdabot>   0.6521739130434783
22:09:41 <dons> dmwit: cool
22:10:28 <lament> cknapp: $ has a higher precedence than function application (" "), so a $ b c  =  a (b c)
22:10:30 <pumpkin_> :i ($)
22:10:50 <pumpkin_> cknapp: type that into ghci and it'll tell you its precedence
22:11:24 <cknapp> Thanks
22:11:33 <cknapp> That makes sense now.
22:11:49 <lament> $ is one of those little things that make haskell usable by humans
22:11:56 <lament> as opposed to, say, Lisp :)
22:12:14 <dmwit> dons: Yeah, it is pretty cool.  Figuring that out is now leading to a refactor that's making the code both shorter and faster (already 30% faster!).
22:12:58 <cknapp> (but (i (like (my (parenthesis)))))
22:13:22 <pumpkin_> you can still use it, but I advise against it if you want anyone reading your code :P
22:14:14 <Saizan> lament: s/higher/lower&
22:14:29 <lament> whatever
22:14:36 <lament> they mean the same thing :)
22:14:40 <pumpkin_> doesn't function application have the highest precedence? above any specifiable operator
22:14:54 <Saizan> yeah
22:15:04 <lament> pumpkin_: which function application, though
22:15:08 <Saizan> and $ has the lowest precedence
22:15:22 <lament> oh, right
22:15:23 <pumpkin_> lament: ?
22:15:34 <lament> nevermind, i got confused with higher/lower again
22:15:46 <lament> i think the haskell usage is opposite of the "common" usage
22:15:56 <lament> where * has higher precedence than +
22:16:18 <pumpkin_> hmm? * has 7, + has 6
22:16:44 <lament> oh, i see! sorry! i'm not confused. I'm just plain wrong.
22:17:24 <lament> but then why does $ work the way it does? Now I'm also confused.
22:17:25 <pumpkin_> it affects function application by taking the place of one of the parameters, I thnk
22:17:52 <pumpkin_> :t ($)
22:17:53 <lambdabot> forall a b. (a -> b) -> a -> b
22:17:57 <pumpkin_> @src ($)
22:17:58 <lambdabot> f $ x = f x
22:18:16 <pumpkin_> actually
22:18:21 <Saizan> lament: having higher precedence means binding tighter to the arguments
22:19:31 <lament> i see.
22:19:34 <Saizan> so "f x y $ g x z" will put $ at the top of the AST
22:20:03 <lament> it's so nasty that precedence is an actual number
22:21:10 <pumpkin_> it'd be nice if you could say infixr (**********) (sameAs (*)) or something to avoid having to look them up
22:21:10 <Saizan> yeah, a preorder would be cleaner, but maybe more tedious in practice
22:22:05 <dons> ?users
22:22:05 <lambdabot> Maximum users seen in #haskell: 561, currently: 489 (87.2%), active: 12 (2.5%)
22:23:08 <dmwit> Wow!
22:23:14 <dmwit> 8x faster after the change
22:23:21 <pumpkin_> dmwit: nice :)
22:23:24 <dons> dmwit: yay
22:23:31 <Saizan> what (#!) was?
22:23:58 <dmwit> Turns out that wrapping and unwrapping constructors is darn slow.
22:24:03 <dmwit> Even if they're strict.
22:24:07 <mmorrow>  cps++
22:24:08 <Cale> Saizan: Surely you mean a partial order :)
22:24:27 <dons> i love watching twitter, and seeing people tweet about RWH arriving.
22:24:29 <Cale> A preorder for operator precedence would be awfully strange :)
22:24:35 <dons> its like watching word-of-mouth live
22:25:17 <mmorrow> dmwit: that sounds just like the situation when i rand State with (#,#) and StateCPS on fib and StateCPS was over twice as fast as the unboxed tuple version
22:25:25 <dmwit> Saizan: I needed an array two-bit saturating counters, so I made a data SatCounter = SatCounter !Bool !Bool and used (#!) to index into a regular STUArray of Bool, then wrap it into a SatCounter.
22:25:52 <dmwit> Saizan: Now I don't have data SatCounter anymore and just do raw indexing, which kind of sucks, but is way, way faster. =)
22:25:53 <mmorrow> because in every (>>=) it has to unpack and repack whereas the cps doesn't (this is my guess at what happened)
22:26:12 <dmwit> right
22:26:15 <Saizan> Cale: yeah, not fully awake yet :)
22:26:39 <Cale> :)
22:26:56 <mmorrow> hmm, how would a partial order behave? i'm not seeing it
22:27:26 <dons> shapr: seen this http://search.twitter.com/search.atom?q=haskell
22:27:32 <Cale> mmorrow: If operators are incomparable, they must be explicitly bracketed.
22:27:35 <mmorrow> like, as in there could be two operators whose precedences are incomparable ==> the parser doesn't know
22:27:38 <mmorrow> ahh
22:27:49 <mmorrow> so an error without explicit brackets then
22:27:57 <pumpkin_> I have a dumb math question
22:28:01 <mmorrow> hmm, i'd never thought about that
22:28:02 <Saizan> just like two operators with the same precedence number now
22:28:13 <mmorrow> ah, true
22:28:49 <Saizan> dmwit: oh, so you're working on a SAT solver? maybe suitable for cabal-install?
22:28:55 <pumpkin_> :o
22:29:14 <dmwit> No, no, Sat stands for saturating here, not satisfiability.
22:29:18 <pumpkin_> dmwit: please do it in polynomial time
22:29:19 <dmwit> Nothing so complicated as that. =)
22:29:20 <pumpkin_> oh
22:30:57 <pumpkin_> what's an algorithm for computing the (hyper)plane of maximum separation between two sets of points?
22:31:52 <cknapp> Is there a built in function to flatten lists?
22:32:04 <dmwit> concat
22:32:17 <dmwit> pumpkin_: SVM?
22:32:18 <cknapp> Thanks
22:32:33 <conal> cknapp: aka join
22:32:38 <pumpkin_> dmwit: oh yeah
22:32:38 <dmwit> cknapp: In the future, you can use hoogle:
22:32:43 <dmwit> ?hoogle [[a]] -> [a]
22:32:43 <lambdabot> Prelude concat :: [[a]] -> [a]
22:32:44 <lambdabot> Data.List concat :: [[a]] -> [a]
22:32:44 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
22:33:07 <conal> hoogle rocks
22:33:19 <pumpkin_> actually my dumb question from earlier was what the algorithm would be for 1d :P
22:33:28 <pumpkin_> is it just the weighted mean?
22:33:40 <dmwit> Do you know they're separable?
22:33:47 <pumpkin_> nope
22:34:12 <dmwit> Then you have to specify a penalty for the misclassified ones.
22:34:20 <cknapp> Thanks, by the way.
22:34:29 <dons> a new modernised HTTP library, courtesy sigbjorn finne, http://www.reddit.com/r/haskell/comments/7gt1m/httpbis_sigbjorn_finnes_quality_modernisation_of/
22:34:32 <lambdabot> Title: HTTPbis : Sigbjorn Finne's quality modernisation of the standard HTTP library :  ..., http://tinyurl.com/6kekbx
22:35:15 <dmwit> pumpkin_: I strongly recommend http://www.seas.upenn.edu/~cis520/burgesSVMs.pdf
22:35:17 <lambdabot> Title: ÌÙØÓÖÐ ÓÒ ËÙÔÔÓÖØ Î ØÓÖ Å Ò× ÓÖ È ØØÖÒ ÊÓÒØÓÒ ...
22:35:28 <pumpkin_> dmwit: if I just take a weighted mean of the two sets of points, what is that telling me? I'm trying to build decision stumps
22:36:01 <dmwit> pumpkin_: It tells the weighted center of the sets, and not much more.
22:36:33 <pumpkin_> it seems like unless the points are uniformly distributed, the weighted mean still tells me that if I pick a point on one side of the break, it's more likely to be of one class than the other?
22:36:34 <dmwit> Anyway, for decision stumps, you don't want maximally separating hyperplanes anyway.
22:36:53 <dmwit> You want the hyperplane with the least misclassification error, which is pretty different.
22:37:06 <pumpkin_> ah, that does make sense
22:37:26 <pumpkin_> hmm
22:37:52 <dmwit> (When I did this, I just took all the possible boundaries and tested them, but there's probably a smarter way to do it.)
22:38:05 <pumpkin_> this is on continuous measurements
22:38:08 <dmwit> With n points, there are at most (n-1) boundaries anyway, so... =)
22:38:12 <dmwit> pumpkin_: Yeah, so?
22:38:17 <pumpkin_> oh I see what you mean
22:38:24 <dmwit> ;-)
22:38:54 <conal> pumpkin_: i'm writing a little blog post about that wrapping/unwrapping pattern.  if you don't mind, I'd like to mention that it came up in talking with you.
22:39:07 <pumpkin_> conal: not at all :) thanks for asking though
22:39:45 <conal> pumpkin_: cool.  i can refer to you as "pumpkin" or your real name.  preference?  /whois tells me that your first name is mark, but not your last.
22:40:04 <conal> (i mean nothing about your last.)
22:40:14 <conal> (i guess it could be mark also)
22:40:19 <pumpkin_> it's actually a lie from back when I was trying to hide from people, my real name's Daniel Peebles :P
22:40:22 <mib_pduyq1rw> 3 + 2
22:40:28 <pumpkin_> ooh a mibbit user
22:40:34 <conal> pumpkin_: oh! funny.  i fell for it.
22:40:57 <hackage> Uploaded to hackage: system-uuid 1.0.2
22:41:01 <conal> pumpkin_: hi daniel. :)  do you prefer name or handle in my post?
22:41:25 <pumpkin_> might as well put my real name, people seem to go by real names in this community anyway
22:41:30 <pumpkin_> but I don't really mind either way
22:41:32 <pumpkin_> both sound stupid :P
22:41:36 <mmorrow> , 3 + 2
22:41:42 <lunabot>  5
22:41:55 <mmorrow> > 3 + 2
22:41:56 <lambdabot>   5
22:42:41 <conal> pumpkin_: will do, thx.  what's your twitter handle?  it's not jumping out at me.
22:42:43 <ski_> names are stupid
22:42:56 <pumpkin_> pumpkingod; pumpkin was already taken
22:43:24 <mib_pduyq1rw> > (\x -> x + 1) 4
22:43:25 <lambdabot>   5
22:43:47 <mmorrow> ski_: should we all have System.Random assign our new identities?
22:43:49 <conal> pumpkin: oh, duh.  now i see. was looking at followees rather than followers
22:44:12 <ski_> mmorrow : that's still names
22:44:13 <mmorrow> we'll be waiting for forever!
22:44:17 * mmorrow ducks
22:45:08 <ski_> > (\m -> m (\x -> x + 1)) (\k -> k 4)
22:45:10 <lambdabot>   5
22:45:17 <mib_pduyq1rw> > fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
22:45:18 <lambdabot>   <no location info>: parse error on input `='
22:45:23 <mmorrow> let
22:45:36 <mib_pduyq1rw> > let fib  = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
22:45:37 <ski_> > fib  where  fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
22:45:37 <lambdabot>   <no location info>: parse error on input `;'
22:45:39 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:45:41 <mmorrow> in
22:45:54 <mmorrow> ooh, lb does where?
22:46:00 <mmorrow> ,  fib  where  fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
22:46:04 <lunabot>  luna: parse error on input `where'
22:46:09 <dmwit> Only accidentally, I think.
22:46:11 <mmorrow> curious
22:46:11 <mib_pduyq1rw> > let fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ] in fib
22:46:11 <quicksilver> > a where a = 1
22:46:14 <lambdabot>   1
22:46:14 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:46:17 <mmorrow> dmwit: ah
22:46:18 <quicksilver> that's a dirty hack.
22:46:21 <ski_> mmorrow : it did initially, i think .. then it was broken .. but works now again :)
22:46:22 <quicksilver> or a nasty accident ;)
22:46:34 <ski_> quicksilver : a *nice* accident ;)
22:46:37 <mmorrow> and exp + where isn't even an expression
22:47:12 <mmorrow> hmm, i wonder what the "accident" is that allows it to work
22:47:13 <conal> posted (http://conal.net/blog/)
22:47:14 <lambdabot> Title: Conal Elliott
22:47:48 <conal> now i can use that trick in the post i'm writing without having to side-track.
22:47:48 <ski_> mmorrow : probably the entered code is spliced as the body of an equation (or `case' branch, i suppose)
22:47:58 <mmorrow> ooh, maybe hint is using runStmt to eval mueval's expressions, in which case maybe that lets wheres in
22:48:22 <mmorrow> ski_: oh? hint is splicing that code into other code?
22:48:29 <ski_> not sure
22:48:34 <mmorrow> hmm. /me needs to looks at the hint code
22:48:37 <ski_> i think that was what was happening initially
22:48:38 <Saizan> not hint
22:48:38 <thoughtpolice> oh mmorrow also yeah lhc's memory management is broken right now
22:48:42 <Saizan> it's the ghc api
22:48:56 <dmwit> :t curry id
22:48:58 <lambdabot> forall a b. a -> b -> (a, b)
22:48:58 <Saizan> that splices the expression in a let
22:49:07 <Saizan> iirc
22:49:09 <dmwit> (,) = curry id
22:49:09 <pumpkin> conal: yay I'm famous
22:49:10 <quicksilver> ski_: well, it undermines LB as a teaching tool.
22:49:14 <mmorrow> thoughtpolice: nowhere to go but up then :)
22:49:24 <quicksilver> ski_: it's hard enough explaining to people that 'where' attaches to definitions, not expressions
22:49:31 <quicksilver> ski_: without LB apparently contradicting that for me :)
22:49:35 <conal> pumpkin: yup!
22:49:36 <thoughtpolice> lemmih said he looked at the talpin paper about regions and said that the programmer in some ways has to adapt his code to not leak
22:49:38 <ski_> quicksilver : .. to some degree yes
22:49:48 <thoughtpolice> however, john apparently has implemented a variant, but in what ways, I do not know
22:49:49 <quicksilver> ski_: yeah. I'm not going to pretend it's very important :)
22:49:54 <thoughtpolice> so i am going to read the papers and see
22:49:56 <ski_> > (a where a = ())
22:49:57 <lambdabot>   <no location info>: parse error on input `where'
22:50:02 <thoughtpolice> there are some papers by fluet that I think are potentially applicable
22:50:05 <mmorrow> Saizan: hmm, i wonder which entry point hint is using to compile expressions
22:50:07 <pumpkin> time to go home, be back soon
22:50:08 <thoughtpolice> about monadic regions and region inference
22:50:55 <mmorrow> thoughtpolice: interesting. what would be a simple example of one way a programmer would adapt code to play nice with region inference?
22:51:09 <thoughtpolice> mmorrow: i'm not sure, I haven't read all the talpin paper
22:51:20 * mmorrow doesn't even know what region inference does yet..
22:51:21 <thoughtpolice> http://lhc.seize.it/Commentary/Region+inference
22:51:23 <lambdabot> Title: Wiki - Commentary/Region inference
22:51:25 <ski_> (quicksilver : i like to think of `run' as taking the missing part in an equation `it = ...' ..)
22:51:26 <mmorrow> heh, nice
22:51:35 <thoughtpolice> that was added by lemmih
22:51:45 <ushdf> will we ever have a kernel that everybody agrees is perfect
22:51:54 <lament> Yes.
22:52:01 <Lemmih> mmorrow: It's basically having the compiler insert malloc's and free's.
22:52:43 <ski_> (Lemmih : though it's usually on a more course-grained level)
22:53:37 <thoughtpolice> mmorrow: you attempt to statically determine memory usage and allocate precisely
22:54:26 <Lemmih> I'd much rather want a conventional GC.
22:55:03 <thoughtpolice> Lemmih: i've been looking at this - http://ttic.uchicago.edu/~fluet/research/thesis/index.html
22:55:06 <lambdabot> Title: Matthew Fluet -- Monadic and Substructural Type Systems for Region-Based Memory  ...
22:55:16 <thoughtpolice> Lemmih: but i haven't read much yet
22:55:40 <thoughtpolice> can we still get cross compilation but retain a conventional GC?
22:55:44 <thoughtpolice> i see ISO C output as a huge win
22:56:33 <mmorrow> Lemmih, thoughtpolice: hmm. from a quick skim of that paper i think i'd rather have a conventional gc as well. i'm gonna read that though, it looks interesting..maybe i'll like it more once i understand it
22:56:45 <mmorrow> thoughtpolice: " you attempt to statically determine memory usage and allocate precisely"
22:57:08 <Saizan> an hybrid?
22:57:13 <mmorrow> so if such a system in functioning correctly, there won't be a space leak with
22:57:22 <mmorrow> putStr =<< getContents
22:57:23 <mmorrow> ?
22:57:43 <Lemmih> thoughtpolice: Hm, probably not. Not without a lot of plain, at least.
22:58:09 <mib_pduyq1rw> :t \x -> x + 1
22:58:09 <mmorrow> i ask not to state the obvious (??), but because my initial skim of that paper seemed to suggest that region inference necessitates a completely difference evaluation model
22:58:10 <lambdabot> forall a. (Num a) => a -> a
22:58:12 <thoughtpolice> Lemmih: yeah, that's the main problem - as john said on the jhc page, GRIN + region inference means you can target a large amount of platforms
22:59:40 <mmorrow> if it's just a simple matter of understanding a system that works nicely once it's used correctly, i wouldn't mind having to learn how to use it
22:59:48 <thoughtpolice> if you look at the LHC RTS, you can see that the memory-related primitives are, well, *really* primitive for the most part. this keeps the memory management side of things way more portable, which is good if you're targeting ISO C for cross-compilation purposes
23:00:04 <mmorrow> it seems like there are definite benefits to it if it could be made to work acceptably
23:00:42 <thoughtpolice> the part of the fluet paper abstract that catches me is this: "However, both the type-and-effect system and the monadic type system require that regions have nested lifetimes, following the lexical scope of the program, restricting when data may be effectively reclaimed. Hence, we introduce a substructural type system that eliminates the nested-lifetimes requirement. The key idea is to introduce first-class capabili
23:01:05 <mib_pduyq1rw> t: \x -> x
23:02:24 <mmorrow> recently i've been trying to understand whether targeting C is inherently limited in what you can do with it, or if all the problems i've had with j/lhc have simply been a result of a gc/whatever that's in need of work
23:02:28 <Saizan> :t \x -> x
23:02:30 <lambdabot> forall t. t -> t
23:03:20 <mmorrow> it seems like on programs j/lhc can handle, it runs them excellently, but if it fails it's always spectacularly (exhausting all memory)
23:03:33 <thoughtpolice> yes, quite hit-or-miss
23:03:49 <ski_> (thoughtpolice : cut off at ".. capabili")
23:04:09 <thoughtpolice> "The key idea is to introduce first-class capabilities that mediate access to a region and to provide separate primitives for creating and destroying regions. The essence of the second encoding is to ``break open'' the monad to reveal its store-passing implementation.""
23:04:11 <mmorrow> thoughtpolice: so you wouldn't say this has anything to do at all with the fact that it's targetting C, would you?
23:04:50 <mmorrow> thoughtpolice: interesting, i've gotta look at that paper
23:05:01 <thoughtpolice> mmorrow: hm, I don't know, but I will say I do think having C as a target is doable. I think cross compilation is also feasible, as well.
23:05:33 <thoughtpolice> with GRIN there is the possibility of targeting many things - LLVM is the first candidate that comes to mind
23:05:52 <mmorrow> cool. i was starting to worry that what could be achieved by targeting C was the limiting factor here
23:06:14 <mmorrow> thoughtpolice: ooh, cool. i have that GRIN paper you linked me too. that's also on my to-read list
23:06:36 <mmorrow> ok, /me to sleep
23:06:38 <mmorrow> night
23:06:40 <thoughtpolice> i think targeting C is quite possible, I mean, look at GHC with -fvia-c -keep-tmp-files :)
23:06:49 <thoughtpolice> j/lhc can produce some really nice C code though
23:07:01 <mmorrow> yeah, but that's with extensive mangling to destroy any remnant of the C stack..
23:07:02 <quicksilver> thoughtpolice: have you looked at the reasons that JaffaCake/SPJ don't like the idea of targetting llvm?
23:07:06 <thoughtpolice> i think that memory management at this point is really the problem, yes
23:07:08 <quicksilver> (from GHC, but still)
23:07:29 <mmorrow> i've heard also (can't remember where) that llvm is a bad target for functional langs
23:07:40 <Lemmih> quicksilver: Link?
23:07:40 <thoughtpolice> quicksilver: no, but i'd be interested in a link. the discussion has popped up here plenty of times before, and I do think due to evaluation semantics, we would someone potentially end up second class citizens
23:07:49 <mib_pduyq1rw> > putStr "Hello"
23:07:51 <lambdabot>   * Exception: "<IO ()>"
23:08:00 <quicksilver> http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011794.html
23:08:02 <lambdabot> Title: LLVM back end, http://tinyurl.com/6z37en
23:08:07 <quicksilver> http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011794.htmlhttp://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011795.html
23:08:09 <lambdabot> http://tinyurl.com/6326g6
23:08:10 <quicksilver> !
23:08:10 <thoughtpolice> but semantically grin is a strict, monadic functional language
23:08:13 <quicksilver> http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011794.htmlhttp://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011795.html
23:08:15 <lambdabot> http://tinyurl.com/6326g6
23:08:17 <quicksilver> grr
23:08:19 <quicksilver> stupid paste!
23:08:24 <quicksilver> http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011795.html
23:08:26 <lambdabot> Title: LLVM back end, http://tinyurl.com/63gpun
23:08:30 <quicksilver> that was two links in total not 4 :P
23:08:54 <pumpkin_> should use is.gd
23:08:58 <pumpkin_> smaller urls!
23:09:26 <pumpkin_> or the more offensive nig.gr :/
23:09:34 <Lemmih> quicksilver: 'a' and 'b' don't apply to lhc. The tail calls would be a problem, though.
23:10:04 <thoughtpolice> http://llvm.org/releases/2.3/docs/CodeGenerator.html#tailcallopt
23:10:05 <lambdabot> Title: The LLVM Target-Independent Code Generator
23:10:55 <mib_pduyq1rw> > fact 5 where fact 0 = 1 fact n = n * fact (n - 1)
23:10:56 <lambdabot>   <no location info>: parse error on input `='
23:11:07 <thoughtpolice> it says for jhc a simple analysis is enough to turn tail calls into loops anyway
23:11:14 <thoughtpolice> not sure if this is implemented?
23:11:54 <ski_> mib_pduyq1rw : again, you need `let ... in ...' (or `... where ...')
23:12:15 <pumpkin_> is it normal for my gf to like drinking pickle brine?
23:12:21 <ski_> mib_pduyq1rw : sorry, misread .. you need a `;' to separate the equations when putting them on the same line
23:12:31 <ski_> > fact 5 where fact 0 = 1; fact n = n * fact (n - 1)
23:12:33 <lambdabot>   120
23:12:48 <thoughtpolice> Lemmih: I do think the main problem is the whole GC/region side of things, because I think in terms of code generation lhc/jhc do pretty damn well
23:12:54 <mmorrow> thoughtpolice: you can do that, but i'm not sure if it can be done in general without a performance hit
23:13:01 <ski_> @brine
23:13:02 <lambdabot> Be quiet Pinky, or I shall have to hurt you.
23:13:04 <thoughtpolice> Lemmih: how much can we decouple the GC from the OS, if at all possible?
23:13:33 <mib_pduyq1rw> Thanks ski_ and mmorrow and Saizan
23:13:40 <thoughtpolice> Lemmih: perhaps have the OS the compiler is being run on the 'implicit' target, and put parts of the RTS together based on that, or if it is over-ridden with a flag? this would allow you to do e.g. 'lhc --target=win32 ...'
23:14:42 <thoughtpolice> (but this does of course require decoupling the GC from the OS as much as possible)
23:15:35 <Lemmih> Well, using a conventional GC while targeting C is out of the question.
23:18:28 <pumpkin_> dmwit: does dmwit stand for something?
23:18:34 <pumpkin_> or did you forget an i? :P
23:18:36 <thoughtpolice> Lemmih: so then native code generation from GRIN with an extra link step?
23:18:38 <dmwit> My initials are DMW.
23:18:51 <pumpkin_> how bout the it?
23:18:55 <Lemmih> thoughtpolice: Say again?
23:19:11 <dmwit> pumpkin_: That part is just clever.  You might say it shows off my... wit?
23:19:32 <thoughtpolice> Lemmih: something like ghc does, we generate an ASM file (.s for gcc,) then we invoke the compiler, including an external piece of code that implements the GC?
23:20:26 <pumpkin_> dmwit: oh ok :)
23:20:28 <dmwit> dmwit has been my universal internet sobriquet for six or seven years now; I never have any trouble with other people having already claimed it as a nick. =)
23:21:29 <Lemmih> thoughtpolice: That wouldn't change anything. GC's and C simply don't mix.
23:23:41 <baaba> Lemmih, why not?
23:24:41 <Lemmih> baaba: It's a pita to incorporate efficiently.
23:24:56 <baaba> oh sure, but it's not impossible by any means
23:25:32 <Lemmih> baaba: Oh, of course not. It's just completely infeasible.
23:26:12 <baaba> http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=7243242B81F87414B967FF4DC72E75AB?doi=10.1.1.19.5570&rep=rep1&type=pdf
23:26:15 <lambdabot> Title: cache:http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=7243242B81F87414B ..., http://tinyurl.com/5a2qgc
23:26:35 <mib_pduyq1rw> > sss 27 [] [10,5,2,1] where sss 0 r _ = r; sss _ r [] = []; sss v r (c : cs) = if c <= v then sss (v - c) (c : r) (c : cs) else sss v r cs
23:26:37 <lambdabot>   [2,5,10,10]
23:27:33 <Lemmih> I'd rather include an email client and hire a bunch of low-wage workers to sort the garbage.
23:28:06 <baaba> that paper seems to conclude that it is in fact feasible
23:28:50 <Saizan> you should have linked the page, rather than the download, se we could easily read the abstract
23:29:02 <baaba> sorry, here: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.5570
23:29:03 <lambdabot> Title: Accurate garbage collection in an uncooperative environment - CiteSeerX
23:31:17 <Lemmih> baaba: For some value of feasible, sure. GHC can still do it. However, it is still more painful than pre-anesthisia surgery.
23:32:53 <erikc> what about the chicken scheme stack-is-nursery approach
23:33:35 <mmorrow> from what i understand it's still a trampoline, you just get to jump /really/ high
23:33:56 <mmorrow> but that may be a different scheme implem altogether and i'm way off mark ;)
23:34:08 <mmorrow> ) 42
23:34:08 <lunabotjs>  42
23:35:38 * pumpkin_ just watched the wrongest (is that even a word? well now it is) music video/song ever
23:36:20 <mib_pduyq1rw> > sss 27 where sss 0 s r _ = r : s; sss _ s r [] = s; sss v s r (c : cs) = if c <= v then sss (v - c) (sss v s r cs) (c : r) (c : cs) else sss v s r cs
23:36:21 <lambdabot>       Overlapping instances for Show ([[t]] -> [t] -> [t] -> [[t]])
23:36:21 <lambdabot>        ar...
23:36:47 <mib_pduyq1rw> > sss 27 [] [] [10,5,2] where sss 0 s r _ = r : s; sss _ s r [] = s; sss v s r (c : cs) = if c <= v then sss (v - c) (sss v s r cs) (c : r) (c : cs) else sss v s r cs
23:36:49 <lambdabot>   [[2,5,10,10],[2,5,5,5,10],[2,2,2,2,2,2,5,10],[2,5,5,5,5,5],[2,2,2,2,2,2,5,5...
23:37:23 <mmorrow> ) go = function(cont){while(cont=cont()){}}; f = function(x,y,z){var k=function(){if(x>z)return(undefined);x+=y;return(k)};go(k);return(x)}; f(0,7,1000000)
23:37:24 <lunabotjs>  1000006
23:37:28 <mmorrow> ) go = function(cont){while(cont=cont()){}}; f = function(x,y,z){var k=function(){if(x>z)return(undefined);x+=y;return(k)};go(k);return(x)}; f(0,7,10000000)
23:37:30 <erikc> mmorrow: its a long jump that promotes stuff out of the nursery
23:37:30 <lunabotjs>  Killed.
23:38:19 <mmorrow> erik: is chicken scheme implem in C and uses setjmp.h?
23:38:24 <mmorrow> (out of curiosity)
23:38:29 <Lemmih> thoughtpolice: I think llvm is our best bet if region-based management doesn't cut it.
23:38:40 <pumpkin_> mmorrow: I don't think so
23:38:41 <thoughtpolice> Lemmih: then what other options do we have? i still think getting region inference working is possible, but it just might be a bitch and require some research.
23:39:02 <mmorrow> pumpkin_, erikc: phew :)
23:39:06 <erikc> mmorrow: yup
23:39:20 <mmorrow> yup phew, or yup setjmp.h?
23:39:20 <pumpkin_> mmorrow: I was reading an article on reverse engineering and this dude was totally freaked out at how different chicken scheme code looked from regular code
23:39:21 <erikc> it compiles to ansi c
23:39:30 <pumpkin_> hmm
23:39:32 <thoughtpolice> Lemmih: grepping through the source, the primitives in the GRIN datatype don't seem to touch much outside of src/Grin
23:39:37 <mmorrow> erikc: ugh :)
23:39:53 <mib_pduyq1rw> How do I implement my subset sum as a set comprehension (like fib) instead of a function ? I am kind of lost with the way the 'fib' example works
23:39:58 <thoughtpolice> Lemmih: this is a big thing but we still need to speed up the compilation pipeline, but I think it would be good to look into our options more
23:40:10 <pumpkin_> mib_pduyq1rw: subset sum as in the exponential problem?
23:40:12 <thoughtpolice> (along with many other things that need to be fixed; quasi-quoting that stuff would be particularly nice)
23:40:46 <mib_pduyq1rw> What is the exponential problem ? subset sum like the sss function(s) I wrote. Compare with fib
23:40:58 <erikc> region-based memory would be really attractive for soft real time apps
23:41:43 <mmorrow> erikc: that would be awesome if there was a more realtime haskell rts
23:41:50 <pumpkin_> > filter (\x -> fst x == 0) [(sum xs, xs) | xs <- subsequences [-2,-1..3]]
23:41:52 <lambdabot>   Not in scope: `subsequences'
23:42:08 <pumpkin_> , filter (\x -> fst x == 0) [(sum xs, xs) | xs <- subsequences [-2,-1..3]]
23:42:12 <lunabot>  [(0,[]),(0,[0]),(0,[-1,1]),(0,[-1,0,1]),(0,[-2,2]),(0,[-2,0,2]),(0,[-2,-1...
23:42:55 <thoughtpolice> Lemmih: I will see if perhaps we can utilize what we already have with region inference in the code base, but if it turns out to be infeasible then we will have to take another route
23:43:26 <pumpkin_> , filter (\xs -> sum xs == 0) (subsequences [-2,-1..3])
23:43:28 <lunabot>  [[],[0],[-1,1],[-1,0,1],[-2,2],[-2,0,2],[-2,-1,1,2],[-2,-1,0,1,2],[-2,-1,...
23:43:46 <mmorrow> just free the codez and compile the whole prog into a single function and use goto like it's jmp :)
23:44:01 <centrinia> > [xs | xs <- [5,11,17,23], sum xs == 31]
23:44:02 <lambdabot>       No instance for (Num [a])
23:44:02 <lambdabot>        arising from the literal `5' at <inter...
23:44:30 <centrinia> > [xs | xs <- subsequences [5,11,17,23], sum xs == 31]
23:44:31 <lambdabot>   Not in scope: `subsequences'
23:44:38 <mmorrow> http://darcs.haskell.org/ghc/rts/Interpreter.c
23:44:45 <pumpkin_> centrinia: oh, smart, hadn't thought of that
23:45:15 <mib_pduyq1rw> subsequences is building the cartesian product and you are filtering the sums that are equal to zero. You are potentially in N^n while the algorithm I wrote filters at the same time it builds
23:45:51 <pumpkin_> mib_pduyq1rw: it's building the powerset (if the input is finite)
23:46:08 <mmorrow> from what i've gleaned from Interpreter.c (the bytecode interpreter), what it's doing in that 1000 lines function with gotos is very analogous to what ghc's rts is doing with cmm and free reign
23:46:16 <mib_pduyq1rw> Right. My point was that I am filtering at the same time I build, not at the end
23:46:16 <pumpkin_> but subset sum is NP-complete, if that's what you're working on
23:46:50 <mib_pduyq1rw> Yes, my work is to solve NP-hard problems if that is the question
23:47:00 <centrinia> mib_pduyq1rw: That is still going to take 2^n operations.
23:47:11 <pumpkin_> oh okay, mib_pduyq1rw
23:47:32 <mib_pduyq1rw> True but you decrease the complexity step by step
23:47:46 <centrinia> Uh, no.
23:48:35 <pumpkin_> there's an approximate polynomial time algo
23:50:08 <mib_pduyq1rw> There is an exact pseudo-polynomial algorithm for subset sum, but I used it only as an example. You can solve truly NP-hard problems with the same approach than my sss function (aka branch and bound).
23:50:31 <pumpkin_> where did conal go :o
23:50:33 <pumpkin_> @seen conal
23:50:33 <lambdabot> I saw conal leaving #haskell and #ghc 10m 24s ago, and .
23:51:08 <centrinia> The Branch and Bound method still requires exponential time.
23:51:13 <pumpkin_> mib_pduyq1rw: it'd be easier to talk to you if you had a real nick btw :P
23:53:42 <mib_pduyq1rw> Variant of the problem: subsetsum with fixed cardinality. Here is how I modify my sss function
23:54:15 <extasic> hi
23:55:04 <extasic> I do have a problem solving a Haskell excercise and hope you can help me a bit:
23:55:16 <extasic> I've been given the structure
23:55:16 <extasic> data Nat = Zero | Succ Nat deriving Show
23:55:16 <extasic> together with a fold functure
23:55:16 <extasic> foldN :: a -> (a->a) -> Nat -> a
23:55:16 <extasic> foldN z s Zero = z
23:55:17 <extasic> foldN z s (Succ n) = s (foldN z s n)
23:55:19 <extasic> and
23:55:21 <extasic> subN :: Nat -> Maybe Nat
23:55:23 <extasic> subN Zero = Nothing
23:55:25 <extasic> subN (Succ n) = Just n
23:55:27 <extasic> Now I have to recreate subN as an instance of foldN.
23:55:28 <centrinia> What does "fixed cardinality" mean?
23:55:29 <extasic> But I don't come along with the MayBe type..
23:56:01 <mib_pduyq1rw> sss 27 5 [] [] [10,5,2,1] where sss 0 0 s r _ = r : s; sss _ _ s _ [] = []; sss v c s r (x : xs) = if (x <= v) then sss (v - x) (c - 1) sss (v s c r xs) (x :  r) (x : xs) else sss v s c r xs
23:56:14 <mib_pduyq1rw> > sss 27 5 [] [] [10,5,2,1] where sss 0 0 s r _ = r : s; sss _ _ s _ [] = []; sss v c s r (x : xs) = if (x <= v) then sss (v - x) (c - 1) sss (v s c r xs) (x :  r) (x : xs) else sss v s c r xs
23:56:16 <lambdabot>       Occurs check: cannot construct the infinite type:
23:56:16 <lambdabot>        t = [a] -> t1 ...
23:57:54 <mib_pduyq1rw> > sss 27 5 [] [] [10,5,2,1] where sss 0 0 s r _ = r : s; sss _ _ _ _ [] = []; sss v c s r (x : xs) = if (x <= v) then sss (v - x) (c - 1) (sss v s c r xs) (x :  r) (x : xs) else sss v s c r xs
23:57:56 <lambdabot>       No instance for (Num [[t]])
23:57:56 <lambdabot>        arising from a use of `sss' at <inte...
23:58:55 <Saizan> extasic: what's your problem with it?
23:58:56 <mgdtgd> hello
23:59:14 <Saizan> extasic: have you tried writing something and got stuck?
23:59:19 <mgdtgd> I have a question about laziness
23:59:37 <mgdtgd> say I have a list to memoize some complex calculation
23:59:50 <extasic> Saizan: I don't know how to start.. I tried something like subN x = foldN Nothing (Just helper) x
23:59:54 <mgdtgd> for example list = map factors [1..]
