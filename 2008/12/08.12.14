00:00:21 <intrados> well, the packages I picked out for audio generation are hccsound, haskore, jack, hamusic, hosc, portaudio, hsc3 and synthesizer. at this point I'm just trying to figure out which is most appropriate for my needs and which I could actually use given the relative scarcity of documentation
00:01:05 <erikc> ah...outside my sphere of knowledge, sorry
00:01:48 <intrados> no problem. thanks for trying
00:01:59 <mgdtgd> hi, I have trouble installing yi
00:02:06 <mgdtgd> I tried cabal install
00:02:10 <mgdtgd> but it failed
00:02:24 <mgdtgd> cabal: alex version >=2.0.1 && <3 is required but it could not be found.
00:02:25 <mgdtgd> cabal: Error: some packages failed to install:
00:02:25 <mgdtgd> yi-0.5.2 failed during the configure step. The exception was:
00:02:25 <mgdtgd> exit: ExitFailure 1
00:03:08 <mgdtgd> I did a cabal install alex, which succeded, but that didn't alleviate the problem with yi
00:04:09 <mgdtgd> what shall I do?
00:05:07 <intrados> do you know what version of alex you have installed?
00:06:30 <mgdtgd> the latest
00:06:38 <mgdtgd> 2.3.^
00:06:40 <mgdtgd> 1
00:10:03 <intrados> uh.. you can try editing the .cabal to remove that dependency and then install with runghc Setup etc
00:10:11 <mgdtgd> hm
00:10:13 <mgdtgd> let's try that
00:16:13 <mgdtgd> aha! it put the alex executable in ~/.cabal/bin
00:16:19 <mgdtgd> which wasn't in my path
00:17:11 <intrados> ah. yeah, I had to add that to my path as well
00:18:24 <mgdtgd> that should be done automatically while installing cabal-install, imho
00:28:30 <ozy`> mgdtgd: the problem with that being, it can mess up your .whatevershrc too easily
00:29:24 <mgdtgd> it could ask me first
00:31:48 <Axman6> mgdtgd: that's easier said than done
00:37:52 <dons> amusing. http://letmegooglethatforyou.com/?q=monads
00:38:22 <dons> oh, 'the monads' are a punk band in st louis?
00:38:41 <dons> http://cdbaby.name/m/o/monads.jpg
00:42:32 <dibblego> > 1
00:44:43 --- mode: irc.freenode.net set +o ChanServ
00:53:02 <mpeter> so let's see
00:53:12 <mpeter> the maybe exists only in functions
00:53:19 <mpeter> where an 'else' isn't an option?
00:53:32 <mpeter> or am i not paying enough attention
00:53:56 <ozy`> mpeter: you mean the Maybe type?
00:54:12 <ozy`> or the maybe function?
00:54:33 <mpeter> type
00:54:39 <mpeter> what on earth does the maybe function do?
00:55:05 <dons> its the elimination form for Maybe values
00:55:08 <dons> ?src maybe
00:55:08 <lambdabot> maybe n _ Nothing  = n
00:55:08 <lambdabot> maybe _ f (Just x) = f x
00:55:33 <dons> apply f, fmap style. or return a default
00:56:00 <mpeter> can i see an example
00:56:27 <ozy`> > maybe "pizza" length Nothing
00:56:29 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Int'
00:56:35 <ozy`> errr
00:56:40 <ozy`> > maybe "pizza" unwords Nothing
00:56:41 <lambdabot>   "pizza"
00:57:05 <ozy`> > maybe "pizza" unwords (Just ["two", "words"])
00:57:06 <lambdabot>   "two words"
00:57:53 <ozy`> mpeter: it's just a slightly terser version of a pattern match on Maybe values
00:58:04 <mpeter> > words "baby i want to get to know you"
00:58:05 <lambdabot>   ["baby","i","want","to","get","to","know","you"]
00:58:24 <mpeter> @src unwords
00:58:25 <lambdabot> unwords [] = ""
00:58:25 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
00:58:27 <ozy`> as for the Maybe type, that's haskell's version of variables that are allowed to be "null"
00:59:12 <ozy`> you can use do-notation to chain together several functions that return Maybe types
00:59:12 <mpeter> i see
00:59:40 <ozy`> so that you don't have to explicitly check every value for success
00:59:54 <mpeter> but implicitly?
00:59:57 <ozy`> yeah
01:00:23 <ozy`> implicit computation is the whole point of do-notation (and monads in general)
01:00:43 <mpeter> lovely
01:01:01 <ozy`> it's all type-dependent, mind you
01:01:15 <mpeter> of course
01:01:31 <mpeter> why did they bother to define notElem instead of just
01:01:37 <mpeter> composing a negation of Elem
01:04:10 <ozy`> saves you half a keystroke
01:05:51 <mpeter> http://learnyouahaskell.com/list.png
01:08:15 <dolio> Why did they bother to define mapAndUnzipM?
01:09:21 <lucca> ozy`: not really; there's a shift involved
01:10:42 <dolio> I think he's counting shift as a half.
01:10:57 <ozy`> that is exactly what I was doing
01:11:33 <ozy`> mpeter: yes, LYAH is basically "why's poignant guide" but with type inference instead of chunky bacon
01:11:50 <dolio> Although it probably saves you more, because sticking a not on an elem likely takes either a (.) or a ($) or parentheses.
01:12:06 <mpeter> hehe
01:13:01 <dolio> I suppose (.) and ($) could theoretically take only one character, but then your code would look bad.
01:16:31 <dons> dolio: i think mapAndUnzipM is weird. usually such things appear in the early papers as useful
01:16:43 <dons> in this case, monads were around forever, so i guess someone asked for it early on.
01:17:03 <dons> want to ask for it to be removed? :)
01:17:18 <dolio> Well, it doesn't bother me any. But I've never seen it used.
01:18:03 <Saizan> ?hoogle mapAndUnzipM
01:18:04 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
01:18:05 <dons> its in H98, http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg03408.html
01:18:22 <dons> but that's the only reference in the entire mailing list history.
01:18:22 <dolio> Yeah. I know it's not new.
01:18:32 <sjanssen> @src mapAndUnzipM
01:18:32 <lambdabot> mapAndUnzipM f xs = sequence (map f xs) >>= return . unzip
01:18:44 <sjanssen> yeah, not worth of a name
01:18:49 <dons> bizarre.
01:18:55 <dolio> That's really the definition? It's not even particularly clever.
01:18:55 <dons> my guess: ghc used it.
01:19:02 <sjanssen> fmap unzip . mapM f -- even looks better
01:19:07 <dons> hey kids, want to get it removed? :)
01:19:14 <dons> i think this would be a good test of the libraries removal process.
01:19:23 <sjanssen> yes
01:19:25 <dons> and would make people feel happy too.
01:19:41 <dons> ok. let's not forget. dolio, we can propose its removal tomorrow.
01:19:49 <dolio> Heh.
01:19:55 <dons> its good to keep the house tidy
01:20:07 <dons> worst case: we find out who wanted it in.
01:20:34 <sjanssen> assuming they're still around :)
01:20:42 <dons> btw, foldl' is badly defined too.
01:20:44 <dons> it should be stricter.
01:20:47 <dons> ?src foldl'
01:20:47 <lambdabot> foldl' f a []     = a
01:20:47 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:20:53 <dons> the first case
01:21:11 <dons> it should be: foldl' f !a [] = a ; foldl' f !a (x:xs) = ...
01:21:17 <dons> not the result after accumulating.
01:21:43 <dons> bug in the h98 spec, due to not having stated strictness properties.
01:21:53 <dons> well, not h98. post-h98
01:22:16 <sjanssen> well, it makes a certain sense to not demand the accumulator, since the user can make sure it is seqed before calling foldl
01:22:27 <dons> yields worse code too.
01:22:32 <sjanssen> but I can't imagine a case where it would be useful
01:23:54 <sjanssen> last = foldl' (flip const) (error "last: empty list") -- one perverted use of the laziness :)
01:24:18 <sjanssen> > foldl' (flip const) (error "last: empty list") [1 .. 10]
01:24:19 <lambdabot>   10
01:24:30 <sjanssen> would work if the accumulator was strict
01:24:36 <sjanssen> erm, I mean would not work
01:25:25 <dolio> > foldl (flip const) (error "last: empty list") [1..1000000]
01:25:27 <lambdabot>   1000000
01:25:32 <dolio> > foldl (flip const) (error "last: empty list") [1..10000000]
01:25:51 <sjanssen> dolio: you'll get a stack overflow eventually
01:25:56 <lambdabot>   thread killed
01:26:41 <dolio> I'm skeptical.
01:26:43 <sjanssen> > foldl' (flip const) (error "last: empty list") [1..10000000]
01:26:47 <lambdabot>   10000000
01:27:09 <dolio> It just worked for 10000000 in ghci.
01:27:13 <sjanssen> dolio: why?  foldl will create a chain of (flip const (flip const (flip const ...)))
01:27:45 <sjanssen> unless "flip const" is one of those functions that doesn't make a thunk
01:27:56 <pumpkin> :T mapAndUnzipM
01:28:00 <pumpkin> :t mapAndUnzipM
01:28:02 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
01:28:05 <pumpkin> (mmm twitter)
01:28:13 <pumpkin> that does seem odd
01:28:32 <Saizan> sjanssen: yeah, but the outer flip const won't force the others
01:28:53 <Saizan> the problem is that the thunk might overflow the heap
01:28:53 <sjanssen> dolio: try (repeat ()) and watch ghci's memory climb
01:29:30 <sjanssen> so we won't get a stack overflow, but we will get a heap overflow
01:29:34 <sjanssen> makes sense
01:29:41 <dolio> Yeah.
01:29:54 <dolio> Since the nested thunks are never used.
01:30:27 <lucca> twitter?
01:31:12 <sjanssen> mapAndUnzipM is my new favorite function!
01:31:39 <sjanssen> why don't we have mapAndSumM?
01:32:29 <Saizan> so, we've kept mapAndUnzipM and discarded takeUntilM ?
01:32:47 <sjanssen> when was takeUntilM around?
01:33:11 * pumpkin tries to think of how to use mapAndUnzipM
01:33:46 <pumpkin> > mapAndUnzipM (return ((+1) &&& (+2))) [1,2,3]
01:33:47 <lambdabot>       Overlapping instances for Show (b -> ([b], [b]))
01:33:47 <lambdabot>        arising from a ...
01:33:55 <Saizan> maybe i'm confusing it with plain takeUntil
01:34:06 <pumpkin> > mapAndUnzipM (return . ((+1) &&& (+2))) [1,2,3]
01:34:07 <lambdabot>       No instance for (Show (m ([a], [a])))
01:34:07 <lambdabot>        arising from a use of `sho...
01:34:31 <cygnus_> > mapAndUnzipM
01:34:32 <sjanssen> Saizan: takeUntil p = takeWhile (not . p)?
01:34:32 <lambdabot>       Overlapping instances for Show
01:34:32 <lambdabot>                                  ((a -> ...
01:34:37 <pumpkin> > mapAndUnzipM (return . ((+1) &&& (+2))) [1,2,3] :: Just ([Int], [Int])
01:34:38 <lambdabot>   Not in scope: type constructor or class `Just'
01:34:38 <cygnus_> > :t mapAndUnzipM
01:34:39 <lambdabot>   <no location info>: parse error on input `:'
01:34:42 <pumpkin> > mapAndUnzipM (return . ((+1) &&& (+2))) [1,2,3] :: Maybe ([Int], [Int])
01:34:44 <lambdabot>   Just ([2,3,4],[3,4,5])
01:34:45 <cygnus_> :t mapAndUnzipM
01:34:46 <pumpkin> whee
01:34:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
01:34:57 <pumpkin> my type skillz are aussom
01:35:08 <Saizan> sjanssen: no, it keeps the last checked element
01:35:24 <pumpkin> now why the hell does that exist?
01:35:43 <sjanssen> Saizan: I don't remember that, where does it come from?
01:36:00 <pumpkin> > mapAndUnzipM ((:[]) &&& (:[])) [1,2,3]
01:36:00 <Saizan> sjanssen: haskell 1.4, iirc
01:36:01 <lambdabot>   Couldn't match expected type `(b, c)' against inferred type `[a]'
01:37:10 <sjanssen> pumpkin: it is weird, especially since normal unzip is such a rarely used function
01:37:37 <cygnus_> what is &&&
01:37:56 <pumpkin> "The mapAndUnzipM function maps its first argument over a list, returning the result as a pair of lists. This function is mainly used with complicated data structures or a state-transforming monad."
01:37:57 <sjanssen> @type (&&&)
01:37:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:38:08 * sjanssen waits for cygnus_'s head to explode
01:38:18 <cygnus_> fizz
01:38:24 <pumpkin> > (+1) &&& (+5) 4
01:38:25 <lambdabot>       Overlapping instances for Show (b -> (b, c'))
01:38:25 <lambdabot>        arising from a use...
01:38:25 <sbahra> @seen wahjava
01:38:26 <lambdabot> I saw wahjava leaving ##freebsd 14h 47m 15s ago, and .
01:38:30 <pumpkin> > ((+1) &&& (+5)) 4
01:38:31 <lambdabot>   (5,9)
01:38:40 <pumpkin> cygnus_: that might be clearer than the nasty arrow stuff :P
01:38:53 <cygnus_> > ((-1) &&& (-5)) 4
01:38:54 <lambdabot>       No instance for (Num (b -> c))
01:38:54 <lambdabot>        arising from a use of `negate' at...
01:39:07 <pumpkin> :t subtract
01:39:09 <lambdabot> forall a. (Num a) => a -> a -> a
01:39:15 <sjanssen> cygnus_: applies two functions to a value, return the tuple of their results
01:39:29 <pumpkin> > ((`subtract` 1) &&& (`subtract` 5)) 4
01:39:30 <lambdabot>   (-3,1)
01:39:43 <pumpkin> > 5 subtract 4
01:39:44 <lambdabot>       No instance for (Num ((a -> a -> a) -> t -> a1))
01:39:44 <lambdabot>        arising from th...
01:39:51 <pumpkin> > 5 `subtract` 4
01:39:52 <lambdabot>   -1
01:39:56 <pumpkin> weird
01:40:22 <cygnus_> ehe
01:40:38 <cygnus_> > `subtract` 5 4
01:40:39 <lambdabot>   <no location info>: parse error on input ``'
01:40:50 <pumpkin> > subtract 5 4
01:40:50 <cygnus_> > 4 `subtract` 5
01:40:52 <lambdabot>   -1
01:40:52 <lambdabot>   1
01:41:04 <pumpkin> it's just flip of (-) it seems
01:41:17 <pumpkin> @src subtract
01:41:17 <lambdabot> subtract x y = y - x
01:41:26 <sbahra> Why?
01:41:31 <pumpkin> @pl subtract x y = y - x
01:41:31 <lambdabot> subtract = subtract
01:41:35 <pumpkin> lol
01:41:42 <cygnus_> what is @pl
01:42:01 <pumpkin> cygnus_: it likes to state the obvious
01:42:06 <Beelsebob> cygnus_: pointless
01:42:14 <Beelsebob> i.e. it makes things pointless
01:42:16 <cygnus_> @pl map
01:42:16 <lambdabot> map
01:42:23 <pumpkin> @pl \x y z = z y
01:42:24 <lambdabot> (line 1, column 8):
01:42:24 <lambdabot> unexpected "="
01:42:24 <lambdabot> expecting pattern or "->"
01:42:32 <Beelsebob> @pl \f x y -> f (x + y)
01:42:46 <pumpkin> @pl \x y z -> z y
01:42:49 <lambdabot> const (flip id)
01:42:49 <lambdabot> (. (+)) . (.)
01:43:08 <athos> :t oneChar
01:43:09 <lambdabot> Not in scope: `oneChar'
01:43:14 <pumpkin> cygnus_: it basically removes explicit arguments to functions
01:43:25 <pumpkin> cygnus_: sometimes it makes them more "elegant", others it makes the obscenely complex
01:43:43 <Beelsebob> and sometimes it misse the obvious
01:43:54 <Beelsebob> @pl \f (x,y) -> f x y
01:43:54 <lambdabot> (`ap` snd) . (. fst)
01:43:56 <pumpkin> @pl \f a b c d e f g h i j -> j i h g f e d c b a
01:44:00 <lambdabot> const (((((const .) .) .) .) . flip (flip . ((flip . ((flip . (flip .)) .) . (((flip .) .) .)) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . ((
01:44:00 <lambdabot> (flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .
01:44:02 <lambdabot> ) .) . flip (flip . (flip .) . ((flip .) .) . join (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id)))))))))
01:44:05 <lambdabot> optimization suspended, use @pl-resume to continue.
01:44:15 <pumpkin> as you can see :)
01:44:20 <Beelsebob> @pl \a e h k l s -> h a s k e l l
01:44:21 <lambdabot> flip flip id . ((flip . ((flip . ((ap . (flip .) . flip) .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip id
01:44:49 <pumpkin> :t ap
01:44:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:11:50 <pumpkin> that non-stop haskell proposal looks neat
02:13:10 <sbahra> pumpkin, ?
02:13:43 <pumpkin> http://research.microsoft.com/en-us/um/people/simonpj/Papers/inc-gc.htm
02:16:32 <solrize_> from 2000?
02:17:00 <solrize_> ghc uses tag bits now, right?
02:21:35 <thoughtpolice> the GC is still stop the world, but does collections in parallel
02:21:39 <thoughtpolice> a concurrent GC would be nice
02:36:47 <intrados> what does >> signify?
02:37:31 <vegai> same as >>= but without keeping the result
02:38:10 <intrados> somehow I missed what >>= does as well
02:39:29 <vegai> well, in the IO monad it means "do this thing and pass the result to this other thing"
02:39:35 <solrize_> how does erlang manage gc when you pass a complicated object between processes?
02:39:48 <vegai> solrize_: #haskell ;)
02:40:32 <intrados> how is it related to <- then?
02:40:49 <vegai> intrados: you can try for instance "getLine >>= putStrLn"
02:41:06 <vegai> <- is used inside a do block as a syntactic sugar
02:41:20 <vegai> "getLine >>= putStrLn" would be
02:41:24 <vegai> do a <- getLine
02:41:24 <solrize_> vegai, question relates to concurrent gc and whether haskell could do it the same way
02:41:28 <vegai>     putStrLn a
02:41:37 <vegai> (without the indentation error :)
02:41:48 <vegai> solrize_: ah, ok.
02:43:11 <intrados> vegai: thanks
02:46:34 <solrize_> maybe there could be a separate ephemeral heap in every thread, with some hair to promote any value to a shared heap if you put in an mvar
02:46:47 <solrize_> then the ephemeral heaps could gc independently
02:47:48 <vegai> my uneducated guess is that Erlang just copies the complicated object
02:48:07 <Saizan> values can be referenced by multiple threads without being in an MVar
02:49:55 <solrize_> saizan, other than being in the closure active at the time the forkIO happened?
02:53:01 <Saizan> solrize_: that's what i was referring to
02:53:23 <solrize_> ok, so those would also be in the shared heap
02:56:28 <solrize_> actually do microthreads ever migrate from one hardware thread to another?
02:57:04 <evident> hello everybode
02:57:06 <evident> y
02:57:30 <solrize_> h'lo evident
02:59:22 <Peaker> solrize_: s/hardware/kernel ?
02:59:47 <Lemmih> solrize_: It can happen.
02:59:47 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:00:29 <solrize_> peaker, yeah, OS thread
03:00:32 <evident> hey guys i have a little question: what is the easiest way to check whether all elements of one list are elements of another one?
03:01:16 <solrize_> all [x `elem` ys | x <- xs]
03:01:28 <Peaker> evident: all (`elem` someList) (nub yourList)  (or without nub, if the list is bigger than the other list).  For large lists, you might want to convert to a set first
03:01:36 <Lemmih> evident: all (`elem` otherList) ?
03:02:09 <solrize_> s/all/and in my example
03:02:37 <Badger> y'what
03:02:38 <Badger> :t nub
03:02:40 <lambdabot> forall a. (Eq a) => [a] -> [a]
03:03:23 <Peaker> > nub (replicate 3 [1,2,3])
03:03:25 <lambdabot>   [[1,2,3]]
03:03:25 <evident> ahh ok
03:03:35 <Peaker> > nub (take 9 $ cycle [1,2,3])
03:03:37 <lambdabot>   [1,2,3]
03:03:46 <Peaker> > repeat [1,2,3]
03:03:47 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
03:04:04 <solrize_> > nub [1,2,6,5,6,2,3,1,9]
03:04:05 <lambdabot>   [1,2,6,5,3,9]
03:04:34 <evident> Peaker: well actually my task is to compare two sets... and now I thought about doing it by converting them into lists with a@(x:xs) and b@(y:ys)
03:04:46 <Peaker> evident: if you want performance, you should probably use Data.Set
03:04:54 <evident> is there an easier way by leaving them as Sets?
03:05:09 <Badger> solrize_: how does that make sense :P
03:05:09 <Peaker> evident: Surely Data.Set has the operations you're looking for
03:05:21 <Peaker> Badger: it removes latter duplicates
03:05:24 <solrize_> badget ?
03:05:27 <Badger> oh, right
03:05:27 <solrize_> badger
03:05:37 <Badger> handy
03:05:47 <solrize_> oh
03:05:50 <Peaker> @hoogle subset
03:05:50 <lambdabot> Data.IntSet isProperSubsetOf :: IntSet -> IntSet -> Bool
03:05:50 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
03:05:50 <lambdabot> Data.IntSet isSubsetOf :: IntSet -> IntSet -> Bool
03:05:56 <Peaker> evident: these?
03:06:06 <evident> ahhh ok
03:06:07 <evident> :)
03:06:09 <Peaker> @hoogle Set a -> Set a -> Bool
03:06:10 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
03:06:10 <lambdabot> Data.Set isSubsetOf :: Ord a => Set a -> Set a -> Bool
03:06:10 <lambdabot> Data.Set member :: Ord a => a -> Set a -> Bool
03:06:14 <evident> sweet thx
03:07:28 <xenoblitz> guys ... was the function "on" added in ghc 6.10.1 or I am missing something?
03:07:43 <solrize_> it's in data.function
03:07:49 <solrize_> and has been there for a while
03:08:06 <solrize_> did 6.10 put it in the prelude?
03:08:06 <sjanssen> added in 6.8, I think
03:08:07 <xenoblitz> solrize: I'm trying to use eclipse and somehow its not finding it
03:08:26 <solrize_> :t on
03:08:27 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:10:10 <xenoblitz> am getting the error could not find Data.Function
03:10:36 <xenoblitz> and Data.List can be found
03:10:38 <xenoblitz> very strange
03:12:14 <Badger> can anyone tell me a bit about xmonad.
03:12:30 <Badger> just if anyone happens to know much.
03:12:36 <Badger> (it's haskell-related, honest.)
03:13:30 <Saizan> "a bit"?
03:13:42 <Badger> well, speicifically:
03:13:47 <Lemmih> Badger: You're more likely to get an answer if you ask a concrete question.
03:13:57 <Badger> is it haskell-related that one cannot pipe commands to it
03:14:04 <solrize_> badger, http://xmonad.org
03:16:19 <evident> would that work? how can i test it? http://hpaste.org/13060
03:17:04 <evident> (i know it's not the smartest way to solve it)
03:18:03 <Saizan> you want to check if any of the two is a subset of the other?
03:19:15 <evident> yees
03:19:21 <evident> but without using Data.Set
03:19:34 <evident> how can i check it?
03:19:51 <evident> i tried: subSet {5,2} {5,3,2}
03:20:00 <evident> but that doesnt work
03:20:10 <evident> (unexpected numeric literal)
03:20:13 <Saizan> there's no special syntax for sets
03:20:31 <Saizan> also, is Set your own defined type or the one from Data.Set?
03:20:44 <evident> hold on
03:21:16 <evident> http://hpaste.org/13060#a1
03:21:23 <evident> this is my Set definition
03:22:07 <Saizan> ok, so you can test is with subSet (St [5,2]) (St [5,3,2])
03:22:41 <evident> ahhh
03:22:42 <evident> ok
03:23:09 <Saizan> defining a Show instance affects only how the value is converted to a string with show, which is what ghci uses to display it
03:23:22 <solrize_> :t showString
03:23:23 <lambdabot> String -> String -> String
03:24:07 <Saizan> > showString "foo" ""
03:24:08 <lambdabot>   "foo"
03:24:34 <solrize_> > showString "foo" "bar"
03:24:35 <lambdabot>   "foobar"
03:25:09 <evident> ahh ok
03:28:42 <evident> can i use "length" on a set?
03:28:48 <evident> to find out how many elements are in it?
03:29:45 <dolio> @type S.size
03:29:46 <lambdabot> forall a. S.Set a -> Int
03:30:08 <evident> hmm ok
03:33:23 <Saizan> evident: in your case you've to define setLength (St xs) = length xs
03:40:59 <xenoblitz> guys is there a channel where I can ask anyone about using eclipse with haskell, or is there anyone here who uses such a setup?
03:42:31 <ben_h> hi folks
03:42:41 <solrize_> xenoblitz, i've heard of something like that, but if it exists at all, it hasn't caught on much
03:43:04 <xenoblitz> solrize: thanks for your reply ;)
03:43:49 <ben_h> i'm new to haskell, haven't really written any yet, but I've been reading Real World Haskell and Learn You a Haskell and I feel like I'm getting a bit of a feeling for the functional way of thinking.
03:44:05 <solrize_> ben_h cool!
03:44:15 <ben_h> I think my next step should be hacking some code, but I'm having trouble finding a project to tinker with that's approachable.
03:44:32 <dibblego> ben_h, you might consider http://projecteuler.net
03:45:01 <ben_h> dibblego: ahh thanks, i remember reading about that a little while ago
03:45:15 <dibblego> ben_h, np :)
03:45:59 <RayNbow> hmm, \underbrace doesn't work quite well on HaWiki?
03:46:14 <dibblego> ben_h, also there is a company that does courses on Haskell and/or FP depending on how far you have advanced
03:46:40 <ben_h> who are they dibblego?
03:47:01 <dibblego> ben_h, Workingmouse (I used to run the training course and I no longer work there, but maybe something can be worked out)
03:47:25 <ben_h> ah right. nice
03:49:26 <PeakerWork> ben_h: I wrote a ray tracer to learn Haskell, it was great fun!
03:49:42 <ben_h> PeakerWork: awesome
03:50:02 <ben_h> where did you start with that - what were you using as input?
03:50:23 <Badger> PeakerWork: how many frames did you get? :P
03:50:25 <PeakerWork> ben_h: First I looked for image format libraries
03:50:35 <PeakerWork> Badger: found none, so someone suggested (and I did) output PPM files
03:50:42 <Badger> ah
03:50:43 <PeakerWork> then I used imagemagick to convert that to a decent format (e.g png/jpg)
03:50:57 <PeakerWork> Badger: I generated a single scene image, not animations
03:50:57 <ben_h> nice
03:51:04 <PeakerWork> though I did toy with animations -- nothing serious
03:51:20 <dibblego> ben_h, I just love and miss teaching (I used to do a lot of work at university) ;)
03:51:31 * RayNbow notices the underbrace notes @ http://www.haskell.org/haskellwiki/Help:Editing
03:53:41 <ben_h> i like this problem: http://projecteuler.net/index.php?section=problems&id=215
03:53:58 * Badger shudders
03:54:04 <Badger> euler project :/
03:54:17 <ben_h> dibblego: what have you been doing for work post-workingmouse?
03:55:01 <dibblego> ben_h, I work from home for a financial company in Sydney
03:55:12 <dibblego> ben_h, so no more teaching - only the occasional guest lecture
03:55:53 <ben_h> cool
04:04:23 <therp> Badger: what's bad about project euler?
04:04:32 <Badger> maths :P
04:05:26 <therp> Badger: yes, math knowledge isn't a handicap there :)
04:06:05 <Badger> I looked at the first problem, then went "erk?" and fled. :P
04:06:21 <Badger> which, er, doesn't bode well for learning Haskell.
04:14:28 <ben_h> http://projecteuler.net/index.php?section=problems&id=107
04:14:34 <ben_h> food, then i hack on that
04:14:37 <ben_h> bbl
04:19:23 <mbz> damn, I forgot my projecteuler login :\
04:38:55 <flice> hi
04:39:40 <flice> I'm looking for a well-reputed article describing the differences between functional and imperative programming
04:40:43 <Lemmih> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html ?
04:41:02 <flice> Lemmih: thanks
04:44:37 <flice> what is the word for the opposite of higher-order programming?
04:47:27 <Raevel> flice: not sure there is an "opposite", how would that work?
04:47:42 <flice> Raevel: like Java?
04:48:05 <thoughtpolice> hi Lemmih
04:48:14 <Lemmih> thoughtpolice: Hey.
04:48:58 <Lemmih> thoughtpolice: I've managed to compile a minimal example without eval indirections (:
04:49:41 <Lemmih> Everything larger than "foldl' (+) [1..n]" fails, though.
04:49:44 <Raevel> flice: so no higher-order, i haven't heard a name for that actually, perhaps because it's just the lack of first class functions
04:50:01 <flice> Raevel: yep, thanks
04:50:15 <Lemmih> thoughtpolice: Our one-month anniversary is coming up (:
04:54:10 <thoughtpolice> Lemmih: :)
04:54:37 <thoughtpolice> Lemmih: I pushed a patch so that now the system will clean up by itself by default
04:54:44 <thoughtpolice> although it doesn't remove all the .ho files properly yet
04:54:54 <thoughtpolice> but it does remove all the .grin and .c files at the very least
04:55:20 <Lemmih> In most cases we need to keep the .ho files around.
04:55:27 <thoughtpolice> Lemmih: k
04:55:34 <thoughtpolice> Lemmih: how much work did it take to start inlining eval?
04:55:43 <thoughtpolice> it looks like eval is actually defined in data/rts or something?
04:55:51 <vegai> should yi-darcs be buildable against gtk2hs-darcs on ghc-6.10?
04:55:57 <vegai> I'm getting
04:55:57 <vegai> Yi/UI/Gtk/ProjectTree.hs:19:40: Module `Graphics.UI.Gtk' does not export `Event'
04:56:47 <Lemmih> thoughtpolice: Writing the points-to analysis was the hardest. A few modifications to the rts were also required.
04:57:01 <thoughtpolice> Lemmih: ah, how much code does the points-to analysis come out to?
04:57:17 <thoughtpolice> (loc)
04:57:36 <Lemmih> sloccount says 200 lines.
04:57:54 <thoughtpolice> nice :]
04:59:10 <thoughtpolice> Lemmih: also PureInteger still fails here, not sure why and I'm not sure about how to go about debugging the resulting executable
04:59:24 <vegai> hmm, looks like it's Graphics.UI.Gtk.Gdk.Event now
04:59:27 * vegai tests
04:59:52 <thoughtpolice> Lemmih: also like I said, compiling stuff with lhc using -fdebug fails due to some very strange OS X linking err
04:59:57 <thoughtpolice> which is pretty annoying honestly
05:00:02 <vegai> a stable gtk2hs would be quite nice
05:01:17 <xenoblitz1> vegai: I just picked up your conversation but i think gtk2hs has not been released for ghc 6.10.1 yet
05:02:39 <Lemmih> thoughtpolice: Can you run the code with 'strace' or gdb?
05:03:57 <Lemmih> thoughtpolice: The current RTS is way too complex, btw. We can discard most of it.
05:04:11 <Pellwurst> hey there, how can i devide two integers and get a double as result
05:04:12 <Pellwurst> ?
05:04:22 <bolrod> 101
05:04:28 <bolrod> ups
05:04:31 <Raevel> > 1 / 3
05:04:32 <Lemmih> We should worry about making it correct before we optimize it for speed.
05:04:32 <lambdabot>   0.3333333333333333
05:04:38 <mauke> Pellwurst: convert them to doubles first
05:05:02 <kig> > (fromInteger 1) / (fromInteger 3)
05:05:04 <lambdabot>   0.3333333333333333
05:05:25 <thoughtpolice> Lemmih: yeah I figure we can trim it down a bit to just a single, simple file
05:05:31 <thoughtpolice> which would be nice
05:05:44 <thoughtpolice> Lemmih: yeah I can use them, I'm still just trying to find a good place to start.
05:06:00 <dolio> > fromRational (1%3)
05:06:01 <lambdabot>   0.3333333333333333
05:08:28 <mgdtgd_> pellwurst: http://haskell.org/haskellwiki/Converting_numbers
05:08:28 <thoughtpolice> Lemmih: but I would really really like to get Integer working and compiling - I have a branch here which actually has it hooked into base, but it doesn't quite work
05:08:51 <thoughtpolice> Lemmih: then we get essentially unbounded numbers in nice, pure haskell98 we can compile and run anywhere!
05:09:30 <Pellwurst> mgdtgd: thx
05:21:25 <lunarisbluemoon> Hello, another newb question - is anyone familiar with calling the newArray# function? (with a #, i.e. primitive)
05:24:41 <Pellwurst> and how can i cast an int to a double?
05:24:48 <Olathe> fromInteger
05:24:54 <mauke> fromIntegral
05:24:57 <Olathe> Ahh.
05:24:58 <Olathe> Yes.
05:25:07 <Olathe> > fromIntegral 5
05:25:09 <lambdabot>   5
05:25:18 <Olathe> > (fromIntegral 5) :: Double
05:25:19 <lambdabot>   5.0
05:25:27 <robertg> I've bee trying to do the problem on project euler http://projecteuler.net/index.php?section=problems&id=3 but the code I have written seems to be inefficient and only works on small inputs http://hpaste.org/13061 - any suggestions?
05:26:16 <mauke> stop using Ints
05:26:30 <Olathe> Well, the algorithm is bad.
05:26:33 <Olathe> It's very slow.
05:26:46 <Olathe> If the largest factor is huge, it takes a while to count up to that.
05:26:48 <Elly> it is unlikely to work well on numbers as large as the one in the problem
05:27:05 <Elly> mostly because of what mauke said :P
05:27:14 <xenoblitz> guys what does ghc --interactive do?
05:27:30 <Olathe> xenoblitz: It doesn't do anything for you ?
05:27:33 <Elly> xenoblitz: try it
05:27:39 <Elly> robertg: I recommend a better algorithm
05:27:49 <Elly> robertg: there's a trivial (and fast!) way to get all the prime factors of a number
05:27:55 <Elly> well, "fast"
05:28:01 <robertg> yeah?
05:28:03 <Olathe> Much faster.
05:28:04 <Elly> yeah
05:28:08 <Elly> you should think of it :)
05:28:11 <xenoblitz> Olathe: I'm trying to use eclipse and somehow it seems to be using --interactive and its not following folders for .hs files
05:28:17 <xenoblitz> Elly: i shall ;)
05:29:02 <Olathe> I'm not too sure how Eclipse uses it, but interactive starts a sort of Haskell interpreter, which can compile stuff and so on.
05:29:22 <xenoblitz> wait so its just calling ghci ?
05:29:26 <Olathe> Yes.
05:29:33 <Olathe> That's what ghci stands for.
05:29:34 <xenoblitz> *feels dumb*
05:29:56 <xenoblitz> Olathe: thanks
05:30:13 <Olathe> You're welcome.
05:31:20 <Elly> robertg: as a hint, the simplest version of the 'faster' one takes two arguments :P
05:32:38 <Olathe> xenoblitz: I'd recommend factoring some numbers by hand to see how you do it.
05:33:23 <xenoblitz> Olathe: I guess you mean robertg :)
05:33:23 <robertg> to factor by hand I would keep dividing by the smallest prime then move on to the next smallest until the number is 0
05:33:30 <Olathe> Oh, yes.
05:33:45 <Olathe> Will that be faster ?
05:33:58 <Olathe> You can try it out to see.
05:34:41 <Elly> mine is instantaneous on the number given
05:35:03 <mauke> ./a.out  0.03s user 0.00s system
05:37:13 <walski> Hi
05:37:52 <walski> Is there any way I can easily check if some expression is a kind of the datatype ABC and especially one constructed by ABC's constructor XYZ?
05:37:57 <evident> how do i apply "filter" on two lists again? I want everything that is in ys, but not in xs. As in: filter (/=x) ys -> but not just for the first element -> for alle elements of first list. How do i do taht again?
05:38:34 <oshyshko> are these the same: 1) name <- x   2) name >>= x   ?
05:38:35 <evident> basically the difference of two lists
05:38:43 <Saizan> ?type notElem
05:38:44 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:39:22 <Asztal> oshyshko: 2) would be name >>= \x -> ...
05:39:32 <Olathe> @src nubBy
05:39:33 <lambdabot> nubBy eq []             =  []
05:39:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:39:43 <Asztal> err, x >>= \name ->
05:39:43 <Saizan> oshyshko: no, "do name <- x; ..."  is the same as "x >>= \name -> ..."
05:40:39 <oshyshko> so, "do + \n" equals to " >>= + ->"?
05:41:25 <oshyshko> er... "do + <- + \n" equals to " >>= + ->"?
05:41:26 <Saizan> ?undo do x; y
05:41:26 <lambdabot> x >> y
05:41:33 <Saizan> ?undo do name <- x; y
05:41:34 <lambdabot> x >>= \ name -> y
05:41:39 <Saizan> ?undo do Just name <- x; y
05:41:40 <lambdabot> x >>= \ a -> case a of { Just name -> y; _ -> fail ""}
05:43:29 <PeakerWork> why does it use "case" and not "let" to pattern-match?
05:44:20 <Saizan> you can't have multiple patterns in a let
05:44:37 <Saizan> oshyshko: here's the complete translation: http://www.haskell.org/onlinereport/exps.html#do-expressions
06:02:31 <athos> :t group
06:02:32 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
06:05:52 <mbz> @index group
06:05:53 <lambdabot> Data.List
06:06:51 <chrisdone> hmm
06:06:57 <Asztal> @src maximum
06:06:58 <lambdabot> maximum [] = undefined
06:06:58 <lambdabot> maximum xs = foldl1 max xs
06:07:54 <Axman6> :t foldr const
06:07:55 <lambdabot> forall a. a -> [a] -> a
06:08:01 <Asztal> hmm... interesting, because in Hugs, maximum [1..65536] gives me "Error - C stack overflow", whereas GHCI is happy to go up to [1..65536^5] and probably higher
06:08:10 <Axman6> > foldr const x [a,b,c]
06:08:12 <lambdabot>   a
06:08:17 <Axman6> > foldl const x [a,b,c]
06:08:19 <lambdabot>   x
06:08:48 <Axman6> > foldr (flip const) x [a,b,c]
06:08:50 <lambdabot>   x
06:08:55 <Axman6> > foldl (flip const) x [a,b,c]
06:08:56 <lambdabot>   c
06:09:00 <PeakerWork> Saizan: can you have multiple patterns in a (x <- Blah) do?
06:09:30 <chrisdone> is there anything unreasonable about defining an instance of Applicative for Reader?
06:09:38 <PeakerWork> chrisdone: there's already one
06:09:45 <PeakerWork> chrisdone: in Control.Applicative
06:09:49 <PeakerWork> (And its reasonable..)
06:09:52 <mauke> chrisdone: no, all monads can be made applicatives
06:10:01 <PeakerWork> s/can be/are
06:10:03 <chrisdone> PeakerWork: where is the definition?
06:10:14 <Saizan> PeakerWork: no, but the translation does, because it has to call fail if the pattern fails
06:10:23 <PeakerWork> Saizan: oh
06:10:32 <chrisdone> PeakerWork: oh, in Control.Applicative. cheers
06:10:48 <chrisdone> I don't see it
06:10:58 <PeakerWork> I think its there...
06:12:00 <PeakerWork> instance Applicative ((->) a) -- Defined in Control.Applicative
06:12:11 <PeakerWork> chrisdone: or do you mean the Reader newtype?
06:12:19 <chrisdone> the Reader newtype
06:13:54 <Axman6> @src Applicative
06:13:55 <lambdabot> class Functor f => Applicative f where
06:13:55 <lambdabot>     pure  :: a -> f a
06:13:55 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
06:14:09 <mauke> pure = return; (<*>) = ap
06:14:21 <RayNbow> @seen dons
06:14:21 <lambdabot> dons is in #haskell, #xmonad, #darcs, #concatenative, #ghc and #arch-haskell. I last heard dons speak 4h 51m 53s ago.
06:14:21 <PeakerWork> > pure 1 :: Control.Monad.Reader.Reader
06:14:22 <lambdabot>       Ambiguous occurrence `pure'
06:14:22 <lambdabot>      It could refer to either `Control.Appl...
06:14:32 <PeakerWork> > Control.Applicative.pure 1 :: Control.Monad.Reader.Reader
06:14:33 <lambdabot>       `Reader' is not applied to enough type arguments
06:14:33 <lambdabot>      Expected kind `?'...
06:14:33 <Axman6> pure for ((->) a) ==?
06:14:40 <mauke> const
06:14:46 <Axman6> thought so :)
06:14:52 <PeakerWork> > Control.Applicative.pure 1 :: Control.Monad.Reader.Reader a Int
06:14:53 <lambdabot>       No instance for (Show (Reader a Int))
06:14:53 <lambdabot>        arising from a use of `sho...
06:15:10 <PeakerWork> > runReader (Control.Applicative.pure 1) 1
06:15:10 <lambdabot>       No instance for (Applicative (Reader r))
06:15:10 <lambdabot>        arising from a use of `...
06:15:13 * RayNbow added http://haskell.org/haskellwiki/The_Fibonacci_sequence#Generalization_of_Fibonacci_numbers ... feel free to modify/enhance/etc.
06:15:27 <PeakerWork> chrisdone: I'm not sure that Reader has an instance
06:15:50 <chrisdone> indeedy
06:16:09 <chrisdone> instance Applicative (Reader s) where pure = return; (<*>) = ap
06:16:09 <chrisdone> ?
06:16:25 <chrisdone> is that how it ought to be defined?
06:16:28 <Saizan> yeah
06:16:39 <chrisdone> hmm
06:16:45 <chrisdone> what about ReaderT?
06:17:25 <chrisdone> instance Monad m => Applicative (ReaderT s m) where pure = return; (<*>) = ap
06:17:28 <chrisdone> right?
06:17:47 <chrisdone> yes
06:18:17 <Axman6> :t ap
06:18:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:18:38 <chrisdone> I've never used `ap' much.. hrmm
06:18:55 <mbz> ?src ap
06:18:56 <lambdabot> ap = liftM2 id
06:18:57 <Axman6> > ap [(+2),(*5),(/3)] [1..3]
06:18:58 <lambdabot>   [3.0,4.0,5.0,5.0,10.0,15.0,0.3333333333333333,0.6666666666666666,1.0]
06:19:06 <Axman6> > ap [(+2),(*5)] [1..3]
06:19:07 <lambdabot>   [3,4,5,5,10,15]
06:19:09 <chrisdone> aw hells yeah
06:19:22 <PeakerWork> chrisdone: ap is <*>'s implementation on top of Monad
06:19:48 <chrisdone> > ap (Just (*2)) (Just 2)
06:19:50 <lambdabot>   Just 4
06:19:51 <PeakerWork> chrisdone: because of the historical accident of not having Monad subclass Applicative, each of Functor/Applicative's methods was reimplemented with the Monadic class
06:20:00 <chrisdone> PeakerWork: right
06:20:04 <Axman6> > ap Nothing (Just 4)
06:20:06 <lambdabot>   Nothing
06:20:09 <PeakerWork> So fmap -> liftM,   pure -> return,  <*> -> ap
06:20:22 <PeakerWork> > liftM (*2) $ Just 5
06:20:23 <lambdabot>   Just 10
06:20:28 <Axman6> @src Functor
06:20:29 <lambdabot> class  Functor f  where
06:20:29 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
06:20:59 <PeakerWork> @src Applicative
06:20:59 <lambdabot> class Functor f => Applicative f where
06:20:59 <lambdabot>     pure  :: a -> f a
06:20:59 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
06:21:50 <Axman6> so what's the point of having functor, if it basically has the same stuff as Monad?
06:22:05 <PeakerWork> Axman6: its not the same, its "weaker" or "more general"
06:22:17 <Axman6> fair enough.
06:22:23 <PeakerWork> Axman6: Monad is more powerful than Functor, so everything a Functor can do, a Monad can, but not vice versa
06:22:25 <chrisdone> presumably because there are types which want what Functor has, but not all of what Monad requires
06:22:28 <robertg> Elly: am i on the right lines yet? this is what I have done, it doesn't work... http://hpaste.org/13062
06:22:30 <Axman6> any good emaples of time saving code that you can use Functor for?
06:22:38 <PeakerWork> Some types are Functors, but not Monads
06:22:46 <Axman6> ah yes, makes sense
06:22:54 <Elly> robertg: looks like it
06:23:09 <chrisdone> > null <$> (Just [1])
06:23:11 <lambdabot>   Just False
06:23:19 <chrisdone> why did I add parentheses ^_^?
06:23:33 <PeakerWork> Axman6: Generally, if you try to stick to generic interfaces in all your code, and generalize everything, you *might* end up with more re-usable code. I think conal's blog is a great example of that in effect
06:23:34 <robertg> Elly: can you see why it only ever returns 1?
06:24:04 <PeakerWork> > null <$> return . return 1 :: Just Bool
06:24:04 <lambdabot>   Not in scope: type constructor or class `Just'
06:24:08 <PeakerWork> > null <$> return . return 1 :: Maybe Bool
06:24:09 <lambdabot>   Couldn't match expected type `Maybe [a]'
06:24:15 <PeakerWork> > null <$> (return . return) 1 :: Maybe Bool
06:24:16 <lambdabot>   Just False
06:25:23 <tarbo> s/can/do/
06:25:38 <chrisdone> welcome back
06:25:55 <Elly> robertg: it's algorithmically wrong
06:25:59 <byorgey> robertg: what's this code supposed to do?
06:26:05 <vixey> your algorithmically wrong!
06:26:06 <Elly> robertg: another hint: the type of my solution is Integer -> Integer -> [Integer]
06:26:12 <Elly> vixey: *you're
06:26:14 <chrisdone> ha
06:26:25 <chrisdone> ergo your rong
06:26:52 <mauke> ERGO YOUR WRONG BITCH
06:28:23 <robertg> Elly: am I barking up the wrong tree making a list of primes the way I am?
06:30:26 <mauke> the | a == b case looks unreachable
06:30:32 <mauke> also, you're still using Ints
06:31:50 <Elly> robertg: generating a list of primes is slow
06:32:01 <Elly> robertg: I do not generate a list of all primes
06:32:29 <mauke> I do, and it's fast
06:32:53 <Asztal> I didn't use primes either
06:33:10 <mauke> my main function is: main = print . last . factors $ n
06:34:52 <vixey> I think you can do it quite fast with a big list of primes
06:34:57 <vixey> infinite
06:36:41 <Axman6> @hoogle forM_
06:36:42 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
06:36:42 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
06:36:43 <Olathe> robertg: How did the version that works like you'd factor a number go ?
06:36:50 <Axman6> @hoogle printf
06:36:51 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
06:36:51 <lambdabot> module Text.Printf
06:36:51 <lambdabot> package printf-mauke
06:37:18 <mauke> o hai
06:37:55 <robertg> Olathe: http://hpaste.org/13062 returns 1 on every input
06:38:57 <Olathe> robertg: That doesn't divide the number by the prime factor you found and then go on from there.
06:39:06 <mauke> robertg: yes, that's what happens when you divide a number by all of its prime factors
06:39:07 <Olathe> I think.
06:39:08 <Olathe> Let me check.
06:39:19 <Olathe> Ahh, it does.
06:39:32 <Olathe> Yes, mauke has a decent observation.
06:40:04 <robertg> so my base case is wrong? with that method?
06:40:41 <mbz> mauke, what's wrong with Ints and why robertg shouldn't use Ints?
06:41:09 <Olathe> robertg: Well, you don't keep a list of factors so that you can see the last one.
06:41:11 <vixey> Ints only go up to 10
06:41:13 <Axman6> i think it was a project euler problem, so Ints probably won't be big enough
06:41:15 <vixey> Integer goes past 11
06:41:31 <mauke> robertg: you don't have a base case
06:41:35 <Olathe> No, Euler problems keep it below 32 bits.
06:41:43 <Axman6> vixey: they're base 14 right? so they fit 7 times more info in each bit
06:41:57 <Olathe> They want to see the algorithm rather than the weird hacked up Bignum implementations.
06:42:12 <Olathe> Or, at least, below 64.
06:44:08 <robertg> Olathe: I was thinking that I wouldn't need to keep a list, if I just output the last one when the input number is equal to the head of the primes list
06:45:36 <Olathe> Sure, but you have a number that has all the factors mixed together and you have a number that's a factor you're taking out.
06:46:09 <Olathe> I think you're returning the number that has all the factors mixed together.
06:46:17 <Olathe> Since you've removed all the factors from it, it's 1.
06:46:34 <Olathe> But you want the last factor removed, so you'll want to return the other number.
06:46:55 <Olathe> Let me look at it, actually.
06:47:14 <Olathe> Oh !
06:47:15 <Olathe> I see.
06:47:16 <ski_> Axman6 : a digit in base 14 doesn't contain 7 times more information than a digit in base 2
06:47:20 <ski_> it contains
06:47:24 <ski_> > logBase 2 14
06:47:25 <lambdabot>   3.8073549220576037
06:47:28 <ski_> times more information
06:47:31 <Olathe> robertg: Sorry, I misunderstood.
06:47:41 <Axman6> ah, my mistake
06:47:44 <Olathe> robertg: If a == b, is a `mod` b == 0 ?
06:48:31 <ski_> > 0 `mod` 0
06:48:32 <lambdabot>   * Exception: divide by zero
06:48:58 <Olathe> Zero is unpossible here.
06:49:10 <ski_> ic
06:49:15 <Axman6> "Did you mean: 64 bit gcc -gcc  " thanks google, i totally didn't mean anything by that -gcc right there
06:49:28 <Axman6> (search term was "64 bit ghc -gcc")
06:49:38 <robertg> so if I change the order of the guards should it work?
06:49:45 <Olathe> robertg: It should help.
06:49:50 * ski_ thinks `mod x 0' ought to be `x', though ..
06:49:59 <Axman6> > mod 3 0
06:50:00 <thoughtpolice> @src ($!)
06:50:00 <lambdabot> f $! x = x `seq` f x
06:50:01 <lambdabot>   * Exception: divide by zero
06:50:05 <Axman6> > mod 3 1
06:50:07 <lambdabot>   0
06:50:12 <Olathe> I'm not sure it can get to the last guard ever.
06:50:30 <mauke> <mauke> the | a == b case looks unreachable
06:50:55 <Olathe> Ahh.
06:50:58 <Olathe> Sorry.
06:51:09 <robertg> 6857!!!!!!!!!!!!
06:51:21 <Axman6> robertg: looks like the answer i got ;)
06:52:14 <robertg> Elly: now that I got it my way - I would be interested in knowing your algorithm
06:52:27 <ski_> > iterate (product . enumFromTo 1) 6857 !! (length "!!!!!!!!!!!!")
06:52:42 <lambdabot>   thread killed
06:52:43 <mauke> http://rafb.net/p/19Unmn69.html <- my solution
06:55:58 <vixey> oh
06:56:13 <vixey> I think I found an O(n) algorithm for topological sort
06:56:26 <vixey> it assumes a topological sort exists though :/
06:56:42 <vixey> and you need to already know a bottom
06:57:13 <vixey> sortBy (\node -> if node == bottom then 0 else 1 + sum (map graph node)) nodes
06:57:30 <vixey> I guess that's really n log n with the sorting too
07:00:03 <Axman6> vixey: topological sort?
07:00:08 <vixey> yeah
07:00:31 <vixey> that was a bit wrong
07:00:47 <vixey> should be like (fix (\graph n -> ..) instead of (n -> ...)
07:03:08 <Axman6> anyone know how to compile GHC 64-bit?
07:03:13 <Olathe> Here's mine for Euler #3: http://hpaste.org/13064
07:04:27 <Axman6> Olathe: rem n 2 == 0 == even?
07:04:41 <Axman6> if even n then ...
07:04:54 <PeakerWork> Olathe: there's a bit of duplication in there
07:05:15 <Olathe> You mean the 2s ?
07:05:23 <Olathe> Axman6: Ahh :)
07:05:35 <Lemmih> Axman6: Compiling GHC on a 64-bit machine is problematic?
07:05:43 <PeakerWork> Olathe: yeah, if..then seems to be a special case for 2, of what you have in factors'
07:05:50 <olsner> Axman6: just build it on a 64-bit system and you'll get a 64-bit ghc :P
07:05:50 <Axman6> Lemmih: on OS X it seems to be at least
07:05:56 <PeakerWork> Olathe: also, you're skipping multiples of 2, but you might as well skip all non-primes?
07:06:03 <Axman6> this is a 64 bit system :\
07:06:04 <Olathe> Ahh, I do that to make it where it can add 2 each time rather than 1.
07:06:05 <SamB_XP_> Axman6: well, start with a 64-bit GHC
07:06:20 <Olathe> Well, generating a list of primes is slower than just running through the odds.
07:06:27 <Olathe> At least here.
07:06:35 <Olathe> So, I just run through the odds.
07:07:00 <Olathe> I think it might get quite a bit faster as the number to factor gets huge.
07:07:00 <Axman6> SamB_XP_: if there were any i would
07:07:08 <Olathe> Using a prime list, I mean.
07:08:09 <PeakerWork> Olathe: I guess it depends, if you have a memoised list of primes, it might be faster for the second factor
07:08:19 <SamB_XP_> Axman6: that would be the problem, then ;-P
07:08:40 <Olathe> Yeah, I think it might.
07:08:46 <Olathe> Especially if they're cached.
07:09:03 <Axman6> cached == memoised
07:09:09 <Olathe> I mean processor cache.
07:09:13 <Axman6> ah
07:09:19 <Olathe> If it has to go to RAM, it's slow compared to adding two.
07:09:56 <PeakerWork> claims about micro-optimization (from thin air) should be taken with grains of salt because there are probably 5 things you didn't think of that affect performance far more than the one you did :)
07:10:08 <Olathe> Oh, sure :)
07:10:09 <PeakerWork> (Claims about processor cache, like that one, I mean)
07:10:39 <Olathe> Yeah, I wouldn't really worry too much about it, I'd just try both for speed.
07:10:40 <PeakerWork> what's the density of prime numbers?
07:10:52 <PeakerWork> what % of numbers are prime?
07:10:59 <Olathe> Oh, zero percent.
07:12:23 <vixey> 0%
07:12:38 <Olathe> I think you have to look at it logarithmically or something like that.
07:12:44 <PeakerWork> Olathe: so checking just prime ones ought to be a nice improvement :)
07:12:48 <Olathe> Oh, sure.
07:13:02 <Olathe> For huge numbers, I think it would start to have huge benefits.
07:13:13 <Axman6> what do pyou guys think of this for testing primeness: prime' n d = (not $ n `rem` d == 0) || d*d > n || prime' n (d+2)
07:13:23 <Axman6> -p
07:13:42 <Olathe> n `rem` d /= 0
07:14:33 <Olathe> I think d*d > n should give false.
07:14:36 <Axman6> hmm, actually it doesn't make sense
07:14:48 <PeakerWork> > let onBoth = join (***) ; sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in onBoth (length . takeWhile (<1000)) ((sieve &&& id) [2..])
07:14:50 <lambdabot>   (168,998)
07:15:07 <Axman6> Olathe: if the divisor is greated than âˆšn then it's prime
07:15:12 <Olathe> Oh !
07:15:17 <PeakerWork> Olathe: so to factor a number ~1000, you'd check ~500 divisions instead of ~170
07:15:35 <PeakerWork> > let onBoth = join (***) ; sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in onBoth (length . takeWhile (<1000000)) ((sieve &&& id) [2..])
07:15:51 <lambdabot>   thread killed
07:16:07 <Olathe> I'd say n `rem` d /= 0 && (d*d >n || prime' n (d + 2))
07:16:18 <Olathe> Or something.
07:16:26 <PeakerWork> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in length . takeWhile (<1000000) . sieve $ [2..]
07:16:42 <lambdabot>   thread killed
07:16:48 <PeakerWork> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in length . takeWhile (<100000) . sieve $ [2..]
07:17:03 <lambdabot>   thread killed
07:17:38 <Axman6> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in sieve [(2:[3,5..])
07:17:41 <lambdabot>   <no location info>: parse error on input `;'
07:17:52 <Axman6> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in sieve (2:[3,5..])
07:17:56 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:18:05 <PeakerWork> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in length . takeWhile (<100000) . sieve $ 2:[3,5..]
07:18:11 <Axman6> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in (sieve (2:[3,5..])) !! 1000
07:18:18 <Axman6> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in (sieve (2:[3,5..])) !! 100
07:18:19 <lambdabot>   7927
07:18:20 <lambdabot>   thread killed
07:18:23 <lambdabot>   547
07:18:24 <Axman6> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in (sieve (2:[3,5..])) !! 200
07:18:29 <lambdabot>   1229
07:19:27 <Olathe> @src odd
07:19:28 <lambdabot> odd = not . even
07:19:29 <PeakerWork> sieve is pretty slow :P
07:19:34 <Olathe> Yeah :)
07:19:40 <PeakerWork> @src even
07:19:40 <lambdabot> even n = n `rem` 2 == 0
07:19:43 <Axman6> >  2:nubBy (\x y -> 0 == mod x y) [3,5..]
07:19:48 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:19:57 <PeakerWork> 15 :-)
07:20:00 <PeakerWork> and 9, etc
07:20:01 <Axman6> >  2:nubBy (\x y -> 0 == mod y x) [3,5..]
07:20:06 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:20:19 <Axman6> @pl (\x y -> 0 == mod y x)
07:20:19 <lambdabot> ((0 ==) .) . flip mod
07:20:25 <Olathe> > let prime 2 = True; prime n = odd n && prime' 3 n where prime' d n = n `rem` d /= 0 && (d*d > n || prime' n (d + 2)) in map prime [2..]
07:20:27 <Axman6> @pl (\x y -> mod y x == 0)
07:20:28 <lambdabot> flip flip 0 . ((==) .) . flip mod
07:20:30 <lambdabot>   [True,False,False,True,False,True,False,False,False,True,False,True,False,F...
07:20:31 <Axman6> heh
07:20:40 <Olathe> Hmm...
07:21:00 <Olathe> > let prime 2 = True; prime 3 = True; prime n = odd n && prime' 3 n where prime' d n = n `rem` d /= 0 && (d*d > n || prime' n (d + 2)) in map prime [2..]
07:21:05 <lambdabot>   [True,True,False,True,False,True,False,False,False,True,False,True,False,Fa...
07:21:09 <Axman6> > let primes = 2:nubBy (\x y -> 0 == mod y x) [3,5..] in primes !! 200
07:21:13 <PeakerWork> @let onBoth = join (***)
07:21:14 <lambdabot>   1229
07:21:16 <lambdabot>  <local>:9:14:
07:21:16 <lambdabot>      Ambiguous type variable `a' in the constraint:
07:21:16 <lambdabot>        `Ar...
07:21:39 <teko> which haskell forum do you guys frequent ?
07:21:51 <PeakerWork> @let onBoth :: Arrow a => a b c -> a (b,b) (c,c) ; onBoth = join (***)
07:21:53 <lambdabot>  Defined.
07:22:25 <Axman6> there are haskell forums?
07:22:36 <PeakerWork> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in uncurry (==) $ onBoth (take 1000) (2:nubBy (\x y -> 0 == mod y x) [3,5..], sieve $ 2:[3,5..])
07:22:48 <PeakerWork> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in uncurry (==) $ onBoth (take 100) (2:nubBy (\x y -> 0 == mod y x) [3,5..], sieve $ 2:[3,5..])
07:22:51 <lambdabot>   thread killed
07:22:53 <lambdabot>   True
07:23:07 <PeakerWork> the nubBy generates the first 100 primes correctly, at least :)
07:23:21 <Axman6> PeakerWork: 2:sieve [3,5..] would be slightly better no?
07:23:24 <PeakerWork> &&& and *** for function composition are pretty great :)
07:23:36 <Olathe> Yeah :)
07:23:43 <PeakerWork> Axman6: would that test for division by 2?
07:23:52 <Axman6> PeakerWork: i think my nubBy version is basically the same as yours
07:24:02 <PeakerWork> Axman6: seems so
07:24:09 <Axman6> PeakerWork: are any of the odd numbers divisible by 3?
07:24:24 <Axman6> uh, 2
07:24:25 <Saizan> teko: the most active is the haskell-cafe@haskell.org mailing list
07:24:30 <Axman6> @src nubBy
07:24:31 <lambdabot> nubBy eq []             =  []
07:24:31 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:24:38 <Olathe> Hmm, you could remove 2 from the sieves prime list.
07:24:41 <Olathe> sieve's
07:24:47 <Axman6> yup
07:25:38 <PeakerWork> Axman6: oh, right :-)
07:25:48 <Axman6> :)
07:25:58 <ronny> anybody knows what debian package is necessary for Control.Category
07:26:01 <chrisdone> @hoogle inRange
07:26:02 <PeakerWork> > let sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0] in uncurry (==) $ onBoth (take 100) (2:nubBy (\x y -> 0 == mod y x) [3,5..], 2:sieve [3,5..])
07:26:02 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
07:26:02 <lambdabot> Distribution.Version withinRange :: Version -> VersionRange -> Bool
07:26:05 <lambdabot>   True
07:27:24 <Olathe> @pl \x y -> rem y x == 0
07:27:25 <lambdabot> flip flip 0 . ((==) .) . flip rem
07:27:40 <Olathe> @pl \x y -> 0 == rem y x
07:27:40 <lambdabot> ((0 ==) .) . flip rem
07:27:42 <athos> :t showHex
07:27:44 <PeakerWork> ronny: If you're going to do any Haskell development, its best to give up on the Deb packages and just install everything into /usr/local manually
07:27:45 <lambdabot> forall a. (Integral a) => a -> String -> String
07:28:01 <PeakerWork> ronny: a lot of stuff isn't packaged, and you're going to need cabal-install anyhow
07:28:09 <athos> hm
07:28:29 <athos> @pl showHex a ""
07:28:30 <lambdabot> showHex a []
07:28:33 <ronny> PeakerWork: for now all i want to do is fix the geordi on my vserver
07:28:33 <idnar> I thought Control.Category was new in ghc 6.10
07:28:55 <rgr> reading RWH. But how to revert prompt after a :set to what it originally was?
07:29:05 <PeakerWork> Yeah, I think its in ghc 6.10, which is not in Ubuntu/Debian, afaik
07:29:08 <Asztal> :unset
07:29:17 <rgr> tried
07:29:37 <rgr> unknown option prompt
07:29:37 <ronny> oh dammit
07:29:40 <PeakerWork> not sure why tutorials even both to mention the prompt changing stuff
07:29:43 <PeakerWork> bother
07:29:54 <rgr> PeakerWork: to get people comfortable. Standard in any tutorial.
07:30:10 <rgr> Unfortunately not so comfirtable when the first thing is not explained how to undo ...
07:30:30 <Asztal> :set prompt %s>
07:30:36 <Asztal> with a space at the end
07:30:58 <idnar> changing the prompt is standard in any tutorial??
07:31:22 <rgr> idnar: the type of thing. It was pretty standard for any shell tutorial for example.
07:31:39 <rgr> Anyway, how would I have found that out fom the help in ghci?
07:31:50 <rgr> I tried ":? unset" and no joy.
07:32:14 <SamB_XP_> rgr: by creating a ticket on the GHC trac and waiting for someone to fix it, and for the fix to make it's way into a release
07:32:20 <SamB_XP_> ;-P
07:32:33 <rgr> SamB_XP_: yeah :-;
07:32:35 <Olathe> I had to do that once.
07:32:41 <Olathe> It took a while.
07:33:15 <rgr> I like the look of Haskell but one thing is apparent - it's real chicken and egg. You kind of have to know it all to learn one thing ..... Anyway back to RWH ...
07:33:29 <Asztal> I just did " :set prompt" while I still had the default prompt, which tells you the current prompt
07:34:01 <Axman6> can you have a list of Int64#'s?
07:34:09 <rgr> Asztal: ah. Not so helpfule when your prompt is the one you overrode it with :-;
07:34:15 <Asztal> yes :(
07:34:27 <SamB_XP_> Axman6: heck no
07:34:27 <idnar> you could run another ghci session and check there
07:34:34 <rgr> I would have thought ":unset prompt" would have worked.
07:34:38 <Axman6> hmm, fair enough
07:34:51 <SamB_XP_> rgr: I wouldn't really expect it to, but I'd wish it would
07:34:59 <SamB_XP_> so file a ticket about it
07:35:24 <rgr> SamB_XP_: I dont know what a ticket is, and find it better to become more familiar with things before logging bugs :-;
07:35:45 <rgr> but wow, just as I thought no language could be a problem along comes Haskell :-;;
07:36:15 <SamB_XP_> rgr: well, you don't have to know the language to understand that it would be best if :unset worked on stuff like that ...
07:36:19 <idnar> Python doesn't have any way to reset the interactive interpreter prompt, either
07:36:32 <idnar> on the other hand, I've never seen a Python tutorial that explained how to change it in the first place
07:36:46 <SamB_XP_> idnar: well, if you could change it you could change it back
07:36:59 <SamB_XP_> since the Python one consists of ">>> "
07:37:05 <SamB_XP_> no ifs, ands, or buts!
07:37:16 <idnar> SamB_XP_: well, yeah, I suppose
07:37:17 <rgr> idnar: why are you so fixated on whether it should be there? It is. Most people like prompts to change. Especially when combined with :m + module and your are working in confined buffers in emacs for example.
07:37:39 <idnar> rgr: you're the one who made the "wow" comment :)
07:38:02 <SamB_XP_> @where trac
07:38:03 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:38:23 <idnar> it's not really a big deal, it's just really not the kind of thing I'd expect to be in any sort of tutorial
07:38:24 <rgr> in the context of Haskell being a head wrecker - not in terms of setting a poxy prompt :-)
07:38:25 <SamB_XP_> rgr: go there, and login with ... someone help me out here ?
07:39:02 <idnar> rgr: oh, right, I guess I read too much into that
07:39:16 <rgr> SamB_XP_: I was being flippant. As I say, I like to become more familiar with things before logging bugs. I'll keep a note of it.
07:39:37 <SamB_XP_> rgr: file now before we kickban you!
07:39:48 <Axman6> bleh, i'm trying to mess with some GHC.Prim stuff, and i'm getting nowhere. can anyone tell me what's wrong with let fib :: Int# -> Int#; fib 0 = 1; fib 1 = 1; fib n = l +# r where l = fib (n -# 2); r = fib (n -# 1)
07:40:18 * rgr blinks and looks back up to RWH in iceweasel with forboding ...
07:40:55 <SamB_XP_> rgr: you don't need to be more familiar with this to see that there's an issue
07:41:02 <SamB_XP_> you can already see it
07:41:09 <ronny> anyone aware of debian repos for more recent ghc?
07:41:11 <SamB_XP_> learning Haskell won't make the issue go away!
07:41:48 <thoughtpolice> Axman6: you can't just have '1' and have it be of type Int#
07:42:00 <Axman6> thoughtpolice: what can i have?
07:42:06 <SamB_XP_> 1# might work
07:42:17 <thoughtpolice> you can also just pull the Int# out of Int directly
07:42:31 <SamB_XP_> thoughtpolice: that'd be more work wouldn't it ?
07:42:43 <thoughtpolice> http://hpaste.org/13065
07:42:52 <thoughtpolice> well it just depends on how you approach it I guess
07:43:35 <Olathe> > 1#
07:43:38 <lambdabot>   Couldn't match kind `#' against `*'
07:43:43 <Olathe> > I# 1
07:43:46 <lambdabot>   Not in scope: data constructor `I#'
07:43:52 <Olathe> Bad lambdabot !
07:44:04 <SamB_XP_> > (# 1# #)
07:44:07 <lambdabot>       Illegal binding of unboxed tuple e_11 :: (# GHC.Prim.Int# #)
07:44:18 <Olathe> You've broken the law !
07:44:25 <SamB_XP_> Olathe: bah
07:44:52 <SamB_XP_> you are probably one of those people who thinks the police will be after 'im after he gets an Illegal Instruction error
07:46:13 <Olathe> Well, it's a bit like speeding.
07:46:18 <Olathe> You hope they're not watching.
07:46:23 <swiert> What kind of array can I use to store Integers?
07:46:24 <Olathe> But you can never be sure.
07:46:38 <Olathe> swiert: A list works well usually.
07:47:00 <Olathe> swiert: But, shouldn't most arrays work with them ?
07:47:15 <swiert> Olathe: it's for a project euler problem where I need to do some dynamic programming.
07:47:35 <Olathe> Ahh.
07:49:23 <swiert> Olathe: and there are quite a few different array types, most of which seem to store things of a fixed size.
07:50:31 <robertg> I've just done Euler 7 http://projecteuler.net/index.php?section=problems&id=7 , but my code is desperately inefficient - took about 1-2mins to get the answer http://hpaste.org/13066 what would have been a better approach?
07:51:10 <vixey> seive isn't good
07:52:10 <SamB_XP_> seive is apparantly a lot better if you do it right -- with a bitmap
07:52:23 <Axman6> create a list of primes, which uses itself to check for primeness by dividing by all primes up to âˆšn
07:52:25 <Olathe> > array (1,100) [let j = (fromInteger i) :: Integer in (i, j*j) | i <- [1..100]]
07:52:29 <lambdabot>   array (1,100) [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),...
07:52:36 <Olathe> > array (1,100) [let j = (fromIntegral i) :: Integer in (i, j*j) | i <- [1..100]]
07:52:39 <lambdabot>   array (1,100) [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),...
07:52:59 <SamB_XP_> of course, the trouble with the bitmap approach is that you have to know how high you want to go ...
07:53:04 <pejo> swiert, TA:ing, or just programming for fun?
07:53:24 <swiert> pejo: just programming for fun :)
07:53:42 <SamB_XP_> swiert: you could also use any Array that has no U in the name ;-)
07:54:40 <Axman6> :t all
07:54:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:54:46 <Axman6> :t and
07:54:48 <lambdabot> [Bool] -> Bool
07:55:04 <Olathe> swiert: I think the arrays will store references or something, rather than the whole Integer.
07:55:31 <SamB_XP_> swiert: if you want Integer indexes, though, you can't expect an array to help ;-P
07:56:15 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (0 /= flip rem x) (takeWhile (\n -> n*n < x) primes) in primes
07:56:17 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
07:56:21 <swiert> SamB_XP_: Actually - I just solved it using a list.
07:56:26 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (0 /= flip rem x) $ (takeWhile (\n -> n*n < x) primes) in primes
07:56:29 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
07:56:32 <swiert> SamB_XP_ : but thanks for the pointer anyhow.
07:56:40 <Axman6> :t (0 /= flip rem x)
07:56:42 <lambdabot>     No instance for (Num (Expr -> Expr))
07:56:42 <lambdabot>       arising from the literal `0' at <interactive>:1:1
07:56:42 <lambdabot>     Possible fix: add an instance declaration for (Num (Expr -> Expr))
07:56:45 <SamB_XP_> no, pointers are in Foreign
07:56:46 <swiert> I got confused by all the different array types.
07:56:55 <swiert> hehe
07:57:12 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n < x) primes) in primes
07:57:15 <lambdabot>   [2,3,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,8...
07:57:20 <Axman6> whoot
07:57:25 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n < x) primes) in primes !! 10001
07:57:33 <lambdabot>   104033
07:57:38 <Axman6> fuck yes!
07:57:46 <Axman6> though that answer's not right...
07:57:57 <Axman6> wait, they aren't primes!
07:58:07 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem m x) $ (takeWhile (\n -> n*n < x) primes) in primes !! 10001
07:58:09 <Olathe> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n < x) primes) in primes !! 1
07:58:12 <lambdabot>   3
07:58:14 <lambdabot>   20003
07:58:22 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem m x) $ (takeWhile (\n -> n*n < x) primes) in primes
07:58:22 <Olathe> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n < x) primes) in primes !! (10001 - 1)
07:58:27 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:58:30 <lambdabot>   104021
07:58:38 <Olathe> The indexing is off by one.
07:58:53 <Axman6> answer should be 104743
07:59:02 <Asztal> maybe n * n <= x?
07:59:09 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n < x) primes) in primes
07:59:13 <lambdabot>   [2,3,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,8...
07:59:18 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n <= x) primes) in primes
07:59:21 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:59:22 <Asztal> yeah, look, it lists 25 as prime
07:59:37 <Axman6> Asztal: yeah, <=, ta :)
07:59:52 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n <= x) primes) in primes !! 10002
07:59:59 <lambdabot>   104761
08:00:07 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile (\n -> n*n <= x) primes) in primes !! 10001
08:00:14 <lambdabot>   104759
08:00:21 <Axman6> hmm
08:00:56 <Axman6> @pl (\n -> n*n <= x)
08:00:57 <lambdabot> (<= x) . join (*)
08:01:08 <Axman6> @pl (\n -> x >= n*n)
08:01:08 <lambdabot> (x >=) . join (*)
08:01:19 <Axman6> heh, ok, good
08:01:37 <Asztal> chatzilla turns >=) into a face... :)
08:01:51 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile ((<= x).(^2)) primes) in primes !! 10001
08:02:00 <lambdabot>   104759
08:02:05 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile ((<= x).(^2)) primes) in primes !! 10002
08:02:14 <lambdabot>   104761
08:02:17 <Olathe> What are you looking for ?
08:02:24 <Axman6> 104743
08:02:34 <Olathe> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile ((<= x).(^2)) primes) in primes !! 10000
08:02:36 <lambdabot>   104743
08:02:40 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map (\m -> 0 /= rem x m) $ (takeWhile ((<= x).(^2)) primes) in primes !! 10000
08:02:43 <lambdabot>   104743
08:02:48 <Axman6> heh yes
08:03:16 <Axman6> ah yes, the nth element is at the n-1th index
08:03:56 <robertg> surely that's typical for everything - eg. the year 1 was the second year
08:04:25 <SamB_XP_> nope
08:04:27 <SamB_XP_> it wasn't
08:04:33 <SamB_XP_> they hadn't invented 0 yet ;-)
08:04:34 <Axman6> @pl (\m -> 0 /= rem x m)
08:04:34 <lambdabot> (0 /=) . rem x
08:04:39 <SamB_XP_> or rather, stolen it
08:04:54 <robertg> well they hadn't invented the calendar yet either
08:05:03 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes) in primes !! 10000
08:05:06 <lambdabot>   104743
08:05:14 <Axman6> > let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes) in drop 1000 primes
08:05:16 <lambdabot>   [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081...
08:05:47 <Axman6> @let primes = 2:[x| x<- [3,5..], isPrime x]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes)
08:05:48 <lambdabot>  Defined.
08:05:53 <Axman6> > primes
08:05:53 <robertg> but a lack of calendars doesn't mean that years don't exist
08:05:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:06:27 <idnar> Axman6: "filter isPrime [3,5...]" reads a lot nicer than the list comprehension, I'd say
08:06:57 <roderyk> typesetting some CT notes, in LaTeX is there something like \underrightarrow{f}, but one that will display the arrow at mid-height? Visually I need "A -> B" with a small 'f' over the arrow
08:07:32 <Asztal> and 'all' reads a little nicer than and . map, I think
08:07:37 <Axman6> @let primes2 = 2:primes'; primes' = filter isPrime [3,5..]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes)
08:07:39 <lambdabot>  <local>:11:55:
08:07:39 <lambdabot>      Multiple declarations of `L.isPrime'
08:07:39 <lambdabot>      Declared at: <...
08:07:42 <SamB_XP_> roderyk: there is *something* for that
08:07:57 <Axman6> @unlet prime
08:07:58 <lambdabot>   Parse error
08:08:04 <Axman6> @help unlet
08:08:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:08:14 <Axman6> @help @unlet
08:08:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:08:19 <Axman6> -_-
08:08:20 <roderyk> SamB_XP_: I've been told to use xypic for this. Was hoping it'd be simpler :)
08:08:25 <Axman6> @unlet
08:08:27 <lambdabot>  Defined.
08:08:32 <Axman6> ...
08:08:49 <mmorrow> timber looks interesting: http://timber-lang.org/
08:09:01 <idnar> @undefine
08:09:09 <idnar> @undef
08:09:15 <Axman6> @let primes = 2:primes'; primes' = filter isPrime [3,5..]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes')
08:09:16 <lambdabot>  Defined.
08:09:23 <Axman6> > primes
08:09:31 <pejo> roderyk, there's some construct that lets you stack symbols in latex, but I don't remember the name right now.
08:09:38 <lambdabot>   thread killed
08:09:42 <Axman6> :|
08:09:51 <pejo> roderyk, perhaps \overset?
08:10:05 <Axman6> @let primes = 2:filter isPrime [3,5..]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes)
08:10:06 <lambdabot>  <local>:2:0:
08:10:06 <lambdabot>      Multiple declarations of `L.primes'
08:10:06 <lambdabot>      Declared at: <loc...
08:10:18 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes) in primes
08:10:20 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:10:44 <Axman6> > let primes = 2:primes'; primes' = filter isPrime [3,5..]; isPrime x = and . map ((0 /=) .rem x) $ (takeWhile ((<= x).(^2)) primes') in primes
08:11:00 <lambdabot>   thread killed
08:11:12 <pejo> mmorrow, have you tried it?
08:11:38 <mmorrow> pejo: not yet, just reading about it now
08:12:10 <SamB_XP_> roderyk: http://www.ctan.org/tex-archive/help/Catalogue/entries/mhchem.html ?
08:12:12 <mmorrow> pejo: i downloaded it a few months ago from code.haskell.org (or somewhere) and looked at the code then, but didn't really know what it was then
08:12:28 <mmorrow> (and didn't actually build it)
08:12:35 <SamB_XP_> might contain the secret in the code, I mean
08:12:42 <SamB_XP_> not that you should actually use it ;-)
08:13:47 <roderyk> SamB_XP_, pejo: from #latex, A \xrightarrow[]{f} B    mathtools package
08:14:01 <roderyk> works like a charm, but will probably have to look into xypics later anyway :)
08:14:09 <vixey> mmorrow: I don't understand why timber is a 'language' not a monad in haskell
08:14:27 <SamB_XP_> there are category-theory related packages aren't there ?
08:14:48 <thoughtpolice> category-extras ?
08:15:54 <pejo> vixey, I'm guessing that subtyping, strict evaluation and probably something else would take some work to shoehorn in.
08:16:29 <SamB_XP_> thoughtpolice: for LaTeX~
08:16:33 <SamB_XP_> s/~/!/
08:17:47 <thoughtpolice> ag
08:17:49 <mmorrow> vixey: apparently it's for realtime code, and ghc's rts isn't realtime. also, the language is strict and apparently incorporates some OO concepts
08:18:06 <mmorrow> it has typeclasses though
08:18:11 <thoughtpolice> timber looks really cool
08:19:09 <mmorrow> vixey: but from what i've gathered in the last 10 minutes, the syntax is very similr to haskell's
08:19:35 <Axman6> thanks wikipedia: "Timber is a functional programming language descendant from O'Haskell, targeted at embedded real-time systems."
08:19:53 <mpeter> what's o'haskell again
08:20:02 <SamB_XP_> mmorrow: it certainly isn't Haskell's syntax that makes it inappropriate for realtime systems ;-)
08:20:19 <mmorrow> SamB_XP_: no, it's the rts.
08:20:37 <SamB_XP_> the semantics, too ;-P
08:20:50 <SamB_XP_> and the library
08:20:56 <pejo> SamB, what semantics?
08:21:09 * mpeter watches intently
08:21:21 <SamB_XP_> pejo: that in itself doesn't help much :-(
08:21:22 <mmorrow> SamB_XP_: there's nothing that prevents someone from writing an implementation whose rts is capable of providing bounded time guarantees
08:21:49 <pejo> mpeter, O'Haskell was a conservative extension to Haskell. It featured the idea of 'reactive objects', and incorporated subtyping in the type system.
08:22:13 <SamB_XP_> yes, but Haskell code is a bit excessively lazy for realtime/embedded stuff, isn't it?
08:22:54 <mmorrow> SamB_XP_: as long as you have a guarantee of a time bound, that's good enough for (soft)-realtime code
08:23:24 <SamB_XP_> pejo: how is that conservative ?
08:23:32 <SamB_XP_> if it was conservative, why didn't it make it into GHC ?
08:23:51 <mmorrow> like "i need the space shuttles arm to react withing x time so that it doesn't get caught in the door"
08:24:03 <mpeter> what languages support symmetric multiprocessing
08:24:10 <mpeter> can we generate a list
08:24:28 <SamB_XP_> mpeter: of course not
08:24:37 * mpeter frowns
08:24:37 <SamB_XP_> no more than we can list the reals
08:24:54 <SamB_XP_> diagonalization!
08:25:04 <mpeter> i mean natively
08:25:30 <SamB_XP_> or if you meant those known to humans, we don't have time!
08:25:31 <PeakerWork> Is there a "standard" way to do error "conditions" with ContT or such?  Handle errors _inside_ the context in which they occur, rather than unwind everything?
08:25:34 <pejo> SamB, most Haskell programs were also O'Haskell programs I think.
08:26:03 <SamB_XP_> pejo: okay, so that covers the "extension" bit
08:26:35 <SamB_XP_> most extensions have that property -- generally you just need to do a bit of munging to deal with the new keywords and whatnot
08:26:41 <mmorrow> Peaker: you can have nest callCCs, but you'd have to implement what you have in mind on top of this (somehow)
08:26:55 <pejo> SamB, I'm not sure why things don't make it into GHC. It definitely depends on someone implementing it for starters, and even if implemented it might not make it into GHC.
08:27:39 <pejo> SamB, but having hung in this channel for a couple of years I think people in general don't like the idea of subtyping here. Atleast there are some very vocal opponents of it.
08:28:15 <SamB_XP_> well, that sounds more controversial than conservative, doesn't it ?
08:28:29 <mmorrow> looks like timber has an incremental gc
08:28:42 <mpeter> we need to start building AI programs that can translate between programming languages
08:28:46 <mmorrow> (i guess that's necessary for realtime code)
08:28:47 <mpeter> true disassemblers
08:28:56 <mpeter> then we will have something interesting
08:29:21 <SamB_XP_> mpeter: how are we going to get AIs to do it if we can't do it ourselves ?
08:29:30 <mpeter> you can't do it yourself?
08:29:32 <mgdtgd_> mpeter: that's what compilers do. they translate from language X to machine language
08:29:38 <mpeter> no, mgd
08:29:42 <SamB_XP_> mpeter: well, it's hard!
08:29:46 <mpeter> translate from machine languae to language x
08:29:49 <asgaroth> mgdtgd_: Well the other way around is much harder
08:29:57 <mpeter> yup
08:30:03 <mpeter> but it's np-complete
08:30:04 <mgdtgd_> only if it needs to be efficient
08:30:19 <mmorrow> mpeter: somewhat related that i think is cool is how vmware translates (kernel-mode) machine code on the fly
08:30:28 <mpeter> that's just HLE
08:30:30 <SamB_XP_> asgaroth: especially if you try to write ABI-compatible code in language Y ;-P
08:30:31 <mgdtgd_> you could just write a CPU emulator in language Y
08:30:32 <asgaroth> I have yet to see, fore example a working C-decompiler that works for more than just simple test apps.
08:30:37 <mpeter> which is a great little technique, i'll admit
08:30:39 <asgaroth> *for
08:30:52 <pejo> SamB, the conservative was wrt the extension. A non-conservative extension would break existing things, I imagine.
08:31:11 <SamB_XP_> asgaroth: why, it's hard enough to write ABI-compatible code for language X
08:31:43 <asgaroth> SamB_XP_: Yes, that'd be hard enough as well.
08:31:45 * SamB_XP_ has a languishing project to do that for ZZT, since it's source has been lost
08:32:14 <asgaroth> Although mere disassemblers like IDA are already quite sophisticated and produce quite usable output for certain purposes
08:32:20 <SamB_XP_> it would be easier if Pascal didn't have so many overloaded primitives!
08:32:21 <solrize_> decompilation sounds undecidable
08:32:24 <pejo> SamB, I was just guessing why things don't make it into GHC, there are people around here who far more qualified to answer that question.
08:32:38 <mmorrow> mpeter: but vmware isn't emulating the hardware, it's translating on the fly just the parts necessary for them to work in non-kernelmode and running that directly on the cpu
08:32:50 <mgdtgd_> solrize_: why?
08:32:52 <SamB_XP_> pejo: well, I think you made it clear that it's in fact NOT conservative, but controversial ;-P
08:32:56 <mpeter> i know, mmorrow
08:32:58 <mpeter> that's what HLE is
08:33:21 <mmorrow> mpeter: i guessed that stood for Hardware Layer Emulation
08:33:23 <mmorrow> ?
08:33:28 <mpeter> don't you remember when ultraHLE came out and everybody went "oh, this way to make emulators actually makes sense! too bad we didn't think of it over the entire course of human history"
08:33:34 <solrize_> there's no way to know if machine code is well-typed
08:33:39 <pejo> SamB, this isn't going anywhere, is it?
08:33:44 * mmorrow does not :)
08:33:54 <solrize_> ultrahle?
08:34:02 <mpeter> it was an n64 emulator
08:34:02 <SamB_XP_> well, it helps that it's basically suicidal to attempt to write x86 code that depends on hardware details ;-)
08:34:07 <mpeter> back in year 2000 or so
08:34:08 <mgdtgd_> solrize_: you should still be able to translate it
08:34:11 <SamB_XP_> HLE is High Level Emulation
08:34:18 <mmorrow> so i don't see how on-the-fly translation of machine code is "emulation"
08:34:18 <SamB_XP_> and I don't think vmware does it
08:34:29 <mpeter> Co-authors Epsilon and RealityMan realized that since N64 games were programmed in C code, that instead of intercepting machine level operations, they could concentrate on intercepting (the far fewer) C library calls, and write their own code to implement the libraries. Thus UltraHLE software is in fact an emulator with some parts implemented as a simulation. The HLE approach is therefore not true 100% emulation, and the technique i
08:34:37 <SamB_XP_> it does dynamic translation, or "recompilation" as the emulator devs call it
08:34:41 <mpeter> there you go
08:35:04 <solrize_> mpeter that sounds like WINE ?
08:35:11 <mpeter> it is like WINE
08:35:16 <SamB_XP_> there is no "x86 kernel library" like the N64 library that nintendo provided ...
08:35:16 <mmorrow> vmware doesn't reimplement anything, the run the translated (to be controllable) code /as-is/
08:35:25 <mmorrow> on the metal
08:35:38 <mpeter> good
08:35:42 <SamB_XP_> and there is no kernel-provided microcode that can be detected and emulated at a high level
08:35:47 <mpeter> that's the sensible way to do it
08:35:59 <mmorrow> totally
08:36:08 <SamB_XP_> so it's not actually HLE
08:36:23 * mpeter is losing track of who's talking
08:36:35 <SamB_XP_> I've seen N64 emulators going through and finding where different library routines were in the ROM ..
08:37:09 <SamB_XP_> oh, some C64 emulators offer HLE as well, coincidentally enough ;-)
08:38:32 <SamB_XP_> (some also offer LLE of the disk drives ... where the disk drive CPU gets emulated ... do they offer sound output for the disk drives ???)
08:39:49 <mpeter> well, i can't speak for all systems, but i doubt most of them are capable of reading sound like that
08:39:54 <p_l> SamB_XP_: Without emulating the drive at very low level, you can't play harddrive racing
08:40:12 <SamB_XP_> I don't think the C64 had hard drives ???
08:40:26 <SamB_XP_> but yes, that's some low level ;-P
08:40:37 <SamB_XP_> mpeter: reading ?
08:40:42 <mpeter> reading
08:40:48 <mpeter> as opposed to generated or loading
08:41:08 <mpeter> generating*, i remember only the dreamcast and up being capable of playing normal audio CDs
08:41:12 <SamB_XP_> um, the C64 disk drive sound output would be a simulation of the disk drive noise
08:41:19 <p_l> SamB_XP_: C64 not really, Atari on the other hand had an extensible bus and loadable device drivers in OS, so there were things like HDDs :)
08:41:22 <mpeter> oh, i see
08:41:31 <SamB_XP_> since apparantly some software used this intentionally
08:41:34 <mpeter> you could just open that in a mp3 player couldn't you ;)
08:42:15 <SamB_XP_> p_l: well, there's no reason why you couldn't have a C64 hard drive
08:42:24 <SamB_XP_> it's just I've never heard of one actually existing
08:42:49 <SamB_XP_> the DOSes ran on the disk drives -- where they belong -- in those days, you know!
08:43:10 <Megzlna> Why doesn't...
08:43:18 <Megzlna> f xs = sum . takewhile (>0) . filter even . (map (*2) xs)
08:43:20 <Megzlna> work?
08:43:24 <Megzlna> you have to do:
08:43:24 <SamB_XP_> and they didn't have those fancy facilities for running programs and so forth ;-)
08:43:24 <p_l> SamB_XP_: Yes, but it was not as easy as on Atari (it had quite impressive architecture for its class)
08:43:35 <Megzlna> f xs = (sum . takewhile (>0) . filter even . map (*2)) xs
08:43:58 <SamB_XP_> so a hard disk would have been easy enough -- just write a DOS to handle it ;-)
08:44:28 <orbitz> Megzlna: why have the xs?
08:44:39 <Megzlna> orbitz: Monomorphism restriction
08:44:41 <orbitz> f = sum . takewhile (>0) . filter even . map (*2)
08:44:48 <orbitz> Megzlna: what?
08:44:50 <SamB_XP_> and load the DOS on the disk, and make sure that the commands to load new code into the disk drive are different from the ones for floppy drives, or something ;-)
08:44:50 <Megzlna> orbitz: That doesn't work.
08:44:58 <Megzlna> watch:
08:45:07 <Megzlna> do :t on it
08:45:11 <Megzlna> in your GHCI
08:45:14 <orbitz> > let f = sum . takewhile (>0) . filter even . map (*2) in f [1, 2, 3]
08:45:16 <lambdabot>   Not in scope: `takewhile'
08:45:20 <p_l> SamB_XP_: In case of Atari, you'd write two modules - a device driver and a DOS (which was more of a filesystem driver + CLI)
08:45:25 <orbitz> > let f = sum . takeWhile (>0) . filter even . map (*2) in f [1, 2, 3]
08:45:26 <Megzlna> Orbitz: The BOT uses language extensions
08:45:27 <lambdabot>   12
08:45:33 <Megzlna> NoMonomorphismRestriction
08:45:39 <mpeter> remember when people were seriously worried about floppy disk viruses?
08:46:01 <SamB_XP_> p_l: well, the DOS on the C64 would take disk commands from the main system over some sort of serial bus ...
08:46:08 <orbitz> Megzlna: what is the restriction?
08:46:08 <SamB_XP_> well, mostly serial bus
08:46:19 <SamB_XP_> it might have done 8-bits at a time or something ...
08:46:22 <Megzlna> orbitz: The types will default because it thinks it's a constant
08:46:35 <vijay4114> orbitz and megzlna: why the filter??
08:46:44 <orbitz> Megzlna: thinks what's a constant?
08:46:52 <SamB_XP_> p_l: you wouldn't even NEED any code for the main system to let the hard disk work
08:46:56 <p_l> SamB_XP_: The difference on Atari was that you could connect directly to main bus
08:47:01 <SamB_XP_> of course, the C64 didn't have directories ...
08:47:07 <Megzlna> Orbitz: Haskell thinks that the 'f' is a constant and so it removes all 'a' and reduces it to ie, Int
08:47:15 <Megzlna> try this in your GHCI,
08:47:17 <orbitz> Megzlna: uhh no
08:47:29 <orbitz> let f = sum . takeWhile (>0) . filter even . map (*2), f :: [Integer] -> Integer
08:47:32 <Megzlna> "let f = (+) 1"
08:47:44 <Megzlna> :t f
08:47:45 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
08:48:01 <orbitz> Megzlna: i htin you wan tlet f = (+1)
08:48:16 <Megzlna> it's the same.
08:48:22 <orbitz> Megzlna: let f = (+) 1 still gives me Integer -> Integer
08:48:22 <orbitz> not a constant
08:48:32 <Megzlna> And that is incorrect results.
08:48:43 <orbitz> why is it incorrect?
08:48:50 <Megzlna> Because 1 is not an Integer
08:48:52 <Megzlna> :t 1
08:48:53 <lambdabot> forall t. (Num t) => t
08:49:14 <SamB_XP_> Megant: -XNoMonomorhpismRestriction ?
08:49:17 <SamB_XP_> er. Megzlna
08:49:19 <Megzlna> SamB_XP: Yes
08:49:27 <Megzlna> so let's now see what it does on the bot
08:49:27 <vixey> lambdabot needs -XNoMonomorhpismRestriction
08:49:34 <vixey> Someone should enable it ......
08:49:35 <Megzlna> @let fff = (+) 1
08:49:36 <lambdabot>  Defined.
08:49:39 <Megzlna> :t fff
08:49:40 <lambdabot> forall t. (Num t) => t -> t
08:49:46 <Megzlna> The bot behaves properly, because it uses that fix.
08:49:53 <vixey> @let lambdabotNeedsMonomorphism = fmap
08:49:54 <lambdabot>  <local>:3:29:
08:49:54 <lambdabot>      Ambiguous type variable `f' in the constraint:
08:49:54 <lambdabot>        `Fu...
08:49:58 <orbitz> :t (+)
08:50:00 <lambdabot> forall a. (Num a) => a -> a -> a
08:50:04 <Megzlna> <orbitz> f = sum . takewhile (>0) . filter even . map (*2)
08:50:08 <mpeter> > "blah blah blah blah" !! 8
08:50:10 <lambdabot>   'h'
08:50:14 <SamB_XP_> Megzlna: the language specification is wierd -- what do you want from us ?
08:50:20 <Megzlna> ^--- so dont do that or your code will break unless you use the language extension
08:50:32 <orbitz> Megzlna: what if i give it a type signature...
08:50:38 <Saizan> @tell Cale should we put {-# LANGUAGE NoMonomorphismRestriction #-} in L.hs ?
08:50:38 <lambdabot> Consider it noted.
08:50:40 <vixey> SamB_XP: Well I didn't know this
08:50:41 <SamB_XP_> orbitz: oh, sure
08:50:43 <vixey> SamB_XP++
08:50:51 <SamB_XP_> I guessed at the name
08:51:12 <SamB_XP_> Saizan: would that help?
08:51:16 <orbitz> so i don't need the extension, except if i waht type inference?
08:51:23 <Saizan> SamB_XP_: for @let it would
08:51:44 <Megzlna> orbitz: Yea
08:51:44 <SamB_XP_> orbitz: you could also use explicit arguments, but yes
08:51:45 <Saizan> SamB_XP_: the code is just pasted at the end of L.hs and compiled
08:51:48 <quicksilver> it always has the monomorphism restriction turned off.
08:51:58 <quicksilver> as Megzlna just demonstrated.
08:52:01 <SamB_XP_> hmm, point
08:52:05 <quicksilver> what is everyone talking about? :P
08:52:09 <vixey> @let lambdabotNeedsMonomorphism = fmap
08:52:10 <lambdabot>  <local>:3:29:
08:52:10 <lambdabot>      Ambiguous type variable `f' in the constraint:
08:52:10 <lambdabot>        `Fu...
08:52:11 <vixey> ^^^^^^^
08:52:30 <SamB_XP_> ah, but the other file needs it!
08:52:31 <vixey> @let haskellNumbersSuck = 8
08:52:32 <lambdabot>  Defined.
08:52:33 <mpeter> > maximum "blah blah blah blah"
08:52:33 <mmorrow> there're some interesting looking papers here http://timber-lang.org/index_pubs.html
08:52:34 <lambdabot>   'l'
08:52:36 <vixey> :t haskellNumbersSuck
08:52:38 <lambdabot> forall t. (Num t) => t
08:52:41 <vixey> ^^^^^^^ wtf
08:52:48 <SamB_XP_> oh ... kay!
08:52:49 <mmorrow> http://www.ittc.ku.edu/~andygill/papers/RecBinds.pdf
08:52:58 <quicksilver> bug in the way @let is executed, I think.
08:53:02 <vixey> monomorphism _except_ in numbers??
08:53:06 <quicksilver> :t and > have monomorphism turned off.
08:53:07 <lambdabot> parse error (possibly incorrect indentation)
08:53:15 <vixey> I thought the whole point of moronmorphism was about numbers
08:53:15 <quicksilver> but the output to @let doesn't, maybe.
08:53:24 <Megzlna> No, the bot has the NoMonomorphismRestriction enabled already
08:53:29 <Megzlna> That's how numbers should be
08:53:33 <vixey> Megzlan, how doesn't fmap work then?
08:53:34 <SamB_XP_> it's confusing me now
08:53:36 <vixey> @let lambdabotNeedsMonomorphism = fmap
08:53:36 <lambdabot>  <local>:4:29:
08:53:37 <lambdabot>      Ambiguous type variable `f' in the constraint:
08:53:37 <lambdabot>        `Fu...
08:53:37 <Saizan> yeah, @let just calls ghci, probably without passing any flag
08:53:39 <vixey> Megzlan, ^^^^
08:53:45 <mmorrow> , let f = fromIntegral in (f (42::Int), f (42::Integer)) :: (Double,Double)
08:53:51 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
08:53:53 <quicksilver> > (fff (1::Int),fff (1.0::Double))
08:53:54 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
08:53:59 <Saizan> so i think a pragma in L.hs itself is the best place to for this
08:54:00 <SamB_XP_> do we have minutes showing just WHO started us on this slippery monomorphism slope ?
08:54:07 <quicksilver> hmm. it's off for ":t"
08:54:09 <SamB_XP_> I'd like to send him some shit
08:54:16 <mmorrow> grr, i thought i turned it off in lunabot
08:54:17 <quicksilver> but looks like it might be on for ">"
08:54:28 <mpeter> > take 1242 [22,44..]
08:54:29 <lambdabot>   [22,44,66,88,110,132,154,176,198,220,242,264,286,308,330,352,374,396,418,44...
08:54:37 <mmorrow> maybe i actually turned it /on/ with the option i thought was turning it off
08:54:47 <quicksilver> > let f = (+1) in (f (1::Int),f (1::Double))
08:54:48 <lambdabot>   Couldn't match expected type `Int' against inferred type `Double'
08:54:57 <Megzlna> vixey: Because 'b' depends on f
08:55:00 <quicksilver> :t let f = (+1) in (f (1::Int),f (1::Double)) in f
08:55:01 <lambdabot> parse error on input `in'
08:55:05 <Megzlna> :t fmap
08:55:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:55:11 <quicksilver> :t let f = (+1) in (f (1::Int),f (1::Double))
08:55:12 <lambdabot> (Int, Double)
08:55:16 <quicksilver> yup.
08:55:25 <quicksilver> DMR is off for :t, on for >
08:55:26 <SamB_XP_> oh, so @let works with things that can be defaulted, but then they end up having the non-monomorphic type?
08:55:35 <vixey> O_o
08:55:43 <mmorrow> i figured this would turn it /off/: Opt_MonomorphismRestriction
08:55:43 <SamB_XP_> that would explain it ;-)
08:55:55 <quicksilver> for @let, the checking it tries to do has DMR off, but the actual addition to L.hs has DMR off as seen by :t
08:55:55 <mmorrow> (since there is no "Opt_NoMonomorphismRestriction")
08:56:09 <quicksilver> all very silly
08:56:20 <quicksilver> @tell Cale lambdabot has a confusing inconsistent DMR situation.
08:56:21 <lambdabot> Consider it noted.
08:56:41 <pejo> mmorrow, Haskell already has the recursive bindings stuff, and more. (Since it's lazy)(
08:56:52 <SamB_XP_> what does this have to do with Dennis Ritchie ?
08:57:08 <tibbe> @src join
08:57:08 <lambdabot> join x =  x >>= id
08:57:18 <tibbe> :t join
08:57:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:57:20 <mmorrow> pejo: totally, but that paper (i haven't read it yet) looks to extend lazy techniques to strict languages
08:57:25 <quicksilver> http://jonex.info/dump/yolisp.jpg
08:57:43 <mmorrow> (to the extent that they don't actually require laziness)
08:58:32 <Adamant> quicksilver: you need to balance your parens
08:59:16 <Adamant> not really, but it's fun to make people count parentheses
08:59:33 <pejo> mmorrow, yes, it's very nice in that sense. :-)
08:59:47 <mmorrow> pejo: it looks interesting :)
09:00:52 <Megzlna> so... why is this malformed?
09:01:00 <Megzlna> > f xs = sum . takewhile (>0) . filter odd . (map (*3) xs)
09:01:02 <lambdabot>   <no location info>: parse error on input `='
09:01:09 <Megzlna> > let f xs = sum . takewhile (>0) . filter odd . (map (*3) xs) in f [1,2,3]
09:01:10 <lambdabot>   Not in scope: `takewhile'
09:01:16 <Megzlna> > let f xs = sum . takeWhile (>0) . filter odd . (map (*3) xs) in f [1,2,3]
09:01:17 <lambdabot>   Couldn't match expected type `a -> [a1]'
09:01:20 <mmorrow> camelCase!!
09:01:29 <Megzlna> I hate camelcase damnit
09:01:33 <mmorrow> heh
09:01:37 <vixey> noYouDon't
09:01:49 <orbitz> how_about_under_scores?
09:02:03 <SamB_XP_> Megzlna: you could turn on the glasses minor mode, then
09:02:13 <Megzlna> SamB_XP_: wozzat?
09:02:22 <SamB_XP_> Megzlna: in emacs
09:02:26 <Megzlna> ah
09:02:39 <SamB_XP_> it is designed specifically for studly-cased identifiers
09:02:45 <vixey> I've seen haskell by stubbons which is l ike    foo_bar_baz concatMap . filter notNull my_list
09:03:01 <vixey> it's so awful to read
09:03:04 <SamB_XP_> stubborns you mean ?
09:03:08 <vixey> yes
09:03:33 <mmorrow> http://pure.ltu.se/ws/fbspretrieve/901432
09:03:38 * orbitz for some reason thinks Megzlna has a problem with emacs
09:03:43 <SamB_XP_> foo_ should be used very sparingly
09:03:43 <mmorrow> " A Correct and Useful Incremental Copying Garbage Collector"
09:03:46 <SamB_XP_> if ever
09:03:52 <mpeter> > map (+1) ones
09:03:53 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
09:04:14 <Megzlna> My problem with emacs is actually that when you, for instance hover over parens, you can feel a 400ms delay before the other paren highlights
09:04:16 <mmorrow> vixey: "stubborns" lol
09:04:26 <Megzlna> It's so high latency
09:04:52 <SamB_XP_> Megzlna: sometimes I have to delete the paren and type it again ;-)
09:05:01 <mmorrow> @remember vixey I've seen haskell by stubborns which is like foo_bar_baz concatMap . filter notNull my_list. it's so awful to read
09:05:01 <lambdabot> It is forever etched in my memory.
09:05:02 <SamB_XP_> usually when the other paren is too far away, though
09:05:54 <SamB_XP_> Megzlna: what size file? is there perhaps a setting for that?
09:06:06 <vegai> Megzlna: here'se a nickel, buy yourself a better computer
09:06:29 <mpeter> > foldr (+) 0 (take 200 (map (+1) ones))
09:06:30 <lambdabot>   400
09:06:37 * mmorrow needs a new car, asks for a quarter
09:06:50 <mpeter> > fix (foldr (+) 0 (take 200 (map (+1) ones)):)
09:06:50 <lambdabot>   [400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,40...
09:06:51 <Megzlna> It's not computer speed -- emacs is just slow
09:07:02 <SamB_XP_> oh, you might try getting yourself a real OS too ;-P
09:07:13 <mpeter> psh
09:07:15 <mpeter> paying for computers
09:07:16 <SamB_XP_> and were you using a native build or an X build?
09:07:19 <mpeter> you guys are way in the last century
09:07:26 <SamB_XP_> yeah, get computers from uncles geese
09:07:43 <Megzlna> SamB_XP_: EmacsW32
09:07:44 <vixey> mpeter, what are you talking about
09:07:49 <mpeter> > fix (foldr (+) 0 (take 200 (map (+1) [1..200])):)
09:07:50 <lambdabot>   [20300,20300,20300,20300,20300,20300,20300,20300,20300,20300,20300,20300,20...
09:08:08 <mpeter> vixey: i get my computers free
09:08:15 <mpeter> by whatever means necessary, short of burglary
09:08:16 <SamB_XP_> Megzlna: well, I dunno what's a good text editor for windows
09:08:28 <vixey> mpeter, what ??
09:08:36 <mpeter> megzlna: try jedit and notepad++
09:08:44 <Megzlna> I use np++, and it can't fold Haskell
09:08:57 <Megzlna> e-editor almost perfect, except it can't do basic editing.
09:08:59 <vixey> code folding .. ugh!
09:09:03 <Megzlna> Like delete a line.
09:09:08 <vixey> just write shorter programs :P
09:09:15 <Megzlna> vixey: No I have a good reason for folding.
09:09:22 <vixey> I'm actually seriously
09:09:24 <mmorrow> origami?
09:09:27 <vixey> not joking thats good advice
09:09:27 <SamB_XP_> I know a number of microsofties used to like Emacs -- but they probably picked that up from before they finished bootstrapping NT
09:09:39 <vixey> lol
09:09:40 <Megzlna> Here's why I use folding
09:10:07 <SamB_XP_> folding is good
09:10:26 <SamB_XP_> but ... not that stuff with the [+]/[-] in Haskell
09:10:49 <mpeter> you mean collapsing the function?
09:10:58 <mpeter> i like having the ability to do that
09:11:02 <mpeter> but i rarely find myself using it
09:11:08 <SamB_XP_> (unless you want to do it based on large sections denoted by special markup in the comments?)
09:11:27 <SamB_XP_> (you could just use two panes, though, that might be simpler ;-)
09:11:51 <xenoblitz> Megzlna: try eclipse with fp support... I think it does allow it... not sure 100% though
09:12:11 <Megzlna> Vixey: http://img179.imageshack.us/img179/2205/c111oy0.png
09:12:32 <Megzlna> making a Haskell one of these atm
09:13:10 <vixey> cool
09:13:11 <p_l> SamB_XP_: There's a reason why Visual Studio includes Emacs keybindings
09:13:32 <p_l> SamB_XP_: And why a lot of donations that go through Vim project are from MS
09:14:14 <SamB_XP_> nearly the entire NT team got hooked on vi and emacs before they got it bootstrapped?
09:14:31 <SamB_XP_> and some of them went on to be the VC/VS team ?
09:15:15 <p_l> SamB_XP_: More like a lot of them still use it... there's a lot of "unreleased" stuff in core teams at MS
09:15:54 <SamB_XP_> p_l: I meant that many of them probably got hooked at that time ?
09:15:59 <xenoblitz> Megzlna: yes i just checked for you eclipse with fp does allow collapsing
09:16:00 <SamB_XP_> not that they aren't still hooked
09:16:21 <SamB_XP_> and of course I guess they've passed it on
09:16:36 <xenoblitz> Megzlna: or folding ;)
09:16:54 <SamB_XP_> but seriously, foldr is much better
09:17:07 <p_l> SamB_XP_: I'd suspect they got hooked a lot earlier. Xeninx was widely used in MS during early 90s
09:17:11 <p_l> *Xenix
09:17:28 <SamB_XP_> oh, yeah, and that was theirs wasn't it ?
09:17:35 <mmorrow> Building timberc-1.0.2...
09:17:36 <p_l> NT was bootstrapped on a completely different machines that didn't run anything other than NT
09:17:44 <p_l> SamB_XP_: Yes, their port of Unix
09:17:57 <SamB_XP_> p_l: before it was boostrapped they were using Unix
09:19:01 <p_l> SamB_XP_: probably. There is no Unix though for the machines they ran NT on :D
09:19:19 <SamB_XP_> which is why they use ar(1) format for .libs, and why PE and .obj are based on COFF ...
09:20:34 <SamB_XP_> p_l: really ?
09:20:36 <vixey> mmorrow, that's interesting (about gc) looks like the mechanized the proofs
09:20:42 <vixey> they*
09:21:30 <Zao> http://blogs.msdn.com/larryosterman/archive/2005/06/24/432386.aspx
09:21:35 <p_l> SamB_XP_: They build their own architecture around IIRC Intel i860
09:22:02 <pejo> vixey, it's not mechanized (yet) afaik. There's work from Yale doing that though iirc.
09:22:03 <SamB_XP_> why did they do THAT ?
09:22:25 <Megzlna> cause of David Cutler and VMS
09:22:57 <SamB_XP_> about all I can say is that I've heard of the CPU series before
09:23:07 <SamB_XP_> I can't say I've heard of any computers that used it before
09:23:22 <mmorrow> vixey: cool. i haven't looked at it yet, but it's open and waiting for after i get timber built
09:23:24 <SamB_XP_> so ... did they sell any of those ?
09:23:29 <mmorrow> speak of the devil
09:23:31 <mmorrow> [m@ganon timberc-1.0.2]$ timberc --version
09:23:31 <mmorrow> The Timber compiler, version 1.0.2
09:23:40 <Megzlna> http://upload.wikimedia.org/wikipedia/commons/f/f2/DavidCutler_WindowsAzure.JPG
09:24:27 <SamB_XP_> a JPG has the answer?
09:24:32 <p_l> SamB_XP_: It was to ensure that NT would not be tied to x86
09:24:48 <SamB_XP_> okay, well I guess it did that
09:25:05 <SamB_XP_> but why didn't they just use an existing architecture ?
09:25:16 <SamB_XP_> like what they were bootstrappring from
09:25:29 <SamB_XP_> or mac or something
09:25:57 <xenoblitz> http://img155.imageshack.us/img155/2121/eclipsewithfpvb4.jpg
09:26:18 <p_l> SamB_XP_: They wanted a system that was completely different from what they had, so that all portability bugs would be squashed when they ported it to MIPS, PPC etc.
09:26:33 <SamB_XP_> p_l: ah
09:26:44 <SamB_XP_> p_l: I guess i860 was probably that ;-)
09:26:50 <Adamant> also the i860 was "the coming thing" at the time, IIRC
09:27:08 <SamB_XP_> you mean like itanic ?
09:27:12 <Megzlna> If you read the Windows 2000 source code, the man in the picture wrote the majority of the kernel
09:27:30 <p_l> Apparently when intel approached them about i386 support, they told them to go away with their puny cpu
09:27:31 <Adamant> SamB_XP_: it is very itanic before itanic, really
09:27:53 <Megzlna> the creator of NT
09:28:17 <SamB_XP_> Megzlna: but then I'd be tainted
09:28:25 <mmorrow> here's examples/TCPClient.t http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=569#a571
09:28:31 <SamB_XP_> (and probably wouldn't understand much of it anyway)
09:29:05 <mmorrow> the compiler only has a few deps too, which is sweet. easy build.
09:29:47 <p_l> SamB_XP_: The NT core is not that bad. It's the "outer shell" that gave them such a bad rep.
09:29:49 <Megzlna> The really low stuff you can understand, stuff like the context switching code, because you see why you're preserving EBX
09:30:06 <newsham> cutler wrote most of the NT code?
09:30:08 <SamB_XP_> p_l: I know the core isn't bad
09:30:20 <SamB_XP_> but kernel code is not generally an easy read
09:30:43 <p_l> newsham: More like he was the main architect behind the design
09:30:58 <SamB_XP_> the documentation format could use work, too...
09:30:58 <newsham> [07:21] < Megzlna> If you read the Windows 2000 source code, the man in the picture wrote the majority of the kernel
09:31:10 <mpeter> the man in what picture
09:31:17 <Adamant> nonsense, how can you architect without using design patterns?
09:31:18 <Megzlna> http://upload.wikimedia.org/wikipedia/commons/f/f2/DavidCutler_WindowsAzure.JPG
09:31:20 <chrisdone> maybe it's metaphorical
09:31:31 <chrisdone> like you "see" the code, you "see" his face
09:31:32 <mmorrow> EchoServer.t, EchoServer2.t http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=569#a572
09:31:44 <Adamant> they weren't invented yet, so he had to write all the code
09:31:45 <vegai> timber looks really nice
09:31:55 <Adamant> uphill in the snow both ways ten miles
09:31:56 <SamB_XP_> Adamant: silly thing
09:31:59 <Adamant> ;)
09:32:10 <SamB_XP_> Adamant: with wolverines strapped to your backs, I know, I know
09:32:19 <SamB_XP_> what you had to go through to hear a remix ...
09:32:31 <vegai> mmorrow: how does that work, though. The TCPClient example, for instance
09:32:35 <Adamant> SamB_XP_: ok, I won't mention the bear calvary pursuing the weak
09:32:43 <SamB_XP_> cavalry
09:32:48 <vegai> what connects the incoming messages to those actions?
09:32:52 <newsham> bizarro history lesson
09:33:00 <SamB_XP_> calvary is aka golgatha, is it not?
09:33:14 <Adamant> yeah, they had a burden to bear on their backs
09:33:17 <Adamant> long story
09:33:34 <chrisdone> â€˜and then cthulhu said to lord hitler, thou shalt not use bears with lasersâ€™
09:33:47 <Adamant> he didn't mention sharks
09:33:53 <chrisdone> that was his mistake
09:34:41 <chrisdone> unsafePerformRaiseCthulhuFromTheSea
09:34:59 <dolio> That might be reallyUnsafe.
09:35:38 <Adamant> unsafePerformTheMightyFistOfTheDesertGodWithNoVowelsInHisName
09:35:41 <mmorrow> vegai: hehe, i ran the EchoServer, and connected to it and communicated successfully with the TCPClient
09:35:43 <chrisdone> it's okay, I can't remember the obscure module name where it's defined
09:36:12 <gwern> @hoogle path
09:36:13 <lambdabot> Data.Graph path :: Graph -> Vertex -> Vertex -> Bool
09:36:13 <lambdabot> Test.HUnit.Base path :: State -> Path
09:36:13 <lambdabot> Test.HUnit.Base type Path = [Node]
09:36:23 <gwern> @seen jeffwheeler
09:36:23 <lambdabot> jeffwheeler is in #haskell. I don't know when jeffwheeler last spoke.
09:36:26 <vegai> mmorrow: I don't doubt it works, I just wonder how
09:36:43 <mpeter> @seen mpeter
09:36:44 <lambdabot> You are in #haskell-blah and #haskell. I last heard you speak just now.
09:36:50 <mpeter> :D!
09:36:51 <mmorrow> vegai: beats me :) (haven't really looked at it yet)
09:37:15 <mmorrow> vegai: i doubted it worked until it did (1/2 serious)
09:37:44 <gwern> offhand, does anyone know whether the haskell base libs provide a way to find the address of a given bianry?
09:37:53 <vegai> mmorrow: it looks like it's those installR calls
09:37:58 <gwern> ie 'foo "hoogle"' would turn into "/usr/bin/hoogle"
09:38:20 <vegai> and perhaps close actions are handled automatically
09:38:25 <mmorrow> dolio: have you checked out timber yet?
09:38:29 <pejo> vegai, there's a bunch of comments about the EchoServer: http://www.timber-lang.org/EchoServer_descr.html
09:38:35 <gwern> (currently it looks like I'm going to have to call which via the shell)
09:38:42 <dolio> mmorrow: Not really.
09:39:01 <mmorrow> vegai: yeah, looks like the "sock.inFile.installR echo"
09:39:15 <mmorrow> dolio: it's an easy build and pretty cool
09:39:24 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bzlib
09:39:26 <mmorrow> oops
09:39:29 <mmorrow> wrong link
09:39:37 <mmorrow> http://timber-lang.org/
09:39:39 <dolio> Yeah, I read about it. You don't need to link me. :)
09:40:02 <mmorrow> dolio: well fine then, maybe i won't.
09:40:05 <mmorrow> :)
09:40:20 <vegai> now I just need a vty-like library and I can write my dwarf fortress clone on that :P
09:40:58 <mmorrow> vegai: looks like it's got posix support, so maybe that won't be too hard (?)
09:41:09 <gwern> vegai: don't we have vty?
09:41:28 * gwern looks over at my yi editor. yep
09:41:39 <Megzlna> > scanr (:) [] [1,2,3,4,5]
09:41:40 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
09:41:50 <Megzlna> so.. the accumulator states are right to left?
09:41:57 <pejo> gwern, there isn't necessarily an absolute path to a binary in unix.
09:42:23 <Megzlna> I would expect the 'scan' accumulator states to be left to right in the list even though foldr is right to left.
09:42:37 <mmorrow> gwern: with timber
09:42:44 <gwern> pejo: I'm not asking for a total, perfect, function, but something which is slightly better tha nshelling out and calling which :)
09:43:13 <gwern> mmorrow: oh. nm. I thought the 'that' referred to the 'vty-like library' not timber
09:44:21 <pejo> gwern, System.Directory.findExecutable?
09:44:33 <mmorrow> dolio: are you thinking of uploading your mtl-cps to hackage?
09:45:07 <dolio> I wasn't, really, although I could, I suppose.
09:45:16 <mmorrow> dolio: you should. :)
09:45:20 <gwern> @hoogle findExecutable
09:45:21 <lambdabot> System.Directory findExecutable :: String -> IO (Maybe FilePath)
09:45:32 <gwern> hm. sig seems right
09:45:36 <dolio> I kind of thought there were enough alternative monad libraries.
09:45:44 * gwern was looking in the POSIX libraries
09:45:47 <mmorrow> dolio: i would replace my mtl lib with it outright
09:46:13 <Heffalump> what does it do?
09:46:13 <mmorrow> dolio: but how many of them increase performance significantly?
09:46:21 <vixey> why dont we just write everything in CPS?
09:46:31 <mmorrow> sounds good to me
09:46:33 <Heffalump> GHC is switching to compiling that way, I think.
09:46:36 <dolio> It's a pain?
09:46:52 <mmorrow> Heffalump: you mean with the Cmm and cps?
09:47:16 * mmorrow doesn't know particulars, but has seen various mention of that
09:47:29 <Heffalump> yes
09:47:42 <mpeter> heffalump: you should unban smerdyakov
09:47:44 <mmorrow> cool, yeah that looks interesting
09:47:45 <mpeter> he's all friendly and shit
09:47:48 <subw> I'm trying to install yi from cabal and it says "cabal: conflict: gtk-0.9.13 requires bytestring ==0.9.0.1 however bytestring-0.9.0.1 was excluded because yi-0.5.0.1 requires bytestring ==0.9.1.*". Does the current yi only work with the dev version of gtk2hs?
09:47:54 <Heffalump> mpeter: I was never in favour of banning him in the first place
09:48:00 --- mode: Heffalump set -o Heffalump
09:48:10 <mpeter> but chanserv was
09:48:14 <Heffalump> (and I wasn't deliberately sitting there with ops on, either; loads of people on here have ops privileges)
09:48:28 <SamB_XP_> I thought he'd been taken off the list by now
09:48:30 <Heffalump> someone else decided to ban him a long time ago
09:49:04 <SamB_XP_> he really doesn't seem to know when he's being annoying, FWIW
09:49:11 <mpeter> bans are like grudges
09:49:17 <mpeter> useless after about
09:49:20 <mpeter> an hour
09:49:28 <ddarius> mpeter: Why do you care?
09:49:29 <Heffalump> well, the behaviour that led to the ban went on for weeks
09:49:38 <mpeter> why wouldn't i?
09:49:45 <SamB_XP_> mpeter: this one should probably have expired after 1-2 years ...
09:49:45 <ddarius> Heffalump: It wasn't weeks.
09:49:59 <SamB_XP_> at most
09:50:07 <gwern> subw: dependencies are hard with yi; in your case, try installing with -fvty instead of with gtk
09:50:28 <SamB_XP_> I've almost forgotten why he was banned
09:50:38 <Heffalump> being aggressive to newbies, IIRC
09:50:39 <mattam> I don't think he's changed the least :)
09:50:46 <SamB_XP_> (I actually forgot once already ;-)
09:50:50 <SamB_XP_> mattam: me either
09:51:01 <vixey> who ?
09:51:06 <mpeter> so tell him, it's ok to be critical of people who want everything done for them
09:51:09 <SamB_XP_> mattam: but I don't think he meant any harm either
09:51:09 <mpeter> as long as you can guide them along
09:51:17 <gwern> @hoogle Failure
09:51:18 <lambdabot> Test.HUnit.Base failures :: Counts -> Int
09:51:18 <lambdabot> Test.HUnit.Base assertFailure :: String -> Assertion
09:51:18 <lambdabot> Test.HUnit.Lang assertFailure :: String -> Assertion
09:51:25 <gwern> @hoogle ExitFailure
09:51:25 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
09:51:25 <lambdabot> System.Exit exitFailure :: IO a
09:51:27 <SamB_XP_> he still doesn't seem to grasp why he was banned :-(
09:51:36 <vixey> SamB_XP, who?
09:51:41 <SamB_XP_> smerdyakov
09:51:52 <ddarius> SamB_XP_: He wasn't trying to be an ass, but that doesn't make it acceptable either.
09:51:57 <dolio> People don't generally get permanantly banned from #haskell based on a whim, with no talking to them beforehand.
09:51:57 <SamB_XP_> no
09:52:04 <SamB_XP_> there was talking
09:52:06 <mpeter> in war and peace, smerdyakov killed himself the minute it seemed he would take blame for his crimes
09:52:18 <vixey> SamB_XP: Why did everyone spontaneously start talking about that?
09:52:18 <mpeter> i mean, brother karamazov
09:52:19 <gwern> subw: incidentally, it's better to run yi from darcs anyway
09:52:32 <SamB_XP_> vixey: someone brought it up, duh
09:52:38 <vixey> oh
09:52:38 <mpeter> hey vixey
09:52:38 <pejo> Heffalump, did you find anything about simplifying the constraint systems you mentioned the other day?
09:52:39 <mattam> SamB_XP_: I don't think he means to do any harm either. He's just not conceeding anything :)
09:52:43 <mpeter> fancy seeing you here
09:52:48 <SamB_XP_> mattam: he probably can't
09:52:52 <SamB_XP_> can't see what he's done
09:53:17 <Heffalump> pejo: the simplex method has a pre-step that turns inequalities into equalities by introducing extra variables to take up the "slack" in the inequalities
09:53:21 <SamB_XP_> has he mentioned a desire to come back ?
09:53:29 <gwern> @hoogle runCommand
09:53:30 <lambdabot> System.Process runCommand :: String -> IO ProcessHandle
09:53:30 <Heffalump> which has given me some ideas to make progress with
09:53:53 <SamB_XP_> how long ago was he banned anyway ?
09:53:57 <Heffalump> at the very least I can turn them into equalities and do echelon-delta reduction
09:54:02 <Heffalump> SamB_XP_: about 4 years ago, IIRC
09:54:14 <SamB_XP_> I think 4 years is too long
09:54:21 <pejo> Heffalump, but simplex is still worst case exponential though, isn't it?
09:54:25 <mpeter> looks like...15 days
09:54:29 <pejo> Heffalump, and you were doing integer solutions?
09:54:32 <gwern> SamB_XP_: 4 more years! 4 more years!
09:54:36 <Heffalump> pejo: yes, but I'm just doing the pre-step, not the actual optimisation bit.
09:54:37 <subw> gwern: thanks, will try. have to update my ghc first though :D
09:54:45 <SamB_XP_> gwern: we can wait until he acts up again first
09:55:05 <Heffalump> as I said, I wanted him not to be banned in the first place, so I'm certainly happy with unbanning him
09:55:13 <vixey> mpeter, oh right, why are talking about channel bans
09:55:21 <vixey> also I think jdh got banned for no reason
09:55:23 <SamB_XP_> Heffalump: the channel compells you
09:55:27 <SamB_XP_> who is jdh?
09:55:34 <SamB_XP_> how long has he been banned ?
09:55:43 <vixey> SamB_XP: someone that wasn't even typing to the channel at the time
09:55:45 <roconnor> I find smerdyakov somewhat harsh on newbies in # coq
09:55:52 <pejo> SamB, John D Harrop?
09:55:55 <SamB_XP_> roconnor: yes, he is
09:56:00 <mmorrow> jdh got banned?
09:56:04 <mmorrow> heh
09:56:08 <vixey> I found him extremely helpful when I had beginner questions there ...
09:56:09 <roconnor> there are less newbies in # coq than in # haskell
09:56:17 <Heffalump> jdh is a bit of a twat, but he didn't do anything on here to get banned, it was just dons felt he ought to be kicked off all Haskell forums
09:56:18 <SamB_XP_> vixey: he's very harsh still
09:56:21 <ddarius> I don't really care one way or another, but I do understand why people had a problem, and I seriously doubt anything has changed, and finally, I only expect him to be worse with the current mixture of #haskell.
09:56:35 <SamB_XP_> ddarius: hmm
09:56:41 <roconnor> vixey: I suspect you have more stamina :)
09:56:45 <SamB_XP_> well, we'd have to be strict with him if he actually came
09:56:50 <Heffalump> As with Smerdyakov, I don't think jdh should be banned.
09:57:08 <SamB_XP_> was he banned for having a lousy connection ?
09:57:16 <ddarius> SamB_XP_: As you've said repeatedly, he doesn't really realize what he's doing wrong and people did talk to him several times beforehand.
09:57:19 <vixey> I think it was some reddit thing or something equally silly
09:57:26 <SamB_XP_> ddarius: I know
09:57:31 <Heffalump> who, jdh? It was after a haskell-cafe thread.
09:57:41 <SamB_XP_> ddarius: perhaps we'd need to draw up some clear guidelines for him
09:57:50 <mmorrow> was jdh banned without ever actually having come in here?
09:57:56 <vixey> mmorrow, no he was here
09:57:57 <Heffalump> no, he was on here at the time
09:58:01 <mmorrow> ah
09:58:13 <vixey> mmorrow, I just thought it weird he got kickbanned without having said anything
09:58:18 <SamB_XP_> people shouldn't be banned from #haskell for behaviour elsewhere
09:58:35 <chrisdone> if you haven't been ridiculed for being less than perfect by Smerdyakov, you haven't lived
09:58:50 <SamB_XP_> chrisdone: I have
09:59:09 <Olathe> I don't like associating with unpleasant people.
09:59:11 <SamB_XP_> we could also add something to the channel FAQ about Smerdyakov ...
09:59:17 <chrisdone> haha
09:59:24 <SamB_XP_> anyway do you really think he'd come ?
09:59:26 <mattam> ;p
09:59:43 <Olathe> If I can find out from somewhere I'm not that that's the case, that's a good thing.
10:00:01 <SamB_XP_> Olathe: what the ...?
10:00:01 <chrisdone> it's that issue where you have to put up with someone's bullshit because they're intelligent or knowledgable. what can you do?
10:00:07 <mmorrow> i'm not an op of course, but i think jdh should be unbanned so he can at least have the ability to come in here and show everyone he's not really how he seems to be (or not)
10:00:12 <mpeter> we can have a free society
10:00:12 <vixey> the ban list is huge ....
10:00:17 <mpeter> where everybody can do whatever they want
10:00:20 <mpeter> but no black people
10:00:26 <vixey> mmorrow, yeah
10:00:27 <SamB_XP_> mmorrow: do you think maybe he's figured out we don't have to put up with it by now ?
10:00:31 <ddarius> chrisdone: There are a lot of intelligent and knowledgable people in #haskell that don't put out bullshit.
10:00:49 <chrisdone> ddarius: indeed, that's why this is my favourite channel on freenode!
10:00:53 <mmorrow> SamB_XP_: we'll never know if we can't talk to him.
10:00:53 <mpeter> ddarius: name 5 of them
10:00:54 <SamB_XP_> I think maybe if we banned him sooner for smaller offenses, for shorter periods of time, maybe he'd learn what we don't like ?
10:01:06 <Actium> spouting bullshit is not an intelligent thing to do
10:01:08 <Olathe> Well, this can all be tested.
10:01:08 <vixey> what do we not like???
10:01:18 <SamB_XP_> Actium: it's not actually bullshit
10:01:20 <mpeter> maybe when you lock a kid in the cellar for 3 days, he forgets what his transgression was
10:01:23 <Olathe> Has banning people for short times worked very frequently ?
10:01:33 <SamB_XP_> it's just ... caustic
10:01:34 <chrisdone> Actium: no, not as in spoken bullshit, but their behaviour
10:01:44 <Olathe> Yeah, but that's just an adjective.
10:01:48 <ddarius> Cale, dons, Heffalump, Igloo, spj, JaffaCake, augustss, ndm, sjanssen
10:02:01 <SamB_XP_> mpeter: I've never heard of parents who do that
10:02:07 <SamB_XP_> usually it does not take 3 days to find a locksmith
10:02:08 <Megzlna> I got banned right away
10:02:11 <Olathe> It's alright to have an environment free of disruptive people.
10:02:15 <Heffalump> ddarius: hmm? Is that an ops list?
10:02:23 <SamB_XP_> hmm, Megzlna is behaving better than before ;-)
10:02:25 <mpeter> olathe: what's the disruption?
10:02:25 <Cale> ddarius: what?
10:02:25 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:02:32 <mpeter> isn't the ban disruptive?
10:02:33 <Olathe> So, if banning people for short periods works on that, go for it.
10:02:36 <ddarius> Heffalump: I'm pretty sure JaffaCake is not an op, nor ndm or augustss.
10:02:43 <Heffalump> nor spj
10:02:46 <Olathe> If not, try something else.
10:02:47 <Heffalump> (I just checked)
10:02:49 <chrisdone> Cale: we're talking about people in haskell who are both intelligent and nice :P
10:03:06 <Heffalump> "/msg chanserv access #haskell list" to find out, though perhaps you have to be an op to do that.
10:03:08 <dolio> mpeter: You're the only person who's cared since I've been here. So no, it isn't disruptive.
10:03:10 <Cale> ah
10:03:15 <SamB_XP_> chrisdone: I thought we were talking about people who have trouble with the concept of "don't bite the n00bs"
10:03:30 <mpeter> either that, dolio, or all the other people who care have been banned by now
10:03:32 <zachk> the younger generation spells it nub
10:03:33 <chrisdone> SamB_XP_: multiple conversations simultaneously!
10:03:45 <dolio> Uh huh. It's a conspiracy.
10:03:46 <SamB_XP_> zachk: we don't care what they say on SMS
10:03:46 <chrisdone> Network.IRC.Parallel
10:03:47 <roconnor> zachk: are you serious?
10:03:48 <SamB_XP_> or AIM
10:03:53 <zachk> whats sms
10:03:56 <roconnor> @type nub
10:03:57 <mpeter> now when did i say it was a conspiracy?
10:03:57 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:03:59 <SamB_XP_> we like to spell things at least approximately correctly
10:04:02 <SamB_XP_> zachk: TXT
10:04:04 <chrisdone> @activity
10:04:04 <lambdabot> 3*total 2*private 1*#haskell
10:04:09 <chrisdone> @users
10:04:10 <lambdabot> Maximum users seen in #haskell: 586, currently: 571 (97.4%), active: 22 (3.9%)
10:04:17 <SamB_XP_> zachk: you know, what cellphones are used for ?
10:04:19 <Olathe> Noobs remove redundant elements from lists these days.
10:04:33 <ddarius> SamB_XP_: It's not usually called SMS in America.
10:04:34 <roconnor> Olathe: *L*
10:04:36 <zachk> i use them to call people who never answer my calls
10:04:37 <chrisdone> aww, I love the definition of nub
10:04:40 <SamB_XP_> ddarius: it isn't ???
10:04:45 <chrisdone> I used it to generate a random list of unique values lazily
10:04:50 <SamB_XP_> ddarius: nobody told ME
10:04:55 <SamB_XP_> and I *live* here
10:05:00 <ddarius> SamB_XP_: I've only heard it from people in Europe and you.
10:05:10 <ddarius> SamB_XP_: Where do you live (roughly)?
10:05:13 <gwern> I hear SMS all the time in the US
10:05:14 <SamB_XP_> google calls it SMS too
10:05:25 <SamB_XP_> I also here text all the time, of course
10:05:39 <SamB_XP_> but that's more of a verb
10:05:40 <roconnor> my cell phone class it SMS as well, with it's  ... -- ...
10:05:51 <roconnor> morse code
10:05:59 <roconnor> s/class/calls
10:06:03 <ddarius> SamB_XP_: I'm not saying that that isn't it's name, people just don't seem to say that.  I don't even think any of the plans I've looked at used the term.
10:06:06 <SamB_XP_> what ???
10:06:41 <SamB_XP_> ddarius: well, this is a programmer channel; I expect people to know things like that and NTSC and PAL
10:07:03 <gwern> pish, how often do programmers watch tv anymore
10:07:07 <ddarius> SamB_XP_: Well, yes.  I did still know what SMS means.
10:07:13 <gwern> why should they know the difference between NTSC and PAL?
10:07:14 <ddarius> gwern: I don't, at all.
10:07:15 <zachk> i know ntsc and pal im just not all hep on cellphones i have 12.95 phone from walmart
10:07:16 <Olathe> What's TV ?
10:07:19 <SamB_XP_> gwern: NTSC and PAL are about videogames ;-P
10:07:22 <SamB_XP_> too
10:07:30 <gwern> SamB_XP_: computer games, you mean
10:07:32 <ddarius> You need to know what to set your emulator to.
10:07:38 <SamB_XP_> zachk: I have a $20 phone from somewhere
10:07:44 * gwern concedes the point to ddarius 
10:07:46 <SamB_XP_> gwern: no, consoles
10:07:52 <zachk> i cant afford text messaging
10:07:59 <zachk> so im not hip on the lingo
10:08:02 <SamB_XP_> I can
10:08:11 <Olathe> TVs take either NTSC or PAL formatted signals.
10:08:33 <SamB_XP_> it's only, what, .3*.25 for me
10:08:36 <Olathe> So, you can't use a game console for one kind of TV on the other kind.
10:08:38 <gwern> (there's a third standard too I thought)
10:08:39 <SamB_XP_> I think
10:08:44 <Olathe> There might be :)
10:08:54 <SamB_XP_> SECAM ?
10:09:10 <mmorrow> vixey: yeah, this gc paper looks great
10:09:16 <roconnor> pft, any tv that does SECAM can probably to PAL as well
10:09:26 * gwern sighs. I wish yi compiled faster, but I don't dare try to use it on -Onot
10:09:29 <roconnor> unless it was built 200 years ago
10:09:34 <SamB_XP_> and the PAL videogames tended to be slowed down to ~5/6 the speed of their NTSC counterparts
10:09:41 <SamB_XP_> roconnor: was a guess
10:09:50 <roconnor> :)
10:10:01 <roconnor> I was about to say the same :P
10:10:04 <SamB_XP_> they had TVs in 1908 ?
10:10:13 <SamB_XP_> er.
10:10:14 <roconnor> that was only 100 years ago
10:10:18 <SamB_XP_> *1808*
10:10:23 <gwern> SamB_XP_: sure, with onions for antennas
10:10:27 <SamB_XP_> hah
10:10:28 <gwern> 'cause that was the style at the time
10:10:35 <Olathe> Haven't you seen the Flintstones ?
10:10:37 <roconnor> :D
10:10:42 <zachk> they could broadcast electrical power back in the 1800's
10:10:57 <Olathe> How did they do that ?
10:10:57 <SamB_XP_> gwern: have you been reading early 8-bit pages ?
10:11:00 <Olathe> Microwaves ?
10:11:05 <Actium> flintstones stuff doesnt use electricity
10:11:12 <zachk> ask the us government who took most of the work of tesla
10:11:12 <SamB_XP_> they hadn't discarded Tesla's ideas
10:11:27 <gwern> SamB_XP_: 8-bit theater you mean? man, the onions bit comes from grandpa simpson
10:11:39 <gnuvince_> With haskell-mode in Emacs, is it possible to C-c C-l modules that import one another?  For example, A.hs exports some functions and B.hs imports them.  Right now, I can't C-c C-l B.hs, because ghci can't find the A module.  What can be done to resolve this issue?
10:11:41 <SamB_XP_> gwern: no, the "style at the time" bit
10:12:04 <SamB_XP_> zachk: I still think he should have thought more about the economics
10:12:23 <SamB_XP_> who would want to just give away power like that?
10:12:37 <gwern> SamB_XP_: I am pretty sure 'wearing an onion on my belt, because that was the style at the time' was all from simpsons
10:13:09 <gwern> SamB_XP_: who would want to just give away sewage systems or national defense or any non-excludable public good, for that matter?
10:13:13 <SamB_XP_> gwern: hmm, that made more sense then the old man who was using the "style at the time" phrase said in 8-bit
10:13:15 <Raevel> can i restrict the contents of a data type to certain instances?
10:13:27 <quicksilver> gnuvince_: yes, just :cd the ghci to the right directory.
10:13:34 <roconnor> Raevel: check out smart constructors
10:13:35 <SamB_XP_> gwern: well, sewage systems save us all from epidemics
10:13:35 <vixey> Raevel, it just happens
10:13:39 <roconnor> @wiki Smart_Constructors
10:13:40 <lambdabot> http://www.haskell.org/haskellwiki/Smart_Constructors
10:13:45 <quicksilver> Raevel: not in a useful way, no. Just restrict the functions that use it.
10:13:50 <vixey> Raevel, (if you don't stop it from, by putting type annotations everywhere)
10:13:53 <roconnor> damn it
10:13:57 <roconnor> @wiki Smart_constructors
10:13:57 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
10:13:58 <gnuvince_> quicksilver: it brings me back to ~/.cabal/
10:14:02 <SamB_XP_> also some water companies charge for (anticipated) sewer use!
10:14:11 <quicksilver> gnuvince_: :cd to/the/right/directory
10:14:15 <martin_joerg> @help
10:14:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:14:16 * roconnor wishes for a smart_@wiki
10:14:22 <martin_joerg> @list
10:14:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:14:26 <quicksilver> @go haskellwiki smart constructors
10:14:30 <SamB_XP_> gwern: power? not so much ...
10:14:30 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
10:14:30 <lambdabot> Title: Smart constructors - HaskellWiki
10:14:37 <quicksilver> roconnor: like that? ;)
10:14:40 <roconnor> :D
10:14:47 <SamB_XP_> gwern: also, how are we supposed to keep people from overusing power if they don't have to pay for it somehow ?
10:14:49 <gnuvince_> quicksilver: right.  But when I do C-c C-l, I see :cd ~/.cabal/ appear in GHCi and then the :load command
10:15:07 <quicksilver> gnuvince_: oh, this is a stupid bug in that version of haskell-mode
10:15:16 <gwern> SamB_XP_: how do we keep people from overusing sewage systems or roads?
10:15:18 <quicksilver> gnuvince_: create a dummy .cabal file at the root directory of your project.
10:15:37 <SamB_XP_> gwern: well, they have to get the sewage from somewhere
10:16:14 <SamB_XP_> also I don't think sewers have brownouts somehow ...
10:16:29 <quicksilver> or maybe they always do?
10:16:33 <SamB_XP_> heh
10:16:41 <zachk> i am personally quite tired of eating and defecating
10:16:46 <zachk> anyone else?
10:17:01 <SamB_XP_> gwern: as for roads ... we don't ?
10:18:23 <mpeter> zach: try uploading your consciousness
10:19:25 * gwern hums. yi is getting decent for haskell hacking. I like how it reindents stuff when you remove an arg
10:19:37 <vegai> indeed
10:19:56 <SamB_XP_> anyway, wouldn't tesla's system suffer the tragedy of the commons?
10:20:17 <Heffalump> where's the .msi?
10:20:18 <gwern> it's actually kind of cool - suppose you remove an argument from a function, normally that messes up your indentation if it has case or do expressions, but yi will reindent the expression inward or outward
10:20:29 <gwern> it's not perfect, but it gets it right most of the time
10:20:49 <SamB_XP_> I'm not quite sure what happens if you try to draw more power than is available in teslas system ...
10:21:29 <SamB_XP_> (did he actually test it?)
10:21:30 <ddarius> Some might find this entertaining: http://lambda-the-ultimate.org/node/295#comment-45595
10:21:57 <gwern> SamB_XP_: seriously, all these questions have been thought out in great depth. just google or wiki for 'nonexcludable public goods' and the economists willdrown you in discussion
10:22:56 <ddarius> SamB_XP_: No.  The (one?) system probably wouldn't work because Tesla misunderstood the results he was getting (for the reasonable reason of not knowing about the ionosphere.)
10:23:13 <SamB_XP_> I thought his system was terrestrial ?
10:23:22 <ddarius> SamB_XP_: That's what he thought.
10:23:39 <SamB_XP_> it woudn't have been ?
10:24:00 <ddarius> The results he was getting were reflections from the ionosphere, not standing waves in the Earth as he thought.
10:24:05 <SamB_XP_> oh
10:24:14 <SamB_XP_> heh
10:24:35 <SamB_XP_> and here I was thinking his system would actually work and had been either repressed or just lost on the wayside ...
10:24:57 <Adamant> ah, Tesla. the patron saint of laser rifles, plasma pistols, and other methods for handling ruffians in Power Armor.
10:25:16 <Gracenotes> SamB_XP_: isn't that what all who subscribe to Tesla's theories think?
10:25:17 <Olathe> The tragedy of the commons is a weird argument, I must say.
10:25:30 <Olathe> Not that people use it, but the argument itself.
10:25:52 <Fractal77> hello
10:25:55 <Olathe> Hello.
10:26:05 <Adamant> Olathe: if something is shared, and it is free and useful, it will be used up faster
10:26:12 <Olathe> Oh, sure.
10:26:12 <Adamant> not so weird
10:26:12 <SamB_XP_> how would teslas system have provided a non-rivaled good ?
10:26:19 <Olathe> But the conclusion is...
10:26:58 <SamB_XP_> or do I mean non-excludable
10:27:09 <Fractal77> I need some help with xmonad; I'm trying to make with work with multiple language : English & Hebrew
10:27:11 <SamB_XP_> I think wikipedia may need to brush up on the meaning of "respectively"
10:27:14 <ddarius> Adamant: That's not the tragedy of the commons.
10:27:28 <ddarius> Fractal77: There is an #xmonad channel.
10:27:28 <gwern> SamB_XP_: tragedy of commons is about non-excludable rivalrous goods
10:27:34 <Fractal77> ohh
10:27:38 <Fractal77> cheers
10:27:40 <Olathe> The idea is: you have something that people can to take advantage of, so they will do so badly, so we need to have people in control of it.
10:27:45 <SamB_XP_> gwern: ah, so I was right the first time
10:27:47 <Olathe> That's how I've heard it.
10:27:53 <gwern> for example, information is non-excludable, but it's also non-rivalrous so in general there's no tragedy of the commosn about information
10:27:55 <Olathe> Which is a weird argument put that way.
10:28:02 <gwern> since there's 'enough for everybody'
10:28:18 <Adamant> ddarius: sheep farmers share a common grazing area, nobody owns it, so they all have an incentive to use it to the max for their sheep before others do
10:28:25 <Olathe> Sure.
10:28:30 <SamB_XP_> Olathe: well, suppose you have a commons, where everyone in the village keep their sheep ...
10:28:32 <mpeter> unsure!
10:28:34 <Olathe> Right.
10:28:45 <SamB_XP_> okay, you take it from there ;-)
10:28:47 <Olathe> I can see the problems there.
10:28:48 <gwern> a grazing area is rivalrous - all the grass my sheep eat is gone forever
10:29:01 <SamB_XP_> gwern: you mean, until it grows back
10:29:03 <Olathe> The shepherds will supposedly have their sheep greedily ruin everything for everyone.
10:29:07 <Olathe> That's the argument.
10:29:08 <kig> nomads vs settlers, short-termers vs. long-termers
10:29:10 <Megzlna> Is there any possible way to "reflect" the parameters  'f . g . h $ xs'   so that I can do :t on each one?
10:29:21 <Olathe> And it concludes by saying that you need to have someone control it.
10:29:26 <Adamant> this destroys the value of the commons in the long term because you don't husband the grass so it will keep growing back
10:29:31 <SamB_XP_> Olathe: if they don't think about the good of the village
10:29:32 <SamB_XP_> yes
10:29:33 <gwern> SamB_XP_: a regenerating resource is still finite; but if you let your goats or sheep graze long enough, it may well not grow back
10:29:35 <Olathe> Sure.
10:29:35 <Adamant> so you end up with a mud pit
10:29:36 <Gracenotes> Olathe: or split it up
10:29:43 <Olathe> Right.
10:29:43 <SamB_XP_> maybe I should have said town
10:29:50 <Olathe> But the solution most people go for is government.
10:29:55 <gp> learnyouahaskell for great good is awesome
10:29:57 <SamB_XP_> gwern: sure
10:30:03 <SamB_XP_> I was just arguing about the "forever" bit
10:30:05 <Olathe> Which is, logically, strange.
10:30:06 <gwern> Gracenotes: but you can't split up a non-excludable resource, which is why those are the most troublesome ones
10:30:22 <Adamant> you need some kind of resource limiting agreement
10:30:26 <gp> I think I just understood a whole lot more of what category theory and functors are
10:30:28 <Olathe> Oh, sure.
10:30:31 <ddarius> Adamant: Yes.  The argument is not "how fast something is used", it's sustainable v. unsustainable, and everyone happy v. no one happy.
10:30:38 <Olathe> Some of those are good and make logical sense.
10:30:43 <SamB_XP_> yeah, tesla's plan would have provided a non-excludable rivalrous resource, as I understand it
10:30:45 <gwern> SamB_XP_: a blade of grass eaten is gone forever... that a new blade of grass *may* grow in the same place is not particularly important
10:30:54 <SamB_XP_> if it hadn't been for that pesky ionosphere
10:31:00 <Adamant> property can work, goverment can work
10:31:10 <Olathe> But giving some small group of people absolute control over it is illogical, given the premises.
10:31:23 <SamB_XP_> Olathe: no one said a small group should control it
10:31:27 <mpeter> yes, olathe
10:31:29 <Olathe> Some do.
10:31:29 <gp> so basically if I wante d a map over a Map id have: instance Functor Map String Int where fmap = map ?
10:31:33 <ddarius> SamB_XP_: I'd rather have the ionosphere and no free power than the other way around.
10:31:34 <gp> something oiek that
10:31:35 <mpeter> that's the basis for anarchy
10:31:39 <SamB_XP_> wewll, none of us said that
10:31:45 <Olathe> Oh, sure.
10:31:46 <SamB_XP_> ddarius: point!
10:31:54 <Olathe> There are lots of reasonable ways to do it, of course.
10:32:03 <SamB_XP_> ddarius: besides, I still don't think it was economically feasible
10:32:16 <rgr> noobQ - is it better to  always think of "hello" as a list of chars or as a String? When does oen thing of String as opposed to list of chars?
10:32:22 <SamB_XP_> "control" just means "don't let everyone just do whatever the heck they want", that's all
10:32:31 <Olathe> But the most common thing I see the argument from the commons used for is a justification for state control.
10:32:35 <mpeter> solar power is the only kind that makes any sense
10:32:43 <Olathe> Which, they might be right, but not using that argument.
10:32:45 <SamB_XP_> the whole town could probably agree that on a more optimal arrangement
10:32:45 <mpeter> matter can probably be generated easily from other matter
10:32:50 * gwern sighs. dammit cabal! warn me when I use a nonexistent flag like -fghc-api!
10:32:53 <mpeter> and at that point, world hunger is solved
10:32:55 <rgr> mpeter: lol.
10:33:13 <Adamant> the whole climate change stuff is a problem because nobody partitions atmosphere use somehow
10:33:16 <SamB_XP_> Olathe: the tragedy is just what happens if everyone just does their own thing
10:33:22 <SamB_XP_> Adamant: lol
10:33:25 <athos> good evening everyone!
10:33:25 <Olathe> Oh, I don't think people are like that.
10:33:26 <ddarius> rgr: A String is a list of characters.
10:33:28 <mpeter> adamant: what?
10:33:32 <rgr> ddarius: I know.
10:33:33 <mpeter> you mean like, giant panes of glass
10:33:36 <mpeter> stretching into the sky?
10:33:37 <Olathe> I think they care about whether their animals can sustainably eat.
10:33:38 <mapreduce> World hunger isn't something to solve, just to distribute.
10:33:41 <ddarius> rgr: It doesn't need to be an either/or thing.
10:33:43 <Olathe> So, they want to work together.
10:33:54 <rgr> I am asking if one should always think of it as so, or if there is a time one thinks of "String".
10:34:01 <athos> :t WorldHunger
10:34:02 <lambdabot> Not in scope: data constructor `WorldHunger'
10:34:03 <Olathe> The problem of the commons is important, and they want to solve it.
10:34:04 <mpeter> svat: what's mit like?
10:34:05 <athos> :(
10:34:06 <zachk> i have a solution to world hunger. kill ever last human on earth. fin
10:34:10 <zachk> every
10:34:18 <Olathe> I don't like your solutions.
10:34:19 <ddarius> rgr: A what is a "String" except a sequence of characters?
10:34:23 <mpeter> or we can turn our own bodies into food
10:34:27 <Adamant> funny how the people who suggest this never bother to go first.
10:34:33 <rgr> ddarius: err, this is what I am asking.
10:34:37 <gwern> zachk: sure, that'll solve *human* hunger. BUT WHAT ABOUT THE ANIMALS
10:34:38 <mpeter> hell, they put euthenized cats in cat food
10:34:47 <rgr> There is a String type.
10:34:55 <rgr> as opposed to [char]
10:34:58 <zachk> damn it well just use the entire nuclear stockpiles of usa and russia
10:35:02 <mpeter> world hunger is not an issue but for poor governmental management
10:35:04 <ski_> @src String
10:35:05 <lambdabot> type String = [Char]
10:35:07 <zachk> this will cause endless world peace
10:35:13 <Adamant> mpeter is correct
10:35:14 <mpeter> the free market adequately feeds everybody
10:35:15 <rgr> mpeter: who told you that nonsense
10:35:18 <Adamant> zachk: not true
10:35:23 <Olathe> rgr: Whichever makes it easier to think about things.
10:35:24 <ski_> rgr : `String' is just another name for `[Char]'
10:35:29 <Adamant> there will still be World War 4
10:35:30 <zachk> adamant: are you considering aliens?
10:35:36 <Olathe> rgr: It's both a list and a string at the same time.
10:35:41 <mpeter> when does world war 3 come
10:35:43 <Adamant> zachk: people will still have sticks and stones
10:35:51 <Adamant> Einstein predicted it
10:35:54 <mpeter> people will be dead after world war three
10:35:58 <mpeter> all of them
10:36:06 <Adamant> mpeter: depends on how you count
10:36:07 <SamB_XP_> Olathe: take a large enough population and people can act rather stupid
10:36:15 <zachk> or rather smart
10:36:15 <SamB_XP_> as Adamant pointed out
10:36:18 <Megzlna> A world with endless food, that'd be sick.. we'd end up like Eloi
10:36:26 <mpeter> we cannot survive a nuclear holocaust
10:36:28 <zachk> eloi?
10:36:29 <Olathe> Oh, they can, but I think that the evidence is gathered with states doing their thing.
10:36:35 <zaitcev> Very fat Eloi though
10:36:42 <gwern> hm. does anyone know why {-# OPTIONS -prof #-} doesn't work?
10:36:53 <Olathe> States allow the worst stupidities to happen, like wars and such.
10:36:54 <rgr> mpeter: it came. You maybe didn't notice it. Rest of the world, near enough, against Iraq and Afghanistan. The "I'm all right Jack" mentality means most people dont see it ... Other countries are guilty in their silence and secret prospering from the outcome.
10:37:12 <Olathe> Not that states are the worst thing in the world, but they don't help.
10:37:34 <mpeter> rgr: what?
10:37:39 <Adamant> SamB_XP_: am I a good example or a terrible warning
10:37:39 <SamB_XP_> this whole federal government thing is a pain
10:37:55 <SamB_XP_> Adamant: you mentioned the atmosphere ;-)
10:37:59 <mpeter> i qualify a world war as one that involves two competiting sets of alliances
10:38:06 <mpeter> competing*
10:38:09 <mpeter> such as the cold war
10:38:15 <Adamant> mpeter: we're on like World War 6 then
10:38:18 <SamB_XP_> mpeter: only two ?
10:38:23 <mpeter> more than 6, probably
10:38:27 <maltem> OT: Has Chalmers replaced FoCAL by ALG?
10:38:37 <skorpan> no, by CSALL
10:38:42 <Adamant> well, the first big modern kickoff was Seven Years War
10:38:44 <mpeter> individual sovereignty is the only legitimate sovereignty
10:38:47 <skorpan> "computer science - algorithms, logic and languages" or something like that
10:38:53 <mpeter> i can moderate my own actions
10:38:58 <mpeter> can i trust another man to do the same?
10:39:01 <skorpan> it's essentially the same program, with a different more fitting name
10:39:05 <zachk> i mean ban abortion and lets get back to fighting and dying use a draft and have endless war
10:39:10 <Olathe> There are ways of pushing him to.
10:39:23 <SamB_XP_> have you never heard of fealty ?
10:39:27 <maltem> skorpan: ah ok, that _is_ ALG :) what you last said is what I wanted to know
10:39:30 <mpeter> fealty is bullshit
10:39:38 <skorpan> maltem: what is ALG?
10:39:39 <SamB_XP_> it's a forgotten concept
10:39:44 <SamB_XP_> nobody has any these days, really
10:39:51 <mpeter> it's not 'forgotten'
10:39:56 <mpeter> it's implied in hierarchal corporate structures
10:40:03 <Olathe> I don't like fealty.
10:40:03 <maltem> skorpan: Computer Science â€“ Algorithms, Language and Logic (MPALG) -- from the entry requirements page
10:40:04 <mpeter> as well as hierarchal governmental structures
10:40:08 <SamB_XP_> I never swore no oath of fealty
10:40:10 <Adamant> SamB_XP_: nationalism has proven more successful in Darwinian competition
10:40:10 <SamB_XP_> to anyone
10:40:23 <mpeter> i screwed up the pledge of allegiance every time i recited it
10:40:26 <SamB_XP_> well, except Jesus Christ, I guess
10:40:27 <skorpan> maltem: okay... i don't quite see what the G in MPALG is for, but sure.
10:40:30 <zachk> yea
10:40:31 <mpeter> i pledge allegiance to pledge, etc
10:40:48 <skorpan> maltem: are you coming to chalmers or something?
10:40:56 <zachk> how about a human psyche that doesnt require a lord
10:40:57 <SamB_XP_> that's not a fealty oath
10:40:58 <maltem> skorpan: either the g in Algorithms, or the g in Logic, I guess
10:41:12 <Adamant> oh
10:41:15 <skorpan> or maybe just ALGorithms
10:41:18 <maltem> skorpan: no, I'm just vaguely considering it for my master
10:41:27 <mpeter> > map (\x->foldr (+) 0 x) (take 100 (fix [1..20]:))
10:41:28 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
10:41:34 <maltem> skorpan: vaguely because I'm first semester now
10:41:40 * mpeter backtracks
10:41:45 <Adamant> you mean fealty oaths for the people with funny gold and gem encrusted hats?
10:41:50 <Olathe> Heheh
10:41:58 <skorpan> maltem: cool, i'm currently taking my last two courses on MPALG and it's been hot. lots of wise FP people.
10:42:15 <SamB_XP_> Adamant: no, gold neckbands
10:42:25 <Raevel> i've been thinking about chalmers...
10:42:26 <Adamant> que?
10:42:27 <maltem> skorpan: yeah I can imagine how hot it is :)
10:42:29 <Adamant> gorget?
10:42:35 <Adamant> I don't think they make those in gold
10:42:48 <SamB_XP_> torqs
10:42:49 <mpeter> oh yeah
10:43:06 <mpeter> wait, why doesn't that work again
10:43:52 <Deewiant> ?ty (fix [1..20]:)
10:43:53 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `[a1]'
10:43:53 <lambdabot>     In the first argument of `fix', namely `[1 .. 20]'
10:43:53 <lambdabot>     In the first argument of `(:)', namely `fix ([1 .. 20])'
10:43:54 <Adamant> mpeter: modern steel-core bullets have no trouble penetrating the thin metal of that type of defensive covering
10:43:59 <Olathe> mpeter: There was some imaginitive possibility that seemed decent for effectively urging people not to act badly, let me look it up.
10:44:07 <mpeter> adamant: what?
10:44:23 <Adamant> mpeter: you wanted to know why gorgets don't work
10:44:38 <mpeter> > map (\x->foldr (+) 0 x) (take 100 (fix ([1..20]:)))
10:44:40 <lambdabot>   [210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,21...
10:44:45 <mpeter> there you go
10:45:15 <rgr> Out of curiosity, how many people (ahem) drop out of Haskell courses ......
10:45:19 <maltem> skorpan: since we're at it, will your thesis be FP-centric?
10:45:21 <Gracenotes> @src fix
10:45:21 <lambdabot> fix f = let x = f x in x
10:45:43 <SamB_XP_> rgr: well, probably not more than get signed up for them
10:45:51 <SamB_XP_> what is a Haskell course, anyway ?
10:45:55 <rgr> You could be right ...
10:45:59 <Olathe> mpeter: Ahh, I found it: http://en.wikipedia.org/wiki/Dispute_resolution_organization
10:45:59 <luite_> rgr: the number of people failing the funtional programming course (in haskell) at utrecht university seems to be quite high
10:46:05 <luite_> functional
10:46:11 <mpeter> that's because functional programming is really goddamn hard
10:46:13 <Olathe> Yeah, functional programming is quite a challenge.
10:46:18 <skorpan> maltem: currently it looks like i will be doing an industrial, probably non-FP, thesis, but i have gotten a few proposals from the FP people and i'm considering it
10:46:22 <mpeter> for morons
10:46:29 <mpeter> ;)\
10:46:35 <rgr> It does seem a challenge. More a change of mindset. I wonder why I am bothering - damn xmonad!
10:46:46 <Olathe> Yes, that's the main issue.
10:46:58 <Olathe> People can do it with a lot of effort, but it's like...why ?
10:47:04 <luite_> rgr: it takes a while to 'get' it, more than the length of a course, and it takes practice
10:47:06 <SamB_XP_> rgr: I like the difficulty of shooting myself in the foot
10:47:16 <SamB_XP_> without trying, that is
10:47:20 <mapreduce> It's harder to write programs that work than programs that don't.
10:47:21 <SamB_XP_> with trying it is really easy
10:47:28 <Olathe> Yeah.
10:47:40 <maltem> skorpan: I see, many people prefer to do their thesis in the industry
10:47:41 <Olathe> It helps you to organize code in nonfunctional languages, too.
10:47:46 <rgr> I was not pleasently surprised to find that for the first time ever cutting ans pastng config examples did nothing to open up the mystery of Haskell syntax. if anything I got more confused. And I've a good bit of experience. Still a challenge must be met!!! :-)
10:47:46 <mapreduce> It's hard to write FP programs that fail, then gradually improve them, I think.
10:47:57 <Olathe> Makes programming there easier, gives you tricks you wouldn't have thought of.
10:48:00 <SamB_XP_> mapreduce: why would you want to?
10:48:05 <mapreduce> Whereas standard OO is all about failure followed by incremental improvements.
10:48:09 <SamB_XP_> and actually it's not that hard
10:48:17 <SamB_XP_> you just use error a lot ;-P
10:48:18 <mapreduce> SamB_XP_: Because that's what the education system promotes.
10:48:22 <rgr> I never saw a maintainable C++ project yet.
10:48:26 <mapreduce> Dijkstra had a little moan about that.
10:48:42 <mpeter> the education system sucks
10:48:47 <mpeter> try learning to code on hallucinogens
10:48:47 <rgr> But then I freely admit to being biased and despising it. Ever since someone overwroite a + operator when dealing with column numbers in some editor code.
10:48:49 <mpeter> that's what i did
10:49:13 <SamB_XP_> yeah, the education system does suck
10:49:24 <Adamant> mpeter: did you get color matching brackets in Scheme?
10:49:25 <SamB_XP_> hmm, I'm supposed to be working on a paper on that topic
10:49:27 <SamB_XP_> due tomorrow
10:49:30 <roconnor> > [1] `mplus` [2]
10:49:32 <lambdabot>   [1,2]
10:49:35 <rgr> If it did you would say "the edukation system sux"
10:49:36 <SamB_XP_> still haven't started typing
10:49:36 <mpeter> did i? no
10:49:37 <roconnor> > [1] `mappend` [2]
10:49:38 <lambdabot>   [1,2]
10:49:44 <SamB_XP_> (only written stuff in a notebook)
10:49:46 <martin_joerg> > [1,2]
10:49:48 <lambdabot>   [1,2]
10:50:02 <martin_joerg> > map (+ 1) [1,2]
10:50:03 <lambdabot>   [2,3]
10:50:05 <mapreduce> > let a + b = (show a) ++ (show b) in 3 + 4
10:50:06 <lambdabot>   "34"
10:50:06 <martin_joerg> > map (1 +) [1,2]
10:50:08 <lambdabot>   [2,3]
10:50:28 <Olathe> rgr: It isn't that they can't teach, it's that the motivation and quality of thinking suck.
10:50:40 <roconnor> @instances monoid
10:50:41 <lambdabot> Couldn't find class `monoid'. Try @instances-importing
10:50:44 <mapreduce> rgr: Is my code above proof that Haskell sucks? :)
10:50:45 <rgr> Olathe: well, like all generalisations there are exceptions.
10:50:50 <athos> > show 22%7
10:50:51 <lambdabot>       No instance for (Integral [Char])
10:50:51 <lambdabot>        arising from a use of `show' a...
10:50:52 <roconnor> @instances Data.Monoid.monoid
10:50:53 <lambdabot> Couldn't find class `Data.Monoid.monoid'. Try @instances-importing
10:50:54 <SamB_XP_> rgr: you are assuming we didn't make our own educations
10:51:01 <athos> @src show
10:51:01 <lambdabot> show x = shows x ""
10:51:02 <rgr> like wot I did?
10:51:06 <Olathe> rgr: Oh, sure, but if it's the general case, there's gotta be something wrong.
10:51:08 <ski_> @instances Monoid
10:51:08 <athos> @src shows
10:51:09 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:51:09 <lambdabot> Source not found. Do you think like you type?
10:51:21 <SamB_XP_> it'd be a lot easier to do that if I didn't have to spend so much time on school, damnit!
10:51:26 <mpeter> > zip [1..20] [20,19..1]
10:51:27 <lambdabot>   [(1,20),(2,19),(3,18),(4,17),(5,16),(6,15),(7,14),(8,13),(9,12),(10,11),(11...
10:51:45 <idnar> rgr: I learned to read and write before I started school
10:51:45 <Olathe> Most people who are very good at thinking thought about stuff apart from school.
10:51:53 <roconnor> oh, there is no datatype wraping a MonadPlus and making it a Monoid?
10:51:58 <Olathe> Like people who were programming hobbyists.
10:52:02 <SamB_XP> I was homeschooled before college
10:52:15 <mpeter> i went to highschool
10:52:16 <rgr> Olathe: if its the general case. Its easy, for example, for me to hink of all English people as loud mouthed violent maniacs. Why? Because I live in Hamburg and meet lots like that. Doesn't mean its the generalisation of them all over the world. The generalization is limited to that small sphere.
10:52:18 <mpeter> and i kicked ass
10:52:25 <svat> in my anecdotal experience, people with no learn programming experience find it easier to learn functional programming
10:52:29 <idnar> rgr: I learned most of what I know about mathematics from reading GEB:EGB
10:52:29 <SamB_XP> and even so I still spent most of my time trying not to let my schooling get in the way of my education
10:52:33 <mpeter> svat: easier than what
10:52:35 <Olathe> rgr: Sure.
10:52:38 <rgr> svat: I would agree that that makes sense.
10:52:43 <SamB_XP> i.e. playing on the computer instead of doing my work ;-P
10:52:45 <mpeter> people who've already learned OO/imperative?
10:52:45 <idnar> rgr: and I had read most of my English setworks long before they came up at school
10:52:47 <Olathe> rgr: That's certainly true.
10:52:56 <svat> mpeter: than to learn non-functional programming :)
10:52:59 <rgr> mpeter: obviously people with lots of normal procedural programming experience I would say.
10:53:06 <Olathe> rgr: I can only really speak for the people I've seen come from them, which are mostly Americans.
10:53:08 <mpeter> i wouldn't have made it through highschool without a TI-89 with mario on it
10:53:18 <Olathe> mpeter: Heheh
10:53:33 <Olathe> TI: Saving people from boredom since 1973.
10:53:34 <mpeter> <3<3<3 ticalc.org
10:53:36 <idnar> rgr: there are some academic institutions that function correctly, and result in people that report a pleasant experience, but the vast majority of people that I've interacted with all had to deal with the same kind of frustrations with the failure of the system
10:53:59 <mpeter> idnar: the problem is the system itself
10:54:07 <mpeter> i can learn a subject about 90 times faster over the internet
10:54:08 <idnar> rgr: aside from that, there are various classes of people for whom the academic system is fundamentally unsuitable as a learning environment
10:54:09 <mpeter> than through a university
10:54:12 <Olathe> I'd say the problem is deeper than that.
10:54:15 <Olathe> The system is screwed up.
10:54:24 <Olathe> But there has to be a reason it was put in place and kept there.
10:54:31 <SamB_XP> my mom used to leave piles of books on my nightstand ... and many was the time that I read one only to find out it had been for school ...
10:54:35 <rgr> i find it tneds to be more the case of them wanting too much freedom and forgetting why they are there. There must be limitations and guidelines. Not all freethinkers are einstein. Many are just not up to it and dreamers.
10:55:00 <idnar> rgr: why should there be limitations on what you can learn?
10:55:08 <pejo> mpeter, but you're not going to pick up as many 'boring' subjects if you aren't enrolled in them automatically.
10:55:16 <mpeter> pejo: not true
10:55:18 <Olathe> rgr: Sure, but if that's the way kids are, forgetting that so easily, surely that has to be designed for.
10:55:22 <mpeter> i learned to program completely of my own accord
10:55:27 <rgr> There isn't. But there has to be a subset you need to  learn in order to be comapred (rightly or wrongly) against the competition. And life IS competition.
10:55:42 <SamB_XP> I don't think you can learn programming fast
10:55:42 <Olathe> rgr: I don't agree with that.
10:55:51 <idnar> rgr: in real life, you compete on real tasks, not fantasy
10:55:54 <rgr> mpeter: me too. And it was a bad thing for must who did the same at my Uni. They tended to fail because they thought they knew it all.
10:55:55 <mpeter> rgr: the competition DRIVES the learning
10:56:08 <SamB_XP> rgr: oh, btw, I don't actually know how to spell
10:56:11 <idnar> pejo: you're not going to learn anything from a 'boring' subject you're automatically enrolled in anyway
10:56:12 <SamB_XP> I just fake it sometimes
10:56:16 <rgr> mpeter: In an ideal world yes. In the real world universities are there to encourage and guide.
10:56:27 <Olathe> rgr: In an ideal world, they are.
10:56:27 <mpeter> the ideal world is coming
10:56:32 <Olathe> rgr: But in reality, they don't.
10:56:36 <rgr> heh :-;
10:56:39 <mpeter> either that or apocalypse
10:56:47 <idnar> in reality, it's more like they're there to oppress and deride
10:56:58 <rgr> Anyway back to the real world and RWH .. nice chat. See in in 8 seconds with some ridiculously trite question ....
10:57:09 <mpeter> :D
10:57:12 <athos> @instance Read
10:57:12 <lambdabot> Maybe you meant: instances instances-importing
10:57:19 <athos> @instances Read
10:57:19 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:57:30 <mmorrow> does anyone here have experience using Agda? in particular the (apparently now unsupported) interactive (cli, not emacs) mode (agda -I).
10:57:34 <mpeter> math classes were the only classes in high school where i learned something
10:57:38 <sereven> uni is a place to make alliances, contacts, reputation
10:57:45 <SamB_XP> the (innately) worst class I've had so far, one of the teachers didn't even like ...
10:57:55 <SamB_XP> (at least)
10:58:06 <kosmikus> mmorrow: what do you want to know?
10:58:08 <mmorrow> i want to do 1+1, where "1" there is a primitive machine (boxed, whatever) Int
10:58:31 <SamB_XP> mmorrow: 1# +# 1#
10:58:37 <SamB_XP> :t 1# +# 1#
10:58:38 <lambdabot> Not in scope: `+#'
10:58:39 * mmorrow tries
10:58:46 <SamB_XP> I think
10:58:52 <mmorrow> SamB_XP: wait, Agda?
10:58:54 <SamB_XP> @hoogle Int# -> Int# -> Int#
10:58:54 <mpeter> > fi
10:58:56 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:58:58 <lambdabot> Control.Parallel par :: a -> b -> b
10:59:00 <lambdabot> Control.Parallel pseq :: a -> b -> b
10:59:02 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:59:02 <SamB_XP> mmorrow: what?
10:59:06 <SamB_XP> this isn't #agda ...
10:59:13 <mmorrow> ooh
10:59:23 <SamB_XP> not that there IS one
10:59:32 <SamB_XP> I missed the part where you said Agda
10:59:34 <chrisdone> this isn't #sparta
10:59:40 <mmorrow> looks like there is an #agda :)
10:59:45 <mpeter> > foldl (+) 0 (take 250 fi)
10:59:45 <idnar> chrisdone: you mean this isn't #madness
10:59:46 <lambdabot>   20672849399056463095319772838289364792345825123228623
10:59:49 <Olathe> I'm #spartacus !
10:59:58 <rgr> uh oh ....
10:59:58 <idnar> Olathe: hahaha
11:00:12 <mpeter> this isn't #agameofchess
11:00:15 <mpeter> this is #agoddamnwar
11:00:24 * rgr wonders how many will take up the spartacus challenge ....
11:00:44 <idnar> no, I'm #spartacus!
11:01:03 <mpeter> > idnar
11:01:04 <lambdabot>   "what a homosexual"
11:01:09 * rgr wonders what auto increment is in Haskell ... num++
11:01:24 <Megzlna> rgr: ..
11:01:32 <Megzlna> Haskell doesn't mutate
11:01:42 <rgr> idnar back to front is "Randi" .. interesting :-;
11:01:43 <mpeter> rgr: num + 1
11:01:47 <rgr> almost
11:01:58 <mpeter> tail recursion is the only use for that, baby
11:02:09 <Megzlna> num++ specifically applies only to mutation
11:02:16 <Asztal> though with GHC 6.10's postfix operators, you could presumably redefine ++ as a postfix operator that works on IORef a
11:02:19 <Asztal> :)
11:02:27 <rgr> and I thought #emacs had the gold cup at dry humour ...
11:02:53 <Olathe> > zomg
11:02:54 <lambdabot>   zomg
11:03:17 <idnar> rgr: my usual nickname is 'mithrandi'
11:03:35 <idnar> rgr: but that clashes with Mithrandir (who is someone completely different) on freenode and some other networks
11:04:36 <rgr> oh no. Just hit "mod-q" in an emacs buffer to compile the eLisp. This is going to be tough ....
11:05:58 <mpeter> > life
11:05:59 <lambdabot>   "To-morrow, and to-morrow, and to-morrow,  Creeps in this petty pace from d...
11:06:15 <gwern> @seen dcoutts_
11:06:16 <lambdabot> dcoutts_ is in #haskell, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts_ last spoke.
11:06:17 <rgr> you have alink for bot activation here?
11:06:20 <gwern> @seen dcoutts
11:06:20 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts last spoke.
11:06:44 <rgr> > help
11:06:45 <lambdabot>   Not in scope: `help'
11:06:51 <ski_> @help
11:06:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:06:54 <rgr> @help
11:06:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:07:16 <gwern> @ask dcoutts_ is cabal currently supposed to warn or error out if one passes configure an invalid -f flag? (ie. -fghc-api when -fghcAPI is needed)
11:07:16 <lambdabot> Consider it noted.
11:07:23 <mpeter> > maximum life
11:07:24 <lambdabot>   'y'
11:07:33 <Olathe> Ehh ?
11:07:47 <rgr> can one not open a /msg conversation with lambdabot as to play with him without disturbing the main channel?
11:08:10 <ski_> rgr : sure can
11:08:16 <mpeter> > ord life
11:08:17 <lambdabot>   Not in scope: `life'
11:08:28 <mpeter> grr
11:08:33 <ski_> (rgr : also, incidentally, lambdabot's a "her")
11:08:34 <Olathe> Life has been destroyed :(
11:08:52 <mpeter> > map ord life
11:08:55 <lambdabot>   [84,111,45,109,111,114,114,111,119,44,32,97,110,100,32,116,111,45,109,111,1...
11:08:57 <rgr> Just did "/msg lambdabot hello" and no message buffer opened. Got not reply.
11:09:09 <Olathe> /msg lambdabot 2 + 2
11:09:11 <Olathe> /msg lambdabot > 2 + 2
11:09:13 <Olathe> Try that.
11:09:52 <rgr> ">" is ? ...
11:10:05 <rgr> eval commmand?
11:10:12 <Olathe> Yes.
11:10:13 <Olathe> > 2 + 2
11:10:14 <ski_> @run 2 + 2
11:10:16 <lambdabot>   4
11:10:16 <lambdabot>   4
11:10:29 <rgr> > printStrLn "Thank You"
11:10:30 <lambdabot>   Not in scope: `printStrLn'
11:10:37 <rgr> oh ...
11:10:58 <ski_> > putStrLn "I/O doesn't work in lambdabot"
11:10:58 <loop_> > putStrLn "Thank You"
11:10:59 <lambdabot>   * Exception: "<IO ()>"
11:11:00 <lambdabot>   * Exception: "<IO ()>"
11:11:05 <loop_> ;(
11:11:10 <Olathe> > let printStrLn n = fun n :: Expr in printStrLn "Thank You"
11:11:11 <lambdabot>   Thank You
11:11:17 <Olathe> @let printStrLn n = fun n :: Expr
11:11:18 <lambdabot>  Defined.
11:11:20 <mpeter> how do you divide an int by a float
11:11:38 <sioraiocht> :t fromIntegral
11:11:39 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:11:46 <ski_> > fromIntegral (10 :: Int) / (3 :: Float)
11:11:47 <lambdabot>   3.3333333
11:11:49 <sereven> > "I'm not a guy, by the way http://www.haskell.org/haskellwiki/Lambdabot "
11:11:50 <lambdabot>   "I'm not a guy, by the way http://www.haskell.org/haskellwiki/Lambdabot "
11:12:13 <mpeter>  > fromIntegral (foldr (+) 1 (map ord life)) / 874.7142857142857
11:12:25 <Olathe> O-o
11:12:26 <mpeter> cmon...cmon...
11:12:29 <ski_> @vixen a/s/l
11:12:30 <lambdabot> 19/f/California
11:12:30 <mpeter> > fromIntegral (foldr (+) 1 (map ord life)) / 874.7142857142857
11:12:31 <lambdabot>   42.0
11:12:34 <mpeter> !!!!!
11:12:36 <SamB> @type life
11:12:36 <Olathe> Oh dear.
11:12:37 <lambdabot> [Char]
11:12:38 <mpeter> alas
11:12:39 <sioraiocht> hahahahahahahahahahahah
11:12:42 <SamB> that's not the type of life
11:12:44 <sioraiocht> > life
11:12:45 <lambdabot>   "To-morrow, and to-morrow, and to-morrow,  Creeps in this petty pace from d...
11:13:01 <mpeter> :D
11:13:37 <SamB> life should be of type InfiniteRaster Bool -> Bool
11:13:45 <Olathe> > printStrLn life
11:13:46 <lambdabot>   Not in scope: `printStrLn'Not in scope: `life'
11:13:54 <Olathe> You've ruined it !
11:14:12 <mpeter> some spiteful person is doing @undefine
11:14:26 <Gracenotes> > length life
11:14:27 <lambdabot>   77
11:14:28 <SamB> rgr: was it you ?
11:14:33 <Quorer> hello. is there a (plattform - independent, if possible) way to run the systems's defaault borwser out of haskell? (e.g. something with the system - command?)
11:14:36 <Gracenotes> looks pretty average to me
11:14:38 <mpeter> or not
11:14:46 <Olathe> Heheh
11:14:51 <Olathe> > printStrLn life
11:14:53 <lambdabot>   To-morrow, and to-morrow, and to-morrow,  Creeps in this petty pace from d...
11:14:58 <Elly> Quorer: probably not, because there is no notion of 'default browser' on many platforms
11:14:59 <rgr> SamB: ?
11:15:00 <SamB> quicksilver: of course not
11:15:05 <SamB> er.
11:15:08 <SamB> Quorer:
11:15:19 <Elly> e.g., a linux system has no 'default browser'
11:15:24 <SamB> do you know of a platform-independant way to do that otherwise ?
11:15:25 <Elly> (gnome or kde may have one, though)
11:15:25 <rgr> Elly: what is most platforms?
11:15:28 <SamB> Elly: mine has!
11:15:33 <SamB> sensible-browser
11:15:35 <rgr> all mine do ...
11:15:37 <mpeter> kazehakase is my latest browser
11:15:38 <rgr> :-;
11:15:40 <Elly> rgr: the only ones I can think of that have one are windows and OSX
11:15:41 <gwern> Quorer: what elly said. in xmonad, I did something like getEnv $WWW-BROWSER,falling back to getEnv $X-WWW-BROWSER, falling back to sensible-browser, falling back to just "firefox"
11:15:44 <mpeter> it almost works, until flash gives it a massive memory leak
11:15:52 <Gracenotes> > drop 71 $ life --meh
11:15:54 <lambdabot>   "om d..."
11:15:55 <rgr> the underlying DE and WM have them ...
11:15:59 <Elly> not here
11:16:11 <Elly> my WM doesn't have a notion of 'default browser' and I don't have a DE
11:16:29 <rgr> there are frequently system calls which map the type to the configured in the ame way mime works
11:16:32 <gwern> Elly: many distros have default browser settings. all debian-descendenats have the sensible-* defaults, and I believe $WWW-BROWSER and $X-WWW-BROWSER are freedesktop standard variables
11:16:55 <p_l> gwern: Wasn't that $BROWSER ?
11:17:07 <rgr> Elly: but you would be right to say "not all" platforms ...
11:17:09 <Elly> gwern: I have neither of those variables set, and gentoo doesn't have sensible-*
11:17:12 <gwern> p_l: that's another one
11:17:21 <SamB> Elly: well, that's your problem
11:17:29 <SamB> (using gentoo ;-P)
11:17:37 <gwern> Elly: why I said debian-descendents...
11:17:41 <Elly> hasn't been a problem so far :)
11:18:03 <rgr> anyway hardcore non WM types use W3.
11:18:04 <Elly> gwern: I know, but "works on debian" is a long way from "platform-independent"
11:18:09 * Elly uses links2 :P
11:18:11 <Gracenotes> echo %BROWSER% yields nothing on this Ubuntu box...
11:18:15 <rgr> and debian descendants ...
11:18:22 <Elly> Gracenotes: that's because environment variables don't work like that
11:18:24 <rgr> And all the Windows platforms ....
11:18:26 <Elly> Gracenotes: try echo $BROWSER
11:18:30 <Quorer> ok, let's change the question and ask about a way to run the default browser on gnome/kde/win/osx
11:18:31 <Gracenotes> er, yeah
11:18:38 <Gracenotes> Elly: confused notation in typing it up here
11:18:42 <Gracenotes> but that doesn't work either
11:19:08 <SamB> Elly: well, why do you suppose I said "of course not" initially ;-P
11:19:14 <rgr> gnome-open
11:19:19 <rgr> ?
11:19:20 <hugo___> hi there
11:19:30 <Gracenotes> %BROWSER% wouldn't yield nothing after all, just the string %BROWSER%
11:19:32 <SamB> on Windows, I think you run "start http://"
11:19:38 <ski_> lo there, hugo___
11:19:52 <rgr> e.g gnome-open "www.ibm.com"
11:19:53 * mpeter sets mode +a mpeter
11:19:55 <athos> is :: for specifying a type always applied at last? so that by some: foo.bar (baz $ barfu [x,y,z]) :: SomeType i can be sure, that SomeType is applied for the whole expression?
11:19:55 <SamB> Gracenotes: Windows is odd
11:20:24 <Gracenotes> I lived with cmd for a few years. It doesn't go away easily <_<
11:20:35 <SamB> F:\>echo ROWSER%
11:20:36 <SamB> ROWSER%
11:20:36 <SamB> F:\>
11:20:39 <SamB> arg
11:20:42 <SamB> stupid x-chat
11:20:43 <ski_> athos : that should be parsed as `(foo.bar (baz $ barfu [x,y,z])) :: SomeType', if that's what you're asking, yes
11:20:43 <gwern> Gracenotes: how tragic
11:20:44 <Olathe> athos: No, just right after the expression you want to be that type.
11:20:45 <SamB> you were right though
11:20:53 <SamB> it doesn't substitute at all
11:21:09 <Olathe> > 5 :: Int + 5
11:21:10 <athos> ski_: that's what i was looking for, thanks
11:21:10 <lambdabot>   Only unit numeric type pattern is valid
11:21:11 <SamB> and why the heck does WINE take so long to start cmd ...
11:21:21 <ski_> > not False :: Bool
11:21:23 <lambdabot>   True
11:21:26 <Olathe> > (5 :: Int) + 5
11:21:27 <lambdabot>   10
11:21:28 <SamB> > otherwise
11:21:29 <lambdabot>   True
11:21:33 <Gracenotes> gwern: in the aristotelian sense, of course
11:21:39 <SamB> > all []
11:21:40 <lambdabot>   Couldn't match expected type `a -> Bool'
11:21:40 <Olathe> @src otherwise
11:21:41 <lambdabot> otherwise = True
11:21:44 <mpeter> hmm
11:21:45 <SamB> > and []
11:21:46 <Olathe> Oh.
11:21:47 <lambdabot>   True
11:21:48 <Quorer> other question: got an application awaiting a string and returning a string. is there a tutorial to teach this application to be reachable as a "user" from icq/jabber?
11:21:49 <Olathe> Well...
11:21:50 <mpeter> > (5 :: Float) + 5
11:21:51 <lambdabot>   10.0
11:21:52 <Olathe> That makes sense.
11:22:05 <SamB> Olathe: it's for use in guards
11:22:11 <Olathe> I know :)
11:22:19 <Olathe> I just thought it was special syntax, not True.
11:22:20 <SamB> it looks better than, e.g. CL's pervasive t
11:22:26 <SamB> I mean, is more clear
11:22:43 * ski_ usually uses `True' instead of `otherwise' ..
11:22:45 <Olathe> Like default in C.
11:23:07 <SamB> only C has no "cond" construct
11:23:32 <Megzlna> else if (true) {
11:23:34 <Gracenotes> Olathe: hm, me too. makes sense though.
11:23:41 <SamB> just say "else"
11:24:14 <Megzlna> that would be too correct, SamB
11:24:17 <SamB> never use special syntax when you can just export a name from the library for the same effect
11:24:22 <jeffwheeler> It's like having then = id and else = id, if one wanted to use if' and keep the syntax similar.
11:24:32 <Olathe> Yeah, I like that idea :)
11:24:35 <jeffwheeler> A bit silly, but very useful.
11:24:35 <SamB> Megzlna: plus, s/true/1/
11:24:41 <Olathe> > let otherwise = False
11:24:42 <lambdabot>   <no location info>: parse error on input `;'
11:25:05 <athos> :t if'
11:25:06 <lambdabot> Not in scope: `if''
11:25:08 <SamB> Olathe: you need to say "in foo" or use @let
11:25:13 <Olathe> I know :)
11:25:15 <SamB> @src if'
11:25:16 <lambdabot> Source not found. stty: unknown mode: doofus
11:25:29 <Olathe> if' is a bit of fakery from @pl, I think.
11:25:33 <Olathe> It doesn't exist.
11:25:35 <SamB> Cale: please add if' to the database with a comment stating that it is not actually standard
11:25:55 <SamB> @tell Cale please add if' to the @src database with a comment stating that it is not actually standard
11:25:55 <lambdabot> Consider it noted.
11:26:00 <jeffwheeler> Grr: http://www.google.com/search?hl=en&q=%22if+prime%22&btnG=Search
11:26:08 <Megzlna> C++ doesn't' lack the bool primitive type -- C++ if actually takes bool.
11:26:21 <SamB> Megzlna: we were talking about C though
11:26:50 <hugo___> c++ bool is actually just one bit
11:26:54 <Gracenotes> jeffwheeler: Google is unfortunately suboptimal when it comes to symbols :(
11:27:00 <Megzlna> SamB: right, C is the first half of my sentence
11:27:01 <SamB> C++ && annoys me because I can't use it on pointer-valued expressions to get a pointer-valued result
11:27:02 <Gracenotes> grrr.
11:27:10 <Megzlna> the "doesn't lack" part
11:27:14 <p_l> c++ bool has super-overloaded operators
11:27:14 <jeffwheeler> Gracenotes: indeed, but I was _sure_ that using "prime" would work. :P
11:27:37 <athos> @src read
11:27:37 <lambdabot> read s = either error id (readEither s)
11:27:45 <p_l> SamB: nothing beats finding that !pointer no longer works :>
11:27:50 <SamB> (WITH short-circuiting)
11:27:55 <SamB> p_l: that still works fine though
11:28:00 <Gracenotes> although, people don't write it as if prime, they read it as if'
11:28:03 <Gracenotes> *write
11:28:07 <SamB> it converts the pointer to bool and then negates it
11:28:13 <Gracenotes> unfortunately
11:28:30 <jeffwheeler> Gracenotes: aye.
11:28:32 <p_l> SamB: I actually had it fail in an if expression, found that it was somewhere deep in GCC C++ runtime
11:28:36 <SamB> the unfortunate bit is that google doesn't have a haskeller's search
11:28:45 <SamB> p_l: huh
11:28:56 <Olathe> I wish Google had an exact text search.
11:28:56 <Gracenotes> Google Code does allow literal searching, but it's not terribly useful for Haskell, as far as I can tell
11:29:13 <Gracenotes> http://www.google.com/codesearch?q=lang%3Ahaskell+%22if%27%22
11:29:17 <SamB> a punctuation-included web search
11:29:17 <Olathe> Ahh.
11:29:49 <SamB> I guess it's not as easy as we act like it is
11:30:16 <SamB> they can't just index it exactly, because people might write things like "like foldl', ..."
11:31:00 <jeffwheeler> Hell, just give me a regular expression search feature for the entire internet and I'd be satisfied.
11:31:16 <Gracenotes> and imagine if one language had a phrase like won, then won' will match won't, etc.
11:31:46 <Gracenotes> or a version with an accidental space, won' t
11:32:26 <SamB> so they'd have to at least index the punctuation as seperate words, I guess
11:32:58 <SamB> and allow somewhat sophisticated specifications of exactly which "word" arrangements were acceptable
11:33:01 <Gracenotes> > [0,0.1..1]
11:33:02 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
11:33:28 <athos> eh
11:33:32 <Olathe> > [0, 0.1 .. 1] :: [Rational]
11:33:34 <lambdabot>   [0%1,1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
11:33:42 <Olathe> Much more rational.
11:33:43 <gwern> google supports regexps
11:33:44 <athos> better!
11:33:45 <athos> :]
11:33:49 <SamB> gwern: it does ?
11:33:52 <gwern> inside quotes, as in "foo.*"
11:33:54 <Gracenotes> gwern: more like globs, in a sense
11:33:57 <gwern> handy, but obscure
11:34:02 <SamB> HOW?
11:34:03 <gwern> Gracenotes: well, that's true enough
11:34:17 <Gracenotes> Google is overall pretty inexact, even with 'exact' quotes
11:34:43 <SamB> do they allow things like [^abf]?
11:35:43 <Gracenotes> I don't quite get the difference between, say, "kittenf.*" and "kittenf*", although they return different things
11:35:46 <gwern> why not try
11:35:55 <Elly> Gracenotes: '.' means "any character"
11:35:59 <dons> ?users
11:35:59 <lambdabot> Maximum users seen in #haskell: 586, currently: 577 (98.5%), active: 22 (3.8%)
11:36:06 <dons> hey all
11:36:07 <Elly> Gracenotes: and "*" means 'match the immediately preceding regex any number of times'
11:36:10 <Gracenotes> Elly: yes, I know
11:36:22 <Elly> Gracenotes: if you like, you can read them as "kittenf(.*)" and "kitten(f*)"
11:36:22 <Gracenotes> but Google doesn't interpret f* to mean any number of f's
11:36:31 <Gracenotes> so it strikes me as a bit inconsistent
11:36:31 <SamB> gwern: well, I don't have a reference database of the internet to compare against ;-P
11:36:32 <Elly> google isn't doing regular expressions
11:36:37 <Elly> they are doing globs, I suspect
11:36:49 <Elly> in which case * means what .* means in regex context
11:37:00 <Gracenotes> indeed... that's what I said.
11:37:10 <Gracenotes> the extent to which they combine both models is confusing though
11:38:00 <gwern> @quote hubris
11:38:01 <lambdabot> No quotes match.
11:38:10 <dons> simonpj video , http://www.reddit.com/r/programming/comments/7jfko/typedriven_testing_in_haskell_simon_peyton_jones/
11:38:40 <gwern> @remember LarryWall We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.
11:38:41 <lambdabot> I will remember.
11:38:51 <gwern> @quote laziness
11:38:52 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
11:39:00 <Gracenotes> interestingly, "kittenf.*" and "kittenf*" have the exact same number of results, but different ordering up at top.
11:39:05 <znutar> Is the difference in results consistent?  You might just be seeing the results from 2 different sets of data because they send different kinda globs to different machines or something like that
11:39:15 <gwern> speak of the edvil, we were just dsicussing jdh's #haskell ban
11:39:33 <Adamant> gwern: i get stuck on the laziness and don't do enough programming
11:39:37 <Adamant> this is bad
11:39:39 <athos> @hoogle CReal
11:39:39 <lambdabot> No results found
11:39:39 <Megzlna> :t nub
11:39:40 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:39:42 <athos> oh
11:39:44 <athos> :[]
11:39:55 <Megzlna> what is a nub
11:40:02 <athos> @src nub
11:40:06 <lambdabot> nub = nubBy (==)
11:40:07 <gwern> @wn nub
11:40:09 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
11:40:10 <Megzlna> a newb?
11:40:10 <lambdabot> nub
11:40:12 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
11:40:14 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
11:40:16 <lambdabot>      3: the choicest or most essential or most vital part of some
11:40:18 <athos> > nub [3,4,2,1]
11:40:20 <lambdabot> [5 @more lines]
11:40:22 <lambdabot>   [3,4,2,1]
11:40:27 <athos> > nub [3,4,2,1,1,1,1]
11:40:28 <lambdabot>   [3,4,2,1]
11:40:40 <athos> > nub [3,4,2,1,1,1,1,7]
11:40:41 <lambdabot>   [3,4,2,1,7]
11:40:44 <Megzlna> > nub [3,3,4,1,1]
11:40:45 <lambdabot>   [3,4,1]
11:40:47 <athos> seems like it dropes redundant stuff
11:40:48 <Gracenotes> > nub [2,3,4,4,4,5,2,6,6,7,7]
11:40:49 <lambdabot>   [2,3,4,5,6,7]
11:40:50 <Elly> nub is `uniq` for those of you that speak shell
11:40:51 <Megzlna> > nub [3,3,4,4,3,4,1,1]
11:40:52 <lambdabot>   [3,4,1]
11:40:56 <gwern> @wn niddering
11:41:01 <lambdabot> No match for "niddering".
11:41:10 <gwern> man, wordnet sucks
11:41:17 <gwern> how can they not having 'niddering'?
11:41:20 <athos> @wn gwern
11:41:21 <lambdabot> No match for "gwern".
11:41:24 <athos> :[
11:41:31 <Megzlna> There was a man, that moshed so hard all he had left was a bloody nub
11:41:38 <Gracenotes> > map head $ groupBy (==) [2,3,4,4,4,5,2,6,6,7,7]
11:41:39 <lambdabot>   [2,3,4,5,2,6,7]
11:42:00 <Gracenotes> @src nubBy
11:42:01 <lambdabot> nubBy eq []             =  []
11:42:01 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:42:08 <Gracenotes> hm.
11:42:45 <athos> > nub [3,1,1,2,3,4]
11:42:46 <lambdabot>   [3,1,2,4]
11:43:37 <Gracenotes> ah, not quite equivalent to the groupBy def.
11:43:44 <athos> yep
11:43:51 <Gracenotes> I'll have to experiment with this.....
11:44:38 <athos> @src cosh
11:44:38 <lambdabot> Source not found.
11:45:28 <dons> dolio: send me what ever patch you need
11:45:36 <dons> for uvector.
11:45:58 <rgr> really silly basic q here. from RWH :
11:45:59 <rgr> ghci> :type 3 + 2
11:45:59 <rgr> 3 + 2 :: (Num t) => t
11:45:59 <rgr>  
11:46:07 <rgr> what is "t" here? short of type?
11:46:43 <dolio> dons: I already have. As far as changes I made to release, it's the memcpy stuff.
11:47:03 <dons> dolio: i'm not sure i have it. if you send it now, i'll apply and upload
11:47:08 <dons> rgr: the 't' is a type variable
11:47:14 <dons> it can be instantiated to any Num type
11:47:21 <dons> e.g. Int, Word, Integer, Double ..
11:47:25 <dolio> dons: For the Schwartzian transform, it's an unsafe zip.
11:47:29 <Olathe> > showRats [0, 0.1 .. 1]
11:47:30 <lambdabot>   "[0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1]"
11:47:36 <dolio> Okay, let me look them up...
11:47:51 <rgr> dons: so in English how would you read that "3 + 2 :: (Num t) => t" ?
11:48:22 <dons> 3 + 2 is polymorphic in the Num class
11:48:37 <dons> or, for all types 't' in the Num class, 3+2 has type t
11:48:44 <dibblego> three plus two is of type forall t then t such that t is a member of the Num class
11:48:45 <Gracenotes> > showRat pi
11:48:46 <lambdabot>   mueval: Prelude.read: no parse
11:48:46 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
11:48:46 <rgr> 2nd makes more sense :-;
11:48:49 <athos> > cosh 0 == (\x -> 0.5*(exp x + exp (-x)) 0
11:48:50 <lambdabot>   <no location info>: parse error on input `;'
11:48:56 <dons> the way to think about it is that (+) is overloaded, simply.
11:48:59 <athos> > cosh 0 == (\x -> 0.5*(exp x + exp (-x))) 0
11:49:00 <lambdabot>   True
11:49:03 <dons> so anything that looks like a Num will work on (+)
11:49:10 <Gracenotes> > showRats [pi]
11:49:11 <lambdabot>       No instance for (Floating (Ratio a))
11:49:11 <lambdabot>        arising from a use of `pi' ...
11:49:15 <athos> :t showRats
11:49:17 <lambdabot> forall a. (Integral a) => [Ratio a] -> [Char]
11:49:19 <rgr> but which bit states its ploymorphic?
11:49:25 <Olathe> > showRats [0, 1/3 .. 1]
11:49:26 <Gracenotes> hm.
11:49:27 <lambdabot>   "[0,0.333333333333333333,0.666666666666666666,1]"
11:49:45 <dons> rgr: the Num t => t
11:49:47 <dons> lower case t
11:49:52 <Olathe> > showCReal 100 pi
11:49:54 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
11:49:57 <dons> means it is a type variable, and one constrained to Num types
11:50:01 <athos> :t CReal
11:50:02 <lambdabot> Not in scope: data constructor `CReal'
11:50:06 <dons> :t id
11:50:08 <lambdabot> forall a. a -> a
11:50:09 <athos> @hoogle showCReal
11:50:09 <lambdabot> No results found
11:50:12 <dons> polymorphic in any type
11:50:16 <dons> so you can apply it to anything
11:50:18 <athos> hmm.. where's CReal situated?
11:50:46 <Gracenotes> Data.Number.CReal, apparently
11:50:49 <Olathe> athos: http://darcs.augustsson.net/Darcs/CReal/
11:50:57 <Olathe> CReal and CRealI, I think.
11:51:29 <athos> ah, so it's nothing delivered with ghc 6.8.x by default
11:51:33 <Olathe> Oh, no.
11:51:40 <Olathe> It is, however, quite nice.
11:52:25 <Gracenotes> mm, where's showRats then?
11:52:26 <dolio> dons: I /messaged you.
11:52:32 <Olathe> Oh, I made that.
11:52:43 <Olathe> @let showRat n = if denominator n == 1 then show (numerator n) else if n < 0 then "-" ++ showRat (-n) else show (floor n) ++ "." ++ showRat' (10 * (n - fromIntegral (floor n))) where showRat' 0 = ""; showRat' n = show (floor n) ++ showRat' (10 * (n - fromIntegral (floor n)))
11:52:44 <lambdabot>  <local>:3:0:
11:52:44 <lambdabot>      Multiple declarations of `L.showRat'
11:52:44 <lambdabot>      Declared at: <lo...
11:53:23 <Gracenotes> neat, *steals your sauce*
11:53:37 <Gracenotes> to analyze, of course .-.
11:54:14 <Gracenotes> and showRats is a mapping version, then
11:54:34 <Olathe> Yeah.
11:54:35 <athos> :t rem
11:54:37 <athos> :t mod
11:54:37 <lambdabot> forall a. (Integral a) => a -> a -> a
11:54:39 <lambdabot> forall a. (Integral a) => a -> a -> a
11:54:43 <Olathe> @let showRats xs = "[" ++ (concat . intersperse "," . map (take 20.showRat)) xs ++ "]"
11:54:45 <lambdabot>  <local>:2:0:
11:54:45 <lambdabot>      Warning: Pattern match(es) are overlapped
11:54:45 <lambdabot>               In...
11:54:52 <athos> uhm, where's the difference between rem and mod?
11:55:00 <basvandijk> Hello, when you 'import qualified Control.Category as C' how do you reference '.' from C ? C.(.) and C.. give parse errors.
11:55:03 <Olathe> In negatives.
11:55:05 <Baughn> athos: For negative number
11:55:11 <athos> oh ok!
11:55:18 <Olathe> One takes the sign of the first argument, the other does the other.
11:55:28 <Botje> Baughn: (C..) , maybe?
11:55:44 <basvandijk> Botje: thanks that's it
11:55:50 <Baughn> Botje: What?
11:55:55 <Botje> oh damn
11:55:59 * Botje hits his autocomplete
11:56:00 * Beelsebob really wants the moudule seperator to be + now
11:56:02 <Botje> meant basvandijk
11:56:08 <Beelsebob> so you can use (C++) as an infix operator
11:56:14 <Beelsebob> >.>
11:56:20 <athos> > toRational pi
11:56:21 <Gracenotes> > denominator .5
11:56:22 <lambdabot>       Overlapping instances for Show (a1 -> a)
11:56:22 <lambdabot>        arising from a use of `...
11:56:23 <lambdabot>   884279719003555%281474976710656
11:56:24 <Botje> evil (C++) _ = evil
11:56:35 <athos> what a nice fraction 8]
11:56:47 <Gracenotes> > denominator (1/2)
11:56:49 <lambdabot>   2
11:56:53 <Baughn> > toRational pi
11:56:55 <lambdabot>   884279719003555%281474976710656
11:57:00 <Olathe> > showRat $ toRational pi
11:57:02 <lambdabot>   "3.141592653589793115997963468544185161590576171875"
11:57:05 <augustss> > yoRational (pi::Float)
11:57:07 <lambdabot>   Not in scope: `yoRational'
11:57:09 <Baughn> > toRational (0.5 :: Float)
11:57:10 <Olathe> > showCReal 40 pi
11:57:10 <lambdabot>   1%2
11:57:12 <lambdabot>   "3.1415926535897932384626433832795028841972"
11:57:17 <Baughn> > toRational (0.2 :: Float)
11:57:18 <lambdabot>   13421773%67108864
11:57:28 <augustss> > toRational (pi::Float)
11:57:30 <lambdabot>   13176795%4194304
11:57:41 <Olathe> > 22%7
11:57:43 <lambdabot>   22%7
11:57:54 <augustss> > approxRational pi 0.01
11:57:56 <lambdabot>   22%7
11:58:01 <Olathe> O-o
11:58:07 <Olathe> @src approxRational
11:58:08 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:58:13 <Gracenotes> ooh.
11:58:40 <Olathe> > approxRational (exp 1) 0.01
11:58:41 <Gracenotes> heh, not being able to write '.01' is biting me in the back ;)
11:58:42 <lambdabot>   19%7
11:58:49 <Olathe> > approxRational (exp 1) 0.0001
11:58:51 <lambdabot>   193%71
11:58:54 <Megzlna> Is there something like (.) which composes in the opposite order?
11:59:13 <Gracenotes> flip (.), which apparently is rather demonic
11:59:35 <Megzlna> well that's too syntax invasive
11:59:48 <Olathe> You can define an operator.
11:59:58 <Megzlna> Olathe: builtin Haskell
12:00:10 <Olathe> Yes, with built-in Haskell ;)
12:00:13 <Olathe> Just kidding.
12:00:41 <Baughn> Megzlna: I don't think anyone feels the need. Reading from right to left is quite natural to us.
12:00:53 <Baughn> (Yes. It's true. Haskellers are all arabs.)
12:01:09 <Gracenotes> and/or Jews
12:01:09 <baaba> @src (.)
12:01:09 <lambdabot> (f . g) x = f (g x)
12:01:13 <athos> dons: don't know if don't made a mistake or if it's even worth mentioning, but in table 6.3 (RWH) about typeclass instances, it seems like Int8 is missing
12:01:20 <Megzlna> Yeah, Left to right looks odd, but I was thinking about what someone said 'uniq' is like nub
12:01:21 <baaba> (it's not really built-in in that sense)
12:01:21 <Beelsebob> > let (>>) = flip (.); ($>) = flip ($) in 2 $> (+ 5) >> (* 6) >> (- 3) >> (/ 27)
12:01:22 <lambdabot>       Overlapping instances for Show (a -> c)
12:01:23 <lambdabot>        arising from a use of `s...
12:01:23 <athos> at least it's missing in the online version
12:01:27 <Beelsebob> >.<
12:01:39 <vixey> :t (>>>)
12:01:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
12:01:41 <athos> my printing did not get delivered until today :o
12:01:41 <vixey> :t (<<<)
12:01:43 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
12:01:43 <Megzlna> cat foo | uniq | grep bar
12:01:47 <dons> athos: oh, that's interesting. i think it made it into the print verrsion
12:01:49 <vixey> s/a/(~>)/
12:01:49 <dons> i rememeber the bug
12:01:52 <vixey> There you go Megzlna
12:01:58 <athos> dons: ok
12:02:34 <Megzlna> vixey: Ah, arrows..
12:02:45 <vixey> actually yeah, (Arrow a) => a b c -> a c d -> a b d in unreadable
12:02:50 <augustss> dons: why is there no @src for approxRational?
12:02:55 <Baughn> > let (|) = flip (.) in 2 | (+3) | (*2
12:02:55 <Gracenotes> running uniq on a large must either be performance-inefficient or memory-inefficient
12:02:56 <lambdabot>   <no location info>: parse error on input `|'
12:02:57 <vixey> (Arrow (~>)) => (b ~> c) -> (c ~> d) -> (b ~> d)
12:03:03 <Gracenotes> *large file
12:03:10 <Baughn> > let (!) = flip (.) in 2 ! (+3) ! (*2)
12:03:11 <lambdabot>       No instance for (Num (a -> b))
12:03:11 <lambdabot>        arising from the literal `2' at <...
12:03:19 <vixey> Megzla, (^ better way to view it)
12:03:29 <Baughn> > let (!) = flip (.) in 2 $ (+3) ! (*2)
12:03:29 <vixey> -> in one instance of ~>
12:03:30 <lambdabot>       No instance for (Num ((a -> a) -> b))
12:03:30 <lambdabot>        arising from the literal `...
12:03:34 <vixey> is*
12:04:03 <Baughn> > let (!) = flip (.); (#) = flip ($) in 2 # (+3) ! (*2)
12:04:04 <lambdabot>   <no location info>: parse error on input `)'
12:04:10 <Gracenotes> hm. or it could use hashcodes. meh, talking aloud.
12:04:14 <Baughn> > let (!) = flip (.); (%) = flip ($) in 2 % (+3) ! (*2)
12:04:15 <lambdabot>       No instance for (Num (a -> b))
12:04:16 <lambdabot>        arising from the literal `2' at <...
12:04:39 <Baughn> ..I should probably stop abusing the language now. It's not even working
12:04:50 <Asztal> unfortunately that's (2 % (+3)) ! (*2), I think
12:05:03 <Baughn> > let (!) = flip (.); (%) = flip ($) in 2 % ((+3) ! (*2))
12:05:04 <augustss> Yeah, need some operator precedences
12:05:05 <lambdabot>   10
12:05:15 <Asztal> you can declare fixity/precedence inline too, though.
12:05:29 <Baughn> Oh, doh. For some reason I thought % would inherit $'s postdescence
12:05:41 <tjb> I have a kind of ugly way of performing something -- anyone have a better idea?  http://hpaste.org/13070#a0
12:05:42 <Gracenotes> > let fn = flip (.) in (fn (negate) (+3)) 0
12:05:43 <lambdabot>   3
12:05:58 <Gracenotes> > let fn = flip (.) in (fn (negate) (+3)) 5
12:05:59 <lambdabot>   -2
12:06:06 <Botje> tjb: use pattern matching.
12:06:25 <Botje> hdlc_byte_stuff [0x7e] = [0x7d, 0x5e]
12:06:50 <Botje> oh wait
12:06:51 <tjb> Botje: ah, will try that now
12:06:51 <Botje> didn't notice the other branches :]
12:07:06 <Botje> hdlc_byte_stuff (0x7e:xs) = 0x7d : 0x5e : hdlc_byte_stuff xs
12:07:11 <Gracenotes> ah, Haskell is way too amusing :/
12:07:31 <tjb> Botje: that does look better
12:08:09 <dolio> dons: My previously sent patches have conflicts in the .cabal file. Do you think you can handle that, or do I need to figure those out?
12:08:30 <Botje> tjb: annotated your paste
12:08:39 <rgr> :?
12:09:02 <Olathe> > [1, 2, 3] >>= (\x -> [x + 1])
12:09:03 <dons> i can handle it
12:09:04 <lambdabot>   [2,3,4]
12:09:09 <tjb> Botje: ah, much nicer -- thanks for the idea
12:09:13 <dons> i majored in vim.
12:09:16 <dolio> Okay. :)
12:09:28 <adekoba> hello. I want to use 'read' in a Binary monad, and have some method for catching errors, but that requires it to be an IO monad. What should I do?
12:09:42 <Olathe> I put some evil monadic stuff on there: http://hpaste.org/13070#a2
12:09:47 <dons> use reads or readMaybe ?
12:09:51 <Baughn> adekoba: Well, you could return an error instead of throwing them
12:09:54 <dons> (there are safe versions of read)
12:10:23 <adekoba> dons: what are they called?
12:10:25 <dons> adekoba:
12:10:40 <Baughn> adekoba: reads, readMaybe
12:10:47 <adekoba> ah, neat, thanks.
12:11:00 <dons>  maybeRead :: Read a => String -> Maybe a
12:11:00 <dons>  maybeRead s = case reads s of
12:11:00 <dons>      [(x, rest)] | all isSpace rest -> Just x
12:11:01 <dons>      _ -> Nothing
12:11:10 <dons> no exceptions.
12:11:20 <Beelsebob> Olathe: personally I think it would read nicer if you called >>= concatMap
12:11:21 <Baughn> Mm. reads seems to be the only one that's actually in the standard libraries
12:11:28 <dolio> dons: Sent.
12:11:35 <dons> yay!
12:11:37 <dons> thanks dolio
12:12:47 <dons> got it.
12:12:48 <dons> ?useers
12:12:48 <lambdabot> Maximum users seen in #haskell: 586, currently: 574 (98.0%), active: 22 (3.8%)
12:12:52 <rgr> in ghci, if I "let a=1" why does ":show bindings" report it as "a :: [Integer] = [1,2,3,4]" ? Yet if I define "let c=1" then c is correctly reported as "c :: Integer =". First mention of it in RWH gettin started but no explanation.
12:13:03 <Olathe> @src concatMap
12:13:04 <lambdabot> concatMap f = foldr ((++) . f) []
12:13:08 <dons> rgr: ah, ghci has "extended defaulting"
12:13:16 <dons> rgr: so you'd have to turn that off
12:13:26 <dons> :set -fno-monomorphism-restriction
12:13:30 <tjb> Botje: do you think 'map' could be used to perform the function also?
12:13:34 <dons> ensures it keeps its most general type, rgr
12:13:35 <Beelsebob> @src (>>=) []
12:13:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:13:36 <rgr> because I had another a which encomasses the simple integer?
12:13:42 <Beelsebob> @src [] (>>=)
12:13:43 <lambdabot> xs >>= f     = concatMap f xs
12:13:50 <Beelsebob> Olathe: that ^^
12:13:53 <dons> it'll default to Integer just by default
12:13:58 <Olathe> Ahh.
12:14:15 <rgr> dons:  so why is c displayed as integer?
12:14:17 <Beelsebob> maps a function over a list, and concatonates the results
12:14:19 <dons> Prelude> :t 1
12:14:19 <dons> 1 :: (Num t) => t
12:14:19 <dons> Prelude> let x = 1
12:14:19 <dons> Prelude> :t x
12:14:19 <dons> x :: Integer
12:14:28 <dons> so there, once we bound it, ghci picked a default type
12:14:34 <dons> Prelude> :set -fno-monomorphism-restriction
12:14:39 <dons> diables that feature
12:14:46 <dons> Prelude> let x = 2
12:14:46 <dons> Prelude> :t x
12:14:47 <Gracenotes> @hoogle Ord
12:14:47 <dons> x :: (Num t) => t
12:14:47 <lambdabot> module Data.Ord
12:14:47 <lambdabot> Prelude class Eq a => Ord a
12:14:47 <lambdabot> Data.Ord class Eq a => Ord a
12:14:51 <Botje> tjb: with concatMap, sure. but you'll have to define a similar function for it
12:14:57 <Olathe> rgr: a is set to a list somehow.
12:15:11 <dons> oh, the listiness is searpate
12:15:17 <Olathe> Ahh.
12:15:18 <Olathe> Oh !
12:15:24 <Olathe> I should have used return.
12:15:24 <rgr> Olathe: but I just said "let a=1" on the line before.
12:15:25 <tjb> Botje: hmm, that is true.  Well I'll see what it looks like an compare
12:15:44 <dons> rgr: seems like :show bindings is weird
12:15:55 <dons> Prelude> :t x
12:15:55 <dons> x :: (Num t) => t
12:15:55 <dons> Prelude> :show bindings
12:15:55 <dons> x :: Integer = _
12:15:58 <dons> for example.
12:16:09 <teko> is haskell useless without monads ?
12:16:30 <rgr> doesn't exactly instill confidence in chapter one :-( Bit lost now.
12:16:32 <vixey> teko, no not at all
12:16:46 <teko> are monads pure or not pure ?
12:16:46 <dons> rgr: just proceed. you're getting tangled in the details of ghci.
12:16:48 <vixey> teko, I think all the monads except maybe 2 (?) can be implemented just in plain haskell
12:16:54 <rgr> dons: will do.
12:17:04 <mapreduce> teko: Clean is basically Haskell without monads.  I don't think Clean is useless.
12:17:18 <Olathe> Yeah, concatMap is much better there.
12:17:33 <teko> like can u write a function that permutes a string without monads ?
12:17:40 <dons> permutes? yes.
12:17:47 <SamB> you don't need to use Monads for IO
12:17:50 <SamB> there are other ways
12:17:51 <vixey> can you write it WITH monads?
12:17:52 <dons> that's a pure function
12:18:06 <dons> rgr: and the authors are here, so feel free to lean on them :)
12:18:11 <SamB> and you certainly don't need to use the list monad as such
12:18:38 <SamB> dons: don't they have a ... uh ... channel of their own to prop up ?
12:18:41 <rgr> I'm adding my "newbie" comments to the web page as I go along. If one doesnt do it at first point of confusion it slips away ...
12:19:09 <athos> @instances Ord
12:19:10 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:19:20 <dons> rgr: yes, please!
12:19:22 <Olathe> @instances Monad
12:19:23 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:19:25 <athos> @hoogle Complex
12:19:26 <lambdabot> module Data.Complex
12:19:26 <lambdabot> Data.Complex data RealFloat a => Complex a
12:19:26 <lambdabot> package storable-complex
12:19:39 <tjb> rgr: if you need a newbie to look at things, I'd certainly be a good target audience :)
12:19:53 <teko> dons can u point me to permute func on the web that doesnt use monads ?
12:19:55 <athos> @hoogle Sum
12:19:55 <lambdabot> Data.Monoid newtype Sum a
12:19:55 <lambdabot> Data.Monoid Sum :: a -> Sum a
12:19:55 <lambdabot> Prelude sum :: Num a => [a] -> a
12:20:19 <dons> teko: sounds like a homework question.
12:20:23 <dons> teko: its a one liner.
12:20:38 <teko> perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])]
12:20:39 <vixey> teko, do you have a version that _does_ use monads?
12:20:45 <teko> that uses a monad no ?
12:20:50 <dons> :t permutatoins
12:20:51 <lambdabot> Not in scope: `permutatoins'
12:20:52 <dons> :t permutations
12:20:53 <lambdabot> Not in scope: `permutations'
12:20:57 <dons> oh, we don't have 6.10 yet?
12:21:16 <dons> teko: no monads.
12:21:21 <teko> oh
12:21:28 <teko> then what is <- ?
12:21:29 <dolio> , [$ty| permutations |]
12:21:30 <dons> teko: you can rewrite all monadic programs as pure programs that thread explicitly
12:21:36 <dons> list comprehension.
12:21:40 <teko> oh
12:21:40 <lunabot>  forall a . ([] a) -> [] ([] a)
12:21:45 <dolio> Heh.
12:21:50 <dons> , permutations "haskell"
12:21:52 <lunabot>  ["haskell","ahskell","sahkell","ashkell","shakell","hsakell","ksahell","s...
12:21:54 <dons> dolio: trikcy
12:22:15 <teko> whats the source for permutations ?
12:22:20 <athos> , length $ permutations "haskell"
12:22:21 <dons> its in Data.List
12:22:22 <lunabot>  5040
12:22:27 <athos> 8]
12:22:40 <teko> kool ta
12:22:41 <athos> > permutations [1,2,3]
12:22:42 <lambdabot>   Not in scope: `permutations'
12:22:50 <athos> hmm, what's ','?
12:22:51 <teko> , permutations [1,2,3]
12:22:53 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
12:22:56 <athos> special magic lambdabot operator
12:22:59 <athos> ? :)
12:23:04 <dons> different bot
12:23:05 <athos> s/operator/command
12:23:08 <athos> ah ok
12:23:28 <teko> is there one that uses repetition ?
12:23:40 <teko> like "aaa"
12:23:48 <teko> and not juse "abc"
12:23:51 <teko> just*
12:24:02 <dons> teko: i'm sure you can write one!
12:24:32 <teko> is there a func that will return all the ways to make x selections from a list ?
12:24:38 <athos> :t sort
12:24:39 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:24:59 <athos> sort [Just 5, Nothing, Just 3]
12:25:02 <athos> > sort [Just 5, Nothing, Just 3]
12:25:03 <lambdabot>   [Nothing,Just 3,Just 5]
12:25:15 <Gracenotes> >  let perms xs = [ x:ps | x <- xs, ps <- perms (xs \\ [x])] in perms [1,2,3]
12:25:16 <lambdabot>   []
12:27:18 <teko> athos why did u put a $ after length ?
12:28:07 <teko> y not put it in brackets ?
12:28:21 <athos> put it in brackets works well, too!
12:28:29 <athos> <- i'm lazy :(
12:28:39 <vixey> y
12:28:40 <vixey> lol
12:29:11 <Olathe> You can never tell if a lazy person has been executed yet.
12:29:19 <athos> :)
12:29:40 <teko> how do i get the source for a func in ghci ?
12:29:55 <athos> @src sum
12:29:56 <lambdabot> sum = foldl (+) 0
12:30:04 <Olathe> I don't think you can by default.
12:30:05 <athos> :t sum
12:30:06 <lambdabot> forall a. (Num a) => [a] -> a
12:30:10 <Japsu> @remember Olathe You can never tell if a lazy person has been executed yet.
12:30:11 <athos> hm
12:30:11 <lambdabot> Done.
12:30:14 <Olathe> I think there's some weird lambdabot thing you can install.
12:30:15 <Gracenotes> does lambdabot keep some sort of internal database for the source?
12:30:34 <chrisdone> there's GHCi on Acid
12:30:35 <Olathe> I think it scans the files or something.
12:30:42 <Olathe> I'm not sure, though.
12:30:45 <Deewiant> Gracenotes: it does
12:30:48 <athos> > sum [1..2^32]
12:31:00 <lambdabot>   mueval: Prelude.read: no parse
12:31:03 <chrisdone> i.e. lambdabot for your ghci
12:31:04 <Deewiant> ?src (++)
12:31:05 <lambdabot> []     ++ ys = ys
12:31:05 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:31:07 <lambdabot> -- OR
12:31:09 <lambdabot> xs ++ ys = foldr (:) ys xs
12:31:16 <teko> > :module +Data.List
12:31:18 <Deewiant> that's obviously not straight from the source :-)
12:31:19 <lambdabot>   <no location info>: parse error on input `:'
12:31:33 <Olathe> > 2^32 * (2^32 + 1) `div` 2
12:31:35 <lambdabot>   9223372039002259456
12:31:43 <teko> , @src sum
12:31:43 <ronny> :t foldl
12:31:44 <lunabot>  luna: parse error on input `@'
12:31:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:31:47 <chrisdone> yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
12:32:31 <mmorrow> @src sum
12:32:31 <lambdabot> sum = foldl (+) 0
12:32:56 <gwern> @remember chrisdone yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
12:32:57 <lambdabot> I will never forget.
12:33:00 <daf> chrisdone: http://i35.tinypic.com/2l8fbwl.jpg ?
12:33:08 <gwern> lies, lambdabot, vicious lies!
12:33:20 <Gracenotes> > let perms xs = [x:ps | x <- xs, ps <- perms $ filter (/=x) xs ] in perms [1,2,3] -- don't quite get why this list comprehension doesn't work
12:33:21 <lambdabot>   []
12:33:51 <Gracenotes> it's not exactly a correct permutation definition, but still, it should return []
12:33:54 <Gracenotes> *not
12:34:05 <rgr> dons: hope the comments are not too frequent.
12:34:22 <gwern> @flush
12:34:49 <Gracenotes> > let perms xs = [x:ps | x <- xs, ps <- [[1]] ] in perms [1,2,3] -- don't quite get why this list comprehension doesn't work
12:34:50 <lambdabot>   [[1,1],[2,1],[3,1]]
12:34:51 <teko> sum overflows stack
12:34:51 <athos>  > let perms xs = [x:ps | x <- xs, ps <- perms $ filter (/=x) xs ] in perms [1,2,3]
12:34:53 <athos> :]
12:34:57 <teko> rather use foldl'
12:35:01 <orbitz> teko!!!!
12:35:02 <Gracenotes> oops, copying, comments
12:35:04 * Badger looks bemusedly at MyCatVerbs 
12:35:19 <chrisdone> daf: I prefer http://farm4.static.flickr.com/3173/3006290331_15c7ed47a9_o.jpg but yeah :P
12:35:19 <teko> orbitz!!!
12:35:20 <Deewiant> > let perms xs = [x:ps | x <- xs, ps <- []] in perms [1,2,3] -- I think this is what happens
12:35:22 <lambdabot>   []
12:35:23 <orbitz> teko: how does sum overflow the stack?
12:35:44 <Gracenotes> Deewiant: that makes sense.
12:35:45 <athos> orbitz: foldl?
12:35:48 <teko> it doesnt eval the expression
12:35:49 <mmorrow> foldl
12:35:50 <mmorrow> '
12:35:51 <Gracenotes> maybe there's no base case
12:35:57 <orbitz> athos: wha?
12:35:57 <orbitz> @src sum
12:35:58 <lambdabot> sum = foldl (+) 0
12:36:00 <teko> it thunks it
12:36:01 <mmorrow> *foldl
12:36:03 <mmorrow> gah
12:36:12 <mmorrow> keep hitting enter when i go for '
12:36:14 <orbitz> @src foldl
12:36:15 <lambdabot> foldl f z []     = z
12:36:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:36:15 <teko> foldl uses thunk
12:36:16 <mmorrow> foldl'
12:36:25 <athos> @src foldl'
12:36:25 <lambdabot> foldl' f a []     = a
12:36:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:36:28 <orbitz> foldl looks tail recursive to me
12:36:35 <athos> magic seq!
12:36:50 <daf> chrisdone: heh, hadn't seen that version
12:36:54 <orbitz> teko: evrything use a thunk in haskell...
12:36:56 <Gracenotes> eh, I'll find an answer in the next few years
12:37:18 <Deewiant> > let perms [] = [[]]; perms xs = [x:ps | x <- xs, ps <- perms $ filter (/=x) xs ] in perms [1,2,3]
12:37:20 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
12:37:23 <mmorrow> foldl lets its accumulator's thunk to grow without bound, whereas foldl' keeps it one-level deep
12:37:27 <teko> foldl = uber space leak
12:37:36 <Olathe> > let perms [] = [[]]; perms xs = [x:ps | x <- xs, ps <- perms $ filter (/=x) xs ] in perms [1,2,2,3]
12:37:37 <lambdabot>   [[1,2,3],[1,2,3],[1,3,2],[1,3,2],[2,1,3],[2,3,1],[2,1,3],[2,3,1],[3,1,2],[3...
12:37:39 <orbitz> indeed sum does overflow the stack
12:37:46 <orbitz> teko: how is it a spaceleak?
12:37:48 <Olathe> Ha, I have foiled your plans !
12:38:06 <vixey> @let square list = replicate (length list) list
12:38:08 <lambdabot>  Defined.
12:38:19 <vixey> > (sequence . square) "pqbd"
12:38:20 <mmorrow> @let sum'
12:38:20 <lambdabot>   ["pppp","pppq","pppb","pppd","ppqp","ppqq","ppqb","ppqd","ppbp","ppbq","ppb...
12:38:20 <lambdabot>   Parse error
12:38:27 <mmorrow> @let sum' = foldl' (+) 0
12:38:28 <lambdabot>  Defined.
12:38:34 <teko> it uses more space than i needs to
12:39:02 <orbitz> teko: it uses as much space as it needs to
12:39:09 <athos> > (sequence.square) "123"
12:39:10 <lambdabot>   ["111","112","113","121","122","123","131","132","133","211","212","213","2...
12:39:18 <vixey> @let triangle = takeWhile (not . null) . iterate tail
12:39:19 <lambdabot>  Defined.
12:39:24 <vixey> > (sequence . triangle) "pqbd"
12:39:25 <lambdabot>   ["pqbd","pqdd","pbbd","pbdd","pdbd","pddd","qqbd","qqdd","qbbd","qbdd","qdb...
12:39:28 <Gracenotes> @src square
12:39:28 <lambdabot> Source not found. My pet ferret can type better than you!
12:39:34 <athos> :t ssquare
12:39:35 <lambdabot> Not in scope: `ssquare'
12:39:37 <athos> ah
12:39:42 <athos> it's defined above, stupid me
12:39:52 <Gracenotes> oh. heh.
12:40:02 <cygnus_> what are some good haskell books?
12:40:11 <chrisdone> Real World Haskell is *the* good Haskell book
12:40:24 <Japsu> school of expression
12:40:33 <chrisdone> Buy It Now or download it!
12:40:54 <teko> > (sequence.square) "01"
12:40:56 <lambdabot>   ["00","01","10","11"]
12:40:59 <Gracenotes> chrisdone: I'm hitting the two-case-studies-in-a-row section
12:40:59 <chrisdone> Ctrl-F doesn't work on the paper version, so the oldies say
12:41:04 <tromp_> @src sequence
12:41:05 <lambdabot> sequence []     = return []
12:41:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:41:05 <lambdabot> --OR
12:41:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:41:11 <athos> :>
12:41:24 <teko> RWH for great justice
12:41:30 <cygnus_> you can download it?
12:41:43 <athos> at least you can view it online
12:42:02 <chrisdone> http://book.realworldhaskell.org/
12:42:03 <tromp_> > square "01"
12:42:05 <athos> every chapter = single .html page
12:42:05 <lambdabot>   ["01","01"]
12:42:10 <cygnus_> ah ok
12:42:19 <chrisdone> isn't there a PDF?
12:42:24 <athos> printing it is a bit.. strange ;)
12:42:30 <Gracenotes> teko: you have no chance to evaluate make your time
12:42:36 <athos> but depends on browser + printer i guess
12:42:36 <teko> lol
12:42:45 <Gracenotes> Somebody set us up the `seq`
12:43:00 <Gracenotes> <_<
12:43:32 <Olathe> Launch every zzzz...for great laziness !
12:43:53 <cygnus_> how come the print ver has such an ugly bug on it
12:43:58 <chrisdone> peyton `simon` jones
12:44:02 <athos> > (sequence.square) "zZzZzz"
12:44:03 <lambdabot>   ["zzzzzz","zzzzzZ","zzzzzz","zzzzzZ","zzzzzz","zzzzzz","zzzzZz","zzzzZZ","z...
12:44:08 <gwern> Gracenotes: are you interested in seqs?
12:44:09 <chrisdone> cygnus_: it's a stag beetle
12:44:13 <chrisdone> cygnus_: say it out loud
12:44:15 <chrisdone> STAG
12:44:17 <Olathe> > (nub.sequence.square) "zZzZzz"
12:44:19 <lambdabot>   ["zzzzzz","zzzzzZ","zzzzZz","zzzzZZ","zzzZzz","zzzZzZ","zzzZZz","zzzZZZ","z...
12:44:26 <Olathe> > (sort.nub.sequence.square) "zZzZzz"
12:44:28 <lambdabot>   ["ZZZZZZ","ZZZZZz","ZZZZzZ","ZZZZzz","ZZZzZZ","ZZZzZz","ZZZzzZ","ZZZzzz","Z...
12:44:30 <teko> > (sequence.square) "011"
12:44:31 <Gracenotes> gwern: they do seem interesting
12:44:31 <lambdabot>   ["000","001","001","010","011","011","010","011","011","100","101","101","1...
12:44:32 <athos> :>
12:44:38 <chrisdone> cygnus_: also, because that's how O'Reilly role
12:44:45 <athos> > length $ (nub.sequence.square) "zZzZzz"
12:44:46 <lambdabot>   64
12:44:50 <Gracenotes> the circumstances under which you might use one, for performance/space
12:44:52 <chrisdone> < _>
12:44:53 <athos> > length $ (sequence.square) "zZzZzz"
12:44:55 <lambdabot>   46656
12:45:28 <Olathe> > let xs = (sequence.square) "zZzZzz" in length (nub xs) == length xs
12:45:30 <lambdabot>   False
12:45:34 <gwern> Gracenotes: people interested in seqs often are interested in languages with stricter type systems like Coq
12:45:35 <Olathe> zomg
12:45:54 <Olathe> > let xs = (sequence.square) "zZzZzz" in length (nub xs)
12:45:55 <lambdabot>   64
12:45:56 <Gracenotes> isn't that a theorem-proving language..?
12:46:05 <Gracenotes> or am I confusing it with something else
12:46:08 <gwern> indeed, the relation of seq to Coq is an interesting one as it covers a lot of areas of language design
12:46:11 <chrisdone> > map toUpper "I see what you did there"
12:46:12 <lambdabot>   "I SEE WHAT YOU DID THERE"
12:46:19 <gwern> Gracenotes: investigate it perhaps. you may be surprised by Coq
12:46:23 <Gracenotes> ah, 'Coq is not an automated theorem prover but includes automatic theorem proving tactics and various decision procedures.'
12:46:28 * gwern stifles a grin
12:46:28 <orbitz> i'm trying to install QuickCheck and I'm getting an error in Exception.hs saying "Class `Exception' used as a type", anyone recognize this?
12:46:40 <gwern> orbitz: yeah, it's the new Control.Exception module
12:46:51 <Gracenotes> I'd imagine one could make some terrible puns with it, at least
12:46:52 <athos> > map toUpper "seems like RWH spawns a new wave of raging beginning haskell programmers"
12:46:53 <lambdabot>   "SEEMS LIKE RWH SPAWNS A NEW WAVE OF RAGING BEGINNING HASKELL PROGRAMMERS"
12:46:54 <athos> ;]
12:46:57 <gwern> orbitz: I think you need to either use base < 4, or import Control.OldException instead
12:46:58 <vixey> the type system is not stricter
12:47:00 <athos> ok, enough for that
12:47:02 <dons> :)
12:47:07 <dons> yay, new haskell programmers!
12:47:13 <athos> \o/
12:47:13 <dons> lambdas for all!
12:47:22 <chrisdone> Î»
12:47:25 <chrisdone> I'm just giving these away!
12:47:28 <gwern> vixey: I thought coq disallowed various haskell dodges like unsafePerformIO and bottom and various problems like that
12:47:29 <dons> orbitz: missing --constraint='base<4'
12:47:34 <athos> Lambda - Everyone should have (at least) one
12:47:39 <athos> :)
12:47:39 <teko>  Î»
12:47:40 <BONUS_> this new SPJ video owns
12:47:45 <chrisdone> The Â£25 Î»
12:47:48 <athos> BONUS: which new one?
12:47:51 <gwern> y'know, dcoutts told me that --constraint doesn't actually work in cabal-install
12:47:54 <chrisdone> BONUS: DO WANT
12:47:55 <BONUS> http://video.google.com/videoplay?docid=-4991530385753299192
12:48:06 <BONUS> dunno if its new, just saw it on reddit
12:48:09 <orbitz> dons: where do i do that?
12:48:20 <BONUS> he's just such a positive character
12:48:26 <athos> yea
12:48:31 <chrisdone> BONUS: aw, excellent. cheers
12:48:44 <dons> orbitz: hmm. actually. which ghc and which quickcheck version?
12:48:46 <BONUS> cheas
12:48:50 <dons> and which cabal-install
12:48:52 <athos> SPJ = Alan Kay - aggressivePolitics
12:48:52 <orbitz> dons: yay that owrked
12:48:55 <athos> something like that :)
12:48:57 <orbitz> dons: 6.10, latest on hackage
12:48:58 <dons> ah
12:48:59 <dons> good.
12:49:05 <athos> besides that, spj is unique of course :>
12:49:07 <Gracenotes> I'd suspect on the most esoteric minds could penetrate the deeper concepts of Coq
12:49:10 <Gracenotes> *only
12:49:42 <gwern> I'm sure experience will loosen the bowels. of one's mind
12:49:47 <chrisdone> (peyton >> jones) . simon
12:49:50 <gwern> so one could get a hand around all the concepts
12:49:52 <chrisdone> (peyton >>> jones) . simon
12:49:54 <shapr> Gracenotes: Nah, it's not that bad.
12:50:01 <shapr> Gracenotes: Everything's easy if you look at it.
12:50:06 <dons> gwern says the weirdest things
12:50:08 <dons> ?users
12:50:09 <lambdabot> Maximum users seen in #haskell: 586, currently: 565 (96.4%), active: 30 (5.3%)
12:50:17 * shapr boings cheerfully
12:50:48 <athos> ahah
12:50:48 <orbitz> is there any tool sthat automaticaly handles getting cabal depndencies?
12:50:49 <athos> active: 30
12:51:05 <Gracenotes> gwern: I'm sure everyone wants to experiment with Coq at *some* point in their lives
12:51:05 <shapr> orbitz: Cabal?
12:51:12 <gwern> dons: I was born with a congenitla deformity of my funny bone
12:51:14 <orbitz> oh cbal can do that?
12:51:15 <athos> i bet there's some strange watermark on every page of RWH which tells the reader "idle #haskell on freenode!"
12:51:17 <dons> orbitz: cabal-install
12:51:21 <shapr> athos: Yeah!
12:51:24 <dons> orbitz: as in, $ cabal install foo
12:51:26 <shapr> athos: Except, you misread it..
12:51:28 <gwern> *congenital
12:51:33 <shapr> athos: It says PARTICIPATE!
12:51:33 <dons> athos: hehe. secret mind messages
12:51:35 <chrisdone> dons: I'm using haskell for my web jawb now^___^. nice to have kibro have use for my job work
12:51:39 <dons> woo!
12:51:49 <athos> hehe ;>
12:51:51 <chrisdone> Î»-five
12:51:56 <shapr> dons: 586 is a new high water mark, yeh?
12:51:58 <dons> chrisdone: yeah, you should thank the kibro author
12:51:58 <gwern> Gracenotes: come on, using something as unflexible and stiff as Coq is just unnatural
12:52:01 <orbitz> thanks
12:52:03 <dons> shapr: yep. this time yesterday
12:52:06 <shapr> spiffy!
12:52:10 <chrisdone> dons: haha, yeah
12:52:11 <dons> :)
12:52:17 <dons> rwh bounce, shapr. (maybe)
12:52:25 * shapr bounces
12:52:30 * dons boings
12:52:36 <shapr> dons: Yeah, RWH is helping.
12:52:48 <Gracenotes> gwern: not unless you carefully lubricate your intellect
12:52:55 <shapr> dons: It's helping me convert the masses at least.
12:53:10 <dons> shapr: yes, a lot of outreach happening suddnely.
12:53:16 * Toxaris has just experimented with Coq for about two months, and is eager to learn about more flexible tools
12:53:24 <dons> oh you kids and your dependent types
12:53:24 <teko> does the author of RWH ever come here ?
12:53:27 <shapr> I say "Haskell is cool." and they say "Prove it to me." I say "Read the O'Reilly Book."
12:53:29 <dons> teko: hmm. not sure.
12:53:33 * shapr laughs
12:53:43 <martin_joerg1> :t fold
12:53:44 <lambdabot> Not in scope: `fold'
12:53:49 <shapr> teko: dons is one of the authors :-)
12:53:51 <dons> shapr: awesome.
12:53:57 * dons waves to teko
12:53:59 <teko> kool
12:54:03 <gwern> Gracenotes: coq can do some kinky things though, like turn coq proofs into running haskell code, or ocaml
12:54:07 <dons> bos too. all the authors.
12:54:08 <dolio> bos comes here, too.
12:54:11 <shapr> dons: Having an O'Reilly book is one of those sings of being a 'real' language.
12:54:14 <shapr> signs*
12:54:17 <dons> yeah. seriously.
12:54:27 <idnar> RWH is way more awesome than most O'Reilly books, though
12:54:37 <chrisdone> agreed
12:54:42 <Gracenotes> gwern: sounds interesting... I didn't know Coq swung that way
12:54:42 <shapr> idnar: truply
12:54:43 <shapr> truly
12:54:45 <dons> yay
12:54:46 <shapr> Bah, I can't type today.
12:54:51 <chrisdone> such an awesome book
12:55:08 <dons> i should write a post summarising how the haskell community works for all the new peopppple
12:55:10 <orbitz> does cabal install do a --user install by default?
12:55:11 <dons> what resources
12:55:13 <dons> orbitz: yeah
12:55:20 <shapr> dons: Good idea! What will you list?
12:55:32 <gwern> Gracenotes: you see, according to curry-howard, there's always a latent side to a proof, which is repressed and unvisible
12:55:40 <chrisdone> I remember first coming to haskell and asking what I should read, and people generally saying "well.. Gentle isn't so gentle, and YAHT is okay...". whereas now it's "RWH. RWH. read it!"
12:55:55 <vixey> gwern you rehearsed this, didn't you?
12:55:57 <shapr> And sufficient proof analysis will turn up your latent .. um what?
12:55:58 <dons> massive snow flakes falling in portland.
12:56:11 <dons> chrisdone: yeah, yaht. those were the days
12:56:13 <shapr> chYeah!
12:56:16 <shapr> bah
12:56:36 <shapr> I gotta reboot emacs, it's not happy when my irc buffers pass 200k lines in toto.
12:56:42 <shapr> Toto is too small for that.
12:56:47 <orbitz> and a --user install puts everythign in ~/.cabal by default right?  do I have to add anything to make ghc find stuff in there?
12:56:48 <gwern> vixey: I feel insulted that you think I couldn't improvise this discussion :(
12:56:54 <Gracenotes> gwern: indeed, it's up to programmers to make those repressed intellectual tendencies come out
12:57:37 <gwern> Gracenotes: but you'd be surprised at how many programmers find formal methods revolting and unnatural; they wish to stick to their vanilla imperative techniques
12:58:15 <gwern> it'll take some hard thrusting against popular opinion by the coq community, indeed, if they wish to be unmarginalized or not stuck in an academic ghetto
12:58:30 <dons> oh please.
12:58:54 <Gracenotes> meh, it's their loss, sticking to their imperitonormative paradigms
12:59:03 <gwern> dons: come on, it's possible! haskell seems't've risen to the occasion
12:59:04 * idnar groans @ gwern
12:59:08 <vixey> @vera imperitonormative
12:59:09 <lambdabot> No match for "imperitonormative".
12:59:20 <dolio> You think that's an acronym?
12:59:22 <gwern> vixey: Gracenotes is riffing off of 'heteronormative'
13:00:15 <dons> btw, i think i found a new "why static typing is useful" metaphor, http://www.reddit.com/r/programming/comments/7jf7x/as_soon_as_we_started_programming_we_found_to_our/c06tl1x
13:00:35 <blackh> I need help! Why does ghc say "Type constructor `Exception' used as a class" (referring to the type class Exception) when I build with 'cabal install' but not when I build with 'runhaskell'? It's as if cabal makes it no able to see the type class (there's also a type constructor of the same name).
13:00:58 <dons> blackh: it is due to different versions of the base library
13:01:13 <dons> cabal install should actually figure that out, normally it would be runhaskell that fails
13:01:15 <roconnor> @type forAll
13:01:17 <lambdabot> forall a prop. (Testable prop, Show a) => Gen a -> (a -> prop) -> Property
13:01:21 <dons> either way, you need to say: --constraint='base<4'
13:01:26 <vixey> more metaphors getting in the way of understanding things?
13:01:26 <Gracenotes> well, that was a vigorous discussion, gwern. Let's be careful not to do it too often, lest our standards of judgment become distended.
13:01:34 <int-e> dons: it's the opposite problem I think
13:02:00 <dons> int-e: oh, maybe. if the code needs base 4.* but doesn't say so.
13:02:00 <int-e> blackh: put a build-depends: base = 4.*  in the cabal file?
13:02:04 <roconnor> @type vectorOf
13:02:06 <lambdabot> forall a. Int -> Gen a -> Gen [a]
13:02:14 <int-e> blackh: err. base == 4.*
13:02:31 <blackh> Thanks! My package is using base-4 features, and I just added base >= 4 to dependencies and it fixed it.
13:02:54 <dons> yeap.
13:03:03 <roconnor> I can't wait until Cabal uses interfaces instead of versions
13:03:03 <dons> cabal install prefers base-3 when it tries to guess which base you want
13:03:07 <dons> runhaskell just uses the latest.
13:03:12 <dons> roconnor: you working on it?
13:03:17 <roconnor> nope
13:03:19 <dons> cabal functors?
13:03:22 <roconnor> I'm working on my thesis
13:03:22 <dolio> He can actually wait.
13:03:23 <vixey> Cabal is getting ready to break again lol
13:03:25 <roconnor> :)
13:03:46 <gwern> Gracenotes: eh, I like to discuss with anything that moves. I'll know I've gone to far when people tell me to sit on it
13:03:57 * dons is happy to see all these cabal users
13:04:02 <dons> anyone else got a cabal tshirt?
13:04:16 <roconnor> cabal has a nice logo
13:04:20 <roconnor> who designed it again?
13:04:23 <gwern> dons: I'm sure there are TINC shirts floating around
13:04:25 <chrisdone> Cale?
13:04:34 <dons> http://haskell.org/haskellwiki/Merchandise that one.
13:04:35 <roconnor> that's what I thought
13:04:36 <dons> roconnor: cale.
13:04:57 <dons> oh, there's some other nice haskell tshirts there
13:05:05 <roconnor> Cale has a distrubingly good sense of asthetics
13:05:13 <chrisdone> haha
13:05:13 <roconnor> aestetics?
13:05:16 <dons> "Hakell logo hotpants"
13:05:24 <chrisdone> aesthetics was right
13:05:43 <dons> i like the logo they use, http://image.spreadshirt.net/image-server/image/configuration/13215127/producttypecolor/2/type/png
13:05:47 <dons> simple, pure.1
13:05:53 <chrisdone> ooooo
13:05:58 <chrisdone> I really like that
13:05:58 <dons> maybe that's the solution to clean up the current logo...
13:05:59 <Badger> I wonder where people actually wear these things.
13:06:10 <chrisdone> I prefer that to the "pick and mix" current one
13:06:12 <gwern> Badger: around college campuses
13:06:23 <Badger> ah
13:06:24 <dons> yes. i think actually we're on to something here.
13:06:34 <dons> let's get a few variants of that together, and then propose to change...
13:06:52 <BONUS> uh
13:06:59 <dons> hey BONUS
13:06:59 <Badger> hahaha
13:07:00 <BONUS> but isnt that basically the half life logo though?
13:07:01 <Badger> http://www.cafepress.com/HaskellHackers.71014523
13:07:02 <BONUS> heyo :]
13:07:13 <chrisdone> I guess it's like the half-life logo
13:07:19 <dons> the half life logo is post-haskell
13:07:21 <chrisdone> bt they're kind of in different fields, haha
13:07:25 <dons> haskell's been using circle + lambda for ages
13:07:32 <BONUS> true that
13:07:51 <orbitz> is this channel okay to ask cabal questions on?
13:07:54 <gwern> I'm sure Valve's lawyers will be deterred by that
13:08:08 <Gracenotes> Haskell programmers do it in a monad... hm, but what about unintended side-effects?
13:08:13 <dons> its kind of the new position for haskell, that circle logo: pure.
13:08:18 <dons> rather than "we got all this cool stuff1"
13:08:19 <chrisdone> Gracenotes: haha, wat
13:08:32 <BONUS> yeah that logo with the >>= and :: and whatnot has too much going on
13:08:34 <Gracenotes> chrisdone: from http://www.cafeshops.com/doitmonad
13:08:43 <chrisdone> dons: organised, serious business
13:08:48 <dons> yeah.
13:08:52 <chrisdone> but nice blue^_^
13:08:56 <vixey> BONUS, don't know it's the best logo in the world!?
13:09:02 <BONUS> haha
13:09:07 <vixey> @go Xah Lee Haskell Logo
13:09:09 <lambdabot> No Result Found.
13:09:16 <chrisdone> oh gods
13:09:22 <BONUS> Mercurial had a nice logo overhaul not long ago
13:09:22 <dons> no no. don't
13:09:24 <chrisdone> xah lee haskell logo?
13:09:26 <chrisdone> haha
13:09:32 <BONUS> they went from this http://pvergain.files.wordpress.com/2007/07/mercurial-logo1.png
13:09:39 <BONUS> to this http://www.straw-dogs.co.uk/wp-content/logo-droplets-200.png
13:09:49 <chrisdone> 40
13:09:53 <BONUS> gah!!
13:09:53 <dons> something capturing the essential purity of the language. de-emphasising all the crazy stuff we got going on.
13:09:58 <dolio> @quote xahlee logo
13:09:58 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
13:10:01 <BONUS> http://blogs.sun.com/richb/resource/mercurial_logo.png
13:10:28 <gwern> BONUS: you're right; the second is superior
13:10:48 <dons> one of the oldest logos, http://www-i2.informatik.rwth-aachen.de/Forschung/FP/logo.gif
13:10:53 <baaba> that really reminds me of logitech's logo
13:10:55 <BONUS> ahaha
13:10:55 * gwern wonders if terser would be better - 'haskellers do it monadically'
13:10:56 <dons> the := with a cross.
13:10:57 <opqdonut> dons: :D:D
13:11:09 <sabren> hey guys... is there a way to put a guard on a constructor?
13:11:11 <chrisdone> BONUS: yeah.. I've noticed logos tend to get simplier, rounder, bolder and smoother... reminds me of mIRC's new web site which I only saw recently. it's all Web 2.0 and stuff
13:11:12 <dons> that's the first haskell logo i recall, the := one
13:11:22 <Gracenotes> gwern: I still think there's a joke to be made about side-effects >_>
13:11:24 <vixey> sabren, no
13:11:28 <gwern> the := alone would be a good general FP logo
13:11:34 <orbitz> i have doen cabal install on a few packages, however when i try to do runhaskell Setup.hs configure in another package, it does nto find the binary package i installed, do i need ot modify my ghc config in some way (note, ghc-pkg shows the package installed)
13:11:39 <vixey> := ??
13:11:45 <vixey> you're not thinking ALGOL gwern?
13:11:48 <zaitcev> I wonder if it's possible to create tabs with Gtk2Hs
13:11:50 <BONUS> that's trends for you i guess, but i think a good logo never becomes old-looking
13:11:57 <gwern> Gracenotes: the only thing I could think of is 'haskellers do it with side-effects' but that's not really accurate
13:12:15 <dons> no assignment. no side effects
13:12:18 <gwern> vixey: := is understood to mean assignment, yes. don't ask me, ask the logo
13:12:19 <RayNbow> dons, I extended the Fibonacci HaWiki page earlier this day :)
13:12:19 <dons> then phase 2 was: we got cool stuff
13:12:27 <dons> now phase 3: pure fp.
13:12:28 <vixey> what s that got to do with haskell?
13:12:34 <dons> RayNbow: i saw. good
13:12:49 <gwern> (1) disallow side-effects 2) ??? 3) Cool stuff!)
13:12:56 <vixey> oh gwern did you see this wiki page?
13:12:59 <gwern> vixey: I said 'good general FP logo'
13:13:02 <teko> (3) profit
13:13:03 <vixey> @wiki Data.List.Split
13:13:04 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
13:13:08 <sabren> vixey... hrm... so how would you model a data type that contains a number, but is only valid for certain numbers (like say a playing card?)
13:13:09 <dons> gwern: 2) is work really hard for 20 years on compilers
13:13:14 <vixey> yeah still clueless what := has to do with fp
13:13:14 <chrisdone> BONUS: 2007: http://web.archive.org/web/20070101152335/http://mirc.com/  and now http://www.mirc.com/
13:13:14 <gwern> vixey: I did
13:13:20 <Gracenotes> yum, curried rice and lentil soup
13:13:30 <dons> sabren: via either smart constructors or a new data type
13:13:30 <chrisdone> isn't `:=' from PASCAL or whatever?
13:13:36 <chrisdone> "no imperative programming!"
13:13:44 <BONUS> haha yeah the site got better imho
13:13:44 <chrisdone> or, no assignment, anyway
13:13:51 <gwern> vixey: did that page incorporate all the implementations from the split repo?
13:13:56 <Toxaris> so we use "<-" instead of ":=" and everything is so much cooler now ...
13:14:03 <BONUS> simpler and less stuff = better
13:14:04 <vixey> gwern no
13:14:08 <sabren> := is hard core pascal assignment!
13:14:29 <vixey> := is in timber too
13:14:42 <chrisdone> I have heard of timber
13:14:45 <augustss> Mmmmm :=
13:14:55 <sabren> toxaris: <- and := aren't the same operator though
13:14:56 <chrisdone> heh
13:15:02 <teko> dons im spreading the gospel of haskell and RWH in south africa for what its worth
13:15:04 <dons> ok. i sent a little note on 'time for a new logo' to the list.
13:15:13 <dons> teko: wow. do you have a copy in South Africa?
13:15:24 <teko> not a hard one no
13:15:27 <teko> its too expensive
13:15:30 <dons> yeah.
13:15:33 <dons> same in australia.
13:15:39 <dons> good thing we have it online.
13:15:41 <augustss> dons: Tell Foyles here in London to stock RWH.  I want to buy a copy.
13:15:49 <teko> 700 rands thats almost 1/4 of my salary
13:15:49 <dons> Foyles, eh?
13:15:50 <chrisdone> someone upvote my blog post so more people know that formlets are awesome: http://www.reddit.com/r/programming/comments/7jg52/haskell_formlets_composable_web_form_construction/
13:16:00 <BONUS> done
13:16:02 * RayNbow is still waiting for his RWH copy...
13:16:03 <augustss> dons: Or any book store
13:16:03 <daf> Foyles is a great bookshop
13:16:05 <dons> augustss: yeah, seems to keep selling out in uk.
13:16:13 <Peaker> dons: does Orielly have no copyright claim on books they publish, and no problem that they're freely online?
13:16:27 <dons> augustss: ganesh's and njbartlett's orders both delayed after amazon ran out.
13:16:39 * chrisdone five-highs BONUS
13:16:40 <dons> Peaker: of course they do. they let us use a CC license.
13:16:46 <BONUS> ^5!
13:17:00 <dons> so you are constrained in particular ways wrt. the online version -- no commercial use.
13:17:04 <augustss> dons: when are you putting the updated version online?
13:17:21 <dons> still waiting to get the xml back. but hopefully before jan uni courses start
13:17:26 <gwern> I wonder what o'reilly's makes of the founder's copyright CC license
13:17:27 <dons> so we can start collecting new commentary
13:17:29 <Toxaris> sabren: some people use "<-", some ":=", some both, to denote either "evaluate something and name the result" or "evaluate something and store the result" or both
13:18:18 <dons> augustss: i'll investigate the state of rwh in the UK.
13:18:26 <dons> find out what the story is.
13:18:37 <sabren> toxaris: yeah, but i meant that in pascal := means assignment and in haskell <- is for naming
13:18:40 <augustss> dons: thanks!
13:18:44 <BONUS> dons: im interested why you didnt include a share-alike clause
13:18:51 <Peaker> how does Amazon already have "Used & New" RWH copies?
13:18:51 <BONUS> in your CC license
13:19:07 <chrisdone> Peaker: a flaw in de system!
13:19:09 <orbitz> Peaker: othe rbook distributors go throuhg amazon
13:19:10 <Toxaris> sabren: sure, but there are other languages then pascal and haskell, and both := and <- are very often used in informal syntax (pseudocode), too
13:19:16 <BONUS> Peaker: time travellers
13:19:19 <dons> Peaker: i think it isn't actually 'used'
13:19:22 <dons> just resellers
13:19:51 <Peaker> gonna get my workplace to order it then :)
13:20:07 <Toxaris> sabren: so while the Haskell semantics may be cooler then the Pascal semantics, I find it silly to extend that to the Haskell syntax
13:20:16 <Peaker> I wonder what the shipment price to Israel is though
13:21:03 <Toxaris> more importantly, I consider do-notation a surface feature, and often a distraction from the real point of Haskell, so I would rather not capitalize on it in promoting Haskell
13:21:33 <Peaker> Toxaris: OTOH, it may show people that Haskell is in fact multi-paradigm and also supports their favorite paradigm, to lower their defenses
13:21:38 <chrisdone> what are you trying to say, you don't like monads?
13:21:46 <twadleigh> RWS, Ch. 18, talks about monad transformers with IO at the bottom of the stack. I'm trying to analogize to combining the a writer monad with ST. I'm struggling. I'm putting ST at the bottom. Is that right?
13:21:59 <b_jonas> ST is hard
13:22:07 <newsham> peaker: does printing out the web version count as a "used" copy?
13:22:11 * bos gets back from lunch with Andre Pang.
13:22:24 <Peaker> newsham: according to what dons said above, that's probably not legal
13:22:27 <bos> twadleigh: yes, that's fine.
13:22:30 <chrisdone> hi bos
13:22:36 <BONUS> Haskell: no need to consult your doctor about side-effects
13:22:42 <bos> hi chrisdone
13:22:52 <newsham> bo`s
13:23:19 <twadleigh> bos: thanks. I'll struggle on, then...
13:23:20 <sabren> toxaris: i get what you're saying... i guess i didn't take that logo with the := on it to be a complaint against a particular syntax
13:23:47 <dons> bos, you surived an ozone attack :)
13:23:56 <bos> dons: i did, indeed
13:24:31 <Cale> twadleigh: it shouldn't be hard...
13:24:31 <sabren> anyone: if I can't put a guard on a constructor, how can I model a playing card? just let it have the -25334343 of hearts? or do I have to create my own numbers (One, Two Three...?)
13:24:31 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:24:54 <Toxaris> chrisdone: I like monads (the concept, the fact that the concept can be expressed somewhat typesafe in Haskell). I do not particulary like do-notation, because in my limited experience, alternatives are often better suited to express what one wants, while using much less machinery, e.g. no special syntax
13:24:55 <Cale> twadleigh: you'd have something like...
13:25:01 <vixey> sabren, don't write any code that computes -25334343
13:25:01 <Cale> runST (runWriterT (do x <- lift (newSTRef 0); lift (writeSTRef x 1); tell ["hello"]; lift (readSTRef x)))
13:25:26 <sereven> wow, how many other O'Reilly books offer live free support with the authors?
13:25:31 <bos> Cale: it might be tricky to typecheck without an explicit signature, maybe?
13:25:34 <Peaker> sabren: you can have hidden constructors, and guarded functions that call the constructors
13:25:43 <Cale> bos: That code there typechecks
13:25:52 <gwern> sereven: well, larry wall idles on IRC often
13:25:54 <twadleigh> Cale: yes the explicit signature has been an issue
13:26:00 <dolio> Maybe he's using $.
13:26:01 <Cale> sabren: You can create a function which makes playing cards and checks that the number is in range.
13:26:06 <dons> i always wanted to use this, http://www.reddit.com/r/programming/comments/7jf7x/as_soon_as_we_started_programming_we_found_to_our/c06tnsq
13:26:28 <twadleigh> Cale: I've been hoping to rely on inference to get the types right, but the need to be specific about the instance of WriterMonad has made it difficult
13:26:45 <Cale> You shouldn't have to be specific...
13:26:46 <vixey> dons http://mumble.net/~campbell/images/HM-t-shirt.png
13:27:05 <dons> yeah, i chose System Fc though, since you can actually do useful proofs in that :)(
13:27:09 <sabren> Peaker: hidden by not exporting the type name?
13:27:10 <twadleigh> Cale: thanks for the the little code tidbit. I'll try to make a little progress from that.
13:27:20 <dons> HM is for the weak of constitution.
13:27:31 <vixey> uhh.. ok
13:27:32 <Peaker> sabren: by not exporting the constructor names
13:27:34 <dons> :)
13:27:35 <dolio> dons: Fc is pretty fancy. :)
13:27:48 <Peaker> sabren: (data constructors)
13:27:51 <chrisdone> dolio: always wanted to use what?
13:28:02 <Cale> The appropriate monad is something like  WriterT w (ST s)
13:28:04 <chrisdone> oh, haha
13:28:12 <MyCatVerbs> dons: bah. At least it's sound, decidable and can still be recreated from scratch if you strip all the annotations.
13:28:18 <Toxaris> sabren: http://www.haskell.org/haskellwiki/Smart_constructors
13:28:19 <dons> Cale: !
13:28:24 <dons> Cale: your time is now.
13:28:33 <Cale> What?
13:28:36 <dons> a new year, a new, mature logo: http://image.spreadshirt.net/image-server/image/configuration/13215127/producttypecolor/2/type/png
13:28:41 <Botje> THE TIME FOR CALE IS NOW.
13:28:47 <dons> can you work with that to produce the true "pure" mature logo for the haskell community?
13:28:52 <gwern> it's always cale time
13:28:53 <dons> not the "we got fancy stuff"
13:28:59 <Cale> hehe
13:29:02 <gwern> stop! Cale time!
13:29:07 <gwern> (break it down now y'all)
13:29:13 <Cale> (you mean the rules for system Fc?)
13:29:16 <Cale> oh
13:29:17 <BONUS> maybe that lambda in a circle should have some more space
13:29:25 <Cale> Somehow I missed that other link :)
13:29:26 <BONUS> i.e. make the circle a bit wider and thinner
13:29:33 <BONUS> also a different typeface for the lambda
13:29:33 <dons> Cale: its almost a return to the clasic (No :=) logo.
13:29:34 <BONUS> that would work
13:29:40 <dons> de-emphasising all our funky tricks and treats
13:29:49 <Gracenotes> are there any other programming languages that use lambda as a logo?
13:29:50 <dons> and instead: pure fp. we have it.
13:29:55 <MyCatVerbs> "CaÎ»eskeÎ»Î»: because (.) == fmap, dammit."
13:29:58 <Cale> Gracenotes: Lots of them.
13:29:58 <vixey> Gracenotes, yes look at the Xah site
13:29:59 <dons> Gracenotes: lisp variants and scheme.
13:30:07 <dons> MyCatVerbs: haha
13:30:14 <vixey> http://xahlee.org/UnixResource_dir/lambda_logo.html
13:30:28 <gwern> is xah still as crazy as ever?
13:30:34 <Gracenotes> ah, of course. Scheme was the one I was thinkin' of
13:30:35 <sabren> Toxaris: huh.. that solves part of the problem. thanks! but if I hide the constructors, don't I lose the ability to pattern match?
13:30:47 <vixey> gwern, he's still got a relevant and well written webpage ..
13:31:07 <dons> the clojure guys shouldn't have a modern logo while we don't..
13:31:15 <Toxaris> sabren: unfortunately yes
13:31:40 <dons> Cale: interesting circle themes, http://www.logodesignlove.com/obama-08-logo-design-options
13:31:42 <sabren> Toxaris: ah.. fair enough
13:31:48 <vixey> clojure logo is like something off a yogurt with bioactive whatever it is
13:31:50 <sabren> here's an awesome lambda logo.. :) http://www.google.com/images?q=tbn:8G0_ykmuhj0J
13:31:55 <dolio> @quote xahlee note
13:31:55 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
13:32:01 <chrisdone> the Clojure logo is sweet
13:32:07 <twadleigh> Cale: the bit I think I had been missing was simply 'lift' (instead of liftM). Thanks again.
13:32:09 <chrisdone> (in simplicity)
13:32:21 <BONUS> two of those obama logos remind me of olympic logos
13:32:23 <dons> Cale: so are you interested. i think you can do this :)
13:33:27 <Toxaris> thats not fair, scheme should have "(lambda ...)" as a logo, so we could use a real lambda symbol
13:33:41 <orbitz> dons: i wonder why some peopel are so reticent about haskell's type system (i.e. MSDN)
13:34:02 <Gracenotes> perhaps we should have a commemorative keyboard with an extra lambda key...?
13:34:02 <dolio> Some people are reticent about type systems.
13:34:07 <sabren> toxaris: or how about :    \
13:34:12 <dolio> MSDN is kind of a troll, though.
13:34:23 <dolio> As far as I recall.
13:34:25 <dons> orbitz: type systems in general. lack of understanding usually, and feeble brains incapable of formal argument.
13:34:31 <b_jonas> hi, all. here are some questions. firstly, how can I find out the dependencies of a cabal package I've downloaded?
13:34:32 <dons> dolio: indeed.
13:34:41 <Toxaris> sabren: interesting idea. a circle and a backslash -> very simple and clean :)
13:34:44 <Botje> b_jonas: check the .cabal file
13:34:54 <dolio> He's not as accomplished as qwe1234, of course.
13:34:56 <Botje> b_jonas: or just try to configure it, and it'll complain about dependencies
13:35:16 <orbitz> i think a lot of peopel don't liek C/Java's type system.  thats how i was at least.  I didn't liek it so I wen tto python because it seemed so much more powerful
13:35:16 <chrisdone> haha, http://www.reddit.com/r/programming/comments/7jf7x/as_soon_as_we_started_programming_we_found_to_our/c06tnty
13:35:16 <gwern>  @quote qwe
13:35:18 <chrisdone> must be a troll
13:35:34 <gwern> @quote qwe
13:35:35 <lambdabot> glguy says: [concerning qwe1234] that God hasn't smote him yet is an argument against said God's existence..
13:35:36 <sabren> or maybe use the various monad operators since that seems to set haskell culture apart from other functional languages
13:35:39 <ski_> (our dear xah appears to have missed <http://barzilay.org/images/CS212/cs212f.jpg>)
13:35:52 <MyCatVerbs> gwern: you say that, and yet his pages on logos appear to be both lucid and informative. =)
13:36:04 <dolio> Wow, that's pretty good.
13:36:20 <BONUS> orbitz: yeah me too. but then when i went from python to haskell i saw that Java's type system is more of a big hack than a type system
13:36:24 <chrisdone> Your Brain On Scheme
13:36:29 <gwern> MyCatVerbs: if he was *completely* insane, he would've walked into a car or off a cliff long ago. I'm sure he has his moments of lucidity
13:36:30 <b_jonas> Botje: ok, thanks, the .cabal file does list them
13:36:46 <b_jonas> so cabal handles or-connected dependencies
13:36:49 <b_jonas> that's good
13:36:51 <new2hskl> hi: http://hpaste.org/13075 ...  similar "abc11" "abc1" is TRUE, now similar "11abc" "1abc" should be TRUE also! But it is false, what can I do to make it TRUE?
13:36:59 <b_jonas> (it sucks how CPAN does not)
13:37:04 <orbitz> BONUS: yeah.  Haskells type system is mor eliek "oh I *can* do what id d in python, and now it' safe" where as Java's type system wouldn't even let me reasonable do that
13:37:31 <dolio> Xah Lee has some valid opinions. For instance, he realizes that emacs lisp sucks.
13:37:33 <MyCatVerbs> orbitz: are you sober?
13:37:40 <Cale> dons: Well, I can play around with it if you like :)
13:37:42 <Toxaris> I think its not Javas type system which holds you back, but Javas general inexpressivity
13:37:47 <dolio> Of course, he also thinks people care that it sucks, which is probably wrong.
13:37:58 <dons> Cale: i think it is the first serious direction for a new logo.
13:37:59 <BONUS> also, im a terrible person. i just used haskell to cheat on a facebook scrabble like game where you have to make words out of 6 letters
13:38:00 <newsham> java is pretty expressive, it just makes you type a whole lot
13:38:01 <gwern> dolio: he also realizes 2+2 = 4. I don't give him much credit for holding a few right opinions
13:38:08 <Gracenotes> what the hell, -1350 comment karma
13:38:14 <Gracenotes> that takes talent :/
13:38:14 <MyCatVerbs> dolio: mmmm, but every Yegge reader on the planet probably thinks that elisp sucks by now. h ;P
13:38:15 <dons> Cale: and i propose replacing the existing one with something like that.
13:38:24 <BONUS> i made a function that generates permutations and then checks them as prefixes agains a wordlist :[
13:38:35 <orbitz> MyCatVerbs: never
13:38:37 <Cale> new2hskl: I think I'd need some more examples or a proper description of what you're attempting to write in order to decide how to fix it.
13:38:43 <Toxaris> newsham: since every turing-complete language can do everything, I would say expressive = can do it without much typing
13:38:52 <MyCatVerbs> orbitz: sehr gut. ^^
13:39:00 <orbitz> BONUS: that game is fun
13:39:03 <MyCatVerbs> newsham: that... no. Just no.
13:39:03 <newsham> ie:   new F<String,Unit>() { public Unit call(String arg) { System.out.println("arg: " + arg); return Unit.unit; }};
13:39:04 <Cale> new2hskl: Is "1abc" similar to "111111111111abc"?
13:39:05 <vixey> Toxaris, I don't find "turing-complete" has much to do with the expressivity of a language at all
13:39:07 <chrisdone> eli barzilay has some cool lambda art. this is what Dr Scheme shows on his birthday, and yes, the symbols rotate: http://img406.imageshack.us/img406/4841/whattheve9.png
13:39:20 <Toxaris> vixey: yep, as I said
13:39:21 <teko> the clojure logo is the best
13:39:48 <newsham> instead of say    \s -> putStrLn ("arg: " ++ s)
13:39:53 <MyCatVerbs> I prefer the hallucinatory Chicken Scheme one. =)
13:39:58 <Toxaris> vixey: so the argument "you can do it in Java" has nothing to do with expressivity, the question is: can you do it nicely, cleanly, ...
13:40:16 <newsham> toxaris: I dont see how turing-complete is relevant here
13:40:23 <chrisdone> MyCatVerbs: link please ;)
13:40:36 <chrisdone> MyCatVerbs: oh, the one pasted above. yeah..
13:40:37 <sabren> new2hskl: your recursion never actually invokes the the comparison against two characters
13:40:49 <Toxaris> newsham: well, ignore turing-complete if you want.
13:40:50 <athos> does anybody know if there's a package on hackage which provides some Turtle graphics?
13:40:52 <teko> chrisdone: http://xahlee.org/UnixResource_dir/lambda_logo.html
13:40:58 <teko> near the bottom
13:41:01 <vixey> turing-complete is a _really_ strange way to say general recursive
13:41:25 <athos> dunno if it'd be a big deal to write one on one's own, but would be quite nice if someone has already hacked one
13:41:27 <MyCatVerbs> chrisdone: I'd post you a more direct link, but there aren't any anchors in that page and I don't want to hotlink the images. =)
13:42:03 <newsham> athos: http://www.thenewsh.com/~newsham/x/machine/turtle/ has some simplistic stuff
13:42:14 <new2hskl> Cale: No, its like: "ab11" == "ab1" ... or: "ab1Id" == "abld" ... or "ab11Id" == "abIld" ...
13:42:15 <newsham> using gtk2hs
13:42:22 <athos> ah cool!
13:42:26 <gwern> @quote tarpit
13:42:27 <lambdabot> No quotes match. You type like i drive.
13:42:50 <athos> newsham: thanks
13:42:54 <Cale> new2hskl: I don't get how the strings of different lengths are similar...
13:42:57 <newsham> my pleasure
13:43:20 <new2hskl> Cale: you can take two 11 for one 1
13:43:24 <new2hskl> its the same
13:43:32 <Cale> Does that apply to any character?
13:43:34 <new2hskl> aehm.. i mean its similar
13:43:37 <Cale> Or just to 1?
13:43:46 <sclv> maybe bind would make a more distinctive logo than lambda.
13:44:11 <athos> newsham: which license does your code use?
13:44:12 <sclv> (>>=)
13:44:24 <newsham> public domain.
13:44:25 <Toxaris> what about   ::   for a logo? we are statically typed, after all
13:44:34 <athos> ok, so you'll get a mentioning ;)
13:44:38 <gwern> @remember AlanPerlis Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13:44:39 <lambdabot> Done.
13:44:43 <newsham> athos: if you wanna.
13:45:05 <gwern> @quote value
13:45:06 <lambdabot> monochrom says: recursive directory search is an alpha-beta with boring values of alpha and beta.
13:45:11 <gwern> @quote value
13:45:12 <lambdabot> newsham says: C programmers know the cost of everything and the value of nothing.
13:45:15 <gwern> @quote value
13:45:15 <lambdabot> newsham says: functional programmers know the value of everything and the cost of nothing
13:45:16 <Toxaris> and it could be easily re-interpreted as meaning four interesting properties (chosen anew everytime something new is hot)
13:45:22 <vixey> how about  head []   for the haskell logo?
13:45:28 <BONUS> lol
13:45:31 <gwern> @remember AlanPerlis A LISP programmer knows the value of everything, but the cost of nothing.
13:45:31 <lambdabot> Done.
13:45:37 <gwern> @flush
13:45:48 <sabren> Toxaris: hmm.. now that i think about it, loss of pattern matching with those smart constructors is a good thing... it forces you to encapsulate the data
13:45:52 <dolio> Toxaris: But then most people from other languages will think we're about consing.
13:46:07 <new2hskl> Cale: Sorry, i have to look at first myself ill tell you in some minutes
13:46:25 <vixey> sabren, you can use views on them but it's still a crap idea
13:46:28 <Toxaris> dolio: yeah thats bad.
13:46:58 <sabren> vixey: what's a view, and why is it a crap idea?
13:47:07 <Toxaris> my personal favorite would be the type of curry, hinting both at the patron of the language, static typing, and first-class functions
13:47:10 <vixey> sabren, a way of looking at something
13:47:13 <roconnor> @djinn (A -> Not (Not B)) -> Not (Not (A -> B))
13:47:14 <lambdabot> Error: Undefined type A
13:47:19 <Toxaris> but thats not good for a logo of course :(
13:47:22 <roconnor> @djinn (a -> Not (Not b)) -> Not (Not (a -> b))
13:47:23 <lambdabot> f a b = void (b (\ c -> void (a c (\ d -> b (\ _ -> d)))))
13:47:40 <Toxaris> is there an equivalent of "both" for three points in english?
13:47:42 <teko> i like this lisp logo : http://xahlee.org/UnixResource_dir/gki/lambda/lisp-big.png
13:47:55 <vixey> sabren you can use the Fin family in haskell
13:48:03 <Gracenotes> teko: Error 403 - Forbidden, very... creative
13:48:06 <vixey> sabren, if you want a type with n different symbols in it
13:48:11 <sabren> vixey: view like a second type that provides a different view of the same data?
13:48:22 <vixey> sabren, exactly yes
13:48:24 <Gracenotes> oh, never mind. Must have been a fluke.
13:48:31 <chrisdone> teko: that logo is clever, but kind of horrible, too
13:48:40 <conal> Toxaris: i guess the best we have is "all three"
13:48:43 <BONUS> hmm
13:48:48 <vixey> for viewing something as a natural number you could use like
13:48:48 <Toxaris> sabren: but encapsulation is not always a good idea
13:48:51 <BONUS> how about Haskell, only instead of the a there's a lambda
13:48:54 <vixey> data NatView a = Zero | Succ a
13:49:07 <roconnor> @type (b (\ c -> void (a c (\ d -> b (\ _ -> d)))))
13:49:09 <lambdabot> Not in scope: `void'
13:49:23 <roconnor> @type \void -> (b (\ c -> void (a c (\ d -> b (\ _ -> d)))))
13:49:25 <lambdabot>     Couldn't match expected type `(t2 -> t1) -> t'
13:49:25 <lambdabot>            against inferred type `Expr'
13:49:25 <lambdabot>     In the expression: b (\ _ -> d)
13:49:41 <chrisdone> I rate like the one dons posted from the t-shirt
13:49:49 <dons> ?users
13:49:49 <lambdabot> Maximum users seen in #haskell: 586, currently: 566 (96.6%), active: 30 (5.3%)
13:50:04 <Saizan> @type \void a b -> (b (\ c -> void (a c (\ d -> b (\ _ -> d)))))
13:50:05 <lambdabot> forall t t1 t2 t3. (t3 -> t1) -> (t -> (t1 -> t2) -> t3) -> ((t -> t1) -> t2) -> t2
13:50:41 <new2hskl> Cale: It is like this: you have three Chars c,d and e... if they are similar eachother then the Strings cd is similar to e and c is similar to de
13:51:34 <roconnor> why do all the bots use void to turn False into False
13:51:38 <Cale> and presumably, ce is similar to d, and all the other combinations like that?
13:52:42 <Toxaris> sabren: how do you handle the non-numeric ranks, by the way? Maybe   data Rank = Ace | King | Queen | Jack | Ten | Nine | ... | Two   would be actually appropriate
13:52:43 <b_jonas> ce is similar to a actually
13:52:50 <b_jonas> but my handwriting is ugly
13:53:00 <new2hskl> Cale: Yes
13:55:28 <newsham> toxaris: if you count them from Two through Ace you can derive Enum,Ord,Eq etc
13:55:32 <sabren> Toxaris: yeah, that was my first plan. i was trying to get clever and come up with some more compact notation. maybe I should just do that and then make a little function like (# "2c")
13:55:35 <Cale> new2hskl: okay...
13:56:06 <sabren> the other option was just to make:  jack = 11     queen = 12    etc
13:56:10 <Cale> new2hskl: Assuming that simChar remains an equivalence relation, then what you might want to do is to first write a function which normalises a string.
13:56:14 <Toxaris> newsham: how can I not do that when I count them from Ace to Two?
13:56:29 <Toxaris> newsham: but Ord is a problem, because the cards are ordered differently for different games
13:56:37 <newsham> toxaris: you can still do that, but then you have King < Eight?
13:56:40 <dons> yay chrisdone http://www.reddit.com/r/programming/comments/7jg52/haskell_formlets_composable_web_form_construction/
13:56:48 <sabren> Toxaris: you wand the Hand to have Ord, not the individual cards
13:56:50 <chrisdone> :D!!
13:56:51 <lucca> sabren: if you do it that way, Five > Six
13:56:52 <newsham> toxaris: use different definitions for different games?
13:57:00 <Cale> new2hskl: That is, start by picking one element of each equivalence class of characters.
13:57:04 <lucca> if you use deriving
13:57:24 <sabren> lucca: ? you lost me
13:57:28 <Cale> new2hskl: Say, 0 for the class {0,O}, u for {u,v} and l for {l,I,1}
13:57:35 <newsham> sabren: having cards have Ord can be useful in implementing Ord on hands
13:57:51 <BONUS> im still browsing the 6.8.3 documentation because you cant view the source in the newer ones :[
13:57:56 <lucca> if you implement ord just by saying deriving (Ord), then it assigns them value in order
13:58:01 <Toxaris> but then you need the correct Ord for you game, which leads straight to newtype hell
13:58:20 <Cale> new2hskl: Then replace all letters from each class with the chosen representative, and remove adjacent pairs of them from the resulting string.
13:58:23 <sabren> newsham: agreed. i just meant that you can't derive hand strength solely from the ranks of the hands. but yes, you need both
13:58:32 <lucca> hmm, perhaps the faces shouldn't be in Ord then
13:58:34 <Toxaris> but since Ord is generally nice (think Data.Map), deriving (Eq, Ord, Enum) is the way to go, I guess
13:58:35 <sabren> newsham: err.. from the ranks of the cards
13:59:05 <Cale> new2hskl: Hmm... actually, that may not work out, since "111111" is similar to "111", but so is "1111"
13:59:10 <newsham> besides, there's only one real card game.
13:59:15 <Toxaris> by the way, I order playing cards from good to bad on my hand, so I find [Ace .. Two] for all cards more natural then [Two .. Ace]
13:59:36 <newsham> Toxaris: Ord has "<"
13:59:49 <Gracenotes> newsham: you could make another class, Ord2
13:59:57 <Toxaris> newsham: yeah, thats true, but it needs Ace | Ten | King | Queen | Jack | Nine | Eight | Seven most of the time
13:59:59 <newsham> no matter how you order your cards, if you say  Three < Two, people will lookat you weird
14:00:07 <sabren> Toxaris: in some games you win with lower cards :)
14:00:09 <Toxaris> yeah, thats true
14:00:25 <Gracenotes> such that, for Ord2, compare Ace King = GT
14:00:25 <sabren> also Ace < 2 in poker and also > K
14:00:39 <rgr> if there are any xmonad users here, could you point me to where I can read how to apply a function to the current window to make it float?
14:00:43 <Gracenotes> and for everything else, Ord2's compare a b = Ord's compare a b
14:00:50 <newsham> AceLo | Two | Three | ... | King | AceHi
14:00:55 <Gracenotes> not sure if that makes sense, but hopefully it's in the right direction
14:01:05 <Toxaris> Gracenotes: for such things often newtypes are used, e.g.   newtype AlternativeOrder = AlternativeOrder Rank; instance Ord AlternativeOrder where ...
14:01:19 <vixey> I would use a function instead of a newtype
14:01:20 <gwern> rgr: doesn't mouse-richclick float?
14:01:28 <Toxaris> Gracenotes: so if you want the usual order, you use Rank directly, but if you want a special one, you use AlternativeOrder (or some shorter name...)
14:01:39 <b_jonas> I think we even have a newtype for turning an Ord upside down
14:01:52 <sabren> newsham: yeah, but when you get dealt your hand, you just have an ace.. and in (say) holdem, a new card can come that changes the ace in your hand from AceHi to AceLo
14:01:53 <Gracenotes> makes sense. I know what newtype does, but haven't seen it out in the wild :)
14:01:53 <b_jonas> in the library that is
14:02:11 <Toxaris> Gracenotes: this way, you don't have to duplicate the whole class definition, and functions which work with (Ord a => ) constraints will work for both Rank and AlternativeOrder
14:02:15 <newsham> sabren: no, when you get dealt an ace you get to hold an AceLo *AND* and AceHi
14:02:24 <b_jonas> it would also make sense to have an alternate Maybe that behaives the _other_ way with respect to Ord
14:02:31 <Gracenotes> Toxaris: where is Rank defined, I forget
14:02:38 <rgr> gwern: it does yes. But its not key board.
14:02:54 <Toxaris> Gracenotes: its just what I call the type we discuss here, e.g. data Rank = Ace | King | ...
14:02:56 <sabren> newsham: hrm.. but then sometimes you have 2 cards and sometimes you have 1... i think it's easier to just make Hand implement Ord
14:03:07 <Gracenotes> oh, okay, duh.
14:03:09 <newsham> sabren: whats wrong with sometimes having 2 and sometimes 1?
14:03:12 <Gracenotes> the data type
14:03:15 <Toxaris> Gracenotes: I'm not actually sure its called rank
14:03:50 <Gracenotes> *scrolls up* think it is... hm
14:04:19 <sabren> newsham: let's play poker and i'll bring an extra ace along :)
14:04:36 <newsham> sabren: you cant pair an AceLo and an AceHi
14:04:40 <rgr> gwern: I could use cycleWS to move the app to a nmaed workspace where the manage hook forces it to float but that not really what I want. I would like it to float on the current ws.
14:04:53 <gwern> rgr: so look up what the default config is doing and copy
14:04:54 <newsham> you'll find that drawing your best 5 cards and making a hand will "Just work" when you split the ace into two cards
14:05:08 <rgr> gwern: I'm not sure I understand
14:05:40 <rgr> oh, i see. Locate the default xmonad config file.
14:05:42 <vixey> sabren, you aren't ensuring that the deck of cards is always full in the type systeM?
14:06:31 <sabren> newsham: i get what you're saying now.
14:06:50 <sabren> vixey: i'm not ensuring anything, because my poker code is all in python at the moment :)
14:07:18 <newsham> but making poker hands by counting out straights and flushes and such is not very efficient
14:07:20 <vixey> yukc
14:07:27 <newsham> there's lots of crazy super fast poker hand ranking algorithms
14:08:35 <pcc1> is it possible to obtain the type of a template haskell expression?
14:09:12 <sabren> newsham: yeah, there should be a way to turn the data structure to/from bit encodings
14:09:43 <sabren> but for most of my work, i'm not dealing with many hands at all
14:09:51 <newsham> http://www.codingthewheel.com/archives/poker-hand-evaluator-roundup
14:10:27 <dolio> pcc1: It depends what you mean by that exactly.
14:10:41 <sabren> newsham: that guys' my hero :)
14:11:09 <dolio> Some template haskell doesn't have a proper type. Like $( ... ) where the ... is describing a declaration.
14:13:03 <rgr> gwern: please bear with me. I installed using cabal. So which default config am I looking for and where?
14:13:24 <pcc1> yes, of course you cannot obtain the type of a declaration, I was thinking of a function of the type Exp -> Q Type or similar
14:14:32 <gwern> rgr: sources
14:14:43 <dolio> , [$ty| [| 5 |] |]
14:14:45 <lunabot>  luna: parse error on input `|]'
14:15:47 <rgr> sources? That doesnt really narrow it down. I'll grep.
14:16:17 <gwern> XMonad/Config.hs
14:17:10 <dons> rgr: what's the question?
14:17:16 <dons> rgr: so you have the 'cabal' binary?
14:17:22 <dons> $ cabal --version
14:17:22 <dons> cabal-install version 0.6
14:17:25 <dons> for example?
14:19:29 <teko> how would i write  let capCount = length . filter (isUpper . head) . words     if i didnt want to use the (.) operator  ???
14:19:59 <vixey> teko, f . g = \x -> f (g x)
14:20:07 <vixey> so capCount = length . filter (isUpper . head) . words
14:20:13 <Deewiant> capCount x = length $ filter (\x -> isUpper $ head x) $ words $ x
14:20:15 <vixey> => capCount x = (length . filter (isUpper . head) . words) x
14:20:20 <augustss> @unpl capCount = length . filter (isUpper . head) . words
14:20:20 <lambdabot> capCount c = length (filter (\ i -> isUpper (head i)) (words c))
14:20:37 <vixey> => capCount x = (length . filter (isUpper . head)) (words x)
14:20:48 <vixey> => capCount x = length (filter (isUpper . head) (words x))
14:21:20 <Gracenotes> @hoogle (a -> b) -> Maybe a -> Maybe b
14:21:20 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
14:21:21 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
14:21:21 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
14:21:35 <Gracenotes> hm
14:22:35 <sabren> is there a drawback to making a Show/Read that doesn't match haskell syntax? I want  Card Two Heart   to just be  2h
14:22:49 <vixey> sabren, it's silly is the only drawback
14:23:01 <sabren> vixey: why is it silly? :)
14:23:04 <vixey> sabren, you should just write a function not called "show"
14:23:45 <teko> which chapter of RWH discusses list comprehension ?
14:24:20 <sabren> vixey: YAGNI.. ok :)
14:24:33 <vixey> @vera YAGNI
14:24:34 <lambdabot> No match for "YAGNI".
14:24:56 <sabren> You Aint Gonna Need It
14:25:02 <vixey> that's not what I meant
14:25:03 <dons> teko: ch12, ch14
14:25:09 <teko> ta
14:25:11 <dons> some in ch26
14:25:24 <edd____> Are you guys fed up of newbies asking questions about Real World Haskell yet?
14:25:51 <opqdonut> nope :)
14:25:52 <Cale> edd____: We feed on newbie questions.
14:26:00 <edd____> excellent :)
14:26:14 <p_l> newbie question vampires?
14:26:24 <edd____> Well I'm trying to do one of the early exercises, creating a function that determines whether a list is a palindrome
14:26:32 <Cale> edd____: Okay.
14:26:34 <edd____> i have a solution, but it's really ugly by my reckoning
14:26:44 <Cale> edd____: The pretty one is fairly simple.
14:26:50 <Deewiant> There are pretty and fast solutions to this problem ;-)
14:26:56 <Cale> edd____: Has the reverse function been introduced?
14:26:59 <Deewiant> But not both
14:27:11 <edd____> Deewiant: no, but I found it anyway :)
14:27:16 <edd____> I'm not using, however
14:27:54 <edd____> http://hpaste.org/13077
14:28:18 <edd____> shield your eyes!
14:28:25 <Gracenotes> does anyone have a relatively simple example of using a Writer?
14:28:56 <Cale> edd____: It should be noted that length is generally considered to be expensive
14:29:14 <edd____> log N ish?
14:29:20 <Cale> edd____: O(n)
14:29:29 <edd____> Sorry, I meany O(n)!
14:29:32 <edd____> meant
14:29:49 <edd____> So xs == reverse xs is better?
14:29:53 <Cale> yeah
14:30:14 <teko> @src reverse
14:30:15 <lambdabot> reverse = foldl (flip (:)) []
14:30:27 <vixey> xs == reverse xs is great
14:30:32 <vixey> that's the definition of a palindrome
14:30:32 <roconnor> > execWriter (tell "hi Gracenotes")
14:30:34 <lambdabot>   "hi Gracenotes"
14:30:47 <roconnor> too simple?
14:31:02 <Gracenotes> hm, I think so :(
14:31:02 <teko> @src flip
14:31:02 <opqdonut> edd____: it
14:31:03 <lambdabot> flip f x y = f y x
14:31:11 <opqdonut> edd____: it's a good solution
14:31:16 <opqdonut> demonstrates functional thinking :)
14:31:22 <opqdonut> but yeah, reverse is faster :)
14:31:43 <edd____> I was thinking that there might be some way to split the list in half and compare the two halves
14:31:43 <roconnor> Gracenotes: Are you looking for a motivating practical example, or a simple tutorial example?
14:31:53 <edd____> in order to do half the number of comparisons
14:31:56 <rgr> dons: I have cabal 0.6.0
14:32:01 <edd____> but I guess I should forget that for now at least?
14:32:17 <Gracenotes> perhaps a tutorial-esque example. e.g., that calculates a sum with a writing result
14:32:30 <roconnor> hmm
14:32:51 <Cale> edd____: Well, there might be a way to do it in half the time, but lists are not so good with random access/splitting.
14:32:52 <roconnor> it seems like there should be an example of writing a logger using Writer somewhere
14:33:03 <dons> rgr: looks good
14:33:09 <dons> rgr: so what was your question?
14:33:18 <edd____> Cale: ok, that's fine. I just thought I might be missing something
14:33:25 <roconnor> Gracenotes: have you read http://www.haskell.org/all_about_monads/html/writermonad.html ?
14:33:27 <Megzlna> Is template Haskell the precise / way I need to do:
14:33:35 <Megzlna>                             map            ::                 (a -> b) -> [a] -> [b]
14:33:35 <Megzlna>                             map (* 3)      ::      (Num a) =>             [a] -> [a]
14:33:35 <Megzlna>                filter odd . map (* 3)      :: (Integral a) =>             [a] -> [a]
14:33:35 <Megzlna>          sum . filter odd . map (* 3)      :: (Integral a) =>             [a] ->  a
14:33:35 <Megzlna> (\xs -> (sum . filter odd . map (* 3)) xs) :: (Integral a) =>             [a] ->  a
14:33:49 <edd____> Thankyou all!
14:33:51 <Gracenotes> D:
14:34:05 <Gracenotes> roconnor: no, not yet
14:34:18 <rgr> The question was more xmonad related. But I found this "    , ((modMask, button3), (\w -> focus w >> mouseResizeWindow w >> windows W.shiftMaster))" in Config.hs but including it in my xmonad.hs it doesnt compile. Says X() has no argument.
14:34:28 <Megzlna> Gotta make a Type Unification Tracer
14:34:37 <rgr> (am looking for a way to float a single app from keyboard)
14:35:01 <Megzlna> Cale does the bot have anything like that?
14:35:28 <Deewiant> > let sum = getSum.execWriter.f; f [] = tell mempty; f (x:xs) = tell (Sum x) >> f xs in sum [1,2,3]
14:35:30 <lambdabot>   6
14:35:34 <Deewiant> Gracenotes: ^
14:35:34 <Megzlna> or is there any "inspection" libs for Haskell
14:35:43 <luite_> @type map (*3)
14:35:45 <lambdabot> forall a. (Num a) => [a] -> [a]
14:36:05 <Megzlna> @type doesnt show the whole process
14:36:06 <lambdabot> Not in scope: `doesnt'
14:36:06 <lambdabot> Not in scope: `the'
14:36:06 <lambdabot> Not in scope: `whole'
14:36:11 <luite_> lol
14:36:24 <twadleigh> For my first try at using the Writer monad, I'm accumulating results in a  list, but I'm assuming that's a bad idea, is Seq the more common choice for that application?
14:36:31 <Gracenotes> Deewiant: thanks
14:37:18 <luite_> Megzlna: can't you parse the expression first and get the inferred type for each part?
14:37:35 <Megzlna> luite thats why I was thinking TH
14:37:47 <Megzlna> Gotta figure out how to get the same evaluation order as Haskell uses
14:37:48 <augustss> twadleigh: depends on how much you are accumulating
14:38:02 <Megzlna> But, it has to be smart somehow
14:38:03 <vixey> Megzlna, at the bottom of http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62
14:38:09 <Megzlna> because you can't do just "filter"
14:38:16 <Megzlna> without the 'odd'
14:38:33 <Gracenotes> Deewiant: how much different is a product?
14:38:50 <luite_> Megzlna: hm, I'm not sure how th can help, but I don't have any experience with that. I was thinking more along the lines of Language.Haskell (haskell-src package)
14:39:01 <Deewiant> > let sum = getProduct.execWriter.f; f [] = tell mempty; f (x:xs) = tell (Product x) >> f xs in sum [1,2,3,4,5]
14:39:07 <Megzlna> vixey: heh what is that?
14:39:07 <Megzlna> Unifier
14:39:07 <lambdabot>   120
14:39:21 <Deewiant> Wow, it worked, didn't even have to look it up :-)
14:39:59 <twadleigh> augustss: for play, it's not much, but in real applications, the O(n) will get you, right? I was just wondering if there was a nobrainer replacement that folks typically use.
14:40:02 <Gracenotes> Product being defined in advance. hm
14:40:40 <augustss> twadleigh: I'd probably use Data.Sequnce
14:40:53 <Megzlna> import Unification
14:40:54 <Gracenotes> > let first = getFirst.execWriter.f; f [] = tell mempty; f (x:xs) = tell (First x) >> f xs in first [1,2,3,4,5]
14:40:54 <Megzlna> ...
14:40:55 <lambdabot>       No instance for (Num (Maybe a))
14:40:55 <lambdabot>        arising from the literal `1' at ...
14:40:56 <vixey> Megzlna, yes but there is a simple type inferer at the end
14:41:03 <Gracenotes> alas.
14:41:11 <Megzlna> vixey: What does this entire piece of code do?
14:41:12 <vixey> doesn't do let polymorphism but it might be interesting anyway
14:41:29 <vixey> Megzlna, one is a unifier (generic over datatypes) and the other page is various examples
14:41:30 <twadleigh> augustss: thanks.
14:41:49 <Gracenotes> > let first = getFirst.execWriter.f; f [] = tell mempty; f (x:xs) = tell (First x) >> f xs in first [Nothing, Just 2]
14:41:50 <lambdabot>   Just 2
14:41:54 <Megzlna> vixey: does it only work on ~~> stuff?
14:41:56 <sabren> here's what I came up with: rankNames = Map.fromList (zip [Two .. Ace] "23456789TJQKA")
14:41:58 <Gracenotes> lol, it worked.
14:42:56 <vixey> Megzlna, F is the full syntax of types, S is the full syntax of terms
14:44:41 <Megzlna> so you have to add each one manually?
14:44:48 <vixey> each what?
14:44:53 <Megzlna> type
14:45:04 <Megzlna> TVar (Variable s (T s))
14:45:06 <tjb> I have a function -- f x y -- and I would like to use QuickCheck to generate test data where sometimes x==[], sometimes y==[] and sometimes both x,y == [].  When trying the test the case where x==[] and y/=[] I keep getting an "arguments exhausted after foo tests"
14:45:42 <tjb> any pointers on how or where to look for this type of QuickCheck usage?
14:47:03 <redditbot> Haskell Formlets: Composable web form construction and validation
14:47:57 <tjb> hpaste of my example: http://hpaste.org/13079#a0
14:48:44 <dolio> Why are you having it generate stuff if you want it to be []?
14:48:50 <dolio> Just stick in [].
14:50:01 <dolio> The reason it's exhausting things is that after a certain point, it stops generating empty lists altogether, so it never satsifies your constraints.
14:50:49 <tjb> dolio: do you mean use something like "prop_myfunc [] y" instead of "prop_myfunc x y" ?
14:51:36 <Eduard_Munteanu> Hi. Is there a function for finding the index of the maximum of a list?
14:52:06 <Eduard_Munteanu> Or the index of an element, for that matter?
14:52:29 <opqdonut> :t find
14:52:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:52:41 <Eduard_Munteanu> opqdonut, thanks.
14:52:44 <opqdonut> :t findIndex
14:52:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
14:52:59 <opqdonut> :t maximumIndex
14:53:00 <lambdabot> Not in scope: `maximumIndex'
14:53:03 <opqdonut> ah, no such thing
14:53:24 <Eduard_Munteanu> I suppose findIndex (maximum list) should work.
14:53:34 <dolio> I mean if you want to test f x y where x == []. Then generate ys and test f [] y.
14:53:48 <dolio> There's no point generating random xs if only one x is valid.
14:54:02 <dolio> (And you know what that x is.)
14:54:38 <tjb> dolio: ah yes, that makes sense.  Let me give that a shot
14:54:54 <mwotton> Eduard_Munteanu: generally, if you care about the index, a list is the wrong data structure...
14:55:11 * mwotton generalises wildly
14:56:37 <tjb> dolio: works great.  For some reason I had it stuck in my mind that my "prop_func" needed to have the same top level definition "prop_func x y" as the underlying "f x y"
14:56:52 <Eduard_Munteanu> mwotton, I want to do partial pivoting for Gaussian elimination of a matrix. So I thought about finding the index of the best pivot.
14:57:08 <tjb> but testing "prop_func xs" with "f xs []" and "f [] xs" works just fine.
14:57:13 <sabren> is there some reflective way to get all my constructors? I did ranks = [Two .. Ace] but is there any way haskell could have deduced it for me?
14:57:29 <vixey> sabren, I think 2 ways at least
14:57:47 <vixey> sabren, deriving Enum  then  [minBound .. maxBound] and deriving Data.. then some generic thingy does it
14:59:05 <athos> @hoogle whenRight
14:59:05 <lambdabot> No results found
14:59:52 <Eduard_Munteanu> Is there a nice way to permute 2 elements of a list?
14:59:52 <athos> :t mapEithers
14:59:53 <lambdabot> Not in scope: `mapEithers'
14:59:58 <athos> :o
15:00:03 <mwotton> Eduard_Munteanu: and you're representing matrices as lists?
15:00:08 <Eduard_Munteanu> mwotton, yes.
15:00:57 <sabren> vixey: cool.. looks like Enum.Bounded lets you at least describe bounded types, too
15:01:01 <Eduard_Munteanu> mwotton, [[Double]]
15:02:17 <teko> in this code
15:02:20 <teko>   where step l ds
15:02:21 <teko>           | "#define DLT_" `isPrefixOf` l = secondWord l : ds
15:02:21 <teko>           | otherwise                     = ds
15:02:21 <teko>         secondWord = head . tail . words
15:02:39 <teko> shouldnt secondWord be precided by a where ?
15:03:11 <Eduard_Munteanu> teko, AFAIK, it should.
15:03:14 <sabren> teko: it is, through indentation
15:04:19 <athos> @instances Arrow
15:04:20 <lambdabot> (->), Kleisli m
15:08:02 <teko> shouldnt it be where step l:ds  ???
15:08:12 <teko> shouldnt it be where step (l:ds)  ???
15:08:14 <teko> rather
15:08:26 <teko> dlts = foldr step [] . lines
15:08:43 <teko> foldr takes a func that takes one argument
15:08:53 <teko> not 2 like step l ds
15:11:13 <hugo___1> is there any generator of C code in haskell ?
15:11:29 <hugo___1> i want to generate C code from my haskell code :/
15:12:46 <MyCatVerbs> hugo___1: you can always dump text into a file and run gcc over it. :)
15:13:14 <hugo___1> yes, thats what i want to do :/
15:13:37 <erikc> do you want a C version of your haskell code, or do you want to generate C code from a haskell program
15:13:47 <hugo___1> dumping text into a file is quite a generic operation, i want to dump a special kind of text (C code)
15:14:01 <MyCatVerbs> hugo___1: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c <- is a library with nice data structures for representing C code, and a pretty printer that outputs it.
15:14:15 <hugo___1> oh
15:14:16 <hugo___1> thanks :D
15:14:20 <hugo___1> this might do the trick
15:14:21 <MyCatVerbs> hugo___1: and also includes a parser for it.
15:14:23 <MyCatVerbs> No worries. ^^
15:14:43 <teko> @src foldl
15:14:44 <lambdabot> foldl f z []     = z
15:14:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:15:17 <teko> @src foldr
15:15:18 <lambdabot> foldr f z []     = z
15:15:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:15:49 <dons> hugo___1: that sounds like a compiler.
15:15:57 <dons> or do you want a domain specific C generator?
15:16:00 <dons> if so, Language.C
15:17:36 <athos> man, rwh seems to really have *much* content
15:17:37 <athos> :>
15:17:50 <mwotton> Eduard_Munteanu: arrays might be more appropriate. i think there's a matrix library as well
15:18:01 <athos> of course that's good
15:18:06 <mwotton> Eduard_Munteanu: still, if you're doing it as a learning exercise that might be beside the point
15:18:10 <mpeter> hm
15:18:16 <mpeter> > map chr giveMeAdvice
15:18:18 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
15:18:19 <Eduard_Munteanu> mwotton, yeah, I know about the matrix library, but I wanted to do it as an exercise.
15:18:36 <mpeter> mnhm
15:18:49 <athos> :t giveMeAdvice
15:18:51 <lambdabot> forall t. (Num t) => [t]
15:18:56 <Eduard_Munteanu> mwotton, still, good to know arrays might be better.
15:19:00 <athos> > giveMeAdvice
15:19:02 <lambdabot>   [109,101,105,110,32,83,99,104,108,97,102,32,105,115,116,32,100,97,115,32,86...
15:19:31 <athos> > length giveMeAdvice
15:19:33 <lambdabot>   55
15:19:40 <athos> > sum giveMeAdvice
15:19:42 <lambdabot>   70809
15:19:44 <Eduard_Munteanu> > :quit
15:19:45 <lambdabot>   <no location info>: parse error on input `:'
15:19:47 <Eduard_Munteanu> :)
15:20:01 <athos> > nub giveMeAdvice
15:20:02 <lambdabot>   [109,101,105,110,32,83,99,104,108,97,102,115,116,100,86,114,111,118,75,6553...
15:20:25 <Eduard_Munteanu> :quit
15:20:48 <mpeter> what a mystery
15:20:53 <mpeter> what's the difference between Int and Integer again
15:21:27 <int-e> > map chr giveAdvice
15:21:29 <lambdabot>   Not in scope: `giveAdvice'
15:21:32 <vixey> mpeter, Int only goes up to 11
15:21:33 <int-e> > map chr giveMeAdvice
15:21:34 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
15:21:40 <sstangl> mpeter: Int is bounded, same as int in C; Integer is not bounded.
15:21:40 <vixey> mpeter, Integer has not limit
15:21:41 <Eduard_Munteanu> vixey, :)
15:21:46 <mpeter> gotcha
15:22:20 <mpeter> > map intToDigit giveMeAdvice
15:22:22 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
15:22:27 <mpeter> >:O
15:22:27 <int-e> > map (chr . fromIntegral) giveMeAdvice
15:22:29 <lambdabot>   "mein Schlaf ist das Verteilerrohr von Kettens\65533gesodomie"
15:22:34 <int-e> toll :/
15:23:03 <athos> KettensÃ¤gesodomie
15:23:26 * mpeter coughs
15:23:29 <Eduard_Munteanu> Why does this definition yield a parse error: ppivot (a ++ oldrow ++ b ++ bestrow ++ c) n = a ++ bestrow ++ b ++ oldrow ++ c
15:23:33 <athos> what the heck.. :>
15:23:42 <chrisdone> man I love the internet
15:23:42 <Eduard_Munteanu> a, oldrow, b, bestrow, c are all [[Double]]
15:23:48 <vixey> Eduard_Munteanu: You cannot pattern match on functions like this sadly
15:24:08 <vixey> Eduard_Munteanu: (++) being a function
15:24:12 <Eduard_Munteanu> vixey, oh, I took pattern matching for granted :)
15:24:19 <vixey> Eduard_Munteanu: but did you mean like [a, oldrow, b, ..] instead?
15:24:28 <Eduard_Munteanu> vixey, well, yes.
15:24:34 <Eduard_Munteanu> oh, no
15:25:04 <Eduard_Munteanu> vixey, they could all be lists of lists
15:25:20 <vixey> tthen I don't know how to  do it
15:26:20 <Eduard_Munteanu> vixey, I'm trying to permute two rows in a matrix. Any idea how I should approach this in a concise manner?
15:26:30 <vixey> which two rows?
15:26:42 <Eduard_Munteanu> vixey, oldrow with bestrow
15:26:57 <teko> > [1,4..50]
15:26:58 <vixey> but if I hand you some arbitrary matrix, how do you know which row is old and which is best?
15:26:59 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49]
15:27:34 <Eduard_Munteanu> vixey, there's an 'where' statement which defines bestrow and oldrow?.
15:27:41 <vixey> show me it
15:28:13 <teko> , @src add
15:28:15 <lunabot>  luna: parse error on input `@'
15:28:31 <mpeter> @src add
15:28:32 <lambdabot> Source not found. :(
15:28:38 <mpeter> @src +
15:28:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:28:43 <mpeter> @src (+)
15:28:43 <teko> what???
15:28:44 <lambdabot> Source not found. Just try something else.
15:28:46 <Eduard_Munteanu> vixey, http://pastebin.com/d538ad73c
15:28:53 * mpeter chastises lambdabot
15:29:11 <vixey> ok
15:29:15 <Eduard_Munteanu> vixey, bestpos should be equivalent to (findIndex(maximum(...))
15:29:22 <vixey> Eduard_Munteanu: I've got an idea
15:29:24 <int-e> mpeter: it's part of the Num typeclass
15:29:41 <mpeter> that would explain it
15:29:43 <byorgey> @src Num
15:29:44 <lambdabot> class  (Eq a, Show a) => Num a  where
15:29:44 <lambdabot>     (+), (-), (*)           :: a -> a -> a
15:29:44 <lambdabot>     negate, abs, signum     :: a -> a
15:29:46 <lambdabot>     fromInteger             :: Integer -> a
15:29:54 <vixey> ppivot matrix n = permute [(bestpos,n),(n,bestpos)] matrix where ...
15:30:01 <vixey> but this function "permute"
15:30:02 <vixey> it's
15:30:13 <vixey> permute :: Permutation -> [a] -> [a]
15:30:22 <vixey> type Permutation = [(Integer,Integer)]
15:30:25 <vixey> so for example
15:30:28 <int-e> vixey: looks like an elaborate identity to me
15:30:45 <int-e> vixey: you swap positions bestpos and n, twice.
15:30:49 <vixey> oh ok
15:31:01 <vixey> then write
15:31:05 <vixey> ppivot matrix n = permute [(bestpos,n)] matrix where ...
15:31:17 <vixey> well I don't really want that actually
15:31:24 <vixey> I need a different name than permute
15:31:39 <mpeter> now somebody please explain the specifics of this to me:
15:31:43 <mpeter> > compare "hello" "goodbye"
15:31:45 <lambdabot>   GT
15:31:51 <Eduard_Munteanu> :t permute
15:31:53 <lambdabot> Not in scope: `permute'
15:32:08 <Eduard_Munteanu> vixey, yeah, but is there a permute function?
15:32:15 <athos> , permute [1,2,3]
15:32:16 <lunabot>  luna: Not in scope: `permute'
15:32:21 <athos> , permutation [1,2,3]
15:32:23 <lunabot>  luna: Not in scope: `permutation'
15:32:27 <athos> , permutate [1,2,3]
15:32:29 <lunabot>  luna: Not in scope: `permutate'
15:32:32 <athos> eh
15:32:35 <Eduard_Munteanu> :t perm
15:32:37 <lambdabot> Not in scope: `perm'
15:33:08 <vixey> Eduard_Munteanu: I just make things up as I go
15:33:20 <vixey> Eduard_Munteanu: you have to write them
15:33:27 <sabren> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/permutation-0.3
15:33:42 <tjb> , permutations [1,2,3]
15:33:44 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
15:33:55 <Eduard_Munteanu> vixey, oh ok. But it boils down to pattern matching something like I tried.
15:34:29 <Eduard_Munteanu> tjb, but I need not generate permutations. I just need to swap two elements in a list (namely matrix rows)
15:34:59 <mpeter> , permutations [1,2]
15:35:01 <teko> , permutations "abc"
15:35:03 <lunabot>  [[1,2],[2,1]]
15:35:04 <lunabot>  ["abc","bac","cba","bca","cab","acb"]
15:35:05 <tjb> Eduard_Munteanu: sorry, no idea -- I was just typing out the "permutations" type for athos
15:35:11 <mpeter> , tail (permutations [1,2])
15:35:13 <lunabot>  [[2,1]]
15:35:31 <mpeter> , last (permutations [1,2])
15:35:33 <int-e> hmm, I'm missing an applyPermutation :: Permute -> [a] -> [a]  function in the permutation package.
15:35:33 <lunabot>  [2,1]
15:35:37 <teko> , head . tail . permutations [1,2,3]
15:35:39 <lunabot>  luna: Couldn't match expected type `a -> [a1]'
15:35:39 <mpeter> there you go ;)
15:35:56 <mpeter> or just
15:35:58 <mpeter> > reverse [1,2]
15:36:00 <lambdabot>   [2,1]
15:36:42 <byorgey> Eduard_Munteanu: there is a permutation library on Hackage if you don't want to write it yourself.
15:36:43 <Eduard_Munteanu> mpeter, how is that going to work for swaping 2 elements in a list of size n?
15:36:57 <mpeter> oh, i see
15:37:07 <mpeter> well, refer to the specific position in the list you want to swap
15:37:10 <mpeter> then concat it back together
15:37:22 <Eduard_Munteanu> byorgey, I'd like to write it. I need some pointers on how to do pattern matching for this sort of work.
15:37:41 <pumpkin> I wonder how efficiently it can be done with lists
15:37:51 <Eduard_Munteanu> byorgey, I tried ppivot (a ++ oldrow ++ b ++ bestrow ++ c) n = a ++ bestrow ++ b ++ oldrow ++ c
15:37:52 <pumpkin> I guess it needs to be linear
15:38:01 <Eduard_Munteanu> byorgey, but it won't parse it.
15:38:08 <byorgey> Eduard_Munteanu: right, you can't use functions like ++ in a pattern-match.
15:38:12 <int-e> pumpkin: swapping the n-th and m-th element of a list will be O(max(n,m))
15:38:44 <byorgey> Eduard_Munteanu: you can't do a straight-up pattern match to pull out two arbitrary elements of a list given their indices.
15:38:45 <int-e> pumpkin: you can reuse the tail, but the remainder of the result has to be reconstructed from scratch.
15:38:51 <pumpkin> yeah
15:38:57 <mpeter> eduard: you want to use use take and break
15:39:00 <mpeter> i believe
15:39:32 <mpeter> (and drop)
15:39:41 <byorgey> Eduard_Munteanu: use splitAt to break the list into pieces before, between, and after the things you want to swap
15:39:56 <byorgey> then glue them back together in the right order with the swapped elements
15:40:06 <byorgey> > splitAt 3 [1..10]
15:40:08 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
15:40:26 <hugo___1> i really dislike the ammount of posts on the net that argue about C++ being much faster than haskell, and more appropriate for interactive and state changing demands
15:40:31 <byorgey> splitAt is take and drop combined into one.
15:40:39 <teko> why does head (tail "ab") work and head. tail "ab" doesnt  ???
15:40:41 <int-e> > let (as, b:bs) = splitAt 3 [1..10] in bs ++ b : as
15:40:42 <byorgey> hugo___1: so don't read them. =)
15:40:43 <lambdabot>   [5,6,7,8,9,10,4,1,2,3]
15:40:44 <Eduard_Munteanu> byorgey, oh, this is an idea. Thanks.
15:41:03 <mpeter> ALSO
15:41:04 <mpeter> > break (==3) [1..10]
15:41:05 <Saizan> > head . tail $ "ab" -- teko
15:41:07 <lambdabot>   'b'
15:41:07 <lambdabot>   ([1,2],[3,4,5,6,7,8,9,10])
15:41:09 <hugo___1> byorgey: its always a good source of those "someone should shut the mouth of these guys" kind of feelings :P
15:41:25 <Eduard_Munteanu> mpeter, thanks.
15:41:35 <mpeter> <3 haskell
15:41:36 <athos> good night everyone
15:41:36 <Saizan> teko: head . tail "ab" is parsed as head . (tail "ab")
15:41:59 <Saizan> so it becomes \x -> head ((tail "ab") x)
15:42:13 <teko> oh
15:42:48 <Eduard_Munteanu> int-e, that sounds good also.
15:42:51 <teko> what does $ do ?
15:42:58 <Saizan> function application binds tighter than anything else
15:43:03 <int-e> @src ($)
15:43:03 <Saizan> ?src ($)
15:43:04 <lambdabot> f $ x = f x
15:43:04 <lambdabot> f $ x = f x
15:43:51 <Saizan> teko: it's just an operator for function application with the lowest precendece
15:43:58 <int-e> teko: the point of ($) is its low fixity. it binds weaker than most other infix operators.
15:44:11 <int-e> stereo :/
15:44:24 <int-e> @quote fugue
15:44:24 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
15:45:01 <Saizan> head . tail $ "ab" == (head . tail) "ab"
15:45:08 <mwotton> i always thought barbershop quartet, but i suppose a fugue is more dignified
15:46:22 <SamB> has anyone actually heard of a real schroedinbug ?
15:46:36 <mpeter> > head (tail [1..10])
15:46:38 <lambdabot>   2
15:47:03 <redditbot> n-heptane lab: Data Migration with HApps-Data
15:47:03 <redditbot> Programmable Concurrency in a Pure and Lazy Language (Peng Li's thesis on Haskell's concurrency) :: PDF
15:47:17 <vixey> @let cadr = head . tail
15:47:18 <lambdabot>  Defined.
15:48:02 <augustss> SamB what is a real one?
15:48:13 <mpeter> > cadr "hello"
15:48:15 <lambdabot>   'e'
15:48:50 <pumpkin> there's car and cadr in haskell?
15:48:50 <mpeter> > replicate 32 (cadr "hello")
15:48:52 <lambdabot>   "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
15:48:52 <Eduard_Munteanu> SamB, yup.
15:48:53 <SamB> augustss: well, not just rumoured
15:48:58 <chrisdone> but do Haskell programmers like to discuss lists over the phone?
15:49:13 <vixey> SamB: that Plan 9 thing with the wobbly lettering
15:49:15 <byorgey> pumpkin: no, but it's easy to write =)
15:49:18 <augustss> SamB: yes, but what is the characteristic you are after of the bug?
15:49:20 <pumpkin> yeah :P
15:49:20 <mpeter> <3<3 plan 9
15:49:34 <SamB> hmm ?
15:49:44 <augustss> SamB: I've certainly had bugs that, e.g., go away when you run the program in the debugger.
15:49:51 <roconnor> > join ((>>) . cadr) "hello"
15:49:52 <lambdabot>   Couldn't match expected type `Char' against inferred type `[a]'
15:49:57 <SamB> that's a heisenbug
15:50:02 <SamB> much more normal!
15:50:14 <roconnor> > join (((>>).) . cadr) "hello"
15:50:15 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a -> m a1]
15:50:15 <lambdabot>      ...
15:50:25 <augustss> That's why I ask what you are after. :)
15:50:25 <SamB> I get those a lot actually
15:50:33 <SamB> http://catb.org/jargon/html/S/schroedinbug.html
15:50:56 <vixey> ohhh....
15:51:02 <vixey> I thought you said heisenbug for some reason
15:51:31 <augustss> Ah!
15:51:44 <Eduard_Munteanu> SamB, oh I see. Yes, I've encountered some, mostly when moving programs from one computer to another, or using another compiler. Though not unexplainable.
15:51:55 <SamB> Eduard_Munteanu: that doesn't count
15:52:13 <SamB> it says that after someone notices the problem in the code, it stops working for EVERYONE
15:52:27 <Eduard_Munteanu> SamB, heh, then I suppose no.
15:52:37 <daf> that doesn't seem like a very useful category
15:52:46 <augustss> SamB: I've encountered something similar.  A bug that has been there a long time, and then at about the same time people independently run into it at about the same time.
15:56:02 <rgr> I realise now why the stdinreder was gone - it just sits there saying "updating" and then after a while crashes xmobar.
15:57:05 <mmorrow> rgr: love those programs ;)
15:57:29 <rgr> I think I'm getting mroe confused with haskell and xmobar config the more I try to understand.
15:57:34 <erikc> grr, damn mac upgrade cycle, mac pro i7s are just around the corner ... gotta put off my purchase
16:00:24 <teko> it was easier for me to learn c than haskell. is that unusual ?
16:00:46 <BONUS> no
16:00:47 <Eduard_Munteanu> teko, no.
16:00:48 <SamB> teko: which did you learn first ?
16:00:53 <teko> pascal
16:00:56 <SamB> how much did you learn C ?
16:00:57 <teko> then asm
16:01:00 <teko> then c
16:01:00 <dons> teko: C is a lot simpler, initially. though the complexities grow..
16:01:06 <BONUS> c is pretty close to asm
16:01:08 <dons> (and some bits are entirely undefined)
16:01:12 <BONUS> because you have to know the memory
16:01:15 <Gracenotes> hm, I think Haskell is giving me a headache. Either that, or I'm not drinking enough fluids.
16:01:16 <BONUS> how it works, etc.
16:01:18 <SamB> if you already knew ASM, C was probably a piece of cake, yes ?
16:01:27 <teko> ye
16:01:48 <SamB> so ... how easy was it to learn Pascal ?
16:02:04 <teko> pretty easy
16:03:05 <teko> its just good to know im not crazy
16:03:13 <erikc> haskell's operational semantics are pretty weird compared to everything else
16:03:22 <erikc> (everything else conventional)
16:03:42 <Eduard_Munteanu> I always wonder how one could do memory management in Haskell. They've been writing an operating system kernel in it.
16:03:45 <chrisdone> look mah I put a Haskell in a lambda abstraction: http://chrisdone.com/path3259.png
16:03:58 <dons> mmm
16:03:59 <chrisdone> needs more Î»f
16:04:09 <dons> Eduard_Munteanu: several, actually
16:04:13 <dons> what's the question?
16:04:18 <dons> how to do explicit memory management?
16:04:23 <Eduard_Munteanu> dons, yes.
16:04:42 <chrisdone> oh, god. we had to do Pascal at college~_~
16:04:46 <dons> in the IO monad (or other more restricted environments) you can do arbitrary, sequenced operations. including alloc/malloc and free
16:04:53 <teko> LOL chrisdone
16:05:02 <teko> we had to do smalltalk
16:05:06 <teko> even worse
16:05:06 <dons> Eduard_Munteanu: have a poke around Foreign.* modules for low level things
16:05:17 <Eduard_Munteanu> dons, yeah, but how would you actually tell functional code which memory areas to use?
16:05:18 <dons> haskell's a curious mix of extreme abstraction, and raw bare metal
16:05:32 <dons> Eduard_Munteanu: much like in C
16:05:33 <SamB> that is NOT bare metal
16:05:33 <dolio> GHC is.
16:05:41 <Eduard_Munteanu> dons, thanks, I'll have a look.
16:05:43 <SamB> bare metal is what House runs on, silly
16:05:50 <dons> x <- mmap 0x100 lots-of-stuff
16:06:04 <dons> dolio: well, any FFI compliant system
16:06:07 <dons> but yeah, haskell =~ ghc
16:06:10 <dolio> Yeah, I guess.
16:06:21 <Eduard_Munteanu> dons, show(FFI) ?
16:06:26 <dons> Eduard_Munteanu: at my work we do *lots* of low level things in Haskell
16:06:38 <dons> for the safety + control + abstraction.
16:06:40 <dolio> GHC has a lot of extra stuff you can do beyond that, but I guess that'll be true of any compiler, really.
16:06:57 <dolio> Like all sorts of unboxed primitive types you can fool with.
16:07:09 <Eduard_Munteanu> dons, nice to know one can find jobs in Haskell programming.
16:07:13 <dons> yep.
16:07:18 <chrisdone> :D
16:07:26 <SamB> you'd obviously need to use an appropriate RTS in order to create an OS kernel in Haskell
16:07:29 <kig> heh. my C# analog clock uses 20 megs of ram, while a much-more-allocating tree animation in haskell uses only 8.5
16:07:45 <chrisdone> isn't there already an OS written in haskell?
16:07:48 <dons> several.
16:07:54 <Eduard_Munteanu> chrisdone, yeah, I know about House.
16:08:13 <SamB> chrisdone: and guess what, none of them uses GHC's usual RTS library
16:08:17 <Pseudonym> Even 8.5Mb of RAM is a lot for a clock.
16:08:29 <Pseudonym> But 20 is just insane.
16:08:43 <dons> kig: using ghc -O2 --make ?
16:08:46 <kig> gtk analog clock drawn with cairo, but yes
16:08:52 <p_l> kig: What do you use for the clock in C#?
16:08:55 <chrisdone> ah, gtk, well
16:09:01 <Pseudonym> Ah, right.
16:09:03 <Eduard_Munteanu> I bet I can code an analog clock for X in under 50KB.
16:09:06 <kig> p_l: i put it in my fvwm buttonbar
16:09:10 <Pseudonym> GTK and Cairo are probably 8 megs by themselves.
16:09:15 <dons> the standard hsclock gtk demo uses 5M
16:09:18 <dons> 5228 S    1  0.3   0:00.34 hsclock
16:09:21 <sereven> xclock is 60K here
16:09:23 <p_l> kig: I mean what libraries etc.
16:09:32 <mmorrow> Eduard_Munteanu: foreign import ccall unsafe "malloc" c_malloc :: CSize -> Ptr a
16:09:33 <dons> mostly due to cairo i imagine
16:09:35 <kig> mono, gtk# and cairo
16:09:48 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsclock
16:09:52 <Eduard_Munteanu> mmorrow, great.
16:09:56 <mmorrow> Eduard_Munteanu: the FFI rocks
16:09:58 <Pseudonym> When you consider that Cairo is functionality that should probably be implemented mostly in hardware.
16:10:27 <chrisdone> what's a good way to keep a directory on some FTP server in synch with a local directory?
16:10:27 <kig> dons: yeah, same memory usage with -O2
16:10:28 <Eduard_Munteanu> mmorrow, yeah, although it would've been nice to be able to do all the stuff in Haskell only.
16:10:35 <Pseudonym> The PostScript/PDF graphics model is ubiquitous these days.  It's the sort of thing that graphics cards should be doing.
16:10:43 <mmorrow> Eduard_Munteanu: mallocBytes :: Int -> Ptr a
16:10:55 <dons> kig: then its the C libs
16:10:55 <Eduard_Munteanu> mmorrow, oh :)
16:11:03 <chrisdone> hm, maybe darcs does FTP
16:11:12 <kig> dons: yes, i imagine so
16:11:16 <mmorrow> (it probably FFI's to C malloc underneath of course, since "malloc" implies C's malloc ;)
16:11:17 <p_l> Pseudonym: Well, if freedesktop stops destroying X11 and instead starts thinking what to improve, they might come up with vector-oriented X12...
16:11:32 <Pseudonym> How are they destroying X11?
16:11:39 <dons> chrisdone: want to add your logo to http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
16:11:40 * Pseudonym is not up to date with the latest X internals
16:11:57 <SamB> Pseudonym: I don't think that's what he was claiming they are destroying
16:12:06 <Pseudonym> Oh.
16:12:11 <chrisdone> dons: sure
16:12:17 <Pseudonym> Just a suggestion: Isn't Helvetica a bit passe?
16:12:26 <Pseudonym> Haskell is postmodern, not modern.
16:12:32 <SamB> oh come on
16:12:38 <SamB> postmodernism is so passe
16:12:40 <chrisdone> haha?
16:12:42 <kig> it's ironic helvetica
16:12:44 <lowasser> oh my
16:12:55 <gwern> o'keefe strikes again
16:12:56 <gwern> '
16:12:57 <gwern> 'December buds swell.
16:12:57 <gwern> Categories unlimit
16:12:58 <gwern> Haskell I once knew.;
16:13:07 <lowasser> teehee
16:13:19 <p_l> Pseudonym: They are doing a lot of weird things. XRandR 1.2, Xft2, latest changes in X.Org server...
16:13:25 <dons> Pseudonym: do you think haskell is post-modern?
16:13:27 <Pseudonym> One of my favourte names for a blog: http://www.ironicsans.com/
16:13:33 <Pseudonym> Yes, I think so.
16:13:38 <Pseudonym> I think that multi-paradigm is postmodern.
16:13:42 <SamB> so ... is helvetica modernist?
16:13:44 <daf> (post)modernism aside, Helvetica is a rubbish font
16:13:46 <dons> i really think haskell's the epitome of modernism. its minimalist, emphasis on pure technology.
16:13:54 <gwern> helvetica is totaly 'modern'
16:13:58 <lowasser> hey, actual Haskell query: why don't scanl and scanr fold/build?
16:13:58 <dons> research and innovation. inventing the world
16:13:59 <Pseudonym> I wouldn't say that Helvetica is rubbish.  It's utilitarian.
16:14:02 * gwern knows this from watching _Helvetica_
16:14:05 <Pseudonym> It's not beautiful.
16:14:11 <Eduard_Munteanu> p_l, yeah, xrandr is nice and all that. But I agree, X tends to be the slowest stuff when it comes to graphics.
16:14:19 <dons> Pseudonym: how is haskell post-modern?
16:14:29 <kig> and that logo reminds me of my clock screenshot http://tinyurl.com/6awcul
16:14:36 <SamB> dons: perhaps in the same sense that C++ is modern ;-P
16:14:48 <dons> its maybe the last modern language. :)
16:14:55 <ikkebr> using that lambda makes haskell logo looks like halflife's logo
16:15:01 <Eduard_Munteanu> kig, that looks like a lambda.
16:15:01 <dons> oh bah halflife.
16:15:01 <mpeter> that's true
16:15:08 <mpeter> do they have halflife for linux yet?
16:15:09 <dons> haskell's been using circle+lambda since forever. as lisp has
16:15:12 <Pseudonym> dons, Haskell is the modern playground for breaking assumptions, especially about types.
16:15:21 <kig> Eduard_Munteanu: lambda clock
16:15:27 <Eduard_Munteanu> Yup.
16:15:31 <gwern> dons: well, post-modern is about critiquing the modern and subverting it, exposing the hidden assumptions that render it futile and vitiate all its goals. I'd say rejecting imperative programming is a pretty radical critique
16:15:31 <SamB> ikkebr: they've always resembled one another ...
16:15:51 <p_l> Pseudonym: XRandR 1.2 is broken. At least it is broken when you are not trying to emulate Windows-like behaviour
16:15:59 <Pseudonym> p_l: Right.
16:16:01 <mpeter> postmodernism is the same thing as modernism
16:16:02 <dons> hmm. maybe. but we're striking out in our own direction here. pure engineering to create a better world.
16:16:06 <hugo___1> i find the learning curve of haskell to be quite steep
16:16:12 <dons> all glass and steel
16:16:14 <lowasser> Concur with Pseudonym: Haskell's beauty comes from doing things its own funky lovely way
16:16:19 <daf> p_l: broken how?
16:16:20 <lowasser> breaking assumptions.
16:16:21 <Nafai> dons: So is gitit hard to set up?
16:16:28 <dons> Nafai: no, trivial.
16:16:31 <dons> cabal install gitit
16:16:34 <dons> ./gitit
16:16:35 <dons> done.
16:16:46 <doublec> gitit is quite possibly the easiest wiki to setup ever
16:16:58 <p_l> daf: It requires you to create _one_ big virtual framebuffer, which is then divided into what is shown on the displays
16:17:35 * Nafai tries :)
16:17:35 <dons> we have a grand narrative for how programming should be done. feels modern.
16:17:40 <Pseudonym> When I think Modern art, I think of Rothko and Jasper Johns.
16:17:47 <p_l> daf: otoh, I quite like multi-head setup, not "one big honking desktop"
16:17:53 <Pseudonym> That's as beautiful as an Algol program.
16:17:54 <dons> not Minimalism?
16:18:10 <p_l> Pseudonym: Algol 60 or Algol 68?
16:18:20 <gwern> perhaps I am alone, but I always felt Haskell was either sumi-e, or De Stijl
16:18:28 <Pseudonym> There's a difference in relative beauty, p_l?
16:18:32 <gwern> depending on how restricted by the type system I feel that day :)
16:18:48 <dons> progress through technology. technology gives us safety and control.
16:18:55 <Pseudonym> I think of Haskell as more new classic and conceptual.
16:18:58 <dons> it feels /really/ modern to me.
16:19:03 <daf> that does sound like a modernist narrative
16:19:09 <p_l> Pseudonym: Algol 68 is what remained when they cut all things that were "too modern" from Algo 60, IIRC
16:19:13 <mpeter> haskell feels more natural
16:19:22 <p_l> Afaik no-one ever finished a complete Algol 60 system
16:19:23 <Pseudonym> Haskell feels more organic.
16:19:28 <Eduard_Munteanu> Haskell looks like Pollock to me
16:19:32 <lowasser> haskell feels very natural, once you learn to think the way it demands
16:19:34 <mpeter> haskell increases her pleasure
16:19:39 <kig> the future is the sixties, the new future is the eighties, the past is the seventies and the new past is the nineties
16:19:40 <mpeter> up to 60% in studies
16:19:50 <Eduard_Munteanu> :P
16:20:06 <kig> (this is how i interpret the current design trends)
16:20:17 <Pseudonym> Present is the new Past
16:20:30 <SamB> I don't think I like either modernism or postmodernism
16:20:31 <dons> minimalist art is in some ways the end point of reduction/abstraction in modernism, and the beginning of post modernism. haskell, i feel, is in some sense there as well. reducing the complexit, paring back the assumptions, to expose the foundations of our business.
16:20:51 <mpeter> hey dons, if you like minimalism, you'll love my album ;)
16:20:52 <dons> its not a sloppy pile of mess. its glittering glass and steel and math.
16:20:58 <Pseudonym> Ah, but Haskell builds a new framework to harness complexity.
16:21:04 <dons> that's the other point, yes.
16:21:05 <SamB> at least, not if that's where we get all these ugly buildings we have these days
16:21:07 <chrisdone> dons: yeah, added some ideas I was messing with a few weeks ago. nice that you brought up a new logo. http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
16:21:08 <dons> we're a revolutionary movement.
16:21:11 <Pseudonym> One that's not arbitrary, but based on real hard-core maths.
16:21:24 <Pseudonym> So perhaps Haskell is Classical Realist.
16:21:28 <mpeter> programming is inextricably based on math
16:21:33 <Pseudonym> Rather than Minimalist.
16:21:34 <gwern> dons: so the occasional warts on haskell exist, but there are so many fewer that we seem clean and glittering and mathy compared to all the other languages?
16:21:35 <mpeter> haskell's quality is in its conformance to demand
16:21:42 <dons> gwern: right.
16:21:42 <mpeter> and by "demand" i mean necessity
16:21:49 <lowasser> most languages are considerably less mathematical than haskell
16:22:04 <chrisdone> (admittedly awful, but it's sometimes nice to have ideas to say â€˜definitely notâ€™ to)
16:22:09 <lowasser> in syntax, philosophy, design
16:22:28 <mpeter> that doesn't mean anything
16:22:30 <dons> Pseudonym: imperative programming is pre-modern.
16:22:34 <dons> :)
16:22:52 <Gracenotes> and brainfuck is post-modern :)
16:22:58 <mpeter> haskell's real beauty is, however, in its immutable state
16:22:58 <dons> well, maybe something like Scala.
16:23:00 <chrisdone> Haskell is my favourite imperative programming language â€” Peyton `Simon` Jones
16:23:03 <lowasser> ahhhhhh bf
16:23:05 <Pseudonym> BF is "entartete Kunst".
16:23:06 <mpeter> that streamlines the shit out of everything
16:23:10 <dons> where they give up on narrative, and mash together things.
16:23:28 <Pseudonym> So perhaps, Haskell is Design, not Art.
16:23:32 <gwern> Gracenotes: BF postmodern - yeah, I could get behind that. a lot of the esoteric langs often feel that way
16:23:47 <lowasser> BF is a Turing machine
16:23:49 <dons> BF is Dadaist.
16:23:53 <mpeter> design and art are inseperable
16:23:54 <dons> little jokes to punk people.
16:23:54 <lowasser> that's pretty premodern from where I sit
16:23:56 <mpeter> BF is certainly dadaist
16:23:58 <Pseudonym> BF and other esoteric languages are performance/conceptual art.
16:24:01 <mpeter> as well as intercal
16:24:01 <SamB> hmm, what's a wikipedia tag for articles that are sorely in need of pictures ?
16:24:03 <Gracenotes> immutable state /is/ pretty neat. Even in imperative languages like Java, it's very useful
16:24:04 <mpeter> <3
16:24:05 <lowasser> hah
16:24:08 <lowasser> what's LOLcode?
16:24:10 <gwern> premodern programming is bashing pointers together hoping to produce the righ sparks.
16:24:12 <dons> more jokes.
16:24:16 <mpeter> LOLcode's built on top of .net
16:24:19 <dons> gwern: exactly.
16:24:19 <mpeter> i think
16:24:20 <lowasser> I mean
16:24:21 <mpeter> it's rather useless
16:24:22 <dons> like early clock engineering
16:24:24 <lowasser> performance?
16:24:26 <lowasser> conceptual art?
16:24:30 <dons> where they just add cogs to cogs to springs to hope it makes something.
16:24:35 <Pseudonym> I think of COBOL, Fortran etc as brutalist.
16:24:37 <dons> (anyone seen 'longitude'?)
16:24:37 <lowasser> dadaist?
16:24:37 <mpeter> the programs themselves are the art
16:24:42 <mpeter> the code itself is simply utility
16:24:44 <mpeter> or medium
16:24:50 <Gracenotes> SamB: {{Reqphoto}}, does on the talk page, with a request :)
16:24:52 <Gracenotes> *goes
16:24:56 <mpeter> then again, programming languages are just programs themselves
16:24:57 <Pseudonym> beton brut
16:25:05 <mpeter> and 'programs' are just big arrangement of tiny other programs
16:25:05 <Gracenotes> there are other types of request templates, like for diagrams, maps, etc.
16:25:14 <mpeter> all piped together ;)
16:25:36 <SamB> eh, I'm just going to mark it as a stub
16:25:48 <gwern> the easy way out
16:25:52 <mpeter> which is why languages/frameworks like lily are abstracted beyond belief
16:25:56 <dons> but we have a grand narrative of correct-by-design. a fundamental reshaping of the business of programming through math. we're the towers of glass and steel, mighty abstractions that could not be built before.
16:26:13 <SamB> http://en.wikipedia.org/wiki/Rationalism_(architecture) if you care
16:26:16 <dons> category-extras might be a post-modern joke on cat. theory.
16:26:18 <Pseudonym> In that sense, Haskell is New Media.
16:26:31 <mpeter> haskell is the palette knife in "nude descending a staircase pt 2"
16:26:40 <mpeter> and java is the paint can in pollock
16:26:44 <Gracenotes> h
16:26:49 <SamB> ah, now THIS is a style! http://en.wikipedia.org/wiki/Gothic_Revival_architecture
16:26:52 <Gracenotes> er, that was meant to be a heh.
16:26:54 <chrisdone> Â¿â€½ØŸ?
16:27:04 <Nafai> That was easy :)
16:27:06 <dons> i think pollock was into dynamic typing.
16:27:08 <gwern> my interrobangs. let me show you dem
16:27:23 <Toxaris> I see Haskell as modern, its based on engineering with a mathematical background, and the overall concept of having a good idea and keeping to it because good ideas are the future is modern
16:28:01 <Toxaris> some other programming languages and paradigms seem to have more in common with alchemy then with engineering or science
16:28:16 <dons> yes. pre-modern natural science.
16:28:16 <SamB> Toxaris: so why is all the stuff on the http://en.wikipedia.org/wiki/Modern_architecture page not actually pretty ?
16:28:25 <dons> cast a magic monkey spell
16:28:28 <gwern> http://upload.wikimedia.org/wikipedia/en/a/a6/House_of_Lords.jpg <-- pretty cool looking, but I don't see space for very many lords
16:28:33 <dons> and woo. gold. or something like it.
16:28:37 <Pseudonym> Toxaris, where I disagree with that is that modernism is modern for the sake of modern.
16:28:45 <Pseudonym> Not because it's better.
16:28:53 <mpeter> > reverse (reverse (map (chr . fromInteger) giveMeAdvice))
16:28:55 <lambdabot>   "mein Schlaf ist das Verteilerrohr von Kettens\65533gesodomie"
16:28:59 <hugo___1> aren't you afraid that haskell turns out like smalltalk ?
16:29:02 <Pseudonym> The modernists tore down Victorian buildings because they simply weren't modern.
16:29:03 <Toxaris> SamB: I'm talking modern in the sense of "the period after the middle ages", not "the last 20 years"
16:29:07 <chrisdone> I heard you like monads so I made a monad transformer so you can bind while you bind
16:29:10 <dons> haskell's the essence of reformation in programming
16:29:14 <dons> hugo___1: its a risk.
16:29:16 <Gracenotes> Haskell is the architectural Ayn Rand of programming languages... okay... bad analogy
16:29:22 <SamB> Toxaris: they aren't talking about the last 20 years ...
16:29:26 <chrisdone> what happened to small talk?
16:29:27 <lowasser>  chrisdone you broke my brain
16:29:27 <Pseudonym> I'm talking "modernism" as in what came between Art Deco and Postmodernism.
16:29:38 <erikc> smalltalk woulda done a lot better if there'd have been a AAA free implementation
16:29:46 <dons> imperative programming is 19th century
16:29:49 <chrisdone> lowasser: this is your brain on Î»Â·haskell
16:29:52 <hugo___1> everyone seems to be stealing good ideas from haskell... wich isn't that bad
16:29:52 <gwern> Gracenotes: who is haskell curry?
16:29:57 <Toxaris> SamB: well that website talks about the last 60 years mainly
16:30:01 <lowasser> teehee
16:30:07 <dons> hugo___1: right. but also we're aware of this.
16:30:10 <dons> ?users
16:30:10 <lambdabot> Maximum users seen in #haskell: 586, currently: 537 (91.6%), active: 29 (5.4%)
16:30:15 <Pseudonym> dons, I find it hard to look at Fortran and Cobol and not see Brutalism.
16:30:16 <SamB> Although there is debate as to when and why the decline of the modern movement occurred, criticism of Modern architecture began in the 1960s on the grounds that it was universal, sterile, elitist and lacked meaning.
16:30:21 <Pseudonym> Big slabs of undressed concrete.
16:30:28 <Gracenotes> gwern: sadly, "is" is polymorphic :/
16:30:32 <chrisdone> gwern: where is Sarah Curry?
16:30:34 <gwern> (haskell curry was a man, who said that he would stop the destructive updates of the world!)
16:30:41 <SamB> Pseudonym: ooh, like the library at my school
16:30:44 <gwern> where's Wadler?
16:30:48 <gwern> (oh, there he is!)
16:30:49 <chrisdone> haha
16:30:50 <dons> Pseudonym: i see sticks and sprynges.
16:30:53 <Pseudonym> SamB: Which school?
16:30:54 <erikc> most languages are gonna have a rough time stealing purity and laziness and selling it to their existing userbases
16:30:56 <SamB> widener
16:31:14 <SamB> the only thing they did to try to make it anything but ugly is make it triangular
16:31:15 <gwern> @quote sprynges
16:31:16 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
16:31:17 <SamB> it doesn't really help
16:31:21 <hugo___1> i want to invest in haskell, as a professional programmer it seems like the right solution as far as my future is concerned
16:31:21 <Pseudonym> SamB: http://en.wikipedia.org/wiki/File:Widener.jpg That?
16:31:34 <mapreduce> erikc: Laziness is pretty well done in linq.
16:31:42 <SamB> no, the library is wolfgram
16:31:43 <Toxaris> I don't see too much point in comparing Haskell or Haskell programming with Arts, because it isn't from my POV. more interesting to compare it with scientific or technological trends.
16:31:58 <dons> hugo___1: well, you'll understand the major innovations in programming of the last 10 years before they hit the mainstream
16:32:07 <Pseudonym> Ah.  Yes, SamB, that's Brutalist.
16:32:15 <kig> Eduard_Munteanu: X analog clock under 50k? i'd like to see that
16:32:34 <Pseudonym> The National Theatre in London and the High Court of Australia are also good examples of Brutalism.
16:32:56 <kig> (after checking that a simple Xlib program that draws a single line takes 200k..)
16:32:58 <Eduard_Munteanu> kig, using only X drawing and dynamic linking, it sounds achievable.
16:33:03 <erikc> mapreduce: i reject linq for it not being D :) (Chris Date's D, not Walter Bright's D)
16:33:13 <mpeter> > map (pred . chr) ffs
16:33:15 <lambdabot>   "deben cuantas veces la hazan~a de los pescados de la luz del sol los pobre...
16:33:21 <Eduard_Munteanu> kig, maybe it's statically-linked.
16:33:24 <augustss> Pseudonym: And Barbican :)
16:33:25 <hugo___1> lets see out it turns out... lisp is always a worst case scenario as far as inovations go
16:33:36 <mapreduce> erikc: URL, or better terms to google
16:33:37 <mapreduce> ?
16:33:40 <kig> 900 res, 700 shr
16:33:58 <Pseudonym> augustss, precisely.
16:33:58 <lowasser> while I'm here, I just uploaded rangemin-1.0 to hackage; comments appreciated
16:34:09 <Pseudonym> Look at those buildings and tell me you don't see Fortran.
16:34:10 <mpeter> i can't think of anything else funny to do with lambdabot
16:34:24 <gwern> mpeter: vixen is good
16:34:34 <mpeter> ?
16:34:36 <erikc> mapreduce: http://www.thethirdmanifesto.com/
16:34:37 <augustss> Pseudonym: ah, yes
16:34:38 <gwern> mpeter: or you could look at themueval repo and try all the evil expressions on lambdabot
16:34:42 <gwern> ?vixen a/s/l
16:34:43 <lambdabot> 19/f/California
16:34:47 <gwern> @where me
16:34:48 <lambdabot> I know nothing about me.
16:34:52 <gwern> @where you
16:34:53 <lambdabot> I'm right here, silly.
16:34:54 <Gracenotes> > take 10 ffs
16:34:55 <lambdabot>   [101,102,99,102,111,33,100,118,98,111]
16:35:54 <Eduard_Munteanu> ?Eduard_Munteanu a/s/l
16:35:55 <lambdabot> Unknown command, try @list
16:36:02 <pumpkin> lol
16:36:18 <Gracenotes> And, those creative facets of lambda's personality arguably don't exist unless someone executes them
16:36:29 <Gracenotes> lambdabot's, that is
16:36:36 <SamB> Pseudonym: to be absolutely clear, the building I refer to is here: http://maps.google.com/maps?q=wolfgram+library&ie=UTF8&ll=39.861975,-75.357604&spn=0.000867,0.001542&t=h&z=19
16:36:36 <lowasser> that's an interesting question, hehe
16:36:38 <Eduard_Munteanu> Yeah, of course.
16:37:05 <Eduard_Munteanu> @list
16:37:05 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:37:21 <SamB> the marker is totally off due to the library having a bogus address
16:37:32 <mpeter> @fact 2=5
16:37:32 <lambdabot> 2=5: hello
16:37:52 <teko> ?vixeyn a/s/l
16:37:52 <lambdabot> 19/f/California
16:37:57 <teko> ?vixey a/s/l
16:37:57 <lambdabot> 19/f/California
16:38:03 <teko> ?dons a/s/l
16:38:03 <lambdabot> a/s/l not available
16:38:07 <pumpkin> lol
16:38:14 <gwern> heh.
16:38:16 <SamB> ?dons Data.Map
16:38:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
16:38:23 <gwern> (dons is not avaluable anyway)
16:38:42 <sereven> dons is priceless
16:38:42 <Gracenotes> ?dons dons
16:38:42 <lambdabot> dons not available
16:38:53 <pumpkin> lol
16:38:56 <mpeter> @fact HIV
16:38:56 <lambdabot> hiv: HIV DOESNT CAUSE AIDS LOL
16:39:03 <gwern> *available
16:39:05 <ben_h> oh dear
16:39:12 <lowasser> oh dearie me indeed
16:39:15 <gwern> @fact lisp
16:39:16 <lambdabot> I know nothing about lisp
16:39:27 <mpeter> @fact AIDS
16:39:28 <lambdabot> aids: AIDS ISNT CAUSED BY HIV LOL
16:39:35 <Eduard_Munteanu> ?fortune
16:39:36 <lambdabot> SANTA IS BRINGING GOOD WISHES FROM ALL THE
16:39:36 <lambdabot> MICRO ARTISTS GANG!  MAY 1988 BE A HAPPY YEAR!
16:39:36 <lambdabot>  
16:39:36 <lambdabot> 					     \__\_ :. ___/
16:39:36 <lambdabot> 						..\  /--
16:39:38 <lambdabot> [10 @more lines]
16:39:42 <Gracenotes> ..
16:39:58 <lowasser> bahahahaha
16:40:04 <ben_h> ?ben_h a/s/l
16:40:04 <lambdabot> Unknown command, try @list
16:40:12 <gwern> fortune is working again?
16:40:15 <mapreduce> > a/s/l
16:40:17 <lambdabot>   a / s / l
16:40:20 <Eduard_Munteanu> vixen is actually a command.
16:40:30 <ben_h> ahh lol
16:40:30 <Eduard_Munteanu> ?fortune
16:40:31 <lambdabot> Rincewind had generally been considered by his tutors to be a natural wizard
16:40:31 <lambdabot> in the same way that fish are natural mountaineers.  He probably would have
16:40:31 <lambdabot> been thrown out of Unseen University anyway--he couldn't remember spells and
16:40:31 <lambdabot> smoking made him feel ill.
16:40:31 <lambdabot> 		-- Terry Pratchett, "The Light Fantastic"
16:40:36 <mpeter> @fact ofmatter
16:40:37 <lambdabot> ofmatter: as a matter of fact, that is
16:40:40 <Gracenotes> @fact LOL
16:40:41 <lambdabot> I know nothing about lol
16:40:46 <Gracenotes> few do.
16:40:51 <Eduard_Munteanu> :))
16:40:53 <ben_h> lol
16:41:08 <gwern> @fact haskell
16:41:08 <lambdabot> I know nothing about haskell
16:41:20 <gwern> don't worry, we'll teach you
16:41:32 <mpeter> @fact lambdabot
16:41:33 <lambdabot> lambdabot: I am the SONGBIRD of orgasmic PASTRY treason
16:41:35 <Adamant> @fact ninjas
16:41:35 <lambdabot> I know nothing about ninjas
16:41:44 <Adamant> @fact mammals
16:41:44 <Gracenotes> :O
16:41:45 <lambdabot> I know nothing about mammals
16:41:57 <gwern> @fact real ultimate power
16:41:58 <lambdabot> I know nothing about real
16:42:05 <gwern> @quote ultimate
16:42:06 <lambdabot> shapr says: The legal system is the ultimate denial of service attack.
16:42:12 <gwern> @quote ultimate
16:42:13 <lambdabot> Korollary says: Isn't wikipedia the ultimate human knowledge trashcan?
16:42:15 <Eduard_Munteanu> ?fact-set mammals are animals
16:42:15 <lambdabot> Fact recorded.
16:42:15 <Adamant> @fact pirates
16:42:15 <lambdabot> I know nothing about pirates
16:42:18 <augustss> @quote
16:42:19 <lambdabot> oerjan says: i only do impractical things
16:42:22 <Eduard_Munteanu> ?fact mammals
16:42:22 <lambdabot> mammals: are animals
16:42:43 <mapreduce> > let a . b = b a in let isBoring = const True in "botabuse".isBoring
16:42:44 <augustss> @quote
16:42:44 <lambdabot>   True
16:42:45 <lambdabot> JonathanShapiro says: This sort of "let's do a conservative, evaluable experiment" approach makes project funding nearly impossible to obtain in academic circles, which may help to explain why
16:42:45 <lambdabot> computer scientists tend to step on each other's toes rather than standing on each other's shoulders.
16:42:50 <Eduard_Munteanu> ?fact-scon mammals
16:42:50 <lambdabot> Maybe you meant: fact-cons fact-snoc
16:42:56 <Eduard_Munteanu> ?fact-snoc mammals
16:42:56 <lambdabot> Fact altered.
16:43:00 <mpeter> @slap lambdabot
16:43:01 * lambdabot activates her slap-o-matic...
16:43:03 <Eduard_Munteanu> ?fact mammals
16:43:03 <lambdabot> mammals:  are animals
16:43:06 <gwern> ?fact-set ninjas are mammals
16:43:07 <lambdabot> Fact recorded.
16:43:16 <gwern> ?fact-cons ninjas are totally sweet
16:43:16 <lambdabot> Fact altered.
16:43:21 <gwern> ?fact ninjas
16:43:21 <Adamant> ?fact-set ninja like to flip out
16:43:21 <lambdabot> Fact recorded.
16:43:21 <lambdabot> ninjas: are totally sweet are mammals
16:43:25 <Eduard_Munteanu> ?fact-delete mammals
16:43:26 <lambdabot> Fact deleted.
16:43:26 <Gracenotes> @slap ..
16:43:26 * lambdabot secretly deletes ..'s source code
16:43:39 <Adamant> @fact ninja
16:43:39 <lambdabot> ninja: like to flip out
16:44:00 <gwern> ?fact-cons ninjas flip out for no reason
16:44:01 <lambdabot> Fact altered.
16:44:06 <gwern> @fact ninjas
16:44:06 <lambdabot> ninjas: flip out for no reason are totally sweet are mammals
16:44:16 <Eduard_Munteanu> > let f n = f (n + 1)
16:44:17 <lambdabot>   <no location info>: parse error on input `;'
16:44:20 <Adamant> ?fact Vikings are the natural enemy of ninja
16:44:21 <lambdabot> I know nothing about vikings
16:44:27 <Eduard_Munteanu> , let f n = f (n + 1)
16:44:28 <lunabot>  luna: parse error on input `)'
16:44:29 <gwern> @fact pirates
16:44:30 <lambdabot> I know nothing about pirates
16:44:32 <mpeter> i think i have a bad influence on you guys
16:44:41 <gwern> @fact god
16:44:42 <SamB> oh, check out these stupid windows: http://maps.google.com/maps?q=wolfgram+library&ie=UTF8&ll=39.861648,-75.35832&spn=0,359.998458&t=h&z=19&layer=c&cbll=39.862027,-75.358704&panoid=INsPU5a740AIDhQMS06I1w&cbp=12,55.16991052331957,,2,2.758364964809921
16:44:42 <lambdabot> I know nothing about god
16:44:58 <gwern> @fact-set god gave ninjas dominion over everything totally sweet
16:44:59 <lambdabot> Fact recorded.
16:44:59 <Adamant> LOL mpeter causes fact-setting
16:45:11 <Gracenotes> > let f (n - 1) = f n --lols?
16:45:12 <lambdabot>   <no location info>: Parse error in pattern
16:45:19 <gwern> @fact-set haskell is the ninja of programming languages
16:45:20 <lambdabot> Fact recorded.
16:45:30 <Gracenotes> where k = -1 :/
16:45:35 <SamB> you see those 3 black windows?
16:45:58 <Eduard_Munteanu> SamB, wtf, did they take those photos at that angle?
16:45:58 <mpeter> @yhjulwwiefzojcbxybbruweejw
16:45:59 <lambdabot> "\""
16:46:08 <mpeter> oO
16:46:12 <SamB> Eduard_Munteanu: what ?
16:46:17 <SamB> that's the street view!
16:46:25 <mpeter> @jargon moby
16:46:26 <lambdabot> *** "moby" jargon "Jargon File (4.3.1, 29 Jun 2001)"
16:46:27 <lambdabot> moby /moh'bee/ [MIT: seems to have been in use among model railroad
16:46:27 <lambdabot>    fans years ago. Derived from Melville's "Moby Dick" (some say from `Moby
16:46:27 <lambdabot>    Pickle'). Now common.] 1. adj. Large, immense, complex, impressive. "A
16:46:27 <lambdabot>    Saturn V rocket is a truly moby frob." "Some MIT undergrads pulled off a
16:46:29 <lambdabot> [42 @more lines]
16:46:36 <mpeter> 42???
16:46:40 <Eduard_Munteanu> SamB, I know, but how do they take the pictures?
16:46:42 <gwern> @more
16:46:43 <lambdabot>    moby hack at the Harvard-Yale game." (See {Appendix A} for discussion.)
16:46:43 <lambdabot>    2. n. obs. The maximum address space of a machine (see below). For a
16:46:43 <lambdabot>    680[234]0 or VAX or most modern 32-bit architectures, it is
16:46:43 <lambdabot>    4,294,967,296 8-bit bytes (4 gigabytes). 3. A title of address (never of
16:46:43 <lambdabot>    third-person reference), usually used to show admiration, respect,
16:46:45 <lambdabot> [37 @more lines]
16:46:48 <Eduard_Munteanu> I presume not from the satellite.
16:46:50 <gwern> @more
16:46:51 <lambdabot>    and/or friendliness to a competent hacker. "Greetings, moby Dave. How's
16:46:51 <lambdabot>    that address-book thing for the Mac going?" 4. adj. In backgammon,
16:46:51 <lambdabot>    doubles on the dice, as in `moby sixes', `moby ones', etc. Compare this
16:46:53 <lambdabot>    with {bignum} (sense 3): double sixes are both bignums and moby sixes,
16:46:55 <lambdabot>    but moby ones are not bignums (the use of `moby' to describe double ones
16:46:57 <lambdabot> [32 @more lines]
16:47:00 <gwern> @more
16:47:01 <lambdabot>    is sarcastic). Standard emphatic forms: `Moby foo', `moby win', `moby
16:47:01 <lambdabot>    loss'. `Foby moo': a spoonerism due to Richard Greenblatt. 5. The
16:47:03 <lambdabot>    largest available unit of something which is available in discrete
16:47:03 <SamB> Eduard_Munteanu: oh, they drive a vehicle with appropriate cameras around the streets
16:47:03 <redditbot> TypeHash: verify serialised data
16:47:04 <mpeter> you have far more patience than me, gwern
16:47:05 <lambdabot>    increments. Thus, ordering a "moby Coke" at the local fast-food joint is
16:47:07 <lambdabot>    not just a request for a large Coke, it's an explicit request for the
16:47:09 <lambdabot> [27 @more lines]
16:47:09 <gwern> good grief. it wasn't kidding
16:47:11 <SamB> anyway, please stop the flooding
16:47:21 <Eduard_Munteanu> SamB, so it's available only on certain locations.
16:47:21 <mpeter> i need to do one more
16:47:22 <Gracenotes> ffs, http://www.jargondb.org/glossary/moby
16:47:27 <mpeter> to see how that sentence ends
16:47:29 <mpeter> @more
16:47:29 <lambdabot>    largest size they sell.
16:47:29 <lambdabot>  
16:47:29 <lambdabot>    This term entered hackerdom with the Fabritek 256K memory added to the
16:47:29 <lambdabot>    MIT AI PDP-6 machine, which was considered unimaginably huge when it was
16:47:29 <lambdabot>    installed in the 1960s (at a time when a more typical memory size for a
16:47:31 <lambdabot> [22 @more lines]
16:47:34 <mpeter> there you go
16:47:53 <SamB> ANYWAY, those three black windows are completely useless
16:47:55 <mpeter> > ffs
16:47:57 <lambdabot>   [101,102,99,102,111,33,100,118,98,111,117,98,116,33,119,102,100,102,116,33,...
16:48:01 <gwern> interesting. seems I can't trigger @more in privmsg
16:48:07 <mpeter> > map (pred . chr) ffs
16:48:09 <lambdabot>   "deben cuantas veces la hazan~a de los pescados de la luz del sol los pobre...
16:48:25 <Eduard_Munteanu> :t ffs
16:48:26 <lambdabot> [Int]
16:48:29 <SamB> I was actually looking at them on streetview from the very room that they would be in ... but there's just wall there!
16:48:48 <Gracenotes> > map (succ . chr) ffs
16:48:50 <lambdabot>   "fgdgp\"ewcpvcu\"xgegu\"nc\"jc|cp\128c\"fg\"nqu\"rguecfqu\"fg\"nc\"nw|\"fgn...
16:48:54 <Gracenotes> lovely
16:49:01 <Eduard_Munteanu> > (\f = f 1) 1
16:49:02 <lambdabot>   <no location info>: parse error on input `='
16:49:03 <mpeter> now what was the use of that ;)
16:49:07 <Eduard_Munteanu> > (\f -> f 1) 1
16:49:08 <lambdabot>       No instance for (Num (t -> a))
16:49:08 <lambdabot>        arising from the literal `1' at <...
16:49:27 <augustss> > length ffs
16:49:27 <Gracenotes> > map chr ffs --so very useful, as well
16:49:28 <mpeter> hmm
16:49:29 <lambdabot>   "efcfo!dvboubt!wfdft!mb!ib{bo\DELb!ef!mpt!qftdbept!ef!mb!mv{!efm!tpm!mpt!qp...
16:49:29 <lambdabot>   94
16:50:03 <int-e> > map (chr . pred) ffs -- '!' is 33 and most likely should be a space
16:50:04 <lambdabot>   "deben cuantas veces la hazan~a de los pescados de la luz del sol los pobre...
16:50:07 <Eduard_Munteanu> > let "Stop consing me!":ffs
16:50:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:50:16 <Eduard_Munteanu> > "Stop consing me!":ffs
16:50:17 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Int'
16:50:40 <int-e> silly games
16:50:46 <Gracenotes> > "Stop consing me!" ++ map (chr . pred) ffs
16:50:48 <lambdabot>   "Stop consing me!deben cuantas veces la hazan~a de los pescados de la luz d...
16:50:58 <Eduard_Munteanu> Oh yeah.
16:51:10 <mpeter> > words (map (pred . chr) ffs)
16:51:12 <lambdabot>   ["deben","cuantas","veces","la","hazan~a","de","los","pescados","de","la","...
16:51:44 <Eduard_Munteanu> > reverse (words (map (pred . chr) ffs))
16:51:45 <lambdabot>   ["funcionamiento","del","pobres","los","sol","del","luz","la","de","pescado...
16:52:14 <Gracenotes> isn't a pescado a sin?
16:52:25 <Gracenotes> it seems like so long since I took Spanish
16:52:27 <dolio> Pescado is fish.
16:52:35 <mpeter> "how many times must the sunlight fish exploit the working poor"
16:53:14 <mpeter> i think
16:53:30 <Gracenotes> I know we have a borrowed word from Italian meaning "small sin" that sounds awfully like that
16:53:32 <gnuvince_> @seen audreyt
16:53:32 <lambdabot> Last time I saw audreyt was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books,
16:53:32 <lambdabot>  #haskell-hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
16:53:32 <lambdabot> haskell.se, #haskell_ru, #jhc, #jtiger, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 2m 1d 10h 27m ago, and .
16:53:47 <gwern> Gracenotes: peccadilloe
16:54:21 <Gracenotes> yeah, peccadillo. have not seen 'e' variety though...
16:56:22 <gwern> 'Introduction to Algorithms (CLRS): This book may have the most misleading title of any programming book ever published. It's widely used at many universities, usually in graduate level algorithms courses....The title is misleading because the word "Introduction" leads one to believe that the book is a good choice for beginning programmers. It isn't. The book is as comprehensive a guide to algorithms as you are likely to find anywhere. ...
16:56:28 <gwern> ... Please stop recommending it to beginners.'
16:56:38 <Gracenotes> ah, pecado vs. pescado. that must have been it.
16:56:40 <pumpkin> lol
16:57:19 <lowasser> gwern, what prompted this?
16:57:23 <gwern> pisces
16:57:27 <lowasser> ahhhkay
16:57:33 <Gracenotes> gwern: that was a nice book
16:57:33 <gwern> lowasser: my boundless love for all sentient beings
16:57:59 <Gracenotes> I didn't actually have a copy, but I watched lectures on it, from http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/LectureNotes/index.htm
16:58:01 <gwern> 'However, unless you have at least a Masters degree in Computer Science (and in Algorithms specifically), I doubt you've read more than a few selected chapters from Introduction to Algorithms.'
16:58:16 <pumpkin> one of my profs was an author for that
16:58:43 <Gracenotes> gwern: ...I went through the MIT lectures up to chapter 13 before graduating from high school. >_<
16:58:58 <gwern> http://www.reddit.com/r/programming/comments/7jgjd/books_programmers_dont_really_read/ <-- it's good to see the palin jokes aren't dead yet
16:58:58 <Gracenotes> is that an Amazon review?
16:59:43 <lowasser> gracenotes, you're not the only one!
16:59:56 <gwern> amazon links? in *my* reddit?
17:00:01 <gwern> it's more likely than you think!
17:00:14 <pumpkin> well I had finished reading sipser's theory of computation by the end of middle school!
17:00:20 <lowasser> oooh
17:00:23 <lowasser> I LOVED THAT
17:00:24 <pumpkin> CLRS was elementary school stuff
17:00:26 <mpeter> the only thing that makes you program better is to write a massive program from scratch
17:00:28 <pumpkin> like, duh
17:00:34 <Gracenotes> lol
17:00:48 <lowasser> (though I went crazier, I read 6.897 lec notes by graduation)
17:01:03 <gwern> pumpkin: pff. by elementary school I had gone through Pierce's TAPL as some light bedtime reading
17:01:08 <mpeter> and i mean massive, up there with the size of like, photoshop
17:01:08 <pumpkin> lol
17:01:32 <mpeter> no libraries, no shortcuts besides what the OS provides
17:01:34 <mpeter> and make it portable too
17:01:49 <pumpkin> well I was reading the spatial datastructures bible in the womb
17:01:56 <pumpkin> my mom had trouble getting it in, but I enjoyed it a lot
17:02:26 <gwern> pumpkin: I would be impressed by that, except my parents got a complete copy of TAOCP from the future, and encoded it into my genome
17:02:37 <pumpkin> :(
17:02:40 <pumpkin> I can't beat the future
17:02:41 <lowasser> ouch.
17:02:50 <lowasser> except gwern?
17:03:01 <lowasser> I'm going to need to hunt you down and extract a sample of your dna
17:03:02 <gwern> (turns out there's a lot of junk dna)
17:03:13 <Gracenotes> yes, most of it
17:03:18 <pumpkin> it's not junk
17:03:19 <Gracenotes> either repeats or jumbled up stuff
17:03:22 <pumpkin> they showed that it's useful
17:03:30 <Gracenotes> which may, however, serve useful epigenetic roles
17:03:46 <Axman6> "let fib :: Word -> Word; fib 0 = 1; fib 1 = 1; fib n = l + r where l = fib (n-2); r = fib (n-1)" -- leads to ghci panicing...
17:03:52 <gwern> pumpkin: not junk? hm, that explains my various congenital defects and social ineptness
17:03:59 <pumpkin> yup
17:06:03 <mpeter> no, it doesn't play records
17:06:05 <mpeter> it plays CDs
17:07:40 <Axman6> > let fib :: Word -> Word; fib 0 = 1; fib 1 = 1; fib n = l + r where l = fib (n-2); r = fib (n-1) ion fib 20
17:07:41 <lambdabot>   <no location info>: parse error on input `;'
17:07:43 <Axman6> > let fib :: Word -> Word; fib 0 = 1; fib 1 = 1; fib n = l + r where l = fib (n-2); r = fib (n-1) in fib 20
17:07:45 <lambdabot>   10946
17:07:49 <Axman6> hmmm
17:08:18 <SamB> gwern: poor you -- all that MMIX
17:08:30 <Gracenotes> an ion keyword? ;)
17:09:03 <Cale> Hey, what do you guys think? Is there an ascending sequence of measure 0 sets of reals whose union is all of R?
17:09:12 <Axman6> > let ion = in in let 2 + 2 = 5 ion 2 + 2
17:09:14 <lambdabot>   <no location info>: parse error on input `in'
17:10:10 <Gracenotes> hm. if we could make 2 + 2 = 5 an axiom, I wonder what other rules of math we'd have to change
17:10:23 <Gracenotes> obviously, 5 - 2 = 2
17:10:30 <Cale> Gracenotes: If 2 + 2 = 5, and the other usual axioms of arithmetic are true, then 0 = 1
17:10:34 <Axman6> > let 2 + 2 = 5 in 2 + 2
17:10:36 <lambdabot>   5
17:10:45 <augustss> Cale: Sounds weird.  But then the classical reals are weird.
17:10:52 <Gracenotes> cale: yes. although under this system, it would be true
17:10:57 <Cale> Gracenotes: and every number ends up being equal to every other -- you have the trivial ring
17:11:12 <Gracenotes> hm. that's true.
17:11:36 <Cale> augustss: Yeah. For full disclosure, if CH is true, then there is such a sequence.
17:11:53 <SamB> Cale: CH is what ?
17:12:02 <Gracenotes> the actual process of going from 2+2=5 to any other statement is somewhat interesting, though
17:12:09 <augustss> Cale: well, show it to me then! ;)
17:12:11 <Pseudonym> Continuum Hypothesis
17:12:12 <Cale> Continuum hypothesis: There is no cardinality between that of the naturals and the reals.
17:12:12 <Gracenotes> if not completely pointless
17:12:20 <Pseudonym> Yeah, I read it as Curry-Howard at first, too.
17:12:34 <Cale> In fact, if CH is true, then there's an ascending chain of countable subsets of R whose union is all of R.
17:12:36 <Pseudonym> My first thought was: "But it IS true!"
17:13:11 <Cale> Well order the reals with the smallest ordinal whose cardinality is that of R. Then all smaller ordinals are countable.
17:13:33 <Cale> and hence the set of predecessors of any given real is a countable set under that order
17:13:40 <Cale> and hence it has measure 0
17:14:07 <Cale> But I'm not sure whether such a sequence can be obtained independently of CH.
17:14:12 <Gracenotes> CH is hard to wrap my mind around. Hard to imagine what a set with that cardinality would look like intuitively
17:14:29 <Cale> Gracenotes: between the naturals and the reals?
17:14:34 <Gracenotes> yes
17:14:45 <lowasser> well, the point is it's nonintuitive
17:15:20 <Cale> Yeah, it is hard to picture because it's impossible to construct such a set without the negation of CH, and so we have little intuition for what objects sit there.
17:15:39 <Gracenotes> well, Cantor went mad from it, so perhaps I shouldn't touch it :P
17:15:39 <Cale> (CH is independent of the other axioms)
17:16:00 <Cale> I've been finding it rather fun :)
17:16:23 <Cale> Once you know that you can't prove CH either way, it's a bit of a relief. :)
17:17:03 <Gracenotes> It's useful in that it provides an insight into the incompleteness theorem. Or is that vice versa?
17:17:20 <Cale> Well, it's a concrete example of the incompleteness of ZFC.
17:18:27 <Cale> I think I'm leaning towards adopting not-CH these days myself. That well-order where the set of predecessors of any element is countable seems not to fit in well with my sense of how large R is.
17:19:36 <Cale> On the other hand, it can be nice to be able to show that something has cardinality at least that of R by showing that it's not countable.
17:20:06 <mpeter> when they say xmonad is standards compliant
17:20:09 <Gracenotes> at least, including?
17:20:11 <mpeter> what standards are they talking about
17:21:16 <Cale> Gracenotes: yeah. If CH is true, then there's no cardinality in between N and R, so if something is infinite and not countable, then it has the cardinality of R or is larger still.
17:24:30 <Gracenotes> in comp sci one had to assume CH true to show that there was no set X s.t. P(X) is countably infinite. If I recall correctly
17:25:01 <Gracenotes> if X is between N and R... who knows what kind of behavior it might have :/
17:25:06 <Axman6> what's CH?
17:25:07 <Gracenotes> *spooky*
17:25:36 <Gracenotes> it is this: http://en.wikipedia.org/wiki/Continuum_hypothesis
17:26:13 <augustss> I prefer CH to be Curry-Howard.
17:27:14 <Gracenotes> are many of you familiar with Curry-Howard?
17:27:25 <roconnor> djinn is
17:27:56 <roconnor> @djinn (a -> Not (Not b)) -> Not (Not (a -> b))
17:27:56 <lambdabot> f a b = void (b (\ c -> void (a c (\ d -> b (\ _ -> d)))))
17:28:00 <Axman6> @djinn f ? a -> a
17:28:01 <lambdabot> Cannot parse command
17:28:11 <Axman6> @djinn a -> a
17:28:11 <lambdabot> f a = a
17:28:16 <Axman6> >_>
17:28:37 <Eduard_Munteanu> Cale, what do you mean by ascending sequence of sets?
17:28:38 <Gracenotes> @djinn (a -> b) -> Maybe a -> Maybe b
17:28:38 <lambdabot> f a b =
17:28:38 <lambdabot>     case b of
17:28:38 <lambdabot>     Nothing -> Nothing
17:28:38 <lambdabot>     Just c -> Just (a c)
17:28:54 <Gracenotes> neat
17:29:08 <Gracenotes> @djinn (a -> b) -> [] a -> [] b
17:29:09 <lambdabot> Cannot parse command
17:29:18 <augustss> No recursive anything
17:29:19 <Gracenotes> @djinn (a -> b) -> [a] -> [b]
17:29:19 <lambdabot> Error: Undefined type []
17:29:25 <teko> why would i use an FPGA instead of a PIC ?
17:29:25 <Gracenotes> oh
17:29:27 <Eduard_Munteanu> Cale, (R - Q) and Q both have measure 0, and you could think of their union to be the reals, but it depends on how you define "ascending sequence"
17:29:59 <augustss> teko: speed
17:30:08 <teko> kool
17:30:27 <roconnor> R-Q has full measure
17:30:29 <lowasser> each set is contained by its successor?
17:31:00 <Eduard_Munteanu> roconnor, what do you mean?
17:31:27 <roconnor> R-Q has infinite lesbegue measure
17:31:34 <Axman6> @djinn (a -> b) -> f a -> f b
17:31:34 <lambdabot> -- f cannot be realized.
17:32:08 <Gracenotes> @djinn a
17:32:08 <lambdabot> -- f cannot be realized.
17:32:19 <Gracenotes> @djinn a -> a
17:32:19 <lambdabot> f a = a
17:32:23 <Axman6> @djinn (a -> c) -> Either b a -> Either b c
17:32:24 <lambdabot> f a b =
17:32:24 <lambdabot>     case b of
17:32:24 <lambdabot>     Left c -> Left c
17:32:24 <lambdabot>     Right d -> Right (a d)
17:32:32 <Eduard_Munteanu> roconnor, hmm. Sounds strange, though explainable if you take irrationals through Dedekind cuts.
17:32:32 <mmorrow> @where reduceron
17:32:33 <lambdabot> http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
17:32:40 <dolio> @djinn ((a -> Cont s r) -> Cont r r) -> Cont r a
17:32:40 <lambdabot> f a b = a (\ c d -> d (b c)) (\ e -> e)
17:32:45 <mmorrow> teko: check out the reduceron
17:33:05 <mmorrow> err, that was the old page
17:33:07 <mmorrow> http://www.cs.york.ac.uk/fp/reduceron/
17:33:09 <Gracenotes> @djinn Eq a => a -> a -> Bool
17:33:09 <lambdabot> f = (==)
17:33:18 <roconnor> Eduard_Munteanu: it has nothing to do with how you choose to define real numbers
17:33:38 <Gracenotes> not quite sure what it does, but it's neat
17:33:39 <mmorrow> @djinn Cont r a -> Cont a a
17:33:39 <lambdabot> -- f cannot be realized.
17:33:47 <mmorrow> @djinn Cont a a -> Cont r a
17:33:47 <lambdabot> f a b = b (a (\ c -> c))
17:34:17 <mmorrow> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
17:34:18 <lambdabot> f a b = a (\ c _ -> b c) b
17:34:36 <twadleigh> R is the disjoint union of Q and R-Q, and the measure of disjoint sets is the sum of the measures of those sets...
17:34:36 <augustss> Gracenotes: It's a theorem prover and uses CH to get the code.
17:34:47 <Gracenotes> mm, http://www.augustsson.net/Darcs/Djinn
17:35:10 <roconnor> twadleigh: when those sets are measurable.
17:35:22 <twadleigh> (given)
17:35:31 <roconnor> but hey, all subsets of R are measurable right? :D
17:35:36 <Gracenotes> @djinn a -> b -> c -> d
17:35:37 <lambdabot> -- f cannot be realized.
17:35:37 <lowasser> CH being Curry-Howard, or Continuum Hypothesis? lolll
17:35:53 <mmorrow> @djinn-env
17:35:53 <lambdabot> data () = ()
17:35:53 <lambdabot> data Either a b = Left a | Right b
17:35:53 <lambdabot> data Maybe a = Nothing | Just a
17:35:53 <lambdabot> data Bool = False | True
17:35:53 <lambdabot> data Void
17:35:55 <lambdabot> type Not x = x -> Void
17:35:57 <lambdabot> class Eq a where (==) :: a -> a -> Bool
17:35:58 <twadleigh> Banach and Tarksi might have something to say about that...
17:35:59 <lambdabot> type Cont r a = (a -> r) -> r
17:36:07 <augustss> I was impressed that djinn code write the code for Martin Escardo's strange infinite search functions.
17:36:34 <dolio> Nice.
17:36:54 <Gracenotes> @djinn (Eq a) => a -> a -> a -> a -> a -> a -> a -> Bool
17:36:54 <lambdabot> f a b _ _ _ _ _ = a == b
17:36:57 * mmorrow googles for said functions
17:37:36 <mmorrow> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
17:37:37 <augustss> @djinn (Eq a) => a -> a -> a -> Bool
17:37:38 <lambdabot> f a b _ = a == b
17:37:53 <Cale> Eduard_Munteanu: under containment
17:37:56 <sjanssen> hmm, how does djinn treat type classes?
17:38:22 <Cale> Eduard_Munteanu: and yes, R - Q has infinite measure.
17:38:23 <augustss> sjanssen: just as if the methods were passed as arguments, but hidden
17:38:35 <roconnor> @djinn (Monad m) => (a -> b) -> m a -> m b
17:38:35 <lambdabot> Error: Class not found: Monad
17:38:42 <sjanssen> augustss: interesting
17:38:47 <sjanssen> can we teach djinn about Monad?
17:38:53 <augustss> sjanssen: no
17:39:02 <augustss> well, at least I don't know how.
17:39:13 <sjanssen> augustss: oh, because the methods would require rank 2 types?
17:39:19 <chrisdone> http://www.reddit.com/r/programming/comments/7jf7x/as_soon_as_we_started_programming_we_found_to_our/c06tr9i?context=3
17:39:20 <chrisdone> I lol'd
17:39:20 <Gracenotes> @djinn Either (Either a) -> a
17:39:20 <lambdabot> Error: kind error: (KVar 1,KStar)
17:39:23 <pumpkin> @teach djinn Monad
17:39:23 <lambdabot> Unknown command, try @list
17:39:26 <Gracenotes> ops.
17:39:30 <Gracenotes> :/
17:39:35 <Gracenotes> @djinn Either (Either a) -> a
17:39:35 <lambdabot> Error: kind error: (KVar 1,KStar)
17:39:41 <Gracenotes> @djinn Either a -> a
17:39:41 <lambdabot> Error: kind error: (KVar 1,KStar)
17:39:42 <chrisdone> guys, pack up your things
17:39:57 <augustss> sjanssen: the higher kinded type variables doesn't fit at all into how djinn works
17:39:59 <Gracenotes> oh, silly me
17:40:19 <Gracenotes> @djinn Either (Either a b) b -> b
17:40:19 <lambdabot> -- f cannot be realized.
17:40:28 <Gracenotes> @djinn Either (Either a b) b -> a
17:40:28 <lambdabot> -- f cannot be realized.
17:40:37 <Gracenotes> @djinn Either a b -> a
17:40:38 <lambdabot> -- f cannot be realized.
17:40:54 <teko> augustss: PIC or atmega ?
17:41:06 <Gracenotes> eh, no rhyme or reason to this testing..
17:41:10 <augustss> what's atmega?
17:41:16 <teko> AVR
17:41:20 <blackh> chrisdone: Haskell is like rock climbing... WITH a harness.
17:41:46 <roconnor> @djinn (a -> Not (Not b)) -> Not (Not (a -> b))
17:41:46 <augustss> teko: I have no clue
17:41:47 <lambdabot> f a b = void (b (\ c -> void (a c (\ d -> b (\ _ -> d)))))
17:42:03 <roconnor> augustss: I find it intresting that djinn uses void to cast False into False
17:42:08 <augustss> @djinn Either a b -> a -> a
17:42:09 <lambdabot> f a b =
17:42:09 <lambdabot>     case a of
17:42:09 <lambdabot>     Left c -> c
17:42:09 <lambdabot>     Right _ -> b
17:42:17 <roconnor> augustss: Coq's tauto tactic did the same
17:42:36 <Gracenotes> hm.
17:42:49 <augustss> roconnor: I've put no effort into simplifying those things.
17:42:58 <Gracenotes> @hoogle Either a b -> a -> a
17:42:59 <lambdabot> Data.Array.Base writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
17:42:59 <lambdabot> Data.Array.MArray writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
17:42:59 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
17:43:20 <Gracenotes> @hoogle Either a b -> a
17:43:20 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
17:43:20 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
17:43:20 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
17:43:57 <augustss> How is typeOf2 anything like the query?
17:44:19 <augustss> I'll ask Neil tomorrow. :)
17:44:20 <sbahra> :t typeOf2
17:44:22 <lambdabot> forall (t :: * -> * -> *) a b. (Typeable2 t) => t a b -> TypeRep
17:44:29 <Axman6> > typeOf 1
17:44:30 <lambdabot>   Integer
17:44:47 <sbahra> t a b -> TypeRep
17:44:57 <Axman6> > typeOf [[[2],[3]],[[2]]]
17:44:59 <lambdabot>   [[[Integer]]]
17:45:00 <sbahra> > typeOf "?"
17:45:02 <lambdabot>   [Char]
17:45:13 <sbahra> Useful.
17:45:27 <Gracenotes> @type typeOf "?"
17:45:28 <lambdabot> TypeRep
17:45:40 <mriou> hi, does anyone know a non trivial code example that would use ST and multiple STRefs?
17:46:07 <Pseudonym> mriou, how about hash consing?
17:46:33 <mriou> Pseudonym: do you have a link?
17:46:54 <Pseudonym> Not to code.
17:47:09 <Pseudonym> But essentially, it's mutable data structures with cycles and/or sharing.
17:47:25 <Pseudonym> What you'd use pointers for in C-like languages.
17:47:27 <mriou> I was actually looking for existing code to learn from it
17:47:45 <Pseudonym> Ah, OK.
17:47:51 <Pseudonym> Sorry, I don't have any code examples.
17:48:02 <mriou> no worries, sorry if I wasn't clear
17:49:24 <dons> woot, http://www.reddit.com/r/haskell/comments/7jhj8/gmap_composable_maps_and_generic_tries_now_on/
17:49:30 <dons> the gmap tries lib now released.
17:50:32 <dolio> @yow!
17:50:32 <lambdabot> As President I have to go vacuum my coin collection!
17:50:42 <gnuvince_> dons: is there an errata for RWH?  Because I think I found a pretty big error on p.149 with the CannotShow/CannotDeriveShow example.
17:51:17 <dons> there is, via the oreilly site.
17:55:13 <dons> gnuvince_: hard copy?
17:55:26 <Gracenotes> oh dear, I have compsci hw due tomorrow, should probably start it
17:55:26 <dolio> Good show.
17:55:32 <Axman6> > 0 :: Word
17:55:33 <lambdabot>   0
17:55:41 * dons wonders how many errors are in a typical book, given the amount of pre-release tech. review this book got.
17:55:53 <augustss> Plenty
17:56:08 <gnuvince_> dons: http://oreilly.com/catalog/errataunconfirmed.csp?isbn=9780596514983
17:56:09 <dons> yeah. I imagine so.
17:56:12 <gnuvince_> dons: yes
17:56:23 <dons> great thanks.
17:56:24 <pejo> dons, Pierce has the errata for all printings of TAPL online on his homepage.
17:56:32 <dons> these'll go into the online version.
17:56:39 <dolio> I'm sure your book has fewer errors than Joe Celko's SQL for Smarties.
17:56:39 <dons> and i imagined flushed back down the pipeline for the 2nd ed.
17:56:55 <SamB> dons: I should hope they'd get into the 2nd ed. !
17:56:56 <dons> pejo: yeah.
17:57:05 <mmorrow> augustss: how would one encode the types for those infinite search functions to hand them to djinn? (in particular, i don't know what to do about type Natural = Integer)
17:57:11 <pejo> (Considering the size of TAPL the errata is tiny).
17:58:16 <augustss> mmorrow: all the types are abstract.  you can read about in Martin Escardo's paper.
17:59:17 <augustss> mmorrow: I recommend the paper.  He's the one that used djinn, not me.
17:59:32 <mmorrow> ah, cool. i was looking at the wrong code :)
17:59:41 <mmorrow> just found the paper
17:59:42 <Axman6> dons: any plans for a RWH 2.0? (with things like STM etc [if they're not there already?])
18:00:31 <dolio> @djinn-add Searcher d = (d -> Bool) -> d
18:00:32 <lambdabot> Cannot parse command
18:00:36 <dolio> @djinn-add type Searcher d = (d -> Bool) -> d
18:00:45 <augustss> Seems there's room for another book
18:00:49 <dolio> @djinn-add type Quantifier d = (d -> Bool) -> Bool
18:01:05 <dolio> @djinn Searcher d -> Quantifier d
18:01:06 <lambdabot> f _ _ = False
18:01:09 <dolio> Heh.
18:02:05 <mmorrow> dolio: you beat me to it
18:02:20 * mmorrow ditches his clipboard contents
18:02:30 <dolio> @djinn (d -> e) -> Searcher d -> Searcher e
18:02:30 <lambdabot> f a b c = a (b (\ _ -> c (a (b (\ _ -> False)))))
18:03:04 <mmorrow> @djinn Eq e => Searcher d -> (d -> e) -> (d -> e) -> Bool
18:03:04 <lambdabot> f _ _ _ = False
18:03:36 <mmorrow> ah, i guess anything -> Bool ..
18:03:55 <dolio> @djinn Bool -> Bool
18:03:55 <lambdabot> f a = a
18:04:34 <mmorrow> @djinn (n -> Searcher d) -> Searcher(n -> d)
18:04:35 <lambdabot> f a _ b = a b (\ _ -> False)
18:05:13 <mmorrow> @djinn a -> Bool
18:05:13 <lambdabot> f _ = False
18:05:47 <jeffz`> SamB_XP: if you haven't run anything prior to cmd, Wine is booting before it starts cmd, keep something around and it won't shutdown, cmd will start faster
18:05:48 <Gracenotes> ah, now I remember where Djinn was from, GEB
18:06:02 <Gracenotes> or more broadly, just genies
18:06:45 <augustss> @djinn-add data Set a = Set ((a -> Bool) -> a)
18:07:10 <augustss> @djinn (a->b)->Set a -> Set b
18:07:10 <lambdabot> f a b =
18:07:10 <lambdabot>     case b of
18:07:10 <lambdabot>     Set c -> Set (\ d -> a (c (\ _ -> d (a (c (\ _ -> False))))))
18:07:19 <SamB> jeffz`: but why does it take so long to boot ?
18:07:39 <augustss> Doesn't look right.
18:07:40 <SamB> btw SamB_XP does not use wine
18:07:57 <dolio> No, it's not the one he has.
18:08:06 <Gracenotes> augustss: did the name from Godel, Escher and Bach?
18:08:17 <jeffz`> SamB: tab-complete error :) I don't know about the timing.
18:08:47 <augustss> Gracenotes: Not really, but perhaps some subliminal influence.
18:09:44 <augustss> Gracenotes: It's the same word as genie.
18:09:56 <Gracenotes> yeah
18:11:15 <lindzeyn> Djinn
18:11:28 * hoopy is *trying* to buy RWH but o'reilly's site is messing up
18:11:50 <lindzeyn> He makes the pun, Jinn and Tonic when talking about stepping outside of a system
18:12:39 <lindzeyn> hah, I just saw a guy in a coffeeshop with that book hoopy
18:13:04 <lindzeyn> Who cares about the real world
18:13:33 <augustss> http://ginntonic.org/
18:13:47 <cygnus_> real world is cool
18:14:02 <lindzeyn> =/
18:14:03 <mmorrow> wow, that paper's pretty neat
18:14:09 <Gracenotes> awww. cute little one-purpose websites
18:14:56 <augustss> What is there beyond gin'n'tonic anyway?
18:16:06 <lindzeyn> definitely not malaria
18:17:14 <august> what's the 'real wold'?
18:17:36 <lindzeyn> no idea
18:17:54 <lindzeyn> I know what the 'real world' is however
18:18:24 <lindzeyn> its that reality you get thrusted into after Morpheus unplugs you.
18:18:27 <mmorrow> i think foldl.com/foldr.com take the cake for "cute little one-purpose websites"
18:19:13 <augustss> But it's two-purpose
18:19:26 <loop_> two?
18:19:33 <mmorrow> sneaky
18:19:34 <augustss> flodl and foldr
18:20:13 <sstangl> flodr is an IRC bot, do not fail to make this distinction!
18:20:14 * roconnor finds Cale's diagrams better
18:20:44 <roconnor> foldl and foldr don't seem to capture the tail-recursive vs non tail-recursive properties of the folds
18:21:05 <sstangl> roconnor: foldl is tail-recursive; foldr is not.
18:21:17 <sstangl> oh, you mean the sites?
18:21:30 <roconnor> yes but that isn't apparent from foldl.com and foldr.com
18:21:46 <sstangl> send the author an angry letter >:(
18:22:08 <roconnor> should I add flour to the letter?
18:22:18 <sstangl> yes, to the letter.
18:22:22 <augustss> Oliver Steele
18:22:37 <Gracenotes> foldl.com is more fun than foldr.com, in my estimation
18:22:45 <mmorrow> looks like those names were open until 2006 too
18:22:52 <augustss> 23 Forestedge Rd., Amherst, MA 01002
18:22:59 <Axman6> http://www.haskell.org/happy/ needs some minor updates i think
18:23:17 <Gracenotes> now we just need a foldlprime.com
18:23:50 <mmorrow> i just got unsafecoerce.com the other week, so don't even try it ;)
18:24:09 <Axman6> > foldl1 (/) [1..10]
18:24:11 <lambdabot>   2.7557319223985894e-7
18:24:20 <Axman6> > foldl1 (flip (/)) [1..10]
18:24:21 <lambdabot>   4.063492063492063
18:24:29 <Axman6> > foldl1 (flip (/)) [1..10] :: CReal
18:24:30 <lambdabot>   4.0634920634920634920634920634920634920635
18:24:41 <SamB> mmorrow: it lacks captions!
18:25:15 <ikkebr> foldl (-) [1..100]
18:25:20 <mmorrow> SamB: ah, yeah i just wired it to moonpatio.com, so those pictures are unrelated (to it or anything really). i should put something up though for it
18:25:22 <dons> Axman6: stm is in there. but there's rooms for lots more books.
18:25:25 <dons> haskell's a big topic
18:25:27 <ikkebr> > foldl1 (-) [1..100]
18:25:28 <lambdabot>   -5048
18:25:32 <Axman6> :)
18:25:34 <ikkebr> > foldl1 (+) [1..100]
18:25:36 <lambdabot>   5050
18:25:39 <ikkebr> > foldr1 (+) [1..100]
18:25:41 <lambdabot>   5050
18:25:44 <mmorrow> @where hpaste2
18:25:44 <lambdabot> I know nothing about hpaste2.
18:25:50 <mmorrow> @help where
18:25:51 <lambdabot> where <key>. Return element associated with key
18:25:57 <Axman6> @go hpaste2
18:26:00 <mmorrow> how do you set @where
18:26:00 <lambdabot> No Result Found.
18:27:18 <augustss> Who owns unsafeperformio.com?
18:27:28 <mmorrow> andygill
18:27:36 <augustss> ah, yes
18:27:43 <mmorrow> (where i got the idea to whois unsafecoerce.com from)
18:27:55 <SamB> okay ... how about unsafeiotost?
18:28:03 <mmorrow> SamB: it's all you
18:28:12 <augustss> too esoteric
18:28:23 <mmorrow> yeah
18:28:27 <Corun_> TOO ESOTERIC?
18:28:30 <Corun_> That's not possible.
18:28:30 <SamB> what, but I accidentally took ~all of my money out of my bank account
18:28:35 <SamB> lol
18:28:40 <dolio> foldr/l.com doesn't really show you the evaluation of the respective fold. It lets you inspect the terms that result (that is, if you imagine foldl giving you back the accumulator after it finishes with the entire infinite list).
18:29:03 <Axman6> if i actually used any, i wouldn't mine lazyio.com
18:29:17 <mmorrow> dolio: i'd email the Technical Contact: in the whois asap
18:29:21 <sstangl> foldl/r.com require bugtrackers so that we may report these deficiencies.
18:29:59 <Gracenotes> http://www.mapm_.com/, up for the taking
18:30:02 <sstangl> also, the license information of the sites is unspecified.
18:30:12 <Axman6> or functional.com/inators
18:30:18 <sstangl> it would be good if foldl/r.com were CC licensed.
18:30:25 <mmorrow> i just found out that you can get domain names with full unicode
18:30:35 <andyjgill> Yes, I
18:30:37 <SamB>     Steele, Oliver  steele@osteele.com
18:30:39 <SamB> mmorrow: don't!
18:30:42 <mmorrow> i bet there are tons of prime names just waiting to be had
18:30:47 <andyjgill> Yes, I own unsafeperformio.com
18:30:53 <SamB> it'll be too hard to enter the names
18:31:07 <Axman6> SamB: no, it's keep the stupid people out!
18:31:09 <SamB> I'll be interested when you can get c--.net
18:31:13 <Axman6> it'd*
18:31:29 <SamB> Axman6: it's hard enough in Agda
18:31:36 <SamB> I don't need it in URLs as well!
18:31:38 <Axman6> Agda?
18:31:57 <SamB> sometimes there are multiple characters with extremely similar appearence
18:32:05 <Gracenotes> how about, someone buy some Haskell names in bulk, and try to sell them on eBay as 'valuable domain names for marketers seeking to saturate the large Haskell-hungry programming market?'
18:32:18 <mmorrow> those'll sell like hotcakes
18:32:21 <SamB> Gracenotes: please no
18:32:40 <Gracenotes> ;)
18:32:42 <SamB> what if they bought 'em!
18:32:53 <Axman6> just.nothing.com
18:34:23 <SamB> Domain monoid.com:
18:34:24 <SamB>   Telepathy, Inc.
18:35:37 <augustss> My favourite domain name: yes.no
18:35:49 <Gracenotes> http://www.zygohistomorphicprepromorphism.com/ -- not yet taken
18:36:09 <SamB> why does .org whois differ so drastically from .com whois ...
18:36:35 <mmorrow> dang, yes.no is super prime
18:36:53 <Axman6> @src Num
18:36:53 <lambdabot> class  (Eq a, Show a) => Num a  where
18:36:53 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:36:53 <lambdabot>     negate, abs, signum     :: a -> a
18:36:53 <lambdabot>     fromInteger             :: Integer -> a
18:37:16 <Axman6> i don't get how fromInteger is supposed to work :\
18:37:54 <Axman6> @src fromInteger
18:37:55 <lambdabot> Source not found. Are you on drugs?
18:38:10 <kig> by magic, just like this
18:38:16 <kig> @src (-)
18:38:17 <lambdabot> x - y = x + negate y
18:38:21 <kig> @src negate
18:38:21 <lambdabot> negate x = 0 - x
18:38:44 <SamB> oh I love this
18:38:45 <augustss> Axman6: How do you mean?  It works differently for different types.
18:38:50 <SamB> Email Address..............: maybe@yes.no
18:38:59 <augustss> haha
18:39:15 <Gracenotes> what country is no? norway?
18:39:17 <mmorrow> here's a list of all the available suffixes http://en.wikipedia.org/wiki/Country-code_top-level_domain
18:39:24 <augustss> yes, norway
18:39:25 <Gracenotes> apparently.
18:39:26 <mmorrow> (that allow foreign registration)
18:39:28 <SamB> Country....................:
18:39:33 <SamB> whoops
18:39:35 <SamB> Country....................: Norway
18:40:16 <Gracenotes> with new ICANN rules, no longer will Tuvalu profit from .tv names!
18:40:24 <SamB> Gracenotes: what ?
18:40:29 <SamB> why not ?
18:40:33 <Gracenotes> ...whenever they get implemented
18:40:34 <mmorrow> oh crap, someone has as.is
18:40:38 <augustss> So how will they survive?
18:40:45 <SamB> isn't that their ISO-given country code ?
18:41:01 <Gracenotes> perhaps Tuvalu should have thought of that before they decided to game such a volatile system :<
18:42:04 <SamB> so what's their new ISO country code ?
18:42:21 * FunctorSalad mumbles something about christmas island
18:42:38 <SamB> do they now have to use .tuv domains ?
18:42:38 <Gracenotes> SamB: more something like http://news.bbc.co.uk/mobile/bbc_news/world/europe/747/74748/story7474889.shtml?ooter
18:42:55 <mmorrow> nobody has emacs.vi ...
18:43:28 <teko> y is emacs better haskell editing than jedit ?
18:43:31 <Gracenotes> it rectifies the problems of .tv ceasing to exist if Tuvalu does
18:44:12 <augustss> because emacs is always the best choice
18:44:35 <mmorrow> blasphemy!
18:44:54 <teko> emacs isnt really crossplatform like jedit
18:45:09 <Gracenotes> vi is the ultimate cross-platform editor
18:45:10 <jeffz`> emacs probably runs on more platforms than jedit does
18:45:16 <mmorrow> yi is pretty cool, and i'm sure it'll be way cooler once i figure out how to make it do stuff
18:45:26 <Gracenotes> I try to be overall neutral, but vi definitely has that going for it
18:45:30 <teko> its behavior differs from platform to platform
18:45:33 <gwern> mmorrow: what are you trying to do? I have some small competency with yi
18:45:51 * Axman6 can't even get yi working...
18:46:01 <augustss> teko: emacs behaves the same on all platforms I've ever used it on.
18:46:27 <mmorrow> gwern: be able to hold a conversation while making it do whatever's coming off my stream of conscious :)
18:47:04 <redditbot> gmap: Composable maps and generic tries: Now on Hackage
18:47:11 <mmorrow> gwern: so, nothing in particular. just to a point where i don't need to look up how to do whatever happens to need doing
18:47:22 <gwern> mmorrow: I've never used an editor which could hold a conversation with me; (doctor-mode doesn't count)
18:47:26 <chrisdone> hmm. I have a problem posting to Haskell Cafe. can I ask about it here?
18:47:38 <chrisdone> â€˜You are not allowed to post to this mailing list, and your message has
18:47:38 <chrisdone> been automatically rejected.  If you think that your messages are
18:47:38 <chrisdone> being rejected in error, contact the mailing list owner at
18:47:46 <chrisdone> damn
18:47:54 <SamB> have you joined the list ?
18:47:54 <erikc> harsh
18:47:55 <mmorrow> gwern: i'm betting my bottom dollar that one of these time yi's juts going to strike on up with me.
18:47:57 <chrisdone> I meant to paste that on one line
18:48:15 <chrisdone> SamB: yeah, I can login and everything. I've been receiving emails from the list for months. never sent one, though
18:48:51 <Axman6> redditbot?
18:49:04 <gwern> I'm not sure jedit is more portable than emacs. http://www.gnu.org/software/emacs/MACHINES lists ana wful lot of oss and archs
18:49:32 <teko> "Haskell is not a production-ready language in which any serious developer would consider writing an application of substantial size (apart from theorem provers), so the need for IDE is not that important. Most of Haskell enthusiasts are happy using Emacs or Vim"
18:49:43 <teko> is that true ?
18:49:47 <eyeris> I have the Reinke haskell mode for vim installed. When I hit _T for GHC_ShowType(1), it says "type not known" for every function I've tried it on.
18:49:59 <gwern> teko: well, the last sentence is true. most haskellers do seem to use emacs or vim
18:50:00 <SamB> teko: not true
18:50:10 <MyCatVerbs> teko: I think Galois would point and laugh at anyone saying that.
18:50:15 <SamB> the part before the , is false
18:50:19 <teko> great to hear
18:50:20 <SamB> the rest is true
18:50:29 <eyeris> I've tried standard prelude functions as well as functions defined in the file I am editing.
18:50:38 <MyCatVerbs> teko: Haskell is, however, very very terse. IDEs aren't particularly necessary when your language isn't mind-bogglingly verbose.
18:51:48 <teko> another victory for the circle-subtending lambda!!
18:51:52 <erikc> there also the insane file number explosion because of 1-file-per-class-itus (or 2 for c++)
18:51:56 <erikc> also isnt
18:52:12 <chrisdone> time and time again I show non-haskellers pastes of Haskell, and their comments has always involved the word "concise" and often "short"
18:52:20 <chrisdone> s/has/have
18:52:33 <loop_> what's the difference between an IDE and emacs?
18:52:52 <chrisdone> as did my own comment when I used to hang out in the #scheme channel and someone pasted some haskell. me: "wow, that's concise"
18:52:55 <erikc> loop: IDEs tend to fuse editing with debugging and building
18:52:56 <eyeris> what's emacs can be an IDE but it doesn't have to be
18:52:57 <SamB> loop_: emacs is easier to use
18:53:07 <Gabbie> IDEs are easier to ue.
18:53:11 <Gabbie> Lol
18:53:15 <Gabbie> >.>
18:53:18 <Gracenotes> have there been any notable commercial Haskell applications? I seem to recall a page listing 'em somewhere
18:54:08 <Gracenotes> ah, [[Haskell in industry]]
18:57:56 <blackh> Gracenotes: Don't quote me but I don't think so.  There will be, though, when I have finished my project!
18:58:09 <gwern> what is your project?
18:58:20 <teko> an OS
18:58:27 <chrisdone> @quote blackh
18:58:28 <lambdabot> blackh says: Haskell is great because of all the wonderful things you can't do with it.
18:58:44 <blackh> gwern: It's a web application, but that's all I'm saying at the moment.
18:59:09 <gwern> tease
18:59:19 <pumpkin> blackh: I bet it's awesome!
18:59:31 <vininim> well it's in haskell
18:59:35 <vininim> so of course it is!
18:59:49 <Pseudonym> It's hard to say.  Things in Haskell are awesome, but web apps aren't.
18:59:59 <pumpkin> webapps are even more awesome
19:00:06 <blackh> Well this project is awesome in terms of size, at any rate. :)
19:00:26 <Pseudonym> Ah, so it's awesome in the true sense.
19:00:31 <Pseudonym> Inspiring awe.
19:01:06 <mpeter> web apps are elegant in haskell
19:01:15 <mpeter> hell, all my php and ruby have been functional in form
19:02:09 <blackh> Haskell saves me a huge amount of time and mucking around.  I can make a direct comparison because I started the project in Python.  (I know a lot of people know about this already.)
19:03:10 <chrisdone> blackh: hey, did you check my blog entry about formlets?
19:03:47 <blackh> Well, I have bookmarked your blog, and I see that you have written it. Great! Let me see...
19:03:53 <chrisdone> ha, ok
19:04:18 <pumpkin> chrisdone: what's a good way to add CSS and styling to formlets? is there one?
19:05:08 <chrisdone> pumpkin: besides wrapping divs around them with class/id properties, you can write custom markup or custom input elements. that is one way I can think of
19:05:38 <august> so has P=?NP been solved with haskell yet?
19:05:56 <pumpkin> @faq has haskell proved P=NP or P!=NP?
19:05:56 <lambdabot> The answer is: Yes! Haskell can do that.
19:05:58 <QtPlatypus> 13:02 [ DrSyzygy      ] [ Lamperi        ] [ Raevel        ] [ xHemi        ]
19:06:00 <QtPlatypus> 13:02 [ dublpaws      ] [ lanaer         ] [ randomity     ] [ xian         ]
19:06:03 <QtPlatypus> 13:02 [ DuClare       ] [ Laney          ] [ ray           ] [ xinming      ]
19:06:15 <chrisdone> :\
19:07:21 <chrisdone> pumpkin: one could define, for example: classWrap name = F.plug (\xhtml -> thediv ! [X.name name] << xhtml)
19:07:40 <cknapp> Evening, everyone
19:07:43 <chrisdone> with classWrap :: (X.HTML xml, Monad m, Plus xml) => String -> Form xml m a -> Form Html m a
19:07:50 <Cale> I can prove that P = NP or P /= NP. ;)
19:07:58 <chrisdone> pumpkin: see?
19:08:31 <blackh> august: N=1  (old joke)
19:08:35 * Cale takes advantage of the fact that this is a tautology :)
19:09:10 <chrisdone> username = "username" `classWrap` ("Username" `label` F.input Nothing)
19:09:19 <august> this sentence is false
19:09:30 <chrisdone> and then in your CSS, of course .username { color: red; font-family: "Comic Sans MS"; }
19:09:38 <cknapp> august: Lies!
19:09:42 <Megzlna> Just ask them if Haskell does OO
19:09:59 <pumpkin> chrisdone: that's neat... it would be nice if there were a way to "surround" tags with "attribute-appliers" if you know what I mean, so I can automatically stick class onto tags
19:10:39 <chrisdone> pumpkin: indeed
19:10:45 <cknapp> So... does Haskell do OO?
19:10:50 * cknapp takes the bait
19:11:22 <ddarius> Cale: Only in classical logic.
19:11:27 <chrisdone> pumpkin: seems like a property of the markup library you are using, I think, rather than formlets, which is markup-agnostic
19:11:41 <chrisdone> pumpkin: Text.XHtml obviously can't, but perhaps other XML libraries let you do that?
19:11:48 <Cale> cknapp: I think the reasonable answer is that no it does not do OO, but that there are comparable means of abstraction.
19:12:03 <cknapp> Cale: that was the answer I expected, actually...
19:12:49 <chrisdone> cknapp: what does â€˜OOâ€™ mean?
19:13:02 <loop_> does haskell do two big eyes
19:13:09 <chrisdone> @_@
19:13:10 <cknapp> I know in scheme (and other lisps), a closure with imperative bits is used to make objects... that can't happen here....
19:13:25 <cknapp> chrisdone: Object oriented... there should be more to the acronym
19:13:35 <dolio> Actually, if that's what you take it to mean, you can do that.
19:13:37 <chrisdone> cknapp: what does â€˜object orientedâ€™ mean?
19:13:55 <cknapp> chrisdone: what other languages have you learned?
19:14:03 <dolio> Your 'closure' just involves monads.
19:14:06 <chrisdone> cknapp: what does that have to do with anything?
19:14:17 <cknapp> I might be able to provide analogies :)
19:14:30 <Cale> cknapp: and not only that, but you can purify that by simply making operations which would have been effectful produce a new version of the object.
19:14:37 <chrisdone> can't you define the term you are using?
19:15:27 <Cale> That is, instead of having a tuple of effectful procedures, you have that an object is a tuple of functions which produce new similar tuples of functions.
19:15:28 <blackh> cknapp: I think you can do OO in Haskell.
19:15:46 <Cale> (though that ignores much of OO)
19:16:01 <roconnor> Oleg has an OO lib
19:16:02 <cknapp> Cale: Ah... that's tricky.
19:16:16 <ddarius> "You can do OO in Haskell as long as you restrict OO to be the stuff that you can do in Haskell."
19:16:21 <Cale> hehe
19:16:59 <roconnor> I wonder if there are any university courses on Oleg
19:17:00 <Cale> cknapp: It's a little sneaky -- it's essentially an encoding of existential types.
19:17:08 <Cale> (which you can also do)
19:17:47 <Cale> Existential types give you what I think of as the heart of OO, but not things like inheritance.
19:17:53 <cknapp> chrisdone: objects are essentially "functions with state" (to quote someone else). You have functions of some sort, which have access to their own internal state. It's a broad term, and can be applied to a lot of different styles of programming... hence the difficult in defining it
19:18:14 <ddarius> I wouldn't say it's an encoding of existential types, but rather that it uses the existential type implicit in closures.
19:18:57 <Cale> ddarius: Well, I have a feeling (possibly unsubstantiated) that any existential type can be converted into one of these.
19:19:23 <cknapp> Hmm.... reading Kant and the Platypus and having a discussion in #haskell in the same night has a way of overwhelming your brain...
19:19:33 <cknapp> What exaclty is an existential type?
19:19:48 <mpeter> cknapp: try doing psychedelics at the same time
19:19:50 <cknapp> s/exaclty/exactly
19:19:52 <ddarius> Cale: I have a similar feeling except it's the negation.  "Translucent" uses do not look like they can be encoded easily, and I believe that not all such uses can be encoded in Haskell.
19:20:07 <Cale> ddarius: Translucent?
19:20:08 <cknapp> mpeter: hmm....
19:20:12 <cknapp> :)
19:20:54 <Megzlna> @src foldl'
19:20:54 <lambdabot> foldl' f a []     = a
19:20:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:21:15 <Cale> cknapp: Basically a type where you're allowed to say that for each value, a type variable takes on *some* type t (but you've forgotten which)
19:21:48 <cknapp> Cale: could you give an example?
19:21:57 <ddarius> Cale: http://okmij.org/ftp/Computation/Existentials.html#eliminating-translucent
19:22:10 <cknapp> Or point me to one...
19:22:26 <mpeter> there are so many ways to piss somebody off inside a movie theatre
19:23:11 <Axman6> having sex on them is pretty good
19:23:38 <Axman6> guess that works most places though
19:23:41 <mpeter> Axman6++
19:23:50 <Axman6> @karma Axman6
19:23:50 <lambdabot> You have a karma of 2
19:23:57 <Axman6> yusss
19:24:05 <blackh> But are there any ways of pissing someone off inside a movie theatre that are relevant to Haskell?
19:24:23 <cknapp> blackh: try to teach them category theory?
19:24:28 <Cale> ddarius: ah, interesting example
19:24:37 <Axman6> writing haskell in a theatre would piss a lot of people off
19:24:59 <blackh> Swap the reel for the Catsters
19:25:13 * chrisdone facepalms
19:25:44 <Cale> cknapp: okay, let's take a look at one... data Foo = forall s. F (s, s -> s, s -> IO ())
19:25:50 <SamB> blackh: are the catsters available in movie film form ?
19:25:50 <Megzlna> Does seq have a hook in the implementation?
19:26:16 <mpeter> now how do we differentiate Cale from Caleb?
19:26:20 <mpeter> and Caleb from Caelum?
19:26:36 <mpeter> and Caelum from cods and cognominal???
19:26:41 <chrisdone> declare an instance of Eq, of course!
19:26:51 <Cale> cknapp: The use of 'forall' might seem a bit odd, seeing as we're calling it an existential type, but the point is that the forall is outside the data constructor, so it's equivalent to  data Foo = F (exists s. (s, s -> s, s -> IO ()))
19:27:22 <Cale> cknapp: So, some examples of values of this type:
19:27:38 <Cale> F (0, (+1), print)
19:27:54 <Cale> F ("", (++"#"), putStrLn)
19:28:42 <Cale> (The tuple is a bit superfluous, btw.)
19:28:43 <chrisdone> (compare to data Foo s = F (s, s -> s, s -> IO ()))
19:28:58 <Cale> Yeah, those two examples are both of type Foo
19:29:21 <Cale> So when we apply the F constructor, we're essentially forgetting the type s.
19:29:48 <cknapp> Hmm... How?
19:29:56 <cknapp> Oh!
19:29:59 <cknapp> nevermind.
19:30:07 <cknapp> Get it. (Thanks, chrisdone.)
19:30:43 <Cale> When we use case to pattern match, we're allowed to assume there's some type s, but we're not allowed to assume anything about what that type is (even if we actually know what it is)
19:31:08 <Cale> This effectively limits us to applying the functions packaged along in the existential type.
19:31:21 <gwern> holy cow. linking gitit is taking 60% of my 4 gigs of ram
19:31:23 <cknapp> I see...
19:31:30 <gwern> > 0.60 * 4000
19:31:32 <lambdabot>   2400.0
19:31:40 <Cale> That is, we can apply the function of type s -> s some number of times, and then possibly apply the s -> IO () to get an IO action, or we could make a new value of type Foo.
19:32:15 <Cale> (we could also do things like replace the s -> s function with its composite with itself)
19:33:01 <Philonous> You could also add a class restriction that actually allows you to do something interesting with the values.
19:33:18 <gwern> > 0.642 * 4000
19:33:19 <lambdabot>   2568.0
19:33:25 <Cale> Right, which is more or less like packaging the typeclass dictionary along with the rest of it.
19:33:27 <dolio> That's the same as packaging the methods of the class with the existential, though.
19:33:40 <gwern> ye flippin' gods. I wonder how anyone compiles gitit if it takes 2.5 gigs to link
19:34:31 <pumpkin> 2.5 gigs of ram? :o
19:34:32 <erikc> gwern: 2.5 gigs in ld?
19:34:34 <SamB> gwern: without -fsplit-objs ?
19:34:58 <gwern> no, I think it's with
19:35:35 * erikc remembers how linking some spec2006 benchmarks with whole program optimization consumed 60 gigs ram
19:35:56 <SamB> gwern: that was my proposed method by which people without 4 gigs might be able to compile it, actually ;-P
19:36:18 <gwern> 66.3% :(
19:36:30 <erikc> is that ld?
19:36:33 <erikc> or ghc
19:36:35 <SamB> of course!
19:36:37 <SamB> ld
19:36:38 <erikc> ah
19:36:41 <SamB> ld is a HOG
19:36:58 <erikc> i wonder if ghc would work with gold
19:37:28 <Megzlna> What keeps Haskell from being as fast as C++, besides boxed values and dictionaries?
19:38:06 <chrisdone> a couple milliseconds?
19:38:22 <erikc> laziness (creating thunks), link data structures, garbage collection and heavy allocation patterns (depends on application, of course)
19:38:28 <SubStack> if you've got a nice algorithm who cares?
19:38:35 <teko> O'Reilly says that its Vim tutorial sells twice as many copies as for Emacs
19:39:13 <Megzlna> SubStack: Depends on what the program does.
19:39:19 <chrisdone> teko: so?
19:39:37 <Cale> teko: Hehe, does that mean that vim is more popular, or that emacs is easier to use? :)
19:39:40 <teko> so nothing i guess
19:39:40 <SubStack> not very often
19:39:47 <chrisdone> haha, ATS is so crazy
19:39:48 <chrisdone> http://shootout.alioth.debian.org/u32/benchmark.php?test=binarytrees&lang=ats&id=2
19:39:52 <chrisdone> "what... *is* that thing?"
19:39:57 <cknapp> Cale: I think that means emacs is just weird, and vim is confusing.
19:40:14 <dons> it starts off ok, chrisdone
19:40:18 <dons> then gets wacky land
19:40:22 <chrisdone> haha
19:40:25 <chrisdone> yeah
19:40:48 <dons> good way to get a research lang noticed.
19:40:51 <gwern> ouch, ld died on me
19:41:09 * dolio has yet to see ATS code he likes.
19:41:13 <gwern> maybe killing firefox will get me enough ram
19:41:25 <pumpkin> what is so special about ATS that makes it do so well on those tests?
19:41:28 <chrisdone> maybe it means emacs users are capable of following the instructions on the start of emacs and doing the tutorial, whereas vim users need to buy a physical book
19:41:51 <gnuvince_> Or maybe Emacs users started using it in 1989 and don't need books anymore
19:42:08 <dolio> Plenty of inline C.
19:42:12 <loop_> ummm.. inline C code
19:42:12 <chrisdone> gnuvince_: there are tonnes of teenager emacs users!
19:42:15 <hydrapheetz> chrisdone: That language looks funky.
19:42:19 <SamB> linear types???
19:42:23 <wli> What's ATS?
19:42:26 <dolio> Plus dependent typing mojo that enables even better optimization.
19:42:41 <chrisdone> hmm, yeah
19:42:58 <chrisdone> I had a paper about dependant types for C 6_6
19:43:03 <gwern> I was a teenage Emacs user!
19:43:09 <SamB> I was
19:43:10 <gwern> sounds like the title of a bad movie doesn't it
19:43:16 <chrisdone> gwen's just a teenage emacs user, baaaaby
19:43:17 <gnuvince_> gwern: how long ago? :)
19:43:20 <SamB> but I turned 20
19:43:25 <SamB> now I'm 22
19:43:45 <gwern> gnuvince_: yes, that's the funny part, that could peg me as being anywhere from 20 to...40-something?
19:43:49 <Gracenotes> how about teenager-at-heart Emacs users
19:43:49 <wli> ATS looks like SML with a C FFI.
19:44:01 <chrisdone> M-x teenager-at-heart
19:44:04 <gwern> depending on your logical interpretation of 'was', and how inclusive your term 'Emacs' is
19:44:08 * hydrapheetz is 19 and still uses vim
19:44:15 <chrisdone> "still"?
19:44:16 <pumpkin> so ATS looks good on benchmark charts but isn't that interesting a language? or does it have any real contributions?
19:44:18 <chrisdone> like, you'll grow out of it?
19:44:22 <hydrapheetz> still.
19:44:25 <erikc> whats the difference between linear typing and uniqueness typing?
19:44:28 * hydrapheetz has been using it for about three years now
19:44:46 * gnuvince_ uses both vim and Emacs.  Best tool for the job I say.
19:44:46 <SamB> gwern: could count you as 14
19:44:51 <SamB> or even 13
19:44:52 <dolio> It has plenty of interesting stuff.
19:44:59 <SamB> if you stopped using emacs while 13
19:45:00 <cknapp> Using vim at the age of 16? You kids start young these days eh?
19:45:06 <hydrapheetz> I guess.
19:45:16 <hydrapheetz> emacs just feels weird to me
19:45:25 <cknapp> Yeah, that's always been my problem...
19:45:40 <gnuvince_> hydrapheetz: vim will keep your fingers healthier
19:45:47 <gnuvince_> Emacs destroys your thumb and pinky
19:45:51 <chrisdone> lies
19:45:52 <gnuvince_> (at least it did for me)
19:45:53 <gwern> let's see, if I was 13 in 1972, then I could be...
19:46:02 <chrisdone> you didn't use correct finger positions, then
19:46:08 <gwern> > (2008 - 1973) + 13
19:46:09 <lambdabot>   48
19:46:28 <chrisdone> gnuvince_: here's something I prepared earlier ... http://chrisdone.com/blog/2008/10/23/Emacs-pinky-solution
19:46:29 <hydrapheetz> I actually reach over to press the ctrl/alt/whatever keys.
19:46:31 <gwern> the oldest I could be to be 'I was a teenage Emacs user' is 48. remarkable
19:46:46 <mpeter> what?
19:46:49 <gwern> so that puts me in an age range from 20-48. what an inclusive group
19:46:51 <gnuvince_> chrisdone: possibly.  But I used the same "bad" position in vim and no pain thanks to modal editing
19:46:56 <SamB> gwern: NO!
19:47:16 <SamB> I already said, you could be a 13-year-old who decided to stop using emacs!
19:47:35 <gnuvince_> chrisdone: what about combinations like C-c C-.?
19:47:37 <mpeter> i never used emacs
19:47:39 <mpeter> emacs sucks
19:47:41 <gwern> SamB: as I said, you could reach different conclusions based on interpretation of 'was' or 'Emacs'
19:47:46 <hydrapheetz> I already know about the vi(m) emulation modes in emacs but it still feels awkward.
19:47:47 <gnuvince_> Do you "interrupt" the command while you switch hands?
19:47:51 <gwern> for example, if you mean only GNU Emacs, 1972 is way off the mark
19:47:52 <mpeter> and i'm still a teenager
19:47:56 <gnuvince_> hydrapheetz: viper-mode sucks
19:47:56 <mpeter> for uh
19:47:58 <mpeter> 13 days
19:48:11 <mpeter> suddenly i feel old
19:48:21 <hydrapheetz> I noticed.
19:48:21 <SamB> gwern: well, "was" means that you used to match the description, but don't anymore
19:48:30 * pumpkin is 5
19:48:45 <SamB> so I guess it's more about "user" than "was" or "emacs"
19:48:54 <cknapp> mpeter: don't worry, you won't feel old when you ahve to wait another year to casually drink a beer at a restaurant...
19:49:02 <cknapp> have*
19:49:05 <gnuvince_> chrisdone: I also have the problem that I can't use AltGr as a second alt; it is used on french canadian keyboards to input certain accented characters (as well as programming characters such as @, [] and {})
19:49:06 <mpeter> i don't have to do that now
19:49:18 <cknapp> You damn non-americans! :D
19:49:25 <SamB> who wants to drink a beer anyway?
19:49:33 <chrisdone> gnuvince_: hmm, I don't know that one. admittedly I don't use long ones too often, which is alright
19:49:35 <cknapp> Me! I like beer (well... good beer)
19:49:49 <dolio> SamB only drinks cosmopolitans.
19:49:51 <mpeter> who said i was a non-american
19:49:58 <gnuvince_> AltGr is the Alt key to the right of the spacebar.
19:49:58 <gwern> hm, gmap made it to hackage
19:50:11 <cknapp> mpeter: I keep making too mayn assumptions...
19:50:14 <SamB> dolio: I prefer the pulp in orange juice to that from cosmopolitans
19:50:16 <chrisdone> gnuvince_: yeah, I don't use AltGr. that's for maths and funky question marks Â¿â€½ØŸ?
19:50:26 <SamB> the color ink really doesn't help the flavour
19:50:29 <gnuvince_> ok
19:50:30 <cknapp> (and too many spelling errors)
19:50:48 <dolio> Cranberry juice with pulp?
19:50:51 <hydrapheetz> Now that's funky
19:51:12 <SamB> dolio: oh, I thought you meant the magazine
19:51:16 <mpeter> i hate when there are voice actors and you KNOW the voice
19:51:20 <mpeter> but you can't for the life of you
19:51:22 <gnuvince_> chrisdone: anyway, I'm trying to learn to use both ctrl keys.  However, I keep using vim for things like Django development, because the Django Template Language + HTML + CSS + JavaScript is just better
19:51:24 <mpeter> figure out who the actor is
19:51:33 <SamB> mpeter: your little brother?
19:51:35 <chrisdone> gnuvince_: but yeah, 90% of the time I'm using two hands for two keys so I've never had pains with emacs since using that style
19:51:40 <mpeter> ??
19:51:50 <SamB> your mom?
19:51:55 <mpeter> no
19:51:55 <chrisdone> gnuvince_: what's vim like for haskell?
19:52:12 <mpeter> vim is fully workable for haskell
19:52:16 <gnuvince_> chrisdone: not terrible, I prefer Emacs for Haskell and Clojure programming.
19:52:27 <mpeter> use jedit
19:52:33 <chrisdone> yeah, I was really impressed with the SLIME mode for clojure
19:52:43 <mpeter> as much overhead as possible in your text editor
19:52:50 <gnuvince_> I was impressed at how quickly that became available.
19:52:55 <chrisdone> yeah, exactly
19:53:02 <chrisdone> I mean, look at Scheme
19:53:06 <gnuvince_> Exactly.
19:53:16 <gnuvince_> They only have support for Scheme48 or something
19:53:21 <chrisdone> right
19:53:28 <SamB> is that from 1948?
19:53:30 <gnuvince_> No Chicken, no Bigloo, no Gambit, etc.
19:53:36 <gnuvince_> SamB: 2048
19:53:40 <SamB> oh
19:53:47 <SamB> is that from the 64-bit era ?
19:54:13 <gnuvince_> No, it's the work of John Titor; he implemented it in APL on an IBM computer
19:54:13 <gwern> ok, let's give linking gitit another shot. with firefox and rtorrent closed, I should have more memory available
19:54:14 <gnuvince_> ;-)
19:54:23 * gwern groans. titor? that's so old
19:54:45 <chrisdone> jinjing!!
19:54:50 <chrisdone> I didn't know he was in here, damn
19:54:50 <SamB> gnuvince_: in 2048 ?
19:55:13 <erikc> gwern: are you on windows?
19:55:32 <chrisdone> he wrote the haskell blog sofware that I'm using. ^_^
19:56:01 <mpeter> that's nice
19:56:04 <mpeter> now can he write it
19:56:05 <mpeter> while undead??
19:56:12 <chrisdone> what?
19:56:14 * mpeter starts chanting
19:56:28 <chrisdone> are you suffering from something, or drunk?
19:56:49 <mpeter> > map chr ffs
19:56:50 <lambdabot>   "efcfo!dvboubt!wfdft!mb!ib{bo\DELb!ef!mpt!qftdbept!ef!mb!mv{!efm!tpm!mpt!qp...
19:57:10 <mpeter> > map (pred . chr) ffs
19:57:12 <lambdabot>   "deben cuantas veces la hazan~a de los pescados de la luz del sol los pobre...
19:57:19 <pumpkin> lol
19:57:23 <hydrapheetz> Wha?
19:58:56 <SamB> where did ffs come from ?
19:59:21 <blackh> SamB: Look out! It's behind you!
19:59:28 <MyCatVerbs> SamB: BSD-lineage Unixes, I think. =)
19:59:39 <Cale> http://bulbapedia.bulbagarden.net/wiki/Catch_rate -- hahaha
19:59:49 <SamB> the above used variable!
19:59:51 <hydrapheetz> > (+) 1 3
19:59:53 <lambdabot>   4
19:59:56 <hydrapheetz> Neat.
19:59:58 <mpeter> > chrisdone
19:59:59 <lambdabot>   "chris done chris done chris done chris done!!!!"
20:00:00 <Gracenotes> Cale: any Pokemon player worth his salt would have memorized those!
20:00:01 <teko> > (+1) 3
20:00:03 <lambdabot>   4
20:00:12 <Gracenotes> but, yes, damn Lugia.
20:00:17 <Gracenotes> :/
20:00:55 <Riastradh> gnuvince_, chrisdone: Your remarks earlier about SLIME for Scheme are somewhat misleading.  The main SLIME developers have little interest in Scheme; the Clojure back end, I presume, was the work of a Clojure developer who had an interest in SLIME, similar to SLIME48 for Scheme48, which is unaffiliated with (and currently out of date with respect to) SLIME.  There are, however, other SLIME back ends for other Schemes.
20:01:19 <hydrapheetz> > (*) 3 5 3 (+) 4
20:01:20 <lambdabot>       No instance for (Num (t -> (a -> a -> a) -> t1 -> a1))
20:01:20 <lambdabot>        arising f...
20:01:20 <Gracenotes> > map (succ . ord) "Sekrit sequence"
20:01:21 <lambdabot>   [84,102,108,115,106,117,33,116,102,114,118,102,111,100,102]
20:01:30 <hydrapheetz> Oh.
20:01:40 <hydrapheetz> I still consider myself a newbie.
20:02:30 <Cale> > (+) ((*) 3 5) 4
20:02:31 <lambdabot>   19
20:02:41 <gwern> erikc: no, ubuntu
20:02:47 <hydrapheetz> Hum
20:02:53 <gwern> man, it succeeded! after using 80% of ram
20:02:54 <mwotton> is there still anyone working on shim?
20:02:57 <gwern> good giref
20:03:05 <mwotton> (sort of slime equivalent for haskell)
20:03:09 <gwern> mwotton: a fork of shim is in yi
20:03:15 <erikc> strange, i dont recall having any linking problems on ubuntu on my 2 gig ram laptop, dont remember any crazy swapping
20:03:38 <gwern> erikc: possibly you didn't have split-objs?
20:03:42 <SamB> Gracenotes: but why do you say damn lugia ?
20:03:45 <mwotton> gwern: oh, that's pretty cool. is it actively used/useful? i've been tempted by yi before..
20:03:49 <erikc> i just did a cabal install
20:03:54 <erikc> so whatever the default is
20:04:00 <gwern> my configure always sets --enable-split-objs
20:04:04 <erikc> ah
20:04:22 <Gracenotes> SamB: it was in the most difficult catch rate class
20:04:22 <SamB> gwern: well, that's pretty stupid if I say so myself
20:04:23 <gwern> mwotton: yes, I find it useful. I have it's annotType bound to a key, for example
20:04:28 <Gracenotes> I had a fair amount of trouble with it
20:04:32 <gwern> SamB: why?
20:04:46 <SamB> because you know that always makes linking take crazy RAM
20:05:27 <mwotton> gwern: good enough for me. i love having stuff in hackage, it's so much easier than it used to be...
20:05:27 <gwern> sure, but does it not gain some performance?
20:05:30 <SamB> Gracenotes: along with tens of others
20:05:32 <teko> As a poke at Emacs’ creeping featurism, vi advocates will describe Emacs as “a great operating system, lacking only a decent editor”.
20:05:49 <SamB> teko: hey, buster, that's featuritis !
20:05:51 <Gracenotes> yes, but I didn't spend a half an hour on those
20:05:54 <Gracenotes> for some odd reason
20:05:56 <gwern> teko: the alternative is trying to do sophisticated things in a cruddy extension language
20:06:18 <Riastradh> (...which elisp is not, gwern?)
20:06:22 <SamB> gwern: wait, but emacs already has that!
20:06:53 <teko> gwern its interesting that u use emacs coz GNU EMACS stands for Generally Not Used, Except by Middle-Aged Computer Scientists
20:07:01 <Megzlna> Is there a way to get associative arrays in Haskell to be an easy to use as lists, having a data constructor similar to [] ?
20:07:04 * wli is unaware of any device drivers emacs might have.
20:07:12 <gwern> Riastradh: compared to vimscript, I suspect elisp is a shining jewel of PLT
20:07:30 <Riastradh> `Shining jewel of PLT'?
20:07:36 <SamB> teko: no, it stands for Eight-hundred Megabytes And Constantly Swapping
20:07:49 <mwotton> Megzlna: [(k,v),(k2,v2)]
20:07:58 <Megzlna> that's not a hash
20:08:03 <mwotton> just an association list - you can turn it into a Map if you want it.
20:08:06 <Megzlna> that's a linked list
20:08:07 <gwern> wow, I'm impressed by gitit
20:08:07 <wli> Originally it was 8, but anyhow.
20:08:10 <Megzlna> with O(n)
20:08:14 <mwotton> sure. but you can apply fromList to it
20:08:23 <gwern> feels clean, performant, and it's done by one guy and is hugely alpha
20:08:29 <Megzlna> cant use fromList all the time
20:08:31 <SamB> wli: yes, I figured that wasn't impressive enough
20:08:35 <mwotton> Megzlna: why not?
20:08:38 <SamB> nor was 18, nor 80
20:08:41 <gwern> I think gitit might become an excellent example of Good Haskell Stuff
20:08:48 <mwotton> if it's a small literal hash, it's not gonna take long
20:08:54 <mwotton> if it's a big one, why are you writing it out literally?
20:09:01 <MyCatVerbs> Megzlna: no, that wouldn't be much of an associative array. The whole point of things like assoc arrays is that they are deliberately opaque. Since you can't see into them, they can be implemented in complicated and efficient ways without you having to worry about them. So you could pretty much not ever under any circumstances ever want to pattern match against an associative array.
20:09:04 <Megzlna> can you imagine using fromText every time you wrote a list in Haskell?
20:09:11 <Megzlna> That would be a nightmare
20:09:15 * gwern feels a warm shivery feeling as I nvagitate and edit in gitit
20:09:33 <Megzlna> sort (fromLiteral [1,2,3,555,3,1,2,3,4])
20:09:38 <gwern> and this Export feature! wow!
20:09:39 <lindzeyn> gwern thats pathetic
20:09:46 <wli> Open-addressed hash tables are drastically under-utilized data structures.
20:09:46 <MyCatVerbs> Megzlna: closer to what you want would be something like Data.Map, which uses balanced search trees.
20:09:56 <lindzeyn> who gets a hardon from an editor
20:10:05 <Megzlna> MyCatVerbs: Yes, but I want a data constructor like list
20:10:05 <gwern> lindzeyn: no, it's a wiki
20:10:09 <Megzlna> I want:
20:10:14 <lindzeyn> either way
20:10:18 <gwern> export a page as latex, export as mediawiki, oh man
20:10:41 <Megzlna> [{ ("foo",2), ("bar",3) }] or such
20:10:48 <sereven> hey lindzeyn, sereven from the pizza joint, here.. get back to work
20:10:50 <MyCatVerbs> Megzlna: you can't pattern match against them without tying them down to a specific layout.
20:10:54 <wli> I want to figure out some good data structures for representing sparse matrices.
20:11:15 <erikc> megzlna: you can write a quasiquoter for that syntax, and have the parser for the quasiquoter map it to your preferred data structure
20:11:26 <MyCatVerbs> Megzlna: oh, just write that as Data.Map.fromList [("foo",2),("bar",3)].
20:11:28 <Cale> MyCatVerbs: are you sure? You can use view patterns to extract a key.
20:11:30 <Megzlna> erikc: That's slow
20:11:35 <erikc> megzlna: slow?
20:11:37 <Cale> Megzlna: no it isn't.
20:11:39 <erikc> its compile-time
20:11:46 <Cale> It's not compile time either.
20:12:10 <Cale> But it's not significantly slower than simply using a loop to insert those elements.
20:12:11 <chrisdone> it's hammer time
20:12:13 <gwern> I guess I know what I'm doing with my spare time this week - converting gitit to use darcs
20:12:17 <Megzlna> lack of native hash types seems to be a big weakness of haskell
20:12:18 <wli> By "good" I mean O(nonZeroA+nonZeroB) matrix addition etc.
20:12:27 <Cale> Megzlna: Data.Map is great.
20:12:34 <erikc> Cale: sorry, got our threads crossed i think, quasiquoting is indeed compile time right?
20:12:39 <lindzeyn> sereven: haha, you're absolutely right
20:12:42 <Cale> erikc: Oh, yes.
20:12:45 <Megzlna> Cale: How could the best syntax look for a Hash constructor?
20:13:05 <MyCatVerbs> Cale: I don't think that'd actually save you any typing though. Usually your action on Data.Map is case lookup value map of { Nothing -> something; Just x -> somethingElse; }
20:13:09 <pumpkin> Megzlna: I'd avoid calling it a hash unless it's a real hashfunction :P
20:13:16 <wli> Or maybe O((nonZeroA+nonZeroB)*lg(nonZeroA)*lg(nonZeroB)) or some such.
20:13:16 <pumpkin> hashtable / function
20:13:19 <erikc> [$h| { k1, v1 }, { k2, v2 }|] <--- quasiquoting you could do
20:13:31 <Cale> Megzlna: Hashtables are honestly overrated.
20:13:32 <Megzlna> If you have to do runtime parsing then you're really losing, paying at runtime to get the syntax you want
20:13:38 <Megzlna> Never pay at runtime for syntax
20:13:50 <Cale> Megzlna: parsing?
20:13:54 <orbitz> parsing what?
20:14:08 <ozy`> Megzlna: "parsing?" sorry?
20:14:09 <Cale> Megzlna: It's not parsing the list at runtime. It's simply iterating over it and building a Map with those elements.
20:14:15 <pumpkin> people tend to use the word "hash" meaning associative array, and you get those in haskell (if you can accept Ord)
20:14:20 <Riastradh> Megzlna, have you identified that the bottleneck of a serious program you have written is isolated to the performance of the construction of a small, literal hash table?
20:14:48 <Megzlna> lol the old "have you a identified a bottleneck" line
20:14:57 <erikc> pumpkin: and if you dont accept Ord, 'lookup' on lists is probably the best you can do anyway :)
20:14:57 <Cale> Megzlna: It's a good serious question.
20:14:58 <pumpkin> there's also
20:14:58 <pumpkin> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-HashTable.html
20:15:02 <MyCatVerbs> Cale: so you'd just end up writing something like, case map of (view value -> Just x). Dunno if that's much of an improvement, IMO.
20:15:11 <pumpkin> whoops, wrong HashTable
20:15:29 <Cale> Megzlna: Until you can demonstrate that it's a performance issue for at least one real program, it's not reasonable to consider it a problem.
20:15:33 <Megzlna> It's not a good question if you're only paying any penalty at all because of a lack of language being able to do the syntax at compile time
20:15:48 <Riastradh> Gee, I guess C must be slow because it doesn't have a literal notation for hash tables.
20:15:57 <erikc> megzlna: make a quasiquoter to support [$h| { k1, v1 }, { k2, v2 }|]
20:15:59 <Riastradh> But Ruby's gotta blaze!
20:16:00 <Axman6> shame on C!
20:16:01 <pumpkin> erikc: yeah, unless you have some sort of "Hashable" notion which you can use on it :)
20:16:04 <erikc> and then put it on hackage so i can use it :)
20:16:11 * Riastradh coughs.
20:16:20 <pumpkin> erikc: Storable could work
20:16:33 <erikc> e.g. i made a quasiquoter for string interpolation: "foo #{bar} baz" -> "foo " ++ bar ++ " baz"
20:16:36 <Axman6> :t foldl1' xor
20:16:37 <lambdabot> forall a. (Bits a) => [a] -> a
20:16:49 <Axman6> :t foldl1' xor "Hello world"
20:16:50 <lambdabot>     No instance for (Bits Char)
20:16:50 <lambdabot>       arising from a use of `xor' at <interactive>:1:8-10
20:16:50 <lambdabot>     Possible fix: add an instance declaration for (Bits Char)
20:17:00 <Axman6> :t foldl1' xor [1..10]
20:17:01 <lambdabot> forall a. (Enum a, Bits a) => a
20:17:05 <ozy`> Megzlna: you know, clojure has a syntax for map literals
20:17:08 <Axman6> >foldl1' xor [1..10]
20:17:12 <Axman6> > foldl1' xor [1..10]
20:17:13 <lambdabot>   Add a type signature
20:17:13 <Axman6> -_-
20:17:23 <Axman6> > foldl1' xor [1..10] :: Word8
20:17:25 <lambdabot>   11
20:17:26 <Cale> One thing which I don't really understand is why people commonly ignore the fact that under the same assumptions that hashtable lookup is O(1), computing the hash function must be O(log n).
20:17:40 <Axman6> > foldl1' xor [1..12345] :: Word32
20:17:41 <lambdabot>   1
20:17:48 <Axman6> > foldl1' xor [1..12344] :: Word32
20:17:50 <lambdabot>   12344
20:17:53 <pumpkin> Cale: ?
20:17:57 <rgr> Is there some sort of optimizer/analyzer which can tell me which imports are not used in a hs file?
20:18:00 <mpeter> > chrisdone
20:18:01 <lambdabot>   "chris done chris done chris done chris done!!!!"
20:18:10 <pumpkin> rgr: just enable warnings
20:18:17 <erikc> Cale: i think cause hashing/hashtables are often taught with machine integers as the key and modulus as the hash
20:18:32 <mpeter> > evaluation
20:18:34 <lambdabot>   "No, you tell me!"
20:18:39 <wli> That's basically it.
20:18:43 <Cale> pumpkin: I often see people complain that binary balanced trees don't have O(1) lookup.
20:18:51 <rgr> pumpkin: so what would I do to remove bloat from my xmonad.hs? Di I need to load it from ghci?
20:19:00 <MyCatVerbs> Cale: because if you ignore *enough* inconvenient practicalities (how the Hell were you planning on getting a family of log(n)-independant hash functions anyway?) you can eventually get van Emde Boas trees down to O(log(log(n)) =)
20:19:08 <teko> > foldl' xor 1 [1..12344] :: Word32
20:19:09 <lambdabot>   12345
20:19:50 <wli> MyCatVerbs: Van Emde Boas queues have since been improved upon.
20:20:08 <Gracenotes> just what is the nature of 'x <- y'? Does it literally translate into 'y >>= \x ->'?
20:20:17 <Cale> erikc: It's still going to take at least O(log n) steps to compute your hash.
20:20:22 <sjanssen> Gracenotes: yes
20:20:32 <Megzlna> The point about finding it unacceptable to even consider the "have you identified a" is cause I expect perfection insofar as the language can go given the way it works. If you're constructing a linked list at runtime, then iterating over it, and constructing a table, that's wrong in spirit because it should not be the best that Haskell is capable of, otherwise it's a language flaw
20:20:32 <pumpkin> Cale: you mean finding an optimal hash function?
20:20:39 <sjanssen> @undo do x <- y; stuffwith y
20:20:39 <lambdabot> y >>= \ x -> stuffwith y
20:20:47 <Cale> pumpkin: Not even optimal. Just good enough to separate n values.
20:20:52 <Cale> (probabilistically)
20:20:57 <sjanssen> @undo do (Just x) <- y; stuffwith x
20:20:58 <lambdabot> y >>= \ a -> case a of { (Just x) -> stuffwith x; _ -> fail ""}
20:21:02 <Gracenotes> hm.
20:21:15 <pumpkin> Cale: ah, you could just throw a cryptographic hash function at it and cross your fingers ;)
20:21:21 <Riastradh> Megzlna, what would prevent a Haskell implementation from making the data structure at compile-time?
20:21:22 <pumpkin> Cale: and then take much longer O(size of key)
20:21:36 <wli> Cale: The more sophisticated arguments in favor of hash tables have to do with locality of reference, which can be smacked down with B/B+/etc. trees from the tree side of things.
20:21:38 <Cale> pumpkin: Any function which takes on n distinct output values must be observing at least log n/log 2 bits of its input.
20:21:46 <Cale> wli: right.
20:21:57 <pumpkin> Cale: but its input is the size of the key, not the size of the datastructure
20:22:01 <Megzlna> Why can't the quasiquoting be done at compile time?
20:22:07 <ozy`> Gracenotes: it's for making stuff like "getLine >>= putStrLn" more readable; i.e. it names the variable that's being passed between functions
20:22:08 <Megzlna> without an intermediary list
20:22:14 <pumpkin> whereas on a tree-based map, your big O parameter is the number of elements in the structure
20:22:31 <Cale> Megzlna: quasiquoting is done at compile time
20:22:32 <orbitz> by what metric is having hashmap constructoion at compiletime perfection?
20:22:41 <pumpkin> Cale: unless you're talking about actually determining a good hash function
20:22:56 <wli> Cale: Mostly I like hashing by open addressing for fixed-size caches.
20:22:57 <pumpkin> orbitz: you cane make a perfect static hash at compile time :P
20:23:02 <Megzlna> orbitz: By the metric of, there's nothing in the overall paradigm of Haskell that should make the literal required. It's not a fundamental "how it works" kinda thing
20:23:03 <Cale> pumpkin: By "good", I just mean that it's good enough to separate n items into different buckets
20:23:12 <Cale> pumpkin: So that lookup is O(1)
20:23:16 <Megzlna> s/the literal/the intermediary list/
20:23:20 <MyCatVerbs> wli: who what seriously how?
20:23:22 <Gracenotes> ozy`: hm, I think I
20:23:24 <Gracenotes> er
20:23:31 <Gracenotes> I'll check out Either before going onto IO
20:23:31 <Cale> pumpkin: Under that assumption, the hash function must be taking at least O(log n) time.
20:23:32 <wli> Cale: A good example of this is kernel/profile.c in Linux.
20:23:39 <orbitz> Megzlna: i don't see why it is important enough.  the runtime cost is negligable and trivial to implement
20:23:40 <MyCatVerbs> wli: to what bounds? oO
20:23:54 <Riastradh> Megzlna, suppose, hypothetically, that you could write, say, `#- fromList [...] -#', and have it evaluated at compile-time.  Would that make you happier?
20:24:14 <wli> MyCatVerbs: Check out kernel/profile.c in the Linux kernel. It's a good example of caching in such a manner.
20:24:28 <ozy`> Cale: hmm, then again, a hash table can cache recent hash codes, making it faster at the cost of memory
20:24:38 <mmorrow> ByteString.agda http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=584#a584
20:24:53 <Megzlna> If I know it's making an intermediary list then I won't use the hash as a primitive
20:24:57 <MyCatVerbs> wli: what? I don't believe you for a second. =)
20:25:18 <pumpkin> Megzlna: you mean like the intermediate AST it's using when parsing? :P
20:25:19 <seafood> Anyone got a hsc2hs compiled for an Intel Mac. I don't care if it's not for ghc 6.10
20:25:37 <Megzlna> pumpkin: Compile time
20:25:39 <seafood> I don't want to have to download ghc 6.8 again just to get this utility.
20:25:41 <Cale> ozy`: hmm, I can see cases where that would be possible. Of course, you could also just cache the pointer to the result of the lookup as well.
20:25:55 <mpeter> an intel mac?
20:25:57 <MyCatVerbs> wli: somehow I cannot see in my wildest dreams the people who hack on Linux improving on the (already fine) asymptotics rather than pushing down the (rather daunting) constants.
20:25:58 <mpeter> isn't that just a PC? ;)
20:26:00 <Cale> (which you can do with a binary tree based finite map as well)
20:26:11 <erikc> out of curiosity, if you do a list literal, does that become a thunk of (:) data constructors?
20:26:13 <MyCatVerbs> mpeter: nope. It has a -much- nicer bootloader.
20:26:22 <seafood> mpeter: No, it's a Mac with an Intel chip inside of it instead of a Motorola or IBM PPC chip.
20:26:24 <erikc> or is the creation of the list forced?
20:26:39 <mpeter> ..the bootloader?
20:26:39 <Megzlna> Cale: if the quasiquoters at compile time, what did you mean about this: <Cale> It's not compile time either.
20:26:50 <mpeter> i was joking
20:26:56 <Cale> Megzlna: I wasn't talking about quasiquoting.
20:26:58 <mpeter> but uh, the bootloader is
20:26:59 <orbitz> that wasn' tin reference to quasioquoting IIRC
20:27:01 <mpeter> fully variable
20:27:04 <Megzlna> ah
20:27:05 <seafood> mpeter: Sarcasm doesn't travel well in text does it :)
20:27:10 <Cale> Megzlna: I was talking about fromList [...]
20:27:13 <Megzlna> ah
20:27:17 <Megzlna> Well that's not so bad then
20:27:23 <Cale> Megzlna: But you really should not be concerned with the cost of fromList [...]
20:27:28 <Megzlna> But I wish you could make quasiquote stuff with less syntax
20:27:33 <mmorrow> it works! http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=584#a585
20:27:35 <MyCatVerbs> mpeter: the bootstrap loader is EFI, rather than a PC BIOS.
20:27:38 <mpeter> the game "rock star" is the most depressing thing i can think of
20:27:50 <mpeter> oh, i see
20:27:52 <erikc> mpeter: you dont like simon says with fischer price toys? :)
20:27:53 <Cale> When it's just a list literal, that's probably going to be lifted to the top level as a CAF.
20:28:01 <orbitz> CAF?
20:28:05 <mpeter> i thought you were talking about that little
20:28:08 <Cale> which means that it'll be computed just once for the whole length of the program
20:28:10 <mpeter> white screen that you could boot into
20:28:16 <mpeter> you know what i'm talking about?
20:28:17 <Cale> orbitz: constant applicative form
20:28:20 <MyCatVerbs> mpeter: are you kidding? Pretending to be a musician for fun is more depressing than the fact that at any one time, multiple genocides are taking place around the world? o_O
20:28:33 <MyCatVerbs> mpeter: no. I was talking about the firmware that loads the OS.
20:28:35 <Cale> Megzlna: So it's a negligible startup cost.
20:28:36 <mpeter> mycatverbs: they're related, you know
20:28:52 <seafood> orbitz: CAF = http://www.haskell.org/haskellwiki/Constant_applicative_form
20:28:59 <orbitz> seafood: thanks
20:29:14 <MyCatVerbs> mpeter: ...multiplayer Guitar Hero causes genocide in faraway countries? Seriously, that's epilleptic trees territory.
20:29:17 <seafood> No got a hsc2hs compiled for an Intel Mac?
20:29:18 <seafood> Anyone?
20:29:25 <mpeter> mycatverbs: you want to see me do it?
20:29:32 <mpeter> they're caused by the same thing
20:29:41 <Megzlna> I always consider performance, cause i'm always at 95% cpu usage and over the years had to cut CPU down everywhere I can
20:29:58 <MyCatVerbs> mpeter: sure, if you can do it within 400 bytes of text. I'm guessing the answer is apathy. =)
20:30:05 <wli> http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.27.y.git;a=blob;f=kernel/profile.c;h=cd26bed4cc26535ca7398eae07fb9b800b762f2e;hb=HEAD
20:30:11 <mpeter> you're close
20:30:16 <Cale> Megzlna: That's a bad place to start cutting ;)
20:30:24 <Cale> Megzlna: You know about GHC's profiler, right?
20:30:26 <wli> MyCatVerbs: Check that URL.
20:30:32 <sjanssen> Megzlna: why not just $( TH.lift $ Data.Map.fromList asdf)?
20:30:47 <sjanssen> (assuming Map has a Lift instance, it isn't hard to add one)
20:30:49 <mpeter> the process of creative stagnation limits the ability of the individual to analyze the processes of government, or of society in general, if there's a limited amount of creative output to interpret, there's much less basis to understand _anything_
20:31:06 <mpeter> especially the psychological processes underlying war
20:31:12 <mpeter> if an understanding of those processes is universal
20:31:13 <mpeter> war is over
20:31:21 <Megzlna> a typical song: "Goddamnit, lets see how I can try to get from 95% cpu down to 75% so I have some more room."  **curse codebase(s) for not utilizing cores better**  "Damnit the last thing I want to do is have to bounce and lose the dynamic nature of the sequence"
20:31:30 <mpeter> and when i say creative stagnation
20:31:41 <mpeter> i mean you're paying to buy a fake instrument to sort of play songs that other people have written
20:31:49 <wli>   12  *  Amortized hit count accounting via per-cpu open-addressed hashtables
20:31:52 <orbitz> Megzlna: do you generally have many-thousand-element map literal sin your code?
20:32:00 <wli>  13  *      to resolve timer interrupt livelocks, William Irwin, Oracle, 2004
20:32:09 <wli> MyCatVerbs: c'est moi
20:32:12 <MyCatVerbs> wli: hang on, that's not solving the same problem as van Emde Boas trees are designed for, though.
20:32:23 <Megzlna> No, but, I would not have used another high level language besides Haskell, that will eat 20% of my CPU doing sequencing
20:32:24 <sjanssen> mpeter: I have no idea what you're talking about, meaning there is a good chance you're way off topic.  #haskell-blah, perhaps?
20:32:27 <wli> MyCatVerbs: No, not even close.
20:32:35 <mpeter> i'm already done, sjanssen
20:32:37 <MyCatVerbs> wli: yeah, I saw the name drop in the giant (welcome) explainatory comment. Nice. =)
20:32:39 <Riastradh> Megzlna, what leads you to suspect that you will save a measurable number of cycles in general by writing literal hash maps?
20:32:45 <Megzlna> I did use haskell period cause it performs pretty well.
20:32:45 <wli> MyCatVerbs: It uses hashing etc.
20:32:50 <erikc> sjanssen: what is Lift/lift? hadnt seen before and haddock is light
20:32:57 <orbitz> Megzlna: do you thik constructing a few element map at runtime uses 20% CPU for some extended period?
20:33:07 <sjanssen> erikc: transforms values to the expressions that create them
20:33:08 <Megzlna> Raistradh: because that question upfront influences a coding style
20:33:18 <Megzlna> you use what's cheap as your basic primitives
20:33:18 * orbitz boggles
20:33:44 <MyCatVerbs> wli: I think it might count as a bit... offtopic, if we were talking about van Emde Boas trees, since it never actually searches for a predecessor or successor to an integer. =)
20:33:48 <Cale> Megzlna: Constructing Data.Map values is generally very cheap.
20:33:50 <Axman6> Megzlna: it performs well when you write it in the way the compiler expects you to, which is using standard types etc. you need to stop trying to fix problems you haven't had yet
20:33:54 <orbitz> Megzlna: how long are your map literals generally?
20:33:59 <Megzlna> Well, what I mean is this:
20:34:10 <Cale> Megzlna: Unless you have upwards of a million elements, you're better off not stressing about it.
20:34:15 <Megzlna> You could make a whole codebase where you're writing Haskell like javascript, and nonstop all the time using Hashes
20:34:20 * mpeter wanders away
20:34:33 <orbitz> you only construct a literal hash once...
20:34:35 <Megzlna> If that was the case, the conversion cost would be inappropriate
20:34:51 <Cale> Megzlna: You seem to be missing the fact that lists are loops.
20:35:27 <Cale> (and please everyone stop calling these hashes, they are not hashes.)
20:35:32 <wli> MyCatVerbs: There's more to hashing than mere search structures; it's the usage patterns which make them appropriate or otherwise.
20:35:55 <MyCatVerbs> wli: I'm impressed at how short that is, especially the amount of stuff in there that's for synchronization and SMP tuning rather than the algorithm itself. =)
20:36:20 <dons> Megzlna: haskell should stomp all over your typical scripting langs. (compiled code ftw)
20:36:28 <Gracenotes> hey, what does m refer to in the second monad law m >>= return == m? The type that's the instance of the monad?
20:36:31 <thetallguy> Anyone have an svg of a lambda?
20:36:32 <dons> and be competitive with C++ when careful.
20:36:33 <orbitz> dons: ccftw!
20:36:36 <Megzlna> dons: Yeah
20:36:45 <wli> MyCatVerbs: My style is notably terse.
20:36:46 <Cale> Gracenotes: It refers to a value of type m a
20:37:02 <Cale> Gracenotes: That is, a computation typed in the given monad
20:37:04 <dons> timewise, it is no contest, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=python
20:37:09 <pumpkin> speaking of svg, is there a good library for generating it in haskell (beyond just doing the xml)
20:37:18 <Megzlna> dons: Lol python is the worst comparison
20:37:21 <dons> we're looking at an order of magnitude.
20:37:25 <Megzlna> I suppose you could pick Ruby though
20:37:27 <dons> well, its best-of-breed for scripting langs
20:37:28 <MyCatVerbs> Gracenotes: yes. forall (Monad m), forall a, (x >>= return) :: (m a) == x :: (m a).
20:37:28 <thetallguy> pumpkin: maybe cairo?
20:37:28 <Gracenotes> ah, I see. I think.
20:37:29 <Megzlna> but compare to LuaJit
20:37:46 <dons> lua's a bit better, still not close though.
20:37:55 <orbitz> Megzlna: what langauges have map literals as anything more than syntax for a runtime list iteration + add
20:37:58 <Cale> Using 'm' there is a little misleading. This is happening at the value level now. It's not the same m as the one at the type level.
20:38:02 <pumpkin> thetallguy: it looks good, but I don't like all those dependencies... it should be possible to generate it without anything but an xml dependency, and it's a real pain getting all the cairo/gtk stuff going on mac os, at least
20:38:03 <Megzlna> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=luajit&lang2=ghc
20:38:09 <Cale> x >>= return = x  would be better.
20:38:26 <Cale> x :: m a
20:38:29 <Axman6> :t (>>= return)
20:38:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
20:38:37 <MyCatVerbs> wli: really? It doesn't look particularly dense to me.
20:38:40 <dons> luajit's impressive
20:38:51 <thetallguy> pumpkin: the very reason I have a question mark there, instead of knowing for sure...
20:38:52 <Gracenotes> hopefully I'll get it better with more monad examples...
20:38:54 <Axman6> (>>= return) == id restricted to monads right?
20:39:04 <MyCatVerbs> Axman6: yep.
20:39:09 <Axman6> thweet
20:39:14 <Cale> Gracenotes: In do-notation, that would look like:  do { v <- x; return v } = x
20:39:17 <Megzlna> orbitz: D, C++0x
20:39:32 <wli> MyCatVerbs: Someone proposed just maintaining parallel profile buffers for each CPU and summing on the fly for read access but it took an hour or two that way on a 512-cpu machine, so I wrote this.
20:39:42 <orbitz> C++0x doesn't really exist yet
20:39:44 <Gracenotes> yeah. that's what (I think) I thought it meant intuitively.
20:39:50 <Megzlna> orbitz: It does!
20:39:54 <orbitz> pfft
20:39:56 <orbitz> it' snot finalized
20:40:00 <orbitz> tr1 sorta exists
20:40:08 <Cale> Megzlna: Do you usually worry about using a loop to construct a hashtable or binary tree in C++?
20:40:09 <Megzlna> C++0x was finalized
20:40:20 <Cale> Megzlna: If not, then don't worry about using a list to construct one in Haskell.
20:40:26 <Megzlna> and, I've been using the gcc C++0x for the past year
20:40:27 <MyCatVerbs> wli: an *hour*? And where did you find a 512-way machine?
20:40:29 <erikc> luajit would be great if it had powerpc support and console platform owners allowed runtime code generation
20:40:30 <sjanssen> Megzlna: and the structures are actually created at compile time?  I can think of plenty of places where this isn't possible
20:40:34 <MyCatVerbs> wli: oh right, Oracle. =)
20:40:35 <Megzlna> granted, it doesn't do every feature
20:40:52 <Megzlna> Initializers is not one of the things it doesn't do.
20:41:10 <wli> MyCatVerbs: The people with the 512x boxen came to me. I didn't have such sitting around (Oracle isn't really a supercomputing affair).
20:41:51 <thetallguy> Hmm.. How about the unicode for the lowercase lambda?
20:41:51 <Megzlna> Cale, I see what you're saying
20:41:51 <Axman6> Megzlna: wikipedia doesn't say it's been released
20:42:09 <MyCatVerbs> wli: oh. I thought they sometimes shipped supermassive boxen for running really huge database loads.
20:42:11 <orbitz> C++0x is nto finalized
20:42:12 <Megzlna> http://herbsutter.wordpress.com/2008/10/28/september-2008-iso-c-standards-meeting-the-draft-has-landed-and-a-new-convener/
20:42:16 <orbitz> it will mos tlikely be in 2010
20:42:17 <erikc> the initializer syntax extensions for c++0x are not evaluated at compile time last i checked
20:42:29 <Axman6> Megzlna: draft /= released
20:42:50 <Axman6> "The ISO/IEC JTC1/SC22/WG21 C++ Standards Committee aims to introduce the new standard in 2009 (hence the standard that is today called C++0x will become C++09) which means that the document must be ready for ratification of the member states of ISO in 2008. To be able to finish on schedule, the Committee decided to focus its efforts on the solutions introduced up until 2006 and ignore newer proposals [1]."
20:43:04 <wli> MyCatVerbs: The guys complained about profiling sucking on IRC. I emailed them code. They told me results over IRC. I emailed lkml with the code and results.
20:43:16 <Megzlna> Axman6: Doesn't really matter, there will be be bugfix if they can find it, but there won't be another feature.
20:43:26 <MyCatVerbs> wli: ... nice. =)
20:43:29 <Megzlna> GCC does a large amount of C++0x
20:43:34 <Megzlna> All the big stuff.
20:43:41 <orbitz> Axman6: translation: despite you being right, you'r estill wrong
20:43:45 <wli> MyCatVerbs: I did much more of that with cpumask_t.
20:43:47 <MyCatVerbs> Couldn't you just fix this whole issue by proving an {-# evaluateAtCompileTime nameOfSomeCAF #-} pragma?
20:43:57 <Axman6> orbitz: yes, i figured that one out -_-
20:43:57 <erikc> gcc: thats not true at all
20:44:02 <erikc> err megzlna
20:44:03 <orbitz> Axman6: haha
20:44:06 <erikc> http://gcc.gnu.org/projects/cxx0x.html
20:44:11 <sjanssen> MyCatVerbs: you don't even need that, just use TH
20:44:14 <erikc> the biggest features are all missing, or in experimental branches
20:44:24 <wli> MyCatVerbs: (That's what enabled Linux to run on arbitrary numbers of CPU instead of being limited to the bitwidth of an unsigned long in C.)
20:44:28 <Axman6> never met anyone so stubborn in here
20:44:40 <orbitz> Megzlna: do C++ hash table literals actually construc ta hashtable AT compile time, or just tarnslate it ot constructionc ode?
20:44:53 <Megzlna> A lot of the 'No' stuff was not the exciting features
20:45:01 <Megzlna> for me, at least
20:45:08 <MyCatVerbs> wli: sweet.
20:45:09 <erikc> orbitz: translates to construction code; they've added sugar to convert initializer syntax to constructor calls
20:45:11 <sjanssen> Megzlna: in what way is C++'s initializer_list<> different from Haskell's []?
20:45:19 <orbitz> erikc: that's wha ti figured
20:45:19 <Megzlna> sjanssen: Inlines
20:45:21 <Axman6> orbitz: need to work on your <space> timing? :P
20:45:27 <sjanssen> Megzlna: inline what?
20:45:32 <orbitz> Axman6: need to install forkIO in brainz
20:45:38 <Megzlna> sjanssen: It's unrolled
20:45:54 <Axman6> Megzlna: do you know haskell ones aren't?
20:45:58 <Megzlna> it can convert for example to a single memmove
20:46:13 <Philippa_> so can haskell ones. Pure, remember?
20:46:14 <orbitz> you can't memove a list into a hashtable...
20:46:30 <sjanssen> Megzlna: okay, so you're referring to when the called constructor is inlined?  Fair enough.  Haskell can, in principle, do the same thing
20:46:31 <Megzlna> orbitz: For vectors
20:46:38 <mgsloan> any critique of my split code under "break on nothing" - http://haskell.org/haskellwiki/Data.List.Split ?
20:46:44 <wli> MyCatVerbs: I've also done some work on the pid allocator http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.27.y.git;a=blob;f=kernel/pid.c;h=064e76afa507a252f6f4de8aec046f03c6cc62a7;hb=HEAD
20:46:55 <sjanssen> Megzlna: and unless the exact inlines and optimizations are guaranteed in the C++ specification, I don't see how Haskell falls short
20:47:02 <Axman6> @faq can haskell do what Megzlna wants? all of it? really?
20:47:03 <lambdabot> The answer is: Yes! Haskell can do that.
20:47:09 <pumpkin> lol
20:47:16 <Axman6> there we go, all your problems settled
20:47:22 <pumpkin> Axman6: I think that's the one thing lambdabot should answer no to ;)
20:47:34 <MyCatVerbs> wli: now you're just showing off. =)
20:47:57 <MyCatVerbs> pumpkin: nah, just abuse Template Haskell until the cows come home.
20:48:03 <Philippa_> @faq Can haskell give me a pony?
20:48:03 <lambdabot> The answer is: Yes! Haskell can do that.
20:48:05 <orbitz> Megzlna: do C++ hash table literals actually construc ta hashtable AT compile time, or just tarnslate it ot constructionc ode?
20:48:06 <sjanssen> Megzlna: and if you're *still* worried that there might be just a little bit of wasted computation, use TH -- the Lift class makes it really easy
20:48:06 <Megzlna> Anyways, here's what I say about C++0x
20:48:11 <wli> MyCatVerbs: No, it's another hashtable affair.
20:48:13 <Megzlna> i think I saw ths image here
20:48:16 <wchogg> @faq can Haskell make my family truly love me?
20:48:16 <lambdabot> The answer is: Yes! Haskell can do that.
20:48:19 <wchogg> Yay!
20:48:25 <gwern> gitit is 1340 LOC. dang
20:48:29 <Gracenotes> awwww.
20:48:32 <Megzlna> <-- (Left side of the picture: the past 5 years of talk about C++0x)  http://cache.consumerist.com/assets/images/consumerist/2008/08/bonzaiwaterparks_01.jpg  (Right side of the picture: the published final C++0x draft for international review) -->
20:48:46 <gwern> obviously we need to do some factoring of xmonad into libraries; it's embarassing to have a wiki smaller than a wm
20:49:05 <orbitz> meh
20:49:06 <Axman6> > unsafePerformIO (holdGunTo (wchogg'sFamily head))
20:49:07 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `holdGunTo'Not in scope: `wcho...
20:49:10 * orbitz is not particualrly impressed with C++0x
20:49:10 <sjanssen> gwern: why?  I don't see why a wiki should be more complex than a window manager
20:49:22 <Philippa_> sjanssen: quite the opposite
20:49:24 <wli> MyCatVerbs: Here the use of hashtables has to do with locking algorithms vs. other concerns. A B+ tree would be much denser wrt. cachelines.
20:49:37 <Philippa_> the basics for a wiki are tiny
20:49:42 <Axman6> i don't find any C languages impressive
20:49:55 <gwern> sjanssen: intuitively, all the web stuff and document formatting and interactivity and IO should add up to more work than moving some windows around
20:50:17 <sjanssen> gwern: web applications only pretend to be interactive
20:50:18 <Philippa_> gwern: if you add in all the libraries, then yes
20:50:32 <sjanssen> window managers actually are
20:50:35 <Megzlna> orbitz: They can make a hash at compile time, yes
20:50:48 <orbitz> Megzlna: can you show me where that is specified, and evidence for it?
20:50:52 <sereven> I'd wager if there's ever a gitit-contrib it'll grow rapidly
20:50:55 <orbitz> Megzlna: i am genuinly curious
20:51:16 <Philippa_> orbitz: bear in mind that can /= must
20:51:27 <orbitz> Philippa_: righ right
20:52:02 <pumpkin> if you make a hash at compile time, it can be perfect
20:52:16 <Megzlna> orbitz: I've seen this idea floating a bit and GCC guys talking about implementing it for map, discussion on #C++ about it and such, but I'm not sure where to show a real implementation
20:52:31 <orbitz> Megzlna: so you hav eno actual evidence for this?
20:52:49 <Megzlna> Not without searching a bit, but they'll do it in the future
20:52:53 <erikc> they wont
20:52:58 <orbitz> i doub tthey will
20:53:01 <orbitz> there is little value in it
20:53:12 <Cale> Technically, the Haskell compiler *could* evaluate the Data.Map.fromList at compile time when applied to a constant. It's just not usually a concern.
20:53:13 <erikc> im saying that as a former c++ compiler optimizer developer, so i understand the issues
20:53:18 <Megzlna> No, they will, because of CONSTEXPR
20:53:26 <Axman6> you know what isn't actually as shit as i thought it was going to be? Java
20:53:38 <orbitz> Axman6: i *hate* writing ajva thouhg
20:53:40 <Megzlna> The point of constexpr is to be able to call a regular function at compile time.
20:53:43 <Axman6> erikc: which compiler(s)?
20:53:50 <orbitz> Axman6: the lack of something liek 'type' drive sme nuts
20:53:51 <erikc> ibm xlc/xlf
20:53:58 <Megzlna> The idea is to use stuff like init list with constexpr
20:54:00 <Axman6> orbitz: i don't mind it too much, but it isn't nice
20:54:14 <Megzlna> And you dont even need compiler support
20:54:20 <orbitz> Axman6: Map<....., ....> x = new HashMap<..., ...>() just drive me up a wall
20:54:20 <Megzlna> It can be done purely in library
20:54:33 <Axman6> heh, yeah
20:54:36 <MyCatVerbs> Cale: only with a pragma telling it that it's worth it, though? It wouldn't be so good for someone to define an intinite lazy CAF and have the compiler try to evaluate it in advance.
20:54:45 <Cale> MyCatVerbs: right.
20:54:49 <Axman6> well writing asteroids in java wasn;t too bad, and we got 97.5% for it :)
20:54:51 <orbitz> has anyone implemetned CONSTEXPR?
20:55:04 <Cale> MyCatVerbs: You'd probably want that. Or some limitation on how much evaluation was done.
20:55:09 <MyCatVerbs> orbitz: wrong question. =)
20:55:16 <Megzlna> Generalized constant expressions  	N2235  	No
20:55:22 <Axman6> erikc: they any good?
20:55:23 <Megzlna> It's one of the good things missing
20:55:26 <Megzlna> from 0x
20:55:33 <Megzlna> in GCC.
20:56:08 <MyCatVerbs> orbitz: have the compilers shipped by Microsoft and IBM and friends implemented CONSTEXPR? 'Cuz otherwise you'll never, ever be able to use it for writing PC games, nor on consoles.
20:56:10 <erikc> axman6: much better than gcc on powerpc
20:56:12 <Megzlna> TR1 also generalizes the hash layer, so it would be trivial to construct hashes with constexpr.
20:56:44 <Megzlna> tr1::hash
20:56:45 <Axman6> erikc: yeah i'd expect that. Did apple's changes to GCC improve things on PPC?
20:56:58 <Axman6> s/changes to//
20:57:09 <MyCatVerbs> orbitz: bet you the MSVC lag keeps things back for at least another five years.
20:57:27 <Megzlna> Now, how do you call regular Haskell functions at compile time!?
20:57:30 <Megzlna> they're pure!
20:57:34 <Megzlna> So it should be no problem.
20:57:36 <mmorrow> aPrime = $(lift (primes !! 100000000 :: Integer))
20:57:45 <erikc> a bit, but its mainly stuff like profile driven feedback, link time interprocedural analysis, and a more powerful modulo scheduler
20:57:46 <mmorrow> :: Integer
20:57:48 <orbitz> Megzlna: i'm somewhat skeptical constexpr does what you think it does
20:57:53 <pumpkin> :t lift
20:57:54 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
20:57:59 <erikc> where xlc shines
20:58:00 <mmorrow> , src 'lift
20:58:01 <pumpkin> ooh
20:58:02 <sjanssen> pumpkin: different lift
20:58:10 <lunabot>  Class op from Lift: lift :: forall t . Lift t => t -> Q Exp
20:58:23 <pumpkin> sjanssen: I'd still only ever come across liftM/A and didn't know about lift
20:58:24 <mmorrow> Language.Haskell.TH.Syntax.lift
20:58:36 <sjanssen> mmorrow: only bad thing about Lift is that it doesn't have enough instances, and isn't derivable
20:58:38 <erikc> auto-simdization was aonther big one for vmx/spu
20:58:38 <mmorrow> erikc: hacking src-meta currently
20:58:49 <Megzlna> orbitz: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf
20:58:58 <Megzlna> 4.3: CONSTANT EXPRESSION CONSTRUCTORS
20:59:01 <Axman6> urgh, looking through the C++0x page, and damn C++ is ugly
20:59:18 <mmorrow> sjanssen: heh, i'm gonna upload some code to make that trivial when i update haskell-src-meta in a few hours
20:59:55 <sjanssen> mmorrow: interesting
20:59:58 <gwern> -meta?
21:00:05 <Gracenotes> @undo do let a = b; c <- f a; f c
21:00:06 <lambdabot>  Parse error at "<-" (column 17)
21:00:09 <gwern> how many haskell-src-* do we have now I wonder
21:00:10 <Gracenotes> hrm.
21:00:20 <thetallguy> dons: I uploaded another logo candidate.
21:00:29 <erikc> axman6: ibm funds gcc development too though, so there's some intra-company competition going on, they've closed the gap a bit in the gcc 4 line
21:00:52 <Gracenotes> @undo do { let a = b, c <- a, f c }
21:00:53 <lambdabot>  Parse error at "," (column 15)
21:01:29 <Gracenotes> @undo do let a = b; f a
21:01:30 <lambdabot>  Parse error at end of input
21:01:33 <Axman6> erikc: good :) kind of a pity Apple stopped using PPC, i liked them (we still use a G3 and G5 everyday in our house. i ony have an intel machine because i needed a lappy for uni)
21:01:34 <Gracenotes> oh, never mind
21:01:49 <mmorrow> sjanssen: it takes Igloo's code (th-lift) and prettifies the output, and everything's made easier by instances of Lift for Exp,Dec,Pat,Type,etc being included in the pkg
21:02:13 <wli> erikc: I think it's more that IBM has their fingers in a lot of pies (or perhaps their tentacles are everywhere).
21:02:20 <erikc> haha, indeed
21:02:30 <mmorrow> so having instances of Lift for the AST types is kinda like the "bootstrap" step
21:02:54 <Axman6> erikc: so you're not working for them anymore?
21:03:20 <wli> e.g. IBM is bigger than all of the "big 3 automakers" put together.
21:03:28 <mmorrow> sjanssen: this is how it'd work (this is essentially the same code that i'm going to merge in)  http://moonpatio.com/repos/th-utils/EXAMPLES
21:03:36 <Gracenotes> messing around with @undo doesn't seem to do it, so: how do 'let' statements work in do blocks?
21:03:47 <mmorrow> well, s/the code/an example of its use in ghci/
21:04:05 <Axman6> what do IBM do these days anyway? i know they're doing a lot, just not sure exactly what
21:04:14 <wli> There aren't many numericists floating around #haskell
21:04:18 <mmorrow> ghci> putStrLn $(lift =<< deriveLiftPretty ''Info)
21:04:21 <wli> Axman6: I'm not sure. I left IBM in '03.
21:04:29 <sjanssen> Gracenotes: they translate into "let in"
21:04:39 <mmorrow> and voila, it spits out the code for instance Lift Info
21:04:54 <sjanssen> @undo do let x = y; z
21:04:54 <lambdabot>  Parse error at end of input
21:05:07 <sjanssen> @undo do {let {x = y}; z}
21:05:08 <lambdabot> let { x = y} in z
21:05:12 <Megzlna> mmorrow: hey
21:05:14 <mmorrow> (but you have to do that for all types reachable from Info/whatever manually)
21:05:14 <erikc> axman6: nope, got tired of hacking on the brittle multi-million loc optimizer written in c++
21:05:16 <Gracenotes> ah.
21:05:18 <wli> I've been having serious medical problems for the past year so I've lost track of everything on top of that anyway.
21:05:21 <mmorrow> Megzlna: hey
21:05:21 <Megzlna> mmorrow: aPrime = $(lift (primes !! 100000000 :: Integer))   -- Was this compile time?
21:05:25 <mmorrow> yes :)
21:05:29 <Axman6> erikc: fair enough
21:05:43 <Megzlna> mmorrow: neat
21:05:44 <mmorrow> it splices as whatever the  100000000th prime is
21:05:49 <Gracenotes> @undo do {let {a = b}; let {c = d}; z}
21:05:50 <lambdabot> let { a = b} in let { c = d} in z
21:06:10 <Megzlna> so, all I gotta do is make a compile time constructor for Data.Map and a Quasiquoter
21:06:18 <mmorrow> (after who-knows-how-long churning away during compilation)
21:06:22 <wli> erikc: Someone at Red Hat once suggested writing a C/C++ optimizer in Haskell.
21:06:38 <erikc> wli: now that i know haskell a lot better, that's a really good idea
21:06:50 <mmorrow> language-c++
21:06:50 <sjanssen> Megzlna: you can actually use the existing constructor, you just have to write code to turn a Map into an expression
21:07:07 <erikc> the xl optimizer is actually written in c++ and plix (an internal version of PL-1)
21:07:21 <Megzlna> mmorrow: what would the shortest possible syntax similar to  [k:v, k:v]  be with TH?
21:07:23 <Gracenotes> > let a = 1 in let b = 2 in a + b
21:07:23 <erikc> its somewhat intractable at this point
21:07:25 <lambdabot>   3
21:07:28 <Gracenotes> oh, good.
21:07:32 <Megzlna> sjanssen: cool
21:07:50 <mmorrow> , [| \k v -> [k:v,k:v] |]
21:07:52 <wli> erikc: I think it was Graydon Hoare.
21:07:53 <lunabot>  LamE [VarP k_0,VarP v_1] (ListE [InfixE (Just (VarE k_0)) (ConE :) (Just ...
21:07:54 <mmorrow> ignore the LamE
21:08:08 <Axman6> > primes
21:08:09 <mmorrow> , (\(LamE _ e)->e) `fmap` [| \k v -> [k:v,k:v] |]
21:08:10 <lambdabot>   Not in scope: `primes'
21:08:12 <lunabot>  ListE [InfixE (Just (VarE k_0)) (ConE :) (Just (VarE v_1)),InfixE (Just (...
21:08:14 <Axman6> damn, got unlet
21:08:48 <wli> erikc: Knowing him, he probably had some code, but since nothing came of it, not quite enough to show in public.
21:08:56 <mmorrow> Megzlna: what makes everything easier (when working with /expressions/) is how you can splice other expressions into holes in quoted expressions
21:09:13 <erikc> wli: a coworker and i developed a c++ template expression language for describing unification-based pattern matching transformations of code
21:09:16 <erikc> http://www.google.com/patents?id=RQCkAAAAEBAJ&dq=erik+charlebois
21:09:20 <erikc> woulda been a lot easier to implement in haskell :)
21:09:23 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) $ takeWhile (\n -> n*n <= x) primes in primes
21:09:25 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:09:27 <erikc> (the patent is total bs)
21:09:34 <Axman6> whoot, got it on the first go
21:09:38 <Megzlna> mmorrow: [| \k v -> [k:v,k:v] |]  -- not how it would look optimally, right?
21:10:03 <mmorrow> , let ntimes 0 f x = [|$f $x|]; ntimes n f x = [|f $(ntimes (n-1) f x)|] in ntimes 4 [|id|] [|42|]
21:10:04 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) $ takeWhile (\n -> n*n <= x) primes in primes !! 1000
21:10:06 <lambdabot>   7927
21:10:06 <lunabot>  luna: Couldn't match expected type `t1 -> t'
21:10:13 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) $ takeWhile (\n -> n*n <= x) primes in primes !! 10000
21:10:15 <lambdabot>   104743
21:10:19 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) $ takeWhile (\n -> n*n <= x) primes in primes !! 100000
21:10:26 <mmorrow> um
21:10:34 <lambdabot>   thread killed
21:10:36 <mmorrow> , let ntimes 0 f x = [|$f $x|]; ntimes n f x = [|$f $(ntimes (n-1) f x)|] in ntimes 4 [|id|] [|42|]
21:10:38 <lunabot>  AppE (VarE id) (AppE (VarE id) (AppE (VarE id) (AppE (VarE id) (AppE (Var...
21:10:44 <mmorrow> , ppDoc `fmap` let ntimes 0 f x = [|$f $x|]; ntimes n f x = [|$f $(ntimes (n-1) f x)|] in ntimes 4 [|id|] [|42|]
21:10:46 <lunabot>  id (id (id (id (id 42))))
21:10:50 <Gracenotes> Axman6: it's elegant, but it's still kinda slow :)
21:11:09 <Axman6> Gracenotes: what's slow about it?
21:11:35 <mmorrow> [| ...blah ... $( .. a hole [| ... i'm at level 1|] ...) .. level 1 as well ... |]
21:11:36 <wli> Axman6/Gracenotes: cf. http://hpaste.org/13040
21:11:50 <erikc> constexpr will not be usable on map/hash structures, and the reason for that is storage management
21:11:59 <Gracenotes> wli: that's the literal version of the sieve, no?
21:12:24 <wli> Gracenotes: A relatively faithful one. Try it and see how it performs.
21:12:42 <mmorrow> [| level1  $(level0 [| level1 $(level0) |] level0) level1 |]
21:13:26 <mmorrow> , \x -> [| x |]
21:13:28 <lunabot>  luna: No instance for (GHC.Show.Show (t -> Language.Haskell.TH.Lib.ExpQ))
21:13:33 * Axman6 liked his one liner
21:13:34 <Megzlna> erikc: Runtime still has to do the storage. constexpr does the hash.
21:13:35 <Gracenotes> Axman6: well, it may be unfair to call it slow, but all the linked list-ing takes its toll, I'd think
21:13:36 <mmorrow> err, forget that one
21:13:54 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) $ takeWhile (\n -> n*n <= x) primes in primes !! 1
21:13:56 <lambdabot>   3
21:13:58 <Megzlna> of course it's no contiguous array
21:14:22 <orbitz> what do you mean "does the hash"?
21:14:27 <orbitz> how do you do the hash without storage?
21:15:25 <mmorrow> <Megzlna> mmorrow: [| \k v -> [k:v,k:v] |]  -- not how it would look optimally, right?
21:15:27 <erikc> yes, you could compute the hashes of literals statically, but nothing about constexpr enables that :), a decent c++ compiler should fold away that computation since it's pure
21:15:34 <mmorrow> err, so what do you mean by "optimally"?
21:16:08 <Megzlna> mmorrow: Least possible syntax, removal of the \k v -> part
21:16:24 <Megzlna> erikc: You have stack local storage with constexpr.
21:16:41 <mmorrow> but then the `k' and `v' wouldn't be bound
21:16:59 <mmorrow> so you need the \k v -> part
21:17:06 <mmorrow> unless you're doing
21:17:20 <mmorrow> \k v -> [|  [k:v,k:v]  |]
21:17:26 <mmorrow> in which case the types of k and v
21:17:32 <mmorrow> have to be instances of Lift
21:17:44 <mmorrow> and if you do
21:17:59 <mmorrow> \x -> [| $x  |]    (=== [| $(x)  |])
21:18:02 <Megzlna> [|["foo": 1, "bar": 2]|]   heh not too bad
21:18:05 <mmorrow> then x :: ExpQ
21:18:30 <mmorrow> heh, that'll give a type error though when you try to splice it
21:18:45 <mmorrow> , [| "foo" : 1 |]
21:18:47 <lunabot>  InfixE (Just (LitE (StringL "foo"))) (ConE :) (Just (LitE (IntegerL 1)))
21:18:51 <mmorrow> , $([| "foo" : 1 |])
21:18:54 <lunabot>  luna: No instance for (GHC.Num.Num [[GHC.Types.Char]])
21:19:48 <mmorrow> so you can generate non-type correct AST fragments with [| ... |] if you like, but you can't use them
21:20:12 <Megzlna> erikc: And that's exactly what the purpose of constexpr is... for enabling that!
21:20:39 <Megzlna> mmorrow: how can you can't use if you can get the tree?
21:21:10 <mmorrow> Megzlna: because in going (AST -> typechecked code -> mach code)
21:21:17 <erikc> megzlna: i wont argue anymore :)
21:21:20 <mmorrow> you'd be stopped by ghc in the first arrow
21:21:22 <sjanssen> > let (!) = (,) in Map.fromList [ "asdf" ! 1, "foo" ! 2, "bar" ! 100 ] -- just use another operator as (,)
21:21:23 <lambdabot>   fromList [("asdf",1),("bar",100),("foo",2)]
21:21:47 <teko> which linux irc client do u guys use ?
21:21:51 <erikc> irssi
21:21:53 <mmorrow> Megzlna: all the code you generate with TH just gets dumped in with the rest of the hand-written code, then typechecked etc. as usual
21:21:59 <Axman6> i use irssi on OS X
21:22:02 <Axman6> nothing beats it
21:22:23 <pumpkin> linkinus isn't terrible
21:22:28 <pumpkin> and has a GUI
21:22:31 <pumpkin> ;)
21:22:45 <Axman6> linkinus is terrible, i'm sorry
21:23:03 <pumpkin> o.O
21:23:25 <jeffz`> teko, erc for emacs
21:23:28 <teko> and xchat ?
21:24:15 <wli> I suppose there's always unfoldr (\(p:ns) -> Just (p, filter (\n -> n `mod` p /= 0) ns)) [2..]
21:24:36 <teko> anyway i have the ubuntu package thing open and i get 2 options for emacs, emacs X11 and emacs GTK
21:24:39 <teko> which should i get ?
21:24:53 <pumpkin> > unfoldr (\(p:ns) -> Just (p, filter (\n -> n `mod` p /= 0) ns)) [2..]
21:24:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:24:57 <orbitz> when i load up ghci, with an .o in input, i get the error unknown symbol `___stginit_bytestringzm0zi9zi1zi4_DataziByteStringziLazzyziChar8_'.  does this mean i probably just don't have the corect bytestring isntalled?
21:25:18 <Megzlna> mmmorrow: Can't you "fix" the tree?
21:25:29 <mmorrow> Megzlna: sure, definitely
21:26:08 <mmorrow> [| ... |] is just a mechanism to ease constructing pieces of AST
21:26:25 <mmorrow> no typechecking is done during that part
21:26:35 <Axman6> 86028121 -- the 5,000,000th prime in 270s, that's not too slow right?
21:26:50 <Axman6> > 270/60
21:26:52 <lambdabot>   4.5
21:27:56 <mmorrow> Axman6: heh
21:30:33 <orbitz> here is the result of trying to run ghci with the bio lib, any suggestsion son how to fix the error? http://hpaste.org/13081
21:31:56 <pumpkin> , permutations [1,2,3]
21:31:58 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
21:32:01 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = not . any (\p -> n `mod` p == 0) . takeWhile (\p -> (p^2 <= n)) $ primes in primes
21:32:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:32:24 <pumpkin> why doesn't hoogle know about permutations?
21:32:30 <Cale> ^^ extremely cute primes via mutual recursion :)
21:32:59 <orbitz> Cale: you see the article on LtU about the comon seive impl not being the seive?
21:32:59 <Axman6> Cale: thank you :)
21:33:09 <Cale> orbitz: yes
21:33:15 <Cale> pumpkin: Possibly due to being based on 6.8.x
21:33:19 <pumpkin> ah
21:33:57 <Axman6> Cale: not . any (\p -> n `mod` p == 0) . takeWhile  (\p -> (p^2 <= n))
21:34:02 <Axman6> whoops
21:34:13 <Axman6> anyway, that should be able to be reduced into a fold right?
21:35:09 <Cale> hmm... yeah, a right fold
21:35:31 <orbitz> > foldr (+) 0 [1..10000000]
21:35:33 <lambdabot>   * Exception: stack overflow
21:35:50 <orbitz> > foldl (+) 0 [1..10000000]
21:36:02 <lambdabot>   mueval: Prelude.read: no parse
21:36:17 <Axman6> eh?
21:36:25 <orbitz> hrmmm
21:36:51 <mmorrow> > foldl' (+) 0 [1..10000000]
21:36:55 <lambdabot>   50000005000000
21:36:59 <orbitz> : tfoldl'
21:37:02 <orbitz> :t foldl'
21:37:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:37:08 <mmorrow> i think
21:37:10 <mmorrow> <lambdabot>   mueval: Prelude.read: no parse
21:37:12 <orbitz> @src foldl'
21:37:12 <lambdabot> foldl' f a []     = a
21:37:12 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:37:16 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = foldr (\p r -> n `mod` p /= 0 && (p^2 > n || r)) True $ primes in primes
21:37:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:37:19 <mmorrow> was refering to the error msg or something
21:37:28 <orbitz> why does normal foldl fail?
21:37:30 <Cale> I'm not sure it's actually clearer like that though.
21:37:39 <mmorrow> Cale: heh, that's a neat one
21:37:48 <Axman6> Cale: yeah, i prefer the clear code
21:37:49 <Cale> foldl always recurses until it hits the end of a list before returning anything at all
21:37:56 <Cale> @src foldl
21:37:56 <lambdabot> foldl f z []     = z
21:37:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:37:59 <mmorrow> orbitz: it's accumulator gets massive and blows the stack
21:38:00 <orbitz> > foldr (+) 0 [1..10000000]
21:38:02 <lambdabot>   * Exception: stack overflow
21:38:05 <wli> > unfoldr (\(p:ns) -> Just (p, filter (\n -> n `mod` p /= 0) ns)) [2..]
21:38:07 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:38:09 <Cale> You can see that the recursive case always just immediately calls foldl again.
21:38:11 <Axman6> ah yes, a fold might not be such a great idea
21:38:15 <orbitz> Cale: both foldl and foldr fail though, i would have trhough on eof them woudl work
21:38:25 <Cale> what?
21:38:32 <mmorrow> foldl' keeps its accum one level deep
21:38:36 <Cale> Oh, for summing that huge list?
21:38:41 <Cale> foldl' is needed yes.
21:38:42 <orbitz> yes
21:38:50 <Cale> > foldl' (+) 0 [1..1000000]
21:38:51 <lambdabot>   500000500000
21:38:58 <Cale> The reason is:
21:39:06 <Cale> foldl (+) 0 [1..1000000]
21:39:08 <orbitz> but isn't foldl doing tail calls?
21:39:11 <wli> Sum adjacent pairs in the list.
21:39:16 <Cale> -> foldl (+) (0+1) [2..1000000]
21:39:21 <Cale> -> foldl (+) ((0+1)+2) [3..1000000]
21:39:22 <mmorrow> orbitz: it's just building up a massive thunk
21:39:26 <Cale> -> foldl (+) (((0+1)+2)+3) [4..1000000]
21:39:29 <Cale> ...
21:39:42 <Cale> Those reductions are being done in a tight loop.
21:39:46 <mmorrow> (1 + 2 + 3 + 4 .... + 10000 + ..... + 1000000)
21:39:49 <Cale> However, when you get to the end, you have:
21:40:05 <orbitz> why can' it do those reductions as it iterates?
21:40:06 <Cale> (((...((0+1)+2)+...+1000000)
21:40:15 <mmorrow> orbitz: that's what foldl' does
21:40:30 <Cale> which causes a stack overflow as it looks for the outermost reducible subexpression, which is 0+1
21:40:33 <orbitz> why doens't foldl do it thouhg?
21:40:45 <mmorrow> because 1 + 1 isn't == 2 really
21:40:49 <mmorrow> but it's a thunk
21:40:51 <Cale> Lazy evaluation always proceeds by reducing the outermost reducible subexpression first.
21:40:58 <Axman6> Cale: one thing i don't like about my version is that if in the takeWhile (\n -> n^2 <= x), if it's equal, it's obviously not prime, so wastes some more computation
21:41:03 <Cale> With foldl, this is *always* foldl, until you reach the end of the list.
21:41:18 <orbitz> what if we forced it to eb strict?
21:41:19 <Cale> Axman6: hm?
21:41:27 <mmorrow> orbitz: exactly
21:41:31 <mmorrow> @src foldl'
21:41:32 <lambdabot> foldl' f a []     = a
21:41:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:41:36 <Axman6> well, if n^2 == x, then x isn't prime
21:41:47 <Cale> orbitz: This is exactly what foldl' is.
21:41:49 <orbitz> mmorrow: is that what foldl' does?
21:41:52 <orbitz> ok
21:41:56 <mmorrow> precisely
21:42:10 <orbitz> :t seq
21:42:12 <lambdabot> forall a t. a -> t -> t
21:42:13 <Gracenotes> is there a way to view the structure of a nested thunk without evaluating it? Or, at least, while evaluating it?
21:42:20 <mmorrow> you could modernize that with bang patterns
21:42:20 <Cale> orbitz: It's strict in the accumulating parameter, so it always forces the evaluation of the expression (up to determining the top-level constructor), before recursing.
21:42:39 <orbitz> @src seq
21:42:39 <lambdabot> Source not found. Just try something else.
21:42:40 <mmorrow> foldl' f !a (x:xs) = foldl' f (f a x) xs
21:42:42 <Cale> Gracenotes: no... it's a bunch of machine code once compiled.
21:42:43 <orbitz> what is seq?
21:42:53 <Cale> Gracenotes: It would be nice to have an interpreter where that was possible
21:42:56 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = null . takeWhile (\n -> n*n <= x && 0 /= rem x n) $ primes in primes
21:43:01 <Gracenotes> ah, okay.
21:43:01 <mmorrow> it forces its first arg to whnf
21:43:06 <Cale> orbitz: evaluating seq x y will evaluate x before resulting in y
21:43:12 <lambdabot>   thread killed
21:43:16 <pumpkin> some of the project euler problems have such simple solutions in haskell
21:43:18 <orbitz> hrm
21:43:26 <orbitz> pumpkin: yah they do
21:43:29 <Cale> Why rem and not mod?
21:43:45 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = null . takeWhile (\n -> n*n <= x && 0 /= mod x n) $ primes in primes
21:43:48 <Axman6> no reason
21:43:51 <Gracenotes> pumpkin: hm, do you have a good example? i.e. difficult in imperative, easy in Haskell
21:44:00 <Cale> rem is strange for negative values.
21:44:01 <lambdabot>   thread killed
21:44:03 <Gracenotes> for curiosity's sake
21:44:05 <pumpkin> Gracenotes: this one is nice http://projecteuler.net/index.php?section=problems&id=40
21:44:07 <orbitz> is seq just a tool to make something strict?
21:44:12 <Cale> orbitz: yes
21:44:22 <mmorrow> , let seq = (\ !x -> id) in foldl (\a b -> a `seq` a+b) 0 [0..1000000]
21:44:25 <lunabot>  Stack space overflow: current size 8388608 bytes.
21:44:25 <lunabot>  Use `+RTS -Ksize' to increase it.
21:44:28 <mmorrow> heh
21:44:31 <Gracenotes> hm.
21:44:32 <Cale> orbitz: It's similar to using case to pattern match away the first constructor, and returning the same result regardless.
21:44:33 <Cale> like:
21:44:45 <mmorrow> , in foldl (\ !a b -> a+b) 0 [0..1000000]
21:44:46 <lunabot>  luna: parse error on input `in'
21:44:48 <mmorrow> , foldl (\ !a b -> a+b) 0 [0..1000000]
21:44:51 <lunabot>  Stack space overflow: current size 8388608 bytes.
21:44:51 <lunabot>  Use `+RTS -Ksize' to increase it.
21:44:57 <Cale> For lists it would be  seq xs y = case xs of [] -> y; (_:_) -> y
21:45:01 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) . takeWhile (\n -> n*n <= x) 4 primes in primes
21:45:03 <lambdabot>   Couldn't match expected type `[a1] -> a -> [a1]'
21:45:17 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) . takeWhile (\n -> n*n <= x) $ primes in primes
21:45:19 <sjanssen> mmorrow: that won't change the strictness of foldl itself
21:45:20 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:45:22 <Cale> This forces the evaluation of xs.
21:45:23 <wli> > let chunk n xs | [] <- xs = [] | otherwise = let (h, t) = splitAt n xs in h : chunk n t ; subDivSum xs | [] <- xs = 0 | [x] <- xs = x | otherwise = subDivSum . map sum $ chunk 16 xs in subDivSum [1..1024]
21:45:25 <lambdabot>   524800
21:45:26 <Gracenotes> pumpkin: works nicely with lazy evaluation
21:45:26 <orbitz> Cale: intresting
21:45:33 <mmorrow> sjanssen: yeah, i just realized
21:45:48 <mmorrow> sjanssen: after at least two wtf's
21:45:51 <pumpkin> Gracenotes: yeah, and a concatMap generates the whole digit sequence almost trivially
21:45:53 <Cale> orbitz: So seq just does this generically for any data, including the one special case which you can't write as a case-expression: functions.
21:46:08 <wli> > let chunk n xs | [] <- xs = [] | otherwise = let (h, t) = splitAt n xs in h : chunk n t ; subDivSum xs | [] <- xs = 0 | [x] <- xs = x | otherwise = subDivSum . map sum $ chunk 16 xs in subDivSum [1..1000000]
21:46:15 <lambdabot>   500000500000
21:46:28 <Cale> There would normally be no way to tell the difference between, say,  undefined :: a -> b, and  const undefined :: a -> b
21:46:30 <orbitz> what module is seq in?
21:46:32 <Cale> But with seq, there is.
21:46:34 <mmorrow> it's magic
21:46:35 <Axman6> > let f x = takeWhile (\n -> n*n <= x && 0 /= mod x n) [2..] in f 10
21:46:36 <Cale> orbitz: Prelude.
21:46:38 <lambdabot>   []
21:46:39 <mmorrow> @src seq
21:46:39 <lambdabot> Source not found. Do you think like you type?
21:46:42 <Axman6> > let f x = takeWhile (\n -> n*n <= x && 0 /= mod x n) [2..] in f 11
21:46:44 <lambdabot>   [2,3]
21:46:46 <mmorrow> "seq x = x"
21:46:48 <Cale> > (undefined :: a -> b) `seq` ()
21:46:51 <lambdabot>   * Exception: Prelude.undefined
21:46:52 <mmorrow> aka compiler magic
21:46:54 <Cale> > (const undefined :: a -> b) `seq` ()
21:46:57 <lambdabot>   ()
21:47:06 <Cale> That's the only magic part right there.
21:47:07 <orbitz> is seq pure haskell or some trickery?
21:47:12 <Cale> seq is mostly nonmagical
21:47:24 <Cale> But because of the above, it must be a primitive.
21:47:25 <mmorrow> but it can't be implem in pure haskell
21:47:34 <Cale> mmorrow: For *most* types it can.
21:47:52 <mmorrow> true
21:47:53 <Axman6> > let f x = takeWhile (\n -> n*n <= x && 0 /= mod x n) [2..] in f 123
21:47:53 <sjanssen> Cale: a function with the type that seq has can't be implemented in Haskell
21:47:55 <lambdabot>   [2]
21:48:01 <Axman6> > let f x = takeWhile (\n -> n*n <= x && 0 /= mod x n) [2..] in f 121
21:48:03 <lambdabot>   [2,3,4,5,6,7,8,9,10]
21:48:27 <mmorrow> it could be "implemented" via case expressions, but the general polymorphic case couldn't
21:48:28 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = not .  null . takeWhile (\n -> n*n <= x && 0 /= mod x n) $ primes in primes
21:48:31 <lambdabot>   [2,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
21:48:32 <Cale> sjanssen: Right, it would have to be in a typeclass, which would be inconvenient, which was one of the motivating factors in defining seq.
21:48:39 <orbitz> so in the case of foldl'. i need to force a' to be computed just to get te thunk evalauted rahter than build up?
21:48:46 <mmorrow> yes
21:49:03 <Cale> I wonder if there's any value in redefining seq so that for functions, it always ignores its first parameter without doing any evaluation.
21:49:14 <Axman6> wait, that doesn't work -_-
21:49:28 <mmorrow> , foldl' (\(x,y) b -> (x+b,y+b)) (0,0) [0..1000000]
21:49:33 <lunabot>  Stack space overflow: current size 8388608 bytes.
21:49:33 <lunabot>  Use `+RTS -Ksize' to increase it.
21:49:34 <mmorrow> , foldl' (\(!x,!y) b -> (x+b,y+b)) (0,0) [0..1000000]
21:49:38 <lunabot>  (500000500000,500000500000)
21:49:47 <mmorrow> and seq can only reach down one level
21:49:48 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = null . takeWhile (\n -> n*n <= x && 0 /= mod x n) $ primes in primes
21:50:03 <lambdabot>   thread killed
21:50:11 <orbitz> thansk all, heaidn gto bed
21:50:16 <Axman6> yeah that doesn't work, lame
21:50:21 <mmorrow> night
21:50:43 <Gracenotes> > for [1..10] negate
21:50:45 <lambdabot>   Not in scope: `for'
21:51:09 <Cale> I also sometimes wonder if our default pair type should be unlifted.
21:52:00 <mmorrow> Cale: but how would it know if it's first arg is a function without checking its tag, which it has to do anyway (and in the case of a function does nothing)
21:52:27 <mmorrow> (i think that's the whole story)
21:52:41 <mmorrow> (not positive)
21:52:58 <Cale> mmorrow: That's statically known.
21:53:06 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = null . takeWhile (\n -> n*n <= x || 0 /= mod x n) $ primes in primes
21:53:10 <Cale> mmorrow: er... hmm, I suppose not actually
21:53:11 <pumpkin> > product $ map ((read . (:[])) . ((concatMap show [1..]) !!) . (subtract 1) . (10^)) [0..6]
21:53:17 <lambdabot>   210
21:53:19 <pumpkin> whee
21:53:20 <pumpkin> lol
21:53:22 <lambdabot>   thread killed
21:53:36 <Cale> mmorrow: But it could be made known prior to evaluation. It might cost a little in memory though.
21:53:39 <pumpkin> Gracenotes: that's my one-liner, it can probably be improved :)
21:53:59 <pumpkin> it uses !!, but the problem kinda demands it
21:54:04 <mmorrow> Cale: hmm, how would it be made known?
21:54:23 <mmorrow> (== what does "made known" mean?)
21:54:23 <Cale> mmorrow: Thunks of functional type could be tagged.
21:54:33 <mmorrow> Cale: ah, i think they are
21:54:38 <Gracenotes> pumpkin: more or less what I did as well
21:55:18 <mmorrow> Cale: like heap objects have a tag `elem` [Fun,Ap,Thunk(can't remember actual tagname),...]
21:55:48 <Gracenotes> the (read . (:[])) function is interesting
21:55:53 <mmorrow> which seq probably check to see if it needs to eval
21:55:59 <mmorrow> checks
21:56:11 <Gracenotes> why the (:[])?
21:56:25 <Gracenotes> it looks so angry :/
21:56:42 <teko> , foldl' (\(x,y) b -> (x+b,y+b)) (0,0) [0..10]
21:56:44 <lunabot>  (55,55)
21:57:05 <mmorrow> Cale: there's this really cool function in RtClosureInspect to get the ClosureInfo of an arbitrary `a'. i'll paste
21:57:07 <Gracenotes> oh, I see, read doesn't support char by default
21:57:44 <Gracenotes> er, only Strings, duh
21:57:49 <Gracenotes> well, there is Data.Char.digitToInt, I guess
21:57:56 <Axman6> > map (read.return).show $ 12345
21:58:00 <lambdabot>   [* Exception: Prelude.read: no parse
21:58:18 <Axman6> > map (read.return).show $ 12345 :: [Integer]
21:58:22 <lambdabot>   [1,2,3,4,5]
21:58:52 <Gracenotes> > map digitToInt . show $ 12345
21:58:55 <lambdabot>   [1,2,3,4,5]
21:59:29 <Gracenotes> > return '4'
21:59:31 <lambdabot>       No instance for (Show (m Char))
21:59:31 <lambdabot>        arising from a use of `show' at ...
21:59:38 <Axman6> > map digitToInt $ "1234567890abcdef"
21:59:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,0,10,11,12,13,14,15]
21:59:47 <Axman6> excellent
22:00:01 <Megzlna> Why does :m + Data.Map  not work when doing it inside GHCI ?
22:00:15 <gaze__> "num ('o':'n':'e':xs) = 1" is this kinda thing a common trick?
22:00:16 <Axman6> :m +Data.Map?
22:00:45 <Axman6> gaze__: as good as any for simple matching
22:01:11 <Megzlna> > :m +Data.Map
22:01:11 <Megzlna> > Map.null $ Map.fromList [("foo",3),("bar",4)]
22:01:11 <Megzlna> <interactive>:1:0:
22:01:11 <Megzlna>     Failed to load interface for `Map':
22:01:11 <Megzlna>       Use -v to see a list of the files searched for.
22:01:11 <mmorrow> Cale: very amusing http://hpaste.org/13082
22:01:13 <lambdabot>   <no location info>: parse error on input `:'
22:01:14 <lambdabot>   False
22:01:16 <gaze__> yeah, it seems nice. I'd figure that haskell's pattern matching is really carefully tuned anyway
22:01:22 <mmorrow> getClosureData  and   isFullyEvaluated
22:01:30 <Cale> > fix ((2 :) . flip filter [3,5..] . flip (flip foldr True . (\n p r -> n `mod` p /= 0 && (p^2 > n || r))))
22:01:33 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
22:01:34 <Axman6> mmorrow: it did work, you need to use Data.Map.fromList or just fromList
22:01:44 <Megzlna> It only actually says there's a problem after you try to use it.
22:01:59 <Axman6> because you're using it wrong
22:02:12 <Axman6> whoops, what i said to mmorrow was for you Megzlna
22:02:14 <Megzlna> ah I didn't do unqualified
22:02:16 * wli attempts summing the first 10^6 primes.
22:02:25 <Axman6> don't need to qualify it
22:02:30 <Megzlna> the problem was
22:02:36 <Megzlna> if I don't qualify it, it's ambiguous
22:02:50 <pumpkin> Gracenotes: ah, I didn't know about that :)
22:02:50 <Megzlna> Ambiguous occurrence `null'
22:02:56 <Axman6> if you're using more than one function caled fromList, then yes
22:03:19 <mmorrow> Cale: hmm, that'd be neat to have those 3 functions in scope in the bot
22:03:35 <pumpkin> what's the simplest way to get a list of all numbers that aren't perfect squares?
22:04:10 <pumpkin> I did a comprehension with floor . sqrt squared but it's ugly
22:04:21 <Axman6> Cale: does that recognise failure right away and exit when there's a False?
22:04:28 <Cale> Axman6: yes
22:04:36 <Axman6> excellent
22:04:36 <mmorrow> Cale: i would've expected isFullyEvaluated id to be True though... not sure what that means exactly (that it isn't)
22:04:42 <Axman6> it's kind of hard to follow though
22:04:45 <wli> pumpkin: Keep  the perfect squares in a priority queue and compare the current list head to it.
22:04:46 <Megzlna> how to do qualified imports in GHCI?
22:04:46 <Cale> Axman6: (this latest one is just an obfuscated version of the previous)
22:04:57 <Axman6> yeah, i noticed that :)
22:05:05 <Megzlna> sorry
22:05:07 <Megzlna> I mean "as"
22:05:13 <Cale> mmorrow: oh, that is amusing :)
22:05:21 <mmorrow> totally
22:05:21 <Cale> mmorrow: (The hpaste finally loaded :)
22:05:22 <Axman6> mmorrow: just call Data.Map.fromList
22:05:34 <Megzlna> I want Data.Map as Map
22:05:49 <Cale> mmorrow: What about  id `seq` isFullyEvaluated id ? ;)
22:06:06 <Cale> mmorrow: Probably functions which need more parameters are not considered fully evaluated?
22:06:42 <mmorrow> Cale: i know that ghci reverts CAFs, but i don't think that'd be related to id
22:07:00 <mmorrow> Cale: i'm not sure, but that sounds possible
22:07:34 <mmorrow> id `seq` isFullyEvaluated id == False
22:07:47 <Cale> mmorrow: How'd you get the ghc package loaded with ghci?
22:07:55 <Megzlna> I guess ghci doesnt do this?
22:07:59 <wli> > let ints = [1..] ; squares = zipWith (*) ints ints ; move (sq:sqs) (i:is) | i < sq = i : move (sq:sqs) is | i == sq = move sqs is | otherwise = i : move sqs is in move squares ints
22:08:00 <lambdabot>   [2,3,5,6,7,8,10,11,12,13,14,15,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32...
22:08:03 <mmorrow> i guess it just considers objects with tag Fun to be not isFullyEvaluated
22:08:07 <Cale> mmorrow: I get a runtime linker error when I try to load that package.
22:08:18 <mmorrow> Cale: oh, i unhid that pkg, but you can just do
22:08:25 <mmorrow> $ ghci -package ghc
22:08:41 <Gracenotes> > concat $ map (\x -> [(x-1)^2+1..x^2-1]) [2..]  -- @pumpkin
22:08:42 <lambdabot>   [2,3,5,6,7,8,10,11,12,13,14,15,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32...
22:08:48 <Cale> Megzlna: Right, it's a little unfortunate, but they don't have syntax for qualified imports. You can instead add a qualified import to the file you're working on though.
22:08:50 <Gracenotes> yet another way to do it ;)
22:08:52 <mmorrow> does it work with -package ghc?
22:08:56 <Cale> mmorrow: That fails for me
22:08:58 <Gracenotes> the syntax is a little messy, but it works
22:09:00 <mmorrow> hmm odd
22:09:06 <Axman6> wli: what's that supposed to do?
22:09:08 <mmorrow> Cale: what version of ghc?
22:09:16 <Cale> 6.10.1
22:09:26 <mmorrow> weird, me too
22:09:39 <wli> Axman6: Enumerate all natural numbers that are not perfect squares.
22:09:48 <Axman6> ah, i see
22:09:55 <Cale> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
22:09:55 <Cale>    waitForProcess
22:10:18 <wli> pumpkin: More interesting is enumerating all squarefree numbers.
22:10:23 <mmorrow> hmm, do you have :m + System.Posix.* in your .ghci or something?
22:10:32 <mmorrow> (i don't know why that woiuld matter though)
22:10:37 <Cale> nope
22:10:45 <jml> wli: squarefree?
22:11:04 <wli> jml: Not divisible by a perfect square.
22:11:06 <mmorrow> Cale: how far do you get?
22:11:21 <Cale> mmorrow: I'm just trying to hpaste the output now.
22:11:26 <mmorrow> :)
22:11:31 <Cale> mmorrow: (my connection is being crappy)
22:11:50 <Cale> http://hpaste.org/13084
22:12:06 <Cale> hmm...
22:13:32 <Cale> perhaps I should try reinstalling the process package
22:13:34 <mmorrow> oh, i know exactly what your problem is (i had this before)
22:13:40 <Cale> ah, what is it?
22:14:07 <mmorrow> having two versions of process, if they both get loaded that'll happen
22:14:25 <Cale> aha
22:14:57 <mmorrow> i had this with a previous ghc, and never actually fixed it because there were just too many pkgs depending on one or the other
22:15:04 <Cale> yes, that appears to be it
22:15:19 <mmorrow> nice
22:15:22 <Cale> hm, I wonder what depends on the new process
22:15:47 <mmorrow> i bet whatever does doesn't actually need the newest version
22:16:22 <Megzlna> > isNothing $ Just Nothing
22:16:24 <lambdabot>   False
22:16:31 <Megzlna> ?
22:17:02 <Raevel> @type isNothing
22:17:04 <lambdabot> forall a. Maybe a -> Bool
22:17:04 <mmorrow> (i had it when the default process was the old-interface one and i had the new process as well, and it completely broke my hs-plugins)
22:17:29 <Cale> ahh, much better
22:17:34 <mmorrow> sweet
22:17:53 <Raevel> Megzlna: isNothing doesn't look inside the maybe, only at the outermost constructor
22:17:53 <erikc> isNothing Nothing = True; isNothing _ = False
22:18:11 <Megzlna> how do you check isNothing on a Just
22:18:27 <Cale> I told it to unregister process-1.0.1.1 which told me that it would break haskell98-1.0.1.0 (which I had installed as user), so I told it to unregister that, which went with no problems, and then I could remove process.
22:18:44 <Cale> Megzlna: By producing False?
22:18:57 <Cale> Megzlna: the _ matches anything else.
22:19:05 <Megzlna> no I mean
22:19:19 <Megzlna> how do you check if my Just is Nothing
22:19:29 <Cale> ....
22:19:32 <Cale> What?
22:19:40 <Cale> It's clearly not.
22:19:44 <Raevel> he means, if he has the exact structure Just Nothing
22:19:49 <Cale> oh
22:20:10 <Cale> You can pattern match.
22:20:25 <Cale> Or if you don't mind the Eq constraint, you can use (== Just Nothing)
22:20:47 <Megzlna> > (== Just Nothing) $ Just Nothing
22:20:49 <lambdabot>   True
22:21:06 <Megzlna> so there's no library function for doing that? weird
22:21:14 <Cale> It would be nice to have a syntax which took a pattern and turned it into a boolean function.
22:21:29 <Cale> Megzlna: For telling if something of type Maybe (Maybe a) is Just Nothing?
22:21:38 <Megzlna> Cale: Yes
22:21:40 <olsner> > liftM2 (&&) isJust (not . isJust . fromJust) (Just Nothing)
22:21:42 <lambdabot>   True
22:21:43 <Cale> Megzlna: That's way too special-case to be in the libraries.
22:21:59 <Megzlna> Oh, I thught Just and Maybe were related.
22:22:04 <Megzlna> and Nothing
22:22:14 <Cale> Just and Nothing are data constructors for Maybe
22:22:25 <wli> > let move (sq:sqs) is = let (pfx, sfx) = (takeWhile (< sq) is, dropWhile (< sq) is) in pfx ++ move sqs (filter (\i -> i `mod` sq /= 0) sfx) in move (let ps = unfoldr (\(p:ns) -> Just (p, filter (\n -> n `mod` p /=  0) ns)) [2..] in zipWith (*) ps ps) [1..] -- squarefree numbers
22:22:27 <lambdabot>   [1,2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30,31,33,34,35,37,38,39,41...
22:22:33 <Cale> It's just that handling that one pattern match is too specialised.
22:22:37 <Cale> You could also write
22:22:49 <olsner> checking for "Just Nothing" is just not very common
22:22:49 <Cale> case x of Just Nothing -> ...; _ -> ...
22:22:50 <Megzlna> if Nothing is a ctor for Maybe, then why would checking if a Maybe is Just Nothing be too specialcase?
22:23:03 <Cale> Megzlna: They have a function for that.
22:23:06 <Cale> isNothing
22:23:13 <Cale> There's isNothing and isJust
22:23:33 <Cale> But not for deeper pattern matches.
22:23:59 <sjanssen> Megzlna: where would it end? Just (Just Nothing)?  Just (Just (Just Nothing))?
22:24:14 <mmorrow> Cale: nice, you got off easy ;)
22:24:37 <sjanssen> Megzlna: also, nested maybes aren't too common, perhaps you just want to use join?
22:25:13 <Cale> If Nothing and Just Nothing are the same to you, then you should apply Control.Monad.join first.
22:25:14 <pumpkin> , subsets [1,2,3,4]
22:25:16 <lunabot>  luna: Not in scope: `subsets'
22:25:19 <ddarius> sjanssen: He just wants to make noise.
22:25:21 <Megzlna> I really have no idea how maybe and just work, it's weird, but the way I imagined it working would be that you'd commonly check for (== Just Nothing), I must have some odd idea here
22:25:22 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
22:25:26 <lunabot>  [AP,Constr]
22:25:27 <Cale> > join (Just Nothing)
22:25:29 <pumpkin> wasn't there a subsets function?
22:25:29 <lambdabot>   Nothing
22:25:40 <Cale> > join (Just (Just 4))
22:25:40 <Megzlna> Oh
22:25:42 <sjanssen> Megzlna: you almost never need to do that
22:25:42 <lambdabot>   Just 4
22:25:52 <olsner> does haskell have some kind of assert construct?
22:25:54 <sjanssen> Megzlna: I think you need to meet the Maybe Monad
22:26:00 <mmorrow> , let x = 1 + 1 in [isFullyEvaluated x, x `seq` isFullyEvaluated x]
22:26:06 <lunabot>  [False,True]
22:26:07 <sjanssen> olsner: yes, somewhere in base
22:26:08 <Cale> Megzlna: *Usually* you use case.
22:26:09 <sjanssen> @hoogle assert
22:26:10 <lambdabot> Control.Exception assert :: Bool -> a -> a
22:26:10 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
22:26:10 <lambdabot> Test.HUnit.Base class Assertable t
22:26:34 <olsner> sweet, does that also print the expression that was asserted?
22:26:39 <Cale> let x = Just Nothing in case x of Nothing -> 0; Just Nothing -> 1; Just (Just x) -> x
22:26:43 <Cale> > let x = Just Nothing in case x of Nothing -> 0; Just Nothing -> 1; Just (Just x) -> x
22:26:45 <lambdabot>   1
22:26:51 <Cale> > let x = Just (Just 5) in case x of Nothing -> 0; Just Nothing -> 1; Just (Just x) -> x
22:26:53 <lambdabot>   5
22:26:57 <Megzlna> @src join
22:26:57 <lambdabot> join x =  x >>= id
22:27:17 <pumpkin> it seems like the Show typeclass should be called Showable :P
22:27:17 <Cale> This has the additional advantage of helping you identify whether you've handled every possible case.
22:27:24 <sjanssen> olsner: I think it prints the source location of the assertion
22:27:32 <Cale> fromJust is a particularly dangerous function.
22:27:38 <Megzlna> why
22:27:42 <Cale> > fromJust Nothing
22:27:44 <sjanssen> > fromJust Nothing
22:27:44 <mmorrow> the head of Maybe
22:27:44 <lambdabot>   * Exception: Maybe.fromJust: Nothing
22:27:46 <lambdabot>   * Exception: Maybe.fromJust: Nothing
22:27:47 <Cale> ^^ that.
22:28:13 <mmorrow> fromJust = maybe undefined id
22:28:21 <Megzlna> > fromJust $ Just 1
22:28:23 <lambdabot>   1
22:28:23 <Megzlna> > fromJust $ Just Nothing
22:28:25 <lambdabot>   Nothing
22:28:26 <Megzlna> > fromJust Nothing
22:28:28 <lambdabot>   * Exception: Maybe.fromJust: Nothing
22:28:33 <mmorrow> program crash
22:28:37 <Cale> Pure exceptions are really tricky to catch. If you throw one, you're basically saying "something is *horribly* wrong, shut the whole program down."
22:29:26 <Cale> Because practically speaking, nobody's going to bother to catch it. (Which can only be done from IO, and involves sequencing evaluation carefully with IO execution)
22:29:28 <Megzlna> how do you describe "Just" in english?
22:29:56 <Cale> It's a data constructor for the Maybe t type which takes a parameter of type t... if that's English enough.
22:30:25 <sjanssen> Megzlna: Maybe is used in situations where you may have a value (Just thevalue), or not (Nothing)
22:30:29 <mmorrow> "here's not Nothing, open me to find an (_::a)"
22:30:52 <Megzlna> is it possible to implement a fromJust which works on only  Just Nothing and Just 1, but not Nothing?
22:31:07 <dons> i wonder if we need a "how do you say this" wiki page
22:31:13 <mmorrow> heh
22:31:17 <erikc> is there a way to catch a failed pattern match? (or...is there a default clause always generated that calls error?)
22:31:23 <dons> since a lot of "how you say it" is an oral tradition passed down through ICFP
22:31:32 <Cale> Megzlna: A value of type Maybe t can be thought of as a tray which either is empty, or has on it a value of type t. If the tray is empty, the value is Nothing, if the tray is full with the value x :: t, the value is Just x
22:31:34 <sjanssen> dons: ISTR a "Haskell pronunciation" thread on the haskell-cafe
22:31:39 <dons> erikc: you can catch them in IO
22:31:54 <dons> erikc: or better still, write total functions
22:31:55 <Cale> Megzlna: That's already the case.
22:32:01 <Cale> > fromJust (Just Nothing)
22:32:03 <lambdabot>   Nothing
22:32:05 <Cale> > fromJust (Just 1)
22:32:07 <dons> erikc: use -Wall and the compiler will warn of partials
22:32:08 <lambdabot>   1
22:32:11 <Cale> > fromJust Nothing
22:32:13 <lambdabot>   * Exception: Maybe.fromJust: Nothing
22:32:14 <wli> That's rather awkward. The std. Prelude shouldn't be such a minefield.
22:32:21 <Megzlna> Cale: Ok -- why would it be a bad idea for fromJust Nothing to return Nothing?
22:32:29 <sjanssen> @type fromJust
22:32:31 <dons> Megzlna: it would be 'id' then
22:32:31 <lambdabot> forall a. Maybe a -> a
22:32:34 <Cale> Megzlna: Because that's a type error.
22:32:35 <sjanssen> Megzlna: fromJust's type says it can't
22:32:42 <erikc> k, that means my _ -> fail "Bad ELF!" bail outs are redundant (aside from providing an error message)
22:32:57 <mmorrow> hehe
22:33:01 <dons> erikc: right. you could leave them off and get a pattern failure
22:33:12 <dons> erikc: depending on how rare they are.
22:33:12 <wli> erikc: Best is to use exception monads.
22:33:13 <sjanssen> erikc: if you swap in a proper exception Monad, they actually will be useful
22:33:22 <dons> maybe run in a parser Error monad.
22:33:32 <sjanssen> man, #haskell is such a hive mind
22:33:33 <dons> like json does
22:33:34 <Cale> Megzlna: The whole point of fromJust is to strip off the Just constructor. If it produced a Maybe a, it would have to put the Just right back on, and would amount to the identity function.
22:33:47 <dons> sjanssen: yeah, collective training
22:33:55 <dons> don't use fromJust
22:34:03 <dons> its bad form , since it introduces new failures
22:34:06 <Cale> But yeah, don't use fromJust, use case.
22:34:09 <Cale> Or maybe
22:34:12 <dons> and we're all about not having failures.
22:34:13 <Cale> :t maybe
22:34:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:34:23 <Cale> :t fromMaybe
22:34:24 <pumpkin> @oeis 6 42 120 156
22:34:25 <lambdabot> forall a. a -> Maybe a -> a
22:34:29 <lambdabot>  Alexandrian integers: numbers of the form n=pqr such that 1/n = 1/p-1/q-1/r ...
22:34:29 <lambdabot>  [6,42,120,156,420,630,930,1428,1806,2016,2184,3192,4950,5256,8190,8364,8970,...
22:34:33 <dons> having a failure in a haskell program is an epic fail.
22:34:41 <Cale> There are lots of good ways to handle the failure case more gracefully :)
22:34:50 <erikc> fromJust is like dereferencing a pointer with no null check when you've been told could be null
22:34:55 <dons> yeah
22:34:57 <sjanssen> > ("epic" `fail`) :: Maybe ()
22:34:57 <Megzlna> What does canonical case-on-just look like?
22:34:59 <lambdabot>   Nothing
22:35:14 <Cale> case foo of Nothing -> ...; Just x -> ... x ...
22:35:14 <dons> oleg's made the point that pattern match failures are our null pointer crashes
22:35:27 <sjanssen> agreed
22:35:32 <Cale> (normally you'd use layout, and align the cases vertically)
22:35:53 <dons> not quite as evil, you don't get into an "i can mess with your memory" state, but still, morally equal
22:36:00 <mmorrow> Megzlna: the `maybe' function is great
22:36:27 <mmorrow> , maybe "" id (Just "asdfg")
22:36:29 <lunabot>  "asdfg"
22:36:32 <mmorrow> , maybe "" id Nothing
22:36:34 <pumpkin> > epic win
22:36:34 <lunabot>  ""
22:36:36 <lambdabot>       Overlapping instances for Show (b -> String -> Maybe Int)
22:36:36 <lambdabot>        arisin...
22:36:41 <mmorrow> @type epic
22:36:43 <lambdabot> forall a b. a -> b -> a
22:36:43 <Megzlna> Does Maybe have two boxes?
22:36:43 <Cale> , fromMaybe "" (Just "asdfg")
22:36:45 <lunabot>  "asdfg"
22:36:52 <Cale> , fromMaybe "" Nothing
22:36:54 <lunabot>  ""
22:37:00 <mmorrow> , maybe 0 length (Just "asdfg")
22:37:02 <lunabot>  5
22:37:05 <pumpkin> > epic fail
22:37:06 <Axman6> > epic win "Axman!"
22:37:07 <lambdabot>       Overlapping instances for Show (b -> String -> m a)
22:37:07 <lambdabot>        arising from...
22:37:08 <lambdabot>       Overlapping instances for Show (String -> Maybe Int)
22:37:08 <lambdabot>        arising fro...
22:37:15 <Cale> Megzlna: What sense of the word 'box'?
22:37:16 <Megzlna> Just 1  <-- 2 boxes?
22:37:18 <pumpkin> Axman6: epic fail
22:37:29 <Axman6> uh huh :(
22:37:45 <Cale> Megzlna: You're asking about the in-memory representation?
22:37:46 <Megzlna> Cale: The way that values are boxed, I was thinking that the '1' box could be bitpacked with the Just box
22:37:50 <dons> two indirections?
22:37:51 <Megzlna> yea
22:37:59 <sjanssen> Megzlna: it isn't
22:38:27 <sjanssen> (in GHC, at least)
22:38:28 <Cale> Just 1  will have a tag for the Just, and a pointer to the Integer value 1.
22:38:47 <dons> its basically a pointer, with 'Just' encoded in the bottom bits, pointing to the 1 structure
22:38:56 <Cale> Oh, pointer tagging?
22:39:04 <Megzlna> yea
22:39:06 <dons> putting the tag back in tagless :)
22:39:16 <sjanssen> but there are still two boxes
22:39:21 <Cale> Does pointer tagging really avoid having a real structure there?
22:39:29 <sjanssen> Cale: nope
22:39:37 <Cale> sjanssen: that's what I thought
22:39:37 <dons> it avoids having to dereference to look at the tag
22:39:51 <wli> The erect-spined, tagged G-machine?
22:40:05 <Cale> If we had x = Just 1, then x, as a pointer, would store the fact that it was Just in the low-order bits, right?
22:40:10 <dons> let's see what the core looks like.
22:40:11 <Megzlna> dons, how is that possible if Just is library?
22:40:19 <Cale> But the Just 1 structure would still exist.
22:40:20 <sjanssen> Cale: yes
22:40:23 <dons> M.a = Internals.S# 1
22:40:33 <dons> M.x = Data.Maybe.Just a
22:40:33 <sjanssen> Megzlna: pointer tagging is an optimization applied to all types
22:40:41 <Megzlna> sjaanssen: k
22:40:42 <dons> Megzlna: tagging is just how the runtime works.
22:40:47 <mmorrow> dons: you should start adding a (tm) after "let's see what the core looks like."
22:40:57 <dons> so, now, the asm.
22:40:58 <Axman6> â„¢
22:41:04 <Megzlna> Yay
22:41:07 <dons> M_a_closure: .quad        integer_GHCziIntegerziInternals_Szh_static_info .quad        1
22:41:07 <Megzlna> The asm ;)
22:41:15 <dons> M_x_closure: .quad        base_DataziMaybe_Just_static_info .quad        M_a_closure+1 .quad        1
22:41:32 <Cale> Megzlna: and for types with <= 3 or <= 7 cases (depending on 32/64 bit arch), the tag also stores for evaluated values, which of the constructors it was
22:41:38 <Axman6> dons: i've been going through your making haskell as fast as C stuff on your blog, it's really nice :)
22:41:44 <mmorrow> preflex: zdec integer_GHCziIntegerziInternals_Szh_static_info
22:41:45 <preflex>  integer_GHC.Integer.Internals_S#_static_info
22:41:48 <Cale> Megzlna: which avoids having to dereference in those cases
22:41:59 <dons> the asm is quite enlightening there.
22:42:02 <Cale> Megzlna: So for instance, you never ever have to dereference to a Bool structure.
22:42:03 <dons> let me stick it on hpaste..
22:42:15 <Cale> (once it's evaluated)
22:42:22 <Megzlna> neat
22:42:36 <dons> http://hpaste.org/13085
22:42:46 <dons> so x = Just 1
22:43:12 <dons> M_x_closure is a label of an object with 24 words
22:43:16 <dons> grr. 3 words
22:43:18 <dons> 24 bytes
22:43:27 <dons> first word. base_DataziMaybe_Just_static_info
22:43:40 <dons> (when evaluated the tag bit will be set to Just )
22:43:46 <dons> second word:   .quad        M_a_closure+1
22:43:58 <dons> indirection to the fast entry into M_a_closure
22:44:06 <dons> containing the 64 bit value '1'
22:44:16 <Axman6> what's .quad mean?
22:44:31 <dons> 64 bit word?
22:44:39 <dons> its a type
22:44:53 <dons> now, what's that last word in the M_x_closure.
22:45:11 <dons> ah, don't know.
22:45:51 <Megzlna> 0 :P .. depending on endianness
22:46:21 <dons> so x = Just 1 is a ptr to { *Just, *1 } , basically.
22:46:27 <dons> skipping the S# constructor (interesting)
22:46:49 <olsner> Megzlna: I think he's referring to 64-bit words there :P
22:46:56 <dons> make sense? (i thought that was surprisingly clear asm)
22:47:16 <dons> and ghc-core ftw. encouraged for those who want to think about data layouts
22:47:17 <Cale> dons: Any way we could figure out what that extra .quad 1 at the end is?
22:47:34 <dons> ask JaffaCake
22:47:35 <Cale> dons: Is it just duplicating the integer value for some reason?
22:47:40 <dons> no, i checked that.
22:47:43 <olsner> or is it duplicating the tag?
22:47:45 <dons> it stays a 1
22:47:54 <Cale> okay...
22:48:04 <dons> now, what is x =Nothing
22:48:15 <dons> M_x_closure: .quad        base_DataziMaybe_Nothing_static_info
22:48:16 <dons> simple
22:48:23 <Gooffy> hi! anybody could give me ebook version of Hudak's SoE?
22:48:52 <dons> so the representation of data is all fairly obvious.
22:49:04 <dons> you can tweak things with {-# UNPACK #-} to avoid some indirections
22:49:12 <dons> let's see what that looks like.
22:49:48 <jeffz`> Gooffy: it's only available for purchase in dead tree form
22:51:08 <dons> M_x_closure: .quad        M_JustS_static_info .quad        7
22:51:15 <dons> data MaybeS = NothingS | JustS {-# UNPACK #-}!Int
22:51:16 <dons> x = JustS 7
22:51:26 <dons> so no indirection into the body (== win)
22:51:27 <Gooffy> post service in russia very bad
22:51:33 <pumpkin> > win
22:51:36 <lambdabot>       Overlapping instances for Show (String -> Maybe Int)
22:51:36 <lambdabot>        arising fro...
22:52:01 <dons> maybe i should write a post about the low level details of data layout for different haskell types
22:52:18 <Cale> dons: Well... apart from the loss of polymorphism and the ability for the value there to be lazily evaluated ;)
22:52:21 <dons> understanding how the layout of data is affected by strictness, optimisation, etc, might be useful.
22:52:28 <pumpkin> Gooffy: maybe you should try RWH, which is available for free online, without breaking any laws ;)
22:52:37 <dons> Cale: right. you have to constrain it to a non-sum type, and make it monomorphic and strict
22:52:58 <dons> Cale: and *then* you get no indirection (since you've ruled out a universal polymorphic box, and ruled out bottom)
22:53:17 <dons> haskell: it has a lot going on.
22:53:24 <Gooffy> pumkin, yes, i get it, but i heard, that soe is best book
22:53:35 <dons> Gooffy: yeah, if you're already a programmer, RWH is a better choice for online use.
22:53:51 <dons> i'm not sure anyone's compared soe to rwh, actually.
22:53:54 <dons> would be interesting.
22:53:56 <Cale> Gooffy: SoE is decent, but aging.
22:54:04 <jeffz`> I found yaht better than SoE
22:54:12 <dons> will have to wait for swiert's review.
22:54:27 <olsner> dons: that definitely sounds like an interesting topic! (data layout and optimizations)
22:54:41 <dons> olsner: i bet it would help make C++ hackers more comfortable.
22:54:46 <Gooffy> thanks!
22:54:50 <dons> how do python people think about data layout?
22:55:24 <olsner> I would think the point of python is to not think about it :P
22:55:47 <dons> hmm. haskell too. but you need to , to get the best out of the machine.
22:55:54 <dons> since it has certain preferences
22:56:29 <olsner> C++ is a weird beast encouraging people to think in bits, while at the same time trying to make bit-thinking unsafe and undefined
22:56:48 <Cale> I think the nice thing about Haskell (at least with GHC) is that it encourages you not to care, but if you really do, the tools are available to get a handle on what the machine is actually doing.
22:58:23 <dons> important if you're writing device drivers
23:03:44 <mmorrow> dons: ByteString.agda  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=584
23:04:18 <mib_h6pwzm> Hi, is there a good tutorial for function proofs?
23:04:31 * mmorrow pulls himself away from irc
23:05:03 <Cale> mib_h6pwzm: hmm, I don't know, but for the most part, it's done by substituting things for their definitions.
23:05:44 <Cale> mib_h6pwzm: and possibly inventing/making use of some lemmas to simplify the journey
23:08:03 <sstangl> mib_h6pwzm: if you google for "15-212", CMU has a course on functional programming that is entirely proof-based.
23:08:20 <sstangl> it's in SML, but the same logic applies to haskell.
23:08:46 <Cale> (with a few small modifications)
23:09:59 <Gracenotes> hm. RWH says "Beware of fail" in the monad chapter. Too true.
23:10:16 <Cale> I would just ignore fail altogether.
23:10:33 <Cale> With any luck, it'll eventually no longer be part of the Monad class.
23:13:44 <Megzlna> > foldr f z [a,b,c,d,e]
23:13:46 <lambdabot>   f a (f b (f c (f d (f e z))))
23:13:57 <Megzlna> Why does this work on infinite lists... but:
23:14:01 <Megzlna> > foldl f z [a,b,c,d,e]
23:14:02 <lambdabot>   f (f (f (f (f z a) b) c) d) e
23:14:04 <Megzlna> does not?
23:14:11 <Cale> foldl is tail recursive
23:14:17 <Cale> @src foldl
23:14:17 <lambdabot> foldl f z []     = z
23:14:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:14:39 <Cale> Note that the first thing which will happen when foldl is applied to a nonempty list is it will call itself with new parameters
23:14:50 <pumpkin> I feel bad on things like problem 13 of project euler, when I just use the fact that haskell has big ints
23:14:57 <pumpkin> makes it trivial
23:15:04 <Cale> f will be given no chance to evaluate or determine part of the result early
23:15:10 <Cale> @src foldr
23:15:10 <lambdabot> foldr f z []     = z
23:15:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:15:12 <olsner> pumpkin: don't feel bad, feel *good*
23:15:16 <pumpkin> :D
23:15:18 <Gracenotes> pumpkin: is that the fibonacci one, by chance?
23:15:20 * pumpkin feels good
23:15:28 <Cale> By contrast, the first thing to evaluate after foldr is applied to a nonempty list will be f
23:15:37 <dancor> pumpkin: there are big ints in other langs too, ppl just use them less :)
23:15:38 <pumpkin> Gracenotes: nah, they give you loads of large numbers and ask you for the first 10 digits of their sum
23:15:48 <dancor> oh laziness
23:15:49 <Cale> if f doesn't need its second parameter to produce some of its output, the recursive call to foldr might never be used.
23:16:04 <Gracenotes> pumpkin: ah. I remember implementing the first dozen or so problems Java
23:16:13 <Gracenotes> using BigInteger and BigDecimal
23:16:20 <Gracenotes> it sucked >_>
23:16:25 <Cale> Megzlna: make sense?
23:16:27 <Megzlna> <Cale> f will be given no chance to evaluate or determine part of the result early
23:16:38 <Megzlna> so... you're saying
23:16:53 <Cale> Let's see a concrete example, say with a finite list.
23:16:54 <Megzlna> the foldl just keeps going forever, but a foldr stops immediately with a lazy f?
23:16:57 <Cale> yes
23:17:03 <Cale> exactly
23:17:14 <Cale> foldr in some sense always finishes in one step
23:17:34 <Cale> But what it produces is f applied to some parameters, one of which contains a call to foldr.
23:17:40 <Megzlna> why cant the foldl result: foldl be lazy ?
23:18:08 <mauke> tail recursion
23:18:11 <CodeWar> /clear
23:18:20 <Megzlna> Can we do that concrete example anyways
23:18:21 <Cale> You mean, is there a way of rewriting foldl to be lazy? In fact, I'm pretty sure there isn't.
23:18:33 <Cale> At least, not in the sense that foldr is.
23:19:00 <roconnor> > foldl (+) e [a,b,c]
23:19:02 <lambdabot>   e + a + b + c
23:19:21 <Megzlna> this makes the distinction of foldl' confusing
23:19:22 <Cale> That's  (((e + a) + b) + c)
23:19:41 <Cale> Megzlna: foldl is not strict in its accumulating parameter
23:19:47 <Cale> @src foldl
23:19:47 <lambdabot> foldl f z []     = z
23:19:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:19:54 <Cale> It doesn't pattern match on z
23:20:11 * jml eyebrow raises
23:20:11 <Cale> So the expressions build up there.
23:20:25 <jml> The '@src' command looks useful.
23:20:34 <jml> how would I do that at home?
23:20:40 <Cale> jml: It's just a text-database of a bunch of Haskell code.
23:20:48 <jml> ahh ok.
23:21:34 <Megzlna> http://hpaste.org/13086  <-- this wasnt enough to clear it up
23:22:48 <Gracenotes> @src liftM4
23:22:48 <lambdabot> liftM4 f m1 m2 m3 m4 = do { x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; return (f x1 x2 x3 x4) }
23:22:50 <Cale> grr, whenever I'm on a torrent, my router seems to just start dropping things on the floor
23:23:11 <Megzlna> @src foldl'
23:23:11 <lambdabot> foldl' f a []     = a
23:23:11 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:23:14 <pstickne> Cale:  the MPAA/RIAA are after you! ^^
23:23:32 <Megzlna> how is that one pattern matching on z?
23:23:34 <sjanssen> Cale: cap your uploads
23:23:34 <Cale> pstickne: I didn't realise they were coming after Canadians ;)
23:23:53 <erikc> downloading the season finale of dexter too Cale? :)
23:23:53 <pstickne> Cale:  well, with the decline of the USD... :)
23:24:00 <Cale> erikc: indeed.
23:24:04 <mauke> Megzlna: it isn't :-)
23:24:10 <erikc> haha, we're probably on the same torrent
23:24:33 <mauke> Megzlna: but seq introduces an artifical data dependency, causing a' to be evaluated before foldl' f a' xs
23:24:42 <jeffz`> I gave up on torrents, my router didn't like them either, somethign to do with hanging onto connections
23:25:12 <Cale> Megzlna: I think that quote at the bottom of your paste is confusing about the order in which foldr and foldl evaluate.
23:25:22 <Cale> foldr doesn't start at the end of the list, it starts at the beginning
23:25:43 <Megzlna> mauke: What's the artificial dependency?
23:25:46 <Megzlna> @src seq
23:25:46 <lambdabot> Source not found. You type like i drive.
23:25:52 <mauke> Megzlna: huh?
23:26:06 <Cale> Megzlna: seq is a primitive
23:26:27 <Zao> There's no easy to access 'end of a list', it's just the lack of more elements in a sequence.
23:26:34 <Megzlna> I wrote: "..investigate! The fact that foldr works on infinite lists is key to lazy.
23:26:48 <Cale> Megzlna: I was referring to the thing just before htat
23:26:50 <Cale> that*
23:26:50 <Megzlna> Because I felt it be a moment of shifted understanding
23:26:54 <Megzlna> Yeah,
23:27:15 <Cale> "you fold it up from the right, you'll eventually reach the beginning of the list"
23:27:28 <Cale> If by 'eventually' one means 'immediately'
23:27:30 <Megzlna> "One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end!"
23:27:46 <Cale> then it's right, but I think "eventually" gives the wrong idea
23:27:47 <Megzlna> how to edit that to be correct?
23:27:59 <Cale> s/eventually/immediately/
23:28:00 <sjanssen> Megzlna: foldr doesn't actually fold from the right
23:28:23 <Cale> It folds in such a way that the operator is associated to the right.
23:28:28 <Cale> It starts at the left end of the list.
23:28:35 <Cale> (that is, the beginning)
23:28:38 <sjanssen> Megzlna: it starts at the very first cons, and the function argument to foldr decides whether to procede to a subsequent element
23:28:42 <Megzlna> Why does foldr's f swap the acc and z ?
23:28:48 <Megzlna> into the opposite order
23:29:05 <sjanssen> Megzlna: it's actually the other way around, foldr has the natural order, foldl swaps them
23:29:06 <Cale> Megzlna: because of the way in which the list is being associated
23:29:10 <pumpkin> @hoogle argmax
23:29:11 <lambdabot> No results found
23:29:12 <Cale> Megzlna: Have you seen my diagrams?
23:29:15 <Megzlna> no
23:29:33 <Cale> okay, http://cale.yi.org/index.php/Fold_Diagrams
23:29:36 <mauke> > foldr (-) 0 [10, 2, 3]
23:29:37 <lambdabot>   11
23:29:39 <Megzlna> thanks
23:29:40 <mauke> > foldl (-) 0 [10, 2, 3]
23:29:41 <lambdabot>   -15
23:29:47 <Cale> (I apologise in advance for slowness)
23:30:17 <Cale> They should explain the difference, and what foldr and foldl are really doing.
23:30:35 <mauke> > (foldl (++) "" ["a", "b", "c"], foldr (++) "" ["a", "b", "c"])
23:30:36 <lambdabot>   ("abc","abc")
23:30:42 <Cale> You can see that in the foldl diagram, the list elements are the right parameter to each f
23:30:46 <Megzlna> http://rafb.net/p/G3lGdc38.html
23:30:53 <Megzlna> ^--- slightly longer
23:30:55 <Cale> Whereas in the foldr diagram, the list elements are on the left
23:32:02 <nanothief> With http://hpaste.org/13087 , why is myfunc [1,1,1] giving an error? I thought it would result in 3, but instead am getting an overlapping instances error
23:32:05 <Cale> erikc: Nice, I just started getting 880 KiB/s
23:32:07 <pumpkin> @src maximum
23:32:08 <lambdabot> maximum [] = undefined
23:32:08 <lambdabot> maximum xs = foldl1 max xs
23:32:47 <pumpkin> is there any way to find out how much of a list has been evaluated so far, without evaluating the rest of it?
23:32:57 <mauke> pumpkin: in ghci, yes
23:33:04 <pumpkin> mauke: that's where I'm at :)
23:33:09 <Cale> pumpkin: Using the GHC API, there's a way.
23:33:28 <mauke> pumpkin: :print var
23:33:32 <Cale> pumpkin: But it's the sort of not-referentially-transparent detail which you're not normally supposed to worry about ;)
23:33:37 <pumpkin> yeah :P
23:33:38 <ski_> Megzlna : any values are capitalized as `fooBar' (i.e. leading lower case), not just functions
23:33:48 <pumpkin> mauke: hrm
23:33:50 <ski_> s/values/variables/, sorry
23:33:56 <mauke> nanothief: it doesn't know which instance to choose
23:34:12 <sjanssen> nanothief: [a] also matches [Char]
23:34:20 <mauke> nanothief: 1 is polymorphic
23:34:39 <Cale> 1 could be of type Char, if at some point an instance of Num for Char was added
23:34:47 <roconnor> @type mapAccumL
23:34:48 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:34:54 <Megzlna> <Megzlna> why cant the foldl result: foldl be lazy ?
23:34:54 <Megzlna> <mauke> tail recursion
23:34:57 <roconnor> @index mapAccumL
23:34:58 <lambdabot> Data.List
23:35:09 <Megzlna> Why does tail recursion mean something can't be lazy?
23:35:15 <roconnor> @hoogle mapAccumL
23:35:16 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
23:35:16 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:35:16 <lambdabot> Data.ByteString.Char8 mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
23:35:24 <mauke> Megzlna: the key to laziness is that you don't actually need some computation right now
23:35:30 <nanothief> Cale: that hasn't happened (the I pasted the whole file). I don't understand why myFunc [True,False] would work when myFunc [1,2] doesn't, as 1 :: Char results in an error
23:35:37 * Cale wonders if mapAccumR is still broken...
23:35:40 <mauke> Megzlna: in the case of foldr, that's the fold of the rest of the list, which is passed to f
23:36:05 <Cale> yep
23:36:12 <Cale> Parameters are still the wrong way around.
23:36:16 <mauke> Megzlna: but foldl immediately calls itself, so there's no way to delay any of that
23:36:55 <roconnor> @serc mapAccumL
23:36:55 <Cale> nanothief: There's no way to know if an instance of Num for Char will be added in a future module or not.
23:36:56 <lambdabot> mapAccumL _ s []        =  (s, [])
23:36:56 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
23:36:56 <lambdabot>    where (s', y ) = f s x
23:36:56 <lambdabot>          (s'',ys) = mapAccumL f s' xs
23:37:25 <Cale> nanothief: Try  myFunc [1::Integer, 2, 3]
23:37:46 <Megzlna> Cale: nice diagrams.
23:37:50 <mauke> Megzlna: if you just look at the outermost calls in each equation, the only way foldl will ever return is when it reaches an empty list
23:38:01 <ski_> Megzlna : also `foo :: String -> Char' should be `foo :: String -> String' (or `foo :: String -> [Char]' if you insist)
23:38:08 <adu> hey
23:38:46 <adu> I just made a library for SVG path manupulation :)
23:38:51 <mauke> Megzlna: whereas foldr returns by calling f, which can ignore its second argument, thus avoiding any further evaluation of foldr
23:39:06 <nanothief> Cale: yes that works. So is the reason that it wasn't working because list wasn't a concrete type, but of type [Num], which Char may be a part of one day. [True,False] is a concrete type [Bool], so there is no problem.
23:39:21 <Cale> It was type (Num a) => [a]
23:39:24 <C-Keen> could some ghc people look at this please? http://hpaste.org/13088
23:39:56 <nanothief> Cale: right, well thanks for that
23:40:01 <Cale> nanothief: Right. Normally the instances would be considered overlapping already and rejected, but you added OverlappingInstances
23:40:09 <Megzlna> mauke: why can't it return a closure to   ' foldl f (f z x) xs '
23:40:34 <Megzlna> I'm missing a really fundamental basic premise here
23:40:35 <mauke> Megzlna: how does that help?
23:40:41 <Cale> nanothief: Another thing to note: instance selection is done *entirely* on the structure of the type, and is not based on what classes the type belongs to
23:40:52 <mauke> Megzlna: that just makes it monolithically lazy, not stepwise
23:40:52 <Megzlna> I think you guys think I understand 1 key fact which I dont :)
23:40:53 <sjanssen> C-Keen: they're probably not around right now, you might want to try #ghc
23:41:12 <Cale> nanothief: This is another consequence of typeclasses being open (you can always end up adding a type to a typeclass in a future module, so it can't rely on it not being an instance)
23:41:20 <ski_> Megzlna : because the full result of `foldr f z (x:xs)' was demanded, the rhs is demanded
23:41:49 <Megzlna> what if you returned a lambda with the foldl in it?
23:41:57 <mauke> Megzlna: the result of foldl is either a thunk (completely unevaluated) or a built up chain of calls to f. the latter case needs to run over the whole list
23:42:16 <Megzlna> that's the part I dont understand, why it has to be built up calls
23:42:27 <mauke> what else can it do?
23:42:28 <C-Keen> sjanssen: thanks
23:42:31 <Cale> Megzlna: well, just evaluate and see what happens:
23:42:37 <Cale> foldl f z [1,2,3]
23:42:41 <ski_> Megzlna : i.e. `foldr f z (x:xs)' got actually called because someone wanted the result of that, and since that simplifies to `foldr f (f z x) xs' (which is not in constructor form), we have to continue simplifying
23:42:43 <Cale> -> foldl f (f z 1) [2,3]
23:42:52 <Megzlna> why can't the result "foldl f (f z x) xs" be lazy?
23:42:53 <Cale> -> foldl f (f (f z 1) 2) [3]
23:43:02 <Cale> -> foldl f (f (f (f z 1) 2) 3) []
23:43:08 <Cale> -> f (f (f z 1) 2) 3
23:43:09 <mib_h6pwzm> Is there a Prelude function counting the number of times a particular element is in a list?
23:43:31 <Cale> Megzlna: It is lazy, it's just not available until the end of the list is reached.
23:43:48 <ski_> Megzlna : `foldl' isn't letting anyone else get control of execution here, until the list is fully traversed .. compare with `foldr'
23:44:00 <ski_>     foldr f z [0,1,2]
23:44:00 <Cale> Megzlna: If at this point, f doesn't need its first parameter to determine part of its result, the (f (f z 1) 2) won't be evaluated.
23:44:01 <Megzlna> 'it' being   f (f (f 0 1) 2) 3  ?
23:44:09 <Megzlna> THAT part is lazy
23:44:09 <ski_>   = f 0 (foldr f z [1,2])
23:44:19 <Cale> Megzlna: foldl does nothing but call itself until the end of the list is reached.
23:44:30 <ski_> at this point, control is passed to `f', which may e.g. just return the `0' and ignore the rest
23:44:44 <ski_> > foldr f z [0,1,2]   where f = const; z = 42
23:44:45 <pumpkin> what can I pass parMap as a Strategy?
23:44:46 <lambdabot>   0
23:44:58 <mauke> > const 42 (foldl (+) 0 [1 ..])
23:44:59 <lambdabot>   42
23:45:09 <erikc> dons: not sure if missed something, is there a way to customize Data.Binary.Get's failure behavior (e.g. reading past the end of the bytestring)?
23:45:10 <Cale> Megzlna: The topmost call to f in the result (and the first thing which needs to evaluate if the result is being evaluated), involves the *last* element of the list.
23:45:30 <Cale> Megzlna: which means foldl has no choice but to walk all the way to the end of the list right off the bat.
23:46:08 <teko> where can i upload my submissions for the new haskell logo ?
23:46:39 <Megzlna> May I ask a very simple question.
23:46:40 <Cale> No part of its result can be available until that outermost f (...) 3 is given a shot to produce stuff, and that 3 comes from the end of the list.
23:46:42 <Megzlna> let f = foldl (+) 0 [1,2,3,4]
23:46:44 <Megzlna> let f = foldr (+) 0 [1,2,3,4]
23:46:50 <mauke> > foldr (\x z -> if x > 10 then x else z) undefined [1 ..]
23:46:51 <lambdabot>   11
23:47:14 <mauke> > foldl (+) 0 [1,2,3,4] :: Expr
23:47:15 <lambdabot>   0 + 1 + 2 + 3 + 4
23:47:23 <mauke> gee
23:47:32 <Megzlna> > foldr (+) 0 [1,2,3,4] :: Expr
23:47:34 <lambdabot>   1 + (2 + (3 + (4 + 0)))
23:47:38 <Cale> Expr is clever and knows that (+) is left associative
23:48:01 <Cale> (or it seems to anyway)
23:48:08 <Megzlna> "foldl f (f z x) xs"   f x (foldr f z xs)
23:48:11 <Cale> > foldl (/) 0 [1,2,3,4] :: Expr
23:48:13 <lambdabot>   0 / 1 / 2 / 3 / 4
23:48:25 <Cale> >  0 / 1 / 2 / 3 / 4
23:48:26 <lambdabot>   0.0
23:48:40 <Cale> heh, bad example ;)
23:48:44 <Megzlna> I simply dont see the difference between 'f' and 'foldl'
23:49:03 <mauke> > foldr (\x z -> if x > 10 then x else z) undefined [1 ..]
23:49:04 <lambdabot>   11
23:49:11 <mauke> ^ try to do that with foldl
23:49:15 <Cale> Megzlna: what?
23:49:24 <Megzlna> lemme rephrase
23:49:32 <Cale> Between foldr and foldl?
23:49:55 <Cale> > foldl (-) 0 [1,2,3]
23:49:56 <lambdabot>   -6
23:49:59 <Cale> > foldr (-) 0 [1,2,3]
23:50:01 <lambdabot>   2
23:50:55 <Megzlna> foldl:"foldl f (f z x) xs"   foldr:"f x (foldr f z xs)"    -- foldl recurses forever, foldr stops immediately, because of 'foldl' vs. 'f' -- I don't see why 'f' stops but 'foldl' doesnt, since they're both merely functions. The only difference is that the foldl has an 'xs' on the end, whereas the xs is in parens with foldr
23:50:58 <ski_> Megzlna : also, neither `let f = g ; h = g where g = 1' nor `let f 1 = g ; f 2 = g where g = 3 in f 1' in your paste is ok
23:51:13 <sjanssen> Megzlna: the difference is that "f" is a function the user supplies, so the user can choose the next step in evaluation
23:51:22 <Cale> Megzlna: Control passes to f in the foldr case
23:51:54 <sjanssen> Megzlna: whereas foldl follows the rules per its definition
23:51:55 <Cale> Megzlna: If f doesn't need its second parameter (the recursive call to foldr), that is, if it doesn't pattern match against it, then the recursive call is never made.
23:52:28 <ski_> Megzlna : with `foldl' it passed control on to itself until the list is exhausted, with `foldr' it passes control to the *user-supplied* function `f' (which may abort at any time) before the list is exhausted
23:52:33 <teko> new haskell logo suggestions:   http://img213.imageshack.us/my.php?image=h2kt1.png    and     http://img367.imageshack.us/my.php?image=h1ve2.png
23:52:54 <pumpkin> bah, can ghci not be parallel? :P
23:53:04 <Cale> pumpkin: it can...
23:53:15 <Cale> pumpkin: Maybe run with +RTS -N2 ?
23:53:43 * ski_ sees no haskell logos ..
23:54:19 <Cale> The Î» is kinda backwards in the second one ;)
23:54:21 <teko> on the right side ?
23:54:25 <teko> ye
23:54:26 <Megzlna> "If f doesn't need its second parameter (the recursive call to foldr), that is, if it doesn't pattern match against it,"
23:54:40 <Megzlna> sjanssen, ski_: k, makes some sense
23:54:46 <Megzlna> Cale: What did you mean by that?
23:54:47 <pumpkin> ooh haskell is looking for a new logo?
23:54:48 <Megzlna> example?
23:55:03 <Megzlna> a simplest possible example (not involving foldl)
23:55:04 <teko> ye pumpkin
23:55:08 <pumpkin> (thank god)
23:55:11 <teko> lol
23:55:12 <ski_> Megzlna : consider `foldr const 42 [0,1,2]'
23:55:31 <sjanssen> > foldr (||) (True : repeat False)
23:55:32 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Bool]'
23:55:33 <ski_> Megzlna : this simplifies to `const 0 (foldr const 42 [0,1,2])', right ?
23:55:39 <Megzlna> if it doesn't pattern match against it....
23:55:46 <sjanssen> > foldr (||) False (True : repeat False)
23:55:47 <lambdabot>   True
23:55:49 <Cale> > foldr (\x xs -> if x > 10 then [] else x:xs) [] [1..]
23:55:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:56:01 <Megzlna> @src ||
23:56:01 <lambdabot> True  || _ =  True
23:56:01 <lambdabot> False || x =  x
23:56:24 <Cale> sjanssen's example is good :)
23:56:24 <sjanssen> Megzlna: notice how (||) only used the second argument if the first is False?
23:56:40 <Megzlna> yea
23:56:42 <sjanssen> (usually called "short-circuiting" in other languages)
23:57:44 <Cale> > foldr (\x xs -> if x > 10 then 0 else x + xs) 0 [1..]
23:57:45 <lambdabot>   55
23:57:59 <Cale> (of course, you would normally use takeWhile to do this)
23:58:13 <pumpkin> hmm, my parMap isn't going above 100%
23:58:21 <pumpkin> maybe r0 is the wrong strategy
23:58:26 <sjanssen> pumpkin: did you pass +RTS -N2 ?
23:58:28 <pumpkin> yup
23:58:31 <pumpkin> but this is in ghci
23:59:03 <sjanssen> hmm
23:59:22 <sjanssen> ghci might tie up one of those capabilities, try +RTS -N4
23:59:41 <pumpkin> ah
