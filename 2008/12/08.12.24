00:00:00 <sjanssen> or it might even decide semi-randomly
00:00:05 <strht> not literally pop, of course
00:00:11 <strht> or push, even...
00:00:27 <conal> sjanssen: yep.  when the precondition is not satisfied.
00:01:07 <conal> sjanssen: another example: parallel reduce for associative functions
00:01:16 <conal> s/reduce/fold
00:02:02 <mbz> are fudgets still alive?
00:02:47 <conal> sjanssen: parallel fold has the same property as unamb of semantic determinacy when the precondition is satisfied.
00:02:47 <sjanssen> conal: DPH does that, but retains determinism by treating the array as a binary tree
00:03:12 <mmorrow> conal: i have a repo that has a "race" equivalent that this discussion has just prompted me too start messing with again (i don't do any exception handling (which i now am going to fix)) http://moonpatio.com/repos/proc/
00:03:16 <conal> sjanssen: does it decide dynamically how to map the sequence onto a tree?
00:03:41 <mmorrow> race f g = runP (One (const f) :||| One (const g)) ()
00:03:49 <sjanssen> conal: statically
00:04:05 <drdo> How would i write something like "Foo a,b =>" ? Meaning i want both a and b to be instances of Foo.
00:04:06 <conal> sjanssen: based on machine info?
00:04:47 <porges> strht: I believe it would be the same as any other constructor (C a b), but for those details you'll have to ask someone else ;P
00:05:19 <porges> strht: although lists might be special-cased
00:05:33 <cads> strht, I think functions with pattern matching in general are tricky to compile to machine code. The meaning of the patterns you've specified are probably turned into a concrete block of tests that are applied to a functions arguments each time you call it
00:05:35 <conal> sjanssen: in any case, whether blessed or damned, please do keep thinking about how to fix the unamb implementation.
00:05:45 <sjanssen> conal: sure :)
00:05:49 <conal> thx :)
00:06:19 <sjanssen> conal: the shape of recursion that DPH uses is static, but it will dispatch worker threads to parts of that shape dynamically
00:06:59 <BeelsebobWork> heya conal -- is this discussion coming from the strange new issue in race?
00:07:13 <conal> BeelsebobWork: yes, sigh.
00:07:28 <mmorrow> mbz: i don't think they're being worked on, but i believe dmitry golubovsky (speling?) is using fudget ideas for yhcjs stuff
00:08:02 <drdo> guys? :S
00:08:26 <mmorrow> @type fronIntegral
00:08:27 <lambdabot> Not in scope: `fronIntegral'
00:08:30 <mmorrow> @type fromIntegral
00:08:31 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:08:38 <mmorrow> drdo: :)
00:08:50 <mmorrow> (Foo a, Foo b) =>
00:09:03 <drdo> thank you :)
00:09:05 <pumpkin> > fromIntegral 5 :: Int
00:09:06 <lambdabot>   5
00:09:09 <pumpkin> :D
00:09:21 <Gracenotes> pumpkin: critical success!
00:09:31 * pumpkin bows, thank you
00:09:43 <conal> BeelsebobWork: see the archive (http://tunes.org/~nef/logs/haskell/08.12.23).  Good stuff in there.  I think sjanssen has nailed a problem with compositional uses of unamb.
00:10:50 <mmorrow> pumpkin: in ghc all the fromIntegrals for base-provided types are implemented via rewrite RULES, so are guaranteed to be the most efficient way to convert (i found this very comforting when i found it out :)
00:10:50 <conal> mmorrow: your Proc stuff looks very related to unamb.
00:11:11 <mbz> mmorrow: thanks for the hint.
00:11:30 <pumpkin> mmorrow: ooh, fun
00:12:15 <mmorrow> conal: totally. i just got excited about it again seeing unamb'd implem. i initially got the idea to write Proc after seeing quicksilver's paste of a version of his reactive implem :)
00:12:25 <mmorrow> *unamb's
00:13:00 <conal> mmorrow: oh!  no wonder.  it looks very nice.
00:13:13 <mmorrow> conal: i'm just starting to realize what reactive is all about too, very exciting
00:13:15 <mmorrow> conal: heh
00:13:26 <conal> :) :)
00:13:53 <sjanssen> conal: do you have a test suite for unamb?
00:13:53 <BeelsebobWork> conal: I'm not certain how v ever becomes bottom -- can you explain?
00:14:46 <sjanssen> BeelsebobWork: v is an unsafePerformIO, which we interrupt, turning it into _|_
00:15:13 <BeelsebobWork> oh hang on -- I think I'm reading the wrong v -- do you mean v in the def of race?
00:15:47 <sjanssen> BeelsebobWork: v in "f v = (v `unamb'` 1) `seq` v"
00:16:38 <BeelsebobWork> but v there is an argument of f -- it's very explicitly 1 in the inner app, and hence very explicitly 1 in the outer one -- I don't see any unsafePerformIO involved in *that* v's computation?
00:16:42 <BeelsebobWork> or am I missing something?
00:16:57 <mbz> @src trace
00:16:57 <lambdabot> trace string expr = unsafePerformIO $ do
00:16:57 <lambdabot>     hPutStrLn stderr string
00:16:57 <lambdabot>     return expr
00:18:05 <sjanssen> BeelsebobWork: look at the outer application of 'f' in 'test'
00:18:18 <sjanssen> BeelsebobWork: v = f 1, which uses unamb, which uses unsafePerformIO
00:18:53 <BeelsebobWork> yeh -- but f 1 itself is not an unamb -- the unamb is before the seq, so it gets "ignored", no?
00:19:28 <BeelsebobWork> oh, but it also doesn't get reducted to WHNF
00:19:29 <BeelsebobWork> I see
00:19:50 <BeelsebobWork> cool, I think I see what you're getting at now
00:22:25 <sjanssen> http://hpaste.org/13310 unamb using par.  Comments?
00:22:32 <sjanssen> that code makes me feel dirty
00:22:32 * BeelsebobWork ponders if two birds can be killed with one stone -- I had a version that caught exceptions in the threads, and passed them up via Eithers -- that would stop them erroring out, as well as providing a "fast" bottom when unamb would currently non-terminate
00:23:16 <BeelsebobWork> sjanssen: what's the () for?
00:23:41 <sjanssen> BeelsebobWork: evaluate (x `par` y) means spark x, evaluate y right now
00:23:47 <BeelsebobWork> oh, duh
00:24:15 <sjanssen> this code is a whole heap of subtlety :)
00:24:32 <conal> and how!
00:26:01 * BeelsebobWork ponders if par is really correct -- doesn't it need deepPar?
00:26:14 <BeelsebobWork> but that would reintroduce the termination bug
00:26:23 <conal> what's deepPar?
00:26:26 <sjanssen> BeelsebobWork: what is deepPar?
00:26:38 <BeelsebobWork> a made up name for a function which reduces to normal form
00:26:39 <BeelsebobWork> not WHNF
00:26:52 <sjanssen> nah, WHNF is enough
00:26:53 <mmorrow> , 1 `unamb` 2
00:26:55 <lunabot>  1
00:26:59 <mmorrow> :)
00:27:04 <mmorrow> , undefined `unamb` 2
00:27:07 <lunabot>  2
00:27:08 <BeelsebobWork> bad mmorrow
00:27:08 <sjanssen> WHNF causes unsafePerformIO to execute
00:27:15 <mmorrow> BeelsebobWork: heh
00:27:21 <conal> BeelsebobWork: lub uses unamb repeatedly.
00:27:32 <BeelsebobWork> conal: ah, course, yes
00:27:39 <BeelsebobWork> actually, that second one is fine -- as far as unamb is concerned mmorrow
00:28:01 <mmorrow> BeelsebobWork: i like that it is
00:28:48 <porges> , 1 `unamb` 2
00:28:51 <lunabot>  1
00:28:59 <conal> naughty, naughty
00:29:01 <BeelsebobWork> conal: incidentally (related to stuff from ages ago), did you see the discussion here yesterday about needing something inbetween data and newtype to make fmap on tuples behave as expected
00:29:04 <mmorrow> , (\v -> (v `unamb` 1) `seq` v) 42
00:29:06 <lunabot>  42
00:29:12 <conal> BeelsebobWork: no
00:29:31 <mmorrow> , let v = 42 in v `unamb` 1) `seq` v
00:29:33 <lunabot>  luna: parse error on input `)'
00:29:37 <mmorrow> , let v = 42 in (v `unamb` 1) `seq` v
00:29:39 <lunabot>  42
00:29:42 <BeelsebobWork> conal: the realisation was that we need a kind of newtype that can have n-arry constructors, so that newtype (a,b) = (a,b)
00:29:45 <solrize> http://pdos.csail.mit.edu/scigen/      hahahahahahahhaa
00:29:50 <BeelsebobWork> then _|_ really does equal (_|_,_|_)
00:30:00 <BeelsebobWork> and you can get proper lazyness in fmap
00:30:14 <mmorrow> i think you're refering to (#,#)
00:30:35 <mmorrow> (or at least, that's how unboxed (n-)tuples behave)
00:31:37 <conal> sjanssen: there are no kills in your unamb'.
00:31:49 <conal> sjanssen: so redundant work would get done, right?
00:31:50 <mmorrow> oh, that was unamb'
00:32:14 * mmorrow was wondering why that didn't do what i thought it was going to
00:32:41 <BeelsebobWork> mmorrow: the bug was introduced in a new version of unamb
00:32:45 <BeelsebobWork> that kills more threads
00:32:53 <BeelsebobWork> s/bug/error/
00:32:59 * BeelsebobWork must keep slapping self for that
00:33:16 <mmorrow> ahhh, ok. is there a darcs repo for the newer version?
00:33:24 <sjanssen> conal: it depends on whether GHC garbage collects unreferenced sparks.  I don't know whether it does
00:33:27 <BeelsebobWork> yeh, it's on c.h.o
00:33:43 * mmorrow updates lunabot with that one
00:33:58 <BeelsebobWork> sjanssen: I was under the impression that par had the same semantics as seq -- i.e. the thing on the left is gonna get evaluated whether it's wanted on the right or not
00:34:21 <sjanssen> BeelsebobWork: par only sparks the computation, it doesn't demand it
00:34:33 <sjanssen> a smart implementation would discard the spark if it is not referenced anywhere else
00:34:58 <BeelsebobWork> sjanssen: oh? nice
00:35:13 <BeelsebobWork> and yeh, that would be nice -- I wonder if we can get a reliable test case for that
00:35:22 <mgsloan> sjanssen: with fingertree.. would it possible for measure to return a function, such that a context may be provided, and still have caching? or would that feature become useless?
00:35:27 <sjanssen> conal: oh, and this version doesn't work at all if the threaded RTS is off
00:35:52 <conal> sjanssen: is par a no-op without -threaded ?
00:36:14 <sjanssen> BeelsebobWork, conal: the first test case I tried shows that stale sparks are not discarded on GHC 6.8.3
00:36:25 <sjanssen> conal: yes, par is a no-op without -threaded
00:36:37 <sjanssen> so unamb will fail with "thread blocked indefinitely"
00:36:38 <conal> sjanssen: how did you test stale sparks?
00:37:23 <sjanssen> print (unamb slowThing evenSlowerThing) >> getLine
00:37:26 <sjanssen> with +RTS -N2
00:37:55 <mmorrow> , let v = 42 in (v `unamb` 1) `seq` v
00:37:58 <lunabot>  42
00:37:58 <sjanssen> watch CPU usage while GHC is executing getLine -- ideally it should go to zero
00:38:17 <mmorrow> hmm, so unamb' wasn't refering to the unamb in the darcs repo then i take it
00:38:29 <sjanssen> unamb' (last [1 :: Int ..]) (last [1 .. 2^26]) -- is exactly what I used
00:38:31 <mmorrow> , undefined `unamb` undefined
00:38:39 <conal> mmorrow: right.  see http://hpaste.org/13310
00:38:40 <sjanssen> mmorrow: no, just a variant in the source file I'm hacking on
00:38:51 <mmorrow> sjanssen: ahhh.
00:40:31 <sjanssen> conal: yeah, par is just not going to work
00:40:46 <conal> sjanssen: too bad.  interesting idea about discarding unused sparks.  reminds me of henry baker's paper "the incremental garbage collection of processes"
00:41:01 <swiert> Anyone here have experience with foreign exports?
00:44:26 <lunabot>  user interrupt
00:45:25 <swiert> I'd like to compile a C file, linking the .o file that ghc produces, but this gives me undefined symbols like stg_ap_pp_fast. I suspect I need to tell gcc where some files reside, but I'm not sure what I'm missing here.
00:47:27 <mmorrow> whoa, this is super odd (possibly a bug in who-know-where):
00:47:32 <jkff> Maybe you better compile your .c file into an .o and link it using ghc instead of gcc? (just a random guess, maybe I'm talking nonsense)
00:47:34 <mmorrow> so if i run
00:47:42 <mmorrow> , let v = 42 in (v `unamb'` 1) `seq` v
00:47:52 <mmorrow> the /bot/ gets frozen
00:48:02 <mmorrow> (but the evaluator is in a separate process)
00:48:14 <mmorrow> now i ^C in the bot's terminal
00:48:22 <mmorrow> shit
00:48:33 <mmorrow> , let v = 42 in (v `unamb'` 1) `seq` v
00:48:41 <mmorrow> , 42
00:48:43 <swiert> jkff: yeah - the problem is the C stuff that calls Haskell has a pretty complicated build process. I'm trying to avoid using ghc to compile the entire thing.
00:48:46 <lunabot>  user interrupt
00:48:48 <lunabot>  42
00:48:49 <mmorrow> there
00:48:59 <mmorrow> i don't know how that could even happen
00:49:10 <jkff> What about running ghc -v on your .o and looking at with what arguments does it call ld?
00:49:21 <jkff> I mean, on your haskell .o
00:49:23 <mmorrow> also, this seems to freeze the bot as well (and ^C just exits)
00:49:29 <mmorrow> , undefined `unamb` undefined
00:49:33 <swiert> jkff: good idea. thanks
00:49:34 <mmorrow> , 42
00:51:11 <porges> lol
00:51:13 <conal> BeelsebobWork: ping
00:51:17 <BeelsebobWork> pong
00:51:47 <conal> BeelsebobWork: going back to my old unamb/race def, the joinE/mappend bug seems to be gone.
00:52:00 <conal> BeelsebobWork: with the new time type
00:52:11 <BeelsebobWork> awesome :D
00:52:16 * BeelsebobWork checks his examples
00:52:41 <BeelsebobWork> oh, you haven't pushed yet?
00:53:21 <conal> BeelsebobWork: no, not yet.  i'm not done testing.  i've checked on some close-up examples i used for debugging.
00:53:30 <BeelsebobWork> :)
00:53:46 <conal> BeelsebobWork: and i'm catching and ignoring a bunch of NonTermination exceptions that i don't understand.
00:53:55 <BeelsebobWork> :/
00:54:15 <conal> BeelsebobWork: yeah.
00:55:58 <conal> BeelsebobWork: probably the ghc RTS is getting tricked into thinking there are black holes.
00:56:28 <BeelsebobWork> I'm not sure why though -- I thought the black hole detection was *very* conservative
00:56:48 <conal> BeelsebobWork: my understanding is pretty sketchy at this point.
00:56:56 <BeelsebobWork> hmm, okay
00:58:50 <conal> some progress.  but my failure to terminate child threads may be all that keeps unamb working.  so it's not really a good solution.
00:59:00 <mmorrow> i just found out what's happening
00:59:06 <BeelsebobWork> mmorrow: ?
00:59:25 <mmorrow> so undefined `unamb` undefined  never terminates, but also doesn't use any cpu
00:59:28 <mmorrow> it just hangs
00:59:40 <mmorrow> and my rlimits are for cputime and mem usage
00:59:58 <BeelsebobWork> yep, that's correct semantics
01:00:04 <mmorrow> and the bot is hGetLine'ing the response from the evaluator
01:00:08 <BeelsebobWork> although I was working on a patch to try and fix that
01:00:14 <mmorrow> so i need to time the evaluator out
01:00:37 <mmorrow> i have some sandbox code that'll do this for me. i guess now's the time to actually use it ;)
01:02:07 <mmorrow> here's that sandbox code if anyone is interested: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=445
01:03:03 <mmorrow> also, i'm not sure if i'm using block/unblock correctly in that code..
01:03:52 <mmorrow> (and i'll have to createPipe :: IO (Fd,Fd) so the child (OS) proc can communicate with the parent or something)
01:04:39 <mmorrow> oh, apparently the "fix id" crashing ghc bug is fixed in HEAD
01:05:12 <mmorrow> (which is one of the reasons an entirely new OS proc is needed for the evaluator)
01:05:27 <mmorrow> *.. crashing ghci ...
01:07:20 <mmorrow> nice. this happened once before (the bot apparently just hanging) and i couldn't figure out what had happened for the life of me. someone must have eval'ed an exp that resulted in non-termination + zero cpu/mem usage.
01:08:08 <mmorrow> man, lunabot was 2 days away from having a month of uptime too :(
01:11:35 <luqui> how do I enable optimization in a cabal file?
01:11:38 <conal> mmorrow: did you try undefined `unamb` undefined in ghci or compiled?  if compiled, i'd expect it to terminate, thanks to BlockedOnDeadMVar
01:11:46 <sjanssen> luqui: -O is on by default
01:11:56 <luqui> ok, that should be fine
01:12:00 <sjanssen> luqui: you can force that with ghc-options: -O, but there's no point, really
01:12:02 <dons> ghc-options: -O2
01:12:03 <lambdabot> dons: You have 14 new messages. '/msg lambdabot @messages' to read them.
01:12:10 <dons> if you want a) spec constr.
01:12:15 <dons> also, -funbox-strict-fields
01:12:19 <dolio> If you do that, hackage will complain at you. :)
01:12:21 <dons> (should be the default at -O)
01:12:34 <dons> i'll lobby for -funbox-strict-fields by default
01:12:48 <mmorrow> conal: i haven't, but lunabot's eval is 99% the same as in ghci (modulo some "minor" (in this case perhaps major) exception handling differences). i'm gonna try.
01:13:10 <dolio> Not {-# UNPACK #-}?
01:13:22 <mmorrow> this might help me catch a bug in my bot + a bug in my eval :)
01:13:52 <luqui> hey conal, just uploaded unamb-custom-0.10.  try it out! :-)
01:14:08 <conal> luqui: will do!
01:14:15 <BMeph_> Is it possible to unbox an Integer? :)
01:14:35 <b_jonas> no, it's a polymorphic composite thingy
01:14:40 <b_jonas> @src Integer
01:14:41 <lambdabot> data Integer = S# Int#
01:14:41 <lambdabot>              | J# Int# ByteArray#
01:15:28 <BMeph_> luqui: Still getting arch set up. ;)
01:15:29 <mmorrow> conal: undefined `unamb` undefined    hangs in ghc-6.10.0.20080927's ghci (lunabot's)
01:15:44 <quicksilver> dons: spec-constr is O2 only? I thought it was pretty uncontroversial.
01:15:53 <conal> mmorrow: for me as well.  but throws BlockedOnDeadMVar when compiled.
01:16:04 <porges> >> === *>, right?
01:16:14 <quicksilver> yup
01:16:24 <quicksilver> although *> is defined on Applicative, which is slightly mor egeneral.
01:16:27 <quicksilver> but it's the same idea.
01:16:33 <mmorrow> conal: ah. it must be related to the mess of exception handling in interpreted code.
01:16:37 <pumpkin> is there a === defined?
01:16:41 <pumpkin> just out of curiosity :P
01:16:46 <porges> so really instead of sequence and sequence_, we should have sequence (which is sequence_) and sequenceM
01:16:49 <b_jonas> @src *>
01:16:49 <lambdabot> (*>) = liftA2 (const id)
01:16:58 * mmorrow is still trying to figure out exactly what's being thrown/handled where in interp code
01:17:01 <quicksilver> porges: no.
01:17:02 <dolio> Using an oracle to decide function equality, you mean?
01:17:10 * porges cries
01:17:12 <quicksilver> porges: the _ indicates the lack of return value.
01:17:13 <ivanm> dons: can darcs X11 have its version bumped please?
01:17:21 <mmorrow> conal: this is a good lead though
01:17:38 <quicksilver> pumpkin: there is reallyUnsafePtrEquality#
01:17:47 <porges> yeah but sequence is defined in terms of (>>), so it could be Arrow-based instead
01:17:54 <quicksilver> pumpkin: if you do that, though, strange demons will fly out of your nose.
01:17:57 <porges> and then we just have an M version like with everything else :)
01:17:59 <pumpkin> dolio: me? if I had an oracle implementation in my computer I'd be very happy ;)
01:18:02 <dons> ivanm: mmm.
01:18:06 <dolio> :)
01:18:08 <quicksilver> porges: sequence cannot be defined in terms of >>
01:18:09 <pumpkin> quicksilver: that sounds kinda fun
01:18:16 <porges> sequence_ I meant
01:18:19 <quicksilver> yes.
01:18:20 <ivanm> it's a bit weird where the version bump happens _outside_ of version control ;-)
01:18:21 <conal> mmorrow: in undefined `unamb` undefined, both threads exit without writing to the mvar, so the takeMVar will block.
01:18:23 <quicksilver> so Foldable
01:18:26 <quicksilver> see Foldable
01:18:30 <quicksilver> which defines a general sequence_
01:18:32 <dolio> , [$ty| reallyUnsafePtrEquality# |]
01:18:37 <mmorrow> heh
01:18:38 <quicksilver> for applicatives over a foldable.
01:18:47 <mmorrow> dolio: oh, i forgot to restart lunabot
01:19:13 <dons> ivanm: yes.
01:19:20 <dons> ivanm: oh, i think its just not pushed, due to brokenn darcs.
01:19:21 <pumpkin> can I get this lambdabot to join other irc networks? or do I need to host it myself?
01:19:21 <mmorrow> conal: hmm, so then maybe BlockOnDeadMVar/whatever isn't being handled for bytecode?
01:19:31 <ivanm> dons: ahhhhh
01:19:35 <porges> quicksilver: cool, that's what I've been looking for
01:19:39 <ivanm> excuses, excuses ;-)
01:19:45 <conal> mmorrow: apparently.  which is inconvenient for me, as i keep having to kill & restart ghci.
01:20:01 <porges> quicksilver: was looking for a generaliztion of sequence to something other than lists
01:20:10 <quicksilver> porges: Traversable for sequence
01:20:15 <quicksilver> porges: Foldable for sequence_
01:20:56 <b_jonas> ah
01:21:07 <b_jonas> so that's what Traversable and Foldable are
01:21:10 <b_jonas> good to kno
01:21:11 <b_jonas> w
01:21:22 <quicksilver> Traversable is a kind of dual to Applicative
01:21:32 <quicksilver> Applicative is the most general kind of thing you can sequence
01:21:43 <quicksilver> Traversale is the most general structure over which you can sequence
01:22:28 <mmorrow> conal: totally. also inconvenient is how "fix id" freezes ghci and will consume all memory unless you ^Z and kill -9 :/
01:22:40 <conal> mmorrow: yow!
01:22:41 <mmorrow> (although i think this has been fixed)
01:22:47 <b_jonas> makes sense
01:23:10 <mmorrow> conal: i think it had to do with not blackholing the thunk in bytecode or something
01:23:16 <b_jonas> I'm not sure that makes them dual, but maybe in some sense yes
01:23:27 <mmorrow> because that'd immediately be caught and result in <<loop>> in compiled code
01:23:38 <baaba> :t fix id
01:23:39 <lambdabot> forall a. a
01:23:59 <pumpkin> > fix id 5
01:24:00 <lambdabot>   * Exception: stack overflow
01:24:05 <pumpkin> nice
01:24:06 * mmorrow tried to mess with Interpreter.c for this but quickly was thwarted
01:24:18 <mmorrow> , fix id
01:24:21 <lunabot>  luna: out of memory (requested 2097152 bytes)
01:24:25 <luqui> mmorrow, I didn't believe you, because I thought I had done that before.  Turns out that Ctrl-Z, kill -9 is a reflex for me...  =P
01:24:41 <mmorrow> luqui: quickdraw mcgraw!
01:24:45 <mmorrow> :)
01:25:18 <mmorrow> pumpkin: i think it just stack overflow in 6.8, but in <= 6.10.1 it is unstoppable
01:25:27 <pumpkin> :o
01:25:27 <mmorrow> (except with rlimits)
01:25:29 <pumpkin> unstoppable!
01:25:32 <pumpkin> I hate those
01:25:41 <mmorrow> (except with ^Z kill -9 of course)
01:25:46 <mmorrow> me too
01:25:47 <pumpkin> what is the prime cause of unstoppableness?
01:25:52 <luqui> it's not unstoppable.  it's just uninterruptable
01:26:02 <mmorrow> yes, that's a better way to say it
01:26:05 <pumpkin> well, whatever it is that shows ^C^C^C^C instead of my shell
01:26:16 <pumpkin> and slows my computer to a standstill
01:26:21 <pumpkin> (when it's eating memory)
01:26:23 <b_jonas> > fix id 5
01:26:25 <lambdabot>   * Exception: stack overflow
01:26:36 <mmorrow> but if "you" are in the same haskell runtime as the fix id, it's essentially unstoppable
01:26:46 <conal> luqui: i'm looking at UnambCustom.Unamb.  don't you get BlockedOnDeadMVar ?
01:26:47 <mmorrow> like if you were a bot
01:26:55 <mmorrow> and your eval was in your proc
01:27:02 <pumpkin> mmorrow: I get it all the time with ghci :(
01:27:09 <mmorrow> or ghci
01:27:16 <mmorrow> bummer
01:27:24 <luqui> conal, when?
01:27:43 <conal> luqui: when you whnf never, in compiled code
01:28:04 <luqui> conal, o maybe.  I hadn't tried that.
01:28:16 <luqui> I have only been running interpreted
01:28:34 <conal> luqui: ghci doesn't throw BlockedOnDeadMVar
01:28:52 <mmorrow> , [$ty| reallyUnsafePtrEquality# |]
01:29:01 <lunabot>  luna: Exception when trying to run compile-time code:
01:29:07 <mmorrow> hmm, i guess there's no harm in including that guy
01:29:15 <mmorrow> (?)
01:29:29 * mmorrow does it
01:29:30 <conal> luqui: does your library handle error-ful values?  i'm finding them very handy.
01:29:36 <luqui> conal, not yet
01:29:50 <conal> luqui: do you think it'll be any difficulty?
01:30:03 <conal> luqui: and once you do, you can use never = undefined .
01:30:13 <luqui> ahh good call
01:30:19 <luqui> I think it'll be pretty easy
01:30:24 * luqui tries
01:31:28 <conal> luqui: i'm currently catching 'ErrorCall _' and BlockedOnDeadMVar.  also NonTermination but probably only as a bug work-around.
01:31:57 <mmorrow> , [$ty| reallyUnsafePtrEquality# |]
01:32:02 <lunabot>  luna: Exception when trying to run compile-time code:
01:32:05 <mmorrow> gah
01:32:16 <conal> luqui: pattern-match failure would be nice also.  then one can define partial functions pretty directly.  although i like to compile with warnings for incomplete-patterns
01:32:56 <luqui> it's hard for me to say what "correct" values to catch are
01:33:05 <conal> for me also
01:33:06 <luqui> my theorist wants to catch every value of _|_... but that seems a bit impractical
01:33:13 <mmorrow> ah, it's choking trying to parse an ident with '#'
01:33:32 <dolio> @type 1#
01:33:33 <lambdabot> GHC.Prim.Int#
01:34:10 <quicksilver> mmorrow: -XMagicHash
01:34:14 <quicksilver> (or -fglasgow-exts)
01:34:18 <dolio> Your theorist doesn't tell you that's impossible?
01:34:33 <quicksilver> maybe luqui needs to upgrade his theorist?
01:35:05 <dolio> mmorrow: What are you using to parse? haskell-src-exts?
01:35:14 <mmorrow> quicksilver: it's getting parsed in an i-can't-recall-but-bootleg-way
01:35:17 <cjs> Any thoughts on this error? http://hpaste.org/13311
01:35:27 <b_jonas> maybe they're legal theorists, not mathematician theorists
01:35:44 <mmorrow> dolio: yes, haskell-src-exts + some code that translates that to TH AST now that i think about it
01:35:52 <cjs> Ought it not be using a -I option to bring in the ghc include dir?
01:36:13 <dolio> Does that not do magic hash?
01:36:28 <mmorrow> ohh, actually it's not that i don't think
01:36:38 <mmorrow> i think it has to do with the return type being Int#
01:36:53 <dolio> Hmm.
01:37:04 * mmorrow makes a wrapper instead of hunting for the probably-buried-way-deep problem
01:37:54 <dolio> , ''Int#
01:37:56 <lunabot>  luna: Not in scope: `#'
01:38:33 <dolio> , src ''Int
01:38:40 <lunabot>  Killed.
01:38:47 <mmorrow> i'm rebuilding it now..
01:38:52 <cjs> Hm. Nobody's seen this with ghci 6.10.1?
01:38:53 <conal> luqui: btw, i think i've finally fixed that old problem with event mappend (merge) that was too strict with the MaxBound optimization and space-leaky without.  my solution is to use unamb, so it can take as long as it likes to test for MaxBound but still make progress in the non-optimized case.  i also replaced MaxBound (Improving t) with Improving (MaxBound t).
01:39:42 <conal> lunabot: s/MaxBound/AddBounds/g
01:39:45 <mmorrow> , [$ty|reallyUnsafePtrEquality|]
01:39:49 <conal> luqui: ^^
01:39:51 <lunabot>  forall a . a -> a -> Bool
01:39:55 * conal is sleepy
01:40:07 <luqui> conal, nice :-)
01:40:09 <mmorrow> , let x = 42; y = x in reallyUnsafePtrEquality x y
01:40:14 <lunabot>  True
01:40:15 <conal> luqui: that outer AddBounds was preventing partial information from getting out.
01:40:18 <luqui> oh, and the error catching suggestion worked like a charm :-)
01:40:18 <mmorrow> sweet
01:40:24 <mmorrow> , src ''Int
01:40:31 <lunabot>  data Int = I# Int#
01:40:44 <quicksilver> conal: this flow of partial information is the key, however you model it.
01:40:48 <dolio> Did you wrap that manually?
01:40:55 <conal> quicksilver: it sure is.
01:40:58 <conal> luqui: great!  tomorrow i'll try switching over from my unamb to yours.
01:41:01 <dolio> Or is there some other module where it's wrapped?
01:41:14 <quicksilver> conal: I'm pretty sure I need to change my future interface so that noblockingReadFuture returns a "new" Future in the case of no result
01:41:17 <maltem> , let x = 5; y = undefined in reallyUnsafePtrEquality x y
01:41:25 <lunabot>  False
01:41:27 <luqui> conal, heheh we will see :-).  I am in no way confident that mine is anywhere near correct =P
01:41:27 <quicksilver> conal: a "new" Future which already contains the information that nothing occurred up to time X
01:41:48 <luqui> schedulers are complicated...
01:41:56 <conal> luqui: thanks for the warning. :)
01:41:59 <quicksilver> conal: this already works fine for positive occurrences of Reactives, because the concrete 'Stepper' holds the positive information in place.
01:42:10 <conal> luqui: i like the sound of your scheduling policy.
01:43:00 <mmorrow> dolio: yeah, you're right. the error was with haskell-src-exts and Int#
01:43:28 <mmorrow> parseExp "() :: a -> a -> Int#" -- literally the code that was failing
01:43:58 <mmorrow> hackery-to-parse-a-type++
01:44:19 * conal succumbs to weariness and goes to bed.
01:44:25 <conal> catch you all later.
01:44:29 <mmorrow> night
01:44:38 * ivanm passes conal a bottle of pure caffeine
01:44:39 <ivanm> ;-)
01:44:42 <drdo> Is there VTY documentation anywhere?
01:44:47 <conal> :)
01:44:49 <dolio> Maybe it'll get fixed with the lhc folks looking to use it.
01:44:58 <dolio> Although I don't think jhc uses #.
01:45:00 <mmorrow> dolio: yeah, i wrapped it manually
01:45:32 <mmorrow> dolio: that's probably fixed (guessing) in the recent overhaul of src-exts
01:45:36 <b_jonas> drdo: yes, for linux it's in the manpages console_codes and console_ioctl
01:45:40 <b_jonas> or not that vty?
01:45:42 <ivanm> is the Int# stuff in the report or ghc-specific?
01:45:51 <dolio> I think it uses some other special character for its primops.
01:46:13 <int-e> ivanm: it's ghc specific.
01:46:24 <ivanm> *nod*
01:46:34 <drdo> b_jonas: it is the terminal interface VTY
01:46:40 <b_jonas> drdo: then what I said,
01:46:50 <mmorrow> dolio: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=675
01:46:56 <b_jonas> the two manpages I listed are for the calls specific to linux console
01:46:58 <ivanm> does this mean that all the high-performance libs/apps are ghc-specific and not easily portable to other compilers when they get finished?
01:47:15 <drdo> b_jonas: well, why would i bother using VTY then?
01:47:34 <dolio> Yeah, I know how you would wrap it. :)
01:47:47 <dolio> I just wasn't sure if there were some existing GHC module that already did.
01:47:54 <b_jonas> the ones for any virtual terminal are the portable ones are documented in glibc info, the unportable ones in tty_ioctl, and some stuff in the terminal emulators' docs (screen, urxvt)
01:47:59 <dolio> Like there's an "unsafeCoerce" in Unsafe.Coerce.
01:48:09 <mmorrow> dolio: pragma's for one have been added to src-exts. also it looks like the AST has been redone to be (i haven't checked to be sure, but it looks like it) the same one as used by ghc's HsSyn
01:48:10 <dolio> Instead of the unsafeCoerce# in wherever.
01:48:25 <b_jonas> drdo: it's a bit broad topic so maybe tell more of what you want
01:48:26 <mmorrow> i think it's just
01:48:33 <mmorrow> unsafeCoerce = unsafeCoerce#
01:48:42 <b_jonas> drdo: do you just want one of those curses-like high-level libraries (but saner than curses)?
01:48:43 <dolio> Well, yeah. That's a less exciting wrapper. :)
01:48:52 <mmorrow> with some #if __NHC__ ... blah stuff
01:48:54 <dolio> But it makes it 'portable'. :)
01:48:59 <mmorrow> yeah, heh
01:49:21 <mmorrow> with copious CPP macro debauchery
01:49:32 <drdo> b_jonas: yup
01:50:01 <quicksilver> potentially portable at least.
01:50:02 <mmorrow> dolio: that totally be nice if that was a standard wrapper for sure
01:50:16 <mmorrow> (.==.) :: a -> a -> Bool
01:50:20 <mmorrow> hmm
01:50:24 <quicksilver> although I think you can imagine other ways of implementing haskell for which unsafecoerce could not be expected to have the semantics it has in GHC
01:50:27 <dolio> Yeah. We definitely want to encourage use of reallyUnsafePtrEquality.
01:50:50 <b_jonas> drdo: I can't really help much then. there are a few of those in C, but I've no idea which one is really the best and I don't know of existing wrappers for haskell either
01:51:08 <mmorrow> dolio: hehe
01:51:12 <drdo> b_jonas: which few for C are there?
01:51:28 <dolio> Oh, I guess jhc just uses underscore suffixes.
01:51:40 <dolio> "data Char = Char Char__"
01:51:49 <luqui> wow!  I want to play with this!   http://users.bigpond.net.au/d.keenan/Lambda/
01:51:51 <dolio> Suffices?
01:51:52 <mmorrow> quicksilver: hmm, what do you have in mind
01:51:55 <luqui> (just look at the filmstrips)
01:52:34 <mmorrow> quicksilver: (i'm thinking of the (ghc semantics at least) to be "this type is whatever you want it to be")
01:52:49 <mmorrow> "you" := the type inferer
01:52:56 <cjs> How might I find out, programatically, where the ghc include directory is located?
01:52:57 <dolio> mmorrow: Well, what happens when you look inside?
01:52:59 <mgsloan> if I have some sort of complex
01:53:12 <dolio> When you coerce a Float to an Int, what kind of bits do you get?
01:53:27 <luqui> quicksilver, perhaps.  though the existence of GHC.Any is nice, and such would be very nice for any implementation of unsafeCoerce.
01:53:33 <b_jonas> drdo: for C there's ncurses (which misuses C namespace like crazy) and there's s-lang (http://www.jedsoft.org/ ; is a bit strange and wants to do everything in one library),
01:53:35 <dolio> That's potentially implementation specific, at least.
01:53:39 <b_jonas> and probably more I don't know of
01:53:41 <mmorrow> dolio: well, that's why it's called unsafe
01:53:50 <mmorrow> dolio: ohh, i see what you're saying
01:53:57 <b_jonas> drdo: there are ncurses ports for windows and slang has windows built in so both are portable
01:54:06 <mgsloan>  if I have some sort of complex "context" object stored in a bunch of objects - the identical, unchanged object - that's equivalent to having a bunch of pointers to a single object, right?
01:54:09 <mmorrow> yeah, it's undefined behavior in that case
01:54:12 <drdo> I don't care about non-POSIX to be honest
01:54:14 <drdo> :)
01:54:15 <b_jonas> drdo: but I just don't have much experience with these to tell which one of them is how good
01:54:26 <luqui> however I can certainly imagine a "compiled garbage collector" which relies on static information, in which it would be impossible to implement GHC.Any
01:54:42 * luqui ponders.  compiled garbage collector, eh?  sounds spiffy.
01:54:51 <drdo> b_jonas: Is there  something i can read on interfacing Haskell with C?
01:55:04 <quicksilver> mmorrow: as a particular example, you can unsafeCoerce (length :: [a] -> Int) into (length :: [Char] -> Int)
01:55:18 <quicksilver> mmorrow: because GHC has a parametric representation of parametric polymorphism.
01:55:28 <ivanm> drdo: which way? Haskell using C, or C using Haskell?
01:55:37 <ivanm> if the former, then FFI...
01:55:42 <quicksilver> mmorrow: another haskell implementation might represent (length :: [a] -> Int) as taking a type parameter explicitly.
01:55:48 <b_jonas> drdo: http://haskell.org/haskellwiki/Language_and_library_specification#Addenda_to_the_report
01:55:48 <quicksilver> mmorrow: a lambda-cube based implementation.
01:55:51 <drdo> ivanm: Haskell using C
01:55:59 <luqui> quicksilver, or even -- god forbid -- C++-template style
01:56:03 <b_jonas> drdo: but maybe look at hackage to see if there's already a good interface
01:56:03 <maltem> Fwiw a haskell drop-in for ncurses is vty (the other vty)
01:56:06 <mmorrow> quicksilver: by "can" do you mean "it will work" or "the type inferer will believe you"?
01:56:13 <quicksilver> mmorrow: it will actually work.
01:56:18 <drdo> b_jonas: apparently there is VTY and hscurses
01:56:23 <drdo> but both of them have no docs
01:56:24 <mmorrow> i'm leaving questions of actually working aside.
01:56:30 <mmorrow> ok, i see wht you're saying
01:56:31 <quicksilver> mmorrow: the GHC rep of (length :: [a] -> Int)  *IS* the GHC rep of (length :: [Char] -> Int)
01:56:37 <ivanm> drdo: IIRC, there was talk about that recently on the haskell reddit...
01:56:39 <b_jonas> drdo: and nanocurses
01:56:39 <maltem> drdo: oh ok
01:56:46 <b_jonas> drdo: you may have to read the curses c interface docs
01:56:55 <quicksilver> mmorrow: well if you only ever use unsafeCoerce to 'coerce away' to xists x . x
01:56:57 <drdo> i have used curses before
01:57:04 <drdo> so it is easier
01:57:07 <quicksilver> mmorrow: and 'coerce back' to the type it was in the first place
01:57:20 <quicksilver> mmorrow: then, that's a pretty safe idea for lots of implementations you can imagine.
01:57:29 <luqui> e.g. the code coq and agda generate
01:57:30 <quicksilver> mmorrow: but people do use it for other things than that.
01:57:32 <mmorrow> quicksilver: also, you can use it to get the same thing we use newtype for
01:57:37 <quicksilver> yup.
01:57:45 <quicksilver> there are more-and-less-plausible ways to use it
01:57:54 <quicksilver> they all make assumptions about implementation representation.
01:57:57 <quicksilver> but some make less than others.
01:58:00 <quicksilver> fewer.
01:58:02 <quicksilver> damn language.
01:58:07 <mmorrow> quicksilver: heh
01:58:26 <mmorrow> actually, i think the newtype one doesn't depend at all on the internal rep
01:58:32 <drdo> cool
01:58:38 <drdo> nanocurses has actual documentation
01:58:40 <luqui> it's okay. if english were perl, it would just say "oh, less, I know what you mean,
01:58:47 <mmorrow> y f = let z x = f (unsafeCoerce x x) in z z
01:58:48 <luqui> no!!!
01:58:57 <luqui> I was building a joke, but then I sent it before I thought of one.
01:59:04 <mmorrow> y f = let z x = f (unsafeCoerce x x); {-# NOINLINE x #-} in z z
02:00:42 <mmorrow> but all the other ones do definitely make assumptions about the implem rep
02:00:42 <cjs> Can anyone give me a clue on how to fix this type error? http://hpaste.org/13312
02:01:06 <mmorrow> crap, i meant
02:01:12 <mmorrow> y f = let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z
02:01:38 <quicksilver> cjs: Yes. You're using the new extensible exceptions.
02:01:56 <quicksilver> cjs: you need to specify which kind you're trying to catch.
02:02:01 <cjs> Right. Not that I particularly *want* to be using them. :-) I'm trying to upgrade to ghc 6.10.1.
02:02:11 <quicksilver> why are you trying to upgrade? ;)
02:02:16 <cjs> Oh, I see, so I have to catch different types of exceptions separately.
02:02:28 <quicksilver> there is an slightly-hidden way to catch all exceptions
02:02:30 <cjs> I need a newer cabal for my build system to work under Windows.
02:02:39 <quicksilver> slightly-hidden because it's generally not recommended.
02:02:46 <cjs> Hm. Do tell.
02:02:50 <luqui> how does one catch all exceptions?
02:03:23 <ivanm> luqui: with much magic! ;-)
02:03:23 <mmorrow> (\e -> ... (e :: SomeException) ... )
02:03:46 <drdo> I'm kind of new to haskell, why would something have type IO () -> IO ()?
02:03:57 <luqui> what about just exceptions that can be thrown from pure code (NonTermination, ErrorCall, ...)
02:03:59 <quicksilver> drdo: it takes an action (like a callback)
02:04:04 <mmorrow> @type \io -> forkIO io >> return ()
02:04:04 <ivanm> @hoogle IO () -> IO ()
02:04:05 <lambdabot> Not in scope: `forkIO'
02:04:05 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
02:04:05 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
02:04:05 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
02:04:22 <drdo> quicksilver: i see
02:04:36 <drdo> the particular one i'm looking at is initCurses
02:04:50 <quicksilver> it probably takes your entire main action as its parameter
02:04:51 <drdo> I'm not sure what it will do with it
02:04:54 <quicksilver> so it wraps everything
02:05:01 <mmorrow> ah, that's probably getting a ptr to some malloced memory from C
02:05:02 <quicksilver> main = initCurses $ do .... everythiing here ...
02:05:33 <cjs> So did I miss the trick to catch all exceptions?
02:05:40 <pk__> @src seq
02:05:41 <lambdabot> Source not found.
02:06:07 <mmorrow> cjs: just saying the type of the exception is SomeException has worked for me
02:06:23 <cjs> Oh, I see. Thanks.
02:06:50 <mmorrow> catchAll :: IO a -> (SomeException -> IO a) -> IO a; catchAll = catch
02:06:54 <mmorrow> should work i think
02:07:01 <porges> is there an automatic way to generate boot files for mutually-recursive modules?
02:07:04 <luqui> drdo, it will probably do some stuff, then execute that action, then do some other stuff
02:08:04 <pk__> I have a function defined as f g n = f (n-1) . g, f _ 0 = id
02:08:15 <mmorrow> @remember luqui no!!! I was building a joke, but then I sent it before I thought of one.
02:08:15 <lambdabot> Nice!
02:08:16 <mmorrow> heh
02:08:24 <pk__> is that function tail recursive ?
02:08:50 <luqui> heh, that is the second of my quotes that is better out of context :-)
02:09:22 <mmorrow> pk_: it looks like it
02:09:27 <mmorrow> luqui: heh
02:09:44 <cjs> So this claims that there's a catchAny function: http://markmail.org/message/tpb72ukx7nbshszq
02:10:30 <pk__> mmorrow: how come I get a stack overflow exeption ?
02:10:34 <dolio> That may have gotten replaced with SomeException.
02:10:50 <drdo> (.text+0xa7): undefined reference to `nanocurseszm1zi5zi2_UIziNanocursesziCurses_endWin_closure'
02:11:03 <quicksilver> cjs: I think they ditched catchAny, yes.
02:11:06 <dolio> Since it should be (I think) equivalent to that catchAny type.
02:11:18 <quicksilver> there is onException (which doesn't actually get the exception)
02:11:20 <mmorrow> pk: oh wait, that f isn't type-correct actually
02:11:24 <quicksilver> and using catch with SomeException.
02:11:32 <mmorrow> pk__: is that actually the function you ran?
02:11:37 <pk__> no
02:11:40 <pk__> sry
02:11:42 <quicksilver> porges: No. Rule of thumb, IMO, is don't use them.
02:11:47 <cjs> Hm. So SomeException is not documented as working this way....
02:12:30 <cjs> Oh, it is, in the type signature.
02:12:44 <luqui> wtf? Not in scope: type constructor or class `SomeException'
02:13:14 <mmorrow> luqui: with Control.Exception (and not Control.OldException)?
02:13:24 <luqui> something is amiss..., I see it in GHCi
02:14:24 <luqui> it only happens when I build with cabal
02:14:26 <pk__> I think what I really tried was:
02:14:28 <dolio> "catchAny m h = m `catch` \(SomeException e) -> h e" and "catch m h = m `catchAny` \e -> h (SomeException e)"
02:14:38 <pk__> f g n = f g (n-1) . g
02:14:39 <luqui> do I need a special dependency?
02:15:10 <luqui> ahh, needed to require base>=4
02:15:15 <mmorrow> pk_: ah, ok in that case you'll need to force the `n' (you wouldn't have had to in the other case, because it had to be evaled at each step to test if it was 0)
02:15:20 <hugo___> merry christmas
02:15:28 <mmorrow> f g !n = f g (n-1) . g
02:15:36 <mmorrow> {-# LANGUAGE BangPatterns #-}
02:15:49 <mmorrow> shouldn't stack overflow
02:16:52 <porges> hugo___: not for another 45 minutes?
02:18:02 <pk__> I still have the stack overflow
02:19:14 <cjs> Argh! My command line history doesn't work in 6.10 ghci!
02:19:17 <dolio> f g !n !x = f g (n-1) (g x)
02:19:28 <quicksilver> cjs: editline is made of fail.
02:19:31 <pk__> mmorrow: maybe I wasn't very clear. I still have the f _ 0 = id equation
02:19:32 <quicksilver> I'm not sure why, though.
02:20:43 <pk__> dolio: it works !
02:20:47 <pk__> thx
02:20:52 <dolio> @yow!
02:20:53 <lambdabot> Leona, I want to CONFESS things to you ... I want to WRAP you in a SCARLET
02:20:53 <lambdabot> ROBE trimmed with POLYVINYL CHLORIDE ... I want to EMPTY your ASHTRAYS ...
02:21:13 <cjs> Hm. So what's the diff between editline and readline? Maybe I just need a different init file of some sort?
02:21:34 <cjs> Oh, is this NetBSD's editline? Cool.
02:21:35 <dolio> editline has a less arduous license.
02:21:42 <dolio> And readline has nicer features.
02:22:11 <quicksilver> some experiences of GHC users suggest editline is entirely broken
02:22:20 <quicksilver> although it's not clear to me what's going on.
02:22:27 <quicksilver> (editline isn't really broken - it works for other programs)
02:23:28 <dolio> editline seems to remember my history between invocations of ghci, that's nice.
02:24:04 <dolio> On the other hand, it doesn't do unicode, which is potentially annoying.
02:24:22 <dolio> Not that I use unicode in my Haskell source.
02:24:27 <quicksilver> readline does the former, too
02:24:32 <quicksilver> depending on settings.
02:24:43 <dolio> Oh. Well, I never had the right settings, I guess. :)
02:26:00 <mmorrow> readline + persistent history == takes the cake
02:27:38 <mmorrow> , let x = Nothing in x .==. Nothing
02:27:44 <lunabot>  True
02:27:46 <mmorrow> hehe
02:27:59 <b_jonas> @type .==.
02:28:00 <lambdabot> parse error on input `.==.'
02:28:04 <dolio> , let x = id Nothing in x .==. Nothing
02:28:09 <lunabot>  False
02:28:14 <mmorrow> , [$ty| (.==.) |]
02:28:21 <lunabot>  forall a . a -> a -> Bool
02:28:26 <mmorrow> , [$ty| reallyUnsafePtrEquality |]
02:28:32 <lunabot>  forall a . a -> a -> Bool
02:28:34 <mmorrow> surprise!
02:28:37 <mmorrow> ;)
02:28:42 <b_jonas> oh
02:28:58 <mmorrow> (.==.) is so much less threatening of a name
02:29:10 <idnar> heh
02:29:24 * luqui wonders why PtrEquality is reallyUnsafe rather than just unsafe
02:29:40 <xpika> how do i operate a plus 1 on [Just 1,Just 2]?
02:29:41 <mmorrow> i'm not sure
02:29:46 <mmorrow> (@luqui)
02:30:00 <luqui> xpika, the numbers are hiding inside two functors (list and Maybe)
02:30:06 <luqui> so fmap twice
02:30:07 <mmorrow> , (fmap . fmap) (+1) [Just 1,Just 2]
02:30:10 <lunabot>  [Just 2,Just 3]
02:30:18 <xpika> nice.
02:30:19 <mmorrow> , fmap (fmap (+1)) [Just 1,Just 2]
02:30:21 <lunabot>  [Just 2,Just 3]
02:30:34 <mmorrow> , (fmap . fmap . fmap) (+1) [Just [1..4],Just [2]]
02:30:35 <mgsloan> class Cached a b c | a c -> b where
02:30:35 <quicksilver> luqui: because even reallyUnsafePtrEquality x x can turn out to be false.
02:30:35 <mgsloan> newtype (Cached a b c, Eq b) => Cache a c = Cache (Maybe (b, c))
02:30:35 <mgsloan> Cache.hs:5:18: Not in scope: type variable `b'
02:30:37 <lunabot>  [Just [2,3,4,5],Just [3]]
02:30:37 <mgsloan> :(
02:30:38 <xpika> must remember that
02:30:52 <mmorrow> quicksilver: whoa. why?
02:30:54 <luqui> quicksilver, so?  =P
02:31:10 <quicksilver> luqui: so that's more unsafe that you might expect, so it's reallyUnsafe
02:31:20 <quicksilver> mmorrow: another thread might reduce the thunk x points to in between the comparison ;)
02:31:24 <luqui> so can unsafePerformIO getCurrentTime == unsafePerformIO getCurrentTime
02:31:29 <luqui> but okay...
02:31:30 <mmorrow> quicksilver: ahh
02:32:33 <mmorrow> , let x = 41 + 1; y = x in x `seq` x .==. y
02:32:39 <lunabot>  True
02:32:40 <mmorrow> , let x = 41 + 1; y = x in y `seq` x .==. y
02:32:45 <lunabot>  True
02:33:04 <luqui> I think it might be false if x was unevaluated on the left but evaluated on the right?  no... something about the garbage collector then?  I don't know.
02:33:05 <mmorrow> i guess it has to be another thread
02:33:05 <hass> http://pastebin.com/d18fcf446
02:33:12 <hass> Why is this erroring and what is the resolution?
02:33:34 <mmorrow> luqui: yeah, i can't think of any way to do that in a single thread
02:33:54 <luqui> :t sqrt -- for hass
02:33:55 <lambdabot> forall a. (Floating a) => a -> a
02:34:07 <quicksilver> hass: sqrt only works for floating types.
02:34:07 <luqui> hass, you need to convert to floating first, which can be done with fromIntegral
02:34:19 <mmorrow> , let x = 41 + 1 in x `par` x .==. 42
02:34:23 <lunabot>  False
02:34:31 <b_jonas> hass: what's the type of sqrt?
02:34:32 <mmorrow> , let x = 41 + 1 in x `seq` x .==. 42
02:34:37 <lunabot>  False
02:34:41 <mmorrow> oh
02:34:45 <luqui> ( hass, note, however, that sqrt n >= divisor  is equivalent to n >= divisor^2  ;-)
02:34:46 <hass> b_jonas: sqrt :: Floating a => a -> a
02:34:50 <dolio> , let lookup' e l = fmap snd $ find ((.==. e) . fst) l ; fastMap f l = go [] l where go m [] = [] ; go m l@(x:xs) | Just l' <- lookup l m = l' | otherwise = let l' = f x : go ((l,l'):m) xs in l' in let ones = 1 : ones in fastMap (+1) ones
02:34:54 <lunabot>  luna: out of memory (requested 1048576 bytes)
02:35:12 <mmorrow> , let x = 41 + 1 in (\x -> [closureType x, x `seq` closureType x]) x
02:35:18 <lunabot>  [AP,Constr]
02:35:21 <hass> Oh
02:35:27 <mmorrow> , (\x -> [closureType x, x `seq` closureType x]) 42
02:35:32 <lunabot>  [AP,Constr]
02:35:50 <hass> luqui: I'm unsure of how to fix it, then
02:36:03 <mmorrow> , let x = 41 + 1 in x `seq` 42 `seq` x .==. 42
02:36:08 <lunabot>  False
02:36:12 <luqui> :t fromIntegral
02:36:13 <lambdabot> forall a b. (Num b, Integral a) => a -> b
02:36:14 <quicksilver> hass: the best thing is to use the n >= divisor * divisor answer
02:36:22 <quicksilver> alternative you can write
02:36:27 <mmorrow> , let x = 41 + 1 in x `seq` x `seq` 42 `seq` x .==. 42
02:36:31 <b_jonas> quicksilver: I disagree
02:36:32 <lunabot>  False
02:36:33 <quicksilver> round( sqrt ( fromIntegral n))) >= divisor
02:36:37 <quicksilver> but that's horrible.
02:36:44 <quicksilver> b_jonas: why?
02:36:47 <b_jonas> because divisor * divisor has to be computed each time whereas sqrt is a constant
02:36:56 <b_jonas> so you only have to calculate sqrt once
02:37:17 <mmorrow> , let x = 41 + 1; y = x in x `par` x .==. y
02:37:18 <hass> So hold up, is it erroring because the argument to sqrt is not floating?
02:37:19 <b_jonas> that doesn't mean the multiplication is very bad, but still I think it's not the best thing to write
02:37:23 <lunabot>  False
02:37:24 <luqui> b_jonas, ah, but I don't think ghc will see that
02:37:31 <mmorrow> aha
02:37:33 <dolio> , let x = 41 + 1 in x `seq` (x .==. 42)
02:37:33 <b_jonas> luqui: yeah, but you can _let_ it see that
02:37:36 <luqui> b_jonas, but yeah, you could finagle it that way
02:37:37 <mmorrow> , let x = 41 + 1; y = x in x `seq` x .==. y
02:37:38 <lunabot>  False
02:37:43 <lunabot>  True
02:37:49 <mmorrow> , let x = 41 + 1; y = x in x `seq` x .==. y
02:37:51 <b_jonas> (also after strictness analysis it might be as smart to even see it)
02:37:54 <lunabot>  True
02:37:55 <mmorrow> , let x = 41 + 1; y = x in x `par` x .==. y
02:38:00 <lunabot>  False
02:38:05 <luqui> b_jonas, doubtful
02:38:18 <luqui> oh, you never know though
02:38:28 <b_jonas> well, anyway, you can always let it
02:38:30 * luqui plays to see if he can get it to
02:38:48 <mmorrow> dolio: i guess with the literal 42 one the x is getting updated with a ptr to 42 rather than being 42 itself (?)
02:39:00 <hass> luqui / b_jonas: I still fail to understand the cause of the error, why does the the type of the function that sqrt is used in make a difference?
02:39:07 <dolio> mmorrow: Not all 42s are shared.
02:39:30 <luqui> hass, because n is an Int, and sqrt doesn't work on Ints
02:39:38 <hass> Oh
02:39:43 <mmorrow> there's one 42 for each type i guess
02:39:55 <dolio> mmorrow: Not even all 42s for Int are shared.
02:40:09 <mmorrow> dolio: hmm
02:40:18 <dolio> The literal 42 may be.
02:40:28 <mmorrow> ah, i see what you're saying
02:40:30 <mmorrow> yeah
02:40:44 <dolio> But a 42 that's the result of a literal 1 added to a literal 41 may not be shared with the literal 42.
02:41:06 <b_jonas> @let reallyUnsafePtrEquality :: a -> a -> Bool; reallyUnsafePtrEquality x y = False;
02:41:07 <lambdabot>  Defined.
02:41:14 <mmorrow> but it'll be a ptr to the literal 42 (i think)
02:41:29 <mmorrow> or at least that's what i'm basing my assumptions on
02:41:30 <mapreduce> Am I correct that ps = do \n y <- [0..] \n return [p x y | x <- [0..]] just constructs an infinite list of infinite lists where each element ps !! x !! y == p x y?
02:41:33 <dolio> Since to do so you'd have to add the Int#s, and then figure out which canonical number to return by comparing the underlying Int#s.
02:41:36 <maltem> why would you ever want to share 42?
02:41:42 <dolio> Which is kind of a waste of time.
02:41:46 <mmorrow> dolio: ah, good point
02:42:13 <dolio> maltem: Save miniscule amounts of memory. :)
02:42:35 <maltem> yea
02:42:37 <mmorrow> ok, but i think all Nothings of a given type are shared
02:42:40 <hass> So, should "sqrt fromIntegral n" work?
02:42:49 <mmorrow> and []s etc
02:42:55 <Japsu> hass: sqrt (fromIntegral n)
02:43:00 <dolio> mmorrow: Yeah. The only way to get a Nothing is to have a literal Nothing.
02:43:07 <maltem> (unboxing of 42 would be another interesting topic)
02:43:08 <mmorrow> true
02:43:16 <mmorrow> but drop 1 [undefined]
02:43:24 * mmorrow tests the hypothesis
02:43:31 <Japsu> > sqrt (fromIntegral (16 :: Word8))
02:43:33 <lambdabot>   4.0
02:43:43 <mmorrow> , let x = drop 1 [undefined] in x `seq` x .==. []
02:43:48 <lunabot>  False
02:43:52 <mmorrow> hmm
02:43:59 <dancor> how do i get lambdabot to generate a quote, show it, and show vixen's reply
02:44:00 <b_jonas> hass: no
02:44:02 <luqui> b_jonas, I can't get it to lift that call
02:44:08 <dancor> (this is important)
02:44:12 <luqui> (or rather, I can't get it to lift Debug.Trace)
02:44:12 <quicksilver> mmorrow: I believe all nothings of all types are shared, in GHC.
02:44:19 <quicksilver> mmorrow: (possibly not cross-module though)
02:44:21 <b_jonas> hass: after that you still want to compare the result of the square root (which is a float) with (<) to an integer
02:44:23 <mmorrow> quicksilver: oh nice
02:44:28 <b_jonas> luqui: I see
02:44:33 <quicksilver> mmorrow: that's the nice thing about a parametric representation.
02:44:36 <quicksilver> mmorrow: similarly all []s.
02:44:40 <Japsu> :t floor
02:44:42 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
02:44:44 <dolio> , let x = drop 1 [undfined] in x `seq` (x .==. [])
02:44:45 <lunabot>  luna: Not in scope: `undfined'
02:44:58 <mmorrow> , let x = drop 1 [undefined] in x `seq` (x .==. [])
02:44:58 <dolio> , let x = drop 1 [undefined] in x `seq` (x .==. [])
02:45:01 <hass> b_jonas: then what is the solution?
02:45:03 <lunabot>  False
02:45:08 <lunabot>  False
02:45:08 <dolio> Oh well.
02:45:13 <hass> Something so simple seems to be made so complicated
02:45:16 <b_jonas> hass: two conversions
02:45:27 <mmorrow> hmm, i wonder if it's being skewed by being interpreted
02:45:44 <Axman6> @check \n m -> (sqrt $ fromIntegral n) < m == n < m^2)
02:45:44 <lambdabot>  Unbalanced parentheses
02:45:45 <b_jonas> hass: take the number, float it, square root it, ceiling it, and compute that once
02:45:51 <Axman6> @check \n m -> (sqrt $ fromIntegral n) < m == n < m^2
02:45:52 <lambdabot>       precedence parsing error
02:45:52 <lambdabot>          cannot mix `(<)' [infix 4] and `(==)'...
02:45:52 <b_jonas> hass: then in the loop compare to that integer
02:45:56 <b_jonas> hass: or something like that
02:45:57 <Ferdirand> hass: just test for divisor * divisor < n
02:46:08 <Axman6> @check \n m -> ((sqrt $ fromIntegral n) < m) == n < m^2
02:46:09 <lambdabot>       precedence parsing error
02:46:09 <lambdabot>          cannot mix `(==)' [infix 4] and `(<)'...
02:46:14 <Axman6> @check \n m -> ((sqrt $ fromIntegral n) < m) == (n < m^2)
02:46:15 <lambdabot>   Add a type signature
02:46:18 <mmorrow> i know that ghci reverts CAFs, (but luna isn't since i don't have  char * rts_revert_cafs = blah linked in)
02:46:31 <b_jonas> actually take care with exact squares
02:46:35 <Axman6> @check \n m -> ((sqrt $ fromIntegral n) < m) == (n < m^2) :: Integer -> Double -> Bool
02:46:36 <mmorrow> s/rts_revert_cafs/whatever that's really called/
02:46:36 <lambdabot>   Couldn't match expected type `Integer -> Double -> Bool'
02:46:48 <Axman6> @check \n m -> ((sqrt $ fromIntegral n) < m) == (fromIntegral n < m^2) :: Integer -> Double -> Bool
02:46:49 <lambdabot>   Couldn't match expected type `Integer -> Double -> Bool'
02:46:53 <Axman6> @check \n m -> ((sqrt $ fromIntegral n) < m) == (fromIntegral n < m^2)
02:46:55 <lambdabot>   "Falsifiable, after 0 tests:\n1\n-3.0\n"
02:46:59 <Axman6> >_<
02:47:20 <Axman6> @check \n m -> n > 0 && ((sqrt $ fromIntegral n) < m) == (fromIntegral n < m^2)
02:47:22 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0.0\n"
02:47:35 <Axman6> @check \n m -> n < 0 || ((sqrt $ fromIntegral n) < m) == (fromIntegral n < m^2)
02:47:36 <lambdabot>   "Falsifiable, after 0 tests:\n2\n-3.3333333333333335\n"
02:47:41 <mmorrow> , let !x = drop 1 [()] in x .==. []
02:47:46 <lunabot>  True
02:47:49 <Axman6> stuff it
02:47:49 <mmorrow> woot
02:48:05 <mmorrow> , let !x = drop 1 [undefined] in x .==. []
02:48:09 <lunabot>  True
02:48:15 <mmorrow> hmm
02:48:21 <luqui> @check \n m -> n < 0 || ((sqrt $ fromIntegral n) <= m) == (fromIntegral n <= m^2)
02:48:22 <lambdabot>   "Falsifiable, after 1 tests:\n0\n-1.0\n"
02:48:25 <dolio> Hmm...
02:48:27 <mmorrow> , let !x = drop 1 [undefined] in closureType x
02:48:32 <lunabot>  Constr
02:48:35 <mmorrow> , let x = drop 1 [undefined] in x `seq` closureType x
02:48:40 <luqui> @check \n m -> m < 0 || n < 0 || ((sqrt $ fromIntegral n) <= m) == (fromIntegral n <= m^2)
02:48:40 <lunabot>  Indirection 28
02:48:41 <lambdabot>   "OK, passed 500 tests."
02:48:43 <mmorrow> ahhhh
02:48:45 <dolio> Oh.
02:48:53 <mmorrow> vewwwy interesting
02:49:06 <dolio> drop n l is whnf, I guess?
02:49:19 * mmorrow makes a note to use let !x = .. over let x = .. in x `seq` ..  from now on
02:49:28 <dolio> Or not...
02:49:38 <mmorrow> i used a let !x = ... in
02:49:41 <luqui> mmorrow, you know that's a ghc extension right?
02:49:53 <mmorrow> luqui: which?
02:49:58 <luqui> let !x = ...
02:50:12 <mmorrow> ah yeah, BangPatterns
02:50:39 <osfameron> :t closureType
02:50:40 <lambdabot> Not in scope: `closureType'
02:50:50 <dolio> , let x = drop 1 [undefined] in case x of [] -> x .==. []
02:50:54 <lunabot>  False
02:51:05 <mmorrow> dolio, luqui: i assumed (incorrectly) that  let !x = ..  and let x = .. in x `seq` ..  were equivalent
02:51:13 <dolio> , let x = drop 1 [undefined] in case x of e@[] -> e .==. []
02:51:20 <luqui> mmorrow, oh.. they're not?
02:51:21 <lunabot>  True
02:51:23 * luqui backlogs
02:51:28 <dolio> Check that out.
02:51:42 <mmorrow> osfameron: closureType a = unsafePerformIO (tipe `fmap` getClosureInfo a)
02:51:50 <mmorrow> dolio: whoa
02:52:08 <dolio> Now I know why the core uses that convention.
02:52:10 <mmorrow> import RtClosureInspect (ClosureInfo(..),getClosureInfo)
02:52:46 <mmorrow> osfameron: (lunabot just has to use unsafePerformIO because it can't do IO)
02:53:19 <osfameron> mmorrow: thanks
02:53:31 <mmorrow> dolio: ohhh, so i guess the first doesn't actually eval the x
02:53:59 <mmorrow> osfameron: it's informative in ghci playing with that
02:54:06 <int-e> > let (!a, b) = (undefined, 1) in b -- hmm
02:54:07 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
02:54:17 <mmorrow> osfameron: another good one in RtClosureInspect.isFullyEvaluated
02:54:18 <int-e> , let (!a, b) = (undefined, 1) in b -- hmm
02:54:20 <lunabot>  luna: parse error (possibly incorrect indentation)
02:54:27 <quicksilver> , let (!a, b) = (undefined, 1) in b
02:54:27 <mmorrow> osfameron: oh, you'll need to do
02:54:29 <lunabot>  luna: Prelude.undefined
02:54:30 <osfameron> mmorrow: where does getClosureInfo live?
02:54:31 <mmorrow> ghc -package ghc
02:54:46 <mmorrow> osfameron: it's in the ghc package (which is hidden by default)
02:55:00 <mmorrow> (or you can do  sudo ghc-pkg expose ghc)
02:55:21 <osfameron> mmorrow: it doesn't come up with  ghci -package ghc
02:55:37 <osfameron> it seems to get linked, but still "Not in scope: `getClosureInfo'"
02:55:48 <mmorrow> oh, maybe it's getClosureData
02:55:54 * mmorrow doublechecks
02:56:05 <mmorrow> yeah, that's it
02:56:13 <osfameron> hmmm, still not
02:56:22 <osfameron> I'll try that expose incantation
02:56:23 <mmorrow> what ghc are you using?
02:56:32 <osfameron> ah, 6.6.1
02:56:40 <osfameron> I thought I'd built a later one...
02:56:44 <mmorrow> hmm, i'll check if it's there
02:57:08 <int-e> mmorrow: let !x = ??? in ... x ... turns into a let x = ??? in ... x `seq` x ..., which has no effect (because x `seq` x === x)
02:57:26 <mmorrow> , let !x = drop 1 [undefined] in closureType x
02:57:28 <mapreduce> @yousers
02:57:28 <lambdabot> Maximum users seen in #haskell: 568, currently: 543 (95.6%), active: 21 (3.9%)
02:57:31 <lunabot>  Constr
02:57:33 <mmorrow> , let x = drop 1 [undefined] in x `seq` closureType x
02:57:38 <lunabot>  Indirection 28
02:58:00 <dolio> int-e: That doesn't seem to be the case.
02:58:19 <int-e> mm
02:58:23 <mmorrow> int-e: i meant for the second "..." in let x = ... in x `seq` ... to mean f x for some f
02:58:44 <int-e> dolio: argh
02:58:56 <mmorrow> , let x = drop 1 [undefined] in rnf x `seq` closureType x
02:58:58 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
02:59:03 <int-e> replace "does" by "should" ;)
02:59:16 <mmorrow> , let x = drop 1 [undefined::NFData a => a] in rnf x `seq` closureType x
02:59:17 <dolio> :)
02:59:20 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
02:59:26 <mmorrow> , let x = drop 1 [undefined::Int] in rnf x `seq` closureType x
02:59:32 <lunabot>  Indirection 28
03:00:04 <int-e> , let x = drop 1 [undefined::Int] in closureType x
03:00:09 <lunabot>  AP
03:00:15 <int-e> seems ok.
03:00:32 <mmorrow> , (\x -> [closureType x, x `seq` closureType x]) (1 + 1)
03:00:37 <lunabot>  [AP,Constr]
03:00:46 <dolio> , let !x = drop 1 [undefined::Int] in closureType x
03:00:51 <lunabot>  Constr
03:00:56 <int-e> hmm. sort of - one would think that the AP is large enough to hold the [] constructor.
03:00:59 <mmorrow> , (\ !x -> closureType x) (1+1)
03:01:04 <lunabot>  Constr
03:01:19 <mmorrow> , (\ !x -> closureType x) (drop 1 [undefined])
03:01:22 <int-e> @src drop
03:01:22 <lambdabot> drop n xs     | n <= 0 =  xs
03:01:23 <lambdabot> drop _ []              =  []
03:01:23 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
03:01:24 <lunabot>  Constr
03:01:37 <mmorrow> , (\x -> x `seq` closureType x) (drop 1 [undefined])
03:01:42 <lunabot>  Constr
03:01:51 <mmorrow> hmm, i guess that only happens with let
03:02:07 <dolio> The interaction of ! with let seems to be the weirdness here.
03:02:25 <int-e> , (\x -> x `pseq` closureType x) (drop 1 [undefined])
03:02:31 <lunabot>  Indirection 28
03:02:33 <dolio> That is, ! on top-level symbols.
03:02:36 <int-e> :)
03:02:42 <mmorrow> hmm
03:03:18 <mmorrow> osfameron: my 6.6.1 is borked (libs have been deleted)
03:03:31 <int-e> @srq pseq
03:03:31 <lambdabot> Source not found. That's something I cannot allow to happen.
03:04:01 <dolio> It seem that "let !x = e in e'" turns into "case x of e -> e'", where case has core semantics.
03:04:11 <dolio> Sorry, "case e of x -> e'".
03:04:41 <mmorrow> that may have something to do with how let is a primitive in STG but lambdas don't exist
03:04:52 <lilac> "let !x = e in exp" is equivalent to "let x = e in x `seq` exp", right?
03:04:59 <dolio> whereas "let x = e in x `seq` e'" is something else.
03:05:01 <int-e> so how do you follow indirections to find the final thunk or constructor?
03:05:43 <dolio> , let x = drop 1 [undefined] in case x of [] -> closureType x
03:05:47 <lunabot>  Indirection 28
03:05:49 <dolio> , let x = drop 1 [undefined] in case x of e@[] -> closureType e
03:05:54 <lunabot>  Constr
03:06:08 <mmorrow> oh, also i should note that the evaluator is being run with +RTS -N2 -RTS (on a 4-core machine)
03:06:30 <mmorrow> so pseq and par are really parallel
03:06:50 <mmorrow> (in case that matters here)
03:06:50 <porges> @src ap
03:06:50 <lambdabot> ap = liftM2 id
03:06:52 <int-e> pseq is not parallel :)
03:07:00 <int-e> pseq  x y = x `seq` lazy y
03:07:01 <mmorrow> heh, ok
03:07:18 <mmorrow> oh yeah, i was just reading about lazy the other day
03:07:23 * mmorrow refreshes his memory
03:07:31 <int-e> it's just artificially lazy in its second argument. (it's operationally strict, but it fools the optimizer into believing otherwise)
03:07:52 <mmorrow> hmm
03:08:11 <int-e> which (hopefully) will cause it to evaluate x before y.
03:08:40 * mmorrow refreshes his mem on the exact meaning of pseq again
03:09:23 <mmorrow> interesting
03:09:58 <mmorrow> so when you're using seq + unsafePerformIO you probably mean pseq + unsafePerformIO
03:10:34 <luqui> anybody know a beautiful implementation of interleave (interleave [1,2,3] [4,5,6] = [1,4,2,5,3,6])?
03:11:07 <mmorrow> , interleave [1,2,3] [4,5,6]
03:11:10 <lunabot>  [1,4,2,5,3,6]
03:11:12 <luqui> LOL
03:11:14 <mmorrow> heh
03:11:20 <luqui> that's pretty good...
03:11:21 <int-e> > let interleave xs ys = concat (transpose [xs, ys]) in interleave [1,2,3] [4,5,6]
03:11:22 <mmorrow> it's on LogocT
03:11:22 <lambdabot>   [1,4,2,5,3,6]
03:11:24 <mmorrow> it's on LogicT
03:11:34 <luqui> oh, ...
03:11:52 <mmorrow> logict on hackage
03:12:02 <mbz_> @go logict
03:12:03 <porges> :t ap
03:12:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:12:04 <lambdabot> http://okmij.org/ftp/Computation/monads.html
03:12:05 <lambdabot> Title: Monads
03:12:08 <mmorrow> , src 'interleave
03:12:14 <lunabot>  Class op from MonadLogic: interleave :: forall m . MonadLogic m => forall...
03:12:14 <lunabot>                                                                           ...
03:12:28 <Axman6> int-e: damn, i was totally thinking that definition would work :(
03:12:50 * Axman6 iz teh genus... just late to the party :(
03:13:02 <dolio> Anyhow, all this stuff demonstrates is that reallyUnsafePtrEquality is even more evil than seq. :)
03:13:19 <Axman6> how is seq evil?
03:13:43 <pao> hi! is there a way to provide a meta implementation for a function of a class? I'd like to "automatize" an instance declaration in the same way Show behaves
03:13:44 <mmorrow> dolio: heh
03:13:45 <dolio> It breaks eta reduction?
03:13:49 <mmorrow> <int-e> so how do you follow indirections to find the final thunk or constructor?
03:13:56 <mmorrow> i don't think you can at the haskell level
03:14:00 <augustss_> dolio: yeah, that's evil enough for me
03:14:54 <augustss_> mmorrow: why would you want to do that in Haskell?
03:15:16 <mmorrow> augustss_: i don't think ever :)
03:15:21 <quicksilver> pao: Yes. TH.
03:15:37 <mmorrow> augustss_: other than with reallyUnsafePtrEquality ;)
03:15:39 <pao> quicksilver: thanks
03:15:42 <quicksilver> pao: (or other tools ultimately based on TH, like Uniplate, Data.Generics, Data.Derive, DrIFT)
03:16:21 <pao> quicksilver: can you suggest a path in between those :-)
03:16:26 * mmorrow runs frantically to find his charger
03:16:28 <augustss_> mmorrow: Haskell has no concept of indirections nor pointers, so anything like that would be totally implementation dependent
03:17:09 <quicksilver> pao: I'd look at uniplate first, and if that isn't what you want, I'd look at Data.Derive.
03:17:32 <drdo`> How would you keep state in an application?
03:17:38 <pao> quicksilver: would you skip TH altogether?
03:18:13 <quicksilver> I would not start with TH.
03:18:21 <quicksilver> it is fiddly.
03:18:42 <pao> quicksilver: thanks... very precious... as usual :-)
03:18:54 <augustss_> TH is fiddly and inelegant.
03:19:20 <drdo`> help the poor newbie :)
03:19:21 <mbz_> is there an alternative to TH?
03:19:51 <augustss_> drdo`: depends on what kind of state you're talking about.  Maybe the State monad.
03:20:29 <Axman6> drdo`: you don't really. you can use MVars and IORefs if you need to, or you can use the State monad, but haskell doesn't let you do things like x = 1; ... ; x = 18;...
03:20:51 <dancor> drdo`: if you mean between invocations, you'll be like writing to a file of course.  if in same invocation, the simplest way is just to pass all the state around as arguments to your functions
03:21:31 <dancor> (and later you could get into how in many cases it's nicer to abstract that into something like the State Monad)
03:21:52 <drdo`> dancor: well, yes, that's what i was doing, passing around arguments
03:22:59 <augustss_> drdo`: passing around arguments works.  you might want to consider using a monad, but it's not necessary.
03:23:39 <dancor> drdo`: another thing is that it's often good to use a data type that has all the parts of your state
03:24:14 <dancor> like data Game = Game {gmBd :: Board, gmTurn :: Color, ee}
03:24:20 <dancor> s/ee/../
03:25:00 <drdo`> Won't it get pretty inefficient to be creating and GCing objects all the time?
03:25:35 <maltem> drdo`: the idea is that the intermediate objects are quickly gc'ed away
03:25:52 <maltem> drdo`: or even optimized away, if you're lucky
03:26:24 <drdo`> It's still a lot worse than destructively changing it
03:26:42 <maltem> drdo`: welcome to functional programming :)
03:27:08 <drdo`> maltem: There must be some nice abstract way of doing this efficiently :P
03:27:11 <Axman6> drdo`: those intermediate objects don't actually have to ever exist
03:27:21 <drdo`> You haskell guys must have thought about it
03:27:26 <drdo`> :)
03:27:38 <maltem> drdo`: well in some cases you really need destructive updates, e. g. if you are working with huge arrays that have to be in memory all the time
03:27:59 <maltem> drdo`: the MArray API takes care of that
03:27:59 <Axman6> drdo`: well if you consider that haskell's speed when compiled with ghc can be up there with C, it's pretty damn efficient ;)
03:28:02 <porges> assuming that this was even a legal syntax, does this definition make sense
03:28:04 <porges> instance (Foldable l, forall a. Monoid (l a)) ⇒ Applicative l where
03:28:04 <porges> 	pure x = mappend x zero
03:28:04 <porges> 	fs <*> xs = foldWith (<*> xs) fs
03:28:49 <porges> (illegal part is forall..., must be MonadPlus at the moment)
03:29:02 * mmorrow 's computer died
03:29:05 <maltem> drdo`: Quite heavy optimizations are done on lists, btw.
03:29:35 <Axman6> mmorrow: :O
03:29:41 <Axman6> mmorrow: are you ok man?
03:29:46 <dolio> mappend x zero = x is a law that monoids are expected to follow.
03:30:11 <porges> oops :)
03:30:21 <porges> didn't even think about that definition
03:30:24 <mmorrow> <augustss_> mmorrow: Haskell has no concept of indirections nor pointers, so anything like that would be totally implementation dependent
03:30:35 <dolio> Assuming zero = mempty.
03:30:42 <porges> yeah
03:30:54 <mmorrow> yeah, it's easy to forget that how ghc does things doesn't have to be the case at all
03:31:02 <dolio> I'm not sure how that's well typed, either. Since pure :: a -> l a.
03:31:24 <mmorrow> Axman6: i barely survived
03:31:28 <dolio> Unless l a = a, that doesn't seem to have the right type.
03:31:33 <porges> yeah
03:32:06 <porges> also the second <*> is meant to be <$>
03:32:26 <Axman6> mmorrow: but... all your awesome reqriting $ty TH stuff! oh god!
03:32:27 <mmorrow> augustss_: doesn't hbc use a G-machine or variant?
03:32:38 <dolio> Yeah. That part may be okay. I'm not sure.
03:33:26 <maltem> drdo`: for example, last [1..10^10] runs in constant (small) memory
03:34:09 <cizra> maltem: But certainly in not constant time.
03:34:10 <dolio> @type \fs xs -> foldWith (<$> xs) fs
03:34:11 <lambdabot> Not in scope: `foldWith'
03:34:16 <cizra> maltem: (at least not in ghci)
03:34:17 <dolio> @type \fs xs -> Data.Foldable.foldWith (<$> xs) fs
03:34:19 <lambdabot> Not in scope: `Data.Foldable.foldWith'
03:34:24 <Axman6> drdo`: also, things like [1..] work just fine in haskell. it'll happily produce an infinite list without any problems
03:34:27 <porges> real name is foldMap
03:34:34 <dolio> @type \fs xs -> Data.Foldable.foldMap (<$> xs) fs
03:34:35 <lambdabot> forall a b (f :: * -> *) (t :: * -> *). (Monoid (f b), Data.Foldable.Foldable t, Functor f) => t (a -> b) -> f a -> f b
03:34:37 <mmorrow> TH could definitely be more elegant. i'm not quite sure how though
03:34:51 <quicksilver> mmorrow: because, unfortunately, we need to understand how GHC does things to a greater or lesser extent to understand space and time behaviour.
03:35:08 <porges> so if (f = t) then we have a definition for <*>
03:35:09 <quicksilver> mmorrow: the ideal haskell semantics do not mandate space or time bounds.
03:35:17 <maltem> cizra: yeah of course not in constant time, but that makes it easy to observe the constant memory in top :)
03:35:21 <dolio> The type is right, at least.
03:35:23 <porges> just have to figure out pure :S
03:35:43 <porges> well it's the same as list's <*> only with a more general type
03:36:17 <dolio> Yeah. It just has to interact with pure in the right way.
03:36:31 <dolio> But, I don't think you'll be writing pure anyhow.
03:36:38 <dolio> Unless you include another class that gives it to you.
03:36:52 <mmorrow> quicksilver: that'd be great if one could just think in terms of the abstract semantics and get the most efficient possible code
03:37:22 <porges> dolio: it's not even possible at the moment because of kind conflicts
03:37:49 <b_jonas> isn't it the other way? the <$> first and all the others are <*>?
03:37:59 <dolio> Well, right. The quantification for Monoid isn't legal.
03:38:27 <porges> but even if I had that I can't define pure
03:38:38 <porges> so I've gotten stuck between Functor and Applicative :P
03:38:57 <mmorrow> Axman6: just my battery. that's stuff's not on my laptop anyway :)
03:39:19 <Axman6> ah, heh
03:39:20 <quicksilver> mmorrow: I'm pretty sure that's halting-hard :)
03:39:36 <quicksilver> mmorrow: (automatically deriving the most efficient code to implement an abstract algorithm)
03:40:28 <mmorrow> quicksilver: hmm. i meant to mean in the sense that you don't necessarily need to know how gcc work to write efficient C, but i guess this is really an issue of the level of these two langs
03:41:03 <mmorrow> as in, in haskell the compiler does a lot more wrt figuring out how to evaluate things
03:41:27 <int-e> mmorrow: you can follow indirections: if clos :: Closure is an indirection, then  ptrs clos ! 0 follows that link. (Apparently, you can `seq` the value safely - this seems to be some magic related to the 'Any' type that HValues use internally)
03:41:30 <porges> ooh it's christmas :)
03:41:59 <mmorrow> int-e: but i think that once you seq, you can't seq again
03:42:08 <mmorrow> but i might very well be wrong
03:42:29 <mmorrow> , let x = drop 1 [undefined] in x `seq` closureType x
03:42:31 <dancor> porges: australia?  i've still got 5 hours to wait here in thailand
03:42:42 <mmorrow> , let x = drop 1 [undefined] in x `seq` (x `seq` closureType x)
03:42:50 <paolino> I want to keep a fixed number of elements while examining an infinite stream , supposing they are orderable and I want to keep the highest ones. Is this the famous priority queue ?
03:42:51 <mmorrow> ohoh
03:42:57 <mmorrow> , 42
03:43:00 <lunabot>  Indirection 28
03:43:04 <lunabot>  Indirection 28
03:43:06 <lunabot>  42
03:43:18 <mmorrow> , let x = drop 1 [undefined] in x `seq` (\x -> x `seq` closureType x) x
03:43:24 <lunabot>  Constr
03:43:27 <mmorrow> ah
03:43:29 <mmorrow> you can :)
03:44:15 <dancor> paolino: i think priority queue keeps all elems
03:44:38 <dancor> http://en.wikipedia.org/wiki/Priority_queue
03:44:57 <mmorrow> , let follow !x = x; y = drop 1 [undefined] in fmap closureType . iterate follow $ y
03:45:04 <lunabot>  [AP,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk 19,Thunk ...
03:45:24 <porges> dancor: NZ
03:45:40 <drdo`> How can i access a field from a data type using its field label?
03:45:41 <int-e> mmorrow: ah, I guess there's a different invariant at work here: can an indirection ever point to a thunk? I think not. Thunks are replaced by black holes, and only updated (possibly with an indirection) when they've been evaluated to whnf.
03:45:54 <porges> dolio: it's precisely because Monoids are kind (*) that I can't write pure :P
03:46:14 <int-e> mmorrow: so `seq`-ing the closure or value pointed to by the indirection is safe
03:46:17 <dancor> paolino: i guess it's similar to Least Recently Used on http://en.wikipedia.org/wiki/Cache_algorithms tho
03:46:44 <dancor> LRU is kind of a type of what you are doing but the ordering is dynamic
03:46:45 <dolio> porges: Well, it's because none of your constraints give you something of type a -> l a.
03:46:58 <Axman6> drdo`: you mean when using record syntax? data Foo = foo {x :: Int; y :: Int; ...} f :: Foo -> Int; f foo = x foo?
03:47:08 <porges> yeah I stuffed that bit up. I thought it would be easy once I had finished the rest :S
03:47:44 <dolio> porges: Actually, they do, since you can do "pure _ = zero", but that's unlikely to be what you want.
03:47:54 <drdo`> Axman6: can i do that? "x foo" ?
03:47:55 <mmorrow> int-e: i think thunks are only blackholed when they're evaluated, but i think there could be a situation where a thunk is updated with an indirection to a new thunk (but maybe not directly (?))
03:48:05 <dancor> drdo`: yeah the labels _are_ functions, which is sometimes annoying bc you can't use as short names
03:48:08 <Axman6> drdo`: yep, that's what it's foo.
03:48:23 <drdo`> goodie, thank yoi
03:48:25 <drdo`> *you
03:48:35 <Axman6> drdo`: the names become functions of type Foo -> (type of the name in the datatype)
03:48:58 <dolio> porges: You could do "pure a = fmap (const a) zero" too, which is closer to what you'd actually want, but zero isn't the right thing to have in there.
03:49:14 <drdo`> hmm
03:49:22 <dolio> You want access to some arbitrary non-zero element of the monoid.
03:49:33 <drdo`> How can i multiply a Word32 and a Float?
03:49:48 <quicksilver> use fromIntegral to turn the Word32 into a Float
03:50:14 <dolio> Or, perhaps not arbitrary, but one that will allow you to fulfill the appropriate laws.
03:50:20 <drdo`> thanks
03:50:44 <paolino> dancor, how is this implemented in haskell ?
03:53:58 <int-e> mmorrow: yes, but the indirection chain will be of finite length and end in a constructor or PAP. I think.
03:54:21 <paolino> dancor: it looks like I need a double linked list
03:54:58 <mbz_> @src ($!)
03:54:59 <lambdabot> f $! x = x `seq` f x
03:55:00 <lilac> paolino: you could do something like: topN _ [] x = [x]; topN n ts@(t:_) x | x < t = ts | otherwise = tail . sort $ x:ts
03:55:12 <lilac> s/tail/take n/
03:55:24 <lilac> hmm, that's not right either :)
03:55:35 <lilac> reverse . take n . reverse :o
03:57:24 <mmorrow> <int-e> mmorrow: yes, but the indirection chain will be of finite length and end in a constructor or PAP. I think.<int-e> mmorrow: yes, but the indirection chain will be of finite length and end in a constructor or PAP. I think.
03:57:30 <mmorrow> yeah, that sounds right
03:57:37 <mmorrow> (oops on the doublepaste)
03:58:32 <paolino> lilac: that's at least naive
03:58:33 <mmorrow> err, but the "end" may not yet be known but to-be-determined by the result of evaluating a thunk i think
03:59:23 <int-e> mmorrow: Then the start of the chain should be a black hole.
03:59:45 <mmorrow> hmmm, i see your point now. i'm not sure
03:59:56 <int-e> mmorrow: but I need to verify that, I'm not completely sure either
04:00:46 <paolino> lilac: I suppose something like a Set would do, with a shrink to n elements when it's 2*n size
04:01:07 <quicksilver> paolino: priority queues? Use a heap or a fingertree.
04:01:27 <quicksilver> okasaki has a paper on it.
04:01:32 <quicksilver> and I imagine it's in his book.
04:04:10 <drdo`> What editor do you guys use?
04:04:21 <drdo`> haskell-mode totally screws up indentation
04:04:24 <mmorrow> yi!
04:04:36 <mmorrow> (kind of ... easing into it)
04:06:30 <Axman6> drdo`: i use TextMate on OS X
04:06:42 <porges> I'm getting to like gedit for some reason
04:06:49 <Axman6> though it'd not great for haskell
04:06:54 <drdo`> i'm an emacs user
04:07:00 <porges> I normally use vim but find I need to skip around a bit faster
04:07:05 <drdo`> but haskell-mode isn't indenting very well
04:07:11 <int-e> mmorrow: meh. "When a CAF is first entered, it creates a black hole in the heap, and updates itself with an indirection to this new black hole." :-/
04:07:26 <Axman6> porges: sounds like you need markers and such
04:07:41 <quicksilver> drdo`: you're using the wrong haskell-mode
04:07:53 <quicksilver> drdo`: the good indentation for haskell-mode is excellent
04:07:57 <quicksilver> @where haskell-indentation
04:07:57 <lambdabot> I know nothing about haskell-indentation.
04:08:04 <quicksilver> @where kuribas-indentation
04:08:04 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
04:08:09 <porges> Axman6: my main problem is vim's interaction with the system clipboard
04:08:10 <mmorrow> int-e: heh
04:08:23 <drdo`> quicksilver: i'm using the wrong haskell-mode?
04:08:30 <quicksilver> drdo`: well, the wrong indentation bit
04:08:33 <quicksilver> use the one I just linked.
04:08:35 <quicksilver> much better.
04:08:38 <Axman6> porges: i'm trying to learn how to use macvim, so it integrates nively :)
04:08:40 <drdo`> i'm using the default one :)
04:08:41 * osfameron doesn't get on with automatic indentation
04:08:41 <Axman6> nicely*
04:08:58 <mmorrow> int-e: this is pretty cool: http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
04:09:05 <quicksilver> osfameron: it's pretty unobstrusive.
04:09:17 <quicksilver> osfameron: and understands the different possibilities in layout code
04:09:34 <int-e> @index threadDelay
04:09:34 <lambdabot> GHC.Conc, Control.Concurrent
04:09:39 <osfameron> yeah I think I just need to train myself for it... I end up getting frustrated too early and giving up
04:11:01 <quicksilver> osfameron: a bad auto-indentation algorithm can be very frustrating.
04:11:13 <mmorrow> i've been off-and-on working on an implem, it's not really that overwhelming in terms of amount to implem. i have the lvm-lang->lvm->...->flat instrs done, but am kinda stuck on the translation from a "core" lang to the lvm lang
04:11:25 <drdo`> quicksilver: why isn't this merged in the main emacs source?
04:11:53 <mmorrow> you have to do a series of simplifications/translations and it doesn't give very specific details on /how/ to do these
04:12:11 <quicksilver> drdo`: no idea.
04:12:46 <mmorrow> so i'm trying to figure it out. anyhow, it's very similar to how the STG machine works (apparently), and it describes these similarities along the way
04:12:53 <mmorrow> i found it super informative
04:14:04 <drdo`> quicksilver: indentation doesn't work at all now
04:14:07 <drdo`> tab just inserts a tab
04:14:31 <mmorrow> now i just need to finish this translation part, a gc, and an rts :/
04:16:02 <mmorrow> int-e: one cool thing too is that it isn't limited to supporting haskell as the src-lang. among other things, it's capable of supporting a dependently-typed lang
04:16:17 <quicksilver> drdo`: M-x haskell-indentation-mode
04:16:22 <int-e> mmorrow: yay. this is actually a problem for the ghci debugger :)
04:16:27 <quicksilver> drdo`: I have it turned on in my haskell-mode hook
04:16:48 <mmorrow> int-e: nice. i haven't used that too extensively. i've been meaning to though
04:16:51 <drdo`> quicksilver: i did that
04:17:27 <drdo`> turn-on-haskell-indentation
04:17:31 <drdo`> this symbol doesn't even exist
04:17:36 <drdo`> why is it there?
04:17:53 <quicksilver> drdo`: M-x haskell-indentation-mode
04:17:57 <drdo`> i did it quicksilver
04:18:03 <drdo`> indentation works, but it's still sucky
04:18:11 <drdo`> just like before
04:18:12 <quicksilver> no it's not.
04:18:15 <mmorrow> hehe
04:18:24 <quicksilver> you've probably got them both turned on then
04:18:30 * mmorrow lols
04:18:37 <dolio> Maybe your sense of how haskell should be indented is wrong. :)
04:18:54 <quicksilver> M-x haskell-indent-mode
04:18:56 <ivanm> dolio: what? you mean haskell is meant to be _indented_? :o
04:18:58 <quicksilver> (to turn off the crappy one)
04:19:01 <porges> but I *want* it right-justified!
04:19:06 <ivanm> I don't have to do the whole {foo ; bar } stuff? :o
04:19:07 <qebab> I have no idea how Haskell should be indented - I let emacs do it and no one's complained about it yet
04:19:10 <qebab> :p
04:19:32 <drdo`> qebab: i like to look at my code and understand it
04:19:34 <Axman6> hang on, you can use more than ONE line? bugger me
04:19:36 <qebab> The same as I do with Lisp, really, best just let a clever indent mode handle it
04:19:58 <qebab> drdo`: I don't usually have a problem with understanding my code :)
04:20:06 <dolio> Lisp is a bit easier to auto-indent.
04:20:10 <drdo`> argh
04:20:13 <ivanm> Axman6: next they'll be claiming we can not only use more than one line, but more than one file! :o
04:20:28 <qebab> ivanm: Lies, no one will ever go that far!
04:20:31 * ivanm only just found that that you don't have to pass the entire program as a cli argument
04:20:32 <ivanm> ;-)
04:20:54 <Axman6> ivanm: wtf would want something as stupid as that
04:21:05 <ivanm> Axman6: what, multiple files?
04:21:15 <Axman6> yes!
04:21:16 <ivanm> Axman6: well, why would you want more than one line?
04:21:22 <Axman6> exactly
04:21:38 <porges> it's rather annoying how NoImplicitPrelude works for some things but not all things
04:21:39 <porges> :|
04:21:39 <Axman6> spreading your line ofer multiple files is just proposterous
04:22:31 <int-e> mmorrow: see here. http://hpaste.org/13313 :)
04:23:09 <ivanm> Axman6: han on, wait, maybe we can make our programs more expandable by swapping which files with our line-segments go where! :o
04:23:14 <ivanm> nah, that's ridiculous
04:23:40 <Axman6> did that sentence even make sense? :P
04:23:49 <ivanm> s/han/hang/
04:23:58 <int-e> mmorrow: note that this doesn't happen for normal values or for CAFs that have not been compiled. Fun :)
04:24:04 <porges> I think he swapped which line file segments where go?
04:24:26 <ivanm> something like that
04:25:14 <drdo`> http://pastebin.com/d2d855606
04:25:19 <drdo`> Is this how you indent haskell?
04:25:25 <drdo`> looks pretty horrible to me
04:25:39 <mmorrow> int-e: ooh, cool
04:25:43 <b_jonas> mmorrow: but C is a bit special, it's so low level that almost any operation you can write in C takes constant time so it's easy to tell how efficent something is
04:25:46 <pumpkin> drdo`: that seems a little excessive, but it works
04:25:54 <drdo`> pumpkin: excessive?
04:26:02 <drdo`> What do you mean excessive?
04:26:04 <pumpkin> the indentation used in that example
04:26:05 <ivanm> drdo`: I wouldn't necessarily do it that way, but if ghc is happy it must be valid
04:26:17 <b_jonas> (except for copying big structures by assignment, passing as argument, or returning)
04:26:19 <drdo`> ivanm: it is valid, but the whole point of code is to be human readable
04:26:32 <drdo`> ivanm: and i didn't do it that way, it was haskell-mode
04:26:45 <ivanm> drdo`: it's not magic!
04:26:48 <ivanm> and not always right
04:26:49 <drdo`> quicksilver: is that how haskell-mode does it there?
04:26:54 <ivanm> check out the tab-indent-cycle
04:26:54 <mmorrow> b_jonas: and i guess manual mem management and strict eval are also big factors
04:27:07 <b_jonas> mmorrow: yes
04:27:07 <drdo`> ivanm: i tried it man
04:27:14 <drdo`> that's the least horrible option
04:27:33 <ivanm> drdo`: I'd take the "= do" onto the next line for starters
04:28:00 <ivanm> align (Just rect) with (screen world)
04:28:22 <mmorrow> int-e: i've never thought to unsafePerformIO a threadDelay. this could be entertaining... ;)
04:28:32 <drdo`> ivanm: that's what i want, but haskell-mode won't do it
04:28:46 <ivanm> drdo`: as I said, it isn't magic
04:28:47 <dolio> drdo`: That's now how the kuribas indentation mode works here.
04:28:51 <int-e> drdo`: how about  http://pastebin.com/m1b7c2d8b?
04:28:56 <ivanm> dolio: it has a name? :o
04:28:58 <mmorrow> (in a hacktastic kind of way :)
04:29:09 <drdo`> kuribas?
04:29:29 <dolio> The one that quicksilver told you to try 10 minutes ago.
04:29:29 <drdo`> oh
04:29:40 <int-e> mmorrow: heh, I just needed a long running but terminating computation :)
04:29:47 <dolio> Not how, I should say. Not "now how".
04:29:54 <drdo`> int-e: that looks good
04:30:06 <drdo`> i'd write something like that
04:30:12 <drdo`> my point is, haskell-mode sucks
04:31:27 <dolio> I actually liked the vim indentation I had.
04:31:31 <dolio> But it's not perfect, either.
04:31:45 <ivanm> dolio: does that mode come with haskell-mode?
04:31:52 <drdo`> How does one customize vim?
04:32:08 <drdo`> other than the obvious edtiting the C code and recompiling
04:32:12 <mmorrow> with a wand, magic, and evil
04:32:17 <dolio> I don't remember where I got it. I think it's available on some vim script download site.
04:34:27 <drdo`> editing in vim is just pure pain
04:34:52 <dolio> I stopped using vim, though, because Agda requires you to use emacs (more or less), and switching between vim mode and emacs mode in my head is too much work.
04:34:55 <int-e> drdo`: I'm using haskell-mode but I have to admit that I'm rather often indenting manually.
04:35:07 <int-e> drdo`: certainly more often than I'd like
04:35:15 <drdo`> int-e: :S
04:35:26 <ivanm> dolio: you couldn't use viper mode or something?
04:35:32 <drdo`> I have this habit of spamming Tab
04:35:40 <drdo`> and that'll ruin my indentation
04:35:48 <PeakerWork> int-e: the indent offsets of the default haskell-mode are pretty horrible for do blocks
04:35:56 <PeakerWork> and the cycle is exactly the reverse order from what it should be
04:36:15 <int-e> PeakerWork: I've done some customization (do blocks are mostly fine)
04:36:26 <dolio> Maybe. But just using viper for a day or so gave me the impression that there were lots of small differences that would throw me off.
04:36:38 <dolio> Not that I was a vim guru or anything.
04:36:47 <drdo`> int-e: can i have it? :)
04:37:06 <dolio> I'm also too lazy to put in the work making viper and vim do exactly the same thing in all cases.
04:37:24 <int-e> drdo`: http://hpaste.org/13314
04:38:14 <drdo`> I don't have a turn-on-haskell-indent function
04:38:21 <PeakerWork> int-e: thanks
04:38:27 <drdo`> i do have turn-on-haskell-simple-indent
04:39:20 <int-e> turn-on-haskell-indent enables the cycle-through-possibilities mechanism, IIRC.
04:39:24 <PeakerWork> int-e: weird behavior for do indents there, but better than default
04:39:38 <PeakerWork> My default Haskell thingie had the indent stuff already on
04:41:30 <quicksilver> drdo`: No.
04:41:53 <quicksilver> drdo`: the haskell indentation mode I linked would have put 'fillRect' 2 chars more indented than 'draw world'
04:42:00 <int-e> PeakerWork: you can play with the numbers obviously. (it seems that 2 is the indent after a "do" all by itself on a line, while the 4 is the indent for a line with more stuff before the  do  keyword.
04:43:13 <PeakerWork> int-e: I think its a little buggy, but when it works, its that way yeah
04:43:27 <quicksilver> drdo`: http://hpaste.org/13315
04:43:37 <quicksilver> drdo`: is how haskell-indentation does it.
04:43:40 <PeakerWork> its GNU Emacs 23.0.60.1 -- so probably a buggy snapshot - so they have excuses
04:44:17 <quicksilver> int-e: I find kuribas-indentation greatly preferable to that behaviour.
04:45:12 <quicksilver> it does TAB for next possible position to the right, BACKSPACE for the left, and only where there genuinely are multiple possibilities
04:45:15 <quicksilver> (because of nested layout)
04:45:22 <quicksilver> otherwise it gives you one and one only
04:45:23 <drdo`> quicksilver: working now, but it's still not right
04:45:30 <quicksilver> and its parser is more accurate too
04:45:48 <PeakerWork> quicksilver: what if you want to continue some expression on the next line? That's always extra options
04:46:10 <drdo`> "(round (fst p))" should be aligned with "(round (snd p))"
04:46:20 <quicksilver> PeakerWork: yes, that's a nested example
04:46:39 <quicksilver> PeakerWork: if you have a layout block, there are always the choices of "continue this expression" and "next line in 'block'"
04:46:45 <quicksilver> with more nesting, of course, it's more choices.
04:47:09 <quicksilver> drdo`: I can understand why you would like that, but I'm happy with the current situation.
04:47:23 <quicksilver> drdo`: often I will put (round (fst p)) on a new line, in a case like this
04:47:33 <quicksilver> assuming that, in practice, the expressions are a bit longer anyway
04:47:38 <drdo`> i see
04:48:04 <quicksilver> it's certainly much better than haskell-mode's build in indentation :)
04:48:41 <drdo`> it is
04:49:01 * maltem is curious how good yi's indenting is. yi doesn't have auto-indent yet, so there is not much opportunity to find out
04:49:25 <quicksilver> drdo`: for literally that code, I'd put the whole (Just (Rect ....)) on one line
04:49:28 <quicksilver> since it fits fine.
04:49:48 <quicksilver> but if the subexpressions were a little longer I'd split it as with each of the 4 parameters on a line by itself, probably.
04:50:17 <drdo`> quicksilver: it isn't very readable all in one line
04:50:32 <quicksilver> well that's subjective. Looks fine to me.
04:51:02 <quicksilver> I'd also bind p and s as tuples
04:51:14 <quicksilver> position = (px,py)
04:52:13 <quicksilver> http://hpaste.org/13315#a1
04:52:32 <quicksilver> might be what I'd write in practice
04:52:38 <quicksilver> and also in practise
04:53:03 <drdo`> that's a good idea actually
04:53:19 <int-e> quicksilver: you didn't see http://pastebin.com/m1b7c2d8b , did you? :)
04:53:33 <ivanm> quicksilver: didn't you spell it right the first time?
04:53:34 <quicksilver> int-e: apparently not.
04:53:56 <quicksilver> ivanm: Yup.
04:54:08 <quicksilver> ivanm: it was a not-very-good pun.
04:54:26 <quicksilver> the second form is the verbal spelling, which has the connotation "only practising"
04:54:37 <ivanm> O...K...
04:54:43 * ivanm backs away from quicksilver 
04:55:47 <osfameron> can you use "practise" (vb) as a noun?
04:56:01 <osfameron> you certainly don't say "in rehearse"
04:56:39 <quicksilver> osfameron: you can't, no.
04:56:46 <quicksilver> well I did. But incorrectly.
04:57:14 <osfameron> ah well, all's fair in love and puns
04:57:24 <ivanm> *groan*
04:57:34 <mmorrow> sure you can use practise as a noun
04:57:45 <ivanm> osfameron: OK, you've achieved your required punny groand, you and quicksilver can stop trying now ;-)
04:58:04 <osfameron> I'm not sure mine even qualified as a pun...
04:58:17 * mmorrow starts to think he spoke without knowing the context
04:58:42 <ivanm> mmorrow: run while you still can!
05:02:31 <Axman6> merry christmas haskellians (from the east of Aus)
05:03:10 <Adamant> Axman6: watch out for Robot Santa
05:03:18 <Axman6> :o
05:03:38 <PeakerWork> quicksilver: that wouldn't be what you write in practice, because you hate type-classes :)
05:05:31 <ivanm> Axman6: you're an hour early! :o
05:05:42 <quicksilver> PeakerWork: yes, that's true.
05:05:49 <quicksilver> PeakerWork: I wouldn't have a drawable typeclass at all.
05:05:52 <Axman6> you're an hour late! now go read your RWH and leave me alone :(
05:06:38 <b_jonas> Adamant: isn't it alien santa?
05:06:40 <ivanm> Axman6: ummmm..... we're UTC+10 ... as such, it's 11PM here...
05:07:08 <Axman6> my clock's telling me it's 12PM. we're +10+DST
05:07:12 <Adamant> b_jonas: no, Robot Santa comes at X-Mas, and because everyone is bad, we all get punished
05:07:25 <b_jonas> Adamant: alien santa is at http://www.savagechickens.com/2008/12/holiday-special.html
05:07:34 <ivanm> Axman6: yes, but DST /= real time ;-)
05:07:39 <dolio> Not everyone.
05:07:41 <dolio> Zoidberg is nice.
05:07:45 <Axman6> yeah it does
05:07:51 <Axman6> it's Axman's time!
05:08:16 <Adamant> ah, Robot Santa is Futurama
05:08:45 <Adamant> I'll take my chances with Robot Santa and avoid chest-bursters kthanxbye
05:54:31 <paolin1> quicksilver: I found this http://www.haskell.org/haskellwiki/Haskell_Quiz/Astar/Solution_Dolio, it takes 1 minute to build a queue with 20000 elements
05:57:03 <dolio> Is that good or bad?
05:57:28 <dolio> Sounds bad. :)
05:57:34 <paolin1> yes
05:58:02 <efficientjelly> oh. right. I can't name an operator (..)
05:58:28 <paolin1> at least by a factor 100 or 1000 to my feelings
05:58:53 <dolio> Well, I didn't do any work optimizing it. :)
05:59:05 <dolio> I pretty much lifted it verbatim out of Okasaki's book.
05:59:29 <PeakerWork> How do I create multi-line literal strings?
06:00:15 <paolin1> to have a huge constant in front of O(log n)
06:00:29 <paolin1> insert seems *
06:00:30 <efficientjelly> hmm. is there a way to turn on glasgow extensions interactively in ghci?
06:00:37 <paolin1> :set
06:00:47 <BONUS> :set -fglasgow-exts
06:00:53 <efficientjelly> perfect, thanks.
06:00:55 <twadleigh> PeakerWork: ++
06:01:00 <PeakerWork> twadleigh: yikes
06:01:42 <twadleigh> PeakerWork: there's (not yet, at least) a Haskell analog of a "here doc"
06:02:04 <PeakerWork> I'd like a """ like in Python :P
06:02:09 <lilac> PeakerWork: you put a \ at the end and start of each line
06:02:19 <PeakerWork> lilac: and start?
06:02:38 <PeakerWork> why in the start?
06:02:39 <lilac> PeakerWork: as in, "foo foo!\<newline>  \bar bar!" -> "foo foo!bar bar!"
06:02:49 <twanvl> > "foo\              \bar"
06:02:51 <lambdabot>   "foobar"
06:02:54 <PeakerWork> ah
06:02:56 <PeakerWork> thanks
06:02:56 <paolin1>  pling\
06:02:56 <paolin1>  \plong
06:02:58 <lilac> backslash, then whitespace, then backslash is stripped
06:03:07 <SamB_XP> Peaker: "string gap"
06:03:15 <SamB_XP> that's what it's called
06:03:29 <PeakerWork> thanks
06:03:31 <SamB_XP> that way, you can align it however you like
06:03:33 <PeakerWork> weird!
06:03:39 <PeakerWork> but its usable
06:03:54 <SamB_XP> without hax like Python's docstrings need
06:06:16 <lilac> PeakerWork: note http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveStringGaps
06:06:19 <dolio> paolin1: You could try adding a bang to the first PriorityQueue k a in Branch. That would match Okasaki's ML version more closely.
06:06:26 <dolio> I doubt that'll make much of a difference.
06:07:02 <lilac> PeakerWork: actually, never mind, looks like that proposal has been rejected for haskell'
06:07:52 <PeakerWork> ah
06:07:58 <PeakerWork> I doubt it matters that much
06:11:18 * quicksilver thinkgs 
06:11:22 <quicksilver> string gaps look horrid.
06:11:32 <quicksilver> I either use concat ["blah",\n"blah"]
06:11:34 <quicksilver> (or unlines)
06:11:39 <quicksilver> or I use an external file.
06:12:32 <PeakerWork> quicksilver: thanks
06:12:37 <PeakerWork> unlines sounds good
06:12:44 <BONUS> i like ++
06:13:26 <mmorrow> breadth-first numbering haskell algo from the okasaki paper: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=676#a676
06:14:01 <mmorrow> (one of them)
06:14:14 <mmorrow> clever
06:14:58 <paolin1> dolio nothing really
06:15:56 <dolio> paolin1: Actually, looking at his code again, it looks like I did something different than he's doing.
06:16:03 <dolio> What are you using as a benchmark?
06:18:47 <paolin1> benchmark being ?
06:19:05 <paolin1> the code ?
06:20:01 <paolin1> ... probably the machine and system ...
06:20:17 <dolio> Yeah, the code.
06:20:26 <dolio> So I can see if his actual implementation makes a difference.
06:20:35 <dolio> It's actually simple.
06:21:37 <dolio> Change "link (Branch k a ll lr) r = ..." to "link (Branch k a ll lr) r = Branch k a Nil (merge (merge r ll) lr)"
06:22:08 <paolin1> http://hpaste.org/13316
06:22:15 <dolio> Sorry, that should be union, not merge.
06:23:47 <dolio> Oh...
06:23:47 <paolin1> ayea
06:24:13 <dolio> Have you tested how long it takes to generate 20,000 random numbers using the standard library generator?
06:24:14 <paolin1> dolio ++
06:24:26 <paolin1> 1 sec now
06:24:42 <dolio> Hey, good. :)
06:24:51 <dolio> Yeah, of course, not 1 minute.
06:24:53 <dolio> :)
06:25:53 <quicksilver> heh.
06:25:56 <quicksilver> excellent!
06:26:00 <quicksilver> dolio++
06:26:27 <quicksilver> dolio: was that incorrect behaviour, or correct behaviour but incorrect complexity?
06:27:11 <drdozer> my code in MonadRandom still slows down as it runs :(
06:27:37 <dolio> I'm actually not seeing that much of a difference.
06:27:41 <quicksilver> drdozer: probably accumulating thunks of unreduced random numbers.
06:27:44 <dolio> In fact, here, the old version seems to be faster.
06:27:47 <quicksilver> drdozer: does it also leak memory?
06:28:06 <paolin1> urgh
06:28:56 <dolio> Wait, now it's happening.
06:29:07 <quicksilver> dolio: yay non determinism :P
06:29:13 <dolio> Wasn't re-compiling the priority queue or something.
06:32:14 <dolio> Apparently the performance of the queue didn't affect that of my A* implementation much.
06:35:43 <paolin1> with 200000 I have a stack overflow
06:38:46 <dolio> paolin1: Change fromList from foldr to foldl'.
06:39:12 <dolio> paolin1: That makes it another order of magnitude faster.
06:40:28 <paolin1> and not overflow the stack
06:40:57 <paolin1> now it's usable
06:42:25 <paolin1> 20 sec for 2 millions entries :)
06:42:38 <dolio> Is it better than PSQueue on hackage?
06:43:05 <dolio> I suppose that has issues if your values aren't in Ord.
06:43:40 <paolin1> I did't see that before
06:44:38 <dolio> This implementation should also be in the edison packages.
06:45:42 <dolio> Although, looks like it's fancier than what I have on that page.
06:47:04 <quicksilver> is a monoid-parameterisable fingertree on hackage yet?
06:47:17 <dolio> I thought so.
06:47:29 <paolin1> mmhh, a bug in xmonad ... it draws a square with a circle in the middle on the left half of the screen
06:47:57 <quicksilver> http://hackage.haskell.org/packages/archive/fingertree/0.0/doc/html/Data-FingerTree.html
06:48:00 <quicksilver> looks like it
06:48:07 <paolin1> funny, it never happened before, and probably never more
06:48:15 <quicksilver> dolio: isn't there a measure which makes a fingertree into a pqueue?
06:48:45 <dolio> Someone mentioned on haskell-cafe that you could make a priority queue out of finger trees, yes.
06:49:59 * quicksilver hasn't internalised all the neat things you can do with fingertrees.
06:50:10 <quicksilver> but I have noticed it 's a remarkable list.
06:50:12 <dolio> Looks like the main difference in the edison package is that they make "Branch k Nil r" into an extra constructor case.
06:50:41 <dolio> Yeah, I really need to get around to digging into that stuff.
06:50:56 <dolio> I really have no idea how you'd turn a finger tree into a priority queue.
06:55:07 <ziman> I used a pair of AVL trees in my dijkstra algorithm
06:56:23 <ziman> they're O(log n) for extract-min and decrease-key
06:56:55 <quicksilver> even after you amortise the cost of the balancing?
06:56:57 <mlesniak> Are there any packages (or papers, ...) for distributed computing in haskell? Glasgow distributed Haskell *seems* to be outdated and erlang-style haskell, too.
06:57:18 <quicksilver> mlesniak: I'm not aware of any recent work in this area.
06:57:48 <mlesniak> quicksilver: Ok, thanks for the hint
06:57:57 <ziman> an AVL tree does at most O(log n) constant-time balancings at insertion and at most one constant-time balancing at deletion, iirc
06:58:39 <ziman> s/balancings/rotations/g
06:58:58 <BONUS> actually i think it can do more on deletion
06:59:04 <BONUS> cause you have to balance it all the way up
06:59:51 <dolio> paolin1: PSQueue seems to have comparable performance, down to fromList being a stack overflow for 200,000.
07:01:24 <helgim_> asdf
07:01:28 <dolio> (And being fixed by using foldl')
07:01:54 <b_jonas> isn't it the other way?
07:01:58 <b_jonas> oh well, it doesn't matter
07:03:08 <ziman> maybe; anyway, it should be O(log n) worst-case. I expect the constants be quite large, though.
07:03:55 <ziman> *to be
07:09:13 <mmorrow> dolio: i optimized/specialized your PriorityQueue a bit (used IntMap for guidance) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=677#a677
07:09:57 <PeakerWork> is an instance of MonadError for Maybe defined anywhere?
07:10:16 <quicksilver> not as far as I know, no.
07:10:24 <PeakerWork> weird
07:10:28 <PeakerWork> its a trivial instance..?
07:10:35 <quicksilver> well MonadError is pretty weird
07:10:39 <b_jonas> yeah
07:10:40 <mmorrow> looks like you do in fact want foldl' for fromList (IntMap does this)
07:10:43 <b_jonas> it has some string thingies
07:10:52 <dolio> mmorrow: The second PQ in Bin being lazy is part of the data structure.
07:11:14 <mmorrow> oh crap
07:11:23 <PeakerWork> oh, you need to be able to give the actual error in catchError
07:11:38 <vixey> hi
07:11:43 <ehird> :t repeat
07:11:45 <lambdabot> forall a. a -> [a]
07:11:46 <mmorrow> dolio: so then i should just ditch the bang on just that one then?
07:11:46 <ehird> :t cycle
07:11:47 <lambdabot> forall a. [a] -> [a]
07:11:47 <PeakerWork> Doh, I want a type-class to abstract away the difference between putting my code in Maybe, and putting it in Either, etc
07:11:54 <dolio> mmorrow: Yes.
07:12:04 <b_jonas> PeakerWork: MonadPlus?
07:12:07 <PeakerWork> so I can throwError (optionally retaining or dumping exception information), and not necessarily be able to catch error
07:12:24 <PeakerWork> b_jonas: mzero has no exception information?
07:12:31 <PeakerWork> b_jonas: and I am not sure what I need mplus for..
07:12:54 <ehird> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split My word. It's about bloody time!!
07:13:09 <b_jonas> why'd you want to abstract that away? can't yuo count on lazyness so if you don't examine the error in an either it's not calculated??
07:13:12 <mmorrow> also, i'm not sure if that extra strictness in toList is worth it (or if it in fact is hurtful?)
07:13:20 <quicksilver> augustss_: does the llvm binding optimise code?
07:13:21 <b_jonas> or you'd like to conserve memory as well?
07:13:32 <mmorrow> i kinda started shooting at anything that moved at that point
07:13:41 <b_jonas> you may have to write your own class though
07:13:47 <b_jonas> if you don't find exactly what you want
07:14:36 <PeakerWork> b_jonas: I don't necessarily care about the error
07:14:41 <mmorrow> dolio: fixed: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=677#a678
07:14:58 <PeakerWork> b_jonas: I have code that parses an XML -- its currently in Maybe, but I dislike my very specific types that mean I cannot later add error information in case I want to know where parses failed exactly
07:15:41 <dolio> mmorrow: You're implementing foldl' yourself? :)
07:15:57 <mmorrow> dolio: heh, i just couldn't bring myself to import Data.List :)
07:15:58 <dolio> And using the version that can't be inlined and specialized as well? :)
07:16:08 <mmorrow> hmm, how do you mean?
07:17:34 <vixey> btw your foldl is much more readable with that <>
07:17:47 <mmorrow> dolio: how do you mean that? i suddenly fear that all my local defs of foldl' have been hurting me
07:17:53 <vixey> (instead of "f")a
07:18:05 <mmorrow> vixey: yeah, the ! and the <> make it purdy :)
07:18:12 <dolio> mmorrow: "foldl' (<>) = go where go z [] = z ; go z (x:xs) = go (z <> x) xs" is better for the optimizer.
07:18:34 <dolio> With appropriate bangs that I left out.
07:19:13 <mmorrow> dolio: ohhh, good. that was actually the first time i've defined it that way. my thought process was that that would elim the initial check for [] (since it only happens at the end).
07:19:28 <mmorrow> so that was not a good thought process then i guess
07:19:46 <b_jonas> PeakerWork: but if you don't care about it, don't evaluate the inside of the Left
07:20:01 <b_jonas> PeakerWork: just like how you don't care about all infinite elements of an infinite list, yet sometimes you use them
07:20:06 <PeakerWork> b_jonas: How can I get all my functions to not care if they return a Maybe or an Either?
07:20:07 <b_jonas> this is why we have a lazy langauge
07:20:10 <dolio> mmorrow: The important thing is that that version can be inlined so that (<>) is known, and can be specialized.
07:20:14 <PeakerWork> b_jonas: but still be able to "throw" an error?
07:20:16 <mmorrow> IntMap puts the Nil r and l Nil cases at the end of union, which made me think to apply that that to foldl'
07:20:19 <b_jonas> jsut always return an Either
07:20:21 <PeakerWork> b_jonas: My problem is not about laziness
07:20:29 <mmorrow> dolio: oh, i see.
07:20:40 <orbitz> return a Maybe Either!
07:20:42 <Saizan> PeakerWork: use the MonadError class
07:20:45 <PeakerWork> b_jonas: I don't want to return an Either, I want the code not to care in which monad it is, currently its all in Maybe and Maybe is easier to compose than Either
07:20:57 <PeakerWork> Saizan: That's what I wanted, but then I discovered MonadError can't have a Maybe instance because it has catchError
07:21:03 <dolio> GHC is supposedly getting an optimization that can do that automatically, but even the heuristic that was current last I checked wouldn't do it for foldl', because it's only one argument.
07:21:07 <quicksilver> PeakerWork: You could use MonadPlus
07:21:21 <PeakerWork> quicksilver: But how do I "throw" an error with an extra information in MonadPlus?
07:21:33 <quicksilver> PeakerWork: fail "extra rubbish"
07:21:43 <vixey> this is readP balanced = between (string "(") (string ")") balanced +++ return ()
07:21:52 <PeakerWork> quicksilver: That's just Strings, though, yuckY :)
07:21:53 <mmorrow> dolio: hmm, so in this case do you think i should flip the cases around, or specialize it for use in fromList?
07:22:01 <SamB_XP> Peaker: try MonadError ;-P
07:22:02 <quicksilver> PeakerWork: I don't understand, though.
07:22:13 <PeakerWork> quicksilver: that way I can just use Monad (and actually use fail)...
07:22:16 <quicksilver> PeakerWork: surely currently your Maybe code doesn't have any error codes in it?
07:22:22 <dolio> mmorrow: Of course, last I checked, the optimization wasn't firing for anything in 6.10, so they must have left it out.
07:22:29 <b_jonas> quicksilver: would that work? doesn't the extra rubbish get lost in an either too?
07:22:30 <PeakerWork> quicksilver: Right, but it would be nicer to add actual errors and not just stringy ones
07:22:30 <quicksilver> PeakerWork: no, because if you just use Monad you don't have `mplus`
07:22:35 * mmorrow should start checking that stuff
07:22:38 <dolio> mmorrow: I don't think the case order will make a difference.
07:22:39 <PeakerWork> SamB_XP: that doesn't have a Maybe instance
07:22:44 <quicksilver> b_jonas: no.
07:22:46 * mmorrow specializes it for fromList
07:22:52 <SamB_XP> PeakerWork: point
07:22:55 <quicksilver> b_jonas: fail = throwError (strMsg "extra rubbish")
07:23:06 <PeakerWork> quicksilver: fail _ `mplus` x     will return x?
07:23:16 <quicksilver> PeakerWork: OK, so if you're adding actual errors, what is your problem with using MonadError then?
07:23:23 <quicksilver> PeakerWork: correct.
07:23:24 <PeakerWork> quicksilver: that Maybe can't have an instance
07:23:38 <quicksilver> because you have some code which uses maybe and you want to reuse that?
07:25:03 <PeakerWork> quicksilver: yeah, maybe composes easily, so I can avoid the generality but still reuse the same general code if I want
07:25:09 <quicksilver> ok, well that's easy
07:25:19 <quicksilver> there is a trivial way to embed existing Maybe code into MonadError
07:25:23 <PeakerWork> quicksilver: MonadPlus is fine, but its not perfect (only string errors)
07:25:33 <PeakerWork> how?
07:25:40 <quicksilver> :t maybe (throwError "Error in legacy Maybe code")
07:25:41 <lambdabot> forall (m :: * -> *) a a1. (MonadError [Char] m) => (a1 -> m a) -> Maybe a1 -> m a
07:25:50 <quicksilver> :t maybe (throwError "Error in legacy Maybe code") return
07:25:51 <lambdabot> forall (m :: * -> *) a. (MonadError [Char] m) => Maybe a -> m a
07:26:00 <quicksilver> there is your embedder.
07:26:04 <quicksilver> Maybe a -> m a
07:26:11 <quicksilver> for any MonadError m.
07:26:25 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=677#a679
07:26:31 <quicksilver> you don't have to use a string, there obviously
07:26:38 <quicksilver> it could be your chosen error type
07:26:56 <quicksilver> maybe (throwError LegacyMaybeCodeError) return
07:27:25 <quicksilver> I wonder why you think maybe composes more easily than MonadError, though?
07:27:27 <mmorrow> , char
07:27:33 <lunabot>  luna: No instance for (GHC.Show.Show
07:27:36 <quicksilver> all the ways maybe composes should apply to MonadError.
07:28:11 <quicksilver> the main advantage of the embedder is reusing chunks of code which have already been written in Maybe and which you don't feel like changing.
07:28:39 <dolio> mmorrow: Are you sure that code for insert is right?
07:29:29 <dolio> mmorrow: It doesn't look right to me. It doesn't even check if the key you're inserting is the minimum key in the heap.
07:29:40 <PeakerWork> quicksilver: No no, I want the _general_ code to be "castable" to Maybe, not from Maybe
07:29:45 <dolio> Same for the inlined version in fromList.
07:30:09 <quicksilver> PeakerWork: throwing away the error messages?
07:30:13 <PeakerWork> quicksilver: IOW:   maybe (return ()) print (generalErrorThrowingFunc)
07:30:14 <PeakerWork> quicksilver: yeah
07:30:21 <quicksilver> PeakerWork: well that's obviously not possible.
07:30:22 <PeakerWork> quicksilver: s/messages/error thingies
07:30:28 <quicksilver> ErrorT IO is an instance of MonadError
07:30:33 <quicksilver> good luck casting that to maybe.
07:30:41 <dolio> And you don't need to put foldl' in a where clause in fromList. You just need to write it with the static argument transform for (<>).
07:30:50 <PeakerWork> quicksilver: I guess I shouldn't have said cast
07:31:07 <quicksilver> then write the bogus MonadError instance for Maybe
07:31:09 <quicksilver> it's not hard :)
07:31:10 <dolio> Assuming that actually makes a difference in this case.
07:31:13 <quicksilver> but it's a strange thing to do.
07:31:30 <PeakerWork> quicksilver: I mean, I want to have:  genericFunc :: MonadError e m => blah -> m a      and be able to use genericFunc to return a Maybe value throwing away the error thingies, or using it to generate an Either with the errors, or anything elsee
07:31:39 <PeakerWork> quicksilver: how do you implement catchError in Maybe?
07:31:46 <PeakerWork> @type catchError
07:31:47 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
07:32:05 <vixey> PeakerWork: Why don't you just figurre out if you want to use Either or Just before writing the code?
07:32:07 <idnar> @type fromMaybe
07:32:08 <lambdabot> forall a. a -> Maybe a -> a
07:32:09 * SamB_XP hates the discarding of meaningful error messages :-(
07:32:47 <idnar> hm no
07:32:57 <quicksilver> instance MonadError () Maybe where throwError = \() -> Nothing; catchError a f = a `mplus` f ()
07:33:03 <quicksilver> PeakerWork: like that.
07:39:33 <PeakerWork> vixey: I like general code :)
07:39:51 <PeakerWork> vixey: admittedly, its more of an educational experiment than a real world requirement
07:40:16 <quicksilver> PeakerWork: Yes, I agree with your instincts and disagree with vixey.
07:40:27 <quicksilver> but not that I advisedly made it an instance of MonadError ()
07:40:30 <vixey> quicksilver, disagree with me? what have I said?
07:40:36 <quicksilver> not MonadError e for some general e.
07:40:56 <PeakerWork> quicksilver: That doesn't allow "losing" error information from general code
07:41:02 <PeakerWork> quicksilver: I guess it does through some adapter
07:41:09 <quicksilver> because if your MonadError e actions contains some internal catching which discriminates on the value of the exception
07:41:16 <quicksilver> than how can you hope to coerce that to maybe?
07:41:32 <quicksilver> in the Maybe type, the discrimination is no longer possible so the internal catching breaks.
07:41:42 <PeakerWork> quicksilver: I'd like a MonadError e instance open forall e. that just discards the 'e' completely..
07:41:50 <quicksilver> forcing the type to () limits the catching to the non-discriminatory one.
07:41:56 <quicksilver> PeakerWork: please read the reasoning I just gave.
07:42:11 <quicksilver> you can't discard the e if it's being used to discriminate in a catch.
07:42:14 <PeakerWork> quicksilver: yeah, what if MonadError had separated catchError into a more specific class?
07:42:20 <lilac> PeakerWork: that can't work. you'd need "catchError a f = a `mplus` f undefined"
07:42:31 <vixey> quicksilver: what are you disagreeing with? .. just "me" in general?
07:42:48 <quicksilver> vixey: "< vixey> PeakerWork: Why don't you just figurre out if you want to use Either or Just before writing the code?"
07:42:58 <lilac> PeakerWork: you could always use 'fail' instead of throwError *ducks*
07:43:31 <quicksilver> PeakerWork: you could ask for an annotated monadzero with no inspection of the annotaitons, yes.
07:43:38 <quicksilver> I think that's a slightly obscure thing to want :)
07:43:42 <quicksilver> but you could ask for it.
07:43:49 <lilac> PeakerWork: does the function you wish to write take an 'm a' as argument?
07:44:18 <vixey> quicksilver: I'm not telling him to chose I'm asking about why he didn't
07:44:35 <quicksilver> PeakerWork: (note that if you gave me a function of type forall e. .... then that would be fine, because given a universal I can choose to set e = ())
07:44:38 <PeakerWork> quicksilver: I think eventually I'll just create my own MonadError that only has throwError but not catch
07:44:50 <quicksilver> vixey: fairenough.
07:45:32 <lilac> PeakerWork: if your function doesn't take 'm a' as argument, then I side with vixey. just return Either e a for some e and a
07:45:33 <PeakerWork> vixey: I chose Maybe - and it was actually fine, I didn't have problems. But I was worried that out of the many places that can "throw", and lacking a good Haskell debugger, I'll have a hard time figuring out where errors come from
07:45:56 <lilac> PeakerWork: converting from Either to whatever your client code wants will be trivial
07:46:05 <vixey> I like to find a programming style that does not involved debugging
07:46:13 <adrian> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlint is a blank page for me
07:46:16 <lilac> PeakerWork: for what it's worth, it's what Data.Map.lookup does these days
07:46:59 <quicksilver> adrian: there seem to be some strange bugs with hackage at the moment
07:47:04 <quicksilver> (or the web page part of it, at least)
07:47:09 <adrian> hm
07:47:11 <lilac> PeakerWork: that is, it uses the most specific type which gives you the most general interface
07:47:11 <adrian> thanks
07:47:14 <adrian> I'll try later
07:47:18 <quicksilver> @quote mckenna
07:47:19 <lambdabot> No quotes match. My mind is going. I can feel it.
07:47:22 <quicksilver> hmm
07:47:24 <quicksilver> @quote initial
07:47:24 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
07:47:30 <quicksilver> ah, I can't sepll his name.
07:47:36 <quicksilver> ^^ another vote in favour of Either e.
07:47:39 <quicksilver> if that is indeed what you want.
07:47:49 <centrinia> What does it mean for a grammar to be as expressive as a Turing machine?
07:47:54 <quicksilver> I thought you were doing the opposite transform at first.
07:48:01 <mmorrow> vixey: lunabot has ReadP
07:48:07 <vixey> centrinia: You can program turing machines in it
07:48:11 <mmorrow> , runP (let go n p = between (char '(') (char ')') (go (n+1) p) <++ (p >> return n) in go 0 (return())) "(((())))"
07:48:15 <lunabot>  ([4],"")
07:48:19 <lilac> PeakerWork: note, if your function takes an /argument/ of form "m a" then uses (>>=) on it, this doesn't work, since Either is not the free MonadError
07:48:26 <vixey> mmorrow, aha
07:48:42 <lilac> but Either is the free instance of [return + throwError + catchError], AFAICS
07:48:51 <paolin1> @hoogle assert
07:48:51 <lambdabot> Control.Exception assert :: Bool -> a -> a
07:48:51 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
07:48:51 <lambdabot> Test.HUnit.Base class Assertable t
07:48:56 <mmorrow> runP and runP' are first result and longest result respectively http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=680#a680
07:48:57 <vixey> mmorrow, I maybe decided too quickly but I prefer ReadP to ReadPrec, ReadPrec seems useless
07:49:14 <mmorrow> vixey: i haven't really used ReadPrec yet
07:49:25 <mmorrow> i'm not quite sure what to make of it
07:49:43 <centrinia> How do you program with a grammar?
07:49:52 <augustss_> @seen quicksilver
07:49:52 <lambdabot> quicksilver is in #haskell-soc, #ghc and #haskell. I last heard quicksilver speak 1m 58s ago.
07:50:00 <quicksilver> augustss_: hello?
07:50:17 <Botje> centrinia: hmm?
07:50:32 <vixey> centrinia: Same as a programming language
07:50:44 <mmorrow> vixey: i was thinking about precedence parsing though. i think the best thing to do is to fix up the AST after an initial parsing pass (since what if you don't see an infix{r,l} n _ until the last line)
07:50:49 <augustss_> quicksilver: the default setting for the llvm stuff is to do some minor optimizations, it looks like.  I have yet to set up the pass manager to do something serious.
07:51:06 <quicksilver> augustss_: *nod*
07:51:08 <vixey> mmorrow, me too
07:51:10 <dolio> centrinia: The idea is that one formalism of turing machines is that they start with some sequence of symbols on the tape, and eventually it may accept or reject that sequence of symbols (or maybe it doesn't ever terminate).
07:51:26 <dolio> So the language defined by that Turing machine is the set of sequences that it accepts.
07:51:28 <mmorrow> vixey: plus it's a total hassle to do on top of parsing ;)
07:51:33 <augustss_> quicksilver: you can write to file and run the standalone optimizer
07:51:33 <quicksilver> augustss_: I have a long running background project to write a query language. I had been toying with the idea of generating haskell code and using GHC to compile it on the fly.
07:51:48 <quicksilver> augustss_: I wondered if llvm might be an alternative.
07:51:49 <vixey> mmorrow, it's very simple http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=681#a681
07:51:57 <dolio> And presumably, a grammar is equivalent to that Turing machine in some way if it denotes the same language.
07:52:06 <lilac> dolio: sounds equivalent to saying it's the set of initial states for which the machine halts?
07:52:15 <vixey> mmorrow, I'm impressed how easy this worked out but of course I am never 100% sure this parser does what I think it does
07:52:17 <augustss_> quicksilver: llvm can do a really good job is speed is what you need
07:52:20 <centrinia> dolio: Thanks. Is there a way to convert a grammar into a Turing machine that only accepts strings from the corresponding language and vice versa?
07:52:41 <lilac> dolio: which in turn is equivalent to saying the grammar is recursively enumerable
07:52:50 <mmorrow> vixey: awesome! /me reads messes with it
07:52:56 <augustss_> centrinia: grammar expressed how?
07:53:01 <dolio> lilac: That sounds right.
07:53:01 <quicksilver> augustss_: it is, yes. but I need to process "custom data types" and Im' not sure how that will go.
07:53:18 <centrinia> A grammar expressed as a set of production rules perhaps?
07:53:18 <vixey> mmorrow, you can see my Prolog backgroud with the  reader (Middle o _) term = ...   bit :/
07:53:23 <dolio> Although recursively enumerable can be defined in a different way, too.
07:53:28 <vixey> I'm using ++> as !/0
07:53:29 <mmorrow> vixey: heh
07:53:30 <xenoterracide> http://privatepaste.com/7bq36nEqbr this doesn't work because of indentation... I'm trying to figure out what's off, I generally use a ts=4 but when I did s/  /\t/g the program wouldn't compile anymore. trying to undestand why
07:53:43 <vixey> (I got a 30 second delay for parsing terms like "((((((()))))))" without this optimization though)
07:53:57 <dolio> Where the machine starts with a blank tape and proceeds to write all the sequences on the tape somehow (possibly never completing).
07:54:06 <augustss_> centrinia: if they are context free rules it shouldn't be a problem
07:54:21 <vixey> I expected ReadP a bit more like PEG but no
07:54:27 <centrinia> augustss_: I think these grammars can be much more general.
07:54:40 <vixey> @go markov algorithm
07:54:42 <lambdabot> http://en.wikipedia.org/wiki/Markov_algorithm
07:54:42 <lambdabot> Title: Markov algorithm - Wikipedia, the free encyclopedia
07:55:02 <dolio> centrinia: I wouldn't expect it to be particularly easy, necessarily. Turing machines are kind of a pain to work with.
07:55:03 <PeakerWork> lilac: you mean, lookup returns Maybe without trying to be more general than it really is?
07:55:10 <vixey> centrinia, to blur the code/data distinction that's been built up, this article might help
07:55:16 <dolio> Depends on how the grammar is stated.
07:55:28 <centrinia> Okay, what about Lambda Calculus expressions?
07:55:46 <vixey> centrinia, ( http://en.wikipedia.org/wiki/Markov_algorithm )
07:55:48 <lilac> dolio: isn't the usual definition of RE in terms of recursive functions (with the Turing machine bit going via Church's Thesis)? :)
07:56:04 <dolio> That might be easier, depending on how much sugar you allow yourself.
07:56:06 <centrinia> Okay.
07:56:21 <lilac> PeakerWork: right. it used to be "Monad m => ... -> m a" but "... -> Maybe a" is just as general
07:56:33 <dolio> lilac: That may be. My classes on this topic totally elided the alternative formalisms.
07:56:54 <lilac> PeakerWork: (but only because the Monad's >>= isn't used)
07:57:30 <lilac> dolio: I did maths, so we were introduced to recursive functions before Turing machines, and we never saw lambda calculus :(
07:57:47 <dolio> Well, we never saw lambda calculus, either. :)
07:57:57 <vixey> but you can see lambda calculus outside of class
07:58:25 <ddarius> You don't need to see anything, you can calculate.
07:58:57 <SamB_XP> you can calculate blind ?
07:59:05 <SamB_XP> that's a good trick
07:59:08 <ddarius> SamB_XP: Sure
07:59:20 <quicksilver> lilac: I don't think so, no. Church's Thesis is basically "all sensible definitions of computability is equivalent". It's not really provable.
07:59:33 <quicksilver> lilac: Turing machine == RE is a theorem which can be, and is, proven.
07:59:37 <lilac> quicksilver: sure, but it /was/ proved for certain classes
08:00:09 <ddarius> "sensible definition of computability" == "equivalent to Turing machine"
08:00:29 <dolio> QED
08:00:35 <lilac> quicksilver: and saying that "Turing machine == RE is provable by the Turing machien == RE theorem" is kinda pointless :)
08:00:42 <vixey> morrow, lots of knot tieery as you can see, not sure it's sane
08:00:59 <vixey> morrow, (I want to use this for a real programming language)
08:01:01 <quicksilver> lilac: not what I'm trying to say.
08:01:15 <centrinia> If A and B are each equivalent to C, than A is equivalent to B. Church's These is just corollary. :p
08:01:21 <quicksilver> lilac: "Turing machine == RE" is not generally considered a 'consequence of' Church's Thesis.
08:01:37 <quicksilver> lilac: "Turing Machine == RE" is an interesting theorem, which is formally proved.
08:01:38 <dolio> lilac: You could give it a fancy all-caps acronym like computability theorists like to do.
08:01:59 <vixey> I called it mu-recursive
08:02:10 <vixey> instead of 'turing complete' I am bored of things being turing complete
08:02:32 <centrinia> Knot complete.
08:02:33 <Saizan> "Turing Machine == RE" supports Church's Thesis, not viceversa
08:02:36 <ddarius> vixey likes courting incomprehension
08:04:51 <gwern> dunno, surely we could disprove church's thesis if we had a physical mechanism for computing uncomputables, if you follow me
08:05:37 <vixey> gwern, my perpetual motion machine runs on one of those :)
08:05:43 <SamB_XP> gwern: that would mean we'd been using the wrong definition of computable all along
08:06:16 <lilac> quicksilver: wasn't the result that turing machines are general recursive actually proved by Church and Turing as part of the creation of Church's Thesis?
08:06:30 <gwern> SamB_XP: I'm not sure that is what it would mean
08:06:33 <centrinia> Aren't there descriptions of Real Computers that can do more than a Turing machine can do?
08:06:39 <SamB_XP> gwern: I'm pretty sure it is
08:06:55 <strht> i have a perpetual motion machine
08:06:58 <strht> wanna see?
08:07:00 <mmorrow> vixey: i've found this to be a nice reference for using ReadP for language parsing http://www.augustsson.net/Darcs/LambdaCube/CubeExpr.hs
08:07:10 <strht> @let perpetualMotion x = perpetualMotion x
08:07:12 <SamB_XP> if we made a machine that could compute things that aren't church-computable ... then we'd need a new definition of computable!
08:07:12 <lambdabot>  Defined.
08:07:14 <dolio> Real Computers that no one's actually really built?
08:07:17 <strht> > perpetualMotion 1
08:07:21 <vixey> why are you applying formal notions like "turing complete" to real world objects?
08:07:24 <centrinia> Yeah.
08:07:25 <quicksilver> centrinia: No.
08:07:29 <strht> watch it go!
08:07:33 <lambdabot>   thread killed
08:07:38 * strht kicks lambdabot
08:07:44 <centrinia> vixey, why not?
08:07:58 <centrinia> Uh, quicksilver. :p
08:08:05 <strht> centrina: NO
08:08:06 <gwern> SamB_XP: wikipedia quotes church as saying '"Every effectively calculable function (effectively decidable predicate) is general[1] recursive" '; if we could compute noncomputable things, then we would be computing non-general recursive things, and thus we'd have an effectively calculable functions that are non-general recursive things
08:08:07 <mmorrow> vixey: i tried to write a parser for that grammar without looking at that at first, and i came up with a parser that had long pauses at certain points (where i didn't factor my parser very well in hindsight)
08:08:07 <SamB_XP> hmm, true, a real-world object isn't even able to be turing complete, due to space requirements + bona fide bit rot
08:08:19 <vixey> centrinia, it seems very ridiculous to me
08:08:22 <strht> turing-complete means "can do all possible computations"
08:08:28 <strht> given one input
08:08:31 <vixey> mmorrow, which grammar?
08:08:36 <strht> oh baby
08:08:43 <strht> given one specific input
08:08:46 <vixey> strht, no it does not
08:08:48 <SamB_XP> strht: doesn't mean that -- it means can do all turing-possible computations ;-P
08:08:49 <lilac> strht: where "computations" mean "calculations which a turing machine could perform"
08:08:55 <centrinia> strht, I thought Turing completeness only implies being able to emulate any Turing machine.
08:09:00 <quicksilver> vixey: doesn't seem remotely ridiculous to me.
08:09:06 * strht takes out his flamethrower
08:09:16 <quicksilver> If you give a computable function, I can *actually* compute it, on a computer.
08:09:22 <quicksilver> subject to memory bounds and so on.
08:09:28 <vixey> quicksilver: I listen to AI reseachers going on "Oh I wonder if the ~human~brain~ is turing complete"
08:09:29 <lilac> strht: lambda calculus can't compute the busy beaver function, but it is turing complete
08:09:29 <quicksilver> if you give me a non-computable one, I can't.
08:09:32 <SamB_XP> I think vixey is referring to the lack of infinite tape in our world
08:09:34 <strht> Before the precise definition of computable function, mathematicians often used the informal term effectively computable. This term has since come to be identified with the computable functions. Note that the effective computability of these functions does not imply that they can be efficiently computed (i.e. computed within a reasonable amount of time). In fact, for some effectively computable functions it can be shown that any algorithm that computes 
08:10:01 <strht> you guys worry too much about theory
08:10:01 <vixey> SamB_XP: not even going as far as that, I am objecting to applying formal notions to real world things
08:10:07 <strht> worry more about concrete application
08:10:18 <mmorrow> vixey: the one (informally) given in http://augustss.blogspot.com/2007/11/some-lambda-calculus-examples-syntax-in.html
08:10:21 <quicksilver> strht: don't tell me what to worry about. Thanks.
08:10:22 <ziman> are there more powerful models/machines than TM?
08:10:35 <gwern> ziman: sure, ones which have oracles
08:10:36 <strht> vixey: did you figure out yet that society as a whole is an emergent consciousness?
08:10:42 <strht> recursion on every level ;)
08:10:47 <PeakerWork> lilac: either >>= or "fail" or throwError could be used by lookup to justify something more general than Maybe
08:10:54 <ddarius> ziman: Yes.
08:11:06 <vixey> strht: no.. I do not my spend time trying to think of ways to control large groups of people
08:11:12 <ziman> and are any of them constructible in the real world?
08:11:14 <strht> maybe you don't
08:11:16 <quicksilver> PeakerWork: true, but 'fail' or 'throwError' would merely justify Either.
08:11:17 <strht> i do
08:11:20 <quicksilver> PeakerWork: a small step :)
08:11:21 <PeakerWork> lilac: For example, instead of Nothing, it could be LookupError key keys   or something like that, but of course that does not add information to the caller
08:11:24 <lilac> PeakerWork: if (>>=) were used in full generality, then Maybe wouldn't be appropriate
08:11:27 <vixey> strht: yes that was clear from your observation :p
08:11:33 <ddarius> ziman: But either useless ones or ones that are more powerful in a pedantic way that is interesting but not very relevant for computability.
08:11:41 <SamB_XP> In fact, for some effectively computable functions it can be shown that any algorithm that computes
08:11:52 <PeakerWork> quicksilver: You're just acting out of your type-class hate :-)
08:11:54 <SamB_XP> ... ?
08:12:13 <quicksilver> quicksilver: on the contrary. I'm acting out of unquestioning belief in James McKinna ;)
08:12:17 <strht> what was the name of that algorithm
08:12:20 <strht> the busy beaver algorithm?
08:12:20 <dolio> ziman: Some people study super-Turing computation.
08:12:22 <ozy`> Maybe is just a special case of Either
08:12:33 <PeakerWork> quicksilver: I guess I agree with you there, though, just returning a concrete type is simple and the fold function is easy enough for conversions :)
08:12:36 <strht> @type perpetualMotion
08:12:38 <lambdabot> forall t1 t. t1 -> t
08:12:51 <PeakerWork> @type unsafeCoerce
08:12:52 <lambdabot> Not in scope: `unsafeCoerce'
08:12:59 <dolio> ziman: The one or two I've seen that people claim to be realizable usually assume that you can build some analog device that can effectively represent all real numbers somehow.
08:13:04 <centrinia> Busy Beavers do a lot of work. ;)
08:13:07 <ziman> hmm.
08:13:08 <dolio> Which seems overly optimistic.
08:13:10 <SamB_XP> ddarius: what oracles can we make ?
08:13:27 <strht> > replicate 25 (perpetualMotion 1)
08:13:38 <strht> thread killed
08:13:39 <vixey> mmorrow, ok I guess these are inherently recursive (readP parsers)
08:13:43 <lambdabot>   thread killed
08:13:47 * vixey &
08:13:51 <mmorrow> vixey: yes, very
08:13:52 <SamB_XP> dolio: yeah, real numbers don't actually exist do they ;-P
08:13:57 <ddarius> SamB_XP: The useless ones are the ones that take oracles (unless you can show how to make the oracle)
08:14:05 <lilac> PeakerWork: every function of type "Monad m => a -> m b" (where m does not appear in a and the function does not use 'fail') can be decomposed as "return . f" for some "f :: a -> b".
08:14:08 <ddarius> @google "Interactive Turing Machine"
08:14:16 <SamB_XP> ddarius: I thought we were talking about real devices
08:14:17 <lambdabot> http://www.comp.nus.edu.sg/~gem1501/interactiveturing.html
08:14:17 <lambdabot> Title: Interactive Turing Machine
08:14:20 <lilac> PeakerWork: this requires the same transformation to be applied to all functions it calls, though
08:14:34 <ddarius> Not what I wanted.
08:14:41 <PeakerWork> lilac: yeah, I see
08:14:42 <ozy`> instance Either a () => Maybe a where ...
08:14:44 <quicksilver> lilac: aren't you missing "and the function doesn't use >>= or >> etc" ?
08:14:44 <strht> alias vixey="startvixey -f 205 -c ~/.vixeyrc"
08:14:46 <dolio> ziman: Other than that, you can study things that are like Turing machines that are augmented with devices that decide some undecidable problem in some unspecified way, and see what additional problems are decidable by such a machine.
08:14:46 <ziman> i was wondering whether there's hope for us to get, say, more values from the busy-beaver function
08:15:00 <lilac> quicksilver: no. those must all cancel with uses of 'return' by the monad laws
08:15:10 <SamB_XP> ziman: that doesn't sound very usefull
08:15:17 <quicksilver> lilac: oh sorry, you mean strictly polymorphic in the monad
08:15:22 <quicksilver> lilac: yes, I'm following now.
08:15:22 <lilac> quicksilver: right :)
08:15:53 <strht> perpetual motion may be an impossibility
08:15:54 <lilac> quicksilver: i do need a restriction on 'seq' though
08:15:57 <mmorrow> strht: forkIO (return (perpetualMotion 0)) >> system "sudo halt"
08:16:02 <strht> but our machines asymptotically approach perpetual motion
08:16:06 <quicksilver> lilac: I don't normally care about seq ;)
08:16:16 <strht> if you define "asymptote" poorly
08:16:27 <ddarius> This paper may cover some things relevant to the second part of my statement: http://www.cs.uu.nl/research/techreps/repo/CS-2000/2000-33.pdf
08:16:44 <SamB_XP> mmorrow: you do realize that would demand the user to type his password ?
08:17:09 <gwern> SamB_XP: not necessarily, if he had sudod previously within the timelimit
08:17:11 <mmorrow> SamB_XP: not if yer in teh wheel and you don't require them to give a pass!! :)
08:17:22 <mmorrow> or what gwern said
08:17:27 <strht> have any of you actually read the source for sudo?
08:17:32 <lilac> if you add 'fail' or 'throwError' back in, then it's "case f a of Left e -> fail e; Right e -> return e" for some "f :: a -> Either e b"
08:17:35 <strht> can you be sure it's not sending a copy of your password to the NSA?
08:17:51 <dolio> SamB_XP: I suppose that depends on what you mean by "exist." But typically such devices appear to rely on an assumption that you can effectively measure analog values with infinite precision, which seems to be an unrealistic assumption.
08:17:51 <lilac> with fail replaced by throwError or e replaced by String as appropriate
08:18:04 <dolio> SamB_XP: Maybe even physically impossible.
08:18:06 <mmorrow> strht: it should unless my code is buggy
08:18:16 <cinimod> @seen dcoutts_
08:18:16 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
08:18:24 <SamB_XP> dolio: I meant in a physical sense
08:18:44 <SamB_XP> I think physical values are all finite-precision
08:18:49 <gwern> strht: I've never inspected GHC's codebase either. zOMG GHC might be molesting my cats!
08:19:02 <strht> oh dear
08:19:04 <drdo`> /usr/lib64/ghc-6.8.2/libHSrts.a(Main.o): In function `real_main':
08:19:04 <drdo`> (.text+0x12): undefined reference to `__stginit_ZCMain'
08:19:11 * mmorrow checks on his cat
08:19:16 <centrinia> Why do some people claim that academics who talk about Turing machines with infinite length tapes are not realistic?
08:19:32 <gwern> why, I've never even grepped for unsafePerformFelineMolestation!
08:19:43 <strht> centrina: i don't know, the lack of infinite length tapes in the world?
08:19:44 <Saizan> bug reports for core libs like process go to the ghc trac?
08:19:53 <centrinia> gwern, GHC only molests categories.
08:19:58 <SamB_XP> centrinia: because they don't know that newtonian physics isn't all that realistic either ?
08:20:13 <strht> everyone knows newtonian physics is obsolete
08:20:15 <strht> don't you?
08:20:23 <strht> :(
08:20:24 <gwern> centrinia: how do you know my cats aren't categories?
08:20:28 <strht> i mean, you all
08:20:36 <dolio> centrinia: Your computer only has finite memory, so it's only a very fancy finite automaton.
08:20:54 <centrinia> gwern, I don't. I just hope you don't apply Functors to your cats. :(
08:21:10 <strht> my cat got jammed in the IO monad
08:21:14 <strht> there's puke and blood everywhere
08:21:20 <ehird> :o
08:21:26 <Saizan> ?bug
08:21:27 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
08:21:28 <dolio> So, clearly those academics talking about Turing machines are useless. :)
08:21:42 <ddarius> dolio: They should be recycled.
08:21:47 <gwern> centrinia: I also don't feed them chocolate. I should be OK
08:22:16 <strht> the busy beaver algorithm is the stupidest algorithm i've ever seen
08:22:23 <strht> why would you ever try to compute that
08:22:23 <ehird> so's your face
08:22:30 <strht> no you
08:22:31 <ehird> you wouldn't
08:22:35 <strht> that's my point
08:22:36 <ehird> because you can't
08:22:36 <ehird> :P
08:22:38 <lilac> well, you might
08:22:40 <lilac> and you can
08:22:42 <lilac> perhaps
08:22:45 <ehird> lol
08:23:01 <ehird> strht: something of only academic interest with seemingly no real-world application?
08:23:02 <ehird> shocking!!
08:23:02 <lilac> aww, your :P messed up the formatting :(
08:23:09 <strht> oh yeah
08:23:13 <strht> like your function "edge cases"
08:23:17 <strht> ;)
08:23:19 <centrinia> The busy beaver function gives a lower bound on the length of a general computation.
08:23:27 <strht> like programmers are dancing around going
08:23:33 <strht> "i'm  going to apply map to an empty list!"
08:23:33 <SamB_XP> ehird: the theoretical mathemeticians should be all over it
08:23:33 <ehird> centrinia: "gives" is a bit of a strong word there ;-)
08:23:36 <strht> "see if they can stop me!"
08:23:41 <SamB_XP> they're always looking for stuff like that
08:23:46 <dolio> ddarius: Clearly they should ditch Turing machines for lambda calculus, since it's much less obvious to the average slashdotter that it doesn't line up with reality. :)
08:23:48 <lilac> strht: don't you find busy beaver interesting? that there exists a well-defined function which has a value for all natural numbers
08:24:00 <lilac> strht: but a computer can't work out that value, and perhaps nor can a human?
08:24:02 <strht> define "well-defined"
08:24:04 <gwern> centrinia: a terminating general computation you mean :)
08:24:18 <strht> lilac: check mine out
08:24:21 <centrinia> gwern, yeah. Sorry.
08:24:25 <SamB_XP> with no IO
08:24:28 <strht> > let allNaturalNumbersReturn x = x
08:24:31 <lambdabot>   <no location info>: parse error on input `;'
08:24:36 <strht> screw you lambdabot
08:24:36 <ehird> strht: a human can work that out
08:24:40 <ehird> so can a computer
08:24:44 <SamB_XP> hmm, so couldn't the busy beaver function be used to solve the halting problem ?
08:24:44 <lilac> strht: there are finitely many 5-state turing machines. some of them halt on an empty tape, some don't.
08:25:02 <ehird> SamB_XP: well if you can compute BB you can probably solve the halting problem too :-P
08:25:12 <strht> hmm
08:25:14 <lilac> strht: for each machine, either there exists a proof that machine halts, or it does not halt
08:25:32 <strht> uhhuh
08:25:37 <strht> > 43609383049680
08:25:40 <lambdabot>   43609383049680
08:25:49 <strht> > let allNaturalNumbersReturn x = x*2
08:25:49 <SamB_XP> lilac: is that so?
08:25:51 <lambdabot>   <no location info>: parse error on input `;'
08:25:57 <strht> > let allNatural x = x*2
08:25:57 <ehird> what is your damn point
08:25:59 <lambdabot>   <no location info>: parse error on input `;'
08:26:00 <ehird> a computer can work that out.
08:26:01 <Beelsebob> @let allNaturalNumbersReturn x = x * 2
08:26:01 <lilac> therefore, there exist machines which do not halt, but which we, as perhaps-computable humans cannot prove do not halt
08:26:02 <lambdabot>  Defined.
08:26:09 <SamB_XP> lilac: I don't think you can prove that without solving the halting problem ;-P
08:26:11 <strht> oh whoops
08:26:16 <centrinia> Why do some people claim to be able to solve the halting problem in their heads? They claim that they can look at a program and decide if it will go into an "infinite loop."
08:26:18 <lilac> SamB_XP: if the machine halts in n steps, i can give you an n step proof that it halts :)
08:26:20 <Beelsebob> > allNaturalNumbersReturn 5
08:26:23 <lambdabot>   10
08:26:24 <ehird> centrinia: they're ignorant.
08:26:28 <strht> look at it!
08:26:35 <strht> it returns a value for all integers
08:26:39 <strht> man am i a genius ;)
08:26:42 <ehird> strht: yeah and it's computable by a machine
08:26:50 <ehird> your ignoring of vital words in the sentence does not make you funny/clever
08:27:00 <strht> yes it does
08:27:00 <ehird> 16:22 <lilac> strht: don't you find busy beaver interesting? that there exists a well-defined function which has a value for all natural numbers
08:27:01 <ehird> 16:22 <lilac> strht: but a computer can't work out that value, and perhaps nor can a human?
08:27:02 <lilac> SamB_XP: if, forall n, there doesn't exist a proof in n steps, then forall n, it doesn't halt in n steps, so it does not halt in finite time
08:27:03 <Beelsebob> strht: the halting problem does not state that you can never tell if a program terminates
08:27:08 <centrinia> > map (+1) []
08:27:09 <quicksilver> I think this conversation is no longer making progress.
08:27:11 <lambdabot>   []
08:27:11 <Beelsebob> it states that there exists a program that you can't tell
08:27:14 <Asztal> now write a program that finds the first odd perfect number and tell me if it halts
08:27:16 <quicksilver> take it to -blah, please.
08:27:21 <strht> take what to blah
08:27:26 <strht> our discussion of turing-completeness?
08:27:26 <quicksilver> the conversation.
08:27:28 <quicksilver> yes.
08:27:31 <centrinia> Wow, I applied map to an empty list. :O
08:27:41 <strht> centrinia: you rebel, you
08:31:07 <ozy`> > [[]..]
08:31:09 <lambdabot>       No instance for (Enum [a])
08:31:09 <lambdabot>        arising from the arithmetic sequence ...
08:31:25 <ozy`> > ["a"..]
08:31:27 <augustss> > map undefined []
08:31:28 <lambdabot>       No instance for (Enum [Char])
08:31:28 <lambdabot>        arising from the arithmetic sequen...
08:31:29 <lambdabot>   []
08:31:33 <EvilRanter> > ['a' ..]
08:31:36 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
08:32:03 <ozy`> mouseentity: zdravstvuyte
08:32:35 <strht> > ['z' //]
08:32:38 <lambdabot>   <no location info>: parse error on input `]'
08:32:40 <strht> > ['z' ..]
08:32:43 <lambdabot>   "z{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\...
08:32:49 <strht> didn't see that coming
08:32:54 <quicksilver> >['a','c'..]
08:33:02 <quicksilver> > ['a','c'..]
08:33:05 <lambdabot>   "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\15...
08:33:20 <strht> ['a','e'..]
08:33:28 <strht> ['a','e'..]>
08:33:32 <strht> > ['a','e'..]
08:33:35 <lambdabot>   "aeimquy}\129\133\137\141\145\149\153\157\161\165\169\173\177\181\185\189\1...
08:33:42 <mmorrow> , (text . utf8enc . take 10) ['☂'..]
08:33:44 <lunabot>  ☂☃☄★☆☇☈☉☊☋
08:34:16 <strht> , (text . utf8enc . take 100) ['☉☊'..]
08:34:18 <lunabot>  luna: parse error on input `
08:34:24 <strht> , (text . utf8enc . take 100) ['☊'..]
08:34:26 <lunabot>  ☊☋☌☍☎☏☐☑☒☓☔☕☖☗☘☙☚☛☜☝☞☟☠☡☢☣☤☥☦☧☨☩☪☫☬☭☮☯☰☱☲☳☴☵☶☷☸☹☺☻☼☽☾☿♀♁♂♃♄♅♆♇♈♉♊♋♌♍♎♏♐♑♒...
08:34:35 <strht> oh sweet, check out the smiley faces :D
08:34:41 <centrinia> Is the function that accepts a positive integer x, where x < 10^m with m minimal, and returns the largest integer n such that (floor(10^n * pi) - x) is a multiple of 10^m?
08:34:52 <centrinia> Is such a function computable?
08:35:21 <SamB_XP> , (text . utf8enc . filter ((== TitlecaseLetter) . generalCategory)) ['\0'..]
08:35:24 <lunabot>  ǅǈǋǲᾈᾉᾊᾋᾌᾍᾎᾏᾘᾙᾚᾛᾜᾝᾞᾟᾨᾩᾪᾫᾬᾭᾮᾯᾼῌῼ
08:35:27 <SamB_XP> aww
08:36:12 <strht> , replicate 20 ((text . utf8enc) ['☺☻'])
08:36:14 <lunabot>  luna: parse error on input `:;'
08:36:28 <SamB> what ARE those ?
08:36:36 <mmorrow> , "☺☻"
08:36:38 <SamB> and why are there only a few ?
08:36:38 <lunabot>  "\9786\9787"
08:36:49 <mmorrow> "Miscellaneous Symbols"
08:36:59 <dolio> centrinia: What does that do? Find x in the digits of pi?
08:37:00 <centrinia> ,t ""
08:37:02 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char] -> a'
08:37:05 <SamB> I meant the titlecase letters
08:37:11 <mmorrow> oh, i dunno
08:37:17 <centrinia> SamB, yes.
08:37:21 <dolio> (As early as possible.)
08:37:22 <Beelsebob> , replicate 20 ((text . utf8enc) ['☺','☻'])
08:37:24 <lunabot>  [☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻,☺☻]
08:37:32 <ozy`> centrinia: http://paste.pocoo.org/show/96640/
08:37:46 <centrinia> It is supposed to find the first occurance of a certain sequence of digits in pi.
08:38:03 <strht> oh oops
08:38:09 <SamB> centrinia: has it found pi yet ?
08:38:14 <centrinia> I guess it can't find any length of zeros though.
08:38:22 <strht> humans didn't even find pi yet
08:38:46 <ozy`> centrinia: http://www.angio.net/pi/piquery
08:38:57 <dolio> It seems semi-decidable, at least.
08:38:59 <ozy`> that's the dumbfire approach
08:39:29 <ozy`> you can probably safely assume that the digits of pi will eventually contain any finite sequence of digits you can throw at it
08:39:45 <strht> probably?
08:39:47 <dolio> That'd be the rub.
08:39:59 <augustss> , 5
08:40:00 <centrinia> ozy`, why the pocoo.org?
08:40:01 <lunabot>  5
08:40:15 <quicksilver> ozy`: I think it's proven.
08:40:21 <ozy`> centrinia: because that was the first thing that showed up when I started to type "paste" in my URL bar
08:40:27 <quicksilver> or at least, it's proven that each sequence occurs with probability 1
08:40:35 <quicksilver> which may not be quite the same thing.
08:40:56 <augustss> quicksilver: has it been proven?  it had not been proven for pi last I heard.
08:41:07 <quicksilver> Hmm. I could certainly be wrong.
08:41:14 <SamB> only 1?
08:41:17 <SamB> I want 1.1
08:41:19 <centrinia> The probability that a randomly chosen real number is not rational is exactly equal to 1. :)
08:41:29 <augustss> it's been proven for certain classes of numbers.
08:41:44 <SamB> centrinia: that's because you can't randomly choose a rational number ;-P
08:41:46 <strht> centrinia: infinitesimally close to 1
08:41:58 <centrinia> strht, no. It is exactly 1.
08:42:03 <strht> bugger
08:42:07 <SamB> well, I mean, you can't know for sure that it is ever
08:42:31 <SamB> since you don't know how it ends until you finish choosing ;-P
08:42:35 <ozy`> I'm searching for successively longer strings of zeros to see at what point it overflows the database this site computed
08:42:53 <ozy`> I'm up to 8
08:43:12 <augustss> centrinia: how do you choose a random real number?
08:43:22 * strht zones out of this boring conversation
08:43:38 <quicksilver> augustss: I think you're right. It has (still) not been proven.
08:43:55 <SamB> augustss: well, to pick one between 0 and 1, you just pick each digit after the decimal point randomly
08:44:00 <strht> > lambdabot
08:44:02 <lambdabot>   "THAT'S ME FOLKSA!"
08:44:16 <augustss> SamB: that sounds like an infinite process to me
08:44:29 <SamB> augustss: of course
08:44:37 <SamB> most things involving real numbers are
08:44:47 <augustss> SamB: so then I won't get my real number ever
08:44:48 <dolio> You just pick. I have an axiom that says you can do it. :)
08:45:07 <SamB> dolio: oh, so we are playing pretend now ?
08:45:08 <centrinia> Axiom of Picking. :)
08:45:13 <augustss> dolio: I don't believe that axiom.  It causes endless trouble. :)
08:45:15 <Cale> It's curious how often one can show that almost all real numbers have some property while having serious trouble finding specific examples of real numbers having that property.
08:45:19 <dolio> :)
08:45:28 <SamB> dolio: what probability distribution does your axiom give ?
08:45:46 <SamB> Cale: it's very easy to exemplify this particular property
08:45:49 <strht> > botFight lambdabot
08:45:51 <lambdabot>   376
08:46:03 <ehird> :t botFight
08:46:05 <lambdabot> [Char] -> Int
08:46:08 <ehird> > botFight "a"
08:46:09 <Cale> Well, you can get a handful of somewhat contrived examples.
08:46:10 <lambdabot>   90
08:46:13 <ehird> > botFight "ab"
08:46:15 <lambdabot>   188
08:46:16 <ehird> @src botFight
08:46:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:46:29 <Cale> If you want it to happen in every base, it's a little trickier.
08:46:36 <SamB> Searchstart: 0 The string 0000000000000000 did not occur in the first 200000000 digits of pi after position 0.
08:46:52 <SamB> Searchstart: 0 The string 000000000000 did not occur in the first 200000000 digits of pi after position 0.
08:47:14 <Cale> I think it would be totally appropriate if, past some point, the only digits in the base 10 expansion of pi were 3's and 7's. ;)
08:48:25 <Olathe> Can't that be disproven ?
08:48:40 <Cale> Olathe: I haven't seen a proof that it doesn't happen.
08:48:40 <quicksilver> it hasn't been.
08:48:44 <strht> > botFight lunabot
08:48:44 <Olathe> Ahh.
08:48:46 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
08:48:50 <quicksilver> That's not to say it can't be :)
08:48:52 * strht scowls
08:49:01 <quicksilver> I don't think any mathematician seriously believes it.
08:49:20 <strht> > botFight lunabot
08:49:20 <Cale> It's certainly not something you'd want to rely on :)
08:49:23 <lambdabot>   -350
08:49:36 <strht> the message is clear
08:49:41 <quicksilver> http://xkcd.com/10/
08:49:50 <lilac> quicksilver: hasn't pi been proved to be normal?
08:49:55 <Cale> lilac: no
08:50:04 <Cale> lilac: Or if it has, then that's news to me :)
08:50:05 <strht> you guys would read xkcd
08:50:07 <augustss> Reminds me on Contact
08:50:13 <gwern> strht: duh
08:50:16 <Beelsebob> @let botFight2 a b = if botFight a > botFight b then a ++ " wins" else b ++ " wins"
08:50:17 <lambdabot>  Defined.
08:50:24 <Beelsebob> > botFight2 lambdabot lunabot
08:50:26 <lambdabot>   "a^eeh9_hedl: wins"
08:50:31 <strht> <3 Beelsebob
08:50:34 <Beelsebob> I see
08:50:41 <Beelsebob> > lunabot
08:50:43 <lambdabot>   "a^eeh9_hedl:"
08:50:49 <Beelsebob> > lambdabot
08:50:51 <lambdabot>   "HELLO CHUMPS!"
08:51:28 <centrinia> @let lambdabot = "foobar" ++ lambdabot
08:51:29 <lambdabot>  <local>:5:0:
08:51:30 <lambdabot>      Multiple declarations of `L.lambdabot'
08:51:30 <lambdabot>      Declared at: <...
08:51:47 <Beelsebob> @let lambdabot = fix ("lambdabot"++)
08:51:48 <lambdabot>  <local>:5:0:
08:51:48 <lambdabot>      Multiple declarations of `L.lambdabot'
08:51:48 <lambdabot>      Declared at: <...
08:51:52 <lilac> > fix (lambdabot++)
08:51:54 <Beelsebob> @undefine lambdabot
08:51:54 <lambdabot>   "HELLO CHUMPS!HELLO CHUMPS!HELLO CHUMPS!HELLO CHUMPS!HELLO CHUMPS!HELLO CHU...
08:51:58 <Beelsebob> @let lambdabot = fix ("lambdabot"++)
08:51:59 <lambdabot>  Defined.
08:52:03 <SamB> whoa, amazon had an algorithms officer!
08:52:10 <Beelsebob> > botFight2 lunabot lambdabot
08:52:12 <lambdabot>   Not in scope: `botFight2'Not in scope: `lunabot'
08:52:14 <strht> SamB: just wait until they have book burnings
08:52:22 <Beelsebob> oh bugger, I forgot that undeffed everything
08:52:45 <SamB> strht: oh, a technique of printing that does not require ink?
08:52:47 <SamB> neat idea!
08:52:54 <strht> > botFight lambdabot lumbdabot
08:52:56 <lambdabot>   mueval: Prelude.read: no parse
08:52:56 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
08:53:11 <gwern> 'For most CS papers, the first author listed is usually the one who did the most work, especially if its a student. In computational geometry, authors are always listed alphabetically. The reason for this was explained to me: "Everyone knows each other. They know who is the teacher and who is the student, and who did all the work."'
08:54:25 <roconnor> @src showString
08:54:26 <lambdabot> Source not found. I feel much better now.
08:54:32 <lilac> whoa, lambdabot, not a hom<what>?
08:54:50 <strht> gwern: i solve that problem without a headache at all by not cooperating with anybody ;)
08:55:53 <gwern> lilac: a homomorphism over the reals; why, what did you think 'homo' was short for? :)
08:56:20 <lilac> covariant hom functor?
08:56:58 <lilac> maybe lambdabot was going to say "not an homage to the Beatles"?
08:57:21 <augustss> gwern: the alphabetical author things is somewhat interesting
08:58:28 <augustss> gwern: more theoretical CS conferences (e.g. POPL) has mostly alphabetical, whereas e.g. OOPSLA is mostly unalphabetical
08:58:38 <gwern> augustss: a little. but I think it's a bad approach. that sort of social knowledge doesn't scale, either in community size or in time, and it advantages people whose last name come earlier
08:58:46 <centrinia> Not a homomorphism between...
08:58:53 <gwern> which has statistically unfair results
08:59:28 <gwern> unalphabetical might lead to professors bullying their way to be first, but at least there's a little correlation there
08:59:45 <centrinia> Alphabeticize according by the reversal of the surname strings. :)
09:00:10 <SamB> centrinia: that doesn't really help
09:00:11 <strht> > map (botImplodes . botImplodes . botImplodes . botImplodes . botImplodes) lunabot
09:00:13 <gwern> centrinia: the opposite of unfair is not necessarily fair...
09:00:14 <lambdabot>   "HELLO FOLKS!"
09:00:30 <gwern> just like the opposite of stupidity is often stupidity
09:00:34 <SamB> gwern: that's not the opposite though
09:00:45 <strht> the opposite of stupidity is genius
09:00:50 <strht> the counterbalance to unfair is fair
09:00:58 <strht> aka, a lack of inequity!
09:01:09 <strht> aka, anarchy...
09:01:10 <SamB> so print everyone's names in the same place?
09:01:20 <SamB> so that nobody can read ANY of them ?
09:01:28 <strht> you can do that, or, print them alphabetically
09:01:41 <strht> that's close enough to fair to elicit no whining
09:01:58 <gwern> SamB: I'd say descending credit is best, followed by randomization of order, but we can't trust people to do either 100%
09:02:20 <centrinia> Order by (\surname n p -> take (length surname) . skipEvery p . drop n . concat . repeat $ surname)
09:02:31 <centrinia> The n and p are randomly chosen. :)
09:03:09 <SamB> how about order by descending number of papers bearing the name already?
09:03:30 <gwern> since there'd be still be benefits accruing to being listed first, there would be temptation for the most powerful author to 'randomize' the list of authors such that he happens to be first
09:03:38 <strht> how about "nobody gets credit and you all write under pseudonyms"
09:03:43 <strht> i'll pull this car over right now
09:03:57 <gwern> no no, we'lls be good!
09:04:07 <SamB> I like mine
09:04:20 <centrinia> How about ordering by the amount of "contributions" made by the individual to the conference. ;)
09:04:41 <gwern> strht: pseudonyms don't really help
09:04:43 <mmorrow> @type \f -> mdo x <- f x; return x
09:04:45 <lambdabot> forall t (t1 :: * -> *). (MonadFix t1) => (t -> t1 t) -> t1 t
09:04:51 <pok4> All Steam Games for week : www.7steam.xoxgo.com
09:04:53 <strht> oh, they'll help soon
09:04:57 <strht> mark my words
09:05:00 <mmorrow> @type mfix
09:05:02 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:05:06 <SamB> yeah, really, would it help if you put strht on all your papers ?
09:05:18 <strht> it might help me not get arrested
09:05:22 <strht> if i write papers about encryption
09:05:24 <gwern> I base this on my observations of WP; most wikipedians are pseuodnymous, yet we still have pecking orders and credit and what not
09:05:51 <strht> yes
09:06:12 <strht> wikipedia is a decent start
09:06:23 <Asztal> > mfix fail
09:06:24 <lambdabot>       No instance for (Show (m String))
09:06:24 <lambdabot>        arising from a use of `show' a...
09:06:32 <strht> if you recall, the original authors of UltraHLE had to go into hiding out of fear of legal coercion
09:06:35 <centrinia> gwern, why doesn't someone just come up with the least pseudonym according to whatever order they give to pseudonyms?
09:06:41 <adekoba> hey, question on typical workflow. When developing a library, should one install it in the source tree for tests, or install it with cabal and --user?
09:06:44 <pok4> All Steam Games for week : www.7steam.xoxgo.com
09:06:46 <strht> you guys probably wouldn't have virtualBox without them
09:06:53 <centrinia> I mean, the pseudonym that is lower than all other pseudonyms.
09:06:58 --- mode: ChanServ set +o quicksilver
09:07:01 --- mode: quicksilver set +b *!*n=pok4@77.125.125.*
09:07:01 --- kick: pok4 was kicked by quicksilver (quicksilver)
09:07:10 --- mode: quicksilver set -o quicksilver
09:07:46 <gwern> centrinia: what?
09:07:53 <gwern> how is a pseudonym 'lower'?
09:08:03 <strht> those who have true contributions to make will be humble enough to understand the harm that would occur if their contributions were destroyed as a result of their own desire to attain credit for them ;)
09:08:11 <centrinia> Lexigraphically.
09:08:32 <strht> i hope all of you realize the thin ice you tread upon as programmers
09:08:37 * gwern has a sudden feeling of deja vu
09:08:38 <centrinia> Hell, why don't contributors change surnames?
09:08:50 <ozy`> let's all just call ourselves Anonymous and be done with it
09:09:05 <Asztal> IRC doesn't allow it!
09:09:28 <mmorrow> or just call yourself Nonymous and admit it
09:09:33 <mmorrow> kinda
09:09:35 <gwern> centrinia: I suspect if more realized the benefits, and there were fewer immediate social costs, they would
09:09:43 <Asztal> well, actually, RFC 2811 does >_>
09:10:05 <gwern> (how does one explain to one's father, oh I abandoned your surname for a statistical academic advantage?)
09:10:22 <centrinia> gwern, the women could marry whoever has the lexigraphically least surname if it is convenient.
09:10:28 <strht> gwern: why would you have to explain it to him?
09:10:48 <gwern> strht: at some point he's goign to notice
09:10:53 <gwern> waiting just increases the costs
09:10:54 <strht> how?
09:11:11 <strht> would he notice*
09:11:23 <gwern> strht: he's goign to see ID, or see you mentioned somewhere, or look up a paper, or read an article on you, or *something*
09:11:42 <strht> so don't hand out pictures with your pseudonym
09:11:46 <gwern> unless the two of you hate each other's guts and never ever meet, I don't see how he could go a lifetime without noticing your last name changed
09:12:07 <strht> are we talking about legally changing your name or handing out papers under a pseudonym
09:12:40 <gwern> strht: if you had noticed what centrinia asked, you'd understand it's the former
09:13:04 <strht> i thought we were talking about the latter first
09:13:20 <strht> i have a better idea, how about we all live in a giant peapod-type situation
09:13:31 <strht> and only bear children through artificial wombs
09:13:45 <centrinia> Do contributions go under maiden names or married names?
09:13:56 <gwern> sounds incredibly risky to the children's health, and expensive.
09:14:04 <strht> and then if we get tired of the boring sights of the peapod
09:14:15 <strht> we can just plug our senses directly into second life
09:14:19 <strht> and pretend that's real
09:14:24 <centrinia> strht, we do that already.
09:14:31 <centrinia> Haven't you seen the Matrix?
09:14:37 <gwern> I mean, we can't do simple surgery without nontrivial risks to mortality; I don't see raising embryos to babies as being more cost-effective than the old-fashioned way
09:14:38 <strht> the what?
09:14:40 <gwern> women are cheap
09:14:46 <gwern> especially third-world women
09:14:50 <strht> is that anything like the metaverse?
09:15:03 <centrinia> strht, no.
09:15:27 <gwern> now, if we replaced having western women becoming pregnant with a system of surrogate 3rdworld mothers with implanted embryos, that might work
09:15:41 <strht> sounds like a plan
09:15:45 <strht> have the bill on my desk by tomorrow morning
09:16:08 <centrinia> gwern, we can even use surrogate women to produce the all important spice melange. :O
09:16:16 <gwern> centrinia: the spice must flow!
09:16:35 <gwern> centrinia: but to be fair, surrogates have it better - they get to keep their brains *and* their pay
09:17:11 <centrinia> They can keep their brains and the pay. We only need the spice.
09:17:31 <strht> i have ridden the might lunaworm
09:17:49 <centrinia> Why didn't they just pay those women? It could have avoided the little conflict with the Matres.
09:18:11 <strht> > lunaworm
09:18:13 <lambdabot>   ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...
09:18:34 <gwern> centrinia: to ask that is to ask why the perquels/sequels of bja were so terrible
09:18:54 <strht> >  strhtOnTopOfLunaworm
09:18:55 <lambdabot>   "strht,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...
09:19:03 <centrinia> Brian J. Anderson. :O
09:19:53 <dolio> Dude, you just ruined like 3 books worth of mystery.
09:20:23 <gwern> dolio: sorry, #haskell is not a spoiler-free channel
09:20:25 <gwern> AERIS DIES
09:20:29 <dolio> :)
09:20:38 <strht> use a phoenix down
09:20:39 <ehird> dumbledore kills HASKELL
09:20:41 <ehird> !!!
09:21:45 <strht> > performCPR haskell
09:21:46 <centrinia> Harvey Dent killed Rachel Dawes .
09:21:47 <lambdabot>   "OH MY GOD I'M DROWNING"
09:22:18 <strht> rosebud is a sled
09:22:34 <dolio> You just saved me 3 long, boobless hours.
09:22:35 <vixey> any haskell
09:22:51 <strht> > familyGuy
09:22:52 <gwern> king kong falls off and dies
09:22:52 <lambdabot>   "FAMILY GUY SUCKS!"
09:22:57 <vixey> @undef
09:23:23 * strht gives lambdabot a treat
09:26:20 <vixey> Why is a program that works over Either and Maybe more general than one that works only on one?
09:26:54 <Heffalump> errm...
09:27:00 <Heffalump> isn't that what more general means?
09:27:47 <gwern> 'why is a more general program more general?'
09:27:50 <vixey> not to me
09:27:58 <vixey> I don't think it's tautology
09:28:00 <Heffalump> what does it mean to you, then?
09:28:01 <_ar> i would think maybe embeds in either
09:28:12 <paolin1> :t replicateM
09:28:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
09:28:15 <Heffalump> I guess that's true.
09:28:25 <vixey> By example, something like  length that works over lists *and* binary trees
09:28:34 <vixey> this is more general than just length on lists
09:28:45 <vixey> (even though you can convert a tree to a list of nodes and use length on it)
09:29:10 <Cale> :t \x -> case x of Left u -> Nothing; Right v -> Just v
09:29:11 <lambdabot> forall t a. Either t a -> Maybe a
09:29:34 <vixey> but with the case of Either vs Maybe, since the translation between Either <-> Maybe is hardly even a computation -- it's just a notational difference really -- maybe it is not really _more general_
09:29:34 <Cale> :t either (const Nothing) Just
09:29:35 <lambdabot> forall a a1. Either a1 a -> Maybe a
09:29:57 <paolin1> @hoogle Int -> (a -> m a) -> m a
09:29:57 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
09:29:57 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
09:29:57 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
09:29:57 <Cale> Well, there's not really a proper arrow going the other way.
09:30:01 <Heffalump> you can't embed an arbitrary Either in Maybe
09:30:04 <b_jonas> MERRY CHRISTMAS
09:30:17 <Heffalump> b_jonas: BAH HUMBUG
09:30:26 <vixey> Maybe a < Either b a
09:30:33 <b_jonas> no really
09:30:39 <b_jonas> we just had christmas dinner
09:30:41 <vixey> but [a] < BinaryTree a is not true
09:30:42 <Cale> You can collapse an arbitrary Either to a Maybe, and you can embed an arbitrary Maybe in a specific Either
09:31:00 <Heffalump> vixey: don't forget contravariance
09:31:11 <vixey> where does contravariance come into it?
09:31:12 <Cale> :t maybe (Left ()) Right
09:31:12 <lambdabot> forall b. Maybe b -> Either () b
09:31:37 <gwern> b_jonas: isn't christmas tomorrow?
09:31:44 <Heffalump> a general program with Either in its type can't just be turned into one with Maybe in its type in all the same places
09:31:47 <vixey> oh I'm not talking about  Maybe/Either -> <something>, but  a -> b -> ... -> Maybe/Either <something>
09:31:53 <vixey> only the monadic case
09:31:56 <b_jonas> gwern: yeah, that's why the dinner is today
09:32:09 <paolin1> how I apply an f :: a -> m a to its result n times ?
09:32:10 <b_jonas> the customs depend a bit on where you are
09:32:17 <Heffalump> Swedes have christmas today, apparently.
09:32:21 <Cale> The composite Maybe -> Either () -> Maybe is the identity, but the composite  Either e -> Maybe -> Either () obviously isn't ;)
09:32:29 <gwern> b_jonas: I don't follow. if today is christmas dinner, then what is dinner tomorrow?
09:32:45 <ehird> gwern: real christmas dinner!
09:33:04 <vixey> I just don't think your program is "more general" since it's polytypic
09:33:12 <vixey> it has to actually have more *meanings*
09:33:15 <gwern> ehird: those crazy sexy swedes!
09:33:25 <ehird> gwern: "CREXY"
09:33:26 <b_jonas> tomorrow and the next day are full day bank holidays when people often visit relatives and stuff
09:33:39 <gwern> ehird: can we sexy? yes we can sexy
09:33:53 <b_jonas> and as you have chrismas dinner today and sing carols and give presents people have the presents all day on christmas day already
09:34:04 <paolin1> :t \f x -> foldM (flip ($)) x $ replicate n f
09:34:04 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
09:34:05 <lambdabot>     In the first argument of `replicate', namely `n'
09:34:05 <lambdabot>     In the second argument of `($)', namely `replicate n f'
09:34:10 <vixey> since you put into the Either, some _non computational_ message, then it is computationally isomorphic to Maybe
09:34:27 <vixey> there's no point in the program where you do case analysis on an error message
09:35:06 <paolin1> :t \n f x -> foldM (flip ($)) x $ replicate n f
09:35:07 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> (a -> m a) -> a -> m a
09:35:28 <Cale> vixey: what?
09:35:39 <Cale> vixey: Either isn't just for errors.
09:35:42 <vixey> Cale, any program written in error monad using throwError
09:35:59 <Cale> Either is the disjunction of two types.
09:36:38 <vixey> Cale, yes sorry I'm only really thinking about programs in Either/Maybe monad
09:36:38 <Cale> also, it's not equivalent. Maybe is equivalent to Either ()
09:36:45 <chessguy> hey, when i use ghci from haskell mode in emacs, if the file i :load imports another module in the same directory, ghci can't find it. any suggestions?
09:37:12 <vixey> one doesn't write a program that goes  throwError (<command that is interpreted later and directs computation>)
09:37:14 <Cale> A program in, say, the Either Bool monad can terminate early to produce a boolean result.
09:37:23 <Philippa_> vixey: you might not
09:37:26 <Cale> vixey: Why not?
09:38:07 <Philippa_> hell, it might turn out to be the only way to make the resource management work
09:38:12 <chessguy> i keep getting this error:    Could not find module `Foo':      Use -v to see a list of the files searched for.
09:38:36 <vixey> @src MonadError
09:38:36 <lambdabot> class (Monad m) => MonadError e m | m -> e where
09:38:36 <lambdabot>     throwError :: e -> m a
09:38:36 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
09:38:41 <Cale> chessguy: It means that GHC can't find the module you're trying to load
09:39:00 <Cale> chessguy: Modules must be located in files which have the same filename as the module name.
09:39:01 <Plouj> what's the $= operator?
09:39:10 <Plouj> also, is the RWH better than YAHT?
09:39:16 <chessguy> Cale: yes, but that is the case
09:39:19 <Cale> Plouj: It's part of the OpenGL library
09:39:27 <Plouj> oh
09:39:38 <chessguy> Cale: this is from haskell-mode in emacs. i think ghci is looking in the wrong place
09:39:55 <Plouj> Cale: how can I figure out what it means?
09:40:01 <gwern> look at :pwd
09:40:21 <chessguy> gwern:  unknown command
09:40:38 <Cale> Plouj: it basically means assignment
09:40:49 <vixey> right, it's more complex than I thought
09:40:54 <gwern> oops, I forgot pwd was a custom command
09:40:56 <gwern> let pwd _ = return "System.Directory.getCurrentDirectory >>= putStrLn"
09:40:57 <gwern> :def pwd cmdHelp pwd ":pwd\t\t\t-- print working directory"
09:40:58 <Cale> http://hackage.haskell.org/packages/archive/OpenGL/2.2.1.1/doc/html/Graphics-Rendering-OpenGL-GL-StateVar.html
09:41:13 <gwern> I suspect you'll find ghci is sitting in ~/.cabal/
09:41:28 <Cale> Plouj: It's a method of the HasSetter typeclass, which is for types of variables which can be set.
09:41:40 <Cale> (or references, if you will)
09:41:42 <vixey> you can put extra information in with the Left of an Either, but with a Maybe -- by parametricity you've got more preconditions on it
09:42:14 <Cale> It's a little odd that it's part of the OpenGL library and not separate.
09:42:26 <Cale> It really should be split into a separate package.
09:42:35 <vixey> so some monadic program that works for Either and Maybe is really more general
09:42:40 <Plouj> haskell is a little odd :)
09:43:04 <Plouj> on a serious note, I wonder how much more haskell I need to learn to understand this: http://www.haskell.org/haskellwiki/OpenGLTutorial1
09:43:27 <chessguy> gwern:  Not in scope: `cmdHelp'
09:43:34 <vixey> it's actually Maybe on the inside, but from the outside (one the computation has finished) there may be extra information there -- except you are certain that the program didn't do a case analysis on that (the error message)
09:43:43 <chessguy> gwern:  that's when i do ":def pwd cmdHelp pwd ":pwd\t\t\t-- print working directory""
09:43:47 <strht> not nearly as much as it appears, Plouj
09:43:49 <gwern> let { cmdHelp cmd msg "--help" = return $ "putStrLn "++show msg; cmdHelp cmd msg other = cmd other }
09:43:52 <gwern> :def . cmdHelp readFile ":. <file>\t\t-- source commands from <file>"
09:43:53 <strht> don't be afraid
09:44:10 <Plouj> strht: it's not that I'm afraid, I'm just overwhelmed.
09:44:24 <strht> how much haskell do you know?
09:44:47 <chessguy> ok
09:44:55 <Cale> Plouj: When you see stuff like "displayCallback $= display", it means that displayCallback is either an IORef, a StateVar, or a SettableStateVar (probably one of the latter two)
09:44:57 <chessguy> gwern:  got it now. it is indeed in .cabal
09:45:09 <_ar> Plouj, i'd say once you understand type constructors, lists, IO, map and the basics of opengl itself you should be ready
09:45:14 <gwern> chessguy: in which case it's not in the sam directory as Foo.hs :)
09:45:19 <gwern> hence ze problem
09:45:26 <Plouj> strht: I read up to the http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced chapter of YAHT and I still didn't understand what that "$=" operator meant nor what the mapM_ function does, nor why function application "$" was used, nor what the meaning of <- was
09:45:38 <chessguy> gwern:  so...i need to tell ghci to change directories?
09:45:39 <Cale> Plouj: The IO action  displayCallback $= display  will set that reference to the value display when executed.
09:45:56 <Saizan> chessguy: use :cd at the prompt
09:46:06 <Cale> Plouj: These are just library functions you need to learn :)
09:46:15 <Cale> Plouj: apart from <-
09:46:24 <gwern> chessguy: well, my personal theory is that something is broken in haskell-mode's reload functions
09:46:26 <strht> > [x|x<-[1..1000],x `mod` 10 == 0]
09:46:27 <lambdabot>   [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210...
09:46:28 <Cale> <- is part of do-notation
09:46:40 <Saizan> gwern: correct
09:46:40 <chessguy> got it working  now, thanks
09:46:41 <gwern> you can use :cd and :load, but the next :Reload will send you back to .cabal, iirc
09:46:43 <Cale> and you probably *have* seen it before if you've read YAHT that far
09:46:47 <Plouj> well, that's the thing, I can't distinguish which is a special library function and which is a Haskell "basic operator" (I guess from Prelude)
09:47:01 <gwern> Saizan: I don't care so much as to really find out since I use yi for my haskell hacking mostly
09:47:09 <strht> Plouj: nothing fixes that but experience
09:47:12 <Cale> Plouj: Stuff that's in the Prelude is not particularly special, the Prelude is just another library
09:47:15 <strht> that and reading the code to Prelude
09:47:29 <_ar> Plouj, then start with some more basic tutorials http://book.realworldhaskell.org/read/
09:47:29 <Cale> <- though is not an infix operator, it's part of the Haskell syntax
09:47:35 <Saizan> chessguy: it should be fixed in the devel version of haskell-mode
09:47:47 <Saizan> gwern: not that Shim is working that well here
09:47:51 <_ar> Plouj: if you find it helpful you should buy that book btw
09:47:53 <Cale> In do notation, the statement  v <- x  means to run the action x and name its result v
09:47:56 <Plouj> _ar: heh
09:47:59 <strht> Plouj: try http://learnyouahaskell.com/
09:48:05 <gwern> Saizan: how is it broken for you>?
09:48:06 <Heffalump> the Prelude functions are used for desugaring of some syntax by default
09:48:07 <strht> it's like real world haskell, except not gay
09:48:08 <Plouj> this will be the third book on Haskell I would be starting
09:48:10 <tryx> Hey Haskellers, a theoretical question that I've been pondering. Suppose we have a function f :: a -> a. Apart from id and _|_ are there any other such functions?
09:48:21 <Heffalump> tryx: const _|_
09:48:25 <Cale> tryx: there's also const _|_
09:48:43 <Saizan> gwern: C-c C-t is quite unpredictable, it usually fails on the first try and works on the second
09:48:45 <Cale> But it's only distinguishable from _|_ using seq
09:48:51 <Plouj> ok, well, I'll go try some of your advice
09:49:04 <Cale> Plouj: Do you know about do notation?
09:49:09 <gwern> Saizan: really? wait, is this yi shim or emacs shim?
09:49:17 <Saizan> gwern: yi shim
09:49:19 <gwern> cause my C-c C-t problem is file locking
09:49:20 <tryx> is that readily provable?
09:49:21 <Cale> Plouj: I can explain some basic monad stuff like mapM if you'd like
09:49:44 <tryx> rather, if there are no other such functions
09:49:52 <tryx> is  that fact readily provable
09:50:20 <Cale> tryx: In any reasonable semantics it should be.
09:50:25 <strht> i'm probably the only person in this room that's ever done heroin
09:50:46 <chessguy> Plouj: Cale  is an excellent teacher. you would be wise to take him up on his offer
09:50:56 <chessguy> even if i don't always like his tutorials :)
09:50:57 <strht> Plouj: i second that
09:51:11 <gwern> strht: I'm probably the only person in this room whose cousin hung himself while on heroin
09:52:44 <tryx> Could you point me in the direction of any references? I would not even know where to start
09:52:54 <chessguy> hrm, i don't get this JSON chapter in RWH
09:53:10 <proq> learn you a haskell?  geez
09:53:38 <_ar> gwern: i'm sorry to hear that. i've got a cousin who had a plan to *drive* from ohio to hawaii
09:56:43 <Cale> tryx: Well, just informally, to start with... a function of type a -> a takes a value of type a, and has to produce a value of type a somehow. _|_ is a member of any type, so the function itself could be _|_. It could also be the function which produces _|_ when given a value. Otherwise, however, it will have to produce a defined value of type a, but there are no other values common to all types a. The only value of t
09:56:44 <Cale> ype a which is available to it is the one which is passed in as a parameter, and it has no means of transforming that, because it hasn't also been passed a function for operating on values of type a. So at least informally, it's clear that it must then return its parameter unchanged.
09:58:18 <Cale> Any formal proof will basically follow that informal one along in some way or another.
09:58:28 <oshyshko> I need to write HTML scrapper which is able to extract/parse invalid HTML (tags nesting etc.). Some lib with good query ability, like Ruby's Hpricot or Mechanize. Where should I dig?
09:58:37 <Heffalump> oshyshko: tagsoup
09:58:42 <strht> beautifulsoup
09:58:51 <strht> that's convertible
09:59:15 <Heffalump> strht: presumably oshyshko was looking for a Haskell library, this being #haskell :-)
10:01:47 <tryx> cale: I thought about that. I may be mangling the maths here but doesn't the axiom of choice provide us with an out? Consider the Set of all types (does this exist?), AoC guarantees that a Choice function exists to select an element of each type. Can we assign the value of f to be the "chosen" element from that type?
10:02:18 <vixey> "AoC guarantees that a Choice function exists to select an element of each type" -- no it doesn't (?)
10:02:51 <vixey> I thought it (typed AC) was more like if  aRb then exists f, f(a) = b
10:03:22 <centrinia> If f' :: (Num a) => a -> a; f' x = x+1; can we have a function f where f = f' for members of instances of Num and f=id for everything else?
10:03:58 <centrinia> Types are not sets. :O
10:04:01 <_ar> tryx, the axiom of choice for the set of all types would let you pick a type, not a value
10:04:14 <Feuerbach> centrinia: yes, you need additional type class
10:04:28 <Heffalump> centrinia: if you're willing to use overlapping instances
10:04:30 <strht> so many misconceptions
10:05:03 <centrinia> Is there a concept of a complementary type class?
10:05:17 <tryx> hmm, how are types structurally different from Sets?
10:05:25 <Philippa_> centrinia: nope. Open world assumption.
10:06:11 <Philippa_> tryx: depends. Do we allow naive set theory?
10:06:14 <_ar> tryx: depends on how you define them
10:06:32 <centrinia> What about a complementary type class that is constrained by another type class? Say the complement of Num with respect to Eq?
10:06:34 <Cale> tryx: You can't define all set theoretic functions between any two types.
10:06:34 <_ar> tryx: i don't think you need to give them any internal structure at all
10:06:40 <Philippa_> System F doesn't have a semantics in ZFC, for example
10:07:19 <Cale> tryx: For example, the type () which consists of {_|_, ()} as a set admits a set-function which simply swaps _|_ and ()
10:07:30 <vixey> Philippa_: because of the forall quantifier?
10:07:37 <Cale> But such a function is not continuous, and so not definable in Haskell.
10:07:42 <_ar> tryx: i think you're thinking of them as the set of all values of that type, i am not sure this is consistent
10:07:58 <Philippa_> vixey: impredicativity
10:08:13 <tryx> _ar: that was my intuition behind it, does this not hold in general?
10:08:15 <Cale> (you would have to be able to solve the halting problem to write it)
10:08:41 <SamB> Cale: and use unsafePerformIO!
10:09:13 <Cale> SamB: Well, the halting problem solver would have to be a language primitive :)
10:09:23 <centrinia> tryx, a cons cell definition of a list (List a) would correspond to the set { _|_, Nil, List a }
10:09:24 <Cale> isBottom :: a -> Bool
10:09:40 <centrinia> Cale, is that possible?
10:09:45 <Cale> centrinia: No, it's not.
10:09:49 <SamB> Cale: it could be part of the exception system
10:09:50 <vixey> centrinia: So List a is a type?
10:09:51 <centrinia> Bummer.
10:09:57 <centrinia> Oh, sorry.
10:10:00 <vixey> centrinia: and List a :: List a?
10:10:02 <strht> @src filter
10:10:02 <lambdabot> filter _ []     = []
10:10:02 <lambdabot> filter p (x:xs)
10:10:02 <lambdabot>     | p x       = x : filter p xs
10:10:02 <lambdabot>     | otherwise = filter p xs
10:10:06 <Cale> SamB: I suppose.
10:10:07 <strht> that's beautiful isn't it?
10:10:14 <vixey> strht, no
10:10:16 <_ar> tryx: someone might be able to cook up an example, i'd think you'd be opening yourself up to russel type paradoxes
10:10:20 <strht> that's not beautiful?
10:10:20 <Cale> strht: That implementation of filter?
10:10:27 <Cale> It's not bad.
10:10:29 <adekoba> when making a cabal package that has both an executable and library, where the executable depends on said library, why does cabal need to compile the library twice? One for the library itself, and one for the program, but why can't it just use the library?
10:10:31 <centrinia> F (List a) =  { _|_, Nil, F (List a) } where F transforms Types to Sets. ;)
10:10:32 <strht> maybe we have different definitions of beauty ;)
10:10:57 <vixey> > let cons x xs | odd x = xs | otherwise = x:xs in foldr cons [] "fooobar"
10:10:58 <lambdabot>       No instance for (Integral Char)
10:10:58 <lambdabot>        arising from a use of `cons' at ...
10:10:59 <Cale> :t foldr (\x -> if p x then (x:) else id) []
10:11:00 <lambdabot>     Couldn't match expected type `a -> Bool'
10:11:00 <lambdabot>            against inferred type `Expr'
10:11:00 <lambdabot>     In the predicate expression: p x
10:11:05 <Cale> :t \p -> foldr (\x -> if p x then (x:) else id) []
10:11:06 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:11:28 <vixey> by odd I meant isVowel
10:11:34 <strht> that's nice also, Cale ;)
10:12:06 <vixey> centrinia, You said a min ago types aren't sets and your definition still makes zero sense
10:12:17 <Cale> Types are sets with additional structure.
10:12:19 <centrinia> vixey, that's my point.
10:12:27 <Cale> (at least in our usual semantics)
10:12:33 <vixey> your point is that you can construct something that doesn't make sense?
10:12:46 <Philippa_> for some type systems that only works in naive set theory though
10:12:47 <Cale> The trouble is that not all set-functions between two types are definable functions.
10:13:04 <centrinia> vixey, I was trying to construct something resembling a set that contains itself.
10:13:16 <strht> > filter (`elem` ['A'..'Z']) "#HAskell TRuly is full of jErks, Don't you think?!"
10:13:17 <lambdabot>   "HATRED"
10:13:18 <vixey> how about x = {x}
10:13:30 <Cale> The problem can be solved by giving every type a topology and demanding that we only talk about continuous functions.
10:13:55 <strht> > filter (`elem` ['A'..'Z'] ++ ['!','?']) "#HAskell TRuly is full of jErks, Don't you think?!"
10:13:56 <lambdabot>   "HATRED?!"
10:14:09 <vixey> strht, you are actually  annoying
10:14:16 <strht> i bet
10:14:27 <strht> that's the typical reaction of jerks to criticism
10:14:51 <_ar> strht: introspect on that last statement
10:14:54 <tryx> Cale: what additional structure DO types have over naked sets?
10:15:14 <strht> _ar: and round and round we go
10:15:23 <Philippa_> tryx: they're CPOs
10:15:29 <SamB> > filter (isUpper `mplus` isPunct) "#HAskell TRuly is full of jErks, Don't you think?!"
10:15:30 <lambdabot>   Not in scope: `isPunct'
10:15:35 <SamB> @hoogle isP
10:15:35 <lambdabot> System.FilePath.Posix isPathSeparator :: Char -> Bool
10:15:35 <lambdabot> System.FilePath.Windows isPathSeparator :: Char -> Bool
10:15:35 <lambdabot> System.IO.Error isPermissionError :: IOError -> Bool
10:15:38 <SamB> @hoogle isPu
10:15:38 <lambdabot> Data.Char isPunctuation :: Char -> Bool
10:15:40 <vixey> what's impredicative about System F?
10:15:47 <SamB> > filter (isUpper `mplus` isPunctuation) "#HAskell TRuly is full of jErks, Don't you think?!"
10:15:48 <lambdabot>       No instance for (MonadPlus ((->) Char))
10:15:48 <lambdabot>        arising from a use of `m...
10:15:55 <SamB> aww ...
10:16:08 <tryx> Philippa_: sorry, I'm not familiar with that term. Could you explain?
10:17:02 <SamB> > filter (isUpper `mappend` isPunctuation) "#HAskell TRuly is full of jErks, Don't you think?!"
10:17:02 <_ar> vixey: i think centrinia's construction was okay, what's wrong with it?
10:17:03 <lambdabot>       No instance for (Monoid Bool)
10:17:03 <lambdabot>        arising from a use of `mappend' at...
10:17:03 <Cale> tryx: They have a topology given by a definedness partial ordering.
10:17:11 <SamB> that's a bit better
10:17:22 <SamB> but Bool isn't a Monoid ...
10:17:23 * SamB sad
10:17:24 <vixey> _ar, didn't make sense, didn't see why it's relevant and it went against something they said a moment ago
10:17:48 <roconnor> SamB: there are two Monoid wrappers for Bool
10:17:58 <SamB> right :-(
10:18:07 <Cale> (actually, it's a directed complete partial order)
10:18:08 <SamB> so, is there a cute way to do this?
10:18:15 <roconnor> similar for integers
10:18:22 <tryx> Cale: Why does every type come with a partial ordering? (did I understand that correctly?)
10:18:24 <centrinia> > let divisors x = filter (\t -> (x `mod` t) == 0) [1..x-1] in filter (\x -> sum (divisors x) == x) [1..]
10:18:27 <Cale> tryx: yes
10:18:39 <lambdabot>   thread killed
10:18:47 <mattam> vixey: impredicative as in [∀ α, α] is a type that can be used to instanciate a polymorphic function I think.
10:18:56 <SamB> where by "this" I mean combine two functions returning bool as if using (||) on the result
10:19:03 <vixey> mattam, ok thanks
10:19:09 <SamB> regardless of arity
10:19:10 <Cale> tryx: In order to explain which functions can be written. _|_ is a value of every type which represents nontermination, a fiddly thing that we don't normally concern ourselves with in general mathematics
10:19:28 <tryx> Cale: yup, I'm with you so far
10:19:40 <centrinia> Unboxed types have bottom?
10:19:52 <Cale> tryx: So consider the type [Bool] of lists of elements of type Bool.
10:20:08 <Cale> centrinia: As far as I'm concerned for this discussion unboxed types don't exist.
10:20:21 <centrinia> Okay. :)
10:20:34 <Cale> (They're of a different kind anyway)
10:20:55 <roconnor> @type on
10:20:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:20:58 <Cale> tryx: It has _|_, and then directly above that, it has [] and (_|_ : _|_)
10:21:08 <Cale> (which are incomparable)
10:21:18 <Cale> (but more defined than _|_)
10:21:32 <vixey> when you are talking about types, what does neighbourhood mean?
10:22:08 <Cale> then above (_|_ : _|_) there's (True : _|_), (False : _|_), (_|_ : []) and (_|_ : (_|_ : _|_)) which are all incomparable with each other.
10:22:35 <centrinia> Cale, what is that colon symbol supposed mean?
10:22:42 <Cale> centrinia: cons
10:22:43 <vixey> @src []
10:22:43 <lambdabot> data [] a = [] | a : [a]
10:22:47 <centrinia> Oh.
10:22:47 <Cale> > 1 : 2 : 3 : []
10:22:49 <lambdabot>   [1,2,3]
10:23:29 <roconnor> @hoogle Mighty
10:23:29 <lambdabot> No results found
10:23:37 <Cale> Above both (True : _|_) and (_|_ : []) there's (True : [])
10:24:29 <tryx> Cale: I'm with you, but I am not seeing when this order is ever necessary?
10:24:41 <mercury^> least fix points for example
10:24:50 <Cale> Essentially, a value y of a type is more defined than another value x if y can be obtained by replacing _|_ values in x with other values.
10:25:01 <mercury^> fixed*
10:25:02 <vixey> are {(True : _|_),(_|_ : []),(True : [])} a neighbourhood?
10:25:10 <dons> ?users
10:25:11 <lambdabot> Maximum users seen in #haskell: 568, currently: 551 (97.0%), active: 21 (3.8%)
10:25:15 <Cale> tryx: Functions which pattern match against _|_ are forced to produce _|_ as a result.
10:25:16 <opqdonut> tryx: defineable functions have to be _monotonous_ wrt this ordering
10:25:18 <dons> have we triumphed over adversity yet?
10:25:30 <opqdonut> for example the function _|_->(), ()->_|_ is not defineable
10:25:44 <opqdonut> there was a good blog on this
10:26:51 <roconnor> SamB: Mighty is Conor's Monoid wrapper for disjuction
10:27:06 <roconnor> but I don't see an elegant way of using it off the top of my head
10:27:12 <Cale> vixey: A subset X of a type is open if it is an upper set (contains anything greater than any of its elements) and if all directed sets with a supremum in X have nonempty intersection with X.
10:27:29 <roconnor> I wonder if there is a generic filter for traversable
10:28:14 <tryx> Cale: is it possible to construct this Ordering over an arbitrary set?
10:28:18 <SamB> roconnor: see, that's what I mean!
10:28:35 <Cale> tryx: Types aren't arbitrary sets. They come with this ordering.
10:28:49 <tryx> As in, can we lift any plain set into a type?
10:28:53 <Cale> tryx: No.
10:29:26 <BONUS_> how about
10:29:35 <BONUS_> @let f () = undefined
10:29:37 <lambdabot>  Defined.
10:29:38 <Cale> In addition, many ZFC sets aren't computable, so there's no hope of them being types in Haskell.
10:29:39 <BONUS_> :t f
10:29:40 <vixey> roconnor, is data T a = Leaf a | Bin a (T a) (T a) traversible? what could  filter odd (Bin 1 (Leaf 2) (Leaf 3))  give?
10:29:41 <lambdabot>     Ambiguous occurrence `f'
10:29:41 <lambdabot>     It could refer to either `L.f', defined at <local>:1:0
10:29:41 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:73:0-32
10:29:47 <BONUS_> gah whoops
10:29:53 <opqdonut> BONUS_: :)
10:30:41 <Cale> BONUS_: That also sends _|_ to _|_
10:30:47 <Cale> @undefine
10:30:52 <BONUS_> aha
10:31:04 <centrinia> How about (const undefined) ?
10:31:07 <Cale> The trick is to swap _|_ with ()
10:31:26 <Cale> If you can do that for me, then I can solve all the unsolved mathematics problems rather easily.
10:31:35 <opqdonut> :-D
10:31:39 <BONUS> haha
10:31:50 <tryx> haha I'll get to work :p
10:31:52 <Cale> I will just write a program which looks for a proof of a theorem forever.
10:31:53 <opqdonut> Cale: and also obtain a bunch of counter-examples for known truths
10:32:09 <Cale> and then apply that function to it
10:32:21 <opqdonut> :>
10:32:26 <Cale> (after applying it to a statement I want to know about)
10:33:38 <centrinia> Cale, what about conjectures that deny the axiom of choice?
10:33:43 <Cale> Well, okay, the practicalities of this might be funny, like you might give me a function which takes a really long time to swap _|_ and ()
10:34:16 <Cale> centrinia: Those would (hopefully) not be provable in a system which has the axiom of choice as an axiom.
10:34:40 <centrinia> Can you prove unsolved mathematics problems that do not assume the axiom of choice?
10:34:44 <Cale> and in ZF, they wouldn't be provable either, because AoC is consistent with ZF
10:35:05 <roconnor> SamB: I guess you just have to write union f g x = f x || g x
10:35:07 <Cale> (though they might also be consistent with ZF)
10:35:55 <quicksilver> vixey: I might be jumping in halfway, but Traversable doesn't support Filter.
10:36:14 <tryx> Well thank you everyone, you have given me a lot of food for thought :) I think I may sleep on it and perhaps wake up with some more insight.
10:37:02 <Cale> tryx: But yeah, the main point is that all Haskell-definable functions preserve the ordering.
10:37:02 <vixey> quicksilver, I think I have a counterexample for the possibility of it
10:37:12 <Cale> tryx: That is, if x <= y, then f x <= f y
10:37:17 <quicksilver> vixey: Traversable is nothing like strong enough
10:37:26 <quicksilver> vixey: the obvious thing to do is add Monoid as a requirement
10:37:27 <centrinia> Dreams about bottom and types are always interesting. ;)
10:37:43 <quicksilver> vixey: but you find you also need 'pure', for the obvious implementation.
10:37:43 <vixey> oh good idea
10:37:54 <quicksilver> vixey: Traversable doesn't have a clean notion of 'substructure'.
10:38:35 <Cale> and so even though f _|_ might not be _|_, whatever it is, we know that since for all y we have _|_ <= y, we know that f _|_ <= f y. So if f _|_ is a fully defined value, f y must be equal to it.
10:40:30 <Cale> and if, say, it's only partly defined, we know that f y will agree with it on that part
10:40:43 <chessguy> there aren't really any standard classes that have any notion of substructure, are there?
10:40:47 <Cale> (for example, the function (1:) is like this)
10:40:59 <centrinia> Cale, can we compare (True : _|_ ) and (False : _|_ ) ?
10:41:03 <Cale> centrinia: no
10:41:49 <Cale> x <= y if and only if y can be obtained from x by substituting other values for each _|_ occurring in x.
10:42:19 <centrinia> Can we have a function f such that f _|_ = True : _|_; and f y = False : _|_; for some y >= _|_ ?
10:42:26 <Cale> no
10:43:02 <Cale> Because f _|_ = True : _|_, so  True : _|_ <= f y for any y.
10:43:23 <Cale> and so f y can only be obtained by replacing the _|_ in True : _|_ with other values.
10:43:26 <strht_> > heh
10:43:28 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
10:43:44 <ozy`> @src heh
10:43:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:43:53 <ozy`> @slap lambdabot
10:43:53 * lambdabot clobbers lambdabot with an untyped language
10:44:01 <chessguy> @type heh
10:44:02 <lambdabot> [Char]
10:44:47 <strht_> that doesn't tell you anything
10:45:19 <strht_> well, a little
10:45:28 <chessguy> > cycle "ha"
10:45:30 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
10:45:52 <vixey> strht_> > heh
10:45:57 <vixey> strht_, please don't
10:46:05 <strht_> please don't what
10:46:05 <centrinia> > let divisors x = filter (\t -> (x `mod` t) == 0) [1..x] in filter ((==2) . length . divisors) [1..]
10:46:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:46:45 <pyNem> can someone help me out with the state monad?
10:46:47 <vixey> strht_, I am just asking in a nice way
10:46:56 <strht_> well, ask in a clear way
10:46:57 <vixey> pyNem, what about it?
10:47:00 <chessguy> pyNem:  go ahead and just ask your question in here
10:47:00 <strht_> don't what
10:47:15 <pyNem> I think I kind of okay understand how it works now .. but how does one use it in haskell
10:47:26 <pyNem> and why does one wrap it around with State
10:47:38 <pyNem> why not just a tuple?
10:47:48 <BONUS> well it's a stateful function
10:47:54 <BONUS> a function from a state to a result and a state
10:47:56 <vixey> pyNem, I find it (StateT) very useful in a monad transformer stack
10:47:57 <centrinia> The monad hides the state. ;)
10:48:04 <BONUS> so it could be just: s -> (a, s)
10:48:13 <BONUS> but then we couldn't make it an instance of Monad over the a
10:48:14 <pyNem> vixey, I dont know monad transformers yet
10:48:25 <vixey> pyNem, if you have written most of your code, then suddenly realize you need a mutable cell to hold constraints for example -- you can just add StateT into that and be done
10:48:42 <vixey> pyNem, which is a lot smaller a change than adding a tuple to every application
10:49:03 <pyNem> oh .. that makes sense @ vixey .. can I see simple examples somewhere?
10:49:36 <vixey> pyNem, yeah I learned how to use it from http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html
10:49:45 <pyNem> BONUS, I finally understood why they chose s -> (a,s) only yesterday after reading a post by mvanier, (over say functions like (s,a) -> (s,a) or a -> (a, s))
10:50:04 <BONUS> think of a statement in C
10:50:04 <BONUS> like
10:50:10 <BONUS> a = 5;
10:50:30 <BONUS> that expression can be thought of taking a state, which are all the previous variables
10:50:43 <BONUS> and returning a tuple of (result, state)
10:50:53 <BONUS> where the new state is all the previous variables along with a mapped to 5
10:50:55 <BONUS> and the result is 5
10:50:58 <pyNem> so the result \subset of new state?
10:51:07 <BONUS> because in C, a = 5 also returns 5
10:51:11 <chessguy> hm, i thought there was a cool state monad example in the "Blow your mind" wiki page
10:51:11 * strht_ overthrows the #haskell bourgeoisie order
10:51:19 <centrinia> Which tree programming languages are actively developed right now?
10:51:19 <vixey> in reality to implement a = 5 I would use ST though
10:51:21 <pyNem> vixey, will look at it .. I dont think ill understand though
10:51:32 <chessguy> centrinia:  tree programming languages?'
10:51:36 <vixey> pyNem, you will :p
10:51:45 <SamB> pyNem: yes, but why over s -> (s, a) ?
10:51:50 <vixey> pyNem, ask stuff here if something is confusing, it is relatively straightforward though (the presentation is good)
10:51:51 <centrinia> chessguy, I only found Refal and TXL on Wikipedia. :(
10:52:04 <BONUS> pyNem: maybe you'll find this forum post i once wrote useful: http://forums.somethingawful.com/showthread.php?threadid=2841145&pagenumber=6#post346173552
10:52:07 <centrinia> By your reaction, they don't seem to be very popular. :(
10:53:32 <strht_> haskell does tree programming
10:53:41 <strht_> construct nodes out of list elements
10:53:52 <strht_> unless you have a tree structure planned, you devil you
10:53:54 <chessguy> strht_:  sure, haskell's Data.Tree module is pretty easy
10:53:56 <pyNem> vixey, My problem is this.. I still dont grasp a) why we prefer s -> (s, a) to something like (s,a) -> (s,a) b) In things which have io and state monads interleaved like for example the famous "guess the random number" program.. how things work and c) how do I actually use it in haskell (all places I saw had their own interface functions)
10:54:08 * strht_ reinvents the tree
10:54:11 <vixey> @src State
10:54:11 <lambdabot> Source not found. That's something I cannot allow to happen.
10:54:20 <vixey> pyNem, exactly what is s -> (s, a) the type of?
10:54:30 <pyNem> sorry .. s -> (a,s)
10:54:30 <BONUS> pyNem: it could be just s -> s
10:54:37 <vixey> @src >>= State
10:54:38 <lambdabot> Source not found. My pet ferret can type better than you!
10:54:41 <vixey> @src State >>=
10:54:42 <lambdabot> Source not found. Take a stress pill and think things over.
10:54:47 <BONUS> but it's useful to have s -> (a, s) because then we think of a as the result of the stateful operation
10:54:48 <chessguy> @src (>>=) State
10:54:49 <lambdabot> Source not found. Just try something else.
10:54:59 <vixey> :t (>>=)
10:55:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:55:21 <pyNem> oh okay .. BONUS vixey so a is the relevant part of the new state?
10:55:26 <vixey> pyNem, where did you find s -> (s, a)?
10:55:33 <strht_> oh wow
10:55:52 <pyNem> vixey, I meant s -> (a,s)
10:56:00 <centrinia> Maybe the s is the value and the a is the state ;)
10:56:01 <vixey> pyNem, ok but what is that the type of?
10:56:31 <BONUS> or think of another C-like function
10:56:34 <pyNem> vixey, thats problem c) .. most of the monad tutorials have their own interfaces, and newtypes .. State I think
10:56:42 <vixey> :t State
10:56:44 <lambdabot> forall s a. (s -> (a, s)) -> State s a
10:56:46 <pyNem> BONUS, okay ..
10:56:50 <centrinia> vixey, runstate.
10:56:53 <BONUS> delete_file(string file_path)
10:56:56 <BONUS> when you run it
10:56:58 <BONUS> it deletes a file
10:57:03 <BONUS> and returns 1 if it managed to delete it
10:57:10 <BONUS> and returns 0 if it didnt delete it
10:57:13 <pyNem> BONUS, yup
10:57:24 <BONUS> it can be thought of as a state function from an old hard disk drive to a new hard disk drive
10:57:29 <BONUS> and the a is the 1 or 0
10:57:30 <vixey> pyNem: ok, the type of state is  (s -> (a, s)) -> State s a
10:57:30 <vixey> \
10:57:37 <BONUS> which represents some sort of result of the stateful computation
10:57:42 <BONUS> or state transition if you will
10:57:47 <vixey> pyNem: and you wonder why the first parameter is a function from s to (a, s) ?
10:57:55 <pyNem> vixey, yup
10:58:00 <pyNem> BONUS, okay ..
10:58:17 <BONUS> what the state monad then allows you to do with that
10:58:19 <BONUS> is to do
10:58:24 <BONUS> result <- delete_file
10:58:30 <BONUS> and the a gets bound to result
10:58:35 <BONUS> while the state "changes
10:58:36 <BONUS> "
10:58:54 <pyNem> oh okay
10:58:57 <vixey> pyNem, the _model_ of a stateful 'computation' is a function s -> (a, s) for example increment s = ((), s+1), so State increment :: State Integer ()
10:59:12 <pyNem> BONUS, and a is implictly stored in the state .. (Everything is `threaded` into the state?)
10:59:37 <BONUS> kind of. what the next stateful computation will be depends on a
10:59:46 <BONUS> because if you use the previous a in the one of the next states
10:59:55 <BONUS> they depend on what the a was
11:00:00 <BONUS> i mean one of the next stateful transitions
11:00:05 <BMeph> @src return (State s)
11:00:05 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:00:15 <strht_> @src zipWith
11:00:16 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:00:16 <lambdabot> zipWith _ _      _      = []
11:00:17 <vixey> pyNem, and to model a stateful function, you can have  swap e (x:xs) = (x, e:xs), which swaps the top element of the stack with e.. and then \e -> State (swap e) :: State a [a]
11:00:33 <vixey> pyNem, (that example is a bit strange but hopefully it makes sense?)
11:00:38 <BONUS> monads have some sort of result a lot of the times contained in them
11:00:48 <pyNem> vixey, that totally made sense .. :)
11:00:48 <BONUS> whereas if you have Just 8, 8 is the result contained in it
11:00:56 <BONUS> if you have \s -> (8, s+1)
11:01:02 <BONUS> 8 is the result in that stateful transition
11:01:08 <pyNem> BONUS, oh okay ..
11:01:17 <BONUS> and you can bind results, you know like, result <- Just 8
11:01:37 <vixey> oops
11:01:43 <vixey> my type annotation was slightly wrong
11:01:46 <vixey> I meant :: a -> State a [a]
11:02:47 <pyNem> okay .. BONUS, but what if a cannot be determined by the state transition alone .. ? Like one I had problem with.. I want to count say elements in a list .. in a _stupid_ state transformer fashion.. Then my a, will be the remainder of the list, and state will be the no. of elements I have come across. or should it be the other way around
11:03:08 <pyNem> vixey, got that
11:03:12 <BONUS> the other way around imho
11:03:22 <BONUS> for instance you can do this
11:03:34 <BONUS> you know splitAt
11:03:36 <vixey> pyNem, you can use pop :: (Maybe a, [a]) as a tool to write this counter
11:03:49 <BONUS> > splitAt 2 [1..10]
11:03:50 <lambdabot>   mueval: Prelude.read: no parse
11:03:58 <BONUS> ugh wtf lambdabot
11:04:01 <vixey> argh, pop :: State (Maybe a) [a]
11:04:14 <pyNem> BONUS, so my state will be a pair of lists (what i have seen so far, what I am yet to see) and my result is the increment?
11:04:33 <BONUS> hmm i dont know how exactly your problem is laid out but check this out
11:04:44 <BONUS> if you do
11:04:45 <pyNem> vixey, oh .. Ill have a look at pop then
11:04:49 <BONUS> splitAt 2 [1..10]
11:04:51 <BONUS> it will return
11:04:59 <BONUS> ([1,2],[3..10])
11:05:01 <pyNem> )[1,2] [3..100])
11:05:03 <pyNem> yup
11:05:05 <BONUS> yeah
11:05:11 <BONUS> so you can think of splitAt 2
11:05:16 <BONUS> as a function that takes a list
11:05:26 <BONUS> and returns a result, which represents, say, the list that it "ate up"
11:05:36 <BONUS> and the remained, which is the list that it didnt eat up
11:05:41 <BONUS> so you can then do
11:05:52 <pyNem> like the parser that is used in Programming in Haskell? (The parsed string, and the rest)
11:05:52 <Raynes> BONUS: Did you get my email about the typo I found in your tutorial?
11:06:03 <BONUS> Raynes: when did you send that?
11:06:07 <BONUS> yeah kind of
11:06:09 <BONUS> so you can do
11:06:09 <Raynes> Last night.
11:06:16 <BONUS> oooh let me check ^_^
11:06:18 <BONUS> i been busy
11:06:43 <BONUS> stateSplitAt n = State $ \list -> splitAt n list
11:06:48 <Raynes> It's nothing big, just "say" instead of "says" but I thought I'd let ya know.
11:06:59 <BONUS> every correction is appreciated!
11:07:06 <Raynes> :)
11:07:19 <BONUS> ah yeah its in my inbox. muchos gracias senor!
11:07:30 <Raynes> No problem.
11:07:32 <BONUS> and then you could do
11:08:00 <gwern> :t splitAt
11:08:01 <lambdabot> forall a. Int -> [a] -> ([a], [a])
11:08:13 <gwern> > splitAt 2 [1..10]
11:08:14 <BONUS> blah = do a <- stateSplitAt 3; b <- stateSplitAt 2; c <- stateSplitAt 2; return [a,b,c];
11:08:15 <lambdabot>   ([1,2],[3,4,5,6,7,8,9,10])
11:09:30 <pyNem> oh
11:09:44 <dmhouse> ?type State
11:09:45 <lambdabot> forall s a. (s -> (a, s)) -> State s a
11:09:46 <pyNem> and that would be a function which takes a list .. and returns lists split up at 3, 2, and 2?
11:09:51 <dmhouse> ?type splitAt
11:09:52 <lambdabot> forall a. Int -> [a] -> ([a], [a])
11:09:56 <BONUS> yeah
11:10:05 <BONUS> it is in itself a state transition function
11:10:10 <pyNem> yeah
11:10:11 <BONUS> it takes a list, like [1..10]
11:10:19 <vixey> :t \x -> State (splitAt x)
11:10:20 <lambdabot> forall a. Int -> State [a] [a]
11:10:21 <BONUS> and returns as its result the list split at 3, 2 and 2
11:10:34 <BONUS> and as the second component, it returns the list that it didnt eat up
11:10:52 <pyNem> oh .. I think I understand that now :)
11:11:18 <pyNem> thanks BONUS
11:11:20 <BONUS> haha np
11:11:36 <pyNem> ill try writing something myself now
11:11:39 <BONUS> return 3 just creates a state transition function that will as its result have 3
11:11:40 <pyNem> and vixey thanks too
11:11:46 <BONUS> and it iwll leave the state unchanged
11:11:47 <vixey> ok :)
11:11:55 <BONUS> look at that link i gave you to see how i implemented stacks :)
11:12:14 <BONUS> or just implement stacks yourself
11:12:20 <BONUS> basically the head of the list is the top of the stack
11:12:36 <pyNem> yup! stumbled upon it last night itself .. dint have time to look at it .. will do today :)
11:12:50 <BONUS> and push a is a state transition from \xs -> ((), a:xs)
11:13:06 <BONUS> and pop a would be a state transition from \(x:xs) -> (x, xs)
11:13:18 <pyNem> sounds really easy.. when I look at it that way
11:13:20 <pyNem> :)
11:13:26 <BONUS> hehe
11:13:50 * pyNem thinks the years of imperative programming kick in when someone says "stacks"
11:14:16 <BONUS> yeah hehe State is kind of a little functional throwback to imperative programming
11:14:20 <BONUS> that's why stacks work
11:14:43 <pyNem> BONUS, ok.. then .. will go look at that link right now
11:14:48 <BONUS> : ]
11:19:01 <pyNem> BONUS, did you write Learn you a Haskell?
11:19:12 <BONUS> no
11:19:15 <BONUS> im still writing it :D
11:19:53 <pyNem> :) .. It was amazing :) .. thanks .. I understood everything I read from there... and is still my quick reference to records and Data.List (after Prelude)
11:20:07 <BONUS> haha awesome! so glad it helped you!
11:20:10 <pyNem> I figured from the O-Kay. Style in LYAH, and in the link you gave me
11:20:28 <pyNem> I am waiting for the rest of the tutorial eagerly :)
11:20:42 <BONUS> haha, i'm a bit busy lately but work is still going strong on LYAH :)
11:20:48 <BONUS> glad people are finding it helpful
11:21:01 * pyNem tells himself that he shouldnt call it a tutorial.. It is really good.. far more than a tutorial.. a mini book perhaps
11:21:10 <BONUS> a magazine maybe
11:21:14 <_ar> BONUS: forgive me if you posted this already but do you have a link to your tutorial?
11:21:20 <BONUS> @where LYAH
11:21:20 <lambdabot> www.learnyouahaskell.com
11:21:20 <SamB> a book can be a tutorial
11:21:22 <BONUS> : ]
11:21:33 <pyNem> BONUS, :) .. thanks again
11:21:47 <BONUS> haha ^^
11:22:26 <_ar> BONUS: i've seen this. it's very nice
11:22:34 <BONUS> thanks!
11:23:27 <BONUS> hey jeffwheeler
11:23:34 <BONUS> did you used to frequent the kirupa.com forums
11:27:03 <jeffwheeler> LYAH really is marvelously written.
11:27:16 <BONUS> you think so? d'awww :3
11:27:53 <BONUS> hey jeffwheeler were you nokrev on the kirupa.com forums
11:28:00 <jeffwheeler> BONUS: yes.
11:28:07 <BONUS> ah, i remember you from there :)
11:28:12 * BONUS waves
11:28:16 <jeffwheeler> What was your username?
11:28:22 <BONUS> foodpk
11:28:27 <jeffwheeler> Oh! Hey.
11:28:34 <BONUS> hehe :)
11:28:48 <BONUS> i stopped visiting that place once my interest for php and flash kind of faded
11:28:50 <BONUS> it was fun though
11:29:03 <jeffwheeler> Oh, I never touch PHP or Flash, but the forums are great.
11:47:53 <ac> @seen humasect
11:47:53 <lambdabot> I saw humasect leaving #haskell-overflow 2m 12d 13h 53m 45s ago, and .
11:57:51 <ben123> cabal install FastCGI got the following error: fastcgi-3001.0.2.2 failed during the configure step. The exception was:
11:57:51 <ben123> sh: runProcess: does not exist (No such file or directory)
11:57:51 <ben123>  
11:58:31 <ben123> this is on windows XP
12:04:38 <pyNem> BONUS, that page on stacks using monads was very helpful :)
12:08:27 <adekoba> how can I get cabal haddock to link to the documentation of external packages? e.g., Int, Maybe, etc. google says to use --html-location=http://hackage.haskell.org/packages/archive/$pkg/$version/doc/html, but that doesn't seem to work
12:08:44 <BONUS> pyNem nice :)
12:08:56 <BONUS> glad to be of help
12:09:02 <BONUS> bbl
12:09:45 <xenoterracide_> why does dropWhile even [2,4,6,7,9,10,12] return [7,9,10,12] ? 10 and 12 are even?
12:10:07 <BONUS> it drops the numbers while they are even
12:10:15 <BONUS> once a number that's not even is found, it stopps dropping them
12:10:26 <xenoterracide_> oh I get it
12:10:28 <xenoterracide_> ok
12:10:32 <xenoterracide_> thanks
12:10:35 <BONUS> basically it cuts it off the first time a non even is encountered
12:10:36 <BONUS> :)
12:10:44 <BONUS> use filter if you want to get rid of 10 and 12 too
12:11:08 <xenoterracide_> I was just reading an example and didn't understand why it gave those results
12:14:35 <xenoterracide_> seems odd to want the behavior to stop the first time it encounters it's predicate instead of cycling through the whole list
12:16:51 <gwern> xenoterracide_: wouldn't that be filter?
12:17:23 <xenoterracide_> guess so..
12:19:16 <gwern> xenoterracide_: so now you know why dropWhil acts like that :)
12:19:48 <gwern> 'a lesser light once asked Ummon - why are the roots of radishes so short? Ummon replied: because rainwater is plentiful'
12:20:19 <sinelaw> at least it used to be
12:20:20 <vixey> I don't understand it gwern:(
12:20:26 <xenoterracide_> heh
12:20:59 <mapreduce> Lazy evaluation.
12:21:22 <gwern> vixey: meditate harder on it. I find it appropos for the current discussion
12:21:42 <mapreduce> @faq can Haskell help me in the garden?
12:21:43 <lambdabot> The answer is: Yes! Haskell can do that.
12:21:59 <sinelaw> but, will it?
12:22:28 <gwern> why did lambdabot come from the west?
12:22:44 <gwern> the lambda in the garden.
12:22:53 <Plouj> Cale: thanks for the offer, but I'm busy withxmass stuff now :)
12:25:13 <sinelaw> what can anybody tell me about static analysis of programs?
12:25:18 <sinelaw> is it a subject worth learning?
12:25:30 <gwern> types are indeed worth learnign about
12:26:24 <eu-prleu-peupeu> hi Hppl
12:26:36 <gwern> sinelaw: indeed, one might see haskell as an argument that static analysis is extremely worthwhile
12:26:37 <eu-prleu-peupeu> happy cHristmas to all of you
12:27:01 <sinelaw> i mean stuff like, despite the halting problem, can we answer questions such as "will this function return a value that satifies requirement X"?
12:27:03 <cnwdup> Can I view the source of a function using ghc? Like lambdabot's @src.
12:27:05 <jeffwheeler> Merry Christmas, eu-prleu-peupeu.
12:27:16 <SamB> sinelaw: not always
12:27:17 <eu-prleu-peupeu> thanks jeff
12:27:21 <idnar> cnwdup: lambdabot's @src just looks stuff up in a text file :/
12:27:25 <sinelaw> Happy Hannuka too :)
12:27:44 <gwern> cnwdup: you could integrate ghci and lambdabot. look up ghci on acid
12:27:52 <gwern> which would obviously get you lb's @src
12:28:09 <sinelaw> SamB obviously not always, question is - is this a dead-end field or does it have some future
12:28:27 <sinelaw> (therefore worthwhile learning about)
12:28:52 <SamB> you can sometimes prove things, yeah
12:28:58 <dons> ?yow
12:28:58 <lambdabot> I was born in a Hostess Cupcake factory before the sexual revolution!
12:29:02 <dons> ?users
12:29:02 <lambdabot> Maximum users seen in #haskell: 568, currently: 543 (95.6%), active: 19 (3.5%)
12:29:17 <eu-prleu-peupeu> dons always controling the user count :)
12:30:03 <cnwdup> gwern: thanks
12:30:05 <sinelaw> it'd be nice to have an automatic verification system with your programming gui, such as "this function (defined like this) must always return a value between 3 and 9"
12:30:18 <vixey> sinelaw, between 3 and 9 ? lol
12:30:30 <sinelaw> :)
12:30:44 <gwern> but between 3 and 9 is, like, an infinity of values
12:30:45 <sinelaw> couldn't think of a sillyer example.
12:30:57 <sinelaw> gwern, yes but it's a constraint
12:31:01 <vixey> only one infinity?
12:31:29 <sinelaw> the function might have a bug and return < 3 sometimes
12:31:43 <sinelaw> it's a stupid example
12:31:54 <vixey> sinelaw, you are interested in formal correctness of programs?
12:31:58 <sinelaw> yes
12:32:01 <sinelaw> i mean
12:32:10 <sinelaw> what do you mean by that? :)
12:32:16 <vixey> sinelaw, have you seen Martin Lof Type Theory and Coq?
12:32:18 <gwern> vixey: well, I think if you had more infinites between 3 and 9 that'd solve the continuum hypothesis
12:32:24 <gwern> although I'm not sure
12:32:55 <sinelaw> I've heard of Coq
12:33:03 <gwern> sinelaw: you can add constraints of course to your functions - just add lines like 'if not (x > 3 && x < 9) then error 'bad value' else stuff'
12:33:12 <gwern> sinelaw: but runtime constraitns aren't very interesting.
12:33:27 <sinelaw> gwern, no i'm interested at something that will say: Hey, your requirement is not satisfied.
12:33:32 <sinelaw> (the code is wrong)
12:33:50 <sinelaw> but i have no interesting example.
12:34:01 <gwern> how can a function in isolation make that kind fo assertion?
12:34:20 <sinelaw> gwern the compiler can, maybe
12:34:22 <vixey> sinelaw, my favorite example of strong specification is
12:34:23 <gwern> it depends in input. if I define f = +1, then it's correct if I call it with 4.5, or 5, or 6...,
12:34:49 <gwern> but suppose we get a number at runtime, how could the compiler say either way
12:34:59 <gwern> I could feed the executable a 5, or a 10
12:35:21 <sinelaw> gwern: abs(x)/x + 4 always returns 5 or 3
12:35:31 <vixey> sinelaw, parse :: (s :: String) -> Maybe { parseTree | Parse s parseTree }, and print :: (p :: Syntax) -> { s | Parse s p }
12:35:48 <vixey> sinelaw, 'Parse' being some relation between text and syntax
12:36:23 <gwern> sinelaw: no.
12:36:41 <sinelaw> well except for 0
12:36:43 <vixey> showing the functions are inverse is completely trivial because of the specification
12:37:00 <gwern> that, and consider - x may not terminate, it may be bottom
12:37:30 <sinelaw> ok, besides termination
12:37:42 <gwern> termination is a pretty big issue
12:38:05 <sinelaw> gwern true, but you're also very much interested in the normal behaviour
12:38:15 <sinelaw> given a valid value, will this function screw up?
12:39:21 <sinelaw> vixey , i'm a little new to haskell i don't think i got your point with that example
12:39:32 <vixey> sinelaw, not haskell
12:39:47 <sinelaw> well it failed to parse :P
12:39:50 <gwern> well, if you have a language like haskell, which was total, then you could certainly verify that such a function went Int -> Int, but it would be difficult to write a function that was MyRestrictedInt -> MyRestrictedInt
12:40:44 <sinelaw> in control theory they speak of stuff like stability, controllability and observability. are any of these ever applied to programs?
12:41:55 <gwern> In a nontotal language, you *could* do something like 'convert :: Int -> MyRestrictedInt' and then maybe you could then have every MyRestrictedInt -> MyRestrictedInt call convert on its output (convert killing the program if no between 3 and 9)... so that at the end of a function chain, if you had a value, it would be in the correct range
12:42:00 <gwern> but that'd be stupid
12:43:11 <sinelaw> gwern i'm not sure we're thinking about the same thing. I'm just asking for a way to statically verify (aka compile time) that a function satisfies some requirement regarding it's input->output behaviour
12:43:37 <gwern> you're not going to get that without gnarly type-level work
12:43:55 <gwern> there are libraries and demonstrations of doign that sort of thing on the type-level, but they're esoteric and hard to use
12:44:01 <gwern> @quote Oleg
12:44:01 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
12:44:08 <vixey> sinelaw, you can do it in either of the two I talked about..
12:44:09 <sinelaw> heh
12:44:15 <gwern> @quote Oleg
12:44:16 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
12:44:17 <baaba> sinelaw, see http://www.ats-lang.org/ and http://www.ats-lang.org/EXAMPLE/MISC/listquicksort.dats
12:44:21 <gwern> @quote oleg
12:44:21 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
12:44:27 <gwern> @quote oleg
12:44:28 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
12:44:31 <gwern> hm.
12:44:34 <gwern> @olegfact
12:44:35 <lambdabot> Unknown command, try @list
12:44:45 <gwern> did we lose the oleg facts agian?
12:44:54 <kublar> @quote oleg.fact
12:44:55 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
12:47:09 <sinelaw> baaba that quicksort example looks horribly complicated :)
12:47:30 <sinelaw> but impressive
12:49:07 <gwern> @where koans
12:49:07 <lambdabot> I know nothing about koans.
12:49:10 <gwern> @where koan
12:49:11 <lambdabot> I know nothing about koan.
12:49:33 <kublar> preflex: ? koan
12:49:33 <preflex>  factoid not found
12:50:23 <gwern> @where haiku
12:50:24 <lambdabot> http://haskell.org/haskellwiki/Haiku
12:50:25 <gwern> @quote koan
12:50:26 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
12:50:41 <kublar> preflex: quote
12:50:42 <preflex>  <yaakov> The problem is that the inheritance tax makes OO programming expensive.
12:50:54 <sinelaw> heh
12:55:24 <Juergen5_> hey leutz was geht ab
12:55:57 <kublar> spam.
12:58:06 <kublar> preflex: quote
12:58:07 <preflex>  <mauke> Hungarian Notation constructs a type system in the mind of the programmer
12:58:51 <gwern> hm. true and funny
13:00:48 <int-e> hmm. "What is the essence of lazy evaluation?" - <silence> - "Did you hear my question?" - <silence> - "Please, answer me." - "Yes, I heard. But I didn't know that you wanted an answer."
13:05:27 <Botje> :)
13:06:04 <vixey> @seen mmorrow
13:06:04 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 3h 56m 38s ago.
13:14:10 <saml> > '\235'
13:14:12 <lambdabot>   '\235'
13:15:36 <Peaker> int-e: "This lecture will be about lazy evaluation. Any questions?"
13:16:51 <int-e> The Koan of Lazy Evaluation: Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced “Today’s lecture will be about Lazy Evaluation”, he paused for a moment then concluded with, “Are there any questions?”
13:17:22 <int-e> (I wonder how many versions of that one exist)
13:18:41 <vixey> can you say anything about (Integer -> Integer) -> Bool using Cales topology for types?
13:36:13 <dons> http://www.reddit.com/r/programming/comments/7lkft/a_neighborhood_of_infinity_the_mother_of_all/
13:39:53 <Axman6> "let's make a hole in the code" oh god, isn't that dangerous? :o
13:54:27 <nolrai_East> @unmlt StateT s [] a
13:54:28 <lambdabot> Maybe you meant: unmtl unpl
13:54:36 <nolrai_East> @unmtl StateT s [] a
13:54:36 <lambdabot> s -> [(a, s)]
13:57:35 * jkff rewrites his simple and fast Java class file parser in Haskell
13:57:48 <Heffalump> shapr!
13:57:56 <shapr> yes?
13:58:01 <shapr> Hiya Heffalump!
13:58:06 <Heffalump> just saying hi :-)
13:58:09 <shapr> Hiya!
13:58:45 <shapr> How's code?
13:58:49 <shapr> @users
13:58:49 <lambdabot> Maximum users seen in #haskell: 568, currently: 545 (96.0%), active: 10 (1.8%)
13:59:04 <Heffalump> unhygienic.
13:59:12 <shapr> Ah, I see.
13:59:28 <Heffalump> (I'm having my usual problems with substitution)
13:59:43 <vixey> substitition Heffalump on what?
13:59:44 <redditbot> A Neighborhood of Infinity: The Mother of all Monads
14:00:03 <Heffalump> expressions
14:00:09 <vixey> with binders?
14:00:14 <Heffalump> yes
14:00:23 <jkff> (I must say that I just read the redditbot article and it is great, as is everything from sigfpe)
14:00:25 <vixey> have you read I am not a number I am a free variable?
14:00:38 <Heffalump> every single time I implement something with binders I fool myself into thinking I can get away without a unique name supply and every time I'm wrong
14:00:47 <vixey> a bit more sensible than HOAS for a lot of things
14:00:55 <vixey> you don't need a unique name supply for it
14:01:41 <Heffalump> I'm aware of it, but I don't remember the details. I'll take a look again, thanks.
14:02:23 <vixey> the really nice trick I took from it
14:02:27 <vixey> newtype Scope a = Scope a
14:02:43 <vixey> so you have data T = ... | Lam (Scope T) | ..., that kind of thing
14:05:58 <BMeph> Hi, Heffalump, and congratulations to/for you and your family! :)
14:06:19 <Heffalump> thanks :-)
14:06:27 <procyon112> I'm trying to map a (char->char) function across the first String in a [(String, String)] (essentially I want to "toLower" the fst in my association list to return a new assoc list.) Is there an arrow or somesuch that handles all the deconstruction/reconstruction for me?
14:06:50 <Heffalump> procyon112: look at Conal Elliott's "semantic editor combinators"
14:06:52 <jkff> :t map (first toLower)
14:06:53 <lambdabot> forall d. [(Char, d)] -> [(Char, d)]
14:06:57 <vixey> procyon112: It's easy to write  first f (x,y) = (f x, y)
14:06:59 <jkff> :t map (first (map toLower))
14:07:01 <lambdabot> forall d. [([Char], d)] -> [([Char], d)]
14:07:16 <jkff> > map (first (map toLower)) [("hElLo", "World)]
14:07:18 <lambdabot>   <no location info>:
14:07:18 <lambdabot>      lexical error in string/character literal at chara...
14:07:21 <vixey> shapr!
14:07:21 <jkff> > map (first (map toLower)) [("hElLo", "World")]
14:07:23 <lambdabot>   [("hello","World")]
14:07:48 <jkff> procyon112, is that what you need?
14:07:52 <procyon112> sweet.  Thanks.
14:08:00 <SamB> :t (map . first . map) toLower
14:08:01 <lambdabot> forall d. [([Char], d)] -> [([Char], d)]
14:08:11 <SamB> procyon112: is that prettier ?
14:08:24 <vixey> :t map . ?f . map
14:08:25 <lambdabot> forall a b a1 b1. (?f::([a1] -> [b1]) -> a -> b) => (a1 -> b1) -> [a] -> [b]
14:08:31 <centrinia> @pl (map . first . map) toLower
14:08:32 <lambdabot> map (first (map toLower))
14:08:45 <jkff> WHOA! ?f is cool
14:08:53 <vixey> yikes how did you come up with that SamB
14:08:58 <jkff> Oh, the treasures of lambdabot
14:09:06 <SamB> vixey: I used the pl in my head
14:09:07 <procyon112> > map (first (map toLower)) [("Xyz","ABC"),("TesT","Testing")]
14:09:09 <lambdabot>   [("xyz","ABC"),("test","Testing")]
14:09:21 <procyon112> jkff: Yes!  Thanks.
14:09:21 <vixey> j0 jkff
14:09:27 <SamB> it's not as capable as the real one, but it's more flexible
14:10:01 <procyon112> SamB:  Yes.  prettier :)
14:10:56 <jkff> @djinn forall d. [([Char],d)] -> [([Char],d)]
14:10:57 <lambdabot> Error: Undefined type []
14:11:01 <jkff> Hmm
14:11:27 <jkff> @djinn forall a b c . (b->c) -> (a->b) -> (a->c)
14:11:28 <lambdabot> f a b c = a (b c)
14:11:38 <jkff> @djinn forall a b . (a->b) -> [a] -> [b]
14:11:39 <lambdabot> Error: Undefined type []
14:11:42 <Peaker> semantic editor combinators
14:11:47 <Peaker> are the hot new thing, it seems :)
14:12:14 <SamB> I've never really seen the Arrow module as being about arrows ;-P
14:12:30 <vixey> yeah arrows are so stupid
14:12:37 <SamB> Peaker: I've been doing that simple stuff for a while
14:12:40 <vixey> down with arrows :p
14:12:41 <SamB> vixey: not that stupid
14:12:59 <SamB> I think they are perhaps more useful in, say, Coq, though
14:13:06 <Peaker> SamB: functions are just a special case of arrows :P
14:13:29 <Peaker> Haskell' needs to break arrows down further than Category/Arrow
14:14:07 <SamB> Arrows don't need to be in the standard!
14:14:14 <vixey> Haskell' should be forgotten
14:14:21 <SamB> yeah, I agree
14:14:24 <SamB> it's not that great
14:14:31 <Heffalump> Haskell' has been forgotten, I thought. There'll be a series of minor revisions instead.
14:14:33 <SamB> it's not out yet and I already have a better Haskell
14:14:51 <SamB> (than Haskell')
14:15:07 <SamB> I want 1.6
14:15:13 <jkff> SamB: Why are arrows more useful in Coq?
14:15:31 <vixey> jkff, hi
14:15:35 <SamB> jkff: well, you can use them to represent calculusy things
14:16:07 <jkff> vixey: hi
14:16:09 <SamB> though that is probably without the arr method
14:16:21 <augustss> Yeah, Haskell' had it's chance.  It won't happen.
14:16:23 <jkff> SamB: Which things, for instance?
14:16:26 <vixey> jkff, any progress on doing free theorems?
14:16:43 <vixey> jkff, I want to try it again but I don't really have any deeper understanding of it I think
14:16:57 <jkff> vixey: Nope, I've been busy with other studies :( However, now that these studies are complete, I'll have time to continue with the FT
14:17:35 <jkff> In the meantime, one of the studies motivated me to try Coqifying LTL, and I tried to do it with category theory; I didn't succeed fully, but it was a very nice experience still
14:18:06 <vixey> what's LTL?
14:18:11 <jkff> Linear temporal logic
14:18:16 <vixey> oh
14:18:27 <jkff> The study was on verification of parallel processes
14:19:04 <jkff> I was going to show off before the teacher and show that one of the properties to verify follows from the other two, in a perverted way :)
14:19:41 <SamB> jkff: on reflection, I may have just been thinking of categories
14:19:52 <dons> augustss: yeah, expect rolling small updates a la FFI spec.
14:20:05 * shapr hugs vixey 
14:20:06 <dons> something that actually fits with community funding, and available time.
14:20:42 <SamB> dons: can we buy some documentation ?
14:20:43 <augustss> dons: I think that's the way forward.  And perhaps when there are enough extensions we can staple them together and call them Haskell XP.
14:21:09 <dons> yep. ship it!
14:21:20 <SamB> augustss: what are we going to call the next one then ???
14:21:25 <SamB> not Haskell Vista!
14:21:31 <augustss> Vista, of course
14:21:39 <SamB> Vista is a flop
14:21:52 <afabian> Hmm.  What's the difference between a non-terminating expression and an infinite expression?  If I say let bot = bot and try to evaluate bot, I get ... the end of the process.  [1..], which also doesn't terminate, results in... a big list printed.  Why does Haskell die and give up in one case of evaluating and infinite expression, and in the other, keep computing it..?
14:22:07 <centrinia> Haskell 98 needs to first upgrade to Haskell 2000.
14:22:08 <jkff> A non-terminating expression doesn't have a weak head normal form
14:22:12 <dons> Haskell Prime: you're already using it, you just didn't know it.
14:22:19 <SamB> afabian: well, the implementation took a shortcut
14:22:29 <_dolio> So that it's only 8 years out of date instead of 10?
14:22:30 <SamB> > let bot = bot in bot
14:22:33 <jkff> When you evaluate [1..], you get [1..]. When you ask the interpreter to show its value, you are actually evaluating putStrLn . show $ [1..]
14:22:35 <vixey> afabian: it always takes a finite time to get another piece off [1..] (it's productive)
14:22:38 <augustss> afabian: the expression [1..] is said to be productive.
14:22:45 <jkff> And it is putStrLn . show $ [1..] who doesn't terminate.
14:22:45 <lambdabot>   thread killed
14:23:00 <afabian> Ahh.  I see.  Thanks.
14:23:05 <SamB> huh, well, in this case the RTS didn't even spot it?
14:23:13 <SamB> , let bot = bot in bot
14:23:18 <lunabot>  luna: out of memory (requested 2097152 bytes)
14:23:21 <SamB> again ???
14:23:25 <SamB> what's with these guys
14:23:29 <centrinia> > fix ((`mod` 1) . (+1)) 1
14:23:31 <lambdabot>       No instance for (Integral (t -> a))
14:23:31 <lambdabot>        arising from a use of `mod' ...
14:23:39 <SamB> > fix id
14:23:40 <lambdabot>   * Exception: stack overflow
14:23:44 <SamB> , fix id
14:23:46 <lunabot>  luna: out of memory (requested 2097152 bytes)
14:24:10 <Heffalump> Hello yav. I was just thinking about using value-supply.
14:24:13 <SamB> > last [1::Integer..]
14:24:14 <lambdabot>   <no location info>: parse error on input `Integer..'
14:24:18 <SamB> > last [1::Integer ..]
14:24:23 <BMeph> Haskell: The Next Generation sounds good to me... ;p
14:24:23 <Heffalump> > last [1..]
14:24:39 <lambdabot>   mueval: Prelude.read: no parse
14:24:39 <lambdabot>   thread killed
14:24:56 <centrinia> > fix ((`mod` 1) . (+1))
14:25:04 <Botje> BMeph: will it feature a balding dons in his quest to seek out new lambdas and new concurrency libraries?
14:25:05 <yav> Heffalump: cool.  let me know how it works. as you might have seen, i have been working on it over the last few days
14:25:08 <SamB> > last [(1::Integer) ..]
14:25:24 <BMeph> Followed by, Haskell: The Adventure Continues! :)
14:26:17 <SamB> will Haskell Enterprise hark back to the 1.4 days but contain lots of CG bits?
14:27:56 <gwern> SamB: it's a programming language. it's *all* CG
14:28:22 <SamB> most of Haskell 98 seems to have been written by humans
14:28:51 <Taejo> I have "class Get' ind list e | list -> ind, list -> e"
14:29:11 <gwern> I ain't never run a haskell program which wasn't compiled by a computer, linked by a computer, and typed by a computer, and ran by a human
14:29:20 <Taejo> and GHC is telling me "instance Get' () e e" and "nstance Get' ind list e => Get' (Int, ind) [list] e" conflict
14:30:00 <kublar> [list] and e overlap
14:31:17 <Taejo> kublar: but [list] only appears when ind is (Int, a) and e only when ind is ()
14:31:53 <SamB> Taejo: ask on cafe ?
14:32:07 <Taejo> oh, I think I see it
14:33:03 <Taejo> what is the FD syntax for "a and b determine c"
14:33:12 <Heffalump> a b -> c
14:33:13 <augustss> mmmm, a new sigfpe blog post
14:33:39 <gwern> oh siggie!
14:38:34 <nolrai_East> @src liftM2
14:38:56 <gwern> 'About a year ago I must have skimmed this post because the line "the continuation monad is in some sense the mother of all monads" became stuck in my head.'
14:39:30 <nolrai_East> @bot
14:39:30 <lunabot>  :)
14:39:40 <gwern> These reports, that the Haskellers are in Baghdad - they are totally false, they are not true. The Haskellers are being GC'd by the thousands. Haskellers! Prepare for the mother of all monads!
14:39:53 <nolrai_East> @src liftM2
14:40:06 <baaba> liftM2 f m n = do { x <- m; y <- n; return $ f x y }
14:42:02 <nolrai_East> thanks
14:42:04 <jkff> @source liftM2
14:42:16 <jkff> Lambdabot, where are you?
14:42:21 <kublar> preflex: seen lambdabot
14:42:22 <preflex>  lambdabot was last seen on #haskell 17 minutes and 43 seconds ago, saying:   thread killed
14:42:22 <gwern> > 1+1
14:42:37 <jkff> Oh, that's what were his last words.
14:42:47 <gwern> tsk. these bad expressions seem to be a problem lately
14:43:32 <procyon112> @src words
14:43:41 <procyon112> ?src words
14:43:52 <procyon112> @source words
14:44:48 <EvilTerran> ?bot
14:45:12 <Peaker> @src liftM2
14:45:12 <PeakerLambda> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:45:39 <efficientjelly> there really is no way to find a maximum *key* in an IntMap?
14:45:40 <Peaker> no ghc extensions though, couldn't get that to compile :(
14:45:46 <Peaker> @hoogle IntMap
14:45:46 <PeakerLambda> module Data.IntMap
14:45:47 <PeakerLambda> Data.IntMap data IntMap a
14:46:39 <Peaker> efficientjelly: http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/Data-IntMap.html#19
14:46:43 <PeakerLambda> Title: Data.IntMap, http://tinyurl.com/9wo3o4
14:47:09 <efficientjelly> Peaker, ah, yes, that's what it says. but look at the type, it returns the value!
14:48:19 <Peaker> efficientjelly: I guess you could just hold (Int, a) instead of a's in there
14:48:25 <EvilTerran> efficientjelly, you could use a (Map Int a) instead of an (IntMap a)
14:48:43 <pumpkin> but IntMaps are cool
14:48:57 <Peaker> Really, why does IntMap exist? Wouldn't it make more sense to have Map Int a  have some specialized implementation for ints?
14:49:00 <ddarius> maxViewWithKey
14:49:12 <SamB> Peaker: um, that's not easy ;-P
14:49:29 <pumpkin> PeakerWork: the specialized stuff is ghc-specific
14:49:34 <SamB> this isn't C++ you know
14:49:36 <Peaker> SamB: Why not?
14:49:45 <SamB> how would you override it ?
14:49:52 <Peaker> SamB: language pragmas :)
14:49:53 <efficientjelly> ddarius, maxViewWithKey? doesn't that remove the maximum member?
14:50:03 <Peaker> also, what is it about IntMap that is more efficient than Data.Map?  Unboxing?
14:50:10 <ddarius> efficientjelly: This is a purely functional language
14:50:18 <SamB> Peaker: it would also wreak bloody hell with polymorphic functions
14:50:27 <Peaker> SamB: Why?
14:50:32 <efficientjelly> ddarius, I know. let me rephrase: doesn't it return a copy with the maximum member removed?
14:50:41 <ddarius> Peaker: An IntMap uses a totally different approach.
14:50:42 <SamB> Peaker: well, they'd have to typecase
14:50:46 <Peaker> ddarius: why?
14:50:46 <ddarius> efficientjelly: So?
14:50:52 <ddarius> Peaker: Because it can.
14:51:08 <dolio> Peaker: IntMap is a fancy trie, Map is a balanced tree.
14:51:08 <PeakerLambda> dolio: You have 1 new message. '/msg PeakerLambda @messages' to read it.
14:51:11 <SamB> ddarius: I don't think that's what peaker objects to
14:51:19 <efficientjelly> ddarius, I'd have to readd it. that's ugly. all I want is the maximum key. I did maximum . keys now, doesn't seem very efficient though (as it's O(n))
14:51:28 <BMeph> What's wrong with 'maximum . keys'? :)
14:51:35 <Peaker> dolio: why not have a typeclass of things that can be divided up for a Trie?
14:51:40 <dolio> Oh good. I got the message about \neg again.
14:51:53 <efficientjelly> BMeph, just did it. it's O(n), that kind of thing should be O(1)
14:51:56 <Peaker> dolio: I wondered how my bot has messages for you, if its only minutes in the channel
14:51:57 <BMeph> Heh-heh, nice timing, efficientjelly. :)
14:51:58 <efficientjelly> but I don't really care right now.
14:52:04 <efficientjelly> BMeph, yep 8)
14:52:09 <ddarius> efficientjelly: It likely works the way it does, in part because it is easy to do.  The operation is O(log n)
14:52:15 <Peaker> dolio: is that put into the default lambdabot build or something?
14:52:17 <SamB> BMeph: shouldn't it be last . keys?
14:52:24 <dolio> Peaker: Specializing data structures like that requires functional dependencies or type families.
14:52:35 <ddarius> efficientjelly: Just ignore the parts you don't need.
14:52:39 <dolio> Peaker: Must be. I've gotten that message 5 or 6 times.
14:52:47 <SamB> dolio: retaining the general version would be the tricky bit
14:52:50 <centrinia> Isn't findMax an O(log n) operation?
14:53:34 <efficientjelly> centrinia, it is, but it returns the value, not the key (contrary to what the documentation says. look at the type!)
14:53:37 <dolio> SamB: Yeah, well, it'd no longer be Ord based. It'd be based on whatever Key class you decide to have.
14:53:54 <nolrai_East> @bot
14:53:55 <lunabot>  :)
14:53:55 <PeakerLambda> :)
14:54:14 <efficientjelly> ddarius, maximum . keys is okay now. I will store the maximum key separately if I need more efficiency...
14:54:18 <dolio> Possibly with some auxillary Ord-based module that you can use to fill in the instance if you don't want to take the time to customize it to your data type.
14:54:20 <gwern> Peaker: msgs are part of the managed State/ files in lb, and are indeed part of the default build.
14:54:30 <nolrai_East> @pl liftT2 f a b = ChoiceT $ liftM f (unChoiceT a) (unChoiceT b)
14:54:34 <PeakerLambda> liftT2 = id (fix (const ((((ChoiceT $) .) .) . flip (flip . ((.) .) . flip ((.) . liftM) unChoiceT) unChoiceT)))
14:54:34 <PeakerLambda> optimization suspended, use @pl-resume to continue.
14:54:39 <Peaker> gwern: you decided to flood quite a few people that way :-) http://hpaste.org/13317
14:54:43 <ddarius> efficientjelly: Why wouldn't you use maxViewWithKey?  It's just as easy and more efficient?
14:54:53 <ddarius> fst . fst . maxViewWithKey
14:55:26 <gwern> Peaker: there'd only be one message, since lambdabot dumps State in ~/ and updates from there
14:55:27 <dolio> Peaker: It's not from other people's bots that I've gotten it. I've actually gotten it repeatedly from lambdabot herself.
14:55:38 <SamB> dolio: her mind is going I guess
14:55:42 <dolio> Yours is the first non-lambdabot one I think.
14:55:44 <efficientjelly> ddarius, I don't know. it seems so... messy
14:55:51 <Peaker> dolio: maybe it gets reinstalled or such?
14:55:57 <dolio> Perhaps.
14:56:05 <ddarius> efficientjelly: Your "seeming" is wrong.
14:56:14 <Peaker> @type fst . fst . maxViewWithKey
14:56:16 <PeakerLambda> Not in scope: `maxViewWithKey'
14:56:32 <nolrai_East> @pl liftT2 f a b = ChoiceT $ liftM2 f (unChoiceT a) (unChoiceT b)
14:56:36 <PeakerLambda> liftT2 = ((id ChoiceT .) .) . flip flip unChoiceT . ((.) .) . (. unChoiceT) . liftM2
14:56:36 <PeakerLambda> optimization suspended, use @pl-resume to continue.
14:56:43 <nolrai_East> @pl liftT2 f a b = ChoiceT $ liftM2 f (unChoiceT a) (unChoiceT b)
14:56:47 <PeakerLambda> liftT2 = ((id ChoiceT .) .) . flip flip unChoiceT . ((.) .) . (. unChoiceT) . liftM2
14:56:47 <PeakerLambda> optimization suspended, use @pl-resume to continue.
14:56:47 <ddarius> efficientjelly: If take and drop weren't defined, would you consider take n = fst . splitAt n messy?
14:56:49 <nolrai_East> opps
14:57:05 <efficientjelly> ddarius, fst . fst . maxViewWithKey isn't really readable to me. at least with maximum . keys I know immediately what's happening. maxViewWithKey is still O(log n), which is much better than O(n) of what I use, but as I said: as soon as I need more efficiency, I'll story the maximum key separately and have O(1) and readable code
14:57:19 <pumpkin> :o
14:57:26 <pumpkin> your nick is wrong then!
14:57:53 <centrinia> efficientjelly, why don't you implement a binary search?
14:57:56 <efficientjelly> ddarius, no I wouldn't, because splitAt seems more clear than maxViewWithKey 8)
14:58:11 <efficientjelly> centrinia, for what?
14:58:22 <ddarius> efficientjelly: getMaximum = fst . fst . maxViewWithKey and call it a day.
14:58:33 <centrinia> A binary search can be used to find the maximum key.
14:58:48 <efficientjelly> ddarius, yeah, thought about that, too, but I just used maximum . keys and called it a day. thanks anyway! will keep it in mind once I really need it
14:59:02 <SamB> centrinia: not the ordinary sort!
14:59:13 <centrinia> Of course not.
14:59:16 <SamB> centrinia: also it's much simpler to get it from the map
14:59:33 <centrinia> It is also faster to get it from the map.
14:59:38 <BMeph> SamB: Sorry, going over D.IM again, and yes, since keys returns them in order, 'last . keys' would work. :)
14:59:40 <efficientjelly> centrinia, seems like an awful lot of work, the maximum key is quite readily available
14:59:42 <SamB> that too
14:59:59 * ddarius goes back to banjo pickin'
15:00:15 <efficientjelly> centrinia, a binary sort would have the same complexity as the code that ddarius suggested, which also has O(log n) (and probably does a binary search), so I'd just use his 8)
15:00:26 <centrinia> BMeph, doesn't last traverse the entire list?
15:00:34 <SamB> centrinia: that it does
15:00:42 <SamB> but at least it doesn't have to do all those comparisons
15:01:37 <dolio> Binary search isn't going to be good on a list.
15:01:52 <BMeph> centrinia: ...yes, it does. This is part of the point; someone messed up the with the selections of IntMap functions. :\
15:02:11 <dolio> Also, for binary search, your array has to be sorted, so you already know where the maximum is.
15:02:54 <centrinia> fst . findMax on a Data.Map actually gets the maximum keey.
15:03:18 <BMeph> Also, it's have to be fst . fst . fromJust . MaxViewwithKey, which is just getting Rube Goldbergian in proportions. :|
15:03:38 <Peaker> data (,) a b = (,) { fst :: a, snd :: b }
15:03:40 <centrinia> dolio, a binary search can be used on a Map as well.
15:03:41 <efficientjelly> ddarius, what BMeph said ;)
15:03:44 <EvilTerran> fst . fst <$> maxViewWithKey, surely?
15:03:48 <BMeph> * MaxViewWithKey
15:04:09 <gwern> > 1 + 1
15:04:11 <centrinia> efficientjelly, why didn't you use a Data.Map instead?
15:04:14 <PeakerLambda>   2
15:04:18 <lambdabot>   2
15:04:34 <SamB> Peaker: hmm, I suppose it might as well be that if it weren't for the Read/Show instances
15:04:34 <efficientjelly> centrinia, hm. why? I have Ints as keys
15:04:40 <BMeph> centrinia: Integral keys, maybe? ;p
15:04:48 <SamB> ... and the special syntax!
15:05:13 <ddarius> efficientjelly: That just means your code is broken.
15:05:17 <EvilTerran> efficientjelly, because (Map Int) has a better interface than IntMap?
15:05:17 <centrinia> efficientjelly, fst . findMax gives the maximum key in a Data.Map.Map
15:05:17 <ddarius> > maximum []
15:05:19 <PeakerLambda>   * Exception: Prelude.maximum: empty list
15:05:20 * SamB wonders if GHC would do anything at all sensible with that definition
15:05:26 <lambdabot>   * Exception: Prelude.maximum: empty list
15:05:42 <EvilTerran> Peaker, lambdabot's back
15:05:53 <Peaker> PeakerLambda: @quit
15:05:54 <SamB> how did IntMap come to have it's own interface ?
15:06:23 <efficientjelly> ddarius, why is my code broken?
15:06:56 <efficientjelly> centrinia, sure that it doesn't give the maximum value, like findMax in IntMap? otherwise, the two interfaces would be AWFULLY inconsistent
15:06:59 <centrinia> IntMap uses bigendian patricia trees.
15:07:18 <dolio> You should be able to do 'data a :*: b = (:*:) { fst :: a, snd :: b }' with GHC extensions.
15:07:28 <dolio> If you don't mind that syntax.
15:07:42 <centrinia> Data.Map.findMax :: Data.Map.Map k a -> (k,a)
15:07:50 <efficientjelly> EvilTerran, but IntMap has the better implementation for what I need here. also, where is IntMaps interface worse? (I don't doubt you, I'm just interested. also: IntMaps interface *shouldn't* be worse, as it's just a specialization)
15:08:17 <SamB_XP> efficientjelly: I'm with you on that last bit
15:08:24 <SamB_XP> it should have basically the same interface
15:08:36 <BMeph> efficientjelly: The two interfaces ARE inconsistent. It's kind of a FAIL, IMHO. :\
15:08:43 <efficientjelly> that's bad, yes :(
15:08:46 <EvilTerran> efficientjelly, IntMap's findMax is broken
15:08:51 <EvilTerran> .'. its interface is inferior
15:08:56 <efficientjelly> (also, as already noted from the beginning, the documentation is broken on IntMap)
15:09:14 <efficientjelly> EvilTerran, sucks, yes, should be fixed
15:09:16 <EvilTerran> i think it's more that the documentation is correct, but the implementation is wrong :P
15:09:24 <centrinia> Is it easy to find the maximum key from a "big-endian patrica tree"?
15:09:37 <efficientjelly> EvilTerran, so findMax *does* return the *key* in Map? then it's like you say, yes!
15:09:51 <EvilTerran> @hoogle Map.findMax
15:09:52 <lambdabot> No results found
15:09:55 <EvilTerran> @hoogle Data.Map.findMax
15:09:55 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
15:09:56 <lambdabot> Data.Map deleteFindMax :: Map k a -> ((k, a), Map k a)
15:10:21 <BMeph> EvilTerran: How is "worse" significantly different from "inferior"? Besides using up more syllables for "inferior"? ;p
15:11:10 <EvilTerran> BMeph, "inferior" looks better near ".'." :P
15:11:18 <centrinia> If IntMap is worse than Map then Map is already bad. :(
15:11:34 <centrinia> If IntMap is inferior to Map, then Map is good.
15:11:53 <EvilTerran> that  too
15:11:57 <BMeph> The worst part of it is, if you negated the keys before you used them, it'd work. Seems like a major kludge, though. :\
15:12:29 <BMeph> EvilTerran: FAIL! ;)
15:12:34 <SamB_XP> centrinia: "inferior" does not imply that either thing is good
15:12:42 <SamB_XP> just that one is less so than the other
15:12:53 <EvilTerran> SamB_XP, yes, but "worse" implies that both are bad
15:14:04 <centrinia> Receiving $100000 is worse than receiving $700000000000
15:14:52 <BMeph> SamB_XP, EvilTerran: That's daft! That's like saying that 'better' implies both choices are good. Do you think that, too? (Now, I'm just curious.) :)
15:15:05 <SamB_XP> BMeph: no
15:15:18 <SamB_XP> I didn't say anything about worse
15:15:24 <SamB_XP> or better
15:15:47 <centrinia> Getting paralyzed in a car wreck is better than getting killed in a car wreck. :)
15:16:19 <dolio> You might have a case for "even worse".
15:16:22 <Peaker> centrinia: debatable
15:16:41 <dolio> Getting paralyzed in a car wreck is even better than getting killed in a car wreck.
15:16:49 <SamB_XP> that sounds daft
15:16:57 <dolio> Right.
15:17:32 <SamB_XP> Getting killed in a car wreck is even better than getting paralyzed in a car wreck.
15:17:54 <dolio> Yeah, that makes sense in a sarcastic way.
15:18:12 <dolio> Or if you like bad things happening to you.
15:18:34 <dolio> Of course, as Peaker mentions, that's still debatable.
15:18:38 <stu8ball> I would say, "Getting paralysed in a car wreck is less bad than getting killed in a car wreck".
15:18:41 <stu8ball> Less bad.
15:19:05 <SamB_XP> are you a native speaker ?
15:19:28 <stu8ball> I am.
15:19:42 <stu8ball> But this is more about logic than anything else.
15:19:44 <SamB_XP> would you really say "is less bad"
15:19:56 <stu8ball> I would, but I'm weird.
15:20:16 <nolrai_East> I would if i was talking carefuly.
15:20:26 <SamB_XP> if you were coming up with something for someone ELSE to say, what would you write ?
15:20:34 <BMeph> SamB_XP: Oh, right - sorry for lumping you in with ET there; he was responding to you, and I was responding to his response
15:20:51 <BMeph> "Less bad"?!?
15:20:53 <dolio> Maybe he's not a literature major.
15:20:54 * BMeph giggles
15:21:05 <SamB_XP> dolio: they have that?
15:21:10 <dolio> Why not?
15:21:22 <SamB_XP> oh, but I bet they make you write papers about the literature...
15:21:24 <dolio> If you can major in basket weaving...
15:21:32 <SamB_XP> you CAN ????
15:22:07 <dolio> Probably not, but it's a classic fictional major for football players and such.
15:22:27 <dolio> Maybe underwater basket weaving, if they're advanced.
15:23:34 <BMeph> stu8ball: Do yourself a favor, and try our "not as bad" for a while. You'll get less giggles - in a good way. ;)
15:23:43 <BMeph> *try _out_
15:23:45 <EmielRegis> hello
15:23:52 <EmielRegis> merry xmas and such
15:24:07 <stu8ball> Thinking about it further, I'm reminded of odd stuff like "not unreasonable" and such.
15:24:57 <dolio> BMeph: How about, "has less badness"?
15:25:06 <centrinia> Colloquial logic is more like intuitionistic logic than classical logic.
15:25:24 <centrinia> You don't usually use double negatives or Pierce's law in everyday speech. :)
15:26:27 <stu8ball> For fuzzy stuff there's not just good and bad, there's a zero in between, and double negatives in language sometimes/often include the possibility of the zero.
15:26:31 <stu8ball> Which I think is nice.
15:27:06 <dolio> Like non-decreasing sequences.
15:27:08 <nolrai_East> @type fmap join . join . liftM sequence
15:27:10 <lambdabot> forall a (m :: * -> *). (Monad m, Functor m) => m [m [a]] -> m [a]
15:27:45 <nolrai_East> @type liftM join . join . liftM sequence
15:27:47 <lambdabot> forall a (m :: * -> *). (Monad m) => m [m [a]] -> m [a]
15:28:19 <BMeph> EmielRegis: Froeliche Weinnachten!
15:28:37 <SamB_XP> and there's ain't not gonna never ...
15:28:51 <BMeph> dolio: Please, "CAN has less badness". ;p
15:29:01 <dolio> Hah.
15:29:21 <centrinia> Examples of non-true claims: "The sky is blue and the sky is not blue."  "This is a lie." "Only two of these claims are lies."
15:29:45 <EmielRegis> ok
15:29:50 <dmhouse> BMeph: "merry wine nights" (roughly)?
15:29:51 <SamB_XP> centrinia: I don't get that third one
15:30:01 <centrinia> Neither do I. :(
15:30:24 <dmhouse> The third one being true isn't a contradiction.
15:30:40 <EmielRegis> mhmhm
15:30:48 <SamB_XP> I think it's being untrue is
15:30:50 <EmielRegis> have you guys read emperors new mind by roger penrose?
15:30:54 <BMeph> For that matter, neither is it being false a contradiction. :)
15:30:57 <dmhouse> You could assign it a truth value of either true or false. It's like the claim "This is a true sentence."
15:31:11 <SamB_XP> EmielRegis: if it's like his new clothes, it should be easy to read
15:31:25 <gwern> EmielRegis: yes.
15:31:59 <BMeph> EmielRegis: It's been a while, but also yes. :)
15:32:09 <EmielRegis> that book is brilliant
15:32:15 <EmielRegis> you should all read it
15:32:19 <EmielRegis> :P
15:32:21 <ksf> true and false are mere concept if taken beyond the fact of action and non-action.
15:32:28 <gwern> EmielRegis: brilliantly wrong, perhaps
15:32:47 <ksf> therefore, logic is utter bunk. Q.E.D.
15:33:01 <EmielRegis> gwern, why?
15:33:10 * BMeph waits to see if ksf makes it through the next zebra crossing...
15:33:35 * centrinia disproves logic using logic.
15:33:42 <EmielRegis> ksf, in fact, all mathematics must be then proved utter crap - because it always needs another 'level of abstraction', as proven by godels theorem
15:33:54 <gwern> EmielRegis: he has all sorts of nice godelian arguments, but I'm not sure why they need have anything to do with strong AI
15:34:01 <ksf> in vino veritas.
15:34:09 * ksf hopes it's in whisky, too.
15:34:13 <gwern> and I find his quantum neurons to both not prove AI impossible and unlikely
15:34:24 <EmielRegis> well
15:34:30 <dolio> They have the same active ingredient.
15:34:44 <gwern> I wish I could be more specific, but  I read it a long time ago, and it was pretty big
15:34:46 <ksf> don't trust any mathematician you can't understand while he's drunk.
15:34:53 <EmielRegis> he argued that the concsiousness is not algorithmical, hence cannot be materialized by using electrical circuits
15:35:01 <centrinia> Quantum neurons make us one with the universe and somesuch.
15:35:09 <EmielRegis> ye
15:35:23 <centrinia> We are all connected by quantum entanglement.
15:35:25 <EmielRegis> I actually believe this can be true
15:35:37 <EmielRegis> And right now, this seems the most plausible theory.
15:35:38 <ksf> why shouldn't consciousness be algorithmical?
15:35:52 <dolio> Because that's so boring!
15:35:52 <gwern> I don't. there's been no progress in linking quantum effects to neurons
15:35:59 <EmielRegis> Because actual neural networks are not self-concious and rather won't be any time soon
15:36:04 <gwern> even microtubules turned out to be a few orders off, iirc
15:36:16 <SamB_XP> EmielRegis: have we tried anything nearly big enough ?
15:36:18 <EmielRegis> gwern, maybe because the theory is incomplete
15:36:20 <ksf> what's the problem in neurons creating a metastructure that's aware of neurons creating a metastructure that's aware of stuff happening?
15:36:24 <EmielRegis> ie. the GUT
15:36:24 <SamB_XP> we're talking more than dog big
15:36:51 <EmielRegis> SamB_XP, I think they are maye 2 or 3 orders of magnitue behind
15:36:59 <ksf> EmielRegis, please continue to further prove your braindeadness incorporated in a neural net inside your skull.
15:37:04 <gwern> EmielRegis: so, we should think consciousness non-computable... because we want to, and we hope that the standard model is incomplete?
15:37:07 <gwern> wut
15:37:08 <EmielRegis> however, I dont see how could the very behaviour of the system cahnge by just adding nods
15:37:12 <EmielRegis> nodes*
15:37:28 <gwern> (let's also prove humans have immortal souls, because that would be nice, and science might be incomplete)
15:37:50 <SamB_XP> if we don't try a net at least as big as those that actually exhibit self-awareness, we've proven nothing at all
15:38:03 <centrinia> Isn't it possible to (slowly) emulate a quantum computer with a classical computer?
15:38:10 <ksf> sure it is.
15:38:22 <ksf> there's even one online, but don't ask me for a link.
15:38:23 <EmielRegis> centrinia, it is, but its not worthy
15:38:26 <gwern> centrinia: yes, with different complexities and a source of randomness
15:38:27 <EmielRegis> why would it be?
15:38:34 <EmielRegis> I mean, if we had quantum computers
15:38:45 <SamB_XP> "not worthy"?
15:38:50 <EmielRegis> with enough amount of qbits to emulate neural network of the brain, then we could get somewhere
15:39:00 <gwern> SamB_XP: we are not worthy!
15:39:01 <ksf> we'd have even more mindboggingly parallel thingies than gpu's.
15:39:06 <ksf> ...and nothing more.
15:39:13 <BMeph> EmielRegis: If you can't understand how a system's behavior could change by adding nodes, then go Google "Busy Beaver " and Learn... ;)
15:39:19 <EmielRegis> SamB_XP, as the actual strength of quantum computers is that they are screamingly fast isnt it?
15:39:36 <SamB_XP> EmielRegis: ... not really
15:39:41 <centrinia> Google itself is a good example of how a system's behavior could change by adding nodes.
15:39:59 <EmielRegis> BMeph, not talking about learning. Conciousness is what primarily interests me
15:40:04 <SamB_XP> centrinia: has it been acting sentient for you too, then ?
15:40:08 <ksf> google's behaviour is, afaict, pure wrt. the number or type of attached nodes.
15:40:25 <ksf> the time complexity of the overall system might change, but not more.
15:40:35 <SamB_XP> EmielRegis: if you don't want to learn, you've no bussiness here
15:40:36 <centrinia> Google will become sentient in 2012, at which point humanity will become extinct.
15:40:38 <eu-prleu-peupe1> :D
15:40:43 <SamB_XP> prepare the banhammer!
15:40:47 <EmielRegis> SamB_XP, how is that untrue? The biggest advantage of quantum computing is ability to manipulate extremely large amount of qbits at once
15:40:52 <eu-prleu-peupe1> so i should take all my things from google
15:40:52 <BMeph> EmielRegis: Okay, but a consciousness that doesn't learn is kind of pointless to me. :)
15:41:09 <SamB_XP> centrinia: you got that from the Matrix didn't you ?
15:41:12 <centrinia> EmielRegis, no.
15:41:17 <EmielRegis> BMeph, but learning is algorithmic, conciousness might not be
15:41:19 <ksf> BMeph, a consciousness that learns if there's nothing to learn is even more pointless.
15:41:28 <centrinia> SamB, Terminator actually.
15:42:05 <dolio> Humanity wasn't extinct in either of those.
15:42:23 <BMeph> EmielRegis: (If I was being too obscure, I meant Your learning, not the theoretical AI. The point's still valid, though, I guess.) :)
15:42:41 <centrinia> The Terminator plotline didn't have Judgement Day happen in 2012 either. ;)
15:42:47 <nolrai_East> @ty traverse . traverse
15:42:49 <lambdabot> Not in scope: `traverse'
15:42:49 <lambdabot> Not in scope: `traverse'
15:42:52 <dolio> :)
15:43:05 <EmielRegis> BMeph, i got that bit. However where am I wrong in this, I cannot see your counterarguments
15:43:14 <dolio> I'm not enough of an afficionado to know that.
15:43:50 <SamB_XP> EmielRegis: so ... learn about Busy Beaver ...
15:44:26 <chessguy> @users
15:44:26 <lambdabot> Maximum users seen in #haskell: 568, currently: 541 (95.2%), active: 19 (3.5%)
15:44:31 <Saizan> it feels like this channel is running in circles..
15:45:22 <dolio> Busy beaver is popular today.
15:45:36 <gweiqi> is anyone here familiar with how the ghc rts's scheduler pre-emption works?
15:45:38 <BMeph> dolio: Is it, really? Cool! :)
15:45:52 <dolio> This is at least the second time it's been brought up.
15:46:11 <centrinia> Eddie Haskell and Cleaver Beaver. ;)
15:46:43 <dons> hey guys, some great news: a free version of cryptol is now available, http://www.galois.com/blog/2008/12/24/cryptol-the-language-of-cryptography-now-available/
15:46:46 <dons> shapr: woo!
15:47:23 <EmielRegis> SamB_XP, alrite, by that you mean quantum computer could calculate the busy beaver function for higher n than currently possible?
15:47:52 <gwern> quick brainstorm: what is a good name for a wiki using darcs and git? or backed by a DVCS in general?
15:48:02 <gwern> currently I have 'diki' as a suggestion
15:48:11 <gwern> dons: free, or Free?
15:48:43 <gwern> 'In this release, Galois has made a implementation of the Cryptol language available free of charge for non-commercial uses.
15:48:49 <dons> right.
15:48:52 <gwern> ah, so free. I suppose Free was a bit much to ask
15:48:56 <dons> kinda.
15:49:17 <cjb> gwern: it would hurt their business model somewhat, I imagine :)
15:49:27 <cjb> (but maybe in a few years once it's not a big seller, I guess..?)
15:49:42 <shapr> dons: awesome!
15:49:59 <dons> fwiw, this is a long term, large haskell project, 10 years of development, some pretty hardcore applications. haskell is the freaking real world.
15:50:00 <gwern> cjb: my understanding was that galois sold services not so much the tools
15:50:39 <dons> gwern: hmm, not sort of. research services/tech transition. we don't do products so much, usually spinning those off into startups
15:51:07 <gwern> dons: startups?
15:51:15 <cjb> dons: it's nice that you released something, but it doesn't like it's immediately useful to anyone unless they want to give Galois money.
15:51:46 <augustss> dons: very cool about free Cryptol!
15:51:51 <cjb> (I guess that depends how useful a specification that isn't compiled into a translation is, and whether there were already tools to do that.)
15:51:51 <dons> its for language researchers like swiert
15:51:59 <dons> who've written papers about cryptol in the past, but not had a version to actually use.
15:52:06 <dons> or for teaching crypto
15:52:09 <dons> augustss: :D
15:52:22 * gwern ponders. 'diki' is the obvious, from darcs+wiki; 'viki' is another possiblity. disti?
15:52:26 <BMeph> gwern: Patchki? :)
15:52:27 <ksf> "free for commercial uses" basically means that you can spin off your own startup and only pay when you've already done all the work, which is kinda neat.
15:52:36 <ksf> s/commercial/non-commercial/
15:52:42 <ksf> freud is calling.
15:52:42 <gwern> BMeph: not darcs-agnostic
15:52:52 <shapr> gwern: distriki
15:52:53 <cjb> ksf: it's functionality-limited as well as non-commercial only, AFAICS
15:53:04 <shapr> distwiki?
15:53:05 <ksf> well... that sucks.
15:53:17 <gwern> shapr: sounds painful. 'Prepare to taste the sharp edge of my distriki!'
15:53:28 <shapr> Yeah, it does like some sort of weapon, I like it!
15:53:53 <gwern> shapr: too many syllables and words
15:53:54 <Nafai> Hi shapr!
15:53:59 <BMeph> shapr: Well, either that, or a Greek pastry...not entirely disjoint, those. ;)
15:54:22 <shapr> gwern: I dunno, mixes the right words, and is good for google searches.
15:54:36 <shapr> gwern: 60 hits
15:54:49 <gwern> diki can't really compare - 1.5m hits
15:54:51 <ksf> darcskij, if you wanna go russian.
15:54:57 <shapr> distributed + wiki = distriki?
15:55:02 * BMeph wonders how long he could get away with asking for a doner kabob and a distriki at the local gyro shop...
15:55:53 * ksf remembers arguing to a Turk that Raki is Turkish Ouzo and figures "not for long".
15:56:04 <gwern> gitit is annoying to me; it works well as a name - gitit the wiki is already top of google queries
15:56:11 <gwern> but it is too specific
15:56:30 <vixey> > 1+1
15:56:31 <lambdabot>   2
15:56:49 * ksf stares at vixey
15:57:11 <ksf> you know, I actually know a girl who can calculate hex in her head.
15:57:30 <BMeph> stop looking up distriki, folks, I have almost 500 hits, now! 8D
15:57:31 <gwern> (kinky. what can she do with her tongue, one wonders)
15:57:43 <gwern> heisensearches!
15:58:19 <ksf> no idea. we were busy implementing a music instrument on a microcontroller, all the time.
15:59:45 <ddarius> ksf: It's not hard
16:00:15 <ksf> I know, I was the one doing the assembly, she was the one doing the electronics and hex calculating.
16:00:41 <ddarius> What do you need a microcontroller for?
16:00:53 <ksf> well it was an exercise.
16:01:01 <ksf> school, that is.
16:01:08 <centrinia> Banach + Tars + Wiki = Banach Tarski?
16:01:33 <gwern> zomg! tarski = tar + SKI!
16:01:43 <cygnus_> tar + sniffing = genius
16:01:47 <gwern> it's a combinatorial trick meant to slow us down
16:01:49 <ddarius> ksf: Would your instructor accept an implementation purely in hardware with the microcontroller used decoratively?
16:01:54 * dmhouse doesn't think skiing on tar would be much fun
16:02:14 <ksf> female geeks are strange, they don't even get shy like the rest, they just ask you how to do foo on bar.
16:02:28 <ksf> nah, it was especially about microcontrollers.
16:02:34 <ddarius> Bah
16:02:50 <ksf> we used an digital infrared sensor and a speaker, which we fed square signals.
16:03:51 <gweiqi> nobody knows how ghc's scheduler works?
16:04:25 <pumpkin> I'm sure somebody does ;)
16:04:32 <centrinia> gweiqi, read up on Spineless Tagless G-Machines.
16:04:37 <gweiqi> i already did
16:05:07 <gweiqi> i'm interested in how the pre-emption problem is solved, with worker threads
16:05:07 <dons> on reddit too, http://www.reddit.com/r/programming/comments/7lkxr/cryptol_a_language_for_the_design_implementation/
16:05:32 <dons> not every day the DoD lets us release crypto stuff ... :) so enjoy!
16:05:57 <dons> nothing like a bit of cryptography over the holiday season
16:06:55 <centrinia> The DoD will get suspicious once someone builds an unbreakable Vernam encryption device using Cryptol. ;)
16:07:06 <gweiqi> basically, i'm imagining that a worker OS thread is executing some haskell thread, and some signal/timer is set off, telling it to work on a new haskell thread
16:07:30 <gweiqi> but i'm wondering how it manages to save the progress on the current haskell thread to be picked up later
16:08:26 <ddarius> ksf: I read an interesting paper on a Fourier-like operation based over square waves for sound synthesis.
16:09:43 <ksf> well we did'nt choose the rectangle signal, it's the only way we could directly produce sound with pure-digital output.
16:09:44 <gweiqi> i'm sure somebody can answer my question... but they need to wake up first, and i don't know who to dump water on
16:10:26 <ddarius> @google "A Synthesizer based on square waves"
16:10:34 <lambdabot> http://arxiv.org/abs/0804.3241
16:10:54 <Saizan> gweiqi: well, GHC threads can't be preempted at any point, only when allocating afaiu
16:11:08 <ksf> ...our instructor, being used to electronic guys, explained to us for hours how to program (while we were just staring with mouths gaping, wondering how painfully explicit you can make such simple stuff), while he should have rather told us stuff like that you have to set a port to high before you can ever read a one from it...
16:11:21 <Saizan> gweiqi: you may look for "concurrent haskell"
16:11:25 <ksf> ...those are semantics only electronic geeks can cope with.
16:11:28 <gweiqi> Saizan: so when allocating, does it always check to see if it's time to return the capability?
16:11:36 <gweiqi> Saizan: i've read all the papers
16:12:53 <Saizan> gweiqi: i don't know much about the details, you can try asking on the haskell-cafe or ghc-users mailing list
16:13:13 <Saizan> one of the Simons might answer you :)
16:13:27 <gweiqi> Saizan: thanks
16:14:07 <int-e> gweiqi: have a look at the big comment in http://darcs.haskell.org/ghc/rts/HeapStackCheck.cmm
16:16:02 <gweiqi> int-e: thanks
16:16:52 <gweiqi> int-e: if i'm interpreting this correctly, this basically means that if a haskell thread is looping forever in constant space (not extending heap or stack) then it will never yield
16:16:58 <gweiqi> ?
16:17:10 <int-e> yep. it does happen.
16:17:29 <dons> ?userrs
16:17:30 <lambdabot> Maximum users seen in #haskell: 568, currently: 538 (94.7%), active: 21 (3.9%)
16:17:35 <int-e> (mostly in toy examples, but still.)
16:17:52 <gweiqi> int-e: ah, so the rts doesn't really have a way of dealing with this case?
16:18:01 <gweiqi> slightly scary
16:19:13 <Heffalump> the problem is that the only way to make a tight loop interruptible without losing efficiency is a timer interrupt, and you have no control at all over the state of the program when they happen
16:19:41 <gweiqi> Heffalump: that's exactly why i was wondering how this problem was solved in ghc's rts
16:20:04 <Heffalump> ah :-)
16:20:27 <Cale> You can however explicitly call yield.
16:20:51 <augustss> You can also insert a scheduler check in each cycle in the control flow graph.
16:20:53 <Heffalump> sure, but that doesn't help with making tight loops both fast and interruptible
16:21:06 <Heffalump> and neither does that
16:21:11 <augustss> Each non-allocating cycle.
16:21:34 <gweiqi> I was trying to reconcile how you'd know when to yield without losing efficiency
16:22:03 <augustss> Allowing timer interrupts has its own overhead.
16:22:19 <Heffalump> augustss: but non-allocating cycles are precisely what you might want to be nice fast tight loops
16:22:29 <Heffalump> so you probably need to unroll too, and balance that cost with the instruction cache costs
16:23:06 <augustss> Heffalump: I agree.  But I don't know a totally satisfactory solution.
16:23:20 <Heffalump> what's the overhead of timer interrupts?
16:23:59 <augustss> Heffalump: you can only switch threads when you're in a consistent state, so you have to make sure to get to one, somehow.
16:24:17 <Heffalump> ok, so just tricky, not an overhead per se
16:24:22 <augustss> e.g., half filled heap cells are no good.
16:24:54 <Heffalump> I wonder if identifying the current loop and patching it to yield would do the trick
16:24:58 <augustss> Heffalump: there might not be a consistent state anywhere in the loop.
16:25:16 <int-e> there's also the issue of finding your way through STG's mixed stack (we still have that, right?)
16:25:31 <augustss> What you can do is associate some code to take you to a consistent state for every possible value of the pc when interrupted.
16:25:51 <Heffalump> and hope that it turns out to be quite small in practice!
16:26:04 <gweiqi> ouch
16:26:05 <augustss> Yes, but I don't know if that is true.
16:26:21 <Heffalump> well, you only need to do it for non-allocating loops
16:26:28 <augustss> Also, for long enough cycles you can insert the reschedule check.
16:26:39 <Heffalump> the rest you can just say "ignore the interrupt, you'll get a yield soon anyway"
16:26:57 <augustss> True
16:27:16 <int-e> sounds highly unportable :/ for one, you need to get at the CPU registers of the interrupted loop to do that patching
16:27:18 <mib_8oomfc> Is there any hash function included in the stdlib?
16:27:34 <kublar> @hoogle hash
16:27:34 <lambdabot> package Hashell
16:27:34 <lambdabot> Data.HashTable hashInt :: Int -> Int32
16:27:34 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
16:27:41 <Heffalump> timer interrupts aren't very portable either
16:27:54 <augustss> int-e: yes, it would be very machine dependent.  But that's fine on this level.
16:28:01 <wabash> newbie question. What is "@hoogle"?
16:28:18 <Heffalump> wabash: a search engine for finding Haskell functions by name or by type
16:28:28 <gweiqi> wabash: http://www.haskell.org/hoogle/
16:28:30 <mib_8oomfc> kublar: that's not a wide variety
16:28:31 <wabash> Is it a website?
16:28:34 <mib_8oomfc> specifically I mean cryptographic
16:28:37 <mib_8oomfc> well, not that strong
16:28:39 <mib_8oomfc> like sha1
16:28:46 <kublar> mib_8oomfc: check hackage
16:28:54 <wabash> Not the url you sent, I mean @hoogle
16:29:03 <augustss> mib_8oomfc: there are packages for that
16:29:08 <mib_8oomfc> kublar: mm...
16:29:23 <Saizan> wabash: they are based on the same program
16:29:51 <Saizan> wabash: just different front-ends, and probably different databases
16:30:23 <augustss> Heffalump: are you offering to make ghc generated code interruptible? :)
16:30:36 <Heffalump> augustss: take a wild guess :-p
16:30:57 <augustss> I think the non-interruptible thing is going to get more pressing as the code generator gets better.
16:31:03 <Heffalump> yeah
16:31:04 <int-e> it's a feature that ghc will need in the long run.
16:31:05 <int-e> :)
16:31:23 <mib_8oomfc> I see nothing on hackage.
16:31:29 <mib_8oomfc> Wtf? Surely there has to be a trivial sha-1 in haskell.
16:31:50 <dons> mib_8oomfc: there's several sha implementations
16:31:53 <dons> e.g. in the sha package.
16:32:02 <augustss> mib_8oomfc: Crypto
16:32:04 <int-e> mib_8oomfc: search for SHA1
16:32:05 <dolio> "Crypto library and programs: DES, Blowfish, AES, TEA, SHA1, MD5, RSA, BubbleBabble, Hexdump, ..."
16:32:12 <mib_8oomfc> ah, OK
16:32:12 <mib_8oomfc> thanks
16:32:16 <int-e> or just SHA, right
16:33:01 <gwern> I belive the last time I counted SHAs, I came up with 6 of them in haskell (pure and FFI)
16:33:05 <augustss> Heffalump: did the omega decision procedure do you any good, btw?
16:33:49 <Heffalump> I haven't tried it yet, because my hacked up combination of ad-hoc rules is working for now
16:35:52 <mib_8oomfc> http://hackage.haskell.org/packages/archive/Crypto/4.1.0/doc/html/Data-Digest-SHA1.html
16:35:54 <mib_8oomfc> This is not terribly helpful.
16:37:07 <kublar> good enough
16:38:02 <augustss> Looks helpful to me.  What else do you want to know?
16:38:08 <pumpkin> that Word160 thing is an odd choice
16:50:36 <harblcat> Merry Christmas!
16:51:10 <wabash> You too!
16:51:18 <wabash> Hey, I'm looking at Hackage. Or trying to.
16:51:31 <wabash> Is there a list of all the hackage projects, so that I can browse?
16:51:49 <dons> wabash: of projects waiting to happen?
16:52:00 <dons> http://www.reddit.com/r/haskell_proposals/
16:52:20 <wabash> dons: That too. You read my mind.
16:52:21 <pumpkin> ooh almost up to 100 subscribers :)
16:52:27 <wabash>  But right now the ones that exist and work.
16:52:30 <wabash> I would like to use them.
16:52:38 <pumpkin> http://hackage.haskell.org
16:52:55 <kublar> http://hackage.haskell.org/packages/archive/pkg-list.html
16:53:11 <wabash> pumpkin: kublar: thank you!
16:53:21 <dons> wabash: hackage.haskell.org
16:53:25 <dons> ~1000 projects
16:53:33 <dons> take your pick. installable via: cabal install foo
16:54:25 <Saizan> and there are also hidden ones!
16:54:35 <Saizan> not on the list but actually downloadable
16:54:41 <pumpkin> what does it take to become a hackage repo? I was thinking about github and its rubygem provider, and how it might be possible for it to become a cabal host too, in a similar way
16:57:44 <dibblego> does anyone recall a survey between preferred programming language and religious conviction? I can't seem to google it
16:57:51 <pumpkin> lol
16:58:02 <pumpkin> not me :)
16:58:16 <Heffalump> I vaguely remember it, but I can't remember any useful details.
16:58:37 <pumpkin> http://www.aegisub.net/2008/12/if-programming-languages-were-religions.html this one?
16:59:06 <kublar> preflex: quote
16:59:07 <preflex>  <suravad> One by one the penguins steal my sanity.
16:59:11 <Saizan> @google if programming languages were lambdatheultimate
16:59:15 <lambdabot> http://lambda-the-ultimate.org/node/3133
16:59:15 <lambdabot> Title: If Programming Languages were <T> | Lambda the Ultimate
16:59:39 <redditbot> Cryptol, Galois' crypto language and compiler, now available for download
17:00:09 <Heffalump> wow, nice
17:00:20 <pumpkin> we're taoists apparently
17:01:06 * BMeph is amused that the first Christians called themselves "followers of The Way"
17:01:19 <ddarius> dibblego: There was one a long while back
17:01:27 <dibblego> ddarius, right - about a year ago
17:01:44 <gwern> pumpkin: cool analogy: taoist tracts were political manifestos about how to conquer the world hidden as religion; haskell papers are manuals to convert the world disguised as CS works
17:01:58 <pumpkin> lol
17:03:34 <dons> dibblego: i do recall the survey
17:03:41 <dons> and was surprised that it has some 200 haskellers
17:03:47 <pumpkin> :o
17:04:08 <pumpkin> what were the main religious beliefs of haskellers? do you remember?
17:04:17 <gwern> atheism, probably
17:04:21 <pumpkin> we could always make a new one
17:04:32 <gwern> 'there are no globals like god!'
17:04:33 <Japsu> iä oleg fhtagn
17:04:34 <pumpkin> it's pretty easy to set up a poll and promote it
17:04:34 <ozy`> the church of the one-eyed lambda
17:04:37 <BMeph> Atheist, I believe... (<snicker>)
17:04:42 <pumpkin> lol
17:05:44 <dibblego> is it just me inept with google?
17:06:18 <qebab> I sat in church for two hours today. I suppose I should tell my family that I don't believe, at some point. :|
17:06:42 <gwern> qebab: too much trouble, personally
17:06:46 <dons> pumpkin: haskellers were the least religious of all language groups, interestingly
17:06:47 <gwern> and they'll no longer get you christmas gifts
17:06:55 <dons> though they didn't measure the Isabelle and Coq userrrs
17:07:09 <pumpkin> dons: it's because they didn't have an option for "Types" as a religious belief ;)
17:07:15 <gwern> dons: there must be a joke about that - 'other languages inculcate religion - run and pray'
17:07:26 <dons> unsafePerformMiracles
17:07:27 <qebab> gwern: I don't think they'll hate me or anything, it's just that I don't want them to be disappointed
17:08:11 <qebab> Of course, there is a risk that there will be loud and angry words if it comes out... :)
17:08:21 <gwern> qebab: disapointed... by what? 'great, we all made it to heaven! wait, where's qebab...'
17:08:30 <pumpkin> how old are you? if you're 50 and have been lying to them about your beliefs for the past 45 years, that might be more problematic
17:08:38 <gwern> dons: did ohloh ever add darcs support?
17:09:03 <qebab> pumpkin: I'm 21, so it's not *quite* that bad
17:09:06 <pumpkin> are there any non-hackage.haskell.org hackage repos?
17:09:16 <pumpkin> qebab: yeah :)
17:09:17 <gwern> pumpkin: yes
17:09:44 <BMeph> pumpkin: Of course there are...but we don't mention them in polite company... ;)
17:10:12 <augustss> pumpkin: just bow down to the one true repo
17:10:19 <pumpkin> lol ok
17:10:28 <dibblego> http://www.reddit.com/r/programming/comments/68zvo
17:10:47 <pumpkin> failink
17:11:47 <augustss> Lua in the lead, huh.
17:12:03 <pumpkin> http://74.125.47.132/search?q=cache:ceswPvQFX38J:www.kimsal.com/reldevsurvey/results.php%3Faction%3DbyLanguage%26language%3D19+http://www.kimsal.com/reldevsurvey/results.php&hl=en&ct=clnk&cd=2&gl=us&client=safari
17:12:05 <gwern> 'If you look at something like Python vs. C/C++/ASM, you'll see that the last 3 have less (well, a tiny tiny less) agnostic/atheist replies than Python. I hypothesize that it's from the "Oh god, please let it work" mentality of those last 3.
17:12:12 <gwern> phooey, my joke was already done
17:12:13 <pumpkin> is it just broken for me?
17:12:19 <dibblego> http://michaelkimsal.com/blog/religion-and-computer-language-use-survey-results/
17:13:21 <gwern> '
17:13:24 <gwern> '
17:13:24 <gwern> Oh wow. I need to add "thetans" as a cause to our bug tracking system now.
17:13:33 <pumpkin> the link is broken for me :(
17:19:23 <ozy`> gwern: gadzooks! was scientology in the poll results?!
17:26:00 <Olathe> I went to look at the survey results and I got "Fatal error: require_once()"
17:26:08 <Olathe> Apparently, Satan uses PHP.
17:44:51 <drdozer> merry xmas one and all
17:47:38 <Smokey`> merry christmas :)
18:46:36 <chessguy> merry Christmas Eve, #haskell
18:47:24 <Smokey`> Merry Christmas, from the future ;)
18:48:21 <chessguy> the ghost of Christmas future? :)
18:48:38 <Smokey`> not quite :)
18:59:37 <redditbot> Success! Gtk2Hs on Mac OS without X11
19:00:19 <thoughtpolice> @seen augustss
19:00:19 <lambdabot> augustss is in #haskell. I last heard augustss speak 1h 48m 35s ago.
19:03:27 <mmorrow> thoughtpolice: C-- ftw. ;)
19:06:26 <Lemmih> mmorrow: C-- ftw?
19:08:50 <defun> hi. I just finished a successful build of ghc 6.10.1 with gcc 4.2.3. At the end of 'make' I get many warnings. Should I worry about these: http://hpaste.org/13318?
19:09:04 <defun> *http://hpaste.org/13318
19:10:18 <kublar> no
19:10:33 <defun> kublar: thanks.
19:13:13 <mmorrow> Lemmih: I was reading the C-- spec, and have become convinced it is the way to go (with the (rather large) caveat that there is no useable C-- compiler)
19:13:54 * mmorrow begin raiding ghc's Cmm collection
19:14:16 <defun> Hurrah! I got ghc 6.10.1 on my computer! I'm going to go play. :-D
19:14:33 <mmorrow> defun: nice.
19:16:08 <mmorrow> Lemmih: have you seen this? https://cminusminus.org/lists/pipermail/cminusminus/2008-November/000078.html
19:19:37 <pumpkin> sure is quiet right now :P
19:20:42 <mmorrow> not a creature was stirring....
19:21:06 * pumpkin feels like a hermit
19:23:37 <mmorrow> picture the earth from space
19:23:54 * mmorrow is drunk. disapears
19:25:03 <mmorrow> (picture... @pumpkin)
19:25:08 <pumpkin> :o
19:25:08 * mmorrow really disapears
19:33:14 <ike> hi, I'm enjoying to read RWH :)
19:33:52 <ike> What do I do if I find a typo in Real World Haskell?
19:34:00 <ike> or, where is the errata?
19:34:06 <majyk> I was about to buy it at B&N today, I'm kicking myself now
19:35:06 <ike> aha, here! http://oreilly.com/catalog/9780596514983/errata/
19:35:11 <ike> thanks google
19:35:25 <Cale> ike: You can also comment on the online version
19:36:14 <majyk> I hacked the Arch Linux ghc package today and updated it to 6.10.1
19:39:09 <ike> Cale: thanks, I found the online version and how to add a comment
19:40:18 <rgr> when in ghci can I get documention for a function like take?
19:40:29 <pumpkin> I don't think ghci provides documentation
19:40:32 <pumpkin> it'll give you types
19:40:39 <rgr> yes I know.
19:40:50 <rgr> but types alone dont tell you much
19:41:59 <Cale> You can find the documentation online
19:42:13 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
19:42:29 <Lemmih> mmorrow: Many people will be forever grateful if you manage to turn GHC's cmm code into a proper C-- compiler.
19:42:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#17
19:45:00 <sereven> rgr: ghci's :i(nfo) can be handy too, includes where defined, works for more than just functions
19:52:28 <roconnor> I think turning GHC's cmm code into a proper C-- compiler will provide the economic boost needed to prevent the coming depression.
19:56:19 <thoughtpolice> mmorrow: yeah I had a book from my library with a bunch of papers; one was over c--
19:56:25 <thoughtpolice> i never got to read that paper in particular thoug
19:56:26 <thoughtpolice> h
19:57:16 <alc> i'm running the calculator example from PiH: http://www.cs.nott.ac.uk/~gmh/calculator.lhs
19:57:19 <alc> it goes well in ghci
19:57:32 <alc> but not if i compiled it to binary
19:58:06 <alc> it shows nothing
19:58:18 <alc> ghc 6.8.2
19:59:09 <pumpkin> wow that indentation is crazy
20:00:53 <BMeph> majyk: There's a 6.10 in extras. :)
20:07:41 <majyk> extra's or AUR?
20:07:45 <majyk> I now see it in AUR
20:08:04 <int-e> alc: try http://hpaste.org/13319
20:09:26 <alc> int-e,  thanks!  it works =)
20:11:15 <majyk> BMeph, actually I was confused. I see it in the testing branch. My bad
20:11:47 <majyk> I simply hacked the 6.8.2 package and bumped the version number, seems to compile fine but maybe that is a naive approach to upgrading the package
20:49:36 <Nafai> Wow.  939 packages in Hackage
20:58:31 <b4taylor> I'm going to write a little app that parses in a text file and stores metadata about it and just stores that in a little file. I was going to ask if anyone had any suggestions as to what I could use to store my metadata in, but I found haskell bindings to sqlite.
20:58:40 <b4taylor> If someone has a better suggestion, I am all ears.
20:58:50 <b4taylor> better (read faster and/or more interesting)
20:59:22 <Nafai> From your description, sqlite seems well suited
21:00:12 <b4taylor> Nafai: That's what I thought.
21:09:13 <mbz> @hoogle malloc
21:09:13 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
21:09:13 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
21:09:13 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
21:09:23 <mbz> @hoogle c_malloc
21:09:24 <lambdabot> No results found
21:09:55 <mbz> which function should I use for allocating memory for the X11's Image ?
21:12:09 <gwern> b4taylor: I say you should use [String], and Read and Show on it!
21:13:10 <b4taylor> gwern: I thought you said your article viewer is slow.
21:13:47 <gwern> lies! my article viewer is faster than a supercomputer! it's faster than a gundam painted red!
21:14:08 <gwern> it is so fast that if NP problems were articles, the conjecture would be settled!
21:14:15 <Nafai> article viewer?
21:14:21 <gwern> it's so fast, yo momma was all like damn that's fast
21:14:36 <dmwit> mbz: Hmm.  Is there nothing in the X11 library for that?
21:15:06 <mbz> dmwit: I'm trying to figure it out right now.
21:15:18 <dmwit> ?hackage X11
21:15:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
21:15:23 <gwern> Nafai: a little utility mode I whipped up for yi. the idea is you have a circular list of items, where each item is a buffer of text, and you go one by one, reading little bits
21:16:14 <gwern> Nafai: ie, for me, one buffer is a book by alan kay, another buffer is the Dhammapada which I'm cutting down into memorizable chunks of verses I like, another item is _The Scarlet Pimpernil_ which I read one chapter a day, etc.
21:16:20 <b4taylor> gwern: I don't know all of Char's MSs were quite fast.
21:17:10 <gwern> b4taylor: far be it from me to denigrate aznable, but technology has advanced since his day
21:17:18 <dmwit> mbz: createImage?
21:17:31 <b4taylor> gwern: Space explosions no longer pink?! :(
21:17:32 <dmwit> Are you wondering where to get a Ptr CChar to pass?
21:17:32 <Nafai> gwern: Nice!
21:17:48 <mbz> dmwit: yep
21:17:49 <dmwit> ?hoogle newForeignPointer
21:17:49 <lambdabot> No results found
21:18:00 <dmwit> ?hoogle foreign
21:18:00 <lambdabot> keyword foreign
21:18:00 <lambdabot> module Foreign
21:18:00 <lambdabot> Language.Haskell.TH data Foreign
21:18:06 <gwern> b4taylor: even better, in space one can now hear enemy suits
21:18:20 <b4taylor> It is hard to tiptoe in space ...
21:19:20 <b4taylor> Oh, also I kinda abused the Duvel I got from the LCBO last night, so no real work on the dzen stuff.
21:19:21 <dmwit> mbz: Check out ForeignPointer, which will give you a chance to let the garbage collector call destroyImage or whatever.
21:19:31 <b4taylor> And now it's Christmas day, so ... little work to continue.
21:19:36 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html
21:19:42 <b4taylor> Work has been annoying, I needed the 8% beer.
21:20:21 <mbz> dmwit: thanks
21:20:44 <cjs>  Speaking of ForeignPointer, has anyone compiled any FFI stuff under Windows with 6.10.1?
21:20:51 <cjs> I'm getting "gcc not found" error messages.
21:22:46 * mbz is using 6.8.2 under linux
21:22:59 <jeffz`> cjs, that's weird... seeing as ghc for windows ships with a gcc
21:23:36 <cjs> Indeed.
21:23:50 <cjs> So gcc is under c:\ghc\ghc-6.10.1, not the bin directory underneath.
21:24:30 <jeffz`> but yeah, I have compiled stuff that uses ffi with 6.10.1 with windows ghc
21:24:34 <cjs> But even adding that to the path just gets me "gcc.exe: installation problem, canot exec `cc1': Invalid argument".
21:24:45 <cjs> So you didn't have these issues?
21:24:52 <jeffz`> nope, which version of windows are you using?
21:26:18 <cjs> XP of some sort.
21:27:30 <cjs> Hm. something seems odd here; I had some path problems with FFI under Linux, too. gcc wasn't invoked with the appropriate -I flag for Haskell's include dir, and so the compiler couldn't find HsFFI.h. I ended up hacking around that by setting the CPATH environment variable.
21:27:58 <cjs> Could it be that I didn't properly de-install 6.8.3?
21:28:44 <mbz> """mallocForeignPtr :: Storable a => IO (ForeignPtr a) Allocate some memory and return a ForeignPtr to it."""
21:28:46 <jeffz`> not sure, i've installed it fresh every time and the stuff I compiled that uses ffi are just stuff like glfw from hackage
21:28:54 <mbz> "some memory"? Is it a joke?
21:29:59 <cjs> mbz: no, not at all. Why?
21:30:36 <mbz> err. I think that you at least should know the size of the allocated chunk to use it
21:30:53 <Cale> mbz: It depends on the type a
21:31:05 <mbz> oops.
21:31:30 * mbz is braindead
21:31:41 <Cale> sizeOf can tell you
21:33:29 <mbz> yeah I got. my primary language at work is C, so sometimes I continue thinking in terms of C
21:34:11 <cjs> Oh, you'll love FFI, then. Doing C programming in Haskell is wonderful.
21:34:31 <cjs> Darn it! I deleted 6.8.3 entirely, removed and re-installed 6.10.1, and I've still got the error.
21:37:23 <Cale> cjs: Which error?
21:37:30 <cjs> "gcc not found."
21:37:35 <Cale> hmm
21:38:34 <cjs> Indeed.
21:39:19 <cjs> I'm at a bit of a loss as to how to debug this.
21:40:17 <cjs> Argh! Same thing on another windows box, too.
21:42:40 <cjs> It's hsc2hs that's having the problem.
21:46:53 <cjs> Something's very strange here.
21:48:37 <cjs> Is there some sort of environment variable to set the "home dir" for ghc or something like that?
21:49:49 <gwern> cjs: you could do :cd foo, in .ghci
21:50:14 <cjs> This is hsc2hs that's failing; I'm not even at the point of calling ghc or ghci yet.
21:50:23 <gwern> oh
21:51:18 * dmwit knows how to fix a buttload of computer problems
21:51:20 <dmwit> icepick
21:51:34 <cjs> Icepick?
21:56:33 <b4taylor> cjs: I think he means to shank the problems.
21:56:46 <ozy`> cjs: just like the human brain, a computer can be greatly simplified in its operations with the strategic application of an icepick
21:58:59 <cjs> Yeah, that's sounding like a rather tempting solution to me, at the moment.
22:09:25 <gio123> merry christmans!
22:09:42 <dmwit> Merry Christmans to you, too!
22:09:50 <dmwit> It's a loovely time to be aliveb.
22:10:09 <dmwit> Also, you must live one time zone away from me!
22:10:11 <dmwit> How close!
22:11:10 <British0zzy> i always celebrate christmas middle eastern time
22:12:03 <dmwit> The Middle East is a dangerous place to celebrate Christmas.
22:12:31 <gio123> why?
22:12:47 <Chile`> dmwit: there are more christians there than you'd think
22:13:26 <gio123> sure
22:13:32 <British0zzy> but there's probably more middle eastern ppl there than christians, ;)
22:13:35 <dmwit> gio123: "The Middle East" refers to a geographic location including Iran, Iraq, Saudi Arabia, etc.
22:13:35 <gio123> I am ortodox
22:13:48 <dmwit> i.e. it was a joke ;-)
22:14:02 <gio123> aha
22:14:24 <gio123> but what is problem with iran, iraq etc?
22:15:38 <dmwit> They are not known for their religious freedom.
22:15:52 <gio123> ok
22:15:53 <dmwit> Or their cable television, for that matter.
22:15:59 <gio123> I dont care about this country
22:16:21 <gio123> I know many easter countries which are OK
22:16:51 <llayland> I know an easter island that is okay
22:18:18 <gio123> Sinch Bush is retried Iran and Iraq will become more democtratic countries
22:18:22 <dmwit> Cherry Mistmas!
22:19:01 <dmwit> I'm not sure why Iran would change at all.
22:19:28 <gio123> Obama will make good relationship with Iran
22:19:35 <dmwit> They already have a "democracy" in which 100% of votes are cast for the current leader.
22:22:07 <llayland> @lambdabot party affiliation/
22:22:07 <lambdabot> Unknown command, try @list
22:22:21 <llayland> lambdabot party affiliation/
22:23:02 <llayland> good
22:24:42 <Lemmih> Sigh, llvm doesn't support exceptions or proper garbage collection. Time to write yet another c-- compiler.
22:26:05 <mbz> @go C--
22:26:08 <lambdabot> http://en.wikipedia.org/wiki/C_programming_language
22:26:08 <lambdabot> Title: C (programming language) - Wikipedia, the free encyclopedia
22:29:16 <dmwit> ?go c minus minus
22:29:27 <dmwit> ?botsnack
22:29:33 <lambdabot> Plugin `search' failed with: thread killed
22:29:33 <lambdabot> :)
22:32:07 <int-e> http://www.cminusminus.org/
22:36:08 <ahunter> http://hpaste.org/13320 Can someone help me fix the ST-related type variables here?
22:36:51 <ahunter> I don't want to expose s in the GraphM constructor, I just need it internally for the STRef's I'm passing around
22:37:23 <Lemmih> ahunter: You must expose 's'.
22:38:22 <ahunter> Lemmih: really?  I don't see how not doing so subverts the types, which suggests it should be possible...
22:39:04 <Olathe> ghci has a line-length limit ?
22:39:35 <Lemmih> ahunter: You have to prove to the compiler that the 's' in GraphM is the same 's' you use to create the arrays.
22:41:19 <ahunter> Lemmih: ok.  Is there a way I can /make/ it the same?  The idea here is that I'll write terms in GraphM that allow fiddling with the passed arrays, but never expose those arrays to the user of GraphM
22:42:01 <Lemmih> ahunter: Something like 'runGraph :: Graph -> (forall s. GraphM s b a) -> a' would probably work.
22:43:07 <Cale> btw, using Data.Map would be way more convenient here
22:43:14 <ahunter> Lemmih: yeah, I thought of that...but I figured that it should in theory be possible to avoid that dodge--there'll be no way to get at STRef or STArray terms in GraphM, so no way to mix different state threeads
22:44:20 <ahunter> Cale: Yeah, I considered that too, I just figured that for fixed-size graphs, the "right thing" is to do array updates...hate adding unnecessary log factors for no reason.  I'm basically trying to write a monad for doing a generic version of the stuff algorithms in Data.Graph use
22:46:59 <pumpkin> is there a "count occurrences that meet the specified criterion" function or is length . filter the best way?
22:46:59 <Cale> For most of the stuff I've ever had to work with, for practical purposes the logarithmic factor could be safely ignored.
22:47:13 <Cale> pumpkin: the latter
22:47:56 <ahunter> Cale: probably true...should be neglible...but if monads and ST have a purpose, this would probably be it, wouldn't it?
22:48:42 <Cale> mm... monads in general no.
22:49:05 <ahunter> Cale: erm, miswrote that (...very late here) try "if ST monad has"
22:49:13 <Cale> ST in particular, I hardly ever find a use for -- I tend to think of it for cases where you have arbitrarily many mutating variables of different types.
22:51:54 <Cale> I suppose there are also cases where you need a very large unboxed mutable array for something like bitmap image processing, where the overhead of a Map is a little too much.
22:52:07 <Cale> and ST is good in those cases.
22:52:30 <Cale> Most of the graphs I've ever run into haven't been quite so large.
22:53:58 <Cale> (really it's the boxing which kills you in those cases moreso than the logarithmic factor)
22:56:04 <Raynes> http://en.wikipedia.org/wiki/Nick_News_with_Linda_Ellerbee
22:56:20 <Raynes> She looks like Linda Ellerbee at a distance.
22:58:00 <Raynes> Oops, wrong window. >_>
22:58:20 * BMeph restrains his pimp hand...
22:58:26 <BMeph> Raynes: No problem! ;)
22:58:46 <Raynes> Haha :)
23:23:33 <super_troll> We are giving away free Ops in main rooms this Xmas.. If you want any, type /server -m Irc.P2Pchat.Net -j #morpheus
23:25:21 <dons> oh, man, giving away free Ops! party
23:25:50 <BMeph> dons: Ha-ha, ROFLMFAO!
23:27:58 <pumpkin> what's that lambdacube package on hackage? there's no info on the hackage page
23:29:51 <cjs> Where in the GCI manual does it talk about using cpp?
23:31:48 <dons> GCI?
23:34:29 <pumpkin> so has santa visited all of you?
23:34:30 <dons> pumpkin: its an implementation of the lambda cube, http://www.rbjones.com/rbjpub/logic/cl/tlc001.htm i guess
23:34:44 <pumpkin> thanks :)
23:43:28 <cjs> Oops, I meant GHC, of course.
23:44:24 <dons> weird :)
23:44:31 <dons> using -cpp or the CPP extension. hmm.
23:44:38 <dons> probably in the preprocessor flags part
23:46:19 <Raynes> pumpkin: I shot Santa a moment ago. Figured he was a robber.
23:46:27 <pumpkin> oh no!
23:46:30 <pumpkin> now he won't visit me :(
23:46:40 <pumpkin> or is he a parallel santa
23:46:50 <Raynes> Parallel
23:47:12 <pumpkin> oh that's good
