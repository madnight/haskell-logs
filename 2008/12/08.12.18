00:01:28 <pumpkin_> solrize: hmm, I think you can do it such that you do
00:04:59 <solrize> could be.  but, i think there is a simpler solution
00:05:04 <pumpkin_> :o
00:06:29 <dolio> mmorrow: Also, a transformer and running two coroutines infinitely in the IO monad: http://hpaste.org/13160#a3
00:06:52 <centrinia> Hmm, I think I have it.
00:07:36 <centrinia> 11 divides R(10^9)
00:07:42 <pumpkin_> yup
00:07:50 <centrinia> So does 24001
00:08:01 <Gracenotes> hm, is there a simple way to construct NaN?
00:08:09 <centrinia> > 1/0.0
00:08:10 <lambdabot>   Infinity
00:08:13 <Gracenotes> > NaN -- not an actual constructor
00:08:13 <pumpkin_> 0.0
00:08:14 <lambdabot>   Not in scope: data constructor `NaN'
00:08:17 <pumpkin_> > 0/0
00:08:19 <lambdabot>   NaN
00:08:25 <Japsu> @index nan
00:08:25 <lambdabot> bzzt
00:08:27 <Gracenotes> hm. seems a bit hacky
00:08:28 <bd_> > read "NaN" :: Double
00:08:30 <lambdabot>   NaN
00:08:52 <bd_> hmm, I thought show was meant to produce haskell code :)
00:08:53 <centrinia> pumpkin_: Do you think that 76801 divides R(10^9)
00:09:08 <pumpkin_> centrinia: it's not one of the ones I found, but it's possible
00:09:14 <pumpkin_> there's a few I know definitely divide it
00:09:17 <Gracenotes> hm, that works, although the constructor itself doesn't seem to be reifiable
00:09:29 <centrinia> Okay, what about these: [11,17,41,73,101,137,251,257,271,353,401,449,641,751,1201,1409,1601,3541,4001,4801,5051]
00:09:35 <solrize> where do those weird numbers come from?
00:09:46 <solrize> i mean 76801 and 24001
00:09:56 <centrinia> Oh, I was playing with my program.
00:10:02 <Japsu> @oeis 11 17 41 73
00:10:03 <lambdabot>  Sequence not found.
00:10:05 <pumpkin_> I have a lot of the ones you listed, but not all of them
00:10:21 <solrize> oh, from factoring small R's
00:10:28 <pumpkin_> yup
00:10:34 <centrinia> I would be more interested in anything on the list that are not factors of R(10^9)
00:10:52 <pumpkin_> I can't guarantee any of the ones I don't have aren't :P
00:11:02 <Gracenotes> > isNaN (0/0)
00:11:04 <lambdabot>   True
00:11:21 <centrinia> pumpkin_: Here: http://hpaste.org/13162
00:11:41 <centrinia> The reps function should give the prime factors of any repunit.
00:12:29 <centrinia> I was just constructing repunits modulo an integer.
00:15:15 <solrize> @hoogle [a] -> a -> Int
00:15:16 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
00:15:16 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
00:15:16 <lambdabot> Prelude (!!) :: [a] -> Int -> a
00:15:43 <centrinia> pumpkin_: Did my approach make sense?
00:15:59 <pumpkin_> centrinia: sort of, trying to figure it out, and I'm not even sure it's correct yet :)
00:16:17 <solrize> pumpkin_ want a hint?
00:16:31 <pumpkin_> centrinia: it isn't accepting the output of your function :P
00:16:38 <pumpkin_> solrize: sure
00:16:46 <pumpkin_> although my approach is sort of working, just rather slowly
00:17:16 <centrinia> pumpkin_:Take the first four factors of R(10)
00:17:19 <solrize> look at the residues [10^k `mod` p | k <- [1..]] for small primes p, and see if useful patterns emerge
00:17:54 <pumpkin_> hmm
00:18:09 <centrinia> Look at the residues of (10^k - 1) `mod` p and see if useful patterns emerge. :-?
00:18:10 <centrinia> Hmm.
00:18:23 <centrinia> R(n) = 10^n - 1
00:18:41 <solrize> that would be (10^n-1)/9
00:18:48 <centrinia> Oh, sorry.
00:18:58 <solrize> i'm saying look at 10 mod p, 100 mod p, 1000 mod p, etc
00:19:24 <centrinia> I'm saying look at (10^n-1)*(modinvert p 9) `mod` p
00:19:35 <solrize> :t modinvert
00:19:36 <lambdabot> Not in scope: `modinvert'
00:19:48 <centrinia> You will have to write a modinvert then. ;)
00:19:50 <solrize> hmm anyway i htink we are basically both doing the same thing
00:19:55 <pumpkin_> hmm
00:21:13 <Gracenotes> does anyone know what the inspiration for the notation of >>= was?
00:21:53 <Gracenotes> . was probably based on the small circle for function composition; -> for math function arrows
00:22:03 <Gracenotes> where did binding come from (if anywhere)?
00:25:12 <BeelsebobWork> Gracenotes: Monads -- as in, the mathematical construct from category theory
00:25:49 <Gracenotes> ah, that's the notation that's used in CT?
00:26:44 <BeelsebobWork> I think so -- but I'm not category theory afficionado
00:28:07 <centrinia> pumpkin_: Did you get it now?
00:28:16 <pumpkin_> centrinia: nope
00:28:30 <solrize> pumpkin should i show an example?
00:28:48 <pumpkin_> solrize: I'm trying something based on what you said, but am not getting much yet
00:28:53 <solrize> ok
00:29:07 <centrinia> What are you trying?
00:29:17 <pumpkin_> solrize: are you sure it works? because centrinia's sample didn't :P
00:29:34 <jeffwheeler> dolio: p205 _was_ way easier with the probability monad. This is what I came up with: http://hpaste.org/13163.
00:29:42 <solrize> unless i'm missing something what i suggested should lead to the answer
00:30:09 <pumpkin_> hmm
00:30:21 <centrinia> pumpkin_: Try this: http://hpaste.org/13162#a1
00:30:50 <centrinia> pumpkin_: How did you use my reps function?
00:31:29 <BeelsebobWork> jeffwheeler: infix applicative strikes again! http://hpaste.org/13163#a1
00:32:04 * jeffwheeler has definitely not gotten that far in RWH. :P
00:32:06 <pumpkin_> centrinia: I thought it gave a different answer last time, let me see if this works
00:32:25 <jeffwheeler> BeelsebobWork: thanks, though; that cleans it up even more.
00:32:32 <pumpkin_> centrinia: 3 seems suspicious though
00:32:44 <chrisdone> does category theory have applications outside of computer science?
00:32:46 <BeelsebobWork> jeffwheeler: it does at a dependancy (on the InfixApplicative package) though
00:32:46 <centrinia> What do you mean?
00:33:30 <pumpkin_> centrinia: I dunno, never found it in any of my small trials
00:33:33 <pumpkin_> but I guess it's possible
00:33:43 <pumpkin_> however, it still rejects the answer that program gives me
00:33:59 <centrinia> Which program?
00:34:06 <pumpkin_> your second paste
00:34:37 <centrinia> What was the answer?
00:34:58 <pumpkin_> I don't know the correct one, it just tells me mine is incorrect :) but I got 683298 from the program you pasted
00:39:35 <jeffwheeler> Is there any Prelude function that can round a number to a specified position? The obvious solution is to just multiply and divide back, but it seems like there should be something I'm missing.
00:40:33 <jeffwheeler> E.g., round 0.567 to two digits, creating 0.57.
00:41:24 <paolino> @hoogle :: a -> a
00:41:24 <lambdabot> Prelude id :: a -> a
00:41:24 <lambdabot> Data.Function id :: a -> a
00:41:24 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
00:42:24 <paolino> there is something with show probably
00:43:41 <pumpkin_> jeffwheeler: how does one get the probability monads stuff working on recent GHCs? I read the blog post about it a while ago but it wasn't working when I tried it
00:43:57 <jeffwheeler> pumpkin_: seems to work fine in 6.10.
00:44:05 <pumpkin_> jeffwheeler: hmm, not for me :(
00:44:10 <jeffwheeler> pumpkin_: although, since I've never used it before, I suppose it could be acting strangely.
00:44:18 <solrize> ok i think i have a working program but it may not finish in 1 minute under ghci
00:44:33 <pumpkin_> solrize: how terrible :P
00:44:37 <Axman6> @djinn (a -> a) -> a -> a
00:44:37 <lambdabot> f a = a
00:44:43 * jeffwheeler can't stand the damn num functions; I can never get the types right.
00:45:42 <solrize> first 10 factors are [11,17,41,73,101,137,251,257,271,353]
00:46:05 <jeffwheeler> solrize: you doing a euler problem, too?
00:46:06 <pumpkin_> I have all of those except 257
00:46:24 <solrize> jeffwheeler, we're both discussing problem 132
00:46:35 * jeffwheeler looks.
00:46:45 <solrize> next few are 401,449,641,751,1201
00:47:00 <centrinia> pumpkin_: I know what's wrong with my program. :p
00:47:06 <pumpkin_> centrinia: yay :P
00:47:21 <pumpkin_> solrize: I'm missing 2 of those :P
00:47:29 <pumpkin_> I guess the number I'm missing will keep going up
00:47:30 <Axman6> @djinn (a -> a -> b) -> a -> b
00:47:30 <lambdabot> f a b = a b b
00:47:44 <centrinia> It considers 3 to be a factor because it computes (10^n-1) `mod` 3
00:48:54 <solrize> even with ghc -O2 this is taking way over a minute though
00:48:59 <pumpkin_> :)
00:49:02 <tehgeekmeister> has there been any progress on the proposed haskell-python bridge?
00:49:03 <solrize> i need a better algorithm
00:49:12 <tehgeekmeister> i can't find anything recent about it...
00:49:14 <pumpkin_> solrize: are you generating primes smartly?
00:49:22 <pumpkin_> or is it not slow because of that?
00:49:26 <solrize> not especially smartly but this doesn't use so many of them
00:49:35 <solrize> i'm not sure why it's slow, maybe a laziness issue?
00:49:44 <pumpkin_> I can tell you ones I'm certain of, if that helps
00:49:57 <solrize> i think the ones i'm getting are correct, it's just slow
00:49:59 <solrize> i have about 25 so far
00:50:14 <pumpkin_> 60101 one of them?
00:50:21 <pumpkin_> or are you not that far yet?
00:50:26 <solrize> 11 17 41 73 101 137 251 257 271 353 401 449 641 751 1201 1409 1601 3541 4001 4801 5051 is all i have so far
00:50:35 <solrize> i can check 60101 if you want
00:50:38 <centrinia> Yay, I got it. :)
00:50:40 <solrize> 9091
00:50:41 <pumpkin_> ah, don't worry about it
00:50:45 <pumpkin_> I have that one too
00:50:48 <pumpkin_> centrinia: verified?
00:50:51 <centrinia> Yes. :)
00:50:55 <pumpkin_> nice :)
00:51:18 * osfameron boggles at the combination of specialist skills, lack of benefits, and terribly hourly rate at http://getafreelancer.com/projects/C-C-Java/Lisp-Developers-Lisp-Really-Yes.354488.html
00:51:49 <solrize> pumpkin does my earlier hint make sense yet?
00:51:51 <centrinia> pumpkin_: I took my second post, tailed reps, and took 40 elements. ;)
00:52:01 <pumpkin_> solrize: sort of
00:52:06 <centrinia> The factor 3 is always going to be present for base 10. :p
00:52:15 <osfameron> (pick 2 would be fine, but all 3 seems bonkers.  Are they counting on the "clever people want to work with good languages" effect?)
00:52:19 <solrize> > take 30 [10^k `mod` 7 | k <- [0..]]
00:52:20 <lambdabot>   [1,3,2,6,4,5,1,3,2,6,4,5,1,3,2,6,4,5,1,3,2,6,4,5,1,3,2,6,4,5]
00:52:31 <pumpkin_> solrize: yeah, got that much
00:52:33 <mmorrow> dolio: sweet, just got back
00:52:36 * mmorrow looks
00:52:53 <solrize> i cant get to that freelancer site
00:52:57 <pumpkin_> me neither
00:53:03 <solrize> probably just as well
00:53:16 <pumpkin_> lol
00:53:17 <solrize> http://hpaste.org/13162#a2
00:54:50 <osfameron> oh, the freelancer page works for me... try http://www.reddit.com/r/programming/comments/7k7tb/we_are_not_trying_to_be_old_school_by_using_perl/ ?
00:55:10 <solrize> :t divMod
00:55:11 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
00:55:12 <pumpkin_> wow
00:55:51 <pumpkin_> that's a terrible deal
00:56:18 <pumpkin_> I can't believe people are bidding on it
00:56:37 <osfameron> as the reddit thread suggests, they probably aren't looking for people within US
00:56:44 <pumpkin_> yeah
00:56:53 <osfameron> but the 10 hour probationary thing is just *mean*
00:57:25 <osfameron> maybe refusing to pay the first *2* hour project (if the dev was completely incompetent) would be fair
00:58:52 <solrize> i guess i can optimize that code a little but it will still be too slow
00:59:40 <solrize> this just sucks, i wonder what it's doing, i guess i should profile it
00:59:58 <solrize> next factor is 10753
01:00:52 <solrize> ohhhh i know what's wrong
01:00:54 <solrize> silly me
01:00:58 <pumpkin_> :o
01:01:51 <solrize> ahhh, much better
01:01:55 <pumpkin_> :o
01:01:58 <solrize> hmm but still slow
01:02:15 <solrize> well it got up to 10753 in about 10 sec instead of 10 minutes
01:02:18 <solrize> it's still there now
01:02:37 <solrize> 15361, 16001 are the next 2
01:02:42 <mmorrow> dolio: interesting
01:02:49 <solrize> 19841
01:02:53 <solrize> 21001
01:03:01 <solrize> 21401
01:03:29 <solrize> 25601
01:03:38 <pumpkin_> missed one
01:03:43 <solrize> i did?
01:03:56 <pumpkin_> centrinia's spat out 24001
01:03:57 <solrize> 27961
01:04:10 <solrize> oh i got that
01:04:14 <pumpkin_> ok :)
01:05:34 <solrize> this looks like a good application for `par`  ;)
01:05:38 <pumpkin_> :o
01:05:39 <solrize> 37501
01:06:01 * pumpkin_ raises centrinia's hand
01:06:18 <pumpkin_> I still need to figure out how it's working :)
01:06:27 <solrize> mine might be clearer, if slower
01:06:36 <pumpkin_> yeah, it looked it
01:07:13 <pumpkin_> no offence to centrinia's coding ;)
01:07:22 <solrize> do you see that R(n)`mod` p = sum [10^k `mod` p | k <- [0..n]]  ?
01:07:33 <solrize> mod p that is
01:07:41 <pumpkin_> yeah
01:08:03 <solrize> > take 30 [10^k `mod` 7 | k <- [0..]]
01:08:05 <lambdabot>   [1,3,2,6,4,5,1,3,2,6,4,5,1,3,2,6,4,5,1,3,2,6,4,5,1,3,2,6,4,5]
01:08:13 <solrize> so for p=7 for example there is a repeating cycle
01:08:14 <centrinia> pumpkin, what's wrong?
01:08:19 <pumpkin_> nothing :)
01:08:22 <dolio> Which problem is this?
01:08:24 <solrize> 132
01:08:29 <pumpkin_> solrize: yeah, I saw
01:08:52 <solrize> the cycle has length 6
01:09:26 <solrize> so the sum of the first billion terms = (billion`div`6) * (sum of terms in the cycle) + remainder
01:10:12 <pumpkin_> ah, I see
01:10:24 <solrize> do that for small primes 3,7,11,13,...
01:10:34 <solrize> (don't do 2 or 5 since they divide 10)
01:10:36 <pumpkin_> yeah
01:11:05 <solrize> so i get that cycle pretty crudely
01:11:10 <solrize> sum the terms in it
01:11:13 <solrize> find the length etc
01:11:25 <pumpkin_> ah
01:11:42 <solrize> i don't understand where those Ints come from that i have to turn to integers with fromIntegral
01:12:03 <solrize> 40961, 43201, 60101, 62501
01:12:11 <solrize> came out in last couple minutes
01:12:18 <solrize> 7 more to go
01:12:43 <pumpkin_> that replen might be getting cast to an Int?
01:12:59 <pumpkin_> actually, no
01:13:01 <solrize> anyway the code could be cleaned up and golfed a lot but i think the algorithm should make sense now
01:13:25 <pumpkin_> aha, it's elemIndex
01:13:35 <solrize> oh crap
01:13:48 <solrize> that was from an earlier version, i wanted takewhile
01:13:55 <solrize> i wonder if that's the slowdown too
01:14:08 <solrize> no i guess it's not
01:14:27 <solrize> anyway i could do tenlen and gp in the same res1 and that would double the speed
01:14:31 <solrize> but that's still too slow
01:14:42 <solrize> 69857
01:15:03 <solrize> oops just 2 more to go
01:15:25 <pumpkin_> :)
01:15:28 <solrize> but it's used 13.5 cpu minutes already, on a pretty fast box
01:15:36 <solrize> with ghc -O2
01:16:42 <solrize> i wonder if it's recomputing primes every time?  hmm
01:16:48 <solrize> i don't want to stop it now that it's almost done
01:17:04 <solrize> but i bet that's the problem and i'll try it as soon as this finishes
01:17:07 <solrize> 76001
01:17:36 <solrize> actually nah, that's not the slowdown
01:18:11 <Axman6> http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas BeelsebobWork strikes again
01:18:51 <BeelsebobWork> >.>
01:19:38 <solrize> i see another speedup i can make but that won't be that big either
01:20:22 <BeelsebobWork> Axman6: I should probably stop the silly ones -- my serious one with λs for ls I still really like
01:21:00 <Axman6> BeelsebobWork: yeah, they just need to be spaced out a bit
01:21:13 * Axman6 wonders how his would look in all black
01:23:02 <mmorrow> dolio: that's annoying that both go and go' are needed in the where clause of coroutineForever
01:23:43 <solrize> http://www.lisperati.com/landoflisp/f057.png
01:25:36 <dolio> mmorrow: Yeah. They do slightly different things.
01:26:03 <solrize> program is still doing the last factor, for at least past 5 minutes, maybe more like 10
01:33:29 <mmorrow> dolio: it seems like they're perfect mirror images about x<--->y , and how GADT pattern matches set the type seems to be why the recursive call can't be on a polymorphic type (???)
01:33:55 <mmorrow> or s/polymorphic/the fixed-by-GADT-pattern-match-type/
01:34:25 <dolio> mmorrow: One sticks in f when one of the coroutines runs out, the other sticks in g.
01:34:42 <mmorrow> ahhh.
01:34:49 <dolio> go and go' denote which coroutine we're currently running.
01:35:10 <mmorrow> sweet, i missed that small diff. i think i know how to merge them now then.
01:35:10 <jeffz`> BeelsebobWork: the text on your rocket is upside down
01:35:25 <BeelsebobWork> jeffz`: ?
01:36:03 <jeffz`> BeelsebobWork: seems more natural to tilt ones head to the right as if you're reading the spine of a book, hmm
01:36:10 <quicksilver> I quite like George Pollard's interpretation of the >\=
01:36:11 <jeffz`> maybe not
01:36:36 <Axman6> jeffz`: i don't like tilting my head more than 90 degrees personally :)
01:36:51 <quicksilver> easier to tilt the laptop.
01:36:58 <BeelsebobWork> jeffz`: not all books go the same way, and yeh, that would involve tilting your head over 90°
01:37:04 <quicksilver> My personal favourite is still Cale's mountain lambda.
01:37:10 <quicksilver> I think it works as a logo and as an icon
01:37:16 <quicksilver> and it works in colour as well as black and white.
01:37:18 <pumpkin_> which is thta?
01:37:22 <pumpkin_> the mountain lambda
01:37:37 <quicksilver> well it's cale's only submission :)
01:37:51 <BeelsebobWork> quicksilver: yeh, it's not bad -- but I prefer the one with the modified font
01:38:03 <quicksilver> Totally; Cale's font is nasty.
01:38:10 <quicksilver> But the letters aren't the important part of the logo :)
01:38:13 <Axman6> any thoughts on improving mine? (the tag line should be changed, but that's not the important part
01:38:13 <quicksilver> easier to find a nicer font.
01:38:19 <BeelsebobWork> and I think the shape of the lambda may need fixed a little, it's not immediately obvious that it's a mountain to me
01:38:24 <jeffz`> BeelsebobWork: if books didn't all go the same way I'm suggesting then they would be upside down when laying flat, but yeah, I guess it doesn't work well for your logo :)
01:38:51 <quicksilver> the colour version is clearly a mountain to my eyes.
01:38:54 <quicksilver> The b&w one less so.
01:38:56 <quicksilver> Axman6: which is yours?
01:39:03 <BeelsebobWork> I think possibly the white cap needs moved up a bit
01:39:05 <Axman6> the one tagged Axman6 ;)
01:39:08 <quicksilver> Axman6: oh, found your name :)
01:39:09 <Axman6> ones*
01:39:12 <BeelsebobWork> and then it might look more mountainy
01:39:45 <quicksilver> Axman6: the concept is good, but the key is in the font.
01:39:59 <quicksilver> Axman6: I think you might need to draw it "by hand" to make the \ and the H join nicely.
01:40:06 <Axman6> quicksilver: yeah, i don't have many nice fonts that flow with the lambda though :\
01:40:19 <quicksilver> currently it looks odd because the stroke width in the lambda follows classical typography
01:40:30 <quicksilver> (NE stroke fatter than SE stroke)
01:40:43 <Axman6> ah yes
01:40:48 <quicksilver> but the stroke width in the H is more 'fat marker pen'
01:40:57 <quicksilver> (EW stroke fatter than NS)
01:41:33 <Axman6> that should be 'shopped easily
01:41:40 <Axman6> i just don't have the tools really
01:41:48 * Axman6 ight gimp it up later
01:41:49 <quicksilver> inkscape ftw!
01:41:51 <mmorrow> dolio: http://hpaste.org/13160#a4
01:42:46 * Axman6 installs inkscape again
01:43:42 <paolino> @hoogle comparing
01:43:43 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:43:43 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:44:07 * BeelsebobWork wonders what the general opinion of http://haskell.org/haskellwiki/Image:HaskellLogoTDavie.png is
01:44:32 <quicksilver> for me, it's a good idea let down by a font :)
01:44:42 <osfameron> people would wonder what "Haske" is
01:45:00 <osfameron> or maybe "Haskem"
01:45:04 <quicksilver> if an idea is essentially typographical, then you have to get the typography looking perfect :)
01:45:44 <BeelsebobWork> how would you improve the typography in it?  reduce the kerning between the e and the first l, and increase it between the ls?
01:45:51 * BeelsebobWork suspects that might look more m like
01:46:53 <pumpkin_> Cale's is nice, but I don't like his font
01:47:05 <quicksilver> pumpkin_: agreed. But the font isn't the important part :)
01:47:11 <quicksilver> pumpkin_: that would be easy to change.
01:47:13 <Axman6> i like Cale's idea, but it needs work
01:47:14 <pumpkin_> yeah
01:47:44 <Axman6> thinker lambda maybe, not quite a rounded at the top
01:47:52 <Axman6> and as BeelsebobWork said, higher snow
01:48:04 <BeelsebobWork> Axman6: I tried that -- the problem is you then lose the lambda
01:48:09 <BeelsebobWork> because you can't see it's lower edge
01:48:12 <mmorrow> dolio: (same function, but how i should've formatted it ;) http://hpaste.org/13160#a5
01:48:16 <mmorrow> purdy
01:49:18 <BeelsebobWork> mmorrow: that only requires applicative, no?
01:50:04 <Axman6> anyway, gotta head off. later al
01:50:41 <mmorrow> BeelsebobWork: ?
01:50:56 <mmorrow> (what are you refering to?)
01:51:49 <BeelsebobWork> mmorrow: your Monad m
01:51:53 <BeelsebobWork> it only needs to be an Applicative
01:52:18 <mmorrow> BeelsebobWork: it's dolio's. i don't understand how you mean.
01:52:32 <BeelsebobWork> go :: (Applicative m) => ....
01:52:47 <mmorrow> BeelsebobWork: did you see the context that it's in though
01:53:13 <BeelsebobWork> mmorrow: sure -- that's no reason not to write your functions as generally as they can be though :)
01:53:16 <mmorrow> the `m' in CoroutineT has to be a monad
01:53:19 <BeelsebobWork> it might come in handy elsewhere
01:53:33 <mmorrow> (and it was in a where clause too...)
01:54:12 <mmorrow> BeelsebobWork: so what would you do about the (>>=)s that it uses?
01:54:26 <BeelsebobWork> mmorrow: it's not needed, it can be replaced with a <*>
01:54:31 <BeelsebobWork> actually no, a <$>
01:54:34 <BeelsebobWork> so it only need be a functor
01:54:46 <mmorrow> but the you'd need to join it
01:54:48 <mmorrow> *then
01:54:59 <mmorrow> mx >>= \x -> go g f (k x) f
01:55:12 <mmorrow> :: m b
01:55:29 <BeelsebobWork> (\x -> go g f (k x) f) <$> mx
01:55:38 <mmorrow> :: m (m b)
01:55:45 <BeelsebobWork> oh, >.<
01:55:49 <mmorrow> :)
01:55:52 <BeelsebobWork> sorry, my brain is not working today
01:56:25 <mmorrow> for a second there i was like whoa .... waiiiiiiit a minute
01:59:25 <n00bie> ello
02:10:41 <luqui> hi n00bie
02:12:43 <solrize> oh that thing finished, next factor after 76801 was 160001.  i wonder why the big gap?  and no wonder it took so long.
02:13:04 <mmorrow> valid PiSigma expressions: http://hpaste.org/13164
02:13:21 <mmorrow> i guess they're declarations..
02:18:23 <quicksilver> solrize: why not a big gap? :)
02:18:52 <quicksilver> solrize: once you've cleared out the small factors, all that's left is the big factors, which have a natural tendency to be further apart from each other...
02:26:08 <fasta> Is there an expert Wordpress user lurking here?
02:31:37 <solrize> quicksilver i'd have guessed the gaps would grow like lg n, i.e. they wouldn't grow slowly for a while then suddenly double in size
02:31:56 <pumpkin_> primes are odd things :P
02:32:39 <quicksilver> solrize: is there some property of the number which makes you expect its factors to be evenly distributed? :)
02:32:46 <quicksilver> because most numbers do not have that property.
02:32:51 <solrize> hmm
02:32:52 <quicksilver> most numbers have lots of factors of 2,3,5
02:33:07 <quicksilver> and then a small number of high factors.
02:33:21 <quicksilver> which are spaced out
02:33:28 <quicksilver> because that's how multiplication works...
02:34:14 <quicksilver> (I mean, obviously 50% of numbers have one factor of 2, 25% have two of them, 33% of numbers have one factor of three, but very very few numbers have a factor of 76801... well, about 1/76801 of them!)
02:34:27 <solrize> yeah, that makes sense
02:34:32 <centrinia> Most integers are divisible by 1. A lot of integers are divisible by 2. Quite a few integers are divisible by 3. Many integers are divisible by 4. ;)
02:35:11 <BeelsebobWork> centrinia: why integer is not divisible by 1?
02:35:19 <BeelsebobWork> which*
02:35:32 <centrinia> BeelsebobWork: I never claimed that there is an integer that is not divisible by 1. ;)
02:35:43 <BeelsebobWork> no, but you implied the claim
02:36:06 <quicksilver> http://www.alpertron.com.ar/ECM.HTM
02:36:21 <quicksilver> solrize: type a random splurge of digits into that rather fast elliptic factoriser
02:36:30 <quicksilver> do it a few times with a few random splurges
02:36:37 <quicksilver> and watch what kind of prime distribution is "typical"
02:36:41 <centrinia> Okay, how about I shift the claim, "All integers are divisible by" into the front and shift every other claim back by one slot? :)
02:37:19 <solrize> well, represent a random n as residues mod (2,3,5,...) and each residue is picked at at random
02:37:59 <BeelsebobWork> centrinia: I'd like to see you then justify the claim that there are more integers divisible by 2 than not :P
02:38:03 <Gabbie> "most integers are divisible by 2" doesn't work either
02:38:07 <quicksilver> yes, so the probability of being divisible by p is 1/p
02:38:07 <BeelsebobWork> significantly more in fact
02:38:19 <quicksilver> but the density of primes is lg
02:38:23 <solrize> and you'd expect to see a run of something more than p after each 0
02:38:27 <centrinia> Claim: if a < b, then the probability that a random integer is divisible by a is greater than the probability that a random integer is divisible by b.
02:38:49 <solrize> you if a and b are both prime i hope
02:38:49 <BeelsebobWork> centrinia: hehe, that one I'll accept :P
02:38:58 <centrinia> solrizeNo.
02:39:07 <pumpkin_> has anyone ever proved that the probability of two integers being relatively prime is 6/pi^2?
02:39:10 <centrinia> b can be less than zero for all I care. :p
02:39:21 <solrize> pumpkin_ i remember a theorem like that from somewhere
02:40:50 <quicksilver> pumpkin_: sounds like it ought to depend on the distribution used to pick the numbers.
02:41:01 <pumpkin_> yeah, uniform :)
02:41:02 <pumpkin_> sorry
02:41:05 <centrinia> pumpkin_: The steps up to proving that pi^2/6 = zeta(2) are easy.
02:41:10 <quicksilver> there is no uniform distrbution over Z!
02:41:15 <centrinia> Proving that zeta(2) = pi^2/6 is a little more difficult. ;)
02:41:19 <quicksilver> can't have uniform infinite distributions.
02:41:22 <pumpkin_> oh, hmm, you're right :P
02:41:42 <quicksilver> finite variance / infinite variance normally makes quite a big difference.
02:42:14 <solrize> gotta sleep, gnite
02:43:50 <centrinia> pumpkin_: What is the probability that two nonnegative integers are divisible by the prime q?
02:44:27 <pumpkin_> not a clue :)
02:44:54 <centrinia> Oh screw it. You can read this alone: http://en.wikipedia.org/wiki/Coprime :(
02:45:09 <pumpkin_> aw
02:45:45 <pumpkin_> I'm sorry, just a little out of it tonight :P
02:45:53 <centrinia> pumpkin_: How many Project Euler problems did you complete?
02:46:06 <pumpkin_> I've got 46
02:46:31 <centrinia> Hmm, I should catch up then.
02:46:42 <pumpkin_> :(
02:46:56 <pumpkin_> http://projecteuler.net/index.php?section=profile&profile=pumpkin
02:47:21 <Asztal> you did the same 3 recent ones as me :)
02:47:25 <Asztal> 204,205,206
02:47:57 <pumpkin_> :)
02:50:15 <ketil> Does haddock (not) support bang patterns?
02:51:43 <pumpkin_> centrinia: how many do you have?
02:51:54 <centrinia> Look up my profile. :(
02:52:05 <centrinia> It's pretty low. :(
02:52:17 <pumpkin_> you have one high one though
02:52:26 <centrinia> What do you mean?
02:52:35 <pumpkin_> 203
02:52:36 <ketil> Hm.  upgrading did the trick - almost.   I now get: "haddock: internal Haddock or GHC error: No libdir found"
02:52:38 <ketil> Any ideas?
02:52:59 <centrinia> Oh.
02:53:07 <pumpkin_> some of them are rather tedious, particularly at the beginning
03:05:57 <Asztal> problem 77 was just silly, I did it by hand.
03:06:22 <ouwerue> os
03:17:19 <lilac> is there a nicer way of writing "liftM2 (&&)" ?
03:18:21 <ivanm> @pl liftM2 (&&)
03:18:21 <lambdabot> liftM2 (&&)
03:18:23 <Peaker> @unpl liftM2 (&&)
03:18:23 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b && a))
03:18:24 <sjanssen> lilac: no, I don't think so
03:18:26 <BeelsebobWork> if you're using it infix x <^(&&)^> y
03:18:28 <ivanm> looks like there isn't
03:18:42 <sjanssen> lilac: what is so bad about liftM2 (&&)?
03:18:42 <BeelsebobWork> if you're not (&&) <$> x <*> y
03:18:50 <BeelsebobWork> but no if you're using it partially applied
03:19:01 <lilac> BeelsebobWork: xmonad's Query doesn't appear to have an Applicative instance :)
03:19:11 <BeelsebobWork> lilac: fix it then
03:19:14 <sjanssen> lilac: see (<&&>)
03:19:22 <sjanssen> we've already got a lifted version in that module
03:19:24 <BeelsebobWork> instance Applicative Query where pure = return; (<*>) = ap
03:19:45 <sjanssen> BeelsebobWork: I don't see how the version involving <*> is any better
03:19:46 <lilac> BeelsebobWork: that seems overkill for an xmonad config script :)
03:20:17 <BeelsebobWork> lilac: I was suggesting you patch xmonad, not put it in your script
03:20:17 <RayNbow> > let infixl 1 «, »; («) = flip liftM2; (») = ($);    in    [False ..] «(&&)» [False ..]
03:20:18 <Peaker> Wouldn't it be nice if functions that are specific to types like Bool could be automatically lifted to the right level somehow, with typeclass trickery?
03:20:19 <lambdabot>   [False,False,False,True]
03:20:20 <luqui> I think he means you should submit a patch
03:20:26 <BeelsebobWork> if it has a monad instance, it should have an applicative one
03:20:33 <BeelsebobWork> sjanssen: in a lot of cases it looks "more functional"
03:20:34 <luqui> Peaker, yes, but not with typeclass trickery
03:20:40 <BeelsebobWork> it looks more like you're just applying it
03:20:40 <Peaker> luqui: why not?
03:20:46 <sjanssen> BeelsebobWork: here, I think it looks "more boilerplate"
03:20:49 <luqui> Peaker, because it would be horrible hacks
03:20:52 <luqui> I would like a clean solution
03:21:06 <Peaker> luqui: I don't think there is any other way
03:21:14 <BeelsebobWork> sjanssen: possibly, yeh
03:21:16 <Peaker> (Maybe TH but that's not "cleaner" :-)
03:21:19 <luqui> Peaker, that's rather presumptuous don't you think?
03:21:22 <sjanssen> Peaker: if the type is fixed to a type, like Bool, that is rather easy to do
03:21:29 <BeelsebobWork> sjanssen: either way, it needs an xmonad patch to get the applicative instance
03:21:33 <BeelsebobWork> because it should be there
03:21:46 <sjanssen> mtl doesn't have Applicative instances, so we don't bother for the most part
03:21:52 <BeelsebobWork> fix mtl then!
03:21:53 <Peaker> liftA2 is probably better than liftM2 to not over-specialize the code..
03:21:54 <sjanssen> patch mtl, then we could just newtype derive it
03:22:02 <luqui> Peaker, oh, impossible in haskell as it stands perhaps.  But solving it in an ML-like language in general is still very interesting, and pretty much unexplored.
03:22:34 <Peaker> sjanssen: how is it done?
03:22:57 <sjanssen> Peaker: you make the function into a class method
03:23:01 <lilac> luqui: i'm pretty interested in union types for ad-hoc overloading, to solve this sort of problem
03:24:10 <sjanssen> class Not t where not :: t -> t; instance Not Bool where not = obvious; instance Not a => Not [a] where not = map not
03:24:37 <Peaker> sjanssen: That's not automatic, maybe something like "liftA2" on (&&) that will go as many levels as necessary (perhaps liftA2 . liftA2 . liftA2 if its within multiple applicatives)..
03:24:52 <lilac> Peaker: maybe what you want is overloaded " "?
03:25:00 <luqui> Peaker, of course there are cases in which both liftA2 and liftA2.liftA2 would typecheck...
03:25:03 <sjanssen> 'not' is a particularly simple one, the trick does not scale well to more complicated types
03:25:13 <Peaker> luqui: for (&&) ?
03:25:15 <luqui> so we have to have something more in the theory, rather than just "pick the one that works"
03:25:16 <sjanssen> Peaker: change the list instance to an Applicative a instance, and you've got it
03:25:19 <luqui> Peaker, no not for &&.
03:25:22 <luqui> in general.
03:25:41 <sjanssen> (of course this is an overlapping instance, but not a terrible one)_
03:25:46 <luqui> Peaker, Bool has an applicative instance, actually.
03:25:50 <luqui> it's just pretty useless.
03:25:56 <sjanssen> luqui: Bool has the wrong kind
03:25:59 <luqui> er
03:26:00 <luqui> duh
03:26:06 <luqui> I was thinking Const Bool
03:26:07 <luqui> =P
03:26:43 <sjanssen> Peaker: any way, I think most functions in Haskell are significantly polymorphic that autolifting would not be possible
03:26:50 <sjanssen> or at least would be horribly complicated
03:27:01 <Peaker> If I have fmap.fmap.fmap -- I can convert it to  first.second.result --  what can I do to   liftA2.liftA2.liftA2 -- if I want to traverse such a path?
03:27:13 <Peaker> sjanssen: Yeah, maybe its fine the way it is :-)
03:27:27 <lilac> class Apply t where ($) :: t; instance Apply ((a -> b) -> a -> b) where ($) = id; instance Functor f => Apply ((a -> b) -> f a -> f b) where ($) = fmap; instance Applicative f => Apply (f (a -> b) -> f a -> f b) where ($) = (<*>)
03:27:55 <lilac> then define "f x" to be syntactic sugar for "f $ x"
03:28:22 <tjb> hopefully a basic questions -- How do I have ghci search for custom module definitions in the current directory?
03:28:26 <sjanssen> lilac: yes, and every single function application will become ambiguous
03:28:41 <sjanssen> lilac: that just doesn't work in Haskell
03:28:50 <quicksilver> tjb: it should automatically search form the current directory
03:28:56 <lilac> sjanssen: do those instances actually overlap?
03:29:13 <quicksilver> tjb: (assuming that there is a "module Foo.Bar where " in ./Foo/Bar.hs )
03:29:29 <tjb> quicksilver: oh, the filename is important?
03:29:38 <lilac> sjanssen: the first and second clearly don't, likewise second and third. but the first and third might i guess
03:29:40 <quicksilver> tjb: yes. That's how the search procedure works.
03:30:01 <sjanssen> lilac: have you actually tried this code?
03:30:04 <tjb> quicksilver: ah, yes -- now it works.  thanks again
03:30:08 <quicksilver> tjb: (it's not part of the haskell standard, it's just a pragmatic way to manage files, but all the major haskell implementations use it)
03:30:08 <lilac> sjanssen: no, it's a thought experiment
03:30:58 <sjanssen> lilac: consider "id $ id", keeping in mind that id :: forall a. a -> a
03:31:10 <ouwerue> admins
03:31:26 <quicksilver> ouwerue: ?
03:31:33 <tjb> quicksilver: I understand.  I was confused because some of the haskell documentation describes how modules and filenames aren't necessarily tied together :)
03:31:56 <tjb> quicksilver: but from a pragmatic point of view, it makes sense to tie them together
03:32:39 <quicksilver> tjb: yeah, they're not "necessarily". But it happens that all the implementations tended towards the same standard :)
03:32:40 <lilac> sjanssen: type classes aren't a good way of expressing this, for various reasons. this is what led me to start thinking in the direction of union types
03:32:56 <quicksilver> tjb: most of the implementations use the same standard library files, so they rather had to agree on a file layout setup.
03:33:21 <sjanssen> lilac: I don't know about union types.  I just know that Haskell's type classes won't work
03:33:30 <tjb> quicksilver: makes sense -- good to know
03:33:33 <sjanssen> a MPTC could probably work
03:35:01 <sjanssen> or just associated types: class Apply f where { type Arg f; type Result f; ($) :: f -> Arg f -> Result f }
03:35:16 <sjanssen> I think that could work
03:38:40 <Botje> OI
03:38:48 <Botje> don't ping people :P
03:40:10 <sjanssen> ouwerue: what are you doing?
03:40:55 <pumpkin_> pinging everyone? :P
03:41:00 <quicksilver> Trying to understand IRC, I suspect.
03:42:52 <lilac> sjanssen: that can't work; selecting an instance needs to depend on at least the function type and the argument type, to support applicative functors
03:43:39 <sjanssen> lilac: http://hpaste.org/13165
03:43:55 <sjanssen> lilac: matching on only the function type seems sufficient
03:44:21 <sjanssen> lilac: I can't really imagine a case where the applied type doesn't depend on the function type
03:44:57 <lilac> sjanssen: how about "negate 42" versus "negate [42, 76]"?
03:46:07 <sjanssen> lilac: so at worst, you'd need to add 'pure' on occasion
03:46:28 <tjb> When creating a set of modules -- in say, "/Foo" is it good form to name my modules "/Foo/FooCommon.hs" or just "/Foo/Common.hs" ?
03:47:10 <lilac> you could just about fix that if you could define a Functor instance for the 'identity' type constructor, but i suspect that woudl break a /lot/ of stuff
03:47:11 <sjanssen> lilac: also, what is to say that [a] isn't a Num instance?
03:47:25 <quicksilver> tjb: I would say Foo/Common.hs
03:47:30 <quicksilver> (module Foo.Common )
03:48:25 <tjb> ok, so having say something like Foo.Prelude won't conflict with the standard Prelude name?
03:48:32 <lilac> sjanssen: nothing, naturally. dealing with ambiguity is obviously important (and not something typeclasses can handle easily)
03:49:48 <tjb> alright, thanks for the help again -- time for that "real" world work stuff now
03:51:04 <blackh> tjb: That's correct (Foo.Prelude won't conflict with Prelude)
03:51:55 <mapreduce> wchogg: Thanks again for the pointer at Pierce's lecture slides.  I'm having fun in CoqIDE with them.
03:53:13 <mapreduce> I'm not sure what's being proved on the lines reading: Proof. simpl. reflexivity. Qed. but I'm sure I'll get there.
03:54:14 <vixey> simpl. is redundant there
03:54:54 <mapreduce> Does it just prove that all functions are total?
04:05:01 <mathijs> how can I type a type declaration in ghci?
04:06:48 <Peaker> mathijs: as in:  let f :: Integer ; f = 5 ?
04:06:58 <Peaker> mathijs: or defining new types? That you can only do in a file, then :load YourFile
04:07:49 <mathijs> Peaker: as in your first example
04:08:53 <mathijs> Peaker: thanks, I tried without the ; (just separate lines)
04:12:06 <mathijs> and how about 'hinting' inline? Say I have this function sumline = sum . map read . words, which expects a line like "1 2 3", it doesn't work on floats for some reason ("1.2 3.8 4.1"). Now I can make sumlineFloat and declare it as :: Float, but what if I want to just 'hint' read inline? like sumlineFloat = sum . map (read :: Float) . words
04:12:52 <luqui> mathijs, well type application would do that if we had it.
04:13:24 <luqui> mathijs, you could do sum . map read' . words where read' x = read x :: Float
04:13:27 <vixey> mathijs, read :: String -> Float
04:13:32 <quicksilver> mathijs: (read :: String -> Float)
04:13:32 <luqui> a bit more work than you probably had in mind
04:13:46 <mathijs> quicksilver, vixey: just found out :)
04:13:58 <quicksilver> or (sum :: [Float] -> Float)
04:14:04 <quicksilver> according to your preference ;)
04:14:04 <luqui> oh, I thought he meant just specifying part of the type
04:14:30 <luqui> or even sumline :: Float = ...  -- (I don't think this is H98)
04:14:36 <mathijs> quicksilver: but what if I wanted to make a function that would work on both integers and floats?
04:14:49 <luqui> mathijs, then don't put in any annotation
04:14:55 <luqui> and sumline already does that.
04:15:00 <quicksilver> :t sum . map read . words
04:15:02 <lambdabot> forall a. (Read a, Num a) => String -> a
04:15:03 <mathijs> then it doesn't work on floats
04:15:12 <quicksilver> it does, as long as you turn off the DMR.
04:15:18 <mathijs> DMR?
04:15:23 <quicksilver> (which is turned off for ":t" which is why it got the right answer)
04:15:29 <quicksilver> or specify the parameter
04:15:30 <luqui> > (sum . map read . words $ "1 2 3 4 5") :: Float  -- does too
04:15:32 <lambdabot>   15.0
04:15:33 <quicksilver> sumline xs = ....
04:15:47 <quicksilver> @go haskellwiki monomorphism restriction
04:15:51 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:15:51 <lambdabot> Title: Monomorphism restriction - HaskellWiki
04:16:17 <luqui> for some reason I was assuming this was in a where clause so let polymorphism would apply
04:16:26 <quicksilver> mathijs: something which "appears" to be a constant - has no syntactic formal parameters - cannot be polymorphic, in haskell98
04:17:09 <quicksilver> well, it can, but you need to specify its type.
04:17:20 <quicksilver> or, turn off the stupid feature :P
04:17:40 <luqui> which is increasingly unfortunate as pointfree style becomes more popular
04:17:51 <mathijs> well.. the thing is... if I :t sum . map read . float, it has the correct type (Num a), but :t sumline gives String -> Integer
04:18:00 <quicksilver> mathijs: I just explained that.
04:18:17 * Provenzano is now away, auto away after 15mins idle (log\on pager\on)
04:18:19 <mathijs> quicksilver: yeah, got that :)
04:18:23 <quicksilver> ;)
04:18:38 <sjanssen> Provenzano: please turn off away messages in #haskell
04:18:40 <quicksilver> Provenzano: turn of auto away messages in busy channels please.
04:18:49 <sjanssen> @quote stereo
04:18:49 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
04:18:56 <luqui> sigh
04:18:56 * quicksilver notes that the ops have now made 100% more noise than the auto-away did ;)
04:19:10 <Provenzano> sorry :|
04:19:16 <sjanssen> Provenzano: not a big deal :)
04:19:20 <ivanm> quicksilver: ummmm..... I'd say more than 100%...
04:19:24 <quicksilver> it's OK, it's easy to do especially in some clients
04:19:44 <quicksilver> ops have to be noisy though, that's how they become ops!
04:19:47 <quicksilver> #haskell is a loquacracy!
04:19:57 <sjanssen> @remember quicksilver ops have to be noisy though, that's how they become ops!
04:19:57 <lambdabot> Done.
04:20:06 <ivanm> quicksilver: ahhh
04:20:06 <sjanssen> @remember quicksilver #haskell is a loquacracy!
04:20:07 <lambdabot> I will never forget.
04:20:19 <ivanm> so a spam script will give me op privileges? :p
04:20:30 <quicksilver> not if we kick you before you out-talk us.
04:20:37 <ivanm> heh
04:20:38 <sjanssen> ivanm: or a ban, depends on how good the script is
04:20:54 <ivanm> quicksilver: so the trick is to make sure no-one else with ops privileges is around... >_>
04:20:58 <blackh> but the emphasis is undoubtedly on quantity. :)
04:20:59 <quicksilver> if the script is excellent, helps newbies and contributes to haskell research
04:21:06 <quicksilver> then sure, that will be fine.
04:21:17 <vegai> loquacracy?
04:21:24 <sjanssen> in that case, we'd probably just make the script an op
04:21:27 <ivanm> quicksilver: exactly how is a spamming script going to help newbies?
04:21:40 <ivanm> vegai: power is derived from speech ;-)
04:24:00 <vegai> yeah, I could infer that, but the word is odd. And looking it up gives hits to geek.com's one article and #haskell logs :)
04:24:10 <p_l> sjanssen: That would require quite good AI
04:24:13 <ivanm> vegai: heh
04:25:15 <ivanm> hmmmmm..... I just realised something... I've never had to write my own monad... does this mean I'm not a real Haskell programmer? :o
04:25:56 <quicksilver> vegai: I believe I coined the word.
04:26:12 <quicksilver> vegai: I hope to submit it to wiktionary using the google search as a reference.
04:26:13 <mokus> ivanm: does not having had a bar mitzvah make a 12 year old jewish boy not jewish? ;-)
04:26:15 <jesnor> is dynamic polymorphism incompatible with type classes?
04:26:19 <quicksilver> and then to wikipedia using the wiktionary.
04:26:33 <quicksilver> jesnor: what does "dynamic" mean in this sense?
04:27:12 <ivanm> mokus: depends on when a jewish boy is meant to have his bar mitzvah, and whether you're referring to jewish == person of hebrew faith, or jewish == citizen of Israel (or descendant thereof)
04:27:32 <mokus> person of modern hebrew faith, and I believe it's 13 years
04:27:43 <ivanm> quicksilver: full of energy and wanting to do stuff? ;-)
04:28:12 <ivanm> mokus: well, IIRC the bar mitzvah is the rite of passage... so not having had it makes him a jewish boy as opposed to a jewish adult male ;-)
04:28:12 <jesnor> quicksilver: lets say you have a type class "Shape a" and then a "forall a. Shape a => List a", how do you execute specialized code for different types of 'a'?
04:28:29 <BONUS> ivanm: most of the monads that aren't trivial have already been written
04:28:32 <BONUS> imho
04:28:45 <quicksilver> jesnor: by putting the 'specialised' code as methods in the class
04:28:54 <quicksilver> jesnor: (or implementing it generically but using specialised methods)
04:29:02 <jesnor> quicksilver: thats the only way?
04:29:14 <ivanm> BONUS: you mean all those apart from new ways of performing concurrency or used in a window manager? ;-)
04:29:19 <quicksilver> what other way would you imagine?
04:29:26 <quicksilver> you have to defined the specialisations somewhere...
04:29:33 <jesnor> quicksilver: well, in a subtyped language its trivial
04:29:35 <BONUS> haha well
04:29:45 <BONUS> lots of monads are just special cases of state
04:29:52 <quicksilver> jesnor: how?
04:29:59 <BONUS> or writer/reader
04:30:04 * quicksilver doesn't see how subtyping helps.
04:30:05 <ivanm> BONUS: or IO?
04:30:09 <jesnor> quicksilver: instanceof in Java for example
04:30:15 <quicksilver> BONUS: reader and writer are both special cases of state.
04:30:20 <BONUS> yes
04:30:21 <quicksilver> jesnor: that has nothing to do with subtyping.
04:30:25 <quicksilver> jesnor: that's RTTI.
04:30:38 <jesnor> quicksilver: well, its RTTI and subtyping
04:30:41 <quicksilver> RTTI is a foul desecration, but you can fake it out in haskell if you like.
04:31:03 <ivanm> what's RTTI? run-time type instantiation or something?
04:31:09 <luqui> quicksilver, really, writer is?
04:31:10 <jesnor> quicksilver: so, how would you encode such a function in Haskell without changing the type class?
04:31:17 <luqui> quicksilver, can you give an isomorphism?
04:31:38 <luqui> (my worry is that it is not lazy enough)
04:31:51 <luqui> I guess I'll just try myself
04:32:28 <mokus> luqui: let the state type be a monoid and let tell be a get/mappend/put
04:32:56 <mokus> and similar for listen
04:32:57 <luqui> mokus, right.  checking.
04:35:25 <quicksilver> modify . mappend
04:35:27 <quicksilver> indeed.
04:36:01 <quicksilver> jesnor: By adding something to the class which gives you a bit of RTTI
04:36:08 <quicksilver> jesnor: but I wouldn't do that.
04:36:19 <quicksilver> I would add whatever properties are needed to the class in the first place
04:36:24 <quicksilver> or more likely not use a class at all.
04:36:29 <quicksilver> damn I wish they weren't call classes.
04:37:06 <ivanm> quicksilver: you mean called rather than call?
04:37:13 * quicksilver nods
04:37:19 <ivanm> what's wrong with the term "class"?
04:37:23 <ivanm> isn't is a class of datatypes?
04:37:23 <quicksilver> I wish they were called FierceUglyStabbyThings
04:37:26 <ivanm> heh
04:37:33 <quicksilver> people assume it's something like class in other languages
04:37:38 <quicksilver> and totally abuse/misuse them
04:37:38 <ivanm> the opposite of monads => WarmFuzzyThings
04:37:45 <quicksilver> and then get upset that it doesn't work well
04:37:49 <ivanm> quicksilver: ahhh, you want to rename return then whilst you're at it I take it...
04:38:01 <luqui> quicksilver, mokus, http://hpaste.org/13166
04:38:09 <ivanm> quicksilver: what does RTTI stand for? run-time type something?
04:38:16 <quicksilver> ivanm: yes, although that appears to cause less trouble in practice.
04:38:19 <quicksilver> Identification.
04:38:24 <ivanm> heh
04:38:27 <quicksilver> or sometimes Information
04:38:59 <quicksilver> it's like having a laxative called "after dinner mint"
04:39:12 <quicksilver> and people being upset when they were looking for something nice to eat after dinner.
04:39:21 <quicksilver> There's nothing wrong with the laxative, it's just that's not what it's for.
04:39:22 <chessguy_work> heh
04:39:24 <ivanm> heh
04:39:26 <quicksilver> and it doesn't taste nice.
04:39:36 <Martijn> It can
04:39:58 <ivanm> @remember quicksilver [about classes having the same name as constructs in other languages] t's like having a laxative called "after dinner mint", and people being upset when they were looking for something nice to eat after dinner.
04:39:58 <lambdabot> Done.
04:40:04 <ivanm> quicksilver: you're on a roll tonight!
04:40:08 <quicksilver> thanks.
04:41:09 <luqui> class/instance  ==>  theory/model ?
04:41:16 <mokus> luqui: good point
04:41:41 <luqui> of course that arises because there is nothing stopping the last action from being put []
04:41:46 <mokus> luqui: State can't know it's whole state won't be blasted at step infinity-1
04:41:48 <mokus> right
04:41:54 <ivanm> I presume they're called "classes" because they represent a class of datatypes?
04:42:11 <Martijn> Not just datatypes, right? Types in general.
04:42:38 <luqui> I don't really consider there to be much of a difference
04:42:42 <chessguy_work> what's the difference between a datatype and a different type?
04:42:43 <luqui> maybe datatype = monomorphic?
04:42:56 <luqui> in which case classes are definitely sets of datatypes...
04:42:57 <ivanm> Martijn: I meant datatype/data structure/whatever
04:43:11 <Martijn> I thought a function is a type but not a datatype. But I might be confused, or just being overprecise.
04:43:25 <ivanm> you have a type signature....
04:43:26 <luqui> yeah that distinction is very seldom made (in our world at least)
04:43:31 <mokus> Martijn: I agree, and was about to say the same
04:43:35 <vixey> (->) is a type constructor just like Either
04:43:40 <ivanm> luqui: which world is your world?
04:43:41 <mapreduce> Martijn: Functions can perfectly well represent state.
04:43:46 <luqui> er, Haskell world?
04:44:02 <ivanm> vixey: except we can't define it ourselves (and its built into the language)?
04:44:11 <chessguy_work> Martijn, look at State -- it's just a wrapper over a function :)
04:44:16 <vixey> that's not a problem though
04:44:27 * Martijn nods.
04:44:32 <quicksilver> ivanm: yes, classes of types.
04:44:42 * luqui doeen't see the Martijn quote to which everyone is responding...
04:44:44 <quicksilver> ivanm: whereas in, say, java, a class is a class of objects
04:44:46 <mokus> how does one pattern match on a function?
04:45:02 <ivanm> quicksilver: *nod*
04:45:02 <mapreduce> > let cons a b = \first -> if (first) then a else b in ((cons 3 4) True)
04:45:03 <lambdabot>   3
04:45:08 <mapreduce> > let cons a b = \first -> if (first) then a else b in ((cons 3 4) False)
04:45:10 <lambdabot>   4
04:45:11 <ivanm> stupid Java :@
04:45:12 <quicksilver> in java a class *is* a type, more or less. An objects belong to classes.
04:45:12 <ivanm> ;-)
04:45:12 <mokus> application is the first though that comes to mind, but that seems pretty weak
04:45:14 <vixey> mokus, ($)
04:45:19 <quicksilver> whereas in haskell, types belong to classes.
04:45:27 <quicksilver> (and values belong to types)
04:45:36 <quicksilver> I mean Im' not going to pretend the two ideas are unrelated.
04:45:40 <quicksilver> Obviously there is common ground.
04:45:45 <mokus> vixey: I can't say, for example, case f of (\x->x) -> ...
04:45:48 <Martijn> if you say values belong to types, i'd say types belong to kinds, not to classes
04:45:48 <quicksilver> but there is a lot which is different, and that's the frustrating part.
04:45:49 <mapreduce> In Java, class = type is only true sometimes.
04:46:00 <quicksilver> Martijn: Classes are used as a kind of pseudo-kind
04:46:04 <mapreduce> E.g., a List<Integer>'s class is List, not List<Integer>.
04:46:15 <ivanm> mapreduce: oh? when does a java class not represent a new type of object?
04:46:29 <quicksilver> Martijn: Num a => a -> a -> a is pretty similar to a :: Num, a -> a -> a
04:46:49 <quicksilver> Martijn: there are some problems with using classes as kinds of course, but they are at the same level.
04:46:53 <luqui> mapreduce, gah!
04:46:57 <luqui> mapreduce, really?
04:46:58 <Martijn> Hmm
04:47:03 <mapreduce> ivanm: (class = type) == (type = class).  List<Integer> is a type, not a class.
04:47:21 <ivanm> ahhhhh, instantiated generics stuff
04:47:26 <mapreduce> luqui: Yes, but it doesn't cause a problem unless you're doing reflection.
04:47:30 <baaba> luqui, you can try List<Integer>.class == List<Double>.class
04:47:31 <ivanm> whereas List<v> is a class?
04:47:46 <mapreduce> baaba: That's not valid Java.
04:47:47 <quicksilver> mapreduce: yes, although I think you could follow that argument either way.
04:47:52 <mapreduce> quicksilver: sure.
04:47:59 <luqui> baaba, I'd rather not.  there doesn't appear to be a javac -e  :-)
04:48:07 <mapreduce> ivanm: No, List<v> is a type.
04:48:15 <quicksilver> mapreduce: that's probably a side effect of the particular implementation they use (generics by autoboxing and erasing to Object)
04:48:21 <ivanm> mapreduce: so List is the class?
04:48:33 <quicksilver> If you were doing a formal analysis of Java's type system
04:48:41 <baaba> er right, i guess you'd need to add .getName() or something
04:48:44 <quicksilver> I'm pretty sure it would be more convenient to call List<Integer> a class.
04:48:46 <mapreduce> ivanm: Yes.
04:48:57 <baaba> been a while since i did anything with java reflection
04:49:52 <ivanm> mapreduce: thanks! you've successfully decreased my opinion of Java to new depths! :D
04:50:00 <vixey> java reflection is awesome
04:50:05 <mapreduce> baaba: You can only do List.class, not List<Integer>.class, which is probably a good thing as they'd be identical.
04:50:48 <mathijs> quicksilver: I tried to understand about the Monomorphism restriction, I kind of see the point, but the workaround given in RWH (explicit type declaration) doesn't seem to help in this case... http://hpaste.org/13167
04:50:51 <pejo> quicksilver, perhaps one should call them typeclass and instance.
04:50:55 <mapreduce> ivanm: I have much greater depths of that.
04:51:41 <chessguy_work> i'm pretty stoked, i actually got RWH as an early Christmas present. i didn't think i'd be this excited about it
04:51:53 <ivanm> mapreduce: heh
04:52:52 <ivanm> chessguy_work: my only problem with RWH is how many places I've spotted where they obviously changed their code, but forgot to change their descriptions of what the code does :s
04:53:04 <ivanm> (e.g. using a different function or giving it a different name)
04:53:17 <chessguy_work> oh really? i haven't noticed, though i have stumbled across a few errata already
04:53:18 <quicksilver> mapreduce: why do you say that "didn't help" ?
04:53:25 <quicksilver> mathijs: why do you say that "didn't help" ?
04:53:27 <quicksilver> mapreduce: (sorry)
04:53:34 <quicksilver> mathijs: the type you got on the annotated one looks ok.
04:53:37 <ivanm> and they suddenly introduce the $ operator without stating what it does (maybe that's why that -cafe thread got started...)
04:53:54 <mathijs> chessguy_work: I'm hoping to get my copy of RWH in time for christmas, but delivery to europe would take 7 - 21 days it said. Hell, I wish my boss would be that flexible when I make estimations :)
04:54:05 <ivanm> heh
04:54:07 <chessguy_work> lol
04:54:09 <pejo> ivanm, hopefully it will be fixed for the next printing, if someone points it out.
04:54:29 <mapreduce> quicksilver: It helped a lot.
04:54:34 <ivanm> chessguy_work: what was really great was that I got my copy before Axman6, even though he ordered it before me (from the same place)! :P
04:54:37 <ivanm> (sorry Axman6)
04:54:46 <mathijs> quicksilver: yes, it just won't parse the string-of-floats thingy yet, while Float seems Num enough to me?
04:54:59 <quicksilver> mathijs: ah well, that's a different problem.
04:55:12 <quicksilver> mathijs: it has the right type, but it still won't magically look at the string to decide which type to adjust.
04:55:22 <Martijn> mathijs: we ordered through Amazon and got out copy within a few days, shipped to Den Haag
04:55:23 <luqui> what the hell, are messages being dropped?  people seem to be responding to mathijs's messages that I have never seen... two now.
04:55:27 <quicksilver> that's not what type classes do.
04:55:31 <luqui> (does IRC do that?)
04:55:44 <baaba> no, it does not
04:55:44 <quicksilver> luqui: check the logs, which are updated in real time
04:55:48 <quicksilver> compare to your own screen
04:55:51 <Zao> luqui: There's no delivery guarantee.
04:55:51 <quicksilver> see what's missing :)
04:55:56 <mathijs> quicksilver: why does it work with integers then?
04:56:08 <quicksilver> mathijs: because it defaults to Integer
04:56:32 <quicksilver> mathijs: if you give haskell a completely ambiguous type, but all the constraints are Prelude-classes (like Num and Read) then it will default
04:56:37 <quicksilver> normally to Integer, sometimes to Double
04:56:53 <satchiii> quicksilver: that is what you can change with the default keyword?
04:56:58 <quicksilver> satchiii: yes.
04:56:59 <mathijs> Martijn: well, I ordered at barnes&noble since amazon doesn't do paypal. I'm from holland too and don't use a credit-card :)  just iDeal and paypal.
04:57:16 <Martijn> mathijs: ah, that might be it then.
04:57:30 <quicksilver> mathijs: (sumline2 :: String -> Float) "1.2 2.8" should work.
04:57:38 <baaba> mathijs, not even a debit card?
04:57:44 <baaba> amazon.co.uk accepts those
04:57:52 <baaba> (like visa electron)
04:57:53 <mathijs> quicksilver: ok, so it's impossible to have a 'sumline' function that takes all Num types you throw at it?
04:58:14 <quicksilver> mathijs: incorrect. that is possible and you have one.
04:58:26 <quicksilver> mathijs: the sumline2 you wrote will take all Num types you throw at it.
04:58:33 <quicksilver> including ones which didn't even exist when you wrote the code.
04:58:50 <quicksilver> However, what it's not going to do is look at the string and decide which type to use based on the contents of the string.
04:59:01 <Martijn> mathijs: as soon as you expect sumline2 to do actual parsing you have to tell the compiler whether you want it to be parsed as an integer or float (or some other num/red type). if you don't, ghc will silently pick integer for you.
04:59:02 <quicksilver> it's going to decide the type upfront using the magic of type inference.
04:59:12 <quicksilver> and then just see whether the string matches that.
04:59:26 <mathijs> baaba: nope, I can get one, but most of the time don't need it. We have our own payment-thingy here in holland, and my regular bookstore accepts that. Furthermore most other stuff I ever ordered online use paypal. So I still don't feel the need to get a credit/debit card :)
05:00:37 <mathijs> quicksilver: so to get that working, I need to write my own numeric parser? or just use Float as default?
05:01:51 <luqui> mathijs, float as default is the easiest way to go
05:02:17 <quicksilver> mathijs: I'm afraid there is a problem here you haven't quite spotted.
05:02:27 <luqui> mathijs, to write your own parser, you'd have to return some strange type like data NumericThingy = NInteger Integer | NFloat Float | ..., which you probably don't want to do
05:02:43 <quicksilver> mathijs: such a magic 'looking at the contenst of the string and picking the right type' sumline2 would be almost useless
05:02:47 <quicksilver> what type would it have?
05:02:53 <quicksilver> in practical code, you need a particular type
05:02:57 <quicksilver> (or you need to work for all types)
05:03:08 <quicksilver> what you don't want, is to get a specific type but you don't know which.
05:03:19 <quicksilver> This is possible (it's caleld existential types) but it's not recommended.
05:03:35 <quicksilver> I'm pretty sure it's the wrong answer for this case.
05:03:52 <quicksilver> luqui's suggestion (NumericThingy) is a "lite" version of an existnetial-type-by-hand.
05:03:53 <mathijs> I get that... just trying to wrap my mind around the type system :)
05:04:07 * luqui 's use of existential types has decreased as his experience has increased
05:04:56 <mapreduce> Existentials are much more common in Scala, which surprised me.
05:05:01 <luqui> hmm, I might like to revisit quantum-arrow to see if I can do it without all that existential muck (pretty it might be).
05:06:11 <quicksilver> mapreduce: I find in haskell that existentials are code smell, but I certainly can't explain why.
05:06:17 <quicksilver> Nothing wrong with them in principle, certainly.
05:06:21 <quicksilver> I'm quite happy with the idea.
05:06:34 <quicksilver> but in practice everything seems to work out better without them.
05:07:15 <mapreduce> Like wildcards in Java.
05:07:19 <mattam> quicksilver: weak existentials are a bit weird.
05:07:26 <quicksilver> mattam: what's that?
05:08:14 <Saizan> mapreduce: but scala has subtyping, right? so isn't an existential like upcasting?
05:08:17 <mattam> Existentials that really hide their first component.
05:08:41 <quicksilver> mattam: I don't understand what you mean.
05:08:45 <mattam> As opposed to strong existentials which are just dependent sums/pairs in type theory terminology.
05:09:24 <mattam> These existentials are generative. Each time you open them they generate a new type.
05:09:35 <chessguy_work> ok folks, i'm working on a general pattern-recognition library. right now i'm just trying to get the API right. what do you think of this: http://hpaste.org/13168 ? is there some way you'd rather be able to write it?
05:10:13 <quicksilver> mattam: I'm lacking a grounding relative to which to understand your comments. The existential quantifier in intuitionistic or classic logic, is that weak or strong?
05:10:40 <mapreduce> Saizan: It probably compiles to some upcasting and downcasting at least.  I'm hazy on it as I don't use it much.
05:11:27 <Saizan> maybe the difference is about propositional and predicative existential quantifier
05:11:33 <luqui> chessguy_work, looks like Pattern a = a -> Bool
05:11:38 <luqui> chessguy_work, is that your semantic domain?
05:11:40 <mapreduce> Saizan: Ask me after TAPL :)
05:11:58 <chessguy_work> luqui, no, Pattern a will be something horribly complex
05:12:11 <luqui> chessguy_work, sure, but it's *representing* an a -> Bool, right?
05:12:12 <chessguy_work> that will be hidden from the client
05:12:22 <quicksilver> chessguy_work: as much as I can tell from that, it looks good. .+. is probably `mappend` for some Monoid instance for Pattern
05:12:42 <quicksilver> luqui: I don't believe it is, no.
05:12:45 <chessguy_work> luqui, mmm, no, not quite. more like [a] -> Bool
05:12:48 <quicksilver> luqui: it's more like [a] -> Bool
05:12:51 <chessguy_work> or [a] -> [a]
05:13:15 <luqui> hmm, I guess I don't quite follow this code then
05:13:23 <ski_> mattam : `generative' how ?
05:13:36 <mattam> quicksilver: depends of the framework. The point is that there are flavors of existentials where opening twice create two different, unconvertible types and others where they are.
05:13:42 <luqui> chessguy_work, the strings are free variables?
05:13:44 <chessguy_work> quicksilver, sure. i kind of don't like the fact that pat2 has to know the right label for the node in pat1 ("a'), but i don't know a good way to get around it
05:14:04 <luqui> chessguy_work, I'd use HOAS for the labels instead of strings
05:14:07 <chessguy_work> luqui, yeah, pat1 says "there's a square, which i'll call 'a', which is in the corner
05:14:21 <chessguy_work> luqui, HOAS?
05:14:21 <chessguy_work> \
05:14:30 <luqui> so something like:  exists s $ \a -> [a `is` corner]
05:14:40 <luqui> superfluous s
05:15:05 <chessguy_work> i have no idea what that means
05:15:22 <luqui> exists :: (Label -> Pattern a) -> Pattern a
05:15:29 <luqui> or some such
05:15:39 <luqui> which allocates a label and passes it to the given function
05:15:42 <vixey> what
05:16:25 <luqui> and it looks like your semantic domain is Set a -> Bool.
05:16:47 <luqui> in that case, the interface should be consistent with that, and it will be nice to use.
05:16:51 <chessguy_work> ( quicksilver: does my last commnt to you make sense?)
05:17:10 <chessguy_work> luqui, yes, Set a -> Bool looks right
05:17:23 <chessguy_work> luqui, i'm still not quite sure i'm getting your consistency argument though
05:17:39 <chessguy_work> luqui, though i think you're on to something
05:17:56 <luqui> just remember when you are coming up with the interface that this *is* a Set a -> Bool; what kinds of things would you want to do to that?
05:18:24 <ski_> mattam : how would the latter case work ?
05:18:45 <luqui> however, the "label knowing" problem you mentioned is solvable, unfortunately it is inconsistent with Set a -> Bool :-(
05:19:00 <chessguy_work> luqui, why is it inconsistent?
05:19:11 <luqui> oh no, it's fine!
05:19:12 <ski_> mattam : would every opening of a value of the same existential type give you the same type ?
05:19:25 <ski_> s/a value/values/
05:19:26 <luqui> chessguy_work, pat1 :: Label -> Pattern Square
05:19:30 <chessguy_work> luqui, Set a -> Bool is actually slightly less than what i'm shooting for. it's closer to Set a -> Set a
05:19:32 <mattam> ski_: of the same value.
05:19:33 <luqui> so then you pass it the label you want to use
05:19:44 <luqui> chessguy_work, how so?
05:19:52 <ski_> mattam : how can you generally know whether you're opening the same value ?
05:20:09 <luqui> chessguy_work, what do you want to do that needs the latter repr?
05:20:12 <chessguy_work> luqui, i want to be able to 'select' certain elements have have them bound to the labels
05:20:27 <chessguy_work> luqui, sort of like clustering in regexes
05:20:31 <chessguy_work> err, capturing
05:20:56 <vixey> why would you open an sum twice?
05:21:12 <luqui> chessguy_work, hmmm... right, because Label is not a well-defined thing in that semantics
05:21:15 <mattam> Well, I think I meant provably equal instead. Maybe I said something wrong.
05:21:33 <luqui> chessguy_work, though I don't think it is in Set a -> Set a either
05:22:09 <chessguy_work> no?
05:22:14 <vixey> mattam, it is something different to proj2 being injective?
05:22:19 <nagnals> how nay years is an undergraduate degree? 2 or 3? or 2.5?
05:22:39 <nagnals> and masters is 5? and then PhD is what, 2-3 years of research on top of that?
05:22:41 <p_l> nagnals: Depends on country
05:22:43 <luqui> chessguy_work, okay, so it's like logic programming.  not only do you want to find whether it matches, you want to say how it matches
05:22:43 <lilac> nagnals: in which country?
05:22:51 <chessguy_work> exactly
05:23:01 <byorgey> nagnals: depends.  in US undergrad is usually 4 years.
05:23:02 <lilac> nagnals: also, what degree, and at which university? :)
05:23:03 <nagnals> how many years is an undergraduate degree? 2 or 3? or 2.5? talking USA first, englan second and australia 3rd
05:23:19 <nagnals> so graduate is what?
05:23:26 <luqui> chessguy_work, thinking back to my logic days about the semantics of WFFs...
05:23:30 <lilac> nagnals: in the UK, undergrad degrees are usually 3 or 4 years; 3 is more common.
05:23:37 <p_l> nagnals: USA it's typically 3yrs for BSc, then you get postgraduate stuff (Masters and later)
05:24:12 <p_l> nagnals: In UK, undergrad is 3yrs in England&Wales, 4yrs in Scotland (where undergraduate also encompasses Masters)
05:24:19 <nagnals> i see
05:24:24 <ski_> (luqui : may i inquire about what you're talking about ?)
05:24:28 <nagnals> but if you want a job at say Google, is undergraduate enough then?
05:24:41 <quicksilver> mattam: hmm, I would echo ski's question.
05:24:49 <nagnals> undergraduate is better than it sounds then? masters is like 5 years right?
05:24:52 <quicksilver> mattam: "logically" when you open an existentially type, the value is local to that scope.
05:24:56 <luqui> ski_, chessguy_work is designing a pattern matching library (http://hpaste.org/13168), and we're trying to figure out a semantics that matches what he wants
05:24:57 <p_l> Courses that give you for example MEng title are 5yrs
05:25:06 <BeelsebobWork> p_l: undergrad doesn't encompas masters in scotland
05:25:11 <quicksilver> since it's local, it's not sensible to compare it to other types in other local scopes.
05:25:12 <BeelsebobWork> it's just an honors degree means something there
05:25:29 <BeelsebobWork> honors means "got a first or 2:1 in first 3 years, and carried on to do the honors year"
05:25:31 <quicksilver> I wasn't aware of any other kind of way you could give an meaning to existential in a logic.
05:25:47 <Saizan> aren't strong existentials a bit like open gadts? so they carry the type inside them?
05:25:48 <luqui> quicksilver, the problem is that there are free variables...
05:25:54 <mattam> vixey: hmm... that seems like it. Weak existentials wouldn't allow you to prove that... or even for first projections. Having two values of type "exists x : A, B x" equal wouldn't give you the fact that the first projections are equal.
05:25:54 <p_l> BeelsebobWork: Actually everywhere I see written "Master's Degree is an undergraduate degree in Scottish Education system"
05:26:11 * p_l is currently doing his undergrad. in Scotland
05:26:20 <BeelsebobWork> p_l: both my sisters got BScs from scottish unis
05:26:35 <nagnals> rhickey: cant you add "sum" to clojure? (reduce + coll)
05:26:37 <mattam> quicksilver: it is if you see existentials as pairs and not black boxes with pack/unpack.
05:26:38 <BeelsebobWork> (one subsequently a PhD too, but that's beside the point)
05:27:04 <ski_> (luqui,chessguy_work : `(.+.)' being a lifted disjunction ?)
05:27:18 <nagnals> but undergraduate sounds demeaning and its 4-5 fucking years
05:27:18 <chessguy_work> uh...
05:27:19 <mattam> so that would be the intuitionistic/classical distinction.
05:27:40 <chessguy_work> ski_, i've never taken a logic course. be gentle
05:28:00 <p_l> BeelsebobWork: All universities in Scotland I applied for informed me that Masters is undergraduate here. It's mostly because with Honours you can go directly to PhD
05:28:00 <luqui> okay okay... Set a -> Bool = Set (Set a) = (a -> Bool) -> Bool ...
05:28:19 <nagnals> or belittling
05:28:19 <luqui> I still think it's doable with this simple semantics
05:28:21 <BeelsebobWork> p_l: yeh, I went straight from a BEng in England into my PhD too though
05:28:22 <ski_> chessguy_work : sorry, i just meant that `p0 .+. p1' succeeds matching something whenever `p0' *or* `p1' succeeds matching that thing
05:28:24 <p_l> nagnals: If you skip Honours you get 3 years in scotland
05:28:32 <quicksilver> mattam: I see all connectives as being defined by their laws.
05:28:35 <BeelsebobWork> (a 3 year Honors BEng)
05:28:39 <quicksilver> mattam: that's what a logic is, in a sense.
05:28:42 <chessguy_work> ski_ no, they both match
05:28:50 * p_l has 5 year BSci CS&AI
05:29:08 <chessguy_work> ski_, "a" in pat2 is the same "a" as in pat1
05:29:13 * cjb has 3 year BSc. (Hons)
05:29:17 <ski_> chessguy_work : oh .. mhm
05:29:30 <p_l> the MEng from Strathclyde seemed more interesting, but I wouldn't make it
05:29:31 <BeelsebobWork> p_l: it may be that some scottish unis have kinda gone "you know what, we're offering much longer, higher quality degrees called BScs atm, why don't we call them Masters', seeing as that's what they really are in the rest of the world"
05:29:35 * lilac has a 3 year MA (Hons)
05:29:51 <chessguy_work> ski_, but i'd like for pat2 to not have to "know" the name of "a" in pat1 of course
05:29:51 <BeelsebobWork> how did we start a letter quoting match?
05:30:01 * BeelsebobWork ponders if his Eiboracum counts :P
05:30:06 * p_l thinks of switching to japanese 4y BSci :D
05:30:11 <BeelsebobWork> (or however the shit you spell York in latin)
05:30:55 <mattam> quicksilver: then you should look at how existentials are defined in type theory. It's not pack/unpack but dependent pairs and I think they have different properties than the usual encoding of existentials.
05:31:16 <luqui> chessguy: maybe your domain is search functions: (a -> Bool) -> Maybe a
05:31:37 <luqui> chessguy_work, have you seen Data.Searchable?  If that interface were expanded, would you be able to do what you want
05:31:39 <luqui> ?
05:31:44 <chessguy_work> luqui, but we need room for (a -> a -> Bool)
05:31:49 <quicksilver> mattam: probably I should yes, but I was hoping you could explain enough for me to understand your point.
05:31:53 <luqui> (I don't suggest you use Data.Searchable itself, just its interface)
05:31:58 <quicksilver> mattam: you suggested that weak existentials were weird.
05:32:09 <luqui> chessguy_work, exists (\a -> exists (\b -> something a b))
05:32:22 <quicksilver> as someone with a logical background, I feel taht the existential we use in haskell ... the intuitionistic existential
05:32:25 <quicksilver> is not remotely weird.
05:32:37 <quicksilver> I think it's extremely natural, and follows all kinds of natural dualities.
05:32:37 <vixey> it is actually an existential ??
05:32:42 <quicksilver> so I'm not sure what's wrong with it :)
05:32:43 <vixey> but you use forall to define it
05:32:46 <p_l> BeelsebobWork: Well, a decade ago you barely could get a Bachelor's in Poland. Because every course ended with Master's :D
05:32:57 <BeelsebobWork> heh, fun
05:33:00 <chessguy_work> luqui, where is Data.Searchable?
05:33:07 <luqui> chessguy_work, http://hackage.haskell.org/packages/archive/infinite-search/0.11/doc/html/Data-Searchable.html
05:33:16 <quicksilver> vixey: right, because existential is dual to forall
05:33:29 <ski_> mattam : i'm not sure that would purely be a `intuitionistic/classical distinction'
05:33:29 <quicksilver> vixey: so you cheat, and define the dual (the type of the constructor)
05:33:35 <luqui> chessguy_work, it's Martin Escardo's compact search combinators.
05:33:40 <vixey> I thought  ~(forall a, P a) = exists, ~(P a)
05:33:42 <quicksilver> something with a universal constructor has an existential destructor.
05:33:44 <mattam> ski_: me neither, but it seems related.
05:33:53 <luqui> vixey, classically.
05:34:10 <quicksilver> there is a duality between forall and exists even in intuitionistic logic though.
05:34:16 <quicksilver> you don't need "NOT" to seei t.
05:34:20 <luqui> it's not as pretty though...
05:34:31 <quicksilver> matter of opinion, I suppose.
05:34:34 <quicksilver> I think it's prettier :)
05:34:37 <luqui> NO IT IS ABSOLUTE FACT
05:34:38 <quicksilver> but I tend to think NOT is ugly.
05:35:01 <chessguy_work> luqui, hmm, i have not seen this.
05:35:57 <vixey> but (forall a, ~P a) <-> ~exists a, (P a) in INT
05:35:59 <luqui> chessguy_work, it's a very pretty and powerful interface, you might want to consider something like it.  You'll have to restrict some of the types to make it efficient though, I think/
05:36:08 <ski_> mattam : i think this might be related to the `blind' vs. `constructive' existential distinction of Japaridze
05:36:16 <mattam> quicksilver: ok. Now suppose you represent an object of type "exists x : A, B x" by a pair (t : A, p : B t). Then you can define the first and second projections [proj1 : (exists x : A, B x) -> A]. Can you do that with Haskell's existentials?
05:36:44 <vixey> what is the duality
05:36:46 <vixey> ?
05:37:00 <chessguy_work> luqui, cool. i'll take a look
05:37:02 <vixey> I think I saw it in linear logic..
05:37:17 <mattam> ski_: indeed, it's a matter of opacity and constructivity.
05:37:18 <luqui> now linear logic... *that* is beautiful
05:37:20 <oklofok> all truths have a co-truth when you swap all exists and foralls and ands and ors and such
05:37:22 <ski_> vixey : which duality ?
05:37:38 <vixey> between forall and exists
05:37:55 <ski_> mattam : also, i suspect this is related to the distinction between parametric universal and dependent ditto
05:38:01 <luqui> oklofok, orly?  sounds cool.  what is the meaning of cotruth?
05:38:17 <oklofok> luqui: just that a truth stays a truth when you swap them.
05:38:19 <mattam> "dependent universal"?
05:38:31 <ski_> (n : Nat) -> P n
05:38:35 <oklofok> meaning you always find a proof for two things when you discover one
05:38:59 <luqui> oklofok, exists x. (x = 0)  <-> forall x. (x = 0) ??
05:39:05 <luqui> or does equality not count in this duality?
05:39:07 <ski_> mattam : a value in that type may examine the `n' .. but haskell functions may not examine the types they are polymorphic in
05:39:17 <oklofok> luqui: you need to negate everything
05:39:18 <quicksilver> vixey: forall a (P(a) -> c) <=> (exists a . P(a)) -> c
05:39:30 <oklofok> exists x = 0 <-> not forall x!= 0
05:39:32 <mapreduce> forall x. (x /= 0) ?
05:39:36 <quicksilver> vixey: basically the 'contravariance' - being on the left of the -> - can turn a forall into an exists.
05:39:45 <luqui> oklofok, oh, you just mean exists x. (x = 0) <-> ~~exists x. (x = 0) <-> ~forall x. (x /= 0)
05:39:51 <quicksilver> vixey: sorry, that only goes one way. => not <=>
05:39:52 <oklofok> luqui: no i don't mean that.
05:39:57 <oklofok> well, it follows from that.
05:39:59 <mattam> I'm not sure if that's relevant, the distinction is also important when A is Type and you don't use the dependent arrow.
05:40:10 <oklofok> but it's a more deep thing, you can convert any proposition like that
05:40:10 <mattam> At least not the "dependent on term" part.
05:40:12 <ski_> mattam : one could imagine a variant of `(n : Nat) -> P n' that would not allow full examination on `n'  (i'm not sure whether this would work out, note)
05:40:26 <oklofok> or well i don't know if predicate logic calls them propositions, but anyway
05:40:29 <oklofok> sentences
05:40:30 <luqui> oklofok, right, you're just talking about the duals under negation
05:40:35 <oklofok> luqui: yes
05:40:56 <mattam> ski_: Yeah, that exists too, it's implemented in the "Implicit alculus of constructions.
05:41:00 <oklofok> called them cotruths, because i'm assuming it's related to the thing category theory uses co- for ;)
05:41:02 <chrisdone> is it possible to have one module A which imports another module X qualified and exports it qualified as Y, such that some other module F can import A and has the exports from X as Y.foo?
05:41:05 <quicksilver> mattam: ah, yes, that's the constructive existential question
05:41:17 <quicksilver> mattam: does (exists x. P (x)) actually allow me to find that 'x' ?
05:41:22 <quicksilver> (since I know it exists)
05:41:25 <mattam> Yes.
05:41:36 <quicksilver> this is an interesting point but I'm not sure it's relevant to haskell
05:41:41 <quicksilver> types aren't terms anyway, in haskell
05:41:52 <quicksilver> so we certainly can't find 'A', it's a type.
05:41:53 <mattam> And of course taking the projection two times give you the same object.
05:42:18 <mattam> Suppose it's exists A : *, ...
05:42:19 <vixey> with:  data Ex where Exists :: x -> Ex
05:43:01 <vixey> rather than:  data Ex (P :: T -> *) where Exists :: (x :: T) -> P x -> Ex
05:43:28 * luqui writes an equivalent type:  data Ex = Ex Absurd ; data Absurd
05:43:34 <ski_> s/-> Ex/-> Ex P/
05:44:24 <vixey> luqui, oh, hm...a
05:44:43 <maltem> 'day all... Are there any good or thorough (or better even, good *and* thorough) descriptions of ghc memory profiling? (Short of the RWH chapter, which is a start)
05:44:59 <vixey> how do you do exists in haskell then?
05:45:01 <quicksilver> maltem: it's pretty self explanatory in my opinion.
05:45:08 <quicksilver> maltem: have you read the chapters in the GHC manual?
05:45:21 <opqdonut> yeah the GHC manual's profiling section is really good
05:45:31 <luqui> vixey, there isn't a most general exists.
05:45:41 <opqdonut> and #haskell is a good place to ask when you have the data and a specific question ;)
05:45:44 <maltem> quicksilver: Well I'm specifically looking for how to interpret things like MAIN, BLACKHOLE, ...
05:45:54 <opqdonut> yeah the manual has those
05:45:56 <opqdonut> CAF etc
05:45:58 <maltem> oh
05:45:59 <luqui> vixey, but existential types are done with GADTs (or CPS and higher-rank types), they just usually have more context to go with them than your Ex
05:46:16 <maltem> opqdonut: so I'll try and look again
05:46:42 <quicksilver> maltem: try all the different types
05:46:51 <quicksilver> you get interesting different partitionings
05:47:18 <quicksilver> I found -hd and -hc the most useful
05:47:23 <quicksilver> but all were interesting
05:47:30 <quicksilver> increase the length of cost centre paths with -L
05:47:35 <mattam> luqui: so you can't have an existential type constructor, but particular existentials coded by [forall a. ... a .. ] inside data decls?
05:48:10 <luqui> mattam, data Foo = forall a. Constr (... a ...)
05:48:17 <luqui> though I generally perfer the cps style
05:48:23 <luqui> (forall a. ... a ... -> r) -> r
05:48:27 <maltem> quicksilver: will -L give me more details if I were lacking them before?
05:48:38 <quicksilver> maltem: it just makes the cost-centre stack longer
05:48:45 <quicksilver> foo/bar/baz/bam/bumble
05:48:46 <quicksilver> instead of
05:48:48 <quicksilver> foo/bar/...
05:48:57 <quicksilver> maltem: but, what details were you lacking ;)
05:49:14 <quicksilver> -hd is nice and easy to visualise because it fingers the data constructors.
05:49:29 <quicksilver> If you use specific data types in specific places that gives a good clue.
05:49:37 <maltem> quicksilver: I got one huge area labelled MAIN
05:49:50 <maltem> quicksilver: and didn't really know what to interpret into it
05:49:57 <quicksilver> sounds like you used -hc
05:50:02 <chessguy_work> luqui, this (Data.Searchable) seems really interesting, but i suspect that it would have to be extended quite a bit for what i want
05:50:04 <quicksilver> and didn't add any cost centres.
05:50:20 <maltem> quicksilver: hm that was with -auto-all
05:50:25 <quicksilver> odd.
05:50:30 <quicksilver> try one of the other options then
05:50:33 <luqui> chessguy_work, probably, it's a weak library as it stands.
05:50:33 <quicksilver> -hd or -hy
05:50:36 <quicksilver> or -hr
05:50:40 <ski_>   data Some p = forall x. MkS (p x)
05:50:42 <maltem> yeah I'll check what options exactly gave me that graph
05:50:56 <luqui> chessguy_work, but the idea of "searchable sets" might be a good basis
05:51:13 <chessguy_work> indeed
05:51:39 <luqui> chessguy_work, I think my main point is that you should do away with labels and instead encode the information you want with monadic returns for example...
05:51:56 <luqui> and quantifiers and whatnot
05:51:57 <chessguy_work> monadic returns?
05:52:09 <luqui> nevermind, that actually doesn't work in this case
05:52:13 <slangan> monads are so weird. I just cant grab them. i know why i want them, i can mark functions as ugly impures tuff, so the io-monad makes sense but stuff like the state-monad? i dont get what it does. it doesnt let me do any x = x+1 anyway so do i ever really need the state monad? is there soemthing that cant be done without it?
05:52:35 <luqui> but what I meant was instead of getting a list of bindings back, you would return something like a Pattern (Square,Square)...
05:52:39 <luqui> oh!
05:52:52 <mapreduce> slangan: What would be annoying about using a function that takes in a seed and gives you a random number?
05:53:01 <luqui> what about:  "Pattern a b" means "finding a b inside an a"....
05:53:03 <mattam> luqui: ok. So that's weak existentials, which is basically a Church encoding. If you use that you can't define a second projection of type [forall (e : exists x : A, P x), P (proj1 e)] (in e.g. Coq) as that would make the first component escape. It's not that weird after all :)
05:53:10 <mapreduce> psuedorandom
05:53:45 <Saizan> slangan: the State monad is not a primitive like the IO-monad, it's implemented in pure haskell
05:53:56 <chessguy_work> luqui, so in this case, b would be Square, and a would be...Board?
05:54:02 <luqui> mattam, makes lots of sense to me :-)
05:54:05 <ski_> slangan : you don't "need" any monad .. they just make thing nicer in that they hide detail .. like other abstractions
05:54:14 <luqui> chessguy_work, or maybe b would be (Square,Square) and a would be Set Square... or something
05:54:21 <luqui> though maybe it's "finding a b in a set of as"
05:54:22 <luqui> or..
05:54:22 <luqui> hmm
05:54:24 <Saizan> slangan: so, it's just a convenient way to thread the state parameter around
05:54:27 <luqui> I'm just trying to make it a functor.
05:54:42 <Baughn> slangan: ..well, except IO. You do need IO.
05:55:18 <Baughn> slangan: But monads bundle a very small amount of required structure with a large library of functions that work when you have that structure. It's just convenient.
05:55:18 <mattam> luqui: me too. Thanks for the refreshment! Now what I meant by generative is that if you want to add these existentials and program in direct style, you have to generate a type at each unpack.
05:55:50 <mattam> /a type/a fresh type variable/
05:56:04 <luqui> chessguy_work, that's not semantically meaningful
05:56:08 <luqui> though
05:56:20 <maltem> quicksilver: ok, it was -auto-all and -hc, I get 8 areas, one of which (MAIN) is practically everything. -hd gives me indeed a rather evenly distributed plot, but I'm a little stuck at the compiler-generated closure names
05:56:52 <luqui> chessguy_work, do you have an email address?  this is very interesting and I'd like to give it some more thought and get back to you.   (Not that you'll necessarily be able to use what I come up with, this is just a cool problem)
05:57:03 <luqui> (hah, "do you have an email address?")
05:57:04 <chessguy_work> luqui, sure, i'll PM you
05:57:25 <chessguy_work> sent
05:58:07 <luqui> I'm into programming poker related things, and I've always wanted a library like this :-)
05:58:09 <ski_> slangan : <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> may perhaps clarify how monads often capture common "patterns" in code, abstracting them so you don't have as much repetition and not as much room for making stupid mistakes
05:58:17 <luqui> for declaratively specifying the types of hands
05:58:28 <chessguy_work> luqui, yeah, i want it for chess/go
05:58:40 <chessguy_work> luqui, but i'm sure it's more generally useful
05:59:29 <quicksilver> maltem: try the caf option to -prof as well
06:00:27 <Saizan> maltem: i'd also try -fforce-recomp
06:00:50 <maltem> Saizan: oh that may be catch :)
06:01:14 * maltem goes further experimenting
06:01:26 <fasta> Did anyone modify Emacs such that it correctly highlight the literate part of the document and the non-literate part? E.g. with mmm-mode?
06:06:05 <chessguy_work> luqui, smallcheck has an interesting approach, too: http://www-users.cs.york.ac.uk/~mfn/sparsecheck/
06:06:14 <chessguy_work> err, s/small/sparse/
06:09:42 <maltem> Saizan: so, d'oh. I was adding cost centres to the executable, but forgot to compile the library with the same option :-/
06:10:00 <maltem> but, further questions:
06:11:30 <maltem> 1) What to do if the heap profile doesn't show me the full names of cost centres? as in, "mkProcess/mkAutomaton..." (three meaningful dots...)
06:13:28 <maltem> 2) opqdonut: could you please point me to where the GHC manual talks about MAIN and BLACKHOLE? I've /really/ looked for it.
06:14:12 * osfameron read the RWH section on using typeclasses to overload integers to make parse trees... that's as evil as abusing Overload in Perl :-)
06:16:41 <maltem> 3) I got a strange type in an -hy profile called stg_ap_2_udp_info, now where would I go to find out about it? (It's nowhere in this project's source code)
06:18:48 <slangan> so haskell doesnt have exceptions like for example java at all? only Maybe instead?
06:19:36 <slangan> what if a function-call could cause several different exceptions? or they cant? IO-monad can only cause one type of error? what if it causes both file-not-exist-error and out-of-memory-error?
06:19:56 <maltem> slangan: yes there's two exception mechanisms: error and Control.Exception
06:20:28 <chessguy_work> slangan, http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
06:21:23 <maltem> yeah that blog article is a good read. just scratch the "these many ways are so confusing" part, and you have a very informative summary
06:21:33 <chessguy_work> haha
06:25:29 <enticingjelly> real life haskell came in the mail today
06:25:39 <vixey> hehe
06:25:52 <enticingjelly> awesome. didn't have a chance to take a look into it, yet. happy anyway %)
06:27:15 <slangan> im using Clojure a lot(functional-oriented lisp) which doesnt use monads but Java mindfucking donkey-exceptions
06:27:35 <slangan> but to use Maybes with that id have to rewrite it all
06:28:11 <slangan> also Maybe is bad if you can have several exceptions and just want to catch one right? or catch several and do specific stuff for each
06:28:15 <mapreduce> slangan: You should be able to use Maybes reasonably in clojure.
06:28:35 <mapreduce> Scala has Option (same thing, different name) and it works well.
06:28:42 <BeelsebobWork> wow, that email from Henrik is gonna take some replying to
06:28:53 <mapreduce> Except clojure is untyped, so you get the usual difficulties of that.
06:29:30 <byorgey_> slangan: yeah, if you want several different kinds of exceptions and want to handle them differently, Maybe is the wrong abstraction.
06:29:32 * tibbe just received his copy of Real World Haskell
06:29:49 <byorgey_> slangan: but Haskell has that sort of thing too.  E.g. the Error monad, exceptions, ...
06:30:06 <mapreduce> slangan: 'Either' is closer for exception-like tasks.
06:31:04 <chessguy_work> luqui, just noticed this on wadler's blog: http://wadler.blogspot.com/2008/12/type-safe-pattern-combinators.html
06:32:19 <luqui> chessguy_work, yeah... I think that's a different kind of pattern though
06:32:34 <luqui> I skimmed that paper
06:32:39 <luqui> maybe it would do the trick...
06:33:47 <quicksilver> chessguy_work: wadler++
06:37:15 <pejo> Apparently the results of RAE 2008 are out as well. http://homepages.inf.ed.ac.uk/mfourman/blogs/news/
06:41:23 <goog> Hey People! When you have a class AdvancedSearchHandler - how do you call the file you save it in?
06:41:56 <scook0> what language are you using?
06:43:44 * byorgey calls it 'Steve'.  That, or 'AdvancedSearchHandler.hs'.
06:44:29 <luqui> we don't "call" files, we apply them.  er...
06:46:33 <goog> i talk code in general. i like to hear how people in different languages do things.
06:47:24 <ksf> haskell programmers tend to append a .hs or .lhs, c programmers a .c, .h or even .i, c++ programmer don't know what they're supposed to do, scheme tends to have .scm...
06:47:52 <goog> ksf: i was mainly interested to see how people deal with uppercase chars.
06:48:00 <goog> so far we never used uppercase in filenames.
06:48:01 <ksf> keep them.
06:48:19 <goog> but advancedserchhandler.xyz is hard to read
06:48:52 <goog> on the other hand, uppercase chars could lead to files that differ only by case.
06:48:56 <ksf> it's either advanced_search_handler, AdvancedSearchHandler or advancedSearchHandler.
06:49:05 <ksf> ...and how's that a problem?
06:49:42 <EvilTerran> goog, the convention in haskell is to follow what the standard does and use CamelCase in programs;  that usually extends to filenames too, in my experience
06:49:54 <ksf> ksf@solaris foo % touch foo
06:49:54 <ksf> ksf@solaris foo % touch Foo
06:49:54 <ksf> ksf@solaris foo % ls
06:49:54 <ksf> Foo  foo
06:50:08 <luqui> more interestingly for the language geek, perhaps, is that AdvancedSearchHandler would never ever be a class in Haskell :-)
06:50:09 <goog> ksf: well, i wonder if i change our current convention "advanced_search_handler.xyz" to "AdvancedSearchHandler.xyz"
06:50:29 <ksf> ghc will have some requirements to locate files, too.
06:50:32 <goog> EvilTerran: CamelCase?
06:50:47 <quicksilver> ksf: it's a problem on at least two other popular operating systems, unfortunately.
06:51:05 <quicksilver> goog: I would keep the case in the name, if that's the convention you normally use.
06:51:17 <quicksilver> it's easier to read if ou use the same convention everywhere.
06:51:24 <EvilTerran> goog, WordsWrittenWithHumps :)
06:51:30 <ksf> ksf@solaris foo % touch foo
06:51:30 <ksf> ksf@solaris foo % touch Foo
06:51:30 <ksf> ksf@solaris foo % ls
06:51:30 <ksf> Foo  foo
06:51:41 <ksf> ...now that's not on a reisefs, but ntfs partition.
06:51:55 <luqui> woah...
06:51:57 <quicksilver> ksf: it wasn't necessary to paste that to make your point.
06:52:48 <quicksilver> You could have just said "NTFS has case sensitivity". However, FAT32 doesn't, and HFS+ is normally used with it turned off.
06:52:54 <quicksilver> So, it's a practive problem.
06:52:55 <luqui> look who is suddenly a paste nazi...  fine, have your way, HITLER
06:52:56 <quicksilver> practical.
06:53:09 <ksf> well, the channel seemed to be silent enough...
06:53:15 * quicksilver peers doubtfuly at luqui 
06:53:19 <luqui> =)
06:53:40 <EvilTerran> goog, bear in mind that in haskell, module names (as used in "module Foo" declerations) must start with a capital letter, and a file's name tends to be the same case as the module it contains so ghc can find it
06:53:56 <EvilTerran> so haskell folks will tend to use CamelCase for their filenameds
06:54:09 <idnar> NTFS has case sensitivity, but most of the Windows APIs can't deal with it
06:55:38 <byorgey> quicksilver: heh, for a minute I thought 'practive' was some fancy word I didn't know.
06:55:53 <ksf> you shouldn't come across files differing only by case, anyway.
06:56:03 <pejo> idnar, it doesn't really matter, HFS+ is normally just case-preserving. If you take a look at what people bring to ICFP there's plenty of macs.
06:56:11 <goog> EvilTerran: i think we will change the convention. i see zend framework also uses uppercase filenames. i often look at what zend is doing codewise. (the makers of php)
06:56:48 <ksf> OMG MY MACHINE IS SO DEAF I HAVE TO SHOUT AT IT
06:57:08 <quicksilver> I think files differing by case is probably a bit confusing even on a FS which supports it.
06:57:11 <ksf> ...reminds me of DOS.
06:57:25 <quicksilver> Do you really need 'ToDo.txt' and 'TODO.txt' to be in the same directory? ;)
06:57:43 <vixey> yes
06:57:48 <ksf> nah, I only got /home/ksf/todo
06:57:59 <quicksilver> pejo: case preserving causes very painful interactions which repositories (VCSes and so on)
06:58:16 * byorgey keeps sixteen todo files, with the relative priority of the tasks in each encoded in binary with the case of the letters in 'todo'
06:58:17 <quicksilver> pejo: renaming a file from XYZ to xyz in the remote repo is very confusing
06:58:37 <quicksilver> (because the local tools keep checking, and saying "It's already here with that name!")
06:59:09 <goog> quicksilver: so how do you deal with cases? no uppercase at all?
06:59:50 <quicksilver> goog: No, I follow the local convention.
07:00:07 <quicksilver> If I had a module called FooBar, I'd put it in a file called FooBar.{hs,c,c++,pm}
07:00:46 <goog> quicksilver: ok
07:00:58 <goog> looks like everybody uses upper/lower in filenames.
07:01:16 <pejo> byorgey, how's that working out for you?
07:01:39 * ksf sometimes uses foo.hs for the Main module of an executable called "foo", though.
07:01:46 <pejo> quicksilver, yes, I'm aware of it. There's parts of ghc that I can't check out from scratch.
07:01:49 <quicksilver> ksf: yeah, me too.
07:02:02 <byorgey> pejo: on a scale of good to GOOD, I'd say about GoOD
07:02:22 <p_l> quicksilver: Imagine how confusing it is for windows apps when you disable case coercion...
07:02:44 <ksf> I've seen mono apps fail because of that...
07:02:58 <EvilTerran> ksf, i do that, too; i figure the filename currently only really matters if ghc has to be able to find the file
07:03:11 <EvilTerran> ... based on the module name, and it doesn't for the Main one
07:03:22 <p_l> ksf: Imagine what happens when someone coded all device paths in lowercase and you suddenly disable case translation....
07:03:56 <quicksilver> p_l: trying to imagine that requires empathising with a windows app.
07:04:02 <quicksilver> p_l: I'm not paid enough for that :)
07:04:37 <p_l> quicksilver: emphatise with poor dev who suddenly finds half of windows ecosystem failing on the machine :D
07:05:38 <ksf> I'd feel happy for them, as I did as my private admin told me he's grateful to have to fix a _real_ windows problem (messed up bluetooth drivers) instead of explaining how to read emails with outlook.
07:08:04 <Holle_> how do i get the most common type of a function without using :t
07:08:54 <byorgey> Holle_: why don't you want to use :t ?
07:09:20 <ksf> Holle_, exactly as :t does it ;)
07:09:34 <Holle_> and how :t works?
07:10:24 <quicksilver> by the magic of type inference.
07:10:39 <quicksilver> are you saying you want to get the type of something from inside a program?
07:10:56 <byorgey> Holle_: there are a lot of possible answers to your questions, depending on what you want to know.  Can you explain a bit better what you are asking, and why?
07:12:04 <Holle_> i've got a function g f = foldr ((:).f) [] and i have to find the most common type of this function, step by step.
07:12:27 <ksf> http://darcs.haskell.org/ghc/compiler/ghci/InteractiveUI.hs line 1207
07:12:59 <BMeph> @pl g f = foldr ((:).f) []
07:13:00 <lambdabot> g = flip foldr [] . ((:) .)
07:13:27 <vixey> ksf, what about it?
07:13:41 <ksf> that's how ghci queries the ghc lib for types.
07:13:58 <byorgey> Holle_: ah, ok.  Is this for a class?
07:14:05 <vixey> Holle_, (most general?)
07:14:12 <Holle_> not for a class
07:14:34 <Holle_> g :: (a -> b) -> [a] -> [b] i have to build
07:15:02 <Axman6> @instances Functor
07:15:03 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:15:35 <byorgey> Holle_: ok, well, first, since   g f = something,  we know   g is a function.  let's say  g :: d -> e, and then we know  f :: d, and foldr ((:).f) [] :: e.  does that make sense?
07:16:25 <byorgey> then you would look at the type of foldr, and wee what that tells you about the type of ((:).f), and what it tells you about the type e.
07:17:06 <byorgey> then since you know the type of ((:).f), you can use the types of (.) and (:) to tell you about the type of f...
07:17:09 <byorgey> and so on.
07:17:17 <quicksilver> and don't forget you know the type of [] ;)
07:17:44 <byorgey> at each step you can make up new type variables as you need, and look at each piece to give you some constraints for those type variables
07:18:25 <byorgey> by 'constraints' I mean 'equalities relating different type variables', such as  a = b -> c
07:18:31 <byorgey> am I making any sense?
07:19:01 <Holle_> i'll try. one moment.
07:19:17 <vixey> Holle_, did you mean most general?
07:19:17 <ksf> yes, but I've never before regarded every type that differs from "a -> b" as just less general.
07:19:28 <Holle_> yes
07:19:42 <vixey> Holle_, Have you seen the first order unification algorithm before
07:19:44 <ksf> ...or more constrained, or rather spelled out.
07:19:55 <Holle_> no
07:20:17 <vixey> Holle_, it's pretty essential, that FOU gives and MGU is why what byorgey described gives the most general type
07:20:36 <Holle_> what?
07:20:42 <quicksilver> to be fair I think you can bumble through it without necessarily appreciating all the details.
07:20:47 <quicksilver> I know I have personally ;)
07:20:47 <Axman6> yeah, what?
07:21:14 <Axman6> quicksilver: i missed the topic, but i'm going to guess, life?
07:21:16 <quicksilver> there's a kind of loosely logical obvious ness about unification if you don't think about it too hard.
07:21:23 <Holle_> what's FOU or MGU?
07:21:27 <quicksilver> Axman6: first order unification and most general types
07:21:35 <vixey> Holle_: you take constraints like {a = b -> c, b -> b = c -> c, c = Integer} --> {a = Integer -> Integer, b = Integer, c = Integer}
07:21:35 <byorgey> FOU = 'first order unification'; MGU = 'most general unifier'
07:21:53 <byorgey> Holle_: it's not that important to know the details when you're first learning how type inference works.
07:22:12 <vixey> .. yes it is
07:22:26 <byorgey> but vixey is talking about the mathematical foundations of type inference, which are rooted in mathematical logic.
07:23:00 <ksf> I thought they were just isomorph?
07:23:26 <byorgey> by 'details' I mean things like 'what "MGU" stands for'
07:25:34 <vixey> well good luck understanding why it gives the most general type without knowing what an MGU is ...
07:25:52 <quicksilver> I'm with byorgey.
07:25:55 <byorgey> ksf: historically, type inference for programming languages did actually emerge from the study of logic.
07:26:04 <quicksilver> Not many people learn best by learning all the details first.
07:26:14 <vixey> quicksilver: I'm perfectly happy by your earlier answer "magic"
07:26:23 <quicksilver> Most people learn best by  seeing some examples and trying to follow it.
07:26:27 <vixey> quicksilver: but there's nothing between that and understanding
07:26:28 <quicksilver> and then fill in the details later.
07:26:40 <quicksilver> Learning styles vary from person to person.
07:27:14 <ksf> yes, details are best if evaluated lazily.
07:27:18 <quicksilver> However, I have never taught a single student who fell into the 'learn the details first' bucket.
07:27:30 <ksf> otherwise, you're doing theory for theory's sake.
07:27:32 <quicksilver> although I've met some people - who were not my students - who claimed that way was best for them.
07:27:49 <quicksilver> And who am I to disagree, unless you're my student.
07:27:56 <quicksilver> If you are my student, I'll damn well tell you what to think :P
07:28:16 <vixey> It does not make sense to me that someone is asking how it *works* (not trying to fix a type error but get deeper understanding) and you are both saying just bumble through without understanding details
07:28:46 <quicksilver> Holle_ didn't ask how it worked. He asked how to find out the answer.
07:28:57 <quicksilver> If they'd asked how it works, I'd have answered it differently.
07:29:14 * vixey I only came on when they asked how it works
07:29:38 <Dridus> why argue about it now? Holle_, were you asking for a deeper understanding, or just to solve a problem?
07:30:06 * SamB hopes quicksilver isn't planning to teach philosophy
07:30:19 <Holle_> if start with g. g :: a -> b
07:30:25 <Holle_> f :: c -> d
07:30:49 <Holle_> so g :: (c -> d) -> b ?
07:31:00 <byorgey> yup
07:31:05 <byorgey> and in particular, a = c -> d
07:31:17 <ksf> well, as the model you want to create exists in the mind, and nescessarily differs from that on paper, it's usually easier to get a grasp of what it's all about and then fill in the details later, as opposed to reading the details and then realising they're isomorphic to you going shopping but missing the isomorphism to type theory.
07:31:41 <sbahra> Who would you talk to about haskell.org mailing lists?
07:31:52 <SamB> ksf: huh ?
07:32:01 <SamB> what does going shopping have to do with type theory ?
07:32:26 <SamB> and don't say "you could buy books on type theory"
07:32:35 <ksf> nothing more than an isomorphism of things like "not having butter" -> "buy butter"
07:32:57 <quicksilver> SamB: I was joking about that bit. Mostly ;)
07:33:15 <quicksilver> Holle_: although you can throw away the 'a' if it's not mentioned any more
07:33:24 <Axman6> SamB: but you could.
07:33:28 <Axman6> borrow them too
07:33:32 <quicksilver> Holle_: (which it isn't, in this simple case), so you don't need to remember that a = c -> d
07:33:42 <vixey> although you can throw away the 'a' if it's not mentioned any more <-- this is one case of the unification algorithm...
07:33:48 <Holle_> ok, so i have g :: (c -> d) -> b
07:33:55 <quicksilver> Holle_: if a was mentioned elsehwere, you'd need to fill it in everywhere.
07:34:25 <Holle_> now i take the (.) :: (b -> c) -> (a -> b) -> (a -> c)
07:34:41 <SamB> yeah, don't look at details until you can usually see what the type should be ... yes ?
07:35:12 <ksf> SamB, exactly. For abstract nonsense lies ahead.
07:35:15 <Holle_> (.) a -> b -> c
07:35:47 <vixey> Holle_, you've used the names a, b and c twice, for different variables
07:36:20 <vixey> (that might make things confusing down the line)
07:36:47 <ksf> hygenic mental scoping?
07:36:49 <Holle_> ok (.) :: h -> i -> k and h = b -> c and i = a -> b and k = a -> c
07:37:22 <Holle_> how to bring it together with g?
07:38:07 <Holle_> how to merge (.) and g?
07:39:26 <quicksilver> I don't think you do.
07:39:34 <quicksilver> isn't (.) applied to (:) and f ?
07:39:46 <quicksilver> that's the thinks you have to unify it with.
07:39:49 <Holle_> ((:).f)
07:39:59 <vixey> (((.) (:)) f)
07:40:06 <vixey> or ((compose cons) f)
07:40:29 <Holle_> g f = foldr ((:).f) []
07:43:55 <vixey> Holle_: compose :: (b -> c) -> (a -> b) -> (a -> c), cons :: a -> [a] -> [a],  so  by the rule,  u = u', f :: u -> v, x :: u' |- f x :: v  unify (b -> c) = a -> ([a] -> [a]) to gen b = a, c = [a] -> [a]  which leads to  compose cons :: (a -> b) -> (a -> c) = (a -> a) -> a -> [a] -> [a]
07:46:55 <Holle_> what means |-
07:47:55 <vixey> Holle_: the type rule for application there means given  u = ' and .. *then* f x has type v
07:48:11 <Dridus> Holle_ I find http://en.wikipedia.org/wiki/Math_symbols pretty useful for deciphering those kinds of things, btw. In this case it's logical inference
07:49:07 <vixey> Holle_, |- is the common name but it's just like any recursive function
07:49:46 <Holle_> sorry it's to difficult
07:50:04 <Holle_> i skip this task
07:50:41 <vixey> Holle_, if code helps it's like this function 'infer': http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62#a63
07:51:15 <Holle_> no
07:51:46 * Axman6 resists using "Just do <- it" as his moto thing for his loho
07:51:48 <Axman6> logo*
07:52:26 <SamB> good, because that isn't valid syntax or even close
07:53:49 <Axman6> i know
07:53:56 <Axman6> that wasn't the point
07:54:08 <fasta> Does cabal use multiple cores by default to compile?
07:54:32 <pejo> SamB, just missing a little context (pattern guards)
07:54:44 <pejo> fasta, not yet afaik. There was a soc project working on it.
07:55:05 <fasta> pejo: uhm, it seems that a soc project is complete overkill for that, not?
07:55:38 <dcoutts> fasta: no, it's actually a much harder problem than that
07:55:38 <quicksilver> well, you have to replicate ghc --make's dependency analysis
07:55:42 <fasta> I am not sure whether hmake is already adapted to it.
07:55:50 <quicksilver> to work out what to compile safelyin parallel
07:56:06 <dcoutts> fasta: right, the main issue is doing dep-based build properly. Once that's done, parallelism is relatively easy.
07:56:20 <fasta> Well, ghc -- make is open-source.
07:56:47 <dcoutts> it's not well adapted to the general case of many different types of files
07:56:53 <malcolmw> hmake is open-source too, but it does not do parallel builds (yet)
07:57:12 <quicksilver> fasta: if it's that easy, we look forward to your patch.
07:57:15 <quicksilver> fasta: tomorrow.
07:57:16 <fasta> malcolmw: was the patch correct this time?
07:57:20 <quicksilver> ;)
07:57:38 <malcolmw> fasta: I think so, but I'll actually apply it and check properly later
07:57:51 <fasta> malcolmw: and I suppose hmake is another highlight? :)
07:57:57 <malcolmw> yup
07:58:55 <quicksilver> malcolmw: does it worry you, that as your superior software naturally comes to dominate the world, you will approach a time when every line highlights?
08:01:24 * fasta notices that Yi didn't crash
08:01:42 <malcolmw> quicksilver: if it is that superior, there will be plenty of other open-source hackers working on it, and I won't need the highlight :-)
08:12:19 <Dridus> I ported Yi to GHC 6.10.1, but I found that in the GUI frontends, the buffer wouldn't visuall switch (the minibar and so on tracked the buffer switches, but it persistently showed the scratch buffer text)
08:12:39 <Dridus> anyone successfully use Yi on 6.10.1, or is that a bug that happened with 6.8.3 already?
08:13:08 <brodie> i used it with 6.10.1 the other day on os x. worked fine with vty, from cursory usage
08:13:19 <brodie> couldn't get HOC to compile, unfortunately
08:13:39 <brodie> though i was a little annoyed that it didn't use the alternate buffer in my terminal
08:14:45 <orbitz> :t concatmap
08:14:47 <lambdabot> Not in scope: `concatmap'
08:14:50 <orbitz> :t concatMap
08:14:51 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:17:52 <Dridus> brodie: yeah vty worked fine, it was just the gtk2hs and cocoa front ends that were unhealthy
08:18:19 <Cale> I think perhaps they haven't been maintained in a while
08:18:37 <brodie> Dridus: this is what i ran into with HOC http://code.google.com/p/hoc/issues/detail?id=10
08:18:51 <Dridus> ah well. I'm a died in the wool emacs user anyway, so it's not high priority to me
08:19:34 <Dridus> brodie: yeah, come to think of it I don't think I even tried HOC, I just tried gtk2hs as a preliminary to see what I thought of Yi. That looks like (yet another) extensible exception porting issue :-/
08:21:25 <Dridus> also, died -> dyed. I can spel
08:22:22 <slangan> The expression problem. Does that mean that I cant create new "primitives"
08:22:25 <slangan> new types?
08:22:29 <slangan> does hskell solve it?
08:22:35 <slangan> with data and typeclasses?
08:24:25 <quicksilver> slangan: nothing can solve the expression problem, that's why it's a problem :)
08:26:48 <quicksilver> in fact, you can tell how hard it is to solve by the number of papers that 'solve' it ;)
08:27:06 <slangan> but it is not proved unsolvable...?
08:29:10 <BMeph> slangan, quicksilver: Ralf Laemmel doesn't think it's such a problem... ;)
08:29:12 <quicksilver> slangan: it's a bit too fuzzy to prove much about it.
08:29:31 <quicksilver> slangan: if you're interested particularly in the 'data type' expression of the problem, take a look at 'Data Types a la Carte'
08:29:45 <quicksilver> which gives you some interesting ways to extend types polymorphically.
08:30:02 <quicksilver> ISTR an 'AI' sense of the problem, too, about global descriptions of the world.
08:30:10 <edwardk> its truly sad when twitter forces you to recall the binomial theorem
08:30:17 <Cale> oh?
08:31:30 <Cale> edwardk: How has twitter reminded you of it?
08:31:34 <edwardk> cale: something syntaxpolice said about the strength of a random password that doesn't have to include a mandatory digit vs. one that does.
08:31:42 <BMeph> slangan: See "The expression lemma", http://www.uni-koblenz.de/~laemmel/expression/long.pdf
08:31:42 <Cale> ah
08:31:50 <edwardk> cale: so i sat down and worked it out, which required the binomial theorem.
08:31:51 <luqui> the expression problem is basically the distributed product problem.  you have distributed sets A and B and you want to form AxB.
08:32:06 <luqui> (distributed = open)
08:32:19 <luqui> MPTC's have that one too
08:33:04 <lilac> you have A = algorithms and B = types operated on. if either of them is a fixed set, the problem is easily solved.
08:33:28 <lilac> in a sense, it's the same problem as multiple dispatch.
08:42:15 <ksf> I don't need any theorems to tell that fixing one char of a password to be a digit makes the distribution less random.
08:42:53 <vixey> yes you do
08:43:12 <orbitz> ksf: use Coq to prove it
08:43:26 <vixey> it might seem like common sense but that doesn't make it true
08:43:49 <Cale> Actually, there's a bit of a psychological issue mixed in here.
08:43:55 <edwardk> ksf: sure. but it provided a nice justification for the result
08:44:04 <orbitz> most people probably arn't goign to use a digit unelss forced
08:44:06 <lilac> it's obvious that the number of passwords is smaller, but it depends on the distribution whether that actually makes them harder to crack
08:44:09 <Cale> If you don't require users to include digits, then what proportion of them do it anyway?
08:44:53 <Cale> (or at least consider including digits in their password)
08:44:59 <drdozer> if I want stateful computation with random numbers, do I use StateT Random, or RandomT State?
08:45:23 <Cale> drdozer: those are likely to be equivalent
08:45:23 <EvilTerran> drdozer, i think those are interchangable
08:45:26 <lilac> if you assume that the restriction causes 90% of people to go from <dictionary word> to <dictionary word><digit>, then most of your passwords get much more secure, and a few of them get a little less secure
08:45:37 <drdozer> I want to be able to thread the random number context on to further computations
08:45:40 <EvilTerran> drdozer, seeing as Random(T) is a wrapper around State(T) anyway
08:45:47 <ksf> so we're left with passwords of the form hello1, hello2, hello3, hello4... I can tell. my former employee suddenly forced us to use 8-char passwords with one digit and change it every week, so I just rotated my old 7-char password (with caps) and added [0..3]
08:45:55 <EvilTerran> and i'm pretty sure StateT commutes with itself
08:45:57 <Cale> drdozer: RandomT/Random are effectively state monads.
08:46:16 <drdozer> olk
08:46:18 <Cale> drdozer: (in fact, they're thin candy shells around StateT/State)
08:46:21 <edwardk> cale: yeah, but the question was about a random n character password rather than about user generated ones
08:46:22 <edwardk> cale: i accept the fact that it tends to force a better distribution of user selected passwords throughout the password space =)
08:46:23 <ksf> downloading a dictionary attack dictionary and checking password strength against that makes more sense.
08:46:47 <slangan> any good tutorial on writing a parser for a programming language?
08:46:52 <drdozer> some of my operations operate on State(T) only and others will need to be random over this
08:47:03 <lilac> slangan: there's something like "Write yourself a scheme in 48 hours"
08:47:19 <slangan> not in haskell
08:47:47 <slangan> more about general tactics, grammars etc
08:47:55 <EvilTerran> drdozer, you'd get a difference if, say, you were comparing ListT (State s) a to StateT s [] a
08:47:59 <byorgey> "newtype: melts in the compiler, not in your hands"
08:48:02 <EvilTerran> ?unmtl  ListT (State s) a
08:48:03 <lambdabot> s -> ([a], s)
08:48:09 <EvilTerran> ?unmtl StateT s [] a
08:48:09 <lambdabot> s -> [(a, s)]
08:48:28 <EvilTerran> ?unmtl StateT s (StateT s' m) a
08:48:29 <lambdabot> s -> s' -> m (a, s, s')
08:48:32 <ksf> @remember byorgey "newtype: melts in the compiler, not in your hands"
08:48:32 <lambdabot> Nice!
08:48:55 <pejo> slangan, if you have a book on compiler construction available that should cover it
08:49:32 <drdozer> so probably I want StateT s (RandomT g a) then?
08:49:41 <drdozer> ?unmtl StateT s (Random g a)
08:49:42 <lambdabot> err: `StateT s (Random g a)' is not applied to enough arguments, giving `/\A. s -> Random g a (A, s)'
08:49:46 <lilac> is there a name for the partial commutativity property of (->)?
08:49:52 <EvilTerran> ?unmtl StateT s (Random g) a
08:49:52 <lambdabot> s -> Random g (a, s)
08:50:30 <EvilTerran> drdozer, (StateT s Random) and (RandomT (State s)) are equivalent
08:50:39 <Saizan> lilac: you mean flip?
08:50:45 <lilac> Saizan: yep
08:50:54 <drdozer> well, they may execute equivalently, but things will lift into them differently??
08:51:12 <Saizan> i'm not aware of any specific name
08:51:48 <byorgey> drdozer: if you make a newtype and use newtype deriving, you won't have to think about the lifting at all
08:51:52 <lilac> i guess it's that "(->) a" is commutative up to isomorphism
08:52:09 <lilac> but for all a
08:52:31 <byorgey> drdozer: http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
08:53:02 <Peaker> can anyone upload anything to hackage?
08:53:06 <Cale> That reminds me that I have to get syntax colouring working again...
08:53:11 <EvilTerran> "cale.yi.org - address not found"
08:53:12 <Peaker> is there any scrutiny at all about maliciousness of uploaders?
08:53:23 <Cale> EvilTerran: really? doh...
08:53:27 <byorgey> EvilTerran: works for me
08:53:35 <pejo> Peaker, you need a username and a password.
08:53:55 * EvilTerran curses richard branson and his rubbish DNS servers
08:53:56 <Cale> Oh, if it works for some of you, you might be behind a bad DNS cache.
08:54:38 <Cale> I have a dynamically assigned IP address, so my DNS record gets reset rather often.
08:55:31 <Martijn> Cale: I can load that page
08:55:45 <Cale> EvilTerran: 99.247.248.73
08:57:17 <Surma> hey guys, is there something like a circular shift for lists or should I just write one myself?
08:57:26 <vixey> write one
08:57:37 <Surma> k
08:57:41 <Surma> thx ^^
08:57:55 <Saizan> there's cycle though
08:58:00 <Saizan> > cycle [1..3]
08:58:02 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
08:58:08 <Axman6> Surma: there's a few ways to do it though
08:58:13 <osfameron> what's a circular shift?
08:58:27 <Martijn> Surma: Are you going to list all rotations?
08:58:35 <osfameron> ah, lik eshift [1,2,3] = [2,3,1] ?
08:58:37 <Axman6> osfameron: it looks like one if you keep popping off the top
08:59:13 <Surma> so, ``take (length n) (cycle n)'' is just what I need ;) thanks
08:59:31 <vixey> no it's not :P
08:59:45 <vixey> > let id = take (length n) (cycle n) in id "foo"
08:59:46 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
08:59:52 <vixey> > let id n = take (length n) (cycle n) in id "foo"
08:59:54 <lambdabot>   "foo"
09:00:07 <LeCamarade> Ey, comrades. Does anyone know of any kind of list of theorems proven or observations made about some algebraic structures (like monads, monoids, rings, et cetera)?
09:00:31 <vixey> LeCamarade: some algebra textbooks
09:00:32 <osfameron> something like - zipWith const (cycle $ tail n ++ [head n]) n    might be better?  To handle shifting an infinite list
09:01:18 <Olathe> > let rotL xs n = take (length xs).drop n.cycle $ xs in rotL "zomg" 1
09:01:19 <lambdabot>   "omgz"
09:01:56 <Olathe> > let rotL xs n = take (length xs).drop n.cycle $ xs in rotL [1..] 1
09:01:59 <Cale> > let crop xs ys = zipWith const ys xs; rotations xs = crop xs . map (crop xs) . tails . cycle $ xs in rotations [1,2,3,4,5]
09:02:18 <Cale> ...
09:02:20 <lambdabot>   thread killed
09:02:20 <lambdabot>   mueval: Prelude.read: no parse
09:02:21 <Cale> slow lambdabot?
09:02:25 <Cale> > let crop xs ys = zipWith const ys xs; rotations xs = crop xs . map (crop xs) . tails . cycle $ xs in rotations [1,2,3,4,5]
09:02:44 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,1],[3,4,5,1,2],[4,5,1,2,3],[5,1,2,3,4]]
09:02:44 <Cale> odd
09:02:57 <Badger> woooahhhh
09:03:01 * Cale sees if anything unusual is happening with the server
09:03:09 <Badger> phew
09:03:32 <Olathe> Ahh.
09:03:51 <Olathe> Does it actually calculate length before doing take ?
09:04:00 <Olathe> I bet it does...
09:04:12 <Olathe> So unlazy.
09:04:13 <vixey> @src take
09:04:14 <Cale> > let crop xs ys = zipWith const ys xs; rotations xs = crop xs . map (crop xs) . tails . cycle $ xs in rotations [1..]
09:04:20 <lambdabot> take n _      | n <= 0 =  []
09:04:22 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
09:04:24 <vixey> I guess the problem is take can't work on naturals
09:04:28 <lambdabot> take _ []              =  []
09:04:34 <lambdabot> Plugin `source' failed with: thread killed
09:04:36 <vixey> ^ is that unsafeInterleaveIO in motion?
09:04:43 <Olathe> Yeah, zipWith is nice.
09:05:11 <Olathe> > let rotL xs n = map snd.zipWith xs.drop n.cycle $ xs in rotL [1..] 1
09:05:18 <lambdabot>   Couldn't match expected type `[(a, b)]'
09:06:24 <dons> ?users
09:06:28 <Olathe> > let rotL xs n = map snd.zip xs.drop n.cycle $ xs in rotL [1..] 1
09:06:41 <lambdabot> Maximum users seen in #haskell: 568, currently: 548 (96.5%), active: 5 (0.9%)
09:06:43 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
09:06:48 <Olathe> There.
09:06:55 <Olathe> > let rotL xs n = map snd.zip xs.drop n.cycle $ xs in rotL "kaboom" 2
09:06:56 <lambdabot>   "boomka"
09:08:30 <int-e> > let rotL n = uncurry (flip (++)) . splitAt n in rotL 2 "kaboom"
09:08:32 <lambdabot>   "boomka"
09:08:33 <quicksilver> > let rotL xs n = map snd.zip xs.drop n.cycle $ xs in rotL "shabooyaka" 3
09:08:34 <lambdabot>   "booyakasha"
09:08:48 <bos> @seen dons
09:08:49 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 2m 24s ago.
09:09:48 <Olathe> > let rotL n xs = map snd.zip xs.drop n.cycle $ xs in rotL 50 "shabooyaka"
09:09:49 <lambdabot>   "shabooyaka"
09:09:53 <Olathe> > let rotL n xs = map snd.zip xs.drop n.cycle $ xs in rotL 51 "shabooyaka"
09:09:55 <lambdabot>   "habooyakas"
09:10:00 <jeffersonheard> any idea what the following runtime error is?
09:10:01 <jeffersonheard> ghc-6.8.2: ../../src/xcb_lock.c:77: _XGetXCBBuffer: Assertion `((int) ((xcb_req) - (dpy->request)) >= 0)' failed.
09:10:34 <bos> jeffersonheard: that's a crash in the XCB bindings
09:10:37 <Dridus> jeffersonheard: It's a thread locking thing in X/Xlib/gtk, as I recall. One suggestion I heard was to update X
09:10:49 <jeffersonheard> Dridus, thanks
09:11:07 <quicksilver> since when does ghc-6.8.2 use x/xlib/gtk ?
09:11:28 <bos> it's probably something jeffersonheard is interpreting using ghci or runhaskell
09:11:32 <chessguy_work> hey bos, just got RWH last night as an early Christmas present. great stuff!
09:11:34 <ksf> jeffersonheard, if you're feeling adventurous, you might want to try out xhb.
09:11:34 <chessguy_work> bos++
09:11:37 <bos> chessguy_work: yay!
09:11:38 <chessguy_work> dons++
09:11:41 <chessguy_work> CosmicRay++
09:11:52 <chessguy_work> bos, i didn't even have to throw any hints out there!
09:11:58 <CosmicRay> thanks ;-)
09:12:12 <ksf> http://community.haskell.org/~aslatter/code/xhb/
09:12:21 <jeffersonheard> xhb?
09:12:51 <ksf> haskell implementation of the x client protocol, generated from the same xml's as xcb.
09:13:13 <CosmicRay> interesting
09:13:15 <jeffersonheard> ahhh
09:13:20 <CosmicRay> so it is a pure-haskell implementation then?
09:13:27 <ksf> yeah.
09:14:21 <ksf> featuring such things as asynchronous server replies and server-extension completeness.
09:14:30 <CosmicRay> where did these xmls come from? X11 predated XML, didn't it?
09:14:43 <ksf> they seem to have written them for xcb.
09:15:10 <bos> Somebody needs to write a paper on lazy parsing with support for errors.
09:15:17 <bos> I'm lookin' at you, #haskell.
09:15:28 <CosmicRay> heh
09:16:02 <ksf> the crystal ball saiz: nobody is intending to write it, so nobody read your request.
09:16:08 <CosmicRay> heh
09:16:32 <bos> Everyone and their mom knows how to write parsing libraries that are either lazy or support errors, but approximately nobody seems to know how to do both.
09:16:39 <CosmicRay> bos: instead of a paper, how about some code?
09:16:48 <bos> I'd take code instead :-)
09:17:02 <bos> In fact, I'd take a patch to Data.Binary before all else :-)
09:17:10 <CosmicRay> ah ha
09:17:24 * jeffwheeler thinks that coroutine library looks neato.
09:17:25 <CosmicRay> I wondered when that was going to crop up ;-)
09:17:45 <CosmicRay> bos: I personally wish pattern matching could apply to ByteStrings.
09:18:01 <bos> CosmicRay: I think that can be done with view patterns now.
09:18:17 <CosmicRay> view patterns?  url me
09:18:20 <bos> CosmicRay: at least in principle
09:18:32 <CosmicRay> is this a new ghc 6.10 thing?
09:19:01 <bos> CosmicRay: yes. http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns
09:19:08 <CosmicRay> thanks
09:19:27 <MarcWeber> ?where hsc2hs
09:19:27 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
09:20:09 <CosmicRay> bos: that's interesting stuff.
09:20:33 <bos> CosmicRay: yes, it is indeed.
09:21:57 <CosmicRay> bos: another thing haskell needs is a good line-oriented network protocol parsing library.
09:22:13 <bos> in principle, you ought to be able to write stuff like foo (prefixedWith "foo" -> True) = bar
09:22:13 <lilac> bos: somewhere i've got a combinator for parsec, manyE :: Parser a -> Parser [Either ParseError a]
09:22:22 <bos> CosmicRay: that's the intention behind AttoParsec
09:22:47 <CosmicRay> ah
09:22:49 <dons> would be worth playing with. bytestring matching
09:23:14 <bos> dons: got any tricks up your sleeve for lazy parsing with error?
09:23:17 <CosmicRay> bos: there's more to it though -- all the network interaction bits.
09:23:27 <CosmicRay> bos: it's not like it's an unknown problem, but it is not trivial to get right.
09:23:38 <dons> bos, i'm sure there's papers on it. (list of failures in the stream?)
09:23:43 <CosmicRay> bos: for instance, you don't want to be DoS'd by just continuing to read characters until you see \n
09:23:55 <CosmicRay> OTOH you don't want to attempt to read too much data, lest you block
09:24:02 <dons> or can you survive with strict parsing?
09:24:04 <ksf> CosmicRay, http://hpaste.org/11880
09:24:29 <dons> bos, need to do some network protocol stuff in Data.Binary at work too, so will be looking at this in coming weeks
09:24:37 <dons> so keeping track of what you know and what you need would be useful
09:24:48 <CosmicRay> ksf: yes, we have LineBuffering.  it's a bit of a hack though.  if your EOL is something different, your life is more complicated
09:25:06 <ksf> erm...
09:25:10 <CosmicRay> ksf: also that code is vulnerable to DoS from the server
09:25:14 <ksf> isn't linebuffering done by the OS?
09:25:23 <CosmicRay> ksf: nope, that's in GHC
09:25:41 <athos> hi all
09:25:49 <CosmicRay> ksf: the source is there in libraries/base IIRC
09:25:53 <Dridus> hey athos
09:25:57 <Cale> bos: Well, lazy + errors means that you have to be content with getting a parse error halfway through consuming the data.
09:26:06 <CosmicRay> ksf: the only time the OS does line buffering is with the terminal in certain modes
09:26:25 <Cale> bos: There's no way around it, since in order to discover errors, you really do have to do the parsing.
09:26:26 <CosmicRay> ksf: otherwise, it's all in the language libs, even with C.  fgets(), etc. are doing buffering in libc, not in kernel
09:26:41 <chessguy_work> is there an errata list somewhere for RWH?
09:26:42 <CosmicRay> Cale: I'm content with that.
09:26:56 <CosmicRay> chessguy_work: funny you should mention that.
09:26:59 <CosmicRay> chessguy_work: there should be.
09:27:06 <CosmicRay> chessguy_work: we have been getting errata reports from people
09:27:12 <chessguy_work> at least a wiki page
09:27:13 <CosmicRay> chessguy_work: I don't think any of us have had time to review them yet.
09:27:13 <quicksilver> chessguy_work: in a recent move, its was ruled that RWH is definitive.
09:27:20 <quicksilver> Any errors should be bug reports against reality.
09:27:23 <CosmicRay> chessguy_work: o'reilly has a whole errata system
09:27:28 <chessguy_work> ah, ok
09:27:31 <CosmicRay> quicksilver: that would certainly simplify my life
09:27:43 <chessguy_work> the pope has decreed RWH infallible?
09:27:44 <chessguy_work> :)
09:27:59 <CosmicRay> chessguy_work: ahh, you missed that at Vatican III? ;-)
09:28:12 <CosmicRay> chessguy_work: http://oreilly.com/catalog/9780596514983/index.html
09:28:18 <Cale> Has anyone worked out a good combinator framework for parsers which can cope with parse errors and try to resume parsing?
09:28:26 <CosmicRay> that's the o'reilly homepage of the book.  there is a "view/submit errata" link on the left
09:28:35 <Cale> (such as might be needed for a text editor)
09:28:47 <wjt> it's a shame that the fourth monad misconception doesn't have a rebuttal :)
09:28:50 <Martijn> Cale: Doaitse Swierstra has error-correcting parsers
09:28:57 <pumpkin_> wjt: ?
09:28:57 <wjt> it reads like "this one is a misconception but actually it's true"
09:29:00 <opqdonut> wjt: where?
09:29:02 <wjt> in RWH
09:29:17 <chessguy_work> CosmicRay, thanks
09:29:33 <Cale> wjt: Which one is that?
09:29:43 <Cale> (so I don't have to go searching for it ;)
09:29:47 <chessguy_work> oh, yeah i thought that was odd when i read it last night
09:29:52 <quicksilver> Cale: I'd also draw your attention to the applicative parser example which collects errors.
09:29:54 <ksf> Cale, I've heard yi folks mentioning such stuff.
09:30:00 <wjt> Cale: Monads are for controlling the order of evaluation.
09:30:03 <quicksilver> Cale: (but it's not a full answer to your question)
09:30:13 <CosmicRay> chessguy_work: as I said, there are a number of errata in our queue to look at
09:30:24 <wjt> Cale: the list purports to prepare the reader with a few good retorts
09:30:29 <Cale> wjt: Oh, right, it really is a misconception. In that case I wish they'd said more about it.
09:30:33 <CosmicRay> chessguy_work: which will be appearing there once we have had the chance
09:30:40 <ksf> http://yi-editor.blogspot.com/2008/11/incremental-parsing-in-yi.html
09:30:50 <Cale> It kind of takes more than a brief remark to explain though.
09:30:56 <chessguy_work> Cale, http://book.realworldhaskell.org/read/monads.html (do a find on "misconceptions")
09:31:07 <ksf> waaiiiitt...
09:31:08 <wjt> indeed Cale is comment #3 on that bullet point
09:31:10 <ksf> that's not it.
09:31:21 <wjt> «Lacking a "good retort". Is this left as an excercise to the reader? :P»
09:31:43 <Cale> ah, I am
09:31:44 <wjt> (not Cale's comment, but a nice one :))
09:31:45 <Cale> hehe
09:32:33 <Cale> I haven't really completely read RWH. Do they explain how lazy evaluation works anywhere?
09:32:47 <chessguy_work> Cale, yes
09:32:50 <bos> Cale: we build a smoke-and-mirrors argument.
09:33:05 <bos> we give the folk intuitive description of it.
09:33:12 <Cale> (As in, proceed by evaluating the outermost reducible expression first.)
09:33:21 <quicksilver> there is no lazy evaluation! It's just a man behind the curtain!
09:33:25 <bos> we don't talk about redexes.
09:34:24 <chessguy_work> Cale, http://book.realworldhaskell.org/read/types-and-functions.html
09:34:43 <dons> nice comment on the amazon reviews today about RWH covering in one volume what legacy langs would take multiple volumes to cover
09:34:45 <jeffersonheard> on the xhb / xcb question, there's no way to get Gtk2Hs to use Xhb, is there?
09:34:47 <dons> (i'm looking at you, Java)
09:34:49 <bos> dons: primarily what i need this week is laziness + errors. although the controlled laziness with continuations of binary-strict is pretty schweet.
09:34:50 <chessguy_work> not very technical, but it's there
09:34:59 <dons> bos. mmm.
09:35:16 <dcoutts> jeffersonheard: you'd need the underlying Gtk+ C lib to use xcb.
09:35:16 <chessguy_work> dons, i am impressed with the range of simplicity to depth
09:35:25 <dcoutts> jeffersonheard: which may well happen eventually.
09:35:30 <jeffersonheard> dcoutts, that's about what I thought
09:35:35 <dons> i'd not thought about that, but yeah, it would be hard to do that breadth without drowning in code
09:35:56 <dons> bos, you might run your parsing ideas by dcoutts too
09:36:07 <jeffersonheard> dcoutts, my main problem is that if I call redraw too fast on the threaded runtime, even if I'm only using one thread, the program occasionally borks
09:36:17 <bos> CosmicRay: if you have any ideas about changes you'd like to see in AttoParsec, let me know.
09:36:21 <jeffersonheard> when I use Gtk.idleAdd
09:36:28 <dcoutts> bos, dons: is this binary parsing on top of a binary monad with continuations to backtrack on errors?
09:36:29 <bos> CosmicRay: they don't have to come in the form of patches, either :-)
09:36:56 <dcoutts> jeffersonheard: only redraw in the onExpose handler, nowhere else.
09:36:58 <bos> dcoutts: binary-strict uses continuations to pull in more input
09:37:08 <chessguy_work> dons, wadler linked to a new (at least i assume it's new) paper today on type-safe patterns. if i can wrap my mind around it, i'm going to turn it into a module and see how it fits with what i've been thinking about
09:37:20 <dcoutts> jeffersonheard: 1 because it's the right thing to do and 2 because it'll solve your mutli-threading problems
09:37:34 <bos> dcoutts: so if a strict bytestring gets exhausted, you get dropped out to the caller with a continuation to resume parsing when you pull in more data
09:37:56 <jeffersonheard> dcoutts, the onExpose handler won't be called for mere mouse motion over the window, though, right?
09:37:58 <dcoutts> bos: yes, that's good. The only problem is the use of strict bytestring
09:38:05 <bos> dcoutts: which is ideal for parsing things like a sequence of network packets, where the current binary package doesn't work
09:38:10 <bos> dcousure
09:38:13 <bos> er, sure.
09:38:19 <jeffersonheard> dcoutts: plus, what about animation?
09:38:25 <dcoutts> jeffersonheard: no but you can invalidate any regions of the widget that you need at any timw
09:38:27 <dcoutts> time
09:38:56 <bos> dcoutts: having some kind of try-like combinator and an alternative instance would be nice, too. working with lookAheadM and a custom combinator is a bit fug.
09:39:30 <dcoutts> bos: the main thing is being able to control how many backtracking points are kept, we don't want to waste resources in the default case.
09:39:47 <jeffersonheard> dcoutts...  hrm.  alright.
09:39:55 * RayNbow is baffled @ a discussion about Java and education stuff on a Dutch forum... in which someone claims C# is getting more and more features of dynamic languages, like for example lambda expressions :X
09:40:04 <pumpkin_> :o
09:40:08 <dcoutts> bos: perhaps the parsec approach of using try when backtracking is needed is the right default for binary parsing.
09:40:09 <RayNbow> (my eyes rolled out of my sockets when I read that)
09:40:17 <bos> dcoutts: i think it is, yes.
09:41:58 <bos> RayNbow: it is best to just pretend discussions about Java and C# don't exist.
09:44:20 <wchogg> bos : but..but they're _so different_
09:44:36 <chessguy_work> RayNbow, i wouldn't call that a "dynamic language" feature, but it is a functional language feature, and it is a good thing
09:45:06 <chessguy_work> LINQ also has some nice functional-ish features
09:45:38 <wchogg> chessguy_work : I once worked at a company that refused to allow the C# programmers to use LINQ because it was strange & frightening
09:45:50 <chessguy_work> haha
09:46:01 <Raevel> "frightening"
09:46:06 <RayNbow> chessguy_work: I know, that's why I replied to thread saying that lambda expressions are not tied to dynamic languages
09:46:06 <opqdonut> :D
09:46:39 <chessguy_work> they've done a nice job of keeping that stuff type-safe too
09:46:46 * ksf wants a rwh for reactive
09:46:51 <wchogg> Yeah, they pretty much explicitly said that the architechts at the company didn't feel comfortable with LINQ or type inference so no one was allowed to use it.
09:47:01 * vixey . o O ( "dynamic language"? )
09:47:04 <RayNbow> bos: well, it depends on the type of discussion... sometimes a discussion is interesting... (but the majority of them are full of crap)
09:57:17 * ksf would already be content if he wouldn't understand reactive, but understanding it while still being at a complete loss just sucks.
09:58:31 * ksf attempts to drown his frustration in chocolate pudding and whisky.
09:58:44 <athos> yummy
10:01:53 <jeffersonheard> dcoutts: if I invalidate the rectangle, does that automatically call a redraw?
10:02:13 <dcoutts> jeffersonheard: it schedules a redraw
10:02:56 <dcoutts> jeffersonheard: any other regions you invalidate get unioned and passed to the exposed handler next time it is run
10:02:58 <jeffersonheard> dcoutts: but I'm not seeing the item redraw.  before, I was calling the render function on every mouse click and idlely to sense mouse motion.  that worked, but only if I used the single threaded runtime
10:03:10 <jeffersonheard> so I don't know how to generate an expose event
10:03:17 <dcoutts> it's automatic
10:03:19 <CosmicRay> bos: I do really need to look at it more closely.
10:03:34 <bos> CosmicRay: look at what? oh, attoparsec.
10:03:38 <dcoutts> jeffersonheard: but you have to actually do the drawing in the expose handler
10:03:55 <CosmicRay> bos: right, sorry, was AFK.  I keep trying to find time to port OfflineIMAP to Haskell.
10:04:06 <CosmicRay> bos: I am tired of working with Python.  plus that code is old and crufty.
10:04:10 <bos> :-)
10:04:13 <jeffersonheard> I am..  but I'm also printing "exposed" every time the onExpose handler gets called, and it's never printing
10:04:38 <bos> Code that is beautifully layered and yet efficient will really mess with your ability to enjoy other languages.
10:04:43 <dcoutts> jeffersonheard: does it get called when you move another window over yours and expose it again?
10:04:47 <jeffersonheard> nope
10:04:55 <jeffersonheard> "onExpose window $ \evt -> print "exposed" >> renderer state scene >> return True"
10:05:02 <dcoutts> jeffersonheard: then you must be blocking somewhere and preventing the main loop from running
10:07:12 <jeffersonheard> Maybe it's time to hpaste this.  If that were true, then I would expect the mouse motion event not to respond, and it does
10:07:19 <jeffersonheard> it just doesn't draw anything
10:07:43 <jeffersonheard> oh!  wait!  I'm binding onExpose to the window and not the drawingArea!
10:10:44 <jeffersonheard> I still get the xcb error now, but the performance is much better when it doesn't give me the error.
10:10:56 <jeffersonheard> I'll post code in a little while
10:10:58 <jeffersonheard> it's lunchtime
10:13:31 <Raevel> oh boy
10:13:36 <Raevel> they just shipped my rwh
10:14:27 <olsner> Raevel: ooooh
10:14:59 <athos> :t lines
10:15:01 <lambdabot> String -> [String]
10:15:08 <pumpkin_> is there any easy way to take up until the last occurrence of something in a list?
10:15:32 <lament> reverse the list first
10:15:34 <mauke> reverse, dropWhile, reverse
10:15:53 <opqdonut> but that's pretty inneffective
10:16:04 <opqdonut> one can code a simple linear-time recursive function for that
10:16:11 <pumpkin_> yeah :P
10:16:14 <mauke> it's very effective
10:16:28 <mauke> and reverse is O(n)
10:16:38 <opqdonut> erm, not linear-time but single-traversal
10:16:47 <Raevel> olsner: christmas is saved :-)
10:16:53 <opqdonut> yeah the reverse solution is not bad for lists of reasonable lengths
10:16:56 <int-e> mauke: try it on an infinite list :)
10:17:47 <BMeph> jeffersonheard: No, no, it's "xkcd", not "xkb". ;)
10:18:33 <pumpkin_> int-e: I'd be hard-pressed to define what the "last occurrence" means in an infinite list :P
10:19:29 <pumpkin_> but I guess it could just return the entire list
10:19:33 <int-e> pumpkin_: well, but if you find two occurences, you know the first one is in the list. so assuming that there are infinitely many occurences, the whole function can be lazy
10:20:15 <int-e> pumpkin_: if there are only finitely many then you can return the list up to the second to last occurence and then diverge.
10:20:19 <lament> pumpkin_: suppose your list is [1..] and you're trying to find the last occurence of 5 :)
10:20:24 <jowens> my understanding is this is a nice place for a n00b (and I do mean n00b) to ask simple questions, is that cool?
10:20:31 <lament> jowens: yes.
10:20:40 <pumpkin_> lament: well, if I know the list is sorted, I can be smarter :P
10:20:42 <mauke> don't ask to ask, just ask
10:20:45 <jowens> :)
10:20:46 <pumpkin_> but I was saying in general
10:21:08 <jowens> i am trying to test if a number is composite or not.
10:21:11 <int-e> > last [1..] :: Word8
10:21:12 <lambdabot>   255
10:21:13 <jowens> here is my one-liner
10:21:14 <jowens> isComposite d = any isTrue (map (evenlyDivides d) [2 .. floor(sqrt(fromIntegral d))])
10:21:22 <mauke> isTrue = id
10:21:27 <jowens> the "isTrue" thing seems really dumb
10:21:33 <jowens> isTrue x = (x == True)
10:21:38 <int-e> any isTrue = or
10:21:38 <jowens> surely there is a better way to do that
10:21:41 <lament> yes.
10:21:42 <mauke> that's the same as isTrue x = x
10:21:56 <pumpkin_> why not id?
10:21:57 <Raevel> @src [] return
10:21:58 <lambdabot> return x    = [x]
10:22:00 <blackh> jowens: Pick me! Pick me! id!
10:22:05 <orbitz> > [1..] :: Word8
10:22:06 <lambdabot>   Couldn't match expected type `Word8' against inferred type `[a]'
10:22:16 <jowens> wow ok that was a lot of responses.
10:22:18 <orbitz> oh durh
10:22:18 <Raevel> > return []
10:22:18 <jowens> explain "id"?
10:22:19 <Deewiant> ?ty any id
10:22:19 <lambdabot>       No instance for (Show (m [a]))
10:22:19 <lambdabot>        arising from a use of `show' at <...
10:22:20 <int-e> jowens:  and why not  any (evenlyDivides d) ...?
10:22:21 <lambdabot> [Bool] -> Bool
10:22:21 <Deewiant> ?ty or
10:22:23 <lambdabot> [Bool] -> Bool
10:22:27 <lament> jowens: id x = x
10:22:32 <lament> jowens: id is the identity function
10:22:37 <jowens> oh that's nice.
10:22:53 <jowens> also the any-evenly-divides looks smart
10:22:56 <jowens> and i like the "or" also.
10:23:01 <mauke> > or [even 3, 3 > 2, odd 3]
10:23:02 <lambdabot>   True
10:23:04 <int-e> any f . map g = any (f . g)
10:23:05 <jowens> would there be any efficiency issues with either of them?
10:23:16 <mauke> not really
10:24:03 <jowens> ok then. that answers my question in three different ways, all of which are better than what i had. Thanks #haskell!
10:24:24 <mauke> (satisfied customer)++
10:24:35 <Deewiant> ?karma customer)
10:24:36 <lambdabot> customer) has a karma of 1
10:24:39 <orbitz> mauke: ++ is binary operator!
10:24:53 <mauke> preflex: karma satisfied customer
10:24:54 <preflex>  karma for satisfied customer: 9
10:25:20 <int-e> customer)--
10:25:34 <int-e> preflex: karma customer)
10:25:35 <preflex>  karma for customer): -1
10:25:36 <Gracenotes> is that a destructive update? :O
10:25:42 <blackh> modifyIORef karma (+1)
10:25:45 <olsner> @karma+ satisfied customer
10:25:46 <lambdabot> satisfied's karma raised to 1.
10:25:51 <mauke> haha
10:25:55 <olsner> :(
10:25:57 <mauke> lambdabot--
10:26:03 <EvilTerran> jowens, you can avoid the going via floating-point in floor(sqrt(fromIntegral d))
10:26:10 <jowens> do tell
10:26:12 <Gracenotes> I think we need karma as part of the channel's state monad, no?
10:26:16 <int-e> lambdabot++ # don't listen to them, I still love you.
10:27:12 <EvilTerran> > let x `leSqrt` y = x^2 <= y in takeWhile (`leSqrt 12) [1..]
10:27:13 <lambdabot>   <no location info>: parse error on input `12'
10:27:15 <EvilTerran> > let x `leSqrt` y = x^2 <= y in takeWhile (`leSqrt` 12) [1..]
10:27:16 <lambdabot>   [1,2,3]
10:27:21 <EvilTerran> > let x `leSqrt` y = x^2 <= y in takeWhile (`leSqrt` 16) [1..]
10:27:23 <lambdabot>   [1,2,3,4]
10:27:54 <Gracenotes> sorry, what does <= do again...?
10:28:04 <Gracenotes> oh, duh, less than or equal to
10:28:17 <jowens> that is very interesting. thanks evilterran!
10:28:20 <EvilTerran> :)
10:28:30 <jowens> floating point is THAT bad, eh?
10:28:41 <EvilTerran> > floor (sqrt 100)
10:28:42 <lambdabot>   10
10:28:44 <EvilTerran> hm
10:28:49 <Deewiant> flipping between integers and floating point is bad for performance
10:29:07 <Gracenotes> > floor (sqrt 10000)
10:29:09 <lambdabot>   100
10:29:24 <olsner> int-e: and all anyone has to do is accidentally write "lambdabot--" as part of a message to undo your appreciation of her
10:29:25 <jowens> yes, i could understand that in general, but it does seem simpler than a whole expression.
10:29:32 <ksf> > sqrt (-1)
10:29:33 <lambdabot>   NaN
10:29:36 <Gracenotes> > sqrt .001
10:29:38 <lambdabot>       No instance for (Num (a -> b))
10:29:38 <lambdabot>        arising from the literal `1' at <...
10:29:43 <ksf> > sqrt (-1)::Complex
10:29:44 <lambdabot>       `Complex' is not applied to enough type arguments
10:29:44 <lambdabot>      Expected kind `?...
10:29:45 <mauke> > sqrt (-1) :: Complex Double
10:29:46 <lambdabot>   (-0.0) :+ 1.0
10:29:48 <Gracenotes> > sqrt 0.001 --gets me every time
10:29:50 <lambdabot>   3.162277660168379e-2
10:29:56 <mauke> preflex: calc '2 pi
10:29:56 <preflex>  11.001001000011111101101010100010001000010110100011
10:30:10 <blackh> olner: What's with this C syntax?
10:30:10 <pumpkin_> preflex: calc '10 pi
10:30:11 <preflex>  3.14159265358979
10:30:17 <Gracenotes> preflex: calc '16 pi
10:30:18 <int-e> > let p = 1058037490287239011341135125141 in p <= round (sqrt (fromIntegral (p^2)))
10:30:18 <preflex>  3.243f6a8885a3
10:30:19 <lambdabot>   False
10:30:26 <int-e> yes, floating point is bad.
10:30:43 <jowens> like, is it particularly bad in the Haskell sense?
10:30:54 <jowens> In assembly I wouldn't think twice about that.
10:31:23 <ksf> It just comes with there uncomputability.
10:31:38 <int-e> jowens: not worse than usual. it's just that in haskell you often tend to do equational reasoning and that fails in some cases. (NaNs mostly)
10:31:39 <ksf> *their
10:31:53 <int-e> > let nan = 0/0 in nan == nan
10:31:54 <lambdabot>   False
10:32:09 <lilac> olsner: it's not like people are going to go around writing lambdabot-- willy-nilly, though, is it? :)
10:32:12 <jowens> ok. i like seeing that it could be done in an integer setting.
10:32:39 <int-e> jowens: the same thing happens in C, but I suspect that fewer C than Haskell programmers would be upset about it.
10:32:51 <jowens> understood. as a c programmer, i would not.
10:33:05 <jowens> (for the record, i am trying to learn haskell by doing Project Euler. This was Problem 3.)
10:33:21 <pumpkin_> yay project euler
10:33:29 * pumpkin_ points at int-e and whispers something to jowens
10:33:33 <olsner> blackh: not C syntax, haskell syntax: lambdabot-- is just the start of a comment, (lambdabot++) is a function that prepends lambdabot to something, or alternately (lambdabot++ [1,2,3]) is the value of lambdabot followed by 1,2,3 :P
10:33:46 <Gracenotes> > let inImpossibleSet a = a != a in inImpossibleSet (0/0)
10:33:47 <lambdabot>   Not in scope: `!='
10:33:52 <Gracenotes> > let inImpossibleSet a = a /= a in inImpossibleSet (0/0)
10:33:54 <lambdabot>   True
10:34:13 <Gracenotes> the null set isn't empty after all :/
10:34:38 <user317> did XMonad.Hooks.ManageDocks move?  i cant get my xmonad to find it when i recompile
10:34:41 <ksf> sure, it has emptiness in it.
10:34:41 <chadz> hey -- seems xmonad-contrib is dying w/ cabal-install and ghc 6.10.1
10:34:55 <chadz> XMonad/Hooks/UrgencyHook.hs:359:48: The section `5 `seconds`' takes one argument, but its type `Int' has none
10:35:08 <mauke> chadz: yes
10:35:28 <chadz> straightforwards workaround?
10:35:40 <blackh> olsner: So then lambdabot-- means that I can say anything I like in THIS bit of the line and lambdabot won't hear!
10:35:43 <mauke> get the darcs version of xmonad or downgrade ghc
10:35:46 <chadz> my eyes are starting to reject gnome, hurry :)
10:35:55 <chadz> mauke: alright
10:36:03 <user317> ah, i need xmonad-contrib as well
10:36:11 <dons> ?users
10:36:12 <lambdabot> Maximum users seen in #haskell: 568, currently: 552 (97.2%), active: 30 (5.4%)
10:36:36 <orbitz> hrm..no megzla today?
10:37:30 <dons> mm
10:37:35 <olsner> lilac: well, stranger things have happened :P
10:37:51 <chadz> any seattlites enjoying the snow?
10:38:04 <dons> chadz: snow in portland , anyway.
10:38:08 <dons> big flakes
10:38:25 <chadz> niceee, pnw wfh day
10:38:30 <orbitz> dons: you wrot the Stream Fusion stuff right?
10:38:35 <dons> orbitz: yup
10:39:02 <orbitz> dons: is 'stream' just a general word there for anything you want to basically process i na transient fashion?
10:39:27 <dons> yes, like iterator or lazy list, or ...
10:39:32 <user317> so what do i need to install to get this to compile, http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#Make_space_for_a_panel.2Fdock.2Ftray_application
10:39:50 <chadz> (phds gotta make everything complicated, especially terminology)
10:40:13 <mauke> user317: xmonad-contrib
10:40:31 <orbitz> dons: cool, i have the .pdf in to-read list.  are there any other godo tutorails on usign it?
10:40:39 <dons> on using streams? the papers
10:40:42 <olsner> Nov 21 21:40:09 <lambdabot>     Maximum users seen in #haskell: 418, currently: 406 (97.1%), active: 20 (4.9%)
10:40:45 <olsner> (2007)
10:40:45 <user317> mauke, i have that, is that example missing a bunch of imports?
10:40:57 <mauke> user317: maybe
10:41:01 <orbitz> dons: i have just one ig ot from cale, whichis yoru intro paper i think
10:41:01 <mauke> user317: WHAT IS THE ERROR MESSAGE
10:41:06 <chadz> how compatible is darcs xmonad-contrib with .8 xmonad?
10:41:14 <dons> chadz: closee
10:41:44 <chadz> dons: worth skimping in on teh darcs xmonad, or should I just jump off the cabal-install wagon for now?
10:41:58 <user317> mauke, http://hpaste.org/13175
10:42:10 <mauke> user317: import XMonad
10:42:15 <dons> chadz: why do you need darcs xmonad?
10:42:28 <Cale> orbitz: Of course, in that paper's context, "Stream" has a particular definition which makes it easy to write functions like map and filter for streams without using recursion.
10:42:37 <chadz> dons: suggestion by mauke to get around xmonadcontrib failing on my 6.10.1 build
10:42:37 <user317> mauke, how silly :)
10:42:59 <Cale> (which is important if you want definitions like that to inline)
10:43:25 <orbitz> Cale: yeah.  I have some Haskell code that is doing some work with 30+GB of files. i was lookign to see if maybe I should consider trying to use stream fusion for part of it
10:44:04 <orbitz> (currently it's rather slow, so also looking to speed it up once i've gotten it to be more idiomatic Haskell)
10:44:08 <Cale> iirc, there's a package on hackage which implements stream fusion for lists. Data.ByteString.* also use it.
10:44:26 <Deewiant> ?hackage stream-fusion
10:44:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream-fusion
10:44:41 <dons> uvector is the best example, imo
10:44:49 <dons> though the lists package is probably easier to grok
10:45:02 <chadz> orbitz: parsing?
10:45:05 <dons> uvector's the most aggressive
10:45:40 <sebaseba> why does this give a stack space overflow? http://hpaste.org/13176
10:46:13 <orbitz> chadz: the parsing isn't too bad.  mostly i have 1 file which i make a Map of some identifier to soem data, and then i'm looking through 30GB of other files trying to match those peices of data, and once i've done that I can do some computations on them
10:46:32 <Deewiant> sebaseba: are you compiling with -O or -O2?
10:46:39 <sebaseba> Deewiant: -O2
10:46:52 <sebaseba> Deewiant: that should activate stream fusion, right?
10:47:10 <mauke> does using foldl' (+) 0 instead of sum change anything?
10:47:16 <pejo> dons, are you guys working on more stream fusion?
10:47:30 <pumpkin_> sum overflows a lot for me on large lists
10:47:38 <Deewiant> sum should become strict with -O
10:47:40 <orbitz> > sum [1..100000000]
10:47:45 <chadz> orbitz: yeah, got a perl problem like that lying around at work i'd like to replace one day :)
10:47:55 <lambdabot>   thread killed
10:47:59 <orbitz> chadz: any advice, or just sharing in my prediciment:)
10:48:06 <Gracenotes> > 100000000*100000001/2
10:48:11 <lambdabot>   5.00000005e15
10:48:26 <chadz> orbitz: well, i was looking at parsec's new bytestring capability
10:48:30 <Deewiant> sebaseba: and yes, it should activate rewrite rules which fuse things
10:48:31 <mauke> > 100000000*100000001`div`2
10:48:33 <lambdabot>   5000000050000000
10:48:38 <sebaseba> mauke: foldl' (+) 0 works fine
10:48:46 <chadz> orbitz: haven't looked at streamfusion at all past some blogs
10:48:52 <mauke> so ... foldl.
10:48:58 <Gracenotes> :t div
10:49:00 <lambdabot> forall a. (Integral a) => a -> a -> a
10:49:01 <lilac> > let isComposite k = foldr(uncurry$flip((.).(&&).(<=k)).(||).(0==).mod k) False$iterate(uncurry(ap((.).(,).(1+))((+).(1+).(2*))))(2,4) in isComposite 14
10:49:03 <lambdabot>   True
10:49:05 <orbitz> chadz: I think my IO code is just weak.  i use hGetContents,  30GB of [Char] is rough from whatI understand
10:49:09 <sebaseba> mauke: so is sum being too lazy?
10:49:19 <Deewiant> the strictness analyser can't catch that? O_o
10:49:20 <lilac> is there a nice foldr/iterate fusion rule?
10:49:23 <chadz> orbitz: yeah, i'd definately try to use bytestrings :)
10:49:27 <mauke> sebaseba: yes
10:49:43 <orbitz> sebaseba: sum id foldl, from how it was explained to me, when yo uhav ea really huge list you blow the stack with all the unevalauted thunks
10:49:44 <sebaseba> mauke, Deewiant: ok thanks
10:50:03 <Deewiant> I'm quite surprised that -O doesn't strictify that
10:50:11 <orbitz> chadz: yeah.  currently i'm at about 225minutes :)
10:50:18 <orbitz> chadz: i think i can bring that down to abotu 45 minutes
10:50:26 <chadz> orbitz: ouch, that's longer than our script, haha
10:50:31 <orbitz> chadz: haah
10:50:32 <lilac> > foldr f x $ iterate g y
10:50:34 <lambdabot>   f y (f (g y) (f (g (g y)) (f (g (g (g y))) (f (g (g (g (g y)))) (f (g (g (g...
10:50:37 <orbitz> chadz: do we work at the same company? :)
10:50:50 <chadz> orbitz: doubtful ;)
10:50:55 <orbitz> hehe
10:50:57 <olsner> @google 30GB / 45 minutes
10:51:05 <lambdabot> http://www.amazon.com/Sony-DCR-SR45-Handycam-Camcorder-Optical/dp/B00123UGXK
10:51:11 <pumpkin_> lol
10:51:12 <chadz> fail
10:51:17 <lilac> > 30.0 / 0.75
10:51:19 <lambdabot>   40.0
10:51:28 <lilac> (GB / hour)
10:51:53 <Gracenotes> > foldr f 0 [1..]
10:51:55 <lambdabot>   Add a type signature
10:52:00 <lilac> @google 30GB / 45 minutes in bytes per month
10:52:01 <Gracenotes> oh, yeah :/
10:52:05 <lambdabot> http://www.amazon.com/Apple-Video-Playback-Black-Generation/dp/B000A3WS84
10:52:10 <Gracenotes> and it's infinite too, nvm
10:52:10 <Deewiant> > foldr f 0 [1..] :: Expr
10:52:11 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
10:52:34 <olsner> googling manually for the exact same string gave me 11.4MB/s
10:52:39 <lilac> 3.1374066  1013 bytes per month
10:52:51 <Gracenotes> > foldr (+) 0 [1..] :: Expr
10:52:52 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (...
10:52:58 <pumpkin_> lilac: missing a 10^?
10:53:06 <lilac> pumpkin_: missing a ^ between 10 and 13
10:53:18 <mauke> 10¹³
10:53:35 <pumpkin_> :)
10:54:51 <athos> > let m f xs = foldr ((:).f) [] xs in m (+2) [1,2,3,4]
10:54:52 <lambdabot>   [3,4,5,6]
10:55:19 <athos> > foldr f [] [a,b,c]
10:55:20 <lambdabot>       No instance for (SimpleReflect.FromExpr [a])
10:55:20 <lambdabot>        arising from a use ...
10:55:28 <athos> > foldr f z [a,b,c]
10:55:29 <lambdabot>   f a (f b (f c z))
10:55:59 <olsner> anyway, you're not done optimizing the data analysis until your script is disk bound :P
10:56:23 <olsner> so at 45 minutes you should have 2-5x more performance to squeeze out
10:56:25 <Gracenotes> :t foldr
10:56:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:56:32 <Deewiant> it's easy to pessimize something to the point that it's disk bound ;-)
10:56:43 <Gracenotes> hm, as I thought :/
10:57:02 <athos> Gracenotes: you don't know foldr already, do you?
10:57:14 <athos> http://www.cs.nott.ac.uk/~gmh/fold.ps
10:57:16 <athos> :)
10:57:23 <Gracenotes> athos: yeah, I do
10:57:28 <redditbot> HXT Arrow Lessons
10:57:28 <redditbot> Crossword puzzles in Haskell
10:57:28 <redditbot> A Game Scripting Language (In Haskell)
10:57:29 <redditbot> QuickCheck rocks my socks
10:57:31 <redditbot> Monad transformers
10:57:34 <pumpkin_> Cale has some pretty diagrams of folds and scans
10:57:35 <Gracenotes> I was just considering the type of the function passed to it
10:57:36 <pumpkin_> iirc
10:57:45 <athos> Gracenotes: oh ok!
10:57:56 <Gracenotes> how it's often (a -> a -> a)
10:57:57 <athos> Gracenotes: anyway, it's a good paper if you don't know it already :)
10:58:02 <chadz> haskell.reddit seems pretty boring
10:58:06 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
10:58:06 <chadz> not enough trolls.
10:58:10 <dons> chadz: ?
10:58:12 <dons> ah
10:58:15 <mauke> http://img145.imageshack.us/img145/863/haskelllogohg0.gif
10:58:23 <pumpkin_> chadz: same with this channel :/
10:58:28 <Cale> mauke: hehe
10:58:55 <chadz> yeah -- time to get xmonad up. pz
10:59:25 <athos> Cale: i like these :)
10:59:25 <Gracenotes> I've been looking at monoids lately... like, uh
10:59:47 <Gracenotes> > foldr mappend mempty ["a", "b", "c"]
10:59:49 <lambdabot>   "abc"
10:59:51 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
10:59:55 <athos> lol mauke :> nice logo
10:59:58 <Deewiant> > mconcat ["a","b","c"]
11:00:01 <lambdabot>   "abc"
11:00:02 <Gracenotes> yep
11:00:07 <Gracenotes> I know that one too ;)
11:00:07 <Deewiant> ?src mconcat
11:00:08 <lambdabot> Source not found. My brain just exploded
11:00:09 <Deewiant> meh
11:00:25 <Gracenotes> ?src ([]) mconcat
11:00:26 <lambdabot> Source not found. Just try something else.
11:00:28 <ski_> > msum ["a","b","c"]
11:00:29 <lambdabot>   "abc"
11:00:32 <Cale> > sortBy (comparing length `mappend` compare) (words "here are some words to sort first by length and then alphabetically")
11:00:34 <lambdabot>   ["by","to","and","are","here","some","sort","then","first","words","length"...
11:00:44 <ski_> @type L.mconcat
11:00:46 <lambdabot> Not in scope: `L.mconcat'
11:00:49 <ski_> @type mconcat
11:00:50 <lambdabot> forall a. (Monoid a) => [a] -> a
11:00:58 <ski_> @type msum
11:00:59 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
11:01:06 <ski_> .. right
11:02:28 <ski_>   mconcat = foldr mappend mempty  -- i think
11:02:49 <Gracenotes> > mconcat [1..]
11:02:51 <lambdabot>   Add a type signature
11:03:01 <Gracenotes> > mconcat [1..] :: Integer
11:03:02 <lambdabot>       No instance for (Monoid Integer)
11:03:02 <lambdabot>        arising from a use of `mconcat'...
11:03:07 <Gracenotes> D:
11:04:25 <Deewiant> > mconcat . map Sum $ [1..]
11:04:28 <lambdabot>   Sum {getSum = * Exception: stack overflow
11:04:31 <Deewiant> :-P
11:05:07 <Gracenotes> oh, yes, almost forgot about that
11:06:21 <user317> exit
11:06:28 * taari nods
11:07:05 <athos> > foldr1 (+) [1,2,3,4,5]
11:07:06 <lambdabot>   15
11:10:26 <orbitz> > 'a' :: Word8
11:10:27 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
11:10:44 <Dridus> > (toEnum.fromEnum 'a') :: Word8
11:10:45 <lambdabot>   Couldn't match expected type `a -> Int' against inferred type `Int'
11:10:57 <Dridus> ((toEnum.fromEnum) 'a') :: Word8
11:11:03 <Dridus> > ((toEnum.fromEnum) 'a') :: Word8
11:11:04 <lambdabot>   97
11:11:07 * Dridus is not so smart
11:19:17 <tomh> anyone here knows where to get pdftex for macosx?
11:19:44 <kpreid> macports
11:21:36 <tomh> ok gonna check
11:51:27 <kaol> @users
11:51:28 <lambdabot> Maximum users seen in #haskell: 568, currently: 556 (97.9%), active: 5 (0.9%)
11:56:28 <RayNbow> so... when/where can we order the "Haskell -- Wishes You Warm and Fuzzy Holidays" sweaters?
11:56:38 <RayNbow> (would be good promotional material :p)
11:57:19 <redditbot> Coroutines for Haskell
12:00:07 <ksf> @slap redditbot
12:00:08 * lambdabot pulls redditbot through the Evil Mangler
12:00:21 <ksf> teach him to post links, will you?
12:00:36 <RayNbow> http://www.reddit.com/r/haskell/comments/7kdsk/coroutines_for_haskell/
12:00:42 <chadz> ksf: 'cuz haskell.reddit.com is hard to type :)
12:11:03 <jeffersonheard> dcoutts: I fixed all my bugs from earlier.  runhaskell and the threaded runtime now work.  The problem was that I'd set "hint" to true in onMotionNotify
12:12:14 <dcoutts_> jeffersonheard: I can never remember which way round that setting goes
12:12:14 <lambdabot> dcoutts_: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:12:49 <dcoutts_> jeffersonheard: is hint=True the mode where you have to explicitly ask for the next mouse move event?
12:12:54 <jeffersonheard> yes
12:13:03 <jeffersonheard> and I was alreayd asking for it, which was the problem, I think
12:13:08 <jeffersonheard> both setting to false and asking for the hint
12:16:00 <jeffersonheard> dcoutts_: I've got the scenegraph library working pretty well now, and I added an interactive mode.  The hello world program is now 16 lines long and draws a smiley face and tracks the mouse with a red ball
12:16:13 <jeffersonheard> dcoutts_: backend is all cairo atm
12:16:17 <dcoutts_> :-)
12:16:34 <jeffwheeler> Is there any (^)-like operator that accepts floats or rationals as the exponent? I want to find the cubic root of a number.
12:16:43 <dcoutts_> jeffersonheard: great. So you're now doing all drawing from the onExpose handler and only from the onExpose handler?
12:16:47 <ski_> > 27 ** (1/3)
12:16:49 <lambdabot>   3.0
12:17:00 <jeffersonheard> dcoutts_: yes.
12:17:03 <jeffwheeler> ski_: thanks; don't know how I missed that.
12:17:03 <dcoutts_> jeffersonheard: great
12:17:35 <jeffersonheard> dcoutts_: do you know if there will ever be an OpenGL backend for Cairo on Windows?
12:17:40 <dcoutts_> jeffersonheard: keep it that way. It's the right way to use it, even for animation and everything.
12:18:23 <dcoutts_> jeffersonheard: I didn't know the opengl backend didn't work on windows, so sorry I'm clearly not in the loop on that. I'd trawl the cairo mailing lists or bug db.
12:18:32 <jeffersonheard> dcoutts_: yeah, I can tell, because my performance is better than I've seen in a long time.
12:18:48 <jeffersonheard> I think glitz just isn't portable, actually.  not a cairo bug
12:19:01 <roconnor> @src ap
12:19:02 <lambdabot> ap = liftM2 id
12:19:18 <roconnor> @src liftM2
12:19:19 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:19:20 <dcoutts_> jeffersonheard: doing it from the onExpose means Gtk+ does double buffering for you which makes things look smother.
12:19:33 <roconnor> @undo do { x1 <- m1; x2 <- m2; return (x1 x2) }
12:19:34 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (x1 x2)
12:19:47 <jeffwheeler> > 41063625 ** (1/3) -- :-/
12:19:48 <lambdabot>   344.9999999999999
12:19:55 <jeffersonheard> yeah -- I was doing the double buffering by hand.  I learned Gtk from looking at the xiangqi board you posted to your site
12:19:56 <RayNbow> ugh... someone thinks "functional programming" is something typical of a dynamic language because it appeared first in dynamic programming languages... :X
12:19:59 <jeffersonheard> and that's the way they did it
12:20:05 <jeffersonheard> or rather, that someone posted to the Gtk2Hs site
12:20:09 <dcoutts_> jeffersonheard: but it also means you only have a single rendering path, and that it works consistently between expose events generated by the window system and from your own app.
12:20:09 <dolio> Hahaha.
12:20:31 <vixey> is it clear what they even mean by dynamic?
12:20:32 <roconnor> @undo do { x1 <- m1; liftM (\x -> x1 x) m2}
12:20:33 <lambdabot> m1 >>= \ x1 -> liftM (\ x -> x1 x) m2
12:20:33 <dolio> I suppose Scheme is a "dynamic language".
12:20:39 <jowens> another n00b question, if you don't mind. "map" is very nice for iterating through a single loop (nesting level 1). How do I do an outer-product through a doubly nested loop ( forall i; forall j; function(i, j) )
12:20:51 <vixey> jowens, map
12:21:04 <eu-prleu-peupeu> hey Hppl
12:21:05 <eu-prleu-peupeu> nice logos
12:21:14 <dcoutts_> jeffersonheard: if you've got a scene graph, does that let you re-render only the bits that are exposed?
12:21:21 <vixey> jowens, well concatMap is better
12:21:29 <roconnor> @undo do { x1 <- m1; liftM x1 m2}
12:21:29 <lambdabot> m1 >>= \ x1 -> liftM x1 m2
12:21:33 <jowens> can you elaborate on how you'd do map?
12:21:37 <roconnor> @type o { x1 <- m1; liftM x1 m2}
12:21:39 <lambdabot> parse error on input `<-'
12:21:41 <roconnor> @type do { x1 <- m1; liftM x1 m2}
12:21:43 <lambdabot> Not in scope: `m1'
12:21:43 <lambdabot> Not in scope: `m2'
12:21:48 <roconnor> @type \m1 m2 -> do { x1 <- m1; liftM x1 m2}
12:21:49 <lambdabot> forall (t :: * -> *) a1 t1. (Monad t) => t (a1 -> t1) -> t a1 -> t t1
12:21:58 <jeffersonheard> dcoutts_: yes and no.  I'm working on an R-Tree so I can have arbitrarily large scene graphs where this is the case without performance issues
12:22:10 <dcoutts_> jeffersonheard: the onExpose event can give you the full region that needs to be redrawn. There's a function that decomposes a region into non-overlapping rectangles.
12:22:15 <jeffersonheard> however right now, I can check the bounding rectangles at each object and determine whether or not to render
12:22:16 <RayNbow> dolio: I try to argue that "functional programming" is a total different axis than "dynamic/static"... but the other guy doesn't buy my arguments :/
12:22:42 <dcoutts_> jeffersonheard: eg my icfp 04 ants visualiser used that to decide which cells to redraw. Much faster.
12:22:56 <jeffwheeler> > 41063625 ** (1/3) == 345.0
12:22:58 <lambdabot>   False
12:23:01 <jeffersonheard> dcoutts_: that's assuming that my invalidate call is sensible.
12:23:06 <jeffersonheard> which right now, it's not
12:23:28 <chadz> > 41063625 ** (1/3)
12:23:30 <lambdabot>   344.9999999999999
12:23:30 <ski_> > [(i,j,i+j) | i <- [0,1,2] , j <- [10,20]]
12:23:32 <lambdabot>   [(0,10,10),(0,20,20),(1,10,11),(1,20,21),(2,10,12),(2,20,22)]
12:23:32 <dcoutts_> jeffersonheard: right, invalidate the bounding box of the object, or perhaps a slightly smaller decomposition of rectangles
12:23:37 <jeffersonheard> but it will be.  problem is that that code is entirely useless for a pure opengl backend
12:23:44 <dolio> RayNbow: Considering functional languages tend to have the most static type system research going on, I'd say his position is pretty silly.
12:23:45 <ski_> jowens : ^
12:23:49 <jeffwheeler> chadz: I'm trying to test to see whether a number is a cube.
12:23:51 <jowens> ski_ : thanks
12:23:53 <jeffersonheard> dcoutts_ can it handle discontiguous rectangles?
12:23:54 <chadz> > 41063625 ** (1/3) + 0.00000000001 == 345
12:23:55 <lambdabot>   False
12:23:55 <Philippa__> RayNbow> ugh... someone thinks "functional programming" is something typical of a dynamic language because it appeared first in dynamic programming languages... :X <- OOP?
12:24:03 <dcoutts_> jeffersonheard: sure
12:24:12 <RayNbow> Philippa__: hmm?
12:24:34 <RayNbow> are you referring to Smalltalk?
12:24:35 <dcoutts_> jeffersonheard: X/Gtk+ just union them together, so they can intersect or not
12:24:45 <Philippa__> and a lot of early lisp work too, yeah
12:25:09 <RayNbow> I (don't (know) (much)) about (lisp) :p
12:25:11 <jeffersonheard> k, so it makes one larger rectangle
12:25:14 <jeffersonheard> that's what I was curious about
12:25:15 <ksf> the confusion only arises because "functional" isn't commonly read as "pure", or at least "mostly pure"
12:25:23 <jeffersonheard> whether I got a list of discontiguous rectangles or one large one
12:25:24 <ksf> it's all about the side effects, actually.
12:25:27 <mm_freak> i'm unable to find any easy introduction to functional reactive programming
12:25:41 <dcoutts_> jeffersonheard: no, it does not keep it as one big rectangle.
12:25:48 <ksf> even sicp makes that point very, very deliberately.
12:25:50 <mm_freak> a lot of long and boring papers, but no quickstart
12:25:59 <ksf> mm_freak, tell me if you found it.
12:26:08 <dcoutts_> jeffersonheard: it tracks expose regions accurately, but it can decompose them for you as a list of non-overlapping rectangles.
12:26:10 <Philippa__> some people confuse HOFs and metaprogramming/eval, too
12:26:17 <jeffersonheard> excellent
12:26:36 <mm_freak> ksf: i'm searching for days now
12:26:58 <dcoutts_> jeffersonheard: both X and Win32 have an abstract Region type for this kind of thing which is what Gtk+ wraps.
12:26:59 <blackh> mm_freak: I have a copy of The Haskell School of Expression and this book is basically a Haskell textbook but FRP is a major theme of it.
12:27:07 <mm_freak> i'm afraid i'll need to study the source code of Reactive or Fran =/
12:27:17 <mm_freak> blackh: interesting, is it free?
12:27:27 <jeffersonheard> gotcha
12:27:31 <blackh> mm_freak: I don't think so. The real gem in it is "paddleball in 17 lines".
12:28:11 <mm_freak> hmm…  currently i'm unable to spend money on printwork =/
12:28:44 <blackh> mm_freak: It gives the whole implementation of a simple declarative reactive animation system based on Fran. The book is 10 years old.
12:28:51 <jeffersonheard> dcoutts_ right now as it stands, the performance for invalidating the entire window with the scenegraph seems fine at 3860x1920, so I think I'll put off that little bit of extra intellgience for now
12:29:01 <jeffersonheard> I'm getting about 15fps
12:29:13 <dcoutts_> jeffersonheard: great
12:29:25 <mm_freak> i'll try reading the Reactive source code for now
12:29:37 <dcoutts_> jeffersonheard: a decent scene graph lib is a great project. If you have any other architecture questions do ask.
12:29:42 <jeffersonheard> if I manage to get the R-Tree integrated, then a lot of the performance problems of having an arbitrarily large scenegraph to test go away
12:30:01 <blackh> mm_freak: I ordered it an it took 3 months (!), so maybe it's not going to be the solution for you!
12:30:11 <jeffersonheard> right now, this is a 2D scene graph only.  I'm developing the 3D one separately as I need it
12:30:58 <dcoutts_> jeffersonheard: they tend to have quite different use cases and APIs I think.
12:31:31 <mm_freak> blackh: indeed, that's quite long
12:31:38 <dcoutts_> jeffersonheard: eg cairo is in some sense just a subset of OpenGL, but being 2D allows many simplifications in the API.
12:31:51 <mm_freak> blackh: but i don't really need a textbook on haskell anyway
12:32:14 <jeffersonheard> dcoutts_: Yes, exactly.  Many things are simpler, and one of the beautiful things about Cairo is the ability to render ot PDF and SVG
12:32:24 <jeffersonheard> I can take my interactive visualizations and take a snapshot in vector form
12:32:27 <ksf> conal must be incubating something. he hasn't blogged for a week now.
12:32:32 <dcoutts_> jeffersonheard: yeah, that's nice
12:32:36 <mm_freak> well, are there any FRP examples i could learn from?
12:32:55 <ksf> there's a tetris.
12:33:05 <conal> ksf: i'm nose down in some subtle bugs in Reactive.
12:33:16 <conal> i miss the blogging, though.
12:33:26 <RayNbow> Philippa__: hmm, I might not be able to use the OOP argument, if Simula is the first language in which OOP ideas appeared
12:33:58 <RayNbow> (but then again, Wikipedia is not a very trustworthy resource :p)
12:34:16 <Philippa__> RayNbow: it's a bit of a case of "what do you mean by OOP?"
12:34:40 <Philippa__> anyway, surely FP first appeared in the lambda calculus? ;-)
12:34:52 * ksf regards haskell records with function(s) of arity > 0 as objects
12:34:54 <conal> if we don't use "number graph" APIs for arithmetic, why would we use "scene graph" APIs for graphics?
12:34:56 <Philippa__> (on which lisp was explicitly based, after all)
12:35:24 <RayNbow> Philippa__: but is LC dynamic or staticly typed? :p (tough question... there are several flavors of LC :p)
12:35:34 <Philippa__> because scenes aren't numbers
12:35:34 <ksf> lisp has side effects, though.
12:35:58 <dolio> It was untyped first, and then types were added.
12:35:59 <MyCatVerbs> ksf: you don't have to use 'em at all. Heck, Haskell has unsafePerformIO.
12:36:04 <mm_freak> ksf: i don't
12:36:28 <Surma1> hey guys. why is this line  ``| abs (dy / dx) > 1 = ...'' complaining about not having no instance for (Fractional Int). dx and dy are Ints
12:36:33 <mm_freak> i regard types, which are instances of certain classes as what you would call 'classes' in other languages
12:36:40 <Philippa__> incidentally, some people /do/ use what amount to number graph APIs. That's part of what CAS is about
12:36:49 <mm_freak> instance Drawable Enemy where …
12:36:51 <MyCatVerbs> conal: 'cuz a scene graph is a pretty good metaphor for a scene in 3D space and because it's the fastest way anyone's thought of yet for renderin' them? >>
12:36:52 <ski_> Surma1 : `(/)' is not defined for `Int'
12:36:55 <ksf> well, they're a good way to tie up some data and code in a recomposable way.
12:37:23 <ski_> Surma1 : what should `dy / dx' be if `dy' was `2' and `dx' was `3' ?
12:37:40 <ksf> like, for example, when using the state monad.
12:38:06 <RayNbow> hmm, what was the first staticly typed FP language? ML?
12:38:09 <Surma1> ski_: optimal would be a fraction 2/3 ;)
12:38:12 <mm_freak> ksf: well, consider that the 'methods' would be variable then, and all the methods would need to be of the form "SomeObject -> a" explicitly
12:38:16 <jeffersonheard> dcoutts_: is there an accepted way for Cairo to draw images, like PNGs/JPGs that one loads from file?
12:38:17 <conal> as a representation, i don't mind scene graphs so much.  i prefer something more abstract/semantic as an interface, though.
12:38:33 <Dridus> Surma1: if you really want integer division, you can use div, e.g. dx `div` dy
12:38:34 <mm_freak> ksf: that's why i'd prefer the type class approach
12:38:34 <ski_> Surma1 : try s/\//%/ ?
12:38:42 <jeffersonheard> I've been using the Gtk DrawWindow API for it
12:38:56 <ski_> > (2 :: Int) % ((-3) :: Int)
12:38:58 <lambdabot>   (-2)%3
12:39:04 <ski_> @type (2 :: Int) % ((-3) :: Int)
12:39:06 <lambdabot> Ratio Int
12:39:18 <Surma1> ski_: Not in scope?!
12:39:27 <ski_> @index (%)
12:39:27 <lambdabot> Data.Ratio
12:39:34 <ski_> Surma1 : so import it
12:39:35 <ksf> mm_freak, well, the first fp program i wrote was in java, using structural recursion, and it stuck.
12:39:38 <orbitz> > 2 % 3
12:39:40 <lambdabot>   2%3
12:39:53 <orbitz> > 2%3 + 1%3
12:39:54 <lambdabot>   1%1
12:39:57 <ski_> > 1%2 + 1%3
12:39:59 <lambdabot>   5%6
12:40:01 <Surma1> ah k, thx
12:41:48 <Philippa__> conal: give or take mutability, I'm not sure there's much in it as compared to numbers anyway - a term's a term, no?
12:42:20 <dcoutts_> jeffersonheard: ideally you load or convert the image into a Cairo surface and use it as the source when you paint or draw
12:42:47 <conal> i wonder how (semantically) simple one can make a semantics-based 3D API and still have adequate functionality.
12:42:54 <dcoutts_> jeffersonheard: for .png it's easy imageSurfaceCreateFromPNG, but for other image formats you have to go via imageSurfaceCreate and set the image data.
12:43:25 <jeffersonheard> dcoutts_: that makes sense, thanks.
12:43:34 <dcoutts_> jeffersonheard: there should be a function to convert a Gtk pixmap into a cairo surface but I don't think there's a quick and easy one. If if there is it's new and we've not bound it yet.
12:43:47 <jeffersonheard> right.  i noticed :-)
12:44:22 <ski_> what's number & scene graph APIs ?
12:44:23 <dcoutts_> jeffersonheard: see http://cairographics.org/samples/ pretty much all of them translate 1:1
12:44:40 <Philippa__> conal: depends on your idea of adequate functionality, I imagine
12:45:14 <jeffersonheard> ski_: I'm in the middle of writing a 2D, purely functional and interactive scene graph API
12:45:47 <ski_> but pray tell, what is it ?
12:46:27 <conal> jeffersonheard: perhaps you're using the term "scene graph" where i'd use "geometry", i.e., an abstract type with simple semantics, rather than a inherently graph-like thing.
12:46:28 <jeffersonheard> oh.  um...  well, the idea is that you have functions that return 2D objects in some arbitrary coordinate space, and then you have another function which rasterizes those objects
12:46:54 <conal> the scene graph APIs i've seen expose the graph nature of the representation.
12:47:10 <dcoutts_> jeffersonheard: oh, I'm wrong, there's setSourcePixbuf
12:47:10 <conal> so, e.g., there are no associative or commutative operators and no identities.
12:47:34 <conal> the apis i've seen also have stateful traversal (operational) semantics.
12:47:35 <dcoutts_> jeffersonheard: so that doesn't give you a surface from a pixbuf but does set the source which is how you would paint from it
12:47:40 <jeffersonheard> conal: Yes -- this is an arbitrarily nested data structure consisting of independent scene elements
12:47:54 <jeffersonheard> ahhh, dcoutts_ thanks
12:47:57 <conal> jeffersonheard: exposing the representation or not?
12:48:09 <conal> jeffersonheard: e.g., do you have any associativity or commutative operations?
12:48:40 <jeffersonheard> conal: I'm working on graph unions and intersections right now
12:49:24 <jowens> ski_ was nice enough to post this snippet:
12:49:29 <jowens> [(i,j,i+j) | i <- [0,1,2] , j <- [10,20]]
12:49:38 <jowens> what is this feature called, this [ ] with <- ?
12:49:45 <jowens> i'm trying to look it up in my RWH book.
12:49:46 <wli> List comprehensions.
12:49:49 <conal> jeffersonheard: do you have a semantic model?  i'm still looking for one.
12:49:55 <jowens> like in python?
12:50:04 <lament> yes.
12:50:05 <Dridus> jowens: yeah, but more awesomer
12:50:35 <jowens> not just awesomer, but MORE awesomer? sign me up.
12:50:35 <jeffersonheard> conal: we're talking past each other, I'm afraid.  I'm not sure what you're looking for.
12:50:47 <jowens> also kudos to the authors that they used the word "cromulent" in their book.
12:50:51 * RayNbow wonders when lambdabot will support the MORE AWESOMER list comprehensions
12:50:54 <conal> jeffersonheard: thx.  by model, i mean something like "function of time" for animation, or "function of space" for imagery.
12:51:05 <wli> RayNbow: Monad comprehensions?
12:51:13 <conal> jeffersonheard: in other words what the type means.
12:51:28 <vixey> SQL comprehensions
12:51:47 <RayNbow> wli: for now I'll settle for http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions :p
12:51:55 <wli> Embedding a logic language for pattern matching?
12:52:04 <Dridus> jowens: darn tootin, you can do cross products and you have somewhat more power in general because functions have more power in haskell than in python
12:52:19 <jeffersonheard> conal: gotcha...  the problem is that I've put this together from a practical perspective first.  The notion of time is not exposed inside the grah
12:52:29 <jowens> cross products (outer products) is exactly what i'm looking for. w00t!
12:52:37 <lament> Dridus: you can do cross products in Python list comprehensions.
12:52:47 <Dridus> lament: oh yeah? in the same one?
12:52:54 <vixey> > liftA2 (,) "abc" "xyz"
12:52:56 <lambdabot>   [('a','x'),('a','y'),('a','z'),('b','x'),('b','y'),('b','z'),('c','x'),('c'...
12:52:59 <jeffersonheard> the function of space more or less is.  Time could be incorporated, but it's not basic, because there's a point at which I have no need for time (e.g. static visualizations)
12:53:08 <vixey> > map (\(x,y)-> x:y:[]  ) liftA2 (,) "abc" "xyz"
12:53:09 <lambdabot>   Couldn't match expected type `[(t, t)]'
12:53:16 <vixey> > map (\(x,y)-> x:y:[]  ) (liftA2 (,) "abc" "xyz")
12:53:17 <lambdabot>   ["ax","ay","az","bx","by","bz","cx","cy","cz"]
12:53:35 <lament> Dridus: [(x,y) for x in [1,2,3] for y in ['a','b','c']]
12:53:36 <conal> jeffersonheard: i'd leave time out of it.  for orthogonality/simplicity.
12:53:52 <wli> I don't see the point of the sortBy and groupBy syntax since it's so very close to the functions.
12:53:53 <vixey> > "abc"  >>= \x ->  "xyz"  >>= \y ->   return [x,y]
12:53:54 <lambdabot>   ["ax","ay","az","bx","by","bz","cx","cy","cz"]
12:53:57 <Dridus> lament: hunh, learn a new thing every day. I thought you had to do it with nesting
12:54:14 <conal> jeffersonheard: and then use it with a polymorphic notion of animation
12:54:14 <Dridus> jowens: well it's still more awesomer because haskell is awesomer, but not quite as more awesomer as I had previously thought
12:54:35 <wchogg> what's the upper bound of awesomeosity?
12:54:37 <wli> I'm not even sure it makes it all that much shorter, either.
12:54:59 <wli> I think it may even require more characters than the list functions for all this.
12:55:10 <dcoutts_> wchogg: wow dude, that is maximally awesome!
12:55:32 <Dridus> wchogg: very large, where awesome approaches infinity
12:55:55 <idnar> @src guard
12:55:56 <lambdabot> guard True  =  return ()
12:55:56 <lambdabot> guard False =  mzero
12:56:09 <jeffersonheard> conal: my thoughts exactly.  if you do a darcs get http://www2.renci.org/~jeff/software/darcs/Thingie , you'll see the library and can judge for yourself
12:56:28 <jeffersonheard> I'm still documenting the interactive part.  Or rather, I'm about to document the interactive party
12:56:30 <jeffersonheard> part
12:56:31 <jeffersonheard> haven't get
12:56:33 <jeffersonheard> yet
12:56:35 <jeffersonheard> gargh.  can't type
12:56:42 <jeffersonheard> but it's not that long.  only 562 lines
12:57:37 <Philippa__> conal: do you want a model for graphics, or for geometry?
12:58:21 <conal> jeffersonheard: if you're interested in the semantic design aspect, please let me know.  it something i've been puzzling over.  what i like is that it gives a definition of implementation correctness and a way to measure the simplicity/generality/gracefulness of the design that's independent of the implementation.
12:58:32 <conal> Philippa__: as in rendering vs modeling?
12:58:49 <jeffersonheard> conal: one thing I have a problem with is that since for my interactive library, I'm using functions that return objects rather than objects themselves, I have the notion of an "unbounded" object
12:59:08 <Philippa__> conal: yeah, though modeling isn't the only other use
12:59:20 <jeffersonheard> everything else has a minimum bounding rectangle, and exists in a "real" euclidean 2D space
12:59:46 * wli is trying to get a model of pieces of sparse matrices enabling swifter search than linked lists of a disorganized mixture of diagonal bands and blocks (potentially nested into things of the same sort).
12:59:58 <wchogg> conal : so are you essentially looking for a good way to represent smooth manifolds in Haskell?
13:00:30 <jeffersonheard> wli: depending on your application, there's a few papers about that in terms of applying them to information retrieval tasks
13:00:31 <wli> If the bounding rectangles are coordinate-aligned, band diagonal matrices don't have useful bounding rectangles.
13:00:34 <conal> jeffersonheard: i expect a focus on semantics would really help make these questions clear.
13:00:36 <jeffersonheard> search on the name Nazli Goharian'
13:00:49 <jeffersonheard> conal:  I'd love to work with you on it.
13:01:29 <jeffersonheard> I've got a couple of things breweing for ICFP09, one of which is a functional R-Tree data structure that is lazy for a significant number of cases
13:01:46 <jeffersonheard> but they all work together, since the goal of this is a geographic information visualization system
13:02:01 <jeffersonheard> a prototype of which I already have
13:02:05 <wchogg> R-Tree?
13:02:08 <jeffersonheard> but it's a hack
13:02:09 <wli> I'm not sure if R-trees can represent coordinate-unaligned rectangles.
13:02:50 <jeffersonheard> wchogg: Region tree -- primary indexing structure for geographic databases
13:02:56 <jeffersonheard> TV-Tree for higher dimensional data
13:03:43 <jeffersonheard> wli: meaning?
13:04:40 <conal> wchogg: i'm looking for a precise and elegant semantic model for what low-level graphics APIs and hardware render.
13:04:48 <ksf> what's the correct way to say "the unit's path", but for "unit" being plural? "units's"?
13:05:05 <conal> ksf: units'
13:05:16 <ksf> thanks
13:05:26 <conal> :)
13:05:57 <jeffersonheard> Conal, I think APIs and hardware are very different in this case
13:06:30 <conal> jeffersonheard: me too.  and i'm not trying to match either one.
13:06:39 <jeffersonheard> one would be more like formalizing a model for something like the GDI.  The other's formalizing notions of "fragments", "vertices", etcetera
13:06:43 <jeffersonheard> gotcha
13:08:29 <conal> jeffersonheard: i'm going for something much more elegant than a formalization of current APIs or hardware.  rather a (purely functional) model/api that is simple/general/composable that can exploit most or all of what the hardware (or exposed interfaces) can do.
13:09:44 <jeffersonheard> conal: Have you looked at OpenSceneGraph?  I'm not sure, but I believe there are a few papers toward the beginning of the project that formalized what it could do and was about
13:10:00 <jeffersonheard> and to my knowledge, there's very little you can do with hardware that you can't with OSG
13:12:06 <jeffersonheard> I understand what you're getting at, though, because with such a model, we could create functional programs for graphics without resorting to the egregious things we have to resort to right now, and create a specification formally that hardware could be designed for
13:12:12 <jeffersonheard> rather than the other way round
13:12:36 <conal> jeffersonheard: yes :)
13:12:41 <conal> jeffersonheard: i doubt i'd find anything like what i'm looking for in an existing API, especially an imperative one.  for instance, i wouldn't use faceted models.
13:12:48 <conal> jeffersonheard: i'd use ideal continuous ones.
13:12:57 <jeffersonheard> conal: understood.  Just thought it might be a jumping off point
13:13:01 <conal> and relegate tessellation to the implementation, rather than the api.
13:13:04 <conal> jeffersonheard: oh, okay.
13:14:44 <jeffwheeler> @djinn (Eq a) => a -> [a] -> [(a, a)]
13:14:45 <lambdabot> Error: Undefined type []
13:14:50 <jeffwheeler> Shucks.
13:15:16 <dons> ?users
13:15:16 <lambdabot> Maximum users seen in #haskell: 573, currently: 571 (99.7%), active: 21 (3.7%)
13:17:29 <conal> has anyone here thought about or played with garbage collection of threads?
13:17:37 <conal> for speculative execution
13:19:07 <thetallgu1> Anyone seen an error like this from ghci 6.8.x?
13:19:15 <conal> i realized this morning that the explicit thread-killing technique i used for unambiguous choice library (http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice/) doesn't terminate nearly enough threads.
13:19:24 <thetallgu1> During interactive linking, GHCi couldn't find the following symbol:
13:19:24 <thetallgu1>   base_DataziTuple_Z290T_con_info or base_DataziTuple_Z290T_static_info
13:19:24 <thetallgu1> This may be due to you not asking GHCi to load extra object files,
13:19:30 <conal> but a GC-like technique might.
13:20:57 <cpriester> Hello.
13:21:13 <cpriester> what is wrong with that piece of code:
13:21:15 <cpriester> main =
13:21:15 <cpriester> 	listenOn (PortNumber 5555) >>= (\s ->
13:21:15 <cpriester> 		(sequence $ repeat (accept s))
13:21:15 <cpriester> 		>>= (mapM_ handleRequest)
13:21:18 <cpriester> 	)
13:21:29 <cpriester> I thought, it should answer request by request on the network
13:21:35 <conal> maybe something akin to Henry Baker's paper "The Incremental Garbage Collection of Processes" (ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-454.pdf)
13:21:52 <sjanssen> cpriester: sequence $ repeat (accept s) will never terminate
13:22:02 <cpriester> yes. that is right.
13:22:17 <cpriester> my servers arent to terminate.
13:22:18 <sjanssen> therefore the result will never be passed to mapM_ handleRequest
13:22:43 <cpriester> well, something like getContents >>= lines >>= mapM_ also works
13:22:50 <cpriester> and reads input linewise
13:22:59 <sjanssen> cpriester: getContents is special, it uses unsafeInterleaveIO
13:23:02 <cpriester> without having all the input
13:23:10 <cpriester> Ah, ok.
13:23:29 <sjanssen> sequence_ $ repeat (handleRequest =<< accept s)
13:23:52 <Cale> :t forever
13:23:52 <mauke> @index forever
13:23:53 <lambdabot> bzzt
13:23:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:24:05 <Cale> Control.Monad, of course :)
13:24:26 <roger_w> ll
13:25:15 <opqdonut> :t fix (action >>)
13:25:16 <lambdabot> Not in scope: `action'
13:25:24 <opqdonut> :t fix (?action >>)
13:25:25 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?action::m a) => m b
13:26:29 <idnar> b??
13:26:36 <idnar> :t (?action >>)
13:26:37 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?action::m a) => m b -> m b
13:26:40 <cpriester> Ah, ok. That works.
13:26:42 <idnar> oh
13:26:46 <cpriester> And what is sequence_ ?
13:26:51 <idnar> :t (>>)
13:26:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:26:54 <cpriester> (forever works)
13:27:02 <idnar> @src sequence_
13:27:02 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:27:39 <idnar> sequence_ strings a list of actions together, ignoring the results
13:27:58 <cpriester> Ah, sequence stores results, ok
13:28:25 <cpriester> but sequence_ did not work in my case.
13:28:31 <cpriester> while forever did
13:29:50 <idnar> sequence_ takes a list of actions, forever just takes a single action to repeat
13:30:06 <idnar> @src forever
13:30:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:30:19 <Martijn> :type sequence . repeat
13:30:19 <Cale> forever x = x >> forever x
13:30:33 <Martijn> @type sequence . repeat
13:30:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
13:31:02 <idnar> hmm, docs say forever :: Monad m => m a -> m b
13:31:10 <cpriester> i do not see, why sequence_.repeat should not also work with that definitions
13:31:12 <dolio> > let repeatM = sequence . repeat in (repeatM ask) 5
13:31:13 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
13:31:31 <idnar> :t sequence_.repeat
13:31:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:32:15 <Martijn> Well I guess since it repeats forever it doesn't matter what it returns.
13:32:35 <cpriester> yes, but what is the difference to forever?
13:32:35 <jeffwheeler> > let fractions to = break (==(3%7)) $ sort [n % d | d <- [1..to], n <- [1..d-1], gcd n d == 1] in last . fst . fractions $ 1000000
13:32:51 <lambdabot>   thread killed
13:33:12 <Martijn> It's convenient when you call it. Since you expect it will be the last statement in a do-block, and it can adapt to any type that is expected of the block.
13:33:28 <jeffwheeler> I wouldn't have expected that to be so bad, but it's quite innefficient.
13:33:31 <jeffwheeler> * inefficient
13:34:36 <Dridus> sequence_.forever won't return because it doesn't use mfix right, so it just spins accumulating an infinite sequence of actions to bind?
13:34:59 <Dridus> scratch mfix, my mistake
13:35:07 <cpriester> i meant the difference between sequence_ . repeat and forever
13:35:11 <cpriester> not seuqence_ .  forever
13:35:38 <Dridus> uh yeah, I meant to say sequence_.repeat
13:35:46 <sjanssen> forever rinse = fix $ \repeat -> do rinse; repeat
13:36:00 <dolio> sequence_ . repeat should be the same, I think...
13:36:09 <dolio> Roughly.
13:37:13 <cpriester> hm, ok.
13:37:22 <sjanssen> @src forever
13:37:22 <lambdabot> Source not found. My mind is going. I can feel it.
13:37:27 <dolio> sequence_ (repeat foo) = foldr (>>) (return ()) (repeat foo) = foldr (>>) (return ()) (foo : repeat foo) = foo >> foldr (>>) (return ()) (repeat foo) = foo >> sequence_ (repeat foo)
13:37:36 <dons> forever a = a >> forever a
13:37:52 * sjanssen preferse the rinse/repeat version :)
13:38:27 <dolio> So, aside from the types, it looks the same to me.
13:39:05 <sjanssen> forever = fix . (>>)
13:39:13 <Martijn> That's scary
13:39:51 <cpriester> what is fix?
13:39:53 <Martijn> @type fix . (>>)
13:39:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:39:59 <mauke> @src fix
13:40:00 <lambdabot> fix f = let x = f x in x
13:40:34 <cpriester> and what does that mean? :)
13:40:43 <mauke> exactly what it says
13:40:53 <mauke> call a function with its own result as argument and return it
13:41:01 <dmhouse> cpriester: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
13:41:04 * ksf still wants a RWH chapter on reactive
13:46:13 <orbitz> I'm trying to get the average time an operation took. so i'm doign diffUTCTime and then i wan to do thatDiff / length mylist. however it doesn't liekthe Int vs NominalDiffTime.  in the shell i can do thatDiffTime / 10 successfully.  do i have to convert he result of length to something?
13:46:55 <dolio> use genericLength
13:47:05 <dolio> or fromIntegral
13:47:30 <orbitz> thanks
13:50:44 <orbitz> compiling a file with several 10k elements in a Map.fromList in windows under cygwin doesn't appear to have been my best move
13:54:00 <roconnor> "cabal-install only installs 1.2 because QC 2 breaks a lot of packages"
13:54:02 <roconnor> WTF?
13:54:16 <roconnor> has quickcheck been special cased?
13:54:21 <dcoutts_> roconnor: no
13:54:33 <dcoutts_> roconnor: we've added general support for version preferences
13:54:42 <roconnor> who says 1.2 is prefered?
13:54:50 <dcoutts_> to help manage when package authors don't specify constraints properly
13:55:11 <dcoutts_> roconnor: more packages that do not say which version they need build with 1.2 than with 2
13:55:32 <roconnor> so the packages voted?
13:55:47 <dcoutts_> hopefully authors uploading packages since the release of QC 2 are using a proper version constraint
13:55:57 <dcoutts_> roconnor: in a sense yes.
13:56:17 <roconnor> and when the vote changes, then all the packages will break?
13:56:36 <dcoutts_> roconnor: of course packages should be using lower and upper bounds on version numbers so that this should not be a problem
13:56:44 <roconnor> on the surface, this seems like a retartded policy
13:57:00 <dcoutts_> roconnor: why? does it prevent you doing anything you like?
13:57:03 <roconnor> the package versions won't be fixed because the fact that they are broken is hidden
13:57:20 <redditbot> Turbinado update | Alson Kemp
13:57:20 <redditbot> Wadler's Blog: Type Safe Pattern Combinators, by Morten Rhiger
13:57:20 <redditbot> lojbot in Haskell
13:57:27 <kosmikus> dcoutts_: maybe Cabal should give a QA warning for missing upper bounds?
13:57:30 <dcoutts_> roconnor: would you prefer that all of hackage had broken with ghc-6.10 was released?
13:57:36 <dcoutts_> kosmikus: yes it should
13:57:38 <roconnor> yes
13:58:00 <dcoutts_> roconnor: well I think the vast majority of users disagree with you, though that's only a hunch.
13:58:02 <kosmikus> dcoutts_: but I'm always unsure whether to give upper bounds, too, if the new version hasn't been released. because it's overly pessimistic in most cases.
13:58:06 <roconnor> you oculd be right
13:58:16 <roconnor> I understand you are in an impossible situation
13:58:27 <roconnor> because the whole concept of versioning of packages is broken
13:58:43 <dcoutts_> kosmikus: the solution is to make it easier to tweak the deps later, then the cost of the pessimism is lower
13:58:47 <kosmikus> roconnor: what do you suggest instead?
13:59:17 <dcoutts_> roconnor: oh sure, package versions and version constraints are just proxies for detailed interface specifications and subtype relations between them.
13:59:21 <roconnor> I understand they are working on checking if interfaces between packages match
13:59:24 <kosmikus> dcoutts_: yes, indeed. but it's good to know that the policy is to *always* use upper bounds.
13:59:53 <kosmikus> roconnor: "they" being?
13:59:54 <roconnor> dcoutts_: does cabal warn when there is no version upperbound?
13:59:58 <dcoutts_> kosmikus: I think that initially we'll require upper bounds on base, that will help the majority of problems
14:00:20 <dcoutts_> kosmikus: then next we'll enable packages to opt-in to the versioning policy and then we can warn about open ranges on those packages.
14:00:25 <dcoutts_> roconnor: not yet
14:00:34 <kosmikus> I'd really like for Haskell to have language support for module interfaces.
14:00:35 <roconnor> kosmikus: I think dcoutts et al. have at least thought about it.
14:00:55 <conal> amen!
14:01:08 <roconnor> kosmikus: um, Haskell does have module interfaces, more or less
14:01:12 <dcoutts_> kosmikus: me too, so long as it is sufficiently lightweight. Packaging is partly a language problem. It's all about composing programs.
14:01:21 <kosmikus> roconnor: no, they're just an implementation accident ;)
14:01:38 <roconnor> kosmikus: is an export list not an interface
14:01:52 <kosmikus> well, in a very limited form
14:02:04 <kosmikus> but there's no way to give it a name
14:02:12 <kosmikus> and you can't add type signatures to the export list
14:02:30 <roconnor> huh?
14:02:32 <roconnor> modules have names
14:02:37 <roconnor> functions have signatures
14:03:36 <kosmikus> you can derive an interface from all the information that's there
14:03:56 <kosmikus> but you can't specify it properly, in one place
14:03:58 <cpriester> Time for bed for me now. Thanks for your help! Bye
14:04:04 <kosmikus> if I can give a name to a list of names and type signatures
14:04:07 <roconnor> properly?
14:04:10 <kosmikus> then say my module should export that interface
14:04:15 <dcoutts_> kosmikus: and that's something we should try doing to validate version numbers and constraints.
14:04:20 <kosmikus> then I get much better error messages as soon as I break it
14:04:26 <roconnor> kosmikus: meh
14:04:31 <kosmikus> the same for imports
14:04:36 <dcoutts_> kosmikus: though of course in the real world people use cpp too which messes everything up
14:04:41 <kosmikus> you can say that you want a certain function
14:04:49 <kosmikus> but you can't say what type you expect it to have
14:05:00 <roconnor> kosmikus: that would be nice, but not needed to have hackage and cabal work properly
14:05:15 <kosmikus> I agree.
14:05:42 <roconnor> <kosmikus> but you can't say what type you expect it to have
14:05:43 <roconnor> oh
14:05:45 <roconnor> that is a good point
14:05:48 <roconnor> I never thought of that
14:05:50 <kosmikus> I was just saying that if people are working on hacking up something that works externally for Hackage, they might as well write a proposal to do it properly within the language :)
14:06:33 <kosmikus> roconnor: aren't you a Coq programmer? ML-like module systems have this feature, of course.
14:06:55 <roconnor> I know very little about ML modules
14:07:04 <eu-prleu-peupeu> hello Hppl
14:07:09 <eu-prleu-peupeu> i wish i was like you Hppl
14:16:15 <hydo> holy crap, it's Mr_Awesome
14:16:26 <Mr_Awesome> holy crap!
14:16:58 <Mr_Awesome> hydo, what should i program in haskell today?
14:17:41 <dons> a mighty lambda robot!
14:17:47 <dcoutts_> @yarr!
14:17:48 <lambdabot> Shiver me timbers!
14:17:52 <hydo> You should write something that takes a gnome theme and turns it into a usable xmonad.hs, complete with fonts, colors, etc.
14:18:11 <hydo> You have your orders, soldier!  Go go go!
14:18:37 <hydo> (at least I'm enthusiastic about the work i'd like -you- to do)
14:19:38 * dcoutts_ adds cabal install foo --preference='bar < 2'
14:19:55 <dcoutts_> dons: ^^ we can now specify constraints and preferences for cabal install
14:20:07 <dcoutts_> on the command line and persistently in the config file
14:20:16 <dcoutts_> though the latter is less than ideal atm
14:20:49 <dcoutts_> we should in theory be able to specify installed constraints and prefs too but that's not hooked up yet
14:21:07 <dcoutts_> ie require that we pick the installed version of a package, ignoring available versions from hackage
14:23:03 <hydo> dons: is there a pdx haskell group?
14:23:14 <hydo> (assuming you're the guy in pdx)
14:25:56 <chrisdone> anyone know if there's a way to get the elments of a Html value in Text.XHtml.Strict?
14:26:12 <chrisdone> er, s/elments/attributes
14:27:21 <dons> hydo: yeah, pdxfunc
14:28:37 <chrisdone> I wonder why getHtmlElements isn't exported, when it is in Text.Html
14:32:54 <hydo> dons: awesome... I have a feeling i'll make more of those meetings than I will seafunc.
14:36:18 <opqdonut> ?yarr
14:36:18 <lambdabot> Yo ho ho, and a bottle of rum!
14:36:28 <opqdonut> quite so
14:36:37 <malouin> anyone know any who happen to be working on EC crypto in haskell?
14:36:40 <chrisdone> Prelude Text.XHtml.Strict> let [HtmlTag _ attrs _] = getHtmlElements (textfield "input0") in attrs
14:36:40 <chrisdone> [type="text",name="input0",id="input0"]
14:36:41 <chrisdone> there we go
14:37:00 <chrisdone> can I upload this change to hackage?
14:37:11 <chrisdone> I'll email Bjorn and ask him pretty please
14:38:00 <opqdonut> chrisdone: is that a bug or?
14:38:33 <chrisdone> opqdonut: that's something I just added by exporting getHtmlElements and HtmlElement(..)
14:38:36 <jeffersonheard> how do I export a bunch of modules from a higher module?
14:38:57 <jeffersonheard> like...  Graphics.Rendering.Thingie should export all the symbols from Graphics.Rendering.Thingie.*
14:39:00 <chrisdone> opqdonut: someone emailed me with a good point that using Text.XHtml with formlets would be more useful if it supported this
14:39:42 <opqdonut> chrisdone: oh okay
14:39:46 <twanvl> jeffersonheard: module Stuff (module Stuff.More, otherThing) where ...
14:40:20 <chrisdone> opqdonut: consider an input field and a label for it. it should be <label for="input0"> <input id="input0">, but we need to know what the id of the input formlet is before we can generate the label. you see? it remains composable, too
14:40:26 <jeffersonheard> thanks
14:41:10 <opqdonut> chrisdone: yeah
14:41:11 <chrisdone> opqdonut: er... <label for="input0"/> <input id="input0"/>, you get the idea
14:49:42 <athos> :t fmap
14:49:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:49:49 <athos> :t (=<<)
14:49:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:50:48 <athos> hmm.. perhaps that's a dumb question, but what's the big difference between monads and functors? how are they related (in haskell)? seems like they have something in common
14:50:55 <athos> like the one is the more general version of the other
14:51:07 <sjanssen> athos: all monads are functors
14:51:30 <sjanssen> in a theoretical sense.  The Monad type class doesn't actually enforce this
14:53:09 <chrisdone> :t fmap
14:53:10 <chrisdone> :t liftM
14:53:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:53:12 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:54:30 <chrisdone> you could have: class Functor m => Monad m where ... and make Functor a superclass of Monad, but it's just not done that way
14:55:14 <athos> ok, thanks chrisdone and sjanssen
14:55:55 <user317> windows cariage returns + perforce on linux + patch == suicide note
14:55:58 <alsonk> @seen dons
14:55:58 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 28m 37s ago.
14:56:10 <alsonk> dons: is plugins working with 6.10?
14:56:24 <dons> nope
14:56:27 <dons> oh maybe
14:56:33 <opqdonut> :D
14:56:39 <dons> no, prob. not. due to cabal.
14:56:42 <dons> please us ghc-api
14:56:59 <Dridus> dons, alsonk: no, it won't compile with Cabal-1.6 right now
14:57:12 <Dridus> dons: plugins is not required anymore?
14:57:24 <dons> for?
14:57:25 <alsonk> dons: doh.  so switch to ghc-api.  Is it relatively compatible or clear how to do so?
14:57:31 <dons> no, its not clear yet.
14:57:46 <dons> there is no plugins-on-ghc-api, though most of the code needed is there.
15:04:55 <mapreduce> dons: Is the twitter user Real World Haskell yourself by any chance?
15:05:02 <dons> its all 3 of us.
15:05:07 <mapreduce> Ah.
15:05:22 <mapreduce> I've never had a book follow me before.
15:05:49 <chrisdone> what about thrown at you?
15:07:07 <dons> mapreduce: likely it'll just be updates/announcements on an irregular basis
15:07:27 <dons> secret chapters, hidden candy surprises etc.
15:08:10 <mapreduce> Like "the first letter of each chapter spells out the words 'actually I prefer ocaml'" etc.?
15:09:12 <hydo> haha
15:09:30 <dons> sssh.
15:09:32 <dons> its a secret.
15:09:35 <vixey> weird sort of relation with ocaml/haskell
15:09:45 <vixey> it's totally different with lisp/scheme
15:09:46 <dons> vixey: i'm not sure there's much relation.
15:10:02 <dons> maybe a little overlap
15:10:10 <vixey> dons, I mean a social relation
15:10:11 <mapreduce> You probably mean common lisp/scheme.
15:10:31 <vixey> dons, like every haskell newbie from here coming into #ocaml asking "why do you use ocaml instead of haskell"
15:10:41 <dons> yeah, its a mystery :)
15:10:53 <dons> and the banned trolls living in #ocaml.
15:10:54 <mapreduce> CL people are amazing, they have all this stuff to help them write functional code, but they actually prefer OOP.
15:11:08 <vixey> but this doesn't happen at all with lisp/scheme or any other that I know
15:11:10 <mapreduce> dons: Is Harrop a banned troll?
15:11:19 <Pseudonym> mapreduce, I think there's a good reason for that.
15:11:21 <dons> i'm not sure he uses irc
15:11:35 <mapreduce> He does.  I've seen him as jgh030 or something
15:11:40 <dons> vixey: you mean, schemers don't ask lispers what's up with them?
15:11:45 <vixey> yes
15:11:51 <Pseudonym> Schemers and Lispers get along.
15:11:51 <dons> interesting.
15:12:02 <dons> Pseudonym: while we just don't care about the ocamlerS?
15:12:04 <vixey> people don't have this attitude lke "omg lisp sucks why aren't you all usinc scheme?"
15:12:09 <Pseudonym> They even tolerate Pau lGraham.
15:12:13 <vixey> but a lot of haskell newbies have it I wonder why
15:12:29 <dons> i'd wonder why someone would use Clean, over Haskell, too, fwiw.
15:12:32 <Pseudonym> The thing is, I think that most Haskellers have a deep respect for O'Caml.
15:12:38 <dons> and ocaml's becoming something of a Clean.
15:12:39 <Pseudonym> It was practical before Haskell was.
15:12:41 <vixey> oh I'm not really asking about language choice
15:12:51 <vixey> but point of view of people from their language of choice
15:13:02 <mapreduce> #lisp is quite critical of Paul Graham.
15:13:11 <dons> yeah, there's a respect, but now its this massive community activity disparity.
15:13:11 <Pseudonym> Is it?
15:13:19 <Pseudonym> OK, I can see that.
15:13:23 <agcorona> do someone has complied the latest versions of plugins under windows?
15:13:23 <Pseudonym> ?quote recursion
15:13:23 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
15:13:47 <mapreduce> They don't deny the quality of his books though.
15:14:04 <dons> vixey: i guess to new people, they've never heard of ocaml, but they see all this activity around haskell, so they wonder
15:14:09 <Pseudonym> Lispers being condescending about Paul Graham is probably the final word in self-reference.
15:14:12 <dons> vixey: while the older hands remember when ocaml was the big game
15:14:35 <Pseudonym> Yeah.
15:14:41 <BONUS_> woo, tons of logos up
15:14:47 <BONUS_> nice
15:14:54 <Pseudonym> Typeful FPers, generally speaking, have a deep respect for the ML family.
15:15:04 <mapreduce> Pseudonym: I expect it's similar to Ocaml people deriding Harrop.
15:15:21 <dolio> Do they?
15:15:32 <Pseudonym> Hell, we invoke the name of Robin Milner so often, we put it in a abbreviation.
15:15:32 <mapreduce> I hope they do. :)
15:16:21 <Pseudonym> I can't think of any Haskellers that we deride.
15:16:26 <Pseudonym> The Haskell community is really damn polite.
15:16:32 <mpeter> you deride me
15:16:34 <Pseudonym> In that respect, anyway.
15:16:37 <Pseudonym> True, mpeter sucks.
15:16:39 <mpeter> my self-esteem is at an all-time low as a result
15:16:41 <Pseudonym> But apart from him.
15:16:47 <dons> mpeter rocks!!
15:16:52 <dolio> Bulat.
15:16:53 <Pseudonym> mpeter++
15:17:03 <vixey> @quote Bulat
15:17:03 <lambdabot> Bulat says: we can also rename Pascal to Blez to avoid confusion
15:17:05 <mpeter> since when you can increment in haskell
15:17:14 <vixey> @quote Bulat
15:17:14 <lambdabot> Bulat says: Haskell was developed with goal to hide implementation details from egg-headed scientists and this obviously should have some drawbacks
15:17:17 <dons> its in the IRC monad
15:17:32 <mpeter> @karma mpeter
15:17:33 <lambdabot> You have a karma of 1
15:17:36 <mpeter> yay
15:17:38 <vixey> I don't know any history if this Bulat guy
15:17:51 <dons> no one does.
15:17:54 <dolio> He just pops up on the mailing list every so often.
15:17:59 <dolio> Saying crazy things.
15:18:04 <dons> he was created fully formed in kazakhstan
15:18:05 <chrisdone> haha, bulat
15:18:10 <bos> he seems to be smart, but prone to weird histrionics.
15:18:11 <dons> with no dsl
15:18:19 <bos> a bit like andrew coppin.
15:18:19 <vixey> histrionics is a cool word
15:18:27 <mapreduce> I wonder whether the politeness in the Haskell community is actually down to shapr, even outside of IRC.
15:18:33 <BONUS_> hello my name-a bulat
15:18:34 <dons> no, its a founder thing.
15:18:35 <chrisdone> bos: a bit like xah lee?
15:18:41 <ddarius> bos: Andrew Coppin doesn't seem to be smart.
15:18:47 <dons> SPJ, Wadler et al, super friendly
15:18:47 <bos> well, xah lee is batshit insane.
15:18:54 <Pseudonym> Yes, that's true.
15:18:56 <dolio> :)
15:18:57 <bos> ddarius: i was trying to be nice,
15:19:02 <Pseudonym> Larry Wall is super friendly, too.
15:19:03 <ddarius> bos: I don't.
15:19:17 <bos> ddarius: you don't what?
15:19:23 <ddarius> bos: Try to be nice.
15:19:27 <bos> Pseudonym: larry thinks that haskell is the spawn of the devil.
15:19:32 <bos> ddarius: i know :-)
15:19:34 <dons> how ironic :)
15:19:56 <mapreduce> Perl 6.  Built on devilspawn.
15:20:08 <mpeter> pugs is written in haskell ;)
15:20:09 <Pseudonym> bos: I didn't know that Larry believed in the devil.  I thought he was postmodern.
15:20:12 <chrisdone> haskell interest is on the up, perl interest is going down? (note, interest, not usage)
15:20:20 <mapreduce> mpeter: My point. :)
15:20:24 <bos> Pseudonym: larry is a committed christian.
15:20:29 <mpeter> that's always a bad sign for a language
15:20:40 <mpeter> except for when it's a good sign
15:20:44 <BONUS_> i thought larry wall liked haskell?
15:20:44 <mpeter> what's hugs written in again
15:20:48 <dolio> C
15:20:50 <Pseudonym> bos: But a postmodern one.
15:20:51 <bos> perl is dead. the only people who write perl now are people who learned it in 1995.
15:20:52 <orbitz> is there an idiom for memoization?
15:21:02 <mpeter> bos, i've written perl for NLP
15:21:14 <mpeter> it's one step from shell scripting
15:21:14 <Pseudonym> Anyway.  So what does he think of Pugs?
15:21:19 <vixey> yeah ... nobody uses perl these days  LOL
15:21:21 <chrisdone> bos: is thatn an accurate statement based on evidence or just hopeful sentiment?
15:21:24 <cjb> orbitz: http://www.haskell.org/haskellwiki/Memoization
15:21:24 <Pseudonym> mpeter: Actually, it's several steps from shell scripting.
15:21:35 <Pseudonym> More or less: sh -> sed -> awk -> perl
15:21:36 <orbitz> cjb: thanks
15:21:39 <bos> chrisdone: i try not to base any statements on evidence.
15:21:43 <dons> bos, i got my arse handed to me on reddit when i suggested noone would use perl as a general purpose lang.
15:21:44 <hydo> for a dead language, it sure is paying me well.
15:21:47 <mpeter> oh well
15:21:49 <hydo> damn commas
15:21:52 <mpeter> don't haskell programmers make
15:21:55 <mpeter> obscene amounts of money
15:21:56 <mpeter> on average
15:22:01 <Pseudonym> Perl isn't dead.  Just try to build GHC some time.
15:22:03 <mpeter> like 200k, i think i read
15:22:06 <chrisdone> haha, what kind of stereotype is that?
15:22:06 <bos> dons: lucky for you your arse is immutable.
15:22:09 <chrisdone> (a good one?)
15:22:11 <Pseudonym> The evil mangler is still evil.
15:22:22 <dons> my immutable arse is invulnerable to their effects, yes.
15:22:42 <mapreduce> Pseudonym: Building ghc requires perl?
15:22:42 <Pseudonym> Not in the body rearrangement monad, it isn't.
15:22:51 <dons> but if someone wanted to use perl at galois, they'd get their arse handed to them.
15:23:03 <Pseudonym> dons: Even as a substitute for a shell script?
15:23:11 <dons> no, that's acceptable :)
15:23:14 <Pseudonym> Right.
15:23:15 <dons> not as a general purpose thing.
15:23:20 <pejo> bos, I write perl, and I learned it in 2000-something.
15:23:22 <Pseudonym> I've been known to prototype Haskell code in Perl.
15:23:29 <dons> so its returned back to its DSL origins
15:23:34 <dons> as a shell thingy
15:23:36 <mpeter> does anybody know the link to that page i'm talking about
15:23:40 <mpeter> where programmer pay by language is listed
15:23:40 <Pseudonym> If it's a Perl-type job, like line-by-line text munging.
15:23:41 <chrisdone> bos: see! a contradictory case! refuted!!
15:24:01 <dolio> The one where "unemployed" makes like 40 grand?
15:24:11 <mpeter> maybe
15:24:20 <Pseudonym> dolio: Cool, I'd be willing to work three jobs.
15:24:24 <mpeter> i miht be thinking of ada instead of haskell
15:24:28 <dolio> Yeah.
15:24:58 <pejo> mpeter, a lot of haskell programmers are employed by investment banks, and they have a phd degree. It's not really comparable to the local php programmer that does a web forum.
15:25:24 <mapreduce> I'm more likely to chain grep and sed together in unreadable ways than to use Perl.
15:25:25 <mpeter> hopefully someday haskell will be used for something which doesn't exploit people
15:25:49 <mapreduce> And when it gets beyond what I can do with grep and sed I use Scala currently, though Haskell seems reasonable for that.
15:25:50 <jeffwheeler> dons: the GHC website (http://haskell.org/ghc/distribution_packages.html) says you're the OpenBSD maintainer of GHC. If this is true, can you make 6.10 available? 6.6 seems really old.
15:25:51 <Pseudonym> mpeter: You mean like automobile ignition systems?
15:26:02 <dons> jeffwheeler: its not true.
15:26:11 <jeffwheeler> dons: :(
15:26:12 <dons> jeffwheeler: it was until about 2 years ago
15:26:13 <Pseudonym> Or did you mean VLSI design?
15:26:25 <mpeter> Pseudonym: basically everything except investment banking
15:26:25 <jeffwheeler> dons: I feared that was the case.
15:26:27 <dons> the current maintainer is kili, matthias killian
15:26:33 <Pseudonym> mpeter: Talk to Galois.
15:26:34 <dons> who has various binaries handy
15:26:36 <mpeter> besides, i thought java was the language of choice at huge international banks
15:26:45 <jeffwheeler> dons: yeah, but there appears to be no interest in upgrading until 6.12, "fall 2009"
15:26:46 <chrisdone> how do you pronounce ``Galois''?
15:26:53 <dons> gal-wah
15:27:00 <mpeter> who is galois?
15:27:02 <chrisdone> ah
15:27:06 <doublec> wow, I've been saying it wrong :)
15:27:07 <Pseudonym> ?go evariste galois
15:27:10 <lambdabot> http://en.wikipedia.org/wiki/%C3%89variste_Galois
15:27:10 <lambdabot> Title: Évariste Galois - Wikipedia, the free encyclopedia
15:27:23 <mpeter> does he come here?
15:27:23 <Pseudonym> Is it gall-wah, or gahl-wah
15:27:24 <Pseudonym> ?
15:27:29 <mpeter> ;)
15:27:40 <dons> he's like the Chuck Norris of the 19th century
15:27:41 * chrisdone has shown himself to be 'neducated again
15:27:50 <dons> or the Jim Morrison
15:27:51 <Pseudonym> Yeah, he was a badarse.
15:27:53 <dons> pick one.
15:27:59 <Pseudonym> The Jimmy Dean of maths.
15:28:02 <dons> yeah
15:28:05 <chrisdone> or the Ray Mears?
15:28:16 <lament> galois was not much of a chuck norris
15:28:22 <dons> he'll get all crypto on your arse
15:28:27 <lament> if he were, he'd have time to do much more math
15:28:37 <dons> ok. so more  james dean
15:28:51 <lament> rebel without a cause
15:29:03 <augustss> Galois was supposed to be named Gauloises because John Launchbury is such and avid smoker, but he couldn't spell it.
15:29:05 <dons> math death fight!
15:29:12 <dons> augustss: haha
15:29:41 <chrisdone> haha
15:29:44 <Pseudonym> So Galois, Hippasus...
15:29:56 <Pseudonym> What other mathematicians died in violent circumstances?
15:29:58 <mpeter> @offtopic
15:29:58 <lambdabot> Unknown command, try @list
15:29:59 <Pseudonym> Archimedes, I guess.
15:30:24 <dons> socrates?
15:30:27 <dons> or does he not count.
15:30:35 <lament> not much of a mathematician
15:30:38 <augustss> not really a mathematician
15:30:53 <Pseudonym> Tycho Brahe wasn't either, but he did lose his nose in a duel over a maths problem.
15:31:11 <dons> socrates had a true FP beard, though.
15:31:34 <jeffwheeler> Pseudonym: and he replaced it with gold!
15:31:48 <jeffwheeler> Pseudonym: I wonder if he smelt the nose. ;)
15:31:52 <Olathe> And that's weird.
15:32:14 <augustss> Turing died under somewhat suspicious circumstances.
15:32:15 <BMeph> In the immortal words of Socrates: "I drank what?!?" ;p
15:32:32 <Pseudonym> And in the immortal words of Einstein: "Oh, looks like the patent office is hiring."
15:32:54 <jowens> integer to string: is there a standard function? (123 -> "123")?
15:33:01 <Pseudonym> jowens: show
15:33:06 <Pseudonym> > show 123
15:33:09 <lambdabot>   "123"
15:33:14 <jowens> that'll do it, thanks!
15:33:22 <Olathe> > read "123" :: Integer
15:33:24 <lambdabot>   123
15:33:35 <mpeter> i'm going to die under suspicious circumstances
15:33:43 <mpeter> or find myself a political prisoner
15:33:49 <BMeph> > (fst.head.reads) "123"
15:33:51 <lambdabot>   * Exception: Prelude.head: empty list
15:33:52 <Pseudonym> No you're not.  I'll make sure it doesn't look suspicious.
15:33:52 <mpeter> i can feel ita lready
15:33:59 * Lemmih wonders if mpeter is on to him.
15:34:02 <BMeph> D'Oh! :|
15:34:05 <mpeter> yes
15:34:06 <mpeter> i am
15:34:24 <mokus> mpeter fell for my Lemmih-decoy, great!
15:34:28 <dons> ?users
15:34:28 <lambdabot> Maximum users seen in #haskell: 575, currently: 567 (98.6%), active: 31 (5.5%)
15:34:45 <augustss> dons: is RWH in sweden yet?
15:34:57 <dons> augustss: yes.
15:35:09 <dons> i heard one report of a delivery in northern sweden
15:35:12 <Olathe> OK, people, we're down 8 and if it stays like this for long, there's going to be some layoffs.
15:35:14 <dons> not sure about bookstores
15:35:15 <augustss> ah, I should buy one then
15:35:29 <pejo> augustss, home for christmas?
15:35:30 <dons> perhaps somewhere in gothenburg or stockholm?
15:35:40 <augustss> pejo: yes
15:35:55 <augustss> dons: I'll have a look.
15:35:57 <dons> chalmers people might know if it is in town.
15:36:05 <augustss> true
15:36:30 <augustss> seems RWH is a best-seller
15:36:49 <dons> yeah, it is the smash hit of the winter :)
15:37:11 <cjb> dons: does ORA ever publish sales numbers or anything?
15:37:24 <dons> cjb: sometimes they do.
15:37:26 <cjb> it'd be great to find out how many zeroes the number sold has in it
15:37:29 <dons> they did a 'state of the market' last year
15:37:47 <dons> 4 figures, currently.
15:37:54 <cjb> cool.
15:37:59 <dons> 3 weeks in. so oreilly is kinda of  happy :)
15:38:14 <lament> dons: do you get any appreciable money from it?
15:38:32 <dons> nothing i'd rely on.
15:38:35 <augustss> dons: 4 figures... so it's all the people that you thank that have bought a copy ;)
15:38:42 <dons> augustss: right :)
15:40:27 <BONUS_> im probably gonna talk to my university library, see if they can order RWH so i can rent it for an extended period >:]
15:40:59 <BONUS_> otherwise i'll just pay the huge shipping fee from amazon :[
15:41:23 <mapreduce> dons: I hope what you did with RWH catches on for other books, wrt the openness etc.
15:41:42 <mapreduce> I know it's not the first like this but it's the best-executed that I've noticed.
15:42:02 <Heffalump> is the website up to date with the printed copy yet? I noticed an error to comment on.
15:42:11 * ddarius hasn't bought a copy.
15:42:17 <ddarius> (and has no intention of doing so)
15:42:50 <chrisdone> mapreduce: I very much agree
15:42:52 <mapreduce> Neither have I, but if I hadn't got TAPL recently I might have.
15:43:03 <Pseudonym> I'm waiting until they bring out the movie.
15:43:59 * Grizzly` has no intention of buying >3 lbs of paper neither, but would consider voluntary payment for his extensive use of the online version.
15:44:07 <mokus> Pseudonym: who's playing lambdabot?
15:44:09 <wjt> i hear bruce schneier will play dons in the movie
15:44:11 <chrisdone> Pseudonym: haha. Haskell Nomads
15:44:32 <Pseudonym> mokus: Helena Bonham Carter
15:44:40 <mokus> Pseudonym: nice
15:44:49 <Pseudonym> Yeah, pretty good casting, actually.
15:45:32 <mapreduce> Haskell and the Attack of the let a . b = b a
15:45:34 <mokus> it's a tough role - gotta be angsty without seeming like a Ruby user
15:45:47 <Pseudonym> ?vixen Who's playing you?
15:45:48 <lambdabot> what about me?
15:45:49 <chrisdone> Pseudonym:  http://pix.nofrag.com/4/0/8/6f4b9779ee96d414ac1f557ec6f54.html
15:46:16 <Pseudonym> LOL
15:47:49 <dons> you guys are weirdos
15:48:16 <mokus> everybody is someone else's weirdo, I've heard
15:48:30 <mokus> some of us just have a larger group of 'someone elses'
15:49:00 <augustss> is anyone their own weirdo?
15:49:05 <dons> mmm
15:49:06 <mokus> probably
15:49:27 <jowens> question on code that does not terminate. I'm trying to find the smallest # that is evenly divisible by [2..20] (Project Euler problem5). My 3-line solution does not terminate and I'd be happy to get pointers as to why (as well as better-code-pointers):
15:49:32 <jowens> evenlyDivides x y = (x `mod` y == 0)
15:49:32 <jowens> evenlyDivides2Through20 n = all (evenlyDivides n) [2..20]
15:49:33 <jowens> main = print (head (filter evenlyDivides2Through20 [1..]))
15:50:16 <augustss> > foldr1 lcm [2..20]
15:50:16 <Pseudonym> > foldr1 lcm [2..20]
15:50:18 <lambdabot>   232792560
15:50:18 <lambdabot>   232792560
15:50:20 <Pseudonym> Coke!
15:50:27 <dibblego> @pl \x y -> x `mod` y == 0
15:50:27 <lambdabot> flip flip 0 . ((==) .) . mod
15:50:42 <satchiii> anyone interested in nominal abstract syntax? http://hpaste.org/13177 :)
15:50:52 * satchiii feels proud
15:50:52 <eu-prleu-peupeu> dons, i love you
15:50:55 <Pseudonym> Are you sure it doesn't terminate?
15:50:56 <augustss> jowens: it's a fairly large number, so maybe it's just working
15:51:00 <Pseudonym> Or is it just taking ages?
15:51:02 <jowens> ok nice work on pointing out lcm, that is groovy
15:51:10 <jowens> lemme run it again
15:51:12 <jowens> it was taking a good while
15:51:23 <jowens> any comments on how i can improve the code (besides the one liner)?
15:51:23 <dons> eu-prleu-peupeu: that's sweet.
15:51:34 <Pseudonym> @let evenlyDivides x y = (x `mod` y == 0)
15:51:35 <lambdabot>  Defined.
15:51:43 <Pseudonym> @let evenlyDivides2Through20 n = all (evenlyDivides n) [2..20]
15:51:44 <lambdabot>  Defined.
15:51:54 <Pseudonym> > evenlyDivides3Through20 232792560
15:51:55 <lambdabot>   Not in scope: `evenlyDivides3Through20'
15:51:58 <Pseudonym> > evenlyDivides2Through20 232792560
15:52:00 <lambdabot>   True
15:52:06 <Pseudonym> I would say it works.
15:52:12 <Pseudonym> It's just taking a long time.
15:52:16 <jowens> ok that is nice. it's just taking a long time, as you say.
15:52:37 <mokus> yea, the best way to improve it is to narrow (or eliminate) the search
15:52:47 <mokus> [1..232792560] is a long list
15:52:55 <Pseudonym> satchiii: Very nice!
15:53:02 <jowens> yes, yes it is. knock out all odd numbers, anything that doesn't end in 0, etc. would help.
15:53:10 <jowens> ok, can someone explain the foldr thing?
15:53:15 <satchiii> Pseudonym: thanks :)
15:53:18 <jowens> i am presuming it's an idiom for (head)
15:53:31 <pumpkin_> > foldr1 lcm [2..10] :: Expr
15:53:33 <lambdabot>   abs (2 `quot` (abs 2 `rem` abs (abs (3 `quot` (abs 3 `rem` abs (abs (4 `quo...
15:53:46 <pumpkin_> > foldr1 lcm [2..4] :: Expr
15:53:47 <lambdabot>   abs (2 `quot` (abs 2 `rem` abs (abs (3 `quot` (abs 4 `rem` (abs 3 `rem` abs...
15:53:56 <pumpkin_> maybe not that way
15:54:02 <satchiii> Pseudonym: Abs has an explicit data instance because GHC derives a wrong one
15:54:05 <jowens> why not just lcm [2..20]
15:54:06 <jowens> ?
15:54:22 <satchiii> Pseudonym: it foregts the datacast
15:54:22 <pumpkin_> jowens: lcm takes two args
15:54:42 <chrisdone> :t loeb
15:54:44 <lambdabot> Not in scope: `loeb'
15:54:48 <mokus> jowens: essentially the fold puts the lcm in place of the :'s in the list
15:54:58 <chrisdone> @let loeb f = fmap ($ loeb f) f
15:55:00 <lambdabot>  Defined.
15:55:02 <chrisdone> :t loeb
15:55:04 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
15:55:42 <jowens> ok, not quite getting the fold yet.
15:55:47 <jowens> let's say i ran lcm [2..4]
15:55:52 <jowens> how does that work with the fold?
15:55:57 <orbitz> :t Word8
15:55:58 <lambdabot> Not in scope: data constructor `Word8'
15:56:03 <augustss> > 2 `lcm` 3 `lcm` 4
15:56:05 <lambdabot>   12
15:56:07 <mokus> @type lcm
15:56:08 <lambdabot> forall a. (Integral a) => a -> a -> a
15:56:09 <chrisdone> :info Word8
15:56:15 <jowens> ah ok
15:56:19 <chrisdone> @info Word8 --?
15:56:20 <jowens> foldr1 is foldr, take head?
15:56:20 <lambdabot> (Word8 --?)
15:56:23 <augustss> jowens: that's what it does, but up to 20
15:56:24 <chrisdone> wat
15:56:32 <Gracenotes> > foldr1 lcm [1..10]
15:56:33 <orbitz> err dur, the type IS Word8 hehe
15:56:34 <lambdabot>   2520
15:56:40 <chrisdone> ha yes
15:56:43 <augustss> @src foldr1
15:56:44 <lambdabot> foldr1 _ [x]    = x
15:56:44 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
15:56:44 <lambdabot> foldr1 _ []     = undefined
15:57:13 <chrisdone> :t join
15:57:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:57:17 <jowens> ok. so for a binary function and a list, foldr puts that function between every element of the list
15:57:22 <jowens> foldr1 + just means sum
15:57:23 <jowens> ?
15:57:42 <augustss> jowens: yes, but foldr1 just work for non-empty lists
15:57:58 <jowens> and the diff btwn foldr1 and foldr?
15:57:59 <Gracenotes> foldr1 is a special type of foldr in which the original value is in the list, sort of like Python's way of having an optional "starting" parameter in reduce
15:58:08 <jowens> ohhh that's cool
15:58:20 <jowens> you don't have to give it an identity value, i guess.
15:58:22 <chrisdone> > loeb [head]
15:58:31 <Gracenotes> foldr1 (+) [1, 2, 3] = reduce(lambda a, b: a + b, [1, 2 3])
15:58:37 <lambdabot>   thread killed
15:58:38 <Gracenotes> foldr (+) 5 [1, 2, 3] = reduce(lambda a, b: a + b, [1, 2 3], 5)
15:58:41 <pumpkin_> @src foldr1
15:58:42 <lambdabot> foldr1 _ [x]    = x
15:58:42 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
15:58:42 <lambdabot> foldr1 _ []     = undefined
15:58:46 <pumpkin_> sorry :)
15:58:51 <chrisdone> :t loeb [head]
15:59:09 <lambdabot> thread killed
15:59:12 <chrisdone> er what
15:59:18 <chrisdone> why is it running it to work out the type?
15:59:20 <chrisdone> :t loeb [head]
15:59:22 <lambdabot> forall a. [a]
15:59:24 <chrisdone> ah good
15:59:25 <jowens> ok you guys are awesome. thanks mucho. my run is still going, btw. really does take a long time.
15:59:50 <pumpkin_> jowens: all project euler problems are designed to be solvable in a minute or less
15:59:50 <chrisdone> > map ($[1]) $ take 3 $ loeb [head]
15:59:55 <augustss> jowens: did you compile with -O2?
15:59:57 <pumpkin_> but it can be hard to find that solution
15:59:59 <jowens> runghc
16:00:09 <lambdabot>   thread killed
16:00:09 <jowens> should i compile?
16:00:11 <Gracenotes> jowens: what does?
16:00:18 <augustss> jowens: give it a try
16:00:22 <chrisdone> what is loeb?
16:00:26 <jowens> i am doing runghc, will that make it take a longer time?
16:00:38 <augustss> :t loeb
16:01:01 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
16:01:29 <Gracenotes> I'm surprised how fast it is. foldr1 lcm [1..10000] returns with about half-second delay
16:01:32 <pumpkin_> you know what would be really helpful? three functions, infiniteMerge, infiniteIntersect, and infiniteDiff of ascending lists
16:01:45 <Pseudonym> @source lcm
16:01:45 <lambdabot> lcm not available
16:01:53 <augustss> Gracenotes: lcm is pretty simple
16:01:57 <Pseudonym> Yes.
16:02:01 <jowens> compiling it is WAY faster.
16:02:02 <Gracenotes> yeah
16:02:03 <jowens> thanks
16:02:05 <Pseudonym> lcm a b = a * b `div` gcd a b
16:02:05 <augustss> @rc gcd
16:02:06 <lambdabot> Not enough privileges
16:02:11 <augustss> @src gcd
16:02:12 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
16:02:12 <lambdabot> gcd x y = gcd' (abs x) (abs y)
16:02:12 <lambdabot>    where gcd' a 0  =  a
16:02:12 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
16:02:47 <Gracenotes> hm... what's that expression
16:03:17 <Gracenotes> > [ (a, b, c) | a <- [1..50], b <- [1..50], c <- [1..100], a < b, gcd a b == 1, a^2 + b^2 == c^2]
16:03:21 <lambdabot>   [(3,4,5),(5,12,13),(7,24,25),(8,15,17),(9,40,41),(12,35,37),(20,21,29),(28,...
16:03:52 <Gracenotes> > [ (a, b, c) | a <- [1..50], b <- [1..50], c <- [1..100], a^2 + b^2 == c^2, gcd a b == 1, a < b] --reverse order...
16:03:54 <lambdabot>   [(3,4,5),(5,12,13),(7,24,25),(8,15,17),(9,40,41),(12,35,37),(20,21,29),(28,...
16:04:07 <Gracenotes> huh, still pretty fast
16:04:11 <chrisdone> > loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
16:04:12 <lambdabot>   [17,3,20,40,6,17]
16:04:45 <Gracenotes> chrisdone: what in the world...?
16:04:54 <chrisdone> oh I get it
16:04:59 <Pseudonym> [ (2*m*n, m*m-n*n, m*m+n*n) | m <- [1..50], n <- [1..50] ]
16:05:04 <Pseudonym> > [ (2*m*n, m*m-n*n, m*m+n*n) | m <- [1..50], n <- [1..50] ]
16:05:05 <lambdabot>   [(2,0,2),(4,-3,5),(6,-8,10),(8,-15,17),(10,-24,26),(12,-35,37),(14,-48,50),...
16:05:10 <Pseudonym> Hmm.
16:05:16 <Pseudonym> > [ (2*m*n, m*m-n*n, m*m+n*n) | m <- [1..50], n <- [n+1..50] ]
16:05:18 <lambdabot>   * Exception: not a number
16:05:25 <Pseudonym> > [ (2*m*n, m*m-n*n, m*m+n*n) | m <- [1..50], n <- [m+1..50] ]
16:05:26 <lambdabot>   [(4,-3,5),(6,-8,10),(8,-15,17),(10,-24,26),(12,-35,37),(14,-48,50),(16,-63,...
16:05:32 <Pseudonym> Sorry.
16:05:39 <Pseudonym> > [ (2*m*n, m*m-n*n, m*m+n*n) | m <- [1..], n <- [1..m-1] ]
16:05:40 <lambdabot>   [(4,3,5),(6,8,10),(12,5,13),(8,15,17),(16,12,20),(24,7,25),(10,24,26),(20,2...
16:05:43 <Pseudonym> There.
16:06:01 <chrisdone> wow, loeb is fucking cool
16:06:11 <Gracenotes> chrisdone: what does it basically do?
16:06:18 <chrisdone> > loeb [const 1]
16:06:18 <augustss> loeb is a strange function
16:06:19 <timetrap> I am trying to make a 15 minute timer in haskell
16:06:19 <lambdabot>   [1]
16:06:22 <chrisdone> > loeb [const 1, const 2]
16:06:23 <lambdabot>   [1,2]
16:06:27 <timetrap> But I come from the world of python
16:06:27 <chrisdone> > loeb [const 1, const 2, sum]
16:06:30 <lambdabot>   [1,2,* Exception: stack overflow
16:06:35 <chrisdone> just as planned
16:06:38 <timetrap> So I am having problems.
16:06:53 <timetrap> can I get some help? http://pastebin.com/m715d9990
16:06:58 <chrisdone> > loeb [const 1, const 2, (!!0)]
16:07:00 <lambdabot>   [1,2,1]
16:07:07 <chrisdone> it's like a spreadsheet
16:07:09 <test> @pl \f l = l ++ (map f l)
16:07:09 <lambdabot> (line 1, column 6):
16:07:10 <lambdabot> unexpected "="
16:07:10 <lambdabot> expecting pattern or "->"
16:07:20 <test> @pl \f l -> l ++ (map f l)
16:07:20 <lambdabot> ap (++) . map
16:07:23 <chrisdone> @src loeb
16:07:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:07:25 <orbitz> will somethign like S.pack ',' in a guard, wil that be evalauted only once for the entire program?
16:07:30 <dons> yes
16:07:35 <chrisdone> loeb f = fmap ($ loeb f) f
16:07:37 <dons> use S.singleton ','
16:07:41 <ziman> > loeb [const 1, const 2, const 3, sum . take 3]
16:07:42 <dons> or float it out if youu're scared
16:07:42 <lambdabot>   [1,2,3,6]
16:07:44 <orbitz> ok
16:07:52 <chrisdone> ziman: how cool is that?
16:07:54 <orbitz> dons: i know no fear!
16:07:55 <ziman> it is :)
16:08:04 <Pseudonym> > loeb (array (1,3) . zip [1..] $ [const 1, const 2, (!0)])
16:08:05 <lambdabot>   array (1,3) [(1,1),(2,2),(3,* Exception: Error in array index
16:08:10 <Pseudonym> > loeb (array (1,3) . zip [1..] $ [const 1, const 2, (!1)])
16:08:11 <lambdabot>   array (1,3) [(1,1),(2,2),(3,1)]
16:08:17 <Gracenotes> > loeb [ (!!4), const 4 ]
16:08:18 <lambdabot>   [* Exception: Prelude.(!!): index too large
16:08:26 <Gracenotes> O_O
16:08:35 <ziman> i wonder whether there are more theorems in intuitionistic logic that can produce similarly interesting functions :)
16:08:56 <orbitz> dons: i have some String processign code that makes use of apttenr matching, thing (',':rest) = blah, an di am converting it to ByteString, am i going ot ahv eot so S.singleton ',' == S.head x i na guard?
16:09:05 <Gracenotes> the mighty loeb is too deep for my comprehension
16:09:09 <Pseudonym> > loeb (const 0 : const 1 : [ (!!i) + (!!i+1) | i <- [0..] ])
16:09:10 <lambdabot>       The operator `!!' [infixl 9] of a section
16:09:10 <lambdabot>          must have lower prec...
16:09:19 <Pseudonym> > loeb (const 0 : const 1 : [ (!!i) + (!!(i+1)) | i <- [0..] ])
16:09:20 <lambdabot>       No instance for (Num ([a] -> a))
16:09:20 <lambdabot>        arising from a use of `+' at <i...
16:09:24 <Pseudonym> Hrm.
16:09:43 <Pseudonym> > loeb (const 0 : const 1 : [ \l -> (l!!i) + (l!!(i+1)) | i <- [0..] ])
16:09:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:09:47 <Pseudonym> Right.
16:09:56 <chrisdone> hehe
16:09:59 <Gracenotes> o-o
16:10:04 <ziman> ooh :)
16:10:06 <Pseudonym> Should probably add that to the gallery.
16:10:09 <chrisdone> Pseudonym: I like how it's i+1
16:10:14 <ziman> is there any fibs gallery?
16:10:25 <augustss> Gracenotes: read sigfpe's blog
16:10:35 <Gracenotes> he has a recent post on it?
16:10:37 <test> > [1..10] . (map (+1))
16:10:38 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
16:10:47 <chrisdone> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
16:11:14 <test> > (const 7)
16:11:15 <lambdabot>       Overlapping instances for Show (b -> t)
16:11:15 <lambdabot>        arising from a use of `s...
16:11:27 <chrisdone> :t const
16:11:27 <Gracenotes> > (const 7) 8
16:11:29 <lambdabot> forall a b. a -> b -> a
16:11:29 <lambdabot>   7
16:11:37 <augustss> > let a . b = b a in [1..10] . (map (+1))
16:11:39 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:11:51 <test> > (map (+1)) . (const [1..10])
16:11:52 <lambdabot>       Overlapping instances for Show (a1 -> [a])
16:11:52 <lambdabot>        arising from a use of...
16:11:55 <Pseudonym> :type flip ($)
16:12:07 <Pseudonym> :t flip ($)
16:12:08 <lambdabot> forall a b. a -> (a -> b) -> b
16:12:09 <chrisdone> :t flip join
16:12:11 <lambdabot> forall a b. b -> (b -> b -> a) -> a
16:12:15 <Pseudonym> ?hoogle a -> (a -> b) -> b
16:12:16 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:12:16 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
16:12:16 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
16:12:36 <solrize> is there a convenient function like python's time.time() which gives a current floating-point timestamp?  i.e. something with type IO Double
16:12:39 <Gracenotes> > negate $! 3
16:12:41 <lambdabot>   -3
16:12:41 <Pseudonym> it's bind in the Id monad, anyway.
16:13:06 <orbitz> solrize: what about using a difftime?
16:13:10 <Pseudonym> > Id [1..10] >>= Id . map (+1)
16:13:11 <lambdabot>   Not in scope: data constructor `Id'Not in scope: data constructor `Id'
16:13:22 <Pseudonym> > Control.Monad.Id [1..10] >>= Control.Monad.Id . map (+1)
16:13:22 <Gracenotes> isn't it called Identity?
16:13:23 <lambdabot>       Not in scope: data constructor `Control.Monad.Id'    Not in scope: data...
16:13:25 <Pseudonym> Maybe.
16:13:34 <solrize> orbitz i'm looking at the docs for that and i can probably figure out how to use it if i spend the rest of the day, but i was hoping for something simpler.
16:13:37 <Pseudonym> > Identity [1..10] >>= Identity . map (+1)
16:13:38 <lambdabot>       No instance for (Show (Identity [t]))
16:13:38 <lambdabot>        arising from a use of `sho...
16:13:39 <chrisdone> > loeb $ Just (const 1)
16:13:40 <lambdabot>   Just 1
16:13:47 <Pseudonym> > runIdentity $ Identity [1..10] >>= Identity . map (+1)
16:13:48 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:13:51 <Pseudonym> There.
16:13:54 <orbitz> solrize: what are you trying to do wiht it?
16:13:59 <chrisdone> Pseudonym: oooooo
16:14:01 <Pseudonym> So much simpler.
16:14:09 <solrize> just timestamp stuff to record when they happened
16:14:22 <test> type (const 7)
16:14:26 <chrisdone> :t Identity
16:14:28 <lambdabot> forall a. a -> Identity a
16:14:30 <test> @type (const 7)
16:14:31 <lambdabot> forall t b. (Num t) => b -> t
16:14:36 <solrize> also to see how long things take, by subtracting timestamps from each other
16:14:50 <Gracenotes> solrize: there's a setting in ghci for that
16:14:58 <chrisdone> :t runIdentity
16:14:59 <lambdabot> forall a. Identity a -> a
16:15:12 <orbitz> solrize: you can use diffUTCTime to figure out how logn osmethign took
16:15:18 <orbitz> solrize: unsure of how to get simethig like time() though
16:15:20 <Gracenotes> :t execWriter
16:15:21 <lambdabot> forall w a. Writer w a -> w
16:15:44 <orbitz> solrize: diffUTCTime does do floats though
16:15:52 <solrize> orbitz yeah it looks like i can use difftime, i guess i'll do that, it's just messy
16:16:05 <chrisdone> > runIdentity $ Identity Nothing >> Identity (Just 1)
16:16:07 <lambdabot>   Just 1
16:16:12 <Gracenotes> :t execReader
16:16:13 <lambdabot> Not in scope: `execReader'
16:16:18 <chrisdone> > runIdentity $ Identity (Just 1) >> Identity (Just 1)
16:16:18 <Gracenotes> :t runReader
16:16:20 <lambdabot>   Just 1
16:16:20 <lambdabot> forall r a. Reader r a -> r -> a
16:16:25 <chrisdone> > runIdentity $ Identity (Just 2) >> Identity (Just 1)
16:16:27 <lambdabot>   Just 1
16:16:28 <orbitz> solrize: yeah, i wish tehre was a conversion function for a unix-style timestamp
16:16:44 <orbitz> solrize: also unsure of how to get an integral out of a DiffTime
16:17:09 <solrize> well, it's a Num, there's a generic way, i think
16:17:17 <Gracenotes> > runIdentity $ Identity Nothing >>= Identity (Just 5)
16:17:18 <lambdabot>   Couldn't match expected type `Maybe a1 -> Identity a'
16:17:25 <Gracenotes> oh. hm.
16:17:33 <chrisdone> > runIdentity $ Identity (Just 1) >>= Identity . fmap (+1)
16:17:35 <lambdabot>   Just 2
16:18:04 <chrisdone> > runIdentity $ Identity [1..3] >>= Identity . fmap (+1)
16:18:05 <lambdabot>   [2,3,4]
16:18:26 <chrisdone> I don't get it
16:18:33 <chrisdone> what's the point of this monad?
16:18:35 <Pseudonym> What don't you get?
16:18:43 <Pseudonym> Two reasons.
16:18:51 <Pseudonym> 1. Identities are generally useful.
16:18:53 <Pseudonym> e.g. the id function
16:19:06 <Pseudonym> 2. To use as the base case for an arbitrary transformer.
16:19:22 <chrisdone> ah
16:19:26 <Pseudonym> Right?  With Identity, everything else need only be a monad transformer.
16:19:41 <chrisdone> heh, interesting
16:19:57 <chrisdone> actually, yeah
16:19:59 <solrize> looks like i can convert to float with realToFrac
16:20:03 <Pseudonym> Monad operations work on all monads.  You could change monadic code into non-monadic code by just changing the type signature to use Identity.
16:20:18 <test> > ((++) (\x y -> id y) map) (+1) [1..3]
16:20:19 <lambdabot>       The lambda expression `\ x y -> id y' has two arguments,
16:20:19 <lambdabot>      but its t...
16:20:23 <orbitz> solrize: worst case you can make a Time at unix epoc, and use difftime
16:20:50 <test> > (\ -> (++) (\x y -> id y) map) (+1) [1..3]
16:20:51 <lambdabot>   <no location info>: parse error on input `->'
16:21:09 <chrisdone> Pseudonym: hmmm. can you give an example? I'm not sure
16:21:31 <solrize> oh what a pain in the neck, UTCTime stores the day and seconds separately
16:21:54 <solrize> :t UTCTime
16:21:55 <lambdabot> Not in scope: data constructor `UTCTime'
16:22:01 <orbitz> solrize: DiffTime doesn't though right
16:22:03 <solrize> :t getCurrentTime
16:22:04 <lambdabot> Not in scope: `getCurrentTime'
16:22:04 <solrize> right
16:22:23 <Pseudonym> chrisdone: Anything with (Monad m) in the type can use Identity.
16:22:39 <Pseudonym> :t liftM2
16:22:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:22:48 <Pseudonym> OK, not a good example.
16:23:02 <orbitz> @src Data.Time.UTCTime
16:23:02 <lambdabot> Source not found. Wrong!  You cheating scum!
16:23:14 <pumpkin_> hmm, is there a simplification of an unfoldr with Just (a, a) as the constant output of the function passed to it?
16:23:42 <pumpkin_> as in, fst and snd are always the same, and it always returns a Just
16:23:54 <sjanssen> pumpkin_: repeat?  iterate?
16:23:58 <sjanssen> > repeat 1
16:23:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:24:04 <test> > f [1..3] (+1) where f = id ++ (flip map)
16:24:05 <pumpkin_> well, the function is actually doing something
16:24:05 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> a1'
16:24:09 <pumpkin_> maybe iterate will do it, let me think
16:24:13 <sjanssen> > iterate (*2) 1
16:24:14 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
16:24:21 <Pseudonym> :t runIdentity . loeb . Identity . runIdentity
16:24:22 <lambdabot> forall b. Identity (Identity b -> b) -> b
16:24:23 <sbahra> cool
16:24:30 <test> @type ap
16:24:30 <Pseudonym> :t runIdentity . loeb . Identity
16:24:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:24:32 <lambdabot> forall b. (Identity b -> b) -> b
16:24:53 <pumpkin_> sjanssen: thanks, iterate did it... not sure why I didn't think of that :)
16:25:20 <Gracenotes> > foldr1 (+) $ take 1000 $ iterate (* 0.5) 1
16:25:22 <lambdabot>   2.0
16:25:23 <Pseudonym> :t \f -> runIdentity . loeb . Identity . f . runIdentity
16:25:24 <lambdabot> forall b a. (a -> Identity b -> b) -> Identity a -> b
16:25:28 <Pseudonym> Hmm.
16:25:29 <Gracenotes> number theory... it works
16:25:31 <solrize> ok, i gues this works
16:25:32 <Gracenotes> :D
16:25:34 <solrize> Prelude Data.Time.Clock> t0 <- getCurrentTime
16:25:34 <solrize> Prelude Data.Time.Clock> t1 <- getCurrentTime
16:25:34 <solrize> Prelude Data.Time.Clock> print $ realToFrac $ diffUTCTime t1 t0
16:26:29 <orbitz> solrize: awesome!
16:27:31 <sbahra> solrize, you might be interested in rdtsc
16:27:42 <orbitz> what is rdtsc?
16:27:46 <test> @hoogle ap
16:27:47 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
16:27:47 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
16:27:47 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
16:27:53 <sbahra> orbitz, on hackage, check for "Rdtsc"
16:27:55 <pumpkin_> is there an "integer square root" function for Integers ?
16:27:56 <solrize> sbahra yeah, that's interesting for high res profiling, right now i just want ordinary timestamps
16:27:57 <sbahra> orbitz, ffi to rdtsc instruction
16:28:09 <Pseudonym> pumpkin: There are a few floating around.
16:28:12 <Gracenotes> heh, my interesting haskell examples file is getting more and more full
16:28:16 <orbitz> sbahra: co
16:28:20 <solrize> orbitz, rtdsc is an x86 machine instruction that tells you the number of machine cycles since you booted the cpu
16:28:25 <sbahra> No
16:28:30 <solrize> i.e. you can use it for nanosecond resolution profiling
16:28:32 <sbahra> The port is wrong about that
16:28:40 <sbahra> and it needs to be fixed to allow for serialization
16:28:42 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Util.hs
16:28:43 <test> > ap [(+), (*)] [4, 6]
16:28:44 <lambdabot>       Overlapping instances for Show (a -> a)
16:28:44 <lambdabot>        arising from a use of `s...
16:28:48 <sbahra> On AMD, it still represents number of cycles.
16:28:52 <sbahra> But this isn't the case on Intel.
16:28:57 <pumpkin_> thanks Pseudonym
16:29:01 <solrize> they changed it?  hmm
16:29:08 <sbahra> Been a while
16:29:14 <test> > [(+ 1), (+ 2)] `ap` [1, 2, 3]
16:29:15 <lambdabot>   [2,3,4,3,4,5]
16:29:25 <sbahra> And with ACPI, timing isn't guaranteed to be accurate, you need to make sure you don't have cpufreq stuff
16:29:45 <sbahra> solrize, newer AMD processors have a much more useful instruction, 'rdtscp'
16:29:54 <test> ap (*) 4 6
16:29:58 <test> > ap (*) 4 6
16:29:59 <lambdabot>       No instance for (Num (a -> a))
16:29:59 <lambdabot>        arising from the literal `4' at <...
16:30:03 <Gracenotes> > [(+ 1), (+ 2)] <$> [1, 2, 3]
16:30:05 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
16:30:05 <sjanssen> rdtsc doesn't seem very useful in a multi-tasking OS
16:30:10 <Gracenotes> hm, wrong operator
16:30:13 <Gracenotes> > [(+ 1), (+ 2)] <*> [1, 2, 3]
16:30:15 <lambdabot>   [2,3,4,3,4,5]
16:30:48 <sbahra> sjanssen, it's useful for sure. Just limited scope :-P
16:30:50 <solrize> sbahra i think the idea of rtdsc is not to give real-time measurements but rather for performance tuning, so you can see how many cycles of difference it makes to use a register for something instead of a memory loc, etc.
16:30:52 <mpeter> ok, my 20 minute foray into perl is over
16:30:54 <sbahra> It still provides a lot of granularity.
16:30:58 <mpeter> what did i miss in the history of haskell
16:31:20 <sbahra> solrize, for that unfortunately (reliable access to a cycles counter) you are stuck with MSRs.
16:31:23 <test> > [(*), (+)] <*> [[4, 6], [4, 6]]
16:31:24 <lambdabot>       Overlapping instances for Show ([t] -> [t])
16:31:24 <lambdabot>        arising from a use o...
16:31:32 <solrize> MSRs?
16:31:36 <sbahra> model-specific registers
16:31:41 <solrize> ic
16:32:03 <sbahra> Requires kernel support for any modern multi-tasking os
16:32:24 <test> is there a function that will use an array as another function's arguments?
16:33:01 <solrize> well, i think the idea is you're timing very short (sub-millisecond) computations and you repeat them a lot and toss out any where it looks like your process got swapped...
16:33:37 <solrize> test, you have to unpack the array and pass those args in
16:33:52 <sbahra> Well, you don't know where/when your process got swapped.
16:34:42 * mpeter passes out
16:34:57 <solrize> right, i dunno if there's any way around that
16:35:30 <solrize> except to rely on being able to usually not be swapped in a given few microsecond stretch
16:35:51 <mpeter> > [(\x->[x^1,x^2,x^3,x^4]),(\x->[x^1.5,x^2.5,x^3.5,x^4.5])] <*> [1..10]
16:35:52 <lambdabot>   Add a type signature
16:35:57 <mpeter> fuck you add a type signature
16:36:01 <Gracenotes> chrisdone: heh, my brain is starting to hurt from loeb :)
16:36:12 <mpeter> why can't it infer that as float
16:36:16 <mpeter> or double
16:36:52 <test>  @hoogle curry
16:37:12 <test> @hoogle curry
16:37:12 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
16:37:12 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
16:37:12 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
16:37:13 <sjanssen> mpeter: the exponent passed to (^) must be Integral
16:37:29 <sjanssen> mpeter: use (**) instead
16:37:31 <mpeter> oh right
16:37:32 <mpeter> thanks
16:37:50 <mpeter> > [(\x->[x^1,x^2,x^3,x^4]),(\x->[x**1.5,x**2.5,x**3.5,x**4.5])] <*> [1.0,2.0..10]
16:37:51 <lambdabot>   [[1.0,1.0,1.0,1.0],[2.0,4.0,8.0,16.0],[3.0,9.0,27.0,81.0],[4.0,16.0,64.0,25...
16:38:04 <mpeter> now how do i feed that into concatmap...
16:38:32 * mpeter takes a hammer and jams it into a one-layer list
16:38:46 <dibblego> mpeter, (<*>) = ap
16:39:08 <mpeter> ap?
16:39:20 <dibblego> @type ap
16:39:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:39:26 <dibblego> @type (<*>)
16:39:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:39:28 <dibblego> @src ap
16:39:28 <lambdabot> ap = liftM2 id
16:40:16 <test> > (lcurry (+)) [4, 6] where lcurry f l = foldl (\x y -> curry x y) ([f] ++ l)
16:40:17 <lambdabot>       Occurs check: cannot construct the infinite type: b = (b1, b)
16:40:17 <lambdabot>        Ex...
16:40:58 <test> > (lcurry (+)) [4, 6] where lcurry f l = foldl curry ([f] ++ l)
16:40:59 <lambdabot>       Occurs check: cannot construct the infinite type: b = (a, b)
16:40:59 <lambdabot>        Exp...
16:41:22 <test> > (lcurry (+) [4, 6]) where lcurry f l = foldl curry ([f] ++ l)
16:41:23 <lambdabot>       Occurs check: cannot construct the infinite type: b = (a, b)
16:41:23 <lambdabot>        Exp...
16:41:37 * mpeter starts crying
16:44:01 <chrisdone> :t msum
16:44:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
16:44:05 <chrisdone> :hoogle msum
16:44:21 <chrisdone> @hoogle msum
16:44:21 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
16:44:21 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
16:47:11 <test> > f [1..3] (+1) where f = ++ (flip map)
16:47:12 <lambdabot>   <no location info>: parse error on input `++'
16:47:21 <test> > f [1..3] (+1) where f = (++ (flip map))
16:47:22 <lambdabot>   Couldn't match expected type `[a]'
16:47:50 <test> > f (+1) [1..3] where f = ap (++) . map
16:47:51 <lambdabot>   [1,2,3,2,3,4]
16:48:00 <mpeter> dibblego: can you concatmap what i wrote?
16:48:01 <test> > f (+1) [1..3] where f = (ap (++)) . map
16:48:02 <lambdabot>   [1,2,3,2,3,4]
16:48:24 <dibblego> mpeter, sure but don't you want to try first? :)
16:48:26 <test> > f (+1) [1..3] where f = (++) . map
16:48:27 <lambdabot>   Couldn't match expected type `[a]'
16:48:42 <mpeter> well, what's the official term for uh
16:48:45 <mpeter> list flattening
16:48:58 <dibblego> [(\x->[x^1,x^2,x^3,x^4]),(\x->[x**1.5,x**2.5,x**3.5,x**4.5])] `ap` [1.0,2.0..10]
16:49:03 <dibblego> > [(\x->[x^1,x^2,x^3,x^4]),(\x->[x**1.5,x**2.5,x**3.5,x**4.5])] `ap` [1.0,2.0..10]
16:49:04 <lambdabot>   [[1.0,1.0,1.0,1.0],[2.0,4.0,8.0,16.0],[3.0,9.0,27.0,81.0],[4.0,16.0,64.0,25...
16:49:12 <dibblego> @src ap
16:49:12 <lambdabot> ap = liftM2 id
16:49:15 <dibblego> @src liftM2
16:49:15 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:49:22 <dibblego> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:49:22 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
16:49:30 <dibblego> (>>=) ~= concatMap
16:49:33 <mpeter> something to do with that damn >>= operator of course
16:51:03 <test> > f (+1) [1..3] where f = ap ((++) . map)
16:51:04 <lambdabot>   Couldn't match expected type `[a]'
16:53:01 <test> > f [1..3] (+1) where f = (++ (map))
16:53:01 <lambdabot>   Couldn't match expected type `[a]'
16:53:12 <test> > f [1..3] (+1) where f = (++ (flip map))
16:53:13 <lambdabot>   Couldn't match expected type `[a]'
16:53:34 <test> > f [1..3] (+1) where f = (++ (\x y -> map y x))
16:53:35 <lambdabot>       The lambda expression `\ x y -> map y x' has two arguments,
16:53:35 <lambdabot>      but it...
16:55:05 <test> @pl (\f g l -> filter f (map g l))
16:55:05 <lambdabot> (. map) . (.) . filter
16:55:23 <test> @type (. map) . (.) . filter
16:55:24 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
16:56:00 <test> @free f :: (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
16:56:01 <lambdabot> g . p = q . h => $map g . f (k . g) p = f k q . $map h
16:56:06 <BMeph> mpeter: Flattening is what we call 'join' in Haskell. List flattening also has a special name, concat. :)
16:56:47 <mpeter> but concat is just cons or ++ with different fixity, isn't it
16:56:58 <mpeter> > concact [1..10] [11..20]
16:56:59 <lambdabot>   Not in scope: `concact'
16:57:03 <mpeter> > concat [1..10] [11..20]
16:57:05 <lambdabot>   Couldn't match expected type `[t1] -> t'
16:57:09 <BMeph> mpeter: No, concat is list flattening. :)
16:57:10 <mpeter> i guess not
16:57:23 <mpeter> > concat ([(\x->[x^1,x^2,x^3,x^4]),(\x->[x**1.5,x**2.5,x**3.5,x**4.5])] <*> [1.0,2.0..10])
16:57:24 <lambdabot>   [1.0,1.0,1.0,1.0,2.0,4.0,8.0,16.0,3.0,9.0,27.0,81.0,4.0,16.0,64.0,256.0,5.0...
16:57:31 <mpeter> god i love haskell
16:57:40 <BMeph> mpeter: That is, it takes a list-of-lists-of something, and makes it into one big list. :)
16:58:23 <BMeph> mpeter: If you're trying to 'golf' it, you can save a pair of chars by using 'join' instead of 'concat' but really, it's the same thing. :)
16:58:31 <BMeph> :ty join
16:58:42 <mpeter> @type join
16:58:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:58:43 <mpeter> @type concat
16:58:44 <BMeph> @ty join
16:58:45 <lambdabot> forall a. [[a]] -> [a]
16:58:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:58:55 <mpeter> those are two different functions why?
16:59:09 <mpeter> @src join
16:59:10 <lambdabot> join x =  x >>= id
16:59:11 <mpeter> @src concat
16:59:11 <lambdabot> concat = foldr (++) []
16:59:16 <mpeter> ah
16:59:19 <BMeph> mpeter: Just sub '[]' for those 'm's, and you're good. :)
16:59:57 <BMeph> mpeter: concat is specifically for lists. 'join' works for anything in the 'Monad' class. :)
17:00:09 <dolio> @type mconcat
17:00:10 <lambdabot> forall a. (Monoid a) => [a] -> a
17:00:15 <BMeph> mpeter: Including, of course, lists. ;)
17:00:44 <dolio> @type Data.Foldable.fold
17:00:46 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
17:01:06 <test> > (truct (+4) (*4)) 6 where truct f g = (\x -> [f x, g x])
17:01:07 <lambdabot>   [10,24]
17:01:26 <mpeter> > [6+4,6^4]
17:01:28 <lambdabot>   [10,1296]
17:01:29 <dolio> @type msum
17:01:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
17:01:35 <mpeter> > [6+4,6*4]
17:01:36 <lambdabot>   [10,24]
17:01:36 * mpeter blushes
17:01:38 <BMeph> > Data.Foldable.fold "banana"
17:01:40 <lambdabot>       No instance for (Monoid Char)
17:01:40 <lambdabot>        arising from a use of `Data.Foldab...
17:01:49 <BMeph> Boo! ;p
17:02:21 <test> @hoogle wrap
17:02:22 <lambdabot> Control.Applicative WrapArrow :: a b c -> WrappedArrow a b c
17:02:22 <lambdabot> Distribution.Simple.Utils wrapLine :: Int -> [String] -> [[String]]
17:02:22 <lambdabot> Control.Applicative WrapMonad :: m a -> WrappedMonad m a
17:02:53 <BMeph> > Data.Foldable.fold [Sum 1, Sum 2, Sum 3, Sum 4, Sum 5]
17:02:54 <lambdabot>   Sum {getSum = 15}
17:03:05 <BMeph> Heh-heh, "getSum"! ;p
17:03:27 <test> > (wrap id) 7 6 where wrap f = (\x y -> f x)
17:03:28 <lambdabot>   7
17:03:37 <BMeph> > mconcat [Sum 1, Sum 2, Sum 3, Sum 4, Sum 5]
17:03:39 <lambdabot>   Sum {getSum = 15}
17:03:42 <test> > (flip wrap id) 6 7 where wrap f = (\x y -> f x)
17:03:43 <lambdabot>       No instance for (Num ((a -> a) -> t))
17:03:43 <lambdabot>        arising from the literal `...
17:04:00 <test> > (flip (wrap id)) 6 7 where wrap f = (\x y -> f x)
17:04:01 <lambdabot>   7
17:04:28 <BMeph> mpeter: Watch and be Boggled... ;)
17:04:32 <BMeph> > ap [(+4),(*4)] [6]
17:04:34 <lambdabot>   [10,24]
17:05:08 <BMeph> > (ap.ap) [(+),(*)] [4] [6]
17:05:10 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
17:05:32 <BMeph> > (ap.ap [(+),(*)]) [4] [6]
17:05:34 <lambdabot>   [10,24]
17:06:15 <dolio> > [(+),(*)] `ap` [4] `ap` [6]
17:06:17 <lambdabot>   [10,24]
17:06:53 * mpeter watches
17:07:41 <dolio> > [(+),(*)] `sequence` 4 `sequence` 6
17:07:43 <lambdabot>   [10,24]
17:08:17 <test> > truct (+) (*) [4, 6] where truct f g x y = (ap.ap [f, g]) [x] [y]
17:08:18 <lambdabot>       Overlapping instances for Show ([t] -> [[t]])
17:08:18 <lambdabot>        arising from a use...
17:08:56 <test> > truct (+) (*) [4, 6] where truct f g l = (ap.ap [f, g]) [head l] [tail l]
17:08:57 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
17:08:57 <lambdabot>        Expect...
17:12:09 <test> > f (+1) [1..3] where wrap f = (\x y -> f x) f = (++) (flip (wrap id)) map
17:12:10 <lambdabot>   <no location info>: parse error on input `='
17:12:36 <test> > f (+1) [1..3] where wrap f = (\x y -> f x) f = (++)(flip (wrap id)) map
17:12:37 <lambdabot>   <no location info>: parse error on input `='
17:12:56 <test> > f (+1) [1..3] where {wrap f = (\x y -> f x); f = (++) (flip (wrap id)) map}
17:12:57 <lambdabot>   Couldn't match expected type `[a]'
17:13:06 <pumpkin_> test: what are you trying to do?
17:13:28 <Gracenotes> let wrap f = (\x y -> f x); f = (++) (flip (wrap id)) map in f (+1) [1..3]
17:13:42 <Gracenotes> > let wrap f = (\x y -> f x); f = (++) (flip (wrap id)) map in f (+1) [1..3] --rather
17:13:44 <lambdabot>   Couldn't match expected type `[a]'
17:13:59 <dolio> "(++) (flip (wrap id)) map" is clearly ill-typed.
17:14:16 <Gracenotes> let > where, in terms of, er, expressionhood
17:14:41 <Gracenotes> so I've heard
17:21:25 * mpeter starts crying
17:27:46 <mm_freak> yeah…  my first type level arithmetic works as expected =)
17:28:15 <mm_freak> well…  almost
17:28:19 <mm_freak>     Context reduction stack overflow; size = 20
17:28:21 <mm_freak> hehe
17:28:22 <pumpkin_> fail
17:28:26 <racliv> > f (+1) [1..3] where f = (flip (\x y -> id x)) ++ map
17:28:27 <lambdabot>   Couldn't match expected type `[a]'
17:28:29 <pumpkin_> (epic)
17:29:22 <racliv> > f (+1) [1..3] where f = (\x y -> id y) ++ map
17:29:22 <lambdabot>       The lambda expression `\ x y -> id y' has two arguments,
17:29:23 <lambdabot>      but its t...
17:30:10 <Botje> racliv: uh, what's ++ map supposed to mean?
17:30:24 <mm_freak> f = flip const ++ map, whatever the intention may be …
17:31:16 <zeno> what would be the best option to sort a list you want to lazily to pull from in a random order?
17:31:30 <racliv> > f (+1) [1..3] where f = flip const ++ map
17:31:31 <lambdabot>   Couldn't match expected type `[a]'
17:31:36 <mm_freak> zeno: sorting destroys laziness
17:32:14 <racliv> > f (+1) [1..3] where f = wrap (++ map) where wrap f = (\x y -> f x)
17:32:15 <mm_freak> racliv: what are you trying to do?
17:32:15 <zeno> mm_freak: this appears to be lazy, but slow randomReorder gen xs = map (xs !!) $ take l (nub (randomRs (0,l-1) gen)) where l = length xs
17:32:15 <lambdabot>   Couldn't match expected type `[a]'
17:32:41 <int-e> zeno: length is strict
17:33:01 <zeno> int-e: ah didnt think of that, thanks
17:33:08 <mm_freak> zeno: you cannot sort lazily, not even a random sort
17:33:09 <racliv> take a function and list, then join the list and the mapped list point-freely
17:33:14 <int-e> zeno: but that's to be expected - you can't uniformly shuffle a list without knowing its length
17:33:34 <mm_freak> @pl \f x -> x ++ map f x
17:33:34 <lambdabot> ap (++) . map
17:33:59 <zeno> hmmm im guessing i should convert it to an array then
17:34:13 <racliv> except i was kind of trying to do it on my own
17:34:15 <racliv> =P
17:34:32 <mm_freak> zeno: if you need random access or lengths anyway, use arrays…  lists are great, but they fail here
17:34:48 <mm_freak> racliv: why?  what's wrong with \f x -> x ++ map f x?
17:34:57 <zeno> whats a good method to shuffle an array randomly? the one i wrote is really slow
17:35:05 <luite> zeno: i did that some time ago for shuffling a list, there must be still something on hpaste
17:35:12 <mm_freak> that's much clearer than the points-free version (which i couldn't come up with on my own either)
17:35:18 <racliv> i was bored, so i was just trying to convert it to a point-free function
17:35:35 <luite> hm, how do I search hpaste :)
17:35:46 <zeno> luite: was about to ask that myself =p
17:36:34 <mm_freak> luite: by using your favorite search engine =)
17:36:40 <mm_freak> the big one supports site:hpaste.org
17:36:41 <luite> zeno: the one on the bottom: http://hpaste.org/12291
17:37:00 <poliquin> Newbie Question .. I'm converting my old programs from Scheme and I made extensive use of 'read' for xferring data from one app to another .. but the GHC manual says don't use read .. what to do?
17:37:08 <ddarius> @google "perfect shuffle" oleg
17:37:10 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
17:37:43 <poliquin> I looked at Parsec (I've never played with parsers before) .. is this a good plan?
17:37:44 <ddarius> poliquin: Use read depending or if you don't need a human-readable format, use Data.Binary.
17:37:51 <zeno> luite: thanks a ton that really helps
17:37:55 <Botje> poliquin: you can probably get away with using interact for most of your programs
17:38:09 <Botje> :t interact
17:38:10 <lambdabot> (String -> String) -> IO ()
17:38:12 <sjanssen> poliquin: Read is okay as long as your data isn't large
17:38:18 <luite> zeno: mine is just a basic fisher-yates shuffle in a mutable array
17:38:47 <luite> don't know if it's faster than olegs version :)
17:38:55 <poliquin> Ok .. I won't be so picky then (at least first cut) .. Thanks everyone !!!!
17:39:57 <zeno> hmmm i dont need "perfect" shuffling, i wonder if thats much slower
17:40:08 <mm_freak> zeno: if you can come up with a simple random Ix permutation, you can easily shuffle an array
17:40:23 <mbac> i want to turn a list [("foo",1), ("bar",2), ("baz",3)] into [(1,"foo"), (2,"bar"), (3,"baz")]; please critique my noobness
17:40:26 <mbac> juxt = map (swap) where swap (a,b) = (b,a)
17:40:37 <mm_freak> see listArray and ixmap
17:40:40 <luite> mm_freak: hmm, that's a good idea
17:40:50 <ddarius> mbac: Other than the unnecessary parentheses, that's fine.
17:41:00 <mbac> they ARE unnecessary
17:41:06 <mbac> hah!
17:41:36 <mbac> wait, on the tuple or around the swap?
17:41:43 <ddarius> mbac: Around swap.
17:42:11 <racliv> > f (+1) [1..3] where f = id ++ map
17:42:11 <mbac> i guess i'm confused about the order of evaluation there
17:42:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> a1'
17:42:20 <Philonous> uncurry ( flip (,) ) $ (1,2)
17:42:23 <Philonous> > uncurry ( flip (,) ) $ (1,2)
17:42:24 <lambdabot>   (2,1)
17:43:33 <racliv> > f (+1) [1..3] where f = (uncurry (++).) . (tand id) . map where tand f g x = (f x, g x)
17:43:34 <ddarius> mbac: Just like in arithmetic (1) means 1, (x) is just x.  Parentheses just specify grouping like in math.
17:43:34 <lambdabot>   [1,2,3,2,3,4]
17:43:55 <mm_freak> zeno: if your element type has sort of an 'empty' value, then array shuffling becomes a very simple and fast operation taking about n * log n operations in average
17:43:58 <mbac> why isn't ''juxt foo'' evaluated as ''map (swap foo)'' then?
17:44:09 <mm_freak> you can use State or MonadRandom
17:44:11 <racliv> > f (+1) [1..3] where f = (uncurry (++).) . (tand id map) where tand f g x = (f x, g x)
17:44:12 <lambdabot>   Couldn't match expected type `a1 -> ([a], [a])'
17:44:32 <mm_freak> otherwise it's going to be a bit tricky
17:44:34 <ddarius> mbac: Why should it be that rather than '(map swap) foo'
17:44:37 <ddarius> ?
17:44:40 <mbac> well, exactly
17:44:42 <mbac> what's the rule?
17:45:10 <mbac> why does haskell decide that it's a partial application of map instead of a partial application of swap?
17:45:17 <zeno> mm_freak: no empty values, olegs or  luite method should work i think though, thanks
17:45:18 <sjanssen> mbac: f x y == (f x) y
17:45:21 <ddarius> mbac: You can figure it out from what I've said above.  (juxt) == juxt == map swap = (map swap) so juxt foo must be (map swap) foo.
17:45:34 <ddarius> mbac: Which, since application is left associative, is just map swap foo.
17:45:53 <mbac> i see, thank you!
17:47:20 <racliv> > f (+1) [1..3] where f = (uncurry (++)) . (tand id map) where tand f g x = (f x, g x)
17:47:21 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> b'
17:48:02 <racliv> > f (+1) [1..3] where f = (uncurry (++)) . (tand id) . map where tand f g x = (f x, g x)
17:48:03 <lambdabot>   Couldn't match expected type `([a], [a])'
17:48:31 <racliv> > f (+1) [1..3] where f = (tand id) . map where tand f g x = (f x, g x)
17:48:32 <lambdabot>   ([1,2,3],[2,3,4])
17:48:48 <racliv> > f (+1) [1..3] where f = (tand id) where tand f g x = (f x, g x)
17:48:48 <lambdabot>       No instance for (Num [t])
17:48:49 <lambdabot>        arising from the literal `1' at <inter...
17:49:00 <racliv> > f (+1) [1..3] where f = (tand id) . const 7 where tand f g x = (f x, g x)
17:49:01 <lambdabot>       No instance for (Num ([t1] -> t))
17:49:01 <lambdabot>        arising from the literal `7' a...
17:49:03 <mm_freak> zeno: well, they use lists
17:49:22 <racliv> > f (+1) [1..3] where f = tand id map where tand f g x = (f x, g x)
17:49:23 <lambdabot>   Couldn't match expected type `[t1] -> t'
17:53:26 <mib_g1k8js> :t try
17:53:28 <lambdabot> Not in scope: `try'
17:53:34 <mib_g1k8js> :t evaluate
17:53:35 <lambdabot> Not in scope: `evaluate'
17:54:52 <mm_freak> > f (+1) [1..3] where f = (uncurry (++) .) . (id &&&) . map
17:54:54 <lambdabot>   [1,2,3,2,3,4]
17:55:24 <mm_freak> > f (+1) [1..3] where f = (uncurry (++) .) . second . map
17:55:25 <lambdabot>   Couldn't match expected type `([a], [a])'
17:56:09 <mm_freak> but i guess lambdabot's version is more comprehensible =)
17:58:10 <mm_freak> > f (+1) [1..3] where f = (uncurry (++) .) . second map
17:58:11 <lambdabot>   Couldn't match expected type `a1 -> ([a], [a])'
17:59:06 <mm_freak> @hoogle a b c -> a b (c,c)
17:59:06 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
18:01:12 <mm_freak> > f (+1) [1..3] where f = (uncurry (++) .) . second map . (\x -> (x+x))
18:01:13 <lambdabot>   Couldn't match expected type `a1 -> ([a], [a])'
18:01:13 <JohnnyL> can someone tell me if you have good haskell experience if it's easy to get a job? (like telecommute)
18:05:17 <racliv> @src uncurry
18:05:17 <lambdabot> uncurry f p = f (fst p) (snd p)
18:05:35 <racliv> @pl uncurry f p = f (fst p) (snd p)
18:05:35 <lambdabot> uncurry = (`ap` snd) . (. fst)
18:06:28 <luite> zeno: I made a new version, that just shuffles Ints in a STUArray, which is about twice as fast in GHCi (havent tested ghc -O2 yet)
18:08:03 <mm_freak> JohnnyL: currently easier with other languages, sadly, but knowing haskell is always a good thing, and may pay off later, as haskell's community is growing fast
18:10:47 <int-e> zeno: http://hpaste.org/13178 does random shuffling with lists. (Using arrays will be faster. But I believe this is a neat idea.)
18:11:34 <solrize> JohnnyL there aren't many haskell jobs per se, but learning haskell will make you a better programmer in every language that you use
18:12:28 <wchogg> Also, from surveying the market lately I'd say that a job where you hack Haskell is likely to be much more interesting than the average one.
18:12:40 <pumpkin_> although you may be tempted to not use variables where variables fit well, in the language you use
18:12:44 <racliv> @src curry
18:12:44 <lambdabot> curry f x y = f (x, y)
18:12:58 <racliv> @pl curry f x y = f (x, y)
18:12:58 <lambdabot> curry = (. (,)) . (.)
18:13:11 <luite> zeno: reload the hpaste if you're interested, I added it as an annotation
18:13:15 <wchogg> The pointless form of curry is ust kind of silly
18:13:24 <wchogg> and my j is really sticky tonight
18:14:00 <dolio> That should really turn into curry = curry.
18:14:19 <dolio> But the rules in @pl have their flaws.
18:14:31 <mm_freak> racliv: you should refrain from overusing points-free style…  it can quickly become pointless
18:14:34 <solrize> the guy who runs skydeck.com (they use ocaml to crunch customer data for phone companies) told me something interesting, they used to not mention in their advertising that they used ocaml, not because it was secret but b/c they basically didn't want to scare people
18:14:49 <int-e> @pl uncurry (curry f)
18:14:49 <lambdabot> f
18:14:57 <solrize> i.e. they hired python and java programmers and got them to learn ocaml, which went sort of ok
18:15:02 <solrize> but then word got out that they were using ocaml
18:15:11 <solrize> and suddenly all the fp nerds wanted to work there
18:15:19 <solrize> so their recruiting problem went away
18:15:29 <wchogg> hah
18:15:48 <solrize> maybe i am misremembering the story somewhat but that was basically the gist of it
18:15:50 <mm_freak> and yeah, since i program in haskell, i'm using many functional concepts in other languages, most notably CPS =)
18:16:36 <mm_freak> and i have a much clearer distinction between pure and side-effecting code, even in languages like C, where it's almost impossible to write pure code
18:21:30 <JohnnyL> mm_freak, solrize, ok thanks guys, i was getting that feeling too.
18:22:30 <solrize> johnnyL i've even heard that some companies including google and microsoft use haskell as a screen test, i.e. if you mention haskell on your resume they automatically flag you as an interesting candidate, even though there's almost no chance that you'll actually use haskell if they hire you
18:23:04 <JohnnyL> yeah, haskell is quite challenging!
18:23:05 <solrize> i have no idea if that's true but it sort of makes sense
18:24:47 <wchogg> I don't know if it's that haskell is particularly difficult, but to go out of your way to learn it does indicate an affection for CS a lot of programmers I've met don't have.
18:24:52 <mm_freak> haskell is about the only language i know of, which uses the concept of abstraction and generalization to that extent
18:25:29 <solrize> haskell instills clarity of thought in programmers
18:25:35 <mm_freak> particularly generalization is a concept, which is alien to most programmers, even functional non-haskell programmers
18:26:08 <pumpkin_> many of the programmers I know of use being interested in CS as some sort of insult
18:26:14 <mm_freak> the language itself isn't difficult, it's the abstract thinking you need to get used to
18:26:53 <wchogg> pumpkin_ : I've experienced that.  I actually got made fun of for reading fp papers over my lunch breaks at one job.
18:28:01 <mokus> solrize: Haskell selects (in the darwinian sense) clarity of thought in programmers
18:28:33 <solrize> nah it's more lamarckian than that.  if you didn't think clearly before you started with haskell, you will afterwards :)
18:28:36 <lament> how Randian
18:28:59 <pumpkin_> very ianian of you all
18:34:39 <mpeter> mokus: explain
18:34:56 <mpeter> by deterring lazy programmers? :0\
18:35:27 <mokus> mpeter: basically just a simple idea that through various means the programmers who can't or won't learn to think clearly get scared off or bored off
18:35:51 <mokus> because there's greener pastures for them elsewhere
18:36:13 <solrize> i think you have to be a bit of a masochist to enjoy haskell.  but it's a good kind of pain, like running a marathon ;)
18:36:58 <mokus> or having your brain rubbed with a fine cheese grater
18:37:05 <solrize> heh
18:37:37 <mpeter> learning haskell is like learning to program correctly
18:37:46 <chrisdone> coi ro do
18:38:18 <mm_freak> mpeter: that's because if your program is incorrect, it usually doesn't compile at all =)
18:38:21 <mxc> hi everyone
18:39:14 <edwardk> @seen lispy
18:39:14 <lambdabot> lispy is in #haskell-blah, #darcs and #haskell. I last heard lispy speak 2h 28m 35s ago.
18:39:41 <mpeter> usually ;)
18:39:54 <mpeter> which reminds me
18:39:59 <mpeter> how often is that not true
18:40:42 <mm_freak> i'd say learning haskell is like learning to express correctly
18:41:13 <mpeter> i mean, i learned how to do that in PHP
18:41:29 <mpeter> the quality of my code increased drastically when i realized i should stop telling the computer to do things which were stupid
18:41:53 <racliv> like what?
18:42:08 <int-e> @remember mpeter the quality of my code increased drastically when i realized i should stop telling the computer to do things which were stupid
18:42:08 <lambdabot> Okay.
18:42:22 <mpeter> like binding a variable twice
18:43:06 <racliv> is map parallel?
18:43:11 <mpeter> you know, taking something from an env
18:43:18 <dibblego> racliv, no, see parMap
18:43:27 <mpeter> combining it with something else into another variable
18:43:29 <mpeter> and so on
18:43:38 <racliv> @hoogle parMap
18:43:38 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
18:43:53 <mm_freak> it's hard not to do the wrong thing with PHP
18:44:01 <mpeter> it's really not
18:44:07 <mpeter> it's rather intuitive
18:44:17 <int-e> mm_freak: it's simple, don't use it ;)
18:44:20 * int-e ducks
18:44:32 <mm_freak> int-e: i agree =)
18:44:55 <racliv> @src parmap
18:44:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:45:00 <racliv> @src parMap
18:45:00 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:45:52 <mm_freak> racliv: http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html
18:46:03 <mpeter> then again, i write awesome functional PHP now
18:46:20 <mpeter> or quasi-functional
18:46:27 <mpeter> if you want to be strict
18:48:04 <mm_freak> mpeter: the worst thing about PHP is its type system
18:48:08 * edwardk is too lazy to be strict.
18:48:19 <mm_freak> it was the main source for insecure or inconsistent code for me
18:49:09 <racliv> why couldn't you just use haskell then?
18:49:44 <mpeter> i'm using it now
18:49:48 <mpeter> what do you think i'm doing in here? ;)
18:49:50 <mm_freak> racliv: i use haskell, where i can, but unfortunately that's not everywhere =)
18:49:52 <mpeter> i don't mind PHP's type system that much, though
18:50:30 <chessguy> hey ya'all
18:50:30 <mpeter> if you can read a manual, you're fine
18:50:46 <mpeter> @type map
18:50:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:50:48 <mpeter> is nice to have, though
18:50:54 <mm_freak> yeah, but it often gives bizarre results
18:51:00 <int-e> which type system?
18:51:01 <mpeter> such as?
18:51:05 <mm_freak> int-e: PHP's
18:51:20 <int-e> mm_freak: my question stands.
18:51:24 <jowens> Hey, a little n00b help, if you would. I'm trying to write a function that takes a string of digits and multiply the first 5 digits together. I'm getting a type error I can't figure out.
18:51:29 <jowens> prod5 (a:b:c:d:e:_) = (read a::Int)*(read b::Int)*(read c::Int)*(read d::Int)*(read e::Int)
18:51:29 <jowens> prod5 _ = 0
18:51:43 <jowens>     Couldn't match expected type `[Char]' against inferred type `Char'
18:51:43 <jowens>       Expected type: [String]
18:51:43 <jowens>       Inferred type: [Char]
18:51:55 <mpeter> jowens:
18:51:55 <qwr> jowens: String is [Char]
18:52:01 <int-e> mm_freak: sorry, bashing PHP is too easy, and somewhat satisfying as well.
18:52:04 <dons> dibblego: sometimes when i read whinging about type systems i just want to say "harden the fuck up" ;)
18:52:11 <mpeter> bashing PHP is for people that haven't written a lot of PHP ;)
18:52:12 <jowens> yes, i understand string is [char]
18:52:15 <mpeter> it has its issues
18:52:15 <dibblego> dons, damn straight :)
18:52:20 <jowens> but i'm not sure where i went wrong in my code :)
18:52:28 <mpeter> but you can still write bulletproof code
18:52:28 <jowens> if i add prod5 :: [Char] -> Int
18:52:29 <dons> :)
18:52:37 <jowens> i instead get     Couldn't match expected type `String' against inferred type `Char'
18:52:40 <mm_freak> mpeter: "" == 0
18:52:40 <mokus> jowens: a, b, c, etc, are :: Char
18:52:49 <jowens> :: Char is ?
18:52:50 <dibblego> dons, head down to Bunnings, throw a 40kg bag of cement over your shoulder, go home, add water, then harden the fuck up! :)
18:52:56 <qwr> jowens: probably you trying to read Char in String or something like that
18:52:59 <mokus> read [a] instead of read a
18:53:03 <mpeter> mm_freak: i've used those little quirks to my advantage a number of times
18:53:04 <mm_freak> mpeter: "" == 0, and "0" == 0
18:53:15 <mm_freak> which would mean "" == "0"
18:53:24 <mpeter> big deal
18:53:31 <jowens> mokus: you're suggesting i need to read [a]?
18:53:34 <jowens> what does that do?
18:53:53 <dons> dibblego: :)
18:54:01 <int-e> mm_freak: http://media.fukung.net/images/7729/php_vs_python.png ;)
18:54:02 <mokus> jowens: it takes the single Char a and makes a string (list of Chars) with just one char, namely a
18:54:06 <jowens> (what i have is just a big number defined as a string: num = "123456" etc.)
18:54:14 <qwr> jowens: make one element list. or string in that case.
18:54:17 <mm_freak> mpeter: i'd prefer not to be able to use this for my advantage =)
18:54:24 <mpeter> jowens: why are you doing this?
18:54:34 <jowens> mpeter: Project Euler # 8
18:54:34 <mokus> > [ '1' ] == "1"
18:54:36 <lambdabot>   True
18:54:41 <jowens> "Find the greatest product of five consecutive digits in the 1000-digit number."
18:54:45 <mokus> > read [ '1' ]
18:54:46 <lambdabot>   * Exception: Prelude.read: no parse
18:54:49 <mpeter> > (show 1) == "1"
18:54:50 <lambdabot>   True
18:54:51 <pumpkin_> jowens: doing project euler?
18:54:59 <jowens> pumpkin_: yup
18:55:04 <mpeter> ah, ok
18:55:04 <qwr> >> foldr (*) 1 (map ((:[]) . read) "123456")
18:55:08 <qwr> > foldr (*) 1 (map ((:[]) . read) "123456")
18:55:09 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
18:55:17 <mpeter> i have an idea
18:55:18 <qwr> > foldr (*) 1 (map (read . (:[])) "123456")
18:55:19 <lambdabot>   720
18:55:26 <pumpkin_> jowens: Data.Char has digitToInt in it
18:55:26 <mpeter> and that was it
18:55:31 <pumpkin_> > digitToInt '5'
18:55:32 <lambdabot>   5
18:55:34 <mokus> why does everyone try to teach fold to the people that are still learning pattern matching? ;-)
18:55:55 <jowens> i don't mind learning fold, but i'd really like to know what i'm doing wrong.
18:56:08 <jowens> entire program:
18:56:08 <jowens> prod5 (a:b:c:d:e:_) = (read a::Int)*(read b::Int)*(read c::Int)*(read d::Int)*(read e::Int)
18:56:09 <jowens> prod5 _ = 0
18:56:09 <jowens> compute5 l n = prod5 (drop n l)
18:56:09 <jowens> main = print (maximum (map (compute5 num) [0..1000]))
18:56:12 <jowens> 4 lines
18:56:17 <mokus> when you break up the string you're putting each char into a variable
18:56:21 <jowens> (num is "123456" etc.)
18:56:28 <mm_freak> jowens: you'll like the 'tails' function
18:56:34 <pumpkin_> jowens: a, b, c,d, e are all Chars, not Strings
18:56:39 <pumpkin_> a String is [Char]
18:56:40 <mm_freak> map (take 5) . tails
18:56:44 <mokus> but read wants a string
18:56:45 <int-e> jowens: read [a] etc. would work. [a] has type [Char] in that context, i.e. String
18:56:47 <mpeter> @let factoriallll x = x*factorial(pred x)
18:56:48 <lambdabot>  <local>:10:19: Not in scope: `factorial'
18:56:52 <mpeter> fuck you lambdabot
18:56:56 <jowens> ah, read wants a string, that's the key thing.
18:56:59 <mpeter> @let factoriallll x = x*factoriallll(pred x)
18:57:00 <lambdabot>  Defined.
18:57:05 <mpeter> > factoriallll 6
18:57:08 <jowens> that's what i had wrong.
18:57:08 <lambdabot>   * Exception: stack overflow
18:57:12 <mpeter> fuck you lambdabot
18:57:13 <pumpkin_> mpeter: base case maybe? :P
18:57:29 <jowens> mm_freak: yes, i will look at tails.
18:57:45 <jowens> thanks guys, that'll clear my issue. you all rock.
18:58:02 <int-e> @botsnack
18:58:02 <lambdabot> :)
18:58:02 <lunabot>  :)
18:58:25 <qwr> @type read
18:58:26 <lambdabot> forall a. (Read a) => String -> a
18:58:43 <mm_freak> > maximumBy (compare `on` product) . map ((- chr '0') . ord . take 5) . tails $ "5723648572634598723"
18:58:44 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
18:59:02 <mpeter> oh right
18:59:03 <luite> http://hpaste.org/12291#a6 <- this code stack overflows when I try to shuffle list of 1M elements, how can I find out what's wrong?
18:59:20 <mm_freak> > maximumBy (compare `on` product) . map ((- ord '0') . ord . take 5) . tails $ "5723648572634598723"
18:59:21 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `Int'
18:59:51 <mm_freak> > maximumBy (compare `on` product) . map (map ((- ord '0') . ord) . take 5) . tails $ "5723648572634598723"
18:59:52 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `Int'
18:59:56 * mpeter whistles
19:00:19 <mpeter> @let factoriall n = foldl (*) 1 [1..n]
19:00:19 <lambdabot>  Defined.
19:00:23 <mpeter> @factoriall 6
19:00:24 <lambdabot> Unknown command, try @list
19:00:33 <mpeter> .......
19:00:37 <mpeter> @let factoriall n = foldl (*) 1 [1..n]
19:00:38 <lambdabot>  <local>:1:0:
19:00:38 <lambdabot>      Warning: Pattern match(es) are overlapped
19:00:38 <lambdabot>               In...
19:00:47 <mpeter> wtf
19:00:54 <mxc> can anyone recommend any good image manipulation libraries?
19:00:55 <mpeter> > factoriall 6
19:00:57 <lambdabot>   720
19:01:02 * mpeter collapses
19:01:13 <mm_freak> > tails . map ((- ord '0') . ord) $ "5723648572634598723"
19:01:14 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `Int'
19:01:33 <mm_freak> > tails . map ((subtract $ ord '0') . ord) $ "5723648572634598723"
19:01:34 <lambdabot>   [[5,7,2,3,6,4,8,5,7,2,6,3,4,5,9,8,7,2,3],[7,2,3,6,4,8,5,7,2,6,3,4,5,9,8,7,2...
19:01:38 <mm_freak> d'oh
19:02:00 <mm_freak> > maximumBy (compare `on` product) . map (take 5) . tails . map ((subtract $ ord '0') . ord) $ "5723648572634598723"
19:02:01 <lambdabot>   [4,5,9,8,7]
19:02:24 <mxc> for reading in a PNG/JPG/BMP and getting an array of pixels, something like that
19:02:25 <mpeter> i need to order some dinner or something
19:02:30 <mpeter> god damn
19:02:35 <mm_freak> > map chr . maximumBy (compare `on` product) . map (take 5) . tails . map ((subtract $ ord '0') . ord) $ "5723648572634598723"
19:02:36 <lambdabot>   "\EOT\ENQ\t\b\a"
19:02:48 <mxc> seems whats on hackage is either abandonware, incomplete or something
19:02:53 <jowens> let's say i want to use tails in ghc. um, how do i include it? It's in Data.List.
19:03:15 <mm_freak> jowens: import Data.List?
19:03:16 <qwr> jowens: import Data.List
19:03:20 <jowens> ok will try.
19:03:23 <jowens> have not done this befre.
19:03:46 <jowens> got it thx!
19:04:16 <mm_freak> it sucks that Char is not a Num instance =/
19:04:36 <mm_freak> would save a lot of ord/chr calls
19:05:06 <orbitz> does Char have a conversion to Word8?
19:05:24 <mpeter> > death
19:05:25 <lambdabot>   41.99999999999999
19:05:44 <orbitz> > Data.ByteString.Lazy.singleton ','
19:05:45 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
19:05:58 <mpeter> @src death
19:05:58 <lambdabot> Source not found. My mind is going. I can feel it.
19:05:58 <mokus> > death :: Expr
19:05:59 <lambdabot>   5678 / 135.1904761904762
19:06:09 <mpeter> that's not right
19:06:18 <mpeter> > life
19:06:19 <lambdabot>   [71,110,118,31,108,96,109,120,31,115,104,108,100,114,31,99,110,31,72,31,103...
19:06:38 <luite> hm, the   newListArray (1,1000000) [1..]    seems to stack overflow
19:06:39 <mpeter> > foldr (+) 1 life
19:06:40 <lambdabot>   5678
19:06:54 <Gracenotes> > map (chr) life
19:06:55 <lambdabot>   "Gnv\USl`mx\USshldr\UScn\USH\USg`ud\USsn\USsdkk\USxnt\USmns\USsn\USrghs\USh...
19:07:01 <orbitz> > ',' :: Word8
19:07:02 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
19:07:06 <Gracenotes> > map (chr . (+1)) life
19:07:07 <lambdabot>   "How many times do I have to tell you not to shit in the sink!!?!?!?"
19:07:17 <Gracenotes> o_o
19:07:46 <mpeter> uh-oh
19:07:49 <mpeter> > sentience
19:07:50 <lambdabot>   "Don't touch my server."
19:07:50 <luite> any idea on a different way to fill an array with values 1..1000000 ?
19:07:51 <pumpkin_> does lambdabot have Control.Monad.Omega?
19:08:05 <pumpkin_> > diagonal
19:08:06 <lambdabot>   Not in scope: `diagonal'
19:08:18 <mpeter> > diagonal
19:08:20 <lambdabot>   "Horizontal."
19:08:26 <orbitz> hrm
19:08:28 <pumpkin_> someone's having fun with @let in pm
19:08:34 <mpeter> talk about an impure function
19:08:38 <mxc> luite:  [1..1000000]
19:08:50 <pumpkin_> fromList [1..1000000]
19:09:03 <mxc> oh, array, my bad
19:09:12 <Pseudonym> > [1..1000000]
19:09:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:09:17 <Gracenotes> let encode = map ((-1) . ord); decode = map (chr . (+1)) in (decode . encode) "What??????"
19:09:25 <Gracenotes> > let encode = map ((-1) . ord); decode = map (chr . (+1)) in (decode . encode) "What??????" --meh
19:09:26 <lambdabot>       No instance for (Num (Int -> Int))
19:09:26 <lambdabot>        arising from the literal `1' ...
19:09:32 <orbitz> how come Data.ByteString.Lazy.pack "foo" gives complaitns about expecting Word8 but getting Char?. is this osmethign funny with ghci?
19:09:50 <luite> mxc: yeah I tried that, but newListArray (1,1000000) [1..]   (or [1..1000000] ) stackoverflows
19:10:25 <twb> For "cabal install", how do I set $DESTDIR ?
19:10:40 <twb> i.e. like make install DESTDIR=$PWD/debian/tmp
19:10:51 <Gracenotes> > let encode = map (((-)1) . ord); decode = map (chr . (+1)) in (decode . encode) "hope it works this time"
19:10:52 <lambdabot>   "* Exception: Prelude.chr: bad argument
19:10:55 <Pseudonym> @undefine
19:11:12 <Gracenotes> :/
19:11:19 <pumpkin_> ong an Axman6 <_<
19:11:23 <pumpkin_> omg even
19:11:27 <Gracenotes> > (-1) 3
19:11:28 <lambdabot>       No instance for (Num (t -> a))
19:11:28 <lambdabot>        arising from a use of `negate' at...
19:11:44 <pumpkin_> > (- 1) 3
19:11:45 <lambdabot>       No instance for (Num (t -> a))
19:11:45 <lambdabot>        arising from a use of `negate' at...
19:11:49 <mokus> it always bugged me that there isn't an array construction function that just takes a function from the index type to the element type
19:11:50 <twb> > (-1 +) 3
19:11:51 <lambdabot>   2
19:12:02 <pumpkin_> I hate the minus operator :P
19:12:03 <twb> -1+ is a lispism :-)
19:12:18 <twb> pumpkin_: you would prefer (~1) like ML? ;-)
19:12:20 <luite> mokus: that's exactly what I was looking for :)
19:12:24 <mokus> and (subtract 1) is too many letters ;-)
19:12:26 <pumpkin_> twb: why not :P
19:12:45 <twb> pumpkin_: it look ugly?
19:12:53 <twb> pumpkin_: actually I'd like unicode haskell
19:13:05 <twb> pumpkin_: so e.g. I type λ, not \
19:13:13 <pumpkin_> you have a lambda on your keyboard?
19:13:17 <mpeter> do you have a lambda key on your keyboard
19:13:18 <twb> No.
19:13:18 <mpeter> i don't
19:13:21 <mokus> twb: that'd be nice
19:13:23 <twb> Is that important?
19:13:27 <mpeter> yes
19:13:30 <Gracenotes> :t λ
19:13:31 <lambdabot> Not in scope: `'
19:13:31 <twb> I don't have a ü on my keyboard, either.
19:13:38 <pumpkin_> I'd get myself a keyboard with a lambda key if that were built into haskell
19:13:44 <mpeter> i rather like \ notation
19:13:55 <pumpkin_> ooh a new startup idea!
19:13:57 <mpeter> pumpkin: just bind it yourself, eh
19:13:58 <twb> \ is just the most common example
19:14:02 <pumpkin_> make keyboards with lambda keys for haskell hax0rz
19:14:03 <pumpkin_> ;)
19:14:07 <mokus> pumpkin_: or a text editor with a context-sensitive lambda macro
19:14:08 <twb> ↦ and ≠ are others
19:14:14 <mpeter> what serious haskell hax0rz can't use xbindkeys or something
19:14:15 <twb> mokus: I already have that
19:14:19 <pumpkin_> mokus: no fun, it's gotta be physical!
19:14:35 <twb> I just use the LaTeX input method
19:14:39 <mokus> you could paint over your \ key
19:14:47 <twb> mokus: that's what I do
19:14:52 <twb> mokus: /msg fsbot prettylambda
19:15:06 <mokus> twb is way ahead of me :)
19:15:14 <twb> mokus: but it's still ugly in diff output and similar.
19:15:26 <twb> And the regexp for making it look pretty is flaky
19:16:07 <twb> And if you have a LOT of those pretties, you end up exceeding your maximum line length, because Emacs wraps at the pretty length, not the decomposed length
19:16:22 <twb> That's why currently I don't markup ≡ and similar
19:16:41 <luite> hm, there seem to be more stack overflows :(
19:17:07 <mokus> or you could put the lambdas in your source files and use a preprocessor to convert them to backslashes
19:17:17 <mokus> you could call it "unlambda" even ;-)
19:18:01 <mokus> I wonder what cpp would do with a lambda
19:18:17 <mokus> probably nothing I'd want it to
19:19:15 <Gracenotes> > let ◌ ♬ ɷ ☹ = map (+☹) [♬..ɷ] in ◌ 2 4 6
19:19:16 <lambdabot>   <no location info>: parse error on input `◌'
19:19:38 <Gracenotes> :/
19:25:08 <twb> mokus: you could ALMOST do it just with iconv –to ascii//translit
19:29:36 <rastar> hey when trying to build ghc-x11-1.4.2 i get the following error http://rafb.net/p/9yy1fR59.html
19:29:37 <Cale> > let (◌) ♬ ɷ ☹ = map (+☹) [♬..ɷ] in ◌ 2 4 6
19:29:38 <lambdabot>   <no location info>: parse error on input `='
19:29:45 * pumpkin_ is in love with Control.Monad.Omega
19:29:57 <Cale> > let (◌) (♬) (ɷ) (☹) = map (+(☹)) [(♬)..(ɷ)] in (◌) 2 4 6
19:29:58 <lambdabot>   [8,9,10]
19:30:30 <pumpkin_> lol
19:30:31 <Cale> > let ((♬) ◌ (ɷ)) (☹) = map (+(☹)) [(♬)..(ɷ)] in (◌) 2 4 6
19:30:32 <lambdabot>   [8,9,10]
19:30:39 <ikkebr> omg
19:32:10 <rastar> nvm bumped to 1.4.5 and works ;)
19:40:02 <pumpkin_> how possible are "lazy numbers" to implement efficiently? say I was going to do let moo xs = length xs > 3 ... it doesn't need to evaluate all of the list to determine if the condition is met, but it sort of needs to "know" about what it's being compared to
19:41:39 <Gracenotes> let moo xs = drop 3 xs /= [] in moo [1,2]
19:41:47 <Gracenotes> > let moo xs = drop 3 xs /= [] in moo [1,2] --meh
19:41:48 <lambdabot>   False
19:41:55 <Gracenotes> > let moo xs = drop 3 xs /= [] in moo [1,2,3,4,5]
19:41:56 <lambdabot>   True
19:42:22 <Gracenotes> actually, null would probably be better than /= []
19:42:27 <Gracenotes> it would look prettier too
19:42:39 <pumpkin_> I mean in general, though
19:43:17 <Gracenotes> hm... what other cases did you have in mind?
19:46:33 <Gracenotes> it might be kind of inefficient if you checked that length xs > 10000 was false 10000 times, and then after counting to 10000 discovering it was true
19:46:45 <luite> zeno: I now have a version that doesn't stack overflow anymore, it shuffles a list of 1M elements in ~3 seconds on my (2GHz) laptop. I'm trying to make it faster
19:47:28 <mm_freak> Gracenotes: yes, null is better than (== []), because the latter requires Eq and is technically a bit slower
19:47:36 <mm_freak> null just needs pattern matching
19:51:17 <edwardk> i always find it funny when i hack up something in code, and then find the idea published a year later by someone who invented it in parallel
19:51:25 <orbitz> @pl \x -> f x : g x
19:51:26 <lambdabot> liftM2 (:) f g
19:51:35 <orbitz> @src liftM2
19:51:35 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:51:44 <orbitz> hrm
19:51:49 <orbitz> @hoogle liftM2
19:51:49 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:53:05 <mm_freak> :t f &&& g >>> uncurry (:)
19:53:06 <lambdabot> forall b a. (SimpleReflect.FromExpr [a], SimpleReflect.FromExpr a, Show b) => b -> [a]
19:54:30 <orbitz> > liftM2 (:) (takeWhile (/='\n')) (dropWhile (/='\n')) "thies\niseies\nfjekwlfjwlfewl\n"
19:54:31 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
19:54:54 <beachsurfin> why is it that many are starting write about the functional paradigm as the future of programming?
19:54:57 <mm_freak> > lines "thies\niseies\nfjekwlfjwlfewl\n"
19:54:59 <lambdabot>   ["thies","iseies","fjekwlfjwlfewl"]
19:55:13 <orbitz> mm_freak: trying to write lines for ByteString
19:55:19 <chylli> are there some articles about haskell kernel ? Or a tutorial || implementation of haskell kernel ?
19:55:20 <edwardk> beachsurfin: because groupthink says it is
19:55:25 <orbitz> oh durh i know why i fail
19:55:32 <byorgey> pumpkin_: there is a lazy natural number package on hackage, IIRC.
19:55:44 <mm_freak> orbitz: it should be available
19:55:50 <byorgey> pumpkin_: but they aren't very space-efficient, I'd guess.
19:56:01 <edwardk> i realize that is somewhat metacircular =)
19:56:31 <mm_freak> orbitz: see Data.ByteString.Char8
19:56:48 <dons> beachsurfin: mm. the majority of new language innovation is happening in functional languages
19:56:57 <orbitz> mm_freak: oh silly me
19:57:06 <orbitz> mm_freak: i was looking in just .Lazy, no Lazy.Char8
19:57:22 <mm_freak> =)
19:57:27 <orbitz> mm_freak: thanks
19:57:34 <mm_freak> you're welcome
19:57:54 <ddarius> edwardk: It's a self-fulfilling prophecy.
19:58:29 <beachsurfin> dons: language innovation, as in?
19:58:47 <edwardk> types may have taken a long time to get to where they are now, but they admit a lot of really nice abstractions that you just can't build in a more ad-hoc setting effectively. functional programming provides a vocabulary that imperative programming lacks. a lot of folks are just now starting to realize that lack
19:58:56 <beachsurfin> ruby, python, and haskell, what?
19:59:01 <dons> as in, say, composable transactional memory, fast high level threads, theorem proving type systems, you pick it.
19:59:05 <beachsurfin> i haven't seen much from haskell aside from xmonad
19:59:16 <beachsurfin> though i haven't looked too hard yet
19:59:16 <dons> http://hackage.haskell.org
19:59:55 <edwardk> beachsurfin: software transactional memory, monads in general, you can turn almost anything from category theory into a tool for computation because of the strength of the type system, and lo and behold they do useful things
19:59:58 <dons> haskell.org is the center of thiiings.
20:00:18 <dons> edwardk loves CT.
20:00:22 <dons> he is Mr. CT actually.
20:00:22 <edwardk> hah
20:00:39 * Taejo is the real Mr Cape Town
20:00:43 <dons> hehe
20:00:56 <ddarius> edwardk is a model from Connecticut?
20:00:58 <mm_freak> @pl \(x,y) -> (y,x)
20:00:58 <lambdabot> uncurry (flip (,))
20:01:41 <edwardk> nah, i'm more like "mr. fumbling towards implementing lots of CT stuff in Haskell in a barely-adequate way." ddarius here knows more CT than I do. I just apply it to Haskell more ;)
20:01:45 <orbitz> , is an operator too...?
20:01:49 <Axman6> @let swap (x,y) = (y,x)
20:01:50 <lambdabot>  Defined.
20:01:51 <lunabot>  luna: Not in scope: `is'
20:01:53 <orbitz> (,) 1 2
20:01:55 <orbitz> > (,) 1 2
20:01:56 <lambdabot>   (1,2)
20:02:00 <Taejo> and I hope to become Mr Category-Theory-in-Cape-Town, but some pretty awesome mathematicians would have (re)emigrate for that to happen
20:02:03 <orbitz> that's wild
20:02:09 <orbitz> i thought ti was syntax for whatever reason
20:02:12 <orbitz> :t (,)
20:02:13 <lambdabot> forall a b. a -> b -> (a, b)
20:02:14 <Axman6> > (,,,) 1 2 3 4
20:02:15 <lambdabot>   (1,2,3,4)
20:02:21 <ddarius> orbitz: , is not an operator.
20:02:23 <dons> i donn't understand this proposed logo, http://haskell.org/sitewiki/images/thumb/b/bc/Haskell-cjay2b.svg/800px-Haskell-cjay2b.svg.png
20:02:27 <dons> anyone?
20:02:33 <orbitz> ddarius: as in, it's just a stnadard function?
20:02:57 <ddarius> orbitz: No, as in it is not syntactically an operator.
20:03:07 <ddarius> You can't write a , b
20:03:23 <sjanssen> dons: just looks like it was misrendered
20:03:24 <Axman6> dons: yeah i've got nothing
20:03:29 <solrize> pwnage ?
20:03:34 <edwardk> orbitz: its 'slightly magical', (,,) is an operator as well, for any # of commas, its not just repeated application of the (,) constructor, (,,) only has one bottom, not two. (,,,) only has one bottom, not three, etc.
20:03:42 <sjanssen> dons: "image/" with a black box covering part of it?
20:03:42 <orbitz> > 1 `,` 2
20:03:43 <lambdabot>   <no location info>: parse error on input `,'
20:03:50 <dons> sjanssen: yeah
20:04:08 <ddarius> edwardk: It's a function, not an operator (in a rather pedantic sense).  More specifically, it is a constructor.
20:04:09 <sjanssen> clearly somebody's SVG -> PNG converter doesn't work correctly
20:04:13 <dons> ah, http://haskell.org/haskellwiki/Image:Haskell-cjay2b.png
20:04:14 <orbitz> edwardk: so it's soemwhere ebtween (:) and not?
20:04:34 <pumpkin_> http://haskell.org/sitewiki/images/1/1d/Monica_monad_falconnl.png is clearly the best
20:05:01 <luite> how do I install the profiling libraries for a hackage package using cabal-install?
20:05:16 <dons> galois' graphic designer came up with http://galois.com/~dons/images/logos/Haskell_logo.png interesstingly
20:05:27 <pumpkin_> luite: it's a pain if you already have a bunch of packages installed that the new package depends on
20:05:40 <pumpkin_> otherwise, I think just pass -p to the install, or change your config to enable profiling
20:05:48 <Axman6> luite: caban install <package> -p
20:05:52 <Axman6> cabal*
20:05:55 <edwardk> i'll admit the "magic" behavior of [] , and : in Haskell have always bugged me.
20:05:55 <dons> not sure how seriouus BeelsebobWork's entry is, http://haskell.org/sitewiki/images/f/f3/UnsafeHaskell.png
20:05:56 <orbitz> hrm
20:06:00 <dons> ?src []
20:06:00 <lambdabot> data [] a = [] | a : [a]
20:06:03 <orbitz> my conversion to ByteString seems even slower
20:06:03 <dons> edwardk: simple! :)
20:06:16 <luite> pumpkin_: ah, unfortunately I have all my packages installed without profiling support :(
20:06:28 <pumpkin_> luite: I had a lot of trouble in that situation :P
20:06:40 <ddarius> edwardk: They're simple syntactic sugar, so it's not that big a deal, though you should be able to redefine (:) at least.
20:06:42 <Taejo> dons: the Galois one is nice, but what *is* it?
20:07:00 * ddarius does not like the Galois one.
20:07:00 <dons> its abstract and nice :)
20:07:04 <luite> pumpkin_: do the packages get slower when I enable profiling?
20:07:08 <Axman6> luite: it's not that hard to fix, just try installing packages with -p, and when it whinges about not having profiling versions of installed ones, just use cabal install <problem pkg> --reinstall -p
20:07:14 <pumpkin_> luite: nope, they compile two separate versions
20:07:25 <dons> i think it might be too abstract for haskellers though ...
20:07:45 <pumpkin_> Axman6: the issue is that you're basically going over the dependency tree backwards and if you have lots of packages, it can be a real pain
20:07:46 <dons> i'd like more professional designers to contribute
20:07:48 <sjanssen> not enough lambda
20:07:53 <pumpkin_> dons: I like the galois one
20:08:04 <edwardk> ddarius: i just cut out the sugar for them when toying around with haskell-like languages. mostly because i want the syntax back. and as Larry Wall says, every language feature wants to use ':' ;)
20:08:05 <sjanssen> (yes, I know there is an implied lambda)
20:08:07 <luite> Axman6: ah thanks, that worked
20:08:37 <dons> there's some very nice logos though, i have to admit.
20:08:40 <dons> http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
20:08:45 <sjanssen> I've got a fever, and the only prescription is more lambda
20:08:48 <dons> heh
20:08:49 <ddarius> dons: Way more than last time.
20:09:00 <dons> ddarius: yeah. seriously.
20:09:09 <ddarius> edwardk: Yet another widening of the chasm between me and Larry Wall.
20:09:28 <dons> pretty, http://haskell.org/sitewiki/images/9/99/Haskel_logo_preview_gburri.png
20:09:31 <Taejo> I don't know if http://haskell.org/sitewiki/images/2/21/Haskell-apankrat.png is by a professional designer, but the guy is from a forum where most people are
20:09:46 <edwardk> i kinda like the pure . simple . fun themed ones. 'purely functional' always bugs me, it is pure and it is functional, but it isn't purely functional. thats like saying that you feel badly. you feel bad. you aren't bad at feeling ;)
20:09:52 <dons> Taejo: interesting
20:10:14 <dons> edwardk: do you think it is simple?
20:10:27 <dons> i also don't like seeing 'lazy', since i think that's not so important.
20:10:31 <Taejo> I rather like Cale's
20:10:39 <dons> language features don't rate in logos, imo.
20:11:00 <dons> "ruby: some OO thing"
20:11:17 <mm_freak> @pl \k x -> x : k (x+1)
20:11:17 <lambdabot> ap (:) . (. (1 +))
20:11:18 <edwardk> not sure i buy 'simple', coherent yes, simple no.
20:11:18 <Axman6> RubyL WTFOP
20:11:32 <Axman6> :*
20:11:37 <dons> haskell-yeeeaaahh will get a special mention, i'm certain, http://haskell.org/sitewiki/images/8/85/NarleyYeeaaahh.jpg
20:11:44 <dons> edwardk: mm.
20:12:03 <edwardk> the haskell yeah one became my work-wallpaper.
20:12:17 <dons> heh
20:12:30 <edwardk> hell, pure . consistent . fun i could believe ;)
20:13:00 <Axman6>   <- Transparent lambda
20:13:45 <edwardk> I still want to write a 'Turbo Haskell' compiler.
20:13:56 <solrize> the periods can be too easily mistaken for the normal punctuation mark as it is more normally used in annoying advertising.  i liked pure -> simple -> fun  better
20:14:09 <solrize> turbo haskell, heh
20:14:09 <ddarius> edwardk: Wonderful. thc
20:14:25 <edwardk> just to get force the 'did you mean Pascal?' folks to do a triple take.
20:14:52 <ozy`> edwardk: I had that the other day with a former COBOL programmer
20:15:25 <edwardk> solrize: given my recent jit research i think its actually fairly viable to even do one in the line of the real old turbo pascal compilers and try to get strictness analysis and other slow stuff purely through trace compilation.
20:15:56 <edwardk> so compile down quickly then use a tracing jit to get a viable execution speed
20:16:03 <solrize> edwark, hmm, what's trace compilation?
20:16:19 <solrize> turbo pascal was a load and go compiler, something of a lost art
20:16:26 <solrize> http://lisperati.com/landoflisp/f057.png    haskell logo?   :)
20:16:36 <ddarius> edwardk: I liked Borland tools.  Not their IDEs, but the toolset was reasonably nice.
20:17:10 <edwardk> a tracing jit basically runs until a spot gets hot enough then interprets while logging a trace. if the trace makes it back to the starting point before it runs too long then you have a loop. optimize the loop.
20:17:16 <dons> solrize: thanks for reminding me of that
20:17:54 <solrize> dons, i can't tell whether you said that with a groan :)
20:17:57 <edwardk> if you take a different branch you exit the trace, restore registers and start another.
20:18:09 <dons> solrize: no, its nice. i've met the author, he's cool.
20:18:47 <solrize> dons, yeah, the whole comic is pretty funny, i keep checking for the nostarch book he mentions but it seems to have been forgotten
20:18:52 <ozy`> solrize: that's what mine is based on :p
20:19:01 <solrize> edwardk how do you get strictness analysis from that?
20:19:04 <luite> is it possible to get cpu profiling data, how much time is spent in which place, overlayed on ghc-core like output?
20:19:08 <edwardk> solrize: the tracemonkey stuff from firefox is along those lines.
20:19:19 <dons> luite: overlayed? no. profiling? yes.
20:19:20 <solrize> i'm not familiar with tracemonkey either
20:19:41 <ozy`> solrize: http://www.haskell.org/haskellwiki/Image:Haskell_proceed.png
20:19:43 <solrize> TraceMonkey adds native‐code compilation to Mozilla’s JavaScript engine (known as “SpiderMonkey”).
20:19:44 <solrize> whooa
20:19:45 <Cale> Thanks Taejo :)
20:19:50 <dons> luite: check the profiling chapter of RWH for general intro. the profiling section of the user's guide for a quick overview. or the various cpu cycle measuing things in ghc for advanced stuff
20:20:04 <solrize> ozy` heh
20:20:25 <edwardk> solrize: well, if you allocate a thunk in a trace, you can hold the contents of the thunk in registers when you compile the trace down, if you can show you will force the thunk before you can take a side exit then you can avoid constructing it in the first place.
20:20:30 <Cale> dons: It would be nice to get someone to integrate the hpc tools with the profiling tools.
20:20:38 <edwardk> solrize: on non-side-exit paths this can also perform unboxing
20:20:42 <luite> dons: ok, tnx
20:20:53 <solrize> edwardk wow, that's interesting
20:20:57 <dons> Cale: yep
20:20:57 <edwardk> solrize basically stuff has to be put in its usual locations only on side-exits
20:21:01 <solrize> you have to be able to check exhaustiveness ?
20:21:07 <Cale> Maybe a good idea for the next summer of code :)
20:21:36 <solrize> and, really it should be possible to do the same thing statically
20:21:45 <edwardk> not quite, remember traces are fairly small. the trick is commuting the side-exits past the allocation.
20:22:07 <edwardk> solrize: the problem is static analysis has to know a lot about the possible branches and wastes a lot of time applying these where its not needed.
20:23:33 <edwardk> solrize: its cheap to find out if a pointer doesn't escape a trace. thats why i've been focusing my optimization strategies on compiling down traces efficiently and basically ignoring the compiler.
20:24:10 <solrize> edwardk this is interesting, should i look at the gal/franz paper that the tracemonkey page links to ?
20:24:19 <edwardk> thats a decent starting point.
20:24:25 <solrize> ok
20:24:28 <edwardk> there are a few other papers by them
20:25:23 <solrize> this is neat
20:25:39 <solrize> is ndm's supero stuff sort of related?
20:26:23 <edwardk> not directly, but if you think of trying to do this sort of thing across all traces from the get-go rather than lazily as need is demonstrated, yes.
20:26:26 <solrize> it works by partial ahead-of-time execution of the user program iirc
20:26:39 <solrize> yeah ok
20:27:25 <edwardk> i just record traces, then constant fold and polyinline cache any indirect calls/jumps, and patch up the stack/etc to look normal on side exits
20:28:06 <rodge> solrize: which tracemonkey page were you reffering to?
20:28:21 <solrize> rodge https://wiki.mozilla.org/JavaScript:TraceMonkey
20:28:27 <rodge> thanks
20:28:46 <orbitz> if i return an IO [Foo], is that list strict because its in an IO?  i suppose it can't be since how would hGetContents work if it were
20:29:18 <solrize> orbitz, no, remember that IO is basically a synonym for (State RealWorld)
20:29:43 <orbitz> right right
20:29:45 <solrize> i.e. an io action is a function  of type RealWorld -> (RealWorld, a)
20:29:48 * orbitz needs to learn more abotu State monad
20:29:58 <solrize> it's a lazy state transformer
20:30:18 <orbitz> solrize: thanks
20:30:19 <solrize> in your example, "a" is [Foo], nothing special about it
20:31:34 <solrize> cale explained it pretty well, an IO action is basically a program that your "main" function returns to the runtime system, and the runtime executes it with its own set of rules
20:31:56 <Cale> main isn't a function :)
20:32:08 <Cale> main *is* one of these IO actions :)
20:32:15 <solrize> heh whoops :)
20:32:46 <edwardk> anyways i keep playing around with a variation on darcs-style patch-theory to commute the side-exits out from between thunk allocation and forced evaluation, in the face of conflicts it can just give up, so its got advantages.
20:32:49 <solrize> the runtime execution rules are analyzed to death in janis voigtlander's thesis
20:34:20 <edwardk> basically if you view registers as files, and instructions as patches a lot of it just seems to work.
20:34:23 <dons> this is what more mainstream exposure can produce, http://twitter.com/bensonk42/statuses/1065939050
20:34:46 <dons> (and we similar 'backlash' against, e.g. terminology, use of symbols, ... elsewhere)
20:34:51 <edwardk> dons: hah
20:35:00 <orbitz> dons: hahah
20:35:04 <solrize> lol
20:35:18 <dons> there was a similar thread about 'the single biggest thing we need to do is explain math notation'
20:35:26 <dons> so i'm not sure.
20:35:26 <solrize> haha
20:35:33 <dons> there's a meme.
20:35:38 <solrize> the problem with math notation is it presupposes the same thing ?
20:35:41 <dons> we need to be seen as more accessible somehow.
20:35:52 <dons> solrize: or that there's no 'math notation' in haskell, really.
20:35:58 <dons> why aren't people scared of perl's stuff when learning
20:36:12 <orbitz> dons: maybe instead of explaining math notation,  you shoudl explain why math notation is important, once peopel think it's important they'll want to learn it
20:36:15 <wli> What precisely is patch theory?
20:36:39 <solrize> wli it's the way darcs represents source code changes
20:36:40 <dons> well, i don't think math notation is important. i think haskell notation is important (if learning haskell)
20:36:48 <QtPlatypus> dons: With perl you could teach people a workable subset of perl without looking too scary.
20:37:14 <solrize> wli there are a bunch of rules about when you can commute two patches (i.e. what happens if you do them in reverse order)
20:37:23 <wli> solrize: SUre, but where else is it studied? What's the fundamental theorem? Is there e.g. an algebraic or category-theoretic structure describing patches?
20:37:32 <dons> QtPlatypus: so we do the same thing with Haskell 1A.
20:37:33 <QtPlatypus> Not untill you start using refreces or regexes do things get line noisy.
20:37:38 <dons> but clearly we're not good at getting that out there.
20:37:46 <dons> showing off monads before teaching say, Bool and Maybe.
20:37:56 <orbitz> maybe someoen should find a way to teach haskell IO Monad first.  i think programming culture is generally in teh way of startign with IO, perhaps that scares a lot of people away
20:38:00 <solrize> wli it's algebraic more or less
20:38:01 <edwardk> wli: patch theory basically comes down to a crap ton of rules about when patches can commute and what they commute yielding. its sort of lacking in fundamental theorems ;)
20:38:03 <orbitz> "hey i can't ask for someones name in teh first 5 minutes? no way!"
20:38:13 * orbitz is just guessing thouhg
20:38:24 <solrize> http:/en.wikibooks.org/wiki/Understanding_darcs/Patch_theory
20:38:37 <QtPlatypus> Also I think that the perl community had the benifit of a few very good authors of manuals ect.
20:39:03 <wli> solrize: Is it just an arbitrary semi-Thue system in algebra? Or is there more?
20:39:05 <solrize> haskell really is inherently harder
20:39:24 <solrize> wli i don't think it's that fancy
20:39:34 <edwardk> wli: i just thought it was interesting that it was directly applicable to moving instructions around. patches are changes in a context.
20:40:25 <dons> solrize: "inherently" ?
20:40:26 <lament> i have always been under impression that 'patch theory' was basically a cool name to be put on the darcs front page
20:40:36 <dons> than ?
20:40:37 <wli> They smell sort of like a group.
20:40:40 <orbitz> lament: eye patch theory?
20:40:41 <lament> in conjunction with 'created by a physicist'
20:41:00 <edwardk> wli: basically all it tries to answer is if given two patches (and the patches they depend on), does one depend on the other, can they be applied in either order or do they conflict?
20:41:22 <Riastradh> Patch theory distinguishes the mechanism from heuristic context-based merging.
20:41:30 <gwern> evening all
20:41:32 <Riastradh> (which is what one finds in nearly every other revision control system out there)
20:41:36 <pumpkin_> ooh a new project euler problem coming out in a few hours
20:41:36 <solrize> dons, yes i think inherently; simple everyday things that are trivial in perl or python require knowing what you're doing in haskell
20:41:37 <edwardk> wli: so its more of a partial order on patches.
20:41:40 <gwern> any news?
20:42:05 <sjanssen> dons: perhaps to battle that particular idea, we need to teach more dumb people about Haskell?
20:42:08 <solrize> the whole "awkward squad" paper is about such things
20:42:26 <blackh1> sjanssen: I managed to learn Haskell.
20:42:30 <sjanssen> dons: the comment just seems like typical anti-intellectualism
20:42:47 <dons> sjanssen: yes.
20:42:56 <dons> we'll brush up against it more as we diversify
20:42:56 <blando> or genuine frustration
20:42:59 <wli> Well, if patch theory is going somewhere it will need to have some sort of conceptual framework. It needs to have a definition of itself.
20:43:03 <orbitz> i think it's somewhat reasonable that a newbie would be confused by sometimes you do x <- foo and others you do let x = ...;  I think once you udnerstand why it's a godo distinction, but that takes effort o udnerstand why
20:43:06 <edwardk> sjanssen: i've been trying. but for some reason i can't seem to teach dumb people anything, let alone haskell ;)
20:43:24 <edwardk> wli: the framework is mostly in Roundy's head. i think igloo has made some headway in re-inventing it ;)
20:43:51 <solrize> wli i dunno that patch theory is rigorous enough to be completely pinned down, but it's implemented using GADT's in an interesting way that statically enforces some of its rules
20:44:00 <gwern> wli: well, there's always the academic patch theory, which is a lot like darcs'
20:44:39 <edwardk> wli: i'm mostly interested in abusing its ideas to get a nice set of heuristic rewrite rules to let me shove around side-exits in traces willy nilly.
20:45:03 <Gracenotes> huh, there are so many "dark corners" of Haskell: functors, arrows, monoids, monadplus, fix, continuation... it's fun to find all of 'em ;)
20:45:22 <solrize> http://perlcabal.org/~autrijus/darcs-gadt.png
20:45:25 <wli> I would say there's a semantic component of patch theory which needs some sort of definition. Patches do not merely alter program text, but also program behavior. How do you define commutation in terms of program behavior?
20:45:27 <edwardk> Gracenotes: er given that list, what is left that isn't a dark corner? =)
20:45:27 <luite> how accurate is the profiler in reporting the location of the cost centers (for example when functions are inlined)?
20:45:49 <solrize> wli, patches commute if applying A then B  to a source file results in the same output as applying B then A
20:46:14 <gwern> wli: ouch, I don't even want to think about behaivour. a haskell-syntax or refactoring aware darcs would be hard enough
20:46:21 <edwardk> wli: patch theory seems to limit its current definition to checking to see if the repository results in the same files in the same states.
20:46:21 <Gracenotes> edwardk: ...map accumulations, maybe? :)
20:46:37 <edwardk> Gracenotes: nah, map is a use of a functor ;)
20:47:10 <Gracenotes> well, I suppose those topics are large and convex to have their own little dark corners
20:47:18 <Gracenotes> +enough
20:47:43 <edwardk> solrize: actually, its weaker than that because you can commute AB to get B'A' which aren't the same as A or B.
20:47:58 <Gracenotes> concave, even. meh.
20:47:58 <gwern> @seen ndm
20:47:59 <lambdabot> I haven't seen ndm.
20:48:07 <solrize> ok
20:48:23 <solrize> there is a set of slides from a droundy talk somewhere that explains it pretty well, but is hard to find
20:48:27 <wli> solrize: I'm obviously going deeper. For instance, one patch changes a data structure from a sorted list into a priority queue. The second adds additional information to the structure possessing the priority key. It's relatively clear how such patches are commuted to humans. How do you elaborate patch theory so it can accomplish the same?
20:48:41 <edwardk> actually lispy had a blog entry explaining the commuting parts
20:48:47 * gwern feels disgruntled. darn it ndm get back to me on hoogle, or commit that patch fixing the main.txts
20:48:58 <solrize> wli i don't think patch theory (as in darcs) makes any attempt at that.  it operates at the level of source files, i.e. strings
20:49:05 <solrize> where equality is easy to test
20:49:23 <gwern> I thought it wasn't even strings, but newlines
20:49:38 <edwardk> wli: that is a larger extension of patch theory to the semantics of programs, right now it focuses on yielding programs that are textually equivalent, as its used in a version control system that lacks that sort of knowledge
20:50:08 <solrize> wli: http://www.science.oregonstate.edu/~roundyd/talks/cs_colloquiem.pdf
20:50:11 <wli> Okay, then go to strings.
20:50:16 <edwardk> wli: an interesting and related idea would be to bake the type checker into it somehow and have it enable commuting of patches that transformed code into code that was consistently typed or had the same meaning, etc. ;)
20:50:46 <edwardk> wli: but that goes off into la-la land fast.
20:50:52 <gwern> nobody would like that. same reason we don't use structured text editors
20:51:14 <sjanssen> edwardk: we really want to make darcs slower? :P
20:51:16 <wli> gwern: But people do use structure editors, at least in the Microsoft context.
20:51:39 <edwardk> my cheesy instruction-based patch theory is kinda that general idea, but since its a lot less concerned with merging patches and it can throw up its hands on any conflicts, it only has to solve a much much easier problem than darcs does.
20:51:49 <ddarius> dons: http://lambda-the-ultimate.org/node/1235#comment-13624
20:51:54 <gwern> wli: microsoft? microsoft? I'm gonna pretend I didn't hear that
20:52:05 <edwardk> i mostly have just been raiding them for notation and terminology ;)
20:52:58 <edwardk> wli: the problem is that no one has been able to come up with a general purpose semantic source control tool, partially because every file format would require custom merge rules, etc.
20:53:55 <edwardk> wli: you can't just abuse the raw grammar, since its not enough to reflect semantics, and convention-oriented information.
20:54:08 <edwardk> after all some patches are just formatting changes and formatting matters to some people.
20:55:01 <wli> edwardk: e.g. it gets nasty in/around FFI affairs where one reimplements something originally in one language in another? e.g. hand-coding asm for a C function or translating an asm function into C?
20:56:06 <edwardk> wli: or even the fact that this is used in a source control system. i don't know the full runtime environment, i don't know all the languages of code used in the repository, what if someone checks in a perl file, what if it doesn't compile and is a checkin just to get a broken starting point diseminated, etc.
20:56:30 <wli> (Or worse yet, umpteen versions of the asm are required, one for each of a number of CPU architectures, each making essential use of data layouts that are both program-specific and architecture-specific.)
20:57:21 <dons> ddarius: yes.
20:57:32 <dons> it is safer for incompetent people to be working in haskell, than C++.
20:57:33 <edwardk> wli: is a using Foo (bar,baz) declaration the same as using Foo (baz,bar) -- depends on if someone was updating haddock and wanted a different order to some comment bullet points...
20:57:46 <edwardk> dons: agreed!
20:58:19 <edwardk> @quote dons it is safer for incompetent people to be working in Haskell than C++
20:58:20 <lambdabot> No quotes match. Where did you learn to type?
20:58:21 <jeffz`> Haskell breeds competence
20:58:22 <edwardk> er
20:58:33 <wli> edwardk: i.e. the formatting difference alters program behavior as the program is interpreted by haddock?
20:58:36 <edwardk> @remember dons it is safer for incompetent people to be working in Haskell than C++
20:58:36 <lambdabot> Good to know.
20:58:48 <Axman6> dons: i believe that imcompetent people should be left to only program non-importany things like drivers and kernel extensions, so C++ would be a good fit
20:58:52 <Axman6> >_>
20:59:05 <edwardk> wli: but the compiler doesn't care, so the tool set matters.
20:59:19 <Axman6> important*
20:59:28 <edwardk> wli: while haddock will name sections if you put them in comments inside the ()'s there
20:59:38 <British0zzy> why is haskell harder to optimize compared to C?
20:59:54 <Elly> hm?
20:59:55 <pumpkin_> it shouldn't be
20:59:57 <Elly> it's not
20:59:58 <Axman6> is it harder?
21:00:04 <Elly> the compiler has way more information to work with in haskell
21:00:07 <wli> edwardk: One can say that a program is simultaneously interpreted by several different interpreters and the semantics are the Cartesian product of the semantics as interpreted by each of the pertinent interpreters.
21:00:15 <Elly> C compilers have many, many hours put into making them fast though
21:00:16 <edwardk> British0zzy: because it tries to be more careful about not doing work that you don't need to get the answer to the questions you ask it.
21:00:21 <Elly> or rather making them spit out fast code
21:00:32 <Elly> and C fits the underlying machine model reasonably closely
21:00:33 <British0zzy> well, are C compilers just more mature?
21:00:45 <dons> British0zzy: i'm not sure it is harder, the compiler actually knows more about the code, so it can be more aggressive.
21:00:45 <Cale> British0zzy: That would be the main reason.
21:00:54 <edwardk> wli: sure, but a new interpreter would invalidate whole repositories and it still doesn't fix the 'broken checkin' problem
21:00:57 <wli> edwardk: The more painful problems are elsewhere IMHO.
21:00:58 <Elly> I think it's the machine-model thing, personally :P
21:01:07 <dons> who said C was 'easy' to optimise?
21:01:11 <solrize> britishozzy, haskell has more complicated semantics (non-strictness)
21:01:16 <wli> edwardk: What's the "broken checkin" problem?
21:01:18 <dons> you have to do lots of crazy analyses in a C compiler.
21:01:20 <Elly> I have worked on an optimizing C compiler
21:01:24 <Elly> and alias analysis *sucks*
21:01:50 <dons> solrize: non-strictness is less complicated than 'can do arbitrary effects'
21:01:52 <Elly> mostly because nobody anywhere thinks the C strict aliasing rules are important
21:01:54 <edwardk> wli: when you want to checkin a document that isn't a valid program, because you want someone else to see it or you want to preserve it for later.
21:02:06 <edwardk> wli: if it can't pass your parser at all, then what?
21:02:36 <wli> edwardk: This being a problem with structure editors generally?
21:02:50 <solrize> dons i think c compilers aren't required to account for arbitrary effects.  if a berserk c program trashes its own code space, the compiler isn't required to make any predictions :P
21:03:07 <Elly> British0zzy: also, if you are curious: http://c2.com/cgi/wiki?AsFastAsCee
21:03:21 <dons> solrize: but to do the optimisations , you have to work out what the code does
21:03:22 <dons> that's hard
21:03:35 <wli> edwardk: This one isn't so bad. Chop up the program into sections considered to be composed, e.g. one function at a time.
21:03:39 <dons> so either a) you be less aggressive   (since C is harder to optimise) or b) you do more work in the compiler
21:03:55 <Taejo> solrize, dons: if the program writes to pointers that weren't allocated to it, it's nose-demon time, and the compiler can do as it pleases
21:04:09 <British0zzy> it seems like llvm is almost as fast as gcc
21:04:22 <Elly> Taejo: are you familiar with the "as-if rule" from the C spec?
21:04:29 <Elly> (well, really from the justification for the C spec)
21:04:36 <British0zzy> are the optimizations llvm does on C unusable in a haskell code
21:04:49 <edwardk> wli: yeah, i buy the whole structure editing thing, but i don't buy storing patches in a repository in a file-meaning specific fashion is anywhere near robust or anywhere near a solved problem.
21:04:54 <dons> British0zzy: they're likely useful on the c code haskell compilers produce
21:04:55 <Elly> British0zzy: LLVM takes as input a form of relatively low-level bytecode
21:04:56 <Cale> I think the results from the reduceron say something about the machine model bit.
21:04:57 <wli> edwardk: Isolate sections not passing preparatory phases of execution (e.g. parsing, translation into native code, etc.)
21:05:08 <Elly> British0zzy: at that point the code generated by a C compiler and a haskell compiler are not distinct really
21:05:09 <dons> British0zzy: but you've got to get haskell down to a simple imperative language first
21:05:10 <edwardk> wli: not that you were actually saying that it was ;)
21:05:16 <Cale> (it would be nice to have a rather different architecture for running Haskell code)
21:05:47 <wli> edwardk: The thrust of my argument is that it's more worthwhile than pushing the envelope of string editing.
21:05:52 <Elly> Taejo: basically, large chunks of the C spec are defined such that it's okay if the situation looks (to the running program) "as if" the compiler was following the spec
21:05:54 <dons> are nice teaching people on the rwh bookclub list? http://groups.google.com/group/real-world-haskell-book-club
21:05:59 <Elly> and since the C machine model is single-threaded, ...
21:05:59 <dons> lots of beginner questions to help with
21:06:22 <gwern> Cale: you mean it would be nice to have an architecture more suited for haskell with as much investment and development of as x86? :)
21:06:23 <edwardk> wli: heh. well i'm happy to let others use it to edit strings, i just want to swap around opcodes and it provides a vocabulary and notation ;)
21:06:24 <ddarius> dons: Are you not on it?
21:06:27 <Elly> oh, I should try building Timber again
21:06:30 <Elly> with ghc 6.10 now :)
21:06:38 <dons> ddarius: i am.
21:06:47 <Taejo> Elly: can you give an example?
21:06:51 <ddarius> dons: So don't you know?
21:06:59 <Elly> Taejo: sure. You know what 'volatile' means, right?
21:07:01 <dons> ddarius: know what?
21:07:03 <Cale> gwern: There's evidence that even with significantly less investment, we could run Haskell programs a lot faster.
21:07:04 <dons> who's on it?
21:07:08 <Elly> Taejo: and why you use it?
21:07:13 <wli> edwardk: What you're describing with opcodes sounds as if it has much in common with what I describe for structure editing.
21:07:15 <ddarius> dons: If there are nice teaching people on the list.
21:07:18 <dons> there's 200 people. i've not looked at the names.
21:07:20 <Taejo> yes. memory-mapped IO and stuff
21:07:20 * ozy` throws this out there: http://llvm.org/docs/CodeGenerator.html#tailcallopt
21:07:29 <ddarius> dons: Have you noticed people being nice and teachy?
21:07:37 <dons> ddarius: i'll rephrase: if you like teaching haskell, please join, i'm sure it will be useful.
21:07:38 <gwern> Cale: well, I'm just warning against idealizing the lisp machine experience a little much. commodity arch is very very hard to beat
21:07:43 <dons> ddarius: i have.
21:07:48 <edwardk> wli: in some sense, but i have very simple structures, and no human has to read the result of my 'refactoring' ;)
21:08:01 <Elly> Taejo: right. If you omit volatile, the compiler is allowed to remove reads and writes to variables
21:08:18 <Elly> Taejo: as long as it determines that you cannot possibly tell the difference - under the idealized C machine model (i.e., the single-threaded one)
21:09:22 <wli> gwern: The Lisp machine experience seems to have varied amongst its users. I was in line to get one of a lab full of Lisp machines when the employees actually required to use them destroyed them with baseball bats to vent their frustration, thwarting the admin's attempt to take home the scrapped machines and sell them off.
21:09:25 <Elly> Taejo: however, volatile just says that you have to emit a read for each logical read, where 'read' is implementation-defined :P
21:09:49 <gwern> wli: which lisp machiens were those? surely not symbolics'. TI's perhaps?
21:10:05 <Elly> hmmmm
21:10:05 <gwern> I've not seen many favorable remiscencies of their dolphin or whatever
21:10:19 <solrize> wli somebody recently wrote an emulator for lisp machines
21:10:20 <Elly> I just asked cabal to install all three of the deps timber wants, and it still complains that all three are missing
21:10:21 <dons> ddarius: my concern is that with 200 people we'll need a decent teacher / student ratio
21:10:22 <Taejo> Elly: I see. So if it knows the address is not memory-mapped IO (because you just malloc'ed it), it can ignore the volatile?
21:10:43 <Elly> Taejo: no; the C compiler (shouldn't) care about whether a pointer was malloced or not
21:10:55 <wli> gwern: They were Symbolics machines. The whole email thread is on a computer of mine that is in need of recovery from a physical catastrophe.
21:11:05 <Elly> to give you a more concrete example: int foo = 1; void bar() { while (foo) { } }
21:11:13 <Elly> on -O3, gcc will optimize that loop into while (1) happily
21:11:58 <wli> Elly: Presumably not if foo escapes e.g. via passing &foo to an external function.
21:11:59 <gwern> wli: how peculiar. and what a waste. there were never very many symbolics machines
21:12:08 <Elly> wli: in that case, foo is a global
21:12:16 <Elly> wli: so it has already escaped
21:12:21 <gwern> I think the grand total I found as a references was <5000 symbolics lisp machines of any kind
21:12:30 <Elly> wli: as far as gcc is concerned, though, you are the only thread, and you don't write it, so that optimization is safe
21:12:35 <pumpkin_> is there a good function that does efficient modular exponentiation of Integers in haskell?
21:12:52 <edwardk> c's semantics terrify me. its sad that c++0x is the first set of multi-thread semantics for a c derivative that i can actually believe you can write safe multi-threaded code under. ;)
21:13:03 <edwardk> thank you, hans boehm
21:13:17 <Elly> HP Research published a great paper a while ago with a convincing argument that you just can't safely bolt threads onto the side of C
21:13:23 <edwardk> yeah
21:13:31 <Elly> hmmmm
21:13:51 <Elly> dev-haskell/mtl-1.1.0.2 doesn't build...
21:13:54 <edwardk> that was boehm
21:14:12 <edwardk> fortunately he was also the steady hand behind the c++0x model.
21:14:15 <wli> Elly: C semantics do have holes, but this one isn't terribly ambiguous. What you say about it being global does cause it to escape.
21:14:21 <dons> Elly: ?
21:14:30 <Elly> wli: I will write an example program; one moment
21:14:32 <edwardk> which i am less unhappy about than any other multithreading model out there, which i guess is saying something.
21:14:40 <dons> pumpkin_: mm. gmp provides such things.
21:14:55 <edwardk> the ghc approach for instance relies a LOT on x86 semantics to avoid having its writes reordered =(
21:15:07 <solrize> does the haskell lib export gmp's modexp routine?
21:15:09 <wli> Elly: I changed my mind and now agree with you.
21:15:15 <dons> solrize: sadly, i don't think it does.
21:15:24 <pumpkin_> boo :)
21:15:24 <Elly> wli: okay
21:15:24 <dons> i think we should modify the integer lib to export everything
21:15:26 <pumpkin_> it's so handy
21:15:38 <dons> pumpkin_: there's a number of math libs (efficient and otherwise)
21:15:42 <pumpkin_> naive modular exponentiation really isn't practical
21:15:45 <dons> and there's normal integer base lib math
21:15:51 <pumpkin_> mmkay, I'll look around on hackage
21:15:54 <Elly> if you compile the following oneliner with gcc -O3, you will get the code I mentioned: int foo = 1; int main() { while (foo) { } return 0; }
21:15:55 <solrize> dons, gmp's modexp is very well optimized and it would be handy to have access to it.  it's a lot better than a naive divide and conquer in the client code
21:16:17 <Elly> dons: whenever I try to install a package from the haskell overlay, this occurs:
21:16:19 <wli> edwardk: Well, the x86 semantics are a particular kind. More stringent semantics translate back to x86 with either less general memory barriers or memory barriers omitted.
21:16:21 <Elly> Warning: The documentation for the following packages are not installed. No
21:16:22 <solrize> naive is practical, it's just that one can do better
21:16:24 <Elly> links will be generated to these packages: rts-1.0
21:16:26 <Elly> haddock: Prelude.Enum.Bool.toEnum: bad argument
21:16:46 <Elly> possibly because I still have the haddock from portage instead of the haskell overlay
21:16:59 <gwern> why does your install fail if haddock fails?
21:17:02 <Elly> no idea
21:17:06 <gwern> it's not like haddock is a very reliable tool
21:17:07 <Elly> probably USE=doc :P
21:17:09 <pumpkin_> solrize: when you have 10-digit exponents?
21:17:13 <solrize> pumpkin_, http://hpaste.org/13179
21:17:21 <solrize> pumpkin_ yeah, 10 digits is no prob
21:17:24 <edwardk> wli: well, what i mean is that ghc relies on writes to be visible to other processors in order of occurence for the correctness of greyholing and its general multithreading model
21:17:30 <pumpkin_> oh, by naive I meant ^ `mod`
21:17:31 <pumpkin_> :)
21:17:41 <solrize> usually modexp is optimized for 100's of digits (public key cryptography)
21:17:49 <pumpkin_> yup
21:18:21 <wli> edwardk: Yeah. I think it sucks and should be done almost the diametric opposite way.
21:18:30 <afabian> I was reading a haskell tutorial and using Hugs.  It gives an example like map toUpper "hello".  So far, I've tried +98 and -98 with both Char.toUpper and toUpper; no dice.  What do I need to do?
21:18:40 <edwardk> wli: unfortunately on platforms with looser memory models, i.e. ia64, the whole approach taken by ghc is flawed, plus gcc isn't guaranteed to respect the memory model ghc is expecting it to support and would be well within its rights to reorder writes as long as it could be proven to not affect a single-thread's view of the world
21:19:06 <Elly> edwardk: that's the best part of C as a target language!
21:19:12 <Elly> edwardk: you never know what semantics it has ;)
21:19:20 <ddarius> @hoogle toUpper
21:19:20 <lambdabot> Data.Char toUpper :: Char -> Char
21:19:39 <solrize> i thought reordering is not allowed if you use volatile
21:19:47 <Elly> solrize: it depends how you read the spec
21:19:58 <Elly> solrize: 'volatile' should mean 'don't reorder reads/writes to this over sequence points'
21:20:03 <edwardk> elly: heh. C. all things to all semantics... except for the set of semantics you want it to have at the time.
21:20:03 <sjanssen> afabian: you need to load the Data.Char module
21:20:05 <Elly> solrize: but 'reads/writes' there is implementation-defined
21:20:09 <ddarius> afabian: From a file, you need to import Char or (preferably) Data.Char.  From the REPL, I think you do :l Data.Char
21:20:14 <ddarius> (or Char should also work)
21:20:23 <sjanssen> afabian: I think the syntax for that in hugs is ":also Data.Char"
21:20:26 <Elly> solrize: and in particular, it can mean "I don't see any other writes, so I'll optimize that"
21:20:27 <solrize> :m Data.Char in ghci, not sure about hugs
21:20:27 <afabian> Ah, I see.  Thanks, guys.
21:20:37 <wli> edwardk: Back to patch theory and structure editing, do you think it'd be plausible to create a language sufficiently stripped-down as to be able to have broad classes of the structure editing affairs I describe implemented?
21:20:43 <Elly> solrize: (it doesn't, for any modern compiler, because volatile behaves 'how people want', but still)
21:20:50 <solrize> afabian maybe you should switch to ghci, hugs is not used much any more
21:20:52 <ddarius> afabian: I'd recommend using GHC
21:21:10 <solrize> elly yeah, one could say the same of haskell though
21:21:14 <edwardk> but locations are very nebulously defined, bitfields mess with you something fierce because how many locations are they? what about atomic swaps, etc.
21:21:45 <afabian> Hmm.  Okay, I'll switch.  Thanks for that suggestion, too.
21:21:51 <Elly> edwardk: the only thing to say is: "Ha! Ha! You're compiling for a modern computer!"
21:21:52 <wli> volatile does very little that's useful.
21:21:55 <solrize> C should just be banned
21:22:07 <Elly> solrize: it's...kind of important
21:22:19 <Elly> solrize: nobody afaik has made an OS work without at least some C and/or assembly
21:22:19 <solrize> elly that just adds urgency to getting rid of it
21:22:29 <MyCatVerbs> solrize: no. C is beautiful. Just... sharp. ^^
21:22:30 <Elly> heh, that's a good way to look at it
21:22:38 <wli> solrize: IMHO C needs to be cleaned up in a backwards-incompatible way.
21:22:43 <Elly> "sharp" is an understatement
21:22:48 <edwardk> elly: i spend a fair chunk of time arguing with people who believe they've invented new lock-free algorithms or structures to show the holes caused by these very pedantic seeming issues. its sad really.
21:23:07 <Elly> edwardk: I spend a fair chunk of time finding students who have made exactly these mistakes :)
21:23:14 <Elly> (the 'global foo' example from above is from student code)
21:23:36 <wli> Some analogue of C is needed, but there's a lot of crap to be cleaned up.
21:23:44 <Elly> BitC is a step the right way
21:23:57 <edwardk> bitc makes me kinda queasy
21:24:06 <solrize> bitc doesn't have much resemblance to c
21:24:08 <solrize> there's cyclone
21:24:19 <Elly> I wrote a file system in cyclone :(
21:24:27 <edwardk> cyclone makes me more than kinda queasy ;)
21:24:33 <solrize> a couple of my officemates used to do embedded stuff in ada, so i got interested in that for a little while, but it's way ugly
21:24:48 <wli> I've no idea about the details of BitC. Cyclone seems promising in a number of respects, though I think it oversteps a number of lines.
21:24:49 <Elly> I want a typesafe assembly language
21:24:49 <rastajames>  /join #winehq-social
21:24:53 <solrize> ats looks kind of interesting
21:24:53 <rastajames> eh
21:24:56 <Elly> there appears to be some research on it
21:25:01 <ozy`> BitC still doesn't have its syntax ready, does it?
21:25:05 <ddarius> Elly: There is more than one now.
21:25:10 <edwardk> elly: tal exists
21:25:12 <ozy`> the semantics are mostly finished though
21:25:17 <Elly> edwardk: does it work?
21:25:27 <edwardk> elly: yeah at last check.
21:25:32 <MyCatVerbs> ozy`: syntax? Feh, who gives a monkey's left nut about that? =)
21:25:35 <Elly> intriguing
21:25:41 <wli> solrize: Ada may very well have enough of C already cleaned up to be the right thing to do.
21:25:49 <MyCatVerbs> ozy`: semantics are, on the other hand, important!
21:25:51 <edwardk> elly: chlipala (smerdyakov) built some neat stuff on it iirc.
21:26:00 <Elly> edwardk: oh?
21:26:06 <ozy`> wli: doesn't Ada have a huge runtime?
21:26:07 <edwardk> er though he was mostly doing proof carrying code stuff
21:26:11 <Elly> wow, happy spits out a LOT of warnings
21:26:19 <Elly> (when being compiled)
21:26:25 <solrize> apparently ada has some really horrible stuff but if you leave those out what's left is ok.  i got a book about spark ada, which is ada with the nasty stuff removed
21:26:30 <wli> ozy`: AIUI the large runtime features are optional.
21:26:38 <solrize> but the result is very constricting and painful
21:26:41 <wli> ozy`: e.g. GC
21:26:43 <MyCatVerbs> wli: aside from being huge and not so good at data structures and mandating a somewhat crazy multitasking runtime
21:26:53 <ozy`> wli: that's what they said about C++....
21:27:22 <wli> MyCatVerbs: I've few doubts it's possible to best Ada at its own game.
21:27:37 <solrize> what about modula-3?
21:28:18 <gwern> > 655 - 14
21:28:19 <lambdabot>   641
21:28:21 <wli> solrize: My impression of Modula-3 is that it has runtime issues precluding it from acting as a C equivalent.
21:28:42 <gwern> > 655 / 14
21:28:44 <lambdabot>   46.785714285714285
21:28:46 <MyCatVerbs> wli: personally, I think I'd take Algol 60. ;)
21:28:49 <edwardk> solrize: is it pathetic that i can't bring myself to use any programming language with the keywords specified in all upper case? ;)
21:28:53 <MyCatVerbs> wli: or a minor upgrade thereof.
21:28:55 <gwern> > (655 / 14) * 100
21:28:56 <lambdabot>   4678.571428571428
21:29:10 <solrize> edwardk what lang does that?  ada?
21:29:13 <Taejo> edwardk: COBOL?
21:29:33 <wli> MyCatVerbs: I think more recent developments in language theory have a great deal that could be applied to C.
21:29:58 <Elly> proper types would be good
21:30:23 <wli> MyCatVerbs: For one, I personally would spooge given C with an ML-style module system for use in the kernel. ;)
21:30:28 <Elly> argh, the timber website sucks
21:30:38 <gwern> > (655 / 12) * 100
21:30:39 <lambdabot>   5458.333333333334
21:30:40 <MyCatVerbs> wli: er riiiight, at which point you notice you've reimplemented BitC. I think. =)
21:30:48 <edwardk> solrize: er.. modula 3, common lisp, cobol, fortran, ...
21:30:50 <solrize> ML-style modules without ML's type system ?
21:30:52 <sutats> Could there be improvements on the hardware level so that Haskell would work better for systems programming?
21:30:58 <MyCatVerbs> wli: the problem might already be solved? =)
21:31:05 <BMeph> Wait - what /is/ Ada's game? :)
21:31:11 <solrize> edwark common lisp is explicitly case insensitive
21:31:12 <Elly> BMeph: the DOD
21:31:17 <Elly> BMeph: the DOD is Ada's game :P
21:31:17 <MyCatVerbs> BMeph: microcontrollers in missiles and aircraft.
21:31:28 <edwardk> solrize: heh thats my module system for kata. no types makes all the corner cases of the module system go away ;)
21:31:30 <wli> MyCatVerbs: Where is it? I'll take a look at start poking holes.
21:31:36 <MyCatVerbs> sutats: probably not really.
21:31:46 <edwardk> solrize: i'm aware. but alas, what do people write all the reference docs using?
21:31:51 <Taejo> Elly: CL is not *quite* case insensitive
21:31:55 <MyCatVerbs> wli: http://www.bitc-lang.org/
21:32:01 <Elly> Taejo: hm?
21:32:16 <Taejo> Elly: it's fairly complicated, I'll see if I can find the spec
21:32:17 * BMeph tnts edwardk it fsh copy of...FORTRAN 99!>;)
21:32:37 <gwern> > (655 / 11) * 100
21:32:38 <lambdabot>   5954.545454545455
21:32:45 <solrize> edwardk i don't remember cltl2 using upper case but it's been a while
21:32:56 * BMeph checks his wireless keyboard's batteries...
21:33:14 <wli> MyCatVerbs: BitC seems to trip over runtime requirements that would make it awkward in kernel contexts.
21:33:34 <edwardk> solrize: its just a cultural thing, i never feel like schemers are shouting at me ;)
21:33:43 <MyCatVerbs> wli: I think anything that wants an ML-style type system is going to.
21:33:49 <BMeph> MyCatVerbs: Hmm, I'll have to talk to my missile tech friend. :)
21:34:15 <Elly> Taejo: I mean, why are you telling me?
21:34:47 <Taejo> Elly: it seems like I was thinking of filenames, but the CL reader converts lowercase letters to uppercase in symbols, but you can have lowercase letters by escaping: so it's case sensitive, but things get converted to uppercase automatically
21:35:00 <wli> MyCatVerbs: Higher-order functions with lexical scope is what does it. I'd leave it all first-order and monomorphic, but with some type parametrization at the module level.
21:35:00 <Taejo> oops
21:35:17 <Taejo> that all was meant for Solrize, I guess
21:35:29 <MyCatVerbs> BMeph: the DoD a while back decided that there were too many languages in use in military projects, so they made up a set of requirements for a new language to replace them all, took a bunch of suggestions in a competition (vaguely similar-ish to how the AES competition went, I think) and then picked Ada and worked on it.
21:35:50 <gwern> > (365 * (6.55 - 0.11))
21:35:51 <lambdabot>   2350.6
21:36:00 <edwardk> ada isn't terrible
21:36:11 <MyCatVerbs> wli: how do you generate microcode for a function of type [a] -> [a] without having some way of representing forall a. a?
21:36:30 <solrize> ada really seems like a 1980's language though, i think it would come out a lot different if done today
21:36:52 <BMeph> MyCatVerbs: Well, yes, I know the history of how Ada, AKA STEELMAN was created. I also know that they had a long period before they actually made a spec-obeying compiler for the thing.
21:37:36 <MyCatVerbs> wli: so you need a way of representing forall a. a. Naturally you turn to pointers. And then you decide that for some reason you really really don't want to dereference a bunch of pointers for some odd reason.
21:37:39 <wli> MyCatVerbs: The type t in [t] -> [t] in the scheme I describe would be a module parameter required to be passed, and worse yet, there could never really be such a type constructor as [ ].
21:37:40 <solrize> mycatverbs that sounds like ada generics
21:38:00 <MyCatVerbs> wli: I bet writing an optimizer for getting rid of that indirection would be *really* fun. =)
21:38:33 <wli> MyCatVerbs: At best one could create a list module parametrized by the type of the list contents.
21:38:53 <Taejo> AFAIR, in CL on Unix, all filenames are written case-inverted
21:39:00 <MyCatVerbs> BMeph: but yeah. Ada has concurrency built into the spec, as well as things like restricted range integers.
21:39:26 <Elly> restricted range integers at least are easyish to compile
21:39:36 <Elly> but very, very slow, I should think
21:39:37 <MyCatVerbs> BMeph: aaaand I presume they would've produced a formally specified semantics. But I don't know for sure.
21:39:57 <edwardk> case insensitivity makes me cry. be sensitive
21:40:08 <solrize> elly, at least in spark ada, you have to statically check that the restricted range integers don't overflow, and that's not so easy
21:40:18 <Elly> ah, I can see that not being easy
21:40:28 <MyCatVerbs> Elly: but if you can prove that they don't overflow statically then you can omit checks.
21:40:29 <Elly> but checking dynamically is easy :P
21:40:32 <Elly> yep
21:40:35 <MyCatVerbs> Elly: no it isn't. =)
21:40:42 <solrize> but, i've had the view that runtime checking should be pretty fast, because of branch prediction
21:40:45 <Elly> why is that not easy?
21:40:49 <MyCatVerbs> Elly: because in many cases you're not allowed to ever throw a range exception. =)
21:40:55 <Elly> you just emit a test, then a jump-to-we're-fucked
21:41:00 <MyCatVerbs> ...
21:41:03 <Elly> in that case you might have trouble :P
21:41:08 * MyCatVerbs thwaps Elly with a newspaper.
21:41:09 <solrize> especially for checking for machine int overflow, i.e. just a jump on the cpu overflow flag
21:41:14 <Elly> but if you can throw exceptions you're good
21:41:16 <wli> MyCatVerbs: IOW the whole thing is designed around the severe constraints of the kernel runtime environment.
21:41:35 <gwern> > 0.11 / 6.55
21:41:36 <lambdabot>   1.6793893129770993e-2
21:41:44 <wli> MyCatVerbs: And very deliberately so, because I want it for kernel programming. ;)
21:41:51 <MyCatVerbs> Elly: where, exactly, is the "we're fucked" handler that you're going to jump to when an error occurs in the software controlling your aeroplane's automatic stabilization?
21:42:06 <gwern> > 0.11 * 6.55
21:42:07 <lambdabot>   0.7205
21:42:23 <Elly> MyCatVerbs: printf("You should start writing your last will and testament nowish.\n");
21:42:29 * solrize buys gwern a calculator
21:42:30 <MyCatVerbs> Elly: generally, it tends to be embedded in the deck. Along with your project, your company, and the poor bastards who volunteered to be your test pilots. :)
21:42:46 <MyCatVerbs> wli: IOW?
21:42:59 <wli> MyCatVerbs: In Other Words
21:43:07 <gwern> > 365 / 2
21:43:09 <lambdabot>   182.5
21:44:33 <MyCatVerbs> wli: ah. Context: in other words, *which* whole thing is designed around the constraints of a kernel's runtime environment?
21:45:01 <wli> MyCatVerbs: My notion of how C should be cleaned up.
21:45:39 <MyCatVerbs> wli: I'm not sure how you're going to manage to stuff ML features into it, then. ;)
21:46:03 <solrize> wli have you looked at ATS?
21:46:10 <wli> MyCatVerbs: Module systems have little or no runtime impact.
21:46:37 <wli> solrize: I checked out the site for it a couple of days ago. It didn't seem to even be related to low-level programming at all.
21:46:54 <solrize> hmm
21:47:41 <edwardk> i'm actually fairly comfortable with the c++0x semantics, even if i'm not happy about having to litter code with atomic<>s and have some publish-across atomic boundary issues that aren't addressed by current implementations of the proposed atomic<> api.
21:47:57 <wli> MyCatVerbs: One could easily envision C with static/extern, namespaces (C99?), globals, etc. replaced with an ML-style higher-order module system.
21:48:06 <Elly> I wish them good luck providing reliable atomic semantics across platforms
21:48:33 <wli> MyCatVerbs: And that with no modification of the monomorphic, first-order, etc. properties of the language.
21:48:55 <edwardk> well, the set they have appears to be portably implementable. however, it is consequently something you need a thorough understanding of almost all platforms to be able to use reliably. ;)
21:49:02 <MyCatVerbs> wli: I'll have to look into ML's module system at some point.
21:50:00 <wli> MyCatVerbs: It rocks my world. I cry when reminded of how castrated Haskell's module system is relative to it.
21:50:22 <edwardk> wli: or worse f#. then you don't even have typeclasses to fall back on
21:50:50 <edwardk> at least in haskell i know that several hours of refactoring later i can make my basic changes and get on with my life ;)
21:51:26 <MyCatVerbs> edwardk: how can F# not have first class modules? It's supposed to be a port of OCaML.
21:51:48 <solrize> it's not a port, it re-uses parts of ocaml but it's a .net language
21:51:55 <solrize> sort of an ocaml-c# hybrid
21:52:02 <solrize> ndm blogged about it
21:52:24 <solrize> http://www.reddit.com/r/programming/comments/7hymd/f_from_a_haskell_perspective/.mobile
21:52:56 <edwardk> f# doesn't support ml functors, it is ocaml-like, but not a port. don syme doesn't believe in modules. f# modules are basically .NET namespaces
21:53:07 <MyCatVerbs> solrize: OCaML's semantics with C#'s libraries was the impression I got at first.
21:53:18 <MyCatVerbs> Ah, oh. Wow, bummer.
21:54:08 <edwardk> i had hoped to port a basic category-extras-like library to f#. i couldn't even get started between that and some other major gaps in the language.
21:56:11 <wli> edwardk: I'd sort of go the other direction entirely. Modules and typeclasses with a first-order, monomorphic (albeit parametrizable at the module level) imperative language within-module language.
21:57:16 <MyCatVerbs> wli: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.1932 <- with respect to typeclasses, seen this? =)
21:57:45 <wli> edwardk: Basically leverage things with no runtime impact to help kernel-level C (i.e. near-zero runtime) along.
21:57:48 <edwardk> wli: my toy has parameterized modules and an open sea of constructors, but no types/typeclasses
21:58:01 <edwardk> wli: but it has very different goals from you
21:58:19 <edwardk> er.. technically it has a very limited notion of types
21:59:12 <wli> MyCatVerbs: Probably not.
21:59:43 <MyCatVerbs> wli: thought maybe you'd find it interesting.
22:00:58 <edwardk> what i'm trying to do now is tie optimization rules to names in namespaces, and allow definition of a more defined name to cascade down to looser defined namespaces, but it so far has come across as fairly pedantic to do so
22:02:03 <wli> MyCatVerbs: Sadly, my ability to act on what I'd like to see done is severely constrained by technical activities for pay consuming time, severe limits on my actual know-how and compiler-hacking abilities, and further time constraints from nontechnical activities.
22:02:20 <edwardk> so, sat, (+) from the semigroup namespace would permit the use of the associativity rule in rewriting, but importing the (+) from the magma namespace would not, but defining a semigroup (+) would allow you to use the magma (+) operation, etc.
22:02:58 <wli> MyCatVerbs: I'll consider myself lucky to keep the "Fastest Fibonacci in the West" title for any significant period of time.
22:03:49 <MyCatVerbs> wli: muoh. I don't think that paper would be really relevant to what you're after anyway. It's just that it's interestingly different from how Haskell does it, but keeping many of the same advantages.
22:05:31 <wli> MyCatVerbs: I have a vague idea that typeclasses would get very strange very quickly when married to modules, particularly when polymorphism is inextricably wedded to the module system as I propose.
22:06:05 <edwardk> wli: there were a set of papers a while back showing that they are interconvertable for the most part
22:06:15 <edwardk> er there was
22:06:58 <MyCatVerbs> wli: can't you pretty much do without typeclasses if you have a really good first-class module system anyway?
22:07:08 <wli> edwardk: The burning question here is how to get them to interoperate, since from a programmer's POV that sort of equivalence is little better than the equivalence between Haskell and C.
22:07:55 <wli> MyCatVerbs: It's possible to do without both of them, but why would you want to?
22:08:27 <MyCatVerbs> wli: implicit in that was "and not really feel any significant pain as a result". ;P
22:09:13 <MyCatVerbs> wli: obviously you can in theory make do with anything that gives you some form of unbounded looping and conditionals. ;P
22:09:47 <edwardk> wli: i was actually trying to do both without parameterized modules and without typeclasses for a while until i realized that with open functions that could be extended post hoc, i still couldn't handle an equivalent for class Eq since the argument only occurs negatively, my view approach didn't have anything to grab onto, so i wound up having to add modules
22:09:48 <mxc> at some level, you can make a turing complete machine out of nothing but time and  NAND gates
22:10:05 <wli> MyCatVerbs: I have substantial doubts regarding the painlessness of carrying out that program transformation by hand, particularly since I've so frequently wanted higher-order modules in Haskell, and often yearn for the fully functorial style.
22:10:37 <wli> mxc: Not quite. Only FSM's are possible from NAND gates. The unbounded tape is the missing piece.
22:10:46 <solrize> wli, edwardk, have you been looking at the recent stuff in sjanssen's blog?
22:10:57 <wli> solrize: I don't even know where sjanssen's blog is.
22:11:00 <edwardk> solrize: not sure that i have
22:11:06 <sjanssen> solrize: I have a blog?
22:11:07 <edwardk> solrize: not sure i've ever seen it
22:11:15 <sjanssen> (answer: no, I don't)
22:11:21 <solrize> oh wait, hmm, who am i thinking of
22:11:24 <mxc> wli true, mispoke, was referring to the computation side, not the tape
22:11:46 <MyCatVerbs> wli: oh. Something of an objects-versus-closures situation, then?
22:11:50 <jowens> howdy, can someone comment on how i might represent a 2d grid of numbers in Haskell?
22:11:55 <edwardk> solrize you mean lennart's?
22:11:56 <jowens> like, an image.
22:12:02 <solrize> sorry, yeah, augustss
22:12:12 <solrize> i knew there was a double s in there somewhere :)
22:12:14 <mauke> jowens: many ways
22:12:20 <jowens> mauke: all ears.
22:12:20 <sjanssen> jowens: possibly an Array
22:12:26 <sjanssen> jowens: or a Data.Map
22:12:33 <jowens> can Array have 2D?
22:12:42 <mauke> list of numbers, list of lists of numbers, 2d array of numbers, 1d array of numbers, array of array of numbers, possibly a bytestring
22:12:42 <sjanssen> jowens: sure, the index type can be a pair
22:12:45 <solrize> http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
22:12:47 <mxc> can't you just have the index to the array be a tuple?
22:12:48 <edwardk> solrize: yeah, though i must admit its just one of the areas that haskell deals with poorly and i by now know to try to avoid sticking my foot in that bear trap ;)
22:13:26 <jowens> ok. my rwh book said "no arrays in Haskell"
22:13:33 <jowens> so Array is welcome. :
22:13:35 <jowens> :)
22:13:35 <jowens> thanks!
22:13:36 <wli> MyCatVerbs: Possibly. It's more that they represent different things. For instance, modules are parametrizable by other modules and values in addition to being parametrizable by types.
22:13:41 <edwardk> solrize: i don't always succeed, hell category-extras is a pretty solid example of going too far down the 'make it a typeclass with a ton of parameters so you don't have to refactor it' mindset
22:13:56 <mauke> jowens: where did it say that?
22:14:26 <jowens> "Life without Arrays or Hash Tables", p. 288
22:14:37 <wli> MyCatVerbs: So one could switch out sorted lists for CBT's for O(n) -> O(lg(n)) speedups.
22:14:59 <edwardk> jowens: well, there is a limited degree of truth to that. you have them, but in general you don't want to use them ;)
22:15:02 <mauke> jowens: which chapter?
22:15:12 <gwern> Life without hash tables? but then how is one going to implement HashLife??? :)
22:15:13 <jowens> Chapter 12, Barcode Recognition.
22:15:27 <jowens> I think they're more referring to mutable arrays, upon further perusal.
22:15:33 <mauke> "Introducing arrays"
22:15:34 <jowens> But that title kind of makes me think, hey, no arrays!
22:15:35 <wli> MyCatVerbs: Or tune some value differently among different users of the module with great ease by making the value a module parameter.
22:15:43 <mauke> "The usual data type for constant-time random access is of course the array. Haskell provides several array  data types. We'll thus represent our encoding tables as arrays of strings."
22:15:52 <MyCatVerbs> wli: mmmmhmmm.
22:16:16 <jowens> mauke: gotcha. I'll poke through Array and see how I'm doing.
22:16:21 <jowens> thanks!
22:16:23 <solrize> in haskell it's all i can do to use a type alias to paramtrize the type i want to use for integers, and then not have int contagion infect my program like a disease because i used "length" somewhere
22:16:30 * Axman6 attempts to make a basic FFI interface to Apple's veclib
22:16:54 <gwern> solrize: so use genericLength?
22:16:56 <mauke> "At a single stroke, then, immutable arrays have eliminated two canonical imperative data structures from our toolbox. Arrays are somewhat less useful in pure Haskell code than in many other languages. Still, many array codes only update an array during a build phase, and subsequently use it in a read-only manner."
22:16:56 <MyCatVerbs> wli: which you can do (extremely tediously) by parameterizing typeclasses and then using gratuitous newtype wrapping and unwrapping in order to change an instance used.
22:17:06 <MyCatVerbs> wli: I think, anyway.
22:17:26 <wli> MyCatVerbs: To the extent modules are parametrizable by types, typeclasses can recover that in a vaguely straightforward manner, at least until things beyond the typesystem like array sizes crop up.
22:18:02 <jowens> mauke: I'm going a read-only array after construction. so i'll try that.
22:18:17 <mauke> have you actually read that chapter? :/
22:18:57 <MyCatVerbs> wli: it's really really painful to do that with typeclasses, though.
22:18:59 <jowens> mauke: I'm reading bits and pieces. I'm doing Project Euler and picking up what I need in those bits and pieces. :)
22:19:07 <jowens> people here have been very helpful.
22:19:33 <solrize> gwern, yeah, that handles "length" but there's not one for "take"
22:19:40 <gwern> really?
22:19:41 <solrize> :t genericTake
22:19:42 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
22:19:44 <solrize> hmm
22:19:44 <gwern> @hoogle generic
22:19:44 <lambdabot> Data.Generics.Aliases type Generic c = a -> c a
22:19:44 <lambdabot> Data.Generics.Aliases data Generic' c
22:19:44 <lambdabot> Data.Generics.Aliases Generic' :: Generic c -> Generic' c
22:19:48 <gwern> @hoogle genericTake
22:19:49 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
22:20:00 * gwern decides to respectfully disagree with solrize 
22:20:03 <solrize> ok, i have to import a module to use it
22:20:15 <solrize> i had tried typing it at the ghci prompt
22:20:16 <gwern> the horrors. the horrors.
22:20:23 <wli> MyCatVerbs: Another big nasty is the usual constrained typeclass parameter problem, e.g. heaps would be instances of Monad if not for the Ord constraint on their parameter type. Doing it in the module system dodges some of the difficulties there (Hell, that argues for running the module -> typeclass transformation *backward* if anything.)
22:20:38 <solrize> well ghci didn't know about it so i figured it didn't exist, shrugged and added a cast
22:21:27 <MyCatVerbs> wli: I was kinda thinking that. Why not translate typeclasses into modules rather than vice versa? If modules are strictly more powerful, then that's the easiest way to do it.
22:21:51 <MyCatVerbs> wli: then your language would still have typeclasses, but only as a convenient way to specify some common cases.
22:21:58 <wli> MyCatVerbs: Arithmetic syntax and various other things.
22:22:03 <wli> MyCatVerbs: Exactly.
22:22:37 <MyCatVerbs> Except for the fact that maybe it'd be kinda funny to have modules generating typeclasses.
22:22:48 <MyCatVerbs> But then there's nothing stopping you from making modules generate modules? ;D
22:23:31 <wli> MyCatVerbs: Define a typeclass within a parametrized module. Every fresh instantiation of the module generates a fresh typeclass along with it.
22:24:19 <wli> MyCatVerbs: Modules generating modules is typical in ML, at least with the fully functorial style.
22:29:10 <wli> MyCatVerbs: Also, nested modules are typical usage in ML where the translation into typeclasses isn't entirely straightforward.
22:29:57 <wli> MyCatVerbs: I think it most typically trips over the constrained parameter problem IIRC.
22:30:04 <MyCatVerbs> wli: I think I really, *really* need to look into this. :)
22:30:12 <MyCatVerbs> wli: which is?
22:30:19 <lispy> I think type classes are just a clever way to implicitly pass a type as a parameter
22:31:10 <sjanssen> I thought type classes were a clever way to implicitly pass a dictionary as a parameter?
22:31:34 <wli> MyCatVerbs: You need an instance on a type of higher kind where the type of higher-kind's parameter(s) must be constrained for the instance to be valid.
22:31:39 <lispy> sjanssen: I think that's just an implementation detail :)
22:31:56 <sjanssen> lispy: I don't think so
22:32:20 <sjanssen> lispy: but I'm curious what you mean by passing a type as a parameter
22:32:27 <MyCatVerbs> wli: I can't follow that, sorry. :)
22:32:47 <lispy> sjanssen: Well, look at the signature of anything that uses a class
22:32:50 <lispy> :t show
22:32:51 <lambdabot> forall a. (Show a) => a -> String
22:33:04 <lispy> That => could have been ->
22:33:09 <lispy> Show a -> a -> String
22:33:14 <sjanssen> but "Show a" isn't a type
22:33:35 <lispy> No, that's true
22:33:35 <sjanssen> in that case, you'd be passing a value of type "Show a"
22:33:41 <sjanssen> ie. a dictionary :)
22:33:55 <lispy> Well, also a value of type "Show a" is a type
22:34:08 <wli> MyCatVerbs: For instance, there's data PriorityQueue t where Ord t is required for almost all of the PriorityQueue manipulation functions. instance Monad PriorityQueue can't ever happen because the type parameter isn't around to be constrained in the instance head.
22:34:16 <sjanssen> "a value ... is a type"?
22:34:34 <lispy> I use "value" liberally
22:34:58 <lispy> A type variables value is a type, right? :)
22:35:11 <lispy> "type varibale's value"
22:35:26 <wli> MyCatVerbs: In a module system implementation of monads, the parameter type could appear and so be constrained, though it's possible to write it in like fashion and so trip over the same problem.
22:35:29 <MyCatVerbs> wli: oh right! I thought you were discussing a problem encountered when using modules, rather than one that came up with typeclasses. =)
22:43:24 <Gracenotes> :t (print "test" >>=)
22:43:25 <lambdabot> forall b. (() -> IO b) -> IO b
22:43:51 <Gracenotes> > print "oof" >>= \a -> print $ show a
22:43:52 <lambdabot>   * Exception: "<IO ()>"
22:44:32 <pumpkin_> oof!
22:44:39 <Gracenotes> lambdabot: 1, side effects: 0
22:46:12 <sbahra> By any chance, do you guys know who to talk to about haskell.org mailing lists?
22:46:21 <Gracenotes> I want to see a monad that launches missiles... the idea of side effects as "destructive" is very fun :)
22:46:56 <sbahra> Specifically, requirements for getting freebsd-support@haskell.org or similar.
22:51:54 <afabian> Hmm.  Can I define functions at the ghci repl?  I'm typing stuff that looks like it would be a valid function if I put it in a file.
22:52:16 <dons> something funny (google knows all): http://galois.com/~dons/images/troll.png
22:53:42 <solrize> hahahahahahahahahahahahahahaa
22:54:21 <rodge> awesome
22:54:57 <pumpkin_> is that the jhc30 guy?
22:55:06 <solrize> jdh30
22:55:10 <pumpkin_> oh yeah
22:55:18 <pumpkin_> got confused with the compiler there
22:57:45 <pumpkin_> wow, he really is a troll, just reading his blog now
22:58:46 <dons> don't read his blog. it is bad for your mental health
22:59:03 <pumpkin_> it's making me want to scream :P
22:59:27 <pumpkin_> what's up with him? why is he like that?
22:59:53 <dons> i'm not sure. i don't think he understands communities (he's said he doesn't believe in them)
23:01:14 <pumpkin_> I mean things like his "haskell < ocaml because look at the top 10 projects' miscounted lines of code, and I'm going to count FFTW as ocaml"
23:01:28 <Gracenotes> dons: which of the blogs?
23:02:13 <dons> yeah, not worth it.
23:02:28 <pumpkin_> :)
23:07:46 <Gracenotes> "Ganesh, I am afraid you are a long way behind me in terms of technical qualifications. This will be obvious to people reading your comments here."
23:07:53 <Gracenotes> heh.
23:08:01 <mxc> hi
23:08:14 <mxc> anyone have any expereince with the various PNG/JPG libraries?
23:08:41 <mib_zev9xghx> > print $ ( uncurry (-) . (\f -> \g -> ( \y -> (f y, g y))) sum (foldr max 0)) [1,5,7,8]
23:08:41 <wli> I've done some reading about the PNG format.
23:08:42 <lambdabot>   * Exception: "<IO ()>"
23:08:48 <wli> I know nothing of the libs.
23:09:00 <dons> Gracenotes: oh dear.
23:09:11 <dons> mxc: only the gtk2hs loader stuff
23:09:17 <dons> mxc: oh, also the gd bindings
23:09:20 <dons> they're nice.
23:09:47 <mib_zev9xghx> ( uncurry (-) . (\f -> \g -> ( \y -> (f y, g y))) sum (foldr max 0)) [1,5,7,8]
23:09:58 <mxc> dons: saw those, the one problem i had just browing the haddock docs is that I couldn't find an obvious  wya to actually work with the Image data once loaded
23:10:06 <mib_zev9xghx> > ( uncurry (-) . (\f -> \g -> ( \y -> (f y, g y))) sum (foldr max 0)) [1,5,7,8]
23:10:07 <lambdabot>   13
23:10:08 <dons> mxc: Graphics.GD.loadPngFile for example
23:10:12 <dons> oh.
23:10:27 <mxc> dons: once I do that, finding specific pixel values and manipulating them
23:11:03 <mxc> dons: was thinking about just using the pbm code from this book that some guy wrote that just came out that I love and finding some utility to convert from PNG <-> PBMs
23:11:10 <Gracenotes> > let sum = getProduct . execWriter . f; f [] = tell mempty; f (x:xs) = tell (Product x) >> f xs in sum [1..5]
23:11:11 <lambdabot>   120
23:11:45 <Gracenotes> > let sum = execWriter . f; f [] = tell []; f (x:xs) = tell [x] >> f xs in sum [1..5]
23:11:47 <lambdabot>   [1,2,3,4,5]
23:12:30 <solrize> http://groups.google.com/group/comp.lang.functional/msg/472326fbdcbb3c9c?dmode=source
23:13:00 <mib_zev9xghx> > ( sum &&& foldr max 0 >>> uncurry (-) ) [1,5,7,8]
23:13:01 <lambdabot>   13
23:13:27 <dons> solrize: problem with newsgroups he exploits well: hard to ban
23:13:36 <dons> well, not sure how well, actually. poorly more likely
23:13:47 <solrize> yeah, i haven't seen him on clf in a while though, maybe his blog is keeping him busy
23:13:53 <dons> its a very archaic way to do thiings
23:13:58 <Gracenotes> > let sum = runWriter . f; f [] = tell []; f (x:xs) = tell [x^2] >> f xs in sum [1..5]
23:13:59 <lambdabot>   ((),[1,4,9,16,25])
23:16:15 <Axman6> would anyone be able to help me write a haskell version of http://hpaste.org/13180 from C? it's from http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html and i wanted to compare it to a haskell version
23:16:33 * Axman6 looks at dons for awesome low level haskell skillz
23:16:38 <jeffwheeler> I'm trying to learn about the Data.Graph library, but having a bit of trouble. Given that I don't know the math behind it, can anybody suggest when using that library might be useful?
23:16:46 <jeffwheeler> I'm not sure when I'd ever use the library, but it seems neat.
23:17:05 <pumpkin_> that's from fgl?
23:18:04 <Axman6> :t tell
23:18:05 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
23:18:06 <dons> Axman6: mmm.
23:18:16 <dons> oh
23:18:21 <pumpkin_> jeffwheeler: oh, from containers?
23:18:27 <jeffwheeler> pumpkin_: yep
23:18:41 <pumpkin_> jeffwheeler: you mean in general, when you'd use graphs of that sort?
23:18:47 <dons> looks like a job for uvector, Axman6
23:18:54 <jeffwheeler> pumpkin_: exactly; when would you ever use one?
23:18:57 <pumpkin_> they're used in any kind of network
23:19:02 <pumpkin_> social networks, for example
23:19:11 <pumpkin_> any time you want to show connectedness
23:19:23 <jeffwheeler> pumpkin_: hmm, alright; I vaguely get that
23:19:26 <pumpkin_> also in constraint satisfaction systems, and things
23:19:35 <jeffwheeler> pumpkin_: I think there are some old contest problems I could try solving using those
23:19:47 <pumpkin_> so if package x depends on package y, for example, you could put a directed edge between their associated nodes
23:20:06 <jeffwheeler> pumpkin_: oh, dependency graph things?
23:20:08 <pumpkin_> a good order for installing a set of packages is then the topological sort of them
23:20:26 <pumpkin_> (topSort) in Data.Graph
23:20:39 * jeffwheeler just pulled up the wikipedia page for that ;)
23:20:45 <pumpkin_> not sure why I put that in parentheses :P
23:20:45 <dons> Axman6: some ideas here to kick you off: http://hpaste.org/13181
23:21:15 <pumpkin_> jeffwheeler: but they're pretty much everywhere
23:21:30 <Axman6> dons: i recognise this code... where's it from? (one of your making haskell as fast as C blogs posts?)
23:21:43 <jeffwheeler> pumpkin_: yeah, I tried looking through the Euler solutions, but it was only used once in a small way, so I thought I might be missing something broader.
23:21:49 <Axman6> i might stick to a simple recursive algorithm i think
23:22:32 <pumpkin_> yeah, surprisingly I haven't seen many problems that are directly related to graphs on project euler
23:22:55 <dons> Axman6: somewhat, yeah.
23:22:59 <jeffwheeler> pumpkin_: there's an excess of prime numbers, though; practically every other problem :P
23:23:06 <pumpkin_> yeah :P
23:23:06 <dons> Axman6: that stuff you can also do by hand using manual recursion
23:23:10 <dons> just harder work
23:23:15 <dons> though easier to think about
23:23:49 <Axman6> i'll stick with defining it myself, so i understand the algorithm better to begin with i think
23:24:00 <jeffwheeler> pumpkin_: there's some great problems for old contest at the Texas Computer Education Association (TCEA); they're intended for Java (and that's occasionally evident), but they have some problems like that
23:24:12 <pumpkin_> ah, cool
23:24:28 <dons> Axman6: the important things are more the types of data and structures you use
23:24:54 <Axman6> yeah
23:25:04 <Axman6> well, i'll get on it after dinner.
23:25:08 * Axman6 &
23:26:40 <vegai> something weird is going on with latest cabal and containers-0.2.0.0
23:27:05 <vegai> I was able to install it before, but when I try to reinstall it, I get
23:27:10 <vegai> Data/IntMap.hs:182:7:
23:27:10 <vegai>     Could not find module `Data.Data':
23:27:10 <vegai>       it is a member of package base, which is hidden
23:27:29 <vegai> and a fresh install on another box fails in a similar way
23:27:48 <vegai> runghc Setup.hs configure && runghc Setup.hs build  -- builds it fine though
23:28:40 <vegai> but if I install it manually, cabal-install is not aware of it and tries to reinstall it again
23:29:53 <vegai> meh, I'll just clean everything and start from tabula rasa
23:30:05 <dons> vegai: mm. --constraint problems i think
23:30:10 <dons> (well, solutions)
23:30:21 <dons> cabal-install and runghc behave different wrt. to which base they pick
23:30:26 <dons> `Data.Data is only in base 4
23:30:34 <dons> (crazy module name btw)
23:30:52 <mxc> dons: looks like the gtk2hs pixbuf module might do what i need
23:30:52 <mxc> thanks
23:32:03 <vegai> HXT seems so nice, but I'm suspicious whether it should really be concerned about connecting to net
23:32:13 <vegai> (slightly changing subjects)
23:33:00 <vegai> or whether an XML parser should be non-pure
23:34:48 <dons> oh, it has some network functions does it?
23:35:10 * wli tries to find readline on Windows' ghci.
23:35:27 <sjanssen> vegai: it probably needs that for DTD validation
23:37:03 <vegai> and to do that, it links against curl
23:38:32 * wli tries to find some sort of readline-like lib for Windows.
23:38:33 <sjanssen> it would have to fetch the DTDs somehow
23:38:40 <vegai> yeah, I know
23:39:24 <dons> talk to the author if its an issue
23:41:50 <solrize> :t (const print)
23:41:51 <lambdabot> forall a b. (Show a) => b -> a -> IO ()
23:42:25 <solrize> i guess you could have an interface that takes the dtd as a separate value.  of course you'd have to get the dtd itself through an IO action.
23:46:16 <vegai> not an issue in the long run. Fortunately. curl has a liberal license
23:48:26 <solrize> does haskell have something like lwp / urllib ?
23:49:13 <vegai> solrize: HTTP perhaps
23:49:46 <gio123> Cale: hi
23:50:05 <dons> solrize: the download lib
23:50:10 <dons> i'm guessing, by that name
23:50:29 <solrize> i'd probably want to use that instead of curl
23:50:53 <solrize> download looks good
23:51:34 <solrize> hmm, has it got stuff to interpret http headers etc.?
23:51:53 <pumpkin_> how would you characterize the Num typeclass in mathematical terms?
23:52:00 <vegai> also http://hackage.haskell.org/packages/archive/HTTP-Simple/0.1/doc/html/Network-HTTP-Simple.html
23:53:29 <solrize> vegai, that looks like a reasonable beginning but a bytestring version that did POST and parsed the headers a bit further would be useful
23:53:36 <pumpkin_> seems to me like Num is a little too specific to "traditional numbers"
23:54:03 <solrize> anyway i'd asked in the context of getting DTD's but urllib is an extremely useful python lib
23:54:38 <Cale> hi gio123
23:57:42 <gio123> Cale: could u pm me please
23:57:48 <gio123> Cale: could u pm me please?
