00:00:47 <Cale> Megzlna: See how that works? foldr replaces each (:) with the supplied function
00:01:00 <Megzlna> foldl has to keep going forever because it keeps consuming the list before it can try f
00:01:10 <ski_> yes
00:01:53 <Cale> right, and even if it *was* applying f (as is the case with foldl'), it has no way of knowing whether it has any finished part of the result until it reaches the very end
00:02:06 <Cale> Because the next call to f might totally change everything
00:02:28 <Cale> Whereas in the foldr case, you're starting with the outermost f at the beginning of the list.
00:02:30 <Megzlna> part of the confusion here was also involving "why foldl HAS to do it tha way (and thinking of foldl')"
00:03:09 <Megzlna> next call to f might change everything?
00:03:17 <mib_h6pwzm> What's the best way to strip duplicates in a list?
00:03:19 <Cale> That outermost f is the absolute authority on any part of the result which it can produce without looking at its second parameter
00:03:20 <Megzlna> How does that change fact that f called for an abort
00:04:04 <Cale> Well, let's look at this one...
00:04:11 <sjanssen> mib_h6pwzm: as long as the list isn't long, use Data.List.nub
00:04:14 <Cale> > foldr (:) [] [1..]
00:04:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:04:23 <Cale> foldr (:) [] is the identity function
00:04:39 <Megzlna> > foldr (:) [] [a,b,c,d,e,f] :: Expr
00:04:40 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Expr]'
00:04:43 <Cale> But let's look at (:) as a function rather than as a constructor for a moment
00:04:59 <Cale> > foldr (:) [] [a,b,c,d,e,f] :: [Expr]
00:05:00 <lambdabot>   [a,b,c,d,e,f]
00:05:18 <Cale> > foldr (\x xs -> x : xs) [] [1,2,3]
00:05:19 <lambdabot>   [1,2,3]
00:05:51 <Cale> Can the function (\x xs -> x : xs) determine any part of its result without knowing the value of xs?
00:05:55 <Cale> Yes it can!
00:06:13 <pumpkin> @faq can haskell determine any part of its result without knowing the value of xs?
00:06:14 <lambdabot> The answer is: Yes! Haskell can do that.
00:06:17 <Cale> In particular, it can tell you that you're getting a list which starts with x
00:06:52 <Cale> Now, let's look at foldl...
00:07:13 <Cale> foldl (\xs x -> x : xs) [] [1,2,3]
00:07:34 <Cale> First of all, what's the result of this?
00:07:44 <Cale> (before we stick it into lambdabot and check ;)
00:07:52 <mib_h6pwzm> sjanssen: I'm looking for a solution without use of any other libraries here
00:07:53 <Megzlna> > foldl (:) 1 [2,3,4,5,[]]
00:07:54 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:07:54 <lambdabot>        Expect...
00:08:01 <pumpkin> :o
00:08:33 <Cale> > foldl (\xs x -> x : xs) [] [1,2,3]
00:08:34 <lambdabot>   [3,2,1]
00:08:38 <sjanssen> mib_h6pwzm: just so you know, we don't do homework problems in #haskell
00:08:45 <Cale> Do you see why it's [3,2,1] ?
00:08:56 <Cale> foldl (\xs x -> x : xs) [] [1,2,3]
00:08:59 <Megzlna> yeah
00:09:11 <Cale> -> foldl (\xs x -> x : xs) (1 : []) [2,3]
00:09:14 <mib_h6pwzm> sjanssen: that's very nice, though I'd like assistance with this part of my program if possible
00:09:24 <Cale> -> foldl (\xs x -> x : xs) (2 : (1 : [])) [3]
00:09:25 <sjanssen> mib_h6pwzm: sure :)
00:09:31 <Cale> -> foldl (\xs x -> x : xs) (3 : (2 : (1 : []))) []
00:09:32 <sjanssen> mib_h6pwzm: so what have you got so far?
00:09:44 <Cale> -> 3 : (2 : (1 : []))
00:09:53 <Cale> okay, now let's modify things a little...
00:10:05 <Cale> > foldl (\xs x -> x : map (+1) xs) [] [1,2,3]
00:10:06 <lambdabot>   [3,3,3]
00:10:10 <Megzlna> why was mine an infinite type?
00:10:21 <Cale> Megzlna: You had both a list and an element in your list.
00:10:29 <ski_> @pl \xs x -> x : xs
00:10:30 <lambdabot> flip (:)
00:10:45 <ski_> > foldl (:) 1 [2,3,4,5]
00:10:45 <Cale> oh, also, (:) is the wrong type for foldl
00:10:46 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:10:46 <lambdabot>        Expect...
00:10:50 <ski_> > foldl (flip (:)) 1 [2,3,4,5]
00:10:51 <lambdabot>       No instance for (Num [b])
00:10:51 <lambdabot>        arising from the literal `1' at <inter...
00:10:58 <mib_h6pwzm> sjanssen: the purpose of this particular function is purely to remove any duplicates from my list, seeing as I'm breaking down the problem, I effectively have nothing thus far (it'll be so short that having /anything/ will mean it's pretty much solved)
00:11:08 <ski_> oh, right .. the `1' should be `[]'
00:11:12 <ski_> > foldl (flip (:)) [] [2,3,4,5]
00:11:13 <lambdabot>   [5,4,3,2]
00:11:19 <Megzlna> hah, yeah [1,[]] illegal
00:11:20 <ski_> > foldl (:) [] [2,3,4,5]
00:11:21 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:11:21 <lambdabot>        Expect...
00:11:28 <sjanssen> mib_h6pwzm: like most list problems, you want to think inductively
00:11:40 <Cale> Megzlna: let's look at this new problem
00:11:45 <sjanssen> mib_h6pwzm: you know that the empty list [] has no duplicates
00:11:50 <Cale> Pretend that we only know the start of the list
00:11:54 <mib_h6pwzm> sjanssen: yep
00:11:56 <Megzlna> it's significant that the 'z' can be a different type from the elements of the list
00:12:01 <Cale> foldl (\xs x -> x : map (+1) xs) [] (1 : ...)
00:12:04 <ski_> Megzlna : because `foldl' wants the argument function to take *its* arguments in the opposite order to `foldr' we had to do `flip (:)' there
00:12:07 <ski_> @type foldr
00:12:08 <ski_> @type foldl
00:12:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
00:12:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:12:15 <Cale> Megzlna: can anything be determined about the result of this ^^
00:12:25 <Cale> (without knowing what's in ...)
00:12:47 <Megzlna> just the lambda
00:12:53 <Megzlna> having flipped order
00:13:07 <Cale> foldl (\xs x -> x : map (+1) xs) [] (1 : ...)
00:13:21 <sjanssen> mib_h6pwzm: what would we have to do to (x:xs) to construct a list that has no duplicates?
00:13:31 <Cale> -> foldl (\xs x -> x : map (+1) xs) (1 : map (+1) []) (...)
00:13:50 <Cale> Megzlna: note that 1 isn't even a part of the result of this foldl
00:13:58 <pumpkin> can't get my ghci to use more than 100% cpu
00:13:59 <pumpkin> ah well
00:14:02 <Cale> Megzlna: So we effectively know absolutely nothing about the result at this step.
00:14:18 <mib_h6pwzm> sjanssen: that sounds as though there's an infinite number of possibilities, but I'm starting to think along the lines of recursion and using elem
00:14:22 <Cale> So in order to know the first thing about the result of a foldl, it's absolutely necessary to look at the end of a list.
00:14:39 <sjanssen> pumpkin: par might not work in ghci, I'm not sure.  Can you try compiling the code?
00:14:42 <Megzlna> ah
00:15:17 <pumpkin> sjanssen: not that important, was just hoping to speed this up by a factor of 2, but it's not that slow
00:15:20 <Cale> Which is an explanation for why it doesn't work for infinite lists. It's not an implementation issue, it's a fundamental limitation on what we're trying to do.
00:15:54 <sjanssen> mib_h6pwzm: yes, there's a workable solution that uses elem
00:15:57 <Cale> Infinite lists have no end, and so we can never know the first thing about the result of foldl, it's perfectly undefined.
00:16:09 <Cale> (no matter how foldl itself is implemented)
00:16:50 * quicksilver chortles at pumpkin's "just hoping to speed this up by a factor of 2"
00:16:59 <quicksilver> if only parallelism was that simple :)
00:17:07 <mib_h6pwzm> sjanssen: are there any less "i'm re-inventing the wheel by making my own primitive recursive function" solutions, though ?
00:17:19 <Megzlna> okay, Cale. Once I textize all this info', I think I can make perfect sense of it
00:17:25 <pumpkin> quicksilver: oh yeah, I'm stupid :) I was thinking of parmap in the wrong direction :P
00:18:07 <Megzlna> still blurry, but only because I didn't write out evaluation chains
00:18:10 <sjanssen> mib_h6pwzm: mmm, not really.  The definition in Data.List uses primitive recursion
00:18:26 <sjanssen> mib_h6pwzm: you can do it via sorting, if that is more your cup of tea
00:18:30 <mib_h6pwzm> sjanssen: yes, but that's another function
00:18:40 <mib_h6pwzm> Rather than me making my own
00:18:47 <mib_h6pwzm> I guess I shouldn't stress too much over it
00:20:23 <aiur> @src map
00:20:24 <lambdabot> map _ []     = []
00:20:24 <lambdabot> map f (x:xs) = f x : map f xs
00:21:48 <Megzlna> <Cale> foldl (\xs x -> x : map (+1) xs) [] (1 : ...)
00:22:01 <Megzlna> why did you put 'xs' there when it would be z?
00:22:14 <jml> does haskell have asynchronous I/O libraries?
00:22:15 <pumpkin> @hoogle comparing
00:22:16 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:22:16 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:22:18 <Megzlna> for \acc
00:22:48 <jml> al-maisan: hello :)
00:22:56 <sjanssen> jml: there are some non-blocking IO functions in System.IO
00:23:09 * jml takes a look
00:23:16 <al-maisan> hello jml, nice seeing you around here :)
00:23:18 <sjanssen> jml: however, blocking in Haskell isn't such a bad thing, since we have threads that actually work
00:24:37 <jml> sjanssen: you wouldn't happen to have a URL that points to a paper or something that backs that up?
00:25:22 <sjanssen> jml: Control.Concurrent should have some pointers, the GHC commentary also.  Perhaps the GHC manual
00:25:33 <jml> thanks
00:25:57 <al-maisan> jml: here's the "Real world Haskell" chapter about I/O: http://book.realworldhaskell.org/read/io.html
00:26:25 <sjanssen> jml: oh, "Haskell on a shared memory multi-processor" by Peyton-Jones et al, is also a good read
00:27:10 <sjanssen> (that isn't about IO so much as the threads)
00:27:35 <Megzlna> > foldl (\xs x -> x : Prelude.map (+1) xs) [] [1,2,3,4,5]
00:27:37 <lambdabot>   [5,5,5,5,5]
00:27:53 <jml> al-maisan: thanks, but what I'm really interested write now is concurrency with I/O. (so either threads or non-blocking I/O & a select loop)
00:28:10 <al-maisan> Ah/
00:28:35 <sjanssen> jml: oh, and if you just want a short explanation, threads in Haskell map to non-blocking IO and a select loop :)
00:28:47 <jml> I need to pick up a copy of RWH post-Christmas.
00:29:08 <jml> sjanssen: oh, well that's handy :)
00:29:18 * al-maisan bought one while attending the UDS :)
00:29:26 <Megzlna> > scanl (\xs x -> x : Prelude.map (+1) xs) [] [1,2,3,4,5]
00:29:28 <lambdabot>   [[],[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5]]
00:30:04 <jml> sjanssen: however, I have a deeply held scepticism for all thing thread related, so I'll do my research.
00:30:30 <jml> (modulo verb/noun agreement)
00:30:42 <sjanssen> jml: GHC/Haskell might be the one place where threads are not broken
00:31:14 <jml> well, it's not the implementation of threads that has got me in other languages
00:31:24 <jml> it's the near-impossibility of reasoning about code.
00:31:42 <jml> but I can see why that might be easier in Haskell.
00:31:59 <Megzlna> > scanl (\xs x -> x : Prelude.map (+1) xs) [] [a,b,c,d,e]
00:32:01 <lambdabot>   [[],[a],[b,a + 1],[c,b + 1,a + 1 + 1],[d,c + 1,b + 1 + 1,a + 1 + 1 + 1],[e,...
00:32:02 <sjanssen> yes, code tends not to rely on state that can be accessed from other threads
00:32:08 <Megzlna> > scanr (\xs x -> x : Prelude.map (+1) xs) [] [a,b,c,d,e]
00:32:09 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:32:10 <lambdabot>        Expect...
00:32:19 <sjanssen> and there are also neat abstractions like STM that really help
00:32:49 <decafbad> can I set a function name shadow another one? for example, I want to use System.IO.Utf8.getLine, not Prelude.getLine, when I write just getLine
00:33:04 <jml> interesting.
00:33:27 <sjanssen> decafbad: import System.IO.Utf8; import Prelude hiding (getLine) -- closest you can get to shadowing
00:34:26 <decafbad> sjanssen: I tought Prelude always automatically imported
00:34:45 <sjanssen> decafbad: it is unless there is an explicit Prelude import
00:35:00 <solrize_> some reason to use select instead of epoll or aio or something like that?
00:35:07 <decafbad> that works, thanks
00:35:39 <sjanssen> solrize_: select is more portable, they haven't gotten around to using the nicer platform specific stuff yet
00:35:42 <solrize_> oh cool i didn't know there was a utf8 module
00:36:54 <quicksilver> jml: when almost all your data is immutable (as is the haskell way) threads are a lot less worrying
00:37:19 <quicksilver> jml: no need for any kind of locking around an immutable value.
00:38:26 <jml> sure.
00:39:01 <quicksilver> and when you do actually need to communicate between threads, Chans are an nice easy to understand abstraction.
00:39:10 <jml> and yet, a little paranoia is justifiable from time to time. :)
00:39:13 <quicksilver> (and easy to reason about)
00:39:17 <quicksilver> definitely.
00:40:23 <jml> in any case, a bit of mucking around won't hurt.
00:40:56 <pumpkin> anyone know what FF is in http://www.polyomino.f2s.com/david/haskell/hs/Primes.hs.txt ?
00:41:32 <pumpkin> oh found it
00:41:38 <quicksilver> pumpkin: IF I had to guess, I'd say it's http://www.polyomino.f2s.com/david/haskell/hs/FF.hs.txt
00:41:41 <quicksilver> :P
00:41:41 <pumpkin> :)
00:41:42 <pumpkin> yup
00:42:08 <quicksilver> looks like an implementation of Z/p
00:45:15 <pumpkin> yup
00:46:08 <solrize_> Haskell on a shared memory multi-processor  is interesting but kinda old, have they redone the benchmark w/ parallel gc and more cores?
00:49:17 <ivanm> I just got RWH! \o/
00:49:33 * ski_ wonders why `F 1 x == F 1 y' is undefined ..
00:50:04 <mib_h6pwzm> Hmm.. is it possible to count how many elements you've gone through in a list comprehension regardless of whether the predicate was true?  (I mean, [ x | x <- xs], working out how many elements of xs you've gone through)
00:50:55 <solrize_> [x | (x,i)<-zip xs [0..]]
00:50:57 <ski_> mib_h6pwzm : maybe you want something like `[ .. | (x,i) <- xs `zip` [0..] , .. ]' ?
00:53:02 <ski_> (pumpkin : would you happen to know whether the author of that code is a regular here ?)
00:53:18 <pumpkin> ski_: I don't, just found it on google :/
00:54:40 <ski_> i'm puzzled by `F p x == F q y | ... | p == 0 && q == 0  = False  -- because we already know x /= y'
01:02:42 <pumpkin> whee, so much eulering in haskell
01:03:49 <ski_> ?
01:04:00 <pumpkin> project euler
01:04:55 <mib_h6pwzm> Is there anything like !! but for tuples?  e.g. xs = (a, b, c) and  xs !! 2  (if it was an array)
01:04:58 <mib_h6pwzm> list*
01:05:29 <solrize_> fst and snd for pairs
01:05:40 <mnislaih> anyone got a reference to a paper about or with an example of lazy search ?
01:05:47 <pumpkin> mib_h6pwzm: in general, no
01:06:01 <blackh> mib_h6pwzm: The type couldn't be known at compile time.
01:06:15 <pumpkin> mib_h6pwzm: having a real nick would help us talk to you :P
01:06:18 <mnislaih> which was the original one on using haskell lists for search ?
01:06:32 <mnislaih> can't remember the author nor the title :S
01:15:43 <ski_> mnislaih : .. maybe you're thinking of "Replacing failure with a list of successes" (Wadler, of course) ?
01:16:06 <mnislaih> ski_: right! thanks :)
01:16:07 <realnick> :)
01:16:21 * ski_ has no idea whether that one is "the original one", though ..
01:17:23 <mnislaih> ski_: it's the one I was thinking about
01:17:53 <realnick> Is it possible to have a function receive a tuple param, modify a specific element in the tuple, and return the modified tuple without assigning names to all the irrelevant tuple elements
01:18:15 <realnick> e.g. function (a, b, c, d) = (a, b, c + 1, d)
01:18:31 <pumpkin> realnick: n-tuples for n /= 2 are a pain to work with
01:18:34 <realnick> I'd prefer to not have to name the other elements
01:18:37 <pumpkin> realnick: but with pattern matching you can do that
01:18:46 <realnick> pumpkin: I was hoping so, how best to do so?
01:18:55 <pumpkin> oh, you can't without naming the other elements
01:19:00 <realnick> Ah, heh
01:19:16 <pumpkin> as I said, I'd stay away from non-pairs
01:19:26 <blackh> realnick: The way to do it is to write a general function for "modify the third element"
01:19:50 <pumpkin> you could call it third, much like first and second from arrow
01:19:52 <pumpkin> ;)
01:19:59 <realnick> Hmm, makes sense
01:20:03 <realnick> thanks
01:20:05 <pumpkin> but the issue is, does it take a (,,) or a (,,,) or what?
01:20:15 <pumpkin> you could make a typeclass out of things having at least n-tuples
01:20:39 <pumpkin> but in general it's ugly, I think
01:21:45 <narain> hi all, is there a function for splitting a list at a given delimiter in the standard libraries? something of type  Eq a => a -> [a] -> [[a]]
01:21:55 <narain> basically a generalization of  lines  and  words
01:22:00 <quicksilver> narain: no.
01:22:18 <quicksilver> comes up every week or two.
01:22:22 <narain> quicksilver: aw, shucks. seems like a useful function to have
01:22:25 <quicksilver> There are quite a few choices.
01:22:31 <quicksilver> Coalesce multiple delimeters or not?
01:22:35 <quicksilver> return delimeters or not?
01:22:48 <quicksilver> specify delimeter as 'a' or 'a -> Bool' or [a] or [a]->Bool
01:23:12 <narain> well the second should be moot, because you can always get delimiters the way you want by  map  or  intersperse , right?
01:23:33 <narain> ditto for coalescing by  filter (not . null)
01:23:41 <narain> :)
01:24:03 <Peaker> I don't see why the delimiter would be an a and not [a], trivially use (return a) to convert the weaker to the stronger
01:24:46 <narain> Peaker: that too
01:24:53 <Peaker> I'd take both the list/function forms (for efficiency/flexibility)
01:24:54 <narain> oh well, let me go write my function then.
01:25:15 <Peaker> narain: the [a] one is non-trivial to implement with good performance
01:27:32 <pumpkin> bah
01:27:39 <pumpkin> it's remarkably difficult to kill ghci once it starts stealing all my memory
01:27:58 <Peaker> pumpkin: Modern OS's suck :-(
01:28:10 <Peaker> I keep making note-to-self to put memory quota, but I never remember to
01:28:16 <pumpkin> how?
01:28:20 <Peaker> rlimit
01:28:44 <Peaker> ulimit that is
01:28:47 <pumpkin> also, couldn't ghci do its computation in another thread so the signal handler doesn't get held up?
01:28:49 <Peaker> use ulimit -a
01:28:53 <pumpkin> or doesn't it work that way?
01:29:17 <quicksilver> pumpkin: the signal handler doesn't get held up by computation.
01:29:17 <Peaker> pumpkin: Signal handlers don't get "held up" by threads, you don't need threads for them to run whenever the kernel wants
01:29:27 <pumpkin> hmm
01:29:29 <quicksilver> pumpkin: but it does get held (haskell-side) if a GC is going on.
01:29:36 <pumpkin> ah
01:29:46 <pumpkin> so the signal handler is getting through to ghci
01:29:51 <quicksilver> yes, it should be.
01:29:53 <pumpkin> but it's putting it on hold
01:29:54 <Peaker> pumpkin: what I think happens is that memory thrashing throws everything from RAM into swap, including critical things like X and the various user-input drivers/code, so you can't control your machine anymore
01:29:54 <pumpkin> hmm
01:30:02 <quicksilver> of course another possibility is that your terminal program has swapped out
01:30:10 <quicksilver> so the ^C hasn't even been converted to a signal yet ;)
01:30:18 <pumpkin> well, I tried to catch it before I saw all my memory go down the drain
01:30:22 <pumpkin> but it just ignored my ctrl+c
01:30:25 <pumpkin> several times
01:30:35 <Shirakawasuna> hrm, stupid book.  It's probably my fault somewhere, but it's having me use hugs98 to learn on.  However, I can't use it like the scripts they're specifying and main = do concepts haven't been introduced yet....
01:30:36 <pumpkin> by the time I opened another terminal to try to kill it
01:30:37 <Peaker> the *sad* thing is that the entire size of everything that deals with user input is *tiny* and that its being swapped out to add a tiny percentage of memory to an already huge thing :-(
01:30:43 <Shirakawasuna> so every time I try to input what's in the book, I get errors
01:30:43 <pumpkin> it had eaten everything up and it took ages
01:31:04 <Shirakawasuna> maybe I'm not supposed to play w/ the examples...
01:31:07 <quicksilver> Shirakawasuna: I'd need to know details for sure, but probably the book is expecting you to type stuff into a small file
01:31:15 <quicksilver> Shirakawasuna: called "example.hs" or whatevre, and load that into hugs.
01:31:17 <RayNbow> memory thrashing = nightmare
01:31:28 <pumpkin> yeah :/
01:31:48 <Peaker> Maybe if each process had a "credit count" of how important it is, and its MFU/MRU pages were thus much more "important" than the MRU/MFU pages of whatever is thrashing (which has low credit), this wouldn't happen
01:31:51 <RayNbow> it degrades your high-end 2+ GHz machine into a 286 or something :p
01:32:01 <quicksilver> no, a nightmare is when you run ghci and a tentacle monster climbs out of your screen and starts bashing you around the head with a closure.
01:32:02 <Peaker> RayNbow: my 286 was faster :(
01:32:02 <pumpkin> worse :(
01:32:07 <quicksilver> or is that just me?
01:32:31 <pumpkin> RayNbow: you see the time it took between the message before my "bah" and the "bah" itself? that was me opening a terminal and killing ghci
01:32:50 <pumpkin> 7 minutes I think
01:33:01 <RayNbow> Peaker: I actually never had a 286... I started with a 386 I think...
01:33:05 <Peaker> pumpkin: when I see it takes more than 20 seconds to get a terminal, I reboot, its faster :-(
01:33:23 <pumpkin> Peaker: I had unsaved stuff in another window :/
01:34:09 <pumpkin> what do the "levels" of project euler represent?
01:34:15 <pumpkin> it says (2 more until first level) for me
01:34:20 <Peaker> pumpkin: Yet another reason modern OS's (or computing) sucks. Why the heck do we need to explicitly "save" or lose everything by default?
01:34:30 <pumpkin> Peaker: yeah :/
01:34:34 <pumpkin> we need a new paradigm!
01:34:37 <RayNbow> pumpkin: I think I didn't catch your first "bah" (I probably joined the channel in between)
01:34:59 <pumpkin> RayNbow: ah, anyway just under 7 minutes :)
01:35:15 <Peaker> We need everything to _always_ be saved ASAP. And we need a universal/global revision control system for all user content (where a big global undo would even re-open closed windows/etc), instead of stupid explicit saving
01:35:26 <pumpkin> mmm
01:35:41 <Peaker> I really miss a "global undo" key
01:36:06 <RayNbow> Peaker: that would be nice, but I'd still vote for some "save" feature
01:36:12 <Peaker> RayNbow: why?
01:36:15 <RayNbow> that marks a version as "stable" or something
01:36:20 <quicksilver> Peaker: that's why I use emacs.
01:36:26 <Peaker> RayNbow: that's a "tag", rather than "save"
01:36:35 <ski_> a more useful undo should not walk back in a totally ordered fashion ..
01:36:36 * quicksilver hasn't lost any work in a file for years. touching wood.
01:36:36 <RayNbow> ah
01:37:08 <quicksilver> (not the only reason, of course, but certainly one of them)
01:37:10 <Peaker> RayNbow: We currently have the   current-editor-state,  saved-to-file-state,   committed-to-rcs-state,   tagged-state.   We really just need to unite the first 2, and last 2 (so commit == tag)
01:37:20 <Peaker> I guess we could generalize tags to be a hierarchy of tags
01:37:35 <Peaker> quicksilver: emacs' auto save is too expensive when editing large files, because it copies the whole thing
01:38:16 <quicksilver> Peaker: I don't consider that to be too expensive.
01:38:26 <quicksilver> Peaker: it's simple and therefore not fragile.
01:38:40 <Peaker> quicksilver: I can't stand the delays it incurred, so I think I cancelled that
01:38:54 <quicksilver> then you deserve to lose your work.
01:39:04 <quicksilver> ;)
01:39:18 <quicksilver> seriously I've not noticed the auto-save delay for years.
01:39:20 <Peaker> quicksilver: If we had proper global RCS, I could have my cake and eat it too
01:39:59 <quicksilver> you'd eitehr have to take the cost of a complete file copy, or have an editor which was smart enough to talk to the global RCS to calculate an efficient diff.
01:40:16 <quicksilver> and tehre would be cases where calculating the diff was more expensive than just a copy.
01:40:46 <Peaker> quicksilver: I want an Eros-like system where everything is revision-controlled, and the editor/UI widgets don't see "files" but typed values/etc
01:41:01 <Peaker> quicksilver: Every edit operation *is* a diff, why calculate a diff?
01:41:06 <jml> andy a Pony
01:41:52 <quicksilver> Peaker: it's very expensive to view every edit operation as a diff and compose them all.
01:41:53 <jml> Peaker: if we are talking blue-sky, then diffs suck.
01:41:57 <quicksilver> after you've made 500 edits
01:42:06 <quicksilver> it would have been far, far cheaper to do a whole-file copy.
01:42:12 <Peaker> quicksilver: why? I am "Caching" the most recent document state
01:42:24 <Peaker> quicksilver: and saving the diffs as well, so I can undo
01:42:28 <quicksilver> MS Word has worked this way for years
01:42:34 <jml> e.g. the stored change should be semantic data, "jml renamed the function 'foo' to 'bar'"
01:42:40 <quicksilver> it's the most abhorrent and ridiculous thing in software engineering
01:42:54 <quicksilver> and contributes to MS Word being the slowest program ever written with the largest file sizes.
01:43:01 <Peaker> quicksilver: MS Word may be a ridiculous piece of crap, but that doesn't mean any particular thing it does is also that :)
01:43:13 * RayNbow always disables MS Word 'quicksave' :p
01:43:18 <quicksilver> however, this particular thing is a key cause of its slowness and crapness.
01:43:22 <Peaker> quicksilver: Why is it slow to store the edit diffs alongside the most-recent version?
01:43:36 <quicksilver> because that very rapidly becomes huge.
01:43:49 <quicksilver> I'm not actually trying to suggest this isn't an interesting problem which would be fun to solve.
01:43:52 <quicksilver> it is.
01:43:58 <quicksilver> I'm just trying to point out it's very hard, and very easy to get wrong.
01:44:03 <Peaker> quicksilver: you can edit documents for weeks and have an undo buffer for all that time available, it can't possibly be huge if its just a product of human input (only)
01:44:49 <Peaker> quicksilver: doc = accumR new id $ editDiff <$> humanInput        -- you only really have to store humanInput or such for the entire history
01:45:17 <Peaker> s/id/applyDiff perhaps
01:45:23 * quicksilver nods
01:45:41 <quicksilver> I did understand what you mean yes ;)
01:45:46 <Peaker> jml: That is a diff
01:45:51 <Peaker> jml: When I say "diff" I don't mean a textual one
01:46:00 <jml> Peaker: good good.
01:46:14 <Peaker> jml: I am an anti-text zealot, you know that :-)
01:46:25 <quicksilver> Peaker: I believe the ideas you are expounding are good ideas.
01:46:28 <jml> Peaker: if you just mean "structured representation of a change to a document", then I'm ok with that.
01:46:37 <quicksilver> I simply do not believe they will be 'cheaper' than emacs' auto-save.
01:46:54 <quicksilver> I believe they will be even more expensive, overall, although the price will be worth paying if it works well.
01:47:29 <Peaker> quicksilver: old diffs you've already saved don't cost you in terms of current performance.. constantly copying the most-recent-document like emacs does is much more expensive
01:48:16 <quicksilver> but at some point you have to checkpoint it
01:48:21 <quicksilver> or file sizes grow without bounds
01:48:39 <Peaker> quicksilver: You don't want the entire history diffs, you mean?
01:49:10 <Peaker> quicksilver: In my system you'd store the current-document (even though its a product of all history's diff, for caching), and all the diffs/human inputs.  The latter is "big", but disk space is cheap
01:50:49 <Peaker> quicksilver: also, you could "compress" old diffs (unite diffs that cancel each other out, etc)
01:51:54 <quicksilver> the complexity of this kind of structure is not well understood.
01:52:17 <quicksilver> RCS systems tend to have quite poor asymptotic bounds (but very good constants)
01:52:48 <quicksilver> if you're going to use it for ebverything, you need to think about how it will scale
01:53:02 <quicksilver> and how you will let people clear out disk space when they want to.
01:54:56 <jml> is there a string formatting convenience in the haskell stdlib?
01:55:16 <Cale> jml: I personally usually use concat or words, together with show
01:55:16 <Deewiant> Text.Printf
01:55:22 <Cale> jml: But there is Text.Printf
01:55:27 <jml> thanks
01:55:28 <Cale> If you really want it.
01:56:12 <quicksilver> Cale: did you get my note about lambdabot and tghe DMR?
01:56:42 <Cale> I don't think I understood what you meant. You want {-# LANGUAGE NoMonomorphismRestriction #-} in L.hs?
01:57:05 <quicksilver> Cale: I don't know what the solution is.
01:57:06 <Peaker> quicksilver: well, if this is done for low-bandwidth reactive inputs (such as mouse/keyboard) it should really not be a disk-space problem.  For camera/etc you could still only do destructive updates
01:57:13 <Cale> It's already supposed to be applying -XNoMonomorphismRestriction when running code.
01:57:14 <quicksilver> Cale: I can describe the problem.
01:57:28 <quicksilver> Cale: it appears to apply NMR for :t but not @run
01:57:39 <Cale> jml: Also note the Numeric library has lots of number-formatting stuff.
01:57:41 <jml> @src unwords
01:57:42 <lambdabot> unwords [] = ""
01:57:42 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
01:57:47 <quicksilver> @let f = (+1)
01:57:49 <lambdabot>  Defined.
01:57:50 <Cale> quicksilver: hmm
01:57:51 <quicksilver> :t f
01:57:52 <lambdabot>     Ambiguous occurrence `f'
01:57:52 <lambdabot>     It could refer to either `L.f', defined at <local>:6:0
01:57:52 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:72:0-32
01:57:56 <quicksilver> doh
01:58:00 <quicksilver> @let ff = (+1)
01:58:01 <lambdabot>  Defined.
01:58:01 <Cale> @undef
01:58:02 <quicksilver> :t ff
01:58:03 <lambdabot> Not in scope: `ff'
01:58:04 <Cale> oh, sorry
01:58:05 <quicksilver> @let ff = (+1)
01:58:06 <lambdabot>  Defined.
01:58:08 <quicksilver> :t ff
01:58:09 <lambdabot> forall a. (Num a) => a -> a
01:58:13 <quicksilver> ^^ polymorphic, good.
01:58:23 <quicksilver> > (ff (1::Int),ff (1::Double))
01:58:24 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
01:58:27 <Cale> okay
01:58:29 <jml> Cale: that's worth knowing.
01:58:29 <quicksilver> ^^ monomorphic wtf?
01:58:31 <quicksilver> ;)
01:58:35 <jml> cheers
01:58:50 <Cale> jml: no problem :)
01:58:59 <quicksilver> Cale: it also does not apply the NMR to whatever "checking" @let does
01:59:09 <quicksilver> Cale: although it's applied to the result as seen through :t
01:59:13 <quicksilver> @let ff = fmap
01:59:14 <lambdabot>  <local>:2:0:
01:59:14 <lambdabot>      Multiple declarations of `L.ff'
01:59:14 <lambdabot>      Declared at: <local>:...
01:59:20 <quicksilver> @let ffff = fmap
01:59:21 <lambdabot>  <local>:2:7:
01:59:21 <lambdabot>      Ambiguous type variable `f' in the constraint:
01:59:21 <lambdabot>        `Fun...
01:59:29 <quicksilver> ^^ DMR error.
02:00:12 <Cale> @undefine
02:00:19 <Cale> @let ff = fmap
02:00:20 <lambdabot>  Defined.
02:00:25 <Cale> :t ff
02:00:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:00:32 <quicksilver> !?
02:00:35 <Cale> fixed.
02:00:39 <quicksilver> cool.
02:00:49 <quicksilver> @let plusone = (+1)
02:00:49 <lambdabot>  Defined.
02:00:50 <Deewiant> > (ff (+1) (Just 1), ff (+2) [1,2])
02:00:52 <lambdabot>   (Just 2,[3,4])
02:01:07 <quicksilver> > (plusone (1::Int),plusone (1::Double))
02:01:08 <lambdabot>   (2,2.0)
02:01:14 <quicksilver> Cale: nice. What did you change?
02:01:53 <Cale> Added a language pragma to the top of Pristine.hs
02:02:08 <Cale> and then @undefine'd so that it would get copied into L.sh
02:02:10 <Cale> L.hs*
02:02:24 * quicksilver nods
02:02:53 <pumpkin> you can just fix lambdabot without even it dying?
02:03:01 <Cale> yep
02:03:12 <Cale> Because a lot of the stuff is just separate programs which run.
02:03:17 <pumpkin> ah
02:04:12 <quicksilver> although you could write hotstart easily enough even without that.
02:04:25 <quicksilver> just need to write out which FDs are which to a file
02:04:37 <quicksilver> (and then exec yourself)
02:05:07 <narain> @pl \x -> map (adjacent x) xs
02:05:08 <lambdabot> flip map xs . adjacent
02:08:25 <Saizan> and make the RTS manage them as before?
02:10:02 <quicksilver> Saizan: well, you have a little bit of code to respawn the reader/writer threads correctly on the FDs.
02:10:04 <jml> is there something like this in the stdlib: joinList a = foldl1 (\x -> \y -> x ++ a ++ y)
02:10:06 <pumpkin> how many primes are there under a million?
02:10:13 <jml> several
02:10:19 <quicksilver> that's the kind of information I meant by 'which are which'
02:10:25 <quicksilver> jml: intercalate
02:10:29 <quicksilver> :t intercalate
02:10:29 <jml> thanks.
02:10:30 <lambdabot> forall a. [a] -> [[a]] -> [a]
02:10:38 <Megzlna> heheh hours of writing out folds
02:10:54 <pumpkin> jml: thanks :P
02:11:00 * Megzlna writing folds till blue in face
02:11:41 <quicksilver> > intercalate " but " $ cycle ["no","yeah"]
02:11:43 <lambdabot>   "no but yeah but no but yeah but no but yeah but no but yeah but no but yea...
02:12:12 <quicksilver> Vicky Pollard in 42 chars of haskell.
02:12:34 <opqdonut> badabum tshh
02:12:51 <jml> pumpkin: I think it's about 72k actually
02:13:06 <jml> pumpkin: http://en.wikipedia.org/wiki/Prime_number_theorem#Statement_of_the_theorem
02:13:10 <pumpkin> yeah
02:13:21 <pumpkin> > 1000000 / log(1000000)
02:13:23 <lambdabot>   72382.41365054197
02:22:00 <realnick> I have list 'a' and list 'b'.  How can I best find elements in 'b' that are not in 'a' ?
02:22:22 <pumpkin> are they big?
02:22:25 <realnick> no
02:22:28 <wjt> > let { a = [1,2]; b = [1,3,5] } in a \\ b
02:22:30 <lambdabot>   [2]
02:22:34 <wjt> uhm, b \\ a
02:22:35 <quicksilver> > [1,2,3,4,5] \\ [1,2,4]
02:22:36 <lambdabot>   [3,5]
02:22:51 <opqdonut> > [1,1,1] \\ [1]
02:22:52 <lambdabot>   Not in scope: `\\ï¿½'
02:22:54 <wjt> if the lists model sets you might want to use Data.Set instead
02:23:04 <quicksilver> realnick: it's an O(n*m) algorithm so it's pretty slow on big lists
02:23:04 <opqdonut> > [1,1,1] \\ [1]
02:23:05 <lambdabot>   [1,1]
02:23:08 <quicksilver> but fine for small ones.
02:23:24 <quicksilver> for large lists, Set.difference or Map.differenceWith
02:24:12 <realnick> quicksilver: any good functions for this in the prelude?
02:24:44 <realnick> Trying to think if I can tie in filter or such
02:25:19 <Megzlna> So, with foldr, it has a chance to stop based upon 'x', not upon 'acc'
02:28:40 <pumpkin> is there a show that gives me an Int in a given base?
02:29:34 <Lemmih> pumpkin: Numeric.showIntAtBase
02:29:39 <pumpkin> ah, thanks :)
02:30:48 <nanothief> With newtype, what is the difference between newtype UniqueID = UniqueID Int and data UniqueID = UniqueID Int other than efficiency?
02:31:02 <quicksilver> nanothief: there is a very subtle definedness difference
02:31:28 <quicksilver> which is not often important
02:31:30 <paolino> realnick: are these lists ordered ?
02:31:55 <quicksilver> nanothief: in the data, UniqueID _|_ is different from _|_
02:32:03 <quicksilver> nanothief: with newtype, UniqueID _|_ *is* _|_
02:32:25 <narain> is there any easy way to do something like  dropWhile  on *two* lists with a binary predicate?  dropWhile  with  zip  loses trailing elements on unequal length lists, which is bad
02:32:51 <nanothief> quicksilver, ok (I remember reading that somewhere)
02:33:08 <wjt> narain: how would you apply the binary predicate to the trailing elements?
02:33:24 <narain> good question. i want to keep them
02:34:12 <wjt> I would just write out your own f :: (a -> a -> Bool) -> [a] -> [a] -> ([a], [a])
02:34:28 <nanothief> quicksilver: but it is primarily done for increased program efficiency, you could make do with just the data statement ?
02:34:29 <Peaker> zippy :: [a] -> [a] -> [(Maybe a, Maybe a)]  could be of use, maybe?
02:34:30 <realnick> Is there a prelude function that may allow me to see if an item is within a list?
02:34:44 <Peaker> realnick: elem
02:34:55 <Peaker> @type elem
02:34:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:34:56 <realnick> er... how did I forget that.
02:35:17 <narain> wjt: i can, but i was wondering if there was a standard function or a one-liner
02:35:22 <narain> oh well
02:35:30 <narain> Peaker: where's that from?
02:36:04 <nanothief> realnick: hoogle is useful when you forget something like that, just search for a -> [a] -> Bool and you would find the function
02:36:17 <nanothief> hoogle is pretty cool btw
02:37:12 <Peaker> narain: my mind :)
02:38:13 <narain> Peaker: fun :)
02:39:53 <quicksilver> nanothief: yes, I think that is true. Newtype is primarily just for efficiencu.
02:40:05 <quicksilver> nanothief: GHC's GeneralisedNewtypeDeriving is handy too
02:40:49 <Peaker> quicksilver: Wouldn't trivial optimizations for the single-strict-data-constructor case be just as efficient as newtype?
02:41:04 <nanothief> quicksilver, ok thanks, I managed to get myself very confused about it after reading about it in real world haskell
02:41:07 <Peaker> Then we only remain with the different way the bottom case is defined for that
02:41:12 <quicksilver> Peaker: they're not trivial, because they change semantics.
02:44:23 <nanothief> well NewTypeDeriving definitely looks useful for making a very similar, but different copy of an existing type
02:44:40 <jml> is it just me, or are Maps just a little bit of a pain to work with.
02:45:32 <jml> hmm. it might just be the me of a minute or two ago.
02:47:07 <redditbot> A purely functional 2D scenegraph library
02:47:59 <pumpkin> whee
02:48:00 <pumpkin> Bravo, pumpkin! Now that you have solved 25 problems you have achieved what 79.98% of members have failed to do and have advanced to level 1. Good luck as you continue.
02:48:19 <pumpkin> lol
02:49:40 <nanothief> I liked answering the first question and jumping 10,000 places or so. After that you don't get the same reward :(
02:50:18 <pumpkin> oh you're ranked?
02:50:26 <pumpkin> I ugess it makes sense :P
02:58:59 <Asztal> the problems above 200 scare me :(
02:59:25 <blathijs> What problems are these? Euler project?
02:59:29 <Asztal> yes
03:00:17 <Asztal> I even had an attempt a 108 (I've done 53 so far), and I haven't even managed that one yet :)
03:03:55 <hugo___> hi there
03:10:42 <pumpkin> bah, I keep coming to the same answer on http://projecteuler.net/index.php?section=problems&id=55 but it rejects it
03:16:46 <hugo___> hello
03:17:35 <hugo___> i have this function that receives a function that generates a string and outputs a string
03:17:51 <hugo___> like this: f str_gen = "t" ++ str_gen ++ "t"
03:18:02 <hugo___> how do i define its type signature ?
03:18:09 <hugo___> f :: String -> String ?
03:18:11 <dibblego> homework?
03:18:14 <hugo___> no
03:18:18 <hugo___> work
03:18:22 <dibblego> :type f
03:18:30 <Asztal> pumpkin: yeah, me too!
03:18:35 <BeelsebobWork> hugo___: what type does "t" have?
03:18:40 <pumpkin> Asztal: frustrating :P
03:18:49 <hugo___> BeelsebobWork: "t" is a String
03:19:00 <BeelsebobWork> hugo___: okay, and what type does (++) have?
03:19:13 <hugo___> its just that, i was generating HTML and ghci started saying that my arguments are functions that were already defined
03:19:34 <hugo___> (++) :: [a] -> [a] -> [a]
03:19:49 <BeelsebobWork> okay, given that it's first argument is "t", what type does ("t" ++) have?
03:19:54 <hugo___> so it must output a [Char] ? :/
03:19:59 <BeelsebobWork> okay, yep
03:20:13 <BeelsebobWork> so, we know that it's output is a [Char] (aka a String)
03:20:31 <hugo___> but isn't type String = [Char] ?
03:20:36 <BeelsebobWork> given that str_gen is used in that (++) call, what type does that have?
03:20:52 <hugo___> str_gen :: String
03:21:05 <BeelsebobWork> okay, so now you know the type of the input to f
03:21:08 <BeelsebobWork> and you know the type of the output
03:21:16 <BeelsebobWork> so you should be able to construct the type of f
03:21:19 <hugo___> yes
03:21:22 <hugo___> but it doesn't work ;)
03:21:35 <BeelsebobWork> (and indeed you get correctly to String -> String)... so we need to look elsewhere for your problem
03:21:43 <BeelsebobWork> can you pastebin the error ghci is giving you?
03:21:46 <hugo___> yes
03:24:37 <hugo___> http://hpaste.org/13093
03:24:58 <BeelsebobWork> ah, it's because your variable names start with capitals
03:25:14 <BeelsebobWork> caps are for data contstructors or types
03:25:20 <BeelsebobWork> lower case are for constants and function names
03:26:09 <BeelsebobWork> while we're at it though... You could make this code a lot nicer by not dealing with strings until the last moment
03:26:27 <hugo___> oh
03:26:29 <hugo___> how ?
03:28:09 <pumpkin> Asztal: did you figure out what was wrong?
03:28:37 <Asztal> not yet :(
03:28:50 <hugo___> BeelsebobWork: using point-free programming ?
03:29:01 <BeelsebobWork> hugo___: sec, I'm just putting together a little paste
03:29:09 <hugo___> olraite, thanks :)
03:33:42 <hugo___> i haven't quite got used to this camel case stuff
03:34:02 <hugo___> but i guess it makes sense in haskell, since data constructors or types must start with caps
03:34:36 <BeelsebobWork> hugo___: something like this... http://hpaste.org/13093#a1
03:35:25 <BeelsebobWork> the benefit being that it's (a) easier to see what you're doing and make sure you're producing valid html (b) you guarentee correct indentation of the html
03:35:30 <BeelsebobWork> and various other nicities
03:35:37 <BeelsebobWork> like you can now write functions from HTML -> HTML
03:35:38 <hugo___> x :=: y ?
03:35:42 <BeelsebobWork> and essentially get XSLT, but nice
03:35:51 <BeelsebobWork> you can use : to create infix data constructors
03:35:58 <hugo___> ah
03:36:01 <BeelsebobWork> so :=: is a data constructor with two arguments -- x and y
03:36:02 <hugo___> thats good :)
03:36:23 <hugo___> i wish i could have thought in that :/
03:36:50 <hugo___> but i lack the experience and knowledge
03:37:04 <BeelsebobWork> we live and learn -- Haskell is a deep language
03:37:20 <hugo___> hey man, thanks you very much :D
03:37:23 <BeelsebobWork> so here your html template would change somewhat
03:37:28 <hugo___> i will study your approach and try to work it out
03:37:32 <BeelsebobWork> you would probably write a "wrap in body" function instead
03:37:40 <BeelsebobWork> and a "wrap in div" function
03:37:42 <BeelsebobWork> and compose them
03:38:08 <hugo___> yes, very good
03:38:53 <hugo___> your data declaration of HTML speaks by itself
03:39:07 <Ferdirand> where's Monad ((->) t) defined again ?
03:39:16 <hugo___> im not able to think like that
03:39:41 <BeelsebobWork> http://hpaste.org/13093#a2 <-- so there's a nice thing you can do with it hugo___
03:39:45 <Asztal> pumpkin: got it :)
03:40:04 <pumpkin> Asztal: :o
03:40:15 <pumpkin> :(
03:40:39 <Asztal> want a clue? (it may be unhelpful anyway)
03:40:43 <pumpkin> sure
03:40:56 <Asztal> I was misreading/not paying attention to the sentence about palindromic numbers
03:41:21 <pumpkin> what was the problem number again? I'm working on another one and lost the link :P
03:41:27 <Asztal> 55
03:41:56 <pumpkin> oh
03:42:01 <pumpkin> damn
03:42:05 <pumpkin> I think I see
03:42:12 <RayNbow> Ferdirand: ((->) t) is defined in Control.Monad.Instances
03:42:49 <Asztal> I first read that sentence, though "how's that surprising?" and subsequently ignored it :(
03:43:33 <Arnar> Hi all!
03:43:37 * BeelsebobWork ponders what Monad (-> t) would look like... is it (>>=) = flip (.); return = const?
03:44:03 <RayNbow> @src (->) (>>=)
03:44:03 <lambdabot> f >>= k = \ r -> k (f r) r
03:44:16 <BeelsebobWork> ah, duh
03:44:17 <Asztal> fmap is flip (.), I think
03:44:25 <Arnar> can anyone here confirm if GHC still produces an STG machine?
03:44:25 <BeelsebobWork> no, fmap is (.)
03:44:31 <Asztal> oh >_>
03:44:50 <Arnar> someone told me that was not the case but Peng Li's thesis says otherwise..
03:45:51 <quicksilver> Arnar: its' not precisely stg, no.
03:45:52 <Saizan> it's no more tagless, afaiu
03:45:54 <quicksilver> it's a close cousin.
03:46:00 <quicksilver> it has a little bit of tagging now.
03:46:09 <Arnar> quicksilver: ah, ok..
03:46:28 <Arnar> quicksilver: can you point me to some text that gives an overview of the current state?
03:47:39 <pumpkin> Asztal: thanks, got it :)
03:47:43 <pumpkin> that was a silly mistake
03:50:58 <quicksilver> Arnar: unfortunately not, no. I think you have to read SPJ's recent papers and join up the dots yourself.
03:51:09 <quicksilver> Arnar: there is some commentary in the GHC wiki.
03:52:30 <Arnar> quicksilver: ok, thanks though :)
03:52:38 <pejo> Arnar, http://www.cs.uu.nl/wiki/bin/view/Alexey/FasterLazinessUsingDynamicPointerTagging is a good starting point
03:53:47 <Arnar> pejo: great, thanks!
03:53:59 <C-Keen> Let me repeat a question I asked 3 hours ago:
03:54:06 <C-Keen>  I got a problem with darcs code I don't understand: http://hpaste.org/13088
03:56:05 <quicksilver> C-Keen: GADTs have changed.
03:56:15 <quicksilver> is that a GADT?
03:56:38 <quicksilver> (type families have also changed, if that is a type family)
03:59:39 <C-Keen> quicksilver: the PatchChoices type is indeed. How would I write this so it gets accepted for older ghcs as well?
04:02:09 <quicksilver> C-Keen: I don't know. The bug in pre-6.10 GADTs is not something I can satisfactorily explain to you.
04:02:52 <C-Keen> quicksilver: Is the usage of let a problem here? I have seen similar code elsewhere that works
04:02:59 <quicksilver> try http://haskell.org/haskellwiki/Upgrading_packages#Changes_to_GADT_matching
04:03:12 <C-Keen> quicksilver: will do! thanks for the hint
04:03:17 <quicksilver> although I think that's 6.8 code which doesn't work in 6.10
04:03:21 <quicksilver> you ave the opposite problem.
04:03:51 <hugo___> oh, haskell doesn't allow for letters in infix data constructors ?
04:04:28 <quicksilver> foo `Bar` baz
04:04:29 <quicksilver> is fine.
04:04:33 <C-Keen> quicksilver: hmmm...
04:04:38 <quicksilver> but operators can't contain letters
04:04:43 <quicksilver> (be their constructor or otherwise)
04:04:46 <pejo> Arnar, does the details of the STG-machine that GHC implements matter?
04:04:53 <hugo___> hmm ok
04:04:55 <hugo___> thanks
04:05:42 * PeakerWork wants smooth-scrolling in emacs
04:06:03 <PeakerWork> hitting the bottom of the screen and getting a huge *quirk* scroll-down is very disorienting
04:08:29 <slarba> (setq scroll-margin 1) ?
04:08:48 <Davbo> Hey all, could someone explain to me why the bottom definition here http://hpaste.org/13094 is more useful than the top?
04:09:42 <slarba> (setq scroll-conservatively 5)
04:09:45 <vixey> Davbo, imagine you wanted to write a function that turns a tree of symbols "Char" into a tree with those symbols paired up with the path (like [L,R,R,L,R]) to get to that symbol
04:09:51 <slarba> that should smoothen scrolling a bit
04:10:18 <vixey> Davbo, with so you either write HTree a -> HTree (a,Path) or you have to define a new datatype
04:10:36 <Davbo> ah, i see
04:11:32 * Davbo lost marks on some coursework for doing the bottom definition
04:11:59 <adept> hi. Strange question about IO - i have code that traverses huge array of unboxed ints and prints some of the indexes out (basically, it's "for all idx: v <- readArray idx; when (p v) (putStrLn idx)"). My problem: profiling shows that I spend 50% of runtime (which is quite decent - tens of seconds) in putStrLn/show. Question: what can I do to speed my IO up? (note that I am pronting indexes, not elements of array, so array has nothing to do with it)
04:12:52 <blackh> adept: Buffering?
04:13:02 <Saizan> adept: you're using MArray?
04:13:40 <adept> blackh: tried BlockBuffering Nothing, BlockBuffering (Just 4096), Just 65536 + hPutStrLn/hFlush instead of putStrLn. No noticeable difference
04:13:52 <adept> Saizan: IOUArray, but this must be irrelevant
04:14:25 <blackh> adept: try piping your output to /dev/null.  That will eliminate a lot of the non-Haskell parts of the I/O.
04:14:55 <blackh> adept: Or perhaps a better question - are you putting the output on the screen or into a file?
04:15:23 <Saizan> i can imagine a single putStr on a lazy String of all the output to have less I/O overhead, but that's not so pratical to do with IOUArray
04:15:28 <adept> blackh: to /dev/null :)
04:15:55 <adept> Saizan: yep. tried that. I loose big on creating all those strings for "unlines" to consume
04:16:05 <vixey> Davbo, did you argue your case and get the marks back?
04:17:42 <Davbo> vixey: about to do so, that's why I wanted to confirm my thoughts here first
04:18:18 <vixey> Davbo, you know any function that operated on HTree works exactly the same with (bottom) HTree Char
04:18:53 <blackh> adept: Perhaps you could try writing dummy strings with Data.ByteString.hPutStrLn and see what difference that makes to performance.
04:19:16 <blackh> adept: I am pretty much out of ideas. :)
04:19:19 <Davbo> vixey: yeah, i do. It's clear it was marked by someone with no knowledge of Haskell
04:20:05 <vixey> :D
04:21:04 <adept> blackh: hPutStrLn (show 10) instead of (show idx) gives me a decent boost (~15-17%)
04:21:12 <quicksilver> adept: 'show' is pretty slow.
04:21:25 <adept> quicksilver: question is - what's fast? :)
04:21:45 <quicksilver> show 10 is faster because it's only executed once
04:21:53 <quicksilver> so it's effectively hPutStrLn "10"
04:22:50 <sjanssen> adept: what is the type of your indices?
04:24:02 <adept> sjanssen: Int
04:27:43 <blackh> adept: From what you've said it sounds like there might not be any actual obvious bottleneck.  If you really want speed, you could use FFI.
04:27:56 <blackh> adept: Writing your own show would also be easy to do.
04:28:15 <quicksilver> adept: possibly a carefully written bytestring show constructed so IO is block-at-a-time
04:28:49 <adept> blackh: mb I'm dense, but it's not so obvious to me
04:29:21 <adept> quicksilver: hmm... bytestring show. Now that's an idea that I havent tried so far ...
04:29:51 <blackh> adept: The reason why I say that is just a "feel" from "show 10" giving 15-17% boost.
04:30:36 <blackh> adept: Given the problem you're describing, if there were some big bottleneck, I would expect that to account for a much smaller percentage (or much larger, depending on whether the bottleneck is in show or out of it.)
04:33:07 <sjanssen> adept: I believe ByteString has an Int show routine specifically
04:35:06 <adept> sjanssen: I went looking for it and failed :(
04:35:14 <adept> @hoogle Int -> ByteString
04:35:14 <lambdabot> Data.ByteString.Internal unsafeCreate :: Int -> (Ptr Word8 -> IO ()) -> ByteString
04:35:14 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
04:35:14 <lambdabot> Data.ByteString.Char8 replicate :: Int -> Char -> ByteString
04:35:22 <Davbo> vixey: my lecturer has graded it now, my mark has improved 6 fold...
04:35:25 <blackh> blackh: This brings up something I've been wondering about: Is there an equivalent of ShowS for ByteString?  That is, is there an efficient way to do text formatting?
04:35:42 <vixey> Davbo, wow.. curious what scheme or what?
04:35:49 <sjanssen> adept: it might be in a separate package
04:35:59 <vixey> like from 10% to 60%?
04:36:20 <Davbo> yeah, 10 - 60 pretty much
04:36:35 <sjanssen> blackh: Data.Binary.Put is ByteString's ShowS
04:37:01 <vixey> Davbo, why didn't you get 100% :P
04:37:33 <vixey> Davbo, I had some exam today which has a lot of mistakes in the questions :/ ...
04:37:44 <Arnar> pejo: depends on what you mean by "matter" :)
04:37:44 <blackh> sjanssen: What package is that in?
04:37:58 <Arnar> pejo: I'm just interested in the implementation and the internals of GHC
04:38:03 <Clockwork> Hey I have a Lambda Parser and now I want to add 2 functions which shows the bound and the free variables of a Lambda-Expression, any ideas?
04:38:05 <vixey> like mixing up names and typing mistkaes
04:38:10 <Arnar> pejo: perhaps orthogonally to my interest in Haskell
04:38:44 <Davbo> vixey: ouch, I can't stand academics as it is, this is just icing on my cake really
04:38:50 <sjanssen> blackh: binary
04:38:55 <chrisdone> haha... my sincere troll seems to have been mildly contentious: http://www.reddit.com/r/programming/comments/7jf7x/as_soon_as_we_started_programming_we_found_to_our/c06tmax people are coming up with some weird-ass stretched metaphors. âstatic typing is like crawling on my hands and knees. I don't want to crawl, I want to run and be freeeee!â
04:38:56 <vixey> Clockwork, in  (\a -> (\x -> x) x)  is x bound or free?
04:39:09 <Clockwork> oh
04:39:28 <Clockwork> this adds difficulties
04:39:32 <Clockwork> so both?
04:39:51 <vixey> Clockwork: What I'd do is just not worry about 'bound' or 'free' variables :)
04:39:58 <vixey> Clockwork, this stuff is solved
04:40:36 <Clockwork> not to my tutor if this is the string I put out :P
04:41:09 <blackh> sjannssen: Brilliant! Thanks - That's just what I was after.
04:41:35 <vixey> :t (\a -> (\x -> x) x)
04:41:36 <lambdabot> forall t. t -> Expr
04:41:41 <vixey> ugh!
04:41:42 <mokus> vixey: the expression still has a free x
04:41:53 <vixey> :t (\aAAAAAAA -> (\xAAAAAAA -> xAAAAAAA) xAAAAAAA)
04:41:54 <lambdabot> Not in scope: `xAAAAAAA'
04:42:06 <vixey> there is an implementation of it already
04:42:37 <Clockwork> oi
04:43:36 * quicksilver thinks vixey is beign slightly unfair.
04:43:44 <quicksilver> A lot of education is about solving already-solved problems.
04:44:02 <quicksilver> The fact that someone else already solved it doesn't mean there is no point solving it yourself.
04:44:03 <vixey> not this one
04:44:23 <vixey> any formal definition of free/bound variables *is* a haskell program (module case sensitivity or curry)
04:44:36 <blackh> chrisdone: Interesting! You might be interested in my experience...
04:44:42 <vixey> in your textbook if you have got
04:44:46 <quicksilver> that fact will not help Clockwork complete his course.
04:44:56 <vixey> FREE(\x -> M) := FREE(M) \\ [x]
04:45:00 <vixey> then you write in haskell
04:45:03 <blackh> chrisdone: I started doing lots of unit testing to compensate for Python's dynamic typing.
04:45:03 <chrisdone> blackh: sorry? how do you mean?
04:45:10 <chrisdone> blackh: ahhh. interesting
04:45:11 <vixey> free (Lam x m) = free m \\ [x]
04:45:59 <chrisdone> blackh: were you compensating for things which haskell's type system would just squash early?
04:46:10 <blackh> chrisdone: ...and then when I switched to Haskell...
04:46:34 <blackh> chrisdone: I felt that only a tiny fraction of the unit testing was required to get the same quality of code.
04:47:07 <RayNbow> hmm, how easy is it to install GHC on a Linux machine without root?
04:47:18 <Deewiant> very
04:47:29 * RayNbow is on a 8 quadcore machine right now
04:47:32 <blackh> chrisdone: So I've experienced what this debate is talking about.  That's all.  Also - thanks for your blog post - that was good stuff!
04:48:09 <ToRA|MSR> RayNBow, probably as easy as: tar -xzf ghc<TAB> ; cd ghc<TAB> ; ./configure --prefix=$HOME ; make ; make install
04:48:10 <pejo> Raynbow, basically nothing will scale to 32 processors out of the box
04:48:17 <Clockwork> vixey, that's a good advice , thx!:)
04:48:33 <RayNbow> pejo: no, but it might be nice to try out some DPH stuff
04:49:39 <chrisdone> blackh: ah, I see. so a tiny fraction of unit testing captured all the things haskell's type system might? ah, glad you liked the post! :D
04:51:00 <blackh> chrisdone: In other words: I felt like 90% of the unit testing I did in Python was compensating for dynamic typing, and 10% of it would also be necessary in Haskell.
04:51:13 <pumpkin> blackh: I agree
04:52:00 <pumpkin> and you can always have that nagging feeling that you'll get some sort of null pointer exception at runtime :P
04:53:44 <chrisdone> blackh: ohhh
04:53:55 <chrisdone> blackh: yeah, that argues haskell's case well
04:55:32 <pumpkin> so much hardheadedness going into that reddit discussion
04:56:40 <blackh> chrisdone: Part of the problem was that Python was the first dynamically typed language I'd used for years and so I didn't quite know what to expect!
04:56:46 <vixey> is it a discussion about something interesting?
04:56:54 <quicksilver> pumpkin: reddit conversation exhibits lack of clue? Say it ain't so! ;)
04:57:06 <pumpkin> vixey: strong typing vs. world, it seems from what I've seen so far :)
04:57:16 <vixey> oh
04:57:40 <vixey> meanwhile the agnostics are off writing code
04:57:42 <pumpkin> "I've found that static type systems don't help me that much. The kind of errors they prevent are the ones that are easy to find - the program expects that to be a number, not an object, or you gave that function three arguments when it only wanted two. The tests I was going to write anyway will catch that. I spend most of my debugging time fixing logic mistakes, and I haven't seen a type system that will help me with that."
04:57:46 <pumpkin> grr
04:58:10 <vixey> pumpkin, show them such a type system then? :)
04:58:14 <PeakerWork> pumpkin: that is understandable, most people have only seen Java/C++ type systems..
04:58:24 <pumpkin> clearly the extent of their experience is with "don't give me a void * when I expect a goober *"
04:58:33 <adept> sjanssen: thanks, D.B.Put + ByteStringLazy give me ~20% boost
04:58:34 <dolio> He writes unit tests that ensure he always calls every function with the right number of arguments?
04:58:34 <pumpkin> yeah :)
04:58:46 <PeakerWork> dolio: Well, with 100% code coverage, sure
04:59:09 <pumpkin> dolio: if you have a variadic function that fails if the number of arguments doesn't fit some criteria
04:59:29 <PeakerWork> dolio: (very difficult to achieve in real ut's, though)
04:59:44 <vixey> "You have no idea. Frankly, if they actually know a specific language very well then they're near the top of the heap. I've supervised about a half dozen Master's students in the year since finishing my Ph.D., and so far, none have displayed even basic competence"
04:59:45 <vixey> lol
04:59:57 <dolio> I guess. That's a pretty non-specific way to find such a problem, though.
04:59:57 <blackh> "Having said that, I still prefer the dynamically typed languages. Duck typing makes things easier."  <-- I thought that too, but then I realized that the thing that duck typing makes easier....
05:00:01 <SamB> dolio: he probably actually runs a primitive typechecker for that ;-P
05:00:08 <blackh> ....is the unit testing you don't have to do any more!
05:00:09 <dolio> :)
05:01:00 <vixey> http://alloy.mit.edu/community/ what's this?
05:01:06 <fasta> vixey: who said that?
05:01:14 <vixey> psnively
05:01:35 <vixey> uhh
05:01:41 <vixey> fasta, psnively linked that thing
05:01:50 <vixey> I don't know who said that paragraph I pasted
05:02:13 <SamB> vixey: why not ?
05:02:42 <vixey> Version 4 of the Alloy Analyzer is a complete rewrite, offering improvements in robustness, performance and usability
05:02:48 <vixey> I still don't know what it is...
05:02:57 <dolio> The website is terrible.
05:03:29 <dolio> The tutorial uses frames.
05:03:37 <vixey> would this sort of thing:
05:03:43 <vixey> Kodkod is an efficient SAT-based constraint solver for first order logic with relations, transitive closure, and partial models.
05:03:54 <vixey> be a bit like a really advaced version of a topological sort?
05:04:46 <PeakerWork> Why is its name in Hebrew?
05:04:59 <SamB> Peaker: all the english-language names were taken
05:05:17 <vixey> why does a spider have 8 legs :P
05:05:59 <PeakerWork> vixey: are you suggesting the name evolved with natural selection?
05:06:10 <pumpkin> kodkod?
05:08:57 <pumpkin> @seen int-e
05:08:57 <lambdabot> I saw int-e leaving #ghc, #haskell-overflow and #haskell 10h 19m 48s ago, and .
05:09:05 <pumpkin> wow, he's done all the euler problems
05:11:00 <pumpkin> http://projecteuler.net/index.php?section=problems&id=80 does anyone get a different answer for the sum of the first 100 digits of sqrt 2?
05:11:08 <pumpkin> they say it's 475
05:11:18 <drbean> What's the list operator (:) called?
05:11:22 <vixey> cons
05:11:32 <pumpkin> > sum . map digitToInt . drop 2 $ showCReal 100 (sqrt 2)
05:11:34 <lambdabot>   481
05:12:03 <fasta> vixey: do you have the link?
05:12:07 <pumpkin> > sum . map digitToInt . drop 2 $ showCReal 99 (sqrt 2)
05:12:09 <lambdabot>   475
05:19:19 <fasta> Does anyone know the interactions between malloc (the one from the FFI) and garbage collection?
05:20:07 <byorgey> drbean: it's called "cons", as in "constructor", for historical reasons ("historical reasons" = "that's what it's called in lisp")
05:23:20 <pumpkin> can anyone think of a way of summing 100 digits of sqrt 2 such that the sum is 475?
05:23:52 <Eridius> what, you mean finding a string of 100 consecutive digits that do that?
05:24:04 <pumpkin> nope, "first 100" for some definition of it :p
05:24:35 <vixey> > (map toDigit . showCReal 100) (sqrt 2)
05:24:35 <pumpkin> based on this... http://projecteuler.net/index.php?section=problems&id=80 they give an example of what they mean by "digital sum" and either it's a typo or I'm going bonkers
05:24:36 <lambdabot>   Not in scope: `toDigit'
05:24:43 <pumpkin> intToDigit
05:24:48 <pumpkin> > sum . map digitToInt . drop 2 $ showCReal 99 (sqrt 2)
05:24:49 <vixey> > (map digitToInt . showCReal 100) (sqrt 2)
05:24:50 <lambdabot>   475
05:24:50 <lambdabot>   [1,* Exception: Char.digitToInt: not a digit '.'
05:24:59 <vixey> > (map digitToInt . tail . tail . showCReal 100) (sqrt 2)
05:25:01 <lambdabot>   [4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8,0,1,6,8,8,7,2,4,2,0,9,6,9,8,0,7,8,5,...
05:25:04 <PeakerWork> fasta: I have no idea, but I would guess that there isn't one?
05:26:08 <Eridius> pumpkin: ok, they say right there that the first 100 digits sum to 475. what's the problem?
05:26:16 <pumpkin> Eridius: can you reproduce that?
05:26:17 <fasta> Peaker: I believe that when you give a malloced piece of memory to C and the C world then calls back to Haskell, the GC might move the malloced piece of memory.
05:26:34 <pumpkin> Eridius: my problem is that I can reproduce that sum... with 99 digits
05:26:46 <pumpkin> so I'm not sure if they're counting them differently (???) or what
05:26:52 <fasta> PeakerWork: so, when the C code goes to the next instruction, it crashes.
05:27:00 <Eridius> what's showCReal? hoogle comes up empty for that
05:27:06 <fasta> Peaker: I think you need to use a StablePtr in that case.
05:27:14 <pumpkin> Eridius: it takes a CReal and gives you n digits after the decimal
05:27:22 <Deewiant> Eridius: try Hayoo
05:27:24 <pumpkin> > showCReal 5 (sqrt 2)
05:27:25 <quicksilver> fasta: I don't think so.
05:27:26 <lambdabot>   "1.41421"
05:27:26 <Eridius> ok, I'm not familiar with CReal
05:27:34 <pumpkin> Eridius: arbitrary precision decimal
05:27:35 <quicksilver> ForeignPtrs should be pinned too.
05:27:39 <Eridius> pumpkin: ah
05:27:47 <fasta> quicksilver: where does the FFI say that?
05:27:58 <quicksilver> does the FFI define ForeignPtrs?
05:28:03 <Eridius> > showCReal 5 (sqrt 2)
05:28:04 <fasta> quicksilver:                                                          Consequently, objects other than stable
05:28:04 <lambdabot>   "1.41421"
05:28:05 <fasta> pointers (cf. Section 5.6) may be moved or garbage collected by the storage manager.
05:28:09 <Eridius> well there's your issue, pumpkin
05:28:16 <pumpkin> Eridius: how so?
05:28:18 <Eridius> showCReal takes the number of decimals, not the number of digits
05:28:25 <pumpkin> Eridius: I know
05:28:28 <Eridius> so showCReal 99 (sqrt 2) gives you 100 digits, since there's one digit before the decimal
05:28:36 <fasta> quicksilver: I never said I used ForeignPtrs, btw.
05:29:09 <pumpkin> Eridius: I'm saying that if I sum the whole part of sqrt 2 into the "digital sum", I don't get their answer for 100 digits
05:29:17 <pumpkin> only if I consider the 99 digits after the decimal point, do I get their answer
05:29:21 <pumpkin> and it seems like an odd definition
05:29:29 <pumpkin> and one by which I get the wrong answer if I try the rest of the problem
05:29:31 <Eridius> 99 digits after the decimal point == 100 digits total, since there's a "1" before the decimal point
05:29:46 <pumpkin> Eridius: I realize that, but it seems strange to omit the 1 before the decimal point from the sum
05:29:51 <Eridius> so take the number of digits before the decimal point, subtract that from 100, and pass that to showCReal
05:29:53 <Eridius> you're *not*
05:29:58 <Eridius> I think
05:30:05 <quicksilver> fasta: you didn't, I know. I mentioned htem.
05:30:10 <pumpkin> what I'm saying, is that you *only* get 475 if you do :P
05:30:23 <quicksilver> fasta: maybe I'm wrong.
05:30:48 <fasta> quicksilver: oh, I slightly misunderstood what you were saying. :)
05:30:48 <pumpkin> > sum . map digitToInt . drop 2 $ showCReal 99 (sqrt 2) -- we know there's a 1 before the decimal point, so if we counted that too, we'd get 476
05:30:49 <alar> does anybody know what thi means?
05:30:49 <alar> http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-Base.html
05:30:50 <lambdabot>   475
05:31:02 <Eridius> ah, I see what you're saying
05:31:09 <Eridius> > sum . map digitToInt . drop 2 $ showCReal 100 (sqrt 2)
05:31:10 <lambdabot>   481
05:31:12 <Eridius> hrm
05:31:16 <Eridius> maybe it's rounding?
05:31:29 <pumpkin> hmm
05:31:38 <pumpkin> > showCReal 1 pi
05:31:40 <lambdabot>   "3.1"
05:31:42 <fasta> quicksilver: yes, the FFI does specify them.
05:31:43 <pumpkin> > showCReal 3 pi
05:31:45 <lambdabot>   "3.142"
05:31:51 <pumpkin> yup it is, hmm
05:31:56 <pumpkin> this problem is painfully vague
05:31:59 <fasta> quicksilver: but those are for memory filled by e.g. C.
05:32:06 <pumpkin> I guess they assume no rounding
05:32:15 <Deewiant> of course not
05:32:22 <Eridius> > sum . map digitToInt . take 100 . drop 2 $ showCReal 110 (sqrt 2)
05:32:23 <lambdabot>   481
05:32:26 <Deewiant> the third digit in the decimal expansion of pi is not 2, it's 1 :-)
05:32:27 <Eridius> damn
05:32:31 <pumpkin> yeah :)
05:32:43 <fasta> quicksilver: I was talking about calling the Haskell malloc to allocate some memory and then giving the pointer to C land.
05:32:54 <Eridius> > sum . map digitToInt . take 99 . drop 2 $ showCReal 110 (sqrt 2)
05:32:55 <lambdabot>   474
05:32:57 <Eridius> there we go
05:32:58 <Eridius> it was rounding
05:32:59 <Deewiant> > (1+). sum . map digitToInt . take 99 . drop 2 $ showCReal 110 (sqrt 2)
05:33:00 <pumpkin> nice, thank you :)
05:33:00 <Eridius> add the 1 and you get 475
05:33:01 <lambdabot>   475
05:33:31 <Badger> > 1 + 1
05:33:32 <lambdabot>   2
05:33:35 <Badger> > 1 * 1
05:33:37 <lambdabot>   1
05:33:38 <Badger> > pi * 1
05:33:39 <lambdabot>   3.141592653589793
05:33:45 <Badger> inexact!
05:33:59 <quicksilver> fasta: yes, my undesrstanding is that the haskell functions provided to malloc foreign ptrs (e.g. mallocForeignPtr) allocated pinned memory.
05:34:00 <Deewiant> > pi * 1 :: CReal
05:34:02 <lambdabot>   3.1415926535897932384626433832795028841972
05:34:03 <quicksilver> fasta: I may be wrong.
05:34:06 <pumpkin> bah, still get a wrong answer, must have a problem elsewhere :)
05:34:09 <Badger> hmm.
05:34:28 <byorgey> pumpkin: is this s project euler problem or something?
05:34:32 <pumpkin> byorgey: yup :)
05:34:37 <Badger> 71693993
05:34:41 <alar> where has the module Data.Array.Base gone?
05:34:41 <Badger> actually.
05:34:42 <byorgey> cool, which one?
05:34:46 <pumpkin> byorgey: #80
05:34:53 <robyonrails> hi guys... does anyone have bought the book "Real world haskell" ?
05:35:13 <Deewiant> > showCReal 47 $ pi * 1
05:35:15 <lambdabot>   "3.14159265358979323846264338327950288419716939937"
05:35:15 <pumpkin> aha, finally got it
05:35:16 * RayNbow has ordered RWH, but it isn't in stock at his bookshop yet
05:35:19 <pumpkin> lol, another rounding issue
05:35:26 <pumpkin> got a two-digit round :P
05:35:38 <vixey> > showCReal 47 $ (-0)
05:35:39 <lambdabot>   "0.0"
05:35:49 <Eridius> yeah, I was just trying to figure out if there's a way to avoid all rounding errors, even if there's a 1000-digit round
05:35:53 * ibid notes that he received RWH a day or two ago
05:35:57 <Eridius> can't think of any way off-hand though
05:36:07 <ibid> (ordered from amazon, /me is located in finland)
05:36:11 <fasta> quicksilver: mallocForeignPtr attaches a finalizer, but otherwise it the same (and automatically frees memory), but nothing is specified about the behaviour of malloc.
05:36:15 <vixey> > showCReal 47 $ (sqrt 2)
05:36:16 <lambdabot>   "1.41421356237309504880168872420969807856967187538"
05:36:17 <byorgey> pumpkin: huh, I've solved it apparently, but I don't remember it =)
05:36:19 <pumpkin> Eridius: yeah, that would be nice, there's probably another CReal function but I didn't feel like looking it up so I just added digits until it seemed to stabilize
05:36:20 <vixey> > showCReal 15 $ (sqrt 2)
05:36:21 <lambdabot>   "1.414213562373095"
05:36:25 <vixey> > showCReal 14 $ (sqrt 2)
05:36:26 <lambdabot>   "1.41421356237309"
05:36:28 <vixey> > showCReal 13 $ (sqrt 2)
05:36:29 <lambdabot>   "1.4142135623731"
05:36:30 <pumpkin> byorgey: I have it too now :P
05:36:41 <quicksilver> fasta: "It uses pinned memory in the garbage collected heap"
05:36:42 <pumpkin> apparently int-e has done them all
05:36:47 <quicksilver> fasta: is what it says in the docs.
05:38:04 <Badger> > pi * 1 :: Double
05:38:06 <lambdabot>   3.141592653589793
05:38:09 <Badger> oic
05:38:52 <kohwj> howdy
05:38:59 <fasta> quicksilver: the problem with mallocForeignPtr is that it frees the memory when there are no references to it anymore in Haskell land, AFAIK.
05:39:06 <vixey> hi
05:39:30 <pumpkin> some of these are so trivial with big ints
05:39:39 <Eridius> > showCReal 0 (sqrt 2)
05:39:41 <lambdabot>   "1"
05:39:55 <vixey> > showCReal 0 (0.9999999999999999999999999999999999999)
05:39:56 <lambdabot>   "1"
05:40:01 <vixey> > showCReal 2 (0.9999999999999999999999999999999999999)
05:40:03 <lambdabot>   "1.0"
05:40:52 <Eridius> > sum . map digitToInt . showCReal 0 $ (sqrt 2) * 100
05:40:53 <lambdabot>   6
05:41:02 <Eridius> o_O
05:41:14 <Eridius> > showCReal 0 $ (sqrt 2) * 100
05:41:15 <lambdabot>   "141"
05:41:19 <Cale> > showCReal 50 (exp (pi * sqrt 163))
05:41:20 <Eridius> O_o
05:41:21 <lambdabot>   "262537412640768743.99999999999925007259719818568887935385633733699086"
05:41:32 <Eridius> > showCReal 10 $ (sqrt 2) * 100
05:41:34 <lambdabot>   "141.4213562373"
05:41:40 <Deewiant> > sum . map digitToInt . showCReal 0 $ (sqrt 2) * 10^100
05:41:41 <lambdabot>   482
05:41:48 <Cale> > showCReal 15 (exp (pi * sqrt 163))
05:41:49 <lambdabot>   "262537412640768743.99999999999925"
05:41:51 <Eridius> oh durrr
05:41:52 <Cale> > showCReal 10 (exp (pi * sqrt 163))
05:41:54 <lambdabot>   "262537412640768744.0"
05:41:59 <Cale> :)
05:42:11 <Eridius> > sum . map digitToInt . showCReal 0 $ (sqrt 2) * (10 ** 100)
05:42:13 <lambdabot>   482
05:42:15 <Cale> > exp (pi * sqrt 163)
05:42:16 <lambdabot>   2.6253741264076826e17
05:42:20 <Eridius> oops, I forgot the take 100
05:42:24 <Eridius> > sum . map digitToInt . take 100 . showCReal 0 $ (sqrt 2) * (10 ** 100)
05:42:26 <lambdabot>   475
05:42:28 <Eridius> yay
05:42:29 <pumpkin> , subsequences [1,2,3,4]
05:42:30 <Eridius> no rounding errors
05:42:37 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[...
05:42:48 <PeakerWork> @src subsequences
05:42:49 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:42:50 <vixey> > showCReal maxBound 1
05:42:51 <lambdabot>   "* Exception: Negative exponent
05:42:54 <PeakerWork> ,src subsequences
05:42:55 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
05:43:13 <kohwj> is it possible to use the FFI to use C libraries such as Loudmouth?
05:43:14 <SamB_XP> :t showCReal
05:43:15 <lambdabot> Int -> CReal -> String
05:43:25 <SamB_XP> kohwj: what's special about loadmouth ?
05:43:48 <SamB_XP> er. loudmouth
05:44:03 <Eridius> hrm, showCReal 0 might still round
05:44:26 <Eridius> > sum . map digitToInt . take 100 . showCReal 0 . truncate $ (sqrt 2) * (10 ** 100)
05:44:27 <lambdabot>       No instance for (Integral CReal)
05:44:27 <lambdabot>        arising from a use of `truncate...
05:44:37 <vixey> , (subsequences . subsequences . subsequences) [[]]
05:44:38 <Eridius> ah, hrm
05:44:39 <lunabot>  [[],[[]],[[[]]],[[],[[]]],[[[[]]]],[[],[[[]]]],[[[]],[[[]]]],[[],[[]],[[[...
05:44:58 <SamB_XP> vixey: ah my eyes!
05:45:02 <Eridius> uh, wow. cabal: memory allocation failed (requested 2097152 bytes)
05:45:21 <kohwj> SamB_XP: i'm just looking into the possibility of using any C library via haskell
05:45:28 <SamB_XP> Eridius: I guess you ran out of either RAM or address space ?
05:45:29 <Eridius> no wonder my machine practically died. it threw *everything* into swap
05:45:45 <Eridius> it just asked for 2GB of RAM. I think it ran out of address space
05:45:47 <SamB_XP> kohwj: should be fine!
05:45:59 <SamB_XP> Eridius: that looks like 2 megs to me
05:46:06 <kohwj> SamB_XP: cool! thanks!
05:46:16 <Deewiant> SamB_XP: it typically doesn't ask for it all at once :-P
05:46:28 <Eridius> SamB_XP: err, yeah, that allocation was 2 megs. Means it probably asked for *4* gigs before that ;)
05:46:37 <Eridius> since *everything* was in swap
05:46:44 <Eridius> thank you cabal!
05:46:46 <SamB_XP> Eridius: you use 64-bit ?
05:46:51 <Eridius> all it was doing was resolving dependencies for numbers
05:47:01 <Eridius> I am on a 64-bit machine but I doubt cabal is compield as 64-bit
05:47:05 <Eridius> *compiled
05:47:11 <kohwj> SamB_XP: i'm thinking of writing a jabber client in haskell, and the only haskell library for xmpp doesn't support TLS, so i'm thinking of using a C library for that.
05:47:12 <Deewiant> Eridius: what version of cabal?
05:47:19 <Eridius> yeah, cabal is compiled 32-bit
05:47:33 <Eridius> Deewiant: dunno, haven't touched it in a while. I know I upgraded ghc after I last touched cabal
05:47:48 <Eridius> cabal-install version 0.5.2
05:47:48 <Eridius> using version 1.4.0.2 of the Cabal library
05:47:50 <fasta> quicksilver: ok, I was wrong.
05:47:51 <Deewiant> Eridius: you probably need to upgrade cabal, that sounds like a fixed known bug.
05:47:55 <Deewiant> Eridius: yes, definitely.
05:48:04 <Eridius> can cabal update itself?
05:48:05 <Deewiant> Eridius: get 0.6.
05:48:11 <Deewiant> On Linux, I think so.
05:48:43 <Eridius> maybe I should just delete my cabal installation and start over
05:48:48 <Eridius> I haven't actually played with Haskell in a while
05:50:45 <Eridius> I seem to recall running across a script at some point that installed cabals dependencies in a temp dir, installed cabal, then reinstalled the deps via cabal itself and blew away the local install. anybody know what I'm talking about?
05:51:11 <vixey> sounds like boot.sh
05:51:19 <ToRA|MSR> http://ghcmutterings.wordpress.com/2008/11/10/bootstrapping-cabal-install/
05:51:21 <ToRA|MSR> ?
05:51:40 <Eridius> ToRA|MSR: yes, I think that's it
05:51:41 <Eridius> thanks
05:59:31 <pejo> Does research.microsoft.com give anyone else "This service is unavailable" right now?
05:59:50 <byorgey> pejo: yup, I get that too
05:59:54 <pumpkin> yup
06:08:25 <pumpkin> is there a good haskell library with "modern" prime code? generating them, factoring, and so on?
06:09:54 * osfameron pimps haskell to a perl ML: http://london.pm.org/pipermail/london.pm/Week-of-Mon-20081215/016093.html
06:10:02 <osfameron> (though my haskell solution is rubbish: any suggestions?)
06:11:19 <pumpkin> is there anything that behaves like filter (not . null) . concatMap tails . inits but has a name?
06:11:47 <fasta> It seems that castStablePtrToPtr is a completely redundant function in the FFI, since it doesn't actually guarantee anything: Coerce a stable pointer to an address. No guarantees are made about the resulting value,
06:11:47 <fasta> except that the original stable pointer can be recovered by castPtrToStablePtr. In partic-
06:11:47 <fasta> ular, the address may not refer to an accessible memory location and any attempt to pass it
06:11:47 <fasta> to the member functions of the class Storable (Section 5.7) leads to undefined behaviour.
06:12:06 <byorgey> > filter (not.null) . concatMap tails . inits $ [1,2,3,4]
06:12:07 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
06:12:41 <byorgey> pumpkin: not that I know of.
06:12:49 <byorgey> if there was it should be called 'sublists', I guess.
06:12:54 <pumpkin> yeah
06:13:00 <pumpkin> @hoogle sublists
06:13:00 <lambdabot> No results found
06:13:03 <pumpkin> :(
06:13:24 <pumpkin> is there an everyNth function?
06:13:31 <pumpkin> @hoogle Int -> [a] -> [a]
06:13:32 <vixey> yeah
06:13:32 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:13:32 <lambdabot> Prelude take :: Int -> [a] -> [a]
06:13:32 <lambdabot> Data.List drop :: Int -> [a] -> [a]
06:13:34 <vixey> map head . chunk n
06:13:54 <pumpkin> @hoogle chunk
06:13:55 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
06:13:55 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
06:13:55 <lambdabot> Data.ByteString.Lazy.Internal chunkOverhead :: Int
06:14:04 <Eridius> hrm, pumpkin, I'm running into a problem solving euler problem 80. Or rather, I have an answer, but it seems to be incorrect, and I don't know why
06:14:07 <pumpkin> what if I just have a list?
06:14:13 <vixey> chunk works on lists
06:14:31 <vixey> @go Data.List.Split
06:14:33 <lambdabot> http://haskell.org/haskellwiki/Data.List.Split
06:14:33 <lambdabot> Title: Data.List.Split - HaskellWiki
06:14:34 <vixey> oops
06:14:39 <vixey> I meant to @wiki
06:15:22 <pumpkin> Eridius: it's finicky... I got an answer but have since lost my code, might be able to give a hint though if you tell me what you did (maybe in pm)
06:15:47 <byorgey> pumpkin: soon, there will be a Data.List.Split module on hackage with that function included in it =)
06:16:28 <pumpkin> byorgey: :(
06:16:57 <byorgey> pumpkin: in the meantime, it's not hard to write yourself using splitAt
06:17:53 <vixey> I added a new version of split
06:22:27 <BeelsebobWork> lilac: do you know of any other bugs in snapshotWith btw?
06:22:47 <BeelsebobWork> just checking, because I appear to be zeroing in on an issue with it, and I'm not wanting to duplicate work
06:26:17 <byorgey> vixey: is that faster?
06:26:30 <byorgey> or just more obfuscated? ;)
06:26:49 <pumpkin> @pl unfoldr (\x -> let y = splitAt 2 $ x in if null . snd $ y then Nothing else Just y) [1..10]
06:26:49 <lambdabot> unfoldr (ap (flip if' Nothing . null . snd) Just . fix . const . splitAt 2) [1..10]
06:26:58 <xhanjian> @src append
06:26:59 <lambdabot> Source not found. I am sorry.
06:27:03 <byorgey> anyway, I think I've got a nice elegant combinator version that can do everything that's posted on that page currently
06:27:08 <xhanjian> @src ++
06:27:09 <lambdabot> []     ++ ys = ys
06:27:09 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
06:27:09 <lambdabot> -- OR
06:27:09 <lambdabot> xs ++ ys = foldr (:) ys xs
06:27:11 <vixey> byorgey, both!
06:27:13 <byorgey> well, except the chunk stuff is separate
06:27:19 <byorgey> vixey: heh, nice =)
06:27:43 <byorgey> I just need to add a bit more documentation and then I'll upload it, hopefully in the next couple days
06:27:44 <vixey> cool I want to see this combinator stuff
06:28:11 <byorgey> you can write things like   split (dropDelims . condense $ whenElt (<0))
06:28:20 <Badger> !wn obsoletion
06:28:29 <Badger> errr
06:28:32 <Badger> @wn obsoletion
06:28:33 <lambdabot> No match for "obsoletion".
06:29:09 <byorgey> vixey: hang on a sec, I will push out the repo
06:29:15 <Deewiant> Badger: obsolescence
06:31:08 <byorgey> vixey: darcs get http://code.haskell.org/~byorgey/code/split
06:31:43 <vixey> byorgey, did you write free theorems?
06:32:13 <byorgey> vixey: I know what a free theorem is but not sure how it would apply in this case.  can you give an example?
06:32:20 <vixey> I mean @free
06:32:27 <Eridius> huh, how do you easily access the 3rd element in a tuple?
06:32:53 <vixey> Eridius, pattern match on it or use a function
06:33:02 <byorgey> vixey: I'll have to think about that.  I do plan to write a large number of QuickCheck properties, which isn't quite the same of course, but similar
06:33:08 <Axman6> (\(_,_,x) -> x)
06:33:10 <Eridius> yeah, I meant function-wise. there's no equivalent to fst/snd for third
06:33:16 <Eridius> hrm, Axman6, that'll work
06:33:20 <vixey> byorgey, I meant did you wrote this actual @free library.. :p I guess not
06:33:43 <byorgey> vixey: oh!! I though you were asking if I had written any free theorems for my splitting combinator library =)
06:33:46 <byorgey> vixey: no, I didn't
06:33:54 <vixey> ok just wonderng
06:34:57 <byorgey> vixey: and btw, with this combinator library,  unintercalate = split . dropFinalBlank . onSublist  =)
06:35:39 * byorgey runs off to school
06:36:03 <vixey> byorgey, yes but I think  unintercalate x (intercalate x l) == l  is not true
06:36:17 <byorgey> oh, no?
06:36:33 <vixey> if l contained some 'x' already
06:37:04 <vixey> > intercalate "x" ["<x>","<y>"]
06:37:06 <lambdabot>   "<x>x<y>"
06:37:11 <byorgey> ah, you're right
06:37:19 <byorgey> QuickCheck agrees with you =)
06:37:21 <vixey> but I like that you write "inverse" in scare quotes :p
06:37:36 <byorgey> I'll have to think harder about what the correct property is
06:37:42 <vixey> just l not containing any x
06:37:47 <vixey> as a precondition
06:37:51 <byorgey> sure, seems like that ought to work
06:38:09 <vixey> or
06:38:09 <byorgey> I just wrote various things I thought should hold in the comments without checking them, because I'm going to write QuickCheck properties later =)
06:38:17 <vixey> unintercalate x (intercalate x (unintercalate x (intercalate x l))) == unintercalate x (intercalate x l)
06:38:23 <vixey> I think this is a theorem
06:38:31 <vixey> ugly one though :p
06:39:02 <byorgey> well, to make it les ugly, you could just say  'unintercalate x . intercalate x  is idempotent'
06:39:04 <vixey> sorry am I making you late
06:39:15 <byorgey> that's ok, I'm not late quite yet
06:39:20 <vixey> hehe
06:39:21 <byorgey> but I should go =)
06:39:25 <byorgey> see you later
06:39:34 <vixey> bye
06:42:02 <BeelsebobWork> ahhh! joinMaybes isn't lazy enough
06:42:24 <Eridius> how do you report bugs in packages?
06:42:35 <vixey> :t joinMaybes
06:42:36 <lambdabot> Not in scope: `joinMaybes'
06:43:15 <vixey> http://conal.net/blog/posts/a-handy-generalized-filter/
06:43:28 <Deewiant> Eridius: depends on the package
06:43:58 <vixey> BeelsebobWork, this one? why not?
06:44:17 <BeelsebobWork> vixey: yes, that one, and because it causes a bug in snapshotWith -- although I'm not certain exactly why yet
06:44:17 <Eridius> Deewiant: numbers
06:44:17 <quicksilver> BeelsebobWork: the problem with my joinMaybes is that any work done discarding Nothings is wasted.
06:44:22 <Eridius> there's a bug in truncate for CReal
06:44:35 <quicksilver> BeelsebobWork: until the first Just comes along, you end up repeating a lot of work.
06:44:37 <BeelsebobWork> quicksilver: it's also causing this bug... http://hpaste.org/13096
06:45:00 <BeelsebobWork> (note that the value of the reactive changes at 3.0, but the value of the snapshot has not
06:45:04 * quicksilver nods
06:45:15 <Deewiant> Eridius: well, it's not a standard package, so if it has a homepage take a look if there's anything about bug reporting there, and if not, mail the maintainer
06:45:25 <BeelsebobWork> the undefined there is a Imp undefined (const LT)
06:45:33 <BeelsebobWork> i.e. an event that hasn't yet occured
06:45:43 <Eridius> Deewiant: I don't see any contact info on the hackage page for numbers, just a name (Lennart Augustsson)
06:46:21 <Deewiant> Eridius: have you heard of Google? It's really handy, type a person's name and their homepage will generally come up first
06:46:22 <Eridius> hrm, I wonder if that's the same Lennart Augustsson as http://en.wikipedia.org/wiki/Lennart_Augustsson
06:46:37 <Eridius> Deewiant: honestly, I didn't expect that to work.
06:47:00 <Deewiant> Eridius: append 'haskell' or some such and it works 100% of the time, if there is a homepage.
06:47:05 <orbitz> even i'm on google
06:47:34 <Eridius> Deewiant: hmm, maybe the haskell community is just more prone to having package authors being discoverable on google?
06:48:08 <Deewiant> Maybe, though it's only very rarely that I've /not/ found someone's contact information on Google, if I needed to contact them
06:54:47 <Eridius> Deewiant: I suppose Haskell is still esoteric enough that most people who work with it will list that somewhere on their homepage, but in other languages, finding a homepage for a man that shares the same name as a library author does not guarantee him to be the same person
06:55:43 <quicksilver> If someone writes haskell, it is very likely they are the most interesting person in the world with that name.
06:55:51 <byorgey> Eridius: well, in this case, that's the same Lennart Augustsson. =)
06:55:53 <quicksilver> Therefore it is likely google will return stuff about them :)
06:55:55 <PeakerWork> quicksilver: hehe
06:56:05 <Eridius> byorgey: I figured as such after looking at the homepage
06:56:06 <byorgey> Eridius: he also hangs out in here as augustss .
06:56:11 <Eridius> I see
06:56:16 <Eridius> augustss: if you're around, I just sent you an email
06:56:39 <Deewiant> Eridius: But typically, their homepage will indicate whether or not it is the same person, so you can find the right one fairly easily.
06:57:28 <Deewiant> Or then you can find an RCS commit log where you can see his email address and then compare that to his web page's address... etc.
06:58:24 <Eridius> ack, I just discovered my Thawte Freemail certificate expired 6 months ago!
06:58:41 <Eridius> not that it's particularly relevant...
07:00:15 <rgr_> I have set up a WS where I stick floats. But some wont resize (e.g amarok) with the mouse despite mouseResize and windowArrange modifiers being there. Also some wont change Z-order. e.g Gimp is always on top. Why is this and what can you suggest?
07:03:56 <BeelsebobWork> hmm, is there any method of creating a pattern match which will match, but not force evaluation -- i.e. if it happens to have been evaluated already and matches this, then match, otherwise, don't hang about here waiting for it to match
07:04:35 <Deewiant> > let f ~(x,y) = 1; g (x,y) = 1 in (f undefined, g undefined)
07:04:37 <lambdabot>   (1,* Exception: Prelude.undefined
07:05:34 <BeelsebobWork> yeh -- but that matches whether it's true or not
07:05:48 <BeelsebobWork> > let f ~(x,y) = 1 in f 92
07:05:50 <lambdabot>       No instance for (Num (t, t1))
07:05:50 <lambdabot>        arising from the literal `92' at <...
07:05:57 <BeelsebobWork> oh, woops
07:06:06 <BeelsebobWork> > let f ~(Left x) = 1 in f (Right 5)
07:06:08 <lambdabot>   1
07:06:24 <Surma> hey guys. My Prof is using a lmacro and longmacro directive in his programs and I can find an explanation for that command anywhere (not a single hit @google). You got any links?
07:06:26 <BeelsebobWork> I want it to *only* match if it happens to have been evaluated, and matches the pattern
07:06:28 <Deewiant> well yeah, but how can you check the input constructor without... actually checking it? :-P
07:06:36 <Deewiant> sounds low-level
07:06:38 <BeelsebobWork> I want to ask "has it been evaluated yet"
07:06:41 <Deewiant> might be possible, I don't know
07:06:43 <Deewiant> I doubt it
07:06:47 <BeelsebobWork> if it hasn't move onto other patterns
07:07:09 <BeelsebobWork> I can do it with unamb -- but that means spawning threads, and it sounds like it should be more efficient than that
07:10:38 <Axman6> Surma: never heard or anything like that. got an example?
07:10:56 <Surma> jup, his code looks like this:
07:11:18 <Surma> lmacro "PA1"="Blablabla{PA2}""
07:11:18 <Surma> lmacro "PA2"="foo"
07:11:37 <Surma> so when he passes "{PA1}" to a function, it turns out to be "Blablablafoo"
07:11:39 <Surma> just like macros
07:11:48 <Axman6> o.O
07:12:18 <Surma> haskell isn't compailing about using lmacro or longmacro, however, it only gives me "{PA1}" as a result instead of the replacements
07:12:22 <Axman6> >_<
07:12:46 <Surma> yeah, I know, it's weird - I can't find anything anywhere. But how can Haskell NOT complain about a directive and not have it documented somewhere
07:12:52 <Axman6> Surma: yeah well as far as i know, there is nothing like that in haskell. need to use template haskell to do something like that
07:13:01 <Deewiant> Surma: it parses as a function definition
07:13:12 <Deewiant> > let lmacro "PA2" = "foo" in lmacro "PA2"
07:13:13 <lambdabot>   "foo"
07:13:15 <Deewiant> > let lmacro "PA2" = "foo" in lmacro "PA3"
07:13:17 <lambdabot>   "* Exception: /tmp/1675926169989186016:71:44-63: Non-exhaustive patterns in...
07:14:04 <Deewiant> Surma: what kinds of functions is he passing those to which do the replacement?
07:15:37 <Surma> Deewiant: I don't actually know - we're supposed to write that ourselves, but I can't even get that stuff to work - I guess I'll have to find another way. he probably implemented that himself somehow
07:15:49 <Deewiant> ah :-)
07:16:20 <Deewiant> Surma: so basically what you need to do is write a function which looks for "{foo}" in a string and then replaces that with lmacro "foo"
07:16:25 <Deewiant> No black magic here :-)
07:17:38 <Surma> Deewiant: I know, but I thought Haskell already had something like that - makes lambda calculus a lot simpler ;)
07:18:08 <kpreid> lmacro as given is just a function defining a table of replacements
07:18:46 <vixey>  lambda calculus ??
07:18:50 <kpreid> so you need to write the code which matches {...} and substitutes lmacro...
07:20:38 <xhanjian> @src groupBy
07:20:38 <lambdabot> groupBy _  []       =  []
07:20:38 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
07:20:38 <lambdabot>     where (ys,zs) = span (eq x) xs
07:23:04 <pumpkin> whee, I just got euler 206
07:23:08 <pumpkin> my highest number yet
07:23:31 <vixey> class Vertex {
07:23:37 <vixey> protected:
07:23:38 <vixey>     string name;
07:23:38 <vixey>     dList<Edge *> edges;
07:23:52 <vixey> ... it just goes on like that
07:23:53 <vixey> for pages
07:24:06 <vixey> string getName() { return name; }
07:24:41 <Axman6> pumpkin: yeah i got that one a while ago, it was fun :)
07:24:49 <pumpkin> :)
07:25:06 <pumpkin> my original one was ridiculous, ate up 1.6 gigs of my RAM and made the computer unusuable
07:25:13 <pumpkin> and hung like that
07:25:26 <pumpkin> this one took under a minute and used a constant 25 megs of ram :D
07:25:36 <Axman6> lol, yeah i've done that many times :)
07:27:32 <Axman6> mine's running in 1.5MB :)
07:27:47 <Axman6> and looking back at it, it's a pathetic algorithm :P
07:27:52 <pumpkin> :P
07:27:57 <pumpkin> how long did it take?
07:28:07 <pumpkin> I've been making the mistake of doing it all in ghci so far
07:28:11 <Axman6> still running...
07:28:13 <pumpkin> which means I don't have much to look back on
07:28:20 <Axman6> checkNumber num
07:28:21 <Axman6>     | length numText /= 19 = False
07:28:21 <Axman6>     | otherwise = ans == ['1','2','3','4','5','6','7','8','9','0']
07:28:21 <Axman6>         where numText = show num
07:28:23 <Axman6>               (a:a':b:b':c:c':d:d':e:e':f:f':g:g':h:h':i:i':j:j') = numText
07:28:25 <Axman6>               ans = [a,b,c,d,e,f,g,h,i,j]
07:28:28 <Axman6> bahaha... :(
07:28:50 <pumpkin> oh my :)
07:29:11 <Axman6> i'm timing its run...
07:29:46 <Botje> Axman6: you awful awful man :P
07:30:06 <Axman6> i know i know
07:30:12 <Axman6> > length [1010101010..1389026624]
07:30:15 <pumpkin> http://projecteuler.net/index.php?section=problems&id=125 looks easy, but it isn't accepting my answer and I'm tired
07:30:20 <Axman6> wait...
07:30:26 <lambdabot>   378925615
07:30:26 <pumpkin> Axman6: you could subtract the endpoints ;)
07:30:27 <Deewiant> > 1389026624-1010101010+1
07:30:29 <lambdabot>   378925615
07:30:42 <Axman6> yes -_- just realised that after pasting it
07:30:49 <pumpkin> that's a pretty epic search space
07:31:15 <Deewiant> nah, that's tiny, that's less than 10^9
07:31:27 <pumpkin> yeah :P
07:31:33 <pumpkin> but it's not something I want to wait around for
07:32:08 <Axman6> still running in 1.5MB
07:32:15 <Axman6> so... beat ya there :P
07:32:16 <pumpkin> project euler should give you the option of ghci as a "language"
07:32:58 <Axman6> > ['1','2','3','4','5','6','7','8','9','0'] -- now that's just terrible, come to think of it
07:33:00 <lambdabot>   "1234567890"
07:33:22 * pumpkin bludgeons Axman6
07:33:52 <Axman6> > (length . show $ ['1','2','3','4','5','6','7','8','9','0'])
07:33:53 <lambdabot>   12
07:34:10 <pumpkin> why show?
07:34:15 <Axman6> > (length "['1','2','3','4','5','6','7','8','9','0']")
07:34:17 <lambdabot>   41
07:34:25 <Axman6> because i'm totally on the ball tonight
07:34:29 <pumpkin> lol
07:35:01 <Axman6> i'm pretty impressed that i types out "(a:a':b:b':c:c':d:d':e:e':f:f':g:g':h:h':i:i':j:j') = numText" though
07:38:24 <Axman6> gotta love it when your answer is as simple as: answer = take 10 $ show (sum nums)
07:38:44 <Axman6> aka take 10 . show . sum $ nums
07:39:19 <Axman6> pumpkin: 12m28.133s it took to finish :P
07:39:25 <vixey> does anyone have names for X and Y in  X < Y ?
07:39:26 <pumpkin> nice :P
07:39:53 <Botje> vixey: first and second argument? :P
07:40:04 <PeakerWork> which XML library is easiest to work with? Text.XML.Light returns a [Content] from an XML, but then has no useful functions to work with [Content]
07:40:41 <Axman6> @check (\n -> (n `rem` 2 == 0) == even n)
07:40:43 <lambdabot>   "OK, passed 500 tests."
07:43:01 <Axman6> hmm, my solution for 14 could be a lot better...
07:46:55 <Axman6> :t (compare`on`snd)
07:46:56 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
07:47:11 <Axman6> :t maximumBy
07:47:12 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
07:47:32 <BeelsebobWork> @type on
07:47:34 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:47:40 <xhanjian> @src cycle
07:47:41 <BeelsebobWork> ah, yeh
07:47:41 <lambdabot> cycle [] = undefined
07:47:41 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:48:00 <BeelsebobWork> shame that can't be made to have Ord b => (a,b) -> (c,b) -> Ordering
07:48:05 <BeelsebobWork> without making it ugly
07:48:39 <Axman6> @djinn Ord b => (a,b) -> (c,b) -> Ordering
07:48:40 <lambdabot> Error: Undefined type Ordering
07:48:43 <Axman6> shame :(
07:49:33 <Axman6> @index on
07:49:33 <lambdabot> bzzt
07:49:39 <Axman6> @hoogle on
07:49:40 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:49:40 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
07:49:40 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
07:49:48 <pumpkin> Axman6: that was a cute one, I used iterate :D
08:02:26 <Axman6> pumpkin: i was using some list implementations (i often write a few different versions when i think of sa better way). just finished a version that runs in constant space i think
08:02:46 <pumpkin> cool
08:02:55 <pumpkin> I'm working on http://projecteuler.net/index.php?section=problems&id=132 now
08:03:17 <vininim> oh my... is SVM implemented naively really supposed to be this slow?
08:04:14 <Axman6> SVM?
08:04:20 <pumpkin> support vector machine?
08:04:39 <vininim> yes, but wrong channel :X
08:05:44 <vininim> (or not, I guess I might try it in haskell sometime)
08:09:42 <Saizan_> gitit is 1.5klocs over 3 files..
08:12:37 <hugo___> how do i make optional arguments with haskell ? i've read about this using the record syntax, but it doesn't seem very elegant
08:12:56 <hugo___> im reading about them in this link: http://okmij.org/ftp/Haskell/types.html#keyword-args
08:13:04 <Beelsebob> hugo___: you *probably* don't want to make optional arguments -- what is it you're trying to do?
08:13:10 <dons> ?users
08:13:10 <lambdabot> Maximum users seen in #haskell: 586, currently: 541 (92.3%), active: 20 (3.7%)
08:13:36 <hugo___> Beelsebob, im using the help code you gave me, and i was planning in adding possible attributes for the html div generator...
08:13:41 <hugo___> like id, class, style, etc...
08:14:08 <hugo___> so i would just need to pass a String, without having to construct the attribute list outside the div generator function
08:14:10 <chrisdone> hmm
08:14:45 <chrisdone> can I use existentials this way? also, overlapping instances? what does this mean? http://hpaste.org/13098
08:14:46 <Beelsebob> hugo___: how about div :: [Attributes] -> [HTML] -> HTML; div = T "div"
08:14:54 <Beelsebob> (just pass a list of the attributes you want)
08:15:01 <chrisdone>       instance SQLValue [Char] -- Defined at Store.hs:76:9-23
08:15:02 <chrisdone>       instance (Num a) => SQLValue a -- Defined at Store.hs:86:9-27
08:15:10 <chrisdone> a [Char] is not an instance of Num, so what is the overlap?
08:15:23 <quicksilver> chrisdone: [Char] is an instance of Num
08:15:28 <quicksilver> chrisdone: I just wrote an instance, over here.
08:15:35 <Axman6> @instances Num
08:15:36 <lambdabot> Double, Float, Int, Integer
08:15:37 <chrisdone> look at the error!
08:15:37 <quicksilver> chrisdone: (instances are open, is the point)
08:15:39 <chrisdone>  No instance for (Num [Char])
08:15:44 <chrisdone> oh
08:15:59 <quicksilver> instance Num a => SQLValue a reads as follows:
08:16:04 <quicksilver> ALL TYPES a are instances of SQLValue
08:16:11 <quicksilver> (Oh, and add a num constraint please)
08:16:22 <quicksilver> as such, it overlaps with every possible other instance.
08:16:44 <chrisdone> hrm
08:16:59 <quicksilver> this is the most commonly dicussed part of haskell's instance selection process :)
08:17:14 <quicksilver> you can play with overlapping and possibly incoherent instances to get the behviour you want
08:17:18 <hugo___> Beelsebob, i wanted to avoid having to build the attributes list outside the function... but okey
08:17:29 <quicksilver> the price you pay is loss of monotonicity, composability, and your mortal soul.
08:17:31 <quicksilver> ;)
08:17:46 <chrisdone> well, that doesn't sound very good
08:17:49 <chrisdone> what's the alternative?
08:18:20 <chrisdone> define an instance of SQLValue just for numbers that I'm going to use?
08:18:22 <quicksilver> don't write that Num instance? Or wrap it in a newtype?
08:19:05 <chrisdone> what would I wrap in a newtype?
08:19:25 <hugo___> i feel like i was drugged with imperative programming, and now im in rehab
08:19:28 <Beelsebob> hugo___: you could create type HTMLTagger = ([Attribute] -> [HTML] -> HTM); htmlID :: HTMLTagger -> HTMLTagger; htmlID id f as es = f (("id" :=: id) : as) es
08:19:58 <Beelsebob> i.e. - something that modifies *any* function that wraps html elems in a tag, and gives it an additional id attribute
08:20:14 <quicksilver> chrisdone: the nums when you wante dto use them as SQLValues
08:20:21 <Beelsebob> htmlID "jam" (div [] [stuff]) -- called like this
08:20:23 <quicksilver> data WNum a = WNum a
08:20:32 <quicksilver> instance (Num a) => SQLValue (WNum a)
08:20:36 <hugo___> hmm i see
08:20:38 <quicksilver> ^^ now it doesn't overlap
08:20:41 <Axman6> @quote-add hugo < hugo___> i feel like i was drugged with imperative programming, and now im in rehab
08:20:42 <lambdabot> Unknown command, try @list
08:20:59 <Axman6> quicksilver: you know how to add quotes right?
08:21:25 <Beelsebob> hugo___: oh, called without the parens I put in
08:21:31 <Beelsebob> does that satisfy you?
08:21:42 <hugo___> that is very nice
08:21:45 <chrisdone> quicksilver: ohh, I see
08:21:45 <Beelsebob> :)
08:21:47 <hugo___> :)
08:21:50 <quicksilver> Axman6: @remember name quote
08:21:58 <chrisdone> quicksilver: newtype as opposed to data?
08:22:03 <Axman6> @remember hugo < hugo___> i feel like i was drugged with imperative programming, and now im in rehab
08:22:03 <lambdabot> Done.
08:22:06 <quicksilver> chrisdone: sure, yes, that's what I meant really
08:22:09 <Axman6> @quote hugo
08:22:10 <lambdabot> hugo says: < hugo___> i feel like i was drugged with imperative programming, and now im in rehab
08:22:10 <quicksilver> (although either works fine)
08:22:12 <chrisdone> sure
08:22:13 <hugo___> oh
08:22:22 <chrisdone> quicksilver: good idea, thanks for that
08:22:25 <Saizan_> @forget hugo < hugo___> i feel like i was drugged with imperative programming, and now im in rehab
08:22:25 <lambdabot> Done.
08:22:32 <hugo___> lambdabot is quoting my dumb assertions...
08:22:36 <Saizan_> @remember hugo i feel like i was drugged with imperative programming, and now im in rehab
08:22:36 <lambdabot> I will remember.
08:22:47 <Saizan_> @quote hugo
08:22:47 <lambdabot> hugo says: i feel like i was drugged with imperative programming, and now im in rehab
08:22:51 <Axman6> thanks Saizan_
08:22:52 <Saizan_> nicer :)
08:23:16 <Axman6> i do wish GHC Core names were nicer
08:23:35 <Botje> search and replace is your friend
08:24:52 <quicksilver> Axman6: tried dons' ghc-core package?
08:25:06 <Axman6> yeah, i am, but the names are still difficult to follow
08:25:22 * quicksilver nods
08:25:30 <Axman6> case w_sVm of w2_XVA { I# ww_sVo ->
08:25:42 <Saizan_> eh, yeah
08:26:27 <Saizan_> getting the Core AST from the ghc-api and renaming the variables shouldn't be so hard though
08:27:47 <Axman6> i was looking for mmorrow, because he's just done something similar with lunabot for TH output
08:28:07 <Axman6> , [$ty|(>>=)|]
08:28:09 <Saizan_> but giving sequential names as in @djinn is not very readable either
08:28:17 <lunabot>  forall a b c . Monad c => (c b) -> (b -> c a) -> c a
08:28:44 <pumpkin> , [$ty|map|]
08:28:46 <ToRA|MSR> don't forget that the ghc core names are namespaced, so the prefix does indicate something about what the variable is or where it came from
08:28:50 <lunabot>  forall a b . (b -> a) -> ([] b) -> [] a
08:28:54 <pumpkin> ooh he fixed it
08:29:01 <pumpkin> except for the list syntactic sugar
08:29:05 <Axman6> yup :)
08:29:13 * pumpkin wants his sugar
08:29:33 <Axman6> aye
08:32:05 <Axman6> think it's reasonable that i might be able to understand the assembly output in ghc-core after the comp course i;m doing this semester which covers C and assembly?
08:32:39 <Saizan_> if it covers x86 assembly..
08:32:42 <Saizan_> maybe
08:32:45 <pumpkin> I'm not sure what the generated code looks like, but you'll certainly understand the individual instructions (more or less, depending on the arch you cover)
08:32:46 <Axman6> i think it does
08:32:48 <Raevel> blast! my rwh was delayed
08:33:10 <Axman6> i haven't heard a word about my RWH yet :(
08:33:27 <Raevel> hopefully they can send it to another address, cause i'm going away for three weeks on friday
08:33:30 * pumpkin pats his RWH
08:34:04 <Saizan_> ToRA|MSR: ah, is there a legend for that?
08:34:12 <SubStack> Axman6: except for the part where hello world is 366k
08:34:47 <Axman6> SubStack: in asm?
08:35:11 <ToRA|MSR> Saizan_: not as far as i know
08:35:25 <Axman6> i'm so glad i ordered RWH in advance when i did, cost 	Estimated Arrival	Current Status	
08:35:31 <Axman6> uh...
08:35:33 <SubStack> that's a lot of instructions to read anyways
08:35:43 <Axman6> $54.54AU
08:36:05 <Axman6> now they're charging $138.99AU (!)
08:36:19 <Axman6> jesus, i lucked out hardcore
08:37:47 <SubStack> > map (* 0.6651) [54.54, 138.99]
08:37:49 <lambdabot>   [36.274554,92.442249]
08:39:23 <Axman6> :t fmap ?f (a,b)
08:39:25 <lambdabot> forall b. (?f::Expr -> b) => (Expr, b)
08:39:56 <Axman6> > fmap (+1) (2,4)
08:39:57 <lambdabot>   (2,5)
08:40:26 <Axman6> anyway, sleep time. night all
08:42:39 <PeakerWork> > second (+1) (2,4)
08:42:39 <lambdabot>   (2,5)
08:42:41 <PeakerWork> > first (+1) (2,4)
08:42:42 <lambdabot>   (3,4)
08:43:16 <PeakerWork> @type result
08:43:16 <lambdabot> Not in scope: `result'
08:43:24 <PeakerWork> @let result = (.)
08:43:25 <lambdabot>  Defined.
08:43:33 <PeakerWork> @let argument = flip (.)
08:43:34 <lambdabot>  Defined.
08:43:55 <teko> > let uniq (x:xs) = x : uniq (filter (/=x) xs); uniq (x:_); uniq [] = []
08:43:56 <lambdabot>   <no location info>: parse error on input `;'
08:44:23 <PeakerWork> > (second.result) (+1) (const (2, 4)) 5
08:44:24 <lambdabot>   Couldn't match expected type `t1 -> t'
08:44:31 <teko> i cant get my unique function to work
08:44:37 <PeakerWork> @type (second.result) (+1) (const (2, 4))
08:44:38 <lambdabot>     Couldn't match expected type `(d, a -> b)'
08:44:38 <lambdabot>            against inferred type `b1 -> (t, t1)'
08:44:38 <lambdabot>     In the second argument of `(second . result)', namely
08:44:40 <teko> it complains bout the second pattern
08:44:42 <PeakerWork> @type (second.result)
08:44:43 <lambdabot> forall d b c a. (b -> c) -> (d, a -> b) -> (d, a -> c)
08:45:08 <PeakerWork> @type (second.result) (+1)
08:45:09 <lambdabot> forall d b a. (Num b) => (d, a -> b) -> (d, a -> b)
08:45:13 <asgaroth> What would be faster for checking whether a number has more digits than another. length . show or using logarithms?
08:45:37 <teko> > let uniq (x:xs) = x : uniq (filter (/=x) xs); let uniq (x:_); let uniq [] = []
08:45:39 <lambdabot>   <no location info>: parse error on input `;'
08:45:50 <teko> , let uniq (x:xs) = x : uniq (filter (/=x) xs); uniq (x:_); uniq [] = []
08:45:52 <PeakerWork> > snd ((second.result) (+1) (1, const 5)) 1
08:45:52 <lunabot>  luna: parse error on input `;'
08:45:53 <lambdabot>   6
08:46:14 <PeakerWork> @type (result . second)
08:46:15 <lambdabot> forall a b c d. (b -> c) -> (a -> (d, b)) -> a -> (d, c)
08:46:34 <PeakerWork> > (result.second) (+1) (const (2, 4)) 5
08:46:35 <lambdabot>   (2,5)
08:46:53 <PeakerWork> asgaroth: Using logarithms
08:47:10 <PeakerWork> asgaroth: because you don't have to compute each digit, and it doesn't divide many times to compute the logarithm
08:47:56 <asgaroth> PeakerWork: Ok, thanks. The proper way to do it would be floor (log n/log 10) > floor (log m/log 10), right?
08:48:15 <PeakerWork> asgaroth: there's logBase
08:48:23 <asgaroth> PeakerWork: Thanks
08:48:33 <PeakerWork> > logBase 10 999
08:48:35 <lambdabot>   2.9995654882259823
08:48:48 <PeakerWork> @hoogle ceil
08:48:48 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
08:48:59 <PeakerWork> > (ceiling . logBase 10) 999
08:49:01 <lambdabot>   3
08:49:02 <PeakerWork> > (ceiling . logBase 10) 1000
08:49:03 <lambdabot>   3
08:49:15 <PeakerWork> > ((1+) . floor . logBase 10) 1000
08:49:16 <lambdabot>   3
08:49:26 <PeakerWork> > logBase 10 1000
08:49:27 <lambdabot>   2.9999999999999996
08:49:36 <PeakerWork> floating points suck :)
08:49:43 <PeakerWork> > logBase 10 1001
08:49:44 <lambdabot>   3.0004340774793183
08:50:35 <asgaroth> PeakerWork: Ok, that might be the reason my algorithm returns different results when using logarithms instead of length . show
08:50:50 <PeakerWork> @hoogle logBase
08:50:50 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
08:51:33 <PeakerWork> you can probably build something faster than a count-how-many-divisions by base can be done
08:53:07 <asgaroth> PeakerWork: Thanks, length . takeWhile (/=0) . iterate (`quot` 10) should work to get the digit count
08:53:23 <PeakerWork> @type quot
08:53:24 <lambdabot> forall a. (Integral a) => a -> a -> a
08:53:27 <PeakerWork> @src quot
08:53:27 <lambdabot> Source not found. There are some things that I just don't know.
08:53:44 <PeakerWork> > 10 `quot` 3
08:53:45 <lambdabot>   3
08:53:56 <PeakerWork> @type div
08:53:57 <lambdabot> forall a. (Integral a) => a -> a -> a
08:54:05 <PeakerWork> what's the difference between div and quot?
08:54:10 <PeakerWork> > 12 `quot` 3
08:54:11 <lambdabot>   4
08:54:15 <PeakerWork> > 12 `div` 3
08:54:17 <lambdabot>   4
08:54:20 <Deewiant> > (-10) `div` 3
08:54:22 <lambdabot>   -4
08:54:23 <Deewiant> > (-10) `quot` 3
08:54:25 <lambdabot>   -3
08:55:02 <PeakerWork> ah
08:55:04 <teko> , let uniq (x:xs) = x : uniq (filter (/=x) xs); uniq [] = []
08:55:06 <lunabot>  luna: parse error on input `)'
08:55:16 <teko> , let uniq (x:xs) = x : uniq (filter (/=x) xs; uniq [] = []
08:55:18 <lunabot>  luna: parse error on input `;'
08:55:21 <PeakerWork> asgaroth: I think it can be faster than that, with a binary search of the number of digits
08:55:44 <teko> how can i express uniq in terms of foldr ?
08:56:10 <PeakerWork> asgaroth: if performance is important, that is
08:56:18 <PeakerWork> @type uniq
08:56:19 <lambdabot> Not in scope: `uniq'
08:56:28 <vixey> teko, start with uniq = foldr (\x ys -> ...) []
08:56:44 <vixey> teko, 'ys' is the uniq'd list and x is something you might cons onto it
08:56:54 <asgaroth> PeakerWork: No, it's just for a projecteuler exercise and thus it's not any code that'll end up in a real project
08:56:56 <teko> k ta
08:57:16 <vixey> , uniq "aaxa"
08:57:18 <lunabot>  luna: Not in scope: `uniq'
08:57:22 <vixey> > uniq "aaxa"
08:57:23 <lambdabot>   Not in scope: `uniq'
08:57:38 <vixey> should that give "axa" or "ax" or "xa"?
08:57:46 <teko> ax
08:57:55 <asgaroth> strange. the version with length . show actually runs faster than my divide by 10 example.
08:58:50 <teko> @let uniq (x:xs) = x : uniq (filter (/=x) xs; uniq [] = []
08:58:51 <lambdabot>   Parse error
08:59:40 <asgaroth> @src nub
08:59:41 <lambdabot> nub = nubBy (==)
08:59:45 <asgaroth> @src nubBy
08:59:46 <lambdabot> nubBy eq []             =  []
08:59:46 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:09:43 <osfameron> eeeek!  Data.List has intersect, yay!
09:10:07 <osfameron> though it seems to behave oddly with the min/max repeated elements depending on which list they're in
09:10:30 <vixey> it would be good if there was a syntax for sets
09:10:35 <vixey> {1, 2, 3} type stuff
09:10:51 <vixey> but all the operations on it were invariant wrt permutations numbering and stuff
09:10:57 <osfameron> ah, it only contains duplicates from the first list
09:11:09 <ddarius> @src intersect
09:11:09 <lambdabot> intersect = intersectBy (==)
09:11:13 <ddarius> @src intersectBf
09:11:13 <lambdabot> Source not found. My pet ferret can type better than you!
09:11:16 <ddarius> @src intersectBy
09:11:16 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
09:12:03 <osfameron> I was trying to find a better solution for the min(n,m) duplicates problem
09:15:57 <conal> sclv: ping
09:18:33 <osfameron> aha:  let is xs ys = let g=group.sort in [ zipWith const x y | x <- g xs, y <- g ys, head x == head y ]
09:18:45 <osfameron> though I think my first solution was more efficient
09:19:08 <conal> does anyone remember what -fenable-rewrite-rules used to be called and at what version the name changed?
09:19:59 <Deewiant> conal: -frewrite-rules
09:20:08 <Deewiant> conal: and it's in the changelog for 6.10.1
09:20:23 <conal> Deewiant: thx!
09:22:55 <conal> @tell sclv would you please try http://hpaste.org/13099#a1 as a replacement header for Data.Zip and let me know if it works for you?
09:22:55 <lambdabot> Consider it noted.
09:36:13 <Clockwork> Hey guys, I want to filter a list of strings ["x","a","a","y", ...] for all letters which are double, triple, and so on
09:36:28 <Clockwork> I don't get a clue for the boolean part of filter to get this
09:36:43 <osfameron> Clockwork: look at group and sort
09:36:45 <pjdelport> Clockwork: define "double, triple, and so on"
09:38:00 <Clockwork> x , x , x is triple
09:38:23 <Clockwork> so x , b, z , a, x , x ,d = bad it should be x, b, z, a, d
09:38:36 <int-e> > group "Hello, world!"
09:38:37 <lambdabot>   ["H","e","ll","o",","," ","w","o","r","l","d","!"]
09:39:04 <Saizan> > nub  "Hello, world!"
09:39:05 <lambdabot>   "Helo, wrd!"
09:39:36 <vixey> > foldr (\x ys -> case ys of [] -> [x] ; u:vs | u == vs -> ys | otherwise = x:vs) [] "Hello, world!"
09:39:37 <lambdabot>   <no location info>: parse error on input `='
09:39:45 <vixey> > foldr (\x ys -> case ys of [] -> [x] ; u:vs | u == vs -> ys | otherwise -> x:vs) [] "Hello, world!"
09:39:46 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
09:39:46 <lambdabot>        Expect...
09:40:56 <PeakerWork> Anyone knows the XML Light library?
09:41:00 <ToRA|MSR> > reverse . map head . sortBy (comparing length) . group . sort $ "hello world!!!!"
09:41:01 <lambdabot>   "!lowrhed "
09:41:51 <SubStack> :i comparing
09:41:58 <SubStack> :t comparing
09:41:59 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
09:42:05 <PeakerWork> :t compare `on` length
09:42:05 <wli> > map head . sortBy (flip (comparing length)) . group . sort $ "hello world!!!!"
09:42:06 <lambdabot> forall a. [a] -> [a] -> Ordering
09:42:07 <lambdabot>   "!lo dehrw"
09:42:12 <PeakerWork> :t (compare `on`)
09:42:13 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
09:42:13 <mib_58ftwa> hi I am using the ghc-6.8.3 and "\n" doesn't create a new line
09:42:24 <mib_58ftwa> any ideas on what  ould be the issue?
09:42:35 <maltem> mib_58ftwa: ?
09:42:42 <Saizan> mib_58ftwa: you've used show, or print
09:42:46 <maltem> What are you doing?
09:42:52 <Saizan> instead of putStr/putStrLn directly
09:43:02 <wli> > map (head &&& length) . sortBy (flip (comparing length)) . group . sort $ "hello world!!!!"
09:43:04 <lambdabot>   [('!',4),('l',3),('o',2),(' ',1),('d',1),('e',1),('h',1),('r',1),('w',1)]
09:43:09 <mib_58ftwa> I am going through the "craft of functional programming book" just now
09:43:21 <mib_58ftwa> and there is this code to print a table of factorials ...
09:43:36 <Saizan> @paste
09:43:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:43:43 <Saizan> paste the code there ^^^
09:45:16 <mib_58ftwa> yeahhttp://hpaste.org/13100
09:46:02 <mib_58ftwa> although that is another question too ... factorialTable -2 4 also gives an error .. which I can't understand why
09:46:45 <SubStack> curious program structure
09:47:25 <mib_58ftwa> SubStack: haven't put the code for factorial .. but other than that looks fine .. noob to functional programming though
09:47:25 <Saizan> mib_58ftwa: you need to wrap -2 in parentheses
09:47:34 <Saizan> like factorialTable (-2) 4
09:47:34 <mib_58ftwa> Saizan: o i c
09:47:58 <mib_58ftwa> Saizan: thanks
09:48:03 <wli> The gamma function has simple poles at 0 and the negative integers.
09:48:12 <mib_58ftwa> now about the printing new lines
09:48:25 <Saizan> use "putStr (factorialTable (-2) 4)"
09:49:16 <maltem> mib_58ftwa: ghci (we just guess you're using the code from ghci?) shows strings quoted, as they would appear in code
09:49:39 <mib_58ftwa> maltem: ok .. and I did say at the top that I am using ghci :)
09:49:48 <maltem> mib_58ftwa: ah sry, missed that
09:50:56 <mib_58ftwa> SubStack: why is the code curious ?
09:51:13 <Taejo> :t \x -> x x
09:51:14 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:51:14 <lambdabot>     Probable cause: `x' is applied to too many arguments
09:51:14 <lambdabot>     In the expression: x x
09:52:02 <SubStack> I guess I just try to do everything in one go too much in my own code is probably what it is
09:53:57 <mib_58ftwa> SubStack: shouldn't really matter with a good compiler how many functions you have
09:54:04 <chrisdone> preflex: be poppavic
09:54:04 <preflex>  I hear you can BUY a doc that makes you a "minister" and perform weddings.. Is that the same as programming?
09:54:08 <SubStack> true enough
09:54:17 <mib_58ftwa> and what I know of lambda calculus .. this looks ok
09:54:38 <SubStack> if you bring in the factorial function closer to the presentation you can use the dynamic programming solution though
09:54:46 <SubStack> good for if you're making a big table
09:54:54 <SubStack> > scanl1 (*) [1..10]
09:54:55 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
09:55:11 <mib_58ftwa> SubStack: hmm .. doesn't haskell do that already ?
09:55:25 <Senger> hi. what's the easiest way to do a function which does: get current date and returns the number of date until a date... e.g. christmas: today is the 15.12. so the function does 24.12 - 15.12 = "9 days left!" as a result
09:55:26 <SubStack> only sometimes
09:55:29 <mib_58ftwa> SubStack: that would look like an easy optimization if functions are all pure and lal that
09:55:43 <SubStack> optimizations are hard
09:55:57 <vixey> lets go shopping!
09:56:00 <SubStack> indeed!
09:56:01 <wli> Derangements are more interesting.
09:56:08 <mib_58ftwa> yeah but thats the selling point in many ways ... that the purity makes these optimizations easy ..
09:56:29 <SubStack> from what I can gather, pure optimizations are much more complicated than impure ones
09:56:42 <SubStack> although potentially much "better"
09:56:59 <mib_58ftwa> I got reinterested in haskell just now cos I saw a presentation by Simon Peyton Jones on nested data parallelism in haskell ... pretty awesome .. and you can see how purity helps in making a large number of optimizations
09:57:13 <SubStack> because imperitive optimizations tend to be quite localized I think
09:57:19 <Saizan> mib_58ftwa: only explicitly named values are shared, since it's hard to see when memoizing is a win
09:57:25 <Lemmih> Senger: Data.Time.diffDays (Data.Time.fromGregorian 2008 12 24) (Data.Time.fromGregorian 2008 12 15)
09:57:30 <mib_58ftwa> SubStack: no .. I mean .. the amount of optimizations that a compiler can do is much more than say what it could do with say C with pointers
09:57:39 <SubStack> that's for sure
09:57:48 <SubStack> but somebody needs to write all of those optimizations
09:58:05 <pjdelport> SubStack: don't confuse purity with laziness
09:58:22 <pjdelport> referentially transparent code is always easier to optimize
09:58:29 <mib_58ftwa> Saizan: can you elaborate more ? I am not "in" with the haskell lingo :)
09:58:30 <pjdelport> lazy evaluatien is harder to optimize
09:58:41 <pjdelport> the two are separate things
09:58:56 <SubStack> ah
09:59:12 <pjdelport> so both factors come into play when you compare Haskell versus C, say
09:59:32 <mib_58ftwa> pjdelport: are you then saying that as a result ghc wouldn't cache factorial 5 cos it would be lazy till it gets to factorial 0 ?
10:00:10 <pjdelport> mib_58ftwa: that's yet another separate question
10:00:16 <Saizan> mib_58ftwa: if i write foo x = (x*2) + (x*2) then (x*2) is probably evaluated twice, if i instead write foo x = let y = (x*2) in y + y, then (x*2) is only evaluated once
10:00:17 <pjdelport> memoization and space/time tradeoff
10:01:00 <pjdelport> mib_58ftwa: an "explicitly named value" is a named function parameter or a let binding, essentially
10:01:19 <Saizan> same with factorial.. if you write (factorial 4,factorial 5) then you're going to evaluate factorial 4 twice
10:01:31 <pjdelport> mib_r85sq9: an "explicitly named value" is a named function parameter or a let binding, essentially
10:02:01 <mib_r85sq9> Saizan: I actually think in both cases x*2 would be evaluated only once ..
10:02:17 <mib_r85sq9> Saizan: in the actual machine code i.e
10:02:24 <dons> ?users
10:02:24 <lambdabot> Maximum users seen in #haskell: 586, currently: 549 (93.7%), active: 23 (4.2%)
10:02:29 <mib_r85sq9> (not in an interpreter )
10:03:05 <vixey> heh
10:03:37 <SubStack> people who are good at irssi and screen are always oversampled in those user counts
10:03:43 <wli> > let ds = 1 : 0 : zipWith3 (((+) .) . (*)) [2..] (tail ds) (cycle [1,-1]) in take 15 ds
10:03:45 <lambdabot>   [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,3...
10:04:07 * roconnor always logs into #haskell on four or five screens
10:04:15 <ddarius> SubStack: The absolute value isn't that important.-
10:04:22 <roconnor> so that there is always a #haskell next to one of my work screens
10:04:43 <mib_r85sq9> SubStack: I am saying that a compiler should know that because of the way haskell works factorial 4 is always factorial 4 , and it can cache its value
10:04:51 <SubStack> roconnor: you don't nest them?
10:04:55 <ToRA|MSR> roconnor: screen -x
10:04:59 <mib_r85sq9> but yeah .. don't know what it actually does
10:05:06 <Saizan> mib_r85sq9: in that very simple case probably yes, but with a function no
10:05:10 <roconnor> SubStack: hah.  That's a good idea
10:05:16 <roconnor> ^A^A^AA
10:05:20 <Taejo> mib_r85sq9, if you have infinite memory, you're welcome to add a flag to GHC to do that, I'm sure
10:05:22 <SubStack> instead of C-a it's C-a-a...
10:05:47 <SubStack> can get really confusing really quickly however
10:05:51 <athos> hi
10:05:57 <roconnor> hi
10:06:01 <mib_r85sq9> hi
10:06:01 <SubStack> and sometimes you can get into cycles
10:06:21 <mib_r85sq9> Taejo: :)
10:06:23 <roconnor> by reattaching the outer one in the inner one?
10:06:28 <lucca> yes, it is possible to attach to screen inside itself and get a hall of mirrors
10:06:33 <lucca> just not a good idea.
10:06:38 <roconnor> wtf?
10:06:39 <wli> > let ds = 1 : 0 : zipWith3 (((*) .) . (+)) ds (tail ds) [1..] in take 13 ds
10:06:41 <lambdabot>   [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841]
10:06:46 <lucca> (you need at least one level of indirection)
10:06:49 <roconnor> that doesn't seem like it would really work
10:06:59 <SubStack> it eats up my procs whenever I've accidentally done it
10:07:16 <lucca> roconnor: don't cross the streams.
10:07:40 <SubStack> hah
10:07:50 <SubStack> screen -S doom; screen -S gloom; screen -x doom
10:07:54 <roconnor> It'd be cool if we could to that with monad transformers
10:08:09 <pk> before learning category theory, what math subjects should I know ?
10:08:33 <ddarius> pk: You don't -need- to know any, but most resources expect certain things.
10:08:38 <roconnor> > FixT (StateT s :O WriterT w :O ReaderT r)
10:08:39 <lambdabot>   Not in scope: data constructor `FixT'Not in scope: data constructor `O'Not ...
10:08:59 * roconnor forgets the TypeCompose notation
10:09:01 <ddarius> roconnor: That should be doable.
10:09:14 * ddarius needs to leave.
10:09:16 <conal> (:.)
10:09:31 <roconnor> ddarius: sure run away before writing FixT
10:09:39 <pk> and praticaly, what should I know ?
10:09:53 <SubStack> mmm maths
10:10:14 <pk> because one can't learn groups if he's never seen an addition
10:10:38 <roconnor> ``-x   Attach to a not detached screen session. (Multi display mode).
10:10:41 <roconnor> oh god
10:10:43 <roconnor> you can do it
10:12:33 <pk> ddarius: what are those certain things ?
10:13:46 <Saizan> roconnor: what should FixT do?
10:14:09 <roconnor> I was wondering myself
10:14:26 <vixey> it doesn't make sense at all :S
10:14:28 <roconnor> should the inner state actually be the outer state?
10:14:35 <Saizan> type FixT t a = t Identity a, maybe
10:14:46 <roconnor> or just another state of the same type
10:15:40 <roconnor> SubStack: your screen command is too scary for me to try
10:15:56 <SubStack> good idea
10:16:00 <roconnor> it seems like it would be bad
10:16:11 <SubStack> it just cycles
10:16:11 <roconnor> the more I think about it
10:16:26 <SubStack> you can kill it with screen -x gloom -X kill
10:16:37 * SubStack tried it to make sure
10:17:02 <roconnor> can I create a new screen to run that command?
10:17:06 <SubStack> since C-a C-k wasn't working for it
10:17:41 <SubStack> why not?
10:28:55 <dons> Heffalump:  someone reported their RWH via amazon.co.uk arriving in london today
10:31:12 <orbitz> is printf some sort of black magic in haskell?
10:31:29 <int-e> orbitz: no, it's just clever use of type classes
10:31:43 <Asztal> I ordered my RWH from somewhere else after my initial source decided to delay it by 3 weeks
10:32:06 <Asztal> I got the last one in stock from the second place :)
10:32:07 <orbitz> how does it take an unknown number of parameters?
10:32:12 <int-e> orbitz: judge for yourself: http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/Text-Printf.html
10:33:58 <byorgey> orbitz: its return type is a member of a special typeclass which could either be a result (like String) or a function which takes more parameters.
10:34:16 <byorgey> @type printf
10:34:17 <lambdabot> forall r. (PrintfType r) => String -> r
10:34:38 <PeakerWork> @src PrintfType
10:34:38 <lambdabot> Source not found. Take a stress pill and think things over.
10:36:16 <dons> here's a challenge for #haskell. which FP person(s) has the lowest Erdos Number.
10:36:26 <orbitz> how does it know when it's consumed everything and it hsould be a string or a function?
10:36:41 <dons> there are lots of 4s, and certainly some 3s. Any 2s?
10:37:26 <roderyk> http://hpaste.org/13101  Can someone take a peek at this? I wrote a timeoutSeq for gtk2hs that evaluates one IO Bool at a time. But I can't figure out how to write the timeoutDep. Would appreciate any ideas
10:37:47 <orbitz> :t printf
10:37:49 <lambdabot> forall r. (PrintfType r) => String -> r
10:37:53 <orbitz> :t printf "hi"
10:37:53 <Saizan> orbitz: depending on how you use it
10:37:55 <lambdabot> forall r. (PrintfType r) => r
10:38:05 <Saizan> :t printf "hi" 1
10:38:06 <lambdabot> forall t t1. (PrintfType (t -> t1), Num t) => t1
10:38:19 <Saizan> > printf "hi" 1 :: String
10:38:20 <lambdabot>   "hi* Exception: Printf.printf: formatting string ended prematurely
10:38:35 * vixey has number infinity :/
10:38:36 <orbitz> > pritnf "hi"
10:38:38 <lambdabot>   Not in scope: `pritnf'
10:38:43 <orbitz> > printf "hi"
10:38:44 <lambdabot>   Add a type signature
10:38:49 <orbitz> > printf "hi" :: Sring
10:38:50 <lambdabot>   Not in scope: type constructor or class `Sring'
10:38:52 <orbitz> > printf "hi" :: String
10:38:54 <lambdabot>   "hi"
10:39:10 <PeakerWork> > printf "hi" :: IO String
10:39:10 <lambdabot>   * Exception: "<IO [Char]>"
10:39:22 <BMeph> dons: I don't know for sure, but I'd be willing to put money on Conor (McBride). :)
10:39:36 <wchogg> BMeph : why that guess?
10:39:40 <dons> mostly via FM people, yes.
10:39:46 <orbitz> wel lif we are goign to put money on it
10:39:50 <orbitz> don't give away yoru edge byorgey
10:39:53 <orbitz> BMeph*
10:39:54 <dons> at galois,all our formal methods people are 4s.
10:39:58 <dons> only some of our FP people are 4s.
10:40:57 <Nafai> 4s?
10:41:12 <byorgey> I think we should count SPJ numbers instead of Erdos numbers.
10:41:27 <int-e> > printf "%d" 1.0 :: String
10:41:29 <lambdabot>   "* Exception: Printf.printf: bad argument
10:41:33 <Taejo> dons, what's your Erdos number?
10:41:42 <Nafai> Oh
10:41:47 <orbitz> > printf "%f" 1.0 :: String
10:41:47 <dons> i've 4 via a TR, but not sure otherwise. prob. 6
10:41:49 <lambdabot>   "1.0"
10:41:56 <dons> byorgey: mmm!
10:42:29 <int-e> orbitz: the clever part is that printf is completely type driven - those errors are generated when the given format doesn't match the expected format(s) for that type.
10:43:30 <vixey> runtime type =errors
10:43:31 <quicksilver> dons: if I had only co-authored a paper with my phd supervisor I think I would have a 3. But, I didn't.
10:43:59 <dons> quicksilver: doh!
10:44:04 <orbitz> int-e: the format errors are runtime though, any way to make them compile time (hypohetical)
10:44:58 <Taejo> There's an informal article my honours supervisor wants me to write. If I coauthored with him, I could get a 5 (if informal articles count)
10:45:40 <Saizan> orbitz: depends, if you relax your definition of format string then yes
10:46:11 <orbitz> Saizan: how so?
10:47:23 <dons> haskell.org new logo contest:
10:47:24 <dons>   http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
10:47:27 <dons> anyone want to try to do one?
10:47:47 <Saizan> orbitz: see the bottom of this message http://www.mail-archive.com/haskell@haskell.org/msg20758.html
10:48:27 <Rapiere> do you intend to take it from half-life ? :)
10:48:47 <orbitz> dons: i like the first oen
10:48:55 <orbitz> Saizan: thanks
10:50:21 <dons> Haskell: Pure. Parallel. Functional.
10:50:57 <EmielRegis> http://haskell.org/haskellwiki/Image:Tshirt-logo-mod-inv.png
10:50:58 <EmielRegis> this one looks good
10:50:59 <Taejo> Haskell: Pure. Parallel. Win.
10:51:20 <EmielRegis> and this http://haskell.org/haskellwiki/Image:HsLogosMB.png
10:51:20 <dons> i  like "Parallel" instead of "Lazy"
10:51:29 <dons> fwiw, since I tend to write strict, parallel programs as often as lazy ones.
10:52:07 <Saizan> parallel is more about GHC than haskell
10:52:21 <dons> haskell was born parallel.
10:52:53 <ViaToR_SG> I add a new logo now :P
10:53:10 <wli> I mostly write strict parallel code in C.
10:53:15 <Saizan> and it's be nice to avoid confusion of the same kind as "haskell being pure memoizes everything by default"
10:55:05 <PeakerWork> Saizan: an adaptive/heuristic profiler that chose whether to memoize based on runtime data could be nice, though :)
10:56:29 <PeakerWork> Hmm, I guess another thing facilitated by purely functional languages -- is that there are far more available possible transformations one can run on a program, that preserve denotational semantics.  This might allow evolutionary algorithms to try optimizing the program incrementally :)
10:57:37 <PeakerWork> (May need to add primitives such as "try forcing in a thread for some limited time, ignore bottoms", because converting to strict does not preserve semantics)
10:58:38 <Megzlna> Know any pages about how Haskell evaluation works?
11:02:03 <Megzlna> http://www.google.com/search?hl=en&q=haskell+%22outermost+first%22
11:03:32 <zong_sharo> does happs-state caches all data in memory?
11:04:13 <vixey> Megzlna, it's very simple -- any specific stuff?
11:04:56 <Megzlna> the sharing isnt simple
11:05:33 <PeakerWork> Megzlna: Cale gives a tutorial about lazy evaluation here every now and then, I can't find it in the IRC logs though
11:05:43 <PeakerWork> Cale: you should tag your mini tutorials with something grappable :-)
11:05:49 <vixey> Megzlna, it is simple
11:06:04 <PeakerWork> Megzlna: generally function calls aren't shared, and bound names are shared for their entire scope
11:06:21 <dons> mfp: length doesn't fuse under build/foldr
11:06:32 <dons> mfp: so you spotted a *missing* optimisation opportunity. thanks!
11:06:43 <PeakerWork> There's a nuance exception to that -- values that seem like named values, but are actually functions (Blah a => a) are not really shared, afaik
11:07:06 <mfp> dons: it doesn't? that's surprising
11:07:23 <dons> mfp: why?
11:07:32 <dons> length is a left fold. build/foldr is a right-fold fusion system
11:07:49 <dons> it of course would fuse away the allocation if you use the stream lib.
11:07:52 <Saizan> zong_sharo: the current state is kept in memory
11:07:56 <dons> as would "multiple passes", fwiw.
11:08:17 <dons> so we'll get the same code either way
11:08:17 <mfp> didn't think it deeply, just looked like something GHC would do
11:08:24 <mfp> +about
11:08:36 <dons> mfp: yeah, its a reasonable intuition. but left folds don't fuse without stream fusion
11:08:39 <dons> which must be explicitly imported
11:08:59 <dons> btw, the pattern case, the alternative would be to mandate 11 traversals, no?
11:09:07 <zong_sharo> Saizan: whole state?
11:09:09 <dons> which the compiler will fuse back into one anyway. so *shrug*
11:09:15 <Saizan> zong_sharo: yes
11:10:09 <mfp> it might not matter for GHC, but it does for compilers which aren't as smart --- the Q is whether the admins would allow code that does that explicitly, as opposed to implicitly, as GHC
11:10:16 <zong_sharo> Saizan: happs-sate like memcached on steroids?
11:10:18 <dons> mfp: yeah.
11:10:29 <dons> so i replied asking the same question.
11:10:44 <dons> i'm not too concerned about the result. if anything, tightening it up makes it easier for ghc.
11:11:20 <dons> a data-parallel version might be interesting.
11:11:35 <dons> duplicate the data, run all the matches in parallel, reduce to the length
11:11:39 <dons> that'd fuse away as well. mm.
11:11:43 <dons> and would look cute.
11:11:52 <Saizan> zong_sharo: i don't know what memcached is
11:12:28 <mfp> ? match-reduce in parallel too?
11:12:31 <mfp> ah misread
11:12:33 <dons> mfp: when are you going to submit some haskell entries? :) its more fun when you've got `par`...
11:12:52 <zong_sharo> Saizan: nevermind. I would like to avoid to use SQLite.
11:12:53 <Megzlna> F# is so weird.. I don't know much about ML, but:
11:12:59 <dons> mfp: parMap (length . replace s) [patterns]
11:13:00 <Megzlna> let mutable j = 3
11:13:00 <Megzlna>     j <- 4       // destructive assignment
11:13:06 <zong_sharo> Saizan: I need a simple, concurrent safe, database
11:13:16 <mfp> told you, I'm still 2X-3X away from "optimal" code
11:13:29 <vixey> F# is a crap version of ocaml afaict
11:13:32 <dons> mfp: oh?
11:13:44 * dons doesn't remember this conversation
11:13:48 <Megzlna> why crap vix
11:14:22 <mfp> meaning that when I've tried to optimize random code found around (remember for instance the CSV thing?), I still get ~2X faster with OCaml
11:14:33 <dons> ah, interesting.
11:14:45 <dons> i wonder why.
11:14:53 <mfp> I need more practice :)
11:14:58 <dons> there's something I do that you don't.
11:15:10 <mfp> write Haskell all the time? :)
11:15:15 <dons> yeah, maybe :)
11:15:25 <quicksilver> the ocaml compiler is a good one, and random code you find around is more often designed on the assumption of strict by default instead of lazy by default.
11:15:29 <dons> spent 5 years reading core, helps understand data layouts, when bottoms induce indirections
11:15:32 <dons> and so on.
11:15:52 <quicksilver> the times that lazy evaluation is a win, strict programmers are familiar with and they solve the problem by hand.
11:16:04 <Megzlna> quicksilver: why woul ecosystem code assuming strict be a good thing?
11:16:05 <dons> mfp: the new register allocator might help you too.
11:16:17 <mfp> 6.10 only?
11:16:24 <quicksilver> Megzlna: it's not a good thing. But it does explain why ecosystem code runs faster on ocaml than ghc.
11:16:25 <dons> 6-12.
11:16:32 <dons> 6.10 has the parallel GC
11:16:37 <dons> the new reg allocator is in the head.
11:16:38 <mfp> ah
11:16:45 <mfp> how long does GHC take to build nowadays?
11:16:52 <quicksilver> 15 minutes.
11:16:52 <dons> between 3 mins and 1hr?
11:17:01 <dons> yeah, 15 mins is prob. about right on a dual core.
11:17:06 <dons> i got 3 mins on a 16 core
11:17:26 <Saizan> zong_sharo: but you don't want to keep all the table in memory?
11:17:27 <dons> mfp: but strictly experimental.
11:17:32 <mfp> might build from CVS to play someday then
11:17:34 <dons> so you'd want to be in touch with the devs i think.
11:17:40 <dons> well, its in darcs :)
11:17:51 <dons> i'm sure they'd welcome feedback though
11:17:59 <dons> the harvard codegen team.
11:18:01 <mfp> uh it's sort of a phrase now "... from CVS"
11:18:04 <dons> hehe
11:18:05 <Badger> good grief
11:18:14 <Badger> how much did a 16-core monster cost you?
11:18:25 <zong_sharo> Saizan: yep
11:18:28 <dons> its a research box for data parallel ghc
11:18:31 <Megzlna> quicksilver: You are saying there's more chances for strict to be faster, than there is for lazy, and because Haskell is usually lazy, unless we use something like foldr', that Haskell is slower, and yet it being slower is a good thing.... ?
11:18:37 <dons> so about the cost of 5 desktops
11:18:38 <mfp> when is GHC's migration to git going to happen?
11:18:46 <Badger> hah
11:18:54 <kig> i priced a 16-core with 256 megs of ram and it was only 10 ke :>
11:18:54 <dons> soonish, i think.
11:18:59 <quicksilver> Megzlna: no, I'm saying that strict and lazy are both faster in certain cases.
11:19:03 <kig> err, 256 gigs
11:19:11 <quicksilver> Megzlna: but lots of code out there is written by experience strict programmers
11:19:23 <quicksilver> Megzlna: who assume strictness, and manually code around laziness when needed.
11:19:51 <quicksilver> IOW lots of people have experience in making strict go fast, and fewer have experience in making lazy go fast.
11:20:03 <dons> laziness can lead to extra indirections in data layout, and extra overheads in tight loops. so something to be aware of. it can also lead to better performance for other data cases due to reduced memory pressure.
11:20:15 <Megzlna> Last night, #Haskell was trying to help me understand folds, and it just kept on confusing me
11:20:19 <dons> so you have to know what you need.
11:20:20 <maltem_> mfp: did they eventually decide which repositories are to be converted, exactly?
11:20:30 <vixey> that will have been me then :p
11:20:33 <Megzlna> and I said: There's one key fact you think I know which I don't.
11:20:48 <Megzlna> that fact was that Haskell does outermost first evaluation
11:20:59 <vixey> that's irrelevant
11:21:03 <Megzlna> it's not
11:21:05 <vixey> folds work stict lazy or anything
11:21:20 <quicksilver> that's not true vixey.
11:21:30 <mfp> maltem_: sorry, don't know much about this (not used to building GHC)
11:21:31 <quicksilver> a right fold over an infinite stream requires laziness to work.
11:21:34 <dons> mfp: and ghc's been doing correct Float/Double unpacking for ever ... :) so there's some advantages.
11:21:46 <Megzlna> I'll show you what an erroneous attempt at using innermost first evaluation with folds looks like
11:22:00 <quicksilver> Megzlna: technically haskell behaves as if it did outermost first.
11:22:03 <vixey> Haskell being lazy isn't important
11:22:04 <quicksilver> it's not required to do that.
11:22:04 <Megzlna> http://hpaste.org/13092   <--- TOTALLY wrong
11:22:11 <quicksilver> it's just required to act as if it did.
11:22:17 <vixey> the point about lazy evalutation is you don't have to think abotu evaluation order anymore
11:22:25 <Megzlna> vixey: It is important, otherwise these folds would not work...
11:22:35 <vixey> wrong try it in scheme
11:22:35 <maltem_> mfp: fwiw there is a git mirror of ghc darcs, which is quite handy when ghc head is needed quickly
11:22:45 <mfp> dons: isn't that orthogonal to strict/lazy evaluation?
11:22:54 <Megzlna> We discussed for an hour about how I couldnt understand how foldr can support infinite folds
11:23:07 <Megzlna> because I was thinking in innermost first
11:23:11 <mfp> oops #haskell goes a bit faster than I'm used to
11:23:26 <Megzlna> as you can see in the lower example, if you do innermost first, foldr just doesnt work out
11:23:35 <vixey> you got 15 both times
11:23:38 <vixey> I don't see the problem
11:23:41 <Megzlna> that doesn't matter vixey
11:23:49 <Megzlna> foldr would die on [1..]
11:23:50 <mfp> (left high-traffic channels a while ago)
11:23:58 <quicksilver> Megzlna: off hand I don't see anything wrong with your right fold.
11:23:59 <Megzlna> in innermost eval
11:24:05 <vixey> yeah sum 1..inf diverges so what
11:24:16 <Megzlna> quicksilver: well, its wrong
11:24:26 <Megzlna> and not how haskell behaves
11:24:33 <Megzlna> Cause...
11:24:40 <mpeter> since when is there a printf function in haskell
11:24:48 <quicksilver> @src foldr
11:24:48 <lambdabot> foldr f z []     = z
11:24:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:24:51 <Megzlna> Where does the lambda even have any chance to evaluate before it descends all the way to the end of the list?
11:24:55 <mpeter> @src printf
11:24:56 <lambdabot> Source not found. There are some things that I just don't know.
11:25:08 <quicksilver> Megzlna: it looks fine, and exactly how haskell behaved.
11:25:15 <Megzlna> (\x a -> x+a) 1 ((\x a -> x+a) 2 ((\x a -> x+a) 3 ((\x a -> x+a) 4 ((\x a -> x+a) 5 (foldr (\x a -> x+a) 0 [])))))
11:25:20 <quicksilver> Megzlna: it's just (+) is a strict function so it's not a very interesting example.
11:25:23 <dons> go logos, http://www.reddit.com/r/programming/comments/7jnjy/the_2009_haskell_logo_contest_submit_your_entries/
11:25:25 <mpeter> @hoogle printf
11:25:25 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
11:25:25 <lambdabot> module Text.Printf
11:25:25 <lambdabot> package printf-mauke
11:25:51 <Megzlna> quicksilver: But my foldr is innermost first
11:25:53 <Gracenotes> dons: misread initially as 'legos'
11:26:00 <Megzlna> outermost isnt like that
11:26:03 <mpeter> hey dons, this is yours, right?
11:26:05 <mpeter> http://cgi.cse.unsw.edu.au/~dons/blog/2007/03
11:26:11 <dons> mpeter: yup
11:26:17 <Megzlna> Outermost is like this:
11:26:20 <mpeter> can you tell me anything that's lost in translation there
11:26:25 <dons> ?
11:26:27 <Megzlna> foldr (\x a -> x+a) 0 [1,2,3,4,5]
11:26:27 <Megzlna> (\x a -> x+a) 1 (foldr (\x a -> x+a) 0 [2,3,4,5])
11:26:30 <mpeter> in the sh->haskell post
11:26:31 <Megzlna> 1 + (foldr (\x a -> x+a) 0 [2,3,4,5])
11:26:34 <dons> what's lost?
11:26:35 <quicksilver> Megzlna: true, true.
11:26:45 <eu-prleu-peupeu> http://lambda-the-ultimate.org/node/3131
11:26:45 <dons> i thought i only added things?
11:26:46 <Megzlna> Hence, the Lambda has a chance to cancel out the fold
11:26:48 <mpeter> is anything lost?
11:26:49 <Megzlna> based upon 'x'
11:26:56 <dons> mpeter: i don't think  so?
11:26:56 <quicksilver> Megzlna: yes, that's right.
11:27:00 <mpeter> ok cool
11:28:03 <vick> Does anybody know a recursive definition for permutation ? (like nCr = (n-1)Cr + (n-1)C(r-1)) ?
11:28:05 <vixey> Megzlna, you can write it  foldr (+) 0 (1 : (2 : (3 : (4 : (5 : [])))))
11:28:28 <vixey> Megzlna, foldr (+) 0 (1 : (2 : (3 : (4 : (5 : []))))) ~~> (1 + (2 + (3 + (4 + (5 + 0)))))
11:28:43 <athos> @hoogle random
11:28:43 <lambdabot> package random
11:28:43 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
11:28:43 <lambdabot> module System.Random
11:28:59 <Gracenotes> vick: n C k = (n - 1 C k) + (n -1 C k - 1), iirc
11:29:03 <mpeter> athos: you have to write the generator function yourself
11:29:13 <mfp> wow  http://relapse-software.net/haskell_5.png
11:29:15 <Megzlna> So I had finished Learn You A Haskell For Great Good and nowhere do they even once mention outermost first. Also read "a gentle introduction" and totally not covered
11:29:17 <Gracenotes> recursively implemented, it would be very slow, factorial is much cleaner
11:29:17 <vick> Gracenotes: I want one for P not C :P
11:29:22 <mpeter> i think :O
11:29:34 <Megzlna> That's such important information on understanding the whole point of haskell
11:29:39 <Gracenotes> vick: oh, duh. Silly me.
11:29:40 <dons> mfp: kinda abstract..
11:29:49 <Gracenotes> vick: That's the one you just printed out ;)
11:29:53 <mfp> indeed
11:29:58 <mpeter> mfp: ???
11:30:02 <mercury^> vick: I just gave you one in #math....
11:30:05 <orbitz> outtermost and innermost are teh whole point of haskell?
11:30:07 <mpeter> did you do that with ink+brush?
11:30:10 <Gracenotes> so, nPr = (n-1)Pr + ... something
11:30:13 <mpeter> or gimp ;)
11:30:14 <mfp> mpeter: not mine
11:30:33 <Gracenotes> either you choose to include an element in a permutation, or not, and then choose the other (n-1) elements
11:30:49 <Gracenotes> so perhaps the formula would be analogous. *thinks*
11:31:10 <zeno> how do i make vim use this? http://www.haskell.org/libraries/haskell.vim?
11:31:23 <vick> mercury^: I dont think that's a recursive defintion for Permutation , i think it's a recursive defintion for haskel to perform permutation, i can be wrong tho
11:31:31 <zeno> sorry no ? on the end http://www.haskell.org/libraries/haskell.vim
11:31:33 <vick> mercury^: Can you do it in a mathematical form ?
11:31:44 <mercury^> vick: it is pretty much in mathematical form
11:31:52 <vixey> mercury^, not really
11:31:54 <mpeter> > [x| x<-[1,4..1000], x `mod` 20 == (-1)]
11:31:55 <lambdabot>   []
11:31:58 <Megzlna> vixey: That only works for (+)
11:32:02 <mercury^> I explained everything that might not be entirely obvious.
11:32:02 <mpeter> > [x| x<-[1,4..1000], x `mod` 20 == 1]
11:32:04 <lambdabot>   [1,61,121,181,241,301,361,421,481,541,601,661,721,781,841,901,961]
11:32:08 <vixey> Megzlna, this works for everything
11:32:26 <Gracenotes> mercury^: hm, I'm curious, what is the formula?
11:32:27 <mfp> zeno: drop to ~/.vim/syntax
11:32:33 <mpeter> what's that site full of "how do you figure this out with code" problems
11:32:37 <mercury^> permute l@(h:t) | l == reverse (sort l) = sort l
11:32:37 <mercury^>                 | t == reverse (sort t) = let n = minimum $ filter (>h) t in
11:32:37 <mercury^>                                           n : (insert h $ reverse $ delete n t)
11:32:38 <mercury^>                 | otherwise             = h : permute t
11:32:49 <idnar> mpeter: Project Euler?
11:32:49 <shepheb> mpeter: projecteuler.net ?
11:32:52 <mpeter> thanks
11:32:53 <zeno> mfp: thanks
11:32:58 <Megzlna> vixey: I'm assuming you're talking about an innermost impl of foldr
11:32:59 <idnar> there are a lot of "coding challenge" sites, though
11:33:06 * mpeter needs some exercise
11:33:08 <Megzlna> since thats what you were defending
11:33:12 <vixey> Megzlna, we don't have lazy evaluation so we can spend all our time tracing *lazy* program execution (like you trace strict execution), we have it so that you do not have to even think about evaluation
11:33:31 <Megzlna> you do have to think about it
11:33:36 <vixey> No I do not
11:33:39 <Megzlna> because foldr is a very fundamental part of haskell
11:33:54 <quicksilver> Megzlna: all you have to think about is evaluation by demand
11:34:03 <quicksilver> which IMO is a simpler concept than outermost first.
11:34:08 <vixey> I don't trace the execution last [1..] to figure it it's not going to terminate
11:34:09 <zeno> mfp: hmm doesnt appear to be working, you sure just put the file in ~/.vim/syntax?
11:34:40 <vixey> it is clearly meaningless regardless of evaluation order
11:34:58 <mpeter> > foldr (+) 0 ([x|x<-[1..1000],x `mod` 5 == 0 || x `mod` 3 == 0])
11:34:59 <lambdabot>   234168
11:35:04 <Megzlna> quicksilver: But...  I was banging my head against the wall... just saying over and over, No, foldr can't support infinite
11:35:07 <mpeter> :D
11:35:11 <Megzlna> even though it did
11:35:15 <Heffalump> dons: oh well, I'm clearly stuck up in the sticks here :-)
11:35:18 <mpeter> 1 down, 250 to go
11:35:28 <mfp> zeno: I think so, I see I've put a bunch of syntax files there
11:35:29 <quicksilver> Megzlna: yes, the solution to which is to think of it as demand-based
11:35:37 <mfp> zeno: do you have  syntax on   in your .vimrc?
11:35:37 <quicksilver> Megzlna: thunks only get reduced when you try to inspect them
11:35:42 <vixey> Megzlna, foldr (@) z [1..] ~~> 1 @ (2 @ (3 @ (4 @ ... is perfectly fine
11:35:47 <quicksilver> and then only enough to answer the question you asked.
11:35:55 <Megzlna> Ok so,
11:35:56 <Megzlna> (\x a -> x+a) 1 (foldr (\x a -> x+a) 0 [2,3,4,5])
11:36:00 <orbitz> > foldr (:) [] [1, 2, 3]
11:36:01 <mfp> also    filetype on     filetype plugin on    filetype indent on    while you're at it
11:36:02 <lambdabot>   [1,2,3]
11:36:05 <vixey> Megzlna, whether that collapses down into something small or a new infinite object, or diverges depends on what (@) means
11:36:05 <Megzlna> How do you decide where the demand is there?
11:36:07 <Megzlna> Inner or outer
11:36:13 <Megzlna> what makes the Outer demanded?
11:36:14 <orbitz> > take 5 $ foldr (:) [] [1..]
11:36:15 <vixey> you don't ..
11:36:16 <lambdabot>   [1,2,3,4,5]
11:36:19 <PeakerWork> Megzlna: \x a -> x+a    is just (+)
11:36:22 <orbitz> > take 5 $ foldl (:) [] [1..]
11:36:24 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
11:36:24 <lambdabot>        Expect...
11:36:25 <zeno> mfp: it has syntax on, but adding that file to ~/.vim/syntax didnt change how it heighlights
11:36:26 <Megzlna> PeakerWork: I know that
11:36:52 <quicksilver> Megzlna: you look at the head of the expression, it's a lambda
11:36:54 <Megzlna> if you prefer
11:37:06 <Megzlna> (+) 1 (foldr (+) 0 [2,3,4,5])
11:37:11 <quicksilver> Megzlna: a lambda isn't a constructor, so you reduce the lambda and look at the head of what's left.
11:37:36 <Megzlna> the head?
11:37:41 <Megzlna> left to right?
11:37:46 <quicksilver> yes.
11:37:47 <mfp> zeno: silly Q: did you restart vim / reload after removing  b:current_syntax   ?
11:38:13 <quicksilver> it is indeed very closely related to outermost first
11:38:22 <quicksilver> but there is no promise we "completely" evaluate anything
11:38:27 <Megzlna> doesnt work with infix
11:38:27 <quicksilver> we just do enough work to produce a constructor
11:38:40 <quicksilver> well you need to understand that infix is only a notation, yes.
11:38:47 <quicksilver> and the 'head' is really the +
11:39:17 <Megzlna> ((((+) 1 2) + ((+) 2 3) + (5 + 6)) + 1)
11:39:26 <Megzlna> The only thing that makes sense here is outer or inner
11:39:33 <Megzlna> otherwise you're trying the figure out infixes
11:39:40 <vixey> Megzla, Why is this approach useful?
11:39:48 <quicksilver> I just know the head is that rightmost +
11:39:50 <zeno> mfp: how do i remove b:current_syntax?
11:39:56 <quicksilver> think of it as an expression tree, if you will
11:39:58 <quicksilver> or an AST.
11:41:03 <Megzlna> You know its the rightmost + cause you're thinking in terms of Outermost
11:41:07 <mfp> zeno: 1 sec, I'm trying to use that syntax file
11:41:08 <Megzlna> rather than demand based
11:41:20 <quicksilver> Megzlna: Don't tell me what Im' thinking.
11:41:30 <quicksilver> Demand-based is very closely related to what you call outermost.
11:41:37 <quicksilver> but infix syntax is really not very interesting.
11:41:55 <vixey> quicksilver, evaluation order isn't interesting
11:42:00 <quicksilver> the thing you typed is really ((+) (((+) 1 2) + ((+) 2 3) + (5 + 6)) 1)
11:42:01 <b_jonas> infix sytax sucks. we should just use prefix for everything.
11:42:11 <quicksilver> and so, it's a (+) at the head.
11:42:19 <b_jonas> let's change haskell grammar so + is an identifier and `+` is the infix
11:42:23 <maltem_> I'll kill the next one in this room saying something isn't interesting.
11:42:26 <quicksilver> vixey: not very interesting, no.
11:42:42 <orbitz> maltem_: there yougo
11:42:49 <maltem_> ...
11:42:51 <mfp> zeno: just dropping to ~/.vim/syntax and reopening the file with  :ed   does it for me
11:42:55 <vixey> neither is it what one needs to think about when writing haskell
11:42:58 <Gracenotes> b_jonas: no, not scheme >_>
11:43:22 <quicksilver> vixey: it is if you want to reason about time or space.
11:43:25 <ozy`> interesting stuff isn't interesting
11:43:27 <mfp> zeno: you can see if vim is loading the new syntax file with  :scriptnames   (~/.vim/syntax/haskell.vim  should be near the end)
11:43:33 <quicksilver> vixey: and it is if you want to deal with infinite lists.
11:44:09 <Megzlna> or to know how to choose between foldr/foldl
11:44:16 <Megzlna> and why you need one or the other
11:44:26 <zeno> mfp: ok thanks
11:44:29 <teko> @let uniq2 xs = foldr (\x ys -> x : filter (/=x) ys) xs xs
11:44:30 <lambdabot>  Defined.
11:44:48 <teko> look vixey i got the uniq in terms of foldr
11:44:56 <vixey> teko, nice
11:45:04 <teko> uniq2 "aabdfvcxdsffff"
11:45:08 <teko> > uniq2 "aabdfvcxdsffff"
11:45:09 <lambdabot>   "abdfvcxs"
11:45:16 <vixey> why does it take xs twice?
11:45:30 <vixey> could the first be [] instead?
11:45:32 <teko> cos xs is the start value for the accumulator
11:45:36 <teko> and the input string
11:45:49 <vixey> @let uniq2' xs = foldr (\x ys -> x : filter (/=x) ys) xs xs
11:45:51 <lambdabot>  Defined.
11:46:00 <vixey> > (uniq2 "aabdfvcxdsffff", uniq2' "aabdfvcxdsffff")
11:46:01 <lambdabot>   ("abdfvcxs","abdfvcxs")
11:46:08 <vixey> oops
11:46:15 <vixey> @let uniq2'' xs = foldr (\x ys -> x : filter (/=x) ys) [] xs
11:46:16 <lambdabot>  Defined.
11:46:18 <vixey> > (uniq2 "aabdfvcxdsffff", uniq2'' "aabdfvcxdsffff")
11:46:20 <lambdabot>   ("abdfvcxs","abdfvcxs")
11:46:33 <zeno> seems fine
11:46:39 <teko> oh
11:46:46 <vixey> > (uniq2 [1..], uniq2'' [1..])
11:46:48 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:46:49 <PeakerWork> > (uniq2 &&& uniq2'') "aabdfvcxdsffff"
11:46:51 <lambdabot>   ("abdfvcxs","abdfvcxs")
11:47:21 <zeno> @src &&&
11:47:21 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
11:47:23 <teko> uniq2'' ????
11:47:29 <zeno> @src arr
11:47:29 <vixey> teko, that's interesting, so I think these two are equal
11:47:29 <lambdabot> Source not found. :(
11:47:36 <Gracenotes> @src >>>
11:47:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:47:40 <Gracenotes> not yet
11:47:55 * mpeter np: the rutabega - serotonin
11:47:57 <teko> what is uniq2'' ??
11:48:05 <teko> oh srs
11:48:08 <mpeter> ./` serotonin, stop the dronin
11:48:14 <ozy`> @src (>>>)
11:48:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:48:15 <mpeter> ./` always flow we can always go ./`
11:48:18 <orbitz> 14:46 < vixey> @let uniq2'' xs = foldr (\x ys -> x : filter (/=x) ys) [] xs
11:48:32 <zeno> @hoogle >>>
11:48:33 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
11:48:44 <PeakerWork> zeno: &&& takes two "arrow processors" (in this case normal functions, which are also arrow processors), and builds a processor that feeds the same input to both of them, yielding the two outputs
11:48:56 <PeakerWork> zeno: >>> just composes arrow processors one after another
11:49:24 <PeakerWork> zeno: arr converts a normal Haskell function to an arrow processor, and *** combines two processors to handle a composite 2 values in a tuple, and puts the results in a composite tuple too
11:49:24 <zeno> PeakerWork: ok thanks, although i dont know what arrows are!
11:49:27 <zeno> googles =p
11:50:17 <vixey> Arrow is kind of useless isn't it?
11:50:25 <PeakerWork> zeno: I think of an arrow as a generalization of a function. Its kind, like (->) is also *->*->*    but instead of being a specific data-type like (->) which can only be applied or built,  an arrow is a type-class, so can be a datastructure or anything else, and you can compose it like functions
11:50:28 <dons> woo, http://www.reddit.com/r/programming/comments/7jnq9/functional_programming_unit_testing/
11:50:54 <PeakerWork> vixey: the existence of the "arr" method takes away much of its usefulness, but its combinators are still very useful to work with tuples with ordinary functions
11:51:11 <vixey> well you could do tuple stuff without 'arro'w
11:51:47 <PeakerWork> vixey: of course, but nobody defined the function-specific (&&&), (***), first, second, which are really useful
11:52:07 <zeno> PeakerWork: ah ok thanks.  when are they really useful specifically?
11:52:27 <quicksilver> vixey: Arrow is useful for Kleisli arrows.
11:52:36 <quicksilver> and certain parser combinators.
11:52:44 <vixey> no parser combinator I know
11:53:09 <b_jonas> um, what does second do on functions?
11:53:20 <dolio> Parser combinators were the original motivation for arrows.
11:53:30 <b_jonas> @src second
11:53:30 <lambdabot> Source not found. :(
11:53:34 <PeakerWork> zeno: One thing that arrows _can't_ do, is decide which arrows to compose together, based on the data that will eventually be available when the arrow is executed (let's call that "runtime data").  So this makes them useful to represent Arrow parsers, which are less expressive than Monadic parsers, and can thus be represented as FSM's (Monadic ones can't)
11:53:43 <PeakerWork> @src (->) second
11:53:43 <lambdabot> second f = id *** f
11:53:46 <dons> ?users
11:53:46 <byorgey> b_jonas: second f (x,y) = (x, f y)
11:53:46 <lambdabot> Maximum users seen in #haskell: 586, currently: 559 (95.4%), active: 30 (5.4%)
11:54:08 <b_jonas> isn't that the same as fmap?
11:54:18 <b_jonas> we have that one specifically
11:54:20 <vincenz> Is there a BiFunctor class somewhere?
11:54:21 <quicksilver> vixey: I believe there are some parser examples in http://www.soi.city.ac.uk/~ross/papers/notation.html
11:54:27 <PeakerWork> > (first . second . fmap (*2)) ((1, [1,2,3]), 2)
11:54:28 <lambdabot>       No instance for (Arrow (,))
11:54:28 <lambdabot>        arising from a use of `first' at <in...
11:54:36 <PeakerWork> > (first . second . fmap) (*2) ((1, [1,2,3]), 2)
11:54:38 <lambdabot>   ((1,[2,4,6]),2)
11:54:47 <byorgey> vincenz: in category-extras, probably
11:54:56 <PeakerWork> Note I "dig into" the first of the tuple, then the second in that, and then I "fmap" on that
11:55:36 <vincenz> hmm
11:55:37 <PeakerWork> You can also apply functions to the arguments of functions or to their results that way, pretty useful
11:55:54 <PeakerWork> > (first . first) (*2) ((1, [1,2,3]), 2)
11:55:55 <lambdabot>   ((2,[1,2,3]),2)
11:56:06 <vincenz> class BiFunctor f where fmap2 :: (a -> b -> c) -> f a -> f b -> f c
11:56:07 <vincenz> ?
11:56:24 <PeakerWork> vincenz: You could implement fmap2 over Applicative
11:56:34 <b_jonas> @src (->) (***)
11:56:34 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
11:56:37 <PeakerWork> vincenz: I think BiFunctor is really the same as Applicative
11:56:37 <dolio> (a -> c) -> (b -> d) -> f a b -> f c d
11:56:39 <b_jonas> @src (->) (&&&)
11:56:40 <lambdabot> Source not found.
11:57:01 <zeno> PeakerWork: neat, although in that case (fst . snd . map) (*2) ((1, [1,2,3]), 2) would work as well?
11:57:04 <byorgey> vincenz: I think you want liftA2.
11:57:09 <zeno> > (fst . snd . map) (*2) ((1, [1,2,3]), 2)
11:57:10 <lambdabot>   Couldn't match expected type `(a, b)'
11:57:10 <vincenz> maybe
11:57:12 <PeakerWork> zeno: Nope
11:57:18 <quicksilver> vincenz: FWIW that's not what bifunctor normally means
11:57:20 <orbitz> :t second
11:57:21 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
11:57:32 <PeakerWork> zeno: fst and snd just extract from a tuple, they don't convert an "editor function" to an "editor of fst/snd cell function"
11:57:33 <byorgey> @type liftA2
11:57:35 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:57:39 <byorgey> vincenz: ^^^
11:57:46 <vincenz> thanks
11:57:50 <vincenz> @info liftA2
11:57:50 <lambdabot> liftA2
11:57:55 <vincenz> :i liftA2
11:58:00 <b_jonas> > (first . fmap . map) (*2) ((1, [1,2,3]), 2)
11:58:02 <lambdabot>   ((1,[2,4,6]),2)
11:58:10 <byorgey> liftA2 f a b = f <$> a <*> b
11:58:16 <PeakerWork> @type liftA2 ($)
11:58:17 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f (a -> b) -> f a -> f b
11:58:29 <quicksilver> BiFunctor would be something like class BiFunctor f where fmap2 :: (a -> b) -> (c -> d) -> f a c -> f b d
11:58:33 <PeakerWork> @type liftA3 id
11:58:34 <lambdabot> forall b c d (f :: * -> *). (Applicative f) => f (b -> c -> d) -> f b -> f c -> f d
11:58:38 <zeno> PeakerWork: i see, neat
11:59:02 <vincenz> ah
11:59:05 <vincenz> I can't define pure:|
11:59:08 <PeakerWork> @type liftA3
11:59:09 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
11:59:19 <vincenz> My thing is not applicative
11:59:37 <PeakerWork> vincenz: you can combine values but you cannot put them inside? What's your type?
11:59:48 <vincenz> it's a triplet of three numbers
11:59:53 <vincenz> that should be combined pointwise
12:00:02 <byorgey> pure x = (x,x,x)  ?
12:00:11 <quicksilver> vincenz: that is applicative, yes.
12:00:19 <vincenz> byorgey: doesn't make sens
12:00:21 <quicksilver> n-tuplets of the same thing are applicative pointwise
12:00:38 <byorgey> well, for it to be a functor at all it needs to be a triplet of *things of the same type*, not just numbers
12:00:44 <ozy`> > (first . length) ("pizza", 4)
12:00:45 <lambdabot>   Couldn't match expected type `a b c' against inferred type `Int'
12:00:53 <vincenz> byorgey: I'm using a big of a hack :)
12:00:58 <quicksilver> pure x = (x,x,...,x); (f0,...,fn) <*> (x0,...,xn) = (f0 x0,...,fn xn)
12:01:04 <PeakerWork> ozy`: length is not an editor function
12:01:06 <ozy`> > first length ("pizza", 4)
12:01:08 <lambdabot>   (5,4)
12:01:19 <quicksilver> and finally fmap f (x0,...,xn) = (f x0,...,f xn)
12:01:27 <byorgey> vincenz: if you must use triples of numbers instead of triples of any type, you'll have to write liftA2/fmap2 yourself
12:01:29 <quicksilver> you will find that obeys all the Applicative laws.
12:01:32 <ozy`> PeakerWork: I haven't bothered how to use arrows yet
12:01:33 <byorgey> not like it's hard to write.
12:01:40 <ozy`> s/how/to learn how/
12:01:56 <PeakerWork> ozy`: the arrow methods implementation for ordinary function is useful separately from arrows
12:02:08 <ozy`> so I hear
12:02:34 <PeakerWork> ozy`: easiest to learn by example, IMO
12:02:36 <ozy`> ...will haskell' have a special syntax for arrows?
12:02:47 <PeakerWork> ozy`: it already has one (special do notation)
12:03:00 <byorgey> PeakerWork: well, it's not part of the standard
12:03:10 <byorgey> dunno if arrow notation will be included in the haskell' standard
12:03:31 <quicksilver> I doubt it.
12:03:38 <b_jonas> there's an array notation?
12:03:41 <quicksilver> Don't think it's really proven its worth, yet.
12:04:00 <ozy`> and, if it's easy to learn by example, point me towards some pages that teach by example instead of describing everything in terms of category theory
12:04:03 <byorgey> b_jonas: arrow, not array.
12:04:09 <b_jonas> is it like the monad do notation and the monadfix notation?
12:04:15 <ozy`> b_jonas: wait... she's in congress?
12:04:17 <byorgey> b_jonas: similar, yes.
12:04:30 <vincenz> byorgey: I just defined T a = T a a a
12:04:36 <vincenz> byorgey: it's just for a one-time-off script
12:04:55 <PeakerWork> > map ((*2)&&&(*3)) [1,2,3]
12:04:56 <lambdabot>   [(2,3),(4,6),(6,9)]
12:04:56 <byorgey> vincenz: ok, that's easy to make Applicative
12:05:01 <PeakerWork> ozy`: that kind of example ^^
12:05:23 <byorgey> vincenz: what's the problem?
12:05:28 <vincenz> nothing :)
12:05:30 <vixey> I hope Haskell' gets rid of arrows
12:05:33 <ozy`> :t &&&
12:05:35 <lambdabot> parse error on input `&&&'
12:05:40 <PeakerWork> ozy`: as for the (first . second . fmap) business, I suggest a short read at conal's blog: http://conal.net/blog/posts/semantic-editor-combinators/
12:05:44 <vincenz> pure just seemed odd to me, as the three numbers repsresent completely different quantities
12:06:37 <byorgey> vincenz: fair enough, so you won't ever call pure on a number.
12:06:46 <b_jonas> why?
12:06:53 <byorgey> but it makes sense to call it on a function, if you want to be able to apply functions pointwise.
12:07:25 <PeakerWork> ozy`: you need () around infix operators
12:07:29 <PeakerWork> :t (&&&)
12:07:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:07:33 <byorgey> b_jonas: why what?
12:07:36 <Megzlna> quicksilver:
12:07:37 <Megzlna> (+) ((+) ((+) ((+) ((+) 0 1) 2) 3) 4) 5
12:07:42 <PeakerWork> vixey: why don't you like arrows?
12:07:46 <Megzlna> is that what you're saying about Demand?
12:07:48 <b_jonas> why won't you ever call pure on a number?
12:07:49 <vixey> useless
12:07:50 <Megzlna> what is the next step?
12:08:00 <PeakerWork> vixey: what about arrows-without-arr?
12:08:08 <vixey> I don't know what that is
12:08:17 <Megzlna> without pirate noises
12:08:30 <byorgey> b_jonas: well, if the three quantities are in completely different units, for example, 'pure 2' might not really mean anything.
12:08:42 <PeakerWork> vixey: I think they should be useful as a generalization of the function type, in the sense that Functor is a generalization of the list type (and others, of course)
12:08:53 <byorgey> you would never want to, e.g. add 2 to each of the three quantities.
12:08:53 <Megzlna> So, in my expression, is the next demand innermost?
12:08:59 <byorgey> although I guess doubling all of them could make sense.
12:09:02 <vixey> I don't know how to define (->)
12:09:09 <vixey> I can define [] and derivatives though
12:09:20 <Megzlna> it *can't do* outermost!
12:09:30 <Megzlna> because (+) is strict
12:09:44 <PeakerWork> vixey: I guess most things arrows are used for are really performance, but they can also do things like Bijective functions (without arr, that is)
12:09:48 <Megzlna> i think I see what quicksilver was saying but not sure
12:10:03 <vixey> Megzlna: (+) ((+) ((+) ((+) ((+) 0 1) 2) 3) 4) 5 ~~> 16
12:10:06 <PeakerWork> Megzlna: I missed out your question before, what are you asking in general?
12:10:19 <vixey> Megzlna: why does it matter how it got there?
12:10:31 <teko> > "sdfds" :: Expression
12:10:32 <lambdabot>       Not in scope: type constructor or class `Expression'
12:10:39 <quicksilver> Megzlna: well of course the problem is that (+) is a primop
12:10:41 <Megzlna> Peaker: I stated that Haskell was outermost first evaluation and quicksilver opposed me and said its demand based
12:10:46 <Megzlna> So
12:10:51 <Megzlna> I just traced another foldl
12:10:53 <quicksilver> Megzlna: so it's a bit hard to deconstruct the next step.
12:11:00 <Megzlna> and when I got to (+) ((+) ((+) ((+) ((+) 0 1) 2) 3) 4) 5
12:11:04 <Megzlna> i realized I could not progress
12:11:08 <PeakerWork> Megzlna: What does "outer-most" mean?
12:11:10 <vixey> yes you could
12:11:10 <quicksilver> Megzlna: the first (+) demands both its parameters
12:11:18 <quicksilver> Megzlna: the '5' is already ok
12:11:25 <quicksilver> Megzlna: but it also demands the left parameter
12:11:27 <Megzlna> quicksilver: But, that goes instantly to innermost demand
12:11:31 <quicksilver> so now we have to progress that
12:11:32 <Megzlna> the outermost demands innermost
12:11:36 <quicksilver> as it happens, yes it does
12:11:42 <quicksilver> for this fully strict expression
12:11:46 <quicksilver> but that doesn't always happen
12:11:53 <dolio> Why are we writing everything prefix?
12:12:04 <quicksilver> that's because this particular expression is strict all the way down
12:12:05 <vixey> idk :/
12:12:09 <Megzlna> dolio: it was from a fold
12:12:10 <vixey> I think the whole discussion is silly
12:12:13 <quicksilver> dolio: to make it clear what the 'head' was.
12:12:14 <dolio> So?
12:12:25 <Megzlna> let me paste:
12:12:26 <quicksilver> dolio: in the sense of 'weak head normal form'
12:12:33 <quicksilver> so we could work out which part to reduce next.
12:12:42 <quicksilver> small-step operational semantics of haskell.
12:12:42 <dolio> Hmm.
12:13:16 <PeakerWork> Megzlna: I think each kind of expression has its own rules about what to force first
12:13:23 <PeakerWork> Megzlna: A function application forces the function first
12:13:38 <PeakerWork> Megzlna: Some functions force their first argument first, some force the second, etc
12:13:45 <vixey> PeakerWork, I think there is one rule
12:14:02 <Megzlna> http://hpaste.org/13103
12:14:10 <PeakerWork> vixey: Just the function application rule?
12:14:13 <Megzlna> dolio, thats why (+)
12:14:16 <mpeter> the heffalump in here is an imposter!!!
12:14:52 <mpeter> at least, that's what the evidence suggests
12:15:48 <dolio> Well, that's doing it to, but it doesn't say why.
12:15:55 <quicksilver> vixey: I don't think it's a silly discussion, although it may have progressed in a silly way.
12:16:16 <quicksilver> vixey: you have to have some evaluation model to explain why "take 5 $ [1..]" doesn't diverge.
12:16:22 <quicksilver> that's why the question comes up at all.
12:16:37 <quicksilver> In the strictly total fragment, there is an evaluation-order independent semantics.
12:16:50 <vixey> who expects  take 5 $ [1..]  to diverge?
12:16:50 <dolio> I could write evaluation like "foldl f z (a:as) ==> foldl f (z `f` a) as ..." if I wanted.
12:17:02 <quicksilver> vixey: it would do in ML for example.
12:17:12 <athos> > take 5 $ [1..] == [1,2,3,4,5]
12:17:13 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Bool'
12:17:25 <athos> > take 5 [1..] == [1,2,3,4,5]
12:17:26 <lambdabot>   True
12:17:27 <athos> ,_,
12:17:32 <lunabot>  luna: parse error on input `)'
12:17:44 <vixey> I'm saying that you don't want to look at execution (aka operational semantics) because then you are just looking haskell via ML
12:18:04 <Megzlna> (First try Outermost first) (If multiple possibilities, go Left to right) (If cannot reduce and strict, go to next Innermost based on demand) (Next innermost potentially descends likewise all the way down to most innermost, producing a strict value)
12:18:19 <quicksilver> even in the strictly total fragment (where evaluation order doesn't affect semantics) you still have to consider evaluation order to understand time and space.
12:18:22 <vixey> this happens a lot with people learning Prolog -- they just treat it like whatever they are used to instead of as Prolog because it's aesier to do so
12:18:34 <chrisdone> @hoogle (m a, m b) -> m (a,b)
12:18:34 <lambdabot> No results found
12:19:11 <quicksilver> vixey: OK, so in your semantic model, what's the value of "take 1 . reverse . reverse $ [1..] " ?
12:19:14 <Saizan> ?type uncurry (liftM2 (,))
12:19:14 <quicksilver> (and why?)
12:19:15 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
12:19:37 <Megzlna> vixey I'm not sure what your opposition towards understanding evaluation is but you seem to be biased
12:19:41 <chrisdone> Saizan: oh, nice one :D
12:19:42 <vixey> quicksilver, I'm just talking about building intuition not formal model of haskell
12:19:51 <C-Keen> hm can I build ghc-6.8.3 with ghc-6.10 ?
12:19:52 <vixey> Megzlna, I already showed you a lazy evaluator ...
12:20:33 <Megzlna> a good understanding of foldr isnt intuition based unless you spend months of coding
12:20:36 <Megzlna> i usually bypass that
12:20:42 <quicksilver> vixey: well I think the intuition is helpful yes, but it's only partly helpful when it gets stuck like that.
12:21:06 <Megzlna> why spend months getting intuition when you can go to something immediately through dissection
12:21:14 <quicksilver> similarly, what does your semantic model tell you about the time complexity of "foldl1 (++) . map return $ [1,2,3,4,5,6]"
12:22:03 <dolio> Time complexity. What's that?!
12:23:29 <insitu`> hello, I am trying to install a fresh up-to-date haskell env. Compiling ghc-6.10 works like a charm. I have troubles compiling cabal-install-0.6.0.0, specifically in zlib-0.4.0.4:  compiling dist/build/Codec/Compression/Zlib/Stream_hsc_make.c failed
12:23:30 <insitu`>  
12:23:33 <Saizan> well, in the outermost-leftmost evaluation you still need to add a rule for pattern matching
12:23:44 <Saizan> and that will solve the problem of (+)
12:24:00 <Megzlna> Saizan: What did I leave out?
12:25:02 <Megzlna> Saizan: How to update rule at bottom of page? http://hpaste.org/13105
12:25:04 <blackh> insitu: I think you need the libz-dev package for your OS
12:25:38 <Megzlna> I'm not sure how the pattern match clause goes in there
12:25:51 <blackh> insitu: On Ubuntu it's zlib1g-dev
12:26:28 <Saizan> well that "and strict" means that the function pattern matches on its argument
12:26:46 <Megzlna> eh?
12:27:06 <Megzlna> can you demonstrate on the simplest possible func
12:27:26 <vixey> look at 1, 2, 3, ... as individual constructors
12:27:28 <Saizan> aside from seq and primitives like (+), the only way to force a value is to pattern match on it
12:27:31 <vixey> (+) defined like:
12:27:33 <vixey> 1 + 0 = 1
12:27:36 <vixey> 3 + 2 = 5
12:27:37 <vixey> ...
12:27:46 <insitu`> blackh: much better. Thanks a lot ! The reason I am not installing from aptitude is that I want to install gitit, and I had issues when compiling it using 6.8.2 which ships with ubuntu and friends
12:28:01 <Megzlna> Saizan: Can you show me on lambdabot please?
12:28:06 <maltem_> @src (&&)
12:28:06 <lambdabot> True  && x = x
12:28:06 <lambdabot> False && _ = False
12:28:07 <BONUS_> > randomR ('a','z') (mkStdGen 100)
12:28:07 <vixey> this way you only need one evaluation rule to cover the whole foldr thing
12:28:08 <lambdabot>   ('n',4041414 40692)
12:28:12 <BONUS_> > randomR ('a','z') (mkStdGen 101)
12:28:13 <lambdabot>   ('n',4081428 40692)
12:28:14 <BONUS_> > randomR ('a','z') (mkStdGen 102)
12:28:16 <lambdabot>   ('n',4121442 40692)
12:28:18 <BONUS_> what's up with the 'n'
12:28:23 <blackh> insitu`: I'm using the pre-built binary of ghc 6.10.1 on Ubuntu x86_64, which works, but compiling works just as well, of course.
12:28:38 <maltem_> Megzlna: (&&), as illustrated above, pattern-matches against its first argument
12:28:39 <Saizan> Megzlna: look at the (&&) definition, it's strict in the left argument because it pattern matches on it
12:28:42 <Megzlna> > let f x = x in f 1    -- forcing a value
12:28:44 <lambdabot>   1
12:29:10 <maltem_> > 1 -- equivalent
12:29:11 <lambdabot>   1
12:29:26 <Saizan> yeah, id is strict because it returns the value it gets
12:29:40 <Saizan> but the evaluation doesn't happen during the evaluation of it
12:29:42 <orbitz> @src id
12:29:42 <lambdabot> id x = x
12:29:44 <Saizan> "id"
12:29:49 <BONUS_> anyone know why randomR for Char is borked?
12:29:54 <Saizan> but during the evaluation of the caller
12:29:57 <Taejo> :t randomR
12:29:58 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
12:30:10 <BONUS_> > randomR ('A','Z') (mkStdGen 3000)
12:30:11 <lambdabot>   ('N',120082014 40692)
12:30:14 <BONUS_> > randomR ('A','Z') (mkStdGen 2)
12:30:16 <lambdabot>   ('N',120042 40692)
12:30:20 <BONUS_> it's always 'N'
12:30:24 <orbitz> BONUS_: is it just in lambda bot?
12:30:27 <BONUS_> no
12:30:29 <BONUS_> its my comp too
12:30:38 <BONUS_> for the interval 'a'..'z' it's 'n'
12:30:49 <mauke> @check ('n' ==) . fst . randomR ('a','z') . mkStdGen
12:30:50 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
12:30:51 <BONUS_> can anyone else try it in their ghc
12:30:52 <Saizan> Megzlna: so, "ow the outermost (+) instantly demands the results of the innermost (+) to progress.
12:30:55 <orbitz> BONUS_: but you won't nkow it's n unless you try forever!
12:31:01 <BONUS_> haha
12:31:07 <augustss> > randomR ('A','Z') (mkStdGen 300055557)
12:31:09 <lambdabot>   ('N',1989980642 40692)
12:31:13 <insitu`> BTW, is this the place for questions about gitit ?
12:31:13 <mauke> > fst . randomR ('a','z') . mkStdGen $ 0
12:31:15 <lambdabot>   'd'
12:31:21 <mauke> > fst . randomR ('a','z') . mkStdGen $ 1
12:31:22 <maltem_> Saizan: I find it a little confusing to talk about several "places" of evaluation
12:31:23 <lambdabot>   'n'
12:31:38 <orbitz> BONUS_: what imports do i need?
12:31:42 <vixey> nobody mentions graph reduction
12:31:44 <BONUS_> System.Random
12:31:47 <Saizan> Megzlna: there "instantly" is a bit misleading, because it doesn't jump to the innermost, it recurses pushing the layers on the stack
12:31:51 <mauke> @check \x -> x > 0 ==> (('n' ==) . fst . randomR ('a','z') . mkStdGen) x
12:31:52 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:31:52 <lambdabot>           ...
12:31:54 <maltem_> Saizan: but I suppose that is how people think anyway
12:32:02 <orbitz> BONUS_: i get N as well
12:32:04 <conal> BONUS_: i get 'N' on my linux 6.10.1
12:32:14 <Megzlna> Saizan: Was wrong... or?
12:32:17 <orbitz> @src randomR
12:32:17 <lambdabot> Source not found.
12:32:22 <Megzlna> oh was scrolled up
12:32:23 <augustss> Only two places does evaluation.  case and function application (evaluating the function)
12:32:28 <BONUS_> @check \i -> i /= 0 ==> fst (randomR ('A','Z') (mkStdGen i)) == 'N'
12:32:30 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:32:30 <lambdabot>           ...
12:32:44 <Megzlna> Saizan: yeah I thought I explained the "instantly" part by enumerating upon steps below
12:32:49 <Megzlna> k
12:33:00 <mauke> *> quickCheck $ \x -> x /= 0 ==> (('n' ==) . fst . randomR ('a','z') . mkStdGen) x
12:33:03 <mauke> OK, passed 100 tests.
12:33:14 <BONUS_> wtf
12:33:18 <blackh> BONUS_: mkStdGen must always start with the same seed because it's the same for numbers.
12:33:24 * Megzlna feels way more comfortable about lazy now
12:33:32 <augustss> mkStdGen 1
12:33:37 <augustss> > mkStdGen 1
12:33:39 <lambdabot>   2 1
12:33:50 <BONUS_> what do you mean
12:33:51 <augustss> > mkStdGen 100000
12:33:52 <lambdabot>   100001 1
12:34:01 <PeakerWork> From Wikipedia's Graph_reduction: "Outermost graph reduction is referred to as lazy evaluation and innermost graph reduction is referred to as eager evaluation."
12:34:21 <Megzlna> http://en.wikibooks.org/wiki/Haskell/Graph_reduction
12:34:31 <vixey> Megzlna: you know this fibs example?  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
12:34:40 <Saizan> maltem_: well, i mix the graph and stack view of expressions in my mind :)
12:34:44 <augustss> > mkStdGen 999999999
12:34:46 <lambdabot>   1000000000 1
12:35:03 <augustss> BONUS: mkStdGen isn't very good
12:35:13 <Megzlna> vixey: wattaboutit
12:35:20 <vixey> Megzlna: if you evaluate it using equational rewrites you get huge complexity blow up but with graph reduction (rewriting on the nodes as you go) it is linear time
12:35:23 <blackh> BONUS_: I know what the problem is.  mkStdGen takes a number, and that's the seed. So it will always give the same sequence given the same number.  Use getStdGen
12:35:35 <augustss> BONUS: you should step the generator a few times before using it
12:35:49 <Megzlna> vixey: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
12:35:57 <BONUS_> yeah but shouldnt it give a different number given a stdgen made with a different seed
12:36:00 <mauke> blackh: but it's not given the same number
12:36:00 <BONUS_> most of the time at least
12:36:04 <quicksilver> PeakerWork: I don't think that wikipedia is correct, in fact.
12:36:21 <agruman> i want to generate all subsets of a given set, my code: http://hpaste.org/13106#a0 but it does not produce the correct result, and i cant seem to find the problem, any help is appreciated.
12:36:24 <blackh> mauke: Then ignore everything I said!
12:36:31 <orbitz> Megzlna: fibs is not factorial
12:36:32 <Megzlna> quicksilver: incorrect how?
12:37:03 <pumpkin> agruman: try looking up source for subsequences
12:37:08 <pumpkin> , subsequences [1..5]
12:37:11 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[...
12:37:11 <mauke> agruman: 'tails' already exists, you don't need to redefine it
12:37:15 <BONUS_> this is weird
12:37:50 <Megzlna> orbitz: it is closely related to what she was saying
12:37:58 <Megzlna> (from Cale:) http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=628#a628
12:37:59 <mauke> agruman: [a] ++ as better written as a : as
12:38:06 <Megzlna> Factorial with sharing
12:38:16 <agruman> mauke its part of my assignment, thats why ive done my "own".
12:38:34 <agruman> mauke, yes i suppose it is :)
12:39:22 <SKuhn> how can I use HUnit with ubuntu? i installed the libghc6-hunit-dev /doc, but  an example says Could not find Module HUnit
12:39:58 <blackh> SKuhn: Test.HUnit?
12:40:09 <vixey> Megzlna, yes exactly this way.. It is a last resort to look at program execution though.. the best thing lazyness gives is the ability to not care about evaluation order
12:40:40 <vixey> (sometimes haskell isn't lazy enough though http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=562 )
12:41:05 <SKuhn> blackh: oh, thx
12:44:02 <teko> @src subsequences
12:44:03 <lambdabot> Source not found. stty: unknown mode: doofus
12:44:13 <hydo> heh
12:45:58 <Megzlna> > subsequences $ permutations [1..3]
12:45:59 <lambdabot>   Not in scope: `subsequences'Not in scope: `permutations'
12:46:07 <roconnor> is the indefinite integral technically the same thing as the anti-derivative?
12:46:17 <Megzlna> , subsequences $ permutations [1..3]
12:46:17 <teko> , subsequences $ permutations [1..3]
12:46:19 <lunabot>  [[],[[1,2,3]],[[2,1,3]],[[1,2,3],[2,1,3]],[[3,2,1]],[[1,2,3],[3,2,1]],[[2...
12:46:21 <lunabot>  [[],[[1,2,3]],[[2,1,3]],[[1,2,3],[2,1,3]],[[3,2,1]],[[1,2,3],[3,2,1]],[[2...
12:47:04 <teko> , subsequences $ permutations [1,2..2]
12:47:05 <lunabot>  [[],[[1,2]],[[2,1]],[[1,2],[2,1]]]
12:47:59 <mauke> agruman: http://hpaste.org/13106#a1
12:48:55 <Gracenotes> I wonder if there's a monad that has the side effect of destroying the earth
12:49:16 <Taejo> Gracenotes, IO
12:49:30 <Gracenotes> hm, possibly
12:51:23 <Gracenotes> I think I basically 'get' monads at this point... at least superificially
12:51:43 <Taejo> roconnor, apparently antiderivative has another meaning in differential geometry
12:52:02 <Gracenotes> basically chaining functions with "hidden" state
12:52:14 <Gracenotes> although I think I need to look at more examples
12:53:21 <sereven> Gracenotes: the monads used by Barclay's and Credit Suisse? ***ducks
12:53:58 <agruman> mauke, thanks alot
12:54:08 <Gracenotes> would that it were I knew what you meant
12:54:49 <sereven> international financial crisis <- sophisticated financial derivatives, ok, stupid bad joke
12:55:15 <roconnor> Taejo: mathworld says the indefinite integral is the same thing as an antiderivative, so I'll go with that.
12:55:18 <Gracenotes> ha. ha. >_> yeah, no one tutorial really did it -- looking at a bunch of them
12:55:46 <Gracenotes> first Maybe, then Writer, then List
12:56:22 <Cale> Gracenotes: have you lookes at State yet?
12:56:28 <Cale> looked*
12:57:13 <Taejo> roconnor, yeah, I was told that by my CA lecturer (who preferred the name "primitive") that the reason he said primitive is because antiderivative is something else
12:57:36 <Cale> I missed part of this conversation, but it's obviously a good example of a monad for which the values are functions which chain state along.
12:57:50 <Gracenotes> I've heard of it, yes. I think it provides a sort of 'context' for the the functions passed...? I'll check it out in RWH after looking through the Wikibooks randgen function
12:58:06 <roconnor> Taejo: primitive sounds good
12:58:16 <Cale> You have something along the lines of  data State s a = S (s -> (s,a))
12:58:28 <Taejo> roconnor, what's this for?
12:58:41 <Cale> That is, we represent a stateful computation as a function from initial state to (final state, result) pairs.
12:59:15 <Gracenotes> how does a function get the state passed to it?
12:59:32 <Cale> We assume that the state will be passed to it at some point.
12:59:39 <vixey> by >>= Gracenotes
12:59:48 <Cale> Or:
12:59:57 <Cale> runState (S f) s = f s
13:00:20 <Cale> Which applies the function to a given initial state s
13:00:31 <Cale> at which point it will reply with the final state and its result
13:00:44 <Gracenotes> as a means of 'escaping' from the monad, basically?
13:00:58 <Cale> If you want to use such painful terminology, yes :)
13:01:05 <Cale> As a way of running the computation.
13:01:27 <hellige> don't say escaping...
13:01:30 <Cale> runState :: State s a -> s -> (s,a)
13:01:36 <hellige> escaping implies that you use it "from within the monad"
13:01:43 <hellige> but you don't, you use it from outside the monad.
13:01:55 <Cale> It takes a (State s) computation, and an initial state, and runs it to produce a final state and a result.
13:01:56 <hellige> instead of "escaping from the monad", think of "containing the monad". :)
13:02:09 <Cale> hellige: wha?
13:02:17 <Cale> The monad is a type constructor.
13:02:45 <Cale> It's not even at the value level. There are lots of values which are members of types which are constructed by it, but they are not called monads.
13:03:15 <Gracenotes> hellige: the Gracenotes monad takes input from tutorials, runs it through his idea of a monad, and outputs a more complete idea of a monad
13:03:30 <hellige> Gracenotes: :)
13:03:35 <Gracenotes> however, Gracenotes is limited in his ability to explain monad terminology <_<
13:03:37 <Cale> In functional programming, they're typically called computations or actions, or more generally, monadic values.
13:04:05 <hellige> cale: beginners tend to make a certain mistake, i think it's because they see IO first...
13:04:26 <vixey> I used IO first
13:04:28 <Cale> For instance, IO is a monad. getLine is not a monad.
13:04:33 <hellige> Cale: so they tend to want to think of functions like run* :: m a -> a (or whatever) as being a way of "escaping" from the monad.
13:05:07 <lament> mission impossible: escape from the monad
13:05:08 <Gracenotes> would 'extracting' the value from the monad be slightly more accurate?
13:05:12 <Cale> In some sense, that's right. But 'escaping' is such loaded terminology, and fails to express what such a function actually is doing.
13:05:18 <hellige> exactly!
13:05:25 <lament> Gracenotes: "running" would be more accurate still, which is why these functions are called "run" and not "extract" or "escape"
13:05:35 <Cale> Extracting also kind of misses the point, though it makes some kind of sense for container-like monads.
13:05:46 <hellige> that's why i suggest that people should say "contain" the monadic computation, although i guess that's also misleading.
13:06:03 <Cale> For example, for the list monad, functions which extract one of the values of a list would be like this.
13:06:07 <hellige> but what i mean is that you'll write a function like (say) a -> b,
13:06:12 <Cale> However, such functions are also necessarily partial.
13:06:23 <Cale> Well, that's not completely true...
13:06:25 <hellige> and internally it may build an m b, but then it uses runM to "contain" that fact.
13:06:35 <Cale> runList :: a -> [a] -> a
13:06:43 <hellige> so it doesn't reveal the "m" in its type.
13:06:48 <Cale> runList z [] = z
13:06:53 <Cale> runList z (x:xs) = x
13:07:14 <Gracenotes> > do { x <- [1,2], y <- [3,4]; return (x, y) }
13:07:15 <lambdabot>   <no location info>: parse error on input `,'
13:07:22 <Gracenotes> oh noes.
13:07:30 <Cale> > do { x <- [1,2]; y <- [3,4]; return (x, y) }
13:07:31 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
13:07:42 <Gracenotes> ah, all semi-colons
13:07:58 <Gracenotes> > do { x <- [1,2]; y <- [3,4]; return [x, y] }
13:08:00 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
13:08:18 <elliottt> > [ [x,y] | x <- [1,2], y <- [3,4]]
13:08:19 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
13:08:22 <hellige> anyway, that's what i meant. i hope it's clear enough. sorry to sidetrack the conversation... :(
13:08:40 <Gracenotes> so, how would you involve the function runList in the psuedo-list-comprehension monad?
13:08:48 <Cale> Gracenotes: okay, so we have this type constructor (State s)
13:08:51 <milian-laptop> I wanna check if a string is of quadratic length, but always get "ERROR - Cannot infer instance" when I do something like `sqrt (length "foobar")`
13:08:54 <milian-laptop> hints?
13:09:18 <roconnor> Taejo: I wanted to claim that the indefinite intetgral (over R) of 1/x is ln |x| and not ln x
13:09:22 <lament> :t sqrt
13:09:23 <lambdabot> forall a. (Floating a) => a -> a
13:09:34 <roconnor> Taejo: but I figured I should double check the techinical definition of indefinite integral
13:09:36 <Cale> Gracenotes: You could use it to pick an element of the resulting list, or else take the default value you supplied, if the list was empty.
13:09:38 <insitu`> are the external dependencies of haskell packages declared somewhere ?
13:09:43 <roconnor> before considering functions that are not total
13:09:57 <conal> hellige: hi.  i've started using your your nifty f~>g notation.
13:09:59 <lament> milian-laptop: try fromIntegral . length
13:10:08 <lament> milian-laptop: the issue is converting from Int to Floating
13:10:20 <conal> (for others: http://matt.immute.net/content/pointless-fun)
13:10:21 <milian-laptop> lament: thanks, I knew the issue but searched for something like "toFloat" ...
13:10:27 <Taejo> roconnor, heh, I was trying to remember this morning if it was S 1/x dx = log |x| or S 1/|x| dx = log x
13:10:29 <Gracenotes> > runList (0, 0) (do { x <- [1,2]; y <- [3,4]; return (x, y) })
13:10:30 <lambdabot>   Not in scope: `runList'
13:10:37 <hellige> conal: ah, cool! how do you find it? useful?
13:10:41 <Gracenotes> oh, hm.
13:10:55 <Cale> Gracenotes: I just invented that function as an example.
13:11:01 <athos> @src finally
13:11:01 <lambdabot> a `finally` sequel = block $ do
13:11:01 <lambdabot>     r <- catch (unblock a) (\e -> do { sequel; throw e })
13:11:01 <lambdabot>     sequel
13:11:01 <lambdabot>     return r
13:11:10 <Gracenotes> ah.
13:11:16 <conal> hellige: useful and pretty.  that pattern comes up a lot.
13:11:17 <Cale> @let runList z [] = z; runList z (x:xs) = x
13:11:18 <lambdabot>  Defined.
13:11:24 <Cale> > runList (0, 0) (do { x <- [1,2]; y <- [3,4]; return (x, y) })
13:11:25 <lambdabot>   (1,3)
13:11:36 <Cale> > runList (0, 0) (do { x <- [1,2]; y <- [3,4]; guard (x^2 + y^2 > 10) return (x, y) })
13:11:37 <lambdabot>   Couldn't match expected type `(t2, t2) -> [(t, t1)]'
13:11:39 <Cale> > runList (0, 0) (do { x <- [1,2]; y <- [3,4]; guard (x^2 + y^2 > 10); return (x, y) })
13:11:41 <lambdabot>   (1,4)
13:11:45 <Cale> heh
13:11:47 <Cale> > runList (0, 0) (do { x <- [1,2]; y <- [3,4]; guard (x^2 + y^2 > 100); return (x, y) })
13:11:49 <lambdabot>   (0,0)
13:11:49 <hellige> conal: good! yeah, i feel like i'd encountered it a lot, but all the examples i could think of were a bit forced.
13:11:51 <lament> milian-laptop: yeah, the from- family of functions seems a bit odd at first
13:12:00 <hellige> conal: so i haven't really used it "in anger"...
13:12:35 <conal> hellige: i see it particularly when f & g are inverses.  (foo ~> unFoo) for working on a more convenient representation.
13:12:48 <Gracenotes> Cale: and runMaybe would probably be the same thing as fromJust, then?
13:13:01 <Cale> Gracenotes: well, fromMaybe would be better.
13:13:05 <Cale> :t fromMaybe
13:13:06 <lambdabot> forall a. a -> Maybe a -> a
13:13:17 <Gracenotes> ah, yeah, the default value
13:13:19 <Cale> (perfectly analogous to my runList)
13:13:23 <hellige> conal: yes, newtypes especially are something that occurred to me.
13:13:23 <dolio> "I stumbled upon something that looks weird to me: 2x-3x performance loss when a module is renamed to a longer name!" Awesome.
13:13:26 <Gracenotes> :t runState
13:13:27 <lambdabot> forall s a. State s a -> s -> (a, s)
13:13:45 <Cale> So here, the s which you provide isn't a default. It's the initial state.
13:13:54 <conal> hellige: newtype wrap/unwrap is my most frequent use
13:14:04 <conal> Foo ~> uFoo
13:14:07 <conal> Foo ~> unFoo
13:14:08 <Cale> Though, that will become the final state in the case that the state never changes.
13:14:33 <conal> inFoo = Foo ~> unFoo
13:14:44 <Gracenotes> okay, I'll read up on State in RWH and/or Wikibooks and/or all_about_monads
13:14:49 <conal> did i get that backwards?
13:14:55 <Cale> Well, if you like, I can step through it here :)
13:15:10 <conal> yeah, inFoo = unFoo ~> Foo
13:15:11 <Cale> Let's look at implementing return, >> and >>=
13:15:18 <Megzlna> guys know anything about FGL vs. Data.Graph?
13:15:35 <Gracenotes> return would presumably make a value into an empty state coupled with a value
13:15:49 <Cale> Megzlna: I don't particularly like either of them, though if I was going to use one, it would be FGL.
13:16:10 <Cale> Gracenotes: let's try to write it
13:16:19 * vixey usually gets by with data Graph = a :-->: [Graph a]
13:16:21 <Cale> return :: a -> State s a
13:16:28 <Cale> return v = ...
13:16:47 <Cale> For graphs, I usually use  Map Vertex (Set Vertex)
13:17:04 <Megzlna> Cale, why reimplment the algorithms yourself?
13:17:12 <Gracenotes> hm, what's the State constructor?
13:17:18 <Megzlna> Dont Graph and FGL just use those structures anyways?
13:17:23 <vixey> Gracenotes, (,)
13:17:23 <Cale> newtype State s a = S (s -> (s,a))
13:17:26 <Cale> for us
13:17:28 <vixey> oh :(
13:17:33 <vixey> It's got to be a newtypeeee
13:17:39 <Cale> Or data, if you prefer
13:18:03 <Cale> So for us, we have  S :: (s -> (s,a)) -> State s a
13:18:34 <Cale> In the libraries, they have the pair swapped around (which I think is ugly for a technical reason), and the constructor is called State
13:18:50 <Cale> But the whole point of making this thing a monad will be so that we don't have to explicitly use the constructor.
13:19:03 <Cale> (well, that and the get and put operations)
13:19:39 <Cale> So, we don't have many ways yet to make a value of type State s a, just this S constructor
13:19:42 <Cale> So probably:
13:19:46 <Cale> return v = S (...)
13:20:02 <Cale> What goes in the (...) must be a function of type s -> (s,a)
13:20:08 <Cale> So might as well use a lambda
13:20:15 <Cale> return v = S (\s -> ...)
13:20:24 <Gracenotes> \s -> (s,a) is seems basic enough... I suppose
13:20:34 <Cale> \s -> (s,v)
13:20:38 <Cale> But yeah :)
13:20:50 <Cale> return v = S (\s -> (s,v))
13:21:05 <Cale> It passes the initial state through to the final state, and has result v.
13:21:27 <Gracenotes> and ultimately, when runState is run, the function will be called?
13:21:35 <Cale> Which is entirely appropriate. return v in an arbitrary monad is supposed to be the action which "does nothing" and returns v.
13:21:41 <Cale> yes
13:22:00 <Cale> Now, how about x >> y
13:22:03 <Gracenotes> or will it be called when passing the value to the next monad?
13:22:12 <Cale> 'next monad'?
13:22:16 <Cale> We only have one monad here
13:22:20 <Cale> It's (State s)
13:22:22 <Gracenotes> heh. uh, next linked function
13:22:29 <Megzlna> Actions
13:22:45 <Cale> Well, yeah, we're going to have a way of constructing actions which run other actions as part of their work.
13:23:30 <Cale> If x and y are two actions, then x >> y is supposed to be the action which first runs x with the initial state, then runs y after, with a possibly modified state.
13:23:46 <Gracenotes> x >> y... means that whatever x does, it affects the state, but it doesn't affect what y does independent of the state
13:23:52 <Cale> hm?
13:23:54 <Gracenotes> to the extent that that makes sense
13:24:16 <Cale> Well, the return value from x will be ignored.
13:24:27 <seanos_s> Hi, totally new to haskell, working through the tutorial, where can I find a solution to excercise 4.7 please? i'm stuck
13:24:28 <Cale> Only its effect on the state will be carried through to y
13:24:35 <Cale> seanos_s: which tutorial?
13:24:49 <seanos_s> Yet another haskell tutorial
13:24:54 <pumpkin> int-e: *worship*
13:25:00 <Cale> I think there are solutions at the back...
13:25:22 <seanos_s> Cale: Your right, sorry!
13:25:28 <Cale> seanos_s: no problem :)
13:25:39 <Cale> Gracenotes: So, let's try writing (>>)
13:25:43 <Cale> x >> y = ...
13:25:59 <Cale> We know that the type is:
13:26:07 <Cale> (>>) :: State s a -> State s b -> State s b
13:26:28 <Gracenotes> hm, yes.
13:26:29 <Cale> So the result here must be an action. We still don't have a lot of ways to make those, so we'll use the constructor.
13:26:38 <Cale> x >> y = S (...)
13:26:45 <Cale> and as before, we might as well use a lambda
13:26:51 <Cale> x >> y = S (\s -> ...)
13:27:13 <Cale> Now we get to the interesting part. We said we want to run x with the initial state, which is s
13:27:32 <Cale> x >> y = S (\s -> let (s',v) = runState x s in ...)
13:27:47 <Cale> So we do that, and get a final state from running x, called s'
13:27:49 <Gracenotes> some analogue to (s, a) would probably go in its place, except we don't have an a.
13:27:52 <Cale> and a result called v
13:28:18 <Cale> See how that line works so far?
13:28:21 <Gracenotes> a is gotten from... hm... damn kids in the next room blaring rap music :/
13:28:27 <Gracenotes> yeah.
13:28:46 <Cale> Now, we want to run y with which initial state?
13:29:03 <Gracenotes> sorry, let me get some headphones really quickly :)
13:29:07 <Cale> okay
13:29:55 * Cale is listening to music just with 3 acoustic guitars :)
13:30:17 <Botje> Cale is so rich he can afford a private guitar concert?
13:30:19 <Cale> (John McLaughlin with Al DiMeola & Paco DeLucia)
13:30:24 <Cale> heh
13:30:28 <Cale> I wish
13:30:29 <taari> G3?
13:30:56 <Cale> It's an album called "Passion, Grace and Fire"
13:31:02 * maltem_ is motivated to get Friday Night playing
13:31:15 <Gracenotes> so, we want to run y with state s', but not with the input of v.
13:31:23 <Cale> right
13:31:31 <Cale> We don't have a way to use v
13:31:46 <Cale> So we'll just drop v on the floor, and run y with the new s'
13:31:50 <chrisdone> Gracenotes: if you go round and pretend to like their music, it will become uncool
13:32:01 <Cale> x >> y = S (\s -> let (s',v) = runState x s in runState y s')
13:32:10 <Gracenotes> chrisdone: if only it were that easy!
13:32:11 <chrisdone> Gracenotes: either that or you'll find yourself at a rap battle next week
13:32:24 <Cale> and we want the result and final state from running y to be the result and final state of the whole thing, so we're dong
13:32:25 <Cale> done*
13:32:27 <Cale> heh
13:32:28 <sbahra> Looks like we got a team together for Haskell on FreeBSD :-P
13:32:29 <Gracenotes> @src runState
13:32:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:32:30 <sbahra> yay
13:32:39 <sbahra> and 1 more exam to go
13:32:50 <Cale> Gracenotes: remember that runState (S f) s = f s
13:33:16 <Gracenotes> yes, was just looking to get a glance at it
13:33:42 <Cale> Okay, so it's a little upsetting perhaps, at least it should be, that we're dropping v on the floor and not using it for anything
13:34:10 <Cale> So suppose we wanted to use it to determine the future of the computation? What might we do?
13:34:16 <Gracenotes> it could be useful for initially setting the state
13:34:35 <Cale> Well, it's of a completely unrelated type from the state, as far as we know.
13:34:45 <Gracenotes> hm, true.
13:35:02 <Cale> But what we might do is turn y into a function of v
13:35:22 <Cale> and then pass the v along to that function
13:35:42 <Cale> while we're at it, we'll rename >> to >>=
13:35:57 <Cale> we had:
13:36:00 <Cale> x >> y = S (\s -> let (s',v) = runState x s in runState y s')
13:36:03 <Cale> and now
13:36:07 <Cale> x >>= y = S (\s -> let (s',v) = runState x s in runState (y v) s')
13:37:00 <Gracenotes> :type (>>=)
13:37:00 <Cale> It's important to notice of course, that the type of this thing has changed, from:
13:37:10 <Cale> (>>) :: State s a -> State s b -> State s b
13:37:10 <Cale> to
13:37:12 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
13:37:43 <chrisdone> âwoopsâ
13:37:45 <Gracenotes> ...the end?
13:37:57 <Cale> grumble
13:37:57 <chrisdone> must've accidentally quit
13:37:58 <Cale> did you get that?
13:38:01 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
13:38:02 <Gracenotes> yep
13:38:05 <Cale> okay
13:38:11 <Cale> So does that make sense?
13:38:32 <Cale> One moment while I reset my IRC client. It's not rejoining channels automatically for some reason.
13:38:46 <Megzlna> why do I have to write data constructors in .hs files for it to work?
13:38:57 <Gracenotes> to an extent. y has to take an a (the result of the previous state) and return a state
13:38:58 <Megzlna> in GHCI they just give a parse error
13:38:59 <athos> > toUpper 'Ã¤'
13:39:00 <lambdabot>   '\196'
13:39:01 <Cale> okay
13:39:04 <dibblego> Megzlna, do you mean opposed to ghci?
13:39:14 <sbahra> > tuUpper '{'
13:39:15 <lambdabot>   Not in scope: `tuUpper'
13:39:16 <Megzlna> yes dibblego
13:39:21 <sbahra> > toUpper '{'
13:39:22 <lambdabot>   '{'
13:39:26 <sbahra> > toUpper '['
13:39:27 <lambdabot>   '['
13:39:31 <Cale> Gracenotes: It depends on the result of the previous computation now, not just the final state.
13:39:40 <Philippa_> Megzlna: you mean type declarations. Mostly because it's never been worth anyone's while to implement, I suspect
13:39:48 <Philippa_> ghci's best used in tandem with a source file anyway
13:39:57 <Megzlna> argh
13:40:01 <Gracenotes> yes, I'm 90% sure I meant that :)
13:40:15 <Megzlna> I just want to experiment with them in ghci.....
13:40:25 <Cale> Gracenotes: okay :)
13:40:27 <Philippa_> :r is your friend
13:40:48 <Cale> Gracenotes: so now, we have only 2 more functions to write before all the basic State monad stuff is in place
13:41:00 <Cale> We now know that (State s) is a monad.
13:41:14 <Cale> But there are some basic computations which are still missing.
13:41:22 <athos> btw.: i bet Cale did a good job at explaining, but just for your information: brian beckman did two videos on the State monad
13:41:29 <athos> using haskell and (i think) c# code
13:41:53 <Gracenotes> Cale: the State itself seems rather... unapproachable at this point :)
13:41:54 <athos> it's somewhere on channel9
13:41:58 <Gracenotes> it's supposed to be a sort of dictionary, no?
13:42:04 <Cale> s?
13:42:12 <Cale> s can be any type at all
13:42:15 <Gracenotes> yes, s.
13:42:19 <Peaker> Megzlna: unfortunately, ghci kinda sucks
13:42:23 <Cale> For example, we have that State Integer is a monad
13:42:29 <Peaker> Megzlna: there's no good reason, but you have to use a file
13:42:39 <Cale> where the state which is passed along through the computation is just a simple integer.
13:42:40 <Gracenotes> that keeps track of a number, presumably
13:42:45 <Cale> right
13:43:02 <Cale> Internally, it's just functions  Integer -> (Integer, a)
13:43:09 <Gracenotes> athos: will watch sooner or later
13:43:12 <Megzlna> okay
13:43:17 * Megzlna ;*(
13:43:50 <Cale> If those are the videos I'm thinking of, they were somewhat painful for me to watch, but I'm not sure :)
13:43:50 <Megzlna> :t Bool
13:43:50 <lambdabot> Not in scope: data constructor `Bool'
13:43:51 <Megzlna> why cant you do tat?
13:43:59 <Saizan> :k Bool
13:44:00 <lambdabot> *
13:44:11 <Saizan> or maybe you want :i Bool in ghci
13:44:25 <vixey> Megzlna, haskell is 3 layered :)
13:44:29 <Cale> oh, or actually, those aren't what I watched
13:44:36 <vixey> values :: types :: kinds
13:44:45 <Megzlna> vixey: Like a kind of pizza or ?
13:44:52 <Cale> I watched a different video in which Brian tried to explain monads, and I just couldn't sit through it :)
13:44:53 <vixey> yeah or a logic
13:45:13 <athos> Cale: you mean "dont fear the monads"?
13:45:23 <athos> Cale: where he uses is clock arithmetic example for a monoid?
13:45:25 <vixey> or a onion..
13:45:27 <Cale> athos: yes
13:45:30 <Gracenotes> Cale: so any supplied 'y' function in x >>= y has to take an a. ala S (\s -> let (s',v) = runState x s in runState (y v) s') ... can it access or modify the Integer, then?
13:45:37 <Megzlna> Brian the crazy Msft guy with the calculator collection?
13:45:58 <athos> Cale: hm, i think it wasn't thaaaaaaaaat bad
13:46:02 <Cale> Gracenotes: The computation that function produces is a State s b
13:46:02 <Gracenotes> x takes the s, outputs a v, which is sent to y
13:46:10 <Megzlna> he likes hats
13:46:11 <Cale> Gracenotes: or a State Integer b, rather ;)
13:46:35 <Megzlna> vixey: What are the 3 layers?
13:46:38 <Megzlna> :k Bool
13:46:39 <lambdabot> *
13:46:44 <Megzlna> :i Bool
13:46:56 <vixey> values :: types :: kinds
13:47:15 <Cale> Gracenotes: let's look at get and put, and then we'll be able to conveniently work with examples
13:47:16 <vixey> it's so you can't write  Bool Just -> Just  or similar odd things
13:47:27 <Megzlna> oh
13:47:29 <vixey> oops
13:47:35 <Cale> Gracenotes: So 'get' is supposed to be a computation whose result is the current state.
13:47:38 <vixey> it's so you can't write  Bool Maybe -> Maybe  or similar odd things**
13:47:47 <Cale> Gracenotes: It doesn't change the state either.
13:47:50 <Gracenotes> lemme see, runState is State Integer a -> Integer -> (Integer, State Integer)
13:48:01 <Cale> Gracenotes: So what type should get have?
13:48:32 <Gracenotes> something like (a, s) -> s
13:48:41 <Cale> nope
13:48:52 <Gracenotes> hm.
13:48:58 <Cale> I said that it was a state computation, so its type must begin with State s
13:49:17 <Cale> all that's left to determine is the type of its result
13:49:25 <Gracenotes> something like State s a -> s, then?
13:49:31 <Cale> no
13:49:41 <Cale> btw,  runState :: State s a -> s -> (s,a)
13:49:46 <Gracenotes> hm.
13:50:10 <Cale> (State s a) is the type of computations which manipulate a state of type s while producing a value of type s
13:50:11 <Cale> er
13:50:13 <Cale> (State s a) is the type of computations which manipulate a state of type s while producing a value of type a
13:50:15 <Cale> *
13:50:16 <Peaker> Megzlna: Parameterized types also need a kind of "type system" to verify that they are given the right amount of types as arguments (in compile-time) and the right kinds of type arguments.  So the "type" of types is called "kind".  The kind of simple types is *, the kind of 1-simple-parameter types is *->*, and so on
13:50:49 <Peaker> Megzlna: List (aka []) is of kind *->*  whereas  [] Int   (also spelled [Int]) is a simple *
13:50:52 <orbitz> Peaker: what would be an exampel of a * -> * -> *
13:50:54 <vixey> Peaker, I heard you like type systems.. so I put a type system n .. :p
13:50:57 <Peaker> orbitz: (->)
13:51:02 <Megzlna> Maybe is built in or not?
13:51:05 <Peaker> vixey: redditor eh? :)
13:51:07 <vixey> @src Maybe
13:51:07 <lambdabot> data Maybe a = Nothing | Just a
13:51:11 <dibblego> orbitz, Either
13:51:12 <Peaker> Megzlna: its in a library
13:51:14 <orbitz> :k (->)
13:51:16 <lambdabot> ?? -> ? -> *
13:51:16 <vixey> Peaker, someone in compilers linked this thing..
13:51:20 <orbitz> :k Either
13:51:22 <lambdabot> * -> * -> *
13:51:27 <Cale> Gracenotes: is that making more sense?
13:51:38 <orbitz> @src Either
13:51:38 <dibblego> :k Either Int
13:51:39 <lambdabot> Source not found. My mind is going. I can feel it.
13:51:40 <lambdabot> * -> *
13:51:41 <Gracenotes> Cale: these computations can also be passed a value, no?
13:51:50 <dibblego> :k Either Int String
13:51:51 <lambdabot> *
13:51:52 <Cale> Gracenotes: only the initial state.
13:51:54 <Peaker> orbitz: hmm.. not sure why (->) thinks its not * -> * -> *
13:51:54 <Gracenotes> obtained from a previous computation
13:52:08 <Cale> Gracenotes: If you want them to take another value, you'll use a function from that value to computations.
13:52:18 <Peaker> orbitz: oh, probably because in ghc, there are non-* kinds like # (for primitive types, etc)
13:52:29 <Cale> Remember the type of >>=
13:52:40 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
13:52:58 <Megzlna> So, you can do :t on Value constructors because they're like regular functions, but you cannot on a Data constructor, and you must use :i .. ?
13:53:04 <Cale> That function which is the second parameter of >>= takes an 'a' as a parameter, and produces the rest of the computation.
13:53:18 <Peaker> Megzlna: A Value constructor is a Data constructor, you mean Type Constructor?
13:53:37 <Megzlna> :t Just
13:53:38 <lambdabot> forall a. a -> Maybe a
13:53:49 <Peaker> Megzlna: a type constructor is in type-land, which is distinct from value-land.  Type-land has :info and :kind, but not :type
13:53:59 <Megzlna> ah
13:54:38 <Peaker> Megzlna: they're actually separate namespaces, which is why you can have: data MyType = MyType -- MyType is a Type name and a Value name
13:54:46 <Cale> Gracenotes: So, if 'get' is meant to be a (State s) computation which returns the current state as its result, it must have type State s s
13:54:52 <Peaker> Megzlna: The grammar context you're in determines which namespace names will be looked up in
13:54:59 <Philippa_> "data constructor" means the same thing as "value constructor", btw
13:55:01 <Cale> Gracenotes: So how might we write it?
13:55:16 <Philippa_> as opposed to "type constructor"
13:55:39 <Cale> Gracenotes: Would you like to give it a shot, or shall I explain how it's done?
13:55:48 <Gracenotes> I'm scrolling up and reading :)
13:56:02 <Philippa_> well, nearly: you could argue that a lambda is a "value constructor" (the value being a function)
13:56:11 <Cale> Gracenotes: Okay, let me know when you want to continue :)
13:56:30 <Philonous> @type Infinity
13:56:32 <lambdabot> Not in scope: data constructor `Infinity'
13:56:36 <Megzlna> isnt a pattern match or a primitive the only thing that makes a value
13:56:37 <Philonous> > 3/0
13:56:38 <lambdabot>   Infinity
13:56:54 <Philonous> > (3/0)*0
13:56:55 <lambdabot>   NaN
13:57:04 <Philonous> > (3/0)+1
13:57:05 <lambdabot>   Infinity
13:57:27 <Cale> There are floating point values which print as Infinity and NaN, but those are not actual data constructors.
13:57:38 <Taejo> Philonous, I generally use `infinity = read "Infinity"'
13:58:03 <orbitz> > read "Infinity" :: Double
13:58:04 <Philonous> @Å§ype let x = read "Infinity" in x
13:58:05 <lambdabot> forall a. (Read a) => a
13:58:06 <lambdabot>   Infinity
13:58:26 <Philonous> Nifty
13:58:36 <Philippa_> Megzlna: "value" is just "anything that's been evaluated"
13:58:40 <Gracenotes> Cele: I probably should have put all of the definitions in a text file, so I'm just collecting everything so as not to look all over constantly
13:58:53 <Cale> Gracenotes: okay :)
13:59:00 * vixey infinity = fix Succ
13:59:17 <Cale> For floating point, I'd just use  infinity = (1/0)
13:59:36 <vixey> Philippa_, and naturally ($) is (->) elimination
13:59:46 <Cale> > 0 == (-0)
13:59:48 <lambdabot>   True
13:59:57 <Cale> > isNegativeZero 0 == isNegativeZero (-0)
13:59:58 <lambdabot>   False
14:00:02 <Actium> what does $ do?
14:00:10 <Cale> Actium: f $ x = f x
14:00:15 <Philippa_> Megzlna: you might find it helps to get your hands on a copy of Pierce's Types and Programming Languages, btw
14:00:30 <dmhouse> Actium: it helps to remove brackets. f (g x) can be written as f $ g x
14:00:35 <Philippa_> it's not about Haskell, but pugs grew out of coding up the stuff in it :-)
14:00:42 <Taejo> Actium, ($) is id with a restricted type (but Cale's definition is probably clearer)
14:00:49 <Actium> thanks, all!
14:00:49 <orbitz> Actium: like f $ g y == f (g y)
14:00:51 <dmhouse> Actium: its definition is as Cale told you, plus some clever stuff with fixities.
14:01:02 <Cale> Actium: But $ has really weak precedence, so it's almost as if the things on the left and right of it are in parens
14:01:13 <Megzlna> I will be in hell with theory papers. I have this damn codebase to get done and, I'll bet that I could actually read papers for 2 years.
14:01:23 <Megzlna> Which would be fail
14:01:24 <Cale> You can write  f . g . h $ x  to mean (f . g . h) x
14:01:31 <luite> only 2 years?
14:01:38 <Cale> which means f (g (h x))
14:01:47 <Megzlna> I have to narrow it down to the best of the best
14:02:14 <Megzlna> I came towards Haskell because it's higher level, less syntax and crap than C++ to solve the problem.
14:02:15 <Cale> To be honest, I'm pretty sure you could read papers for the rest of your life ;)
14:02:17 <Actium> so the dollar is syntactic sugar?
14:02:25 <dmhouse> Actium: no, it's a genuine function.
14:02:28 <Megzlna> But, I am veering towards MORE syntax in the form of many, many papers
14:02:28 <Cale> Actium: It's just a normal infix function.
14:02:40 <orbitz> :t ($)
14:02:42 <lambdabot> forall a b. (a -> b) -> a -> b
14:02:42 <Cale> Actium: But we use it for its syntactic properties
14:02:47 <dmhouse> Actium: but, it's used as a syntactic shortcut, yes.
14:02:57 <dmhouse> It's not technically sugar due to the wonderful expressfulness of Haskell.
14:03:19 <vixey> Actium, ($) is just something I used as a name for function application
14:03:19 <Cale> I just wish that it was left-associative though.
14:04:08 <Cale> It's defined as being right associative. This means that you can write  f $ g $ h $ x, but I consider that to be bad style.
14:04:25 <Taejo> Cale, nice in theory, but I think it would end up counting dots and dollars
14:04:31 <Cale> It's less refactorable than f . g . h $ x
14:04:39 <Actium> thanks for your help everyone, this symbol is the most difficult aspect of the language i've encountered so far
14:04:49 <Cale> Actium: It's really not so hard :)
14:04:54 <luite> the . also looks a bit less messy than the $
14:04:58 <wli> The word is "compositionality."
14:05:21 <Megzlna> I'm genuinely becoming fearful with Haskell of my desire to (know everything) because it's a can of worms which could introduce failure into my life! My nature will create a gigantic stack of papers, and reading each one will produce a larger stack of further dependencies
14:05:25 <Megzlna> you yank one string
14:05:35 <Megzlna> and you pull up the entire ocean underworld
14:05:37 <Cale> The nice thing about f . g . h $ x is that you have that f . g . h and f . g and g . h are all well-typed functions.
14:05:54 <Cale> But f $ g $ h, f $ g, and g $ h are all going to be type errors.
14:05:55 <vixey> Megzla, you described lazy evaluation there :)
14:06:08 <Philippa_> Megzlna: pick some limits? For example, "Only what I need to understand the language itself"
14:06:16 <wli> e.g. monads are great not because they're a way to cram side effects into a pure language but because they're a compositional method of organizing side effects.
14:06:22 <Cale> So using (.) is better, because it gives you more chunks which can be separately understood.
14:06:30 <Saizan> and as in lazy eval, the key to understand haskell is to not evaluate all the requirements :)
14:07:03 <pumpkin> lazy Megzlna
14:07:05 <Cale> Moreover, if ($) were left associative (which it is currently not), we could remove parens from expressions like f (g x) (h y) (k z)
14:07:07 <Philippa_> and yeah, you can easily read papers for two years. You come out a very different programmer to the one you went in
14:07:23 <Cale> It would be: f $ g x $ h y $ k z
14:07:28 * Philippa_ would recommend TaPL anyway though, it comes under the "helpful for any language" heading
14:07:51 <Actium> this is such a fantastic language. i'm excited to learn it
14:07:53 <Beelsebob> Cale: I'd actually say that's significantly less clear than the one with parens though
14:08:01 <luite> Cale: I often find parentheses better readable though
14:08:08 <Cale> Beelsebob: Well, in this case, yes
14:08:11 <vixey> I use . and ()'s
14:08:14 <Cale> Beelsebob: There are cases where it would be nicer.
14:08:28 <Philippa_> I'd say yes, currently: I can see how I'd get used to it with practice
14:08:29 <Gracenotes> Cale: I think I'm having some trouble reconciling the fact that, in going from one state to the next, two separate values, of type a and s, are considered input for completing the computation, and both a value and a state are used as output.
14:08:30 <Cale> Beelsebob: Also, when you pair this up with $!
14:08:38 <Cale> left associativity becomes exactly what you want
14:09:04 <Philippa_> Gracenotes: imagine you're building a chip to do it
14:09:06 <necroforest> TaPL?
14:09:14 <dmhouse> ?where tapl
14:09:14 <vixey> TAPL
14:09:18 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:09:21 <vixey> great book
14:09:22 <Philippa_> you need a register for the state and another for the accumulator, right?
14:09:23 <Cale> Gracenotes: in which context?
14:09:36 <Cale> Gracenotes: In the second parameter to >>= ?
14:09:41 <Gracenotes> yes.
14:09:51 <Gracenotes> none of the functions explicitly take in two values and output two. It's convoluted to abstract it into a monad, although it must be worth it :)
14:09:57 <Cale> Okay, let's take a step-by-step approach to defining >>=
14:10:02 <Cale> I went a little quickly there
14:10:37 <Gracenotes> so, in x >>= y, both of them are states, and the result of the computation is a state. in a simple sense
14:10:41 <Philippa_> Gracenotes: it's curried - one parm inside the monad (the state), one 'outside' it (the ordinary parm) but used to put something inside it
14:10:57 <Cale> So, if x is a State s computation, and f is a function from possible results of x to further State s computations, then x >>= f is supposed to be the State s computation which first runs x, and then takes its result and applies f to it
14:11:11 <Cale> to get another computation which is run with the final state after running x
14:11:29 <Cale> x :: State s a
14:11:32 <Cale> f :: a -> State s b
14:11:38 <Cale> x >>= f :: State s b
14:11:51 <wli> flip $ (join .) . fmap
14:12:12 <Cale> So, how do we write this? We'll use the constructor S
14:12:19 <Cale> x >>= f = S (\s -> ...)
14:12:21 <Cale> as before
14:12:31 <Cale> First, we run x with the initial state...
14:12:41 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in ...)
14:13:21 <Gracenotes> if, say, s is an Integer and b is a String, what would x look like?
14:13:22 <Cale> Now we have v :: a the result of running x, and s' :: s, the final state after running x
14:13:27 <Gracenotes> *a is a string
14:13:31 <wli> Maybe flip $ (join .) . liftM since there's weirdness I forget about Functor involved with fmap.
14:13:53 <Cale> x would be of type State Integer String
14:14:04 <Cale> which is internally represented by a function of type Integer -> (Integer, String)
14:14:20 <Cale> from the initial state, to a final state and a String
14:14:40 <pumpkin> I wonder how many adjacent (ignoring spaces and parentheses) . operators have been used in real stuff?
14:14:43 <pumpkin> I've seen three
14:14:50 <wli> (one can also represent e.g. functions from types with few elements like Bool by tables of functions' values)
14:14:55 <Cale> pumpkin: I've used upwards of 10
14:14:56 <vixey> pumpkin, lol
14:15:03 <pumpkin> Cale: :o
14:15:03 <Taejo> pumpkin, does (.).(.) count as three?
14:15:13 <pumpkin> Taejo: sure, if you actually use it
14:15:26 <Cale> pumpkin: oh, I thought you were referring to composition chains
14:15:28 <Taejo> pumpkin, the boobs operator is a very useful one
14:15:29 <wli> pumpkin: I write long pipelines all the time.
14:15:31 <Cale> Like f . g . h . ...
14:15:34 <vixey> pumpkin, if you have f = x . y . z . u . v . w you can just go m = x . y . z; n = u . v . w; f = m . n
14:15:42 <Taejo> :t (.).(.)
14:15:43 <luite> pumpkin: have you finished your, ehm, DAWG, by the way?
14:15:44 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:15:46 <pumpkin> :t (.).(.).(.)
14:15:48 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
14:16:01 <Olathe> @unpl (.).(.).(.)
14:16:01 <wli> pumpkin: I put each function on a line by itself (usually it's a compound expression) and align each . with the = sign.
14:16:02 <lambdabot> (\ l b c f i -> l (b c f i))
14:16:02 <pumpkin> luite: nah, got sidetracked by project euler and real work :)
14:16:08 <Cale> Gracenotes: so is this starting to become clear? How might we proceed from here?
14:16:13 <pumpkin> wli: ah :)
14:16:13 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in ...)
14:16:22 <pumpkin> I've chained many many functions up between .s
14:16:29 <Gracenotes> Cale: if for some reason you really wanted to start with a 3 as state and "h" as the computed value, could you do State (\s -> (3,"h")) >>= y?
14:16:31 <EnQLey_> Vous me rendez mon vélo s'il vous plait ?
14:16:33 <Taejo> pumpkin, I've never used the threeboobs operator, but it could be useful somewhere
14:16:43 <pumpkin> that's what I meant
14:16:48 <Gracenotes> as convoluted as it is, the type system still permits it, right?
14:16:50 <Cale> Gracenotes: You'd pass in 3 as the initial state to runState
14:16:56 <pumpkin> multibreast ( ;) ) operators
14:16:57 <Cale> But yes
14:17:11 <wli> pumpkin: map with this, filter with that, sort by something else, group and re-form fresh elements, map some more, filter some more, etc. all in a big pipeline with lots of long lambdas.
14:17:20 <Cale> Gracenotes: actually, you would use 'put' which we haven't described yet
14:17:21 <luite> pumpkin: ah. I still want to make one some time, but am a bit too busy at the moment
14:17:22 <EnQLey_> Haskell, it's jew ?
14:17:33 <vixey> o_o
14:17:36 <pumpkin> wli: yeah, I've done that
14:17:49 <pumpkin> wli: but I was after more of the n-breast operator
14:18:00 <EnQLey_> ho oui en plein dans le mille comment je t'ai vixey LOL ahahahaha !
14:18:04 <Gracenotes> Cale: hm.... yeah, I'm not sure I get the whole picture, i.e. how to pass things that are not (yet) constructible. I'll just go with it at the moment though.
14:18:38 <Cale> Gracenotes: okay
14:18:44 <vixey> EnQLey_, :) je ne sais pas
14:18:52 <Cale> Gracenotes: So do you see how to finish the construction of >>= ?
14:19:04 <Cale> We get v :: a from running x
14:19:16 <Cale> along with the final state after running x, called s'
14:19:21 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in ...)
14:19:23 <EnQLey_> tu ne sais jamais rien de toute fasson :-)
14:19:36 <Cale> What do we do from there?
14:19:41 <Cale> We apply the function f to v
14:19:45 <Gracenotes> we're passed the initial state s, and (s', v) is the next state and result from x
14:19:52 <Cale> yes
14:19:55 <mpeter> it's amazing how quickly you learn haskell
14:20:00 <mpeter> what does >>= mean
14:20:07 <pumpkin> mpeter: bind? :P
14:20:10 <chrisdone> interesting
14:20:12 <vixey> EnQLey_, fasson?
14:20:22 <mpeter> define 'bind'
14:20:27 <roconnor> @src Maybe (>>=)
14:20:28 <lambdabot> (Just x) >>= k      = k x
14:20:28 <lambdabot> Nothing  >>= _      = Nothing
14:20:30 <Asztal> probably facon with a cedille
14:20:30 <Cale> mpeter: I would have to go back a ways in my tutorial to explain...
14:20:34 <chrisdone> foo = do
14:20:34 <chrisdone>   undefined <- undefined)
14:20:34 <chrisdone>   undefined
14:20:34 <chrisdone> gives âThe last statement in a 'do' construct must be an expressionâ, rather than âunexpected paranthesisâ
14:20:39 <roconnor> @src Either (>>=)
14:20:40 <lambdabot> Left  l >>= _ = Left l
14:20:40 <lambdabot> Right r >>= k = k r
14:20:40 <Peaker> mpeter: a >>= func_that_returns_b        means roughly, build action that will: execute a, feed the function with a's result, then execute b
14:20:44 <Cale> mpeter: If you want, I can explain monads to you in just a sec.
14:20:50 <vixey> oh right means 'way'
14:20:51 <EnQLey_> vixey > manière.
14:20:55 <Cale> mpeter: But I should finish with Gracenotes :)
14:20:59 <roconnor> @src [] (>>=)
14:21:00 <lambdabot> xs >>= f     = concatMap f xs
14:21:05 * mpeter waits
14:21:06 <Gracenotes> then we want to get from the result to the next state, so (y v) is a way to get the next-next state
14:21:10 <quicksilver> chrisdone: I have also found that error message surprising.
14:21:11 <EnQLey_> All way, you known nothing :-)
14:21:12 <dons> mpeter: in imperative land, sort of:   x = e ; .. x ...
14:21:14 <Philippa_> Cale: explaining monads gets to be a bit of a habit after five years, no? :-)
14:21:17 <quicksilver> chrisdone: there is a strange short-cut rule in the parser.
14:21:19 <Cale> Philippa_: yep :)
14:21:20 * osfameron wonders if he could submit his talk on functional Perl for the ICFP Functional Pearls talks...
14:21:26 <chrisdone> quicksilver: ah, for speed?
14:21:26 <Cale> Philippa_: I enjoy it :)
14:21:29 <vixey> osfameron, LOL
14:21:46 <quicksilver> chrisdone: it says basically "if you get an unexpected token, close the current layout block and see if it's legal then"
14:21:54 <Cale> Gracenotes: y v :: State s b
14:21:57 <chrisdone> quicksilver: interesting
14:22:00 <quicksilver> chrisdone: it can close any number of nested blocks in fact.
14:22:18 <luite> I do like the State monad example, it seems to be the 'ideal' monad for explaining
14:22:20 <quicksilver> chrisdone: and then it will notice that ) is *still* unexpected after all. but not before it's complained that your do block ended badly.
14:22:24 <Cale> Gracenotes: So we could continue by running that action.
14:22:28 <Gracenotes> Cale: how would you intuitively describe runState?
14:22:28 <quicksilver> chrisdone: I do think it leads to pretty weird errors :)
14:22:29 <EnQLey_> kliken dich dach douch klinkendichenachenouch.
14:22:41 <Gracenotes> in terms of its parameters, that is...
14:22:47 <osfameron> vixey: actually, I'm semi-serious: they suggest "a novel use or exposition of functional programming in the classroom", and I wonder if "teaching monads to crufty old CGI hackers" might not count as such :-)
14:22:51 --- mode: ChanServ set +o quicksilver
14:22:52 <Gracenotes> it seems deceptively simple :)
14:22:55 --- mode: quicksilver set +b *!*n=EnQLey@*.dyn.versateladsl.be
14:22:55 --- kick: EnQLey_ was kicked by quicksilver (WTF?)
14:22:56 <Cale> Gracenotes: As a function which takes a (State s a) computation, and an initial state, and produces a final state and result of type a
14:22:59 * mpeter googles it in the meantime
14:23:00 --- mode: quicksilver set -o quicksilver
14:23:15 <Cale> mpeter: >>= is one of the basic monad operations
14:23:22 <vixey> what's klinkendichenachenouch??
14:23:31 <mpeter> i think it means "ban me, please, i am asking for it"
14:23:32 <roconnor> Philippa_: can monads really be explained?  I kinda think all you can do is look at a bunch of monads and say "A monad is what is in common with all these things"
14:23:53 <luite> Cale proves they can ;)
14:24:08 <Philippa_> roconnor: I've got a story I'm happy with for monads in Haskell, not least because it's a straight mapping of the category theory onto the categories involved
14:24:09 <quicksilver> chrisdone: if yo'ure interested, "that is, if an illegal lexeme is encountered at a point where a close brace would be legal, a close brace is inserted"
14:24:14 <Actium> may i ask: how many here expect videogames to see a great benefit from Haskell in the near future (3 years time) ?
14:24:22 <Philippa_> OTOH, it does take a certain mindset to understand it
14:24:23 <quicksilver> chrisdone: from http://www.haskell.org/onlinereport/lexemes.html section 2.7 Layourt
14:24:23 <Gracenotes> roconnor: in that sense one could easily have a partial understanding of monads, by understanding some similarities but not others :/
14:24:28 <mpeter> actium: me
14:24:28 <pumpkin> Actium: directly, not much :P
14:24:43 <Cale> Actium: 3 years is perhaps a little short, but if the userbase keeps growing like it has, then sure.
14:24:45 * vixey feels sorry for EnQ
14:24:47 <mpeter> i believe haskell will produce some amazing video games due to ease of coding
14:24:52 <Philippa_> Actium: unlikely in 3, the product cycle's too long these days. 6 is more likely
14:24:55 <quicksilver> vixey: it's was more "haskell's jew?" that made me think kicking was appropriate ;)
14:25:06 <vixey> is jew french for something?
14:25:10 <Taejo> Gracenotes, some of those partial understandings have names: Functor, Applicative
14:25:13 <vixey> or it is short for jewish
14:25:14 <Cale> Actium: I could believe that in 3 years, a major company starts working on a videogame in Haskell.
14:25:16 <chrisdone> quicksilver: thanks
14:25:22 <mpeter> games like civ, spore, WOW, whatever, the ease in which you may describe them in haskell is stunning
14:25:27 <roconnor> Gracenotes: true.  That's why the list monad is so important :D
14:25:29 <Actium> good point about the production cycle. and Haskell would shorten that
14:25:32 <Gracenotes> Taejo: although one might not know it at the time >_>
14:25:43 <Gracenotes> *puts in back of mind*
14:25:45 <Philippa_> Cale: I don't think that's likely. Partly in Haskell is a lot more likely though
14:25:46 <Cale> But having a finished one in 3 years, probably not ;)
14:25:47 <Taejo> Gracenotes, indeed
14:25:49 <wli> mpeter: Could you give an example of how they're described?
14:25:52 <quicksilver> vixey: Jew is the noun denoting a person who is Jewish, yes.
14:25:58 <vixey> in english I know that
14:26:14 <vixey> but they seemed to be talking french (or german)
14:26:26 <mpeter> wli: in a few months ;)
14:26:44 <Cale> Gracenotes: It is deceptively simple.
14:26:47 <chrisdone> I can't think of any right now but I swear GHC has given me other completely unhelpful/meaningless error messages that the solution had nothing to do with. am I probably right or was I just ignorant?
14:27:04 <Cale> Gracenotes: The only tricky part is that the State monad *really* makes use of functions as first class values.
14:27:08 <orbitz> chrisdone: the correct spelling is 'ignint'
14:27:14 <Cale> In a way that many other monads don't quite live up to.
14:27:29 <chrisdone> orbitz: heh
14:27:54 <Philippa_> Cale: that's one reason I like the version with an term algebra datatype...
14:28:02 <Cale> yeah
14:28:04 <Gracenotes> so the essence of >>=, hopefully, is that: combining the state derived from x, and the state derived from y with the value from x, one can get the state derived from both x's state and x's value
14:28:11 <Gracenotes> put informally
14:28:16 <quicksilver> chrisdone: GHC certainly takes a different view on what the main 'problem' is sometimes
14:28:19 <Gracenotes> the key to the combination seems to be runState.
14:28:25 <vixey> where is this algebra and coalgebra way to define datatypes ... defined?
14:28:31 <Philippa_> Gracenotes: yes! Very much so
14:28:31 <Gracenotes> which is funny, because it's in two places at once  :)
14:28:33 <idnar> > (+5) + 6
14:28:34 <lambdabot>       No instance for (Num (a -> a))
14:28:35 <lambdabot>        arising from the literal `6' at <...
14:28:37 <Actium> ok this is good. it seems likely that the language will gain much interest in that sector, especially if people like Tim Sweeney have been talking about it.
14:28:39 <ddarius> How does one confuse French and German?
14:28:41 <idnar> chrisdone: ^^^ something like that?
14:28:44 <vixey> I don't think I ever understood it but I memorized some keywords like "initial algebra"
14:28:49 <Cale> Gracenotes: It's important not to be confused about what a value of type (State s a) is. It is not a state.
14:29:01 <Cale> Gracenotes: The states are values of type s
14:29:14 <chrisdone> idnar: well, that's actually fairly descriptive
14:29:16 <Riastradh> StateAction would have been a better name for it than State.  The state's type is s.
14:29:31 <idnar> chrisdone: it is, but the proposed solution from GHC is unlikely to be the one you actually want in that case
14:29:33 <chrisdone> idnar: though I can see why one from another language might prefer "you can't add a function to a number"
14:29:36 <Saizan> vixey: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1418
14:29:39 <Philippa_> vixey: it's made worse by the fact initial algebras and final coalgebras are isomorphic in this context...
14:29:59 <Philippa_> which means algebra vs coalgebra is something of a matter of your point of view
14:30:01 <idnar> chrisdone: ie. you probably made a typo, rather than forgot to define a Num instance for functions
14:30:06 <ddarius> Dialgebras all the way!
14:30:15 <vixey> ty Saizan
14:30:17 <Philippa_> but the lay version is "a datatype for the 'State language'"
14:30:58 <chrisdone> idnar: yeah. I guess that's the main factor, it always assumes you meant exactly what you wrote, without speculating
14:31:03 <Asztal> > (+5) 3 3
14:31:05 <lambdabot>       No instance for (Num (t -> a))
14:31:05 <lambdabot>        arising from the literal `5' at <...
14:31:12 * Cale wonders if anyone else still secretly hopes that Haskell will continue to avoid success. :)
14:31:19 <roconnor> I do
14:31:26 <roconnor> I think dons will destroy haskell
14:31:28 <pumpkin> lol
14:32:06 <ddarius> The messenger of the Apocalypse has come.
14:32:12 <tibbe> I don't care too much success. But I do care about Haskell being useful for me :)
14:32:19 <Cale> Yeah... as much as I enjoy seeing new Haskell users, I paradoxically hate to see the userbase grow large.
14:32:25 <Saizan> hopefully agda or epigram will be become more usable but still too obscure in the meantime
14:32:35 <ddarius> Cale: You're part of the problem.
14:32:42 <roconnor> Saizan: ah yes.  Epigram will be our refuge
14:32:47 <mpeter> i think dons will destroy us all!!!
14:32:53 <chrisdone> tibbe: hey, I saw your name listed here.. :D http://chrisdone.com/blog/db/static/formletsexample/
14:33:07 <roconnor> formlet sex ample?
14:33:14 <roconnor> sounds very kinky
14:33:15 <chrisdone> indeed
14:33:25 <tibbe> chrisdone: heh yes, I enjoyed reading about formlets yesterday and today
14:33:25 <chrisdone> I have ample sex formlets
14:33:26 <Cale> ddarius: Depends on what you consider the goal to be. I just want to have a language which sits firmly on the border between being a research language and something which is practically usable.
14:33:34 <chrisdone> tibbe: yayy
14:33:47 <tibbe> chrisdone: it's a beautiful abstraction
14:33:52 <vixey> what is not useable about agda ?
14:33:53 <chrisdone> tibbe: I agree!
14:33:58 <Cale> ddarius: If you take away the research language part, I'm no longer interested.
14:34:19 <chrisdone> all the cool stuff comes from the research part
14:34:37 <tibbe> chrisdone: while I have you on the line. If I have many different form on a page do I have to make them one big form in order for the unique name supply to be passed around correctly?
14:34:37 <rgr> Anyone here running Debian on a "no HD" netbook? If so which one and how do you find it?
14:34:45 <Cale> I love seeing Haskell used for practical things, but if that means we become afraid of changing the language, I don't want it.
14:34:52 <rgr> sorry, wrong #.
14:34:58 <mpeter> cale: why would it mean that?
14:35:18 <mpeter> shouldn't any language be shaped by the necessities that draw users to it?
14:35:28 <Cale> mpeter: Because the larger the body of code which is written in Haskell, the more that people whine about backwards compatibility.
14:35:28 <Philippa_> Cale: it does kinda need to mean at least one piece of community fragmentation - we can't expect the bulk of practical-here-and-now users to keep up with research
14:35:54 <mpeter> but the core of haskell is so tiny
14:36:01 <chrisdone> tibbe: do you want two independant forms, or one large form? specifying a different name for each forms when you use runFormState will ensure that they are distinct in the element naming
14:36:10 <Philippa_> Cale: not to mention things like the old datatype syntax vs the new one
14:36:18 <tibbe> chrisdone: distinct forms, thanks, that answers my question
14:36:19 <Cale> Philippa_: yeah...
14:36:22 <chrisdone> tibbe: great!
14:36:38 <Philippa_> I mean, that one effectively just came up for you - "can I safely use this extension in explaining something?"
14:36:39 <tibbe> chrisdone: (I must admint I haven't looked at the API carefully yet, just a quick browse before reading the paper)
14:36:47 <chrisdone> tibbe: sure
14:38:33 <Cale> (well, I might also have avoided GADTs here for the reason that Gracenotes might not have been introduced to them yet -- of course that would be less of a problem if the GADT syntax was the only syntax for datatypes)
14:38:52 <Cale> Well, let's try it :)
14:39:11 <wli> I could probably use a GADT tutorial.
14:39:45 <Cale> Gracenotes: Instead of defining State s a using functions, we could also use something like the following:
14:39:51 <tibbe> chrisdone: how flexible are formlets when it comes to using different ways of generating (X)HTML?
14:39:54 <Cale> data State s a where
14:40:01 <tibbe> chrisdone: what if I had my own templating language?
14:40:02 <Cale>   ReturnS :: a -> State s a
14:40:14 <Cale>   BindS :: State s a -> (a -> State s b) -> State s b
14:40:26 <Cale>   GetS :: State s s
14:40:35 <Cale>   PutS :: s -> State s ()
14:41:00 <Cale> This syntax is called GADT syntax (for generalised algebraic data type)
14:41:02 <pumpkin> tibbe: then I'd urge you to release it to the public cause the more the merrier ;)
14:41:21 <Cale> It describes each of the constructors of the datatype by giving each an explicit type.
14:41:34 <Cale> This makes the monad implementation trivial:
14:41:38 <Cale> return = ReturnS
14:41:44 <Cale> x >>= f = BindS x f
14:41:45 <chrisdone> tibbe: the Formlets library is mark-up-library-agnostic, so you can use whatever markup generation method you like, in that sense. I'm not sure how your template language might work, but if it supports including arbitrary mark-up then you can use formlets with it just fine
14:41:49 <vixey> wli, what about GADTs needs written?a
14:41:52 <Cale> But it makes runState far more interesting
14:41:57 <wli> Cale: What about runState?
14:42:10 <Gracenotes> hm, does it? >_>
14:42:12 <Cale> runState :: State s a -> s -> (s,a)
14:42:12 <Philippa_> it also makes runState make far more sense :-)
14:42:28 <Cale> runState (ReturnS v) s = (s,v)
14:42:30 <tibbe> pumpkin: heh :)
14:42:44 <Gracenotes> seems to make sense
14:42:46 <chrisdone> tibbe: in my post I used Text.XHtml.Formlets, but that just implements a set of inputs for the Formlets library, you can easily implement your own
14:42:55 <tibbe> chrisdone: cool
14:43:04 <Cale> runState (BindS x f) s = let (v,s') = runState x s in runState (f v) s'
14:43:19 <Cale> runState GetS s = s
14:43:25 <chrisdone> is StringTemplate a mark-up templating library thing? I've never used one
14:43:34 <Cale> er
14:43:34 <Cale> no
14:43:35 <Gracenotes> whoa. possibly recursion :)
14:43:37 <Cale> runState GetS s = (s,s)
14:43:59 <Cale> runState (PutS s') s = (s',())
14:44:14 <Cale> Now we'll have:
14:44:17 <Cale> get = GetS
14:44:18 <Cale> and
14:44:24 * tibbe wishes hpaste had search
14:44:25 <Cale> put s' = PutS s'
14:44:41 <Gracenotes> and we'd use PutS with >>, probably, because snd is just a dummy value?
14:44:46 <chrisdone> http://google.com/search?q=site:hpaste.org ?
14:44:56 <Cale> So in this way, our (State s a) values are like higher order abstract syntax for a little language of stateful computations.
14:45:06 <Cale> >> would just be...
14:45:15 <Cale> x >> y = BindS x (const y)
14:45:38 <Cale> We could also add a primitive to the language for it, but it's not necessary, as that shows
14:45:41 <Philippa_> Cale: they're not even HOAS, they just happen to incorporate haskell terms :-)
14:45:59 <Cale> Philippa_: Well, I was referring to the fact that BindS has a functional parameter.
14:46:07 <Taejo> is a GADT just a ADT with restricted constructors?
14:46:16 <vixey> restricted? no
14:46:17 <Cale> Taejo: yes, pretty much :)
14:46:21 <vixey> It's LESS restricted
14:46:28 <Philippa_> Cale: sure, I didn't /just/ mean return
14:46:34 <Cale> vixey: The types of the constructors themselves are more restricted.
14:46:37 <vixey> more expressive
14:46:51 <Philippa_> vixey: it's there to let you express restrictions and exploit them
14:46:59 <vixey> what you can define as a GADT is every ADT and more
14:47:00 <roconnor> why is Cale defining a reified state monad?
14:47:23 <ddarius> roconnor: It is a didactic experiment.
14:47:24 <Cale> roconnor: as an example of an alternate implementation, so that Gracenotes can see the idea behind runState
14:47:29 <vixey> I guess the point is, everything not an ADT that you define using a GADT is a restricted version of some ADT?
14:47:38 <vixey> I don't think that's a reasonable intuition ...
14:47:57 <Cale> Gracenotes: So in our other implementation, runState did something trivial. It just extracted the function which was wrapped up in the S constructor, and applied it to the initial state.
14:48:21 <Cale> Gracenotes: But this possibly makes it hard to see how significant its function is.
14:48:26 <Megzlna> Is there a different way to access the fields of a value besides pattern matching?
14:48:38 <Taejo> Megzlna, no
14:48:39 <Gracenotes> Megzlna: records?
14:48:41 <Peaker> Megzlna: accessors, catamorphisms, records...
14:48:44 <ddarius> Cale: It's function isn't significant.  It is operationally the id function.
14:48:46 <Cale> It represents carrying out the computation in our new little embedded language.
14:48:47 <Gracenotes> if by value you mean data
14:49:04 <Peaker> Megzlna: my favorite is folds/catamorphisms..
14:49:06 <Megzlna> how do you use an accessor
14:49:15 <Peaker> Megzlna: fromJust (Just x) = x
14:49:19 <Taejo> oh yes, records ... the rest (accessors, catamorphisms) have to be defined with pattern matching (don't they?)
14:49:21 <Cale> ddarius: Once you hide the data constructor, it is very significant.
14:49:25 <Peaker> Megzlna: head (x:_) = x
14:49:28 <Gracenotes> ah, domain-specific language. Last time I implemented one of those was, uh, JavaScript, 5 months ago
14:49:50 <Gracenotes> embedded domain-specific, for that matter
14:49:54 <Peaker> Megzlna, Taejo: Sure, but you define them once, and then others don't have to pattern-match
14:49:56 <Megzlna> Peaker: so you just match on the whole type in your function?
14:49:58 <Gracenotes> so,
14:49:58 <Cale> ddarius: any number of other implementations might have been used, and we don't care which -- runState is the thing which actually carries out the work
14:50:03 <Megzlna> rather
14:50:07 <Megzlna> the *not whole type*
14:50:16 <ddarius> Cale: runState is what lets you -observe- the work.
14:50:32 <Peaker> Megzlna: that's basically ordinary pattern-matching, but you define it - and then you can use it instead of pattern matching directly
14:51:12 <Peaker> Megzlna: Basically the only way to extract a field from a data constructor directly is pattern-matching and records -- or calling these functions that pattern-match for you
14:51:13 <Cale> ddarius: Well, it also is what lets you supply an initial state without which not much can actually happen.
14:51:20 <Megzlna> surface (Circle _ _ r) = pi * r^2    -->   surface Circle? = pi * (?)^2
14:51:27 <ddarius> Cale: In the "AST" representation, all the operations become trivial.  Am I supposed to take that to mean that they are insignificant.
14:51:28 <Peaker> Megzlna: records are just surface syntax, though
14:51:28 <ddarius> ?
14:51:33 <Megzlna> how do you remove the need for _ _ r and every parameter of the data
14:51:42 <Cale> ddarius: No, they are still significant. :)
14:51:47 <Megzlna> from the surface function
14:52:04 <Peaker> Megzlna: data Circle = Circle { x, y, radius :: Double }
14:52:19 <Megzlna> without changing data
14:52:28 <Peaker> Megzlna: surface = (pi *) . (^2) . radius
14:52:31 <Cale> ddarius: But I'm saying from a didactic perspective, the implementation of runState is so simple in the function representation that it can be hard for a beginner to see what its actual value is.
14:52:49 <Cale> So seeing both might be a good idea :)
14:52:54 <Peaker> Megzlna: you can write the "record accessors" yourself, with pattern matching, then functions like surface can call these accessors instead of pattern matching directly
14:53:06 <Megzlna> is there any way to just match:
14:53:10 <ddarius> Cale: In the AST version, it is so complex that it is easy for a beginner to attribute overly much significance to it.
14:53:13 <Peaker> Megzlna: radius (Circle _ _ r) = r ;  surface is defined the same way then
14:53:16 <Megzlna> surface Circle...x =
14:53:25 <Megzlna> and then pull out individual fields from x
14:53:26 <Peaker> Megzlna: dots instead of underscores? :)
14:53:40 <Megzlna> the dots had no significance
14:53:44 <Megzlna> just "match ANY circle"
14:53:46 <Cale> ddarius: Well, given that State computations are totally pointless if you don't have runState, I think it's hard to attribute too much significance to it ;)
14:53:48 <Peaker> Megzlna: You can pattern-match specific fields by name, but only with records
14:53:50 <wli> 3 points also define a circle.
14:54:03 <Saizan> Megzlna: surface c@Circle{} = ..
14:54:07 <Cale> You can't actually make any use of State computations if you don't have runState.
14:54:12 <orbitz> Megzlna: just deifne cirle as surface :: Circle -> a
14:54:23 <ddarius> Cale: State computations are totally pointless if you don't have get/put as well.
14:54:27 <Cale> sure
14:54:35 <Cale> I agree.
14:54:56 <Megzlna> so what Saizan just showed is what Peaker said about records? but using them
14:54:59 <Gracenotes> yeah... just what do they do? :)
14:55:13 <Cale> Gracenotes: So let's go back and do those, because we kind of got caught up in the middle of that
14:55:20 <Cale> get :: State s s
14:55:35 <Cale> Its job is to produce the current state as its result
14:55:40 <Peaker> Megzlna: data Shape = Circle {fields here} | Square {fields here} ...  Then you can pattern-match as Saizan said (Yes, its records-based)
14:55:47 <tibbe> "Occurs check: cannot construct the infinite type: ..." is the most unhelpful error message ever when it comes to actually finding the problem
14:55:49 <Peaker> Saizan: will that work for non-records too?
14:55:54 <vixey> why don't you write  surface (Circle _ _ _) ?
14:55:56 <Saizan> Peaker: yes
14:55:57 <Megzlna> thanks
14:55:58 <Cale> Let's go back to the original definition of State s a
14:56:05 <Cale> How do we write get?
14:56:10 <Megzlna> vixey: cause that assumes circle isnt complex
14:56:13 <Cale> Gracenotes: do you want to try?
14:56:14 <Peaker> tibbe: I hate that error too, it always confuses the hell out of me
14:56:17 <vixey> data Shape = Circle {fields here} | Square {fields here} extends Shape -- :P
14:56:20 <ddarius> Cale: The problem with the AST view is that it moves -all- of the work into runState which is definitely not a balanced view.  Mimicking your earlier statement another way: "the implementation of (>>=) is so simple in the AST representation that it can be hard for a beginner to see what its actual value is"
14:56:21 <Megzlna> or that I can even remember
14:56:22 <Cale> (there's only one thing which will typecheck, and it is correct)
14:56:25 <Megzlna> how many fields it has
14:56:31 <orbitz> Cale: when yo usay 'state', are your eferrign to for instance, the integer value if i had a State Integer?
14:56:34 <vixey> Megzlna, if it is complex then this is what's wrong
14:56:37 <Deewiant> vixey: if you add or remove fields from Circle you have to change all matches like that
14:56:42 <Cale> ddarius: Right. I'm not saying that one view is better than another at everything.
14:56:49 <vixey> Deewiant, yes.. That is not a problem
14:56:56 <tibbe> Peaker: the problem is that the type error could be in one of many places e.g. in the data type declaration or any of the cases in your instance declaration
14:56:57 <Cale> ddarius: I'm saying that each view makes certain aspects easier to understand.
14:56:59 <Deewiant> No, but it's an inconvenience. :-)
14:57:08 <Cale> orbitz: yes
14:57:13 <Megzlna> <orbitz> Megzlna: just deifne cirle as surface :: Circle -> a
14:57:14 <Megzlna> ???
14:57:30 <orbitz> Megzlna: if you defined it that way you could just do surface blah = ...
14:57:33 <Peaker> tibbe: I agree with something I read somewhere - if the compiler brought a single counter-example instead of saying why its generally wrong, it would be much easier to decipher
14:57:34 * Philippa_ thinks the AST version works better if you use longer names for the intermediates and lay it out right, too
14:57:37 <Cale> Gracenotes: are you still with us?
14:57:38 <orbitz> Megzlna: i dont' think my answer is what youa re lookign for though
14:57:38 <Megzlna> orly.
14:57:57 <tibbe> Peaker: good point
14:58:01 <Philippa_> there /is/ something deep about there being a let-binding involved, though
14:58:04 <Gracenotes> yes, essentially
14:58:05 <Megzlna> orbitz: How was I supposed to get a Circle 'x' anyways using your way?
14:58:32 * RayNbow looks at http://haskell.org/sitewiki/images/6/62/Haskell_logo_ideas_falconnl.png ...
14:58:42 <RayNbow> is Haskell simple? :p
14:58:47 <Cale> Gracenotes: okay, do you want me to write get?
14:58:54 <orbitz> Megzlna: what do you mean?
14:58:58 <Cale> Gracenotes: Or do you want to try to write it yourself?
14:59:00 <Peaker> RayNbow: I went "wtf is ctional??" for 5 seconds :)
14:59:06 <RayNbow> :D
14:59:10 <Megzlna> orbitz: get 'x' in f to extract 'r' from
14:59:12 <Gracenotes> hm. let me see.
14:59:13 <ddarius> RayNbow: The term level is.
14:59:25 <Taejo> Peaker, it's the style of programming favoured by Cthulu
14:59:28 <Peaker> I think the "ctional" is far more emphasized than the "fun"
14:59:42 <Megzlna> Peaker maybe cause you arent a newb
14:59:42 <Peaker> Taejo: :)
14:59:52 <Gracenotes> so get :: State s s, something of the form (\s -> (s, s))
15:00:11 <Gracenotes> rather, of the form State (\s -> (s, s))
15:00:22 <Megzlna> If I was 5 years old, I'd probably read the FUN part
15:00:30 <Gracenotes> hm... is that it? :)
15:00:38 <Peaker> Megzlna: I think that blue just sticks out more out of my monitor
15:00:48 <osfameron> yeah
15:00:52 <osfameron> the second version works better
15:01:00 <wli> (x+dx)^2-x^2 = 2*x*dx+dx^2 so ((x2-x0)^2+(y2-y0)^2)-((x1-x0)^2+(y1-y0)^2)=2*(x2-x0)*(x2-x1)+2*(y2-y0)*(y2-y1)+(x2-x1)^2+(y2-y1)^2=0=2*(x3-x2)*(x3-x0)+2*(y3-y2)*(y3-y0)+(x3-x2)^2+(y3-y2)^2 yielding linear equations for x0 and y0; r is then just ((x1-x0)^2+(y1-y0)^2)^(1/2) (any of the 3 points' coordinates works)
15:01:00 <Cale> get = S (\s -> (s,s))
15:01:07 <Cale> right
15:01:11 <osfameron> because of the positioning of the blue subtext
15:01:21 <Megzlna> The whole logo is totally ununique and unoriginal and doesn't express purity, functionality, lambdas, or anything good about Haskell anyways
15:01:21 <Taejo> pure . lazy . fun $ ctional
15:01:24 <Cale> (I named the data constructor S, to keep it separate in your mind from the type constructor ;)
15:01:39 <Cale> (in the mtl, both are called State though)
15:01:40 <Megzlna> has no chance to win
15:01:51 <Gracenotes> ah, I'm fine with State, I think
15:01:59 <Cale> okay
15:02:03 <Cale> now how about put?
15:02:08 <Cale> put :: s -> State s ()
15:02:26 <Cale> Its job is to produce the computation which sets the current state to the given one.
15:02:27 <vixey> Haskell_logo_ideas_falconnl.png <- lol sooooooo silly
15:02:58 <Megzlna> i think you gotta do more than a font and >>
15:03:05 <Megzlna> and catch phrase
15:03:10 <Gracenotes> so something of the form State (\s -> ((), s)), based on the definition of the State constructor
15:03:12 <vixey> catch phrase--
15:03:12 <chrisdone> wher's the page for the logo ideas?
15:03:17 <RayNbow> http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
15:03:22 <chrisdone> ta
15:03:28 <vixey> why does haskell want a logo?
15:03:30 <Cale> Gracenotes: in my convention, it's  s -> (s,a)
15:03:40 <RayNbow> "Comic Sans is the *Official Font of Haskell*, after all" <-- great comment on that page :p
15:03:52 <Gracenotes> Cale: ah. then switch () and s in the tuple
15:03:55 <Cale> Gracenotes: But for the mtl, that's correct :)
15:04:04 <pumpkin> RayNbow: please, no
15:04:09 <Cale> Gracenotes: The mtl's convention of using (a,s) is kind of bad.
15:04:11 <RayNbow> we gotta blame/praise SPJ for that :p
15:04:20 * pumpkin barfs
15:04:21 <Cale> The reason is that (,) s is a functor itself.
15:04:30 <RayNbow> (cross out the verb that's not applicable :p)
15:04:34 <osfameron> I like http://relapse-software.net/haskell_5.png though it might be a little hard to draw
15:04:50 <Cale> And so you'd want the State s functor to use that functor as part of its definition...
15:04:55 <vixey> http://haskell.org/sitewiki/images/c/c5/HsLogosMB.png <-- think busters!
15:04:57 <Cale> But it's kind of a subtle point.
15:04:58 <vixey> thunk*
15:05:06 <luite> RayNbow: I think there are enough people hating Comic Sans now that it's cool again to use it
15:05:23 <RayNbow> :p
15:05:27 <Megzlna> best logo ive seen is this one:
15:05:30 <Megzlna> http://www.haskell.org/sitewiki/images/8/86/Haskellwiki_logo_big.png
15:05:38 <vixey> yes
15:05:38 <olsner> yeah, you can use comic sans as an ironic comment nowadays
15:05:54 <RayNbow> hmm... how about a certain animal for the new Haskell logo?
15:06:20 * RayNbow coughs "Î»cat" :p
15:06:22 <vixey> a mythical one
15:06:33 <chrisdone> not a beetle
15:06:39 <pumpkin> lol
15:06:49 <mokus> lambda the hedgehog
15:06:50 <vixey> haskell should be some swamp dwelling thing
15:06:57 <erikc> how about a RED DRAGON
15:07:00 <pumpkin> RayNbow: maybe we need a sly fox? http://mine.icanhascheezburger.com/view.aspx?ciid=2605097&vk=6sroRAqXS1q3GWKronEM2IMBOiHliOaSPGble9W7Dox7LFNlxXe8n2XPZh4Ez4FKuiz8GDvRN%2bofXfnbEmkyFg%3d%3d
15:07:25 <Gracenotes> > let x = (runState (State (\s -> (s,s)) :: State Integer Integer)) in x 3
15:07:27 <lambdabot>   (3,3)
15:07:27 <Megzlna> http://www.spiritus-uk.com/Ambigram.jpg
15:07:32 <chrisdone> maybe a type of metal
15:07:35 <chrisdone> diamond, the hardest metal
15:07:38 <pumpkin> lo
15:07:50 <erikc> why do languages need logos
15:07:58 <RayNbow> pumpkin: how about an oleg-cat? http://arcanux.org/lambdacats/type-woes.jpg
15:08:09 <pumpkin> lol
15:08:13 <pumpkin> cats are so clichÃ© though
15:08:28 <chrisdone> erikc: well, the community wants representation, I think
15:08:29 <Peaker> There's an animal that's called "lazy" in Hebrew, not sure what its English name is
15:08:35 <Gracenotes> cats are cute :(
15:08:38 <chrisdone> a sloth?
15:08:40 <jml> Peaker: sloth probably
15:08:45 <RayNbow> cat(amorphisms) are awesome
15:08:50 <vixey> jml! perfect
15:09:07 <jml> I think the mascot should be a quokka.
15:09:10 <Cale> > runState (do x <- get; put (x+1); return x) 0
15:09:10 <Peaker> jml: yep, how'd you guess?
15:09:12 <lambdabot>   (0,1)
15:09:17 <jml> Saying "quokka" is fun.
15:09:17 <Gracenotes> sloth, great way to attract corporate marketers
15:09:34 <jml> Peaker: because "sloth" is an older word for "laziness" in English.
15:09:41 <Megzlna> Peaker: so, I got the record version.. how about the catamorphism version?
15:09:47 <Cale> > let inc = do x <- get; put (x+1); return x in runState (sequence [inc,inc,inc]) 0
15:09:49 <lambdabot>   ([0,1,2],3)
15:10:14 <chrisdone> "lol i dunno" http://img410.imageshack.us/img410/3673/sloth3pr7.jpg
15:10:28 <Peaker> Megzlna: catamorphism is about supplying a function to handle each possible pattern-match -- where recursive references to the same type get recursively applied the catamorphism, and fed to the outer one.  foldr is the catamorphism of lists
15:10:30 <Megzlna> sloth is already used
15:10:37 <vixey> by?
15:10:38 <chrisdone> it is?
15:10:40 <wli> Usually I shove a bag of state variables into a record and hammer out a few combinators to wrap the record access.
15:10:51 <mauke> http://sloths.us/wp-content/uploads/2007/08/sloth_in_a_box.jpg - boxed sloth jumps more ... uh ...
15:11:26 <vixey> they've got great clows
15:11:27 <vixey> claws
15:11:36 <Peaker> @src []
15:11:37 <lambdabot> data [] a = [] | a : [a]
15:11:41 <Peaker> @type foldr
15:11:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:11:43 <Megzlna> http://chl.be/mascots/
15:11:51 <Megzlna> ^-- free software mascots.
15:11:56 <olsner> mauke: that's just screaming for a \sloth about boxing
15:12:25 <chrisdone> hurr http://pbfcomics.com/archive_b/PBF135-Volcano_Snails.jpg
15:12:38 <Peaker> Megzlna: note that (a -> b -> b) handles the a : [a] case (2 fields -> 2 args), and b handles the [] case (0 fields -> 0 args), and then [a] can be converted to a "b" with these functions
15:13:01 <Peaker> Megzlna: the catamorphism of Maybe is the function called "maybe", and you can use that instead of pattern matching Just and Nothing
15:13:18 <Peaker> @src Maybe
15:13:19 <lambdabot> data Maybe a = Nothing | Just a
15:13:19 <Peaker> @type maybe
15:13:20 <Gracenotes> > let x = (runState (State (\_ -> ((),s)) :: State () Integer)) in x 3
15:13:22 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:13:22 <lambdabot>   Couldn't match expected type `Integer' against inferred type `()'
15:13:37 <Gracenotes> > let x = (runState (State (\_ -> ((),s)) :: State Integer () )) in x 3
15:13:38 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Expr'
15:13:49 <Gracenotes> hm, oh dear.
15:13:56 <Peaker> Megzlna: note "b" handles Nothing (0 args), and (a -> b) handles Just (1 arg)
15:14:05 <erikc> icarus flying toward the sun would be a good haskell logo
15:14:11 <Gracenotes> > let x = (runState (State (\s -> ((),s)) :: State Integer () )) in x 3
15:14:13 <lambdabot>   ((),3)
15:14:24 <Megzlna> Peaker: If you wanted to use 'maybe' inside a function, how would you feed the original Maybe to the funtion in the first place without matching?
15:14:43 <Megzlna> f m = blah (maybe m)
15:15:00 <Peaker> Megzlna: maybe can be used to "extract" the value out of a Maybe, not that way
15:15:00 <roconnor> Re: Malbolge: ``This is the hardest language to program in, hands down. To write a "Hello World" program, one programmer had to use a genetic algorithm that worked for hours before making a program that wrote "HEllO WORld" - that was the best it could do. It took a cryptanalyst to find "encryption weaknesses" - ways to make an instruction change in a predictable way - to finally make it possible to write simple programs in
15:15:00 <roconnor> Malbolge.
15:15:26 <erikc> logo for c++: http://www.indorphyn.com/wp-content/uploads/2007/01/Sisyphus.jpg
15:15:41 <vixey> haha
15:15:57 <roconnor> ``Malbolge was so difficult to understand when it arrived that it took two years for the first Malbolge program to appear.
15:16:08 <Peaker> > let  f x = maybe 0 (+1) x  in  (f (Just 5), f Nothing)
15:16:09 <lambdabot>   (6,0)
15:16:19 <rgr> Anyone know when and if hoogle will index xmonad and XMC? I cant build haddocks with latest code bases and can find no "interactive" API help anywhere.
15:16:30 <Peaker> Megzlna: f uses maybe to extract the value out of the Maybe, handling both Nothing and Just
15:16:50 <vixey> :t either
15:16:51 <teko> what do those cities have in common in the first chapter of RWH ??
15:16:52 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:17:23 <Gracenotes> teko: nothing! It's a red herring!</nontruth>
15:17:30 <Peaker> > let f = either (+1) (-1) in f (Left 10) (Right 20)
15:17:32 <lambdabot>       No instance for (Num (Either a t -> a1))
15:17:32 <lambdabot>        arising from a use of `...
15:17:36 <Peaker> > let f = either (+1) (-1) in (f (Left 10), f (Right 20))
15:17:38 <lambdabot>       No instance for (Num (b -> a))
15:17:38 <lambdabot>        arising from the literal `1' at <...
15:17:44 <Megzlna> Peaker: Ah that's what I wanted. And that's still considered catamorphism?
15:17:45 <Cale> Gracenotes: So is the State s monad beginning to make sense?
15:17:50 <Megzlna> how is that different from accessors?
15:18:00 <byorgey> rgr: what do you mean by 'interactive'?
15:18:01 <Megzlna> it looks like the accessors we did before
15:18:23 <Peaker> Megzlna: accessors usually extract just 1 field out of 1 data constructor, and errorize on any other/unexpected data constructor
15:18:29 <Gracenotes> Cale: sort of. I'm trying to 'simulate' a bind at the moment
15:18:39 <Peaker> Megzlna: the catamorphism is "complete" - it handles all fields of all data constructors, and it gracefully handles recursion as well
15:18:49 <Peaker> Megzlna: (if recursion exists, as in lists, with foldr)
15:18:52 <rgr> byorgey: search from editor or search interface in a set of data relative to the search. Think of what hoogle does and extent that thought to including xmonad ...
15:18:59 <byorgey> I don't think the online hoogle indexes hackage yet.
15:19:02 <Peaker> > let f = either (+1) (subtract 1) in (f (Left 10), f (Right 20))
15:19:04 <lambdabot>   (11,19)
15:19:15 <rgr> byorgey: I know. Thats why I asked when it might :-;
15:19:20 <Cale> Gracenotes: I think it might help to see a simple application. Consider the problem of writing a function which takes a binary tree of type  data Tree a = Leaf | Branch a (Tree a) (Tree a)  and relabels the nodes with the numbers from 1 up to the number of nodes, from left to right
15:19:22 <byorgey> I think ndm has talked about doing that but hasn't yet.
15:19:31 <byorgey> oh, wrong channel, I was responding to shepheb
15:19:33 <vixey> for every ADT there is a fold
15:19:35 <Gracenotes> > let (s', v) = (runState (State (\s -> ((),s)) :: State Integer () )) in let y = (runState ((State (\s -> (s,s)) :: State Integer Integer) v) s') in y 3
15:19:36 <lambdabot>   Couldn't match expected type `(t, t1)'
15:19:39 <rgr> heh, me too!
15:19:47 <vixey> for some GADTs there is no fold that is typeable in haskell (?)
15:19:49 <Gracenotes> heh, way too complicated to succeed
15:19:58 <Peaker> Megzlna: the less scary name of catamorphisms is "folds"
15:20:17 <Megzlna> the same old folds?
15:20:18 <Gracenotes> > let x = (runState (State (\s -> ((),s)) :: State Integer () )) in x 3
15:20:19 <Cale> Gracenotes: So the inorder traversal of the resulting tree will be [1..n]
15:20:20 <lambdabot>   ((),3)
15:20:37 <Peaker> Megzlna: well, foldl/etc are not really the catamorphisms of lists, so maybe its not exactly the same thing
15:20:47 <Peaker> Megzlna: but specifically foldr is *the* catamorphism of list
15:20:56 <Gracenotes> okay.
15:21:12 <Cale> Gracenotes: You might start by just trying to write this function withouth the use of the State monad
15:21:19 <Megzlna> Peaker: But, a catamorphism does not have to be recursive?
15:21:26 <Peaker> Megzlna: converting an ADT to the catamorphism function is a systematic/non-creative process, it could be done automatically (but unfortunately Haskell does not have that feature)
15:21:35 <Cale> Gracenotes: But you'll quickly find that it is awkward to write
15:21:36 <Peaker> Megzlna: A catamorphism is recursive iff the type is recursive
15:22:05 <Cale> Gracenotes: in order to know what label goes at the root node of the tree, you need to first label the entire left subtree.
15:22:06 <Gracenotes> it would be somewhat simple if the tree were full
15:22:14 <vixey> Peaker, mmorrow hacked it up in TH :)
15:22:19 <Peaker> Megzlna: List is recursive:  data [a] = [] | a : [a]  -- note the (:) data constructor references the [a] type inside it
15:22:31 <Peaker> vixey: cool! where is that?
15:22:42 <vixey> @where moonpaste
15:22:42 <lambdabot> I know nothing about moonpaste.
15:22:44 <Megzlna> hacked what in TH?
15:22:44 <ddarius> There are actually quite a few tools/approaches that let you "generically" create a fold.
15:22:50 <Peaker> Megzlna: so foldr is recursive.  maybe/either are not recursive, so their catamorphism isn't recursive
15:22:58 <Megzlna> i see
15:23:47 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=541
15:24:19 * Megzlna waits for Cale & Gracenotes to be done in order to grep and cut the whole conversation, remove all noise then read.
15:24:47 <Cale> Oh, mmorrow should have implemented something along the lines of Charity's syntax :)
15:24:49 <Megzlna> vixey: How is that useful?
15:24:58 <vixey> Megzlna, it's not
15:25:08 <Megzlna> goodness gracious then
15:25:23 <Megzlna> that's an awful lot of complexification to not do anything
15:25:30 <Cale> A quasiquoter catamorphism syntax would be cool
15:25:40 <vixey> I always type out folds in full
15:26:00 <Peaker> Megzlna: its useful that foldr, either, maybe, etc will be auto-generated
15:26:17 <Megzlna> heh okay
15:26:25 <vixey> it's just interesting to see polytypic programming
15:26:34 <Cale> [$cata| Leaf -> 1; Branch x l r -> l + r ]
15:26:51 <vixey> that would be great Cale
15:27:23 <dolio> vixey: Seems likely that the induction principle for GADTs would be typeable in Haskell + GADTs.
15:27:28 <Peaker> Cale: could also be viewed as pattern-matching-in-expression, not introducing a new scary "cata" word? :)
15:27:34 <Taejo> Megzlna, I'm sure others would appreciate the results of your grepping
15:27:57 <Cale> Peaker: Well, you could make the syntax nicer if it was a language extension
15:28:07 <dolio> Or, maybe + another extension or two.
15:28:09 <Cale> Peaker: and the name 'cata' was just chosen arbitrarily
15:28:14 <Peaker> I suggested that Cale decorated his tutorials with <tutorial> </tutorial> or so for greps :)
15:28:19 <Cale> If you want to call it 'fold' instead, that's fine with me :)
15:28:30 <Megzlna> sometimes we have intercalcate long conversations here
15:29:04 <dolio> Probably needs RankNTypes in general, too.
15:29:13 <Cale> I wonder if layout is available inside quasiquotes...
15:29:19 <vixey> I couldn't come up with an example but I feel like it shouldn't be possible
15:29:27 <Peaker> Its sad that IRC clients don't get interesting features -- heuristically splicing conversations, usable search, awareness of log-sites for backlog searching/etc...  Maybe an IRC client is a useful thing to practice Haskell on :)
15:29:57 <teko> @src take
15:29:58 <lambdabot> take n _      | n <= 0 =  []
15:29:58 <lambdabot> take _ []              =  []
15:29:58 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
15:29:59 <Cale> Peaker: I would like it if I could click on some names in the user list and restrict the conversation to just those names temporarily.
15:30:14 <Cale> Peaker: Or press a button to view just the lines which highlighted me.
15:30:30 <Peaker> Cale: yeah, and if generally the user list was ordered by activity in conversations with you, and then activity in general...
15:30:50 <Gracenotes> or have the feature built into software: a user is able to set up and invite others into a subconversation in a channel
15:30:56 <Peaker> Though after being exposed to the goodness of FRP, it'd be sad to revert back to (mature) imperative programming just to get an IRC client working
15:31:03 <Gracenotes> or join an existing subconversation
15:31:13 <Gracenotes> hm, talk about feature creep.
15:31:21 <Peaker> Gracenotes: I think if you have to explicitly create/join/leave sub-conversations, you might as well use channels?
15:31:44 <Gracenotes> yeah, I think so. But there's no way to join a conversation without already being in a channel.
15:31:57 <Gracenotes> whereas someone not in any conversation would see them all overlapping
15:32:21 <Megzlna> The distinction is that with subconversations you chance upon interesting things because you're joined by default rather than explicitly following into the proper new channel
15:32:28 <Peaker> well, just having a decent "grep" on my backlog would already be a great improvement
15:32:42 <Olathe> Ignore that filtered rather than blocked would be great.
15:32:50 <Gracenotes> quick! abandon freenode and set up our own haskell-based utopian chatting system!
15:32:57 <Peaker> So sub-conversations are joined by default, and you can filter them? How do you "tag" your messages for any specific conversation?
15:33:01 <teko> @src fst
15:33:01 <lambdabot> fst (x,_) =  x
15:33:29 <Gracenotes> PRIVMSG #haskell #state-monad :yada yada
15:33:47 <Megzlna> Peaker: You have bar of toggles. Each subconversation has an On/Off switch. Your current conversation is the one with a selection square around it
15:34:02 <Peaker> Megzlna: Sounds like too much trouble, nobody would bother
15:34:04 <Megzlna> You have an option set to "default on or off for new subconvos"
15:34:34 <Megzlna> Peaker: depends on the software
15:34:53 <Peaker> if the UI is really fancy, maybe
15:36:34 <Cale> Gracenotes: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=657#a657
15:36:59 <Cale> (nb. I wrote that code in the paste editor and didn't check it)
15:37:40 <Cale> But it should give you an idea of how the State Integer monad makes that task easier.
15:42:22 <Gracenotes> it seems you don't exactly have to understand it to use it -- superficially, applying the right syntax results in 'magic' :)
15:42:43 <Gracenotes> but, lemme see. hrm.
15:44:00 <Peaker> wow, from 2003: http://www.haskell.org/hircules/
15:44:27 <dolio> Mmm... Aliasing.
15:49:50 <Gracenotes> @undo do { l' <- relabelTree' l, x' <- getLabel, r' <- relabelTree' r, return (Branch x' l' r') }
15:49:51 <lambdabot>  Parse error at "," (column 26)
15:50:01 <Gracenotes> @undo do { l' <- relabelTree' l; x' <- getLabel; r' <- relabelTree' r; return (Branch x' l' r') }
15:50:01 <lambdabot> relabelTree' l >>= \ l' -> getLabel >>= \ x' -> relabelTree' r >>= \ r' -> return (Branch x' l' r')
15:51:46 <Gracenotes> so if the tree is just one node... return Leaf >>= \l' -> getLabel >>= \x' -> return Leaf >>= \r' -> return Branch(x' l' r')
15:52:22 <Cale> Like Branch x Leaf Leaf you mean?
15:52:29 <Cale> yeah, that's what'll happen
15:52:29 <Gracenotes> yeah.
15:52:38 <Gracenotes> return leaf being State (\s -> (s, Leaf))
15:52:44 <Cale> right
15:53:22 <Cale> You can check that  return v >>= f is the same as f v
15:53:34 <Cale> So l' will be bound to Leaf
15:53:40 <Gracenotes> runState (State (\s -> (s, Leaf))) 1 isn't too impressive, I'd think, but it'll work
15:53:55 <Cale> yes
15:53:58 <Cale> You can also write
15:54:01 <Gracenotes> yielding a... Leaf
15:54:05 <Cale> runState (return Leaf) 1
15:55:48 <wli> data Position = Position { x, y :: Int } ; goLeft = do { p <- get ; put (p {x = x p + 1}) } ;
15:56:34 <Cale> return v >>= f  =  S (\s -> let (s',w) = runState (return v) s in runState (f w) s')
15:56:34 <Gracenotes> what's the type of the State used there?
15:57:13 <Cale> = S (\s -> let (s',w) = runState (S (\t -> (t,v))) s in runState (f w) s')
15:57:21 <Cale> = S (\s -> let (s',w) = (s,v) in runState (f w) s')
15:57:35 <Cale> = S (\s -> runState (f v) s)
15:57:47 <Cale> = f v
15:58:08 <Cale> Gracenotes: where?
15:58:13 <Cale> (I have to go to dinner)
15:58:15 <Gracenotes> in wli's algorithm
15:58:32 <Cale> State Position ()
15:58:49 <Gracenotes> hm.
15:59:01 <Gracenotes> (I don't say "hm" *that* much in real life, by the way)
15:59:16 <Olathe> Why not ?
15:59:33 <Gracenotes> Oh, I say it. Just not as frequently as in the last few hours
15:59:38 <wli> The idea was to break down updates into moves like goLeft, goRight, goForward, goBackward
15:59:43 <Olathe> Ahh.
16:01:21 <idnar> @src sort
16:01:21 <lambdabot> sort = sortBy compare
16:01:24 <idnar> @src sortBy
16:01:25 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:01:42 <Gracenotes> insertBy's a long-ish one
16:01:45 <wli> goLeft = modify (\q -> q { x = x q - 1 }) ; goRight = modify (\q -> q { x = x q + 1 }) ; goForward = modify (\q -> q { y = y q + 1 }) ; goBackward = modify (\q -> q { y = y q - 1 })
16:01:47 <idnar> I thought sort was a merge sort
16:02:01 <Gracenotes> @src insertBy
16:02:01 <lambdabot> insertBy _   x [] = [x]
16:02:02 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:02:02 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:02:02 <lambdabot>                                  _  -> x : ys
16:02:52 <Peaker> I thought it was quick-sort
16:03:20 <idnar> quicksort would be rather awkward
16:04:03 <Gracenotes> it seems to be a sort of insertion sort (?)
16:04:13 <idnar> it seems to be exactly insertion sort
16:04:44 <dolio> sortBy in GHC is a merge sort.
16:04:54 <idnar> dolio: ah, okay
16:04:55 <Peaker> idnar: why? select pivot, divide by pivot, merge?
16:04:58 <saml> given a string, how can I count number of "blah"?
16:04:59 <dolio> The insertion sort there is from the report.
16:05:17 <saml> as substring
16:05:18 <saml> ok i'll do the homework myself
16:05:18 <Gracenotes> saml: are the "blah" overlapping?
16:05:25 <saml> could be. problem doesnt' specify
16:06:24 <idnar> Peaker: quicksort really wants random access
16:06:54 <Megzlna> If you use record syntax, how do you deal with every type creating conflicting functions?
16:06:55 <wli> I like heapsort.
16:06:57 <idnar> I'm sure there was a haskell-cafe thread about this
16:07:00 <dolio> It is pretty nice for the report that sortBy is a one-liner. :)
16:07:04 <idnar> or something
16:07:11 <dolio> Makes Haskell look nice and concise. :)
16:07:15 <saml> !split
16:07:18 <idnar> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
16:08:32 <Megzlna> how can you even have a 'name' record ?
16:09:08 <Gracenotes> Megzlna: name them getTypeValue?
16:09:15 <wli> I say just shove it all into a priority queue and dequeue until empty.
16:09:16 <Megzlna> ?
16:09:21 <blando> Megzlna: modules or embed namespacing in the accessors
16:09:28 <Megzlna> oh jeez
16:09:31 <Megzlna> that is horrible
16:09:40 <dolio> You can't create conflicting functions with records. One of the weaknesses of the current system.
16:09:44 <Megzlna> major language blunder
16:09:47 <Gracenotes> Megzlna: data Person = { getPersonName :: name }
16:10:03 <augustss> Megzlna: yeah, it's pretty ugly
16:10:07 <Gracenotes> makign the record's getters descriptive
16:10:11 <Gracenotes> *sp
16:10:44 <Megzlna> why isnt there a language extension to fix that?
16:11:12 <dolio> Hugs has improved records.
16:11:25 <dolio> People have written papers on other systems, too, but no one's ever implemented them for GHC.
16:12:26 <Megzlna> so do you guys literally make a module for every single type even though you cant even make multiple modules in a file
16:12:36 <pumpkin> not me
16:12:38 <augustss> Megzlna: it's not clear what the right record system is
16:12:44 <blando> no, most just use descriptive names
16:13:06 <augustss> Megzlna: It's not too nad in practice, actually.
16:13:20 <Megzlna> sounds fatal
16:13:27 <dolio> Most people don't need lots of record types with the same field names.
16:13:30 <blando> it can get annoying, though.  i'm working on a physics sim with a ton of structured, heirarchical data and a lot of repetative record members.  very irritating, but you just come up with a good naming convention and work through it
16:14:57 <Gracenotes> for (State (\s -> (s, Leaf)) >>= (\l' -> getLabel)) in http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=657... if the latter part is (a -> State s b), then what's b? Integer?
16:15:53 <Gracenotes> assuming relabelTree' is passed a one-node tree
16:16:13 <Megzlna> isnt there some totally different way?
16:16:51 <blando> there's always type classes
16:16:53 <blando> verbose, though
16:17:25 <Megzlna> how do you avoid the problem with typeclasses?
16:17:37 <Gracenotes> then that would yield State Integer Integer... combined with (Tree -> State Integer Tree), yields State Integer Tree.
16:17:59 <Botje> @pl \(a,b) (c,d) -> (a-c, b-d)
16:17:59 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (-)) . flip . (((.) . (,)) .) . (-))
16:18:08 <Botje> urgh. that's vile
16:18:54 <dolio> @type (-) *** (-)
16:18:54 <Olathe> @pl \(a, b) (c, d) -> (f a c, f b d)
16:18:55 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
16:18:55 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. f) . flip . (((.) . (,)) .) . f)
16:19:47 <Olathe> > join (***) (-) (a, b) (c, d)
16:19:49 <lambdabot>   Couldn't match expected type `t1 -> t'
16:19:52 <Olathe> Lies.
16:20:16 <dolio> @type (-) *** (-) >>> uncurry (***)
16:20:17 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a, b') -> (a, b')
16:21:34 <Gracenotes> then, State Integer Tree combines with (Tree -> State Integer Tree), creating... State Integer Tree :/
16:22:15 <JohnnyL> what are you people trying to accomplish?
16:22:16 <Gracenotes> executing runState with 1 finally realizes the result of the state actions, producing a beautiful... sort of... Tree
16:23:39 <Gracenotes> uh, anything and everything related to Haskell?
16:24:25 <byorgey> Gracenotes: sounds like a plan =)
16:24:37 <Taejo> JohnnyL, this channel is the closest I can get to attaining enlightenment just by having IRC open while I work
16:25:01 <saml> did you write python's split function?    "abcde".split("cd") ==> ["ab", "e"]
16:25:05 <Cale> Gracenotes: So relabelTree' turns the tree into a computation which when run with an initial state will produce the relabelled tree.
16:25:06 <ozy`> JohnnyL: what exactly are you referring to?
16:25:29 <Megzlna> I am genuinely furious
16:25:40 <Megzlna> I am trying to resist deleting my Haskell file
16:26:01 <blando> well that's quite furious
16:26:09 <augustss> Megzlna: what are you furious about?
16:26:10 <Saizan> think of the functions!
16:26:20 <Megzlna> I don't want to embarrass myself here and outright leave, I've already invested some time into haskell and have been learning
16:26:36 <Megzlna> but the namespace situation is fatal
16:26:47 <luite> Megzlna: have you used import qualified?
16:26:48 <augustss> Megzlna: btw, ghc had a bug once where it deleted the source file if it had a type error.  Quite sensible, I think.
16:27:05 <Megzlna> this thing totally descredits the entire language
16:27:10 <Olathe> Passive aggressive ghc.
16:27:21 <luite> augustss: hehe, that would teach people to think before compiling. dijkstra would've liked it :)
16:27:28 <blando> Megzlna: i'm with you on namespacing and record syntax, but the rest of haskell has always kept me coming back.  it's just too beautiful to ever let go
16:27:33 <ozy`> Megzlna: sheesh, relax
16:27:43 <Megzlna> Heh, I feel genuinely pissed
16:27:45 <augustss> Megzlna: That's just nonsense.  Put your records with conflicting fields in different modules.  Not a big deal.
16:27:49 <Megzlna> it was almost great
16:28:00 <ozy`> Megzlna has lots of issues with the details of certain things in Haskell
16:28:00 * EmielRegis http://www.tatom.org/documents/CNN.com-StudyNewstudyshows.htm
16:28:05 <SamB> Megzlna: yes, the records SUCK
16:28:12 <SamB> we KNOW that
16:28:18 <Philippa_> Megzlna: you use C++. As warts go, Haskell's namespacing is minor at worst and a non-wart at best
16:28:36 <SamB> isn't namespacing the only thing C++ gets remotely right ?
16:29:00 <Gracenotes> Megzlna: you could say the same thing about Java's one-to-one class/file relation. Just create a new file for each entity, and be done with it. So long as it doesn't get huge... uh, as most Java projects do :/
16:29:15 <Gracenotes> </my perhaps naive analysis>
16:29:22 <augustss> Megzlna: ghc also has an extension that handles many of the conflicts.
16:29:27 <ozy`> Megzlna: OCaml has a so-called "state of the art" namespace system that usually floors people
16:29:37 <Nafai> What's so special about it?
16:29:49 <SamB> ozy`: is it because the art is all missing ?
16:29:57 <ozy`> it's not haskell but you can still apply a lot of stuff that you've learned about haskell
16:30:15 <Megzlna> the prospect of making a file for every single type does not sound fun at all, and then doing it in an ad-hoc manner becomes messed up where you're randomly making files just because youo used a field called "name"
16:30:19 <ozy`> SamB: I don't actually know what people like about it. I know it has wacky reflection powers
16:30:30 <SamB> ozy`: what does now ?
16:30:33 <dons> ?users
16:30:33 <lambdabot> Maximum users seen in #haskell: 586, currently: 537 (91.6%), active: 29 (5.4%)
16:30:41 <ozy`> SamB: what castle?
16:30:46 <Philippa_> Megzlna: you don't need one per type, it's overlapping fieldnames that cause the problem
16:30:56 <Megzlna> Phil: That's why I said ad hoc
16:31:01 <Megzlna> trying to determine when
16:31:27 <Philippa_> it's fairly rate I find it causes me to change module boundaries
16:31:30 <Philippa_> *rare
16:31:48 <SamB> Megzlna: well, ideally you would invent the time machine and steal the coolest record system from the future
16:31:53 <Philippa_> also, you might want to be careful with how you abbreviate my name: you just regendered it
16:31:56 <SamB> and then bring it back and integrate it into GHC
16:32:10 <SamB> (and the Haskell report, I guess)
16:32:19 <Megzlna> Well, it also makes Circular data's messed up, where you define 2 separate ones which have fields of eachother's types
16:32:19 <Philippa_> often the typeclass wrapper's the right thing anyway
16:32:23 <luite> SamB: it'd be easier to steal a ghc from the future, that has already implemented it
16:32:29 <Megzlna> they can't have any similar names on the inner types
16:32:43 <SamB> luite: but that would mess up the VC history!
16:32:47 <Philippa_> like I said, do the typeclass thing
16:32:59 <ivanm> dons: ping!
16:33:16 <dons> pong
16:33:19 <SamB> can you imagine how confused git would get if the commit graph was was CYCLIC ?
16:33:28 <ivanm> I just got RWH yesterday! \o/
16:33:32 <dons> yay!
16:33:45 <ivanm> though I take it you didn't bother proof-reading the list of names of people who contributed? ;-)
16:33:55 <dons> mmm... somewhat...
16:33:58 <tromp_> I got RWH today!
16:33:58 <SamB> ivanm: why ?
16:34:02 <dons> yay!
16:34:11 <Philippa_> Megzlna: basically, you'll have to accept that records are a minor, inessential thing in haskell. Once that clicks, you'll be fine
16:34:19 <ivanm> since my name is listed twice (once with and once without my middle name), and someone else's name has a box in it, which I presume is an unprintable character
16:34:46 <dons> yes, the box we know about.
16:34:52 <dons> not sure about the duplicate. that's interesting..
16:34:56 <Megzlna> why are records minor?
16:35:11 <Megzlna> depends what you're doing, they'd certainly be minor in math haskell
16:35:14 <ivanm> dons: though I thought Haskell was a non-strict language, with most implementations interpreting that as laziness... or did you just want to not confuse the issue?
16:35:22 <Megzlna> doesn't seem minor in app haskell
16:35:30 <dons> "no strict" doesn't mean much to most people
16:35:37 <ivanm> fair enough
16:36:02 <ivanm> and a minor typo, but do we really use ` ""S ' to represent an empty string? ;-)
16:36:03 <augustss> Megzlna: I don't use records too much, but I cab't really give a good reason.  Pattern matching eliminates a lot of records, I guess.
16:36:08 <Philippa_> Megzlna: they're minor because you can get all the functionality another way
16:36:17 <Megzlna> how?
16:36:32 <ozy`> Megzlna: using regular constructor notation
16:36:33 <Philippa_> write a getter and a 'setter' and you're done
16:36:38 <dons> http://twitter.com/hydo/statuses/1059118959
16:36:45 <dons> interesting to read twitter feeds for 'haskell'
16:36:48 <SamB> now if only the Haskell compiler wrote a setter for you ;-P
16:36:48 <Megzlna> i hated getter and setter
16:37:00 <Megzlna> i was celebrating D leaving that stuff behind
16:37:11 <Megzlna> with proper properties
16:37:14 <ivanm> dons: so with your first code example, what do all those cities have in common? :s
16:37:18 <olsner> having to use records indicates you are trying to lump too much different data into one monolithic structure
16:37:24 <SamB> Megzlna: did you know that Haskell's record notation does just *slightly* more than define a getter ?
16:37:25 <Philippa_> yeah. But this is the one such wart the language has, and the syntactic overhead is much smaller
16:37:40 <Philippa_> olsner: I wouldn't go that far
16:37:57 <Megzlna> It makes reading your types look so nuked out
16:37:58 <ivanm> olsner: oh? I've used records when passing values around in simulations, etc.
16:37:59 <SamB> however, be aware that nobody is thrilled by Haskell records
16:38:00 <SamB> nobody
16:38:06 <Saizan> use TH to generate getters and setters
16:38:07 * mpeter is
16:38:11 <ivanm> basically for stuff that I wouldn't want to recompute in every iteration
16:38:16 <ozy`> Megzlna: have you ever tried ruby? (and no, I don't mean rails. don't go near rails.)
16:38:20 <luite> do many people here use the Data.Accesor package?
16:38:24 <luite> Accessor
16:38:24 <SamB> I will now kill mpeter to rectify the situation
16:38:25 <Philippa_> Megzlna: lucky thing that the type declaration doesn't include its functions, huh?
16:38:33 <ivanm> SamB: well, I'm not thrilled but I find them useful ;-)
16:38:35 * mpeter kills SamB in frightened self-defense
16:38:46 <Megzlna> data Person = Person { getFirstName :: String, getLastName :: String, getAge :: Int } deriving (Show)   -- this is so unreadable
16:38:53 <Megzlna> and then the 'f' working on a Person is even worse
16:39:03 <Megzlna> you put all that bullshit in the pattern match !?!
16:39:12 <ivanm> Megzlna: so spread it over multiple lines!
16:39:21 <Philippa_> Megzlna: you don't have to name them getSomething, something will do nicely
16:39:21 <Megzlna> its no better
16:39:25 <SamB> mpeter: well, what the heck mudhole did you crawl out of that leaves you thrilled with Haskell's record syntax ?
16:39:34 <olsner> Megzlna: fullName p = firstName p ++ " " ++ lastName p
16:39:35 <ivanm> Megzlna: IIRC, the new record extensions in 6.10 let you pattern match on a particular record field...
16:39:38 <augustss> Megzlna: I'd not call them getXxx.  That's confusing.
16:39:41 <Megzlna> fullName conflicts
16:39:55 <Megzlna> these're global names
16:40:00 <ozy`> Megzlna: data Person = Person String String Int -- this is the constructor way
16:40:01 <ivanm> Megzlna: but typically, people don't pattern match records AFAIK
16:40:04 <Philippa_> and that's when you throw it in a typeclass
16:40:36 <Gracenotes> Megzlna: apparently, you can use records for the constructor and just a regular list for pattern matching
16:40:36 <Megzlna> Philippa: How do you get the equivalent of "records" from the typeclass?
16:40:37 <SamB> really, we are just waiting for Oleg to invent us a better one, yes ?
16:40:41 <ozy`> firstName (Person n _ _) = n ; lastName (Person _ n _) = n; --etc.
16:40:52 <Philippa_> Megzlna: a typeclass per "field"
16:40:54 <Megzlna> ozy`: Horrible
16:41:05 <Megzlna> I dont remember the order
16:41:11 <SamB> Megzlna: that's just about what GHC does ...
16:41:19 <Megzlna> That's causing you to remember implementation details
16:41:22 <Megzlna> just to use the type
16:41:22 <Philippa_> so define some internal-use record names
16:41:26 <Philippa_> no, it's not
16:41:37 <Philippa_> those functions being defined? *Those* are what you use
16:42:09 <Megzlna> And if you've only got 3 fields then theres no reason to have records anyways
16:42:14 <Megzlna> so the records are useless
16:42:21 <ivanm> Megzlna: leave your prejudiced non-Haskell notions of what nice code looks like at the door please ;-)
16:42:25 <saml> @src sortBy
16:42:26 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:42:39 <saml> is this insertion sort?
16:42:43 <saml> @src insertBy
16:42:43 <lambdabot> insertBy _   x [] = [x]
16:42:43 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:42:43 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:42:43 <lambdabot>                                  _  -> x : ys
16:42:50 <ivanm> saml: I think so...
16:42:52 <ozy`> Megzlna: I'll ask again. have you ever used ruby?
16:42:56 <augustss> Megzlna: There's also -fdisambiguate-record-fields to make life easier.
16:43:02 <Megzlna> Ruby's VM is too slow, no chance
16:43:08 <Philippa_> Megzlna: the overhead sucks, no argument there. But you can give yourself something good enough once you've written the boilerplate, that's enough
16:43:31 <Megzlna> Philippa: .. a typeclass per field.. ..
16:43:37 <Megzlna> are you serious lol.
16:43:40 <Philippa_> yes. So? What's so horrific about that?
16:43:50 <augustss> Megzlna: I'd not do the typeclass thing unless forced to :)
16:43:56 <Philippa_> that's exactly one line more than writing the accessors to go with it
16:43:59 <Megzlna> It's fine when you're making a superstructure for your program, very common types, major themes
16:44:05 <Philippa_> augustss: me either. But I'm not the one insisting on it
16:44:06 <Megzlna> but not on Inner details
16:44:12 <augustss> Philippa: It's pretty bad when you have 100 fields.
16:44:22 <Taejo> Megzlna, do you know what a typeclass is?
16:44:30 <Megzlna> inside a given component, you have types which your whole codebase needs, and you have little localized types
16:44:36 <ivanm> Megzlna: language slowness depends on what you're doing with the language
16:44:39 <Philippa_> *nod*. I have to admit, I've been lucky enough not to have any case with 100 fields that didn't break up sensibly into subrecords
16:44:55 <ivanm> if you're IO bound, surely the speed of the VM is of less consequence?
16:45:06 <SamB> 100 records ?
16:45:11 <SamB> er. fields?
16:45:15 <SamB> what the heck ?
16:45:15 <Megzlna> ivanm: Ruby's VM is a joke. Not usable. I don't consider it a real language.
16:45:18 <augustss> SamB: sure
16:45:27 <ozy`> ivanm: he's a C++ guy. of course it has to run fast.
16:45:29 <Philippa_> SamB: sometimes the app domain drops it on you
16:45:30 <Megzlna> or a real implementation
16:45:32 <ivanm> Megzlna: it's Turing complete, isn't it? ergo, it is a real language
16:45:33 <Megzlna> rather
16:45:34 <ivanm> ozy`: heh
16:45:38 <ozy`> Megzlna: yes, 1.8 is dog slow. use 1.9
16:45:44 <ozy`> or JRuby
16:45:44 <Taejo> Megzlna, VM /= language
16:45:52 <ozy`> or MacRuby
16:45:59 <Philippa_> ivanm: read that as Real Language if you have to. In the same sense that Real Men smell and go "ug" a lot
16:46:02 <ivanm> @remember ozy` [about relative slowness of ruby] he's a C++ guy. of course it has to run fast.
16:46:02 <lambdabot> Done.
16:46:03 <JohnnyL> ozy`, All the commands sent to the bot. lol
16:46:09 <SamB> do they have psyco for Ruby yet ?
16:46:10 <augustss> SamB: I admit 100 is rare.  But 15-40 is pretty common.
16:46:22 <ivanm> Philippa_: ahhhh, neanderthals! :o
16:46:25 * ivanm is enlightened
16:46:28 * lament smells Philippa_ 
16:46:32 <Megzlna> and if you wanted to use Ruby, you could just use LuaJit instead
16:46:34 <lament> Ug! 8)
16:46:41 <SamB> augustss: with no sensible subdivisions ?
16:46:49 <Megzlna> anyways...
16:46:55 <Philippa_> lament: don't make me club you!
16:47:04 <Philippa_> SamB: like I said, app domain
16:47:05 <ivanm> lament: I think he meant that Real Men stink, not go around sniffing each otehr
16:47:05 <ivanm> *other
16:47:11 <Philippa_> ivanm: she
16:47:13 <lament> hey baby, wanna go clubbing (baby seals)?
16:47:20 <ozy`> SamB: without any kind of type information, it's impossible to perform any useful degree of inlining to help make ruby compilable
16:47:22 <ivanm> Philippa_: sorry, my mistake
16:47:23 <Megzlna> How does ML deal with this record problem?
16:47:27 * ivanm hangs his head in shame
16:47:31 <augustss> SamB: There might be, but is say a trade record is stored in a database with 100 columns, it's natural to read it into a record.
16:47:42 <SamB> ozy`: psyco doesn't have type information either!
16:47:58 <SamB> at least, not before the code runs
16:48:02 <augustss> Megzlna: ML basically has what -fdisambiguate-record-fields gives you.
16:48:04 <lament> Philippa_: sorry, too many puns, i'll stop hitting on you so you don't have to club on me
16:48:05 <int-e> augustss: hmm, but then you hopefully have a tool for generating the code for that record, and it could generate the type classes as well
16:48:09 <SamB> but then that's exactly when psyco compiles it, so ...
16:48:23 <Megzlna> augustss: what does -fdisambiguate-record-fields give you?
16:48:35 <ozy`> SamB: but is python as trigger-happy about metaprogramming as ruby is?
16:48:48 <SamB> ozy`: define metaprogramming
16:49:01 <augustss> It does what the name suggests, but not for the accessor function, nor updating.  But construction and pattern matching work.
16:50:00 <Megzlna> augustss: Construction? So you're saying that in Haskell, you cant even do  Person {first="Mr",last="Foo"} without it being ambiguous?
16:50:09 <augustss> int-e: I've never felt the need for the type classes, actually.
16:50:11 <int-e> ok, so it still sidesteps the complicated interaction of records and type checking; the decision of which accessor is meant is made by examining the constructor.
16:50:18 <ozy`> SamB: basically, lazy evaluation of class and method definitions rather than actual data ;)
16:50:19 <int-e> augustss: fair enough.
16:50:27 <augustss> Megzlna: That's right.  And that's pretty stupid.
16:50:30 <Megzlna> wow
16:50:40 <Botje> augustss: uh, wasn't that fixed in ghc 6.8.something?
16:51:13 <augustss> Botje: there's a flag.  But Haskell-98 says it's not allowed so you need a flag.
16:51:24 <idnar> ozy`: it shouldn't matter if you're doing just-in-time compilation
16:51:53 <Botje> oh, i misread, then
16:51:54 <Botje> nevermind :)
16:51:59 <Saizan> some of those metaprogramming tricks don't work in psyco, iirc
16:52:01 <augustss> Megzlna: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
16:52:07 <Botje> Haskell 98 regards all four as ambiguous, but with the -fdisambiguate-record-fields flag, GHC will accept the former two.
16:52:10 <Botje> just read that
16:53:00 <augustss> I use the C{..} notation a lot, so then it all works fine with that flag.
16:53:52 <Megzlna> Philippa, with your multiple typeclass way, were you meaning to not use Records at all, and have the typeclass instances pull them out using _ _ _ x _ _ _ _ _ ?
16:54:22 <Megzlna> or rather to do   data Person = Person { personFirst :: String, etc
16:54:27 <SamB> Megzlna: she said to use records with longer fieldnames internally
16:54:42 <Megzlna> combined with typeclasses to remove the "personFirst" and make it "first"
16:54:59 <Megzlna> How about template Haskell ?
16:56:36 <hoopy> so it turns our oreilly's ecommerce system didn't set up an oracle id for my account and i was unable to make a purchase
16:57:34 <saml> > filter ((>) 3) [2,1]
16:57:34 <Saizan> with TH you could write the type as $(mkRecord [d| data Person = Person {first :: String ... |]) and have mkRecord transform it in personFirst internally, and write the instances etc..
16:57:35 <lambdabot>   [2,1]
16:57:37 <Philippa_> Megzlna: take your pick. All are options
16:58:00 <saml> > filter ((>) 3) [2 .. 1]
16:58:01 <lambdabot>   []
16:58:45 <augustss> But TH is a pretty large hammer for such a small nail.
16:59:35 * mokus uses TH for small nails
16:59:43 * Megzlna now depressed about haskell
16:59:44 <mokus> especially when there's lots of them
17:00:40 <mokus> Megzlna: no language is perfect, but in practice haskell is still pretty darn cool despite its warts
17:01:29 <augustss> Besides, ambiguous record fields like that is just like C.
17:01:39 <ozy`> Megzlna: maybe you'd be more comfortable with a more object-oriented language
17:01:42 <augustss> C around 1980, that is.
17:01:50 <Peaker> augustss: what's the ambiguity?
17:01:53 <Megzlna> ozy`: This has nothing to do with OO
17:02:08 <saml> @src and
17:02:08 <lambdabot> and   =  foldr (&&) True
17:02:13 <augustss> Peaker: That you can't have the same field name in multiple records easily.
17:02:28 <ozy`> Megzlna: could've fooled me with your complaints :p
17:02:46 <Peaker> augustss: How can it be shared? What would the type of the "getter" be?
17:03:26 <Peaker> augustss: I see how it could be shared between different data constructors of the same type, is that what you mean?
17:03:29 <Megzlna> ozy`: Because a particular OO language was good at namespacing and solved an issue with fields, does in no way imply that such an ability is "owned" by OO
17:03:30 <augustss> Megzlna: You have to make a decision, either work around it in any of the suggested ways, or don't use Haskell.  Haskell won't change soon.
17:03:49 <Peaker> augustss: also, why does that make Person { first="Hello", last="Blah" } ambiguous?
17:04:07 <Megzlna> <augustss> C around 1980, that is.
17:04:12 <augustss> Peaker: Only if you've used first and last somewhere else.
17:04:31 <Megzlna> what he's referring to hasnt been ambiguous for 30 years
17:04:37 <Peaker> augustss: ambiguous in what way? According to the grammar here, first/last are fields of the Person data constructor?
17:05:04 <saml> @src (>)
17:05:04 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
17:05:46 <augustss> Peaker: OK, it's not ambiguous in that sense.  But I'm sure you know what I mean.
17:06:10 <Peaker> augustss: I really don't understand the ambiguity yet (Not trying to be annoying)
17:07:18 <Peaker> I guess I could read about what -fdisambiguate-record-fields is
17:07:42 <augustss> Peaker: then compile this if you don't understand: data Person = Person { first :: String, last :: String }; x = last Person{}
17:07:47 <pastorn> i'm working on a project euler problem, mor specifically #10, "sum all primes below two million". so what would be the fastest aproach here? "sum $ filter (isPrime . odd) [1..2000000]" or sumAllPrimesFromAndBelow this sumSoFar = if (odd this) then..."
17:08:27 <Olathe> I'd get the list of primes.
17:08:32 <pastorn> whoops... "if (odd this && isPrime this)"
17:08:39 <augustss> pastorn: sum $ takes 2000000 primes
17:08:43 <augustss> sorry
17:08:47 <Peaker> augustss: but that's just a general problem with the definition of names, not records?
17:08:55 <augustss> sum $ filter (< 2000000) primes
17:09:09 <Gracenotes> pastorn: in that case, you could do [3,5..2000000]
17:09:11 <ozy`> augustss: s/filter/takeWhile/
17:09:16 <Gracenotes> as a small optimization
17:09:26 <ozy`> augustss: otherwise you'll get an infinite list of nothing
17:09:28 <Olathe> pastorn: I'm not sure what your second choice is there.
17:09:31 <augustss> Peaker: but it's extra annoying with records.  You can't have two records with a field named, e.g., first (in scope).
17:09:32 <Gracenotes> very very small, in fact. Let's not even call it an optimization.
17:09:39 <pastorn> Olathe, augustss: but why would lists be faster than having a variable "sumSoFar" added to with each recursive call?
17:09:48 <augustss> ozy`: yes.  It's late :)
17:10:10 <augustss> pastorn: that's not the functional way
17:10:19 <Peaker> augustss: What does the flag do? I'd expect the solution would be to have records be namespaces for fields, perhaps
17:10:26 <pastorn> augustss: yes, i know
17:10:29 <Peaker> augustss: or does it try to figure it out from the types?
17:10:42 <pastorn> but from what i've learnt is that when optimizing haskell, make it look like C
17:10:45 <Megzlna> Peaker: it fixes one problem
17:10:52 <Megzlna> <Megzlna> augustss: Construction? So you're saying that in Haskell, you cant even do  Person {first="Mr",last="Foo"} without it being ambiguous?
17:11:06 <Peaker> Megzlna: how does it fix it, that's what I'm wondering
17:11:10 <augustss> Peaker: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
17:11:16 <Megzlna> You cant have another type with a record field called "first"
17:11:18 <Megzlna> and then go
17:11:28 <Megzlna> Anothertype { first="foo"   .. to construct
17:11:48 <Megzlna> but, that flag allows you to do it, in that context.
17:11:52 <augustss> Megzlna: There's already a function named last.
17:11:57 <pastorn> augustss: but what i was wondering is why one approach would be faster than the other? (and can this knowledge be generalized to more than just [Int]?)
17:12:12 <ozy`> augustss: couldn't he hide it with "import Prelude ()"?
17:12:21 <Megzlna> Peaker: but it does not fix the problem
17:12:29 <augustss> pastorn: It's impossible to say which is faster without seeing all the code.
17:12:34 <Megzlna> because you cant even define them in the same module
17:12:38 <Olathe> pastorn: I didn't understand the second approach.
17:12:51 <pastorn> Olathe: paste coming up...
17:13:10 <Olathe> Alright :)
17:13:36 <augustss> Megzlna: I've only found the problem mildy annoying in practice.
17:13:40 <Peaker> Megzlna: the problem is that records are not a namespace, IMO
17:13:57 <Peaker> Megzlna: People make them a namespace with prefixing, which is indeed somewhat annoying, but not terribly so
17:15:29 <ozy`> Peaker: that's why I suggested OO to him, since OO languages either implicitly or explicitly make new types their own namespaces... but he wants that in haskell
17:15:47 <ozy`> (implicitly in the case of message passing)
17:15:49 <Megzlna> ozy`: Again, this is unrelated to OO
17:16:01 <ozy`> Megzlna: no it's not. it's a problem OO was designed to solve
17:16:09 <Megzlna> not true, Ozy
17:16:09 <Peaker> Megzlna: I find Haskell's warts to be superficial issues that relate to its textual/syntactic encoding (unary minus, namespacing/names, records are more of a syntactic than a semantic thing, too).  Since I plan to get rid of textual encoding, they bother me less :-)
17:16:16 <ozy`> (one of the problems, not the only problem)
17:16:29 <Olathe> Unary minus is the work of SATAN !
17:16:44 <mpeter> Unary minus is the work of JESUS THE SAVIOR !
17:16:44 <saml> @src foldl
17:16:44 <lambdabot> foldl f z []     = z
17:16:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:16:54 <mpeter> @src foldl'
17:16:55 <lambdabot> foldl' f a []     = a
17:16:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:16:59 <augustss> Olathe: Actually, it was Joe Fasel.
17:17:00 <Peaker> ozy`: well, the common practice of prefixing the record name into each field, suggests that field names should be in the record namespace
17:17:20 <pastorn> hpaste.org/13110
17:17:34 <Megzlna> C is not OO, pascal isn't OO, Algol isnt OO, FORTH isnt OO
17:17:34 <Olathe> Oh, you all can look at who actually did it, but it's plain that Satan was behind it all.
17:17:38 <Megzlna> none of them had this issue
17:17:40 <pastorn> Olathe: ^^
17:17:43 <Megzlna> it was solved long before OO existed
17:18:36 <Peaker> Megzlna: Those languages don't have auto-getter functions, which is the source of the problem here
17:18:47 <Megzlna> Peaker: Getting rid of textual encoding is fine for logic and structure of a program, but does not invalidate the need for an adjective
17:18:50 <mpeter> soon they will make a board with a nail so big
17:18:53 <mpeter> it will destroy them all!!!!
17:18:53 <Olathe> pastorn: Is the second one slower ?
17:18:55 <ozy`> Megzlna: I dunno about Algol and Forth (did Algol even have records?) but the way C and Pascal solve it is by not using functions to manipulate the fields
17:19:02 <Peaker> Megzlna: it gets rid of the need for namespaces
17:19:20 <pastorn> Olathe: don't know... too tired to write "isPrime" at the moment
17:19:25 <Olathe> Ahh.
17:19:47 <Peaker> Megzlna: if you only ever use the records as you do in C, there's no problem, the idea is that you can pass around getters as ordinary functions
17:20:08 <Megzlna> Peaker, you cant use Haskell records as you do in C
17:21:05 <Peaker> Megzlna: you can with the -f augustss mentioned, it seems
17:21:16 <wagle> no (struct foo *) (&baz)?
17:21:22 <Megzlna> Peaker: You can only do that once
17:21:25 <Peaker> Megzlna: ?
17:21:27 <Megzlna> at construction time
17:21:41 <augustss> Megzlna: and pattern matching.
17:22:18 <pastorn> @src foldl
17:22:19 <lambdabot> foldl f z []     = z
17:22:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:22:21 <pastorn> @src foldr
17:22:21 <lambdabot> foldr f z []     = z
17:22:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:22:42 <augustss> Megzlna: And pattern matching with Person{..} is pretty cool.
17:22:48 <Peaker> Megzlna: So you can construct unambiguously, and extract via pattern matching unambiguously. The latter requires specifying the type - but so does C (even if in C you have to specify it separately)
17:23:16 <Megzlna> Peaker: You dont specify the type in C
17:23:23 <Megzlna> augustss: show us the pattern matching example?
17:23:36 <augustss> Megzlna: yes, you do.  when you declare the variable.
17:23:49 <rgr> Anyone here found a way to get http://holumbus.fh-wedel.de/hayoo/hayoo.html to search on a passed url term? Currently I can only make it seacrh on the up keystroke, so its impossible to invoke from, say, emacs using browse-url "url:keyword"
17:23:50 <Megzlna> You declare a variable to be of a type, of course.
17:23:52 <Peaker> Megzlna: If its done on a variable, you do (which is usually the case)
17:23:59 <Megzlna> You don't write the type every time you go s.x
17:24:01 <augustss> Megzlna: name Person{..} = firstName ++ " " ++ lastName
17:24:01 <Megzlna> there's no
17:24:03 <Megzlna> s.MyType x
17:24:35 <ozy`> augustss: is that literally what it looks like?
17:24:41 <augustss> ozy`: yes
17:24:51 <Peaker> Megzlna: C can "infer" the type trivially in some cases, but who uses funcall().member in C?
17:25:13 <Megzlna> Peaker: There's no "infer"
17:25:31 <augustss> Peaker: C can infer the type then too.  There's very little "inference" needed.
17:25:33 <Megzlna> It simply works 100% of the time. You never provide the type.
17:25:45 <Megzlna> It doesn't need to infer anything because it only has concrete types.
17:25:51 <Peaker> Megzlna: you provide the type of the variable you're accessing the member of
17:25:58 <Megzlna> Peaker: No.
17:26:08 <augustss> Megzlna: that's because you provide the type of variables in C, which don't have to in Haskell.  C's solution just doesn't work for Haskell.
17:26:24 <Gracenotes> > (mempty :: String)
17:26:25 <lambdabot>   ""
17:26:27 <Gracenotes> yay
17:26:31 <Megzlna> yeah, You do type your variables heh
17:26:46 <Peaker> Megzlna: void f() { Blah b; b.member; }  --   f = case b of Blah{..} -> use fields here
17:26:51 <Peaker> Megzlna: both mention Blah once
17:27:01 <Megzlna> Yeah, C's like that, but not C++ or D
17:27:08 <Gracenotes> > (mappend "Hello " "monoids")
17:27:08 <Peaker> Megzlna: note that I can pass around the getter functions, and you can't do that in C, C++, or D
17:27:09 <lambdabot>   "Hello monoids"
17:27:21 <Megzlna> Peaker: You can in C++ and D
17:27:31 <Megzlna> boost::function or D delegate
17:27:42 <Peaker> Megzlna: fmap myRecordField [records] -- what's that in C++/D?
17:27:43 <Gracenotes> > mconcat $ words "A B C D E"
17:27:44 <lambdabot>   "ABCDE"
17:27:49 <ozy`> Megzlna: hmm, is boost part of the standard library now?
17:27:49 <Gracenotes> sweet.
17:27:57 <Megzlna> ozy`: boost is std++
17:27:59 <Taejo> Gracenotes, if you like monoids, wait until you see free commutative idempotent monoids
17:28:13 <Megzlna> pieces of Boost get introduced into the STD over time
17:28:14 <ozy`> Megzlna: I asked: is boost part of the standard library now?
17:28:19 <Megzlna> ozy`: Some of it
17:28:23 <Gracenotes> *raises eyebrows*
17:28:26 <Megzlna> 20 pieces of boost were just added to tr1 STD
17:28:29 <ozy`> including boost::function, then?
17:28:30 <Peaker> Megzlna: What's that code in C++/D?
17:28:37 <Megzlna> ozy`: Yes, including boost::function
17:28:48 <Megzlna> boost::function is now official tr1 C++ and ships with all major compilers
17:28:51 <Taejo> Gracenotes, free monoid == List. free commutative idempotent monoid == Set
17:29:03 <Megzlna> renamed to tr1::function
17:29:20 <saml> what's big-O of intersection?
17:29:30 <ozy`> Megzlna: okay, cool... now then, Peaker's question. how do you do "fmap myRecordField [records]" in C++ or D?
17:29:32 <saml> O(n+m) oh darn doc says so
17:29:48 <Taejo> saml, you were hoping for something faster?
17:30:05 <Gracenotes> free monoid is any number of mappends, then, with restriction?
17:30:07 <saml> Taejo, no i thought the best possible was O(n*m)
17:30:10 <Gracenotes> *without
17:30:12 <Megzlna> well, I don't even know what fmap is in Haskell
17:30:16 <Megzlna> @src fmap
17:30:16 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:30:24 <Peaker> Megzlna: then map, not fmap
17:30:35 <saml> well building a Set is O(n*log N)
17:30:40 <Peaker> Taejo, saml: That sounds too good
17:30:47 <Gracenotes> and free idempotent monoid is any number of mappends, without restrictions, such that same elements are essentially discarded in comparisons?
17:30:48 <ozy`> Megzlna: well in this case it's the same as map. fmap is just map generalized to all applicable "container" types
17:31:13 <Peaker> Taejo, saml: Doesn't it have to traverse the trees?  Something like O(min(m*log(n), n*log(m)))
17:31:20 <Gracenotes> and free commutative idempotent monoid... hm... I'm kind of lost on the commutative part, Taejo
17:31:27 <mokus> ozy`:  oh darn doc says so
17:31:30 <Taejo> Peaker, it can go left-to-right on both trees at once
17:31:39 <mokus> argh, bad copy/paste ,sorry
17:31:43 <Peaker> Taejo: oh, right :-)
17:31:55 <Taejo> Gracenotes, commutative ~= order doesn't matter
17:31:59 <Peaker> Taejo: they're basically sorted lists when you want them to be, yeah
17:32:12 <Gracenotes> oh! gotcha.
17:32:15 <saml> i have 2 lists. i want to get intersection of the lists and turn it into set (only uniq elements)
17:32:23 <Taejo> Peaker, I believe cons is log n
17:32:23 <saml> what's my best runtime efficiency?
17:32:34 <dolio> You don't do it in C. Such willy-nilly allocation would be insane. :)
17:32:38 <Peaker> Taejo: what's cons for sets?
17:32:40 <Gracenotes> cool. Not sure what use it is outside of pure math, but it's a pretty name.
17:32:43 <saml> i can do it in O(n*m) naive way
17:32:58 <Taejo> Peaker, insert element guaranteeing that it's smallest
17:33:03 <ozy`> Megzlna: would you write a for loop? e.g. for (i = 0; i < some_length; i++) result[i] = records[i].field;
17:33:06 <Peaker> saml: You can convert both to sets O(n+m) and then intersect them as sets O(n+m) again?
17:33:16 <Megzlna> std::for_each(v.begin(), v.end(), bind(&X::f, _1, [](int x){ do stuff; }));
17:33:26 <saml> Peaker, converting to sets is O(n*logn)
17:33:27 <Peaker> Taejo: guaranteeing how you mean?
17:33:44 <Gracenotes> @instance Monoid
17:33:44 <lambdabot> Maybe you meant: instances instances-importing
17:33:49 <Peaker> saml: oh, right, still better than O(n*m) ?
17:33:49 <saml> so, it's like O(m*logn + n*logn + m + n)
17:33:52 <Gracenotes> @instances Monoid
17:33:53 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:33:54 <Taejo> Peaker, I mean programmer's proof obligation ... like fromAscList
17:33:58 <Megzlna> like that
17:34:03 <Megzlna> you just make a binder to some member
17:34:06 <Peaker> saml: so O(m*logm + n*logn)
17:34:08 <Megzlna> you can do whatever you want with the bind
17:34:08 <Gracenotes> hm.
17:34:11 <saml> right
17:34:13 <ozy`> Megzlna: I can see what you mean about how C++ has much more elegant and readable record manipulation syntax
17:34:36 <Peaker> Taejo: ah, so the same complexity as any insertion
17:35:02 <SamB> ozy`: that's the thing they took from C that still fits well
17:35:25 <Taejo> Peaker, yeah
17:35:25 <Peaker> ozy`: I had to read what he wrote above to realize you were sarcastic :P
17:35:29 <Taejo> bye
17:35:38 <ozy`> Peaker: you were able to read it?
17:35:50 <Megzlna> Its because theres a lambda in there
17:35:53 <Megzlna> I used a lambda in the binder
17:36:12 <Megzlna> otherwise, it would look normal.
17:36:37 <SamB> where was the Î»?
17:36:52 <augustss> []
17:36:57 <Peaker> Megzlna: can you agree that the Haskell record getter is nicer?
17:36:59 <ozy`> SamB: bind(&X::f, _1, [](int x){ do stuff; }) <== that part
17:37:03 <Megzlna> Peaker: No
17:37:08 <pastorn> i have "isPrime x = any ((==0) . mod x) [2,3 ..(div x 2)]
17:37:09 <SamB> I see no lambda
17:37:16 <Megzlna> The Haskell record is total failure
17:37:19 <JohnnyL> how does haskell compare against logic programming language like prolog?
17:37:25 <ozy`> JohnnyL: yes.
17:37:28 <SamB> Megzlna: I'd have to disagree
17:37:28 <pastorn> is there any way to make it a bit faster withot making it all too complicated?
17:37:38 <SamB> it's *slightly* better than nothing
17:37:39 <Peaker> Megzlna: map myRecordField [records] is pretty clear -- I still don't understand what your "equivalent" does
17:37:43 <ivanm> Megzlna: you have to take into account that the Haskell record syntax is a compromise
17:37:50 <augustss> Megzlna: then I suggest you give up Haskell.  Because it's not changing soon.
17:37:50 <ivanm> see the interview by SPJ recently
17:37:58 <ivanm> s/by/of/
17:38:02 <Megzlna> Ok, looking at freakish C++ lambda syntax and some how comparing that to C++'s most basic ability to do   'f.x'  is not analogous
17:38:04 <SamB> augustss: how about 10 years ?
17:38:21 <Peaker> Megzlna: f.x is not a function that takes "x" out of f's type
17:38:28 <ivanm> SamB: so how do you define soon? ;)
17:38:44 <augustss> SamB: I hope so.  But records are not high on anyones priority list, I think.
17:38:45 <SamB> ivanm: well, that actually seems like it would be soon to me
17:38:47 <Peaker> Megzlna: Haskell records do create that as a function - and thus there's a problem if that function is named in the global scope
17:39:01 <Peaker> Megzlna: th problem is not solved in C/etc, its just not there, because they don't have it as a function at all
17:39:01 <SamB> augustss: so it's like I said -- we are waiting for oleg to come up with a better one ?
17:39:09 <Megzlna> Peaker: indeed it's not. o.x is merely referring to O::x of an instance
17:39:21 <Megzlna> it's a qualified name
17:39:25 <SamB> Megant: what is this O::x
17:39:28 <augustss> SamB: No, we already have several better ones.  But nothings shines brightly.
17:39:30 <SamB> I don't think there is such a thing
17:39:37 <SamB> hmm
17:39:37 <Megzlna> You could just as easily write global getters/setters in C/C++ as you can in Haskell
17:39:51 <SamB> augustss: so ... why aren't we using one of the better ones?
17:39:52 <ozy`> pastorn: by using [2,3..n] you regenerate that list every time the function is called
17:39:53 <Megzlna> Just because Haskell has no ability to have T.x does not mean its better
17:39:55 <Peaker> Megzlna: Yes, if you want a getter function, you have to convert it to one.  In Haskell its always a function, which is simpler (less special syntax) and more powerful, but requires an extra name
17:39:59 <Megzlna> its simply only able to do Half
17:40:09 <Megzlna> the T.x is the entire name
17:40:10 <Peaker> Megzlna: You get the getter for free in Haskell
17:40:12 <augustss> SamB: which one?
17:40:32 <SamB> augustss: we could just pick one at random and try it for the next decade
17:40:33 <Peaker> Megzlna: You have to write it in C++/D
17:40:33 <Megzlna> Peaker: You get it for free injected into your global naemspace like some useless piece of crap
17:40:49 <Peaker> Megzlna: alrighty then
17:40:51 <Peaker> good night!
17:40:54 <ozy`> pastorn: define a list "primes = 2 : filter isPrime [3,5..]" (or something) to memoize the primes you've calculated
17:41:08 <augustss> SamB: that got us into the mess we're in last time it was tried.
17:41:11 <ozy`> pastorn: primes and isPrime can refer to each other
17:42:00 <SamB> augustss: but you said the new ones are better
17:42:02 <Megzlna> Heh, I dont know how anyone could even argue that making global functions for each record field is good, it's basicaally heavy duty kool aid swallowing / religious justification
17:42:07 <pastorn> ez
17:42:08 <augustss> Megzlna: you get it injected into your module namespace like some useless piece of crap
17:42:21 <JohnnyL> is there a smaller haskell channel?
17:42:28 <pastorn> ozy`: just thought of that... lazyness will keep generated primes remembered, right?
17:42:30 <augustss> SamB: but are they better enough?
17:42:37 <ozy`> JohnnyL: yes. #haskell-cafe, for one
17:42:41 <ozy`> pastorn: exactly
17:42:41 <pizza_> #hskl
17:42:45 <JohnnyL> ozy` thanks
17:42:59 <Olathe> #smaller-haskell has only one person in it.
17:43:07 <Megzlna> augustss: Is the field 'x' appropriate?
17:43:17 <JohnnyL> ozy` no one there
17:43:22 <ivanm> ozy`: that's mean... (what you said to JohnnyL)
17:43:24 <ivanm> JohnnyL: it doesn't exist
17:43:36 <augustss> Megzlna: I'd never use it. :)
17:43:46 <ivanm> except that as soon as you did /join #haskell-cafe, Freenode decided to create it for you
17:43:46 <ozy`> ivanm: whoops, I thought it did :
17:43:48 <ozy`> :\
17:43:51 <ivanm> ozy`: nope
17:43:57 <ivanm> this is the real deal ;-)
17:44:03 <lucca> for this prime discussion there was a nice paper on LtU recently
17:44:11 <lucca> that kinda blew the typical one liner out of the water
17:44:27 <lucca> http://lambda-the-ultimate.org/node/3127
17:44:37 <ozy`> lucca: yeah, there are much nicer algorithms. pastorn wants a simple one though
17:44:44 <ivanm> JohnnyL: there is #haskell-blah and #haskell-chat IIRC, but they're for non-haskelly topics by haskellites... otherwise, other haskell channels are either language-specific or topic-specific (e.g. #gentoo-haskell is _meant_ to be about haskell packages in gentoo)
17:44:45 <Megzlna> well, I'm done with Haskell.
17:44:59 <Megzlna> and sad
17:45:31 <ivanm> Megzlna: if you decide not to use a language just because one language construct doesn't behave as you'd expect in other languages, then I pity you
17:45:33 <mokus> Megzlna: how much haskell have you written?
17:45:49 <augustss> Megzlna: too bad.  you never got to experience the fun.
17:45:57 <lucca> is this angst about record construction?
17:46:04 <augustss> lucca: yes
17:46:10 <Olathe> If you leave Haskell for a reason we didn't leave Haskell, you're evil !!
17:46:13 <Olathe> EVIL !
17:46:29 * ddarius says, "Good riddance."
17:46:35 <ivanm> Olathe: but.... AFAIK, none of the rest of us have left Haskell... :s
17:46:37 <ozy`> mokus: Megzlna won't learn haskell because he is dissatisfied with it
17:46:41 <lucca> Megzlna: it'd probably be better to just make yourself your own set of functions for manipulating these records
17:46:42 <Olathe> ivanm: Exactly !
17:46:42 <augustss> Megzlna: I've written a few hundred thousand lines of Haskell.  And the record problem has never worried me.
17:47:00 <ivanm> ddarius: though it's a slightly better rationale than the person who left because they didn't like the unary negation issues
17:47:02 <lucca> but barring that i'm sure we'll all wish you goodluck&goodbye... lazily :p
17:47:16 <Megzlna> sigh
17:47:18 <mokus> ozy`: yea, I've noticed too - I've been watching with amusement for a week or 2
17:47:39 <ivanm> lucca: what, he's got to ask us personally in turn for our best wishes before we bother to formulate them? ;)
17:47:48 <mokus> ozy`: I think it's funny that he's analyzing it to death rather than actually trying it ;-)
17:47:51 <augustss> Someone left because of unary negation?
17:47:59 <augustss> There's a person with principles!
17:48:25 <pastorn> lucca: this is for project euler... not winning any turing awards here...
17:49:28 <Megzlna> i was highly motivated
17:49:37 <conal> Megzlna: i'm glad you gave haskell something of a try.  i hope you got something useful for yourself out of the experience.
17:49:58 <Gracenotes> > foldr mappend [] (map (Last . Just) [3,2,5])
17:49:59 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Last a1'
17:50:11 <ozy`> Megzlna: I'm curious, why exactly did you want to learn Haskell in the first place?
17:50:13 <Gracenotes> > foldr mappend (Last Nothing) (map (Last . Just) [3,2,5])
17:50:14 <lambdabot>   Last {getLast = Just 5}
17:50:52 <Gracenotes> > (Last Just 4) `mappend` (Last Just 7) `mappend` (Last Just 49)
17:50:53 <lambdabot>   Couldn't match expected type `Maybe a'
17:51:06 <Gracenotes> > (Last $ Just 4) `mappend` (Last $ Just 7) `mappend` (Last $ Just 49)
17:51:07 <lambdabot>   Last {getLast = Just 49}
17:51:12 <roconnor> heh, Haskell "records" do suck.
17:51:34 <augustss> roconnor: nobody has disputed that :)
17:51:40 <ivanm> roconnor: as do must compromises
17:52:04 <Gracenotes> > (Last $ Just 4) `mappend` (Last $ Just 7) `mappend` (Last Nothing)
17:52:05 <lambdabot>   Last {getLast = Just 7}
17:52:35 <Gracenotes> > (Sum 4) `mappend` (Sum 5) `mappend` (Sum 6)
17:52:36 <lambdabot>   Sum {getSum = 15}
17:52:52 <ozy`> Megzlna: I'm still curious
17:53:00 <augustss> Gracenotes: having fun with monoids?
17:53:14 <Megzlna> ozy`: trying not to talk
17:53:19 <Megzlna> you heard enough from me
17:53:23 <Megzlna> I'm sitting here feeling "anger" inside about the records
17:53:34 <Gracenotes> augustss: trying to savor the fun while it lasts :)
17:53:39 <lucca> pastorn: if you're doing those problems for learning, then you should especially look at that paper when you get the chance...
17:54:58 <lucca> ivanm: that, or perhaps because he'll figure out something better and stay so we don't need to...
17:55:04 <ddarius> ivanm: The rationale wasn't why I said that.
17:55:09 <Gracenotes> > All `mappend` All
17:55:10 <lambdabot>       Overlapping instances for Show (Bool -> All)
17:55:10 <lambdabot>        arising from a use ...
17:55:55 <ozy`> Megzlna: not gonna stop being curious... I'll just ask you later
17:55:57 <erikc> ok...unpackaging my very first mac
17:56:07 <_dolio> > getAll . msum . map All $ [True, False, True, True]
17:56:08 <lambdabot>   Couldn't match expected type `m a' against inferred type `All'
17:56:17 <_dolio> > getAll . mconcat . map All $ [True, False, True, True]
17:56:19 <lambdabot>   False
17:57:06 <Gracenotes> > getAll . msum . map (Product . Just) $ [1..10]
17:57:07 <lambdabot>   Couldn't match expected type `All'
17:57:09 <Gracenotes> oops
17:57:22 <Gracenotes> > getProduct . mconcat . map (Product . Just) $ [1..10]
17:57:23 <lambdabot>       No instance for (Num (Maybe a))
17:57:23 <lambdabot>        arising from a use of `mconcat' ...
17:57:39 <Gracenotes> >_>
17:57:59 <Gracenotes> > map (Product . Just) $ [1..10]
17:58:00 <lambdabot>   [Product {getProduct = Just 1},Product {getProduct = Just 2},Product {getPr...
17:58:54 <Gracenotes> > getProduct . foldr mconcat map (Product . Just) $ [1..10]
17:58:55 <lambdabot>   Couldn't match expected type `[[((a -> b) -> [a] -> [b])
17:59:18 <Lemmih> Gracenotes: You can also talk to lambdabot in private.
17:59:41 <Gracenotes> I suppose.
17:59:47 <ivanm> ddarius: oh? why then?
18:00:04 <ivanm> or you can get your very own private lambdabot...
18:00:13 <ivanm> or you can run a hugs or ghci session...
18:00:21 <ivanm> the possibilities are endless! \o/
18:00:22 <ivanm> ;)
18:01:02 <Gracenotes> there's also a lambdabot that responses to queries in the #haskell channel on irc.freenode.net, anonymous sources have revealed to me
18:01:51 <Lemmih> GHCi needs a --spam flag that sends every line to #haskell, haskell-cafe@ and twitter.
18:01:53 <ivanm> heh
18:02:10 <ivanm> Lemmih: who's twitter account are we going to use?
18:02:19 <Olathe> > srsly
18:02:20 <lambdabot>   No, it's not true.
18:02:24 <ivanm> and why not the otehr mailing lists whilst we're at it?
18:02:38 <Gracenotes> it would be neat to use twitter as a sort of interpretor
18:02:53 <ivanm> Olathe: do I dare ask who told lambdabot to remember that pseudo-function?
18:03:21 <dolio> > length "Algorithms"
18:03:22 <lambdabot>   10
18:03:51 <dolio> > length "Bytestring"
18:03:53 <lambdabot>   10
18:04:20 <Olathe> > should_he
18:04:22 <lambdabot>   No, it would reveal too much.
18:04:27 <ivanm> dolio: what, you couldn't count the number of letters by hand? ;)
18:04:35 <dolio> Too much work.
18:04:38 <ivanm> @slap Olathe
18:04:38 * lambdabot clobbers Olathe with an untyped language
18:04:41 <Olathe> :(
18:04:50 <ivanm> dolio: as opposed to typing the word in?
18:04:56 <dolio> Right.
18:05:03 <Megzlna> http://www.haskell.org/pipermail/haskell-prime/2006-March/000884.html
18:05:05 <porges> does GHC enforce minimal complete definitions?
18:05:12 <dolio> I type a lot faster than I count letters on a screen.
18:05:17 <porges> s/does/can
18:05:42 <ivanm> dolio: surely you could have counted as you typed...
18:05:56 <dolio> So, do large qualified names get around the long-module-name bug?
18:06:13 <ivanm> no idea what you're talking about, tbh
18:06:25 <Lemmih> Megzlna: You're not doing a very good job at keeping quiet.
18:06:35 <dolio> ivanm: If your module names are too long, you get a 2x - 3x performance decrease in GHC. :)
18:06:39 <dolio> Newly discovered.
18:06:44 <ivanm> dolio: :o
18:06:49 <ivanm> how come? :o
18:07:01 <dolio> Something funky going on with the assembly, I guess.
18:07:14 <ddarius> ivanm: Megzlna is just here to make noise.
18:07:30 <Gracenotes> > foldr mconcat (Product Nothing) (map (Product . Just) [1..10]) -- perhaps an appropriate use of lambdabot -- what's going on here?
18:07:31 <lambdabot>   Couldn't match expected type `[Product (Maybe a)
18:07:42 <dolio> Let me find you a mailing list link. It's pretty awesome.
18:07:45 <ivanm> ddarius: fair enough
18:08:04 <ivanm> ddarius: but is the noise he generates could enough to produce random numbers with? ;)
18:08:33 <ivanm> s/could/good/
18:08:37 <ivanm> gah
18:08:42 <dolio> ivanm: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-December/016343.html
18:08:58 <ddarius> ivanm: I wish, but we have mpeters for that.
18:09:15 <ivanm> heh
18:09:48 <saml> where can I find source of Data.Set?
18:09:54 <saml> @src Data.Set.fromList
18:09:54 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:09:56 <ddarius> @source Data.Set
18:09:57 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
18:10:07 <Gracenotes> oh, I think I get it. mconcat automatically folds it
18:10:11 <Gracenotes> thanks channel
18:10:14 <ddarius> @src mconcat
18:10:14 <lambdabot> Source not found. You untyped fool!
18:10:16 <dolio> Ooo, that's out of date.
18:10:18 <ddarius> Cripes.
18:10:24 <Lemmih> Gracenotes: Product doesn't know how to multiple Maybe's.
18:10:51 <ivanm> dolio: I guess we're going to see a spate of renaming to A/B.hs style files and module names then ;)
18:11:14 <dolio> :) augustss has already said he's doing as much.
18:11:33 <ivanm> heh, just got to that email
18:11:55 <ivanm> though no-one else has seem to have said anything since :o
18:12:36 <ivanm> dolio: does that include the directory qualifications, or just the actual file name?
18:12:40 <Gracenotes> wait -- why did I put Maybes there in the first place?
18:12:42 <ivanm> the emails didn't seem to say either way
18:12:55 <dolio> That's what I was wondering earlier.
18:13:00 <Gracenotes> and how does the type system check for multiple Maybes? hm.
18:13:00 <ivanm> i.e. if we have a module called IsThisGoingToBeSlowAsWell.A
18:13:01 <ivanm> heh
18:13:35 <dolio> I don't know what the assembly looks like for higherarchical modules.
18:14:01 <SamB> dolio: it has longer symbol names!
18:14:34 * Gracenotes should have quit while ahead
18:15:05 <dolio> Might be good news, though. Maybe uvector-algorithms will spontaneously get 3x faster when this is fixed.
18:15:08 <Apocalisp> @hoogle (Monad m) => a -> m b -> m (a, b)
18:15:09 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
18:15:09 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
18:15:09 <lambdabot> Control.Monad.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
18:15:09 <dolio> Then we'll be beating C++.
18:15:24 <ivanm> dolio: heh
18:15:27 <dolio> Handily.
18:15:44 <ivanm> forgot bytestring, etc.... for _real_ efficiency, rename your files!
18:15:55 <dolio> Yes, and use smaller fonts.
18:15:56 <ivanm> *forget
18:16:01 <ivanm> lol
18:16:18 <ivanm> I didn't know ghc took your favourite editors font size into account when creating assembler...
18:16:46 <dolio> Who knows? I haven't run any benchmarks.
18:17:19 <porges> can anyone see any obvious problems with this? :P http://hpaste.org/13111
18:17:22 <ivanm> good thing I haven't bothered to set the editor I use in ghci then...
18:17:35 <ivanm> if it uses a non-existent editor, maybe that makes it more efficient! ;)
18:17:42 <pastorn> lucca: reading that sieve document now... after some coffee this is getting quite interesting :)
18:17:46 <pastorn> lucca: thanks
18:17:51 <SamB> dolio: smaller fonts!
18:17:58 <SamB> lol
18:18:00 <dolio> if $EDITOR == "ed" then #use the good code generator ...
18:18:09 <ivanm> lol
18:18:26 <Olathe> If you use monospace fonts, it forces ghc to use nops to get the instructions to align.
18:18:47 <ivanm> @remember dolio [after joking that editor choice affects runtime performance] if $EDITOR == "ed" then #use the good code generator ...
18:18:47 <SamB> lol
18:18:48 <lambdabot> Okay.
18:19:06 <Olathe> Heheh
18:20:19 <ivanm> I suppose we can use this new-found optimisation technique to determine which side in the editor wars SPJ supports...
18:20:46 <ddarius> edit.com all the way
18:20:50 <Saizan> they should introduce this feature in the JVM
18:20:58 <SamB> ivanm: I thought he used powerpoint
18:21:18 <ivanm> SamB: :o
18:21:50 <jeffz`> he uses emacs in an xmonad video I think
18:22:12 <SamB> yes, and he's also unable to use powerpoint on-the-fly
18:27:25 <jeffwheeler> Are the Exception sections in Chapter 9 of RWH using old exception stuff from 6.8.3?
18:28:11 <dolio> Most likely.
18:29:46 <ivanm> yeah, I was just thinking that this morning... I've just got this new book, and already a chapter is out of date :(
18:29:55 <newsham> send it back!
18:29:56 <newsham> ;-)
18:30:01 <ivanm> heh
18:30:22 <ivanm> HEY DONS, I CAN HAZ MY MONEY BACK PLZ? KTHX BYE
18:30:22 <ivanm> ;)
18:31:09 <SamB> ivanm: maybe he'll just take you off the thanks list
18:31:33 <ivanm> SamB: which one of me? :p
18:31:44 <SamB> both of you ?
18:31:50 <ivanm> awwwww :(
18:33:29 <newsham> hmm.. all of these haskell reddit stories are submitted by dons
18:34:24 <jeffwheeler> newsham: he gets around.
18:34:34 <ivanm> newsham: yeah, it's his own personal haskell-related online bookmark list ;)
18:35:33 <dons> ivanm: explicitly using old exceptions.
18:35:37 <dons> base < 4, thanks.
18:35:45 <dons> newsham: please submit things.
18:35:56 <dons> i wish other people would submit stuff...
18:36:06 <mpeter> i bought a copy of real world haskell
18:36:14 <mpeter> TO BURN
18:36:14 <newsham> dons: this is the first time i've used reddit in 6-9mos
18:36:15 <newsham> i dont think you want me to be submitting things
18:36:17 <mpeter> AFTER USING AS TOILET PAPER ;)
18:36:32 <newsham> i dont even have an account
18:36:34 <saml> > sortBy compare [100000000, 99999999 .. 0]
18:36:39 <ivanm> dons: for me to submit stuff, that would require me to actually get a reddit login... I waste enough time _reading_ reddit as opposed to submitting, commenting, etc. ;)
18:36:42 <dons> newsham: ok. so you just get to read.
18:36:57 <ivanm> @slap mpeter
18:36:58 <lambdabot> why on earth would I slap mpeter?
18:37:09 <newsham> reddit's not really my thing, but i like ot peek occasionally to see whats been going on
18:37:12 <ivanm> *sigh* why won't lambdabot ever back me up? :p
18:37:21 <mpeter> > endresult joke
18:37:22 <lambdabot>   "hahahahahahaha!!!!"
18:37:33 <jeffwheeler> > endresult
18:37:34 <lambdabot>       Overlapping instances for Show ([Int] -> [Char])
18:37:34 <lambdabot>        arising from a ...
18:37:35 <ivanm> reddit is a great way to procrastinate by pretending to actually be reading relavent material
18:37:42 <saml> > endresult 42
18:37:43 <lambdabot>       No instance for (Num [Int])
18:37:43 <lambdabot>        arising from the literal `42' at <in...
18:37:46 <ivanm> who the hell added that stuff to lambdabot?
18:37:48 <dons> yes, it is all relevant to your interests.
18:37:53 <mpeter> ivanm: dons
18:38:00 <dons> except saml's stuff, which is  just weird.
18:38:28 <ivanm> why, what did saml add?
18:38:53 <saml> i'm a noob i don't add stuff. but i say haskell is so awesome!
18:39:02 <mpeter> > endresult [42]
18:39:04 <lambdabot>   "*"
18:39:12 <mpeter> a star <3
18:39:39 <Olathe> > joke
18:39:41 <lambdabot>   [104,97,104,97,104,97,104,97,104,97,104,97,104,97,33,33,33,33]
18:39:53 <SamB> > map chr joke
18:39:54 <lambdabot>   "hahahahahahaha!!!!"
18:39:58 <saml> @src endresult
18:39:58 <lambdabot> Source not found. Sorry.
18:40:00 <SamB> that's not a joke
18:40:02 <ivanm> dolio: I wonder if someone added that module bug as a way to instantly give their app a speed boost when they feel like procrastinating but want to show their boss that they did some work... >_>
18:40:11 <mpeter> maybe not from your culture
18:40:11 <saml> i think endresjust converts ASCII int to char
18:40:11 <jeffwheeler> > map endresult joke
18:40:12 <lambdabot>   Couldn't match expected type `[Int]' against inferred type `Int'
18:40:15 <dolio> Heh.
18:40:33 <Olathe> Well, if we're judging how jokelike it is, I'd say its jokelikeness is a joke.
18:40:33 <jeffwheeler> > map (endresult.(:[])) joke
18:40:33 <lambdabot>   ["h","a","h","a","h","a","h","a","h","a","h","a","h","a","!","!","!","!"]
18:40:46 <SamB> > endresult joke
18:40:47 <lambdabot>   "hahahahahahaha!!!!"
18:40:55 <SamB> oh, we did that already
18:40:58 <mokus> > map chr joke
18:40:59 <lambdabot>   "hahahahahahaha!!!!"
18:41:04 <jeffwheeler> Oh, it does.
18:41:06 <jeffwheeler> Heh.
18:41:12 <saml> what's inverse of chr?
18:41:15 <jeffwheeler> ord
18:41:16 <mokus> ord
18:41:16 <mpeter> ord
18:41:19 <jeffwheeler> I win!
18:41:20 <Olathe> ord !
18:41:22 * mpeter kills mokus and jeffwheeler
18:41:25 <saml> > map ord endresult == joke
18:41:26 <lambdabot>   Couldn't match expected type `[Char]'
18:41:47 <mpeter> saml: ?
18:41:48 <saml> @quicktest endresult joke
18:41:48 <lambdabot> Unknown command, try @list
18:41:55 <mpeter> @src endresult
18:41:55 <lambdabot> Source not found. Maybe you made a typo?
18:41:56 <Olathe> > (map ord.endresult) joke == joke
18:41:57 <lambdabot>   Not in scope: `endresult'Not in scope: `joke'Not in scope: `joke'
18:42:01 <Olathe> :(
18:42:18 <ivanm> lol
18:42:21 <mpeter> @undefine
18:42:25 <mpeter> @let endresult xs = map chr xs
18:42:26 <lambdabot>  Defined.
18:42:34 <mpeter> @let joke = map ord "hahahahahahaha!!!!"
18:42:35 <lambdabot>  Defined.
18:42:37 <mpeter> > endresult joke
18:42:39 <lambdabot>   "hahahahahahaha!!!!"
18:42:43 <mpeter> real simple
18:44:42 <mokus> @let mokusSays = [73,32,119,97,110,116,32,49,44,48,48,48,32,112,97,110,99,97,107,101,115]
18:44:43 <lambdabot>  Defined.
18:44:53 <mpeter> > endresult mokusSays
18:44:55 <lambdabot>   Not in scope: `endresult'
18:45:01 <mpeter> :/
18:45:05 <mokus> heh, I guesss someone @undefined
18:45:07 <mpeter> > map chr mokusSays
18:45:09 <lambdabot>   "I want 1,000 pancakes"
18:45:17 <mpeter> <3
18:45:21 <dons> keep the logo ideas coming, http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
18:45:24 <dons> there's lots of good stuff there.
18:45:33 <dons> we'll vote to pick the winner after enough are submitted
18:45:39 <mpeter> dons: i'm a visual art major ;)
18:45:47 <dons> go go go!!
18:45:55 <saml> i like the first one the best
18:45:55 <ivanm> dons: with "enough" meaning "dons has found a logo he likes"? ;)
18:45:58 <mpeter> also
18:46:01 <mpeter> http://relapse-software.net/haskell_5.png <--that one is amazing
18:46:12 <mpeter> please pick that
18:46:20 <dons> ivanm: no, it kindaa turned into a contest afterwards. but everyone should contribute
18:46:23 * ivanm likes this one: http://haskell.org/haskellwiki_logo_small.png
18:46:32 <dons> you can vote for the old one too
18:46:32 <saml> but why do they have lambda greek letter?
18:46:38 <dons> saml, see.
18:46:40 <dons> like that.
18:46:44 <ivanm> saml: functional language?
18:46:46 * mpeter opens illustrator
18:47:05 <ivanm> and there's a dearth of lambda english letters... ;)
18:47:13 <saml> is this mandatory for a logo to have lambda?
18:47:16 <porges> we should make sure that the end result is completely free to use anywhere
18:47:19 <newsham> > foldl (\a b -> a*10+b) mokusSays
18:47:20 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
18:47:20 <lambdabot>        arising from a use...
18:47:26 <mpeter> oo, my copy of illustrator is registered to Roman Polanski
18:47:28 <newsham> > foldl (\a b -> a*10+b) 0 mokusSays
18:47:29 <lambdabot>   7749919739332429098825
18:47:32 <porges> e.g. font face is ok to use and so on
18:47:33 <ivanm> porges: a creative commons license?
18:47:35 <mpeter> i don't remember being roman polanski but
18:47:36 <newsham> > foldl (\a b -> a*128+b) 0 mokusSays
18:47:37 <lambdabot>   102105787555865139405749429340733810646119155
18:47:39 <mpeter> i'll roll with it
18:47:42 <ivanm> mpeter: so you're a pirate?
18:47:56 <mpeter> we're all pirates
18:48:02 <Olathe> I'm not a pirate.
18:48:05 * ivanm begs to differ
18:48:10 <mpeter> if you've ever learned something at a university
18:48:12 <mpeter> and then told it to somebody else
18:48:15 <mpeter> you're a pirate
18:48:17 <ivanm> there might be someone somewhere who _isn't_ a pirate
18:48:26 <ivanm> mpeter: no, because what you're taught isn't copyrighted
18:48:32 <mpeter> oh, ok
18:48:37 <mpeter> so the US copyright system is infallible
18:48:45 * Olathe snores.
18:48:54 * mpeter pours molten gold down Olathe's nose
18:48:54 <ivanm> Olathe: heh
18:49:02 <ivanm> @slap mpeter
18:49:03 * lambdabot activates her slap-o-matic...
18:49:03 <ikkebr> <mpeter> http://relapse-software.net/haskell_5.png <--that one is amazing
18:49:06 <ikkebr> clearly
18:49:10 <ikkebr> that one originates from half-life
18:49:24 <jeffwheeler> lambdabot is a she?
18:49:37 <Olathe> Yes.
18:49:41 <mwotton> @vixen: a/s/l?
18:49:41 <lambdabot> 19/f/California
18:49:44 <mwotton> see?
18:50:12 <jeffwheeler> I never knew!
18:50:21 <ivanm> @where lambdabot
18:50:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:50:35 <mpeter> @fact haskell
18:50:35 <lambdabot> haskell: is the ninja of programming languages
18:50:39 <mpeter> @fact life
18:50:40 <mwotton> dude, that is hell of sexist
18:50:40 <lambdabot> I know nothing about life
18:50:56 * mwotton hastily applies emoticons
18:51:08 <mpeter> @fact dons
18:51:09 <lambdabot> dons: is my favorite owner LOLOLOLOLOL
18:51:31 <jeffwheeler> @fact jeffwheeler
18:51:31 <lambdabot> I know nothing about jeffwheeler
18:51:34 <jeffwheeler> :(
18:51:42 <jeffwheeler> Life and I are too similar.
18:51:54 <jeffwheeler> @eliza a/s/l
18:51:55 <lambdabot> 4/s/L
18:52:39 <mpeter> @fact mpeter
18:52:40 <lambdabot> mpeter: mpeter is the sexiest of everybody in #haskell
18:52:49 <mpeter> oh yeah, i knew it
18:53:17 <ivanm> *sigh*
18:55:29 <gwern> @fact god
18:55:30 <lambdabot> god: gave ninjas dominion over everything totally sweet
18:55:44 <Olathe> Oh dear
18:56:06 <gwern> @fact ninjas
18:56:07 <lambdabot> ninjas: flip out for no reason are totally sweet are mammals
18:56:12 <mokus> none of the logo ideas have photos of Haskell Curry
18:56:27 <newsham> ?eliza how are you?
18:56:27 <lambdabot> |-|0\/\/ aRE Y0U?
18:56:33 * mokus recuses himself from the vote (not that his vote counts anyway ;-) )
18:56:38 <Olathe> I like the t-shirt one.
18:56:45 <newsham> ?eliza three leet you are indeed
18:56:46 <lambdabot> +|-|ree lee+ u ArE InDeeD
18:57:56 <mokus> @@ @elite @ghc
18:57:56 <lambdabot>  ghc SAYs: phUNc7ioNaL dep3ndeN(I3S C0NF|ict 8E7w3eN iN$7anCE deC|arAtIOnz
18:58:00 <gwern> @fact-delete ninjas
18:58:01 <lambdabot> Fact deleted.
18:58:05 <gwern> @fact ninjas
18:58:06 <lambdabot> I know nothing about ninjas
18:58:15 <newsham> ?fact ?fact
18:58:15 <lambdabot> I know nothing about ?fact
18:58:18 <gwern> @fact-set ninjas flip out for no reason
18:58:18 <lambdabot> Fact recorded.
18:58:22 <Olathe> @ghc
18:58:23 <lambdabot> ghc says: Too many parameters for class
18:58:30 <gwern> @fact-set ninjas ; are totally sweet
18:58:31 <lambdabot> Fact already exists, not updating
18:58:38 <gwern> @fact-cons ninjas ; are totally sweet
18:58:39 <lambdabot> Fact altered.
18:58:47 <gwern> @fact-cons ninjas ; are mammals
18:58:48 <lambdabot> Fact altered.
18:58:50 <gwern> @fact ninjas
18:58:51 <lambdabot> ninjas: ; are mammals ; are totally sweet flip out for no reason
18:58:57 <gwern> dammit
18:59:08 <gwern> @fact-delete ninjas
18:59:08 <lambdabot> Fact deleted.
18:59:17 <dolio> Not snoc! Yow!
18:59:17 <ikkebr> @fact-cons ninjas are invisible
18:59:17 <lambdabot> A fact must exist to alter it
18:59:24 <newsham> gwern: http://www.codingthewheel.com/image.axd?picture=ninja2.jpg ?
18:59:26 <ikkebr> @fact-set ninjas are invisible
18:59:27 <lambdabot> Fact recorded.
18:59:32 <ikkebr> @fact ninjas
18:59:33 <lambdabot> ninjas: are invisible
18:59:39 <gwern> @fact-set ninjas are 1) totally sweet 2) mammals 3) invisible and 4) flip out for no reason
18:59:39 <lambdabot> Fact already exists, not updating
18:59:43 <gwern> oh right
18:59:44 <gwern> @fact-delete ninjas
18:59:45 <lambdabot> Fact deleted.
18:59:46 <gwern> @fact-set ninjas are 1) totally sweet 2) mammals 3) invisible and 4) flip out for no reason
18:59:47 <lambdabot> Fact recorded.
18:59:47 <Olathe> @fact-set fact A fact must exist to alter it.
18:59:47 <lambdabot> Fact recorded.
18:59:50 <gwern> @fact ninjas
18:59:51 <lambdabot> ninjas: are 1) totally sweet 2) mammals 3) invisible and 4) flip out for no reason
19:00:05 <Olathe> @fact fact
19:00:06 <lambdabot> fact: A fact must exist to alter it.
19:00:19 <porges> it sucks when you send an email then suddenly realize everything is wrong :|
19:00:20 <gwern> newsham: that's not a ninja. you can see her, for starters
19:00:22 <ikkebr> newsham there are 20 in that picture
19:01:16 <newsham> gwern: but do you truely see her?
19:01:24 <ddarius> newsham: High heels?! Lord!  But anyway, this is better off not-in-#haskell.
19:01:37 <gwern> newsham: I don't not see her
19:02:14 <newsham> > show ninjas
19:02:15 <lambdabot>   Not in scope: `ninjas'
19:02:17 <Olathe> It could be an optical illusion.
19:03:19 <mpeter> phew
19:03:22 <mpeter> i finished my haskell logo
19:03:49 <saml> me too. just now
19:04:09 <mpeter> http://i35.tinypic.com/15ceonk.png
19:04:14 <mpeter> obviously a little inspired from that other one
19:04:23 <erikc> mpeter: awesome
19:04:40 <saml> http://i37.tinypic.com/20q19mq.png  without lambda
19:04:42 <erikc> that gets my vote
19:04:54 <mpeter> <3
19:05:18 <chessguy> those both look too chaotic to me
19:05:36 <mpeter> yup
19:05:37 <newsham> not lazy enough
19:05:41 <newsham> less letters please
19:06:07 <mpeter> the laziness in mine is symbolized by the twice-pasted lambda mask
19:06:13 <mpeter> and the leaf symbolizes the userbase ;)
19:06:20 <mpeter> to receive the sunlight of knowledge
19:06:28 <mpeter> oh baby
19:06:42 * mpeter dies from a heroin overdose
19:07:32 <gwern> perhaps we could use a haskell logo where the H is sharp and well-defined, and it fades out to the final L
19:07:32 <porges> http://i35.tinypic.com/15ceonk.png
19:07:36 <gwern> since no one has looked at it yet
19:07:37 <porges> this is your brain... ON HASKELL
19:07:40 <newsham> some sort of fractal pattern that is not fully rendered and is pruned into a bunch of unevaluated thunks...
19:07:52 <mpeter> exactly, porges
19:08:18 * ivanm thinks it needs more maths
19:09:13 <gwern> but math is not warm and cuddly
19:09:20 <gwern> we need a logo which doesn't scare people away
19:09:25 <ivanm> neither are monads ;)
19:09:35 <mpeter> how do you draw a monad
19:09:38 <Olathe> That's why I like the second t-shirt one.
19:09:45 <gwern> ivanm: monads or - WARM FUZZY THINGS???
19:09:47 <dons> >>= , mpeter
19:09:51 <ivanm> @src monad
19:09:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:09:54 <porges> it's a crocodile
19:09:57 <ivanm> grrr....
19:09:58 <newsham> how about something like this?  http://images.artnet.com/artwork_images_423841944_184420_mc-escher.jpg
19:10:09 <mpeter> now that reminds me of haskell
19:10:28 <ivanm> newsham: no lambdas...
19:10:32 <mpeter> how about a big pot of curry
19:10:44 <gwern> 'My best student in this scenario was writing very advanced Haskell after a week full-time (40 hours). To give you a hint, by "very advanced" I mean something like: he was writing his own Applicative instance for a data type he had written that basically newtyped the (->) constructor (if you don't know what that means, never mind).'
19:10:49 <gwern> man
19:10:54 <gwern> http://www.reddit.com/r/programming/comments/7jpo7/i_am_looking_into_learning_a_new_language_for_fun/c06uf9l
19:11:36 <ivanm> gwern: did you see the link to the 10 steps on learning a new language?
19:11:41 <mpeter> that professor's got the hang of it
19:11:43 <gwern> no
19:11:57 <ivanm> the author says to prove you know a language, you should write a database app
19:12:03 <ddarius> Step 1: Learn a new language. Step 2: Done.
19:12:05 <mpeter> you can't write 'advanced' haskell though, nor any programming language
19:12:05 <ivanm> why are so many people obsessed with database apps?
19:12:08 <ivanm> ddarius: lol
19:12:10 <mpeter> just concise or effective haskell ;)
19:12:31 <gwern> ddarius: that's so lame
19:12:48 <mpeter> database interface or just something that uses a database
19:12:54 <ddarius> gwern: Fine. Step 3: Repeat.
19:12:54 <newsham> ivanm: some people learn a new language by writing a ray tracer, some learn it by writing a db
19:13:12 <ivanm> mpeter: a blog engine or something he says
19:13:13 <mpeter> i'm learning haskell by writing god
19:13:18 <mpeter> ivanm: that's so easy
19:13:23 <ivanm> newsham: heh, fair enough
19:13:27 <newsham> i learn haskell by reading keal
19:13:28 * ivanm tries to avoid dbs
19:13:40 <Axman6> would you guys say it's easier to come from a functional language like haskell to a imperative language like C? (as opposed to the other way around)
19:13:53 <ivanm> then again, I learnt haskell by converting a sudoku solver into a latin square solver + generator...
19:13:59 <mpeter> axman: yes
19:14:00 <ivanm> Axman6: probably
19:14:04 <gwern> ddarius: no, adding a step 3 makes it even lamer since now you don't have the 10=2 binary joke builtin
19:14:09 <ivanm> Axman6: I got RWH yesterday! \o/
19:14:13 <ivanm> any idea when you're getting yours?
19:14:22 <ivanm> seeing as how you ordered before me and all...
19:14:23 <newsham> axman: i think it would be very frustrating at times.
19:14:23 <gwern> Axman6: definitely
19:14:32 <Axman6> i think i just got the email saying it has shipped...
19:14:40 <ivanm> ahhhh
19:14:50 <ivanm> seeing? complaining gets you your copy faster! :p
19:14:51 <Axman6> so, fu ivanm *glares*
19:14:58 <ivanm> :D
19:15:16 <jimmyjazz> Does anyone use haskell professionally, just wondering how common it is the the professional world
19:15:51 <ivanm> jimmyjazz: check out the list of companies on haskell.org
19:16:23 <chessguy> jimmyjazz:  not very common at all
19:16:43 <mpeter> define 'professionally'
19:17:15 <Axman6> from what i've learnt about haskell, i'd say it's help me write better imperative code. just reading dons' blog helps a lot there
19:17:15 <Axman6> jimmyjazz: galois write entire systems in haskell from what i hear
19:17:15 <Axman6> my god i hate my ISP!
19:17:15 <ivanm> chessguy: well, we can probably say that there's a lot of people who would _like_ to be using Haskell rather than C/C++/Java/etc. in their jobs...
19:17:16 <Axman6> 66 seconds lag... and rising
19:17:19 <jimmyjazz> well how often do you see job listings for haskell work, that is
19:17:34 <Axman6> rarely
19:17:40 <ivanm> jimmyjazz: there's a job listing every now and then on the mailing list...
19:17:54 <chessguy> ivanm:  "a lot"? even relatively?
19:18:12 <ivanm> chessguy: most people here who have to use another language at work? ;)
19:18:26 * ivanm is currently using Java on a project, and would prefer not to
19:18:50 <chessguy> ivanm:  yes, i'm aware of that. i wouldn't consider that "a lot" compared to the number of developers who have never heard of haskell :)
19:19:05 <Axman6> "TransACT has since confirmed that a fault had occurred on their network at around 10.30am however whilst we were diagnosing the fault, we caused an error on our own network that interrupted services to all customers." -- frigging love my ISP
19:19:06 <ivanm> chessguy: true
19:19:17 <ivanm> Axman6: heh
19:19:19 <jimmyjazz> I of course will not stop using haskell even if it is not currently considered marketable yet , I was just wondering
19:19:37 <mpeter> java sucks
19:19:56 <chessguy> Axman6:  nice :)
19:20:00 <mpeter> all programming is functional in form
19:20:10 <mpeter> or approaching it..
19:20:13 <jeffwheeler> mpeter: Java is still taught for the AP exam in high-schools and for most computer science contests at that level.
19:20:25 <mpeter> jeff: thank god i'm done with high school
19:20:29 <ivanm> jeffwheeler: AP == ?
19:20:43 <Gracenotes> jeffwheeler: it replaced C++, at least
19:20:45 <ddarius> jeffwheeler: It wasn't when I went through, though they were switching over next year.
19:20:54 * ddarius likes C++.
19:21:01 <jeffwheeler> ivanm: it's a type of test that usually gives college credit for high-school classes.
19:21:01 <ivanm> not all of us here are yanks ;)
19:21:07 * chessguy likes c# somewhat
19:21:09 <ivanm> ahhhh
19:21:10 <mpeter> now, i know this is the wrong place to ask, but are there any languages that are nearly a step ahead of haskell?
19:21:17 <mpeter> out of curiosity
19:21:18 <ddarius> C# is actually pretty nice, relatively speaking.
19:21:22 <ivanm> mpeter: prolog ;)
19:21:24 <Gracenotes> I have a small phobia for C++, which I'm sure I'll get around to fixing when I take it next semester
19:21:27 <jeffwheeler> I've heard good things about C# too.
19:21:34 <Axman6> oh wtf! fishpond have emailed me saying they can't get RWH just yet!
19:21:34 <Axman6> i don't really have a problem with Java. it's possible to be very productive with it
19:21:36 <mpeter> every benchmark i've seen for C# is depressing
19:21:37 <jimmyjazz> C++ is nice
19:21:44 <ddarius> ivanm: Prolog is horrid.  There are some nice language "beyond" it though.
19:21:46 <jeffwheeler> Apparently it's (C#) like Java, without the suck.
19:21:52 <ivanm> mpeter: erlang if you need to do distributed stuff maybe
19:21:56 <ddarius> jeffwheeler: Indeed.
19:22:08 <chessguy> jeffwheeler:  it takes the best of c++ and java, and adds some coolness to it
19:22:11 <ddarius> Gracenotes: Screw class, just write something in it.
19:22:11 <mpeter> do they have a plan9 erlang compiler yet ;)
19:22:14 <ivanm> Axman6: feel free to use my name to complain, saying that if I've got mine why haven't you got yours
19:22:18 <Gracenotes> C# is Java with a 'best of' features from at least half a dozen other programming languages
19:22:23 <ivanm> not that I'm going to give you my copy or anything :p
19:22:35 <Gracenotes> a lot of paradigms can fit into one C# program
19:22:42 <jeffwheeler> Same goes for Python.
19:22:44 <chessguy> Gracenotes:  half a dozen?
19:23:07 <jimmyjazz> Python is all I ever really end up using most the time
19:23:11 <mpeter> the problem with the word 'paradigm' is that it has no meaning whatsoever
19:23:18 <Gracenotes> chessguy: okay, I just made that up. But it has a lot: namespaces, passing by value/reference, closures, etc.
19:23:21 <jimmyjazz> everything seems to keep leading me back to python
19:23:26 <ivanm> mpeter: sure it does, the dictionary has a meaning for it!
19:23:26 <jeffwheeler> Off topic, but what is this logo supposed to represent: http://haskell.org/haskellwiki/Image:Haskell_halfhalfinfinitylambda.png
19:23:39 <Gracenotes> and much more.
19:23:51 <mpeter> jeffwheeler: a pregnant woman?
19:23:56 <ivanm> jeffwheeler: from the name, infinity + lambda
19:24:06 <chessguy> looks like a lambda with a nasty mutated growth
19:24:09 <jeffwheeler> ivanm: but the other one made _so_ much more sense
19:24:09 <jimmyjazz> a pregnant lambda
19:24:11 <Gracenotes> it's a very pregnant logo
19:24:13 <mpeter> i guess pregnancy sort of represents recursion
19:24:24 <jeffwheeler> http://haskell.org/haskellwiki/Image:Haskell_3qhalfinfinitylambda.png, too
19:24:32 <Gracenotes> mpeter: for only children, tail recursion
19:24:33 <mpeter> so why don't you guys make the haskell logo
19:24:36 <mpeter> a woman giving birth
19:24:40 <jimmyjazz> mpeter I never thought of it that way
19:24:43 <mpeter> a photo of it
19:24:44 <ivanm> jeffwheeler: that link fails for me
19:24:49 <jeffwheeler> http://haskell.org/haskellwiki/Image:Haskell_3qhalfinfinitylambda.png
19:24:53 <jimmyjazz> wow now I do, creepy thought
19:24:55 <mpeter> you can put it on the cover of RWH and everything
19:24:57 <ivanm> oh, wait, my IRC client put a comma on the end
19:24:59 <jeffwheeler> ivanm: the punctuation probably through it off
19:25:19 <Gracenotes> Hercules beetle ain't functional enough? ;)
19:25:27 <gwern> I don't get that infinity lambda
19:25:38 <ivanm> hercules beetle represents _strong_ static typing! ;)
19:25:41 <gwern> where's the infinity?
19:25:43 <jeffwheeler> Using lambda calculus for all applications, to infinity?
19:25:47 <mpeter> now if you're sending a pixmap directly to X, can it be that much more trouble to make your app run outside of X?
19:26:09 <jeffwheeler> gwern: http://haskell.org/haskellwiki/Image:Haskell_infinitylambda.png
19:26:15 <jimmyjazz> will learning Haskell help me learn Scheme in the future?
19:26:28 <mpeter> jimmyjazz: learning lisp will help more
19:26:35 <gwern> hm... looks a little awkward in that version
19:26:54 <Axman6> ivanm: man, this is a load of shit. can't believe they shipped your book before mine (since i ordered first), and now they say they won't have the book until the 30th
19:26:55 <jimmyjazz> lisp seems less interesting
19:26:58 <mpeter> but all three are functional
19:27:05 <ivanm> Axman6: :o
19:27:07 <mpeter> and haskell is a bit less stupid than lisp
19:27:14 <jeffwheeler> Just a bit?
19:27:21 <Gracenotes> in the full infinity version, it would look better if the semi-circle on the right were attached from the top, rather than from the bottom
19:27:24 <mpeter> a smidgeon
19:27:32 <ivanm> Axman6: that is _really_ weird :s
19:27:33 <Gracenotes> ...or maybe it wouldn't.
19:27:34 <inforichland> that's a matter of opinion ;)
19:27:39 <jimmyjazz> most lisp books I have picked up thought where fairly dry
19:27:39 <mpeter> where did Cale go?
19:27:49 <ivanm> @seen Cale
19:27:49 <Axman6> yes indeed. especially since you got a discount from my recommendation right?
19:27:50 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 3h 2m 43s ago.
19:27:55 <ivanm> preflex: seen Cale
19:27:55 <preflex>  Cale was last seen on #haskell 3 hours, 2 minutes and 49 seconds ago, saying: Gracenotes: So relabelTree' turns the tree into a computation which when run with an initial state will produce the relabelled tree.
19:28:03 <Cale> hey
19:28:09 <Gracenotes> fun times.
19:28:13 <ivanm> heh
19:28:21 <Cale> mpeter: So, you wanted an explanation of >>= ?
19:28:23 * Axman6 fires off angry letter to fishpond
19:28:26 * ivanm thinks lambdabot needs preflex's ability to remember last line said
19:28:50 <mpeter> whoa
19:28:55 <mpeter> yeah, go ahead ;)
19:28:56 <Cale> mpeter: I should get a handle on what stuff from Haskell you're already familiar with.
19:29:05 <Cale> Have you done any IO stuff yet?
19:29:13 <mpeter> past putStrLn, no
19:29:28 <mpeter> a little opengl tinkering
19:29:31 <mpeter> that's all
19:29:38 <Cale> okay
19:30:04 <Cale> Types and type constructors?
19:30:08 <mpeter> yeah, got all that
19:30:11 <Cale> okay
19:30:21 * jeffwheeler is listening intently to the lesson.
19:30:33 <lament> i got RWH today!
19:30:44 <porges> maybe we should just go for ÎÎÎ£ÎÎÎÎ
19:30:56 <jeffwheeler> Hell, why not just start our own frat?
19:31:09 <Cale> So there are a lot of libraries in Haskell which make use of this overarching pattern that computations of a specific type are represented using values.
19:31:30 <mpeter> yes
19:31:36 <porges> ÎÎ±ÏÎºÎµÎ»Î»
19:31:55 <Cale> For example, in a parser library, a parser for parsing an abstract syntax tree might have a type like  Parser AST
19:32:16 <Cale> Or in the IO monad, we have things like  getLine :: IO String
19:32:28 <Cale> which is an action which when carried out will produce a String
19:33:19 * mpeter nods
19:33:56 * Axman6 still finds this definition of a monad slightly confusing
19:34:08 <Cale> Okay, so a monad is a type constructor M, together with some operations which are a common interface that can be relied on.
19:34:18 <Olathe> I like the what-could-be-simpler definition.
19:34:40 <Cale> Many libraries look like this, and so operations can be written which work in any monad, and hence with all those libraries.
19:34:52 <Cale> Let's take a closer look at what's involved
19:35:03 <mpeter> @src Bool
19:35:03 <Cale> We have:  return :: a -> M a
19:35:04 <lambdabot> data Bool = False | True deriving (Eq, Ord)
19:35:18 * jeffwheeler bets this is scripted, and he's just copying/pasting. :P
19:35:21 <ivanm> Olathe: you mean "What could be simpler than defining a new cateogry-theory based method of abstracting out all that nasty IO-stuff from the rest of our code, generalising it so that other constructs can use the same technique but then _still_ making IO a special case" ? ;)
19:35:31 <ivanm> jeffwheeler: shhhh!
19:35:39 <Cale> return v is intended to give us the computation which "does nothing" and produces the result v every time
19:35:51 <ivanm> he's actually running a lambdabot instance that's doing it all!
19:35:53 <mpeter> you mean produces no chaneg in state?
19:35:54 <Cale> hm?
19:35:59 <Cale> I'm just talking :)
19:36:07 <Cale> mpeter: If the monad in question has a notion of state.
19:36:19 <Cale> mpeter: Then it will remain unchanged by return.
19:36:31 <mpeter> ???
19:36:35 <Cale> What exactly it means to "do nothing and return v" will vary slightly based on the monad.
19:36:44 <ddarius> Cale: You -should- have this scripted by now.
19:36:58 <Cale> In the case of the list monad, for instance,  return v = [v]
19:37:08 <mpeter> can i see an example
19:37:12 <mpeter> of its usage
19:37:28 <Cale> Of the list monad?
19:37:33 <Olathe> Most functions do something without changing state.
19:37:35 <mpeter> of monads in eneral
19:37:42 <Cale> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) }
19:37:43 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
19:37:57 <jeffwheeler> > return 1 :: [Int]
19:37:58 <lambdabot>   [1]
19:38:01 <mpeter> oO
19:38:10 <mpeter> that's handy
19:38:15 <Cale> This is something written in the list monad, it says to choose x from the list [1,2,3], and then choose y from the list [4,5]
19:38:18 <Cale> and return (x,y)
19:38:20 <Olathe> > return 1 :: Maybe Int
19:38:22 <lambdabot>   Just 1
19:38:26 <Cale> This is done in all possible ways
19:38:34 <Cale> (that's just how the list monad works)
19:38:55 <mpeter> well i mean
19:39:08 <mpeter> besides the foreach x { foreach y { return (x,y) }}
19:39:13 <mpeter> where does the monad come in
19:39:22 <Cale> okay
19:39:42 <solrize> > return 3 :: Maybe Float
19:39:43 <lambdabot>   Just 3.0
19:39:44 <Cale> So this desugars into  [1,2,3] >>= (\x -> [4,5] >>= (\y -> return (x,y)))
19:39:46 <Taejo> > liftM2 (,) [1, 2, 3] [4,5]
19:39:47 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
19:40:13 <Cale> This >>= is the other component of what it means for something to be a monad.
19:40:16 <pumpkin> @undo  liftM2 (,) [1, 2, 3] [4,5]
19:40:17 <lambdabot> liftM2 (,) [1, 2, 3] [4, 5]
19:40:20 <pumpkin> boo
19:40:21 <porges> ÙØ³Ú©Ù
19:40:55 <Cale> But before I explain >>= generally, let's look at >> which is a simplified version of it
19:40:56 <jeffwheeler> > [1,2,3] >>= (\x -> [4,5] >>= (\y -> return (x,y)))
19:40:57 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
19:41:05 <Taejo> pumpkin: do you prefer liftM2 (\x y -> (x, y)) [1, 2, 3] [4,5]
19:41:15 <Cale> If x :: M a and y :: M b are actions in my given monad
19:41:26 <pumpkin> I was just hoping it would desugar the do statement that liftM2 was defined as
19:41:34 <pumpkin> @src liftM2
19:41:34 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:41:47 <Cale> then x >> y :: M b is intended to be the action which first "runs x", and then "runs y", and whose result is the result of y.
19:41:53 <porges> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:41:54 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
19:42:01 <Cale> What it will mean to 'run x' will be different in different monads.
19:42:32 * Axman6 thinks people should leave Cale to produce the examples...
19:42:35 <jeffwheeler> What does it mean in the list monad?
19:42:53 <Cale> In the list monad, "running" a list means selecting one of its elements in all possible ways.
19:43:15 <mpeter> iterating through the list
19:43:17 <Cale> yes
19:43:40 <Axman6> mpeter: don't forget to ask questions if you're confused, or you'll get lost (i know i did when Cale gave me a hand learning monads) [Thanks again Cale!]
19:43:41 <Cale> In the IO monad, running an IO action means actually carrying out the input and output associated with it.
19:44:02 <mpeter> and this is to stdin and stdout by default?
19:44:18 <jeffwheeler> Wait, can you give a stupidly simple example of just something like [1, 2, 3] >> ?
19:44:20 <mpeter> what's the simplest illustrative usage of the IO monad
19:44:23 <Cale> In a parsing monad, running a parser means to allow that parser to try to eat the initial part of the current string which is being parsed and produce a value depending on it.
19:44:29 <Cale> sure
19:44:48 <porges> > [1,2,3] >> [4,5,6]
19:44:49 <Olathe> > "zomg" >> (\x -> "A")
19:44:50 <lambdabot>   [4,5,6,4,5,6,4,5,6]
19:44:50 <lambdabot>       The lambda expression `\ x -> "A"' has one argument,
19:44:50 <lambdabot>      but its type ...
19:44:52 <Cale> mpeter: How about:  do { x <- getLine; putStrLn x }
19:44:54 <Axman6> mpeter: depends on the IO action. things like writeFile ... well write to a file :)
19:45:08 <Cale> Which desugars as:  getLine >>= (\x -> putStrLn x)
19:45:12 <jeffwheeler> porges: makes sense.
19:45:20 <Olathe> Ahh.
19:45:23 <Olathe> > "zomg" >> "A"
19:45:24 <Cale> This is the action which gets a line of text from the user, and then prints it back out.
19:45:25 <jeffwheeler> It's ignoring the first input, because >> just takes the result of the second.
19:45:25 <lambdabot>   "AAAA"
19:45:42 <Cale> In the list monad, >> is just a little bit silly.
19:45:53 <mpeter> > replicate 4 "A"
19:45:55 <lambdabot>   ["A","A","A","A"]
19:46:09 <porges> > replicate 4 'A'
19:46:10 <lambdabot>   "AAAA"
19:46:12 <Cale> But yes, it picks an element from the first list in all possible ways, ignores what it is, and then picks an element of the second list.
19:46:16 <Olathe> > (>>"AAA").(++"!!!") "zomg"
19:46:18 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:46:24 <Olathe> > (>>"AAA").(++"!!!") $ "zomg"
19:46:26 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAA"
19:46:29 <Cale> > [1,2,3] >> [4,5]
19:46:30 <Olathe> Ahh.
19:46:31 <lambdabot>   [4,5,4,5,4,5]
19:46:36 <mpeter> i think you need to get more abstract, cale
19:46:44 <Olathe> > (++"!!!").(>>"AAA") $ "zomg"
19:46:45 <lambdabot>   "AAAAAAAAAAAA!!!"
19:46:45 <Cale> > [10,20,30] >>= \x -> [4 + x,5 + x]
19:46:47 <lambdabot>   [14,15,24,25,34,35]
19:47:08 <porges> aka
19:47:10 <Cale> Okay, so let's take a look at the type of >>= in general
19:47:26 <jeffwheeler> That last example made a lot of sense; what is concatenating them, though?
19:47:32 <Cale> Given any monad M, we have (>>=) :: M a -> (a -> M b) -> M b
19:47:41 <Cale> What does it do?
19:47:56 * mpeter stares at that thing
19:48:07 <Axman6> :t return
19:48:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:48:08 <Cale> x >>= f is the action which will "run" x, getting its result (say v)
19:48:14 <Axman6> mpeter: ^^ might help :)
19:48:21 <Cale> and then apply f to v to get another action, which it will then run
19:48:22 <Axman6> trivial example though
19:48:23 <porges> jeffwheeler: (>>=) == concatMap
19:48:40 <ivanm> :t return
19:48:42 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:48:45 <porges> err
19:48:47 <ivanm> :t return . return -- what I meant
19:48:48 <saml> how can list be monad!!!!!!!!!
19:48:49 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, Monad m) => a -> m (m1 a)
19:48:50 <byorgey> jeffwheeler: that's just what >>= does in the list monad.
19:48:50 <Cale> gah, this channel is noisy :)
19:48:51 <porges> flip concatMap :)
19:48:59 <ivanm> saml: because its an instance of the Monad class?
19:49:00 <Cale> #haskell-overflow ?
19:49:01 <mpeter> > return 5
19:49:02 <lambdabot>       No instance for (Show (m t))
19:49:02 <lambdabot>        arising from a use of `show' at <in...
19:49:08 <Axman6> saml: huh?
19:49:10 <mpeter> > mnmn
19:49:11 <lambdabot>   Not in scope: `mnmn'
19:49:17 <saml> > "" >= \x -> ""
19:49:18 <lambdabot>       The lambda expression `\ x -> ""' has one argument,
19:49:18 <lambdabot>      but its type `...
19:49:24 <Cale> hello?
19:49:29 <mpeter> hello
19:49:31 <Taejo> I've heard Haskell's "monads" are really strong monads. What is a general (weak?) monad?
19:49:55 <Cale> Taejo: a strong monad is one which respects the categorical product in a particular way
19:49:56 <ivanm> Taejo: one that's easily beaten up by a Haskellian monad? :p
19:49:56 <jeffwheeler> saml: you need ">>"
19:49:57 <Axman6> saml: >>=
19:50:07 <jeffwheeler> saml: err, yeah; sorry, ">>="
19:50:15 <Cale> Taejo: Monads in Haskell are strong simply because of restrictions on the way we have to write them
19:50:18 <mpeter> > "Cale" >>= "Caelum"
19:50:19 <lambdabot>   Couldn't match expected type `Char -> [b]'
19:50:25 <rgr> is there a common fix for the input echo in the emacs integration for ghci 6.10?
19:50:34 <mpeter> :t >>=
19:50:36 <lambdabot> parse error on input `>>='
19:50:43 <Axman6> @src (>>)
19:50:43 <lambdabot> m >> k      = m >>= \_ -> k
19:50:45 <Cale> mpeter, others: want to move to #haskell-overflow and avoid some of the noise?
19:50:50 <mpeter> sure
19:50:58 <jeffwheeler> Cale: I'm fine with that.
19:51:08 <Cale> http://en.wikipedia.org/wiki/Strong_monad
19:51:13 <Cale> (for Taejo)
19:51:15 <solrize> > "Cale" >>= "Caelum" >>= return
19:51:16 <lambdabot>   Couldn't match expected type `Char -> [a]'
19:51:53 <solrize> > "Cale" >>= \x->"Caelum" >>= return
19:51:54 <lambdabot>   "CaelumCaelumCaelumCaelum"
19:52:03 <porges> > "Cale" >> "Caelum" >>= return
19:52:05 <lambdabot>   "CaelumCaelumCaelumCaelum"
19:52:10 <porges> > "Cale" >> return "Caelum"
19:52:12 <lambdabot>   ["Caelum","Caelum","Caelum","Caelum"]
19:52:13 <Taejo> Cale: I was hoping for something short, but thanks
19:52:20 <porges> oops :)
19:52:30 <roconnor> @check \(x:String) -> (x >>= return) == x
19:52:32 <lambdabot>   Not in scope: data constructor `String'
19:52:32 <solrize> > "Cale" >>= \x->"Caelum" >>= \y-> return (x,y)
19:52:33 <lambdabot>   [('C','C'),('C','a'),('C','e'),('C','l'),('C','u'),('C','m'),('a','C'),('a'...
19:52:39 <roconnor> @check \(x::String) -> (x >>= return) == x
19:52:40 <lambdabot>   Parse error in pattern at "->" (column 14)
19:52:47 <saml> > return <<= \x -> [chr x] <<= joke
19:52:48 <lambdabot>   Not in scope: `<<='Not in scope: `<<='Not in scope: `joke'
19:52:51 <roconnor> @check \x -> (x >>= return) == (x::String)
19:52:52 <sereven>  /join #haskell-overflow
19:52:52 <lambdabot>   "OK, passed 500 tests."
19:53:02 <solrize> > mapConcat $ "Cale" >>= \x->"Caelum" >>= \y-> return [x,y]
19:53:03 <lambdabot>   Not in scope: `mapConcat'
19:53:11 <Megzlna> data Foo = Foo { foo_x :: Int, foo_y :: Int, foo_z :: Int }
19:53:13 <solrize> > concatMap $ "Cale" >>= \x->"Caelum" >>= \y-> return [x,y]
19:53:15 <lambdabot>   Couldn't match expected type `a -> a1'
19:53:25 <orbitz> can i clear all the binding sin ghci without restarting?
19:53:49 <orbitz> solrize: concatMap doens't work on a monad does it?
19:53:55 <orbitz> :t concatmap
19:53:56 <lambdabot> Not in scope: `concatmap'
19:53:57 <orbitz> :t concatMap
19:53:59 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
19:54:00 <sjanssen> orbitz: :r will reload source files and also forget all bindings
19:54:05 <solrize> > concat $ "Cale" >>= \x->"Caelum" >>= \y-> return [x,y]
19:54:06 <lambdabot>   "CCCaCeClCuCmaCaaaealauamlClalelllulmeCeaeeeleuem"
19:54:36 <orbitz> sjanssen: it doens't seem to forget all bindigns for me, it also complains "no current target"
19:54:41 <porges> Cale: does strong vs. weak monad have some equivalence to constructivism vs. non-constructivism?
19:54:51 <orbitz> > "Cale" >>= \x->"Caelum" >>= \y-> return [x,y]
19:54:53 <lambdabot>   ["CC","Ca","Ce","Cl","Cu","Cm","aC","aa","ae","al","au","am","lC","la","le"...
19:54:58 <sjanssen> orbitz: it won't forget the bindings if you haven't loaded a source file
19:55:04 <orbitz> sjanssen: oh
19:55:05 <solrize> > concat $ "Cale" >>= \x->"Caelum" >>= \y-> return [toLower x, toUpper y]
19:55:07 <lambdabot>   "cCcAcEcLcUcMaCaAaEaLaUaMlClAlElLlUlMeCeAeEeLeUeM"
19:55:13 <Cale> porges: That's a tough question. At first glance, I don't think so.
19:55:28 <Cale> Please stop using my name unless you're directing things at me.
19:55:34 <porges> lol
19:55:35 <solrize> hehe ok
19:55:48 <orbitz> solrize: is this basically doing list comprehension but in the list monad?
19:56:13 <solrize> orbitz they are the same thing, list comprehensions are syntax sugar for list monad operations
19:56:22 <Megzlna> Goddamnit
19:56:27 <Cale> orbitz: Yes, the list monad is exactly list comprehensions
19:56:33 <porges> So a strong monad is one with a function f :: (Monad m) => (a, m b) -> m (a, b)
19:56:42 <solrize> > do { a <- [3..7]; return 3*a }
19:56:43 <lambdabot>       No instance for (Enum [t])
19:56:43 <lambdabot>        arising from the arithmetic sequence ...
19:56:45 <Cale> porges: yeah
19:56:52 <dolio> @undo [ x | y <- m , x <- y , x < 5 ]
19:56:52 <lambdabot> concatMap (\ y -> concatMap (\ x -> if x < 5 then [x] else []) y) m
19:57:08 <solrize> > do { a <- [3..7]; return (3*a) }
19:57:09 <Cale> orbitz: The advantage being that the list monad gives you lots of stuff from Control.Monad to use with lists
19:57:10 <lambdabot>   [9,12,15,18,21]
19:57:13 <dolio> @undo [ x | Just (y,_) <- m , x <- y , x < 5 ]
19:57:13 <lambdabot> concatMap (\ a -> case a of { Just (y, _) -> concatMap (\ x -> if x < 5 then [x] else []) y; _ -> []}) m
19:57:21 <porges> @define f (x, other) = other >>= \y -> return (x,y)
19:57:38 <porges> @let f (x, other) = other >>= \y -> return (x,y)
19:57:40 <lambdabot>  Defined.
19:57:47 <porges> @t f
19:57:47 <lojbot> f. /[NAME]/
19:57:47 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:57:56 <porges> @type f
19:57:58 <lambdabot>     Ambiguous occurrence `f'
19:57:58 <lambdabot>     It could refer to either `L.f', defined at <local>:1:0
19:57:58 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:73:0-32
19:58:02 <orbitz>    Cale do you hav ean exampl ei can see for what you mean?
19:58:08 <porges> @type L.f
19:58:10 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t, m a) -> m (t, a)
19:58:35 <Cale> > sequence [[1,2,3], [4,5], [6,7,8]]
19:58:36 <porges> existential proof? :)
19:58:37 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
19:58:51 <Cale> > filterM (const [True,False]) [1,2,3]
19:58:53 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
19:58:58 <Cale> lots of useful stuff
19:59:41 <dolio> @type uncurry (ap . (,))
19:59:42 <lambdabot>     Couldn't match expected type `a -> b'
19:59:42 <lambdabot>            against inferred type `(a1, b1)'
19:59:42 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
20:00:04 <dolio> @type uncurry (fmap . (,))
20:00:05 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
20:00:06 <purple_> I have a two line IO program importing Data.ByteString - how can i link it ?  ghc main3.hs -lData.ByteString  doesnt work
20:00:25 <orbitz> Cale: is the list monad stuf fin Data.List?
20:00:37 <dolio> All Haskell Functors are strong.
20:00:41 <augustss> purple_: use --make
20:00:50 <porges> Cale: any to-hand examples of weak monads?
20:00:52 <purple_> augustss i tried --make Main
20:01:05 <purple_> but it complained that i didnt have a module
20:01:14 <purple_> do i need to have a module
20:01:21 <Taejo> purple_: the argument to -l is a package, I believe, rather than a module
20:01:22 <augustss> purple_: ghc --make main3.hs
20:01:24 <porges> ghc --make main3.hs ?
20:01:53 <purple_> ok without an argument to --make
20:02:10 <purple_> works super - thanks for helping with newbi question ;-)
20:03:24 <porges> dolio: it's times like this I wish there were an automatic-generalization function in Haskell :)
20:03:52 <dolio> Just saying something here usually works. :)
20:04:28 <porges> like if you write something with concatMap you could ask GHC and it would say you could use flip (>>=)
20:04:52 <sclv> porges: @pl does that
20:04:52 <lambdabot> sclv: You have 1 new message. '/msg lambdabot @messages' to read it.
20:04:56 <porges> if anyone's ever used the Resharper for C#/Visual Studio they'll know what i mean :)
20:05:33 <porges> Write a function F(DerivedClass thing) with only functions from SuperClass and it will let you know you only need SuperClass
20:06:06 <sclv> on that tip, in general, if you write without a type signature, ghc will give the most general type.
20:06:20 <Gracenotes> meh, I've been away at my residency hall meeting while you all were talking about monads :/
20:06:26 <Gracenotes> *reads log*
20:06:29 <sclv> unless you use extensions such that you need a type signature. in which case, good luck.
20:06:35 <porges> sclv: but not if you use functions which constrain the types
20:06:45 <porges> if you see what I mean
20:06:57 <sclv> right, but the fact that concatMap = >>= isn't obvious to the compiler.
20:07:42 <porges> yeah, but I want a tool which knows these things :)
20:07:57 <dolio> Well, it is, for some value of obvious.
20:07:58 <chrisdone> haha, I wonder who the channel troll is: http://chrisdone.com/haskell-cloud.png
20:08:03 <sclv> porges: for real, patch @pl!
20:08:14 <dolio> Since it knows that (>>=) = flip concatMap for lists.
20:08:33 <sclv> chrisdone: looks like dons to me :-)
20:08:39 <dons> chrisdone: hah
20:08:46 <dons> heya sclv
20:08:52 <sclv> heya dons!
20:09:04 <chrisdone> :D
20:09:20 <Nafai> dons: So are you editing gitit stuff via the web or via an edit and doing a git add ; git commit?
20:09:24 <dons> chrisdone: would be interesting to do the whole logs.
20:09:24 <porges> chrisdone: cloud \\ usernames
20:09:29 <dons> Nafai: a bit of both
20:09:44 <chrisdone> dons: got a .tar.gz?
20:09:48 <dons> yeah, getting it ...
20:09:51 * chrisdone considers wget'ing from the archive
20:09:58 <dons> nah, i've got logs handy..
20:10:02 <chrisdone> :D
20:10:11 <chrisdone> porges: a'ight, I'll do two, one with and one without
20:11:07 <dons> compressing...
20:11:14 <dons> 500M
20:11:22 <chrisdone> hahaha
20:11:55 <dons> when you have something you like, could you add it to the irc page, http://haskell.org/haskellwiki/IRC_channel
20:11:58 <chrisdone> I wonder if my program will be able to handle that. is GHC's garbage collector aggressive enough? :P
20:12:01 <dons> along with our other nice analyses
20:12:04 <Gracenotes> oh, that's right, I don't *have to* log this channel because technically logs are freely available
20:12:06 <Gracenotes> *duh*
20:12:07 <chrisdone> dons:  sweet
20:12:36 <chrisdone> I like those social graphs
20:13:30 <dons> www.cse.unsw.edu.au/~dons/haskell-2002-2008.tgz
20:13:33 <dons> complete logs
20:13:42 <dons> 150M gzipped
20:13:50 <chrisdone> nice one
20:14:05 <ivanm> dons: we need people to talk about RWH more, so that it appears in the cloud graph ;)
20:14:09 <dons> hehe
20:14:15 <chrisdone> haha
20:14:18 <dons> well, if we had a cronjob that did a daily graph
20:14:26 <dons> versus total, yearly, etc
20:14:51 <orbitz> do predicates from list comprehension become if/else in list monad?
20:14:56 <chrisdone> I never did stick my word cloud library on hackage
20:15:17 <dons> orbitz: nope.
20:15:21 <sclv> orbitz: guard
20:15:24 <dons> chrisdone: sounds like a good time
20:15:26 <sclv> ?ty guard
20:15:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:15:34 <chrisdone> I'll have to clean it up
20:15:42 * chrisdone wipes away cobwebs
20:16:04 <orbitz> hrm guard?
20:16:06 <solrize> "yes your dolio has list" ??
20:16:16 <sclv> ?src guard
20:16:16 <lambdabot> guard True  =  return ()
20:16:17 <lambdabot> guard False =  mzero
20:16:22 <porges> @src guard
20:16:23 <lambdabot> guard True  =  return ()
20:16:23 <lambdabot> guard False =  mzero
20:17:00 <idnar> not that guard, though :/
20:17:17 <sclv> huh?
20:17:24 <solrize> orbitz:
20:17:42 <solrize> > do { x <- [1..10]; guard (even x); return x }
20:17:43 <lambdabot>   [2,4,6,8,10]
20:17:46 <idnar> oh wait, I guess it is that guard
20:18:09 * idnar was thinking of something else
20:18:15 <porges> ghci needs :src
20:18:25 <orbitz> @undo do { x <- [1..10]; guard (even x); return x }
20:18:26 <lambdabot> [1 .. 10] >>= \ x -> guard (even x) >> return x
20:18:58 <solrize> question: is there a way to break out of the monad completely?  like   do {x <- [1..]; break_if (x^2 > 200); return x }   ==  takeWhile (\x->x^2 < 200) [a..]
20:19:01 <porges> @undo [x|x<-[1..10],even x]
20:19:01 <lambdabot> concatMap (\ x -> if even x then [x] else []) [1 .. 10]
20:19:08 <solrize> >=
20:19:21 <orbitz> tahnks
20:20:54 <ozy`> monads should support GOTO
20:21:25 <idnar> ozy`: that's the Cont monad
20:21:27 <Olathe> Heheh
20:21:28 <porges> @ty callCC
20:21:30 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:21:33 <sclv> porges: see "ghci on acid" -- not sure if it isn't utterly bitrotted.
20:22:06 <Gracenotes> huh, list comprehensions are just a form of monad? I thought so... :/
20:22:32 <sclv> it used to be that comprehension notation turned into do notation internally, but no longer...
20:25:41 <Gracenotes> > mzero :: [Integer]
20:25:42 <lambdabot>   []
20:25:50 <chrisdone> yeah, the source is awful, it's slow, and the output isn't great: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/wordcloud
20:26:02 <chrisdone> but it's up there, and I'll improve it sometime
20:26:20 * chrisdone haet looking at old code
20:26:40 <idnar> > mzero :: [a]
20:26:41 <lambdabot>   []
20:26:49 <orbitz> how does guard work?  i se eteh source but i'm not sure the actual meaning
20:27:17 <ivanm> sclv: I think it's bitrotted :(
20:27:22 <idnar> orbitz: guard True gives you a "useless value" in the monad
20:27:29 <idnar> orbitz: guard False is "failure"
20:27:36 <porges> how do I install an old version of lambdabot using cabal?
20:27:43 <ivanm> ozy`: why do you want GOTOs? Aren't they considered harmful?
20:27:58 <ivanm> porges: the older versions of lambdabot didn't work too well IIRC
20:27:58 <orbitz> idnar: so when i do guard (even x); return x.  is teh 'fail' route being taken there, giving me nothing?
20:28:03 <sclv> ivanm: consider an edsl for assembly, for example.
20:28:11 <ivanm> as in if using an actual installer
20:28:18 <sclv> orbitz: it depends on your monadplus instance...
20:28:21 <porges> ivanm: but Debian/Ubuntu is still stuck on 6.8.3 :(
20:28:27 <idnar> orbitz: well, the exact meaning of "failure" depends on the MonadPlus instance
20:28:33 <idnar> orbitz: for example, in the list monad, guard True gives you [()]
20:28:38 <chrisdone> > do x <- Just (Just 1); guard (isJust x); return (fromJust x)
20:28:39 <idnar> which is a useless list, but it contains one value
20:28:39 <lambdabot>   Just 1
20:28:43 <ivanm> porges: oh, latest lambdabot requires 6.10 does it?
20:28:44 <chrisdone> ^_^
20:29:04 <idnar> whereas guard False gives you [], which is an empty list, which is like a black hole in the list monad
20:29:09 <ivanm> in that case, download a tarball, extract it, build it and run it from that directory IIRC
20:29:11 <sclv> ?src [] mzero
20:29:11 <lambdabot> mzero = []
20:29:13 <ozy`> ivanm: I was half-joking
20:29:25 <ivanm> only half?
20:29:28 <ozy`> I've been leaning more and more towards assembly these days though
20:29:29 <idnar> > guard True >> [5]
20:29:30 <porges> ivanm: this isn't helping with the 'using cabal' part :P
20:29:31 <lambdabot>   [5]
20:29:32 <idnar> > guard False >> [5]
20:29:33 <lambdabot>   []
20:29:35 <sclv> ?src Maybe mzero
20:29:35 <lambdabot> mzero = Nothing
20:29:46 <idnar> > guard False >> Just 5
20:29:48 <lambdabot>   Nothing
20:29:49 <idnar> > guard True >> Just 5
20:29:50 <lambdabot>   Just 5
20:30:03 <ozy`> > do x <- []; guard True
20:30:05 <lambdabot>   []
20:30:06 <sclv> ?instances MonadPlus
20:30:07 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
20:30:11 <ozy`> > do x <- [1]; guard True
20:30:13 <lambdabot>   [()]
20:30:16 <ozy`> I see
20:30:25 <sclv> I wrote some neat code the other week using MonadPlus in an ErrorT
20:30:37 <Gracenotes> > concatMap negate [()]
20:30:38 <lambdabot>   Couldn't match expected type `[b]' against inferred type `()'
20:30:55 <Gracenotes> fair enough
20:31:09 <idnar> "guard foo >>= whatever" and "x <- guard foo" are generally useless
20:31:20 <sclv> it let me try a set of database queries until I found one that worked and feed that into a set of database queries based on them and etc... essentially a list comprehension in IO.
20:31:26 <ivanm> porges: AFAIK you can't... old lambdabot had to be run from the directory it was built in
20:31:31 <ivanm> to find the STATE file, etc.
20:31:44 <porges> wah!
20:31:49 <ozy`> > (\() -> ()) ()
20:31:50 <lambdabot>   ()
20:31:58 <porges> someone make me some tasty 6.10 .debs!
20:32:02 <ozy`> @pl (\() -> ()) ()
20:32:02 <lambdabot> (line 1, column 5):
20:32:02 <lambdabot> unexpected " "
20:32:02 <lambdabot> expecting operator, pattern or "->"
20:32:06 <ozy`> @pl (\() -> ())
20:32:06 <lambdabot> (line 1, column 5):
20:32:07 <lambdabot> unexpected " "
20:32:07 <lambdabot> expecting operator, pattern or "->"
20:32:10 <ozy`> guh
20:32:40 <idnar> ozy`: isn't that just id?
20:33:14 <ozy`> idnar: restricted to type (), yes
20:33:22 <Gracenotes> I haven't quite caught on to what @pl does -- what?
20:33:51 <Olathe> It takes all the arguments out.
20:34:04 <porges> @djinn () -> ()
20:34:05 <lambdabot> f a = a
20:34:05 <Olathe> @pl \a b -> f b a
20:34:06 <lambdabot> flip f
20:34:11 <Olathe> See, no a or b.
20:34:15 <ozy`> "pl" = perl? :p
20:34:24 <pumpkin> pointless
20:34:32 <Gracenotes> converting to pointfree if possible, then?
20:34:40 <Olathe> @pl \a b -> b (f a b b a b a b a)
20:34:41 <lambdabot> ap id . (flip =<< join . (flip =<< join . (flip =<< join . f)))
20:34:51 <Gracenotes> oh dear
20:34:57 <pumpkin> there's no way to "split" a string on a separator, right? I feel like someone asked this yesterday but I forgot
20:35:00 <Olathe> No as or bs anywhere.
20:35:03 <ozy`> @pl "GREAT SCOTT"
20:35:03 <lambdabot> "GREAT SCOTT"
20:35:24 <Gracenotes> @pl \a -> a
20:35:25 <lambdabot> id
20:35:30 <porges> pumpkin: see Data.List.Split on the wiki :)
20:36:03 <Megzlna> ozy`, why would you lean towards ASM?
20:36:06 <Gracenotes> @pl \a b c -> a (b*c)
20:36:07 <lambdabot> (. (*)) . (.)
20:36:20 <pumpkin> :)
20:36:22 <ozy`> Megzlna: because it's fast, and fast is important. you should know!
20:36:29 <pumpkin> :o
20:36:33 <Megzlna> I do know -- it's not fast.
20:36:34 <pumpkin> not relaly :P
20:36:56 <Gracenotes> @pl \a b c -> a . b . c
20:36:56 <lambdabot> (. (.)) . (.) . (.)
20:37:04 <ozy`> Megzlna: yes it is. it has a great syntax for GOTO that most languages don't
20:37:09 <Gracenotes> okay, I'm done :3 most interesting.
20:37:20 <porges> Gracenotes: stop trying to make pointfree breasts
20:37:37 <Megzlna> ASM has no syntax
20:37:40 <Megzlna> only bytes
20:37:41 <Gracenotes> oh, come now. What do you take me for?
20:38:12 <Gracenotes> thanks for the idea, though.
20:39:12 <ozy`> Megzlna: and minimal syntax is optimal for readability
20:39:21 <porges> @type (:[]) ((.) (.))
20:39:22 <lambdabot> forall b c a a1. [(a1 -> b -> c) -> a1 -> (a -> b) -> a -> c]
20:39:37 <ozy`> Megzlna: I still want to know why you're looking into Haskell
20:39:41 <Megzlna> ozy is that sarcasm or are you being serious?
20:39:47 <porges> decapitated gorilla?
20:39:53 <ozy`> that was sarcasm :p
20:40:03 <ozy`> but the part about wanting to know was serious
20:40:48 <porges> cabal, you need uninstall
20:40:54 <Gracenotes> porges: hm, I've succeeded already
20:41:01 <Gracenotes> *bows out*
20:41:37 <Megzlna> If you go happily a'coding in ASM, you'll get slow code.
20:41:47 <Megzlna> slower than what GCC would produce, etc.
20:42:08 <Elly> holy shit I just slightly got monads
20:42:18 <Olathe> Elly: They have creams for that.
20:42:25 <Elly> I'm working in SML
20:42:25 <chrisdone> Â¿high five?
20:42:37 <Elly> and I have a chain of functions: 'a -> 'b option, 'b -> 'c option, ...
20:42:45 <Elly> and I want to compose them all into 'a -> 'z option
20:42:55 <Elly> and I thought to myself "I want the Maybe monad"
20:43:00 <Elly> then I was sad, because SML doesn't have it :(
20:43:24 <chrisdone> WHAT
20:43:31 <byorgey> pumpkin: there will be a hackage package to do that in the next day or two!
20:43:35 <byorgey> you'll be the first to know
20:43:37 <chrisdone> dons: hahaha, it actually completed. it took 8 whole minutes to do 400MB of logs
20:43:38 <pumpkin> yay
20:43:53 <chrisdone> dons: I thought it would crash my computer but the memory usage barely went over 80%
20:43:53 <chrisdone> http://chrisdone.com/haskell/code/irc-logs/haskell.png
20:43:54 <Taejo> Elly: surely it's not hard to write `bind' in SML?
20:44:00 <erikc> megzlna: depends on the platform, gcc is quite immature for a lot of unpopular hardware
20:44:08 <chrisdone> GO HASKELL
20:44:14 <chrisdone> !! ^_____^ !!
20:44:24 <Elly> Taejo: try figuring out the type
20:44:27 <Megzlna> why 'net' ?
20:44:45 <chrisdone> did shapr used to be a lot more active?
20:45:00 <porges> chrisdone: HASKELL
20:45:15 <chrisdone> porges: NOMADS. HASKELL NOMADS
20:45:34 <Taejo> Elly: I don't know SML
20:45:36 <chrisdone> Megzlna: maybe it's picking up the hostnames in part/quit messages. I'll filter those out and do again
20:45:40 <porges> needs more  words :P
20:45:44 <Elly> Taejo: I do, and it's difficult :P
20:45:46 <Elly> it lacks typeclasses
20:45:55 <chrisdone> porges: yeah, good point. I'll make it bigger
20:46:03 <dublpaws> it'd be neat to see how that output png changes over time.
20:46:07 <Taejo> Elly: that much I know. I meant write a bind specialised for option
20:46:13 <Megzlna> strange that 'xerox' is one of the top words...
20:46:14 <Elly> oh, you could do that
20:46:18 <Elly> I was trying to generalize it though
20:46:18 <pumpkin> is there a good way to "rotate" a string? (like bit rotation)
20:46:35 <chrisdone> dublpaws: maybe one could do one cloud per day
20:46:35 <pumpkin> or should I just drop ++ take
20:46:56 * gwern feels a alittle insulted to not be on the chrisdone chart
20:47:08 <chrisdone> gwern: haha, you active pillar of the community, you!
20:47:24 <sclv> pumpkin: splitAt should be slightly better than a drop and take.
20:47:32 <pumpkin> oh, yeah
20:47:34 * chrisdone sets the settings to be bigger and starts the generating again
20:47:35 <pumpkin> thanks
20:47:45 <gwern> well, I can take comfort in knowing I'd be high up if chrisdone were making charts for hackage anyway
20:47:47 <Elly> fuck this SML nonsense, I'm going to use haskell
20:47:47 <Taejo> pumpkin: and you might like to use cycle so you can rotate by more than the length
20:47:52 <Megzlna> chrisdone: make it huge.
20:48:01 <chrisdone> Megzlna: that's what she said
20:48:08 <porges> pumpkin: use cycle and just drop appropriate amounts
20:48:11 <Elly> chrisdone: I successfully resisted the temptation to say that ;P
20:48:14 <pumpkin> > join (***) (flip (++)) $ splitAt 2 "abcdef"
20:48:15 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
20:48:15 <lambdabot>        arising from a...
20:48:19 <chrisdone> Elly: hahaha, you're a better man than me
20:48:37 <Elly> better human, perhaps :P
20:48:38 <Megzlna> wtf?
20:48:55 <pumpkin> ?
20:49:02 <ivanm> gwern: why, because you're a hackage whore? :p
20:49:10 <Megzlna> he was talking about his penis pumpkin
20:49:13 <pumpkin> lol
20:49:16 <chrisdone> Â¿wtfo?
20:49:56 <porges> off topic, but does anyone know how to find exactly which Compose file X is using at the moment >_<
20:50:13 <gwern> ivanm: I do it with just about every package that moves
20:50:56 <pumpkin> > uncurry (flip (++)) $ splitAt 2 "abcdef"
20:50:58 <lambdabot>   "cdefab"
20:51:16 <BMeph> gwern: Have you talked to John Tromp? His binary LC coder would be handy on Hackage... ;)
20:51:29 <solrize> LC?
20:51:30 <gwern> who and what?
20:52:16 <BMeph> solrize: LC == Lambda Calculus
20:52:26 <solrize> binary lambda calculus???  hmm
20:53:00 * gwern still has no idea what a abinary lambda calculus coder is
20:53:14 <BMeph> Shoot! Who was asking about Erdos numbers earlier today? 'Cause Tromp's is 2 - it's on his homepage. =8*O
20:53:25 <BMeph> gwern: Check out http://homepages.cwi.nl/~tromp/cl/cl.html
20:53:33 <Elly> haha, oh wow
20:53:38 <Elly> darcs takes out my router really quickly
20:57:08 <gwern> BMeph: what woud you do with a cabalized binary lc? he doesn't even seem to've license info
20:57:35 <sw17ch> is there a way i can ask cabal to use gcc instead of ghc when compiling a C file?
20:59:06 <ivanm> sw17ch: ummmmm..... AFAIK ghc can't compile C files...
20:59:20 <sw17ch> ivanm: it sure can :P
20:59:37 <gwern> ghc is very talented
20:59:46 <BMeph> gwern: Hmm, you know, I'm no genius, but just being a fan, I bet you'd better better answers if you asked /him/... ;)
21:00:11 <BMeph> s/better better/get better/
21:01:00 <sw17ch> i'm having this really funny behavior...
21:01:08 * BMeph laughs
21:01:18 <gwern> BMeph: ok, just don't expect me to get around to it anytime soon; I have higher priority haskell hacking than random unlicensed stuff
21:01:20 <sw17ch> if i build the file by hand, it all seems to be okay
21:01:25 <pumpkin> I asked this ages ago but have since lost the answer... does anyone have a good way to intersect two infinite lazy lists that are known to be sorted?
21:01:36 <gwern> (for example, darcsit, if you will. I'd reall like that)
21:01:37 <sw17ch> but hwen i use cabal to build the project, i get all sorts of odd warnings
21:02:32 <BMeph> pumpkin: What's wrong with the naive approach? :)
21:02:39 <sjanssen> sw17ch: does the .cabal file have different ghc-options?
21:02:48 <sw17ch> sjanssen, i've replicated everything
21:02:49 <sw17ch> :\
21:02:57 <sjanssen> sw17ch: it would also help to know what the odd warnings are
21:03:00 <sw17ch> somehow ghc seems to be referencing a bad headerfileor something...
21:03:07 <pumpkin> BMeph: nothing :P was wondering if there was one already written out there
21:03:07 <sw17ch> let me see if i can get some of this into hpaste...
21:03:47 <sw17ch> sjanssen, first off, here's my cabal file: http://code.google.com/p/scurry/source/browse/trunk/scurry.cabal
21:04:12 <sjanssen> gwern: do you think darcs is fast enough to support a wiki?
21:04:22 <BMeph> pumpkin: For some (likely hysterical) reason, there are a slew of functions helpful, easy to write...but not actually written, in Haskell. :)
21:04:26 <sjanssen> gwern: I imagine you'd need better speed for thinks like "darcs annotate"
21:04:29 <sw17ch> sjanssen, here's the horribly ugly C file that seems to generate odd warnings when build: http://code.google.com/p/scurry/source/browse/trunk/src/C/help-win.c
21:05:28 <mwotton> BMeph: there was a MissingPrelude project or something at some point, wasn't there?
21:05:34 <sjanssen> sw17ch: what are the warnings?
21:06:07 <sw17ch> sjanssen, here's the build output: http://hpaste.org/13113
21:06:09 <sw17ch> notice the first warning
21:06:19 <pumpkin> BMeph: boo :)
21:06:56 <Olathe> @index liftM2
21:06:56 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:07:25 <brushbox> s
21:07:28 <gwern> sjanssen: I'm not sure gitit requires darcs annotate
21:07:30 <sw17ch> sjanssen, and this is the -v output from build (C compile line only): http://hpaste.org/13113#a1
21:07:31 <gwern> does it?
21:07:46 <sjanssen> gwern: it would if you want to show history for a given page
21:09:02 <Elly> hm
21:09:15 <Elly> how do people have a magic 'cabal' binary? I installed cabal from portage and I don't have one :(
21:09:21 <gwern> sjanssen: is darcs annotate very slow?  it doesn't seem too bad
21:09:43 <gwern> Elly: people are very sloppy - cabal the library versus 'cabal' the executable supplied by cabal-install
21:09:48 <sjanssen> sw17ch: so I don't know much about Windows, but are you sure the second argument to RegOpenKeyEx is supposed to be an LPCTSTR?
21:09:56 <Olathe> @hoogle [a] -> a -> Int
21:09:57 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
21:09:57 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
21:09:57 <lambdabot> Prelude (!!) :: [a] -> Int -> a
21:10:06 <sjanssen> gwern: IIRC, the GHC team has trouble with it
21:10:18 <sw17ch> sjanssen, that's the funny thing. i've reproduced that short bit of functionality in a separate C file and it compiles without the warning
21:10:24 * Elly looks for packages owning 'cabal'
21:10:26 <sjanssen> gwern: also, they couldn't use darcs trac integration because annotate was too slow
21:10:33 <sw17ch> if i build the file with GCC it compiles without the warning
21:10:35 <ddarius> Elly: cabal-install
21:10:42 <Elly> cabal-install is not a gentoo package :(
21:10:43 <gwern> well, that's GHC. I'm not sure that's really analogous to a wiki
21:10:43 <sw17ch> it's only when i build it with cabal
21:10:45 <sjanssen> gwern: but I suppose this isn't really a problem for small scale personal wikis
21:11:21 <gwern> sjanssen: wikis also have different usage patterns, I guess. it's an open question how to scale a DVCS-backed wiki to English sizes
21:11:25 <sw17ch> sjanssen, ah, breakthrough
21:11:34 <sw17ch> in the C build line, if i drop all the -package definitions, it builds
21:11:39 <sw17ch> without the warning
21:11:53 <gwern> you would probably have to make each article its own repo, in which case darcs annotate would only rarely be a problem in the most modified articles
21:11:53 <sjanssen> gwern: "English sizes"?
21:12:32 <gwern> sjanssen: yes, as the English wikipedia, around ~3m articles; the sql tables for en alone are like 500gb. I suspect even git has trouble at those sizes
21:12:42 <sjanssen> sw17ch: packages can make more includes available to #include, perhaps you've got clashing includes?
21:12:57 <sw17ch> sjanssen, i'm starting to think so...
21:13:05 <sjanssen> gwern: yeah, it might not be reasonable to expect a VCS to handle that
21:13:05 <sw17ch> it's odd because it was working just fine
21:13:08 <gwern> not to mention the hundreds/thousands of revisions a minute thing. that'd probably expose some race bugs :)
21:13:10 <sw17ch> and then one day it broke
21:13:15 <sw17ch> although i've only checked on my vista machines
21:13:18 <sw17ch> not any XP ones...
21:13:20 <sjanssen> gwern: and there are all sorts of optimizations you can make on a wiki
21:13:29 <gwern> sjanssen: oh, and hundreds of gigs of binary (non-textual) content
21:13:32 <sjanssen> eg. in a wiki, a patch will only ever edit one file
21:13:38 <gwern> which may or may not be included in the sql table count
21:13:54 <sw17ch> sjanssen, holy crap it's the time package
21:14:08 <sw17ch> this suddenly makes sense...
21:14:16 <sw17ch> i added that about a week ago and figured it wouldn't make a difference...
21:14:19 <sjanssen> sw17ch: heh, which include is messing you up?
21:14:28 <sw17ch> i'm not entirely sure...
21:14:45 <sw17ch> but if i drop -package time-1.1.2.1 it compiles fine
21:15:17 <ivanm> gwern: git having troubles with large repos? Perish the thought! :p
21:15:21 <sw17ch> is there a way to see what includes get pulled in?
21:15:37 <sjanssen> gwern: in a wiki, every page could be a separate repository.  That should scale time-wise, but would be a massive explosion in space
21:15:51 <sjanssen> sw17ch: ghc-pkg describe will tell you
21:16:09 <sjanssen> sw17ch: specifically, include-dirs
21:16:23 <sw17ch> sjanssen, thanks, i'll go hunting
21:16:38 <gwern> sjanssen: doesn't seem like it'd be too bad. a git or darcs repo is just 2n, or so at athe beginning - one copy for git/darcs, and the original, plus a small constant for the prefs/ and directories themselves
21:16:52 <sjanssen> gwern: on the other hand, perhaps atomic commits that touch many files could be useful?
21:17:41 <gwern> sjanssen: well, global search-and-replaces are common enough tasks on a wiki. but I suspect that dependencies and stuff mean you would want to lots of indivudual commits
21:17:48 <sw17ch> sjanssen, ah, even better. time depends on Win32-2.1.1.1
21:17:55 <sw17ch> and if i add that -package line, i get the warning again
21:18:02 <sw17ch> so, the clash is in that package
21:18:05 <Megzlna> I'm going to get in trouble on this channel if I keep going on. I'm biting my lip, but I'm still furious
21:18:21 <sjanssen> Megzlna: what?
21:19:07 <Axman6> Megzlna: about what?
21:19:14 <blando> record syntax
21:19:29 <Axman6> o.O
21:19:42 <sjanssen> just the syntax?
21:19:44 <pumpkin> lol
21:19:46 <blando> don't worry, he'll fill you in
21:20:01 <Axman6> i'm not so sure about that
21:20:02 <sjanssen> maybe I should just grep the logs
21:20:02 <BMeph> dons - John Tromp has an Erdos number of 2. Just in case you were still working on that. :)
21:20:07 <ivanm> Megzlna: if you're still that furious, why are you here?
21:20:15 <pumpkin> furious why?
21:20:15 <ivanm> BMeph: heh
21:20:16 <sjanssen> but yes, the record system in Haskell sucks.  Everybody knows it
21:20:33 <ivanm> pumpkin: he still doesn't like record syntax
21:20:50 <pumpkin> that doesn't seem like the kind of word I'd use furious for
21:20:53 <ivanm> sjanssen: exactly... even SPJ says it was a compromise kludge (well, maybe not the kludge bit...)
21:21:07 <pumpkin> I don't like it either, but I'm disgusted, not pleased, disappointed at the ugly syntax, etc.
21:21:21 * ivanm feels more resigned
21:21:26 <ddarius> ivanm: There's nothing kludgy about it, it's just very conservative.
21:21:28 <ivanm> than disgusted, etc.
21:21:32 <sw17ch> man, this bug went from perplexing to enraging in a very short amount of time...
21:21:34 <ivanm> ddarius: true
21:21:45 <gwern> funnily, I'm more bothered by the import syntax than the record system
21:21:48 <sw17ch> is there a way to ask that ghc *not* pass the -package options to the C compile?
21:21:57 <sjanssen> sw17ch: I don't think so
21:22:01 <Olathe> I hate arrays in Haskell.
21:22:03 <ddarius> gwern: The module system is very conservative too.
21:22:08 <ivanm> sw17ch: get down on your knees and beg? :p
21:22:13 <ivanm> Olathe: oh? why?
21:22:22 <ddarius> Olathe: Okay, the standard arrays are a mess.
21:22:22 <sjanssen> sw17ch: you just need to find out which of your #includes share the same name as a file in some package's includ-dirs
21:22:23 <sw17ch> is there an alternate compilation option?
21:22:27 <gwern> ddarius: it's really the repetitiveness of typing 'import' that gets to me. that and the parentheses
21:22:29 <Axman6> Megzlna: why are you furious?
21:22:40 <ivanm> Axman6: record syntax
21:22:51 <sw17ch> sjanssen, well, it seems that Win32 pulls a different windows.h than i'm expecting
21:23:23 <ivanm> gwern: well, you have to tell it _somehow_ that you want to import it...
21:23:30 <ivanm> it's either that or include ;)
21:23:32 <ddarius> gwern: Isn't this like almost every other language in existence? (Not that that means it's good, but...)
21:23:45 * ivanm prefers import to #include
21:23:58 <ivanm> and haskell's way is better than python's
21:24:21 <erikc> so as a new mac owner, macports is the right package management system to go with?
21:24:30 <jeffz`> either that or install a linux distro :P
21:24:47 <ivanm> erikc: depends on what you want ;)
21:24:49 <ddarius> erikc: I'm sure there is a mac channel somewhere.
21:24:57 <blando> ivanm: i dunno, i really like being forced to stuff my code into into files called __init__
21:24:58 <chrisdone> a comma?
21:25:11 <erikc> ddarius: i would trust #haskell users more than mac channel users in terms of what would suit my taste
21:25:11 <ivanm> blando: heh
21:25:14 <chrisdone> import Control.Monad,Control.Applicative,Control.Arrow
21:25:26 <gwern> ivanm: what I'd like is something like 'import Data.Bytestring\ntab-tab-tab Data.Char\ntab-tab-tab Data.List', if you follow
21:25:29 <ddarius> erikc: Unfortunately, that does not make it any more on topic here.
21:25:32 <ivanm> erikc: there's also fink and gentoo-prefix that I know of
21:25:43 <ivanm> gwern: ahhh, nested import kind of stuff?
21:25:51 <porges> I don't like the "qualified" keyword
21:25:53 <gwern> so one could almost think of 'import' as a function taking a list of modules
21:25:59 <porges> "as" is already there
21:26:05 <ivanm> gwern: import :: [Modules] -> IO () :p
21:26:20 <ivanm> porges: two different things
21:26:24 <chrisdone> porges: qualified and as do indiviudual things
21:26:30 <ivanm> as if for an alias, but it doesn't qualify it
21:26:40 <ivanm> then again, is there anyone that aliases without qualifying?
21:26:41 <gwern> ivanm: also, it bugs me that I have to overspecify with both () *and* newlines. I mean, isn't 'import Prelude hiding filter\n' as clear and unambiguous as 'import Prelude hiding (filter)\n'?
21:26:50 <porges> ahhhhhhhhhh!
21:27:01 <porges> help
21:27:07 <ivanm> gwern: not really.... I find the bracketing clearer
21:27:28 <sjanssen> gwern: actually, I bet the brackets could be removed without messing up the syntax
21:27:31 <ivanm> porges: hmmm? saying "ahhhhhhhhhh!" helps you understand things or something? :p
21:27:50 <Olathe> It helps the doctor.
21:27:55 <porges> I didn't realise you could do one without the other
21:27:56 <gwern> sjanssen: the only problem I could think of is importing operators, but those you already have to use () again on
21:27:59 <ivanm> Olathe: lol
21:28:00 <Olathe> Why not us ?
21:28:02 <porges> :P
21:28:17 <ivanm> porges: I only realised that when I had to deconstruct haskell-src{,-exts} output
21:28:29 <gwern> ivanm: I'll bet you admire Java's superfluous parentheses as well! 'foo();'...
21:28:43 <ivanm> gwern: I can't think of a single think I admire about Java...
21:28:54 <ivanm> but in Java's defence, that indicates a method as opposed to a variable
21:29:09 <sw17ch> sjanssen, i found it
21:29:16 <Axman6_> i like java's libraries
21:29:20 <sw17ch> winreg.h is different in ghc's include dir and my gcc include dir
21:29:26 <ivanm> I commonly have in my Java code something like: String foo() { return foo; }
21:29:36 <sw17ch> it appears the ghc version is *wrong*
21:29:40 <gwern> indeed
21:29:42 <sjanssen> sw17ch: interesting
21:29:51 <ivanm> Axman6_: OK, maybe the large wealth of libraries people have written for Java is useful.... but isn't that what hackage is for?
21:30:05 <ivanm> I'm not even sure if there is a standard Java lib site...
21:30:21 <ivanm> sw17ch: maybe they need to update it?
21:30:23 <Axman6_> ivanm: it'd be nice if there was an easy way to make foo read only, without having to explicitly define the function though :\
21:30:43 <ivanm> Axman6_: you mean from outside that class?
21:30:53 <Axman6_> ivanm: i'm talking about the libraries included with java, not the ones people have written seperately
21:30:57 <Axman6_> ivanm: yes
21:31:04 <porges> java has a lot of baggage libraries
21:31:07 <ivanm> oh? the default libraries piss me off...
21:31:10 <ivanm> porges: exactly
21:32:06 * ivanm 's current biggest gripe with Java is the whole "multiple inheritance is _bad_" attitude
21:32:27 <sw17ch> ivanm, that's what it appears like
21:32:31 <sw17ch> i am using an older Win32
21:32:34 <sw17ch> (6.8.3)
21:32:47 * sw17ch decides to bite the bullet and upgrade to 6.10
21:32:53 <sw17ch> but this is very odd..
21:32:59 <ivanm> sw17ch: my guess is that they can't get a newer version due to licensing issues
21:33:05 <Gracenotes> ivanm: then how to do take care of the diamond problem? :/
21:33:08 <Gracenotes> +you
21:33:09 <ivanm> since gcc is gpl, and ghc is bsd
21:33:11 <sw17ch> ivanm: licensing issues?
21:33:24 <ivanm> Gracenotes: carefully ;)
21:33:24 <sw17ch> ah...
21:33:40 <sw17ch> well shoot, this is a showstopping bug...
21:33:44 <ivanm> with what I'm doing, I have a lot of code duplication because I have to use interfaces :@
21:33:55 <sw17ch> this means all the registry commands in the Win32 package do'nt work
21:33:57 <ivanm> sw17ch: maybe ask on #ghc?
21:34:05 <Gracenotes> ivanm: any details...? like, 'this class has bytes so it gets precedence' ;)
21:34:07 <BMeph> ivanm: Yeah, if you're trying to model, say, a boat house, you start imagining driving a truck full on fertilizer to Sun's HQ... :P
21:34:23 <ivanm> BMeph: heh
21:34:24 <Gracenotes> more bytes, even. meh @ translating thoughts to keystrokes
21:34:25 <BMeph> Full *of
21:34:27 <Olathe> 6.10 is out ?
21:34:31 <pumpkin> whee I'm ruling euler
21:34:39 <BMeph> Olathe: 6.10 is IN! ;)
21:34:42 <sw17ch> ivanm: giving it a shot
21:34:43 <chrisdone> Olathe: that's so, like, ten minutes ago
21:35:09 <ivanm> Olathe: no, but 6.10.1 is ;)
21:35:58 <ivanm> hmmmm..... if I believe this email I just got, I just lost my own mobile number and have to click on the link provided because I can't read the full message properly...
21:36:19 <Olathe> Ahh :)
21:36:25 <Olathe> I'd been using an early 6.8
21:36:27 <chrisdone> nah, that email's legit. I got the same one
21:36:35 <ivanm> chrisdone: lol
21:36:45 <byorgey> pumpkin: nice!  how many have you solved?
21:37:03 <pumpkin> byorgey: up to 37
21:37:06 <pumpkin> not in order
21:37:19 <ivanm> chrisdone: you lost your own mobile number as well, have you (as in the from address == to address)? :p
21:37:24 <byorgey> pumpkin: good work =)
21:38:08 <chrisdone> ivanm: I haven't lost my number, but I was glad they sent the link. shows initiative
21:38:11 <Axman6> pumpkin: damn, beating me by 1
21:38:17 <pumpkin> Axman6: muahahaha
21:38:37 <pumpkin> thanks byorgey :)
21:38:46 <sw17ch> geeze this is frustrating
21:38:48 <chrisdone> Axman6: quick, solve that word search one that you didn't bother to do because it was so trivial!
21:39:42 <ozy`> http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
21:40:21 * Axman6 does http://projecteuler.net/index.php?section=problems&id=24
21:41:11 <FunctorSalad> > (-1) -- is unary minus magic?
21:41:13 <lambdabot>   -1
21:41:37 <FunctorSalad> seems like it...
21:41:42 <ivanm> FunctorSalad: yes
21:41:47 <Olathe> Hmm...that's an interesting one.
21:41:54 <chrisdone> http://chrisdone.com/haskell-cloud.png
21:41:55 <ivanm> the RWH section on it is one of the best I've seen tbh
21:41:59 <FunctorSalad> I've been here for a while but never really thought about it ;)
21:42:17 <pumpkin> Axman6: better hurry, just got another one ;)
21:43:17 <ozy`> chrisdone: great scott D:
21:43:20 <chrisdone> hahaha
21:43:24 <Axman6> mwaha! (sort.permutations $ [0..9])!!999999
21:43:48 <pumpkin> Axman6: ?
21:43:58 <Axman6> number 24
21:44:01 <pumpkin> oh :P
21:44:30 <chrisdone> ozy`: that's all of Haskell's IRC logs since the dawwwn of tiiiime
21:44:55 <ozy`> chrisdone: my brain was just vaporized and the magic smoke exploded out my ears
21:45:02 <FunctorSalad> chrisdone: stopword filter? ;)
21:45:16 <FunctorSalad> ("are" is not very interesting)
21:45:30 <chrisdone> FunctorSalad: yeah, I think so, too. *finds a stop words text file*
21:45:43 <cjay> regarding the logo ideas, imho lambdas in circles look cool, but look too much like the half-life logo most of the time
21:45:49 <chrisdone> http://www.dcs.gla.ac.uk/idom/ir_resources/linguistic_utils/stop_words
21:45:51 <chrisdone> sufficient?
21:46:04 <lament> chrisdone: you should probably normalize case too
21:46:10 <chrisdone> lament: indeed
21:46:33 <lament> i like the central position of 'think' :)
21:46:48 <ozy`> cjay: and who says we don't -want- that association? I've almost written "HÎ»SKELL" a few times...
21:46:55 <idnar> haha
21:46:59 <FunctorSalad> from "I think", methinks
21:47:16 <idnar> cogito?
21:47:17 <lament> somehow I is missing
21:47:23 <cjay> "Gordon Freeman would use Haskell"
21:47:45 <idnar> maybe Half-Life: Episode 3 could have a minigame where you have to write a Haskell program
21:47:54 <ozy`> that would be so epic
21:47:57 <lament> chrisdone: also, things like "doesn" and "ll" are ugly.
21:47:59 <cjay> :)
21:48:07 <mwotton> Portal is definitely a zipper
21:48:07 <BMeph> Haskell: If you don't have a crowbar, use this... ;)
21:48:20 <pumpkin> http://projecteuler.net/index.php?section=problems&id=37 hmm, can only find 10
21:48:24 <chrisdone> lament: where's that?
21:48:33 <Gracenotes> @hoogle Monad m => (a -> b) -> m a -> m b
21:48:33 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
21:48:33 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
21:48:33 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
21:48:34 <lament> chrisdone: in the cloud.
21:49:01 <lament> chrisdone: ll is two lines down from 'll' in "Haskell"
21:49:28 <lament> i mean "haskell"
21:49:28 <ozy`> http://haskell.org/haskellwiki/Image:Haskell_3qhalfinfinitylambda.png <== this one ought to satisfy the people who don't like the lambda-in-a-circle thing. it's got a lambda and a circle but the lambda isn't exactly -in- the circle. and it looks cool.
21:49:50 <ozy`> my favorite idea is still the pyramid-eye, though ;)
21:50:10 <chrisdone> lament: mmkay
21:50:28 <chrisdone> let me do some adjusting
21:50:41 <lament> "don" is very big too
21:51:02 <idnar> ozy`: that 'a' looks like rho or something
21:51:02 <sw17ch> does 6.10 ship with cabal-install?
21:51:07 <pumpkin> sw17ch: nope
21:51:11 <pumpkin> mine didn't
21:51:11 <idnar> well, an upside-down rho, I guess
21:51:13 <sw17ch> dangit
21:51:15 <FunctorSalad> lament: but nothing wrong with that, is it
21:51:25 * sw17ch remembers why he didn't upgrade to 6.10 in the first place...
21:51:31 <ozy`> idnar: yeah, it's weird
21:51:31 <lament> FunctorSalad: it's an artifact from "don't"
21:51:33 <sw17ch> reinstalling all his stupid libraries
21:51:44 <FunctorSalad> lament: ahh
21:51:49 <pumpkin> sw17ch: you should stay away from stupid libraries
21:52:01 <FunctorSalad> I guess one just wants to count apostrophes as letters?
21:52:02 <ozy`> sw17ch: I still can't get Cabal to work... aaargh
21:52:03 <idnar> haha
21:52:18 * sw17ch rejoices
21:52:18 <idnar> FunctorSalad: except they're often used as quotes
21:52:24 <sw17ch> my old cabal-install is still in tact and works
21:52:37 <pumpkin> in tact?
21:52:37 <idnar> FunctorSalad: like in 'foo of bar'
21:52:38 <sw17ch> cabal install cabal-install --reinstall
21:52:50 <lament> an apostrophe surrounded by letters without whitespace is probably part of a word
21:52:59 <FunctorSalad> mhm
21:53:09 <chrisdone> indeed
21:53:33 <chrisdone> dropQuote = reverse . dropWhile (/='\'') . reverse . dropWhile (=/'\'')
21:53:35 <chrisdone> or w/e
21:53:48 <chrisdone> er, ==, not /=
21:54:04 <pumpkin> Axman6: you on twitta?
21:54:12 <FunctorSalad> using the same " character for both opening and closing quotes on computers has to be the most failed attempt at parsimony ever :)
21:54:41 <chrisdone> ha
21:54:43 <FunctorSalad> since the different typographical quotes would be better for parsing
21:54:53 <FunctorSalad> (different open and close)
21:54:57 <chrisdone> âdid somebody ask for âexpert unicodeââ?
21:55:18 <chrisdone> yeah, none of this \" crap
21:55:41 <dolio> âââ
21:56:01 <chrisdone> ;_;
21:56:02 <FunctorSalad> hmm
21:56:12 <FunctorSalad> ok ;)
21:58:34 <jinjing> @bot
21:58:35 <lambdabot> :)
21:58:35 <lunabot>  :)
21:58:47 <dolio> @quote qwe1234
21:58:47 <lambdabot> qwe1234 says: which is why talking about 'functional languages' as such is a wankfest for clueless people without a functioning thought mechanism.
21:59:34 <FunctorSalad> hmm
21:59:50 <FunctorSalad> @quote qwe1234
21:59:50 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
21:59:55 <FunctorSalad> @quote qwe1234
21:59:56 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
22:00:31 <FunctorSalad> which quote were you looking for? ;)
22:00:34 <FunctorSalad> @quote qwe1234
22:00:35 <lambdabot> qwe1234 says: i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
22:00:42 <dolio> A random one.
22:00:55 <dolio> They're funny.
22:02:58 <chrisdone> preflex: be poppavic
22:02:58 <preflex>  I already climed the ladder and paid the dues, and KNOW better
22:03:09 <sw17ch> sjanssen, upgrading to 6.10 fixes the problem
22:03:26 <Axman6> pumpkin: RE: twitter, no. i got out early ;)
22:03:40 <pumpkin> Axman6: boo
22:03:55 <Taejo> "Given below is an elementary derivation for Shannon entropy, the measure of information. This derivation is different from the one given in Theorem 2 and Appendix 2 of the Shannon paper [Shannon]. The present derivation is somewhat close to the one hinted at in Theorem 4. I did it one evening while doing laundry."
22:03:57 <pumpkin> just for that, I solved another problem :(
22:04:02 <Axman6> but, i recently saw a list of haskell people on twitter, might be worth getting back into ;)
22:04:10 <Taejo> Oleg is in your laundry, deriving your shirts
22:04:14 <idnar> @quote
22:04:14 <lambdabot> bd_ says: [SamB_XP] what is this "release" thing anyway? [bd_] SamB_XP: it's when you disown a project [SamB_XP] bd_: why would I want to do that? [bd_] Well, for example, in case of death.
22:04:32 <Axman6> ha
22:05:49 <lament> @quote
22:05:49 <lambdabot> kilimanjaro says: the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in like
22:05:49 <lambdabot> 10 days!"
22:06:38 <FunctorSalad> ...
22:06:54 <chrisdone> @quote xah lee
22:06:54 <lambdabot> No quotes for this person. Maybe you made a typo?
22:06:56 <chrisdone> :(
22:07:03 <gwern> @quote xah
22:07:04 <lambdabot> No quotes match. Take a stress pill and think things over.
22:07:43 <ski_> @quote xahlee
22:07:43 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
22:07:46 <Olathe> Ahh, have a nice solution to Euler #24 :)
22:07:51 <dolio> @quote qwe1234 than Haskell
22:07:51 <lambdabot> qwe1234 says: For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
22:08:32 <Nafai> WTF
22:08:56 <Gracenotes> any main quote?
22:08:58 <Gracenotes> @quote qwe1234
22:08:58 <lambdabot> qwe1234 says: check out 'complexity theory', it's all there.
22:09:31 <dolio> Heh. It's all there.
22:10:28 <lament> @quote
22:10:28 <lambdabot> zeeeeeee says: so aside from the refactoring, there's no other (major) improvements i can make to my program
22:10:47 <lament> @quote python
22:10:47 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
22:10:59 <jml> heh heh
22:11:12 <Olathe> Euler 24 spoiler: http://hpaste.org/13114
22:11:18 <lament> they do, right? Secretly in their underground bunker in Switzerland
22:11:20 <lament> @quote python
22:11:20 <lambdabot> sieni says: python, like php, is just training wheels without the bike
22:12:02 <Elly> how does one debug a stack overflow in ghci?
22:12:09 <dolio> > scanl (*) 1 [1..]
22:12:10 <Gracenotes> Olathe: I'm sure there are hundreds of Euler spoilers all over the internet, heh
22:12:10 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
22:12:15 <jml> spoken like someone who's never been forced to maintain a million line PHP app.
22:12:19 <Olathe> Gracenotes: Probably :)
22:12:21 <dolio> > 1 : scanl1 (*) [1..]
22:12:22 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
22:13:45 <Elly> ahh!
22:13:47 <Elly> that was stupid
22:13:47 <roconnor> In an Hue-Saturation-Lightness library, should Hue be valued in degrees or radians?
22:13:53 <Elly> didn't indent my show implementation
22:15:10 <solrize> i just pasted my version on that olathe
22:15:36 <^Someone^> roconnor, wouldn't radians be a bad idea
22:15:47 <Pseudonym> roconnor: Whatever CIE uses.
22:16:12 <solrize> what's with the factorials?!!
22:16:13 <^Someone^> Hm, Pseudonym... The same one here? http://blog.tmorris.net/agile-is-falling-like-religions-do/#comment-25365
22:16:17 <Taejo> radians seem like a bad idea if you're doing basic stuff
22:16:38 <Pseudonym> Someone: Yes.
22:17:03 <^Someone^> Hehe, okay. Was reading that just a short while ago
22:17:12 <Olathe> solrize: It's from a Euler problem.
22:17:29 <solrize> yeah, i did that problem but i didn't use any factorials
22:17:39 <Pseudonym> Oh, looks like Tony responded some time in the last month.
22:17:40 <Olathe> solrize: Ahh, you can use factorials to skip work.
22:17:45 <solrize> h,,
22:17:46 <solrize> hmm
22:17:54 <solrize> ic
22:18:00 <solrize> i mean, ok
22:18:26 <mpeter> hey Pseudonym
22:19:02 <Gracenotes> okay... writing the >>= function for the ((->) t) monad... yay fun
22:19:15 <pumpkin> :o
22:19:16 <Gracenotes> [as part of an exercise]
22:19:18 <mpeter> Gracenotes: what've you got
22:19:19 <solrize> olathe, yeah, yours is a lot faster than mine and gets the same answer
22:19:31 <Elly> @hoogle Int -> Integer
22:19:32 <lambdabot> Prelude toEnum :: Enum a => Int -> a
22:19:32 <lambdabot> Data.Bits bit :: Bits a => Int -> a
22:19:32 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
22:19:43 <idnar> I thought Hue was normally either 0.0-1.0 or 0-255?
22:19:46 <solrize> right, factorials, makes sense
22:19:52 <mpeter> http://i35.tinypic.com/15ceonk.png
22:19:52 <Gracenotes> mpeter: nothing yet :) but I have return a = (\_ -> a)
22:19:56 <mpeter> you like my haskell logo? ;)
22:20:29 <Megzlna> I want to continue learning Haskell
22:20:35 <Gracenotes> mpeter: I'd like to think it has... structure
22:20:38 <Gracenotes> of some sort
22:20:40 <solrize> mpeter, hmm, nice pic but doesn't seem like a logo
22:20:41 <Megzlna> But this is driving me nuts
22:20:53 <mpeter> it's my kind of logo
22:20:57 <mpeter> hard to look at
22:21:34 <ozy`> mpeter: so you're the one!
22:21:35 <mpeter> of course the consensus seems to be that the number of vertices contained in the logo is inversely proportional to how logo-like it is ;)
22:21:41 <^Someone^> Reminds me too much of a bathroom drain-filter : /
22:21:48 <pumpkin> lol
22:21:52 <^Someone^> (With hair and dirt) v.v
22:21:56 <mpeter> doesn't haskell remind you of that?
22:21:57 <^Someone^> Sorry, it really does : |
22:22:03 <^Someone^> Um, no, mpeter
22:22:03 <^Someone^> Lol
22:22:15 <ozy`> perl reminds me of that
22:22:19 <ozy`> haskell, not so much
22:22:32 <mpeter> haskell is like the crazy dadaist perl
22:22:34 <pumpkin> OOOH YEAH
22:22:37 <mpeter> whereas perl is
22:22:38 <mpeter> i dunno
22:22:40 <mpeter> cubism
22:22:57 <roconnor> idnar: hue is an angular measurement
22:23:00 <ozy`> ...are you smoking the same haskell I'm smoking?
22:23:06 <mpeter> yes
22:23:14 <mpeter> but i mixed in some 5-meo-dmt
22:23:30 <roconnor> ^Someone^: radians would allow uses to use haskell's trig functions directly
22:23:39 <idnar> roconnor: sure, I'm just saying
22:24:00 <ozy`> mpeter: anyway, my logo can beat up your logo :p http://haskell.org/haskellwiki/Image:Haskell_proceed.png
22:24:19 <mpeter> illuminati--
22:24:21 <Adamant> mpeter: I think you're a little too hyped up on goofballs
22:24:23 <ozy`> bah
22:24:30 <roconnor> http://en.wikipedia.org/wiki/HSL_and_HSV states hue in degrees
22:24:31 <mpeter> i am quite hyped up on goofballs
22:24:38 <Gracenotes> so far, for the ((->) t) monad, I have func >>= tf = (\s -> func (tf s)). haskell ain't liking it. <_<
22:24:45 <lament> ozy`: i like it except for the silly font
22:24:58 <ozy`> lament: I had trouble choosing a font, yeah
22:25:11 <pumpkin> I'm on fire
22:25:15 <lament> is it from land of lisp?
22:25:18 <ozy`> ninjas can't catch you
22:25:21 <ozy`> lament: yes :p
22:25:26 <ozy`> (more or less)
22:25:29 <lament> hehe
22:26:30 <roconnor> > a == a
22:26:32 <lambdabot>   True
22:26:41 <ozy`> > show a
22:26:42 <lambdabot>   "a"
22:26:43 <roconnor> > find b [a,b,c]
22:26:45 <lambdabot>   Couldn't match expected type `a -> Bool'
22:26:49 <ozy`> whoa
22:26:52 <roconnor> > findIndex b [a,b,c]
22:26:53 <lambdabot>   Couldn't match expected type `a -> Bool'
22:27:01 <roconnor> > findIndex (==b) [a,b,c]
22:27:02 <ozy`> show desu
22:27:03 <lambdabot>   Just 1
22:27:04 <ozy`> > show desu
22:27:06 <lambdabot>   Not in scope: `desu'
22:27:09 <ozy`> curses
22:27:19 <roconnor> @hoogle a -> [a] ->  Int
22:27:20 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
22:27:20 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
22:27:20 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
22:27:46 <Olathe> @type a
22:27:48 <lambdabot> Expr
22:28:31 <roconnor> > pi `mod` 1
22:28:33 <lambdabot>   Add a type signature
22:28:38 <roconnor> > pi `mod` 1 :: Double
22:28:40 <lambdabot>       No instance for (Integral Double)
22:28:40 <lambdabot>        arising from a use of `mod' at...
22:28:48 <Olathe> @type mod
22:28:49 <lambdabot> forall a. (Integral a) => a -> a -> a
22:28:52 <ozy`> > (pi `mod` 1) :: Int
22:28:53 <lambdabot>       No instance for (Floating Int)
22:28:53 <lambdabot>        arising from a use of `pi' at <in...
22:28:57 <ozy`> > (pi `mod` 1) :: Double
22:28:58 <lambdabot>       No instance for (Integral Double)
22:28:58 <lambdabot>        arising from a use of `mod' at...
22:29:01 <ozy`> >:|
22:29:07 <roconnor> > trunc pi
22:29:08 <lambdabot>   Not in scope: `trunc'
22:29:09 <Olathe> @type pi
22:29:11 <lambdabot> forall a. (Floating a) => a
22:29:12 <roconnor> > truncate pi
22:29:14 <lambdabot>   3
22:29:23 <roconnor> er
22:29:32 <roconnor> what the other part?
22:29:32 <ozy`> > 3 .|. 4
22:29:33 <lambdabot>   Add a type signature
22:29:37 <Olathe> > pi - fromIntegral (floor pi)
22:29:38 <lambdabot>   0.14159265358979312
22:29:59 <ozy`> > error
22:30:00 <lambdabot>       Overlapping instances for Show ([Char] -> a)
22:30:01 <lambdabot>        arising from a use ...
22:30:05 <ozy`> whoops
22:30:12 <solrize> olathe, http://hpaste.org/13114#a2
22:31:20 <mpeter> can you interface with git such that you can make changes to a revision of the code over the web?
22:31:26 <mpeter> i.e., has anybody done that yet
22:31:37 <mpeter> as in, through HTTP
22:31:42 <mpeter> :O
22:31:50 <Olathe> solrize: Ahh, cool :)
22:32:13 <chrisdone> http://dis.4chan.org/read/prog/1229294713/11,12,13,15,16,17,18
22:32:22 <Olathe> solrize: I think that's quite a bit cleaner in ways than mine.
22:32:41 <mpeter> wtf@code@4chan
22:33:09 <lament> chrisdone: nice
22:34:35 <Gracenotes> hm. so, I'm having a bit trouble for this monad exercise, in which: instance Monad ((->) t) where
22:34:37 <chrisdone> lament: is this histogram better? http://chrisdone.com/haskell/histogram.txt
22:34:40 <Gracenotes>   return a = (\_ -> a)
22:34:41 <solrize> tx
22:34:43 <Gracenotes>   func >>= tf = func . tf
22:34:54 <chrisdone> I'll try pasting the bulk of it into Wordle
22:34:55 <Gracenotes> >>= isn't compiling
22:35:13 <Gracenotes> I'm just sort of guessing and checking, but does anyone know why?
22:35:20 <chrisdone> (Worlde has decent word stops, I believe)
22:35:22 <Gracenotes> I'm getting "Occurs check: cannot construct the infinite type: b = t -> b"
22:35:44 <Gracenotes> When trying to generalise the type inferred for >>=
22:36:00 <lament> chrisdone: nice, i guess ideally you want to keep the most common capitalization of each word
22:36:14 <lament> but that's not essential
22:36:17 <Olathe> @type (>>=)
22:36:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:36:28 <chrisdone> lament: indeed
22:36:36 <chrisdone> oh god, haha. there are tonnes of variations of unsafe*
22:37:00 <Gracenotes> oh, have I confused the order, hm
22:37:41 <chrisdone> http://hpaste.org/13115
22:37:50 <Gracenotes> Olathe: still getting the same error after switching around everything the right way
22:38:00 <lament> chrisdone: lol
22:38:08 <Olathe> @index unsafeatanyspeed
22:38:09 <lambdabot> bzzt
22:38:23 <chrisdone> unsafecompareinfinitedatastructures
22:38:25 <chrisdone> I am lol'ing
22:38:26 <Gracenotes> it's from http://blog.tmorris.net/20-intermediate-haskell-exercises/ exercise 9 :/
22:38:33 <chrisdone> this is haskell's best mee
22:38:35 <chrisdone> meme
22:38:36 <Olathe> Gracenotes: I think the type won't allow it.
22:38:54 <chrisdone> unsafecuttheredwire, oh god, hahaha
22:39:01 <Gracenotes> Olathe: is there anything the type will allow in this case?
22:39:54 <chrisdone> unsafeflyblackhelicopter
22:40:03 <Gracenotes> it seems to make perfect sense as I have it. of course, it doesn't quite compile.
22:40:58 <Olathe> Gracenotes: You have x >>= f, x is a monad containing c, f is c -> monad containing d, result is monad containing d.
22:41:41 <Gracenotes> in this case, a monad is (t -> w)
22:41:59 <Olathe> Sure, but what is the type of f . x ?
22:42:50 <Gracenotes> t -> (t -> d), no?
22:43:30 <mpeter> > tapPhone dons
22:43:32 <lambdabot>   "OK, Phillipa, I'll meet you at the National Mall at 12:30, and then we'll ...
22:43:39 <mpeter> @more
22:43:49 * mpeter scowls
22:44:12 <lament> > dons
22:44:13 <lambdabot>   [109,109,98,88,33,122,115,115,98,77,33,109,109,106,108,33,109,109,40,102,12...
22:44:17 <Gracenotes> and putting a t into that will yield a ((->) d) monad of type t
22:44:19 <mpeter> > reverse (take 25 (reverse (tapPhone dons)))
22:44:21 <lambdabot>   "hen we'll kill Larry Wall"
22:44:22 <Olathe> @type (->) (>>=)
22:44:23 <lambdabot> parse error on input `->'
22:44:27 <Olathe> Hmm...
22:44:38 <mpeter> stupid cheap NSA tapping software
22:44:43 <Olathe> > dons
22:44:45 <lambdabot>   [109,109,98,88,33,122,115,115,98,77,33,109,109,106,108,33,109,109,40,102,12...
22:44:45 <Gracenotes> @type ((->) t) (>>=)
22:44:47 <lambdabot> parse error on input `->'
22:44:48 <lament> > map chr dons
22:44:49 <lambdabot>   "mmbX!zssbM!mmjl!mm(fx!ofiu!eob!-14;32!ub!mmbN!mbopjubO!fiu!ub!vpz!uffn!mm(...
22:44:54 <Olathe> O-o
22:44:58 <Gracenotes> I'm not so sure if it's defined normally
22:45:05 <teko> @src unfold
22:45:05 <lambdabot> Source not found. Are you on drugs?
22:45:08 <teko> @src unfoldl
22:45:09 <lambdabot> Source not found.
22:45:10 <Olathe> > length $ tapPhone dons
22:45:12 <lambdabot>   89
22:45:16 <Olathe> > length $ dons
22:45:18 <lambdabot>   89
22:45:30 <lament> there's a lot of 'm' in dons
22:45:43 <mpeter> you're telling me
22:45:53 <lament> @src tapPhone
22:45:53 <lambdabot> Source not found. My pet ferret can type better than you!
22:46:00 <roconnor> @check \x -> floor x == fst (properFraction x)
22:46:02 <lambdabot>   "Falsifiable, after 1 tests:\n-2.5\n"
22:46:02 <lament> @src I.tapPhone
22:46:03 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:46:16 <mpeter> @type tapPhone
22:46:17 <lambdabot> [Int] -> [Char]
22:46:22 <lament> > tapPhone [109, 109, 109, 109, 109]
22:46:24 <lambdabot>   "lllll"
22:46:30 <Olathe> > tapPhone [0..10]
22:46:32 <lambdabot>   "\t\b\a\ACK\ENQ\EOT\ETX\STX\SOH\NUL* Exception: Prelude.chr: bad argument
22:46:34 <lament> > tapPhone [109, 110, 111, 112, 113]
22:46:35 <lambdabot>   "ponml"
22:46:37 <roconnor> @check \x -> truncate x == fst (properFraction x)
22:46:38 <lambdabot>   "OK, passed 500 tests."
22:46:39 <lament> ah.
22:46:42 <Olathe> > map ord $ tapPhone [0..10]
22:46:44 <lambdabot>   [9,8,7,6,5,4,3,2,1,0,* Exception: Prelude.chr: bad argument
22:46:58 <roconnor> map truncate [-1.5,-1..1.5]
22:46:58 <Olathe> > map ord $ tapPhone [0..100]
22:46:59 <lambdabot>   [99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75...
22:47:00 <roconnor> > map truncate [-1.5,-1..1.5]
22:47:01 <lambdabot>   [-1,-1,0,0,0,1,1]
22:47:06 <Olathe> Ahh.
22:47:23 <roconnor> > properFraction (-1.5)
22:47:24 <lambdabot>   (-1,-0.5)
22:47:49 * mpeter has an idea...
22:47:52 <Gracenotes> i herd you leik reverse engineering
22:47:57 <lament> > map ord $ [tapPhone 100..200]
22:47:58 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
22:48:00 <lament> er.
22:48:07 <lament> > map ord $ tapPhone [100..200]
22:48:09 <lambdabot>   [199,198,197,196,195,194,193,192,191,190,189,188,187,186,185,184,183,182,18...
22:48:32 <mpeter> this might take a while
22:48:42 <teko> is there a standard unfold func??
22:48:51 * mpeter does some regex magic
22:48:57 <mpeter> i have something fun for you guys to whip up ;)
22:49:07 <Gracenotes> > maximum dons
22:49:09 <lambdabot>   122
22:49:15 <Gracenotes> > dons
22:49:16 <lambdabot>   [109,109,98,88,33,122,115,115,98,77,33,109,109,106,108,33,109,109,40,102,12...
22:49:24 <Olathe> > reverse.map (chr.(subtract 1)) $ dons
22:49:25 <lambdabot>   "OK, Phillipa, I'll meet you at the National Mall at 12:30, and then we'll ...
22:50:48 <lament> and that's why you should encrypt your phone conversations.
22:50:51 <teko> @src subtract
22:50:52 <lambdabot> subtract x y = y - x
22:51:06 <Gracenotes> hm...
22:51:09 <Gracenotes> hm.
22:51:11 <Olathe> > reverse.map (chr.(-1)) $ dons
22:51:13 <lambdabot>       No instance for (Num (Int -> Int))
22:51:13 <lambdabot>        arising from a use of `negate...
22:51:31 <mpeter> > (reverse reverse.map (chr.(subtract 1)) $ (reverse dons))
22:51:33 <lambdabot>   Couldn't match expected type `[a]'
22:51:34 <Olathe> Doesn't work because UNARY MINUS !!
22:51:37 <mpeter> > (reverse (reverse.map (chr.(subtract 1)) $ (reverse dons))
22:51:37 * Olathe grumbles.
22:51:38 <lambdabot>   <no location info>: parse error on input `;'
22:51:41 <mpeter> > (reverse (reverse.map (chr.(subtract 1)) $ (reverse dons)))
22:51:43 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
22:51:46 <mpeter> screw you
22:51:54 <mpeter> > reverse (take 60 (reverse (tapPhone dons)))
22:51:55 <lambdabot>   "Don Stewart"
22:52:01 <mpeter> ????
22:52:09 <mpeter> who redefined dons
22:52:10 <Olathe> > dons
22:52:12 <lambdabot>   "Don Stewart"
22:52:16 <pumpkin> lol
22:52:21 <lament> boo.
22:52:38 <mpeter> > reverse (take 60 (reverse (tapPhone dons)))
22:52:40 <lambdabot>   Not in scope: `tapPhone'
22:52:49 <mpeter> > reverse (take 60 (reverse (tapPhone dons)))
22:52:50 <lambdabot>   "t the National Mall at 12:30, and then we'll kill Larry Wall"
22:53:06 <mpeter> > tapPhone dons
22:53:07 <lambdabot>   "OK, Phillipa, I'll meet you at the National Mall at 12:30, and then we'll ...
22:53:29 <Gracenotes> scary.
22:53:46 <Olathe> dons needs better encryption.
22:55:13 <mpeter> somebody remind me how randomGen works?
22:55:27 <Olathe> @type randomGen
22:55:29 <lambdabot> Not in scope: `randomGen'
22:55:39 <mpeter> @hoogle randomGen
22:55:40 <lambdabot> System.Random class RandomGen g
22:56:39 <chrisdone> here's Wordle's interpretation: http://chrisdone.com/haskell-wordle.png
22:57:09 <Gracenotes> @pl \func tf = (\s -> (func (tf s)) s)
22:57:09 <lambdabot> (line 1, column 10):
22:57:09 <lambdabot> unexpected "="
22:57:09 <lambdabot> expecting pattern or "->"
22:57:19 <Gracenotes> eek.
22:57:25 <mpeter> that's nice, wordle
22:57:29 <teko> @src unfoldr
22:57:29 <lambdabot> unfoldr f b  = case f b of
22:57:29 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:57:29 <lambdabot>    Nothing        -> []
22:57:49 <Gracenotes> @pl (\func tf = (\s -> (func (tf s)) s))
22:57:50 <lambdabot> (line 1, column 11):
22:57:50 <lambdabot> unexpected "="
22:57:50 <lambdabot> expecting pattern or "->"
22:58:08 <pumpkin> does anyone have msieve running on linux?
22:58:51 <mpeter> finding word lists is hard
22:59:44 <roconnor> chrisdone: use one type, think like haskell ?
22:59:56 <teko> @src repeat
22:59:57 <lambdabot> repeat x = xs where xs = x : xs
23:00:18 <roconnor> using one type is thinking like scheme!
23:00:41 <lament> chrisdone: that's a cute way of bypassing the case issue
23:01:25 <Gracenotes> @hoogle (a -> t -> b) -> (t -> a) -> (t -> b)
23:01:25 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
23:01:25 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
23:01:25 <lambdabot> Distribution.ParseUtils liftField :: (b -> a) -> (a -> b -> b) -> FieldDescr a -> FieldDescr b
23:02:14 <roconnor> heh, there is a little dons next ot the T in think
23:03:44 <jeff123> is there anyone here who could help me understand why taking the head of my list causes an infinite loop? [ x | x <- [2..], primeIn primes x]
23:03:52 <mpeter> > randomR (1,5)
23:03:53 <lambdabot>       Overlapping instances for Show (g -> (t, g))
23:03:53 <lambdabot>        arising from a use ...
23:03:54 <Gracenotes> wow, it worked, now I just need to find out why the hell it did, and what the heck it means :/
23:04:08 <mpeter> > randomR (1,5) randomGen
23:04:09 <lambdabot>   Not in scope: `randomGen'
23:04:12 <mpeter> bah
23:04:27 <jeff123> here's the rest of the code (it's short) http://pastebin.com/m2bd31e62
23:05:03 <mpeter> @hoogle randomGen
23:05:04 <lambdabot> System.Random class RandomGen g
23:05:13 <jeff123> I'd try 2 : [ x | x <- [3..], primeIn primes x] but I'm afraid of it locking up my computer again while it tries to allocate memory
23:09:57 <mpeter>  > unwords [n|n<-bigwords,'s' `elem` n] ++ "!!!!"
23:10:10 <mpeter> > unwords [n|n<-bigwords,'s' `elem` n] ++ "!!!!"
23:10:12 <lambdabot>   "across adjustment advertisement against almost amusement answer apparatus ...
23:10:18 <mpeter> > unwords [n|n<-bigwords,'t' `elem` n] ++ "!!!!"
23:10:20 <lambdabot>   "about account act addition adjustment advertisement after against agreemen...
23:10:33 <lament> > length bigwords
23:10:34 <lambdabot>   44
23:11:17 <mpeter> i have a more elegant function coming
23:12:08 <jeff123> ok I fixed it, the 2 : [...] version works
23:12:19 <jeff123> just gotta fix my prime generator a little
23:12:20 <Gracenotes> great, now I have no idea what to do with the Monad ((->) t) class
23:12:31 <Gracenotes> any applications anyone knows of?
23:12:43 <cygnus_> > [ 1 .. ]
23:12:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:13:07 <cygnus_> > [ 1 .. 2]
23:13:08 <lambdabot>   [1,2]
23:13:09 <mpeter> http://wordweb.info/developer/ordering.html
23:13:10 <mpeter> assholes
23:13:27 <mpeter> > [1,2362..22]
23:13:29 <lambdabot>   [1]
23:13:32 <mpeter> > [1,2362..22232535]
23:13:34 <lambdabot>   [1,2362,4723,7084,9445,11806,14167,16528,18889,21250,23611,25972,28333,3069...
23:13:55 <mpeter> > [1,2362..2363]
23:13:57 <lambdabot>   [1,2362]
23:14:07 <solrize> @goo mptc
23:14:13 <lambdabot> http://www.mass.gov/?pageID=eopsagencylanding&L=3&L0=Home&L1=Public+Safety+Agencies&L2=Municipal+Police+Training+Committee+(MPTC)&sid=Eeops
23:14:13 <lambdabot> Title: Municipal Police Training Committee (MPTC) - Executive Office of Public Safety
23:14:17 <solrize> bah
23:14:22 <solrize> what's mptc?
23:14:34 <solrize> oh
23:14:39 <solrize> multi-parameter type class
23:17:14 <mpeter> there are MySQL/PGSQL bindings for haskell, right?
23:17:24 <Gracenotes> > (return 2 >>= (\num -> (\item -> num ^ item )) >>= (\num -> (\item -> num - item))) 5
23:17:26 <lambdabot>   27
23:17:33 <solrize> mpeter, there are several, i dunno what's preferred these days
23:19:15 <Gracenotes> > (return 2 >>= (\x -> \y -> x ^ y )) >>= (\x -> \y -> x - y))) 10
23:19:16 <lambdabot>   <no location info>: parse error on input `)'
23:19:24 <Gracenotes> > (return 2 >>= (\x -> \y -> x ^ y )) >>= (\x -> \y -> x - y)) 10
23:19:25 <lambdabot>   <no location info>: parse error on input `)'
23:19:32 <Gracenotes> argh. nvm.
23:20:52 <Gracenotes> > (return 2 >>= (\num -> \item -> num ^ item ) >>= (\num -> \item -> num - item)) 4
23:20:53 <lambdabot>   12
23:25:17 <Megzlna> Haskell is dead to me now
23:26:56 <Megzlna> just wrote a letter to simon p.j to say how pissed i am
23:27:09 <wli> Megz1na: How so?
23:27:28 <Olathe> wli: This is like the third time today that Megzlna has quit.
23:27:33 <Megzlna> I found out that record fields are global
23:27:39 <Megzlna> no, Olathe
23:27:53 <Megzlna> I've been learning nonstop
23:27:55 <Megzlna> my motive is gone
23:28:25 <wli> Variant subtyping is vastly more useful.
23:28:36 <Megzlna> wli: ?
23:29:09 <wli> Megz1na: data F t = F1 t | F2 t | F3 | ...
23:29:13 <solrize> ?????
23:29:24 <mpeter> oh man
23:29:29 <mpeter> pomegranate ice cream is amazing
23:29:34 <Megzlna> I don't follow, wli
23:29:44 <Gracenotes> > Just (Just 4) >>= id
23:29:45 <lambdabot>   Just 4
23:29:48 <wli> Megz1na: data G t = F1 t | F2 t ... Fn | G1 t | G2 t | G3 t ...
23:30:12 <Megzlna> how does that allow you to do...
23:30:13 <wli> Megz1na: G is a subtype of F because it has all of F's cases.
23:30:14 <Gracenotes> @hoogle Monad m => m (m a) -> m a
23:30:14 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
23:30:14 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
23:30:14 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
23:30:59 <Gracenotes> @src join
23:31:00 <lambdabot> join x =  x >>= id
23:31:03 <Gracenotes> :D
23:31:07 <Megzlna> data Vector3 = Vector3 { x :: Float, y :: Float, z :: Float }  data Vector2 = Vector2 { x :: Float, y :: Float }
23:31:54 <Megzlna> or even
23:32:08 <mpeter> join (map (\x->[x*1,x*2,x*3,x*4] [1..30])
23:32:11 <mpeter> > join (map (\x->[x*1,x*2,x*3,x*4] [1..30])
23:32:12 <lambdabot>   <no location info>: parse error on input `;'
23:32:26 <mpeter> > join (map (\x->[x*1,x*2,x*3,x*4]) [1..30])
23:32:28 <lambdabot>   [1,2,3,4,2,4,6,8,3,6,9,12,4,8,12,16,5,10,15,20,6,12,18,24,7,14,21,28,8,16,2...
23:32:42 <Megzlna> data Thing = Thing { x :: Int }     data DBconn = DBconn { x :: String }
23:32:47 <Megzlna> 2 unrelated things
23:32:51 <mpeter> [1..30] >>= [1..4]
23:32:54 <mpeter> > [1..30] >>= [1..4]
23:32:55 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
23:33:02 <mpeter> oh ho
23:33:16 <Gracenotes> Megzlna: why in the world would you use 'x' for both, though?
23:33:21 <Gracenotes> descriptive names have their value!
23:33:29 <Gracenotes> (no pun intended)
23:33:32 <Megzlna> Gracenotes: Because it's IRC
23:33:37 <Megzlna> not a real program
23:33:45 <Megzlna> having field members be global is ...absurd
23:33:53 <Megzlna> it discredits the whole language
23:33:53 <mbz> > [1..30] >>= \_ -> [1..4]
23:33:55 <lambdabot>   [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,...
23:33:55 <Gracenotes> Megzlna: they're not global
23:34:10 <Gracenotes> if you're nice to everyone else and make your own module
23:34:13 <mpeter> where \_ means what?
23:34:25 <roconnor> @src const
23:34:26 <Gracenotes> otherwise, you shouldn't blame others if you can't play nice with record names
23:34:26 <lambdabot> const x _ = x
23:34:57 <mpeter> > const 1 3203962039
23:34:58 <lambdabot>   1
23:34:59 <roconnor> mpeter: \_ -> expr is a lambda expression that doesn't use (or name) it's parameter
23:35:09 <mpeter> oh, ok
23:35:13 <mpeter> so it means "do something"
23:35:27 <Megzlna> Grace, it's like finding out your girl/boy friend still lives with their momma, or has a STD, or is in a religious cult
23:35:39 <Gracenotes> > ['a'..'c'] >>= \_ -> [1..3] >>= return (x, y)
23:35:40 <lambdabot>   Couldn't match expected type `[b]'
23:35:50 <Gracenotes> eek.
23:36:23 <wli> Megz1na: I just get banged by them, let whatever's going to come out come out,  and then convince them they
23:36:38 <wli> rMegz1na: they're dumping me if they need to be  dumped.
23:37:22 <Megzlna> <wli> Megz1na: data G t = F1 t | F2 t ... Fn | G1 t | G2 t | G3 t ...
23:37:33 <mpeter> > [1..30] >>= \_ -> ['a'..'z']
23:37:35 <lambdabot>   "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuv...
23:37:40 <wli> Megz1na: Do you get it?
23:37:42 <mpeter> > [1..30] >>= \_ -> ['a'..'b']
23:37:44 <lambdabot>   "abababababababababababababababababababababababababababababab"
23:37:44 <Megzlna> how does that apply to my example?
23:37:57 <mpeter> > [1..30] >>= \_ -> ['b','l','a','h'])
23:37:58 <lambdabot>   <no location info>: parse error on input `)'
23:38:02 <mpeter> > [1..30] >>= \_ -> ['b','l','a','h']
23:38:03 <Gracenotes> oh
23:38:03 <Gracenotes> > ['a'..'c'] >>= \x -> [1..3] >>= \y -> return (x, y)
23:38:03 <Gracenotes> > ['a'..'c'] >>= \x -> [1..3] >>= \y -> return y
23:38:04 <mbz> > ['a'..'c'] >>= \x -> [1..3] >>= \y -> return (x,y)
23:38:05 <lambdabot>   "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbl...
23:38:06 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
23:38:07 <lambdabot>   [1,2,3,1,2,3,1,2,3]
23:38:07 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
23:38:08 <wli> Megz1na: It doesn't. It needs its own example to demonstrate it.
23:38:10 <mbz> oops
23:38:21 <mpeter> > fix ('blah':)
23:38:22 <lambdabot>   <no location info>:
23:38:22 <lambdabot>      lexical error in string/character literal at chara...
23:38:29 <mpeter> > fix ("blah":)
23:38:31 <lambdabot>   ["blah","blah","blah","blah","blah","blah","blah","blah","blah","blah","bla...
23:38:33 <mpeter> > fix ("blah"++)
23:38:35 <lambdabot>   "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbl...
23:38:38 <Megzlna> Ok, I will ask a more general question then
23:38:59 <jeff123> quick question - if I have something that's type IO Bool, how do I get it to just Bool?
23:39:17 <jeff123> like after a "do .... return False", something like that
23:39:24 <mpeter> > length ([1..30] >>= \_ -> ['a'..'b'])
23:39:26 <lambdabot>   60
23:39:33 <wli> jef123: You don't. You bury the thing needing the Bool value inside the IO monad.
23:39:39 <mbz> @hoogle IO Bool -> Bool
23:39:40 <jeff123> bleh, ok
23:39:40 <lambdabot> Foreign unsafePerformIO :: IO a -> a
23:39:40 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
23:39:40 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
23:39:41 <mpeter> talk about useless
23:39:53 <Megzlna> how do you do the most basic requisite of bread and butter programming tasks, grouping together a collection of data as unique names, and passing them around as a single value, and having multiple of them in a module
23:40:02 <Megzlna> without polluting a global namespace
23:40:12 <Megzlna> or without any kind of name clashes
23:40:19 <mpeter> > length ([1..30] >>= \x -> [(1+x)..(2*x)])
23:40:20 <lambdabot>   465
23:40:25 <Megzlna> Haskell can't do the basics
23:40:26 <mpeter> :(
23:40:39 <mpeter> > [1..30] >>= \x -> [(1+x)..(2*x)]
23:40:41 <lambdabot>   [2,3,4,4,5,6,5,6,7,8,6,7,8,9,10,7,8,9,10,11,12,8,9,10,11,12,13,14,9,10,11,1...
23:41:03 <solrize> megzlna perhaps you could learn this stuff more efficiently by reading a book or tutorial
23:41:10 <mpeter> > [1..30] >>= \x -> [(1**x)..(2**x)]
23:41:12 <lambdabot>   [1.0,2.0,1.0,2.0,3.0,4.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,1.0,2.0,3.0,4.0,5....
23:41:21 <mpeter> nifty
23:41:24 <Megzlna> solrize: That's not relevant to my question
23:41:40 <mpeter> > length ([1..1000] >>= \x -> [(1**x)..(2**x)])
23:41:51 <mpeter> don't kill it...don't kill it
23:41:53 <Megzlna> the point is, Haskell cannot do it
23:41:55 <lambdabot>   thread killed
23:42:00 <mpeter> i told you not to kill it!
23:42:02 <Megzlna> has nothing to do with tutorials or books
23:42:09 <mpeter> > length ([1..80] >>= \x -> [(1**x)..(2**x)])
23:42:21 <Gracenotes> you can do it, lambdabot!
23:42:25 <lambdabot>   thread killed
23:42:33 <mpeter> > length ([1..30] >>= \x -> [(1**x),(1.5**x)..(2**x)])
23:42:37 <lambdabot>   22433
23:42:42 <mpeter> > [1..30] >>= \x -> [(1**x),(1.5**x)..(2**x)]
23:42:44 <lambdabot>   [1.0,1.5,2.0,1.0,2.25,3.5,1.0,3.375,5.75,8.125,1.0,5.0625,9.125,13.1875,17....
23:42:58 <mpeter> that is so cool
23:43:22 <Olathe> > kill $ length ([1..30] >>= \x -> [(1**x),(1.5**x)..(2**x)])
23:43:24 <lambdabot>   thread killed
23:43:25 <Megzlna> Not all programs are lists of numbers
23:43:44 <mpeter> yes they are
23:43:45 <Gracenotes> well, if by numbers you mean 0s and 1s...
23:44:07 <mbz> is there the same issue with records in OCaml?
23:44:15 <Megzlna> of course not
23:44:37 <Megzlna> Haskell is the single most retarded language in modern day use when it comes to this
23:44:43 <Megzlna> no other language even has this problem
23:44:55 <mpeter> > foldl (*) 1 ([1..30] >>= \x -> [(1**x),(1.5**x)..(2**x)])
23:44:58 <lambdabot>   Infinity
23:45:06 <mpeter> infinity?
23:45:16 <mbz> > 1/0
23:45:19 <lambdabot>   Infinity
23:45:26 <mbz> > 0/0
23:45:27 <mpeter> at what point do i divide by zero though
23:45:29 <lambdabot>   NaN
23:46:04 <Gracenotes> > 1^(1/0)
23:46:06 <lambdabot>   Add a type signature
23:46:18 <Gracenotes> > 1**(1/0)
23:46:21 <lambdabot>   1.0
23:46:30 <Gracenotes> > .5**(1/0)
23:46:33 <lambdabot>   <no location info>: parse error on input `.'
23:46:40 <Gracenotes> > 0.5**(1/0) --oops :/
23:46:42 <lambdabot>   0.0
23:46:43 <mpeter> > foldl (+) 1 ([1..30] >>= \x -> [(1**x),(1.5**x)..(2**x)])
23:46:44 <Olathe> > infinity
23:46:47 <lambdabot>   4.811644907228442e12
23:46:47 <lambdabot>   * Exception: stack overflow
23:46:52 <mpeter> yay!
23:46:52 <Olathe> > infinity
23:46:56 <lambdabot>   * Exception: stack overflow
23:46:59 <Olathe> O-o
23:47:02 <Olathe> @src infinity
23:47:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:47:33 <Gracenotes> > infinity / infinity
23:47:35 <lambdabot>       No instance for (Fractional Natural)
23:47:35 <lambdabot>        arising from a use of `/' a...
23:47:52 <Olathe> @type infinity
23:47:54 <lambdabot> Natural
23:48:25 <mpeter> ???
23:48:48 <Olathe> I think there's some stupid formal definition of naturals built-in to lambdabot.
23:49:08 <Olathe> So, infinity is something like infinity = succ infinity
23:49:16 <Olathe> @type succ
23:49:19 <lambdabot> forall a. (Enum a) => a -> a
23:49:25 <Olathe> Hmm.
23:50:51 <Gracenotes> > let f nm =  f $ succ nm in f 1
23:51:06 <lambdabot>   thread killed
23:51:10 <osfameron> hmmm, to submit a *talk* on functional pearls to ICFP, you have to send them a *paper* ?
23:51:17 <osfameron> they are two very different things
23:51:18 <Olathe> > Zero
23:51:32 * Olathe knocks on lambdabot.
23:51:33 <osfameron> hey ho, academic conferences must be a very different beast than the type that I'm familiar with :-)
23:51:40 <Olathe> @type Zero
23:51:56 <lambdabot> Not in scope: data constructor `Zero'
23:51:57 <lambdabot>   Not in scope: data constructor `Zero'
23:52:16 <osfameron> that result was so good it had to be given twice
23:56:21 <olsner> @remember augustss ghc had a bug once where it deleted the source file if it had a type error.  Quite sensible, I think.
23:56:21 <lambdabot> It is stored.
23:57:10 <mpeter> ./` found the pieces, you counted them all alone ./` didn't add up, forgot to carry a zero
23:58:39 <mpeter> why doesn't haskell just have a sensible random number generated
23:58:41 <mpeter> generator
23:59:02 <mpeter> @let rollDice = getStdRandom (randomR (1,6))
23:59:04 <lambdabot>  Defined.
23:59:10 <mpeter> > rollDice
23:59:15 <lambdabot>   * Exception: "<IO Integer>"
23:59:28 <mpeter> god damn they crippled his IO
23:59:52 <osfameron> I found working with random numbers quite painful too
23:59:57 <osfameron> apparently you get used to it :-)
