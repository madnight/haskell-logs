00:01:17 <mmorrow> , [$tyQ|  id  |]
00:01:23 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
00:01:56 <mmorrow> though my fan died for a second there
00:01:59 <mmorrow> *thought
00:01:59 <jml> is there a haskell convention for naming what other languages might call global constants?
00:02:51 <Cale> jml: I name them like any other values
00:03:00 <mmorrow> jml: closest thing i've seen to that is first letter small, rest CAPS
00:03:08 <mmorrow> iMACONST
00:03:14 <jml> Cale, mmorrow: thanks.
00:03:30 <jml> I think I'd prefer naming them like regular values
00:03:52 <sjanssen> mmorrow: though that is generally just for FFI bindings that can't use the real name
00:04:04 <mmorrow> yeah, me to. although that other way does certainly distinguish tHEM
00:04:15 <sjanssen> eg. in C it is XK_a is xK_a in Haskell
00:04:30 <mmorrow> sjanssen: yeah, i've mostly only seen it in ghc
00:05:01 <ksf> I'd prefer _XK_a
00:06:01 <sjanssen> ksf: typically a leading _ is used for unused variables
00:06:23 <ksf> I comment those out.
00:06:34 <sjanssen> I mean unused variables in a case
00:07:35 <ksf> either I bind them to normal names or just use _, I'm not going to be arsed to write something I have to edit to use.
00:08:29 <sjanssen> well, GHC will give a warning about unused variables, but it won't if you prefix it with _
00:08:52 <sjanssen> so you can document the variable while avoiding any warnings about non-use
00:09:03 <ksf> you've got a point there.
00:09:55 <cjs> Anybody have any thoughts on this error? http://hpaste.org/12926
00:10:05 <sjanssen> probably the best thing is to give a reasonable name and capitalization to the variable
00:10:07 <cjs> Oh, crud, forget it. I just realized the issue.
00:10:15 <ksf> the fun thing is that haskell's OTBS invades my C code.
00:10:27 <sjanssen> for example: import Graphics.X11.Keysyms as Key; Key.a
00:10:29 <ksf> that is, leading ",".
00:10:43 <sjanssen> OTBS?
00:10:52 <ksf> One True Brace Style
00:11:07 <sjanssen> ah yes, I know what you mean
00:11:16 <sjanssen> I've come to love leading ,
00:11:42 <ksf> maybe I should try leading ";", just for kicks.
00:12:11 <sjanssen> sure, if you want future editors of your code to hate you :)
00:12:59 <ksf> I've got ages of positive karma regarding that stuff.
00:14:39 <cjs> Actually, I've seen that used for do blocks.
00:14:40 <ksf> "wait... let's generate a map: Repeatedly generate maps, throw thousands of them away and stop as soon as we stumble upon a valid one by accident"
00:15:03 <cjs> It doesn't look so bad, though it's of course not good to put unnecessary ink on the page.
00:15:53 <ksf> you know, code that is so bad it's elegant again, by informally introducing the amb operator.
00:35:31 <cjs> Hm. So I thought I had a great idea about how to do this, but now I'm confused.
00:36:37 <cjs> I'm making something an instance of Data.Binary so I can efficiently serialize it. However, the serialized format includes an MD5 digest of the contents, appended to the contents.
00:36:58 <cjs> I was thinking I could update the MD5 for each of the various pieces of this as I put them.
00:37:54 <cjs> But now I'm not quite clear how. It almost seems as if I need to change Data.Binary itself, in order to re-use all of the instances of it.
00:38:21 <pumpkin> why md5 and not a simpler checksum?
00:39:35 <olsner> or let restOfData = runPut put (...); put (checksum restOfData)
00:39:56 <cjs> It's primary purpose is not actually as a checksum, it's as a transaction ID.
00:40:35 <pumpkin> ah
00:40:44 <pumpkin> hmm
00:41:03 <cjs> olsner: yes, I'm doing that now, but it seemed more elegant to do it as one goes along.
00:41:16 <cjs> I also thought it might be more efficient, but thinking about it now, I'm having grave doubts about that.
00:42:53 <olsner> if the data is smallish it's probably more efficient to serialize and checksum in different steps
00:43:34 <cjs> Actually, there are other interface issues, too. For example, dealing with get; it really needs to return Either Transaction Transaction, to communicate md5 failing to match or match the data themselves.
00:43:41 <cjs> s/md5/the digest/
00:44:48 <cjs> Actually, there are various other errors, too. Really, exposing this to the world as an instance of Binary is rather uninteresting.
00:46:17 <redditbot> Why classic FRP does not fit interactive behavior
00:50:02 <ksf> I feel like I'm using gl for the first time.
00:50:15 <ksf> I apperently get stuff to display, but can't see it.
00:50:27 <ksf>   anim3 $ (pure.pure) $ materialG (flat $ rgb 255 255 255) $ flatG $ utext "hello"
00:55:02 * ksf smacks redditbot
00:55:09 <ksf> give me a link next time, will you?
00:55:14 <solrize> @hoogle permutat
00:55:15 <lambdabot> package permutation
00:55:16 <ksf> http://conal.net/blog/posts/why-classic-frp-does-not-fit-interactive-behavior/
00:56:19 <conal> ksf: thanks for the plug.  two more posts on the way.  i one rambly long one and split it in three pieces.
01:04:22 <cjs> Darn, Conal, aren't you supposed to be *promoting* FRP? :-)
01:05:30 <osfameron> what's neoclassical frp?
01:05:34 <conal> cjs: i'm *improving* FRP.
01:05:44 <conal> cjs: then i'll get back to promoting it.
01:06:05 <cjs> Cool.
01:06:13 <conal> osfameron: maybe Reactive, i.e., explicit behaviors but with modern type class interfaces.
01:06:53 <conal> i've known about these FRP problems for a long time but haven't done a good job at conveying them.
01:08:33 <jml> can you define named functions inside functions in haskell?
01:08:47 <ksf> they're called let- or where-bindings.
01:11:46 <BeelsebobWork> conal: I'm playing a little with a Reactive example, and I remember you mentioning that it should be able to deal with getting precise times for collisions between objects, but I'm having trouble putting together such an Event
01:11:55 <BeelsebobWork> don't suppose you have any insight into how I should approach this?
01:12:02 <BeelsebobWork> (atm, I'm trying to do pong correctly)
01:14:04 <conal> BeelsebobWork: i'd love to help.  right now i'm touching up another blog post before going to bed.  eep -- it's 1:15am.
01:14:11 <BeelsebobWork> no probs
01:14:50 * ksf remembers doing similar stuff, filling pages of a4 paper with reductions of equations, giving up after finding a mistake that was introduced one and a half page before and settled to learn a bit of mathematica.
01:15:00 <BeelsebobWork> heh
01:15:16 <ivanm> can someone _please_ stop lambdabot from giving me the same message over and over again?
01:18:33 <Asztal> lambdabot: bad bot
01:19:32 <Zao> ivanm: Write correct code?
01:19:43 <sjanssen> @flush
01:19:50 <sjanssen> ivanm: that might fix it
01:19:53 <ivanm> sjanssen: thank you! thank you! thank you!
01:19:57 <sjanssen> ivanm: how old is the message?
01:24:24 <ivanm> sjanssen: more than 8d agao :s
01:30:49 <mmorrow> i was just thinking it'd be possible to auto-derive the necessary newtype (which serves as the "coercion") for an infinite type directly from ghc's error msg ;)
01:31:13 <mmorrow> @type let go f x = let (y, g) = f x in go g y
01:31:14 <lambdabot> <no location info>:
01:31:14 <lambdabot>     not an expression: `let go f x = let (y, g) = f x in go g y'
01:31:29 <mmorrow> @type let go f x = let (y, g) = f x in go g y in go
01:31:30 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> (t2, t)
01:31:30 <lambdabot>       Expected type: t -> t2 -> t3
01:31:30 <lambdabot>       Inferred type: (t1 -> (t2, t)) -> t1 -> t3
01:31:43 <mmorrow> newtype A t1 t2 = A {unA::t1 -> (t2, A t1 t2)}
01:31:55 <mmorrow> go f x = let (y, g) = f x in go (unA g) y
01:32:05 <mmorrow> forall t1 t. (t1 -> (t1, A t1 t1)) -> t1 -> t
01:32:07 <mmorrow> :)
01:34:45 <opqdonut> mmorrow: wow, where did that t come from :D
01:37:08 <mmorrow> opqdonut: from wanting a lot of types like that and writing newtype wrappers and also reading about newtypes in ghc that made me make the connection
01:38:05 <mmorrow> ignore that that sentence was extremely convoluted and runon ;)
01:38:13 <opqdonut> yeah I see
01:38:17 <mmorrow> heh
01:38:32 <opqdonut> ah, the result type is t because that will never return?
01:38:47 <mmorrow> exactly
01:38:53 <opqdonut> (heh, I can see a haskell IDE in the future asking: would you like to newtype this?)
01:39:02 <mmorrow> well, with that particular newtype it'll never return, but if you do:
01:39:30 <opqdonut> yeah yeah
01:39:46 <mmorrow> data A a b = A b | B (a -> (b, A a b))
01:39:59 <mmorrow> (or something)
01:41:09 <mmorrow> i think it'd be amusing to have lunabot check every error msg for "cannot construct the infinite type: <type here>", then if found, parse the type and spit out a newtype or data decl for it
01:41:34 <mmorrow> or even different variations on what it could be
01:41:42 <mmorrow> like the above two As
01:41:57 <mmorrow> <opqdonut> (heh, I can see a haskell IDE in the future asking: would you like to newtype this?)
01:42:10 <mmorrow> hah, i didn't see that line until after i wrote that
01:42:16 <mmorrow> same page
01:42:26 <mmorrow> (we're on)
01:43:23 <mmorrow> @type let y f = (\x -> f (x x)) (\x -> f(x x))
01:43:25 <lambdabot> <no location info>:
01:43:25 <lambdabot>     not an expression: `let y f = (\x -> f (x x)) (\x -> f(x x))'
01:43:25 <mmorrow> @type let y f = (\x -> f (x x)) (\x -> f(x x)) in y
01:43:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
01:43:27 <lambdabot>     Probable cause: `x' is applied to too many arguments
01:43:27 <lambdabot>     In the first argument of `f', namely `(x x)'
01:44:14 <mmorrow> hmm
01:44:34 <ivanm> Axman6: didyou get an email from fishpond re RWH?
01:45:13 <quicksilver> conal: I've found a memory leak which the behaviour comonad would solve! ;)
01:45:25 <quicksilver> conal: I seem doomed to discover the same stuff as you, N months later
01:45:31 <quicksilver> although N seems to be reducing.
01:46:13 <jeltsch> Hello, does anyone know where to look for operator fixities? Especially, whatâ€™s the fixity of ^>> and >>^ from Control.Arrow?
01:46:18 <conal> quicksilver: :)  hopefully N will go negative soon.
01:46:55 <mmorrow> newtype Y a = Y (Y a -> a)
01:47:08 <mmorrow> maybe
01:47:12 <quicksilver> conal: basically if "foo" is a top-level Behaviour, and you construct an Event (Behaviour a) mentioninig foo
01:47:18 <jml> if I want to give a particular type of map from strings to strings a domain-specific name, how wolud I do it?
01:47:48 <quicksilver> something like fmap (\e -> snapshotWith (*) foo e) (someEvent)
01:47:56 <quicksilver> then the closure is hanging onto the 'head' of foo
01:48:01 <quicksilver> and will keep doing so for ever.
01:48:07 <quicksilver> massive memory leak ensues.
01:48:18 <quicksilver> What you need is a Behaviour (Behaviour a) which is a 'pre-aged' foo
01:48:36 <quicksilver> jeltsch: :i in ghci will tell you
01:48:40 <quicksilver> jeltsch: the haddock should, too
01:49:00 <mmorrow> jeltsch: do in ghci> :info (^>>)
01:49:08 <mmorrow> or just ghci> :i (^>>)
01:49:21 <mmorrow> it'll give you the fixity
01:49:31 <mmorrow> , src '(^>>)
01:49:33 <lunabot>  luna: Not in scope: `^>>'
01:49:42 <jml> currently I have "type Headers = Map.Map String String"...
01:49:43 <mmorrow> hmm, that's in Control.Arrow?
01:50:08 <mmorrow> ah, sure enough
01:50:26 <quicksilver> jeltsch:
01:50:31 <quicksilver> jml: that's one way, yes.
01:50:37 <conal> quicksilver: yep.  you might like my three new posts.
01:50:43 <quicksilver> jml: type synonyms are jsut for convenience, though, they carry no weight.
01:50:55 * conal heads to bed.
01:51:01 <jml> quicksilver: ahh
01:51:05 <ksf> is there a fuzzy logic package?
01:51:06 <quicksilver> conal: I solved another memory leak in snapshot by strictifying my accumR
01:51:10 <jml> quicksilver: is there a weight-carrying alternative?
01:51:15 <ksf> I need to execute a couple of braindumps.
01:51:20 <quicksilver> jml: newtype Headers = Header (Map.Map String String)
01:51:22 <jml> (I'm not sure I need/want one, but it would be nice to know)
01:51:33 <jml> quicksilver: thanks.
01:51:41 <quicksilver> conal: that is, accumR init e = init `seq` .....
01:52:07 <jml> so, it's been a while since I've used such a strongly typed language -- why would I want one over the other?
01:52:21 <quicksilver> at the moment I'm finding memory leaks like bubbles under sticky backed plastic
01:52:28 <quicksilver> push one down and it pops up somewhere else
01:52:33 <quicksilver> I'll probably get the hang of it soon
01:52:40 <quicksilver> jml: at least two reasons
01:52:53 <quicksilver> jml: (1) to hide the implementation from other packages so you can change it later
01:53:13 <quicksilver> jml: (2) to protect yourself against accidentally passing 'just any Map String String' instead of a Headers
01:53:40 <jml> hmm
01:53:45 <quicksilver> jml: on the other hand the disadvantage is a bit more typing.
01:55:30 <jml> quicksilver: thanks.
01:55:52 * jml makes learning faces
01:58:50 <jml> quicksilver: so the "Header" in the example you gave is kind of like a tag.
01:59:27 <quicksilver> jml: yes, to be honest it was a typo, I meant 'Headers'
01:59:30 <joed> dons: om om inte fanns, skulle karringen stanga tjuren
02:00:00 <quicksilver> jml: it's traditional (if slightly confusing) to double up and use constructor name as type name
02:00:43 <jml> quicksilver: it makes sense. saves thinking up (probably crappier) names
02:01:07 <quicksilver> newtype Headers = MkHeaders (Map.Map String String) is another common choice
02:01:54 <quicksilver> and for unwrapping convenience you sometimes see newtype Headers = MkHeaders { unHeaders :: Map.Map String String }
02:02:04 <jml> braces?
02:02:20 <jml> haven't seen those in haskell before.
02:02:25 <quicksilver> the braces introduce record notation which lets you define a selector function 'unHeaders' which unwraps the constructor
02:02:42 <quicksilver> it's rather an "abuse" of record notation, it's ust a short hand way to define the unwrapper
02:02:44 <quicksilver> you could instead write
02:02:50 <quicksilver> unHeaders (MkHeaders m) = m
02:03:02 <jml> cool.
02:03:28 <jml> I was thinking (and typing that), so I guess I'm winning.
02:04:20 <quicksilver> of course if you goal is abstracton you wouldn't export the unwrapper
02:04:26 <quicksilver> (because you're trying to hide the implementation)
02:04:31 <quicksilver> but you could use it internally.
02:05:36 <jml> hmm, so I guess I'd be defining a lot of functions that look like: f (MkHeaders m) = ...
02:06:32 <quicksilver> yes
02:06:37 <quicksilver> or using unHeaders
02:06:42 <quicksilver> it's much of a muchness in many ways
02:06:48 <jml> *nod*
02:06:50 <quicksilver> composing with unHeaders can look neater
02:07:02 <quicksilver> f = M.toList . unHeaders
02:07:15 <quicksilver> (f :: Headers -> [(String,String)])
02:07:29 <quicksilver> but thats no less typing than
02:07:34 <quicksilver> f (MkHeader m) = M.toList m
02:07:42 <quicksilver> well only one or two chars less.
02:07:43 <jml> oh, man, the compose operator...
02:07:47 <jml> (memories flood back)
02:08:04 <quicksilver> f h = M.toList (unHeaders h)
02:08:10 <quicksilver> if you want the non-. version
02:08:13 <jml> quicksilver: and I guess the compiler makes it all look the same?
02:08:19 <quicksilver> yes
02:08:24 <jml> cool.
02:08:24 <quicksilver> small functions like that reliable inline
02:08:28 <quicksilver> so it really makes no difference
02:09:08 <jml> [I was wondering why I was writing so much code like: f (g (x)) ...]
02:09:27 <quicksilver> indeed :)
02:09:39 <quicksilver> there's not much wrong with that style to be honest.
02:10:12 <jml> I guess it comes down to clarity
02:10:58 <quicksilver> but if code naturally pipelines, it's a little easier to edit a pipeline in the form e . f . g . h
02:11:08 <quicksilver> you can, for example, replace "f . g" with something else
02:11:16 <quicksilver> or factor it out into a named function, etc
02:13:22 <jml> *nod*
02:13:41 <quicksilver> doesn't generalise particularly well when various functions have more than one parameter though
02:13:50 <quicksilver> then you have a tree rather than a pipe
02:21:43 <DMKE> how do i write this? uncurry2 :: (a-> b-> c-> d) -> ((a, b), c) -> d
02:23:07 <BeelsebobWork> how about uncurry2 f ((x,y),z) = f x y z
02:23:17 <BeelsebobWork> having said that -- that's not the type sig I'd expect for uncurry2
02:24:57 <DMKE> is it possible to write that in lambda style? i need uncurry2 only once...
02:25:14 <quicksilver> \f ((x,y),z) -> f x y z
02:25:55 <quicksilver> although if you're only using it once I'd proabbly directly substitute the f
02:26:00 <quicksilver> assuming it doesn't vary.
02:26:17 <idnar> @djinn (a-> b-> c-> d) -> ((a, b), c) -> d
02:26:20 <lambdabot> f a ((b, c), d) = a b c d
02:26:22 <BeelsebobWork> @pl \f ((x,y),z) -> f x y z
02:26:23 <lambdabot> (`ap` snd) . (. fst) . (`ap` snd) . (. fst)
02:26:24 <pumpkin> @pl \f ((x,y),z) = f x y z
02:26:25 <lambdabot> (line 1, column 14):
02:26:25 <lambdabot> unexpected "="
02:26:25 <lambdabot> expecting pattern or "->"
02:26:29 <BeelsebobWork> hmm, I'm sure that should be simpler
02:26:33 <pumpkin> @pl \f ((x,y),z) -> f x y z
02:26:34 <lambdabot> (`ap` snd) . (. fst) . (`ap` snd) . (. fst)
02:26:53 <fasta> How do I poke x where in C one would write a->b->x = 1? I am using hsc2hs.
02:27:13 <BeelsebobWork> @type uncurry . uncurry
02:27:15 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
02:27:19 <BeelsebobWork> there we go :)
02:27:23 <BeelsebobWork> thought that should be simpler
02:27:41 <quicksilver> fasta: peek a at the offset of the field b, to get the 'b-Ptr'
02:27:56 <quicksilver> fasta: then poke the 'b-Ptr' at the offset of the field x with the value 1
02:28:04 <DMKE> wow, thanks...! it works very well :-)
02:28:06 <fasta> quicksilver: I was hoping there was an easier way :)
02:28:17 * BeelsebobWork ponders why @pl doesn't know about uncurry
02:28:21 <quicksilver> fasta: you can probably wrap it up in a cunning way ;)
02:28:27 <fasta> quicksilver: I thought of that laborious solution myself already. Thanks
02:28:37 <quicksilver> BeelsebobWork: I think it does
02:28:52 <quicksilver> BeelsebobWork: but I'm not sure how it chooses when it has more than one path it can follow
02:28:53 <BeelsebobWork> @pl (\f (x,y) -> f x y)
02:28:54 <lambdabot> (`ap` snd) . (. fst)
02:29:00 <BeelsebobWork> hmm, okay
02:29:16 <quicksilver> @@ pl djinn type uncurry
02:29:17 <lambdabot>  pl djinn type uncurry
02:29:19 <quicksilver> hmm
02:29:27 <quicksilver> I can never make that work ;)
02:29:29 <BeelsebobWork> @. pl . type uncurry
02:29:30 <lambdabot> Plugin `compose' failed with: Unknown command: "uncurry"
02:29:31 <pumpkin> :t f
02:29:32 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
02:29:36 <BeelsebobWork> oh wait
02:29:40 <BeelsebobWork> @. pl type uncurry
02:29:41 <lambdabot> (line 1, column 18):
02:29:42 <lambdabot> unexpected ">"
02:29:42 <lambdabot> expecting variable, "(", operator or ")"
02:29:53 <BeelsebobWork> @. pl . djinn type uncurry
02:29:55 <lambdabot> f = (`ap` snd) . (. fst)
02:29:58 <BeelsebobWork> there we go
02:30:13 <pumpkin> @. djinn type uncurry
02:30:14 <lambdabot> f a (b, c) = a b c
02:30:32 <pumpkin> can I stick src in there?
02:30:38 <pumpkin> @. pl . src uncurry
02:30:38 <lambdabot> Plugin `compose' failed with: Unknown command: "uncurry"
02:30:45 <pumpkin> @src uncurry
02:30:46 <lambdabot> uncurry f p = f (fst p) (snd p)
02:30:48 <BeelsebobWork> @. pl src uncurry
02:30:49 <lambdabot> (line 1, column 1):
02:30:49 <lambdabot> unexpected end of input
02:30:49 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
02:31:22 <blackh> @pl (foldr (.) id)
02:31:22 <lambdabot> foldr (.) id
02:31:24 <idnar> @. pl src uncurry
02:31:25 <lambdabot> (line 1, column 1):
02:31:25 <lambdabot> unexpected end of input
02:31:25 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
02:31:30 <pumpkin> @. src uncurry
02:31:31 <lambdabot> Plugin `compose' failed with: Unknown command: "uncurry"
02:31:38 <idnar> @pl uncurry f p = f (fst p) (snd p)
02:31:39 <lambdabot> uncurry = (`ap` snd) . (. fst)
02:31:42 <idnar> hmm
02:36:40 <fasta> Is anyone using HSFFIG?
02:39:01 <jml> does '_' as a var prefix mean anything?
02:39:25 <blackh> jml: no - it's just like any other character
02:39:27 <quicksilver> jml: not formally, no
02:39:45 <quicksilver> jml: informally it might be used to indicate that var is unused, or somehow internal or private.
02:39:58 <jml> perfect :)
02:39:59 <jml> thanks.
02:42:48 <mmorrow> opqdonut: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=559#a560
02:43:40 <artyoms> hello people
02:44:12 <artyoms> can anybody tell me the state of affairs of ByteString/Binary and iteratee-based IO
02:44:26 <artyoms> is anybody interested in the latter?
02:45:20 <quicksilver> tibbe certainly is.
02:45:26 <mmorrow> i like the idea of it for sure. it's not really implemented anywhere though, so i guess it's "do-it-yourself" at this point
02:45:29 <quicksilver> (interested)
02:45:42 <mmorrow> yeah, tibbe wrote a webserver that makes use of it. i have the link..
02:45:50 <mmorrow> (called hyena on github)
02:45:57 <zax> Is there some way to see how sum is implemented?
02:46:02 <zax> or any function for that matter
02:46:10 <ivanm> @src sum
02:46:10 <lambdabot> sum = foldl (+) 0
02:46:11 <zax> They seem to have taken that away from hoogle
02:46:17 <zax> oh thanks -:)
02:46:27 <artyoms> yes, I know of Hyena, that's how I got into this :)
02:46:56 <mmorrow> artyoms: have to read oleg's stuff on it?
02:47:30 <artyoms> mmorrow: already did that, not quite sure that I understand all of correctly, though
02:48:17 <mmorrow> nice. (just in case you haven't seen this one: http://www.haskell.org/pipermail/haskell-cafe/2008-November/050436.html)
02:49:01 <artyoms> mmorrow: could you please correct the link? (gives me 404)
02:50:47 <Eelis> artyoms: works for me. don't include the trailing closing parenthesis
02:52:59 <quicksilver> zax: I'm not sure why the 'source' links on the standard library docs have gone away. It's annoying.
02:53:22 <artyoms> Eelis: oops, thanks =)
02:55:29 <zax> It sure is annoying
02:59:42 <quicksilver> well I know roughly why, it's something to do with haddock versions
03:01:55 <blathijs> Is there any way I can do this: "instance Show [Bit] where ..." ? It seems that Haskell only allows type variables to be inside the [], but I want to specifically override the display of a list of (my custom) Bit type...
03:02:45 <quicksilver> blathijs: (1) no, that would break parametricity, and be disgusting, and is an abuse of the 'Show' class
03:02:54 <quicksilver> blathijs: (2) yes, that's what the showList method is for.
03:03:04 <quicksilver> choose your answer depending on how pragmatic you are feeling ;)
03:04:19 <blathijs> quicksilver: I'll go for (2), thanks :-)
03:04:28 * dcoutts does the quickcheck dance
03:04:53 <blathijs> (And look up "parametricity" in teh meantime)
03:05:00 <dcoutts> yay for quickcheck disproving my hypothesis
03:05:33 <dcoutts> are the version ranges "<0" and "< 1 && > 1" equivalent?
03:05:59 <quicksilver> blathijs: Show is for producing valid haskell syntax which can be copy-pasted into test cases. Any other Show instance is punishable by death.
03:06:25 * dcoutts agrees with quicksilver 
03:07:10 <blathijs> quicksilver: Ah, but shouldn't Show be the reverse of Read?
03:07:34 <idnar> Read is for reading valid haskell syntax which can be copy-pasted out of test cases >:)
03:07:41 <quicksilver> quite.
03:07:53 <Beelsebob> blathijs: Read should be the reverse of Show
03:07:54 <quicksilver> yes, Show should be the opposite of Read, but Read should read haskell syntax.
03:07:58 <Beelsebob> the reverse is not necessarily true
03:08:01 <quicksilver> (like read in lisp, I believe)
03:08:09 <roderyk> I have a gtk app where I'm trying to animate something like a spinning plate of circles. For now I'm using gtk2hs and refreshing an SVG every 100 ms. It works, but I'm getting flicker effects. The problem is I need to keep redrawing a white rectangle as the background, otherwise I get a shadow trace of all the old positions. Any ideas on how to best go about fixing this w/o too much rewriting? My current svg generator looks like this: http:/
03:08:10 <roderyk> /hpaste.org/12927
03:08:13 <Axman6> ivanm: no, did you?
03:08:14 <roderyk> http://hpaste.org/12927
03:08:36 <quicksilver> roderyk: you need double-buffering, I imagine.
03:08:43 <blathijs> quicksilver: Ok, that makes sense
03:08:44 <dcoutts> roderyk: use the gtk double buffering
03:08:46 <quicksilver> I would have thought that is somethign that gtk provides in some form or other?
03:08:52 <ivanm> Axman6: yeah, they said they shipped it today and I should get it sometime next week \o/
03:09:00 <Axman6> whoot :D
03:09:05 * blathijs adds a "display" function
03:09:09 <dcoutts> roderyk: do use it, just do the repaint inside the exposed handler
03:09:12 <Axman6> if you get yours first though...
03:09:14 <quicksilver> ivanm: Amazon asked me to check my payment details so presumably my copy is also approximately on the way
03:09:24 <jeffz`> how much was rwh on fishpond?
03:09:25 <dcoutts> roderyk: I guess at the moment you're drawing directly from a timer handler?
03:09:41 <ivanm> jeffz`: originally, AU$55
03:09:47 <ivanm> but then the dollar fell :(
03:10:21 <roderyk> dcoutts: yes, I'm using drawing directly from a timer
03:10:40 <jeffz`> ivanm: ouch, its showing $139.99 atm.  bookware is only selling it for $84, but that's still a few more dollars than it costs to order from amazon I think.
03:10:51 <dcoutts> roderyk: so instead of doing the drawing directly during the timout handler, instead at that point invalidate the widget. Since your exposed handler has to do the right thing anyway then you're done.
03:11:08 <ivanm> jeffz`: :s
03:11:27 <ivanm> big w had it listed online... and I think dymocks had it at a semi-reasonable price back in october...
03:11:29 <dcoutts> roderyk: when you do the drawing during the exposed handler, gtk manages the double buffering automatically.
03:11:50 <roderyk> dcoutts: what do you mean by invalidating the widget?
03:12:22 <Axman6> ivanm: no email here :\
03:13:03 <dcoutts> roderyk: there's a widget function to say that the whole thing, or just a rectangle needs to be redrawn. It's equivalent to the user dragging another window in front of yours, it means the widget gets scheduled to be redrawn.
03:13:22 <dcoutts> roderyk: that's called invalidate / invalidating.
03:13:59 <roderyk> dcoutts: ah, ok. drawWindowInvalidateRect .. will look into this
03:16:00 <dcoutts> roderyk: or do invalidate the whole widget rather than just a specific rect/region use widgetQueueDraw
03:16:56 <dcoutts> roderyk: there are several advantages to doing it this way
03:18:09 <dcoutts> roderyk: one is that you don't end up animating when your window is hidden, the system deals with the posibility of overloading, that multiple timeouts may occur in between the time it takes to get round to drawing. It also means only one code path for drawing, it only happens in the expose handler.
03:19:15 <quicksilver> dcoutts: how quickly does it get called, roughly? In other systems I've used invalidate doesn't cause a redraw quickly enough for really smooth fast animations/.
03:19:35 <dcoutts> quicksilver: gtk does redraws in the idle handler
03:20:30 <jml> does haskell have hex literals?
03:20:38 <pumpkin> > 0x6
03:20:39 <lambdabot>   6
03:20:43 <pumpkin> looks like it :)
03:20:48 <idnar> > 0xa0
03:20:50 <lambdabot>   160
03:20:50 <dcoutts> quicksilver: which means they happen as soon as your app isn't processing other events, so usually quick enough unless your drawing itself is really slow.
03:20:52 * jml should have tried :)
03:21:06 * idnar waves to jml
03:21:12 <jml> idnar: hi
03:21:47 <roderyk> dcoutts: sorry, still a little confused. Currently I have a timeoutAdd running a tick every 100ms. If my tick runs widgetQueueDraw followed by updateCanvas, it will actually flicker more than before (unless I'm going about this the wrong way)
03:22:25 <dcoutts> roderyk: updateCanvas is your drawing function?
03:22:57 <roderyk> updateCanvas :: DrawingArea -> IO ()
03:23:03 <roderyk> it generates a svg and renders it
03:23:23 <dcoutts> roderyk: you should do nothing in your timeoutAdd except widgetQueueDraw. No drawing. All drawing should be done in the exposeEvent handler.
03:23:34 <roderyk> oh, I see
03:23:37 <roderyk> ok, will try that
03:23:57 <dcoutts> roderyk: see the gtk2hs/demo/Clock.hs
03:24:07 <dcoutts> timeoutAdd (widgetQueueDraw window >> return True) 1000
03:24:15 <dcoutts> 1000 because it's a clock of course :-)
03:24:45 <PeakerWork> BeelsebobWork: you still there?
03:24:47 <dcoutts> roderyk: then all the drawing is called from: window `on` exposeEvent $ do ...
03:25:24 <PeakerWork> BeelsebobWork: Sounds to me that if a precise event depends on behaviors/event contents, rather than other event timings, you probably have to use some kind of "atTimes" or such with a computation of when the collision occurred?
03:25:26 <roderyk> dcoutts: brilliant, that worked for me. Now I understand.... :)
03:25:41 <PeakerWork> Beelsebob: s/percise event/percise event timing
03:26:13 <Beelsebob> PeakerWork: yeh, that was roughly my thought
03:26:27 <Beelsebob> the problem though is getting enough info from the behaviors that I'm playing with
03:26:56 <Beelsebob> e.g. I have a behavior of directions that a ball is going in -- what I need from that is a list of times at which it changes
03:26:59 <Beelsebob> (lazily generated)
03:27:13 <Beelsebob> which should be as simple as grabbing the Reactive from inside it
03:27:16 <Beelsebob> but that's not exposed
03:27:39 <roderyk> dcoutts: so as an aside, all my logic that is dependent on time should be run by the exposeEvent and not the timeoutAdd tick?
03:28:25 <dcoutts> roderyk: it depends if it matters that the time reflect exactly what is on screen or if the few ms lag is ok
03:28:36 <PeakerWork> Beelsebob: Maybe it should be exposed via some trigger :: (a -> Bool) -> Behavior a -> Event a   (that works precisely when Reactives are being switched, and not percisely [sampled] when its a time-changing behavior)
03:28:55 <Beelsebob> PeakerWork: that would be interesting indeed
03:29:06 <Beelsebob> but it would remove some of the encapsulation of the behavior
03:29:08 <dcoutts> roderyk: also bear in mind that timeoutAdd is only relative time, it does not "catch up" if it gets delayed
03:29:15 <Beelsebob> in that to the user the behavior is meant to appear like a Time -> a
03:29:44 <PeakerWork> Beelsebob: Well, if you could test all of the possible Time's, then you could generate the Events precisely, in theory
03:29:50 <Beelsebob> yeh
03:29:59 <Beelsebob> but that's obv not possible
03:30:13 <dcoutts> roderyk: so eg, in the clock demo we use the timeout to trigger a redraw, but when we redraw we find out what the absolute time is, to do the correct drawing.
03:30:20 <quicksilver> Beelsebob: this is an argumetn in favour of exposing Reactive.
03:30:29 <dcoutts> roderyk: so it depends on your application
03:30:30 <Beelsebob> quicksilver: it is indeed
03:30:31 <quicksilver> Beelsebob: I.e. having a type which is documented to "change at known times"
03:30:39 <Beelsebob> yep
03:30:46 <Beelsebob> because really the ball-velocity is a Reactive
03:30:55 <Beelsebob> and then I wouldn't need to break Behavior's abstraction barrier
03:31:00 <quicksilver> I discussed it briefly with conal but not with any conclusion.
03:31:13 <quicksilver> when I've needed to do it myself, I've "backtracked" to the underlying Event
03:31:18 <quicksilver> (that was used to build the reactive)
03:31:22 <quicksilver> and built something out of that.
03:32:41 <Beelsebob> hmm, thought for the day actually
03:32:53 <Beelsebob> the colision event needs to be built out of the position behavior
03:33:26 <Beelsebob> which doesn't have the neat reactive structure internally
03:33:34 <Beelsebob> because it's an euler integral
03:33:39 <PeakerWork> Beelsebob: a more radical solution would be to limit Behaviors to not be arbitrary Turing-complete functions of time, but only compositions of arrows processing time, such that those arrows can answer questions about when their result will hold certain properties
03:33:51 <Beelsebob> yep, that's true
03:34:07 <Beelsebob> but then you couldn't have the mousePosition behavior any mor
03:34:08 <Beelsebob> more*
03:34:14 <quicksilver> Beelsebob: I don't think there is any combinator which lets you build Events out of Behaviours
03:34:23 <quicksilver> Beelsebob: such as the collision problem
03:34:25 <lilac> Beelsebob: that's not possible
03:34:25 <quicksilver> (is there?)
03:34:30 <lilac> Beelsebob: as i understand things at least
03:34:31 <Beelsebob> quicksilver: not unless the behoviors are really Reactives, indeed
03:34:39 <PeakerWork> Beelsebob: The mouse position can be considered a Reactive value with constants that change at the mouse sampling rate
03:34:51 <Beelsebob> lilac: sure it is -- as long as you can integrate the velocity precicely
03:34:54 <quicksilver> even something simple like "give me an Event when this behaviour goes > 10"
03:35:03 <quicksilver> is, of course, a root-finding problem
03:35:21 <quicksilver> what you can do of course is snapshot with a fixed sampling rate  (Event ())
03:35:24 <Beelsebob> yep, but that's possible for a limited set of behaviors
03:35:25 <quicksilver> and check for the first.
03:35:32 <Beelsebob> I wonder if there's a good way to expose it for said limited set
03:35:41 <lilac> Beelsebob: If your position is really the double-integral of an acceleration term, which is itself a stepper function (Reactive Vector2d or something) then that's probably doable
03:35:46 <quicksilver> extend FunTime to have explicit constructors for polynomials
03:35:52 <quicksilver> like K a, only more so.
03:35:58 <Beelsebob> yeh -- that's easy -- conal had indicated though that he thought he could get the colision point of the ball precicely quicksilver
03:36:12 <Beelsebob> lilac: yeh, which is the case here
03:36:17 <quicksilver> (and then implement root finding for polynomials one way or another)
03:36:21 <Beelsebob> (it's actually a single integral of a velocity which is a stepper)
03:36:22 <lilac> Beelsebob: if you assume the position function is continuous, then again it's possible
03:36:42 <Beelsebob> and yeh, the position function "is" continuous -- except that it's an euler integral
03:36:42 <lilac> (by function i mean the semantic interpretation of the Behaviour)
03:37:05 <PeakerWork> Beelsebob: you don't really have to find the collision point precisely, actually, you only need to find it consistently, right?
03:37:08 <Beelsebob> oh shit, my tram ticket is about to run out -- carry this discussion on when I get back to work
03:37:17 <Beelsebob> PeakerWork: I'd *like* to find it precicely
03:37:29 <lilac> Beelsebob: actually, i'm not sure what i just said is true, sadly
03:37:39 <lilac> too late :(
03:38:08 <quicksilver> snapshotWith fixed interval Event is quite a godo answer for some purposes
03:38:47 <lilac> quicksilver: combine that with an assumption of linearity between the events and you've got yourself a traditional collision detection algorithm
03:39:49 <pumpkin> waiting for godo
03:39:56 * wjt 's pre-ordered copy of Real World Haskell is delayed until January :'(
03:40:03 <pumpkin> wjt: oh no! why?
03:40:19 <pumpkin> does the author of happs hang out on IRC btw?
03:41:51 <quicksilver> pumpkin: one of them does ---> Lemmih
03:41:56 <pumpkin> ah :)
03:42:10 <pumpkin> thanks
03:42:14 <PeakerWork> Beelsebob: it does change the picture though - if its only _desirable_ and not necessary, then a "trigger" function that may succeed in doing so (but not guarantee it) may be good enough
03:42:38 <PeakerWork> BeelsebobWork: trigger will succeed when there are Reactives behind the scenes, and only get it "close enough" when its an actual function of time
03:43:21 <PeakerWork> Beelsebob: It can also do the trigger sampling at the exact same sampling rate of the adapter's engine, so that when its "close enough", its at least at the exact right sample point
03:44:35 <lilac> PeakerWork: something i've been thinking about: suppose you have a GUI clock which has an event every 1s to update various aspects of itself. you want the update to basically not happen when it's invisible, with no space leak and no 'catch up' lag when it becomes visible. how do you do this in Reactive?
03:45:58 <lilac> "Event a" as "[(Time, a)]" doesn't really support this way of working, as far as I can see
03:46:00 <PeakerWork> lilac: You basically want a pull behavior then, rather than a push one, as an actual function of time?
03:46:29 <lilac> right. and i want the system to know that the intermediary updates are irrelevant.
03:46:39 <PeakerWork> lilac: in a pull behavior, there are no updates?
03:47:03 <lilac> except that when the clock is visible, i want it redrawn every 1s, so it's still kind-of push
03:47:03 <PeakerWork> lilac: though if its inputs are events/reactives, its impossible, as you say..
03:48:20 <PeakerWork> lilac: that doesn't make it push yet, you can use a (time `div` (1 second)) as input to your pull behavior
03:48:35 <PeakerWork> lilac: but if it depends on actual Events/Reactives, then it has to FF them when it actually needs them
03:49:01 <PeakerWork> lilac: or in Reactive's current implementation, all Events/Reactives FF themselves constantly
03:49:11 <PeakerWork> (If I understood it correctly)
03:50:44 <lilac> PeakerWork: FF?
03:51:01 <PeakerWork> fast-forward
03:51:45 <lilac> PeakerWork: a time `div` (1 second) behaviour doesn't allow me to trigger a repaint every 1s
03:52:12 <lilac> and i'd ideally like to have that triggered solely by the contents of the window changing
03:52:25 <lilac> (where the contents of the window are represented by some kind of Event, probably)
03:57:54 <quicksilver> lilac: you can have a repaint triggered by an Event
03:58:00 <quicksilver> lilac: (not entirely sure I'm following you)
04:02:05 <PeakerWork> You want repaints triggered by either the window system, or changes to the image (capped by some maximal sampling rate, to avoid continuous repainting of continuous behaviors)
04:02:43 <quicksilver> I certainly wrote a demo with repaints triggered by Events, rather than fixed framerate
04:03:07 <lilac> quicksilver: that's not a problem. the issue is that when the window is invisible, i do not want the overhead of computing what to repaint
04:04:06 <quicksilver> lilac: haskell's default laziness should be enough there
04:04:16 <lilac> and i don't want a space leak and i don't want a 'catch-up' lag on first repaint
04:04:16 <quicksilver> you have an Event (AbstractClockDescription)
04:04:38 <quicksilver> but if you never look at the contents of the AbstractClockDescription, it will never get generated.
04:04:55 * BeelsebobWork returns
04:05:04 <quicksilver> you only get a bad catchup lag if the contents of one event depends on the contents of the previous event
04:05:06 <lilac> quicksilver: right, but the data it's computed out of will be stored until the system knows it won't be needed
04:05:15 <quicksilver> which is actually a very common situation but not the one you're describing
04:05:20 <quicksilver> lilac: not if it's working right, no.
04:05:32 <quicksilver> the "Event (AbstractClockDescription)" stream should still be being processed
04:05:34 <quicksilver> and discarded
04:05:44 <quicksilver> (because it doesn't turn into redraws when the window is hidden)
04:05:51 <quicksilver> so hte old ones can be GCed
04:05:58 <lilac> quicksilver: i'm not convinced it's a problem, but it makes me feel uneasy nonetheless
04:06:17 <pumpkin> http://resources.businessobjects.com/labs/cal/tutorial_calintro.html
04:06:52 <lilac> quicksilver: also, in the case of 'withPrevE' i wonder whether it might be better to make forcing the time force the value to avoid catch-up lag
04:06:57 <quicksilver> lilac: I'm pretty sure it's not a problem if its working right.
04:07:06 <quicksilver> I know for a fact it can be easy to make it work wrong ;)
04:07:19 <quicksilver> I have the opposite problem in that my events *do* all depend on previous occurrences
04:07:28 <quicksilver> so I'd rather they were eagerly evaluated than build up thunks.
04:07:42 <quicksilver> so, I strictified my 'accumE' which fixed that, for me, but might break it for you.
04:08:13 <lilac> do you think it's possible to satisfy my clock case and your dependent case with the same set of primitives?
04:08:30 <lilac> (that is, with those which build an event dependent on a predecessor being value-strict)
04:08:47 <quicksilver> yes, by providing primitives which let you pass in a "Strategy a"
04:09:01 <quicksilver> accumE :: Strategy a -> a -> Event (a -> a) -> Event a
04:09:14 <quicksilver> which controls how much strictness you want, from all to nothing and all points in between.
04:10:07 <lilac> ugh :) that's something i'd rather the users of the library didn't have to think about
04:10:25 <lilac> but it may well be unavoidable (whnf vs rnf)
04:10:28 <quicksilver> well you have the option of wrapping up versions which choose particular Strategies.
04:10:49 <quicksilver> but at least you can expose (As a lower level optional interface) the tools to fix hard examples.
04:11:01 <quicksilver> the ideal is high level combinators which get the common cases precisely right
04:11:12 <quicksilver> and lowl level combinators which give you tools to fix the unusual cases.
04:11:26 <quicksilver> (well, the *ideal* is high level combinators which always get it right, but assuming that's not possible ;)
04:12:04 <lilac> powerful primitives, elegant combinators
04:12:20 <lilac> that sounds almost sloganesque :)
04:13:14 <quicksilver> lilac: certainly my hack with "Seq" is inadequate because, for example, it behaves totally differently with a tuple (a,b) to a and b
04:13:33 <quicksilver> lilac: assuming the tuple is greedily constructed, seq'ing it does nothing.
04:13:44 <quicksilver> lilac: it happens to hit a sweetspot which fixed one particular leak I was analysing
04:13:51 <quicksilver> lilac: to be frank, I don't even know (Exactly) why
04:21:58 <quicksilver> zax: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
04:22:09 <quicksilver> zax: has doc links, so does the version if you s/current/stable/
04:29:28 <aleator> Hi, can someone help me to defeat a typing problem? http://haskell.pastebin.com/dac967fb
04:37:00 <quicksilver> aleator: I'll have a go, what's the error?
04:39:26 <byorgey> good morning, #haskell!
04:39:58 <quicksilver> aleator: calling 'snd' on the recursive calls to streamHead x/y looks suspicious to me.
04:40:36 <quicksilver> so does the declaration
04:40:36 <PeakerWork> yeah, they return (SE a) and (SE b), not tuples
04:40:37 <quicksilver> type SE (ZipStream a b) = (a,b)
04:40:44 <quicksilver> I think maybe you want
04:40:46 <quicksilver> type SE (ZipStream a b) = (a,b)
04:40:51 <quicksilver> type SE (ZipStream a b) = (SE a,SE b)
04:41:02 <quicksilver> (sorry hit return too early!)
04:41:09 <aleator> oops. I think I pasted something in flux.
04:41:19 <aleator> snd wasn't supposed to be there.
04:41:48 <aleator> What does 'type SE (ZipStream a b) = (SE a,SE b)' really mean?
04:42:12 <PeakerWork> this works: http://haskell.pastebin.com/m121143e8
04:42:16 <aleator> And, thanks btw, since adding that makes this work.
04:42:24 <quicksilver> well, it means that the "SE" for a ZipStream a b is a tuple of the "SEs" for a and b
04:42:45 <aleator> Oh. That was something I didn't figure out.
04:42:52 <quicksilver> SE is a type function
04:43:03 <quicksilver> if 'a' is a type then 'SE a' is a type
04:43:09 <quicksilver> (but only if a is a member of the class)
04:43:25 <aleator> Ah. So I "call" SE to get whats in the type?
04:44:21 <PeakerWork> if those are type families, what are associated types, what's the difference?
04:44:39 <PeakerWork> "data" vs "type" in the class?
04:48:01 <quicksilver> aleator: yes.
04:48:12 <quicksilver> aleator: in the same sense that you 'call' Maybe on Int to get Maybe Int ;)
04:48:35 <aleator> Hmm.. I'm still rather confused.
04:48:39 <aleator> How about this: http://haskell.pastebin.com/d72e6eb13
04:48:46 <quicksilver> but the type functions from classes are rather more general than tyep constructors
04:48:49 <quicksilver> (which Maybe is)
04:49:10 <cknapp> PeakerWork: Are you asking what the difference between data and type is in general? Or some subtlety of the code I haven't looked at?
04:49:43 <quicksilver> aleator: where are you getting this from?
04:49:59 <zax> quicksilver: thanks alot
04:50:14 <quicksilver> PeakerWork: associated type familiest are type families which are associated to a class, I thought.
04:50:21 <aleator> quicksilver: Trial and error? I'm trying to learn what these are.
04:50:22 <quicksilver> PeakerWork: ICBW about the terminology.
04:50:41 <quicksilver> aleator: streamHead s has type 'SE c'
04:50:48 <quicksilver> aleator: what makes you think you can apply 'f' to that?
04:51:42 <aleator> Nothing, because I of course can't. But is it possible to formulate something like that?
04:52:13 <PeakerWork> cknapp: I am wondering if there's a difference between "associated typed" and "type families"
04:52:17 <quicksilver> I have no idea what you're trying to formulate?
04:52:31 <PeakerWork> cknapp: and whether there's a difference between a "type" and "data" declaration _inside_ a class declaration
04:52:42 <aleator> quicksilver: a map over a continous stream?
04:52:45 <quicksilver> PeakerWork: I think a type family may be outside of a class (in which case it is not associated)
04:53:16 <SamB_XP> PeakerWork: yes, there is. associated type synonyms are not the same as plain associated types, exactly
04:53:25 <quicksilver> aleator: then you probably want instance (CContinousStreamE c) => CContinousStreamE (MapStream (SE c) b c)
04:53:28 <quicksilver> if that's legal.
04:53:55 <quicksilver> PeakerWork: the difference between type and data (inside a class) is that type is giving a synonym to an existing type, and data is declaring a new one, surely?
04:54:23 <PeakerWork> quicksilver: sounds to me like every case of declaring a new one can be converted to using a synonym (because you can always use a synonym to a new one)?
04:54:33 <SamB_XP> quicksilver: well, declaring the intention to give synonyms for existing types in the instances
04:54:45 <quicksilver> yes, that's what I meant.
04:55:12 <SamB_XP> PeakerWork: would you believe that associated type synonyms were implemented after associated types ?
04:55:15 <PeakerWork> quicksilver: what do you gain by requiring the type to be a new one?
04:55:33 <PeakerWork> SamB_XP: seeing is believing
04:55:49 <SamB_XP> PeakerWork: you could look at the patches ;-P
04:57:09 <PeakerWork> heh, given support for associated type synonyms, is there any reason to support associated types?
04:57:20 <aleator> quicksilver: Nope. Not legal.. :/
04:57:48 <quicksilver> aleator: then I think it has to be (CContinousStreamE c, SE c ~ a) => CContinousStreamE (MapStream a b c) ?
04:58:14 <SamB_XP> PeakerWork: well, you could ask ChilliX
04:58:23 <SamB_XP> I might not have got the name exactly right
04:58:34 <SamB_XP> @seen ChilliX
04:58:35 <lambdabot> I saw ChilliX leaving #ghc and #haskell 3h 15m 38s ago, and .
04:58:40 <SamB_XP> okay, yes, I got it right
04:59:41 <aleator> quicksilver: Thanks. Where do I find more info about these. I didn't even know existence of ~
05:00:15 <quicksilver> aleator: ~ is an equality constraint on types in a context
05:00:25 <quicksilver> aleator: it basically means "such that SE c === a, as types"
05:00:46 <quicksilver> http://www.haskell.org/haskellwiki/GHC/Type_families
05:00:51 <quicksilver> plus the paper links
05:00:59 <quicksilver> I don't think any of those sources is entirely complete though.
05:01:22 <quicksilver> PeakerWork: I can't answer your underlying question.
05:01:36 <quicksilver> "Why do we need associated data now we have associated type synonyms?"
05:01:48 <quicksilver> if no one else here can, perhaps you'd care to ask it on the cafe?
05:01:59 <quicksilver> I also would like to know the answer ;)
05:02:15 <SamB_XP> it might be more efficient?
05:02:51 <quicksilver> it might be more typesafe?
05:03:08 <quicksilver> (e.g. the same reason you use newtype instead of type in normal code?)
05:04:18 <aleator> quicksilver: Thank you
05:04:48 <araujo> morning
05:05:01 <orbitz> morning araujo
05:05:10 <cknapp> morning
05:05:15 <teko> sup peeps
05:05:23 <teko> whats the best free haskell IDE ?
05:05:33 <orbitz> oh gosh, not teko
05:05:38 <araujo> hi there orbitz , cknapp
05:05:41 <pumpkin> teko: yi maybe?
05:05:42 <araujo> hi teko
05:05:46 <teko> orbitz!!
05:05:48 <quicksilver> teko: emacs!
05:05:49 <pumpkin> teko: not sure there's exactly an "IDE" for it
05:05:52 <orbitz> teko: AHHHH
05:06:06 <orbitz> teko: i use Emacs, it has served me well, althouhg not sure what 'IDE" wold be here
05:06:48 <quicksilver> there aren't any "> version 1.0" haskell IDEs in the traditional sense.
05:06:54 <quicksilver> although there are several projects
05:07:03 <cknapp> I use screen, GHCi and vim. :)
05:07:14 <quicksilver> yi, leksah, eclipse-fp and visual haskell
05:07:25 <mokus> textmate and ghci :)
05:07:30 <quicksilver> AFAIK, the latter two are bitrotted, whilst the first two are under development.
05:07:39 <cknapp> It makes an effective IDE... if you're not afraid of the command line (well... mostly if you're not scared of vim)
05:07:45 <cknapp> yi seems promising.
05:09:37 <xhanjian> @src Data.List.sort
05:09:38 <lambdabot> Source not found. That's something I cannot allow to happen.
05:09:47 <xhanjian> @src sort
05:09:47 <lambdabot> sort = sortBy compare
05:09:59 <xhanjian> @src compare
05:09:59 <lambdabot> compare x y | x == y    = EQ
05:09:59 <lambdabot>             | x <= y    = LT
05:09:59 <lambdabot>             | otherwise = GT
05:10:30 <xhanjian> why use <= in the second guard?
05:11:34 <mokus> xhanjian: <= is probably defaulted in terms of < and ==
05:12:23 <mokus> it's more "work" to go from <= and == to <
05:12:31 <mokus> just my speculation though
05:13:11 <xhanjian> mokus: what do you mean by 'more work'?
05:13:22 <mokus> more operations
05:13:27 <mokus> gotta have a not in there
05:13:29 <teko> can u get yi for windows ?
05:13:36 <mokus> I'm probably wrong anyway though, actuall
05:13:45 <mokus> it's probable defaulted in terms of 'compare'
05:14:03 <xhanjian> umm..
05:14:37 <psault> foldl (*)(*) <- :)
05:15:28 <quicksilver> teko: I imagine it works, but I don't think it's easy to compile.
05:16:09 <orbitz> :t (*)(*)
05:16:10 <lambdabot> forall a. (Num (a -> a -> a), Num a) => (a -> a -> a) -> a -> a -> a
05:16:33 <dmwit> That Num (a -> a -> a) context is hard to satisfy.
05:16:46 <dmwit> Luckily, it wasn't foldl ((*)(*)).
05:16:49 <quicksilver> :t foldl (*) (*)
05:16:50 <lambdabot> forall a. (Num a, Num (a -> a -> a)) => [a -> a -> a] -> a -> a -> a
05:16:56 <quicksilver> that's not much better :)
05:16:59 <dmwit> ...not that ti matters much. =)
05:17:12 <quicksilver> PeakerWork: good question, well asked.
05:17:19 * quicksilver waits hopefully for an answer.
05:17:30 * orbitz waits next to quicksilver 
05:17:37 <dmwit> But hey, if you *did* have Num (a -> a -> a), it would be easy to construct a [a -> a -> a]. =)
05:18:19 <PeakerWork> quicksilver: thanks!
05:18:50 <pumpkin> dmwit: I can't think of any way to satisfy that, how would you do it?
05:18:59 <pumpkin> the Num (a -> a -> a)
05:19:39 <quicksilver> viewing a product as a field.
05:19:46 <quicksilver> there is probably some duality thing you can exploit
05:20:02 <quicksilver> (rather, viewing a set of product operators as a field)
05:20:18 <quicksilver> pointwise combination.
05:20:24 <idnar> :t ((*)(*))
05:20:25 <lambdabot> forall a. (Num (a -> a -> a), Num a) => (a -> a -> a) -> a -> a -> a
05:20:36 <idnar> oh
05:20:55 <quicksilver> instance Num (a->a->a) where (?) + (#) x y = (x ? y) + (x#y)
05:20:58 <quicksilver> and so on.
05:21:18 <pumpkin> hrm
05:21:27 <pumpkin> I guess you just need to define the methods Num expects for it
05:21:28 <pumpkin> yeah
05:21:29 <pumpkin> hmm
05:21:34 <quicksilver> fromInteger n x y = x * y * n
05:21:36 * pumpkin tries to think of a meaningful use of that
05:22:13 <PeakerWork> have there been proposals to add keywords arguments as syntactic sugar or type system additions?
05:22:26 <PeakerWork> I think I have a few ideas about how to do this, and I wonder if they are new..
05:22:47 <PeakerWork> (with/without losing the ability to perform partial application)
05:23:22 <quicksilver> pumpkin: actually I think I prefer
05:23:37 <quicksilver> ..where (?) + (#) x y = (x ? y) + (y # x)
05:23:53 <quicksilver> reversing the symettry makes it look like a lie algebra
05:23:55 <quicksilver> maybe it is...
05:23:58 <pumpkin> :o
05:24:00 <idnar> lies
05:24:04 <pumpkin> I know how to pronounce that!
05:24:13 <pumpkin> but I haven't taken enough algebra to know what it is :P
05:24:29 <idnar> how do you pronounce it?
05:24:32 <pumpkin> lee
05:24:36 <idnar> ah
05:24:56 <pumpkin> at least, so I've been told
05:25:15 <idnar> I read http://sigfpe.blogspot.com/2008/04/infinitesimal-rotations-and-lie.html and thought I knew what a lie algebra was
05:25:18 <idnar> but I've forgotten again
05:25:26 <idnar> no, http://sigfpe.blogspot.com/2007/11/whats-all-this-e8-stuff-about-then-part.html
05:25:47 <quicksilver> I did a whole module on Lie Algebras, by the great Martin Hyland.
05:25:51 <quicksilver> I can't remember what they are :(
05:26:05 <pumpkin> module?
05:26:13 <quicksilver> course module
05:26:16 <pumpkin> ah
05:26:16 <orbitz> http://www.haskell.org/haskellwiki/Almost_Haskell
05:26:16 <orbitz> hah
05:26:18 <quicksilver> 8 week lecture course
05:26:22 <pumpkin> cool
05:26:59 <quicksilver> seriously though, lie algebras are "stuff like cross product"
05:27:11 <quicksilver> they have a kind of antisymmetry law.
05:27:16 <pumpkin> I've always wondered about the cross product
05:27:26 <pumpkin> it felt kinda specific to 3 dimensions
05:27:34 <pumpkin> I couldn't think of a meaningful analog in 2d
05:28:04 <pumpkin> but my math is pretty basic
05:29:55 <pumpkin> ah, the wikipedia article has some explanations of generalizations of it
05:30:56 <SamB_XP> you could take the cross-product of the 3-vector 0-extensions of a a pair of 2-vectors
05:31:24 * pumpkin 's head explodes
05:31:32 <SamB_XP> not that that is much like what you're probably looking for
05:32:20 <SamB_XP> but I seem to remember something that that could have been used for in statics ...
05:32:29 <quicksilver> there is certainly something magic about 3 dimensions, in that it is precisely the right number of dimensions to have at most 3 mutually orthogonal vectors at a point.
05:32:40 <quicksilver> and in "a x b = c" a,b,c are such a set of three.
05:32:49 <pumpkin_snorkel> maybe that's why we're 3-dimensional beings!
05:32:50 <pumpkin_snorkel> :P
05:33:00 <quicksilver> so I suppose it's not surprising that an operation which is 'about'' sets of 3 vectors seems 'most special' in 3-space.
05:33:27 <SamB_XP> so ... would the 2D analog of the cross-product be a unary op then ?
05:34:00 <quicksilver> I think it's difficult to say what 'analogy' is in this sense.
05:34:15 <quicksilver> 2 and 3 are such small numbers, they are special in all kinds of ways
05:34:20 <pumpkin_snorkel> yup
05:34:33 <quicksilver> (triangles tesselate the plane but tetrahedra do not tesselate 3-space, for example)
05:37:49 <fasta> quicksilver: in the poke definition of a Storable instance for a type isomorphic to a List, do I have to allocate memory myself or will that happen automatically via the #peek and #poke stuff in hsc2hs?
05:38:36 <quicksilver> fasta: in general, as long as your "sizeOf" tells the truth, the space should already be allocated.
05:38:48 <quicksilver> however, I'm not entirely sure how that works with recursive types.
05:39:05 <fasta> quicksilver: I think it probably allocates everytime you poke something.
05:39:24 <fasta> quicksilver: since that's the way you are going to construct it too.
05:39:32 <PeakerWork> why is augustuss online but not on IRC? heh
05:39:48 <chessguy_work> PeakerWork, he just sent an email to -cafe
05:39:50 <teko> which haskell bundle should i use for textmate ?
05:39:59 <PeakerWork> chessguy_work: that's how I know he's online
05:40:02 <teko> mokus ?
05:40:05 <chessguy_work> oh. right.
05:40:12 <PeakerWork> chessguy_work: He answered my question, but noone answered it here
05:40:39 <chessguy_work> well, i, for one, am not usually on here when at work
05:40:51 <SamB_XP> maybe he is afraid we would distract him with our insane ramblings
05:40:56 <chessguy_work> but i'm most definitely online, and watching my email
05:41:19 <SamB_XP> so why are you here now ?
05:41:29 <quicksilver> chessguy_work: although either your nick is lying to use, or you are today ;)
05:41:45 <chessguy_work> thus the word "usually"
05:41:45 <pejo> His work might be blocking irc/ssh/etc, but not his email.
05:41:55 <SamB_XP> pejo: doubt it
05:42:12 <SamB_XP> blocking ssh would be kind of dumb, I think
05:42:33 <nominolo|msr> @seen dcoutts
05:42:33 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 2h 12m 4s ago.
05:42:41 <chessguy_work> so i've come up with an interesting idea for composable patterns for chess positions, and i'm wondering if it can be extended to other types of patterns as well
05:43:01 <pejo> Sam, plenty of telecom business do it, for example. It wouldn't be surprising if banks do.
05:43:10 <quicksilver> SamB_XP: many places do, dumb or otherwise ;)
05:43:18 <quicksilver> there are quite a lot of dumb people out there.
05:43:29 <SamB_XP> for developers ?
05:43:39 <quicksilver> chessguy_work: maybe you can use it to play go, as well.
05:43:45 <chessguy_work> well, sure
05:43:55 <quicksilver> chessguy_work: (the inability to appreciate how patterns compose has been a real block for go programs)
05:43:58 <chessguy_work> it very obviously extends to many board games
05:44:14 <SamB_XP> oh, hmm, for banks it might make sense ...
05:44:26 <chessguy_work> i'm wondering if it extends even further
05:44:29 <pejo> SamB, for everybody. The idea is if people can't get out/in they're safer.
05:45:38 <chessguy_work> the idea is, roughly, type Pattern a = Graph (a -> Bool) (a -> a -> Bool)
05:46:02 <quicksilver> is "a" a board? or a piece?
05:46:22 <chessguy_work> that is, you can think of a pattern as a labelled graph, where the nodes are predicates on the components, and the edges are relationships between them
05:46:32 <chessguy_work> a would be a square, actually, with or without a piece
05:47:09 <chessguy_work> something like data Square = Square Int (Maybe Piece)
05:47:16 * quicksilver nods
05:47:47 <quicksilver> does that give enough detail on the relationships between?
05:47:55 <chessguy_work> i'm not sure yet
05:48:01 <quicksilver> don't you need to label the edges with the 'kind of' relationship
05:48:09 <quicksilver> "can attack" is the obvious one in chess
05:48:18 <quicksilver> but I suppose it is not the only one.
05:48:26 <chessguy_work> well, that's an a -> a -> bool
05:48:40 <quicksilver> yes, but then you've used up your edges for that
05:48:46 <quicksilver> and you can't use them for other things
05:48:52 <chessguy_work> hm?
05:49:17 <chessguy_work> how about canAttack . areSameColor
05:49:33 <quicksilver> that's a different graph, thoug, it has a different edge set?
05:49:47 <quicksilver> maybe that's what you intend. A pattern is a family of graphs?
05:49:48 <chessguy_work> i'm not following
05:49:48 <PeakerWork> Who is Jules Bean?
05:49:51 <quicksilver> me.
05:49:56 <PeakerWork> ah :-)
05:50:57 <chessguy_work> each pattern is a single graph, but the edges can be labelled differently
05:51:39 <quicksilver> ok
05:51:51 * PeakerWork tries to set a gmail contact   Jules "quicksilver" Bean   but gmail is still just showing Jules Bean
05:52:42 <chessguy_work> quicksilver, not at all saying your wrong, this is the kind of discussion i'm looking for. just trying to understand where you're coming from
05:52:50 <chessguy_work> ahem. "you're"
05:54:38 <def__> kjkjkjkj
05:54:39 <chessguy_work> quicksilver, the example i've been using to try to prototype my ideas is http://en.wikipedia.org/wiki/Tic-Tac-Toe#Strategy . #1 there, for example, can be expressed in a single pattern, i think
05:54:58 <chessguy_work> vertex a, labelled by the predicate "isEmpty"
05:55:32 <chessguy_work> vertex b, labelled by the predicate (not . isEmpty)
05:55:55 <chessguy_work> label c, labelled by the predicate (not . isEmpty)
05:56:05 <quicksilver> label c ?
05:56:09 <chessguy_work> vertex c
05:56:12 * quicksilver nods
05:56:50 <kebomix> Free Programming e-books With Direct Links & Request ebooks Here : http://request-ebooks.blogspot.com/
05:56:56 <chessguy_work> b and c have a relationship of sameColor && onSameDiagonal
05:57:17 <chessguy_work> a and b have a relationship of onSameDiagonal
05:57:31 <chessguy_work> a and c have a relationship of onSameDiagonal
05:57:57 <chessguy_work> err, s/Diagonal/Line/
05:57:58 <quicksilver> interesting
05:58:40 <kebomix> Free Programming e-books With Direct Links & Request ebooks Here : http://request-ebooks.blogspot.com/
06:00:04 --- mode: ChanServ set +o quicksilver
06:00:09 <chessguy_work> quicksilver, where it gets hairy though is that i think i'll also want a way to 'capture' certain vertices, much like in a regex
06:00:09 --- mode: quicksilver set +b *!*n=sadmasd@41.233.46.*
06:00:09 --- kick: kebomix was kicked by quicksilver (sod off and die)
06:00:32 <quicksilver> chessguy_work: ooh. That sounds a bit nasty.
06:01:05 <quicksilver> maybe something a bit more tractable than a regexp?
06:01:20 <chessguy_work> oh no, i'm just borrowing the term from regexes
06:02:17 <chessguy_work> in practice, it could almost be like a zipper with multiple focii
06:02:27 <chessguy_work> (though i have no idea what that looks like)
06:03:19 <quicksilver> you can have zippers with multiple focii
06:03:33 <quicksilver> they're a bit syntactically clunky if you're not careful
06:03:37 --- mode: quicksilver set -o quicksilver
06:03:44 <chessguy_work> i bet
06:05:43 <chessguy_work> anyway, i think it will be easy enough to start by simply marking the vertices with a boolean or something, and forcing some kind of ordering
06:07:46 <pejo> quicksilver, *** kebomix has been kicked off channel #haskell by quicksilver (sod off and die), and the line after that: <quicksilver> chessguy_work: ooh. That sounds a bit nasty.
06:07:54 <quicksilver> ;)
06:08:21 <quicksilver> chessguy_work: what do you use the ordering for?
06:08:37 <chessguy_work> to work out references to 'captured' vertices
06:08:41 <quicksilver> chessguy_work: I can see your structure is holding good information, but I don't imediately see how you go from that structure to a play algorithm
06:08:59 <chessguy_work> it doesn't necessarily
06:09:09 <chessguy_work> there are lots of different ways you could go once you have patterns
06:09:36 <chessguy_work> (i.e., i'm only trying to describe the positions mentioned in that list, not the strategy involved, at least right now)
06:11:47 <chessguy_work> quicksilver, you can, however, see immediate benefits to, for example, chess engines, though. there are some positions which, if you see a particular pattern, the strategy of play is obvious
06:12:27 <chessguy_work> s/some/exceedingly many/ :)
06:12:48 <quicksilver> yes.
06:12:51 <cpriester> Hi everyone. I am unable to link a C prog that uses Haskell-Modules. What do i have to tell the linker?
06:13:13 <quicksilver> and one of the problems has always been getting a computer to pattern recognise they way we do.
06:13:21 <cpriester> There are errors like "undefined reference to `rts_lock'"
06:13:30 <chessguy_work> quicksilver, precisely
06:13:42 <quicksilver> AFAIK the good chess programs do a pruned exhaustive search
06:13:48 <cpriester> i linked with libHSbase
06:13:50 <chessguy_work> "good"
06:13:52 <quicksilver> and the cleverness is just in the evaluation algorithm and the pruning.
06:14:03 <quicksilver> chessguy_work: well they beat most humans ;)
06:14:10 <chessguy_work> as Kasparov says, the best chess players just suck less than the rest :)
06:14:14 <quicksilver> indeed.
06:14:17 <quicksilver> much like mail clients.
06:14:28 <chessguy_work> heh
06:14:37 <chessguy_work> i've never heard chess compared to email before :)
06:14:49 <quicksilver> maybe Michael R. Elkins is actually Kasparov in disguise?
06:14:52 <Saizan> cpriester: i think you've to make ghc do the linking
06:15:27 <quicksilver> cpriester: http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
06:16:25 <chessguy_work> but i could see eventually, maybe, being able to write something like match :: Functor f => Pattern a -> Functor a -> Bool
06:16:34 <chessguy_work> maybe not Functor
06:16:36 <chessguy_work> but something
06:18:18 <Axman6> Saizan: is english your native tongue? I just ask because i never see people use you've in that manner :) (not that there's anything wrong with it!)
06:18:18 <cpriester> There are no command lines on this web page...
06:18:29 <cpriester> Wher i replace gcc with ghc the same linker errors occur.
06:18:50 <chessguy_work> Axman6, i've heard of it before, occassionally
06:19:21 <Axman6> seems rather old fasioned to me
06:19:32 <Saizan> Axman6: it isn't :)
06:19:39 <Axman6> ok :)
06:19:52 <Axman6> what is?
06:19:53 <chessguy_work> i would have guessed it's a british-english thing
06:19:55 <Saizan> how you'd say that?
06:20:00 <cpriester> Ah, no. My fault, sorry.
06:20:05 <Saizan> i'm italian
06:20:31 <cpriester> But now, the application segfaults.
06:20:32 <cpriester> :(
06:20:59 <Axman6> ah, yes i've found italians have some very nice um.. not sure how to put it, interpretations? of english, they usually make me smile :)
06:21:00 <chessguy_work> Saizan, usually, we would only contract "you have" to "you've" when the "have" is an indicator of a perfect tense
06:21:13 <teko> jEdit > vim & emacs ?
06:21:23 <Axman6> Saizan: i would've used 'you have' instead
06:21:27 <chessguy_work> like "you have said that before"
06:21:30 <fasta> quicksilver: actually, one of the members of the struct is a union named foobar. The only member of this union (don't ask why) is a pointer to some other struct of type Z. How can I access it in this case? In C, it would be the_struct.foobar->thing_of_type_z
06:22:22 <Axman6> Saizan: since 'have' is where the emphasis in the sensense is
06:22:41 <quicksilver> Saizan's form is perfectly idiomatic in some dialects
06:22:52 <Saizan> ah, i see
06:22:55 <quicksilver> west england, for example.
06:23:26 <quicksilver> fasta: I don't know if there is a clever trick.
06:24:13 * Saizan now wonders how weird his english sounds
06:24:46 <quicksilver> PeakerWork: ah, good answer from augustss
06:25:04 <Axman6> Saizan: well, it took me that long to pick it up, so not very :P
06:25:05 <quicksilver> PeakerWork: associated data lets you use methods which dispatch on the data, rather than the class member per se.
06:26:15 <fasta> quicksilver: because in particular I don't know what argument to give to peek for a nested inline type. I could name it and then it will probably work, but it's not ideal.
06:26:31 <Axman6> BeelsebobWork: had any more ideas about Hacports?
06:27:20 <PeakerWork> quicksilver: the idea is that you can't infer that its the C2 instance, because other instances may also use the same data constructors?
06:27:38 <quicksilver> PeakerWork: yes.
06:27:39 <PeakerWork> quicksilver: while you can infer that its the C1 instance from the A/B data constructors
06:27:48 <quicksilver> PeakerWork: because that's the only way they are used.
06:27:55 <pumpkin_snorkel> Axman6: you'd want to be able to read the existing port specifications, but in haskell, and elegantly?
06:28:03 <quicksilver> the type of 'C' is just D2
06:28:21 <Axman6> pumpkin_snorkel: yup
06:28:34 <pumpkin_snorkel> Axman6: writing a parsec parser for the portfiles seems simple and like a good start to me
06:28:35 <quicksilver> there is no informaiton in that type to indicate it's a C2 instance
06:28:39 <PeakerWork> quicksilver: aha, so the class is allowed to contain methods that refer only to a "data" in it, without referring to the actual instance type (because its just as identifying), but its not allowed to refer only to the type synonym, but not to the instance type itself
06:28:47 <quicksilver> whereas the type of 'A' is T1 Bool
06:28:48 <Axman6> i was thinking it'd be a good way to learn parsing, but the port files can be pretty complpex
06:29:10 <quicksilver> PeakerWork: it's not a case of 'not allowed'; such things are allowed as far as I know.
06:29:17 <pumpkin_snorkel> Axman6: how do they currently parse it? with a parser generator of some sort, or is it handcrafted?
06:29:22 <quicksilver> it's "not useful" because there is no way to give the type checker the information to pick the right one.
06:29:25 <cpriester> what is the problem with "foreign export ccall "mul" mul :: Int -> Int -> Int" in Haskell and "int mul(int, int);" in C. why should that segfault, when linked together?
06:29:31 <PeakerWork> quicksilver: yeah, I'd expect the type error to be in the f2 method existence itself. Which would be sort of like a method:  blahMethod :: Int    -- has nothing to do with the class instance types, so it cannot be defined there
06:29:44 <Axman6> pumpkin_snorkel: the portfiles are a form of Tcl, so i think they're run in a way
06:29:49 <pumpkin_snorkel> ah
06:30:01 <quicksilver> cpriester: should be CInt -> CInt > CInt ?
06:30:02 <pumpkin_snorkel> dammit :P now we need a tcl interpreter
06:30:22 <Axman6> pumpkin_snorkel: but the syntax could easily be parsed i think
06:30:25 <pumpkin_snorkel> yeah
06:30:28 <Axman6> maybe i need a parsec tutorial
06:31:00 <Axman6> , [$ty|(>>=)|]
06:31:15 <devragert> I am a beginner, and i have a question
06:31:15 <cpriester> Hm, still segfaults...
06:31:16 <lunabot>  luna: Exception when trying to run compile-time code:
06:31:19 <PeakerWork> quicksilver: example error "The class method `bMethod' mentions none of the type variables of the class A a"
06:31:25 <PeakerWork> quicksilver: I see it as another case of the same thing
06:31:28 * quicksilver nods
06:31:32 <quicksilver> agreed.
06:31:38 <Axman6> devragert: ask away
06:31:52 <devragert> why do i get an error, when i just write "import MyModule" in another module?
06:32:04 <cpriester> I changed to CInt, but i get the same result.
06:32:09 <devragert> he says he cant find it
06:32:39 <devragert> i have a MyModule.hs in the same directory as my MainModule.hs
06:32:55 <Axman6> devragert: are you in the same directory?
06:32:56 <PeakerWork> devragert: are you using "ghc --make" ?
06:33:00 <devragert> yes
06:33:03 <Axman6> ah, that'll be it
06:33:08 <PeakerWork> devragert: does MyModule.hs have "module MyModule where ..." ?
06:33:20 <devragert> what is "ghc --make"?
06:33:28 <Saizan> cpriester: i'd also try asking in #ghc
06:33:31 <pumpkin_snorkel> you type it into your command-line
06:33:35 <Axman6> devragert: you are using ghc aren't you?
06:33:44 <devragert> yes ghc
06:33:54 <Axman6> devragert: ghc --make MainModule.hs -o main
06:34:22 <devragert> ok, i will try now
06:34:44 <Axman6> , [$ty|(+)|]
06:34:50 <lunabot>  luna: Exception when trying to run compile-time code:
06:35:22 <Saizan> , [$ty|id|]
06:35:28 <lunabot>  forall a . a -> a
06:35:43 <Saizan> , [$ty|+|]
06:35:46 <pumpkin_snorkel> Axman6: sounds like mmorrow's got some fixin to do :Pp
06:35:49 <lunabot>  luna: Exception when trying to run compile-time code:
06:36:00 <Axman6> pumpkin_snorkel: want to have a look at the code i have so far to represent a portfile?
06:36:03 <quicksilver> (+) doesn't have an unambiguous type
06:36:07 <quicksilver> I guess that's the problem?
06:36:19 <devragert> so have to write "ghc --make MainModule.hs -o main" in the GHCi?
06:36:23 <Axman6> it's pretty crap, and probably needs changing
06:36:30 <quicksilver> , [$ty|putStrLn]
06:36:31 <lunabot>  luna: lexical error in string/character literal at end of input
06:36:32 <Axman6> devragert: no, in terminal
06:36:32 <pumpkin_snorkel> Axman6: sure, why not... don't have much macports experience myself, I was listed as the bdb maintainer for a while but got bored of it
06:36:33 <Saizan> , [$ty| show |]
06:36:34 <quicksilver> , [$ty|putStrLn|]
06:36:39 <lunabot>  luna: Exception when trying to run compile-time code:
06:36:44 <lunabot>  luna: Exception when trying to run compile-time code:
06:36:51 <devragert> yes, in the terminal?
06:36:52 <quicksilver> , [$ty|map|]
06:36:54 <cpriester> Saizan: Ok, thanks. But there are very few people in that channel :)
06:36:58 <lunabot>  forall a b . (a -> b) -> ([a]) -> [b]
06:37:00 <devragert> he says: ghc not in scope
06:37:11 <quicksilver> cpriester: however, those very few people are the most important + knowledgeable ones
06:37:21 <Axman6> devragert: you need to do it in terminal, not ghci
06:37:47 <pumpkin_snorkel> , [$ty| \x -> (x, y)|]
06:37:50 <pumpkin_snorkel> whoops
06:37:52 <lunabot>  luna: Exception when trying to run compile-time code:
06:37:53 <pumpkin_snorkel> , [$ty| \x y -> (x, y)|]
06:37:59 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:38:01 <Lemmih> devragert: GHCi should just work. No need for --make.
06:38:02 <pumpkin_snorkel> oh my
06:38:06 <devragert> so just in the linux terminal?
06:38:07 <Axman6> :o
06:38:14 <Axman6> devragert: yes
06:38:26 <Axman6> http://hpaste.org/12930 -- pumpkin_snorkel
06:38:40 <PeakerWork> how do LANGUAGE directives work, in GHC?
06:38:50 <Axman6> i'm importing a few things i think i might need in the end
06:38:57 <Counter-Strike> Erik__!
06:38:58 <PeakerWork> what would I do to make another such directive available?
06:39:15 <Saizan> hack the compiler?
06:39:42 <Axman6> write a paper about how you would hack the compiler
06:39:56 <Axman6> then let SPJ hack the compiler for you ;)
06:40:49 <ToRA|MSR> or apply to do an internship and be paid to have SPJ explain to you how to hack the compiler...
06:40:51 <pumpkin_snorkel> Axman6: looks nice so far :)
06:40:56 <pumpkin_snorkel> Axman6: set up a github project for it :P
06:41:05 <quicksilver> PeakerWork: making GHC more pluggable was a SoC project
06:41:28 <Axman6> that'd mean learning git... and... i dislike linus -_-
06:41:42 <pumpkin_snorkel> oh no!
06:42:47 <shepheb> Axman6: code.haskell.org?
06:43:00 <devragert> i tried to do the "ghc --make" thing in the terminal, but he still can't find my MyModule
06:43:01 <Axman6> ure, guess i could get an account
06:43:03 <Axman6> s*
06:43:24 <quicksilver> devragert: well, maybe we're solving the wrong problem here.
06:43:29 <Axman6> devragert: does MyModule start with the line "module MyModule where"?
06:43:34 <quicksilver> devragert: are the two files in the same directory?
06:43:39 <quicksilver> do they have the right headers?
06:43:40 <devragert> the "ghc --make" thing does work however, when i delete the import MyModule line
06:43:50 <quicksilver> is ghci running in the right directory.
06:44:10 <quicksilver> you should be able to do this (program with multiple modules) equally well in ghci or ghc.
06:44:15 <devragert> yes
06:44:16 <pejo> Tora, aren't the internships currently frozen?
06:44:27 <PeakerWork> quicksilver: hacking on GHC still scares me :-)
06:44:31 <PeakerWork> quicksilver: I ought to get to it one day
06:44:36 <devragert> the files are in the same directory
06:44:50 <devragert> maybe ghci is not running in the right directorry
06:44:55 <devragert> directory
06:44:58 <PeakerWork> How big is GHC? LOCs are a silly measure but still give an Order of Magnitude.. How many LOCs?
06:45:13 <pumpkin_snorkel> does anyone have any haskell jokes? :P
06:45:16 <Lemmih> PeakerWork: 60k, iirc.
06:45:17 <pumpkin_snorkel> maybe that's -blah material
06:45:30 <quicksilver> PeakerWork: http://www.ohloh.net/p/ghc/analyses/latest
06:45:31 <PeakerWork> Lemmih: that's tiny! really?
06:45:50 <Axman6> not really haskell, but i like the recursion definition: Recursion: see Recursion
06:46:02 <PeakerWork> 16% of ghc in XML?? heh
06:46:03 <Lemmih> PeakerWork: That's the Haskell code. The rts is quite a bit larger.
06:46:24 <pumpkin_snorkel> :o
06:46:34 <quicksilver> there's also 6K lines of perl. Hah!
06:46:48 <ikkebr> 6k lines of perl is a great danger
06:46:58 <ikkebr> that's like 500k lines of any other readable language
06:47:08 <shepheb> ikkebr: it's even known as the Evil Mangler
06:47:09 <walski> hi there
06:47:56 <Axman6> hmm, my Hacports proposal is the second most controversial
06:48:14 <pumpkin_snorkel> Axman6: granted ,that's only one down-vote
06:48:32 <Axman6> it got a down vote though :(
06:48:44 <njbartlett_> Is there anything in the standard libs like this... chunk :: Int -> [a] -> [[a]]
06:48:58 <pumpkin_snorkel> @hoogle Int -> [a] -> [[a]]
06:48:59 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
06:48:59 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:48:59 <lambdabot> Prelude take :: Int -> [a] -> [a]
06:49:01 <walski> I would like to build a data type "Token" and it should have a constructor named TokNum which consists of a not empty sequenze of digits maybe followed by a decimal point and if there was a decimal point another, not empty sequence of digits
06:49:03 <njbartlett_> chunk n xs breaks the list xs into chunks of n length
06:49:04 <Lemmih> Ohloh still doesn't support darcs?
06:49:07 <walski> and I have not even a clue how to start with that
06:49:12 <quicksilver> njbartlett_: let groupsOf n = map (take n) . dropWhile (not.null) . iterate (drop n)
06:49:22 <walski> the first question is: how do I model a digit?!
06:49:23 <devragert> I have find out the problem: ghci was not working in the right directory
06:49:29 <devragert> thanks for your help
06:49:31 <walski> There is no such type in Haskell, is there?
06:49:35 <quicksilver> njbartlett_: probably my most commonly defined function in this channel ;)
06:49:50 <njbartlett_> quicksilver: Wow thanks. Now to try to understand it ;-)
06:50:17 <quicksilver> walski: you can defined data Digit = Nought | One | Two | .... if you wish.
06:50:25 <Axman6> > let chunk n xs = let (h,t) = splitAt n xs in h : if null t then [] else chunk n t in chunk 3 [1..10]
06:50:26 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
06:50:31 <quicksilver> walski: personally I would just use Chars or Ints.
06:51:29 <walski> quicksilver: your first recommendation is how I tried it
06:51:38 <walski> but then how do I define this TokNum constructor?
06:52:22 <quicksilver> walski: date Token = TokNum [Digit] (Maybe [Digit])
06:52:23 <Axman6> i'd use something like data Token = TokNum [Integer] (Maybe Integer)
06:52:34 <Axman6> ha
06:52:36 <walski> Ah cool!
06:52:50 <walski> :/ this maybe thing is a little weird :)
06:52:55 <quicksilver> walski: you are, by the way, confusing two things
06:52:59 <Axman6> that was supposed to be [Integer], but you might like to define Digit too, like quicksilver was implying
06:53:05 <quicksilver> a concrete description (which soundsl ike a grammar)
06:53:10 <quicksilver> and an implementation as a type.
06:53:17 <quicksilver> the type doesn't need to model "the decimal point"
06:53:20 <quicksilver> that is implicitly there.
06:53:28 <walski> How do you mean this?
06:53:38 <pjdelport> quicksilver: s/drop/take/ ?
06:53:46 <quicksilver> the decimal point is there if there are numbers after it.
06:53:54 <walski> let a = TokNum [One, Two, Three] [Four, Five] is cool
06:53:57 <quicksilver> pjdelport: dropWhile/takeWhile, yes
06:54:07 <pjdelport> yes
06:54:08 <quicksilver> walski: correct. You also don't need the 'Maybe'
06:54:28 <quicksilver> the 'absence of stuff after the point' can be modelled by the second list being empty.
06:54:37 <quicksilver> data Token = TokNum [Digit] [Digit]
06:54:47 <walski> Ok... but I need the to define that the first sequence is not empty
06:54:51 <quicksilver> you might also enforce that there must be at least one digit
06:54:55 <quicksilver> data Token = TokNum [Digit] Digit [Digit]
06:55:03 <walski> and the second list must not be empty if there is a decimal point
06:55:11 <quicksilver> what's a decimal point
06:55:13 <quicksilver> ?
06:55:16 <quicksilver> you're working backwards
06:55:18 <walski> 334.23
06:55:22 <walski> just the  . ;)
06:55:26 <quicksilver> the presence of the decimal point can be inferred from whether the last list is empty
06:55:35 <walski> that's right ;)
06:55:40 <Axman6> walski: if the second list is empty, you can say there's no decimal point
06:55:40 <quicksilver> [yes, I know what a decimal point is, I was being rhetorical :P]
06:55:48 <walski> cool ideas!
06:55:51 <walski> thank you a lot
06:55:57 <quicksilver> there is no need to explicitly model the punkt.
06:55:58 <walski> I'll try to carry on a little on my own
07:03:23 <Axman6> pumpkin_snorkel: git://github.com/axman6/hacports.git
07:04:08 <pumpkin_snorkel> Axman6: omg!
07:04:17 <Axman6> :o
07:04:43 <Axman6> Beelsebob__: git://github.com/axman6/hacports.git if you're interested
07:04:57 <cpriester> Hm, there are two executables, after the building process. One of them even segfaults, if i do not call any foreign function.
07:05:44 <cpriester> what are those two executables about?
07:06:30 <ziman> @index (.|.)
07:06:31 <lambdabot> Data.Bits, Foreign
07:06:48 * ksf wants yi to be three-dimensional.
07:06:50 <quicksilver> cpriester: What exact commands have you been using? what are the names of the two executables?
07:07:05 <ksf> with funny arrows into the screen pointing to docs, definitions and stuff.
07:07:20 <cpriester>  gcc -c -I /usr/local/lib/ghc-6.8.3/include main.c
07:07:25 <cpriester>  ghc -c -shared -ffi Mul.hs
07:07:31 <cpriester> ghc -o cmain Mul.o Mul_stub.o main.o
07:07:45 <quicksilver> use ghc --make for the last step
07:07:46 <cpriester> in mul there is only one mul x y = x*y
07:08:24 <quicksilver> and I'm not sure ghc -shared is useful
07:08:43 <Axman6> pumpkin_snorkel: care to join me on the project?
07:08:45 <cpriester> with --make it complains about no input files...
07:09:11 <pumpkin_snorkel> Axman6: no real time for projecting right now (brand new grad student), but I'd like to contribute at some point :/
07:09:30 <Axman6> well anything you can add would be great :)
07:09:34 <orbitz> where are you a grad student at?
07:09:47 <pumpkin_snorkel> dartmouth
07:09:56 <Axman6> i've just finished my first year at ANU, and i have about 2 months off before next semester :)
07:10:42 <pumpkin_snorkel> cool :)
07:10:47 <pumpkin_snorkel> I want time off! :P
07:11:09 <Axman6> and i think that something like this would be a good learning experience
07:11:46 <pejo> pumpkin, does dartmouth do fp research?
07:11:52 <pumpkin_snorkel> pejo: sadly not :)
07:13:33 <Axman6> i know ANU does, one of the PhD students got that nice Sun UltraSPARC maching to research haskell on
07:14:24 <Axman6> pumpkin_snorkel: want to give me a quick tutorial on git usage? mainly getting stuff on github and off it if someone does any work
07:14:47 <pumpkin_snorkel> github itself has some good how-tos on merging changes from other people
07:14:51 <pumpkin_snorkel> you know the basic model?
07:15:19 <Axman6> not really
07:16:12 <pejo> pumpkin, so Haskell isn't really related to your research? :-)
07:16:20 <pumpkin_snorkel> you don't typically have more than one committer per repo on github, people will fork your repo, do their work on their fork of it, and when there's something they feel should be merged into the "main" repo, will notify you, suggesting to pull from their repos
07:16:36 <pumpkin_snorkel> pejo: not at all :) except that I'm trying to do some of my implementations in haskell because I enjoy it :)
07:16:45 <pumpkin_snorkel> (and want to learn more)
07:16:57 <Axman6> ah fair enough
07:17:06 <orbitz> pumpkin_snorkel: the vermont dartmouth or teh massachusetts artmouth?
07:17:21 <pumpkin_snorkel> new hampshire one :P
07:17:27 <pumpkin_snorkel> right on the edge next to Vt
07:17:28 <orbitz> beautiful campus
07:17:40 <Axman6> i was assuming you meant in the UK
07:17:42 <pumpkin_snorkel> yeah, except today is a nasty drizzly day and the rain made the snow into slush
07:17:43 <Axman6> heh
07:17:50 <leimy> does lazy evaluation do away with some of the need for tail recursion?
07:17:52 <orbitz> hah it's raining here too
07:18:15 <orbitz> leimy: see the performance/lazy evalution wiki article
07:18:24 <Axman6> leimy: not afaik. tail recursion should speeds things up a lot of the time too
07:18:39 <orbitz> i was walking into work today and heard 2 huge explosions, they demolitioned some buildigns acros the harbor from me, was cool
07:18:49 <orbitz> Axman6: only if yo uare doing things strictly though, right?
07:18:58 <Axman6> no idea :)
07:19:07 <leimy> well it seems  like it'd hit the garbage collector, but it might not blow "stacks" if it's lazy and not tail recursive
07:19:11 <orbitz> Axman6: and doign a struct version wont' owrk on infinite lists
07:19:35 <pumpkin_snorkel> orbitz: where you at? :)
07:19:35 <Axman6> yeah
07:19:43 <orbitz> pumpkin_snorkel: i'm in Baltimore
07:19:47 <orbitz> s/struct/strict
07:19:57 <leimy> orbitz: neat... I'm from Baltimore
07:20:04 <leimy> what'd they blow up?! :-)
07:20:22 <orbitz> leimy: i believe a lazy evaluation of a list can be faster than a strict TC version, since you treat it liek a stream
07:20:32 <orbitz> leimy: something by the military ship yard across from Boston St
07:20:40 <leimy> wow
07:20:45 <orbitz> pumpkin_snorkel: my bro in law wen to dartmouth though so i've visited that area
07:20:57 <pumpkin_snorkel> ah :) yeah, it's very pretty during the fall, at least
07:21:03 <pumpkin_snorkel> the rest of the year is kinda meh
07:21:04 <pumpkin_snorkel> :)
07:21:19 <pumpkin_snorkel> summer is really hot and humid, winter is deathly cold, and spring is muddy
07:21:20 <orbitz> are the women loose? i didn't see muhc of a nigth life :)
07:21:30 <Axman6> pumpkin_snorkel: 'fall'?
07:21:36 <pumpkin_snorkel> Axman6: autumn :)
07:21:37 <orbitz> Axman6: autumn
07:21:58 <Axman6> i know, i was just a little shocked to hear a brit call it that... not a brit?
07:22:11 <matthewp> Hello everyone.  Had a question about writing QuickCheck tests for an ROT13 algorithm
07:22:16 <pumpkin_snorkel> orbitz: there is hardly anything outside of the huge frat scene :P but there's a lot going on if you consider frat houses
07:22:18 <matthewp> I have a code snippet here: http://pastie.org/335797
07:22:25 <pumpkin_snorkel> Axman6: I am actually a brit, but don't sound like one
07:22:32 <orbitz> pumpkin_snorkel: ugh.  i guess gotta work with what yoa ure given
07:22:34 <Axman6> shame :(
07:22:39 <pumpkin_snorkel> :)
07:22:48 <orbitz> would have to become good at AMOGing
07:22:55 <Axman6> orbitz: that was some awesome typoing there :)
07:23:03 <Axman6> yoa ure :D
07:23:06 <orbitz> Axman6: everyone needs a skill
07:23:24 <Axman6> yeah, making me look like a typo newb now
07:23:25 <pumpkin_snorkel> orbitz: yeah, not a big fan of frats myself, but there are other reasons to be here which I enjoy
07:23:39 <orbitz> i wish these hadoop jobs would finish so I could start working on my other hadoop jobs
07:23:40 <matthewp> What I was wondering is how to further prove that I offset by 13 in a nice way using QuickCheck
07:24:08 <Axman6> ['a'..'Z']
07:24:10 <Axman6> > ['a'..'Z']
07:24:12 <lambdabot>   ""
07:24:20 <Axman6> > ['A'..'z']
07:24:21 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
07:24:38 <orbitz> > ['z'..'a']
07:24:39 <lambdabot>   ""
07:24:45 <Badger> hah
07:24:49 <Axman6> [(chr 0) ..]
07:24:52 <orbitz> > ['z', 'y'..'a']
07:24:53 <trofi> > ['z','y,..]
07:24:53 <lambdabot>   "zyxwvutsrqponmlkjihgfedcba"
07:24:54 <lambdabot>   <no location info>:
07:24:54 <lambdabot>      lexical error in string/character literal at chara...
07:24:59 <Axman6> > [(chr 0) ..]
07:25:01 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
07:25:13 <trofi> > ['z','z'..'a']
07:25:15 <lambdabot>   ""
07:25:20 <Badger> what is \ACK
07:25:26 <orbitz> > "beef, it's what's for dinner"
07:25:27 <lambdabot>   "beef, it's what's for dinner"
07:25:33 <soa2ii> Hi there. What does
07:25:34 <soa2ii> *MGPL_Parser> test "testfile.bla"
07:25:36 <soa2ii> *** Exception: MGPL-Parser.hs:(123,0)-(157,38): Non-exhaustive patterns in function scanIdentifier
07:25:41 <soa2ii> mean in this case?
07:25:42 <soa2ii> *MGPL_Parser> test "testfile.bla"
07:25:44 <soa2ii> *** Exception: MGPL-Parser.hs:(123,0)-(157,38): Non-exhaustive patterns in function scanIdentifier
07:25:45 <soa2ii> sry
07:25:49 <soa2ii> http://hpaste.org/12931
07:25:50 <orbitz> srsly
07:25:53 <soa2ii> this should be snd
07:25:57 <Axman6> > [(chr 20) ..]
07:25:58 <lambdabot>   "\DC4\NAK\SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=...
07:26:02 <Axman6> > [(chr 24) ..]
07:26:04 <lambdabot>   "\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLM...
07:26:07 <Axman6> > [(chr 30) ..]
07:26:09 <lambdabot>   "\RS\US !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`a...
07:26:17 <Axman6> > [(chr 33) ..]
07:26:19 <lambdabot>   "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
07:26:20 <pumpkin_snorkel> lol
07:26:38 <orbitz> soa2ii: what if your thrid param is []?
07:26:50 <PeakerWork> Hmm.. I wonder if conal uses: repeat x = Cons x (repeat x)     -- it would probably be more efficient to use sharing/let, no?
07:27:00 <PeakerWork> (from his blog)
07:27:22 <PeakerWork> repeat x = fix (Cons x)
07:27:38 <quicksilver> PeakerWork: yes, although it's possible to argue the non-shared form helps you find space leaks ;)
07:27:40 <Axman6> > concat [show x ++ ":" ++ (show .chr) x++ " "| x <- [33..]]
07:27:42 <lambdabot>   "33:'!' 34:'\"' 35:'#' 36:'$' 37:'%' 38:'&' 39:'\\'' 40:'(' 41:')' 42:'*' 4...
07:27:47 <soa2ii> orbitz: Hm. Then the otherwise case mathces?
07:27:51 <quicksilver> assuming you might also work with non-shareable conses.
07:27:53 <sh10151> does anyone feel like tweaking a small function I wrote? it seems a little too complicated for what it does
07:27:55 <orbitz> soa2ii: what is the other case?
07:28:03 <PeakerWork> quicksilver: ah
07:28:06 <quicksilver> soa2ii: no, the otherwise is only a guard
07:28:11 <Axman6> > concat [show x ++ ":" ++ [chr x]++ " "| x <- [33..]]
07:28:12 <quicksilver> soa2ii: it's a guard on the (x:xs) csae
07:28:12 <lambdabot>   "33:! 34:\" 35:# 36:$ 37:% 38:& 39:' 40:( 41:) 42:* 43:+ 44:, 45:- 46:. 47:...
07:28:20 <quicksilver> soa2ii: but there is no [] case.
07:28:43 <Axman6> sh10151: paste the code
07:28:44 <soa2ii> So I have to guard on str@(x:xs) ?
07:28:51 <quicksilver> no.
07:28:54 <quicksilver> you have to have the other case.
07:29:08 <quicksilver> there is nothing you can do with the (x:str) case which will make it match []
07:29:09 <orbitz> scanIdentifier sym identifier [] = otherwisecase
07:29:13 <quicksilver> it's just not going to ;)
07:29:27 <orbitz> quicksilver: surely we can think of soemthigif we put our minds together! :)
07:29:28 <soa2ii> Oh let's see
07:29:41 <orbitz> there must be someway to pull x:xs out of a []!
07:29:50 <Badger> :D
07:29:58 * orbitz gets distrated by jelly beans instead
07:30:14 <leimy> lst@(x:xs)
07:30:39 <orbitz> > let lst@(x:xs) = [] in x
07:30:40 <lambdabot>   * Exception: /tmp/8611571887892680812:71:36-50: Irrefutable pattern failed ...
07:30:53 <orbitz> there is no refuting that
07:30:57 <Badger> :(
07:31:07 <Axman6> IRREFUTABLE!
07:31:16 <soa2ii> So all my other functions are wrong too? :'(
07:31:34 <quicksilver> yes.
07:31:51 <pumpkin_snorkel> lol
07:31:53 <Axman6> soa2ii: just need a base case for [] for each function
07:32:04 <quicksilver> soa2ii: elem x "/" is a very strange way to write x == '/'
07:32:12 <leimy> > let lst@(x:_) = [1] in x
07:32:13 <lambdabot>   1
07:32:28 <Axman6> i'd use a case statement for that
07:32:29 <qwr> Axman6: give -W to ghc
07:32:37 <soa2ii> quicksilver: I'm not familiar with haskell and I think my profs at university aren't too :/
07:32:37 <leimy> > let lst@(x:_) = [1] in x + 1
07:32:38 <lambdabot>   2
07:32:39 <qwr> Axman6: then it will warn you against those
07:32:42 <quicksilver> scanner sym ('/':'/':str) = scanner sym (deleteComment str)
07:32:56 <quicksilver> soa2ii: ^^ you can also pattern match directly on Chars
07:33:02 <soa2ii> Axman6: Well... but what should the base case do?
07:33:02 <Axman6> case x of '/' -> thing; '(' -> anotherthing;...
07:33:05 <leimy> ?src ($!)
07:33:05 <lambdabot> f $! x = x `seq` f x
07:33:08 * qwr don't know why in the hell isn't this warning enabled by default
07:33:18 <matthewp> Anyone have ideas for QuickCheck on these property tests? http://hpaste.org/12932
07:33:30 <quicksilver> qwr: because incomplete patterns are often necessary in good code.
07:33:34 <Axman6> soa2ii: depends what you want to do with an empty list :)
07:33:38 <leimy> I need to learn to profile my haskell
07:33:53 <qwr> quicksilver: _ -> error "wtf"
07:33:56 <soa2ii> Axman6: Hmm... just stop? (:
07:34:10 <quicksilver> qwr: *nod* that's a fair answer.
07:34:21 <Axman6> sure. might want to say scanner sym [] = sym
07:34:35 <soa2ii> ok
07:34:38 <soa2ii> let's see
07:34:49 <qwr> quicksilver: they are not frequent enough to not tell anything when you write them by accident
07:34:56 <qwr> at least imho
07:35:00 <Axman6> ca you match on say f (Just 0)?
07:35:09 <Axman6> not just Just x?
07:35:35 <leimy> > let factorials = \x -> take x $ drop 1 $ scanl (*) 1 [1..] in factorials 10
07:35:36 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
07:35:37 <Axman6> can*
07:36:16 <soa2ii> ok... now I just added:
07:36:18 <soa2ii> scanner sym [] =
07:36:19 <soa2ii> 	sym
07:36:22 <sh10151> Axman6: OK, I pasted it
07:36:25 * Axman6 doesn't like using lambdas as function definitions, unless it makes it more clear
07:36:26 <soa2ii> This sounds ok...
07:36:35 <Axman6> sh10151: and the link is...?
07:36:39 <sh10151> http://hpaste.org/12933
07:36:56 <sh10151> sorry about that, had trouble remembering how to use xclip
07:37:10 <leimy> > let fac = \x -> x !! (drop 1 $ scanl (*) [1..]) in fac 11
07:37:11 <lambdabot>   Couldn't match expected type `[a]'
07:37:14 <leimy> doh!
07:37:33 <quicksilver> Axman6: yes.
07:37:44 <Axman6> leimy: need to change arounf the x and the (drop $...) bits
07:37:53 <leimy> yep
07:37:54 <quicksilver> Axman6: you can match on arbitrarily deam patterns
07:37:56 <quicksilver> deep
07:37:59 <quicksilver> damn fingers
07:38:07 <Axman6> quicksilver: cheers :) wasn;t sure if you could match inside
07:38:11 <matthewp> I think I'm missing a more exhaustive check on my ROT13 for my QuickCheck.  Any advice?
07:38:12 <leimy> Axman6: unlike C, the indexing operator is not commutative
07:38:12 <Axman6> heh
07:38:33 <Axman6> well yeah ;)
07:38:37 <Axman6> :t (!!)
07:38:39 <lambdabot> forall a. [a] -> Int -> a
07:38:39 <leimy> > let fac = \x -> (drop 1 $ scanl (*) [1..]) !! x in fac 11
07:38:40 <lambdabot>   Couldn't match expected type `[a]'
07:39:04 <Axman6> leimy: also, drop 1 == tail
07:39:10 <leimy> yes
07:39:22 <leimy> no
07:39:24 <leimy> not really
07:39:26 <leimy> see
07:39:28 <leimy> > tail []
07:39:30 <lambdabot>   * Exception: Prelude.tail: empty list
07:39:32 <Axman6> ah yes
07:39:32 <leimy> > drop 1 []
07:39:33 <lambdabot>   []
07:39:38 <leimy> drop is safe :-)
07:39:44 <quicksilver> but in this case you had an infinite list
07:39:47 <Axman6> but, you know it'll always not be null ;)
07:39:48 <quicksilver> so they were the same ;)
07:39:57 <soa2ii> Hm... now I'm here:
07:39:58 <soa2ii> *MGPL_Parser> test "Pong.mgpl"
07:39:59 <leimy> quicksilver: drop is not a partial function
07:40:00 <soa2ii> *** Exception: MGPL-Parser.hs:(56,0)-(109,3): Non-exhaustive patterns in function scanner
07:40:00 <leimy> tail is
07:40:06 <soa2ii> http://hpaste.org/12934
07:40:09 <quicksilver> leimy: yes, I do understand what you said.
07:40:10 <soa2ii> This is my source
07:40:21 <leimy> quicksilver: right, so I don't "tail" often :-)
07:40:28 <quicksilver> leimy: I was just commenting that you were calling it on an observably infinite list.
07:40:55 <leimy> I was more pointing out that tail != drop 1
07:41:14 <leimy> but agreed
07:42:00 <leimy> brb
07:43:37 <matthewp> so far, given my ROT13 quickcheck property checks, I have calling twice should return the original string and that calling it once with characters shouldn't return the same string
07:43:43 <matthewp> But there should be more proof than that
07:43:52 <matthewp> Any help?
07:44:51 <orbitz> matthewp: you can also verify calling it iwth A gives whatever A + 13 is
07:44:56 <Axman6> have you checked it actually ROT13 encodes the data? probably easiest to do it by eye
07:44:57 <orbitz> and calling i with Z gives wahtever Z + 13 is
07:45:03 <edwardk> @seen conal
07:45:03 <lambdabot> I saw conal leaving #ghc and #haskell 5h 53m 11s ago, and .
07:45:16 <soa2ii> why are there still those patterns? I think I capture every string case... don't I?
07:45:18 <Axman6> orbitz: Z - 13 i believe
07:45:41 <matthewp> Axman6: yes, it encodes, but I was hoping for a QuickCheck proof for that
07:45:58 <sh10151> it seems like splitAt should be better for http://hpaste.org/12933 but I couldn't make it more readable and work
07:46:26 <sh10151> also liftM is a little frustrating to have
07:46:50 <quicksilver> matthewp: with a program that simple, the property would be the program
07:47:03 <quicksilver> \s -> map rot13 s = map rot13 s
07:47:07 <quicksilver> that's pretty ridiculous
07:47:19 <sh10151> and the actual conditional seems a little obscure
07:47:29 <Axman6> if there are any macports users around, check out git://github.com/axman6/hacports.git
07:47:41 <quicksilver> quickcheck is interesting when it's easier to specify properties than write the code
07:47:56 <quicksilver> for a simple functional algorithm the code *is* the most direct expression of the property
07:48:01 <edwardk> quicksilver: well you could check that rot13 . rot13 ~ id, etc.
07:48:06 <quicksilver> and your quickcheck property looks stupid.
07:48:11 <quicksilver> edwardk: sure. He did that.
07:48:17 <edwardk> but that wouldn't tell you that it was rot13 uniquely
07:48:17 <edwardk> ah
07:48:38 <matthewp> quicksilver: it was a quick silly demo to show people how to use it for some quick things
07:48:42 * quicksilver nods
07:48:49 <quicksilver> I'm afraid it's not a very good demo of quickcheck.
07:48:51 <quicksilver> (sorry!)
07:49:05 <quicksilver> search for something which has interesting properties which don't just look like repeating the code.
07:49:06 <matthewp> quicksilver: fair enough
07:49:27 <quicksilver> a sort algorithm is a decent one
07:49:40 <quicksilver> checking something is sorted is genuinely simpler than sorting it.
07:50:03 <quicksilver> and you can put a deliberate bug in your sorting algorithm
07:50:08 <quicksilver> see if your audience spot it
07:50:12 <quicksilver> and then prove that QC does.
07:50:24 <quicksilver> s/prove/demonstrate/
07:50:38 <matthewp> quicksilver: sounds like a much better idea.  Wanted something silly, but sorting makes a bit more sense
07:51:11 <quicksilver> finding the integer square root is another thing which is easier to check than perform.
07:52:03 <saml> did anyone write Kaleidoscope (http://llvm.org/docs/tutorial/LangImpl1.html) in haskell?
07:52:09 <matthewp> quicksilver: ok
07:55:23 <Lemmih> saml: There are no working llvm bindings for Haskell, I think.
07:56:10 <saml> Lemmih, oh? i use archlinux and i installed llvm and haskell-llvm packages. didn't test if they work though. at least i can import LLVM.Core
07:56:10 <BeelsebobWork> camior: this look sensible to you? http://hpaste.org/12935
07:57:01 <Lemmih> saml: Interesting. What version of llvm?
07:57:10 <saml> 2.4
07:57:45 <quicksilver> BeelsebobWork: shouldn't need joinE, I don't think.
07:57:53 <saml> I installed these: http://aur.archlinux.org/packages.php?ID=18018   and   http://aur.archlinux.org/packages.php?ID=11372    but i'm just reading llvm doc. iddn't really try if they are working
07:58:00 <quicksilver> BeelsebobWork: you should be able to do it just with snapshot and withNextE ?
07:58:01 <Lemmih> saml: Ah, then I guess they are working.
07:58:21 <BeelsebobWork> quicksilver: I don't think so -- the problem is needing to change the occurance times of the input event
07:58:26 <edwardk> they worked when i looked at them last, but they seemed to only cover Core functionality and mocked up the C API which is largely non-typesafe
07:58:31 <wjt> huh. having told me this morning that my RWH was delayed until January, Amazon just told me that it's shipped \o/
07:58:35 <BeelsebobWork> if the input occurs at 4 and 5, the output can occur at 4.6
07:58:47 <BeelsebobWork> oh, I missed some fsts and snds in there though
07:58:54 <quicksilver> BeelsebobWork: oh, you're being cleverer than I first saw. Neat.
07:59:15 <BeelsebobWork> quicksilver: it's a shame that you can't do proper newton raphson
07:59:21 <quicksilver> BeelsebobWork: in my mind 'atTime' is somehow labelled as unsafe but this is still neat.
07:59:24 <BeelsebobWork> because then you need to break out sampleB and gain a memory leak
07:59:57 <BeelsebobWork> oh, I don't think that I am missing a fst, nvm
08:00:04 <BeelsebobWork> I must run home -- dutch lessons soon
08:00:08 <BeelsebobWork> bbiab to chat about it
08:00:40 <Zero_In_Mood> yo :)
08:04:13 <soa2ii> Can you please watch this?
08:04:15 <soa2ii> http://hpaste.org/12936
08:04:34 <soa2ii> Why is thout output on the one hand missing everything after the first line
08:04:56 <soa2ii> on the othere hand it is missing the Lbrace for example but not the Assign.
08:05:13 <soa2ii> But both chars use the same "logic"... ?!
08:08:29 <quicksilver> soa2ii: you can answer that question yourself, by trying it on various input
08:08:39 <quicksilver> try it on "game", on  "game ", on "game(" and so on.
08:08:40 <qwr> soa2ii: scanner sym ('/':'/':str) = scanner sym (deleteComment str)
08:08:50 <qwr> soa2ii: etc would be imho easier to read
08:09:09 <soa2ii> qwr: Might be...
08:10:48 <soa2ii> quicksilver: Do you see the error yourself? I'm not in a good mood... have to finish this today... no idea from haskell and sitting here over 6 hours now :/
08:12:08 * Beelsebob returns victorious
08:12:10 <Beelsebob> quicksilver: what i'd like to do is find a way to generalise it -- so you can provide your own aproximation function
08:12:13 <Beelsebob> unfortunately, that needs a varying number of inputs
08:12:21 <quicksilver> soa2ii: believe it or not, I have a job. And the thing I'm paid to do is not debug other people's code. Well actually it is. But not your code.
08:12:38 <soa2ii> quicksilver: I believe it ;)
08:12:44 <quicksilver> soa2ii: so, if I suggest to you a path which might help you solve that problem, take the advice in the spirit it is intended.
08:12:54 <quicksilver> I'm not about to stop what I'm doing, download your code and start playing iwith it.
08:13:07 <quicksilver> Beelsebob: *nod*
08:13:10 <soa2ii> quicksilver: Sorry...
08:13:26 <quicksilver> Beelsebob: I feel like such a thing should be possible, but I'm not sure how to make the details work nicely.
08:13:40 <quicksilver> Beelsebob: (in terms of efficient and space leaks and the right level of control and not making it ugly)
08:15:33 <Beelsebob> yeh, it's possible to do easily with sampleB -- but then you get the space leaks problem
08:15:44 <edwardk> @tell conal trimf = ap trim
08:15:44 <lambdabot> Consider it noted.
08:18:09 <pumpkin_snorkel> :t ap
08:18:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:18:42 <pumpkin_snorkel> :t return (*4)
08:18:43 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => m (a -> a)
08:25:06 <mmorrow> , [$ty| \x y -> (x, y)|]
08:25:12 <lunabot>  luna: out of memory (requested 1048576 bytes)
08:25:14 <mmorrow> sigh
08:25:20 <mmorrow> why?
08:25:25 <mmorrow> , [$ty| \x -> x|]
08:25:31 <lunabot>  forall a . a -> a
08:25:40 <mmorrow> , [$ty| \x -> (x,x)|]
08:25:46 <lunabot>  luna: out of memory (requested 1048576 bytes)
08:25:59 <mmorrow> looks like i need to up the rlimits (again)
08:26:01 <skorpan> who is this impostor "lunabot"?
08:26:38 <mmorrow> a robot disguised as an irc bot
08:27:16 <skorpan> sounds sexy
08:27:19 <skorpan> can it do tricks?
08:27:40 <mmorrow> skorpan: oh yesh. lunabot can do template-haskell among random other circus tricks :)
08:27:43 <Saizan> , [$ty| show |]
08:27:48 <lunabot>  luna: Exception when trying to run compile-time code:
08:28:02 <mmorrow> hmm, i dunno what that is
08:28:05 * mmorrow checks
08:28:53 <zuff> mmorrow: what's this?
08:30:21 <mmorrow> ah, looks like i need to clean the names: "Not in scope GHC.Show.Show
08:31:37 <mmorrow> zuff: `ty' is a QuasiQuoter (Language.Haskell.TH.Quote) that wraps a function that uses the ghc-api to go String -> Type by interactively compiling/getting the type from GHC, then turning it into a template-haskell type
08:31:48 <zuff> oh, it's TH
08:31:50 <zuff> kay
08:31:51 <mmorrow> well, ty does go to a TH Type
08:32:00 <mmorrow> , [$tyQ|\x -> x|]
08:32:06 <lunabot>  Killed.
08:32:10 <mmorrow> gah
08:32:28 <mmorrow> i need to get a faster machine or keep the evaluator running or something
08:32:30 <mmorrow> , [$tyQ|\x -> x|]
08:32:36 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
08:33:40 <CyberGarp> I'm having trouble getting hmatrix installed. Anyone care to take a stab at helping me?
08:34:06 <CyberGarp> compiling dist/build/Numeric/GSL/Special/Internal_hsc_make.c failed
08:36:38 <lilac> , [| show |]
08:36:41 <lunabot>  VarE show
08:36:45 <lilac> :(
08:37:13 <lilac> how... unhygienic
08:37:29 <zuff> , [| HYGENE |]
08:37:31 <lunabot>  luna: Not in scope: data constructor `HYGENE'
08:41:48 <mmorrow> ah, all the "compile-code error" stuff was on account of the names not being cleaned and having GHC.*.* in them...
08:41:54 <mmorrow> , [$ty| \x y -> (x, y)|]
08:41:59 <lunabot>  forall a b . b -> a -> (b, a)
08:42:03 <mmorrow> , [$ty| show |]
08:42:08 <lunabot>  forall a . Show a => a -> String
08:42:23 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
08:42:28 <lunabot>  forall a . (a -> a) -> a
08:42:34 <mmorrow> woohoo
08:43:18 <mmorrow> , [$ty| [$tyQ| let fix f = let x = f x in x in fix \|] |]
08:43:22 <lunabot>  Type
08:44:09 <quicksilver> mmorrow: hmm you have to escape the final | and that's all?
08:44:12 <quicksilver> that's a bit weird.
08:44:55 <mmorrow> yeah, it's too bad. the problem though i think is that if you don't require it to be escaped, your parser needs infinite lookahead
08:45:15 <quicksilver> , [$ty| \x -> [$ty| x \|] |]
08:45:19 <mmorrow> (or needs to parse the insides of quasiquotes in the lexer/parser rather than after the fact
08:45:20 <lunabot>  luna: Exception when trying to run compile-time code:
08:45:20 <mmorrow> )
08:46:02 <mmorrow> ah yeah, so to do that, you'd have to arrange to `tyQ` to construct a TH Exp so that it's (in this case)  VarE (mkName "x")
08:46:11 <mmorrow> then that'll capture the outer x
08:46:31 <mmorrow> *..arange _for_ `tyQ' to ...
08:46:52 <quicksilver> well, I was only trying to be difficult
08:46:59 <mmorrow> heh
08:47:01 <quicksilver> I had not clear vision of what that might mean ;)
08:47:44 <mmorrow> hmm, well it's complicated by the fact that the whole things wrapped in another QQ, but at least they're the same one
08:48:38 <athos> hi everyone
08:49:00 <Megzlna> [| and |] was not a good choice for parsing.
08:49:12 <Megzlna> [{   }]   <-- no prob
08:49:29 <mmorrow> heh, that's true
08:49:36 <jajamana1> With vertices of (x::Double, y::Double, z::Double), how can I convert those components to GLfloat?
08:49:37 <zuff> , [| |]
08:49:39 <lunabot>  luna: parse error on input `|]'
08:49:44 <quicksilver> jajamana1: realToFrac
08:50:00 <mmorrow> everything is so complicated by how overloaded the ascii symbols are with all the various hs syntax
08:50:07 <jajamana1> quicksilver: great, thanks
08:50:28 <leimy> >:t realToFrac
08:50:50 <quicksilver> mmorrow: yeah, there aren't enough ascii symbols for this stuff ;)
08:51:01 <mmorrow> quicksilver: totally!
08:51:08 <leimy> Î»
08:51:20 <quicksilver> :t realToFrac
08:51:22 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
08:51:26 <jajamana1> > :t realToFrac
08:51:27 <lambdabot>   <no location info>: parse error on input `:'
08:51:38 <quicksilver> jajamana1: > is for executing code
08:51:40 <quicksilver> :t for type
08:51:41 <lambdabot> parse error on input `type'
08:51:45 <quicksilver> ;)
08:51:45 <Badger> :t realToFrac
08:51:47 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
08:53:03 <leimy> > let fac = \x -> (drop 1 (scanl (*) 1 [1..])) !! x  in fac 20
08:53:03 <mmorrow> , toUTF8 . concat $ replicate 3 "â¨â˜‚â©"
08:53:04 <lambdabot>   51090942171709440000
08:53:06 <lunabot>  â¨â˜‚â©â¨â˜‚â©â¨â˜‚â©
08:54:02 <lilac> [{ and }] only fix the issue if you require {} to nest properly within quasiquoters
08:54:06 <Megzlna> What's that? Badger mushroom?
08:55:21 <mmorrow> lilac: ah yeah, that's true. i think the only way around it is to require escapes like ghc does, or hand off full control (of the rest of the parse) + a continuation to re-enter haskell parsing (or not) to the each QuasiQuoter's parser
08:55:44 <zuff>  
08:56:16 <mmorrow> i tried hacking about with some haskell parsers and they're pretty epic to mess with
08:57:03 <leimy> as in epic fail?
08:57:18 <mmorrow> all i managed to do was introduce like 90 reduce/reduce errors, and a few hundred shift/reduce
08:57:31 <mmorrow> (up from 6 shift/reduce, 1 reduce/reduce)
08:57:47 <mmorrow> and that was from changing maybe 10 characters
08:57:57 <mmorrow> heh, yeah epic fail
08:58:04 <leimy> "ghc -e" is pretty sweet
08:58:35 <ksf> hmm... all I ever got out of any yacc was reduce/reduce and shift/reduce errors.
08:58:37 <mmorrow> totally, i keep reminding myself to use it more, but always forget when i have the occasion to
08:58:53 <leimy> I think it was invented to keep people beating on lambdabot :-)
08:59:11 <leimy> er keep them from :-)
08:59:25 <ksf> So I actually went off and wrote every parser I needed by hand, until I stumbled across parsec.
08:59:38 <leimy> ksf: DOH!
08:59:44 <quicksilver> I still tend to write parsers by hand
08:59:45 <leimy> parsec is pretty sweet
08:59:47 <quicksilver> combinator style
08:59:47 <mmorrow> ksf: yeah, happy/yacc is a trickster
08:59:56 <quicksilver> I don't find parsec adds much value over doing it myself
09:00:10 <leimy> quicksilver: Except that many people might understand Parsec already :-)
09:00:14 <ksf> quicksilver, that's why I love it
09:00:18 <mmorrow> i've recently become enamored with ReadP
09:00:29 <mmorrow> it's friggin great
09:00:35 <wchogg> mmorrow:  howso?
09:00:47 <quicksilver> parsec's stubborn non-backtracking-by-default really gets on my nerves.too.
09:00:55 <leimy> quicksilver: well there's that
09:01:09 <leimy> and some expressions can't be done very efficiently in Parsec
09:01:11 <quicksilver> if I was to use a library, I'd probably download polyparse
09:01:43 <mmorrow> it's nicer than parsec because (<|>) is commutative, and it does breadth-first search, so you can get results online-ish. plus, the datatype it uses internally is really neat
09:02:01 <mmorrow> (so there is no need for a "try")
09:02:08 <PeakerWork> @type (<|>)
09:02:09 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
09:02:12 <wchogg> Also, does anyone know if c2hs can handle unions with the #get & #set directives?
09:02:18 <leimy> Text.Read is supposedly pretty bad
09:02:34 <PeakerWork> Someone needs to make up a sensible operator scheme where <> wrapping actually has some agreed-upon meaning
09:02:37 <mmorrow> (i was just trying to emulate the parsec op, it's (+++) in ReadP)
09:02:59 <quicksilver> mmorrow: doesn't polyparse share those advantages?
09:02:59 <dons> Heffalump: "In short the availability of 10-13 days is incorrect and they should
09:03:02 <dons> have ordered more pre-pub based on their pre-orders.  They should have
09:03:03 <mmorrow> leimy: yeah. thankfully it's transitioning to ReadP
09:03:04 <PeakerWork> what are the semantic differences between mappend, <|>, and mplus ?
09:03:05 <dons> stock available in the next 2-3 days."
09:03:05 <lilac> mmorrow: another option for quasiquotes would be something like [<arbitrary string>| <stuff> |<same arbitrary string] (like the new C++0x raw string literals)
09:03:18 <leimy> mmorrow: guess I should look at readP
09:03:30 <mmorrow> quicksilver: i think it does in some respects. ReadP is nice because it's fully cps internally
09:03:53 <leimy> some might say CPS isn't that nice :-)
09:04:26 <mmorrow> but it's efficient in both space and time (and the datatype they use makes it look purty too)
09:04:32 <mmorrow> :)
09:04:38 <quicksilver> PeakerWork: mappend is for Monoids, mplus is for Monads.
09:04:48 <quicksilver> PeakerWork: <|> is one of the possible meanings of mplus.
09:04:52 * mmorrow has to run
09:04:55 <mmorrow> ReadP++
09:05:04 <quicksilver> (if the Applicative concerned were, in fact, a monad)
09:05:06 <PeakerWork> quicksilver: I know, but isn't the monad subclassing kind of wrong?
09:05:09 <wchogg> Also, mplus may or may not be commutative depending on religious affiliation.
09:05:09 <PeakerWork> (in MonadPlus)
09:05:26 <PeakerWork> You could always use (Monad m, Monoid (m a))
09:05:27 <quicksilver> mplus has at least two different semantic possibilities
09:05:29 <quicksilver> (maybe more)
09:05:39 <quicksilver> PeakerWork: not realy
09:05:42 <PeakerWork> So lets start with the simpler question:
09:05:44 <PeakerWork> @src Monoid
09:05:45 <lambdabot> class Monoid a where
09:05:45 <lambdabot>     mempty  :: a
09:05:45 <lambdabot>     mappend :: a -> a -> a
09:05:45 <lambdabot>     mconcat :: [a] -> a
09:05:48 <PeakerWork> @src Alternative
09:05:48 <lambdabot> class Applicative f => Alternative f where
09:05:48 <lambdabot>     empty :: f a
09:05:49 <lambdabot>     (<|>) :: f a -> f a -> f a
09:05:58 <quicksilver> because MonadPlus denotes equations between the Monoid behaviour and the Monad behaviour.
09:06:01 <quicksilver> that's the point.
09:06:10 <PeakerWork> oh, I see
09:06:20 <quicksilver> similarly Alternative.
09:06:47 <quicksilver> PeakerWork: http://www.haskell.org/haskellwiki/MonadPlus
09:06:52 <PeakerWork> is it possible to say:  class (Monad m, Monoid (m a)) => MonadPlus m where <nothing> ?
09:06:53 <quicksilver> for a discussion of the two possible rulesets.
09:07:17 <PeakerWork> So you don't have to duplicate the methods...
09:07:21 <lilac> PeakerWork: it is typical for (return a) `mappend` (return b) == return (a `mappend` b) -- but i don't know whether it's required to be
09:07:22 <PeakerWork> (and all code based upon these methods)
09:07:44 <PeakerWork> lilac: you could define that the MonadPlus instance (method-less) defines nothing but those rules upon the existing Monoid instnace
09:07:47 <lilac> PeakerWork: the Monad and Monoid instances for Maybe aren't derivable from one another
09:07:54 <lilac> becasue they do different things
09:08:18 <quicksilver> m () is also always a Monoid
09:08:21 <quicksilver> (a different one again)
09:08:25 <PeakerWork> lilac: I don't understand how that follows from what I said?
09:08:30 <leimy> Maybe is a Monoid? :-)
09:08:42 <lilac> > Just 1 `mplus` Just 2
09:08:44 <lambdabot>   Just 1
09:08:45 <PeakerWork> leimy: (Maybe a) is a monoid, if a is a monoid
09:08:50 <quicksilver> PeakerWork: you don't want to use the MonadPlus instance for Maybe as the Monoid instance for Maybe a
09:08:56 <lilac> > Just [1] `mappend` Just [2]
09:08:57 <lambdabot>   Just [1,2]
09:09:00 <quicksilver> because you want something else to be the Monoid instance for Maybe a
09:09:15 <PeakerWork> quicksilver: use newtype then
09:09:21 <orbitz> :t mappend
09:09:22 <lambdabot> forall a. (Monoid a) => a -> a -> a
09:09:44 <orbitz> Just 1 `mappend` Just 2
09:09:49 <orbitz> > Just 1 `mappend` Just 2
09:09:50 <lambdabot>   Add a type signature
09:09:55 <quicksilver> PeakerWork: no thanks.
09:09:59 <quicksilver> the current system works well.
09:10:05 <quicksilver> thanks for the offer.
09:10:10 <PeakerWork> quicksilver: I think the current scheme leads to code duplication, and perhaps even cartesian product of code duplication if you have code that works with Monoid, SomethingElse,  it has to have a "version" for MonadPlus, SomethingElse,   Monoid, SomethingElse2, and MonadPlus, SomethingElse2
09:10:25 <PeakerWork> quicksilver: for the exact same code
09:10:33 <PeakerWork> quicksilver: because of the differing methods, that have the same laws
09:10:36 <quicksilver> you can access the 'monoid behaviour' of a MonadPlus by a newtype, if you want.
09:10:49 <quicksilver> I've actually never needed that.
09:10:53 <quicksilver> although I can certainly imagine it.
09:11:05 <quicksilver> However I have very very often needed the current MonadPlus and Monoid instances.
09:11:16 <quicksilver> > "abc" `mplus` "def"
09:11:17 <lambdabot>   "abcdef"
09:11:31 <leimy> > "abc" `mappend` "def"
09:11:33 <lambdabot>   "abcdef"
09:11:45 <quicksilver> this highlights the different between maybe's MonadPlus
09:11:49 <quicksilver> and list's MonadPlus
09:12:10 <quicksilver> (or perhaps the difference between Maybe's monoid and List's monoid? ;)
09:12:21 * Badger considers
09:12:24 <Badger> :t mplus
09:12:25 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
09:12:31 <Badger> :t mappend
09:12:32 <lambdabot> forall a. (Monoid a) => a -> a -> a
09:12:51 <leimy> > 1 `mappend` 2
09:12:52 <lambdabot>   Add a type signature
09:13:05 <leimy> > 1 `mappend`2 ::Int
09:13:06 <lambdabot>       No instance for (Monoid Int)
09:13:06 <lambdabot>        arising from a use of `mappend' at ...
09:13:16 <quicksilver> PeakerWork: the point surely is that they don't have the same laws.
09:13:17 <PeakerWork> quicksilver: I think having duplicated method declarations, with the exact same laws applying to them, just to avoid newtype, is not.. nice
09:13:20 <quicksilver> MonadPlus has more laws.
09:13:26 <Badger> :t "abc" `mappend` "def"
09:13:28 <lambdabot> [Char]
09:13:31 <PeakerWork> quicksilver: Right, but for extra laws you can use an extra method-less class
09:13:46 <walski> Any idea on how I can model a datatype which basically is a char but only a-z, nothing else
09:13:59 <PeakerWork> quicksilver: Consider Monoid subclasses - you'd have to duplicate those subclasses to MonadPlus too
09:14:04 <Badger> > 1 `mappend` 2 :: [Int]
09:14:05 <lambdabot>       No instance for (Num [Int])
09:14:05 <lambdabot>        arising from the literal `1' at <int...
09:14:15 <PeakerWork> > [1] `mappend` [2]
09:14:16 <lambdabot>   [1,2]
09:14:23 <Badger> oh, fair enough
09:14:34 <gwern> walski: how about data Foo = A | B | C |...?
09:14:39 <PeakerWork> Badger: mappend has the same type args as result (m -> m -> m)
09:14:59 <quicksilver> PeakerWork: true, but there are no Monoid subclasses.
09:15:04 <walski> gwern: ok, thought there might be a simple solution
09:15:07 <leimy> > sum ([1] `mappend` [2])
09:15:09 <lambdabot>   3
09:15:16 <quicksilver> PeakerWork: hypothetical examples are less interesting than real ones.
09:15:22 <gwern> admittedly, you might find it a bit inconvenient to write literals like [H, E, L, L, O, W, O, R, L, D]...
09:15:31 <leimy> > sum ([1] `mplus ` [2])
09:15:33 <lambdabot>   3
09:15:38 <PeakerWork> quicksilver: isn't a Monoid that has "negative" elements (not sure about the proper term) a subclass of Monoid?
09:15:44 <PeakerWork> quicksilver: Monoid + negate, perhaps
09:16:01 <quicksilver> PeakerWork: the current situation does have an advantage, that you can have different MonadPlus and Monoid instances for some types, which turns out to be useful in practice.
09:16:17 <quicksilver> [yes, that would be called a Group]
09:16:24 <quicksilver> [commutative monoid would be another]
09:16:31 <PeakerWork> quicksilver: I agree, but I think that teaches us that the alternative mechanism for doing this (newtype) is too cumbersome, if we're willing to do things "the wrong way" for immediate practical benefit
09:16:41 <quicksilver> [but we don't actually use these in interesting programs]
09:16:56 <PeakerWork> quicksilver: because obviously duplicating everything here is "the wrong way" (IMO)
09:17:06 <quicksilver> type classes are only a good fit when there is morally only one instance.
09:17:21 <quicksilver> whenever that isn't true, type classes will be a bit annoying.
09:17:44 <quicksilver> however the dulplication in this case (mappend/mplus,mconcat/msum) is pretty minor IMO.
09:18:45 <PeakerWork> quicksilver: If newtype was cheap, it wouldn't be annoying?
09:18:52 <PeakerWork> quicksilver: (cheap as in easy/usable)
09:19:10 <quicksilver> I think newtype is pretty cheap.
09:19:23 <quicksilver> I just think type classes are a poor fit for any case where there is more than one instance.
09:19:52 <PeakerWork> quicksilver: Isn't that just because using newtypes for the various instances expensive?
09:20:49 <athos> @src not
09:20:49 <lambdabot> not True   =  False
09:20:50 <lambdabot> not False  =  True
09:20:53 <athos> :]
09:21:19 <PeakerWork> not = pred `unamb`succ   :-)
09:21:23 <PeakerWork> (I think)
09:21:31 <PeakerWork> would that work? :)
09:21:35 <athos> :t unamb
09:21:36 <lambdabot> Not in scope: `unamb'
09:21:42 <quicksilver> PeakerWork: No. It's because the entire purpose of the typeclass system is to associate a unique dictionary with a type.
09:21:52 <ksf> unamb requires both branches to have the same result.
09:21:59 <quicksilver> if you have multiple dictionaries for a type, you're doing it wrong ;)
09:22:04 <ksf> it's a parallel and that trusts you.
09:22:09 <quicksilver> you should just use explicit dictionary.
09:22:17 <athos> :i not
09:22:49 <athos> wwhat's unamb good for?
09:23:01 <PeakerWork> > pred True
09:23:02 <lambdabot>   False
09:23:04 <PeakerWork> > pred False
09:23:05 <lambdabot>   * Exception: Prelude.Enum.Bool.pred: bad argument
09:23:09 <PeakerWork> > succ True
09:23:10 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
09:23:13 <ksf> http://conal.net/blog/posts/merging-partial-values/
09:23:21 <PeakerWork> ksf: so if its bottom, its ignored, and its alright
09:23:31 <PeakerWork> I guess it should work ;)
09:23:55 <ksf> or, actually, http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice/
09:24:02 <athos> thx
09:24:56 <PeakerWork> Conal's blog is growing to be an awesome resource :)
09:25:11 <leimy> huh parallel or
09:25:13 <leimy> via unamb
09:25:15 <leimy> that's badass
09:26:06 <PeakerWork> Pretty much all of the functions that have:  blah a _ = something  ; blah _ b = something ; have to be biased towards handling certain bottoms - and can use unamb to remove that bias
09:26:08 <leimy> :t âŠ¥
09:26:10 <lambdabot> parse error on input `¥'
09:26:15 <leimy> heh
09:26:19 <PeakerWork> why does lambdabot change the symbol?
09:26:31 <PeakerWork> Oh, it probably isn't utf8-aware?
09:26:35 <athos> maybe leimys encoding is foobar
09:26:48 <pejo> PeakerWork, because it could parse â
09:26:56 <leimy> athos: didn't you see it properly?
09:27:16 <athos> nope
09:27:22 <ksf> >  âŠ¥
09:27:24 <lambdabot>   <no location info>: parse error on input `âŠ¥'
09:27:32 <leimy> Looks fine here.  I cut and pasted it from Conal's web page :-)
09:27:39 <leimy> > âŠ¥
09:27:40 <lambdabot>   <no location info>: parse error on input `âŠ¥'
09:27:40 <athos> hmpf
09:27:45 <leimy> same thing :-)
09:27:51 <leimy> it's not my encoding :-)
09:27:52 <ksf> > let âŠ¥ = undefined in âŠ¥
09:27:53 <lambdabot>   <no location info>: parse error on input `âŠ¥'
09:27:55 <athos> same, realy?
09:28:01 <athos> because lambdabot messed it up this time
09:28:03 <quicksilver> there was a version of lambdabot which understood utf8 but I think this isn't it?
09:28:12 <leimy> :t undefined
09:28:13 <ksf> > let a âŠ¥ b = undefined in  1 âŠ¥ 2
09:28:14 <lambdabot> forall a. a
09:28:15 <lambdabot>   * Exception: Prelude.undefined
09:28:18 <ksf> ha!
09:28:29 <quicksilver> ah.
09:28:37 <quicksilver> it does work, it just wants to be infix :)
09:28:43 <bauchus> is here a takusen expert? I have problems with the postgresql backend. I get this error, if i read more than one column of a table: " Prelude.read: no parse
09:28:43 <bauchus> "
09:28:44 <leimy> > let a âŠ¥ b = undefined in  1 âŠ¥ 2
09:28:46 <lambdabot>   * Exception: Prelude.undefined
09:28:47 <ksf> only :t does'nt seem to understand it.
09:28:57 <leimy> :t (âŠ¥)
09:28:58 <lambdabot> Not in scope: `¥'
09:29:01 <leimy> hah
09:29:07 <quicksilver> that's possible; :t is different code to >
09:29:25 <athos> ah
09:30:14 <BMeph> Are there any MonadPlus instances that are Monoids?
09:31:15 <bauchus> how can I get a call stack for my problem?
09:31:59 <quicksilver> BMeph: yes, Maybe is a monoid, in a different way
09:32:18 <leimy> Maybe itself is not a monoid
09:32:20 <leimy> right?
09:32:23 <quicksilver> > Just (Sum 3) `mplus` Just (Sum 3)
09:32:24 <lambdabot>   Just (Sum {getSum = 3})
09:32:24 <pejo> bauchus, perhaps the ghci debugger can?
09:32:26 <leimy> just like [Int] is a monoid
09:32:26 <quicksilver> > Just (Sum 3) `mplus` Just (Sum 4)
09:32:27 <lambdabot>   Just (Sum {getSum = 3})
09:32:32 <quicksilver> > Just (Sum 3) `mappend` Just (Sum 4)
09:32:32 <leimy> but [] is a Monad
09:32:33 <lambdabot>   Just (Sum {getSum = 7})
09:32:41 <ksf> <unknown> at <unknown>: Code problem <unknown> at <unknown>: Ask in #haskell
09:32:46 <quicksilver> leimy: indeed but should be clear what I meant.
09:33:01 <leimy> Right, I'm just trying to point out a really minor distinction :-)
09:33:21 <athos> :@hoogle Sum
09:33:22 <leimy> :kind []
09:33:25 <athos> @hoogle Sum
09:33:26 <lambdabot> Data.Monoid newtype Sum a
09:33:26 <lambdabot> Data.Monoid Sum :: a -> Sum a
09:33:26 <lambdabot> Prelude sum :: Num a => [a] -> a
09:33:37 <idnar> presumably Either is too
09:33:46 * wli notes "parallel or" has some deep semantic significance.
09:34:59 <athos> > [10..1]
09:35:01 <lambdabot>   []
09:35:06 <athos> > [10,9..1]
09:35:08 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
09:35:09 <PeakerWork> quicksilver: btw: You said: "If you have multiple instances, use a dictionary", but instead, we use multiple classes :-(
09:35:37 <quicksilver> PeakerWork: which I claim is OK, in this case, because the classes really do represent different things ;)
09:35:50 <leimy> > [10,8..3]
09:35:51 <lambdabot>   [10,8,6,4]
09:36:01 <athos> hm, why does [10..1] return []?
09:36:25 <Zao> Without a step, it counts upwards.
09:36:27 <wli> The default increment is 1, so it tries 11, sees that it's > 1, and stops without adding anything.
09:36:30 <athos> ah ok
09:36:33 <Zao> enumFromTo or something.
09:36:37 <athos> thx
09:36:43 <ski_> athos : because it starts at `10' and begins counting upwards, with steps of `1', til it reaches `4'
09:36:58 <ski_> (s/4/1/)
09:37:05 <Zao> > enumFromTo 3 6
09:37:06 <lambdabot>   [3,4,5,6]
09:37:12 <athos> well, that'd take a long time
09:37:18 <athos> :)
09:37:23 <Zao> With a suitable base case :P
09:37:35 <wli> Hmm. The functional interactive behavior bit doesn't say much (if anything) about signals.
09:37:38 <athos> :>
09:37:42 <jajamana1> @hoogle flatten
09:37:42 <lambdabot> Data.Tree flatten :: Tree a -> [a]
09:37:42 <lambdabot> Distribution.PackageDescription.Configuration flattenPackageDescription :: GenericPackageDescription -> PackageDescription
09:37:42 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
09:37:49 <bauchus> pejo: cannot set breakpoint on read: module GHC.Read is not interpreted :-((
09:39:25 <athos> @hoogle prime
09:39:26 <lambdabot> Data.HashTable prime :: Int32
09:39:26 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
09:39:26 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
09:39:26 <lambdabot> a
09:39:46 <athos> a!
09:40:29 <athos> @src (:)
09:40:29 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:44:16 <Saizan> http://augustss.blogspot.com/2008/12/ocaml-code-again-im-posting-slight.html <- with the code here, in OCaml, with "open BasicPersion" do i also get opConcat and opShow in scope?
09:44:25 <dons> http://www.reddit.com/r/programming/comments/7imgg/accessing_sql_databases_with_haskell/
09:46:24 <redditbot> Synchronous Events
09:46:24 <redditbot> Lennart Augustsson: Abstracting on, suggested solutions
09:46:24 <redditbot> Lennart Augustsson: The abstraction continues
09:46:24 <redditbot> Functional interactive behavior
09:46:24 <redditbot> Trimming inputs in functional reactive programming
09:49:20 <quicksilver> dons: heh. Now we can see when you go on your reddit trawls ;)
09:58:19 <zeno> if i have data A = A { a::A, b::B, c::C etc, is there a better way to change one field than say f (a b c d) = A a b 2 d?
09:58:52 <Saizan> f r = r {c = 2}
09:59:14 <athos> @src succ
09:59:15 <lambdabot> Source not found. You type like i drive.
09:59:19 <athos> :t (succ 6)
09:59:21 <lambdabot> forall t. (Enum t, Num t) => t
09:59:57 <zeno> Saizan: thanks
10:01:16 <athos> btw.: is there something like a "dependency graph" which gives information (especially about the number types) like "okay, foobar is "derived" from barfoo and baz, integral is just a "derived"/specialized version of bazfoo)
10:01:42 <byorgey> athos: there's a graph like that in the Report, I think
10:01:44 <byorgey> @where report
10:01:44 <lambdabot> http://www.haskell.org/onlinereport/
10:02:35 <athos> thx!
10:02:43 <byorgey> hmm, I can't seem to find it
10:02:44 <athos> btw byorgey: still playing go?
10:03:01 <byorgey> athos: I haven't played in a while, but I am still a go player =)
10:03:16 <athos> cool :)
10:03:22 <byorgey> ah, here we go: http://www.haskell.org/onlinereport/basic.html#standard-classes
10:03:44 <wli> I'll settle for how to do signals so ctrl-C and so on can be handled by apps.
10:04:51 <Vulpyne> It raises an exception in recent versions of ghc I think.
10:05:09 <wli> I've been a bit further than that before.
10:05:48 <wooli> does cgibbard from reddit come on here?
10:06:27 <wli> One odd behavior I got was that the ^C wouldn't register until one additional character was entered.
10:06:44 <Vulpyne> Strange.
10:06:50 <Lemmih> wooli: Yes, he's Cale.
10:07:56 <jajamana1> > map succ (1,2,3)
10:07:57 <lambdabot>   Couldn't match expected type `[a]'
10:07:58 <wooli> Lemmih: thanks :)
10:08:13 <wooli> Cale: ayt?
10:10:27 <jajamana1> > map succ ((\(a,b,c) -> [a,b,c]) (1,2,3))
10:10:29 <lambdabot>   [2,3,4]
10:11:25 <jajamana1> Is there any convenience for map on a homogenous tuple?
10:12:12 <Lemmih> jajamana1: No.
10:12:44 <jajamana1> ok
10:14:34 <wli> jajamana1: This works on pairs: Control.Arrow.join (Control.Arrow.***) :: (t -> t') -> (t, t) -> (t', t')
10:15:11 <wli> > join (***) (+1) (1,2)
10:15:13 <lambdabot>   (2,3)
10:16:56 <jajamana1> wli: Fine, wondering if I should rather store vertices as list than tuples?
10:17:46 <rafting> is Haskell good for genetic algorithms and genetic programming?
10:18:03 <znutar_> rafting: I'm finding it lovely for that
10:18:18 <jeffersonheard> Thingie-0.5 is now in hackage.  Enjoy purely functional 2D drawing using Cairo
10:18:28 <dcoutts> cool
10:18:34 <luite> rafting: yes :P
10:18:47 <jajamana1> wli: Maybe better to just make a custom map for vertices?
10:19:44 <luite> rafting: but it may depend on how complicated the programs you generate are
10:19:46 * dcoutts really should add a check to disallow build-depends: base with no upper version bound
10:20:15 <Raevel> oh boy, i just named the helper for my tableux function "tablaux"
10:21:16 <zuff> Raevel: haha
10:22:24 <rafting> genetic algorithms might be one thin but rewriting the programs, how would I do that? with template haskell?
10:22:41 <edwardk> @faq
10:22:41 <lambdabot> The answer is: Yes! Haskell can do that.
10:23:00 <edwardk> haskell is quite good at GP
10:23:06 <bauchus> \me wrote an tiny example with my problem: http://hpaste.org/12944
10:23:24 <edwardk> think about it you commonly represent a GP program as an immutable a tree like structure with an evaluation function.
10:23:34 <bauchus> error msg: : Prelude.read: no parse
10:23:34 <bauchus>  
10:23:38 <edwardk> add a couple of minor rules for crossover and mutation and poof
10:23:41 <luite> rafting: you will probably need to do some 'juggling' with monads to pass all the state around (for genetic algorithms you probably need a random generator and maybe some state for adapting your operators), but when you're done with the structure, haskell makes it really easy to experiment with various operators, compose them, etc
10:24:40 <ksf> genetic programming already comes naturally with bitrot.
10:31:58 <wli> @faq Is it possible to write a library of interior decorating and fashion design combinators in Haskell? I want to replace that Peter Perfect guy on the Style Network with a robot controlled by a Haskell program.
10:31:58 <lambdabot> The answer is: Yes! Haskell can do that.
10:32:55 <wli> There you have it.
10:33:31 <wli> I take it that question was on everyone else's mind as well.
10:34:04 <athos> @faq Is Haskell godlike?
10:34:05 <lambdabot> The answer is: Yes! Haskell can do that.
10:34:09 <athos> :]
10:34:28 <athos> @M-x doctor
10:34:28 <lambdabot> you are welcome
10:34:30 <wli> I invoke Jeffrey rules: the most stylish response wins.
10:34:33 <athos> :D
10:34:53 <wli> Or in this case, the most stylish question.
10:36:18 <Raevel> this is a little intimidating:
10:36:21 <Raevel> @fag
10:36:21 <lambdabot> The answer is: Yes! Haskell can do that.
10:36:35 <dons> Rageros: welcome!
10:37:40 <idnar> uhm, where do I get the Parsec applicative instance(s)?
10:38:19 <dons> idnar: prob. in parsec 3?
10:38:41 <quicksilver> conal: I read your blog posts at lunch time.
10:38:45 <idnar> wait
10:39:01 <lilac> idnar: in parsec2, there was a <|> operator but it wasn't the Control.Applicative one
10:39:01 <idnar> is Text.ParserCombinators.Parsec actually what I want?
10:39:06 <lilac> no, Text.Parsec
10:39:27 <lilac> the longer name is the parsec2 compatibility interface afair
10:39:30 <quicksilver> conal: you have described very much the problems I have been discovering.
10:39:45 <idnar> how would I install parsec 3 with cabal-install?
10:39:54 <quicksilver> conal: I don't think I agree with the implication that cojoin is more natural with relative time than absolute time, though.
10:39:58 <ddarius> cabal install parsec
10:39:59 <lilac> idnar: firstly, are you sure you don't already have it?
10:40:19 <idnar> Could not find module `Text.Parsec'
10:40:25 <conal> quicksilver: hi
10:40:26 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
10:40:27 <ddarius> There is a small omission in the one on Hackage so the darcs version is a bit better.
10:40:33 <idnar> cabal install parsec says "All requested packages already installed. Nothing to do."
10:40:44 <lilac> cabal upgrade parsec
10:41:08 <idnar> cabal: Unresolved dependencies: base >=4.0, base >=4.0&&<4.1
10:41:35 <idnar> I'm on ghc 6.8.2 here
10:41:38 <dcoutts> lilac: upgrade and install are the same in that respect, they both try to install the latest version.
10:41:40 <lilac> that means it depends on ghc6.10
10:41:49 <ddarius> It shouldn't.
10:41:54 <dcoutts> lilac: the difference is whether it also tries to upgrade dependencies or not
10:42:01 <idnar> dcoutts: they definitely give different output here
10:42:09 <lilac> dcoutts: interesting
10:42:23 <dcoutts> idnar: you mean with --dry-run ?
10:42:39 <idnar> dcoutts: no, no flags
10:42:57 <dcoutts> idnar: well they do different things, one tries to upgrade dependencies
10:42:58 <idnar> dcoutts: cabal install parsec says "All requested packages already installed. Nothing to do.", cabal upgrade parsec says "Unresolved dependencies: base >=4.0, base >=4.0&&<4.1"
10:43:21 <dcoutts> idnar: because it tries to upgrade a dependency to the latest version, and the latest version needs base 4
10:43:30 <kig> what monad combinators are there in the stdlib?
10:43:37 <dcoutts> idnar: if you run it with --dry-run and -v it gives more info
10:43:41 <idnar> dcoutts: but I don't have Text.Parsec, so presumably I don't have the latest version of parsec installed
10:43:56 <dcoutts> idnar: if you want to install parsec 3 then use cabal install 'parsec > 3'
10:44:04 <dcoutts> idnar: the default parsec version is 2.x
10:44:17 <idnar> ah
10:44:21 <Badger> ooh
10:44:26 <Badger> didn't know you could do that
10:44:34 <idnar> okay, that seems to have worked
10:44:46 <dcoutts> Badger: arbitrary constraints or extact versions
10:45:55 <kig> since i'm feeling silly writing stuff like doWith g f m = do { f m; g } , withDo f g m = do { f; g m }
10:46:06 <lilac> dcoutts: why is the default version 2.x?
10:46:17 * lilac didn't even know that hackage supported default /= latest
10:46:24 <redditbot> Accessing SQL databases with Haskell
10:46:25 <idnar> No instance for (Stream s m Char)
10:46:34 <quicksilver> kig: just use "f m >> g" and "f >> gm" ?
10:46:37 <byorgey> kig: doWith g f m = f m >> g
10:46:55 <dcoutts> lilac: because that is the stable version, 3.x is the experimental version
10:47:16 <dcoutts> lilac: just as with haxml, 1.13.* is the stable version
10:48:31 <quicksilver> conal: anyhow, I wrote cojoinR and cojoinB and they solved my space leak ;)
10:48:45 <conal> quicksilver: that's awesome!
10:48:58 <lilac> dcoutts: it'd be nice if 'cabal upgrade' didn't need a -v to tell you that there's a later version it's not using :)
10:49:04 <conal> quicksilver: how about coreturn?
10:49:08 <quicksilver> conal: now I just have to fix an old-fashioned bug of something not doing what I thought it would.
10:49:19 <conal> quicksilver: aka counit, extract
10:49:22 <leimy> old fashioned bugs are great :-)
10:49:37 <quicksilver> conal: yeah, extract doesn't make sense with absolute time
10:49:46 <conal> quicksilver: thanks for the tip about strictifying accumR
10:49:51 <conal> quicksilver: exactly
10:50:07 <kig> quicksilver, byorgey: mm, i'm using them to do point-free function definitions; fillWith = doWith fill (but maybe that's needlessly unreadable)
10:50:08 <idnar> bleh
10:50:31 <quicksilver> conal: my suspicion is that we will need to get down and dirty with something like Strategy
10:50:32 <dcoutts> lilac: please add your comments to http://hackage.haskell.org/trac/hackage/ticket/408
10:51:03 <quicksilver> because there really are reasons you want things to be lazy, and reasons you want them to be strict.
10:51:23 <dcoutts> lilac: the downside is that it will pester users about not using the latest unsable version when they may well just want the stable version. We do not want to pressure users into using the unstable versions. That should be for the package authors to decide.
10:51:32 <dons> word: perl people are sensitive when you suggest that perl is not a general purpose language. i didn't realise that was so touchy
10:51:40 <byorgey> kig: yeah, I don't think it's worth it to go to quite that length to be able to give point-free definitions.
10:51:41 <conal> quicksilver: strict to patch space-time leaks and lazy for definedness?
10:51:48 <dcoutts> lilac: so we should be careful about the circumstances in which we add such notices or warnings.
10:52:00 <byorgey> kig: point-free notation is not particularly an end in and of itself.
10:52:46 <byorgey> fillWith f m = f m >> fill  looks fine to me
10:54:30 <upsh9401_> If I have something thats like a monoid with out mzero, is that anything at all. Im trying to make a Choice monad, but the null option doesnt seem to be semanticly nessary, but is for monoid, and Alternative.
10:55:05 <Saizan> fillWith = (>=> const fill)
10:55:55 <quicksilver> conal: I actually meant lazy to avoid work.
10:56:08 <conal> quicksilver: oh, okay.
10:56:31 <Saizan> upsh9401_: in abstract algebra that's a magma
10:56:34 <quicksilver> conal: consider an Event (Geomatry2) for a clock which displays once per seoncd.
10:57:00 <upsh9401_> hmm
10:58:37 <lilac> dcoutts: it's probably possible to word the message so it implies that a later version exists without suggesting that it's desirable
10:59:02 <dcoutts> lilac: I'd welcome any suggestions added to that ticket
10:59:54 <kig> here the fillWith-stuff in context http://gist.github.com/34439
11:01:31 <edwardk> saizan: well, an associative magma - a semigroup
11:03:01 <Saizan> edwardk: oh, right
11:04:49 <conal> quicksilver: and?
11:05:09 <guenni> hi, what's the recommended gui toolkit, wxHaskel or rather gtk2hs?
11:07:17 <upsh9401_> Why is "ListT m a" like "m[a]" and not "[m a]"?
11:09:15 <lilac> dcoutts: done.
11:09:40 <dcoutts> lilac: ta
11:09:47 <Saizan> ?type sequence
11:09:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:09:58 <edwardk> upsh9401_: iirc there is an issue defining that version of bind in general.
11:10:19 <athos> @src sequence
11:10:19 <lambdabot> sequence []     = return []
11:10:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:10:20 <lambdabot> --OR
11:10:20 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:12:10 <athos> > sequence [Maybe 5, Maybe 6]
11:12:11 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe'
11:12:12 <edwardk> You can go from [m a] -> m [a] with sequence, but there isn't a general Monad m => m [a] -> [m a] law to distribute the other way. the common types of monad transformers can be constructed using a distributive law of one of three different forms. none of them work out the other way for all monads.
11:12:15 <Saizan> with m [a], join :: m [m [a]] -> m [a], and that's fmap join . join . fmap sequence
11:12:21 <athos> > sequence [Just 5, Just 6]
11:12:23 <lambdabot>   Just [5,6]
11:12:36 <MikeMayer> Hello and good morning
11:12:55 <upsh9401_> > sequence [Just 5, Nothing 6]
11:12:56 <lambdabot>   Couldn't match expected type `t1 -> Maybe t'
11:13:01 <upsh9401_> > sequence [Just 5, Nothing]
11:13:02 <lambdabot>   Nothing
11:13:25 <MikeMayer> dons: I just got my scores for my haskell homework that you (and others) assisted me with
11:13:28 <Saizan> however ListT defined that way is not really a tranformer either
11:13:34 <edwardk> yeah
11:13:37 <Saizan> ?google ListT done right
11:13:39 <MikeMayer> I got %100 - thanks everyone :)
11:13:44 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
11:13:44 <lambdabot> Title: ListT done right - HaskellWiki
11:13:47 <edwardk> congrats MikeMayer
11:18:04 <idnar> @instances Monoid
11:18:05 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:18:14 <idnar> why isn't there one for Either a b?
11:18:34 <mauke> what would it look like?
11:18:42 <idnar> actually, maybe I want mplus
11:18:59 <edwardk> Left 1 `mappend` Right True == ?
11:19:11 <edwardk> does left always win? right?
11:19:14 <Saizan> ?src Either mplus
11:19:14 <lambdabot> Left _ `mplus` n = n
11:19:14 <lambdabot> m      `mplus` _ = m
11:19:20 <idnar> where's that defined?
11:19:50 <Saizan> Control.Monad.Error
11:19:57 <athos> @hoogle mplus
11:19:57 <edwardk> heh saizan beat me to the punchline
11:19:57 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
11:20:01 <Saizan> but only for Error e => Either e
11:20:10 <znutar_> So does this ghc-pkg describe '*' --user behavior with an empty user package db mean you have to manually install a package as a user before you can use cabal?
11:20:14 <idnar> No instance for (Error ParseError)
11:20:14 <idnar> :(
11:21:19 <dcoutts> znutar_: no, it means you should upgrade cabal-install to version 0.6.x
11:21:37 <edwardk> the Error constraint on the Either monad always pisses me off
11:22:06 <edwardk> yet again, monad fails
11:22:14 <Saizan> heh
11:23:52 <rafting> is there eval in haskell?
11:24:20 <rafting> which ghc ships with ubuntu and mandriva now? 6.8 or 6.10?
11:24:27 <idnar> how do I turn 6 into "06"?
11:24:36 <idnar> 6 :: Integer, that is
11:24:42 <Deewiant> printf "%2d" 6
11:24:44 <Deewiant> ;-)
11:24:53 <rafting> ksf: bitrot? birotation?
11:24:55 <edwardk> there is eval inside of all of us. it is whether or not you choose to give in to it that decides whether or not you are a good person... look up the hsplugins stuff. does that still work?
11:25:06 <idnar> mmm
11:25:23 <idnar> printf is a bit ugly
11:25:30 <lilac> > let idnar 6 = "06" in idnar 6
11:25:31 <lambdabot>   "06"
11:25:32 <Saizan> idnar: see the Numeric module
11:25:47 <tromp> > const "06" 6
11:25:49 <lambdabot>   "06"
11:25:51 <idnar> Saizan: ah, thanks
11:25:53 <lilac> what, you wanted non-_|_ values for the other inputs?
11:25:56 <Deewiant> does Numeric have width padding?
11:26:51 <Saizan> , (fromJust . fromDynamic $ eval "\x -> x + 41") 1
11:26:55 <tromp> > ('0':).show $ 6
11:26:57 <lambdabot>   "06"
11:26:57 <lunabot>  luna: lexical error in string/character literal at character ' '
11:27:02 <lilac> > let idnar = reverse . take 2 . (++ repeat '0') . reverse . show in idnar 6
11:27:04 <lambdabot>   "06"
11:27:38 <lilac> > let idnar2 = take 2 . show . (100+) in idnar 6
11:27:39 <lambdabot>   Not in scope: `idnar'
11:27:42 <lilac> > let idnar2 = take 2 . show . (100+) in idnar2 6
11:27:44 <lambdabot>   "10"
11:27:49 <lilac> :(
11:28:00 <lilac> > let idnar2 = drop 1 . show . (100+) in idnar2 6
11:28:02 <lambdabot>   "06"
11:28:30 <Deewiant> idnar: seriously, I think printf might be the simplest choice here ;-)
11:28:46 <ksf> rafting, http://www.catb.org/jargon/html/B/bit-rot.html
11:29:27 <tromp> @hoogle printf
11:29:28 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
11:29:28 <lambdabot> module Text.Printf
11:29:28 <lambdabot> package printf-mauke
11:29:33 <athos> :t _|_
11:29:34 <lambdabot> parse error on input `|'
11:30:27 <tromp> > printf "%2d" 6
11:30:29 <lambdabot>   Add a type signature
11:30:34 <lilac> > (\a -> map toEnum [8*a, 9*a]) 6 :: String
11:30:36 <lambdabot>   "06"
11:30:51 <Deewiant> > (\a -> map toEnum [8*a, 9*a]) 600 :: String
11:30:52 <lambdabot>   "\4800\5400"
11:31:07 <lilac> > (\a -> map toEnum [8*a, 9*a]) 7 :: String
11:31:08 <lambdabot>   "8?"
11:31:13 <lilac> :)
11:31:16 <athos> ?
11:31:17 <athos> :o
11:31:30 <tromp> haha, lambdabot is not sure:)
11:31:36 <athos> > toEnum [1,2,3]
11:31:37 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
11:31:43 <athos> ai
11:31:46 <lilac> > (\a -> map toEnum [8*a, 9*a]) 5 :: String
11:31:48 <lambdabot>   "(-"
11:31:48 <athos> :t toEnum
11:31:49 <lambdabot> forall a. (Enum a) => Int -> a
11:31:58 <lilac> lambdabot: you forgot the :
11:32:03 <athos> > toEnum 5
11:32:04 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
11:32:20 <athos> > toEnum 5 :: String
11:32:21 <lambdabot>       No instance for (Enum String)
11:32:21 <lambdabot>        arising from a use of `toEnum' at ...
11:32:26 <Deewiant> ?check \a -> (fromEnum . last . map (toEnum :: Int -> Char)) [8*a,9*a] == a
11:32:28 <lambdabot>   "* Exception: Prelude.chr: bad argument
11:32:31 <Deewiant> :-P
11:33:02 <tromp> map chr ":-) (-:"
11:33:08 <tromp> > map chr ":-) (-:"
11:33:10 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
11:33:11 <Deewiant> > map ord ":-) (-:"
11:33:13 <lambdabot>   [58,45,41,32,40,45,58]
11:35:23 <tromp> > map succ "9,("
11:35:25 <lambdabot>   ":-)"
11:35:31 <hallongrottan> lol
11:36:06 <jberryman> that command turns a sad cyclops into a happy human
11:36:07 <Baughn_> Say, has anyone tried curve-matching the package count on hackage?
11:36:35 <smarmy> do we have access to historical counts?
11:36:50 <smarmy> i guess date is in the metadata, so yes
11:37:01 <Baughn_> I bet anyone who asked could get that, if it isn't
11:37:32 <Baughn_> It's just, I have the feeling it's at least exponential. It'd be nice to have that verified
11:37:37 <rafting> Baughn: give me the data il curve-match in 2 mkinutes
11:37:54 <Baughn_> rafting: Yes, see, extracting the data would be most of the work. :P
11:37:59 <rafting> I can do least-squares in scipy right now
11:38:03 <rafting> ok :P
11:38:18 <rafting> doesnt anyone have commit-data?
11:38:29 <Baughn_> I'm sure the maintainers do
11:38:40 <rafting> can anyone upload to hackage or you need to be confirmed?
11:38:50 <rafting> Baughn: and the maintainers are?
11:38:53 <Baughn_> You need to have an account, but that's just a formality
11:38:59 * Baughn_ checks
11:39:29 <Deewiant> http://hackage.haskell.org/packages/archive/log
11:39:45 <Deewiant> that's the full log AFAIK
11:40:00 <Baughn_> Hum. That looks nice and simple to massage
11:40:55 <rafting> awesome ill arse it and post here
11:40:55 <Shimei> Found this on reddit. It's a fun programming quiz, if somewhat frustrating: http://www.sporcle.com/games/csvocab.php
11:41:19 <Shimei> (also, non-fp bias in the quiz design :p)
11:43:43 <Baughn_> Shimei: You've seen the Euler problems, right?
11:46:14 <CyberGarp> dons, got a minute?
11:46:20 <Shimei> Baughn_: Yeah. I have an account there I think.
11:46:27 <Baughn_> Just checking
11:46:31 <lilac> > map (toEnum . floor . (\n -> 58.3 - 75.5*n + 126.2139*n^2 - 87.67*n^3+28.055*n^4-4.15*n^5+0.23056*n^6)) [0..6] :: String
11:46:33 <lambdabot>   ":-) )-:"
11:47:02 <Baughn_> lilac: *twitch*
11:48:33 <jberryman> anyone have a way to define a combinator (.:) to be able to compose something like f = (^2) . (+1) . (*2) .: (+)
11:49:13 <jberryman> I'm thinking I would have to not use (.) but define something else
11:50:18 <Azstal> @pl \f g a b -> f (g a b)
11:50:18 <lambdabot> (.) . (.)
11:50:25 <Azstal> thought so
11:50:33 <Deewiant> > let (.:) = (.)>>>(.) in (((^2) . (+1) . (*2)) .: (+)) 2 6
11:50:35 <lambdabot>   289
11:50:41 <mdmkolbe> I need some help with cabal.  If I say "cabal upgrade", I get back "cabal: Couldn't read cabal file "./yi/0.5.2/yi.cabal"".  What does that mean?
11:50:54 <blackh> jberryman: Do you just want to give . another name?
11:51:06 <int-e> @type (.)<$>(.)
11:51:08 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:51:13 <Deewiant> @type fmap fmap fmap
11:51:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:51:15 <Baughn_> mdmkolbe: Is there any chance some of those files are owned by another user?
11:51:17 <dcoutts> mdmkolbe: it probably means you're using cabal-install-0.5.x, try upgrading cabal-install first
11:51:26 <smarmy> http://spreadsheets.google.com/pub?key=p-1NdKGNifCo6IPkmdOzefg
11:51:31 <Baughn_> mdmkolbe: Try chown -R me:me ~/.cabal; chmod -R u+rw ~/.cabal just in case
11:51:40 <smarmy> hackage stats
11:51:53 <dcoutts> Baughn_: that'd give a different error message
11:52:30 <mdmkolbe> dcoutts: does the new cabal-isntall require ghc 6.10?  (The ubuntu version seems to still be at 6.8)
11:52:34 <Baughn_> Well, if it can't read it.. it's either not there, there's a permissions issue, or the FS is broken
11:52:46 <jberryman> blackh: I want to compose a sequence of functions where the last one is (a->b->c) rather than (a->b)
11:53:15 <dcoutts> mdmkolbe: no, it works with 6.6+
11:53:24 <dcoutts> actually it probably still works with ghc-6.4
11:54:20 <jberryman> Deewiant: can you point me to some info about (>>>)?
11:54:51 <Deewiant> ?ty (.).(.)
11:54:52 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:54:53 <Deewiant> ?ty (.)>>>(.)
11:54:54 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
11:55:04 <Deewiant> jberryman: (>>>) = flip (.) for functions
11:55:20 <Deewiant> in this case, it doesn't matter which you use, I just felt like >>> for some reason :-P
11:55:27 <mdmkolbe> dcoutts: ... and upgrade cabal-install complains about not having base >= 4.0
11:55:59 <jberryman> > let (.:) = (.)>>>(.) in (((*7) . (^2) . (+1) . (*2)) .: (+)) 2 6
11:56:00 <lambdabot>   2023
11:56:53 <jberryman> Deewiant: awesome! thanks. Where would I find that(>>>) function
11:57:04 <Deewiant> jberryman: Like said, just use (.) :-)
11:57:16 <jberryman> ok
11:57:20 <Deewiant> > let (.:) = (.)(.)(.) in (((*7) . (^2) . (+1) . (*2)) .: (+)) 2 6
11:57:21 <lambdabot>   2023
11:58:02 <jberryman> that last one is great on so many levels
11:58:43 <Megzlna> reminds me of the movie Total Recall
11:58:45 <blackh> jberryman: It is! compose dot with dot!
11:58:52 <lament> Megzlna: haha
11:58:54 <jberryman> exaaactly
12:01:53 <jberryman> can this please be known henceforth as the total recall combinator?
12:03:01 <saml> how can I parse things like "a + 1"  "1 - 43 + a + b"  ?  parsec's buildExpressionParser takes [[Operator]]  and Operator takes (a -> a -> a) for Infix. so, I can only parse 1 + 2, not a + 1 ?
12:03:24 <quicksilver> conal: ...and when the window is hidden, you don't want to waste work calculating the geometry ;)
12:03:28 <quicksilver> conal: sorry, I lost connection.
12:04:40 <dcoutts> mdmkolbe1: you still there?
12:04:56 <mdmkolbe1> dcoutts: I'm back
12:05:44 <mdmkolbe1> it looks like new cabal-install needs base >=4 which needs GHC 6.10 which hasn't been packaged for Ubuntu yet
12:05:46 <jberryman> saml: I wrote a big ugly chunk of code for converting expressions to reverse polish notation and evaluating them, etc. if you think that might be helpful. I know nothing about parsec however
12:06:10 <saml> jberryman, is this open source?
12:06:21 <saml> ah you did it manually
12:06:35 <dcoutts> mdmkolbe1: if you do cabal install cabal-install rather than upgrade then it should work.
12:07:06 * mdmkolbe1 tries it
12:07:19 <dcoutts> mdmkolbe1: cabal upgrade on it's own tries to upgrade everything you currently have installed, so that is the most likely thing to lead to a conflict
12:07:55 <dcoutts> mdmkolbe1: cabal upgrade foo  means to install foo and also to upgrade all the things foo depends on, which basically means all the core libs too
12:07:56 <Megzlna> jberryman: sure ;)
12:08:21 <dcoutts> mdmkolbe1: and the solver isn't very good yet at selecting older versions when the latest version cannot be installed.
12:11:04 <mdmkolbe1> dcoutts: that makes sense then.  So until I scrounge up a 6.10 GHC, are there any flags or such that I can use to let me keep my packages up to date instead of cabal upgrade?  (Like something to say "upgrade everything that doesn't require upgrading 'base'"?)
12:11:53 <dcoutts> mdmkolbe1: unfortunately not. You can install/upgrade specific things or lists of specific things and you can add maximum versions when you discover that the latest version needs base 4.
12:12:09 <dcoutts> mdmkolbe1: eg cabal install 'foo < 1.2' 'bar < 1.3'
12:12:20 <dcoutts> mdmkolbe1: and --dry-run -v is your friend
12:12:35 <rafting> eh
12:12:41 <Megzlna> What's as convenient as 'zip' but works on N lists?
12:12:56 <dcoutts> Megant: zip3, zip4, ...  !
12:13:00 <mdmkolbe1> dcoutts: ok thanks
12:13:07 <lament> Agda zip? :)
12:13:18 <Megzlna> dcoutts: why can't it take N ?
12:13:19 <mauke> transpose
12:13:26 <dcoutts> Megant: what type would it have?
12:13:31 <rafting> Baughn: so i parsed all the commits so I have a bunch of dates of modules uploaded to hackage. What do you want to know?
12:13:39 <Megzlna> dcoutts: a single tuple
12:13:44 <dcoutts> oopsm Megzlna, sorry Megant
12:13:50 <rafting> It just hit me I have a bunch of dates but as the functions of what
12:14:00 <dcoutts> @type zip
12:14:02 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
12:14:09 <lament> Megzlna: tuples of different length are unfortunately completely different types in haskell
12:14:27 <jberryman> saml: yeah, it's written in haskell sitting on my HD. and I'm happy to let anyone use it who wants to. again I'm sure it's pretty ugly
12:14:44 <Megzlna> lament: that's good
12:14:44 <Baughn_> rafting: Can you curve-match it and figure out some approximate function for it?
12:14:53 <Megzlna> since their structure is compile time
12:14:53 <dcoutts> Megzlna: the generic list of lists version is transpose, as mauke said
12:14:58 <lament> Megzlna: right
12:14:58 <Baughn_> rafting: Eg. is it polynomial, exponential, what?
12:15:05 <lament> Megzlna: which means there's no type for zipN
12:15:19 <Deewiant> Baughn_, rafting: the cumulative number of packages, or what?
12:15:27 <dcoutts> except to generalise to lists of lists instead of lists of tupils
12:15:41 <Baughn_> Cumulative number of packages. Checkins would be too subject to development style
12:18:25 <rafting> Baughn: well exactly does that mean? I could plot commits per day month or year(only 3 years)
12:18:55 <smarmy> i get a very close curve match over months at x^2.4+40
12:19:04 <Baughn_> rafting: Rolling average for a month, maybe?
12:22:27 <Megzlna> Are multiline list comprehensions uncommon?
12:22:34 <Megzlna> http://hpaste.org/12948
12:22:37 <Megzlna> looks a little odd
12:23:03 <Lemmih> Megzlna: Quite common.
12:23:21 <Megzlna> Lemmih: do they usually put the | on 1st line like that?
12:24:06 <Lemmih> I don't but whatever floats your boat.
12:27:49 <saml> > .1
12:27:50 <lambdabot>   <no location info>: parse error on input `.'
12:31:03 <rafting> where is the quickest way to post a picture?
12:31:21 <rafting> which i can link to? i have some plots of hackage-commits
12:31:33 <conal> quicksilver: "conal: ...and when the window is hidden, you don't want to waste work calculating the geometry ;)".  thx.  yes.  laziness is a big win in this situation.  we don't have to compute the geometry, nor its rendering.
12:33:49 <rafting> it seems like a fairly straight(increasing) line if plotting commits per day
12:34:33 <saml> rafting, imageshack.us ?
12:34:53 <rafting> yes thats the one
12:35:20 <camio> Anyone know of a split function in haskell somewhere? [a] -> [a] -> [[a]]? split "." "a.b.c" -> ["a","b","c"].
12:35:46 <Deewiant> Not in the standard libraries
12:35:57 <smarmy> rafting: linear per-unit plots make sense, as i get polynomial curves when plotting cumulative numbers
12:36:18 <camio> Ah well, I should probably be using parsec anyway. Is that still the best way to write quick parsers?
12:37:09 <Baughn_> camio: Yes, but not for this I think
12:37:13 <Baughn_> @src words
12:37:14 <lambdabot> words s = case dropWhile isSpace s of
12:37:14 <lambdabot>     "" -> []
12:37:14 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:37:24 <Baughn_> camio: Some things are just too simple. ;)
12:37:48 <Baughn_> Although.. you might be able to make it a one-liner with parsec. Hmm.
12:38:09 <camio> Baughn_: I need to parse filenames like asdfasdf-2.3.4rc3-inst.exe. I was going to use System.FilePath and split, but it seems parsec will be cleaner.
12:39:17 <Baughn_> camio: You'll still want to use FilePath to separate the directories; not every system uses /
12:39:18 <sm> g'day all.. is there an option for ghc --make that cleans up all intermediate build files ?
12:39:32 <camio> Baughn_: good point
12:40:01 <Baughn_> sm: Nope, but there is for cabal
12:40:13 <sm> hmm.. thanks
12:40:16 <Baughn_> sm: If you've gotten far enough to care about that, you should probably use cabal anyway. ;)
12:41:34 <Baughn_> Oh dear. Anyone know why xmonad fails to launch a terminal with M-S-key-I-rebound-to-return?
12:42:10 <rafting> http://img397.imageshack.us/img397/3193/hackagecommitslj5.png
12:42:24 <rafting> ^^ Hackage commit sperday 2006jan to 2008 dec
12:42:41 <rafting> x=dates, y = commits
12:43:32 <athos> red line = average?
12:44:06 <rafting> http://hackage.haskell.org/packages/archive/log
12:44:17 <rafting> athos: least-squares curve fitting
12:44:32 <athos> ok
12:45:25 <Baughn_> I was hoping for something more exponential, but it'll do. At least it /is/ increasing. :)
12:46:04 <rafting> yes
12:46:12 <rafting> ill plot per month too
12:47:04 <rafting> http://hpaste.org/12949
12:47:20 <rafting> ^^ there is the python-script for the plotting if anyone wants to paly with it
12:47:26 <rafting> or chekc fo correctness :)
12:53:48 <Megzlna> How can I have ?src on my own GHCI?
12:54:05 <mauke> @where goa
12:54:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
12:54:20 <orbitz> Megzlna: :list
12:54:25 <Megzlna> Goa is in India...
12:54:30 <orbitz> Megzlna: although doesn't work as good as @src
12:54:47 <Megzlna> will goa give me as good as @src ?
12:54:57 <evident> good evening everybody
12:54:57 <evident> :)
12:55:06 <mauke> goa integrates lambdabot and ghci
12:55:07 <orbitz> Megzlna: goa might even be what @src is
12:55:09 <mauke> not sure if it still works
12:55:14 <Megzlna> k
12:55:58 <evident> could anybody maybe tell me where my mistake is?
12:55:59 <evident> http://hpaste.org/12950
12:56:04 <evident> i just dont get it
12:56:04 <evident> :)
12:56:15 <mauke> it is evident
12:56:23 <evident> ^^
12:56:31 <Botje> what's the type of head [Char] ?
12:56:32 <mauke> "<" is a String. head xs is a Char
12:56:49 <evident> ahhh
12:56:50 <orbitz> == '<'
12:56:54 <evident> right
12:56:54 <Megzlna> the proper way to represent "temporaries" (what do you call them in haskell?) is with a type constructor?
12:56:58 <evident> stupid me
12:57:06 <orbitz> or just forwardToTag ('<':xs) = xs
12:57:07 <Megzlna> vector3 (1, 1, 1) ?
12:57:40 <Botje> Megzlna: uh, we just use let to temporarily bind values to names
12:57:42 <Megzlna> I want to have "*" be overloaded hence
12:57:50 <orbitz> or where
12:58:01 <Megzlna> Ok, so then how do I:
12:58:10 <orbitz> Megzlna: can't you make Vector an instance of the Num typeclas or wahtever
12:58:13 <evident> orbitz: and that works? Does it check whether the first char is a '<' ?
12:58:21 <Megzlna> (1,1,1) * (-1,Q,x)
12:58:30 <evident> never heard of writing it that way
12:58:30 <Megzlna> where the second is supposed to be
12:58:32 <orbitz> evident: check out pattern matching
12:58:36 <Megzlna> a quaternion ctor
12:58:46 <evident> hmm ok
12:58:46 <evident> thanks
12:58:47 <evident> :)
12:59:05 <orbitz> > let ('<':xs) = "<hi" in xs
12:59:06 <lambdabot>   "hi"
12:59:10 <Megzlna> orbitz: I dont want vector as an instance of Num because I need specific overloads
12:59:11 <orbitz> evident: see?
12:59:28 <orbitz> Megzlna: what do you mean?
12:59:35 <Megzlna> v3 * q
12:59:37 <Megzlna> q * v3
12:59:39 <orbitz> Megzlna: you ca ndefine * withotu it being an instance
12:59:40 * mornfall giggles in the background
12:59:45 <evident> well but i cant write it as a function that searches the list for the first '<' with pattern matching, or?
12:59:50 <Megzlna> orbitz: Yes, but...
12:59:52 <orbitz> Megzlna: i think at least
12:59:59 <Megzlna> that's why I asked how you specify "temporaries"
13:00:01 <Megzlna> like
13:00:02 <Megzlna> v3 (1,1,1)
13:00:11 <Megzlna> so that infixes work on that properly
13:00:18 <orbitz> i don't know what you mean by temporaries
13:00:18 <roconnor> Boy, rational numbers are a lot slower that floating point numbers. :)
13:00:20 <evident> > let ('<':xs) = "test<hi" in xs
13:00:22 <lambdabot>   "* Exception: /tmp/3539395907059256693:71:36-55: Irrefutable pattern failed...
13:00:38 <orbitz> evident: why don't yo ujust use dropwhile?
13:00:39 <Megzlna> orbitz: Values
13:00:51 <orbitz> > dropWhile (/='<') "test<hi"
13:00:52 <lambdabot>   "<hi"
13:00:54 <evident> hmm... that would solve my problem, too
13:00:54 <evident> :)
13:00:55 <Megzlna> a vector value explicitly constructed
13:00:57 <roconnor> > readFile "/tmp/3539395907059256693"
13:00:59 <lambdabot>   * Exception: "<IO [Char]>"
13:01:13 <evident> thx
13:01:17 <orbitz> Megzlna: let v3 = (1, 1, 1)
13:01:23 <roconnor> > unsafePerformIO $ readFile "/tmp/3539395907059256693"
13:01:24 <lambdabot>   Not in scope: `unsafePerformIO'
13:01:25 <Megzlna> but without let
13:01:35 <Megzlna> It's unusable if you have to use let
13:01:39 <orbitz> Megzlna: where v3 = (1, 1, 1)
13:01:46 <orbitz> Megzlna: i don't understand what you are askign then
13:01:51 <orbitz> Megzlna: just do (1, 1, 1) then?
13:02:08 <Megzlna> (v3 1 1 1 + (v3 2 2 2 * quaternion -1 x PI) )
13:02:09 <Megzlna> etc
13:02:22 <Megzlna> where the * is overloaded to rotate a vector
13:02:23 <orbitz> what is v3?
13:02:26 <orbitz> a function?
13:02:28 <Megzlna> vector 3 type
13:02:36 <orbitz> types start with upper case letter
13:02:49 <Megzlna> I know but I was giving an example of function form
13:02:52 <Megzlna> if that's usable
13:03:04 <orbitz> it's not really helpful if you don't specify what you are actually tryign to do
13:03:19 <orbitz> Megzlna: can't yo ujust defien * for type V3 and type whatever?
13:03:24 <Megzlna> Orbitz I have specified clearly
13:03:46 <orbitz> not clear enough for me apparently, and i'm the onlyone taking interest in your question right nwo
13:03:49 <geezusfreeek> Megzlna: i would recommend that you use a new operator instead of (*) for that
13:04:01 <Megzlna> freezusfreeek: why
13:04:12 <geezusfreeek> because Vector3 and Quaternion are different types
13:04:16 <geezusfreeek> no?
13:04:45 <Megzlna> they are different, but it's common-faire in every 3d lib to rotate via multiply
13:04:55 <geezusfreeek> meaning, as you said, it's not a good fit for Num
13:05:07 <geezusfreeek> what is wrong with a new operator?
13:05:21 <Megzlna> Well, first -- this is impossible right?
13:05:30 <geezusfreeek> Vector 1 1 1 + Vector 2 2 2 ^* quaternion blah bah blah
13:05:33 <Megzlna> since functions cannot have two signatures
13:05:34 <geezusfreeek> or whatever
13:05:57 <Megzlna> can * be overloaded for a given type?
13:06:01 <geezusfreeek> you could make another (*) definition, but from then on you would have to qualify which one you mean every time you use (*)
13:06:06 <maltem> Megzlna: The thing is, Num is defined in the Prelude and includes (*), so (*) is kind of stolen by the Prelude. You can of course redefine it, but that doesn't make things very clear. You may argue it's a Prelude bug :)
13:06:20 <geezusfreeek> i don't think it's a bug
13:06:22 <Megzlna> I don't fault Prelude for that
13:06:31 <Megzlna> I point towards "one signature only"
13:06:52 <geezusfreeek> what you are doing is not multiply, so it's not valid to use (*) and expect any sort of consistency
13:06:57 <Megzlna> What I want, is different functions dependent on the types involved
13:07:44 <Megzlna> geezusfreek: Ok, so perhaps this is a bad example then, however.
13:08:00 <Megzlna> What if user just wants to overload * for their BigNum type?
13:08:11 <geezusfreeek> why couldn't you do that?
13:08:12 <Megzlna> they want 21873187238127368176387162378681376 * 12376172836187236817263817236817632871263871623871623876123 to work
13:08:14 <orbitz> woudln't BigNum be par tof Num typeclass?
13:08:16 <geezusfreeek> that would be fine
13:08:20 <orbitz> in which cause you would defien (*)
13:08:24 <orbitz> case*
13:08:25 <maltem> Megzlna: they would write a Num instance
13:08:41 <Megzlna> So basically
13:08:47 <Megzlna> it has to be a Num or you're screwed.
13:09:32 <ikkebr> 270706345737349263494656168925648890967199961285553316289303723128208987719836509690711185248
13:09:41 <ikkebr> using windows calc
13:09:45 <Megzlna> lol.
13:09:51 <maltem> ...
13:09:52 <Megzlna> again with vector3
13:09:56 <ikkebr> haha j/k
13:09:57 <Megzlna> vector3 is not a num.
13:09:59 <ikkebr> pythonpowa
13:10:00 <Megzlna> But I want + to work.
13:10:28 <geezusfreeek> > 21873187238127368176387162378681376 * 12376172836187236817263817236817632871263871623871623876123
13:10:29 <lambdabot>   270706345737349263494656168925648890967199961285553316289303723128208987719...
13:10:33 <maltem> Megzlna: Replace (*) with (+) in the past discussion to get your answer
13:10:55 <geezusfreeek> Megzlna: (*) :: Num a => a -> a -> a
13:10:58 <Megzlna> It would not make sense to add Vector3 to Num instance, because then you'd be improperly stepping your bounds on constraints -- things accepting Num would expect a single element
13:11:02 <geezusfreeek> if you can formulate the problem that way you are okay
13:11:06 <geezusfreeek> otherwise, use something else
13:11:13 <maltem> Megzlna: the usual workaround is to define something like (^+), (^*)
13:11:15 <geezusfreeek> huh?
13:11:29 <geezusfreeek> what do you mean a "single element"?
13:12:04 <Megzlna> I mean this:
13:12:08 <Megzlna> > (1,1,1) + (2,2,2)
13:12:10 <lambdabot>       No instance for (Num (t, t1, t2))
13:12:10 <lambdabot>        arising from a use of `+' at <...
13:12:15 <geezusfreeek> there is nothing wrong with that
13:12:19 <geezusfreeek> it just isn't an instance of num
13:12:30 <Megzlna> Right, not would a Vector3 be
13:12:36 <Megzlna>       *nor
13:12:39 <geezusfreeek> define one
13:12:53 <geezusfreeek> instance Num a => Vector3 a where ...
13:13:01 <geezusfreeek> err
13:13:10 <geezusfreeek> instance Num a => Num (Vector3 a) where ...
13:13:15 <Megzlna> " things accepting Num would expect a single element"
13:13:21 <geezusfreeek> what is a single element?
13:13:23 <Megzlna> You're overstepping your boundary on constraints
13:13:45 <Megzlna> using any given 'Num' function would be ill formed
13:13:55 <geezusfreeek> i have defined instances of num for vectors before without violating anything (besides things like signum, which arguably is a prelude bug)
13:14:10 <geezusfreeek> can you say why, or are you just going to say the same thing over and over?
13:14:11 <Gracenotes> so... all functions take only one argument. *mind blown*
13:14:22 <maltem> geezusfreeek: how did you define (*), out of curiosity?
13:14:37 <smarmy> a vector is a "single element"
13:14:45 <maltem> geezusfreeek: or is that one of the "things like signum"? :)
13:14:48 <geezusfreeek> maltem: just component-wise
13:14:56 <maltem> hm ok
13:15:07 <Megzlna> a vector3 is not a Number.
13:15:16 <geezusfreeek> why not?
13:15:51 <Megzlna> geezusfreeek: Because it's only a Number insofar as you have to pervert Haskell due to inability to have multiple function signatures
13:15:58 <Megzlna> but no other good reasons
13:16:07 <Megzlna> The justification should not be the lack
13:16:12 <mauke> numbers are vectors
13:16:33 <Megzlna> but numbers aren't 3 vectors
13:16:38 <Megzlna> err, vector of 3
13:16:46 <mauke> why not?
13:17:01 <Megzlna> mauke, decompose 1 into a vector of 3
13:17:04 <geezusfreeek> 1 ==> Vector 1 0 0
13:17:07 <mauke> (1, 0, 0)
13:17:14 <mauke> complex numbers are pairs of reals
13:17:16 <Megzlna> that's dubious
13:17:23 <geezusfreeek> it's perfectly fine
13:18:07 <thoughtpolice> oi
13:18:07 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
13:18:14 <Eelis> Data.Generics question: i'm seeing strange ext1Q behavior; testcase here: http://rafb.net/p/HXhKxW85.html
13:18:15 <thoughtpolice> @/msg lambdabot @messages
13:18:15 <lambdabot> Not enough privileges
13:19:29 <thoughtpolice> @seen Lemmih
13:19:29 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I last heard Lemmih speak 55m 22s ago.
13:19:34 <Lemmih> thoughtpolice: Hey.
13:20:06 <thoughtpolice> Lemmih: I've got a patch sitting in my repo that will make the 'cabal install' procedure install lhc's base package after installing the compiler itself - but it requires us to have cabal 1.7
13:20:30 <thoughtpolice> and it also requires a Custom Setup.hs routine
13:20:45 <Lemmih> thoughtpolice: We also require cabal 1.7 for --lhc support, no?
13:20:45 <gbacon> ?ty (<*>)
13:20:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:20:57 <gbacon> ?ty ((Left 1) <*>)
13:20:58 <lambdabot> forall t a b. (Applicative (Either t), Num t) => Either t a -> Either t b
13:21:11 <gbacon> how does that typecheck?
13:21:28 <thoughtpolice> Lemmih: yeah
13:21:53 <thoughtpolice> Lemmih: http://hpaste.org/12951
13:22:02 <yitz> gbacon: it requires you to provide an Applicative instance for Either 1 - which would be really weird.
13:22:03 <Lemmih> thoughtpolice: Does it build 'base' by default? I use 'cabal install' for development so it needs to be fast.
13:22:16 <geezusfreeek> Megzlna: http://hpaste.org/12952
13:22:27 <gbacon> yitz: but how is 1 an a -> b?
13:23:07 <gbacon> > (Right (+3)) <*> (Right 2)
13:23:08 <lambdabot>       No instance for (Applicative (Either a))
13:23:08 <lambdabot>        arising from a use of `...
13:23:16 <Megzlna> somehow the prospect of  v3 `v+` v4 is rather uninviting
13:23:33 <thoughtpolice> Lemmih: it only builds/installs base after you do the 'cabal install' step (it's a post-installation hook,) but if you just go into lhc/ and do 'cabal install' and the lib/base dir already has been built, it won't take long
13:24:00 <geezusfreeek> Megzlna: you can't just make a real operator like ^* or something?
13:24:11 <yitz> gbacon: 1 is polymorphic, it could represent a function that you also give a Num instance. Perverted, but the typechecker doesn't express opinions.
13:24:20 <Megzlna> geezusfreeek: And what if somebody else is using ^* ?
13:24:26 <geezusfreeek> Vector3 x y z ^* Vector4 w' x' y' z' = ...
13:24:34 <geezusfreeek> Megzlna: that's what qualifiers are for
13:24:41 <geezusfreeek> if you ever run into such a situation
13:25:16 <thoughtpolice> Lemmih: so if you 'cabal install' it only should take a while if you modify the stuff in lib/base, otherwise it'll just install and install the already built .ho files, so it doesn't really take long, no
13:25:22 <gbacon> ?ty ((Left "sdfkj") <*>)
13:25:23 <dons> http://www.reddit.com/r/programming/comments/7io75/haskell_projects_reddit_use_reddit_to_suggest/ yay, for the masses
13:25:23 <lambdabot>     No instance for (Applicative (Either [Char]))
13:25:23 <lambdabot>       arising from a use of `<*>' at <interactive>:1:0-19
13:25:23 <lambdabot>     Possible fix:
13:25:25 <Lemmih> thoughtpolice: 'cabal install' in lib/base/ takes 7 seconds on my box.
13:25:46 <rafting> Baughn_: http://hpaste.org/12949#a1
13:25:48 <Lemmih> thoughtpolice: Can we add a flag like --no-base?
13:26:08 <thoughtpolice> Lemmih: we could probably work that in but I would need to talk to dcoutts
13:26:12 <gbacon> yitz: thanks
13:26:22 <Lemmih> thoughtpolice: -f no-base, maybe?
13:26:29 <thoughtpolice> Lemmih: all my patch does is add a lib/base/Setup.hs (because cabal needs it,) and then adds that Setup.hs to the build
13:26:54 <dcoutts> thoughtpolice: so what is this hyopthetical --no-base ?
13:27:18 <rafting> Baughn_: I changed it to plot the total number of uploads up to each date when anew commit is made. so if first commit is jan 6 2006 and second s jan 7 2006 then it will be on the y-axis, 1 and then 2.
13:27:22 <Lemmih> dcoutts: It's LHC specific. It shouldn't be added to Cabal.
13:27:29 <thoughtpolice> dcoutts: http://hpaste.org/12951 <- that's a Custom Setup.hs I wrote for lhc, that will install lhc's base package after the cabal-install procedure
13:27:52 <thoughtpolice> dcoutts: there a way we can have that be configurable, so you could do something like 'cabal install --no-base'? or is that unsupported?
13:28:21 <rafting> Baughn_: http://img261.imageshack.us/img261/7249/accumcommitsgp0.png
13:28:28 <rafting> everyone: http://img261.imageshack.us/img261/7249/accumcommitsgp0.png
13:28:31 <Lemmih> thoughtpolice: Perhaps we could use a custom field in the .cabal file.
13:28:32 <dcoutts> thoughtpolice: I would not put that in the lhc Setup.hs
13:28:38 <rafting> least-squares doesnt fit that very well though
13:28:56 <dcoutts> thoughtpolice: if you need something to automate the whole process then add a separate top level script
13:29:27 <dcoutts> thoughtpolice: think about what happens when someone makes a distro package for lhc, that extra bit will fail horribly
13:29:56 <Baughn_> rafting: Nope, that curve doesn't look linear at all. Are you sure your program would check for nonlinear curves?
13:30:24 <Lemmih> dcoutts: It would make lhc work from Hackage.
13:30:50 <Lemmih> thoughtpolice: Perhaps a --with-base flag would be better.
13:31:37 <rafting> http://img401.imageshack.us/img401/9486/acccommitsng8.png
13:31:50 <rafting> Baughn: no it doesnt
13:31:58 <smarmy> http://img505.imageshack.us/img505/7080/plotpo0.png
13:32:14 <smarmy> here's a plot of cummulative month-to-month with polynomial fit
13:32:23 <smarmy> y=x^2.425+77
13:32:29 <rafting> i plotted cummulative day to day
13:32:55 <rafting> BaughN: the first one i posted (linear one) was commits per day, the last cummulative per day
13:33:04 <rafting> http://img401.imageshack.us/img401/9486/acccommitsng8.png
13:34:17 <smarmy> even at a glance, quadradic cummulative seems intuitive, as the non-cummulative data is nearly linear
13:34:49 <Lemmih> thoughtpolice: We could add a conditional flag in the .cabal. If the flag is on, the 'build-base' field is set to true. That field can be read from the Setup.hs script.
13:35:15 <thoughtpolice> Lemmih: ok
13:36:05 <Lemmih> Yay, LHC will finally be usable straight from Hackage (:
13:36:11 <thoughtpolice> hopefully :)
13:37:58 <thoughtpolice> alright, bbl, i'll try to work on that tonight
13:38:52 <rafting> soryry last one was cummulative per commit, not per day. first was as said
13:39:12 <gbacon> ?pf \f g x -> f (g x) (g x)
13:39:13 <lambdabot> Maybe you meant: bf pl
13:39:14 <rafting> smarmy: what program do you use?
13:39:19 <gbacon> ?pl \f g x -> f (g x) (g x)
13:39:20 <lambdabot> join . liftM2
13:39:23 <dons> jeffersonheard: are there examples of thingie in action?
13:39:30 <smarmy> ghci, of course ;)
13:39:32 <dons> i'd love to see a blog post. code + resulting images..
13:41:42 <rafting> smarmy: of but for the plotting?
13:41:59 <gbacon> ?pl \f g x -> f x (g x)
13:41:59 <lambdabot> ap
13:42:28 <rafting> smarmy: can you paste the program?
13:42:33 <smarmy> oh, that's just excel.  i usually use gnuplot, but i used excel for the data grouping because pivottables do that effortlessly
13:44:05 <Cale> Speaking of which, I was just thinking to myself the other day that it's strange how open source implementations of spreadsheets seem to have converged on trying to copy Excel, as if it was the be-all and end-all of tabular computation.
13:44:49 <SamB_XP> as if
13:44:54 <Cale> There are so many obvious things you could do to be more convenient or expressive than Excel.
13:45:07 <smarmy> that would require change, and nobody likes that ;)
13:45:08 <flx> cale, sounds like you're going to write a spreadsheet some day now?-)
13:45:21 <dcoutts> like a nicer language for defining functions in cells?
13:45:22 <rafting> did you use some package to enter the data into excel?
13:45:37 <Cale> flx: There are a lot of things I should do. :)
13:45:46 <Cale> dcoutts: For one, yes :)
13:46:46 <smarmy> rafting: no.  i just pasted it in.  pulled out the date components.  then some pivottable magic.  nothing i couldn't have done with a quick script, but sometimes its fastest to just chug through it using a familiar tool
13:47:21 <Cale> One of the things which always bothers me about working with spreadsheets is that the only way to impose structure on the initially blank canvas you're given is to write formulas into individual cells and perhaps copy and paste/drag-extend them down to make more.
13:47:22 <rafting> you pasted it how? i dont have excel but I have openoffice
13:47:25 <rafting> Mon Mar  5 14:54:01 UTC 2007 ChrisKuklewicz regex-compat 0.90
13:47:32 <rafting> you just paste that into a cell?
13:49:05 <Cale> Which means you can't really get to a point where you just enter data, you always have to be prepared to copy cells with formulas. (That is, unless you're going to do custom scripting)
13:49:48 <smarmy> rafting: excels klunky in this case... i just happend to know it well.  a script would be better.  but yeah, just paste and fiddle.  some formulas to tear apart each line.  that sort of thing.  kludgy, but fast when you just need the data for some geeky chatroom math expedition
13:50:26 <repnop> that's the same reason spreadsheets are easy for non-programmers to use
13:50:42 <repnop> at least initially...and then the suffering begins once they realize what a mess they've built :)
13:51:08 <rafting> ok
13:51:10 <smarmy> repnop: very true.  i find excel bliss for small n ;)
13:52:35 <yitz> Cale: usually you type in some labels, enter data down a column or two using enter, put in a formula and drag it down by the corner, hit the sum button in one cell, and you're done.
13:52:59 <Cale> yitz: yeah, it's that process of having to manually extend the list whenever it fills up which I don't like
13:53:01 <yitz> Cale: not that I like spreadsheets - I usually use ghci instead
13:53:46 <Cale> There should be a way to define a repeating pattern.
13:54:01 <yitz> Cale: then you start moving blocks around, and after a while the spreadsheet gets confused and you have to re-enter stuff
13:54:10 <Cale> heh
13:54:11 <smarmy> cale: what do you mean?
13:55:12 <Cale> smarmy: I mean that generally you have a bunch of blocks which have similar formulas (of course with formulas in them retargeted to the appropriate cells), and those blocks repeat downward or across.
13:56:04 <Cale> smarmy: and you might make a bunch of these to start with, but when they fill up, you have to make more manually -- in simple cases by selecting and dragging the corner box, and in more complicated ones by copying and pasting cells
13:57:03 <smarmy> good point.  to some extent, excel has some tricks.  for example, you can highlight a block of forumlas and when you drag it, the entire thing is copied block for block, preserving the structure
13:57:09 <Cale> smarmy: This is something which is common to almost every spreadsheet in existence. There should be a way to tell the spreadsheet what your pattern is, so that it can make you a new blank bunch of fields whenever you fill the last one up.
13:57:16 <smarmy> but yeah, it gets difficult fast as you ask more of it
13:58:21 <Cale> Also, it's silly to always have to refer to cells by position rather than being able to give them names. (Newer Excels have some guessing that they can do here, iirc, but it's not perfect.)
13:58:49 <mrd> pretty sure you can set some kind of aliases up
13:58:53 <StoneToad> is there a way to declare datatypes in ghci?
13:59:13 <cpriester> Sorry for asking again, but i cannot get that FFI to work. Would anyone like to have a look at http://haskell.pastebin.com/m52352dc4 ?
13:59:21 <mrd> StoneToad: no
13:59:27 <StoneToad> arg :/
13:59:28 <mrd> StoneToad: :load file.hs
13:59:29 <cpriester> I alawys get segfaults.
13:59:32 <smarmy> cale: excel lets you label cells, but to your point, it gets kludgy fast as you being copying and manipulating
13:59:38 <StoneToad> mrd: thx
13:59:51 <kpreid> Cale: I'm curious: does the end point of that not become a relational database?
14:00:13 <Heffalump> most people using Excel for big complicated things add lots of stuff to try to rectify some of these issues :-)
14:00:18 <kpreid> er...I don't mean exactly that. But a bunch of separate grids, each with a record type
14:00:26 <Heffalump> I think the ideal thing would be some kind of canvas on which you can draw multiple grids as you need them.
14:00:41 <kpreid> + computed fields and ordered rows with references
14:01:03 <Heffalump> kpreid: you sometimes want to be more free-form than having a record type
14:01:10 <kpreid> right
14:01:19 <Cale> kpreid: What you want is basically something in between current spreadsheets and relational databases.
14:01:19 <kpreid> the question is, what is the interesting middle ground?
14:01:23 <Cale> yeah
14:01:39 <kpreid> I'm interested in this myself, it's a type of app I've given some small thought to
14:02:05 <Heffalump> I think lots of small grids, each dynamically growable, with links between them, is the way to go.
14:02:36 <kpreid> doesn't Apple's Numbers do that?
14:03:01 <Heffalump> no idea, it usually takes quite a lot to get me touch Apple's stuff even with a bargepole
14:03:38 <dons> Heffalump: did you see my note about amazon.co.uk?
14:03:38 <damkor> Hi
14:03:42 <ozy`> yes, that's what Numbers does
14:03:43 <Heffalump> dons: no
14:04:01 <dons> i think they just under-estimated the demand, but they've confirmed they're back to a 'expected to ship in 2-3 days' timetable
14:04:32 <damkor> can anyone help me create a table (not layout table but ordinary widget) in gtk2hs? I'm lost with models and renderers and I really don't know what's happening
14:04:38 <Heffalump> I'll check my account nw
14:05:07 <dcoutts> damkor: do you mean a list/tree view?
14:05:16 <damkor> Maybe, I don't know
14:05:18 <dcoutts> damkor: have you looked at the demos?
14:05:25 <damkor> I mean, that's what I'm using right now
14:05:29 <dons> Heffalump: i hope that means you won't actually have to wait till after xmas. but seems like i can put more pressure on if you need it.
14:05:34 <damkor> yes, but it seems like everyone is using glade
14:05:41 <damkor> and I really don't want to use glade
14:05:46 <dons> we got in contact with amazon.co.uk people who explained the process
14:05:54 <Heffalump> I'm impressed they talked to you
14:05:55 <yitz> dons: given a choice between the two alternatives, I guess "under-estimated demand" is the preferred one.
14:06:10 <dons> Heffalump: i was surprised!
14:06:16 <dcoutts> damkor: glade doesn't help much with making tree/list views, you have to set up the columns and cell renderers etc
14:06:28 <Heffalump> it claims to have dispatched today
14:06:31 <dons> woo!
14:06:36 <damkor> exactly, that's where I'm stuck
14:06:37 <dons> ok. so that's an improvement.
14:06:38 <dcoutts> damkor: so which demo have you looked at already?
14:06:50 <damkor> I can create one-column tables
14:06:55 <damkor> and they work just fine
14:07:18 <dcoutts> one column list views
14:07:36 <damkor> sorry, yeap, one column list views
14:08:09 <dcoutts> damkor: so that's using eg: treeViewAppendColumn view col1
14:08:23 <dcoutts> so adding more columns follows the same pattern
14:08:30 <damkor> I went through the examples that come with the documentation, and tried to guess by the names which ones might have something to do with 'tables' (aka. multi-column list views)
14:08:51 <damkor> and all I found was using glade or was not realted to listviews
14:08:55 <dcoutts> damkor: you're looking at demo/treeList/ListDemo.hs right?
14:09:05 <dcoutts> it doesn't import glade
14:09:58 <damkor> hmm, surprisingly enough, I don't have that one
14:10:01 <damkor> let me see
14:11:11 <damkor> Nope, my bad, I do have
14:11:13 <damkor> I do have it
14:11:47 <damkor> I don't understand how the model can use a Phone as an argument
14:11:52 <dcoutts> great, that demo makes a three column TreeView using a ListModel
14:12:27 <dcoutts> damkor: it makes a ListModel Phone, that is a list of Phone values
14:12:51 <dcoutts> erm ListStore
14:12:53 <damkor> yeap, but my question is: what value can I provide as argument to the model data type constructor
14:12:56 <damkor> ?
14:13:11 <dcoutts> whatever type your model is of
14:13:17 <dcoutts> your model contains some data type
14:13:18 <damkor> I mean, what can I provide, (does it have to instance show in all fields or something)
14:13:18 <dcoutts> what is it?
14:13:25 <damkor> ?
14:13:31 <dcoutts> no restriction
14:13:45 <edwardk> all i can say is that any product named glade needs to allow plugins
14:14:03 <dcoutts> edwardk: heh heh, and I rather suspect that it does :-)
14:14:24 <dcoutts> edwardk: hmm, or perhaps the other way around, you can embed (plugin?) glade into other apps
14:14:49 <dcoutts> damkor: you use your own custom functions to define the relationship between values from your model and the cell renderer attributes
14:15:08 <damkor> ok, now I understand
14:15:14 <damkor> cheers
14:15:17 <dcoutts> damkor: see the lines cellLayoutSetAttributes
14:16:08 <camio> Anyone know of a cross-platform way to get the modify time of a file?
14:16:24 <damkor> yeap, I see it is using number to extract the value from a Phone
14:16:35 <damkor> now I think I do understand it :) thanks
14:16:40 <dcoutts> damkor: great
14:17:00 <dcoutts> @hoogle getModificationTime
14:17:00 <lambdabot> System.Directory getModificationTime :: FilePath -> IO ClockTime
14:17:04 <dcoutts> camio: ^^
14:17:10 <camio> oops!
14:17:12 <camio> thanks
14:18:24 <cjb> woo!  I got me a RWH.
14:18:32 <cjb> it was on the shelves at the MIT Coop today
14:18:47 <Heffalump> mine shipped today
14:19:01 <Heffalump> despite the email late last night saying it would be weeks
14:19:24 <cjb> oh, that's good
14:19:27 <kosmikus> Heffalump: hey, then there might be hope for me as well
14:19:29 <mapreduce> I noticed it on amazon; not too bad a price.
14:20:34 <dons> cjb: wow. awesome.
14:20:49 <dons> kosmikus: through amazon.co.uk ? or .de?
14:21:00 <kosmikus> dons: .de in my case
14:21:03 <dons> it seems like we can lean on them a bit, if anyone's having trouble
14:21:20 <kosmikus> they told me a week ago that it'll be delayed until at least dec 18
14:21:29 <dons> oh. hmm. amazon.de?
14:21:33 <kosmikus> yes
14:21:44 <dons> ok. i'll mail o'reilly. worked for amazon.co.uk ... so might work twice
14:22:11 <kosmikus> they list the book as available, but "versandfertig in 12 bis 14 Tagen"
14:22:24 <dons> yeah, that's what amazon.co.uk said too -- but apparently it was incorrect.
14:22:24 <kosmikus> a bit strange
14:22:42 <dons> they'd just made a gap between running out of copies, and reordering more.
14:22:47 <kosmikus> well, I can wait a bit longer
14:22:56 <dons> which resulted in people getting mails saying not till the new year :/
14:23:13 <dons> good reason to order from oreilly directly, imo.
14:23:20 <dons> people who did that already have copies in .de
14:23:44 <luite> dons: oh, I forgot to ask for it on the blog, do you know if there is a sample of the electronic version (pdf) somewhere? I remember some people complaining about fonts (and I can't change the pdf reader on my eink device)
14:24:05 <dons> a sample? hmm. there was one person using some device that had unusual fonts
14:24:15 <dons> but otherwise there's been no issues.
14:24:33 <doublec> I see the occasional glitchy character in the pdf
14:24:37 <dons> poke around on the oreilly page, they may have demos
14:24:48 <doublec> but it's nothing big
14:24:58 <dons> keith falgren should be pretty responsive if you mention it on the blog
14:24:59 <luite> doublec: which reader software or hardware?
14:25:04 <dons> he's the main guy technically who can help at oreilly
14:25:26 <doublec> mobireader on my phone and on windows. I'm pretty sure they were there with acrobat on windows too - let me check
14:26:06 <luite> that's not pdf, right?
14:27:59 <cjb> oh!  I wasn't expecting my name to be in it, I just made a handful of comments.  woot!
14:28:24 <dons> if you commented with your name you got in.
14:28:31 <dons> so pity for the 'anonymous' users
14:28:54 <cjb> that's great.
14:28:56 <doublec> luite: correct, mobireader is something different
14:29:13 <dons> doublec: i'd love to see a phhhoto
14:29:18 <doublec> in mobireader all single quotations in things you "you're" appear as 3 block characters
14:29:49 <doublec> dons, a photo of the problem, or a photo of rwh on my phone?
14:30:50 <dons> a photo of rwh on your phone.
14:30:55 <doublec> luite: just checked the pdf, the characters display fine
14:31:01 <dons> i'm very interested in seeing what its like on different mobile devices
14:31:05 <doublec> dons, sure, I'll send you one when I get home
14:31:13 <dons> photos of problems are likely to lead to fixes, too
14:32:24 <dons> ?users
14:32:24 <lambdabot> Maximum users seen in #haskell: 578, currently: 555 (96.0%), active: 18 (3.2%)
14:32:31 <mathijs> Hi all, I'm looking for a (demo) sql parser. I found an example of it that uses rparsec, which is a ruby port of parsec, but the syntax/structure is quite hacky. I would expect haskell's parsec to have some sql-parsing examples too?
14:32:51 <dons> mathijs: hmm
14:33:04 <dons> good question
14:33:17 <porges> reexporting modules: do I just put the module name in the export list?
14:33:37 <devragert> i have a question
14:33:53 <dons> porges: yes.
14:33:55 <dons> devragert: ask it!
14:33:56 <erikc> heh, i just delivered a scathing c++ rant / haskell pimpage at work (we had Scott Meyer doing c++ training here this week and ppl were wondering what I thought about c++0x)
14:33:58 <devragert> why does this not work:
14:33:59 <mathijs> thanks :)  I don't feel like 'porting' the example back to haskell, feels awkward if no such thing is available in haskell itself
14:34:41 <devragert> f ("<":s) = "(":s    -- I want to make a parser
14:35:49 <Raevel> i'm guessing s is a string, so "<" and "(" should be '<' and '(' since cons is a -> [a] -> [a]
14:36:23 <wli> erikc: Do tell.
14:37:32 <devragert> ah, that solved the problem
14:37:34 <devragert> thanks!
14:37:43 <quicksilver> conal: so, the point is that unfortunately we sometimes want laziness and sometimes want strictness. Still hopefully common useful cases will become clear as we keep exploring.
14:39:43 <erikc> wli: just ppl being really excited about c++0x features and thinking they were 'new', had to set the record straight
14:40:15 <erikc> i prolly sold a few copies of RWH in the process tho
14:40:51 <wli> I wish some FPL gurus would get together and hammer out an imperative language worth its salt. C/C++/Java/etc. suck even as such go.
14:40:55 <devragert> How do i do something like: f (string1:'+':string2) = string1:'*':string2
14:41:21 <erikc> i also argued it was easier to learn advanced c++ programming by learning haskell
14:41:59 <erikc> since a lot of advanced c++ template wankery is just typeclasses
14:42:45 <wli> (Actually mutatis mutandis for logic languages, since Mercury seems to have fizzled out.)
14:43:38 <twanvl> wli: what is wrong with C/C++/Java as imperative languages?
14:43:56 <mapreduce> twanvl: They lack lambdas.
14:44:01 <dons> erikc: haha.
14:44:02 <pumpkin_snorkel> about c++ in particular :P http://yosefk.com/c++fqa/defective.html
14:44:17 <evident23> hey guys i have a little problem:
14:44:17 <evident23> http://hpaste.org/12954
14:44:36 <evident23> it's a bit more complex
14:44:37 <evident23> :)
14:44:57 <rafting> is there an eval-function in Haskell?
14:45:47 <dons> not for casual use, rafting. usually you just want 'read'
14:45:55 <dons> > read "1" :: Integer
14:45:58 <lambdabot>   1
14:46:07 <wli> I don't know that lambdas are the crucial bit wrt. the flaws of the predominant imperative languages.
14:46:27 <redditbot> Parallel Join Patterns with Guards and Propagation in Haskell
14:46:42 <mapreduce> wli: Well, only C, C++ and Java really.  They're in everything else I can think of.
14:46:51 <wli> I'd literally say that the module systems and/or lacks thereof are vastly higher up the list of problems.
14:46:56 <mapreduce> Unless COBOL is still predominant.
14:47:24 <twanvl> evident23: try using span instead of takeWhile
14:49:18 <evident23> why that, twanvl? arent they equivalent?
14:50:13 <twanvl> devragert: do you want to match a string containing a '+' anywhere?
14:50:46 <yitz> evident23: dropWhile takes a test function on the type of the *content* of the list, not of the list
14:50:58 <ozy`> rafting: to be clear on the "eval" function, there's no function that will take a string and actually execute code (definitions and such)
14:51:14 <wli> I'd literally say that a first-order language is fine. Just drop in a reasonable type system and a higher-order module system.
14:51:20 <yitz> > dropWhile (/= [3,4]) [1,2,3,4]
14:51:21 <lambdabot>       No instance for (Num [t])
14:51:22 <lambdabot>        arising from the literal `1' at <inter...
14:51:28 <yitz> > dropWhile (/= 3) [1,2,3,4]
14:51:29 <lambdabot>   [3,4]
14:52:01 <twanvl> > break (==3) [1,2,3,4]
14:52:02 <lambdabot>   ([1,2],[3,4])
14:52:12 <evident23> well, i think one way to solve it is to use dropwhile (/= tag) string
14:52:20 <rafting> so how do you do genetic programming? write a program to a file then execute that file? but that would be dynamic too, isnt genetic programming dynamic by nature?
14:52:37 <evident23> with tag being ie "<Tag>"
14:52:49 <evident23> but that doesnt work because
14:53:01 <evident23> dropwhile only checks for each char
14:53:08 <yitz> evident23: exactly
14:53:12 <sjanssen> rafting: you could generate an AST and interpret the AST
14:53:16 <twanvl> evident23: instead of first finding the tag and then splitting, why not split at once?
14:53:20 <ozy`> rafting: you could write an interpreter for a custom language
14:53:30 <sjanssen> rafting: nothing says the generated language has to be the same as the host language
14:53:47 <evident23> how do i do that?
14:54:08 <wli> Is there a break where the breaking element is put into the first list?
14:54:16 <rafting> sjannsen: at runtime? doesnt that reasoning go into infinite recursion?
14:54:17 <evident23> the problem is I dont know very many functions yet, and I am told to use the functions i already learned
14:54:24 <evident23> (the problem is for a homework)
14:54:29 <sjanssen> rafting: but there are also various tools like hs-plugins and GHC API for executing Haskell code at runtime
14:54:33 <sjanssen> rafting: no, it doesn't
14:54:48 <twanvl> wli: unfortunately, no, nor is there one that returns Maybe ([a],[a])
14:55:02 <sjanssen> rafting: you design a language, generate code in that language, and execute that code with an interpreter written in Haskell
14:55:17 <rafting> so basically sjannsen I should write a little lisp-interpreter to do genetic programming :) ?
14:55:31 <sjanssen> rafting: sure, you could do that
14:55:51 <sjanssen> rafting: if you're set on using Haskell, use one of the various options for executing Haskell code at runtime
14:56:03 <evident23> is there a function that locates a substring in a string and tells me where it is?
14:56:18 <evident23> twanvl, what did you mean by splitting it first
14:56:20 <evident23> ?
14:56:24 <Botje> no, but you can combine functions to make it so
14:56:35 <twanvl> evident23: in your code, you first find a tag in extractTag
14:56:42 <evident23> right
14:56:42 <leimy> the answer is there is such a function, but it hasn't been realized in code :-)
14:56:58 <twanvl> evident23: at that time you know where it is, and you takeWhile everything up to the closing '>'
14:56:59 <Botje> combine tails, isPrefixOf and zip in the appropriate way
14:57:12 <ddarius> @src isInfixOf
14:57:12 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
14:57:18 <twanvl> evident23: then at that time, you can also easily know what comes after that tag, using dropWhile
14:57:50 <leimy> > isInfixOf "poop" "a pooper"
14:57:51 <lambdabot>   True
14:58:20 <ddarius> Also, it would usually be more useful to simply return the remainder of the list rather than an index.
14:58:39 <evident23> well but when i find the first "tag" with extractTag, i havent checked whether it is a valid one yet... so it searches on from taht point in the function checkIfTag
14:58:49 <leimy> > zip [1..] "Hello"
14:58:51 <lambdabot>   [(1,'H'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
14:58:56 <evident23> therefore I lose the position of the tag, dont I?
15:00:04 <conal> quicksilver: and nonstrictness is crucial for semantics
15:00:08 <conal> (some nonstrictness)
15:00:09 <twanvl> evident23: but you don't need the position, just the part of the string that comes after it
15:00:19 <devragert> Can someone explain me how the "<-
15:00:27 <devragert> Can someone explain me how the "<-" thing works?
15:00:48 <sjanssen> devragert: in which context?
15:00:50 <erikc> hmm...how do i go about fixing this aspect of haddock: Warning: The documentation for the following packages are not installed.
15:01:26 <evident23> well but how do i seperate that rest out of the string? sorry, but i dont get it yet
15:01:38 <devragert> for example in: factors = [ p | p <- [1..n] , mod n p == 0 ]
15:01:41 <erikc> how do i pull the documentation for certain packages?
15:01:53 <leimy> :browse
15:01:58 <leimy> IIRC
15:02:16 <devragert> i mean: factors n = [ p | p <- [1..n] , mod n p == 0 ]
15:02:17 <twanvl> evident23: extractTag "foo<tag>bar" == "<tag>", right?
15:02:21 <BONUS_> > [p*2 | p <- [1..5]]
15:02:21 <lambdabot>   mueval: Prelude.read: no parse
15:02:27 <sjanssen> devragert: in that list comprehension, it means that p takes on every value from 1 to n
15:02:36 <Botje> evident23: find (\x -> needle `isPrefixOf` (snd x)) $ zip [0..] $ tails haystack
15:02:50 <sjanssen> > [p | p <- [ 1 .. 5]]
15:02:52 <lambdabot>   [1,2,3,4,5]
15:02:55 <porges> what's the easiest way to find where an instance for a specific type is defined?
15:03:06 <leimy> > [1..5]
15:03:08 <lambdabot>   [1,2,3,4,5]
15:03:20 <sjanssen> porges: in ghci, :info Type
15:03:24 <evident23> yes@twanvl
15:03:41 <evident23> @botje, wait i will try yours in a minute... information flood... :)
15:03:42 <lunabot>  :)
15:03:42 <lambdabot> Unknown command, try @list
15:03:47 <devragert> and why do i get such strange results when i write [n | n <- [1..3], n <- [1..3]]
15:03:54 <twanvl> evident23: what if you make it return ("<tag>","bar") instead, i.e. (theTagJustMatched, stuffAfterIt)
15:04:05 <sjanssen> devragert: the second "n <-" shadows the first
15:04:06 <leimy> > take 5 $ concat [1..] [2..]
15:04:08 <lambdabot>   Couldn't match expected type `[t] -> [a]'
15:04:11 <leimy> ahhh
15:04:18 <leimy> right
15:04:31 <porges> sjanssen: thx
15:04:34 <sjanssen> > [(n, m) | n <- [1 .. 3], m <- [1 .. 3]] -- list comprehensions make the cartesion product
15:04:36 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:04:46 <sjanssen> s/cartesion/cartesian
15:04:48 <evident23> ahh thats an idea
15:04:53 <evident23> i will try...
15:05:04 <ddarius> devragert: Do you know SQL?
15:05:04 <evident23> (but first i will try to find out what botje meant
15:05:08 <evident23> but that's an idea
15:05:09 <evident23> :)
15:05:09 <sjanssen> @undo [n | n <- [1..3], n  <- [1..3]]
15:05:10 <lambdabot> concatMap (\ n -> concatMap (\ n -> [n]) [1 .. 3]) [1 .. 3]
15:05:19 <Gracenotes> sjanssen: oh, just like a set definition
15:05:21 <devragert> but how is the mechanism behind [ n | ? ]
15:05:44 <sjanssen> Gracenotes: yep, list comprehensions are inspired by the set notation in math
15:06:05 <devragert> why for example does it work in such an environment, and not when i just type: n <- [1..3]
15:06:09 <sjanssen> devragert: you can see the Haskell report for the translation, or play around with lambdabot's @undo command
15:06:10 <leimy> > take 10  $ zipWith (:) [1..] [2..]
15:06:12 <lambdabot>       No instance for (Enum [a])
15:06:12 <lambdabot>        arising from the arithmetic sequence ...
15:06:30 <sjanssen> devragert: the syntax only works as part of a list comprehension (or do block)
15:06:33 <Botje> devragert: it only works in the form [ ... | ... <- ... ]
15:06:45 <devragert> ok
15:07:01 <BONUS_> > take 10 $ zipWith (:) [1..] (map return [2..])
15:07:02 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11]]
15:07:14 <leimy> that's close :-)
15:08:21 <roconnor> > zip`ap`tail $ [1..11]
15:08:23 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
15:08:42 <leimy> :type ap
15:08:54 <roconnor> @quote zip`ap`tail
15:08:55 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:09:01 <sjanssen> what is the goal here?
15:09:05 <devragert> and does anyone have a tip how to make an ordinary parser?
15:09:14 <elliottt> ordinary how?
15:09:28 <devragert> for example, when i want to turn "x+y" into Sum x y
15:09:36 <roconnor> @type ap
15:09:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:09:40 <devragert> (Sum is data constructor)
15:09:44 <leimy> > take 10 $ concat $ zipWith (:) [1..] (map return 2[..])
15:09:46 <lambdabot>   <no location info>: parse error on input `..'
15:09:49 <leimy> oops!
15:09:58 <elliottt> devragert: you could use parsec
15:09:59 <_MaK_> > take 10 $ [[x,x+1] | x<-[1..]]
15:10:00 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11]]
15:10:05 <elliottt> devragert: or alex and happy
15:10:08 <leimy> >take 10 $ concat  $ zipWith (:) [1..] (map return [2..])
15:10:13 <elliottt> devragert: or just happy with a custom lexer
15:10:20 <sjanssen> > take 10 $ transpose [[1 ..], [2..]]
15:10:22 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11]]
15:10:23 <roconnor> need a space after >
15:10:27 <leimy> TRANSPOSE
15:10:31 <leimy> that's what I was looking for
15:10:37 <_MaK_> ;]
15:10:41 <ddarius> transpose is underappreciated.
15:10:43 <devragert> so parsec alex and happy are existing parsers i suppose?
15:10:44 <leimy> indeed
15:10:56 <Gracenotes> > [ (a, b, c) | a <- [1..20], b <- [1..20], c <- [1..20], a < b, a^2 + b^2 == c^2]
15:10:58 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
15:11:10 <elliottt> devragert: alex is a lexer generator, happy is a parser generator, and parsec is a parser combinator library
15:11:11 <ddarius> devragert: Parsec is a library for making parsers.  Alex is a tool for generating lexers.  Happy is a tool for generating parsers.
15:11:14 <sjanssen> devragert: happy is a parser generator, parsec is a set of parser combinators
15:11:14 <Gracenotes> nice...
15:11:19 <leimy> > take 10 $ concat $ transpose [[1..] [2..]]
15:11:20 <lambdabot>   Couldn't match expected type `t -> [a]'
15:11:22 <hallongrottan> Gracenotes: nice one, euler?
15:11:22 <sjanssen> @quote stereo
15:11:23 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
15:11:47 <leimy> need a comma :-)
15:11:58 <wli> > let p = (=='f') in let (_, l, r) = foldr (\x (q, l, r) -> if q then (q, l, x : r) else if p x then (True, l, x : r) else (q, x : l, r)) (False, [], []) ['a'..'j'] in (r, l)
15:11:58 <devragert> what is the difference between a parser generator and a parser maker?
15:11:59 <leimy> > take 10 $ concat $ transpose [[1..],  [2..]]
15:12:00 <lambdabot>   ("abcdef","ghij")
15:12:00 <lambdabot>   [1,2,2,3,3,4,4,5,5,6]
15:12:23 <ddarius> > tail $ concatMap (\x -> [x,x]) [1..]
15:12:24 <lambdabot>   [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,1...
15:12:32 <_MaK_> @type transpose
15:12:32 <jeffwheeler> ?src transpose
15:12:32 <lambdabot> transpose []             = []
15:12:32 <lambdabot> transpose ([]   : xss)   = transpose xss
15:12:32 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:12:33 <lambdabot> forall a. [[a]] -> [[a]]
15:12:35 <Gracenotes> hallongrottan: nah. probably not the most efficient way to do it either...
15:12:47 <elliottt> devragert: the parser generator takes a specification, and generates a parser from it, while the parser maker just lets you write haskell code as the parser
15:13:03 <elliottt> devragert: http://www.haskell.org/haskellwiki/Parsec
15:13:40 <twanvl> > map floor [1.5,2..] -- evil, I know
15:13:41 <lambdabot>   [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,1...
15:13:51 <leimy> oh yeah
15:14:03 <devragert> ok thanks
15:14:15 <leimy> > [1..5,2..]
15:14:16 <lambdabot>   <no location info>: parse error on input `,'
15:14:28 <leimy> oops
15:14:33 <leimy> damn can't type today
15:14:47 <Gracenotes> > [ (a, b, c) | a <- [1..50], b <- [1..50], c <- [1..50], a < b, gcd a b == 1, a^2 + b^2 == c^2]
15:14:49 <lambdabot>   [(3,4,5),(5,12,13),(7,24,25),(8,15,17),(9,40,41),(12,35,37),(20,21,29)]
15:14:54 <leimy> > [1.5,2..]
15:14:56 <lambdabot>   [1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9.5,10.0,1...
15:15:26 <leimy> Gracenotes: pythtips!
15:15:32 <leimy> er pythtrips!
15:15:43 <roconnor> > drop 1000000000 $ floor [1.5,2..] -- evil, I know
15:15:43 <roconnor> oops
15:15:43 <roconnor> too much
15:15:43 <roconnor> @botsnack
15:15:44 <lunabot>  :)
15:15:44 <lambdabot> :)
15:15:45 <lambdabot>       No instances for (RealFrac [t], Integral [a])
15:15:45 <lambdabot>        arising from a use...
15:15:51 <ddarius> > scanl1 (+) $ cycle [1,0]
15:15:52 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
15:18:36 <saml> if I want to parse "a+b*2", would I represent it as: BinaryOp "+" (Variable a) (BinaryOp "*" (Variable "b") (Number 2.0))   ?
15:18:44 <saml> or is there a better way?
15:18:55 <ddarius> saml: It depends on what you want to do.
15:19:11 <saml> hrm?
15:19:23 <saml> my way is good for compliation or evaluation?
15:19:55 <ddarius> saml: No, not particularly.  The trade-offs are finer grained than that.
15:20:20 <ddarius> There are many different representations one could use even if only compilation is your goal.
15:20:37 <wli> > take 30 $ join replicate =<< [1..]
15:20:39 <shepheb> is there a standard solution if I want to wrap a ReaderT around an existing ReaderT? (in this case, one carrying a DB connection over top of CGI)
15:20:39 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8]
15:21:14 <saml> hrm maybe i'll go with that and if i hit a wall ask for other representations
15:21:17 <twanvl> shepheb: make a newtype wrapper for one of them, and add specialized functions for it
15:21:35 <ddarius> Make a newtype wrapper for both of them.
15:21:42 <ddarius> However, you can "just do that"
15:22:15 <twanvl> saml: it is a good starting point, I have often used that representation without problems
15:22:30 <shepheb> hm. I don't want to upset the underlying cgi functions that expect ask to get the CGIRequest. but I guess I'd have to use a cgi $ wrapper on them anyway
15:22:38 * shepheb will do this
15:23:08 <ozy`> saml: I'm under the impression that optimizing compilers usually use linear representations (like [(ISet "c" "b"), (ISet "d" 2.0), (IMult "c" "d"), (IAdd "c" "a")])
15:23:27 <saml> other representation would be App "+" (Variable "a") (App "*" (Variable "b") (Number 2))  ?
15:23:28 <ozy`> that is, turn it into an imperative format as early as possible
15:24:15 <twanvl> ozy`: most compilers use both, first the syntax tree, and later on a more imperative representation
15:24:35 <saml> hrm ah
15:24:59 <BMeph> Does anyone know if there is a Posix.Resource binding for Windows using pthreads?
15:25:01 <Gracenotes> ISet is an assignment operation? :/
15:25:14 <BMeph> Or rather, the pthreads-win32 lib?
15:25:19 <ozy`> twanvl: yeah, parsers almost always generate ASTs... after that it's up for grabs
15:25:26 <ozy`> Gracenotes: I just made up some operator names
15:25:45 <ozy`> call it IMove or ICopy if you prefer
15:26:18 <BMeph> saml: What, no de Bruijn indices? ;)
15:26:31 <Gracenotes> yes, I assumed. so it involves assignment, then
15:27:01 <Saizan> i'd find quite weird to use a repr involving assignment for functional languages
15:27:16 <BMeph> tromp: ping
15:27:47 <ozy`> saml: are you trying to compile a functional language?
15:27:48 <Saizan> apart from the last stage before generating asm
15:28:05 <saml> ozy`, imperative one. i'm doing http://llvm.org/docs/tutorial/OCamlLangImpl2.html
15:28:11 <tromp> what's up?
15:28:36 <Philippa_> ozy`: a good rule is not to go linear until you're ready to work with sequencing
15:29:18 <Philippa_> usually that's pretty late in the pipeline
15:31:24 <gwern> @seen JaffaCake
15:31:24 <lambdabot> JaffaCake is in #ghc and #haskell. I last heard JaffaCake speak 6h 23m 34s ago.
15:32:51 <gwern> @tell JaffaCake btw, did you see my message to haskell-cafe about threads not running? ( http://www.haskell.org/pipermail/haskell-cafe/2008-December/051547.html ) dons said you knew a lot about such issues
15:32:51 <lambdabot> Consider it noted.
15:34:17 <BMeph> tromp: I was wondering if you've written/modified a plugin for your BCL/BLC codings? :)
15:34:45 <BMeph> tromp: PS: I think I've hooked mmorrow on it, so I may be saving him some work as well. ;)
15:35:32 <pumpkin_snorkel> BMeph: is it on the new reddit? :D
15:35:59 <BMeph> tromp: I remember seeing a Java plugin that does it (my company firewall blocks CWI personal pages) but I don't remember if you've already done a Haskell module for it. It seems elementary, though. :)
15:37:00 <BMeph> pumpkin_snorkel: "This <(*^@!($*^@$!(*^$)!@(> is your brain; this <                   ...                           > is your brain on reddit." ;p
15:37:05 <pumpkin_snorkel> lol
15:37:11 <pumpkin_snorkel> http://www.reddit.com/r/haskell_proposals/ :)
15:37:53 <tromp> yes, you can download haskell source from my webpage
15:38:04 <tromp> want me to email a copy?
15:38:10 <adamvo> > \x -> traverse (:) (map ZipList x)
15:38:11 <lambdabot>   Not in scope: `traverse'
15:38:18 <BMeph> tromp: Ah - I'll do that when I get home, then. :)
15:38:47 <tromp> ok
15:38:49 <BMeph> tromp: Thank you for the email offer, though. Say, how come it isn't on Hackage? ;p
15:38:54 <adamvo> lambdabot doesn't know about traversable?
15:39:12 <adamvo> anyways, why is the type of that [[a]] -> [ZipList a] -> [[ZipList a]]
15:39:24 * BMeph wonders how gwern was able to possess him so swiftly...
15:40:31 <tromp> BMEph, got a busy job:(
15:40:37 <BMeph> adamvo: What part of that type makes you question it? It seems rather direct (to me)... ;)
15:41:01 <adamvo> BMeph: I was expecting to get a function with 1 argument
15:41:17 <adamvo> traverse takes 2 to my knowledge
15:41:33 <BMeph> :t \x -> traverse (:) (map ZipList x)
15:41:34 <lambdabot> Not in scope: `traverse'
15:41:49 <BMeph> :t \x -> Data.Traversible.traverse (:) (map ZipList x)
15:41:50 <lambdabot> Couldn't find qualified module.
15:41:53 <twanvl> ?type \x -> Data.Traversable.traverse (:) (map Control.Applicative.ZipList x)
15:41:54 <lambdabot> forall a. [[a]] -> [ZipList a] -> [[ZipList a]]
15:42:11 <adamvo> I'm confused
15:42:17 <BMeph> :t Data.Traversable.traverse
15:42:18 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
15:42:49 <Pseudonym> @haddock Traversable
15:42:50 <lambdabot> Unknown command, try @list
15:42:51 <twanvl> ?type \xs -> map ZipList xs
15:42:52 <lambdabot> forall a. [[a]] -> [ZipList a]
15:43:03 <Pseudonym> @hoogle Traversable
15:43:03 <Pseudonym> Duh.
15:43:03 <lambdabot> module Data.Traversable
15:43:03 <lambdabot> Data.Traversable class (Functor t, Foldable t) => Traversable t
15:46:27 <redditbot> Knight in N, part 4: tensors
15:47:09 <BMeph> adamvo: 1) What is the type of (:)? 2) Given that, how do the types map with traverse's types? :)
15:50:03 <Gracenotes> okay, typeclass chapter time. *braces*
15:52:53 <Botje> Gracenotes: danger of head explosion is minimal.
15:54:23 <Gracenotes> Risk assessment dynamically altered. Reticulating splines.
15:54:48 <Botje> don't forget to fold,spindle and mutilate.
15:55:36 <Gracenotes> of course.
15:55:51 <ozy`> holy crap, Reia uses pretty much exactly the same syntax I've been toying with for my abominable scripting language idea
15:56:08 <ozy`> well that saves me a whole lot of effort
15:56:36 <evident> i got another problems... any ideas?
15:56:36 <evident> http://hpaste.org/12955
15:57:44 <twanvl> evident: I would sugest that you first turn it into a list of tags
15:57:59 <evident> and then?
15:58:11 <evident> you mean just cut out everything inbetween, right?
15:58:22 <leimy> so bytestring-lexing needs alex
15:58:28 <leimy> but alex doesn't automatically install
15:58:41 <leimy> at least not as a dependency
15:58:51 <twanvl> evident: I mean [String], i.e. ["<tag1>","<tag2>",..]
15:58:52 <leimy> via cabal-install Imean
16:00:07 <twanvl> evident: Or better yet, abstract away the open/close tags:  [Left "tag1", Left "tag2", Right "tag2"], here I use Left for open tags and Right for close tags, but you could also define a new data type or use booleans
16:03:04 <evident> hmm thats an idea
16:03:16 <evident> a friend of mine just told me i could try to use Stacks
16:03:37 <twanvl> yes, you will probably need some kind of stack
16:03:57 <twanvl> but in Haskell you can use a list as a stack
16:04:57 <evident> yeah... thats a good idea... i will try to do that
16:05:00 <evident> thanks for the help
16:05:15 <evident> i bet there will be more problems so I'll be back
16:05:16 <evident> :)
16:11:10 <evident> did anyone of you answer my first problem in hpaste? there is a revision with a pretty neat solution... but i dont know who wrote it or even how it works
16:11:16 <evident> http://hpaste.org/12954
16:11:27 <psygnisfive> i'm finding myself in the humorously predictable situation of finding a task in my coding that would probably be made significantly simpler with monads. :P
16:12:10 <psnively> So use monads.
16:12:21 <psygnisfive> coding in scheme.
16:12:26 <psnively> So?
16:12:45 <psygnisfive> really its probably more the idea of an abstract datatype and data directed programming, but even so
16:13:08 <psnively> http://okmij.org/ftp/Scheme/monad-in-Scheme.html
16:13:29 <psygnisfive> thanks :P
16:14:01 <psnively> Or: http://www.ccs.neu.edu/home/dherman/research/tutorials/monads-for-schemers.txt
16:14:28 <psygnisfive> probably wont actually use it
16:15:07 <evident> how does taht "case ... of" work?
16:15:07 <evident> case findOpeningTag str of
16:15:18 <evident> (first line in the link i wrote)
16:15:30 <evident> never heard of that function and couldnt find it in hoogle
16:15:50 <dons> evident: how does 'case' work?
16:16:27 <dons> it evalutes the 'scrutinee', then pattern matches against the patterns in the alternative, branching to the matching branch
16:19:33 <adamvo> BMeph: thanks, I didn't expect that part of the expression to behave that way
16:23:46 <Megzlna> let f x = x; f :: String -> [Char]
16:23:55 <Megzlna> Why doesn't the  "String" part get erased?
16:24:25 <Megzlna> when I do :t f
16:24:53 <Megzlna> String doesn't decay into [Char]
16:24:57 <Igloo> ghc tries to give you the most helpful type it can
16:25:01 <Megzlna> @src String
16:25:01 <lambdabot> type String = [Char]
16:25:14 <Megzlna> it's not a newtype
16:25:20 <Igloo> e.g. when getting a type error, you want to see the type synonym you defined, rather than the huge type it is a synonym of
16:25:48 <Megzlna> okay
16:27:03 <hml> does haskell have bindings for any 3d physics libraries?
16:38:03 <Baughn_> So, riddle me this: After installing any (any!) package in ~/.ghc, ghci dies a terribly bloated death on its second startup, trying to eat all my memory and subsequently blowing up. I've traced it to the presence of ~/.ghc/ghci_history, but I'd rather enjoy having history. -_-?
16:38:50 <Zao> Baughn_: Got a botched editline/readline?
16:38:51 <Igloo> Baughn_: Sounds like a known bug in editline
16:39:01 <Igloo> Baughn_: What platform are you on?
16:39:05 <Baughn_> Igloo: Gentoo
16:39:10 <Baughn_> x86_64
16:39:21 <Igloo> Ask the Gentoo folk about it. They should be able to point you at a working version
16:39:37 <Baughn_> If it's editline, portage has a newer version. I'll just tell it to install that one.
16:41:01 * wli ponders the visual studio plugin he's heard about somewhere.
16:42:50 <Baughn_> ..do I also need to recompile ghc?
16:43:07 <saml> http://hpaste.org/12957#a1  i'm trying to parse floats.   234 02342  0.3242 .324 -.435 -023.342  34.  ...
16:43:19 <gwern> Baughn_: regretting using gentoo? :)
16:43:33 <Baughn_> gwern: I always compile ghc from source anyway
16:44:15 <Baughn_> That was in the manner of a question
16:44:22 <Baughn_> I've updated editline, but it's still crashing
16:46:42 <saml> do you like it to be able to write float, 0, as  +.0, -.0, 0.0, .0, 0, 0. ?
16:48:41 <Baughn_> gwern: Oh well. I had to go google it to get a sufficiently new one.
16:48:48 <Baughn_> So much for gentoo having all new software
16:50:39 <wli> Which implementation was the Visual Studio plugin made for?
16:52:13 <wli> Never mind; I found it.
16:52:34 <thoughtpolice> dcoutts: ping?
17:12:34 <thoughtpolice> Lemmih: ping
17:12:58 <saml> p://hpaste.org/12957#a2  do you like this?
17:17:52 <glguy> '/lastlog ushdf
17:23:13 <thoughtpolice> @tell Lemmih ok I've got a cabal file and Setup.hs working - we can optionally install base with the '-fwith-base' flag - I'm pushing the patches now
17:23:13 <lambdabot> Consider it noted.
17:23:55 <thoughtpolice> @tell Lemmih oh also I'll update the version and upload it to hackage
17:23:55 <lambdabot> Consider it noted.
17:27:55 <stoneToad> is there a better way to add a list of pairs then using foldl and (\a b -> (fst a + fst b, snd a + snd b))?
17:29:17 <byorgey> stoneToad: sum *** sum . unzip
17:29:31 <byorgey> > sum *** sum . unzip $ [(1,2), (3,4), (5,6)]
17:29:32 <ozy`> sure... instance Num (Int, Int) where (la, lb) + (ra, rb) = (la + ra, lb + rb)
17:29:32 <lambdabot>   Couldn't match expected type `[a]'
17:29:33 <ozy`> damn
17:29:50 <byorgey> hmm
17:29:56 <byorgey> > unzip $ [(1,2), (3,4), (5,6)]
17:29:58 <lambdabot>   ([1,3,5],[2,4,6])
17:30:00 <stoneToad> byorgey: *** is in what module?
17:30:05 <byorgey> stoneToad: Control.Arrow
17:30:11 <byorgey> @type sum *** sum
17:30:13 <lambdabot> forall a a1. (Num a1, Num a) => ([a], [a1]) -> (a, a1)
17:30:20 <roconnor> > (sum *** sum) . unzip $ [(1,2), (3,4), (5,6)]
17:30:22 <lambdabot>   (9,12)
17:30:28 <byorgey> ah, the precedence
17:30:31 <byorgey> doh =)
17:30:57 <byorgey> stoneToad: unzip turns a list-of-pairs into a pair-of-lists
17:30:58 <Axman6> :t sum *** sum . unzip
17:31:00 <lambdabot>     Couldn't match expected type `[a]'
17:31:00 <lambdabot>            against inferred type `([a1], [b])'
17:31:00 <lambdabot>       Expected type: [(a1, b)] -> [a]
17:31:00 <ozy`> @type (***)
17:31:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:31:12 <byorgey> and f *** g  applies f and g to the elements of a pair
17:31:24 <stoneToad> byorgey: ay, I was trying to use unzip, but I couldnt figure out anything to use to apply stuff to the pair
17:31:25 <byorgey> (although it is actually more general, as you can see from the type)
17:31:25 <Axman6> are there any other uses for
17:31:27 <Axman6> ***?
17:31:34 <stoneToad> that's an awesome use of arrows btw
17:31:37 <byorgey> Axman6: well, it's a general Arrow combinator
17:31:50 <mercury^> Is there a good way to have the following output the one possible output of the function being constructed lazily:
17:31:54 <mercury^> g s = g (\l -> s $ 1:zipWith (+) (s $ repeat 0) (0:l))
17:31:57 <Axman6> got any nice examples?
17:31:59 <roconnor> stoneToad: in this case "better" largely depends on what you are trying to optimize
17:32:17 <stoneToad> roconnor: elegance for now :)
17:32:18 <roconnor> stoneToad: your foldl code is pretty efficent
17:32:38 <roconnor> stoneToad: the *** code is possibly easier to understand and modify
17:32:42 <byorgey> stoneToad: although note, you should pretty much always use foldl' in preference to foldl
17:32:48 <Axman6> stoneToad: i'd use (\(a,b) (a',b') -> ... in the lambda
17:32:51 <gwern> fascinating. I just discovered why reddit only loads 1 out of 10 or so times
17:32:57 <gwern> I had my useragent set to googlebot
17:33:03 <Axman6> heh
17:33:12 <gwern> apparently reddit filters googlebots
17:37:00 <mercury^> As you can see I am trying to represent lists as functions from lists to lists, with every function starting to add the second list to the first one after an increasing offset.
17:37:55 <mercury^> That is useful here because every list calculated so far has two future continuations.
17:39:27 <byorgey> mercury^: there's no way that function will ever produce any output, since the first thing it does is call itself recursively.
17:39:57 <mercury^> byorgey: yes, that's why I'm asking how I can keep the underlying idea while having the function output stuff :)
17:41:45 <JohnnyL> how do you build GLUT for haskell?
17:42:18 <mercury^> byorgey: given a function :: [Num] -> [Num], repeated application of g makes it "converge" to a constant function. I'm interested in that constant functions output.
17:42:19 <ozy`> JohnnyL: I just used cabal-install
17:42:33 <dons> JohnnyL: cabal install glut
17:42:47 <dons> JohnnyL: but probably you should use the distro package
17:43:08 <byorgey> mercury^: why not just drop the recursive call to g, and then use 'iterate' to get successive convergents?
17:43:30 <byorgey> (I'm not entirely sure I understand what you're trying to do =)
17:46:28 <redditbot> Haskell Weekly News: December 6, 2008 | The Haskell Sequence
17:46:48 <mercury^> byorgey: to get the result list then I'd have to do [(iterate g bla)!!i | i <- [0..]] ?
17:47:05 <mercury^> Looks pretty unefficient. =)
17:47:58 <twanvl> [x!!i | i <- [0..]] == x
17:48:00 <byorgey> mercury^: eh?  [foo!!i | i <- [0..]] == foo
17:48:31 <byorgey> mercury^: maybe you mean something like  zipWith (!!) (iterate g bla) [0..] ?
17:48:35 <mercury^> [(iterate g bla)!!i!!i | i <- [0..]] ?
17:48:36 <mercury^> sorry
17:48:55 <BMeph> mercury^: Since you claim it converges, I'd throw fix into the mix, and see if the compiler agrees with your hypothesis. :)
17:50:08 <byorgey> mercury^: well, there might be a more efficient way to set up the problem in the first place
17:50:14 <byorgey> mercury^: but I don't see how else you would do it.
17:50:50 <thoughtpolice> woot
17:51:14 <thoughtpolice> @tell Lemmih ok I uploaded a version that works to hackage - we can now do 'cabal install lhc -fwith-base'!
17:51:14 <lambdabot> Consider it noted.
17:51:19 <mercury^> byorgey: I have thought that there must be something easier myself, but I couldn't find anything similarly concise with a lot of thinking.
17:51:25 <Axman6> :t join (!!)
17:51:27 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
17:51:27 <lambdabot>       Expected type: [a] -> [a] -> a1
17:51:27 <lambdabot>       Inferred type: [a] -> Int -> a
17:51:33 <Axman6> :t join (!!.!!)
17:51:34 <lambdabot> Not in scope: `!!.!!'
17:51:39 <BMeph> :t let g s = g (\l -> s $ 1:zipWith (+) (s $ repeat 0) (0:l)) in g
17:51:40 <lambdabot> forall a t. (Num a) => ([a] -> [a]) -> t
17:51:43 <Axman6> :t join ((!!).(!!))
17:51:45 <lambdabot>     Couldn't match expected type `[a]'
17:51:45 <lambdabot>            against inferred type `Int -> a1'
17:51:45 <lambdabot>     Probable cause: `!!' is applied to too few arguments
17:52:06 <BMeph> mercury^: ^^ Would suggest you've missed a loop in your knot... :)
17:52:39 <Axman6> are there any fixed point number formats in haskell?
17:52:39 <JohnnyL> ozy` do you need cabal for cabal-install?
17:53:17 <Axman6> JohnnyL: it comes with ghc. so the answer is yes, but you should already have it ;)
17:53:21 <BMeph> Axman6: Are there any non-fixed point number formats...anywhere? ;)
17:53:27 <mercury^> BMeph: if you can tell me how I can apply fix here I'd be glad to do so.
17:54:02 <Axman6> BMeph: ?
17:54:23 <twanvl> Axman6: Data.Fixed
17:54:30 <Axman6> sounds good
17:55:46 <byorgey> BMeph: well, with g s = g (...) it obviously won't converge.  but if you take the g off, the question is what you get on repeated application of g.
17:55:52 <byorgey> I mean the second g.
17:56:13 <BMeph> > :t fix (\s l -> s $ 1: zipWith (+) (s $ repeat 0) (0:l))
17:56:15 <lambdabot>   <no location info>: parse error on input `:'
17:56:28 <JohnnyL> Axman6 i'm in somewhat of a confusion how do I install cabal-install?
17:56:32 <byorgey> but it's not going to converge according to 'fix'.
17:56:37 <JohnnyL> i just downloaded two depencied ZLIB and HTTP.
17:56:43 <JohnnyL> dependancies
17:57:15 <Axman6> JohnnyL: cd into the dirs, and run runghc Setup.hs configure; runghc Setup.hs build; runghc Setup.hs install
17:57:32 <JohnnyL> Axman6 ok
17:57:59 <mercury^> byorgey: I'm not searching for the fixed point of g, but for the fixed point of what g converges to on certain inputs.
17:58:24 <mercury^> (of what "iterate g fun" converges to)
17:59:03 <byorgey> mercury^: right.  this is why BMeph's suggestion won't work.  the 'fix' function finds the *least defined* fixed point, which for 'g' is clearly bottom.
17:59:47 <byorgey> but what makes g special is that iterating it (on certain inputs) may lead you to compute progressively more of some other fixed point.
18:00:15 <BMeph> Axman6: Ah, fixed-point, as opposed to floating-point, not fixed point, as in (least) fixed point, which I'm also hip-deep in now. :)
18:00:28 <Axman6> heh, yes
18:00:38 <byorgey> @let g s = g (\l -> s $ 1:zipWith (+) (s $ repeat 0) (0:l))
18:00:39 <lambdabot>  <local>:10:6:
18:00:39 <lambdabot>      Ambiguous occurrence `g'
18:00:39 <lambdabot>      It could refer to either `L...
18:01:01 <byorgey> @let foo s = \l -> s $ 1:zipWith (+) (s $ repeat 0) (0:l)
18:01:02 <lambdabot>  Defined.
18:01:19 <mercury^> (\l -> zipWith (+) (repeat 1) (0:l)) would be one such input
18:01:20 <byorgey> > foo (1:)
18:01:21 <lambdabot>       Overlapping instances for Show ([t] -> [t])
18:01:21 <lambdabot>        arising from a use o...
18:01:30 <byorgey> > foo (1:) [2,3]
18:01:31 <lambdabot>   [1,1,1,2,3]
18:01:44 <byorgey> > foo (1:) $ foo (1:) [2,3]
18:01:46 <lambdabot>   [1,1,1,1,1,1,2,3]
18:02:20 <mercury^> > foo (\l -> zipWith (+) (repeat 1) (0:l)) (repeat 0)
18:02:21 <lambdabot>   mueval: Prelude.read: no parse
18:03:07 <mercury^> Do you see where that failed?
18:03:40 <twanvl> > foo (map f) [a,b,c]
18:03:42 <lambdabot>   [f 1,f (f 0 + 0),f (f 0 + a),f (f 0 + b),f (f 0 + c)]
18:04:59 <mercury^> Does anyone see why the above input of mine failed?
18:05:10 <Axman6> > let fibs = 1:1:zipWith (+) fibs (tails fibs) in fibs -- what do i have wrong here?
18:05:11 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
18:05:11 <lambdabot>        Expect...
18:05:12 <mercury^> Works in ghci here.
18:05:32 <Cale> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
18:05:34 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:05:38 <byorgey> I still really don't understand what that function does...
18:05:45 <Cale> What function?
18:05:52 <Axman6> ah, tails!
18:05:57 <mercury^> @src foo
18:05:58 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:06:03 <byorgey> Cale: oh, mercury^'s function g
18:06:36 <byorgey> g s = \l -> s $ 1:zipWith (+) (s $ repeat 0) (0:l)
18:06:40 <Cale> hmm
18:06:54 <Philonous> @type foo
18:06:55 <lambdabot> forall a. (Num a) => ([a] -> [a]) -> [a] -> [a]
18:07:18 <byorgey> Cale: I @let defined it in \bot as 'foo' to play with it
18:07:29 <Cale> ah
18:07:42 <byorgey> since 'g' didn't work for some reason =)
18:07:58 <Cale> > foo (0:) []
18:07:59 <lambdabot>   [0,1,0]
18:08:17 <JohnnyL> axman6: http://rafb.net/p/3KlniZ62.html
18:08:26 <mercury^> > foo (\l -> zipWith (+) (repeat 1) (0:l)) (repeat 0)
18:08:27 <lambdabot>   [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
18:08:46 <mercury^> > (foo $ foo (\l -> zipWith (+) (repeat 1) (0:l))) (repeat 0)
18:08:47 <lambdabot>   [1,2,2,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
18:08:52 <Megzlna> Why can 'read' only be used hence:
18:09:01 <Megzlna> > read "[1,2,3,4]" ++ []
18:09:03 <lambdabot>   * Exception: Prelude.read: no parse
18:09:03 <mercury^> > (foo $ foo $ foo (\l -> zipWith (+) (repeat 1) (0:l))) (repeat 0)
18:09:05 <lambdabot>   [1,2,2,3,3,5,5,6,6,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,...
18:09:17 <Megzlna> > read "1" + 1
18:09:19 <lambdabot>   2
18:09:20 <Cale> > read "[1,2,3,4]" :: [Integer]
18:09:20 <Megzlna> but not
18:09:21 <lambdabot>   [1,2,3,4]
18:09:24 <Megzlna> > read "1"
18:09:25 <lambdabot>   * Exception: Prelude.read: no parse
18:09:27 <Cale> > read "1" :: Integer
18:09:28 <lambdabot>   1
18:09:31 <mercury^> as you can maybe see, that should converge to the partition function
18:09:39 <byorgey> Megzlna: it has to know what type to read.
18:09:40 <Cale> It doesn't have any context to tell what type you want to parse.
18:09:48 <Megzlna> k
18:10:42 <mercury^> Cale: do you see a way to get the resulting list it converges to without doing [(iterate foo bla)!!i!!i | i <- [0..]]?
18:10:48 <JohnnyL> Axman6 help!
18:11:14 <Axman6> JohnnyL: have you read the docs on how to install cabal install? they're not that hard to follow
18:11:32 <JohnnyL> Axioplase did you see the paste error I get on OpenGL?
18:11:46 <mercury^> Since it already calculates the elements while calculating the successive approximations of the constant function, there ought to be some way to also get direct access to them. :(
18:11:48 <Megzlna> Eq, Ord, Show, Read, Bounded, Enum, Num, Integral, Floating
18:11:56 <Megzlna> did I miss any essential prelude typeclasses?
18:12:04 <Centrinia> Monad,Monoid,Functor,Applicable.
18:12:11 <llayland> is it possible to do something like - data Abcd = A Int; B String; C B
18:12:12 <JohnnyL> Axman6 ^
18:12:26 <Cale> Centrinia: Only Functor and Monad are in the Prelude
18:12:35 <Centrinia> Oh.
18:12:37 <Axman6> JohnnyL: no, i'm doing other things atm
18:12:40 <Megzlna> why not applicable?
18:12:43 <Cale> Monoid is in Data.Monoid and Applicative is in Control.Applicative
18:12:50 <JohnnyL> well it's so f**** up it's f**** out.
18:14:46 <bbs> lol
18:15:10 <llayland> I mean - data Abcd = A Int | B String | C B
18:15:12 <Megzlna> @src Ordering
18:15:12 <lambdabot> data Ordering = LT | EQ | GT
18:15:51 <llayland> The idea being that I only want the recursion in the type to be possible specifically for B
18:17:26 <JohnnyL> Axman6 i actually get the error while trying to configure OpenGL libs from hackage
18:17:34 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx <-- about the Ordering type
18:17:46 <Cale> (and the Monoid class)
18:17:48 <byorgey> mercury^: you should at least do  zipWith (!!) (iterate foo bla) [0..]
18:18:05 <byorgey> mercury^: repeatedly indexing into (iterate foo bla) is unnecessarily inefficient
18:18:16 <Megzlna> @src Ord
18:18:16 <lambdabot> class  (Eq a) => Ord a  where
18:18:16 <lambdabot>     compare      :: a -> a -> Ordering
18:18:16 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
18:18:16 <lambdabot>     max, min         :: a -> a -> a
18:18:52 <Axman6> JohnnyL: yeah i have no idea, sorry. someone else will probably know though
18:21:02 <JohnnyL> looks like cabal has Da Bugz00rssZ.
18:21:14 <dons> JohnnyL: hmm?
18:21:38 <dons> on hpaste?
18:21:58 <dons> cabal install opengl should just work (works for me)
18:22:14 <dons> btw guys, here's an idea. let's produce some top 10 lists for 2008 for the haskell community
18:22:17 <dons> top 10 new libs
18:22:19 <dons> top 10 blog posts
18:22:22 <dons> top 10 papers
18:22:56 <dons> i'll make a list of all the new libs on hackage this year, and we can vote on reddit about them
18:23:28 <Megzlna> top 1 new books?
18:23:30 <dons> hehe
18:23:40 <dons> maybe general top 10 news
18:23:45 <dons> top 10 new ghc featuress
18:24:03 <Megzlna> top 1 newbie == Megzlna
18:24:09 <dons> woot!
18:24:11 <dons> go Megzlna !
18:24:38 <Axman6> dons: JohnnyL is trying to install cabal install (i think)
18:24:47 <dons> ah.
18:24:55 <dons> on which platform?
18:25:02 <Axman6> windows i believe
18:25:08 <Axman6> http://rafb.net/p/3KlniZ62.html
18:25:12 <dons> ok. so use cabal.exe
18:25:41 <dons> http://haskell.org/~duncan/cabal/cabal.exe
18:25:51 <dons> life just got easier :)
18:26:19 <Axman6> heh, good work
18:26:25 <llayland> I'm going to nomiate myself for _|_ 1 newbie.
18:26:53 <dons> best newbies eh?
18:27:01 <dons> hmm. best first-time hackage release?
18:27:12 <dons> best new comer?
18:27:17 <Gracenotes> dons: purchasing a copy of Windows is not terribly easy :/
18:27:30 <dons> oh, please use linux then.
18:27:34 <Axman6> my first hackage release was an ARM emulator, that's gotta be up there right?
18:27:36 <dons> for which cabal will just build out of the box.
18:27:41 <dons> Axman6: that's pretty stunning, yes.
18:27:54 <Axman6> dons: .... not that i wrote it :\
18:27:59 <Gracenotes> oh, so, really.
18:28:19 <dons> on linux you'd just use your distro package
18:28:27 <dons> on windows, without a distro system (why!?) you need the .exe
18:28:41 <dons> you'd think MS with its gazillions would have come up with a distro system by now.
18:28:58 <Gracenotes> oh, nice. comes with ghc6?
18:29:03 <Axman6> you'd think that MS would've done a lot of things by now
18:29:15 <dons> sometimes it feels like they're asleep at the wheel
18:29:24 <Axman6> sometimes?
18:29:25 <smarmy> they have done a lot of things... it's just that nobody agrees with them
18:29:47 <dons> they're that xbox company, right?
18:29:51 <Axman6> just look ay XP Pond Wdition (Vista)
18:29:54 <Axman6> E*
18:30:03 <Gracenotes> ah, libghc6-cabal-dev
18:30:05 <smarmy> no no... i think they make that music player
18:30:13 <Axman6> the iPod?
18:30:26 <dons> Gracenotes: probably looking for  the 'cabal-install' exe
18:30:29 <Axman6> "no, the one that sucks"
18:30:31 <dons> not the cabal library
18:30:41 <mercury^> byorgey: Hmm, it works now, but it's still very slow.
18:30:57 <Gracenotes> hrm.
18:30:59 <mercury^> Maybe I'll do some profiling tomorrow to see why.
18:31:13 <dons> mercury^: compiled with -O2 ?
18:31:37 <mercury^> byorgey: dons -O3 even
18:31:39 <dons> sometimes people a) don't compile or b) don't use -On
18:31:45 <dons> well, -O3 == -O2 :)
18:31:46 <dons> but ok.
18:31:53 <mercury^> dons: -O3 is worse?
18:32:04 <dons> same
18:32:08 <mercury^> used to doing -O3 because of gcc convention
18:32:11 <dons> it is clamped to 2
18:32:49 * byorgey makes mental note to use -O1337 next time
18:33:54 <mercury^> in case anyone wants to play with the stuff: http://rohanlean.de/pub/76/
18:33:59 <dons> -Ofunky
18:34:05 <dons> -OMG
18:34:22 <dons> anyone got suggestions on the best way to prepare a 'vote on the best of this list' system?
18:34:28 <Megzlna> Is it possible to replace 'where'  with {  } stuff?
18:34:38 <dons> i'd like to put up a set of new libs broken down by category, and have people vote on them
18:34:46 <dons> Megzlna: hm?
18:34:48 <sjanssen> Megzlna: no, but you can use { } with where
18:35:03 <Megzlna> class Foo a where {
18:35:03 <Megzlna> ?
18:35:16 <sjanssen> Megzlna: { } is just a substitute for indentation, it doesn't substitute any keywords
18:35:28 <sjanssen> Megzlna: yep, that's fine
18:35:34 <Megzlna> I see
18:35:36 <dons> interesting idea that it could replace keywords
18:36:23 <Megzlna> The reason I asked is because where seems mostly applicable to indentation usage
18:37:07 <Axman6> it's just a way of defining function specific functions most of the time
18:38:16 <sjanssen> Megzlna: actually, "where" indicates that class methods are coming next (or, after a function definition, some local bindings)
18:38:43 <Megzlna> just a delimeter
18:39:13 <Megzlna> word based delimeters freak me out
18:39:51 <Axman6> sjanssen: or a module definition is coming...
18:39:57 <sjanssen> Axman6: ah, that too
18:40:52 <dons> > 2216 / 344
18:40:53 <lambdabot>   6.441860465116279
18:41:04 <dons> 6.5 uploads on hackage this year per day
18:41:15 <sm> dons: time for a new happs app ?
18:41:28 <dons> > 678 / 365
18:41:29 <lambdabot>   1.8575342465753424
18:41:33 <dons> 1.85 in 2007.
18:41:38 <dons> sm, yes perhaps!
18:41:41 <zeno> in yi :%s/a/b/gc doesnt work, is there another way?
18:42:04 <zeno> (to replace a with b with a confirmation for each)
18:45:02 <Megzlna> x <= y = compare x y /= GT
18:45:09 <Megzlna> does this stuff get inlined away completely?
18:45:17 <sm> a handy benchmarking script: http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/tools/bench.hs
18:45:34 <dons> Megzlna: yeah...
18:45:54 <dons> ghc does very aggressive inlining, to the point of being a whole program compiler
18:46:22 <sm> with something I don't understand.. with eg lines 86 and 117 I feel like I'm fooling GHC
18:46:28 <redditbot> A purely functional 2D scenegraph library
18:46:28 <redditbot> "Sarasvati is an open source workflow/business process management engine for Java and Haskell"
18:47:49 <Megzlna> Is this prelude
18:47:49 <Megzlna> http://www.haskell.org/onlinereport/standard-prelude.html
18:47:55 <Megzlna> Up to date with he one I use on GHC?
18:48:37 <dons> Lemmih: around?
18:48:45 <byorgey_> Megzlna: no
18:48:58 <Axman6> Megzlna: i think it should be. though the implementations are often different (better)
18:49:00 <dons> Lemmih: this should produce a server that listens on localhost:5001 right?
18:49:01 <dons> main = simpleHTTP nullConf [
18:49:01 <dons>     method GET $ ok $ toResponse "Hello World"
18:49:01 <dons>   ]
18:49:48 <Megzlna> what does ... on instances mean?
18:49:52 <byorgey_> Megzlna: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
18:49:59 <Megzlna> thx
18:50:10 <blenket> Would you forgive me for doing porn?
18:50:17 <pizza__> yes
18:50:23 <Megzlna> instance Eq Int where ...
18:50:27 --- mode: ChanServ set +o dons
18:50:34 <dons> blenket: do you have a haskell question?
18:50:46 <sm> dons: I had to use nullConf{port=5001} recently, the default seems to be something else
18:50:56 <byorgey_> Megzlna: I guess it just means the code is not shown
18:51:08 <byorgey_> Megzlna: it isn't Haskell syntax
18:51:24 <Megzlna> the code is shown below
18:51:38 <dons> sm++
18:52:10 <doublec> I think it's 8000 now
18:52:13 <doublec> (the port)
18:52:27 <sm> 5001 is carefully documented all over, I guess it's to slow us down a bit :)
18:52:35 <dons> doublec: yeah, i'm working through your cookbook.
18:52:43 --- mode: ChanServ set -o dons
18:52:56 <doublec> dons, I'm not sure why I was using 5001 - maybe it used to be the default
18:53:19 <doublec> if you confirm it's 8000 I'll change it
18:53:25 <dons> confirmed. it is 8000
18:53:49 <Axman6> i wish HAppS had some decent documentation/tutorials :(
18:53:57 <dons> Axman6: enjoy. http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial
18:54:09 <dons> also enjoy, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happs-tutorial-0.5.1
18:54:29 <dons> this for a web app is just awesome,
18:54:29 <dons> import HAppS.Server
18:54:30 <dons> main = simpleHTTP nullConf [ method GET $ ok $ toResponse "Hello World" ]
18:54:33 <dons> :)
18:54:40 <Axman6> i looked at the latter, it was't very helpful :\
18:54:48 <dons> the tutorial? why do you think that is?
18:54:52 <dons> too specific?
18:54:58 <dons> i also like the cookbook approach better
18:55:02 <doublec> thanks, changed
18:56:43 <doublec> I'll be adding more to the cookbook soon
18:56:53 <doublec> currently sidetracked writing a vorbis/theora player
18:57:23 <doublec> I'm wrapping liboggplay using Haskell FFI and writing a test app to test some liboggplay things
18:57:43 <Megzlna> why both sequence and sequence_ ?
18:57:46 <dons> hey, very cool.
18:57:55 <Megzlna> and mapM and mapM_
18:58:00 <dons> Megzlna: so you can explicitly get a tail recursive loop
18:58:07 <doublec> It gave me a chance to use the Hackage OpenAL library too
18:58:14 <Axman6> :t sequence
18:58:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:58:15 <Axman6> :t sequence_
18:58:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:58:17 <dons> you've looked at hogg?
18:58:26 <doublec> dons, yes I'd love to write a player using hogg
18:58:50 <doublec> but I'm testing liboggplay which is why I've gone that route
18:59:06 <solrize> axman6 the best intro to happs i know of is alexj's talk at bayfp video
18:59:14 <solrize> http://www.bayfp.org/blog/2007/10/16/alex-jacobson-on-happs-videos-slides/
18:59:24 <dons> ok. awesome.
18:59:26 <Axman6> i think i saw it... it was very badly filmed and quiet right?
18:59:30 <Megzlna> How are you supposed to use 'const' ?
18:59:46 <Axman6> > map (const 1) [2..]
18:59:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:59:57 <doublec> dons, reading Oleg's iteratee and binary i/o articles makes me want to try that approach to reading/playing theora
19:00:02 <solrize> i don't think it was intended to be a scorsese masterpiece--you can see and hear the guy
19:00:08 <solrize> and the slides are online too
19:00:09 <Megzlna> what's the point of that?
19:00:40 <solrize> (const 23) "skidoo"
19:00:44 <solrize> > (const 23) "skidoo"
19:00:46 <lambdabot>   23
19:00:48 <Megzlna> because const could be some 'x' ?
19:00:55 <Megzlna> some parameter to another func
19:00:59 <solrize> megzlna, (const x)  is just a function that returns x
19:01:01 <solrize> :t const
19:01:02 <lambdabot> forall a b. a -> b -> a
19:01:08 <Megzlna> that's id
19:01:09 <Axman6> HAppS-Util-0.9.3 failed during the building phase. The exception was:
19:01:10 <Axman6> exit: ExitFailure 1
19:01:17 <Axman6> oh no bro :(
19:01:17 <pizza__> :t id
19:01:17 <Megzlna> oh
19:01:18 <lambdabot> forall a. a -> a
19:01:22 <solrize> megzlna, no, idx = x
19:01:23 <Megzlna> i see
19:01:27 <Cale> Megzlna: It's a memory thing. sequence_ throws away the results of executing the actions, sequence keeps them in a list
19:01:29 <solrize> const x = \a -> x
19:01:38 <Cale> (regarding that previous question)
19:01:55 <Cale> The distinction between mapM and mapM_ is the same.
19:01:58 <Cale> :t sequence_
19:01:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
19:02:00 <Cale> :t sequence
19:02:01 <solrize> > let c3 = const 3 in  c3 9
19:02:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:02:03 <lambdabot>   3
19:02:08 <Megzlna> Cale: k
19:02:25 <Axman6> Megzlna: they're often used with IO i think, so you can run a list of IO actions, and either get the results back, or just know that they;ve been run
19:02:30 <Megzlna> > (const 3) 4
19:02:31 <lambdabot>   3
19:03:15 <Megzlna> just know they've been run?
19:03:19 <Megzlna> what would you do
19:03:22 <Megzlna> (const True) ?
19:03:40 <smarmy> > sequence_ $ map print [1..10]
19:03:41 <lambdabot>   * Exception: "<IO ()>"
19:03:48 <dons> doublec: thanks for your cook book, that's exactly what happs needed.
19:03:48 <ozy`> :t mapM
19:03:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:03:55 <dons> Lemmih: is it linked on happs.org yet?
19:04:21 <ozy`> > mapM putStrLn ["this", "is", "an", "example"]
19:04:22 <lambdabot>   * Exception: "<IO [()]>"
19:04:27 <ozy`> aaaargh
19:04:29 <Cale> Megzlna: for example, try  mapM (\x -> putStr (show x ++ ">") >> getLine) [1..5]
19:04:35 <doublec> dons, no problem. I always liked the cookbook approach to documenting libraries myself.
19:04:51 <Cale> Megzlna: Or, for this example, it's probably nicer to use forM, which is just mapM with its parameters flipped
19:05:08 <sm> very little is linked on the happs wiki (http://code.google.com/p/happs/w/list)
19:05:14 <Cale> forM [1..5] $ \x -> putStr (show x ++ ">") >> getLine
19:05:32 <Axman6> dons: got any ideas about "ghc: could not execute: /opt/local/lib/ghc-6.10.1/./ghc-asm" when trying to upgrade happs-server?
19:05:34 <sm> how about a wiki reboot, Lemmih
19:05:46 <Megzlna> Cale: That's for mapM vs mapM_  or for 'const' ?
19:05:56 <Cale> Megzlna: Well, for mapM
19:06:09 <Cale> Megzlna: For mapM_ in this case, it would be throwing away the user's inputs
19:06:19 <Cale> (but would still request 5 lines from the user in the same way)
19:06:34 <Megzlna> ah
19:06:59 <Axman6> hmm, it appears i don't have ghc-asm...
19:06:59 <iammisc> I'm still learning haskell and I'm writing a simple music management program. I made a data declaration for a music album and it has a lot of fields. however, most of them don't need to be filled. When I create a new instance of this type, do I have to specify all the contents? Is there a way to have default contents or do I have to make a function that will return an album instance with those defaults in there already?
19:07:06 <Megzlna> and that would only matter in an IO context, otherwise due to purity, the results are lost forever?
19:07:17 <Axman6> or maybe i do
19:07:40 <Cale> iammisc: you might create a 'blank' or 'default' value, and use record update syntax when creating your values
19:07:41 <dons> iammisc: use record update syntax
19:07:54 <Axman6> ew, bad perl interpreter...
19:08:13 <cknapp> Axman6: ?
19:08:17 <smarmy> Megzlna: in a pure context, a function that returns () isn't particularly useful
19:08:18 <Cale> default { suchAndSuch = "is different from the default", somethingElse = 42 }
19:08:38 <Cale> er, of course you can't name it 'default', that's a keyword
19:08:48 <sm> dons: xmonad.org has got really good! how do you maintain it ?
19:08:57 <Axman6> cknapp: trying to run ghc-asm, it had perl5.9 installed, and it wanted 5.8
19:09:16 <Cale> But presumably that would be the name of your chosen default value for that type.
19:09:37 <Cale> If you use this pattern a lot, it might be worth creating a class.
19:09:38 <dons> sm, in darcs.
19:09:41 <cknapp> Ah
19:09:43 <Megzlna> alright the mapM_ makes sense with IO
19:09:43 <Megzlna> so
19:09:50 <sm> I've been clicking around.. can you point me to that repo ?
19:09:51 <cknapp> Oh! Haskell WM....
19:09:59 <Megzlna> why doesn't  data Foo = ... 'x' | 'y' ...
19:10:02 <Megzlna> work in my Haskell
19:10:03 <Cale> class Blank t where
19:10:05 <Megzlna> but it's in prelude
19:10:06 <Cale>    blank :: t
19:10:19 <Cale> instance Blank MyRecordType where
19:10:29 <iammisc> Cale and dons: when you say use record update syntax, do you mean create a blank object and then use the record update syntax to create new objects of it?
19:10:34 <Cale>    blank = MRT { ... fill in values here ... }
19:10:37 <dons> sm: http://code.haskell.org/~sjanssen/xmonad-web
19:10:39 <Cale> iammisc: yes
19:10:42 <sm> thanks
19:10:47 <iammisc> okay thanks
19:11:15 <Megzlna> and why is IO data?
19:11:49 <Cale> Megzlna: IO is data because that's how we explicitly represent the order in which things happen.
19:11:53 <dons> Megzlna: perceptive question.
19:12:07 <Axman6> @src IO
19:12:07 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
19:12:17 <Megzlna> what the hell
19:12:18 <Cale> Since the evaluation order of Haskell is unspecified (and even if it were, the order would be strange)
19:12:21 <Axman6> ha
19:12:24 <Cale> Ignore that definition of the IO type
19:12:41 <Cale> A better definition for a mental model is more like:
19:12:48 <cknapp> Hmm.... how is XMonad?
19:12:49 <Cale> data IO t where
19:12:54 <Cale>   returnIO :: t -> IO t
19:13:07 <Cale>   bindIO :: IO a -> (a -> IO b) -> IO b
19:13:12 <Cale>   getChar :: IO Char
19:13:21 <Cale>   putChar :: Char -> IO ()
19:13:27 <Cale>   ... other IO primitives here...
19:13:50 <Cale> (seeing as you already know the GADT syntax)
19:14:06 <Cale> That is, it's just some data that represent what should be done.
19:14:36 <Cale> The Haskell runtime can be seen as taking that data apart and actually carrying out the instructions, specifically for the value 'main' in a compiled program.
19:14:44 <ozy`> isn't >>= where the actual "run this command" code is hooked?
19:14:54 <ozy`> for IO, I mean
19:14:58 <Cale> That's not actually how GHC does it, but how it actually does it is a low-level hack
19:15:19 <Cale> (and it need not be such a hack, except possibly for performance reasons)
19:15:43 <Cale> (also the fact that GADTs didn't exist when the IO monad was invented)
19:15:55 <jsn> Cale: what is the hack?
19:17:02 <Cale> The hack is using functions that actually do have side effects, and threading a token (the unique value of type "State# RealWorld") around to ensure that everything gets evaluated in the right order.
19:17:13 <byorgey> ozy`: not really, >>= basically just composes two IO computations into a bigger one
19:17:29 <Megzlna> >>= is only for the monad
19:17:48 <byorgey> cknapp: what do you mean, how is it?
19:17:58 <Cale> The actual fact that IO is a monad is less essential than the fact that it's some data structure.
19:18:54 <zeno_> hmmm why is the data type A | B (C | D) less efficient than Int? shouldnt it take less memory?
19:19:00 <Cale> In fact, we could use any kind of library, not just a monad. It's just that the library we have happens to be a monad. The important thing is that the order in which things occur, and what occurs, is represented as data.
19:19:07 <byorgey> cknapp: it's a fantastic piece of software, if that's what you're asking =)
19:19:36 <zeno_> Array Int (A | B (C | D)) vs Array Int Int to be specific
19:19:47 <Cale> zeno_: that looks like a syntax error to me
19:19:55 <Axman6> me too...
19:20:21 <jsn> Cale: well, wasn't the whole point of the monad that it assures the ordering?
19:20:29 <Cale> But one nice thing about Array Int Int is that you can change it to UArray Int Int
19:20:31 <byorgey> zeno_: maybe because Ints can be unboxed and whatever that thing is can't?
19:20:37 <Cale> and use an unboxed array
19:20:37 <byorgey> jsn: nope!
19:20:41 <zeno_> Cale: C | D is a separate datatype
19:20:46 <jsn> byorgey: well, foo
19:20:58 <jsn> this is the part of the movie where we look behind the curtain
19:21:02 <Cale> jsn: Well... there are other ways of encoding that
19:21:06 <byorgey> jsn: it isn't the monad which assures the ordering, it's data dependencies
19:21:11 <zeno_> Cale: ill have to look that up, thanks
19:21:15 <Cale> jsn: Monad is just a particular interface to doing that
19:21:23 <Megzlna> Cale: is IO really all funneled through Char's?
19:21:32 <dons> no.
19:21:40 <Cale> jsn: The real reason we recognise that IO is a monad is so we can use all the stuff in Control.Monad for free.
19:21:41 <dons> see Data.ByteString for very efficient Io
19:21:49 <Cale> Megzlna: That was just an example.
19:21:52 <byorgey> Megzlna: heh, Cale's 'data IO t' was just an (incomplete) illustration
19:21:53 <Megzlna> k
19:22:04 <jsn> Cale: but not just anything could work, right?
19:22:18 <jsn> Cale: like Applicative Functors would be no good, i assume
19:22:23 <Megzlna> in GHC are Char's 4 bytes?
19:22:25 <Cale> Well, they would work.
19:22:37 <jsn> oh?
19:22:47 <Axman6> Megzlna: i believe ther're 1 byte
19:22:51 <Axman6> they're*
19:22:56 <Cale> Perhaps only recognising that IO was an applicative functor would make some programs a bit of a pain to express.
19:23:06 <jsn> so you just need something with "lift" and no corresponding "unlift" ?
19:23:09 <Axman6> @src Char
19:23:09 <lambdabot> data Char = C# Char#
19:23:14 <Cale> But we could also use vastly different library structures.
19:23:16 <Megzlna> well they could not be 1 Byte
19:23:27 <jsn> Cale: like?
19:23:30 <Axman6> why not? they are in all other languages...
19:23:41 <Megzlna> Axman6: coz Haskell's unicode
19:23:43 <dons> hmm. where is happs' haddocks?
19:23:45 <Cale> We could fail to recognise that IO was any kind of special type of library at all, and define various special operations for composing IO actions
19:23:53 <Cale> (that didn't work with others)
19:23:58 <Axman6> Megzlna: not afaik.... dons?
19:24:17 <Megzlna> it could be 2 bytes as well
19:24:24 <Megzlna> depending on how wide the unicode support is
19:24:31 <Axman6> dons: Chars aren't unicode are they?
19:24:40 <dons> they are.
19:24:46 <dons> depends on how you read them in though
19:24:47 <Axman6> > 'ï£¿' :: Char
19:24:48 <lambdabot>   <no location info>:
19:24:48 <lambdabot>      lexical error in string/character literal at chara...
19:24:51 <Megzlna> UTF-16 or UTF-32
19:24:54 <jsn> > maxBound :: Char
19:24:55 <lambdabot>   '\1114111'
19:25:10 <Cale> > log 1114111 / log 2
19:25:11 <lambdabot>   20.087461546321563
19:25:25 <jsn> Cale: so monads are convenient, but what is necessary?
19:25:45 <jsn> there was continuation based IO, once upon a time, I guess
19:25:46 <Axman6> > (log 1114111 / log 2)/8
19:25:47 <lambdabot>   2.5109326932901954
19:25:55 <Axman6> there you go, 2.5 bytes :)
19:25:55 <Cale> jsn: Well, that's a great question.
19:26:07 <Cale> jsn: You need *some* way to express dependence of outputs on inputs.
19:26:15 <jsn> Axman6: that means 4, of course
19:26:22 <cygnus_> > (log 0)
19:26:23 <jsn> Cale: aye
19:26:23 <lambdabot>   -Infinity
19:26:25 <Axman6> bah!
19:26:27 <cygnus_> it's a genius
19:26:36 <cygnus_> > log( -1)
19:26:37 <lambdabot>   NaN
19:26:41 <Cale> > (log 1114111 / log 8)
19:26:42 <lambdabot>   6.695820515440522
19:26:55 <mriou> hi guys, question about polymorphic types and monad unwrapping
19:26:59 <Cale> > (log 1114111 / log (2^8))
19:27:01 <lambdabot>   2.5109326932901954
19:27:11 <pumpkin_snorkel> omg magick
19:27:14 <mriou> I have a function with type [ASTType] -> STRef s WyEnv -> ST s [WyType]
19:27:42 <mriou> I want to modify it just so that it unwraps, returning [WyType]
19:27:55 <jsn> :t runST
19:27:56 <lambdabot> forall a. (forall s. ST s a) -> a
19:27:57 <mriou> so I just run it with runST
19:28:06 <mriou> yeah
19:28:16 <Cale> mriou: Yes, 'run' is a better term than 'unwrap'
19:28:22 <mriou> which results in "Inferred type is less polymorphic than expected"
19:28:34 <Cale> mriou: Are you writing  runST $ ...
19:28:35 <mriou> cale: ah ok, I'll use run then
19:28:40 <Cale> because if so, then don't do that
19:28:43 <Cale> runST (...)
19:28:44 <mriou> cale: yup
19:28:47 <Megzlna> new mission: understand each line of prelude
19:28:49 <Cale> $ doesn't work with runST
19:28:57 <jsn> haha
19:28:59 <Cale> (it's a complicated typing issue)
19:29:04 <Cale> :t runST
19:29:05 <lambdabot> forall a. (forall s. ST s a) -> a
19:29:11 <mriou> cale: mmmh nice to know, thanks for the tip
19:29:13 <Cale> runST's type is higher-rank
19:29:35 <mriou> cale: you either said too much or not enough :)
19:29:36 <Cale> So as to ensure that effects don't leak -- you can't return an IORef.
19:29:39 <Cale> er, STRef
19:29:52 <mriou> higher rank?
19:29:56 <Megzlna> does haskell have any block comments?
19:30:03 <Megzlna> because...
19:30:07 <jsn> Megzlna: yes
19:30:08 <mriou> {- ... -}
19:30:12 <Cale> Well, that's just a name for "requires a polymorphic argument"
19:30:13 <Megzlna> {-  is used with language extensions
19:30:18 <Cale> Megzlna: In fact, you can nest them.
19:30:21 <Megzlna> so it didn't seem a real comment
19:30:25 <jsn> {-# LANGUAGE #-}
19:30:34 <Cale> {- this is a comment {- and so is this -} and this is too -}
19:30:40 <jsn> not {- LANGUAGE -}
19:30:47 <Megzlna> k
19:30:57 <Philippa_> {-# this is a pragma, it's that way because it's also a comment #-}
19:31:05 <mriou> cale: perfect, thanks for the help
19:31:25 <Cale> mriou: See, the thing which makes it work...
19:31:43 <Cale> newSTRef :: a -> ST s (STRef s a)
19:31:45 <Axman6> mriou: haskell eve supports nested comments
19:31:54 <Axman6> even*
19:32:01 <Cale> The 's' type parameter ends up attached to the STRefs you make
19:32:23 <Cale> and in the end, the type of runST means that 's' can't be used in the result type 'a'
19:32:35 <Megzlna> what's the purpose of these keywords:
19:32:38 <mriou> cale: mmh actually doesn't work
19:32:39 <Megzlna> infix  4  ==, /=, <, <=, >=, >
19:32:39 <mriou> :)
19:32:47 <Megzlna> infixr 0  $, $!, `seq`
19:32:54 <smarmy> because the s would be of higher order than a, and therefore can't be fixed at the level of a?
19:32:58 <Cale> Megzlna: Defining the precedence and associativity of infix operators
19:33:02 <mriou> still "inferred type is less..."
19:33:08 <Megzlna> Cale: oh!
19:33:12 <Megzlna> you can do that? :P
19:33:19 <Cale> smarmy: Because 'a' is quantified before 's' is in scope.
19:33:31 <Megzlna> neat
19:33:32 <Cale> Megzlna: yep :)
19:33:36 <smarmy> hmmm
19:33:48 <Cale> Megzlna: It could be done better, but it's good that it was done at all :)
19:34:08 * Megzlna rewrites prelude to reverse associativity of all basic operators
19:34:12 <Cale> hehehe
19:34:22 <Cale> Actually I want to reverse the associativity of two of them
19:34:25 <Cale> $ and $!
19:34:28 <Megzlna> why
19:34:38 <Cale> Because presently, you can always rewrite:
19:34:43 <Cale> f $ g $ h $ x
19:34:44 <Cale> as
19:34:46 <Cale> f . g . h $ x
19:34:55 <Cale> But, suppose you have something like:
19:35:02 <Cale> f (g x) (h y) (k z)
19:35:08 <Cale> There's no way to remove the parens
19:35:21 <Cale> If $ was left associative like function application is though
19:35:24 <Cale> It would be
19:35:31 <Cale> f $ g x $ h y $ k z
19:35:52 <Cale> This is more important with strict application: $!
19:36:00 <roconnor> @pl \f g h x y z -> f (g x) (h y) (k z)
19:36:01 <lambdabot> flip flip k . ((flip . ((flip . ((flip . ((.) .)) .)) .) . flip . ((.) .)) .) . (.)
19:36:09 <Cale> It's currently a pain in the ass to use $! for more than one parameter
19:36:18 <Cale> and for anything but the last parameter, for that matter
19:36:24 <Cale> You end up bracketing things strangely
19:36:30 <Megzlna> the only purpose of $ and . is lowest/highest precedence?
19:36:37 <Cale> ((f $! x) $! y) $! z
19:36:46 <Cale> $ is very low precedence
19:36:53 <Cale> . is function composition
19:36:53 <Megzlna> 0
19:36:58 <Cale> :t (.)
19:36:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:37:02 <Cale> :t ($)
19:37:03 <lambdabot> forall a b. (a -> b) -> a -> b
19:37:07 <mokus> @pl \f g x h y k z -> f (g x) (h y) (k z)
19:37:08 <lambdabot> ((((((.) .) .) . (.)) .) .) . (.)
19:37:22 <Megzlna> Cale, why would you want to write f . g . h $ x instead of f $ g $ h $ x ?
19:37:29 <intrados> how do I unregister a cabal package with the compiler?
19:37:34 <Cale> Megzlna: Well, one nice thing is that (.) is associative
19:37:48 <Cale> f . (g . h) = (f . g) . h
19:37:58 <erikc`> hrm...im missing something, what is the connection between the .cabal file and the Setup.hs? i have a test hook in my Setup.hs but 'cabal test' doesnt run the tests, 'runhaskell Setup.hs test' does
19:38:01 <Cale> which makes code written with it easier to refactor
19:38:08 <mcnig> http://pastebin.com/d5e030116 - what does this error mean?  I'm trying to find the sum of all multiples of 3 or 5 below 1000
19:38:20 <Cale> Note that in that example,  g . h  will be a well-typed function
19:38:29 <Cale> But  g $ h  on its own is meaningless.
19:38:40 <Cale> (probably a type error)
19:39:08 <Cale> mcnig: Wow, is that a hugs message?
19:39:17 <Cale> (bad error message)
19:39:21 <mcnig> Yeah..
19:39:28 <Cale> mcnig: It means there's a case you didn't handle.
19:39:30 <luite> mcnig: you miss an 'otherwise' case
19:39:53 <Cale> mcnig: What if n is not 1000 and n is neither a multiple of 3 nor a multiple of 5?
19:39:59 <mcnig> Ah!
19:40:18 <Cale> mcnig: By the way, using sum and filter for this is clearer.
19:40:31 <Cale> Or sum and a list comprehension.
19:40:45 <mcnig> Hmm, will try that too, experimenting
19:40:48 <mcnig> Thanks
19:40:53 <Cale> no problem :)
19:40:53 <mriou> cale: I think I missed your point earlier about STRef and 's' not being used in the result type 'a'
19:41:00 <Cale> mriou: ah
19:41:09 <mcnig> By the way, are there any debuggers that can let you step through the code?
19:41:15 <Cale> mriou: Were you trying to return something containing an STRef? :)
19:41:28 <luite> mcnig: ghci has a debugger
19:41:28 <mriou> mmmh no
19:41:36 <mriou> an argument was an STRef though
19:41:41 <Cale> hmm...
19:41:44 <Cale> ah
19:41:46 <mriou> [ASTType] -> STRef s WyEnv -> ST s [WyType]
19:42:20 <Cale> Ah, you'll have to use that function properly, setting up an initial STRef to use before applying runST
19:43:14 <mriou> why do I have to setup another STRef, I'm passing one
19:43:29 <Cale> Like... typeCheck xs = runST (do envRef <- newSTRef emptyEnv; foo xs envRef)
19:43:46 <Cale> The STRef has to be constructed in the *same* ST computation.
19:44:16 <Cale> What goes on inside one call to runST is kept entirely separate from all the other calls to runST in the program.
19:44:23 <hml> anyone has an implementation of J in haskell? it seems like other than the built in matrix support, J is very similar to Haskell
19:44:28 <mriou> no kidding?
19:44:41 <Cale> mriou: no kidding. :)
19:44:56 <mriou> Cale: mmmh that's problematic
19:45:22 <Megzlna> @src ()
19:45:22 <lambdabot> data () = ()
19:45:28 <Cale> mriou: If you want state to flow from one ST computation to another, you must push the runST upward, and build a bigger ST computation before applying it.
19:46:00 <Cale> Or else you must return some representation of that state which does not involve STRefs or STArrays, and then pass it into the next one.
19:46:15 <mriou> so I have to slice
19:46:23 <Megzlna> what does it mean when you...
19:46:49 <Cale> If the second seems at all awkward, use the first way.
19:47:04 <Megzlna> f :: (Foo f) => (a -> f b) -> etc
19:47:09 <Megzlna> -> f b ?
19:47:21 <mriou> Cale: the first way being building a new STRef?
19:47:38 <Cale> mriou: Meaning don't apply runST yet.
19:47:53 <Cale> mriou: Leave things as ST computations, and hook them together into one larger ST computation first.
19:48:00 <Megzlna> (=<<)            :: Monad m => (a -> m b) -> m a -> m b
19:48:03 <Megzlna> m b
19:48:05 <luite> Megzlna: f b is a 'container' of type f, containing b
19:48:09 <Megzlna> ?
19:48:19 <smarmy> think Maybe Int
19:48:22 <smarmy> or IO String
19:48:23 <Cale> m is a variable for a type constructor
19:48:24 <Megzlna> what type of container
19:48:30 <mriou> Cale: I don't understand "hook them together into one larger ST computation first"
19:48:38 <Cale> So it could be IO, it could be Maybe, it could be [] (lists)
19:49:16 <Megzlna> () never needed around (Foo a) =>   ?
19:49:21 <Megzlna> that's just convention?
19:49:36 <Megzlna> why do some things have
19:49:39 <Megzlna> (Foo a) =>
19:49:40 <Megzlna> and others
19:49:42 <Megzlna> Foo a =>
19:49:52 <Cale> mriou: Like... suppose you have firstPart :: Foo -> ST s (STRef s Bar, Quux), and you have something like secondPart :: Quux -> STRef s Bar -> ST s Result
19:49:56 <smarmy> you might have (Foo a, Bar a)
19:50:02 <Cale> mriou: then you'd write something like
19:50:08 <smarmy> if there is more than one, sperated by commas, you need parens
19:50:09 <Megzlna> so, what's wrong with
19:50:14 <Cale> together :: Foo -> ST s Result
19:50:15 <Megzlna> Foo a, Bar a =>
19:50:38 <Cale> together foo = do (ref, quux) <- firstPart foo
19:50:50 <mriou> got it
19:50:54 <Cale>                   secondPart quux ref
19:51:02 <Cale> and then apply runST to 'together'
19:51:09 <Cale> well, to its result
19:51:22 <intrados> what's my best option for turning mathematical functions into sound?
19:51:52 <Cale> Megzlna: Probably a parsing thing.
19:51:52 <lament> saying them aloud?
19:51:58 <Cale> lament: hehe
19:52:08 <mriou> Cale: my problem though is not necessarily chaining type transformations, it's starting a on a given state and then change the state without influencing the previous one
19:52:32 <doublec> intrados: There's an openal binding on hackage
19:52:34 <Cale> mriou: hmm, I'm not sure what you mean...
19:52:44 <mriou> Cale: thing is I'm building a small interpreter for a pet language, so when I see a function call in that pet language
19:53:23 <mriou> I want to copy the closure environment (it supports closure), add the stack frame binding the parameters and create a new environment
19:53:58 <mriou> so I have an environment before the call, that should still exist after the call
19:54:04 <mriou> and another one during the call
19:54:10 <Cale> mriou: Okay.
19:54:19 <Cale> That sounds like a job for the Reader monad and local.
19:54:19 <mriou> I don't want to unwind the whole interpreter for that
19:54:36 <Cale> Or just parameter passing.
19:55:14 <mriou> Cale: but environments are mutable (the aforementioned pet language has assignment)
19:55:30 <Cale> mriou: It doesn't mean that your interpreter has to. ;)
19:55:41 <mriou> Cale: correct
19:55:57 <Megzlna> what does it mean when a typeclass constraint is a tuple?
19:56:00 <Cale> mriou: If you don't particularly care about performance but still want something reasonable, you can use a Data.Map for the environment.
19:56:13 <Cale> Megzlna: It means the conjunction of those constraints.
19:56:24 <mriou> Cale: that's what I did :)
19:56:41 <Cale> mriou: Right, so then you can pass that Data.Map around by hand...
19:56:43 <Megzlna> how do you write persistent code in lambdabot
19:57:03 <mriou> but then every function need to return the environment and every caller need to get back that environment
19:57:11 <Cale> Megzlna: Well, you can use @let to make definitions, but they go away whenever the next person comes along and does @undefine
19:57:11 <mriou> and so on an so forth
19:57:19 <Megzlna> @let f x y = x + y
19:57:20 <lambdabot>  Defined.
19:57:25 <Megzlna> :t curry f
19:57:26 <lambdabot>     Ambiguous occurrence `f'
19:57:26 <lambdabot>     It could refer to either `L.f', defined at <local>:11:0
19:57:26 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:72:0-32
19:57:29 <Cale> oh, that name might be a problem...
19:57:37 <mriou> with STRef I could just alter the ref without needing to pass it around
19:57:38 <Cale> The single-letter variables are sort of taken
19:57:39 <Megzlna> @let fff x y = x + y
19:57:40 <lambdabot>  Defined.
19:57:43 <Megzlna> :t curry fff
19:57:44 <lambdabot> forall a b. (Num (a, b)) => a -> b -> (a, b) -> (a, b)
19:58:05 <Megzlna> the "conjunction" of (a,b) ?
19:58:10 <Megzlna> what does that mean?
19:58:14 <Cale> mriou: You could also use the simple State monad.
19:58:18 <Cale> Megzlna: ah, that's what you mean
19:58:30 <Cale> Megzlna: it means there must be an instance of Num for the type (a,b)
19:58:50 <Megzlna> hows that possible?
19:58:55 <Cale> (which there isn't in the Prelude, but you could write one)
19:58:56 <Megzlna> tuples arent nums
19:58:57 <mriou> Cale: would that be better than ST?
19:59:01 <Cale> They can be.
19:59:05 <Cale> mriou: Possibly
19:59:25 <Cale> mriou: Seeing as all your state is in one basket anyway.
19:59:40 <Cale> ST is good when you have unbounded amounts of state of different types flying around
19:59:49 <Megzlna> so why was (a,b) needed for curry ?
19:59:59 <Cale> :t curry
20:00:00 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:00:07 <Cale> :t fff
20:00:08 <mriou> Cale: yeah but I need to have stacks of them
20:00:09 <lambdabot> forall a. (Num a) => a -> a -> a
20:00:15 <Megzlna> hrmph
20:00:20 <smarmy> :t uncurry fff
20:00:21 <lambdabot> forall a. (Num a) => (a, a) -> a
20:00:35 <mriou> leaving one behind for each function call
20:01:35 <Cale> mriou: Well, you can use a list of environments...
20:01:56 <Cale> or else do something like Reader's 'local' which is implementable using State.
20:01:56 <mriou> Cale: that's actually what I was thinking :)
20:02:20 <pumpkin> does anyone here have happs running on 6.10?
20:02:46 <Cale> Megzlna: So if  curry :: ((a,b) -> c) -> a -> b -> c
20:02:51 <Cale> and  fff :: t -> (t -> t)
20:03:05 <pumpkin> @src curry
20:03:05 <lambdabot> curry f x y = f (x, y)
20:03:08 <Cale> then if we want to apply curry to fff, we must have that  t = (a,b)
20:03:09 <dons> pumpkin: yeah
20:03:12 <Cale> and c = (t -> t)
20:03:24 <dons> pumpkin: no problems.
20:03:29 <Cale> so c = ((a,b) -> (a,b))
20:03:57 <Cale> and the result has type  a -> b -> (a,b) -> (a,b)
20:04:16 <mriou> Cale: thanks and sorry for all the questions, I'll see if I can find something
20:04:19 <Cale> Adding in the typeclass constraints, we had that  fff :: (Num t) => t -> (t -> t)
20:04:20 <pumpkin> dons: hmm, I seem to be having some :/ I'm just trying the 3-step recipe on the happs homepage, but am getting lots of warnings during startup and it eventually dies on an ambiguous type :/
20:04:36 <Cale> So that constraint must be preserved, and we must have  Num (a,b)
20:04:43 <Cale> (since t = (a,b))
20:04:45 <pumpkin> http://pastie.org/336451
20:06:00 <pumpkin> I just followed the three steps on the homepage :o
20:06:04 <Cale> Megzlna: make sense?
20:06:26 <Cale> Megzlna: That'll typically result in an error, because there is no instance (by default) for Num (a,b)
20:06:31 <Cale> However, you could easily add one
20:06:34 <Cale> Like:
20:06:38 <dons> pumpkin: i suggest cabal install happs-server
20:06:46 <Cale> instance (Num a, Num b) => Num (a,b) where
20:06:46 <dons> use hackage.
20:06:54 <Cale>   (a,b) + (c,d) = (a+c, b+d)
20:06:57 <Cale>   ... etc.
20:07:41 <Megzlna> I clipped your whole description out into txt
20:07:50 <Megzlna> going to have to prod it in ghci before it makes sense
20:07:56 <ozy`> FUN FACT: Obj-C-ese for "map f d" is "[d dictionaryByMakingObjectsPerformSelector:@selector(f)]"
20:09:08 <Megzlna> Cale: what would go wrong if you did:
20:09:25 <Megzlna> curry f :: (Num a, Num b) => a -> b -> (a, b) -> (a, b)
20:10:08 <EvilTerran> well, that's uncurry
20:10:11 <EvilTerran> ?type uncurry
20:10:12 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:10:29 <cjs> ?type ununcurry
20:10:30 <lambdabot> Not in scope: `ununcurry'
20:10:34 <cjs> Darn.
20:10:41 <EvilTerran> ?type uncurry (,)
20:10:42 <lambdabot> forall a b. (a, b) -> (a, b)
20:10:43 <Cale> :t uncurry uncurry
20:10:44 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
20:10:53 <Cale> :t curry uncurry
20:10:54 <lambdabot>     Couldn't match expected type `(a, b)'
20:10:54 <lambdabot>            against inferred type `a1 -> b1 -> c'
20:10:54 <lambdabot>     Probable cause: `uncurry' is applied to too few arguments
20:10:58 <pumpkin> dons: aha, I had a bunch of messed up cabal state preventing it from working, I think it's getting fixed now :)
20:10:59 <Cale> :t uncurry curry
20:11:00 <lambdabot> forall a b c. ((a, b) -> c, a) -> b -> c
20:11:01 <Cale> hehe
20:11:06 <pumpkin> thanks
20:13:53 <llayland> is it possible to state a function returns bottom ie -  f [] = _|_
20:14:14 <pumpkin> undefined?
20:14:24 <llayland> ah
20:14:26 <pumpkin> are they the same thing?
20:14:31 <pumpkin> I think so, not sure though
20:14:57 <cjs> Technically not, but for practical purposes they are.
20:15:09 <johnnowak> cjs: why technically not?
20:15:24 <llayland> undefined works for this.  thanks.
20:15:26 <roconnor> f [] = fix id
20:15:31 <cjs> Well, for example _|_ can represent non-termination. But undefined very much terminates your program. :-)
20:15:37 <pumpkin> ah
20:15:43 <johnnowak> ah, right
20:15:51 <roconnor> with extreme prejudice
20:15:57 <roconnor> > const 5 undefined
20:15:59 <lambdabot>   5
20:16:18 <ozy`> @let undefined_ = undefined_
20:16:19 <lambdabot>  Defined.
20:16:26 * ozy` gasps
20:16:29 <pumpkin> lol
20:16:32 <roconnor> > undefined_
20:16:40 <lament> heh @ "Defined"
20:16:40 <llayland> oops
20:16:48 <lambdabot>   thread killed
20:16:54 <ozy`> llayland: yes, that's what it was for :p
20:17:01 <cjs> Well, you can't say lambdabot doesn't try,.
20:17:13 <Gracenotes> damn you, lazy evaluation! -.-
20:17:16 <llayland> nice
20:18:03 <orbitz> dam you all to hellllll!
20:18:11 <pumpkin> lol
20:19:16 <thedward> hmm, the version of regex-base I have installed seems to be missing an instance for letting =~ return a list of strings.
20:19:28 <dons> thedward: yes! someone else mentioned this.
20:19:42 <dons> we should ask chris what the story is.
20:19:49 <dons> since he shouldn't be removing instances
20:19:57 <pumpkin> is there something like c++filt to demangle haskell's mangled symbols?
20:20:27 <thedward> dons: there does appears to be an instance however for [[String]]; which seems strange
20:21:01 <adu> hasktags?
20:21:13 <thedward> I was mainly making sure it wasn't just me.
20:21:14 <adu> or we could call it haskfilt
20:21:32 <thedward> I've broken my haskell more than once by doing silly things.
20:23:41 <dons> hmm. 800 projects uploaded this year.
20:24:02 <pumpkin> dons: where do you get these stats? :o
20:24:10 <dons> hackage :)
20:24:11 <wchogg> This is going to sound dumb...but other than finalizers, what's different about Ptr vs. ForeignPtr?  Anything?
20:24:21 <dons> now to filter out things released prior to 2008
20:24:34 <dons> wchogg: allocation internals
20:25:55 <wchogg> dons:  any basic consequences to watch out for or do I just need to RTFFFI?
20:25:57 <dons> the following projects were released on hackage this year (including how many updates), http://galois.com/~dons/tmp/2008-releases.txt
20:26:03 <dons> wchogg: they're very different?
20:26:15 <dons> ForeignPtr is specially for when you want to manage the resource in some way
20:26:18 <dons> Ptr is just a .. pointer.
20:27:18 * sm installed regexpr and got on with work
20:27:26 <adu> pumpkin: you could just write a main-wrapper for zEncodeString and zDecodeString from ghc/compiler/utils/Encoding.hs
20:27:42 <pumpkin> adu: ?
20:27:47 <pumpkin> oh I see
20:27:57 <pumpkin> yeah, that's an option
20:28:11 <wchogg> dons:  I think I'm not being very clear about my question, sorry.  I'm trying to debug something strange in some bindings & I was wondering if it could be caused by not using any ForeignPtr when I should have.
20:30:37 <sjanssen> @keal
20:30:38 <lambdabot> all i know is i have experienced my own death unhappening...
20:30:42 <sjanssen> hahaha
20:31:20 <wchogg> ...?
20:31:37 <sjanssen> wchogg: keal is a crazy guy that used to hang out in #haskell
20:32:13 <dons> 601 new releases on hackage this year.
20:32:39 <sjanssen> dons: brand new packages, or new versions?
20:32:48 <dons> new packages that hasn't been released on hackage before
20:32:54 <sjanssen> impressive
20:33:18 <dons> http://galois.com/~dons/tmp/new-releases-2008.txt
20:33:19 <sjanssen> we really need to get going on search for packages
20:33:33 <sjanssen> also some sort of rating system
20:33:38 <dons> yep
20:33:49 <dons> so now, i want to pick the best new libs
20:33:50 <Cale> HIntegerByInt seems not to be there
20:33:53 <dons> but 600 is kinda hard to vote on.
20:34:22 <sjanssen> dons: I'd go with download count, and an Amazon-esque rating system
20:34:27 <dons> sure.
20:34:52 <llayland> Is there a download count? I didn't see one
20:35:00 <dons> no, but it can be obtained
20:35:19 * sm wonders about that new happs-based hackage that was coming
20:35:22 <sjanssen> you don't have to vote on all 600 at once.  Even if just a portion of users vote when they have a good (or bad) experience with a particular package, we'd be off to a great start
20:35:48 <dons> dcoutts_: what is holding up deployment of the new hackage server, iyo?
20:36:27 <wchogg> What's really the point of rating them?  It seems like that information would be useless for libraries that are updated frequently.  You either keep around irrelevant results or never have a good sample of datapoints.
20:36:35 <sm> if a user can give a 5-star rating on the package page, that's all you need to start
20:36:46 <dons> there's a whole bunch of heuristics to help people
20:37:13 <sjanssen> wchogg: you might use some sort of moving average
20:37:35 <sjanssen> weight ratings against version x+1 of a package more highly than version x, and so on
20:37:55 <llayland> how about the one that is used by the most other packages?
20:38:09 <sjanssen> llayland: another useful measure
20:40:10 <wchogg> Eh...I'm afraid that any kind of serious ratings system is the kind of thing that will lead drama or reluctance for people to contribute.
20:40:14 <lispy> we have voting now?
20:41:30 <llayland> wchong: yes I'd hate to see haskdot
20:41:56 <sjanssen> wchogg: really?
20:43:17 <wchogg> sjanssen:  Honestly, yeah.  I think it sounds intimidating.  I might be unique in that regard, though.
20:43:18 <sm> I don't see that.. ratings as on amazon, firefox addons site, and even slashdot are useful
20:44:21 <sm> I mean, the 5 stars and number of voters. helps me get a quick sense of things
20:44:33 <llayland> sjanssen: I know many people that will contribute to something without recognition, but won't if their contribution would stand a good chance of being rated poorly
20:45:10 <llayland> especially bad for packages with limited applicability
20:45:50 <pumpkin> how common is the arrow package? I love using the easy parts of it, although I don't quite get what arrows are in general yet :)
20:46:11 <sm> llayland: maybe we'd be better off without that contribution ?
20:46:23 <sm> encouraging people to contribute to hackage is no longer a problem
20:46:34 <pumpkin> sm: niche packages are good, I think
20:46:35 <sm> but sorting out the good stuff is..
20:46:39 * pumpkin mutters TAO
20:46:54 <doublec> quality of docs would weigh heavily on the vote I suspect
20:46:55 <sm> oh sure, but I don't see why those would be rated poorly. In the metric I'm talking about
20:47:01 <pumpkin> oh I see
20:47:16 <doublec> you can have a great package but if it's hard to find out how to use it, not many will use it and vote for it
20:48:17 <Megzlna> Why doesn't the Haskell Way include namespacing away of functions that work on a particular value type?
20:48:29 <wchogg> And packages can be improved by community help & support, which I think makes it a bit different than the Amazon ratings case.  Either way, I don't care _that_ much but I do lean towards just giving dependency statistics to show how widespread something is rather than a true rating.
20:48:34 <sjanssen> llayland: packages with limited applicability will just get fewer ratings, they won't get lower ratings
20:48:54 <lispy> We should remove the announce check box from hpaste
20:48:57 <pumpkin> I get the impression this searchpath thing is recompiling stuff I already have :o
20:49:00 <lispy> It confuses people and it doesn't work
20:49:06 <sjanssen> lispy: we should make the announce feature work!
20:49:08 <Cale> Megzlna: because we have the module system for controlling the namespace
20:49:11 <Megzlna> Cale: Rather not on the granularity of a module
20:49:20 <sjanssen> llayland: nobody is going to rate a package they don't use
20:49:26 <llayland> Sjanssen hopefully.  I'm cynic :)
20:49:27 <lispy> sjanssen: so why is it broken?
20:49:32 <sjanssen> lispy: ask glguy?
20:49:36 <ozy`> lispy: or it should just be a link to lisppaste, which has a working announce feature
20:49:47 <Megzlna> Because then you use potentially a Module per type
20:50:04 <Megzlna> Unless, you could make multiple modules in 1 file?
20:50:10 <Cale> Megzlna: You could. Some people advocate that approach.
20:50:18 <Cale> (one module per type)
20:50:30 <lispy> Well, one problem with making it work is that it's not at all clear what announce will do when it does work
20:50:38 <Cale> Sometimes you have a few interrelated types which work well together in one module
20:50:41 <Megzlna> well, that's too teutonic for me
20:50:44 <lispy> Will it post my code to reddit?
20:51:02 <lispy> but, that's about as easy to fix as making it go away
20:51:14 <lispy> So, I say that until someone fixes it, it should go away :)
20:51:48 <Megzlna> too teutonic being 1 per module
20:52:01 <Megzlna> What about multi modules to a file?
20:52:50 <Cale> Megzlna: I would like to be able to directly nest modules, but the current system helps GHC find modules automatically rather well.
20:52:55 <Megzlna> If you try to use 1 value type per module, then you're turning Haskell into OO
20:52:55 <lispy> Megzlna: the haskell spec doesn't forbid it, but non of the existing compilers seem to allow it
20:53:01 <Megzlna> and explicitly passing around the this pointer
20:53:03 <Megzlna> like in C
20:53:22 <lispy> Haskell modules are very similar to OO classes
20:53:29 <lispy> At least in the way they are used
20:53:35 <sjanssen> lispy: huh?  I don't think that is very true
20:53:41 <pumpkin> dons: http://pastie.org/private/aie9h7h2l7aa8n0usclbw :(
20:53:41 <sjanssen> some modules, like Data.Map, sure
20:53:42 <pumpkin> same error
20:53:46 <sjanssen> but most are not like OO at all
20:55:17 <ozy`> Megzlna: yeah, you can write all functions with infix notation as well
20:55:36 <Megzlna> o `method` 1 2 3
20:55:36 <Megzlna> ?
20:55:38 <Megzlna> lol
20:56:20 <sjanssen> there was a crazy Haskell tutorial that redefined (.) = flip ($)
20:56:23 <ozy`> exactly!
20:56:35 <pumpkin> ah, I remember seeing that
20:56:43 <ozy`> @src (.)
20:56:44 <lambdabot> (f . g) x = f (g x)
20:56:44 <sjanssen> so you could write: [1,2,3].take(10).map(+1).sum
20:56:45 <Megzlna> o.f 1 2 3 ?
20:56:50 <wchogg> sjanssen:  so have you ever had an FFI issue where an object you have a pointer to appears to remain the same over time even you could _swear_ that it should be changing?
20:56:51 <Megzlna> worked if you did that?
20:57:32 <ozy`> Megzlna: yep
20:57:42 <sjanssen> wchogg: how are you allocating the pointer?  malloc/Haskell's GC/the applications internal memory management might just be reusing the same memory area
20:57:52 <ozy`> @pl flip (.)
20:57:53 <lambdabot> flip (.)
20:57:57 <ozy`> @unpl flip (.)
20:57:57 <lambdabot> (\ b c f -> c (b f))
20:58:36 <sjanssen> > let (.) = flip ($) in [1,2,3].take(2).map(+1).sum
20:58:37 <lambdabot>   5
20:58:40 <sjanssen> hilarious
20:58:47 <ozy`> lulz
20:59:21 <Megzlna> niiiiice
21:00:00 <Megzlna> so why not just add "Objects" as some extension in the first place
21:00:11 <hml> anyone here ever write a siggraph paper? just curious if anyone's written a siggraph paper using haskell
21:00:20 <Megzlna> which are just finer grained Modules / namespaces
21:00:23 <pumpkin> anyone have any issues on my happs error? http://pastie.org/private/aie9h7h2l7aa8n0usclbw I've cabal-installed all the dependencies, but attempting to run the sample app fails as in that pastie
21:00:25 <sjanssen> Megzlna: because we don't need them?
21:00:28 <Megzlna> and some convention for Operators
21:00:38 <Megzlna> sjanssen: Says who?
21:00:40 <Cale> Well, that's not clearly better than  sum . map (+1) . take 2 $ [1,2,3]
21:00:44 <sm> why do I get `coarbitrary' is not a (visible) method of class `Arbitrary' during cabal install SHA ?
21:01:01 <wchogg> sjanssen:  Well so what I have is a pointer to an array of pointers of wiimotes.  This is allocated by the library I'm binding.  I can use the first pointer in the array to modify the state of the wiimote, but if I try to read from the pointer it's always the initial state with which it was created.
21:01:06 <sjanssen> Cale: wtf is that?  You crazy Haskell people!
21:01:43 <wchogg> sm:  mismatch between your quickcheck version & what the library wants?  Quickcheck 2 separated out Aribitrary & Coarbitrary
21:01:54 <sm> ooh, thanks for the pointer
21:02:34 <Megzlna> the idea of no namespaces is a rather elevated idea about perfection of genericity
21:02:59 <Megzlna> but I think in practice, it's impossible to not have some functions only work on some value types
21:03:26 <Cale> Megzlna: There *are* namespaces.
21:03:35 <Megzlna> yes, Module
21:03:51 <Cale> I suppose the feeling is that we don't need any other means of controlling namespaces.
21:04:10 <Megzlna> But I was following up on ... "Object" as finer grained namespaces
21:04:14 <Cale> We have one, and it should be good enough to keep the number of visible names to something manageable.
21:04:33 * sm hides both versions of QuickCheck but still can't build SHA
21:05:08 <Cale> sm: By 'hides' do you mean that you edited the .cabal file for SHA?
21:05:18 <sm> no I mean ghc-pkg hide ?
21:05:23 <Cale> oh, don't do that :)
21:05:29 <sm> ack
21:05:44 <pumpkin> I don't really get what searchpath does :o
21:06:00 <Cale> The SHA package probably just doesn't specify that it needs a version of QuickCheck < 2
21:06:07 <sm> editing the .cabal file for downloaded packages is a drag, it's cached in some mysterious place and re-downloaded each time..
21:06:10 <sjanssen> pumpkin: does anyone actually use that any more?
21:06:14 <august> i thought you were a haskell guru, pumpkin
21:06:19 <pumpkin> sjanssen: it's listed on the happs page
21:06:22 <sm> I've had luck tweaking the environment with ghc-pkg before
21:06:26 <pumpkin> august: not at all
21:06:28 <Cale> sm: Well, it would be good to send the author a comment about their broken package.
21:06:40 <sm> ok. I guess it is broken then
21:06:42 <Cale> and maybe a patch :)
21:06:44 <sm> thanks
21:06:57 <Cale> sm: It should be an easy fix in this case
21:07:33 <Cale> sm: Either ensure that it's using QC 1 or else update it to define separate Arbitrary and Coarbitrary instances.
21:07:39 <pumpkin> sjanssen: http://happs.org/ right on step 3 :P
21:07:42 <Cale> (and require QC 2)
21:07:45 <pumpkin> sjanssen: also happens to be what's failing
21:07:58 <pumpkin> (I think it's trying to reinstall packages I already cabal-installed)
21:08:03 <sjanssen> pumpkin: ah, maybe you could try cabal install instead?
21:08:08 <sm> I use sp strictly for rebuilding when local files change, and it simply rocks
21:08:25 <pumpkin> sjanssen: I did, I have all the happs components, but I don't know how to start the sample happs app :o
21:08:35 <pumpkin> since step 3 starts the http server
21:08:57 <vegai> aww, why isn't (.) = flip ($) in Prelude...
21:08:58 <sjanssen> pumpkin: looks like "runghc -isrc src/Main.hs --http-port=foobar" is the right command
21:09:07 <pumpkin> sjanssen: thanks!
21:09:44 <pumpkin> sjanssen: it works! is it safe for me to get rid of the ~/.searchpath?
21:09:57 <sjanssen> pumpkin: probably?  I haven't really used it
21:10:01 <pumpkin> ah ok
21:10:17 <Megzlna> Cale: Can I alias Foo.f to f only within a small scope?
21:10:42 <llayland> is trinary the correct adjective for a function with arity 3?  seems odd for some reason
21:10:46 <Megzlna> or must it import to the entire module
21:10:50 <pumpkin> ternary?
21:10:58 <pumpkin> not sure
21:11:16 <Megzlna> triple
21:11:36 <smarmy> ternary
21:11:39 <Cale> Megzlna: You can  let Foo.f = f in ...
21:11:40 <Cale> er
21:11:45 <Cale> Megzlna: You can  let f = Foo.f in ...
21:11:47 <Cale> rather
21:11:51 <llayland> ternary, yeah that is the ticket.  Thanks
21:12:02 <Megzlna> let f = Foo.f in { work?
21:12:44 <Megzlna> I wonder if ghc inlines that away entirely
21:13:06 <firedrill> whats the best monad tutorial around?
21:13:15 <smarmy> cale
21:13:20 <smarmy> ;)
21:14:08 <wchogg> firedrill:  I'm fond of All About Monads
21:14:48 <firedrill> thanks smary and wchogg
21:14:50 <august> wasn't that going to be the name of Window's new cli?
21:14:58 <august> Monad
21:15:18 <Cale> firedrill: hehe -- I've written a couple.
21:15:24 <pumpkin> august: yeah, I think so
21:15:30 <pumpkin> "Windows PowerShell"
21:15:39 <pumpkin> I swear they make a point of coming up with the worst names ever
21:16:02 <august> PowerShell sounds like it should be in Mario Kart
21:16:19 <pumpkin> I'm sure it'd be made of glass
21:17:04 <llayland> Is ghc's optimization good enough that (foldl1 (++) (map toXml [a,b.c])) performs the same as toXml a ++ toXml b ++ toXml c?  I'm guessing so
21:17:28 <llayland> err b,c not b.c
21:17:30 <sjanssen> llayland: foldl1 (++) is not the same thing
21:17:42 <sjanssen> llayland: you want foldr (++) []
21:17:47 <august> and yes, pumpkin, that question i just asked is a joke
21:17:51 <firedrill> cale: readin it
21:17:57 <Cale> firedrill: Which one?
21:17:58 <pumpkin> august: ORLY
21:19:08 <firedrill> oh wiat
21:19:12 <firedrill> this isnt yours is it: http://www.alpheccar.org/en/posts/show/60
21:19:26 <firedrill> i searched for cale monad tutorial and got this
21:19:57 <sm> I got SHA built.. I think cabal was using the hidden user QC 2 and ignoring the exposed global QC 1
21:20:42 <Cale> firedrill: oh, no.
21:20:49 <sm> that user/global thing is really tricky
21:20:52 <Cale> firedrill: I just replied to that
21:21:08 <pumpkin> my ghc 6.10 came with parsec 2
21:21:09 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
21:21:14 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
21:21:14 <pumpkin> is it safe to upgrade to 3?
21:21:22 <llayland> sjanssen, interesting. same result but foldr can be better optimized ?
21:21:37 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- not really about monads, but a quick way to get thinking about IO properly
21:22:52 <Megzlna> Cale: http://www.haskell.org/hierarchical-modules/
21:22:56 <Megzlna> what's wrong with that?
21:22:59 <pumpkin> august: you played with haskell much yet? :)
21:23:18 <sjanssen> llayland: (++) is O(n) in its first argument, so it is best to use it in a right associative way
21:23:19 <august> still learning me a haskell
21:23:27 <sjanssen> llayland: also, you'd be best of just using "concat"
21:23:31 <Cale> Megzlna: Nothing. It's what's implemented in GHC and Hugs, etc.
21:23:58 <Megzlna> oh, it's not what I thought?
21:24:04 <Megzlna> this is the regular old modules?
21:24:43 <Cale> Megzlna: It's a very small change. All it does is add '.' to the list of valid characters in a module name.
21:24:57 <Megzlna> ah ;/
21:25:17 <sm> why does cabal install cgi or cgi-any.version always say Couldn't read cabal file "./cgi/3001.1.7.1/cgi.cabal" ?
21:25:38 <intrados> why would "myMod n d = (n/d-fromInteger(truncate(n/d)))*d" return "0.5000001" for "5.5 `myMod` 2.5"?
21:26:18 <Cale> intrados: Floating point rounding error?
21:26:34 <pumpkin> seems weird to have that on 1/2
21:27:18 <intrados> yeah. but why would it give me that rounding error? it's not terribly complex. is there anything I can do to fix it?
21:27:40 <Cale> I get 0.5000000000000004
21:27:55 <Cale> You could use the Rational type
21:28:03 <intrados> well, it's actually part of a foldl
21:28:04 <pumpkin> > let myMod n d = (n/d-fromInteger(truncate(n/d)))*d in 5.5 `myMod` 2.5
21:28:06 <lambdabot>   0.5000000000000004
21:28:14 <llayland> Thanks sjanssen.  I'd normally use concat. but I'm practicing folding
21:28:26 <Cale> > let myMod n d = (n/d-fromInteger(floor(n/d)))*d in 5.5 `myMod` 2.5
21:28:27 <lambdabot>   0.5000000000000004
21:29:33 <pumpkin> how can I force parsec 3 to install? if I do cabal install parsec --reinstall, it just grabs 2 again
21:29:36 <Cale> intrados: Basically, little rounding errors like that are common when doing calculations on floating point values. You just have to be careful never to compare floating point values for equality, but instead test whether they're within some small range of one another.
21:30:57 <Cale> > 5.5 / 2.5
21:30:59 <lambdabot>   2.2
21:31:08 <Cale> > 5.5 / 2.5 - 2
21:31:10 <lambdabot>   0.20000000000000018
21:31:35 <intrados> is the [.5000001] that I see in my ghci output the actual value or is it just shortened some for readability?
21:32:10 <sjanssen> intrados: any decimal rendering of a Float or Double is probably not the actual value
21:32:16 <intrados> okay
21:32:51 <intrados> is this a peculiar feature of haskell or are other languages just better at hiding it?
21:33:01 <Elly> other languages hide it
21:33:10 <Elly> it's a "feature" of the way floating-point is implemented in hardware
21:33:18 <sjanssen> intrados: Haskell uses IEE for floating point, which pretty much all other languages also use
21:33:29 <Megzlna> CReal
21:33:34 <Elly> if you are interested in the gory parts, look up IEEE 754
21:33:36 <pumpkin> although it doesn't commit to using IEEE 754
21:33:42 <intrados> okay. I just checked in python and it gave the exact same value for 5.5/2.5-2
21:33:43 <pumpkin> it just happens to most of the time
21:33:53 <sjanssen> pumpkin: I'm fairly certain the report says IEEE 754
21:34:06 <pumpkin> I thought someone brought up the fact that it doesn't the other day
21:34:08 <pumpkin> and that's why
21:34:09 <ozy`> intrados: there are fixed-point and decimal data types that perform all their rounding errors in base 10
21:34:13 <sjanssen> maybe you're right
21:34:15 <pumpkin> > isIEEE 7.54 -- exists
21:34:16 * sjanssen checks
21:34:16 <lambdabot>   True
21:34:32 <Elly> seriously?
21:34:39 <sjanssen> pumpkin: ah, I think it only guarantees IEEE 754 for the built in Float and Double types
21:34:42 <Elly> oh, wow
21:34:59 <sjanssen> isIEEE is for types that want to be instances of that class, but don't have the IEEE semantics
21:35:04 <pumpkin> ah
21:35:08 <sjanssen> > isIEEE (1 :: CReal)
21:35:09 <lambdabot>   False
21:36:13 <pumpkin> :t pi
21:36:14 <lambdabot> forall a. (Floating a) => a
21:36:18 <Cale> Heh, I suppose since it takes a value parameter, you could extend IEEE floating point with additional values, and it would distinguish the extensions :)
21:36:58 <Cale> > map isDenormalized (iterate (/2) 1)
21:37:00 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
21:37:15 <Cale> > map (fromEnum . isDenormalized) (iterate (/2) 1)
21:37:16 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:37:31 <Cale> hmm
21:37:42 <Cale> actually, it doesn't hit anything that way
21:38:02 <sjanssen> pumpkin: I guess all the report says is that Float and Double *should* have similar precision to the IEEE single and double precision types
21:38:09 <pumpkin> ah
21:38:27 <pumpkin> > sqrt 1By2
21:38:28 <lambdabot>   Not in scope: data constructor `By2'
21:38:29 <pumpkin> > sqrt1By2
21:38:31 <lambdabot>   Not in scope: `sqrt1By2'
21:38:55 <Cale> > isDenormalized 1.2e-322
21:38:56 <lambdabot>   True
21:40:25 <solrize> is (Set.toList . Set.fromList) a good way to get the unique elements of a number list if i don't care about preserving the order?  nub is quadratic time, not so good
21:41:36 <pumpkin> > omg
21:41:38 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,...
21:42:31 <sjanssen> solrize: yes, that is a pretty good way to do it
21:42:37 <solrize> thanks
21:43:25 <august> omg is pi?
21:43:43 <august> > Ï€
21:43:44 <lambdabot>   Not in scope: `Ï€'
21:43:49 <august> > pi
21:43:51 <lambdabot>   3.141592653589793
21:44:13 <pumpkin> > Ï€
21:44:14 <lambdabot>   3.141592653589793
21:44:23 <august> hey now
21:44:28 <sjanssen> > pi :: CReal
21:44:30 <lambdabot>   3.1415926535897932384626433832795028841972
21:44:43 <august> why did your Ï€ work?
21:44:46 <pumpkin> > showCReal 50 pi
21:44:47 <lambdabot>   "3.14159265358979323846264338327950288419716939937511"
21:44:59 <pumpkin> august: I @let it in a pm :P
21:45:05 <august> psh
21:49:25 <roconnor> > Ï€
21:49:27 <lambdabot>   3.1415926535897932384626433832795028841972
21:49:54 <august> > e^(iÏ€)
21:49:55 <lambdabot>   Not in scope: `iÏ€'
21:49:59 <august> > e^(i*Ï€)
21:50:00 <lambdabot>   Couldn't match expected type `Expr' against inferred type `CReal'
21:50:56 <sjanssen> > i
21:50:58 <lambdabot>       Ambiguous occurrence `i'
21:50:58 <lambdabot>      It could refer to either `L.i', defined a...
21:51:01 <lispy> how can we get haskell to work with this? http://arstechnica.com/news.ars/post/20081209-safer-than-activex-a-look-at-googles-native-client-plugin.html
21:51:06 <dolio> > e^(0 :+ Ï€)
21:51:07 <lambdabot>       No instance for (Integral (Complex (Complex CReal)))
21:51:07 <lambdabot>        arising fro...
21:51:10 <lispy> I want a ghc -> nacl compiler
21:51:18 <roconnor> > e**(i*Ï€)
21:51:19 <lambdabot>       Ambiguous occurrence `e'
21:51:19 <lambdabot>      It could refer to either `L.e', defined a...
21:51:21 <dolio> > e^^(0 :+ Ï€)
21:51:22 <lambdabot>       Ambiguous occurrence `e'
21:51:22 <lambdabot>      It could refer to either `L.e', defined a...
21:51:28 <roconnor> damn
21:51:30 <dolio> > exp(0)^^(0 :+ Ï€)
21:51:31 <lambdabot>       No instance for (Integral (Complex (Complex CReal)))
21:51:32 <lambdabot>        arising fro...
21:51:36 <dolio> Geeze.
21:51:39 <sjanssen> dolio: the argument to (^^) must be Integral
21:51:40 <dolio> > exp(0)**(0 :+ Ï€)
21:51:42 <lambdabot>       No instance for (RealFloat (Complex CReal))
21:51:42 <lambdabot>        arising from a use o...
21:51:49 <dolio> Well, that's it. :)
21:51:55 <lispy> that's seriously spammy guys :)
21:51:58 <sjanssen> > exp (0 :+ pi)
21:51:58 <roconnor> > exp(0)**((0 :+ 1)*Ï€)
21:52:00 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
21:52:03 <lambdabot>   1.0 :+ 0.0
21:52:07 <lispy> maybe better to play in #haskell-overflow?
21:52:09 <dolio> Ah, there we go.
21:52:26 <august> > exp(0)
21:52:27 <lambdabot>   1.0
21:52:34 <dolio> Oh right.
21:52:37 <sjanssen> exp = (e**)
21:52:43 * dolio is a bit out of it.
21:53:39 <ozy`> lispy: I guess so long as you can compile to C, you can compile the C to NaCL
21:54:27 <ozy`> "Google supplies a customized GCC build toolchain that can be used to compile portable binaries that are compatible with the Native Client infrastructure."
21:54:44 <cygnus_> > exp ( 1)
21:54:45 <lambdabot>   2.718281828459045
21:54:58 <cygnus_> > exp ( Pi)
21:54:59 <lambdabot>   Not in scope: data constructor `Pi'
21:55:03 <lispy> ozy`: yeah, so I guess you -fvia-C and trust that their modified gcc is still close enough to normal gcc?
21:55:06 <cygnus_> > exp ( Math.Pi)
21:55:07 <lambdabot>       Failed to load interface for `Math':
21:55:07 <lambdabot>        Use -v to see a list of the...
21:55:13 <roconnor> > exp pi
21:55:14 <ozy`> lispy: exactly
21:55:14 <lambdabot>   23.140692632779267
21:55:21 <cygnus_> > exp ( ii)
21:55:22 <lambdabot>   Not in scope: `ii'
21:55:26 <cygnus_> > exp ( pi)
21:55:27 <lambdabot>   23.140692632779267
21:55:32 <cygnus_> > exp ( i * pi)
21:55:33 <lambdabot>       Ambiguous occurrence `i'
21:55:33 <lambdabot>      It could refer to either `L.i', defined a...
21:55:40 <lispy> cygnus_: dr. cygnus?
21:55:45 <ozy`> lispy: I suspect it will require modification to the C runtime though, judging by the weird-looking hello world program in the article
21:55:46 <cygnus_> i wish
21:58:07 <cygnus_> > sqrt ( 1)
21:58:08 <lambdabot>   1.0
21:58:19 <cygnus_> > exp ( sqrt ( -1) * pi )
21:58:20 <lambdabot>   NaN
22:01:11 <lispy> ?tell gwern can we make lambdabot error messages be just 1 line like they were in the pre-mueval days?
22:01:11 <lambdabot> Consider it noted.
22:02:15 <august> NaN?
22:02:26 <august> that's a bug
22:02:34 <pumpkin> august: nope
22:02:43 <pumpkin> you didn't tell it you wanted a complex :P
22:02:48 <pumpkin> > sqrt (-1)
22:02:49 <lambdabot>   NaN
22:02:52 <august> e^(iÏ€) is 1
22:02:53 <pumpkin> > sqrt (-1) :: Complex Double
22:02:55 <lambdabot>   (-0.0) :+ 1.0
22:03:11 <pumpkin> > exp ( sqrt ( -1) * pi ) :: Complex CReal
22:03:12 <lambdabot>   (-1.0) :+ 0.0
22:03:26 <cygnus_> nice
22:03:34 <cygnus_> what does := mean
22:03:49 <roconnor> where?
22:03:53 <august> instead of -1 + 0i
22:03:55 <cygnus_> i mean :+
22:03:58 <pumpkin> :+ is a + bi
22:04:15 <cygnus_> ugly
22:04:17 <pumpkin> it's a data constructor for complex
22:04:24 <roconnor> yep
22:04:46 <roconnor> just let i = (0 :+ 1) and never look back
22:05:06 <cygnus_> exp ( sqrt (-1) * pi / 2 ) :: Complex CReal
22:05:19 <cygnus_> what did i do wrong
22:05:19 <solrize> @hoogle mapConcat
22:05:20 <lambdabot> No results found
22:05:26 <solrize> @hoogle concatMap
22:05:26 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
22:05:26 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
22:05:26 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
22:06:00 <august> cygnus_: need a > to start
22:06:02 <pumpkin> cygnus_: you didn't preprend >
22:06:09 <august> too slow
22:06:45 <cygnus_> > exp ( sqrt (-1) * pi / 2 ) :: Complex CReal
22:06:46 <lambdabot>   0.0 :+ 1.0
22:06:50 <cygnus_> this robot is a genius
22:07:35 <roconnor> cygnus_:
22:07:39 <roconnor> cygnus_:  not really
22:07:45 <roconnor> > cos (2*pi/3) :: CReal
22:07:47 <lambdabot>   0.5
22:07:51 <roconnor> > cos (2*pi/3)
22:07:53 <lambdabot>   -0.4999999999999998
22:08:07 <cygnus_> whats going on there
22:08:11 <cygnus_> creal has less precision?
22:08:18 <cygnus_> or more precision
22:08:28 <roconnor> lambdabot is a moron
22:08:32 <roconnor> that's the problem
22:08:53 <cygnus_> hold it's arms and i will work the chest
22:09:09 <roconnor> pervert
22:09:18 <roconnor> :)
22:10:01 <august> more precision
22:10:14 <august> that 999999999999998 comes from rounding errors
22:10:35 <august> > [0.1...1.0]
22:10:35 <lambdabot>   Not in scope: `...'
22:10:39 <august> > [0.1..1.0]
22:10:40 <lambdabot>   [0.1,1.1]
22:10:45 <august> > [0.1,0.2..1.0]
22:10:46 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999999...
22:10:52 <august> > [0.1,0.2..1.0] :: CReal
22:10:53 <roconnor> > (read . show) (cos (2*pi/3) :: CReal) - cos (2*pi/3)
22:10:53 <lambdabot>   Couldn't match expected type `CReal' against inferred type `[a]'
22:10:54 <lambdabot>   0.9999999999999998
22:11:06 <august> > [0.1,0.2..1.0] :: Double
22:11:07 <lambdabot>   Couldn't match expected type `Double' against inferred type `[a]'
22:11:09 <roconnor> > (read . show) (cos (pi/3) :: CReal) - cos (pi/3)
22:11:10 <lambdabot>   -1.1102230246251565e-16
22:11:15 <roconnor> > (read . show) (cos (2*pi/3) :: CReal) - cos (2*pi/3)
22:11:17 <lambdabot>   0.9999999999999998
22:11:29 <roconnor> CReal has the dumb
22:12:15 <pumpkin> :o
22:12:25 * thoughtpolice yawns
22:12:39 <cygnus_> what do scientists use
22:13:46 <roconnor> Double
22:14:02 <august> Science!
22:14:44 <roconnor> Stand back!  \o/b  I'm going to try SCIENCE!
22:15:31 <dons> do it!
22:15:37 <pumpkin> onoes not science!
22:15:39 * pumpkin hides
22:15:43 <roconnor> > cos (2*pi/3)
22:15:45 <lambdabot>   -0.4999999999999998
22:15:50 <roconnor> damn
22:16:21 <roconnor> http://store.xkcd.com/#StandBackScience
22:16:24 <pumpkin> oh no, science has failed!
22:16:29 <pumpkin> let ID prevail :P
22:16:39 <roconnor> only $17
22:16:50 <roconnor> makes a great gift
22:16:55 <cygnus_> > cois ( 2 * pi /3 ) :: Double
22:16:56 <lambdabot>   Not in scope: `cois'
22:16:57 <pumpkin> he came and gave a talk here a few weeks ago
22:16:59 <cygnus_> > cos ( 2 * pi /3 ) :: Double
22:17:00 <pumpkin> (randall munroe)
22:17:01 <lambdabot>   -0.4999999999999998
22:17:03 <cygnus_> ???
22:17:05 <cygnus_> not double
22:17:20 <cygnus_> i want to build a space craft with haskell but i can't trust the precision
22:17:21 <pumpkin> plenty doubl
22:17:37 <pumpkin> > cos ( 2 * pi / 3) :: Triple
22:17:38 <lambdabot>       Not in scope: type constructor or class `Triple'
22:17:44 <Cale> heh
22:17:45 <pumpkin> > cos ( 2 * pi / 3) :: Quintuple
22:17:46 <lambdabot>       Not in scope: type constructor or class `Quintuple'
22:17:48 <pumpkin> :(
22:17:57 <Cale> > cos (2*pi / 3) :: CReal
22:17:59 <lambdabot>   0.5
22:18:35 <cygnus_> > cos ( 2 * pi /3 ) :: CReal - cos ( 2 * pi / 3 ) :: Creal
22:18:36 <roconnor> cygnus_: then you'll be happy to learn that the guy who wrote CReal works for NASA
22:18:36 <lambdabot>   <no location info>: parse error on input `-'
22:18:53 * roconnor isn't kidding
22:19:12 <Cale> > cos ( 2 * pi /3 ) - cos ( 2 * pi / 3 ) :: CReal
22:19:13 <lambdabot>   0.0
22:19:33 <cygnus_> ok cool
22:19:35 <Cale> roconnor: Of course, it's upsetting in that case that there's a terrible bug in it.
22:19:49 <roconnor> although I think he wrote CReal before he worked at NASA
22:20:04 <roconnor> at NASA he proved the CReal implementation correct using PVS
22:20:09 <roconnor> ... and found a few bugs
22:20:35 <cygnus_> PVS?
22:20:44 <cygnus_> is that isabelle
22:20:52 <pumpkin> prove very systematically
22:20:55 <roconnor> I don't think so
22:21:13 <cygnus_> i know at my old university they did a lot of haskell proofs with isabelle
22:23:04 <august> kinky
22:23:26 <Cale> > cos (2 * pi / 3) :: CReal
22:23:27 <lambdabot>   0.5
22:23:30 <Cale> ^^ bug
22:23:51 <cygnus_> ye
22:23:52 <cygnus_> wtf
22:23:57 <cygnus_> why is it not negative
22:24:01 * roconnor was reviewing his paper moments ago
22:24:26 <cygnus_> cos ( pi )
22:24:28 <august> google got it correct
22:24:33 <cygnus_> > cos ( pi )
22:24:34 <lambdabot>   -1.0
22:24:38 <cygnus_> > cos ( pi ) :: CReal
22:24:40 <lambdabot>   -1.0
22:24:46 <cygnus_> i don't get it
22:24:53 <Cale> I think there's a sign problem in how cos is extended to arbitrary real parameters. It appears to have a discontinuity.
22:25:01 <pumpkin> do people use http://hackage.haskell.org/cgi-bin/hackage-scripts/package/html with happs normally?
22:25:12 <dons> or xhtml
22:25:17 <dons> or hstringtemplate
22:25:21 <dons> or formlets
22:25:28 <dons> or anything that constructs html
22:25:54 <roconnor> oh wait
22:26:02 <roconnor> I can fix the CReal package
22:26:10 <roconnor> now that I have a hackage account
22:26:19 <pumpkin> > cos (2 * pi / 3)
22:26:21 <lambdabot>   -0.4999999999999998
22:26:25 <roconnor> I should do that some time
22:26:43 <cygnus_> cos ( 2 * pi /3 + 0.000000001) :: Creal
22:26:46 <cygnus_> > cos ( 2 * pi /3 + 0.000000001) :: CReal
22:26:47 <sjanssen> roconnor: wouldn't it be better to send a bug fix to the maintainer?
22:26:48 <lambdabot>   0.5000000008660254035344386466193856034764
22:26:53 <Cale> > cos (pi - 0.49999) :: CReal
22:26:54 <lambdabot>   0.8775873561018795501478749054438420682969
22:27:00 <Cale> > cos (pi - 5.0) :: CReal
22:27:01 <lambdabot>   0.2836621854632262644666391715135573083344
22:27:02 <roconnor> sjanssen: yes
22:27:05 <Cale> > cos (pi - 0.5) :: CReal
22:27:06 <lambdabot>   0.8775825618903727161162815826038296519916
22:27:17 <Cale> > cos (pi - 0.499) :: CReal
22:27:18 <lambdabot>   0.8780615485578282874302356064792622209726
22:27:24 <cygnus_> cos ( - 2 * pi / 3 ) :: CReal
22:27:27 <cygnus_> > cos ( - 2 * pi / 3 ) :: CReal
22:27:28 <lambdabot>   -0.5
22:27:31 <Cale> er, hmm
22:27:32 <cygnus_> yay its fixed again :p
22:27:36 <roconnor> the discotinuity happens at one of the quarter turns
22:27:57 <cygnus_> > cos ( 2 * pi + 2 * pi / 3 ) :: CReal
22:27:57 <roconnor> er
22:27:58 <lambdabot>   0.5
22:28:03 <pumpkin> so much for his proof ;)
22:28:03 <roconnor> eigth turns
22:28:10 <cygnus_> > cos ( 4 * pi + 2 * pi / 3 ) :: CReal
22:28:11 <lambdabot>   0.5
22:28:20 <cygnus_> > cos ( -2 * pi + 2 * pi / 3 ) :: CReal
22:28:21 <lambdabot>   0.5
22:28:27 <august> > pi
22:28:28 <lambdabot>   3.141592653589793
22:28:34 <august> there's your problem
22:28:48 <cygnus_> ??
22:28:56 <Cale> > pi :: CReal
22:28:57 <lambdabot>   3.1415926535897932384626433832795028841972
22:28:59 <august> > :t pi
22:29:00 <lambdabot>   <no location info>: parse error on input `:'
22:29:02 <Cale> :t pi
22:29:03 <lambdabot> forall a. (Floating a) => a
22:29:09 <roconnor> pumpkin: the author fixed the bug
22:29:09 <pumpkin> pi is whatever you ask it to be
22:29:13 <pumpkin> roconnor: ah :P
22:29:15 <roconnor> but not the maintainer
22:29:15 <cygnus_> :t pi :: Creal
22:29:16 <lambdabot> Not in scope: type constructor or class `Creal'
22:29:17 <cygnus_> :t pi :: CReal
22:29:18 <lambdabot> CReal
22:29:19 <Cale> showCReal 100 pi
22:29:21 <Cale> > showCReal 100 pi
22:29:22 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
22:29:59 <cygnus_> > cos ( 2 * (pi :: CReal ) / 3 ) :: CReal
22:30:00 <lambdabot>   0.5
22:30:21 <Cale> roconnor: If you want to upload a new version of numbers, I'll make sure lambdabot gets it...
22:30:40 <roconnor> I told the author to tell the mainatiner, but you know how it is.  They haven't spoken with each other in like 10 or 20 years.
22:30:57 <Cale> Well, anyone with a Hackage account can just upload a new version.
22:30:59 <roconnor> oh right, it is part of the Number package.
22:31:03 <roconnor> yikes
22:31:10 <sjanssen> Cale: that is hardly a good solution
22:31:14 <roconnor> if I don't tell the maintainer, he might overwrite it again.
22:31:19 <Cale> Well, yes.
22:31:26 <sjanssen> the next version augustss uploads would be broken
22:31:31 <roconnor> in that case I can just fix it again
22:31:40 <roconnor> problem solved
22:31:43 <cygnus_> i don't understand the bug
22:31:44 <august> me?
22:31:52 <sjanssen> roconnor: not really
22:31:53 <roconnor> nope
22:31:55 <cygnus_> why is it showing the wrong answer
22:32:34 <Cale> cygnus_: Because the implementation of cos for CReal is broken.
22:32:42 <roconnor> sjanssen: problem solved! :P
22:33:29 <dons> so who's has commit access?
22:33:39 <dons> s/got/
22:33:46 <sjanssen> roconnor: you can say that as many times as you'd like, it doesn't make it any more true :)
22:33:54 <sjanssen> dons: I'm not sure if numbers has a public darcs repo
22:34:13 <dons> is it lennart's?
22:34:17 <sjanssen> yes
22:34:29 <dons> ok. he accepts patches!
22:34:43 <dons> roconnor: did you want to send a diff?
22:37:51 <cygnus_> so what happened to proving the CReal was correct statement
22:38:52 <roconnor> dons: diffs are so slow.
22:39:07 <roconnor> cygnus_: the bugs were found.
22:39:14 <mcnig> Is it possible to pattern match a null parameter?  i.e.
22:39:21 <mcnig> sorry, i.e. check if there was NO parameter
22:39:29 <cygnus_> so why didn't he fix them
22:40:18 <jsn> mcnig: i think the answer is no
22:40:53 <jsn> mcnig: what would that even mean?
22:41:05 <roconnor> I can just upload the fix, and then tell augustss to make a diff himself :P
22:41:06 <jsn> mcnig: you mean like, varargs?
22:41:27 <mcnig> jsn: hmm, I suppose.  I wish to have a function where I can invoke it without parameters, but its internal workings require them
22:42:08 <jsn> mcnig: this is actually a subtle problem
22:42:13 <roconnor> Cale: I fixed the bug, and updated the version number.  Is 2008.4.20.1 a valid version number?
22:42:15 <jsn> mcnig: what is the type of your function?
22:42:24 <mcnig> jsn: Int -> Int
22:42:34 <mcnig> (Assuming it takes the parameter)
22:42:39 <jsn> well, sometimes it doesn't take a parameter
22:42:46 <jsn> so sometimes it is, sometimes it isn't
22:42:57 <Cale> roconnor: I think so.
22:43:07 <jsn> there is a way to do this with type classes
22:43:38 <jsn> mcnig: another way is to make all the parameters 'Maybe a'
22:43:50 <jsn> Maybe Int -> Int
22:44:02 <jsn> to choose the default, use Nothing
22:44:30 <jsn> there is no way to pattern match on having only so many arguments
22:44:38 <roconnor> Cale: bug fix and version number.  That should bit it right?
22:44:44 <jsn> which is rather different, i guess from Prolog and Erlang
22:44:44 <Cale> mcnig: Another way is just to write a simplified wrapper around the more complicated function which supplies defaults
22:44:53 <Cale> roconnor: I think so
22:45:40 <roconnor> Source tarball created: dist/numbers-2008.4.20.1.tar.gz
22:46:20 <roconnor> Cale: if I upload, you can update lambdabot right away?
22:46:23 <august> i heard that haskell functions only have 1 argument
22:46:24 <Cale> yep
22:46:32 <Cale> august: yes
22:46:48 <Cale> august: always exactly one -- those which appear to take more just produce other functions
22:47:09 <Cale> (or take a tuple as their parameter)
22:47:38 <dons> roconnor: ? diff -u old new > foo ; mailx -s patch augustuss < foo
22:47:39 <Cale> roconnor: I'm ssh'ed into the machine where lambdabot is running :)
22:47:52 <roconnor> I don't have mail on my laptop
22:48:49 <dons> roconnor: ? diff -u old new > foo ; scp foo i-have-lots-of-reasons-to-keep-slacking.org
22:49:38 <august> i'm curious how you go from n arguments to n - 1 arguments
22:50:10 <pumpkin> each function returns either another function or a value
22:51:13 <roconnor> Cale: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers-2008.4.20.1
22:51:16 <august> blah a b = â€¦ goes to ?
22:52:04 <Cale> > cos (2 * pi / 3) :: CReal
22:52:05 <lambdabot>   -0.5
22:52:10 <Cale> yay!
22:52:34 <roconnor> that was totally worth it
22:52:53 <pumpkin> august: something like a -> b -> c means a -> (b -> c)
22:52:57 <HelgeS> @src Ord
22:52:58 <lambdabot> class  (Eq a) => Ord a  where
22:52:58 <lambdabot>     compare      :: a -> a -> Ordering
22:52:58 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
22:52:58 <lambdabot>     max, min         :: a -> a -> a
22:53:08 <pumpkin> which means a function that takes an a, and returns a function that takes a b and returns a c
22:53:12 <roconnor> augustss has not contact information in his package .... so no email?
22:53:21 <dolio> > properFraction (1.5 :: CReal)
22:53:23 <lambdabot>   (2,-0.5)
22:53:37 <dons> roconnor: do you want to know how to contact lennart?
22:53:52 <roconnor> I can probably figure it out
22:53:56 <dolio> > properFraction (1.6 :: CReal)
22:53:57 <august> pumpkin: oic
22:53:58 <lambdabot>   (2,-0.4)
22:54:56 <HelgeS> pl \x y -> x y
22:55:14 <ddarius> id
22:55:25 <dolio> Might want to send a fix for that as well. It looks like it uses round instead of floor or something.
22:55:38 <dolio> Or truncate. Whichever is the right one.
22:56:20 <pumpkin> > fix CR
22:56:21 <lambdabot>   Not in scope: data constructor `CR'
22:56:31 <pumpkin> > fix cos :: CReal ;)
22:56:33 <lambdabot>   <no location info>: parse error on input `)'
22:56:44 <dolio> cos _|_ = _|_
22:57:04 <HelgeS> pl \x y -> x +1
22:57:15 <dolio> @pl \x y -> x + 1
22:57:15 <lambdabot> const . (1 +)
22:57:17 <cygnus_> roconnor: how di yo ufix it
22:57:32 <roconnor> cygnus_: I downloaded the package from hackage
22:57:38 <roconnor> then I edited the source code
22:57:42 <cygnus_> ye what was the bug
22:57:45 <roconnor> then I upped the version number
22:57:51 <roconnor> then I uploaded it to hackage
22:58:05 <roconnor> cygnus_: the definition of cos had a few sign errors
22:58:24 <cygnus_> i assume it just does it as a taylor series?
22:58:29 <dolio> > properFraction (-1.5 :: Double)
22:58:30 <lambdabot>   (-1,-0.5)
22:58:38 <dolio> > truncate (-1.5 :: Double)
22:58:40 <lambdabot>   -1
22:58:41 <cygnus_> can i see the diff
22:59:19 <roconnor> cygnus_: you can by downloading the old and new versions and running diff
22:59:54 <HelgeS> pl \x y -> x y
22:59:59 <cygnus_> where do i dl it from
23:00:09 <dolio> Dude, you need to put an @ before the pl.
23:00:11 <roconnor> cygnus_: the error was not in the taylor series
23:00:17 <roconnor> the error was in the range reduction
23:00:23 <HelgeS> @pl \x y -> x y
23:00:24 <lambdabot> id
23:00:25 <dolio> :)
23:00:42 <HelgeS> @pl \x y -> x + 1
23:00:43 <lambdabot> const . (1 +)
23:01:25 <roconnor> cygnus_: cos and sin evaluate x `div` pi/4 and then call the taylor versions of sin and cos
23:01:41 <roconnor> based on x `div` pi/4 `mod` 8
23:01:46 <roconnor> or something like that
23:02:00 <HelgeS> @pl \f a b = b a
23:02:01 <lambdabot> (line 1, column 8):
23:02:01 <lambdabot> unexpected "="
23:02:01 <lambdabot> expecting pattern or "->"
23:02:21 <HelgeS> @pl f a b = b a
23:02:21 <lambdabot> f = flip id
23:02:33 <HelgeS> @pl  a b c = b a
23:02:33 <lambdabot> a = fix ((const .) . flip id)
23:03:03 <HelgeS> @pl  f a = f a
23:03:03 <lambdabot> f = fix id
23:03:10 <HelgeS> @pl  f a = a f
23:03:10 <lambdabot> f = fix (flip id)
23:03:32 <engstad> @pl f (x,y) = (y,x)
23:03:32 <lambdabot> f = uncurry (flip (,))
23:03:41 <engstad> @pl f (x,y) = (y, f x y)
23:03:41 <lambdabot> f = fix ((`ap` snd) . (. fst) . (ap (,) .))
23:03:47 <engstad> jeez.
23:03:56 <mcnig> lookup 'c' [('a',0),('b',1),('c',2)]      --->   "Just 2"    -- how can I just extract the 2 from this?
23:04:45 <HelgeS> @unpl  ((((((.) .) .) . (.)) .) .) . (.)
23:04:46 <lambdabot> (\ p v y ab ae b c -> p (v y) (ab ae) (b c))
23:05:33 <dolio> @unpl ap
23:05:33 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
23:06:06 <engstad> maybe maybe (-1) (\ a -> a) $ Just 2
23:07:09 <roconnor> dolio: technically properFraction can't really be implemented.  Although I suppose it could be less wrong.
23:07:39 <cygnus_> what the hell is this @pl stuff
23:07:46 <dolio> roconnor: Yeah. As long as it is implemented.
23:08:15 <engstad> It's a point style converter bot, I suppose.
23:08:21 <dolio> > truncate (1.5 :: CReal)
23:08:22 <lambdabot>   2
23:08:31 <dolio> Oh, well, that's weird.
23:08:37 <cygnus_> @unpl (.)
23:08:38 <lambdabot> (\ a b c -> a (b c))
23:08:43 <cygnus_> @unpl ()
23:08:43 <lambdabot> ()
23:08:55 <cygnus_> @unpl (.)(.)
23:08:55 <lambdabot> (\ b c e f -> b c (e f))
23:09:00 <engstad> It's a little more reasonable if you mentally translate . to "left-pipe" <|
23:09:46 <engstad> (Or even reverse it, so that you get right pipes |>
23:10:15 <engstad> f <| g = \x -> f (g x)
23:10:40 <engstad> g |> f = \x -> g (f x)
23:11:41 <engstad> > maybe (-1) id $ lookup 'c' [('a',0),('b',1),('c',2)]
23:11:42 <lambdabot>   2
23:13:19 <dolio> roconnor: I'm not sure how easy that will be to fix, looking at it now.
23:13:38 <engstad> case (lookup 'c' [('a',0),('b',1),('c',2)]) of Nothing -> (-1); Just a -> a
23:13:44 <engstad> > case (lookup 'c' [('a',0),('b',1),('c',2)]) of Nothing -> (-1); Just a -> a
23:13:45 <lambdabot>   2
23:14:28 <dolio> roconnor: I guess you could test if fromInteger n > x and fudge it.
23:14:59 <roconnor> dolio: just let n = x' 1 `div` 2
23:15:14 <roconnor> or n = x' 2 `div` 4
23:15:27 <dolio> Ah, okay.
23:15:32 <roconnor> or n = x' i `div` (2^i) for whatever your favourite i is
23:15:41 <dolio> Yeah. :)
23:16:02 <roconnor> you can never be right anyways :)
23:16:30 <engstad> dolio: What's the question?
23:16:45 <dolio> Yeah. But it's less noticeable to fail on something like 1.4999999999999999999999 than it is on 1.5. :)
23:17:09 <dolio> At least as far as randomly typing stuff in on lambdabot goes. :)
23:17:16 <roconnor> engstad: how do compute properFraction for a CReal
23:17:25 <roconnor> how to
23:17:38 <engstad> CReal?
23:17:44 <roconnor> > pi :: CReal
23:17:46 <lambdabot>   3.1415926535897932384626433832795028841972
23:18:01 <roconnor> dolio: actually I'm not certain about my defininition of n
23:18:07 <roconnor> you may need to add or substract a half
23:22:54 <jsn> Cale: is associativity enough to have ordering?
23:23:30 <Cale> jsn: hm?
23:23:39 <Cale> jsn: ordering in what sense?
23:24:30 <jsn> i mean, in the sense of sequential execution
23:25:23 <jsn> monads have just two operators, eta and mu
23:25:31 <jsn> or i mean, natural transformations
23:25:46 <jsn> and it seems that mu is what really takes care of the sequencing
23:25:48 <ddarius> jsn: Monads don't enforce sequential execution.
23:26:07 <cjs> Has anyone ever written a DDE server in Haskell?
23:26:18 <dolio> > (undefined >>= \_ -> ask) 5
23:26:20 <lambdabot>   5
23:26:26 <jsn> oh, heck
23:26:44 <engstad> > ask
23:26:45 <lambdabot>       No instance for (Show (m r))
23:26:45 <lambdabot>        arising from a use of `show' at <in...
23:26:54 <jsn> okay, so they can model it, but they don't enforce it?
23:26:58 <Cale> in this case, ask = id
23:27:29 <dolio> It's the data dependencies (if any) in the definition of the monad that enforce execution order.
23:27:29 <Cale> Well, the idea of a monad doesn't really tell you what execution is...
23:27:36 <quicksilver> jsn: they sequence something, abstractly called 'effects'
23:27:43 <quicksilver> which varies from monad to monad.
23:27:55 <jsn> hmm
23:28:03 <quicksilver> and I don't think it's really to do with the monad laws, at all.
23:28:09 <quicksilver> It's just to do with >> not being commutative
23:28:17 <quicksilver> a >> b is different from b >> a, in general
23:28:18 <engstad> They don't have to sequence anything... List and Maybe are perfectly fine monads.
23:28:22 <wli> As soon as VS2005 Beta 2 finishes installing I'm about to try to write Haskell on Windows. Any Windows coders around?
23:28:24 <ddarius> quicksilver: They let you -express- a sequential ordering, but nothing actually forces it.
23:28:25 <quicksilver> (there's no law that says it must be different though)
23:28:35 <jsn> wli: Philippa
23:28:42 <dolio> > runState (undefined >> put () >> get) ()
23:28:44 <lambdabot>   ((),())
23:28:50 <quicksilver> ddarius: they sequence effects by definition.
23:28:55 <Cale> engstad: The list monad sequences nondeterministic choices.
23:28:56 <quicksilver> ddarius: that is the definition of effect
23:29:03 <quicksilver> (that thing which is sequenced by a monad)
23:29:07 <wli> jsn: I know Philippa. Cool.
23:29:11 <quicksilver> I appreciate that this is recursive.
23:29:19 <jsn> hehe
23:29:27 <quicksilver> it is certainly not haskell evaluation, that they sequence.
23:29:31 <wli> I'll hit people up for handholding after the install finishes, which is taking a while.
23:29:33 <ddarius> quicksilver: That's an odd definition of 'effect' and is also clearly wrong.
23:29:44 <jsn> haha
23:29:51 <quicksilver> ddarius: it's not that odd. It's the definition of effect in Moggi's paper
23:29:53 <jsn> the monadology begins
23:29:56 <Cale> Monads on other categories start to get hard to interpret in this computational way...
23:30:02 <engstad> Cale: You could perhaps think of it in that way, but really : Is [ 1, 2 , 3] a "sequence"?
23:30:05 <quicksilver> ddarius: which introduced monads as a computational tool.
23:30:10 <jsn> Cale: categories other than Hask?
23:30:21 <Cale> engstad: It's a single choice between 1, 2, and 3
23:30:27 <jsn> engstad: well, the sequencing would be of operations
23:30:34 <quicksilver> it strikes me as a natural definition of effect and gives rise to a slightly abstruse definition of sequence.
23:30:34 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
23:30:35 <jsn> engstad: not of the elemnts
23:30:35 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
23:30:44 <Cale> jsn: Yes
23:31:03 <Cale> jsn: For example, on metric spaces, the completion functor is a monad.
23:31:25 <engstad> Cale: I'm aware of that... but you could also just say that is just a way of building a data structure (no "sequencing").
23:31:40 <quicksilver> if you interpret the list monad to be multisets, then it's commutative. no sequencing per se.
23:31:53 <Cale> engstad: Yes, of course. You could also just completely ignore the fact that lists form a monad.
23:32:15 <quicksilver> but the senses of 'sequence' in the state monad and the ST monad are much clearer, say.
23:32:18 <ddarius> quicksilver: I don't think he uses the term "effect" or "sequencing" in Notions of Computation and Monads.  Adobe Acrobat seems to agree with me.
23:32:47 <quicksilver> ddarius: I'm pretty sure he uses 'computational effect'
23:33:46 <engstad> > do x <- Just 1; y <- Nothing; return (x, y)
23:33:47 <lambdabot>   Nothing
23:33:54 <engstad> > do x <- Just 1; y <- Just 3; return (x, y)
23:33:56 <lambdabot>   Just (1,3)
23:34:18 <quicksilver> ddarius: no, you're right.
23:34:22 <wli> I may have already forgotten how I came to understand monads. ISTR it had something to do with join vs. some other combinator and substitution monads over program expressions.
23:34:24 <ddarius> quicksilver: He uses "computations", "notion of computation" and he uses "side-effect" specifically for the state monad.
23:34:26 <quicksilver> ddarius: he uses 'computation'a nd 'notion of compution'
23:34:40 <quicksilver> ddarius: other writers following him have used the phrase 'computational effect'
23:34:46 <quicksilver> for what he called 'notation of computation'
23:35:09 <quicksilver> I suspect that's because his terminology can be confused with computability which is something different.
23:35:16 <wli> join vs. (>>=)/bind I'm pretty sure now.
23:35:47 <wli> x >>= f = join $ fmap f x
23:36:13 <quicksilver> ddarius: the (recursive) usage which is now common is that an 'effect' is the thing which is sequenced by "sequence :: [m a] -> m [a]".
23:36:30 <quicksilver> ddarius: ...and sequence sequences effects, by definition ;)
23:37:18 <engstad> The real issue here is that monads are extremely simple, which means that the concept can be applied to many different things.
23:37:52 <wli> Encoding a dependency dag (perhaps implicitly) and spawning everything as some mixture of lightweight and kernel threads (e.g. M:N thread runtime) might make sense.
23:37:57 <engstad> It's even simpler than the concept of "addition".
23:38:47 <ddarius> Addition is a monad.
23:38:59 <engstad> MonadPlus.
23:39:10 <ddarius> I meant what I said.
23:39:11 <wli> On that note, are M:N threads available for Visual Haskell on Windows?
23:39:29 <jsn> ddarius: how is addition a monad?
23:39:51 <intrados> does anyone know why "runhaskell Setup configure" gives me the following error: http://rafb.net/p/dH1aJg97.html for the jack package?
23:39:54 <engstad> By addition, we usually associate the law a + b == b + a.
23:40:20 <wli> (I know that there is kernel support for M:N threads in Windows.)
23:42:16 <jsn> engstad: yes
23:43:14 <sjanssen> wli: I don't know about Visual Haskell, but GHC does support it
23:44:01 <wli> sjanssen: I suspect that means yes for Visual Haskell, in which case wonderful things are true about threadbombing.
23:44:16 <sjanssen> wli: threadbombing?
23:44:42 <wli> sjanssen: Spawning numerous threads.
23:45:15 <jsn> so, some monads in haskell can be "run"
23:45:16 <ddarius> jsn: Any monoid induces a monad.
23:45:23 <jsn> ddarius: ah
23:45:33 <jsn> ddarius: okay, i can look that up
23:45:59 <ddarius> To be specific, mu is addition.
23:46:00 <sjanssen> wli: only forkOS will do that
23:46:04 <sjanssen> forkIO should be safe
23:46:10 <jsn> ddarius: interesting
23:46:24 <Cale> ddarius: ah, okay, in that sense.
23:46:29 <redditbot> A HAML parser for Haskell | Alson Kemp
23:46:29 <redditbot> A 2008 Retrospective for the Haskell community? Suggestions please!
23:46:48 <ddarius> Cale: I could probably do it the other way too, though that would likely be less natural.
23:46:59 <jsn> ddarius:  the other way?
23:47:07 <Cale> ddarius: I thought it was some trick similar to how subtraction is a functor (R, <=) -> (R, +)
23:47:17 <Cale> (though obviously you must use the same category)
23:47:46 <wli> sjanssen: The idea of M:N threads is that some "ambiguous" primitive wrt. kernel threads vs. lightweight thread is used, and the runtime (e.g. via an additional cmdline arg, env. var., etc.) picks how many kernel threads to use and the lightweight threads are processed by the various kernel threads and distributed across them.
23:47:59 <quicksilver> wli: I thought visual haskell was bitrotted. Hopefully I'm wrong.
23:48:11 <wli> quicksilver: Oh crap.
23:48:18 <quicksilver> wli: you are describing the GHC thread model, yes.
23:48:25 <quicksilver> (GHC has such a system)
23:48:39 <sjanssen> wli: the number of OS threads is static (excluding forkOSed threads)
23:49:09 <sjanssen> wli: but I don't see what sort of "bombing" this will cause?
23:49:14 <quicksilver> sjanssen: my understanding is that forkOS doesn't increase the number of OS threads, it merely creates a haskell thread which is bound to a single capability.
23:50:10 <quicksilver> ddarius: it looks like mcbride and patterson make consistent use of the word 'effect' in the sense I referred to in the applicative paper.
23:50:12 <sjanssen> quicksilver: doesn't it also create a new capability?
23:50:18 <jsn> so i am looking at this diagram on wikipedia, diagramming a "T-algebra" (where they are calling their monads T)
23:50:19 <quicksilver> sjanssen: I don't think so, no.
23:50:22 <wli> sjanssen: It's not that it causes it, it's that it handles the load/stress/etc. induced by creating numerous threads properly.
23:50:28 <quicksilver> (it should really be called forkBoundIO)
23:50:50 <quicksilver> ddarius: I don't think they were being novel, though, I think it was common terminology before them.
23:50:51 <jsn> and a T algebra has a "structure map" h : Tx -> x
23:50:52 <ddarius> quicksilver: That's fine.  The significant thing wasn't whether Moggi defined "effect", but whether he said anything about "sequencing" them.
23:51:11 <wli> sjanssen: Something of the opposite.
23:51:13 <jsn> do T algebras describe runnable monads?
23:51:17 <sjanssen> quicksilver: wouldn't this cause a problem when multiple bound threads need to make a blocking foreign call?
23:51:52 <jsn> for example, Parsec, [], State (everything but IO) ?
23:51:52 <ddarius> jsn: If I were you, I'd drop the notion of "runnable monad"
23:52:03 <ddarius> Very few monads have a total function M a -> a
23:52:23 <jsn> ddarius: okay
23:52:34 <jsn> ddarius: but there are some in Haskell that do
23:52:39 <jsn> for example, Parsec
23:52:45 <ddarius> jsn: No it doesn't.
23:52:49 <quicksilver> sjanssen: multiple bound threads are allowed to be bound to the same capability, as far as I understand it. That means they can't run simultaneous, but there is no problem with them blocking simultaneously ;)
23:53:06 <jsn> ddarius: no?
23:53:13 <quicksilver> jsn: the 'runnable' monads invariably have a slight variation on that type
23:53:18 <ddarius> jsn: Define a total function, Parsec a -> a.
23:53:28 <quicksilver> jsn: it takes extra parameters, or returns a bit of extra results, or both
23:53:30 <jsn> runParser ?
23:53:34 <ddarius> :t runParser
23:53:35 <lambdabot> Not in scope: `runParser'
23:53:38 <ddarius> @hoogle runParser
23:53:38 <lambdabot> Language.Haskell.ParseMonad runParser :: P a -> String -> ParseResult a
23:53:38 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
23:53:38 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
23:53:39 <jsn> oh, i see what you are saying
23:53:50 <jsn> because it is Either ... ...
23:53:56 <quicksilver> general form is more like f(M a) -> g a
23:54:07 <quicksilver> where f,g are arbitrary type functions (not necessarily functors)
23:54:35 <jsn> hmm, okay
23:55:26 <quicksilver> in practice they are quite often functors
23:55:27 <dolio> @hoogle runCC
23:55:27 <lambdabot> No results found
23:55:34 <quicksilver> but I don't think they need to be
23:55:41 <ddarius> As for T-Algebras, they have not yet had much significance for programming.
23:55:53 <jsn> hmm
23:55:55 <jsn> okay
23:56:07 <ddarius> Though, categorists tend to prefer the Eilenberg-Moore category of T-Algebras to the Kleisli category.
23:57:47 <jsn> so actually, it is trying to decipher the term Kliesli arrow that has led me to this matter in the first place :)
23:59:06 <jsn> though i have gotten distracted
23:59:53 <jsn> in kliesli categories, there is a composition that makes me think of >>=
