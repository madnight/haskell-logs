00:02:06 <solrize> > rollDice >>= print
00:02:09 <lambdabot>   * Exception: "<IO ()>"
00:02:16 <solrize> :t rollDice
00:02:18 <lambdabot> forall t. (Num t, Random t) => IO t
00:03:00 <solrize> what's the exception?
00:03:21 <olsner> solrize: IO being disallowed in lambdabot, most likely
00:04:42 <mornfall> IO is dangerous.
00:05:18 <solrize> > return 3 >>= print
00:05:19 <lambdabot>   * Exception: "<IO ()>"
00:05:24 <solrize> ic
00:05:35 <solrize> how does it know?
00:06:01 <olsner> lambdabot has her ways to know, obviously
00:06:15 <Gracenotes> her .-.
00:06:53 <olsner> Gracenotes: yes, she's a she, didn't you know? :)
00:07:48 <quicksilver> solrize: by type inference.
00:07:53 <Gracenotes> > a/s/l
00:07:54 <lambdabot>   a / s / l
00:07:56 <vegai> hmm, this is nasty
00:08:05 <olsner> @vixen a/s/l
00:08:05 <lambdabot> 19/f/California
00:08:06 <vegai> I have a program with three threads and all of them might have sockets open
00:08:09 <quicksilver> @vixen asl
00:08:09 <lambdabot> 19/f/California
00:08:17 <vegai> when I order that command to quit, it kills all the threads and leaves
00:08:30 <vegai> however, in some cases, this causes the process to just hang, taking 100% CPU
00:08:38 <Gracenotes> > s
00:08:39 <lambdabot>   s
00:09:03 <vegai> it dies with a SIGTERM properly, though.
00:09:15 <quicksilver> vegai: what does "order that command to quit" mean?
00:09:33 <vegai> I have a small command line interface with the program running in the main thread
00:09:50 <vegai> quit exits the input loop
00:10:38 <vegai> can I strace a binary made by ghc...
00:10:45 <litb_> > foldr' (+) 0 [1, 2, 3, 4]
00:10:46 <lambdabot>   Not in scope: `foldr''
00:10:47 <vegai> I can
00:10:48 <quicksilver> no reason why not.
00:10:56 <quicksilver> you may not find it terribly informative.
00:11:00 <litb_> how was the taoil recursive foldr called?
00:11:03 <vegai> it stucks on sched_yield()
00:11:07 <vegai> sched_yield()                           = 0
00:11:14 <vegai> nothing else
00:11:19 <quicksilver> you might take some care to think about how your various threads will handle exceptions.
00:11:30 <quicksilver> and what you might do to make sure they handle them cleanly.
00:11:37 <vegai> aye.
00:11:40 <quicksilver> exceptions won't interrupt a blocking FFI.
00:12:01 <quicksilver> (letting the process end is equivalent to sending killthread to all threads)
00:12:31 <vegai> all my sockets are around 'finally' statements that cleanup the socket
00:12:39 <vegai> .... I think :P
00:12:49 <quicksilver> do you make any FFI calls?
00:12:54 <quicksilver> are you using the threaded RTS?
00:13:11 <olsner> can you fork without the threaded rts?
00:13:17 <quicksilver> olsner: yes.
00:13:25 <vegai> I am using threaded RTS, I don't make FFI calls myself. Perhaps something I use does
00:13:31 <quicksilver> without the threaded RTS its pure software threading.
00:13:32 <vegai> like HTTP
00:15:17 <vegai> Network.Socket perhaps makes FFI calls?
00:17:02 <vegai> perhaps I could signal the threads in a nicer way about quitting before killing them
00:27:20 <vegai> naah, this will be too awkward
00:27:56 <vegai> perhaps later
00:32:16 <purple_> spj in Tackling the Awkward Squad:
00:32:16 <purple_> monadic input/output, concurrency, exceptions, ...  describes a web server written in 1500 lines
00:32:24 <purple_> Does anyone know if the source is available ?
00:32:30 <Gracenotes> @src mapM
00:32:31 <lambdabot> mapM f as = sequence (map f as)
00:33:04 <Gracenotes> @src sequence
00:33:05 <lambdabot> sequence []     = return []
00:33:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:33:05 <lambdabot> --OR
00:33:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
00:33:46 <Gracenotes> @src liftM2
00:33:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:40:42 <hydo> I don't see this explicitly stated anywhere:  return gives a value wrapped in a monad of the same type as the enclosing function, correct?  I'm resisting the idea that it's always IO
00:41:09 <quicksilver> hydo: certainly not always IO.
00:41:14 <quicksilver> hydo: it's whatever type you ask for.
00:41:20 <quicksilver> > return 5 :: [Int]
00:41:21 <lambdabot>   [5]
00:41:27 <quicksilver> > return 5 :: Maybe Int
00:41:29 <lambdabot>   Just 5
00:41:37 <quicksilver> hydo: by the magic of type inference :)
00:41:49 <hydo> ah, yea, sorry, I should have tried it in ghci first.
00:42:09 <quicksilver> ghci does default to IO, in the absence of other type information
00:42:37 <quicksilver> (because one of the features of ghci is letting you try IO actions aout)
00:43:41 <mpeter> > return 5 :: [Float]
00:43:43 <lambdabot>   [5.0]
00:43:48 <quicksilver> "return 5" is actually a polymorphic value, which you can use with any monad you want. In a real program, the monad is generally fixed by context.
00:43:49 <Baughn> hydo: Of course, the trick about monads is that.. there is no trick about monads. They're a syntax, and a shared API; that's about it. As is usual, a little shared structure goes a long way in having common functions, as you can see in Control.Monad
00:43:50 <mpeter> > return 5/0 :: [Float]
00:43:51 <lambdabot>       No instance for (Fractional [Float])
00:43:51 <lambdabot>        arising from a use of `/' a...
00:43:55 <mpeter> damn
00:44:15 <quicksilver> > return (5/0) :: [Float]
00:44:16 <lambdabot>   [Infinity]
00:45:16 <mpeter> > return (5/0) :: [Int]
00:45:18 <lambdabot>       No instance for (Fractional Int)
00:45:18 <lambdabot>        arising from a use of `/' at <i...
00:45:20 <hydo> If you guys are serious about the whole "avoid success at any cost" thing, you'll need to be a hell of a lot less helpful :)
00:45:22 <hydo> hehe
00:45:23 <mpeter> > return (5/0) :: [Maybe Int]
00:45:24 <lambdabot>       No instance for (Fractional (Maybe Int))
00:45:25 <lambdabot>        arising from a use of `...
00:45:34 <Baughn> hydo: Nah, that's lisp
00:45:39 <mpeter> you're not fractional
00:45:55 <solrize> heh, the solution to euler 25 in the wiki is wrong
00:46:11 <quicksilver> > liftM show (return (5/0)) `mplus` ["And"] `mplus` ["Beyond!!!"]
00:46:12 <lambdabot>   ["Infinity","And","Beyond!!!"]
00:48:46 <BeelsebobWork> anyone know of a way to block until another specific thread blocks?
00:51:13 <quicksilver> BeelsebobWork: the GHC runtime doesn't have any wakeup guarantees.
00:51:36 <BeelsebobWork> yeh, I don't want a guarentee -- only a "wake on that blocking"
00:51:43 <quicksilver> BeelsebobWork: best you can do is get that thread to post to an mvar before it blocks
00:51:47 <quicksilver> or a chan.
00:51:52 <BeelsebobWork> yeh -- that's not possible
00:51:59 <BeelsebobWork> I don't think
00:51:59 <quicksilver> then, no.
00:52:02 <BeelsebobWork> :(
00:52:11 <quicksilver> blocking is not, in and of itself, observable.
00:52:12 <BeelsebobWork> I'm still trying to find a nice solution to merge
00:52:21 <BeelsebobWork> well, other than by the scheduler
00:52:27 <quicksilver> indeed :)
00:52:32 <quicksilver> that doesn't count.
00:52:37 <BeelsebobWork> hehe
00:52:41 <quicksilver> God(SPJ) can observe everything.
00:52:50 <quicksilver> what matters is what we as programmers can observe.
00:53:14 <BeelsebobWork> I realised that to get the "very lazy" pattern matching that *I* want (but not the general case), I don't need to solve the halting problem -- but only find out when a thread blocks on its value
00:53:27 <quicksilver> BeelsebobWork: finally posted my code to the reactive list, btw.
00:53:31 <BeelsebobWork> oh?
00:53:40 <BeelsebobWork> just this second?  I didn't see it this morning
00:53:47 <quicksilver> about 8 seconds ago
00:54:27 <BeelsebobWork> ohhh, from your email this sounds fun
00:55:10 <Gracenotes> > sequence [[1..3], [1..3]]
00:55:12 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
00:56:42 <BeelsebobWork> quicksilver: just a check -- are you expecting things to gain a white background when you mouse over them?
01:03:00 <cjs> Any FFI experts here? Given a C struct for which I'd like to implement Storable, how do I write the alignment function?
01:03:48 <jeff123> How do I get "let .. in" to work in a "do" block? I keep getting "parse error on input `='"
01:04:16 <cjs> "do" uses a special let: "do foo; let bar = 17; print bar
01:04:25 <jeff123> (I'm trying to read some integers from a string after doing readLn)
01:04:27 <cjs> Drop the "in", and just do the lets in whatever order.
01:05:25 <jeff123> ah ok, thanks!
01:06:27 <ibid> you can have more than one definition in do's let, too, just indent properly (this is necessary for recursive defs)
01:07:20 <jeff123> I thought you could do that, but I kept getting the error. I'll try again.
01:07:40 <mpeter> > unwords [n|n<-bigwords,'e' `elem` n] ++ "!!!!"
01:07:41 <lambdabot>   "able adjustment advertisement after agreement amusement angle answer apple...
01:07:43 <jeff123> ok it worked. The problem was I kept using "in" at the end
01:08:10 <mpeter> > reverse (reverse (unwords [n|n<-bigwords,'e' `elem` n] ++ "!!!!"))
01:08:12 <lambdabot>   "able adjustment advertisement after agreement amusement angle answer apple...
01:08:29 <mpeter> > reverse (take 25 (reverse (unwords [n|n<-bigwords,'e' `elem` n] ++ "!!!!")))
01:08:31 <lambdabot>   "tempt attention awake!!!!"
01:08:48 <mpeter> > reverse (take 25 (reverse (unwords [n|n<-bigwords,'w' `elem` n] ++ "!!!!")))
01:08:50 <lambdabot>   "answer awake!!!!"
01:08:51 <ibid> how does one tempt attention?
01:09:01 <mpeter> > reverse (take 90 (reverse (unwords [n|n<-bigwords,'s' `elem` n] ++ "!!!!")))
01:09:03 <lambdabot>   "across adjustment advertisement against almost amusement answer apparatus ...
01:09:25 <mpeter> is there a better way to do that
01:09:39 <mpeter> take last elements of a list by number
01:10:07 <ibid> drop and length?
01:10:17 <mpeter> > reverse (drop 50 (reverse (unwords [n|n<-bigwords,'s' `elem` n] ++ "!!!!")))
01:10:19 <lambdabot>   "across adjustment advertisemen"
01:10:22 <osfameron> index into tails ?
01:10:38 <mpeter> > drop 50 (unwords [n|n<-bigwords,'s' `elem` n] ++ "!!!!")
01:10:39 <BeelsebobWork> quicksilver: tis really neat -- I'm attempting a port to Conal's reactive to see what happens
01:10:40 <lambdabot>   "sement answer apparatus as!!!!"
01:11:05 <mpeter> > take 5 (drop 50 (unwords [n|n<-bigwords,'s' `elem` n] ++ "!!!!"))
01:11:07 <lambdabot>   "semen"
01:11:18 <mpeter> > take 5 (drop 50 (unwords [n|n<-bigwords,'s' `elem` n])) ++ "!!!!"
01:11:19 <lambdabot>   "semen!!!!"
01:11:33 <osfameron> eeek!
01:11:37 * mpeter ducks
01:11:48 <mpeter> it has a mind of its own!
01:11:51 * ibid disappears
01:11:58 <mpeter> run while you still can
01:12:10 <mpeter> you came in at a bad time
01:12:48 <mpeter> @fact death
01:12:49 <lambdabot> death: I'M GOING TO KILL EVERYBODY IN #HASKELL HAHAHAHAHAHA
01:14:11 * vegai sues Death for unlawful threat
01:16:41 <BeelsebobWork> quicksilver: do there happen to be any points where you really *need* reactives, not behaviors?
01:16:48 <BeelsebobWork> I'm not seeing any yet, but I'm wondering
01:18:41 <quicksilver> BeelsebobWork: I doubt it.
01:18:47 <quicksilver> BeelsebobWork: my ideas were evolving as I wrote.
01:19:00 <BeelsebobWork> cool, so if I s/Reactive/Behavior/, then in theory I shouldn't trip up
01:19:13 <quicksilver> BeelsebobWork: and you can remove a bunch of 'rToB' in the process ;)
01:19:22 <BeelsebobWork> idd
01:19:29 <BeelsebobWork> and s/accumR/accumB/ etc
01:19:37 <quicksilver> BeelsebobWork: yes, the white background is a really crude hover effect.
01:19:52 <quicksilver> BeelsebobWork: it's on my list to make it look nicer, but I decided to just release the bloody thing :)
01:19:52 <BeelsebobWork> okay cool -- just checking it wasn't something like a texture load failing or something
01:20:22 <BeelsebobWork> it's very cool... you planning on expanding it into a full elite-like sim, or just leaving it as a reactive example?
01:20:42 <quicksilver> BeelsebobWork: it's supposed to be more like railroad tycoon than elite.
01:20:53 <BeelsebobWork> ah, okay
01:20:58 <quicksilver> BeelsebobWork: the idea was to plot shipping routes rather than control an individual ship.
01:21:04 <BeelsebobWork> ah, okay
01:21:07 <quicksilver> I have no idea if that makes a fun game.
01:21:09 <quicksilver> ;)
01:21:09 <BeelsebobWork> that's a neat idea
01:21:18 <BeelsebobWork> it sounds like it's something I would enjoy
01:21:30 <quicksilver> one of the things that interests me from time to time is "what makes things fun"
01:21:39 <quicksilver> for example, the premise of railroad tycoon sounds really dull, to me.
01:21:41 <hugo___> hello
01:21:44 <quicksilver> and yet, I enjoyed playing it ;)
01:21:46 <quicksilver> (version II, that is)
01:21:47 <BeelsebobWork> indeed
01:22:14 <quicksilver> jeff123: just for completeness, you can use 'let ... in ...' inside do blocks as well. let...in... is just an expression former, you can use any expression former in a do block.
01:22:27 <quicksilver> jeff123: the shortcut let is just to save indentation creep.
01:22:43 <Darkhost> http://imperiumreklamy.com/pages/ptp.php?refid=krzysztof9222 super;]
01:22:47 --- mode: ChanServ set +o quicksilver
01:22:53 --- mode: quicksilver set +b *!*=Krzysiek@*.multimo.gtsenergis.pl
01:22:53 --- kick: Darkhost was kicked by quicksilver (diediedie)
01:23:00 --- mode: quicksilver set -o quicksilver
01:23:10 * quicksilver thinks his kick messages getting less original.
01:23:18 <BeelsebobWork> quicksilver: I'm fairly certain that anything that involves taking over some "universe" with your evil empire counts as fun to a lot of people
01:23:22 <quicksilver> ;)
01:23:42 <BeelsebobWork> also, I take it I shouldn't click on that link at work
01:23:42 <quicksilver> BeelsebobWork: the reason I thought it was a good test is the mixture of passive/active effects, mouseovers, clicks, and so on.
01:23:47 <BeelsebobWork> yep
01:23:51 <ivanm> quicksilver: you need a random kick-message generator
01:23:55 <BeelsebobWork> that's why I'm interested in a conal-reactive port
01:23:57 <quicksilver> BeelsebobWork: you can if you like, you're just giving him 'gold' or 'credits' in som eonline game.
01:24:00 <ivanm> BeelsebobWork: what, you just tested it, did you?
01:24:09 <BeelsebobWork> quicksilver: heh
01:24:17 <BeelsebobWork> ivanm: stars -- yes
01:24:18 <quicksilver> that's what most of these links are about.
01:24:42 <BeelsebobWork> also yeh -- you need something to generate random warcraft like click messages
01:24:54 <quicksilver> BeelsebobWork: the thing which was hardest to get working is the 'clicking on ship makes the camera follow ship'
01:24:57 <ivanm> quicksilver: maybe you should get a lambdabot plugin to do the kicking with a new message each time ;-)
01:25:13 <quicksilver> actually the hard bit is really 'clicking away from the ship leaves the camera where it was'
01:25:15 <BeelsebobWork> quicksilver: oh? I would have expected that to be reasonably easy... what's the difficulty?
01:25:21 <quicksilver> clicking away from ship resetting to -100,-100 is easy.
01:25:36 <Peaker> Hey, I just realized seq/friends could have been implemented via a type-class (like Typeable for dynamic stuff), any idea why not?
01:25:37 <quicksilver> feeding the final value from a dynamic behaviour into the initial value of the next static behaviour
01:25:48 <quicksilver> it's a kind of feedback.
01:25:56 <quicksilver> Peaker: many people thing it should be.
01:26:04 <quicksilver> Peaker: I think maybe it was, in some version of haskell.
01:26:08 <Peaker> quicksilver: where's your game, btw?
01:26:11 <quicksilver> it was certainly very seriously proposed.
01:26:17 <quicksilver> Peaker: on the reactive list. Tis not really a game yet ;)
01:26:23 <quicksilver> lacking in interactivity.
01:26:42 <quicksilver> if Seq were a class, some of the nasty _|_ issues go away.
01:27:00 <quicksilver> in particular the difference between \_ -> _|_ and _|_ becomes unobservable.
01:27:04 <quicksilver> which is nice for semantics.
01:27:38 * BeelsebobWork ponders... accumB (-100,-100) shipEvents where shipEvents = clickOn `mappend` clickAway; clickAway = const (0,0) <$ filterE isClickAway mouseEvents; clickOn = integral shipVel <$ filterE isClickOn mouseEvents
01:27:50 <BeelsebobWork> something like that, but with something to change velocity when the ship changes too
01:27:52 <BeelsebobWork> no?
01:28:32 <Peaker> quicksilver: what are the disadvantages?
01:28:43 <quicksilver> BeelsebobWork: that makes clickAway jump to the location you click on.
01:29:03 <quicksilver> BeelsebobWork: which is perfectly reasonable, in fact, and avoids the problem I was describing.
01:29:17 <BeelsebobWork> quicksilver: hmm? no -- it replaces all clickAways with functions that do nothing to the ship position
01:29:21 <Peaker> BeelsebobWork: conal united the mouse events into one big event source?
01:29:24 <BeelsebobWork> and accumulates than function on the behavior
01:29:38 <BeelsebobWork> Peaker: no -- I'm just writing pseudo-code
01:29:56 <BeelsebobWork> do nothing to the camera pos rather
01:29:58 <quicksilver> BeelsebobWork: either I'm wrong about what accumB does, or you are. Let me check ;)
01:30:26 <BeelsebobWork> accumB takes a starting value, and applies the functions in the events to that value when the events occur
01:31:10 <BeelsebobWork> oh no -- mine doesn't do anything dynamic during the clickOn stage
01:31:10 <Peaker> quicksilver: hmm, stars hangs very quickly, no longer redrawing or responding
01:31:35 <quicksilver> BeelsebobWork: the hard bit is getting the 'final value' from a period during which you are following the ship.
01:31:45 <quicksilver> BeelsebobWork: and using that as the 'static value' for the next static phase.
01:31:48 <jeff123> What's the difference between the Int and Integer types; Haskell doesn't seem to like adding them together.
01:31:53 <quicksilver> that's why I needed to write switcherFold
01:32:01 <quicksilver> jeff123: Int is a native machine int, either 32 or 64 bit most likely
01:32:03 * BeelsebobWork goes and peaks at what you did
01:32:07 <quicksilver> jeff123: Integer is unbounded.
01:32:22 <jeff123> oh ok
01:32:24 <quicksilver> jeff123: you can convert from one to the other with fromInteger
01:32:44 <BeelsebobWork> quicksilver: for me it doesn't seem to hang, but it does seem to use progressively more CPU
01:32:59 <BeelsebobWork> up to about 45% atm
01:33:09 <quicksilver> yeah, it uses a lot of CPU
01:33:16 <BeelsebobWork> yeh, it's not the "lots" that I'm worried about
01:33:21 <quicksilver> and leaks memory slowly, eventually it will be painful.
01:33:21 <BeelsebobWork> it's the linearly more
01:33:26 <BeelsebobWork> (although a low linear)
01:33:29 <BeelsebobWork> 49% now
01:33:30 <quicksilver> probably the GC cost of the memory leak
01:33:38 <BeelsebobWork> oh, is there a leak?
01:33:41 <quicksilver> yes
01:33:47 <quicksilver> although believe me it's a slow one, compared to what it used to be :)
01:33:55 <quicksilver> it used to bring the computer to a grinding halt in about 10 seconds.
01:33:58 <BeelsebobWork> yeh, I'm not seeing OS X claiming that it's using more
01:34:19 <jeff123> I found toInteger. Thanks!
01:34:25 <quicksilver> Peaker: did you compile with -threaded
01:34:29 <quicksilver> jeff123: I meant fromIntegral
01:34:30 <Peaker> quicksilver: oops :)
01:34:37 <quicksilver> jeff123: there is no need to ever use toInteger
01:34:45 <quicksilver> jeff123: fromIntegral is more general :)
01:34:45 <jeff123> oh
01:34:54 <Peaker> quicksilver: you did mention that, silly me :)
01:34:57 <quicksilver> since it works in both directions.
01:35:03 <jeff123> Oh I see, yup.
01:35:06 <quicksilver> Peaker: yeah, some of the event passing requires the threaded RTS.
01:35:09 <BeelsebobWork> also QS, it doesn't seem to be that big a CPU hog to me
01:35:14 <BeelsebobWork> about half of one core for me
01:35:18 <quicksilver> BeelsebobWork: you have quite a fast machine don't you?
01:35:36 <BeelsebobWork> yeh, but still -- half of one core is not that much
01:35:39 * quicksilver nods
01:35:47 <quicksilver> well some people have much slower CPUs than either you or me ;)
01:35:55 <quicksilver> it's fine on my C2D macbook pro.
01:36:04 <BeelsebobWork> true true -- but the suggestion is that it'll run (just) on a 1.4Ghz CoreSolo
01:36:08 * quicksilver nods
01:36:22 <quicksilver> it should degrade framerate reasonably gracefully once it hits 100% CPU
01:36:33 <quicksilver> you can probably make it hit 100% CPU by zooming right out
01:36:38 <quicksilver> so it's drawing all six galaxies at once
01:36:59 <BeelsebobWork> yeh, I do -- interestingly, it doesn't thread at all
01:37:08 <BeelsebobWork> that degrades performance to about 25fps on this machine
01:37:33 <quicksilver> there's no real attempt to thread except in the event handling
01:37:37 <BeelsebobWork> it can draw at full speed with about 1.5 galaxies on screen
01:37:46 <quicksilver> pushing events off to the second core really isn't going to make much difference ;)
01:37:53 <BeelsebobWork> true
01:37:57 <quicksilver> (although of course you have to run with +RTS -N2 to do even that)
01:38:02 <BeelsebobWork> oh duh
01:38:38 <BeelsebobWork> with -N5 it hits at most 135% CPU use
01:38:45 <BeelsebobWork> and still degrades frame rate
01:39:16 <sioraiocht> grr
01:39:29 <sioraiocht> Object oriented programming is just scoping trickery!
01:42:21 <quicksilver> BeelsebobWork: there are certainly various ways I could speed up the drawing but frankly that's not the most interesting problem to me at the moment ;)
01:42:29 <BeelsebobWork> indeed
01:44:28 <quicksilver> BeelsebobWork: my OBJ loader is much simpler than yours but I had the code lying around and it worked for this simple case, BTW.
01:44:37 <quicksilver> BeelsebobWork: there is something to be said for code with no dependencies.
01:44:45 <BeelsebobWork> indeed
01:44:48 <solrize> ". For example, Kolmogorov's embedding of classical propositional logic/proofs into intuitionistic propositional logic/proofs is exactly the the typed CPS transform."
01:44:51 <solrize> ????
01:45:11 <BeelsebobWork> I was gonna take a look at your obj loader and check if there's anything in there that can get taken into mine
01:45:25 <BeelsebobWork> Mine is an ugly hack -- but that's mostly because obj is an ugly hacky format
01:46:21 <quicksilver> solrize: well, the embedding takes A to (A -> _|_) -> _|_
01:46:31 <quicksilver> solrize: but it turns out that (A -> r) -> r works just as well
01:46:40 <quicksilver> where 'r' is arbitrary.
01:46:44 <quicksilver> and that's CPS.
01:46:52 <quicksilver> it is a strange connection.
01:47:04 <solrize> does CPS stand for what it usually does??
01:47:11 <quicksilver> continuation passing semantics
01:47:21 <quicksilver> I'm not 100% sure about the 'S' actually.
01:47:54 <Deewiant> style
01:48:02 <quicksilver> ah yes :)
01:49:23 <solrize> that's forall r. (A->r) -> r ?
01:49:34 <quicksilver> no, I don't think so.
01:50:00 <quicksilver> just (A -> r) -> r for some fresh propositional constant 'r'
01:50:15 <quicksilver> but I'm pretty rusty.
01:50:22 <quicksilver> It's also the same thing as the Yoneda lemma.
01:50:29 <quicksilver> That's the thing about maths. Everything is actually the same.
01:50:55 <solrize> @quote quicksilver It's also the same thing as the Yoneda lemma.  That's the thing about maths. Everything is actually the same.
01:50:56 <lambdabot> No quotes match. I am sorry.
01:51:03 <solrize> @remember quicksilver It's also the same thing as the Yoneda lemma.  That's the thing about maths. Everything is actually the same.
01:51:04 <lambdabot> Done.
01:51:07 <solrize> :)
01:51:45 <yakov> hey
01:52:43 <yakov> GLUT seems to be b0rken, I've installed binary distribution ghc 6.10.1 and then with the latest cabal-install cabal installed glut, now I can't build RedBook examples from glut due to missing symbols
01:52:47 <solrize> say r=top (that's like unit, right?),   then (A->r)->r
01:52:57 <solrize> is trivially inhabited
01:53:11 <yakov> ghc-pkg describe GLUT   shows empty ld-options :(
01:53:32 <solrize> hmm
01:53:34 <solrize> thanks
01:53:45 <yakov> (ubuntu
01:53:52 <zeno> what to use for parsing text out of HTML? parsec?
01:53:53 <solrize> i'll have to think about this earlier in the day
01:54:01 <solrize> zeno, tagsoup
01:54:32 <zeno> solrize thanks
01:56:47 <quicksilver> haxml is another option.
01:57:20 <quicksilver> yakov: did you have glut and glut-dev installed when you installed GLUT?
01:57:24 * wli tries to remember how to balance binary tree heaps without keeping count of how many elements are in a subtree.
01:57:42 <quicksilver> yakov: what I mean is, did you have the native packages installed before installing the cabal package.
01:58:00 <thomashartman1> how do I get around this bug with ghc 6.10.1 that cabal
01:58:00 <thomashartman1> 		 doesn't work the first time? I did this already but I forget
01:58:03 <thomashartman1> 		 how?
01:58:10 <yakov> quicksilver, actually first time i cabal installed glut it could not find glut-dev from configure, so i apt-geted it, then i reinstalled glut with cabal install glut
01:58:22 <yakov> might it be that something has been cached?
01:58:29 <thomashartman1> "The"
01:58:31 <thomashartman1> workaround is to register at least one package in the user package db.
01:58:40 <ajhager> identify cha84ron
01:58:41 <quicksilver> sounds surprising, yakov
01:58:49 <thomashartman1> Not a very helpful error message if you're just used to cabal install and it works every time.
01:58:52 <quicksilver> ajhager: oops. You probably need to change that password now.
01:59:08 <quicksilver> wli: is there a variant of red-black for heaps?
01:59:40 <ajhager> luckily it wasn't irc or anything important.  But still. big oops.
01:59:57 <ksf> doesn't red-black require rotation? if yes, it doesn't make much sense on heaps.
02:00:36 <yakov> quicksilver, well, i've cabal install --reinstall'ed glut and anyway ghc-pkg reports empty ld-options.. :(
02:01:10 <wli> quicksilver: I think  you insert based on heap properties then fixup based on red-black, but I don't know the details.
02:01:43 <wli> http://hpaste.org/13116
02:02:34 <wli> There are such things as red-black heaps, but I don't know how the blatant and glaring problem(s) are resolved.
02:04:25 <Gracenotes> @hoogle Data.ByteString.Lazy.Char8.ByteString -> String
02:04:25 <yakov> no luck, it's b0rken, i've reinstalled it completely and still could not link simple example
02:04:25 <lambdabot> Parse error:
02:04:25 <lambdabot>   --count=20 "Data.ByteString.Lazy.Char8.ByteString -> String"
02:04:25 <lambdabot>                  ^
02:04:51 <quicksilver> yakov: there is a message on hopengl showing someone else sharees your problem. No solution is given.
02:05:02 <quicksilver> Gracenotes: unpack
02:05:23 <quicksilver> yakov: the workaround is to specify -lglut by hand, but I suspect you know that.
02:05:31 <yakov> quicksilver, aha thx!
02:05:33 <Gracenotes> ...oh, of course. Thanks :) Don't know why Hoogle failed though
02:05:35 <wli> For the moment, I'm just tracking how many elements each subtree is, and redistributing things at insertion and deletion.
02:12:01 <ksf> you can loose much in terms of average big-O by switching from linked trees to a heap if all you do isn't looking stuff up at positions you know, or replacing single elements w/o resorting/balancing
02:12:13 <BeelsebobWork> quicksilver: your VBO compacting algorithm -- is it O(something large)?
02:12:37 <wli> ksf: Do you see anything wrong at http://hpaste.org/13116 ?
02:13:16 <quicksilver> BeelsebobWork: I think it's only n log n ?
02:13:33 <quicksilver> BeelsebobWork: it's a while since I looked at it.
02:13:38 <quicksilver> BeelsebobWork: I'm not sure it's useful in practice.
02:13:45 <ksf> wwait... that isn't a heap, that's a linked tree.
02:13:46 <hugga011_> #biology
02:13:51 <BeelsebobWork> quicksilver: what's the intention of it?
02:14:17 <BeelsebobWork> to make the buffers smaller?
02:14:45 <wli> I won't argue about heaps having linked tree implementations. I just want to know where I went wrong.
02:14:58 <BeelsebobWork> it seems to have made them larger in this case...
02:14:59 <BeelsebobWork> modelToVBO stats : 35077 vertices,75737 normals,6762 triangles,80184 quads.
02:14:59 <BeelsebobWork> Compacting complete, 63346 vertices, 63346 normals, 80184 indices.
02:15:30 <quicksilver> BeelsebobWork: well it reduced the number of normals, because some were identical
02:16:05 <quicksilver> it was forced to increase the number of vertices because OBJ format can reuse position between points which have different other properties
02:16:11 <quicksilver> but an indexed VBO cannot do that
02:16:16 <BeelsebobWork> ah, okay
02:16:20 <BeelsebobWork> makes sense
02:16:22 <quicksilver> still I"m not quite convinced it's doing the right thing ;)
02:16:33 <BeelsebobWork> also... giggle -- I have tie fighters flying round
02:16:35 <BeelsebobWork> >.>
02:16:51 <quicksilver> ;)
02:16:59 <wli> ksf: Do you see where I "went wrong" that made it slow?
02:17:05 <quicksilver> at a weird scale, presumably?
02:17:44 <tjb> Anyone familiar with QuickCheck?  I'm trying to redefine/modify the generator for Integer and keep getting "Duplicate instance" errors.
02:18:27 <opqdonut> tjb: you can't override instances
02:18:30 <quicksilver> tjb: you can't have more than one Arbitrary instance for the same type.
02:18:32 <opqdonut> wrap it in a newtype
02:18:37 <quicksilver> fortunately the quickcheck develoeprs knew this
02:18:42 <quicksilver> that's what 'Gen Integer' is for
02:18:52 <quicksilver> to specify a custom gen instead of the Arbitrary one.
02:19:17 <ksf> wli, not without profiling, nope.
02:20:13 <tjb> (I'm obviously new) : so I should use "newtype" to define my custom generator and specify my custom generator in the "prop" statement?
02:21:13 <opqdonut> you can either 1) do a newtype MyInteger = MyInteger Integer and add an Arbitary instance for that or 2) use Gen
02:21:18 <cjs> So, in FFI, if I have a funtion that takes a Ptr Word8, and I've got a Ptr MyThingie to pass it, what do I do to cast it?
02:21:35 <sjanssen> tjb: you can use Test.QuickCheck.forAll
02:21:44 <tjb> opqdonut: ah, ok.  Thanks for clearing that up for me
02:22:01 <Gracenotes> oh, jeez, I've been doing 15 hours straight of Haskell (not including eating and news-checing)
02:22:14 <sjanssen> myprop = forAll myIntegerGen $ \n -> ...
02:22:23 <Gracenotes> need to stop >_<
02:22:37 <quicksilver> cjs: you use castPtr, although you probably shouldn't be in this situation.
02:22:55 <tjb> sjanssen: thanks, I'll take a look at that
02:23:05 <quicksilver> cjs: if you are validly expected to pass Ptr MyThing then that should be the declared type, surely?
02:23:42 <cjs> No, it's one of those dumb APIs that just stores globs of data, and you hope that the guy that asks for it out  and what you put in are the same thing.
02:24:00 <cjs> It's sort of like malloc, actually, if you get my drift.
02:24:59 <ksf> pointer casts are evil, even in C.
02:25:15 <opqdonut> a necessary evil
02:25:17 <quicksilver> cjs: traditionally one uses Ptr () for globs of data
02:25:32 <opqdonut> why not Ptr Void ;)
02:25:35 <quicksilver> cjs: although it would be neither to have a haskell-side safe interface.
02:25:38 <ksf> but then, *char != *void
02:25:55 <quicksilver> opqdonut: only because Void isn't part of the prelude. That would indeed be better.
02:25:56 <ksf> void should have a size_t increment iirc.
02:26:00 <cjs> Oh, but it's a glob I make up myself, before handing it to the storage API. For me, it really is a Ptr HSZPair, where HSZPair is an instance of Storable.
02:26:17 <wli> char * != void *?
02:26:29 <opqdonut> wli: in terms of alignment fer instance
02:26:36 <ksf> wli, yes.
02:28:17 <quicksilver> only for pointer arithmetic.
02:28:26 <quicksilver> if you don't use ++ or += they are the same.
02:28:55 <quicksilver> I would argue using ++ or += on void* should really be undefined, or an error.
02:28:58 <quicksilver> (but, it isn't.)
02:29:20 <ksf> dunno... I never even tried to deref a void* directly, so I wouldn't know what it dereferences to.
02:29:32 <wli> In kernels people cast unsigned longs back and forth to various pointer types (esp. the same unsigned long to different pointer types) on a routine basis. ;)
02:30:41 <wli> Lots of implicit conversions between void * and other pointer types also.
02:31:24 <flux> I remember that's one main point linus prefering C over C++: int *foo = malloc(42); compiles
02:31:32 <wli> ksf: Dereferencing them is illegal; they're only containers for pointers to data of unspecified type.
02:31:39 <ksf> -Wwarn-if-Wall-would-make-me-cry
02:32:07 <flux> -Wcry-threshold=10 ?
02:32:38 <wli> Check things like virt_to_page() and page_address().
02:33:08 <ksf> -std=c99 -Wall -pedantic
02:33:10 <wli> pfn_to_page() may be better than virt_to_page().
02:38:56 <blackh> Here's a style question: If I'm doing this kind of stuff: e.g. "do {let user' = user {confirmed = True}; put user'; return user'}" - Is there a way or a trick to put the old user out of scope (shadowing?) so I can't refer to it by mistake?
02:39:42 <opqdonut> blackh: not really, no
02:39:45 <quicksilver> blackh: did it come from "get" ?
02:39:46 <opqdonut> perhaps with view patterns
02:39:57 <opqdonut> ah, or if it came from get
02:40:00 <quicksilver> that's the kind of thing state is for
02:40:09 <opqdonut> that is, you might be able to avoid having it in scope ever at all
02:40:09 <quicksilver> but you seem to using state for something else (or almost the same thing?)
02:40:19 <blackh> quicksilver: This is my own "put" (commit to database).
02:40:24 <quicksilver> oh.
02:40:29 <wli> I wonder if I could get away with HeapBranch Ordering t (Heap t) (Heap t) instead of HeapBranch Int t (Heap t) (Heap t)
02:40:44 <quicksilver> blackh: the generic solution is to use StateT User ....
02:40:53 <blackh> quicksilver: But essentially it does the same job as State monad's put.
02:41:00 <quicksilver> blackh: State is the "solution" to the problem of confusing "s" and "s'"
02:41:21 <quicksilver> but it is not completely for free - you pay with a little syntatic overhead.
02:41:37 <quicksilver> so it's not always worht using in tiny examples.
02:41:43 <quicksilver> worth recognising the pattern, though.
02:43:18 <blueonyx> hi
02:44:05 <blackh> quicksilver: In many cases I do this then only refer to it again twice. Maybe "let user' = user {confirmed = True} ; let user = user'" - Urk!
02:44:13 <blackh> blueonyx: hello!
02:45:22 <quicksilver> blackh: be careful of accidental recursion.
02:45:46 <blackh> quicksilver: Or "let user' = user {confirmed = True} ; let user = undefined" - Double urk!
02:45:55 <sjanssen> blackh: you can use "let ... in ..." if you want to limit the scope of a binding
02:46:04 <quicksilver> why would you do that last, blackh ?
02:46:42 <blackh> quicksilver: It's a very bad way of making it so "user" isn't useful any more.
02:46:53 * quicksilver nods
02:47:05 <quicksilver> I think you do want StateT
02:47:15 <quicksilver> StateT User (whateveryouhadbeforemaybeitwasIO?)
02:47:45 <quicksilver> then it looks something like
02:48:22 <quicksilver> do { modify (\x -> x {confirmed = True}); liftIO bhPut =<< get; get; }
02:48:27 <quicksilver> although you might miss off the final get
02:48:38 <quicksilver> since that value is implicitly available you probably don't need to return it.
02:48:52 <quicksilver> I renamed your put to bhPut so it wouldn't collide with state's put ;)
02:50:18 <quicksilver> if you use one of the lense packages out there, like Data.Accessor, you can get rid of the ugly (\x -> x{confirmed = True})
02:50:23 <quicksilver> it becomes
02:50:33 <quicksilver> modify (confirmed ^= True)
02:50:48 <quicksilver> (where 'confirmed' is no longer a simple record selector but now a lens)
02:50:59 <blackh> quicksilver: I think you are right. I recall that the state transformer is really easy to use. But I'll have to rename 'put'. :)
02:51:15 <quicksilver> blackh: I'm not necessarily suggesting this is the right answer for your code.
02:51:20 <quicksilver> but it certainly is the way to avoid naming 'user'
02:51:34 <quicksilver> at the cost of some "liftIO"s and "runStateTs" here and there.
02:51:42 <quicksilver> you may find the cost outweighs the benefit.
02:53:02 <blackh> quicksilver: Basically it's a slight cost in clarity for a gain in making it harder to make mistakes.
02:53:19 <BeelsebobWork> quicksilver: I'd love a record "modification" syntax along the lines of x[confirmed / True] actually -- it would fit nicely in a mathematical syntax kinda way
02:53:33 <blackh> In my experience, making it harder to make mistakes is a very worthy goal.
02:54:37 <cjs> This is pretty cool. With FFI I can implement an entire interface into Microsoft's ddeml library without writing a line of C.
02:59:51 <tjb> For myGen :: Gen Integer function, what I'd really like is to return a list of random integers -- should this be in my forAll statement, or in the actual generator function?
03:00:15 <quicksilver> BeelsebobWork: "(confirmed ^= True) x" is not too bad
03:05:22 <blueonyx> tjb: you want a pure funktion that returns a different result on every call? :>
03:05:58 <quicksilver> tjb: do you mean, you want to it to return a random value from a list? different one each time?
03:05:59 <tjb> blueonyx: With QuickCheck, I'm trying to write a Generator that returns a list of random Integers
03:06:11 <quicksilver> then you want a Gen [Integer]
03:06:14 <quicksilver> not a Gen Integer
03:06:42 <tjb> quicksilver: correct -- but I'm not sure how to generate the random length lists in my Gen Integer function
03:06:55 <tjb> I'm currently just using: x1 <- choose(0,255)
03:07:33 <tjb> would I want something like:  x1 <- vector choose(0,20) choose(0,255) ?
03:07:58 <blueonyx> there is arbitrary::Gen [Integer]
03:08:15 <quicksilver> blueonyx: he wants to write his own Gen
03:08:21 <quicksilver> blueonyx: the default one isn't appropriate for him.
03:08:29 <blueonyx> but he can use this?
03:08:41 <quicksilver> but I'm not really understanding exactly what tjb is trying to do just now ;)
03:08:50 <quicksilver> tjb: are you trying to generate Integers or [Integer]s?
03:08:55 <tjb> blueonyx, quicksilver: correct, but after I've learned the basics I'd like the generator to do a bit more than arbitrary::Gen [Integer]
03:08:56 <quicksilver> what problem are you actually trying to solve?
03:09:18 <tjb> quicksilver: trying to generate [Integer]s
03:09:33 <blueonyx> O.o
03:11:11 * tjb is on his second day of learning haskell -- it's fun, but a different mindset from other languages
03:11:20 <vininim> tjb: you can get what you want with simple math, iiuc
03:11:50 <blueonyx> ..simple.. :/
03:12:38 <BeelsebobWork> quicksilver: can you tell me what starChangesE contains -- I'm having trouble penetrating it
03:13:10 <quicksilver> BeelsebobWork: timewiseIterate runs a funciton (a -> a) at timed intervals.
03:13:19 <quicksilver> BeelsebobWork: so I have a pure function which 'evolves' the starfield
03:13:31 <quicksilver> BeelsebobWork: and timewiseIterate runs that function once every 400 ms
03:13:58 <BeelsebobWork> oh, so it's along the lines of accumE f $ atTimes [0,0.4 ..]?
03:14:02 <quicksilver> the slight mess there is (a) threading the RNG through and (b) adding some possibly un-needed strictness because I was chasing down a leek.
03:14:07 <quicksilver> BeelsebobWork: yes, exactly.
03:14:10 <BeelsebobWork> cool :)
03:14:14 <opqdonut> heh, space leek
03:14:22 <quicksilver> although with stupid non-deterministic time.
03:14:35 <quicksilver> (my timewise iterate uses threadDelay not atTimes)
03:14:36 <BeelsebobWork> stupid non-deterministic time?
03:14:39 <BeelsebobWork> oh, I see
03:14:39 <quicksilver> not very important for a game though.
03:15:59 <quicksilver> opqdonut: shame I'm not artist, that would be a great cartoon.
03:16:07 <opqdonut> yep
03:16:36 <quicksilver> "If python makes you fly, haskell lets you fold space like a guild navigator : just watch out for the space leeks."
03:16:52 <aleator> Yo. What is the preferred way of generating xml (or specifically svg)?
03:24:34 <blackh> aleator: What is your application?
03:27:05 <aleator> blackh: I'm experimenting with sparklines
03:27:24 <blackh> aleator: What are sparklines?
03:27:51 <aleator> blackh: Well, simple, narrow graphs of data.
03:29:08 <blackh> aleator: How much speed do you need?
03:29:34 <fasta> Can Haskell-mode be unloaded? M-x haskell-mode doesn't work like in normal emacs modes.
03:29:55 <aleator> blackh: Not very much. ultimate goal is just to produce 10-50 graphs for a publication
03:30:12 <opqdonut> fasta: well killing the buffer is one choice ;)
03:30:33 <fasta> opqdonut: yes, but then I need to disable the autoload in my .emacs etc.
03:31:12 <opqdonut> ah
03:31:27 <quicksilver> aleator: did you see there is already a haskel sparkline thing? might be interesting to compare.
03:31:32 <blackh> aleator: There are several XML libraries but I'm a bit too new at this to give you a comprehensive overview.
03:31:44 <quicksilver> fasta: M-x fundamental-mode or text-mode?
03:32:15 <blackh> aleator: HXT might be a bit heavyweight.  I'm working on a patch to hexpat which might be a bit lightweight.  Look at HaXML and XML.
03:32:23 <fasta> quicksilver: yes :)
03:32:25 <quicksilver> haxml is for XML parsing though.
03:32:32 <quicksilver> aleator wants XML generation
03:32:33 <fasta> quicksilver: thanks
03:32:54 <fasta> If you want XML generation, you just generate it yourself, no?
03:33:01 <quicksilver> well combinators can help
03:33:04 <aleator> quicksilver: I saw that, but I need vector graphics
03:33:04 <quicksilver> to e.g. keep it balanced
03:33:05 <fasta> At least that's what I did.
03:33:06 <malcolmw> HaXml can do document generation too
03:33:13 <quicksilver> or even to respect a DTD
03:33:20 <quicksilver> malcolmw++ # always pops in with the answer :)
03:33:39 <malcolmw> keyword highlight in my IRC client :-)
03:33:44 <opqdonut> :D
03:33:58 <blackh> aleator: I just wrote a really really simple cut-down XML generator... It generates XML form this tree structure: http://hackage.haskell.org/packages/archive/hexpat/0.2/doc/html/Text-XML-Expat-Tree.html
03:34:03 <aleator> I'm basically Just asking if there is reason to go for haxml, hxt, cairo or just squirt out strings?
03:34:05 <fasta> malcolmw: mIRC?
03:34:34 <blackh> aleator: I have asked the author of hexpat to integrate it.
03:34:35 <daf> I would imagine that cairo > haxml/hxt > strings
03:34:39 * fasta noticed mIRC support in HsColour.
03:34:39 <opqdonut> fasta: irssi does it too
03:34:40 <daf> in terms of ease
03:34:51 <malcolmw> fasta: colloquy on MacOS
03:34:59 <fasta> opqdonut: can you see fasta at the end of a line?
03:35:04 <fasta> opqdonut: say*
03:35:35 <quicksilver> aleator: cairo is adding another big library but I bet it makes it easier to generate graphics with a natural API
03:35:58 <malcolmw> aleator: in general, it is always better to construct complex values as trees rather than strings.  It gives you more ability to check that the construction is correct, and also gives more flexible output string formatting
03:36:40 <opqdonut> will do, fasta
03:36:51 <fasta> opqdonut: ok, it works :)
03:36:56 <aleator> quicksilver: For cairo I think I need gtk2hs, so that is kinda big investment :)
03:37:02 <quicksilver> aleator: yeah, quite.
03:37:27 <daf> a big investment how?
03:37:30 <daf> in terms of disk space?
03:37:40 <daf> you don't need to use the Gtk API
03:37:46 <daf> just the Cairo one
03:37:50 <daf> and the Cairo API is quite small
03:38:14 <mornfall> daf: In terms of a nasty dependency, I guess.
03:38:23 <daf> what's nasty about it?
03:38:31 <aleator> daf: Has the cairo been split from gtk2hs?
03:38:33 <mornfall> You can't get it from hackage.
03:38:41 <daf> aleator: no
03:38:50 <daf> mornfall: that's true
03:38:51 <mornfall> Which in turn makes your code non-cabal-installable.
03:39:07 <daf> aleator: but the APIs are still separate
03:39:29 <mornfall> (At least for people who don't already have gtk2hs... and I imagine that one builds for a long time...)
03:39:47 <vegai> gtk2hs is not quite as easy to install as haskell libraries typically
03:39:53 <vegai> plus it breaks easily
03:39:57 <mornfall> Right.
03:39:59 <aleator> daf: Yeah. Thats true. And as bonus I could get an easy viewer on top.. But it's quite much work to handle.
03:40:09 <daf> if you use a real system, it provides gtk2hs for you
03:40:40 <aleator> daf: Hah. I'm stuck with uni-it-center mandated "fedora from stoneage"-system :)
03:40:52 <daf> ah, shame
03:41:00 <daf> modern Fedora would probably count as a real system
03:41:06 <quicksilver> /usr/bin/flintstones
03:41:21 <mornfall> daf: Even if you have a system gtk2hs, you are then forced to use its dependencies with anything that uses gtk2hs, which excludes new versions of I imagine many packages.
03:41:31 <mornfall> But you have the same problem with ghc which is not cabal-upgradable either.
03:41:47 <mornfall> (Ie. ghc api versus bytestring...)
03:42:00 <vegai> I sure hope daf doesn't refer to Debian as a real system :P
03:42:08 <vegai> oops
03:42:14 * vegai waves a white flag of surrender
03:42:15 <tjb> I figured out how to generate the random length lists of random Integers -- but anyone have a way to simplify it to a single function? http://hpaste.org/13117#a0
03:42:24 <mornfall> vegai: Good move.
03:42:26 <daf> vegai: that was in fact what I was referring to :)
03:42:26 <fasta> Is there a program that turns a {-  -} commented document into a Bird style literate Haskell one?
03:42:53 <daf> mornfall: I haven't run into problems with system vs. non-system packages
03:42:57 <daf> though I hear other people have
03:43:00 <quicksilver> tjb: randomIntList n is "replicateM n (choose (0,255))"
03:43:22 <daf> obviously gtk2hs should be in hackage
03:43:29 <daf> but it still doesn't save you from building it
03:43:49 <mornfall> daf: But you can say "cabal install foorequiringgtk2hs" and walk away.
03:43:57 <mornfall> And when you get back, hopefully you have everything ready.
03:44:01 <daf> I can do that
03:44:16 <daf> it's just that people without real systems can't
03:44:33 <daf> I agree that it would be nice if they could
03:44:44 <mornfall> daf: That's a non-argument.
03:45:07 <mornfall> daf: Cabal still won't be able to pull in your system gtk2hs, nor will it be able to rebuild it in case that's required.
03:45:14 <tjb> quicksilver: ah excellent, thanks!
03:45:15 <mornfall> And I need to go, anyway.
03:45:20 <mornfall> -->
03:45:24 <daf> mornfall: true
03:45:36 <quicksilver> tjb: you didn't need to know that to write it in one function though ;)
03:45:45 <quicksilver> tjb: xs <- sequence [ choose(0,255) | i <- [1..n] ]
03:45:52 <quicksilver> tjb: as 2nd line of randomInt would have been fine.
03:46:17 <tjb> quicksilver: when I tried that I got a type inference error
03:46:39 <tjb> let me get the error message
03:47:12 <tjb>     Ambiguous type variable `t' in the constraints:
03:47:13 <tjb>       `Num t' arising from the literal `0' at hdlc_frame.hs:46:17
03:47:13 <tjb>       `System.Random.Random t'
03:47:13 <tjb>         arising from a use of `choose' at hdlc_frame.hs:46:10-20
03:47:13 <tjb>       `Enum t'
03:47:13 <tjb>         arising from the arithmetic sequence `1 .. n'
03:47:15 <tjb>                      at hdlc_frame.hs:49:42-47
03:47:17 <tjb>     Probable fix: add a type signature that fixes these type variable(s)
03:47:22 * quicksilver nods
03:47:31 <quicksilver> (don't paste things that long here please)
03:47:40 * tjb oops, ok
03:47:41 <quicksilver> you could have fixed that just by annotating the type of 'n' somewhere though
03:48:18 <quicksilver> finally, "xs <- blahblahblah ; return xs" is the same as simply "blahblahblah"
03:48:27 * fasta just wrote a script to install the latest and greatest gtk2hs
03:48:39 <quicksilver> so the final version looks something like "n <- choose (0,2); replicateM n (choose (0,255))"
03:49:22 <quicksilver> or if you like ugly code, flip replicateM (choose (0,255)) =<< choose (0,2)
03:49:34 <tjb> quicksilver:  great, that works -- well, both work actually :)
03:50:52 <tjb> quicksilver: you mentioned I could have annotated the type for 'n' in the previous version -- any pointers on that?
03:51:18 <quicksilver> [1..n::Int]
03:51:26 <quicksilver> would be one possible place to annotate it.
03:51:41 <quicksilver> n <- choose (0,2) :: Gen Int
03:51:43 <quicksilver> would be another
03:52:02 <tjb> interesting -- thanks again
03:53:15 <tjb> ok, well thanks a lot for the help -- now I have to get ready to go to my real job :(
03:53:34 <quicksilver> (n :: Int) <- choose (0,2) -- unfortunately this annotation requires a GHC extension.
03:54:09 <tjb> quicksilver: I have a feeling it will take me more than these past couple of days to get comfortable with Haskell :)
03:55:43 <quicksilver> tjb: I would say you're doing well :)
03:57:32 <fasta> Where is the unlit program documented?
04:03:48 <therp> is there any haskell implementation around that allows me to override module encapsulation?
04:04:23 <therp> I found it time consuming to build additional debugging into modules so that I can inspect certain values
04:05:07 <therp> in common lisp you have module:symbol, respecting the export directives, but if you really want to go for the unclean option one could you use module::symbol and get direct access
04:11:03 <diegoech`> Im trying to compile some libs with ghc 6.10.1 ... anybody knows whats "Module `PackageConfig' does not export `packageIdString'"
04:11:03 <diegoech`>  
04:17:12 <diegoeche> Im trying to compile some haskell libs
04:17:14 <Lemmih> therp: The compiler is free to completely eliminate unexported symbols.
04:17:41 <diegoeche> ananybody knows what's this all about:
04:17:44 <diegoeche> src/System/Plugins/Load.hs:87:0:
04:17:44 <diegoeche>     Failed to load interface for `GHC.Prim':
04:17:44 <diegoeche>       it is a member of package ghc-prim, which is hidden
04:17:51 <Lemmih> diegoeche: They probably haven't been updated to support ghc-6.10. Ask the maintainer.
04:18:05 <Lemmih> diegoeche: hs-plugins doesn't work with ghc-6.10.
04:18:58 <diegoeche> and, cant be ported?
04:19:10 <diegoeche> thats what im trying to do...
04:19:11 <chrisdone> oh wowo
04:19:13 <chrisdone> http://haskell.org/haskellwiki/Image:NarleyYeeaaahh.jpg
04:19:15 <chrisdone> I lol'd so hard
04:19:54 <C-Keen> chrisdone: :)
04:20:07 <Lemmih> diegoeche: Porting it will be quite difficult (requiring a bunch of code to be rewritten). Are you sure you're up for it?
04:23:08 <diegoeche> well i have compiled 12 of 16... i have changed some files that used some deprecated cabal function
04:23:41 <diegoeche> but i dont have any idea about this :     Module `PackageConfig' does not export `packageIdString'
04:23:53 <diegoeche> i tried hoogle and no clue
04:24:22 <blueonyx> hehe 'laziness without side effects' :)
04:28:12 <Lemmih> diegoeche: It's from the 'ghc' package.
04:28:59 <Lemmih> diegoeche: Porting hs-plugins is a /lot/ of work. I recommend using another library.
04:31:24 <diegoeche> ok... thanks.
04:44:20 <diegoeche> well it compiled... it wasn't that hard... now ill have to see if it works
04:48:07 <mbz_> @index MaybeT
04:48:08 <lambdabot> bzzt
04:55:20 <quicksilver> mbz_: there's a MaybeT on hackage.
04:55:43 <quicksilver> I don't know why there isn't one in the MTL
04:59:42 <mbz_> quicksilver, thanks
05:03:49 <mereandor> hi! a little newbie question: how can I save a state in haskell ie. consequtively adding values to a list without explicitly using monads?
05:04:36 <quicksilver> well the short answer is you can't.
05:04:45 <quicksilver> but that's a bit of a specific question about a strange objective.
05:04:49 <quicksilver> what are you actually trying to do?
05:05:02 <quicksilver> the natural thing to do is keep passing the list around as parameter-return value
05:05:20 <osfameron> adding values to a list sounds like you might want to use a fold with an accumulator
05:06:22 <mereandor> I need a list that is used to lookup indices for values. if a value is not present in the list it should be added (and be found in later calls)
05:06:41 <EvilTerran> memoisation!
05:06:45 <quicksilver> mereandor: you can't do that, in the way you describe it.
05:06:45 <EvilTerran> ?
05:06:45 <mereandor> basically it's a mapping [a] -> a -> Int
05:06:51 <quicksilver> mereandor: all haskell values are immutable
05:07:00 <quicksilver> there is no such thing as 'add something to the list for future calls'
05:07:12 <mereandor> i know but I learned that there is something like the <- operator?!
05:07:24 <mereandor> in "do"-statements
05:07:26 <quicksilver> you said you didn't want to explicitly use monads
05:07:32 <quicksilver> I assumed that meant you didn't want to use <-
05:07:48 <mereandor> I meant I don't want to create an instance of monad for that purpose
05:07:58 <quicksilver> the natural functional model for this is to have the lookup function return the new lookup table
05:08:01 <hoopy> @type Just
05:08:02 <lambdabot> forall a. a -> Maybe a
05:08:07 <quicksilver> (and then pass that back in the next time you call it)
05:08:18 <hoopy> "Tree.hs:1:35: Not in scope: type constructor or class `Just'"
05:08:26 <mereandor> ah
05:08:33 <mereandor> ok
05:09:22 <quicksilver> hoopy: Just is a value constructor; you must be using it in a context which expects a type.
05:09:50 <hoopy> is there a paste bin for this channel?
05:10:21 <quicksilver> http://hpaste.org/
05:10:29 <quicksilver> should be in the topic, I hope.
05:11:10 <hoopy> ah, i'm using irssi
05:11:15 <hoopy> could have tried /topic
05:11:18 <hoopy> http://hpaste.org/13118
05:11:38 <quicksilver> I think you meant
05:11:46 <hoopy> this is an exercise in RWH where you try to make a tree where the leaf nodes don't have to be told they're Empty
05:11:53 <quicksilver> data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))
05:12:06 <quicksilver> Maybe is the name of the type
05:12:13 <quicksilver> Just is the name of the value (constructor)
05:12:20 <hoopy> RWH uses Just when it's explaining the Maybe type... it's weird
05:12:24 <quicksilver> is, in "Just 5" is a value of type "Maybe Int"
05:12:42 <quicksilver> yes, because types and values sometimes have different names.
05:12:45 <quicksilver> does my example help?
05:12:58 <hoopy> it will likely make it work
05:13:07 <hoopy> i'm trying to grok this though
05:13:17 <mereandor> http://hpaste.org/13119 any idea why that doesn't work?
05:13:42 <hoopy> I get that Just 5 is a constructor for a type Maybe Int
05:13:49 <quicksilver> mereandor: yes. Because 'Int' isn't a monad so you can't use 'do' syntax.
05:14:51 <mereandor> ok so the return value must be IO Int ?
05:16:06 <blackh> mereandor: Ideally this code would not use a monad, because it doesn't need to.
05:16:10 <mereandor> quicksilver: when I delete the fromMaybe and make the return value "Maybe Int" it works - but when I add fromMaybe it complains that i is not of type "Maybe Int" that's a bit confusing
05:16:26 <mereandor> that's because the part that needs the monad is not there yet
05:17:09 <quicksilver> :t findIndex
05:17:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
05:17:37 <quicksilver> f1 l x = fromMaybe 0 (findIndex (==x) l)
05:17:39 <quicksilver> should be fine
05:17:48 <quicksilver> > :t let f1 l x = fromMaybe 0 (findIndex (==x) l) in f1
05:17:49 <lambdabot>   <no location info>: parse error on input `:'
05:17:51 <quicksilver> :t let f1 l x = fromMaybe 0 (findIndex (==x) l) in f1
05:17:52 <lambdabot> forall a. (Eq a) => [a] -> a -> Int
05:18:04 <mereandor> ^^
05:18:48 <mereandor> I don't unterstand it yet but thanks anyhow ;)
05:19:00 <cha0xz> ello
05:19:14 <blackh> mereandor: I know why it's confusing: Maybe can act as a monad, and you can sometimes do this by mistake.
05:19:37 <blackh> mereandor: So make sure your return type is IO Int
05:19:55 <quicksilver> blackh: I don't think he wants IO Int
05:19:59 <quicksilver> he's not doing any IO...
05:20:02 <hoopy> http://hpaste.org/13120
05:20:09 <quicksilver> I think he's writing a pure function at the moment.
05:20:13 <blackh> quicksilver: He does - he said he's going to add some I/O.
05:20:31 <quicksilver> perhaps.
05:20:35 <quicksilver> he didn't quite say that.
05:20:38 <quicksilver> We're both only guessin :)
05:20:44 <quicksilver> hoopy: Node takes three parameters.
05:21:01 <quicksilver> hoopy: there are a few mistakes there, but one is that the two "inner" nodes only have one parameter each
05:21:06 <quicksilver> (the left+right children)
05:21:06 <hoopy> so instead of putting empty as the 2nd and third arguments what would you put>?
05:21:16 <quicksilver> well, what type should go there?
05:21:30 <quicksilver> what does the definition of Node say its second parameter is?
05:21:49 <hoopy> that it's maybe another Tree
05:21:54 * quicksilver nods
05:21:58 <quicksilver> "Maybe" another tree
05:22:04 <quicksilver> what choices does the Maybe type give us?
05:22:08 <quicksilver> @src Maybe
05:22:08 <lambdabot> data Maybe a = Nothing | Just a
05:22:18 <hoopy> so i can put Nothing instead of Empty
05:22:24 <quicksilver> yup.
05:22:33 <hoopy> okay... i'm guessing that's more efficient
05:22:35 <quicksilver> now you have a problem with the "outer" Node.
05:22:48 <hoopy> Node "left child" Nothing Nothing
05:22:57 <quicksilver> the second parameter to the "outer" Node is now .. right, what you said.
05:23:01 <quicksilver> that has type Tree String
05:23:16 <quicksilver> but the second parameter to Node is supposed to be Maybe (Tree a)
05:23:18 <quicksilver> not just Tree a
05:23:22 <quicksilver> see what you have to do here?
05:24:27 <hoopy> no :[
05:24:37 <quicksilver> ;)
05:24:46 <quicksilver> well, how can you make  Tree a into a Maybe (Tree a)?
05:24:50 <quicksilver> what are the choices of the Maybe type?
05:25:01 <hoopy> Just a | Nothing
05:25:16 <quicksilver> nod
05:25:29 <quicksilver> so what do we do with our Tree, to make it into a Maybe Tree ?
05:26:04 <hoopy> data Maybe (Tree a) ?
05:26:09 * hoopy is taking wild stabs in the dark
05:26:12 <quicksilver> no.
05:26:20 <quicksilver> one choice for Maybe (Tree a) is Nothing
05:26:25 <quicksilver> that's what you used in the inner trees.
05:26:32 <quicksilver> what's the other choice for Maybe (Tree a)
05:26:33 <quicksilver> ?
05:26:55 <hoopy> Just (Tree a)
05:28:00 <Japsu> > sequence ["ki","it","ie","to","o","st"]
05:28:02 <lambdabot>   ["kiitos","kiitot","kiioos","kiioot","kietos","kietot","kieoos","kieoot","k...
05:28:37 <hoopy> i'm supposed to make this a recursive data type... the part of tree thats defined outside of its child nodes isn't considered to be Maybe (Tree a)
05:28:51 <quicksilver> hoopy: Just takes a value, not a type.
05:29:01 <hoopy> okay i think i get that now
05:29:01 <quicksilver> I'll put you out of your misery.
05:29:19 <quicksilver> Node "parent" (Just (Node "left" Nothing Nothing)) (Just (Node "right" Nothing Nothing))
05:29:41 <jg> Does QuickCheck2 have an equivalent to verboseCheck ?
05:30:02 <hoopy> okay so i can see how that's turning the Tree a's into Maybe a's
05:30:27 <Asztal> yay, I have my RWH! (Only ordered it yesterday, too)
05:31:09 <hoopy> interesting
05:31:18 <hoopy> i don't know why i didn't think that
05:31:20 <blackh> quicksilver: Thanks for your help earlier - in case you're interested, here's the shiny new StateT version of that code snippet: http://hpaste.org/13121
05:31:56 <hoopy> they're either Maybe (Tree a) | Nothing
05:32:16 <hoopy> so you have to use the Just constructor with the value of the leaf nodes to turn them into Maybe (Tree a)
05:32:32 <quicksilver> hoopy: precisely!
05:32:54 <hoopy> thanks
05:33:01 <quicksilver> blackh: cool :)
05:33:21 <quicksilver> blackh: as you can see, the noise of the lift and exec is slightly annoying but that's life.
05:33:43 <quicksilver> blackh: what do you do in the 'Nothing' case of the top case?
05:34:08 <blackh> quicksilver: I still think this is a good way when you want to make a non-trivial state change conditionally.
05:35:32 <blackh> quicksilver: Just some more state changing: http://hpaste.org/13121
05:36:52 <blackh> I have session state and request state, just like a typical web app.
05:37:00 <quicksilver> ah, fair enough.
05:37:06 <quicksilver> I often have Nothing -> return ()
05:37:20 <quicksilver> in which case I was going to recommend to you writing 'whenJust' which is a nice idiom
05:37:25 <quicksilver> but this is apparently not a use case for it ;)
05:37:53 <quicksilver> I suggest you add a function 'modifyRequestState'
05:38:00 <quicksilver> so you can write
05:38:01 <blackh> You mean this? whenJust = maybe (return Nothing)
05:38:05 * SamB_XP is tempted to say something about it raining both upon the Just and the Nothing
05:38:09 <blackh> Great minds think exactly alike, it seems!
05:38:21 <quicksilver> modifyRequestState (\x -> x {loginFailed=True})
05:38:43 <quicksilver> blackh: mine is maybe (return ())
05:38:47 <quicksilver> very similar.
05:39:00 <quicksilver> : maybe (return Nothing)
05:39:03 <quicksilver> :t maybe (return Nothing)
05:39:04 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
05:39:39 <quicksilver> :t maybe (return ())
05:39:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
05:40:07 <blackh> quicksilver: I use my whenJust for getting a CGI key, then fetching the database object if that CGI key exists, e.g.
05:40:08 <blackh> mProduct <- whenJust (fetch . ProductKey) =<< getField "id"
05:41:03 * quicksilver nods
05:41:17 <quicksilver> I can definitely see arguments for both versions.
05:41:52 <blackh> quicksilver: What I really want is a MaybeT but the one that's on the Haskell wiki just *will not* do the job mentioned above.
05:42:31 <quicksilver> it should do.
05:42:39 <quicksilver> that should be >>= for MaybeT, I think
05:42:46 <quicksilver> modulo argument order
05:44:10 <quicksilver> and modulo the imposition of 'runMaybeT' somewhere.
05:44:33 <quicksilver> oh, and 'return' somewhere.
05:44:35 <rgr> Why does the expression "true && 1" give "No instance for (Num Bool)" whereas "true && 'a'" gives "Couldn't match expected type `Bool' against inferred type `Char'" ?
05:44:36 <quicksilver> what a mess.
05:44:47 <quicksilver> rgr: because '1' is polymorphic.
05:44:58 <quicksilver> rgr: '1' has the type "Num a => a"
05:45:10 <quicksilver> so it searches for a posible Num instance which contains True
05:45:20 <quicksilver> i.e. it searches for an instance Num Bool
05:45:35 <quicksilver> whereas 'a' is monomorphic and you get the simpler error message
05:45:52 <rgr> gives me something to chew on. thanks.
05:46:21 <blackh> quicksilver: I will have to try again at some point to get the MaybeT of my dreams that will allow me to simply chain Maybe-returning monadic functions.
05:46:30 <rgr> I need to re-read types section in RWH since Num a => a is eluding me again...
05:47:45 <quicksilver> blackh: been there, done that ;)
05:48:11 <quicksilver> I sometimes define "orElse :: m (Maybe a) -> m (Maybe a) -> m (Maybe a)"
05:48:23 <quicksilver> that would be `mplus` for a suitably defined MaybeT
05:48:30 <quicksilver> (with a scattering of runMaybeT too)
05:48:55 <SamB_XP> and MaybeT, yes ?
05:49:04 <Axman6> is that the same as the STM orElse?
05:49:12 <SamB_XP> of course not
05:49:21 <quicksilver> SamB_XP: yup.
05:49:24 <SamB_XP> STM orElse is nondeterministic ;-P
05:49:40 <Axman6> you're non-deterministic
05:49:40 <quicksilver> Axman6: it's a similar idea, though
05:49:48 <quicksilver> (keep trying until one computation succeeds)
05:49:51 <quicksilver> just a deterministic cousin.
05:50:15 <Axman6> yeah seems like it could be polymorphic
05:50:44 <quicksilver> the polymorphic version is `mplus`
05:50:53 <quicksilver> this is mplus for the 'or-else-style' MonadPlusses
05:51:32 <blackh> quicksilver: What is it about this language, eh? That sounds good, but I'm after the Maybe monad behaviour: Keep trying until one fails
05:51:50 <quicksilver> that would just be (>>)
05:51:53 <quicksilver> in MaybeT
05:52:24 <SamB_XP> or >>=
05:53:39 <Axman6> @src liftM
05:53:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:53:44 <Axman6> @src liftM2
05:53:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:53:52 <Axman6> @src liftM3
05:53:53 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
05:54:08 <Axman6> hmm, thought there was a way to define those in terms of each other
05:54:58 <mbz_> @src liftMn
05:54:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:55:58 <quicksilver> Axman6: there is
05:56:02 <quicksilver> Axman6: <$> and <*>
05:56:30 <quicksilver> "liftMn f x0 x1 ... xn" is f <$> x0 <*> x1 .... <*> xn"
05:56:31 <ski_> liftM3 f ma mb mc = return f `ap` ma `ap` mb `ap` mc
05:57:17 <quicksilver> yeah, as ski_ correctly points out, <$> and <*> have other names.
05:58:03 <ski_> (s/return f `ap`/f `liftM`/ is possible)
05:58:26 * blackh turns into a pumpkin.  Good night all.
05:59:21 * quicksilver wonders how pumpkin feels about that.
06:00:17 <Botje> haven't you noticed we don't ever see pumpkin and blackh at the same time?
06:02:50 <blathijs> In the ghc sources I see a lot of "let" expressions, that don't seem to have a corresponding "in" clause
06:02:53 <blathijs> How does that work?
06:03:13 <Axman6> let doesn't need an in a lot of the time
06:03:20 <ToRA|MSR> generally i guess they're of the form: do { let x = 3 ; let y = 4 ; ... }
06:03:25 <Axman6> they can be used like where clauses a lot
06:03:32 <Axman6> s/a lot/
06:03:58 <blathijs> ToRA|MSR: Yeah, they're indeed lets in a do block
06:04:06 <quicksilver> erm that's not very precise Axman6
06:04:13 <quicksilver> the in-less form of let is a special case for do blocks
06:04:23 <quicksilver> you can't do that anywhere else.
06:04:33 <ToRA|MSR> is this a difference of let statements vs let expressions?
06:04:35 <Axman6> ah, yes, my bad
06:04:44 <ToRA|MSR> do do blocks introduce that distinction?
06:04:45 <ski_> > [ () | let () = () ]
06:04:47 <lambdabot>   [()]
06:04:50 <quicksilver> if you think "statemnet" means "something in a do block" then yes
06:04:57 <quicksilver> that's exactly what it is.
06:05:07 <quicksilver> I think the haskell report uses "statement" in this sense.
06:06:01 <vixey> > case undefined of _ -> "test"
06:06:03 <lambdabot>   "test"
06:06:22 <blathijs> Is there any difference between do { let a = 1; let b = 2; } and do { let { let a = 1; b = 2 } } then?
06:06:42 <EvilTerran> the second isn't valid
06:06:52 <EvilTerran> the inner "let" is a let-expression rather than a let-statement
06:07:15 <vixey> http://www.alsonkemp.com/haskell/thinking-about-haskell-you-know-lazy-evaluation-you-just-dont-know-it/
06:07:25 <EvilTerran> actually, it's neither; i don't think two "let"s next to each other is ever valid
06:07:36 <ToRA|MSR> if you meant do { let { a = 1; b = 2 } ; ... } the only difference is that b is in scope in the rhs of a afaict
06:07:37 <vixey> or http://arbitrary-blog.com/more-misunderstood/crap.html
06:07:44 <quicksilver> there is no difference between do { let a = 1 ; let b = 2; } and do {let {a=1;b=2} }
06:07:48 <quicksilver> which is maybe what you meant?
06:08:42 <blathijs> ToRA|MSR: I meant that, yes
06:09:28 <blathijs> quicksilver: And that, indeed
06:09:28 <quicksilver> do { let x = 1; blah } is basically shorthand for do { let x = 1 in do blah; }
06:09:43 * ski_ averts quicksilver's eyes to the list comprehension above
06:09:50 <quicksilver> so it avoids indentation creep from repeated nestings of do/let
06:10:09 <quicksilver> ski_: well a list comprehension is a special case do block.
06:10:23 <ksf> vixey, the second link doesn't work
06:10:26 <blathijs> quicksilver: So that means to read this stuff, I just scroll down to the last non-let block and start there :-)
06:10:49 <quicksilver> you can read it as if it was imperative code if you like
06:10:58 <quicksilver> viewing "let x = 1" as "x := 1"
06:11:20 <quicksilver> it's not actually destructive assignment but nonetheless it reads in a similar way.
06:11:32 <quicksilver> the operational is different of course (lazily evaluated)
06:11:55 <ski_> > do { let a = 1 ; let b = 2; }
06:11:56 <lambdabot>   <no location info>: parse error on input `}'
06:12:01 <ski_> > do { let a = 1 ; let b = 2; return () }
06:12:03 <lambdabot>   <no location info>: parse error on input `}'
06:12:04 <osfameron> gah, trying to model overlapping things functionally is a right pita
06:12:22 <vixey> what "overlapping things"
06:12:28 <quicksilver> > do { let {a=1}; let {b=2}; return () }
06:12:29 <lambdabot>       No instance for (Show (t ()))
06:12:30 <lambdabot>        arising from a use of `show' at <i...
06:12:34 <osfameron> vixey: I was thinking about a crossword
06:12:41 <quicksilver> ski_: you get some odd effect with the overlapping layout blocks there.
06:12:49 <ski_> *nod*
06:12:54 <quicksilver> I'm not entirely sure why it can't infer the right thing without the extra {}
06:12:58 <vixey> as a function from Cell -> Content?
06:13:00 <ski_> `let' is greedy, there
06:13:02 <osfameron> the down clues and across clues contain the same cells, and the cells refer to the lights, and the lights to the cells
06:13:07 <blathijs> quicksilver: Yeah, so starting to read at the bottom is effectively lazy reading :-)
06:13:22 <quicksilver> ;)
06:13:22 <osfameron> vixey: I'm trying to write [[Char]] -> [[Cell]]
06:13:37 <vixey> [[_]] is a really horrid thing to use almost always.....
06:13:40 <vixey> I have found
06:13:44 <osfameron> well, tbh, right now I'm trying to do [Char] -> [Cell]
06:13:48 <vixey> except for gauss elimination it was ok
06:13:50 <osfameron> that's relatively easy
06:14:12 <osfameron> apart from the tying the know of Cell's referring to Lights and vice versa
06:14:16 <osfameron> *knot
06:14:21 <vixey> a type like Coordinate = (Integer,Integer), then Coordinate -> Cell wouldn't be easier?
06:14:29 <osfameron> but I can't even imagine how it works when you're also working Down
06:14:59 <osfameron> vixey: I've got as far as http://hpaste.org/13122
06:15:31 <osfameron> I believe step 3 is Profit!!!
06:15:33 <SamB_XP> crosswords have lights now ?
06:15:39 <vixey> ok yeah that doesn't make sense
06:15:43 <osfameron> but I'm a little confused in between
06:15:46 <quicksilver> ski_: my reading of the layout rule is that the second "let" is an invalid lexeme in the context of the first let's layout block, so a } should be inserted.
06:15:51 <quicksilver> ski_: is this a bug in GHC therefore?
06:15:56 <SamB_XP> osfameron: it's usually that way !
06:16:01 <osfameron> SamB_XP: "lights" are collections of non-blocked cells, like 2 across
06:16:12 <SamB_XP> if step 3 is profit!, step 2 is usually ...
06:16:17 <SamB_XP> or ???
06:16:23 <BONUS> hmm
06:16:36 <ski_> quicksilver : dunno ..
06:16:37 <BONUS> with the new haskell logo, whats the situation with non free fonts
06:16:40 <BONUS> is it ok to use them or what
06:16:49 <osfameron> tbh, it's probably easier to do it in multiple passes
06:16:51 <quicksilver> depends on the license of the font, I guess, BONUS
06:16:58 <vixey> I though it was ok to use rasterized bitmaps of them but not vector versions...
06:17:06 <quicksilver> haskell has no debian-like commitment to absolute freedom of everything
06:17:08 <vixey> don't quote me on it though
06:17:15 <SamB_XP> vixey: in the US, yeah
06:17:20 <quicksilver> but if the license doesn't permit us to use it on webpages and T-shirts that's probably a bit useless.
06:17:22 <ski_> (quicksilver : incidentally, i get an error in HuGS, too)
06:17:23 <SamB_XP> dunno about everywhere else
06:17:44 <purple_> is it possible to enter a data type definition into the ghci interpreter ie --> data Bird = Bird { name :: String, wings :: Integer }
06:17:54 <vixey> purple_, no
06:17:57 <SamB_XP> font outlines are not copywriteable in the US
06:18:07 <purple_> needs to be in file - thanks vixey
06:18:12 <vixey> purple_, when is wings not 2??
06:18:12 <SamB_XP> only specific computer descriptions of them are
06:18:32 <Zao> vixey: Dragonflies?
06:18:39 <Zao> Albeit not birds :P
06:18:41 <purple_> vixey_ good point
06:18:57 <ToRA|MSR> he could be doing data modelling for a bird sanctuary?
06:18:58 <SamB_XP> when it's 0 ?
06:19:09 <SamB_XP> (don't some birds have no wings ? )
06:19:19 <Zao> vixey: let bucket = Bird "Chicken" 24
06:19:25 <SamB_XP> lol
06:19:30 <quicksilver> ;)
06:19:50 <SamB_XP> how abotu
06:19:58 <purple_> dont some supermarkets sell 3 winged chickens ?
06:20:16 <vixey> and do they mark them GM?
06:20:17 <SamB_XP> let bwings = Bird "Buffalo" 48
06:20:37 <SamB_XP> vixey: GM?
06:21:21 <purple_> is it possible to map over a record and change the record values to a list of Maybe's - eg for pretty printing
06:21:36 <vixey> no
06:21:40 <purple_> or serialization or do i have to write something like this
06:21:48 <ski_> purple_ : what would the list type be for your `Bird' type ?
06:22:04 <purple_> something like [ Maybe, Maybe ]
06:22:21 <ski_> that's not valid type syntax
06:22:22 <purple_> or( string, Maybe) tuples
06:22:39 <purple_> [ ( string, Maybe) ]
06:22:54 <SamB_XP> dunno what you want to do
06:23:02 <ski_> @kind [ ( String, Maybe) ]
06:23:02 <vixey> I do
06:23:03 <lambdabot>     `Maybe' is not applied to enough type arguments
06:23:03 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
06:23:03 <lambdabot>     In the type `(String, Maybe)'
06:23:30 <purple_> sorry i am only learning haskell - i am thinking of something like a visitor pattern  - or double dispatch in OO
06:23:48 <vixey> puple_, don't do that in haskell :P
06:23:54 <purple_> yes i know
06:24:19 <quicksilver> purple_: Functor is a bit like the visitor pattern.
06:24:19 <ski_> what are you trying to do ?
06:24:26 <quicksilver> Traversable is very like it
06:24:34 <quicksilver> as ski says, it depends what you're trying to do.
06:25:12 <quicksilver> (Functor is like a visitor pattern without carrying global state, Traversable is like a visitor which can thread state through a monad/applicative)
06:26:28 <purple_> to have a function that takes my record and another hof  which would get passed the record value as Maybe types
06:26:38 <purple_> sorry its difficult to articulate
06:27:09 <purple_> i will investigate Traverable
06:28:28 <PeakerWork> I wonder how hard it would be to put a decent memory eviction scheme that prevent thrashing/DoS into the Linux kernel
06:28:42 <quicksilver> traversing a record isn't something you get for free
06:28:51 <quicksilver> you can build stuff with SYB / Data though
06:28:56 <quicksilver> (and other people already have)
06:29:03 <SamB_XP> PeakerWork: don't you think they've been trying ?
06:29:13 <PeakerWork> SamB_XP: I think they probably suck :-)
06:29:48 <pejo> Peaker, there's a thesis about the memory management system in NetBSD, which should provide a good intro to the subject.
06:30:06 <PeakerWork> SamB_XP: I don't believe in the competence of Linux programmers (and most programmers in the world in general)
06:30:28 <PeakerWork> pejo: Does NetBSD not have the Linux/Windows/OSX problem of memory thrashing killing all usability of _everything_?
06:30:55 <BONUS> thinking of submitting this http://www.vulomedia.com/images/21912haskell.png
06:31:03 <PeakerWork> I have a rather simple (At least it seems simple, before implementing it) idea that might make memory management a bit more CPU intensive, but will not allow memory thrashing to be a problem
06:31:54 <SamB_XP> PeakerWork: is that because it uses so much CPU that the memory will thrash back in as fast as it can be used?
06:31:59 <quicksilver> BONUS: the kerning is nasty ;)
06:32:15 <Axman6> ha! frak yes! the people i ordered RWH from are giving me a $10 credit for them not having it on time, and sending it to someone else who ordered after i did (ivanm)
06:32:28 <BONUS> hmmmm
06:32:57 <SamB_XP> Axman6: he also got listed twice in the thanks list ;-P
06:33:08 <BONUS> yeah i added some more spacing between the letters
06:33:14 <Axman6> what? :O
06:33:20 <BONUS> so it doesnt look too heavy
06:33:30 <PeakerWork> SamB_XP: The idea is to have processes hold "memory credit" that they automatically dispense on their MFU/MRU pages, and then evict pages which accumulated less credit.. So small and high-credit processes have a serious advantage (i.e: my bash will never be swapped out)
06:33:44 <BONUS> but the general idea still holds, just Haskell with a lambda instead of the a
06:34:14 <cjs> PeakerWork: it had that at one point, a long time ago.
06:34:23 <PeakerWork> cjs: Linux had it?
06:34:38 <pejo> Peaker, that can't be a new idea, it's quite similar to how interactive processes were handled eons ago.
06:34:39 <cjs> NetBSD. It had that problem.
06:34:40 <PeakerWork> cjs: Why would anyone prefer the current terrible situation over that?
06:34:49 <PeakerWork> cjs: oh
06:35:14 <PeakerWork> pejo: well, good old ideas died out, and we have Linux/Windows now, instead
06:35:17 <cjs> It's better now, though of course if you sufficiently drive enough stuff out into swap, you're going to thrash regardless. The problem is really that you run out of disk I/O,
06:35:47 <cjs> So your shell might be running just fine, but an 'ls' still takes forever.
06:36:18 <SamB_XP> cjs: what kind of idiot lses my home directory?
06:36:49 <Axman6> http://haskell.org/haskellwiki/Image:NarleyYeeaaahh.jpg best one so far >_>
06:37:15 <PeakerWork> cjs: well, then credits don't only get assigned to processes, but to various segments of the file system as memory credits for caching it
06:38:15 <PeakerWork> cjs: The Linux distro can define "applications" and priorities (probably each "package" can be an application) and then evicting cache pages of "ls" should be only after you evict pages of less important programs
06:38:55 <SamB_XP> PeakerWork: I think he was talking about the time to read the directory ?
06:39:00 <pejo> Peaker, so you just invented manual priorities.
06:40:08 <cjs> It's not the cache pages of ls that are the problem, it's the inodes and data you need to read in order to produce the result. They're not associated with any particular program.
06:40:10 <PeakerWork> SamB_XP: Well, the home directory can be cached by more credit than the swap of the thrasher
06:40:29 <PeakerWork> cjs: they can still be assigned memory credit to be cached, though
06:40:39 <cjs> BTW, this does seem a bit of a #haskell-overflow conversation. (I'm there.)
06:41:40 <SamB_XP> don't you mean -blah ?
06:42:06 <PeakerWork> The division is probably superfluous :)
06:48:46 <solrize> http://www.newegg.com/Product/Product.aspx?Item=N82E16820167005  price of this thing just fell for abount the 7th time in 2 weeks
06:48:53 <solrize> in 5-10 dollar increments though
06:48:58 <solrize> abount->about
06:50:35 <jot> ~~
06:51:11 <quicksilver> ##
06:52:04 <rgr> vocab question : in the following expression why is 'a' the inferred type `char? "true && 'a'". It is not "inferred" is it? It is quite explicit.
06:52:38 <BeelsebobWork> rgr: a type is infered exactly when you don't tell Haskell what it is
06:52:42 <quicksilver> rgr: well infer is a verb, not a property.
06:52:48 <BeelsebobWork> so the type of 'a' is inferred to be Char
06:52:51 <EvilTerran> rgr, sure, there's no inference steps, but it's still inferred
06:52:51 <quicksilver> rgr: it is inferred by your haskell compiler
06:53:01 <BeelsebobWork> however the type of 'a' :: Char is not infered -- it's explicitly known
06:53:02 <quicksilver> it's a particularly simple inference in this case.
06:53:19 <quicksilver> BeelsebobWork: in practice it's still inferred, and then checked against the type you gave.
06:53:26 <BeelsebobWork> true true
06:53:30 <quicksilver> (in terms of the way haskell compilers operate)
06:53:33 <quicksilver> > () :: Char
06:53:35 <lambdabot>   Couldn't match expected type `Char' against inferred type `()'
06:53:36 <rgr> uh oh ...
06:53:54 <quicksilver> rgr: so, it "inferred" () from the term ()
06:53:59 <BeelsebobWork> the difference between type inference and type checking is fairly subtle
06:54:03 <quicksilver> and then it "expected" Char, cos that's what I told it.
06:54:15 <quicksilver> and then it blew up, because it knew Char /= ()
06:54:19 <BeelsebobWork> type checking only needs to prove that what you told it the types were are in fact one possible solution to the typing equation
06:54:29 <BeelsebobWork> type inference must find the most general solution to the typing equation
06:54:33 <rgr> The only good thing that came out of that is I bet other people get confused easily too :-; You guys know your stuff, but phew, it aint easy.
06:54:46 <quicksilver> sure, there is a lot of unfamiliar vocab.
06:54:52 <quicksilver> and ghc has some pretty confusing error messages.
06:54:57 <quicksilver> not for want of trying, though :(
06:55:16 <rgr> ghc error messages confuse the hell out of me.
06:55:28 <EvilTerran> rgr, basically, the "inferred" type is the type the compiler worked out for the expression
06:55:38 <rgr> I know that one day the light will click on and it will all be second nature :-;
06:55:51 <EvilTerran> and the "expected" type is the type the compiler worked out must go in the "hole" where the expression is from looking at the stuff around it
06:56:12 <BeelsebobWork> rgr: be warned -- when the light turns on you'll discover you're in a room with 4 other dark rooms adjacent to it
06:56:13 <vixey> rgr, you know first order unification?
06:56:21 <vixey> lol
06:56:24 <EvilTerran> sometimes, inference is just a case of "this is a character constant - it must be type Char!"
06:56:52 <rgr> lol! TBH I know that from lurking here and seeing a few smart people pulled up short when they realised their knowledge wasn't as broad as they thought.
06:57:27 <chrisdone> aw man, I'm getting such a weird error
06:57:41 <chrisdone> I'm reading a value from a string, when I just print it out with `show`, it's fine
06:57:46 <pejo> rgr, there's always someone here who can point you to more documentation though.
06:57:48 <chrisdone> but when I compare it to something I get a Prelude.read error
06:58:02 <rgr> slightly OT : does anyone know if a permanent fix is coming for the problems with ghci 6.10.1 with emacs integration? Ikeep getting ^J where there used to be a newline.
06:58:32 <chrisdone> showCat :: Integer -> (String,(String,Integer)) -> Store Html
06:58:32 <chrisdone> showCat bid (mode,(name,id)) = do
06:58:32 <chrisdone>   brandId <- readParam "brand-id" :: Store (Maybe Integer)
06:58:32 <chrisdone>   let this = brandId == Just bid    -- this line causes a `Prelude.read no parse' error
06:58:52 <pejo> rgr, there was a thread on ghc-users mailing list about that problem, I think Conal asked about it.
06:59:17 <quicksilver> chrisdone: what's readParam?
06:59:22 <quicksilver> (I bet it calls read internall)
06:59:29 <chrisdone> quicksilver: thats' right
06:59:41 <quicksilver> well your erro is coming from that
07:00:00 <quicksilver> and you don't notice it until you compare with ==
07:00:01 <chrisdone> getParam name = lookup name <$> gets storeParams; readParam = fmap (>>= read) . getParam
07:00:05 <chrisdone> indeed
07:00:05 <quicksilver> because of lazy evaluation.
07:00:10 <chrisdone> hmm
07:00:15 <quicksilver> well, that read is failing.
07:00:25 <chrisdone> yeah
07:00:49 <quicksilver> you should never use 'read' unless you know 100% it cannot fail
07:00:52 <rgr> pejo : i have that solution - basically alias ghci to "cat | ghci" for whatever reason.
07:00:59 <quicksilver> because it has no failure-recovery
07:01:07 <rgr> (terms in general give me the heebie jeebies)
07:01:12 <quicksilver> you should use reads instead, or something based on it.
07:01:24 <quicksilver> rgr,pejo: presumably it's editline brokenness?
07:01:43 <pejo> quicksilver, it was introduced since the switch to editline I think, yeah.
07:01:49 <rgr> I picked that up from lots of text I didnt understand. libedit0 related? haskell-line? something like that.
07:02:16 <chrisdone> quicksilver: it shouldn't fail because I've validated it with a regexp before hand ([0-9]+). I'll use reads, but I guess that's not my problem anyway. it's this laziness
07:03:17 <jotun> oh, this seems like a real nice channel, yay :)
07:04:06 <PeakerWork> EvilTerran: hey, is the _ type wildcard proposal anywhere?
07:04:07 <quicksilver> chrisdone: no, the laziness is not your problem.
07:04:25 <quicksilver> chrisdone: the laziness is just making it harder to see where the problem is.
07:04:34 <quicksilver> chrisdone: the problem is that that is not being correctly read.
07:04:39 <chrisdone> quicksilver: that's what I meant
07:04:42 <EvilTerran> PeakerWork, not that i know of; only if someone else thought of it independently to me (which seems quite likely, really)
07:04:59 <PeakerWork> EvilTerran: It would be a shame to wait for Haskell'' if that's ignored
07:05:03 <EvilTerran> true
07:05:05 <quicksilver> chrisdone: what's the type of readParam?
07:05:07 <PeakerWork> EvilTerran: Maybe you should suggest it to Haskell-cafe?
07:05:23 <EvilTerran> i'll put it on my list of things to do when i have Copious Free Time :P
07:05:36 <chrisdone> quicksilver: readParam :: Read a => String -> Store (Maybe a)
07:06:52 <PeakerWork> EvilTerran: If I write it to Haskell-cafe, what's your name so I can credit it to you?
07:07:34 <quicksilver> chrisdone: it surely must be that the string stored is not of the form [0-9]+ after all.
07:07:43 <quicksilver> chrisdone: I can't think of any other situation.
07:08:34 <chrisdone> quicksilver: hmm. maybe there's a space or something inside the string that I don't see when displaying it in HTML. let me see..
07:09:43 <EvilTerran> PeakerWork, thanks, that'd save me having to be organised *or* articulate; I'm Martin Foster
07:10:01 <EvilTerran> :)
07:12:54 <solrize> hey, does java have a fix for the "covariant hole" these days?
07:14:52 <chrisdone> quicksilver: when I `show` the parameter list I get [("brand-id","27")]
07:15:00 <chrisdone> quicksilver: which is why I'm so confused. I'll investigate more..
07:15:36 * Axman6 attempts to submit his first go at a haskell logo
07:16:59 <RayNbow> solrize: "covariant hole"?
07:17:06 <RayNbow> do you mean the odd arrays?
07:17:48 <solrize> raynbow, it goes: Dog[] dogs = new Dog[10];
07:17:48 <solrize> Mammal[] mammals = dogs;
07:17:48 <solrize> mammals[0] = new Cat();
07:18:11 <solrize> that passes the old fashion java type checker but is a type error caught at runtime
07:18:41 <EvilTerran> because the typechecker seemed to think that (A <: B) => (A[] <: B[])
07:18:43 <opqdonut> it's fixed iirc
07:19:29 <EvilTerran> which would be true... except arrays are mutable
07:19:31 <solrize> yeah it's still possible to write that code, but i think there's some way to program around it?
07:19:43 <solrize> something like c++ templates
07:20:39 <quicksilver> I think "Mammal[] mammals = dogs;" is now illegal.
07:20:45 <solrize> oh interesting
07:20:54 <solrize> that would break a ton of old code
07:21:22 <quicksilver> hmm.
07:21:27 <quicksilver> maybe it's not that part that's illegal.
07:21:43 <quicksilver> yes, I think it is.
07:21:44 <chrisdone> oh...
07:21:45 <PeakerWork> what language is that?
07:21:48 <quicksilver> java.
07:21:55 <quicksilver> you can copy the dogs one by one in a mammals array
07:22:00 <quicksilver> but you can't just assign the array, IIRC>
07:22:06 <rgr> Any emacs users : hayoo working from emacs complete with xmonad and xmc bet
07:22:07 <rgr> (define-key haskell-mode-map (kbd "<f3>") (lambda()(interactive)(browse-url (format "http://holumbus.fh-wedel.de/hayoo/results/hayoo.html?query=%s&start" (region-or-word-at-point)))))
07:24:12 <Axman6> what do you guys think of the logo i just submitted? http://haskell.org/haskellwiki/Image:Axman6-logo-1.0.png
07:24:39 <chrisdone> personally I think the shadows are a bit 90
07:24:42 <chrisdone> 90's
07:24:59 <Axman6> yeah they don't quite work right
07:25:28 <vixey> it looks like an americal political party logo :p
07:25:33 <quicksilver> add some disco lights
07:25:39 <chrisdone> yeah
07:25:40 <quicksilver> the 80s was so much better than the 90s
07:25:44 <chrisdone> Vote Haskell the Dog
07:25:48 <chrisdone> haha
07:26:08 <quicksilver> Axman6: I don't think the => -> really work.
07:26:08 <Kerris7> one of the characters in the last Cube movie is named Haskell :V
07:26:31 <quicksilver> Axman6: other than that I quite like it.
07:27:20 <chrisdone> quicksilver: ah. `read' is working now...
07:27:31 <quicksilver> chrisdone: woot. What was wrong?
07:27:32 * chrisdone facepalms himself
07:28:11 <chrisdone> quicksilver: the return type is Store (Maybe a), but in my code I was returning (read (n :: String)), instead of (Just (read (n :: String)) (annotations added for clarity)
07:28:22 <chrisdone> of course, the compiler saw returning the former as just fine and I didn't notice
07:28:29 <quicksilver> hah!
07:28:36 <chrisdone> so it was trying to read "Just 27", heh
07:28:40 <quicksilver> maybe a better read combinator.
07:28:48 <chrisdone> yeah
07:29:15 <quicksilver> readMaybe s = case reads s of (x,ss) | all isSpace ss -> Just x | otherwise -> Nothing
07:29:18 <quicksilver> is not bad.
07:29:33 <RayNbow> solrize: sorry, I was afk for a bit... but yeah, Java's arrays are odd :p
07:29:55 <quicksilver> readEither s = case reads s of (x,ss) | all isSpace ss -> Right x | otherwise -> Left ("readEither failed with string ["++s++"]")
07:29:56 <chrisdone> quicksilver: hmm, good one. that's "white space is okay after the value"?
07:30:02 <quicksilver> is slightly better.
07:30:11 <quicksilver> chrisdone: well that's the way 'read' behaves.
07:30:21 <quicksilver> may or may not be important.
07:30:23 <chrisdone> right
07:30:27 <quicksilver> I'm missing [] around [(x,ss)]
07:30:54 <quicksilver> and I meant _ instead of |otherwise
07:30:55 <quicksilver> damnit
07:30:57 <chrisdone> haha
07:31:16 <quicksilver> readMaybe s = case reads s of [(x,ss)] | all isSpace ss -> Just x ; _ -> Nothing
07:31:23 <blueonyx> but the | works in case..of?
07:31:31 <quicksilver> blueonyx: it does indeed.
07:31:36 <blueonyx> nice to know
07:31:40 <chrisdone> blueonyx: this is your brain on haskell
07:31:42 <quicksilver> > case 1 of 1 | 4 == 4 -> "hi"
07:31:43 <lambdabot>   "hi"
07:32:02 <blueonyx> O.o
07:33:15 <blueonyx> > case 1 of 1 | 4 == 3 -> "hi" | 2==2 -> "buh"
07:33:17 <lambdabot>   "buh"
07:33:20 <chrisdone> quicksilver: aye, I'll use Either
07:33:48 <EvilTerran> ?src otherwise
07:33:49 <lambdabot> otherwise = True
07:34:48 <blueonyx> :)
07:35:34 <Axman6> something which i saw recently which confused me was using ghards and patern matching like f Nothing = "Hi"; f (Just x) | even x = "EVEN!"; f x | 1 > 2 = "Wut?"; f x = "hmm"
07:35:52 <Axman6> never knew guards could be used like that
07:36:13 <chrisdone> 
07:36:20 <Axman6> not confused really, just found it odd
07:36:21 <quicksilver> Axman6: what else would you use them for?
07:36:25 <BeelsebobWork> Axman6: a case is just an unnamed function
07:36:42 <BeelsebobWork> (and an application too in one)
07:36:57 <Axman6> quicksilver: well ormally i'd use them like f x | g x = a | h x = b | otherwise = c
07:37:19 <quicksilver> Axman6: you mean you didn't know about several equations with several guards each?
07:37:31 * quicksilver nods
07:37:39 <quicksilver> that's quite critical really
07:37:44 <quicksilver> otherwise you could just use "if"
07:38:08 <quicksilver> the exciting things about guards is they restart pattern matching at the next equation, if the all fail
07:38:12 <Axman6> i mean i didn't know about several equations with single guards, that can not be used (struggling to think ogf how to phrase this...)
07:38:28 <BeelsebobWork> quicksilver: ohhhh! now that I didn't know
07:38:28 <Axman6> quicksilver: yeah, that's the bit i didn't know about :)
07:38:39 <Axman6> which is awesome
07:39:23 <BeelsebobWork> quicksilver: so f (Just x) = case x of _ | (Jam 5) -> "jam"; f x = "ham" will produce "ham" if I give it Just (Ham 5)?
07:39:51 <quicksilver> well no, not if guard is inside a nested case.
07:39:58 <BeelsebobWork> aww :(
07:40:00 <quicksilver> but if the guard is at the definition level then yes.
07:40:08 <BeelsebobWork> ah yeh, I knew that
07:40:20 <Axman6> don't guards have to be used with bools?
07:40:35 <quicksilver> yes.
07:40:50 <BeelsebobWork> :t otherwise
07:40:51 <lambdabot> Bool
07:40:54 <Axman6> so does '| (Jam 5)' make sense?
07:40:56 <BeelsebobWork> > otherwise
07:40:57 <lambdabot>   True
07:41:11 <BeelsebobWork> Axman6: oh, yeh
07:41:12 <BeelsebobWork> woops
07:41:17 <Axman6> :)
07:41:27 <seanos_s> Hi, anyone know where I can find the solution to 4.12 from "Yet another Haskell tutorial" please?
07:41:36 <Axman6> i was getting confused, wondiring if there was some weird case guard syntax...
07:42:04 <quicksilver> there is somethiing called PatternGuards
07:42:09 <quicksilver> which work somewhat like what BeelsebobWork wrote.
07:43:11 <BeelsebobWork> seanos_s: I can give you a hint -- map' :: (a -> b) -> ([a] -> [b]) -> [a] -> [b]
07:43:20 * BeelsebobWork hopes he's thinking along the right lines
07:43:32 <Axman6> @where yaht
07:43:33 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:44:55 <seanos_s> BeelsebobWork: thanks
07:51:04 <blathijs> It seems darcsweb at darcs.haskell.org is broken, anyone else seeing this?
07:51:54 <orbitz> what is a MonadPlus?
07:52:38 <Axman6> @src MonadPlus
07:52:38 <lambdabot> Source not found. Take a stress pill and think things over.
07:52:43 <PeakerWork> orbitz: its a Monad m that defines a Monoid for any (m a) as well as being a monad, with some laws about the interaction between the monoid and monad laws
07:52:58 <PeakerWork> s/monoid and monad laws/monoid and monad operations
07:53:13 <orbitz> what sort of laws?  I believe i saw it used in 'guard', is that correcT?
07:53:47 <PeakerWork> orbitz: I don't recall the MonadPlus laws. I think     mzero >>= _  === mzero   is one of them, I am not sure
07:55:16 <orbitz> PeakerWork: so i guess my question is more alogn teh liens of:  [1..10] >>= \x -> guard (even x) >> return x, how does hat return x only happenf or teh evens?
07:55:51 <PeakerWork> @src guard
07:55:52 <lambdabot> guard True  =  return ()
07:55:52 <lambdabot> guard False =  mzero
07:56:12 <PeakerWork> orbitz: I guess mzero >> _ == mzero because of the above
07:56:20 <PeakerWork> > mzero :: []
07:56:21 <lambdabot>       `[]' is not applied to enough type arguments
07:56:21 <lambdabot>      Expected kind `?', bu...
07:56:26 <PeakerWork> > mzero :: [Int]
07:56:27 <lambdabot>   []
07:56:34 <orbitz> PeakerWork: so that goes to the fail path?
07:57:43 <Axman6> @src Maybe mzero
07:57:43 <lambdabot> mzero = Nothing
07:58:00 <maltem> @src [] mzero
07:58:00 <lambdabot> mzero = []
07:58:08 <Axman6> @src Either mzero
07:58:09 <lambdabot> mzero            = Left noMsg
07:58:21 <Axman6> > noMsg
07:58:22 <lambdabot>   Add a type signature
07:58:26 <Axman6> > noMsg :: String
07:58:28 <lambdabot>   ""
07:58:39 <Axman6> :t noMsg
07:58:40 <lambdabot> forall a. (Error a) => a
07:58:46 <EvilTerran> ?instances Error
07:58:47 <lambdabot> IOError, String
07:59:44 <maltem> blathijs: Has there ever been a darcsweb at darcs.haskell.org?
08:00:11 <orbitz> does lambda bot have soemthig nso i can ee teh full lambda version of a monad?
08:00:29 <PeakerWork> orbitz: well, guard False = mzero = fail = []   so it explains why the computation "stops" there
08:01:19 <maltem> orbitz: "full lambda version of a monad"?? Do you mean @undo?
08:01:34 <blathijs> maltem: /usr/lib/hugs/packages/hugsbase/Hugs/Internals.hs
08:01:37 <blathijs> argh
08:01:43 <orbitz> maltem: even wihotu the >>='s and >>
08:01:44 <blathijs> maltem: http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=hugs98;a=summary <-- There
08:02:29 <maltem> blathijs: oh so it has :) well use http://darcs.haskell.org/darcsweb/darcsweb.cgi then
08:02:41 <maltem> blathijs: ah wait I see
08:02:54 <blathijs> :-)
08:02:55 <maltem> blathijs: yeah looks like it's broken :(
08:03:30 <ski_> @wiki MonadPlus
08:03:30 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
08:03:31 <ski_> @wiki MonadPlus_reform_proposal
08:03:31 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
08:03:45 <ski_> orbitz : ^
08:03:53 <blathijs> maltem: Any clue who to nudge about this?
08:04:00 <orbitz> PeakerWork: so if i were to write that out, from the guard it's really doing soething like guard (even x) >>= \(_:_) -> return x; _ -> ... ?
08:04:04 <orbitz> ski_: thanks
08:04:36 <EvilTerran> ?undo do x <- [1..10]; guard (even x); return x
08:04:36 <lambdabot> [1 .. 10] >>= \ x -> guard (even x) >> return x
08:04:53 <PeakerWork> @pl [1 .. 10] >>= \ x -> guard (even x) >> return x
08:04:53 <lambdabot> ap ((>>) . guard . even) return =<< [1..10]
08:04:57 <maltem> orbitz: ok I think lambdabot doesn't have such a thing
08:05:08 <orbitz> maltem: ok, probably not very sueful anyways
08:05:49 * orbitz is trying to understand monad flow in this situation
08:06:01 <PeakerWork> orbitz: >>= (const [])  will always result in an empty list . >>= (sometimes empty, sometimes not) will result with only those non-empty cases
08:06:53 <vixey> http://semantic.org/HBase/HBase/HBase/HBase/ wow
08:07:18 <maltem> blathijs: according to the wiki, darcs.haskell.org is run by Galois, so maybe dons would be a good address
08:07:31 <orbitz> >[] >>= return
08:07:34 <orbitz> > [] >>= return
08:07:36 <lambdabot>   []
08:07:42 <vixey> http://semantic.org/hnop/nop/Control/Nop.hs
08:08:08 <Axman6> > sequense [[1..3],[4..6]]
08:08:10 <lambdabot>   Not in scope: `sequense'
08:08:14 <Axman6> > sequence [[1..3],[4..6]]
08:08:15 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
08:09:11 <orbitz> where is the Monad [] instance defined?
08:09:12 <Axman6> > sequence [[1,2],[3,4],[5,6]]
08:09:13 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
08:09:27 <cjs> Ok, my brain is melting down after too much FFI, though I'll admit at least I've not had to write any C yet. But I've got this "handle" thing which sometimes isn't, and instead I need to return TRUE or FALSE. The latter is easy, nullHANDLE (if you're using System.Win32) or just nullPtr. But for the other?
08:09:36 <blathijs> dons: It seems the darcsweb at darcs.haskell.org is broken, and apparently you might be able to solve that (or point me in the right direction at least). See for example http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=hugs98;a=summary
08:09:43 <cjs> Oh, in this Win32 world, "type   HANDLE      = Ptr ()"
08:10:22 <andyjgill> Hey, I've been looking for the web page that lets me type in a Haskell type, and get the free theorem. Can anyone remember where it was? I used it about 6 months ago.
08:11:05 <maltem> @free reverse
08:11:06 <vixey> you can do it in lambdabot if you don't find the page
08:11:06 <lambdabot> $map f . reverse = reverse . $map f
08:11:12 <vixey> there's the whole haskell source codetoo
08:11:40 <Axman6> @free reverse.reverse
08:11:40 <lambdabot> Extra stuff at end of line
08:11:49 <Axman6> @free reverse . reverse
08:11:50 <lambdabot> Extra stuff at end of line
08:11:52 <Axman6> bah
08:12:00 <Axman6> @free (>>=)
08:12:00 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
08:12:04 <vixey> :t reverse . reverse
08:12:05 <lambdabot> forall a. [a] -> [a]
08:12:13 <vixey> @free reverse_dot_reverse :: forall a. [a] -> [a]
08:12:14 <lambdabot> $map f . reverse_dot_reverse = reverse_dot_reverse . $map f
08:12:16 <Olathe> @free id
08:12:17 <lambdabot> f . id = id . f
08:12:36 <Axman6> @free (+)
08:12:36 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
08:12:49 <vixey> ^ well typed programs don't go wrong
08:13:18 <Olathe> @free flip id
08:13:18 <lambdabot> Extra stuff at end of line
08:13:36 <vixey> :t flip id
08:13:37 <lambdabot> forall b c. b -> (b -> c) -> c
08:13:42 <vixey> @free flip_id :: forall b c. b -> (b -> c) -> c
08:13:43 <lambdabot> g . h = k . f => g (flip_id x h) = flip_id (f x) k
08:13:55 <pejo> andyjgill, it's probably linked somewhere from Janis Voigtlnder's homepage. He's been doing free theorems stuff and have had some implementations.
08:14:00 <Olathe> @type id
08:14:01 <lambdabot> forall a. a -> a
08:14:14 <Olathe> @free kaboom :: forall a. a -> a
08:14:15 <lambdabot> f . kaboom = kaboom . f
08:14:54 <Olathe> @free kaboom :: forall a. a -> a -> a
08:14:55 <lambdabot> f . kaboom x = kaboom (f x) . f
08:15:55 <Olathe> @free kaboom :: forall a. a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a
08:15:56 <lambdabot> f . kaboom x y z u v a b c s = kaboom (f x) (f y) (f z) (f u) (f v) (f a) (f b) (f c) (f s) . f
08:16:48 <vixey> @free fix
08:16:49 <lambdabot> f . g = h . f => f (fix g) = fix h
08:16:56 <vixey> @free foldr
08:16:57 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
08:18:42 <andyjgill> Thanks pejo, but I looked there first, and could not find it.
08:19:40 <andyjgill> Found it: http://linux.tcs.inf.tu-dresden.de/~voigt/ft/
08:21:29 <ToRA|MSR> @src () Show
08:21:29 <lambdabot> Source not found. I feel much better now.
08:22:29 <EvilTerran> ?src () show
08:22:29 <lambdabot> Source not found. Wrong!  You cheating scum!
08:22:33 <EvilTerran> hm
08:22:38 <EvilTerran> show () = "()"
08:22:42 <EvilTerran> :P
08:22:59 <orbitz> > show ()
08:23:00 <lambdabot>   "()"
08:23:05 <orbitz> tricky
08:23:11 <ToRA|MSR> just checking it really is strict in the ()
08:23:15 <orbitz> > show ("hi", 1)
08:23:17 <lambdabot>   "(\"hi\",1)"
08:23:20 <ToRA|MSR> > show (undefined :: ())
08:23:21 <lambdabot>   "* Exception: Prelude.undefined
08:23:22 <vixey> > show (undefined :: ())
08:23:23 <lambdabot>   "* Exception: Prelude.undefined
08:23:24 <EvilTerran> actually, it's "data  () = () deriving (Eq, Ord, Bounded, Enum, Read, Show)"
08:23:32 <EvilTerran> according to the report
08:23:32 <orbitz> > show (1, 2 3, 4, 5, 6 7, 8, 9, 10, 11)
08:23:34 <lambdabot>       No instance for (Num (t -> t2))
08:23:34 <lambdabot>        arising from the literal `2' at ...
08:25:06 <Olathe> > show (1, 2, 3, 4, 5, 6 7, 8, 9, 10, 11)
08:25:08 <lambdabot>       No instance for (Num (t -> t1))
08:25:08 <lambdabot>        arising from the literal `6' at ...
08:25:12 <Olathe> > show (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
08:25:13 <lambdabot>   "(1,2,3,4,5,6,7,8,9,10,11)"
08:25:29 <dblazakis> any good way to load a module into GHCi that imports a .hsc?
08:25:31 <maltem> so according to the report, deriving-Show must specifically implement () :-/
08:26:06 <orbitz> is show for n-tuples a special case are are they defined?
08:26:13 <Olathe> > show (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
08:26:14 <lambdabot>       No instance for (Show
08:26:14 <lambdabot>                         (t,
08:26:14 <lambdabot>                      ...
08:26:23 <Olathe> They're defined up to 15 elements.
08:26:27 <orbitz> ah
08:26:37 <orbitz> > show (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
08:26:38 <lambdabot>   "(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)"
08:27:39 <vixey> > (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
08:27:40 <lambdabot>       No instance for (Show
08:27:40 <lambdabot>                         (t,
08:27:40 <lambdabot>                      ...
08:28:18 <EvilTerran> maltem, i think http://haskell.org/onlinereport/derived.html gives enough info to determine the meaning of "data () = () deriving Show"
08:28:19 * EmielRegis http://img399.imageshack.us/img399/1630/1229442677093gm7.jpg
08:28:25 <Axman6> :t (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
08:28:27 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15. (Num t15, Num t14, Num t13, Num t12, Num t11, Num t10, Num t9, Num t8, Num t7, Num t6, Num t5, Num t4, Num t3, Num t2, Num t1, Num t) => (
08:28:27 <lambdabot> t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15)
08:28:36 <Axman6> ha
08:28:56 <orbitz> weird, why isn't it just 1 type?
08:28:58 <Axman6> :t (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,17,18,19,20)
08:28:59 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19. (Num t19, Num t18, Num t17, Num t16, Num t15, Num t14, Num t13, Num t12, Num t11, Num t10, Num t9, Num t8, Num t7, Num t6,
08:28:59 <lambdabot>  Num t5, Num t4, Num t3, Num t2, Num t1, Num t) => (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19)
08:29:16 <EvilTerran> > (1 :: Int, 1 :: Double) -- orbitz, because you can do this
08:29:17 <lambdabot>   (1,1.0)
08:29:24 <quicksilver> orbitz: tuples don't have to be uniform ;)
08:29:25 <EvilTerran> > (1,1) :: (Int,Double)
08:29:26 <orbitz> EvilTerran: but that isn't his type
08:29:27 <Axman6> is there a limit to tuple size?
08:29:27 <lambdabot>   (1,1.0)
08:29:35 <orbitz> right, but isn't Axman6's type uniform by defintin?
08:29:39 <Olathe> No, there's no limit.
08:29:42 <vixey> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
08:29:44 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
08:29:44 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
08:29:44 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126 t127 t128 t129 t130 t131 t132 t133 t134 t135 t136 t137 t138 t139 t140 t141 t142 t143 t144 t145 t146 t147 t148
08:29:44 <lambdabot> t149 t150 t151 t152 t153 t154 t155 t156 t157 t158 t159. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 ->
08:29:46 <lambdabot>  t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 ->
08:29:49 <lambdabot> [8 @more lines]
08:29:50 <Olathe> The niceties just aren't there for ones above 15.
08:29:59 <vixey> I thought there was a limit.......
08:30:00 <Axman6> vixey: you're an evil man (or woman?)
08:30:10 <quicksilver> orbitz: it is the same as axman's example.
08:30:10 <Olathe> You can, of course, add in the niceties easily enough.
08:30:13 <quicksilver> :t (1,2)
08:30:14 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
08:30:18 <quicksilver> > (1,2) :: (Int,Int)
08:30:19 <lambdabot>   (1,2)
08:30:19 <Olathe> Wait.
08:30:21 <quicksilver> > (1,2) :: (Int,Double)
08:30:23 <lambdabot>   (1,2.0)
08:30:26 <quicksilver> orbitz: see ?
08:30:31 <Olathe> lambdabot cuts off stuff at about 50 characters...except for that.
08:30:34 <quicksilver> (1,2) is separately polymorphic in the types of both.
08:30:38 <orbitz> oh ok
08:30:43 <orbitz> :t (1.0, 1.0)
08:30:44 <lambdabot> forall t t1. (Fractional t1, Fractional t) => (t, t1)
08:30:49 <Axman6> > (1,2,3,4) :: (Int,Double,Float,CReal)
08:30:50 <lambdabot>   (1,2.0,3.0,4.0)
08:30:54 <vixey> Prelude> ((),(),(),(),(),()...
08:30:59 <vixey> <interactive>:1:0:
08:30:59 <vixey>     A 226-tuple is too large for GHC
08:30:59 <vixey>       (max size is 62)
08:30:59 <vixey>       Workaround: use nested tuples or define a data type
08:31:03 <orbitz> :t (1.0, 1.0) :: (Double, Double)
08:31:04 <lambdabot> (Double, Double)
08:31:16 <Axman6> vixey: thanks for the answer :)
08:31:20 <avizoa> anyone know why Prelude has insert and sort, but not merge? Anything obvious I'm missing?
08:31:40 <vixey> @src sort
08:31:40 <lambdabot> sort = sortBy compare
08:31:42 <solrize> :t merge
08:31:43 <lambdabot> Not in scope: `merge'
08:31:46 <vixey> @src sortBy
08:31:46 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:32:17 <solrize> whaaat?   it's a quadratic sort???
08:32:29 <quicksilver> No, it's really merge.
08:32:45 <EvilTerran> it's just going to have the same semantics as that one
08:32:51 <EvilTerran> not necessarily the same complexity
08:32:51 <vixey> insertion sort
08:32:51 <gwern> 'Erlang would be Hinduism - It's another strange language that doesn't look like it could be used for anything, but unlike most other modern languages, it's built around the concept of multiple simultaneous deities.'
08:32:57 <maltem> @slap lambdabot
08:32:57 * lambdabot pushes lambdabot from his chair
08:33:04 <qebab> Sure does look like insertion sort
08:33:13 <quicksilver> qebab: that definition lies.
08:33:22 <Axman6> the actual definition is different
08:33:28 <orbitz> @src Data.List.sort
08:33:29 <lambdabot> Source not found. Take a stress pill and think things over.
08:33:30 <quicksilver> @src is just a bunch of made-up rubbish that has no relationship to the definitions in GHC or hugs.
08:33:30 <lambdabot> Source not found. It can only be attributed to human error.
08:33:31 <qebab> quicksilver: Okay.
08:33:33 <avizoa> i'm not sure how I'd use sortBy to merge two sorted lists
08:33:40 <solrize> ic
08:33:43 <EvilTerran> the actual definition that ghc uses is ingenious
08:33:59 <quicksilver> whereas the above defn would be disingenuous.
08:34:15 <Olathe> @@ @run (@run let tuple n = fun ('(':(concat.intersperse ",".map show $ [1..n])++")") :: Expr in tuple 256)
08:34:18 <lambdabot>   <no location info>: parse error on input `;'
08:34:29 <Axman6> avizoa: mergeBy cmp xs ys = foldr (insertBy cmp) xs ys?
08:34:31 <Olathe> It worked in private, botty !
08:34:33 <gwern> and users of @src would be incredulous?
08:34:58 <avizoa> ah ok I see it now
08:35:07 <Olathe> @. run run let tuple n = fun ('(':(concat.intersperse ",".map show $ [1..n])++")") :: Expr in tuple 256
08:35:10 <lambdabot>   <no location info>: parse error on input `;'
08:35:16 <Olathe> @slap lambdabot
08:35:17 * lambdabot submits lambdabot's email address to a dozen spam lists
08:35:32 <qebab> Well, that's suicide if I ever saw one!
08:35:38 <qebab> I didn't though
08:35:46 <Axman6> lambdabot: take it back before it's too late!
08:35:49 <gwern> no jury in the world would convict Olathe
08:36:03 <Olathe> If you try that in private, you can see.
08:38:02 <EvilTerran> http://hpaste.org/3422 <- have some mergesort!
08:38:51 <EvilTerran> although "wrap x = [x]" seems to be missing from thatp aste
08:39:28 <quicksilver> take not the name of the monkey in vein!
08:39:34 <Axman6> why ot just use return?
08:40:20 <orbitz> > return 1 :: []
08:40:22 <lambdabot>       `[]' is not applied to enough type arguments
08:40:22 <lambdabot>      Expected kind `?', bu...
08:40:26 <orbitz> > return 1 :: [Int]
08:40:28 <lambdabot>   [1]
08:40:39 <orbitz> @src Monad []
08:40:39 <lambdabot> Source not found.
08:40:49 <EvilTerran> ?src [] return
08:40:50 <lambdabot> return x    = [x]
08:40:52 <EvilTerran> ?src [] >>=
08:40:52 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:40:55 <EvilTerran> ?src [] (>>=)
08:40:55 <lambdabot> xs >>= f     = concatMap f xs
08:41:00 <EvilTerran> ?src [] fail
08:41:00 <lambdabot> fail _      = []
08:41:14 <EvilTerran> ?? (?src [] mzero) (?src [] mplus)
08:41:20 <Holle_> can anyone help me with the ?
08:41:45 <Axman6> Holle_: what's the problem?
08:41:45 <vixey> 
08:41:46 <EvilTerran> hm
08:42:05 <Holle_> i have an expression to reduce
08:42:27 <Holle_> FALSE = x.y.y
08:42:32 <Holle_> AND = x.y.x y FALSE
08:42:33 * EmielRegis http://www2.b3ta.com/host/creative/61609/1229336413/ggtu.gif
08:42:35 <vixey> that's wrong
08:42:45 <Holle_> is given
08:42:45 <vixey> x.y.y is a syntax error
08:42:55 <BONUS_> is that church encoding
08:42:59 <vixey> maybe you meant x.y.y ?
08:43:28 <Holle_> oh yes!
08:43:40 <Holle_> i found my mistake...
08:43:44 <Holle_> thanx!
08:44:26 <conal> would someone recommend a unicode fixed-width font for emacs-22 gtk?
08:45:52 <byorgey> oh dear, I seem to have slightly hosed Cabal
08:46:06 <Axman6> conal: i'm a big fan of anonymous
08:46:33 <Axman6> annonymous? meh, google + font will turn it up :)
08:46:58 <byorgey> BONUS_: indeed, it is church encoding
08:47:00 <conal> Axman6: thx!
08:47:11 <maltem> conal: not sure about emacs, but I'm looking at DejaVu Sans Mono most of the time (or maybe Bitstream Vera, they look the same)
08:47:29 <Axman6> conal: i think it looks good antialiased (which is how i use it in terminal all the time)
08:47:32 <conal> maltem: great.  i'll check them out. :)
08:47:36 <Axman6> very clear font :)
08:48:00 <Axman6> http://www.ms-studio.com/FontSales/anonymous.html for anyone interested
08:49:15 <byorgey> @seen dcoutts_
08:49:15 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #darcs. I don't know when dcoutts_ last spoke.
08:51:00 <ksf> conal, Bitstream Vera Sans Mono?
08:52:16 <Axman6> hmm... i think i'm getting close to haskell leveling up... GHC's Core is starting to make some sense to me, and i can almost see how it would translate to ASM
08:52:31 <Axman6> the naming is horrible though :(
08:53:03 <Saizan> ahhahaha
08:53:30 <orbitz> @src return :: []
08:53:31 <lambdabot> Source not found. Just try something else.
08:53:35 <orbitz> @src return :: [Int]
08:53:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:53:40 <Deewiant> @src [] return
08:53:41 <lambdabot> return x    = [x]
08:53:48 <orbitz> thanks
08:53:53 <orbitz> @src [] (>>=)
08:53:54 <lambdabot> xs >>= f     = concatMap f xs
08:54:04 <orbitz> :t concatMap
08:54:05 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:54:06 <Axman6> just one more gold coin and... *ping* yes!
08:54:56 <orbitz> concatMap (:) [1, 2, 3]
08:55:01 <orbitz> > concatMap (:) [1, 2, 3]
08:55:02 <lambdabot>   Couldn't match expected type `[b]'
08:55:20 <orbitz> err durh
08:55:33 <EvilTerran> > concatMap (:[1,2]) [1,2,3]
08:55:34 <lambdabot>   [1,1,2,2,1,2,3,1,2]
08:55:36 <orbitz> > concatMap (\x -> [x]) [1, 2, 3]
08:55:37 <lambdabot>   [1,2,3]
08:55:47 <Axman6> i take it that  "Worker $wsequ'" in Core means that $wsequ' is the worker for (in this case) sequ'?
08:55:48 <EvilTerran> > concatMap (:[{- om nom nom -}]) [1,2,3]
08:55:50 <lambdabot>   [1,2,3]
08:56:17 <orbitz> @src [] (>>)
08:56:17 <lambdabot> xs >> ys      = concatMap (const xs) ys
08:57:36 <gwern> maltem: as far as I understand it, deja vu is bitstream with more unicode symbols. so it may be worth using dejavu if you plan on using haskell-mode's unicodifying feature
08:57:49 <Philonous1> Concurrent haskell is still lazy, isn't it? So when I start a thread that generates some data structure (e.g. a tree) and another thread traverses it, the first thread will be invoked "on demand" to generate the data the other thread consumes?
08:58:19 <Saizan> Philonous1: err, no
08:58:24 <Saizan> Philonous1: it's still lazy
08:58:32 <Axman6> Philonous1: good question, and i was doing the exact same thing :)
08:58:57 <Saizan> Philonous1: but that means that if you return an unevaluated thunk from a thread, it's the thread consuming it that will pay the cost of evaluation
08:58:57 <Axman6> Philonous1: depends how you write the code i guess
08:59:24 <vixey> isn't the point of lazy evaluation so you don't have to consider execution order...?
08:59:25 <EvilTerran> this is why `par` forces its first parameter to WHNF in a thread
08:59:58 <Philonous1> Ah, I see
09:00:13 <orbitz> WHNF?
09:00:23 <Philonous1> weak heead normal form
09:00:27 <Philonous1> head*
09:00:35 <Saizan> vixey: if you're trying to spread execution over multiple threads to make use of multiple cores, then you care about execution order
09:00:51 <EvilTerran> execution partial order?
09:03:06 <vixey> ok so then it's not lazy if you are doing concurrent programming
09:03:21 <EvilTerran> it could still be non-strict
09:03:34 <vixey> (like how using while loops and mutable in Prolog is not declarative)
09:06:52 <Axman6> crap, don't you hate it when you realised how to fix some code just as you go off to bed?
09:07:55 <maltem> gwern: ah good to know
09:08:21 <Axman6> given sequ' count 1 = count+1; sequ' count n = sequ' (count+1) if even n then n `div` 2  else 3 * n + 1, how would i use the MemoTrie package to memoise the results based on the second argument only?
09:08:47 <Axman6> i think i have to change the definition to be 1 + sequ f even n then n `div` 2  else 3 *  n + 1
09:08:59 <maltem> Axman6: I really hate it more when I'm in bed already, and then get a vague idea how to do a task that didn't work out during the whole day
09:09:16 <oklofok> Axman6: sometimes i've just been about to fall asleep, and an idea has come to me, have had to go code it up before going back to sleep.
09:09:20 <Axman6> maltem: that's exactly what's happening to me now :)
09:09:36 <Axman6> oklofok: yep, working on it now :)
09:09:39 <Axman6> ha
09:10:03 <oklofok> like you know those dreams where just as you fall asleep like a bee stings you in the dream and you wake up heart racing like hell, that but with codes.
09:11:30 <Axman6> that's never happened to me afaik.. maybe it will now :o
09:13:05 * vixey is curious what these programs are that take such inspiration to write
09:17:30 <Axman6> vixey: annoyingly this is a trivial project euler one :\
09:17:41 <Axman6> which i've already solved too. trying to make better answers
09:17:50 <Olathe> Which one ?
09:17:55 <Axman6> 14
09:18:22 <Olathe> Ahh.
09:20:48 <dons> ?users
09:20:48 <lambdabot> Maximum users seen in #haskell: 586, currently: 567 (96.8%), active: 17 (3.0%)
09:22:37 <Axman6> this can;t be good: 14: <<loop>>
09:22:47 <Axman6> (the program's called 14)
09:23:06 <Zao> Axman6: You've entered a thunk while evaluating that thunk.
09:23:14 <Zao> Badness 10000.
09:23:21 <Axman6> heh, i see
09:23:23 <Axman6> hmm
09:24:08 <Zao> The term 'blackhole' comes to mind.
09:24:11 <Axman6> well i have: sequ'' = memo sequ'''; sequ''' n = (+1) . sequ'' $ if even n then n `div` 2  else 3 * n + 1
09:24:38 <Axman6> there's a basecase for 1 = 1 as well
09:25:35 <roconnor> ghc has decided your program is one of those that never halts, so it stopped it.
09:25:50 <Axman6> but it does halt :(
09:26:15 <Axman6> at least, it is hypothysised
09:26:17 <Deewiant> @faq Can GHC solve the halting problem?
09:26:18 <lambdabot> The answer is: Yes! Haskell can do that.
09:27:42 <Holle_> is it possible to sum up a list of integers with "map"?
09:27:49 <EvilTerran> ?type map
09:27:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:27:58 <EvilTerran> map always returns a list of elements
09:28:04 <vixey> yeah sum . map id
09:29:24 <Axman6> Holle_: usually you'd use a fold (foldl' (+) 0)
09:29:53 <drdozer> is MonadRandom packaged up nicely for kubuntu somewhere?
09:29:57 <drdozer> or should I acquire it from darcs and build?
09:30:05 <Holle_> that's right, but the task says: "write a function sumlist using the higher order function map"
09:30:58 <Axman6> Holle_: map has no way of combining the elements of a list
09:31:08 <Axman6> > map f [a,b,c,d]
09:31:09 <Zao> Axman6: Unless you map over tails :)
09:31:09 <lambdabot>   Add a type signature
09:31:26 <Deewiant> Zao: but that's essentially a scanl
09:31:59 <Deewiant> and requires explicit recursion or folding on top of the map, so it doesn't quite fit the problem description
09:33:04 <Axman6> > map f [a,b,c,d] :: [Expr]
09:33:06 <lambdabot>   [f a,f b,f c,f d]
09:33:23 <Axman6> Zao: i don't get how, could you show me?
09:33:24 <Holle_> that's the defintion of map...
09:34:35 <hellige> > head . map sum . tails $ [1,2,3]
09:34:37 <lambdabot>   6
09:34:49 <hellige> but that's a really stupid thing to do.
09:34:51 <Axman6> heh, fair enough
09:35:18 <Deewiant> > head $ scanr1 (+) [1,2,3]
09:35:20 <lambdabot>   6
09:35:31 <ddarius> > 6
09:35:32 <lambdabot>   6
09:35:33 <Holle_> Main> summatrix [[1,2,3],[4,5,6],[7,8,9],[1,2,3]
09:35:33 <Axman6> ok, sleep time. night all
09:35:34 <goog> Hey People! Do you have a standard way of commenting a whole directory? Im using a "0info" file, where I put all infos about the directory in a big comment. Any thoughts on this?
09:35:34 <Holle_> 51
09:35:36 <Holle_> we have the definition as recursiv, foldr/foldl function. an definition with the usage of map is asked
09:36:11 <Axman6> Holle_: looks like sum . map sum to me
09:36:18 <Holle_> the sum all elemnts of all lists in the list
09:36:36 <Axman6> :t sum . map sum
09:36:37 <lambdabot> forall a. (Num a) => [[a]] -> a
09:36:56 <Axman6> > sum . map sum $ [[1,2,3],[4,5,6],[7,8,9],[1,2,3]]
09:36:57 <lambdabot>   51
09:37:49 <Holle_> what does the $ mean?
09:37:55 <Deewiant> @src $
09:37:56 <lambdabot> f $ x = f x
09:38:29 <PeakerWork> Holle_: its a very-low-precedence operator so   a $ b   is like (a) $ (b)  so its saves you the parens
09:38:40 <Holle_> so it is not necessary
09:38:47 <Deewiant> You meant a $ b is like (a) (b)
09:38:56 <PeakerWork> yeah, that too :)
09:39:12 <Deewiant> Holle_: f . g x is (f . g x) whereas f . g $ x is (f . g) x
09:39:18 <Philonous1> Btw is $ left or right associative?
09:39:19 <PeakerWork> sum . map sum $ [[1,2,3],[4,5,6],[7,8,9],[1,2,3]]      is like:  (sum . map sum) [[1,2,3],[4,5,6],[7,8,9],[1,2,3]]
09:39:26 <PeakerWork> @info ($)
09:39:27 <lambdabot> ($)
09:39:31 <Asztal> It's right-associative
09:39:33 <PeakerWork> Philonous1: rassoc
09:39:40 <Philonous1> thx
09:40:04 <PeakerWork> Holle_: it saves the need to surround sum . map sum  with ()
09:40:10 <PeakerWork> nice syntactic trick
09:42:53 <roconnor> crap. We all have to make our module names 10 characters or less
09:43:20 <roconnor> Haskell is as bad as Fortran
09:43:21 <Deewiant> 9 or less *
09:43:30 <ddarius> roconnor: Fully qualified or simple?
09:43:32 <Deewiant> 10 was the tipping point
09:43:35 <roconnor> :(
09:43:35 <Deewiant> Fully qualified
09:43:37 <roconnor> 9 or les
09:43:43 <vixey> worse!
09:43:47 <Holle_> ok thank you for the trick..
09:45:13 <dolio> Only if you use lots of record selectors, apparently.
09:45:29 <roconnor> ``This is almost certainly because the length of the error string pushes the definition of val just over the size limit for inlining
09:45:38 <roconnor> oh god
09:45:46 <vixey> roconnor, awesome :D
09:45:52 <Deewiant> I think it's somewhat ridiculous that manually written record selectors perform differently to compiler-written
09:45:57 <roconnor> seriously.  We need some PhDs to make the optimiser less ad hoc
09:46:00 <Deewiant> there've been a lot of bugs about that
09:46:19 <pejo> roconnor, we have ndm
09:46:37 <roconnor> as far as I can tell GHC's optimiser is a pile of garbage.
09:46:47 <roconnor> but that may be unfair of me
09:46:55 <roconnor> not that I can write an optimiser
09:47:01 <vixey> IT's difficult to asses something as completely unreadable as GHC :P
09:47:10 <vixey> assess*
09:47:28 <roconnor> but it is all so arbitrary
09:47:49 <roconnor> I wonder if gcc is the same
09:48:10 <pejo> vixey, there's plenty of papers written about the stuff in GHC though.
09:48:19 <vixey> yeah the papers are nice and neat :)
09:48:32 <pejo> roconnor, except they don't write a lot of papers, and have an ambigious standard.
09:49:25 <quicksilver> on the other hand, gcc has a big regression test suite
09:49:36 <quicksilver> (the entire linux and BSD kernels and userlands, for starters)
09:50:12 <roconnor> is ndm's supero usuable yet?
09:50:19 <roconnor> I doubt it would have this problem.
09:50:32 <quicksilver> nope.
09:50:57 <quicksilver> not to put ndm down, but whole program compilation is exponential.
09:51:10 <pejo> quicksilver, atleast previously the linux kernel developers explicitly told people to aovid a bunch of versions of gcc. So either they aren't testing, or it's difficult.
09:51:15 <quicksilver> I think that's some distance away from being a useful technique still?
09:51:21 <quicksilver> pejo: that is testing.
09:51:31 <roconnor> quicksilver: pefect.  With all that time spent, it probably doesn't have to resort to arbitrary hacks.
09:51:33 <quicksilver> pejo: release GCC, see if kernel developers complain
09:51:39 <pejo> quicksilver, MLton does whole program and have atleast worked on 100kloc.
09:51:44 <quicksilver> pejo: if they do, that release was buggy ;)
09:52:38 * quicksilver nods. MLton is impressive from what I've heard.
09:53:03 <wli> There is kernel/gcc overlap (e.g. davem, rth).
09:53:07 <quicksilver> Mind you, I think ghc is ratehr impressive too. What roconnor is talking about (the inlining heuristic) doesn't sound particularly hard to improve.
09:53:11 <Deewiant> roconnor: this bug isn't an arbitrary hack, it's just a heuristic going wrong for some stupid reason
09:53:13 <PeakerWork> quicksilver: is it exponential worst-case or exponential average-case?
09:53:17 <pejo> quicksilver, why would whole program compilation be exponential, but separate compilation not?
09:53:54 <quicksilver> pejo: well, the thesis is that separate compilation is exponential only in the size of the largest file
09:54:02 <EvilTerran> pejo, separate compilation is also exponential, but the size of individual modules is sublinear in the size of the program
09:54:07 <quicksilver> rather than the size of the project as a whole.
09:54:08 <roconnor> isn't a heuristic an arbitrary hack?
09:54:17 <quicksilver> roconnor: yes, welcome to the real world.
09:54:20 <Deewiant> @wn heuristic
09:54:21 <lambdabot> *** "heuristic" wn "WordNet (r) 2.0"
09:54:22 <lambdabot> heuristic
09:54:22 <lambdabot>      adj : of or relating to or using a general formulation that serves
09:54:22 <lambdabot>            to guide investigation [ant: {algorithmic}]
09:54:22 <lambdabot>      n : a commonsense rule (or set of rules) intended to increase
09:54:23 <lambdabot>          the probability of solving some problem [syn: {heuristic
09:54:26 <lambdabot>          rule}, {heuristic program}]
09:54:28 <roconnor> god damn real world
09:54:33 <EvilTerran> (indeed, the size of individual modules is effectively O(1), according to good design)
09:55:00 * EvilTerran considers "optimisation" to imply "heuristic", anyway
09:55:11 <quicksilver> roconnor: real problems have NP-hard or double exponential or indeed non-computable solutions.
09:55:19 <quicksilver> so, you have to make do with what you can do.
09:55:42 <Deewiant> It would be nice if you could just run every program with the correct result and pick the fastest ;-)
09:56:23 <quicksilver> program optimisation has lots of subproblems in this category.
09:56:24 <pejo> quicksilver, I don't think it's "easy" to tweak the GHC inliner, especially not if you want something less hacky. Inlining seems to be black art.
09:56:48 <quicksilver> Heck, even register allocation is NP I think?
09:56:50 <roconnor> quicksilver: are SAT solvers as arbitrary?
09:56:55 <pejo> quicksilver, and instruction scheduling.
09:56:57 <Deewiant> quicksilver: Yeah, I think it is.
09:57:05 <PeakerWork> quicksilver: NP in what axis?
09:57:14 <PeakerWork> quicksilver: number of registers?
09:57:16 <vixey> There is that logic of register allocation
09:57:27 <vixey> proof theory stuff for register allocation :D
09:57:29 <quicksilver> pejo: the size heuristic is easily tweakable. roconnor is talking about a size heuristic which is implemented in the number of characters.
09:57:41 <quicksilver> pejo: that could easily be replaced by some "size" metric over the AST.
09:57:55 <quicksilver> which would solve his particular problem (sensititivity to the lengths of your identifier names)
09:58:20 <pejo> Just stating for the record: the problems seen in Supero (according to the paper) was that the homeomorphic embedding was taking a lot of time. And that itself is polynomial, not exponential.
09:58:35 <quicksilver> PeakerWork: I was thinking length of the subroutine.
09:58:43 <quicksilver> PeakerWork: but, I was also only guessing.
09:58:46 <ddarius> roconnor: JHC is what you get when you try to avoid heuristics.
09:58:49 <roconnor> quicksilver: I don't know if it is the number of characters.  The problem seems to be with the error message, which is part of the AST
09:59:05 <roconnor> ddarius: I should use J/LHC.
09:59:12 <quicksilver> roconnor: *nod* but a more sophisticated hack could discount that ;)
09:59:22 <quicksilver> roconnor: ignore the size of Strings or even perhaps of CAFs.
09:59:22 <roconnor> ahhhhh
09:59:27 <vixey> are they any good
09:59:33 <roconnor> actually the reall bug seems to be:
09:59:37 <ddarius> roconnor: As long as you don't care about getting binary code in the end, you should.
09:59:38 <vixey> I don't think anyone did a formal account of parsing haskell
09:59:39 <roconnor> ``What's more, this wouldn't be a problem if the inliner was using the optimised definition of the record selector, in which the error string had been pulled out to the top level.
09:59:39 <Deewiant> The error message is to be moved to the toplevel anyway, the inliner just doesn't realize it
09:59:54 <quicksilver> ddarius: and indeed, I think JHC is a very interesting compiler.
09:59:57 <roconnor> that seems like a real bug that is not a hack
10:00:09 <quicksilver> Deewiant: that's what I meant by ignoring CAFs
10:00:19 <quicksilver> Deewiant: I didn't appreciate it hadn't "noticed" it was a CAF by that point.
10:00:23 <dolio> The bug is, roconnor didn't read the whole thread/bug report before complaining. :)
10:00:29 <Deewiant> quicksilver: Yep.
10:00:45 <roconnor> dolio: I'll take any opertunity I can get to complain about the optimiser :)
10:00:59 * quicksilver wonders if there is a trac to report bugs in roconnor 
10:01:23 * roconnor is still scarred from his old bitshifting wounds
10:01:46 <quicksilver> #1 - Bitshifting scar tissues causes incorrect bug reports in GHC.
10:01:51 <roconnor> it was psycologically damaging
10:02:10 <ddarius> > (1-0.001)/(40*log 2)
10:02:12 <lambdabot>   3.603130864620186e-2
10:02:25 <ddarius> > (1-0.001)/(40*log 2)*100000
10:02:27 <lambdabot>   3603.130864620186
10:02:36 <Lemmih> vixey: Were you asking if JHC or LHC are any good?
10:02:39 <quicksilver> > (1-0.001)/(40*log 2) :: CReal
10:02:40 <lambdabot>   0.0360313086462018610988141189080222561322
10:02:45 <vixey> no
10:02:46 <roconnor> dons says the bitshifting is fixed.  Maybe I should try out my UM again.
10:03:08 <dcoutts_> byorgey: pong
10:03:09 <lambdabot> dcoutts_: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:03:25 <ddarius> > (1-0.001)/(40*log 2)/.000001
10:03:27 <lambdabot>   Not in scope: `/.'
10:03:32 <quicksilver> conal: I finally posted my code :)
10:03:32 <ddarius> > (1-0.001)/(40*log 2)/0.000001
10:03:33 <lambdabot>   36031.30864620186
10:04:13 <conal> quicksilver: thanks!  i haven't tried it yet, but Beelsebob says it does some shiny things.
10:04:22 <ddarius> 1/(20000*log 2)/0.000001
10:04:30 <ddarius> > 1/(20000*log 2)/0.000001
10:04:32 <lambdabot>   72.13475204444818
10:05:08 <byorgey> dcoutts_: I was having a Cabal-related problem, but I solved it by reinstalling ghc-6.8.3 =)
10:05:22 <byorgey> dcoutts_: I can tell you more about it later if you like
10:05:33 <dcoutts_> byorgey: any idea what the root of the problem was? any Cabal bug?
10:05:37 <dcoutts_> byorgey: ok, later
10:06:09 <quicksilver> conal: I think he was trying to port it to your Reactive. I would (a) be interested in making that simple by unifying the API (b) be interested to see if it behaves any differently ;)
10:07:00 <conal> quicksilver: i'm with you.
10:07:36 <quicksilver> conal: since a difference in behaviour is very clearly a bug, although no doubt we can argue about whose ;)
10:08:03 <conal> quicksilver: maybe not much arguing, given the specified semantics.
10:08:22 <quicksilver> sha,e the arguing is the fun part.
10:08:33 <quicksilver> s/,e /me, /
10:08:39 * quicksilver peers doubtfully at his fingers.
10:09:09 * Beelsebob suspects that any bugs exposed will be in things not covered by the semantics -- e.g. space time behavior
10:09:24 <quicksilver> yes, there is that.
10:09:34 <quicksilver> I will be very interested to hear which implementation is "smoother"
10:09:46 <quicksilver> a notoriously fiddly thing to  quantify.
10:09:53 <quicksilver> be interesteing to compare heap profiles too.
10:10:00 <Beelsebob> my guess at the moment is yours -- I suspect it will hit the merge bug in conal's reactive just atm
10:10:06 <PeakerWork> quicksilver: did you get my message about the stars thing hanging after a few seconds, even with -threaded -O2 ?
10:10:07 <Beelsebob> quicksilver: oh, also, I realised how to do the camera nicely
10:10:22 <quicksilver> it ought to work with conal's as of a few revisions back though?
10:10:32 <conal> i'm having a devil of a time tracking down this bug.  i don't think it's in merge or in joinE.
10:10:38 <roconnor> how do I get ghc to output optimized core?
10:10:39 <quicksilver> PeakerWork: No, that's odd.
10:10:49 <conal> and i just added QC test coverage to improving values.
10:10:51 <quicksilver> PeakerWork: which OS/GHC version?
10:10:53 <Beelsebob> conal: oh? I had identified a deffinate bug in merge
10:11:21 <conal> Beelsebob: oh.  maybe i missed it.  pointer?
10:11:25 <PeakerWork> quicksilver: Ubuntu's newest.. I'll give you more data later (gotta go)
10:11:45 <quicksilver> PeakerWork: ok, no probls.
10:11:55 <quicksilver> I will try to try it on linux tonight.
10:12:02 <quicksilver> Although my linux box has a laughable graphics card.
10:12:12 <conal> i also fixed the memory/work leak with external inputs, using weak pointers.
10:12:17 <Saizan> roconnor: -ddump-simpl
10:13:04 <Beelsebob> conal: [(n, ())] `merge` [(notYet, ())] == _|_, it should be (n,())->(sameNotYetTime,())
10:13:14 <Beelsebob> where n is some time that's already passed
10:14:00 <roconnor> Saizan: does -fext-core dump the optimized core?
10:14:22 <roconnor> seems no
10:14:56 <roconnor> maybe yes?
10:15:28 <roconnor> Crap!
10:15:32 <roconnor> (base:GHC.Word.zdwzddmshiftR1 ww
10:15:32 <roconnor>                                             (28::base:GHC.Prim.Intzh)
10:15:34 <Saizan> never used that
10:15:35 <conal> Beelsebob: wow.  does this bug require improving values and external input?
10:15:45 <roconnor> shiftR is still not being inlined!
10:15:55 <EvilTerran> preflex: list
10:15:56 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
10:16:05 <EvilTerran> preflex: zdec zdwzddmshiftR1
10:16:06 * roconnor 's psycological damage returns
10:16:06 <preflex>  $w$dmshiftR1
10:16:24 * roconnor cries
10:16:40 <Saizan> it looks like some part of it is inlined?
10:16:46 <Beelsebob> conal: yes, I think so -- you need to provide an improving value that has not yet occured, so that you can't match it against MaxBound -- this is the bug I was discussing with Claus Reinke on the mailing list
10:17:05 <roconnor> Saizan: you mean the dictionary lookup was inlined?
10:17:07 <Beelsebob> I think you must have partly-known about it, because there's a comment to the effect that it's too strict in the source
10:18:21 <Saizan> roconnor: i'm not that good at reading core, but $w$dmshiftR1 doesn't look like the toplevel function
10:18:33 <roconnor> right
10:18:38 <roconnor> it is the word instance I assume
10:18:49 <conal> Beelsebob: oh, okay.  thanks.  i have a hunch there are just one or two subtle laziness bugs that are behind the various strange symptoms.
10:18:59 <Beelsebob> conal: the effect of this is that if you snapshot a behavior, you won't see the effect of the last step of the Reactive until after the next step has happened -- at which point the past values of the reactive will suddenly change
10:19:06 <conal> Beelsebob: this example gives me something to focus on.
10:19:28 <vixey> @oies 5 13 563
10:19:29 <lambdabot>  Wilson primes: primes p such that (p-1)! == -1 mod p^2.
10:19:29 <lambdabot>  [5,13,563]
10:19:34 <Beelsebob> give me a min, I'll paste-bin a nice ghci session that reproduces the bug conal
10:19:47 <conal> Beelsebob: please
10:20:14 <roconnor> but I'm expecting to see something like base:GHC.Prim.uncheckedShiftLzh
10:21:44 <roconnor> like I got with one of my shiftLs
10:22:00 * roconnor cries
10:22:01 <Deewiant> expect the unexpected
10:22:15 <roconnor> the trauma is all coming back to me
10:22:27 <vixey> :(
10:23:08 <roconnor> every time I shift right I call a function, then check if the argument is less than 32, then do the shift
10:23:17 <roconnor> maybe with a few more function call in there
10:23:24 <roconnor> and it is in my inner loop
10:23:30 <roconnor> ;(
10:23:47 <roconnor> Lemmih: does LHC work?
10:24:12 <Lemmih> roconnor: For small values of "work", yes.
10:24:13 <roconnor> does it have IOUArrays
10:24:50 <Lemmih> roconnor: Arrays don't work very well.
10:25:07 <Lemmih> But "Hello World" runs really well.
10:25:14 <roconnor> :)
10:25:42 <roconnor> maybe when dons said that bitshifting works, he means under ghc 6.10
10:26:07 <arjanb> i also noticed ghc is very unpredictable in optimizing bit twidling
10:26:10 <bos> what about bitshifting?
10:26:28 <roconnor> bitshifting by a constant isn't inlined
10:26:39 * Beelsebob tries to remember what he needs to change to stop getting errors about zipWith in conal's Reactive implementation
10:27:49 <agl> X11-1.4.5 is broken for 6.10, right? It appears to need syb which is no long part of base
10:29:47 <conal> Beelsebob: are you importing Data.Zip ?
10:30:01 <mpeter> > "hello world"
10:30:03 <lambdabot>   "hello world"
10:30:45 <conal> Beelsebob: i wonder if i'm missing a version dependency.  TypeCompose's Data.Zip now exports zip, unzip, zipWith and maybe a few others.
10:31:02 <Beelsebob> ah, yeh -- that's the one
10:31:11 <conal> Beelsebob: which are all generalizations of the prelude functions.
10:31:21 <conal> Beelsebob: what's the error message?
10:32:14 <Saizan> agl: pass --constraint="base < 4" to configure
10:32:19 <Saizan> agl: or use cabal-install
10:32:27 <conal> Beelsebob: my copy of reactive.cabal says it depends on TypeCompose>=0.6.3.  does yours?
10:33:29 <agl> Saizan: this is with cabal-install; the package is just missing a syb dependency I believe
10:34:23 <Saizan> agl: cabal-install-0.6.0? i agree that the .cabal is not correct, but cabal-install works around that here
10:35:28 <agl> Saizan: not for me, sadly. If I manually build X11 with syb added, it recognises it "X11-1.4.5 (reinstall) changes: syb-0.1.0.0 removed"
10:35:36 <agl> clever but unhelpful :)
10:35:57 <Saizan> bump the version
10:36:08 <Saizan> e.g. to 1.4.5.1
10:36:20 <Beelsebob> conal: yeh, it's because I'm deliberately not using cabal on my laptop, because a recent change broke tetris
10:36:45 <dcoutts_> Beelsebob: ?
10:36:46 <conal> oh, oops.  one of my changes?
10:36:53 <conal> Beelsebob: ^^
10:37:01 <agl> Saizan: ah, good trick. Thanks
10:37:17 <Botje> I have a discrete-time trade sim and want to hook it up to an UI
10:37:18 <conal> Beelsebob: i can include tetris in my testing.  i don't use it now.
10:37:28 <Botje> can i use reactive for that?
10:38:29 <conal> Botje: for the UI?  for writing the sim more functionally?
10:38:48 <Botje> for coupling events in the sim to the UI
10:39:07 <Botje> for example if a boat docks, i want the sim to pause and give the user some options
10:39:44 <Botje> at the moment its basically runRWS, see if any events come out, show them, else continue
10:40:09 <Saizan> agl: wait, but X11.cabal already specifies base == 3.*
10:41:28 <Beelsebob> conal: I'm struggling to get myself working just now, I've had a little too much to drink -- I have this paste from yesterdays investigations at work that can show you the bug -- http://hpaste.org/13096
10:41:30 <Saizan> agl: can you paste the output of cabal install X11-1.4.5 --dry-run -v ?
10:41:34 <Beelsebob> but it's not quite ideal
10:41:46 <Beelsebob> note that the snapshot of the reactive does not update when the reactive changes
10:41:47 <agl> Saizan: yea, I saw that
10:42:05 <wchogg> Beelsebob : where are you?
10:42:17 <Beelsebob> wchogg: Antwerpen
10:42:47 <conal> Beelsebob: i'll take a look.  where's the paddlePosR def?
10:43:00 <agl> Saizan: http://haskell.pastebin.com/d10137910
10:43:13 <wchogg> Beelsebob : oh right!  Durr.
10:43:18 <Beelsebob> conal: that's exactly what I'm struggling to reproduce just now, I'd need to take a look at my code at work to get acomplete paste up
10:44:01 <conal> Beelsebob: okay, thx.
10:44:03 <wchogg> conal : I haven't done much with Reactive over the past few weeks because your blog has made it sound like you're planning some API changes again.  Is that an erroneous assumption?
10:44:07 <agl> Saizan: it might just be that I'm screwed up my GHC installation. I can manually install everything, thanks
10:44:08 <Beelsebob> conal: the undefined on the end there is because the improving value is (Imp undefined (const GT)), and my show instance for improving values is show . exact
10:44:36 <Saizan> agl: it shouldn't need the syb package
10:44:40 <Beelsebob> i.e. an improving value that we haven't discovered the value of yet
10:44:46 <conal> Beelsebob: oh, got it.  i was wondering.
10:45:25 <conal> Beelsebob: great.  this looks like the kind of example i've been looking for.
10:45:36 <Beelsebob> conal: some further refinement discovers that snap does not produce all its output
10:45:44 <Beelsebob> so catMaybes doesn't pick up the value
10:45:45 <gwern> (oh snap?)
10:45:56 * gwern feels ashamed of that quip already :(
10:45:56 <conal> Beelsebob: which snapsnot are you using?
10:45:58 <Beelsebob> and snap doesn't produce all its output because merge isn't lazy enough
10:46:17 <Beelsebob> conal: FRP.Reactive.PrimReactive.snapshot
10:46:20 <Beelsebob> snapshotWith*
10:46:44 <conal> Beelsebob: okay -- my original code.  not lilac's or Chuan-kai's or yours?
10:46:51 <Beelsebob> yes, your original
10:46:58 <conal> Beelsebob: thx. :)
10:47:03 <Beelsebob> hope that helps :)
10:47:15 <Beelsebob> sorry I'm a little bit useless tonight
10:47:57 <Saizan> ?where xmonad-contrib
10:47:58 <lambdabot> http://xmonad.org/xmonad-docs/xmonad-contrib/
10:48:05 <conal> wchogg: yes, i intend to add a higher level programming interface above the current one, for composable interaction, along the lines i've been hinting at in the blog.  also switch from absolute to relative time in the basis.
10:48:46 <conal> wchogg: although right now i'm focused on tracking down some subtle bugs, perhaps about laziness, which i think i have to tackle regardless of the higher level interface.
10:49:34 <wchogg> conal : Is there anything in particular I can do to help track down bugs, other than just look at trac & get digging?
10:50:40 <conal> wchogg: i like the offer. :)  thinking ...
10:54:59 <conal> wchogg: did you follow the exchange with Beelsebob above, about merge & strictness (also between Beelsebob and Claus on the reactive list)?  and about misbehaving snapshot (http://hpaste.org/13096)?
10:56:08 <conal> wchogg: one thing i'm struggling with is how to make some of the inner workings more visible when they don't work correctly.  for instance, i sometimes get a long stream of "<<loop>>".
10:56:27 <conal> wchogg: and i don't know how to find how where they're coming from.
10:57:44 <conal> wchogg: there are also gaps in QC test coverage.  we have a lot of class-related properties, but many of the reactive functions are not specified & tested.
10:58:15 <wchogg> conal : huh, that might be an interesting mini-project in & of itself to think of _what_ we can test via QC.
10:58:19 <teko> @src reverse
10:58:19 <lambdabot> reverse = foldl (flip (:)) []
10:58:26 <teko> @src flip
10:58:27 <lambdabot> flip f x y = f y x
10:58:31 <conal> wchogg: yes!
10:58:37 <Beelsebob> conal: the approach I've used to track down the couple of bugs in the last few days is to algorithmic-debug them -- create some simple reactives/events that look like your inputs, and work down through the EDT manually (because unfortunately hat won't play nice on reactive)
10:59:08 <conal> Beelsebob: "EDT"?
11:01:02 <Beelsebob> conal: evaluation dependancy tree -- it's a compositional tree that destribes the evalution of the program.  Each big step reduction appears at a node, the children of a node are the big step reductions required to carry out the reduction at that node
11:01:05 <conal> wchogg: of course i want to address visible bugs, but more i want a completely solid implementation.  elegant implementation, with thorough specification and automatic testing.
11:02:05 <Beelsebob> you can then use it for debugging -- a node is erronious if the result of the big-step reduction disagrees with your semantics, a node is faulty if it is erronious, but all its children are correct
11:02:39 <Beelsebob> a faulty node indicates that the small-step reduction used to combine all the children is faulty, and the program slice associated with it is faulty too
11:02:58 <wchogg> conal : and a specification via a hardcore set of QC tests might also help clear up differences between the various alternative versions.
11:02:59 <conal> Beelsebob: thx.  i'll give it a try and ask for help.  i haven't internalized algorithmic debugging, and i suspect it'd help me.
11:03:14 <conal> wchogg: yeah
11:04:20 <wchogg> Beelsebob : now you're talking about doing all of this by hand or with some kind of tool?
11:04:29 <conal> wchogg: i like the whole process to be driven by denotational semantics.  the QC tests can follow from and capture the semantics.  and then measure the implementation(s) against the semantics.
11:04:47 <olsner> hmm, what's the problem?
11:05:48 <Beelsebob> wchogg: at the moment I'm doing it by hand, because Hat baulks at Reactive, thanks to the number of extensions used
11:07:37 <Beelsebob> the practical implication is 1) create some pieces of data that look like your program inputs in ghci 2) run a reasonably top-level function in your program on the inputs -- if its result disagrees with expected semantics, look at how that function is defined, and run the sub-parts of it 3) repeat this process until you find one where all the sub-parts are right, but the evaluation is right -- you now have your bug
11:07:55 <teko> @src foldl
11:07:55 <lambdabot> foldl f z []     = z
11:07:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:08:28 <olsner> liberal sprinkling of Debug.Trace.trace is also an idea
11:08:43 <wchogg> Beelsebob : that's a much better disciplined approach than when I was trying to debug by hand a few weeks back.
11:08:45 <teko> @src factorial
11:08:46 <lambdabot> Source not found. Do you think like you type?
11:09:58 <conal> Beelsebob: how about this addition: add QC properties and/or generators that also reveal the problems.
11:10:03 <Olathe> If I have xs, what's an easy way to find out which x has the greatest output from applying f to it ?
11:10:17 <Beelsebob> conal: yep, that too
11:11:29 <conal> the QC properties & generators may have more long-term value than the implementation.
11:11:37 * BMeph imagines Beelsebob's blog: "Faulty Data Towers"
11:11:47 <Beelsebob> hehe
11:12:10 <conal> i'd subscribe!
11:12:59 * Beelsebob is not much of a blogger  I find it a relatively painful process to put ideas on paper
11:13:00 <psnively> Fawlty Data Towers.
11:13:16 <Beelsebob> psnively: :D I'm glad I wasn't the only one thinking that
11:13:36 <psnively> :-D
11:13:45 <wchogg> Well I think that was the original joke, just less blatent. :p
11:13:52 <psnively> Exactly.
11:14:42 * BMeph sympathizes. His blog is all-but-empty, although it has a fantastic title.
11:14:56 <wchogg> BMeph : and what is this fantastic title?
11:15:00 <psnively> It's all I can do to post the occasional story on LtU.
11:15:10 <BMeph> wchogg: "Effing the Ineffable" :)
11:17:07 <psnively> Oddly, I find being in completely over my head conducive to posting. The result tends to be "Hey! Look at this shiny paper I found. What's it mean?" and then various people orders of magnitude smarter than I am tell me what it means in the comments.
11:19:18 <psnively> Lunch. Back later.
11:19:47 <wchogg> BMeph : Alright, I will concede that is a pretty damn good title.
11:20:09 <zeno> Olathe: one (probably not best) solution: findLargest xs f = fst $ head $ sortby snd $ zip xs (map f xs)
11:20:28 <zeno> soryby would sort by second, descending
11:21:17 <Olathe> Hmm, when I run out of stack space, I get this :
11:21:26 <Olathe> "Use `+RTS -Ksize' to increase it."
11:21:36 <Olathe> When I do that, I get :
11:21:38 <Olathe> "bad RTS option: -Ksize"
11:21:50 <Olathe> zeno: Ahh, thanks.
11:21:56 <zeno> maybe ksize could be a number?
11:22:02 <olsner> Olathe: -K100M etc
11:22:09 <Olathe> Ahh.
11:22:20 <Olathe> Thanks :)
11:23:29 <byorgey> dcoutts_: well, I'm not really sure what the root of the problem was
11:23:47 <dcoutts_> byorgey: the symptoms?
11:23:58 <byorgey> I tried using cabal-install to install QC2, but it failed when it tried to install old-time
11:24:09 <byorgey> since it said the Build-type: was Configure but there was no configure script
11:24:15 <dcoutts_> hmm
11:24:17 <byorgey> which is true, I looked at the old-time package.
11:24:29 <byorgey> but I'm not sure why it wanted to install old-time in the first place.
11:24:32 <dcoutts_> the interesting thing is why it wanted to rebuild it
11:24:33 <Heffalump> dons: I have RWH. Although the spine is very slightly blemished.
11:24:35 <byorgey> I would have thought I already had that installed.
11:24:36 <byorgey> right.
11:24:57 <dcoutts_> byorgey: --dry-run -v says what it is changing, it's usually changing versions of dependencies
11:25:06 <byorgey> so in an attempt to fix it I tried just installing old-time manually, by changing the build-type: to Simple
11:25:31 <byorgey> then it installed ok but then everything was totally hosed because it couldn't find certain symbols from the old-time package
11:25:45 <byorgey> I guess it really does need the configure script.
11:26:03 <dcoutts_> aye
11:26:22 <dcoutts_> cabal-install is a little too eager to rebuild core packages
11:26:26 <byorgey> so I reinstalled ghc-6.8.3, and then everything worked again, and I did cabal-install of QC2 again and it worked this time without installing any other packages
11:26:43 <dcoutts_> there's one particular case where I'm going to fix it to be less eager
11:27:08 <dons> Heffalump: wonderful!
11:27:08 <lambdabot> dons: You have 13 new messages. '/msg lambdabot @messages' to read them.
11:27:14 <dons> Heffalump: i'm glad it arrived in time
11:27:31 <conal> Beelsebob: oh!  i see what you mean about the problem that event merge pattern-matches against infinity.  silly mistake on my part!
11:27:54 <BMeph> wchogg: Not only sassy, but it has a relevant reference to a major function of a blog. :)
11:28:10 <Heffalump> dons: in time for what?
11:28:42 <conal> Beelsebob: not that i know what to do about it.
11:30:58 <conal> Beelsebob: oh, wait.  on second thought, i don't see why a future time wouldn't sail past this check, using NoBound.
11:31:48 <conal> Beelsebob: do you know of a case of [(n, ())] `merge` [(notYet, ())] in which the notYet isn't a NoBound?
11:32:13 <zeno> @pl  Olathe: maybe more efficient (and prettier :): findLargest xs f = xs !! $ (head . elemIndices . maximum) (map f xs)
11:32:14 <lambdabot> (line 1, column 65):
11:32:14 <lambdabot> unexpected "="
11:32:14 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
11:33:56 <dolio> > 8 * 40000000 `div` 1024 `div` 1024 `div` 1024
11:33:57 <lambdabot>   0
11:34:04 <dolio> > 8 * 40000000 `div` 1024 `div` 1024
11:34:06 <lambdabot>   305
11:36:49 <hoopy> > 8 * 40000000 / 1024 ^ 2
11:36:50 <lambdabot>   305.17578125
11:40:03 <bos> @seen dcoutts
11:40:03 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts last spoke.
11:40:08 <dcoutts_> hia bos
11:40:09 <bos> @seen dcoutts_
11:40:10 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #darcs. I last heard dcoutts_ speak 1s ago.
11:40:13 <dcoutts_> @arr!
11:40:13 <bos> oh!
11:40:13 <lambdabot> Keelhaul the swabs!
11:40:27 <bos> dcoutts_: any word from tom harper re his unicode library?
11:40:29 <BMeph> zeno: Uh, (!!) is (almost) NEVER involved in an "efficient" solution. (Although, I may be excessively prejudiced... ;)
11:40:46 <dcoutts_> bos: nope, mind you I've been away
11:40:56 <bos> hmm, shame.
11:40:59 <dcoutts_> bos: I'll try and find him in the office this week
11:41:04 <bos> cheers!
11:41:08 <dcoutts_> bos: he can't get away :-)
11:41:33 <dcoutts_> bos: the only problem is he's at least as lazy as me, you have to grab him in person.
11:41:38 <zeno> BMeph: what would you suggest then?
11:42:06 <bos> dcoutts_: if we can just winkle a git repo out of him, he can go back to silence immediately :-)
11:42:13 <dcoutts_> bos: aye
11:42:58 <tnarg> Hi, folks. I am having trouble writing a simple http server using Network.HTTP 4000.0. receiveHTTP takes Stream s. I have a Handle from listenOn, but I can't figure out how to create a Stream s value from the handle.
11:43:14 <dcoutts_> bos: for the real impl I think we want a layer like dons's low level array layer
11:43:33 <dcoutts_> bos: something that provides the equivalent of ForeignPtr but for in-heap arrays.
11:43:35 <bos> the uvector lib?
11:43:49 <ziman> > let largest f = maximum . map f in largest (+1) [1..10]
11:43:50 <lambdabot>   11
11:43:54 <dcoutts_> bos: the low level byte array bits in/below uvector
11:44:08 <bos> ok, haven't looked at that recently.
11:44:20 <dcoutts_> bos: ie a byte array type with ops for getting/setting primitive types at byte offsets
11:44:34 <bos> sounds like a useful thing to factor out of uvector.
11:44:46 <dcoutts_> bos: so just like ForeignPtr where the user is responsible for bounds checking and alignment
11:44:55 <dcoutts_> but a movable heap array
11:45:00 <bos> right.
11:45:23 <dcoutts_> the construction functions would be in ST
11:45:53 <dcoutts_> though sadly for nhc it'd have to be implemented in terms of IO and unsafePerformIO
11:46:06 <dcoutts_> but it should otherwise be portable to nhc, hugs and ghc
11:46:08 <stepcut> I have an application which uses CPU while idle, but only if run it with runhaskell. Compiled  (even with -O0) it is fine. How would I debug this ?
11:46:33 <dcoutts_> stepcut: try compiled with the -threaded rts
11:46:58 <dcoutts_> stepcut: ghci/runghc/ghc -e use the threaded rts
11:46:58 <stepcut> dcoutts_: good point
11:47:36 <Megzlna> Why did Simon's new record system proposal get passed by with no action in 2003?
11:47:49 <dcoutts_> Megzlna: getting agreement is hard
11:48:10 <quicksilver> it's not just that, in my opinion.
11:48:13 <stepcut> dcoutts_: no dice. Even with -threaded, the compiled version is fine
11:48:19 <quicksilver> someone has to step up and do the work (at least to write a prototype)
11:48:20 <Megzlna> sometimes you just need to do something and screw all the newbies crying WAAA WAA BACKWARDS COMPATIBILITY
11:48:28 <Megzlna> because, time goes fast
11:48:42 <Megzlna> By now, 2008, nobody would even remember those original newbies
11:48:44 <quicksilver> SPJ is a finite resource, and I guess he found other things a more compelling use of his time.
11:48:49 <Megzlna> or their disagreement
11:48:59 <quicksilver> (and no one else felt their time was best spent implementing it)
11:49:02 <Megzlna> it would be long since past, and Haskell would not be destroyed as a language
11:49:04 <dcoutts_> stepcut: ask on the ghc users mailing list
11:49:17 <blackh> Megzlna: Can you give me a link? I am interested in record proposals.
11:49:26 <vixey> design and implement a Haskell-like language that is not worried about compatability
11:49:38 * quicksilver finds that with a decent lens library, haskell records no longer bother him at all.
11:49:40 <Megzlna> http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
11:50:06 <vixey> quicksilver, any lens code online?
11:50:09 <stepcut> dcoutts_: ok. The problem is the code base is pretty large, so I don't even know how to narrow it down to the problem area if I can use the profiler
11:50:25 <Megzlna> I will state that Haskell is over for me
11:50:50 <orbitz> what does that mean?
11:51:03 <mauke> HASKELL IS DEAD TO ME
11:51:08 <Megzlna> quicksilver: Can you write lense syntax please?
11:51:23 <vixey> I have no lambda-calculus
11:51:32 <conal> heh
11:51:50 <quicksilver> vixey: Data.Accessor is the most mature I guess
11:52:11 <quicksilver> vixey: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
11:52:11 <vixey> @hackage data-accessor
11:52:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
11:52:22 <orbitz> Megzlna: is haskelld ead to you?
11:52:32 <quicksilver> Megzlna: for the general idea, see this blog post : http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
11:52:34 <olsner> Is this the beginning of the third day of record syntax rants in #haskell?
11:52:44 <wchogg> orbitz: What does it mean for something to be ead to you?
11:52:47 <quicksilver> Megzlna: for an example implementation, see the link I just pasted to vixey.
11:53:08 <vixey> annoying thng about hackage is that I can't read the source code in the webpage
11:53:15 <orbitz> wchogg: i'm not sure yet, still working o na defitnion
11:53:22 <quicksilver> (what twanvl calls a 'functionarl reference' is a lens, by the way)
11:53:45 <Asztal> I miss the little "View Source" link :(
11:53:45 <Megzlna> quicksilver: Is the idiom realistic enough that you can remember it because it's good enough that you actually use it, and could write the equivalent of     f x = (Foo.name x) ++ "!"    <-- as simply as that?
11:54:51 <Megzlna> name is a field of the type of x's records
11:55:04 <Megzlna> which is Foo
11:55:10 <dolio> Lenses are just a way of making record operations more first class.
11:55:24 <quicksilver> Megzlna: for an example of me using them, see http://hpaste.org/8996
11:55:25 <athos> hi all
11:55:28 <dolio> They don't solve overloading of field names, if that's the only thing you absolutely care about as far as a language goes.
11:55:55 <Megzlna> it just casts doubt on the whole language
11:55:59 <quicksilver> although I chose slightly different names for my combinators.
11:56:00 <Megzlna> its such a fundamental failure
11:56:07 <hellige> anybody have a decent reference for the (a ->) monad?
11:56:14 <vixey> Megzlna: I hadn't really noticed somehowe
11:56:19 <quicksilver> it's such  a fundamentally *trivial* failure
11:56:22 <hellige> i "understand" it, but have no good intuition...
11:56:27 <dolio> Yes. It's a fundamental failure that hasn't been enough of an actual problem for anyone to do anything about it for years.
11:56:38 <vixey> Megzlna: I got distracted by the numeric system and unary negation syntax and how inexpressive typeclasses are ...
11:57:08 <teko> so we're all wasting our time here
11:57:19 <lament> how do you pronounce Megzlna?
11:57:25 <Megzlna> Meg Zull Nuh
11:57:28 <vixey> Megzlna: and how stuff like head/fromJust is the prelude
11:57:29 <teko> menstealia
11:57:30 <Saizan> hellige: maybe this http://www.haskell.org/all_about_monads/html/readermonad.html
11:57:31 <orbitz> what is Megzlna's latest complaint? i'm confused
11:57:44 <Saizan> orbitz: still the record system
11:57:58 <orbitz> why is it broken now?
11:58:02 <mrd> haskell has functional record update. that makes it light years better than SML.
11:58:06 <hellige> Saizan: oh jeez. i never realized that reader was just (a ->)
11:58:18 <wchogg> orbitz : Don't be coy.  You broke it.
11:58:22 <hellige> Saizan: haha. see? i *told* you i had no intuition about it! ;)
11:58:24 <orbitz> crap
11:58:30 <orbitz> wchogg: i was hoping noone would notice
11:58:35 <Saizan> hellige: hehe :)
11:58:38 <hellige> Saizan: but i do understand reader, so now i'm quite satisfied!
11:58:40 <vixey> mrd, it does ??
11:58:50 <bos> hellige: it's carefully hidden that way. it's sometimes written as (->) e, which obscures it equally well.
11:58:59 <teko> vixey: are type classes inexpressive ?
11:59:10 <Megzlna> I brought it up variouos times hoping somebody would have a solution cause I do want to use Haskell, but am totally unmotivated to learn it now
11:59:12 <mrd> vixey: yes?
11:59:15 <hellige> bos: well, i guess it shows (again) the value of a nice name. i just never made the connection.
11:59:18 <hellige> thanks guys!
11:59:52 <orbitz> Megzlna: is this a real problem, or another 'Data.Map.fromList isn't compiletime' complaints?
11:59:56 <vixey> mrd, what does SML have?
11:59:57 <Megzlna> quicksilver: I don't understand this example. You're not even using any of the same names.
12:00:02 <vixey> teko, I just don't like them
12:00:13 <vixey> teko, they are great for stuff like monad syntax b
12:00:15 <Megzlna> orbitz: It's a real, hardcore, serious problem
12:00:24 <vixey> teko,..but I couldn't do some things I wanted with them
12:00:28 <mrd> vixey: a very bothersome hole where that feature should be
12:00:47 <mrd> vixey: it's one of the main issues for successor ML, which will never get done
12:01:03 <vixey> mrd, I didn't know that at all, I thought it would be just the same thing you do in ocaml
12:01:05 <Saizan> complaining about non-overloaded fields is silly imo, but extending the record system to the point of making it usable as first-class modules is another story
12:01:09 <teko> vixey: how does it compare to C++ templates ?
12:01:15 <vixey> teko, I don't know
12:01:30 <orbitz> teko: typeclasses are not comparable to templates AFAIK
12:01:34 <mrd> vixey: if you want to talk about show-stopping missing features, the lack of functional record update literally stopped me in writing a large SML program, and I never was able to pick it up again
12:01:45 <mrd> haskell's records are at least usable
12:01:52 <pejo> mrd, why will it never get done?
12:01:53 <Megzlna> orbitz: data Foo = Foo { rotation :: Quat, name :: Int }    data Person = Person { name :: String }         <--- 2 types cannot have the same field name
12:01:59 <BMeph> zeno, Olathe: Try http://hpaste.org/13125
12:02:04 <quicksilver> Megzlna: the namespace thing doesn't bother me in the slightest
12:02:08 <lament> some sort of polymorphic records wolud be great
12:02:09 <mrd> pejo: lack of interest mostly, and the amount of work required to refactor to workaround that missing feature doesn't justify it
12:02:11 <quicksilver> if "name" is to be a first class haskell object
12:02:14 <orbitz> Megzlna: oh yeah, same in ocaml and friends.
12:02:15 <quicksilver> which is obviously what you want it to be
12:02:17 <vixey> mrd, how come you couldn't just define it as a new function ?
12:02:20 <quicksilver> it must have a principal type.
12:02:22 <arussel> why is this function type wrong: (x,y) -> z ?
12:02:31 <vixey> arussel, it's not wrong
12:02:35 <BMeph> Sorry it took so long - my pf-foo is weak. ;p
12:02:48 <vixey> arussel, there is no function of that type in the closed context but that doesn't make it wrong
12:02:49 <dolio> orbitz: Really? I would have expected OCaml to do better.
12:02:54 <mrd> vixey: because of the nature of record pattern matching and reconstruction, every time you change a record defn you must update every single place you construct the record
12:02:58 <orbitz> dolio: ocaml is weak
12:03:19 <lament> Megzlna: I agree that this is a concern. The short term solution is to tolerate the pain. The long term solution is to try to restructure the program to avoid the use of record types.
12:03:20 <arussel> vixey: so my definition is wrong: (x,y) = 2 ?
12:03:26 <vixey> arussel, yes
12:03:32 <wchogg> FFI question : I have a Haskell type I want to be storable & the corresponding struct has an array in it.  An actual array, not a ptr to one.  How can I poke the array into place?  I could just push a byte at a time off of the Haskell-side list, but that seems a little goofy.
12:03:43 <Megzlnaa> lament: Not using "values with fields" is not a solution
12:03:48 <vixey> mrd, I do not believe that is a problem of the language though...
12:03:50 <Megzlnaa> Every single damn language can do that
12:03:59 <mrd> vixey: it's not a problem in haskell
12:04:04 <mauke> Megzlnaa: fail
12:04:10 <Megzlnaa> Haskell is the single most retarded language in any form of modern day use when it comes to this
12:04:17 <Megzlnaa> There is nothing else as broken
12:04:24 <wchogg> mauke : is fail defined for the #haskell monad?
12:04:26 <lament> Megzlnaa: not really, for example Javascript has hashtables and nice syntactic sugar for them
12:04:26 <teko> Megzlnaa: just put the types in diff modules ??
12:04:32 <vixey> mrd, because you can pattern match like  f (G {x = y}) = .. and it doesn't matter if you added a new field?
12:04:35 <arussel> vixey: whatever pair, it returns 2. I don't understand the error message: Could not deduce (Num y) from the context
12:04:38 <lament> Megzlnaa: Haskell has hash tables too
12:04:44 <vixey> mrd, ... is that called functional update?
12:04:48 <mauke> arussel: 2 does not have the type z
12:05:05 <vixey> arussel, just don't write type annotations out
12:05:11 <vixey> arussel, Haskell will infer them
12:05:15 <Megzlnaa> Oh come on.. Haskell is supposed to be fast. Now I'm gonna use Hashes just because the language can't have F.x without name clashes?
12:05:20 <mrd> vixey: you can pattern match like that (something like (fun f (G{x=y,...})) but you can't update just 1 field
12:05:30 <vixey> mrd, ohh I see
12:05:37 <vixey> mrd, you can write a function to do it though
12:05:55 <mrd> vixey: yea you have to maintain a whole set of functions which each have the entire record repopulated except for 1 field
12:06:10 <mrd> and my record had dozens of fields.  so i just moved on.
12:06:14 <Megzlnaa> teko: Do you really think it's a happy scenario to make a new file for every single "data" ?
12:06:18 <Megzlnaa> that's ridiculous
12:06:19 <mrd> it's solvable, but wasn't worth the effort in that case
12:06:21 <vixey> mrd, I see it now
12:06:34 <arussel> vixey: you mean function type ? Graham Hutton wants me to write them down :-)
12:06:35 <teko> Megzlnaa: no
12:06:41 <vixey> mrd, but it sounds like a use for an object system
12:06:45 <BONUS_> are guards on case syntax H98?
12:06:51 <mauke> arussel: try (x, y) -> Integer
12:06:55 <vixey> arussel, well take someones advice
12:06:56 <mrd> vixey: or functional record update :)
12:07:09 <mauke> Megzlnaa: why?
12:07:16 <Megzlnaa> Well Simon obviously knew how big a problem it was and hence wrote...  http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
12:07:49 <teko> well if it breaks the lang then howcome ppl use it to write big projects ?
12:07:54 <vixey> mrd, idk.. I have never used records but it seems the argument you gave is the same as the argument for inheritance and so on.. I mean it's just about what needs to be changed often
12:07:56 <Megzlnaa> Yet there's always one of THESE assholes named "Henrik Nilsson"
12:07:58 <Megzlnaa> http://www.haskell.org/pipermail/haskell-prime/2006-March/000836.html
12:08:08 <Megzlnaa> ^--- lover of the status quo
12:08:10 <orbitz> Megzlnaa: you don't need it for every single data, just the conflicting ones
12:08:13 <dolio> Yes, everyone knows the record system sucks.
12:08:13 <vixey> Megzlnaa, maybe you should stop talking for a few hours?
12:08:22 <_roconnor> Megzlnaa: I think everyone knows records are a big problem in Haskell.  Perhaps we only disgree about exactly how big.
12:08:23 <vixey> Megzlnaa, It would probably be better
12:08:40 <mrd> vixey: i don't see it as an inheritance issue.  i just wanted names on the members of a tuple.
12:08:41 <dolio> And yet, people manage to write significant programs in spite of it.
12:08:55 <dolio> Whereas you're ranting without even having tried, as far as I can tell.
12:08:59 <wchogg> Calling random people you disagree with assholes is a bit ridiculous.
12:09:01 <orbitz> dolio: they're living in a dream world!
12:09:27 * orbitz awaits Megzlnaa to start stomping feet and demanding haskell live upto his D expectatiosn
12:09:31 <arussel> mauke: I understand why -> Integer works. But I don't understand why y doesn't. Why does haskell needs to know the return type when it can infer it from the function definition
12:09:32 <mrd> vixey: also that was around the time i graduated :)
12:09:36 <ozy`> Megzlnaa: well, even though I've gotten along fine so far without stumbling on the record syntax issue, you've convinced me that it's a fatal flaw, so I'll stop using Haskell. what should I use instead?
12:09:40 <mrd> vixey: got a little preoccupied
12:09:50 <vixey> mrd, is there some justification why SML didn't have this built in? because it seems like such an obvious thing to have
12:10:02 <dolio> If you want to implement Daan Leijen's record system for GHC, I'm sure we'll all be fine with that, though.
12:10:05 <mauke> arussel: it inferred it, and it was different from what you wrote
12:10:07 <Megzlnaa> ozy`: maybe you should become a house painter
12:10:15 <mauke> arussel: you can't just lie to the type checker and get away with it
12:10:24 <orbitz> that's very Zhivago of Megzlnaa
12:10:26 <mrd> vixey: don't know. as far as I can tell, just overlooked.
12:10:31 <orbitz> he generally prefers 'plumber' though
12:10:31 <wchogg> dolio : maybe even just include some kind of preprocessor like how arrow syntax used to be.
12:10:49 <lament> Megzlnaa: that nilsson message is pretty painful :(
12:11:02 <lament> haskell is fossilizing!
12:11:06 <dolio> I guess. That record system has some fancy type system stuff going on. I don't know how amenable to a preprocessor it is.
12:11:09 <Megzlnaa> lament: Yeah, and this kind of message is the reason we suffer today
12:11:15 <Megzlnaa> such a sad reason
12:11:16 <dolio> Row polymorphism and whatnot
12:11:30 <orbitz> Megzlnaa: not many peopel appear to be usffering though..
12:11:32 <mauke> just use OOHaskell
12:11:35 <arussel> mauke: (x,y) -> z doesn't mean it would return something ? and 2 being part of something then it is ok. What returned value would be allowed ?
12:11:42 <Megzlnaa> oohaskell dead
12:11:50 <wchogg> dolio : Oh, I didn't mean that particular record system.  Just something that would give Megzlnaa the syntax he wants.  It seems like you could do it.
12:11:55 <Megzlnaa> HUGS solves the problem
12:11:56 <ozy`> Megzlnaa: that sentence no verb
12:12:01 <mauke> arussel: no, it means it would return *anything*
12:12:07 <dolio> wchogg: Oh. Perhaps.
12:12:20 <Megzlnaa> it has something called "TRex"
12:12:26 <mauke> arussel: basically, the caller gets to choose which type they want, and the function has to provide it
12:12:40 <dmead> aka polymorphism :x
12:12:49 <Megzlnaa> Which is a totally new record system... one that simon based his proposal on, and had to scale back some of the features of.
12:13:05 <arussel> mauke: makes sens, I think I got it. thanks for taking the time to answer :-)
12:13:07 <Megzlnaa> http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.2
12:13:14 <dmead> new record syntax?
12:13:15 <dmead> what what?
12:13:29 <mauke> arussel: basically, the only value with type z is undefined (or equivalent)
12:13:39 <teko> but hugs is useless if u want speed
12:13:50 <Megzlnaa> yeah and no GHC extensions
12:14:01 <roconnor> newtype Point = Point { x,y :: Int }
12:14:05 <roconnor> is that legal
12:14:09 <roconnor> or part of their extension?
12:14:24 <dolio> I think that's H98 legal...
12:14:34 <roconnor> OMG
12:14:35 <mauke> doesn't look like H98
12:14:42 <roconnor> ooh
12:14:50 <dolio> Well, not newtype.
12:14:52 <wchogg> I don't _think_ that's H98.  What type would it be at the end of the day?
12:14:52 <dolio> But data maybe.
12:15:00 <wchogg> Right, with data.
12:15:46 <dolio> Yeah, works with data.
12:15:48 <wchogg> Pretty sure you'd have to do something like newtype Point = Point (Int,Int)
12:16:24 <ozy`> > do return undefined
12:16:25 <lambdabot>       No instance for (Show (t a))
12:16:25 <lambdabot>        arising from a use of `show' at <in...
12:16:36 <Megzlnaa> quicksilver: I really can't understand your Lense example man... there's no conflicts in the first place to resolve
12:16:37 <dolio> I figured the point was that you could define two fields of the same type at once.
12:16:47 <dolio> Which you can.
12:16:47 <lament> i blame haskell's mathy bias for neglecting record types. Who uses records in math?
12:16:49 <BONUS> uh, newtypes can have one field and one constructor
12:17:17 <quicksilver> Megzlnaa: no, it solves the other problem about record syntax, which is the clunky update syntax not being first class
12:17:19 <ozy`> Megzlnaa: why don't you ever give serious answers to my questions?
12:17:26 <Botje> lament: writing out tuples tends to pad one's paper size dramatically.
12:17:27 <mauke> Megzlnaa: do you think name clashes are the biggest problem with haskell's record system?
12:17:29 <quicksilver> Megzlnaa: it doesn't solve the namespacing problem, which isn't a problem.
12:18:11 <Megzlnaa> ozy`: I'm not going to say you should use language X ..
12:18:15 <mrd> you guys are way too nice to trolls
12:18:38 <Megzlnaa> cause I'm not a troll, but really into Haskell and learning it, and ran into this record thing
12:18:38 <quicksilver> Megzlnaa isn't a troll.
12:18:47 <quicksilver> Sure he's an irritating son of a bitch.
12:18:51 <quicksilver> but that's different.
12:18:58 <quicksilver> if he was a troll, I'd have banned him.
12:19:34 <lament> quicksilver: saying that the namespacing problem isn't a problem is quite a bit of POV
12:19:35 <Megzlnaa> quicksilver: Not a problem because you use files for each data with records?
12:19:44 <roconnor> Megzlnaa's whining is only 2x or 3x as bad as my whining about bitshifting in GHC.
12:19:51 <vixey> haa
12:20:13 * roconnor needs to test out ghc 6.10
12:20:17 <vixey> GHC is open source by the way
12:20:22 <dolio> Speaking of which, that module name length bug is another problem with records. :)
12:20:22 <mauke> data types are simply not that important in haskell
12:20:32 <roconnor> vixey: We made a patch back in the day
12:20:34 <vixey> mauke, data types are fundamental importance ...
12:20:36 <roconnor> vixey: it was rejected.
12:20:39 <quicksilver> lament: of course it is. When I say things, they are my opinion ;)
12:20:46 <quicksilver> lament: that's what opinion is, I guess.
12:20:49 <vixey> roconnor, doesn't stop it from working though
12:21:04 <quicksilver> Megzlnaa: I choose unique names for record fields.
12:21:05 <dolio> roconnor: What was the problem? Lack of inlining and specialization?
12:21:05 <Megzlnaa> reconnor: Try again? :)
12:21:07 <roconnor> doesn't stop what from working?
12:21:16 <vixey> your code
12:21:20 <quicksilver> it's no greater burden that choosing unique names for any other value.
12:21:21 <roconnor> dolio: something like that.
12:21:37 <vixey> most language I use I hacked some feature I want into the compiler
12:21:43 <roconnor> vixey: oh sure, the code works.  It is only a matter of efficency.
12:21:43 <vixey> (not haskell though..)
12:21:46 <quicksilver> If record fields are going to be first class (haskell makes them selectors, I would rather they were lenses) then they are going to live in the same namespace as all other values.
12:22:05 <quicksilver> so, you have to use that namespace, just like with constants and functions.
12:22:08 <Cale> quicksilver: Actually, I'm not certain about that.
12:22:14 <lament> quicksilver: it is my intuition that namespace problem (in its more general form) is one of just a few fundamental problems of language design, but i'm too lazy to argue or properly express it, and i'm going for lunch anyway :P
12:22:14 <quicksilver> the alternative (not making them first class) would be far worse.
12:22:29 <quicksilver> lament: the namespace problem *as a whole* is a very important one.
12:22:32 <Cale> quicksilver: It's possible that they could live in a slightly separate namespace, and yet still be first class.
12:22:41 <quicksilver> lament: but I wouldn't localise it to record fields.
12:22:51 <Cale> (and I think this would actually be the way to go)
12:22:52 <quicksilver> lament: I agree haskell's namespacing stuff is sub-perfect.
12:22:57 <Saizan> quicksilver: even if they are first-class they don't need to have the type of the record or of the field in them
12:22:59 <dolio> Cale: Well, they could be magic, row-polymorphic lenses. :)
12:23:11 <vixey> what's a row?
12:23:12 <Heffalump> Haskell's namespacing is really annoying, not just sub-perfect :-)
12:23:18 <quicksilver> you could overload them.
12:23:27 <vixey> in data Foo = X a b c d are a,b,c and d rows?
12:23:30 <quicksilver> personally I think overloading them might lead to really nasty type errors
12:23:35 <quicksilver> but it's obviously possible.
12:23:36 <Saizan> quicksilver: like having get :: forall label r a. {label := a | r} -> a
12:23:51 <quicksilver> Cale: two slightly separate namespaces isn't quite what I call 'first-class'
12:23:59 <Cale> I propose field names should all start with ' (and not be a character literal)
12:24:12 <dolio> vixey: It's like a (label,type) vector, or some such.
12:24:15 <Saizan> err, i forgot a Label label there
12:24:43 <roconnor> my interpretation of why our patch was rejected was because no changes are accepted unless they always make all programs better, but the inliner is so ad hoc that that is impossible, so no patches are acceptable.
12:24:46 <quicksilver> Cale: it's more "two houses both alike in dignity"
12:24:47 <Cale> and then their type ends up with the same name encased in it
12:24:57 <roconnor> but my version is coloured by my bitterness
12:25:04 <dolio> Or maybe forget the labels, if you're just going for unlabelled tuples.
12:25:08 <quicksilver> Cale: which admittedly could work. But I quite like having only one class of identifier if possible.
12:25:20 <quicksilver> Saizan: right, that's the overloaded version.
12:25:20 <Cale> quicksilver: It avoids the need to declare them.
12:25:31 <Megzlnaa> roconnor: What did your patch do exactly?
12:25:42 <Cale> quicksilver: (and that's about it)
12:25:43 <roconnor> anyhow, I still need to try ghc 6.10
12:26:04 <Heffalump> roconnor: I'm fairly sure that's not true about the acceptance criteria
12:26:10 <Heffalump> because lots of changes get made that make some programs worse
12:26:15 <roconnor> Megzlnaa: Something about making literal constants easier to inline or something.
12:26:49 <roconnor> Heffalump: I suspect core GHC developers get more leway.
12:26:51 <quicksilver> roconnor: I think it's probably true that "any patch which obviously makes all programs better is automatically accepted"
12:26:55 <blackh> Control.Exception.catch (return ()) (\e -> putStrLn $ show e)  <-- Why does this give "Ambiguous type variable 'e'"  ?!
12:26:59 <quicksilver> roconnor: and, your patch wasn't in that category.
12:27:02 <roconnor> quicksilver: :)
12:27:06 <quicksilver> roconnor: the converse isn't true, I'm sure.
12:27:17 <roconnor> ya you are right.
12:27:20 <quicksilver> roconnor: but rather "if it's not in that category, then someone has to think hard about the trade-off"
12:27:29 <mauke> blackh: because it doesn't know which type of exceptions you want to catch
12:27:44 <roconnor> and no one is available for such hard though.
12:27:47 <roconnor> thought
12:28:03 <Lemmih> blackh: catch :: Exception e => IO a -> (\e -> IO a) -> IO a.
12:28:20 <dolio> vixey: If you read Daan Leijen's record papers, the type system is extended with row variables and such, and you have a calculus of rows (like, <> is an empty row, and < label :: type | r > is a row if r is a row) and a then a type of records parameterized by rows (so if < label1 :: type1 , label2 :: type 2, ... > is a row, then { label1 :: type 1 , label2 :: type2 , ... } is a record).
12:28:29 <blackh> Lemmih: What should I do for a "catch all"?
12:28:38 <Lemmih> blackh: show (e::SomeException)
12:28:48 <vixey> dolio, oh right
12:29:04 <mauke> (\e -> print (e :: SomeException)) -- does SomeException implement Show?
12:29:06 <quicksilver> dolio: Daan's system is certainly clever, and I'd be very interested to play with an implementation of it.
12:29:07 <vixey> dolio, annd they are equal types modulo permutation?
12:29:23 <quicksilver> the idea of all that overloading does make me suspicious though
12:29:23 <dolio> Yeah, something like that.
12:29:27 <vixey> cool
12:29:31 <blackh> Lemmih: Thank you! You have solved my problem!
12:29:38 <quicksilver> that we'd get nasty error messages and it would be hard to work with in practice.
12:30:04 <quicksilver> still the "in practice" part indicates that we need an implementation to play with to know.
12:30:29 <dolio> Yeah.
12:30:35 <Cale> I really think that something very close to Daan's system is the right thing.
12:30:53 <quicksilver> I went through a period of being really annoyed by haskell's records.
12:30:59 <quicksilver> Although perhaps not as much as Megzlnaa.
12:31:03 <Cale> Me too.
12:31:06 <teko> @src \\
12:31:06 <lambdabot> (\\) = foldl (flip delete)
12:31:15 <quicksilver> but now I find that higher order constructs (like lenses) are just nicer than records.
12:31:15 <teko> @src delete
12:31:15 <lambdabot> delete = deleteBy (==)
12:31:25 <teko> @src deleteBy
12:31:25 <lambdabot> deleteBy eq x []        = []
12:31:25 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
12:31:30 <quicksilver> the point about a lens is that it abstracts the notion of 'record-like-think' away
12:31:41 <Megzlnaa> quicksilver: as you said, that solves extensibility, not namespacing
12:31:42 <Cale> But the naming issue turned out to not be as big a problem as I thought. The row polymorphism bit would certainly be nice though.
12:31:43 <quicksilver> and it needn't actually be a record, although it might be
12:31:49 <lament> lenses as in bananas paper?
12:31:58 <quicksilver> Cale: FWIW, you can also get polymorphism in lenses.
12:31:59 <mrd> the trouble with records is that its easy to get caught up in complex proposals
12:32:03 <vixey> no lament
12:32:10 <vixey> boomerang
12:32:21 <Cale> Megzlnaa: The namespacing thing can be solved without much help from the compiler though.
12:32:27 <quicksilver> Cale: "forall r . Lens r Int" is a perfectly useful kind of polymorphism.
12:32:30 <Saizan> http://www.equational.org/morrow/download.html <- here Daan implemented that system
12:32:30 <Cale> quicksilver: Well, yes.
12:32:41 <quicksilver> Cale: type-based rather than name based, but is that worse?
12:32:59 <Cale> quicksilver: It's not worse. I'd like something which was both though :)
12:33:05 <mrd> and before you know it you end up with subtyping in the language, and, bam
12:33:06 <Megzlnaa> "Code generation to OCaml. If ocamlc can be found, it is used to compile and execute expressions."
12:33:26 <vixey> cool it's got exists
12:33:51 <quicksilver> Cale: all the polymorphism I've needed in practice seems to be achievable with the * -> * -> * Lens type constructor.
12:33:59 <vixey> I don't like that  some   though
12:34:01 <dolio> Cale: Could you do both? I suppose you could reserve a new syntax for lenses.
12:34:28 <quicksilver> in a way, Lenses are the explicit dictionary version of Daan's system.
12:34:31 <Saizan> what's the first argument of Lens? the record?
12:34:33 <quicksilver> without some of the magic.
12:34:38 <quicksilver> Saizan: yes.
12:34:55 <quicksilver> and since I generally dislike type classes and like HOFs, I prefer Lenses.
12:35:11 <Megzlnaa> HOF?
12:35:16 <Saizan> so, in haskell you can't write something of type forall r. Lens r Int?
12:35:23 <quicksilver> sure you can
12:35:28 <vixey> it would make more sense if the typeclasses could be totalyl erased at compile time
12:35:37 <quicksilver> Saizan: yeah, my type was longer than that
12:35:52 <quicksilver> Saizan: I really meant "forall r . Lens r Int -> blah -> blah -> blah"
12:36:01 <dolio> Where %foo is something like :: a -> { foo :: a | r } -> (a , { foo :: a | r }), or whatever your lens type is.
12:36:04 <Saizan> ah ok
12:36:04 <quicksilver> Saizan: otherwise what I said doesn't make much sense.
12:36:30 <quicksilver> Saizan: the point is you can be polymorphic over the 'r', not knowing the exact type of the record, merely that it has an Int in it somewhere.
12:36:39 <quicksilver> Saizan: I believe that is the same as Daan's row polymorphism
12:36:39 <Cale> dolio: My idea is something like Daan's system, where the field labels refer to appropriate lenses.
12:36:45 <blackh> Megzlnaa: Higher Order Functions
12:36:50 <quicksilver> modulo not actually having field names.
12:37:00 <Cale> dolio: yeah...
12:37:23 <Saizan> quicksilver: well, you lack extension
12:37:35 <Cale> dolio: in fact, you could include all the record operations, and not have to put up with the horrible syntax which Daan's paper uses ;)
12:37:36 <dolio> Cale: Right. I was just thinking that you couldn't just stick them with regular alphanumeric identifiers, because there's no declaration to distinguish when you're talking about a record label.
12:37:45 <Cale> right
12:37:58 <Cale> So that's why you reserve 'namesLikeThis for that :)
12:38:04 <vixey> need more alphabets
12:38:23 <Cale> Oh, TH uses that too, doesn't it?
12:38:38 <quicksilver> Saizan: remind me what extension is?
12:39:06 <quicksilver> if "r" is an extension of "s" then there should be a Lens r s, I think.
12:39:13 <quicksilver> which shows how to project the s bit out.
12:39:21 <quicksilver> so I think lenses do model extension?
12:39:45 <quicksilver> (s needn't be a single field, it can be any substructure)
12:39:54 <Cale> quicksilver: But how do I use a lens to add a new field to records which don't have it?
12:40:11 <Megzlnaa> Cale: how does your idea which you just mentioned, not overcomplicate the simple usage of    f x = (Person@name x) ++ "!"    where @ goes into Person local namespace of fields
12:40:11 <Cale> (can't)
12:40:12 <Megzlnaa> The point being that a superpowerful lense system is great, but simple field access is bread and butter computing, and should not go against what haskell is good at, short programs.
12:40:27 <quicksilver> Cale: right, you can't do that, because my fields aren't named.
12:40:36 <Cale> Megzlnaa: It would look like  get 'name x
12:40:48 <quicksilver> Cale: but frankly I don't see the point in named fields.
12:40:53 <Cale> Megzlnaa: The 'name is a field label.
12:40:54 <quicksilver> Cale: I've probably missed something :)
12:40:55 <Megzlnaa> Cale: How does it know which type 'name is from then?
12:41:04 <Megzlnaa> 'name looks like a global
12:41:11 <Cale> Megzlnaa: It doesn't belong to any fixed type.
12:41:23 <Megzlnaa> okay
12:41:23 <lament> what's the type of get? :)
12:42:17 <dolio> get :: Lens -> Record -> Whatever
12:42:38 <Cale> lament: Something like  get :: forall l :: Label, r :: Row. l -> (l :: t | r) -> t
12:43:17 <Saizan> quicksilver: yeah, living in Reader x a is the same as having a constant of type x, the point is that having a lot of explicit arguments gets inconvenient, or so we fear
12:43:25 <Cale> (maybe with some kind inference there)
12:43:42 <Cale> er
12:43:47 <Cale> sorry, that's not quite right :)
12:43:59 <Cale> no, it is :)
12:44:28 <Cale> The l acts sort of as a lens, in that there are a number of operations like get which extract the useful operations on records from it.
12:44:53 <Saizan> with "('foo :: 'foo) :: Label"
12:45:21 <Cale> 'foo :: ('foo :: Label)
12:45:44 <Saizan> oh, yeah
12:46:29 <dolio> I wonder if this isn't easier to add to j/lhc.
12:47:06 <dolio> Since pure type systems are 'easy' to add new kinds to and such.
12:47:33 <quicksilver> Saizan: yes, that's a good response.
12:48:00 <quicksilver> Cale, dolio : somehow records seem too unimportant to need to fiddle with the kind system to fix. That's only a gut feeling though.
12:48:22 <Cale> quicksilver: I think we need to grow a decent kind system eventually anyway.
12:48:29 <quicksilver> I agree.
12:48:40 <quicksilver> but records aren't top of my list of reasons why :)
12:48:53 <Cale> Also, I wouldn't want to stop here
12:49:11 <Cale> Once you have extensible records like this, you're one step away from extensible variants.
12:50:03 <wchogg> Not sure what you mean by extensible variant
12:50:18 <dolio> wchogg: Like a record, only sums instead of products.
12:50:19 <Cale> wchogg: Rather than having many fields, you have many cases.
12:50:21 <Cale> yes
12:50:52 <wchogg> Right wasn't thinking you mean variant as sum type.
12:51:07 <Cale> This is what a lot of languages use for exceptions.
12:51:37 <Cale> You have an unbounded number of cases, you only ever want to handle some of them...
12:51:50 <Cale> (or all the rest uniformly)
12:52:22 <Cale> It would certainly be more convenient than the new polymorphic exceptions which seem to be a pain in the ass as far as I can tell ;)
12:53:26 <hoopy> so _:x:_ will match the second element of a 2 element list and bind that to x?
12:53:49 <Cale> yeah
12:53:57 <Cale> er
12:53:58 <yitz> hoopy: 2 or more element list
12:54:02 <Cale> yes
12:54:09 <hoopy> and _:x:_:_:_:_:_ is basically the same?
12:54:23 <Cale> hoopy: Except the list needs to be longer for that to match
12:54:36 <hoopy> then why does _:x:_ match a two element list?
12:54:40 <Cale> It would need to have at least 7 elements in that case
12:54:46 <hoopy> why wouldn't it need to be a 3 element list
12:54:48 <yitz> 6
12:54:59 <Cale> er, 6 yes
12:55:05 <tromp_> it matches any list of at least 2 elems
12:55:06 <Cale> (_:x:_) matches an at least 2 element list
12:55:07 <oklofok> hoopy _:x:[]
12:55:13 <hoopy> ahhhh
12:55:23 <Cale> It's easier to understand without all the blanks
12:55:28 <Cale> x:y:xs
12:55:32 <oklofok> the last on is the rest of the list, can be a zero-length list
12:55:39 <Cale> x matches the first element, y the second, and xs matches the rest
12:55:41 <hoopy> or an n-length list
12:55:47 <tromp_> x1:x2:xrest
12:55:51 <hoopy> gotcha
12:56:02 <hoopy> where xrest can be [] or infinitely large
12:56:15 <zeno> why does http://pastebin.com/m6b48df66 construct an infinite type? is there a better way to do this?
12:56:17 <tromp_> or undef:)
12:56:23 <oklofok> yeah and anything in-between
12:56:24 <oklofok> except 17
12:56:36 <hoopy> ;p
12:56:57 <Cale> zeno: looking...
12:57:15 <mauke> zeno: delete try l
12:57:28 <mauke> l :: [a], try :: Maybe a
12:57:35 <mauke> :t delete
12:57:36 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
12:57:42 <zeno> mauke: ah ok thanks
12:57:43 <mauke> therefore a = Maybe a
12:57:59 <Cale> zeno: findJust f xs = fmap msum (mapM f xs) ?
12:58:16 <Cale> Maybe I'm not understanding what this is meant to do :)
12:58:22 <yitz> @type delete
12:58:24 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
12:58:53 <vixey> :t let findJust f xs = fmap msum (mapM f xs) in findJust
12:58:54 <lambdabot> forall a (f :: * -> *) (m :: * -> *) a1. (Functor f, Monad f, MonadPlus m) => (a -> f (m a1)) -> [a] -> f (m a1)
12:59:13 <Cale> I just went based on the type.
12:59:17 <zeno> @src msum
12:59:17 <lambdabot> msum =  foldr mplus mzero
12:59:33 <zeno> @src mapM
12:59:33 <lambdabot> mapM f as = sequence (map f as)
12:59:42 <Cale> @src sequence
12:59:42 <lambdabot> sequence []     = return []
12:59:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:59:43 <lambdabot> --OR
12:59:43 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:00:08 <Cale> sequence takes a list of actions, and turns them into a single action which will run them all and collect a list of the results
13:00:27 <zeno> ok thanks
13:00:44 <Cale> mapM is like a for-each loop over the elements of the list it's given, mapping the function over the list to get a list of actions, which it sequences
13:01:17 <Cale> msum appears to be how you want to combine the Maybe values -- you're looking for the first "Just" value in the list, right?
13:01:45 <vixey> why not filter isJust ?
13:02:01 <Cale> vixey: Well, that doesn't have the same type...
13:02:12 <Cale> Other than that it's not bad :)
13:02:15 <Saizan> that findJust is going to perform much more side-effects than i'd expect
13:02:19 <vixey> that type confused me.....
13:02:36 <Cale> Which one?
13:02:45 <Cale> findJust :: ([a] -> IO (Maybe a)) -> [a] -> IO (Maybe a) ?
13:02:48 <vixey> forall a (f :: * -> *) (m :: * -> *) a1. (Functor f, Monad f, MonadPlus m) => (a -> f (m a1)) -> [a] -> f (m a1)
13:02:51 <Cale> oh
13:02:58 <Cale> Well, that's a little overgeneral
13:02:58 <vixey> why findJust is in IO?
13:03:07 <vixey> actually I don't khave any idea what is' for
13:03:19 <vixey> so maybe findJust is a bad name
13:03:39 <Cale> Saizan: aha!
13:03:45 <vixey> IO (Maybe a)  rather than  IO a ?
13:03:51 <Cale> Saizan: Yes, we could stop performing the actions at the first Just
13:04:02 <Cale> vixey: What if they're all Nothing?
13:04:05 <vixey> Cale, what about findJust :: ([a] -> IO (Maybe a)) -> [a] -> IO a
13:04:09 <vixey> oh I see
13:04:23 <vixey> yes very confusing
13:05:03 <Cale> findJust f [] = return Nothing; findJust f (x:xs) = do v <- f x; case v of Nothing -> findJust f xs; (Just y) -> return y
13:05:08 <quicksilver> this is a case for MaybeT isn't it?
13:05:12 <Cale> This has less effects.
13:05:25 <quicksilver> MaybeT IO will stop effects on the first Nothing
13:05:36 <Cale> quicksilver: That's not what we want.
13:05:41 <Cale> quicksilver: (it's the opposite)
13:05:49 <roconnor> IOT Maybe ?
13:05:49 <Cale> We want to stop effects on the first Just
13:05:59 <quicksilver> well that's msum in MaybeT IO
13:06:08 <Cale> That's true.
13:06:12 <quicksilver> I use it quite often
13:06:16 <quicksilver> although not with that name
13:06:18 <quicksilver> I just define
13:06:22 <Cale> I don't use MaybeT all that much :)
13:06:25 <vixey> MaybeT isn't broken?
13:06:29 <quicksilver> orElse :: m (Maybe a) -> m (Maybe a) -> m (Maybe a)
13:06:38 <quicksilver> which is MaybeT in spirit, although not in fact.
13:06:45 <Cale> vixey: I'm pretty sure it's okay.
13:06:52 <quicksilver> it's mplus conjugated through appropriate numbers of runMaybeT and MaybeT
13:06:57 <Cale> vixey: It doesn't suffer from the ordering problem which ListT does.
13:07:39 <yitz> vixey: I don't understand. MaybeT isn't in mtl.
13:07:46 <yitz> vixey: so you define it yourself
13:07:50 <quicksilver> I never use it in fact, because I don't have it installed.
13:07:53 <yitz> vixey: it's only broken if you do it wrong
13:07:55 <Cale> yitz: It's available on Hackage, iirc.
13:08:00 <quicksilver> But I use it in spirit, and recognise its patterns
13:08:06 <roconnor> is MaybeT in monadlib?
13:08:14 <quicksilver> in fact, the noise of MaybeT and runMaybeT is more than you want sometimes.
13:08:35 <Cale> I'm not really completely satisfied with any of the Monad libraries. :/
13:08:42 <roconnor> nope
13:08:43 <yitz> Cale: oh ok. so I would hope that the one on hackage isn't broken.
13:08:57 <Cale> yitz: It's just the obvious thing.
13:09:27 <Cale> ListT is what's broken.
13:09:52 <Cale> You need to do something a bit fancier to get a nondeterminism monad transformer which is actually a monad transformer.
13:10:04 * yitz looks for ListTDoneRight on hackage
13:10:06 <Cale> (which is what LogicT is for)
13:10:06 <quicksilver> MaybeT is just ErrorT where you ignore the left.
13:10:08 <vixey> LogicT!
13:10:24 <Cale> LogicT is really nice
13:10:29 <yitz> LogicT is ListTDoneRight?
13:10:41 <Cale> It's better than the ListTDoneRight which was on the wiki
13:10:51 <roconnor> ErrorT ()
13:11:12 <Cale> It's implemented using continuations, and is quite fast, and supports fair conjunction and disjunction operations.
13:11:23 <Cale> (in addition to the monadic ones)
13:11:26 <quicksilver> roconnor: together with a bogus Error instance for (), precisely.
13:11:26 <zeno> Cale: sorry my connection went bad.
13:11:32 <yitz> oh horrors, its CPS.
13:11:32 <mauke> type ListTDoneRightDoneRight = LogicT
13:11:39 <vixey> it's not CPS
13:11:39 <quicksilver> well "bogus" is a bit harsh
13:11:40 <roconnor> hmm
13:11:44 <quicksilver> "uninteresting"
13:11:46 <vixey> there is various implementations
13:11:46 <Cale> yitz: But you needn't worry about the implementation :)
13:11:59 <Cale> zeno: findJust f [] = return Nothing; findJust f (x:xs) = do v <- f x; case v of Nothing -> findJust f xs; (Just y) -> return y
13:12:01 <zeno> thanks for all help btw
13:12:11 <Cale> zeno: ^^ that one does less effects and stops at the first Just
13:12:37 <Cale> (though you might want to lay it out properly of course, I squished it on to one line ;)
13:13:55 <Cale> zeno: quicksilver pointed out that this is msum in the MaybeT IO monad, but I'm not sure if it's worthwhile downloading MaybeT from hackage just for that :)
13:14:02 * quicksilver wonders what it tells us about GHC's optimiser that a manual CPS transform often speeds code up.
13:14:14 <quicksilver> does a manual CPS transform effectively add a bit of strictness?
13:14:17 <zeno> Cale: i dont want it to try a value that f v = Nothing again though
13:14:18 <Cale> quicksilver: Well, it's like deforesting.
13:14:37 <Cale> zeno: I don't understand
13:14:47 <Cale> zeno: It never goes backwards in the list.
13:15:13 <Cale> zeno: Do you mean that you'd like to return the remainder of the list along with the result?
13:16:03 <quicksilver> Cale: so it removes a bit of boxing?
13:16:04 <Cale> zeno: The pattern matching throws away the first element of the list on each step.
13:16:14 <zeno> Cale: oh sorry misread it.  f is type [a] -> IO (Maybe a) though not a -> IO (Maybe a)
13:16:18 <roconnor> quicksilver: isn't the CPS transform analogous to using Dlists instead of lists?
13:16:20 <Cale> quicksilver: yeah, I suspect that's the main reason why
13:16:28 <Cale> zeno: Are you sure?
13:16:36 <Cale> er
13:16:38 <Cale> oh!
13:16:53 <Cale> So it takes the whole list...
13:17:05 <Cale> and then what is the recursive step meant to be then?
13:17:19 <Cale> What's the next list to try if this one gives Nothing?
13:17:20 <yitz> I do tons of stuff with ListTDR, it's not obvious how to do them with that LogicT thing.
13:17:22 <zeno> Cale: yeah one example would be picking a random value from the list and wrapping it in Just if it fits some quality
13:17:25 <yitz> looks much more complicated.
13:17:34 <quicksilver> roconnor: yes, but the specific reasons why DLists are a win are very specific. They're to do with (++) and the way it associates and multiple traversals.
13:17:48 <Cale> zeno: uhhh...
13:17:50 <quicksilver> roconnor: I don't think those comments carry over to uses of CPS in other cases.
13:18:07 <roconnor> quicksilver: so CPS does more than just associating (>>=)
13:18:12 <stepcut> this seems to use 2-5% of my cpu in ghci, though it is fine if compiled. Should the cpu usage be that high ? let idle = Control.Concurrent.threadDelay 1000000 >> idle in idle
13:18:42 <Cale> zeno: findJust f [1,2,3] will apply f to [1,2,3] and execute the resulting computation. If the result of that computation is Nothing, what's the next list to which findJust will apply f?
13:18:45 <Saizan> well, for monads you can in general simplify "return" by using CPS
13:18:47 <zeno> Cale: if the result is IO Nothing, then try again with f (delete value that was tried somehow)
13:18:59 <Cale> zeno: It tried the entire list.
13:19:24 <Cale> zeno: You're passing the whole list to f, and it's the only list you have.
13:19:50 <quicksilver> Saizan: why's that?
13:19:51 <Cale> So you either have to modify that list somehow, or take a list of lists as a parameter.
13:20:05 <Cale> (in which case, you might as well just take a single list of any type at all)
13:20:23 <Cale> Do you get what I'm saying?
13:21:08 <Saizan> quicksilver: in CPS return is simply function application, while with e.g. Either you need to construct a Right which will be immediatiely discared
13:21:13 <Cale> I don't know what you mean by (delete value that was tried somehow) -- I suspect if you can figure out what you mean by that, you'll know why you have a type error and how to fix it :)
13:21:49 <quicksilver> Saizan: ah, interesting.
13:22:10 <Cale> zeno: My suggestion is that findJust tries one element of the list at a time, and recurses on the tail of the list.
13:22:27 <Cale> zeno: this means that f just takes a single element of the list
13:22:43 <Cale> zeno: If you need that to be a list, then you could just pass a list of lists to findJust
13:24:25 <Cale> zeno: Could you perhaps give me an example of how your function is supposed to be used?
13:25:51 <zeno> Cale: sequentially doesnt work since it needs to allow any order (including random)
13:26:18 <Cale> Order?
13:26:27 <Cale> Order through what things?
13:26:38 <satchiii> hi, can anyone help me with this: http://hpaste.org/13130 ?
13:26:57 <Cale> zeno: I still have no idea what the next call to f will be
13:27:24 <Cale> zeno: If I call  findJust f [1,2,3], I know it'll call f [1,2,3]. What's the next call to f that it should make?
13:27:50 <Cale> satchiii: hmm
13:28:30 <Gracenotes_> is there an essential difference beetween import X and :m +X in ghci?
13:28:43 <Cale> Gracenotes: import X doesn't work in ghci
13:28:48 <Beelsebob> yes it does
13:28:50 <Beelsebob> and no there isn't
13:28:53 <Cale> it does?
13:29:01 <Cale> Is this a 6.10 thing?
13:29:03 <Beelsebob> it got added very recently as a synonym for :m +
13:29:05 <quicksilver> in recent versions.
13:29:23 <quicksilver> Gracenotes: import is the syntax to use in files, but it got added to ghci because people kept getting confused :)
13:29:26 <Cale> interesting
13:29:36 <Cale> It doesn't support the full syntax of import though :(
13:29:41 <Beelsebob> no
13:29:44 <Beelsebob> which is a shame
13:29:44 <Gracenotes> quicksilver: I can definitely see they're disparate, but I do find "import" a bit easier to type :)
13:29:44 <Cale> Prelude> import qualified Control.Monad as M
13:29:44 <Cale> <interactive>:1:0: parse error on input `import'
13:29:53 <orbitz> hrm, is (=~) no longer pat of Text.Regex.Posix?
13:30:04 <Beelsebob> Cale: yeh, that would be lovely
13:30:08 <mercury^> Why do case expressions not have type Monad m => m a, taking fail "something" if a pattern not listed occured?
13:30:08 <Cale> orbitz: I would be surprised if that was so.
13:30:16 <orbitz> i wonder waht i'm doing wrong then
13:30:23 <Cale> mercury^: because fail is already stupid enough
13:30:30 <mercury^> :(
13:30:33 <Cale> mercury^: It shouldn't be in the Monad class at all
13:30:36 <orbitz> Cale: i did :m + Text.Regex.Posix, :t (=~) days not in scope
13:30:43 <mercury^> Cale: but if it is there, why not use it?
13:30:44 <Cale> mercury^: Monads don't all support failure.
13:30:47 <orbitz> s/days/says
13:31:01 <quicksilver> orbitz: I think the typeclass magic part of text.regex is in a different module
13:31:06 <Gracenotes> Cale: is it replaceable? or should we have a subclass for FailMonad...?
13:31:07 <quicksilver> because it annoys some people
13:31:07 <byorgey> MonadPlus m => m a  or MonadZero m => m a  could be reasonable though.
13:31:07 <pchiusano> is there any reason Functor's fmap is called fmap instead of just map?
13:31:11 <quicksilver> (not sure which one)
13:31:14 <yitz> mercury^: use _ -> ... at the end
13:31:15 <mercury^> Cale: they aren't mathematical monads. I see that. But why not use them for what they are?
13:31:23 <byorgey> pchiusano: yes, because map was already taken =(
13:31:30 <Cale> mercury^: Another problem is that this makes all case expressions monadic.
13:31:34 <quicksilver> mercury^: because, e.g., State and Reader have no useful definition of failur.
13:31:36 <Cale> Which is bad, isn't it?
13:31:38 <orbitz> quicksilver: i'm following RWH here, AFAIK.  when i do "test foo" =~ "foo" :: Bool i get not in schoope as well. i'm on 6.10
13:31:42 <quicksilver> (and they're not the only two examples)
13:31:49 <svat> @pl (\x -> x == reverse x)
13:31:50 <lambdabot> ap (==) reverse
13:31:53 <svat> what is ap?
13:31:55 <mercury^> Cale: they are sort of monadic already. Just that all failure is IO failure.
13:32:02 <pchiusano> byorgey: but why not have the List implementation of Functor just contain the existing map implementation?
13:32:03 <Cale> mercury^: What if I just want my case expression to produce a number?
13:32:04 <byorgey> pchiusano: well, and the reason that the list map isn't just fmap is, I suppose, because newbies might be confused by error messages about Functor if they used map wrong
13:32:07 <orbitz> :t ap
13:32:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:32:09 <Cale> mercury^: and not a Maybe number?
13:32:21 <byorgey> pchiusano: I totally agree with you, though.
13:32:40 <orbitz> actually no, i' mnt on 6.10
13:32:45 <orbitz> i'm on a much odler verison, my b
13:32:45 <quicksilver> orbitz: I think you need Text.Regex.Base as well
13:32:50 <mercury^> Cale: can you give a concrete example where the new case would be hindering?
13:32:53 <pchiusano> byorgey: did typeclasses exist when map was first defined?
13:32:58 <Cale> If case was monadic, then basically you couldn't have functions which pattern matched and weren't monadic.
13:33:01 <Gracenotes> :t liftM
13:33:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:33:07 <Cale> For instance, 'not' would be monadic.
13:33:17 <byorgey> pchiusano: I think so, yes.
13:33:20 <Cale> not x = case x of True -> False; False -> True
13:33:28 <Cale> So what type does not have now?
13:33:37 <mercury^> Cale: you can give a complete case analysis for not.
13:33:39 <Gracenotes> hm. is there a huge difference between liftM and ap?
13:33:39 <Cale> not :: (MonadZero m) => Bool -> m Bool
13:33:44 <mercury^> So the case would not be monadic.
13:33:46 <pchiusano> byorgey: hmm, ok
13:33:55 <Gracenotes> after all, ap is just a generalization of liftM, no?
13:33:56 <yitz> not x = fromJust $ case x of True -> False; _ -> True
13:34:02 <orbitz> quicksilver: looks like it was jsut my ghc version, i was suepr old
13:34:06 <svat> orbitz: thanks, where is "ap" defined?
13:34:07 <Cale> mercury^: I prefer just adding a default case to the end when it's needed.
13:34:10 <yitz> seems a bit of a waste though
13:34:34 <Cale> mercury^: Also, how do you write head?
13:34:35 <quicksilver> orbitz: that syntax (=~) has worked since at least 6.6
13:34:41 <Cale> Or fromJust?
13:34:43 <quicksilver> orbitz: but I think it's moved around in terms of which module you find it in.
13:34:44 <Beelsebob> Gracenotes: yes, but you shouldn't use either -- liftM is better called <$>, and ap is better called <*>
13:34:53 <orbitz> quicksilver: i'm on 6.4 here (need to update my freebsd so bad)
13:35:02 <Cale> I suppose you can give a complete case analysis and use error.
13:35:05 <quicksilver> orbitz: oh, OK, it might not go back that far :)
13:35:08 <orbitz> svat: i don't nkow
13:35:10 <mercury^> Cale: one could write head as head (h:t) = h then. It'd have type Monad m => [a] -> m a which seems nice.
13:35:13 <orbitz> quicksilver: hehe
13:35:16 <mercury^> I _want_ head to have that type.
13:35:23 <Cale> mercury^: I don't.
13:35:24 <byorgey> svat: Control.Monad
13:35:38 <svat> byorgey: thanks
13:35:39 <quicksilver> mercury^: except, there is nothing monadic about that
13:35:41 <Gracenotes> Beelsebob: when you want to use them in an infix fashion, presumably
13:35:42 <quicksilver> it's just about failure
13:35:43 <Cale> mercury^: The class you're looking for is called MonadZero and unfortunately no longer exists, btw.
13:35:57 <quicksilver> so you might as well call it Failable f => [a] -> f a
13:36:06 <Beelsebob> Gracenotes: well no, if you don't want them infix, then still, use fmap and (<*>) -- then you don't rely on Monad
13:36:10 <Beelsebob> only Functor and Applicative
13:36:10 <Cale> Yeah, this monads-as-failure idiom is misleading.
13:36:12 <quicksilver> except that Maybe is a totally general specification for Failure
13:36:15 <Beelsebob> so it's more general
13:36:19 <quicksilver> in which case you might as well just use Maybe
13:36:23 <quicksilver> [a] -> Maybe a
13:36:24 <Gracenotes> hm
13:36:30 <Cale> Right. Maybe is the right way to express failure.
13:36:30 <quicksilver> which is of course a sensible type for it ;)
13:36:51 <mercury^> quicksilver: combine is needed to go on doing something meaningful with the result.
13:36:51 <quicksilver> there is no need for a Failable class when the concrete type is good enough
13:37:04 <quicksilver> mercury^: sure, and Maybe is indeed a Monad
13:37:06 <quicksilver> so that's fine.
13:37:11 <quicksilver> @quote initial
13:37:11 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
13:37:18 <quicksilver> mckinna++ # very smart man
13:37:59 <mercury^> quicksilver: yes, but why use Maybe when an arbitrary monad works and allows you to use head in IO comfortably without any fromJust hassle.
13:38:00 * vixey I don't understand that...........
13:38:16 <Cale> mercury^: case.
13:38:21 <Saizan> Maybe doesn't keep the only thing that's good about fail, the error message
13:38:22 <Cale> Or maybe
13:38:38 <yitz> Saizan: so use Either
13:38:42 <Saizan> (which contains the line number by default)
13:40:15 <Cale> mercury^: What about an arbitrary applicative functor?
13:41:09 <Cale> mercury^: Monads are not *that* fundamental. They're a nice technique for giving different libraries a bit of the same interface, but they're not the only technique. We give them enough special syntax as it is, I think.
13:41:13 <yitz> what are some good simple examples of useful applicatives that are not monads?
13:41:29 <mercury^> Cale: how would you represent failure in an applicative functor?
13:41:32 <zeno> Cale: sry had to go a bit.  you were right though my types were wrong, heres what i wanted (and works) http://pastebin.com/m706b3ca5.  thanks a ton
13:41:43 <yakov_> hello
13:41:54 <Cale> mercury^: How would you do so in an arbitrary monad?
13:42:15 <mercury^> Cale: the typeclass specifies a fail, so that should work.
13:42:16 <Cale> yitz: Some of Conal's new FRP stuff is morally a monad, but it seems impractical to actually write an instance.
13:42:20 <yakov_> could anybody give me a pointer on how to make cabal package with *.hsc files? i'm using Makefile at the moment
13:42:31 <Cale> yitz: Ziplists are the common example.
13:42:31 <yitz> Cale: not too simple I think
13:42:49 <Cale> mercury^: But fail shouldn't be there.
13:42:51 <yakov_> i'm searching haskell.org with no luck, does cabal support hsc files?
13:42:54 <zeno> still feels like something that could be one line using stuff like msum though :)
13:43:01 <Cale> mercury^: fail should be in its own class.
13:43:02 <mercury^> yitz: lists with [a,b,...] <*> [c,d,...] = [a c, b d, ...]
13:43:38 <yitz> so zipWith ($)
13:43:47 <Cale> zeno: Using delete suggests to me that this is a bit inelegant.
13:43:51 <quicksilver> Cale: ziplists are a poor example.
13:44:02 <mercury^> Cale: I don't argue against that. But can we agree on that there should be such a class and that it would make sense to have everything that can fail to return something from that class instead of many operations silently returning io failure?
13:44:03 <vixey> more like  f <- left; x <- right; return (f x)
13:44:03 <quicksilver> Cale: they are monadic over streams.
13:44:04 <Cale> zeno: delete is one of those functions on lists which you want to try to avoid
13:44:20 <quicksilver> yitz: the only interesting example I know is certain clever parsers.
13:44:27 <zeno> Cale: i dont want it to try a value that produces Nothing twice
13:44:47 <Cale> mercury^: But that's a lot of fanciness for what amounts to not quite as much expressiveness...
13:45:04 <yitz> quicksilver: ok. so alternative stuff?
13:45:59 <Cale> zeno: You should have select return the depleted list while it's picking the element.
13:46:14 <Cale> zeno: That is, perhaps  [a] -> IO (a, [a])
13:46:53 <Cale> Then you won't incur an Eq constraint, and you won't be doing O(n) comparisons on every iteration.
13:49:50 <mercury^> Cale: not much I can say against your last argument except that I deem it a nice enough property for the types of functions not to lie to justify that fanciness.
13:51:23 <Cale> We should have a standard name for the embedding  (MonadPlus m) => Maybe a -> m a  and such.
13:51:53 <Cale> maybe mzero return  isn't *so* bad though.
13:52:27 <Cale> Similarly, I often need  foldr mplus mzero
13:52:45 <zeno> Cale: how about this? http://pastebin.com/m6d914630
13:53:40 <Cale> zeno: hmm...
13:55:09 <Cale> zeno: Wait a minute.
13:55:10 <sam_> My phone operator is blocking me to use three computers in my network. They only allow 2. Do you know how to solve this problem? I observed that I can use google, which means that G has some technology which passes my operator's block. I cannot use any other internet page
13:55:15 <Cale> zeno: Your f is pure now!
13:55:24 <Cale> zeno: You can just map f over the list.
13:56:00 <yitz> sam_: use a nat router
13:56:32 <Cale> zeno: (and you don't *really* need IO to select random elements, but I don't know, you might have other effects you're worried about there)
13:56:51 <dons> sam_: entirely wrong channel to ask though
13:57:05 <orbitz> any suggestions for the best tool to parse some CSV-like data?  It wil look liek (v1, v2, v2, v4) where each one may or maynot be quoted with '
13:57:06 <zeno> Cale: no other possible effects, but how can you select random elements without IO?
13:57:09 <yitz> uh, yeah, dons is right
13:57:14 <Cale> zeno: Using a StdGen
13:57:20 <Cale> :t randomR
13:57:21 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
13:57:30 <satchiii> anyone familiar with SYB? http://hpaste.org/13130
13:57:42 <Cale> It takes a range, and a StdGen, and gives you a pseudorandom element in that range, and a new StdGen
13:57:59 <Cale> (or other random generator, if you really want to use something else)
13:58:11 <mercury^> But that involves some initializing of the StdGen by IO operations I presume?
13:58:28 <Cale> Well, you can make one by hand, but the most common thing is to use newStdGen
13:58:30 <Cale> which is in IO
13:58:50 <yitz> orbitz: you can strip the () and use a csv tool from hackage
13:59:19 <orbitz> yitz: thanks
13:59:20 <Cale> You can also use MonadRandom, which is available on Hackage, if the thought of threading a StdGen along seems tedious to you
13:59:37 <FunctorSalad> couldn't you put your stuff inside Reader StdGen?
13:59:45 <FunctorSalad> and only have IO at main
13:59:48 <Cale> FunctorSalad: More like State StdGen
13:59:50 <yitz> MonadRandom++
13:59:52 <zeno> was using randomSelect l = do i <- getStdRandom $ randomR (0, maxIndex l);return (l !! i)
13:59:58 <FunctorSalad> Cale: oh, right
14:00:04 <BONUS> monads mo problems
14:00:11 <FunctorSalad> @stc MonadRandom
14:00:12 <lambdabot> Source not found. My pet ferret can type better than you!
14:00:15 <FunctorSalad> @src MonadRandom
14:00:16 <lambdabot> Source not found. Maybe you made a typo?
14:00:16 <Cale> zeno: right, getStdRandom is a strange function.
14:00:45 <Cale> zeno: It's more common to use newStdGen, and then pass the generator into the pure function you're using.
14:01:05 <FunctorSalad> , typeOf "foo"
14:01:12 <lunabot>  [Char]
14:01:22 * Cale wonders where mmorrow is :)
14:01:32 <Cale> I want to ask him to write some TH magic :)
14:01:32 <FunctorSalad> that could be a replacement for apparent lack of @ for the lunabot :)
14:02:11 <Cale> FunctorSalad: He has a quasiquoting thingy for it too, but I forget what that's called
14:02:16 <FunctorSalad> , typeOf (*2)
14:02:17 <zeno> Cale: ah ok, thanks
14:02:19 <lunabot>  Integer -> Integer
14:02:23 <Cale> , [$ty| "foo" |]
14:02:30 <mercury^> Does anyone reading at the moment still oppose fallibility of every function being visible in the type?
14:02:34 <lunabot>  [] Char
14:02:42 <Cale> , [$ty| show |]
14:02:47 <lunabot>  forall a . Show a => a -> String
14:02:52 <FunctorSalad> nice
14:03:00 <Cale> mercury^: Well, Haskell is a partial language.
14:03:06 <FunctorSalad> it infers the most general type?
14:03:15 <FunctorSalad> , [$ty| (*2) |]
14:03:21 <lunabot>  forall a . Num a => a -> a
14:03:22 <vixey> being visible ? I don't understand
14:03:24 <Cale> I think it just hijacks GHC's typechecker
14:03:26 <mercury^> Cale: I'm not proposing elimination of bottom if that's what you mean.
14:03:29 <quicksilver> mercury^: enforcing totality of all case matches is a great idea, but it doesn't work.
14:03:54 <quicksilver> mercury^: it's too common a situation to have a value which you know has a particular constructor or set of constructors
14:03:55 <Cale> mercury^: The point is that it's sort of what you are proposing ;)
14:03:58 <quicksilver> but the type system doesn't know that.
14:04:12 <quicksilver> it's too painful to define a fresh type for every possible subset of constructors.
14:04:35 <Cale> quicksilver: Or you don't actually know, but if it's not some constructor of your choice, you don't mind the program failing.
14:04:42 * quicksilver nods
14:04:58 <Cale> (better than going into a loop, anyway)
14:07:19 <quicksilver> mercury^: a better solution by the way, is Catch
14:07:23 <mercury^> I don't think I follow. head at the moment violates the law that more defined values result in more defined values, if you denote exceptions as bottom. My proposal would fix that, and I don't see why it is impossible to implement.
14:07:37 <quicksilver> (a software package by ndm which checks you do this right)
14:07:38 <vixey> what is your proposal
14:07:38 <Cale> I look at uses of things like head and fromJust as assertions. It could be argued that they should be more visually distinguished as being possibly troublesome.
14:08:03 <quicksilver> mercury^: what? head doesn't violate monotonicity.
14:08:04 <vixey> There are languages that do not have effects like nontermination/partiality in them
14:08:07 <quicksilver> mercury^: show an example?
14:08:08 <vixey> They are not haskell ...
14:08:20 <Cale> But sometimes you really do want to say "if this thing is not a Just, something has gone horribly wrong and I don't mind the program dying"
14:08:59 <vixey> Cale, I find these situations to be cause by inexpressive type system
14:09:03 <mercury^> Cale: in that case you can embed the computation in IO.
14:09:11 <zeno> Cale: hmm cant tell from http://www.zvon.org/other/haskell/Outputrandom/newStdGen_f.html how to make a pure function taking a IO StdGen return a number 0 to x
14:09:18 <Cale> mercury^: That's awkward.
14:09:20 <vixey> xdo you?
14:09:22 <gwern> > head []
14:09:24 <lambdabot>   * Exception: Prelude.head: empty list
14:09:28 <gwern> >  [] !! 0
14:09:30 <lambdabot>   * Exception: Prelude.(!!): index too large
14:09:32 <Cale> mercury^: I think I'd rather just go into an infinite loop then.
14:10:01 <quicksilver> mercury^: can you explain how you think head violates monotonicity?
14:10:01 <gwern> hm. I guess there is no reason to use !! 0 than head, then
14:10:13 <mercury^> @let head' [] = fail "head': empty list"; head' (h:t) = return t
14:10:15 <lambdabot>  Defined.
14:10:19 <Cale> zeno: btw, that zvon reference is really old and out of date.
14:10:26 <gwern> > take 1 []
14:10:27 <lambdabot>   []
14:10:38 <bos> zeno: there's material on working with pseudo-random numbers in Real World Haskell, http://book.realworldhaskell.org/
14:10:39 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:10:51 <zeno> bos ok thanks a ton
14:11:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
14:11:03 <gwern> this Dr. Haskell of neil's is pretty interesting
14:11:05 <Saizan> > randomRs (0,1) (mkStdGen 42)
14:11:06 <lambdabot>   [1,1,1,0,0,1,0,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,...
14:11:14 <Cale> zeno: Somewhere up in IO, you'll do g <- newStdGen
14:11:26 <gwern> has anyone else used Dr. Haskell? seems to give decent results on the darcs srouce
14:11:26 <Cale> zeno: Then you pass g as a parameter to functions which need random numbers
14:11:29 <zeno> getting that book (hardcopy) for xmas btw :)
14:11:30 <augustss> mercury^: Haskell cannot possibly violate monotonicity. No implementable language can.
14:11:32 <zeno> (new to haskell)
14:11:32 <mercury^> quicksilver: ah sorry, it might not.
14:11:43 <mercury^> yeah, my fault
14:11:43 <quicksilver> mercury^: *nod*
14:11:57 <quicksilver> putting everything in IO is a horrible solution to anything.
14:12:01 <vixey> haha
14:12:11 <quicksilver> incomplete pattern matches should only be used when you know it won't actually happen
14:12:20 <quicksilver> and 'Catch' can tell you if you were right.
14:12:27 <dv_> how can I "un-import" Prelude?
14:12:39 <quicksilver> head on a list you know to be non-empty is a good simple xample
14:12:49 <vixey> dv_, yeah
14:12:49 <quicksilver> a separate type for non-empty lists is a hassle
14:12:52 <quicksilver> (although possible)
14:12:56 <vixey> dv_, import qualified Preludue
14:12:59 <gwern> hm. eta-reduce == pointlessify?
14:13:25 <vixey> gwern: eta reduce  \x -> f x  ~~> f
14:13:29 <Cale> Hacking on GHC is such a daunting proposition...
14:13:30 <vixey> everywhere
14:13:39 <mercury^> quicksilver: so you think that by using head the programmer should give a guarantee that it will not be used on empty lists?
14:13:47 <vixey> Cale, yes :(
14:13:57 <vixey> I found this also
14:13:58 <gwern> vixey: ok, so that's what I thought it was. dr. haskell reduces more than a hundred pointlessifying for darcs...
14:14:04 <vixey> it is definitely a fault of the implementation
14:14:14 <Cale> mercury^: yeah, unless the programmer does not care about the nontermination when the list is empty
14:14:15 <vixey> i.e. there is no reason a haskell implementation has to be complex
14:14:42 <gwern> ehc proved haskell implementations can be simple :)
14:14:57 <vixey> gwern, maybe it means als    f a b c x = (...) x into  f a b c = ...
14:15:07 <vixey> EHC is weird.. it's all attribute grammars
14:15:29 <gwern> vixey: the sttribute grammars annoy me because they make it hard to cabalize
14:16:56 <gwern> the pre-processing calls make it a little difficult; I think I decided that one would need to either hack setup.hs or use the obscure GHC pre-processing option
14:17:04 <zeno> bos31337: do you know which chapter its in?
14:17:21 <kosmikus> gwern: or include the preprocessed sources in the tarball?
14:17:37 <Cale> zeno: He'd better know, he's one of the authors :)
14:17:39 <gwern> kosmikus: madness!
14:18:12 <gwern> I don't want to live in a world where the sdist tarball needs special treatment!
14:18:38 <kosmikus> gwern: are you seriously trying to cabalize EHC? have you been talking to upstream about this?
14:18:39 <vixey> it doesn't take a lot of work to implement haskell does it?
14:19:34 <gwern> kosmikus: not right now, I'm not. after discussing how hard it'd be to get bnfc cabal support, I decided to move on. (I don't have as much energy for cabalization as I used to)
14:19:37 <Cale> vixey: hmm... how many extensions?
14:19:45 <gwern> although I fairly sure they wouldn't object
14:19:54 <Cale> vixey: To me, it seems like a rather big project
14:20:02 <mercury^> Ok, I think I am almost convinced now that if you include buttom, you might as well have some functions fail by returning it and force the programmer to implement it differently if he wants more flexible behaviour on failure.
14:20:12 <kosmikus> gwern: well, sooner or later there will be an official release, I hope
14:20:16 <vixey> yeah I guess so
14:20:47 <gwern> huh. I didn't know function names could start with '_'
14:20:59 <ddarius> Why wouldn't they be able to?
14:21:02 <Philippa> gwern: heh. Yeah, though it's highly unrecommended
14:21:05 <gwern> (guess that isn't a dr. haskell bug after all :)
14:21:21 <Philippa> ddarius: most people get told "variable names start with a lower case letter"
14:21:22 <gwern> ddarius: well, it's just _ always seemed like a special keyword to me
14:21:29 <ddarius> Philippa: For parameter names, it indicates to GHC that the parameter is unused.
14:21:30 <Cale> mercury^: yeah. You can do things like have the compiler prove that certain things are total, and require programmer-supplied assertions/proofs when this can't be done... but that's a bit more than we're after at the moment :)
14:21:35 <Philippa> ddarius: I know :-)
14:21:49 <gwern> I only just learned that you could doo stuff like 'fst (one,_two) = one', afetr all
14:24:02 <gwern> @pl f x y = z (x y)
14:24:03 <lambdabot> f = (z .)
14:25:54 <Raevel> @type (id .)
14:25:56 <lambdabot> forall b a. (a -> b) -> a -> b
14:27:38 <ddarius> Woo.  Richard's on my side.
14:27:58 <gwern> ddarius: sure, but how many divisions does he have?
14:28:09 <mm_freak> never type 'fix id' into ghci
14:28:27 <Raevel> mm_freak: MUST DO IT
14:28:41 <mm_freak> it almost crashed my system
14:28:45 <Raevel> Not in scope: `fix'
14:28:50 <Raevel> *phew*
14:28:51 <mm_freak> :m Data.Function
14:28:54 <gwern> Data.Function, iirc
14:28:57 <gwern> > fix id
14:28:59 <lambdabot>   * Exception: stack overflow
14:29:21 <mm_freak> GHC 6.10.1 doesn't stack-overflow
14:30:39 <gwern> mm_freak: ghc 6.10 also messes up threads in a bad way for mueval
14:30:45 <gwern> I consider it a net loss
14:31:21 <sjanssen> gwern: oh, what sort of thread issue does 6.10 have?
14:31:59 <mm_freak> by now i haven't had any problems with GHC 6.10
14:32:01 <gwern> sjanssen: I covered it on -cafe, but a looping thread means other threads don't get to run at all with -N1
14:32:11 <gwern> sjanssen: you can see why this is death for mueval
14:32:30 <mm_freak> gwern: a looping thread like ?
14:32:45 <gwern> mm_freak: let f = x + 1 in f, iirc
14:32:51 <gwern> > let f = x + 1 in f
14:32:53 <lambdabot>   x + 1
14:33:04 <gwern> (oh wait, no, that wasn't it)
14:33:16 <sjanssen> gwern: this is the case with all versions of GHC
14:33:20 <gwern> > let f = f + 1 in f -- hm
14:33:35 <lambdabot>   thread killed
14:33:38 <Saizan> lambdabot is on 6.8, no?
14:33:40 <gwern> there we go
14:33:47 <mm_freak> yeah  if your thread doesn't garbage-collect, other threads don't get to run
14:33:58 <gwern> Saizan: lambdabot itself has been updated for 6.10, I think, but the lb mueval is still 6.8
14:34:02 <mm_freak> this has nothing to do with GHC 6.10
14:34:10 <gwern> otherwise we would no longer have lb handy
14:34:24 <gwern> mm_freak: then why did -N1 work with 6.8?
14:34:27 <kosmikus> I actually find it strange that fix id would cause a stack overflow
14:34:35 <osfameron> is this a sane way to thread coordinates through a grid? http://hpaste.org/13131
14:34:55 <gwern> you can say all you like that 'oh, it's always been that way', but I've locked my computer several times with 6.10 when the same expression did not lock with 6.9
14:34:58 <gwern> *6.8
14:35:18 <osfameron> (This is related to the crossword task I mentioned earlier... this works but I'm sure there are more elegant ways too)
14:35:37 <mm_freak> gwern: good question  maybe GHC 6.8 had more GC spots
14:35:55 <mm_freak> kosmikus: it shouldn't  i'd rather expect it to eat heap
14:35:56 <sjanssen> gwern: well, GHC 6.10 might tickle the code in a slightly different way, but it is definitely true that a non-allocating thread will hang all other threads
14:36:02 <mm_freak> and that's how it performs for me
14:36:10 <sjanssen> mm_freak: it is actually allocation that allows other threads to run, not GC
14:36:36 <mm_freak> sjanssen: doesn't GC do that, too?
14:37:25 <b_jonas> if you don't allocate anything, why would GC need to run?
14:37:40 <mm_freak> b_jonas: to free unused memory
14:37:58 <b_jonas> yeah, it would need to
14:38:04 <sjanssen> mm_freak: I believe the GC only runs when an allocation is attempted
14:38:06 <b_jonas> but I'm not sure if it's actually done
14:38:14 <b_jonas> I mean it's the same as with thread switching
14:38:20 <mm_freak> consider a long algorithm consuming a finite list slowly  it could gradually free part of the list
14:38:45 <sjanssen> mm_freak: yes, but if the algorithm doesn't allocate memory all other threads will hang
14:38:51 <b_jonas> what would it gain with freeing if it doesn't allocate anything new?
14:38:51 <BMeph> mm_freak: 'fix id' == Omega ;)
14:39:08 <vixey> :h 'fix id'
14:39:44 <mm_freak> b_jonas: freeing unused memory?  probably making system resources available to other processes ;)
14:39:57 <mm_freak> BMeph: yeah, i found that out =)
14:40:22 <gwern> iirc, doesn't ghc not release memory to the OS? so it'd only be other threads who could benefit
14:40:49 <b_jonas> it might occasionally release some if it was allocated at a large chunk
14:40:52 <b_jonas> like as a large array
14:41:01 <b_jonas> not too likely otherwise, but possible theoretically
14:41:07 <b_jonas> just like with any other malloc
14:41:16 <b_jonas> well, that's what I think
14:41:44 <SodaSucks-Com> Hi!
14:43:21 <sjanssen> GHC does not release memory back to the OS in any circumstance
14:44:21 <BMeph> mm_freak: Actually, I mean '==' literally - it's Church encoding. ;)
14:44:54 <vixey> which equivalence
14:48:54 <cjay> I accidentally a new logo at the bottom of http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas ^^
14:48:57 <eu-prleu-peupeu> hello Hppl
14:50:13 * Beelsebob finds it very cheeky that people have started adding to the top of that page
14:50:32 <Saizan> gwern, sjanssen: i think it was this bug http://hackage.haskell.org/trac/ghc/ticket/2783
14:50:38 <vixey> maybe add a note saying people should add to the bottom then?
14:50:48 <Beelsebob> and oh god oh god -- please don't let the logo say "Haskell, all about monads"
14:50:49 <Beelsebob> >.<
14:51:11 <Beelsebob> vixey: I don't want to take authority over the page -- especially given that I'm biased by having one up there
14:51:27 <gwern> Beelsebob: I think we were considering 'Haskell: our monads, we will show you dem'
14:51:31 <Beelsebob> (this one http://haskell.org/haskellwiki/Image:HaskellLogoTDavie.png)
14:51:33 <eu-prleu-peupeu> the tagline should be the one from this channel
14:51:43 <eu-prleu-peupeu> "we put the funk in funktion"
14:51:47 <eu-prleu-peupeu> that is the best one :D
14:51:56 <cjay> :)
14:51:56 <Beelsebob> heh
14:52:03 <gwern> Saizan: you think the closing of that bug led to mine?
14:52:59 <eu-prleu-peupeu> i will make a logo
14:52:59 <zeno> > let randomReorder gen xs = map (xs !!) ((\x -> take x (nub (randomRs (0,(x-1)) gen))) (length xs)) in randomReorder (mkStdGen 42) [1..10] -- is this an efficient re-ordering function?
14:53:02 <lambdabot>   [2,8,5,7,9,6,10,4,3,1]
14:53:46 <Saizan> gwern: that bug is about 6.10.1 and is merged for 6.10.2
14:54:49 <gwern> ah. so it's one simon mentioned had been fixed. but he also said that you could still supply expressions that would prevent other threads from running
14:54:57 <BMeph> cjay: Did you also accidentally a verb in your sentence? ;)
14:55:37 <cjay> BMeph: oops ^^
14:56:26 <cjay> hmm.. there should be a size limitation for the logos
14:56:35 <BMeph> zeno: See my last comment concerning efficiency... ;p
14:56:59 <cjay> screen filling logos don't help anyone
14:57:16 <mm_freak> BMeph: indeed =)
14:57:21 <rskjr> trying to figure out monads.... reading http://www.cas.mcmaster.ca/~carette/CAS706/F2006/presentations/comonads.pdf
14:57:30 <rskjr> unfamiliar with this declaration on slide 11:
14:57:42 <rskjr> State s a = {runState :: s -> (a,s)}
14:57:50 <zeno> ah !! is bad, so hard not to use though =p
14:58:09 <rskjr> what's going on there
14:59:24 <mm_freak> zeno: efficient list reordering?  that's self-contradicting
14:59:31 <mm_freak> you should use arrays for such things
14:59:42 <eu-prleu-peupeu> my logo is going to be (of course) the best one
15:00:07 <Saizan> rskjr: it's the same as data State s a = State (s -> (a,s)); runState (State f) = f
15:00:36 <Saizan> rskjr: assuming you missed a "State" between = and [
15:00:37 <Saizan> {
15:01:01 <vixey> is there a name for something like an escalator, except going downwards?
15:01:16 <Heffalump> that's an escalator too
15:01:32 <mm_freak> what's an escalator?
15:01:36 <gwern> don't escalators go up and down?
15:01:38 <vixey> I need a work which says "always going downward"
15:01:43 <gwern> you see pairs of them *all* the time
15:01:46 <vixey> a word
15:01:48 <Heffalump> vixey: monotonically decreasing?
15:01:51 <gwern> vixey: firepole
15:01:59 <Heffalump> trapdoor
15:02:01 <gwern> you only ever go down a firepole
15:02:12 <vixey> it's not actually monotonically decreasing in this case, cyclic
15:02:18 <Deewiant> vixey: http://en.wikipedia.org/wiki/Escalator#Name_development_and_original_intentions
15:02:28 <vixey> but that is a consequence of there always being something smaller and being finite
15:03:46 <zeno> mm_freak: your right, timePrint $ randomReorder (mkStdGen 42) [1..1000] takes 1.5 seconds :\.  i guess convert to array first
15:04:07 <mm_freak> zeno: or use arrays all the time, if you need random access
15:04:43 <vixey> I can't think of anyhing good to name this :(
15:04:57 <satchiii> so can anyone help me with ext1T? should i ask it elsewhere? details: http://hpaste.org/13130
15:05:09 <vixey> it's not a firepole or a trapdoor .. but it has the property that they do
15:05:14 <vixey> and I want to name that property
15:06:44 <osfameron> ooo, I do like this recursive logo http://haskell.org/haskellwiki/Image:Haskell2_logo.png
15:09:27 <Saizan> is it recursive?
15:10:04 <osfameron> well, that's how it's described by the submitter
15:10:16 <satchiii> looks like no luck for me :(
15:10:17 <osfameron> it's kinda recursive in the sense of the Escher drawing hands image
15:10:19 <Gracenotes> heh, http://haskell.org/haskellwiki/Image:Haskell-logo-revolution.png ... just the impression to make about Haskell?
15:10:48 <vixey> idk lambda seems the wrong thing
15:10:54 <Gracenotes> Anarchism or communism, I can't tell
15:10:58 <vixey> why everyone is focused on lambda?
15:11:18 <Gracenotes> they're all gay for lambda?
15:11:32 <Gracenotes> sorry, terrible joke :/
15:11:45 <vixey> @go Wikipedia lambda
15:11:48 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
15:11:48 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
15:12:01 <osfameron> is there a function I can use to group a list by constructor?
15:12:30 <vixey> Gracenotes: yeah lambda - A symbol of the LGBT community, popular in the 1970s and 1980s.
15:12:38 <augustss> osfameron: in general, no
15:12:40 <osfameron> e.g. given data Cell = Cell Char | Block, can I group together Cell vs. Block in a [Cell] ?
15:12:57 <osfameron> augustss: so I have to pattern match on the specific constructor?
15:12:57 <augustss> osfameron: in that case, sort the list
15:13:10 <Gracenotes> the pink triangle is somewhat probably more popular today, but the lambda still exists
15:13:11 <osfameron> I want to group on contiguous Cells
15:13:12 <opqdonut> i think most of the logos are boring
15:13:13 <vixey> but I guess it's easier to do a picture of lambda that lazyness or hwatever
15:13:19 <opqdonut> the current one is great
15:13:31 <vixey> opqdonut, just use group
15:13:33 <vixey> :t group
15:13:35 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
15:13:40 <osfameron> I think the current one is quite ugly
15:13:44 <opqdonut> vixey: :)
15:13:47 <vixey> Cell _ == Cell _ = True
15:13:50 <opqdonut> mistab?
15:13:51 <ozy`> the current logo is too busy
15:13:59 <osfameron> yeah
15:14:00 <augustss> groupBy might be better
15:14:06 <ozy`> and impossible to reproduce from memory if you don't know what all the parts mean
15:14:18 <vixey> opqdonut, misunderstanding.. I can't juggle _3_ users starting with o at once
15:14:25 <opqdonut> :)
15:16:02 <Saizan> satchiii: there's a mailing list about generics
15:17:43 <vixey> what's the point in a logo at all?
15:17:53 <vixey> for a langauge
15:18:14 <ozy`> vixey: mnemonics, obviously
15:18:21 <vixey> @w80 mnemonics
15:18:24 <ozy`> ruby has... a ruby
15:18:31 <ozy`> perl has... uhm
15:18:32 <lambdabot> *** "mnemonics" wn "WordNet (r) 2.0"
15:18:32 <lambdabot> mnemonics
15:18:32 <lambdabot>      n : a method or system for improving the memory
15:18:39 <stu8ball> A camel.
15:18:40 <ozy`> python has the cute snake thing
15:18:42 <Philippa> vixey: t-shirts, marketing, helps in logos for related stuff...
15:18:49 <ozy`> stu8ball: I wasn't gonna actually say it :\
15:19:05 <Pseudonym> Haskell don't need no steenking animal.
15:19:05 <luite_> will the winner of the logo competition get a free t-shirt with the logo?
15:19:11 <BMeph> vixey: Call it an Escherian banana peel! ;p
15:19:14 <Pseudonym> We have lambdas.
15:19:15 <satchiii> Saizan: isn't that about generic implementations?
15:19:18 <eu-prleu-peupeu> there you go: http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas  a lightbulb that is also a lady
15:19:19 <eu-prleu-peupeu> ;)
15:19:28 <orbitz> ozy`: doesn't perl hav ea camel?
15:19:29 <orbitz> err stu	already said taht
15:19:33 <Pseudonym> Ubuntu just has a group hug.
15:19:36 <ozy`> I want a T-shirt with the Ministry of Safety and Happiness logo
15:20:04 <Saizan> satchiii: i thought you could also ask for advice
15:20:12 <osfameron> perl is an onion these days
15:20:13 <Pseudonym> Debian has a... who knows what.  Smoke plume?
15:20:32 <osfameron> apache has a very ugly feather
15:20:34 <satchiii> ok, i'll try
15:20:43 <Pseudonym> osfameron: It's not ugly, it's patchy./
15:21:05 <orbitz> C has...a pile of poo?
15:21:06 * ozy` drums a rimshot on Pseudonym's skull
15:21:08 <osfameron> ah, the current feather is prettier than I remember it
15:21:28 <Pseudonym> C has a sans serif letter.
15:21:33 <opqdonut> :)
15:21:34 <vixey> Coqs logo is a Coq :p
15:21:41 <orbitz> oh gosh
15:21:54 <orbitz> hopefully a rooster
15:22:07 <opqdonut> ^_^
15:22:27 <Pseudonym> http://www.fledermausland.org/blog/media/1/20070616-haskell.jpg <- Suggested logo
15:22:28 <vixey> ocaml is a caml
15:22:32 <orbitz> gosh this ocaml hread is horribly long
15:22:41 <cjay> btw there is still no logo with a lambdacat in it :|
15:22:48 <chrisdone> http://haskell.org/sitewiki/images/e/e5/Haskell_girl.jpg
15:22:48 <chrisdone> wat
15:23:08 <taari> :P
15:23:27 <Pseudonym> chrisdone: OK, _that's_ ugly.
15:23:50 <chrisdone> beggars can't be choosers
15:24:23 <ozy`> (... and java has that stupid coffee mug)
15:24:31 <opqdonut> cup!
15:24:35 <ozy`> MUG
15:24:40 * ozy` mugs opqdonut
15:24:45 * ozy` runs off with his wallet
15:24:49 <chrisdone> "fancy going for a mug of coffee?"
15:24:50 <orbitz> what does C# have?
15:24:52 * opqdonut cups ozy` on the head
15:25:04 <Pseudonym> I reckon Java's logo should be something from the Ramayana.
15:25:05 * ozy` gets his mugshot posted on sun's website
15:25:06 <vixey> javas logo is java
15:25:23 <chrisdone> Microsoft C# Scalable Solutions
15:25:24 <ozy`> orbitz: just Microsoft
15:25:35 <Pseudonym> vixey, Java is an island in Indonesia.
15:25:47 <Pseudonym> Their logo looks nothing like it,.
15:25:49 <vixey> it's also the name of coffee ......
15:25:49 <ozy`> actually the name C# is very much a logo itself
15:25:54 <orbitz> if Ocaml's logo is a caml, is F#'s a caml being raped?
15:26:28 <orbitz> too soon?
15:27:13 <mdmkolbe> What is the easiest way to get 6.10 on ubuntu?  I doesn't seem to be in the main ubuntu apt repository yet.
15:27:14 <chrisdone> I want a bug tracker/feature thingie of some sort, with severity, status, comments, things like that
15:27:31 <chrisdone> mdmkolbe: pretty sure it is
15:27:37 <vixey> mdmkolbe, compile it from source code works
15:27:49 <zeno> lol http://haskell.org/haskellwiki/Image:NarleyYeeaaahh.jpg
15:28:15 <zeno> mdmkolbe: linux binary
15:28:23 <Pseudonym> Does any project use an elephant for their logo?
15:28:27 <opqdonut> chrisdone: check out ditz
15:28:30 <opqdonut> if command-line is enough
15:28:36 <chrisdone> mdmkolbe: hm, scratch that. just get the .tar.gz and ./configure --prefix=/user and install locally. much better
15:28:39 <mdmkolbe> chrisdone: nope, it's still at 6.8 http://packages.ubuntu.com/intrepid/ghc6
15:28:44 <chrisdone> opqdonut: I'll see
15:28:45 <Vq^> Pseudonym: postgres
15:29:00 <Pseudonym> Right.
15:29:18 <Pseudonym> Actually... duh, if you want an animal logo, use the one on RWH.
15:29:21 <vixey>     If this sentence is true, then Santa Claus exists.
15:29:35 <vixey> that's an example of Currys Paradox
15:30:50 <Saizan> which corresponds to fix?
15:30:55 <vixey> yes
15:31:07 <vixey> well slightly more general  a = a -> b
15:31:12 <vixey> rather than a = a -> a
15:41:54 <augustss> BOOOOO!
15:42:08 <chrisdone> ~_~!!
15:42:17 <hydo> zomg
15:42:31 <roconnor> zygo!!
15:43:16 <chrisdone> batman.cs.indian.edu, ok
15:43:58 <augustss> not ok
15:47:44 <roconnor> augustss: did you switch employers recently?
15:51:17 <augustss> A few months ago.
15:51:32 <augustss> roconnor: September
15:54:14 <zeno> i dont think the creator of this logo liked lambda enough :\ http://img56.imageshack.us/img56/3400/megalambdahl4.jpg
15:54:42 <augustss> Sorry, that's just too ugly.
15:54:49 <opqdonut> :D
15:55:06 <chrisdone> that's a ilta, not a lambda. a ilta is basically a backwards lambda
15:55:21 <lament> my favourite is the artsy black-and-white disturbing looking one
15:55:33 <opqdonut> there's two of them right?
15:56:03 <roconnor> hah, lighbulb lady
15:56:13 <solrize> ppseudonym, hadoop uses an elephant
15:56:25 <roconnor> we should totally put pornography into the logo.
15:56:34 <lament> "monads"
15:57:12 <augustss> roconnor: why not squids?
15:57:19 <solrize> monad lisa
15:57:25 <roconnor> squids are even better
15:57:34 <chrisdone> unsafePerformDVDA
15:57:35 <Pseudonym> Squid is a proxy server.
15:57:48 <Apocalisp> bicycles and unicorns
15:58:08 <augustss> porcupines
15:58:25 <Saizan> the logos which use lambda for H just don't make sense
15:58:30 <augustss> Maybe antimatter
15:58:37 <chrisdone> oh, haha, did you guys see this? http://hpaste.org/13115
15:58:44 <lament> actually looking through the list, the comic sans logo is clearly the best
15:58:58 <chrisdone> it's from a histogram of all the haskell logs, I cut out a section with tonnes of unsafe*
15:59:04 <osfameron> http://hpaste.org/13132 <-- tonight's work on modelling a crossword
15:59:05 <chrisdone> comedy gold
15:59:39 <roconnor> I think Haskell needs a new report more than it needs a new logo.
15:59:42 <augustss> hahaha
15:59:49 <Apocalisp> Do you ever find that you need () for something like a comap?
16:00:05 <augustss> roconnor: don't we need a new language before we have a new report?
16:00:17 <chrisdone> unsafecompareinfinitedatastructures
16:00:22 <guenni> hi, how can I compile an exe on windows without the dos window opening, are there compile flags for ghc?
16:00:32 <yav> augustss: wouldn't that require a new logo? :)
16:01:19 <lament> augustss: you mean you have never tried to start a band?
16:01:25 <Apocalisp> Given ((a, b) -> (a, b) -> Boolean), I need a -> a -> Boolean. I'm tempted to synthesize a value of type b by just supplying ().
16:01:37 <lament> oh, s/augustss/roconnor/
16:01:44 <chrisdone> @remember guenni how can I ... on Windows without ... window opening
16:01:44 <lambdabot> Good to know.
16:01:55 <opqdonut> Apocalisp: sounds reasonable
16:01:55 <augustss> I wish ha;f of the energy spent on the new logo was spent on Haskell'
16:02:47 <chrisdone> I wish half of the energy spent learning LOLCODE was spent on Haskell'
16:03:00 <opqdonut> nuh-uh
16:03:01 <lament> when starting a band, first you come up with a name, then you find some people to jam with, and then finally you begin learning to play a musical instrument
16:03:05 <amiddelk> tss, lolcode is so much nicer syntax
16:03:08 <amiddelk> has*
16:03:12 <guenni> chrisdone: ?
16:03:12 <opqdonut> the energy spent on lolcode is negative energy
16:03:17 <opqdonut> it's best spent elsewhere
16:03:41 <augustss> lament: I've been doing it wrong. :(
16:04:12 <lament> augustss: it only makes sense that hardest tasks should come first!
16:04:15 <yav> lament: i guess that's lazy evaluation for you?
16:04:21 <chrisdone> hur hur
16:04:40 <lament> @quote robotics
16:04:41 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
16:05:05 <augustss> @quote augustss
16:05:06 <lambdabot> augustss says: Haskell boggles my mind too. :)
16:05:18 <augustss> Have I said that?
16:05:33 <augustss> It's true, though.
16:05:56 <lament> so something else boggles your mind?
16:07:00 <augustss> lament: yes.  dark energy
16:07:11 <llayland> has anybody had any luck using parsec for a language with single quoted strings?
16:07:42 <augustss> llayland: why would that be a problem?
16:08:08 <Asztal> guenni: you could maybe try passing -optc "-subsystem windows" to GHC
16:09:11 <chrisdone> the type of the gas contained within scotch eggs boggles my mind
16:09:22 <llayland> augustss: The token parsers from language def only work with double quoted strings.  I can do a single quoted string easily enough but it is evaluated after the tokenizing so things like line comments kill me
16:10:21 <roconnor> hasn't haskell already had like 5 reports?
16:10:27 <augustss> llayland: so take a token parser and hack around to use single quotes
16:10:51 <augustss> roconnor: yes, but each somewhat different from the others.
16:10:59 <guenni> Asztal: thx
16:11:08 <FunctorSalad> preprocess with tr \' \"
16:11:11 <FunctorSalad> ;)
16:11:11 <eu-prleu-peupeu1> my logo is the best!
16:11:16 <eu-prleu-peupeu1> the concept at least
16:11:47 <llayland> FunctorSalad: Nice :)  unfortunately I need double quoted strings to be distinct since they are actually identifiers - hoorah pl/sql
16:11:51 <lament> eu-prleu-peupeu1: needs boobs
16:12:07 <eu-prleu-peupeu1> yeah, im not that good in inkscape
16:12:16 <zeno> why a new report haskell == ghc anyways
16:12:40 <BONUS> haha eu-prleu-peupeu did you put your logo at the top by yourself :D
16:12:59 <augustss> zeno that's so not true
16:13:37 <zeno> augustss: anyone actually use hugs?
16:13:59 <yav> zeno: yes
16:14:16 <augustss> zeno: yes.  but that's not the point.  having a language defined by an implementation is really bad.
16:14:18 <yav> besides there other implementations that are not hugs
16:14:31 <Saizan> can anyone point me to a good resource on ML functors? or similar module systems?
16:14:36 <FunctorSalad> llayland: sorry I don't know enough about parsec tokens for a real suggestion... what augustss suggested sounds easiest
16:14:54 <yav> llayland: replace the stringLiteral parser
16:15:01 <yav> in the TokenParser record
16:15:15 <zeno> yav: oh? i thoguht those were the only 2 interesting
16:15:35 <roconnor> augustss: so we don't need a new language to make a new report.
16:15:44 <yav> zeno: well, depends on what you consider interesting.  there is at least nhc.
16:15:55 <augustss> roconnor: we need some minor changes, IMO
16:16:34 <augustss> And hbc still beats ghc on a number of benchmarks. :)
16:16:39 <llayland> Yav: excellent. makes incredible sense in retrospect
16:17:09 <yav> augustss: really?  that's pretty cool.  which ones?
16:17:15 <roconnor> augustss: of course.  No point writing a new report that is the same as the old one
16:17:28 <osfameron> how do you sortBy more than one criteria?  EQ isn't False, so I can't just do (crit1 || crit2) as I would in Perl
16:17:30 <augustss> yav: dons had a table from a while ago, I can't remember
16:17:40 <roconnor> None of these logos are Web 2.0 logos.  We need a web 2.0 logo
16:17:43 <yav> i'll ask him, thanks
16:18:13 <Saizan> osfameron: mappend
16:18:15 <Pseudonym> Surely getting submissions on a wiki is as 2.0 as it gets.
16:18:36 <Pseudonym> I think the logo needs to be more enterprisey.
16:18:36 <roconnor> :D
16:18:51 <yav> Pseudonym: you got it all wrong.  2.0 is about shiny, possibly spinning, and with rounded corners :)
16:19:00 <Nafai> Don't forget pastels!
16:19:05 <osfameron> Saizan: Ordering is a monad?
16:19:11 <roconnor> it's all about gradients
16:19:15 <Saizan> osfameron: a Monoid
16:19:20 <roconnor> of various sorts
16:19:26 <Saizan> > EQ `mappend` GT
16:19:27 <lambdabot>   GT
16:19:31 <roconnor> and  ya, rounded corners
16:19:32 <Saizan> > EQ `mappend` LT
16:19:34 <lambdabot>   LT
16:19:39 <roconnor> bubbles if possible
16:19:53 <Nafai> And, geez, if we are going to be Web 2.0, we need to remove the e
16:19:53 <osfameron> @index mappend
16:19:54 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
16:19:55 <Nafai> Haskll
16:20:00 <osfameron> cool, thanks
16:20:18 <FunctorSalad> the blue-orange on white one wasn't bad methinks
16:20:26 <FunctorSalad> (there were several versions)
16:21:52 <roconnor> FunctorSalad: this one? -> http://haskell.org/sitewiki/images/1/1d/Monica_monad_falconnl.png
16:22:59 <FunctorSalad> haha, the lightbulb one... "haskell: save the lightbulbs!"
16:23:40 <FunctorSalad> roconnor: http://haskell.org/haskellwiki/Image:Haskell_logo_idea_3_falconnl.png
16:23:47 <roconnor> actually http://haskell.org/sitewiki/images/f/fc/Haskell_logo_ideas_tshirt_falconnl.png is borderline web 2.0
16:24:15 <roconnor> FunctorSalad: ya.  Needs more gradient, like in the shirt
16:24:46 <wjesusaxl> can anybody tell what's this channel about_
16:24:47 <wjesusaxl> ?
16:24:57 <Nafai> wjesusaxl: The Haskell programming language
16:25:10 <augustss> wjesusaxl: Haskell
16:25:56 <zeno> interesting, strict haskell http://www.haskell.org/haskellwiki/DDC
16:26:02 <roconnor> wjesusaxl: http://www.haskell.org/haskellwiki/Real_World
16:26:08 * zuff writes nice little imaging library for haskell
16:26:26 <BONUS> i love it how like almost half of the logo entries are joke entries
16:26:31 <augustss> Mostly we discuss the programming language, but sometimes the indian college.
16:26:37 <BONUS> ok well not half, a third
16:26:39 <zuff> BONUS: your book is great.
16:26:44 <BONUS> thanks! :))
16:26:45 <Nafai> augustss: He missed your job :/
16:26:49 <Nafai> s/job/joke/
16:26:50 <BONUS> glad you like it!
16:26:51 <jvd> ell
16:26:53 <zuff> :)
16:27:04 <Nafai> BONUS: What book?
16:27:09 <BONUS> @where LYAH
16:27:10 <lambdabot> www.learnyouahaskell.com
16:27:10 <zuff> learnyouahaskell.com
16:27:14 <Nafai> Ah
16:27:16 <Gracenotes> I can't tell if there's a difference between the \in symbol and the lunate epsilon
16:27:19 <zuff> lambdabot: you type too fast ;)
16:27:22 <Nafai> BONUS: Yes, it's awesome
16:27:30 <BONUS> haha, woo!
16:27:32 <Gracenotes> oh, not quite the right channel
16:27:37 * Gracenotes goes off
16:27:51 * zuff figures out how to write the bmp format
16:28:05 <zeno> huh i dont get Chapter 11. So You Want to Be Like shapr? A Lesson in Boinging, inside jokes :\
16:28:21 <zuff> i'm _pretty_ sure i invented the word caleskel.
16:28:22 <roconnor> @quote shapr
16:28:22 <lambdabot> shapr says: I was chatting with someone who writes Haskell and at some point they said they're not an academic, and I said that too. And then there was what I perceived to be a small disbelieving
16:28:22 <lambdabot> silence...
16:28:24 <zuff> *caleskell
16:29:07 <grul> i've BLOGGED about LREANHASKELU!.com whatever url
16:29:10 <roconnor> zuff: the logs should clear that up
16:29:25 <zuff> grul: i see. roconnor: that would be effort
16:29:32 <Nafai> zeno: Chapter 11 of what?
16:30:19 <augustss> Oh noes, bankrupcy protection!
16:30:32 <zuff> hmm, is there a library that writes out to bmp/png/tga?
16:30:57 <eu-prleu-peupeu1> the logo that i most like is the "haskell flower" by tanimoto
16:31:01 <eu-prleu-peupeu1> it should win
16:31:08 <eu-prleu-peupeu1> or at least some variation of it
16:31:22 <augustss> Haskell needs a logo?
16:31:28 <roconnor> Nafai: chapter 11 of real world #haskell
16:31:36 <roconnor> (not to be confused with Real World Haskell, of course :)
16:31:54 <Nafai> roconnor: Oh!  Of course :)
16:32:09 <eu-prleu-peupeu1> augustss: haskell needs corporation image
16:32:41 <augustss> eu-prleu-peupeu1: oh?  it does?
16:32:54 <roconnor> I think BONUS should make the new logo
16:33:04 <BONUS> haha oh my
16:33:16 <augustss> yes!
16:33:26 <BONUS> i did make one submission but it's not nearly as wacky as people expected from me :]
16:33:57 <zuff> i suggest haskell adopts the logo: logo = 1 : logo
16:34:10 <zuff> interpreting this as an image is left as an excersize to the reader, but it is infinitely large.,
16:34:17 <eu-prleu-peupeu1> :D
16:34:23 <BONUS> let logo = logo in logo
16:34:26 <Saizan> let logo = haskell logo in logo?
16:35:00 <eu-prleu-peupeu1> or maybe make some fuzzy playarround with the word "logoTYPE" and haskell types or whatever
16:35:01 <eu-prleu-peupeu1> ehh
16:35:20 <Cale> > fix ((0:) . scanl (+) 1)
16:35:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:35:35 <Cale> That should be the Haskell tag-line ;)
16:35:44 <Cale> Haskell: fix ((0:) . scanl (+) 1)
16:36:00 <zuff> Cale: no, that's the Caleskell tagline
16:36:01 <wchogg> neeerd
16:36:02 <BONUS> lol. oh my
16:36:05 <roconnor> zip`ap`tail
16:36:06 <BONUS> nice fib
16:36:10 <BONUS> zip`ap`tail owns
16:36:12 <grul> i've always (for as long as i remember seeing it) wondered what the . operator does
16:36:16 <eu-prleu-peupeu1> Cale: that is a bit nerdy
16:36:17 <zuff> compose
16:36:27 <BONUS> f . g = \x -> f (g x)
16:36:30 <Gracenotes> zip`ap`tail?
16:36:30 <zuff> er, haskell is nerdy
16:36:33 <zeno> @src fix
16:36:34 <lambdabot> fix f = let x = f x in x
16:36:38 <BONUS> > zip`ap`tail [1,2,3,4,5]
16:36:39 <lambdabot>   Couldn't match expected type `[a] -> [b]'
16:36:54 <BONUS> > ap zip tail [1,2,3,4,5]
16:36:56 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
16:36:58 <Saizan> i think it's perfect, haskell should make your mind explode right from the logo
16:37:28 <roconnor> @quote zip`ap`tail
16:37:28 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:37:29 <wchogg> I think our logo should be lazily defined.  It's just a thunk until you try to look at it.
16:37:35 <Gracenotes> > zip [1,2,3,4,5] [2,3,4,5]
16:37:36 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
16:38:07 <Saizan> @unpl ap zip tail
16:38:07 <lambdabot> (zip >>= \ b -> tail >>= \ a -> return (b a))
16:38:13 <Gracenotes> wchogg: probably the best 'analogy' for including laziness in logos is quantum theory
16:38:13 <zeno> @src ap
16:38:14 <lambdabot> ap = liftM2 id
16:38:20 <Saizan> sehr gut
16:38:36 <Gracenotes> otherwise it's kind of hard to spell out graphically
16:38:46 <Gracenotes> imho, anyway.
16:38:52 <BONUS> haha, using quantum theory as an analogy for something
16:38:55 <Gracenotes> like, having an electron be the logo, or something :)
16:38:56 <zeno> @unpl fix ((0:) . scanl (+) 1)
16:38:57 <lambdabot> fix (\ d -> 0 : (scanl (+) 1 d))
16:39:08 <Cale> heh
16:39:08 <lucca> I think a simple H might be better
16:39:17 <Gracenotes> then again, an electron goes away if you shine light on it, it doesn't evaluate
16:39:29 <Cale> > let fibs = 0 : scanl (+) 1 fibs in fibs
16:39:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:39:46 <wchogg> ...I don't think an electron goes away when it gets hit by a photon.
16:40:02 <BONUS> it changes its level or something
16:40:12 <BONUS> *level up*
16:40:22 <llayland> level down emits a photon
16:41:08 <Gracenotes> it moves.
16:44:07 <jeffwheeler> It's hard to get that ASCII logo just right in PS.
16:44:17 <jeffwheeler> I've got it geometrically correct, but it doesn't look quite right, still.
16:45:27 <osfameron> Saizan: ah, even better, I can just derive Ord and it automatically does the right thing (as if mappend'ing left to right)
16:46:26 <BONUS> hmm
16:46:36 <BONUS> how would you guys represent cards with ADTs
16:46:58 <Philippa_> data Suit = Hearts | Diamonds |...
16:47:07 <BONUS> i'd prob. do it like this http://hpaste.org/13133
16:47:16 <Philippa_> type Card = (Suit, Int) or similar
16:47:17 <skorpan> deriving?
16:47:21 <BONUS> whoops
16:47:23 <BONUS> forgot to remove that
16:47:26 <skorpan> :)
16:47:35 <Philippa_> you can make the face values another type instead of using Int
16:47:43 <Philippa_> then it's time for lots of helper functions
16:48:02 <BONUS> yeah hmm
16:48:23 <BONUS> but then you have a problem of the ace
16:48:23 <Botje> Card Value Suit, with data Value = Number Int | Jack | Queen | King | Ace deriving (enum)
16:48:25 <BONUS> is it high or low?
16:48:52 <Philippa_> you pick an encoding, then it's up to individual games to actually 'value' it
16:48:52 <augustss> BONUS: I'd not do it just like that, the derived Ord instance for that type would be wrong
16:48:57 <Botje> make it high by default, implement custom comparison function if not?
16:49:08 <BONUS> yeah
16:49:12 <BONUS> certainly intersting, hmm
16:49:28 <skorpan> (this is the first lab of the introductory haskell course at chalmers)
16:50:17 <BONUS> Botje: i dont think that can derive Enum though
16:50:40 <Botje> I meant Ord
16:50:45 <BONUS> ah
16:50:52 <Botje> enum would be wrong, indeed
16:50:53 <FunctorSalad> if you want to do type-level reasoning with the face values you probably don't want Number Int Suite
16:51:07 <zeno> Botje: will it get jack queen king etc in the correct order when you derive enum?
16:51:08 <Botje> but you can use enum to show off typeclass instances
16:51:18 <llayland> standard 52 card deck? or do you have to take into account the possibility of jokers
16:51:20 <Botje> zeno: it will do those, but be horribly wrong for Number
16:51:35 <BONUS> nah, no jokers
16:51:59 <roconnor> Either Bool Card
16:52:26 <augustss> Bool?
16:52:55 <roconnor> throw joker1 where joker1 = True
16:53:27 <augustss> what about joker3
16:54:21 <roconnor> joker3 = joker3
16:54:25 <jfoutz> um... what's the list monad over multiple infinite lists trick? do {x<-[1..];y<-[1..]; guard x<y } kinda thing?
16:55:19 <sjanssen> jfoutz: x <- [1 ..]; y <- [1 .. x-1]
16:56:12 <sjanssen> or something to that effect
16:56:31 <BONUS> what was that cool thing quicksilver was explaining once
16:56:41 <BONUS> that infinite lists aren't monads
16:56:48 <BONUS> but they're something else that finite lists ain't
16:56:50 <BONUS> what was it again
16:56:58 <roconnor> logicT?
16:57:11 <sjanssen> BONUS: you're thinking of the ZipList Applicative?
16:57:25 <BONUS> hmm maybe
16:57:34 <jfoutz> sjanssen: thanks hmm... i think that i gave a bad example... how do i get x to have a value other than 1? take 5 $ do { x<-[1..]; y<-[1..]; return (x,y)}
16:57:47 <jfoutz> >take 5 $ do { x<-[1..]; y<-[1..]; return (x,y)}
16:57:58 * jfoutz peers around
16:58:03 <sjanssen> jfoutz: use something other than the list monad
16:58:10 <jeffwheeler_> > take 5 $ do { x<-[1..]; y<-[1..]; return (x,y)}
16:58:11 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5)]
16:58:20 <jeffwheeler_> jfoutz: you need a space following the '>'
16:58:27 <jfoutz> thanks jeffwheeler_
16:58:42 <roconnor> > take 5 $ do { x<-[1..]; y<-[1..x-1]; [(x,y),(y,x)]}
16:58:44 <lambdabot>   [(2,1),(1,2),(3,1),(1,3),(3,2)]
16:59:09 <jfoutz> ok.
16:59:16 <augustss> Data.List needs a diagonalize function
16:59:37 <jfoutz> interleave... i was looking for something like interleave.
16:59:50 <jfoutz> *shrug* thanks again
16:59:51 <roconnor> > take 5 $ do { x<-[1..]; y<-[1..x-1]; [(y,x-y)]}
16:59:52 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2)]
16:59:53 <Saizan> there's omega on hackage
17:00:05 <Botje> jfoutz: georg cantor solved this problem ages ago ;)
17:00:44 <jfoutz> heh
17:01:04 <jfoutz> omega. that looks promising.
17:22:41 <jeffwheeler> Is it possible to invite lambdabot to a private room for a bit?
17:24:15 <llayland> @lamdbabot a/s/l
17:24:15 <lambdabot> Unknown command, try @list
17:24:24 <lambdabot> I don't follow strangers into dark rooms. Not after what happened last time.
17:26:11 <jeffwheeler> I had a feeling that was going to happy. :-/
17:27:23 <roconnor> @vixen a/s/l
17:27:23 <lambdabot> 19/f/California
17:27:55 <lambdabot> I might change my mind with enough flattery.
17:29:30 * jeffwheeler loves lambdabot.
17:30:24 <jeffwheeler> Is it possible to get lambdabot kicked from the server by having too many people ask it questions simultaneously?
17:31:30 <lambdabot> Nothing about drowning in the beauty of my lambdas?
17:33:08 <roconnor> lambdabot: fix (Rose (<3) . repeat)
17:34:26 <lambdabot> Or perhaps a haiku poem about my sparkling purity and overwhelming finesse?
17:35:04 <roconnor> There once was a bot named lambda
17:35:17 <roconnor> ...
17:35:26 <roconnor> um, what rhymes with lambda?
17:35:33 <sstangl> labbott: amanda
17:35:35 <sstangl> err
17:35:37 <sstangl> roconnor: amanda
17:36:03 <sstangl> "a man, duh", but that is without class :(
17:36:50 <roconnor> if there is anything lambdabot has, it's class
17:39:50 <Philippa_> sstangl: we knew she wasn't a man, duh?
17:40:06 <Philippa_> roconnor: so long as @vixen is nowhere in sight?
17:40:27 <chrisdone> u'i
17:40:35 <chrisdone> uh
17:40:53 <roconnor> @vixen do you have class?
17:40:53 <lambdabot> i do occassionally, i guess
17:44:21 <Philippa_> @vixen do you stab people for asking stupid questions?
17:44:21 <lambdabot> i do occassionally, i guess
17:58:13 <oklofok> @vixen o
17:58:14 <lambdabot> So, tell me your biggest and darkest secret. Something that no one knows of you.
17:58:53 <oklofok> sometimes i look at long mathematical proofs and get this tingly feeling in my dark areas
18:08:23 <jeffwheeler_> Before I post this, any critiques?
18:08:24 <jeffwheeler_> http://media.nokrev.com/junk/haskell-logos/logo1.png
18:08:39 <hoopy> i like it.
18:08:43 <jeffwheeler_> I just made the ASCII one posted to the list.
18:08:58 <Apocalisp> very nice
18:08:59 <jeffwheeler_> So, all credit goes to the original person (didn't check the name).
18:09:01 <hoopy> but i'm a haskell noob so i might not know what all visual cues it should have
18:09:14 <jeffwheeler_> hoopy: It's >>= and a lambda in the middle.
18:09:34 <hoopy> i don't know anything about arrows yet :)
18:09:37 <jeffwheeler_> I'll make a second version with the second > more defined.
18:09:41 <Apocalisp> jeffwheeler, it's pretty much awesome
18:09:45 <hoopy> i've just finished the 3rd chapter of RWH
18:09:52 <qwr> hoopy: >>= is monads bind
18:09:55 <jeffwheeler_> hoopy: that's not using arrows; that's just the bind operator from monads.
18:10:02 <hoopy> well there you have it :)
18:10:07 <jeffwheeler_> hoopy: and I don't know arrows either ;)
18:10:29 <Apocalisp> You could have invented arrows!
18:11:26 <FunctorSalad> jeffwheeler_: beautiful, though it's so minimalistic that on a crowded webpage one might not realize it's the logo o_o
18:11:27 <ikkebr> jeffwheeler looks nice
18:12:21 <jeffwheeler_> FunctorSalad: perhaps. I'll play adding 'Haskell'.
18:12:33 <jeffwheeler_> (. . . after I find the original post so I can reply to it.)
18:13:15 <FunctorSalad> jeffwheeler_: nah, it's fine as it is :) would just have to be put somewhere where it can mostly stand by itself...
18:13:50 <jeffwheeler_> Grr, I've completely lost the entire post and all the ones replying to it. What have I done!
18:14:41 <jeffz`> jeffwheeler_: interesting design, looks a bit like a sportswear insignia
18:14:57 <jeffwheeler_> jeffz`: ha, a bit.
18:15:06 <llayland> could be the ke in Haskell
18:15:30 <jeffwheeler_> Oh, also clever.
18:15:54 <jeffwheeler_> Again, all credit goes to the guy who posted the ASCII version to the mailing list. Can't find his name, now.
18:16:09 <jeffz`> jeffwheeler_: got it, I was thinking of EA Sports - http://tw-online-magazine.co.uk/images/Logo_EA_HR-747608.jpg
18:16:15 <FunctorSalad> fix ("ke" ++)
18:16:18 <FunctorSalad> > fix ("ke" ++)
18:16:19 <lambdabot>   "kekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekeke...
18:16:35 <jeffwheeler_> jeffz`: yep, it's a bit similar.
18:17:15 <hoopy> @src fix
18:17:15 <lambdabot> fix f = let x = f x in x
18:17:22 <jeffwheeler_> It was originally Darrin Thompson.
18:17:58 <FunctorSalad> why is fix written like that, not "fix f = f (fix f)" ?
18:18:18 <jeffwheeler_> I want to say tail recursion.
18:19:17 <llayland> Can't an optimizing compiler handle that?
18:19:36 <jeffwheeler_> I'm no expert; I could very easily be wrong.
18:20:19 <llayland> >let fx f = f . f in fx ("ke" ++)
18:20:23 * hoopy fails to see how fix can be useful
18:20:27 <llayland> > let fx f = f . f in fx ("ke" ++)
18:20:29 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
18:20:29 <lambdabot>        arising from a...
18:22:26 <FunctorSalad> > take 6 ( fix ("ke" ++) ) -- hoopy
18:22:28 <lambdabot>   "kekeke"
18:22:50 <FunctorSalad> (if I understood correctly that your objection is that it doesn't terminate)
18:31:13 <JohnnyL> what's a good web platform for haskell?
18:31:52 <jeffz`> anything.
18:32:14 <Megzlnaa> http://www.aegisub.net/2008/12/if-programming-languages-were-religions.html
18:32:59 <Axman6> JohnnyL: happs is the usual one
18:33:25 <jeffwheeler_> Although that new one, Turbadino or something, looks awfully hot.
18:33:52 <jeffz`> plain ol' cgi is good too.
18:33:57 <doublec> Turbinado does look nice. Doesn't work with 6.10 though
18:34:08 <doublec> afaik
18:34:32 <byorgey> http://www.youell.com/matt/writing/?p=46
18:34:54 <byorgey> That's "if programming languages were martial arts" =)
18:35:08 <Megzlnaa> they forgot ML
18:35:18 <Megzlnaa> and ASM
18:35:53 <doublec> JohnnyL, what sort of web stuff are you planning on doing?
18:36:45 <Elly> ML would be a lot like haskell I think
18:37:03 <Elly> I'm curious where prolog goes on that list :P
18:37:09 <llayland> holy crap, a hylomorphic solution to a problem just came naturally to me
18:37:16 <llayland> Elly: it was !
18:37:33 <JohnnyL> doublec, well i was just looking for typical web platform stuff, maybe with fancy pattern matching for the HTML parameters,etc. I'm not at all the familiar the way it's done in haskell. So i'm open.
18:37:38 <Megzlnaa> "What about Prolog?
18:37:38 <Megzlnaa> Surely that'd be athiesm (yeah - I know, not technically a religion, but you know what I mean) a completely rationalistic take on the programming universe by following scientific deduction.
18:37:41 <Megzlnaa> "
18:37:49 <llayland> ! was cut in prolog, right?
18:37:55 <Elly> yep
18:38:00 <byorgey> llayland: hehe
18:38:32 <FunctorSalad> science? deduction? ^^
18:39:18 <Axman6> i think the APL description is pretty good
18:39:37 <Elly> me too
18:40:36 <doublec> JohnnyL, I have a guide to basic HAppS stuff here if you want to play with it: http://tinyurl.com/5w9yfy
18:40:45 <doublec> to get an idea of doing simple web stuff
18:41:22 <Axman6> doublec: i found your guide far more informative than the happs-tutorial, just so ya know :)
18:41:31 <doublec> Thanks :)
18:41:57 <Megzlnaa> "Haskell   is not really a car; it's an abstract machine in which you give a detailed description of what the process of driving would be like if you were to do it. You have to put the abstract machine inside another (concrete) machine in order to actually do any driving. You're not supposed to ask how the concrete machine works. There is also a way to take multiple abstract machines and make a single abstract machine, which you can 
18:42:08 <doublec> happs-tutorial is good for building a complete app though
18:43:18 <jeffwheeler_> Err, did my message just get lost going to haskell-cafe?
18:43:23 <loop_> HTML 3.2 final, seems a bit outdated
18:44:33 <chrisdone> my other abstract machine is a, er..
18:45:03 <Pseudonym> My other abstract machine is a WAM.
18:45:21 <chrisdone> yo dawg I heard you like haskell so we put an abstract machine in your abstract machine so you can describe while you describe
18:45:24 <Elly> Pseudonym++
18:45:46 <Elly> I like the prolog one: You describe what the destination looks like and it figures out how to drive you there
18:46:00 <Pseudonym> In exponential time.
18:46:14 <Pseudonym> Prolog only has one algorithm: Exponential backtracking search.
18:46:41 <chrisdone> my driving instructor said technology is growing expotentially
18:46:54 <JohnnyL> doublec wow thanks. looks really good. what's the json like format called?
18:46:58 <JohnnyL> :)
18:47:35 <Elly> Pseudonym: why would you need any other algorithm?
18:48:15 <pizza_> chrisdone: actually i forgot to water it, thanks for reminding me
18:48:36 <Pseudonym> Obviously, exponential backtracking search is a universal algorithm.
18:49:35 <chrisdone> pizza_: your abstract machine?
18:50:27 <pizza_> no, technology. it only grows polynomially in wintertime.
18:50:28 <ozy`> there's someone in here with the nick pizza_?
18:50:40 <Elly> no, there isn't; it's an optical illusion
18:51:02 <pizza_> i do not exist.
18:51:08 <chrisdone> sounds like someone's got the munchies
18:51:25 <ozy`> I'm a connoisseur of pizza
18:51:43 <chrisdone> pizza_: I recognise you from ##c. when did you start idling here? /me expecting years, now..
18:52:05 <Elly> it's a prepromorphism, get in the car!
18:52:08 <pizza_> when i started playing with Haskell ;) only a couple of months
18:52:12 <chrisdone> Elly: haha
18:52:22 <chrisdone> pizza_: ah, I see :-)
18:53:03 <chrisdone> @quote chrisdone
18:53:04 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
18:53:11 <chrisdone> @quote chrisdone
18:53:12 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
18:53:14 <chrisdone> hrm
18:53:27 <chrisdone> gives me different quotes on privmsg
18:53:57 <chrisdone> <lambdabot> chrisdone says: yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
18:54:34 <int-e> @quote overrated
18:54:34 <lambdabot> Masklinn says: stability is overrated
18:54:37 <int-e> @quote overrated
18:54:37 <lambdabot> Masklinn says: stability is overrated
18:54:44 <int-e> @quote overrated
18:54:44 <lambdabot> Masklinn says: stability is overrated
18:54:45 <int-e> :(
18:54:56 <pumpkin> int-e: did you really do all the euer problems?
18:54:58 <Gracenotes> @quote
18:54:59 <lambdabot> int-e says: C++ does make a reasonably usable high-level assembler
18:55:05 <Gracenotes> heh
18:55:13 <pumpkin> euler, that is
18:55:15 <int-e> pumpkin: yes. no big deal.
18:55:20 <pumpkin> :o
18:55:31 <int-e> just a lot of wasted time :-P
18:55:40 <pumpkin> I bet :) still fun
18:55:41 <Gracenotes> int-e: even the one about sudoku? :)
18:56:00 <Philippa_> has anyone packaged up the work from Data Types a la Carte on Hackage yet?
18:56:02 <Gracenotes> and the bricks with non-overlapping vertical lines?
18:56:23 <pumpkin> Gracenotes: all 221 of them :o
18:57:04 <chrisdone> pizza_:
18:57:07 <chrisdone> preflex: be poppavic
18:57:07 <preflex>  trigraphs remind me of "escapes" - which means "well, we agree - but what do we send and what does it do?"
18:57:19 * chrisdone laughs
18:57:20 <pizza_> hehe
18:57:38 <pizza_> insanity is only funny because /ignore exists
18:58:49 <chrisdone> verily
19:01:39 <int-e> Gracenotes: I have my own Sudoku solver, yes. I didn't write it for Project Euler, no :P
19:03:05 <sjanssen> @keal
19:03:06 <lambdabot> how do i search for someone saying 'Keal' in mirc
19:04:20 <Gracenotes> int-e: cool -- which language?
19:04:42 <int-e> Gracenotes: C++, see the quote above ;) (it needed to be really, really fast.)
19:05:40 <Gracenotes> really really fast? less than a second, then?
19:06:59 <pumpkin> needed to solve infinite boards?
19:10:03 * byorgey <3 quickcheck!!
19:10:08 <byorgey> quickcheck++
19:10:09 <JohnnyL> wow 8.5 megabytes for hello world nuder HApps, is this cachable?
19:10:25 <sjanssen> JohnnyL: does strip help?
19:10:30 <int-e> pumpkin: no, the program originally enumerated sudoku grids
19:10:36 <pumpkin> ah
19:10:41 <JohnnyL> sjanssen new to strip, do tell! :)
19:10:45 <sjanssen> JohnnyL: GHC statically links in libraries, so executables can be a bit larger
19:10:51 <sjanssen> JohnnyL: just 'strip theexecutable'
19:10:55 <doublec> JohnnyL, well it does include a webserver in that executable
19:10:56 <JohnnyL> sjanssen oh ok
19:10:59 <int-e> Gracenotes: it can solve all of http://magictour.free.fr/top1465 in 1.2 seconds on my dated computer.
19:11:26 <int-e> Gracenotes: it's not the fastest solver on earth, far from it. but it's decent.
19:11:33 <JohnnyL> sjanssen there is no package named 'strip'.
19:11:43 <Gracenotes> that's.... pretty fast :) did you use backtracking, or a sophisticated heuristic, or both...?
19:12:15 <sjanssen> JohnnyL: it's a standard Unix utility
19:13:52 <int-e> Gracenotes: the program picks all positions of a digit at once - so you have, essentially, a nested loop of depth 8 (the 9th digit falls into place automatically). The tests are done with bit masks. And as a heuristic, it picks the digit with the fewest possibilities first. (Nothing really exciting in all of that.) Oh it only works for 3x3x3x3 sudokus.
19:14:41 <JohnnyL> sjanssen i'm using xp, but i'll look into it for min.
19:14:59 <Gracenotes> sounds neat :)
19:15:03 <byorgey> @seen vixey
19:15:04 <lambdabot> I saw vixey leaving #rosettacode, #haskell, #perl6 and ##logic 3h 48s ago, and .
19:15:16 <Axman6> int-e: what is that page anyway?
19:15:19 <Gracenotes> I tried to implement one in Java quite a while back... I didn't get much farther than half-writing a SudokuBoard object, though
19:15:42 <JohnnyL> sjanssen got it down to 3.4.
19:15:54 <gwern> goodness, it takes a while to download hackage
19:16:14 * Gracenotes hasn't done Java in 7 months
19:16:44 <int-e> Axman6: which, the magictour site?
19:16:44 <Axman6> gwern: ... all of it?
19:16:48 <byorgey> @ask vixey what should be done about  unintercalate "" ?  Your implementation, the one in section 3 on the Data.List.Split page, and mine all blow up, although yours at least has the advantage of being productive.  The others just go into infinite loops.  I have some thoughts but would be interested to hear yours.
19:16:49 <lambdabot> Consider it noted.
19:16:49 <Axman6> yeah
19:16:49 <gwern> (and downloads are faster compared to configuring and building docs)
19:16:51 * BMeph goes by the saying, "Friends Don't Let Friends Code Java". ;p
19:16:58 <gwern> Axman6: I accidentally the entire hackage!
19:17:00 <Axman6> the knights tour i take it?
19:17:05 <Axman6> gwern: :o
19:17:20 <BMeph> gwern: You accidentally a verb, too. ;p
19:17:23 <gwern> Axman6: but srsly, my goal is to generate hoogle databases for every package I can
19:17:34 <Axman6> ha, good idea :)
19:17:35 <int-e> Axman6: The magic tour is a knight tour that is also a magic square (if you label the squares by the number of the step it's visited in)
19:17:50 <gwern> and since cabal-install doesn't take the hoogle option... I have to do it manually with tarballs and stuff
19:17:57 <Axman6> int-e: ... wow, nice.
19:18:07 <gwern> (ah, darcs-cabalized just downloaded. good times, good times!)
19:18:18 <gwern> int-e: that's possible? impressive
19:18:18 <Gracenotes> gwern: shell scripts to the rescue...?
19:18:42 <gwern> Gracenotes: basically yeah. a quick forloop, a 'cp dist/foo/*.txt ./' and so on
19:18:55 <int-e> Axman6: the site is owned by two fans of combinatorial searching and regular contestants of Al Zimmerman's programming contests. That's all I know about it. http://magictour.free.fr/sudoku has a bit sudoku related stuff.
19:19:06 <gwern> I could write a hsh script, but that'd be slower and do more or less the same thing
19:20:58 * gwern notes that the http library is distressingly inefficient; 25% of cpu to download a tarball? srsly
19:21:25 <sjanssen> it uses [Char]
19:21:46 <gwern> yes, I assumed as much, as the bytestring-based HTTP library I benchmarked did much better
19:24:54 <teko> "Haskell is a no-compromises functional programming language like Erlang. It presently has no commercial implementations. But while its aspirations are more academic than commercial, there are some interesting applications of Haskell. "
19:25:22 <JohnnyL> sjanssen does haskell have to load an entire 3.4 meg image for each call to the server?
19:25:52 <gwern> teko: everyone knows that a closed-source compiler makes the difference between an academic and a real programming language
19:25:58 <pumpkin> yup!
19:25:59 <Axman6> teko: doesn't really do haskell justice imo
19:26:09 <pumpkin> Axman6: I'm up to 401
19:26:11 <pumpkin> 40!
19:26:14 <teko> " You want a pure (not hybrid) FP experience and you aren't expecting to get productive work out of the exploration. Is there a best language for simply learning functional programming? A good case can be made for Haskell."
19:26:16 <Axman6> bah
19:26:20 <pumpkin> Axman6: but got me a concussion in the mean time :P
19:26:24 <pumpkin> + amnesia
19:26:37 <Axman6> eh?
19:26:43 <teko> "and you aren't expecting to get productive work out of the exploration" !??!?!?!?!?!
19:26:51 <pumpkin> was snowboarding and had a bad fall, knocked myself out :D
19:26:53 <teko> by the way this is from DDJ
19:27:04 <Axman6> teko: yeah they obviously don't know haskell very well. where are you getting this from?
19:27:08 <gwern> yes, we saw it
19:27:11 <sjanssen> JohnnyL: I believe HAppS runs persistently, right?
19:27:35 <doublec> JohnnyL, no, because that image is itself a web server
19:27:37 <doublec> it stays loaded
19:28:03 <Philippa_> teko: to be fair, Haskell takes longer to be productive than impure languages do
19:28:15 <Axman6> pumpkin_: whatchu on about?
19:28:25 <Philippa_> I've watched my dad's learning curve - he's finally learned enough to write Fortran in Haskell :-)
19:28:33 <Axman6> heh
19:28:41 <gwern> fortran in haskell? that takes a fair bit of skill, you ask me
19:28:44 <pumpkin_> Axman6: not much?
19:28:48 <jeffz`> a fortran interpreter in Haskell?
19:28:57 <Philippa_> (strictly speaking, only just so as well - I told him about tail calls for emulating goto over dinner tonight)
19:28:58 <pizza_> heh.
19:28:58 <Axman6> "14:26 < pumpkin> Axman6: but got me a concussion in the mean time :P"?
19:29:14 <JohnnyL> doublec oh ok
19:29:22 <orbitz> i'm trying to recursivelyr ead files in a directory, proces the, and add their processed reustls to a list
19:29:30 <Philippa_> gwern: yeah, but real programmers can write fortran in any language :-) Besides, he's doing it because he has an actual chunk of Fortran code to rescue
19:29:33 <pumpkin_> Axman6: oh did my message not get through? I was snowboarding too fast and knocked myself out by falling, can't remember any of it but got me an ambulance ride and a stay at the hospital :P
19:29:46 <Philippa_> jeffz`: nah, just translating a specific fortran program into it
19:29:50 <orbitz> I'm using hGetContents to do this, and i'm runnign into "too many open files" exception
19:29:59 <Axman6> oh, missed that part. ha, nicely done
19:30:18 * Axman6 secretly hopes that slows down the PE progress
19:30:20 <Axman6> >_>
19:30:23 <pumpkin_> lol
19:30:41 <orbitz> i fi call hClose i don't get any contents though
19:31:19 <sjanssen> orbitz: hGetContents lazily reads the data, so the Handle stays open until you demand the entire result
19:31:26 <Axman6> orbitz: you need to lay off the pre-emptive spacetasking :P
19:31:35 <orbitz> http://hpaste.org/13134
19:31:36 <orbitz> my code
19:31:53 <chromakode> jeffwheeler: nice logo concept!
19:31:58 <orbitz> Axman6: i got bad synchronization in mah brainz
19:32:02 <jeffwheeler> chromakode: thanks. :)
19:32:13 <orbitz> sjanssen: shouldn't it not need the contetn sby the time it hits my recursive call though?
19:32:13 <Axman6> orbitz: turn down the overclocking!
19:32:38 <Axman6> i've seen brain cases carch on fire if they're too overclocked!
19:32:49 <orbitz> IEEE
19:32:54 <jeffwheeler> chromakode: I'm excited to try scaling it down to less than 16x16. It should work /really/ well.
19:32:56 <sjanssen> orbitz: no, because you don't force 'r'
19:33:01 <orbitz> sjanssen: do i have to force the thunk to be executed?
19:33:31 <chromakode> jeffwheeler: indeed -- which is super important for a new logo
19:33:38 <Cale> http://img.thedailywtf.com/images/200812/errord/hotwine.JPG -- heh, speaking of overclocking...
19:34:02 <chromakode> jeffwheeler: it's all about the distinctive outline shape... that's why I'd like to see less circle logos
19:34:18 <Axman6> jeffwheeler: oo, nice
19:34:26 <jeffwheeler> chromakode: yeah; I really like Darrin's concept (the one that mine is based on).
19:34:38 <sjanssen> orbitz: you will need to do that, yes
19:34:39 <Axman6> why's everyone sticking their new logos up the top? :O
19:34:51 <chromakode> I dunno, I just did because that's what I saw other people were doing.
19:34:59 <Axman6> lame guys
19:35:05 <orbitz> sjanssen: something like: r `seq` (readClickData' r fs) ?
19:35:06 <jeffwheeler> I did it because the person before me did. :P
19:35:19 <Axman6> you guys suck
19:35:20 <chromakode> Axman6: it makes sense to me, because the ones that were previously on top have been seen there for a while. in a sense, it's a sane way to share the spotlight.
19:35:28 <gwern> Axman6: no u
19:35:38 <teko> http://morenews.blogspot.com/2006/10/oo-is-trick-functional-programming-is.html
19:35:43 <sjanssen> orbitz: http://hpaste.org/13134#a1 yes, exactly :)
19:35:47 * Axman6 is kidding, but still a little disappointed
19:35:47 <teko> o postulate a state-less model of computation on top of a machinery whose most eminent characteristic is state, seems to be an odd idea, to say the least.
19:35:50 <orbitz> sjanssen: sounds like i'm writing this wrong though
19:36:08 <sjanssen> orbitz: also, you might notice that readClickData' is a fold (foldM to be precise)
19:36:23 <teko> "...this writer believes that a more effective way to let a system make good use of parallelism is provided by object-orientation, each object representing its own behaviour in the form of a private process."
19:36:25 <orbitz> sjanssen: yeah, i wasn't sure which one though.  tahnks!
19:36:34 <orbitz> sjanssen: (this is my first 'real' haskell program, so still workign ove rthe idios)
19:36:42 <sjanssen> orbitz: and you should probably use foldl' instead of foldl -- foldl is almost always the wrong thing
19:36:44 <orbitz> sjanssen: seq worked great
19:37:02 <JohnnyL> sjanssen looks that way
19:37:04 <gwern> teko: why? we do the same thing in physics with great success
19:37:08 * jeffwheeler is too addicted to Helvetica Neue, a non-free font.
19:37:10 <orbitz> sjanssen: thank you
19:37:28 <jeffwheeler> Hell, I don't think my Mac has any free fonts. :P
19:37:34 <gwern> (time-invariance is a major property of many equations, for example)
19:37:43 <chromakode> jeffwheeler: also check out bitstream charter
19:37:45 <gwern> jeffwheeler: you effete mac artist you
19:38:05 <JohnnyL> many programs in haskell are written bottom up , no?
19:38:07 <jeffwheeler> gwern: Inkscape is still compiling on my OpenBSD machne.
19:38:09 <jeffwheeler> * machine
19:38:17 <chromakode> Helvetica Neue is beautiful :(
19:38:35 <gwern> jeffwheeler: if you say so
19:38:37 <jeffwheeler> chromakode: It is. Especially in bold with minimal kerning.
19:39:03 <jeffwheeler> (And while on the topic of compiling on OpenBSD, what's with it still having GHC 6.6!?)
19:39:15 <Axman6> security!
19:39:21 <gwern> jeffwheeler: no one uses openbsd any more?
19:39:32 <jeffwheeler> I just switched. It's hot.
19:39:34 <Axman6> bah, plenty of people use OpenBSD
19:39:40 <Axman6> it's an awesome system
19:39:44 <Axman6> makes a great router
19:39:46 <gwern> (the only haskeller I can think of who was on openbsd was dons, and he moved to archlinux a awhile ago)
19:39:59 <chromakode> jeffwheeler: many of the aluminum body laptops *are* very hot... ;)
19:40:00 <Axman6> i wouldn't use it for a desktop though
19:40:02 <gwern> Axman6: just what I always wanted - to hack haskell on my router
19:40:06 <Axman6> i'd go with PC-BSD
19:40:16 <jeffwheeler> chromakode: I know that all too well. I have one of those, too.
19:40:26 <chromakode> one of the new ones?
19:40:33 <jeffwheeler> chromakode: nah, a few years old.
19:40:38 <chromakode> ah, aha.
19:40:57 <Axman6> my MBP has got up to 90C before
19:40:58 <jeffwheeler> GNOME seems to be most up-to-date on OpenBSD, of all the BSDs.
19:42:35 <chromakode> jeffwheeler: what kind of gets me is that there's no information about the contest... no deadline, no judges, nothing...
19:42:51 <jeffwheeler> chromakode: I think it's pretty informal for the time being. :)
19:43:05 <jeffwheeler> chromakode: I'm fine with that. No need for formalities yet.
19:43:12 <chromakode> yeah, that's cool
19:43:23 <chromakode> but I'd hate to see someone not get included because of informalities in deadline.
19:43:38 <chromakode> especially since some people sit on their designs for a while before finalizing them
19:43:43 <jeffwheeler> Heh, yeah. Dons, our god, will take care of everything, I'm sure.
19:44:00 <gwern> contest?
19:44:17 <jeffwheeler> gwern: http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
19:44:18 <p_l> laptops should have warm-feeling ballistic plastic on the outside, f*ck solid metal structure inside... <--- opened his thinkpad for the first time
19:44:25 <jeffwheeler> Check out the top of that page, gwern.
19:44:26 <gwern> oh, the logo thing
19:44:27 <jeffz`> jeffwheeler: ghc 6.6 is still pretty good, it's not terribly out of date.
19:44:45 <gwern> jeffwheeler: how long ago was 6.6 released?
19:44:47 <jeffwheeler> jeffz`: It is when Yi only compiles on 6.10. :)
19:45:12 <jeffz`> jeffwheeler: ah, Yi doesn't have enough for me to bother with it, I'd be constantly switching between Yi and Emacs
19:45:13 <gwern> jeffwheeler: incidentally, my hoogle stuff is in darcs yi now
19:45:37 <jeffwheeler> Yeah; I don't know why I haven't committed anything to Yi in like, two weeks.
19:46:00 <gwern> (I was kind of flattered; jpb immediately added a binding to it in his config)
19:46:57 <jeffwheeler> gwern: nice; I'm really hoping it can be switched to native bindings instead of a CLI soon
19:47:27 <jeffwheeler> gwern: and hopefully somebody with a vim keymap will come up with a clever binding for it.
19:47:51 <gwern> jeffwheeler: well, cc yourself to the librarify request on the hoogle tracker
19:48:07 <jeffwheeler> gwern: will do.
19:48:09 <gwern> it's an easy thing for ndm to do since it's cabalized, but he just hasn't done it is all
19:49:13 <jeffwheeler> I just 'starred' the issue; that does the same thing for Google.
19:49:48 <gwern> it'd also be nice if hoogle did popularity weighting, but I dunno how to do that in any easy way
19:55:32 <tehgeekmeister> do you need a backslash at the end of the line to continue an expression across multiple lines?  i forget...
19:56:20 <jeffwheeler> tehgeekmeister: what does your code look like? Usually with nice formatting it should be unnecessary.
19:56:47 <ozy`> tehgeekmeister: no, you just need to indent the continuing line
19:56:50 <tehgeekmeister> jeffwheeler: it's pretty neat and tidy
19:56:53 <tehgeekmeister> okay
19:57:22 * jeffwheeler just realized that I really don't have a single free font on my machine, that I'm aware of.
19:57:37 <jeffwheeler> Definitely not a free sans-serif font.
19:58:24 <tehgeekmeister> next question, then; is there a way to do constructor pattern matching inside a do notation block?
19:59:32 <sjanssen> do (Just x) <- foobar; return x
19:59:34 <gwern> backslashes are for continued strings
20:00:02 <tehgeekmeister> sjanssen: err, not quite what i meant
20:00:08 <chromakode> jeffwheeler: it's worth browsing dafont.com for some
20:00:10 <sjanssen> tehgeekmeister: or you can just use case
20:00:13 <tehgeekmeister> i meant something similar to
20:00:31 <tehgeekmeister> foo (Bar a) = ...
20:00:37 <tehgeekmeister> foo (Baz a) = ...
20:00:40 <jeffwheeler> chromakode: yeah, but I really quite like keeping my machine clean. I suppose I do have FontExplorer, though . . .
20:00:53 <StoneToad> tehgeekmeister: use a case statement
20:00:58 <jeffwheeler> Meh, I'll show off in Helvetica and let that stay for a bit.
20:00:59 <tehgeekmeister> okay
20:01:00 <tehgeekmeister> thanks
20:01:04 <sjanssen> tehgeekmeister: do x <- blah; case x of Bar a -> ..., etc.
20:01:37 <SamB_XP> augustss: remind me why contexts on data daclarations are allowed
20:02:25 <jeffwheeler> Check out these: http://media.nokrev.com/junk/haskell-logos/logo3.png and http://media.nokrev.com/junk/haskell-logos/logo4.png
20:02:40 <jeffwheeler> I don't like #3, actually.
20:02:51 <ozy`> jeffwheeler: neat design
20:03:08 <chromakode> I like #4
20:03:15 <jeffwheeler> Thanks, but the credit goes to Darrin who posted the idea.
20:03:37 <jeffwheeler> chromakode: I'll add it to the wiki page.
20:04:13 <chromakode> nice choice lining up the H with the '=' of your logo
20:04:26 <chromakode> it's a bit phallic though...
20:04:39 <jeffwheeler> chromakode: XD, indeed
20:04:42 <jeffwheeler> I'll leave that one out.
20:05:23 <JohnnyL> What is *the* editor to use for Haskell programs?
20:05:30 <chromakode> ed
20:05:40 <gwern> emacs, yi, vim imo
20:05:42 <SamB_XP> JohnnyL: a magnet
20:05:54 <JohnnyL> sh: ed: command not found
20:05:55 <wli> ed is the standard UNIX editor ;)
20:05:56 <sjanssen> JohnnyL: most people use their favorite general purpose editors.  emacs and vim a popular
20:06:06 <gwern> there are rumors about visualstudio, but I shune the frumious closed-sourcernatch
20:06:14 <JohnnyL> can you use tags with haskell?
20:06:18 <ozy`> JohnnyL: vim's pretty good. emacs is a bit better. there's also yi, but you kind of have to already know haskell
20:06:27 <sjanssen> JohnnyL: yeah, there are some tags generators
20:06:34 <gwern> yes; ghc's tag generator is called 'hasktags'
20:06:42 <mdmkolbe> Does 6.8 have any sort of type functions?
20:07:05 <SamB_XP> ozy`: why, because yi is only half-done ?
20:07:16 <ozy`> SamB_XP: among other reasons
20:07:23 <ozy`> (half? that much?)
20:07:29 <gwern> SamB_XP: no, because to set up a good haskell mode, you need to write a yi.hs, and it's not as easy as xmonad.hs
20:07:38 <SamB_XP> ozy`: er, partially
20:07:42 <SamB_XP> sorry for the confusion
20:07:46 <ozy`> :p
20:07:55 <ozy`> I'm just taking a dig at the yi devs
20:08:06 <jeffwheeler> Fortunately, examples/yi.hs :)
20:08:13 <SamB_XP> wouldn't they agree ?
20:08:18 <gwern> the incompleteness is bad, certainly, but most of it's nothing a competent haskeller couldn't put together within a few days or a week
20:08:30 <SamB_XP> gwern: then why isn't it there yet
20:08:34 <SamB_XP> apathy ?
20:08:46 <JohnnyL> gwern ok, for use in emacs/vi?
20:08:48 <sjanssen> gwern: why is it so hard to write a yi.hs, are yi's defaults broken?
20:09:13 <jeffwheeler> I use the default yi.hs, for the most part.
20:09:24 <gwern> sjanssen: it's complex, and poorly documented, and there doesn't seem to be a good story for how modes should set keymaps
20:09:28 <jeffwheeler> Mine's just way simpler. I removed most all of their stuff and just have the main function.
20:09:39 <gwern> half my yi.hs is just binding keys in haskell-mode to useful functions
20:10:06 <gwern> we can't make them default because mine are emacs style, and oh noes that'd trample on the vim and other emulations
20:10:24 <sjanssen> mdmkolbe: GHC 6.8 has fundeps, and a partial implementation of type families
20:11:18 <sjanssen> gwern: doesn't mainline yi have an emacs emulation mode?  Seems like a good place to stick your bindings
20:11:29 <mdmkolbe> thx sjanssen
20:11:40 <sjanssen> gwern: also, do you actually use yi for hacking?
20:11:41 * mdmkolbe goes off to study up on type families
20:12:27 <sjanssen> mdmkolbe: note, GHC 6.8's implementation has lots of bugs
20:13:01 <gwern> sjanssen: yes. haskell hacking; yi's haskell mode is better than emacs'
20:13:11 <gwern> *once you've set it up, that is...
20:14:18 <ozy`> yi desperately needs a default setup. any default setup.
20:14:30 <sjanssen> it doesn't have any default setup?
20:14:35 <ozy`> it took me an hour to figure out I just needed a yi.hs file in the right place
20:14:45 <ozy`> that was when I could get it to compile
20:15:02 <sjanssen> really, if you're missing a config it just doesn't run?
20:15:05 <ozy`> yep
20:15:13 <sjanssen> that's stupid
20:15:14 <jeffwheeler> It definitely is not intuitive, yet.
20:15:18 <ozy`> it tries to load a binary, fails, and dies
20:15:49 <sjanssen> hmm, they need to learn from xmonad :).  We've been doing this stuff right for more than a year now
20:15:58 <gwern> ozy`: no it doesn't; if you don't have a yi.hs or a custom yi binary, yi opens up and gives you an error about keymap not defined
20:16:20 <ozy`> gwern: so the behavior's changed in the last three or four months?
20:16:20 <gwern> if you hit 'h' as it suggests, it gives you this message:
20:16:23 <gwern> This instance of Yi is not configured.
20:16:26 <gwern> To get a standard reasonable keymap, you can run yi with either --as=cua, --as=vim or --as=emacs.
20:16:29 <gwern> You should however create your own ~/.yi/yi.hs file:
20:16:33 <gwern> You can type 'c', 'e' or 'v' now to create and edit it using a temporary cua, emacs or vim keymap.
20:16:47 <jeffwheeler> (I _love_ that feature.)
20:16:52 <ozy`> on my PPC machine (which is unsupported by everything, naturally) it just died with no explanation
20:17:02 <gwern> and 'e' opens up .yi/yi.hs with a big defaults yi.hs
20:17:14 <ozy`> well then that's nice
20:17:40 <gwern> I'm not saying it's perfect, it should at least let you do things as normal once you've chosen the mode, but it doesn't just crash
20:17:45 * gwern speaks of darcs yi obviously
20:19:48 <ozy`> (speaking of epic PPC failures, I'm still baffled by this Setup bug...)
20:19:49 <ozy`> http://pastie.org/private/hhcde0zfy1eakgyqiyp9w
20:20:33 <ozy`> (what's the best way to trace this? is this more likely a compiler error than a problem with Setup.hs itself?)
20:27:03 <Megzlnaa> is Maybe an ancient Monad?
20:28:01 <gwern> Megzlnaa: no, it's one of the Elder Monads
20:28:03 <ozy`> Megzlnaa: yes, it was discovered by the Aztecs
20:28:07 <gwern> along with List and Either
20:28:07 * SamB_XP attempts a citeseer search to answer the question
20:28:17 <ozy`> Megzlnaa: what do you mean, "ancient?"
20:28:19 <SamB_XP> gwern: lol
20:28:25 <SamB_XP> still lol
20:28:26 <orbitz> is there a standard function to convert "2008-12-15 00:06:36" to something i can do math with (comparing times)
20:28:26 <gwern> pgthu Ry'leh ftaghn IO!
20:28:35 <SamB_XP> man am I punchy
20:29:40 <orbitz> ah found it
20:29:51 <sjanssen> ozy`: most likely a GHC bug/busted GHC installation
20:30:02 <orbitz> drats. not in 6.6
20:30:03 <GNUlicious> lol at timing, I just read the religions article now.
20:30:20 * SamB_XP tries google scholar
20:30:28 <gwern> 'that is not evaluated which can eternal lie / and with strange eons unsafePerformIO will die'
20:30:54 <ozy`> sjanssen: yeah, I figure it's the former, seeing as it happens whether I try to compile with source or whatever else
20:32:26 <sjanssen> are old versions of the report online?
20:32:33 <SamB_XP> well, I found "instance Monad Maybe" in the Gopher 2.28 release notes from 1993 ...
20:33:25 <sjanssen> yeah, I bet that instance is about as old as the class
20:33:42 <SamB_XP> http://www.haskell.org/haskellwiki/Definition
20:33:45 <SamB_XP> has back to 1.0
20:38:51 <centrinia> Is there a school with a department of experimental epistemology?
20:40:45 <SamB_XP> what's epistemology ?
20:40:51 <orbitz> study of how we know things
20:40:55 <orbitz> aka study of knowledge
20:40:59 <centrinia> Yeah.
20:41:05 <SamB_XP> of course not!
20:41:18 <SamB_XP> you aren't allowed to know things at school! that's preposterous
20:41:45 <Korollary> so they shouldn't teach FP at schools?
20:41:47 <orbitz> is experimental epistemology mean tto be epistemology on the cutting edge or doign experimetns?
20:42:11 <centrinia> It involves experiments.
20:42:13 <SamB_XP> orbitz: doing experiments duh
20:42:23 * orbitz licks SamB_XP 
20:42:36 <SamB_XP> that's one strange experiment
20:42:48 <centrinia> I want to know where the epistemologist in this story got his degree: http://www.mit.edu/people/dpolicar/writing/prose/text/epistemologicalNightmare.html
20:43:45 <jeffwheeler> MIT?
20:47:26 <SamB_XP> lol @ Because, as I told you, you don't believe any of them.
20:49:09 <orbitz> lawlz
20:51:17 <SamB_XP> lol @ My goodness, do you mean to say that you can't even tell me what you believe without consulting the machine?
20:51:57 <SamB_XP> Epistemologist (sadly):
20:51:57 <SamB_XP>     It doesn't work. Whenever I ask myself what I believe, I never get any answer!
20:51:59 <centrinia> Yeah, that was pretty sad and funny at the same time.
20:55:47 <llayland> well obviously the Epistemologist believes that he has beliefs
20:56:10 <JohnnyL> anyone here use htags and get: Parse Error: (SrcLoc {srcFilename  ?
20:59:36 <SamB_XP> I love the last line!
20:59:46 <SamB_XP> I quite agreed with the machine ;-)
21:05:01 * centrinia gives the machine to SamB_XP as a Christmas present. :)
21:05:30 <SamB_XP> ah, but now I'll have to figure out how to fix it
21:06:11 <centrinia> That's why I wanted to know where I can find a department of experimental epistemology in the first place. ;)
21:06:28 <SamB_XP> there isn't one
21:06:55 <SamB_XP> this guy didn't get a degree in it -- he got a degree in criminal justice, actually
21:08:23 <lament> high-energy epistemology
21:09:22 <SamB_XP> he should have asked the thing if P=NP
21:09:35 <centrinia> Does he believe if P=NP?
21:09:46 <SamB_XP> no, just if P=NP
21:09:58 <SamB_XP> it knew that he'd be better off not trusting it all the time like that
21:15:32 <Cale> http://cale.yi.org/haskell-logo-4up.png
21:16:27 <Adamant> crazy jibberish
21:16:43 <Adamant> not that logo - it's nice
21:16:46 <lament> those aren't real stars
21:16:58 <Cale> No, they are circles.
21:17:01 * wli is in the market for computer hardware, esp. laptops with integrated cellular modems.
21:18:01 <SamB_XP> hey, include that euro-constellation thing so it can't be photocopied ;-P
21:18:30 <lament> copying is fine, you just can't mutate
21:19:55 <Cale> http://cale.yi.org/haskell-logo-6up.png -- w/ b&w versions.
21:20:57 <byorgey> Cale: very nice =)
21:21:12 <Cale> thanks :)
21:21:39 <SamB_XP> ugh, banding!
21:21:59 <Adamant> Cale: you an artist?
21:22:18 <Cale> Adamant: I suppose so. Not professionally.
21:22:23 <Adamant> or "graphic designer" or whatever they call it these days
21:22:26 <Adamant> ah
21:22:31 <Adamant> still cool though
21:22:37 <SamB_XP> good enough for the Haskell community
21:22:38 <Adamant> math + art
21:22:54 <Adamant> what other fields are there left to conquer?
21:23:48 <SamB_XP> Cale: I'm not sure what the top left one is supposed to be for ...
21:23:49 <gwern> centrinia: it may sound funny, but 'experimental philosophy' does exist
21:24:16 <Adamant> gwern: yeah, it's trying to experiementally discover the truth of philosophical assertions
21:24:16 <SamB_XP> gwern: how the heck does it exist ?
21:24:33 <gwern> SamB_XP: very well
21:24:41 <Cale> SamB_XP: Yeah, perhaps I should make the black regions outline in that one.
21:25:19 <gwern> but if you mean what does it do, well, instead of arguing if people would shove a fat man onto a track to save 5 innocents, an experimental philosopher goes and does surveys and that sort of thing
21:25:33 <SamB_XP> gwern: aww
21:26:13 <SamB_XP> oh, but I thought you were supposed to have one guy on one branch of track and 5 people on the other
21:26:29 <sjanssen> gwern: wouldn't you have to actually create the scenario to really know?
21:26:35 <Gracenotes> hm, what is the identity arrow for monads (if this question makes any sense)?
21:26:48 <Cale> http://cale.yi.org/haskell-logo-6up.png -- updated.
21:26:53 <SamB_XP> placed there by some maniac, like snidely wiplash ... or an experimental philosopher ...
21:26:59 <gwern> well, that's a variant that a x philosopher would ask - do people see a difference between pushing a fat man, and flipping a switch, even though the utilities are the same?
21:27:17 <dridus> Gracenotes: id?
21:27:18 <gwern> sjanssen: the research boards would not approve such an experiment, alas
21:27:44 <SamB_XP> well, pushing the fat man is funnier
21:27:52 <gwern> Cale: hm. going for a mt fuji look?
21:27:52 <Gracenotes> dridus: what would that look like in >>=/return notation?
21:27:53 <SamB_XP> possibly because he is fat
21:28:12 <SamB_XP> but also seems less likely to actually save the other 5's lives
21:28:20 <gwern> SamB_XP: oh, it is. it's a comical mental image - the fatman licking his ice cream, oblivious to the subject sneaking up on him...
21:28:25 <Gracenotes> wait, it's probably one of the three monad rules
21:28:28 <Cale> gwern: I didn't actually have a specific mountain in mind.
21:28:38 <SamB_XP> gwern: or the train thundering on
21:28:43 <gwern> sjanssen: but anyway, you can read this in https://secure.wikimedia.org/wikipedia/en/wiki/Experimental_philosophy
21:28:53 <gwern> 'Experimental philosophy is a form of philosophical inquiry that makes at least partial use of quantitative researchespecially opinion pollingin order to address philosophical questions. '
21:29:11 <Gracenotes> hm. or not. I suppose this'll make more sense as I read on.
21:29:52 <dridus> Gracenotes: well sounds like you're talking about monads if you're talking about >>=/return. If you want an IO action that just acts as identity on the righthand side of >>=, you want just return probably
21:31:04 <Gracenotes> oh, I read that monads were a type of arrow. So objects must have a sort of identity arrow involving monads
21:31:13 <dridus> if anyone has a moment and knows about extensible exceptions in ghc 6.10.1, I was wondering if anyone knows why GHC.IOBase.catchAny doesn't have a non-GHC-specific name... I'm trying to port some code in hs-plugins to work with GHC 6.10.1, but it's complaining about an ambiguous type variable, when all I need is Show e
21:31:33 <Gracenotes> in the context of category theory...
21:31:37 <dridus> Gracenotes: I think that would be returnA then
21:31:50 <dridus> Gracenotes: but don't quote me on it... I'm a newb
21:32:05 <Gracenotes> @type returnA
21:32:07 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
21:32:20 <Gracenotes> @instances Arrow
21:32:21 <lambdabot> (->), Kleisli m
21:32:53 <Gracenotes> hm. Yeah, I'm not quite sure what category theory in its entirety *is*. trying to learn, though
21:33:04 <SamB_XP> abstract nonsense!
21:33:06 <SamB_XP> that's all
21:33:25 <Gracenotes> well, monads at least are warm fuzzy abstract nonsense
21:33:57 <SamB_XP> Cale: hmm, I think the upper left one would look better with the lambda black ;-P
21:34:16 <dons> http://twitter.com/sigfpe/statuses/1061161347  (woo!)
21:34:16 <Cale> SamB_XP: That's a good idea :)
21:35:23 <gwern> tom duff of duff's device?
21:35:51 <dons> yup...
21:36:04 <dons> the revolution will not be televised.
21:36:37 <gwern> dons: I have my eye on a t-shirt which features a victorian man hoisting an ak-47, proclaiming The Revolution Will Not Be Telegraphed
21:36:42 <SamB_XP> dons: nonsense!
21:36:52 <SamB_XP> the media wouldn't miss it for the world!
21:37:23 <SamB_XP> gwern: will it be semaphored ?
21:37:47 <gwern> SamB_XP: presumably it will be grapevined
21:37:48 <JohnnyL> where are some sites that support haskell webserving?
21:38:08 <SamB_XP> example.com?
21:39:03 <dons> gwern: hehe
21:39:14 <dons> JohnnyL: you mean, isp's?
21:39:20 <wli> I downloaded and watched that movie about Hugo Chavez.
21:40:26 <JohnnyL> dons yeah
21:41:23 <dons> any that support binaries
21:41:37 <dons> i.e. cgi. any that let you host servers in user land on other ports
21:41:39 <dons> (via happs)
21:42:10 <JohnnyL> dons oh, i'm sure that'll happen. hehe
21:42:23 <dons> Cale: no submission yet?
21:42:29 <dons> we've lots of interesting ideas for new logos, http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
21:42:39 <Cale> http://cale.yi.org/haskell-logo-6up.png
21:42:48 <dons> i set a deadline for Dec 31, after which #haskell will pick 3 or 5 or so, and then everyone can vote.
21:42:55 <wli> YTF is my heap so slow.
21:43:05 <dons> mmm. Cale is that Mt. Hood? :)
21:43:16 <dons> (the mountain in Portland, OR, where Haskell got named..)
21:43:33 <Cale> I didn't have a specific mountain in mind, but that's an interesting take on it :)
21:43:45 * wli is homesick for PDX
21:43:49 <dons> mt. hood is famously pointy, http://vulcan.wr.usgs.gov/LivingWith/Historical/LewisClark/NewOldPhotos/mount_hood_USGS.jpg
21:43:52 * gwern installs hackage. goodness, hours later and I'm only up to libgeni
21:44:05 <cygnus_> !hackage
21:44:15 <dons> gwern: cabal install $(everything) ?
21:44:29 <dons> Cale: make sure it ends up on the wiki page though, when you're done.
21:44:37 <gwern> dons: a for loop with ; for ignoring errors, but yes
21:45:05 <dons> gwern: oh, you shouldn't need a loop
21:45:05 <gwern> it would be easier to process the output of 'cabal list' if people wouldn't use '*' in their summaries...
21:45:10 <dons> cabal install $(cat list) should work
21:45:14 * BMeph would like to see a Monice Monad doll on CafePress...
21:45:17 <dons> --short-output ?
21:45:24 * BMeph meant *Monica
21:45:40 <gwern> dons: I don't believe that option exists
21:45:46 <dons> http://haskell.org/sitewiki/images/e/ed/Haskell-flower.png is unusual
21:46:05 <dons> $ cabal list --simple-output
21:46:06 <dons>  ?
21:46:44 <gwern> ok, simple-output works
21:46:52 <gwern> but it outputs every version, it seems
21:47:12 <dons> quite so!
21:47:13 <Megzlnaa> some of those logos look way too high tech
21:47:22 <Megzlnaa> but  http://hackage.haskell.org/trac/haskell-prime/chrome/common/HaskellLogo_2.jpg
21:47:24 <Megzlnaa> looks classical
21:47:43 <dons> what's the circle mean in that one?
21:47:55 <dons> or is it a eucalyptus lozenge?
21:47:55 <gwern> many of the suggestions look better than the current one
21:48:06 * EvilTerran likes the first two on the page in particular
21:48:07 <dons> many look more modern too.
21:48:10 <gwern> the flower one is interesting because it's so abstract it works well
21:48:11 <dons> the current one is by accident
21:48:19 <Megzlnaa> accident how?
21:48:25 <EvilTerran> in http://haskell.org/haskellwiki/Image:Haskell2v3.png , it's a bit hard to spot the lambda, tho
21:48:46 <gwern> dons: perhaps we could settle on two logos - kind of like how debian has the Free swirl but reverses the swirl-out-of-a-lamp (or was it vice-versa?)
21:48:57 <EvilTerran> http://media.nokrev.com/junk/haskell-logos/logo1.png is probably my favourite of those so far
21:49:41 <gwern> EvilTerran: I liked the greyer one better, although that wasn't bad
21:49:45 <Megzlnaa> that looks like some weird techno nightclub dance party clothing company logo
21:50:03 <Megzlnaa> very 'k'
21:50:18 <Megzlnaa> high tek
21:50:21 <SamB_XP> EvilTerran: it needs to lose the lense flare IMO
21:50:49 <SamB_XP> but I like the Commodore logo/Lambda/Bind look
21:51:42 <ddarius> SamB: Lense flare?
21:51:57 <SamB_XP> ddarius: there's some kind of radial gradiant
21:52:12 <SamB_XP> it bands really badly in 16-bit mode
21:54:08 <dons> i think that one looks a bit 80s.
21:54:16 <malouin> even with all the lambdas, none of the logos say Haske...
21:54:21 <Megzlna> I'm really depressed about Haskell now
21:54:27 <SamB_XP> well, I'm 80s if you don't mind
21:54:27 <dons> oh?
21:54:42 <dons> not enough narwhals?
21:54:42 <SamB_XP> I actually like the Commodore-style one :-P
21:54:43 <jeffwheeler> SamB: I can do the lens flare, if you like. :)
21:54:53 <SamB_XP> jeffwheeler: I don't want a lense flare!
21:54:53 <Megzlna> hey dons, why dont we just implement  http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html   ?
21:54:57 <wchogg> There are never enough narwhals.
21:54:59 <Megzlna> I'll put in 2 hrs a day
21:55:04 <Megzlna> on GHC
21:55:08 <dons> how many hrs would it take?
21:55:24 <Megzlna> i'm not sure?
21:55:34 <Megzlna> But I dont know much about GHC to begin working on a patch
21:55:48 <Megzlna> it must be difficult, if simon himself didnt even do it
21:55:50 <Megzlna> so I dont know
21:55:51 <dons> basically, someone has to ask for it.
21:56:00 <jeffwheeler> If anybody cares, I can put up a version of any of the logos without the gradient bg.
21:56:01 <dons> make it a worthy thing to spend time on.
21:56:11 <dons> jeffwheeler: yeah, a simple version would be good
21:56:16 <dons> when need simple versions of all of them
21:56:18 <dons> i'll add a note
21:56:24 <dons> white background only version
21:56:41 <jeffwheeler> Anybody have a preference about which one I remove the bg from?
21:57:30 <jeffwheeler> Or, I suppose I can just do 'em all. :P
21:57:43 <dons> pick the one you like!
21:57:57 <jeffwheeler> Simple enough.
21:59:05 <erikc> i like cale's last logo with the stars
21:59:21 <Cale> erikc: :)
21:59:44 <chromakode> aha, a deadline!
22:00:35 * sjanssen likes http://haskell.org/haskellwiki/Image:BurkeLibbey_Haskell.png
22:00:47 <jeffz`> jeffwheeler: I'm ready to order a Haskell tracksuit and sneakers with http://media.nokrev.com/junk/haskell-logos/logo3.png :)
22:01:01 <sjanssen> perhaps minus the "Pure . Lazy . Functional" bit
22:01:18 <jeffwheeler> jeffz`: and I'm ready to take all the profits from that store.
22:01:29 <hoopy> jeffz`: i looked at all the logos on the wiki and i like that one the best
22:01:31 <Megzlna> That Burke Libbey one is neat, except for the catchphrase part
22:01:35 <Megzlna> nice font and lambda.
22:01:42 <ddarius> jeffz`: Shades of xmonad...
22:01:56 <jeffz`> hoopy: it reminds me of adidas and the EA sports logo
22:02:06 <SamB_XP> mmm ... I kinda like the catchphrase ;-)
22:02:42 <SamB_XP> jeffwheeler: do you like the C64 ?
22:02:46 <sjanssen> it stands out too much, draws the eyes from "Haskell", which should be the focus of any logo
22:02:51 <jeffwheeler> SamB_XP: I'm too young to have ever used one.
22:02:57 <SamB_XP> jeffwheeler: nonsense
22:03:07 <SamB_XP> you just haven't tried hard enough!
22:03:11 <jeffwheeler> SamB_XP: okay; well, I've never used one. :P
22:03:47 <ddarius> dons: The reason such things haven't been implemented is because (almost) everyone agrees that a nice, powerful, orthogonal system has not been realized yet.
22:03:53 <SamB_XP> How about putting the Haskell belolow the bind ?
22:04:05 <SamB_XP> ddarius: not everyone ?
22:04:21 <ddarius> SamB_XP: Presumably in some cases, the creators think they did good.
22:04:51 <jeffwheeler> SamB_XP: you mean for logo3.png?
22:05:00 <JohnnyL> SamB i was big on the c64.
22:05:00 <SamB_XP> jeffwheeler: yeah
22:05:06 <JohnnyL> SamB_XP ^
22:05:11 <jeffwheeler> SamB_XP: I'll give it a shot.
22:06:19 <jeffwheeler> In the meantime, I'm adding a couple without the bg.
22:07:03 <jeffwheeler> http://media.nokrev.com/junk/haskell-logos/logo6.png is the first one.
22:08:51 <JohnnyL> dons so cgi is haskell (HAppS) basically?
22:09:36 <jeffwheeler> http://media.nokrev.com/junk/haskell-logos/logo7.png, too
22:10:57 <JohnnyL> jeffwheeler looks like an Airline logo.
22:11:18 <jeffwheeler> JohnnyL: haha, "We'll fly your code straight into the ground."
22:11:26 <Cale> It does look like an airplane :)
22:11:27 <chromakode> any critique of my diagonal 'H' logo?
22:11:49 <jeffwheeler> chromakode: I like it, but it took me a long time to see the lambda.
22:12:04 <chromakode> I like jeffwheeler's because it looks remarkably like Japanese Kanji, and Haskell has always had a distinctly Japanese feel to me.
22:12:10 <chromakode> hehe.
22:13:00 <chromakode> yeah, I found it's difficult to pull off that inner symbol without overdoing it
22:13:27 <jeffwheeler> After I saw it, it made a lot of sense, and now it seems quite clever. Just hard to get initially.
22:13:28 <Cale> chromakode: It's nice. I'm somehow reminded of a Microsoft logo for Visual C++ from way back. :)
22:14:03 <chromakode> Cale: http://www.microsoft.com/presspass/images/gallery/boxshots/web/wincetoolkitforvc++6.jpg
22:14:27 <jeffwheeler> That star thing on the right is awesome.
22:14:29 <sjanssen> chromakode: needs more lambda
22:14:44 <lament> lambda, the ultimate logo
22:14:48 <Cale> chromakode: Yeah, that's a newer version of it :)
22:14:52 <ddarius> lament: Indeed.
22:15:21 <jeffwheeler> Why do all the logos incorporate lambdas anyways? It's like we think that's the only big idea in Haskell.
22:15:22 <chromakode> don't other languages use lambda, though?
22:15:25 <jeffwheeler> Perhaps just the easiest to illustrate.
22:15:34 <lament> because >>= is taken.
22:15:51 <jeffwheeler> chromakode: yep; I think it's Scheme's logo
22:15:53 <Cale> Well, lambda is the symbol of functional programming.
22:15:58 <chromakode> that's what I thought
22:16:05 <lament> http://schemers.org/
22:16:12 <lament> very nice logo there
22:16:22 <lament> lambda in parens
22:16:22 <chromakode> hahaha
22:16:31 <Megzlna> http://www.geocities.com/Athens/Oracle/8465/monad/MONAD3.gif
22:16:31 <jeffwheeler> Cale: perhaps we should have big Venn Diagrams for categorical theory. :D
22:16:34 <Megzlna> ^--- monad
22:16:44 <chromakode> I think in a perfect world, all languages would have logos like Python's
22:16:46 <ray> the "monad square"
22:17:02 <znutar> I think the logo should be John Dee's hieroglyphic monad http://www.esotericarchives.com/dee/monad.htm
22:17:09 <Cale> jeffwheeler: Category diagrams would make more sense. :)
22:17:26 <jeffwheeler> Cale: probably, but I don't know any category theory, so they're above me. :P
22:17:39 <ddarius> jeffwheeler: Venn Diagrams have nothing to do with category theory.
22:17:49 <jeffwheeler> ddarius: I figured, but they make the association for me.
22:17:59 <Cale> We could use the commuting square for a natural transformation to represent Haskell's parametric polymorphism.
22:18:08 <Megzlna> http://www.harrypotterforseekers.com/images/MonadJohnDee.jpg
22:18:11 <Cale> http://upload.wikimedia.org/wikipedia/commons/5/58/NaturalTransformation-01.png
22:18:12 <jeffwheeler> Yeah! That's the spirit, Cale!
22:18:23 * cads can't decide whether he wants a universal quantifier, lambda, integral, or pi symbol tattoo..
22:18:36 <chromakode> definitely the universal quantifier
22:18:51 <lament> Cale: ugh, that's even more ugly than (and oddly reminiscent of) the current logo
22:19:48 <Cale> The problem with the universal quantifier is that from some directions, it's just an A ;)
22:19:54 <sjanssen> the universal quantifier seems like a bad idea, clueless people will just ask "what's up with the upside down A"?
22:20:05 <jeffwheeler> What's with that awful use of "--" instead of a proper dash in the title of http://python.org/?
22:20:11 <jeffwheeler> Right there at the top; it's ugly!
22:20:23 <Cale> Get a circle, and claim that it represents function composition ;)
22:20:25 <zloog> Is there a way to downgrade my Text.Regex libraries in Ubuntu?
22:20:41 <ddarius>  : T^2  T
22:20:55 <chromakode> jeffwheeler: I agree, but I also think that "Official Website" has no place in the header at all
22:21:00 <centrinia> Maybe "Official Website" is merely a comment. ;)
22:21:10 <Cale> Get the commutative diagram for a Hopf algebra
22:21:18 <ddarius> cads: Get them all!
22:21:33 <jeffwheeler> centrinia: You're probably right. :P
22:21:43 * Cale wants a tattoo of the entire category Set, but doesn't have enough skin for that.
22:21:56 <Cale> http://upload.wikimedia.org/wikipedia/commons/9/9c/HopfAlgebra.png
22:21:59 <cads> zloog, I don't really trust apt to manage haskell for me
22:22:04 <cads> i'd do it manually
22:23:12 <ddarius> Cale: We should make a single 2-diagram encoding the monad laws.
22:23:16 <zloog> cads: Yea, I'm running the repos haskell install but Id really really like to use the same verison of regex that RWH uses. Can I just use cabal and expect it to work?
22:23:23 * jeffwheeler finds it amusing to find a header "Python 3.0 final released" right below the header "Python 2.6.1 released".
22:23:32 <ddarius> Well, I guess it would have to be a 3-diagram.
22:23:51 <SamB_XP> jeffwheeler: well, who'd want to use Python 3000 ?
22:24:10 <jeffwheeler> SamB_XP: not I, until Django does.
22:24:27 <cads> zloog, i'd expect cabal to be able to swing that
22:24:51 <zloog> cads: O well, its easy to reinstall ubuntu even if I screw up
22:24:58 <zloog> gonna try it
22:25:23 <Philippa_> ddarius: I basically offered to sketch it for my dad earlier over dinner tonight...
22:25:24 <cads> hehe, ubuntu's not _that_ likely to just blow up
22:25:53 <lament> the haskell logo should be http://arcanux.org/lambdacats/io-monad.jpg
22:26:39 <JohnnyL> lambdabot thats big eyes for a small cat.
22:26:54 <cads> quick poll/question, which *nix embraces ghc/cabal the best and gives the most comfortable environment, up to date packages in the repositories and the like
22:27:29 <Philippa_> I know which dons'd say :-)
22:27:42 <cads> i've been using ubuntu/debian and it's pretty good, though cabal needs to be compiled from scratch
22:28:27 <jeffwheeler> cads: not OpenBSD. :P
22:28:37 <jeffwheeler> cads: apparently archlinux has pretty much everything.
22:29:23 <zloog> cads: Is there an uninstall command? I tried the config/build/install from an old hackage tarball, but the verison number is still too high
22:29:33 <JohnnyL> lament ^
22:30:15 <vegai> jeffwheeler: funnily though, dons works on both of those :)
22:30:31 <cads> Philippa, which would dons say? something like gentoo?
22:31:24 <cads> i was surprised to find out that ghc/cabal will compile "out of the box"
22:31:42 <vegai> cads: dons is a developer in Arch Linux
22:32:20 <vegai> so I would hope he'd recommend that :P
22:33:14 <SamB_XP> cads: uh, well, it has to grab GHC binaries to build GHC you know ...
22:35:02 <wagle> what happens when a cobol virus deletes all the ghc binaries?
22:36:11 <SamB_XP> wagle: I don't think that's very likely
22:36:12 <lament> wagle: bad stuff. Other compilers have the same problem.
22:36:16 <lament> wagle: (eg gcc)
22:36:25 <SamB_XP> anyway, we just download new ones from the backup tapes
22:37:01 <cads> SamB, in ubuntu there's a broken dependency, the ghc package is the wrong version for the cabal package..
22:37:13 <SamB_XP> cads: oh!
22:37:24 <cads> so I was happy to know that a source based distro manages to get it right :D
22:38:10 <lament> wagle: what happens when a nanotech virus deletes all the DNA transcryptase? :)
22:39:16 <SamB_XP> lament: the AI suddenly realizes that it's very boring without us organic life-forms around
22:40:01 <cads> grr.. I wish i had the time to learn the ins and outs of something like arch or gentoo.. i like the idea of slick optimized software but can't deal without autocofiguration scripts and plush defaults in a desktop environment
22:40:12 * cads is a fan of convention over configuration
22:41:58 <bos> babies love strong types: http://www.facebook.com/photo.php?pid=1287115&id=502614155
22:43:53 <lament> SamB_XP: it will be so sad :(
22:46:56 <cjs> If I've got a C function that normally returns a pointer, but has some special constants (e.g., #const CBR_BLOCK) that it can also return, how do I create a Ptr () of that constant value to return?
22:47:31 <cjs> Hm. WordPtr?
22:48:53 <Cale> cjs: Yeah, IntPtr and WordPtr are instances of Num and Eq, etc.
22:49:19 <cjs> Cool. Thanks.
22:50:02 <cjs> Don't like the names so much, though. PtrAsWord or something like that would be more descriptive to me.
22:50:12 <ddarius> Moral of the story: fromIntegral
22:50:28 <cjs> yeah, it was finding an instance of Num that slowed me down.
22:50:58 <cjs> Oops, Integral, I mean.
22:51:25 <ddarius> Num is what you mean.
22:51:55 <ddarius> Of course in this case you don't need fromIntegral, simply write the literal constant.
22:52:20 <cjs> Right.
22:55:15 <olsner> cjs: think intptr_t and uintptr_t, with uint mapped to Word
22:55:46 <olsner> (not that I know, but it sounds like it would be the logic behind the names)
22:57:50 <Megzlna> http://www.boingboing.net/images/x_2008/iraqimage007.gif
22:57:59 <Megzlna> awww ;/
23:09:23 <Megzlna> @src Functor
23:09:23 <lambdabot> class  Functor f  where
23:09:23 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
23:09:32 <nemik> i <3 /topic. because it told me about the Real World Haskell book. this is the best intro to the language i've yet seen and ultra-addictive
23:09:37 <Megzlna> why doesn't Functor call it simply "map" ?
23:10:00 <Megzlna> I don't understand the idea behind the 'f' in fmap
23:12:00 <bos> are IORefs pinned in memory?
23:12:03 <quicksilver> Megzlna: it should simply be called map.
23:12:08 <quicksilver> bos: no.
23:12:17 <bos> sigh. didn't think so.
23:12:20 <Megzlna> so fmap is some kind of error?
23:12:25 <quicksilver> Megzlna: unfortunately 'map' is a specialisation for list
23:12:39 <quicksilver> Megzlna: a regrettable decision and/or historical accident.
23:14:52 <bos> urgh, no nice fast map data structures available in base.
23:14:54 <Megzlna> you mean ? (a -> b) -> [a] -> [b]
23:15:33 <Megzlna> so essentially if 'fmap' had been the current 'map', then it would be   (a -> b) -> f a -> f b   where  'f'  is [] ?
23:16:38 <ddarius> quicksilver: It used to be that way.
23:16:47 <Megzlna> How do you do an fmap with   'f a'   becoming [a] ?
23:17:17 <jsn> Megzlna:     (+ 1) `fmap` [0..9]
23:17:25 <jsn> > (+ 1) `fmap` [0..9]
23:17:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:17:47 <jsn> instance Functor [] where { fmap = map }
23:19:19 <Megzlna> I just wanna see how 'f a' becomes [a]
23:20:03 <sjanssen> Megzlna: [a] is just special syntax for [] a
23:20:16 <Megzlna> so its really like
23:20:31 <Megzlna> (a -> b) -> [] a -> [] b
23:20:35 <Megzlna> when used on lists
23:20:51 <jeffwheeler> @src liftM
23:20:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:20:55 <ddarius> :t [] :: [] Int
23:20:56 <lambdabot> [Int]
23:20:58 <sjanssen> Megzlna: yes
23:21:08 <sjanssen> Megzlna: when f = [], fmap = map
23:21:17 <Megzlna> so why was map hardcoded on lists?
23:21:26 <Megzlna> the whole prelude is hardcoded on lists
23:21:42 <jeffz`> bos, are there more alternatives to Data.Map not on hackage?
23:21:45 <sjanssen> Megzlna: historical reasons, really
23:21:46 <Megzlna> Why even bother to do that if there could be a nice 'f' all over the place, allowing the prelude to be more generic
23:21:56 <bos> jeffz`: not that i know of
23:22:16 <sjanssen> Megzlna: and also some concerns about polymorphism
23:22:28 <jeffz`> bos, I only know of compact-map and berkeleydb, but I haven't tried them... plan to soon.
23:22:52 <sjanssen> eg. 'x = fmap f' runs afoul of the DMR, 'x = map f' doesn't
23:22:57 <bos> jeffz`: there's a whole bunch of other self-balancing stuff, too. look at edison.
23:22:58 <sjanssen> (assuming monomorphic f)
23:23:21 <jeffz`> bos, cheers
23:23:28 <jeffwheeler> I think this is what scares people away from Haskell: liftP q f k w x y z = f w x y z `q` k -- from RWH :)
23:23:31 <Megzlna> FMR?
23:23:32 <Megzlna> DMR?
23:23:40 <sjanssen> Dreaded Monomorphism Restriction
23:24:00 <opqdonut> haskell' removes DMR right?
23:24:08 <sjanssen> opqdonut: it isn't decided
23:24:19 <Megzlna> {-# LANGUAGE NoMonorphismRestriction #-}
23:24:27 <Megzlna> typo there :P
23:25:04 <Megzlna> I suppose, your codebase is 5% slower with that enabled?
23:25:11 <sjanssen> probably not
23:25:21 <opqdonut> well the status page says it's an accepted proposal
23:25:48 <sjanssen> but maybe.  I don't think anyone has quantified the effects of DMR on real code bases
23:26:16 <Megzlna> don't constants only matter once?
23:26:17 <olsner> Megant: with the normal length of a haskell program, that might well make up 5% of your codebase
23:26:40 <olsner> Megzlna*
23:26:47 <Megzlna> Since lazy stuff's just replaced by a thunk the first time
23:26:51 <sjanssen> Megzlna: polymorphic constants may be evaluated many many times
23:27:25 <sjanssen> x :: Num a => a; x = 2 ^ 1024 -- may be evaluated many times
23:27:41 <sjanssen> x :: Integer; x = 2 ^ 1024 -- is a CAF and will be executed once
23:28:35 <jsn> :info ($!)
23:28:43 <jsn> @info ($!)
23:28:43 <lambdabot> ($!)
23:29:09 <jsn> i am looking at    ($!)    and     ($)     and they appear to be the exact same thing
23:29:16 <jsn> is there any difference at all?
23:29:24 <sjanssen> jsn: ($!) seqs the argument before applying the function
23:29:27 <sjanssen> @src ($!)
23:29:27 <lambdabot> f $! x = x `seq` f x
23:29:30 <jsn> aha
23:29:31 <sjanssen> @src ($)
23:29:31 <lambdabot> f $ x = f x
23:36:00 <cjs> Hm. When I use something like withCString "foobarbam", how do I figure out the amount of storage that's been allocated?
23:36:11 <Megzlna> Are the Haskell graph libraries updatable?
23:36:36 <sjanssen> Megzlna: I think fgl has a mutable version
23:36:46 <bos> @hoogle withCStringLen
23:36:47 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
23:36:53 <bos> cjs: ^^^
23:37:08 <bos> @type CStringLen
23:37:09 <lambdabot> Not in scope: data constructor `CStringLen'
23:37:11 <cjs> Doesn't that produce a CString that has a length prepended?
23:37:14 <bos> no.
23:37:24 <bos> it tells you what the length is.
23:37:24 <Megzlna> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Graph.html    <--- totally immutable?
23:37:27 <cjs> Ah!
23:39:01 <jeffz`> Megzlna: why are you using Hugs?
23:39:18 <Megzlna> I just googled Data.Graph
23:39:48 <jeffz`> ah, well, google fgl, it's a more extensive graph library, which I think is a bit more flexible
23:40:11 <jeffz`> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
23:40:32 <jeffz`> the linked homepage has stuff worth reading
23:40:33 <Megzlna> Cale said don't even use that
23:40:40 <Megzlna> but to use Data.Map and Data.Set
23:40:43 <Megzlna> not sure why
23:41:16 <jeffz`> shrug, doesn't mean it's not useful.
23:41:45 <cjs> Ooo, weird. Why does '(withCWStringLen "abcdefgh" $ \(s,i) -> return i)' return 8? Oh, because I need to multiply it by the sizeOf the thing being pointed to....
23:42:29 <Cale> fgl has lots of useful algorithms, but an annoying user interface
23:42:48 <Megzlna> annoying how?
23:43:05 <Gracenotes> just wondering -- though it seems like an interesting intellectual pursuit -- category theory does have some application to Haskell, yes?
23:44:20 <ddarius> Gracenotes: For actually programming in Haskell, not terribly much.  There are some things.
23:44:46 <ddarius> Gracenotes: However, it could probably be applied more than it is.
23:45:01 <Gracenotes> it seems a lot of the language -- e.g. homomorphism -- shares some terminology with category theory
23:45:10 <Gracenotes> although such terms also exist in math at large
23:45:23 <ddarius> Gracenotes: "homomorphism" isn't a particularly common Haskell termh
23:45:35 <Gracenotes> no? catamorphism then? :)
23:45:42 <loop_> category theory seems awfully abstract
23:45:50 <ddarius> Gracenotes: catamorphism isn't a particularly CT term
23:46:01 <Gracenotes> mm, fair enough.
23:46:34 <Gracenotes> as far as I can tell, then, functors and monads?
23:46:39 <ddarius> Gracenotes: Most categorist would not know what the heck you were talking about if you said "catamorphism"
23:47:11 <ddarius> Gracenotes: Functors and monads do come directly from CT.  They are used rather differently than they typically are used in CT though.
23:47:52 <Gracenotes> interesting
23:48:14 <loop_> "catamorphisms are sometimes referred to as bananas."
23:48:34 <ddarius> @google "Bananas in Space"
23:48:39 <lambdabot> http://citeseer.ist.psu.edu/293490.html
23:48:39 <lambdabot> Title: Bananas in space: Extending fold and unfold to exponential types - CiteSeerX
23:49:10 <Gracenotes> loop_: I thought bind functions were sometimes referred to as bananas ;)
23:49:31 <Gracenotes> that is, http://blog.tmorris.net/20-intermediate-haskell-exercises/
23:50:18 <loop_> Gracenotes: link seems slow/broken
23:50:59 <sbahra> Seems broken
23:51:04 <Gracenotes> hm. basically, it's a series of exercises... one of the exercises involves
23:51:08 <Gracenotes> class Misty m where
23:51:12 <Gracenotes>   banana  :: (a -> m b) -> m a -> m b
23:51:13 <Gracenotes>   unicorn :: a -> m a
23:51:30 <Gracenotes> and you implement Misty [], Misty ((->) t), etc.
23:51:33 <sbahra> @hoogle (a -> m b) -> m a -> m b
23:51:34 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
23:51:34 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
23:51:34 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:51:50 <Gracenotes> you also implement moppy :: (Misty m) => [a] -> (a -> m b) -> m [b]
23:52:02 <Gracenotes> jellybean :: (Misty m) => m (m a) -> m a
23:52:17 <Gracenotes> which are suspiciously similar-sounding to certain haskell functions
23:53:31 <Gracenotes> @pl \func -> \tf -> (\s -> (func (tf s)) s)
23:53:31 <lambdabot> flip flip id . liftM2
23:54:26 <Gracenotes> @src (a -> b) (>>=)
23:54:26 <lambdabot> Source not found. My brain just exploded
23:55:07 <Gracenotes> huh, I can't find the source for Monad ((->) t) anywhere, although it seems to exist
23:55:28 <Gracenotes> > (return "first" >>= (\str -> (\item -> length (str ++ item)))) "second"
23:55:30 <lambdabot>   11
23:55:31 <ddarius> @src (->) return
23:55:32 <lambdabot> return = const
23:55:59 <Gracenotes> @src (->) >>=
23:55:59 <lambdabot> Source not found. That's something I cannot allow to happen.
23:56:38 <ddarius> @src (->) (>>=)
23:56:38 <lambdabot> f >>= k = \ r -> k (f r) r
23:56:57 <sbahra> ddarius, what does the first (->) do?
23:57:03 <Gracenotes> oh. that might do it... hm, did I really fail that many times?
23:57:19 <sbahra> Oh
23:57:36 <Gracenotes> I had it written as tf func = (\s -> (func (tf s)) s)
23:57:46 <Gracenotes> (>>=) tf func that is
23:58:04 <Gracenotes> so... same thing I guess
