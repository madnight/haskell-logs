00:00:05 <solrize_> @pl (\Foo a) -> a
00:00:05 <lambdabot> (line 1, column 8):
00:00:05 <lambdabot> unexpected ")"
00:00:05 <lambdabot> expecting pattern or "->"
00:00:10 <drbean> @hoogle [a]->a->a
00:00:11 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
00:00:11 <lambdabot> Prelude (!!) :: [a] -> Int -> a
00:00:11 <lambdabot> Data.List (!!) :: [a] -> Int -> a
00:00:19 <pumpkin> the typical fibs = 0 : 1 : zipWith (+) fibs (tail fibs) isn't ideal
00:00:25 <solrize_> @pl \(Foo a) -> a
00:00:25 <lambdabot> (line 1, column 7):
00:00:25 <lambdabot> unexpected "a"
00:00:25 <lambdabot> expecting operator or ")"
00:00:39 <solrize_> @pl \(Just a) -> a
00:00:39 <lambdabot> (line 1, column 8):
00:00:39 <lambdabot> unexpected "a"
00:00:39 <lambdabot> expecting operator or ")"
00:00:54 <solrize_> @pl (\(Just a) -> a)
00:00:54 <lambdabot> (line 1, column 9):
00:00:54 <lambdabot> unexpected "a"
00:00:54 <lambdabot> expecting operator or ")"
00:00:59 <solrize_> ?
00:01:10 <ski_> i don't think `pl
00:01:18 <ski_> ' uses a full haskell parser
00:01:22 <int-e> @src fromJust
00:01:22 <lambdabot> fromJust Nothing  = undefined
00:01:22 <lambdabot> fromJust (Just x) = x
00:01:37 <int-e> solrize_: @pl doesn't do pattern matches
00:01:41 <solrize_> thanks
00:03:44 <solrize_> :t listify
00:03:45 <lambdabot> forall r a. (Typeable r, Data a) => (r -> Bool) -> a -> [r]
00:03:50 <solrize_> @hoogle listify
00:03:50 <lambdabot> Data.Generics.Schemes listify :: Typeable r => (r -> Bool) -> GenericQ [r]
00:04:07 <ski_> @index listify
00:04:08 <lambdabot> Data.Generics.Schemes, Data.Generics
00:06:02 <mbz> where can I find a graph showing dependencies of the standard modules from GHC library?
00:10:29 <drbean> What's (!!) called, the operator that gives the nth element of a list?
00:10:55 <sjanssen> drbean: I read it as "index"
00:23:03 <mbz> @hoogle mmap
00:23:04 <lambdabot> package mmap
00:23:04 <lambdabot> package bytestring-mmap
00:23:19 <mbz> @hoogle munmap
00:23:19 <lambdabot> No results found
00:27:29 <bogner> so I'd like to get a list of the sums of every pair of numbers in a sorted infinite list, but I can't think of a way that terminates
00:28:11 <bd_> bogner: rather than thinking of the constituent pair, think of the sums themselves
00:28:22 <bd_> also, are we talking about whole numbers, or integers, or numbers?
00:28:31 <bogner> integers
00:28:40 <bd_> okay, then you can't do it
00:28:46 <bd_> or well, not in haskell
00:28:53 <bogner> can't?
00:28:55 <bogner> oh
00:29:02 <bd_> bogner: well, there's no well-defined 'first'
00:29:18 <bd_> since you can just take one less than your first element plus zero :)
00:29:37 <bogner> oh, I mean from a seed list
00:29:44 <bd_> so you'll need to go non-negative integers at least
00:29:45 <bd_> seed list?
00:29:56 <bogner> and they're actually positive, I guess
00:30:38 <bogner> I mean, I have a list of numbers, they're all positive numbers and greater than zero
00:30:55 <bogner> so... not integers d:
00:31:17 <bogner> but rather, natural numbers
00:31:35 <bd_> okay... and you want to find only pairs of numbers from this finite list?
00:31:41 <bogner> yes
00:31:51 <bd_> ... so your output list isn't infinite?
00:32:21 <bogner> the simplest thing to do is to map each element of the list onto the list, but that obviously only works for finite lists
00:32:40 <bogner> oh, sorry, myy input list isn't finite
00:33:02 <bd_> bogner: what do you know about your input list?
00:33:51 <solrize_> "This article was nominated for deletion on 14 December 2008 (UTC). The result of the discussion was Complete trainwreck."
00:34:17 <bogner> bd_: it's the result of `filter someFunction [1..]`
00:34:42 <bd_> hmm, so you know the input list is ordered at least
00:35:36 <bd_> so you're basically, conceptually looking for sort [ x + y | x <- l, y <- l]
00:35:38 <bd_> okay
00:35:42 <bd_> well consider this
00:35:59 <bd_> imagine a grid, where rows and columns represent non-negative integers
00:36:16 <bogner> okay
00:36:17 <bd_> now draw diagonal lines down it - one line with (0,0), one with [(1,0),(0,1)], etc
00:36:43 <bd_> you'll note, each pair in a line has the same sum
00:36:54 <bd_> your filter function is removing rows and columns from this grid
00:36:58 <bd_> but the diagonal property remains
00:37:04 <bd_> now you just have to exploit it
00:37:15 <bd_> which I shall leave as an exercise to the motivated reader ;)
00:37:30 <bogner> thank you, I think I can work with that
00:46:49 <bogner> bd_: got it now. thanks again
01:14:56 <peregrine81> so I'm reading real world haskell, and im here, what else do you suggest I do to improve my functional understanding?
01:15:12 <ivanm> peregrine81: write some code?
01:17:56 <peregrine81> @ivanm where can I find example problems
01:17:57 <lambdabot> Unknown command, try @list
01:24:06 <mdiin> The exercises in Real World Haskell are good
01:24:31 <mdiin> But that's ot ehat you're looking for?
01:24:55 <mdiin> s/ot ehat/not what
01:26:35 <PaulAJ> haskell.org seems down
01:27:25 <pumpkin> mdiin: he's gone :P
01:27:33 <pumpkin> PaulAJ: same for me
01:27:59 <PaulAJ> Anyone know who looks after it?
01:28:27 <mdiin> pumpkin: Ah, okay. I suppress joins and parts, so I hadn't noticed :)
01:28:33 <pumpkin> :)
01:28:34 <b_jonas> oh no!
01:29:25 <PaulAJ> Oops, gotta go.  Breakfast to cook.
01:29:27 <PaulAJ> Bye
01:29:28 <tehgeekmeister> http://hpaste.org/13229 <== any ideas why this grows in memory slowly?
01:47:04 <b_jonas> well, it seems I could load the haskell.org main page at least
01:58:01 <mbz_> it works
01:59:01 <tehgeekmeister> is there a read that uses maybe instead of raising an exception when there's no parse?
02:01:29 <mbz_> @hoogle String -> Maybe a
02:01:30 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
02:01:30 <lambdabot> Prelude fail :: Monad m => String -> m a
02:01:30 <lambdabot> Control.Monad fail :: Monad m => String -> m a
02:06:33 <tehgeekmeister> gracias
02:12:01 <mbz_> @djinn a -> Maybe b
02:12:01 <lambdabot> f _ = Nothing
02:12:11 <mbz_> very usefull
02:12:20 <mbz_> @djinn String -> Maybe a
02:12:21 <lambdabot> Error: Undefined type String
02:12:27 <mbz_> @djinn [Char] -> Maybe a
02:12:28 <lambdabot> Error: Undefined type []
02:13:25 <b_jonas> tehgeekmeister: doesn't reads give an array of possible reads?
02:13:29 <b_jonas> let me look up
02:13:31 <b_jonas> @type reads
02:13:33 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:13:39 <PeakerWork> @djinn Maybe a -> a
02:13:39 <lambdabot> -- f cannot be realized.
02:13:43 <b_jonas> yeah, array of reads and rest of strings
02:13:47 <Dynetrekk> hi folks. is it possible to get a lambdabot to play with in your own terminal?
02:13:58 <Dynetrekk> It'd be great for learning haskell
02:14:01 <b_jonas> Dynetrekk: possible but really hard
02:14:12 <Dynetrekk> b_jonas: is that a challenge? :P
02:14:12 <b_jonas> Dynetrekk: you can get a ghci, or you can talk to lambdabot (or one of its clones) in private message
02:14:16 <PeakerWork> Dynetrekk: its not easy to compile lambdabot, but ghci is close.. also /query lambdabot works
02:14:22 <Dynetrekk> okay
02:14:28 <Dynetrekk> private message?
02:14:29 <tehgeekmeister> b_jonas: read just returns an int for me
02:14:31 <tehgeekmeister> well
02:14:32 <tehgeekmeister> in this case
02:14:36 <tehgeekmeister> > read "1" + 2
02:14:38 <lambdabot>   3
02:15:12 <Dynetrekk> PeakerWork: all right, I'll try that
02:16:21 <b_jonas> Dynetrekk: irc private message to lambdabot
02:16:34 <b_jonas> Dynetrekk: you can send commands to lambdabot that way too isntead of on a channel (like #haskell)
02:16:39 <b_jonas> Dynetrekk: and it will answer
02:16:52 <Dynetrekk> b_jonas: hm, using /msg ?
02:17:00 <tehgeekmeister> b_jonas: oh, i get it, you were saying i could just handle the empty list from reads the same as a maybe.  okay.  that might work for my purposes.  i'll look at it tomorrow, tho, i think it's bed time for me.
02:17:06 <Dynetrekk> b_jonas: I never used IRC before I tried learning haskell :P
02:17:32 <mbz_> > reads "1" :: [(Float, String)]
02:17:33 <lambdabot>   [(1.0,"")]
02:18:04 <Dynetrekk> b_jonas: ah, I got it to work now. thanks!
02:18:55 <b_jonas> > reads "12 " :: [(Int, String)]
02:18:57 <lambdabot>   [(12," ")]
02:24:34 <PeakerWork> > reads "Just 15 Just 13" :: [(Maybe Float, String)]
02:24:35 <lambdabot>   [(Just 15.0," Just 13")]
02:25:54 <PeakerWork> @type reads
02:25:55 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:26:18 <PeakerWork> > iterate (reads . snd . head) (Nothing, "Just 15 Just 13") :: [[(Maybe Float, String)]]
02:26:20 <lambdabot>   Couldn't match expected type `[(Maybe Float, String)]'
02:26:50 <PeakerWork> @type reads . snd . head
02:26:51 <lambdabot> forall a a1. (Read a) => [(a1, String)] -> [(a, String)]
02:27:07 <PeakerWork> @type iterate (reads . snd . head)
02:27:08 <lambdabot> forall a. (Read a) => [(a, String)] -> [[(a, String)]]
02:28:01 <PeakerWork> > iterate (reads . snd . head) [(Nothing, "Just 15 Just 13 Just 11")] :: [[(Maybe Float, String)]]
02:28:03 <lambdabot>   [[(Nothing,"Just 15 Just 13 Just 11")],[(Just 15.0," Just 13 Just 11")],[(J...
02:28:14 <PeakerWork> > tail $ iterate (reads . snd . head) [(Nothing, "Just 15 Just 13 Just 11")] :: [[(Maybe Float, String)]]
02:28:15 <lambdabot>   [[(Just 15.0," Just 13 Just 11")],[(Just 13.0," Just 11")],[(Just 11.0,"")]...
02:28:45 <PeakerWork> > map fst $ iterate (head . reads . snd) (Nothing, "Just 15 Just 13 Just 11") :: [[(Maybe Float, String)]]
02:28:47 <lambdabot>   Couldn't match expected type `[(Maybe Float, String)]'
02:28:52 <b_jonas> in lambdabot, which is the type that shows as any string?
02:28:53 <PeakerWork> > map fst $ iterate (head . reads . snd) (Nothing, "Just 15 Just 13 Just 11") :: [(Maybe Float, String)]
02:28:54 <lambdabot>   Couldn't match expected type `(Maybe Float, String)'
02:28:59 <PeakerWork> > iterate (head . reads . snd) (Nothing, "Just 15 Just 13 Just 11") :: [(Maybe Float, String)]
02:29:01 <lambdabot>   [(Nothing,"Just 15 Just 13 Just 11"),(Just 15.0," Just 13 Just 11"),(Just 1...
02:29:07 <PeakerWork> > map fst $ iterate (head . reads . snd) (Nothing, "Just 15 Just 13 Just 11") :: [Maybe Float]
02:29:08 <lambdabot>   [Nothing,Just 15.0,Just 13.0,Just 11.0,* Exception: Prelude.head: empty list
02:33:04 <mbz_> @index loeb
02:33:05 <lambdabot> bzzt
02:37:40 <cjs_> I've got a little accept loop that just forks off threads which then write to the clients that have connected to my server socket. But when I kill a client, the server mysteriously and quietly dies, despite that I'm using Control.Concurrent.catch to catch and print exceptions at the top levels of of threads. Any idea why this might be happening? (GHC 6.8.3 on NetBSD 1.4_STABLE.)
02:38:34 <cjs_> Oh, not fricking catching SIGPIPE!
02:38:36 <mbz_> try to catch sigpipe
02:38:38 <cjs_> I always forget that one....
02:39:00 * cjs_ slinks back into his hole.
02:40:19 <Deewiant> in 6.10 SIGPIPE is a catchable exception, I think
02:42:32 <b_jonas> Deewiant: iirc in 6.10 the runtime ignores sigpipe by default so you would catch the io expression for EPIPE
02:42:44 <b_jonas> (I don't like this change btw)
02:43:59 <Armored_Azrael> Hey, I'm trying to make a toy operation restricted application execution environment. Does the idea of having a set of queues, one for each type of operation the program is allowed to execute, passed into a function at the beginning of execution make sense?
02:44:32 <PeakerWork> Armored_Azrael: Not to me -- but I'm a capabilities' person :)
02:44:53 <PeakerWork> Armored_Azrael: If you're into software security, I recommend looking at object capabilities
02:45:09 <b_jonas> found it, SimpleReflect.var
02:46:28 <Armored_Azrael> PeakerWork: Wasn't really going for an OO thing. Specifically, the plan was to have an application be a haskell function that I could typecheck was only going to do the things I wanted it to.
02:47:45 <Armored_Azrael> Though, the capabilities thing is similar to what I was suggesting, namely that the central portion which is in the IO monad would perform actions in the queues, and the restricted apps would simply send requests to the queues, only knowing about the queues which they are supposed to know about
02:49:57 <PeakerWork> Armored_Azrael: I don't think object capabilities is necessarily an OO thing
02:50:21 <PeakerWork> Armored_Azrael: the question is what granularity of "things" you want to have - and I think the one found in obj-caps is a good one
02:51:12 <cjs_> Actually, I prefer the change; it's a quite reasonable (and not uncommon) argument that the default SIGPIPE action in POSIX is wrong, and should be IGNORE.
02:51:15 <Armored_Azrael> OK--just to make sure I'm getting this right, an example of obj-caps in this case would be to compile it without prelude or anything like that, but pass in manually those functions it is allowed to use?
02:52:33 <PeakerWork> Armored_Azrael: Its fine to have a global namespace of immutable authority-free things (like ordinary functions/etc).  Functions that convey authority (such as openFile and others) are the problem and should not be importable, but passed as argument
02:57:42 <Armored_Azrael> Yeah, this is more or less what I was noting, so you'd basically want to restrict IO.
02:57:53 <Armored_Azrael> (as all regular functions should be fine)
03:00:01 <PeakerWork> Armored_Azrael: unsafe functions might also be bad
03:00:16 <PeakerWork> Armored_Azrael: anything that can core dump can probably jail break too
03:00:36 <Armored_Azrael> PeakerWork: Yeah.
03:00:57 <PeakerWork> Armored_Azrael: some IO functions are fine, as long as they don't carry more authority than given to them in their arguments
03:01:12 <PeakerWork> Armored_Azrael: for example, readFile is fine, because a file Handle conveys the authority to read it
03:01:35 <Armored_Azrael> True.
03:02:01 <PeakerWork> Armored_Azrael: Something like DirectoryHandle -> String -> Handle   would also be fine, though (String -> Handle) is not (because it carries the authority to the _whole_ filesystem in it, which is crazily too much authority)
03:03:20 <PeakerWork> That's DirectoryHandle -> String -> IO Handle, of course, and String -> IO Handle
03:19:39 <Armored_Azrael> Random question, have nhc or yhc gotten read/show to work on functions yet? (given that they use bytecode)
03:20:45 <b_jonas> @@ @run SimpleReflect.var(let{p="@@ @@ @run SimpleReflect.var(let{p=";s="}in p++show p++\";s=\"++show s++s)"}in p++show p++";s="++show s++s)
03:20:47 <lambdabot>   @@ @@ @run SimpleReflect.var(let{p="@@ @@ @run SimpleReflect.var(let{p=";s=...
03:20:49 <b_jonas> @@ @@ @run SimpleReflect.var(let{p="@@ @@ @run SimpleReflect.var(let{p=";s="}in p++show p++\";s=\"++show s++s)"}in p++show p++";s="++show s++s)
03:20:52 <lambdabot>     <no location info>: parse error on input `;'
03:21:23 <b_jonas> it truncates something to very short, hmm
03:22:12 <xenoblitz> hi guys, has anyone of you tried to install gtk2hs 0.9.13 with ghc-6.10.1 on a windows machine?... Is it hard to fix the "You will have to fix the DLL search path problem yourself later"? and is there link where I can get help with this cause I have no clue what that means.
03:23:25 <dcoutts> xenoblitz: did it list any clashing files?
03:23:38 <dcoutts> in an earlier message box in the installer
03:24:10 <dcoutts> you might want to run the installer again to see the message again
03:24:21 <xenoblitz> dcoutts: well no cause i ran the installer and clicked next > ... then I got presented with that message and was not sure on whether to proceed or not
03:24:41 <dcoutts> ok, run it again and look at the message
03:24:45 <xenoblitz> It just says that it requires ghc 6.8.3
03:24:54 <dcoutts> oh, well that's true
03:25:02 <xenoblitz> i know about this but it might be problematic to install 2 versions of ghc on one machine
03:25:15 <dcoutts> I've got 4 versions installed :-)
03:25:18 <dcoutts> it's not a problem
03:25:23 <xenoblitz> on windows?
03:25:34 <dcoutts> on windows I've only got 3 versions installed :-)
03:25:37 <xenoblitz> how do you pick which you are using when you compile?
03:25:48 <dcoutts> I do it by changing the %PATH%
03:25:55 <xenoblitz> i c
03:25:58 <dcoutts> so I have a default one
03:26:11 <dcoutts> and to use the others I have to run a script to change the %PATH%
03:26:41 <xenoblitz> i guess than it means I have to install both ghces and use the same method
03:27:25 <xenoblitz> dcoutts: thanks for your help
03:27:53 <dcoutts> xenoblitz: np. There will eventually be a release with an installer built for 6.10.x
03:28:44 <xenoblitz> dcoutts: yes i can imagine so :)
03:30:11 <xenoblitz> dcoutts: also in case you know... is it possible to make ghc compile the required files inside your exe... cause if i take my exe to another machine and it does not have gtk2hs installed i have to install it... i was wondering if there is a way to make compiling the exe stand alone feasible
03:31:37 <dcoutts> xenoblitz: yes, the .exe itself is standalone, it does not need ghc installed, however when you use gtk2hs then your .exe needs all the gtk+ dlls.
03:31:56 <dcoutts> xenoblitz: but it's quite possible to make an installer that installs your .exe and all the gtk+ dlls
03:32:26 <dcoutts> xenoblitz: for example: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
03:32:28 <xenoblitz> dcoutts: yes that's what i do in the end... it just would be nice to take your application as one file sometimes... :)
03:32:45 <dcoutts> xenoblitz: that's not possible in general for windows programs that need external .dll files.
03:33:07 <xenoblitz> dcoutts: yes i guess the problem is WINDOWS :P
03:33:08 <xenoblitz> lol
03:33:18 <dcoutts> xenoblitz: ordinary simple Haskell programs need no .dll files but using big libs like Gtk+ need many dlls
03:34:02 <dcoutts> though in theory it should be possible to link .dll files directly into an .exe
03:34:13 <dcoutts> but I don't know if that's possible in practise
03:34:53 <xenoblitz> dcoutts: yes... i was using another library before gtk ... soe... it required no dlls but it gave me problems with threads so i had to use gtk
03:35:08 <xenoblitz> soe needed no external dlls
03:35:16 <xenoblitz> that's why i was wondering about it
03:35:27 <dcoutts> right, it calls the win32 GDI functions directly
03:35:35 <dcoutts> so only needs .dll files that come with windows
03:36:02 <dcoutts> xenoblitz: you know there is an implementation of soe that uses gtk, if you want to use that simple api
03:36:42 <xenoblitz> dcoutts: what is it called? and does it have the same refreshing problems soe has? :P
03:36:43 <xenoblitz> lol
03:37:06 <dcoutts> I hope not, it's called gtksoe, I think it's bundled with the gtk2hs installer
03:37:15 <dcoutts> or perhaps soegtk, I forget
03:37:42 <xenoblitz> dcoutts: my problem was strange... when i created a window in soe... it froze and updated sporadically... or when i forced refreshed it by moving my mouse over the window
03:37:55 <xenoblitz> and its inherent with soe so i think i'd best stick to gtk
03:37:56 <dcoutts> xenoblitz: it is well known to be broken
03:38:06 <dcoutts> that's one reason I wrote gtksoe
03:38:31 <xenoblitz> dcoutts: I will definitely try it then :)
03:38:56 <xenoblitz> dcoutts: thanks once moe hehe :)
03:39:32 <xenoblitz> *more... and moe/soe ... Freudian slip?
03:57:05 <jsn> the ability to use guards in a case statement is such a blessing
04:03:58 <cnwdup> http://hpaste.org/13231 Is this not working because records are built in special types? Shouldn't record support go that far? Or dies my problem lie elsewhere?
04:06:30 <Deewiant> Records are essentially just data types where the getters are written for you: data Color = Color { red :: Int } instead of data Color = Color Int; red (Color r) = r
04:07:00 <Deewiant> I think doing what you want requires template haskell or something more complicated than a plain data type
04:07:46 <cnwdup> But I have special syntax for updating records using the getter as function to assign values. But apparently I can't use them as plain functions.
04:09:40 <Deewiant> changeRed c = c { red = 1 } is equivalent to changeRed (Color _ blue green) = Color 1 blue green; it's just shorthand for preserving the old field values and/or pattern matching on just one (as in Color {red=1} instead of Color 1 _ _)
04:09:40 <cnwdup> Is there a reason this isn't working which I am not seeing?
04:09:49 <Deewiant> How would you do that without records
04:10:18 <Deewiant> Remember, records are essentially just some syntactic conveniences to make your code shorter and clearer
04:10:23 <Deewiant> Or that's how I see it, anyway
04:10:50 <cnwdup> Yep. But I'd find it convenient if my example code was working and I don't see a reason why it shoudn't be. (Albeit that it isn't.)
04:11:39 <cnwdup> Oh wait... actually I'm getting why it cannot work.
04:11:41 <Deewiant> Like said, can you write it out without the record syntax
04:11:54 <Deewiant> It'd be essentially doing a case-match on the function you give in
04:12:03 <Deewiant> To find out which field it is
04:12:13 <cnwdup> Yeah, using arbitrary functions of the right type, ghc is still not able to infer on which data field to apply the function.
04:12:19 <cnwdup> Right. Thank you.
04:12:45 <Deewiant> Yep, because you could even give in a function which is not one of the fields
04:29:42 <dmhouse> Hi all. I recently upgraded to GHC 6.10 and now it seems I can't compile anything. I'm getting the error "cannot find -lgmp" from ld.
04:29:49 <dmhouse> Here's a full transcript: http://hpaste.org/13232
04:30:29 <dcoutts> dmhouse: I think there's a way to tell ghc where to find gmp when you configure it
04:30:56 <dcoutts> dmhouse: but given that you've already built it, the quickest thing to do is to modify the package config for the rts or base package.
04:31:04 <dcoutts> probably rts
04:31:28 <dmhouse> How do I do that?
04:31:39 <dcoutts> dmhouse: ghc-pkg describe rts > rts.pkg; vi rts.pkg; sudo ghc-pkg update rts.pkg
04:32:06 <dcoutts> add the dir containing gmp to the library-dirs field
04:32:55 <dmhouse> Oh, hang on, I just installed a couple of packaged with "gmp" and "dev" in the name, that seems to have fixed things.
04:33:05 <dmhouse> I wonder why the configure script didn't pick up on the missing header files...
04:34:27 <dmhouse> The exact package name was "libgmp3-dev" which had a dependency on "libgmpxx4ldbl"
04:34:33 <dcoutts> dmhouse: oh, you installed a ghc binary
04:34:39 <dmhouse> (Running Ubuntun 8.04.)
04:35:13 <dmhouse> dcoutts: oh, good point. Heh.
04:41:00 <Raevel> get equipped with: rwh
04:41:08 <Raevel> it finally arrived!
04:44:10 <b_jonas> is that the same as RWS?
04:44:51 <hugo___> hi
04:45:52 <Raevel> b_jonas: rwh is real world haskell
05:12:06 <robreim> How can I compile a bare minimum executable in haskell (probably ghc but potentially not). Say for example I want to compile an executable intended to run as a kernel on bare metal and want to link my main module compiled to a .o and some assembly together and very little else.
05:19:41 <cnwdup> > pl \x -> (fst $ snd x, fst x)
05:19:42 <lambdabot>   <no location info>: parse error on input `\'
05:19:51 <cnwdup> > pl (\x -> (fst $ snd x, fst x))
05:19:52 <lambdabot>   Not in scope: `pl'
05:20:48 <ziman> :t liftM2 (,) (fst . snd) fst
05:20:49 <lambdabot> forall a b a1. (a1, (a, b)) -> (a, a1)
05:21:27 <ziman> ah, it's @pl, not > pl
05:21:28 <Tobsan> cnwdup: @pl
05:21:29 <sbahra> @pl (\x -> (fst $ snd x, fst x))
05:21:30 <lambdabot> ap ((,) . fst . snd) fst
05:21:43 <cnwdup> thanks
05:22:04 <cnwdup> I am not quite sure if I find ap ((,) . fst . snd) fst more readable. Or is it just that I am not used to it?
05:22:43 <robreim> cnwdup, it's not. Point-free programming tends to be obfuscated. Only use it when it does make something more readable.
05:23:06 <cnwdup> ok
05:25:11 <Axman6> :t ((,) . fst . snd)
05:25:13 <lambdabot> forall b a b1 a1. (a1, (a, b1)) -> b -> (a, b)
05:25:41 <baaba> @src ap
05:25:41 <lambdabot> ap = liftM2 id
05:26:02 <baaba> :t ap
05:26:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:26:14 <ziman> ap = liftM2 ($) -- might be more suggestive
05:29:32 <Axman6> how would i go about making an FFI interface to s library that's installed with the system? (OS X's vecLib in this case)
05:31:15 <sbahra> @seen JaffaCake
05:31:15 <lambdabot> JaffaCake is in #haskell and #ghc. I don't know when JaffaCake last spoke.
05:32:58 <Axman6> there aren't any rules about expanding something like cos(const*x) are there?
05:33:28 <b_jonas> Axman6: there are
05:34:10 <Axman6> b_jonas: what is it?
05:34:34 <cnwdup> @pl (\m -> fromJust $ Map.lookup mod ~modifiers)
05:34:34 <lambdabot> (line 1, column 34):
05:34:34 <lambdabot> unexpected "~"
05:34:34 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
05:34:49 <b_jonas> Axman6: cos(2*x) = cos(x)**2-sin(x)**2 = 1 - 2*sin(x)**2 = -1 + 2*cos(x)**2
05:34:52 <Axman6> my calculus is failing me -_-
05:34:55 <cnwdup> @pl (\m -> fromJust $ Map.lookup mod Map.empty)
05:34:55 <lambdabot> const (fromJust (Map.lookup mod Map.empty))
05:34:56 <b_jonas> Axman6: there's a general one too, a moment
05:35:04 <cnwdup> @pl (\m -> fromJust $ Map.lookup m Map.empty)
05:35:05 <lambdabot> fromJust . flip Map.lookup Map.empty
05:35:46 <Axman6> b_jonas: basically i was hoping i could take out the cos(const) out somehow, so it's only computer once in what i'm doing
05:35:56 <b_jonas> Axman6: cos(n*x) = binom(n,0)*cos(x)**n - binom(n,2)*cos(x)**(n-2)*sin(x)**2 + binom(n,4)*cos(x)**(n-4)*sin(x)**4 - ...
05:36:05 <Deewiant> :t ap ((,) . fst . snd)
05:36:07 <lambdabot> forall b a b1 a1. ((a1, (a, b1)) -> b) -> (a1, (a, b1)) -> (a, b)
05:36:14 <Deewiant> :t fst . snd &&& fst
05:36:16 <lambdabot> forall a b a1. (a1, (a, b)) -> (a, a1)
05:36:24 <b_jonas> Axman6: you get them by induction from cos(x+y) = cos(x)cos(y) - sin(x)sin(y) and similar rules
05:36:26 <Deewiant> :t ap ((,) . fst . snd) fst
05:36:27 <lambdabot> forall a b a1. (a1, (a, b)) -> (a, a1)
05:36:29 <Axman6> b_jonas: heh, yeah, not savng any computation there :P
05:36:34 <b_jonas> Axman6: I'm reading from a paper by the way
05:36:57 <Deewiant> cnwdup: I'd use (fst . snd &&& fst)
05:36:58 <Axman6> i should check my calculus book
05:37:18 <b_jonas> Axman6: if you just want the formulas, I think that reference book has it
05:37:22 <b_jonas> Axman6: what's its name
05:37:55 <cnwdup> @pl (\x -> (snd x, fst x))
05:37:55 <lambdabot> liftM2 (,) snd fst
05:38:07 <Deewiant> :t snd &&& fst
05:38:09 <lambdabot> forall a b. (a, b) -> (b, a)
05:38:13 <Axman6> Calculus: a complete course, Adams
05:38:19 <cnwdup> deewiant: thank you
05:38:33 <Axman6> it's rather large
05:38:37 <Deewiant> I tend to use &&& and *** quite heavily when working with tuples
05:38:45 <b_jonas> Axman6: Abramowitz and Stegun
05:38:52 <b_jonas> Axman6: the scans are online, it's in public domain
05:39:26 <PeakerWork> I like      onBoth = join (***)
05:39:28 <sbahra> :t (&&&)
05:39:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:39:39 <sbahra> wat
05:39:48 <Deewiant> PeakerWork: I just write join (***) :-P
05:39:54 <PeakerWork> :t join (***)
05:39:55 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
05:40:00 <b_jonas> Axman6: http://www.convertit.com/Go/ConvertIt/Reference/AMS55.ASP?Res=150&Page=72
05:40:04 <Deewiant> annoying that I need both Control.Monad and Control.Arrow for such a simple function
05:40:12 <Axman6> thanks :)
05:42:10 <Axman6> b_jonas: yeah, those expansions aren't quite what i want, but i think what i'm after may not exist
05:45:26 <[dezzy]> hello
05:46:28 <PeakerWork> Anyone remembers how to use Text.Regex.DFA?
05:46:44 <PeakerWork> "blah" ~= "blah"   does not seem to work, neither does:  makeRegex "blah" ~= "blah"
05:46:47 <Deewiant> same way as any other Text.Regex?
05:46:53 <Deewiant> I never used the ~= operators
05:46:53 <cnwdup> @pl (\t -> (t -> t1) -> t1)
05:46:54 <lambdabot> (line 1, column 11):
05:46:54 <lambdabot> unexpected ">"
05:46:54 <lambdabot> expecting variable, "(", operator or ")"
05:47:06 <Deewiant> ?hackage regex-dfa
05:47:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-dfa
05:47:08 <cnwdup> :t flip ($)
05:47:09 <lambdabot> forall a b. a -> (a -> b) -> b
05:48:40 <PeakerWork> Deewiant: I keep having to spend 10 minutes to re-remember how to work with that, whereas regexps everywhere else "just work" :(  Maybe it has to do with docs having no examples.. Frustrating
05:49:13 <Deewiant> I never remember how any regexp work in haskell
05:49:53 <Saizan> they all work via the same class, no?
05:50:17 <mbz_> yep and this class's name is perl.
05:50:29 <PeakerWork> matchAll (makeRegex "hello" :: Regex) "hello goodbye" works, but matchAll (makeRegex "hello") "hello goodbye"       lacks instance declarations??
05:50:50 <PeakerWork> I'd expect an ambiguous type maybe, how can it lack instances?
05:50:57 <PeakerWork> oh, defaulting
05:51:54 <Saizan> do you have extended defaulting on?
05:53:06 <PeakerWork> How do I test?
05:55:43 <Deewiant> PeakerWork: being in GHCi means you do, otherwise it's a -X flag
06:06:09 <vixey> hi
06:06:19 <vixey> did anyone before write a ReadP parser for infix expressions?
06:06:29 <vixey> I'm just not wanting to duplicate this if it already existed..
06:07:25 <cnwdup> @pl flip ($)
06:07:26 <lambdabot> flip id
06:08:28 <Saizan> do we have a javascript parser+prettyprinter?
06:08:53 <[dezzy]> does somebody use ghc on freebsd 6.x?
06:09:03 <vixey> @go javascript quasiquoter
06:09:06 <lambdabot> http://use.perl.org/~agent/journal/37097
06:09:06 <lambdabot> Title: Journal of agent (5836)
06:10:42 <vixey> I thought there was but  I can't find it
06:12:10 <PeakerWork> how do I "lines" a ByteString easily?
06:12:38 <PeakerWork> BS.split (fromIntegral . ord $ '\n')  is not very nice?
06:12:51 <Deewiant> pack . lines . unpack
06:12:56 <Deewiant> er, map pack
06:13:18 <Deewiant> modulo some c2w/w2c if you're doing it right and not using Char8
06:13:27 <maltem> Deewiant: that defeats the point of having a ByteString?
06:13:32 <PeakerWork> @type c2w
06:13:34 <lambdabot> Not in scope: `c2w'
06:13:48 <Deewiant> PeakerWork: Char -> Word8, Word8 -> Char
06:13:54 <Deewiant> maltem: yes, somewhat
06:14:10 <PeakerWork> Deewiant: where's that?
06:14:14 <msch> hi, are ghc 6.10 .debs available for Ubuntu?
06:14:18 <Deewiant> PeakerWork: Data.ByteString.Internals... for some reason
06:14:20 <b_jonas> so what's the other good xml library apart from haxml?
06:14:26 <maltem> PeakerWork: I think how you do it it as nice as it gets
06:14:37 <b_jonas> I'm not sure I like haxml and I don't want to be stuck with it if the other one is better
06:14:39 <PeakerWork> Deewiant: I think I'll just use the "ugly" one and hide the ugliness behind "bsLines"
06:14:39 <maltem> *is as nice as it gets
06:14:42 <Deewiant> does BS.split have the same behaviour, though?
06:15:02 <PeakerWork> I think so, what could it possibly mean?
06:15:17 <PeakerWork> @type Data.ByteString.split (fromIntegral . ord $ '\n')
06:15:18 <lambdabot> BSC.ByteString -> [BSC.ByteString]
06:15:37 <Deewiant> PeakerWork: well, remember the current Data.List.Split - there are a lot of ways of splitting :-)
06:16:04 <PeakerWork> Deewiant: the different ways have different types, I think :)
06:16:05 <Deewiant> > lines "foo\nbar\n" -- BS.split might give [foo,bar,""]
06:16:06 <lambdabot>   ["foo","bar"]
06:16:09 <Deewiant> PeakerWork: no, they don't
06:16:33 <Deewiant> and that's exactly the problem :-P
06:16:39 <maltem> PeakerWork: you can get rid of the (fromIntegral . ord) by using the .Char8 variant of ByteString
06:16:45 <Deewiant> Char8 is evil
06:16:54 <maltem> oh is it?
06:17:25 <Deewiant> if you know for certain that you're working with ASCII only then I guess it's fine
06:17:50 <maltem> Deewiant: ok, well '\n' is an ASCII character to split on
06:17:51 <PeakerWork> Deewiant: well, I don't mind that difference in this case
06:18:00 <PeakerWork> @hoogle String -> ByteString
06:18:00 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
06:18:01 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
06:18:01 <lambdabot> Prelude read :: Read a => String -> a
06:18:09 <Deewiant> maltem: yeah, but in general
06:18:21 <maltem> Deewiant: ok
06:18:26 <b_jonas> Deewiant: it's ok as well if you're working with utf-8 or any sane byte encoding, but not if you're working iwth like utf-16, but in the latter case just splitting on the byte (fromIntegral . ord $ '\n') won't work either
06:18:34 <b_jonas> so imo it's not necessarily evil
06:19:02 <b_jonas> really, what's the other xml module?"
06:19:03 <Deewiant> in this case UTF-8 may be fine but be careful
06:19:28 <Deewiant> use utf8-bytestring if you're doing anything with text
06:19:47 <Deewiant> unless, again, you know fairly exactly what your input looks like
06:20:08 <b_jonas> is haxml the only one you recommend?
06:20:40 <Deewiant> But IMO Char8 is somewhat fighting the type system; it's analogous to having floats and ints convert to each other automatically, or something
06:21:20 <adekoba> anyone familiar with the binary package? I'm trying to catch the decode function, but it always seems to terminate my program.
06:21:53 <Saizan> adekoba: paste your code
06:22:35 <adekoba> Saizan: http://hpaste.org/13220
06:23:02 <Saizan> adekoba: how is ID3v defined?
06:23:25 <adekoba> holds lazy bytestrings, h/o
06:23:59 <Saizan> h/o?
06:24:18 <adekoba> Saizan: http://hpaste.org/13220#a1
06:25:51 <Saizan> adekoba: ok, then $! is not enough, it will only force the ID3v1 constructor, but not the fields
06:26:15 <adekoba> so strict bytestrings, you think?
06:26:21 <Saizan> no
06:27:27 <Saizan> you need something like force v@(ID3v1 !a !b !c !d !e mi !w) = case mi of Just _ -> v; Nothing -> v
06:28:00 <Saizan> or you can import Control.Parallel.Strategies, and make ID3v an instance of NFData
06:28:37 <Saizan> you might also need to force the bytestrings, but it depends on how you're doing the parsing
06:28:48 <adekoba> wow, really? Seems a bit complex.
06:29:18 <Saizan> yeah, the Get monad doesn't handle errors very well..
06:29:44 <adekoba> Saizan: this works http://hpaste.org/13220#a2
06:29:51 <PeakerWork> hmm.. why aren't regexps a combinator DSL instead of an ugly String DSL?
06:30:02 <PeakerWork> I am getting runtime errors about missing ')', that sucks :(
06:30:04 <adekoba> Saizan: I wast just tring to use decode instead of all of that runGet stuff
06:31:31 <vixey> @hoogle  >>= return .
06:31:31 <lambdabot> Parse error:
06:31:31 <lambdabot>   --count=20 ">>= return ."
06:31:31 <lambdabot>              ^
06:31:41 <vixey> @hoogle  (>>= (return . ?f))
06:31:42 <lambdabot> Parse error:
06:31:42 <lambdabot>   --count=20 "(>>= (return . ?f))"
06:31:42 <lambdabot>                   ^
06:32:20 <Axman6> :t (>>= (return . ?f))
06:32:21 <lambdabot> forall a b (m :: * -> *). (?f::a -> b, Monad m) => m a -> m b
06:32:25 <Saizan> adekoba: ah, you should have said so, i was tackling a completely different problem :)
06:32:51 <adekoba> Saizan: sorry for the misunderstanding
06:34:51 <Saizan> well, not that different, by checking if the stream is empty you force some of the parsing to occur
06:34:58 <Saizan> and i guess that's enough for you
06:35:12 <Saizan> i was trying to make that happen by forcing the result
06:37:08 <adekoba> evaluate doesn't do that?
06:37:30 <adekoba> or seq, or something. There must be a function for that.
06:37:33 <Saizan> evaluate only forces it to weak head normal form, i.e. the outermost constructor
06:38:06 <Saizan> there isn't a primitive for deep forcing
06:38:25 <Saizan> ?type rnf
06:38:26 <lambdabot> forall a. (NFData a) => a -> Done
06:38:31 <Saizan> only that ^^^^
06:38:40 <Saizan> but you've to write an NFData instance
06:38:46 <adekoba> i'll look into that
06:38:55 <SamB_XP> there is no such primitive because it would violate abstractions
06:38:55 <lambdabot> SamB_XP: You have 1 new message. '/msg lambdabot @messages' to read it.
06:39:01 <Saizan> > Just undefined `seq` ()
06:39:01 <SamB_XP> @messages
06:39:01 <lambdabot> gwern said 23h 16m 8s ago: Those are the show instances for IO. they return a string and error too for good measure
06:39:02 <lambdabot>   ()
06:39:23 <Saizan> fsvo of "good"
06:39:34 <SamB_XP> agreed
06:39:36 <Saizan> which implies giving a really weird result
06:40:35 <b_jonas> (as if seq didn't violate abstractions)
06:41:06 <SamB_XP> b_jonas: point
06:41:29 <SamB_XP> but it doesn't violate them as badly as deepSeq would if it were primitive
06:42:46 <SamB_XP> it still bothers me that (const undefined >= undefined) in definedness
06:43:01 <SamB_XP> er.
06:43:07 <SamB_XP> rather, it still bothers me that (const undefined > undefined) in definedness
06:43:15 <PeakerWork> if seq was implemented via type-classes, it would resolve that, no?
06:44:37 <SamB_XP> (I suppose I can see how it makes it easier to implement, but it seems like a rather lame excuse ...)
06:45:43 <Axman6> hmm, HLint is rather nice. take (n - length str) (repeat c) -> replicate (n - length str) c
06:45:48 <Axman6> not my code btw
06:47:36 <PeakerWork> Axman6: yeah, and using partials more elegantly and stuff like tha
06:47:46 <Axman6> partials?
06:48:15 <PeakerWork> partial applications
06:49:46 <PeakerWork> f x y = blah y -- iirc, it said: "why not: f x = blah?"
06:49:50 <Axman6> rectangleWC sizeX sizeY = lineLoop $ recListC sizeX sizeY ---> rectangleWC sizeX = lineLoop . recListC sizeX -- that kind of thing?
06:50:10 <Axman6> yeah, i'm not fuch a fan of that, though if the type sig's there, it makes it clear
06:51:26 <Axman6> anyway, sleep time. night all
06:51:32 <vixey> > (x + y) + z
06:51:33 <lambdabot>   x + y + z
06:51:37 <vixey> > x + (y + z)
06:51:38 <lambdabot>   x + (y + z)
06:51:48 <PeakerWork> that can also become rectangleWX = result lineLoop . rectListC
06:52:04 <b_jonas> sure
06:52:13 <PeakerWork> actually, I think its rectangleWX = (result.result) lineLoop . rectListC
06:52:27 <PeakerWork> @type result
06:52:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:52:35 <b_jonas> PeakerWork: you just couldn't implement seq for functions in general
06:52:46 <b_jonas> if you call that resolve, well, then it would
06:53:39 <b_jonas> PeakerWork: also it's not just a little easier to implement, it's actually impossible to implement the other way:
06:53:50 <b_jonas> PeakerWork: how could seq know if a function always returns bottom?
06:54:01 <b_jonas> that's halting problem strong
06:54:56 <PeakerWork> b_jonas: I don't know, I was just re-iterating something I thought quicksilver had said :)
06:55:02 <PeakerWork> why does the regexp stuff return arrays of matches, and not lists?
06:55:47 <b_jonas> which regex stuff?
06:56:04 <PeakerWork> The matcher functions
06:56:29 <b_jonas> maybe this way it's clearer that it doesn't lazily match one by one?
06:56:32 <b_jonas> or something
06:56:37 <b_jonas> dunno
06:56:57 <PeakerWork> aha, it returns the match groups, I think, and they're typically indexed
06:57:04 <PeakerWork> (and not iterated)
06:57:15 <PeakerWork> there are usually just a couple, but there could be many
06:57:53 <b_jonas> > [4..10] >>= (\x -> when (odd x) (return x))
06:57:54 <lambdabot>       No instance for (Integral ())
06:57:54 <lambdabot>        arising from a use of `odd' at <in...
06:58:07 <vixey> does anyone know ReadP a bit?
06:58:10 <b_jonas> @type when
06:58:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:58:19 <luite> @seen dons
06:58:19 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 6h 40m 42s ago.
06:58:52 <vixey> http://hpaste.org/13238
06:58:54 <b_jonas> > [4..10] >>= (\x -> guard (odd x) >> return x)
06:58:56 <lambdabot>   [5,7,9]
06:59:06 <b_jonas> > [4..10] >>= (\x -> guard (odd x) >> return (x+1))
06:59:08 <lambdabot>   [6,8,10]
06:59:09 <vixey> Is this the best way to parse infix expressions?
06:59:48 <vixey> you just sort them by the precedence level, and then use chain[lr] with the lower precedence thing as the element
07:00:21 <vixey> I'm not sure it's good though because I had to do: exp = sum >>= eos
07:01:53 <vixey> no thoughts about it..?
07:05:18 <Saizan> @seen mmorrow
07:05:18 <lambdabot> I saw mmorrow leaving #ghc and #haskell 2h 8m 58s ago, and .
07:11:08 <EvilTerran> vixey, what parser library are you using?
07:11:15 <vixey> ReadP
07:11:44 <adrian> @pl f (a,b) (c,d) = (a+c,b+d)
07:11:45 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
07:11:58 <EvilTerran> have you seen ReadPrec? it seems to be intended for use with ReadP
07:12:29 <Deewiant> f (a,b) = (a+) *** (b+)
07:13:21 <EvilTerran> > uncurry ((***)`on`(+)) (a,b) (c,d)
07:13:23 <lambdabot>   (a + c,b + d)
07:13:26 <vixey> http://hackage.haskell.org/packages/archive/base/3.0.1.0/doc/html/src/Text-ParserCombinators-ReadPrec.html
07:13:30 <vixey> it doesn't do anything ??
07:13:35 <Deewiant> ew, on (***)
07:13:39 <Deewiant> ?ty on (***)
07:13:40 <lambdabot> forall (a :: * -> * -> *) b c a1. (Arrow a) => (a1 -> a b c) -> a1 -> a1 -> a (b, b) (c, c)
07:14:02 <Deewiant> (a -> b -> c) -> a -> a -> (b,b) -> (c,c)
07:14:16 <Deewiant> hmm
07:14:18 <adrian> I prefer lambdabots version :D
07:14:32 <EvilTerran> vixey, the key point being "prec n (P f) = P (\c -> if c <= n then f n else ReadP.pfail)
07:14:32 <EvilTerran> ", i think
07:15:19 <Deewiant> ?pl \a b (c,d) -> a b c d
07:15:20 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .)
07:15:24 <Deewiant> tch
07:17:44 <vixey> are there any ReadPrec examples around?
07:18:13 * gwern looks at haskell tetris: http://svn.coderepos.org/share/lang/haskell/tetris
07:18:41 <gwern> (what a pleasant surprise, it compiles)
07:18:50 <gwern> 'freeglut  ERROR:  Function <glutCreateWindow> called without first calling 'glutInit'.
07:18:54 <gwern> verdammt
07:19:07 <PeakerWork> I wish "do" caused haskell-mode to indent the next line 2 or 4 spaces, and not all the way over till after the "do"
07:19:16 <gwern> you know, the sucky thing is I could swear that last year, I ran into the same exact problem with agame from the same author
07:19:23 <smg> gwern: s/verdammt/damn/
07:20:09 <gwern> I says what I meants, and I meants what I says, 100 percent
07:20:16 <luite> PeakerWork: if you make a patch, please give me thode code ;)
07:20:50 <gwern> 'doc:
07:20:51 <gwern>         haddock -h -o man -l C:\\ghc\\haddock-2.0.0.0 -B c:\\ghc\\ghc-6.8.2 *.hs
07:20:54 <gwern> -_-
07:25:05 <gwern> well, at least it wrosk now
07:25:23 <gwern> now I just need to figure out how to use svn :)
07:25:47 <kpreid> gwern: hi! need help?!
07:26:14 <chrisdone> @hoogle either
07:26:14 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
07:26:15 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
07:26:15 <lambdabot> module Data.Either
07:26:18 <chrisdone> ‚ù§
07:26:45 <gwern> kpreid: I think so. as svn is centralized can I record patches locally?
07:26:55 <cnwdup> What's the meaning of this character? It looks like a deformed circle to me. ^^
07:27:13 <gwern> I mean, the only svn command I know is 'svn co'
07:27:19 <hugo___> :P
07:27:25 <kpreid> gwern: in full generality, that's a missing feature
07:27:38 <kpreid> gwern: for simple cases just send the output of svn diff (no args)
07:27:40 <cnwdup> Ah, nvm.
07:28:11 <kpreid> gwern: if you've added files consult 'svn status' and make sure you have 'svn add'ed any ? files (? corresponds to 'a' in darcs)
07:28:21 <gwern> kpreid: well, i plan extensive changes. first, I fixed tetris for linux, then I cabalize it, then I do -Wall and hlint cleanup
07:28:27 <gwern> this is all a bit much for a single diff
07:28:44 <kpreid> gwern: the Official Right Thing is you ask them for commit access (to a branch just for you)
07:28:59 <gwern> I'm unsure how much english the author understands
07:29:23 <ziman> compareTuple = mconcat [comparing fst, comparing snd] -- this is beautiful :)
07:29:29 <gwern> and I'd rather not wait a day or two for him to respond
07:29:47 <kpreid> (to move to a branch you svn copy <url...>/trunk  <url...>/branches/gwern and then svn switch to the latter)
07:30:03 <kpreid> gwern: I have no excellent answers for that case
07:30:17 <gwern> :( people use svn and love it?
07:31:30 <Saizan> is there something like "show" in javascript?
07:31:52 <Raevel> toString or toSource
07:31:59 <kpreid> Saizan: not builtin afaik
07:32:07 <gwern> hm, svn commit seems to want to modify the remote repo
07:32:09 <kpreid> there are libs which will add such
07:32:14 <gwern> I guess that's what centralized means
07:32:15 <kpreid> gwern: yes
07:32:25 <kpreid> gwern: that's why you have them make a branch for you
07:32:35 <kpreid> or get commit access and make it yourself
07:33:46 <gwern> (this has been a valuable lesson for me about svn, specifically why I never want to use it)
07:34:57 <Raevel> i use svn, but that's cause i haven't gotten around to using (or needing) anything distributed so far
07:37:46 <EvilTerran> ziman, so is "compareTuple = compare" :P
07:38:33 <ziman> EvilTerran, in this special case, yes. :)
07:38:56 <Saizan> Raevel: i'm trying to eval some code in e.g. rhino, and toString(1) gives me [object global], do you happen to know how to get a string out of that?
07:39:19 <Saizan> on the prompt i mean
07:39:25 <Raevel> Saizan: that's the default if you haven't overriden the default toString method
07:39:26 <kpreid> 1.toString()
07:40:05 <Raevel> but try toSource also
07:40:50 <Raevel> not sure how it behaves in general
07:43:07 <maltem> Is there a way to ask what RTS options got passed to a program?
07:44:14 <maltem> Something like getRTSArgs?
07:44:48 <gwern> hm, hlint can't handle n+k patterns
07:44:49 <iagoabal> I think there is
07:45:01 <iagoabal> maltem, uhmm wait a moment
07:45:16 <ehird> gwern: why are you using them :P
07:45:27 <gwern> ehird: I'm not, the tetris dev is
07:45:37 <ehird> :P
07:47:16 <klinkers> is ghci compiling code?
07:47:28 <klinkers> unoptimize compiled code? or it is interpreted?
07:47:31 <ehird> klinkers: yes. uh, I think.
07:47:37 <maltem> iagoabal: I hope you'll find it :)
07:48:12 <iagoabal> maltem, I (or I think that) remember that I saw it before
07:48:34 <Deewiant> klinkers: AIUI ghci generates a kind of bytecode but it's not really optimized at all
07:49:45 <maltem> iagoabal: right, I just don't find such a thing anywhere
07:51:44 <maltem> iagoabal: ah I got it :)
07:51:51 <iagoabal> yep?
07:51:53 <iagoabal> where?
07:52:03 <maltem> GHC.Environment.getFullArgs
07:52:20 <iagoabal> perfect ;P
07:52:25 <iagoabal> I remember that I saw it
07:52:27 <iagoabal> but not where
07:52:27 <iagoabal> :P
07:52:48 <maltem> sounds at least promising
07:52:55 <gwern> @hoogle getFullArgs
07:52:56 <lambdabot> No results found
07:53:08 <ehird> hi Deewiant
07:53:18 <Deewiant> yo
08:03:25 <klinkers> anyone have a realtek wireless card and have it work on any linux platform? because im about ready to kill myself...
08:13:44 <b_jonas> rm /dev/meme
08:14:27 <pardus> klinkers, my friend blamed realtek wireless not so long ago
08:14:58 <pardus> that's why I prefer intell wireless or atheros
08:16:33 <b_jonas> is Data.Maybe.catMaybes considered evil?
08:16:59 <Olathe> Well, cats are evil.
08:17:03 <BrokenClockwork> Hey, http://hpaste.org/13239 : Why is it not possible to create a pattern match, like:      parse('(':x:')':r) = (parse x) parse r ?
08:17:08 <Olathe> So, that's maybe evil.
08:17:16 <vixey> BrokenClockwork, hey what are you up to? :p
08:17:28 <iagoabal> why evil? :?
08:17:32 <pardus> Olathe, naah, dogs are pure evil.
08:17:35 <BrokenClockwork> I write a SKI Parser
08:17:36 <vixey> BrokenClockwor: "Nil"??
08:17:45 <Olathe> Yes, dogs are, too.
08:17:45 <iagoabal> lol
08:17:59 <vixey> BrokenClockwork, is it homewrk
08:18:04 <BrokenClockwork> yes
08:18:11 <BrokenClockwork> x-mas homework
08:18:11 <Provenzano> hi. I'm trying to save a list in a file. is that possible?
08:18:18 <vixey> BrokenClockwork, ?? lol
08:18:31 <BrokenClockwork> it's homework over X-Mas
08:18:39 <BrokenClockwork> I have holiday right now
08:18:47 <Olathe> Provenzano: Sure, if the data in the list has show and read.
08:18:50 <vixey> why don't you separate out the combinators from the syntax
08:18:50 <vixey> like
08:18:54 <vixey> data Combinator = S | K | I
08:19:08 <vixey> data Tree a = Leaf a | Branch (Tree a) (Tree a)
08:19:15 <vixey> type SKI = Tree Combinator
08:19:28 <vixey> so you can write
08:19:46 <vixey> parseCombinator :: Parser Combinator, parseTree :: Parser a -> Parser (Tree a)
08:19:58 <vixey> then parseSKI = parseTree parseCombinator
08:20:12 <Provenzano> it is for me vixey?
08:20:22 <vixey> Provenzano: sure if you like
08:20:31 <vixey> I'm just suggesting it to anyone
08:20:37 <BrokenClockwork> :)
08:20:55 <Provenzano> I'm a n00b @ haskell, and I have to try to use it :p
08:21:04 <vixey> I'm just using ReadP
08:21:09 <vixey> which seems to fit this well
08:24:43 <b_jonas> BrokenClockwork: because that's type errorred
08:25:12 <BrokenClockwork> yeah ghci told me so, too
08:25:16 <BrokenClockwork> I just don't get it
08:25:20 <ehird> @hoogle a -> (a -> b) -> b
08:25:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:25:21 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
08:25:21 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
08:25:24 <b_jonas> BrokenClockwork: what's the type of the (:) constructur?
08:25:33 <vixey> BrokenClockwork, imagine a pattern match like:
08:25:42 <ehird> hmm, there's no nice infix (flip ($)) in any module?
08:25:46 <vixey> f (a ++ "-" ++ b) = (a,b)
08:25:57 <b_jonas> ehird: I heared it's called ($.)
08:26:01 <vixey> what is the result of  f "a-b-c"
08:26:24 <vixey> really there it is a nondeterministic choice of ("a","b-c") and ("a-b","c")
08:26:31 <ehird> @hoogle ($.)
08:26:31 <lambdabot> No results found
08:26:40 <BrokenClockwork> ah
08:26:54 <Deewiant> ehird: where "called x" means "commonly called x by those who use it"
08:26:54 <b_jonas> > let { f (a ++ "-" ++ b) = (a,b); } in f "a-b-c"
08:26:56 <lambdabot>   <no location info>: Parse error in pattern
08:27:00 <vixey> so functionally, there is not a clear way to give meaning to pattern matching like that
08:27:00 <ehird> ah.
08:27:01 <ehird> :)
08:27:09 <BrokenClockwork> okay now I get it
08:27:14 <ehird> it'd be nice if it was in some common place, though.
08:27:38 <ehird> also, $. doesn't really reflect the "piping" nature of it, does it?
08:28:12 <Deewiant> there's (>>>) for flip (.)
08:28:25 <b_jonas> ehird: same as for (flip const) and for (\x y z -> if x then y else z) and for (\x y z -> case x of { [] -> y; u : v -> z u v })
08:28:28 <Deewiant> which is probably what you want anyway :-P
08:28:37 <ehird> :t flip (.)
08:28:38 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
08:28:41 <b_jonas> those aren't in a library either but everyone thinks they're so basic they define them
08:28:45 <ehird> Nah.
08:28:58 <ehird> b_jonas: if'
08:29:02 <ehird> @src if'
08:29:02 <lambdabot> Source not found. Are you on drugs?
08:29:02 <b_jonas> ehird: yeah
08:29:04 <ehird> err
08:29:04 <Deewiant> ehird: not in any standard place.
08:29:05 <ehird> :t if'
08:29:06 <lambdabot> Not in scope: `if''
08:29:08 <b_jonas> but it's not actually in the sources
08:29:09 <Olathe> if' doesn't exist.
08:29:11 <ehird> huh.
08:29:12 <b_jonas> if' is a standard name for it
08:29:14 <ehird> I was certain it did
08:29:21 <Deewiant> ?pl \x y z -> if x then y else z
08:29:21 <lambdabot> if'
08:29:31 <Deewiant> that's the main place you see it
08:29:34 <ehird> of course caleskell has it
08:29:37 <ehird> caleskell has everything
08:29:42 <Deewiant> no, not even caleskell
08:29:42 <Deewiant> only ?pl
08:29:47 <Deewiant> sorry :-P
08:29:57 <Botje> Caleskell even has unsafeSolveHaltingProblem?
08:29:59 <ehird> wait.. something caleskell DOESN'T have?
08:30:01 <ehird> hahahahahahahahah!
08:30:05 <ehird> nice joke.
08:30:22 <hugo___1> im reading the "functional pearl" paper, it is very enlighting
08:30:23 <Deewiant> AFAIK Caleskell doesn't have much, it just generalizes a few ops :-P
08:30:26 <b_jonas> Botje: lol
08:30:44 <b_jonas> Botje: what's its type?
08:30:49 <ehird> Deewiant: no, caleskell has _everything_
08:30:55 <Deewiant> b_jonas: (a -> b) -> Bool
08:31:02 <ehird> Deewiant: why (a -> b)?
08:31:03 <ehird> surely just a
08:31:05 <b_jonas> @quote unsafeSolveHaltingProblem
08:31:06 <lambdabot> No quotes match.
08:31:09 <ehird> also, it's unsafe, you need some #s
08:31:12 <Deewiant> oh right, a
08:31:16 <ehird> wait, no
08:31:19 <ehird> GHC.Any
08:31:21 <ehird> or whatever it's called
08:31:28 <ehird> unsafeSolveHaltingProblem# :: Any -> Bool#
08:31:40 <ehird> -- may cause your toaster to explode
08:31:44 <Botje> I don't think sharp Bools are a good idea
08:31:44 <Deewiant> nah, a is fine; it works for any type without even knowing anything about it
08:31:53 <ehird> Any is more primitive :-P
08:32:06 <ehird> Botje: yeah someone might get hurt
08:32:13 <b_jonas> @remember Botje Caleskell even has unsafeSolveHaltingProblem?
08:32:14 <lambdabot> I will remember.
08:32:50 <b_jonas> I think it's unsafeSolveHaltingProblem# :: () -> ();
08:33:01 <Olathe> Is Caleskell available somewhere ?
08:33:13 <b_jonas> where unsafeSolveHaltingProblem# bottom = (); unsafeSolveHaltingProblem# () = bottom;
08:33:45 <Deewiant> haha
08:34:23 <b_jonas> but maybe a -> Bool makes more sense, returning true iff its arg is bottom
08:34:40 <ehird> Olathe: your local lambdabot
08:34:47 <b_jonas> > let { x = unsafeSolveHaltingProblem# x; } in x
08:34:49 <lambdabot>   Not in scope: `unsafeSolveHaltingProblem#'
08:35:07 <Deewiant> b_jonas: not iff; also if it's an IO a which never returns, say
08:35:35 <ehird> > let f = if unsaveHaltingProblem# x then () else f in f
08:35:35 <opqdonut> b_jonas: why not
08:35:36 <lambdabot>   Not in scope: `unsaveHaltingProblem#'
08:35:36 <EvilTerran> unsafeHalts# (_|_) = False; unsafeHalts# x = True
08:35:38 <b_jonas> I think it gives some monadic value, not just a boolean though
08:35:41 <b_jonas> because of that paradox
08:35:48 <ehird> b_jonas: that;'s no paradox
08:35:49 <ehird> mine is
08:35:54 <opqdonut> yeah
08:36:10 <EvilTerran> throw in some weird semantics for pattern-matching (_|_)
08:36:46 <b_jonas> so there's a monad in which you can determine the halting of any pure expr (or say almost pure with IO still counting as pure), then a higher monad in which you can determine the halting of any action in that first monad, etc
08:36:54 <b_jonas> then there's no paradox
08:37:06 <EvilTerran> "force the value being matched in another thread; guess that it doesn't terminate and continue evaluating appropriately; if it terminates, rewind evaluation to the pattern-match, then continue
08:37:07 <b_jonas> otoh we might not be able to run them on computers
08:37:08 <EvilTerran> " :P
08:37:28 <ehird> hmm, is there a CaseInsensitiveMap
08:37:33 <opqdonut> EvilTerran: :D
08:37:40 <ehird> for String keys
08:37:54 <EvilTerran> sure, "doesn't terminate before the program does" is a weaker restriction than "doesn't terminate", but it's a close enough approximation :P
08:38:24 <b_jonas> ehird: is there? I thought it's better to have a case preserving string wrapper type on which Eq and Ord are case insensitive
08:38:35 <b_jonas> ehird: at least that's what I defined in a ruby app
08:38:37 <ehird> true, but...
08:38:38 <b_jonas> and I used normal maps on them
08:38:39 <ehird> is there :)
08:38:41 <EvilTerran> that'd do it
08:38:45 <b_jonas> you can define them
08:38:48 <ehird> or do I have to roll my own ;)
08:39:12 <b_jonas> has the advantage that you can use them sets and arrays and stuff and also use pairs as keys
08:39:34 <b_jonas> and usually you treat a given string either always case-sensitive or always case-insensitive so it makes sense to be a type
08:39:41 <EvilTerran> newtype Caseless = Caseless String; instance Eq Caseless where Caseless x == Caseless y = map toUpper x == map toUpper y; ...
08:39:47 <ehird> so, the answer is yes
08:40:18 <EvilTerran> (similar Ord instance)
08:40:36 <b_jonas> in fact I think I actually used these not just in maps but some other map-like type too
08:40:56 <b_jonas> (a size-limited memoization map that forgets the last accessed value when it gets too large)
09:09:24 <msch> is it possible to have two separate cabal installations? (I'm thinking of ~/.cabal-ghc6.8 and ~/.cabal-ghc6.10)
09:13:34 <_andre> could anyone give me a hand with http://hpaste.org/13240 ? :)
09:13:51 <_andre> ghc says "Could not deduce (MArray (STArray s) a (State StdGen)) from the context () arising from a use of `readArray'"
09:13:57 <_andre> but i don't understand what that means
09:14:23 <bos> _andre: to use readArray and writeArray, you have to be in the ST monad
09:14:33 <bos> _andre: but you're trying to operate in the State monad
09:14:41 <_andre> oh
09:15:18 <_andre> so i guess i'll have to use a transformer then
09:16:48 <kpreid> there is not (cannot be?) a STT
09:16:57 <kpreid> you cna use StateT ST though
09:17:40 <b_jonas> there can't be an efficent one, yeah
09:19:10 <b_jonas> look at me, I'm writing haskell
09:19:16 <b_jonas> I'm pretending to be a programmer
09:21:13 <_andre> something like "type ShuffleT s a = StateT StdGen (ST s) a" ?
09:24:18 <PeakerWork> any good way to represent a tree of strings where all the leafs are ints?
09:24:27 <PeakerWork> (is there a library data type that can do this?)
09:25:44 <vixey> what? Peaker that doesn't make sense
09:26:09 <vixey> data LeafStringTree = Leaf Int | Branch String LeafStringTree LeafStringTree this?
09:28:45 <PeakerWork> vixey: Yeah, though now I've discovered that was wrong and the leafs are not typed that way
09:29:39 <PeakerWork> is there something like this in the libs: data Tree a = Tree a [Tree a]
09:29:53 <vixey> I've got that
09:30:20 <vixey> data Graph a = a :-->: [Graph a] deriving Show
09:30:43 <b_jonas> PeakerWork: there's Data.Tree which is similar
09:30:44 <vixey> HTH :p
09:30:59 <b_jonas> not exactly the same
09:31:08 <b_jonas> but there are so many different trees that you can't have just one type
09:31:27 <PeakerWork> vixey: why is that a graph?
09:31:44 <vixey> I use it in combination with other stuff
09:31:51 <opqdonut> PeakerWork: it can be cyclic
09:31:53 <PeakerWork> vixey: a is identity, rather than contained data?
09:32:09 <PeakerWork> opqdonut: but there's no way to find out where it cycles, that way, given referential transparency
09:32:21 <EvilTerran> ,src ''Tree
09:32:26 <vixey> like  f :: a -> [a]   is the adj. list representation,  n :: [a] is a list of all the nodes,  Graph is  just a tool to write algorithms on these
09:32:39 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
09:32:40 <vixey> i.e. transitive closure is a one liner
09:33:02 <EvilTerran> , let nontree = Node () [nontree] in nontree
09:33:05 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
09:33:05 <vixey> DFS avoiding cycles etc
09:33:36 <PeakerWork> vixey: but to avoid cycles, you need a concept of identity?
09:33:52 <vixey> no just decidable equality on a
09:34:02 <vixey> *ahem*
09:34:06 <vixey> no just Eq on a
09:34:22 <vixey> and lazyness of course :)
09:34:23 <Saizan> so yeah, you use 'a' as the node identity
09:34:46 <PeakerWork> vixey: So you can't distinguish a graph that has a node containing 4 referring to two nodes containing 5, from one that has 4 -> 5 ?
09:34:48 <EvilTerran> PeakerWork, anyway, that "data Tree" is in Data.Tree, i believe
09:35:03 <PeakerWork> EvilTerran: thanks, it doesn't seem like the one I have
09:35:05 <vixey> PeakerWork, I tthink 5 == 5
09:35:21 <vixey> PeakerWork, so there aint two different 5.s
09:35:24 <PeakerWork> vixey: but a node containing 5 is not necessarily another node containing 5, so 5 is your identity here, which is what I asked
09:35:38 <vixey> dunno what you are getting at
09:35:39 <EvilTerran> PeakerWork, considering type Forest a = [Tree a], i think it is
09:35:50 <PeakerWork> EvilTerran: oh, I didn't know that given :)
09:36:00 <EvilTerran> ,src ''Forest
09:36:06 <lunabot>  type Forest a = [Tree a]
09:36:09 <PeakerWork> EvilTerran: why is there a type-alias for [Tree a] ?
09:36:13 <MyCatVerbs> PeakerWork: then impose the requirement for distinct a's. Enforce it with smart constructors, if at all. :)
09:36:18 <EvilTerran> because whoever wrote Data.Tree felt like it?
09:36:40 <mapreduce> I followed the instructions in RWH for setting up Cabal, and found it fails.  Details follow.
09:36:40 * EvilTerran likes "Map NodeId (Set NodeId)" as a more concrete graph representation
09:36:58 <mapreduce> cd Cabal-1.6.0.1 && runghc Setup cofigure -p
09:37:05 <EvilTerran> (or "Map NodeId (NodeLabel, Set NodeId)")
09:37:22 <mapreduce>    Could not find module `System.FilePath'
09:37:32 <mapreduce> Any suggestions
09:37:33 <mapreduce> ?
09:37:42 <PeakerWork> Map NodeId (NodeData, Set (NodeId, EdgeData))
09:37:48 <Saizan> mapreduce: how did you get your ghc?
09:38:28 <mapreduce> I forget, but probably via apt-get install on a customised EEE.  It's 6.6.
09:38:51 <Saizan> mapreduce: apt-get install libghc6-filepath-dev
09:40:01 <mapreduce> That appears to have got me past the problem.  Thanks a lot.
09:41:08 <Saizan> debian's ghc package installs almost no library
09:42:10 <racliv> @src loeb
09:42:10 <lambdabot> Source not found. There are some things that I just don't know.
09:42:19 <mapreduce> At least the following dependencies are missing:
09:42:19 <racliv> > loeb []
09:42:21 <lambdabot>   []
09:42:31 <mapreduce> filepath >=1 && <1.2
09:42:34 <Badger> :t loeb
09:42:35 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
09:42:44 <mapreduce> 0.11-2 was installed.
09:42:46 <racliv> > loeb [const 1, (!!0) + 6]
09:42:48 <lambdabot>       No instance for (Num ([a] -> a))
09:42:48 <lambdabot>        arising from the literal `6' at...
09:42:59 <racliv> > loeb [const 1, (!!0)]
09:43:00 <lambdabot>   [1,1]
09:43:04 <mapreduce> I will uninstall ghc and do it from binary packages.
09:43:17 <mapreduce> .tgz etc.
09:43:30 <racliv> :t curry
09:43:32 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
09:43:34 <Saizan> mapreduce: you can find those packages on hackage, fyi
09:44:10 <mapreduce> I don't know how to use hackage yet.  In fact I've just realised that I managed to get hackage and cabal confused.
09:44:12 <ehird> is there a tutorial for using parsec's LanguageDef anywhere?
09:44:24 <racliv> :t uncurry
09:44:26 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:45:59 <racliv> > loeb [const 1,  (+) (!!0) 6]
09:46:01 <lambdabot>       No instance for (Num ([a] -> a))
09:46:01 <lambdabot>        arising from the literal `6' at...
09:46:12 <racliv> > loeb [const 1,  (+) (!!0) (const 6)]
09:46:14 <lambdabot>       No instance for (Num ([a] -> a))
09:46:14 <lambdabot>        arising from a use of `+' at <i...
09:46:22 <Saizan> ehird: seen the secret parsec documentation? http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
09:46:42 <ehird> Saizan: I was reading the ghc-libraries docs
09:47:28 <b_jonas> what on earth is loeb?
09:47:40 <ehird> :t loeb
09:47:41 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
09:47:45 <Saizan> > loeb [const 1,  liftM2 (+) (!!0) (const 6)]
09:47:46 <lambdabot>   [1,7]
09:49:26 <racliv> > loeb [const 7, liftM2 (+) (!!0) (const 6)]
09:49:28 <lambdabot>   [7,13]
09:49:48 <baaba> @src loeb
09:49:48 <lambdabot> Source not found. Are you on drugs?
09:49:56 <racliv> :t iterate
09:49:57 <lambdabot> forall a. (a -> a) -> a -> [a]
09:50:00 <Saizan> ?type let loeb f = let r = fmap ($r) f in r in loeb
09:50:01 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
09:50:33 <byorgey> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (!!(n+1)) [0..20])
09:50:34 <lambdabot>   <no location info>: parse error on input `;'
09:50:45 <byorgey> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (!!(n+1)) [0..20]))
09:50:47 <lambdabot>   Couldn't match expected type `[b -> t]'
09:50:51 <byorgey> phooey
09:51:15 <byorgey> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (!!(n+1))) [0..20])
09:51:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:51:17 <racliv> > iterate (+6) 0
09:51:18 <lambdabot>   [0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,1...
09:52:00 <PeakerWork> @type mfix
09:52:02 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:52:19 <PeakerWork> loeb is sort of a functor fix
09:52:21 <PeakerWork> ?
09:53:05 <racliv> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (liftM2 (*) (!!n) 2) (!!(n+1))) [0..20])
09:53:06 <lambdabot>       No instance for (Num ([a] -> a))
09:53:06 <lambdabot>        arising from the literal `2' at...
09:53:18 <racliv> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (liftM2 (*) (!!n) (const 2)) (!!(n+1))) [0..20])
09:53:20 <lambdabot>   [0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,1...
09:54:35 <b_jonas> > let { myloeb f = fix (\a -> map ($a) f); } in myloeb [const 1,  liftM2 (+) (!!0) (const 6)]
09:54:37 <lambdabot>   [1,7]
09:55:01 <racliv> :t fix
09:55:02 <lambdabot> forall a. (a -> a) -> a
09:57:17 <racliv> > fix (1+)
09:57:18 <lambdabot>   * Exception: stack overflow
09:57:27 <racliv> > fix (1:)
09:57:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:57:38 <racliv> > fix (:1)
09:57:39 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
09:57:39 <lambdabot>        Expect...
09:57:58 <PeakerWork> @type (1:)
09:57:59 <lambdabot> forall t. (Num t) => [t] -> [t]
09:58:01 <PeakerWork> @type (:[1])
09:58:02 <lambdabot> forall a. (Num a) => a -> [a]
09:58:07 <racliv> > fix (:[[1]])
09:58:09 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
09:58:09 <lambdabot>        Expect...
09:58:12 <racliv> > fix (:[1])
09:58:14 <PeakerWork> @type (:[[1]])
09:58:14 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
09:58:14 <lambdabot>        Expect...
09:58:15 <lambdabot> forall t. (Num t) => [t] -> [[t]]
09:58:32 <PeakerWork> note (:y) will always return something that has an extra list layer
09:58:34 <b_jonas> > let { myloeb f = fix (\a -> map ($a) f); } in (const 0 : const 1 : map (\n -> liftM2 (+) (liftM2 (*) (!!n) (const 2)) (!!(n+1))) [0..20])
09:58:35 <lambdabot>       Overlapping instances for Show ([a] -> a)
09:58:36 <lambdabot>        arising from a use of ...
09:58:46 <b_jonas> > let { myloeb f = fix (\a -> map ($a) f); } in myloeb (const 0 : const 1 : map (\n -> liftM2 (+) (liftM2 (*) (!!n) (const 2)) (!!(n+1))) [0..20])
09:58:48 <lambdabot>   [0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,1...
09:59:00 <pumpkin> > l√∂b  (const 0 : const 1 : map (\n -> liftM2 (+) (liftM2 (*) (!!n) (const 2)) (!!(n+1))) [0..20])
09:59:01 <lambdabot>   [0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,1...
09:59:06 <wli> > let parts' n k m | n == m * k = [replicate (fromIntegral k) m] | k == 1 = [[n]] | k <= 0 || k > n || n < m * k = [] | q <- n `quot` m = concat [map (replicate (fromIntegral r) m ++) $ parts' (n - m * r) (fromIntegral $ k - r) (m + 1) | r <- [q, q - 1 .. 0]] in [length $ concatMap (parts n) [n, n - 1 .. 1] | n <- [1..]]
09:59:08 <lambdabot>   Not in scope: `parts'
09:59:30 <racliv> > l√∂b (const 0 : const 1 : const 2 : map (\n -> liftM2 (+) (liftM2 (*) (!!n) (const 2)) (!!(n+1))) [0..20])
09:59:31 <wli> > let parts' n k m | n == m * k = [replicate (fromIntegral k) m] | k == 1 = [[n]] | k <= 0 || k > n || n < m * k = [] | q <- n `quot` m = concat [map (replicate (fromIntegral r) m ++) $ parts' (n - m * r) (fromIntegral $ k - r) (m + 1) | r <- [q, q - 1 .. 0]] ; parts n k = parts' n k 1 in [length $ concatMap (parts n) [n, n - 1 .. 1] | n <- [1..]]
09:59:33 <lambdabot>   [0,1,2,1,4,5,6,13,16,25,42,57,92,141,206,325,488,737,1138,1713,2612,3989,60...
09:59:47 <lambdabot>   thread killed
09:59:51 <wli> That looks wrong, but anyway.
10:00:28 <racliv> > l√∂b (const 0 : const 1 : const 2 : map (\n -> liftM2 (+) (liftM2 (*) (!!n+1) (const 2)) (!!(n))) [0..20])
10:00:30 <lambdabot>       The operator `!!' [infixl 9] of a section
10:00:30 <lambdabot>          must have lower prec...
10:00:57 <ehird> l√∂b = loeb, that's great
10:01:29 <racliv> > l√∂b (const 0 : const 1 : const 2 : map (\n -> liftM2 (+) (!!n) (liftM2 (*) (!!(n+1)) (const 2))) [0..20])
10:01:32 <lambdabot>   [0,1,2,2,5,6,12,17,30,46,77,122,200,321,522,842,1365,2206,3572,5777,9350,15...
10:01:40 <racliv> hmm...
10:01:57 <eu-prleu-peupeu> hello
10:02:02 <racliv> > l√∂b (const 0 : const 1 : const 2 : map (\n -> liftM2 (+) (!!n) (liftM2 (*) (!!(n+1)) (const 2))) [0..20])
10:02:04 <lambdabot>   [0,1,2,2,5,6,12,17,30,46,77,122,200,321,522,842,1365,2206,3572,5777,9350,15...
10:02:11 <racliv> > l√∂b (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (liftM2 (*) (!!(n+1)) (const 2))) [0..20])
10:02:14 <lambdabot>   [0,1,2,5,12,29,70,169,408,985,2378,5741,13860,33461,80782,195025,470832,113...
10:02:15 <eu-prleu-peupeu> can someone point me to good haskell papers for me to read on the train ?
10:02:28 <racliv> there we go
10:02:31 <racliv> pell numbers
10:03:47 <b_jonas> though there's a bit easier way to generate those
10:03:56 <b_jonas> (/msg buubot oeis: pell numbers)
10:04:29 <racliv> > l√∂b (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (liftM2 (*) (!!(n+1)) (const 2))) [0..])
10:04:44 <lambdabot>   thread killed
10:04:54 <wli> Now I have it.
10:05:03 <wli> > let parts' n k m | n == m * k = [replicate (fromIntegral k) m] | k == 1 = [[n]] | k <= 0 || k > n || n < m * k = [] | q <- n `quot` m = concat [map (replicate (fromIntegral r) m ++) $ parts' (n - m * r) (fromIntegral $ k - r) (m + 1) | r <- [q, q - 1 .. 0]] ; parts n k = parts' n k 1 ; partitions n = concatMap (parts n) [n, n - 1 .. 1] in map (length . partitions) [1..20]
10:05:05 <lambdabot>   [1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627]
10:05:32 <b_jonas> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (!!(n+1))) [0..])
10:05:47 <lambdabot>   thread killed
10:05:54 <b_jonas> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (!!(n+1))) [0..10])
10:05:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144]
10:06:08 <b_jonas> > loeb (const 0 : const 1 : map (\n -> liftM2 (+) (!!n) (!!(n+1))) [0..20])
10:06:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:06:19 <b_jonas> now how about catalan numbers?
10:06:22 <racliv> > infinity
10:06:25 <lambdabot>   * Exception: stack overflow
10:06:30 <Badger> heh
10:06:57 <PeakerWork> is there a wiki page with 9999 ways to generate the fib sequence?
10:07:04 <wli> Yes.
10:07:14 <PeakerWork> is loeb on that page? :)
10:07:15 <dons> PeakerWork: yeah
10:07:16 <dons> no.
10:07:19 <b_jonas> > loeb (const 0 : const 1 : (\s -> map (\n -> sum (map (\k -> s!!k + s!!(n-k-1)) [0..n-1]))) [0..20])
10:07:22 <lambdabot>   Couldn't match expected type `[b -> t]'
10:07:32 <b_jonas> dunno but I myself have written at least twenty ways
10:07:35 <Deewiant> ?ty loeb
10:07:37 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
10:08:04 <b_jonas> there are some evil ones among those, let me search for those writeups
10:08:28 * wli 's code is still in the wiki last he checked.
10:09:32 <wli> http://haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
10:09:46 <b_jonas> > loeb (const 0 : const 1 : map (\n s -> sum (map (\k -> s!!k + s!!(n-k-1)) [0..n-1]))) [0..20])
10:09:48 <lambdabot>   <no location info>: parse error on input `)'
10:10:07 <b_jonas> > loeb (const 0 : const 1 : map (\n s -> sum (map (\k -> s!!k + s!!(n-k-1)) [0..n-1])) [0..20])
10:10:10 <lambdabot>   [0,1,0,0,2,2,2,6,10,14,26,46,74,126,218,366,618,1054,1786,3022,5130,8702,14...
10:10:14 <b_jonas> hmm
10:10:19 <b_jonas> > loeb (const 1 : map (\n s -> sum (map (\k -> s!!k + s!!(n-k-1)) [0..n-1])) [0..20])
10:10:22 <lambdabot>   [1,0,2,2,6,10,22,42,86,170,342,682,1366,2730,5462,10922,21846,43690,87382,1...
10:10:29 <b_jonas> not really
10:10:35 <b_jonas> > loeb (const 1 : map (\n s -> sum (map (\k -> s!!k * s!!(n-k-1)) [0..n-1])) [0..20])
10:10:37 <lambdabot>   [1,0,1,0,2,0,5,0,14,0,42,0,132,0,429,0,1430,0,4862,0,16796,0]
10:10:45 <b_jonas> almost...
10:10:46 * wli seems to remember Bernoulli numbers being substantially more involved than the 2nd-order linear recurrences with constant coefficients.
10:11:03 <b_jonas> what are all the zeros for?
10:11:19 <b_jonas> > loeb (const 1 : map (\n s -> sum (map (\k -> s!!k * s!!(n-k-1)) [0..n])) [0..20])
10:11:21 <lambdabot>   [1,* Exception: Prelude.(!!): negative index
10:11:26 <b_jonas> > loeb (const 1 : map (\n s -> sum (map (\k -> s!!k * s!!(n-k)) [0..n])) [0..20])
10:11:41 <lambdabot>   thread killed
10:12:02 <b_jonas> > [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790] -- damn it
10:12:05 <lambdabot>   [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,...
10:14:30 <Deewiant> > extendSequence [1,1,2,5]
10:14:33 <lambdabot>   [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,...
10:14:54 <racliv> > filter (==0) (loeb (const 1 : map (\n s -> sum (map (\k -> s!!k * s!!(n-k-1)) [0..n-1])) [0..20]))
10:14:58 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0]
10:15:05 <racliv> > filter (!=0) (loeb (const 1 : map (\n s -> sum (map (\k -> s!!k * s!!(n-k-1)) [0..n-1])) [0..20]))
10:15:07 <lambdabot>   Not in scope: `!='
10:15:11 <b_jonas> actually this works too: /msg evalj : 0j0":(,[:+/]*|.)^:20,1
10:15:26 <wli> I'm not sure how to combinatorially interpret "n labeled balls into n indistinguishable boxes."
10:15:33 <racliv> :t extendSequence
10:15:35 <lambdabot> SequenceData -> SequenceData
10:15:36 <Deewiant> b_jonas: It looks like your paste came out as line noise, try again
10:16:06 <racliv> > extendSequence [1, 1, 2]
10:16:10 <maltem> wli: an partition of a set?
10:16:11 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:16:20 <maltem> wli: strange though the two occurences of n
10:16:35 <racliv> > extendSequence [1, 2, 5]
10:16:35 <b_jonas> > reverse (iterate (\s -> sum (zipWith (*) (reverse s) s) : s) !! 20)
10:16:38 <lambdabot>   Couldn't match expected type `[a]'
10:16:39 <lambdabot>   [1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35...
10:16:51 <Deewiant> cute
10:16:59 <racliv> > extendSequence [1, 2, 5, 12]
10:17:02 <lambdabot>   [1,2,5,12,29,70,169,408,985,2378,5741,13860,33461,80782,195025,470832,11366...
10:17:03 <wli> maltem: THe description of Bell numbers just sucks.
10:17:05 <Deewiant> ?pl \s -> sum (zipWith (*) (reverse s) s) : s
10:17:06 <lambdabot> (:) =<< sum . (zipWith (*) =<< reverse)
10:17:07 <b_jonas> ok, but how about with loeb?
10:17:18 <wli> maltem: In the OEIS that is.
10:17:24 <vixey> n labeled balls into n indistinguishable boxes ??
10:17:36 <vixey> isn't that the same as (the much less confusing) n balls into n different boxe
10:17:38 <vixey> s
10:18:12 <b_jonas> racliv: if you want to use oeis, '/msg buubot oeis: catalan' or '/msg buubot oeis: a108' is the simplest
10:18:33 <maltem> wli: ah wait, it's not a partition if you allow empty boxes
10:18:35 <wli> vixey: No idea. IMHO it's too vague.
10:19:00 <b_jonas> so how do you write this with loeb?
10:19:37 <wli> I like the n-pattern sequence definition.
10:20:01 <b_jonas> > loeb (1 : map (\n t -> let { s = take n s } in sum (zipWith (*) (reverse s) s) : s) [1..20])
10:20:04 <lambdabot>       No instance for (Num ([[a]] -> [a]))
10:20:04 <lambdabot>        arising from the literal `1...
10:20:19 <b_jonas> > loeb (const 1 : map (\n s -> sum (map (\k -> s!!k * s!!(n-k-1)) [0..n-1])) [1..20])
10:20:25 <b_jonas> > loeb (const 1 : map (\n t -> let { s = take n s } in sum (zipWith (*) (reverse s) s) : s) [1..20])
10:20:28 <lambdabot>       No instance for (Num [a])
10:20:28 <lambdabot>        arising from the literal `1' at <inter...
10:20:29 <ziman> > loeb $ 0:1:map (\x -> liftM2 (+) (!!x) (!!(x+1))) [1..]
10:20:30 <Deewiant> > loeb (const [1] : map (\n t -> let { s = take n s } in sum (zipWith (*) (reverse s) s) : s) [1..20])
10:20:32 <lambdabot>       No instance for (Num ([a] -> a))
10:20:33 <lambdabot>        arising from the literal `0' at...
10:20:35 <lambdabot>   thread killed
10:20:46 <lambdabot>   thread killed
10:21:09 <b_jonas> > loeb (1 : map (\n t -> let { s = take n t } in sum (zipWith (*) (reverse s) s) : s) [1..20])
10:21:12 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
10:21:12 <lambdabot>        Expect...
10:21:32 <b_jonas> > loeb (1 : map (\n t -> let { s = take n t } in sum (zipWith (*) (reverse s) s)) [1..20])
10:21:34 <lambdabot>       No instance for (Num ([a] -> a))
10:21:34 <lambdabot>        arising from the literal `1' at...
10:21:54 <sbahra> :t loeb
10:21:56 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
10:22:05 <maltem> wli: hm I looked up Bell numbers, but they don't match that n-balls-n-boxes definition at all :)
10:22:09 <ziman> > loeb $ const 0:const 1:map (\x -> liftM2 (+) (!!x) (!!(x+1))) [1..]
10:22:14 <lambdabot>   [0,1,* Exception: stack overflow
10:22:17 <sbahra> scary
10:22:17 <b_jonas> > loeb (const 1 : map (\n t -> let { s = take n t } in sum (zipWith (*) (reverse s) s)) [1..20])
10:22:19 <vixey> > flip concatMap
10:22:22 <lambdabot>       Overlapping instances for Show ([a] -> (a -> [b]) -> [b])
10:22:22 <lambdabot>        arisin...
10:22:24 <boyscared> is there a way to get the type signature of a unary operator like negation (e.g. -1)?
10:22:27 <ziman> > loeb $ const 0:const 1:map (\x -> liftM2 (+) (!!x) (!!(x+1))) [0..]
10:22:30 <lambdabot>   [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,...
10:22:41 <wli> The rhyme scheme combinatorial interpretation is also good for the Bell numbers.
10:22:42 <lambdabot>   thread killed
10:22:49 <sbahra> :t (`not`)
10:22:51 <lambdabot> parse error on input `)'
10:22:54 <sbahra> wot
10:22:56 <b_jonas> boyscared: the unary operator is special syntax, it always means the method 'negate' from prelude, and there are no other unary operators in haskell
10:23:01 <ziman> @oeis [1,1,2,5,14,42,132,429,1430,4862]
10:23:01 <lambdabot>  Sequence not found.
10:23:06 <sbahra> ye
10:23:31 <PeakerWork> why doesn't UTCTime have a Show?
10:23:33 <b_jonas> did that finally work?
10:23:36 <b_jonas> > loeb (const 1 : map (\n t -> let { s = take n t } in sum (zipWith (*) (reverse s) s)) [1..20])
10:23:42 <boyscared> b_jonas: thanks
10:23:51 <lambdabot>   [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,...
10:24:19 <b_jonas> boyscared: by the way it's so special it's even recognized in patterns (the same way as numeric literals and string literals are)
10:24:57 <b_jonas> great, so I can generate catalans with loeb
10:25:14 <sbahra> :t const
10:25:16 <lambdabot> forall a b. a -> b -> a
10:25:19 <PeakerWork> hmm.. why isn't there an Ord instance for Data.Tree ?
10:25:32 <sbahra> > const 1 2
10:25:35 <lambdabot>   1
10:26:20 <b_jonas> back to fibonacci, one way to generate them I like is this:
10:26:23 <b_jonas> dc -e1d[pdk+Krlxx]dsxx | less
10:26:40 <dons> looks like the article of the day on proggit is one of those top 10 lists of "stretch" languages. haskell's the first entry, thankfully.
10:26:49 <dons> though i always feel mixed being lumped in with toys :/
10:27:16 <sbahra> overflow
10:27:51 <Deewiant> dons: toys?
10:28:30 <dons> not all langs in that list are past the 'compiler writer == language user' state.
10:28:41 <Deewiant> they aren't?
10:30:03 <sbahra> Io isn't.
10:30:05 <sbahra> At the least.
10:30:48 <Deewiant> I was just about to say that Io might be one which isn't, but surely the rest are?
10:31:22 <luite> dons: do you know if there's a technical reason that there is no unsafeThawU in the uvector package? I needed an enumFromToMU function for something yesterday, but I don't know how to write one efficiently without duplicating a lot of code (or importing a hidden module), an unsafeThawU would've made it easy
10:31:23 <b_jonas> where's that list?
10:31:32 <Deewiant> http://www.reddit.com/r/programming/comments/7kwm5/10_programming_languages_worth_checking_out/
10:31:33 <sbahra> Clojure?
10:31:41 <pumpkin> top is haskell
10:31:50 <pumpkin> although it's not meant to be ordered
10:32:08 <Deewiant> Surely Clojure has users? Or maybe all the talk is just from one-time testers
10:32:20 * sbahra doesn't know
10:32:48 <dons> luite: mmm. we could thaw, yes.
10:33:05 <Deewiant> Hell, a book about Clojure is on the way
10:33:44 <vixey> only 10 ?!
10:33:46 <dons> wow. they're organised.
10:34:04 <vixey> "PLT Scheme" rather than "Scheme"? bizarre
10:34:28 <vixey> 9 languages 1 implementation it should say
10:34:35 <Deewiant> Also "Squeak" rather than "Smalltalk"
10:34:39 <vixey> oops
10:34:42 <vixey> 8/2 thanks
10:57:14 <boegel> I just started reading Real World Haskell, and I must say, it has reawakened my hunger for using Haskell...
10:57:34 <pumpkin> glad to hear it :)
10:57:35 <dcoutts> @yarr!
10:57:35 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
10:57:43 <dcoutts> lambdabot: don't be so rude!
10:58:02 <boegel> I really like the way in which it's written, but I find the small incorrect details disturbing
10:58:13 <pumpkin> boegel: like what?
10:58:22 <boegel> dcoutts: lambdabot is kind of right though, it's been a while
10:58:27 <boegel> pumpkin: well, small things
10:58:58 <dcoutts> boegel: sorry about lambdabot, can't take her anywhere without her mouthing off
10:58:59 <boegel> pumpkin: in chapter 3 (I think), they use a BookInfo type, and sometime refer to BookStore (meaning BookInfo instead)
10:59:14 <boegel> pumpkin: it's clear they mean BookInfo though, because no BookStore thingie was defined
10:59:36 <boegel> pumpkin: I'm trying to keep track of the things annoying me, and I hope I can submit them to the authors
10:59:42 <boegel> dcoutts: ;-)
10:59:54 <pumpkin> the book was written online with an online commenting system
11:00:01 <pumpkin> so you can probably just put comments there
11:00:02 <boegel> pumpkin: yeah, I know...
11:00:23 <boegel> pumpkin: well, I'm not sure if that's the best way to get the corrections in, there's a ton of comments there already :)
11:00:44 * boegel fetches an apple for his gf
11:04:24 <gwern> ok, got tetris cabalized. another tetris
11:04:45 * gwern now has two tetriss in haskell
11:05:07 <PeakerWork> gwern: FRP Tetris?
11:05:35 <gwern> no, they both look like OpenGL/GLUT tetrises
11:06:37 <dons> yay gwern
11:06:54 <PeakerWork> hmm.. when :loading a Main module (one without a "module Blah where..") -- its only importing the "main" name?
11:07:29 <gwern> http://translate.google.com/translate?hl=en&ie=UTF-8&u=http%3A%2F%2Fd.hatena.ne.jp%2Fmokehehe%2Fsearchdiary%3Fword%3DHaskell&sl=ja&tl=en&history_state0= <-- the results of google translating haskell is funny
11:07:37 <PeakerWork> oh, it was already compiled, that's why
11:07:39 <gwern> 'The stone against stone | == black-white stone | stone == white-black - board '
11:07:52 <gwern> 'Acquisition board by board by board xy =!! Y!! X
11:08:34 <gwern> hm. real world haskell in japanese?
11:09:10 <gwern> http://www.mokehehe.com/realworldhaskell/
11:09:19 <gwern> dons: did you know about that? ^
11:09:30 <gwern> 'Real World Haskell license Creative Commons. „Å™„ÅÆ„ÅßÂãâÂº∑„Åå„Å¶„Çâ„Å´Êó•Êú¨Ë™û„Å´Ë®≥„Åô„Å®„ÅÑ„ÅÜ‰ø∫„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÄÇ Since the study was partly my project to translate English into Japanese.
11:09:34 <gwern> http://www.mokehehe.com/realworld haskell / http://www.mokehehe.com/realworld haskell /
11:09:37 <gwern> „Åß„Åç„Çå„Å∞Áô∫Â£≤„Åæ„Åß„Å´Ë®≥„Åó„Åü„Åã„Å£„Åü„Åë„Å©„ÄÅ„Åù„Çå„ÅØÂè∂„Çè„Å¨Â§¢„ÄÇ Release it toË®≥SHITAKATTA preferably, but that dreamÂè∂WANU.
11:09:40 <gwern> ËëóËÄÖ„ÅÆÊñπ„Å´ÈÄ£Áµ°„Çí„Åó„Çà„ÅÜ„Å®ÊÄù„Å£„Åü„Çì„Å†„Åë„Å©ÈÄ£Áµ°ÂÖà„Åå„Çè„Åã„Çâ„Å™„Åã„Å£„Åü„ÅÆ„Åß„ÄÅÂº∑Ë°åÊé°Ê±∫ÔºÅ The author attempts to contact you, but I thought I did not know the contact, so steamrolling! '
11:09:48 <jonaskoelker> Hi all.  Why won't a match against Int?  -- http://rafb.net/p/gTOVo670.html
11:10:22 <paggas> how could i define a function named chain such that chain = [], chain a = [a], chain a b = [a, b] etc? i guess it can be done with some clever use of classes, but i can't get it right :|
11:10:30 <gwern> google translate is frustrating. I can *almost* figure out what he means
11:10:55 <pumpkin> byorgey: ooh, split is up!
11:10:58 <gwern> paggas: you can't really define a function which takes an indifnite number of arguments
11:11:02 <jonaskoelker> paggas: I think you need infinitely many classes
11:11:24 <gwern> 'GHC is not a function of the name of the Japanese shame!'
11:11:30 <jonaskoelker> paggas: and even then, I'm not quite sure it can be done, and I'm _very_ sure it shouldn't be ;)
11:12:10 <paggas> jonafan: at least printf can do it :)
11:12:14 <gwern> 'BangPatterns I'm using it' <-- is that a new lambdacat caption? 'BangPatterns - I'm using it'
11:12:35 <Cthulhon> paggas: http://okmij.org/ftp/Haskell/vararg-fn.lhs
11:12:48 <pumpkin> byorgey: your Data.List.Split blog entry is referenced on hackage, but not public yet :P
11:13:04 <paggas> jonafan: and i'm not saying that i *should* do it, it's more of an exercise on classes and the type system :P
11:13:14 <trygvis> I'm trying to compile ghc for solaris/x86, but I'm getting this failure: (Could not find module `System.Directory') http://rafb.net/p/HpnYGw33.html
11:13:23 <vixey> paggas, you can do it without classes :)
11:13:38 <vixey> well almost it
11:13:39 <gwern> oh wow, he's translated up to chapter 14 of RWH. industrious guy
11:14:09 <paggas> vixey: well, how? :|
11:14:17 <vixey> paggas, do you know GADTs?
11:14:42 <gwern> you don't know GADT!
11:14:44 <paggas> vixey: no
11:14:50 <vixey> you could have something like  chain (I a) (I b) (I c) End ~~> [a,b,c]
11:14:52 <dons> gwern: i wonder: can we link the book gallery to the book entry on the books page, http://www.haskell.org/haskellwiki/Books_and_tutorials
11:14:56 <dons> so clicking on the icons works?
11:15:03 <pumpkin> gwern: who?
11:15:21 <paggas> vixey: aha
11:15:24 <gwern> pumpkin: I was making a verbal joke about the phrase 'You don't know jack'
11:15:31 <pumpkin> oh :P
11:15:36 <gwern> since GADT and Jack sound akin to me
11:15:52 <gwern> dons: I see no reason not to
11:16:32 <vixey> gwern, I read it Gadit, how do you?
11:16:50 <gwern> I read it 'gat'
11:16:57 <gwern> as in the archaic past tense of 'get'
11:16:57 <pumpkin> how many packages are on hackage?
11:17:02 <vixey> silent G
11:17:03 <pumpkin> are we close to 1000 yet?
11:17:16 <vixey> I wish i could write
11:17:20 <vixey> f = f'
11:17:22 <gwern> pumpkin: unique packages, working packages, versions, or just simple tarball count, including all versions?
11:17:23 <vixey> g = g' where
11:17:26 <vixey>   f' = ... g' ...
11:17:30 <vixey>   g' = ... f' ...
11:17:42 <vixey> or maybe  f = f' and g = g' where ...
11:17:47 <pumpkin> gwern: I dunno, whatever the count was for the "900 packages" that went up on reddit recently :P
11:17:47 <vixey> but anyway, I can't :/
11:18:22 <gwern> dons: that page is a little odd. there's two different routes to the RWH website, the thumnail and the book list
11:18:43 <gwern> dons: perhaps a better place would be the RWH website? you must have a links section or somewhere you could stick it
11:19:42 <vixey> > let (f x, g y) = (y,x) in f 3
11:19:43 <lambdabot>   <no location info>: Parse error in pattern
11:19:49 <vixey> > let (f, g) x = (x,x) in f 3
11:19:50 <lambdabot>   <no location info>: Parse error in pattern
11:19:55 <vixey> grrrrr.......
11:21:02 <conal> vixey: maybe you want (generalized) unzip
11:21:36 <vixey> well I just take things out of the where and have everything toplevel
11:21:42 <vixey> and it is ok like that but it is a shame
11:22:13 <dons> gwern: ?
11:22:22 <dons> gwern: i'm talking about the haskell book gallery
11:22:30 <dons> which i think is a great way to introduce haskell books
11:22:40 <dons> rather than a list.
11:22:43 <masklinn> @pl \xs -> zip (0:xs) (xs ++ [0])
11:22:43 <lambdabot> liftM2 zip (0 :) (++ [0])
11:22:52 <dons> but i want each image in the gallery to be a link to the underlying books section
11:22:55 <dons> i'll look into it.
11:23:20 <masklinn> @pl \xs -> map (uncurry (+)) $ zip (0:xs) (xs ++ [0])
11:23:21 <lambdabot> map (uncurry (+)) . liftM2 zip (0 :) (++ [0])
11:23:30 <gwern> there apparently are two ways to do that on Wikipedia, using either imagemaps or |link= syntax, but I dunno if hawiki supports'em
11:24:47 <pumpkin> omg a smiley face
11:26:30 <byorgey> pumpkin: can you see the blog post now?
11:26:33 <masklinn> > max lst !! 300 where lst = [1] : (map (map (uncurry (+)) . liftM2 zip (0 :) (++ [0])) lst)
11:26:35 <lambdabot>   Couldn't match expected type `[a]'
11:26:47 <pumpkin> byorgey: yup! thanks!
11:27:12 <byorgey> there are race conditions inherent in these release sorts of things
11:27:21 <byorgey> and my internet connection sucks atm
11:27:43 <byorgey> anyway, enjoy =)
11:27:52 <pumpkin> byorgey: it looks nice :D
11:28:00 <gwern> byorgey: were my splits of any aid?
11:28:04 <pumpkin> do you have haddock for it too?
11:28:13 <jonaskoelker> just asking before I try this out --- is [1..] a DoS attack against lambdabot? ;)
11:28:19 <gwern> no
11:28:21 <gwern> > [1..]
11:28:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:28:26 <jonaskoelker> bah
11:28:34 <jonaskoelker> y'all code too carefully ;)
11:28:40 <pumpkin> jonaskoelker: it would be unfortunate to have it be vulnerable to such common things :P
11:28:43 <gwern> jonaskoelker: there are no easy attacks against lb, I'm afraid
11:28:48 <jonaskoelker> good
11:28:56 <gwern> 'This battlestation will be quite operational'
11:29:04 <pumpkin> you can't even get it to say itself into an infinite loop :(
11:29:06 <jonaskoelker> how about last [1..]?
11:29:11 <jonaskoelker> > last [1..]
11:29:12 <pumpkin> > say "> \"say\""
11:29:14 <lambdabot>   > "say"
11:29:18 <gwern> > last [1..]
11:29:19 <pumpkin> jonaskoelker: it'll kill it
11:29:29 <jonaskoelker> ah
11:29:34 <pumpkin> in a few seconds
11:29:37 <lambdabot>   thread killed
11:29:37 <lambdabot>   thread killed
11:29:39 <jonaskoelker> :)
11:30:04 <jonaskoelker> :?
11:30:05 <pumpkin> lol
11:30:11 <gwern> hm. that's interesting.
11:30:16 <gwern> > last [1..]
11:30:17 <jonaskoelker> > last [1..]
11:30:29 <masklinn> lambdabot killers :(
11:30:31 <gwern> @botsnack
11:30:32 <lunabot>  :)
11:30:38 <lambdabot> :)
11:30:38 <pumpkin> maybe if you give it two simultaneous nonterminating tasks
11:30:41 <pumpkin> it'll die?
11:30:51 <gwern> > 2 + 2
11:31:02 <lambdabot>   4
11:31:11 <gwern> > last [1..]
11:31:13 <gwern> > last [1..]
11:31:13 <gwern> > last [1..]
11:31:14 <gwern> > last [1..]
11:31:14 <gwern> > last [1..]
11:31:22 <jonaskoelker> > 2 + 2
11:31:25 <pumpkin> > last [1..]
11:31:25 <jonaskoelker> tick tack...
11:31:40 <masklinn> > "laughter"
11:31:41 <pumpkin> if it isn't dead, it's working hard :P
11:31:48 <pumpkin> > say "slaughter"
11:32:12 <lambdabot>   thread killed
11:32:19 <int-e> murderers!
11:32:28 <masklinn> lambdabot isn't dead
11:32:29 <masklinn> yet
11:32:30 <gwern> int-e: the thread was never born
11:32:40 <masklinn> was the thread a lie?
11:32:55 <gwern> bots have a right to control their processes!
11:32:56 <pumpkin> gwern: its life began the moment I thought of what to ask it
11:32:57 <lambdabot>   thread killed
11:32:57 <lambdabot>   thread killed
11:33:01 <lambdabot>   thread killed
11:33:03 <lambdabot>   thread killed
11:33:18 <byorgey> gwern: it was useful to look at what people had done before, yes
11:33:30 <byorgey> gwern: although I didn't end up actually using any of the code
11:33:42 <gwern> fair enough
11:33:45 <gwern> > 2+2
11:33:45 <dons> interesting, http://www.reddit.com/r/programming/comments/7kxsi/comparing_code_coverage_tools_in_haskell_and_f/
11:33:57 <gwern> @botsnack
11:33:58 <lunabot>  :)
11:33:59 <pumpkin> has anyone written a regular expression enumerator?
11:34:20 <byorgey> I'm pretty sure that my library can handle most every permutation of split that has been proposed.
11:34:35 <gwern> (famous last words?)
11:34:38 <pumpkin> byorgey: is that a challenge?
11:34:43 <jonaskoelker> pumpkin: use a string enumerator and a parser ;)
11:35:13 <byorgey> although patches are of course welcome =)
11:35:28 <pumpkin> byorgey: can you do overlapping splits???
11:35:39 <pumpkin> overlapping by floor(pi / index)
11:36:12 <pumpkin> actually that wouldn't be very interesting
11:36:14 <byorgey> pumpkin: no.  has anyone seriously proposed that? =)
11:36:23 <pumpkin> byorgey: I just did!
11:36:25 <paggas> what does this mean? class X a b | a -> b where ...
11:36:27 * pumpkin laughs evilly
11:36:34 <byorgey> pumpkin: note I said "has been" ;)
11:36:49 <pumpkin> byorgey: I'd better see that in the next version then :D
11:36:56 <int-e> paggas:  the | a -> b is a functional dependency; it says that the type a uniquely identifies the type b
11:37:12 <byorgey> pumpkin: as for regular expression enumeration, see http://www.cs.dartmouth.edu/~mckeeman/cs118/assignments/nfa.ps
11:37:27 <byorgey> pumpkin: ok, send me a patch ;)
11:37:44 * byorgey goes to eat lunch
11:37:55 <paggas> int-e: nice :)
11:37:58 <pumpkin> mcilroy again :o
11:38:33 <pumpkin> THEY KILLED LAMBDABOT
11:38:53 <pizza_> YOU BASTARDS
11:38:59 <gwern> hm, I dunno what we can do about that. re-enabling rlimits might help
11:39:10 <gwern> each mueval is going to take x amount of resources, after all
11:39:20 <jeffwheeler> What is each matching-case of a 'case' called?
11:39:28 <Heffalump> an "alternative" normally
11:39:33 <jeffwheeler> That'll work; thanks.
11:41:30 <maltem> sometimes "branch", if you refer to the right-hand side
11:49:52 <jonaskoelker> are there any balanced binary search trees in the stdlib?
11:50:04 <jonaskoelker> (or a non-std ghc-and-hugs lib)?
11:51:32 <sjanssen> jonaskoelker: Data.Map is a size balanced binary search tree internally
11:51:44 <jonaskoelker> will do :)
11:53:12 <jonaskoelker> thanks
11:53:21 <trygvis> how does ghci search for its wired-in packages?
11:53:57 <MyCatVerbs> trygvis: have a look at the ghci executable =)
11:54:54 <MyCatVerbs> trygvis: it's a bash script that executes (something like) /usr/lib/ghc-version/ghc-version -B/usr/lib/ghc-version --interactive
11:55:04 <trygvis> hm, didn't give me much. I'm unable to compile anything: http://hpaste.org/13241
11:55:37 <trygvis> I assume it is trying to use /tmp/ghc/lib/ghc-6.8.3/package.conf, which is empty (contains "[]" only)
11:55:48 <MyCatVerbs> Yow, that's epic.
11:56:06 <MyCatVerbs> Did you manage to build GHC without any libraries or something? :)
11:56:28 <MyCatVerbs> (Or are you running it from a different place to what its configure --prefix makes it expect?)
11:56:32 <trygvis> hehe, you tell me. I got the binary build, did ./configure & make install
11:58:10 <redditbot> Comparing code coverage tools in Haskell and F#
11:58:10 <redditbot> String, string, how do I split thee? Brent Yorgey counts the ways
11:58:36 <trygvis> hm, installing it again gave me a better package.conf
11:59:23 <pumpkin> @hoogle mapMaybe
11:59:23 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
11:59:24 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
11:59:24 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
11:59:31 <pumpkin> ah, that's nice
12:00:46 <jonaskoelker> if I want to store lists in a Data.Set, but with a different comparison than the default (i.e. lexicographic), can I do this?  Can I override the Ord instantiation for [a] for the purpose of a single value/type?
12:00:53 <jonaskoelker> s/purpose/scope/, I think
12:02:23 <vixey> jonaskoelker, I think you use a newtype for that
12:02:46 <pumpkin> you could write a simple type that wraps a list, I guess, and define an ordering on that
12:03:07 <jonaskoelker> vixey: that's something like defining subclass that doesn't override anything, except there's no sub/supertype relation between the two?
12:03:14 <jonaskoelker> kinda-sorta?
12:03:27 <vixey> idk.........
12:03:48 <jonaskoelker> vixey: it's "more" than typedef, in that it's not just a new name for the same type, correct?
12:03:58 <vixey> no typedef is a C thing
12:04:14 <jonaskoelker> and it's spelled "type" in haskell, right?
12:04:20 <vixey> no I'm talking about newtype
12:04:37 <klinkers> is there a haskell-implementation that runs on the JVM? would it be hard to implment haskell for the jvm?
12:04:42 <vixey> for example
12:04:48 <vixey> newtype Scope a = Scope a
12:04:49 <jonaskoelker> vixey: I know.  I'm saying that "type" is roughly "typedef", and "newtype" is "more" than type
12:06:01 <vixey> what's better of  State (a,b)  or  StateT a (State b ...?
12:06:31 <jonaskoelker> wait, what??  "newtype Scope a = Scope a"?
12:06:35 <jonaskoelker> my brain just asplode
12:06:47 <vixey> hehe
12:06:56 <pumpkin> the first one is the name of the type, the second of the constructor
12:06:56 <sinelaw> asplode?
12:06:58 <pumpkin> they can be the same
12:07:17 <jonaskoelker> ah
12:08:50 <b_jonas> type (a,b) = (a,b) deriving *;
12:09:49 <ski_> (vixey : depends, i think)
12:09:58 <vixey> type Infer a = StateT Constraints (StateT Integer (ErrorT String Identity)) a
12:10:03 <vixey> I'm going with that for the moment I guess
12:10:51 <ski_> you'll have to use `lift' (or raw `StateT' data constructor), though
12:11:46 * ski_ thinks one should be ablw to do something like `StateT (?x :: X) (StateT (?y :: Y) (...)) a'
12:12:35 <b_jonas> doesn't ? only work together iwht -> in a type?
12:13:04 <vixey> what for ski?
12:13:44 <ski_> to avoid using peano numerals for accessing the right "level"
12:14:24 <ski_> instead of `get',`lift get',`lift (lift get)' you should be able to use labels. somehow
12:14:29 <vixey> oh right
12:14:50 <ski_> (of course it shouldn't be limited to state monad (transformer))
12:15:09 <klinkers> is there a haskell-implementation that runs on the JVM? would it be hard to implment haskell for the jvm?
12:16:35 <b_jonas> depends on how efficent you want
12:20:12 <boegel> does anyone know if a somewhat generic implementation of a genetic algorithm has been implemented in GA?
12:21:07 <sjanssen> ski_: I've tried to do something like that with newtypes as the labels
12:21:11 <sjanssen> ski_: but it didn't work out
12:25:36 <suspect43> hi, i'm having problems getting parsec to work. for some reason it wasn't in the ghc installation; i did a manual install from source, and now my program compiles but gives horrible link errors. i'm on Ubuntu 8.10. any suggestions?
12:26:18 <abbe> suspect43, from delhi ?
12:26:42 <suspect43> ?? yes, incidentally. how'd you know?
12:26:42 <lambdabot> Plugin `compose' failed with: Unknown command: ""
12:26:46 <klinkers> boegel: GA?
12:27:26 * abbe also hacks in delhi :)
12:27:31 <klinkers> boegel: im doing geentic programming light in clojure(was gonna tyr in haskell but it seeemded i would have to write a lisp-interpreter first...)
12:27:40 <pumpkin> new delhi?
12:27:48 <suspect43> pumpkin: yes
12:27:52 <pumpkin> ah ok
12:28:00 <abbe> pumpkin, east delhi to be precise :)
12:28:05 <suspect43> abbe: but how'd you know?
12:28:10 <pumpkin> ah ok :)
12:28:16 <abbe> suspect43, your IPv4 address
12:28:24 <abbe> leaks it
12:28:29 <suspect43> ah. awesome. so, how do i fix this?
12:29:12 <abbe> get a cloak, move to some IPv6 tunnel, or use tor :)
12:29:27 <klinkers> boegel: im doing geentic programming light in clojure(was gonna tyr in haskell but it seeemded i would have to write a lisp-interpreter first...)
12:29:29 <klinkers> boegel: im doing geentic programming light in clojure(was gonna tyr in haskell but it seeemded i would have to write a lisp-interpreter first...)
12:29:32 <suspect43> :) no, i meant the parsec errors
12:29:36 <klinkers> is there a haskell-implementation that runs on the JVM? would it be hard to implment haskell for the jvm?
12:29:36 <Taejo> @pl \a b c -> a (b c)
12:29:36 <lambdabot> (.)
12:29:44 <Taejo> d'oh
12:30:35 <abbe> suspect43, i'm not a haskell expert, may be you should paste your errors somewhere
12:30:50 <dons> ?passste
12:30:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:31:22 <eu-prleu-peupeu> (.)(.)
12:31:32 <suspect43> http://hpaste.org/13242
12:34:00 <abbe> suspect43, how're you trying to compile it ?
12:34:09 <Laney> z
12:34:19 <dons> ?users
12:34:19 <lambdabot> Maximum users seen in #haskell: 568, currently: 557 (98.1%), active: 16 (2.9%)
12:35:10 <Taejo> > fix id
12:35:14 <lambdabot>   * Exception: stack overflow
12:35:14 <dons> gwern: ok. i see. that wiki link thing might work
12:36:16 <suspect43> um, ghc source.hs
12:36:24 <suspect43> what should i be doing?
12:36:58 <abbe> suspect43, ghc --make -o output input.hs
12:37:38 <Deewiant> where -o output can be left out if you're happy with input[.exe]
12:37:47 <suspect43> oo
12:37:54 <suspect43> worked. thanks!
12:38:54 <dons> and if you'r eusing ghc , I always add -O2
12:38:56 <dons> since i like fast code.
12:39:06 <cpfr_> hey why is a function like: let foo [] = 0; foo [a] = 1 + foo a, bad
12:40:25 <Deewiant> cpfr_: '[a]' matches a single-element list and calls the element of that list 'a'
12:40:25 <pumpkin> eww fast code
12:40:49 <abbe> cpfr_, if you're trying to calculate length, use foo [] = 0; foo (x:xs) 1 + foo xs
12:40:59 <Deewiant> cpfr_: which in itself is fine although you'll find that calling foo with any longer list will crash since it doesn't match
12:41:02 <cpfr_> abbe, im trying to calculate depth
12:41:13 <abbe> cpfr_, oh, i'm sorry.
12:41:38 <b_jonas> doesn't match what?
12:41:44 <cpfr_> and i get an occurs infinite type error
12:41:45 <Deewiant> cpfr_: the actual problem here is that the type of [a] and a are different, so you can't call foo with both
12:41:46 <abbe> cpfr_, foo [[2]] = 1 + foo [2] = 1 + 1 + foo 2
12:41:46 <b_jonas> do you mean a stack overflow?
12:42:04 <abbe> cpfr_, but 2 is not defined for non-array element
12:42:10 <Deewiant> b_jonas: no, I mean it won't match since the only two alternatives are [] and [_]
12:42:12 <abbe> s/2/foo/
12:42:17 <b_jonas> oh
12:42:18 <b_jonas> I see
12:42:19 <abbe> s/element/argument/
12:42:27 <chrisdone> record wild cards are awesome‚ù§‚ô•
12:42:35 <vixey> depth of what?
12:43:53 <Deewiant> cpfr_: in general, the problem you have cannot be solved: the depth of a list is a compile-time constant - [a], [[a]], [[[a]]], etc.
12:43:59 <litb> > seq (1+2) (1+2+3)
12:44:00 <lambdabot>   6
12:44:02 <litb> hmm
12:44:18 <Deewiant> cpfr_: now, if you're willing to move away from basic lists, that's another matter.
12:44:18 <b_jonas> > foldl' (const . succ) 0 "hello"
12:44:20 <lambdabot>   5
12:44:29 <augustss> chrisdone: :)
12:45:07 <cpfr_> Deewiant, i just thought this basic operation would work on the basic lists
12:45:37 <sjanssen> cpfr_: you can write something like this using type classes, but it is a bit tricky, and probably not worth the effort
12:45:48 <cpfr_> oh
12:45:51 <b_jonas> sjanssen: are you sure you can write it?
12:45:52 <Deewiant> cpfr_: The problem is, how would the function know where to stop?
12:46:08 <cpfr_> when element inside was a []
12:46:09 <b_jonas> @unpl const . succ
12:46:10 <lambdabot> (\ d _ -> succ d)
12:46:11 <litb> b_jonas: oh that's neat
12:46:14 <Deewiant> cpfr_: foo [2] -> 1 + foo 2   <--- type error, 2 and [2] are of different types
12:46:20 <sjanssen> b_jonas: yes, with some caveats
12:46:23 <cpfr_> so foo [] = 0; foo [[]] = 1, etc
12:46:24 <b_jonas> @pl (\ d _ -> succ d)
12:46:25 <lambdabot> const . succ
12:46:38 <sjanssen> what is this supposed to calculate, the depth of the list?
12:46:45 <Deewiant> sjanssen: yep
12:46:48 <cpfr_> sjanssen, yes
12:46:49 <sjanssen> yep, we can do that
12:46:52 * sjanssen hacks
12:46:53 <litb> i understand the first yields a (const 1) . but seq evaluates it to 1 and then foldl' goes along. rite?
12:46:55 <b_jonas> no we can't
12:47:11 <b_jonas> really
12:47:20 <abbe> cpfr_, the foo [[1]] = 1 + foo [1] = 1 + foo 1, but 1 is not array so ?
12:47:42 <b_jonas> you can do it if you fix the type at the bottom (eg. Integer) but not otherwise
12:47:42 <abbe> cpfr_, s/1 + foo 1/2 + foo 1/g
12:47:53 <sjanssen> b_jonas: right, that is the caveat
12:48:01 <b_jonas> I see
12:48:02 <sjanssen> you have to rely on a set of "ground" types
12:48:14 <b_jonas> and of course it doesn't have much point anyway
12:48:32 <cpfr_> well this is a limited form of depth
12:48:53 <b_jonas> maybe it could have some point
12:49:07 <b_jonas> with that unwhatsit whatsit thing
12:49:53 <vixey> cpfr, depth of what?
12:51:19 <b\6> http://hpaste.org/13243 cabal/haddock problem.
12:52:09 <b_jonas> b\6: ooch
12:53:07 <pumpkin> wow, that RWH in japanese thing is cool
12:53:39 <sjanssen> cpfr_: http://hpaste.org/13244
12:54:34 <sjanssen> cpfr_: despite this being an interesting hack, it really isn't very useful
12:54:47 <sjanssen> the depth of a list is always a compile-time constant
12:55:08 <litb> > foldl (const . succ) 0 "hello"
12:55:09 <lambdabot>   5
12:55:23 <gwern> pumpkin: you know japanese?
12:55:40 <pumpkin> gwern: not well enough to read a technical book in it :P
12:56:00 <b_jonas> well, I still think foldl' is the right fold to use there
12:56:02 <b_jonas> but I could be wrong
12:56:10 <gwern> so it's just the general idea of translating RWH you find cool
12:56:16 <pumpkin> yup :)
12:56:32 <b_jonas> > foldl (const . succ) 0 (replicate (10^7) ())
12:56:37 <lambdabot>   * Exception: stack overflow
12:56:37 <b_jonas> > foldl' (const . succ) 0 (replicate (10^7) ())
12:56:39 <gwern> pumpkin: fair enough. and to think that would've been impossible if not for the CC license
12:56:40 <lambdabot>   10000000
12:56:41 <b_jonas> > foldr (const . succ) 0 (replicate (10^7) ())
12:56:43 <lambdabot>       No instance for (Num ())
12:56:43 <lambdabot>        arising from the literal `0' at <intera...
12:56:47 <pumpkin> yeah
12:56:57 <b_jonas> > foldr (flip const . succ) 0 (replicate (10^7) ())
12:56:59 <lambdabot>   0
12:57:17 <b_jonas> > foldr (const succ) 0 (replicate (10^7) ())
12:57:19 <lambdabot>   * Exception: stack overflow
12:57:23 <b_jonas> > foldr (const succ) 0 (replicate (10^3) ())
12:57:25 <lambdabot>   1000
12:57:56 <paggas> is this legal? class X a b c | c -> b -> a where ...
12:58:04 <dons> there's other efforts underway too, both CC and conventional.
12:58:10 <redditbot> Abesto's techie stuff: Learning Haskell
12:58:10 <redditbot> Two FP language books make Jolt Award "Best Technical Book" finalists
13:01:59 <m3ga> "undefined reference to containerszm0zi1zi0zi1_DataziMap_zdf2_closure" : what do I need to link?
13:02:06 <dons> --make
13:02:31 <m3ga> thanks dons
13:03:30 <gwern> @quote fuzzy
13:03:31 <lambdabot> Botje says: fuzzy feelings aren't always aerodynamic, unfortunately.
13:03:35 <gwern> @quote fuzzy
13:03:36 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
13:03:41 <gwern> @quote fuzzy
13:03:42 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
13:03:53 <gwern> @remember PaulJohnson A paradox of the Haskell world is that, while the language is Vulcan, the community around it is dominated by Warm Fuzziness.  Clearly the two are not mutually exclusive.
13:03:54 <lambdabot> Done.
13:04:00 <gwern> @quote vulcan
13:04:00 <lambdabot> PaulJohnson says: A paradox of the Haskell world is that, while the language is Vulcan, the community around it is dominated by Warm Fuzziness.  Clearly the two are not mutually exclusive.
13:04:17 <gwern> @flush
13:04:26 <cpfr_> @quote fuzzy
13:04:26 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
13:04:39 <gwern> cpfr_: note the 'y'
13:04:47 <cpfr_> @quote fuzz
13:04:47 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
13:04:55 <cpfr_> @quote fuzzi
13:04:55 <lambdabot> PaulJohnson says: A paradox of the Haskell world is that, while the language is Vulcan, the community around it is dominated by Warm Fuzziness.  Clearly the two are not mutually exclusive.
13:05:41 <litb> @quote litb
13:05:41 <lambdabot> No quotes match. My mind is going. I can feel it.
13:05:43 <litb> -.-
13:05:51 <gwern> @quote gwern
13:05:52 <lambdabot> gwern says: The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
13:06:54 <gwern> darn, cabal-install can't use http 4000. I gues the api changed
13:10:09 <dons> gwern: mm.
13:10:23 <dons> good idea to make it use 4.0
13:12:30 <PeakerWork> What's the fold/catamorphism of Data.Tree?
13:13:47 <adekoba> I know that Eiffel allows you to provide restrictions on arguments. What would be the best way to restrict input in Haskell? e.g., if I had a function that could only accept Int's from 0 to 100 ? Would I have it return an Either?
13:13:57 <PeakerWork> data Tree a = Node a [Tree a]        -- so cata would be:    (a -> [b] -> b) -> Tree a -> b ?
13:14:22 <pumpkin> adekoba: or a Maybe
13:14:35 <b\6> what can i do about ghc-6.10.1 requiring process-1.0.1.0 but other stuff like haddock requiring process-1.0.1.1?
13:14:38 <pumpkin> but there's no built-in way to restrict, other than a guard or an if
13:14:40 <vixey> PeakerWork, it's a interesting thing when you have functors inside functors...
13:14:48 <adekoba> pumpkin: that's the accepted method, yeah?
13:15:07 <PeakerWork> vixey: what do you mena?
13:15:16 <vixey> PeakerWork, []
13:15:16 <pumpkin> adekoba: well many of the prelude functions just throw an error if you give it invalid input, but I wouldn't do that
13:15:19 <vixey> in this case
13:15:21 <pumpkin> > head []
13:15:22 <lambdabot>   * Exception: Prelude.head: empty list
13:15:34 <dons> adekoba: via smart constructors is easiest.
13:15:49 <PeakerWork> vixey: hmm.. separating the list fold is more useful, isn't it?
13:15:52 <dons> adekoba: http://www.haskell.org/haskellwiki/Smart_constructors
13:15:59 <dons> you can also do it entirely statically
13:16:18 <dons> but you still need to construct a witness that the data is in bounds
13:17:02 <adekoba> oh, neat. Hadn't known about this.
13:17:12 <adekoba> thanks.
13:21:07 <PeakerWork> its fun that with Maybes, I end up never pattern matching Nothing, and always binding or fmapping them :)
13:25:20 <PeakerWork> Hmm, I have a tree where only the leafs have values -- is it a great sin to use a Tree.Tree anyway, and ignore the values in the branches? Or should I define my own structure for that?
13:26:13 <wli> I'd define my own structure.
13:26:30 <PeakerWork> thanks, I think I will too
13:26:51 <wli> I wish ghci could do decls like hbi.
13:27:03 <dons> wli: would you like to make a feature request?
13:27:07 <wli> (or SML/NJ's repl)
13:27:09 <dons> and point to the reference implementation?
13:27:26 <dons> i think if we just showed a few people how hbi worked, we might make progress.
13:27:31 <wli> dons: AIUI doing data decls at the repl is a longstanding one.
13:27:57 <dons> yes, but if people knew that hbi did it 20 years ago...
13:28:36 <pumpkin> how did hbi work?
13:29:00 <wli> I've been pointed to the code and made an abortive stab at implementing myself.
13:29:28 <wli> I lacked the necessary reconnoiter.
13:30:24 <wli> Heck, in SML/NJ you could hammer in whole modules at the repl.
13:31:47 <pumpkin> anyone played with http://www.cs.dartmouth.edu/~doug/powser.html ?
13:32:59 <dons> wli: yes, there's no goodish reason.
13:33:01 <klinkers> @quote SPJ
13:33:02 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial]: It's better than sex.
13:33:05 <dons> mutually recursion modules and bindings aside.
13:33:05 <klinkers> @quote SPJ
13:33:06 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
13:33:06 <lambdabot>  what you just said?"
13:33:17 <klinkers> @quote SPJ
13:33:17 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
13:33:22 <klinkers> @quote SPJ
13:33:22 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbies recruited in '07"
13:33:32 <klinkers> @quote SPJ
13:33:33 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
13:33:33 <lambdabot>  what you just said?"
13:33:41 <klinkers> @quote SPJ
13:33:42 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial]: It's better than sex.
13:34:05 <klinkers> would stewie griffin program in haskell if he programmed?
13:35:53 <PeakerWork> is there an alias for (Either String) ?
13:36:03 <PeakerWork> type Error a = Either String a ?
13:36:18 <thoughtpolice> dons: is there already a bug report on trac for this feature?
13:37:07 <dons> i don't think so
13:39:13 <klinkers> does hmatrix have svd?
13:41:02 * wli has been haskelling so long he's forgotten SML.
13:41:06 <pumpkin> what does default (Integer,Rational,Double) do?
13:41:20 <aconbere> is there something I'm missing in this type definition? (it tells me the type variable a is not in scope)
13:41:23 <aconbere> mag :: (Num a) => Vector -> a
13:41:26 <aconbere> mag x = sqrt $ dot x x
13:42:03 <byorgey> PeakerWork: no, there isn't
13:42:06 <pumpkin> shouldn't that be Floating?
13:42:10 <thoughtpolice> aconbere: if you take the type signature away, can the compiler infer it properly?
13:42:12 <dons> pumpkin: when a value must receive a monomorphic type (e.g. in a binding of some sort) it'll be defaulted to one from that set
13:42:18 <pumpkin> ah ok
13:42:23 <dons> :t sqrt
13:42:25 <lambdabot> forall a. (Floating a) => a -> a
13:42:26 <aconbere> thoughtpolice: probably, but I would have to do it to a bunch of funcs
13:42:39 <pumpkin> klinkers: http://hackage.haskell.org/packages/archive/hmatrix/0.5.0.1/doc/html/Numeric-LinearAlgebra-Algorithms.html#3
13:43:18 <PeakerWork> byorgey: I think a bunch of Maybe -> Error and back convertors could be useful, so I can get a nice description of where something failed -- or easily change a Maybe computation to an Either computation for that purpose
13:43:41 <PeakerWork> or maybe not, it turned out my computation did succeed so I don't need it for now :)
13:44:11 <PeakerWork> can one define shows in a Show instance, or only show/showsPrec ?
13:44:27 <PeakerWork> I am not sure what to do with the precedence in showsPrec
13:45:23 <wli> pumpkin: I'd like to do up a bunch of linear algebra algorithms from the ground up in Haskell, and furthermore with sparse matrix support.
13:45:40 <pumpkin> wli: mmm me too
13:45:51 <pumpkin> like a BLAS/LAPACK + more in pure haskell
13:46:03 <pumpkin> sounds like a lot of work though
13:46:14 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas ?
13:46:21 <dons> i started on the 'statistics-fusion' lib doing super simple things with uvectors
13:46:24 <dons> you could extend that.
13:46:37 <pumpkin> thoughtpolice: that's a FFI one isn't it?
13:47:25 <bos> it would make most sense to write a fused version of the LAPACK and BLAS bindings.
13:47:37 <thoughtpolice> i think so
13:47:54 <pumpkin> my main complaint with BLAS and LAPACK are their horrible (if regular) naming convention
13:47:56 <bos> as in, leave the native fortran code untouched, and just write Haskell wrappers.
13:48:14 <pumpkin> bos: those already exist
13:48:22 <pumpkin> I thought
13:48:24 <wli> pumpkin: I can't figure out a decent set of data structures for fast search on sparse matrices to support mat/vec and mat/mat multiplies and (worse yet) additions.
13:48:29 <bos> pumpkin: they live in the ST monad, which is precisely what i'd like to avoid.
13:48:33 <pumpkin> ah
13:48:54 <wli> bos: I need the polymorphism to do it symbolically (e.g. in Q(2^(1/2)))
13:48:59 <bos> the idea behind a fused version of the library is that you'd get pure bindings that wouldn't do any copying behind the scenes.
13:49:09 <pumpkin> ah
13:49:21 <pumpkin> that would be nice, and we wouldn't have to preserve the ugly names either
13:49:29 <pumpkin> although some might want to :o
13:49:35 <bos> this is a path that has been well trodden by the likes of dons and others by now.
13:49:55 <bos> the folk wisdom has accumulated to the point where it's not exactly routine, but can be done by someone fairly smart.
13:50:09 <dons> yeah, it isn't research now
13:50:14 <RayNbow> hmm, question... what is the usual Haskell naming convention for accumulator variables?
13:50:20 <dons> you can just pick up examples and start there.
13:50:25 <dons> RayNbow: 'a' ?
13:50:31 <dons> sometimes 'acc'
13:50:33 * wli has differing motives/etc.
13:50:48 <dons> RayNbow: they're equivalent to 'i' in a loop
13:50:54 <RayNbow> ah
13:50:59 * RayNbow used 'c' in a code example
13:51:34 <bos> wow, we have nearly as many reviews after 4 weeks on amazon as graham's book after 2 years.
13:51:38 <RayNbow> but 'acc' is probably better :p
13:51:48 <b_jonas> reasking same question as earlier,
13:51:54 <b_jonas> what XML library do you recommend?
13:51:54 <RayNbow> @go real world haskell site:amazon.com
13:51:55 <dons> bos: mm. hadn't thought about that. interesting.
13:51:57 <theclaw> hi
13:51:58 <lambdabot> http://www.amazon.com/Real-World-Haskell-Bryan-OSullivan/dp/0596514980
13:52:07 <dons> b_jonas: what is your task?
13:52:17 <dons> simple and quick? use the 'xml' lib. hard complex, use haxml
13:52:23 <pumpkin> omghax
13:52:35 <b_jonas> dons: parsing a short xml and getting the value of a couple of fields from it
13:52:46 <dons> ok. the 'xml' lib
13:53:22 <b_jonas> dons: also I need a way to catch error from malformed xml because sometimes the server gives such when an error happens, but I think all libraries have that
13:53:29 <b_jonas> I'll look at xml
13:53:37 <b_jonas> I currently looked at haxml
13:53:40 <b_jonas> but I don't really like it
13:53:53 <b_jonas> and I didn't know which of the other ten on hackage to look at
13:53:53 <b_jonas> thanks
13:54:10 <bos> i hope that andyjgill's book will cover some fun topics like CPS-converting monads.
13:54:26 <bos> there's an area that isn't well documented at all.
13:54:48 <dons> yeah, pick more things from the cloud of community knowledge
13:55:11 <Heffalump> andyjgill has a book?
13:55:13 <dons> i've been asked several times specifically about design idioms and patterns for structuring different sorts of haskell apps
13:55:20 <dons> someone should put those together in a pleasant format
13:55:22 <Heffalump> we really need a book on functional design patterns
13:55:30 <dons> what Heffalump said :)
13:55:44 <Raevel> i'd buy that book
13:55:58 <dons> well, there's a market for FP books.
13:56:09 <wli> pumpkin: Want to pick a matrix structure that can handle blocks, bands, and borders, and do some LU and/or QR on them?
13:56:11 <b_jonas> in http://hackage.haskell.org/packages/archive/xml/1.3.3/doc/html/Text-XML-Light.html why does hackage write the (,) tycon in prefix form instead of shorthand form?
13:56:16 <Raevel> dons: i got my rwh yesterday, by the way, EXCITED
13:56:25 <RayNbow> dons, bos: do you already have any insights in the RWH sales? (any figures?)
13:56:30 <dons> Raevel: yay!
13:56:45 <dons> RayNbow: far above expectations
13:56:54 <Heffalump> whose expectations?
13:57:07 <pumpkin> wli: I have almost no sparse matrix experience :P not sure you want to be asking me :) I'd like to have such a lib but am not much of an expert on the topic
13:57:08 <RayNbow> dons: that either means that it's a good book or that your expectations are too low :p
13:57:17 <RayNbow> *were too low
13:57:29 <dons> oreilly's (and ours, to some degree)
13:58:01 <b_jonas> sparse matrices are hard
13:58:11 <redditbot> Initial performance numbers for the new bytestring-based HTTP 4 library
13:58:11 <redditbot> Creative Commons in action: Real World Haskell being translated into Japanese!
13:58:14 <Raevel> oh, and read on ltu about the jolt nomination, congratulations
13:58:27 <wli> pumpkin: They're dumb. Just use some data structure (e.g. interval search trees, hash tables, etc.) instead of flat arrays and then do the usual things in such a way as to avoid filling up things with huge numbers of nonzero entries.
13:58:42 <Raevel> (if winning jolt is worth anything...?)
13:58:55 <bos> RayNbow: we've hit 50% of the number of sales that o'reilly thought would be a good number for us to total over the lifetime of the book, but done so in the first 4 weeks of sales.
13:59:28 <RayNbow> bos: nice :)
14:00:16 <wli> pumpkin: data Matrix = Block ... | Band ... | VertBorder ... | HorzBorder ... | NestedMatrix ... etc. Then just poke at array indices in mostly the usual way.
14:01:12 <wli> pumpkin: (THe difference being that you skip over places where you know it's all 0 etc.)
14:01:13 <bos> woo, haskell.reddit.com now has more than 2.25% the number of subscribers that proggit has!
14:01:40 <PeakerWork> b_jonas: I am currently parsing with Text.XML.Light
14:01:53 <PeakerWork> b_jonas: I like it.. I didn't understand HaXML though
14:02:01 <PeakerWork> (Found no simple/working examples)
14:02:21 <dons> bos, oh, interesting stat.
14:02:40 <PeakerWork> oh, xml is Text.XML.Light, didn't know that :)
14:02:50 <macondo> @src isPrefixOf
14:02:50 <lambdabot> isPrefixOf [] _          = True
14:02:50 <lambdabot> isPrefixOf _  []         = False
14:02:50 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
14:03:25 <wli> pumpkin: Let's say you've got a sparse vector times a block matrix. Go over the sub-indices of the vector corresponding to the blocks, do regular i-th row times j-th column bits, recover the vector's sparseness on the RHS, etc.
14:03:27 <macondo> great
14:03:40 <macondo> I have to grease my haskell gears again
14:04:54 <wli> pumpkin: Matrix/matrix multiplies of block matrices are just pretending that the whole matrices inside the blocks are matrix entries (at least where the granularities line up), etc.
14:05:15 <pumpkin> wli: seems neat
14:05:35 <b_jonas> so in Text.XML.Light too, you have to pass a decoded character string to parseXMLDoc, it won't infer encoding from a byte string, right?
14:06:24 <wli> For what I'm interested in, I end up with block matrices where inside the blocks they're symmetric and skew diagonal (a.k.a. diagonal along the wrong diagonal).
14:06:59 <b_jonas> how about a quadtree?
14:07:30 <b_jonas> where you mark all-zero squares as such and divide not all-zero squares to smaller squares unless they're already of size 1
14:07:36 <klinkers> hmm i really like haskell and a lot of its features but im just more productive in clojure and python. you think that will change if i stick with haskell on the side?
14:07:46 <wli> b_jonas: Plausible, though the flexibility with respect to things like diagonal bands is weird. My first thought was actually KDB trees.
14:08:03 <dons> klinkers: i'm surprised you're more productive in clojure. what's missing for you in haskell?
14:08:09 <klinkers> or lisp wins because worse is better?
14:08:19 <b_jonas> or you could just use band
14:08:22 <dons> klinkers: i mean, there's more libraries, faster code, bigger community , and more documentation.
14:08:31 <b_jonas> if your blocks aren't too large
14:08:39 <dons> so 'productivity' comes down to your familiarity?
14:08:42 <wli> b_jonas: OTOH given that the lengths of the skew diagonal bands within blocks are tiny, I might just punt and treat them like blocks.
14:08:49 <dons> or are there resources you're missing?
14:10:21 <b_jonas> isn't band better than block?
14:10:36 <b_jonas> or symmetric band
14:10:55 <wli> b_jonas: The bands are only within blocks.
14:11:14 <dons> klinkers: ?
14:12:15 <wli> b_jonas: So there will be a symmetric (and "persymmetric") block within which there is a skew diagonal.
14:12:45 <klinkers> and a  lot of the libs i find hard to use. some are easy and very good but take webapps for example. happs i couldnt even get up and running on windows.
14:13:25 <pumpkin> is the windows bit supposed to make it sound easier? :P
14:14:00 <wli> b_jonas: These basically describe the quadratic components of the system. The linear part of the system consists of blocks (triangular depending on how I do them).
14:15:37 <b_jonas> but if all the blocks are small, then the whole matrix is a band matrix
14:16:18 <b_jonas> lapack has symmetric band matrices (DSY)
14:16:25 <b_jonas> can divide them
14:17:32 <wli> Yeah. The linear part is bands-within-blocks. The quadratic components are just one tiny skew diagonal affair each (since they're simultaneous homogeneous quadratic equations and never have overlapping monomial they don't really add up).
14:17:54 <b_jonas> and blas/gsl can apparently has support for them as well
14:17:55 <wli> Er, blocks-within-bands.
14:18:02 <b_jonas> symmetric band one that is
14:18:19 <wli> b_jonas: LAPACK doesn't support number field arithmetic.
14:18:33 <wli> (or arbitrary-precision rational arithmetic)
14:18:40 <b_jonas> yeah
14:18:43 <b_jonas> do you need that?
14:18:51 <b_jonas> you mean arithmetic over GF(q)?
14:19:41 <wli> b_jonas: Q(2^(1/2)) and similar. It's for Grobner basis -type stuff with a problem-specialized elimination order.
14:20:12 <b_jonas> Q(2^(1/2)) of bigints?
14:20:12 <b_jonas> I see
14:21:04 <wli> Q = rational numbers (arbitrary precision), 2^(1/2) is the square root of 2 represented symbolically like a + b*2^(1/2) as (a, b) :: (Rational, Rational)
14:21:19 <b_jonas> yep
14:21:35 <b_jonas> and you want to compute exactly over those
14:21:38 <b_jonas> well yeah
14:21:45 <b_jonas> lapack is definitely not for that kind of thing
14:21:59 <b_jonas> it's optimized for little numerical errors with floating-point numbers
14:22:14 <wli> IOW I need polymorphic linear algebra.
14:22:34 <b_jonas> maybe look at one of those algebra programs: GAP or Magma
14:23:19 <C-Keen> hm, if I want to draw some raster graphics, which haskell lib would I need to use?
14:23:20 <b_jonas> GAP definitely handles expressions like that
14:23:29 <wli> They barf on the problem sizes of the systems because all they can do is the generic Grobner vs. the specialized elimination order.
14:23:44 <b_jonas> but I'm not sure if it likes band matrices
14:24:06 <wli> The sparseness may also be an issue.
14:25:02 <pumpkin> :t genericLength
14:25:03 <lambdabot> forall b i. (Num i) => [b] -> i
14:25:08 <b_jonas> yeah, I thing gap doesn't have sparse matrices
14:25:14 <pumpkin> bahh, standard length's Int-ness just bit me on a long computation
14:25:15 <b_jonas> or band or similar
14:25:24 <b_jonas> but I coulld be wrong, there are lots of user libraries for GAP after all
14:25:32 <b_jonas> it's quite programmable
14:25:32 <wli> I presumed it was generic Grobner exploding since using the matrices directly is already something that uses specialized knowledge of reducing the problem to linear algebra.
14:28:50 <b_jonas> according to google, Magma has sparse matrices
14:29:15 <wli> I tried Maple and Mathematica, not Magma.
14:29:32 <wli> And that not by means of the linear algebraic formulation.
14:29:58 <b_jonas> well, if you have licenses for that, maple and mathematica might work
14:30:10 <b_jonas> they do have sparse matrices and handle algebraic expressions
14:30:43 <b_jonas> mathematica is quite powerful
14:31:21 <wli> I do have a use for the results, though.
14:33:23 <bos> @seen juhp
14:33:23 <lambdabot> juhp is in #ghc and #haskell. I don't know when juhp last spoke.
14:35:57 <C-Keen> @hoogle a -> [a] -> [Int]
14:35:58 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
14:35:58 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:35:58 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:35:58 <wli> It's not a one-shot deal like a CAS would be best for. General programming language affairs crop up in my uses. The polymorphic sparse linear algebra also has other uses for me, e.g. linear algebra over rings lacking division (pure integers, polynomials, more).
14:37:34 <Chile`> mathematica supports functional programming quite well, & depending on who your audience is may be standard enough
14:37:52 <b_jonas> I don't know because I don't have much practice with these kinds of things
14:38:18 <b_jonas> I inverted a 120x120 GF(2) matrix with gap once and that's about it
14:38:53 <b_jonas> and I once attempted to do calculations with arbitary quadratic irrationals but it didn't work well
14:41:40 <klinkers> how much bette ris matlab on linear algebra stuff than the haskell libs? do most linear algebra package suse the lapack blas etc so they are equally fast?
14:42:02 <wli> b_jonas: Neither do I, which is part of why I'm failing.
14:42:35 <gwern> it's amazing how 'fail' has bcome normal jargon
14:42:54 <pumpkin> klinkers: matlab's pretty concise at matrix operations
14:43:00 <pumpkin> just in terms of syntax
14:43:21 <b_jonas> klinkers: blas is supposed to be fast but it isn't becaues it doesn't have optimized implementations for modern processors
14:43:35 <b_jonas> still it has a good interface so you could hope there'll be a good implementation once
14:43:54 <b_jonas> or you can hope that the compiler does wonders
14:43:56 <vixey> what's the most pedantic warning settings?
14:43:59 <ehird> > let oko = "o" : map ("ok" ++) oko in oko
14:44:00 <lambdabot>   ["o","oko","okoko","okokoko","okokokoko","okokokokoko","okokokokokoko","oko...
14:44:10 <vixey> for ghci
14:44:11 <pumpkin> > scanl1 (*) [1..]
14:44:12 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
14:44:21 <b_jonas> sokoban?
14:44:23 <klinkers> so since haskell makes multicore programming easy could it perhaps be easy to make faster math code in haskell soon?
14:44:30 <pumpkin> ehird: you could do that with a fix too I think
14:44:31 <b_jonas> klinkers: no
14:44:35 <ehird> pumpkin: Yes. :-)
14:44:43 <klinkers> b_jonas: why not?
14:44:46 <b_jonas> klinkers: multicore can be at most 4x or 8x speedip
14:44:48 <pumpkin> > fix ('o':'k':]
14:44:49 <lambdabot>   <no location info>: parse error on input `]'
14:44:54 <pumpkin> > fix ('o':'k':)
14:44:55 <lambdabot>       The operator `:' [infixr 5] of a section
14:44:55 <lambdabot>          must have lower prece...
14:44:57 <pumpkin> boo
14:45:02 <Cale> b_jonas: Are you sure?
14:45:05 <vixey> > fix ("ok"++)
14:45:06 <lambdabot>   "okokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokok...
14:45:13 <klinkers> b:jonas, and c-code is much faster than that?
14:45:16 <b_jonas> that doesn't compensate for knowing the cpu very well
14:45:21 <Cale> There are linear algebra tasks for large matrices which parallelise wonderfully.
14:45:31 <pumpkin> > iterate ("ok" ++) "o"
14:45:35 <lambdabot>   ["o","oko","okoko","okokoko","okokokoko","okokokokoko","okokokokokoko","oko...
14:45:51 <b_jonas> Cale: they do but not on current computers which only have at most 4 or 8 cores typically
14:45:53 <wli> Various big linear algebra problems get 300+x speedups on 4096 CPU's.
14:45:59 <Cale> b_jonas: Not for long :)
14:46:24 <wli> b_jonas; There are current computers with 4096 (probably more by now) cores.
14:46:26 <b_jonas> and I think it's exactly numeric code where a good compiler and a high-level language helps a lot in performace
14:46:26 <klinkers> b_jonas: yes but i was asking in the future when you have 64 cores...
14:46:33 <b_jonas> wli: yeah, there are...
14:46:43 <klinkers> your answer sounded like the speedup itslef was limited to 8x even with 64 cores
14:46:52 <b_jonas> klinkers: oh, lots of other things would change till that
14:46:56 <b_jonas> not just the number of corse
14:47:10 <klinkers> 4096 as in 4thousand 96?
14:47:25 <Cale> klinkers: I think Haskell is wonderfully positioned (at least compared to the competition) to take advantage of SMP.
14:47:29 <Cale> klinkers: yeah
14:47:30 <wli> klinkers: Yeah.
14:48:02 <wli> I wrote my kernel/profile.c bit for the benefit of such, though the test machine used for kernel patch submission was only 512 cores.
14:48:13 <conal> does anyone know how to express disjunction of quickcheck properties?
14:48:15 <Cale> Data Parallel Haskell is the closest thing to being a reasonable programming model for large numbers of cores.
14:48:17 <b_jonas> well, this is just my opinion, I'm not really an expert in these kinds of fields so there's no reason to believe my guesses
14:50:20 <dons> Cale: i think `par` also makes sense as a model. maybe. with enough strategies
14:50:48 <wli> Autoparallelization is the way to go IMHO.
14:51:12 <dons> well, that's what DPH is. a subset that is auto-parallelisable
14:51:41 <dons> ?users
14:51:41 <lambdabot> Maximum users seen in #haskell: 568, currently: 550 (96.8%), active: 16 (2.9%)
14:51:44 <Cale> dons: The trouble with par is that you need a way to know where the parallelising should stop and turn into a serial computation so you don't waste more time sparking things.
14:52:03 <Cale> It almost works though...
14:52:32 <Cale> Maybe with a better scheduler, or more static analysis.
14:52:48 <dons> yep
14:53:39 <klinkers> so the reason it doesnt autoparallellize(because it could do that right for pure functions?) is that there will be overhead for simple functions?
14:54:16 <wli> Curiously, full abstraction vaguely requires parallelism and/or concurrency.
14:54:17 <klinkers> couldm you turn on automatic parallellisation in the comiler perhaps? ghc -O2 -autopar fname.hs ?
14:54:40 <Cale> conal: Hmm, Property values don't seem very composable.
14:55:02 <Cale> klinkers: The trouble is determining which computations are worth parallelising.
14:55:07 <wli> Basically for pattern matching of multiple arguments at one time.
14:55:10 <klinkers> full abstraction?
14:55:25 <Cale> klinkers: It's very hard (impossible) for a compiler to tell how long a computation will take to run without running it.
14:55:37 <wli> klinker: The full equivalence of operational and denotational semantics.
14:55:47 <dons> klugez: right. there is too much parallelism by default
14:55:55 <dons> klinkers: for the current hardware
14:56:07 <dons> so we have to reduce the amount, which is where it gets hard to decide statically
14:56:41 <b_jonas> @src unwords
14:56:42 <lambdabot> unwords [] = ""
14:56:42 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
14:56:48 <klinkers> couldm you turn on automatic parallellisation in the comiler perhaps? ghc -O2 -autopar fname.hs ?
14:57:07 <wli> My point here was actually that parallelism can in certain ways regularize the language semantics in ways that may enable further program analysis.
14:57:40 <Cale> It would be interesting to see if with a million cores or something, the need to decide how to break up computations goes away... I still feel that without a change in the architecture of the machine (something like the reduceron perhaps), there will be too much overhead associated with just parallelising every expression.
14:58:12 <redditbot> /r/Haskell, recommend me a book! Note: I didn't like RWH.
14:59:50 <wli> Full abstraction affects some weirdness surrounding strictness, nontermination, and something to do with order of arguments or otherwise "denotationally equivalent expressions."
14:59:53 <Cale> klinkers: I think DPH makes a decent compromise between automatic and programmer supplied annotations.
15:00:45 <Cale> klinkers: Have you seen much about it?
15:01:10 <Cale> klinkers: The basic idea is that you have a new datatype, called the parallel array, and computations on these arrays are parallelised automatically.
15:02:11 <Cale> Parallel array computations can even make use of other parallel array computations, and the compiler will flatten them out, and ensure that each processor gets a fair share of the work.
15:04:57 <wli> case (x, y) of { (True, _) -> True ; (_, True) -> True ; (False, False) -> False } is the canonical example. Where x or y are nonterminating i.e. _|_ a.k.a. "bottom" if the other is true, the "parallel or" or "parallel case" recovers the full abstraction.
15:05:40 <_andre> lift $ unsafeFreeze a
15:05:47 <_andre> oops, wrong window
15:06:27 <pumpkin> :o
15:06:32 <Badger> o:
15:06:54 <wli> Suddenly a lot of strictness analysis for things to stay _|_ when optimized or not to become _|_ when optimized goes away with full abstraction in hand.
15:12:03 <nolrai_East> :t maybeT
15:12:04 <lambdabot> Not in scope: `maybeT'
15:12:39 <vixey> :k MaybeT
15:12:40 <lambdabot> Not in scope: type constructor or class `MaybeT'
15:15:00 <pumpkin> :k IO
15:15:01 <lambdabot> * -> *
15:15:08 <litb> it's Maybe
15:15:17 <pumpkin> there's a MaybeT too
15:15:20 <litb> oh
15:15:32 <pumpkin> :k Either
15:15:33 <lambdabot> * -> * -> *
15:15:35 <pumpkin> fun
15:15:39 <pumpkin> didn't know about :k
15:15:44 <litb> playing billard -.-
15:21:45 <conal> Cale: no, QC properties aren't composition-friendly. :(  someone gave me a cool trick for conjunction.
15:22:20 <dons> compositional properties eh?
15:22:21 <dons> mmm
15:24:57 <conal> do you know who's working on improving QC these days?
15:26:56 <dons> huh, cute. http://blogs.ijw.co.nz/chris/index.php/2008/12/language-suckiness-shootout/
15:27:06 <dons> 25x more "rocks" than "sucks" for haskell (best overall?)
15:27:10 <dons> conal: Andy mostly
15:27:39 <conal> dons: thanks.  i'll email him & koen, asking for ideas.
15:28:28 <_andre> http://hpaste.org/13240#a1
15:28:44 <_andre> i'm a bit lost there... what does "less polymorphic than expected" mean?
15:28:58 <vixey> it means you're using ST
15:29:06 <litb> hmm i see this channel doesn't grow anymore like back last years :p
15:29:28 <vixey> _andre, you have to be careful in ST with the hack they use
15:29:39 <vixey> :t runST
15:29:40 <lambdabot> forall a. (forall s. ST s a) -> a
15:29:48 <vixey> this forall s. is really important
15:30:07 <vixey> (I think it's so ST can use mutation internally but it is not observable externally)
15:30:16 <_andre> i actually don't know what it means
15:30:20 <vixey> forall a s. (ST s a) -> a
15:30:22 <vixey> is differen
15:30:41 <vixey> so if you want to run your ST computatin, it should have a type like
15:30:58 <vixey> foo :: a -> b  -> ... -> (forall s. ST x)
15:31:47 <augustss> vixey: but that forall is the same as a forall at the top level
15:32:21 <vixey> oh I meant, foo :: a -> b  -> ... -> (forall s. ST s x)
15:32:24 <vixey> is it still wrong?
15:32:41 <dons> augustss: do you know if the hbi interactive environment was written up anywhere?
15:33:02 <kniu> The Functional Pearl "Type Safe Patterns" (Rhiger 2008) shows a way to bypass Haskell's inbuilt pattern-matching facilities, and emulates pattern matching on pairs and numerical constants using nothing but plain functions.
15:33:24 <augustss> dons: not really.  It's the same idea as Small, which I did write up many years ago.  Published in BIT, I think.
15:33:29 <kniu> The paper, however, uses the functions "fst" and "snd" to extract the left and right values of tuples.
15:33:35 <dons> mmm.
15:34:07 <kniu> how can fst and snd be implemented, if no pattern matching facilities exist beforehand?
15:34:28 <pumpkin> I don't think theycan
15:34:32 <Peaker> kniu: you could define tuples in the lambda calculus way, as cata-morphisms
15:34:39 <augustss> kniu: you have to assume some primitives
15:34:49 <dons> augustss: BIT?
15:34:50 <nolrai_East> @unmtl StateT s IO a
15:34:50 <lambdabot> s -> IO (a, s)
15:35:13 <augustss> dons: yes, it's is (was?) as Scandinavian publication.
15:35:16 <kniu> as catamorphisms, eh?
15:35:22 <dons> ah i see. hunting..
15:35:36 <augustss> kniu: well, it's much easier than it sounds
15:35:44 <Peaker> kniu: fancy name for a simple concept
15:35:53 <dons> i should just dig around the src.
15:35:55 <Peaker> kniu: Do you know what ADT means?
15:35:58 <kniu> yes
15:36:20 <dons> mm. it would be fun to put out a "Haskell:  Current status
15:36:23 <dons> " doc like the early 90s
15:36:39 <dons> i guess HCAR is that to some extent.
15:36:46 <augustss> kniu: pair x y = \ f -> f x y; fst p = p (\ x _ -> x); snd p = p (\ _ y -> y)
15:37:02 <Peaker> kniu: Well, to convert an ADT to its "catamorphism", you basically create a function of the form:   cata :: dataConstructor1Func -> dataConstructor2Func -> dataConstructor3Func -> ... -> DataType -> a  where each dataConstructorFunc is of the form  (dataConstructorParam1 -> dataConstructorParam2 -> ... -> a)
15:37:29 <vixey> Peaker, (does that cover cases like [] which you mentioned earler?)
15:37:56 <Peaker> vixey: well, does the cata have to be "all the way down"?
15:38:52 <Peaker> kniu: In the recursive case (the param is a recursive reference to the whole data structure) you replace the param type with "a" again
15:39:40 <augustss> Peaker: I prefer not to encode data types that way.  You just ignore the recursion and tie the know with fix outside.
15:39:51 <kniu> Is there a paper out there that explains these things?
15:40:29 <Peaker> kniu: so if list is defined:  data List a = Cons a (List a) | Nil   then the cata is:   foldr :: (a -> b -> b) -> b -> List a -> b
15:40:52 <Peaker> kniu: where the first is consFunc, and the second is nilFunc, and the consFunc takes a "b" for the recursive list there
15:41:44 <vixey> if you have  data X a = X a [a]
15:41:45 <_andre> vixey: but what should i do to have a type like that?
15:42:12 <Peaker> augustss: so would you define foldr CPS-ly?
15:42:20 <juhp> hey bos
15:43:19 <augustss> Peaker: I just define the data type so that it just does case analysis, not recursion.  Then I'd just code foldr the obvious way with fix.
15:44:16 <Peaker> augustss: so   folda :: (a -> [a] -> b) -> b -> [a] -> b   first ?
15:44:37 <augustss> kniu: you can look at my blog post for some examples http://augustss.blogspot.com/2007/11/some-lambda-calculus-examples-syntax-in.html
15:44:52 <kniu> THanks.
15:47:26 <augustss> Peaker: yes.  As if the type was data List a l = Nil | Cons x l
15:48:08 <augustss> Peaker: that plus recursion is more powerful than foldr
15:48:18 <Peaker> in what way?
15:49:06 <augustss> foldr does not allow implementing tail with constant time complexity
15:50:57 <Peaker> augustss: even relying on laziness?
15:51:18 <augustss> Peaker: that's right.
15:51:30 <Peaker> oh whoops, tail, not  (head . tail)
15:52:04 <Peaker> augustss: Yeah, I see.. Good point.. Is that form also called catamorphism?
15:52:08 <augustss> Peaker: Actually, I'm basing my argument of the proof that you can't do pred in constant time with primitive recursion on the natural numbers.
15:52:33 <vixey> do you know where to find that proof ?
15:52:34 <augustss> Peaker: I guess it's a cata for the type I showed.  I don't call it anything. :)
15:52:37 <vixey> or what it's called
15:52:43 <Peaker> augustss: intuitively, the (tail) has size O(N), and foldr is not "exposed" to that, so it has to build it
15:53:12 <augustss> vixey: I don't remember offhand.  I think it was someone in the Coq camp that did it.
15:53:37 <augustss> vixey: it's fairly recent.
15:55:12 <tehgeekmeister> how do i send a darcs repository from one computer to another without darcs running as a server on either?
15:55:43 <Peaker> tehgeekmeister: there's #darcs too, btw
15:55:49 <augustss> tehgeekmeister: tar?
15:55:56 <tehgeekmeister> Peaker: oh, thanks;; didn't think about that.
15:56:11 <tehgeekmeister> augustss: oh.  that's a really simple answer.  =D
15:56:12 * ozy` covers tehgeekmeister in tar and feathers
15:56:33 <opqdonut> tehgeekmeister: darcs pull and darcs push can work over ssh
15:58:12 <redditbot> You Know Lazy Evaluation; You Just Don‚Äôt Know It
15:58:44 <opqdonut> gah, links please
15:58:55 <tehgeekmeister> there's a reddit bot in here?  cool.
15:59:13 <tehgeekmeister> http://www.reddit.com/r/programming/comments/7jrri/you_know_lazy_evaluation_you_just_dont_know_it/
15:59:18 <gwern> opqdonut: I complained the same thing to hwomever set it up
15:59:27 <gwern> he said he was going to fix it. eventually
15:59:35 <stu8ball> Spreadsheets are lazy evaluation, and even IT teachers can do spreadheets.
15:59:55 <stu8ball> (Sorry if I'm just repeating what that article says; I didn't look at it yet, I don't know what it says)
16:00:31 <tehgeekmeister> stu8ball: how are spreadsheets lazy evaluation?
16:01:01 <stu8ball> Cells starting with =somethng
16:01:10 <stu8ball> The cells which evaluate something.
16:01:16 <nolrai_East> @pl choiceSum a b = choiceSum' False a b `unamb` choiceSum' True b a
16:01:16 <lambdabot> choiceSum = ap (ap . (unamb .) . choiceSum' False) (flip (choiceSum' True))
16:01:40 <stu8ball> They don't give a shit what you define them as until they actually get around to being executed.
16:02:14 <opqdonut> gah, horrible article
16:02:18 <opqdonut> that laziness one
16:02:50 <stu8ball> That && thing is hardcoded straight into the compiler/intpreretr usually.
16:03:03 * stu8ball has epic dystypia.
16:12:51 <dons> who suggested the permutations function for Data.List?  awesome for advocacy :) http://www.reddit.com/r/programming/comments/7kyuq/i_need_to_calculate_permutations_of_a_list_with/27e5
16:12:58 <dons> up there with the list monad.
16:14:19 <Raevel> :-)
16:14:21 <opqdonut> ah, Data.List has permutations nowadays
16:14:28 <Beelsebob> main = print . permutations . lines =<< readFile . head =<< getArgs
16:14:34 <Beelsebob> one liners ftw :P
16:14:42 <opqdonut> the base has really improved since 6.4 or so
16:14:58 <dons> yeah, useful stuff is useful
16:15:02 <Peaker> @type interact
16:15:03 <lambdabot> (String -> String) -> IO ()
16:15:33 <opqdonut> :)
16:15:38 <Peaker> dons: probably best to unlines there somewhere
16:19:48 <pumpkin> is there some way to take a set of infinite lists that take a while to compute, and to "concatenate them" into a lazy list (in parallel) that just returns one of the lazy lists' element as soon as it's ready?
16:20:15 <Taejo> pumpkin: no, because it's nondeterministic
16:20:18 <koeien> not without IO, methinks
16:20:27 <pumpkin> oh, yeah, I wasn't expecting it to be deterministic
16:20:30 <Saizan> use threads
16:20:32 <Raevel> i'll agree with koeien
16:20:36 <Beelsebob> Taejo: no, his semantics are non-deterministic
16:20:49 <Beelsebob> i.e. there are several deterministic implementations that agree with his semantics
16:21:06 <pumpkin> Saizan: yeah, I was wondering if there was some easy way to do that or if I'd need to roll my own
16:21:09 <Taejo> Beelsebob: right
16:21:30 <sjanssen> pumpkin: should be easy with forkIO and a Chan
16:21:38 <koeien> i would spawn N threads, and use an MVar or Chan
16:21:56 <Lemmih> pumpkin: Control.Concurrent.nmergeIO ?
16:22:25 <pumpkin> ah, that looks perfect :o
16:22:27 <defun> Hi, I just installed ghc onto solaris 10 via some binary package. I try to run ghci from the terminal and I get this message. Any idea what is wrong? # ghci
16:22:27 <defun> ld.so.1: ghc-6.6: fatal: libreadline.so.5: open failed: No such file or directory
16:22:27 <defun> Killed
16:22:35 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html#v%3AwriteList2Chan , if you pay attention on whre the forcing of the values occurs
16:23:01 <Taejo> defun: you don't have libreadline (in the expected place)?
16:23:16 <defun> That is a library?
16:23:26 <Taejo> yes
16:23:33 <defun> One moment. I'll google it.
16:23:41 <Raevel> http://bnfc.org/bnfc/images/bnfc.jpg
16:23:45 <defun> Thanks, btw.
16:23:55 <pumpkin> thanks Lemmih and others for the suggestions :)
16:24:48 <hugo___> hello Hppl
16:25:27 <nolrai_East> :t on
16:25:28 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:25:46 <Saizan> nmergeIO looks cool
16:25:51 <pumpkin> yeah
16:27:45 <Zericon> tddr
16:27:53 <nolrai_East> @Hoogle (a -> b) -> (a, a) -> (b, b)
16:27:53 <lambdabot> Maybe you meant: google hoogle
16:27:59 <nolrai_East> @hoogle (a -> b) -> (a, a) -> (b, b)
16:27:59 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
16:27:59 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
16:27:59 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
16:28:24 <nolrai_East> :t (***)
16:28:25 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:28:33 <Zericon> hello peeps
16:29:04 <Zericon> where is everyone
16:29:11 <pumpkin> we're all hiding, shh
16:29:14 <pumpkin> don't tell Zericon
16:31:17 <Zericon> oooo
16:31:23 <Zericon> makes
16:31:26 <Zericon> sense
16:32:05 <Peaker> see why (join (***)) needs a name? Giving stuff names makes them more accessible
16:32:15 <Zericon> rumple smooskin...
16:32:40 <Zericon> baby got back!
16:32:43 <pumpkin> PeakerWork: I agree
16:32:53 <pumpkin> about join (***), that is
16:33:03 <Zericon> hahahahaha
16:33:21 <Peaker> @djinn (a -> b) -> (a, a) -> (b, b)
16:33:21 <lambdabot> f a (b, _) = (a b, a b)
16:33:41 <Peaker> that is evil
16:33:43 <pumpkin> :P
16:33:43 <Zericon> i feel like im talking to myself
16:33:50 <pumpkin> Zericon: do you have a haskell question? :P
16:34:07 <Zericon> maybe
16:35:16 <Zericon> this is very lame
16:35:23 <pumpkin> what is?
16:35:23 <Zericon> veeeerrrryyyy
16:35:44 <pumpkin> o.O
16:35:48 <opqdonut> :t join (***)
16:35:48 <Zericon> the song im listenen 2
16:35:49 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
16:35:52 <opqdonut> ah
16:35:54 <opqdonut> :)
16:36:02 <pumpkin> it's still not exactly clear :P
16:36:21 <opqdonut> Peaker: how about "both"?
16:36:21 <Raevel> join (***) is my friend
16:36:28 <Zericon> like a fox
16:36:29 <opqdonut> in the spirit of first and second
16:36:31 <pumpkin> Raevel: yeah, I've used it a couple of times too
16:36:40 <Peaker> opqdonut: sounds good, (consistent with first/second)
16:36:41 <pumpkin> opqdonut: that sounds decent
16:37:05 <pumpkin> > both (+1) (5,6)
16:37:06 <lambdabot>   (6,7)
16:37:20 <opqdonut> :)
16:37:27 <pumpkin> quick, someone add it to Control.Arrow
16:37:29 <Zericon> i hate u all
16:37:32 <Saizan> what about square?
16:37:38 <Zericon> goodbye
16:37:45 <pumpkin> Zericon: this was productive, thanks
16:37:47 <Peaker> Saizan: ?
16:37:55 <Peaker> Saizan: why square?
16:38:06 <Saizan> x * x == square x
16:38:08 <opqdonut> cartesian square :)
16:38:09 <opqdonut> kinda
16:38:11 <pumpkin> if you think of it in terms of join (*)
16:38:23 <pumpkin> hmm
16:38:39 <pumpkin> in that case shouldn't *** be called product? :P
16:38:44 <Saizan> but (***) is not really product, it's the bimap of it..
16:38:47 <Peaker> I don't think   join (blah)  is "square" of blah, or "double" is also a square :)
16:38:55 <Peaker> join (+)
16:39:04 <Saizan> ah, right, double..
16:39:15 * Saizan fails
16:39:18 <Peaker> Saizan: but if the naming scheme is first,second,  why not "both"?
16:39:26 <pumpkin> join (-) is the most useful of all though
16:39:32 <opqdonut> :D
16:39:53 <Peaker> join (/) can test if you used join (-)
16:40:10 <opqdonut> pumpkin: join (-) reminds me of "XOR AX,AX"
16:40:13 <pumpkin> :P
16:40:21 <Peaker> opqdonut: it reminds me of "SUB AX,AX" :P
16:40:27 <Peaker> opqdonut: (its also used...)
16:40:28 <opqdonut> :D indeed
16:40:32 <trygvis> how do I know if the testsuite passed or not?
16:40:38 <trygvis> when building ghc
16:41:00 <opqdonut> > join xor 541
16:41:01 <lambdabot>   Add a type signature
16:41:12 <opqdonut> > join xor (100::Word8)
16:41:14 <lambdabot>   0
16:41:16 <opqdonut> ding
16:41:16 <opqdonut> :)
16:41:24 <pumpkin> lo
16:41:26 <pumpkin> lol
16:43:25 <thoughtpolice> yay
16:43:36 * thoughtpolice is very impressed with the improvements to memory usage that yi has made recently
16:45:14 <thoughtpolice> now if I open a file and go to the bottom, the memory usage *does* jump a little (for a 900loc, went to like 27mb) but continuous file editing and killing/yanking doesn't seem to affect it that much :)
16:45:36 <opqdonut> heh 27mb
16:45:49 <opqdonut> yi'll soon outbloat emacs!
16:46:30 <thoughtpolice> well, only a month or two ago, if I went to the end of a 900mb file and tried to keep editing it, memory usage would never stop going up, i.e. up to 200mb or so
16:46:32 <Peaker> how does yi compare to emacs?
16:46:40 <thoughtpolice> so they're very very big improvements imo :)
16:46:49 <thoughtpolice> er, s/mb/LOC/
16:47:10 <thoughtpolice> jpb pushes little fixes and optimizations constantly. darcs ftw :)
16:54:40 <Saizan> thoughtpolice: is the scrolling smooth?
16:55:47 <thoughtpolice> Saizan: i use the vty interface and fn+shift+up/fn+shift+down pretty smoothly, yeah (macbook)
17:05:39 <monochrom> ¬´Real World Haskell¬ª is among the Jolt Awards finalists. w00t!  (Some say the Jolt Awards is like Oscar.)
17:05:51 <chrisdone> yay!!
17:05:53 <FunctorSalad> thoughtpolice: which now, 900 loc or 900mb?
17:07:31 <thoughtpolice> FunctorSalad: i meant that previously if I went to a 900loc (and went to the bottom) file and kept editing then memory usage would start climbing pretty badly
17:07:46 <thoughtpolice> now if I do it on the same file with the current darcs version, memory usage seems fairly constant
17:08:28 <FunctorSalad> thoughtpolice: yeah, as you wrote it you said that the old version couldn't handle 900mb but the new version can handle 900 loc ;)
17:09:23 <kalven> being able to handle a 900mb file would put it ahead of emacs in that department ;)
17:10:19 <tehgeekmeister> any way to find out if my install of ghc has profiling built into base before i start adding more packages?
17:10:47 <FunctorSalad> maybe the lines of code contain 1mb-type signatures *ducks and runs*
17:10:54 <dons> monochrom: where'd you see that?
17:11:20 <monochrom> Greg Wilson sent an email to software engineering people at University of Toronto.
17:11:49 <monochrom> Oh oops I forgot the url. http://www.joltawards.com/finalists.html
17:12:39 <thoughtpolice> tehgeekmeister: what do you mean? base comes with a profiled version by default (all the stock packages do)
17:13:22 <tehgeekmeister> thoughtpolice: huh, well the ghc i was using in debian lenny yesterday didn't have it, so before i start building all the packages i need on my osx box i wanted to check about that
17:13:30 <thoughtpolice> dons: I saw on LtU - http://lambda-the-ultimate.org/node/3134
17:23:12 <Saizan> tehgeekmeister: check if you've a *_p.a inside the dir listed by ghc-pkg field base library-dirs
17:23:32 <tehgeekmeister> Saizan: thanks
17:24:37 <tehgeekmeister> Saizan: yep, that means it's got a profiled version, right?
17:27:18 <Saizan> tehgeekmeister: right, another way to test is compile main = putStrLn "Hello World" with -prof
17:27:35 <tehgeekmeister> tehgeekmeister: ah, good thinking.  okay.  thanks for your help.
17:29:25 <pumpkin> anyone have any examples of good uses of LogicT?
17:30:43 <mm_freak> is there any way for a program to retrieve the fields of its own cabal file?
17:31:30 <pumpkin> @instances MonadPlus
17:31:30 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:33:08 <Lemmih> mm_freak: You can only get the version, I think.
17:33:34 <gwern> mm_freak: well you can parse the cabal file
17:33:37 <gwern> http://hackage.haskell.org/packages/archive/Cabal/1.6.0.1/doc/html/Distribution-ParseUtils.html
17:33:44 <gwern> 'The .cabal file format is not trivial, especially with the introduction of configurations and the section syntax that goes with that. This module has a bunch of parsing functions that is used by the .cabal parser and a couple others. It has the parsing framework code and also little parsers for many of the formats we get in various .cabal file fields, like module names, comma separated lists etc. '
17:34:11 * gwern thinks mm_freak should've looked at the library documentation in the first place :)
17:35:00 <mm_freak> Lemmih: that's what i want
17:35:17 <mm_freak> i would like to print the version number of the program along with usage info, if the user passes -h
17:35:31 <Taejo> @help unlambda
17:35:31 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
17:35:31 <Saizan> mm_freak: import Paths_$pkgname
17:35:32 <Lemmih> mm_freak: import Paths_your_program (version).
17:35:42 <mm_freak> thanks =)
17:35:43 <Taejo> @unlambda S(KK)I
17:35:43 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
17:35:58 <pumpkin> > ifte [1,2,3,4] (return . (+1)) [5,5,4,5]
17:35:59 <lambdabot>   [2,3,4,5]
17:36:13 <Saizan> cabal will generate that module under dist/build/autogen
17:37:04 <Taejo> @unlambda `S`KKI
17:37:05 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
17:37:29 <int-e> @unlambda ``si`k.*`k. kk`k``s``s`ks``s`kks`k``s`ksk
17:37:29 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
17:37:41 <gwern> Taejo: if the machine running lb doesn't have unlambda installed ,that's not gonna do anything else
17:37:41 <int-e> missing interpreter, I guess
17:38:01 <pumpkin> anyone used LogicT much?
17:38:50 <gwern> I once saw it used to solve the knight's tour?
17:39:06 <pumpkin> yeah, that's all I've seen it used for too
17:39:11 <pumpkin> on http://haskell.org/haskellwiki/The_Knights_Tour#LogicT_monad
17:39:33 <pumpkin> but it's not exactly clear how it all works :P
17:39:57 <gwern> @seen dcoutts_
17:39:57 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
17:40:01 <gwern> @seen dcoutts
17:40:01 <lambdabot> I saw dcoutts leaving #haskell-soc, #gentoo-haskell, #ghc, #haskell-overflow and #haskell 2h 27m 56s ago, and .
17:40:13 <gwern> @seen dcoutts dcoutts_
17:40:14 <lambdabot> I saw dcoutts leaving #haskell-soc, #gentoo-haskell, #ghc, #haskell-overflow and #haskell 2h 28m 8s ago, and .
17:40:28 <jeffz`> is there a svg of the current Haskell logo?
17:40:32 <gwern> (bad. it should be able to take multiple names)
17:40:46 <Cale> I haven't used the transformer version, but the Logic monad is like a faster version of the list monad with some nice features
17:41:04 <pumpkin> Cale: like what?
17:41:47 <Cale> Fair conjunction and disjunction
17:42:04 <Cale> So you can pick from several infinite lists, for instance.
17:42:07 <mm_freak> is there a ready-made pretty-printer for Paths_*.version?
17:42:31 <Cale> (though the monadic interface still can't support that)
17:42:37 <Cale> (or it wouldn't be a monad)
17:42:39 <mm_freak> or even better, is there some documentation on that module?
17:42:54 <pumpkin> Cale: hmm, do you have a simple example? what can I do that is normally difficult?
17:42:55 <sjanssen> mm_freak: yes, showVersion or something like that
17:42:59 <Saizan> mm_freak: Data.Version or Distribution.Text
17:43:18 <sjanssen> mm_freak: Data.Version.showVersion, to be specific
17:43:33 <mm_freak> thanks
17:45:19 <Cale> pumpkin: [1..] >>- \x -> [1..] >>- \y -> return (x,y)
17:45:43 <pumpkin> oh, so just like Omega in that case
17:45:45 <Cale> (of course, that's with the implementation of >>- for lists)
17:46:32 <pumpkin> oh it's doing it differently
17:47:19 <pumpkin> > [1..] >>- \x -> [1..] >>- \y -> return (x,y)
17:47:20 <lambdabot>   [(1,1),(2,1),(1,2),(3,1),(1,3),(2,2),(1,4),(4,1),(1,5),(2,3),(1,6),(3,2),(1...
17:47:42 <pumpkin> so >>- is like >>= but "fair"? :P
17:47:46 <Cale> yeah
17:47:55 <pumpkin> interesting
17:48:35 <tehgeekmeister> how do i build a package with profiling support?
17:48:39 <pumpkin> -p
17:48:48 <pumpkin> but its dependencies also need profiling support
17:50:09 <mm_freak> is there a nicer way to write '(\cfg -> cfg { showTodo = False })'?
17:51:30 <pumpkin> I think that is the nicer way isn't it? :P
17:51:39 <pumpkin> "nicer"
17:52:00 <mm_freak> i thought, there might be a nicer possibility
17:52:32 <mm_freak> command line argument parsers are ugly in any language‚Ä¶  haskell does a bit about it, but still
17:52:39 <mm_freak> at least, the parseargs package is nice
17:53:17 <dons> needs an expert
17:53:43 <Elly> dons needs an expert? :O
17:54:02 <dons> a good parseargs
17:54:13 <jeffz`> does anyone know who designed the current Haskell logo?
17:54:13 <dons> someone who cares deeply and personally about argument parrsing
17:54:30 <dons> jeffz`: let me find out...
17:54:42 <tehgeekmeister> ah, man.  now i remember why i wasn't doing this on my personal machine: hexpat won't build on it.
17:54:49 <jeffz`> dons, cool, I'm trying to find out if there's a svg
17:56:02 <mm_freak> dons: indeed
17:56:03 <dons> 03.05.24:10:22:02 <pesco> Ook, when did that gruesome haskell.org logo appear?!
17:56:10 <tehgeekmeister> anyone know what /usr/include/available.h is and why it might be different enough on osx from what it is on debian lenny that c2hs can't handle it?
17:56:11 <dons> 03.06.04:07:09:52 <Smerdyakov> The logo on www.haskell.org is ugly, tome
17:56:30 <mm_freak> i wrote a command line parsing library for personal use in C++
17:56:45 <pumpkin> omg c++
17:56:46 <mm_freak> it evolved into an entire class hierarchy and become about 500 lines long
17:56:53 <pumpkin> it was a big loser in that google meter
17:57:02 <mm_freak> pumpkin: at that time, i couldn't even spell "functional" =)
17:57:23 <dons> 06.04.06:16:04:50 <sieni> because the haskell logo colours are Unbelievably Fucking Ugly
17:57:44 <te> c++ > *
17:57:55 <Taejo> :t \x y z -> (x z) (y z)
17:57:56 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
17:58:07 <te> lol -- speaking of hating on c++, Alan Kay is remarkably good at ripping on C++
17:58:11 <te> after all, he coined "OOP"
17:58:40 <te> he often will say "When I first said 'OOP', C++ was /not/ what I had in mind." :D
17:59:05 <te> hdhaisdhhhi12DDCXx
17:59:10 <te> whooa momma
17:59:27 <mm_freak> > c++ > *
17:59:29 <lambdabot>   <no location info>: parse error on input `>'
17:59:40 <mm_freak> > "c++" > "*"
17:59:42 <lambdabot>   True
17:59:52 <mm_freak> > "C++" > "*"
17:59:54 <lambdabot>   True
17:59:59 <mm_freak> ASCII sucks
18:00:41 <Taejo> > "C++" > "Haskell"
18:00:43 <lambdabot>   False
18:00:50 <Taejo> ASCII rules
18:01:07 <mm_freak> > "c++" > "Haskell"
18:01:09 <lambdabot>   True
18:01:11 <mm_freak> ASCII sucks
18:01:43 <Philippa__> That's cheating:
18:01:49 <Philippa__> > "c++" > "haskell"
18:01:49 <Taejo> mm_freak: C++ doesn't deserve much respect, but it does deserve a capital letter
18:01:50 <lambdabot>   False
18:02:10 <mm_freak> > 1 > 2
18:02:11 <lambdabot>   False
18:02:16 <mm_freak> > 1 > undefined
18:02:17 <lambdabot>   * Exception: Prelude.undefined
18:02:29 <te> c++ has been succesful in showing us the opposite of what ought to be OOP
18:02:32 <mm_freak> Philippa__: your cheat is unnecessarily strict =P
18:02:34 <te> so in that regard it's been useful
18:02:56 <int-e> @quote OO
18:02:56 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
18:03:01 <mm_freak> > "C++" < "Haskell"
18:03:02 <lambdabot>   <no location info>:
18:03:02 <lambdabot>      lexical error in string/character literal at chara...
18:03:07 <ikkebr> > "Python" > "C++" && "Haskell" > "C++" && "C++"> "*" && "Python" > "Haskell"
18:03:08 <lambdabot>   True
18:03:08 <Philippa__> mm_freak: huh? It's not a function, it can't possess strictness :-p
18:03:12 <int-e> > "Unlambda" > "Haskell"
18:03:13 <lambdabot>   True
18:03:18 <te> I'm going to change my name to Lambda
18:03:21 <te> like prince, only geekier
18:03:33 <mm_freak> > "Lazy K" > "Unlambda"
18:03:34 <lambdabot>   False
18:03:42 <te> "John" > "Dave"
18:03:44 <dons> jeffz`: apparently Fritz Ruehr designed it
18:03:51 <te> > "John" > "Dave"
18:03:52 <lambdabot>   True
18:03:55 <jeffz`> dons: thanks
18:04:03 <dons> this was the logo for many years, http://xahlee.org/UnixResource_dir/gki/HaskellLogo.jpg
18:04:11 <mm_freak> Philippa__: (>) is not a function?
18:04:14 <dons> 2002-ish to 2005 or so, until we tried the new wiki
18:05:12 <Philippa__> mm_freak: its double application isn't :-)
18:05:14 <chessguy> @bot
18:05:14 <lambdabot> :)
18:05:14 <lunabot>  :)
18:06:03 <jonaskoelker> what's lunabot?
18:07:03 <te> a mystical bot
18:07:06 <jonaskoelker> and why's there no love for C++ in here?
18:07:11 <te> filled with wonder (and immense amounts of shame)
18:07:14 * jonaskoelker *acts* surprised (but isn't)
18:07:31 <te> jonaskoelker: it's the cool thing to hate in CS
18:07:44 <te> it's just like lots of psych majors hate Freud
18:08:20 <te> it's also cool to scoff at PHP and Java, depending on your school's ciriculum
18:08:27 <Philippa__> te: it's also something a good many people have a distaste for based on their personal experience
18:08:34 <Philippa__> it may well have nothing at all to do with uni
18:08:48 <te> Philippa__: You'll get no argument from me.  I don't like C++, and it was my full CS undergrad coursework.
18:09:44 <te> I made it work, but as soon as I got out I found other things I liked more.  However, that's kind of an odd thing.  I was more interested in finding something new to learn, than I hated c++.
18:09:52 <luite> do universities actually teach php?
18:10:03 <jonaskoelker> I'm kinda ambivalent on C++.  It's a very good C-with-generics-and-deallocation-on-scope-exit...
18:10:14 <Philippa__> sometimes in a "we want to talk about web dev, here's the lang we'll use" manner
18:10:15 <te> Some universities have media/arts programs that teach development with PHP and the like.
18:10:22 <jonaskoelker> on the other hand, things can get out of hand *FAST*
18:10:53 <Philippa__> jonaskoelker: there're fair arguments against templates as a form of parametric polymorphism, too
18:11:08 <O_4> C++ makes it ridiculously easy to write atrocious code.
18:11:08 <jonaskoelker> the PHP notion of modularity is ~= C's #include, right? ;)
18:11:28 <te> 80% of this is going way over my head
18:11:29 <jonaskoelker> Philippa__: oh cool, what are they?
18:11:31 <mm_freak> actually C and C++ are great for confusing people
18:11:31 <O_4> So a lot of people are going to have bad experiences with it,
18:11:39 <mm_freak> at least if you use functional concepts in them
18:11:53 <Philippa__> jonaskoelker: for one, it's not actually parametric!
18:12:29 <Philippa__> more generally, the specialisation mechanics are very much a double-edged sword
18:12:30 <jonaskoelker> Philippa__: that needs a definition and a proof :)
18:12:54 <Philippa__> jonaskoelker: it's parametric if you can't tell ("from the inside") what the parameter was
18:13:06 <jonaskoelker> mm_freak: function pointers as higher-order functions (for qsort, bsearch) seems to work fine in C... no?
18:13:18 <Philippa__> nope
18:13:40 <Philippa__> trying something as simple as currying ought to give lie to that
18:14:02 <jonaskoelker> s/higher-order/first-class/
18:14:15 <jonaskoelker> which is less valuable (and I stand corrected)
18:14:50 <Philippa__> actually it makes little difference: true first-class functions would let you build new ones at run-time
18:14:57 <jonaskoelker> Philippa__: so C++ lets you have parametric polymorphism, if you constrain yourself, and lets you have something different if you don't?
18:16:04 <Philippa__> jonaskoelker: and leaves you unable to tell whether you have it or not
18:16:35 <Philippa__> the argument is that what you /should/ have is a) parametric polymorphism and b) a more powerful module system that does most of the things templates do
18:16:50 <Philippa__> the ML languages have such module systems, btw
18:17:12 <jonaskoelker> does haskell count as an ML language in this regard?
18:17:38 <jonaskoelker> Philippa__: could you read the source and know whether you have parametric polymorphism?
18:17:45 <Philippa__> nope. Haskell's module system is pretty simple
18:18:22 <Philippa__> jonaskoelker: Strictly speaking, I'm not sure it's always decidable :-) There most certainly isn't a quick analysis for it
18:18:49 <Philippa__> and someone else can break it for you later
18:19:05 <Philippa__> by adding another specialisation
18:19:15 <jonaskoelker> ah true
18:19:53 <jonaskoelker> so, what does the module mechanism of ML do that haskell's doesn't?
18:20:31 <Philippa__> functors - which in this context are (sort of) parameterisable modules
18:21:14 <Philippa__> "give me a balanced tree module based on this item type and this ordering"
18:22:54 <jonaskoelker> you could get the same functionality by storing the ordering in the tree in haskell, right?
18:24:36 <Philippa__> no: you get a new type
18:24:52 <Philippa__> it's not the same type as a balanced tree with the same item type and a different ordering, say
18:25:22 <jonaskoelker> ah
18:25:33 <jonaskoelker> so it parameterises types based on values
18:25:47 <jonaskoelker> like C++, only not as crappy
18:25:49 <jonaskoelker> ;)
18:26:58 <Philippa__> it doesn't: the values don't appear in the types as such
18:26:59 <Elly> "Haskell: like C++, only not as crappy"
18:27:37 <jonaskoelker> once again, I stand corrected
18:28:07 <Philippa__> also: modules (like C++ templates) are resolved strictly at compile-time. With polymorphic recursion, it's possible to get 'new' types at run-time
18:28:58 <jonaskoelker> Philippa__: got a good use case for that?
18:29:13 <mxc>  /join #cocoa
18:29:17 <mxc> oops, sorry
18:29:33 <mxc> (had a leading space, didn't realize)
18:29:36 <jonaskoelker> (I'm not trying to be dismissive of the concept, I just can't think of one right now)
18:29:43 <Philippa__> I don't run into polymorphic recursion often without GADTs involved. Others do, though
18:30:19 <Philippa__> and it's a fairly sensible part of a lot of schemes where the type system guarantees invariants you wouldn't normally expect it to
18:32:23 * wli finally longed for modules badly enough to install SML/NJ.
18:37:07 <mm_freak> jonaskoelker: i found myself using CPS in C, which confuses the average C programmer
18:37:28 <mm_freak> in a lot of cases, CPS makes memory management much easier
18:37:35 * mxc still doesn't exactly get CPS, even in haskell
18:37:53 <mm_freak> mxc: instead of returning the result, pass it to a function
18:37:58 <mm_freak> that's it
18:38:00 <jonaskoelker> CPS - you send a function (pointer), the callee returns by calling it
18:38:06 <jonaskoelker> bah, yer beat me to it
18:38:11 <mxc> right, i get the high level description,
18:38:23 <mxc> just never really figured out a use for it or how to implement it on my own
18:38:24 <mm_freak> mxc: there is nothing more to it, really
18:38:57 <mm_freak> mxc: in functional languages, CPS is usually only used, where some flexible type system is missing, like in scheme
18:39:45 <mm_freak> however, in C you can ease memory management in some cases using CPS, like dynamically allocating a string for further processing
18:40:11 <pumpkin> it's only "easing memory management" if you're insane, like mm_freak
18:40:13 <pumpkin> ;)
18:40:35 <pumpkin> just kidding :P
18:40:42 <mm_freak> instead of malloc(), pass pointer to function, get result, free(), do the following:  call the function, pass it a continuation‚Ä¶  the function allocates a string on the stack and passes a pointer to it to the continuation
18:40:59 <mm_freak> automatic garbage collection in C =)
18:41:31 <jonaskoelker> either you're just describing callbacks, or you're leaking memory on the stack
18:41:37 <jonaskoelker> ;)
18:41:44 <mm_freak> jonaskoelker: why?
18:41:58 <mm_freak> of course, the continuation should not return any reference to that memory ;)
18:41:59 <pumpkin> how does one leak stack memory?
18:42:01 <Elly> "leaking memory on the stack"?
18:42:13 <Philippa__> pumpkin: by failing to pop it, presumably
18:42:15 <jonaskoelker> if you allocating function never returns, you've allocated memory that won't get free'd until the program exits
18:42:18 <bd_> pumpkin: alloca() and deep recursion? :)
18:42:23 <Elly> well, yes
18:42:23 <dons> leak doesn't nec. mean 'lost'
18:42:34 <Elly> but if it never returns, it's using the buffer (you hope)
18:42:38 <pumpkin> Philippa__: which would amount to not returning from a function I guess
18:43:05 <Philippa__> pumpkin: yeah, which is why TCO is important
18:43:16 <jonaskoelker> unless there's some funky static analysis and TCO going on...
18:43:16 <pumpkin> total cost of ownership? :o
18:43:20 <mm_freak> jonaskoelker: indeed, that's a problem with that approach, but it works well in a few scenarios
18:43:21 <jonaskoelker> tail call optimization
18:43:23 <pumpkin> :P
18:43:29 <jonaskoelker> :)
18:43:40 <jonaskoelker> TCO of C code is also important
18:43:40 <mm_freak> it's just that the average C programmer gets crazy reading that code =)
18:43:47 <jonaskoelker> which is why you should switch to haskell today ;)
18:44:10 <jonaskoelker> mm_freak == mem mgmt freak?
18:44:20 <mm_freak> nope
18:44:31 <mm_freak> if i were, i wouldn't use haskell =)
18:45:22 <jonaskoelker> :P
18:46:39 <pumpkin> I love the comment on this: http://www.reddit.com/r/haskell/comments/7kdsk/coroutines_for_haskell/?sort=new
18:48:32 <scsibug> I just heard the good news about HTTP-4000... could someone give me a hand in figuring out how to select ByteString as the underlying buffer datatype, instead of String?
18:48:51 <pumpkin> if I write "abc" ++ "def", is it just changing the next pointer for the cell with 'c' in it, or is it copying "abc" (I'm not keeping a reference to "abc")
18:49:21 <pumpkin> (behind the scenes)
18:50:21 <mm_freak> pumpkin: with lists you usually don't care about how you construct them, but rather how you use the result
18:50:41 <mm_freak> the answer really depends on that
18:50:51 <pumpkin> ah, I guess it doesn't bother doing anything until I ask for the concatenation of them
18:51:03 <thoughtpolice> using cabal install, is there a way to pass arguments to a ./configure script if one is included?
18:51:29 <pumpkin> thoughtpolice: I couldn't find anything last time I looked :/ but that's no guarantee :P
18:52:18 <mm_freak> in quicksort, (++) involves copying, but in concatenating a set of strings, which aren't used later, (++) should not copy, but really append
18:52:39 <mm_freak> especially "abc" ++ "def" should not involve copying
18:53:23 <Saizan> (++) makes new cons cells, but doesn't copy the elements
18:53:44 <jonaskoelker> mm_freak: huh?  Quicksort doesn't need to copy when appending
18:54:04 <jonaskoelker> mm_freak: at least not my dirty evil C implementation ;)
18:54:19 <Saizan> but fusion can avoid the presence of lists altogether
18:54:33 <mm_freak> jonaskoelker: the haskell list version does (IIRC)
18:54:44 <jonaskoelker> oh :\
18:55:03 <mm_freak> but sorting lists is flawed by concept anyway
18:55:19 <Saizan> it's hard to call quicksort the haskell list version
18:55:20 <tehgeekmeister> how do you handle exceptions that occur in pure code?
18:55:30 <tehgeekmeister> control.exception doesn't seem to have anything for that
18:55:35 <Philippa__> from IO
18:55:36 <mm_freak> tehgeekmeister: you don't
18:55:46 <mm_freak> you do that in IO
18:56:09 <tehgeekmeister> bah
18:56:13 <tehgeekmeister> that's not what i wanted to here.  =P
18:56:15 <tehgeekmeister> *hear
18:56:17 <mm_freak> Saizan: i meant the version of quicksort for lists in haskell
18:56:36 <mm_freak> tehgeekmeister: consider that a function, which throws an exception, has a bottom result
18:56:46 <Saizan> tehgeekmeister: avoid pure exceptions if you cen
18:56:49 <mm_freak> so it never returns (from the perspective of pure code)
18:56:53 <Axman6> :t BS.split
18:56:55 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
18:56:58 <Saizan> tehgeekmeister: by using Either or Maybe
18:57:03 <Axman6> @src ByteString
18:57:04 <lambdabot> Source not found. Are you on drugs?
18:57:07 <Axman6> bah
18:57:10 <tehgeekmeister> Saizan: Prelude.read is my problem
18:57:20 <Saizan> ?type reads
18:57:21 <mm_freak> tehgeekmeister: use reads
18:57:21 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:57:49 <tehgeekmeister> okay
18:58:07 * wli prefers heapsort.
18:58:13 <redditbot> Creative Commons in action: Real World Haskell being translated into Japanese!
18:58:22 <Saizan> readMaybe xs = case reads xs of [(v,rest)] | all isSpace rest -> Just v; _ -> Nothing
18:58:23 <mm_freak> /me prefers quicksort on arrays
19:00:22 <pumpkin> I prefer bozosort
19:02:46 <tehgeekmeister> where's stuff for dealing with an interrupt (^C)?  what library?  need to make my code exit cleanly on interrupt.
19:03:15 <jonaskoelker> I prefer stooge sort :)
19:03:33 <jonaskoelker> runs in O(n^2.71) time
19:03:56 <pumpkin> how bout pancake sort then?
19:04:53 <mm_freak> > let mySort = foldr (\x -> span (<x) >>> arr (\(a,b) -> a ++ [x] ++ b)) [] in mySort [5,1,3,4,2]
19:04:55 <lambdabot>   [1,2,3,4,5]
19:05:41 <pumpkin> :t (>>>)
19:05:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
19:06:00 <mm_freak> actually that's overcomplicated
19:06:18 <mm_freak> > let mySort = foldr (\x -> (\(a,b) -> a ++ [x] ++ b) . span (<x)) [] in mySort [5,1,3,4,2]
19:06:20 <lambdabot>   [1,2,3,4,5]
19:07:26 <jonaskoelker> > let mySort = foldr (\x -> (\(a,b) -> a ++ [x] ++ b) . span (<x)) [] in mySort [5,1,3,4,2]
19:07:27 <lambdabot>   [1,2,3,4,5]
19:07:31 <jonaskoelker> > let mySort = foldl (\x -> (\(a,b) -> a ++ [x] ++ b) . span (<x)) [] in mySort [5,1,3,4,2]
19:07:32 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:07:32 <lambdabot>        Expect...
19:08:05 <mm_freak> jonaskoelker: i think, a right fold is going to be faster here
19:08:37 <mm_freak> > let mySort = foldl (flip (\x -> (\(a,b) -> a ++ [x] ++ b) . span (<x))) [] in mySort [5,1,3,4,2]
19:08:39 <lambdabot>   [1,2,3,4,5]
19:10:58 <pumpkin> > loop (join (***) (+1)) 5
19:10:59 <lambdabot>   6
19:11:03 <pumpkin> :o
19:11:16 <jonaskoelker> :-?
19:11:19 <pumpkin> that's super useful!
19:11:24 <pumpkin> although I haven't decided why yet
19:11:27 <jonaskoelker> :t (***)
19:11:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:11:41 <jonaskoelker> :t join
19:11:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:12:03 <pumpkin> > loop ((+4) (***) (+1)) 5
19:12:04 <lambdabot>       Occurs check: cannot construct the infinite type: d = (c, d)
19:12:04 <lambdabot>        Exp...
19:12:12 <pumpkin> > loop ((+4) *** (+1)) 5
19:12:12 * gwern looks at http://www.reddit.com/r/haskell/comments/7ky7v/initial_performance_numbers_for_the_new/ and feels weird. if I upvote my linked email, is - is that like touching myself?
19:12:13 <lambdabot>   9
19:12:33 <pumpkin> it's okay
19:12:58 <mm_freak> @hoogle a (b,b) c -> x -> a b c
19:12:58 <lambdabot> No results found
19:13:09 <mm_freak> @hoogle a (b,b) c -> (b -> c) -> a b c
19:13:10 <lambdabot> No results found
19:13:15 <mm_freak> @hoogle a (b,b) c -> a b c -> a b c
19:13:16 <lambdabot> No results found
19:13:20 <mm_freak> @hoogle a (b,b) c -> a b c
19:13:21 <lambdabot> No results found
19:13:25 <pumpkin> > let f g = loop (join (***) g) in f (+1) 5
19:13:26 <lambdabot>   6
19:13:32 <pumpkin> there we go, it's even reusable now!
19:13:38 <pumpkin> :P
19:14:01 <pumpkin> oh actually
19:14:12 <pumpkin> > let f = loop . join (***) in f (+1) 5
19:14:13 <lambdabot>   6
19:14:27 * pumpkin is so l33t
19:15:01 <Axman6> me is happy with (+1) 5 personally
19:15:07 <pumpkin> lol
19:15:20 <pumpkin> why not 5 + 1?!!? don't overcomplicate things when you don't need to!!
19:15:34 <pumpkin> ;)
19:15:43 <mm_freak> > sin *** cos >>> arr (uncurry ((+) `on` (^2))) $ (3,3)
19:15:44 <lambdabot>   0.9999999999999999
19:15:54 <mm_freak> > sin *** cos >>> arr (uncurry ((+) `on` (^2))) $ (2,2)
19:15:56 <lambdabot>   1.0
19:16:05 <mm_freak> rounding errors suck
19:16:20 <Axman6> :t arr
19:16:21 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
19:16:23 <Axman6> :t (>>>)
19:16:24 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
19:16:27 <pumpkin> so arr just makes a function into an arrow?
19:16:40 <mm_freak> pumpkin: into an arrow computation, that is
19:16:58 <pumpkin> but it doesn't do anything "interesting", right?
19:17:02 <pumpkin> just "wraps" it?
19:17:07 <pumpkin> @src arr
19:17:07 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:17:27 <mm_freak> pumpkin: it's analog to 'return' in monads
19:17:35 <pumpkin> ah, I see
19:17:47 <Axman6> @src Arrow
19:17:47 <lambdabot> class Arrow a where
19:17:47 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:17:47 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:17:47 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:17:47 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:17:49 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:17:51 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:18:01 <Axman6> is >>> like .?
19:18:09 <Pseudonym> Axman: Yes.
19:18:12 <mm_freak> Axman6: like flip (.)
19:18:13 <Axman6> hoorah
19:18:25 <Axman6> close enough :P
19:18:30 <mm_freak> > (+1) >>> (^2) $ 4
19:18:31 <Axman6> :) even
19:18:32 <lambdabot>   25
19:18:38 <pumpkin> so could I make a matrix an arrow?
19:18:47 <Pseudonym> @src (>>>) (->)
19:18:47 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:19:02 <Pseudonym> @src (->)
19:19:03 <lambdabot> Source not found. My pet ferret can type better than you!
19:19:06 <Pseudonym> Whatever.
19:19:08 <litb> hey guys. is 1::Int standard or extension of ghc ?
19:19:16 <Pseudonym> Standard.
19:19:16 <mm_freak> pumpkin: consider monads and how they are computations, which result in a value of a certain type
19:19:27 <mm_freak> arrows allow you to add the concept of specifying the type of the input
19:19:33 <Lemmih> litb: Depends on the context.
19:19:41 <thoughtpolice> hi Lemmih
19:19:50 <Lemmih> Hello thoughtpolice.
19:19:53 <poliquin> I looked at Parsec (I've never played with parsers before) .. is this a good plan?
19:20:05 <litb> i wonder about   (+) (1::Int)
19:20:12 <thoughtpolice> poliquin: parsec is a lot of fun and it's easy too :)
19:20:21 <Pseudonym> Just don't look at the implementation yet.
19:20:26 <mm_freak> litb: standard
19:20:31 <litb> neat, thanks
19:20:44 <Pseudonym> Yes, there are some contexts where it's not standard.
19:20:45 <Pseudonym> e.g.:
19:20:48 <thoughtpolice> Lemmih: how has your lhc work been going? I've been coming back home since I left uni. for the break and haven't had much time to code
19:20:49 <Pseudonym> f (1 :: Int) = 1
19:20:51 <mm_freak> litb: if you use GHC without command line options and your code compiles, it should be standard h98 =)
19:20:54 <Pseudonym> f n = n * f(n-1)
19:21:01 <litb> i remind someone told me ::Int used in soome context is ghc stuff
19:21:04 <Pseudonym> But in an expression it's standard.
19:21:06 <litb> but don't remember what exactly
19:21:11 <pumpkin> litb: Pseudonym just did
19:21:26 <litb> oh
19:21:28 <Pseudonym> This, OTOH, is standard:
19:21:32 <Pseudonym> f 1 = (1 :: Int)
19:21:35 <Pseudonym> etc etc
19:21:50 <Axman6> i prefer writing out the type signature :\
19:21:52 <litb> great stuff
19:22:09 <pumpkin> Axman6: I'm up to 75 problems btw! :)
19:22:15 <Pseudonym> Axman: Me too.
19:22:16 <Axman6> :o
19:22:22 <Pseudonym> It's good documentation.
19:22:47 <orbitz> hah
19:22:58 <orbitz> megzlna has been in ##c++ for the last week espousing Haskell
19:23:05 <pumpkin> :o
19:23:05 <Lemmih> thoughtpolice: I haven't gotten much work done. Something seemingly unrelated always blows up when rewrite a chunk of code.
19:23:06 <Axman6> pumpkin: if i had more knowledge on how to do some of the problems, i might be further ahead (i've just finished my first year at uni, so only basic comp so far. Haskell and java -_-)
19:23:15 <Axman6> orbitz: hahaha
19:23:25 <wcstok> I'm 5 minutes from booting his ass too
19:23:28 <ozy`> orbitz: there's just no understanding people, is there?
19:23:30 <orbitz> Axman6: he always starts by bitching about records for 20 minutes though
19:23:32 <Axman6> that guy is messed up
19:23:33 <orbitz> wcstok: pelase do
19:23:48 <thoughtpolice> Lemmih: that's the tendency, yes. death to impurity!
19:23:57 <mm_freak> @pl \xs -> if null xs then a else b
19:23:58 <lambdabot> flip (flip if' a . null) b
19:24:37 <pumpkin> can that if' be seen as a catamorphism for Bool, or can only monads have catamorphisms? :P
19:24:44 <Axman6> wcstok: no one would blame you (and many would praise you quite highly i think)
19:24:48 <monochrom> Why would anyone go to another channel to preach Haskell. It's annoying.
19:24:59 <orbitz> monochrom: it' megzlna
19:25:02 <pumpkin> monochrom: because there's no point in preaching to the crowd :P
19:25:04 <Lemmih> thoughtpolice: I'm not giving up, though. Eventually all the invariants will be discovered and documented.
19:25:07 <pumpkin> we already know haskell is awesome
19:25:11 <orbitz> can he only be in 1 channel at a time?  i would have expected him to be in here still
19:25:31 <wcstok> I'm undetermined on haskell's quantity of awesome, thanks :P
19:26:00 <pumpkin> wcstok: that's why you're an op in #c++, you're the upper echelon of c++ers, it's natural it would take you longer to come to the dark side
19:26:02 <orbitz> hah
19:26:10 <Lemmih> thoughtpolice: There's this annoying holiday coming up soon. It'll probably interfere with my hacking for at least a week (:
19:26:15 * pumpkin waits to be booted from ##c++
19:26:23 <wcstok> well there's that, and it hurts my brain
19:26:29 <blackh> wcstok: I've established a lower bound on Haskell's quantity of awesome.
19:26:32 <Axman6> ?usera
19:26:32 <lambdabot> Maximum users seen in #haskell: 568, currently: 530 (93.3%), active: 24 (4.5%)
19:26:34 <Axman6> ?users
19:26:34 <lambdabot> Maximum users seen in #haskell: 568, currently: 530 (93.3%), active: 24 (4.5%)
19:26:45 <pumpkin> blackh: and it happens to be exactly the sum of all other languages' quantity of awesome?
19:26:45 <blackh> wcstok: I'm still searching for the upper bound.
19:26:53 <thoughtpolice> Lemmih: indeed. we'll just keep stabbing at it until we figure it out, and things will be better off. since we've cleared all the low-hanging fruit just about now, mainly big stuff remains to be done
19:26:59 <thoughtpolice> Lemmih: hehehe.
19:27:05 <orbitz> wcstok: hurts in a good way sometime though
19:27:40 <orbitz> i like the insergence of #haskelelrs -> ##c++ :)
19:27:41 <Axman6> my legs hurt from paintball and climbing a mountain yesterday :(
19:27:46 <Axman6> better be worth it!
19:27:54 <orbitz> my butt hurts from sitting around all day
19:28:06 <Axman6> orbitz: meg deserves a crowd
19:28:15 * blackh is programming in C++ at this very moment.
19:28:21 <orbitz> haah
19:28:33 <orbitz> blackh: heretic!
19:29:08 <nolrai_East> @pl g f (a,b) = (f a, f b)
19:29:09 <lambdabot> g = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
19:29:18 <nolrai_East> hmm
19:29:20 <orbitz> my cat is snoring
19:29:23 <orbitz> :t ap
19:29:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:29:40 <blackh> orbitz: At least I am admitting it!
19:30:00 <dibblego> RWH just arrived!
19:30:01 <nolrai_East> @pl g (a,b) f = (f a, f b)
19:30:01 <lambdabot> g = uncurry ((. flip id) . ap . ((,) .) . flip id)
19:30:03 <Axman6> wcstok: you're not going to boot him just yet are you? :( i want to hear some non-sense first!
19:30:08 <orbitz> dibblego: awesome!
19:30:29 <blackh> orbitz: I speak with authority when I say how brilliant Haskell is.
19:30:36 <nolrai_East> I just got my copy too. Very useful.
19:30:53 <wcstok> he shutup when I found my @ hat
19:31:03 <tehgeekmeister> http://hpaste.org/13247 <== wondering why this hangs instead of exiting
19:31:21 <tehgeekmeister> oh man, it's still too long, even without the imports...
19:31:31 <O_4> Holy smokes
19:31:34 <Axman6> tehgeekmeister: jesus :|
19:31:59 <tehgeekmeister> i should probably take the time to reformat that beast soon, i know.
19:32:37 <Axman6> orbitz: don't you wish meg would choose a language, stick to actually learning it, and shut up?
19:33:21 <tehgeekmeister> okay, annotated it with a shorter version so you can actually see all of it.
19:33:24 <orbitz> Axman6: i wish he would just learn rather than ask a bunch of complicated questions that are based on assuming some other language is how things should be
19:33:41 <Axman6> yes, so frustrating!
19:33:54 <Axman6> and getting 'furious' at recoed syntax? far out
19:33:57 * orbitz wonders if Meg has written a single lin eof haskell yet
19:34:13 <orbitz> wel li dont' think it was the syntax, just the constraints on naming rihgt?
19:34:34 <Axman6> i have no idea what his problem was, he wouldn't say
19:34:57 * orbitz shrugs
19:35:02 <orbitz> oh well. there are all kidns out there clearly
19:37:32 <mm_freak> > permutations "abc"
19:37:33 <lambdabot>   Not in scope: `permutations'
19:38:10 <mm_freak> > fix (\k x -> case x of [] -> []; (x0:xs) -> k (filter (<x0) xs) ++ [x0] ++ k (filter (>=x0) xs)) ['z', 'y' .. 'a']
19:38:12 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
19:38:22 <mm_freak> > fix (\k x -> case x of [] -> []; (x0:xs) -> k (filter (<x0) xs) ++ [x0] ++ k (filter (>=x0) xs)) "you suck bad!"
19:38:23 <lambdabot>   "  !abcdkosuuy"
19:38:34 <ozy`> orbitz: yeah, he wanted to be able to re-use field names for all kinds of stuff
19:39:12 <ozy`> so he could get a pet penguin and a cactus and a pony and name them all "pet"
19:39:37 <orbitz> i mean. IMO that is a valid complaint.  I just disagree with how big of a problem he found it to be
19:40:54 * Axman6 would use ppet, for polymorphic pets
19:41:06 <pumpkin> http://projecteuler.net/index.php?section=problems&id=38 does anyone see any subtle nuance in that? it's not taking my rather obvious answer
19:41:21 <ozy`> orbitz: it's like he went over his soup with a magnifying lens looking for specks of dust
19:41:31 <blackh> You do get something in return for not being able to re-use field names: Your field names imply types.
19:42:17 <wli> > let permutations [] = [] ; permutations [x] = [[x]] ; permutations (x:xs@(_:_)) = concatMap (\ys -> zipWith (\f b -> f ++ [x] ++ b) (inits ys) (tails ys)) (permutations xs) in map (length . permutations) $ inits "abcdefg"
19:42:18 <lambdabot>   [0,1,2,6,24,120,720,5040]
19:42:47 <int-e> yes, permutations [] = [[]]
19:44:30 <wli> Hmm. I guess it's more conventional for that to be the case.
19:46:49 <mm_freak> wli: in GHC 6.10, there is a 'permutations' implementation in Data.List
19:46:58 <pumpkin> , permutations [1..5]
19:47:04 <lunabot>  [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],...
19:47:30 <int-e> , map (take 5) $ permutations [1..]
19:47:32 <lunabot>  [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],...
19:47:50 <mm_freak> , subsequences "abc"
19:47:53 <lunabot>  ["","a","b","ab","c","ac","bc","abc"]
19:48:26 <mm_freak> , foldr (\x ys -> map (x:) ys ++ ys) [[]] "abc"
19:48:28 <lunabot>  ["abc","ab","ac","a","bc","b","c",""]
19:48:38 <mm_freak> hmm
19:48:44 <mm_freak> , foldl (\ys x -> map (x:) ys ++ ys) [[]] "abc"
19:48:46 <lunabot>  ["cba","cb","ca","c","ba","b","a",""]
19:49:02 <mm_freak> , foldr (\x ys -> ys ++ map (x:) ys) [[]] "abc"
19:49:05 <lunabot>  ["","c","b","bc","a","ac","ab","abc"]
19:49:49 <tehgeekmeister> jesus my code got messy;; i had two threads parsing the same file and writing to the same mvar...
19:49:57 <tehgeekmeister> that couldn't have made anything faster.
19:50:29 <tehgeekmeister> what does it mean when your code dies with <<loop>>?
19:50:40 <wli> mm_freak: I was not aware of that.
19:50:47 <mm_freak> tehgeekmeister: race condition
19:50:59 <tehgeekmeister> mm_freak: huh?
19:51:06 <mm_freak> uh, no, that was another error
19:51:10 <tehgeekmeister> mm_freak: i'm new to concurrent programming
19:51:26 <wli> I've always wanted something that did \xs -> zip (inits xs) (tails xs) more efficiently.
19:51:31 <mm_freak> <<loop>> is output, if an endless loop is detected
19:51:33 <int-e> > let x = x in x
19:51:42 <pumpkin> int-e: do you have any insight on problem 38 of PE? it seems so obvious but it doesn't accept my answer (or any of the other ones) ( http://projecteuler.net/index.php?section=problems&id=38 )
19:51:51 <lambdabot>   thread killed
19:52:07 <mm_freak> > (\xs -> zip (inits xs) (tails xs)) "abc"
19:52:08 <lambdabot>   [("","abc"),("a","bc"),("ab","c"),("abc","")]
19:52:56 <mm_freak> wli: for what purpose?
19:53:16 <wli> mm_freak: I just end up doing zip (inits xs) (tails xs) a lot.
19:53:18 <pumpkin> wli: a list rotation?
19:53:43 <wli> pumpkin: I guess.
19:54:10 <Axman6> @src tails
19:54:11 <lambdabot> tails []         = [[]]
19:54:11 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
19:54:11 <pumpkin> > zipWith (++) (tails "abcd") (inits "abcd")
19:54:12 <lambdabot>   ["abcd","bcda","cdab","dabc","abcd"]
19:54:19 <pumpkin> I guess mine is backwards :)
19:54:31 <Axman6> @src inits
19:54:31 <lambdabot> inits []     =  [[]]
19:54:31 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
19:54:36 <int-e> pumpkin: nope. did you miss the n>1 perhaps?
19:54:50 <pumpkin> int-e: nope :/
19:54:55 <pumpkin> ah well, I'll keep trying
19:55:44 <Axman6> @src undefined
19:55:45 <lambdabot> undefined =  error "Prelude.undefined"
19:55:45 <Axman6> >_>
19:55:59 <Axman6> @src error
19:56:00 <lambdabot> error s = throw (ErrorCall s)
19:56:03 <pumpkin> int-e: oh, I was just being stupid, got it now :P
19:56:17 <tehgeekmeister> mm_freak: that's weird, what's causing the <<loop>> is killing the parser thread that i don't need anymore, since i'm only parsing the first bit of input for profiling purposes: when i remove the killThread call, it doesn't <<loop>>, but it keeps waiting for the mvar to be emptied...
19:56:35 <pumpkin> Axman6: my favorite one is otherwise
19:56:44 <pumpkin> I thought it was special syntax
19:56:46 <pumpkin> but no!
19:56:52 <Axman6> eh, of course not!
19:56:55 <Axman6> heh*
19:57:10 <Axman6> i'd like never = False too :P
19:57:32 <pumpkin> lol
19:58:42 <Axman6> f x | never = unsafePerformIO (launchMissiles >> return 0) | x == x = x* f (x-1)
19:58:48 <pumpkin> lol
19:59:11 * wli is momentarily at a loss for a linear-time \xs -> zip (inits xs) (tails xs) implementation that doesn't involve effectively separate calls to inits and tails.
20:01:18 <mm_freak> wli: well, that can be done differently in different scenarios
20:01:26 <mm_freak> often, you wouldn't need an explicit split at all
20:01:47 <tehgeekmeister> could it be because i'm killing a thread that's calling a foreign function?
20:02:09 <tehgeekmeister> and the foreign code just keeps going?
20:02:45 <mm_freak> tehgeekmeister: i received <<loop>> for endless loops‚Ä¶  make sure you don't read an MVar, which is never written to
20:02:58 <mm_freak> that will cause the thread to be killed (if detected)
20:03:09 <mm_freak> since it would wait forever anyway
20:03:22 <tehgeekmeister> that's not happening
20:03:35 <tehgeekmeister> i'm killing the reader thread, and immediately after killing the producer thread
20:03:59 <mm_freak> kill the reader thread first
20:04:10 <tehgeekmeister> if i don't kill the producer thread, the code hangs (it's waiting for the mvar to be emptied)
20:04:20 <tehgeekmeister> i am killing the reader first
20:04:21 <mm_freak> but then, on the other hand, the producer thread may write to an MVar that is never read
20:04:44 <mm_freak> if there is no reason to kill explicitly, don't do it
20:05:00 <tehgeekmeister> how long should i expect to wait for it to exit on it's own?
20:05:11 <mm_freak> probably there is something wrong in your communication concept
20:05:17 <wli> > let splits [] = [([],[])] ; splits xxs@(x:xs) = ([], xxs) : map (first (x:)) (splits xs) in splits [1..3] -- not linear but inits isn't anyway
20:05:19 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
20:05:29 <mm_freak> you shouldn't‚Ä¶  as soon as the IO computation ends, the thread ceases to exist
20:05:58 <tehgeekmeister> hum.  i'm looking at it's cpu usage now
20:06:07 <tehgeekmeister> and even with the reader thread killed
20:06:15 <tehgeekmeister> it's using some 90% of the cpu
20:06:58 <tehgeekmeister> i suspect the problem is that hexpat doesn't stop parsing just because i've stopped consuming the input
20:08:04 <mm_freak> > takeWhile (not . null . snd) . iterate (\(xs,(y:ys)) -> (xs ++ [y], ys)) $ "abcde"
20:08:05 <lambdabot>   Couldn't match expected type `([a], [a])'
20:08:11 <blackh> @let let for_wli txt = (map (\(a,b) -> (reverse a, b)) . scanl (\(xs,c:ys) _ -> (c:xs,ys)) ("",txt)) txt
20:08:11 <lambdabot>   Parse error
20:08:13 <mm_freak> > takeWhile (not . null . snd) . iterate (\(xs,(y:ys)) -> (xs ++ [y], ys)) $ ("", "abcde")
20:08:15 <lambdabot>   [("","abcde"),("a","bcde"),("ab","cde"),("abc","de"),("abcd","e")]
20:08:27 <blackh> @let for_wli txt = (map (\(a,b) -> (reverse a, b)) . scanl (\(xs,c:ys) _ -> (c:xs,ys)) ("",txt)) txt
20:08:28 <lambdabot>  Defined.
20:08:33 <blackh> > for_wli "hello!"
20:08:34 <lambdabot>   [("","hello!"),("h","ello!"),("he","llo!"),("hel","lo!"),("hell","o!"),("he...
20:08:46 <blackh> wli: I had fun with that.
20:08:48 <pumpkin> mm_freak: you're doing ++ inside an iteration the length of the string though
20:09:04 <mm_freak> pumpkin: ?
20:09:10 <tehgeekmeister> hum.  yeah.  two minutes after the reader thread's killed it's still not closing.
20:09:16 <pumpkin> mm_freak: is that linear?
20:09:22 <mm_freak> pumpkin: it is
20:09:25 <pumpkin> hmm
20:09:38 <mm_freak> (++) is lazy on both arguments
20:10:42 <mm_freak> whatever you do, you need to construct the inits list anyway
20:11:40 <pumpkin> yeah, hmm
20:11:45 <mm_freak> i'd probably go with the zip or do something more specific
20:11:49 <Saizan> inits is not linear by itself
20:12:41 <Saizan> it has to produce O(n^2) (:)s
20:14:15 <scsibug> Wheee... this new HTTP library is rocking.  hS3 is actually usable now.
20:14:58 <jonaskoelker> quote for Simon Peyton Jones: "The universe does not actually disappear into your laptop when you run a haskell program"
20:15:01 <jonaskoelker> ;)
20:15:12 <gwern> scsibug: how much of a speedup?
20:15:24 <porges> @hoogle (MonadPlus m) => Bool -> a -> m a
20:15:25 <lambdabot> Control.Exception assert :: Bool -> a -> a
20:15:25 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
20:15:25 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
20:15:52 <mm_freak> ConfigFile is highly inconvenient
20:15:57 <mm_freak> any better alternative?
20:16:00 <pumpkin> porges: what would that do? :o
20:16:12 <gwern> mm_freak: I like reading and showing datatypes
20:16:24 <porges> @let ifM p x = if p then return x else mzero
20:16:25 <lambdabot>  Defined.
20:16:48 <mm_freak> gwern: a wanted to avoid that, but it seems like i'll be using that
20:17:10 <scsibug> gwern: my first criteria was simply "don't crash when uploading more than 50 megs"
20:17:22 <porges> if p then [x] else [] -> if p then return x else mzero -> ifM p x
20:17:23 <gwern> mm_freak: what's wrong with that approach? I think it very cleverly exploits and demonstrates the power of haskell types
20:17:24 <porges> :)
20:17:33 <mm_freak> gwern: any easy way to introduce default values by that?
20:17:33 <scsibug> but it's gone from about 15% CPU to between 0.5-2%
20:18:00 <FunctorSalad> launchMissiles = system "echo launched | aosd_cat" -- neat for understanding IO with immediate feedback :)
20:18:03 <scsibug> and memory usage is constant
20:18:18 <gwern> mm_freak: 'if file exists then read (readFile foo) :: MyType else return (MyType Foo Bar Baz)'? dunno
20:18:37 <mm_freak> gwern: for individual fields
20:18:51 <Axman6> scsibug: blog it!
20:18:58 <gwern> I guess you'd have to do that in the read instance
20:19:14 <mm_freak> in other words, i need to write my own parser =)
20:19:14 <gwern> when = "" then defaultValue, if you follow
20:19:14 <porges> pumpkin: just surprised it doesn't exist
20:19:20 * Axman6 refrains from adding brother to that last sentense
20:19:38 <Axman6> c*
20:19:46 <mm_freak> in yet other words, i could just go without Read ;)
20:19:56 <scsibug> Axman6: will do.  Gotta finish final touches to some library changes so that everything takes advantage of it.
20:20:08 <porges> pumpkin: because I don't like hlints "if b then [x] else [] ==> [x | b]
20:20:24 <scsibug> gwern: did you make the bytestring changes to HTTP?
20:20:36 <mm_freak> in fact, ConfigFile would be neat, if the author wouldn't insist on monads that much
20:21:57 <gwern> scsibug: alas, I didn't. I have occasional mentioned them however and wished that they could make it into the official HTTP lib
20:22:11 <gwern> scsibug: the bytestring version of HTTP was created back in '07, basically
20:22:46 <tehgeekmeister> what's the runtime option to enable profiling?
20:22:57 <gwern> +RTS -p -RTS?
20:24:21 <scsibug> gwern: Well, thanks for announcing it, and thanks to dons for posting it on reddit.  I've been wanting a bytestring-HTTP for literally years.  I made a feeble attempt to get it working a long time ago, but never quite figured it all out.
20:24:33 <wli> Who comes up with these Project Euler things?
20:24:37 <tehgeekmeister> bah, all that work so i could profile it, and the profiler tells me like nothing
20:24:53 <gwern> scsibug: well, I didn't really announce it
20:24:58 <gwern> although someone certainly should
20:25:32 <pumpkin> wli: the dude who runs the site, or member suggestions, I think
20:26:39 <wli> The 1-9 pandigital number thing was annoying.
20:26:53 <pumpkin> which one? there are so many :(
20:27:03 <pumpkin> they really like pandigital numbers there
20:27:12 <tehgeekmeister> oh!  -auto-all solves my problem.  oops.
20:28:10 <gwern> not the runtime's fault then
20:28:55 <dancor> the emacs hsc3 mode says "no hsc3 process running?" when i try to run a line; does that mean it's not seeing my 'sudo scsynth -u 57110' or that there is another actual hsc3 binary involved that i don't have
20:30:34 <tehgeekmeister> oh!  that's why it's so slow.  i love the profiler.
20:30:39 <tehgeekmeister> i'm spending 90% of my time appending to strings.
20:30:52 <gwern> 90%?
20:31:03 <tehgeekmeister> 94.9%, to be precise.
20:31:18 <tehgeekmeister> so if i can get rid of that, my code should be pretty fast.
20:31:27 <pumpkin> what are you appending and why?
20:32:00 <tehgeekmeister> hexpat doesn't always return the full body of the <text> tag in one chunk, so i'm appending each chunk as i get it to the text of the page
20:32:02 <gwern> fortunately we know how to fix string appending
20:33:14 <tehgeekmeister> gwern: how's that?
20:33:19 <blackh> tehgeekmeister: I'm using hexpat. You don't happen to know the author of it do you? I want to submit a patch.
20:33:30 <tehgeekmeister> blackh: no, not at all.
20:33:51 <blackh> tehgeekmeister: There's a bug: The tags under the root are reversed.
20:33:58 <gwern> tehgeekmeister: ShowS, iirc. or was it difference lists?
20:34:00 <porges> @info <<=
20:34:00 <lambdabot> (<<=)
20:34:12 <tehgeekmeister> blackh: seems to be martine@danga.com, evan martin
20:34:43 <porges> @hoogle <<=
20:34:44 <lambdabot> No results found
20:35:00 <blackh> tehgeekmeister: He's not replying. Perhaps I shouldn't have tried to sell him Viagra at the same time.
20:35:07 <blackh> :)
20:35:13 <tehgeekmeister> blackh: lul.
20:35:28 <tehgeekmeister> gwern: oh, that looks good.  constant time concatenation is good.
20:35:34 <Axman6> :t (<<=)
20:35:36 <lambdabot> Not in scope: `<<='
20:35:39 <wli> I see permutations, nonempty partitions of ascending size, and gcd's.
20:36:35 <porges> @info (=<<) -- :P
20:36:35 <lambdabot> (=<<)
20:36:41 <cjs>  Hey, where does one get the epub version of Real World Haskell?
20:36:47 <gwern> epub?
20:36:56 <cjs> http://www.realworldhaskell.org/blog/2008/11/22/real-world-haskell-in-the-wild/
20:37:07 <gwern> @where rwh
20:37:08 <lambdabot> is http://www.realworldhaskell.org/blog/
20:37:16 <tehgeekmeister> there's a digital version?!
20:37:21 <cjs> I have that exact reader, and that's just what I want.
20:37:48 <gwern> cjs: oh. well the article says that o'reilly sells PDF versions, doesn't it?
20:38:05 <cjs> (The reader, along with some 11,000-odd other books, is significantly lighter than this tome that's landed on my desk recenty. :-))
20:38:06 <Axman6> tehgeekmeister: it's not the final version (afaik), but it's pretty complete
20:38:21 <tehgeekmeister> gwern: i'm not quite sure how to use this, the documentation is a bit confusing
20:38:29 <cjs> Ah, O'Reilly sells the epub version as well.
20:38:41 <weakish> I heard that realworld haskell is under CC before.
20:38:50 <gwern> cjs: I'd like to get a reader some day myself, but I keep waiting for the picture quality to be better and for devices to get more open
20:39:01 <cjs> It's available for free as web pages.
20:39:04 <gwern> weakish: yes, that's true. there's even a half-done japanese translation because of it
20:39:28 * tehgeekmeister likes his kindle, even with its limitations
20:40:19 <cjs> gwern: The screen quality is great, except that the reflectivity is not quite as good as good quality paper. (It's about as good as a mass-market paperback.) The resolution is fine, and the reader is reasonably open. It reads PDFs and RTF and so on, there are tools make the sony format, and you can hack the OS if you like. (It's just Linux underneath.)
20:41:23 <gwern> and another problem is that I keep seeing wearable computers on the horizon, so a little voice goes 'why spend 200 or whatever bucks on a view, when you could just get a wearable computer which could do that and so much more?'
20:42:01 <porges> cjs: what model are you talking about? the page isn't loading for me :P
20:42:51 <cjs> I've got the PR-505. The wikipedia page gives lots of links to further stuff. The original link about the EPUB edition was http://ui3.info/d/rwh/
20:43:54 <orbitz> from the tone of RWH, it sounds like 'fail' is kind of a useless funciton in Monads, is that right?
20:44:00 <cjs> It's definitely annoying that, because I ordered the print copy before I knew that there was an EPUB version, I now have to pay $40 instead of $15 for the EPUB version.
20:44:24 <gwern> orbitz: yes. I understand fail is considered fail
20:44:36 <gwern> Cale could no doubt talk your ear off about it
20:44:58 <tehgeekmeister> gwern: using ShowS it actually takes even more of the run time.
20:45:16 <orbitz> gwern: i'll bring it up to him next time i'm not nearly ready for bed
20:45:21 <gwern> I guess that means ur doing it wrong?
20:46:07 <tehgeekmeister> well, to be fair, it's taking the majority of the time
20:46:24 <tehgeekmeister> but it's entered 43,000 some times, whereas no other function is entered more than 200.
20:46:30 <orbitz> i think i am missing something about Monads though.  Why doesn't a function like getLine take an IO a as input?  doesn't the crrent state of the IO universe have to come from somewhere?
20:47:00 <gwern> I think the idea is that main gets a RealWorld token, and then that gets passed around the io functions
20:47:22 <orbitz> how though?  it is not in any of the type signatures of these functions
20:47:24 <orbitz> :t getLine
20:47:25 <lambdabot> IO String
20:47:53 <idnar> orbitz: it's implicit
20:47:58 <idnar> @src IO
20:47:58 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:48:12 <idnar> orbitz: or, to put it another way, it's part of what IO means
20:48:43 <orbitz> so in real-life, getLine is taking a real world state as input?
20:48:57 <idnar> IO doesn't necessarily have to be a a function under the hood
20:49:15 <orbitz> what do you mean?
20:49:29 <idnar> well, I mean, that newtype lambdabot spat out is what ghc does
20:49:45 <idnar> but it's defined differently in different implementations
20:49:54 <orbitz> ok
20:50:04 <idnar> but regardless of how it's actually defined, IO String conceptually means "a magic box that takes the state of the real world and turns it into a new state and a String"
20:50:28 <porges> orbitz: you want a comonad :)
20:50:33 <idnar> however, you only need to feed the real world state into that box at execution time
20:50:41 <porges> then getLine would be IO -> String
20:51:00 <orbitz> when i do:  foo = getLine >>= putStrLn,  the type sig is goign ot be IO (), but IO a -> IO ().  i'm just confued about how that function operates since it seems like it would need the current state of the world as input
20:51:14 <idnar> orbitz: it does, but only when the IO action is *executed*
20:51:24 <idnar> orbitz: getLine >>= putStrLn doesn't execute anything
20:51:56 <orbitz> udner the hood, is the compiler saying "Oh, this returns an IO a, I need to pass in the world wiht this call" ?
20:52:06 <idnar> orbitz: no, the point is that the world isn't being passed in yet
20:52:09 <jml> depends on the compiler, actually :)
20:52:11 <Saizan> orbitz: that's what >>= does
20:52:15 <idnar> orbitz: nothing has actually *happened*, you've just constructed a new magic box
20:52:20 <orbitz> where does >>= get the world from though?
20:52:36 <Saizan> from the result of the previous action
20:53:36 <porges> does anyone know of a generalization for MonadPlus to give something similar to ShowS for mplus?
20:53:51 <cjs> orbitz: You want to carefully look at the type of >>=.
20:53:55 <idnar> orbitz: there are two ways for an IO action to actually be executed
20:53:59 <idnar> orbitz: one is to assign it to main
20:54:13 <idnar> orbitz: in which case, the runtime passes the real world state in when it actually executes main
20:54:22 <cjs> orbitz: Or maybe, better, read the Functional Parsers chapter of the Graham Hutton book. After about three goes at that, monads suddenly clicked.
20:54:23 <orbitz> hrm. so 'main' is just an action.  so would it be correct to say main = getLine >>= putStrLn look slike (in terms of flow) RealWorld >>= main >> getStrLn >>= putStrLn ?
20:54:25 <Saizan> understanding a "pure" monad like Maybe or State is going to be easier, since you can actually look at the implementation of >>=
20:54:26 <tehgeekmeister> gwern: dons apparently has a list type that does efficient appends, so i suppose i could use it and then convert from the special list type to string at the end of parsing a page?
20:54:29 <idnar> orbitz: the other is unsafePerformIO, which gets a RealWorld from a shady drug dealer and passes it in
20:55:04 <orbitz> idnar: haah
20:55:39 <Saizan> tehgeekmeister: that special list type is just [a] -> [a], btw
20:55:54 <idnar> but aside from those two things, you're basically just connecting pipes that don't yet have any water flowing through them
20:56:32 <tehgeekmeister> Saizan: i don't even understand that type declaration...
20:56:32 <orbitz> i think i was missing the 'main' part here.  if i undertand correctly now, main has an input of the real world adn then >>= and >> are modifying teh state all along the way, so the real word just gets passed everywhere
20:57:11 <idnar> orbitz: yes, it's sort of similar to function composition
20:57:22 <gwern> tehgeekmeister: isn't that what you were doing with ShowS?
20:57:38 <Saizan> tehgeekmeister: a function from a list to a list
20:57:38 <idnar> if you have f . g, f gets an argument from the result of g; but of course, there's no result of g until you actually apply the resulting function to an argument
20:57:50 <tehgeekmeister> gwern: i think
20:57:59 <orbitz> idnar: i think my problem was, i was thinking of foo = putStrLn "hi" as being isolated, and forgot that that has to be executed via  >> so of coures it implicitly has the real world passed to it
20:58:24 <tehgeekmeister> appendToContent str page = page {pageContent = newContent} where newContent = (showString $ pageContent page) str
20:58:27 <tehgeekmeister> that's my append function
20:58:31 <Saizan> and yeah DList is the same concept as ShowS
20:58:48 <orbitz> figuring out concepts in haskell is very mentaly rewarding
20:58:57 <tehgeekmeister> orbitz: yes it is.
21:00:30 <tehgeekmeister> maybe it's taking so much time just because it's being called forty three thousand some times, then?
21:00:43 <tehgeekmeister> i can't see how long it's taking per call in this report
21:01:44 <Saizan> ?type showString
21:01:45 <lambdabot> String -> String -> String
21:02:23 <tehgeekmeister> maybe it'd be faster if i composed all of them, and then converted it later?
21:02:34 <Saizan> tehgeekmeister: if you use showString like that it's not going to be faster than just appending
21:02:39 <pumpkin> @src scanl
21:02:39 <lambdabot> scanl f q ls = q : case ls of
21:02:39 <lambdabot>     []   -> []
21:02:39 <lambdabot>     x:xs -> scanl f (f q x) xs
21:02:40 <pumpkin> @src scanl1
21:02:40 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
21:02:40 <lambdabot> scanl1 _ []     =  []
21:03:05 <tehgeekmeister> Saizan: do i need to compose a bunch of calls to it, or what?
21:03:12 <Saizan> yeah
21:03:29 <Axman6> > scanl1 f [a,b,c,d]
21:03:30 <tehgeekmeister> *thinks how to do that
21:03:31 <lambdabot>   [a,f a b,f (f a b) c,f (f (f a b) c) d]
21:04:01 <Saizan> instead of ((a ++ b) ++ c) ++ d) you need (a++) . (b ++) . (c ++) . (d++)
21:04:08 <Saizan> and apply that to [] in the end
21:05:01 <orbitz> can I play with the Maybe monad in ghci?   I think i'm doing something wrong as it keep son wanting to pass the IO Monad around
21:05:49 <ozy`> orbitz: can't you use curly braces to put it all on one line?
21:06:06 <Saizan> > Just 1 >> Just 2
21:06:07 <lambdabot>   Just 2
21:06:16 <Saizan> what problem are you having?
21:06:20 <pumpkin> ...and by the pigeonhole principle, there exist two people in this room who have the same birthday and month
21:06:52 <Saizan> unless there are actually a lot of clones
21:06:59 <orbitz> whoops, i didn't have a  return. i was tryign to do Just 1 >>= \x -> x * 2
21:07:24 <geezusfreeek> ?users
21:07:24 <lambdabot> Maximum users seen in #haskell: 568, currently: 523 (92.1%), active: 14 (2.7%)
21:07:29 <orbitz> pumpkin: probbly even more base don birthday paradox
21:07:43 <pumpkin> orbitz: yeah, I just said that there exist two people :P probably many more
21:07:51 <pumpkin> in fact, certainly many more :P
21:07:56 <BMeph> Saizan: What - clones don't have birthdays in your world? What are you, some kind of geneist? ;p
21:08:20 <orbitz> BMeph: chauvenist genist pig!
21:08:28 <mm_freak> gwern: i'm using a Read-based solution now
21:09:07 <orbitz> bed time. Saizan, idnar thanks for the help
21:10:22 <mm_freak> http://hpaste.org/13248
21:11:29 <tehgeekmeister> !!!
21:11:34 <tehgeekmeister> it takes 1/10th of the time, so far
21:11:40 <tehgeekmeister> and almost  none of that is in append.
21:12:27 <mm_freak> > fmap (*2) $ Just 3
21:12:28 <lambdabot>   Just 6
21:12:45 <Saizan> heh :)
21:13:13 <pumpkin> is there a name for :[] ?
21:13:16 <pumpkin> as a function
21:13:18 <pumpkin> not as a monkey
21:13:20 <Saizan> tehgeekmeister: btw, do you see why a left associated chain of (++) is very slow?
21:13:22 <sjanssen> pumpkin: return
21:13:31 <pumpkin> oh good idea
21:13:49 <mm_freak> (: []) 1
21:13:51 <mm_freak> > (: []) 1
21:13:53 <lambdabot>   [1]
21:14:32 <pumpkin> so sneaky!
21:14:33 <pumpkin> ;)
21:14:46 <pumpkin> although it is kinda long compared to monkeyface
21:15:00 <Axman6> http://www.reddit.com/r/programming/comments/7kttg/given_that_we_are_going_to_have_1024_core_cpus_in/ ha
21:15:06 <tehgeekmeister> Saizan: yes, i do, i just didn't realize i was doing it.  and didn't know how to get around it.
21:15:12 <mm_freak> > (:[]) 1
21:15:14 <lambdabot>   [1]
21:22:09 <wli> Hmm, shouldn't Math.Statistics.Fusion sort the numbers it's going to sum?
21:22:51 <scook0> damn it, how am I supposed to conduct a conversation on reddit when I can only post once every 7 minutes? :/
21:24:22 <shapr> @users
21:24:22 <lambdabot> Maximum users seen in #haskell: 568, currently: 524 (92.3%), active: 16 (3.1%)
21:24:39 <shapr> What's the recent max? about 570?
21:27:53 * wli checks out the ars technica article saying more than 16 cores may very well be useless.
21:29:33 <blackh> wli: People think so small!
21:29:50 <wli> Heh, they're practically predicting the resurrection of COMA.
21:30:07 <wli> blackh: Not I; I've hacked on much bigger boxen than that.
21:31:32 <porges> @src shows
21:31:32 <lambdabot> Source not found. :(
21:31:37 <porges> :/
21:34:07 <jeffwheeler> Doesn't it depend on the implementing type?
21:34:20 <jeffwheeler> > shows 1
21:34:22 <lambdabot>       Overlapping instances for Show (String -> String)
21:34:22 <lambdabot>        arising from a...
21:35:31 <Axman6> :t shows
21:35:32 <lambdabot> forall a. (Show a) => a -> String -> String
21:36:26 <porges> I think it's just shows x s = show x ++ s?
21:38:25 <nj32> Where can I find source of prelude.hs on my Ubuntu, I installed ghc from apt.
21:38:32 <Axman6> > shows 1 . shows "hello" . shows (Just 10) $ ""
21:38:33 <lambdabot>   "1\"hello\"Just 10"
21:41:05 * wli has some rather big fish to fry with solving systems of quadratic equations.
21:42:41 <mm_freak> ClockTime has no Read instance, so what is the best way to read a string time?
21:43:00 <mm_freak> CalendarTime?
21:43:33 <juhp> are HTTP 3001.1.5 and 4000.0.0 incompatible?
21:43:43 <porges> @src showString
21:43:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:43:51 <juhp> the modules that overlap i mean
21:47:03 * tehgeekmeister celebrates his finally working code
21:47:47 <Pseudonym> You mean it compiles?
21:47:57 <tehgeekmeister> oh no, it does what it's supposed to, even
21:48:04 <tehgeekmeister> and fast enough that i'm willing to wait for it
21:48:05 <Axman6> bonus!
21:48:37 <tehgeekmeister> and it's IO bound, so i know i didn't totally botch my coding, either
21:50:11 <mm_freak> got it:  Data.Time =)
21:52:41 <Cale> tehgeekmeister: sounds good :)
21:53:10 <tehgeekmeister> took awhile, but after a year of playing with it in my spare time, i can finally do useful things with haskell.
21:53:58 <wli> It took me 10 years to learn how to use monads. If I can do it, anyone can.
21:54:15 <shachaf> nj32: You probably can't.
21:54:36 <shachaf> nj32: Unless you get the source of GHC also. I don't think it's included in the binary.
21:54:54 <nj32> shachaf: i have 6.8.2, where can i get it on web
21:55:02 <Cale> Can't what?
21:55:08 <shachaf> nj32: You could apt-get source ghc, I guess.
21:55:16 <nj32> ok
21:55:17 <Cale> oh, find the Prelude source
21:55:22 <nj32> yeha
21:55:31 <porges> http://darcs.haskell.org/packages/base/Prelude.hs
21:55:33 <Cale> It's sad that the current docs don't have source links
21:55:47 <Cale> But the previous versions, and in particular 6.8.2's library docs do.
21:55:49 <shachaf> Yes, or that. :-)
21:56:01 <nj32> porges: thanks
21:56:05 <shachaf> @source Prelude
21:56:05 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
21:56:06 <Cale> In fact, they may even be installed with the documentation.
21:56:19 <porges> Everything is in the GHC.* packages though :)
21:56:38 <Cale> (the source for those is included as well)
21:56:54 <tehgeekmeister> wow, my code might actually turn out to be faster than the perl version which was the previous champion.  =D
21:56:58 <nj32> shachaf: do i need to install source from apt to get documentation?
21:57:54 <jeffz`> nj32: ghc6-doc
21:58:33 <nj32> jeffz`: ok
22:00:50 <ozy`> tehgeekmeister: what problem is this again?
22:01:21 <tehgeekmeister> ozy`: oh it's nothing too complicated; populating a database from the xml dump of a wikipedia
22:01:37 <ozy`> tehgeekmeister: dude.... far out
22:01:52 <tehgeekmeister> ozy`: ?
22:02:03 <ozy`> ¬Ø\O_o/¬Ø
22:02:29 <tehgeekmeister> the next step will be the fun part
22:02:54 <tehgeekmeister> i'm going to turn a foreign language wikipedia into a graded reader, of sorts
22:04:33 <tehgeekmeister> anyone here used missingpy much?
22:13:15 <cjb> tehgeekmeister: I guess we (One Laptop per Child) would be interested in the result, but it sounds intractable to me.
22:13:27 <cjb> or well, that you would likely get lousy results.
22:13:47 <tehgeekmeister> it's solves a very, very, very limited part of a huge problem
22:14:03 <tehgeekmeister> i'm only using wikipedia for now because it's a huge source of text that's already formatted in one way
22:14:18 <tehgeekmeister> i don't have to fight many different text formats like i would using project gutenberg
22:14:58 <tehgeekmeister> even then, tho, it's a limited approach from the start.
22:15:18 <tehgeekmeister> i'll be posting to my blog about it very soon, tho, so if you follow planet haskell you'll see how it turned out.
22:15:38 <cjb> cool, ok
22:21:41 <BMeph> Cale: ping
22:21:57 <Cale> pong
22:22:35 <BMeph> Cale: Ah, good, I thought I saw you on. Anyway, I found out where I saw the claim for flip bind being the Kleene star.
22:22:57 <BMeph> Cale: It's in Stefan Klinger's Monad tutorial.
22:22:58 <Cale> ah, where is that?
22:24:54 <BMeph> Cale: Acording to the wiki page, http://stefan-klinger.de/files/monadGuide.pdf is a good link. :)
22:26:18 <Cale> Oh, he calls it the Kleisli star
22:26:52 <Cale> That name makes a little more sense :)
22:33:28 <BMeph> Cale; Oh, yeah, I called it a Kleene star. That's my dumb-@$$ fuzziness with all of this new (to me) knowledge error. Sorry about that.
22:34:10 <BMeph> Cale: They always say that getting the right terminology solves about 90% of your problem. I guess I just showed how true that saying is. ;p
22:34:36 <loop> isn't kleene star the * -operator in regexen?
22:43:16 <Cale> loop: yeah
22:52:19 <nj32> i want to understand this choice: why should -- foldl (*) 3 [] -- return 3?
22:53:11 <jeffwheeler> nj32: what else would it return? It doesn't have anything to multiply 3 by.
22:53:45 <loop> @src foldl
22:53:46 <lambdabot> foldl f z []     = z
22:53:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:54:00 <loop> => foldl (*) 3 [] = 3
22:54:09 <nj32> then why should it be defined for empty list?
22:54:39 <jeffwheeler> nj32: that's why fold1 and foldr1 exist; they don't have default values.
22:54:50 <jeffwheeler> > foldl1 []
22:54:51 <lambdabot>   Couldn't match expected type `a -> a -> a'
22:54:52 <jeffwheeler> err
22:54:56 <jeffwheeler> > foldl1 (*3) []
22:54:58 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
22:54:58 <lambdabot>      Proba...
22:55:00 <jeffwheeler> gah
22:55:28 <loop> > foldl1 (*) []
22:55:29 <lambdabot>   * Exception: Prelude.foldl1: empty list
22:55:32 <jeffwheeler> that's the one
22:55:53 <nj32> when would you want to use foldl instead of foldl1?
22:56:19 <Cale> Almost always? foldl works in the empty list case
22:56:21 <jeffwheeler> nj32: what if you're summing up numbers and you don't know whether your list will be empty?
22:56:41 <Axman6> sum xs = foldl' (+) 0 xs -- nj32 if xs is empty, the sum is 0
22:56:41 <jeffwheeler> nj32: in that case, you use 0 as your default value
22:56:59 <dibblego> foldl is a generalisation of foldl1; you can derive foldl1 from foldl but not the other way around
22:57:08 <nj32> i seem to get it
23:01:01 <idnar> dibblego: why not the other way around?
23:01:40 <dibblego> idnar, foldl1 fails on [] (for a start)
23:01:40 <idnar> wouldn't "foldl f z xs = foldl1 f z:xs" work?
23:02:27 <dibblego> that's not foldl
23:02:46 <dibblego> @type \f z xs -> foldl1 f (z:xs)
23:02:47 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
23:03:01 <idnar> @type foldl
23:03:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:03:24 <idnar> oh, of course
23:03:56 <jeffwheeler> > do dir <- [(+1), (*2)] ; return $ take 5 $ iterate dir 1 } -- I can't wrap my head around this code
23:03:57 <lambdabot>   <no location info>: parse error on input `;'
23:04:06 <jeffwheeler> > do { dir <- [(+1), (*2)] ; return $ take 5 $ iterate dir 1 } -- I can't wrap my head around this code
23:04:08 <lambdabot>   [[1,2,3,4,5],[1,2,4,8,16]]
23:04:21 <davidL> @src toLower
23:04:22 <lambdabot> Source not found. I feel much better now.
23:04:26 <Cale> jeffwheeler: dir is selected from that list of functions
23:04:47 <Cale> jeffwheeler: in all possible ways, and the results are collected in a list
23:05:38 <Cale> > [take 5 (iterate dir 1) | dir <- [(+1),(*2)]]
23:05:39 <lambdabot>   [[1,2,3,4,5],[1,2,4,8,16]]
23:05:43 <jeffwheeler> Cale: hmm, yep. And iterate applies the function, um, iteratively to 1 so that it gets [1, 1 (+1), (1 (+1)) (+1) ..] and the same for (*2)
23:05:48 <Cale> yes
23:05:56 <Cale> > iterate (+1) 1
23:05:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:06:04 <Cale> > iterate (*2) 1
23:06:05 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:06:15 <jeffwheeler> That code is _really_ neat.
23:10:25 <nj32> how is the pattern matched in unnamed function of -- last1 = foldl1 (\_ x -> x)  -- when i do: last1 [5]
23:11:01 <nj32> last1 :: [a] -> a
23:11:10 <idnar> @type (\_ x -> x)
23:11:11 <lambdabot> forall t t1. t -> t1 -> t1
23:12:12 <nj32> you mean, nothing matches with _ ?
23:12:20 <dibblego> @pl \_ x -> x
23:12:20 <lambdabot> const id
23:12:31 <idnar> nj32: _ matches anything and then throws it away
23:12:41 <idnar> it's basically the same as \y x -> x
23:12:46 <augustss> nj32: The function is not used at all for the list [5]
23:13:15 <jeffwheeler> > foldl1 (error "test") [5]
23:13:16 <augustss> > foldl1 undefined [5]
23:13:17 <lambdabot>   5
23:13:18 <lambdabot>   5
23:13:50 <nj32> augustss: then there was no use of writing it ?
23:14:09 <jeffwheeler> nj32: it would be used if you gave a longer list.
23:14:16 <augustss> nj32: not if all you're going to use is lists with one element
23:14:36 <nj32> hmm
23:14:38 <pumpkin> > 2**((30.403243784) - ((-1)**2)) :: CReal -- is this normal?
23:14:39 <lambdabot>   * Exception: log of negative number
23:14:56 <augustss> pumpkin: looks normal to me
23:15:08 <pumpkin> > 2**((30.403243784) - ((-1)**2)) :: Double -- vs. this?
23:15:09 <lambdabot>   7.10000000139659e8
23:15:19 <augustss> That's the unnormal one.
23:15:36 <pumpkin> why? where's the log coming from?
23:15:53 <loop> (**) uses logarithm?
23:16:00 <augustss> The default implementation of ** is with log and exp
23:16:03 <jeffwheeler> @src (**)
23:16:03 <lambdabot> Source not found. I feel much better now.
23:16:09 <pumpkin> hmm
23:16:24 <augustss> x ** y = exp (log x * y)
23:16:30 <pumpkin> > ((-1)**2) :: CReal
23:16:31 <lambdabot>   * Exception: log of negative number
23:16:45 <pumpkin> that seems unreasonable of it :P
23:16:50 <augustss> But for Double it calls the C function pow which has a hack.
23:17:06 <augustss> > (-1)**2.1
23:17:07 <lambdabot>   NaN
23:17:38 <mm_freak> how can i export a data type together with its constructors and field functions?
23:17:45 <augustss> pumpkin: Use ^ for integral exponents
23:17:48 <mm_freak> without having to name each explicitly
23:17:53 <pumpkin> augustss: it isn't guaranteed to be integral though
23:17:56 <augustss> mm_freak: T(..)
23:17:56 <pumpkin> it just happens to be here
23:18:10 <augustss> pumpkin: Then you need complex numbers
23:18:14 <mm_freak> thanks
23:18:42 <augustss> > ((-1)**2.2) :: Complex Double
23:18:44 <lambdabot>   0.809016994374947 :+ (-0.5877852522924736)
23:18:51 <pumpkin> aha, it gives me the right answer for Complex CReal, even if the imaginary part is 0
23:19:00 <pumpkin> > 2**((30.403243784) - ((-1)**2)) :: Complex CReal -- aha
23:19:02 <lambdabot>   710000000.1396586678369581429508299259447261719598 :+ 0.0
23:40:26 <augustss> > 2**((30.403243784) - ((-1)**2.1)) :: Complex CReal
23:40:30 <lambdabot>   717715200.141524418679128313623149582803683759673 :+ (-156125445.7688990599...
23:40:56 <pumpkin> :)
23:41:04 <augustss> > 2**((30.403243784) - ((-1)**2.00000000000001)) :: Complex CReal
23:41:07 <lambdabot>   710000000.1396586678369581430253517845120401022674 :+ (-0.00001546086124419...
23:42:36 <augustss> I like how Complex just works for new types.  It's one of the many cool things about Haskell.
23:42:58 <pumpkin> yeah
23:44:08 <mxc> http://bash.org/?152037
23:44:30 <dancor> parametric-polymorphism++
23:45:25 <Axman6> oh, i thought it was something that needed to be specified, awesome :)
23:45:27 * dancor almost trolled #emacs the other day for a similar reason
23:45:47 <Beelsebob_> mxc: so so true
23:45:55 <Axman6> mxc: the 'you need to troll to get answers' one?
23:46:05 <dancor> instead i never figured out how to do my thing heh
23:46:08 <mxc> haskell sucks because you can't use GTK on OSX with 10.5 and ghc 6.10.x
23:46:17 <mxc> step 2...
23:46:20 <mxc> step 3: profit
23:46:39 * Axman6 plays the Haskell user
23:47:01 <Axman6> mxc: you're right, i'm so sorry. it'll be fixed by Q3 2009 though :)
23:47:02 <dancor> act 1
23:47:06 <Axman6> here, have a lambda
23:47:07 <pumpkin> gtk sucks anyway
23:47:46 <mxc> dammit
23:49:30 <solrize_> :k Complex
23:49:31 <lambdabot> * -> *
23:50:18 <Axman6> @src Complex
23:50:19 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
23:50:46 <Axman6> any particular reason it's strict?
23:51:27 <dmwit> efficiency?
23:51:42 <dmwit> It probably isn't used with anything but Double, anyway.
23:52:08 <adrian> @src fix
23:52:08 <lambdabot> fix f = let x = f x in x
23:52:43 <augustss> Axman6: Efficiency, yes.
23:53:04 <Axman6> yeah i guess complex thunks could be complex
23:53:05 <Axman6> >_>
23:53:56 <augustss> Axman6: I can't think of any real life use of Complex which is non-strict in the real and imaginary parts.
23:54:50 <pumpkin> > 1 :: Complex (Complex Double)
23:54:51 <lambdabot>       No instance for (RealFloat (Complex Double))
23:54:51 <lambdabot>        arising from the li...
23:55:42 <augustss> Yeah, Complex has demands. :)
23:56:06 <Axman6> if programming languages were cars: "Cobol   is reputed to be a car, but no self-respecting driver will ever admit having driven one."
23:57:03 <dancor> Complex is not your average (,)
23:58:41 <dancor> well Pair is better than (,) there i guess since types should be same
23:58:52 <dancor> or Point
23:59:24 <Axman6> Haskell   is an incredibly elegantly-designed and beautiful car, which is rumored to be able to drive over extremely strange terrain. The one time you tried to drive it, it didn't actually drive along the road; instead, it made copies of itself and the road, with each successive copy of the road having the car a little further along. It's supposed to be possible to drive it in a more conventional way, but you don't know enough math to figure
