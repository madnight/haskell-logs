00:07:05 <pumpkin> :t unzip
00:07:06 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
00:07:16 <pumpkin> that's fun
00:09:40 <Olathe> Is there a Haskell parser in the standard library ?
00:10:15 <Cale> Hehe, I just gave rking from #math a very quick tour of Haskell by solving a Risk (board game) simulation problem he wanted to solve :)
00:10:18 <int-e> Olathe: have you seen http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-exts ?
00:10:40 <int80_h> hmm RISK AI...
00:10:47 * int80_h is a big RISK fan.
00:10:50 <Cale> I used the random variable monad :)
00:11:14 <Cale> (he wanted to compute the probabilities of various outcomes of a campaign)
00:11:47 <int-e> Gracenotes: regarding your "fun problem" yesterday, have a look at http://int-e.home.tlink.de/tmp/g.hs
00:11:48 <Olathe> int-e: Thanks
00:12:02 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=705#a706 -- here's the code, modulo a "collect $" tacked on to the campaign function.
00:12:48 <NameAlreadyInUse> do the brackets in "a -> a ()" mean "action"?
00:12:56 <Cale> campaign n ms  represents the outcomes of a campaign starting with n attackers against the chain of defenders ms
00:12:56 <vixey> no
00:12:57 <int-e> Gracenotes: (I hope there are no bugs. If the result is indeed correct, I'll be impressed if there is a closed formula for it.)
00:13:02 <vixey> also that's a kind error
00:13:12 <vixey> (non well formed type)
00:13:20 <int-e> NameAlreadyInUse: () is a data type with a single element, ().
00:13:25 <Cale> NameAlreadyInUse: () is the type of the empty tuple
00:13:40 <Cale> :)
00:13:45 <Olathe> () is the Circle of Life.
00:13:54 <Gracenotes> int-e: *me reviews*
00:14:11 <Cale> NameAlreadyInUse: various actions will return () when they have nothing else of interest to produce
00:14:37 <mnpn> "tupil" is this similar to "tuple" or "tulip"?
00:14:57 <Cale> mnpn: I think it's intended to be similar to tuple.
00:15:18 <Cale> (if you're referring to the company)
00:15:22 <Gracenotes> int-e: on the other hand, though, patterns with bins-in-boxes problems seem to be more obvious for larger n's
00:15:47 <NameAlreadyInUse> so what does it mean when something is like "a -> IO ()"
00:15:49 <Cale> Their logo is (,) if I recall correctly
00:16:07 <int-e> NameAlreadyInUse: in any case, as functions have to return a value in Haskell, () is used in the case that that value is not important. (pure functions returning () are rare - they are generally useless. IO actions returning () are common, because there can be side effects.)
00:16:11 <Cale> NameAlreadyInUse: it's a function from values of type a to IO actions which return nothing of interest.
00:16:15 <mnpn> that makes sense
00:16:23 <mnpn> too bad a computer wouldnt get it
00:16:45 <Cale> :t (,) tupil
00:16:46 <lambdabot> Not in scope: `tupil'
00:16:50 <Cale> :t (,)
00:16:52 <lambdabot> forall a b. a -> b -> (a, b)
00:16:59 <Cale> :k (,)
00:17:01 <lambdabot> * -> * -> *
00:18:22 <sereven> might be tulip also, since it's a dutch company and (,) looks sort of like a tulip as well as tupl-izing
00:18:56 <Cale> I think quantum-arrow might have the most awesome sounding name of any of the packages on Hackage so far.
00:19:03 <mnpn> its a hard symbol for a human to understand w/o the name next to it also
00:19:27 <Gracenotes> int-e: on the other hand, it might just be too complicated... an easier problem might be if more than one person picked the same seat, no one would get it, instead of one person getting it
00:20:35 <mnpn> the seat problem, can be scaled smaller by induction
00:20:35 <dmwit> derangements!
00:20:40 <dmwit> learn them
00:20:43 <dmwit> they are awesome
00:20:48 <pumpkin> there's a hackage package for them
00:20:58 <Gracenotes> dmwit: I recall derangements mentioned from a lecture...
00:21:04 <int-e> Gracenotes: hmm, why would that be simpler? btw, if you plan to run that program, use Double instead of Rational - the program as linked takes ages (a few hours)
00:21:14 <mnpn> ...sans emergent properties, which the seats one doesnt seem to have
00:21:18 <Cale> P ~> I * D
00:21:36 <Gracenotes> a formula for derangements can be derived from inclusion/exclusion, right?
00:21:43 <Cale> Which is only directly recognisable by perhaps hundreds of people in the world ;)
00:21:43 <int-e> Gracenotes: yes.
00:21:46 <dmwit> Cale: Whoops, you seem to be using term symbols as type operators... ;-)
00:21:54 <Cale> Gracenotes: The exponential generating series is easier.
00:22:15 <Cale> Every permutation is an identity part together with a derangement.
00:22:29 <int-e> Gracenotes: iterating the process will still complicate things, I expect. (Unless there's a lucky accident.)
00:22:30 <pumpkin> it's annoying that the gnuplot package doesn't seem to allow any nondefault terminal other than eps :(
00:22:47 <Cale> So the e.g.s. for permutations is the product of the e.g.s. for identity permutations with the e.g.s. for derangements.
00:22:48 <dmwit> Hack it!
00:22:57 <dmwit> That's why it's called Hackage. ;-)
00:23:00 <pumpkin> lol
00:23:11 <pumpkin> maybe I will!
00:23:11 <Cale> that is, 1/(1-x) = D(x) e^x
00:23:30 <Cale> and so D(x) = e^-x / (1-x), is the e.g.s for derangements :)
00:23:56 <cjs> Hey, I don't get the removeInv function from The STM chapter of RWH. Am I just really dumb, or is it quite broken?
00:23:57 <Cale> Nice simple example of an indirect combinatorial decomposition. :)
00:24:17 <cjs> http://book.realworldhaskell.org/read/software-transactional-memory.html and search for "removeInv"...
00:25:44 <Cale> The P ~> I * D thing expresses the bijection using something called a star product, which I think is perhaps less widely known than it should be, but it's behind the idea of exponential generating series.
00:25:54 <Cale> (lots of people neglect to talk about it directly though)
00:27:04 <Gracenotes> so much combinatorics/set theory/number theory/category theory to learn, so little time :/
00:29:06 <Gracenotes> I'll probably take a few more pure math classes than I planned to take....
00:29:31 <pumpkin> so no combinatorics? :(
00:29:39 <pumpkin> :P
00:32:54 <vixey> I think contextual closure is synonymous with compatible closure
00:33:50 <vixey> anyone happen to know if it is true?
00:39:29 <ivanm> @go "contextual closure" "compatible closure"
00:39:43 <lambdabot> http://www.loria.fr/~larchey/papers/TCS2000.ps.gz
00:44:53 <vixey> ivanm, this is an answer for me?
00:45:10 <ivanm> vixey: yeah ;-)
00:45:19 <vixey> ivanm, I don't find anything in this
00:45:20 <ivanm> let's see if lambdabot+google are smart enough to answer you
00:45:27 <ivanm> vixey: I guess they're not then :(
00:45:37 <vixey> not really I just wasted my time skimming this paper
00:47:07 <greenrd> This question is not haskell-specific, but... I wrote a haskell program to answer the question "Why is wiki article X (indirectly) in category Y?" and it draws graphs like this: http://img296.imageshack.us/img296/1750/catsva1.jpg
00:47:22 <greenrd> I think this graph contains some unnecessary information, however
00:47:42 <greenrd> but I'm not sure how to define what counts as "unnecessary" information
00:48:08 <pumpkin> what was the query that generated that graph?
00:48:28 <pumpkin> why is VUE in free software?
00:48:33 <greenrd> yes
00:49:02 <pumpkin> wouldn't it just be the shortest path between them?
00:49:56 <cjs> @seen dons
00:49:56 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 5h 2m 14s ago.
00:50:01 <cjs> @seen bos
00:50:02 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 2h 12m 35s ago.
00:50:11 <greenrd> well, no, because there might be multiple paths between them, and if you were to remove one subcategory from its parent, it wouldn't necessarily affect all the paths
00:50:32 <pumpkin> well yeah, but a quick answer to a question
00:50:43 <pumpkin> a shortest path would be a valid answer to the question wouldn't it?
00:50:47 <pumpkin> it obviously wouldn't be complete
00:51:00 <greenrd> so I want to see all paths, to see if it's feasible to change the category structure to make it so that VUE is no longer in Free Software
00:51:09 <pumpkin> oh
00:52:11 <greenrd> but the loop that goes through KDE and X Window System (at the bottom of the graph) doesn't seem to be helpful
00:53:06 <greenrd> I mean, it might be an undesirable category loop, but it's not really relevant to my query
00:53:36 <pumpkin> would loops ever be relevant to your query?
00:54:00 <greenrd> well, except the one path in that loop that is part of a path from Free Software to VUE
00:54:36 <pumpkin> so what you really want to get rid of is the Qt category and its two edges?
00:55:09 <greenrd> well, I don't know - what criteria should I use to decide what to get rid of?
00:55:15 <pumpkin> that's what I would do
00:55:41 <pumpkin> you're only interested in edges that contain a non-loopy path from free software to vue, I guess?
00:55:55 <pumpkin> the only way the Qt edges could make it in are if you allowed loopy paths :P
00:56:53 <pumpkin> that's what I would guess, at least
00:57:24 <pumpkin> it would also get rid of that edge from X Window System to GTK
00:57:35 <vixey> Cale, you know we were talking about powersets in type theory, It's actually a theorem that if you add them, A \/ ~A becomes a theorem, so your logic become classicala
00:58:04 <vixey> (came across a paper about it earlier)
00:58:46 <pumpkin> greenrd: does that make any sense?
00:59:04 <greenrd> yeah, because including loops only allows you to have paths with repeated nodes, which is pointless
00:59:49 <xenoblitz> can some one help me with this please? http://hpaste.org/13471
01:00:22 <vixey> xenoblitz, try module Program where ( Program ( (:>),
01:00:36 <pumpkin> it's line 12 though
01:00:37 <hydo> Should the aspiring haskell programmer decide to build as their first project a cross platform desktop application, they should use _____ as the gui library.
01:00:40 <vixey> xenoblitz, oops nevermind the 'where' you got that bit right
01:00:47 <greenrd> but like I said, I can't delete *all* edges that are part of a loop, because some of them are on a valid path
01:01:06 <hydo> I'm thinking glade... though windows seems to be something of a royal pain in the ass.
01:01:24 <greenrd> and I can't delete edges that are not on a path, period, because even the loops are on a path (just a stupid path)
01:01:26 <xenoblitz> vixey: now am getting the error "attempts to export constructors or class methods that are not visible here"
01:01:52 <hydo> err.. glade/gtk2hs
01:01:53 <pumpkin> greenrd: would deleting the back-edges on a topological sort do it? not sure
01:01:57 <prokyona> How do I represent a neural net which is *not* fully connected and has shortcut connections?
01:01:57 <vixey> xenoblitz, so exporting any constructors of Program that aren't visible?
01:02:02 <dolio> xenoblitz: ForThisPiece isn't a constructor of Program.
01:02:04 <prokyona> This means there are layers of nodes and each node has an arbitrary number of input connections and output connections. The only restriction is: Input connections must be with a node from one of the previous layers and output connections must be with a subsequent layer. Seems to be easy with C++-Pointers, I have no clue how to do it in haskell.
01:02:08 <xenoblitz> vixey: wait a sec cause it might be from my side
01:02:13 <xenoblitz> dolio: yes :S
01:02:33 <xenoblitz> vixey, dolio: yes it works now
01:02:33 <dolio> xenoblitz: If you're just exporting all the constructors, you can do "Program(..)"
01:02:34 <xenoblitz> thanks
01:02:43 <xenoblitz> dolio: oh good to know thank
01:02:50 <xenoblitz> dolio: thanks
01:03:59 <greenrd> pumpkin: not sure what you mean. I thought a cyclic graph does not *have* a topological sort, because it doesn't have a partial order
01:04:19 <pumpkin> well, yeah, but running the topological sort algo on it will give you some back-edges
01:04:22 <pumpkin> for the cycles
01:05:03 <vixey> pumpkin, you can give a topological sort of the SCCs
01:12:07 * greenrd is reading http://groups.google.com/group/comp.theory/browse_thread/thread/a82f7e3415f87c6c?pli=1 which seems relevant to my problem
01:13:55 <hcube> Lemmih: are you here?
01:14:25 <hcube> can lhc compile hopengl?
01:14:31 <Lemmih> hcube: Yes, no.
01:14:45 <hcube> what's missing?
01:15:28 <Lemmih> I don't know. Haven't tried. It's just that the usual answer to "can LHC compile X" is "no".
01:18:32 <pumpkin> @hoogle mkdir
01:18:32 <lambdabot> System.Posix.Internals mkdir :: CString -> CInt -> IO CInt
01:18:54 <pumpkin> is there a nicer more general way to make a directory?
01:19:11 <pumpkin> @hoogle String -> IO ()
01:19:12 <lambdabot> Prelude putStr :: String -> IO ()
01:19:12 <lambdabot> Prelude putStrLn :: String -> IO ()
01:19:12 <lambdabot> System.IO putStr :: String -> IO ()
01:19:18 <pumpkin> @hoogle FilePath -> IO ()
01:19:19 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
01:19:19 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
01:19:19 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
01:19:21 <pumpkin> aha
01:19:24 <pumpkin> :)
01:20:21 <Lemmih> hcube: LHC can only compile small toy applications. It will choke on anything much bigger than Hello World.
01:20:43 <pumpkin> but those hello world apps will be beautifully optimized!
01:21:39 <NameAlreadyInUse> what is lhc?
01:21:41 <francis> u think LHC could be ported to iphoneos?
01:22:30 <Lemmih> NameAlreadyInUse: It is yet another Haskell compiler.
01:22:54 <pumpkin>  getUserDocumentsDirectory
01:22:54 <pumpkin> "/Users/pumpkin"
01:23:01 <pumpkin> I beg to differ
01:23:22 <NameAlreadyInUse> heh, i didn't think there were that many
01:23:33 * vixey is not sure why you call it a haskell compiler
01:23:52 <Lemmih> francis: LHC itself depends on GHC. However, the output of LHC is portable C.
01:24:12 <coud> Hi. I'm just reading Real World Haskell and must say I realyy like that book. Are there somewhere solutions to the exercises ?
01:24:39 <francis> so lhc is sorta like llvm?
01:24:53 <thoughtpolice> francis: if we could get lhc to bootstrap itself, then feasibly yes, you could put it on say an iphone
01:24:55 <francis> in terms of being used in conjunction with a compiler for code optimization i mean
01:25:03 <francis> that would be pretty cool
01:25:21 <thoughtpolice> by default it does whole-program optimization and outputs a single C file for your app
01:25:24 <thoughtpolice> Lemmih: not true!
01:25:30 <thoughtpolice> it can compile things more complex than hello world
01:25:34 <thoughtpolice> i.e. the PureInteger test
01:25:40 <thoughtpolice> it just doesn't generate the right code :)
01:25:54 <pumpkin> can it compile the various programs used on the shootout? :D
01:26:03 <thoughtpolice> it can compile recursive
01:26:09 <vixey> thoughtpolice, why did you fork JHC instead of starting from scratch?
01:26:23 <thoughtpolice> because that's about the only shootout entry that doesn't depend on something that only GHC provides
01:26:34 <thoughtpolice> pumpkin: unfortunately, if you try to run it, your RAM is going to go away very quickly
01:26:59 <pumpkin> ah
01:27:10 <thoughtpolice> the problem is region inference, well, doesn't work so good. you can mitigate the leaking by compiling apps with 'lhc -fboehm' which will use the boehm GC if you have it
01:28:19 <thoughtpolice> vixey: well, I didn't intiate any fork. I was working on something along similar lines myself, and when Lemmih's patches were rejected (and lhc was basically born) and he put it out there, I decided to drop my work and use work on lhc instead.
01:28:50 <vixey> well I see but why hack on _L_HC instead of starting from scratch then?
01:29:39 <vixey> (or I should say, continue with what you had)
01:31:42 <Lemmih> vixey: Why reinvent the wheel?
01:31:49 <thoughtpolice> my project shared some very similar ideals with jhc regardless (GRIN being the major thing; I had some different thoughts about code generation) and john didn't seem to be working on it. on top of that, Lemmih's patches allowed me to actually build it since iirc jhc HEAD didn't build on OS X - lemmih also made some very nice improvements to jhc that made it way faster or something (i can remember when jhc took twen
01:32:13 <thoughtpolice> the speed increase made it fairly usable finally
01:32:20 <vixey> oh GRIN isn't a EHC thing?
01:32:47 <Lemmih> thoughtpolice: You got truncated after "took twen".
01:33:17 <thoughtpolice> "(i can remember when jhc took twenty minute to  compile hello world on my old linux box)?
01:34:02 <vixey> I only skimmed it so maybe I missed all the gems... but afaict it's basically a LOT of code with LOTS of dependencies which does not *do* something
01:34:18 <thoughtpolice> I simply decided it would probably be easier to take something that's attractive, similar and already works and try to make something out of it. while things are going slow now, I think me and Lemmih can get something working. :)
01:34:31 <thoughtpolice> well, works more than my compiler did anyway.
01:34:55 <thoughtpolice> it's an excellent project with some very novel ideas that appeal to me. why not improve it?
01:35:12 <hcube> Lemmih: why don't you develop EHC instead of continue jhc?
01:35:19 <thoughtpolice> vixey: we're trying to ship dependencies off to hackage
01:35:26 <vixey> :S I really don't get it but I do wish you both good luck with it
01:35:40 <thoughtpolice> there was TONS of ridiculous duplication in some of john's code
01:35:49 <thoughtpolice> shipping it off to simple hackage libraries makes it way easier to install
01:35:55 <thoughtpolice> and keeps the build system manageable
01:35:57 <vixey> well yeah JHC looks like crap and LHC looks like JHC
01:35:58 <pumpkin> why didn't j accept lemmih's patches in the first place?
01:36:06 <thoughtpolice> because john hates cabal
01:36:13 <pumpkin> vixey: looks like crap? why?
01:36:17 <thoughtpolice> i think he has a fair bit of good reason behind his choice too
01:36:25 <vixey> pumpkin, you haven't read it
01:36:30 <thoughtpolice> vixey: think what you want. i like it. :)
01:36:32 <quicksilver> he doesn't hate cabal.
01:36:39 <quicksilver> he doesn't think cabal is the right solution for JHC.
01:36:44 <hcube> i like jhc, because it give a proof of GRIN performance
01:37:09 <arjanb> vixey: GRIN is http://www.cs.chalmers.se/~boquist/phd/
01:37:19 <thoughtpolice> quicksilver: he has expressed his distaste for cabal several times in the past, has he not? either way you're right, he doesn't want to fight a build system and I can understand that
01:37:31 <Lemmih> hcube: I wasn't aware of EHC until a while ago.
01:38:13 <thoughtpolice> hcube: keeping in mind that jhc does some novel analysis on its own, e.g. type class implementation
01:38:17 <Lemmih> vixey: Why are you so negative? LHC is work in progress. You shouldn't expect it to shine like a supernova.
01:39:03 <vixey> Lemmih: I don't mean to be negative .. I wished good luck also bc. it's clearly a WIP
01:39:19 <vixey> Lemmih, I was trying to understand why to pick up this huge mess and fix it instead of starting from scratch though...
01:39:20 <hcube> i'll develop EHC in next university semester. i prefer ehc because it has very nice design and already have grin and llvm backend, which are my favourits :D
01:40:13 <thoughtpolice> llvm + grin is something I've thought about a few times before. GRIN is really a pretty nice low-level language for compilers.
01:40:22 <thoughtpolice> well, haskell compilers anyway
01:40:48 <pumpkin> I've got phc almost ready
01:40:54 <pumpkin> ;)
01:40:56 <Lemmih> hcube: EHC has a working LLVM backend?
01:41:11 <vixey> Lemmih, different LLVM
01:41:23 <vixey> something like  lazy lowlevel vm
01:41:24 <hcube> yep :) (buggy, it's quite new)
01:41:27 <pumpkin> lol
01:42:48 <arjanb> Lemmih: someone at UU did his master thesis about that
01:43:17 <thoughtpolice> Lemmih: I'm still trying to work on getting lhc to compile/use PureInteger successfully, fwiw
01:43:24 <hcube> here is some info about ehc's llvm backend (it's a master thesis, benchmarks included): http://www.cs.uu.nl/wiki/bin/view/Stc/CompilingHaskellToLLVM
01:43:37 <Lemmih> arjanb: Was anything published? I'd love to read about it.
01:43:48 <thoughtpolice> hcube: ty
01:43:48 <Lemmih> hcube: Thanks.
01:43:53 <hcube> :)
01:46:30 <arjanb> seems like it could be a nice test case for the haskell llvm bindings
01:47:05 <hcube> if you'd like to learn about ehc this is a good start: http://www.cs.uu.nl/wiki/bin/view/Ehc/TheStructureOfTheEssentialHaskellCompiler
01:50:35 <hcube> vixey: no, ehc's llvm means low level virtual machine, and it's homepage is llvm.org
01:50:46 <NameAlreadyInUse> @src (!!)
01:50:46 <lambdabot> xs     !! n | n < 0 = undefined
01:50:47 <lambdabot> []     !! _         = undefined
01:50:47 <lambdabot> (x:_)  !! 0         = x
01:50:47 <lambdabot> (_:xs) !! n         = xs !! (n-1)
01:51:24 <vixey> hcube, I got mixed up somehow,  ehc makefile says   make lvm                 : make Lazy Virtual Machine library
01:51:54 <hcube> ok
01:52:06 <Lemmih> Ack, EHC doesn't use a GC together with LLVM.
01:53:57 <quicksilver> I remember some comments on why LLVM was poorly suited to GHC
01:54:13 <hcube> i've found an interesting thing about compile time GC. mercury compiler has a compile time gc and here is the paper about this: http://www.cs.mu.oz.au/research/mercury/information/papers.html#mazur-thesis
01:54:16 <quicksilver> do they apply to LHC too, or was that GHC-specific?
01:56:24 <Lemmih> http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011794.html
01:56:51 <Lemmih> 'a' applies, 'b' does not, and I think 'c' has been fixed.
01:57:21 <Lemmih> A bigger issue is that LLVM has horrible support for GCs and no support for exceptions.
01:58:11 <quicksilver> Lemmih: which points are mentioned in jaffacake's followup : http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011795.html
01:58:29 <quicksilver> along with concurrency, which may not be on your target list?
01:58:36 <hcube> llvm supports exceptions
02:00:00 <Lemmih> hcube: http://lists.cs.uiuc.edu/pipermail/llvmdev/2008-December/018968.html
02:01:16 <redditbot> HUnit with Cabal: The easy way
02:01:16 <redditbot> Generate Windows installers for your Haskell apps
02:01:16 <redditbot> Maintaining laziness - HaskellWiki
02:01:17 <redditbot> COM bindings and support for Haskell
02:01:19 <redditbot> OpenID for Haskell: courtesy of Trevor Elliott
02:09:49 <pumpkin> @hoogle (Ord a) => [a] -> (a, a)
02:09:50 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
02:09:50 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
02:09:50 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
02:10:03 <pumpkin> is there anything that gives me minimum and maximum in one pass?
02:10:25 <vixey> pumpkin, fuse two foldrs togther
02:10:34 <mnpn> i have a question
02:10:37 <vixey> @src min
02:10:38 <lambdabot> min x y = if x <= y then x else y
02:10:40 <vixey> @src minimum
02:10:41 <lambdabot> minimum [] = undefined
02:10:41 <lambdabot> minimum xs = foldl1 min xs
02:10:47 <greenrd> OK, I think what I need to do is find all acyclic paths from X to Y, and draw a graph with just those paths included
02:10:54 <vixey> guess you could fuse foldl the same way
02:12:00 <pumpkin> :t minBound
02:12:02 <lambdabot> forall a. (Bounded a) => a
02:13:00 <arjanb> mnpn: just ask
02:13:50 <mnpn> a math statement is followed by "find out if this is true"
02:14:07 <mnpn> is it possible to use this as evidence that something is wrong?
02:14:23 <pumpkin> ?
02:15:00 <mnpn> use the "find out if this is true" interpret as "there is something wrong"
02:15:10 <mnpn> instead of "maybe something is wrong"
02:15:33 <mnpn> after all, why would they ask
02:15:50 <vixey> mnpn, no
02:16:07 <mnpn> thats what i thought too
02:21:16 <hugo___> hi
02:21:54 <greenrd> mnpn: badly designed tests sometimes have phrasing which gives you a clue as to the answer. but in general, no.
02:22:32 <mnpn> i knew that something was missing b/c i thought there "might be a dirty trick"
02:23:42 <mnpn> but that was because there was no reason for me to be asked the question
02:28:46 <greenrd> hmm, found lots of papers mentioning the phrase "acyclic path", but only found one algorithm to do what I want, and that's in an abandoned C++ project
02:29:05 <vixey> greenrd, is the a desc. what you're doing, got curious now..
02:29:52 <greenrd> I have a digraph, I want to find all acyclic paths from a particular node X to a particular node Y, efficiently
02:30:21 <greenrd> not that it really matters, but this is just for fun
02:30:21 <Peaker> greenrd: dijkstra?
02:30:29 <vixey> greenrd, sounds like you can take it into SCCs and then do a BFS
02:30:39 <vixey> greenrd, Data.Graph has a SCCifier btw
02:31:11 <vixey> greenrd, well ....... it's not quite as simple as I just said
02:31:54 <Peaker> greenrd: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
02:32:00 <vixey> greenrd, if I go round a loop once, and then get the finish.. does this count as a acyclic path?
02:32:23 <greenrd> Peaker: I don't want just the shortest, I want all the acyclic paths
02:32:48 <greenrd> vixey: firstly we can assume X != Y
02:33:06 <vixey> yaeh but if I start at X do a loop without touching Y then go to Y, I mean
02:33:12 <greenrd> sorry, I should be more haskellish: X /= Y :)
02:33:49 <greenrd> vixey: no, that doesn't count
02:33:53 <vixey> oh
02:34:00 <vixey> in that case it's just BFS without any SCCs
02:34:22 <vixey> (as you travel store a list of seen nodes, fail on seeing the same node twice)
02:35:25 <greenrd> right
02:35:27 <greenrd> makes sense
02:35:42 <greenrd> or DFS, right?
02:38:47 <vixey> yes
02:39:11 <greenrd> yeah, I think I can skip finding the paths and just produce what I really want, which is the list of edges that are on those paths
02:39:37 <greenrd> ok cool, I think I know what to do now
02:39:46 <vixey> list of edges that are on those paths.....................
02:39:48 <greenrd> thanks vixey
02:39:53 <vixey> you can calculate that easier
02:39:57 <vixey> you know how probably
02:40:44 <quicksilver> what's the significance of "edges from all acyclic paths" ?
02:40:48 <quicksilver> that's just "edges from all paths"
02:41:02 <quicksilver> any cyclic path can be decomposed into two acyclic ones
02:41:09 <quicksilver> so you'd get all the edges from all the cyclic ones too.
02:41:21 <quicksilver> Then it's just one component of the graph.
02:44:11 <mahogny> I think once at a time so decomposition implies you try to take two at one time?
02:46:01 <greenrd> quicksilver: it's edges from all acyclic paths from X to Y
02:46:41 <quicksilver> I assume you mean 'paths which don't cross themselves' ?
02:46:43 <Gracenotes> how coincidental, I was just implementing Dijkstra's in Python... heh
02:46:59 <quicksilver> you can transform any cyclic path into an acyclic one which touches the same edges
02:47:05 <quicksilver> by snipping the cycles into double-backs.
02:47:20 <greenrd> quicksilver: that's what I mean yes - am I using the wrong terminology?
02:47:31 <quicksilver> I don't know. My graph theory is rusty and was never great.
02:47:38 <quicksilver> I'd call that "non-self-intersecting paths" ;)
02:48:27 <quicksilver> some definitions of cyclic (for path) are "contains the same edge more than once"
02:48:29 <greenrd> what does " snipping the cycles into double-backs" mean?
02:48:40 <quicksilver> whereas what you mean is "contains the same vertex more than once"
02:48:47 <quicksilver> I'm not sure what's standard.
02:49:24 <quicksilver> greenrd: convert a crossing >< into > <
02:49:35 <quicksilver> (sharp left turn followed by sharp right)
02:50:15 <greenrd> sorry, I'm lost
02:50:40 <greenrd> got to go - back soon
02:54:40 <pumpkin> what's that *ator haskell web framework?
02:54:54 <pumpkin> oh, turbinado, lol
03:07:58 <greenrd> yes, I was using the wrong terminology - this is what I should have said, and the answer is what vixey said: http://www.nist.gov/dads/HTML/allSimplePaths.html
03:08:34 <quicksilver> ;)
03:08:47 <vixey> The paths may be enumerated with a depth-first search. The search can avoid repeating vertices by marking them as they are visited in the recursion --- very procedural suggestion there
03:09:05 <pumpkin> isn't DFS quite hard in functional land?
03:09:09 <vixey> continues with "then removing the mark just before using GOTO from the recursive call."
03:09:27 <greenrd> vixey, haha, yes, I could pass a Set around instead and avoid having to remove anything
03:09:29 <vixey> pumpkin,  dfs (Leaf a) = return a ; dfs (Branch l r) = dfs l ++ dfs r
03:09:29 <quicksilver> pumpkin: not really
03:09:45 <pumpkin> well yeah, but the avoiding already visited nodes
03:10:06 <vixey> well that's not a one liner
03:10:28 <pumpkin> how is it typically done?
03:10:35 * vixey takes it to be 3 lines + 1 data definitino
03:10:39 <pumpkin> the issue seems to be getting the branches to talk to each other?
03:10:49 <pumpkin> oh I guess they don't need to
03:10:52 <pumpkin> yeah, I see
03:11:44 <quicksilver> dfs (Leaf a) = push a >> return a; dfs (Branch l r) = liftM2 (++) (dfs l) (dfs r)
03:11:58 <quicksilver> for some suitable monad which defines 'push' suitably ;)
03:12:01 <pumpkin> :P
03:12:14 <vixey> with no pop?
03:12:21 <pumpkin> neva!
03:12:29 <quicksilver> it's pushing it onto the 'already visited' list
03:12:32 <quicksilver> I never pop stuff off that.
03:15:51 <thoughtpolice> yay
03:15:59 * thoughtpolice finally got the haskell llvm bindings working correctly
03:16:20 <pumpkin> :o
03:16:27 <pumpkin> to do what?
03:17:12 <thoughtpolice> to work
03:17:25 <pumpkin> ah :o
03:17:47 <thoughtpolice> i normally --prefix=$HOME things, and the linker was giving me a very weird error if I passed e.g. `llvm-config --libs` on the command line
03:17:56 <thoughtpolice> so i just uninstalled it and let it install in /usr/local instead
03:18:15 <thoughtpolice> so I also didn't have to pass ./configure options etc.
03:23:46 <knapr> so when we will be programming cell phones with Haskell?
03:24:15 <pumpkin> when someone ports ghc to arm
03:25:08 <quicksilver> ghc already runs on arm
03:25:20 <quicksilver> however, for cell phone development you really want a cross-compiler
03:25:44 <vegai> some people tried a bit with Maemo
03:25:54 <olsner> so when will ghc be able to cross-compile? :P
03:26:25 <vegai> arm devices usually are rather short on memory
03:26:28 <quicksilver> olsner: when you submit the patch
03:26:38 <quicksilver> well, and when it's been tested.
03:26:39 <beelsebob> vegai: 128MB in the iPhone
03:26:45 <beelsebob> IIRC
03:26:48 <beelsebob> it may even be 256
03:26:57 <quicksilver> 128M is hardly enough for ghc to launch, let alone compile anything :)
03:27:06 <pumpkin> it's 128M :)
03:27:12 <pumpkin> of which you can use about 116
03:27:14 <beelsebob> yeh, I wasn't saying that ghc would run
03:27:15 <vegai> could be enough to run reasonable apps compiled elsewhere, though.
03:27:18 <beelsebob> but that Haskell programs could
03:27:20 <olsner> wow, 128MB is almost an infinite amount of ram
03:27:30 <quicksilver> no, I'm pretty sure cross-compilation is the way to go.
03:27:50 <beelsebob> indeed
03:27:53 <quicksilver> although it would be nice to have the interpreter running on the phone
03:27:56 <vegai> you can evade that problem if you could get ghc inside scratchbox
03:27:58 <quicksilver> people have ported hugs to other phones
03:28:00 <pumpkin> gcc can almost compile itself on the iphone
03:28:02 <quicksilver> that should be fairly simple
03:28:15 <vegai> or whatever emulator thingie you use to develop
03:28:18 <quicksilver> pumpkin: how long does it (almost) take?
03:28:25 <pumpkin> a long time :P
03:28:27 <beelsebob> quicksilver: unfortunately, that's something that will never be official :(
03:28:29 <pumpkin> can't remember, but several hours
03:28:35 <beelsebob> one of the major rules is "can't run arbitrary code"
03:28:36 <knapr> and the unpredictable memory-use of ghc?
03:28:46 <ziman> what about other compilers, such as nhc?
03:28:56 <pumpkin> beelsebob: actually, the rule says can't run arbitrary downloaded code :) on the iphone, at least
03:29:01 <ziman> they generate C, don't they?
03:29:04 <beelsebob> pumpkin: good point
03:29:25 <vegai> yhc generated bytecode, no?
03:29:37 <quicksilver> beelsebob: hugs is just an overblown calculator ;)
03:30:02 <beelsebob> quicksilver: I actually had an idea to create a "graphing calculator" that had an embedded Haskell like language in it
03:30:03 <quicksilver> beelsebob: it would be harmless in apple's eyes as long as it didn't have access to the iPhone API, I suspect.
03:30:20 <quicksilver> if it was just meddling with strings and lists and numbers and the occasional putStrLn
03:40:02 * vegai arghs at hsx & ghc-6.10
04:01:26 <hugo___> how do i open a file descriptor in haskell ?
04:01:32 <hugo___> without actually reading the file
04:01:58 <hugo___> do i get this kind of behaviour automatically because of lazyness ?
04:02:26 <ziman> hugo___, you can use System.IO.openFile
04:02:38 <hugo___> oh, sweet
04:02:59 <ziman> however, that's not the low-level file descriptor, it'll give you a (buffered) handle
04:04:23 <quicksilver> hugo___: no, this is not laziness
04:04:27 <jeffz`> you can't really open a file descriptor either, a file descriptor is what you receive when you open a file
04:04:40 <quicksilver> to the extent that anything is 'lazy', it's a broken interleaved IO implementation.
04:04:43 <hugo___> yes, thats what i meant jeffz
04:04:52 <quicksilver> it's not related to that elegant and beautiful thing which is laziness of pure functions.
04:05:15 <hugo___> :D
04:05:51 <hugo___> well, i mean, you could only read the file when you actually need it
04:07:44 <quicksilver> hugo___: yes, that's not laziness.
04:07:50 <quicksilver> that's a broken IO setup.
04:08:04 <hugo___> ok
04:08:12 <quicksilver> which interleaves IO with pure execution
04:08:14 <hugo___> i just wanted the fd, without any buffers associated
04:08:21 <quicksilver> thus defeating the point of having a pure language.
04:08:32 <quicksilver> why don't you want any buffers associated?
04:08:46 <quicksilver> you need to understand your OS fairly well to know whether or not the act of opening a file allocates some buffers :)
04:08:49 <quicksilver> I certainly don't know.
04:09:08 <hugo___> i want to use the kernel buffers only, through send_file
04:10:44 <hugo___> ill also need to do a ffi to it :/
04:11:22 <quicksilver> I think someone did a send_file binding.
04:11:39 <quicksilver> but there are bindings in the posix module for direct FD opens
04:12:30 <hugo___> im reading about it on google
04:13:11 <hugo___> http://www.hackerdashery.com/2008/05/how-not-to-handle-streams.html
04:14:34 <hugo___> "I eventually gave up on Haskell, and switched to Python."
04:14:39 <hugo___> im guessing this is not good news for me
04:17:57 <hugo___> anyway, im more stubborn that him
04:20:22 <quicksilver> "because the language itself supports streaming behavior via lazy evaluation"
04:20:23 <quicksilver> rubbish
04:20:27 <quicksilver> I hate that meme so much.
04:20:33 <quicksilver> My quest for 2009 : to discredit that meme.
04:22:21 <quicksilver> hugo___: still, FFI'ing sendfile shouldn't be hard
04:25:54 <hugo___> yeh
04:26:00 <hugo___> ill do it, its my goal for today
04:26:18 <hugo___> learning the basics of ffi, and wrap the sendfile
04:26:27 <liff> does the HTTP library support SSL yet?
04:30:40 <Entroacceptor> I'm just learning haskell, is there a way to show the implementation of a function (like in Prolog)?
04:31:10 <Lemmih> ?src foldr
04:31:10 <lambdabot> foldr f z []     = z
04:31:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:31:17 <Entroacceptor> aaaah
04:31:19 <Entroacceptor> don't spoil me
04:31:30 <Entroacceptor> I'm just trying to implement that myself ;)
04:31:38 <Entroacceptor> but, thanks :)
04:32:13 <quicksilver> Entroacceptor: No.
04:32:36 <quicksilver> Entroacceptor: (it's not possible to implement '?src' yourself, the version here just has a database of sources)
04:32:47 <quicksilver> Entroacceptor: all the source is browsable on the web, though
04:33:00 <quicksilver> (some of it is not entirely obvious to find, if it's buried deep in an implementation module)
04:33:00 <paper_cc> quicksilver: does HTTP library really read request bodies non-lazily?
04:33:52 <Entroacceptor> no, I mean, I was just trying to implement foldr
04:33:59 <quicksilver> paper_cc: I read that there was a version which uses lazy bytestrings and interleaved IO.
04:34:03 <quicksilver> Entroacceptor: ah, fair enough :)
04:34:36 <quicksilver> I think writing foldr yourself is quite hard until you "get it", and then it's obvious ;)
04:35:29 <Entroacceptor> quicksilver: yeah, I'm checking if I "got it".
04:35:48 <Entroacceptor> I know some Prolog, so the mind-set is not completely new to me
04:36:16 <mightybyte> What happened to the view source links in the standard library docs?
04:36:46 <Entroacceptor> aah, missed the braces,  but otherwise I got it
04:37:34 <quicksilver> mightybyte: they're in them, if you look at the right version
04:37:42 <quicksilver> mightybyte: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
04:38:02 <Entroacceptor> ?src foldl
04:38:02 <lambdabot> foldl f z []     = z
04:38:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:38:41 <quicksilver> mightybyte: as to why they vanished from the other set, I think it's a subtle haddock problem
04:38:45 <quicksilver> but I'm not sure what
04:39:29 <mightybyte> quicksilver: Thanks.  Maybe the link from the haskell.org main page should be updated?
04:39:40 <quicksilver> mightybyte: yes. Or the problem fixed :)
04:39:53 <mightybyte> That too
04:43:00 <int-e> (continuing from #ghc) Phyx-: the long story is that cabal invokes ghc with --hide-all-packages and explicit -package flags for all the packages listed in build-depends in the cabal file. So when ghc says that old-time is hidden, it's actually true: --hide-all-packages hid it.
04:43:34 <Phyx-> int-e: ah cool, that makes sense. it works now :)
04:44:33 <mightybyte> quicksilver: There, I changed it.
04:45:34 <quicksilver> thanks!
04:46:46 <Phyx-> does anyone know where "DynIOError" is defined in?
04:46:56 <therp> @ho DynIOError
04:46:56 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
04:47:00 <therp> @hoogle DynIOError
04:47:00 <lambdabot> No results found
04:47:14 <quicksilver> probable the new Control.Exception
04:47:25 <Phyx-> ok, i'll look there
04:47:44 <quicksilver> if you're porting old code to ghc 6.10 you probably need to change Control.Exception to Control.OldException
04:47:50 <quicksilver> they're not source compatible.
04:48:01 <Phyx-> which would explain alot
04:48:11 <Phyx-> since comLib was written for the old vsHaskell
04:49:46 <Phyx-> hm, i still get
04:49:48 <Phyx-> src\ComPrim.hs:61:32: Not in scope: data constructor `DynIOError'
04:50:29 <quicksilver> maybe thats the old-old exception stuff?
04:50:37 <quicksilver> 6.4 and earlier?
04:50:45 * quicksilver never used that
04:50:56 <Phyx-> the last version of vsHaskell was for 2003, so 5 years ago
04:52:28 <Phyx-> ah
04:52:30 <Phyx-> for the record
04:52:36 <Phyx-> it's in GHC.IOBase
04:52:48 <Phyx-> or was, in 6.2.2
04:53:09 <quicksilver> if you google it, you can find where Igloo removed it ;)
04:53:12 <quicksilver> not sure what the history is though.
04:53:17 <lorenzo2> ss
04:53:19 <Phyx-> quicksilver: yeah
04:53:26 <Phyx-> i saw it "as far as i know it is never used"
04:53:27 <Phyx-> lol
04:56:57 <Phyx-> *seees if he can replace it with another constructor*
04:57:56 <_ry> i just compiled the latest ghc - and now i'm building cabal-install with the bootstrap script. but it seems to have a problem with a missing dependency: network >=1
04:58:18 <Phyx-> download it
04:58:27 <_ry> is this network package not part of ghc?
04:59:03 <Phyx-> http://hackage.haskell.org/packages/hackage.html
05:00:02 <Phyx-> not that i know off
05:00:09 <Phyx-> direct link is http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network
05:00:10 <int-e> _ry: it's semi-bundled with ghc: it's part of the extra-libs tarball.
05:00:30 <Phyx-> semi-bundled
05:00:32 <int-e> it's also available via hackage as Phyx- points out.
05:00:32 <Phyx-> ^_^
05:00:55 <okriM> newtype Dist a = D {unD :: [(a,Probability)]} <--  what does "{unD :: [(a,Probability)]}" mean?
05:01:06 <Phyx-> hm.. why can't i find GHC.IOBase at all in the haddock for 6.10
05:02:32 <Phyx-> *looks into base"
05:02:32 <mauke> Phyx-: isn't the bootstrap script supposed to deal with that?
05:02:57 <int-e> because it's hidden from haddock (it contains a -- #hide  line)
05:03:10 <Phyx-> mauke: i'm trying to find what i can update the code to, now that the DynIOError has been removed
05:04:29 <mauke> ECONTEXT
05:04:59 <Phyx-> @hoogle ECONTEXT
05:04:59 <lambdabot> Distribution.Extension FlexibleContexts :: Extension
05:04:59 <lambdabot> Language.Haskell.Extension FlexibleContexts :: Extension
05:05:07 <Lemmih> okriM: It defines the function 'unD :: Dist a -> [(a,Probability)]'.
05:06:01 <quicksilver> Phyx-: mauke means "I cannot answer your question about the best way to acheive that objective without some more context about why that objective is useful or important"
05:06:06 <okriM> Thanks
05:06:22 <Phyx-> quicksilver: lol, ok
05:06:28 <mauke> quicksilver: more like "I have no idea what you're talking about because we have different conversation contexts"
05:06:29 <mightybyte> Is there a way to automatically derive a class instance for a library type where you don't have control over the original definition?
05:07:08 <int-e> @go ghc standalone deriving
05:07:10 <mauke> mightybyte: yes, assuming a recent enough ghc
05:07:11 <lambdabot> No Result Found.
05:07:15 <int-e> :(
05:07:25 <mightybyte> mauke: How recent?
05:07:28 <int-e> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
05:07:30 <Phyx-> mauke: well, what i am trying to do is update the comlib code from vsHaskell to build under the new ghc, so i can use that instead of rewriting it all (since frankly, i don't know enough about ghc to do that). but the DynIOError constructor was removed from GHC.IOBase in recent versions
05:07:45 <mauke> Phyx-: I don't care
05:07:47 <olsner> @go ghc stand-alone deriving
05:07:49 <lambdabot> No Result Found.
05:07:55 <mightybyte> int-e: Thanks
05:07:59 <olsner> @google broken?
05:08:01 <lambdabot> http://www.youtube.com/watch?v=CoUOrLe4vlY
05:08:01 <lambdabot> Title: YouTube - Broken - Seether and Amy Lee
05:08:39 <int-e> mightybyte: 6.8.3 is recent enough. 6.6.1 isn't, I think.
05:08:47 <olsner> hmm, not entirely broken then
05:10:19 <mauke> mightybyte: 6.8.1, but >=6.8.2 is recommended
05:11:14 <mightybyte> mauke: Ok, great.  I've already got 6.8.2
05:19:24 <mightybyte> Hmmm, "deriving Read for Type" doesn't work.
05:20:28 <mauke> wtf, did they change the syntax?
05:21:28 <mightybyte> Should I upgrade ghc?
05:22:09 <ivanm> is there an upgrade guide for http 3000 => 4000?
05:22:37 <mauke> mightybyte: documentation bug
05:22:40 <mauke> the syntax is 'deriving instance Read Type'
05:23:35 <mightybyte> Ok.  It doesn't show that here:
05:23:36 <mightybyte> http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#stand-alone-deriving
05:23:45 <mauke> I know
05:25:16 <mightybyte> mauke: Can you derive multiple types at once?  "deriving instance (Read,Show) Type" doesn't work.
05:26:32 <ivanm> mightybyte: why do you have Type on the end? don't you normally have the deriving statement at the end of a data/newtype statment?
05:27:01 <mauke> mightybyte: no, you can't. 'instance (Read,Show) Type where ...' doesn't work either
05:27:04 <mightybyte> ivanm: I'm referring to standalone deriving.
05:27:15 <mightybyte> mauke: Ok.
05:27:19 <ivanm> you can do that? :o
05:27:26 <mauke> mightybyte: use multiple statements
05:27:53 <mightybyte> ivanm: It appears so.  (mauke just told me about it)
05:28:16 <Phyx-> @hoogle Foreign.COM.Marshal.Exception
05:28:17 <lambdabot> package iException
05:31:58 <Phyx-> @hoogle catchDyn
05:31:58 <lambdabot> Control.Exception catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
05:33:27 <Phyx-> hm, odd
05:36:37 <Phyx-> seems base 4.0.0 fubared that too, 3.0.3.0 works
05:37:03 <ivanm> Phyx-: yeah, base-4 has a new exception library
05:37:13 <ivanm> so a lot of packages need updating to use base-4
05:37:58 <Phyx-> yeah, i'll eventually update them, but for now i'll just use the old ones
05:42:50 <paolino> I need some help in understanding http://hpaste.org/13481behaviour
05:43:01 <paolino> http://hpaste.org/13481
05:44:00 <paolino> putting IO inside WriterT destroy the monoid lazyness
05:47:28 <dons> ?users
05:47:28 <lambdabot> Maximum users seen in #haskell: 597, currently: 569 (95.3%), active: 12 (2.1%)
05:48:02 <Phyx-> hm, there, updated iException and interleavableIO to compile on 6.10
05:50:00 <chessguy_work> @users
05:50:00 <lambdabot> Maximum users seen in #haskell: 597, currently: 570 (95.5%), active: 12 (2.1%)
05:50:09 <chessguy_work> 'morning, ya'all
05:51:47 <ivanm> chessguy_work: morning?
05:51:50 * ivanm looks outside
05:51:56 <ivanm> doesn't look like morning to me ;-)
05:52:00 <chessguy_work> @time ivanm
05:52:02 <lambdabot> Local time for ivanm is Wed Dec 31 23:52:01
05:52:09 <chessguy_work> well it will be in a few minutes :)
05:52:25 <mauke> @time preflex
05:52:26 <lambdabot> Local time for preflex is OVER 9000!
05:52:35 <ivanm> mauke: lol
05:52:38 <chessguy_work> what the...
05:53:33 <saml> @time saml
05:53:34 <lambdabot> Local time for saml is Wed Dec 31 08:54:01
05:56:22 <paolino> also I should point out that it has nothing to do with WriterT replacing Writer, as it works with WriterT [Int] Identity
05:58:24 <mauke> @time
05:58:28 <lambdabot> Local time for mauke is badger badger badger badger badger badger badger badger badger badger badger badger badger badger badger badger badger badger badger badger
05:59:01 <opqdonut> @tiem
05:59:05 <lambdabot> Local time for opqdonut is Wed Dec 31 15:59:02 2008
05:59:08 <opqdonut> wh
05:59:11 <opqdonut> *ah
05:59:12 <opqdonut> ctcp time
05:59:50 <mauke> @time
05:59:53 <lambdabot> Local time for mauke is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
06:00:00 <mauke> hmm
06:00:11 <idnar> heh
06:00:22 <Raynes> O_o
06:00:25 <Gilly> in hex counting nanoseconds since big bang?
06:01:06 <Elly> number's too long for that
06:01:09 <redditbot> Cryptol
06:01:09 <Gilly> i know
06:02:06 <chessguy_work> @quote bang
06:02:06 <lambdabot> HarriKiiskinen says: banging my head against Haskell, but liking the feeling of hurting brains
06:02:38 <elbar> @time
06:02:42 <lambdabot> Local time for elbar is Wed Dec 31 15:02:39 2008
06:03:59 <chessguy_work> pretty quiet in here this morning
06:08:07 <Phyx-> @hoogle ioErrors
06:08:08 <lambdabot> Control.Exception ioErrors :: Exception -> Maybe IOError
06:08:15 <Phyx-> ok wtf..
06:08:33 <chessguy_work> whassup?
06:10:03 <Phyx-> not much, just updating some code
06:18:22 <Twey> Gah, what's the computational cost of matching an arbitrary substring?
06:18:54 <mauke> you mean searching for a substring?
06:19:06 <Twey> Yes, but just a boolean result
06:19:23 <mauke> depends on your string representation
06:19:28 <mauke> O(m*n) in the worst case
06:19:34 <Twey> Why?
06:19:41 <olsner> it's free if you don't force the result :P
06:19:48 <Twey> Haha :-P
06:20:09 <lorenzo> @hoogle Arrows
06:20:09 <lambdabot> Distribution.Extension Arrows :: Extension
06:20:09 <lambdabot> Language.Haskell.Extension Arrows :: Extension
06:20:09 <lambdabot> package arrows
06:20:17 <lorenzo> @hoogle Arrow
06:20:17 <lambdabot> module Control.Arrow
06:20:17 <lambdabot> Control.Arrow class Arrow a
06:20:17 <lambdabot> Control.Arrow class Arrow a => ArrowApply a
06:21:25 <chessguy_work> mauke, err, does it have to be m * n? can't it be just n?
06:22:01 <mauke> chessguy_work: how would you do that?
06:22:30 <chessguy_work> oh never mind, i just realized a counter to what i was about to suggest
06:22:37 <chessguy_work> bugger
06:22:46 <chessguy_work> you're right, of course
06:22:58 <Twey> @src isPrefixOf
06:22:58 <lambdabot> isPrefixOf [] _          = True
06:22:58 <lambdabot> isPrefixOf _  []         = False
06:22:58 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
06:23:23 <mauke> boyer-moore is something like O(m/n) in the best case
06:23:32 <paolino> if it is m*n it should match the right at the beginning so becomes m
06:23:32 <olsner> @ty \substring -> not . null . filter (== substring) . take (length substring) . tails
06:23:34 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
06:23:59 <Twey> @index [a] -> [a] -> Bool
06:24:00 <lambdabot> bzzt
06:24:04 <Twey> @hoogle [a] -> [a] -> Bool
06:24:05 <mauke> @src isInfixOf
06:24:05 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
06:24:05 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
06:24:05 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
06:24:06 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
06:24:07 <Twey> Silly me
06:24:12 <Twey> That's the one
06:24:13 <Twey> Thanks
06:24:26 <Twey> So yes, O(m*n)
06:25:02 <olsner> there's a library on hackage that does KMP and other substring search algorithms on bytestrings
06:25:31 <olsner> which would be faster than isInfixOf on [Char]
06:26:54 <paolino> I cannot build a truly m * n complex example
06:28:28 <paolino> mmhh, even (m -1) * n is difficult
06:31:25 <paolino> anyone would please help me with the WriterT [w] IO difficulties ?
06:31:37 <chessguy_work> just ask your question
06:31:50 <mauke> he already did that
06:32:06 <paolino> code is here http://hpaste.org/13481
06:32:18 <chessguy_work> oh, sorry, i missed it
06:34:34 <chessguy_work> @hoogle runWriterT
06:34:34 <lambdabot> Control.Monad.Writer.Lazy runWriterT :: WriterT w m a -> m (a, w)
06:34:34 <lambdabot> Control.Monad.Writer.Strict runWriterT :: WriterT w m a -> m (a, w)
06:40:02 <C-Keen> hm, has someone in here compiled the darcs gtk2hs with 6.10.1?
06:40:11 <C-Keen> I get glib/System/Glib/GError.chs.pp:186:31: Not in scope: `throwDyn'
06:42:18 <Phyx-> C-Keen: open the file saying that and change Control.Exception to Control.OldException
06:42:41 <C-Keen> thanks Phyx-! should I send that as a patch?
06:43:18 <Phyx-> don't think so, they should probably update their codes to work with the new Control.Exception instead
06:43:26 <C-Keen> oh
06:43:45 <C-Keen> the code is already there but it seems the macro did not get set right
06:44:02 <Phyx-> aha
06:45:37 <Gilly> someone knows if cabal-install in darcs works well with the current Cabal in darcs repository?
06:46:10 <Lemmih> Gilly: It seems to work fairly well.
06:47:43 <Gilly> ok, good... then i'll modify the current ebuild in gentoo haskell overlay
06:48:29 <Lemmih> Gilly: You have to edit the .cabal file to build against Cabal-1.7, though.
06:48:42 <Lemmih> Gilly: The darcs version of cabal-install will build against the stable Cabal by default.
06:48:50 <Gilly> oh bah
06:48:59 <Gilly> well, gonna do the whole thing by hand then
07:05:08 <chessguy> does it seem to anyone else like the quality of the questions on -cafe have gone down a little lately?
07:06:04 <SamB> Lemmih: hmm, I sent a patch to the jhc list but it doesn't seem to have gotten through, looking at gmane and pipermail ...
07:06:18 <SamB> er.
07:06:19 <SamB> lhc
07:06:21 <SamB> sorry
07:06:33 <Gilly> hmh, the build fails with: http://hpaste.org/13483
07:06:33 <Peaker> People are working to make Haskell popular, I think its inevitable that the quality will go down...
07:06:42 <nomeata> Hi. Is something wrong with RefSerialize:
07:06:46 <nomeata> *Main Data.RefSerialize> rShow (let a = (); b = Just a; c = Just a  in (a,b,c))
07:06:48 <nomeata> " v9 where {v9= ((),Just (),Just ()); }"
07:07:02 <chessguy> peaker: yeah, i guess
07:07:04 <nomeata> shouldnt the a be shared?
07:07:16 <SamB> Lemmih: my suspicion is that it either tripped the size limit, or got held because I'm not on the list
07:07:19 <Peaker> #haskell will eventually be #python :P
07:07:30 <SamB> Lemmih: so it should be in the moderation bin
07:08:19 <dagnachew> hi all
07:08:30 <BMeph> nomeata: What do you think it should have shown? :)
07:08:33 <mauke> nomeata: my guess is that () is a primitive
07:08:51 <nomeata> mauke: I can replace it with "Hi"...
07:08:55 <mauke> :-(
07:09:13 <nomeata> BMeph: rShow should introduce a varible for it, which is then used several times
07:09:30 <nomeata> mauke: and the example Im testing it with is actually lager, with proper algebraic types
07:09:48 <nomeata> mauke: testState' = let user = User 0 [Id computer]; computer = Computer 1 (Id user);  in  State [user] [computer]
07:11:06 <Lemmih> SamB: I don't see it.
07:12:06 <SamB> hmm.
07:12:11 <Phyx-> @hoogle throwIO
07:12:12 <lambdabot> Control.Exception throwIO :: Exception -> IO a
07:14:31 <BMeph> Ah, so. Thank you; it sounds interesting...if it works. :)
07:15:05 <BMeph> dagnachew: hi, how may we improve your life today? :)
07:15:47 <dagnachew> BMeph, any suggestion on the best haskell book ? I bought real world haskell
07:16:19 <BMeph> dagnachew: Hmm, my suggestion would be to read it, then. 8D
07:16:27 <SamB> Lemmih: well, my ISP accepted the email with no sign of trouble ...
07:16:36 <dagnachew> you have another suggestion
07:17:04 * BMeph scratches his head, then pats down his clothing...
07:17:47 <BMeph> dagnachew: Your Jedi mind tricks won't work on me. :)
07:18:43 <BMeph> dagnachew: Ah, it's not a book (yet!) but BONUS has a tutorial that's getting good reactions - http://learnyouahaskell.com
07:20:53 <Lemmih> SamB: Are you familiar with the mailman administration interface? (I'm not)
07:21:03 <SamB> Lemmih: somewhat
07:21:21 <dagnachew> BMeph, thanks a lot
07:21:52 * SamB offers BMeph large quantities of money
07:22:25 <Olathe> @src null
07:22:26 <lambdabot> null []     = True
07:22:26 <lambdabot> null (_:_)  = False
07:24:29 <Phyx-> does anyone know how i can solve "Class `Exception' used as a type" with base 4.0 and not changing the signature to (Exception a) => a ?
07:25:37 <mauke> use SomeException instead?
07:26:25 <Absolute0> I hava X11 installed but i am still getting this error:  Could not find module `Graphics.X11.Xlib' when trying to install xmobar
07:26:31 <Phyx-> ok, thanks
07:27:11 <nomeata> quicksilver: thanks again for your help yesterday. With it, I managed to come up with this: https://www.joachim-breitner.de/blog/archives/316-Handling-explicit-and-implicit-recusion-in-Haskell-data.html
07:28:58 <Lemmih> SamB: I should see your mail when I click on "Tend to pending moderator requests", right?
07:28:59 <Gilly> any idea about this error on building cabal-install from darcs: http://hpaste.org/13483 ?
07:29:14 <SamB> Lemmih: it should be in there, yeah
07:29:21 <SamB> neasten at gmail.com
08:11:32 <imphasing> I would love it if GHC eventually had a CLR target :)
08:11:38 <imphasing> Just saying..
08:12:02 <chessguy> you mean like compiling to IL?
08:12:20 <imphasing> Yeah
08:12:30 <imphasing> For Mono/.NET
08:20:13 <imphasing> I'll just have to stick to F# for now, I guess.
08:21:42 <matthewp> imphasing: I believe Neil D Mitchell was working on that with his YHC
08:21:53 <imphasing> Oooh, cool..
08:22:06 <matthewp> imphasing: and then there's Salsa, which is a .NET bridge, but not complete
08:22:31 <matthewp> imphasing: But if you want full CLR support, then F# is your pick
08:23:08 <matthewp> imphasing: which is not a bad thing, figuring I work for the blue monster and do a bit of work on it
08:23:21 <imphasing> blue monster?
08:23:25 <imphasing> MS?
08:23:26 <SamB_XP> IBM?
08:23:29 <matthewp> imphasing: when not enfatuated with Haskell of course
08:23:35 <matthewp> imphasing: MSFT
08:23:40 * SamB_XP doesn't remember MS having a color
08:23:41 <imphasing> Right, that.
08:23:56 <imphasing> Well, I really like haskell so far, but I'm still learning
08:24:08 <imphasing> F# seems to have less of a curve, but I like the purity of haskell.
08:24:13 <Peaker> imphasing: it only gets better :)
08:24:25 <imphasing> Peaker, As soon as my brain heals :P
08:24:30 <SamB_XP> does less curve => less sexy ?
08:24:44 <matthewp> imphasing: purity is a wonderful thing to learn and can influence your F# for the better IMO
08:25:04 <imphasing> SamB_XP, I think so. It must be awesome if it's hard to learn :P
08:25:16 <SamB_XP> I was making a joke ;-P
08:25:30 <matthewp> imphasing: well, could say the same of say Smalltalk
08:25:40 <imphasing> matthewp, Well, seeing as this is my 3rd try to learn haskell, hopefully this time it'll stick
08:25:48 <SamB_XP> smalltalk is all rectangles!
08:25:53 <Peaker> imphasing: What difficulties did you encounter?
08:26:10 <imphasing> Peaker, I kept looking under the hood at all the mathematical stuff that was happening
08:26:13 <Peaker> imphasing: After learning Haskell, in retrospect, things look pretty clear, and its hard to see why I had a hard time..
08:26:43 <imphasing> I begining to see some clarity, after working with Scheme a little, but there's plenty of haze still
08:26:47 <SamB_XP> Peaker: maybe you were expecting them not to be clear
08:27:04 <imphasing> I'm by no means a mathematician, so some of the concepts in haskell are going to take some time
08:27:21 <SamB_XP> heh
08:27:35 <SamB_XP> as if just being a mathemetician would necessarily help all that much ;-)
08:27:52 <imphasing> Well, having any background in math would probably help
08:28:01 <imphasing> I never did any of that stuff :)
08:28:09 <imphasing> I get to play catch-up now.
08:28:16 <SamB_XP> what was your major ?
08:28:41 <imphasing> I never went to any schools :P
08:28:52 <imphasing> Homeschooled all the way.
08:29:00 <SamB_XP> no college ?
08:29:02 <imphasing> Which involved a lot of programming, but no formal math
08:29:03 <Peaker> imphasing: I am not a mathematician. I think reasonably understanding Haskell (perhaps not proving theorems about it :-) does not require understanding more mathematics than other more main stream languages
08:29:04 <imphasing> Nope.
08:29:28 <SamB_XP> you clearly should have discovered Haskell in highschool ;-P
08:29:29 <imphasing> Peaker, I'm certainly not complaining. I like a challenge.
08:29:29 <SamB_XP> like me
08:29:30 <Phyx-> how do i fix these following warnings
08:29:31 <Phyx-> Warning: resolving _primFreeMemory@4 by linking to _primFreeMemory
08:29:33 <Phyx-> etc?
08:29:35 <matthewp> imphasing: what languages do you currently know well?
08:30:11 <imphasing> matthewp, I'm a C# developer by day, but I've worked with Perl, PHP, C, and assembly in other stuff
08:30:45 <imphasing> My hobbies usually had something to do with low level C stuff, so jumping into higher level languages is interesting.
08:30:49 <matthewp> imphasing: ok, well, if you understand the functional stuff in C#, you're getting there
08:31:03 <matthewp> imphasing: such as LINQ, lambdas and so on
08:31:17 <imphasing> I like that C# 3.0 added lambdas, which are handy
08:31:20 <imphasing> LINQ is nice too.
08:31:29 <imphasing> But I fail to see how those make it more functional
08:31:37 <matthewp> imphasing: LINQ is just a List Monad
08:31:49 <imphasing> Speak not of monads to me :P
08:31:51 <matthewp> imphasing: LINQ to Objects that is
08:32:16 * SamB_XP wonders why he has Borland C++ Builder 6 installed
08:32:19 <imphasing> I know the concept of a monad is supposedly simple, but that doesn't make my head stop groaning
08:32:21 <matthewp> imphasing: it emphasizes functions as first class citizens
08:32:25 * SamB_XP supposes it won't do any harm to uninstall it
08:32:36 <matthewp> imphasing: Do you have the Real World Haskell book?
08:32:42 <imphasing> I'm reading it online
08:32:47 <imphasing> It's good. :)
08:32:50 <SamB_XP> hmm, Windows says I haven't used it in over 4 years ;-P
08:33:05 <matthewp> imphasing: We're starting the RWH Book Club on the 5th
08:33:13 <matthewp> imphasing: to go over it in detail
08:33:16 <leadnose> you have had same windows installation for 4 years :o
08:33:31 <imphasing> matthewp, Very cool.
08:33:38 <matthewp> Thinking this might need to be refactored, but not sure how - fmap find3 (liftM (map read) (liftM lines getContents))
08:33:54 <Phyx-> @hoogle Distribution.Setup
08:33:54 <lambdabot> module Distribution.Setup
08:33:55 <lambdabot> module Distribution.Simple.Setup
08:33:55 <lambdabot> Distribution.PackageDescription setupMessage :: Verbosity -> String -> PackageDescription -> IO ()
08:34:09 <Phyx-> @package Distribution.Setup
08:34:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Distribution.Setup
08:34:20 <matthewp> unfortunately, HLint gives no hints
08:34:27 <Phyx-> right..
08:34:42 <matthewp> any ideas?
08:34:47 <asgaroth> matthewp: not really refactoring, but I always find that using liftM as infix makes it a bit clearer.
08:36:00 <matthewp> asgaroth: understood, that's where I was thinking, but was hoping for something cleaner
08:36:06 <Phyx-> i thought Distribution.Setup was in Cabal
08:39:46 <Lemmih> SamB_XP: You can send the patch to me directly.
08:41:29 <Peaker> matthewp: I don't think LINQ is the list monad
08:42:00 <Peaker> matthewp: consider the fact it can be used to modify the source (bidirectionality).  I also think its a bit more sophisticated a query than list, but that may be wrong
08:42:37 <EvilTerran> it's embeddable in Cont :P
08:42:42 <matthewp> Peaker: well, it has a base in the List Monad.  Look at the signature of SelectMany and you'll see the resemblance
08:42:54 <Peaker> matthewp: such horrible syntax, C# has :-(
08:42:56 <Peaker> (looking at examples)
08:43:18 <EvilTerran> asgaroth, have you met Control.Applicative.<$> and <*> ?
08:43:41 <matthewp> from x in Enumerable.Range(1, 10) from y in Enumerable.Range(11, 10) select x + y is a simple example
08:44:15 <EvilTerran> matthewp, (find3 . map read . lines) <$> getContents?
08:44:48 <EvilTerran> fmap f . fmap g = fmap (f . g)
08:44:54 <EvilTerran> liftM = fmap = (<$>)
08:44:54 <Peaker> @hoogle find3
08:44:55 <lambdabot> No results found
08:45:20 <matthewp> Peaker: find3 is my own function
08:45:49 <matthewp> Peaker: Just a simple [Int] -> [Int]
08:46:31 <EvilTerran> if this were a certain version of caleskell, that'd be "find3 . map read . lines . getContents", of all things
08:48:49 <matthewp> EvilTerran: Thanks, worked like a champ!
08:48:50 <kpreid> EvilTerran: but if you don't, you might as well be using ML!
08:48:51 <kpreid> :-)
08:49:48 <EvilTerran> kpreid, er, don't what? program in caleskell?
08:50:10 <kpreid> Something like that
08:50:23 <kpreid> ('twas a joke)
08:50:55 <EvilTerran> k :)
09:07:47 <fschwidom> TOPIC
09:09:18 <hugo___> how do i put a breakpoint in ghci ?
09:10:35 <lispy> topic?
09:10:39 <Phyx-> :b
09:10:59 <hugo___> hmm
09:11:07 <lispy> hugo___: :breakpoint ?
09:11:12 <hugo___> how about a breakpoint in a module that is not interpreted ?
09:11:33 <lispy> hugo___: well, ghci doesn't interpet
09:11:53 <hugo___> lispy: thats the output message for breakpoint on a module not on my code :P
09:12:22 <lispy> hugo___: if it's not your code, i bet you need some other debugger like gdb
09:12:29 <Phyx-> then you're trying to break somewhere not in your code that doesn't expose it's implementation
09:12:47 <lispy> hugo___: But, maybe I should shut up since I've never used the ghci debugger
09:12:52 <hugo___> :b Module.XPTO 123 outputs: "module 'Module.XPTO' is not interpreted
09:13:17 <mauke> hugo___: you can't :/
09:13:22 <hugo___> its haskell code, but not my code, i have the source from hackage though
09:13:37 <hugo___> hmm ok
09:13:43 <mauke> hmm, then you need to make sure ghci loads it from source
09:14:02 <hugo___> ill try good old IO style debugging
09:14:21 <mauke> what was the command for that? :m + *Foo?
09:14:42 <lispy> hugo___: yeah, on that subject, have you seen Debug.Trace?
09:14:45 <lispy> ?hoogle trace
09:14:46 <lambdabot> Debug.Trace trace :: String -> a -> a
09:14:46 <lambdabot> module Debug.Trace
09:14:46 <lambdabot> package traced
09:14:54 <imphasing> if `f x = x + x` and `g x = x + 1`, how come when I do something like `f (g 5)` it gives me '12', but when I do `g . f 5` it doesn't?
09:14:59 <hugo___> thats nice
09:15:00 <hugo___> thanks
09:15:06 <imphasing> I must not be getting this whole composition thing..
09:15:19 <Phyx-> hugo___: if you're trying to debug a package you downloaded, why not load that package up
09:15:30 * EmielRegis http://tnij.org/os_charts
09:15:41 <mauke> imphasing: precedence
09:15:43 <lispy> hugo___: trace can sometimes cause your program to behave differently, but often it's not a problem
09:15:50 <mauke> imphasing: try (f . g) 5
09:16:06 <imphasing> mauke, Well, I'm dumb. Thanks :)
09:16:25 <hugo___> Phyx-: the error is in my code, i just want to check the output of the several stages on the module to gain more insight about what the heck im doing wrong :P
09:18:59 <Phyx-> i have a question about Cabal, i downloaded a package, trying to compile it, but i get
09:19:05 <Phyx-> Setup.lhs:18:20: Not in scope: `compilerPath'
09:20:47 <Phyx-> @hoogle compilerPath
09:20:47 <lambdabot> No results found
09:21:12 <mauke> what package is this?
09:22:04 <hugo___> remove the line :)
09:22:28 <Phyx-> a really old package. i'm guessing this was in cabal but now is done differently
09:22:40 <Arnar> hey all
09:22:56 <frea> hello, please look at http://hpaste.org/13486, how could i make countSth1 more general? that 'fix' allows me to use countSth1 only for Ints
09:23:50 <Arnar> I'm having a hard time debugging some template haskell stuff
09:24:03 <dons> ?users
09:24:03 <lambdabot> Maximum users seen in #haskell: 597, currently: 586 (98.2%), active: 14 (2.4%)
09:24:14 <mauke> frea: that code works here
09:24:34 <Arnar> specifically I'm using derive package and Derive.Binary -- and I'm getting a run-time exception "chr: invalid argument"
09:24:35 <frea> ? without that 'fix' ?
09:24:40 <mauke> frea: yes
09:24:53 <Arnar> tried tracing it but the history isn't telling me much
09:24:54 <mauke> frea: I just pasted the first four lines into a file and loaded it in ghci
09:27:33 <frea> uh, sorry forgot about pasting code that calls it. calling countSth1 [Sth1] makes that error
09:27:42 <Phyx-> @hoogle showPackageId
09:27:43 <lambdabot> Distribution.Package showPackageId :: PackageIdentifier -> String
09:27:58 * ddarius came across the most wonderful CT term today: a bicoequinverter
09:29:05 <mauke> frea: foldr (\s cnt -> case s of Sth1 -> cnt + 1; _ -> cnt) 0 l
09:29:14 <Phyx-> @hoogle compilerPath
09:29:14 <lambdabot> No results found
09:29:25 <dons> i wonder if there's any chance we'd reach 600 users today.
09:29:53 <dons> it was < 6 months since we reached 500, which is interesting. that's still the same growth of 100 users every 6 months
09:30:18 <frea> thanks it works
09:31:15 <hugo___> hehe
09:31:37 <hugo___> today is party day
09:31:43 <Phyx-> bah, i give up, all these incompatibilities
09:31:51 <hugo___> i dont think people will come to #haskell to party :/
09:32:11 <ddarius> dons: That's merely linear growth.
09:32:21 <hugo___> "new year" is pointless
09:32:45 <faXx> dons: if you reach 600 when 6 months pass, i was will start refering to the occurence as the "dons' law" (reference to goldwin's law). Then within 2 month tops there will be a wikipedia entry about it :P
09:32:58 <faXx> if #haskell *
09:33:24 <dons> huh, we reached 200 in Jan 2006, 300 in Dec 2006, 400 in Aug 2007, 500 in Aug 2008
09:33:27 <dons> and 600 in Dec 2008...
09:33:31 <dons> so that's not linear
09:33:38 <hugo___> :)
09:33:41 <faXx> crap
09:33:45 <faXx> well it could have worked
09:33:51 <hugo___> its a good pointer though
09:34:06 <saml> what's maximum number of users supported by an irc channel?
09:34:08 <faXx> trying to make you famous here and you just had to come and destroy it with facts
09:34:24 <hugo___> saml: 256 :)
09:34:34 <dons> there's no maximum
09:34:52 <dons> only a handful of channels are above 600 though.
09:35:26 <saml> ##PHP wins
09:36:27 <okriM> I'm new to this network. which sense does "##" make?
09:36:35 <hugo___> ## means not-official
09:37:05 <hugo___> its like a channel that is not the official channel for that theme
09:37:20 <hugo___> ...i think
09:38:53 <saml> holy shat #ubuntu 1324 users
09:39:46 <dons> #java doesn't exist anymore?
09:40:00 <saml> it's ##Java
09:41:16 <frea> mauke: i tried to make that function more general, taking what it calculating as argument, i came up with http://hpaste.org/13487.(compiler complains about overlapped patter matches)
09:41:26 <czShadoW> It's just succ 2008, nothing special.
09:41:54 <Zao> czShadoW: Unless you're a Zune 30GB developer.
09:41:57 <mauke> frea: yep
09:42:00 <MiniCow> Are there any standard libraries for finding roots of functions? (e.g. find where (f x) == 0)
09:42:21 <mauke> frea: that pattern binds a new variable (also called 'what'); it doesn't use the function argument
09:43:32 <frea> ah ok
09:43:56 * ddarius should make an implementation of Barry Jay's pattern calculus.
09:44:19 <czShadoW> Zao: That is some variation of Y2k?
09:44:30 <mauke> frea: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.case
09:46:47 <Zao> czShadoW: http://www.neowin.net/news/main/08/12/31/30gb-zunes-failing-due-to-software-glitch
09:47:25 <czShadoW> Ooops!
09:49:19 <luite> how can I make the haskell profiler count the amount of time spent in a foreign function?
09:52:44 <BMeph> okriM, hugo__: Technically, the ## on a channel means that it isn't "official" according to the freenode people, so most channels should have it. Since it's extra typing compared to just one #, most folks ignore the convention, and use one #. The freenode folks don't kick anyone off for it, but they haven't shown signs of re-thinking the policy, either. :)
09:56:52 <hugo___> olraite
09:56:57 <hugo___> well, its party time for me...
09:57:13 <hugo___> so, see you next year
10:00:39 <dons> hey, this is pretty cool,
10:00:40 <dons> http://www.reddit.com/r/programming/comments/7moc9/haskell_now_has_an_ffi_to_erlang_impersonate/
10:00:51 <dons> all the secret projects people work on..
10:01:45 <lispy> top secret
10:02:01 <sclv> delightful
10:02:11 <dons> sclv: yeah, very interesting, eh?
10:02:35 <sclv> very cool
10:02:58 <dons> i'm impressed by the new stuff produced this month.
10:03:03 <dons> lots of useful libs and bindings and tools
10:08:46 <frea> mauke: thanks, but it didn't help much.
10:12:24 <dons> interesting, another (biggish?) haskell web framework,
10:12:25 <dons>  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/salvia-0.0.4
10:12:32 <dons> sclv: how many does that make now? :)
10:12:52 <RayNbow> @users
10:12:53 <lambdabot> Maximum users seen in #haskell: 597, currently: 578 (96.8%), active: 19 (3.3%)
10:13:00 <sclv> got to be five or so?
10:15:03 <maltem> interesting, that web framework is STM-based
10:15:28 <centrinia> Is there an IOT (IO Transformer) monad?
10:15:45 <maltem> centrinia: no, there is no IO monad transformer
10:16:43 <vegai> and a nice name
10:16:51 <vegai> although poorly googlable
10:17:20 <ddarius> @google salvia web framework
10:17:22 <lambdabot> No Result Found.
10:17:37 <centrinia> @google salvia
10:17:40 <lambdabot> http://en.wikipedia.org/wiki/Salvia_divinorum
10:17:40 <lambdabot> Title: Salvia divinorum - Wikipedia, the free encyclopedia
10:18:41 <dons> shamen magic eh?
10:18:50 <dons> "nduce a visionary state"
10:20:20 <vegai> also, he wrote a wiki on it
10:20:22 <vegai> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/orchid-0.0.6
10:20:27 <vegai> with a darcs backend, even.
10:21:44 <bos> wow, everyone's got one.
10:22:05 <bos> i feel inadequate for not having written four or five web frameworks.
10:22:23 <saml> how easy/hard is it to make an  http server? a single threaded one. so that i can visit loalhost:8080 and see hello world
10:22:38 <ddarius> saml: Stupid easy.
10:22:40 <sclv> bos: just set aside an afternoon :-)
10:23:01 <saml> ddarius, do i need to install HTTP library from hackage? or can I just use Network.CGI ?
10:23:03 <bos> dons: did you see the bytestring patch i sent?
10:23:20 <bos> saml: if you use Network.CGI, you'll need a server like Apache to run it
10:23:26 <sclv> saml: neither will create an http server.
10:23:29 <ddarius> saml: You don't need either if you are making the server.
10:23:46 <sclv> and the http library from hackage is for the client side
10:23:50 <ddarius> Though the HTTP package probably has some functions that are useful.
10:24:02 <bos> sclv: it has a little bit of server-side support
10:24:30 <saml> use Network.Socket and study HTTP protocol?
10:25:12 <dons> saml, it is one line of Network.HAppS
10:25:19 <dons> bos, yes. recvd.
10:25:27 <dons> bos, i'm on vacation ... so prob. won't apply it till next week
10:25:52 <sclv> bos: ok, i see the functions you're talking about.
10:26:00 <bos> dons: no rush
10:26:08 <dons> bos, good catch though.
10:26:17 <dons> dcoutts will jump up and down about strictcheck again :)
10:26:33 <bos> yeah, i suspect that there are several such bugs.
10:26:46 <dons> yep. we've caught 2 i know of, long after the fact.
10:26:55 <dons> needs a day of auditing for 'off by one' chunk laziness properties
10:26:58 <bos> strictness bugs are really tricky beasties.
10:27:28 <dons> they're easy to catch with the strictcheck properties: you should be as lazy as a lazy list impl. in lazy bytestrings.
10:27:43 <dons> which often shows up one-byte too eager bugs
10:29:21 <dons> GhcT mtl transformer is interesting
10:29:40 <bos> i should write a blog posting about best practices for network programming in haskell.
10:29:57 <dons> would be useful.
10:30:05 <dons> also: a survey of the state of play library-wise
10:30:11 <bos> yep.
10:30:18 <harinath> Happy New Year
10:30:20 <mauke> hey, Angelina24-Cam is back
10:30:44 <mauke> and I'm still not an op :[
10:30:54 --- mode: ChanServ set +o sjanssen
10:31:00 --- mode: sjanssen set +b *!*n=xxx@*.190-30-166.telecom.net.ar
10:31:00 --- kick: Angelina24-Cam was kicked by sjanssen (sjanssen)
10:31:13 <bos> what's that bot been doing?
10:31:21 --- mode: ChanServ set -o sjanssen
10:31:27 <mauke> onjoin spam
10:31:28 <bos> @users
10:31:29 <lambdabot> Maximum users seen in #haskell: 597, currently: 577 (96.6%), active: 20 (3.5%)
10:31:42 <bos> damn, we're doing well for new year's eve/day
10:31:46 <dons> i'm not sure what is the current state of play of libs. there's been so many developments this month.
10:32:10 <bos> well, it's safe to say that most stuff uploaded this month probably isn't fully cooked :-)
10:32:11 <dons> http 4 (with bytestring), lots of frameworks now, several templating systems, new db releases. happs is stablised..
10:32:22 <dons> big diff. from 12 months ago
10:32:42 <dons> need  to spend some time cleaning up the shootout entries too.
10:32:50 <dons> a few missing / old things. and they've got 6.10 now
10:33:03 * bos `liftM` office
10:33:04 <dons> (we climbed a few points just by subbing in 6.10, which is nice)
10:33:10 * dons `ap` pool
10:33:27 <bos> lucky sod
10:33:39 <dons> ;)
10:33:42 <sclv> a nice what's new and exciting about http4 post would be very helpful.
10:33:54 <dons> and sof wrote a dozen or so web 2.0 thingies this year
10:34:05 <RayNbow> :t dons
10:34:06 <lambdabot> Not in scope: `dons'
10:34:14 <RayNbow> in which module does dons reside in? ;)
10:34:37 <RayNbow> or more importantly... where's the pool! :p
10:34:40 <dons> galwegians in general: openid, gravatar, twitter, flickr, mediawiki, sqlite, json, ...
10:34:54 <dons> yeah, i should get off irc. see you later all.
10:35:00 <RayNbow> laters :)
10:39:00 -ChanServ(ChanServ@services.)- sjanssen set flags +votiA on mauke.
10:39:16 <sjanssen> mauke: you should be able to become op now
10:40:59 <mauke> awesome
10:44:09 <vegai> ah, salvia built just fine by cabal install
10:46:05 --- mode: ChanServ set +o mauke
10:46:10 --- mode: mauke set -o mauke
10:53:09 <ddarius> let server = forkIO $ listenOn (PortNumber 8080) >>= server' where server' socket = do (h,_,_) <- accept socket; hPutStr h "HTTP/1.0 200 Ok\r\n\r\n<h1>Hello World!</h1>"; hClose h; server' socket
10:55:21 <bohdan> hi
10:55:46 <bohdan> I don't understand why I can't curry assertEqual from HUnit ?
10:56:39 <Asztal> is it just me or is http://haskell.org/ghc/docs/latest/html/libraries/base/Control-OldException.html#v%3Athrow wrong? Surely it should be "throw :: Exception -> a"?
10:57:01 <vixey> :t Control.OldException.throw
10:57:02 <lambdabot> Couldn't find qualified module.
10:57:15 <vixey> t Prelude> :t Control.OldException.throw
10:57:16 <vixey> Control.OldException.throw :: (GHC.Exception.Exception e) => e -> a
10:57:42 <Asztal> I thought Control.OldException was just GHC 6.8's Control.Exception
10:58:10 <ski_> Asztal : apparently `Exception' <http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception-Base.html#t%3AException> is a class
10:58:24 <bohdan> so I have 'eq = assertEqual "message"' and then TestCase $ eq 1 1 -- this doesn't work, but 'eq a b = assertEqual "message" a b' works
10:58:46 <sclv> bohdan: think carefully about your types.
10:59:22 <Asztal> hmm, OK, so OldException isn't an exact copy of GHC 6.8's Exception, I see :)
10:59:44 <ski_> @type Test.HUnit.Base.assertEqual
10:59:46 <lambdabot> forall a. (Show a, Eq a) => String -> a -> a -> Test.HUnit.Lang.Assertion
10:59:56 <ski_> sclv : DMR, i'd say
11:00:08 <sclv> hmm.
11:00:12 <rwbarton> bohdan: because of the monomorphism restriction; add a type signature to eq
11:00:22 <ski_> hrm, s/sclv/bohdan/
11:00:31 <vixey> or turn off monomorphism
11:01:13 <redditbot> Haskell FFI to Erlang: impersonate Erlang nodes on the network with Haskell
11:01:13 <redditbot> salvia: (yet another) lightweight web framework for Haskell using transactional memory
11:01:13 <redditbot> Handling explicit and implicit recusion in Haskell data
11:02:26 <bohdan> ski_, do you mean 'department of mental retardation? :)
11:02:58 <sclv> dreaded monomorphism restriction
11:03:35 <ski_> bohdan : more like `Dicing Myoproteid Regulatable'
11:05:29 * bohdan is confused like hell
11:06:32 <sclv> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:08:04 <bohdan> sclv, yeah was just reading that -- didn't help but whatever, I'm not at that level of understanding haskell anyway
11:08:35 <sclv> so take a simple thing: [0..]
11:09:04 <sclv> if I say "nums = [0..]" then that's actually something of "forall a. Num a => [a]" right?
11:09:14 <sclv> well, enumerable too
11:09:40 <sclv> but the notion is the same. -- nums, which we think is just a list of numbers, is actually going to have to be stored as a function with a polymorphic type
11:09:47 <sclv> so it has to be recomputed each time we use it.
11:10:00 <athos>  Could not find module `Graphics.SOE.Gtk':
11:10:09 <athos> is it possible to fetch this package via cabal install?
11:10:21 <sclv> haskell98 in its infinite wisdom said "this will not stand!" and thus forces "nums = [0..]" to be of only a SINGLE type (i.e. monomorphic)
11:10:22 <ski_> bohdan : basically, whenever you define `foo = ...' (as opposed to `foo x ... = ...', the DMR insists on `foo' not being overloaded .. so instead of `eq :: (Show a, Eq a) => a -> a -> Assertion' above, you get `eq :: a -> a -> Assertion' where `a' is some specific instance of `Show' and `Eq' (chosen by defaulting) .. if there's no appropriate default found, you'll get an error
11:10:56 <athos> @hoogle Graphics
11:10:57 <lambdabot> package graphics-drawingcombinators
11:11:04 <sclv> you can of course change this behavior by declaring an explicitly polymorphic type signature.
11:11:26 <ski_> (sclv : do i detect irony somewhere there ?)
11:11:34 <vixey> bohdan: just use -XNoMonomorphismRestriction and it works
11:11:42 <sclv> ski_: I can't tell anymore :-)
11:11:44 <ski_> ([tm])
11:11:45 <vixey> bohdan: or {-# LANGUAGE NoMonomorphismRestriction #-} at the start of the file
11:12:00 <vixey> bohdan: you don't have to put any type signatures down
11:12:16 <bohdan> ski_, sclv, vixey : thanks folks :)
11:13:18 <dmwit> athos: I think maybe Gtk2Hs has the SOE modules.
11:15:29 <dmwit> athos: Yup, http://www.haskell.org/gtk2hs/docs/current/Graphics-SOE-Gtk.html
11:15:40 <dmwit> athos: So, no, you can't get that module via cabal-install.
11:15:50 <athos> dmwit: cabal: cannot configure soegtk-0.9.12.2. It requires cairo >=0.9.12 and gtk
11:15:54 <dmwit> They're working on cabalizing Gtk2Hs, but the work isn't completed, yet, I think.
11:16:01 <athos> hm
11:16:12 <athos> ok, i guess i've to read the docs
11:16:36 <dmwit> athos: Just install all of Gtk2Hs, it'll save you a lot of time over trying to install just the packages you need.
11:16:44 <dmwit> Besides, Gtk2Hs is pretty useful anyway. =)
11:18:02 <athos> ok
11:18:17 <athos> i'll fetch the tarball and hope it'll compile with ghc 6.8.3 and freebsd :)
11:23:01 <BMeph> BONUS_, ddarius: Any chance you two could collaborate to make: "Learn you a opology for Great Good"? :)
11:24:27 <dmwit> opology?
11:24:27 <ski_> @wn opology
11:24:38 <lambdabot> No match for "opology".
11:25:03 <idnar> apology?
11:25:08 <idnar> ontology?
11:25:39 <googl> topology
11:28:11 <ski_> > uncurry (++) (munch "apology" "apomorphism")
11:28:13 <lambdabot>   "logymorphism"
11:28:35 <ziman> @t munch
11:28:36 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:28:43 <ziman> :t munch
11:28:44 <lambdabot> forall t. (Eq t) => [t] -> [t] -> ([t], [t])
11:31:43 <dmwit> Wow, google really does know all... even how to speak in IRC.
11:31:43 <ddarius> > uncurry (++) (((unzip . filter (uncurry (/=)) .) . zip) "apology" "apomorphism")
11:31:45 <lambdabot>       The operator `.' [infixr 9] of a section
11:31:45 <lambdabot>          must have lower prece...
11:31:55 <ddarius> > uncurry (++) ((((unzip . filter (uncurry (/=))) .) . zip) "apology" "apomorphism")
11:31:56 <lambdabot>   "lgymrp"
11:32:14 <ddarius> > uncurry (++) ((((unzip . dropWhile (uncurry (==))) .) . zip) "apology" "apomorphism")
11:32:15 <lambdabot>   "logymorp"
11:33:36 <dmwit> > let munch (a:as) (b:bs) | a == b = munch as bs | otherwise = (a:as, b:bs); munch as bs = (as, bs) in munch "apology" "apomorphism"
11:33:38 <lambdabot>   ("logy","morphism")
11:34:12 <dmwit> > let munch (a:as) (b:bs) | a == b = munch as bs; munch as bs = (as, bs) in munch "apology" "apomorphism"
11:34:14 <lambdabot>   ("logy","morphism")
11:35:04 <ddarius> dmwit: That would be the sensible way of writing it, but I was trying to do it compactly without explicit recursion.
11:35:12 <dmwit> You could probably do something nasty with inits and tails if you wanted that.
11:35:15 <ddarius> or case analysis
11:36:06 <bohdan> http://www.haskell.org/haskellwiki/99_Haskell_exercises should really contain unittests instead of examples
11:36:25 <ddarius> Are examples not unit tests?
11:37:26 <Elly> perhaps they should use quickcheck though
11:37:31 <Elly> for demonstration purposes?
11:38:08 <vixey> 11 Problem 89
11:38:08 <vixey> <Problem description>
11:38:08 <vixey> Example:
11:38:08 <vixey> <example in lisp>
11:38:09 <vixey> ?????
11:39:24 <Elly> vixey: haha :P
11:39:34 <Elly> vixey: a lot of them seem to do that!
11:39:54 <ddarius> vixey: It's a fill-in-the-blank.
11:40:03 <Elly> mad-libs for Haskell :)
11:43:54 <sinelaw> hi
11:43:56 * BMeph apologizes to everyone, and promises to "lern2tiep" in the near future. Well, either that, or find a keyboard shaped like a game controller...
11:44:56 <BMeph> ddaruis, BONUS_: Yes, I meant "Topology". Sorry for my not being able to type and watch the screen at the same time. :)
11:45:49 <rey_> BMeph: FYI: http://www.extremetech.com/article2/0,2845,2337587,00.asp :)
11:45:52 <bohdan> ddarius, can you test your implementation against examples automatically?
11:48:45 <ski_> (BMeph : were you thinking of stuff like "Synthetic topology of data types and classical spaces" ?)
11:48:47 <ddarius> bohdan: As automatically as unit tests.
11:49:12 <bohdan> I can't understand why haskell, unlike lots of other languages, disallows trailing comma in list literals? it makes multiline lists much harder to edit :( e.g. [1,2,3,]
11:49:53 <alza> kse!
11:50:02 <bohdan> ddarius, do you refer to http://code.google.com/p/hs-doctest/ ?
11:50:10 <alza> kse!
11:50:18 <vixey> alza, yeah yeah heard you
11:50:45 <BMeph> alza: Put some in a can, then we'll talk. ;p
11:51:23 <sinelaw> ma ze kase?
11:51:25 <alza> kse in a can? I won't do that
11:51:31 <sjanssen> bohdan: usually we put the comma on the new line: [1\n, 2\n, 3\n]
11:51:36 <BMeph> ski_: If I understood what that was, I'd probably say "Yes." As it is, I'll say "Probably yes." :)
11:51:38 <sjanssen> bohdan: so the only irregular line is the first
11:52:24 <vixey> @remember <alza> kse in a can? I won't do that
11:52:24 <lambdabot> It is stored.
11:52:44 <bohdan> sjanssen, ok thanks -- makes sense :)
11:53:01 <ddarius> BMeph: Your response to ski_ would depend on whether you are interested in learning "traditional" topology or a somewhat non-standard form.
11:53:03 <mauke> bohdan: write 1: 2: 3: [] instead
11:53:14 <bohdan> sjanssen, although I see no harm in allowing the other style too
11:53:27 <mauke> > "foo": "bar": "baz": []
11:53:29 <lambdabot>   ["foo","bar","baz"]
11:54:05 <Badger> hmmmm, canned kse.
11:54:12 <Badger> ...urgh.
11:55:15 <bohdan> obligatory: http://www.youtube.com/watch?v=B3KBuQHHKx0
11:59:33 <BMeph> ddarius: Is there an equivalent in "standard" form to it, then, because I want to be able to build on what I know. Also, is the "traditional" form on it's way out, or just known to be lacking? :)
12:00:41 <BMeph> rey_: Thanks for the ref, I'll look at it. There's a particular one I'm thinking of, though, and if I find the link, I'll let you know. :)
12:01:26 <BMeph> rey_: No sooner said than done: http://www.alphagrips.com/
12:01:40 <ddarius> BMeph: The "traditional" form is what everyone is using.  It is what people usually mean when they say "topology."  Synthetic topology tries to be as similar to traditional topology as it can while still achieving it's ends.  Presumably similarly for point-free topology.
12:02:31 <BMeph> ddadrius: So what does synthetic topology synthesize? :)
12:02:49 <vixey> loll
12:04:01 <sinelaw> topology?
12:04:05 <ddarius> BMeph: When you hear "synthetic foo" it usually means that foo has been recast in a Cartesian closed category.
12:05:52 <BMeph> ddarius: Hm, interesting convention. So, what does it mean for "analytic bar"? :)
12:09:36 <ddarius> Well there's another (arguably a "generalization") of "synthetic" that is juxtaposed to "analytic" whereby "whole" things are worked with rather breaking them down into point, e.g. synthetic geometry v. analytic geometry
12:12:21 <ddarius> This is a cute proof: "Theorem: It is consistent with intuitionistic set theory for there to exist a set X such that X ~ X^X in which there exists a, b in X such that a /= b. Proof: Apply Yoneda lemma to domain-theoretic model of untyped lambda calculus."
12:12:49 <sinelaw> ouch.
12:14:14 <vixey> X ~ X^X is an inaccessible cardinal?
12:14:16 <bohdan> 'assertEqual "" [1] [1]' works,  'assertEqual "" [] []' complains -- how do I fix this?
12:15:28 <ski_> BMeph|lunch : topology in Haskell <http://www.haskell.org/pipermail/haskell/2004-June/014134.html>, Seemingly impossible functional programs <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>, A Haskell monad for infinite search in finite time <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
12:15:30 <ddarius> vixey: No.
12:19:51 <ski_> bohdan : you need to tell what type the list elements are of ..
12:20:16 <vixey> bohdan, did you turn off monomorphism?
12:20:22 <vixey> :t assertEqual
12:20:23 <lambdabot> Not in scope: `assertEqual'
12:20:37 <bohdan> vixey, no I decided to struggle on with it :)
12:20:45 <vixey> bohdan, bad idea I guess
12:20:56 <ddarius> vixey: The monomorphism restriction isn't the problem.  It could only help here.
12:21:27 <bohdan> :t Test.HUnit.assertEqual
12:21:29 <lambdabot> forall a. (Show a, Eq a) => String -> a -> a -> Test.HUnit.Lang.Assertion
12:21:46 <vixey> > Test.HUnit.assertEqual "" [] []
12:21:47 <lambdabot>   /tmp/6680482713084501747:70:32:
12:21:47 <lambdabot>      Not in scope: `Test.HUnit.assertEqual'
12:22:03 <sjanssen> bohdan: assertEqual "" ([] :: [()]) []
12:22:26 <bohdan> acutally, this works from the interpreter prompt, but not when loading a file
12:22:35 <bohdan> which makes it twice as confusing
12:22:43 <ddarius> bohdan: That's due to GHCi's extended defaulting.
12:23:10 <sjanssen> > typeOf $ [] -- -fextended-defaulting at work
12:23:11 <lambdabot>   Add a type signature
12:23:14 <sjanssen> pssh
12:23:42 <Twey> Doesn't work for me
12:23:48 <Twey> 'ambiguous type variable...'
12:24:14 <guenni8> hi, how can I format a number?
12:24:22 <sjanssen> bohdan: also, QuickCheck would be nicer than unit tests here :)
12:24:34 <Twey> guenni8: Text.Printf.printf perhaps?
12:24:35 <sjanssen> @check \xs -> xs == (xs :: [Int])
12:24:36 <lambdabot>   "OK, passed 500 tests."
12:24:40 <sjanssen> @scheck \xs -> xs == (xs :: [Int])
12:24:41 <lambdabot>   "OK, passed 500 tests."
12:24:46 <sjanssen> hmm
12:25:04 <guenni> Twey: thx
12:25:07 <sjanssen> okay, which jerk removed smallcheck?
12:25:13 <Twey> Haha
12:26:13 <Twey> what jerk**  the scope of the set of jerks is unknown \end{grammarnazi}
12:26:35 <ddarius> Bah, there's only finitely many.
12:26:41 <bohdan> Twey, presumably those who have root access to the bot
12:26:49 <sjanssen> yes, limited by the number of people who have commit access to the repo
12:26:55 * sjanssen already has theories
12:27:19 <Twey> Heh, fair enough :-P
12:28:26 <sjanssen> it's looking like it might be me :(
12:29:11 <sjanssen> nope, Cale
12:29:26 <ddarius> That will make meteing out punishment easy.
12:29:28 <sjanssen> Cale: any reason you removed smallcheck from the modules list?
12:29:37 * ddarius doesn't know how to conjugate mete.
12:30:29 <Twey> 'meting', I think
12:33:10 <bohdan> since when is 'mete' a verb?
12:33:35 <Twey> bohdan: It's always been a verb
12:33:54 <Twey> The noun comes from the verb form, in fact
12:38:35 <BMeph> bohdan, Twey: So, when is 'mete' used as a noun? :)
12:39:31 <Twey> BMeph: It means a limit of something
12:39:35 <Twey> 'The mete of my patience'
12:43:26 <guenni> Twey: is there an alternative to this function?
12:44:48 <Twey> guenni: *shrugs* You can do it yourself, or I'm sure there are assorted low-level formatting functions about
12:44:54 <Twey> @index pad
12:44:54 <lambdabot> bzzt
12:44:55 <mmorrow> preflex: seen Heffalump
12:44:55 <preflex>  Heffalump was last seen on #haskell 22 hours, 28 minutes and 47 seconds ago, saying: saml: I believe GHC has one, but I forget how to use it.
12:45:27 <guenni> Twey: thx
12:46:04 <mmorrow> does anyone know off hand how any (*lightweight*) methods to generate a .xls excel file /with formulas generated by you/?
12:46:11 <Twey> guenni: Use 'show' to convert the number to a string, you can do what you like from there
12:46:56 <athos> hm, building gtk2hs 0.9.3 on freebsd failed: http://hpaste.org/13489
12:47:02 <athos> is this a known error?
12:47:13 <athos> aah, it's 0.9.13 of course
12:47:31 <mmorrow> or i should say, "to write one out assuming the formulas are already generated"
12:47:56 <Absolute1> http://rafb.net/p/OnxJcq10.html <-- why is there a brace error here
12:48:02 <Absolute1> i matched all the braces
12:48:09 <Absolute1> error is in the paste as well
12:48:19 <EvilTerran> Absolute1, you need to indent the { more
12:48:39 <EvilTerran> it's indented no more than the line above, so is interpreted as a new line in the do-block
12:48:54 <Absolute1> EvilTerran: haskell handless whitespaces like python?
12:49:03 <EvilTerran> mostly
12:49:04 * mmorrow gave himself about 1% chance of finding someone with a nice and easy method to do that :)
12:50:27 <ddarius> xslx files are just zipped xml files, though that isn't very convenient (though much better than a proprietary binary format)
12:52:51 <rey_> it might be easier to output some ancient spreadsheet format (say 1-2-3) if office still ships conversion filters for them by default
12:53:52 <mmorrow> i'm glad i took one last peek at the logs
12:54:05 <mmorrow> ddarius: good call, i'll check that out.
12:54:48 <mmorrow> i hope that i'm not crazy to assume that i can spit out formulas into them
12:54:53 <athos> oh
12:54:59 <mmorrow> we shall see..
12:55:00 <athos> there's even a gtk2hs port for freebsd
12:55:04 <athos> i hope that'll build
12:57:07 <ddarius> @tell mmorrow If you are still interested and you didn't already find them, the standard that is used is http://openxmldeveloper.org/default.aspx
12:57:07 <lambdabot> Consider it noted.
12:57:43 <ddarius> :t runWriterT
12:57:44 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
13:00:13 <BMeph> mmorrow: Also, you might see if OO.o may work it better for you. :)
13:02:41 <BMeph> Which reminds me: Could someone explain what the benefits are of making a "standard" for some protocol, but charging money to see it? :\
13:03:13 <Heffalump> money?
13:04:33 <BMeph> Well, not always money, since it's pretty easy to make money at something, but in general, restricting access to the protocol description that is still in the process of being accepted.
13:04:43 <bohdan> http://www.haskell.org/haskellwiki/99_questions/1_to_10 -- question 8's solution uses `group` which doesn't seem to be defined in the prelude. where is it ?
13:05:04 <BMeph> bohdan: It's definitely in Data.List. :)
13:05:58 <BMeph> My "canonical" example is Miranda - what possessed a company to invent a programming language, then restrict the means to learn it?
13:06:27 <Twey> Heh
13:06:53 <Twey> Yeah, it sounds a bit stupid really
13:07:06 <BMeph> (modulo what it would mean for a company to "invent" something, yada-yada-yada.)
13:07:12 <vegai> some people use that strategy to add business value
13:08:19 <BMeph> How does that quote go, "Here is a purse full of money...which I'm not going to give you." ;p
13:35:09 <athos> naaaah
13:35:28 <athos> even the gtk2hs port fails at buliding
13:35:30 <athos> *building*
13:36:22 <Shurique> is there any way to identify exceptions thrown by Network.connectTo?
13:36:38 <athos> http://hpaste.org/13490
13:37:30 <sjanssen> @pl (\y -> ((x, y) :) . xs)
13:37:30 <lambdabot> (. xs) . (:) . (,) x
13:37:38 <athos> anybody got an idea how to fix this?
13:39:26 <athos> as you can see in the output, it even removes the file where the error occurs
13:39:35 <athos> so i guess i can't fix that by hand
13:39:56 <lispy> dons: I got my copy of RWH today :)
13:41:07 <lispy> dons: i think it needs a signature or three
13:45:16 <BMeph> BBL
13:45:32 <athos> anybody got gtk2hs working under freebsd?
13:49:26 <athos> ah, i see, it's a known error
13:49:38 <luite> does anyone know that the first parameter of replicateEachU does?
13:49:42 <luite> (package uvector)
13:50:10 <lispy> ?hoogle replicateEachU
13:50:11 <lambdabot> No results found
13:50:25 <lispy> luite: what is the type?
13:50:28 <luite> replicateEachU :: UA e => Int -> UArr Int -> UArr e -> UArr e
13:50:41 <athos> :t replicate
13:50:43 <lambdabot> forall a. Int -> a -> [a]
13:50:50 <lispy> It's how many copies
13:50:59 <athos> replicate 4 'a'
13:51:02 <athos> > replicate 4 'a'
13:51:05 <lambdabot>   "aaaa"
13:51:15 <athos> :t replicateM_
13:51:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
13:51:18 <luite> lispy: the UArr Int seems to specify now many copies of each element in the UArr e are made
13:51:43 <lispy> luite: http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/src/Data-Array-Vector-Strict-Basics.html
13:51:47 <lispy> luite: the source is there
13:53:06 <luite> hm, the meaning of n is hidden in replicateEachS
13:59:58 <quantax> ]\j
14:00:06 <lunabot>  luna: parse error on input `)'
14:07:44 <athos> newsham: online?
14:07:54 <leadnose> happy new year :)
14:08:06 <athos> happy new year leadnose
14:08:31 <abbe> Happy New Year to you too leadnose :)
14:08:32 <leadnose> any others already in 2009?
14:08:38 <athos> nope
14:08:43 <athos> still 52mins to go :D
14:09:10 <athos> and unfortunately i've to drive tonight :(
14:10:08 <dolio> luite: UArr doesn't store size information (I think), so that's what the first Int is probably for.
14:10:31 <vininim> great, it's raining :/
14:10:39 <Dessous> 2009 here
14:11:03 <abbe> Dessous, welcome it :)
14:11:28 <dolio> Then again, perhaps it does. Hmm...
14:11:57 <Dessous> Are there any good alternatives to WinRAR? I dislike 7zip
14:12:35 <athos> hm
14:12:38 <athos> that's strange
14:13:09 <EvilTerran> Dessous, what about 7zip's command-line interface?
14:13:18 <athos> tle.hs:65:23: Couldn't match expected type `Double' against inferred type `Angle' In the second argument of `(+)', namely `d * sin theta'
14:13:49 <athos> d is type Num (using fromIntegral), theta is type Angle = Float
14:13:52 <Dessous> I'm looking for a program with GUI
14:14:05 <athos> so what is expecting a Double?
14:14:09 <athos> the (+)?
14:14:34 <EvilTerran> athos, i guess either the context of (+) requires a Double, or the first argument of it is inferred to be a Double
14:14:40 <athos> hm ok
14:14:49 <ski_>      
14:15:18 <EvilTerran> 
14:15:30 <athos> yep, the first argument is double
14:15:36 <ski_> (EvilTerran : keyboard slip)
14:16:29 <EvilTerran> http://icanhascheezburger.files.wordpress.com/2007/05/catliketyping.jpg
14:16:37 <opqdonut> good new year and all
14:16:49 <athos> EvilTerran: now i'm unsure how to "fix" this, because i'm not very proficient with the "converting" functions
14:16:50 <opqdonut> cava rules \o/
14:16:58 <pumpkin> > fix this
14:16:59 <lambdabot>   Not in scope: `this'
14:17:11 <pumpkin> > fix this
14:17:14 <athos> is there anything that convertes from Num to Double? (because the result of the * operation seems to deliver something of type Num)
14:17:27 <lambdabot>   thread killed
14:17:33 <Badger> tsk tsk, pumpkin
14:17:35 <pumpkin> athos: nothing more specific than num?
14:17:36 <opqdonut> :t fromIntegral
14:17:37 <IWannaLog> :t sin
14:17:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:17:39 <lambdabot> forall a. (Floating a) => a -> a
14:17:39 <Zao> athos: FromIntefral?
14:17:53 <Zao> Protip - do not party and haskell at the same time.
14:17:56 <rwbarton> athos: Double is already a Num
14:18:07 <athos> hm
14:18:09 <rwbarton> athos: the question is where is Double coming from
14:18:09 <Zao> You may come up with a whole new set of monads.
14:18:10 <Badger> Zao: haskell party! :)
14:18:13 <IWannaLog> :t toRational
14:18:15 <lambdabot> forall a. (Real a) => a -> Rational
14:18:23 <athos> rwbarton: (x + d * sin theta(
14:18:26 <newsham> hello
14:18:34 <rwbarton> athos: hpaste more of the surrounding code maybe
14:18:43 <athos> x is Double, d is Num (fromIntegral someInt) and theta is Float
14:18:48 <athos> rwbarton: ok
14:18:50 <rwbarton> Yeah, you can't do that
14:18:58 <rwbarton> Do you really want to be using Float anyways? :)
14:19:10 <athos> well, it's not my own code
14:19:13 <rwbarton> Or, why mix them
14:19:13 <EvilTerran> given "sin", it's inevitable, isn't it?
14:19:14 <rwbarton> ah
14:19:24 <rwbarton> EvilTerran: I mean Float as opposed to Double
14:19:27 <EvilTerran> ah, yes
14:19:38 <athos> it's some Turtle module from newsham
14:19:47 <EvilTerran> does it have a url?
14:19:48 <athos> http://www.thenewsh.com/~newsham/x/machine/turtle/Turtle.hs
14:19:51 <athos> if anybody is interested
14:20:00 <athos> error occurs at line 65
14:20:02 <rwbarton> :t realToFrac
14:20:04 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
14:20:19 <rwbarton> that should convert Double to Float or Float to Double if you have to
14:21:00 <rwbarton> Angle is defined in Graphics.SOE.Gtk I guess?
14:21:04 <athos> yep
14:21:07 <IWannaLog> :t fromRational
14:21:08 <athos> type Angle = Float
14:21:08 <lambdabot> forall a. (Fractional a) => Rational -> a
14:21:37 <newsham> athos: you rang?
14:21:59 <Heffalump> hi andyjgill
14:22:09 * Heffalump was just looking at KURE
14:22:12 <athos> newsham: i had/have some problems with your Turtle.hs.. seems to be "simple" conversion problems
14:22:15 <athos> Float vs. Double
14:22:31 <athos> i guess i just try to convert them using realToFrac
14:22:46 <rwbarton> athos: Personally I would just change t_direction :: Angle to t_direction :: Double
14:22:55 <athos> hm
14:23:51 <athos> rwbarton: well, yeah, that seems to be the cleanest way
14:23:53 <athos> rwbarton: thanks!
14:24:02 <newsham> where are you getting Floats from?  perhaps you could change them to Dobles (or conversely redefine the Double values in Turtle.hs to Float)
14:26:08 <andyjgill> Hi Heffalump
14:27:31 <athos> newsham: btw. it seems your turtle has quite a "nice" design. i mean, for me as haskell newbie it looks quite usable and is a good example for using a state monad, isn't it? :))
14:28:04 <newsham> as the author i would have to say it is a stellar use of the state monad! ;-)
14:28:10 <newsham> but, yah, I guess its a good example.
14:28:30 <newsham> i'm glad you found it "nice".  I think haskell makes defining such systems nice
14:28:31 <newsham>         http://www.cnn.com/2008/POLITICS/12/31/burris.memorial/index.html
14:28:38 <newsham> oops, mispaste, sorry
14:47:02 <BMeph> > fix yourself
14:47:04 <lambdabot>   "No! No! No! No! No! No! No! No! No! No! No! No! No! No! No! No! No! No! No...
14:47:30 <lucca> :t yourself
14:47:32 <lambdabot> [Char] -> [Char]
14:48:23 <mercury^> > yourself
14:48:24 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
14:48:24 <lambdabot>        arising from a...
14:48:29 <mercury^> > yourself ""
14:48:30 <lambdabot>   "No! "
14:48:53 <vegai> :t fix
14:48:55 <lambdabot> forall a. (a -> a) -> a
14:49:07 <lucca> fix is Y
14:49:13 <vegai> ah
14:49:20 <lucca> > fix error
14:49:22 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:49:27 <vegai> :-)
14:49:31 <BMeph> Thus ends "Cheap Haskell Tricks, pt. I". :)
14:52:20 <Heffalump> > trace "5" undefined
14:52:21 <lambdabot>   Not in scope: `trace'
14:52:24 <Heffalump> shame
14:52:29 <Heffalump> > fix show
14:52:31 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:53:01 <Heffalump> > map length . group . fix $ show
14:53:37 <Heffalump> odd, that works for me in ghci
14:55:26 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/salvia-0.0.4 bah, this sounds interesting but there's no information anywhere
14:55:32 <mercury^> > map length $ group $ fix show
14:55:51 <lambdabot>   mueval: Prelude.read: no parse
14:55:58 <Heffalump> hackage links are always very unsatisfying, especially since the haddock usually takes a while to appear
14:57:31 <lucca> > [[1,x] | x <- [2^n-1 | n <- [1..]]] >>= id
14:57:36 <lambdabot>   [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1...
14:57:48 <Heffalump> paulvisschers_: was it you asking about newtype deriving for type families?
14:59:43 <lucca> heh, that's a Lot faster
14:59:52 <Heffalump> lucca: much less fun though :-)
15:00:06 <lucca> no, it was just a Different kind of fun
15:00:27 <lucca> well >>= on lists still amuses me anyway
15:01:04 <Heffalump> concatMap id == concat shocker!
15:01:58 <pumpkin> lol
15:02:08 <lucca> sequence is great fun also
15:02:40 <Heffalump> cross product?
15:03:12 <lucca> > sequence [[1..3],[4..6]]
15:03:14 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
15:04:01 <lucca> map length $ group $ sort $ map sum $ sequence [[1..6],[1..6],[1..6]]
15:04:05 <lucca> > map length $ group $ sort $ map sum $ sequence [[1..6],[1..6],[1..6]]
15:04:06 <lambdabot>   [1,3,6,10,15,21,25,27,27,25,21,15,10,6,3,1]
15:12:57 <schme_> happy new year
15:13:35 <FunctorSalad> > fix (":) love :) " ++)
15:13:39 <lambdabot>   ":) love :) :) love :) :) love :) :) love :) :) love :) :) love :) :) love ...
15:15:13 <ski_> > [x | n <- [1..] , x <- [1,2^n-1]]  -- lucca
15:15:15 <lambdabot>   [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1...
15:15:35 <lucca> ahhhhh
15:15:46 <lucca> yeah, that's a better way to do things
15:27:12 <paulrd> "functional array fusion", "loop fusion", "stream fusion" - i'm a bit confused to what extent these terms overlap.  any pointers to concise definitions?  thanks
15:29:34 <ddarius> > intersperse 1 $ map (subtract 1) $ iterate (2*) 1
15:29:36 <lambdabot>   [0,1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191...
15:38:54 <proq> don't forget "cons fusion"
15:40:51 <augustss> Happy new yesr!
15:42:02 <matthewp> augustss: Happy new year to you!
15:42:30 <augustss> I'm actually 5:12 into the new year. :)
15:42:46 <Heffalump> Singapore?
15:43:07 <augustss> India.
15:43:11 <matthewp> augustss: well, it's 18:42 here, so I have a few hours to spare
15:43:32 <Heffalump> is the leap second at midnight local time or midnight UTC?
15:43:40 <augustss> We're in Agra, going to see the Taj Mahal in 2 hours.
15:43:54 <augustss> Heffalump: good question!
15:44:34 <rwbarton> UTC
15:44:46 * ddarius should go to India some time.
15:44:55 <Heffalump> so that means that local time is xx:59:60 ?
15:44:57 <matthewp> UTC so it already happened
15:45:13 <Heffalump> no, UTC midnight is in 15 mins
15:45:17 <matthewp> oh wait
15:45:19 <matthewp> you're right
15:45:24 <Heffalump> I ought to be, I live in it :-)
15:45:45 <augustss> Heffalump: you live in it in the winter :)
15:45:50 * Heffalump tries to remember a good text-mode clock program in Linux
15:45:56 <byorgey> ooh, a leap second?
15:45:58 <Heffalump> augustss: I meant "right now", but yeah
15:46:19 * byorgey prepares to leap
15:46:23 <roconnor> ugh, each time zone gets a leap second?
15:46:31 <IWannaLog> Hi, do you you know why there is two words for type declaration: Data and newtype
15:46:43 <IWannaLog> isn't one better, and the compilator made the work for me
15:46:50 <byorgey> IWannaLog: newtype can only be used for types with a single constructor.
15:46:57 <augustss> They are not semantically equivalent.
15:47:16 <Heffalump> roconnor: no, there's one global leap second, see above
15:47:17 <IWannaLog> I know but i use newtype each type I got a simple type and don't want to use alias, and Data for the rest
15:47:18 <byorgey> with a newtype, the constructor tag will actually get compiled away before runtime.
15:47:31 <Heffalump> so they are at different numeric local times
15:47:38 <ziman> Heffalump, watch -n1 'date +"%H:%M:%S" | figlet' ;)
15:47:45 <Heffalump> ziman: yeah, that's my backup plan :-)
15:47:58 <IWannaLog> I used OCaml which did the work for me
15:47:59 <byorgey> IWannaLog: newtype and data with only one constructor are actually not the same thing.  the one with data will be lazier.
15:48:19 <IWannaLog> byorgey: oh intersting
15:48:21 <augustss> IWannaLog: in a strict language they would be the same, but not in HAskell.
15:48:32 <IWannaLog> I'm not used with lazy
15:48:36 <IWannaLog> it's very strange some times
15:48:45 <vixey> indeed!
15:48:48 <byorgey> IWannaLog: it can be strange indeed =)
15:49:02 <vixey> call by need is strange indeed
15:49:05 <IWannaLog> but it could be useful
15:50:01 * IWannaLog asks himself how he could use OCaml during so many time when Haskell exists
15:57:43 <dons> IWannaLog: its a good question. This is the 21st century :)
15:58:44 <vixey> haven't really noticed haskell programs to be more reliable/easy to build etc than ocaml
15:59:16 <vixey> quite the opposite maybe this'll change though
16:00:05 <Heffalump> hmph!
16:00:20 <Heffalump> the clock just paused at 59 instead of showing 60.
16:00:46 <byorgey> whoops, I missed it =P
16:01:06 <vixey> > 1+1
16:01:07 <lambdabot>   2
16:03:13 <crathman> Have a question about going from an ST into IO Monad:  http://hpaste.org/13491
16:03:33 <crathman> the first one with IORef works.  The second one with STRef fails to compile.
16:03:54 <crathman> how to you get ST Monad to play nice with IO Monad?
16:04:15 <crathman> Not haskell monad savvy enough to know how to phrase the question better
16:05:43 <rainmann> @hoogle stToIO
16:05:44 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
16:05:46 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
16:05:48 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
16:05:53 <dons> vixey: reliable/easy to build? quite the opposite? i.e. your haskell code's harder to build, and less reliable?
16:05:59 <dons> you're probably doing it wrong.
16:06:15 <crathman> rainmann:  thanks.  will try
16:07:40 <byorgey> crathman: you don't want stToIO, you want runST.
16:08:04 <byorgey> crathman: the problem is that makeSTRef has type  ST s STRef, but main has to have type  IO ().
16:08:04 <ski_> byorgey : i'm not sure about that
16:08:28 <ski_> byorgey : `makeSTRef :: a -> ST s (ST s a)'
16:08:51 <byorgey> oh, hm, you're right
16:08:56 <byorgey> so there are several problems =)
16:09:22 <byorgey> crathman: in any case, you can't use an ST action in main, since the types don't match
16:09:34 <ski_> (rainmann : btw, if you want, you could just `return (readSTRef balance)' instead of using the auxilary `let')
16:09:40 <byorgey> the whole point of ST is that all the stateful actions are encapsulated within a call to runST
16:10:10 <byorgey> @type runST
16:10:11 <ski_> you can use an `ST s' action as an `IO' action, using `stToIO'
16:10:13 <lambdabot> forall a. (forall s. ST s a) -> a
16:10:38 <byorgey> ski_: but that requires getting a 'RealWorld' from somewhere.  That's not really how ST is supposed to be used.
16:10:43 <ski_> (thereby instantiating `s' to `RealWorld' ..)
16:10:43 <Badger> "happy new year!"
16:10:45 <Badger> oops
16:10:48 <Badger> > "happy new year!"
16:10:49 <lambdabot>   "happy new year!"
16:10:52 <byorgey> oh, wait, never mind, I see
16:11:02 <ski_> byorgey : `IO' provides the `RealWorld'
16:11:10 <byorgey> huh, I didn't know you could do that =)
16:11:19 <byorgey> thanks ski_
16:11:21 <ski_> just as long as you're polymorphic in `s', it should work
16:11:26 <byorgey> right
16:11:54 <byorgey> it's actually pretty difficult to construct an ST action that isn't polymorphic in s, I think =)
16:13:38 <ski_> well, you could do something like `do r <- newSTRef bletch; return (stToIO (do x <- readSTRef r; fnord x))'
16:18:01 <Heffalump> ski_: eww
16:18:03 <byorgey> ski_: you could =)
16:19:11 <crathman> http://hpaste.org/13491#a1   that seems to work using stToIO...  Is that the idea?
16:19:39 <ski_> (.. well, imagine a `runST' wrapping all of that ..)
16:19:42 <crathman> and is there something similar for STM to IO?
16:20:01 <Heffalump> crathman: atomically
16:20:18 <Heffalump> that's the whole point of STM, that you can use atomically on its computations
16:20:42 <crathman> Heffalump:  thanks.
16:23:02 <ski_> crathman : try changing `getBalance <- makeSTRef 100' into `getBalance <- stToIO `liftM` stToIO (makeSTRef 100)' instead of using `stToIO' inside `makeSTRef'
16:23:42 <crathman> @ liftM
16:23:58 <ski_> (.. since presumably the idea was to not duplicate the code for `makeSTRef' for both `ST s' and `IO')
16:24:06 <ski_> @type Control.Monad.liftM
16:24:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:24:12 <ski_> basically `fmap'
16:24:38 <ski_> @type \x -> Control.Monad.ST.stToIO `liftM` Control.Monad.ST.stToIO x
16:24:40 <lambdabot> forall a. ST GHC.Prim.RealWorld (ST GHC.Prim.RealWorld a) -> IO (IO a)
16:29:27 <crathman> ski_: thanks.  redo at http://hpaste.org/13491#a2
16:32:01 <ski_> @type let f :: (forall s. ST s (ST s a)) -> IO (IO a); f x = Control.Monad.ST.stToIO `liftM` Control.Monad.ST.stToIO x in f
16:32:03 <lambdabot> forall a. (forall s. ST s (ST s a)) -> IO (IO a)
16:32:53 <ski_> hm, maybe `stToIO' would be better typed as
16:33:03 <ski_>   stToIO :: (forall s. ST s a) -> IO a
16:33:04 <ski_> ?
16:33:51 <ski_> (or maybe `stToIO :: exists s. ST s a -> IO a', if you will)
16:33:59 <IWannaLog> vixey: Its just that I find Haskell's type system more powerfull that ocaml's one
16:34:41 <ski_> (IWannaLog : fyi, vixey's connection broke about 11 minutes ago)
16:34:52 <IWannaLog> damned
16:43:34 <augustss> I find stToIO highly dubious.
16:44:04 <Heffalump> why?
16:44:05 <ddarius> If you're using it often, you probably just want IO
16:44:26 <ddarius> In the particular code, ST is completely pointless.
16:44:35 <augustss> First, it seems to assume that IO is implemented the way GHC does.  Second, if you need it, why not use IORef etc instead?
16:45:12 <atp> quick quickcheck question.  i have a property that uses implications, and because this restricts the testing space to a relatively small subset.  as a result, it never completes 100 tests (it averages around 40).  is there any way I can force quickcheck to run 100 tests?
16:45:14 <Heffalump> well, writing polymorphic ref-handling code would be harder without it
16:45:14 <ddarius> In the "lift on usage" version, you could make a case about controlling effects and making things explicit.
16:51:19 <athos> happy new year
16:51:24 <athos> :)
17:02:59 <athos> > 1283021380129381029381290831 + 5
17:03:01 <lambdabot>   1283021380129381029381290836
17:03:14 <athos> > (1283021380129381029381290831 + 5) :: Int
17:03:16 <lambdabot>   7085048634831682388
17:04:32 <InkBottle> Hi, along a call tree, informations contained in parameters are transmetted forward. Return values are transmetted backward. You can take a return value and put it in a parameter so that this information is doing a depth first traversal of the calling tree. Q: I'm looking for the right vocabulary to speek about those things, to write comment of the code. Would you know an adress where to find some informations about tha
17:04:47 <mae> happy new years!
17:05:00 <InkBottle> you too :)
17:05:10 <athos> mae: dito
17:05:10 <ziman> InkBottle, your question got truncated at: "some informations about tha..."
17:05:16 <EvilTerran> happy leap second!
17:05:19 <ziman> happy new year to all ;)
17:05:36 <ziman> where is midnight right now? Portugal?
17:05:59 <InkBottle> ziman: you missed 't?' :)
17:06:38 <athos> nope
17:06:40 <athos> portugal is UTC
17:06:44 <beelsebob> InkBottle: f (g x) -- puts the return value of g x into the parameter of f
17:06:50 <ziman> InkBottle, i did ;)
17:06:56 <athos> so i think its around 01:06 in portugal right now
17:07:00 <beelsebob> or are you wanting to pass the returned value into the function computing the return value
17:07:12 <beelsebob> along the lines of let x = f x in x
17:07:20 <Heffalump> I don't think there's much in UTC-<small number> timezones
17:07:32 <InkBottle> beelsebob: no, I am looking for 'vocabulary' to speak about it. :)
17:07:40 <ziman> so midnight is somewhere in the Atlantic ;)
17:07:42 <beelsebob> oh, I see
17:08:10 <InkBottle> beelsebob: there might be right way to say it in english
17:08:14 <Heffalump> South America (Argentina/Brazil) will be the next to have midnight.
17:08:16 <beelsebob> InkBottle: well, return and parameter are certainly the right vocabulary, but at least in most functional language implementations, there's no passing of values forwards and backwards going on
17:08:25 <beelsebob> instead there's chunks of graphs being reduced
17:09:31 <beelsebob> Heffalump: strange, I would have expected greenland
17:09:56 <Heffalump> the page I'm looking at only has big cities, so I might have missed that
17:10:25 <beelsebob> oh no, I'm wrong
17:10:33 <beelsebob> part of greenland just got it 10 mins ago
17:10:40 <beelsebob> and the next chunk gets it at the same time as brazil
17:11:10 <Heffalump> well, Brazil has to be the next, unless there's a 15/30 minute offset in between
17:11:22 <Heffalump> but I think the original question was about who'd just had midnight, so Greenland is the right answer.
17:11:36 <beelsebob> hehe
17:15:52 <beelsebob> Heffalump: there's always the safe answer: Antarctica
17:16:57 <Heffalump> not sure that has all that many time zones
17:30:31 <mohbana> what kind of file is .lhs?
17:32:08 <Cale> mohbana: Literate Haskell Script. There are two types: One where code lines are denoted with an initial "> ", and another where code lines occur between \begin{code} and \end{code}. All the rest of the file in either case is treated as a comment.
17:33:26 <mohbana> thanks
17:48:35 <dons> cuute, http://twitter.com/davejohnson/statuses/1088784537
17:58:37 <athos> dons: btw: my rwh copy was delivered right on time at christmas
17:58:38 <athos> :)
17:59:10 <athos> although amazon.de told me that they'd have shipping problems or stuff
18:11:26 <MrStamp>  /qujit
18:14:54 <bremner> I want to experiment with transforming some xml (opendocument) using Haskell. Is there a best toolkit for a relative beginner?
18:17:14 <hcube> bremner: i'm using HXT for parsing xml
18:18:43 <bremner> ah, I was just reading the web site.
18:19:30 <bremner> hmm, the latest versions look they require ghc-6.10
18:34:59 <athos> http://haskell.org/haskellwiki/Image:UnsafeHaskell.png
18:35:02 <athos> :D
18:35:25 <athos> man, seems like there are zillions of submissions to the logo contest
18:37:36 <SamB> arg
18:37:47 <SamB> Lemmih and syntaxpolice are both out :-(
18:38:24 <SamB> runghc -- why isn't it documented it and what is it supposed to do ?
18:38:31 <vininim> lambda 2009, haskellers!
18:39:08 <athos> http://haskell.org/sitewiki/images/3/36/Haskell-logo-revolution.png <- hah :>
18:39:58 <ddarius> SamB: It does what runhaskell does.
18:40:05 <SamB> ddarius: it doesn't work for me :-(
18:40:40 <SamB> oh, no wonder, it's resolving to /usr/local/bin/runghc ;-P
18:40:49 <SamB> that's NOT the right version of GHC
18:41:07 <luite> is it risky to use unsafePerformIO to call a function that generates random numbers? could the compiler optimize away the calls?
18:41:08 <CakeProphet> what would be the easiest way to get a list of numbers digits as [Int]
18:41:21 <CakeProphet> I'm trying to use map read but I'm getting no parse errors.
18:43:02 <rwbarton> > map (read . (:[])) "123"
18:43:04 <lambdabot>   [* Exception: Prelude.read: no parse
18:43:06 <rwbarton> > map (read . (:[])) "123" :: [Int]
18:43:08 <lambdabot>   [1,2,3]
18:43:42 <CakeProphet> hmmm... I didn't try applying the type constraint on the map functions return value.
18:44:29 <ddarius> > map digitToInt "123"
18:44:31 <lambdabot>   [1,2,3]
18:44:41 <CakeProphet> oh dude.
18:44:42 <CakeProphet> ...
18:44:47 <MyCatVerbs> > map ((flip subtract (ord '0') . ord) "123"
18:44:49 <lambdabot>   <no location info>: parse error on input `;'
18:45:06 <MyCatVerbs> > map ((flip subtract (ord '0')) . ord) "123"
18:45:08 <lambdabot>   [-1,-2,-3]
18:45:13 <athos> > foldr ((:).read.(:[])) "123"
18:45:15 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
18:45:15 <lambdabot>        arising from a...
18:45:24 <MyCatVerbs> Heh, whoops.
18:45:24 <ddarius> flip subtract, for Pete's sake
18:45:27 <athos> > foldr ((:).read.(:[])) [] "123"
18:45:28 <lambdabot>   [* Exception: Prelude.read: no parse
18:45:34 <athos> > foldr ((:).read.(:[])) [] "123" :: [Int]
18:45:35 <lambdabot>   [1,2,3]
18:46:06 <MyCatVerbs> > map (((flip subtract) (ord '0')) . ord) "123"
18:46:08 <lambdabot>   [-1,-2,-3]
18:46:09 <athos> hm, ghci gives me a "ambigious foobar add type constraint"
18:46:15 <athos> instead of "foobar: no parse"
18:46:20 <ddarius> MyCatVerbs: Don't ever write flip subtract
18:47:37 <MyCatVerbs> @check x `subtract` y == y - x
18:47:39 <lambdabot>   "OK, passed 500 tests."
18:47:43 <MyCatVerbs> Oops. Heheheh.
18:47:50 <Cale> @check \x y -> x `subtract` y == y - x
18:47:52 <lambdabot>   "OK, passed 500 tests."
18:47:53 <athos> > map (((ord '0') -).ord) "123"
18:47:53 <rwbarton> @pl flip subtract
18:47:54 <lambdabot> (-)
18:47:55 <lambdabot>   [-1,-2,-3]
18:47:58 <ddarius> > subtract x y
18:48:00 <lambdabot>   y - x
18:50:59 <SamB> dcoutts_: okay ... any particular reason why cabal-install won't build with the cabal HEAD ?
18:51:23 <SamB> Distribution/Client/SetupWrapper.hs:208:28:
18:51:23 <SamB>     Couldn't match expected type `Simple.PackageDBStack'
18:51:23 <SamB>            against inferred type `PackageDB'
18:51:23 <SamB>     In the third argument of `getInstalledPackages', namely
18:51:23 <SamB>         `(usePackageDB options')'
18:58:54 <hcube> where can i find info about parsing binary files in haskell?
18:59:49 <MyCatVerbs> hcube: http://code.haskell.org/binary/ <- szoink!
19:00:25 <MyCatVerbs> hcube: http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html <- and here's the API docs.
19:00:38 <hcube> thanks
19:00:55 <CakeProphet> > zipWith (zipWith (+)) [1..]
19:00:56 <lambdabot>       Overlapping instances for Show ([[a]] -> [[a]])
19:00:57 <lambdabot>        arising from a u...
19:01:17 <CakeProphet> > zipWith (zipWith (+)) (map even [1..]) (map odd [1..])
19:01:19 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Bool'
19:01:33 <CakeProphet> ...I'm not even sure what I'm doing.
19:01:42 <CakeProphet> > zipWith  (+) (map even [1..]) (map odd [1..])
19:01:43 <lambdabot>       No instance for (Num Bool)
19:01:44 <lambdabot>        arising from a use of `+' at <interac...
19:01:50 <CakeProphet> ...orite
19:01:59 <CakeProphet> > zipWith  (+) (filter even [1..]) (filter odd [1..])
19:02:01 <lambdabot>   [3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,1...
19:02:44 <CakeProphet> > zipWith  (*) (filter even [1..]) (filter odd [1..])
19:02:46 <lambdabot>   [2,12,30,56,90,132,182,240,306,380,462,552,650,756,870,992,1122,1260,1406,1...
19:04:02 <Olathe> > [3,7..]
19:04:06 <lambdabot>   [3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,1...
19:04:41 <CakeProphet> hmmm... neat.
19:04:41 <Olathe> > scanl (+) 2 [8,16..]
19:04:43 <lambdabot>   [2,10,26,50,82,122,170,226,290,362,442,530,626,730,842,962,1090,1226,1370,1...
19:04:53 <CakeProphet> I just made an unintersting arithmetic sequence, I suppose.
19:04:56 <Olathe> > scanl (+) 2 [10,20..]
19:04:58 <lambdabot>   [2,12,32,62,102,152,212,282,362,452,552,662,782,912,1052,1202,1362,1532,171...
19:05:06 <Olathe> Let's see
19:06:38 <athos> @src scanl
19:06:39 <lambdabot> scanl f q ls = q : case ls of
19:06:39 <lambdabot>     []   -> []
19:06:39 <lambdabot>     x:xs -> scanl f (f q x) xs
19:06:51 <ziman> > map (\n -> 4*n^2 - 2*n) [1..]
19:06:53 <lambdabot>   [2,12,30,56,90,132,182,240,306,380,462,552,650,756,870,992,1122,1260,1406,1...
19:07:07 <Olathe> > scanl1 (+) [2,10..]
19:07:12 <lambdabot>   [2,12,30,56,90,132,182,240,306,380,462,552,650,756,870,992,1122,1260,1406,1...
19:07:40 <athos> > scanl (+) 0 [1..]
19:07:42 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
19:08:01 <CakeProphet> let odds = [1,3...]; evens = [2,4...] in zipWith subtract (zipWith (+) evens odds) (zipWith (*) evens odds)
19:08:14 <CakeProphet> > let odds = [1,3...]; evens = [2,4...] in zipWith subtract (zipWith (+) evens odds) (zipWith (*) evens odds)
19:08:16 <lambdabot>   <no location info>: parse error on input `]'
19:08:35 <CakeProphet> > let odds = [1,3..]; evens = [2,4..] in zipWith subtract (zipWith (+) evens odds) (zipWith (*) evens odds)
19:08:37 <lambdabot>   [-1,5,19,41,71,109,155,209,271,341,419,505,599,701,811,929,1055,1189,1331,1...
19:09:06 <CakeProphet> sequences were my favorite section of high school math. :D
19:09:46 <MyCatVerbs> CakeProphet: what's so interesting about that one?
19:10:06 <CakeProphet> nothing that I can see. It could have tons of interesting things about it.
19:10:09 <Olathe> > scanl (-) [-1,5,19,41,71,109,155,209,271,341,419,505,599,701,811,929,1055,1189,1331]
19:10:11 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
19:10:11 <lambdabot>        arising from a u...
19:10:12 <Olathe> > scanl1 (-) [-1,5,19,41,71,109,155,209,271,341,419,505,599,701,811,929,1055,1189,1331]
19:10:14 <lambdabot>   [-1,-6,-25,-66,-137,-246,-401,-610,-881,-1222,-1641,-2146,-2745,-3446,-4257...
19:10:20 <Olathe> > scanl1 subtract [-1,5,19,41,71,109,155,209,271,341,419,505,599,701,811,929,1055,1189,1331]
19:10:22 <lambdabot>   [-1,6,13,28,43,66,89,120,151,190,229,276,323,378,433,496,559,630,701]
19:10:56 <CakeProphet> it's neither arithmetic or geometric though
19:12:15 <Olathe> > map (\x -> 4*x^2 + 2*x - 1) [0..]
19:12:26 <lambdabot>   [-1,5,19,41,71,109,155,209,271,341,419,505,599,701,811,929,1055,1189,1331,1...
19:13:01 <Olathe> > lagrange [-1,5,19,41,71,109,155,209]
19:13:03 <lambdabot>   [4%1,2%1,(-1)%1]
19:14:33 <CakeProphet> @src lagrange
19:14:33 <lambdabot> Source not found.
19:14:37 <CakeProphet> what does that do?
19:14:52 <athos> @hoogle lagrange
19:14:53 <lambdabot> No results found
19:15:43 <Olathe> http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html
19:16:42 <CakeProphet> > zipWith (flip.div) (zipWith subtract [3,7..] (scanl (+) 2 [10,20..])
19:16:44 <lambdabot>   <no location info>: parse error on input `;'
19:16:52 <CakeProphet> > zipWith (flip.div) (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:16:54 <lambdabot>       Overlapping instances for Show ([b] -> [(b -> c) -> c])
19:16:54 <lambdabot>        arising ...
19:17:06 <Olathe> flip div
19:17:07 <ddarius> flip . div doesn't make sense.
19:17:24 <CakeProphet> > scanl1 (flip div) (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:17:26 <CakeProphet> o rite
19:17:26 <lambdabot>   [-1,-5,-5,-10,-9,-15,-13,-20,-17,-25,-21,-30,-25,-35,-29,-40,-33,-45,-37,-5...
19:17:44 <athos> > scanl (/) 3 [27, 3, 1]
19:17:46 <lambdabot>   [3.0,0.1111111111111111,3.7037037037037035e-2,3.7037037037037035e-2]
19:17:54 <CakeProphet> hmmm...
19:18:18 <athos> ah
19:18:19 <athos> :]
19:18:39 <athos> > scanl (/) 27 [3, 3, 1]
19:18:40 <lambdabot>   [27.0,9.0,3.0,3.0]
19:19:12 <athos> > scanl (/) 27 [3, 3]
19:19:14 <lambdabot>   [27.0,9.0,3.0]
19:20:56 <CakeProphet> there doesn't seem to be any pattern in their ratios that I can see.
19:21:19 <CakeProphet> hmmm... actually.
19:22:52 <Olathe> > scanl (/) a [b, b]
19:22:54 <lambdabot>   [a,a / b,a / b / b]
19:22:59 <athos> :-)
19:23:33 <sbahra> :t a
19:23:35 <lambdabot> Expr
19:23:38 <sbahra> sexy
19:23:43 <ddarius> :t f
19:23:44 <sbahra> Expr is really nice
19:23:45 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:27:55 <Olathe> Hmm...Mathematica 7 just came out.
19:28:55 <sbahra> Nerd
19:29:18 <athos> why would a nerd call sb. a nerd?
19:29:24 <Olathe> http://www.wolfram.com/products/mathematica/newin7/content/IntegerSequenceAnalysis/
19:29:30 <Olathe> Relevant to what we were just discussing.
19:29:59 <athos> > scanl (+) 1 [1..10]
19:30:01 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56]
19:30:15 <CakeProphet> > let seq 0 = -1; seq n = |odd n = seq (n-2) - (n+2) | even n = seq(n-1)+(n-2) in map seq [1..]
19:30:17 <lambdabot>   <no location info>: parse error on input `|'
19:30:30 <CakeProphet> > let seq 0 = -1; seq n |odd n = seq (n-2) - (n+2) | even n = seq(n-1)+(n-2) in map seq [1..]
19:30:34 <lambdabot>   [* Exception: stack overflow
19:30:38 <CakeProphet> :3
19:30:38 <athos> :-)
19:31:01 <athos> :t seq
19:31:03 <lambdabot> forall a t. a -> t -> t
19:31:19 <athos> > let map = 5 in map
19:31:21 <lambdabot>   5
19:31:40 <CakeProphet> > let seq 0 = -1; seq n |odd n = seq (n-2) - (n+2) | even n = seq(n-1)+(n-2) in map seq [1..2]
19:31:44 <lambdabot>   [* Exception: stack overflow
19:31:51 <CakeProphet> hmmm
19:32:41 <athos> @check map f x xs == foldr ((:).f) [] xs
19:32:42 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
19:32:45 <CakeProphet> > let seq 0 = -1; seq n |odd n = (seq (n-2)) - (n+2) | even n = (seq(n-1))+(n-2) | n<0 = 0 in map seq [1..2]
19:32:49 <lambdabot>   [* Exception: stack overflow
19:33:08 <CakeProphet> it shouldn't be overflowing from only two or three recursive calls.
19:33:49 <athos> P
19:33:54 <athos> > odd (-1)
19:33:55 <lambdabot>   True
19:34:54 <CakeProphet> > lol
19:34:56 <lambdabot>   Not in scope: `lol'
19:35:29 <athos> > let seq 0 = -1; seq n | odd n = (seq (n-2)) - (n+2); seq n | even n = (seq(n-1))+(n-2); seq | n < 0 = 0 in map seq [1..2]
19:35:31 <lambdabot>       Equations for `seq' have different numbers of arguments
19:35:31 <lambdabot>        <interac...
19:35:42 <athos> > let seq 0 = -1; seq n | odd n = (seq (n-2)) - (n+2); seq n | even n = (seq(n-1))+(n-2); seq n | n < 0 = 0 in map seq [1..2]
19:35:46 <lambdabot>   [* Exception: stack overflow
19:36:03 <athos> hm
19:36:31 <pumpkin> > whatWhat
19:36:32 <lambdabot>   happy new year!
19:36:43 <athos> CakeProphet:
19:36:49 <athos> i don't get why it should "terminate"
19:36:59 <hcube> lambdabot: happy new year!
19:37:34 <CakeProphet> @let  lol 0 = -1; lol n |n<0 = 0 |odd n = (lol (n-2)) - (n+2)| even n = (lol (n-1))+(n-2)
19:37:37 <lambdabot>  Defined.
19:37:49 <athos> > let seq 0 = -1; seq n | n<0=0;seq n | odd n = (seq (n-2)) - (n+2); seq n | even n = (seq(n-1))+(n-2) in map seq [1..2]
19:37:50 <CakeProphet> athos:  because of lol 0 = -1
19:37:51 <lambdabot>   [-3,-3]
19:37:59 <CakeProphet> > lol 1
19:38:01 <lambdabot>   -3
19:38:07 <CakeProphet> > lol 2
19:38:09 <lambdabot>   -3
19:38:10 <CakeProphet> > lol 3
19:38:12 <lambdabot>   -8
19:38:13 <athos> CakeProphet: 1-2 = -1
19:38:13 <athos> -1 is odd
19:38:18 <CakeProphet> ...not the function I wanted.
19:38:36 <CakeProphet> I wanted to find the nth term of the sequence I made above.
19:38:51 <CakeProphet> > scanl1 (flip div) (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:38:53 <lambdabot>   [-1,-5,-5,-10,-9,-15,-13,-20,-17,-25,-21,-30,-25,-35,-29,-40,-33,-45,-37,-5...
19:38:54 <CakeProphet> this one
19:40:39 <athos> > let findNthTerm n seq | n > 0 = seq!!(n-1) in findNthTerm 3 scanl1 (flip div) (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:40:41 <lambdabot>   Couldn't match expected type `[a]'
19:40:56 <Olathe> > (scanl (+) 2 [10,20..])
19:40:57 <athos> > let findNthTerm n seq | n > 0 = seq!!(n-1) in findNthTerm 3 $ scanl1 (flip div) (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:40:58 <lambdabot>   [2,12,32,62,102,152,212,282,362,452,552,662,782,912,1052,1202,1362,1532,171...
19:40:59 <lambdabot>   -5
19:41:11 <Olathe> > lagrange $ take 10 (scanl (+) 2 [10,20..])
19:41:13 <athos> ok, that's not what you wanted anyway :)
19:41:13 <lambdabot>   [5%1,5%1,2%1]
19:41:34 <CakeProphet> :t lagrange
19:41:36 <lambdabot> [Int] -> [Ratio Int]
19:41:42 <Olathe> > lagrange $ take 10 (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:41:44 <lambdabot>   [5%1,1%1,(-1)%1]
19:42:03 <athos> Olathe: did you understand: scanl (+) 2 [10,20..]?
19:42:09 <Olathe> > scanl1 (flip div) $ map (\x -> 5*x^2 + x - x) [0..]
19:42:11 <lambdabot>   [0,* Exception: divide by zero
19:42:17 <Olathe> Hmm...
19:42:34 <Olathe> > map (\x -> 5*x^2 + x - x) [0..]
19:42:36 <lambdabot>   [0,5,20,45,80,125,180,245,320,405,500,605,720,845,980,1125,1280,1445,1620,1...
19:42:41 <Olathe> > (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:42:42 <lambdabot>   [-1,5,21,47,83,129,185,251,327,413,509,615,731,857,993,1139,1295,1461,1637,...
19:42:49 <athos> :t drop
19:42:51 <lambdabot> forall a. Int -> [a] -> [a]
19:42:54 <Olathe> > map (\x -> 5*x^2 + x - 1) [0..]
19:42:55 <lambdabot>   [-1,5,21,47,83,129,185,251,327,413,509,615,731,857,993,1139,1295,1461,1637,...
19:43:02 <Olathe> > scanl1 (flip div) $ map (\x -> 5*x^2 + x - 1) [0..]
19:43:04 <lambdabot>   [-1,-5,-5,-10,-9,-15,-13,-20,-17,-25,-21,-30,-25,-35,-29,-40,-33,-45,-37,-5...
19:43:10 <CakeProphet> ah ha
19:43:31 <sbahra> heh
19:43:43 <sbahra> Prelude> man liftM_
19:43:45 <sbahra> :)
19:43:45 <Olathe> > scanl1 (flip div) $ [a, b, c, d]
19:43:47 <lambdabot>   [a,b `div` a,c `div` (b `div` a),d `div` (c `div` (b `div` a))]
19:43:51 <athos> 8]
19:44:05 <CakeProphet> how did you figure out the nth term?
19:44:12 <Olathe> CakeProphet: nth term ?
19:44:27 <CakeProphet> 5*x^2 + x - 1
19:44:33 <Olathe> Oh, using lagrange.
19:44:39 <Olathe> (21:41.37) (Olathe) > lagrange $ take 10 (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:44:42 <CakeProphet> I don't understand what lagrange does.
19:44:52 <Olathe> It gives a polynomial that generates that list.
19:44:58 <Olathe> > lagrange $ take 10 (zipWith subtract [3,7..] (scanl (+) 2 [10,20..]))
19:45:00 <lambdabot>   [5%1,1%1,(-1)%1]
19:45:06 <CakeProphet> oh, wow.
19:45:07 <Olathe> 5*x^2 + x - 1
19:45:10 <sbahra> Cool
19:45:16 <sbahra> @hoogle lagrange
19:45:17 <lambdabot> No results found
19:45:27 <sbahra> @src lagrange
19:45:28 <lambdabot> Source not found.
19:45:29 <Olathe> I copied the idea from Mathworld.
19:45:39 <CakeProphet> oh I see.
19:45:44 <sbahra> Where can I find the source to it, Olathe?
19:45:52 <Olathe> @let lagrange ys = if length ys <= 1 then map (%1) ys else sum' $ map (section ys) [0..(length ys - 1)] where section ys n = map (% (foldr (*) 1 $ map (n-) (dropOne n [0..(length ys - 1)]))) $ ([ys !! n] #*#) $ prod' $ map (\x -> [1, -x]) (dropOne n [0..(length ys - 1)]); prod' [a] = a; prod' (a:as) = a #*# prod' as; sum' [a] = a; sum' (a:as) = a #+# sum' as; dropOne n xs = (take n xs) ++ (drop (n + 1) xs)
19:45:53 <lambdabot>  <local>:33:0:
19:45:54 <lambdabot>      Multiple declarations of `L.lagrange'
19:45:54 <lambdabot>      Declared at: <...
19:46:04 <Olathe> @let as #*# bs = dropWhile (==0) $ map (sum'.(map fst)) $ groupBy (\a b -> snd a == snd b) $ sortBy (flip (comparing snd)) $ liftM2 (\(aCoeff, aPow) (bCoeff, bPow) -> (aCoeff*bCoeff, aPow + bPow)) (zipPow as) (zipPow bs) where zipPow xs = zip xs (reverse [0..length xs - 1]); sum' [a] = a; sum' (a:as) = a + sum' as
19:46:05 <lambdabot>  <local>:33:3:
19:46:05 <lambdabot>      Multiple declarations of `L.#*#'
19:46:05 <lambdabot>      Declared at: <local...
19:46:10 <Olathe> @let as #+# bs = dropWhile (==0) $ map (sum'.(map fst)) $ groupBy (\a b -> snd a == snd b) $ sortBy (flip (comparing snd)) ((zipPow as) ++ (zipPow bs)) where zipPow xs = zip xs (reverse [0..length xs - 1]); sum' [a] = a; sum' (a:as) = a + sum' as
19:46:11 <lambdabot>  <local>:33:3:
19:46:11 <lambdabot>      Multiple declarations of `L.#+#'
19:46:11 <lambdabot>      Declared at: <local...
19:46:26 <Olathe> #*# and #+# are polynomial multiplication and addition.
19:46:32 <CakeProphet> oh, awesome.
19:46:37 <CakeProphet> can you paste the source?
19:46:45 <Olathe> Oh, those three are it.
19:46:56 <sbahra> thanks Olathe
19:47:00 <CakeProphet> ....it's a little hard to read.
19:47:01 <Olathe> You're welcome.
19:47:03 <Olathe> Yeah.
19:47:06 <Olathe> It's also a bit buggy.
19:47:10 <Olathe> Since it uses Ints.
19:47:27 <sbahra> hindent ftw
19:47:27 <athos> > lagrange $ map (2^) [0..]
19:47:36 <Olathe> It needs a finite list.
19:47:40 <athos> > lagrange $ map (2^) [0..100]
19:47:41 <lambdabot>   mueval: Prelude.read: no parse
19:47:47 <Olathe> It can use an infinite list if you give it...a while.
19:47:52 <lambdabot>   * Exception: Ratio.%: zero denominator
19:47:57 <Olathe> Yeah, that's what Ints do.
19:48:03 <Olathe> Quite evil.
19:48:04 <athos> > lagrange $ map (2^) [0..100] :: [Int]
19:48:05 <athos> > lagrange $ (map (2^) [0..100] :: [Int])
19:48:06 <lambdabot>   Couldn't match expected type `Int'
19:48:13 <lambdabot>   * Exception: Ratio.%: zero denominator
19:48:18 <CakeProphet> I could see Haskell being very very good for sequence analysis.
19:48:18 <athos> :t lagrange
19:48:19 <Olathe> With Integers, you don't get zero division.
19:48:21 <lambdabot> [Int] -> [Ratio Int]
19:48:39 <CakeProphet> how do you not?
19:48:44 <CakeProphet> > 5 / 0 :: Integer
19:48:46 <lambdabot>       No instance for (Fractional Integer)
19:48:46 <lambdabot>        arising from a use of `/' a...
19:48:50 <athos> :D
19:48:50 <Olathe> Well, I think it uses factorials.
19:48:56 <sbahra> :t (/)
19:48:57 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:48:58 <Olathe> Int factorials go to zero pretty quick.
19:49:03 <sbahra> :t Integer
19:49:04 <sbahra> err
19:49:04 <lambdabot> Not in scope: data constructor `Integer'
19:49:07 <sbahra> That was stupid :)
19:49:11 <Olathe> You just need 32 or 64 2s in the factorization.
19:49:13 <athos> :i Integer
19:49:16 <athos> :]
19:49:48 <Olathe> > drop 50 $ scanl1 (*) [1..100::Int]
19:49:50 <lambdabot>   [-162551799050403840,-8452693550620999680,-5270900413883744256,-79274612440...
19:49:55 <CakeProphet> does Haskell not have an arbitrary size integer type that is automatically small for Int-sized values?
19:49:57 <Olathe> Hmm...not by then.
19:50:05 <Olathe> It has Integer.
19:50:14 <rwbarton> :k Integer
19:50:15 <lambdabot> *
19:50:16 <Olathe> > drop 100 $ scanl1 (*) [1..100::Int]
19:50:17 <rwbarton> there :)
19:50:18 <lambdabot>   []
19:50:23 <Olathe> > drop 100 $ scanl1 (*) [1..::Int]
19:50:24 <lambdabot>   Not in scope: `..::'Not in scope: data constructor `Int'
19:50:26 <sbahra> :k Integer
19:50:27 <Olathe> > drop 100 $ scanl1 (*) [1::Int..]
19:50:28 <lambdabot> *
19:50:29 <lambdabot>   <no location info>: parse error on input `Int..'
19:50:30 <ddarius> @src Integer
19:50:31 <lambdabot> data Integer = S# Int#
19:50:31 <lambdabot>              | J# Int# ByteArray#
19:50:31 <sbahra> :k Int
19:50:32 <lambdabot> *
19:50:36 <Olathe> > drop 100 $ scanl1 (*) [(1::Int)..]
19:50:38 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:50:40 <rwbarton> , src ''Integer
19:50:41 <Olathe> There.
19:50:42 <sbahra> Ah, ddarius has it
19:50:45 <Olathe> Factorial goes to zero.
19:50:48 <centrinia> @src Int
19:50:48 <lambdabot> data Int = I# Int#
19:50:54 <lunabot>  data Integer = S# Int# | J# Int# ByteArray#
19:50:54 <CakeProphet> oh wow
19:50:55 <sbahra> What was a "kind" again?
19:50:57 <CakeProphet> the 0s are overflows?
19:51:00 <sbahra> Is all this in Haskell'98 BTW?
19:51:02 <Olathe> So, since the denominator uses factorial, it dies.
19:51:09 <CakeProphet> ah, I see now.
19:51:12 <Olathe> CakeProphet: Of a sort.
19:51:12 <sbahra> I mean, definition of "kind", etc...
19:51:30 <Olathe> Let me see if I have a generalized version.
19:51:35 <Olathe> It would be nice to use Exprs.
19:51:36 <CakeProphet> anything using factorial should use Integer, I think.
19:51:54 <sbahra> rwbarton, hi.
19:52:10 <sbahra> rwbarton, definition of "kind", etc...are available in Haskell'98?
19:52:28 <centrinia> > drop 100 $ scanl1 ((*) . (+1)) [(1::Int)..]
19:52:29 <lambdabot>   [38265503294355237,3903081336024234276,-3810992011114005021,-89615436079559...
19:52:37 <Olathe> @type (#+#)
19:52:39 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
19:52:42 <Olathe> That's good
19:52:57 <centrinia> Wait, what does (#+#) do?
19:53:01 <Olathe> @type (#*#)
19:53:03 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
19:53:12 <Olathe> Polynomial addition.
19:53:12 <centrinia> [0,0,0] #+# [1,2,3]
19:53:15 <centrinia> > [0,0,0] #+# [1,2,3]
19:53:17 <lambdabot>   [1,2,3]
19:53:18 <CakeProphet> a polynomial addition operator makes me happy.
19:53:26 <centrinia> > [3,2,1] #*# [1,2,3]
19:53:28 <lambdabot>   [3,8,14,8,3]
19:53:33 <centrinia> Cool. :)
19:53:33 <Olathe> Let me generalize lagrange.
19:53:40 <CakeProphet> is there an "expand" operator?
19:53:44 <Olathe> > [a, b] #+# [c, d, e]
19:53:46 <lambdabot>   [c,a + d,b + e]
19:53:51 <CakeProphet> that takes the polynomial and an x value?
19:53:52 <Olathe> > [a, b] #*# [c, d, e]
19:53:54 <lambdabot>   [a * c,a * d + b * c,a * e + b * d,b * e]
19:53:54 <centrinia> :t a
19:53:56 <lambdabot> Expr
19:54:00 <sbahra> nice
19:54:05 <Olathe> CakeProphet: No, but that's simple enough.
19:54:14 <CakeProphet> -nod- just wondering if it already existed.
19:54:50 <Olathe> > sum $ zipWith (*) poly (iterate (*x) 1)
19:54:51 <lambdabot>   Not in scope: `poly'
19:54:54 <Olathe> Or whatever.
19:54:55 <athos> > [a,b,c] #+# [d,e,f]
19:54:57 <lambdabot>   [a + d,b + e,c + f]
19:55:20 <Olathe> > sum $ zipWith (*) ([a,b,c] #+# [d,e,f]) (iterate (*x) 1)
19:55:22 <lambdabot>   0 + (a + d) * 1 + (b + e) * (1 * x) + (c + f) * (1 * x * x)
19:55:31 <athos> hmm
19:55:35 <rwbarton> sbahra: Yes, see section 4.1.1 of the Report
19:55:35 <CakeProphet> > #=#
19:55:37 <lambdabot>   <no location info>: parse error on input `#=#'
19:55:40 <athos> wow, it's already 5:00 am
19:55:48 <sbahra> rwbarton, thanks
19:55:48 <Olathe> CakeProphet: That's list ==
19:55:48 <CakeProphet> hmmm... what would be a good name for it?
19:56:06 <centrinia> > foldl (\p a -> (a #*# [x]) #+# p) $ [a,b] #*# [c,d,e]
19:56:07 <lambdabot>       Overlapping instances for Show ([[Expr]] -> [Expr])
19:56:07 <lambdabot>        arising from...
19:56:24 <centrinia> > foldl (\p a -> ([a] #*# [x]) #+# [p]) $ [a,b] #*# [c,d,e]
19:56:26 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Expr]'
19:56:47 <centrinia> > foldl1 (\p a -> ([a] #*# [x]) #+# [p]) $ [a,b] #*# [c,d,e]
19:56:48 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Expr]'
19:56:52 <pumpkin> damn it's cold
19:58:23 <Olathe> @index groupBy
19:58:24 <lambdabot> Data.List
20:00:51 <CakeProphet> > let polyeval poly x =sum $ sub poly where sub p:ps = p^(length ps) in polyeval [1,2,1] 1
20:00:52 <lambdabot>   <no location info>: Parse error in pattern
20:00:59 <CakeProphet> > let polyeval poly x =sum $ sub poly where sub (p:ps) = p^(length ps) in polyeval [1,2,1] 1
20:01:01 <lambdabot>       No instance for (Num [a])
20:01:01 <lambdabot>        arising from a use of `polyeval' at <i...
20:01:59 <CakeProphet> > let polyeval poly x =sum $ sub poly where sub (p:ps) = p^(length ps):sub ps in polyeval [1,2,1] 1
20:02:01 <lambdabot>   * Exception: /tmp/6046649358695400714:71:90-122: Non-exhaustive patterns in...
20:02:06 <CakeProphet> lol wat
20:02:32 <CakeProphet> > let polyeval poly x =sum $ sub poly where sub [] = []; sub (p:ps) = p^(length ps):sub ps in polyeval [1,2,1] 1
20:02:34 <lambdabot>   4
20:02:37 <CakeProphet> :D
20:02:57 <CakeProphet> I probably should have used combinations instead.
20:03:22 <rwbarton> > let polyeval poly x = foldl (\t c -> x * t + c) 0 poly in polyeval [1,2,1] 1
20:03:24 <lambdabot>   4
20:03:31 <athos> hah, need
20:03:34 <athos> *neat*
20:04:25 <CakeProphet> hmmm... I don't get how that one works.
20:05:04 <CakeProphet> hmmm... oh I see.
20:06:00 <CakeProphet> will that work when x doesn't equal 1?
20:06:19 <CakeProphet> > let polyeval poly x = foldl (\t c -> x * t + c) 0 poly in polyeval [1,2,1] 2
20:06:21 <lambdabot>   9
20:06:49 <centrinia> Is there a polynomial division operator?
20:06:59 <athos> CakeProphet: do you know what foldl does?
20:07:02 <CakeProphet> > (#/#)
20:07:04 <lambdabot>   Not in scope: `#/#'
20:07:04 <CakeProphet> athos:  yeah
20:07:08 <athos> CakeProphet: ah ok :)
20:07:28 <CakeProphet> I just don't get where it does the exponents
20:07:35 <CakeProphet> x**2 + x + 1
20:07:56 <CakeProphet> well... ^ in Haskell
20:07:58 <dons> happy new years from the west indies :)
20:08:03 <CakeProphet> not **
20:08:06 <athos> :t (**)
20:08:07 <centrinia> > take 10 $ foldl1 (*) (repeat 2)
20:08:07 <lambdabot> forall a. (Floating a) => a -> a -> a
20:08:08 <lambdabot>       No instance for (Num [a])
20:08:08 <lambdabot>        arising from a use of `*' at <interact...
20:08:09 <athos> dons: happy new year!
20:08:33 <CakeProphet> > 2**2
20:08:35 <lambdabot>   4.0
20:08:39 <athos> CakeProphet: i think t is your exponent
20:08:54 <athos> although..
20:09:06 <athos> no, that's nonsense :)
20:09:28 <centrinia> > take 10 $ scanl1 (*) (repeat 2)
20:09:30 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
20:09:58 <CakeProphet> > let polyeval poly x = foldl (\t c -> x * t + c) 0 poly in polyeval [2,2,2] 2
20:10:00 <lambdabot>   14
20:11:44 <CakeProphet> > let polyeval poly x = foldl (\t c -> x * t + c) 0 poly in polyeval [2,1,2] 2
20:11:46 <lambdabot>   12
20:13:02 <CakeProphet> > let polyeval poly x = foldl (\t c -> x * t + c) 0 poly in polyeval [a,b,c] x
20:13:04 <lambdabot>   x * (x * (x * 0 + a) + b) + c
20:13:35 <ddarius> CakeProphet: None of these functions are "standard"
20:14:05 <CakeProphet> ddarius:  why does that matter?
20:14:31 <pumpkin> x * 0 :o
20:14:46 <pumpkin> that's kinda cute :)
20:14:54 <CakeProphet> oh... I see how it works
20:14:57 <CakeProphet> that's craziness
20:15:32 <CakeProphet> @let polyeval poly x = foldl (\t c -> x * t + c) 0 poly
20:15:33 <pumpkin> shouldn't everyone be celebrating new year's by not writing haskell?
20:15:34 <pumpkin> :o
20:15:35 <lambdabot>  Defined.
20:15:40 <CakeProphet> pumpkin:  nope
20:15:43 <pumpkin> oh ok :)
20:16:09 <athos> new year is now 5 hours ago
20:16:09 <athos> :)
20:16:33 <athos> good night everyone
20:17:32 <CakeProphet> >let sound x = sin(x) + sin(x+4) + sin(x+5) + sin(x+6) + sin(x+7) in map sound [1..]
20:17:37 <ddarius> CakeProphet: It deosn't.  I'm just making it clear that these functions aren't in the libraries (though surely there's something on hackage that does contain them)
20:17:50 <CakeProphet> ddarius:  you mean the polynomial operators?
20:17:57 <ddarius> CakeProphet: Yes.
20:17:59 <CakeProphet> > let sound x = sin(x) + sin(x+4) + sin(x+5) + sin(x+6) + sin(x+7) in map sound [1..]
20:18:01 <lambdabot>   [1.249476057288003,2.688345259210683,1.655562227754425,-0.899337080882863,-...
20:18:11 <CakeProphet> I just made a sound wave.
20:18:13 <CakeProphet> ...
20:18:36 <flippo> Not exactly Beethoven.
20:18:57 <ddarius> CakeProphet: A very dissonant and distorted one.
20:19:16 <augustss> No it's not
20:19:26 <augustss> It's a sine wave.
20:19:37 <ddarius> True
20:19:46 <CakeProphet> > let sound x = sin(x) + sin(x*4) + sin(x*5) + sin(x*6) + sin(x*7) in map sound [1..]
20:19:46 <centrinia> It should be equivalent to some sin(a*x+b)
20:19:48 <lambdabot>   [-0.49668468464330706,1.808669000254129,0.34050332198092914,-0.766433134944...
20:19:54 <CakeProphet> now it's sound wave... :D complete with harmonics
20:19:57 <CakeProphet> +a
20:20:16 <augustss> Or even a*sin(x+b)
20:20:24 <centrinia> Oh yeah.
20:20:41 <CakeProphet> > sign
20:20:43 <lambdabot>   Not in scope: `sign'
20:20:50 <ddarius> :t signum
20:20:51 <lambdabot> forall a. (Num a) => a -> a
20:20:55 <CakeProphet> ah. Thanks.
20:21:01 <augustss> Harmonics!
20:24:49 <CakeProphet> @let square = signum.sin; triangle = arcsin.sin; sawtooth x = x - floor(x)
20:24:50 <lambdabot>  <local>:34:32: Not in scope: `arcsin'
20:25:10 <CakeProphet> no arcsin?
20:25:17 <ddarius> :t asin
20:25:19 <lambdabot> forall a. (Floating a) => a -> a
20:25:23 <CakeProphet> ah
20:25:29 <CakeProphet> @let square = signum.sin; triangle = asin.sin; sawtooth x = x - floor(x)
20:25:31 <lambdabot>  Defined.
20:26:07 <CakeProphet> crap, sawtooth is wrong
20:26:13 <CakeProphet> operator precedence
20:26:27 <pumpkin> centrinia: are you a student?
20:27:07 <kniu> So, with dependent types, the type of an expression is a function of the types of the operands, right?
20:27:17 <CakeProphet> mhm
20:27:31 <CakeProphet> that's how Haskell can infer types
20:27:32 <ddarius> kniu: No more than with any other type system.
20:27:37 <CakeProphet> in most cases
20:27:38 <kniu> Why, then use that strange pi symbol to bind type values, instead of using another lambda?
20:28:00 <kniu> For convenience?
20:28:00 <ddarius> kniu: The difference is the type of an expression can depend on the -values- of the free variables.
20:28:26 <kniu> oh, right.
20:28:27 <pumpkin> that sounds like it would be quite complicated
20:29:12 <ddarius> kniu: The pi symbol is "just another lambda."  Pi was chosen because it is the dependent product.
20:29:21 <CakeProphet> how do you change a bool to an int (0 or 1)
20:29:31 <ddarius> fromEnum
20:29:47 <CakeProphet> > True + False
20:29:48 <lambdabot>       No instance for (Num Bool)
20:29:48 <lambdabot>        arising from a use of `+' at <interac...
20:29:53 <CakeProphet> didn't think that would work.
20:30:09 <kniu> just another lambda, eh?
20:30:40 <kniu> This is sort of kind of starting to make sense.
20:31:36 <ddarius> The normal lambda allows values to depend on values, in System F, the polymorphic lambda calculus, usually capital lambda is used to make values depend on types.  Usually a normal lambda is used at the type level for making types depend on types.  The Pi symbol is what is usually used in dependently typed languages to have types depend on values.
20:32:18 <CakeProphet> > let signum' x = (fromEnum (x>1)) - (fromEnum (x<1)) in map (\x -> signum' x == signum x) [-100..100]
20:32:20 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
20:32:29 <kniu> why the distinction in the first place, is what I ask?
20:32:30 <CakeProphet> > let signum' x = (fromEnum (x>1)) - (fromEnum (x<1)) in all (\x -> signum' x == signum x) [-100..100]
20:32:32 <lambdabot>   False
20:32:35 <CakeProphet> :o
20:33:10 <CakeProphet> > let signum' x = (fromEnum (x>1)) - (fromEnum (x<1)) in signum' 0 == signum 0
20:33:12 <lambdabot>   False
20:33:13 <ddarius> kniu: Because they are different things.  You could make a "parameterized" lambda (actually usually Pi is used then) that handles going between the different sorts.
20:33:28 <ddarius> This is roughly how Pure Type Systems work.
20:33:40 <CakeProphet> > let signum' x = (fromEnum (x>0)) - (fromEnum (x<0)) in all (\x -> signum' x == signum x) [-100..100]
20:33:42 <lambdabot>   True
20:33:52 <CakeProphet> ghetto signum
20:34:14 <ddarius> > map fromEnum [LT ..]
20:34:15 <lambdabot>   [0,1,2]
20:34:38 <CakeProphet> @let signum' x = (fromEnum (x>0)) - (fromEnum (x<0))
20:34:41 <lambdabot>  Defined.
20:35:12 <CakeProphet> > check
20:35:13 <lambdabot>   Not in scope: `check'
20:35:43 <ddarius> > map (subtract 1 . fromEnum . comparing 0) [-5,-4 ..]
20:35:44 <lambdabot>       No instance for (Enum (a -> Ordering))
20:35:44 <lambdabot>        arising from a use of `fr...
20:35:56 <ddarius> > map (((subtract 1 .) fromEnum .) comparing 0) [-5,-4 ..]
20:35:57 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Int'
20:36:08 <ddarius> Oops.  Misplaced paren
20:36:17 <CakeProphet> @let fcheck f g ls = all (\x -> f x == g x) ls
20:36:19 <lambdabot>  Defined.
20:37:28 <CakeProphet> > fcheck (>=1) (>0) [-100..100]
20:37:30 <lambdabot>   True
20:38:05 <kniu> cons:(\ x:* . (\ (List x n):* . (List x (n + 1)))) == cons:(forall x (pi n:Int . x -> (List x n) -> (List x (n + 1))))
20:38:07 <kniu> ?
20:38:32 <kniu> wait, shit
20:38:45 <CakeProphet> > fcheck id (negate.negate) [-100..100]
20:38:47 <lambdabot>   True
20:38:57 <CakeProphet> wooo
20:39:59 <roconnor> how much fcheck could an fcheck check if an fcheck could check fcheck?
20:40:10 <roconnor> > fcheck fcheck fcheck ()
20:40:11 <lambdabot>   Couldn't match expected type `[a -> a1]' against inferred type `()'
20:40:34 <kniu> cons:(pi x:* . (pi n:Int . (x -> (List x n) -> (List x (n + 1)))))
20:41:07 <kniu> oh lord, my brain.
20:41:29 <ddarius> I wouldn't think you'd need all those parentheses.
20:41:47 <ddarius> cons: pi x:*. pi n:Int. x -> List x n -> List x (n+1)
20:41:52 <roconnor> cons is parametric in the type of list
20:42:22 <roconnor> it takes a length, an head, an tail of length n, and returns a list of length (n+1)
20:43:32 <CakeProphet> > map ($ [-100..100]) zipWith fcheck (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor])
20:43:34 <lambdabot>   Couldn't match expected type `[[t] -> b]'
20:44:32 <CakeProphet> > map ($ [-100..100]) (zipWith fcheck (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor])
20:44:34 <lambdabot>   <no location info>: parse error on input `;'
20:44:35 <CakeProphet> > map ($ [-100..100]) (zipWith fcheck (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor]))
20:44:37 <lambdabot>       No instance for (Enum (Int -> Int))
20:44:37 <lambdabot>        arising from the arithmetic ...
20:45:00 <CakeProphet> :t map
20:45:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:45:11 <CakeProphet> :t zipWith
20:45:13 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:45:41 <BMeph> :t repeat
20:45:43 <lambdabot> forall a. a -> [a]
20:45:44 <CakeProphet> :t floor
20:45:46 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
20:45:52 <CakeProphet> :t signum
20:45:53 <lambdabot> forall a. (Num a) => a -> a
20:46:02 <CakeProphet> ...why is it complaining by enums?
20:46:45 <CakeProphet> :t ($ [-100..100])
20:46:46 <lambdabot> forall b t. (Enum t, Num t) => ([t] -> b) -> b
20:46:50 <CakeProphet> oh ho
20:49:10 <CakeProphet> :t (zipWith fcheck (map fcheck [id, signum, floor]) (map fcheck [negate.negate, signum', floor]))
20:49:12 <lambdabot>     No instance for (Eq ([Int] -> Bool))
20:49:12 <lambdabot>       arising from a use of `fcheck' at <interactive>:1:9-14
20:49:12 <lambdabot>     Possible fix: add an instance declaration for (Eq ([Int] -> Bool))
20:55:36 <CakeProphet> > map ($ [-100..100]) (zipWith (\x y -> fcheck (x [-100..100]) (y [-100.100]))  [ (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor]))
20:55:38 <lambdabot>   <no location info>: parse error on input `)'
20:55:55 <CakeProphet> > map ($ [-100..100]) (zipWith (\x y -> fcheck (x [-100..100]) (y [-100.100]))  [ (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor])
20:55:56 <lambdabot>   <no location info>: parse error on input `;'
20:56:54 <CakeProphet> > map ($ [-100..100]) (zipWith (\x y -> fcheck (x [-100..100]) (y [-100.100]))  (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor]))
20:56:56 <lambdabot>   Couldn't match expected type `[t]' against inferred type `a -> a1'
20:58:53 <CakeProphet> > zipWith (\x y -> fcheck (x [-100..100]) (y [-100.100]) [-100..100])  (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor])
20:58:55 <lambdabot>   Couldn't match expected type `[t]' against inferred type `a -> a1'
20:59:02 * CakeProphet gives up
20:59:34 <CakeProphet> > zipWith (\x y -> fcheck (x [-100..100]) (y [-100..100]) [-100..100])  (map fcheck [id, signum, floor]) (map fcheck  [negate.negate, signum', floor])
20:59:36 <lambdabot>   Couldn't match expected type `[t]' against inferred type `a -> a1'
21:00:36 * BMeph changes the line to: "The Cake(Prophet) is a lie!" ;p
21:01:19 <redditbot> Monte Carlo Poker Odds
21:01:31 <pumpkin> OMG happy new year!
21:01:37 * pumpkin faints
21:02:19 <CakeProphet> happy new year, pumpkin
21:03:19 <ben_h> happy '09 folks
21:03:39 <ben_h> i hope all your wildest dreams come true.
21:03:45 <pumpkin> oh no, you really don't
21:03:48 <CakeProphet> > all ($[-100..100]) (zipWith fcheck [id, signum, floor] [negate.negate, signum', floor])
21:03:49 <lambdabot>       No instance for (RealFrac Int)
21:03:49 <lambdabot>        arising from a use of `floor' at ...
21:03:54 <pumpkin> but thanks :)
21:03:55 <CakeProphet> bah
21:03:55 <ben_h> lol
21:04:08 <CakeProphet> > all ($[-100..100]) (zipWith fcheck [id, signum, sin] [negate.negate, signum', sin])
21:04:10 <lambdabot>       No instance for (Floating Int)
21:04:10 <lambdabot>        arising from a use of `sin' at <i...
21:04:15 <CakeProphet> it doesn't want to let me
21:04:19 <CakeProphet> -cries-
21:04:23 <pumpkin> whatchoo trying to do?
21:04:33 <CakeProphet> I'm not entirely sure anymore
21:04:48 <CakeProphet> I was going to use fcheck to check the equivalent of multiple fcheck calls.
21:04:54 <CakeProphet> *equivalence
21:04:56 <CakeProphet> or something.
21:05:06 <CakeProphet> which is much more complicated than I originally thought
21:05:26 <pumpkin> ah
21:05:55 <CakeProphet> > all ($[-100..100]) (zipWith fcheck [id, signum, (+3)] [negate.negate, signum', (+(-3))])
21:05:57 <lambdabot>   False
21:06:17 <CakeProphet> > all ($[-100..100]) (zipWith fcheck [id, signum, (+3)] [negate.negate, signum', (subtract (-3))])
21:06:19 <lambdabot>   True
21:06:23 <CakeProphet> ...close enough
21:10:11 <CakeProphet> > fcheck (const 5) (fix (const 5)) [-100..100]
21:10:13 <lambdabot>       No instance for (Num (a -> t))
21:10:13 <lambdabot>        arising from the literal `5' at <...
21:12:30 <CakeProphet> @let isinv f g x = (f.g) x == x
21:12:33 <lambdabot>  Defined.
21:12:48 <CakeProphet> > isinv negate negate 5
21:12:49 <lambdabot>   True
21:13:24 <CakeProphet> @let isinvs f g ls = all (f.g==) ls
21:13:27 <lambdabot>  Defined.
21:13:59 <CakeProphet> > isinvs negate negate ([minBound..maxBound]::[Int])
21:14:01 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `Int'
21:14:37 <CakeProphet> meh.
21:14:55 <CakeProphet> the operator precedence for . always messes me up
21:15:12 <CakeProphet> because in my head it binds almost just as tightly as function application.
21:15:33 <pumpkin> well your issue there
21:15:39 <pumpkin> is that you want to apply f.g to x
21:15:43 <pumpkin> and == to that and to x
21:15:50 <pumpkin> sounds like an ap
21:15:52 <mauke> happy new year!
21:16:02 <CakeProphet> oh... there's a function for that. Excellent
21:16:24 <pumpkin> (==) =<< f . g apparently ;)
21:16:29 <pumpkin> if you want to be super obscure
21:16:41 <CakeProphet> @src ap
21:16:41 <lambdabot> ap = liftM2 id
21:17:16 <pumpkin> @src (->) (>>=)
21:17:16 <lambdabot> f >>= k = \ r -> k (f r) r
21:17:26 <mbz> mauke, thanks
21:17:30 <Asztal> ap is also liftM2 ($) IIRC
21:17:49 <Asztal> which certainly reads more nicely to me
21:18:24 <pumpkin> http://imgboot.com/images/b403/hotdog.jpg
21:19:05 <CakeProphet> > let isinverse f g ls = all (ap (f.g) (==)) ls in isinverse negate negate ([minBound..maxBound]::[Int])
21:19:07 <lambdabot>       Occurs check: cannot construct the infinite type:
21:19:07 <lambdabot>        a = (a -> Bool...
21:19:33 <pumpkin> I really want a function inverse :: (a -> b) -> b -> a :P
21:20:03 <CakeProphet> a function that produces the inverse of a number?
21:20:06 <CakeProphet> er
21:20:09 <CakeProphet> nevermind
21:20:11 <mbz> @hoogle (a -> b) -> b -> a
21:20:13 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
21:20:13 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
21:20:13 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
21:20:17 <pumpkin> :P
21:20:23 <pumpkin> it would be rather difficult
21:20:27 * CakeProphet can never tell what a function does by type signature alone
21:20:50 <pumpkin> it would take an invertible function and return its inverse :P
21:21:01 <pumpkin> so you'd need a typeclass on the (a -> b) or something
21:21:05 <CakeProphet> yeah
21:21:08 <pumpkin> but it can't work really
21:23:17 <CakeProphet> @let reverseMap [] x = []; reverseMap (f:fs) x = f x:reverseMap fs x
21:23:20 <lambdabot>  Defined.
21:23:46 <mauke> > sequence [(* 2), (+ 1), (^ 2)] 4
21:23:47 <lambdabot>   [8,5,16]
21:23:56 <CakeProphet> > reverseMap [id, negate, (+3)] 5
21:23:59 <lambdabot>   [5,-5,8]
21:24:20 <mauke> I WIN
21:25:15 <Saizan_> ?type reverseMap
21:25:17 <lambdabot> forall t a. [t -> a] -> t -> [a]
21:25:33 <Saizan_> ?ty sequence
21:25:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:25:38 <Asztal> @let inverse f x = fromJust $ find ((==x).f) [0..]
21:25:41 <lambdabot>  Defined.
21:25:42 <mauke> :t sequence `asTypeOf` reverseMap
21:25:43 <lambdabot> forall a t. [t -> a] -> t -> [a]
21:25:48 <Asztal> inverse (+5) 9
21:25:53 <Asztal> > inverse (+5) 9
21:25:55 <lambdabot>   4
21:26:04 <CakeProphet> :t asTypeOf
21:26:06 <lambdabot> forall a. a -> a -> a
21:26:55 <centrinia> Is there a fast way to calculate ( [1..n] \\ [x+y|x <- a, y <- a]) where (a \\ [1..n]) is []
21:32:52 <CakeProphet> @src \\
21:32:52 <lambdabot> (\\) = foldl (flip delete)
21:33:01 <CakeProphet> @src delete
21:33:01 <lambdabot> delete = deleteBy (==)
21:34:14 <chrisdone> @src deleteBy
21:34:14 <lambdabot> deleteBy eq x []        = []
21:34:14 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
21:48:37 <altmattr_> does haskell restrict the type of a binding (name/left hand side) to be used monomorphically in its own definition (right hand side)?
21:49:05 <pumpkin> altmattr_: by default, yeah
21:49:10 <pumpkin> if you mean the monomorphism restriction?
21:49:24 <altmattr_> no, I think this might be something different
21:49:39 <altmattr_> hang on, I will check exactly what the monomorphism restriction is
21:49:39 <pumpkin> how do you mean then?
21:50:19 <ddarius> altmattr_: No, it does not.
21:50:20 <altmattr_> if you have `let x = .... x (3) ... x(True)  in ..."
21:50:54 <altmattr_> even if x is a -> Int then you can't do it (under this restriction)
21:51:16 <ddarius> This is actually an underappreciated, significant feature of Haskell 98's type system.
21:51:21 <altmattr_> ddarius: right, that's a bummer
21:51:22 <ddarius> It's called polymorphic recursion.
21:51:51 <ddarius> altmattr_: I was saying "no" to your original question.
21:51:59 <altmattr_> :) for me anyway.  I am working through the book on implementing functional languages and the code presented there *does* have this restriction
21:52:03 <ddarius> I.e. yes, you can do what you want.
21:52:08 <conal> altmattr_: i think what you're asking about is called "polymorphic recursion", and it's not handled by Hindley-Milner type inference.
21:52:10 <altmattr_> and now I want to work out how to restrict it
21:52:26 <altmattr_> it is a bummer since haskell won't have a named extension for it :)
21:52:29 <conal> altmattr_: but is handled in haskell with type annotations.
21:52:35 <altmattr_> which is usually a good place to start looking
21:52:45 <ddarius> conal does have a point.  It won't do this unless you provide a type annotation.
21:53:14 <altmattr_> conal, ddarius: so haskell *requires* type annotations to make it work?
21:53:20 <ddarius> altmattr_: Yes.
21:53:26 <altmattr_> beauty!
21:53:30 <conal> yeah, iiuc
21:53:35 <altmattr_> that is how I will implement it then
21:53:42 <conal> another advantage of haskell over ml
21:53:51 <conal> it's crucial for nested data types.
21:53:53 <altmattr_> and it explains why another language I am playing with requires annotations for _all_ letrecs
21:54:33 <altmattr_> but since there is no chapter in the book about this, I guess I have to work it out myself :(
21:54:53 <altmattr_> chapters for the easyer bits, on your own for the hard bits
21:54:57 <altmattr_> easier
22:00:59 <nj32> altmattr_: what book are you using?
22:01:50 <Olathe> > celebrate
22:01:51 <lambdabot>   2003 is finally here !
22:02:04 <ray> at last
22:02:14 <Olathe> I know.
22:07:45 <centrinia> Why is lambdabot still stuck in 2003? :(
22:08:19 <blando> change is hard for us all
22:08:35 <mauke> > celebrate 2009
22:08:36 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `Expr'
22:08:59 <centrinia> :t 2009
22:09:00 <lambdabot> forall t. (Num t) => t
22:09:09 <centrinia> :t celebrate
22:09:11 <lambdabot> Expr
22:14:16 <altmattr_> nj32: "Implementing Functional Languages"
22:14:25 <nj32> ok
22:14:28 <altmattr_> nj32: by Simon Peyton Jones
22:30:28 <weilawei> im new to haskell and very confused.. I need to create and work with complex numbers but it's telling me that there's no data constructor even after I imported Complex
22:30:57 <Olathe> > (1 :+ 0)
22:30:59 <lambdabot>   1.0 :+ 0.0
22:31:04 <Olathe> Does that work ?
22:31:44 <weilawei> ah yes! what does :+ mean?
22:31:49 <pumpkin> a + bi
22:31:59 <pumpkin> it's the + .. i bit :P
22:32:13 <weilawei> so, it has no special meaning elsewhere?
22:32:17 <weilawei> they just picked that operator?
22:32:21 <pumpkin> well, it's just the data constructor for complex
22:32:31 <pumpkin> because symbolic data constructors must have a colon
22:32:37 <rwbarton> @src Complex
22:32:37 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
22:33:08 <weilawei> thank you all
22:37:38 <rwbarton> @vixen happy new year!
22:37:38 <lambdabot> Tell me truthfully what the nastiest thing you have ever done.
22:37:53 <Olathe> > lagrange [a]
22:37:55 <lambdabot>   [a * 1 / 1]
22:37:57 <Olathe> > lagrange [a,b]
22:37:59 <lambdabot>   [(a * (-1) + 0) / (-1) + (b * 0 + 0) / 1,a * 1 / (-1) + b * 1 / 1]
22:38:03 <pumpkin> @elite happy new year!
22:38:04 <lambdabot> hAppy nEW yEAr!
22:38:09 <Olathe> The joys of Expr.
22:38:14 <Olathe> > lagrange [a,b,c]
22:38:16 <lambdabot>   [(a * 2 + 0 + 0) / 2 + (b * 0 + 0 + 0) / (-1) + (c * 0 + 0 + 0) / 2,(a * (-...
22:38:48 <Olathe> > lagrange [0,1,4,9.5]
22:38:50 <lambdabot>   [0.0,0.16666666666666652,0.75,8.333333333333326e-2]
22:39:01 <Olathe> > lagrange [0,1,4,9.5] :: [Rational]
22:39:03 <lambdabot>   [0%1,1%6,3%4,1%12]
22:39:55 <CakeProphet> > fac
22:39:57 <lambdabot>   Not in scope: `fac'
22:40:07 <Olathe> > map (\x -> (12*x^3 + 9*x^2 + 2*x)/12) [0..10]
22:40:09 <lambdabot>   [0.0,1.9166666666666667,11.333333333333334,34.25,76.66666666666667,144.5833...
22:40:20 <Olathe> > map (\x -> (x^3 + 9*x^2 + 2*x)/12) [0..10]
22:40:21 <CakeProphet> @let fac 0 = 1; fac n = produce [1..n]
22:40:21 <lambdabot>   [0.0,1.0,4.0,9.5,18.0,30.0,46.0,66.5,92.0,123.0,160.0]
22:40:22 <lambdabot>  <local>:11:19: Not in scope: `produce'
22:40:28 <CakeProphet> rofl. produce
22:40:38 <Olathe> @let produce n = n
22:40:40 <lambdabot>  Defined.
22:40:48 <Olathe> > produce "rabbit"
22:40:50 <lambdabot>   "rabbit"
22:40:57 <CakeProphet> @let fac 0 = 1; fac n = n * fac (n-1)
22:41:00 <lambdabot>  Defined.
22:41:04 <Olathe> > fac (-1)
22:41:07 <lambdabot>   * Exception: stack overflow
22:41:11 <CakeProphet> > fac a
22:41:13 <lambdabot>   a * ((a - 1) * ((a - 1 - 1) * ((a - 1 - 1 - 1) * ((a - 1 - 1 - 1 - 1) * ((a...
22:41:43 <mauke> > let fac n = product [1 .. n] in fac (-1)
22:41:44 <lambdabot>   1
22:41:49 <Olathe> I wonder if there's a noninsane Expr.
22:41:55 <Olathe> > lagrange [a,b,c]
22:41:57 <lambdabot>   [(a * 2 + 0 + 0) / 2 + (b * 0 + 0 + 0) / (-1) + (c * 0 + 0 + 0) / 2,(a * (-...
22:42:01 <CakeProphet> it would be neat if it autoeval'd constant expressions
22:42:10 <Olathe> b*0 + 0 + 0 is...zero !
22:42:17 <centrinia> > let mandel c = fst $ until (\(i,x) -> (abs x >= 4.0) || (i>=256)) (\x -> x^2+c) (0,0) in mandel (0 :+ 0.3)
22:42:18 <lambdabot>   Couldn't match expected type `(a, b)'
22:42:30 <mauke> > let b = 1/0 in b*0 + 0 + 0 == 0
22:42:31 <lambdabot>   False
22:42:40 <Olathe> > lagrange [a,b,c] !! 2
22:42:42 <lambdabot>   a * 1 / 2 + b * 1 / (-1) + c * 1 / 2
22:43:07 <Olathe> > lagrange [a,b,c] !! 1
22:43:09 <lambdabot>   (a * (-3) + 0) / 2 + (b * (-2) + 0) / (-1) + (c * (-1) + 0) / 2
22:43:10 <centrinia> Isn't Lagrange interpolation just an application of the Chinese Remainder Reconstruction?
22:43:12 <CakeProphet> > [1..a]
22:43:13 <lambdabot>   * Exception: not a number
22:43:18 <CakeProphet> teehee
22:43:31 <CakeProphet> :t a
22:43:33 <lambdabot> Expr
22:43:53 <CakeProphet> @instances-importing
22:43:53 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
22:43:54 <centrinia> :t foobar
22:43:55 <lambdabot> Not in scope: `foobar'
22:44:05 <Olathe> > length $ lagrange [a,b,c]
22:44:07 <lambdabot>   3
22:44:16 <mauke> :t lagrange
22:44:17 <lambdabot> forall b. (Fractional b) => [b] -> [b]
22:44:33 <Olathe> > let zomg a b c = [a, -3/2*a + 2*b -1/2*c, a/2 - b + c/2] in zomg 0 1 4
22:44:35 <lambdabot>   [0.0,0.0,1.0]
22:44:48 <CakeProphet> sum $ replicate 100 a
22:44:55 <CakeProphet> > sum $ replicate 100 a
22:44:57 <lambdabot>   0 + a + a + a + a + a + a + a + a + a + a + a + a + a + a + a + a + a + a +...
22:46:15 <Olathe> @check let zomg [a, b, c] = [a, -3/2*a + 2*b -1/2*c, a/2 - b + c/2] in \a b c -> zomg [a, b, c] == lagrange [a, b, c]
22:46:16 <lambdabot>   Not in scope: `lagrange'
22:46:23 <Olathe> ...
22:46:27 <Olathe> > lagrange
22:46:29 <lambdabot>       Overlapping instances for Show ([b] -> [b])
22:46:29 <lambdabot>        arising from a use o...
22:46:43 <pumpkin> check is separate, unfortunately :/
22:46:57 <CakeProphet> @help check
22:46:57 <Olathe> > randoms (mkStdGen 5)
22:46:58 <lambdabot> check <expr>
22:46:58 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
22:46:59 <lambdabot>   [7776561651304326943,2660592214809256573,-198934792153589140,-4772860058847...
22:47:34 <rainmann> @check const True
22:47:35 <lambdabot>   "OK, passed 500 tests."
22:47:42 <Olathe> > let f xs = take 3 xs:f (drop 3 xs) in f.randoms.mkStdGen $ 5
22:47:44 <lambdabot>   [[7776561651304326943,2660592214809256573,-198934792153589140],[-4772860058...
22:47:52 <mauke> @check (> 0)
22:47:53 <lambdabot>   "Falsifiable, after 1 tests:\n0\n"
22:47:56 <mauke> @check (>= 0)
22:47:57 <lambdabot>   "Falsifiable, after 3 tests:\n-1\n"
22:48:13 <mauke> @check (==)
22:48:14 <lambdabot>   "OK, passed 500 tests."
22:48:37 <Olathe> > let zomg [a, b, c] = [a, -3/2*a + 2*b -1/2*c, a/2 - b + c/2]; f xs = take 3 xs:f (drop 3 xs) in map (\xs -> lagrange xs == zomg xs) (f.randoms.mkStdGen $ 5)
22:48:38 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
22:48:46 <Olathe> > let zomg [a, b, c] = [a, -3/2*a + 2*b -1/2*c, a/2 - b + c/2]; f xs = take 3 xs:f (drop 3 xs) in map (\xs -> lagrange xs == zomg xs) (f.randoms.mkStdGen $ 257)
22:48:48 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
22:49:28 <CakeProphet> I don't understand what check does.
22:49:49 <Olathe> @check \xs -> null xs || tail xs == drop 1 xs
22:49:51 <lambdabot>   "OK, passed 500 tests."
22:49:54 <rainmann> @check \a b -> a + b == b + a -- does (+) commute?
22:49:55 <lambdabot>   "OK, passed 500 tests."
22:50:02 <bd_> CakeProphet: tests some function with a bunch of random inputs, and reports if it turns out to be false
22:50:04 <rainmann> @check \a b -> a - b == b - a -- does (-) commute?
22:50:05 <lambdabot>   "Falsifiable, after 0 tests:\n2\n0\n"
22:50:17 <Olathe> It generates a bunch of test cases and sees if your lambda always returns True.
22:50:38 <ddarius> @check False
22:50:39 <CakeProphet> @check not
22:50:39 <lambdabot>   "Falsifiable, after 0 tests:\n"
22:50:40 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\n"
22:51:06 <Olathe> > let zomg [a, b, c] = [a, -3/2*a + 2*b -1/2*c, a/2 - b + c/2]; f xs = take 3 xs:f (tail xs) in map (\xs -> lagrange xs == zomg xs) (f.randoms.mkStdGen $ 257)
22:51:08 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
22:51:27 <CakeProphet> @check fcheck
22:51:29 <lambdabot>   Not in scope: `fcheck'
22:51:34 <CakeProphet> forgot.
22:51:38 <Olathe> @check False
22:51:39 <lambdabot>   "Falsifiable, after 0 tests:\n"
22:51:49 <Olathe> @check undefined
22:51:49 <bd_> @check not
22:51:50 <lambdabot>   "Falsifiable, after 4 tests:\nTrue\n"
22:51:51 <lambdabot>   Add a type signature
22:51:59 <Olathe> @check undefined :: Bool
22:52:00 <lambdabot>   Couldn't match expected type `Bool' against inferred type `String'
22:52:08 <Olathe> Hahah
22:52:25 <bd_> @check const undefined
22:52:26 <lambdabot>   Add a type signature
22:52:29 <bd_> @check const undefined :: Bool -> Bool
22:52:30 <lambdabot>   Couldn't match expected type `Bool -> Bool'
22:52:38 <bd_> @check (const undefined :: Bool -> Bool)
22:52:39 <lambdabot>   Undefined
22:52:43 <Olathe> @check const (undefined :: Bool)
22:52:44 <CakeProphet> > dropWhile (a==) [1..100]
22:52:45 <lambdabot>   Undefined
22:52:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:53:03 <Olathe> > dropWhileR (>50) [1..100]
22:53:05 <lambdabot>   Not in scope: `dropWhileR'
22:53:09 <Olathe> Lies.
22:53:20 <Olathe> > rDropWhile (>50) [1..100]
22:53:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:53:32 <Olathe> > drop 40 $ rDropWhile (>50) [1..100]
22:53:34 <lambdabot>   [41,42,43,44,45,46,47,48,49,50]
22:53:50 <schme_> @src rDropWhile
22:53:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:54:01 <Olathe> let rDropWhile _ [] = []; rDropWhile f [x] = if f x then [] else [x]; rDropWhile f (x:xs) = if null ds then rDropWhile f [x] else x:ds where ds = rDropWhile f xs
22:54:24 <CakeProphet> > zipWith (+) (replicate 100 a) (replicate 100 b)
22:54:26 <lambdabot>   [a + b,a + b,a + b,a + b,a + b,a + b,a + b,a + b,a + b,a + b,a + b,a + b,a ...
22:54:37 <Olathe> Hmm...
22:55:05 <CakeProphet> what's to zipWith as spanl is to foldl?
22:55:20 <CakeProphet> ...er
22:55:26 <Olathe> > let rDropWhile _ [] = []; rDropWhile f (x:xs) = if null ds then if f x then [] else [x] else x:ds where ds = rDropWhile f xs in rDropWhile (>10) [1..100]
22:55:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:55:28 <CakeProphet> nevermind, lawl
22:56:03 <CakeProphet> zipWith (+) [1..100] (reverse [100..1])
22:56:10 <CakeProphet> > zipWith (+) [1..100] (reverse [100..1])
22:56:12 <lambdabot>   []
22:56:21 <CakeProphet> > zipWith (+) [1..100] (reverse [1..100])
22:56:23 <lambdabot>   [101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,10...
22:56:25 <CakeProphet> tada!
22:56:30 <Olathe> Lies.
22:57:06 <centrinia> @check (\x -> x*(x+1) `div` 2 == sum $ zipWith (+) [1..x] (reverse [1..x]) )
22:57:06 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
22:57:22 <Olathe> scanl.zip
22:57:26 <CakeProphet> > (sum $ zipWith (+) [1..100] (reverse [1..100])) / 2
22:57:28 <lambdabot>   5050.0
22:57:53 <centrinia> @check (\x -> x*(x+1) / 2 == (sum (zipWith (+) [1..x] (reverse [1..x]))) / 2 )
22:57:54 <lambdabot>   "Falsifiable, after 0 tests:\n-1.25\n"
22:58:08 <int-e> lambdabot++
22:58:09 <Olathe> > scanl (\a (b, c) -> a*b + c) 1 $ zip [1..100] (reverse [1..100])
22:58:10 <lambdabot>   [1,101,301,1001,4101,20601,123701,866001,6928101,62353001,623530101,6858831...
22:58:28 <centrinia> @check (\x -> x<= 0 || (x*(x+1) `div` 2 == (sum (zipWith (+) [1..x] (reverse [1..x]))) `div` 2 ))
22:58:29 <lambdabot>   "OK, passed 500 tests."
22:58:31 <centrinia> Yay.
22:58:49 <dmwit> uh
22:58:52 <CakeProphet> @let arithsum s = (length s / 2) * (first s + last s)
22:58:53 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
22:59:11 <dmwit> sum [1..x] -- better than (sum (zipWith (+) [1..x] [x,x-1..1]))
22:59:13 <CakeProphet> @let arithsum s = (length s / 2) * (head s + last s)
22:59:15 <lambdabot>  <local>:13:14:
22:59:15 <lambdabot>      No instance for (Fractional Int)
22:59:15 <lambdabot>        arising from a u...
22:59:18 <dmwit> ... `div` 2
22:59:29 <Olathe> @type (/)
22:59:30 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:59:32 <Olathe> @type length
22:59:34 <lambdabot> forall a. [a] -> Int
22:59:39 <int-e> genericLength
22:59:46 <Olathe> @type genericLength
22:59:48 <lambdabot> forall b i. (Num i) => [b] -> i
22:59:52 <Olathe> Ahh.
23:00:07 <Olathe> @type toInteger.length
23:00:08 <lambdabot> forall a. [a] -> Integer
23:00:14 <dmwit> ?let arithSum s = length s * (head s + last s) `div` 2
23:00:16 <lambdabot>  Defined.
23:00:17 <adrian_> happy new year
23:00:27 <dmwit> > (arithSum [1..2], arithSum [1..3])
23:00:28 <BMeph> Happy new year, Arizona. :)
23:00:28 <lambdabot>   (3,6)
23:00:34 <CakeProphet> what's the difference between / and `div`?
23:00:41 <dmwit> CakeProphet: The types.
23:00:43 <centrinia> > arithsum [1,100]
23:00:44 <lambdabot>   Not in scope: `arithsum'
23:00:47 <CakeProphet> arithSum [1..100]
23:00:49 <centrinia> > arithSum [1,100]
23:00:49 <Olathe> > celebrate
23:00:50 <dmwit> CakeProphet: `div` is integer division; / is real division
23:00:51 <lambdabot>   101
23:00:52 <lambdabot>   Happy 2003 !
23:00:58 <Olathe> @type div
23:01:00 <lambdabot> forall a. (Integral a) => a -> a -> a
23:01:01 <CakeProphet> hmmm... that's definitely not right.
23:01:05 <Olathe> @type (div, (/))
23:01:06 <lambdabot> forall a a1. (Fractional a1, Integral a) => (a -> a -> a, a1 -> a1 -> a1)
23:01:09 <centrinia> > arithSum [1..100]
23:01:10 <lambdabot>   5050
23:01:18 <pumpkin> @src div
23:01:19 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:01:22 <pumpkin> :(
23:01:29 <Olathe> @type (div, (/), length, genericLength, take, takeWhile, approxRational)
23:01:30 <lambdabot> forall a a1 a2 b i a3 a4 a5. (RealFrac a5, Num i, Fractional a1, Integral a) => (a -> a -> a, a1 -> a1 -> a1, [a2] -> Int, [b] -> i, Int -> [a3] -> [a3], (a4 -> Bool) -> [a4] -> [a4], a5 -> a5 ->
23:01:30 <lambdabot> Rational)
23:03:50 <CakeProphet> @let last' (l:[]) = l; last' (_:ls) = last' ls
23:03:52 <lambdabot>  Defined.
23:04:01 <CakeProphet> > last' [1..100]
23:04:03 <lambdabot>   100
23:04:33 <Olathe> > last' []
23:04:35 <lambdabot>   * Exception: <local>:15:0-40: Non-exhaustive patterns in function last'
23:04:42 <Olathe> > last []
23:04:44 <lambdabot>   * Exception: Prelude.last: empty list
23:05:07 <Olathe> > error "zomg"
23:05:09 <lambdabot>   * Exception: zomg
23:05:14 <CakeProphet> :t error
23:05:16 <lambdabot> forall a. [Char] -> a
23:05:17 <centrinia> > let div' a b = until (\(r,q) -> abs q < abs b) (\(r,q) -> (r - signum b * b,q+1) )  (a,0) in div` 100 3
23:05:17 <Olathe> > let a = error "zomg" in a
23:05:18 <lambdabot>   <no location info>: parse error on input `100'
23:05:19 <lambdabot>   * Exception: zomg
23:05:28 <CakeProphet> :t error "lol"
23:05:30 <lambdabot> forall a. a
23:05:41 <pumpkin> tonight is when the lambdabot abusers come out to play :o
23:05:51 <CakeProphet> ...what  does error "lol" produce.
23:05:57 <centrinia> > let div' a b = until (\(r,q) -> abs q < abs b) (\(r,q) -> (r - signum b * b,q+1) )  (a,0) in div' 100 3
23:05:59 <lambdabot>   (100,0)
23:06:08 <centrinia> > let div' a b = until (\(r,q) -> abs r < abs b) (\(r,q) -> (r - signum b * b,q+1) )  (a,0) in div' 100 3
23:06:09 <lambdabot>   (1,33)
23:06:10 <Olathe> We're going to party like it's 1999+10.
23:06:18 <centrinia> > let div' a b = until (\(r,q) -> abs r < abs b) (\(r,q) -> (r - signum b * b,q+1) )  (a,0) in div' -100 3
23:06:19 <lambdabot>       No instance for (Num (a -> a -> (a, t)))
23:06:19 <lambdabot>        arising from a use of `...
23:06:45 <centrinia> @let div' a b = until (\(r,q) -> abs r < abs b) (\(r,q) -> (r - signum b * b,q+1) )  (a,0)
23:06:47 <lambdabot>  Defined.
23:06:47 <CakeProphet> does error "lol" just stop the program and never return?
23:07:00 <Olathe> @type div'
23:07:02 <lambdabot>     Ambiguous occurrence `div''
23:07:02 <lambdabot>     It could refer to either `L.div'', defined at <local>:16:0
23:07:02 <lambdabot>                           or `Data.Fixed.div'', imported from Data.Fixed
23:07:07 <dmwit> CakeProphet: If it ever gets evaluated, yes.
23:07:09 <centrinia> pumpkin, I think I defined divMod.
23:07:09 <Olathe> O...K
23:07:20 <Olathe> @type L.div'
23:07:21 <lambdabot> forall a t. (Num a, Ord a, Num t) => a -> a -> (a, t)
23:07:26 <Olathe> Ord ?
23:07:31 <pumpkin> centrinia: looks like it :), or more like modDiv, the second time
23:07:42 <Olathe> > div' 5 "Hello"
23:07:44 <lambdabot>       Ambiguous occurrence `div''
23:07:44 <lambdabot>      It could refer to either `L.div'', def...
23:07:48 <Olathe> > L.div' 5 "Hello"
23:07:49 <lambdabot>       No instance for (Num [Char])
23:07:49 <lambdabot>        arising from the literal `5' at <in...
23:07:52 <CakeProphet> @let eat "cookies" = "lol useless"
23:07:54 <lambdabot>  Defined.
23:07:58 <pumpkin> o.O
23:08:06 <Olathe> > eat "edible things"
23:08:08 <lambdabot>   "* Exception: <local>:17:0-28: Non-exhaustive patterns in function eat
23:08:19 <CakeProphet> @let eat "edible things" = error "lolwhut"
23:08:21 <lambdabot>  Defined.
23:08:44 <Olathe> @type abs
23:08:45 <lambdabot> forall a. (Num a) => a -> a
23:08:52 <CakeProphet> @let abuse "lambdabot" = "aye aye, cap'n"; abuse x = "noep"
23:08:55 <lambdabot>  Defined.
23:09:00 <centrinia> > div` (-100) 3
23:09:02 <lambdabot>   <no location info>: parse error on input `('
23:09:05 <Olathe> Oh !
23:09:06 <centrinia> > div' (-100) 3
23:09:06 <CakeProphet> @data
23:09:07 <lambdabot>       Ambiguous occurrence `div''
23:09:07 <lambdabot>      It could refer to either `L.div'', def...
23:09:07 <lambdabot> Unknown command, try @list
23:09:19 <centrinia> > L.div' (-100) 3
23:09:21 <Olathe> > L.div' a b
23:09:22 <CakeProphet> can you make datatypes from lambdabot?
23:09:23 <lambdabot>   (a,0)
23:09:33 <Olathe> No.
23:09:34 <lambdabot>   thread killed
23:09:40 <Olathe> > L.div' 100 3
23:09:44 <CakeProphet> > a / b
23:09:46 <centrinia> Damn, my div' function doesn't work for negative dividends. :(
23:09:47 <Olathe> Poor lambdabot.
23:09:56 <Olathe> @botsnack
23:09:56 <pumpkin> centrinia: epic fail, sry
23:09:57 <lunabot>  :)
23:10:01 <lambdabot> :)
23:10:05 <Olathe> > lagrange
23:10:08 <CakeProphet> I should read up on how computer division works.
23:10:15 <lambdabot>       Overlapping instances for Show ([b] -> [b])
23:10:29 <centrinia> CakeProphet, try the second volume of The Art of Computer Programming.
23:10:30 <Olathe> > lagrange [0, 1, 8, 27]
23:10:37 <Olathe> Faster !
23:10:39 <lambdabot>   [0.0,0.0,0.0,1.0]
23:10:42 <quylui> if one were to learn haskell without any previous programming experience, how long do you think it would take them to ascertain an applicable understanding of the language?
23:10:56 <quylui> just curious
23:10:59 <pumpkin> quylui: depends how technically/mathematically minded you are :P
23:11:02 <pumpkin> I mean, one was
23:11:09 <quylui> :P
23:11:13 <centrinia> quylui, quicker than if one has previous programming experience. ;)
23:11:17 <CakeProphet> iterate (/11) 1
23:11:20 <CakeProphet> > iterate (/11) 1
23:11:28 <Olathe> > hurry up
23:11:29 <lambdabot>   [1.0,9.090909090909091e-2,8.264462809917356e-3,7.513148009015778e-4,6.83013...
23:11:35 <lambdabot>   Not in scope: `hurry'Not in scope: `up'
23:11:38 <rainmann> quylui, that varies quite a lot, but importantly, they are much better off having not been exposed to anything else
23:11:46 <quylui> could i get a ballpark estimate? (weeks, months...?)
23:11:58 <centrinia> 21 days.
23:12:00 <schme_> quylui: Somewhere in between a day and 15 years.
23:12:01 <Olathe> > iterate (/11) (1::Rational)
23:12:01 <centrinia>  :)
23:12:02 <quylui> hah
23:12:07 <Olathe> Eight hours.
23:12:09 <lambdabot>   [1%1,1%11,1%121,1%1331,1%14641,1%161051,1%1771561,1%19487171,1%214358881,1%...
23:12:11 <quylui> yeah i guess i expected this
23:12:12 <rainmann> quylui, I've seen someone take two weeks to achieve what another person hsa still failed to achieve after 3 years
23:12:29 <schme_> rainmann: You've been watching me, huh?
23:12:31 <quylui> what did they achieve after two weeks?
23:12:33 <CakeProphet> I honestly don't know. I think some concepts that I learned from functions in Python have been applicable to understanding Haskell... I certainly had a better grasp of functions after learning Python than before.
23:12:56 <rainmann> quylui, a certain understanding of some high-level abstractions and applying them
23:12:59 <quylui> CakeProphet: i'm taking up python after i feel comfortable with haskell :)
23:13:25 <Olathe> Learning the basics of writing functions from scratch in Scheme was good for learning Haskell.
23:13:25 <CakeProphet> but if you had a strong background in mathematics most aspects of Haskell would be natural.
23:13:40 <CakeProphet> SICP helped me with functional programminga lot.
23:13:58 <CakeProphet> but it's still a huge ordeal to figure out how to replace state in Haskell.
23:14:08 <CakeProphet> because I'm so used to using it.
23:14:14 <pumpkin> I wouldn't say an ordeal
23:14:43 <Olathe> Who uses...state ?
23:14:44 <Olathe> Eww.
23:14:52 <pumpkin> I haven't touched it yet
23:14:55 * pumpkin shudders
23:14:58 <CakeProphet> lack of state so far has been my main obstable in writing complex Haskell programs (either that or a lack of experience with the equivalent monads)
23:15:12 * CakeProphet likes state. :D
23:15:17 <pumpkin> lol
23:15:23 <Olathe> Repeated function application > state.
23:15:28 <quylui> CakeProphet: i'm undergrad in physics right now. haskell seems pretty straightforward so far, but i still haven't gotten to "monads" yet :o
23:15:40 <Olathe> Monads are simple enough.
23:15:42 <schme_> quylui: Nothing to 'em.
23:16:42 <CakeProphet> quylui:  do you know any other programming languages?
23:16:42 <centrinia> If you understand arrows, then you understand monads. Arrows are simplified functions. ;)
23:17:18 <dmwit> Functions are simplified arrows.
23:17:25 * pumpkin pulls out his bow and quiver
23:17:30 <dmwit> :t arr -- proof
23:17:32 <quylui> i'm struggling most with the syntax, spacing, stuff like that. unfortunately that's what's taking up most of my time.
23:17:32 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
23:17:55 * pumpkin eats appletizer
23:18:02 <quylui> learning to "think like a programmer"
23:18:31 * appletizer gasps at the hole on itself
23:18:36 <schme_> Oh wow. Good luck with that.
23:19:04 <CakeProphet> quylui: thinking in Haskell has been like no other programming I've ever done.
23:19:43 <quylui> CakeProphet: what exactly do you mean?
23:19:50 <CakeProphet> @bf +++++++++++++++++++++++++++++++++++++++++.
23:19:51 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
23:19:57 <CakeProphet> still broken. :(
23:20:29 <awesame> quylui: if you cross your eyes, haskell syntax looks a lot like math notation
23:20:34 <int-e> > chr . length $ "+++++++++++++++++++++++++++++++++++++++++"
23:20:35 <Olathe> @hoogle (a -> Either b c) -> (a -> Maybe c)
23:20:35 <lambdabot>   ')'
23:20:36 <lambdabot> No results found
23:20:41 <Olathe> No results found ?!
23:20:46 <CakeProphet> quylui:  well, I'm used to imperitive languages.
23:20:49 <awesame> or squint at it, maybe
23:21:14 <quylui> heh
23:21:25 <Twey> quylui: Grab a copy of something that will do the formatting for you :)
23:21:43 <quylui> Twey: such a thing exists?
23:21:53 <quylui> other than emacs, presumably
23:21:53 <Olathe> @type let zomg f a = kaboom (f a) where kaboom (Right x) = Maybe x; kaboom _ = Nothing in zomg
23:21:55 <lambdabot> Not in scope: data constructor `Maybe'
23:22:02 <Olathe> @type let zomg f a = kaboom (f a) where kaboom (Right x) = Just x; kaboom _ = Nothing in zomg
23:22:04 <lambdabot> forall t t1 t2. (t -> Either t1 t2) -> t -> Maybe t2
23:22:11 <Olathe> Take that !
23:22:16 <CakeProphet> I kind of want to write a bf interpreter function recursively.
23:22:21 <CakeProphet> not entirely sure how though
23:22:25 <Olathe> Why doesn't that exist by default ?
23:22:55 <Olathe> @djinn forall t t1 t2. (t -> Either t1 t2) -> t -> Maybe t2
23:22:56 <lambdabot> f a b =
23:22:56 <lambdabot>     case a b of
23:22:56 <lambdabot>     Left _ -> Nothing
23:22:56 <lambdabot>     Right c -> Just c
23:22:57 <Twey> quylui: Nothing wrong with emacs
23:23:01 <int-e> @type either Just (const Nothing)
23:23:03 <lambdabot> forall a b. Either a b -> Maybe a
23:23:05 <pumpkin> I wonder how short you can make a bf interpreter in haskel
23:23:07 <pumpkin> +l
23:23:11 <Twey> KDevelop has a Haskell plugin too
23:23:22 <CakeProphet> evyerthing would be fairly simple except for [ and ]
23:23:26 * BMeph still wants a sweatshirt that proudly displays, "Immutable State"
23:23:26 <quylui> Twey: i use emacs, it's great. i still encounter formatting errors, though
23:23:31 <int-e> @type (either (const Nothing) Just .)
23:23:32 <lambdabot> forall a a1 a2. (a2 -> Either a1 a) -> a2 -> Maybe a
23:23:42 <Olathe> @type either (const Nothing) Just
23:23:44 <lambdabot> forall a a1. Either a1 a -> Maybe a
23:23:51 <Olathe> Ahh.
23:24:26 <Twey> quylui: The haskell-mode is pretty accurate as far as I can see
23:24:33 <Twey> It's fairly simple, it just aligns to tokens on the line above
23:24:35 <awesame> BMeph: would this sweatshirt be transparent?
23:24:36 <Olathe> @djinn forall t t1 t2. (t -> Either t1 t2) -> t -> Maybe t1
23:24:37 <lambdabot> f a b =
23:24:37 <lambdabot>     case a b of
23:24:37 <lambdabot>     Left c -> Just c
23:24:37 <lambdabot>     Right _ -> Nothing
23:24:39 <quylui> Twey: i'm using it right now
23:24:58 <Olathe> @@ @pl @djinn forall t t1 t2. (t -> Either t1 t2) -> t -> Maybe t1
23:24:59 <lambdabot>  (line 1, column 36):
23:24:59 <lambdabot> unexpected ">" or "-"
23:24:59 <lambdabot> expecting variable, "(", operator or end of input
23:25:14 <quylui> Twey: unfortunately this is only my fifth day with the language so i'm not too keen on how to organize everything
23:25:21 <pumpkin> @. pl djinn forall t t1 t2. (t -> Either t1 t2) -> t -> Maybe t1
23:25:21 <lambdabot> (line 3, column 12):
23:25:22 <lambdabot> unexpected ">" or "-"
23:25:22 <lambdabot> expecting variable, "(", operator or end of input
23:25:25 <pumpkin> boo :(
23:25:27 <quylui> though i'm getting in the gist of things.
23:25:44 <awesame> I really don't like haskell-mode
23:26:06 <Twey> quylui: Organise it the way that makes sense
23:26:09 <CakeProphet> what's string equivalence?
23:26:25 <CakeProphet> ..(the operator)
23:26:33 <awesame> I think maybe that's because I want consistent indentation, not alignment to tokens on the line above?  I can never figure out what it's trying to do
23:26:38 <int-e> > "abc" == "abc" -- this?
23:26:38 <idnar> > "foo" == "foo"
23:26:40 <quylui> Twey: sure, but i have to organize it in a way that makes sense to the interpreter as well
23:26:40 <lambdabot>   True
23:26:40 <lambdabot>   True
23:26:48 <CakeProphet> > 'c' == 'c'c
23:26:49 <lambdabot>   Couldn't match expected type `t -> Char'
23:26:50 <CakeProphet> ah okay
23:26:52 <CakeProphet> > 'c' == 'c'
23:26:53 <lambdabot>   True
23:26:57 <CakeProphet> char too
23:27:04 <int-e> @instances Eq
23:27:04 <sbahra> Twey, I'm teaching AppleJuice Haskell right now :-P
23:27:05 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:27:09 <sbahra> Twey, if you recall him.
23:27:09 <Twey> awesame: In Haskell, the most important thing is usually the position relative to the above line
23:27:11 <int-e> and those, and more.
23:27:15 <Twey> sbahra: Vaguely
23:27:19 <Twey> sbahra: How's he getting on?
23:27:24 <int-e> @src Dual
23:27:25 <lambdabot> Source not found. Take a stress pill and think things over.
23:27:25 <awesame> maybe I write funny-looking haskell!
23:27:33 <sbahra> Twey, so far, so good. He's loving it.
23:27:34 <Twey> awesame: Haha :-P
23:27:38 <sbahra> Twey, I'll get him in here soon. :-P
23:27:40 <Twey> sbahra: First language?
23:27:40 * sbahra cackles 
23:27:45 <Twey> Hehe
23:27:48 <Twey> He will be assimilated!
23:27:53 <sbahra> No, not first language.
23:28:03 <sbahra> But he barely has any experience in programming, which is great.
23:28:08 <int-e> what's that Dual thing?
23:28:28 <rwbarton> @instances Monoid
23:28:29 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:28:31 <Olathe> Something about the morphism's dual or something.
23:28:35 <int-e> @type Dual
23:28:37 <lambdabot> forall a. a -> Dual a
23:28:41 <sbahra> He is loving type classes, for example. :)
23:28:46 <sbahra> Which is cool.
23:28:48 <rwbarton> I think it reverses the operation in a monoid.  It should be called Opposite.
23:29:16 <Olathe> "The dual of a monoid, obtained by swapping the arguments of mappend.
23:29:18 <Twey> sbahra: You realise you're ruining his career prospects
23:29:32 <Twey> Whenever he sees another language, he'll be thinking 'what is this crap!' :-P
23:29:39 <rwbarton> Olathe: Yeah, it's not really called the dual :)
23:30:28 <Twey>  /exec - mpc play
23:30:30 <Twey> Oops
23:32:27 <pumpkin> > ((), All True, Any False, True, 'a', Dual 2, Left 4, First Nothing, 5, Last (Just 7), Just 7, LT, Product 2, Sum 6, [1]) == ((), All True, Any False, True, 'a', Dual 2, Left 4, First Nothing, 5, Last (Just 7), Just 7, LT, Product 2, Sum 6, [1])
23:32:28 <lambdabot>   True
23:32:33 <pumpkin> ah, just what I thought
23:32:51 <idnar> heh
23:32:56 * Twey blinks.
23:33:04 <pumpkin> @instances Eq
23:33:07 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:33:08 <pumpkin> got most of them :P
23:33:11 <Twey> Ah
23:33:14 <idnar> what the heck is First?
23:33:17 <pumpkin> not a clue
23:33:23 <pumpkin> @index First
23:33:25 <Twey> @info First
23:33:27 <lambdabot> bzzt
23:33:29 <lambdabot> First
23:33:32 <pumpkin> lol
23:33:34 <Twey> Helpful
23:33:36 <pumpkin> really helpful, thanks lambdabot
23:33:38 <idnar> "Maybe monoid returning the leftmost non-Nothing value. "
23:33:48 <BMeph> awesame: Only referentially. ;p
23:33:49 <Twey> Oho.
23:33:51 <idnar> isn't that what Maybe does already?
23:33:55 <Twey> No
23:34:01 <Twey> It returns the rightmost
23:34:22 <idnar> okay, but Last is "Maybe monoid returning the rightmost non-Nothing value. "
23:34:23 <Twey> > Just 5 >> Just 3
23:34:25 <lambdabot>   Just 3
23:34:29 <Twey> > Just 5 >> Just 3 >> Nothing
23:34:30 <lambdabot>   Nothing
23:34:35 <idnar> Twey: monoid, not monad
23:34:40 <Twey> Ah, yes
23:34:41 <Twey> Hmn.
23:34:44 <idnar> oh, wait
23:34:55 <idnar> > Just 5 `mappend` Just 6
23:34:57 <lambdabot>   Add a type signature
23:35:01 <int-e> > First 1 `mappend` First 2
23:35:03 <lambdabot>       No instance for (Num (Maybe a))
23:35:03 <idnar> > Just [5] `mappend` Just [6]
23:35:05 <lambdabot>        arising from the literal `1' at ...
23:35:09 <lambdabot>   Just [5,6]
23:35:34 <idnar> right, that just does mappend on the inner monoid
23:35:47 <idnar> so I guess I was thinking of the monad
23:36:38 <int-e> > mconcat . map Last $ [Nothing, Just 1, Nothing, Just 2, Nothing]
23:36:40 <lambdabot>   Last {getLast = Just 2}
23:36:45 <int-e> > mconcat . map First $ [Nothing, Just 1, Nothing, Just 2, Nothing]
23:36:47 <lambdabot>   First {getFirst = Just 1}
23:36:47 <BMeph> Twey: No, The Maybe monoid returns the mappend of all of its 'Just' arguments. :)
23:37:02 <pumpkin> I'm so superficial
23:37:09 <pumpkin> but I really hate reading "old PDFs"
23:37:26 <Twey> As opposed to new PDFs?
23:37:26 <BMeph> Just (Product 5) `mappend` Just (Product 6)
23:37:36 <Twey> I don't like PDFs where the font's all buggered up for some reason
23:37:36 <pumpkin> Twey: yup
23:37:40 <pumpkin> Twey: exactly
23:37:41 <BMeph> > Just (Product 5) `mappend` Just (Product 6)
23:37:43 <lambdabot>   Just (Product {getProduct = 30})
23:37:45 <Twey> Makes my eyes go funny
23:38:09 <Olathe> > 5 .&. 6
23:38:10 <lambdabot>       Ambiguous occurrence `.&.'
23:38:11 <lambdabot>      It could refer to either `Data.Bits..&....
23:38:21 <Olathe> > Data.Bits.(.&.) 5 6
23:38:21 <int-e> > Dual "abc" `mappend` Dual "def"
23:38:24 <lambdabot>       Failed to load interface for `Data':
23:38:24 <lambdabot>        Use -v to see a list of the...
23:38:24 <lambdabot>   Dual {getDual = "defabc"}
23:38:33 <Olathe> How am I supposed to use .&. ?
23:38:39 <int-e> @type (.&.)
23:38:41 <lambdabot>     Ambiguous occurrence `.&.'
23:38:41 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
23:38:41 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
23:38:48 <int-e> @type (Data.Bits..&.)
23:38:49 <lambdabot> forall a. (Bits a) => a -> a -> a
23:38:56 <Olathe> > (Data.Bits..&.) 5 6
23:38:58 <lambdabot>   Add a type signature
23:39:03 <Olathe> > (Data.Bits..&.) 5 6 :: Integer
23:39:04 <lambdabot>   4
23:39:08 <Olathe> Ahh, thanks :)
23:39:31 <int-e> qualified names for infix operators are ugly though.
23:40:03 <int-e> > 5 Data.Bits..&. 6 :: Int
23:40:04 <lambdabot>   4
23:40:22 <BMeph> int-e: I like to think of it an an 'inqualified' failure. ;p
23:40:40 <BMeph> *'unqualified', even. :p
23:41:16 <BMeph> > 5 Data.Bits..|. 2::Word32
23:41:18 <lambdabot>   7
23:41:23 <quylui> i just broke ghci by running the fibonacci sequence
23:41:42 <adrian_> quylui: you ran out of electrons?
23:41:51 <quylui> i'm positive.
23:42:04 <quylui> BA DUM TSH
23:42:51 <CakeProphet> > let bf (x:source) state pt input | x == '+' = bf source (first ++ (val+1) ++ last) pt input | x == '-' = bf source (first ++ (val-1) ++ last) pt input | x == '>' = bf source state (pt+1) input | x == '<' && pt > 0 = bf source state (pt-1) input | x == '.' = chr val: bf source state pt input | x == ',' = bf source (first ++ (head input) ++ last) pt (tail input) where (first, val, last) =...
23:42:52 <CakeProphet> ...((take pt state), state!!pt, (drop (pt+1) state)) in bf "++++++++++++++++++."
23:42:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:42:54 <CakeProphet> ...
23:43:02 <CakeProphet> well then
23:43:17 <adrian_> I wonder if any quotes from #haskell ever make it to bash.org
23:43:24 <pumpkin> > (id >>= (==)) 5 -- I like being obscure
23:43:26 <lambdabot>   True
23:44:09 <adrian_> :t (>>=)
23:44:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:45:11 <pumpkin> > uncurry (&&) $ (join (==) &&& (id >>= (==))) 5 -- let's see how big we can make const True
23:45:12 <lambdabot>   True
23:46:14 <pumpkin> anyone wanna help me be useless?
23:48:13 <quylui> sure
23:48:29 <pumpkin> just trying to make my function larger and scarier
23:50:34 <centrinia> > (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in ((x' x') x') True) False
23:50:36 <lambdabot>   True
23:50:48 <pumpkin> lol
23:51:18 <pumpkin> mine is more monadic and arrowful though
23:51:25 <pumpkin> let's merge 'em!
23:51:29 <CakeProphet> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in ((x' x') x') True) False
23:51:30 <lambdabot> True
23:51:35 <CakeProphet> ...
23:51:39 <pumpkin> lol
23:51:50 <CakeProphet> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in ((x' x') x') True)
23:51:51 <lambdabot> const True
23:51:55 <pumpkin> hah
23:51:55 <CakeProphet> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in ((x' x') x'))
23:51:56 <lambdabot> const
23:51:58 <CakeProphet> ...
23:52:02 <CakeProphet> ridiculous
23:52:05 <pumpkin> I'm impressed that @pl can figure that out :)
23:52:08 <CakeProphet> pointless isn't making more complicated.
23:52:09 <CakeProphet> me too
23:52:11 <pumpkin> I bet it can't do mine
23:52:31 <pumpkin> @pl uncurry (&&) $ (join (==) &&& (id >>= (==)))
23:52:31 <lambdabot> uncurry (&&) (join (==) &&& ((==) =<< id))
23:52:34 <pumpkin> muahahaha
23:52:39 * pumpkin muahahahas some more
23:52:46 <centrinia> > (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in ( (x' (x' x')) ((x' x') x') ((x' x') x') ) (((x' x') x') True)) False
23:52:48 <lambdabot>   True
23:53:01 <pumpkin> @unpl const
23:53:01 <lambdabot> (\ a _ -> a)
23:53:05 <CakeProphet> hmmm, the problem with my current bf function is that it discards old instructions, when it needs them for [] backtracking.
23:53:08 <pumpkin> @unpl  (\ a _ -> a)
23:53:08 <lambdabot> (\ a _ -> a)
23:53:09 <centrinia> :t (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in ( (x' (x' x')) ((x' x') x') ((x' x') x') ) (((x' x') x')))
23:53:11 <lambdabot> forall t t1. t -> t1 -> t
23:53:16 <Olathe> @unpl maybe
23:53:16 <lambdabot> maybe
23:53:24 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in ( (x' (x' x')) ((x' x') x') ((x' x') x') ) (((x' x') x')))
23:53:24 <lambdabot> const
23:53:33 <Olathe> @unpl maybe.not
23:53:33 <lambdabot> (\ c -> maybe (not c))
23:53:54 <pumpkin> @unpl maybe || maybe.not
23:53:55 <lambdabot> (maybe || \ c -> maybe (not c))
23:54:45 <centrinia> pumpkin, I think pointless was able to simplify my expression because it really does correspond to the simplified functions. :)
23:55:04 <pumpkin> awesome
23:55:13 <pumpkin> it's fun
23:55:26 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in  (x' (x' x'))  )
23:55:26 <lambdabot> ap
23:55:32 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in  ((x' x') x')  )
23:55:32 <pumpkin> lol
23:55:32 <lambdabot> const
23:55:40 <pumpkin> such a minor change
23:55:43 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in  ((x' x') x') ((x' x') x') ((x' x') x')  )
23:55:44 <lambdabot> const
23:55:47 <pumpkin> you have shown a fundamental linkage between ap and const
23:55:52 <pumpkin> !
23:56:02 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in  (x' (x' x')) ((x' x') x') ((x' x') x')  )
23:56:03 <lambdabot> id
23:56:16 <pumpkin> wow, they're all permutations of the same function!
23:56:18 <centrinia> @pl ap const const
23:56:19 <lambdabot> id
23:56:25 <pumpkin> :P
23:56:27 <centrinia> @pl ap ap ap
23:56:27 <lambdabot> ap ap ap
23:56:34 <pumpkin> :t ap ap ap
23:56:36 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
23:56:36 <lambdabot>     Probable cause: `ap' is applied to too few arguments
23:56:36 <lambdabot>     In the second argument of `ap', namely `ap'
23:56:45 <pumpkin> :t ap . ap . ap
23:56:46 <lambdabot> forall a a1 b. (a -> a1 -> b) -> (((a -> a1) -> a) -> a -> a1) -> ((a -> a1) -> a) -> b
23:57:13 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in x')
23:57:13 <lambdabot> flip (flip ($ const) ap) const
23:57:30 <pumpkin> ah, there's the @pl we all know and love
23:57:34 <pumpkin> I knew it was too simple
23:57:59 <centrinia> That was an one-point basis for SK combinatory logic.
