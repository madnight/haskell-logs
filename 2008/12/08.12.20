00:00:03 <Cale> (similar to Haskell's type notation)
00:00:15 <Gracenotes> mmorrow: using it as a concurrent cache, essentially?
00:00:21 <mmorrow> Gracenotes: yes
00:00:31 <pumpkin> Cale: ok
00:01:14 <mmorrow> Gracenotes: and threads blocked on an mvar queue up and are serviced in fifo order
00:01:36 <Cale> There is an operation called composition (defined as part of the category). If f: X -> Y, and g: Y -> Z are arrows, then their composite g . f is some arrow X -> Z
00:01:53 <Gracenotes> mvar queue is internal?
00:02:03 <psygnisfive> Arrows?!
00:02:06 <psygnisfive> :O
00:02:08 <psygnisfive> whats an arrow
00:02:09 <Cale> Also, for every object X, there is an arrow id_X: X -> X such that id_X . f = f and g . id_X = g for any appropriate f and g
00:02:14 <mmorrow> well, the rts implements that queueing
00:02:35 <mmorrow> but on the topic of queues, a Chan is implemented with Mvars
00:02:38 <mmorrow> @src Chan
00:02:38 <lambdabot> Source not found. You untyped fool!
00:02:42 <Cale> psygnisfive: Anything at all, in this case -- I'm defining a category, see above :)
00:02:43 <mmorrow> grfr
00:02:57 <Gracenotes> I've heard of Chans! mystical creatures, they are.
00:03:04 * psygnisfive shoots anything at all at cale
00:03:14 <Gracenotes> but, yeah. http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
00:03:15 <Cale> and one last thing...  f . (g . h) = (f . g) . h whenever f, g, and h are appropriately typed arrows
00:03:17 <pumpkin> Cale: makes sense so far
00:03:29 <mmorrow> data Chan a = Chan  (MVar (Stream a))
00:03:29 <mmorrow>                     (MVar (Stream a))
00:03:47 <mmorrow> type Stream a = MVar (ChItem a)
00:03:52 <Cale> any objects, arrows, composition and identities which satisfy these criteria are said to form a category
00:03:54 <conal> jsn: oh, okay. :)
00:03:55 <mmorrow> data ChItem a = ChItem a (Stream a)
00:04:19 <Cale> The most familiar category from mathematics is the category whose objects are sets, and whose arrows are functions.
00:04:31 <pumpkin> yeah, that's what I've been thinking of it as so far :P
00:04:43 <pumpkin> what are the other options?
00:04:59 <pumpkin> -the
00:05:01 <Cale> Another example would be, pick your favourite logical system, and have the objects be statements in it.
00:05:18 <Cale> and have exactly one arrow A -> B if and only if A entails B logically.
00:05:22 <mmorrow> Gracenotes: and MVars are a ghc primitive, so they're at the bottom level as far as haskell can tell
00:06:20 <pumpkin> ah
00:06:27 <Cale> If you've had a linear algebra course, another example would be to fix a field, and take the objects to be vector spaces over that field, and the arrows be linear transformations.
00:07:08 <Cale> Or groups and group homomorphisms, rings and ring homomorphisms, graphs and graph homomorphisms, fields and field morphisms...
00:07:17 <Cale> Topological spaces and continuous maps
00:07:31 <Cale> Metric spaces and contraction maps
00:07:44 <Cale> (If you don't recognise the examples, don't worry about it :)
00:08:18 <lament> hell, is there any class of mathematical object that doesn't form a category?
00:08:19 <Cale> But almost all of mathematics ends up being the study of some objects which are naturally a category in one way or another.
00:08:23 <pumpkin> I get the first two :)
00:08:48 <Cale> Let's take another off-the-wall example...
00:09:30 <Cale> Let S be any set, and <= be a preorder on S. That is, we have that x <= x for any x in S, and whenever x <= y and y <= z, we have x <= z as well.
00:09:50 <Cale> Then we can turn S into a category in a similar way to what we did with logical systems.
00:10:15 <Cale> We let S be the set of objects, and put a unique arrow x -> y when x <= y.
00:10:39 <Cale> How about a monoid? Do you know what a monoid is?
00:10:49 <pumpkin> vaguely
00:10:54 <vininim_> this reminds me I have to install flash to watch the catsters
00:11:24 <Cale> A monoid is a set M, together with a binary operation M x M -> M, usually called multiplication, such that:
00:11:45 <Cale> There is an identity element 1 in M for which 1 * x = x * 1 = x for all x in M
00:12:01 <pumpkin> it's a group without the need for inverses, right?
00:12:05 <Cale> Multiplication is associative: x*(y*z) = (x*y)*z, for all x,y,z in M
00:12:08 <Cale> yeah
00:12:32 <Cale> So if we have a monoid, we can turn it into a category with exactly one object.
00:12:50 <Cale> The arrows of that category are the elements of M
00:12:56 <Cale> and composition is multiplication
00:13:07 <pumpkin> ah, that's an interesting way to do it
00:13:17 <pumpkin> and the object is the operation
00:13:18 <pumpkin> ?
00:13:30 <Gracenotes> okay, so the getQuotes function has the type ReaderT (MVar (M.Map P.ByteString [P.ByteString]), String) (ReaderT (IRCRState,IORef IRCRWState) IO a) String
00:13:35 <Gracenotes> as far as I can tell
00:13:43 <Gracenotes> useful, I know >_>
00:13:52 <Cale> So a category is a simultaneous generalisation of a monoid and a preorder. In the monoid case, we only have one object, but lots of arrows, and in the preorder case, we have at most one arrow between any two objects, but lots of objects.
00:14:05 <Gracenotes> *runQuote
00:14:11 <Cale> pumpkin: The object is just a placeholder, it doesn't actually do anything in the monoid case.
00:14:18 <Gracenotes> oh, and String -> the whole expression above
00:14:19 <pumpkin> ah, I see
00:14:33 <Cale> pumpkin: In fact, objects are mostly just for keeping track of which arrows compose.
00:14:45 <pumpkin> and in this case they all do?
00:14:48 <Cale> yeah
00:14:53 <pumpkin> ah ok
00:15:06 <Cale> Objects in category theory are not required to have any internal structure of any kind.
00:15:31 <Cale> Category theory deals only with how the objects relate to one another via the arrows, and not the internals of the objects.
00:15:36 <pumpkin> ah
00:16:10 <pumpkin> so in haskell's category (hask? I remember seeing that somewhere), are the objects types that determine what functions can be used on one another
00:16:13 <pumpkin> ?
00:16:25 <Cale> Yeah, the objects are types, and the arrows are functions.
00:16:33 <pumpkin> ah
00:16:34 <Cale> (Haskell definable functions)
00:17:19 <lament> and monads are monads?
00:17:21 <Cale> and composition is just composition :)
00:17:29 <Cale> Yes, and monads are indeed monads :)
00:17:32 <Cale> hehe
00:17:35 <pumpkin> lol
00:17:36 <lament> odd
00:17:46 <lament> i don't understand the importance of the monad as a mathematical structure at all
00:17:54 <Cale> Functors are just endofunctors though ;)
00:17:56 <lament> it seems pretty arbitrary
00:18:06 <lament> right, obviously endofunctors
00:18:16 <lament> unless we use FFI :D
00:18:20 <Cale> hehe
00:18:34 <pumpkin> so what are functors in the context of category theory?
00:18:36 <lament> why are monads important in math?
00:18:43 <lament> pumpkin: functors are arrows between categories
00:19:06 <lament> :t fmap
00:19:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:19:12 <pumpkin> so there's a category whose objects are categories?
00:19:17 <lament> yes
00:19:18 <Cale> pumpkin: yes :)
00:19:23 <pumpkin> awesome
00:19:37 <pumpkin> but that kind of functor doesn't exist in haskell?
00:19:41 <lament> but in haskell, functors are only arrows from hask to hask
00:19:47 <Cale> If C and D are two categories, then a functor F: C -> D is an assignment, for each object X of C, an object FX of D
00:19:56 <lament> because you can't go to any other category outside of haskell :)
00:20:00 <pumpkin> yeah :P
00:20:08 <pumpkin> ah, is that what the endo means?
00:20:09 <Cale> and for each arrow h: X -> Y of C, an arrow Fh: FX -> FY in D.
00:20:09 <pumpkin> within?
00:20:11 <lament> yes
00:20:16 <pumpkin> ah
00:20:25 <Gracenotes> @instances Functor
00:20:26 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
00:20:30 <Cale> Such that: F(id_X) = id_(FX)
00:20:36 <lament> there can be many different arrows from an object to that same object
00:20:38 <Cale> and F(f.g) = Ff . Fg
00:21:04 <Cale> So for instance, [] is a good example.
00:21:20 <Cale> [] takes a type t, to the type [t] of lists of values of type t
00:21:44 <Cale> and (via fmap) it sends a function a -> b to a function [a] -> [b]
00:21:51 <Cale> and the two laws are satisfied
00:21:54 <pumpkin> ah
00:22:04 <lament> i suppose that data Foo a = Foo a is a distinct functor for all Foo?
00:22:12 <Cale> fmap (f . g) = fmap f . fmap g
00:22:17 <Cale> and fmap id = id
00:22:20 <Cale> (in Haskell notation)
00:22:22 <pumpkin> yeah
00:22:33 <Cale> lament: yeah.
00:22:49 <Cale> lament: There's an obvious natural isomorphism between them though
00:22:54 <pumpkin> something about fmap feels "linear" :P
00:22:56 <lament> right
00:23:16 <Cale> pumpkin: Yeah, it's structure preserving in the same way that linear transformations and group homomorphisms are.
00:23:23 <pumpkin> ok
00:23:44 <Beelsebob> Cale: yeh, that fmap id = id rule is really irritating in a Haskell context
00:23:49 <Beelsebob> mostly because of lazyness
00:24:17 <Cale> Well, we usually ignore bottoms when deciding if the rules hold.
00:24:52 <Beelsebob> the pair functor certainly doesn't
00:24:56 <Beelsebob> (and it's bloody annoying)
00:25:04 <Beelsebob> > fmap id undefined
00:25:05 <lambdabot>       No instance for (Show (f a))
00:25:05 <lambdabot>        arising from a use of `show' at <in...
00:25:16 <Beelsebob> > fmap id undefined  :: (a,a)
00:25:17 <lambdabot>   * Exception: Prelude.undefined
00:25:23 <Gracenotes> > fmap show (4, "hello")
00:25:24 <lambdabot>   (4,"\"hello\"")
00:25:36 <Gracenotes> > fmap show ("hello", 3)
00:25:37 <lambdabot>   ("hello","3")
00:26:26 <Cale> (nb. this is why if you're going to tag values with something using pairs, the less-important tag should go in the first component of the pair)
00:26:52 <pumpkin> Cale: so I know what a monad is in the context of haskell... in a broader mathematical sense, how would you describe it?
00:26:53 <Gracenotes> @type const
00:26:54 <lambdabot> forall a b. a -> b -> a
00:27:09 <Cale> pumpkin: Well, I'd have to describe what a natural transformation is
00:27:10 <Beelsebob> Cale: yeh, it's fmapping something over undefined that annoys me
00:27:16 <Beelsebob> you don't get out that the result is a pair
00:27:26 <Cale> pumpkin: Natural transformations are the arrows between two functors.
00:27:32 <Beelsebob> (because then fmap id undefined /= undefined
00:27:38 <Gracenotes> > uncurry const ("less important", "important")
00:27:40 <lambdabot>   "less important"
00:28:13 <Cale> Beelsebob: Wait, doesn't that satisfy the rule?
00:28:32 <Cale> Beelsebob: fmap id undefined = id undefined = undefined
00:28:47 <Gracenotes> > uncurry (flip const) ("less important", "important")
00:28:48 <lambdabot>   "important"
00:28:54 <Cale> Beelsebob: That's good, isn't it?
00:29:00 <Beelsebob> Cale: yeh exactly, what I'm saying is that I'd like the Functor instance for tuples to be lazy
00:29:02 <pumpkin> Cale: so a functor is the arrow in the category whose obects are categories, and a monad is an arrow in the category whose objects are functors? or am I just getting confused :P
00:29:05 <Beelsebob> and in that case, it would break the rule
00:29:17 <Beelsebob> fmap id undefined :: (a,b) = (undefined, undefined)
00:29:23 <pumpkin> Cale: oh wait, I misunderstood what you just said
00:29:36 <Cale> pumpkin: No, that's what a natural transformation is.
00:29:42 <pumpkin> yeah, I misread it :) sorry
00:29:57 <Cale> pumpkin: A monad is a triple, consisting of an endofunctor, and two natural transformations
00:30:18 <Gracenotes> the endofunctor being bind?
00:30:37 <Cale> no, the endofunctor being the type constructor
00:30:41 <Cale> (and fmap)
00:30:49 <Gracenotes> oh, and the natural transformations are bind and unit
00:30:53 <Cale> nope
00:30:57 <Gracenotes> heh
00:30:59 <Cale> return and join
00:31:04 <Cale> but it's equivalent
00:31:21 <Cale> I suppose you could choose bind, but its category theoretic description is more complicated than necessary
00:31:36 <Cale> (because it's natural in two parameters)
00:31:48 <Gracenotes> and join is a type of functor
00:31:57 <pumpkin> so a monad is a triple, why is it defined that way?
00:31:57 <Cale> join is a natural transformation
00:32:02 <Gracenotes> yes
00:32:09 <chrisdone> :t unsafeCompareInfiniteDatastructures
00:32:11 <lambdabot>     Not in scope: `unsafeCompareInfiniteDatastructures'
00:32:47 <Beelsebob> why is that unsafe chrisdone?
00:32:50 <Cale> pumpkin: Well, it's not *primarily* a triple, it's just that three things specify it. They're required to satisfy some laws.
00:32:56 <Beelsebob> or does it terminate with true after a while?
00:33:11 <Gracenotes> oh, mapM is the functor
00:33:16 <chrisdone> unsafePh'ngluimglw'nafhCthulhuR'lyehwgah'naglfhtagn
00:33:16 <Gracenotes> silly me, confuzzling them.
00:33:17 <chrisdone> :P
00:33:46 <shepheb> @quote madness
00:33:47 <lambdabot> LoganCapaldo says: madness? This is #haskell!
00:33:51 <Gracenotes> > join ["hello", "world"]
00:33:52 <lambdabot>   "helloworld"
00:34:08 <pumpkin> Cale: so to be blunt about it, what's the "point" of creating such a structure... are its laws "natural" in some way that makes it an interesting structure to study?
00:34:13 <Cale> lament: Monads were first useful in mathematics mostly as part of the study of adjoint functors (which are interesting because they pop up everywhere)
00:34:20 <Cale> pumpkin: yes
00:34:28 <Gracenotes> what are some, eh, more useful uses of join?
00:34:41 <pumpkin> Gracenotes: to get rid of a layer of Maybe!!
00:34:42 <pumpkin> :P
00:34:45 <mmorrow> , join (Just Nothing)
00:34:52 <lunabot>  Nothing
00:34:56 <Cale> pumpkin: One fun thing you can do is to generalise the definition of a monoid so that instead of being a set, it's an object in some category with specific properties.
00:35:19 <pumpkin> > join Left $ Right 5
00:35:20 <lambdabot>   Couldn't match expected type `a -> b'
00:35:28 <Gracenotes> mmorrow: well, yes, but where would one use that ;)
00:35:30 <mmorrow> join (takeMVar (mvar :: MVar (IO a))) :: IO a
00:35:31 <Cale> pumpkin: A monad is then a monoid object in a particular category (the category of endofunctors and natural transformations between them)
00:35:33 <chrisdone> `join' could peel an orange and not have any white bits lfet
00:35:35 <pumpkin> > join (Left (Right 5))
00:35:36 <lambdabot>       No instance for (Error (Either a t))
00:35:36 <lambdabot>        arising from a use of `join...
00:35:39 <pumpkin> boo
00:35:58 <mmorrow> Gracenotes: it's actually really handy, but it doesn't look it until it comes up
00:36:08 <pumpkin> Cale: this is so meta* :P
00:36:17 <pumpkin> Cale: but graspable so far
00:36:18 <Cale> pumpkin: Yeah, just wait. :)
00:36:19 <Cale> hehe
00:36:56 <Cale> pumpkin: If you've understood this much, you should watch the Catsters videos...
00:37:00 <pumpkin> > join (*) 5
00:37:01 <lambdabot>   25
00:37:07 <pumpkin> Cale: ooh, where?
00:37:14 <Gracenotes> :t join (*)
00:37:15 <lambdabot> forall a. (Num a) => a -> a
00:37:16 <Cale> http://uk.youtube.com/user/TheCatsters
00:37:17 <jsn> pumpkin: youtube
00:37:39 <pumpkin> ooh
00:37:46 <Cale> You might start with the playlist on natural transformations...
00:38:02 <Cale> I can't recall if that was a really good approach for beginners though
00:38:04 <pumpkin> oh is it not in order?
00:38:19 <mmorrow> f =<< m    ===   join (fmap f m)
00:38:22 <pumpkin> Cale: I'll also start browsing that pdf you linked to
00:38:30 <Cale> Not in any reasonable order for learning.
00:38:31 <mmorrow> @pl \f m -> join (fmap f m)
00:38:31 <lambdabot> (=<<)
00:38:31 <pumpkin> not really browsing, reading :P
00:38:33 <Gracenotes> which PDF?
00:38:34 <Cale> http://uk.youtube.com/profile?user=TheCatsters&view=playlists
00:38:41 <mmorrow> (join .) . fmap
00:38:53 <Cale> has major chunks selected though, so you can look for ones which make sense :)
00:38:58 <chrisdone> oh man those videos are awesome
00:39:00 <pumpkin> Gracenotes: can't remember the url
00:39:04 <Gracenotes> @unpl (a .) . b
00:39:04 <lambdabot> (\ f i -> a (b f i))
00:39:21 <chrisdone> in that I don't know any of the maths except random bits that I picked up from haskell's theory
00:39:23 <Cale> The ones on monads are also fairly elementary, as well as limits and colimits.
00:39:31 <mmorrow> @pl \x y -> g (f x y)
00:39:31 <lambdabot> (g .) . f
00:39:35 <mmorrow> @pl \x y z -> g (f x y z)
00:39:36 <lambdabot> ((g .) .) . f
00:39:39 <mmorrow> @pl \x y z a -> g (f x y z a)
00:39:40 <lambdabot> (((g .) .) .) . f
00:39:42 <mmorrow> ...
00:39:48 <pumpkin> Cale: this is all too concrete for me, I need more abstraction!
00:39:50 <Cale> The limit and colimit ones start with initial and terminal objects, so they actually may be a good starting point.
00:39:52 <chrisdone> pacman train
00:39:57 <Cale> pumpkin: :)
00:40:13 <mmorrow> chrisdone: heh
00:40:23 <Gracenotes> @pl \a b c d e f g h i j k l m n o p -> g (a b c d e f g h i j k l m n o p)
00:40:24 <lambdabot> (((((ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)) .) .) .) .) .)
00:40:32 <pumpkin> lol
00:40:40 <mmorrow> @pl \a b c d e f g h i j k l m n o p -> g (f a b c d e f g h i j k l m n o p)
00:40:40 <swc|666> (@Y@)
00:40:42 <lambdabot> (((((ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)) .) .) .) .) .) . flip flip id . ((flip . ((flip . ((flip . (ap .) . flip) .) . flip) .) . flip) .) . flip . flip id
00:40:44 <Cale> Categories are monads in the 2-category Span(Set)?
00:40:47 <chrisdone> dvorak: typing up to `p' is easy™
00:40:55 <mmorrow> um, i think you rearranged some of the args
00:41:04 <Cale> (okay, small categories)
00:41:06 <Gracenotes> yes, me too
00:41:13 <Gracenotes> these must be something out of order...
00:41:15 <Gracenotes> 09:33 < mmorrow> f =<< m    ===   join (fmap f m)
00:41:21 <mmorrow> oh, the g's and f's overlapped
00:41:24 <pumpkin> Cale: :o
00:41:28 <Gracenotes> oops, sorry about that
00:41:30 <mmorrow> @pl \a b c d e f g h i j k l m n o p -> z (y a b c d e f g h i j k l m n o p)
00:41:31 <Gracenotes> rawr.
00:41:31 <lambdabot> (((((((((((((((z .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . y
00:41:46 <Cale> Of course, for that you need to be able to say what a monad *in* a 2-category is.
00:41:55 <Gracenotes> was going a nice little excursion into my own ghci...
00:41:57 <mmorrow> for a second there i was like whoahuhtf!!?
00:42:01 <Gracenotes> *doing
00:42:13 <Gracenotes> mmorrow: what did I screw up?
00:42:23 <Cale> It's the obvious generalisation from the definition of a monad on a category in the 2-category of categories, functors and natural transformations though.
00:42:26 <mmorrow> the 'g' and 'f' overlapped with the args
00:42:39 <mmorrow> @pl \x y z -> g (f x y z)
00:42:39 <lambdabot> ((g .) .) . f
00:42:40 <Gracenotes> oh! funny.
00:42:43 <mmorrow> heh
00:42:59 <Cale> pumpkin: and then once you're talking about 2-categories, the obvious place to go from there is higher-dimensional category theory
00:43:06 <pumpkin> :o
00:43:28 <Cale> Which incidentally, is what Eugenia Cheng, (the girl in the Catsters videos) studies.
00:44:30 <pumpkin> you know her?
00:44:42 <Cale> Only from the videos and her website.
00:44:52 <Gracenotes> it seems pretty captivating so far. Although I'm having a minute sort of trouble keeping up with her accent.
00:44:52 <Cale> She has good notes.
00:45:39 <pumpkin> what's odd about her accent?
00:46:11 <Gracenotes> hm... nothing as far as I can tell... perhaps it's just the speed of talking combined with the lower quality
00:46:16 <pumpkin> :)
00:46:19 <Gracenotes> *switches to HQ*
00:46:34 <Gracenotes> the vowels aren't how I'd pronounce them, but then again, is anyone's?
00:46:52 <Gracenotes> hardly the point though. at all.
00:47:30 <jsn> i actually started trying to learn category theory from those videos, but it was pretty confusing
00:47:44 <jsn> maybe i should not have started with the "monads" videos
00:47:49 <Cale> Well, they're not in a great order...
00:48:00 <jsn> yeah, really
00:48:04 <Cale> and there's some foundational stuff which they haven't covered yet
00:48:25 <Gracenotes> there's also a book, Topoi: The Categorial Analysis of Logic
00:48:26 <Cale> The closest to foundational stuff they have is the playlist on limits and colimits
00:48:37 <Gracenotes> which I downloaded from Cornell, some 1980s edition
00:48:48 <Gracenotes> I'm still working through it, but it seems comprehensible so far
00:48:52 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
00:49:00 <Cale> (in case anyone still needs it ;)
00:49:21 <Cale> That book has the advantage of not requiring a ton of other mathematics knowledge.
00:49:34 <pumpkin> the first monad vid seems pretty clera so far
00:49:43 <pumpkin> clear
00:50:01 <Cale> pumpkin: You may want to actually look at the definition of a natural transformation on Wikipedia at some point.
00:50:12 <pumpkin> yeah, already done that :)
00:50:17 <Cale> ah okay :)
00:50:25 <Gracenotes> it goes from http://digital.library.cornell.edu/cache/g/o/l/gold010/0001.tifS.gif up to 567
00:50:37 <Cale> It's sort of enough to know that they're the "natural" arrows between functors, but that definition is one of the great successes of category theory.
00:50:47 <jsn> one thing it would have helped is to know what a functor even was
00:51:03 <Cale> MacLane said that he didn't invent category theory to define "functor", he did it to define "natural transformation"
00:51:09 <Gracenotes> jsn: they're arrows between categories! what could be more clear ;)
00:51:14 <Cale> hehe
00:51:30 <jsn> i had a great deal of trouble interpreting   ηT   and    Tη    for example
00:52:03 <Cale> jsn: Oh, yes, that's special notation
00:52:31 <jsn> well, it makes sense when you consider that a Functor operates differently on arrows and objects
00:52:36 <Gracenotes> http://www.catster.com/group/Columbus_catsters-292
00:53:23 <Cale> You can just regard it as the eta acting on the part which isn't covered by the T, if you get what I mean.
00:53:26 <jsn> however, i was not aware of that, and took it to be just composition in either direction
00:53:43 <jsn> isn't covered?
00:54:23 <Cale> Well, okay... a natural transformation is defined by what it does on each component, right?
00:54:47 <Cale> So if eta: F -> G, say, then eta_X: FX -> GX
00:55:29 <Cale> Then eta T: FT -> GT, and (eta T)_X: F(TX) -> G(TX)
00:55:33 <jsn> yes
00:55:34 <Gracenotes> @hoogle Functor a, Functor b => a -> b
00:55:35 <lambdabot> Parse error:
00:55:35 <lambdabot>   --count=20 "Functor a, Functor b => a -> b"
00:55:35 <lambdabot>                       ^
00:55:43 <Gracenotes> mehs.
00:55:59 <Cale> (eta T)_X = eta_(T X)
00:56:10 <Cale> and then you have:
00:56:22 <Cale> T eta: TF -> TG
00:56:45 <pumpkin> I hate this kind of pdf: http://cheng.staff.shef.ac.uk/misc/4000.pdf
00:56:54 <Cale> so (T eta)_X: T(FX) -> T(GX)
00:57:06 <pumpkin> although the content is interesting, it's slow to render and the text isn't hinted on mac os
00:57:11 <Cale> and we take (T eta)_X = T (eta_X)
00:57:35 <Cale> But the definition is guided by the type, as you can see there.
00:58:01 <Cale> You just want the natural transformation to act on the part of the composite functor which isn't T :)
00:58:14 <Gracenotes> oh, I know someone who goes to Sheffield
00:58:23 <jsn> okay
00:59:02 <jsn> Gracenotes: maybe you can get some free theorems
00:59:08 <Draconx> pumpkin, xpdf has no trouble rendering that quickly.
00:59:27 <lucca> pumpkin: looks like TeX
00:59:27 <pumpkin> Draconx: I dunno, something about it is different from most pdf papers I read
00:59:36 <Cale> pumpkin: I had a surprising amount of problems with pdfs and postscript files on Mac OS X.
00:59:37 <pumpkin> lucca: I render TeX all the time just fine on mac os :)
00:59:43 <lucca> likewise :p
00:59:54 <lucca> just saying what it Looks like, not what it acts like
01:00:06 <Gracenotes> jsn: heh :)
01:00:08 <dfranke`> try TeXShop.
01:00:28 <pumpkin> I think it must've been rendered to something other than text when converting to pdf
01:00:32 <pumpkin> which is why the text isn't hinted
01:00:33 <Cale> It might possibly have been created with pstopdf or something.
01:01:19 <Cale> pumpkin: Well, the text is just a bunch of curves, is it actually possible to hint at that point?
01:01:47 <Cale> (Does PDF even store hinting information?)
01:01:58 <pumpkin> nope, but if it represents the text as text, the OS can do that
01:02:04 <pumpkin> (if it keeps font info)
01:02:06 <jeffz`> pumpkin: that pdf works fine here with kpdf on linux, the metadata says it was created with dvi2ps and run through acrobat distiller
01:02:30 <pumpkin> if it gets reduced to a set of curves then that's why it looks different in this case :)
01:02:48 <Cale> The font isn't one which you'd have on your system.
01:02:53 <pumpkin> jeffz`: it works fine here too, but is a little slower at fast page scrolling than most PDFs I read, and the text isn't pretty
01:02:53 <Cale> It's computer modern roman.
01:03:08 <pumpkin> Cale: yeah, but pdflatex does it right somehow :P
01:03:12 <Cale> And that doesn't have hinting, it's a metafont font.
01:03:17 <pumpkin> Cale: and I actually do have that as a ttf ;)
01:04:48 <Cale> Yeah, but it probably wouldn't try to do that... since the ttf was probably rendered at one point size, and the nice thing about CMR and friends is that they do the paper equivalent of hinting -- at small point sizes the characters become rounder and fatter.
01:04:58 <pumpkin> yup
01:05:28 <pumpkin> but either way, pdflatex does something right which gives me hinting and pretty text in the pdfs I make
01:06:32 <pumpkin> and xetex makes them even prettier ;)
01:06:55 <Draconx> I've found pdflatex output to look pretty bad on screen, but good when printed.
01:09:35 <Beelsebob> Draconx: odd, I find that pdflatex output is pretty much the only latex output that looks good when rendered by my mac
01:09:41 <pumpkin> yup
01:09:49 <Beelsebob> anything else ends up wierd and blurry for some reason
01:10:05 <pumpkin> Beelsebob: that's what I'm talking about, like that pdf I linked to above
01:11:31 <Draconx> Beelsebob, well, it looks _okay_, but there are noticeable defects.
01:11:35 <Beelsebob> pumpkin: yeh, that one renders perfectly on screen for me
01:11:44 <pumpkin> Beelsebob: it doesn't look blurry? :o
01:11:48 <Beelsebob> nope
01:12:07 <Draconx> which makes sense, given that print resolution is typically significantly higher than most computer displays.
01:12:18 <Beelsebob> Draconx: not really
01:12:29 <Beelsebob> usually the artifacting is way more severe than it needs be on a display
01:12:37 <jsn> conal: do you see any relationship between the notion of files as behaviours and the iteratee/enumerator approach to file IO ?
01:12:38 <Beelsebob> but that one that pumpkin linked is 100% fine
01:13:35 <Draconx> Beelsebob, hm, I see all the usual problems with it, though I haven't seen what it looks like in print.
01:14:21 <Draconx> stroke widths on glyphs tend to be inconsistent due to antialiasing.
01:14:41 <basvandijk> Hello, I'm creating a patch for the Monad Template Library (mtl) that adds Applicative instances for all types. However I have a bit of a dilemma regarding the transformer monads. In short: should I have "instance Applicative m => Applicative (ListT m)" or should I have "instance Monad m => Applicative (ListT m)". See: http://hpaste.org/13203
01:15:54 <basvandijk> The problem is if I have "instance Applicative m => Applicative (ListT m)" I have to modify the Functor instance and write 'fmap = liftA' which may be less efficient
01:20:38 <Beelsebob> ditto -- but occasionally I get pdfs that OS X's rip just goes crazy at
01:27:48 <pumpkin> I have an answer for http://projecteuler.net/index.php?section=problems&id=125 that I'm reasonably sure is correct but it isn't accepting it
01:27:49 <pumpkin> :(
01:29:41 <pumpkin> oh there we go
01:29:45 <pumpkin> minor mistake :P
01:30:30 <pumpkin> up to 64 problems!
01:30:31 <pumpkin> whee
01:31:11 <Cale> basvandijk: I think you can generally expect things that small to inline, no?
01:31:44 <Cale> basvandijk: In any event, ListT isn't actually a monad transformer, and probably shouldn't be there (there should be a properly functioning nondeterminism monad transformer)
01:36:28 <basvandijk> Cale: yes probably. Then I think I will go for "instance Applicative m => Applicative (ListT m)"
01:39:37 <apsod> pl (\x y z -> f x $ g y z)
01:42:00 <swc|666> DCC CHAT GETMEANOTHERFSCKINBREWSKITORQUITTHECHANPLZKTHXBAI
01:42:11 <swc|666> ...
01:44:24 <Gracenotes> no, no one
01:44:30 <Gracenotes> that's how much you fail
01:46:02 <vininim_> @pl (\x y z -> f x $ g y z)
01:46:03 <lambdabot> (. g) . (.) . f
01:47:11 <pumpkin> whee, got another one
01:47:15 <pumpkin> using Omega once more!
01:47:19 <pumpkin> it's so useful
01:48:56 * basvandijk back in 10 min.
01:52:38 <pumpkin> if I wanted to generate all rotations of a list
01:52:54 <pumpkin> is there an elegant way to do that?
01:53:31 <pumpkin> [1,2,3,4] goes to [[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]]
01:54:55 <pumpkin> here's a really ugly one
01:54:55 <pumpkin> > take 4 $ map (take 4 . (++ [1,2,3,4])) $ tails [1,2,3,4]
01:54:57 <lambdabot>   [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]
01:55:36 <twb> pumpkin: google for "permutations" ?
01:55:52 <pumpkin> , permutations [1..4]
01:55:55 <lunabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3...
01:56:02 <pumpkin> that's more than I want
01:56:10 <pumpkin> you saying to filter it down?
01:56:19 <twb> I always get them mixed up
01:56:33 <twb> There are two kinds: one that cares about the order and one that doesn't.
01:56:40 <twb> I'm thinking of the latter.
01:56:54 <twb> ,combinations [1..3]
01:56:56 <lunabot>  luna: Not in scope: `combinations'
01:56:58 <twb> Hmph.
01:57:22 <pumpkin> > zipWith (++) (tails [1,2,3,4]) (inits [1,2,3,4])
01:57:23 <lambdabot>   [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
01:57:26 <pumpkin> that's a bit better
02:00:23 <pumpkin> whee, got problem 35 too
02:04:29 <Gracenotes> > take 4 $ unfoldr (\a -> Just (a, tail a ++ [head a])) ([1,2,3,4]) -- pumpkin
02:04:31 <lambdabot>   [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]
02:04:35 <Gracenotes> not terribly elegant :)
02:04:40 <pumpkin> :)
02:04:47 <pumpkin> not too ugly though
02:04:52 <pumpkin> I prefer my zipwith though
02:05:02 <Gracenotes> it seems very straightforward
02:05:29 <Gracenotes> well, disregarding the implemntation, and even considering that it's nice
02:07:27 <Gracenotes> a more efficient implementation would probably use part of one rotation to build up the next rotation
02:07:31 <pumpkin> yeah
02:07:49 <pumpkin> seems like you could make it out of an iterate
02:07:50 <Gracenotes> it might be easier to do it in reverse
02:08:15 <pumpkin> > iterate (\(x:xs) -> xs ++ [x]) [1,2,3,4]
02:08:19 <lambdabot>   [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1...
02:08:26 <Gracenotes> @src iterate
02:08:27 <lambdabot> iterate f x =  x : iterate f (f x)
02:08:54 <Gracenotes> ++ does go through the entire xs though
02:09:08 <pumpkin> yup
02:09:23 <pumpkin> can't really get around it though
02:09:29 <pumpkin> even in reverse, you've gotta get the last element
02:10:08 <Gracenotes> well... you could reverse the entire list once
02:10:20 <Gracenotes> which gets the elements as needed (it's lazily)
02:10:29 <pumpkin> hmm
02:10:46 <Gracenotes> *thinks*
02:14:24 <oklopol> > read "[1,2,3]"
02:14:26 <lambdabot>   * Exception: Prelude.read: no parse
02:14:52 <oklopol> > read "[1,2,3]" :: [Int]
02:14:54 <lambdabot>   [1,2,3]
02:18:15 <pumpkin> I hate it when I have an "almost right" answer on project euler
02:18:19 <Cale> swc|666: picking on people with broken routers is old, and not cool. Don't do it.
02:21:49 <Gracenotes> pumpkin: doing it efficiently is more difficult than thought ;)
02:21:57 <pumpkin> Gracenotes: the rotation?
02:22:00 <Gracenotes> yeah
02:22:17 <Gracenotes> Euler has almost right now?
02:22:41 <Gracenotes> which gets the elements as needed (it's lazily)?
02:22:51 <Gracenotes> damn it, accidentally scroll up
02:22:58 <Gracenotes> (thanks laptop keyboard)
02:23:01 <pumpkin> Gracenotes: no, I know it's almost right, but not quite (but I've since fixed it)
02:23:08 <pumpkin> I had an off-by-two :P
02:23:20 <Gracenotes> ah, okay. What problem was the rotations for, if any?
02:23:35 <pumpkin> hmm
02:23:38 <pumpkin> let me see
02:23:52 <pumpkin> http://projecteuler.net/index.php?section=problems&id=35
02:24:10 <pumpkin> that one took a couple of seconds once I got it :)
02:24:23 <Gracenotes> ah, you brute forced it?
02:24:30 <pumpkin> nah, did it a little more smartly
02:24:55 <Gracenotes> you mean checking if prime first, then checking first rotation prime first, etc.?
02:25:04 <Gracenotes> still a sort of brute forcing :P
02:25:11 <pumpkin> nah :P
02:25:19 <pumpkin> I mean, it took a couple of seconds
02:25:24 <pumpkin> it can't have been that brute :P
02:25:44 <pumpkin> very slightly brute
02:37:41 <jbjohns> Hi, anyone on?  I have a math question for a program I'm writing.
02:37:48 <dcoutts> @yarr!
02:37:48 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
02:37:58 <jbjohns> :)
02:38:06 <Gracenotes> pumpkin: heh, enough time to spend on the problem
02:38:09 <dcoutts> yay, my copy of RWH (that I pre-ordered 6 months ago) has arrived!!
02:38:21 <pumpkin> :)
02:38:25 <Gracenotes> I've almost worked out a numerical rotation -- which wouldn't quite work for numbers like 34560, or with 0's at the end
02:38:33 <Gracenotes> but, anyway, time to do other stuffs
02:38:57 <Gracenotes> after all strings are slowish
02:39:30 <pumpkin> yup
02:39:34 <jbjohns> I'm trying to convert an srt file.  The one I have seems to have the right text but it drifts a lot.  It starts out 2 seconds, 710 milliseconds behind.  1 hour, 41 minutes and 15 seconds later it's behind 3 minutes, 36 seconds
02:40:33 <jbjohns> so there's an obvious curve I guess, but lacking a strong math background I'm not sure how to uncover it.  My current method was just to write a program to bump up all the times, but this leaves me having to change basically every subtitle
02:41:16 <jbjohns> (e.g. current method:  start at sub 1 and push all back 2 seconds.  Now, start at sub 2 and push all back n seconds, etc.)
02:41:36 <Dynetrekk> hi guys! I'm a total newbie here, so bear with me. how do you read a text file for numbers and put them into some nice lists/arrays? say, I want to read a text file wit 3 columns of numbers, ignoring some lines starting with  '#'...
02:41:52 <pumpkin> Gracenotes: are you doing project euler?
02:42:27 <Dynetrekk> jbjohns: is the drift linear? you could easily do a linear fit and calculate real time as a function of stored time?
02:43:10 <jbjohns> Dynetrekk: not sure.  Let me pick a subtitle around the middle and see if you can predict how far off it is
02:44:22 <Dynetrekk_> jbjohns: I'm not sure if I can do that, but anyway - if it's a straight line, you can just plot it - right?
02:44:34 <Dynetrekk_> (my network is unstable, unfortunately)
02:44:49 <jbjohns> plot it, yea ok, I'll try that
02:44:53 <Dynetrekk_> jbjohns:  and then find slope + constant and voila, a formula...
02:45:10 <Dynetrekk_> jbjohns: surprisingly often, a good idea... 1. step of data analysis: look at the data :)
02:45:46 <jbjohns> Yea, I grabbed some figured but couldn't think of a way to make it clear.  Plotting... why didn't I think of that. :)  Thanks
02:45:56 <jbjohns> grabbed some data*
02:46:52 <Dynetrekk_> jbjohns: hehe, who knows why. plotting is usually nice, you quickly see odd behavior. and, you see if it _is_ a simple curve, as you put it.
02:47:46 <Gracenotes> pumpkin: nope
02:48:28 <Gracenotes> I'm watching people do it in (=>2) places, though :)
02:48:36 <pumpkin> :)
02:49:20 <Dynetrekk_> anyone care to give some hints on basic file IO (and a litte string processing) ?
02:49:41 <pumpkin> Dynetrekk_: in your case
02:50:01 <pumpkin> the simplest thing is probably to read into a string, ask for lines on that string (will give you a list of strings, one for each line)
02:50:17 <pumpkin> then check if the head of each of those strings is a '#'
02:50:19 <Dynetrekk_> pumpkin:  sounds reasonable, I thought of something similar. now, how to do that?
02:50:26 <Dynetrekk_> pumpkin:  yeah, something like that
02:50:48 <pumpkin> well, readFile will give you an IO String
02:50:56 <Dynetrekk_> pumpkin: I got that
02:50:57 <pumpkin> so do contents <- readFile "filename"
02:51:07 <Dynetrekk_> pumpkin:  exactly
02:51:21 <pumpkin> then filter ((/= '#') . head) $ lines contents
02:51:59 <pumpkin> and take it up to: map (read . words) . filter ((/= '#') . head) $ lines contents [[Int]]
02:52:22 <pumpkin> whoops
02:52:26 <pumpkin> there's supposed to be a :: there
02:52:53 <blueonyx> how can i map a list of functions over a single value?
02:53:07 <pumpkin> map ($ value) [func1, func2, ...]
02:53:13 <blueonyx> oh nice
02:53:19 <pumpkin> there are also fancier ways of doing it
02:53:37 <Dynetrekk_> pumpkin: this will do exactly what? what does map (read . words) mean? map should put the list as its 1. argument or something?
02:54:40 <pumpkin> Dynetrekk_: it breaks the string into lines, filters out ones that start with '#', then breaks the others into words (space-separated), and parses the "words" as Ints
02:54:44 <pumpkin> > ap [(+1), (+2), (+3)] [4]
02:54:45 <lambdabot>   [5,6,7]
02:55:01 <pumpkin> blueonyx: ^^
02:55:28 <Dynetrekk_> pumpkin: I see, I just haven't seen the dot in map (read . words) syntax before
02:55:39 <Dynetrekk_> what do the dots do anyway? :P
02:55:42 <pumpkin> it composes
02:55:46 <pumpkin> but that's wrong actually
02:55:47 <pumpkin> just realized :P
02:55:48 <Dynetrekk_> composes? music?
02:55:56 <pumpkin> that should be map read . words I think
02:56:10 <Dynetrekk_> I'll try..
02:56:12 <pumpkin> Dynetrekk_: function composition (f . g) x = f (g x)
02:56:34 <Dynetrekk_> pumpkin: ah, like in math? :)
02:56:37 <pumpkin> yup
02:56:46 <pumpkin> you'll see people using the dot all the time
02:56:57 <pumpkin> @src (.)
02:56:57 <lambdabot> (f . g) x = f (g x)
02:57:01 <pumpkin> hah
02:57:03 <Dynetrekk_> so words is a function to "split" on whitespace, like python's split or something similar
02:57:39 <pumpkin> yup, you can try it out
02:57:50 <pumpkin> > words "hello Dynetrekk, how are you?"
02:57:51 <lambdabot>   ["hello","Dynetrekk,","how","are","you?"]
02:57:57 <Dynetrekk_> fun
02:58:02 <pumpkin> it's pretty naive as you can see
02:58:15 <Dynetrekk_> > words "I am fine but \n this is a new line"
02:58:17 <lambdabot>   ["I","am","fine","but","this","is","a","new","line"]
02:58:28 <pumpkin> @src words
02:58:29 <lambdabot> words s = case dropWhile isSpace s of
02:58:29 <lambdabot>     "" -> []
02:58:29 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
02:58:31 <Dynetrekk_> naive is nice, at least right now
02:58:38 <pumpkin> @src isSpace
02:58:38 <lambdabot> Source not found. Take a stress pill and think things over.
02:58:46 <pumpkin> anyway, it's just breaking it up on whitespace :)
02:58:50 <Dynetrekk_> I see
02:58:58 <Dynetrekk_> including tabs & newline
02:59:15 <pumpkin> yup
02:59:20 <pumpkin> > isSpace '\t'
02:59:21 <lambdabot>   True
02:59:27 <Dynetrekk_> so the map actually takes the function (read . words . filter)
02:59:48 <pumpkin> nope
03:00:06 <Dynetrekk_> ah no, you supplied filter's first argument?
03:00:07 <pumpkin> it just takes read . words (it's why I used the parens there, to separate it)
03:00:14 <Dynetrekk_> hm anyway, it doesn't work
03:00:15 <pumpkin> it should be map read . words though
03:00:16 <pumpkin> yeah
03:00:36 <pumpkin> you're using the map read . words version?
03:00:46 <Dynetrekk_> yep
03:00:48 <Dynetrekk_> I can paste
03:00:51 <pumpkin> sure, please
03:01:30 <Dynetrekk_> http://hpaste.org/13204
03:02:19 <pumpkin> oh, it needs to be
03:02:19 <pumpkin> map (map read . words) . filter ...
03:04:54 <pumpkin> Dynetrekk_: any luck
03:04:55 <pumpkin> ?
03:05:10 <Dynetrekk_> pumpkin: 2 min, phone call
03:07:32 <Dynetrekk_> http://hpaste.org/13204#a1
03:08:40 <pumpkin> oh, the :: is interfering
03:08:51 <pumpkin> write it as print (map (map read . words) . filter ((/= '#') . head) $ lines contents :: [[Int]])
03:08:53 <pumpkin> although it's ugly
03:08:56 <pumpkin> but it should work, for now
03:09:21 <pumpkin> it's trying to make print return an [[Int]], which it clearly can'y
03:09:22 <pumpkin> can't
03:11:00 <Dynetrekk_> [[*** Exception: Prelude.read: no parse
03:11:13 <pumpkin> remind me of the format you're reading?
03:11:18 <Dynetrekk_> text?
03:11:25 <Dynetrekk_> possibly utf-8..
03:11:29 <pumpkin> I mean
03:11:37 <pumpkin> what does the file look like?
03:11:40 <pumpkin> can you paste a subset of it?
03:12:09 <Dynetrekk_> http://hpaste.org/13204#a2
03:12:21 <pumpkin> oh, it's a float
03:12:33 <pumpkin> replace [[Int]] with [[Double]] or [[Float]]
03:13:34 <pumpkin> I thought you had a file full of ints :)
03:13:41 <Dynetrekk_> ah
03:14:59 <Dynetrekk> *** Exception: Prelude.head: empty list <- have to check for this too I guess
03:15:16 <pumpkin> yup :)
03:16:27 <pumpkin> simplest way to fix that is to filter once before that with (not . null)
03:16:43 <pumpkin> but you may want to reorganize the whole thing to be more generally elegant
03:17:57 <Dynetrekk> I see
03:18:03 <Dynetrekk> indeed
03:18:08 <Dynetrekk> @src null
03:18:08 <lambdabot> null []     = True
03:18:08 <lambdabot> null (_:_)  = False
03:18:28 <Dynetrekk> @src not
03:18:28 <lambdabot> not True   =  False
03:18:28 <lambdabot> not False  =  True
03:18:57 <pumpkin> :)
03:19:02 <Gracenotes> well, off to bed, with my laptop humming quietly beside me
03:19:25 <Dynetrekk> allright... I guess I should write some filter-function separately to avoid the line becoming 200 chars
03:19:37 <pumpkin> :t not . null
03:19:39 <lambdabot> forall a. [a] -> Bool
03:19:48 <pumpkin> > not . null $ []
03:19:50 <lambdabot>   False
03:19:51 <pumpkin> > not . null $ [1]
03:19:52 <lambdabot>   True
03:20:08 <Dynetrekk> > null 3.14
03:20:09 <lambdabot>       No instance for (Fractional [a])
03:20:09 <lambdabot>        arising from the literal `3.14'...
03:20:21 <pumpkin> :t null
03:20:22 <lambdabot> forall a. [a] -> Bool
03:20:31 <Gracenotes_away> @p
03:20:31 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
03:20:31 <lambdabot> v
03:20:32 <Dynetrekk> > null [3.14]
03:20:34 <lambdabot>   False
03:22:49 <Dynetrekk> @src read
03:22:49 <lambdabot> read s = either error id (readEither s)
03:22:57 <Dynetrekk> :t read
03:22:58 <lambdabot> forall a. (Read a) => String -> a
03:23:41 <pumpkin> :t readEither
03:23:43 <lambdabot> Not in scope: `readEither'
03:25:00 <Dynetrekk> :t if
03:25:01 <lambdabot> parse error (possibly incorrect indentation)
03:25:02 <Dynetrekk> @src if
03:25:02 <lambdabot> Source not found. stty: unknown mode: doofus
03:28:26 <Dynetrekk> http://hpaste.org/13204#a3  <- how can this be wrong?
03:32:05 <Beelsebob> Dynetrekk: 1) what types do you expect them to have?
03:32:38 <Dynetrekk> Beelsebob: hm... the filterlines function should take a list of strings as argument
03:32:44 <Beelsebob> the most obvious thing I can see though is that filterlines doesn't return anything in a monad -- so you shouldn't be using <-
03:32:56 <Dynetrekk> and give back the list, minus the ones started with # or empty ones
03:33:08 <pumpkin> also, wordList is the output of a "read"
03:33:11 <pumpkin> without a constricted type
03:33:24 <Beelsebob> why not just use filter?
03:33:26 <pumpkin> *constrained
03:33:28 <Dynetrekk> heh, but how do you use your precious pure functions then? if it's all in a do...
03:33:41 <Dynetrekk> filter? hm, good idea, but it gets long and complicated; at least I think so
03:33:43 <Beelsebob> Dynetrekk: let a = f x
03:34:00 <Beelsebob> as long and complicated as 9 lines of code?
03:34:33 <Dynetrekk> sorry, I didn't quite get that.... okay, you declare a to be a function, but...
03:35:59 <Beelsebob> http://hpaste.org/13204#a4 <-- what's wrong with this?
03:36:31 <Beelsebob> oops, missed a lines in there
03:36:46 <Beelsebob> http://hpaste.org/13204#a5 <-- this
03:38:09 <Dynetrekk> let me check
03:38:23 <Dynetrekk> first of all, could not find module...
03:38:43 <Beelsebob> it's in the InfixApplicative package -- though you could just use <$> and <*> instead of <^ and ^>
03:38:46 <Dynetrekk> dielectric.hs:7:7:
03:38:46 <Dynetrekk>     Could not find module `Control.Applicative.Infix':
03:39:00 <Dynetrekk> sorry, but this is slightly over my head I think
03:39:15 <Dynetrekk> it must be, I spent more than an hour trying to read a few floats :P
03:39:27 <Dynetrekk> @src isWhiteSpace
03:39:27 <lambdabot> Source not found. It can only be attributed to human error.
03:39:39 <Dynetrekk> :t isWhiteSpace
03:39:40 <lambdabot> Not in scope: `isWhiteSpace'
03:39:49 <Beelsebob> @hoogle Char -> Bool
03:39:49 <lambdabot> Data.Char isAlpha :: Char -> Bool
03:39:49 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
03:39:49 <lambdabot> Data.Char isAscii :: Char -> Bool
03:39:55 <Beelsebob> @hoogle isSpace
03:39:55 <lambdabot> Data.Char isSpace :: Char -> Bool
03:39:55 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
03:39:55 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
03:39:57 <Beelsebob> that's the one
03:40:02 <Beelsebob> isSpace, not isWhitespace
03:40:15 <Dynetrekk> Beelsebob: yeah, seen that one before
03:41:00 <Beelsebob> http://hpaste.org/13204#a6 <-- rather neater btw
03:41:24 <Beelsebob> oh, that one's missing a show though >.<
03:41:29 <Dynetrekk> :P
03:41:38 <Beelsebob> http://hpaste.org/13204#a7 <-- better
03:42:29 <Dynetrekk> Beelsebob: still using the infix module?
03:42:56 <Beelsebob> yep, I can remove that if you like
03:43:20 <Beelsebob> http://hpaste.org/13204#a8 -- there you go
03:43:32 <Dynetrekk> Beelsebob: I'd actually like to learn how to think, if I wanted to read a simple text file
03:43:38 <Dynetrekk> it seems slightly impossible
03:43:55 <pumpkin> impossible!
03:44:02 <pumpkin> @faq can haskell make the impossible possible?
03:44:02 <lambdabot> The answer is: Yes! Haskell can do that.
03:44:05 <Beelsebob> well, the first thing you should learn from this, is get out of the IO monad as fast as you can
03:44:06 <pumpkin> I thought so
03:44:27 <Beelsebob> in this case -- you can get out of it faster than you were, by producing a string concatonated together, to be printed once
03:44:56 <Beelsebob> and the second thing you should learn is higher order functions are there because someone already did the work for you
03:45:12 <Beelsebob> the word filter is a lot more simple than reinventing it every time you want to filter a list
03:45:27 <pumpkin> and more readable if you have a lot of code
03:45:38 <Beelsebob> yep
03:47:01 <Dynetrekk_> Beelsebob: yeah, sure... how do you define higher order functions then?
03:47:14 <pumpkin> Dynetrekk_: map, filter, foldl/r, and so on
03:47:19 <Dynetrekk_> Beelsebob: and it still doesn't work. .hs:19:54: Not in scope: `isSpace'
03:47:21 <pumpkin> functions that apply other functions to data
03:47:39 <Beelsebob> well, in yoru example, you used filterlines, yeh?
03:47:39 <Dynetrekk_> pumpkin: okay, I kinda like that about haskell... that's why I bother trying to learn how to read from file :)
03:47:49 <Beelsebob> lets base a definition of filter on it
03:48:10 <pumpkin> Dynetrekk_: sorry, I just gave you a load of code without much of an explanation or justification :)
03:48:11 <Beelsebob> the base case is very similar -- if we want to filter an empty list on any predicate, we get the empty list back
03:48:14 <Dynetrekk_> Beelsebob: I see that your filter isCommentOrBlank is an example of what you're getting at
03:48:19 <Beelsebob> filter _ [] = []
03:48:23 <Dynetrekk_> Beelsebob: sure
03:48:36 <Dynetrekk_> @src filter
03:48:36 <lambdabot> filter _ []     = []
03:48:36 <lambdabot> filter p (x:xs)
03:48:36 <lambdabot>     | p x       = x : filter p xs
03:48:36 <lambdabot>     | otherwise = filter p xs
03:48:38 <Beelsebob> if we want to filter a list that's more complex, we run the predicate on the first element...
03:48:50 <Beelsebob> yep -- so there you go -- there's how you define higher order functions
03:49:16 <Beelsebob> @hoogle isSpace
03:49:16 <lambdabot> Data.Char isSpace :: Char -> Bool
03:49:16 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
03:49:16 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
03:49:21 <Beelsebob> ah, it's in Data.Char
03:49:24 <Dynetrekk_> allright... I actually did a little haskell before, and had little problems as long as I stayed out of the pesky IO monad
03:49:41 <Dynetrekk_> @hoogle isWhiteSpace
03:49:41 <lambdabot> No results found
03:49:46 <Beelsebob> yep -- IO isn't so fun
03:49:56 <Beelsebob> it's also ugly
03:50:03 <Beelsebob> so yeh -- try and stay out of it
03:50:05 <pumpkin> they make it deliberately unfun and ugly to keep us away from it as much as possible :P
03:50:08 <pumpkin> it's a trap!
03:50:10 <pumpkin>  / plot
03:50:11 <Beelsebob> haha
03:50:25 <Dynetrekk_> Beelsebob: no, I agree. I am more mathematically oriented, so I like the funky funktions and all that, but the IO stuff kinda stops haskell from being useful - at least yet :P
03:50:46 <Beelsebob> Dynetrekk_: in case you're wondering what's going on in the last line there...
03:50:58 <Beelsebob> (=='#') is a function that tests if a character is a hash
03:51:01 <Dynetrekk_> Beelsebob: anyway, it _still_ fails: *** Exception: Prelude.head: empty list
03:51:03 <pumpkin> @src otherwise
03:51:03 <lambdabot> otherwise = True
03:51:05 <pumpkin> :P
03:51:11 <Beelsebob> oh -- sec
03:51:35 <Dynetrekk_> or (== '#') (isEmpty) or something?...
03:52:22 <Beelsebob> http://hpaste.org/13204#a10
03:52:29 <Beelsebob> so yeh -- it was baulking on empty lines
03:52:34 <Beelsebob> grabbing the head from them
03:53:00 <Dynetrekk_> wow, I almost understand this
03:53:11 <pumpkin> Cale's category theory book is remarkably clear
03:53:21 <Beelsebob> so Dynetrekk_ the second last line is obvious
03:53:30 <Dynetrekk_> indeed
03:53:32 <Beelsebob> the last one is true if...
03:53:42 <Dynetrekk_> but, what if the line contains ten whitespace chars
03:53:43 <Beelsebob> either all the things in the list xs are spaces
03:53:53 <Dynetrekk_> ah
03:53:53 <Beelsebob> > isSpace ' '
03:53:55 <lambdabot>   True
03:53:59 <Beelsebob> > all isSpace "         "
03:54:00 <lambdabot>   True
03:54:07 <Dynetrekk_> @src all
03:54:08 <lambdabot> all p =  and . map p
03:54:10 <Dynetrekk_> :t all
03:54:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:54:13 <Beelsebob> > all isSpace "       monkies jam and spam"
03:54:14 <lambdabot>   False
03:55:19 <Beelsebob> > (\x -> (all isSpace x) || (head x == '#')) "#     monkies jam and spam"
03:55:20 <lambdabot>   True
03:55:23 <Dynetrekk_> Beelsebob: so "all" just chews over the list and if they're not all true, the result is false
03:55:36 <Beelsebob> Dynetrekk_: exactly
03:55:43 <Beelsebob> it applies the predicate to everything
03:55:46 <Dynetrekk_> nicely higher order
03:55:50 <Beelsebob> and makes sure *all* the applications are true
03:55:56 <Beelsebob> it's sister function is any
03:55:59 <Dynetrekk_> the predicate is in this case isSpace, and is a function
03:56:10 <Beelsebob> (which applies the predicate to everything and checks that at least one is true)
03:56:13 <Dynetrekk_> Beelsebob: which is then the "multi-or" (if all is "multi-and")
03:56:18 <Dynetrekk_> right
03:56:27 <Beelsebob> yep, exactly
03:56:39 <Dynetrekk_> and || is just "C" for logical or
03:56:46 <Beelsebob> and yeh -- predicates are just functions that return Bools
03:56:56 <Beelsebob> yeh
03:56:56 <Beelsebob> @type all
03:56:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:56:59 <Beelsebob> @type isSpace
03:57:00 <lambdabot> Char -> Bool
03:57:06 <Beelsebob> @type all isSpace
03:57:07 <lambdabot> [Char] -> Bool
03:57:09 <Dynetrekk_> aaah. roughly :: Something -> Bool then
03:57:13 <Beelsebob> exactly
03:57:26 <Dynetrekk_> this last version I kinda understand
03:57:30 <Dynetrekk_> what is unlines?
03:57:34 <Dynetrekk_> same as lines, backwards?
03:57:36 <Beelsebob> yep
03:57:52 <Beelsebob> > unlines ["monkies", "jam", "spam"]
03:57:53 <lambdabot>   "monkies\njam\nspam\n"
03:58:44 <Dynetrekk_> allright, now I'll have to try actually getting my numbers
03:58:56 <Dynetrekk_> back in a µs
03:58:58 <Beelsebob> > let comment = unlines . map ("--" ++) . lines in comment "main = do\n  print \"jam\""
03:58:59 <lambdabot>   "--main = do\n--  print \"jam\"\n"
03:59:22 <Dynetrekk_> > putStrLn  "--main = do\n--  print \"jam\"\n"
03:59:23 <lambdabot>   * Exception: "<IO ()>"
04:00:08 <Dynetrekk_> Beelsebob: you wrote a function to comment any line in the input
04:00:19 <Beelsebob> indeed
04:00:24 <RayNbow> > say $ unlines ["monkies", "jam", "spam"]
04:00:25 <Dynetrekk_> how convenient
04:00:25 <lambdabot>   monkies
04:00:26 <lambdabot>  jam
04:00:26 <lambdabot>  spam
04:00:34 <Dynetrekk_> :t say
04:00:35 <Beelsebob> unlines . something . lines -- this is a *very* useful pattern
04:00:35 <lambdabot> forall a. String -> Sym a
04:00:42 <Dynetrekk_> @src say
04:00:42 <lambdabot> Source not found. My mind is going. I can feel it.
04:00:44 <Beelsebob> as is unwords . something . words
04:00:47 * RayNbow is abusing SimpleReflect :p
04:01:05 <RayNbow> :t x
04:01:06 <lambdabot> Expr
04:01:58 <Beelsebob> >  say $ unlines [" ", "> 5+6"]
04:02:00 <lambdabot>  > 5+6
04:02:16 <Beelsebob> >  say $ unlines ["spam", "> 5+6"]
04:02:17 <lambdabot>   spam
04:02:17 <lambdabot>  > 5+6
04:02:20 <Beelsebob> :(
04:03:17 <pumpkin> I don't quite get why join (*) works actually
04:03:26 <RayNbow> :t join
04:03:27 <Dynetrekk_> :t join
04:03:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:03:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:03:31 <pumpkin> shouldn't it expect a monad in the first param?
04:03:32 <Dynetrekk_> @src join
04:03:33 <lambdabot> join x =  x >>= id
04:03:46 <RayNbow> replace 'm' with '(e ->)'
04:03:52 <vininim> > say "lol\nleel"
04:03:54 <lambdabot>   lol
04:03:54 <lambdabot>  leel
04:04:17 <vininim> > say "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
04:04:19 <lambdabot>   1
04:04:19 <lambdabot>  2
04:04:19 <lambdabot>  3
04:04:19 <lambdabot>  4
04:04:19 <lambdabot>  5
04:04:19 <RayNbow> Beelsebob: lambdabot intentionally prefixes its output with a space :p
04:04:21 <lambdabot> [5 @more lines]
04:04:31 <vininim> too much output imo
04:04:32 <Beelsebob> RayNbow: yeh -- I wasn't sure if the following lines did
04:04:50 <pumpkin> > say "> say \"hmm\""
04:04:51 <RayNbow> and even if it didn't, I don't think it would respond to its own text
04:04:52 <lambdabot>   > say "hmm"
04:04:54 <pumpkin> :P
04:04:57 <pumpkin> :)
04:05:14 <Beelsebob> pumpkin: yeh, I would have built up to a quine if it had worked
04:05:14 <Beelsebob> >.>
04:05:16 <Beelsebob> <.<
04:05:21 <pumpkin> aw
04:05:29 <ttt--> > say ", 3"
04:05:30 <lambdabot>   , 3
04:05:36 <ttt--> , 3
04:05:53 <lunabot>  3
04:05:55 <pumpkin> ooh a mutual quine between lambdabot and lunabot would be neat
04:06:03 <pumpkin> but lunabot still doesn't like the space
04:06:11 <pumpkin> lunabot: 3
04:06:20 <vininim> say "1\n, 3"
04:06:28 <vininim> >say "1\n, 3"
04:06:44 <vininim> > say "1\n, 3"
04:06:46 <lambdabot>   1
04:06:46 <lambdabot>  , 3
04:06:49 <vininim> ok
04:07:22 <vininim> I remember someone playing with ascii terminal codes
04:07:27 <pumpkin> does lunabot specifically ignore lambdabot maybe?
04:07:47 <vininim> pumpkin: it's just the extra space
04:07:54 <pumpkin> ah
04:08:03 <pumpkin> lunabot: , 4
04:08:17 <pumpkin> no way to talk to it directly :(
04:08:22 <vininim>   , 3
04:08:38 <blueonyx> is there a type class which contains every type? so i can declare: type A = ((B -> anything),(anything -> C)) ?
04:09:27 <pumpkin> nope, but you can use existential types
04:09:40 <pumpkin> @type seq
04:09:41 <lambdabot> forall a t. a -> t -> t
04:10:56 <blueonyx> whats that?
04:11:17 <pumpkin> type definitions written like that
04:11:22 <pumpkin> containing forall
04:11:34 <pumpkin> blueonyx: but that kind of thing can be hard to work with
04:12:58 <pumpkin> blueonyx: why do you need an anything?
04:13:04 <pumpkin> could it be restricted somehow?
04:13:22 <blueonyx> i want to get to functions
04:13:26 <blueonyx> map and reduce
04:14:09 <pumpkin> :t map
04:14:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:14:13 <blueonyx> im not interested in what the map produces or what the reduce expects, since the reduce gets a list of results of maps
04:14:18 <pumpkin> you can still do that
04:14:26 <pumpkin> you just use type variables
04:14:27 <blueonyx> as type Rule = forall a. ((Species -> a), ([a] -> [(Species, ArrCoeff)]))
04:14:35 <blueonyx> nah
04:14:51 <blueonyx> mapReduce mapFun redFun = redFun . map mapFun
04:14:56 <blueonyx> thats my function
04:15:59 <pumpkin> you can put type variables into your type
04:16:04 <blueonyx> it got that type: mapReduce :: (Species -> a) -> ([a] -> [(Species, ArrCoeff)]) -> [Species] -> [(Species, ArrCoeff)]
04:16:40 <blueonyx> okay, but arent these then different types?
04:17:08 <blueonyx> so Rule Int is different from Rule (Double,Int)?
04:17:21 <blueonyx> or can i still put them together in a list?
04:17:26 <pumpkin> it's different
04:18:40 <pumpkin> also, there's a mapReduce and explanation in http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
04:18:48 <blueonyx> yea
04:19:59 <blueonyx> but there is no type which is composed of a map and a reduce function
04:20:23 <pumpkin> why should there be?
04:20:33 <pumpkin> there could be quite easily
04:20:51 <pumpkin> but the type constraints still guarantee type safety on mapReduce
04:20:56 <blueonyx> i want to name a pair of a map and a reduce function a Rule
04:21:20 <pumpkin> ah, so just give Rule two type parameters
04:21:42 <pumpkin> and say Rule Int Double for something whose mapReduce takes from [Int] to Double
04:21:42 <blueonyx> but how to create then a list of rules?
04:21:55 <pumpkin> you want a list of rules with different types?
04:22:02 <pumpkin> :o
04:22:22 <Heffalump> blueonyx: look into existential types/GADTs, but they are somewhat complicated to get to grips with
04:22:56 <blueonyx> the input and output of the whole mapReduce is everytime the same, but the difference is the intermediate type which is returned by the map function and taken by the reduce function :/
04:23:25 <blueonyx> and since the map and reduce functions are kind of input i dont want to restrict there types :/
04:23:35 <pumpkin> then you shouldn't have a problem with the Rule as I described, I think
04:23:59 <pumpkin> you can just use a type variable to constrain the intermediate type to be the same for output of map as input of reduce
04:24:17 <Heffalump> that's what the forall above will do
04:26:05 <blueonyx> Heffalump: can you give an example type declaration using forall?
04:26:36 <blueonyx> pumpkin: but i want to put rules in a list and every rule can have different intermediate types, so i cant group them in a list :/
04:26:36 <Heffalump> you (probably) can't use type
04:26:47 <Heffalump> I'd use GADT syntax personally, it's much easier to understand
04:27:07 <Heffalump> data Rule where
04:27:37 <Heffalump>    Rule :: (Species -> a) -> ([a] -> [(Species, ArrCoeff)]) -> Rule
04:27:55 <Heffalump> or something like that, I'm not sure which bits are supposed to be part of your rule and which bits are part of applying it
04:32:02 <blueonyx> okay thanks you two, i'll leave this alone then :)
04:43:55 <mm_freak> is the {-# LANGUAGE … #-} pragma standard?
04:44:44 <nanothief> I think it is the standard way to do non-standard stuff
04:45:35 <Heffalump> correct
04:48:03 <mm_freak> k, next question:  data X a where C :: X b
04:48:19 <mm_freak> this renders any two C values to be of different type, right?
04:49:15 <Heffalump> mm_freak: no
04:49:32 <Heffalump> that declaration is no different from data X a where C :: X a
04:49:55 <mm_freak> (C, C) :: (X b, X b1)
04:50:39 <Dynetrekk> @src show
04:50:39 <lambdabot> show x = shows x ""
04:52:07 <mm_freak> Heffalump: why is that?  is the 'a' meaningless in "data X a" and just used to denote the fact that there is a parameter?
04:52:23 <mm_freak> in GADTs, that is
04:55:27 <Heffalump> mm_freak: yeah
04:55:46 <Peaker> mm_freak: you could use the * -> * -> * syntax instead
04:56:20 <Peaker> data X :: * -> * where C :: X a
04:56:35 <Peaker> IMO it would be better to only allow that syntax
04:56:56 <Peaker> names that are completely ignored and do not contain all the necessary information (such as non * kinds) are just misleading
04:57:18 <Peaker> (And its better to allow less syntax for the same constructs, too)
04:57:45 <redditbot> HLint - Gives suggestions for improving your Haskell code
04:58:10 <mm_freak> ok, that makes things much clearer, thanks
05:00:11 <Dynetrekk_> http://hpaste.org/13205
05:01:12 <Dynetrekk_> anyone better?
05:03:12 <Dynetrekk_> I don't like the head $ tail thingy...
05:03:13 <luite_> Dynetrekk_: you could use a map
05:03:25 <Dynetrekk_> luite_:  in that situation?
05:03:48 <luite_> Dynetrekk_: why do you use lists anyway, if you only use two elements? can't you use a list of tuples?
05:03:49 <Dynetrekk_> luite_: hm, maybe it's possible to write funcname (x1:x2:xs) btw? then the let would go away
05:03:57 <Dynetrekk_> luite_: the lists will get longer eventually
05:04:14 <Dynetrekk_> I just don't know how to do it nicely, yet
05:04:48 <luite_> Dynetrekk_: you can use nk!!1 for your head $ tail nk
05:05:05 <Dynetrekk_> luite_:  0-based indexing?
05:05:30 <Heffalump> yes
05:05:31 <luite_> Dynetrekk_: yes, but it is slow for larger indices, as this is a linked list
05:06:00 <Dynetrekk_> luite_:  I see, maybe I'll find a better algorithm. anyway the list is small, I'm going to crunch ~1000 numbers...
05:06:14 <Peaker> this doesn't look like a map, but like a foldr?
05:06:50 <luite_> Peaker: why foldr? each element is a calculation on nk, the rest of the list is nks
05:07:06 <Peaker> oh whoops, you're right
05:07:46 <Dynetrekk_> I don't see how you could fold this, really..
05:08:03 <luite_> Dynetrekk_: you can fold anything you can map :)
05:08:29 <Dynetrekk_> luite_: I don't see how I could map it, either! :P
05:10:51 <Dynetrekk_> luite_: out of curiosity; how can you fold a map? say, map toUpper listofstrings
05:11:01 <Peaker> found a ghc bug, heh
05:11:01 <Peaker>  -Wall prints the "inferred type", but it inferred a wrong type there, in the warning
05:11:18 <luite_> > diel_const = map (\nk -> let n = head nk; k = nk!!1; in [n**2 - k**2, 2*n*k])
05:11:19 <lambdabot>   <no location info>: parse error on input `='
05:11:21 <luite_> euh
05:12:10 <Dynetrekk_> luite_: nice
05:13:55 <Peaker> http://hpaste.org/13205#a1
05:15:06 <Peaker> Dynetrekk_: ^^
05:15:28 <Dynetrekk_> okay... could you explain:
05:15:35 <Dynetrekk_> diel_const1 ((n, k):nks) =
05:15:45 <Dynetrekk_> (n, k) is now the first tuple in a list?
05:15:54 <Peaker> Dynetrekk_: pattern matching the head of the list as a 2-tuple (n,k), and the rest of the list into nks
05:15:57 <mm_freak> (\nk@(n:_) -> …)
05:16:29 <Dynetrekk_> Peaker: you do realise that nks is a list of lists? not tuples?
05:16:38 <Peaker> Dynetrekk_: I changed it to be a list of tuples ;)
05:17:04 <Dynetrekk_> Peaker: okay, I can see that this is a better solution in this case, but I want to extend to longer lists later on
05:17:08 <Dynetrekk_> I'm trying to, right now :P
05:17:16 <Peaker> Dynetrekk_: ah
05:17:39 <Dynetrekk_> but sure, it's a good idea if the size is fixed at 2
05:17:56 <Dynetrekk_> this is boring work anyway, I just need to convert a lot of numbers in a table... gah
05:18:51 <Peaker> Dynetrekk_: http://hpaste.org/13205#a2
05:19:04 <luite_> > let map' f = foldr ((:).f) [] in map' toUpper "test"
05:19:05 <lambdabot>   "TEST"
05:19:06 <Peaker> Dynetrekk_: replace that function with whatever you wish
05:19:16 <Peaker> @src map
05:19:16 <lambdabot> map _ []     = []
05:19:16 <lambdabot> map f (x:xs) = f x : map f xs
05:19:37 <luite_> Dynetrekk_: the non-pointsfree version would be (\x y -> f x : y)
05:20:23 <Peaker> Dynetrekk_: try to separate your solution into solving smaller problems
05:20:26 <Dynetrekk_> hm okay... I think I found a solution though. possibly stupid, but it kinda works
05:20:29 <Peaker> Dynetrekk_: write a function that operates on a single list
05:20:32 <Dynetrekk_> I do :P
05:20:35 <Dynetrekk_> and I did
05:20:37 <Dynetrekk_> I can paste..
05:20:41 <Peaker> Dynetrekk_: please do then
05:21:08 <Dynetrekk_> http://hpaste.org/13205#a3
05:21:15 <Dynetrekk_> I thought it was pretty readable, at least :P
05:21:52 <Dynetrekk_> oh, and my data would be "somenumber n1 k1 n2 k2 n3 k3.... " in the data file
05:22:10 <Dynetrekk_> so the "tail" is because I don't want somenumer (incidentally, photon energy)
05:23:03 <Peaker> Dynetrekk_: why don't you define dielConsts in terms of map?
05:23:42 <Peaker> Dynetrekk: why don't you define dielConst in terms of map?
05:24:02 <Dynetrekk> Peaker: good question. I'm not good at haskell being one possible answer
05:24:04 <Peaker> Dynetrekk: why the "tail" call there, too?
05:24:13 <Dynetrekk> my data would be "somenumber n1 k1 n2 k2 n3 k3.... " in the data file
05:24:15 <luite_> Dynetrekk: you're here te learn, right? :P
05:24:18 <luite_> to
05:24:19 <Dynetrekk> right
05:24:23 <Dynetrekk> te learn, mate
05:24:23 <Peaker> Dynetrekk: your dielConst is dropping the first item on all the items...
05:24:34 <Dynetrekk> Peaker: I put it back
05:24:50 <Peaker> Dynetrekk: where?
05:24:58 <luite_> recognizing those patterns really makes your code easier to read, and write
05:24:59 <Peaker> oh you pasted again
05:25:01 <Dynetrekk> http://hpaste.org/13205#a4
05:25:10 <Dynetrekk> what patterns?
05:26:05 <Peaker> Dynetrekk: well, now your function seems to be doing something else entirely
05:26:06 <luite_> Dynetrekk: where you can use map, fold (sorry, not to be confused by pattern matching)
05:26:30 <Dynetrekk> hm, there's a list too much somehow
05:26:33 <Peaker> Dynetrekk: dielConsts is eating 2 items at a time from a flat list
05:26:39 <Peaker> Dynetrekk: and not a list of 2-lists
05:27:05 <Dynetrekk> Peaker: yep. the real and imaginary part...
05:27:19 <Dynetrekk> there are 2 functions here, right: dielConst and dielConsts
05:27:23 <Peaker> Dynetrekk: and dielConst is doing something pretty weird too
05:27:26 <Dynetrekk> (in lack of better names)
05:27:35 <Peaker> Dynetrekk: Haskell has a Complex data-type, btw
05:27:36 <Dynetrekk> hm, yep, it makes lists of each pair...
05:28:04 <Dynetrekk> Peaker: not really too interesting. I have to take real and imag parts afterwards, easier to do it all in my head :)
05:28:15 <Dynetrekk> i. e. ñ = n + ik
05:28:21 <Dynetrekk> epsilon_real = n**2 - k**"
05:28:25 <Peaker> Dynetrekk: dielConst is not making lists of each pair, not exactly...
05:28:31 <Dynetrekk> epsilon_imag = 2 n k
05:28:43 <Dynetrekk> Peaker: hm, but something is weird from the output
05:28:47 <Peaker> > (5 :+ 6) * (0 :+ 1)
05:28:49 <lambdabot>   (-6.0) :+ 5.0
05:29:02 <Dynetrekk> what's that mess? :P
05:29:08 <Dynetrekk> complex numbers I guess
05:29:14 <Dynetrekk> seems like it from the math
05:29:20 <Peaker> Dynetrekk: a :+ b       means    a * 1 + b * i
05:29:39 <Dynetrekk> indeed...
05:29:43 <Peaker> Dynetrekk: and you can use it as a value, multiply it, add it, etc
05:30:08 <Peaker> > (1 :+ 1) ** 3
05:30:09 <lambdabot>   (-2.0) :+ 2.0000000000000004
05:30:11 <Dynetrekk> Peaker: but I don't really need to add or multiply, just do n**2 - k**2 and 2*n*k... don't need a new datatype for that
05:30:25 <Peaker> Dynetrekk: the data-type already exists
05:30:33 <Peaker> Dynetrekk: but ok - lets do it with explicit pairs
05:30:49 <Dynetrekk> yeah, but it won't make the job easier. then I have to modify the reading part of the code, as well.
05:30:51 <Peaker> Dynetrekk: if you want explicit pairs, sounds like 2-tuples are what you want, why do you want an N-list if its complex numbers you're representing?
05:31:38 <Dynetrekk> Peaker: I was figuring, as I have 3 columns, to just keep one list for each row. then, first item is photon energy. then, you have re and im for each 3 metals. i.e. 7 columns total
05:32:24 <Peaker> Dynetrekk: what's the exact data you have as input, and what data do you want as output?
05:32:34 <Dynetrekk> Peaker: I'll paste an example
05:33:42 <Peaker> afaik, energy is a real number, not a complex one :)
05:33:51 <Dynetrekk> http://hpaste.org/13205#a5
05:34:16 <Dynetrekk> Peaker: yep, well, usually. in this case it is. but the index of refraction is complex.
05:34:50 <Dynetrekk> so this is index of refraction for different frequencies. anyways, the numbers are just dummy values for now.
05:35:07 <cnwdup> Just mapping over a list of 3-tupels would be a lot easier, wouldn't it?
05:35:07 <Peaker> (n,k) form a complex number?
05:35:15 <Dynetrekk> Peaker: exactly
05:35:20 <Peaker> Dynetrekk: then you should group them together
05:35:26 <Dynetrekk> cnwdup:  there are no 3-tuples. there are 3 2-tuples per line
05:35:28 <Peaker> Dynetrekk: not "flatten" them over the row
05:35:38 <Dynetrekk> Peaker: in principle, yes
05:35:52 <Dynetrekk> cnwdup: just not right now
05:36:06 <Peaker> Dynetrekk: so,  [(Energy, Complex)]
05:36:07 <Dynetrekk> Peaker: but it will work like this :P
05:36:14 <Dynetrekk> Peaker: hmm, not really...
05:36:34 <Dynetrekk> [(Energy, Complex, Complex, Complex)]
05:36:39 <Dynetrekk> as there will be 3 metals, eventually
05:36:47 <Dynetrekk> I guess I should add some "data" for that...
05:36:52 <Peaker> Dynetrekk: so: [(Energy, [Complex])] for any number of metals?
05:37:14 <cnwdup> > map (\(hv, n, k) -> (hv, n**2 - k**2, 2*n*k)) [(0.7), (1.0), (2.0), (2.0, 1.1, 2.2), (3.3, 1.5, 2.0)]
05:37:15 <lambdabot>       No instance for (Fractional (t, t1, t1))
05:37:15 <lambdabot>        arising from the litera...
05:37:27 <Peaker> Dynetrekk: you can have: type Energy = Double ; and use: type Complex = (Double, Double)  if you don't want to use the Data.Complex module
05:37:33 <Dynetrekk> Peaker: better, yep
05:37:40 <cnwdup> > map (\(hv, n, k) -> (hv, n**2 - k**2, 2*n*k)) [(0.7, 1.0, 2.0), (2.0, 1.1, 2.2), (3.3, 1.5, 2.0)]
05:37:42 <lambdabot>   [(0.7,-3.0,4.0),(2.0,-3.630000000000001,4.840000000000001),(3.3,-1.75,6.0)]
05:37:44 <Dynetrekk> I don't care about modules
05:38:05 <Peaker> Dynetrekk: re-using existing code is a good thing, in general :)
05:38:06 <Dynetrekk> I just know this will be easier to do by hand, easier to write out the multiplication than wrapping and unwrapping complex numbers
05:38:10 <Dynetrekk> Peaker: agre
05:38:15 <Dynetrekk> Peaker: agree
05:38:30 <Peaker> Dynetrekk: Are the epsilon outputs also part of a complex number?
05:38:54 <Dynetrekk> Peaker: sure, the epsilon is complex. epsilon = n**2 (to some approximation, neglecting magnetic effects)
05:38:55 <Peaker> Dynetrekk: (epsilon_re, epsilon_im) form a complex number?
05:39:00 <Dynetrekk> Peaker: sure
05:39:10 <Peaker> oh, its reAL and imAGINARY :)
05:39:17 <Dynetrekk> what else? :)
05:39:52 <Dynetrekk> re and im are what mathemagicians call them for short, right?
05:40:29 <Peaker> Dynetrekk: ok then,  so something like:     type Energy = Double ; type Complex = (Double, Double) ; type Row = [(Energy, [Complex])] ; mapRow :: Row -> Row ;  mapRows = map mapRow  ; so far so good?
05:40:54 <Dynetrekk> wow, but, yeah...
05:40:55 <Peaker> Dynetrekk: mapRows will apply to a whole list of such rows
05:41:27 <Dynetrekk> except it's such a bitch to make everything into complex numbers and stuff first... gah...
05:41:44 <Peaker> Dynetrekk: why? an extra pair of parens? :)
05:42:05 <Dynetrekk> Peaker: haha, sure, but where to insert them:P (sounds like a lisp problem)
05:42:35 <Peaker> Dynetrekk: its pretty easy to write:  [Double] -> [(Energy, [Complex])] if you really want to format your data as [[Double]]
05:42:57 <Dynetrekk> I never wrote that... I'm not sure exactly what you mean by that :P
05:43:29 <Dynetrekk> but yeah, now it's [[Double]]... or Float, does that change anything?
05:43:36 <Peaker> Dynetrekk: If you don't like the extra parens in each row, you can have your table in the form:  table = [[1,2,3],[4,5,6],[7,8,9]] and convert it to the form you want to use with a simple function
05:43:51 <Dynetrekk> I tried doing something like that
05:44:00 <Peaker> Dynetrekk: If its now [[Double]] then you can easily convert it to [(Energy, [Complex])] with a function, instead of by hand
05:44:02 <Dynetrekk> I can paste the whole thing, perhaps...
05:44:21 <Dynetrekk> sure, probably... but what is the motivation? it won't really make life any easier.
05:44:55 <Dynetrekk> reusing code; yes, if there is something to gain. but is there anything? we're talking 1 multiplication
05:45:23 <Dynetrekk> all the rest is essentially file plumbing etc, which I wanted to try to learn, but it seems a bit overwhelming
05:45:32 <Peaker> Dynetrekk: is Row [(Energy, [Complex])] or is it (Energy, [Complex]) ?
05:45:44 <Peaker> (A single row has multiple energy/metals, or just one?
05:45:48 <Dynetrekk> each row has one energy and 3 complex'es
05:45:55 <Peaker> ah, so not a list as I wrote above
05:45:59 <Peaker> Dynetrekk: 3 or N?
05:46:15 <Dynetrekk> i.e. at a given optical frequency, each metal has one complex number for its optical properties.
05:46:41 <Dynetrekk> I could give you the pdf, if you want :P
05:47:05 <Peaker> Dynetrekk: http://hpaste.org/13205#a6
05:47:27 <Peaker> Dynetrekk: nah, lets stick to the Haskell side of things
05:47:32 <Dynetrekk> what does "type" do?
05:47:43 <Dynetrekk> Peaker: okay, just to make the data input clear to you
05:47:47 <Peaker> Dynetrekk: it creates a type alias
05:47:55 <Peaker> Dynetrekk: just gives another name to some existing type
05:48:03 <Dynetrekk> okay... but why?
05:48:21 <Peaker> Dynetrekk: so I can write [Row] -> [Row]  instead of having to write: [(Energy, [Complex])] -> [(Energy, [Complex])] -- much more readable
05:48:36 <vixey> > foldr const [] "hi"
05:48:37 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
05:48:39 <Peaker> Dynetrekk: easier to work with
05:49:03 <Dynetrekk> hm, this makes a bit more sense now
05:49:18 <Dynetrekk> though, what is maprow?
05:49:19 <Peaker> > foldr const '0' "hi"
05:49:20 <lambdabot>   'h'
05:49:40 <Peaker> Dynetrekk: it transforms a single row according to your rules..
05:49:51 <Dynetrekk> i.e. n**2 - k**2 etc
05:50:12 <Peaker> Dynetrekk: Yeah, except you haven't explained what it has to do with (energy, metals) yet ...
05:50:28 <Peaker> Dynetrekk: its actually storing the refraction index of metals in each row?
05:50:44 <Dynetrekk> but the energy has nothing to do with it though. it's just there. in python I would probably do a dict, epsilons[energy] = somecomplex
05:50:54 <Dynetrekk> yep, a row is 7 numbers
05:51:09 <Dynetrekk> energy , n, k, n, k, n, k
05:51:14 <Dynetrekk> one n for each metal, one k
05:51:20 <tristes_tigres> Hello
05:51:22 <tristes_tigres> http://hpaste.org/13206
05:51:22 <Peaker> Dynetrekk: oh, then mapRow can ignore it, then we can see how we make it even more elegant
05:51:24 <Dynetrekk> so the n_complex = n + ik
05:51:30 <Dynetrekk> okay
05:51:50 <Peaker> Dynetrekk: so how do you handle these multiple (n, k) pairs, what do you want to transform them to?
05:52:02 <tristes_tigres> Anyone is well familiar with type families ? I can't figure out how to give a type signature to d_C in http://hpaste.org/13206
05:52:12 <Dynetrekk> I start out with:
05:52:17 <Dynetrekk> ñ = n + ik
05:52:20 <Dynetrekk> I want to end up with:
05:52:32 <Dynetrekk> epsilon_re = n**2 - k**2
05:52:39 <Dynetrekk> epsilon_im = 2*n*k
05:53:05 <Peaker> Dynetrekk: are the transformations of the different metals independent of each other?
05:53:23 <Peaker> Dynetrekk: do you transform each (n,k) pair separately, or do they affect each other somehow?
05:53:50 <Peaker> Dynetrekk: sounds like you want them completely independent
05:53:58 <tristes_tigres> it seem to me that fundeps are more useable right now
05:54:24 <Peaker> Dynetrekk: so you can define:  epsilon :: Complex -> Complex ; epsilon (n, k) = (n**2 - k**2, 2*n*k)    right?
05:54:28 <Dynetrekk_> Peaker: completely. one property (number) for each metal. yep, map is probably a good idea.
05:54:34 <Peaker> Dynetrekk_: so you can define:  epsilon :: Complex -> Complex ; epsilon (n, k) = (n**2 - k**2, 2*n*k)    right?
05:54:41 <Dynetrekk_> yep
05:54:57 <Dynetrekk_> well no maybe not
05:55:03 <Peaker> Dynetrekk_: so you can define:  mapRow (energy, refractions) = (energy, map epsilon refractions) -- right?
05:55:12 <Dynetrekk_> epsilon n = n_re**2 - n_im**2
05:55:27 <Dynetrekk_> probbly, yes..
05:55:34 <mm_freak> i hope, the next haskell standard will incorporate most of the usual extensions
05:55:39 <Olathe> I think you need Complex a -> Complex a
05:55:48 <mm_freak> it gets tiring to write the long LANGUAGE pragma all over again
05:56:22 <Dynetrekk_> bt now I'm not using the built-in complex type, right?
05:56:59 <Peaker> Dynetrekk_: http://hpaste.org/13205#a7
05:57:15 <Peaker> Dynetrekk_: right, just a   type Complex = (Double, Double)   (just using Double 2-tuples)
05:57:36 <Peaker> Olathe: We defined a simple Complex type alias, not the one from Data.Complex
05:57:42 <Dynetrekk_> yep, right
05:58:07 <Peaker> Dynetrekk_: so do you understand http://hpaste.org/13205#a7  ?
05:58:19 <Dynetrekk_> oh, don't use r an i. r is usually sqrt(re**2 + im**2) :)
05:58:21 <Dynetrekk_> wait a sec
05:58:35 <Dynetrekk_> makes sense
05:59:03 <Dynetrekk_> and actually, I'd use n and k, as this is the notation from the data set :)
05:59:26 <Peaker> http://hpaste.org/13205#a8 uses n,k
05:59:46 <Dynetrekk_> yep, this is how I wrote it, based on your idea
05:59:59 <Dynetrekk_> so, now I just get a list of rows, and bingo..
06:00:37 <Peaker> Dynetrekk_: if this solves your problem, then you're done. However, if you want to learn about more advanced features you can use to make that code shorter/more concise, I can show you
06:00:59 <Dynetrekk_> hm, I'm not really done yet
06:01:22 <Peaker> Dynetrekk_: what's missing?
06:01:26 <Dynetrekk_> I have a list of lists. each "smaller list" contains the 7 values - but I need to get it on "Row" format
06:03:29 <Dynetrekk_> finally, write it nicely to file
06:03:33 <Peaker> Dynetrekk_: ah, say you have  convert :: [Double] -> Row     -- how can you use that?
06:03:48 <Dynetrekk_> sounds good
06:04:18 <Dynetrekk_> hm, do I need to make a "constructor" (OO jargon) for each complex then?
06:04:46 <Dynetrekk_> makeRow xs = (head xs, ...)
06:04:56 <Dynetrekk_> what's the dots? :P makeRow :: [Double] -> Row
06:05:05 <vixey> makeRow (x:xs) = (x, ...)
06:06:06 <Dynetrekk_> vixey: so now how do I turn xs into a list of complex?
06:06:19 <vixey> map complicate xs
06:06:31 <Dynetrekk_> Peaker: sounds reasonable to you?
06:06:43 <Peaker> Dynetrekk_: Have you gone through a Haskell tutorial?
06:06:53 <Dynetrekk_> Peaker: yup
06:07:01 <Peaker> Dynetrekk_: surely it taught you what the "::" means
06:07:10 <Dynetrekk_> I understand the ::
06:07:13 <Dynetrekk_> makes perfect sense
06:07:25 <Peaker> Dynetrekk_: what dots were you asking about?
06:07:40 <Dynetrekk_> I have more of a problem conjuring up how to structure the program in a functional way
06:08:01 <Dynetrekk_> I was trying to understand how to make a row, Peaker
06:08:49 <Peaker> Dynetrekk_:  makeRow :: [Double] -> Row          means:  the value by name of "makeRow" has the type:   Function from List-of-Doubles to Row
06:09:03 <Dynetrekk_> I'm more used to OO and procedural thinking
06:09:08 <Dynetrekk_> Peaker: yep, I know
06:09:27 <Peaker> Dynetrekk_: Ok, so can you state the type of the function you are missing?
06:09:44 <Beelsebob> Peaker: isn't mapRow aka fmap epsilon?
06:09:44 <Dynetrekk_> hmmm... possibly...
06:09:45 <Dynetrekk_> but I think I have a sugestion now
06:09:54 <Dynetrekk_> :t fmap
06:09:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:10:04 <Dynetrekk_> functor? new to me
06:10:13 <Beelsebob> Dynetrekk_: btw, there's already a Data.Complex module
06:10:17 <Beelsebob> which does complex numbers for you
06:10:19 <Dynetrekk_> Beelsebob: I know
06:10:32 <Peaker> Beelsebob: Yes, I'm trying to help Dynetrekk_ -- building it up from the ground
06:10:37 <Beelsebob> ah, I see
06:10:40 <Dynetrekk_> Beelsebob: but I'm not going to do a lot of arithmetic, in fact, very very little. the problem is more the following:
06:11:07 <Dynetrekk_> I know how to do a little crunching in haskell, but I don't know how to start up, say by reading a text file as input, and then Getting Something Done, and writing a text file as output
06:11:24 <Peaker> Dynetrekk_: lets do the file handling last
06:11:31 <Peaker> Dynetrekk_: first, you have the conversion issue
06:11:36 <SamB_XP> parsing
06:11:37 <Dynetrekk_> I have the read in-thing now
06:11:37 <SamB_XP> printing
06:11:38 <Dynetrekk_> yep
06:11:53 <Dynetrekk_> and I know how to read data from file - at last :P
06:11:57 <Dynetrekk_> took me a while
06:12:04 <Peaker> Dynetrekk_: what you have in the file is a table of doubles, right?
06:12:10 <Dynetrekk_> still, yep
06:12:17 <Dynetrekk_> 7 x N, N is large
06:12:42 <Peaker> Dynetrekk_: well, converting each line of 7 doubles to a [Double] is easy
06:12:46 <Peaker> Dynetrekk_: we'll do that later
06:12:49 <Dynetrekk_> http://hpaste.org/13205#a9 <- so far
06:12:58 <Peaker> Dynetrekk_: what do you want to do with the [Double]?
06:13:00 <Dynetrekk_> I have done that, i.e. read from file
06:13:31 <Beelsebob> Dynetrekk_: on a purely stylistic issue -- chains of f $ g $ h $ x are better written as f . g . h $ x
06:13:36 <Dynetrekk_> well, we wrote that part. I just need to get my list of [Double] into a Row "object"
06:13:41 <Beelsebob> they have more expressions in them and are more easily refactored
06:13:43 <Dynetrekk_> Beelsebob: allright
06:14:29 <Peaker> Dynetrekk_: your "numbers" function is really a map too,  so    numbers = map (map read)
06:14:34 <Peaker> Dynetrekk_: do you understand why?
06:15:23 <Dynetrekk_> Peaker: hmmm, I think so. because I do the same thing to each element. I just couldn't figure out where to put the :: [Double] in a map map construction
06:15:29 <Dynetrekk_> but yep, it's a map
06:15:35 <Dynetrekk_> (believe me, I tried first :))
06:16:02 <Peaker> Dynetrekk_: makeRow xs = (head xs, map _makeRow $ tail xs)        can become:   makeRow (x:xs) = (x, map _makeRow xs)
06:16:27 <Peaker> Dynetrekk_: you're using a map for the "internal" manipulation of each item, but your external traversal of the list in numbers is also a map
06:16:46 <Peaker> Dynetrekk_: so numbers = map (map read)   means the same thing (but much shorter)
06:17:04 <Dynetrekk_> ah , I agree
06:17:12 <Dynetrekk_> but again: where do I put the pesky :: Double part?
06:17:26 <Beelsebob> numbers :: [[String]] -> [[Double]]
06:17:50 <Dynetrekk_> Beelsebob: ah, so I don't even need to put it next to the read function?
06:17:52 <vixey> you don't have to put down any ::'s by the way
06:17:55 <Beelsebob> nope
06:18:09 <Beelsebob> it'll infer the fact that read needs to produce Doubles from the fact that numbers does too
06:18:19 <Peaker> Dynetrekk_: your comment "-- Parses [[String]] to [[Float]]"  is better expressed as a type declaration like Beelsebob just mentioned
06:18:35 <Dynetrekk_> vixey:  can't be. how does read figure out what to convert to?
06:18:44 <Beelsebob> Dynetrekk_: defaulting
06:18:44 <Dynetrekk_> Peaker: okay, I can agree
06:18:53 <Beelsebob> it'll default to something useless at the moment though
06:18:59 <Beelsebob> until you make your program do something
06:19:04 <vixey> Dynetrekk_, context
06:19:06 <Dynetrekk_> Beelsebob: but vixey said "you don't have to put any ::'s"
06:19:07 <Peaker> Dynetrekk_: and if you have that - you don't need the ::[Double] in there, either
06:19:09 <Beelsebob> and then it'll go "oh hai, that has to be a float, or none of the rest works"
06:19:18 <Dynetrekk_> vixey: from where the function is called elsewhere?
06:19:25 <Beelsebob> Dynetrekk_: exactly
06:19:33 <Dynetrekk_> ah..
06:19:35 <Peaker> vixey: surely Double will have to be specified somewhere, to choose between Double/Float/etc
06:19:53 <Dynetrekk_> hm, good point
06:19:54 <Beelsebob> Dynetrekk_: note that if you don't put int the annotation then it's inferred type will be Read a => [[String]] -> [[a]
06:19:55 <Beelsebob> ]
06:19:55 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
06:20:01 <vixey> Dynetrekk_, to see what I'm talking about the best thing is to try it out and use :t in ghci to see if you get what you suspect
06:20:07 <Beelsebob> and then you'll be able to use it for reading lines with words of "somethings" on all the time
06:21:08 <taruti> Is there a nice way of defining Data instances by hand?
06:21:16 <Saizan> Peaker: Floating a => a defaults to Double
06:21:27 <Dynetrekk_> hm, I'll experiment a bit...
06:21:32 <SamB_XP> taruti: why ?
06:21:57 <Peaker> Saizan: with a warning :-(
06:22:19 <taruti> I have a datatype like "data D t = A String | B t" and want the data instance to just ignore all 'B _' (i.e. I want a "instance Data (D t)" instead of a "instance Data t => (D t)"
06:22:56 <taruti> SamB_XP: t will typically have types like "IO ()" that are in data and thus there will be no instance for D in the relevant cases...
06:22:57 <Dynetrekk_> btw, the numbers thing fails when I try to print the numbers as numbers
06:23:02 <Dynetrekk_> it doesn't understand
06:24:02 <Peaker> taruti: you can just define the instance that way then - there's no need to specify that "t" is also Data
06:24:19 <Peaker> taruti: but then in the B case, you're not going to have the Data instance available for the value in B
06:24:33 <Dynetrekk_> vixey: seems inconvenient to not specify anything, if you ask me...
06:24:50 <Peaker> ter
06:24:55 <vixey> Dynetrekk_: why?
06:25:05 <vixey> Dynetrekk_: (most people seem to agree with that by the way)
06:25:12 <Saizan> ?type show . read
06:25:13 <lambdabot> String -> String
06:25:18 <Dynetrekk_> vixey:  because the program fails. since I call print $ numbers argument
06:25:26 <Dynetrekk_> the print doesn't know what to read - I think
06:25:28 <Saizan> that works only because of extended defaulting.
06:25:30 <Dynetrekk_> and stuff fails
06:25:50 <SamB_XP> Saizan: doesn't work for much ;-P
06:25:59 <vixey> Dynetrekk_, watch this:
06:26:02 <Saizan> Dynetrekk_: yeah, "print" is not specific enough to determine a sensible type
06:26:08 <Dynetrekk_> exactly
06:26:09 <vixey> > read "3.2"
06:26:10 <lambdabot>   * Exception: Prelude.read: no parse
06:26:11 <vixey> > read "()"
06:26:12 <lambdabot>   ()
06:26:17 <SamB_XP> print is no more specific than read ;-P
06:26:28 <SamB_XP> (in practice)
06:26:35 <Dynetrekk_> yeah, so if you don't specify, it says no parse... right?
06:26:42 <vixey> no
06:26:46 <Dynetrekk_> you can't parse something, unless you know what to parse to?
06:26:52 <SamB_XP> (in theory, it's specificity is incomparable with that of read ;-P)
06:27:00 <Dynetrekk_> > read "3.1415" :: Float
06:27:02 <lambdabot>   3.1415
06:27:07 <Dynetrekk_> yeee
06:27:14 <vixey> Dynetrekk_, but look
06:27:28 <vixey> > read "3" + 1
06:27:29 <lambdabot>   4
06:27:32 <SamB_XP> Dynetrekk_: if you don't specify, it probably tries to parse as the wrong thing ;-P
06:27:40 <Dynetrekk_> but if I want to :
06:27:48 <Dynetrekk_> > print $ read "3.14"
06:27:49 <lambdabot>   * Exception: "<IO ()>"
06:28:03 <SamB_XP> .... oookay !
06:28:05 <Dynetrekk_> ah... so I still need to specify, even if only very rarely
06:28:08 <SamB_XP> that's a strange exception
06:28:19 <SamB_XP> a very strange exception
06:28:35 <Dynetrekk_> SamB_XP: a fool can ask more than 10 bots can reply
06:28:39 <kpreid> > print False
06:28:40 <vixey> Dynetrekk_, the alternative is to not do bizarre things like  print . read
06:28:41 <lambdabot>   * Exception: "<IO ()>"
06:28:50 <kpreid> > getLine
06:28:51 <lambdabot>   * Exception: "<IO [Char]>"
06:28:53 <SamB_XP> why's that an exception ?
06:28:54 <Dynetrekk_> vixey: :P
06:29:02 <SamB_XP> shouldn't it just say "IO is n
06:29:07 <SamB_XP> 't allowed"?
06:29:07 <kpreid> looks like a bug to me
06:29:18 <Dynetrekk_> I should be allowed to print my input, just to see that I parsed it right? right?
06:29:23 <kpreid> it used to just respond <IO ()> as the show for IO
06:29:37 <kpreid> (well, the show for Typeable a => IO a anyway)
06:30:00 <qwr> > show (read "3.14" :: Float)
06:30:03 <lambdabot>   "3.14"
06:30:05 <Badger> > putStrLn
06:30:07 <lambdabot>       Overlapping instances for Show (String -> IO ())
06:30:07 <lambdabot>        arising from a ...
06:30:14 <SamB_XP> @ask gwern what's up with these exceptions on attempts to use IO-monadic expressions?
06:30:14 <lambdabot> Consider it noted.
06:30:37 <SamB_XP> @tell gwern > print False
06:30:37 <lambdabot> Consider it noted.
06:30:51 <Dynetrekk_> Peaker: hey, I think I'm close to making the thing work now:P
06:31:01 <Dynetrekk_> Peaker: I'll paste when I'm done (or frustrated)
06:31:19 <qwr> > putStrLn "a"
06:31:20 <lambdabot>   * Exception: "<IO ()>"
06:31:48 <qwr> > [putStrLn "a"]
06:31:49 <lambdabot>   [* Exception: "<IO ()>"
06:32:13 <kpreid> hey neat
06:32:21 <kpreid> iirc lambdabot used to not do partial printing
06:32:25 <kpreid> > [1,2,3,undefined]
06:32:27 <lambdabot>   [1,2,3,* Exception: Prelude.undefined
06:33:21 <kpreid> > iterate tail [1,2,3]
06:33:22 <lambdabot>   [[1,2,3],[2,3],[3],[],* Exception: Prelude.tail: empty list
06:33:34 <Badger> hah
06:35:07 <kpreid> > transpose $ iterate tail $ [1..]
06:35:08 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:37:55 <dmwit> > [[1..]] -- more efficient ;-)
06:37:56 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:38:08 <vixey> > tail $ transpose $ iterate tail $ [1..]
06:38:10 <lambdabot>   [[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:38:16 <papermachine> > [1, 2] >>= replicate 2
06:38:17 <lambdabot>   [1,1,2,2]
06:44:43 <Axman6> @hoogle a -> [b]
06:44:44 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:44:44 <lambdabot> Prelude repeat :: a -> [a]
06:44:44 <lambdabot> Data.List repeat :: a -> [a]
06:47:52 <Beelsebob> Axman6: randoms?
06:48:33 <Axman6> wondering what can be used on the right side of >>= for lists
06:48:58 <Axman6> Beelsebob: any idea what cryptic did in #macosx? seems to have kicked everyone...
06:49:25 <Beelsebob> Axman6: yeh, the freenode staffers weren't too chuffed
06:49:36 <Axman6> what happened?
06:49:37 <Badger> hah
06:49:39 <Beelsebob> there was some talk of them deopping him
06:49:40 <Badger> CLEAR USERS?
06:49:43 <Beelsebob> Badger: yeh
06:49:45 <Dynetrekk_> Peaker: hm, how do you make a list of (Double,Double) into a list of whitespace-separated strings?
06:49:49 <Dynetrekk_> eh, or a string
06:49:57 <Beelsebob> Dynetrekk_: show?
06:50:08 <Dynetrekk_> Beelsebob: but then you get some parens etc, I'll show
06:50:14 <Dynetrekk_> > show (1,2,3)
06:50:15 <lambdabot>   "(1,2,3)"
06:50:24 <Dynetrekk_> Beelsebob: I'd like
06:50:29 <Beelsebob> > let showP (x,y) = show x ++ " " ++ show y in showP (5,3)
06:50:31 <lambdabot>   "5 3"
06:50:31 <Dynetrekk_> > map show [1..3]
06:50:32 <Axman6> map ((" "++").show)?
06:50:33 <lambdabot>   ["1","2","3"]
06:50:41 <Peaker> > (unwords . map show) [1,2,3]
06:50:42 <lambdabot>   "1 2 3"
06:50:43 <Dynetrekk_> eh, no, I didn't like what I said :P
06:50:49 <Axman6> > map ((" "++").show) . zip [1..] $ [4..]
06:50:51 <lambdabot>   <no location info>:
06:50:51 <lambdabot>      lexical error in string/character literal at chara...
06:50:53 <Peaker> Dynetrekk_: unwords . map show
06:51:00 <Axman6> > map ((" "++).show) . zip [1..] $ [4..]
06:51:02 <lambdabot>   [" (1,4)"," (2,5)"," (3,6)"," (4,7)"," (5,8)"," (6,9)"," (7,10)"," (8,11)",...
06:51:06 <Dynetrekk_> Peaker: but I have a list of pairs, i.e. our Complex thing
06:51:15 <Dynetrekk_> I don't want the parens and commas
06:51:18 <Axman6> > concatMap ((" "++).show) . zip [1..] $ [4..]
06:51:19 <lambdabot>   " (1,4) (2,5) (3,6) (4,7) (5,8) (6,9) (7,10) (8,11) (9,12) (10,13) (11,14) ...
06:51:31 <Beelsebob> > let showP (x,y) = show x ++ " " ++ show y in unwords $ map showP [(5,3),(1,2), (9,4), (10,3)]
06:51:33 <lambdabot>   "5 3 1 2 9 4 10 3"
06:51:38 <Beelsebob> that do you Dynetrekk_?
06:51:51 <Dynetrekk_> Beelsebob: lookin' better :)
06:52:12 <Peaker> > let showTuple (x,y) (show x ++ " " ++ show y) in (unwords . map showTuple) [(1,2),(3,4),(5,6)]
06:52:13 <lambdabot>   <no location info>: parse error on input `in'
06:52:39 <Peaker> > let showTuple (x,y) = (show x ++ " " ++ show y) in (unwords . map showTuple) [(1,2),(3,4),(5,6)]
06:52:41 <lambdabot>   "1 2 3 4 5 6"
06:52:42 <Dynetrekk_> Beelsebob: perfect!
06:52:57 <Dynetrekk_> Peaker: yep, I didn't use the $ :P
06:52:59 <Peaker> Beelsebob: Independently writing the exact same thing :P
06:53:03 <Dynetrekk_> haha
06:53:05 <Dynetrekk_> funny
06:53:26 <Peaker> Beelsebob: Except I like the (a . b . c) $ style    so you can get rid of the list there easily :)
06:53:33 <athos> hi all
06:53:39 <Beelsebob> Peaker: yeh, ditto -- I just didn't like the parens it introduced
06:53:40 <Dynetrekk_> the . style seems to make sense
06:53:52 <Peaker> > let showTuple (x,y) = (show x ++ " " ++ show y) in unwords . map showTuple $ [(1,2),(3,4),(5,6)]
06:53:54 <lambdabot>   "1 2 3 4 5 6"
06:53:58 <Dynetrekk_> but what are really the advantages / differences?
06:54:05 <Peaker> > let showTuple (x,y) = show x ++ " " ++ show y in unwords . map showTuple $ [(1,2),(3,4),(5,6)]
06:54:07 <lambdabot>   "1 2 3 4 5 6"
06:54:11 <Badger> @src (.)
06:54:11 <lambdabot> (f . g) x = f (g x)
06:54:16 <Beelsebob> Dynetrekk_: writing f . g . h $ x has more expressions in it than f $ g $ h $ x
06:54:21 <Beelsebob> so it's more easily refactored
06:54:24 <Dynetrekk_> more expressions in it?
06:54:30 <Beelsebob> e.g. I can write e = f . g . h
06:54:30 <Heffalump> more type-correct subexpressions, he means
06:54:32 <Saizan> more valid subexpressions
06:54:33 <Dynetrekk_> what does that mean?
06:54:33 <Beelsebob> and then e x instead
06:54:46 <Dynetrekk_> more valid? is there som fuzzy logic to validity?
06:54:48 <Beelsebob> but I can't write e = f $ g $ h and expect to apply it
06:54:56 <Dynetrekk_> Beelsebob: _that_ was very clear
06:54:56 <Beelsebob> Dynetrekk_: you parsed incorrectly
06:54:57 <Heffalump> Dynetrekk_: valid = type-correct and useful
06:54:59 <Beelsebob> more (valid expressions)
06:55:06 <Dynetrekk_> hehe
06:55:24 <Heffalump> the downside of writing code that way is that you have to change $ to . when you change x to some expression with a $ in itself
06:55:27 <Dynetrekk_> I must be thinking to pythonic:P it's what I use mostly
06:55:41 <Dynetrekk_> *too
06:55:50 <Beelsebob> Dynetrekk_: essentially, I can refactor more easily using dots
06:55:57 <Beelsebob> because I can copy and paste chunks of code more easily
06:56:07 <Dynetrekk_> Beelsebob: okay, thanks, that's a good point
06:56:41 <Beelsebob> there's also f . g $ h x that various people use
06:56:52 <Beelsebob> I don't really see any advantage of that over f . g . h $ x though
06:57:03 <Peaker> Beelsebob: I wouldn't say "more valid [sub]expressions" because   a $ b $ c      has a $ (b $ c)  as a subexpression.  But more _useful_ sub-expressions (a . b) is probably more useful than (b $ c)
06:57:29 <Beelsebob> Peaker: yes -- but a . b $ c has (b $ c) *and* (a . b)
06:57:30 <Dynetrekk_> Peaker: http://hpaste.org/13207 <- final soln.
06:57:35 <Beelsebob> while yours only had (b $ c)
06:58:01 <Beelsebob> Dynetrekk_: on a stylistic front -- it's traditional to name related functions function'
06:58:03 <Peaker> Beelsebob: oh, you mean that textual artifact :-)
06:58:05 <vixey> _makeRow is a horrid name
06:58:10 <Beelsebob> so I'd expect _makeRow to be called makeRow'
06:58:21 <Beelsebob> or something more meaningful
06:58:35 <Dynetrekk_> now I think I understood some more. you can more easily change part of the line, because a larger number of sub-strings form valid expressions... neat
06:58:39 <Dynetrekk_> Beelsebob: aha
06:58:57 <Dynetrekk_> Beelsebob: i.e. a "helping function" which people would not normally use?
06:59:05 <Beelsebob> yeh
06:59:14 <Beelsebob> if you don't expect anyone else to use it at all -- put it in a where clause
06:59:32 <Dynetrekk_> Beelsebob: the top of my file is
06:59:35 <Dynetrekk_> module Dielectric
06:59:36 <Dynetrekk_>     where
06:59:38 <Dynetrekk_> right?
06:59:46 <Beelsebob> sec
07:00:59 <Beelsebob> some tidy up for you Dynetrekk_ http://hpaste.org/13207#a1
07:01:24 <Dynetrekk_> I did change the makeRow'
07:01:32 <Dynetrekk_> ah, sorry, you did it differently
07:01:39 <Beelsebob> you see what I mean by a where clause now?
07:01:50 <Beelsebob> that has the same effect as let x = y in z
07:01:57 <Dynetrekk_> so it's similar to a let...
07:01:57 <Beelsebob> but it is sometimes neater
07:02:00 <Beelsebob> yep
07:02:05 <Dynetrekk_> exactly
07:02:05 <Dynetrekk_> okay
07:02:14 <Dynetrekk_> seems nicer than let actually
07:02:46 <Dynetrekk_> in physics at least, it's not uncommon to say (this is the eqn) and _then_ explain what it contains, e.g. m = mass, E = energy, ...
07:03:17 <Dynetrekk_> a practical question: what's the difference between ghc, runhaskell, ghci, runghc? ghci is interactive, ghc is the compiler, but what is runhaskell and runghc?
07:03:26 <athos> :t zip
07:03:27 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
07:03:30 <Dynetrekk_> and - are there large speed differences?
07:03:44 <athos> > zip [a,b,c] [d,e,f]
07:03:45 <lambdabot>   [(a,d),(b,e),(c,f)]
07:03:53 <Saizan> runghc is the non-interactive version of ghci
07:04:11 <Saizan> and ghci compiles to bytecode and interprets
07:04:16 <Dynetrekk_> okay
07:04:19 <Heffalump> compiled code runs much faster than interpreted code
07:04:20 <Saizan> while ghc compiles down to machine code
07:04:22 <Dynetrekk_> so, not "proper" compilation
07:04:28 <Dynetrekk_> I see
07:04:29 <Heffalump> but ghci can load up machine code compiled modules too
07:04:34 <Heffalump> if you pre-compile them with ghc
07:04:43 <athos> and what about runhaskell?
07:04:44 <Dynetrekk_> sure, and then call functions from the prompt
07:04:46 <athos> runhaskell == runghc?
07:04:48 <Dynetrekk_> yep, what about it?
07:05:19 <Saizan> runhaskell is a generic name
07:05:21 <Dynetrekk_> athos: on my machine, the one is a symlink to the other
07:05:28 <mdiin> (init [[3]]) ++ [3,3]
07:05:28 <Dynetrekk_> runhaskell -> runghc
07:05:29 <athos> Dynetrekk_: ah i see
07:05:38 <Saizan> it could use hugs if that's installed on your system
07:05:42 <Dynetrekk_> I guess that answers... well.. everything
07:05:45 <Peaker> init is the worst function name I've ever seen :)
07:05:46 <Dynetrekk_> aaah....
07:05:52 <Dynetrekk_> all right
07:05:54 <athos> ok, that makes sense
07:06:12 <Beelsebob> Dynetrekk_: http://hpaste.org/13207#a2 <-- because I'm anally retentive
07:06:14 <christian__> Can anyone suggest a good (GPL/LGPL) haskell project? Preferrably something rather small. It is mostly for self-educational purposes.
07:06:19 <mdiin> Peaker: Defined in Data.List though :)
07:06:24 <Beelsebob> oh, I missed some parens that can go
07:06:27 <Dynetrekk_> Beelsebob: sounds uncurable
07:06:39 <Axman6> christian__: why GPL?
07:06:42 <Dynetrekk_> Beelsebob: I have that too, but I'm not good enough in haskell to care yet
07:07:06 <Axman6> most projects are BSD licenced afaik, which is less restrictive than GPL
07:07:11 <Beelsebob> Dynetrekk_: http://hpaste.org/13207#a3 <-- final anally retentive version
07:07:28 <mdiin> If I want to append something to the last list in a list of lists, how would I go about doing that?
07:07:29 <christian__> Yeah, BSD is fine too, though i prefer GPL if possible
07:07:33 <Dynetrekk_> haha
07:07:37 <Dynetrekk_> Beelsebob: good job there :P
07:08:12 <Saizan> ?tye \xs -> all isSpace xs || head xs == '#'
07:08:13 <lambdabot> [Char] -> Bool
07:08:16 <Peaker> Beelsebob: still some parens
07:08:21 <vixey> mdiin, ++[x]
07:08:21 <Dynetrekk_> Beelsebob: why all the spaces in the Complex definition?
07:08:26 <Axman6> christian__: well look on hackage and find something that interests you
07:08:29 <vixey> mdiin, oh not that
07:08:33 <Dynetrekk_> Peaker: careful, you might kill the poor fella
07:08:34 <Beelsebob> Peaker: yeh -- I don't delete all parens -- only superfluous ones
07:08:39 <Dynetrekk_> haha
07:08:43 <vixey> mdiin, write a function onLast which does it
07:08:47 <Dynetrekk_> but why the spaces?
07:08:47 <Saizan> christian__: xmonad is fairly small and has a good functional core
07:08:49 <Beelsebob> Dynetrekk_: because it lines up with the line below >.<
07:08:49 <mdiin>  christian__> Can anyone suggest a good (GPL/LGPL) haskell project? Preferrably something rather small. It is mostly for self-educational purposes.
07:09:00 <Peaker> Beelsebob: :(makeRow' xs)
07:09:04 <Dynetrekk_> Beelsebob: that's anal retention for ya
07:09:10 <Beelsebob> Peaker: oh, good point
07:09:27 <Dynetrekk_> Peaker: those parens not necessary in general?
07:09:32 <Dynetrekk_> the : knows what is what?
07:09:40 <Dynetrekk_> i.e. has low priority or whatever
07:09:45 <mdiin> vixey: will try that. Why can't I do this though: (init xxs) ++ ((last xxs) ++ [v])
07:09:51 <mdiin> Where xxs is list of lists
07:09:58 <mdiin> ?
07:09:59 <Saizan> operators have lower priority than function application
07:10:11 <vixey> mdiin, I don't know
07:10:25 <Peaker> Dynetrekk_: prefix (func application, e.g: f x) is always "stronger" than infix (x:y)  so x:(f x)  can always become x:f x
07:10:26 <augustss> Dynetrekk_: If Complex has anything to do with complex numbers I suggest you use Data.Complex
07:10:30 <vixey> mdiin, maybe  init xxs ++ [last xxs ++ [v]]
07:10:31 <Saizan> mdiin: you can only append a list, not an element
07:10:51 <Beelsebob> Dynetrekk_: http://hpaste.org/13207#a4 <-- slightly more anally retentive
07:10:52 <christian__> Saizan: Looks great. Thanks!
07:11:02 <Dynetrekk_> augustss: in principle I agre, but this is all "educational" :)
07:11:11 <Dynetrekk_> Beelsebob: more anal or more retentive?
07:11:13 <mdiin> Saizan: but everything in there evaluates to lists?
07:11:13 <Dynetrekk_> or both
07:11:20 <Beelsebob> not sure, just more anal I think
07:11:33 <augustss> Dynetrekk_: And why run it in such a strange way?  "run with $ runghc dielectric.hs"
07:11:58 <mdiin> vixey: You nailed it! Thanks :)
07:12:12 <Saizan> mdiin: well yeah, but if you have [[a]], you can't append [a] to it, but only [[a]]
07:12:16 <Dynetrekk_> augustss:  I found out about that now
07:12:17 <Saizan> ?type (++)
07:12:18 <lambdabot> forall a. [a] -> [a] -> [a]
07:12:23 <Dynetrekk_> Beelsebob: your code does something different
07:12:27 <Dynetrekk_> I think
07:12:28 <Beelsebob> Dynetrekk_: oh?
07:12:33 <Axman6> http://chrisdone.com/haskell/unsafe.txt nice :)
07:12:37 <Dynetrekk_> your maprow is not the same?
07:12:47 <augustss> Dynetrekk_: do you actually use Control.Applicative?
07:12:53 <Dynetrekk_> don't know
07:13:00 <Axman6> unsafeNoReallyWeMeanItThisCouldLaunchNukesPerformIO
07:13:00 <Beelsebob> Dynetrekk_: second is a function which accepts a function and a tuple
07:13:05 <Peaker> I don't think Dynetrekk_ knows about type-classes yet
07:13:08 <Beelsebob> it applies the function to the second elemnt of the tuple
07:13:10 <vixey> mdiin, would the whole program be easier by the way, if lists consed up the other way? i.e. they grew on the right instead of left
07:13:15 <Axman6> unsafeNoReallyWeMeanItThisTimeAndToProveItWeAreGoingToMakeThisFunctionNameUnreasonablyLongToPersuadeYouNotToUseItTooFrequently
07:13:16 <Beelsebob> Peaker: no, I don't think so
07:13:22 <mdiin> saizan: Hmm. I just got the impression that last [[3]] == [3] - so I could append [4] to it with ++
07:13:31 <athos> hehe Axman6 :>
07:13:38 <chrisdone> :P
07:13:38 <Dynetrekk_> Beelsebob: second? it takes the second in a tuple?
07:13:41 <racliv> > [[3]] == [3]
07:13:42 <lambdabot>       No instance for (Num [t])
07:13:42 <lambdabot>        arising from the literal `3' at <inter...
07:13:46 <Beelsebob> Dynetrekk_: no -- that's snd
07:13:48 <Dynetrekk_> Beelsebob: not in scope
07:13:49 <Beelsebob> @type snd
07:13:50 <lambdabot> forall a b. (a, b) -> b
07:13:52 <Beelsebob> @type second
07:13:53 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
07:13:54 <Dynetrekk_> yeah, I thought so
07:14:01 <Dynetrekk_> Beelsebob: not in scope, your second is
07:14:11 <Saizan> mdiin: yeah, but then you've [3,4], and you can't append that to init [[3]]
07:14:11 <Beelsebob> Dynetrekk_: did you add the import Control.Arrow
07:14:22 <augustss> Dynetrekk_: I'd pattern match on the argument in rowToString instead of using fst and snd
07:14:23 <Saizan> ?type init [[3]]
07:14:24 <lambdabot> forall t. (Num t) => [[t]]
07:14:31 <Saizan> ?type [3,4]
07:14:32 <Dynetrekk_> Beelsebob: no...
07:14:32 <lambdabot> forall t. (Num t) => [t]
07:14:43 <athos> @type unsafeDiv
07:14:44 <lambdabot> Not in scope: `unsafeDiv'
07:14:45 <Dynetrekk_> augustss: okay, I see
07:14:48 <Beelsebob> Dynetrekk_: that's why then -- second is defined in there ;)
07:14:51 <athos> :]
07:14:56 <Axman6> @hoogle unsafe
07:14:56 <lambdabot> module Data.ByteString.Unsafe
07:14:57 <lambdabot> module System.IO.Unsafe
07:14:57 <lambdabot> Language.Haskell.TH Unsafe :: Safety
07:15:04 <Dynetrekk_> Beelsebob: makes sense
07:15:12 <Beelsebob> and ye, as augustss says -- I'd pattern match there probably
07:15:16 <Dynetrekk_> all right guys, thanks for a lot of help... I have to run now!
07:15:16 <mdiin> Saizn: Ah, I see now. I hadn't thought of the return type of init :S
07:15:18 <mdiin> Thanks
07:15:25 <Dynetrekk_> Beelsebob: sounds anally pleasing, yep.
07:16:09 <augustss> Dynetrekk_: Oh, and use ^2 instead of **2
07:16:09 <Beelsebob> http://hpaste.org/13207#a5 <-- for a final final final attempt
07:16:23 <mdiin> vixey: I donøt know, haven't thought about that. It's just an exercise from Real World Haskell
07:16:25 <Dynetrekk_> augustss: why? isn't one for float and the other for int?
07:16:26 <Beelsebob> oh wait
07:16:32 <augustss> Dynetrekk_: it's faster, and more general
07:16:33 <Dynetrekk_> :t ^
07:16:34 <lambdabot> parse error on input `^'
07:16:39 <Dynetrekk_> :t (^)
07:16:40 <augustss> :t (^)
07:16:41 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:16:41 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:16:44 <Dynetrekk_> :t (**)
07:16:45 <lambdabot> forall a. (Floating a) => a -> a -> a
07:16:52 <Dynetrekk_> augustss: how can it be both?
07:16:56 <vixey> mdiin, well something to consider :)
07:17:00 <Dynetrekk_> augustss: how does that justify the **'s existence?
07:17:02 <Beelsebob> Dynetrekk_: http://hpaste.org/13207#a6 <-- yay, managed more anality :)
07:17:18 <Dynetrekk_> Beelsebob: wow, if I want something anally, I know who to call
07:17:22 <augustss> Dynetrekk_: Sorry, not more general.  Different.
07:17:29 <athos> @type const
07:17:31 <lambdabot> forall a b. a -> b -> a
07:17:34 <Beelsebob> Dynetrekk_: yep ;)
07:17:44 <Saizan> Dynetrekk_: (^) is more restrictive in the exponent type, but since you use 2 anyway..
07:17:44 <Dynetrekk_> augustss: all right... well... I'll remember. ^works for both Float and Int I hope
07:17:51 <augustss> Dynetrekk_: ** uses log&exp, so it doesn't work for negative numbers necessarily.
07:18:05 <Dynetrekk_> Saizan: ah, I see , it's for integer exponents. probably faster, yes
07:18:09 <racliv> > deepmap [1, [2, [3, [4, [5, [6, [7, [8, [9, [10]]]]]]]]]] where deepmap f l = map (\x -> if length x > 0 then deepmap f x else f x) l
07:18:11 <lambdabot>       No instance for (Num [[[[[[[[[t]]]]]]]]])
07:18:11 <lambdabot>        arising from the liter...
07:18:18 <augustss> Dynetrekk_: Always use ^ if you have an integer exponent (not too big)
07:18:40 <Dynetrekk_> augustss: I'll remember
07:19:01 <Dynetrekk_> all right, merry christmas everyone
07:19:01 <Dynetrekk_> I have to go
07:19:05 <augustss> Dynetrekk_: Haskell has too many exponentiation operators. :)
07:19:06 <Dynetrekk_> see you around
07:19:12 <Peaker> racliv: you're list is ill-typed
07:19:12 <Dynetrekk_> augustss: indeed
07:19:52 <Peaker> racliv: a Haskell list is generally homogenously-typed
07:19:56 <athos> @src deepmap
07:19:57 <lambdabot> Source not found. My pet ferret can type better than you!
07:19:57 <Peaker> s/you're/your
07:19:59 <athos> ah
07:19:59 <athos> :>
07:21:38 <gwern> so anyone been using hlint?
07:21:39 <lambdabot> gwern: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:22:40 <vixey> I hadn't realized how quick dependent pattern matching gets undecideable :/
07:22:52 <gwern> @tell SamB_XP Those are the show instances for IO. they return a string and error too for good measure
07:22:52 <lambdabot> Consider it noted.
07:23:37 <racliv> > deepmap (+1) [1, [2, [3, [4, [5, [6, [7, [8, [9, [10]]]]]]]]]] where deepmap f l = map (\x -> if length x > 0 then deepmap f x else f x) l
07:23:39 <lambdabot>       No instance for (Num [[[[[[[[[t]]]]]]]]])
07:23:39 <lambdabot>        arising from the liter...
07:24:18 <vixey> :t [(), [()]]
07:24:19 <lambdabot>     Couldn't match expected type `()' against inferred type `[a]'
07:24:19 <lambdabot>     In the expression: [()]
07:24:28 <vixey> :t ((), ((), ()))
07:24:29 <lambdabot> ((), ((), ()))
07:24:45 <racliv> > null 6
07:24:46 <lambdabot>       No instance for (Num [a])
07:24:46 <lambdabot>        arising from the literal `6' at <inter...
07:24:56 <gwern> ouch, 199 suggestions from hlint for XMC
07:24:56 <Peaker> racliv: why do you have that kind of list?
07:25:06 <Peaker> racliv: sounds like what you want may be a tree?
07:25:25 <racliv> it's more just like an exercise i made up
07:25:31 <idnar> [1, [2, [3, [4, [5, [6, [7, [8, [9, [10]]]]]]]]]] is basically an impossible list
07:25:41 <gwern> 31 suggestions and a bunch of parse errors for xmonad proper
07:26:03 <sbahra> mmorrow, ping
07:26:11 <Peaker> hlint is nice
07:26:13 <eu-prleu-peupeu> this is great: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
07:26:54 <gwern> Peaker: indeed it is. the parser is a bit fragile w/r/t infix operator, and I have reason to blieve the list comprehension suggestions don't always work. but it's overall very good for a first release
07:27:04 <gwern> 308 suggestions for Yi :(
07:27:50 <Peaker> gwern: its yours?
07:28:12 <gwern> no, it's ndm's
07:28:27 <gwern> but I've been using it a lot this morning on shu-thing and monadius
07:28:44 <gwern> whigh together had hundreds of redundant brackets, it seems
07:36:47 <gwern> now if only I could figure out how to hack ghci to run hlint on a file whenever it's reloaded...
07:36:54 <gwern> it'd be like -Wall on steroids
07:36:55 <augustss> hlint is cool.  But I'll ignore some of its suggestions.
07:39:59 <athos> well, i don't like this list comprehension suggestion
07:40:20 <athos> from the HLint example
07:43:39 <dcoutts_> athos: is that the single place list comp trick?
07:43:56 <dcoutts_> > [ "yarr" | True ]
07:43:57 <lambdabot>   ["yarr"]
07:44:26 * dcoutts_ agrees with ndm that it's rather neat and quite readable once you get used to it
07:45:37 <idnar> what is?
07:47:22 <dcoutts_> idnar: list comprehensions with a guard and no generator
07:47:31 <idnar> oh, right
07:47:32 <dcoutts_> instead of: if foo then [bar] else []
07:47:38 <dcoutts_> [ bar | foo ]
07:48:00 <idnar> well, it's certainly a lot shorter
07:48:24 <Axman6> can anyone see the fatal floor in this code? "print . last . recipf .  randoms $ gen"
07:48:39 <Axman6> (recipf is an FFI function, not that it matters)
07:48:45 <Axman6> the results are not fun :)
07:49:03 <athos> dcoutts_: well, maybe i dislike it because i don't really understand it ;)
07:49:09 <vixey> it prints something?
07:49:14 <idnar> Axman6: fatal flaw, you mean?
07:49:16 <vixey> :t randoms
07:49:17 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
07:49:25 <Axman6> idnar: tat one too
07:49:29 <Axman6> that* rawr
07:49:33 <vixey> > length (randoms (mkStdGen 42))
07:49:34 <lambdabot>   Add a type signature
07:49:37 <vixey> > length (randoms (mkStdGen 42) :: [()])
07:49:39 <lambdabot>       No instance for (Random ())
07:49:39 <lambdabot>        arising from a use of `randoms' at <...
07:49:43 <vixey> > length (randoms (mkStdGen 42) :: [Integer])
07:50:17 <sutats> > take 5 (randoms (mkStdGen 42) :: [Integer])
07:50:21 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
07:50:38 <augustss> No instance for Random ()?  We should have one.  It's pretty easy.
07:52:28 <Axman6> bah, i'm failing at FFI :(
07:53:38 <vixey> I'm wondering how this ffi thing knows what to do with an infinite list
07:53:51 <athos> [ "foo" | "bazz" ]
07:53:55 <athos> > [ "foo" | "bazz" ]
07:53:56 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Char]'
07:54:41 <athos> > [ "foo" | (=='f') ]
07:54:42 <lambdabot>       The section `(== 'f')' takes one argument,
07:54:42 <lambdabot>      but its type `Bool' has...
07:55:06 <mux> well you can't pass haskell lists to FFI functions
07:55:30 <mm_freak> i installed the ConfigFile package through 'cabal install ConfigFile' as non-root, but this doesn't work:  Build-depends: base, ConfigFile, filepath, mtl, parsec
07:55:47 <mm_freak> what's the matter?
07:56:33 <pejo> mm_freak, you installed the ConfigFile as --user but want to install some other package as --global?
07:56:48 <mm_freak> pejo: no, both as the same user
07:56:51 <athos> > [ 'o' `elem` x | x <- "foo"]
07:56:52 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
07:56:58 <mm_freak> the one, which fails, is my own package i'm developing
07:57:06 <athos> > [ "o" `elem` x | x <- "foo"]
07:57:07 <lambdabot>   Couldn't match expected type `[[Char]]'
07:57:21 <Axman6> athos: what are you trying to do?
07:57:44 <mux> mm_freak: I believe you need to pass --user to the configure command if you want it to see modules in the user database
07:57:47 <mm_freak> > map (== 'o') "foo"
07:57:48 <lambdabot>   [False,True,True]
07:57:50 <mux> for your own code that is
07:58:09 <mm_freak> mux: even if i install them as a user anyway?
07:58:32 <mux> yes
07:59:46 <athos> > [ (x,y) | x <- [1,2], y <- [1,2] ]
07:59:48 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
08:00:01 <athos> > [ (x,y) | x <- [1,2,3], y <- [1,2,3] ]
08:00:02 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
08:00:30 <athos> ah, cool.
08:00:47 <sjanssen> @keal
08:00:48 <lambdabot> proofs are no longer sound
08:02:05 <augustss> @keal
08:02:05 <lambdabot> there is no way to prove the failsafe exists
08:02:16 <augustss> @keal
08:02:17 <lambdabot> i cant think anymore
08:02:23 <augustss> @keal
08:02:24 <lambdabot> with KealDigit quantum crackproof encryption possible
08:02:32 <athos> @hoogle sort
08:02:33 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
08:02:33 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
08:02:33 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
08:02:46 <mm_freak> honestly i like the monadic do-syntax much cleaner and better than list comprehensions
08:03:01 <mm_freak> > do x <- [1,2,3]; y <- [4,5,6]; return (x,y)
08:03:03 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:03:06 <Axman6> i don't for lists
08:03:51 <mm_freak> Axman6: they're equivalent, but you have better aligning options with do-notation
08:04:08 <Saizan> it's good for guards, but sometimes the implicit return gets annoying
08:04:32 <Japsu> > sequence [[1,2,3],[4,5,6]]
08:04:34 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
08:04:37 <mm_freak> yeah, and list comprehensions can get quite ugly
08:04:59 <mm_freak> > liftM2 (,) [1,2,3] [4,5,6]
08:05:00 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:05:42 <mux> > (,) <$> [1..3] <*> [4..6]
08:05:44 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:06:59 <Axman6> ghc -o foo foo.o Foo.o <-- that right there is why i like case insensitive (but preserving) file systems
08:07:02 <athos> ah ok
08:07:10 <athos> my idea went down quickly ;)
08:07:45 <athos> i thought list comprehension would suite for some simple permutation function (working on lists)
08:07:52 <sjanssen> Axman6: case insensitive filesystems can be rather annoying
08:08:05 <Axman6> i've never found that so
08:08:13 <mm_freak> athos: list comprehensions can be used to _build_ lists
08:08:22 <mm_freak> they are unsuitable for rearranging lists
08:08:22 <sjanssen> Axman6: we had an xmonad bug due to the bad mapping between Haskell module names and case insensitve filesystems
08:08:27 <athos> mm_freak: ok
08:08:31 <mm_freak> (rearranging lists is a bad idea anyway)
08:08:40 <Axman6> sjanssen: which FS?
08:08:56 <sjanssen> this bug prevents users from splitting their xmonad.hs
08:09:08 <sjanssen> Axman6: whatever Mac OS ships with, HFS+ nowadays?
08:09:13 <Axman6> yes
08:09:17 <dcoutts> mm_freak: were you using cabal install for both tasks? or were you using runghc Setup to configure your own package?
08:09:23 <Axman6> Xmonad is pretty broken on OS X anyway
08:09:32 <sjanssen> Axman6: shouldn't be
08:09:32 <mm_freak> dcoutts: the latter
08:09:46 <sjanssen> (if it is broken, probably has to do with Apple's lame toolchain)
08:09:49 <dcoutts> mm_freak: then use the former! or add --user when you configure via runghc Setup
08:09:58 <adekoba> I have a cabal package that includes a library and an executable. The library builds fine, but upon building the executable, an error is reported saying that the package is hidding. How do I fix this?
08:10:13 <Axman6> sjanssen: well X11 is pretty crap on OS X, and the way its used means that Xmonad can't run the way it was designed to
08:10:33 <dcoutts> mm_freak: there's really never any need to runghc Setup configure since cabal configure does the same thing (but with --user as default and other clever things).
08:10:40 <mm_freak> dcoutts: oh, i just installed with --user and it installed a lot of packages redundantly =/
08:10:45 <mm_freak> any easy way to revert this?
08:11:01 <dcoutts> mm_freak: you mean an easy way to uninstall packages?
08:11:14 <mm_freak> nope, an easy way to undo a huge installation
08:11:20 <dcoutts> mm_freak: for future reference, --dry-run is your friend
08:11:23 <mm_freak> most of the packages are already installed via portage
08:11:40 <mm_freak> i know --dry-run, but i thought, --user is necessary anyway
08:11:57 <sjanssen> Axman6: ah, in this case you're reffering to Apple's lame windowing system :)
08:11:59 <dcoutts> mm_freak: --user is the default
08:12:13 <Axman6> sjanssen: anyway, my issues with the alternative is that i don't see the point of having foo Foo FOO FoO fOo fOO etc in the same dir except to confuse yourself
08:12:29 <sjanssen> Axman6: yes, those are not useful
08:12:40 <Saizan> adekoba: add that package to build-depends in the executable stanza
08:12:48 <dcoutts> mm_freak: there's no simple automated uninstall yet, you have to delete files and unregister manually
08:12:50 <Axman6> sjanssen: you talking about quartz or xquartz?
08:13:21 <sjanssen> Axman6: I don't have a personal problem with case-insensitive filesystems, but thought I'd point out that there is no perfect solution
08:13:52 <sjanssen> Axman6: quartz.  Specifically that the architecture doesn't let you change how windows are managed
08:14:06 <mm_freak> dcoutts: deleting ~/.cabal and ~/.ghc should undo _all_ cabal-install installations safely, right?
08:14:31 <dcoutts> mm_freak: yes, though also looses all downloaded tarballs
08:14:40 <Saizan> ~/.ghc is enough
08:14:43 <Axman6> sjanssen: i don;t see that asd a bad thing personally. i like things like Xmonad, but they're ot for everyday users. and going the other way you end up with crap like KDE and Gnome
08:14:46 <dcoutts> mm_freak: if you don't care about disk space then ~/.ghc is enough
08:14:56 <adekoba> Saizan: it's the package itself.
08:15:03 <sjanssen> Axman6: at least you'd have the choice, is all I'm saying
08:15:09 <sjanssen> Apple apparently doesn't like choice
08:15:17 <mm_freak> Saizan: that will leave trash, won't it?  i can see binaries and libraries in ~/.cabal
08:15:20 <adekoba> Saizan: when I do that, I get a dependency cycle
08:15:37 <Saizan> adekoba: ah, then maybe the hs-source-dirs is not set properly?
08:15:40 <dcoutts> mm_freak: yes, but ghc and cabal will no longer know about them so they're not a problem
08:15:42 <mm_freak> i could delete everything but ~/.cabal/packages, i guess
08:15:47 <dcoutts> mm_freak: no, don't do that
08:15:58 <dcoutts> mm_freak: those are the only bits worth saving
08:16:16 <dcoutts> mm_freak: oh, sorry, I misread
08:16:42 <mm_freak> =)
08:16:46 <dcoutts> mm_freak: so yes, everything except ~/.cabal/packages
08:16:51 <adekoba> Saizan: why would that be an issue? The library is under lib/ and the executable is under ./
08:16:54 <mm_freak> ok, thanks
08:17:01 <adekoba> Saizan: I have hs-source-dirs: lib in the library secion
08:18:22 <adekoba> Saizan: http://hpaste.org/13208
08:18:36 <Saizan> adekoba: you've to put ., lib in the executable section, otherwise it can't find the library modules
08:18:47 <adekoba> Saizan: ah
08:19:11 <adekoba> Saizan: worked :D
08:19:55 <mm_freak> any easy way to rebuild all cabal-install packages after upgrading GHC?
08:21:00 <athos> @index unsafePerformIO
08:21:00 <lambdabot> System.IO.Unsafe, Foreign
08:21:21 <Saizan> mm_freak: no, you can only get a list of the installed packages with ghc-pkg list
08:24:09 <mm_freak> ok, seems like cabal-install is not the ultimate solution yet
08:25:41 <taruti> Why is deriving(Data) different with Data.Data and Data.Generics in ghc-6.10.1?
08:27:15 <taruti> "import Data.Generics; data F = A () | B (IO ()) deriving(Data,Typeable)" works fine with ghc, but "import Data.Data; data F = A () | B (IO ()) deriving(Data,Typeable)" fails with the same GHC with the error "No instance for (Data (IO ()))"
08:28:49 <Saizan> taruti: most of the point of Data.Data is to not export some controverse instances like (IO a)
08:28:54 <Saizan> afaiu
08:29:41 <Saizan> since they are partial
08:30:06 <taruti> hmm. so I need to depend on syb, export a Data instance for IO (dirty) or write the data instances for all datatypes like F by hand.
08:31:06 <Saizan> yeah
08:31:21 <edd____> Would anybody be willing to help me understand an error message I get when attempting a Real World Haskell exercise?
08:32:21 <adekoba> go ahead and state the issue
08:32:27 <Saizan> @paste
08:32:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:32:32 <edd____> http://hpaste.org/13209
08:32:45 <edd____> when I load it in ghci I get an error:
08:32:56 <orbitz> what am i doing wrong in terms of indentation here? http://hpaste.org/13210
08:33:19 <edd____> http://hpaste.org/13211
08:33:19 <Saizan> orbitz: indent "then" and "else" more
08:34:34 <orbitz> Saizan: thanks. i should upgarde my haskell-mode i guess
08:34:42 <Saizan> ?type (==)
08:34:44 <lambdabot> forall a. (Eq a) => a -> a -> Bool
08:35:21 <Saizan> edd____: (==) is a method of the Eq typeclass, and you're using it on accum which is of type [a]
08:35:38 <ziman> edd____, such error messages usually mean you need to add the mentioned constraint to the type signature: myGroupBy :: (Eq a) => (a -> a -> Bool) -> [a] -> [[a]]. You need that because you compare lists of a using ==.
08:35:39 <Saizan> edd____: so it requires 'a' to be an instance of Eq as well
08:36:01 <Saizan> edd____: however the best way to test if a list is empty is to use null
08:36:04 <Saizan> > null []
08:36:05 <lambdabot>   True
08:36:06 <Saizan> > null [1]
08:36:07 <mm_freak> Saizan: side note:  use the 'null' function instead of (== [])
08:36:07 <lambdabot>   False
08:36:23 <Saizan> @quote fugue
08:36:24 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:36:25 <Saizan> :)
08:36:49 <edd____> Saizan: ah, ok. I haven't come across these constraints yet, so will using the null function work for now?
08:37:13 <Saizan> edd____: yeah, or you could use pattern matching
08:37:13 <mm_freak> uhm
08:37:22 <mm_freak> sorry, that side note was meant for edd____ =)
08:37:24 <athos> @type filterM
08:37:25 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
08:37:27 <mm_freak> not for Saizan
08:37:30 <athos> @type filter
08:37:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:37:42 <edd____> Saizan: ok, perfect. thanks very much
08:37:56 <athos> @type liftM2
08:37:57 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:38:46 <ttt--> hi, does anyone here use scion? http://github.com/nominolo/scion/tree/master
08:38:58 <ttt--> i get an error when i do (require 'scion)
08:39:24 <ttt--> Debugger entered--Lisp error: (error "Required feature `scion' was not provided")
08:41:04 <edd____> Actually, which would using pattern matching be preferrable for this? I haven't yet developed any intuition about when it would be better
08:41:48 <mm_freak> edd____: pattern matching is always preferable over guards
08:42:01 <Saizan> edd____: http://hpaste.org/13209#a1
08:42:16 <edd____> mm_freak: what's the reason for that?
08:43:19 <edd____> Saizan: thanks! The book hasn't introduced one of the things you're using there (@), but I'll come back to your code when I encounter it
08:43:47 <Saizan> because instead of testing and decomposing later, you can just try to decompose, and if it works you also have the knowledge provided by the test
08:44:23 <edd____> Ah I see. Makes sense
08:44:52 <mm_freak> edd____: pattern matching uses the inherent structure of the type instead of functions operating on that structure
08:45:12 <Saizan> edd____: ah, right, it's simple, foo accum@(x:xs) = ... is the same as foo (x:xs) = ... where accum = x:xs
08:45:41 <mm_freak> xs == [] needs to do an equality comparison, where no comparison is necessary…  an empty list is empty by structure, not by value
08:46:00 <edd____> Saizan: ah I see. I could have used that lots up to now!
08:46:09 <koeien> mm_freak: you could get around that by using "null xs", which is a pattern match "under water"
08:46:21 <vixey> > null [id, reverse, tail]
08:46:22 <lambdabot>   False
08:46:23 <mm_freak> koeien: that's the point ;)
08:46:24 <vixey> > (== null) [id, reverse, tail]
08:46:26 <lambdabot>   Couldn't match expected type `[a] -> Bool'
08:46:27 <athos> fooBar baz >>= someF is the same as fooBar baz >>= \x -> someF x, which is the same as do {x <- fooBar baz; someF x}, isn't it?
08:46:34 <koeien> but pattern matching is clearer
08:46:34 <edd____>  mm_freak: but both an equality comparison and decomposition are performed at runtime, right?
08:46:43 <vixey> > (== ][) [id, reverse, tail]
08:46:44 <lambdabot>   <no location info>: parse error on input `]'
08:47:37 <edd____> so even though no comparison is necessary in the sense of ==, there still has to be some underlying comparison performed somewhere
08:47:45 <edd____> to compare structure?
08:48:47 <koeien> edd____: no, but the compiler doesn't know that. the type of (== [] ) is (Eq a) => [a] -> Bool
08:49:31 <edd____> That's a constraint (Eq)?
08:49:36 <koeien> edd____: right
08:49:48 <edd____> I'll have to wait until I come across those
08:49:59 <koeien> ok
08:50:15 <edd____> Right, well I have enough to go on. Thanks all!
08:50:18 <vixey> you just came across it here
08:50:36 <edd____> vixey: sure, but I don't what it does yet
08:50:55 <edd____> I will soon, though :)
08:51:28 <mm_freak> edd____: pattern matching may need an implicit comparison, but that's a compiler detail
08:52:08 <mm_freak> in some cases, it may get away without comparison
08:52:26 <edd____> mm_freak: sure, I just like to have some kind of intuition about what's going on behind the scenes. I guess that will come with practice/time and I'll have to let it go for now
08:53:25 <mattam> > [id, reverse, tail]
08:53:26 <lambdabot>       Overlapping instances for Show ([a] -> [a])
08:53:26 <lambdabot>        arising from a use o...
08:53:30 <b_jonas> but that's only numeric and string patterns, right?
08:53:33 <mm_freak> edd____: it's better not to bother about compiler details, really
08:53:41 <mm_freak> that's a good thing to do in C, but not in haskell
08:53:46 <b_jonas> it's not detail but syntactic sugar I think
08:53:55 <vixey> I don't think it's a good thing in C
08:54:16 <b_jonas> that never generates extra constraints though because numbers and strings are Eq anyway
08:54:34 <mm_freak> vixey: but at least better than in haskell…  at times, where i considered such details, my code went awfully ugly
08:54:44 <edd____> mm_freak: Well the reason I started to learn this language was because of its efficiency, I'm (too?) afraid of losing some of it by using constructs inappropriately
08:55:04 <athos> :t mymap f xs = xs >>= return.f
08:55:04 <mm_freak> edd____: use proper constructs and know what they do
08:55:05 <lambdabot> parse error on input `='
08:55:21 <mm_freak> edd____: but better don't bother about how they are implemented in the interpreter/compiler
08:55:37 <koeien> at least until you have a better understanding what's going on
08:55:39 <athos> @type \f ys -> ys >>= return.f
08:55:40 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
08:55:45 <koeien> in the beginning i wouldn't worry about it
08:55:46 <mm_freak> athos: myMap = liftM
08:55:55 <mm_freak> =)
08:56:03 <athos> @type liftM
08:56:04 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:56:04 <edd____> yep, it's knowing what "proper constructs" are though, hence my query about guards/pattern matching
08:56:11 <athos> mm_freak: ah. cool! :)
08:56:18 <koeien> yeah, i've written that function before as well :)
08:56:22 <Saizan> edd____: it's generally safe to imagine each constructor as a tag + pointers to the fields it contains, so yeah there's a check at runtime on which constructor get passed to the function
08:56:27 <koeien> until i came across liftM
08:56:45 <mm_freak> athos: whenever you find code that reads '>>= return . f', you should consider liftM or fmap
08:56:55 <edd____> Saizan: ok, thanks
08:57:14 <Saizan> edd____: modulo optimizations :)
08:57:17 <edd____> :)
08:57:26 <athos> mm_freak: well, i was just curious if a "general map" (maybe that's not the appropriate word) would be something like \f ys -> ys >>= return.f
08:58:35 <blueonyx> what does The type signature for `evolveOne' lacks an accompanying binding mean?
08:59:02 <athos> @hoogle evolveOne
08:59:02 <lambdabot> No results found
08:59:10 <blueonyx> its my function ;D
08:59:11 <mm_freak> athos: yes, that's one way to generalize maps
08:59:19 <mm_freak> athos: but probably fmap is a more useful generalization
08:59:21 <athos> mm_freak: i guess there are better ways to do so ;)
08:59:23 <asmdel> 18:09 <     athos> mm_freak: i guess there are better ways to do so ;)
08:59:23 <athos> yeah
08:59:24 <asmdel> 09 <  blueonyx> its my function ;D
08:59:26 <mm_freak> or let's say, more general
08:59:31 <asmdel> 1818:09 quit       < drdozer!n=drdozer@79-64-140-23.dynamic.dsl.as9105.com [Read error: 110 (Connection timed out)]
09:00:35 <blueonyx> oh my fault
09:05:59 <vixey> Are there any notes like Simply Easy about implementing data?
09:09:22 <augustss> implementing data?
09:11:32 <racliv> > rg 0 10 2 where rg min max step = filter (\x -> mod (x - min) step == 0) [min..max]
09:11:33 <lambdabot>   [0,2,4,6,8,10]
09:11:41 <racliv> @pl rg min max step = filter (\x -> mod (x - min) step == 0) [min..max]
09:11:41 <lambdabot> rg = ap ((.) . flip . (filter .) . flip flip 0 . ((flip . ((==) .)) .) . flip . (mod .) . subtract) enumFromTo
09:12:16 <racliv> @unpl rg = ap ((.) . flip . (filter .) . flip flip 0 . ((flip . ((==) .)) .) . flip . (mod .) . subtract) enumFromTo
09:12:17 <lambdabot> rg = (\ ae b c f -> filter (\ p -> (mod (subtract ae p) f) == 0) (b c)) >>= \ x -> enumFromTo >>= \ w -> return (x w)
09:15:39 <Martijn> @pl \f x y -> rev (asc f x y)
09:15:39 <lambdabot> ((rev .) .) . asc
09:16:43 * Martijn wonders if there's a more intuitive way than nesting .'s like that.
09:17:41 <gwern> does anyone know how to rebind :reload in ghci to run hlint on the file first and then load it?
09:17:52 <vixey> :t \f -> ?rev . ?asc f
09:17:53 <lambdabot> forall b c t a. (?asc::t -> a -> b, ?rev::b -> c) => t -> a -> c
09:18:03 <vixey> :t \f x y -> ?rev (?asc f x y)
09:18:04 <lambdabot> forall t t1 t2 t3 t4. (?asc::t2 -> t3 -> t4 -> t, ?rev::t -> t1) => t2 -> t3 -> t4 -> t1
09:18:19 <vixey>  not the same
09:19:31 <Martijn> Nope
09:19:52 <vixey> augustss, I am wondering how to add data definitions to something like simply easy/ier
09:24:35 <gwern> bah, these preprocessor options aren't working
09:24:42 * gwern shakes fist at http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#pre-processor
09:30:43 <gwern> confusing. if I creae a tmp.sh which looks like 'cp $2 $3 && hlint $2', then :set -F -pgmF tmp.sh sort of works
09:30:48 <gwern> I think
09:31:44 <gwern> looks like it fails on loading a module which requires other files
09:31:52 <vixey> http://www.cs.chalmers.se/ComputingScience/Research/Functional/Pictures/logo.gif
09:32:35 <gwern> vixey: it's old and terrible we got it already
09:35:53 <gwern> dang it, this would be easier if one could overwrite the :reload or :load bindings on ghci
09:36:03 <Martijn> @src on
09:36:04 <lambdabot> (*) `on` f = \x y -> f x * f y
09:41:41 <gwern> > 1 !! [1..10]
09:41:42 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
09:41:48 <gwern> > [1..10] !! 1
09:41:50 <lambdabot>   2
09:43:27 <Martijn> @pl \f -> f 5
09:43:27 <lambdabot> ($ 5)
09:43:36 <Martijn> @pl \f -> f 5 6
09:43:36 <lambdabot> flip ($ 5) 6
09:43:43 <Martijn> @pl \f -> f 5 6 7
09:43:44 <lambdabot> flip (flip ($ 5) 6) 7
09:43:53 <Martijn> Bah
09:45:48 <Martijn> I wonder if there are things @pl can't handle
09:46:27 <shapr> Martijn: Try it on your box with quickcheck?
09:46:54 <Martijn> I'm not sure how I would do that
09:48:15 <shapr> Martijn: Find some sort of data type that represents Haskell code, get QC to generate random values for that, then feed them into @pl, see if anything breaks.
09:49:19 <Martijn> I'm more thinking about the theory behind @pl -- can any pointful lambda be converted to a pointless one?
09:49:32 <Saizan> yes
09:50:12 <shapr> There's a neat paper about the history of lambda calculus that talks about that discovery.
09:50:48 <Martijn> Obviously @pl uses specific instances of, say, Monad so that it will use, say, liftM2 at appropriate places. That makes me wonder what the minimal set of needed functions is.
09:51:12 <Martijn> I imagine . and $ will be in there.
09:52:10 <shapr> @users
09:52:10 <lambdabot> Maximum users seen in #haskell: 575, currently: 552 (96.0%), active: 9 (1.6%)
09:52:15 <shapr> spiffy!
09:52:19 <chrisdone> married(X,Y) ^ father(Y,Z) ⇒ mother(X,Z)
09:52:23 <chrisdone> si this correct logic notation?
09:53:26 <chrisdone> Wife and Husband are married and Husband is the father of Child implies Wife is the mother of Child
09:53:40 <gwern> 'The :def command, documented here, allows quite GHCi's commands to be extended in quite a powerful way. ' <-- lies! villainous lies! until one can feed a :foo command into a haskell expression tis viciously false
09:53:52 <Saizan> Martijn: the SKI combinator calculus is one
09:53:53 <Spark> chrisdone: step mother at least
09:54:04 * shapr boings cheerfully
09:54:20 <Spark> chrisdone: you need to update your model to reflect today's broken society :)
09:54:22 <chrisdone> Spark: yeah, it's just a generalisation example from SICP
09:54:28 <chrisdone> Spark: haha, yes ;)
09:54:40 <dmhouse> Saizan: that's not quite minimal, though.
09:54:53 <chrisdone> I'm not sure about the precedence
09:55:00 <chrisdone> is ^ higher than ⇒?
09:55:11 <Spark> err yes
09:55:20 <chrisdone> (married(X,Y) ^ father(Y,Z)) ⇒ mother(X,Z)  or  married(X,Y) ^ (father(Y,Z) ⇒ mother(X,Z))
09:55:31 <chrisdone> mkay
09:55:36 <Spark> ⇒ is usually fairly weak
09:55:46 <Spark> like ==
09:55:50 <chrisdone> sure
09:55:54 <Spark> i haven't got a key bound to that, ⇐⇒ might work though
09:56:18 <Spark> a bit stupid since i have keys bound to do ⇑⇓ and ↤↥↦↧
09:56:23 <chrisdone> haha
09:56:28 <vixey> hi shapr
09:56:33 <chrisdone> yeah, I need bidirectional
09:57:02 * chrisdone consults xmodmap
09:57:10 <vixey> Martijn, S and K combinators are equivalent to simple lambda calculus
09:57:13 <chrisdone> Spark: its unicode value is 8660
09:57:53 * shapr hugs vixey 
09:57:55 <hydo> I love it when it's icy outside... everyone is slipping and sliding down the sidewalk while I trudge around in golf shoes.
09:58:08 <shapr> vixey: Spiffy greetings and all sorts of goodness! How's life treating you?
09:58:08 <hydo> damnit.. wrong window.
09:58:18 <chrisdone> hydo: going for a good ole' lynching?
09:58:27 <shapr> hydo: Haskell helps me keep a grip too ;-)
09:58:50 <hydo> chrisdone: I'm not following you.
09:59:30 <Spark> ⇔
09:59:34 <Spark> that looks awful in misc.fixed
10:00:15 <chrisdone> Spark: looks alright in Monaco
10:00:36 <Spark> even the double one is still too small ⟺
10:00:43 <Spark> is that a fixed width font?
10:00:54 <chrisdone> yeah
10:01:00 <Spark> free?
10:01:03 <chrisdone> from the Mac, but I got a Linux version
10:01:12 <Spark> ah it'll be blurred then
10:01:27 <vixey> shapr, conspicuously
10:01:35 <vixey>  ai
10:01:36 <chrisdone> Spark: http://chrisdone.com/font.png
10:01:42 <vixey> wrong word, nvm :p
10:02:05 <Spark> chrisdone: what is that rendered with, pango?
10:02:17 <chrisdone> Spark: it's gnome-terminal, so I think so
10:02:37 <Spark> that looks less awful than pango fonts normally look
10:02:42 <chrisdone> Spark: subpixel rendering, I believe
10:02:50 <Spark> yeah i can see that
10:02:52 <Spark> with xmag
10:03:03 <chrisdone> yeah, not as blurry, more crisp but not like blocks of lego or pixelated
10:03:05 <chrisdone> what's xmag?
10:03:16 <chrisdone> ah, duh
10:03:38 <Spark> the k of Spark is a bit fuzzy
10:03:58 <cnwdup> With what do I have to compile my program if it's using forkIO? Currently it blocks after the first call of forkIO which isn't what I want. I doesn't block using ghci.
10:04:15 <dons> cnwdup: ghc -O2 -threaded
10:04:20 <cnwdup> dons: thanks
10:04:27 <dons> cnwdup: see simonpj's intro to parallel programming for haskell
10:04:42 <dons> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/index.htm
10:04:50 <cnwdup> Thank you
10:04:54 <chrisdone> Spark: yeah, I guess so
10:05:53 <dons> http://www.reddit.com/r/programming/comments/7ks60/new_simon_peyton_jones_tutorial_on_multicore/
10:05:57 <dons> yay
10:06:26 <chrisdone> ^_^!!!
10:08:21 <sbahra> Hi.
10:08:48 <sbahra> dons, I was hoping you knew who I would need to talk to about mailing lists on haskell.org.
10:08:48 <dagnachew> hi
10:08:54 <sbahra> dons, any ideas?
10:10:14 <sbahra> dons, a haskell list may be created @FreeBSD.org, however, I'm thinking a freebsd-discuss or similar would be better suited @haskell.org instead.
10:10:34 <Heffalump> sbahra: FWIW the debian-haskell list is on debian.org, not haskell.org
10:11:00 <sbahra> Heffalump, sure. But why?
10:11:04 * gwern sighs and gives up on hlint and ghci playing together. maybe someone else knows
10:11:07 <cnwdup> Is it worth the trouble writing X11 code that redraws only the parts of the application which are needed or should one stick to the "redraw everything on expose" policy?
10:11:15 <Heffalump> dunno really :-)
10:11:37 <sbahra> Heffalump, I think it is better to be @haskell.org. Any FreeBSD committers may help out the FreeBSD project@Haskell.
10:12:08 <sbahra> Heffalump, but if it is Haskell@FreeBSD, some committers will be marked as "responsible" for Haskell on FreeBSD. They leave, the effort leaves with them (this is what happened with the previous Haskell effort and KDE on FreeBSD).
10:12:13 <mpeter> can i get a haskell.org email ;)
10:12:37 <mpeter> and of course, accompanying shell account and sudoers privileges
10:12:38 <gwern> if mpeter gets one, I want one too!
10:12:43 * gwern sticks out tongue at mpeter 
10:12:51 <mpeter> idiot!
10:12:52 <sbahra> Have a very small team now, me, another guy and a committer.
10:12:59 <mpeter> dons, she's making faces at me!
10:13:03 <Heffalump> sbahra: fair enough
10:17:32 <paper_cc> Hello. Is there a way to use ARB_{vertex,fragment}_program in HOpenGL?
10:19:13 <gwern> 'Common Lisp Weekly News'? sounds like HWN envy :)
10:19:25 <vixey> lol
10:32:16 <dons> sbahra: arch-haskell@haskell.org btw.
10:33:40 <sbahra> dons, nice
10:33:43 <chrisdone> I like how haskell {- -} comments are nested
10:33:55 <sbahra> dons, well, I was wondering who I would talk to about getting freebsd-haskell@haskell.org?
10:35:54 <mpeter> and i was wondering who i could talk to about getting ksah@haskell.org
10:36:16 <sbahra> ;[
10:37:00 <Saizan> ksah?
10:38:19 <dons> sbahra: ah, JaffaCake
10:38:53 <sbahra> dons, cool, thank you.
10:39:09 <sbahra> @ask JaffaCake Any chance of creating freebsd-haskell@haskell.org?
10:39:09 <lambdabot> Consider it noted.
10:57:48 <redditbot> Simon Peyton Jones' tutorial on parallel and multicore programming in Haskell
11:01:31 <sbahra> eh
11:03:24 <ziman> umm, fresh SPJ stuff :)
11:06:00 <gwern> > 1776 - 1711
11:06:02 <lambdabot>   65
11:09:55 <orbitz> Woooo! i got this I/O code from 1m45s to 1m4s
11:10:28 <gwern> (you know, it's a tad sad that implementing space invaders in FRP justifies a 12 page 3-author ICFP paper)
11:11:04 <dons> gwern: hmm. no.
11:11:23 <dons> this was about demonstrating FRP was practical, which is perfectly acceptable considering the time.
11:11:37 <vixey> gwern, welcome to functional programming!
11:11:53 <gwern> vixey: hush you. I'm ragging on FRP here, not FP
11:12:09 <vixey> gwern, have you seen my FRP implementation of factorial? :)))
11:12:21 <gwern> dons: but 12 pages? if you want to demo it, you post a tarball to -cafe or something
11:12:40 <gwern> and maybe give a short talk where you compile and let people watch you play it
11:12:46 <gwern> vixey: never
11:13:26 <gwern> and 3 authors? well, at least now we know how many haskellers it takes to screw in a FRP bulb
11:13:50 <gwern> or maybe they delegated - one created the graphics in photoshop, one wrote the program, and the third wrote the paper :)
11:14:51 <BMeph> gwer: So, where is this paper that's breaking your heart, gwern? ;p
11:15:05 <gwern> BMeph: proggit, iirc
11:15:13 <BMeph> *gwern (stupid wireless kybd)
11:15:13 <gwern> or maybe it's haskell.reddit. I never can tell these days
11:16:49 <gwern> hm. wait, didn't I put that space invaders up on hackage?
11:17:32 <gwern> (nope. 'twas KidoTakahiro.)
11:19:06 <gwern> ....this is a very strange space-invaders
11:20:30 <gwern> oh! it's mouse-based!
11:28:43 <mm_freak_> portage installs parsec 3, while cabal-install installs parsec 2
11:29:04 <mm_freak_> any way to tell cabal-install to use the newest version?
11:31:11 <Saizan> mm_freak_: cabal install "parsec >= 3", it defaults to 2 since that's the stable one
11:31:19 <mm_freak_> ah ok, thanks
11:31:57 <gwern> parsec-3 had big slowdowns, iirc
11:32:05 <gwern> qc 2 on the other hand just broke stuff
11:36:54 <vixey> why do you call sums coproducts?
11:41:57 * gwern squints at 'tx :: String = "Thu Oct 14 05:40:06 CEST 2004 "'. the heck? that's valid?
11:43:01 <mm_freak_> Warning: This package indirectly depends on multiple versions of the same
11:43:01 <mm_freak_> package. This is highly likely to cause a compile failure.
11:43:07 <mm_freak_> if it does not, is it all well?
11:43:52 <gwern> mm_freak_: maybe. sometimes that's a problem. often not
11:44:03 <Saizan> mm_freak_: if it compiles it will work fine
11:44:37 <mm_freak_> ty
11:47:39 <orbitz> i like to oat, oat, oat opple and bononos
11:48:59 <solrize_> *Main> let a::Float = 5
11:48:59 <solrize_> <interactive>:1:4:
11:48:59 <solrize_>     Illegal signature in pattern: Float
11:48:59 <solrize_>         Use -XPatternSignatures to permit it
11:49:01 <solrize_> aha
11:50:16 <orbitz> solrize_: odd i get a different error
11:50:32 <orbitz> or rather, i get a different suggestion on how to be abel to use it
11:54:54 <solrize_> hmm
12:05:53 * gwern lieks the busy beaver numbers. B1: 1. B2: 6. B3: 21. B4: 107. B5: ~47,176,870. B6: > ~2.5 * 10^2879
12:07:25 <dons> woo http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-trie-0.1
12:08:39 <gwern> what does one use a bytestring trie for?
12:08:40 <dons> is wren thornton here?
12:08:44 <dons> gwern: like an IntMap
12:08:53 <dons> is it s abytestring-keyed map structure, that is faster than a genricc map
12:09:47 <luite_> dons: ooh fun :)
12:09:51 <gwern> hm, so just text-based applications? 'search the dictionary for a given word' and so on?
12:09:52 <dcoutts> dons: yes, that looks good
12:10:05 <orbitz> dons: faster than Map ByteString a?
12:10:38 <gwern> orbitz: must be, else why would anyone bother?
12:10:41 <solrize_> oh cool
12:10:51 <solrize_> data.map is slow
12:10:53 <orbitz> gwern: pick up chicks
12:11:02 <solrize_> on bytestrings
12:11:17 <orbitz> solrize_: what about String?
12:11:22 <solrize_> even slower
12:11:35 <orbitz> really
12:11:35 <orbitz> hrm
12:11:44 <orbitz> maybe i shoudl unpack these small bytestrings i'm usign as keys in teh map here
12:12:58 <solrize_> actually i'm maybe confused
12:13:18 <solrize_> one of the first haskell programs i wrote read a lot of small strings into data.map
12:13:26 <solrize_> and it was quite a bit slower than the python equivalent
12:13:40 <solrize_> but i'm not certain that data.map itself was the bottleneck
12:14:08 * orbitz is trying to get some code that i smostly I/O bound as fast as pssible, so far it seems pretty slow
12:14:24 <solrize_> well if it's i/o bound...
12:15:00 <orbitz> well the task should be I/O bound, but the code i've written is rather poor so it's not
12:15:05 <solrize_> oh ic
12:15:41 <orbitz> i finally switcehd from hGetContents to hGetLine :: ByteString which sped it up a lot, but it still seems slow
12:16:33 <gwern> orbitz: now that you've prototyped in haskell, you can go write the real program in a real language like C
12:16:46 <taruti> Is there a way to do String -> Language.Haskell.TH.Exp, or does that need to be written?
12:17:28 <Saizan> orbitz: the String hGetContents ?
12:17:37 <orbitz> gwern: i'd prefer to keep it in haskell :)
12:17:47 <gwern> no, he said he used bytestring's hGetLine
12:18:00 <luite_> is there anything that's significantly faster (or better optimizable) than STUArray?
12:18:04 <taruti> lazy bytestring hGetContents...
12:18:07 <orbitz> Saizan: I'm using ByteString for all my I/O. I swithed from the .Lazy with hGetContents to the non lazy with hGetLine
12:18:11 <Botje> luite_: C? :)
12:18:15 <taruti> ah
12:18:25 <luite_> Botje: short of using FFI ;)
12:18:43 <solrize_> orbitz did you use bytestring.lines to split up the hgetcontents?
12:18:57 <orbitz> solrize_: yes
12:19:01 <solrize_> hmm
12:19:07 <luite_> Botje: my code is still slower than equivalent code in other languages, I was wondering if the more flexible indexing of STUArray could cause some overhead
12:19:11 <Saizan> taruti: going via haskell-src-exts: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
12:19:12 <gwern> strict bytestrin doesn't have hGetContents?
12:19:19 <orbitz> my previous implementation took 3m30s, once i switcehd to hGetLine it was 1m4s
12:19:19 <gwern> @hoogle hGetContents
12:19:19 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
12:19:19 <lambdabot> System.IO hGetContents :: Handle -> IO String
12:19:19 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
12:19:32 <gwern> hm. Char8 is strict, isn't it?
12:19:45 <orbitz> gwern: that one is
12:19:49 <Saizan> the strict hGetContents is strict
12:19:49 <orbitz> i think
12:19:59 <Saizan> so it loads everything in memory up front
12:20:06 <gwern> intuitively, I would expect lines . hGetContents to be faster than a hGetLine loop, if you're IO bound
12:20:08 * orbitz is trying to be able to process really large files or really small files
12:20:11 <taruti> Saizan: thanks
12:20:41 <orbitz> gwern: at this point it could be somethign else i'm doing.  every line i parse and then check if it's in a Data.Map.
12:21:07 <Saizan> orbitz: tried profiling?
12:21:17 <orbitz> Saizan: not, yet. next step
12:21:31 * orbitz is processign 6.3 gigs, still goign and it's eben 50 minute s:(
12:21:49 <vinc456> what is the type of ":t ()" called again?
12:21:57 <gwern> unit?
12:22:13 <gwern> .prof is dumped while in progress, iirc, so I'd re-compile and kill it after 10 or 20 minutes
12:22:19 <idnar> vinc456: in HAskell, it's called () :P
12:22:20 <BMeph> Why isn't profiling every one's first resort, instead of their last? :\
12:22:33 <luite_> is there a mutable variant of UVectors?
12:22:38 <idnar> BMeph: because it's so hard to interpret the results
12:22:59 <dons> luite_: uvector MUArrs are mutable
12:23:02 <gwern> quite.
12:24:27 <athos> hmm.. i've some data constructor: Foobar x y = Baz x y | Foo x | Bar x and i want to write some eval functions, which take's a foobar, and produces a suitable type: so at first i implemented Bar, which is quite easy.
12:24:56 <luite_> dons: ah, I'll try that then. Hopefully my haskell code will finally beat my java implementation ;)
12:25:01 <athos> but let's imagine i want to match for: Foo x, which should for example return a constant function returning x
12:25:10 <athos> so eval (Foo x) = \x -> x
12:25:21 <athos> but now i got problems with the type of the function
12:25:35 <Botje> athos: you probably mean \y -> x
12:26:15 <Botje> athos: can you show concrete code on hpaste.org?
12:26:40 <athos> yeah, that'll make it easier
12:27:49 <athos> so what i actually want to do is to play a bit with SKI calculus. but i maybe my data constructor for it is already wrong
12:27:52 <athos> http://hpaste.org/13214
12:27:55 <athos> (S Combinator not implemented yet)
12:28:42 <athos> i'm really stuck with the types
12:28:47 <Botje> athos: you'll probably have to use some other data type for the runtime data
12:31:28 <athos> Botje: you mean for my eval function?
12:31:32 <solrize_> anyone know if there's an extended gcd function in hackage somewhere?  it's not in the obvious places
12:31:55 <Botje> athos: yeah
12:32:03 <athos> Botje: ok, i'll contemplate about that
12:32:14 <athos> seems like a little challenge for me, but that's ok :)
12:32:20 <athos> actually that's good
12:33:49 <BMeph> solrize_: I'm curious - what /is/ "an extended gcd function"? :)
12:34:18 <solrize_> bmeth, xgcd x y = (a,b) such that ax+by=1
12:34:38 <solrize_> or rather, ax+by= gcd x y
12:35:19 <solrize_> basically you run the euclidean gcd algorithm but keep track of the quotients as well as the remainders
12:35:33 <solrize_> you use it if you want to find a modular inverse
12:35:46 <athos> Botje: well, i first have to change the Combinator data type :)
12:36:18 <athos> because combinators can have combinators as argument, too
12:36:21 <Botje> athos: your constructors should probably take another Combinator argument, i think
12:36:30 <Botje> so S Combinator Combinator | ...
12:36:40 <athos> yeah :)
12:37:00 <solrize_> http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
12:38:00 <BMeph> solrize_: Ah, interesting...
12:38:03 * BMeph reads
12:56:37 <athos> @pl \x,y,z -> foo x z (foo y z)
12:56:37 <lambdabot> (line 1, column 5):
12:56:37 <lambdabot> unexpected ","
12:56:37 <lambdabot> expecting letter or digit, operator, pattern or "->"
12:56:37 <lambdabot> ambiguous use of a non associative operator
12:56:45 <athos> @pl \x y z -> foo x z (foo y z)
12:56:46 <lambdabot> (. foo) . ap . foo
12:57:50 <redditbot> bytestring-trie: efficient string-indexed finite maps
13:07:21 <birkenfeld> hmm... wasn't there a neat way to generate functions to update single record fields?
13:07:28 <birkenfeld> like
13:07:36 <birkenfeld> updateFoo f r = r { foo = f (foo r) }
13:07:51 <Liskni_si> drift or data.derive
13:08:20 <athos> Botje: ah, i see.. my "eval" function (maybe that's not the appropriate term) must return a Combinator
13:08:39 <athos> of course you can "evaluate" I x to x, but eval (K x) is always K x
13:09:41 <paolino> is there a way to make an Monad instance for a type ?
13:10:11 <paolino> typesynonym, sorry
13:13:07 <Botje> yes, there's a language extension for it
13:13:17 <Botje> TypeSynonymInstances, iirc
13:13:46 <paolino> I tried with TtpeSynonymInstances, and LiberalTypeSynonym, but still couldn't partially apply the synonym
13:14:00 <Botje> oh
13:14:10 <Botje> that's something different then
13:15:19 <paolino> well Monad wants a * -> * as member, right ?
13:16:19 <gwern> LiberalTypeSynonym? whoa now let's not drag politics into this
13:16:43 <orbitz> hrm, so 76% of my time is spent in gc
13:16:46 <Heffalump> I don't think there's any extension for partial synonym application
13:16:48 <orbitz> that sounds bad?
13:16:56 <gwern> yes
13:17:09 <Heffalump> as that would require quite a lot from the type checker (as it opens up type-level lambda)
13:17:50 <Saizan> orbitz: very bad
13:18:03 <orbitz> hrm
13:18:15 <orbitz> i must be doign things very non-haskell
13:18:21 <Saizan> use heap profiling to see what's going on
13:18:30 <EvilTerran> paolino, FlexibleInstances?
13:18:58 <gwern> or you could 1) post it to -cafe, 2) add a line saying this proves haskell is slow and 3) ??? 4) profit
13:19:35 <EvilTerran> paolino, note that a type synonym has to always be applied to all the explicit parameters (as they appear in the "type" decleration) wherever you use it
13:20:00 <EvilTerran> paolino, ie, "type List a = [a]" would always have to be fully-applied; "type List = []" wouldn't
13:20:01 <opqdonut> gwern: :D
13:20:42 <orbitz> gwern: haah
13:20:47 <orbitz> gwern: i like step 1, i dont liek step 2
13:20:52 <gwern> and y'all think I'm joking
13:20:53 <orbitz> since i'm qutie certain the faul tis my own
13:21:53 <orbitz> http://hpaste.org/13216 i the code if anyone wants it.  it somewhat long though.  i'm looking at how to profile an app on the wiki
13:22:55 <orbitz> my first usefl haskell program too so i expec tit ot be rather wrong
13:25:23 <paolino> EvilTerran: type Prova r s = StateT s (State r), isn't this partially applied ?
13:25:59 <paolino> uhm, no, nevermind
13:27:51 <paolino> thanks
13:42:12 <augustss> @seen bos
13:42:13 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
13:43:03 * Saizan wonders about the amount of duplication that mailing lists produce in gmail's servers
13:44:26 <Botje> maybe they do some cool header munging and redirect the message body to an already stored copy :)
13:44:42 <gwern> probably quite a bit, but I wouldnt be surprised if they optimize mailing list batches to hash the contents and store them that way
13:45:07 <gwern> :t fmap
13:45:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:45:09 <gwern> :t liftM
13:45:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:45:21 <gwern> hm. can I use fmap everywere I use liftM?
13:45:56 <augustss> If every monad has been defined to be a functor.  It could be, but sometimes you forget.
13:46:21 <Botje> isn't there an automatic instance?
13:46:29 <b_jonas> Botje: I think there can't be
13:46:32 <Botje> @src join IO
13:46:32 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:46:48 <augustss> @src join
13:46:49 <lambdabot> join x =  x >>= id
13:46:51 <Botje> join can be implemented as >>= id
13:46:51 <b_jonas> Botje: that's because then you couldn't define any other instance
13:46:57 <Botje> oh
13:46:57 <b_jonas> but maybe I'm wrong
13:46:58 <Botje> boo!
13:47:17 <b_jonas> I still don't understand typeclasses much so maybe someone should confirm
13:47:19 <augustss> b_jonas: you are right for Haskell 98.
13:47:52 <b_jonas> also a problem is that you'd need to define lots of classes, not just functor
13:48:05 <EvilTerran> "instance Monad f => Functor f where ..." would overlap all other instances
13:48:13 <EvilTerran> (of Functor, i mean)
13:48:15 <b_jonas> there's applicative, and sometimes others (mtl monadfoo classes etc) too
13:48:16 <lispy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nehe-tuts
13:48:20 <augustss> EvilTerran: yes, you'd have to remove all other.
13:48:40 <b_jonas> of course there could be a wrapper
13:48:45 <b_jonas> I dunno if there's one for functors
13:49:23 <b_jonas> yeah, there is one
13:49:27 <b_jonas> called WrapperMonad
13:49:33 <b_jonas> no
13:49:36 <b_jonas> WrappedMonad
13:49:44 <b_jonas> in Control.Applicative
13:50:09 <b_jonas> it wraps a monad to be a functor and applicative, and a monadplus to be alternative
13:50:57 * Heffalump wants the class alias stuff to happen
13:51:07 <Heffalump> in some form, at any rate
13:53:34 <augustss> Yes!
13:54:09 <athos> @src const
13:54:10 <lambdabot> const x _ = x
13:58:22 <athos> @src []
13:58:23 <lambdabot> data [] a = [] | a : [a]
13:59:35 <athos> @src (:)
13:59:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:59:41 <athos> @src :
13:59:41 <lambdabot> Source not found. Just try something else.
14:04:06 <Lemmih> athos: You just saw the definition of (:).
14:04:13 <athos> :)
14:04:16 <athos> yep
14:06:13 <athos> i want to model the SKI calculus, just as an exercise, but i'm really stuck with designing the appropriate type/value constructors for it: http://hpaste.org/13217
14:06:30 <athos> i think my design is just completly wrong
14:07:21 <athos> i don't see a way with my current design to evaluate something like K I (Value 5), or even K I I, which both should just yield I
14:09:21 <lispy> athos: looks like, eval (I x) = eval x, is a problem
14:09:35 <athos> hm, yeah
14:09:56 <lispy> athos: or wait, I guess that would have the right type, hmmm
14:10:25 <b_jonas> athos: see http://www.madore.org/~david/programs/unlambda/
14:10:27 <athos> lispy: but i think the whole data stuff is wrong
14:10:28 <lispy> athos: I guess one thing about the Combinator type is that x seems to always have to be the same, is that right?
14:10:32 <b_jonas> athos: I think it descrives the constructors you need
14:10:48 <EvilTerran> lispy, yes, although it could be "Either y z"
14:11:10 <lispy> EvilTerran: I'm not following you
14:11:53 <Heffalump> the problem is that your combinators don't have any notion of substitution
14:12:06 <EvilTerran> lispy, as in, if x = Either Foo Bar, then you can effectively have values of type Foo or of type Var
14:12:08 <EvilTerran> *Bar
14:12:23 <lispy> EvilTerran: yeah, okay
14:12:30 <Heffalump> to implement the S combinator, you need to be able to apply x to something
14:13:39 <lispy> athos: I have a hunch that GADTs would work well here but if you haven't learned about them disregard my advice :)
14:14:19 <Heffalump> GADTs would help you impose a type system on the combinators, but since they can model untyped lambda calculus that isn't necessary at all
14:14:52 <vixey> data Combinator = S | K | I
14:14:53 <Heffalump> I think the basic problem is that you are confusing Haskell application with combinator application.
14:15:04 <vixey> data Tree a = Leaf a | Branch (Tree a) (Tree a)
14:15:10 <vixey> type Program = Tree Combinator
14:15:25 <Heffalump> data Combinator = S | K | I | Apply Combinator Combinator | Value
14:15:43 <vixey> Heffalump, hm, "Value"?
14:15:44 <Heffalump> (which is equivalent to vixey's view, apart from adding the Value constructor, but more direct)
14:15:53 <lispy> Heffalump: ah yeah, I saw 'x' as being that type system
14:16:06 <Heffalump> (and if you want actual values, you need to add a parameter to Combinator as you have done in your hpaste)
14:16:11 <Heffalump> vixey: just to deal with values
14:16:17 <vixey> what's a value?
14:16:24 <Heffalump> the pure SKI calculus obviously doesn't have them
14:16:28 <Heffalump> but athos's paste does
14:18:40 <wolverian> hm. why did cabal-install install a binary in ~/.cabal/bin, when I have user-prefix set elsewhere in teh config?
14:18:44 <wolverian> s/teh/the/
14:19:00 <athos> Heffalump: but who is it possible to "evaluate" (better: reduce) something like K I I now? seems like i'm totally confused now, but i can't imagine how to pattern match this
14:19:20 <athos> Heffalump: i mean taking your definition of Combinator
14:19:44 <Heffalump> reduce (K `Apply` x `Apply` y) = reduce x
14:20:00 <Heffalump> [you need infixl <n> `Apply` for some n to use that notation]
14:20:05 <Dynetrekk> I was wondering one thing. how can you define functions directly in ghci?
14:20:11 <Heffalump> or perhaps it defaults to being infixl anyway, not sure
14:20:18 <Heffalump> Dynetrekk: let foo x = ...
14:20:26 <Dynetrekk> Heffalump:  ah, of course...
14:20:37 <athos> Heffalump: ah of course
14:20:41 <athos> Heffalump: thanks!
14:20:43 <Heffalump> Dynetrekk: it's not totally obvious, but ghci behaves rather like do notation
14:20:57 <Dynetrekk> Heffalump: ah... I see... more "monadic"
14:21:16 <athos> and thanks to all other guys, too, for being that patient with me :)
14:23:31 <mmorrow> i believe stuff defaults to infixl 9
14:24:08 <Heffalump> mmorrow: yeah, I had a half a feeling that was the case after I said that, but didn't want to throw yet more ill-informed guesses into the ether :-)
14:24:52 <vixey> :$: is also a constructor
14:24:58 <ozy`> Heffalump: were you in here when MegIzna threw a fit over that?
14:25:09 <Heffalump> ozy`: over what?
14:25:13 <vixey> you can do one step reductions too
14:25:18 <ozy`> ghci's do-notation input stuff
14:25:22 <Heffalump> no...
14:25:24 <vixey> and fold over the tree with it
14:25:26 <mmorrow> i only know that on account of seeing that show up in TH-reified Infos
14:25:39 <Heffalump> mmorrow: heh. I think it also shows up in ambiguity error messages.
14:26:23 <dons> ?users
14:26:23 <lambdabot> Maximum users seen in #haskell: 575, currently: 548 (95.3%), active: 13 (2.4%)
14:26:52 <mmorrow> , (1 `id` 2 `id`) 3
14:26:59 <lunabot>  luna: No instance for (GHC.Num.Num (t -> t1 -> a))
14:27:05 <mmorrow> grr
14:27:24 <mmorrow> , (`id` 1 `id`2 ) 3
14:27:26 <lunabot>  luna: The operator `GHC.Base.id' [infixl 9] of a section
14:27:28 <vixey> , (1 `const` 2 `const`) 3
14:27:32 <lunabot>  1
14:27:33 <mmorrow> heh, there we go
14:27:40 <mmorrow> , (1 + 2 +) 3
14:27:42 <lunabot>  6
14:27:49 <mmorrow> curious
14:27:56 <vixey> that's weird
14:28:13 <mmorrow> i think that came up in here before (i don't think that's supposed to happen)
14:28:20 <mercury^> > (1+ 2+) 3
14:28:22 <lambdabot>   6
14:28:33 <mmorrow> , (+ 1 + 2) 3
14:28:35 <lunabot>  luna: The operator `GHC.Num.+' [infixl 6] of a section
14:28:39 <mercury^> Are , and > the same?
14:28:46 <mmorrow> it'a a different bot
14:28:50 <mercury^> ah
14:28:56 <mmorrow> with different imports/misc
14:29:08 <mmorrow> lunabot only does eval
14:29:36 <mmorrow> . [$ty| let fix f = let x = f x in x in fix |]
14:29:44 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
14:29:56 <lunabot>  forall a . (a -> a) -> a
14:29:59 <Cale> Oh, mmorrow, I have a cool idea for something for you to implement in TH :)
14:30:10 <mmorrow> Cale: oh sweet, what?
14:30:17 <Cale> A syntax for catamorphisms.
14:30:50 <mmorrow> hmm, what do you have in mind?
14:30:50 <Cale> Something like,  [$cata | Leaf -> 0; Branch x l r -> 1 + l + r |]
14:31:50 <mmorrow> cool. so what would that generate?
14:32:07 <byorgey> hey, that would be nifty =)
14:32:07 <Cale> That would be the function which finds the number of Branch nodes in a tree.
14:32:26 <Cale> It would generate:
14:32:33 <Cale> size Leaf = 0
14:32:43 <Cale> size (Branch x l r) = 1 + size l + size r
14:32:57 <mmorrow> ohhh, i see it now
14:33:03 <Heffalump> figuring out that the auxiliary function is called "size" is a crucial part of the spec
14:33:12 <Cale> heh
14:33:14 <mmorrow> hehe
14:33:30 <byorgey> you could just output an application of 'fix' to an anonymous lambda
14:33:37 <mmorrow> totally
14:33:41 <byorgey> and say    size = [$cata | ...]
14:34:19 <Heffalump> or use let, it doesn't really matter
14:34:51 <mmorrow> nice, i think with a little hackery one could use the case exp haskell parser too
14:35:08 <orbitz> is the ByteString fold* most likely going to be better optimized than walking over a ByteString myself with head/tail?
14:35:21 <Heffalump> don't forget [$ana | ... ] too or you'll upset the unfold people :-)
14:35:51 <mmorrow> heh, very true
14:35:57 <vixey> and for edwardk [$zygohistormorphic| ... |]
14:36:32 <Cale> orbitz: yes
14:36:34 <mmorrow> nice, that could just use quickcheck to generate some random haskell exps, feed them into @pl, loop a few times, and voila
14:36:48 <Cale> orbitz: I would be somewhat surprised if it wasn't, anyway.
14:37:00 * wli ponders natural language parsing.
14:37:30 <orbitz> Cale: ah, my functino that parse a bytestring is horribly slow, i think doing a foldl might be ebtter, hopefully
14:37:31 <wli> Oh, wait, speaking of trees, how the heck do you write a balanced heap without abysmal performance?
14:38:03 <mmorrow> wli: chrisdone was doing some stuff with parsing lojban, not sure how related that'd be though
14:38:06 <Cale> wli: There's a good paper on that linked from the Data.Set documentation as I recall
14:38:22 <Cale> http://groups.csail.mit.edu/mac/users/adams/BB/
14:38:39 <wli> Checking.
14:39:11 <wli> I tried just keeping a depth counter and using that to guide various operations.
14:39:20 <wli> This turns out to have sucked.
14:40:06 <tehgeekmeister> semi off topic: anyone know how to print a bell character from the shell?  i need a way to have my shell notify me when my compile is done.  =P
14:40:37 <mmorrow> putChar '\a' -- ?
14:40:43 <mmorrow> oh, the shell
14:40:45 <b_jonas> tehgeekmeister: either just echo ^G where you type a literal control G with control-V control-G to the shell prompt or to the file,
14:41:00 <b_jonas> tehgeekmeister: or echo $'\a' or echo -e '\a'
14:41:01 <mmorrow> echo -ne '\a'
14:41:20 <b_jonas> unless you want windows shell or something
14:41:21 <igel> ghc -e 'putChar '\a'' ;)
14:41:34 <b_jonas> igel: yeah, if only that didn't take a whole second on a fast computer
14:41:35 <Deewiant> "putchar '\a'"
14:41:50 <vixey> there's a command called beep on some systems
14:41:50 <mmorrow> ghc -e is so handy
14:41:59 <b_jonas> ok, just 0.21 seconds actually
14:42:02 <b_jonas> still dead slow
14:42:09 <mmorrow> yeah
14:42:15 <igel> b_jonas: i didn't mean it seriously ;)
14:42:24 <mmorrow> i think that has to do with parsing the package.conf
14:42:32 <b_jonas> I wish it was faster because I like using one-liner perl scripts
14:42:32 <tehgeekmeister> huh, for some reason none of the echo ones work
14:42:33 <Cale> Heh, or you could use play to play a sound file :)
14:42:47 <tehgeekmeister> i wonder if my terminal has funny settings...
14:42:50 <vixey>        beep allows the user to control the pc-speaker with precision, allowing
14:42:50 <vixey>        different  sounds  to  indicate  different events.  While it can be run
14:42:52 <wli> b_jonas: I'd love to hear about command-line editing on Windows, because System.Console.Readline/etc. aren't around.
14:43:01 <Cale> Some terminals use a visual bell, or don't beep at all.
14:43:11 <b_jonas> wli: I think you can just type a literal control-G in windows, I'm not sure though
14:43:24 <b_jonas> wli: oh wait
14:43:32 <b_jonas> wli: I dunno windows then
14:43:47 <wli> b_jonas: I'm speaking of a direct workalike of readline.
14:43:53 <mmorrow> you could always do to
14:43:54 <b_jonas> I have set my terminals to visual bess, I prefer that to real bell
14:44:06 <b_jonas> real bell is annoying especially if you're not at home but among other people
14:44:08 <tehgeekmeister> yeah, my problem could be in a bunch of different places, since i'm running screen thru ssh thru osx's terminal...
14:44:24 <b_jonas> tehgeekmeister: try ^A^G
14:44:25 <mmorrow> dd if=/dev/urandom count=42 bs=4096 > /dev/dsp
14:44:28 <b_jonas> tehgeekmeister: in screen that is
14:44:29 <mmorrow> ;)
14:44:57 <b_jonas> screen can emulate a visual bell
14:45:08 <adekoba> why does binary use "error" instead of exceptions? Is there any way to catch "error"?
14:45:11 <b_jonas> oh, there's an ioctl variation too
14:45:14 <mmorrow> perhaps count=42 slightly overdoes it..
14:45:28 <tehgeekmeister> mmorrow: i like that one
14:45:41 <b_jonas> ioctl KDMKTONE with the right arguments on a real linux console
14:45:47 <b_jonas> I used to play with that a bit
14:46:16 <Elly> http://3.bp.blogspot.com/_LsoZGb_JnNk/SQDm_DJY7fI/AAAAAAAAAW4/gYtduyJkKbA/s1600-h/haskell_is_provably_correct.png :D
14:46:29 <mmorrow> cat /dev/urandom > /dev/dsp & while [[ true ]]; do cat /dev/urandom > /dev/fb0; done
14:46:32 <bos> @seen augustss
14:46:33 <lambdabot> augustss is in #haskell. I last heard augustss speak 52m 58s ago.
14:46:34 <mmorrow> that's amusing
14:46:35 <vixey> Elly, loll
14:46:59 <mmorrow> s/\/dev\/fb0/whatever your framebuffer device is/
14:47:12 <tehgeekmeister> b_jonas: that fixed it, thanks
14:47:21 <b_jonas> great
14:47:43 <b_jonas> (and of course there are a few motherboards that just lack the pc speaker or have one that's very silent)
14:48:19 <mmorrow> i don't think you'll get the (audible) bell in an xterm
14:48:43 <mmorrow> (by default at least)
14:49:01 <mmorrow> well i know you dont
14:49:09 <mmorrow> (but i don't know why)
14:49:10 <b_jonas> mmorrow: I think you can configure it
14:49:17 <mmorrow> yeah, someway
14:49:39 <b_jonas> with the -vb or +vb option
14:49:50 <mmorrow> ooh, nice
14:50:20 <tehgeekmeister> eww, been running for 22 minutes now.  i suspect something's wrong with my code...
14:50:21 <b_jonas> I prefer visual bell though so I've set urxvt to visual bell
14:50:36 <b_jonas> tehgeekmeister: maybe an infinite loop
14:51:06 <vixey> idk how to proceed
14:51:07 <tehgeekmeister> b_jonas: very possibly.  i don't have any prints in my code to show what's going on, or any other way, really...  *adds some
14:51:08 <mmorrow> there's some little prog out there that changes the pitch of the bell and plays songs with it
14:51:08 <vixey> :/
14:51:21 <mmorrow> don't recall where or its name though
14:51:28 <vixey> I want this language toprogram in but it doesn't exist and implementing it is too hard
14:51:52 <mmorrow> vixey: me too ;)
14:51:57 <b_jonas> vixey: what?
14:52:33 <mmorrow> vixey: i don't think it's too hard though, just a lot of work ...
14:52:37 <tehgeekmeister> i think arrows are what i want here, but i don't want to learn them right now; is there a way to feed a value into two functions at once?
14:52:57 <vixey> feed (f,g) x = (f x, g x)
14:53:03 <vixey> also known as $$
14:53:22 <vixey> and you have (f,g,h) $$$ x = (f x, g x, h x)
14:53:30 <mmorrow> @pl \(f,g) x -> (f x,g x)
14:53:31 <lambdabot> uncurry (liftM2 (,))
14:53:40 <mmorrow> cheater!
14:53:42 <b_jonas> what language toprogram?
14:53:54 <b_jonas> @type $$$
14:53:56 <lambdabot> parse error on input `$$$'
14:53:58 <vixey> b_jonas, to program with
14:54:00 <b_jonas> @type ($$$)
14:54:02 <lambdabot> Not in scope: `$$$'
14:54:12 <Saizan> > (f &&& g) x
14:54:13 <lambdabot>   Add a type signature
14:54:15 <b_jonas> oh, you define it there
14:54:22 <Saizan> > (f &&& g) x :: (Expr,Expr)
14:54:23 <lambdabot>   (f x,g x)
14:54:29 * vixey I am definitely not using the std library
14:56:11 <vixey> mmorrow, I wish Epigram 2 was useable or buildable or something
14:56:25 <tero-> Is select support now deprecated for good in Haskell, that is, threads and blocking IO are the way to go?
14:56:36 <tehgeekmeister> vixey: i've dreamt of epigram being usable ever since i heard of it.
14:57:17 <mmorrow> vixey: i have the code for that, but i haven't gotten around to doing anything with it yet
14:57:27 <mmorrow> err, maybe i have Epigram 1 (?)
14:57:31 <mmorrow> not sure
14:57:35 <vixey> it don't build with 6.10 (it used to with the old ones)
14:57:41 <mmorrow> ah
14:57:43 <Elly> where does &&& actually live?
14:57:44 <vixey> you can get Epigram 1 to build with a couple  fixes though
14:58:03 <mmorrow> vixey: cool, i'll have to try it
14:58:10 <vixey> idk
14:58:13 <byorgey> Elly: Control.Arrow
14:58:21 <mmorrow> @index (&&&)
14:58:22 <lambdabot> Control.Arrow
14:58:58 <mmorrow> tero-: ghc's threaded IO manager uses select
14:59:08 <chessguy> @bot
14:59:09 <lunabot>  :)
14:59:09 <lambdabot> :)
14:59:12 <vixey> maybe I should just program in <non-existent language> until I have enough to bootstrap
14:59:28 <mmorrow> vixey: heh, that's an idea
14:59:45 <tero-> mmorrow: but user should use threads, right?
14:59:51 <b_jonas> vixey: so what do you actually want from that hypothetical language?
15:00:19 <tero-> also, I'm interested in knowing more about the (dirty?) implementation of Haskell threads
15:00:30 <tero-> they don't map 1-1 with the OS threads I guess
15:00:35 <chessguy> @bot
15:00:35 <lambdabot> :)
15:00:35 <lunabot>  :)
15:00:45 <tehgeekmeister> oops.  suddenly my program does nothing and exits.  and just a moment ago i think it was in an infinite loop.
15:00:51 * tehgeekmeister thinks there's something wrong in his program
15:00:57 <vixey> b_jonas, not totally sure, inductive-recursive definitions would be interesting to play with
15:01:32 <b_jonas> tehgeekmeister: it just ran out of memory, that's why it exited
15:01:34 <mmorrow> tero-: sure. the io manager just is forkIO'ed in a thread no diff from forkIO (print 42). you could always ffi-import select too if you wanted to for some reason, but that's probably only useful in very particular apps
15:01:53 <tehgeekmeister> b_jonas: but before it ran for 20 some minutes; this time it exited instantly.
15:01:53 <b_jonas> inductive-recursive definitions...
15:02:10 <b_jonas> oh, you mean you ran it again?
15:02:17 <mmorrow> tero-: oh cool. yeah, they're not os threads. are you interested in the low-level implem?
15:02:22 <tehgeekmeister> b_jonas: and the only change was adding some printing in so i can monitor progress
15:02:53 <tehgeekmeister> OH
15:03:13 <tehgeekmeister> using the shell absolutely wrong.
15:03:19 <tehgeekmeister> | doesn't do the same thing as ;
15:03:44 <mmorrow> tero-: http://darcs.haskell.org/ghc/rts/
15:04:06 <chessguy> anybody see the pattern combinator paper wadler linked to the other day? http://hpaste.org/13215
15:04:13 <tero-> mmorrow: nope. nothing special about select. I just used to use it. the low-level implementation of threads would be interesting. thanks for the link
15:04:42 <chessguy> @bot
15:04:42 <lunabot>  :)
15:04:42 <lambdabot> :)
15:04:58 <mmorrow> tero-: np
15:06:33 <b_jonas> right
15:06:35 <b_jonas> good night now
15:07:25 <tehgeekmeister> will printing to the terminal everything i'm adding to a db slow down the whole process?  should i print a small summary for each step to make it go faster?
15:07:41 <mmorrow> tero-: the haskell code that directly ffi-imports select and implem the threaded io manager is in  http://darcs.haskell.org/libraries/base/GHC/Conc.lhs  starting around line 1100 (/me was looking at this earlier today)
15:08:40 <mmorrow> i'd seen it before, but never actually read-it-to-understand-it until today. pretty cool.
15:09:55 <orbitz> is this function just horribley inefficient how it is written? It appears to be consuming 80% of my applications CPU/allocation: http://hpaste.org/13218
15:09:59 <afabian> tehgeekmeister: Terminal output slows down CPU-bound tasks.  Depends on how much output you're generating.
15:10:34 <tehgeekmeister> afabian: i think the process is IO bound; i'm reading from a nearly 4gb xml file and putting entries into a db
15:10:39 <mmorrow> orbitz: probably don't unpack, and do stuff like
15:11:05 <mmorrow> foo s | (not . B.null) s = ... unsafeHead s .... unsafeTail s ....
15:11:28 <orbitz> mmorrow: i only unpack on the error situation right?
15:11:31 <afabian> tehgeekmeister: Huh.  I dunno.  I guess there's nothing to do but try it and see. :o
15:11:51 <tehgeekmeister> afabian: yeah, i'm just hoping i'm not here for hours waiting.  =P
15:12:03 <mmorrow> orbitz: you're right. hmm
15:12:07 <orbitz> mmorrow: how are unsafeHead and tail unsafe?
15:12:11 <mmorrow> maybe all the reversing?
15:12:31 <Cale> Yeah, I bet it's the reversing.
15:12:34 <mmorrow> orbitz: they're no more unsafe than head and tail (well, i suppose you could segfault if you mess up)
15:12:40 <tehgeekmeister> hmm, well at least i know i'm using constant memory!  my algorithm can't be horrible.
15:13:09 <mmorrow> orbitz: they're just prefixed with unsafe because they don't check that the ByteString isn't empty first
15:13:09 <orbitz> can i implement this without reversing?
15:13:33 <tehgeekmeister> (altho the fact that the postgres user has hundreds of ssh processes running probably isn't good...)
15:13:53 <Cale> also, this is just a style thing, but I would tend to recommend replacing f $ g $ h $ x with f . g . h $ x -- that's not a performance thing of course.
15:14:20 <orbitz> Cale: because $ has funky assoiativity/semantics?
15:14:22 <hugo___> hello
15:14:23 <Cale> yeah
15:14:51 <Cale> It's easier to think about compositions of functions, once you're used to them, because they break down more nicely.
15:15:00 <orbitz> ok
15:15:04 <Cale> g . h is another function, but g $ h isn't.
15:15:14 <Cale> (it's not even type correct)
15:15:20 <orbitz> any suggestions on how to better write this function?
15:15:50 <Cale> This is just parsing CSV?
15:15:54 <vixey> id . f = f = f . id,  f . (g . h) = (f . g) . h, ...
15:15:59 <Cale> Or...
15:16:05 <vixey> no way to calculate with ($)
15:16:22 <tehgeekmeister> hum; anyone know how i could add a progress meter of some sort?  just a simple indicator of how far i've made it thru the file?
15:16:40 <orbitz> Cale: it's really SQL, but each line is pretty much a csv, with some surroudngin syntax
15:17:02 <Cale> Yeah, my main concern would be finding a way to avoid using S.reverse. ByteString has fast indexing, but reverse will be slow and costly.
15:17:43 <Cale> (you're making a new string every time you do that)
15:18:07 <orbitz> would even using append be faster?
15:18:07 <int-e> S.cons isn't cheap either
15:19:00 <Elly> hm?
15:19:12 <Elly> cons is cheap on lists
15:19:36 <Cale> On strict bytestrings cons is O(n)
15:19:39 <int-e> yes, but bytestrings aren't lists
15:20:02 <vixey> I thought they were (lists of chunks of bytes)
15:20:05 <vixey> '`a;o
15:20:19 <Cale> That's lazy bytestrings
15:20:50 <pejo> orbitz, append should cost the length of the first list
15:21:30 <Cale> uh, for strict bytestrings, it should cost the sum of the lengths of the strings
15:21:56 <Cale> afaik, it allocates a new string of the appropriate length and does two memcpys.
15:22:06 <orbitz> is my code unidiomatic, if that's a word?
15:22:31 <Cale> orbitz: It's complicated enough that I would consider using Parsec.
15:22:50 <orbitz> ok
15:22:52 <vixey> haha "A direct translation of the simply typed lambda calculus into C++-templates"
15:23:06 <Cale> But if you'd rather not, it's not too far from reasonable code...
15:23:17 <Cale> What is removeHead?
15:23:40 <orbitz> the strings look like (few, few, efwf, gr),
15:23:50 <orbitz> with possible more , on teh end
15:24:19 <orbitz> i could proabbly get rid of it and justbuild it into the state machine
15:25:43 <int-e> this is annoying - producing one element of the list can be expressed in terms of Data.ByteString.Char8.unfoldr, but that doesn't give us the length of the extracted part.
15:29:37 <Cale> orbitz: can the strings be empty?
15:29:52 <Cale> Like (few,,efwf,gr), ?
15:30:50 <Cale> and can the list be empty?
15:31:58 <orbitz> Cale: no, but i coudl get an empty line
15:32:13 <orbitz> Cale: i'm alsod ealing with 30+GB of data, so faster = better
15:32:31 <pumpkin> om nom nom nom
15:32:37 <pumpkin> don't eat it all at once
15:33:06 <luite_> hm, isn't it possible to thaw a UArr to a MUArr ?
15:38:49 <Cale> orbitz: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=672#a672
15:39:17 <Cale> orbitz: That's roughly how it looks in Parsec. You may want to tweak how it works a bit.
15:40:17 <orbitz> Cale: awesome.  i have to learn Parsec but i'll hold onto this so I can figure out how it works
15:40:56 <orbitz> Cale: heading to work party.  tahnks for the help
15:41:17 <Cale> cool, no problem :)
15:41:42 <Cale> Note that this version doesn't eat spaces, which you may want to do.
15:41:51 <orbitz> ok
15:41:54 <Cale> (they just become part of the strings)
15:42:05 <orbitz> i'm goign to try to learn parsec tommorrow then so I can spruc eit up
15:42:43 * Martijn is looking for a prettier way of writing:
15:42:43 <Martijn> collapse :: [Ordering] -> Ordering
15:42:44 <Martijn> collapse = flip foldr EQ $ \o o' -> if o /= EQ then o else o'
15:43:04 <vixey> if o /= EQ then o else o' ??
15:43:10 <vixey> why aren't you using ++
15:43:29 <vixey> :t msum
15:43:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
15:43:33 <Martijn> How would I use ++?
15:43:41 <vixey> hum..... m is monad not monoid
15:43:44 <vixey> @instances Monoid
15:43:45 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:43:50 <vixey> Ordering is in there
15:43:55 <vixey> @hoogle Monoid
15:43:55 <lambdabot> module Data.Monoid
15:43:55 <lambdabot> Data.Monoid class Monoid a
15:44:03 <augustss> > mappend () ()
15:44:04 <lambdabot>   ()
15:44:08 <vixey> @hoogle Monoid m => [m] -> m]
15:44:08 <lambdabot> Parse error:
15:44:08 <lambdabot>   --count=20 "Monoid m => [m] -> m]"
15:44:08 <lambdabot>                                  ^
15:44:09 <vixey> @hoogle Monoid m => [m] -> m
15:44:10 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
15:44:10 <lambdabot> Prelude head :: [a] -> a
15:44:10 <lambdabot> Prelude last :: [a] -> a
15:44:20 <vixey> > mconcat EQ EQ LT EQ GT
15:44:21 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Ordering'
15:44:26 <vixey> > mconcat [EQ, EQ, LT, EQ, GT]
15:44:28 <lambdabot>   LT
15:44:40 <Martijn> Oh nice
15:44:45 <int-e> Martijn: head . (++ [EQ]) . dropWhile (== EQ)  (really want a headWithDefault)
15:44:49 <int-e> oh.
15:44:57 <int-e> > mconcat []
15:44:58 <lambdabot>   ()
15:45:03 <int-e> > mconcat [] :: Ordering
15:45:05 <lambdabot>   EQ
15:45:11 <int-e> I forgot about that, thanks :)
15:46:34 <Martijn> mconcat seems to do exactly the right thing here. awesome, thanks. :-)
15:47:16 * Martijn wants to be able to write: compareTuple = comparingMany [asc fst, asc snd]
15:47:25 <Martijn> comparingMany :: [Compare a] -> Compare a
15:47:26 <Martijn> comparingMany fs x y = mconcat $ map (\f -> f x y) fs
15:47:33 <Martijn> type Compare a = a -> a -> Ordering
15:48:50 <jav_> can some explain this? or confirm that they are seeing the same thing, please? --> this code contains two functions that are identical, but return two different values: http://hpaste.org/13219#a0 .. compiler bug?
15:51:05 <Martijn> That's interesting :-)
15:51:45 <Cale> It's the stupid type of take
15:51:47 <Cale> :t take
15:51:48 <lambdabot> forall a. Int -> [a] -> [a]
15:52:12 <int-e> jav_: check the types
15:52:12 <Cale> That coerces p to be an Int
15:52:23 <Cale> Ints are stupid.
15:52:44 <pumpkin> :t length
15:52:45 <lambdabot> forall a. [a] -> Int
15:52:45 <tehgeekmeister> how do i make vim auto-indent haskell nicely?
15:52:47 <pumpkin> tsk tsk
15:52:51 * int-e likes Ints
15:52:55 <idnar> :t genericLength
15:52:56 <lambdabot> forall b i. (Num i) => [b] -> i
15:52:59 <idnar> :t genericTake
15:53:00 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
15:53:00 <pumpkin> that's better
15:53:11 <Martijn> Can you explain please, Cale?
15:53:12 <mpeter> http://71.192.179.132/transylvanian%20ruins.mp3
15:53:15 <idnar> @src genericTake
15:53:15 <lambdabot> Source not found. :(
15:53:28 <Cale> Martijn: The default numeric type is Integer, which allows any value which fits in memory.
15:53:57 <jav_> aww, I see.. thx for explaining that
15:54:04 <int-e> (g ^ e) `mod` p begs for optimization.
15:54:09 <Martijn> Oh, I only just noticed p is used again in the expression.
15:54:13 <Cale> Int on the other hand is a machine integer, which is essentially an Integer mod some power of 2.
15:54:49 <hasenov> hello, im interested to know what software the authors of RWH used for collaborative writing
15:54:58 <Cale> > 7^12
15:54:59 <lambdabot>   13841287201
15:55:03 <Cale> > 7^12 :: Int
15:55:04 <lambdabot>   13841287201
15:55:11 <Cale> er :)
15:55:12 <Martijn> @pl \fs x y -> mconcat $ map (\f -> f x y) fs
15:55:12 <lambdabot> ((mconcat .) .) . flip (flip . (map .) . flip . flip id)
15:55:15 <wli> http://hpaste.org/13116 <-- the heap implementation that was too slow
15:55:18 <pumpkin> hasenov: bos and dons might be able to tell you :P
15:55:26 <Cale> > 7^12 :: Int32
15:55:27 <lambdabot>   956385313
15:55:35 <bos> hasenov: darcs
15:55:40 <int-e> > log (fromIntegral (maxBound :: Word64) + 1) / log 2
15:55:42 <lambdabot>   64.0
15:55:44 <Cale> (lambdabot is running on a 64 bit machine)
15:55:44 <int-e> > log (fromIntegral (maxBound :: Word) + 1) / log 2
15:55:46 <lambdabot>   64.0
15:55:53 <hasenov> me any my professor are writing a paper this winter but I'll be far away so it'll be all digital and he'll be mostly making comments on my work
15:55:59 <pumpkin> bos: does the third author hang out in here too? don't want him to feel left out!
15:56:08 <bos> yes, CosmicRay
15:56:22 <pumpkin> hasenov: use any scm, TeX, and the fixme package :P very simple
15:56:35 <gwern> hasenov: they used darcs, and a custom django website, iirc
15:56:45 <pumpkin> omg not happs :o
15:56:49 <pumpkin> FAIL
15:56:52 <pumpkin> :P
15:56:59 <Cale> Int is a correctness-damaging premature optimisation in most cases, and doesn't belong in the Prelude.
15:57:02 <hasenov> so it was django, is it possible that me and my professor use it?
15:57:16 <Cale> It's good that it is available, but it should never be the default.
15:57:23 * wli hasn't smoked out how to do O(lg(...)) merges without a full counter.
15:57:25 <bos> hasenov: i intend to release the code, yes.
15:57:41 <hasenov> i mean the website aspect of it, btw, since my professor probably will never want to used darcs but he wouldn't mind making comments on a website
15:57:44 <gwern> pumpkin: well, I understand whichever of the two (not dons) set it up was already good at django, so rather than shaving a rather large yak...
15:57:56 <pumpkin> gwern: just being silly :)
15:58:02 <gwern> hasenov: you could look into gitit
15:58:08 <hasenov> bos: ok thanks
15:58:14 <gwern> pumpkin: no, gitit could be a reasonable alternative for that sort of thing
15:58:20 <gwern> and it does use happs
15:58:58 <pumpkin> I like the fixme package with LaTeX and an SCM myself :P but maybe I'm old-fashioned
15:59:22 <gwern> iirc, latex is one of the formats gitit can export the reSt in
16:00:00 <gwern> (dunno if it can import it yet)
16:05:57 <RayNbow> hmm, cabal installing hlint failed...
16:06:29 <RayNbow> because haskell-src-exts failed... which failed because I didn't have happy...
16:06:58 <RayNbow> shouldn't cabal-install automatically install happy then? :p
16:09:35 <gwern> RayNbow: it's an old issue - executables aren't tracked
16:09:47 <gwern> the same issue exists for yi, with alex
16:10:18 * wli attempts to smoke out how to shoehorn a definite clause grammar (DCG) into monadic Haskell code.
16:10:31 <gwern> you can cc yourself to the bug report, on which is eternally playing the world's 23rd smallest violin
16:10:42 <RayNbow> gwern: ah
16:11:34 <gwern> the work around would be for happy/alex to expose their internals as a library, and for packages to depend on them, but that's unprincipled and the devs of those tools haven't done it
16:12:04 <RayNbow> hlint is fun :)
16:12:14 <tehgeekmeister> hmm; if it continues to go at about the speed it's going now, it'll take 41 hours to read a wikipedia dump into a database...  perhaps i'm doing something wrong?
16:12:33 <gwern> RayNbow: it is, but I'm dismayed at how many unneessary brackets project use!
16:12:35 <solrize_> woot, my copy of RWH came!  now i are a functi0na1 pr0gramm0rz :)
16:12:48 <gwern> tehgeekmeister: maybe not. WP dumps are really big
16:13:03 <RayNbow> gwern: I got 4 suggestions on some old file I tested on
16:13:12 <RayNbow> 2 eta reductions
16:13:24 <RayNbow> concat . intersperse " " ==> unwords
16:13:29 <gwern> lucky. I had hundreds of suggestions on the Monadius source
16:13:32 <tehgeekmeister> gwern: it's taking constant memory, so that's not a problem.  i was just planning on working on this all weekend -- but if just reading the file in takes the rest of the weekend, that idea won't work very well...
16:13:37 <RayNbow> and head . drop 1 ==> ? !! 1
16:13:48 <tehgeekmeister> gwern: it's 3.8 gb of xml, the one i'm working on
16:13:50 <gwern> ? !! 1
16:13:52 <gwern> what?
16:14:39 <RayNbow> hmm
16:14:49 <RayNbow> I don't think that's a good suggestion
16:15:02 <gwern> no, I mean what is '? !! 1' anyway
16:15:09 <gwern> :t (?)
16:15:10 <lambdabot> Not in scope: `?'
16:15:18 <RayNbow> oh
16:15:23 * wli may end up resorting to SWI Prolog.
16:15:39 <RayNbow> case root of Canvas -> bounds . head . drop 1 $ levels tree   -- this is the line
16:15:58 <gwern> so 'bounds $ (levels tree !! 1)'
16:16:06 <RayNbow> yes
16:16:21 <gwern> hm. seems better than head . drop 1 $ to me, although the function composition looks nice
16:18:29 <chrisdone> does anyone else tend to put everything on hold while working on an interesting problem?
16:18:45 <chrisdone> like, work, hobbies, .. eating
16:19:10 <gwern> yes. I used to go a day or 2 without eating while doing stuff
16:19:11 <RayNbow> please don't remind me, chrisdone ;)
16:19:18 <mmorrow> chrisdone: never ;)
16:19:27 <chrisdone> ;_;
16:19:33 * mmorrow lies
16:19:59 <chrisdone> like, if I stop working on this, I'll be hollow inside. haha
16:24:31 <luite_> is it possible to import a hidden module? I want to make an enumFromToMU function, but I need the hidden Data.Array.Vector.Stream module for this
16:24:45 <tehgeekmeister> gwern: oh, my estimate seems to have been a bit off.  in the past ten minutes it's gone from 41 hours to 36.  i suppose if it keeps getting lower at that rate, it'll be done rather quickly.
16:25:03 <mmorrow> luite_: the only way is the make a personal fork
16:25:35 <luite_> mmorrow: hm, that sounds like something I don't want to do
16:25:38 <mmorrow> (and cough*adjust*cough the export list)
16:26:31 <luite_> is there a way to write a function that converts a UArr to a MUArr without copying then?
16:26:58 <mmorrow> yeah, it's not always ideal, but when compared to not being able to do it at all it gets slightly more palateable
16:27:12 <mmorrow> i'm not sure
16:27:46 <luite_> an unsafeThaw would be nice, as some functions are provided for the immutable versions, but not for the mutable ones
16:28:15 <mmorrow> you could also have a module that import that module qualified, duplicated the type/data decl exactly, and unsafeCoerces to/from your duplicate (!*!identical!*!) type
16:28:37 <int-e> luite_: hmm, that would require freezing.
16:28:43 <mmorrow> but you'd have to be positive you keep your dup in sync
16:29:04 <mmorrow> luite_: yeah, there's definitely a way (if you can get at the contents)
16:30:02 <mmorrow> GHC.Prim might have something
16:30:48 <luite_> int-e: freezing? there are two freeze functions (unsafeFreezeMU and unsafeFreezeAllMU, but I don't know the difference), but this is the other way around
16:31:09 <luite_> ah, all is for all elements, no from index
16:31:13 <pumpkin> @src maximumBy
16:31:13 <lambdabot> Source not found. My mind is going. I can feel it.
16:31:30 <pumpkin> hmm, getting stack overflows on code that processes a list of length 1000000
16:32:24 <Martijn> You probably need the strict version of maximum then.
16:32:33 <mmorrow> luite_: oh, i just looked at the haddocks and there's all kinds of stuff going on with different types of vectors particular to that pkg. i'd probably ask dons
16:32:36 <pumpkin> there is one?
16:32:48 <Saizan> pumpkin: compiling with -O2?
16:32:49 <tehgeekmeister> would HDBC start to consume more memory if you did a large number of insertions with no commit?
16:32:53 <pumpkin> Saizan: ghci :P
16:33:05 <mmorrow> luite_: (and would disregard everything i suggested ;)
16:33:07 <int-e> luite_: you contradicted yourself.
16:33:07 <luite_> dons!! :)
16:33:17 <pumpkin> fine, fine I'll compile it
16:33:24 <luite_> int-e: oh, then I probably worded something wrong
16:33:56 <Martijn> pumpkin: Prelude Data.List> foldl1' max [1..10000000]
16:33:56 <Martijn> 10000000
16:34:16 <pumpkin> yeah, but I need maximumBy, which is a bit more of a pain
16:34:21 <pumpkin> I'll see if compiling it helps
16:34:54 <pumpkin> yup, worked fine :)
16:35:16 <Saizan> ?src maximumBy
16:35:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:35:17 <luite_> int-e: i want to use the function enumFromToU, but I need a mutable MUArr, enumFromToU returns an immutable UArr. so I'd like to have some function UArr e -> ST s (MUArr e s)
16:37:18 <int-e> luite_: aha. enumFromToU start end = unstreamU (enumFromToS start end) -- the same with  unstreamMU  instead of  unstreamU  probably does what you want.
16:37:48 <luite_> int-e: that's true, but that requires functions from hidden modules
16:38:18 <int-e> luite_: I was going to check that next, hmm. Sad :(
16:38:20 <luite_> int-e: enumFromToS is hidden, and it uses a hidden Stream implementation
16:46:57 <pumpkin> does anyone know how to compute the integer partition function?
16:47:50 <pumpkin> or if there's a library in haskell that implements it already?
16:48:21 <int-e> luite_: Hmm, ok, I think it can't be done - unsafeThaw really needs the same infrastructure as unsafeFreeze. As for unsafeFreezeAll vs. unsafeFreeze: the latter can be used to truncate an array to a specified size while freezing..
16:48:47 <bhurt> So, style question for people, if I can.  I have a certain problem-
16:48:47 <bhurt> basically, I have a bunch of functions which need a special function,
16:48:47 <bhurt> of type a -> Foo say.  And a bunch of other functions which can define
16:48:47 <bhurt> that function on some type of interest, and then what to call the first
16:48:47 <bhurt> batch of functions.  I can do this either by defining a type class,
16:48:48 <bhurt> something like:
16:48:50 <bhurt> class Fooable a where
16:48:52 <bhurt>     toFoo :: a -> Foo
16:48:54 <bhurt> or I can simply have all the functions which need a toFoo take an extra
16:48:56 <bhurt> agrument.  Performance really isn't that important here, so it's really
16:48:58 <bhurt> a matter of style- which approach would people prefer in this case?
16:49:00 <mbz_> pumpkin, integer partition? what's that?
16:49:15 <pumpkin> mbz_: the number of ways an integer can be written as a sum
16:49:22 <pumpkin> a unique sum
16:49:41 <pumpkin> so 4 = 3 + 1 = 2 + 2 = 2 + 1 + 1 = 1 + 1 + 1 + 1
16:49:50 <luite_> int-e: ok, thnx. I'll ask dons about the possibility of an unsafeThaw
16:51:00 <luite_> and create a stub that just copies the array, for now
16:51:06 <bhurt> Pumpkin: should be easy enough to write, give me a moment.
16:51:12 <Martijn> If anyone remembers the comparingMany I asked about earlier: I found a very short implementation, namely: comparingMany = mconcat
16:51:13 <pumpkin> bhurt: really?
16:51:49 <ozy`> pumpkin: I implement that in every language I learn, as a rule
16:52:00 <pumpkin> ozy`: lol, I can haz?
16:54:22 <pumpkin> bhurt: it's not trivial to write
16:55:19 <luite_> it's a special case of the coin change problem, but I'm not sure if this makes it much easier to write
16:55:22 <ozy`> pumpkin: it's fine if you think about it recursively
16:55:35 <ozy`> http://paste.pocoo.org/show/96217/
16:55:49 <ozy`> note that this is designed for partitioning with primes only
16:56:07 <ozy`> you might have to tweak it to get sums that include 1
16:56:30 <pumpkin> ah
16:56:35 <int-e> pumpkin: http://mathworld.wolfram.com/PartitionFunctionP.html ... there's a very nice recurrence involving pentagonal numbers
16:57:05 <pumpkin> int-e: oh nice, I looked at that page but missed that
16:57:37 <adekoba> why does binary use "error" instead of exceptions? Is there any way to catch "error"?
16:57:54 <redditbot> Building a shared library in Haskell
16:57:55 <Cale> adekoba: In IO, yes
16:58:33 <adekoba> Cale: yes, it's in IO. Catch doesn't seem to work?
16:58:45 <Cale> adekoba: Control.Exception.catch ?
16:58:54 <Cale> adekoba: It should throw an ErrorCall exception.
16:59:01 <Lemmih> adekoba: Control.Exception.catch is different from Prelude.catch
16:59:13 <Cale> Prelude.catch should be removed.
16:59:16 <adekoba> Lemmih: yes. I'm currently using Control.Exception.catch
16:59:22 <tehgeekmeister> i've been lazy and not put any type signatures in my code: is there a way ghc can tell me the type signatures of all my functions so i can start doing that now?
16:59:35 <Cale> tehgeekmeister: yes
16:59:43 <Cale> tehgeekmeister: In ghci, you can type :t functionName
16:59:45 <adekoba> tehgeekmeister: I know you can go into ghci and do :t <function>
16:59:49 <Cale> and it'll give you the type
16:59:49 <adekoba> yeah..
16:59:56 <tehgeekmeister> thanks
17:00:36 <Lemmih> tehgeekmeister: There's also a compiler flag for that.
17:00:36 <alson> Are there any good guides on converting from hs-plugins to ghc-api?
17:00:46 <alson> haven't seen anything on The Google yet
17:00:50 <tehgeekmeister> wow, i have some nasty looking type signatures
17:00:53 <Cale> alson: Using hint would probably be gentler.
17:01:15 <alson> Cale: really?  Does it offer good runtime performance (compiled)?
17:01:22 <Cale> @hackage hint
17:01:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
17:01:31 <Cale> It's just a wrapper around the ghc apie
17:01:33 <Cale> api*
17:01:53 <Cale> It can compile with optimisations
17:02:32 <adekoba> so when I use decode (http://tinyurl.com/7rok6c) and it fails, catch doesn't seem to "catch" it.
17:03:01 <Saizan> you've to use Control.Exception.catch
17:03:15 <Saizan> and be sure to force the value inside its scope
17:03:26 <alson> Cale: good stuff.  I had looked at it, but had only seen "Interpreter" and couldn't see how to get it to compile.
17:03:32 <Cale> Ah, he's probably leaving out the call to evaluate
17:03:50 <luite_> @seen dons
17:03:50 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 2h 37m 27s ago.
17:04:05 <tehgeekmeister> Lemmih: does it automatically add them for you, as opposed to having to copy and paste them yourself?
17:04:13 <Cale> alson: Yeah, it mentions "Interpreter", but GHC is a compiler, so it actually compiles the code you give it.
17:05:02 <Lemmih> tehgeekmeister: No, it'll just say "You have a top-level function without a type signature! Here's the type: ...'.
17:05:23 <bhurt> Pumpkin: getting the code right is a little harder than I thought, but my basic approach is for every number k less than x (x is the number I'm trying to partition), create the partition of (x-k) (recursively calling myself), then prepend k onto the head of every list.
17:05:41 <bhurt> This generates a lot of duplicate lists, however.
17:05:42 <pumpkin> bhurt: oh, I just want to know how many of them there are
17:05:57 <adekoba> Saizan: force the value? Does that mean using Control.Exception.evaluate?
17:06:33 <Cale> bhurt: The easiest way to construct partitions of an integer is to write the function which constructs partitions of an integer n into parts of size at most k, and then use that.
17:06:56 <bhurt> That was going to be my next solution.
17:06:58 <Saizan> adekoba: yes, or (return $!) but you might also need to add more strictness if the result is a comples structure
17:07:02 <wli> I'd try parts of size k.
17:07:14 <bhurt> Pumpkin: the easiest way I can think of to figure out how many of them there are is to generate them and count them.
17:07:15 <Cale> Exactly k?
17:07:35 <wli> Ergh, k parts.
17:08:09 <bhurt> Wait a minute.  We may be able to be clever here.
17:08:26 <Cale> That'd work, but it's tougher than parts of size at most k
17:08:46 <bhurt> The number 1 has only one partition- 1 itself.
17:09:22 <Cale> A partition of n into parts of size at most k is a number j from 1 up to k followed by a partition of n-j into parts of size at most j.
17:09:33 <tehgeekmeister> do blocks evaluate to the last expression that's run in the block, correct?  and you use return to pass something out to be used somewhere else?
17:09:43 <Cale> A partition of n is a partition of n into parts of size at most n.
17:09:48 <Zao> tehgeekmeister: return doesn't control flow.
17:09:55 <Zao> tehgeekmeister: It only lifts a value into the monad.
17:10:12 <bhurt> Hmm.  All pumpkin needs is the count- so I'm playing with the idea that if we know the number of solutions for x-1, can we calculate the number of solutions for x?
17:10:22 <pumpkin> there are several recurrences for it
17:10:25 <Cale> Oh, you'd do that in a similar way.
17:10:42 <Cale> Rather than actually picking j, you just multiply by it.
17:10:48 <Zao> > (do ; return 42 >> return 3) :: [Int]
17:10:48 <tehgeekmeister> Zao: understood, but you've gotta wrap the value in return if you're going to get it to be the value of a do block's evaluation; you get what i mean?
17:10:49 <Cale> er
17:10:50 <lambdabot>   [3]
17:10:56 <Cale> rather, you sum over the options
17:11:07 <tehgeekmeister> > (do ; return 42 >> 3) :: [Int]
17:11:08 <lambdabot>       No instance for (Num [Int])
17:11:08 <lambdabot>        arising from the literal `3' at <int...
17:11:17 <Cale> (since there's a dependence on j)
17:11:20 <tehgeekmeister> see?  that's the difference
17:11:32 <pumpkin> I remember playing with the partition function in my combinatorics class, but don't remember much beyond that :P
17:11:33 <bhurt> So, no opinions on my type classes vr.s functions question?
17:11:39 <Zao> tehgeekmeister: The type of the last expression has to match the type expected.
17:11:40 <adekoba> Saizan: http://hpaste.org/13220
17:11:46 <adekoba> Saizan: still, doesn't seem to work
17:12:04 <tehgeekmeister> Zao: yep.  i was just making sure the last expression was the one that determined the value of the whole, that's all.
17:12:15 <tehgeekmeister> Zao: little rusty from not having touched haskell for around four months.
17:12:27 <Cale> > let partitions' 0 k = []; partitions' n k = sum [partitions' (n-j) j | j <- [1..k]] in partitions' 5 5
17:12:28 <lambdabot>       No instance for (Num [a])
17:12:29 <lambdabot>        arising from a use of `partitions'' at...
17:12:31 <Zao> tehgeekmeister: do is just a lot of sugar around >> and friends.
17:12:31 <Cale> er
17:12:36 <Cale> > let partitions' 0 k = 1; partitions' n k = sum [partitions' (n-j) j | j <- [1..k]] in partitions' 5 5
17:12:39 <lambdabot>   * Exception: stack overflow
17:12:43 <Cale> heh
17:12:44 <pumpkin> :o
17:12:54 <Cale> oh, right
17:12:54 <pumpkin> sum is nasty
17:13:33 <int-e> > let partitions' 0 k = 1; partitions' n k = sum [partitions' (n-j) j | j <- [1..min n k]] in partitions' 5 5
17:13:34 <lambdabot>   7
17:13:43 <Cale> right
17:13:43 <bhurt> Also, Cale, you're not eliminating duplicates I don't think.
17:13:49 <Cale> bhurt: No, I am.
17:13:58 <Cale> bhurt: They're generated in descending order.
17:13:58 <tehgeekmeister> aww, i'm not sure how to make this expression the last one in the block...
17:14:25 <pumpkin> however, that seems rather slow
17:14:41 <pumpkin> I guess there's no explicit formula for partitions?
17:14:46 <Cale> > let partitions' n k | k > n = partitions' n n; partitions' 0 k = 1; partitions' n k = sum [partitions' (n-j) j | j <- [1..k]] in partitions' 5 5
17:14:48 <lambdabot>   7
17:14:49 <bhurt> Cale: OK, I'm being stupid.
17:14:54 <Cale> pumpkin: There is.
17:15:13 <int-e> pumpkin: http://hpaste.org/13221
17:15:24 <Cale> pumpkin: There's an asymptotic approximation which is exact in the sense that its floor is the exact result.
17:15:27 <int-e> almost totally non-instructive, I'm afraid.
17:15:31 <pumpkin> ah
17:15:46 <int-e> (try to find the pentagonal numbers :)
17:16:18 <pumpkin> yeah, those are easy to get :P
17:16:46 <int-e> no, I meant in that paste.
17:16:50 <pumpkin> oh lol
17:17:09 <wli> > let n `parts` k | n < k = [] | k == 1 = [[n]] | otherwise = concat [map (m:) . filter (all (>=m)) $ (n - m) `parts` (k - 1) | m <- [1 .. k `min` (n - 1)]] in 7 `parts` 3
17:17:10 <lambdabot>   [[1,1,5],[1,2,4],[2,2,3]]
17:18:12 <pumpkin> int-e: I will study that for a month and get back to you :P
17:20:06 <tehgeekmeister> http://hpaste.org/13222 <== wondering how to change my code so instead of printing a value and putting another into the db, it generates a lazy list of the values it was putting in the db
17:21:17 <Cale> tehgeekmeister: hmm... without looking at the code, that sounds suspicious
17:21:22 <tehgeekmeister> (line 41 is where i print the value and put it into the db, the values which i'd like to make a lazy list of.)
17:21:35 <tehgeekmeister> Cale: how so?
17:21:42 <Cale> tehgeekmeister: If it has to put the values into the DB, it has to evaluate them, in which case they can't really be lazy.
17:21:43 <tero-> mmorrow: ok. I'll have a look at it, thanks
17:21:44 <pumpkin> Cale's a suspicious guy
17:22:10 <int-e> tehgeekmeister: lazy in which sense?
17:22:53 <tehgeekmeister> int-e, Cale: i mean lazy as in the values won't be put into the list until somewhere else they're read from that list
17:25:33 <luite_> wow even with the extra (unnecessary) copy (because of missing unsafeThawU) the UArr implementation of my array shuffle is already 4x faster than the STUArray version
17:25:34 <Cale> err...
17:25:52 <int-e> tehgeekmeister: hrm. that only makes sense if you can suspend that computation you're in. I suspect that you can't. (But I don't know Text.XML.Expat)
17:26:00 <ozy`> tehgeekmeister: 40 inch widescreen monitors were not invented so that you could write code that spans the entire monitor...
17:26:27 <MyCatVerbs> ozy`: maybe not, but they're pretty good for that purpose =D
17:26:39 <ozy`> MyCatVerbs: this is why we can't have nice things
17:26:40 <tehgeekmeister> ozy`: i knew someone would say that.  i really do need to reformat this code, i apologize.  but i must point out i only have a 15" screen.  =P
17:26:43 <bhurt> ozy`: only after resetting your font size to 4pt...
17:26:51 <bhurt> :-)
17:27:31 <kpreid> bah. what we need is structure editors that automatically layout code to the viewer's display and preferences
17:27:43 <tehgeekmeister> int-e: okay, let me clarify more; i don't want parseElement to run away crazy building up that list faster than it can be consumed and using a ton of memory.
17:28:34 <bhurt> Actually, Haskell has the best reason to keep code under 80 chars wide I've ever seen: so that when you generate the latex from your literate haskell, the code doesn't run off the side of the page.
17:28:49 <pumpkin> use fullpage :P
17:29:08 <int-e> tehgeekmeister: oh. so what about forking an extra thread and communicating the elements to that thread (through an MVar or possibly a Chan) when they're produced?
17:29:24 <MyCatVerbs> ozy`: what, because we're guaranteed to abuse them? =D
17:29:31 <int-e> tehgeekmeister: you're in IO (indirectly) so "lazy list" is really a concept mismatch
17:29:48 <athos> @src curry
17:29:48 <lambdabot> curry f x y = f (x, y)
17:30:11 <athos> :t curry (+)
17:30:12 <lambdabot> forall a b. (Num (a, b)) => a -> b -> (a, b) -> (a, b)
17:30:49 <athos> :t curry (+) 2
17:30:50 <lambdabot> forall a b. (Num a, Num (a, b)) => b -> (a, b) -> (a, b)
17:30:50 <int-e> tehgeekmeister: alternatively, call any IO action to consume the item to the parsing function and call it when the item is produced.
17:31:23 <athos> > curry (+) 2 3 (1,2)
17:31:24 <lambdabot>       No instance for (Num (a, b))
17:31:24 <lambdabot>        arising from a use of `+' at <inter...
17:31:24 <tehgeekmeister> int-e: hmm, that sounds reasonable, but i'm still not sure how i build up a list inside a monad and then get it back out.  if that makes any sense at all?
17:32:13 <int-e> tehgeekmeister: it makes sense, but you won't be able to do it lazily in a reasonable sense of the word.
17:32:17 <int-e> @src mapM
17:32:17 <lambdabot> mapM f as = sequence (map f as)
17:32:22 <int-e> @src sequence
17:32:22 <lambdabot> sequence []     = return []
17:32:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:32:22 <lambdabot> --OR
17:32:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:33:16 <int-e> tehgeekmeister: err, qualification: you won't be able to do it lazily when you're inside the IO monad or a (state, reader) wrapper around it.
17:34:33 <tehgeekmeister> int-e: sorry, i'm still lost.  =/  i can write a function that generates a list in pure code, but i'm not quite sure how i do that once i'm inside a monad.
17:35:54 <int-e> > let generate 0 = return []; generate n = do x <- return n; xs <- generate (n-1); return (x:xs) in generate 10 :: Maybe [Int]
17:35:55 <lambdabot>   Just [10,9,8,7,6,5,4,3,2,1]
17:36:25 <BMeph_> tehgeekmeister: But, but...a list /is/ a Monad. ;p
17:36:38 <ozy`> tehgeekmeister: I always start my do blocks on a new line
17:36:40 <tehgeekmeister> BMeph_: quiet, you
17:36:55 <ozy`> ie. "do\n  stuff <- doStuff"
17:36:56 <pumpkin> is there an "integer logarithm" function for Integer?
17:37:09 <pumpkin> for an arbitrary base
17:37:12 <int-e> tehgeekmeister: that's how it works. the problem is, that if you do that in IO, you will not be able to consume the list before it is completely built. and there's really nothing that can be done about it - IO enforces sequential execution of its actions.
17:37:34 <tehgeekmeister> ozy`: oh, that's a good idea.  i thot the way i was formatting it was the ONLY correct way.  i'm still a bit unclear about how the syntax works as far as layout goes...
17:37:42 <int-e> tehgeekmeister: "nothing" meaning "unless you use unsafeInterleaveIO, but it's unsafe, and should not be used lightly. Oh, did we mention that it's unsafe?"
17:38:29 <tehgeekmeister> int-e: i'd be in the state monad when i was returning the value, wouldn't i?  or does that not count since it's really StateT IO?
17:38:43 <int-e> tehgeekmeister: oh and it also doesn't work when IO is nested in another monad.
17:38:47 <ozy`> tehgeekmeister: a do block starts not with the do keyword, but with the next non-whitespace character after it. "whitespace" includes newlines :p
17:38:47 <Beelsebob> > let generate 0 = pure []; generate n = (n:) <$> generate (n-1) in generate 10 :: Maybe [Int]
17:38:49 <lambdabot>       Ambiguous occurrence `pure'
17:38:49 <lambdabot>      It could refer to either `Control.Appl...
17:38:57 <Beelsebob> > let generate 0 = Control.Applicative.pure []; generate n = (n:) <$> generate (n-1) in generate 10 :: Maybe [Int]
17:38:58 <lambdabot>   Just [10,9,8,7,6,5,4,3,2,1]
17:39:10 <int-e> tehgeekmeister: yes, that's still essentially an IO monad - it still enforces sequential execution.
17:39:13 <Beelsebob> yay for not using monads where they're not needed
17:39:31 <int-e> Beelsebob: but that is completely missing the point.
17:39:58 <Beelsebob> oh? I just saw the random line, and went "but that's just applicative", what's the point?
17:40:22 <tehgeekmeister> Beelsebob: i needed an example of how to generate a list from monadic code.
17:40:27 <int-e> Beelsebob: that the topic was monads, and that the x <- return n was just a placeholder for some more complicated monad action.
17:40:40 <Beelsebob> ah, I see
17:41:26 <int-e> Beelsebob: you're right of course.
17:42:11 <tehgeekmeister> hum.  i'm still lost.  maybe i need to come back to this a bit later.
17:43:36 <mbz> @pl \x -> (x,x)
17:43:37 <lambdabot> join (,)
17:44:18 <tehgeekmeister> int-e: so if i passed all the values out via an mvar and built up the list in another thread, would the whole list still have to be built before any of it could be consumed and garbage collected?
17:44:41 <tehgeekmeister> int-e: or in other words is there no way to avoid building the WHOLE list in memory all at once?
17:46:09 <int-e> tehgeekmeister: if you want to consume the list on the fly you probably need a callback that is called once per list item and processes it (insert is essentially such a callback).
17:46:29 <int-e> tehgeekmeister: so you'd never generate that list at all.
17:47:01 <tehgeekmeister> int-e: the point was specifically to generate a list so i could pass that to executeMany, and thus speed up populating the database
17:47:14 <pumpkin> wooo, solved another PE problem using Omega
17:47:17 <pumpkin> it's so useful
17:47:27 * pumpkin becomes an Omegavangelist
17:47:49 <tehgeekmeister> pumpkin: omega?
17:47:54 <pumpkin> Control.Monad.Omega
17:48:13 <tehgeekmeister> if that doesn't sound like a scary module, i'm not sure what would.
17:48:21 <int-e> tehgeekmeister: I guess you can build chunks of queries - collect, say, 100 of them, then uses executeMany to process them.
17:48:24 <pumpkin> it's really not
17:48:30 <ozy`> THE OMEGA MODULE... yeah, not scary at all
17:48:54 <pumpkin> you can think of it as something that allows you to make list comprehensions over multiple infinite lists
17:48:58 <tehgeekmeister> hey, monad by itself sounds scary to me still
17:49:04 <tehgeekmeister> add in omega and it's no better
17:49:08 <pumpkin> :)
17:49:44 <pumpkin> say you wanted [(x, y) | x <- [1..], y <- [1..]]
17:49:52 <pumpkin> > [(x, y) | x <- [1..], y <- [1..]]
17:49:53 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
17:50:01 <pumpkin> ack, it's stuck on x = 1, and will never end
17:50:06 <pumpkin> because y isn't finite
17:50:06 <tehgeekmeister> int-e: i'm just surprised there's no way to generate this list "lazily" enough to consume it on the fly.  it seems there's gotta be SOME way to do that...
17:50:14 <pumpkin> omega allows you to generate all pairs
17:50:20 <tehgeekmeister> !!!
17:50:23 <tehgeekmeister> that's freaking cool.
17:50:24 <Administrador> Asians, Whites, Amerindians, and Mestizos are descended from extraterrestrials who mixed with anthropoids and Neanderthals.  Niggggers really did solely evolve from just MONKEYS.  Join us today at Chimpout.com!  No matter what race you are, as long as you aren't a nigiigger.  http://www.chimpout.com/forum/index.php
17:50:41 <pumpkin> ?op
17:50:41 <lambdabot> Maybe you meant: . ? @ bf ft id map pl rc v wn yow
17:51:14 <pumpkin> Saizan: you around?
17:51:28 <pumpkin> oh nevermind :)
17:51:38 <luite_> hmm, why does he obfuscate the n-word? does that get you a k-line automatically?
17:51:57 <pumpkin> luite_: doubt it
17:52:13 <pumpkin> maybe on some networks, so their script does it to be safe
17:52:28 <pumpkin> is there some way I can get Omega onto lambdabot?
17:52:32 <pumpkin> :t runOmega
17:52:34 <lambdabot> Not in scope: `runOmega'
17:52:39 <pumpkin> , runOmega
17:52:41 <lunabot>  luna: Not in scope: `runOmega'
17:53:38 <pumpkin> anyway, tehgeekmeister, this is what I get from omega for the "same" "comprehension": [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,3),(4,2),(5,1) ...
17:53:51 <pumpkin> it works in the same way you can count the rationals
17:54:13 <tehgeekmeister> ah, cool.
17:54:22 <tehgeekmeister> which allows you to do a lot more with it.
17:54:57 <pumpkin> yup, it's mostly me being lazy for project euler problems that require me to check an expression over multiple variables
17:55:04 <luite_> hm, I wonder why profiling makes my problem at least 100x slower :(
17:55:22 <pumpkin> luite_: someone's in there with pen and paper writing down what you do as you do it!
17:55:30 <pumpkin> luite_: you can't expect him to write too fast
17:55:49 <pumpkin> it's a little demon
17:56:41 <tehgeekmeister> pumpkin: apparently not a speed demon.
17:56:52 <jsn> homonunculus
17:57:00 <int-e> tehgeekmeister: it's possible to do that - producing lists element by element from another thread. have a look at Control.Concurrent.Chan.getChanContents for example.
17:57:05 <luite_> hm, actually it's about 500 times slower
17:57:25 <tehgeekmeister> int-e: oh, is that analogous to getContents?
17:57:29 <pumpkin> Cale, int-e: is there another "simple" way of determining the shortest partition of a number (in terms of number of additions)?
17:57:45 <tehgeekmeister> int-e: if so that's JUST what i meant by lazy, even if that's not the real meaning of the term.
17:57:56 <redditbot> Turbinado: Implementing a poor-man's wiki | Alson Kemp
17:57:58 <Cale> pumpkin: The shortest partition of a number is always the number itself
17:58:09 <pumpkin> Cale: oh, you're right
17:58:12 <int-e> pumpkin: n = n is rather short
17:58:14 <pumpkin> :P
17:58:22 <pumpkin> and I guess, if I didn't want that one, I could subtract 1
17:58:24 <pumpkin> :P
17:58:36 <pumpkin> hmm
17:58:46 * pumpkin needs to think this problem through a little more
17:59:04 <luite_> pumpkin: the thing is that I wonder why it's suddenly so slow, I just changed some things from STUArray to MUArr. the old program only ran about twice as slow when profiling
17:59:07 <int-e> tehgeekmeister: it needs two threads to work, obviously. and you're trusting executeMany to process the list in chunks, not as a whole.
17:59:40 <tehgeekmeister> int-e: hmm.  well, it's worth a try.  if it doesn't work i can suffer thru 40 or so hours to populate the database...
17:59:42 <pumpkin> luite_: I don't really know :) was just being silly there... it does seem awfully slow, even for profiling
18:00:34 <luite_> pumpkin: hehe, np :) I just reduced my problem size, I hope my profiling data is still meaningful now
18:00:59 <Cale> pumpkin: The shortest partition of n into parts of size at most k (when k <= n) will have ceiling(n/k) parts.
18:01:09 <pumpkin> Cale: yeah
18:01:29 <pumpkin> that makes sense, I was just thinking of this problem wrong :P
18:02:16 <int-e> tehgeekmeister: looking at HDBC-postgresql looks like it won't matter, performance wise. what probably *will* matter is executing the prepare conn "INSERT INTO articles VALUES (?, ?, ?);"
18:02:34 <int-e> tehgeekmeister: only once and passing the result to  insertArticle as an extra argument.
18:02:52 <int-e> tehgeekmeister: right now you do that once per article.
18:03:17 <tehgeekmeister> int-e: okay, i didn't think that'd matter.  i'll try that first.
18:03:26 <tehgeekmeister> that's mch, much easier.
18:03:33 <tehgeekmeister> int-e: thanks for all your help
18:04:41 <chrisdone> is there a fail alias that doesn't take a string?
18:05:32 <chrisdone> I'm using a monad which ignores it >_~
18:08:59 <monochrom> If you use MonadPlus, there is mzero which is usually the same as fail.
18:09:13 <FunctorSalad> or you could use MonadError
18:09:24 <monochrom> It doesn't take a string. So it doesn't ignore anything, since there is nothing to ignore.
18:10:31 * monochrom actually doesn't understand the logic behind "someone's fail ignores the string, so now I want something that doesn't take a string".
18:12:26 <Cale> chrisdone: You probably should just avoid fail altogether.
18:12:49 <Cale> chrisdone: If you need to express failure, for now the best you can do is MonadPlus
18:13:04 <chrisdone> okay then
18:13:07 <Cale> (or pick a specific kind of failure)
18:13:14 <Cale> Maybe/Either are good.
18:13:16 <chrisdone> I was using Control.Monad.Maybe but that doesn't have MonadPlus
18:13:28 <Cale> Maybe is an instance of MonadPlus
18:13:38 <chrisdone> the transformer isn't
18:13:54 <Cale> Oh... I would think it really ought to be.
18:13:58 <chrisdone> there's one on the wiki I guess I could use
18:14:00 <chrisdone> Cale: http://hackage.haskell.org/packages/archive/MaybeT/0.1.1/doc/html/Control-Monad-Maybe.html#1
18:14:02 <Cale> There's an obvious instance.
18:15:07 <Cale> chrisdone: Yeah, that's a shame.
18:15:21 <Cale> chrisdone: Maybe I should download the package, modify it and reupload it :)
18:15:27 <chrisdone> pity they couldn't export two modules
18:15:29 <chrisdone> Cale: yes! :P
18:17:01 <mmorrow> pumpkin: lunabot haskell Control.Monad.Omega now
18:17:02 <chrisdone> I'm trying to write a unfifier, so I'm using MaybeT (State Env), where I use MaybeT's failure when two terms don't match, and State to store the "frame" of bindings. I figured this was a nice abstraction
18:17:02 <mmorrow> , diagonal (repeat [0..])
18:17:04 <lunabot>  [0,1,0,2,1,0,3,2,1,0,4,3,2,1,0,5,4,3,2,1,0,6,5,4,3,2,1,0,7,6,5,4,3,2,1,0,...
18:17:09 <int-e> mmm, all the SQL libs seem to be String based internally. :/
18:17:14 <pumpkin> mmorrow: thanks :)
18:17:29 <mmorrow> chrisdone: cool, have you seen vixey's that she pasted?
18:17:29 <pumpkin> , liftM2 (,) (each [1..]) (each [1..])
18:17:31 <lunabot>  luna: No instance for (GHC.Show.Show
18:17:32 <mmorrow> pumpkin: np
18:17:36 <pumpkin> , runOmega $ liftM2 (,) (each [1..]) (each [1..])
18:17:38 <lunabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),...
18:17:39 <chrisdone> mmorrow: nope
18:17:42 <pumpkin> whee :)
18:18:40 <mmorrow> chrisdone: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62#a62
18:18:42 <monochrom> Does d2d mean p2p in the Southern Hemisphere? :)
18:20:06 <dancor> is using system in Setup.hs still the best way to make quickcheck part of the compile?  as per http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
18:20:31 <mmorrow> monochrom: i'm not sure, but i hear they say "pupu" instead of "dude" fwiw
18:20:38 <mmorrow> pupe
18:20:55 <mmorrow> i can't even spell imaginary words correctly
18:21:09 <dancor> in some ways those are the hardest to spell
18:21:32 <dancor> it requires an extension of the real letters
18:21:50 <mmorrow> algebraic closure of teh words
18:22:15 <dancor> ^i^
18:25:25 <chrisdone> mmorrow: yeah that's pretty cool
18:27:09 <chrisdone> guess I'll write something else :P
18:27:17 <Gracenotes> Haskell version: http://stackoverflow.com/questions/383403/code-golf-print-the-entire-12-days-of-christmas-song-in-the-fewest-lines-of-code#384018 :)
18:28:26 <Gracenotes> prints out the 12 days of christmas song in aroudn 500 characters...
18:29:38 <mmorrow> chrisdone: heh
18:31:21 <chrisdone> Gracenotes: hmm. the lisp version takes advantage of rhtier sweet format function of course
18:31:22 <dancor> Gracenotes: the 'do' is unneeded right?
18:31:54 <Gracenotes> dancor: I'm not entirely positive. I've written far more one-liners than I have actual programs (ghci vs. runhaskell)
18:32:09 * Cale uploads a new MaybeT package ;)\
18:32:22 <chrisdone> ^_^ !
18:32:28 <dancor> you only need do if you have multiple lines in the monad
18:32:30 <Cale> Slightly evil, as I'm not the original uploader, but then, the original uploader is not the original maintainer.
18:32:34 <monochrom> sudo putStrLn "make sandwich"
18:32:57 <chrisdone> mmorrow: could use that class towr ite a simple logic language, eh? one instance for the pattern matching, one for theunification, like in SICP λ_λ
18:33:04 <Gracenotes> dancor: ah, that saves 3 characters :D
18:33:10 <dancor> score
18:33:34 <chrisdone> Cale: fair's fair!
18:33:40 * chrisdone redownlaods
18:34:02 <Cale> chrisdone: So it now has a MonadPlus instance. mplus x y will execute y only if x executes mzero at some point.
18:35:36 <tehgeekmeister> int-e: okay, that change is done, it seems to be going a bit faster subjectively.  any idea why some of the inserts would take twenty or so seconds?
18:35:49 <chrisdone> Cale:
18:35:51 <chrisdone> Prelude Control.Monad.Maybe Control.Monad.State> evalState (runMaybeT (do mzero; return 1)) undefined
18:35:51 <chrisdone> Nothing
18:35:55 <chrisdone> Cale: exactly what i wanted!
18:36:04 <mmorrow>  chrisdone: i'm not familiar with λ_λ (but i'm gonna check it out), but totally
18:36:07 <int-e> tehgeekmeister: sorry, nope. unless it's GC kicking in (but 20 seconds seems excessive for that)
18:36:09 <dancor> UsurpT
18:36:25 <chrisdone> mmorrow: haha. that's  ^_^
18:37:06 <chrisdone> I love the sound yobbos outside at 2 in the morning. it adds colour to my black and white life
18:37:19 <Cale> chrisdone: Oh, also, it now reexports all of Control.Monad.Trans and just MonadPlus from Control.Monad
18:37:33 <chrisdone> mmorrow: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html
18:37:46 <mmorrow> nice
18:38:05 <chrisdone> Cale: oh I see. fair enough?
18:38:25 <Cale> (I was annoyed to have to import Control.Monad.Trans to use lift.)
18:38:32 <tehgeekmeister> int-e: hum.  so far it seems to be going just about the same speed from back of the envelope calculations.  gotta find somewhere else to optimize, i guess?
18:38:51 <Cale> Libraries which define monad transformers probably should always reexport Control.Monad.Trans
18:38:54 <chrisdone> Cale: ah, I see. yeah
18:38:58 <mmorrow> chrisdone: ah, i see where this is headed. sounds interesting.
18:38:58 <chrisdone> agreed
18:39:52 <mmorrow> yeah, i've started to do that with TH-using modules
18:40:07 <mmorrow> (re-export all the TH one'd need)
18:43:25 <pumpkin> mmorrow = THevangelist
18:44:47 <chrisdone> heard you like template haskell so we put a quasi quoter in your quasi quoter..
18:45:12 <Zao> quasi recursion?
18:46:14 <chrisdone> requarsion
18:48:06 <gwern> yocursion, you mean
18:48:36 <Gracenotes> @unpl fix
18:48:37 <lambdabot> fix
18:48:53 <chrisdone> yomad
18:49:30 <gwern> yocursion is the dual of requarsion, via a hoodomorphism. it supports mamads with nonlocal exits
18:50:02 <gwern> when your mamad exits round the stack, she exits round the stack!
18:50:53 <gwern> when you mamd pops a stack frame, that frame stays popped!
18:51:06 <Gracenotes> isn't a mamad just an arrow between phallomorphic unctorisms?
18:51:24 <gwern> your mamad's heap is so big, voyager had to take her portrait!
18:53:12 * Gracenotes must be thinking of another mamad
18:53:21 <gwern> yo mamad's more unsafe than head [], cause she's got two _|_s!
19:10:02 <gwern> > (10 / 7000000000)*100
19:10:04 <lambdabot>   1.4285714285714287e-7
19:10:21 <gwern> > 100-((10 / 7000000000)*100)
19:10:22 <lambdabot>   99.99999985714285
19:10:56 <chrisdone> wat
19:11:05 <gwern> ?
19:11:15 <chrisdone> excuse me wtf r u doin
19:12:15 <gwern> chrisdone: I am calculating roughly what percentage of humanity cannot access a dead webpage archived by the Internet Archive but kept private
19:12:22 <gwern> in case you were wondering -_-
19:14:20 <chrisdone> ah. ~_~
19:15:02 <chrisdone> in lojban I'd express empathy with your annoyance as {oi dai}, but I'll have to use emoticons instead. will that be satisfactory?
19:15:40 <gwern> eminently
19:15:43 <chrisdone> /( ~_~)/ “there there”
19:16:15 <chrisdone> needs moar loeb
19:16:16 <chrisdone> @type loeb
19:16:18 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
19:16:20 <chrisdone> yay
19:16:48 <chrisdone> > loeb [const 1, (*2) . (!!0)]
19:16:50 <lambdabot>   [1,2]
19:17:33 <chrisdone> > loeb $ [const 1] ++ [ (*n) . (!!n) | <- [1..10] ]
19:17:34 <lambdabot>   <no location info>: parse error on input `<-'
19:17:49 <chrisdone> > loeb $ [const 1] ++ [ (*n) . (!!n) | n <- [1..10] ]
19:17:51 <lambdabot>   [1,* Exception: stack overflow
19:17:56 <chrisdone> humph
19:18:06 <chrisdone> > loeb $ [const 1] ++ [ (*n) . (!!n) | n <- [0..10] ]
19:18:09 <lambdabot>   [1,0,0,0,0,0,0,0,0,0,0,0]
19:18:18 <chrisdone> > loeb $ [const 1] ++ [ (*(n+1)) . (!!n) | n <- [0..10] ]
19:18:19 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800]
19:19:03 <chrisdone> > loeb $ [const 1,const 1] ++ [ (*n) . (!!(n-1)) | n <- [1..10] ] -- amidoinitrite?
19:19:05 <lambdabot>   [1,1,1,2,3,8,15,48,105,384,945,3840]
19:19:12 <chrisdone> ~_~
19:20:30 <chrisdone> > loeb $ [const 1] ++ [ (+1) . (!!n-1) | n <- [1..10] ]
19:20:31 <lambdabot>       The operator `!!' [infixl 9] of a section
19:20:31 <lambdabot>          must have lower prec...
19:20:37 <chrisdone> > loeb $ [const 1] ++ [ (+1) . (!!(n-1)) | n <- [1..10] ]
19:20:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
19:21:10 <tehgeekmeister> http://hpaste.org/13223 <== getting a GHC internal error.
19:21:56 <jowens> howdy, can i get a hint on building a list with the following properties: element n is f(n-1)?
19:22:16 <tehgeekmeister> i suspect it's because i did something something i shouldn't have with the concurrency
19:22:25 <jowens> the fib sequence construction is beautiful, but not perfectly applicable here.
19:22:45 <pumpkin> jowens: map (f (n - 1)) [1..]
19:23:03 <twanvl> > iterate f x
19:23:05 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
19:23:20 <jowens> iterate.
19:23:21 <jowens> yes of course.
19:23:25 <jowens> still learning the prelude.
19:23:26 <jowens> thanks!
19:23:28 <jowens> y'all rock.
19:23:42 <pumpkin> ah, whoops :)
19:23:47 <racliv> > (+1) == (1+)
19:23:48 <lambdabot>       No instance for (Eq (a -> a))
19:23:48 <lambdabot>        arising from a use of `==' at <int...
19:24:00 <pumpkin> racliv: that would be awesome :P
19:24:18 <kpreid> @check \x -> (x + 1) == (1 + x)
19:24:19 <lambdabot>   "OK, passed 500 tests."
19:25:29 <kpreid> @check let f === g = liftM2 (==) in (+1) === (1+)
19:25:30 <lambdabot>       No instances for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
19:25:30 <lambdabot>         ...
19:25:48 <racliv> is there a list of the "to mock a mockingbird" combinators in haskell?
19:25:55 <kpreid> @check let (===) = liftM2 (==) in (+1) === (1+)
19:25:56 <lambdabot>   "OK, passed 500 tests."
19:26:07 <kpreid> there we go
19:26:10 <jowens> and is there an opposite to dropWhile? take elements until a condition is met?
19:26:20 <kpreid> @hoogle takeWhile
19:26:20 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
19:26:20 <lambdabot> Data.ByteString takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
19:26:20 <lambdabot> Data.List takeWhile :: (a -> Bool) -> [a] -> [a]
19:26:24 <tehgeekmeister> hmm.  it's easy to run out of memory using chans.  =/
19:26:43 <racliv> @hoogle liftM2
19:26:43 <jowens> thank you, all who know the prelude back to front. :)
19:26:43 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:27:02 <racliv> @src liftM2
19:27:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:28:28 <kpreid> racliv: that's using the reader monad instance; feel free to not understand it
19:28:42 <tehgeekmeister> Botje: you were the one who warned me about chans eating up memory, weren't you?
19:28:50 <racliv> so does liftM2 just apply a function to two values wrapped in a monad?
19:28:57 <kpreid> yes
19:29:28 <tehgeekmeister> oh!  that's what's happening...
19:29:37 <kpreid> in this case the monad is the (x ->) monad, and Num x
19:29:47 <kpreid> that monad passes around an argument
19:29:57 <tehgeekmeister> of course.  if you never empty the channel and there's still a reference to it.  it'll get pretty big that way.
19:30:06 <kpreid> so liftM2 foo f g applies foo to the result of f and g applied to the hidden parameter
19:30:16 <kpreid> ...f and g each applied...
19:30:37 <twb> Argh, I always forget how to use foldl.
19:30:50 <kpreid> > (liftM2 (,) (+1) (+2)) 0
19:30:52 <lambdabot>   (1,2)
19:30:57 <tehgeekmeister> actually, does anyone know if getChanContents removes items from the chan as it reads them?
19:31:24 <kpreid> > liftM2 (,) [1,2] [3,4]
19:31:25 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
19:31:57 <kpreid> racliv: got it?
19:32:06 <racliv> yeah
19:32:24 <kpreid> incidentally liftM2 can be generalized by ap
19:32:30 <kpreid> but ap is even more confusing :-)
19:32:32 <kpreid> @src ap
19:32:32 <lambdabot> ap = liftM2 id
19:32:41 <twb> OK, a is the accumulator.  I'm OK now.
19:32:41 <racliv> i thought ap was just the s combinator
19:32:50 <kpreid> > return (,) `ap` [1,2] `ap` [3,4]
19:32:51 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
19:33:03 <jowens> ok, 3rd question. i want to calculate (x, f(x)) for lots of x. (map) i want to find the biggest f(x) (so i'd use maximum) but i need to return x, not f(x). Construct?
19:33:04 <racliv> @pl s (x y z) = x z (y z)
19:33:04 <lambdabot> (line 1, column 11):
19:33:04 <lambdabot> unexpected "="
19:33:04 <lambdabot> expecting variable, "(", operator or end of input
19:33:11 <racliv> @pl s x y z = x z (y z)
19:33:11 <lambdabot> s = ap
19:33:12 <kpreid> ap takes a function and an argument in the monad and applies
19:33:20 <kpreid> jowens: maximumBy?
19:33:24 <kpreid> :t maximumBy
19:33:24 <twb> kpreid: so it's just Lisp's APPLY?
19:33:25 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:33:31 <jowens> where is that function?
19:33:35 <kpreid> twb: no, very different
19:33:36 <jowens> (not in prelude)
19:33:41 <kpreid> @hoogle maximumBy
19:33:41 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
19:33:41 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
19:34:02 <kpreid> racliv: so it's the S combinator if the monad is the (e ->) monad
19:34:07 <kpreid> otherwise not :-)
19:34:16 <jowens> ok i'll check that out.
19:34:17 <jowens> thanks!
19:36:34 <luite_> jowens: the 'on' function may come in handy here: myMax f = maximumBy (compare `on` f)
19:36:54 <jowens> oh, cool, i'll check that out too, thanks!
19:37:07 <chrisdone> twb: the type tells you how to use it!
19:37:20 <chrisdone> :t foldl
19:37:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:37:41 <twb> chrisdone: yes, but I *always* have to glare at it to work out which argument is the accumulator.
19:37:51 <twb> chrisdone: probably SRFI-1 puts the arguments the other way around
19:40:28 <jowens> can i get an example of maximumBy?
19:40:29 <Riastradh> There are only two choices, but somehow everyone manages to do it differently.
19:40:38 <jowens> it's not on zvon or in my RWH book.
19:40:45 <chrisdone> twb: yeah, srfi-1's has the accumulator second, i.e. foldr
19:41:13 <chrisdone> :t foldr
19:41:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:41:14 * FunctorSalad throws right and left cosets around the room
19:41:20 <FunctorSalad> ;)
19:43:03 <chrisdone> > foldr f n [a,b,c]
19:43:04 <lambdabot>   f a (f b (f c n))
19:43:08 <chrisdone> > foldl f n [a,b,c]
19:43:10 <lambdabot>   f (f (f n a) b) c
19:43:28 <FunctorSalad> well yes, foldL is Left-associative
19:44:13 <jowens> @hoogle on
19:44:13 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:44:13 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
19:44:13 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
19:46:09 <FunctorSalad> > ((==) `on` length) [a,b] [1,2]
19:46:10 <lambdabot>   True
19:46:30 <FunctorSalad> wait, what is a? ;) lambdabot magic presumably
19:46:43 <FunctorSalad> @ty a
19:46:44 <lambdabot> Expr
19:46:54 <chrisdone> > ((,) `on` length) [a,b] [1,2]
19:46:56 <lambdabot>   (2,2)
19:47:50 <chrisdone> @check \x -> ((,) `on` length) x == (length***length) x
19:47:51 <lambdabot>   Couldn't match expected type `[a] -> (Int, Int)'
19:47:59 <FunctorSalad> @ty ((==) `on` length)
19:48:00 <lambdabot> forall a. [a] -> [a] -> Bool
19:48:17 <FunctorSalad> hmm wth did my example work then?
19:48:40 <chrisdone> a can be instantiated as Expr?
19:48:49 <FunctorSalad> it would need [a1] -> [a2] -> Bool
19:48:58 <FunctorSalad> yeah, I mean Expr /= Int
19:49:16 <chrisdone> hum
19:49:39 <FunctorSalad> > a == 1
19:49:41 <lambdabot>   False
19:49:52 <chrisdone> mmkay
19:49:57 <FunctorSalad> :)
19:50:04 <FunctorSalad> maybe number literals can be Expr's
19:50:07 <chrisdone> > (a == a,a == b)
19:50:07 <FunctorSalad> @ty 1
19:50:09 <lambdabot>   (True,False)
19:50:09 <lambdabot> forall t. (Num t) => t
19:50:22 <chrisdone> @ty 1 :: Expr
19:50:24 <lambdabot> Expr
19:50:27 <chrisdone> fair enough
19:50:37 <chrisdone> @ty [1..] :: [Expr]
19:50:39 <lambdabot> [Expr]
19:50:50 <FunctorSalad> > a + b
19:50:51 <lambdabot>   a + b
19:50:58 <pumpkin> > 1 + 2 :: Expr
19:51:00 <lambdabot>   1 + 2
19:51:12 <chrisdone> > 1 + 2 == (1 + 2 :: Expr)
19:51:13 <lambdabot>   True
19:51:18 <pumpkin> > sum [1..10] :: Expr
19:51:19 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
19:51:37 <chrisdone> > loeb [const 1, (*2) . (!!0)] :: [Expr]
19:51:38 <lambdabot>   [1,1 * 2]
19:52:00 <chrisdone> > loeb $ [const 1] ++ [ (+1) . (!!(n-1)) | n <- [1..10] ] :: [Expr]
19:52:02 <lambdabot>   [1,1 + 1,1 + 1 + 1,1 + 1 + 1 + 1,1 + 1 + 1 + 1 + 1,1 + 1 + 1 + 1 + 1 + 1,1 ...
19:52:29 <pumpkin> what is this loeb you keep playing with? :o
19:52:35 <chrisdone> haha
19:52:43 <FunctorSalad> > loeb a
19:52:45 <lambdabot>   Couldn't match expected type `f (f b -> b)'
19:52:47 <chrisdone> it's like a spreadsheet
19:53:17 <chrisdone> > loeb $ [const 1, (*5) . (!!0), (^3) . (!!1)]
19:53:19 <lambdabot>   [1,5,125]
19:53:20 <racliv> @src loeb
19:53:20 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:53:23 <chrisdone> > loeb $ [const 1, (*5) . (!!0), (^3) . (!!1)] :: [Expr]
19:53:25 <lambdabot>   [1,1 * 5,1 * 5 * (1 * 5) * (1 * 5)]
19:53:39 <chrisdone> loeb x = fmap (\a -> a (loeb x)) x
19:53:41 <pumpkin> hmm
19:54:08 <racliv> @pl loeb
19:54:08 <lambdabot> loeb
19:54:23 <pumpkin> @pl loeb x = fmap (\a -> a (loeb x)) x
19:54:23 <lambdabot> loeb = fix (fmap . flip id =<<)
19:54:43 <racliv> @unpl loeb = fix (fmap . flip id =<<)
19:54:43 <lambdabot> loeb = fix (\ e -> e >>= \ h -> fmap (\ c -> c h))
19:55:13 <twb> @hoogle (a -> [b]) -> [a] -> [b]
19:55:14 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
19:55:14 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
19:55:14 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
19:55:15 <chrisdone> I prefer the original definition
19:55:33 <chrisdone> :t (=<<)
19:55:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:56:02 <FunctorSalad> @ty (=<<) :: (a -> [b]) -> [a] -> [b] -- twb
19:56:04 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
19:56:12 <racliv> any reason why it's called loeb?
19:56:23 <FunctorSalad> the guy's name, I guess racliv
19:56:24 <twb> FunctorSalad: eh?
19:56:45 <FunctorSalad> twb: (=<<) instantiated for the list monad
19:57:03 <twb> FunctorSalad: why do I care about that?
19:57:15 <chrisdone> racliv: presumably something about Loeb's theorem but I don't think it's the same thing
19:57:16 <chrisdone> racliv: http://sigfpe.blogspot.com/2006/11/from-l-theorem-to-spreadsheet.html
19:57:23 <FunctorSalad> twb: you asked the bot :)
19:57:31 <twb> FunctorSalad: er, I was looking for concatMap
19:57:56 <FunctorSalad> ok, nvm then :)
19:58:05 * chrisdone just likes suggesting things
19:58:06 <pumpkin> chrisdone: why not löb ?
19:58:25 <chrisdone> pumpkin: written 2006. did haskell ahve unicode then? :P
19:58:30 <pumpkin> @let löb x = fmap (\a -> a (löb x)) x
19:58:32 <lambdabot>  Defined.
19:58:34 <pumpkin> it does now :)
19:58:43 <chrisdone> yay
19:58:49 * chrisdone figures out how to type that character
19:58:51 <pumpkin> now you can be even more esoteric
19:59:10 <racliv> hmm
19:59:11 <jowens> can i get an example of maximumBy? Would be much obliged.
19:59:19 <chrisdone> :t maximumBy
19:59:19 <pumpkin> on a mac, it's option + u, o
19:59:20 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:59:27 <mmorrow> wouldn't that be like lo-ob instead of lo-eb though
19:59:35 <chrisdone> > maximumBy compare [1..10]
19:59:37 <lambdabot>   10
19:59:43 <monochrom> > maximumBy (>) [1,2,3]
19:59:44 <pumpkin> > maximumBy (comparing snd) [(1,2), (2,5), (3,1)]
19:59:44 <lambdabot>   Couldn't match expected type `Ordering'
19:59:45 <lambdabot>   (2,5)
19:59:56 <monochrom> oops
20:00:01 <FunctorSalad> mmorrow: ö is commonly typed as oe if no ö is available
20:00:04 <chrisdone> > maximumBy (\a b -> if a > b then EQ else GT) [1..10]
20:00:06 <lambdabot>   1
20:00:19 <jowens> the "comparing" thing ... can i get an explanation of that?
20:00:23 <pumpkin> :t comparing
20:00:24 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
20:00:27 <pumpkin> @src comparing
20:00:27 <lambdabot> Source not found. Are you on drugs?
20:00:48 <mmorrow> FunctorSalad: sure, but it's not pronounced that way (i don't believe)
20:00:55 <chrisdone> > let (²) = (^2); (³) = (^3) in löb $ [const 1, (²) . (!!0), (³) . (!!1)]
20:00:55 <pumpkin> jowens: see that b -> b -> Ordering ?
20:00:56 <lambdabot>   [1,1,1]
20:01:00 <pumpkin> jowens: that's what compareBy wants
20:01:10 <mmorrow> i've gotta find my file of sub/sup scripts
20:01:12 <pumpkin> jowens: so you pass it a function to transform its two inputs by, and it compares based on that
20:01:20 <mbz> > 3 ³
20:01:21 <lambdabot>   <no location info>: parse error on input `;'
20:01:28 <chrisdone> :t comparing snd
20:01:29 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
20:01:35 <Gracenotes> the whole 'random insult' item can get frustrating after a while :/
20:01:36 <pumpkin> jowens: if that makes any sense
20:01:57 <chrisdone> Gracenotes: haha, from lambdabot?
20:02:22 <Gracenotes> yeah. If you don't have the source it's your own fault for not indexing it!
20:02:32 <racliv> :t foldl
20:02:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:02:40 <jowens> pumpkin: thanks.
20:02:44 <racliv> :t reduce
20:02:45 <lambdabot> Expr -> Expr
20:02:51 <chrisdone> @_@
20:03:02 <chrisdone> > reduce $ 1 * 1
20:03:03 * Gracenotes anthropomorphizes lambdabot, rawrawr
20:03:03 <lambdabot>   1
20:03:09 <chrisdone> hrrrrrm
20:03:11 <jowens> what is the difference between comparing and compareBy then?
20:03:15 <Gracenotes> > reduce $ (a - a)
20:03:17 <lambdabot>   a - a
20:03:19 <chrisdone> can we construct Exprs nonsyntactically?
20:03:37 <FunctorSalad> @vixen Gracenote think's you're not human :o
20:03:37 <lambdabot> i'm half white and half mexican
20:03:38 <chrisdone> :t compareBy
20:03:39 <lambdabot> Not in scope: `compareBy'
20:03:39 <chrisdone> :t comparing
20:03:41 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
20:03:46 <racliv> > reduce $ (a + (0 - b))
20:03:48 <lambdabot>   a + (0 - b)
20:03:49 <FunctorSalad> argh. "thinks"
20:03:56 <chrisdone> jowens: what's compareBy?
20:04:01 <Gracenotes> chrisdone: http://hackage.haskell.org/packages/archive/simple-reflect/0.1/doc/html/Debug-SimpleReflect-Expr.html
20:04:09 <jowens> pumpkin: jowens: that's what compareBy wants
20:04:11 <Gracenotes> 'tis all that is known :/
20:04:18 * chrisdone screams
20:04:18 <jowens> did pumpkin mean comparing?
20:04:25 <pumpkin> oh, I meant maximumBy
20:04:28 <chrisdone> > var "x"
20:04:29 <pumpkin> but also sortBy, minimumBy
20:04:29 <lambdabot>       Ambiguous occurrence `var'
20:04:29 <lambdabot>      It could refer to either `Data.Number.S...
20:04:36 <jowens> ah ok
20:04:38 <chrisdone> > var "x" :: Expr
20:04:39 <lambdabot>       Ambiguous occurrence `var'
20:04:39 <lambdabot>      It could refer to either `Data.Number.S...
20:04:51 <chrisdone> > Debug.SimpleReflect.Expr.var "x" :: Expr
20:04:52 <lambdabot>       Failed to load interface for `Debug.SimpleReflect.Expr':
20:04:52 <lambdabot>        Use -v ...
20:04:56 <chrisdone> tut
20:05:02 <pumpkin> sortBy (comparing snd) [(1,2),(1,5),(2,3),(1,100),(4,2)]
20:05:05 <chrisdone> what's it imported as?
20:05:08 <pumpkin> > sortBy (comparing snd) [(1,2),(1,5),(2,3),(1,100),(4,2)]
20:05:09 <lambdabot>   [(1,2),(4,2),(2,3),(1,5),(1,100)]
20:06:06 <jowens> so there's a maximumBy and a minimumBy. But we pass them an arbitrary function with which they compare. Could I pass a minimum function to maximumBy and make it act like minimum?
20:06:25 <Cale> yes
20:06:25 <pumpkin> jowens: sure
20:06:26 <chrisdone> jowens: yeah, if it did the reverse
20:06:31 <pumpkin> you could compare based on negate
20:06:36 <Cale> > maximumBy (flip compare) [1,2,3,4,5]
20:06:37 <lambdabot>   1
20:06:44 <pumpkin> > maximumBy (comparing negate) [1,2,3,4,5]
20:06:45 <lambdabot>   1
20:06:54 <pumpkin> Cale's is more efficient though :P
20:06:59 <chrisdone> > sortBy (flip compare) [1..5]
20:07:01 <lambdabot>   [5,4,3,2,1]
20:07:02 <Cale> (and general)
20:07:04 <mmorrow> , "⁰²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉"
20:07:06 <lunabot>  "\8304\178\179\8308\8309\8310\8311\8312\8313\8320\8321\8322\8323\8324\832...
20:07:12 <pumpkin>  :(
20:07:13 <mmorrow> doesn't look like there's a superscript 1
20:07:16 <Cale> , maximum "⁰²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉"
20:07:18 <lunabot>  '\8329'
20:07:19 <chrisdone> ¹²³
20:07:20 <racliv> > (Σ 0 10 (^2)) where Σ min max f = foldl1 (+) (map f [min..max])
20:07:21 <lambdabot>   Not in scope: data constructor `Σ'Not in scope: data constructor `Σ'
20:07:24 <mmorrow> chrisdone: nice
20:07:31 <mmorrow> , "¹²³"
20:07:32 <lunabot>  "\185\178\179"
20:07:36 <jowens> cool. thanks guys!
20:07:42 <chrisdone> welcome
20:07:56 <monochrom> Σ is a capital letter.
20:08:06 <chrisdone> why did the where clause in that not throw a syntax error?
20:08:13 <chrisdone> > a where a = 1
20:08:14 <mmorrow> @let supsub = "⁰¹²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉"
20:08:15 <lambdabot>   1
20:08:16 <lambdabot>  Defined.
20:08:22 <chrisdone> oh, I guess you added it due to all the bitching?
20:08:28 <monochrom> because the parser doesn't even have to read it.
20:08:34 <racliv> > supsub
20:08:36 <lambdabot>   "\8304\185\178\179\8308\8309\8310\8311\8312\8313\8320\8321\8322\8323\8324\8...
20:08:43 <Gracenotes> maximumBy cmp xs =  foldl1 maxBy xs
20:08:54 <Gracenotes> maxBy x y = case cmp x y of { GT -> x; _ -> y }
20:08:57 <mmorrow> @let sup = ("⁰¹²³⁴⁵⁶⁷⁸⁹"!!) . (`mod`10)
20:08:59 <lambdabot>  Defined.
20:09:16 <mmorrow> @let sub = ("₀₁₂₃₄₅₆₇₈₉"!!) . (`mod`10)
20:09:17 <lambdabot>  Defined.
20:09:20 <Gracenotes> minimumBy cmp xs  =  foldl1 minBy xs, and it's defined similarly
20:10:01 <Gracenotes> s/maxBy/where maxBy/
20:10:12 <mmorrow> gah, lunabot needs a way to define things
20:10:22 <mmorrow> , (text . utf8enc) "⁰²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉"
20:10:24 <lunabot>  ⁰²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉
20:10:35 <Gracenotes> > sup 3
20:10:37 <lambdabot>   '\179'
20:11:15 <mmorrow> i don't know of a function in lambdabot to utf8encode
20:11:15 <chrisdone> , text "PRIVMSG #haskell: unsafeAllowArbitraryCharacters\n"
20:11:18 <lunabot>  PRIVMSG #haskell: unsafeAllowArbitraryCharacters
20:11:23 <chrisdone> , text "\nPRIVMSG #haskell: unsafeAllowArbitraryCharacters\n"
20:11:24 <chrisdone> ?
20:11:25 <lunabot>  PRIVMSG #haskell: unsafeAllowArbitraryCharacters
20:11:28 <mmorrow> heh
20:11:29 <chrisdone> dang :P
20:11:50 <Gracenotes> plus, the syntax is a bit off ;)
20:11:53 <pumpkin> , text "> say \"hi\""
20:11:55 <lunabot>  > say "hi"
20:12:09 <chrisdone> Gracenotes: yeah, *tuts at himself*
20:12:11 <pumpkin> is it adding a space? my client eats it up
20:12:24 <chrisdone> it adds a space
20:12:27 <pumpkin> :(
20:12:33 <pumpkin> my client sucks
20:12:36 <chrisdone> your client uses trim?
20:12:38 <pumpkin> I had my hopes up
20:12:43 <pumpkin> yup
20:12:45 <chrisdone> what client?
20:12:45 <pumpkin> I guess
20:12:48 <pumpkin> linkinus
20:12:55 <pumpkin> it sucks, this is just another example of how :)
20:12:56 <chrisdone> can you hack it?
20:13:00 <chrisdone> oh
20:13:20 <pumpkin> I could, but it's not really worth it
20:13:24 <Gracenotes> I'll be able to get a better client once freenode implements SSL...
20:13:34 <pumpkin> actually, it's probably just using an html view for the channel
20:13:40 <chrisdone> Patrick_Bateman: do you like Huey Lewis and The News?
20:13:58 <Patrick_Bateman> I don't like singers.
20:14:01 <Gracenotes> ...or I can find a reliable proxy I can ssh into
20:14:26 <chrisdone> Gracenotes: got something to hide?
20:14:56 <luite_> what does unsafeInterleaveIO do? the haddock description is empty.
20:14:59 <Gracenotes> yes, from my university ;) it freezes the connection at higher ports when it sees "PRIVMSG" passing through
20:15:19 <Gracenotes> or "JOIN #channel", for that matter
20:15:22 <chrisdone> Gracenotes: ahh. yeah, I used to SSH tunnel home
20:15:32 <pumpkin> Gracenotes: why would it do that??
20:15:37 <pumpkin> that seems like an odd thing to do at university
20:15:53 <chrisdone> pumpkin: chatting is unproductive!!
20:15:58 <pumpkin> lol
20:16:04 <Gracenotes> I don't know, IRC is teh illegals if you use it for teh illegals thingz0rs
20:16:09 <Gracenotes> not very shocking.
20:16:18 <pumpkin> Gracenotes: x is teh illegals if you use it for teh illegals thingz0rz :P
20:16:31 <Gracenotes> :X
20:16:43 <pumpkin> I guess silly admins :)
20:16:44 <chrisdone> glasgow's is pretty good. IIRC they just ban you if you mess about
20:16:55 <chrisdone> and allow most things
20:17:35 <pumpkin> here it's mostly unrestricted, and you get public IPs too
20:17:46 <chrisdone> where's that?
20:17:53 <pumpkin> dartmouth
20:18:12 * chrisdone googlemaps
20:18:22 <pumpkin> it's in the middle of nowhere :P
20:18:39 <chrisdone> oh, massivecheesiepuffs
20:18:51 <pumpkin> ?
20:19:02 <chrisdone> not Massachusetts? ah
20:19:04 <Gracenotes> Dartmouth isn't that far away from here
20:19:10 <pumpkin> nope, NH
20:19:17 <Gracenotes> ...either MA or NH :)
20:19:17 <pumpkin> Gracenotes: where you at?
20:19:33 <pumpkin> lol
20:19:48 <Gracenotes> Long Island, although normally I live near Poughkeepsie. Just a 6-hour drive away! :)
20:20:01 <pumpkin> :o
20:20:16 <chrisdone> toga party?
20:20:39 <Gracenotes> never!
20:21:23 <pumpkin> :)
20:21:27 <chrisdone> hi chris
20:21:31 <Gracenotes> don't worry... categorically
20:22:01 <Gracenotes> a Haskell-learning party would be good
20:23:03 * dancor thought this was one
20:23:05 * tehgeekmeister just found some benchmarks of some other wikipedia dump imports, and is ashamed that his was going to take around 40 hours whereas others seem to be taking around one or two.
20:23:18 <Gracenotes> there's no free food, though
20:23:28 <tehgeekmeister> free food?
20:23:31 <tehgeekmeister> i'll take some.
20:23:47 <Gracenotes> tehgeekmeister: which dump?
20:24:03 <tehgeekmeister> french, current pages only
20:24:09 * pumpkin takes a dump
20:24:12 <pumpkin> ...from wikipedia
20:24:19 <Gracenotes> ah.
20:24:38 <tehgeekmeister> the benchmark was for german, but the two aren't that different in size
20:24:39 <Gracenotes> is that an XML or an SQL...?
20:24:59 <tehgeekmeister> xml, but we're comparing it to an xml to sql import
20:25:01 <tehgeekmeister> so it's fair there
20:25:11 <dancor> so runhaskell dosen't like -main-is eh
20:26:22 <tehgeekmeister> Gracenotes: http://hpaste.org/13222 <== that's essentially my current code
20:28:10 <Gracenotes> so you're reading the entire database into variables, then writing it all?
20:28:21 <Gracenotes> writing as you read..?
20:28:25 <tehgeekmeister> writing as read
20:28:41 <tehgeekmeister> it uses nearly constant memory
20:28:46 <tehgeekmeister> gets up to about 10mb total
20:28:46 <Gracenotes> okay, so not the former :)
20:29:16 <tehgeekmeister> it's about 3.8 gb total, so reading it all in just isn't an option
20:29:16 <tehgeekmeister> =P
20:29:30 <tehgeekmeister> well, at least i don't have that much ram.
20:29:32 <pumpkin> tehgeekmeister: you like your indentation, don't you :P
20:29:44 <Gracenotes> oh. yeah :) do you read it from online, or a downloaded copy?
20:29:58 <tehgeekmeister> Gracenotes: downloaded
20:30:19 <tehgeekmeister> pumpkin: actually it annoys the hell out of me, but i'm not too familiar with the layout rules of haskell, and i'm not using a good editor right now
20:30:37 <tehgeekmeister> pumpkin: i'd rather my code compile for now than have it be convenient
20:30:45 <pumpkin> yeah :)
20:31:07 <tehgeekmeister> pumpkin: that's all manually indented with spaces.  just think what i go thru when i change the arguments to parseElement
20:32:52 <mbz> tehgeekmeister, why aren't you using vim+indent plugin or emacs with haskell mode?
20:33:20 <mmorrow> @let utf8c=map chr.((let{fi=fromIntegral;multi x n=fi(x`shiftR`n Data.Bits..&.0x3f.|.0x80);f x n y=fi(x`shiftR`n.|.y);test n = span((/=0).(Data.Bits..&.(n::Int)))[0xffffff80,0xfffff800,0xffff0000,0xffe00000];s n = (take 1.reverse.snd.unzip)(zip(snd(test n))(reverse(zip([0,6,12,18])([0,0xc0,0xe0,0xf0]))))}in(\n->concatMap(\(a,b)->f n a b:(fmap(multi n).takeWhile(>=0))(iterate(\x->x-6)(a-6)))(s n)))).ord
20:33:22 <lambdabot>  Defined.
20:33:22 <tehgeekmeister> mbz: been too lazy to set either of them up yet.  i'll be so annoyed by it that i break down and do it soon, i'm sure.
20:33:23 <mmorrow> woot
20:33:31 <pumpkin> mmorrow: wow :P
20:33:34 <mmorrow> @let utf8 = concatMap utf8c
20:33:35 <lambdabot>  Defined.
20:33:42 <mmorrow> > utf8 supsub
20:33:44 <lambdabot>   "\226\129\176\194\185\194\178\194\179\226\129\180\226\129\181\226\129\182\2...
20:33:48 <mmorrow> > text $ utf8 supsub
20:33:49 <lambdabot>   â°Â¹Â²Â³â´âµâ¶â·â¸â¹ââââââââââ
20:33:50 <pumpkin> > say supsub
20:33:51 <lambdabot>   ⁰¹²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉
20:33:53 <mmorrow> aww crap
20:33:56 <mmorrow> ahh
20:33:57 <mmorrow> yeah
20:34:06 <mmorrow> pumpkin: heh, i forgot sabout say
20:34:07 <tehgeekmeister> wow.
20:34:08 <pumpkin> it already is utf8, right?
20:34:17 <mmorrow> > supsub
20:34:19 <lambdabot>   "\8304\185\178\179\8308\8309\8310\8311\8312\8313\8320\8321\8322\8323\8324\8...
20:34:34 <mmorrow> it's not utf8 already
20:34:42 <mmorrow> > utf8 supsub
20:34:44 <lambdabot>   "\226\129\176\194\185\194\178\194\179\226\129\180\226\129\181\226\129\182\2...
20:34:53 <tehgeekmeister> i'm really confused by what's making my code so much slower than this perl script that's doing about the same thing...
20:34:54 <mmorrow> it took me forever to find that one-liner
20:35:00 <pumpkin> :o
20:35:19 <twb> Suppose I have a string "<[foo|bar]...>".  I want to split it up into substrings that aren/aren't punctuation, i.e. ["<[","foo","|","bar","]...>"].  Is there a prelude function to do this?
20:35:26 <mmorrow> (should have grepped my logs /first/.. sigh)
20:36:31 <Gracenotes> tehgeekmeister: it does create a *lot* of data using constructors
20:36:54 <tehgeekmeister> Gracenotes: oh?  does that slow it down?
20:37:01 <mmorrow> @let utf8len = sum . fmap (length . utf8c)
20:37:02 <lambdabot>  Defined.
20:37:06 <Gracenotes> I know non-native object creation is expensive in other languages... not sure about haskell though
20:37:08 <mmorrow> > utf8len supsub
20:37:09 <lambdabot>   57
20:37:15 <mmorrow> > length supsub
20:37:16 <lambdabot>   20
20:37:46 <tehgeekmeister> there's some way to see how much time is being spent on that via run time options, isn't there?
20:39:53 * tehgeekmeister seems to remember some post dons did about something like this a while back
20:40:16 <scodil> tehgeekmeister: have you done the whole profiling thing?
20:40:27 <tehgeekmeister> scodil: not familiar with that in haskell
20:40:36 <scodil> compile with -prof -auto-all
20:40:41 <scodil> run with +RTS -P
20:40:54 <scodil> it will make a file called myExe.prof
20:41:03 <scodil> that will give you some good leads
20:41:15 <tehgeekmeister> semi-related, how do i revert to a previous version of a file in darcs without losing the current one?
20:41:26 <twb> @hoogle split
20:41:26 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
20:41:26 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
20:41:26 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
20:42:08 <twb> @hoogle (a -> Bool) -> [a] -> [[a]]
20:42:08 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
20:42:08 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
20:42:08 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
20:42:22 <twb> Hrmph
20:42:27 <scodil> doesn't exist, twb
20:45:30 <twb> @hoogle (a -> a -> Bool) -> [a] -> [[a]]
20:45:31 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
20:45:31 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
20:45:31 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
20:45:36 <twb> aha!
20:47:05 <twb> @hoogle isPunctuation
20:47:05 <lambdabot> Data.Char isPunctuation :: Char -> Bool
20:47:18 * gwern is shocked to see that my wishlist item of a faster HTTP library using bytestring seems to've already been answered: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
20:47:24 <gwern> 'A library for client-side HTTP, version 2. Rewrite of existing HTTP package to allow overloaded representation of HTTP request bodies and responses. Provides three such instances: lazy and strict ByteString, along with the good old String. Inspired in part by Jonas Aadahl et al's work on ByteString'ifying HTTP a couple of years ago. Git repository available at http://code.galois.com/HTTPbis.git '
20:47:25 <twb> @hoogle toLower
20:47:25 <lambdabot> Data.Char toLower :: Char -> Char
20:47:48 <gwern> uploaded just 9 days ago too
20:47:51 <tehgeekmeister> scodil: bah, it's complaining about me not having the profiling libraries for HDBC.PostgreSQL
20:48:06 <scodil> tehgeekmeister: how did you install that library?
20:48:08 <gwern> one day we will reach HTTP-9000.0.0
20:48:10 <scodil> cabal?
20:48:23 <tehgeekmeister> scodil: yep
20:48:28 <scodil> do it again with -p
20:48:34 <tehgeekmeister> gwern: and at the next version we'll be over 9000.
20:48:43 * tehgeekmeister hopes someone else got that
20:48:46 <gwern> tehgeekmeister: IMPOSSIBLE!!!!
20:48:47 <scodil> i don't know why thats not the default
20:49:18 <gwern> scodil: because profiling requires all dependencies be profiled, it doubles space requirements, and not everybody ships profiled GHC, for example
20:50:30 <tehgeekmeister> scodil: -p during making setup, or what?
20:50:38 <scodil> yeah, if i recall
20:50:56 <tehgeekmeister> scodil: not recognized
20:51:14 <mmorrow> i think it's not the default because it makes the end-binary slower
20:51:27 <scodil> cabal install -p
20:51:40 <mmorrow> but it's totally a pain when you try to prof something and all these libs need rebuilding or no prof
20:51:42 <tehgeekmeister> oh wow, that's not what i'm doing at all
20:51:50 <gwern> my understanding from the cabal bug report was the space hit and the unreliability
20:51:54 <pumpkin> mmorrow: it builds two libs for each one though, one with profiling and one without
20:52:01 <tehgeekmeister> scodil: i'm doing ghc --make Setup.(l)hs
20:52:03 <pumpkin> so there's nothing stopping it from building both by default?
20:52:09 <mmorrow> pumpkin: oh sweet.
20:52:16 <pumpkin> there's .o and .p_o
20:52:18 <mmorrow> pumpkin: (cabal you mean?)
20:52:21 <pumpkin> yup
20:52:25 <mmorrow> hmm
20:52:38 <mmorrow> i'm thinking of -auto-all, is that the same thing?
20:52:50 <scodil> tehgeekmeister: for the PostgreSQL library? I think you should do runhaskell Setup.hs
20:52:53 <gwern> pumpkin: well presumably it needs some sort of intelligent selection - 'is this libary/bianry buildable with profiling?' which I think is currently beyond cabal's ability
20:53:01 <pumpkin> dunno, I just build with -p or whatever the equivalent flag is in the config
20:53:17 <tehgeekmeister> scodil: really?  huh, worked fine this way last time, but okay
20:53:29 <tehgeekmeister> in any case, it's complaining about base not having profiling
20:53:32 <tehgeekmeister> so i have to rebuild that
20:53:48 <mmorrow> because i heard that -auto-all is bad to put in .cabal files as ghc-options:, but i'm not sure what the relation of that is to -p or if this is even still the case
20:54:41 <mmorrow> heh, if you rebuild base, you'll have to rebuild _everything_
20:54:41 <gwern> ghc-options: is mandatory, I think
20:54:46 <gwern> you want ghc-prof-options:
20:55:01 <tehgeekmeister> mmorrow: but i didn't build it to start with!  =/  i hate building ghc
20:55:12 <Gracenotes> how many repositories does cabal-install download from?
20:55:14 <mmorrow> tehgeekmeister: by everything i mean all your libs
20:55:18 <pumpkin> just one?
20:55:28 <Gracenotes> mm, thought as much
20:55:29 <tehgeekmeister> mmorrow: oh; i can rebuild all my libs.  but ghc?  that takes ages.
20:55:55 <tehgeekmeister> mmorrow: i can't seem to find the package for base in hackage, is it somewhere else?
20:56:11 <mmorrow> darcs.haskell.org/libraries/base
20:56:27 <Gracenotes> ah
20:56:34 <mmorrow> if you build ghc from src, it'll be in ghc/libraries/base
20:57:00 <mmorrow> (and you'll probably have to modify the .cabal i guess since it didn't build with what you need to begin with)
20:57:08 <twb> @hoogle exclusive or
20:57:08 <lambdabot> No results found
20:57:25 <twb> @hoogle Bool -> Bool -> Bool
20:57:26 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
20:57:26 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
20:57:26 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
20:58:07 <twb> I want hoogle.el.  Using w3m-el is too slow.
20:59:29 <gwern> twb: you aren't using haskell-mode?
20:59:36 <twb> gwern: I am.
21:03:40 <twb> let xand x y = (x && y) || (not y && not x); cmp x y = xand (isPunctuation x) (isPunctuation y) in groupBy cmp "[FILE or DIRECTORY]..."
21:03:45 <twb> > let xand x y = (x && y) || (not y && not x); cmp x y = xand (isPunctuation x) (isPunctuation y) in groupBy cmp "[FILE or DIRECTORY]..."
21:03:47 <lambdabot>   ["[","FILE or DIRECTORY","]..."]
21:03:54 <gwern> twb: so then doesn't haskell-mode provide a hoogle function?
21:03:55 <twb> Yay me!
21:04:15 <twb> gwern: AFAIK, haskell-mode does not provide a hoogle function.
21:04:35 <gwern> strange. I could've sworn I submitted one and was told it was already present
21:05:00 <gwern> I see M-x haskell-hoogle
21:05:14 <twb> Oh, it has haskell- in front.
21:05:16 <gwern> and it's not defined by my .emacs
21:05:29 <gwern> twb: well, what would you expect it to be prefixed by?
21:05:38 <twb> Nothing.
21:05:49 <chrisdone> :t liftM2 (&&)
21:05:51 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
21:06:22 <gwern> of course it'd be prefixed if it was supplied by haskell-mode. that's the convention, major modes prefix their functions
21:07:34 <gwern> hm. does anyone know a nice 10-30 megabyte file I can use to benchmark downloading?
21:07:36 <chrisdone> > (&&) `on` isPunctuation '[' ']'
21:07:37 <lambdabot>   Couldn't match expected type `Char -> a -> Bool'
21:07:41 <twb> From a user perspective, I didn't/don't conceive of hoogle as being "part of" the major mode for editing Haskell files.
21:07:45 <chrisdone> > (&&) `on` isPunctuation $ '[' ']'
21:07:47 <lambdabot>       precedence parsing error
21:07:47 <lambdabot>          cannot mix `on' [infixl 0] and `($)' ...
21:08:03 <chrisdone> > on (&&) isPunctuation '[' ']'
21:08:05 <lambdabot>   True
21:08:09 <chrisdone> > on (&&) isPunctuation '[' 'a'
21:08:11 <lambdabot>   False
21:08:11 <tehgeekmeister> is communicating every single chunk thru an mvar significant overhead?
21:08:31 <tehgeekmeister> i don't NEED concurrency.  it was just kinda convenient to start with.
21:08:42 <gwern> I could use the ghc tarballs, I guess. I doubt there's much traffic right now I'd interfere with
21:08:44 <chrisdone> twb: `on' is cool
21:09:29 <twb> I see "Typical usage: Data.List.sortBy (compare `on` fst)." and am thinking "Who's on First?"
21:10:02 <gwern> (who `on` fst)?
21:11:00 <twb> The other problem I have with hoogle is that haddock output isn't very w3m-friendly -- there's lots of missing whitespace and such.
21:11:25 <twb> And all the headings are just normal lines as far as HTML is concerned -- they're only turned into headings by CSS.
21:11:32 <gwern> hardly hoogle's fault, I'd say
21:11:36 <aconbere> weird side question... anyone here know ocaml? and can explain the +| or *| operators?
21:11:39 <twb> gwern: granted; it's haddocks.
21:11:44 <twb> *haddock's
21:11:49 <twb> gwern: but it's still annoying.
21:12:08 <twb> What I'd *really* like is haddock to emit info format :-)
21:12:23 <gwern> aconbere: iirc, doesn't ocaml define + various ways for different kind of numbers? +. for two floating numbers, + for two ints, and so on
21:13:03 <gwern> hm. interesting. HTTP-4000.0.0 downloads faster than wget?
21:13:23 <twb> Amusingly, "(*) `on` id = (*) (if (*) ∉ {⊥, const ⊥})" looks better in xterm than midori because FreeMath has shitty hinting.
21:13:35 <tehgeekmeister> what's the darcs command to get the most recent revision in a repository?
21:13:42 <gwern> pull?
21:13:45 <twb> tehgeekmeister: that's the default behaviour.
21:14:46 <tehgeekmeister> er, not what i meant.  i'm trying to grab base from the url i was given up there ^^ without having to resort to wget -r -np...
21:14:48 <aconbere> gwern: ahh... then it probably is the conncatination operator
21:15:01 <tehgeekmeister> since there doesn't seem to be a tarball of it
21:15:07 <gwern> tehgeekmeister: darcs get?
21:15:25 <tehgeekmeister> that's doing it!
21:15:26 <aconbere> or maybe not
21:15:26 <tehgeekmeister> thanks.
21:15:26 <aconbere> damn
21:15:28 <twb> chrisdone: that on example doesn't seem to capture "not xorg", because it doesn't succeed when both x and y are NOT punctuation.
21:15:35 <twb> s/xorg/xor/ ^_^;;
21:16:25 <twb> get = clone = checkout
21:16:26 <gwern> now I'm just confused. are we discussing logic or GUIs?
21:16:40 <twb> gwern: my fingers perform predicitive typing
21:17:01 <gwern> needs a larger database. let's throw a bayesian network at your fingers
21:17:06 <twb> gwern: it copes badly when typing a substring or a word they are "used to"; xor instead of xorg.
21:17:08 <aconbere> gwern: my problem is I don't really want to know ocaml, so much as translate some code from ocaml to haskell :P
21:17:23 <twb> gwern: they know about xor, but it's weighted by frequency of use.
21:17:39 <twb> OK, onto the next problem!
21:17:54 <gwern> pfft, it shouldn't be dumb frequency, but smarter markov chains or something
21:17:56 <twb> I want to replace " or " in a string with "|".
21:18:10 <twb> gwern: I don't fully understand how it works.
21:24:39 <gwern> @ask dcoutts_ any chance of cabal-install moving to http-4000? that should speed cabal fetch up noticeably
21:24:40 <lambdabot> Consider it noted.
21:37:33 <tehgeekmeister> it's safe to assume my code isn't cpu bound if it's consistently using less than the available cpu time, no?
21:38:08 <scodil> sounds reasonable
21:39:37 <tehgeekmeister> hum.  then i really don't know why the perl should be going faster than my code.
21:39:59 <tehgeekmeister> it uses the same sql, basically:  i guess hexpat is the slow point?
21:45:45 <mbz> does haskell use C-- for code generation?
21:46:05 <twb> mbz: I believe GHC generates ordinary C.
21:51:04 <twb> Is there a better way to write this?
21:51:06 <twb> (\x -> "\"" ++ x ++ "\"")
21:52:22 <Mr_Awesome> ("\"" ++) . (++ "\"")
21:52:30 <bd_> twb: if you want it to be escaped as well, you could just use show
21:52:35 <bd_> > show "a\"b"
21:52:37 <lambdabot>   "\"a\\\"b\""
21:53:13 <twb> bd_: that will probably DTRT for my case
22:01:25 <dancor> @pl \ x -> "\"" ++ x ++ "\""
22:01:26 <lambdabot> ('"' :) . (++ "\"")
22:15:21 <jowens> type for read-show question.
22:15:27 <jowens> main = print(sum(map (\c -> read [c]::Int) show(2^1000)))
22:15:27 <jowens> main = print(sum(map read show(2^1000)))
22:15:30 <jowens> neither one of these works.
22:15:35 <jowens>     Couldn't match expected type `[String]'
22:15:36 <jowens>            against inferred type `a -> String'
22:15:46 <jowens> what am i doing wrong?
22:16:16 <pumpkin> I think you're looking for digitToInt
22:16:27 <pumpkin> you doing project euler? :P
22:16:32 <pumpkin> > digitToInt '5'
22:16:32 <jowens> yes, yes i am.
22:16:33 <lambdabot>   5
22:16:40 <jowens> ok, i can use that. no prob.
22:16:44 <jowens> but what am i doing wrong?
22:16:49 <pumpkin> let's see
22:16:58 <conal> jowens: missing parens around show (2 ^ 1000)
22:17:17 <conal> jowens: you're mapping read over show
22:17:31 <jowens> well, now i feel stupid.
22:17:51 <jowens> thanks to both of you for making me smarter.
22:18:08 <conal> jowens: habits take a while to change
22:18:24 <jowens> yes, yes they do.
22:20:20 <jowens> thanks guys!
22:35:03 <twb> Given a list that represents a set, how do I remove duplicate entries?  The list is not sorted.
22:35:39 <jeffwheeler> twb: I assume nub doesn't work, right?
22:35:48 <twb> I don't know about nub.
22:35:58 <jeffwheeler> > nub [1, 1, 2, 5, 1]
22:36:00 <lambdabot>   [1,2,5]
22:36:09 <twb> nub sounds like what I want.
22:36:17 <jeffwheeler> :)
22:36:20 <twb> (I wouldn't have guess that name)
22:36:34 <jeffwheeler> I have no idea why it has that name . . . it's silly. :P
22:41:32 <BMeph> jeffwheeler: What's so silly about 'nub'? :)
22:41:53 <jeffwheeler> BMeph: well, silly because it's random, given that I have no idea for what it's named.
22:42:37 <mbz> @src nub
22:42:37 <lambdabot> nub = nubBy (==)
22:42:53 <Chile`> it means something along the lines of 'focal point' or 'center', no?
22:42:57 <Chile`> still a bizarre choice
22:43:05 <jeffwheeler> mbz: scroll down below the table, http://haskell.cs.yale.edu/haskell-report/newlib/List.html
22:43:05 <Chile`> is unique taken for something else?
22:43:19 <qwr> nub is nice name ;)
22:44:20 <jeffwheeler> @hoogle unique
22:44:20 <lambdabot> module Data.Unique
22:44:20 <lambdabot> Data.Unique data Unique
22:44:20 <lambdabot> Data.Unique hashUnique :: Unique -> Int
22:44:27 <jeffwheeler> Nope, quite safe.
22:45:41 <jeffwheeler> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Anub : "The name nub means `essence'."
22:46:55 <Chile`> why on earth would you use nub & not unique?
22:47:39 <BMeph> jeffwheeler: Exactly - when you whittle away the extra stuff, what you have left is...the nub! :)
22:48:10 <jeffwheeler> That is ridiculous. :P
22:48:23 <BMeph> Also, because nub is only three letters, and unique is six? :)
22:48:55 <jeffwheeler> BMeph: that's a better reason. And for that reason, I'd also like to create 'hd' for head' and 'tl' for 'tail'. :)
22:49:07 <litb> there is an emacs paste library for hpaste
22:49:11 <litb> is there one for codepad too?
22:49:12 <Chile`> unix uses uniq
22:49:16 <Chile`> now its down to 4 :p
22:49:41 <vininim> typing less shouldn't be that high in the priority list
22:50:03 <twb> Argh, fuck.
22:50:05 <qwr> don't you think, that nub is a cute name?
22:50:12 <jeffwheeler> vininim: this is Haskell. When was the last time you saw somebody use a variable longer than three letters? ;)
22:50:16 <twb> DarcsOption does not have an Eq instance, and it's nontrivial to derive
22:50:52 <vininim> jeffwheeler: that's because prelude hasn't eaten up them all =P
22:51:08 <scook0> variables are for the weak
22:51:13 <scook0> real men write point-free code
22:52:19 <jeffwheeler> Real men have no need for Haskell. They do the calculations in their head.
22:52:25 <Olathe> Point-free code ?! Bah. Real men write code consisting only of calls to nand.
22:53:13 <tehgeekmeister> if you use getChanContents on an empty chan, do you get []?
22:53:27 <shapr> Real men use a butterfly.
22:53:52 * jeffwheeler no longer uses Emacs.
22:54:11 <vininim> heathen!
22:54:50 <tehgeekmeister> bah, control.concurrent.chan needs better documentation
22:55:41 <Chile`> ugh, emacs crowd?
22:55:48 <litb> hmm
22:56:06 <litb> pointer means baller anyway
22:56:58 <litb> so point-free means ball-free. i therefor prefer non point-free code :)
22:57:34 <litb> (don't worry if you don't get that. hehe)
22:58:11 <tehgeekmeister> anyone know if when you read an element from getChanContents it's removed from the chan?
22:58:29 <twb> point-free = pointless!
22:58:37 <twb> Hyuk hyuk hyuk
22:59:43 <litb> twb: http://stackoverflow.com/questions/374945/what-is-the-origin-of-the-term-baller-which-means-pointer -.-
23:05:02 <Cale> tehgeekmeister: If you call getChanContents, I'm pretty sure you should never read from the Chan in any other way, and yeah, I think it does remove them.
23:05:14 <tehgeekmeister> Cale: okay, thanks.
23:11:52 <tehgeekmeister> if i get a warning about pattern matches overlapping, how serious is that?
23:14:12 <pumpkin> tehgeekmeister: depends how much you want each of your cases to run :P
23:14:18 <pumpkin> it's a good sign that you might want to look carefully
23:14:40 <tehgeekmeister> pumpkin: i think what it is is that i was matching xs in one branch and then [] in the next
23:14:41 <BMeph> tehgeekmeister: That's an excellent question. If you have overlapping patterns that give the same answer, is there a way to get the compiler to see that, and shut up about the overlap? :)
23:14:56 <tehgeekmeister> which, i think because of the order, is safe
23:15:00 <tehgeekmeister> but probably could be done better
23:15:06 <pumpkin> tehgeekmeister: well, xs will always match
23:15:09 <pumpkin> and [] won't
23:15:15 <pumpkin> or is that x:xs?
23:15:19 <tehgeekmeister> no, it was just xs
23:15:27 <pumpkin> then your [] won't match
23:15:32 <pumpkin> ev4r
23:15:33 <pumpkin> :P
23:15:39 <tehgeekmeister> oh, fail.
23:15:48 <tehgeekmeister> maybe that's why my program just died?
23:16:02 <pumpkin> if the [] was a base case
23:16:13 <pumpkin> and is the only place some recursive function terminated
23:16:15 <pumpkin> probably :P
23:16:16 <BMeph> pumpkin: I have a function that does similarly: f [] _ = []; f xs [] = xs; ...
23:16:32 <pumpkin> BMeph: in that order it's fine isn't it?
23:16:47 * pumpkin defers to BMeph
23:17:03 <BMeph> pumpkin: It's fine, but it's still a pattern overlap - f [] [] matches them both.
23:17:11 <pumpkin> yeah
23:17:31 <pumpkin> but in tehgeekmeister's case, it's actually a good warning
23:18:14 <pumpkin> tehgeekmeister: so the basic answer is, flip your patterns, or make the first one more restrictive :P
23:18:21 <BMeph> pumpkin: Is it? I mean, if your overlapping patterns give the same answer, does it matter that they overlap? :)
23:19:02 <pumpkin> BMeph: well, in his case it caused him to look at it more carefully and see that one of the patterns would never match, so I'd say it was helpful
23:19:16 <pumpkin> but given that he'd get the same warning if he flipped the cases, probably not in general
23:19:41 <pumpkin> you could do xs@(_:_) or something but it's ugly
23:33:47 <wli> I got the partition garbage working.
23:36:03 <pumpkin> wli: ?
23:36:27 <wli> wtf. hpaste.org is telling me I can't have URL's in my code for spam reasons, but I don't have a URL in my code.
23:36:37 <pumpkin> lol
23:36:43 <pumpkin> their URL detector sucks I guess
23:36:50 <pumpkin> try pastie.org ?
23:36:56 <wli> http://hpaste.org/13227
23:37:00 <wli> Never mind.
23:37:58 <pumpkin> that is nice :)
23:38:23 <wli> It seems to line up with the OEIS partition function with list length and its results also check against brute-force methods.
23:41:24 <litb> codepad.org is also nice wli
23:44:49 <wli> It was me being dumb and putting my initials in both the author and title fields.
23:48:40 <wli> Slightly prettier output upcoming.
23:51:45 <wli> i.e. generated sorted (compare output to output with Data.List.sort applied).
23:53:49 <wli> Have I mentioned that pattern guards are bloody brilliant?
23:54:34 <SubStack> yes, just now
23:55:04 <wli> http://hpaste.org/13227#a1
23:56:01 <scook0> wli: glorious
23:56:34 <scook0> I've been doing a lot of scala recently, and I'm really missing the ability to create additional bindings in pattern matches
23:57:43 <wli> Haskell's ability?
23:58:24 <mbz> where is Monad ((->) a) defined?
23:58:32 <mbz> Control.Applicative?
23:58:34 <wli> Control.Monad.Reader
23:58:50 <mbz> thanks.
23:58:54 <int-e> mbz: Control.Monad.Reader or Control.Monad.Instances
23:59:02 <ski_>   [replicate (fromIntegral r) m ++ foo | r <- [q, q - 1 .. 0] , foo <- parts' (n - m * r) (fromIntegral $ k - r) (m + 1)]
23:59:09 <mbz> thanks again
23:59:16 <ski_> wli : would that be clearer or not ?
23:59:43 <pumpkin> what'sa good way to make an infinite list of fibonacci numbers without needing to keep them all around?
23:59:51 <solrize_> @pl \Foo a -> a
23:59:51 <lambdabot> const id
23:59:57 <wli> ski: Possibly.
