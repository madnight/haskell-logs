00:00:06 <olsner> if I have a module with a data type and two data constructors, can I choose to only export a subset of the constructors?
00:01:11 <olsner> i.e. I have data Ref = Null | SecretInternalData and I'd like to only expose the Null one so that I can pattern match on nulls but treat other kinds of pointers as opaque data
00:02:06 <ddarius> Yes, but it tends not to work out as nicely as you'd think.
00:02:40 <olsner> oh, how so?
00:04:01 <ddarius> Well, it might work out for you.
00:06:16 <quicksilver> olsner: Ref(Null)
00:07:54 <olsner> quicksilver: oh, special syntax! didn't know about that
00:08:27 <quicksilver> Ref(..) means Ref and all constructors. Ref() means Ref and no constructors. You can work out the rest ;
00:09:42 <olsner> hmm, and how about type class instances, do I always get all of them exported?
00:10:13 <quicksilver> olsner: type class instances are global.
00:10:21 <quicksilver> to pretend otherwise is to risk insanity.
00:16:02 <olsner> hmm, you can't have more than one instance of MonadReader for one monad can you? I'd like to write one module of this such that it works with "any reader-monad that can be asked to produce an X", but my other monad already has a reader instance for something that contains an X
00:17:09 <olsner> and thinking about it, I think I'll just make another type class for that
00:18:17 <ahunter> Erm, how does one denote an instance declaration in an export list?  Or is that always exported (for a global class, like Num here.)
00:18:42 <olsner> 9 minutes from when I asked the exact same question :)
00:18:49 <ahunter> hey, I jsut got here :P
00:18:53 <olsner> yes, all instances are always exported
00:19:13 <olsner> "to pretend otherwise is to risk insanity."
00:20:09 <Saizan__> instances are global is a stronger claim than instances are always exported
00:21:37 <dmwit> You can specify which member functions are exported, though.
00:22:15 <dmwit> If you hide some (or all!) of the member functions, you can prevent people from writing usable instances.
00:22:21 <dmwit> If that's the kind of thing you get off on.
00:23:40 <ahunter> As a related note, why aren't things like (^) /part of Num/?  I'm writing a DSL that has a Num instance for some expressions that basically maps to ASTs, and I genuinely need to make AST terms for powers...it'd be nice to overload (^)
00:23:53 <ivanm> can someone _please_ @flush lambdabot (or whatever the command to save state is)? I've just received the same @message for the fourth time! :@
00:24:09 <ivanm> ahunter: because maybe not all numbers have powers?
00:24:22 <ahunter> @type (^)
00:24:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:24:42 <ahunter> ivanm: as you can see, you can raise a^ for any Num a.  I just want to do it differently for Expr in the instance Num Expr
00:25:07 <ivanm> ahhh, duh
00:25:08 <mjrosenb> i'd gess because asymptotically
00:25:28 <ahunter> ?
00:25:32 <mjrosenb> the standard implementation of ^ in therms of + * is the fastest you can muster
00:25:41 <mjrosenb> *terms
00:25:44 <ivanm> ahunter: differently in what way? it's defined in Integral because there's no such thing as Integral numbers when defining Num instances (plus the voodoo magic is done with the integer numbers)
00:25:48 <ahunter> mjrosenb: my implementation is constant time :P
00:25:51 <mjrosenb> heat has nothing to do with this
00:26:00 <ivanm> mjrosenb: lol
00:26:11 <ivanm> ahunter: what are you taking the power of that it's constant time? :o
00:26:12 <mjrosenb> ahunter: it'll still be so if you never need to look at the AST
00:26:19 <idnar> @type (**)
00:26:20 <lambdabot> forall a. (Floating a) => a -> a -> a
00:26:27 <pumpkin> @type (^^)
00:26:28 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
00:26:37 <idnar> hmm
00:26:38 <ahunter> ivanm: (^) is not a member of Integral either.
00:26:41 <mjrosenb> ivanm: well if it's just joining two AST's then it can't take long
00:26:51 <ahunter> ivanm: and I don't really care about Integral...my implementation would li
00:26:57 <ivanm> ahunter: it's defined using Integral instances, isn't it?
00:27:01 <mjrosenb> ahunter: you should be able to import prelude without ^ and define it yourself
00:27:01 <ivanm> mjrosenb: true
00:27:01 <solrize_> @hoogle (a->b)->b
00:27:02 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:27:02 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
00:27:02 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
00:27:17 <idnar> @type fix
00:27:17 <mjrosenb> define it as a constructor even
00:27:18 <lambdabot> forall a. (a -> a) -> a
00:27:19 <dmwit> (^) is not a member of a class.
00:27:31 <dmwit> If you want an exponentiation function, write it with a different name.
00:27:35 <dmwit> I don't see what all the fuss is about.
00:27:52 <dmwit> Do you actually have some function that you're going to be calling with two different instances of Num, one of which is your AST?
00:27:52 <ahunter> dmwit: two things: first, the best available name I can think of is (^^^), which is butt-ugly
00:28:00 <dmwit> ...and which also uses (^)?
00:28:09 <dmwit> ahunter: How about a prefix name?
00:28:18 <dmwit> pow is untaken.
00:28:31 <dmwit> `tothe` is also available.
00:28:42 <dmwit> > let tothe = (^) in 3 `tothe` 4 -- hehe
00:28:44 <lambdabot>   81
00:28:56 <ahunter> dmwit: that's one option, but still nonideal: the other problem is that this is a DSL for writing numerical expressions (...if odd, special oneS) that get fiddled with.
00:29:13 <mjrosenb> tothe, rhymes with roth
00:29:16 <ahunter> dmwit: hence, I want to use the standard Haskell-ish notations for standard things: a + b, x * y, n^c
00:29:22 <idnar> > h `tothe` izzo
00:29:23 <lambdabot>   Not in scope: `tothe'Not in scope: `izzo'
00:29:26 <dmwit> ahunter: If you really need this power, it is available.
00:29:36 <dmwit> ahunter: {-# LANGUAGE NoImplicitPrelude #-}
00:29:37 <ahunter> dmwit: it is?  How?
00:29:54 <Saizan> you just need to import Prelude hiding (^)
00:29:58 <mjrosenb> import prelude hiding (^)
00:30:04 <Saizan> and define your own (^)
00:30:05 <dmwit> Yep.
00:30:07 <mjrosenb> efb
00:30:19 * mjrosenb said this a while ago
00:30:30 <ahunter> dmwit: mmmmm, hadn't considered that!  thanks.  I still think it would be nice if I could overload without breaking other uses of (^), but that'll be helpful :P
00:30:36 <ivanm> mjrosenb: I bear witness! ;-)
00:30:36 <pumpkin> what's that haskell charts lib?
00:30:46 <ivanm> pumpkin: charts? it draws 2D graphs
00:30:59 <pumpkin> I'm afraid of calling them graphs to avoid confusion with fgl :P
00:31:01 <ivanm> some of the best looking graphs/plots/whatever you call them I've seen, tbh
00:31:05 <mjrosenb> ahunter: you can declare a new class, give all num's an implementation of it
00:31:10 <ivanm> pumpkin: yeah, I realised that as soon as I said it :s
00:31:32 <pumpkin> :)
00:31:45 <Asztal> what about using Knuth's up arrow? :)
00:31:47 <pumpkin> chart on hackage?
00:32:13 <Saizan> ?hackage charts
00:32:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/charts
00:32:43 <mjrosenb> Asztal: good luck waiting for anything useful to finish
00:32:45 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Chart
00:32:55 <mjrosenb> not as bad as conway's chains
00:33:14 <mjrosenb> 2 -> 2 -> 2 -> 2 -> 2
00:33:18 <mjrosenb> * shivers *
00:34:07 <mjrosenb> so does anyone know of any recent version of ghc working on ppc64-linux?
00:37:19 <osfameron> are there good resources for "using haskell in a startup"?
00:37:43 <osfameron> I'm guessing some of the players in http://www.haskell.org/haskellwiki/Haskell_in_industry - ah yes, anygma and gamr7
00:47:55 <mib_vusyxzh4> hello everyone
00:48:11 <mib_vusyxzh4> hallo alle
00:48:48 <mib_vusyxzh4> kann jemand bitte erklären mir, was der Unterschied zwischen Deutsch und Niederländisch ist?
00:50:26 <dmwit> -> #xmonad.de
00:50:28 <dmwit> uh
00:50:34 <dmwit> -> #haskell.de of course
00:50:42 * earthy looks at mib_vusyxzh4 cross-eyed
00:50:49 <pumpkin> (gone)
00:50:55 <dmwit> oy
00:51:02 <dmwit> He didn't stick around very long.
00:51:05 <pumpkin> nope :)
00:51:17 <earthy> thank goodness. :)
00:51:22 <dmwit> There's not a whole heck of a lot of people in #haskell.de anyway.
00:51:28 <pumpkin> those damn mibbiters don't have much of an incentive to stay around
00:51:33 <pumpkin> :)
00:51:42 <dmwit> *mibbit mibbit*
00:54:14 <Korollary> "Could somebody please clarify what the difference between German and Dutch is?", in German, wtf?
00:54:40 <pumpkin> lol
00:55:07 <earthy> indeed
00:55:39 <solrize_> what's this mib stuff?  i've seen several
00:55:46 <pumpkin> it's a web irc client
00:55:56 <pumpkin> gives you a randomized nick
00:56:02 <pumpkin> and most people are too lazy to change it
00:57:35 <pumpkin> omg
00:57:44 <mib_pumpkin> zomg
00:57:47 <idnar> o hi
00:58:02 <mib_pumpkin> o hai, i iz in ur braosa, chattin ur ircz
00:59:10 <dmwit_> mib_pumpkin: Here, let me show you a neat trick.  Try taking my nick...
00:59:19 <pumpkin> lol
00:59:26 <pumpkin> you mean /ns ghost ? :P
00:59:30 <dmwit_> ;-)
00:59:35 <dmwit> zomg
00:59:42 <dmwit_> Bam! Headshot.
00:59:49 <pumpkin> I waz dmwit for a few seconds!
00:59:51 <pumpkin> it was awesome
00:59:55 <pumpkin> I knew all about haskell n stuff
01:00:01 <dmwit> hahaha
01:00:11 <idnar> it was an accident, right; I tripped, slipped on the floor, and accidentally collided with his nickname
01:00:27 <dmwit> <3 #haskell
01:00:49 <pumpkin> bah, I hate macports
01:00:55 <pumpkin> but I hate it less than I hate fink
01:01:13 * earthy hates both with a passion and therefore doesn't use either
01:01:21 <dmwit> yaourt is nice
01:01:25 <pumpkin> you compile stuff by hand?
01:01:30 <earthy> pumpkin: exactly.
01:01:37 <osfameron> instruction by instruction?
01:01:43 <pumpkin> ugh, but what if it has a bajillion dependencies?
01:01:45 <pumpkin> (and instructions)
01:01:57 <earthy> pumpkin: then I'm fucked. and I start looking for an alternative
01:02:09 <pumpkin> dmwit: not on mac os :P
01:02:11 <earthy> (which, happily, often exists)
01:02:27 <pumpkin> the damn graphs package for haskell depends on gtk
01:02:35 <pumpkin> oh maybe there's a .pkg for gtk
01:03:03 <pumpkin> oh there is
01:06:33 <pumpkin> hmm
01:07:11 <pumpkin> how does chart depend on gtk and cairo when they aren't packages
01:07:23 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Chart
01:07:33 <osfameron> has anyone got links to the 2004 ICFP talk from Galois?  I tried the links from the LtU article but they are dead
01:07:37 <Saizan> pumpkin: they are packages, but they aren't on hackage
01:07:39 <pumpkin> oh
01:07:45 <Saizan> ?google gtk2hs download
01:07:47 <lambdabot> http://www.haskell.org/gtk2hs/download/
01:07:47 <lambdabot> Title: Gtk2Hs » Download
01:07:55 <pumpkin> why not on hackage?
01:08:02 <osfameron> I mean, for example: http://www.galois.com/cufp/icfp2004.mp3 <-- broken link
01:08:16 <Saizan> the build system is still too complex for cabal
01:08:23 <pumpkin> ah
01:09:00 <pumpkin> bah, this is a real pain
01:13:26 <pumpkin> bah, not in the mood to struggle with all this gtk crap
01:14:55 <pumpkin> and isn't it wonderful when numbers (supposedly an excel replacement) tells me it can't open my csv file cause it's too large
01:15:39 <whoppix> how large is it?
01:15:45 <pumpkin> 32 megs :P
01:15:52 <pumpkin> granted, I loaded the wrong csv file
01:15:58 <pumpkin> I meant to open the 12 kb one
01:15:58 <whoppix> well, that should fit into you ram.
01:16:14 <pumpkin> yup, it should, but apple likes to impose arbitrary restrictions on me
01:16:20 <pumpkin> (and I have 4 gigs of ram)
01:16:34 <Saizan> any reccomended sources on CSP (Constraint Satisfaction Problem)? especially the Soft variant
01:16:38 <whoppix> s/you/your/
01:16:58 <whoppix> pumpkin, perhaps import it to some other format that numbers can read
01:17:05 <whoppix> CSV is easy to convert
01:17:10 <whoppix> to whatever format you want
01:17:23 <pumpkin> I'll survive, it's not as if numbers will even graph this 12kb csv for me
01:18:55 <pumpkin> bah, I hate dumb software :P
01:39:07 <hml> is real world haskell available asa pdf instead of a bunch of htmls?
01:39:38 <dmwit> It's available in dead-tree form, but I don't know of a PDF form.
01:40:23 <quicksilver> hml: someone hacked together a script to pdf it.
01:40:28 <quicksilver> I think it was twb.
01:40:43 <gio123> is there deference between this 2 definitions:
01:40:46 <gio123> d_R(S)={w | there exist x in [[R]] such that xw \in [[S]] /\ for all x in [[R]] there exist u such that xu \in [[S]}
01:40:46 <gio123> d_R(S)={w | for all x in R such that xw \in S}
01:42:41 <quicksilver> gio123: not really a haskell question.
01:42:53 <gio123> right
01:42:56 <xsdnyd> hi
01:43:39 <blackh> hi xsdnyd
01:43:57 <xsdnyd> i have a function that requires an IO () but i have an function "func -> IO Bool". can i somehow omit the Bool? like dropParam func. or something like that?
01:44:59 <quicksilver> xsdnyd: do { foo ; return () }
01:45:05 <quicksilver> xsdnyd: or simply foo >> return ()
01:45:18 <xsdnyd> quicksilver, thanks will try :)
01:45:42 <redditbot> Exploring Haskell concatMap
01:45:47 <idnar> @type (?f :: a -> IO Bool) >> return ()
01:45:48 <lambdabot>     Could not deduce (?f::a -> IO Bool) from the context ()
01:45:48 <lambdabot>       arising from a use of implicit parameter `?f'
01:45:48 <lambdabot>                    at <interactive>:1:1-2
01:46:07 * quicksilver nods
01:46:10 <idnar> @type (?f :: a -> IO Bool) ?x >> return ()
01:46:11 <lambdabot>     Could not deduce (?f::a -> IO Bool) from the context ()
01:46:11 <lambdabot>       arising from a use of implicit parameter `?f'
01:46:11 <lambdabot>                    at <interactive>:1:1-2
01:46:11 <quicksilver> that's not going to work, no
01:46:16 <quicksilver> you do need to pas the parameter
01:46:21 <quicksilver> but I was assuming xsdnyd understood that ;)
01:46:25 <idnar> heh
01:46:34 <idnar> @type (?f :: IO Bool) >> return ()
01:46:35 <lambdabot> (?f::IO Bool) => IO ()
01:47:08 <xsdnyd> Couldn't match expected type `IO ()' against inferred type `()'
01:47:09 <xsdnyd> :(
01:47:16 <dolio> gio123: They look pretty different.
01:47:40 <xsdnyd> seems like it misses the IO...
01:48:01 <blackh> > let dropParam f = f >> return ()
01:48:02 <lambdabot>   <no location info>: parse error on input `;'
01:48:51 <dmwit> xsdnyd: Did you remember the "return"?
01:49:01 <dmwit> :t (>> return ())
01:49:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
01:49:20 <xsdnyd> yes. changed "EL.readHistory" to "EL.readHistory >> return ()"
01:49:49 <dmwit> Does readHistory take any parameters?  If so, you'll need to supply them.
01:49:58 <dmwit> If not, then paste some code and the exact error you get.
01:50:04 <dmwit> ?hpaste
01:50:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:51:23 <xsdnyd> dmwit, indeed, readHistory takes a FilePath. thanks. i think i can now figure it out myself :)
02:03:00 <alar> who is the maintainer for standard libraries
02:03:13 <alar> haddock fo Data.IntMap lies
02:03:23 <pumpkin> how so?
02:03:26 <quicksilver> if in doubt, it's libraries@haskell.org
02:03:29 <quicksilver> that's the default maintainer
02:03:36 <bmwit> ?remember alar haddock for Data.IntMap lies
02:03:36 <lambdabot> Done.
02:03:45 <alar> example for Data.IntMap.updateMin is wrong
02:03:56 <pumpkin> bmwit: you waiting for more people to fall into your ghost trap?
02:04:04 <alar> it seems the example is blindly borrowed from Data.Map
02:04:17 <bmwit> pumpkin: -blah is a b-fest right now
02:04:23 <pumpkin> ah :)
02:04:25 <alar> what is ghost trap?
02:04:45 <pumpkin> I'd change to b too, but then I'd sound dangerously like an obscure sexual practice
02:04:49 <bmwit> pumpkin: boegel, bcoppens, bourbaki, and Badger were all discussing... something or other
02:04:58 <pumpkin> ah :)
02:05:29 <bmwit> alar: Well... try "/nick dmwit" and you'll see. ;-)
02:05:48 <alar> ./nick dmwit
02:05:57 <bmwit> Oh, you shouldn't have...
02:06:06 <pumpkin> lol
02:06:16 <bmwit> ?tell alar I'm so sorry.
02:06:17 <lambdabot> Consider it noted.
02:06:53 <bmwit> It had the word "trap" in it...
02:06:57 * bmwit feels he can't be blamed
02:07:56 <bmwit> Actually, I feel kind of bad now.  I hope alar comes back.
02:08:05 <pumpkin> aw
02:08:25 <pumpkin> I'm sure he'll be okay
02:10:10 <idnar> @type xor
02:10:11 <lambdabot> forall a. (Bits a) => a -> a -> a
02:10:21 <idnar> @type (&)
02:10:22 <lambdabot> Not in scope: `&'
02:10:30 <idnar> @instances Bits
02:10:31 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
02:11:20 <Beelsebob> idnar: are you looking for xor on Bools?
02:13:02 <zax> xor True a = not a; xor False a = a
02:13:04 <zax> works great
02:13:17 <Beelsebob> or just (==)
02:13:32 <idnar> no, I want the bitwise operation
02:14:19 <idnar> > 5 `xor` 10
02:14:20 <lambdabot>   Add a type signature
02:14:28 <idnar> > 5 `xor` 10 :: Integer
02:14:29 <lambdabot>   15
02:15:14 <dmwit> Hm, there's a Bits instance for Integer?
02:15:25 <Beelsebob> that's rather odd
02:15:34 <dmwit> Indeed.
02:15:36 <idnar> why wouldn't there be?
02:15:38 <dmwit> Isn't there a bitwise not?
02:15:40 <Beelsebob> surely that's very gmp version dependant?
02:15:41 <joelr1> good morning
02:15:54 <dmwit> Beelsebob: Oh, I wouldn't worry about that.
02:15:57 <Beelsebob> idnar: because there's no standard rep for infinite size integers
02:16:02 <dmwit> So?
02:16:08 <dmwit> Conceptually, it's just a string of bits.
02:16:25 <Beelsebob> if you assume that your representation is the number in binary
02:16:31 <dmwit> Let the functions map some odd representation of that onto the odd representation of the string of bits that corresponds to the intuitive operations.
02:16:34 <Beelsebob> which isn't true in most cases
02:16:45 <idnar> Beelsebob: sure, but there's a base 2 representation
02:16:50 <dmwit> Right.
02:16:53 <dmwit> And that's all that matters.
02:16:56 <idnar> Beelsebob: maybe you have to convert back and forth, but that's all "under the hood"
02:17:06 <quicksilver> > complement (0 :: Integer)
02:17:07 <lambdabot>   -1
02:17:08 <dmwit> The odd thing to me is that usually bitwise "not" also takes leading zeros to leading ones...
02:17:12 <quicksilver> hrm
02:17:15 * dmwit blinks
02:17:17 <idnar> quicksilver: hehe, I was just about to try that
02:17:18 <quicksilver> this is slightly fishy.
02:17:18 <dmwit> > complement 15
02:17:20 <lambdabot>   Add a type signature
02:17:23 <dmwit> > complement 15 :: Integer
02:17:25 <lambdabot>   -16
02:17:37 <Beelsebob> the thing is -- asking for the bits is not the same as asking for the base two representation of it
02:17:37 <dmwit> complement = succ . (0-) ?
02:17:40 <dmwit> err...
02:17:45 <dmwit> pred . negate
02:17:55 <Beelsebob> after all, asking for the bits of a Float, doesn't give us a fixed point representation, does it?
02:17:59 <Beelsebob> it gives the floating point one
02:18:01 <blackh> It's like dealing with some sort of unknown alien intelligence.
02:18:09 <dmwit> Beelsebob: The Bits class is not about asking for the bits of the *representation*.
02:18:16 <pumpkin> :t complement
02:18:16 <quicksilver> Beelsebob: Data.Bits is really about the base two representation.
02:18:18 <lambdabot> forall a. (Bits a) => a -> a
02:18:20 <idnar> Beelsebob: there's no Bits instance for any floating-point type, as far as I can see
02:18:27 <quicksilver> Beelsebob: in the sense of Bit = Binary Digit = Base Two Digit
02:18:29 <Beelsebob> quicksilver: it's a bit of an odd name then
02:18:31 <pumpkin> > complement (5.6 :: Float) :: Integer
02:18:32 <lambdabot>   Couldn't match expected type `Integer'
02:18:34 <quicksilver> not really, no.
02:18:36 <Beelsebob> I guess
02:18:37 <pumpkin> > complement (5.6 :: Float)
02:18:38 <lambdabot>       No instance for (Bits Float)
02:18:38 <lambdabot>        arising from a use of `complement' ...
02:18:41 <quicksilver> Bits are base two digits ;)
02:18:50 <idnar> it's Bits, not RawMemory ;)
02:18:55 <Beelsebob> true true
02:19:06 <Beelsebob> so why then does Float not give a proper representation
02:19:23 <pumpkin> because it doesn't have an integer base 2 representation?
02:19:25 <Beelsebob> it just seems rather ill-defined to me
02:19:30 <quicksilver> "This module defines bitwise operations for signed and unsigned integers"
02:19:39 <quicksilver> Data.Bits is about base two reps of integers.
02:19:40 <Beelsebob> oh, does it?
02:19:42 <Beelsebob> hmm
02:19:45 <pumpkin> waht if I unsafeCoerce it?
02:19:47 <idnar> pumpkin: it has a fractional base 2 representation, though ;)
02:19:47 <Beelsebob> okay
02:19:47 <ToRA|MSR> > (fromIntegral (-1 :: Word32)) `xor` (-1) :: Integer
02:19:48 <lambdabot>   -4294967296
02:19:56 <pumpkin> idnar: of course
02:19:58 <quicksilver> you could imagine exctending it for base 2 non-integers, though.
02:20:22 <pumpkin> I guess I should've said whole rather than integer
02:34:35 <naradapuri> I was discussing Haskell with a friend and he asked a valid question - how portable Haskell is? Do you guys have good/bad experience with running a haskell program on several different platforms?
02:34:57 <dmwit> Haskell is very portable.
02:35:58 <fasta> Does the Hugs foreign export functionality work?
02:38:08 <quicksilver> naradapuri: if by 'portable' you mean osx/i386, linux/i386, and win32/i386, then the standard libraries are very portable and everythign works well.
02:38:54 <quicksilver> naradapuri: PPC is a slightly less well supported hardware platform, and other chips (arm, sparc, etc) have no native codegen so they go via unregisterised C which is slow.
02:39:02 <fasta> No, not everything works well. A lot works well.
02:41:28 <naradapuri> quicksilver: Thanks, I'd be interested in windows/linux i386/64bit - how is it with 64bit support?
02:41:28 <naradapuri> And do I understand correctly that other platforms (i.e. sparc) work, just that they are slow?
02:42:56 <zax> > 1900 `mod` 100
02:42:57 <lambdabot>   0
02:43:37 <quicksilver> naradapuri: yes, they work, under debian at least.
02:43:47 <quicksilver> naradapuri: 64bit support is fine as far as I know, but I've never used it.
02:45:55 <fasta> Does Cabal also work with Hugs?
02:47:21 <dmwit> naradapuri: I'm on 64-bit and have not had any trouble.
02:47:26 <fasta> Hmm, it seems Hugs doesn't like foreign exports.
02:50:27 <Saizan> fasta: you use Cabal to compile a package with Hugs, but it won't check the dependencies at configure time
02:51:03 <fasta> Saizan: ok, and do you know whether foreign export declarations work?
02:51:21 <fasta> Saizan: it seems that it doesn't, but maybe there is the -justwork flag that I missed.
02:51:30 <fasta> Saizan: I already tried -98 of course.
02:53:27 <Saizan> uhm, no, i don't know
03:06:30 <blackh> naradapuri: When I was leaning Haskell, I had two programs compiled with ghc running on 64 bit Linux - one processed files, and the other was an OpenGL program.  I compiled them both on Windows, and they both worked perfectly.
03:07:58 <blackh> naradapuri: My machine is a 64-bit Linux and I have done everything I can think of with ghc and had no trouble.
03:08:59 <naradapuri> blackh: that's great; I was thinking that since Haskell is very abstract and detached from the way computers work, it would have little problems with portability. But I better wanted to ask people with more experience.
03:09:31 <pumpkin> in theory that's true, but it's a bit of a pain to get started on new platforms
03:09:40 <ksf> Would anybody be surprised if I'd say that, in retrospective, Haskell was an outstanding factor I got out of my burnout?
03:10:04 <fasta> naradapuri: I had one import inconsistency between i386 and x86-64, but that's all.
03:10:30 <fasta> naradapuri: the hard part was to get cabal install on x86-64, but there is a script for that now.
03:11:12 <blackh> I had no trouble at all getting cabal installed on x86-64 - I didn't have to do anything special
03:11:19 <blackh> (This was recently.)
03:11:52 <pumpkin> well 64 is pretty similar to i386 :)
03:12:18 <pumpkin> I'm still gathering courage to give osx/arm another go
03:13:12 <ksf> there are people that are still using x86?
03:16:02 <blackh> ksf: We're not all lucky enough to have a ... err .. what?
03:16:19 <ksf> amd64
03:16:24 <ksf> for ages now.
03:16:48 <blackh> Oh right. I've got one of those inferior Intel dual core Centrino things. Sounds like a kind of sheep.
03:17:17 * quicksilver has had an amd64 for ages but has always run it in i386 mode.
03:17:41 <naradapuri> fasta: I'm using debian, which already provides cabal in ghc6 package, so I believe this will go without problems on 64bit too.
03:18:18 <British0zzy> hi, in haskell, how can i retrieve pixel (x,y) and get the integer values for the pixels rgb?
03:18:24 <idnar> since when does OSX run on ARM?
03:18:38 <ksf> http://www.cpu-world.com/CPUs/K8/TYPE-Athlon%2064.html
03:18:45 <British0zzy> idnar: iPhone is ARM, right?
03:18:46 <ksf> 3200+.
03:18:56 <pumpkin> idnar: since iphone :)
03:19:00 <idnar> British0zzy: the iPhone runs OSX?
03:19:04 <pumpkin> yup
03:19:16 <British0zzy> idnar: practically
03:19:17 <idnar> that's weird
03:19:21 <pumpkin> it is osx
03:19:25 <British0zzy> it's stripped down
03:19:43 <pumpkin> the important bits are all there
03:19:52 <pumpkin> minus the dtrace :(
03:20:02 <blackh> British0zzy: What library are you using for your images?
03:20:47 <British0zzy> i don't know what library to use. i can use any image format
03:21:10 <blackh> Try hsmagick
03:21:56 <British0zzy> blackh: checking it out
03:22:42 <blackh> It looks like it should do what you want.
03:23:11 <blackh> importPixelImageArea :: QuantumType2 -> Word -> [[Word8]] -> Maybe ImportPixelAreaOptions -> HImage -> HImage
03:23:22 <blackh> ...maybe
03:23:31 <pumpkin> we needz us dtrace bindings for haskell
03:24:06 <blackh> Note that [Word8] is a list and indexing a list is O(N) so you might want to convert to an array first
03:26:50 <dmwit> British0zzy: What do you need the library to do to images?
03:27:34 <British0zzy> i've written an autoencoder, and want to try and get it to learn different patterns
03:28:10 <pumpkin> I really need to make my program more efficient
03:28:20 <pumpkin> eating up 2.5 gigs of RAM isn't a good idea
03:29:01 <pumpkin> especially when that's just from a 40 MB CSV file :P
03:29:36 <dmwit> British0zzy: Oh, have you seen the machine learning-oriented image/video library?
03:29:38 <earthy> uh. uhuh.
03:29:55 <dmwit> It's got some bindings to OpenCV stuff, I think, as well as a bunch of other neat-looking functions.
03:29:57 <earthy> pumpkin: do you use ByteString at all? :)
03:30:14 <pumpkin> only before converting it to the numeric type I need :P
03:30:38 <earthy> ah
03:30:55 <British0zzy> dmwit: i've seen some of the machine learning stuff, i'm probably doing something different, but i never mind seeing more inspiration :) where can i find it?
03:31:04 <earthy> 2.5G sounds like a shitload of unevaluated thunks
03:31:52 <pumpkin> earthy: I have a 651-dimensional dataset with around 10000 samples per dimension, and I proceed to calculate another 3 dimensions (features) for each input dimension of the same size
03:31:57 <pumpkin> I then do some "stuff"
03:32:02 <pumpkin> and output a relatively tame list
03:33:24 <dmwit> I'm having difficulty locating the thing I'm thinking of...
03:37:27 <dmwit> Here we go!
03:37:31 <dmwit> British0zzy: http://www.easyvision.googlepages.com/
03:38:47 <pumpkin> that looks pretty awesome
03:39:20 <pumpkin> "camera combinators"
03:40:11 <pumpkin> how do I tell the garbage collector to be more aggressive?
03:40:33 <Saizan> ?hoogle performGC
03:40:33 <lambdabot> System.Mem performGC :: IO ()
03:40:49 <pumpkin> isn't there some command-line parameter I can pass?
03:40:51 <Saizan> i guess there are also +RTS flags that affect it
03:40:52 <zax> if i have a list of bools, is there a function which tells me the first occurense of a False? or do i have to do it myself?
03:40:58 <zax> at what index*
03:41:06 <pumpkin> you could do length . break, maybe
03:41:23 <zax> like a reverse !!
03:41:23 <Saizan> ?type findIndex
03:41:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
03:41:36 <kpreid> ?type elemIndex True
03:41:37 <lambdabot> [Bool] -> Maybe Int
03:41:54 <Saizan> > findIndex not [True,Ture,False]
03:41:55 <lambdabot>   Not in scope: data constructor `Ture'
03:41:58 <kpreid> er, elemIndex False, I mean
03:43:15 <British0zzy> dmwit: Thanks, that looks quite interesting.
03:46:47 <quicksilver> pumpkin: there are lots of commandline flags which affect it, but what do you mean by aggressive?
03:46:59 <quicksilver> pumpkin: nodes are either reachable or not, so they're either eligible for collection, or not.
03:47:05 <quicksilver> it's binary, not a continuum.
03:47:07 <pumpkin> "check often if there's stuff I can get rid of"
03:47:13 <pumpkin> oh, it does it on the fly?
03:47:27 <quicksilver> it does minor collections more regularly than major
03:47:38 <quicksilver> it does minor collections whenever a nursery fills up, I believe.
03:48:01 <quicksilver> pumpkin: if you want to keep memory usage stable, the best approach is probably to call performGC at a 'good time for you'
03:48:02 <pumpkin> what was the thing about the multithreaded GC?
03:48:13 <quicksilver> e.g. just after swappingBuffers, or something.
03:49:38 <quicksilver> pumpkin: as of 6.10, the GC can use all the threads to do the work.
03:50:19 <pumpkin> ah
03:50:33 <pumpkin> so if I +RTS -N2 it'll use two?
03:50:52 <quicksilver> yup.
03:51:07 <quicksilver> it doesn't make a huge difference in practice, but it's better than nothing.
03:51:25 <quicksilver> 30% speedup I seem to remember was quoted.
03:56:54 <pumpkin> this makes no sense
03:57:20 <pumpkin> if I filter a large list only a little bit, I use less memory than if I filter it more
03:58:19 <dmwit> Are you holding on to a reference to the list?
03:58:33 <dmwit> i.e. do you use the beginning of the (unfiltered) list later?
03:58:56 <pumpkin> yeah
03:59:45 <pumpkin> but I need to
04:00:45 <dmwit> These results should then not surprise you.
04:00:58 <dmwit> Nor could "aggressive garbage collection" help you.
04:01:05 <pumpkin> well, I have a large list, and then a filtered down version of it
04:01:14 <pumpkin> and I understand that I'll need more space to keep both around
04:01:35 <pumpkin> but I'd assume the more I filter the filtered version, the less memory I'd need total?
04:01:47 <dmwit> No, the more you filter it, the more of it you're forcing.
04:01:57 <dmwit> amirite?
04:02:08 <dmwit> Or am I misunderstanding what you mean by "filter more"?
04:03:23 <pumpkin> say I have a list of all the integers to 1000... I need to keep that around, then say I also filter all odds out of the list. I understand that this situation will take more than the simple 1..1000, but why would filtering all odds out use less memory than filtering all odds AND all multiples of 4 out?
04:03:57 <dolio> It would depending on what elements of the list you look at.
04:04:09 <pumpkin> I need to look at all of them eventually
04:04:28 <dolio> If you look at the first, it's the same (2). If you look at the second, then in the first case it's 4, in the second it's 6.
04:04:40 <pumpkin> yup
04:04:46 <dolio> So looking at the second element of the filtered list causes more of the large list to be evaluated and kept around.
04:05:03 <pumpkin> but I'm fully evaluating both of them eventually
04:05:09 <pumpkin> it's not as if I'm only looking at some of the larger list
04:05:29 <pumpkin> in fact, I rnf the large list immediately (not sure if that makes a difference actually)
04:05:49 <dolio> If it's rnf, then it should be fully evaluated.
04:06:06 <dolio> Can you paste some code?
04:06:57 <pumpkin> just a sec, let me see if I can figure it out
04:19:45 <ToRA|MSR> anybody involved with c.h.o about? i'm getting a 500 ISE on account creation request...
04:23:12 <Igloo> Wow, something odd has happened to the error reporting
04:23:20 <Igloo> It's trying to tell you you have a newline in your SSH key
04:23:41 <ToRA|MSR> ah ok
04:23:50 <ToRA|MSR> ta
04:23:53 <Igloo> Hmm, are you sure it doesn't say that?
04:24:04 <Igloo> Oh, IE is probably being "helpful" and showing you a "friendly" error
04:24:47 <ToRA|MSR> well i.e. was being "helpful" yeah
04:24:49 <Igloo> But that doesn't explain why we're getting things like http://hpaste.org/12849 in logs
04:25:04 <quicksilver> cute.
04:26:14 <ToRA|MSR> Igloo: that was just me testing i.e.
04:26:15 <ToRA|MSR> sorry
04:26:31 <Igloo> No, that's me testing it
04:26:41 <ToRA|MSR> oh i see
04:26:51 <Igloo> All that is from a single request; you have to read down a column near the middle to see the actual error
04:28:09 <Igloo> Hmm, that's with cgi-2006.9.6, so I should wait until we upgrade before investigating
04:33:22 <mokus> that log dump looks like someone was overzealous with the mapM_ ;-)
04:45:42 <redditbot> [Haskell-cafe] Re: Fun with Haskell, runST, MArray, and a few queens. (Imperative Haskell Version)
04:45:56 <athos> hi all
04:46:16 <slarba_> hmm. is there still no TH library for generating zippers for given type?
05:01:44 <skorpan> b
05:02:16 <hallongrottan> c
05:02:49 <Erik__> d
05:05:36 <SamB_XP> e
05:05:45 <bbs> f
05:06:41 <Choko> g
05:08:04 <opqdonut> h
05:09:29 <saml> is there a library that loads c libraries dynamically?
05:09:46 <pumpkin> dlopen style?
05:10:02 <saml> like python's ctypes
05:10:16 <saml> or this: http://alien.luaforge.net/
05:10:20 <PeakerWork> saml: I think "the" FFI support is like Python's ctypes
05:10:35 <SamB_XP> but it isn't dynamic
05:10:46 <saml> oh let me read about ffi
05:12:09 <SamB_XP> (well, I mean, you can certainly use dlopen if you want...)
05:15:16 <quicksilver> saml: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-DynamicLinker.html#v%3Adlopen
05:15:51 <pumpkin> oh sweet, I love fun pointers!!
05:15:54 <SamB_XP> ooh, even better -- ready-made bindings
05:16:06 <SamB_XP> didn't know about those
05:16:23 <saml> i'm on windows. this is to compile SDL hello world on windows
05:16:38 <SamB_XP> oh
05:16:50 <quicksilver> saml: why do you need dlopen to compile SDL hello world?
05:16:53 <SamB_XP> couldn't you just use HSDL ?
05:16:53 * quicksilver looks strangely at saml 
05:17:06 <quicksilver> even if you didn't just use HSDL, you could just bind to SDLs ffi
05:17:15 <quicksilver> (but just using hsdl is probably better)
05:17:31 <saml> i use SDL binding from hackage. i can install it. but programs written with it fail to link
05:17:49 <Lemmih> saml: You need to write your own main.c.
05:17:54 <quicksilver> OK, well you asked the wrong question then.
05:17:58 <quicksilver> ;)
05:17:59 <PeakerWork> saml: then something messed up, you can probably add "-l" or linker-flags/libraries to the ghc-pkg description of the installed sdl
05:18:12 <lilac> ghc --make should fix that, shouldn't it?
05:18:26 <SamB_XP> Lemmih: why is that ?
05:18:45 <Lemmih> SamB_XP: The SDL library redefines 'main' to SDLmain.
05:19:02 <SamB_XP> oh sick
05:19:10 <lilac> that's quite rude of it...
05:19:14 <Lemmih> Yeah, it sucks ass.
05:20:01 <saml> hsdl and hssdl are different?
05:20:19 <Lemmih> HSDL isn't maintained anymore.
05:20:32 <lilac> Lemmih: a quick googling seems to indicate that only happens if you link to SDLmain.o (or something)
05:21:13 <saml> Lemmih, do you have an example on how to do that? http://darcs.haskell.org/~lemmih/hsSDL/hssdl/Examples/MacOSX/  it seems like this is doing that.. but i can't find main.c
05:21:43 <lilac> redefining main isn't going to work for cases like python's sdl bindings, so it's got to be optional
05:22:19 <Ezla> Did you guys ever see that "A taste of haskell" video with Simon Peyton Jones about XMonad
05:22:34 <Ezla> I tried to watch it like 3x, but he speaks so fast it causes anxiety.
05:22:44 <saml> lilac, why is so?
05:23:03 <quicksilver> Ezla: yeah, SPJ is a bit enthusiastic sometimes :)
05:23:14 <quicksilver> still, I find him enjoyable to listen to in person. Very engaging.
05:23:31 <lilac> saml: because the python sources won't be including the SDL headers
05:24:04 <Ezla> It would make more sense to listen to somebody going speed nuts in person
05:24:28 <quicksilver> I certainly think videos are normally not as good as a seminar in person.
05:24:33 <quicksilver> Although it's quite cool that they exist at all.
05:24:46 <quicksilver> (if you were setting out to make a video in the first place you'd do it differently)
05:25:03 <Ezla> I'm trying to find the descrption of the structure of a haskell programming, starting at main
05:25:26 <SamB_XP> quicksilver: well, yeah, you can't even read the slides in the video can you ;-P
05:25:28 <Ezla> If somebody asked me that about an OO lang (C++/D), I could go on for hours
05:25:31 <SamB_XP> good thing those are available too
05:25:48 <lilac> Lemmih: right, so SDL ships with an SDLmain.a which contains a 'main' which calls your 'SDLmain' but linking to this appears to be optional.
05:25:52 <Ezla> *structure of a haskell program
05:26:23 <Lemmih> lilac: It only affects MacOS and Windows so I have no direct experience with it.
05:26:25 <SamB_XP> lilac: what does it do first ?
05:26:25 <daf> Ezla: crunchy IO shell with a yummy pure centre
05:26:30 <quicksilver> Ezla: structure of a haskell program is that "main" is an IO () action which gets executed.
05:26:40 <quicksilver> Ezla: everything beyond that is "on-demand".
05:27:27 <Ezla> The easy part to describe about OO is:  "and now we're going to allocate some objects, and pass some pointers, and pass some references, and create a vector of Foo's, and ..."
05:27:37 <Ezla> But I read 3 haskell tutorials so far and
05:27:55 <Ezla> none of them explain how you actually ... do stuff beyond 5-10 lines of code
05:27:55 <SamB_XP> what are these "references" ?
05:28:03 <daf> and what's a "pointer"?
05:28:10 <pumpkin> lol
05:28:14 <PeakerWork> Ezla: Which tutorials did you read, and how far into them did you get?
05:28:32 <PeakerWork> "cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0" -- and it also claims ghc is not itself a package
05:28:35 <Ezla> daf/sam, you don't want me to really answer that right ? :)
05:28:47 <daf> Ezla: the point is that "easy" is relative
05:28:58 <daf> Ezla: it's easy if the person you're explaining to has the appropriate grounding
05:29:14 <quicksilver> Ezla: what kind of stuff do you hope to do, that wasn't explained in those tutorials?
05:29:25 <SamB_XP> Ezla: most OO languages don't have those C++ concepts
05:29:42 <quicksilver> Ezla: if you mean stuff like 'open a graphics file' or 'connect to a database' or 'run a webserver' then most of those facilities are provided by libraries
05:29:59 <quicksilver> Ezla: for the most part, they provide IO actions which you put in your main action (directly or indirectly)
05:30:32 <Ezla> Peaker: LYAHFGG, A gentle introduction (mostly reading gentle intro stuff that i noticed wasnt in LYAHFGG), and also "hi everyone welcome to my haskell tutorial"
05:30:36 <PeakerWork> Ezla: the "Real World Haskell" book seems to go into quite large practical programs
05:30:46 <quicksilver> Ezla: I was about to recommend RWH also.
05:30:53 <quicksilver> for a more practical programmer approach.
05:31:23 <Ezla> the reason the pointers are easier to describe to people, is because of the mutability
05:31:34 <PeakerWork> Ezla: Did you read the full tutorials? Do you now know about Monads, Transformers, data types, etc?
05:31:51 <pumpkin> pointers are known as things people trip up on a lot, and particularly beginner-unfriendly, actually :P
05:32:05 <Ezla> Peaker, I only understand Monads in the context of 'do' so far
05:32:10 <athos_> pointers aren't easy to describe.
05:32:27 <pumpkin> you need to explain memory structure
05:32:28 <PeakerWork> Ezla: IIRC, The Gentle Introduction does cover monads
05:32:30 <athos_> the only good tutorial on pointers (c) can be found in "the c programming language)
05:32:32 <pumpkin> to explain why pointer arithmetic works
05:32:38 <athos_> there's no better one
05:33:43 <SamB_XP> pumpkin: even then, people won't really get it for a while
05:33:52 <daf> and even experienced people make mistakes
05:33:57 <daf> especially with pointers to pointers
05:34:02 <athos_> yep
05:34:11 <PeakerWork> hmm.. "ghc-6.10.1 requires process ==1.0.1.1" and "ghc-6.10.1 requires process ==1.0.1.0"  in the same error message from cabal-install, how is this possible?
05:34:13 <PeakerWork> @seen dcoutts
05:34:13 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
05:34:31 <SamB_XP> maybe they get it after they disassemble a 16-bit x86 program ...
05:34:38 <Ezla> So what I'm really wondering about is passing data around. I'd like to ask about one example.
05:34:41 <lilac> SamB_XP: SDLmain: on linux, it does nothing. on windows, it does argument parsing, calls SDL_Init and SDL_SetModuleHandle (and a few other things)
05:34:41 <pumpkin> why 16-bit?
05:34:44 <SamB_XP> (a non-tiny one)
05:35:02 <pumpkin> with the older x86 stuff you have all that nasty segmentation
05:35:14 <Zao> lilac: On OSX it does lots of magic, and woe the one that forgets it.
05:35:15 <pumpkin> which distracts even further from the real pointers
05:35:16 <SamB_XP> pumpkin: well, few 32-bit x86 programs use a segmented memory model
05:35:26 <quicksilver> Ezla: ask away :)
05:35:27 <SamB_XP> pumpkin: no, that's exactly what I was talking about
05:35:31 <pumpkin> ah ok :)
05:35:42 <SamB_XP> pointers are specified to accomodate that!
05:35:57 <lilac> Zao: indeed. /lots/ of magic there :) in Objective-C no less (I think?)
05:36:19 <Zao> lilac: All I know is that I tried building SDL on my own there, and failed horribly.
05:36:30 * pumpkin whacks his macbook pro
05:36:39 <Zao> Several rubber chickens have given their lives to spawn the SDL packages there.
05:36:49 <kfish> Ezla, how about this: http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial -- you can pass data, use typeclasses, use cabal, all good fun
05:37:57 <pumpkin> Ezla: what example are you thinking of? :)
05:38:02 <Ezla> Even though I understand how typeclasses are restraints, and that the data constructor makes "terminals" and or enums and or nonterminals, by which to match against the typeclasses-
05:38:09 <Ezla> If I have:
05:38:22 <Ezla> list of Monkey, Bear, Duck, Goose, and they all match the typeclass of Animal
05:38:35 <Ezla> and I have functions in the typeclass for working on those Terminal types
05:38:43 <Ezla> first off --
05:39:04 <Ezla> If your functions are only using Animal as a typeclass, why would you even make a type for "Monkey", "Bear", etc?
05:39:25 <lilac> Ezla: typically, so you can implement the typeclass methods differently
05:39:26 <Ezla> How do you get the "virtual" part
05:39:46 <Ezla> Where functions that are typeclass constrained to Animal
05:39:54 <lilac> Ezla: but faking OO is not the usual way to write code in Haskell
05:39:56 <Ezla> end up invoking a forwarded function for a proper type
05:40:45 <quicksilver> under-the-hood, you can imagine that the compiler generates a stub which passes the type
05:40:53 <quicksilver> so the function can call the appropraite methods by looking them up
05:41:01 <lilac> Ezla: when you have foo :: Animal a => a -> a, you can think of it as foo :: Animal a -> a -> a, where "Animal a" is basically the type of a vptr for Animal
05:41:05 <Saizan> typeclasses are all about the "virtual" part
05:41:12 <Ezla> quicksilver what does that even look like in code?
05:41:13 <quicksilver> (that's not exactly what practical compilers do, but that's one way to think of it)
05:41:31 <quicksilver> Ezla: well, for example "negate 5"
05:41:33 <Ezla> Do you mean that the typeclass Instances
05:41:37 <quicksilver> negate is a typeclass function
05:41:40 <Ezla> are *automatically* picked
05:41:41 <quicksilver> the correct version of negate
05:41:46 <quicksilver> (say integer in this case)
05:41:50 <quicksilver> is picked form the type.
05:41:50 <Ezla> when you use typeclass functions?
05:41:55 <Saizan> yes
05:41:56 <quicksilver> yes.
05:41:58 <Ezla> oh!
05:41:59 <quicksilver> the compiler infers the types
05:42:04 <quicksilver> all types are known at compiler time
05:42:31 <lilac> Ezla: at runtime, a typeclass instance acts a bit like a vtable
05:42:51 <pumpkin> for example I can do multiplyEnum :: (Enum a) => a -> a, and have it be defined as (toEnum . (*2) . fromEnum)
05:43:06 <pumpkin> (not sure why I'd want to do that
05:43:08 <Ezla> thanks
05:43:12 <Ezla> So how about this:
05:43:19 <Saizan> pumpkin: you also need Num a there
05:43:23 <pumpkin> oh true
05:43:25 <Ezla> In OO, typeid is a hash, or a unique pointer, which has a constant location in memory or some regularized hash based upon that type, and which ensures it can be sorted (implements operator <)
05:43:30 <Ezla> Say I want to implement a factory
05:43:37 <pumpkin> Saizan: actually, do I?
05:43:42 <Ezla> where I map strings to typeclass instances
05:43:50 <Ezla> and I'd like to use the 'map' function
05:43:56 <Ezla> to iterate over this list:
05:44:07 <Ezla> ["Dog", "Bear", "Alligator"
05:44:08 <Ezla> ...
05:44:12 <quicksilver> instances and indeed classes and indeed types are all not first-class values.
05:44:21 <Saizan> pumpkin: no, sorry
05:44:27 <Ezla> I never actually construct any values ever?
05:44:44 <Ezla> Or do you store "polymorphic entries"
05:44:46 <Ezla> inside an
05:44:48 <quicksilver> if you're trying to do something dynamic you probably shouldn't use typeclasses in the first place.
05:44:48 <Ezla> [Animal]
05:44:49 <lilac> Ezla: that's not really OO, that's a specific language feature, but i get your point.
05:45:06 <SamB_XP> lilac: of which language ?
05:45:06 <pumpkin> Ezla: you could do read or something
05:45:12 <quicksilver> typeclasses are specifically a tool for adhoc overloading.
05:45:13 <lilac> SamB_XP: C++ has that, for a start
05:45:13 <EvilTerran> Ezla, that'd be [exists a. Animal a => a]
05:45:24 <quicksilver> not really a general abstraction.
05:45:29 <EvilTerran> (not valid syntax, just pseudocode)
05:45:48 <Ezla> [exists a. Animal a => a] -- what's exists for?
05:46:17 <ksf> It's mathematicians trying to be incomprehensible.
05:46:18 <pumpkin> backwards E?
05:46:29 <ksf> "for every a that exists, there's also an Animal a
05:46:41 <SamB_XP> ksf: lier!
05:46:43 <Ezla> i'm not sure how to parse that lol
05:46:44 <SamB_XP> er. liar!
05:46:46 <PeakerWork> Ezla: exists a. means that "a" is some type, but it can by any type at all that satisfies the constraints, but you don't get to choose what it is
05:46:56 <EvilTerran> "list of elements such that, for each list entry, there exists a valid type for the entry that is an instance of the Animal typeclass"
05:46:58 <SamB_XP> they aren't trying to be incomprehensible -- it just comes naturally!
05:47:04 <Ezla> Peaker: Why not just write  [Animal]   ?
05:47:04 <lilac> newtype AnyAnimal = forall a. Animal a => AnyAnimal a
05:47:14 <EvilTerran> Ezla, because Animal is a typeclass, not a type
05:47:16 <quicksilver> Ezla: because Animal is a class, not a type.
05:47:16 <lilac> then [AnyAnimal]
05:47:21 <PeakerWork> Ezla: (forall a. a) means that you get to choose whatever a you want.  (exists a. a) means that its some chosen 'a', and it can be anything, but you don't get to choose, so you have to know how to work with any type at all
05:48:21 <Ezla> > AnyNum = forall a. Num a => AnyNum a; :t [AnyNum]
05:48:22 <lambdabot>   <no location info>: parse error on input `='
05:48:48 <quicksilver> Ezla: lambdabot doesn't do type definitions. Which is a pity.
05:49:05 <PeakerWork> Ezla: they are sort of opposites.  f :: forall a b. (a -> b) -> b      means that the user of "f" chooses whichever specific 'a' and 'b' it wants. However, this means that the "f" function itself gets an (exists a b. a -> b) so it must be able to work with any "a" and "b", and not some specific types
05:49:36 <PeakerWork> Ezla: indeed you can do that
05:49:57 <lilac> "newtype AnyAnimal = forall a. Animal a => AnyAnimal a" means "create a new type called AnyAnimal where, for all types a in typeclass Animal, there exists a constructor AnyAnimal taking that a"
05:50:23 <Ezla> The difficult part is to understand why Haskell works this way, rather than the language design just using a sledgehammer and saying  [Num]  is OK
05:50:38 <lilac> Ezla: multi-parameter typeclasses are one reason
05:50:39 <PeakerWork> Ezla: note that polymorphism makes the life of its user easy, and its implementor hard.  "exists" and "forall" are basically specifying who the "user" (forall) and who the "implementor" (exists) are
05:50:52 <macron> hi all, what's more "Haskell's way"? Writing functions after the definitions they depend on, or writing them immediately after them at the top level of a source file?
05:50:58 <Ezla> lilac, how does that look?
05:51:09 <lilac> Ezla: class Foo a b where foo :: a -> b
05:51:21 <Ezla> why is exists the implementor?
05:51:22 <kalven> back to ezla now?
05:51:31 <quicksilver> Ezla: because the language design is based on the principles of a well understood mathematical system.
05:51:34 <lilac> Ezla: although that's not allowed in the Haskell98 report
05:51:42 <daf> Ezla: how would such a sledgehammer work?
05:51:53 <PeakerWork> Ezla: The implementor of polymorphism does not get to choose the type, it allows the "user" to choose the types, meaning it must have the difficult position of being able to work with all the types its given, which is what (exists) means
05:51:59 <Ezla> daf: basically by doing the 'exists' part for you
05:52:11 <quicksilver> Ezla: and typeclasses are a particular extension to that system.
05:52:22 <Ezla> and for all values of "Basically meaning"  ->  "I am a newbie"
05:52:23 <daf> Ezla: that's just a matter of typing
05:52:28 <PeakerWork> Ezla: For every forall, there is an exists somewhere else
05:52:32 <PeakerWork> (I think)
05:52:33 <quicksilver> Ezla: IOW the justification for this decision is not an engineering one, but a theoretical one.
05:52:44 <lilac> daf: something like "newtype Animal = forall a. Animal a => Animal a deriving Animal" ?
05:52:46 <Ezla> so it's not practical, but it's consistent?
05:52:50 <quicksilver> Ezla: albeit a theoretical one which turns out to have good practical results.
05:52:57 <quicksilver> it is consistent and also practical ;)
05:53:12 <quicksilver> it just looks different (perhaps) from how it would look if practicality had been the initial objective.
05:53:16 * RayNbow gets the feeling he should pick up TaPL again and continue reading it...
05:53:17 <daf> lilac: I'm not sure what that means :)
05:53:52 <PeakerWork> category-extras from darcs seems to still be assuming ghc-6.8 arrow library structure?
05:54:12 <lilac> daf: Animal is a type which contains, for any type in class Animal, a constructor taking that type, with an Animal instance derived from it
05:54:38 <Ezla> so, usually when something is consistent like that, part of the reason is because the simplified form "can do 90% of use cases, but not the other 10", whereas the explicit form can do it all
05:54:56 <Ezla> lilac, class Foo a b where foo :: a -> b
05:55:03 <Ezla> how do you use that in the list?
05:56:04 <ski_> "use in the list" ?
05:56:05 <lilac> Ezla: you can say "fooMap :: Foo a b => [a] -> [b]; fooMap = map foo" for instance
05:56:11 <quicksilver> Ezla: that's probably true (the 90/10 rule).
05:56:23 <quicksilver> Ezla: more importantly, though, these existential things are very seldom used.
05:56:28 <quicksilver> they weren't in haskell98 at all.
05:56:43 <quicksilver> so this is a corner case, not a common practical stumbling block.
05:57:22 <lilac> Ezla: that example should hopefully make it clear that classes and typeclasses are fundamentally quite different
05:57:27 <Ezla> so using exists is the same as like making a Looping 'data' definition or some other recursive data def ?
05:57:36 <lilac> Ezla: despite having surface similarities in many cases
05:57:37 <Ezla> in the existential part
05:58:15 <lilac> 'exists' is basically making a union type
05:58:20 <Ezla> what is an 'existential thing'
05:58:35 <lilac> or do i mean intersection?
05:58:49 <PeakerWork> the category-extras authors are taking a long while to fix their .cabal mishap :-(
05:59:09 <ski_> (afaik only jhc currently (partially) allows actually using `exist' .. but it's still useful for talking about what one wants to express)
05:59:12 <ksf> "exists" is conjuring up the existence of something you don't wanna define.
05:59:53 <ksf> as in "a^2+b^2=c^2", where you say "three numbers exist"
05:59:54 <Ezla> what's the simplest example of an existential 'data' usage
06:00:29 <lilac> the "forall a. f a" type contains all values which are in type "f a" for every a. the "exists a. f a" type contains all values which are in type "f a" for some a.
06:00:54 <Ezla> hmm that makes more sense
06:00:59 <Ezla> when you get really specific
06:01:11 <lilac> therefore, the set of operations available on "forall a. f a" is those operations which are available for any "f a"
06:01:21 <quicksilver> Ezla: recursive data is supposrted directly, by the way
06:01:30 <quicksilver> you don't need any quantifiers for that.
06:01:35 <lilac> and the set of operations available on "exists a. f a" is those operations which are available for all "f a"
06:01:46 <Ezla> quicksilver: yes, I was just asking because I learned "existential types" as recursive data
06:01:55 <Ezla> but you used a new meaning of it I guess?
06:02:11 <lilac> existential types and recursive types are, i think, unrelated
06:02:14 <PeakerWork> I am not sure why "existentials" have anything to do with recursive data types?
06:02:47 <quicksilver> suppose you have a tuple (a,a -> b,a -> c)
06:02:57 <quicksilver> then, even if you don't know what 'a' is
06:03:00 <quicksilver> it's still useful
06:03:07 <quicksilver> you can apply the function in teh 2nd to the value in the first
06:03:13 <PeakerWork> Ezla: I am not sure why you are trying to learn advanced topics like existential types before implementing anything simple in Haskell :)
06:03:14 <quicksilver> and also the function in the 3rd to the value in the first
06:03:26 <quicksilver> so exists a . (a , a->b, a->c) is a useful type
06:03:34 <quicksilver> even though you don't know which a is stored there.
06:03:40 <quicksilver> in fact, even the compiler doesn't know any more!
06:03:48 <quicksilver> (haskell values have no type information at runtime)
06:03:48 <ski_> e.g. the only (non-bottom) value of type `forall a. [a]' is the empty list .. but the type `exists a. [a]' contains every list value, so e.g. `[[],"foo",[Just ('a',False),Nothing],[id,not]] :: [exists a. [a]]'
06:03:54 <Ezla> Peaker got start on em' sometimes, and also because its germane to what I did originally ask as simple haskell use: polymorphic list
06:04:00 <PeakerWork> quicksilver: s/haskell/ghc?
06:04:06 <quicksilver> PeakerWork: yes.
06:04:28 <lilac> quicksilver: isn't that type isomorphic to (b, c)?
06:04:29 <Ezla> otherwise it would be: "heres you solution use exists. Now go code with it. But dont try to understand it!"
06:05:01 <PeakerWork> Ezla: Not necessarily, if you just want a list of things that may differ from each other, you can use normal ADT's (ordinary data types, multiple constructors)
06:05:11 <lilac> Ezla: "polymorphic list" is not the goal of a program, it's an implementation detail. what are you trying to accomplish?
06:05:25 <kalven> to troll
06:05:30 <PeakerWork> Ezla: a "polymorphic list" is in essence a list of things that differ from each other
06:05:50 <PeakerWork> Ezla: one way is to have the actual type differ (as in existential types), and another way is to have only the values differ
06:05:56 <quicksilver> lilac: operationally, certainly.
06:06:00 <Ezla> lilac: literally, im not trying to accomplish any real program, Just making a bunch of smaller programs, and todays one was "map a list of strings to real types"
06:06:17 <lilac> Ezla: i think we made the mistake of saying how to implementa polymorphic list rather than telling you how to solve the overarching problem in haskell
06:06:17 <Ezla> only for exposition
06:06:22 <quicksilver> types don't really exist at runtime, Ezla
06:06:23 <ski_> maybe a better variation of quicksilver's example is `exists x. (x,a -> x -> x,x -> Maybe (a,x))' which could implement a stack (or possibly a queue, ..) of elements of type `a' .. where `x' is the hidden representation type
06:06:30 <quicksilver> so it's quite hard to do that kind of thing.
06:06:50 <quicksilver> (you can't map a list of strings to real types because real types are not haskell values.
06:07:12 <lilac> Ezla: when learning Japanese, you don't start by learning how to translate each latin letter into kanji
06:07:25 <Ezla> But, you could map it to a list of type identifiers, which maps to a set of constructor functions, which give you the right type back
06:07:30 <Ezla> out of a polymorphic set
06:07:55 <Ezla> lilac: What's that overarching problem?
06:08:02 <lilac> Ezla: that's my question to you.
06:08:12 <bjorkLinux> lilac, how then is japanese learnt?
06:08:30 <pumpkin> with great difficulty :)
06:08:34 <pumpkin> but the kana isn't too bad
06:08:50 <lilac> bjorkLinux: i never got very far learning japanese :)
06:08:53 <quicksilver> Ezla: yes, constructor functions, definiely.
06:09:00 <quicksilver> Ezla: not sure what you mean by 'type identifiers'
06:09:11 <quicksilver> Ezla: if you mean 'some value which identifies the tyep' then, yes, definitely.
06:09:24 <quicksilver> the class Typeable (from Data.Typeable) exists to give you values like that
06:09:26 <pumpkin> bjorkLinux: same with any language though... you won't get very far if you learn a language by literal translation
06:09:27 <quicksilver> (reifications of types)
06:09:34 <pumpkin> (in my experience at least)
06:09:37 <PeakerWork> Ezla: try starting with normal programs, rather than meta programs whose goal description includes language-specific terms like "types" or "polymorphic"
06:09:40 <lilac> bjorkLinux: but the point is, the mapping between English and Japanese, like between C++/D and Haskell, is at a high level of abstraction, not at a low one
06:09:48 <Ezla> , src ''TypeRep
06:09:51 <PeakerWork> Ezla: when I started with Haskell, the first thing I set out to write is a Ray Tracer, for example
06:10:08 <pumpkin> PeakerWork: ooh, good idea
06:10:16 <lunabot>  data TypeRep = TypeRep !Key TyCon ([TypeRep])
06:10:17 <pumpkin> someone should make a list of "good starting-out projects for learning haskell"
06:10:37 <Ezla> what other type representers are there?
06:10:44 <Ezla> not a template one
06:10:48 <Ezla> but some runtime kind
06:11:04 <PeakerWork> pumpkin: There were no libraries to create image files!
06:11:13 <pumpkin> oh no!
06:11:14 <PeakerWork> pumpkin: I had to create PPM files and use imagemagick to convert that to sensible formats
06:11:29 <pumpkin> we young'uns have it easy, don't we
06:11:37 <pumpkin> :)
06:12:01 <lilac> Ezla: i suspect you're asking the wrong questions.
06:12:26 <Ezla> I was trying to answer quicksilver
06:12:27 <Ezla> re:
06:12:32 <Ezla> <quicksilver> Ezla: not sure what you mean by 'type identifiers'
06:14:06 <PeakerWork> Ezla: Why do you insist on writing "meta" programs?  Why does your program goal include things like "type" in its description?
06:14:11 <quicksilver> Ezla: haskell, per se, has no notion of type at runtime
06:14:25 <quicksilver> Ezla: and that turns out to be fine for most code.
06:14:32 <quicksilver> Data.Typeable gives you a rather weak notion of type at runtime
06:14:41 <daf> I think that if you want to convert a list of strings to a list of values of different kinds, then you would just make a type with a constructor for each kind
06:14:43 <quicksilver> (a unique, comparable, identifier per type)
06:15:02 <Ezla> My human nature is to write a bunch of meta programs first
06:15:13 <Ezla> I don't think I can do it the other way
06:15:19 <lilac> Ezla: the meta-programs you want to write may not make sense in haskell
06:15:19 <pumpkin> you should learn template haskell first then
06:15:35 <Ezla> pumpkin: not ;P
06:15:45 <pumpkin> not meta enough for you?
06:15:45 <Ezla> By meta, just language experiments
06:15:48 <pumpkin> template template haskell!
06:16:17 <pumpkin> and make sure you create a type called MetaClass
06:16:20 <pumpkin> and MetaTypeClass
06:16:23 <kfish> Ezla, sounds great, type hacking is fun
06:16:24 <pumpkin> (doesn't have to do anything)
06:16:32 <scook0> well, there's nothing stopping you from generating TH code in TH
06:16:32 <pumpkin> (you just gotta have it, to be truly meta)
06:16:40 <scook0> except perhaps a sudden outbreak of sanity ;)
06:17:19 <kfish> Ezla, seen http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html ?
06:17:43 <PeakerWork> Ezla: I doubt your "human nature" does.  Why not write some program that solves some useful problem, or does something cool?
06:17:56 <Cheery> Can haskell communicate through COM?
06:17:58 <Ezla> Can you explain this a little better?
06:18:04 <Ezla> <PeakerWork> Ezla: (forall a. a) means that you get to choose whatever a you want.  (exists a. a) means that its some chosen 'a', and it can be anything, but you don't get to choose,
06:18:07 <Ezla> "dont get to choose" ?
06:18:26 <Cheery> (Does it have library for doing that already?)
06:18:39 <lilac> Ezla: it's some specific type, but you can't find out which.
06:18:40 <PeakerWork> Ezla: you get some unknown type, you have to work with it despite it being unknown, so the operations available to you are just those you get from whatever restrictions the type has
06:18:53 <EvilTerran> Ezla, a value of type (exists a. a) already has its type set, you just don't know what it is
06:19:04 <PeakerWork> Ezla: "forall a." is the "opposite", because you decide which "a" it is, rather than getting some unknown "a" from someone else
06:19:06 <Ezla> lilac: Is there no way to incur a runtime penalty with some form of "dynamic typecheck" ?
06:19:11 <Ezla> and switch on that
06:19:19 <lilac> Ezla: you can add a constraint whihc lets you find out
06:19:22 <Ezla> yeah
06:19:25 <pumpkin> haskell RTTI :o
06:19:27 <EvilTerran> lilac, that'd be Data.Dynamic
06:19:27 <PeakerWork> Ezla: There are ways, but they are discouraged
06:19:28 <Ezla> a virtual entry in the instances
06:19:32 <EvilTerran> er, Ezla, i mean
06:19:33 <PeakerWork> @type cast
06:19:34 <lilac> Ezla: for instance, (exists a. Typeable a => a)
06:19:35 <quicksilver> Ezla: that's what Data.Typeable does, basically.
06:19:35 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
06:19:36 <Ezla> but can haskell build that into every instance?
06:19:46 <Ezla> for me
06:19:54 <quicksilver> GHC can derive Typeable, yes.
06:19:56 <pumpkin> you can derive typeable automatically
06:20:00 <quicksilver> YOu mean 'type' not 'instance' I think.
06:20:27 <Ezla> quicksilver: I meant instance in terms of "you could implment it yourself if you added stuff to each instance"
06:21:01 <quicksilver> Ezla: yeah. You do mean type.
06:21:10 <quicksilver> (in haskell an 'instance' is an instance of a class, not the same as a type)
06:21:14 <Ezla> but how do you "add stuff" to a type?
06:21:21 <Ezla> I only know how to add stuff to typeclass instances
06:21:55 <polveroj> Ezla: types aren't really "full of stuff" the way classes in OO languages are full of methods
06:22:04 <Ezla> well thats what I thought now
06:22:08 <quicksilver> Ezla: you would write the Typable instance for that type ;)
06:22:09 <Ezla> and hence why I said instance
06:22:20 <quicksilver> but you don't write a Typeable instance for an instance.
06:22:23 <quicksilver> You write it for a type.
06:22:29 <PeakerWork> Ezla: you can define new instances for existing types and existing classes
06:22:33 <quicksilver> perhaps I was being stupidly pedantic and you understand perfectly.
06:22:41 <Ezla> quicksilver: oh yeah, I was saying if you had no "Typeable"
06:22:48 <quicksilver> agreed.
06:22:51 <PeakerWork> Ezla: (unlike OO, btw, you can add 3rd party interfaces to existing types)
06:22:55 <quicksilver> However, writing your own Typeable instances is unsafe.
06:23:01 <quicksilver> because you could lie, and that would break stuff.
06:23:05 <Ezla> you could probably get the same thing for a given set of instances by adding a "waht are you" function to each
06:23:07 <quicksilver> so it's best to let the compiler do that.
06:23:15 <EvilTerran> Typeable uses an unsafe operation under the hood
06:23:16 <Ezla> k
06:23:26 <EvilTerran> ?hoogle coerce
06:23:27 <lambdabot> module Unsafe.Coerce
06:23:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:23:31 <quicksilver> EvilTerran: Typeable doesn't, per se, but 'cast' and friends do.
06:23:31 <EvilTerran> ^ that one
06:23:43 <EvilTerran> quicksilver, yeah, true
06:24:06 <lilac> why are non-derived Typeable instances allowed even?
06:24:19 <Ezla> PeakerWork: how would 3rd party interface be useful?
06:24:41 <lilac> and that's the answer to my question :)
06:24:56 <lilac> Ezla: if there's a library which has types without Typeable instances, you can add them
06:25:24 <quicksilver> lilac: because GHC can't derive instances for everything.
06:25:32 <quicksilver> although argubaly that's a bug in GHC.
06:26:03 <EvilTerran> lilac, well, the standalone deriving is an extension, although i guess that still works as an example
06:26:17 <lilac> EvilTerran: hmm, fair point :)
06:29:10 <daf> EvilTerran: generally you don't "add stuff to a type", you just write functions
06:29:32 <earthy> which in a categorical view kinda is adding stuff to a type
06:29:35 <daf> unless you need to treat a bunch of differnt types in a similar way, in which case you use typeclasses
06:30:53 <Ezla> how is 'exists' implemented?
06:31:02 <Ezla> what is it /really/ doing?
06:31:03 <Ezla> http://www.haskell.org/hoogle/?hoogle=exists
06:31:05 <Ezla> ^--- nada
06:31:30 <PeakerWork> Ezla: for example, "Applicative" is a 3rd party interface to many types that were conceived before Applicative, but I can still define Applicative instances for these types
06:31:31 <yitz> @hoogle exists
06:31:32 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
06:31:32 <lambdabot> System.IO.Error isAlreadyExistsError :: IOError -> Bool
06:31:32 <lambdabot> System.IO.Error isAlreadyExistsErrorType :: IOErrorType -> Bool
06:31:39 <ski_> Ezla : `exists' doesn't really exist currently in haskell implementations .. however, the effect of it exists
06:31:46 <luite> hehe
06:31:47 <PeakerWork> Ezla: so its very useful, because my Applicative code can work on all these types, even though they were created _before_ Applicative even existed
06:31:57 <Ezla> ski_: what?
06:32:37 <jpcooper> @hoogle (Monad m) => m [a] -> (a -> m b) -> m [b]
06:32:38 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
06:32:38 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:32:38 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:32:51 <PeakerWork> Ezla: So OO creates an artificial dependence of types on their instances, even though (As Haskell proves) those can be defined separately and independently
06:32:55 <ski_> Ezla : i.e. you can't write `[exists x. (x,a -> x -> x,x -> Maybe (a,x))]', but you can write `[Foo x]' where you've defined `data Foo a = forall x. MkFoo x (a -> x -> x) (x -> Maybe (a,x))'
06:33:14 <ski_> Ezla : and that latter amounts to the same thing
06:33:37 <Ezla> PeakWork: Could you show me a line of coding of "what would be impossible" if you couldn't work with types created before Applicative existed?
06:34:07 <ski_> Ezla : however, it is easier to explain (imho) in terms of `exists' (and maybe in the future, it will be supported as a keywords, just like `forall' (which is an extension, mind))
06:34:12 <Ezla> ski answered heh
06:34:42 <Ezla> But why did you say exists doesn't exist?
06:35:00 <ski_> it doesn't exist as a *keyword*
06:35:22 <ski_> (except for in jhc, and there it's not currently allowed in the way we want here ..)
06:35:54 <Ezla> and it's not in Haskell 98 std either, but is in the GHC std?
06:36:41 <ski_> ghc and hugs implements it, and jhc,nhc too .. hbc has the same feature with not quite the same synatx
06:36:58 <ski_> you asked about implementation
06:37:01 <ski_> consider
06:37:03 <ski_>     data Foo a = forall x. MkFoo x (a -> x -> x) (x -> Maybe (a,x))
06:37:28 <ski_> what this says is the `Foo' is a type constructor, mapping types to types .. so `Foo Int' is a valid type, e.g.
06:37:41 <ski_> also, `MkFoo' is a data constructor for this type (constructor)
06:38:01 <ski_> roughly we know (for every type `a')
06:38:23 <ski_>   forall x.
06:38:31 <ski_>      MkFoo x (a -> x -> x) (x -> Maybe (a,x)) :: Foo a
06:38:43 <ski_>     if
06:38:48 <ski_> er
06:39:01 <ski_> (sorry, i goofed up, i'll retry)
06:39:05 <ski_>   forall x.
06:39:29 <ski_>        MkFoo foo bar baz :: Foo a
06:39:32 <ski_>     if
06:39:39 <ski_>      foo :: x
06:39:46 <ski_>      bar :: a -> x -> x
06:39:56 <ski_>      baz :: x -> Maybe (a,x)
06:40:14 <ski_> or, writing with more normal syntax
06:40:39 <ski_>   forall x.  MkFoo :: x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> Foo a
06:40:42 <ski_> or
06:40:47 <ski_>   MkFoo :: forall x. x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> Foo a
06:41:02 <ski_> finally remembering that this works for every type `a'
06:41:06 <ski_>   MkFoo :: forall a x. x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> Foo a
06:41:39 <daf> ski_: don't those restrictions still hold without the forall qualification?
06:41:55 <daf> (or in other words: what does the forall restriction change about the declaration?)
06:42:02 <ski_> this just explains how to read and understand the `forall x.' in the definition
06:42:30 <ski_> (sorry, some laggae on this end)
06:42:59 <PeakerWork> > (Just (+5)) <*> Just 6
06:43:00 <lambdabot>   Just 11
06:43:08 <BONUS> w00t check this out, just impelmented tries in like 10 minutes http://hpaste.org/12852
06:43:10 <BONUS> haskell owns
06:43:14 <PeakerWork> Ezla: That wouldn't work, because Maybe was defined before Applicative
06:43:23 <Badger> BONUS: we need LYAH :)
06:43:30 <BONUS> gah!!!
06:43:35 <pumpkin> BONUS: now make it into a DAWG ;)
06:43:41 <Ezla> ski: I've saved that to fully experiment with, thanks
06:43:42 <BONUS> swamped with school work right now!! :[
06:43:44 <Ezla> Peaker: neat
06:43:46 <Badger> :(
06:44:03 <BONUS> but i'll get some freizeit later this week, hope to finish the I/O chapter by then
06:44:58 <fasta> Is the char required in this expression? #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
06:45:04 <ski_> Ezla : my first point here was to explain why use `forall x. ' if we call this "existential data type"
06:45:12 <ski_> (lag appears over)
06:45:46 <ski_> Ezla : the interesting thing about this constructor is that it is polymorphic in the type `x' but `x' doesn't appear in the result type
06:45:53 <scook0> fasta: if you omit it, won't the offset of y__ be zero?
06:45:56 <ski_> compare with (the non-constructor)
06:45:58 <ski_> @type length
06:46:00 <lambdabot> forall a. [a] -> Int
06:46:40 <scook0> the point of the char field is to force the compiler to find the first *nonzero* alignment boundary
06:46:56 <scook0> which just so happens to be the type's alignment
06:47:00 <ski_> so, when using `MkFoo' you can use it with any `x' you like .. but the `x' you choose will not turn up in the result type `Foo a' .. i.e. the type `x' is hidden
06:47:47 <fasta> scook0: ok, so if y__ has type t which needs 5 bytes, then?
06:47:58 <ski_> and because you can use different `x' at different calls to `MkFoo' (though at each call, all the `x's has to be the same), you can't know beforehand which `x' to expect when you get a value of type `Foo a'
06:48:04 <ski_> now
06:48:10 <ski_> look at
06:48:11 <ski_>   MkFoo :: forall a x. x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> Foo a
06:48:13 <ski_> again
06:48:22 <ski_> this is a curried constructor
06:48:42 <scook0> fasta: it still gets placed at the start of an alignment boundary
06:48:48 <ski_> now, let's assume that the data constructor was not curried .. it's be more or less the same, but taking a tuple argument instead
06:48:51 <ski_> i.e.
06:49:00 <scook0> if it only needs byte alignment, it gets placed immediately after and the offset is 1
06:49:17 <ski_>   MkFoo' :: forall a x. (x,a -> x -> x,x -> Maybe (a,x)) -> Foo a
06:49:24 <scook0> if it needs (say) 8-byte alignment, there will be 7 bytes of padding before the y__ field
06:49:58 <fasta> scook0: ok, so the compiler needs to find the first location where the type t can fit at the beginning of any address  that is divisible by 32 on a 32 bits arch?
06:50:23 <ski_> now, one of the laws of logic tells us that `forall x. (..x..) -> Bleh' (where `Bleh' doesn't contain `x') is equivalent to `(exists x. ..x..) -> Bleh'
06:50:37 <scook0> basically, if type T has alignment N, then a valid address for a T must be some multiple of N
06:50:50 <ski_> so (assuming `exists x. ..x..' woulc be valid haskell syntax), we can now rewrite the type of our constructor as
06:51:08 <ski_>   MkFoo' :: forall a. (exists x. (x,a -> x -> x,x -> Maybe (a,x))) -> Foo a
06:51:10 <scook0> the alignment requirements for different types depends on architecture
06:51:26 <ski_> and this uncovers where the `exists' in "existential data type" were hiding
06:51:34 <scook0> e.g. some archs require 64-bit quantities to be 8-byte aligned
06:52:00 <scook0> whereas others might only require (say) 4-byte alignment even though the quantity is 8 bytes long
06:52:48 <pejo> dcoutts, ping?
06:52:59 <ski_> so, this type is saying, for any type `a' *you* (the user, the caller) want, `MkFoo' can take an argument of type `(x,a -> x -> x,x -> Maybe (a,x))' where we just need to know that there exists some type `x' (don't need to know what it actually is), and returns something of type `Foo a'
06:53:08 <ski_> a similar rewriting turns
06:53:18 <ski_>   length :: forall a. [a] -> Int
06:53:19 <ski_> into
06:53:29 <ski_>   length :: (exists a. [a]) -> Int
06:53:39 <ski_> Ezla : does this help any at all ?
06:55:36 <drdozer> hi
06:55:40 <fasta> scook0: regarding the 7 bytes of padding example. The char x__ is never needed, right? It seems that we are wasting 8 bytes then.
06:55:49 <drdozer> can I use |- as a constructor?
06:56:02 <fasta> drdozer: not in H98
06:56:21 <quicksilver> drdozer: operator constructors begin with :
06:56:30 <quicksilver> drdozer: you can use :-
06:56:40 <quicksilver> or :|-
06:56:43 <scook0> fasta: well, that struct never actually gets instantiated anywhere
06:56:51 <drdozer> I want something like: data Sequent p = [p] |- [p]
06:57:00 <drdozer> oh - quicksilver - is there a reason for that restriction?
06:57:03 <daf> ski_: how can you use the members of Foo a if you don't know what x is?
06:57:03 <scook0> it's just a trick to find out the alignment required for a particular type
06:57:08 <fasta> drdozer: consistency
06:57:38 <daf> (or: how can the compiler check anything that you do with members of Foo a, given that it can't infer what x should be?)
06:57:39 <fasta> drdozer: just use :->:
06:57:46 * Beelsebob has a sudden impulse to use the :-| constructor for something
06:58:04 <scook0> (:[])
06:58:11 <pumpkin> can I make :-) into a constructor?
06:58:20 <daf> ) is taken
06:58:22 <Beelsebob> fraid not, no -- parenthesis aren't alowed
06:58:26 <pumpkin> boo
06:58:38 <ski_> daf : well, for each value of `Foo a' you get three values, one of type `x' (unknown type), one of type `a -> x -> x' and one of type `x -> Maybe (a,x)' .. and you know all the `x' here (that you got from this particular value of `Foo a' must be the same type)
06:58:38 <drdozer> mm - can I put the unecode for |- in the source instead?
06:58:45 <Beelsebob> :- would be nice too, if only for making the Mk2 robot monkey :-[]
06:58:51 <pumpkin> lol
06:59:02 <daf> drdozer: yes
06:59:10 <quicksilver> drdozer: same reason that initial capitals are required for Constructors.
06:59:28 <quicksilver> drdozer: that is, no, it's not a strong requirement but it's convenient ot have distinguished syntactic classes.
06:59:30 <ski_> daf : so if you have `case foo of MkFoo foo bar baz -> ...' then in the `...' you can e.g. do `case baz foo of Nothing -> ...; Just (a,foo') -> ...'
06:59:31 <polveroj> daf: when you pattern match on Foo a you can get things of type x, but it's a different type variable each time.  The only thing you know about it is that two x's from the same MkFoo will be the same type.
06:59:48 <daf> that doesn't seem very useful :)
07:00:15 <drdozer> so could I use the unecode for |- as an in-fix constructor, or would I have to prefix it with : or backticks?
07:00:17 <polveroj> daf: it's mostly used to explicitly hide a type, I think
07:00:26 <polveroj> daf: so you can abstract away representation
07:00:30 <daf> ski_: oh, I see what you're getting at
07:00:41 <quicksilver> drdozer: there are no magic unicode classes for constructors, I think
07:00:47 <quicksilver> drdozer: so it would still have to being with :
07:00:53 <scook0> (:-<>) is a perfectly legal constructor
07:01:17 <quicksilver> :-< I ACCIDENTALLY THE WHOLE PARAMETER >
07:01:27 <pumpkin> noes
07:01:29 <daf> :D
07:01:40 <ski_> daf : in this case, you can think of `foo' as the current "state", and `bar' as a "push" operation while `baz' being a "pull" operation
07:01:51 <scook0> data OhNoes x y = x :-<> y
07:01:56 <PeakerWork> BONUS: did you see conal's composable Tries?
07:02:01 <drdozer> quicksilver: ok, thanks :( that's a pity.
07:04:27 <fasta> What makes something composable?
07:04:36 <fasta> Functions were meant to be composable.
07:04:58 <fasta> I.e., Conal seems to name everything he makes "composable".
07:05:32 <PeakerWork> fasta: composable means that you can take a bunch of these things, put them together, and they work as you'd expect, rather than break
07:05:45 <PeakerWork> fasta: for example, lock-based (MVar, for example) code is not composable
07:05:54 <fasta> PeakerWork: yes, I know that definition already.
07:06:33 <fasta> PeakerWork: it is composable, but just not in every way one would want it.
07:06:51 <Beelsebob> fasta: conal names everything he makes "composable" because it's one of his primary design goals
07:07:20 <PeakerWork> fasta: the composition semantics depend on implementation details that are not type-checkable and quite difficult to describe, let alone get right, so its composability is a fraud :)
07:07:35 <fasta> PeakerWork: and with MVar you get a certain semantics and there is nothing more efficient that is also "composable". There was a research paper on adding something to STM to come close, IIRC, but I haven't read it yet.
07:08:08 <fasta> PeakerWork: there have been calculi since the 70's that could type check that, AFAIK.
07:08:09 <PeakerWork> fasta: composability is a design restriction, if you give up some restrictions, its likely that you can do a better job on other things (such as performance) than with these restrictions
07:08:27 <fasta> PeakerWork: it's just that nobody uses it or took the ideas to build a real system.
07:08:54 <PeakerWork> fasta: Okay, is it composable if the complicated composition semantics are encoded into a type-checker that just disallows most compositions you might want?
07:09:09 <haskell_newbie> Hi guys, listen, I've got a small project I'm doing and I'm stuck at a problem. The this is, I have to know what's the position of a certain string inside  a list of strings, and I only know what that string is and the list. Does anyone know how to find out the position of that string in the list? Thanx in advance
07:09:13 <rafting> how do I write or in C?
07:09:37 <Zao> | or || or or
07:09:38 <quicksilver> haskell_newbie: "elemIndex"
07:09:53 <haskell_newbie> quicksilver:  thanks a lot :)
07:10:32 <fasta> PeakerWork: not really, but then you should have chosen different semantics or constructed another object with the desired semantics.
07:10:57 <PeakerWork> fasta: yeah, semantics that emphasize composability rather than implementation simplicity or performance, for example
07:11:46 <PeakerWork> rafting: in C?
07:11:54 <fasta> PeakerWork: I do see some value in simpler semantics with worse performance, but according to various papers (notable the IBM one) STM is currently fairly pointless.
07:12:02 <fasta> notably*
07:12:06 <jpcooper> @pl output x = head <$> getArgs >>= flip writeFile x
07:12:07 <lambdabot> output = (head <$> getArgs >>=) . flip writeFile
07:12:18 <jpcooper> does anyone know of a nicer way in which to do that?
07:13:00 <haskell_newbie> quicksilver: is there a way to make the result an Int and not a Maybe Int? Because I have to use that value as an index to the list of strings, that is, I'm looking for the position of a certain string inside a list of strings, and I want to change that string to be the next string after the one I found, with [String]!!index+1, and I don't think it works with the Maybe Int.
07:13:14 <PeakerWork> fasta: in what way is it pointless?
07:13:23 <PeakerWork> fasta: because it doesn't have reversible IO in it?
07:13:38 <fasta> PeakerWork: no, because it doesn't scale.
07:13:38 <PeakerWork> fasta: (I haven't used STM myself...)
07:13:51 <fasta> PeakerWork: it is too abstract for a machine to take advantage of it.
07:13:55 <ski_> haskell_newbie : you could `case' on it and decide what to do when the string wasn't found in the list
07:14:17 <rafting> fasta: ok but it works well in Clojure doesnt it?
07:14:29 <fasta> rafting: show me the benchmarks
07:14:45 <fasta> rafting: I doubt Clojure build something better than IBM.
07:14:54 <fasta> built*
07:15:01 <rafting> anyone good with C? because those guys arent very helpful. is there a hashmap in the stdlib? or a binary tree? id liek some fast key-value lookup and insert.
07:15:16 <PeakerWork> rafting: the C stdlib is pretty poor
07:15:25 <PeakerWork> rafting: why can't you write the code in Haskell? :)
07:15:38 <ski_>   case elemIndex string list of
07:15:41 <ski_>     Nothing -> when not found
07:15:44 <ski_>     Just i  -> when found
07:15:51 <ski_> haskell_newbie : ^
07:15:59 <frwmanners> rafting: I think STL is the only place to find that
07:16:10 <haskell_newbie> ski_: mmm
07:16:50 <PeakerWork> haskell_newbie: Maybe Int means that you maybe have an int, and maybe you have a nothing.. its not necessarily an int
07:17:08 <haskell_newbie> ski_: but I know the string is there for sure, I just don't know were it is.
07:17:33 <rafting> STL as in C++ STL you mean?
07:17:47 <haskell_newbie> PeakerWork: Yeah, I understand it, but I've got to have an Int, so that I can do [list of strings]!!index_of_last_string++1
07:18:04 <frwmanners> rafting: y
07:18:11 <PeakerWork> haskell_newbie: the compiler is making sure you give attention to the case where Nothing is returned, so you handle that case properly
07:18:19 <rafting> im trying to better my C-skills. In ahskell iw rote a spamfilter in 30 lines :), in C that gets me to open a file and read the words...
07:18:23 <haskell_newbie> PeakerWork: and Maybe Int doesn't work has an int (I think)
07:18:25 <PeakerWork> haskell_newbie: (a really awesome thing, lacking in most languages :-)
07:18:35 <ski_> haskell_newbie : if you're really (*really* !) sure, then you can use `fromJust' to remove the `Maybe' layer .. just don't complain if/when you get a `Nothing' and you're not sure which `fromJust' in the program triggered it :)
07:18:51 <Clockwork> I try to do the induction for the lambda function.  /wyx. y(wyx) , for n=0 it is /wyx. y(wyx) /sz.z, but how could I express n or n+1 abstract in lambda calculus?
07:19:11 <ski_> ("it" being the exception)
07:19:17 <ski_> > fromJust Nothing + 2
07:19:19 <lambdabot>   * Exception: Maybe.fromJust: Nothing
07:19:42 <frwmanners> haskell_newbie: The other option is to keep the answer within Maybe
07:20:30 <frwmanners> haskell_newbie: (\x -> [list]!!x) `fmap` (result of lookup)
07:20:42 <frwmanners> haskell_newbie: or whatever
07:22:18 <haskell_newbie> frwmanners: I think I'll use the list_of_strings!!(fromJust(elemIndex string list_of_strings))+1
07:22:27 <ksf> > let (Just x, Just y) = (Just 3, Nothing) in (x,y)
07:22:28 <lambdabot>   (* Exception: /tmp/6947841187168490097:71:40-75: Irrefutable pattern failed...
07:22:41 <ksf> do it like that and you'll get a line number.
07:22:49 <ski_> haskell_newbie : why `..+1' ?
07:22:50 <PeakerWork> @type maybe
07:22:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:22:55 <PeakerWork> haskell_newbie: you can use the "maybe" function
07:23:05 <PeakerWork> haskell_newbie: instead of writing a full-fledged pattern matcher on Nothing and Just cases
07:23:37 <PeakerWork> haskell_newbie: so you can call "maybe whatToReturnWhenNothing whatToReturnWhenJust yourMaybeValue" and then whatToReturnWhenJust gets the int itself, rather than a Maybe Int
07:23:47 <haskell_newbie> ski_ because I want to get the string that follows the one I found inside the list_of_strings
07:23:48 <ski_> haskell_newbie : just maybe .. what you want would be better written without using indices at all ?
07:25:07 <ski_> haskell_newbie : why do you want that one .. where does thie current `string' come from ? other part of program .. previous "next string" ?
07:25:12 <haskell_newbie> ski_:no, because I know the string is there for sure. Does the code I've shown doesn't work?
07:25:32 <ski_> haskell_newbie : can't tell, unless you tell what it's supposed to do
07:25:56 <rafting> but is there any decent C key/val library?
07:26:05 <rafting> a binary tree is fine
07:26:48 <haskell_newbie> ski_: ok, so I have this list of strings, and my program is using one of the strings inside of it and now I want to get the next string in line. (And in the future I'll have to get the next after this one, etc, etc). I hope this is understandable...
07:27:07 <frwmanners> haskell_newbie: f str (a:b:as) = if str == a then b else f str (b:as); f _ _ _ = {fail}
07:27:28 <ski_> haskell_newbie : (as i suspected) .. so you're basically looping through the list of strings, handling one at a time, then ?
07:27:45 <haskell_newbie> ski_: yeah thats it
07:27:57 <haskell_newbie> frwmanners:  yeah that looks like a good solution
07:28:29 <ski_> haskell_newbie : note that repeatedly indexing into a list here is needlessy inefficient
07:28:44 <ski_> what are you doing with the strings ?  computing some information to be gathered up inside a new list ?
07:28:51 <ski_> doing some `IO'-action ?
07:29:07 <ski_> summarizing some final information, combined from each string ?
07:30:08 <ski_> haskell_newbie : also, will you always start at the head of the list, or will you sometimes want to start at a specific given string (but then continue with the following ones in the list) ?
07:31:42 <haskell_newbie> ski_:the project is about simulating a population of creatures which evolve with time, and at each point of evolution their "sound" evolves by adding the next sound from a list of sounds
07:32:06 <haskell_newbie> . when the the next sound gets to the end, they start getting the sounds from the begining again
07:32:43 <ski_> so maybe it could be nice to use `cycle', then ?
07:32:52 <haskell_newbie> cycle?
07:32:53 <ski_> > cycle ["do","re","mi"]
07:32:54 <lambdabot>   ["do","re","mi","do","re","mi","do","re","mi","do","re","mi","do","re","mi"...
07:33:19 <ski_> (that way you would only have to go onward in the list of sounds)
07:33:50 <ski_> but maybe you'd later want to modify the available sounds .. in that case, this might not be that good an idea
07:34:09 <haskell_newbie> ski_: no, actually the available sounds are fixed in the start
07:34:20 <ski_> (`cycle' would not be something essential .. just a convenience)
07:34:50 <ski_>   foo x (sound:sounds) = do
07:35:03 <ski_>     bleep x sound
07:35:05 <haskell_newbie> but how do I know the next string after a certain string
07:35:09 <ski_>     ...
07:35:14 <ski_>     foo y sounds
07:35:24 <ski_> just follow the list
07:35:49 <nominolo|msr> anyone know what happened to cabal-install's option to only install dependencies?
07:35:50 <haskell_newbie> ski_: maybe this is a stupid question, but how do I follow a list?
07:36:02 <ski_> (here i was assuming you wanted some kind of `IO' .. but even if you don't you can use the same idea)
07:36:29 <smarmy> editline is driving me mad.  trying to build 6.10.1 using a libedit installed in a non-standard location, but with no end of frustration
07:36:44 <nominolo|msr> smarmy: you could try haskline
07:36:52 <smarmy> haskline?
07:36:59 <Saizan> haskeline
07:37:09 <ski_> haskell_newbie : match on `(hat:hats)', do something with `hat', then continue (recursively) with `hats' .. that will get the first hat from the rest of them et.c.
07:37:21 <ski_> @src last
07:37:22 <lambdabot> last [x]    = x
07:37:22 <lambdabot> last (_:xs) = last xs
07:37:22 <lambdabot> last []     = undefined
07:37:35 <ski_> that is following a list to find the last element
07:37:36 <haskell_newbie> ski_:ah ok
07:38:13 <Saizan> smarmy: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15619.html
07:38:25 <nominolo|msr> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15619.html
07:38:28 <nominolo|msr> oh, heh
07:38:37 <ski_> haskell_newbie : i.e., the moral is, when appropriate, work directly on the list instead of using indices into a list
07:39:38 <smarmy> nominolo,Saizan: interesting... will investigate
07:40:49 <ski_> (haskell_newbie : if you don't see how to write this recursive code, you might @hpaste it for the channel to have a peak at ..)
07:42:29 <PeakerWork> haskell_newbie: it is considered more "advanced", but perhaps its not harder to understand:  If you have some list, it is of the form:  a:b:c:...:n:[]   -- there's a function called "foldr" which replaces each : with some operator/function, and the [] with some other thing you give to it
07:42:58 <PeakerWork> haskell_newbie: so you can "follow" the list by calling foldr to replace the : and [] in the list. For example:  foldr (+) 0 [1,2,3,4] will return the sum of the list
07:43:08 <ski_> > foldr f z [a,b,c,d]
07:43:09 <lambdabot>   f a (f b (f c (f d z)))
07:43:35 <haskell_newbie> ski_: no, it's ok, I'm actually using indexes now, I'll see if that works
07:43:47 <PeakerWork> haskell_newbie: because [1,2,3,4] is actually  1:2:3:4:[]      and replacing : with + and [] with 0 becomes:  1+2+3+4+0
07:43:48 <orbitz> indeces on list?
07:43:48 <orbitz> eeep
07:44:47 <PeakerWork> haskell_newbie: following?
07:45:24 <byorgey> PeakerWork: shouldn't we explain 'map' to haskell_newbie before 'foldr'?
07:45:41 <PeakerWork> byorgey: I don't know, map is defined in terms of foldr :-)
07:45:43 <haskell_newbie> PeakerWork: not really :)
07:45:50 <PeakerWork> byorgey: (can be, that is)
07:45:52 <byorgey> PeakerWork: it *can* be.
07:46:04 <PeakerWork> haskell_newbie: which part is difficult to understand?
07:46:17 <ski_> (it sounded like what haskell_newbie wanted possibly didn't fit into `map' ..)
07:46:30 <orbitz> what does haskell_newbie want?
07:47:46 <haskell_newbie> I just posted the code I've got to http://hpaste.org/12853
07:48:15 <haskell_newbie> The variable names are in portuguese but I can translate them if you want to (to better understand the point of the code)
07:48:18 <ski_> (argh .. no newlines)
07:48:24 <haskell_newbie> :)
07:48:36 <haskell_newbie> can I use newlines without a problem?
07:48:37 <PeakerWork> argh, foreign language
07:48:42 <haskell_newbie> :)
07:48:50 <haskell_newbie> Ok, I'm gonna translate
07:48:53 <haskell_newbie> brb
07:48:55 <PeakerWork> haskell_newbie: you can, as long as you indent everything properly
07:49:48 <oklopol> good code documents itself even if the variable names are in a nonexistant language
07:50:30 <orbitz> what in sam hill...
07:52:03 <bla123> this one eats up memory like hell:
07:52:05 <bla123> main = interact $ show . foldl' (\m w -> M.insertWith (+) w 1 m) M.empty . words
07:52:21 <wolverian> you probably want strict insertWith
07:52:43 <ski_> haskell_newbie : `Natureza' takes seven arguments in the pattern but only 4 arguments in the result .. probably that's not intended
07:53:21 <haskell_newbie> ski_:no, it's not intended, I'm translating and commenting the code (and adding those missing arguments)
07:54:18 <ski_> haskell_newbie : also, your `Natureza blah bleh bloh sons_puros !! bletch' is parsed as `(Natureza blah bleh bloh sons_puros) !! bletch' .. maybe you wanted `Natureza blah bleh bloh (sons_puros !! bletch)' ?
07:54:50 <swiert> @seen dcoutts
07:54:50 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
07:54:57 <swiert> @seen dcoutts_
07:54:57 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
07:55:03 <oklopol> are there cases where lazy evaluation can somehow use exponentially more space than strictly evaluating the expression in the first place?
07:55:20 <Deewiant> bla123: try M.insertWith'
07:55:32 <haskell_newbie> ski_:yeah thanks for that I wasn't noticing it
07:55:46 <bla123> Deewiant: thanks, i already found it and am testing it
07:56:07 <oklopol> i mean at least it can use more space, if not evaluating a long expression that evaluates into, say, 0
07:56:23 <fasta> When using the ghci-haskeline program I still get ^J in my output in Emacs: :t with^J. I thought ghci-haskeline solved that problem?
07:56:26 <oklopol> (not really a haskell question)
07:57:00 <mlesniak> If I'm in the StateT String Io a "monad", is there a more elegant way to do IO than writing liftIO (my io action) before every io?
07:57:50 <fasta> mlesniak: write a template haskell program that runs over your program to detect everything of type IO and then insert a liftIO :)
07:57:57 <fasta> mlesniak: that's the long answer.
07:58:04 <fasta> mlesniak: the short answer is no.
07:58:16 <mlesniak> fasta: :D Definitely a must for a new haskell programmer ;)
07:58:18 <smarmy> mlesniak: or newtype the monad and create functions in that monad that wrap the io operations
07:58:26 <flux> can template haskell access type information?
07:58:41 <mlesniak> hmm, ok, thanks, than I have to deal with it :)
07:58:54 <fasta> flux: probably if you fight against it long enough.
07:59:02 <ski_> (mlesniak : just to be pedantic, `StateT String IO' is the monad (type) .. `StateT String IO a' is the type of some monadic action (in that monad))
07:59:03 <ksf> mlesniak, io = liftIO
07:59:05 <flux> fasta, like make your own type inference? thanks, but no thanks :)
07:59:11 <fasta> flux: it's something that should be easy.
07:59:22 <fasta> flux: but the tools are not in a state where it is easy.
07:59:24 <flux> fasta, so it's not one way street from source->TH->haskell?
07:59:25 <mlesniak> ski_: thanks, thats not pedantic, but informative :)
07:59:35 <rafting> what does it mean: cannot send to channel?
07:59:36 <mlesniak> ksf: can you explaint this a bit more?
07:59:53 <flux> it has been my understanding that retrieving type information from ghc is not possible without patching source?
08:00:00 <PeakerWork> rafting: it means you're voice-less or banned from the channel
08:00:03 <fasta> flux: there is the GHC API.
08:00:06 <PeakerWork> rafting: or not in it
08:00:07 <flux> oh, ok
08:00:11 <ksf> well, open a file, write module YourModuleName where, a newline, your imports, and then io = liftIO
08:00:20 <flux> fasta, and that provides way to retrieve type information of expressions?
08:00:20 <rafting> im logged in and gt that when posting to C
08:00:32 <mlesniak> ksf: Ah, you meant that :)
08:00:40 <haskell_newbie> translated variables and a bit of comment http://hpaste.org/12854
08:00:51 <mlesniak> ksf: just thought there was a deeper meaning hidden ;)
08:01:01 <fasta> flux: AFAIK, everything should be exported now, but I haven't used it in a significant way, so my opinion is still that it sucks, but it might have been improved :)
08:01:32 <slarba_> hmm, where has throwDyn gone from Control.Exception
08:02:08 <ksf> 6.10 has eaten a lot of exceptions and replaced them with compile time errors.
08:03:01 <Deewiant> :-D
08:03:15 <slarba_> d'oh :D
08:04:02 <Saizan> slarba_: throwDyn is simply throw now
08:04:24 <slarba_> ok
08:04:24 <daf> ksf: oh really?
08:04:40 <ski_> (haskell_newbie : 'til, next time, try to remember you can `annotate' your original paste with related pastes :)
08:07:13 <PeakerWork> haskell_newbie: When you see a repetitive pattern like (blahs next_blah) you can wrap it up somehow. For example:  data Something a = Something a [a]
08:07:23 <PeakerWork> haskell_newbie: or whatever the types of sounds and next_sound are
08:07:38 <PeakerWork> haskell_newbie: so 7 args to Nature can be 4...
08:08:13 <haskell_newbie> PeakerWork:I'm sorry, I'm not following you
08:08:52 <PeakerWork> haskell_newbie: you have "noises next_noise pure_sounds next_sound educators next_educator" -- its repeating the BLAHs next_BLAH   pattern 3 times, right?
08:09:33 <PeakerWork> haskell_newbie: where BLAH=noise, then sound, then educator
08:09:51 <haskell_newbie> PeakerWork:ok, yes
08:09:57 <haskell_newbie> PeakerWork: ok, yes
08:10:33 <PeakerWork> haskell_newbie: repetitions are usually bad in code. Its almost always better to not repeat
08:10:50 <PeakerWork> haskell_newbie: so if you see a repitition, its often a good idea to ask how you can avoid repeating yourself
08:11:04 <haskell_newbie> PeakerWork: But they are not repetitions, I mean each of those arguments are individual and unique
08:11:26 <haskell_newbie> PeakerWork: They just happen to have similar names, but are unique
08:12:18 <PeakerWork> haskell_newbie: the repetition is not exact text repeating, but a repetition of a pattern, that also merits the question of whether it can be eliminated
08:12:35 <jeffersonheard> dcoutts: do you know if Cairo is more or less thread-safe if you're working with different surfaces on each thread?  I realize it wouldn't be for OpenGL, but others...
08:12:37 <PeakerWork> haskell_newbie: and indeed you can unify the (blahs next_blah) into one thing
08:12:57 <bla123> wolverian: insertWith' dramatically decreased the mem usage. however, it is still very slow
08:13:04 <bla123> is this due to char-based io?
08:13:14 <dons> oh, not using bytestrings?
08:13:19 <bla123> no
08:13:20 <dons> or are you compiling the code?
08:13:25 <bla123> yes
08:13:25 <dons> e.g. ghc --make -O2
08:13:31 <dons> with optimisations?
08:13:42 <bla123> profiling is turned on, so i better did not specify any "-O"
08:13:55 <dons> oh. well without -O it'll be much slower.
08:14:09 <dons> but bytestrings should help a lot if you're building up some kind of dictionary
08:14:24 <dons> which version of ghc?
08:14:44 <Saizan> what's the point of profiling with optimizations disabled?
08:14:45 <bla123> it's been running for 15mins now and still choking on a 100mb file - is this within limits? (-prof, no -O)
08:14:53 <bla123> g.10.1
08:15:11 <dons> bla123: oh. 100M stop now and use bytestrings.
08:15:18 <dons> yes, there's no point profiling with optimisatoins off.
08:15:24 <dons> even the manual says that :)
08:15:35 <bla123> i thought profiling would turn off lots of optimizations nayway?
08:15:39 <dons> no.
08:15:52 <PeakerWork> haskell_newbie: start by pairing each such pair in a tuple
08:15:55 <bla123> oh, so i didn't rtfm (at least not thoroughly enough)
08:16:08 <PeakerWork> haskell_newbie: then, you can have functions that operate on such tuples
08:16:17 <bla123> thanks, i'll try bytestrings
08:16:17 <PeakerWork> haskell_newbie: maybe it would make sense to replace the tuple with a more specific type
08:16:42 <dons> it's ok. but in general, once a file is over about 100k you should use bytestrings
08:16:45 <haskell_newbie> PeakerWork:  I can't, because the project explicitly gives me that definition of Nature
08:17:02 <PeakerWork> I am trying to compile hint and its failing to find ErrUtils -- is that from base < 4 or base 4 ?
08:17:10 <PeakerWork> haskell_newbie: yucky :-)
08:17:34 <haskell_newbie> PeakerWork: :)
08:17:45 <jeffersonheard> what's the syntax for deriving instances standalone?
08:18:11 <PeakerWork> haskell_newbie: so you have a stream/list passing along with an index into it? Instead of just moving the list reference forward?
08:18:22 <PeakerWork> jeffersonheard: "standalone" as in writing your own instance?
08:18:26 <dons> bla123: here's an example of a bytestring-based word dictionary program, http://hpaste.org/12855
08:18:35 <PeakerWork> jeffersonheard: writing your own instance is the opposite of automatically "deriving" it
08:18:50 <jeffersonheard> and can I derive an instance of oh, say, Show, for a Graphics.Rendering.Cairo.Operator in a different module than Graphics.Rendering.Cairo?
08:18:57 <jeffersonheard> No, I don't mean writing my own instance
08:19:01 <dons> bla123: it just counts the most common words in a file, but does so using Data.Map and bytestrings
08:19:11 <quicksilver> with GHC's standalone deriving extension I believe you can, yes.
08:19:13 <jeffersonheard> there's a way to say "derive Show for DataType"
08:19:23 <jeffersonheard> just don't remember the syntax
08:19:34 <EvilTerran> ... that sounds like it could maim encapsulation badly
08:19:53 <dons> standalone deriving?
08:20:01 <jeffersonheard> dons: yes
08:20:09 <dons> well, it only works where you can also derive by hand.
08:20:10 <jeffersonheard> EvilTerran, I'm only doing it for debugging purposes
08:20:19 <dons> and it means you can write a library without having it depend on everything it needs to derive.
08:20:21 <haskell_newbie> PeakerWork:  yeah, I guess I could do that, but I would need to make an auxiliary function I think
08:20:23 <dblazakis> any have experience with Harpy disassembly?
08:20:23 <PeakerWork> I unregistered the "ghc" package, and it seems it doesn't exist in hackage?
08:20:29 <dons> PeakerWork: right.
08:20:37 <PeakerWork> dons: so I need to reinstall ghc?
08:20:42 <dons> you do now. yes.
08:20:45 <PeakerWork> doh :)
08:20:48 <dons> since you just broke your ghc install :)
08:20:55 <PeakerWork> heh
08:21:03 <dons> bla123: you might find some inspiration in that post.
08:21:11 <PeakerWork> ouch, even with cabal, there's some dependency hell
08:21:36 <bla123> dons: thanks a lot
08:21:41 <bla123> benchmarking it right now
08:21:44 <dblazakis> i can't find a function to disassemble a block without knowing where the instruction boundaries are -- it fails if you give it a byte count that ends in the middle of an instruction
08:21:51 <Saizan> PeakerWork: same for "base", btw :)
08:22:44 <PeakerWork> Saizan, dons: Why not put them on hackage?
08:22:56 <pejo> Does "cabal install" behave differently from "runhaskell Setup configure && runhaskell Setup build && runhaskell Setup install"?
08:23:24 <ToRA|MSR_> jeffersonheard: deriving instance Show DataType   with {-# LANGUAGE StandaloneDeriving #-}
08:23:27 <PeakerWork> haskell_newbie: that definition is A) Unnecessarily more complicated than it needs to be B) leaks memory
08:23:40 <PeakerWork> pejo: it will also try to install dependencies
08:23:53 <PeakerWork> pejo: and perhaps hide packages not explicitly mentioned as deps in the .cabal
08:23:55 <Saizan> pejo: well, first of all it downloads dependencies and installs them from hackage if they are missing
08:24:08 <jeffersonheard> ToRA|MSR_ thanks
08:24:09 <Saizan> PeakerWork: even Setup hides them
08:24:11 <bla123> dons: testfile: 100mb, 1m39, max memuse: 350 MB
08:24:12 <PeakerWork> oh
08:24:23 <bla123> dons: great
08:24:24 <PeakerWork> dcoutts: why does "cabal fetch" require the dependencies like "install"?  I just want it to be fetched...
08:24:51 <pejo> Saizan/Peaker: I'm more curious why my postInst hook doesn't seem to be called with cabal install, but does with runhaskell Setup install.
08:25:12 <Saizan> pejo: what's you Build-Type?
08:25:26 <Saizan> pejo: with Simple, the Setup.hs script is not called
08:25:42 <PeakerWork> dons: according to cabal, ghc 6.10.1 depends on an old process package (1.0.1.0) and a new process (1.0.1.1) simultaniously
08:25:51 <Saizan> pejo: you need Custom for that
08:26:16 <PeakerWork> dons: and it fails "cabal upgrade" - which is why I tried removing the "ghc" package as part of toying around to fix it
08:26:32 <Saizan> PeakerWork: have you tried verifying that with ghc-pkg?
08:26:46 <PeakerWork> Saizan: nope, not sure how
08:26:55 <pejo> Saizan, argh. Food burning. Sec.
08:27:40 <Saizan> PeakerWork: "ghc-pkg describe $pkg" gives you all the info about $pkg
08:28:08 <PeakerWork> Saizan: I'll check that out, thanks
08:28:13 <jeffersonheard> funny how you can almost tell what timezone people are in around here...   I assume pejo is either on the west coast or east coast of America
08:28:20 <jeffersonheard> or that pejo eats food at an odd time of the day
08:29:14 <Saizan> PeakerWork: that error message might also be wrong.. maybe it's just that the whole build was going to depend on both those process versions
08:29:28 <PeakerWork> Saizan: cabal-install says "dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0" -- ghc-pkg describe says that ghc-6.10.1 depends on the old process only
08:29:32 <Saizan> because of ghc that can't be recompiled/upgraded
08:29:42 <PeakerWork> Saizan: to make it depend on the new process, do I have to recompile ghc?
08:30:19 <pejo> Saizan, is that design deliberate?
08:30:22 <Saizan> PeakerWork: you'd have to change the version of the process package that's in ghc sources too
08:30:24 <ksf> @localtime pejo
08:30:26 <lambdabot> Local time for pejo is Mon Dec  8 17:30:25 2008
08:30:38 <ksf> looks like CET to me.
08:30:39 <dons> bla123: so what was the problem you're trying to solve?
08:30:47 <dons> i just guessed something to do with dictionaries
08:31:09 <bla123> dons: the problem is word counting
08:31:13 <dons> ah i see :)
08:31:29 <dons> well, make sure you understand that example, and modify to your needs
08:31:42 <Saizan> pejo: yes, since build-type: Simple means precisely that you're just using the default Setup, and so cabal-install can avoid wasting time compiling it
08:31:46 <bla123> i wanted a nice, clean, "see how nice haskell is"-example
08:31:51 <dons> the key is that by using bytestrings we use the same amount of space to store the file as the file itself. and we can take keys from it without copying
08:32:00 <bla123> but then figured out that it consumes space like hell
08:32:07 <PeakerWork> Saizan: ouch, so basically I want to have only the old process then
08:32:19 <dons> bla123: right. [Char] is a very heavy representation
08:32:37 <dons> but as you see , using bytestrings the code is pretty much identical (still use words, readFile etc)
08:32:40 <pejo> Saizan, suppose I have a cabal file that works with runhaskell Setup install. What are the minimal changes for making it work with cabal install?
08:32:41 <dons> but better space
08:32:44 <PeakerWork> can I tell cabal-install to install haskell98 with some old lib rather than a new one?
08:32:50 <bla123> dons: but it's code is easy on the eyes ;)
08:33:15 <bla123> dons: yeah, your example looks still very nice
08:33:26 <bla123> maybe i should permanently switch to bytestrings
08:33:53 <Saizan> pejo: "build-type: Custom" inside it
08:33:57 <PeakerWork> should you use byte strings when using unicode as well?  or generally just for memory buffers/etc?
08:34:05 <Saizan> pejo: if you're using a custom Setup.hs script
08:34:07 <ksf> lazy bytestrings _should_ be the default [Char].
08:34:09 <PeakerWork> I thought "String" for human-readable text, and Bytestring for "binary buffers"
08:34:51 <PeakerWork> I want to "ban" a version of a package, is that possible?
08:34:56 <ksf> ...for the same reasons streams should be the default [].
08:35:05 <pejo> Saizan, well, my Setup.hs is "main = defaultMainWithHooks simpleUserHooks { postInst = myPostInst } basically.
08:35:06 <bla123> bytestrings don't handle unicode (utf8) directly, do they?
08:35:33 <Saizan> pejo: yeah, that counts as custom
08:36:05 <pejo> Saizan, ok, thanks.
08:36:37 <bla123> dons: i tried it without -fvia-C and it didn't run slower
08:36:41 <PeakerWork> Does the "hint" package have a ghc-6.10 version?
08:37:04 <Saizan> PeakerWork: the darcs version works on it
08:37:13 <PeakerWork> Saizan: I can't find hint darcs
08:37:38 <Saizan> PeakerWork: heh, it's hard: darcs get http://www.glyc.dc.uba.ar/daniel/repos/hint
08:37:46 <PeakerWork> thanks!
08:38:10 <Saizan> see the parent directory for the repos of some dependencies
08:39:40 <PeakerWork> Saizan: I added the darcs URL to the google search results, I wonder if anyone else also sees it now
08:40:23 <Saizan> PeakerWork: which keywords?
08:40:37 <PeakerWork> Saizan: darcs get hint
08:41:09 <mdmkolbe> Is it possible to write an iterator over a stream that returns whether each point matches a regular expression that contains variable length lookaheds but only requires linear time in the expored portion of the stream?  (I already asked in #perl, but the guys here are smarter ;-))
08:41:57 <Saizan> PeakerWork: i don't :)
08:41:59 <bla123> dons: is there any benefit with using "-fvia-C" (when i don't use ffi)?
08:42:29 <PeakerWork> Saizan: mueval from mubot darcs also doesn't compile with ghc-6.10 :-(
08:42:34 <PeakerWork> Saizan: (hint compiled now)
08:42:46 <Saizan> PeakerWork: uhm, i got it to compile
08:42:47 <mdmkolbe> (If it was a string instead of a stream the answer would surely be yes/linear-in-length-of-string but that uses some prepasses over the entire string even if the regex only matches a small prefix of the string)
08:43:27 <PeakerWork> Saizan: it depends on base>=4 according to its use of Control.OldException, but when I add ">=4" to its build-depend on base, then it says: `Language.Haskell.Interpreter.GHC' does not export `setOptimizations'
08:43:56 <PeakerWork> Saizan: (and another dependency on "Optimizations(All)" in the same package)
08:43:58 <Saizan> PeakerWork: ah, i get that now
08:44:24 <Saizan> PeakerWork: hint has probably changed some exports in these days
08:44:32 <Friffon> hi guys, i have a question about pattern matching, if someone can help :p
08:44:51 <PeakerWork> @hoogle Language.Haskell.Interpreter.GHC
08:44:52 <lambdabot> package ghc-core
08:44:52 <lambdabot> package ghc-paths
08:44:58 <bla123> Frffon: just ask
08:45:08 <PeakerWork> Saizan: it seems to be from ghc-core/ghc-paths though?
08:45:52 <redditbot> Literate Haskell with Markdown and Syntax Highlighting
08:46:16 <Saizan> PeakerWork: it's among exposed-modules in hint.cabal
08:47:25 <Friffon> if i have, let's say, 'data Test = A Int | B Int String' how can i do the pattern match on 'example:: Test -> Bool' if Test is null/void (the usual [] _ = [])
08:47:42 <Saizan> PeakerWork: if i unpull "New configuration api" from hint, then mueval builds
08:48:08 <PeakerWork> Saizan: what's "uppulling" ?
08:48:12 <PeakerWork> oh, unpull
08:48:24 <Saizan> darcs unpull, removes patches
08:48:52 <Saizan> Friffon: [] is not a generic null/void value, it's the empty list value
08:48:55 <Saizan> ?src []
08:48:56 <lambdabot> data [] a = [] | a : [a]
08:49:20 <PeakerWork> Saizan: how can I find that patch to identify it for unpull ?
08:49:25 <Badger> ?src Nothing
08:49:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:49:36 <Badger> oh, yeah
08:49:46 <chrisdone> PeakerWork: what was that site with the language without code? I want to show a friend ^_^
08:49:51 * Badger whacks Badger over the head.
08:50:01 <PeakerWork> chrisdone: www.subtextual.org and also conal's tech talk
08:50:09 <chrisdone> PeakerWork: thank you
08:50:22 <Saizan> PeakerWork: i think darcs unpull -p "New configuration api" should do
08:50:30 <Saizan> ?src Maybe
08:50:30 <lambdabot> data Maybe a = Nothing | Just a
08:51:17 <Saizan> Friffon: so, you can either use example :: Maybe Test -> Bool, or add a Null constructor to your definition of Test
08:51:48 <bla123> Friffon: a parameter of type Test can never be null/void
08:52:10 <Friffon> oh ok
08:52:38 <bla123> Friffon: you don't pass references around, but values - always
08:52:46 <PeakerWork> Saizan: thanks! At first I tried that but it seemed to be asking about unrelated patches, I guess they are dependents of the patch
08:53:05 <PeakerWork> ?src Nothing -- should probably be equivalent to ?src Maybe
08:53:06 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:53:43 <chessguy_work> @set scrambler off
08:53:43 <lambdabot>   Parse error
08:53:49 <Friffon> thought it could be, what i was trying to do is if i tried to run 'example []' it would return False
08:53:59 <Saizan> PeakerWork: yeah
08:54:28 <PeakerWork> patch dependents are basically conflicting patches, I'd assume?
08:54:36 <Friffon> oh well, thanks for the clarification :)
08:54:41 <PeakerWork> (ones that would conflict if you removed their dependency)
08:54:44 <fasta> bla123: 3% of performance
08:55:10 <bla123> fasta: ok, now that's worth it ;)
08:55:15 <Saizan> i'm not that familiar with patch theory..
08:55:38 <bla123> fasta: but i read they want to drop first-class via-C-support, iirc
08:56:05 <bla123> Frffon: [] is  a list and is incompatible with Test. try Saizan s version with Maybe
08:56:23 <fasta> bla123: yes, for 3% that's not that odd. Especially, since via-c will will be slower when the new backend is done.
08:56:33 <fasta> bla123: libffi will be used for the FFI.
08:56:43 <fasta> bla123: so the C backend will be obsolete.
08:56:49 <fasta> bla123: AFAIU
08:56:50 <bla123> Friffon: then you can call example with Nothing or (Just $ A 3)
08:57:37 <bla123> fasta: but -fvia-C will allow haskell-code to be compiled for virtually any platform, is that correct?
08:57:38 <camio> conal: I've been looking at a particular class of event functions.
08:58:13 <camio> conal: Those that can be of the form f a = zip (pfst a) (f' a) where f': [(t,a]->b
08:58:17 <fasta> bla123: I only care about a few platforms, and I only know for those, sorry.
08:58:36 <fasta> bla123: in general one can assume that the number of platforms supported, grows with time.
08:58:56 <dons> bla123: -fvia-C doesn't mean portabilty.
08:59:17 <dons> it just means it spits out non-portable C to be compiled with the C compiler, which sometimes (less often these days) results in better asm
08:59:42 <camio> conal: I like that Events can have a piecewise applicative functor instance if we only use functions of that type.
08:59:53 <bla123> dons: what makes the C-code non-portable?
08:59:55 <camio> conal: do you follow?
09:00:31 <dons> well, it's tied to the current platform word size, headers etc.
09:00:42 <bla123> ok, i see
09:00:56 <Saizan> also, the asm from gcc is subsequently mangled
09:01:34 <conal> camio: what's that f' type?
09:01:36 <bla123> dons: btw, i wanted to write some word count app, because this guy wanted to see it written in different languages: http://ptrace.fefe.de/wp/ (spreading the word)
09:01:56 <bla123> dons: maybe you'd like to send him your version
09:01:59 <dons> awesome. good work!
09:02:04 <camio> conal: [(t,a)]->b
09:02:04 <dons> well, you can send my version if you like.
09:02:13 <bla123> dons: ok
09:02:17 <PeakerWork> @hoogle HsModule
09:02:18 <lambdabot> Language.Haskell.Syntax data HsModule
09:02:18 <lambdabot> Language.Haskell.Syntax HsModule :: SrcLoc -> Module -> Maybe [HsExportSpec] -> [HsImportDecl] -> [HsDecl] -> HsModule
09:02:27 <PeakerWork> does this exist in ghc 6.10.1?
09:02:33 <PeakerWork> @index Language.Haskell.Syntax
09:02:33 <camio> conal: Sorry, [(t,a)] -> [b]
09:02:33 <lambdabot> bzzt
09:02:49 <conal> camio: oh, okay. that helps.
09:02:50 <dons> ah so very similar to my bytestring one. just slower
09:03:01 <dons> and not using do notatoin
09:03:03 <conal> camio: and "piecewise applicative functor"?
09:03:06 <dons> so looks a little scarier
09:03:08 <Saizan> Language.Haskell.Syntax is from haskell-src, iirc
09:03:39 <camio> camio: For a list, [f, g, h] <*> [1,2,3] -> [f 1, g 2, h 3].
09:04:21 <wjt> > [f,g] <*> [x,y]
09:04:22 <conal> camio: like ZipList
09:04:22 <lambdabot>   Add a type signature
09:04:28 <wjt> > [f,g] <*> [x,y] :: [Expr]
09:04:30 <lambdabot>   [f x,f y,g x,g y]
09:04:36 <wjt> camio: no it's not
09:04:58 <wjt> > zipWith ($) [f,g] [x,y] :: [Expr]  -- this is
09:04:59 <camio> wjt: I'm taking some liberties with notation here.
09:05:00 <lambdabot>   [f x,g y]
09:05:02 <wjt> ok
09:05:19 <camio> conal: I suppose like ZipList.
09:05:23 <EvilTerran> ZipList [f,g,h] <*> ZipList [x,y,z] = ZipList [f x, g y, h z]
09:05:36 <wjt> ah
09:05:39 <conal> ZipList [f,g] <*> ZipList [x,y] :: ZipList Expr
09:05:47 <Deewiant> > getZipList $ ZipList [f,g] <*> ZipList [x,y] :: [Expr]
09:05:47 <conal> > ZipList [f,g] <*> ZipList [x,y] :: ZipList Expr
09:05:49 <lambdabot>       No instance for (Show (ZipList Expr))
09:05:49 <lambdabot>        arising from a use of `sho...
09:05:49 <lambdabot>   [f x,g y]
09:06:01 <conal> oh -- no Show
09:06:05 <conal> rly
09:06:11 <Badger> ya, rly
09:06:12 * EvilTerran doesn't get why there isn't an instance Show a => Show (ZipList a)
09:06:22 <camio> conal: The idea is to exploit these functions to simplify definitions that would otherwise be tuple manipulations.
09:06:48 <conal> camio: yeah?
09:06:59 <EvilTerran> heck, i'd expect "newtype ZipList a = ZipList { getZipList :: [a] } deriving Show" to be fully h98
09:07:29 <Saizan> it is
09:07:32 <dons> http://www.reddit.com/r/programming/comments/7i4s2/timber_a_purely_functional_strict_language/
09:07:36 <dons> timber is on hackage!
09:07:50 <dons> (it's a by-default-strict pure fp lang)
09:07:52 <polveroj> camio: so you can avoid recomputing tuples if (e.g.) one of the elements is constant over a segment?
09:08:33 <camio> conal: data F a = F {current :: a, next :: a}. toF :: Event a -> Event (F a). toF e = (liftA2 F id next_) e
09:08:45 <camio> Something like that.
09:08:53 <quicksilver> conal: I have found another way to express the problem with recursive snapshotWith
09:09:09 <conal> quicksilver: great!
09:09:13 <camio> Exploiting the knowledge that "id" and "next_" are of that particular form.
09:09:34 <camio> I should say "id_" since my id != id
09:10:06 <quicksilver> conal: the law we need is that "snapshot _|_ e" has the occurrences of e (just undefined values)
09:10:19 <geezusfreeek> what is snapshotWith? snapshot with a function to apply?
09:10:36 <geezusfreeek> and what is the problem with it exactly?
09:10:37 <quicksilver> conal: for example "() <$ snapshot _|_ e === () <$ e"
09:10:39 <conal> geezusfreeek: yeah.  like zipWith
09:10:59 <quicksilver> geezusfreeek: yes; the problem is that you can't define a reactive recursively on itself, which you should be able to.
09:11:12 <camio> polveroj: It is more simplification of code that manipulates events.
09:11:17 <PeakerWork> lambdabot is 1845 patches? ouch!
09:11:29 <quicksilver> conal: unfortunately, in my formulation, snapshot _|_ e is _|_. You can't observe anything about it at all.
09:11:34 <dancor> PeakerWork: wait until you get to the readline dependency! ;)
09:11:52 <dancor> forget about ghc 6.10.1
09:12:01 <camio> I guess I'm going to have to get more specific.
09:12:01 <PeakerWork> dancor: dependency hell in its finest :-)
09:12:17 <conal> quicksilver: i like that snapshot/_|_ property.
09:12:19 <geezusfreeek> oh, something like myreactive = foo $ snapshot e myreactive doesn't work and should?
09:12:32 <quicksilver> geezusfreeek: exactly.
09:12:43 <conal> quicksilver: btw, did you swap snapshot arguments relative to Reactive & Fran?  i'm considing doing so.
09:12:51 <geezusfreeek> hmm... i wonder if mine works
09:13:13 * geezusfreeek makes a note to try it later
09:13:14 <quicksilver> conal: I have (a -> b -> c) -> Behaviour a -> Event b -> Event c
09:13:27 <conal> geezusfreeek: yes, and there are some fixes.  some create space-leaks.
09:13:44 <conal> geezusfreeek: worked fine in fran, though tricky to get right iirc.
09:14:14 <geezusfreeek> alright. i'm glad i heard about it then. i want to make sure to avoid such problems in the first place
09:14:21 <conal> quicksilver: snapshotWith, with the B & E args reversed.  i like that ordering, because it ends in an event transformer.
09:14:30 <quicksilver> conal: *nod* that's why I chose it.
09:15:12 <conal> camio: be warned: snapshot's B & E args are probably going to get swapped.
09:15:22 <PeakerWork> heheh
09:15:28 <PeakerWork> that was a funny exchange :-)
09:15:45 <camio> conal: okay. Will you send a note to the list when it happens?
09:16:06 <Saizan> dancor: uh? i can install readline on ghc-6.10.1 just fine
09:16:32 <quicksilver> conal: I certainly don't see how to adjust my current formulation to have this property, though. It uses accumE to collect occurrences of both the event and the (underlying) event of the reactive.
09:16:39 <geezusfreeek> i've noticed in haskell that if you try to write functions in pointfree form when possible and rearrange arguments to make it simpler you often also simplify the areas that you actually _use_ the function as well. i don't understand why that is
09:17:02 <quicksilver> that's just not going to work. I need to collect the occurences only of the event and then lazily collect occurrences of the other, which sounds likely to lead to inevitable space leaks.
09:17:03 <dancor> Saizan: there are notorious difficulties of install libreadline and libedit simultaneously.  but yeah it is possible
09:17:19 <conal> camio: most likely.
09:18:49 <conal> quicksilver: have you looked at http://trac.haskell.org/reactive/ticket/14 ?
09:19:40 <conal> quicksilver: btw, about arg ordering, the ends-in-a-transformer principle also suggests swapping arguments to switcher.
09:19:42 <quicksilver> conal: not until just now.
09:20:15 <conal> quicksilver: i have a hard time switching switcher.  and then there's stepper.
09:20:24 <quicksilver> conal: yeah, I wouldn't change switcher.
09:20:34 <quicksilver> switchers arguments read left to right in time
09:20:46 <quicksilver> first do this `switcher` and evolve like this
09:21:04 <conal> quicksilver: exactly
09:21:14 <conal> quicksilver: s/do/be
09:21:49 <PeakerWork> stepper has all differing type arguments, no?
09:21:58 <conal> PeakerWork: yes
09:22:29 <conal> PeakerWork: so switching stepper doesn't get the same benefit as switching switcher
09:24:11 <quicksilver> conal: ah yes, the sinatra dichotomy
09:24:16 <quicksilver> conal: (do be do be do)
09:24:55 <PeakerWork> scooby do be do
09:24:56 <conal> :)
09:25:45 <lilac> getting a snapshotWith with quicksilver's laziness property and no behaviour space leak will be tricky :-/
09:26:07 <quicksilver> lilac: it certainly seems that way to me
09:26:24 <conal> to me, too.  let's find it.
09:26:44 <quicksilver> lilac: do you agree my property makes sense? do you have a weaker one you would suggest which still guarantees sensible recursions work?
09:27:30 <lilac> quicksilver: i think your property is semantically sensible (and is indeed met by my current snapshotWith implementation)
09:28:12 <lilac> although my current implementation leaks space quite badly
09:28:22 <conal> maybe something like speculative evaluation.
09:28:27 <tibbe> how can I convince myself, given a data type, that it's not an applicative functor?
09:28:36 <tibbe> http://hpaste.org/12858
09:28:46 <lilac> tibbe: if its kind is not * -> *, it's not an applicative functor :)
09:28:56 <lilac> tibbe: also, if it's covarinat
09:28:59 * ski_ idly wonders what this laziness property is ..
09:29:25 <tibbe> lilac: that's an easy one :)
09:29:39 <tibbe> lilac: my type has kind (* -> *) -> * -> *
09:29:40 <lilac> ski_: snapshotWith _|_ e == fmap _|_ e
09:29:48 <PeakerWork> lambdabot's newest darcs eval plugin depends on an old haskell-src-exts package, it seems
09:29:56 <PeakerWork> The eval plugin is in charge of "> ..." I suppose?
09:30:13 <tibbe> lilac: can I read up on that somewhere or is there an "obvious" explanation to why that is the case?
09:30:33 <lilac> tibbe: "Iteratee f" can still be an applicative
09:30:43 <tibbe> lilac: oh right
09:30:48 <tibbe> lilac: that's what I want :)
09:31:20 <lilac> tibbe: well, Applicatives are composable, so if your type is the composition of Applicatives then it is
09:31:22 <tibbe> lilac: I've been able to write some of the cases but I'm struggling with the last ones
09:31:28 <lilac> although that doesn't allow you to prove a negative
09:31:33 <Saizan> tibbe: i think "Iteratee f" is a Monad, even
09:31:42 <tibbe> Saizan: it is
09:31:50 <Saizan> then it's trivially an applicative
09:31:51 <EvilTerran> tibbe, btw, it looks to me like there's simularities between Iteratee and ContT
09:31:52 <PeakerWork> tibbe: you can easily remove kind arguments to make things instances (i.e: instance Applicative (MyType a b)) though the opposite is more difficult
09:31:57 <tibbe> Saizan: or at least m (Iteratee f) is
09:32:14 <EvilTerran> although i'm not sure how signficant they are
09:32:30 <lilac> Saizan: it depends what 'm' is
09:33:08 <EvilTerran> , src ''ContT
09:33:17 <conal> camio: did you decide to work some more on your idea and bring it up again?
09:33:20 <lilac> if "newtype M a = M (a -> Int)" then Iteratee M isn't even a functor.
09:33:24 <lunabot>  newtype ContT r m a = ContT {runContT :: ((a -> m r) -> m r)}
09:33:40 <conal> camio: the one about ziplist-like events?
09:34:07 <PeakerWork> tibbe: note that a . b is also fmap, so you could replace   fmap (fmap f) . k      with fmap (fmap (fmap f)) k     which then becomes (fmap.fmap.fmap) f k -- which then becomes   inCont (fmap.fmap.fmap)
09:34:17 <tibbe> lilac: it's unclear to me what the applicative instance would look like though
09:34:25 <PeakerWork> tibbe: if you define inCont as something that applies a function inside the Cont constructor
09:34:30 <conal> lilac: though it's probably a contravariantfunctor
09:34:32 <camio> conal: yes, I'm almost ready to present it.
09:34:49 <camio> conal: http://hpaste.org/12859
09:34:58 <lilac> conal: i don't think the "Done" constructor allows that
09:35:14 <conal> lilac: i meant your M example.
09:35:22 <lilac> conal: as do i :)
09:35:29 <Saizan> tibbe, lilac : am i missing something? http://hpaste.org/12858#a1
09:35:30 <camio> conal: At the end is an alternative definition of metronome using the "Special" applicative functor.
09:35:35 <conal> lilac: nm.  i wasn't reading carefully
09:35:38 <PeakerWork> tibbe: that is:  fmap = inCont . fmap . fmap . fmap
09:36:10 <tibbe> PeakerWork: hmm
09:36:19 <tibbe> PeakerWork: that's quite a lot to absorb at once ;)
09:36:40 <PeakerWork> tibbe: see: http://conal.net/blog/posts/semantic-editor-combinators/
09:37:03 <lilac> Saizan: Done x (Chunk "foo") >>= return == Done x Eof
09:37:26 <lilac> i think at least a Monoid instance for Stream (or equivalent) is needed
09:37:50 <Saizan> ah, no
09:37:59 <lilac> (with return = flip Done mempty)
09:38:00 <Saizan> mmh
09:38:06 <conal> camio: are you somehow managing to ensure that the time-stamps match up in zip/(<*>)?
09:38:24 <Saizan> i think oleg fixes that somehow
09:38:29 <camio> Yes, by proof obligation of the S constructor.
09:39:06 <ski_> (tibbe : `Done x _ >>= f = f x' looks suspicious ..)
09:39:13 <camio> conal: Note the flip in splitE'
09:39:27 <tibbe> ski_, I didn't write it ;)
09:39:48 <tibbe> ski_, I need to thing some about this when I get home
09:39:51 <conal> camio: obligation to prove what?
09:39:52 <tibbe> after dinner...
09:40:01 <PeakerWork> hmm.. lambdabot compiles and runs, but doesn't seem to actually connect as its told in the online.rc
09:41:12 <Raevel> PeakerWork: what does your online.rc look like?
09:41:13 <camio> conal: That the event function is of the form I mentioned before. The (pfst a) == (pfst (f a)) for all a.
09:41:49 <PeakerWork> Raevel: irc-connect freenode chat.freenode.net 6667 PeakerLambda Lambda_Robots:_100%_Loyal
09:42:02 <PeakerWork> Raevel: and then the usual lines (I changed the join list to be my channel)
09:42:15 <Raevel> and how do you start lambdabot?
09:42:16 <Saizan> lilac, ski_: http://hpaste.org/12858#a2
09:43:12 <Saizan> tibbe: however once you've a Monad instance for T, then you can get an Applicative instance by using "return" and "ap"
09:43:36 <conal> camio: oh, okay.  the event transformers are synchronous.
09:43:42 <tibbe> Saizan: right, the question is what that monad instance would look like or if there even is one
09:44:14 <tibbe> Saizan: you can write one for newtype IterateeM m a = IM (m (Iteratee m a))
09:44:31 <tibbe> instance Monad m =>  Monad (IterateeM m) where ...
09:44:38 <conal> camio: you could rename "Special" to "Synchronous", iiuc.
09:45:03 <camio> conal: Good idea. I was calling it parallel but I knew that would confuse.
09:45:38 <PeakerWork> Raevel: just "lambdabot" in the commandline
09:45:55 <redditbot> Timber: a compiler for a strict and pure functional language: now on Hackage!
09:45:55 <redditbot> FP Lunch : The new GHC API
09:46:29 <camio> conal: I was trying to figure out if there is some general typeclass that could be used here since the syncronous concept can apply to functions that don't modify a list's length.
09:46:36 <Raevel> PeakerWork: try lambdabot -e "rc path/to/online.rc"
09:46:44 <PeakerWork> Raevel: oh! thanks!
09:46:48 <camio> conal: Hoping for a morphism.
09:47:06 <camio> conal: Unfortunately, I've got to run to lunch. To be continued...
09:47:13 <conal> camio: there's a connection with arrows also.
09:47:46 <conal> camio: the synchronous property allows these transformers to be arrows.
09:47:57 <camio> neat
09:48:40 <chessguy_work> @hoogle Array
09:48:40 <lambdabot> module Data.Array
09:48:40 <lambdabot> module Foreign.Marshal.Array
09:48:40 <lambdabot> package array
09:53:49 <quicksilver> conal: we spoke about guaranteed simultaneous events before, I think
09:53:55 <tux91> what's an equivalent to python's import statement?
09:53:55 <quicksilver> they're certainly a natural notion
09:54:17 <quicksilver> although I'm not entirely sure they're within comfortable reach in the haskell type system.
09:54:20 <quicksilver> tux91: import
09:54:34 <tux91> quicksilver: i do import <module> and it doesn't work
09:54:47 <byorgey> tux91: are you using ghci?
09:54:51 <quicksilver> tux91: then you're doing it wrong.
09:54:58 <byorgey> in ghci you have to do  :m +Module
09:54:59 <quicksilver> tux91: what exactly did you do, and what happened?
09:55:35 <tux91> oh i figured it out, thanks everybody
09:56:05 <chessguy_work> heh. SELECT IS BROKEN
09:56:14 <tibbe> http://hpaste.org/12858#a3 that code doesn't type check
09:56:27 <tibbe> f = Iteratee f
09:58:10 <PeakerWork> > 5+5
09:58:11 <PeakerLambda>   L.hs:3:29: Module `Control.Arrow' does not export `pure'L.hs:3:29: Module `...
09:58:12 <lambdabot>   10
09:58:26 <PeakerWork> any idea where that comes from? The only L.hs I see has no "pure" in it?
09:58:40 <tibbe> Saizan: any idea what's wrong? http://hpaste.org/12858#a4
09:59:15 <tibbe> Saizan: it's the same problem I ran into when I tried to write that monad instance
09:59:30 <PeakerWork> There used to be a hiding(pure) clause, but I recompiled lambdabot without it
09:59:43 <Saizan> tibbe: yeah, i was thinking that it can't work, since k stream :: m (Iteratee m a), and we've nowhere to put an "m a"
10:00:07 <conal> PeakerWork: that's the error message you'd get if the hiding(pure) were still in there.
10:00:14 <tibbe> Saizan: so Iteratee is neither a monad nor an applicative functor
10:00:34 <PeakerWork> conal: Yeah, but I think I cleaned+recompiled the whole thing after making sure it wasn't there
10:00:35 <tibbe> Saizan: but m (Iteratee m) is
10:00:54 <ski_> tibbe : you need an `\stream2 -> ' somewhere after the `Cont k   -> '
10:00:56 <tibbe> Saizan: or rather the newtype of that is
10:00:58 <conal> PeakerWork: gremlins
10:01:17 <tibbe> ski_, what do you mean? :)
10:01:28 <ski_> (tibbe : i've no idea what to do with the `stream2' .. since i have no clue what you're doing ;)
10:01:42 <pejo> Saizan, I set Build-type: Custom in my .cabal and did "runhaskell Setup sdist" and simply copied dist/package-version.tar.gz to ~/.cabal/packages/...., but my postInst hook still does not fire when I do "cabal install". Any more ideas? :-)
10:01:52 <ski_> (but the types tell me so ..)
10:02:02 <tibbe> ski_, I'm trying to figure out if Iteratee is a monad, Iteratee is a stream processor over Stream
10:03:59 <tibbe> ski_, I'll have to leave now, will continue thinking about it on the way home
10:04:06 <arjanb> stream processor sounds more comonadic or arrowish than monadic
10:04:08 <PeakerWork> conal: oh! Apparently lambdabot copies its stuff to $HOME too
10:04:18 <Saizan> ski_: something like this? http://hpaste.org/12858#a5
10:04:29 <conal> PeakerWork: :p
10:04:46 <PeakerWork> yay! I have a lambdabot!
10:04:46 <tibbe> arjanb, sounds interesting! have to run unfortunately!
10:04:55 <PeakerWork> that took hours! heh
10:04:56 <conal> PeakerWork: awesome!
10:05:21 <conal> PeakerWork: how about a wiki or blog post so the rest of us will gain from your suffering?
10:05:51 <PeakerWork> I hope I can remember everything I did, I think Saizan basically had an answer to each of my difficulties in a flash though, heh
10:05:55 <Saizan> pejo: can you pass me the tarball?
10:07:04 <conal> PeakerWork: if you make it a wiki page, then someone else can come along later and fix anything you forgot.  may take a few iterations to converge on a solid recipe.
10:09:45 <ski_> Saizan : maybe :) .. seriously, i don't know what this is trying to do at all
10:11:09 <PeakerWork> what's wikisyntax for "<pre>" or don't-touch-this-code ?
10:11:35 <conal> PeakerWork: depends. which wiki/markup?
10:11:45 <PeakerWork> conal: Mediawiki (HaskellWiki uses that, right?)
10:12:16 <conal> PeakerWork: yeah.  haskell code can go in <haskell>...</haskell> (out of line) or <hask>...</hask> (in line)
10:12:34 <cjay> is there a ubuntu repo for ghc-6.10.1?
10:12:42 <PeakerWork> conal: I want to use it for shell commands
10:12:53 <conal> PeakerWork: i think there's also "{{{...}}}" and maybe "<code>...</code>"
10:13:14 <PeakerWork> conal: I didn't know <tags> were supported at all in mediawiki markup
10:13:15 <conal> PeakerWork: i use a few different markups that differ in code markup and have to keep looking.
10:13:36 <conal> PeakerWork: check out the FieldTrip page.
10:13:38 <conal> @wiki FieldTrip
10:13:39 <lambdabot> http://www.haskell.org/haskellwiki/FieldTrip
10:14:32 <PeakerWork> conal: Yeah, thanks.  <code> it is
10:14:51 <conal> PeakerWork: oh! and i used <pre>...</pre> for out-of-line
10:21:04 <PeakerWork> Can I attach a diff file to the HaskellWiki?
10:21:19 <PeakerWork> ah found it, nm
10:23:52 <lispy> Does anyone know why dependent types are called usch?
10:23:54 <lispy> such*
10:24:02 <lispy> What does dependent refer to?
10:24:06 <gwern> PeakerWork: many of the tags are supported in mw; ie, if you don't want ''foo
10:24:11 <gwern> you can do <i>foo</i>
10:24:43 <gwern> lispy: I always thought it was because functions in dependent languages could return different types 'depending' on input
10:25:02 <lispy> gwern: so, types depend on programs?
10:25:08 <PeakerWork> lispy: I think types depend on values
10:25:08 <quicksilver> lispy: that types can depend on values.
10:25:17 <lispy> on values, okay
10:25:33 <quicksilver> since values are computed by programs the other interpretation is probably OK too ;)
10:26:02 <quicksilver> one consequence of dependent types is values into type system => programs into type system => turing complete type system => your type system is a programming language.
10:26:19 <lispy> Have you gus yever seen MetaOCaml?  They layer on Coq so you can do dependent programming in OCaml...why don't we have that with Haskell?  As I understand it, the dependent typing of Coq generating Haskell code isn't really production ready
10:26:31 <quicksilver> I thought metaocaml was templating
10:26:35 <quicksilver> not dependent types?
10:26:54 <lispy> oh sorry, it's called concoqtion
10:27:09 <lispy> it's implemented in MetaOCaml but it's called Concoqtion, my bad
10:27:43 <quicksilver> I had not heard of that until today.
10:27:43 <lispy> You can give coq types anywhere you'd give a normal ocaml type
10:28:27 <gwern> quicksilver: great! so now we can have holy wars about syntax on the type level as well as below
10:28:32 <lispy> I really think in a lot of ways this would be better than the continued extensions of Haskell types.  I suspect you'd get better feedback from a proper proof assistant for one
10:28:46 <wchogg> gwern:  The holier the better.
10:28:55 <chessguy_work> anybody know of any examples of fgl (Data.Graph.Inductive)?
10:29:28 <lispy> chessguy_work: I thought there were a few trivial-ish examples on the website
10:29:34 <chessguy_work> oh, missed the link to their site
10:29:39 <pejo> lispy, why do you think it's easier to generate good error messages if you make the type system even more powerful?
10:30:01 <quicksilver> lispy: different aim, surely?
10:30:14 <quicksilver> lispy: most of the haskell extensions are aimed explicitly at *not* making the type system TC
10:30:24 <quicksilver> trying to avoid the disadvantages of a full TC type system
10:30:25 <lispy> pejo: I don't think that, but I do hope that proof assistants have better facilities for working with code that doesn't yet type check
10:30:35 <quicksilver> and seeing how useful we can get without that.
10:30:45 <Eelis> quicksilver: Coq is not TC.
10:31:15 <roconnor> Coq has no facilities for working with code that doesn't yet type check.
10:32:02 <roconnor> other than asserting magic::a -> b and sprinking that around.
10:32:07 <lispy> I've never used Coq or Eppigram but I was under the impression those sort of systems let you mark things as 'I don't know' and it helps you figure it out
10:32:36 <PeakerWork> conal: http://www.haskell.org/haskellwiki/Building_Lambdabot
10:33:06 <roconnor> Epigram's editor has holes which are places where code is needed, but they are typed holes.
10:33:12 <geezusfreeek> i'm pretty sure Coq does not, i don't know about epigram, agda does but has a TC type system
10:33:27 <roconnor> although perhaps those types for the holds may themselves have holes
10:33:50 <ski_> (that's the case for agda)
10:33:58 <geezusfreeek> i've been meaning to give epigram a more fair chance than i have so far
10:34:22 <PeakerWork> Can anyone try to follow the steps in http://www.haskell.org/haskellwiki/Building_Lambdabot  and tell me if they actually work/are complete?
10:35:10 <conal> PeakerWork: cool.  thx :)
10:35:26 <quicksilver> Eelis: Coq is not TC but that doesn't mean that coq-induced extension to metaocaml isn't.
10:35:42 <lispy> PeakerWork: these days you're supposed to be able to use cabal to build/install lambdabot
10:35:57 <gwern> hm, what is this new configuration api in hint?
10:36:11 <lispy> PeakerWork: at least I think; gwern would probably be the expert :)
10:36:18 <gwern> lispy: that's for 6.8 only tho; the instructions are targeted at people who want 6.10
10:36:32 <lispy> k, I'll stop confusing people :)
10:36:35 <PeakerWork> lispy: the ghc-6.10 support is only in the darcs
10:36:39 <luite> PeakerWork: I've built lambdabot with 6.10, but I changed those lines manually
10:36:47 <PeakerWork> lispy: and the various darcs repo's are not really in complete harmony
10:36:52 <luite> PeakerWork: using the hackage version
10:36:59 <dons> ?users
10:36:59 <lambdabot> Maximum users seen in #haskell: 568, currently: 566 (99.6%), active: 20 (3.5%)
10:37:03 <dons> ooh
10:37:03 <PeakerWork> luite: what did you do about the Eval plugin, Hint, etc?
10:37:14 <orbitz> OT, but is merging in darcs less horrid than merging in SVN?
10:37:19 <luite> PeakerWork: but I build mueval with 6.8.2, because that seemed rather hard to get working with 6.10
10:37:40 <luite> built
10:37:44 <PeakerWork> luite: ah, my instructions also include getting the mueval/hint from darcs which do work with ghc-6.10
10:37:45 <lispy> orbitz: yeah, darcs is always merging
10:37:56 <PeakerWork> luite: I don't have ghc-6.8 installed
10:37:56 <orbitz> what dose that mean lispy?
10:38:02 <orbitz> i've only seriously usd svn and clearcacse
10:38:04 <PeakerWork> luite: didn't know you could mix/link stuff from various compiler versions
10:38:48 <lispy> orbitz: every copy of a repository is a separate branch, so anytime you share patches you merge
10:39:19 <orbitz> lispy: neat
10:39:21 <luite> PeakerWork: oh haven't tried that yet, but at least fixing the lambdabot package (eval plugin etc) is quite easy. mueval is a separate executable and is not linked into lambdabot, so that can be built with another compiler
10:39:39 <orbitz> lispy: so it actually has concepts of branching, as opposed to SVN which just has a copy and doesn't understand it's really a branch?
10:39:54 <PeakerWork> luite: oh
10:40:07 <CyberGarp> I just got a new job doing large numerical simulations. Most of the code is in C++, but I'm free to use what I like. Is there any group out there doing diff-eq work in Haskell?
10:40:24 <lispy> orbitz: yeah, I guess you could say that.  To darcs a repository is just a sequence of patches.  And it has the ability to reorder those sequences give or take dependencies between patches
10:40:33 <CyberGarp> I'm not talking just Runge-Kutta, but that's a good start.
10:40:46 <orbitz> lispy: cool
10:41:07 <orbitz> is darcs getting any commercial usage tehse days?  'git' seems to be the new popular one
10:42:00 <ciscbrain> lispy: hm.. you mean darcs has rebasing, the git way? I always though git was alone there
10:42:00 <lispy> orbitz: you might want to ask in #darcs.  I think galois might be using darcs internally.  I use it sometimes at work
10:42:18 <Vulpyne> Is there any reason why this would consume a huge amount of memory? The lists/maps involved really aren't that large. http://hpaste.org/12860
10:42:28 <pejo> CyberGarp, check http://cufp.galois.com/2008/report.pdf and the section about immune response.
10:42:43 <lispy> ciscbrain: I'm not a git user so I don't really know much about rebase, but I've been told that rebase is similar to darcs' patch commutation except not as powerful
10:42:46 <CyberGarp> pejo, supercool....
10:42:48 <burp_> hi
10:43:46 <lispy> ciscbrain: git was inspired by several distributed vcs including darcs
10:44:06 <burp_> http://paste.debian.net/23148/ <- whats the problem there? Couldn't match expected type `Float' against inferred type `Integer'
10:44:24 <PeakerWork> I think "darcs" has a distinctive feature separating it from the rest -- that patches only depend on what they must from the past, whereas git/bzr/etc revisions depend on their entire history
10:44:48 <Asgaroth> burp_: You need to use realToFrac $ fac n instead of fac n
10:44:54 <PeakerWork> so its easier/safer to pull out/remove patches, or cherry pick from history in darcs, than it is in git/bzr/etc
10:45:22 <burp_> Asgaroth: thanks
10:45:36 <CyberGarp> pejo, That's a wonderful tease, is there some way to get at code/examples.
10:46:08 <lispy> orbitz: oh, allmydata is another company that uses darcs
10:46:16 <orbitz> lispy: cool
10:46:20 <orbitz> lispy: i'll have to start messing with darcs
10:46:28 <orbitz> (i need to get the biohaskell code so will start there)
10:46:36 <lispy> darcs tends to be much easier to start with than most vcs too
10:46:48 <orbitz> cool
10:46:53 <PeakerWork> I found bzr the easiest to work with.. git the fastest, and darcs seems to be the most powerful as of yet
10:46:56 <orbitz> what are some problems with darcs?
10:47:07 <PeakerWork> orbitz: it is said to have performance issues in some cases
10:47:43 <lispy> orbitz: well, darcs1 had some notorious problems, but these days people are using and loving darcs2.  Still working on some performance issues, but unless you have a very large project you won't notice the performance
10:48:19 <orbitz> cool
10:48:21 <orbitz> thanks for th einfo
10:48:31 <lispy> orbitz: something the size of the linux kernel will kill you...but, darcs itself has 7k patches all the way back to like 2002-2003 or so and the performance is fine
10:48:50 <orbitz> awesome
10:48:51 <Riastradh> So, when will the file cache happen...?
10:48:55 <orbitz> activelyd eveloped?
10:48:55 <orbitz> hi Riastradh
10:48:58 <Riastradh> Hi.
10:50:07 <TuringTest> Is anyone good at arranging hs-boot files to allow recusively defined modules?
10:50:35 <TuringTest> I have 3 modules (created via code generation) that have a nasty potential dependency.
10:50:39 <Vulpyne> Is there any reason why this would consume a huge amount of memory? The lists/maps involved really aren't that large. http://hpaste.org/12860
10:50:55 * TuringTest goes to hpaste a test case
10:51:15 <therp> TuringTest: it's not hard to generate proper hs-boot files
10:51:29 <tux91> Can somebody please explain curried functions?
10:51:38 <TuringTest> therp: For 2 modules, this is true.  I am having a problem with 3 modules.
10:51:54 <wchogg> tux91:  What's not making sense?
10:51:59 <TuringTest> A test case for 3 modules is now at http://hpaste.org/12861
10:52:11 <tux91> wchogg: everything, it's kinda confusing
10:52:12 <jsn> tux91: a curried function takes it's arguments one at a time, producing intermediate functions as it goes
10:52:22 <jsn> :t (+)
10:52:23 <lambdabot> forall a. (Num a) => a -> a -> a
10:52:25 <Deewiant> ?ty curry
10:52:26 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:52:52 <jsn> so (+) is a two argument function that returns a number
10:53:24 <jsn> or a one argument function that returns a one argument function that returns a number
10:53:36 <jsn> :t (+ 1)
10:53:38 <lambdabot> forall a. (Num a) => a -> a
10:53:39 <tux91> ok, so it says 1) add' :: Int -> (Int -> Int) 2) add' x y = x+y
10:54:01 <tux91> How can it take one argument, when the defenition states it needs 2
10:54:19 <orbitz> tux91: all functions take 1 argument, it's currying
10:54:22 <jsn> because it can return a function
10:54:23 <lispy> Riastradh: I'm not sure, I had thought it was in, but I guess it's not
10:54:46 <TuringTest> therp: Under the current namespace design, each module of A,B,C can define two objects whose type contains the other 2 modules.  And each namespace wants to import one such object from each of the other 2 modules.
10:54:49 <mrd> tux91: the definition is really:  add' = \ x -> \ y -> x + y
10:54:53 <Deewiant> tux91: you can desugar add x y = x+y to add = \x -> \y -> x+y
10:55:14 <jsn> tux91: exactly
10:55:19 <mrd> tux91: which is a function inside a function
10:55:51 <Vulpyne> Does anyone have any ideas regarding my question?
10:55:54 <tux91> is the order from right to left?
10:56:08 <orbitz> -> is right associative
10:56:15 <mrd> (\ x -> (\ y -> x + y)) 3 4
10:56:21 <orbitz> a -> b -> c == a -> (b -> c)
10:56:23 <mrd> take that example and work it through step-by-step
10:56:36 <mrd> orbitz is talking about the types
10:56:45 <tux91> mrd: what does '\' mean?
10:56:57 <Asgaroth> tux91: It indicates the start of a lambda expression
10:56:58 <mrd> tux91: that's syntax for lambda in haskell. it means: function
10:57:36 <mrd> do you have a book or a tutorial?
10:58:01 <tux91> mrd: Programming in Haskell
10:58:07 <mrd> Hutton?
10:58:21 <mrd> it should cover this stuff
10:58:46 <tux91> mrd: Hutton
10:58:51 <tux91> mrd: it covers it
11:02:11 <jberryman> weird, I came here to ask about currying too. I was surprised to find that I wasn't able to compose a function such as: f = (div 10) . (+)
11:02:19 <jberryman> having trouble understanding why
11:02:35 <Beelsebob> jberryman: (+) is binary
11:02:38 <orbitz> + takes 2 parameters
11:02:41 <Beelsebob> (.) takes two unary functions
11:02:46 <Beelsebob> @type (.)
11:02:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:03:00 <orbitz> :t uncurry
11:03:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:03:11 <Beelsebob> so... we know the second argument is of type (Int -> (Int -> Int))
11:03:13 <orbitz> you could use hat it hink?
11:03:19 <Beelsebob> that means that a == Int, and b == (Int -> Int)
11:03:31 <Beelsebob> so the first argument must have type (Int -> Int) -> c
11:03:38 <Beelsebob> which (div 10) doesn't
11:03:44 <gwern> o.0 what an interesting ghc error
11:03:46 <gwern> 'mueval: internal error: PAP object entered!
11:04:05 <orbitz> > (div 10) . (uncurry (+)) (3, 4)
11:04:06 <lambdabot>       No instance for (Num (a -> t))
11:04:06 <lambdabot>        arising from a use of `+' at <int...
11:04:31 <PeakerWork> > ((div 10) . (uncurry (+))) (3, 4)
11:04:32 <lambdabot>   1
11:04:37 <gwern> > True {- Testing -}
11:04:39 <lambdabot>   True
11:04:41 <profmakx> was this already discussed here: http://blog.fefe.de/?ts=b7c295e7 ?
11:04:46 <gwern> hm, should work
11:04:47 <profmakx> especially the haskell version
11:04:48 <Beelsebob> jberryman: what you may however want is (div 10 .)
11:04:51 <gwern> > True -- Testing
11:04:53 <lambdabot>   True
11:05:08 <gwern> nope, -- gives thepap error too
11:05:11 <Beelsebob> > ((div 10 .) . (+)) 4 5
11:05:13 <lambdabot>   1
11:05:22 <Beelsebob> > ((div 10 .) . (+)) 40 50
11:05:24 <lambdabot>   0
11:05:29 <orbitz> :t ((div 10 . ) . (+))
11:05:30 <lambdabot> forall a. (Integral a) => a -> a -> a
11:05:36 <orbitz> crazy
11:05:36 <mrd> once you start using . like that, you may have gone too far :)
11:05:46 <orbitz> haha
11:06:02 <mrd> @unpl ((div 10 .) . (+))
11:06:02 <Beelsebob> mrd: I dunno, using (f .) . g to mean "apply g to two arguments and f to the result" works for me
11:06:03 <lambdabot> (\ d g -> div 10 (d + g))
11:06:07 <hallongrottan> lol
11:06:25 <idnar> > ((div 10 .) . (+)) 1 1
11:06:26 <lambdabot>   5
11:06:31 <mrd> @unpl (((`div` 10) .) . (+))
11:06:32 <lambdabot> (\ e h -> div (e + h) 10)
11:07:30 <Beelsebob> mrd: thinking about (.) as a unary operator helps a lot
11:07:33 <mrd> while the point-free version is super cool, it only saves 3 characters
11:08:15 <mrd> i've noticed that about (.) too, but, I find it is a step too far for most code
11:08:35 <jberryman> orbitz: awesome, yeah I was playing around with $ and . for some winning combination. Is there no combinator for composing something like that?
11:09:27 <jberryman> the code I'm working on has a function f a b = blah ... and a bunch like: g a b = f2 $ f a b
11:09:57 <CyberGarp> pejo, what do you think of hmatrix?
11:10:21 <pejo> CyberGarp, I have no idea about this kind of stuff, I just happened to know about Amgen.
11:10:26 <CyberGarp> ah, okay
11:10:54 <CyberGarp> There's supposed to be a recoding of the presentation available at some point from my poking around, but it's not up yet.
11:10:56 <quicksilver> jberryman: some people define .: or similar for this.
11:11:10 <quicksilver> jberryman: if I have a bunch of coding using "a b" I often recode it as (a,b)
11:11:16 <quicksilver> jberryman: maybe the unit is a logical tuple.
11:11:19 <gwern> (hm, reddit is having real problems lately)
11:11:26 <quicksilver> (I don't use tuples very often but this is one of the times I do)
11:12:01 <pejo> CyberGarp, I think the recording equipment had left the building when CUFP was held. Most speakers didn't seem willing to be recorded.
11:14:01 <jberryman> quicksilver: interesting, thanks. maybe I will use the tuple version internally and make exportedVersion = curry internalVersion
11:14:08 * quicksilver nods
11:14:22 <jberryman> or just stop worrying about making everything point free
11:14:31 <quicksilver> that too ;)
11:14:40 <mrd> having functions take tuples as arguments vs currying is a style issue and haskell opted for the latter, but as you can see, sometimes the tuple style is better
11:15:38 <jberryman> thanks people, I have been enlightened
11:16:30 <camio> conal: Can you define what you mean by "funny" for withRestE and withNextE? Funny in that they aren't MutantBots?
11:16:56 <conal> camio: oh -- i meant to suggest you include others in the conversation.
11:17:37 <quicksilver> mrd: I don't think haskell 'opted' not to use tuples as arguments.
11:17:38 <camio> We're looking at ways of representing synchronous event transformers (I think that's the name).
11:17:47 <quicksilver> mrd: the facility is there if you want it.
11:17:56 <mrd> quicksilver: the standard library does not use it
11:18:02 <mrd> not the way SML does
11:18:08 <quicksilver> in a few places it does
11:18:15 <mrd> clearly it is a style difference
11:18:16 <quicksilver> in more others, it does not.
11:18:26 <camio> And the MutantBot representation (http://conal.net/blog/posts/functional-reactive-chatter-bots/) doesn't cover all of them. It excludes things like withNextE and withRestE which are funny.
11:18:35 <mrd> i personally prefer curried functions
11:18:55 <quicksilver> I personaly prefer using the form which suits the abstractions I'm using at the time ;)
11:19:01 <orbitz> curried gievs you both options, just tuples doesn' right?
11:19:07 <quicksilver> most of the time, that isn't tuples, because they're clunky.
11:19:07 <PeakerWork> mrd: when you say style, it seems to imply the consequences are not significant, but I think that they are
11:19:10 <mrd> it is trivial to convert either way
11:19:26 <quicksilver> occassionally tuples are actually less clunky, when you want to group arguments in a composition
11:19:29 <mrd> PeakerWork: never implied that style isn't significant
11:19:31 <quicksilver> and in that occasion I use them ;)
11:19:38 <PeakerWork> also, n-tuples suck and we'd need a converter for each n-tuple type
11:20:00 <PeakerWork> n-tuples don't have to suck though, Haskell just made them suck
11:22:29 <arw> which one would one want to use, Data.Map or Data.HashTable?
11:22:42 <arw> (for example to count the occurences of words in a text)
11:22:45 <dancor> PeakerWork: they suck because of the vertex of the lambda cube that haskell is on right?  they suck less in coq right?
11:23:03 <Lemmih> arw: Data.Map
11:23:20 <arw> Lemmih: any particular reason?
11:23:29 <Lemmih> arw: Data.HashTable sucks.
11:23:57 <Lemmih> arw: Data.Map is pretty much always a safe bet.
11:24:01 <PeakerWork> dancor: I have no idea about lambda cubes :)  They suck because 3-tuples aren't composed of smaller tuples, which complicates everything and means composable primitives cannot deal with these tuples
11:24:50 <dancor> PeakerWork: ok yeah maybe it's not related to the cube anyway.. so you would want like a decision that (a, b, c) is actually sugar for (a, (b, c))?
11:25:05 <opqdonut> why not ((a,b),c)?-)
11:25:09 <dancor> heh well
11:25:11 <PeakerWork> dancor: yeah, I'd love either option
11:25:28 <dancor> PeakerWork: write a preprocessor! :)
11:26:26 <PeakerWork> dancor: Interesting idea (I'd have to recompile the entire world with it, though, and get rid of instances of 3-tuples and above)
11:28:00 <dancor> i don't think you'd have to recompile the whole world, it could be an extension like the arrow notation sugar
11:28:32 <dancor> oh for interaction with other libraries maybe
11:28:50 <dancor> who uses 3-tuples anyway
11:29:36 <dancor> i think ppl know they are lame and you are more likely to see a typeclass or ((a,b),c) or (a,(b,c))
11:29:51 <dancor> err s/typeclass/type
11:29:52 <quicksilver> I use them occasionally in isolated bits of code
11:30:03 <quicksilver> like pipelines which happen to work on 3 values at once
11:30:09 <quicksilver> which feels like a natural place to use them :)
11:30:18 <quicksilver> very seldom though.
11:30:34 <dancor> once you write like fst3 it starts to go downhill
11:30:43 <Lemmih> ?users
11:30:44 <lambdabot> Maximum users seen in #haskell: 571, currently: 571 (100.0%), active: 28 (4.9%)
11:30:56 <opqdonut> wow :)
11:31:13 <RayNbow> will we hit the 600 before the end of 2008? :p
11:31:34 <opqdonut> are there graphs of this somehwere?
11:31:45 <dons> ?users
11:31:45 <lambdabot> Maximum users seen in #haskell: 572, currently: 572 (100.0%), active: 28 (4.9%)
11:31:46 <dons> yay
11:31:51 <dons> welcome everyone.
11:32:48 <thetallgu1> seems like RWH is swelling the ranks?
11:32:58 <dons> i think so, but can't prove it.
11:33:12 * byorgey passes out 572 bags of cheap party favors
11:33:13 <dons> it's triggered a general growth in chatter to new people, i think
11:33:15 <dancor> pull the book suddenly to establish causality
11:33:33 <dancor> it's for science
11:33:53 <dons> let's not.
11:34:24 <quicksilver> I think we should burn all our copies in a joint fit of pointless lunacy
11:34:25 <byorgey> thta might not work anyway, we'd get lots MORE people asking 'wtf happened to RWH?'
11:34:28 <quicksilver> that should get some PR
11:34:52 <gwern> aha, my PAP error manifests only with profiling turned on
11:34:54 <gwern> interesting
11:35:40 <camio> Can an arrow be implemented with arr and (&&&)?
11:37:09 <byorgey> camio: you would need >>> too, I think
11:37:40 <camio> thanks. it is already Category, just needed that last link.
11:37:45 <lilac> I have a haskell DSL which allows this:  printHtml (XML <p><a>"Foo!"</a><br/>"This is a test: "<a>"Hello"<a>"world"</a>""</a>" OK?"</p>)
11:38:42 <lilac> (with static type errors if the opening and closing tags don't match)
11:38:59 <quicksilver> that's clever.
11:39:12 <opqdonut> heh
11:39:19 <quicksilver> I bet the type errors are a bit of a sight, though.
11:39:21 <byorgey> lilac: hm, so  <, >, </, /> are combinators?
11:39:22 <lilac> it should be quite easy to add rules to only allow legal tag nestings
11:39:34 <lilac> byorgey: yep
11:39:40 <bos31337> Wow, we're creeping up on 600 people.
11:39:42 <byorgey> heh, neat =)
11:39:50 <lilac> ctx /></ tag = ctx/> "" </tag
11:40:38 <byorgey> hah, I guess you need that one too =)
11:40:52 <dons> ?users
11:40:52 <lambdabot> Maximum users seen in #haskell: 573, currently: 573 (100.0%), active: 24 (4.2%)
11:40:59 <lilac> the basic ones are <, > and </, and the rest are defined in terms of those three
11:41:01 * dons wonders if we'll reach 600
11:41:17 <dons> hey all. go get ghc and cabal-install if you're new :)
11:41:17 <Botje> of course we will
11:41:22 <bos> I bet we'll top 600 within the next 6 months.
11:41:25 <Botje> it's only a matter of time and sugared lambdas.
11:41:28 <byorgey> lilac: I'm guessing though that you're not allowed to write  (XML <p> <a> "Foo!" </a> </p>)  because of the spaces?
11:41:29 <Saizan> hah, so you can write </a><br/> but not <a> <br/> ? :)
11:41:33 <dons> bos, i wouldn't be surprised if we hit it by new years.
11:41:40 <lilac> byorgey, Saizan: right :)
11:41:42 * byorgey high-fives Saizan
11:41:49 <bos> dons: that would be exciting.
11:41:54 <Saizan> ;D
11:42:10 <lilac> man, i feel /dirty/ :)
11:42:21 <lilac> to be honest, i was expecting crazy precedence issues
11:42:31 <bos> We're bigger than #mysql, and two or three people behind #perl now.
11:42:43 <dons> woot.
11:42:54 <dons> community building efficiency win!
11:43:02 <wchogg> Why the cultural difference in irc usage?
11:43:15 <bos> Hmm, this is actually the all-time high water mark right now, AFAICT.
11:43:22 <dons> yes.
11:43:24 <lilac> byorgey: no, it was a minute ago :)
11:43:33 <lilac> s/byorgey/bos/
11:43:48 <quicksilver> lilac: why can't <p> <a> with a space work?
11:43:54 <dons> wchogg: we're working actively to improve the efficiency and centralisation of the haskell community. maximum collaboration
11:44:11 <lilac> quicksilver: haskell's grammar doesn't allow > <
11:44:14 <dons> yeah, we're #9 in size!
11:44:22 <dons> first time into the top 10 on freednoe
11:44:25 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
11:44:30 <quicksilver> lilac: ohyeah. Duh.
11:46:48 <dons> ?users
11:46:48 <lambdabot> Maximum users seen in #haskell: 576, currently: 576 (100.0%), active: 23 (4.0%)
11:47:15 <dons> 2 more to catch #perl. hehe. then the world ends.
11:47:47 <opqdonut> :))
11:48:04 <hallongrottan> oh snap
11:48:34 <stalker_> just one more :-)
11:49:43 <dons> so why today? enough built up news since rwh, and first non-holiday week ?
11:50:42 <dons> i imagine we'll be bigger than #perl soon enough, simply due to long term trends
11:51:08 <opqdonut> also, #haskell is the main community for haskell (along with the mailing lists)
11:51:21 <opqdonut> distros and other languages tend to have forums and whatnot
11:51:22 <dons> yep. we're just more efficiently coverting users into irc users
11:51:47 <dons> if we're consistently a few percent more efficient at training, we win in the long run, imo.
11:52:07 <dons> so 578 people here need to upload 578 libraries this week.
11:52:13 <dons> please.
11:52:33 <lilac> anyway: http://hpaste.org/12864
11:52:34 <ikegami__> :)
11:53:38 * lilac is not sure whether this is actually useful or just fun
11:54:02 <opqdonut> useful, i'd say
11:54:14 <opqdonut> tho the specific syntax is a bit more on the "fun" side ;)
11:57:22 <TuringTest> dons: Is it always possible to use hs-boot files to allow recursively defined modules (in the same package, of course) ?
11:58:46 <ksf> ghc-pkg: dependency stm-2.1.1.2 doesn't exist (use --force to override)... it IS installed. cabal install pulled it.
11:59:13 <ksf> ...while installing wxcore-0.10.5, that is.
12:02:32 <Saizan> ksf: mmh, --user/--global mismatch?
12:02:58 <ksf> both are --user.
12:03:09 <ksf> ...unless cabal is getting confused.
12:04:07 <ksf> ghc is able to find stm while compiling wxcore, after all.
12:04:48 <Asgaroth> @src intersperse
12:04:49 <lambdabot> intersperse _   []     = []
12:04:49 <lambdabot> intersperse _   [x]    = [x]
12:04:49 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
12:06:28 <Saizan> stm might be a bit special cased by ghc
12:06:38 <Saizan> what does ghc-pkg list stm says?
12:06:59 <ksf> /usr/lib64/ghc-6.10.1/./package.conf:
12:06:59 <ksf> /home/ksf/.ghc/x86_64-linux-6.10.1/package.conf:
12:06:59 <ksf>     stm-2.1.1.2
12:07:07 <Nafai> Cool.  Looks like I might give a Haskell presentation for our company's technical brown bag lunches some time
12:08:45 <TuringTest> Nafai: How much functional programming does the audience know or use?
12:09:48 <Nafai> TuringTest: Varying, but not a ton.  We primarily use C++ and Python here, but I'm not sure of the expose to FP of the individuals
12:11:41 <ksf> python has lambdas.
12:11:51 <ksf> to be honest, I was shocked.
12:11:59 <TuringTest> Nafai: The new C++ standard document has lambdas as well.
12:12:16 <Nafai> Right, they do use Boost for similar features
12:12:18 <jaj> ksf: python has map, filter and foldr
12:12:28 <TuringTest> Nafai: The new C++ standard document defined "concepts" which are very close to Haskell type classes
12:12:35 <apsod> jaj: reduce was taken out in 3000.
12:12:39 <wchogg> C++ is growing to be a mash of half of every other language...
12:12:52 <RayNbow> I read about C++'s lambdas...
12:12:55 <TuringTest> wchogg: Except lisp
12:13:04 <jaj> apsod: really? ...
12:13:05 <RayNbow> you have to specify which and how variables are captured :X
12:13:21 <jaj> why would they do that?
12:13:27 <ksf> is the new c++ going to have type inference?
12:13:32 <apsod> Because Guido doesn't understand functional programming.
12:13:35 <ksf> the most urgently needed feature.
12:13:39 <apsod> jaj: Also, map and filter now return iterators instead of lists.
12:13:42 <ksf> apart from a sane syntax.
12:13:47 <dancor> php is also getting lambdas lol
12:13:51 <ksf> and sane semantics.
12:14:19 <quicksilver> ksf: yes, in a very simple sense.
12:14:31 <quicksilver> ksf: you'll be able to write "auto foo = bar();"
12:14:40 <ksf> duh.
12:14:45 <quicksilver> ksf: and assuming 'bar' is declared, foo get the type of whatever bar returns.
12:15:38 <quicksilver> solves the This::That<Iterator char, char , bar> c = This::That<char,char,bar>->GetIterator(); rubbish
12:15:45 <quicksilver> but that's all it solves, as far as I know.
12:15:58 <dancor> ksf: well python has one-line lambdas only
12:16:21 <ksf> I guess I'm going to be stuck with Haskell at least until a proper total language comes out.
12:16:36 <Botje> you could do worse :)
12:17:10 <dancor> ksf: a total language is where you prove everything terminates?  isn't that usually more work than you want to do
12:17:30 <ksf> not as long as you don't have to write the proofs.
12:17:35 <wchogg> dancor:  Well, you wouldn't necessarily prove it.  You would just write all your functions to only use structural recursion.
12:17:48 <wchogg> Then it's necessarily total.
12:17:59 <byorgey> ksf: what about Agda?
12:18:22 <ksf> wasn't that the language that made c look even more like line noise?
12:18:31 <quicksilver> no, agda looks a lot like haskell
12:18:34 <wchogg> ksf:  I think you're thinking of APL
12:18:36 <byorgey> no. it looks a lot like Haskell.
12:18:59 <hallongrottan> http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php
12:18:59 <byorgey> it's a dependently-typed, total language.
12:19:00 <hallongrottan> :o
12:19:17 <dancor> we need to touch on ada for maximal confusion
12:19:38 <ksf> the colour of the links tells me I had a passing glance on it.
12:19:51 <ksf> I guess I did'nt investigate further and read papers instead.
12:20:10 <jsn> ksf: that language is ATS
12:20:34 <ksf> Sentences like "Agda is a proof assistant." also tend to scare me off.
12:20:40 <ksf> I wanna hack, not proof.
12:20:59 <wchogg> But types are related to proofs.  It shouldn't be scary.
12:21:09 <halberd> totality doesn't seem like a feature you want to actually program with, how would you create a program that's designed to stay open and wait for input?
12:21:19 <ksf> codata.
12:22:14 <RayNbow> dancor: time to write a few Language.Ada.* modules for Haskell? :p
12:22:22 <ksf> see eg. http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf
12:22:33 <ksf> @bot
12:22:34 <lunabot>  :)
12:22:34 <lambdabot> :)
12:22:36 <dancor> RayNbow: Language.SafeEnoughForNasa
12:22:52 <ksf> why isn't lambdabot giving titles of links any more?
12:23:02 <RayNbow> :D
12:23:21 <Cale> ksf: I turned the url module off because it was responsible for the last 3 lambdabot crashes.
12:23:29 <wchogg> Seems like a good reason
12:24:26 <ksf> In a nutshell, you just accept the fact that your data isn't infinite but only potentially infinite.
12:24:44 <ksf> ...which makes your program potentially terminate in finite time.
12:25:21 <ksf> cut out that second "potentially".
12:25:29 <Cale> Well, what you really want is a guarantee that you'll keep running in that case, no? So you could enforce the guarantee that there will always be another item.
12:26:57 <gwern> Cale: btw, you may want to hold off on compiling mueval with 6.10 - the latest restriction is that besides having to run with +RTS -N2 -RTS, you can't compile it with profiling...
12:27:01 <ksf> the thing you want to guarantee is that you can't just do [1..], define it as codata and recurse infinitely on it. that is, any fold on [1..] is illegal, map is legal.
12:27:08 <Cale> gwern: Yeah, I got your message.
12:27:23 <camio> ping conal
12:27:41 <gwern> Cale: the no-profiling I just discovered today
12:27:51 <Cale> ksf: Well, some right folds should be okay.
12:27:52 <gwern> (something's funny in either hint or ghc)
12:28:04 <dancor> ksf: maybe epigram is perfect since it's similar to agda 2 but not marketed as a proof assistant? :)
12:28:06 <ksf> "The rule for primitive corecursion on codata is the dual to that for primitive
12:28:06 <ksf> recursion on data. Instead of descending on the argument, we ascend on the
12:28:06 <ksf> result."
12:28:08 <Cale> gwern: Ah, okay
12:28:14 <ksf> exactly.
12:28:24 <quicksilver> Cale: the characterisation of which ones are OK is subtle though.
12:28:29 <quicksilver> Cale: map is a right fold and it's fine.
12:28:38 <Cale> quicksilver: Indeed :)
12:28:45 <quicksilver> so folds in general are not fine.
12:28:59 <dancor> PeakerWork: epigram also has dependent types so tuples should be cooler
12:29:02 <quicksilver> but tehre are a class of functions which are, which includes map (which you could define as a right fold, as it happens)
12:29:06 <ksf> I guess I wanted to say reduction.
12:29:21 <ksf> still, they might be legal if you got finite codata.
12:29:23 <quicksilver> ksf: no, what you said was fine IMO
12:29:36 <quicksilver> ksf: folds - that is, their most general type - are not permissible.
12:29:50 <quicksilver> some instances of them are, sure. that's where the careful bit comes in.
12:29:58 <Cale> Some filters would be okay, but most of them wouldn't be trivial to prove as okay.
12:30:21 <Cale> (and would rely on the properties of the stream you're giving them)
12:30:28 <conal> camio: here
12:30:48 <ksf> the trick is to avoid having to prove anything by limiting the language to what's allowed.
12:31:02 <Asgaroth> cabal question: haskell-src-exts fails to install because it requires happy>=1.17, although happy 1.18.2 is installed. Why does this happen?
12:31:08 <camio> I pinged you in haskell. Anyway, check out the definition of elapsed compared to the previous version.
12:31:15 <camio> http://hpaste.org/12866
12:31:21 <camio>  I believe this Synchronous thing is going to eliminate the need for two versions of every function.
12:31:26 <camio>  And the code is much cleaner.
12:31:45 <Cale> For instance, it's okay to filter the stream [1..] for primes, but not trivially so :)
12:31:54 <pejo> Asgaroth, happy is not in your PATH?
12:32:12 <Asgaroth> pejo: No, that might be the problem.
12:33:43 <quicksilver> Cale: is it OK to filter it for mersenne primes?
12:33:57 <Cale> hehe
12:34:07 <Asgaroth> pejo: Thanks, that was the cause.
12:34:31 * ksf is suddenly completely lost due to references to numerology.
12:35:31 <Cale> quicksilver: Apparently nobody knows.
12:35:56 <Cale> quicksilver: Also, nobody knows if there are infinitely many Mersenne numbers with prime exponents which are composite.
12:35:56 <conal> camio: what second set of functions gets eliminated?
12:36:02 <quicksilver> maybe agda can tell us?
12:36:04 <quicksilver> ;)
12:36:20 <camio> conal: The non-_ variants.
12:37:01 <conal> camio: it eliminates the value-carrying versions?
12:37:35 <camio> conal: right. If you need the values, you can use id.
12:37:54 <conal> camio: e.g.,?
12:38:44 <camio> conal: liftA2 (,) id timeE
12:40:06 <conal> camio: don't you just get double times then?
12:40:19 <conal> camio: rather than somehow recovering the values that withTime_ discards?
12:40:25 <camio> conal: Note that my use of id is the Category type.
12:40:43 <conal> camio: yep
12:40:55 <conal> oh, i see.
12:41:01 <camio> thing ::  Synchronous a (a, TimeT)
12:41:01 <camio> thing = liftA2 (,) id timeE
12:41:16 <conal> timeE is a stream transformer.  your grabbing the value info from the original stream
12:41:21 <conal> s/original/input
12:41:26 <camio> yep
12:41:30 <Cale> quicksilver: Interestingly, there's a conjecture that not only are there infinitely many Mersenne primes, but the number of Mersenne primes with exponent p less than x is asymptotically approximated by e^gamma log_2(x)
12:41:53 <conal> camio: btw, i'm flipping the args of splitE.  you won't need the flip here.
12:42:05 <camio> great
12:42:15 <Cale> I wonder what it takes to come up with a conjecture like that :)
12:42:17 <conal> camio: okay.  i see what you're up to.
12:42:20 <quicksilver> Cale: it's a plausible conjecture, but number theory is hard.
12:42:23 <quicksilver> let's go shopping?
12:42:30 <camio> conal: fun stuff, no?
12:42:41 <conal> camio: yeah
12:42:48 <Cale> Number theory is too crazy for me, yeah :)
12:43:32 <Cale> The natural numbers are strange.
12:44:09 <Cale> Maybe stranger than the reals even :)
12:44:37 <solrize> of course they're stranger than the reals.  the reals don't actually exist :)
12:44:54 <Cale> Nothing in mathematics "actually exists"
12:45:13 <earthy> um.
12:45:22 <camio> conal: I'll probably do a blog post on it tomorrow.
12:45:28 <earthy> now yer heading into faith territory, cale
12:45:55 <ksf> primes _do_ exist, though.
12:46:31 <wchogg> No, Cale is probably taking the most pragmatic view that math is just ideas.  As opposed to the more Platonist view that on some level anything you can conceive of, like math, is 'real'.  Of course, wtf does it really matter?
12:46:39 <Cale> "I would like one copy of the natural numbers, and, what the heck, I'll take GL_n(Z)." "Okay, that comes to $26.50." "Thanks!"
12:46:58 <ksf> found that out by doing my silk reeling repetition in incrementing and decrementing chunks of primes.
12:47:28 <Cale> wchogg: Right. I'm a bit of a formalist :)
12:47:46 <earthy> "I would like one filling meal, scrumptious and hot. What the heck, it can be hamburger and fries." "Okay, that comes to $6.40." "Thanks!"
12:47:57 <ksf> actually, they exist because they don't exist: the chunking stops the body from developing repetitive patters as the repetitions just don't match up.
12:50:22 <kiko_hskl> hi, i want to define in a string-> string-> bool function, that if a string contains one char then....... but how i do this?
12:50:42 <Cale> kiko_hskl: You sort of trailed off there...
12:51:01 <earthy> kiko_hskl: let me write you a function that takes two strings and returns a bool
12:51:19 <earthy> > let ssb s1 s2 = False in ssb "one" "two"
12:51:20 <lambdabot>   False
12:51:33 <earthy> now, the trick is what to do with s1 and s2
12:51:49 <kiko_hskl> what do you mean Cale?
12:51:53 <kiko_hskl> hmm whats ssb earthy?
12:52:03 <earthy> the name of the function from
12:52:15 <earthy> string to (string to bool)
12:52:38 <Cale> > let foo [] ys = False; foo (x:xs) ys = if x `elem` ys then True else foo xs ys in (foo "ke" "abracadabra", foo "ke" "abrakadabra")
12:52:40 <lambdabot>   (False,True)
12:52:42 <earthy> basically it is an arbitrarily chosen name
12:52:52 <Cale> There's a more interesting String -> String -> Bool function.
12:53:18 <earthy> there are many interesting String -> String -> Bool functions
12:53:26 <ksf> that's it. the wxhaskell makefiles are bugged.
12:53:34 <ksf> they don't pass --user through.
12:53:35 <Cale> It might even be something close to what you're looking for, but you sort of trailed off when describing the function you were after.
12:53:49 <Cale> So I don't know which function you want :)
12:54:31 <kiko_hskl> actually ive got a char->char-> bool function.. so if theres one chars in both brings they should go to the char function i hope you get what i mean
12:54:32 <earthy> plus, we wonder if this is homework. :)
12:54:46 <gwern> I find (==) to be the most interesting String -> String -> Bool function
12:55:02 <TuringTest> gwern:  (<=) is better
12:55:05 <Cale> kiko_hskl: Like  foo [x] [y] = bar x y  ?
12:55:18 <earthy> kiko_hskl: do you want to apply that function pointwise to all elements of the string?
12:55:22 <gwern> TuringTest: bah. yours is asymetrical!
12:55:30 <gwern> > "foo" <= "bar"
12:55:32 <lambdabot>   False
12:55:42 <gwern> > "boo" <= "far"
12:55:43 <TuringTest> gwern: (==) a b = (a <=b) && (b<=a)
12:55:43 <lambdabot>   True
12:55:53 <earthy> or do you want to apply it to each element of the second string once for each element of the first string?
12:55:57 <earthy> or what?
12:55:57 <Cale> (==) is a very interesting one indeed. If it was total, we could solve the halting problem.
12:56:03 <gwern> hm. lexicographic ordering, I guess
12:56:17 <yitz> Cale: foo = (not . null .) . intersect
12:56:17 <kiko_hskl> i think at a later time but first i want to define this condition
12:56:28 <gwern> Cale: I guess that would work by doing 'bottom == (function)'?
12:56:32 <earthy> which condition?
12:56:43 <Cale> yitz: foo xs ys = any (`elem` ys) xs
12:56:59 <earthy> kiko_hskl: you  have a function   f :: Char -> Char -> Bool
12:57:15 <earthy> kiko_hskl: you want a function   g :: String -> String -> Bool   that uses f
12:57:27 <yitz> Cale: also
12:57:34 <kiko_hskl> correct earthy
12:57:43 <earthy> kiko_hskl: however, you have not specified when to apply f
12:57:46 <yitz> Cale: but actually it is symmetric w.r.t. x and y
12:58:16 <gwern> oh, that sounds easy. zip the two strings with f, and then run and on them
12:58:28 <gwern> assuming we're comparing the two strings, and can't use ==
12:58:39 <kiko_hskl> yes earthy tahts what im asking.. the condition is.. if i put in both string one char they have to be checked in the f function
12:59:13 <earthy> kiko_hskl: so, one possible g would be:  g [x] [y] = f x y
12:59:18 <kiko_hskl> i thought about using head but i dont kknow if theres another way
12:59:25 <earthy> g _ _ = False
12:59:29 <gwern> > let f x y = x == y in zipWith f "foo" "foo"
12:59:31 <lambdabot>   [True,True,True]
12:59:36 <earthy> (making it total)
12:59:42 <gwern> > let f x y = x == y in and $ zipWith f "foo" "foo"
12:59:44 <lambdabot>   True
12:59:52 <gwern> hm. what was all then...
12:59:54 <gwern> @hoogle all
12:59:55 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
12:59:55 <lambdabot> Data.ByteString all :: (Word8 -> Bool) -> ByteString -> Bool
12:59:55 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
13:00:00 <gwern> ah
13:00:23 <Cale> gwern: Well, I'm thinking even with just the ability to compare all totally-defined infinite strings :)
13:00:32 <Cale> gwern: Let me think about how it would work though :)
13:01:05 <gwern> Cale: yeah, I'm having trouble seeing how it would work for just strings, unless your strings were encodings of turing machines. or something. hm
13:01:31 <Vulpyne> http://hpaste.org/12860#a1 - Does anyone have an idea of why this code fragment would consume so many resources when running? I've added strictness annotations and whittled the function down to pretty much not doing anything, but it still uses >500M  to run.
13:01:43 <Cale> gwern: Well, for one this gives you the ability to compare any two computable reals for equality.
13:01:43 <kiko_hskl> earthy? what do you mean by g _ _ = False?
13:02:44 <kiko_hskl> because if i write this, everything i put in both strings is false
13:02:54 <Vulpyne> It seems like it's generating lots of copies of the map, is the only thing I can think of. I don't know why though.
13:03:00 <gwern> Cale: wait, what is a 'computable real'? if a real is finite, then it's not a real
13:03:02 <earthy> kiko_hskl: look at this:
13:03:33 <earthy> > let f = (==); g [x] [y] = f x y; g _ _ = False in (g "a" "b", g "de" "f)
13:03:34 <lambdabot>   <no location info>:
13:03:34 <lambdabot>      lexical error in string/character literal at chara...
13:03:38 <earthy> drat.
13:03:47 <Cale> gwern: A computable real is one which, given any positive rational number, we can compute an approximation to it within that error bound.
13:03:53 <peoppenheimer> Is this the right place to ask a question about installing GHC on Leopard?
13:04:39 <Cale> gwern: For example, pi is a computable real, because we can approximate it with a computer to any number of places.
13:04:45 <ksf> you may try, but there's #ghc, too.
13:04:52 <earthy> > let { f a b = a== b; g [x] [y] = f x y; g _ _ = False } in (g "a" "a", g "de" "f")
13:04:53 <lambdabot>   (True,False)
13:04:58 <peoppenheimer> ah, thanks
13:05:01 <Cale> gwern: Since there are only countably many programs, most reals are not computable.
13:05:21 <gwern> Cale: right, I knew that. but then how does == on Strings give us all computable reals?
13:05:23 <kiko_hskl> okay, at first, why are there two bool outputs?
13:05:49 <kiko_hskl> ah its ok, now i understand
13:05:53 <kiko_hskl> its a test
13:05:53 <Cale> gwern: It gives us a way to compare them. Just build their decimal expansions as strings, say, and then compare for equality.
13:06:00 <Cale> (assuming that (==) is total)
13:06:20 <Cale> (which it is actually not)
13:06:32 <gwern> Cale: hm. does this need finite strings or are you assiming infinite?
13:06:36 <Cale> Infinite :)
13:07:18 <gwern> ah, I see. inifinte strings can't handle the noncomputable reals since they're exactly as vulnerable to diagonalization
13:07:41 <gwern> although come to think of it, if == is total on strings, then it ought to be on other things as well, like Integer
13:07:48 <Cale> right.
13:08:00 <Cale> and Bool
13:08:57 <yitz> == total on Bool? doesn't sound too hard
13:09:03 <leadnose> :D
13:09:07 <Cale> yitz: On [Bool]
13:09:19 <yitz> ok
13:09:28 <lispy> I just realized darcs was prototyped in C++ and written in Haskell.  Does that seem a little backwards? :)
13:09:31 <lispy> http://osdir.com/Article2571.phtml
13:10:14 <Cale> So the trick is to come up with a way to express the halting problem in terms of equality on [Bool], perhaps :)
13:10:27 <Cale> I have a feeling that it can be done ;)
13:10:37 <kiko_hskl> earthy, it works
13:10:45 <yitz> What does "total" mean, considering that every type contains bottom?
13:10:54 <quicksilver> Cale: have you seen the trick with decidable equality on infinite [Bool] ?
13:10:59 <kiko_hskl> thanks^^ but i dont understand that, why x and y have to be in brackets
13:11:22 <Vulpyne> It's matching the one item out of a list with a single item.
13:11:23 <olsner> lispy: bah, darcs is only trying to piggy-back on haskell's success!
13:11:29 <Vulpyne> [x] same as (x:[]) if that helps.
13:11:41 <Cale> yitz: It means that for any two totally-defined lists (ones which don't contain bottoms), it produces a non-bottom result
13:11:47 <kiko_hskl> ah!
13:11:58 <kiko_hskl> nice one that was the thing i was asking hehe
13:12:01 <Cale> quicksilver: On functions of [Bool]
13:12:24 <yitz> Cale so that's a specialized definition for []. It doesn't even work for [[]].
13:12:31 <quicksilver> Cale: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
13:12:37 <Cale> quicksilver: Right.
13:12:41 <Vulpyne> http://hpaste.org/12860#a1 - Does anyone have an idea of why this code fragment would consume so many resources when running? I've added strictness annotations and whittled the function down to pretty much not doing anything, but it still uses >500M  to run.
13:12:49 <quicksilver> Cale: blew my mind first time I read it.
13:12:53 <quicksilver> Cale: still does, actually ;)
13:13:02 <Cale> quicksilver: That's for comparing functions  (Eq a) => [Bool] -> a
13:13:07 <Cale> which happen to be total
13:13:53 * quicksilver nods
13:14:23 <kiko_hskl> is there a website where are things like [s1] are described?
13:14:27 <kiko_hskl> on strings
13:14:50 <Cale> kiko_hskl: That's just a case of the list syntax where you have just one element
13:14:53 <Cale> > [1,2,3]
13:14:55 <lambdabot>   [1,2,3]
13:14:55 <roconnor> Vulpyne: strictness annotations only puts data into (weak) head norma form
13:14:59 <Cale> > length [1,2,3]
13:15:00 <lambdabot>   3
13:15:01 <roconnor> normal
13:15:02 <Cale> > length [1]
13:15:03 <lambdabot>   1
13:15:07 <Cale> > length "a"
13:15:09 <lambdabot>   1
13:15:13 <Cale> > length ['a']
13:15:14 <lambdabot>   1
13:16:04 <Cale> kiko_hskl: Unless you're referring to the type-level version of that, in which case it would mean the type of lists whose elements have type s1
13:16:27 <quicksilver> Vulpyne: how big is the CDR files? what is the format like?
13:16:59 <Vulpyne> quicksilver: 1.9m records, it's basically a CSV.
13:17:32 <Vulpyne> I parse it into records - and I print out the length of the generated lists before I get into the part that consumes all the CPU/memory (genStats) and the loading of the lists isn't what's causing the problem.
13:17:49 <Vulpyne> At least as far as I can tell. I've also annotated just about everything with strictness, and it didn't make much of a difference.
13:18:02 <quicksilver> it seems likely that you don't actually consume much memory until you look at the generated stuff.
13:18:10 <Vulpyne> BTW, thank you for looking at it. This has been driving me crazy for a couple hours now.
13:18:28 <quicksilver> having said that, your code (in the recent annotation) is basically just calling 'length' on cdrs
13:18:42 <quicksilver> I can't see why that would have different space or time behaviour than just calling length on cdrs directly.
13:19:11 <Vulpyne> Well, if I change genStats to just return psm, it finishes instantly.
13:19:33 <Vulpyne> I don't really have deep knowledge of this, but what it seems is like the foldl is replicating the map many times.
13:19:37 <Vulpyne> Even though it doesn't even change.
13:19:52 <quicksilver> :t foldl'
13:19:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:20:24 <Vulpyne> I've also tried using the state monad, and it just ran out of stack. The foldl' version eventually completes, it just uses gigantic amounts of memory and CPU and takes about 2min.
13:20:53 <quicksilver> your hacked code completely ignores the cdrs, doesn't it?
13:21:07 <quicksilver> test that by replacing the cdrs with a fixed list of the same length :)
13:21:11 <Vulpyne> It doesn't do anything with them, but the foldl' will iterate once per cdr.
13:21:15 <quicksilver> > length [1..2000000]
13:21:17 <lambdabot>   2000000
13:21:31 <Vulpyne> I can try that.
13:21:48 <quicksilver> maybe you're just seeing the cost of doing a full "seq" on a Data.Map two million times.
13:22:19 <quicksilver> 90 seconds, 2 million iters, that's 45 microseconds.
13:22:24 <bla123> quicksilver: why is a full seq so expensive?
13:22:35 <quicksilver> 45 microseconds to "seq" a map with 200 elements is not that surprising to me.
13:22:44 <quicksilver> bla123: well, it's a full traverse of the tree structure.
13:22:54 <quicksilver> or is it?
13:22:55 <bla123> ok
13:22:55 <quicksilver> hmm.
13:23:18 <quicksilver> not, it's not. it should be observably in WHNF because it hsn't changed.
13:23:26 <bla123> must be - i also tried it and it was extremely slow, but the program consumed only very little ram
13:23:38 <athos> hi
13:24:20 <bla123> quicksilver: if a full traversal is not needed and only very few has changed (only one update for example), shouldn't it be very cheap then?
13:24:40 <Vulpyne> Hmmm, running that on a static list of CDRs generated with replicate finished quickly.
13:24:49 <Vulpyne> That's weird, I wouldn't have expected that to be the problem.
13:24:59 <Vulpyne> The parsing of the file doesn't really do anything except B.split and lines.
13:25:11 <quicksilver> Vulpyne: how large is the file, in bytes?
13:25:20 <quicksilver> Vulpyne: and show us your parsing code.
13:25:26 <quicksilver> are you using strict or lazy bytestrings?
13:25:32 <Vulpyne> Tried both - strict at the moment.
13:25:42 <Vulpyne> The file is about 80mb.
13:25:48 <Vulpyne> I'll just put the whole thing into the hpaste.
13:25:49 <Vulpyne> If it'll fit.
13:26:49 <Vulpyne> http://hpaste.org/12860#a2
13:27:14 <haskell_newbie> Hi guys is there a way to concatenate to tuples like this: (a,[c,d]) + (e,[g,h]) + (i,[j,k])= (i,[c,d,g,h,j,k]) ?
13:27:22 <haskell_newbie> I mean two tuples
13:28:06 <sinelaw> what does haskell have a probability library using the mathematical primitives?
13:28:33 <quicksilver> Vulpyne: well, your cost is definitely the bytestring parsing then.
13:28:41 <Vulpyne> haskell_newbie: You'd probably have to write a function for it, but would be pretty simple.
13:28:49 <quicksilver> Vulpyne: which GHC version / bytestring version?
13:28:56 <Vulpyne> quicksilver: So it seems - that's weird though, as you can see it's not doing anything special.
13:29:12 <sinelaw> i mean, including random variables as functions, expectation as a function on a function, etc..
13:29:12 <haskell_newbie> Vulpyne: how would that function be? in pseudo-code I mean.
13:29:32 <nybyn> is there any documentation for configuring/using lambdabot? i've edited the ~/.cabal/share/lambdabot-4.2.2/online.rc file, how do i tell lambdabot to connect?
13:29:44 <quicksilver> Vulpyne: well to be fair parsing 22 thousand records per second is not *awful*
13:30:08 <quicksilver> Vulpyne: see how long excel takes to open a document with 2 million rows.
13:30:12 <Vulpyne> 6.11.20081117 version of GHC (was having problems with the normal version.)
13:30:25 <Vulpyne> Well, should it really use 500mb to load a 80mb file?
13:30:37 <quicksilver> yes, probably
13:30:51 <Vulpyne> If I wrote it in Python it wouldn't.
13:30:52 <quicksilver> B.filter is making fresh bytestrings for the fixDst function
13:30:58 <quicksilver> I shouldn't think so, no
13:31:06 <quicksilver> python's attitude is not to create lots of small cheap heap objects
13:31:10 <bla123> haskell_newbie: did you mean: (a,[c,d]) + (e,[g,h]) = (e,[c,d,g,h])?
13:31:17 <quicksilver> GHC's attitude is to do that precisely because allocation and GC are cheap
13:31:23 <quicksilver> (note that only 12% of your time is GC time)
13:31:31 <haskell_newbie> bla123: yes, that's it
13:31:47 <smarmy> f (a,as) (b,bs) = (b,as++bs)
13:31:57 <quicksilver> Vulpyne: did you try -O2?
13:32:09 <Cale> I wonder if there is a performance gap imposed by the constraints on total functional programming languages. That is, are there problems for which the fastest algorithm using only structural recursion is asymptotially slower than the fastest algorithm using general recursion?
13:32:29 <haskell_newbie> smarmy : that was easy :) I feel stupid for not thinking about it :p
13:32:34 <sjanssen> Vulpyne: does your program use all 500MB at one time, or does it just happen to do 500MB's worth of allocations?
13:32:34 <Vulpyne> Tried with -O2 and -O3.
13:32:37 <quicksilver> Vulpyne: I will be interested if you do recode it in python if it will beat 22k recs/sec. It would suprise me.
13:32:41 <quicksilver> sjanssen: the latter.
13:32:48 <sjanssen> oh, then why worry?
13:32:53 <Vulpyne> Looking at it in top, it's actually using 500mb.
13:32:54 <quicksilver> sjanssen: its peak usage was 180M
13:33:14 <quicksilver> well memory usage is heap * 3, roughly
13:33:19 <quicksilver> copying collector.
13:33:41 <Vulpyne> Well, if nothing else, I guess it's good to know I wasn't doing anything stupid with my Haskell code. :)
13:33:43 <sjanssen> Vulpyne: does your program need to keep the entire file in memory at once?
13:33:48 <Vulpyne> No.
13:33:48 <quicksilver> Vulpyne: if you want it to use less memory you can impose a heap limit with RTS options
13:33:56 <quicksilver> that will make it GC more often, which will keep memory usage lower.
13:34:02 <sjanssen> if not, it seems you might be able to do better than 180MB
13:34:05 <Vulpyne> I guess right now it's forced to load the whole file.
13:34:05 <quicksilver> default is to run with an unlimited heap.
13:34:29 <Vulpyne> But I tried it without the strictness annonations as well (where I would have expected it to basically load a record, parse it, update the stat, and then that record would be GC'd.)
13:34:39 <quicksilver> Vulpyne: I'm pretty sure one of the bytestring experts could squeeze some more performance out of it
13:34:50 <quicksilver> creating lots of very small bytestrings is not optimal.
13:34:53 <sjanssen> Vulpyne: where is your code?
13:35:07 <quicksilver> sjanssen: http://hpaste.org/12860#a2
13:35:07 * dmwit has processed an 800MB file in 10MB of space (as reported by top)
13:35:08 <Vulpyne> quicksilver: Since I print out the lengths of the stuff, and all the fields are annotated with strictness, wouldn't you expect that the loading/parsing part would be done after it was printed?
13:35:15 <dmwit> But then, I was keeping *very* simple statistics about the file.
13:35:17 <quicksilver> Vulpyne: no.
13:35:22 <Vulpyne> sj: http://hpaste.org/12860#a2
13:35:32 <quicksilver> Vulpyne: the actual lists are still lazy
13:35:39 <quicksilver> Vulpyne: only the things stored inside them are not.
13:35:40 <dmwit> If you're building a list describing the file, that kind of low memory usage isn't too likely. =P
13:35:49 <sjanssen> Vulpyne: are you compiling with -funbox-strict-fields?
13:35:56 <Vulpyne> I haven't tried that, but I can.
13:35:57 <quicksilver> in fact, by printing out the list lengths you are forcing the whole spine
13:36:08 <quicksilver> ...whilst the values remain unforced
13:36:13 <quicksilver> so taht's forcing the whole file into memory
13:36:16 <sjanssen> Vulpyne: that should be a small boost in both space and time use
13:36:22 <quicksilver> it should use less memory if you don't print the list lengths.
13:36:55 * roconnor finds making programs less strict is a better way to deal with space leaks
13:37:02 <sjanssen> Vulpyne: B.take 1 fbs == B.pack "1" -- is better written with B.isPrefixOf
13:37:04 <roconnor> such as not computing lengths
13:37:10 <ksf> Vulpyne, did you try to use stream-fusion?
13:37:12 <sjanssen> similarly with the line imediately below it
13:37:14 <dmwit> Oh, yeah, you're building a list.
13:37:19 <sjanssen> stream fusion is overrated
13:37:26 <gwern> roconnor: isn't that a haskell saying - the best way to optimize a program is to make it lazier or stricter?
13:37:36 <Vulpyne> I haven't tried stream-fusion.
13:37:39 <roconnor> @quote lazier
13:37:39 <lambdabot> No quotes match. My pet ferret can type better than you!
13:37:44 <roconnor> gwern: nope
13:37:45 <roconnor> :P
13:38:01 <Vulpyne> Honestly, the amount of CPU/memory it was taking seemed excessively high, not just a little bit high. Maybe my expectations were unrealistic.
13:38:04 <roconnor> @quote gwern the best way to optimize a program is to make it lazier or stricter.
13:38:05 <lambdabot> No quotes match. Do you think like you type?
13:38:12 <roconnor> @remember gwern the best way to optimize a program is to make it lazier or stricter.
13:38:12 <lambdabot> It is forever etched in my memory.
13:38:20 <roconnor> gwern: it is now
13:38:23 <Vulpyne> I also had to increase the stack size just to get it to run.
13:38:42 <sjanssen> Vulpyne: ah, do you know which function might be using too much stack?
13:38:42 <gwern> roconnor: well, that's one solution...
13:38:46 <quicksilver> Vulpyne: stop printing the length of cdrs should get the peak memory down a bit.
13:38:54 <roconnor> It's nice that "print $ sequence (replicate 10000000 (Just 1)) >> return ()" blows my stack
13:38:58 <olsner> I think you just have to move the strictness and laziness into different places :)
13:39:07 <dmwit> Vulpyne: Well, your function isn't reading the file lazily.
13:39:24 <roconnor> It's nicer that "print ( (`runContT` return) $ sequence (replicate 10000000 (return 1)) >> return () :: Maybe ())" allocates all my memory and then blows my stack
13:39:30 <roconnor> :P
13:39:32 <dmwit> Vulpyne: i.e. you have a nice producer, but not a nice consumer.
13:39:40 <dmwit> Vulpyne: (If I'm reading it right.)
13:40:20 <Vulpyne> Trying it now - up to 250mb memory used with -funbox-strict-fields on.
13:40:25 <Vulpyne> And not printing out the sizes.
13:40:42 <quicksilver> Vulpyne: the code you showed us is strict bytestrings, too
13:40:45 <dmwit> foldl' is also not consumer-friendly
13:41:06 <quicksilver> dmwit: but, it's used strictly here anyway
13:41:08 <sjanssen> dmwit: hmm?  Sure it is
13:41:09 <quicksilver> (isn't it?)
13:41:14 <dmwit> um
13:41:16 * dmwit looks again
13:41:19 <Vulpyne> The code I pasted is actually the product of quite a few iterations of trial-and-error testing, I started out without the strictness annotations and lazy bytestrings.
13:41:25 <sjanssen> it doesn't fuse, but it demands cons cells one at a time
13:41:29 <Vulpyne> And it was behaving in a similar fashion.
13:41:30 <dmwit> > foldl f [x,y,z]
13:41:31 <lambdabot>       Overlapping instances for Show ([b] -> [Expr])
13:41:31 <lambdabot>        arising from a us...
13:41:34 <dmwit> > foldl f [x,y,z] :: Expr
13:41:35 <lambdabot>   Couldn't match expected type `Expr'
13:41:38 <Deewiant> foldl1
13:41:41 <dmwit> thanks
13:41:48 <dmwit> > foldl f w [x,y,z] :: Expr
13:41:49 <lambdabot>   f (f (f w x) y) z
13:42:06 <dmwit> Those thunks are going to be nasty on any reasonably sized file...
13:42:13 <sjanssen> dmwit: foldl'
13:42:19 <Vulpyne> How can I make it better? :)
13:42:30 <quicksilver> Vulpyne: does it still blow the stack if you remove that option?
13:42:36 <quicksilver> because if so, that's a problem.
13:42:42 <quicksilver> code which uses huge stacks is very slow
13:42:54 <quicksilver> you should definitely fix that stack overflow
13:43:02 <dmwit> Oy, I'm an idiot.
13:43:11 <dmwit> sjanssen, quicksilver: Of course you're right.
13:44:29 <Vulpyne> quicksilver: Trying it.
13:47:29 <Vulpyne> quicksilver: Yeah, still a stack overflow when trying to display the resulting list of stats.
13:47:52 <Vulpyne> However, I did uncomment some of the other function bodies so there would be stats to display.
13:49:06 <sjanssen> what is that law about observation effecting the thing you're observing?
13:49:25 <Botje> a watched electron never waves?
13:49:25 <Vulpyne> Quantum uncertainty principle? :)
13:49:28 <quicksilver> that's odd.
13:49:40 <quicksilver> "mapM_ print $ biglist" should not stack overflow.
13:49:49 <ksf> Heisenberg's demon.
13:49:53 <Vulpyne> Well, it's trying to print the map.
13:49:59 <Vulpyne> Well, iterating each item in the map.
13:50:08 <olsner> well, unless the list contains big thunks
13:50:24 <olsner> Well, a lot of "well" there
13:50:37 <opqdonut> well well what's all this then?
13:51:03 <quicksilver> I find it very strange.
13:51:14 <ksf> actually, he himself called named it the "blur relation"
13:51:18 <ksf> or fuziness.
13:51:32 <Vulpyne> ./cdrstats +RTS -s ++  4 ++ Stack space overflow: current size 8388608 bytes.\n
13:51:44 <Vulpyne> Lines seperated with ++ for brevity. What's weird is there's only 4 items in the map it tries to print.
13:51:47 <Vulpyne> And it still dies.
13:52:07 <Botje> your list contains big thunks, then
13:52:12 <quicksilver> must be a buried thunk somewhere
13:52:21 <Cale> can we see the program?
13:52:35 <Vulpyne> http://hpaste.org/12860#a2
13:52:58 <Vulpyne> It currently has the commented out part of mostSpecificPrefix enabled when I ran it.
13:53:24 <quicksilver> I can confirm that I can print a 2million element Data.Map without stack overflow.
13:53:39 <Vulpyne> Yeah, well I didn't think it was an error with core Haskell stuff. :)
13:53:40 <Cale> What is the bang pattern in  !cdrs <- readCDRs "..."  for?
13:53:45 <Vulpyne> I know it's something freaky with my code.
13:53:49 <Vulpyne> Forcing strictness.
13:53:57 <Cale> You're only forcing the head of the list.
13:53:59 <quicksilver> takles quite a while due to my stupid terminal emulator, but it works. So there is no overflow in M.toList
13:54:17 <Vulpyne> I just added lots of strictness annotations when it didn't work - adding them or removing them didn't seem to have much of an effect.
13:54:38 <Cale> Adding strictness annotations at random is usually not a great plan ;)
13:54:48 <Cale> I'll give this program a shot...
13:54:52 <quicksilver> I suspect it's the M.alter you want to make strict, by the way
13:54:56 <Cale> Does it need a data file?
13:55:13 <Vulpyne> Yeah, it needs 2, actually, but unfortunately I can't supply them.
13:55:20 <Cale> hmm, all right...
13:55:21 <Vulpyne> I could probably try to generate something though.
13:55:25 <quicksilver> that looks like the most likely thunk candidate
13:55:30 <Vulpyne> (It's customer call detail records for the company I work at, so...)
13:56:18 <quicksilver> Vulpyne: your alter is in fact always an insert, isn't it?
13:56:22 <quicksilver> Vulpyne: it never returns nothing.
13:56:31 <quicksilver> Vulpyne: that means you can replace it with M.insertWith', which is strict.
13:56:36 <opqdonut> :))
13:56:53 <Vulpyne> quicksilver: It may already exist though, and I need to modify the existing entry if so.
13:57:01 <Vulpyne> I could do a lookup then an insert I guess.
13:57:02 <quicksilver> Vulpyne: yeah, insertWith' does that
13:57:08 <quicksilver> Vulpyne: it takes a binary combining function
13:57:47 <Vulpyne> Ahh, maybe I read the definition of it wrong when I was looking at data.map, I was expecting to see a maybe.
13:58:17 <Cale> Another thing you should know is that bang patterns before a constructor to match are always pointless.
13:58:29 <Cale> It already has to evaluate in order to decide if the constructor matches.
13:58:54 <Vulpyne> Ah, thanks.
13:58:55 <Cale> So bang patterns are only meaningful before variables.
14:00:56 <Cale> (and are usually silly if those variables refer to lists)
14:01:04 <Cale> (or other compound data structures)
14:01:29 <Cale> Data.Map is a bit of an exception though, in that it is structure-strict.
14:02:01 <dmwit> I like to think of it as strict in the ordering of the keys.
14:02:05 <Cale> The elements in the Map can be expressions, but if any part of the tree structure itself is evaluated, the whole thing is.
14:02:33 <dmwit> where "thing" = "structure"
14:02:40 <Cale> yes :)
14:02:48 <roconnor> Cale: really? that sucks
14:03:01 <dmwit> roconnor: Try to imagine how else it could possibly work.
14:03:05 <Cale> iirc, it's a counted tree
14:03:20 <roconnor> dmwit: by not evaluating subtrees until it is demanded
14:03:46 <dmwit> Thunk heaven! =)
14:03:47 <qbitor> Had anyone had a look at http://ptrace.fefe.de/wp/wp.hs (info at http://ptrace.fefe.de/wp/README.txt) yet? What do you think about it?
14:03:56 <Cale> roconnor: I think it's tricky to enforce balancing constraints at the same time.
14:04:11 <roconnor> oh
14:04:37 <roconnor> I guess that is okay then
14:05:12 <dmwit> qbitor: Seems fine.  The style is a bit... weird... but otherwise looks pretty readable.
14:05:35 <Vulpyne> Hmm, using insertWith' is looking promising.
14:05:53 <Vulpyne> It's not going above 175M memory usage, hopefully it'll actually be able to print the result. :)
14:05:59 <Cale> Vulpyne: Yes, it's a little annoying that there aren't more strictified variants of the Data.Map functions.
14:06:16 <Cale> In particular, there should be a strict fromListWith
14:07:05 <Vulpyne> Yeah, I think I've been bitten by this before.
14:07:19 <Cale> qbitor: I prefer 'comparing' from Data.Ord for  (compare `on`)
14:07:30 <Cale> But that's not a big deal :)
14:07:34 <quicksilver> Cale: it's not actually tricky to enforce balancing constraints lazily.
14:07:53 <quicksilver> Cale: but it is probably expensive to do so (building up a great big thunk to clear out the first time that branch is accessed)
14:07:55 <Cale> Also, it might be nice to use forM_ sorted $ \(word, count) -> ... instead
14:08:05 <Data_Maybe_Nothi> are gread / gshow suitable for deserialization/serialization?
14:08:12 <Saizan> btw of strictness, does  "foldr1 (insertBy compare)" use O(n) stack as i imagine?
14:08:41 <qbitor> What somehow bugs me is that it is nearly the slowest implementation: http://ptrace.fefe.de/wp/timings.txt
14:08:50 <Cale> Saizan: insertBy is a strict function isn't it?
14:08:58 <Saizan> ?src insertBy
14:08:59 <lambdabot> insertBy _   x [] = [x]
14:08:59 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
14:08:59 <lambdabot>                                  GT -> y : insertBy cmp x ys'
14:08:59 <lambdabot>                                  _  -> x : ys
14:09:05 <quicksilver> Saizan: yes, that's building a n-deep thunk of 'insertBy's
14:09:16 <quicksilver> Saizan: (which then get forced all at once == O(n) stack)
14:09:19 <solrize> Prelude> maximum [1..10000000]
14:09:19 <solrize> *** Exception: stack overflow
14:09:19 <solrize> Prelude>
14:09:24 <solrize> :-P
14:09:33 <quicksilver> Saizan: general rule : only use foldr to generate constructors.
14:09:40 <quicksilver> [for example (:) ]
14:09:50 <quicksilver> use foldl' in in other circumstances.
14:10:04 <Saizan> but what should we use in that case? foldl' doesn't seem to do much better either
14:10:27 <Cale> Well... or things which probably evaluate to constructors, but may take a few steps... filters are a good example for foldr too
14:11:04 <roconnor> > concat (repeat [])
14:11:20 <lambdabot>   thread killed
14:11:35 <Cale> qbitor: Well, there are obviously less expensive things you can do. You're building up a big not-strictly-necessary tree structure just to sort the things.
14:12:06 <Cale> qbitor: Actually, that's probably not the main problem.
14:12:23 <Cale> qbitor: The main problem is probably the I/O, and the fact that you're using plain String
14:12:46 <Cale> If you're interested in getting competitive performance, you'll probably want Data.ByteString
14:13:29 <Ezla> What's the best prelude reference site?
14:13:49 <qbitor> Cale: thx for the hint
14:13:57 <Cale> There are two which are good...
14:13:58 <Cale> http://haskell.org/onlinereport/standard-prelude.html
14:14:15 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:14:20 <Ezla> Cale: thanks
14:14:25 <Cale> The first has actual code.
14:14:44 <Ezla> Do I need a reference Other-than the Prelude too?
14:14:45 <Cale> (well, reference code, not the code which is actually used)
14:14:54 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html
14:15:00 <Ezla> How inclusive is prelude exactly?
14:15:10 <Ezla> prelude "is" Haskell
14:15:17 <Cale> It's just very basic stuff dealing with lists, numbers and IO
14:15:17 <olsner> am I the only one slightly surprised the Cale linked the *actual* prelude instead of the Caleskell prelude? :P
14:15:26 <olsner> *that
14:15:34 <Cale> olsner: I don't actually have a Prelude.
14:15:40 <Ezla> Cale perverted a skeleton version of prelude?
14:15:59 <Cale> olsner: The "Prelude" which people were talking about is just L.hs in lambdabot, which I'd added some things to.
14:16:01 <olsner> you don't? I always thought you did
14:16:16 <Cale> I imported the Prelude qualified and defined a couple functions.
14:16:37 <Cale> I have an idea in my head about what the Prelude would look like if I could reshape it, but I haven't written anything down.
14:17:19 <olsner> well, isn't that just what making a new prelude is? importing prelude qualified, reexporting interesting new definitions of things?
14:17:20 <Cale> Ezla: actually, http://www.haskell.org/ghc/docs/latest/html/libraries/
14:17:41 <Cale> olsner: Well, what I'd actually like to do is redefine the *actual* Prelude.
14:17:49 <Ezla> I run MS Windows, and I end up with 30 web browsers, 40 tasks running, and I battle to Pop the stack, pop the stack, pop
14:17:56 <Cale> So that it's not bloody inconvenient to use the new definitions.
14:17:59 <Ezla> They're things needing to get done.
14:18:15 <Ezla> For code, it's done once I wrote an exact use case and documented it very nicely
14:18:20 <Ezla> Well, I closed everything today for Haskell
14:18:23 <Cale> Redefining things like (++) is a pain in the ass, because not only do you have to import the Prelude qualified, you also have to import Data.List qualified.
14:18:44 <Cale> Ezla: It's too bad Windows doesn't have multiple desktops.
14:18:46 <Ezla> so those URL's are at the base of new stack.
14:18:50 <Cale> (at least not by default)
14:18:52 <olsner> maybe if you add a cabal flag for specifying a prelude, hackage could end up with a plethora of alternate preludes
14:19:23 <Cale> olsner: I don't know how well-supported the notion of a new base-module is.
14:19:29 <Cale> But it seems kind of doable.
14:20:02 <Cale> I would also want to add a flag to GHC, possibly triggered by use of the new base, in order to change, for instance, the translation of do-notation.
14:20:10 <Cale> (fail must die.)
14:20:27 <Cale> Then again, putting fail in another typeclass might work out okay.
14:20:35 <jeffersonheard> am I right in reading that a SampleVar will allow you to read a unique value exactly once?  (i.e. readSampleVar ~= takeMVar)
14:21:04 <olsner> instance MonadFail Fail where fail = Fail?
14:21:07 <GNU\caust1c> how do you call the nonlist argument of fold? :>
14:21:13 <GNU\caust1c> singular value?
14:21:14 <Cale> jeffersonheard: "Reading a filled SampleVar empties it and returns value. (same as takeMVar)"
14:21:23 <jeffersonheard> thanks, Cale.
14:21:34 <olsner> GNU\caust1c: 'zero', usually
14:21:57 <GNU\caust1c> i mean how you name it :>
14:22:06 <Cale> olsner: class Monad m => MonadFail m where fail :: String -> m a
14:22:47 <Ezla> does * -> * work without extensions?
14:22:53 <Cale> GNU\caust1c: If it's foldr, I might call it the replacement for the empty list. If it's foldl, "initial value" seems appropriate.
14:23:06 <GNU\caust1c> hmk
14:23:10 <Cale> Ezla: No, explicit kind annotations are an extension.
14:23:21 <GNU\caust1c> thanks :)
14:23:23 <Ezla> Cale: I was wondering cause the bot does it by default.
14:23:33 <Cale> Yeah, it has extensions turned on.
14:23:33 <olsner> Cale: I was aiming for humoristic repetition of the word 'fail' there, maybe I failed
14:23:36 <Ezla> What extensions are enabled on lambdabot?
14:24:18 <Cale> good question... it used to be -fglasgow-exts, which is just a large collection of them, but maybe it's actually specified somewhere now.
14:24:43 <Cale> I can try and check if you really care :)
14:25:01 <Ezla> cale: maybe add a
14:25:12 <Ezla> lambdabot --show-extensions
14:25:38 <olsner> shouldn't it all be in options_ghc and language pragmas in L.hs?
14:26:18 <Cale> For the type extension, it's running with -fglasgow-exts and -XNoMonomorphismRestriction
14:26:24 <Cale> as well as -fno-th
14:26:36 <Cale> For mueval...
14:27:20 <FunctorSalad> view patterns are handy for preprocessing an argument without giving a name to the unprocessed arg :) not just for pattern matching
14:27:47 <int-e> @kind (->)
14:27:49 <lambdabot> ?? -> ? -> *
14:28:45 <olsner> hmm, can you use ? in kind annotations? what do they mean?
14:29:35 <byorgey> olsner: IIRC you can't actually use them, they are special kinds internal to GHC
14:29:41 <byorgey> but I don't know what they mean.
14:30:03 <int-e> olsner: you can't. their purpose is to deal with unboxed types in ghc. unboxed types have kind #. unboxed tuples have kind (#). ?? encompasses * and # while ? encompasses *, # and (#).
14:30:45 <int-e> olsner: (->) is the only type constructor that uses them, I believe. And that one is built into the compiler.
14:31:18 <Cale> Well, I think it's just -fglasgow-exts, but I'd have to dig into hint to find out if that's really true.
14:31:29 <olsner> @kind Maybe
14:31:31 <lambdabot> * -> *
14:31:45 <Cale> ? and ?? are related to unboxed types
14:32:03 <olsner> wild stuff, makes we kind of not want to know too much about kinds
14:32:58 <Vulpyne> Heh, so using insertWith' and lazy bytestrings, memory usage from 500mb to 4mb.
14:33:31 <sjanssen> Haskell ftw
14:33:47 <int-e> olsner: you really only have to worry about *
14:33:49 <Vulpyne> Sometimes it makes my brain hurt, though.
14:33:50 <mapreduce> @seen cdsmith
14:33:51 <lambdabot> I haven't seen cdsmith.
14:33:57 <int-e> olsner: * -> * and so on :)
14:34:04 <mapreduce> Does cdsmith visit #haskell?
14:34:10 <olsner> I was writing some type-system church numerals the other day, ran into the kind system pretty soon
14:34:17 <Cale> ? means any type at all, ?? is the least upper bound of * and #,  * means boxed type, # means unboxed type, (#) means unboxed tuple
14:34:25 <int-e> @kind StateT
14:34:27 <lambdabot> * -> (* -> *) -> * -> *
14:34:30 <Cale> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
14:34:32 <olsner> couldn't figure out the right kind annotation for the exponential function
14:34:43 <olsner> s/function/type/
14:34:45 <bd_> Cale: so ?? doesn't contain unboxed tuples?
14:34:50 <Cale> right
14:35:00 <Ezla> It's strange how there's so many
14:35:07 <Ezla> "Monads as ______"
14:35:14 <Ezla> definitions.
14:35:20 <Cale> Ezla: aren't there just the two I wrote? :)
14:35:40 <Cale> Ezla: I suppose there might be some more perspectives. :)
14:35:40 <Ezla> Well, I run into a new definition everyday.
14:35:46 <Ezla> Today it's "Monads as computation"
14:36:01 <Saizan> olsner: type-level church numerals?
14:36:05 <Cale> Monads are an extremely general notion, and there are different concrete analogies which can be made.
14:36:50 <int-e> monads: ask three haskell programmers, get four different explanations.
14:36:52 <byorgey> mapreduce: he used to, haven't seen him in a while though.
14:37:30 <mapreduce> Thanks.
14:38:16 <mapreduce> I was hoping he'd make the types thing say "untyped" and "typed" more instead of "dynamically typed" and "statically typed".
14:38:43 <mapreduce> This would make those ever-important Internet arguments easier.
14:38:50 <opqdonut> :)
14:38:55 <olsner> Saizan: yep, in this case for producing nested types, so type List a = [a]; type Foo = Eight List () would give you type Foo = <eight-nested list of ()>
14:39:47 <opqdonut> so type-level church numerals?
14:40:15 <Saizan> ah, so Eight is a type-synonim, i see
14:40:38 <Ezla> Cale, can you help with [exists a. Animal a => a] ?
14:40:39 <foo17y> Anyone knows what the big difference between nanocurses and hscurses is? which is easier to use?
14:40:41 <olsner> yeah, produced by e.g. type Eight t a = Mul Four Two t a
14:41:42 <Cale> Ezla: data AnyAnimal where AA :: (Animal a) => a -> AnyAnimal
14:41:54 <Cale> Ezla: Then you can use [AnyAnimal]
14:42:18 <Ezla> Cale: that's just so weird.
14:42:19 <Saizan> olsner: can you partially apply type synonyms like Four and Two there?
14:42:33 <Cale> Ezla: Once you've applied the AA constructor, it's permanent though. It's what lets you forget which animal you had.
14:42:39 <Ezla> :t exists
14:42:41 <lambdabot> Not in scope: `exists'
14:42:53 <Cale> exists isn't actually part of the syntax of any existing Haskell extension
14:43:31 <Cale> However, there are "existential types", which avoid adding that keyword by moving the quantifier a bit so that it becomes a forall
14:43:51 <Cale> data AnyAnimal = forall a. (AnyAnimal a) => AA a
14:43:53 <olsner> Saizan: http://hpaste.org/12795
14:44:10 <Cale> Is the older notation for that existential (I prefer the GADT syntax myself)
14:44:55 <Ezla> f :: (Num a) => a -> a   -- f is a function taking a type of typeclass Num, and returning a type of typeclass Num
14:44:58 <Ezla> data AnyAnimal where AA :: (Animal a) => a -> AnyAnimal   -- ?
14:45:05 <Ezla> Can you do the same english enumeration?
14:45:07 <carlos> Hi guys  can you help me?
14:45:36 <nybyn> how do i uninstall a cabal package?
14:45:39 <byorgey> Guest11133: hard to know until you ask a question.  what are you having trouble with?
14:45:49 <Guest11133> I'm getting a "Instance of Num [Char] required for definition of proxSonsAux2" in my code
14:45:50 <Cale> Ezla: AA is a data constructor which takes a value of any type in the Animal class and produces an AnyAnimal value.
14:46:09 <byorgey> nybyn: you can unregister it,  'ghc-pkg unregister package'
14:46:22 <nybyn> byorgey: thx :)
14:46:26 <Cale> Guest11133: It means you're using a string as a number.
14:46:33 <byorgey> nybyn: or 'sudo ghc-pkg unregister --global package' if it's in the systemwide package repository
14:46:34 <Guest11133> with the following code http://hpaste.org/12868
14:46:37 <Ezla> Cale: If you must do that, then why does [Num] work ?
14:46:39 <nybyn> ah
14:46:44 <Ezla> or is [Num] invalid too
14:46:46 <Cale> Ezla: It doesn't.
14:46:58 <Cale> You can have  (Num a) => [a]
14:47:01 <Cale> But that's different
14:47:07 <Cale> They all have to be the same type of number.
14:47:10 <byorgey> Guest11133: you need parens around (i+1)
14:47:11 <Guest11133> proxSonsAux2 :: [String] -> Int -> String proxSonsAux2 x i | i+1 <= (length x) = x !! i+1  		 | otherwise = head x
14:47:24 <byorgey> Guest11133: x !! i+1 parses as (x!!i) + 1
14:47:51 <Cale> Guest11133: byorgey nailed it :)  Also, watch out: there are tabs in this code.
14:48:06 <Cale> Guest11133: You'll want to reconfigure your text editor to use spaces instead of tabs.
14:48:13 <Ezla> Cale: It's allowed for my Animal because I have declared instances, and they implement exactly each function required. But what stops 'Num' from working with  data AnyNum where AA :: ...
14:48:36 <Ezla> it does seem odd to store integers and floats in one list
14:49:00 <Cale> Ezla: It's semi-useless, because you need two numbers to do something generally interesting with numbers, and if you don't know they're the same type, you can't apply any operations to them.
14:49:35 <Cale> Ezla: An existential wrapper which forgets the type of the numbers basically forbids you from doing anything interesting with them from that point on.
14:49:37 <Guest11133> http://hpaste.org/12868#a1
14:50:18 <jsn> in a haskell source file, say we have a line that is indented
14:50:19 <Cale> Guest11133: Too many parameters.
14:50:20 <Guest11133> the error changed with the parentises aded
14:50:38 <Cale> Guest11133: You're giving  proxSonsAux the parameters  xs, proxSons, and (i+1)
14:50:45 <jsn> that line is either part of a definition that begins with a line not indented, or a comment, or a syntax error, right?
14:51:04 <Ezla> unless I used Typeable
14:51:28 <Cale> jsn: or part of an expression which is less indented
14:51:58 <jsn> Cale: yes, that too
14:51:58 <olsner> nicer names of the type-level church numerals here: http://hpaste.org/12795#a1
14:52:03 <Ezla> In what situation would you genuinely need Typeable?
14:52:21 <jsn> (when i said "definition" i guess i should have declaration or expression)
14:52:27 <Guest11133> XD THX GUYS
14:52:34 <olsner> unit :: (Eight :+ Four :+ Two :+ One) List () ---> [[[[[[[[[[[[[[[()]]]]]]]]]]]]]]]
14:52:55 <haskell_newbie> Hi guys I'm having a problem with my code, hope you can help me :)
14:53:10 <Cale> haskell_newbie: sure thing :)
14:53:38 <Ezla> Cale: are existential wrappers the primary means of polymorphism?
14:53:46 <Cale> Ezla: Well... it's used in an implementation of what we call generics (which is something different from what the OO world calls generics)
14:53:50 <Cale> Ezla: no
14:54:00 <roconnor> is sequence.complete.org  down for everyone else?
14:54:00 <Cale> Ezla: parametricity is the primary means of polymorphism
14:54:05 <byorgey> roconnor: yep
14:54:08 <Ezla> parametricity?
14:54:12 <byorgey> well... for me at least =)
14:54:13 <Cale> Ezla: yeah, for example:
14:54:16 <Cale> :t length
14:54:18 <lambdabot> forall a. [a] -> Int
14:54:32 <Cale> length doesn't care about what type of elements the list has, so it's polymorphic
14:54:35 <jsn> Cale: so i can have a literate haskell syntax that finds all the indented lines which are not haskell comments or part of a declaration or expression, in principle
14:54:37 <haskell_newbie>  Heres the code and the error http://hpaste.org/12869 thanx in advance
14:54:40 <Cale> :t sort
14:54:41 <Ezla> The . operator looks so odd to me.. is there a basis for it?
14:54:41 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:54:56 <Cale> Ezla: you mean the . which marks the end of the forall?
14:55:00 <Ezla> They were just trying to avoid {  } ?
14:55:07 <Cale> haskell_newbie: I'll take a look :)
14:55:15 <Cale> Ezla: yeah, it's just a delimiter there
14:55:17 <haskell_newbie> Cale: thanx a lot!
14:55:28 <Cale> Ezla: you can have  forall a b. (stuff)
14:55:43 <Philippa> Cale: it might be an idea to introduce Ezla to System F
14:55:43 <Cale> Ezla: So it marks the end of the sequence of type variables which are being introduced
14:56:04 <byorgey> haskell_newbie: looks like you have some extra parentheses there
14:56:16 <Philippa> it makes fairly natural sense to a C++er anyway, as it appears to have "run-time templates" :-)
14:56:16 <haskell_newbie> byorgey: really?
14:56:31 <byorgey> haskell_newbie: I think you want to apply  tick_aux_2 to (evoluiNat nat x) and xs, right?
14:56:33 <Philippa> (yes, yes, I know, erasure works!)
14:56:34 <Cale> haskell_newbie: You've effectively given evoluiNat 3 parameters
14:56:42 <Cale> haskell_newbie: But it only takes 2
14:57:03 <haskell_newbie> byorgey: yes thats right
14:57:11 <jsn> Ezla: it reminds me of   λab.a   and such
14:57:12 <Cale> haskell_newbie: if you want xs to be a parameter to tick_aux_2 it can't go in the same parens as evoluiNat
14:57:27 <Ezla> Philippa: Type erasure? Call a templated type, and a contained object is allocated which implements the innards based on the passed type?
14:57:32 <Cale> haskell_newbie: tick_aux_2 nat (x:xs) = tick_aux_2 (evoluiNat nat x) xs
14:57:37 <Cale> haskell_newbie: Try that :)
14:57:49 <Ezla> or some FP permutation of that
14:58:06 <Philippa> Ezla: no, it means that you can take all the types out of a System F program and get a valid program in the untyped lambda calculus still
14:58:08 <haskell_newbie> Cale: I'm gonna try it
14:58:27 <Philippa> whereas you can't do that for Haskell unless you translate out the typeclasses first
14:58:27 <Cale> Ezla: The reason that parametric polymorphism works in Haskell is that all values have the same wrapping representation.
14:58:32 <haskell_newbie> Cale: IT worked ! :) THANK YOU!!
14:58:50 <jsn> Philippa: with typeclasses it
14:58:51 <Cale> Ezla: So for something like length, you don't have to compile separate versions for every type of list you want to use it at.
14:58:57 <jsn> is system Fc?
14:59:03 <Ezla> ah
14:59:15 <Philippa> jsn: no
14:59:20 <Philippa> not at all
14:59:24 <cknapp> Cale: parametric polymorphism?
14:59:31 <Cale> cknapp: yes
14:59:32 <cknapp> Is "List a" an example of that?
14:59:41 <Cale> cknapp: Yes, "type variables"
14:59:46 <cknapp> Cool.
15:00:13 <jsn> Philippa: ah, yeah, i guess Fc is rather more involved
15:00:28 <Ezla> forall x. (F x -> x) -> x
15:00:31 <cknapp> "Peter programmed a program with parametric polymorphism..."
15:00:34 <Cale> Well, I should be careful perhaps -- GHC does allow for "unboxed types" which don't work with parametrically polymorphic functions, but they're a lowlevel detail which can be ignored for most programming.
15:00:42 <pejo> jsn, a bunch of other type system features "motivated" System Fc. There's some motivation in the System Fc paper.
15:00:59 <centrinia> Unboxed types save space and time. :)
15:01:24 <Ezla> If only you could load it again, centrinia
15:01:52 <jsn> pejo: yes, i found it
15:02:35 <dons> ?users
15:02:35 <lambdabot> Maximum users seen in #haskell: 583, currently: 564 (96.7%), active: 25 (4.4%)
15:02:38 <dons> sweet.
15:02:53 <Philippa> guys: Someone actually explain System F to Ezla who won't have encountered it at all?
15:02:56 <Megzlna> Hooray, Ezla's dead
15:03:10 <tibbe> could someone give me an example of something that's a functor but not an applicative functor?
15:03:32 <shepheb> tibbe: binary tree/
15:03:33 <shepheb> ?
15:03:58 <tibbe> shepheb: couldn't you have a binary tree of functions? :)
15:04:19 <Cale> Binary trees should be applicative in at least one way. But any functor which we haven't specified operations pure and <*> would be an example.
15:04:40 <cknapp> Philippa: what do you mean?
15:04:42 <MyCatVerbs> @type serious cat = serious
15:04:43 <lambdabot> parse error on input `='
15:04:46 <opqdonut> i guess what tibbe was asking for was a Functor which can't be applicative
15:04:48 <shepheb> yeah, I guess you could just pretend the tree was a list by choosing, say, infix order
15:04:56 <MyCatVerbs> @type let serious cat = serious in serious
15:04:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
15:04:57 <lambdabot>     Probable cause: `serious' is applied to too few arguments
15:04:57 <lambdabot>     In the expression: serious
15:05:10 <Cale> shepheb: Well, there's a natural generalisation of 'zip' for trees.
15:05:18 <Cale> and zippable structures are applicative
15:05:31 <Megzlna> Philippa: Does System F ease  f x = True :: (Num a) => a -> Bool   ,   f x = False :: (Enum a) => a -> Bool   ?
15:05:41 <opqdonut> :D
15:05:46 <MyCatVerbs> Cale: aren't there multiple? Postorder and in-order, at least?
15:05:46 <opqdonut> Megzlna must be Ezla
15:05:50 <shepheb> Cale: point, I hadn't thought about the connection with zippers
15:05:55 <Megzlna> I am Ezla
15:05:56 <tibbe> Cale: I'm trying to write an Applicative instance for a functor I have but it seems to "easy"
15:05:57 <Philippa> Megzlna: It'll help in understanding why that's not going to happen
15:06:07 <Cale> Maybe something like  data ListOrIO a = List [a] | IO (IO a)
15:06:09 <opqdonut> oh well, time to update my ignorelist
15:06:10 <tibbe> Cale: extract the function and fmap
15:06:19 <Philippa> though one relevant detail with typeclasses is that you can never be sure there is no instance
15:06:21 <Cale> That's a functor, but I can't think of a way to make it applicative
15:06:30 <Philippa> there's an open world assumption about instances so that they can be added in other modules
15:06:39 <Philippa> therefore you could never refute the pattern you want
15:06:41 <MyCatVerbs> Oh nvm, I was thinking of fold for some reason.
15:06:42 <centrinia> Megzlna: That is not a well defined function.
15:07:10 <Cale> For example, what's  IO f <*> List (x:xs) ?
15:07:21 <Philippa> if you /could/, then you'd encode it using another typeclass with one instance for types with a Num instance and another for types with no Num instance and an Enum instance
15:07:25 <opqdonut> Cale: yeah, that's a good example
15:07:27 <centrinia> How about Either [a] (IO a)
15:07:37 <Cale> same thing :)
15:07:40 <opqdonut> centrinia: well that's isomorphic ;)
15:07:42 <Megzlna> You break it by adding an type which previously satisfied only Num, but now satisfies Enum, in another module?
15:08:01 <opqdonut> Cale: of course, one could handle the IO as a "Nothing" case, right?
15:08:02 <Philippa> other way round, but yes
15:08:09 <Philippa> you can't have "no instance" qualifications
15:08:21 <opqdonut> oh no, that wouldn't work
15:09:01 <byorgey> IO f <*> List (x:xs) = List []   ;)
15:09:42 <centrinia> Megzlna: What is f 2 ?
15:09:42 <Cale> A good question is whether it will satisfy the laws :)
15:09:56 <byorgey> yes, of course =)
15:10:05 <centrinia> Note that 2 is both an Num and an Enum.
15:10:07 <byorgey> hmm, I always forget the applicative laws
15:10:11 <Megzlna> centrinia: Lexical match
15:10:21 <Megzlna> But what Philippa said made sense.
15:11:02 <mokus> centrinia: 2 isn't necessarily Enum ;-)
15:11:14 <Cale> Megzlna: btw, you're writing the type signatures for those functions incorrectly -- when it occurs on the right hand side of an = the :: applies to the expression on the RHS, not the function
15:11:18 <centrinia> Oh.
15:11:25 <centrinia>  (2 :: Integer) then ;)
15:11:41 <Megzlna> Cale: k. I didn't try for correctness due to it being invalid in the first place.
15:11:49 <Cale> right :)
15:12:51 <Cale> One of the things we strive for in our type systems is that for any value, there should be exactly one most general type which it belongs to (and if all goes well, type inference will be able to figure out what that is)
15:12:52 <Megzlna> It seems that Haskell has a lot of untapped potential power if there were to be a Half-compiled-modules system.. Indeterminate modules, Where the compiler keeps some kind of little graph, and then re-passes over modules that have broken determinancy
15:13:20 <centrinia> How do I implement an untyped SK combinator logic with Haskell expressions?
15:13:30 <Cale> Megzlna: The standard allows recursive modules, but for whatever reason, the implementations don't support them.
15:13:48 <Megzlna> Recursive modules would do as I asked?
15:14:27 <Cale> Megzlna: Well, you could have two modules each of which imports the other, which sounds like what you were talking about to me.
15:15:30 <Megzlna> It would allow for typeclass AND's too
15:15:46 <Cale> You would probably have to do some kind of partial compilation of modules in each strongly connected component of the dependency graph, and then do another pass.
15:16:16 <Cale> No, it wouldn't really, unless you mean something which I'm not thinking of...
15:16:24 <centrinia> How about splicing modules with Template Haskell and make the import statement reify the module?
15:17:08 <Megzlna> Cale: what about this system F?
15:17:10 <Cale> Do you really mean AND? That kind of already exists.
15:17:18 <Megzlna> no not AND.
15:17:39 <Cale> I'm still not really sure how typeclass OR would work.
15:17:41 <Megzlna> pardon  me. OR and NOT, even though you'll say you cannot take action upon eithere
15:17:52 <Cale> right.
15:18:16 <centrinia> Cale, would an untyped Haskell make sense?
15:18:20 <Cale> There's nothing you can actually accomplish by assuming that either of two typeclass instances are available.
15:18:41 <Cale> centrinia: Not with typeclasses.
15:18:43 <Cale> ;)
15:18:53 <Megzlna> Cale: Why do I keep doing this
15:19:07 <byorgey> centrinia: well, if you want to implement an *untyped* combinator logic, then if I were you I'd just make a data type to represent combinator expressions
15:19:36 <Cale> Though, if it was accompanied with a syntax at the value level... maybe
15:19:38 <byorgey> data CExp = S | K | App CExp CExp
15:19:41 <Cale> Something like typeclass-case
15:19:57 <cknapp> Megzlna: keep doing what?
15:20:01 <Megzlna> Because I'm trying to prod Haskell for perfection in a realization that every feature has a proof basis, such that when I propose unsound features as previously when Philippa replied about new modules, Haskell is "perfect" all the way through
15:20:04 <opqdonut> and then a recursive eval function for CExp
15:20:06 <Cale> But that's very strange. It would be a pain to implement, and I don't see the real use cases.
15:20:24 <Cale> Megzlna: Haskell is extremely well-thought-out in general.
15:20:25 <Megzlna> Clangs are ad-hoc in terms of usefulness
15:20:41 <Megzlna> the M.O. for D is stuff-we-need
15:20:42 <Cale> There are warts, but they're mostly library things.
15:21:02 <Cale> and there are missing features, but the workarounds are not too horrible
15:21:13 <centrinia> Monomorphism restriction wart. :)
15:21:27 <Cale> Well, there's that, yes.
15:21:58 <Cale> For missing features, I would say  polymorphic extensible record and variant types are at the top of my list.
15:22:04 <Philippa_> same here
15:22:28 <Philippa_> mind you, if I had those then I have some smartarsed use cases for recursive module definitions...
15:22:29 <Megzlna> How does that work?
15:22:55 <Cale> Megzlna: I'll find you a paper.
15:22:58 <Megzlna> Can you show an example of how records are not polymorphic-extensible?
15:23:07 <Megzlna> I wanna see the deadend
15:23:11 <Cale> Megzlna: Our current "records" are not extensible at all.
15:23:20 <Cale> They have a fixed number of fields at runtime.
15:23:48 <centrinia> Cale, can't we half-ass extensible records?
15:23:51 <Cale> http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf -- this paper describes a system with good semantics, but I hate the syntax :)
15:24:22 <Megzlna> > data Foo = Foo { bar :: Int, baz :: String }
15:24:22 <lambdabot>   <no location info>: parse error on input `data'
15:24:23 <Cale> centrinia: Yes, sort of, but it's so kludgey and horrible that I would hesitate to use it in a real program.
15:24:38 <Philippa_> Cale: the syntax is largely traditional for the field IIRC
15:24:44 <Philippa_> still sucks, but hey
15:24:45 <Megzlna> You want to extend across modules?
15:24:47 <centrinia> You could also scrap your boilerplate. :)
15:24:51 <roconnor> Oleg has extensible records
15:25:01 <Philippa_> yeah, across modules. Why not?
15:25:05 <Philippa_> it's only subtyping
15:25:14 <Cale> Philippa_: yes. I would prefer something which used lenses.
15:25:37 <Cale> also, the field names should get a special syntactic indication that they're field names to allow that.
15:25:40 <centrinia> What do lenses have to do with bananas?
15:25:46 <Megzlna> We did have this discussion, I asked for it a few days ago, didn't know Cale was speaking of the same thinig
15:25:49 <Cale> Oh, not that kind of lenses.
15:26:02 <mlesniak> Anyone who ever worked with HScurses could take a look at http://hpaste.org/12870 . Seems I'm forgetting something simple.
15:26:02 <centrinia> Oh.
15:26:13 <Megzlna> Cale: Variant types?
15:26:35 <Megzlna> machine level variants, provide the explicit T to extract it as T?
15:26:41 <Cale> The kind where you treat field names as effectively tuples of the record operations, and have operations for extracting them.
15:26:54 <Cale> So you use  get 'fieldName  as the getter.
15:27:08 <Megzlna> Cale: Should that be able to produce a bogus representation of float when packed with int?
15:27:16 <Cale> oh, I have to go -- that paper describes variants as well
15:27:39 <Cale> The important point is the variants are typed and labelled, so you know what you're asking for/getting
15:28:00 <Megzlna> I thought the data constructor worked as a union.
15:28:07 <Philippa_> yeah, but not as in C union
15:28:23 <Philippa_> C unions aren't disjoint: it's all the types, not just one of them
15:28:57 <olsner> accessing any other member than the one you last wrote is undefined behaviour though :)
15:29:26 <Philippa_> I'd hope it's implementation-defined given some common use cases?
15:29:33 <centrinia> Cale, how do you handle getting an arbitrarily typed field?
15:29:46 <olsner> iirc, gcc has an extension for making some of the unsafe uses safe
15:31:00 <oklopol> > replicate 4 5
15:31:01 <lambdabot>   [5,5,5,5]
15:35:52 <Saizan> Cale: btw, with that scopedlabels paper you can't pass labels around as values, i.e. get and set aren't typeable, we need the previous "morrow & first-class labels"
15:38:24 <sinelaw> I want to define "random variable" in haskell
15:38:34 <sinelaw> that is, a function Omega -> R
15:38:57 <sinelaw> but in many cases, nobody really cares what Omega is
15:39:04 <sinelaw> so what should i do?
15:40:18 <roconnor> sinelaw: use one of the existing libs
15:41:54 <sinelaw> roconnor, such as? the probability package i'm seeing in hackage doesn't seem to follow the mathematical structure
15:42:34 <xyuu> hello
15:43:53 <blackh> xyuu: hello there!
15:44:02 <xyuu> i'm having trouble building yhc
15:44:07 <Cale> Saizan: ah
15:45:23 <Cale> Saizan: well, we need label variables to type them
15:45:39 <Saizan> Cale: yeah
15:45:54 <Cale> I don't think that introduces a serious problem...
15:45:55 <blackh> xyuu: I haven't tried.  Maybe paste your output into the paste bin.
15:46:22 <Saizan> i think it may complicate things at the value level
15:46:47 <Cale> Saizan: Hmm...
15:47:35 <sinelaw> where can i find an explanation of the UMP?
15:47:55 <ddarius> Read a book.
15:47:57 <xyuu> yhc build error: http://hpaste.org/12871
15:48:33 <sinelaw> ddarius, i'm trying :) hard to learn abstract math on my own with ->0 background
15:49:28 <ddarius> sinelaw: It will take a while, but it is doable.  If you don't mind spending money, then buying books with a good reputation is probably the quickest route.  (I had no money, so that's not the route I took.)
15:50:29 <ddarius> There are introductions online that specifically use the term "universal mapping property," but the idea dressed up slightly differently is in any introduction to CT (online or hardcopy).
15:50:31 <Cale> sinelaw: You want this in general?
15:50:51 <blackh> xyuu: Looks like a missing dependency. Otherwise I can't suggest much.
15:50:52 <sinelaw> Cale, i'm trying to understand Awodey's book
15:50:58 <Cale> sinelaw: Ah, okay
15:52:08 <ddarius> That Awodey book strikes me as a very good introduction (though this is coming from a perspective of someone reasonably proficient in CT.)  I wish I had read it years ago.
15:52:22 <xyuu> blackhn: i don't think so. There is a Machine.hs file in the same directory as Prim.hs, but for some reason, it's not being found
15:53:21 <Cale> sinelaw: In that book, lots of separate definitions for universal mapping properties of various types are given.
15:53:41 <sinelaw> ok, i'm only on page 17 so it's the first one :) for Monoids
15:54:56 <sinelaw> i get the definition, but not the idea behind it
15:55:28 <Cale> Okay, so the idea is that it's telling you a sense in which the free monoid is "special"
15:56:54 <Cale> For any other monoid at all, and mapping f from A into its underlying set, that mapping factors through the map i from A to |M(A)| in a unique way
15:57:52 <Cale> Another way to say that is that monoid homomorphisms from the free monoid are entirely determined by where they send the images of the elements of A
15:58:56 <Cale> Note that when you have a property like this, that for all other structures, there's a unique map making the diagram commute, it means that any other thing satisfying the same property must have an isomorphism to this one.
15:59:22 <Cale> Have a look at it in this case...
15:59:27 <sinelaw> hmm
15:59:41 <Cale> Suppose we have some other monoid F, and map j: A -> |F|
16:00:43 <sinelaw> ok
16:00:47 <Cale> so that for any monoid N and any function f: A -> |N|, there's a unique mapping f^: F -> N such that |f^| . j = f, like the same diagram
16:01:11 <Cale> Then we could take N = M(A)
16:01:22 <JFC1993> Hello?
16:01:35 <Cale> and similarly, we could use the UMP for M(A) to get a unique map M(A) -> F
16:02:40 <ddarius> sinelaw: I like viewing the function induced by Cale's notation |-| as the crucial thing.  This leads to representability.  Representability is just another perspective of the UMP.
16:02:52 <Cale> and, we could show that the unique maps satisfying these properties are in fact inverses
16:02:59 <Cale> JFC1993: hello!
16:03:20 <Cale> (you'll find a proof of it on the next page)
16:03:30 <sinelaw> Cale, yes, looking at that
16:03:45 * ddarius tends to prefer proving things using representability and Yoneda.
16:03:58 <Cale> Well, this is way before Yoneda ;)
16:04:11 <Cale> (in the book)
16:04:33 <ddarius> Cale: I have an article I'm (sporadically) working on where Yoneda is the very first thing proven.
16:05:31 <Cale> I think one may need a good sense of what limits and colimits and such are first before one can really appreciate Yoneda's lemma.
16:06:13 <ddarius> The full extent of it, probably, but the extremely useful corollary is basic and fundamental.
16:06:58 <Cale> Which one?
16:07:20 <Cale> yA isomorphic to yB implies A isomorphic to B?
16:07:25 <ddarius> That the Yoneda functor is full and faithful.
16:07:26 <ddarius> Yes.
16:07:36 <Cale> ah, oka
16:07:38 <Cale> y*
16:08:43 <Cale> But I think it's hard to see why it's worth working in Set^(C^op) before you understand how Set^(C^op) is a nice category...
16:09:49 <ddarius> Cale: Well, immediately after Yoneda, I introduce representability, which, I think, can mostly stand on it's own and it absolutely requires the Yoneda lemma to be useful.
16:11:11 <sinelaw> do i understand correctly that part of M(A)'s property is that it isn't "lossy" about A?
16:11:20 <blackh> xyuu: Has it been compiled? (is there a .o and .hi file?)
16:11:33 <Cale> sinelaw: in some sense, yes :)
16:11:55 <xyuu> blackh: no
16:12:03 <Cale> sinelaw: Though just the fact that A -> |M(A)| alone is an injection isn't quite enough.
16:12:19 <sinelaw> the uniqueness of |f^| confuses me
16:12:28 <sinelaw> why must it be unique?
16:12:36 <Cale> sinelaw: Good question :)
16:12:58 <Cale> sinelaw: Let's take a look at the free monoid construction
16:13:03 <sinelaw> ah, maybe to say that M(A) only contains "as much as needed"? sorry for the preschool math thinking :)
16:13:09 <ddarius> sinelaw: From a representability point of view, it just means |-| is a function.
16:13:12 <Cale> and consider what it means to be a homomorphism from the free monoid to something else
16:13:15 <blackh> xyuu: My guess is that ghc handles make dependencies differently. Just shag about with the make file
16:13:34 <Cale> Every element in the free monoid can be written as a product of elements of the image of A
16:13:39 <sinelaw> right
16:13:45 <Cale> which, incidentally, are usually called "generators"
16:13:46 <blackh> xyuu: "differently" meaning "differently from how it did when the yhc was last updated"
16:13:56 <ddarius> sinelaw: Yes, it's the "no junk" aspect of a free algebra.
16:14:13 <ddarius> (if I haven't gotten them mixed up)
16:14:16 <Cale> Suppose we take some u in M(A) and write it as the product a_1 ... a_n of generators
16:14:39 <Cale> then where will a homomorphism f: M(A) -> N send this u?
16:14:51 <Cale> f(u) = f(a_1 ... a_n) = f(a_1) ... f(a_n)
16:14:56 <sinelaw> ok
16:15:05 <Cale> It sends it to the product of the images of the generators.
16:15:21 <Cale> So if we know where the generators are supposed to go in N already
16:15:28 <Cale> then we know where everything in M(A) will go
16:15:40 <JFC1993> Can anyone help me in math?
16:15:44 <Cale> JFC1993: probably :)
16:15:57 <lament> "Can anyone help me in #math?"
16:16:31 <JFC1993> Cale http://en.wikipedia.org/wiki/User:JFC1993
16:16:31 <Cale> A question like that is usually best left unanswered until the actual question is put forward ;)
16:16:38 <JFC1993> http://en.wikipedia.org/wiki/User:JFC1993
16:16:41 <JFC1993> there
16:16:59 <ddarius> Cale: That seems a bit backwards for sinelaw's question.  That shows that it is unique, but doesn't show why we need to require uniqueness.
16:17:32 <cknapp> lament: check #math
16:17:59 <Cale> ddarius: That's sort of what I took "why must it be unique" to mean...
16:18:08 <Cale> the other question is a bit more philosophical, I suppose.
16:18:16 <sinelaw> hmm. That does show that it must be unique...the condition for it is that every u in M(A) can be repesented as product of generators, right?
16:18:20 <JFC1993> Cale can you?
16:18:43 <Cale> JFC1993: I see a bunch of integrals, but no question.
16:18:50 <JFC1993> The bottom
16:18:55 <cknapp> Oh, dear....
16:19:08 <JFC1993> is the one i need to solve I got the top
16:19:13 <Cale> JFC1993: you want to evaluate that integral to a number?
16:19:19 <JFC1993> Yep
16:19:41 <JFC1993> We have not got that far in my class yet
16:19:57 <lament> integrals like that are proof that God does not want humans to be doing math.
16:19:58 <Cale> 15 ;)
16:20:31 <lament> (but rather computers) ;)
16:20:37 <JFC1993> Cale you did it that fast?
16:20:45 <Cale> JFC1993: I'm sitting in front of a computer.
16:20:52 <JFC1993> huh?
16:20:53 <ddarius> Yeah, "Stick it in Mathematica and press Evaluate" is the correct answer.
16:21:12 <JFC1993> Cale are you a genius
16:21:14 <Cale> But it's really not so hard.
16:21:15 <ddarius> That integral is simple enough to solve in your head that fast.
16:21:19 <Cale> Yeah.
16:21:36 <cknapp> JFC: Um... pull out the 4... then solve... it's just a simple double integral
16:21:40 <JFC1993> for me it is im in 10th grade
16:21:49 * QtPlatyp1s tought that ordinals where the proof that God does not want humans to do math.
16:22:01 <Cale> JFC1993: What are you doing with integrals in 10th grade?
16:22:07 <lament> ordinals are proof that God doesn't know when to stop.
16:22:10 <Cale> JFC1993: What country do you live in?
16:22:13 <cknapp> QtPlatypls: tought or thought?
16:22:17 <JFC1993> Im in HL IB math studies
16:22:20 <JFC1993> usa
16:22:25 <QtPlatypus> thought
16:22:26 <cknapp> JFC1993: Nice.
16:22:27 <Cale> Curious.
16:22:32 <lament> i thought IB started in grade 11?
16:22:39 <sinelaw> JFC1993, what you started is the correct direction, just keep going with y and then x (or other way round)
16:22:40 <cknapp> I thought so too...
16:22:50 <JFC1993> I used to be smart
16:22:51 <lament> i did HL IB math, and i think we only had integrals in grade 12 actually
16:23:01 <JFC1993> at math'
16:23:13 <JFC1993> now Im not that great any more
16:23:33 <ddarius> lament: Where?
16:23:35 <lament> "I used to be smart... Now i'm just stupid"   -- Wiz kid Donnie Smith
16:23:38 <lament> ddarius: Canada.
16:23:41 <cknapp> JFC: If you're taking HL math in 10th grade, you're smart....
16:23:51 <ddarius> Huhm
16:23:52 <cknapp> Math gets really, really hard... suddenly...
16:23:56 <lament> "If you're stupid enough to take HL math in 10th grade, you're smart"
16:23:57 <JFC1993> I know
16:24:25 <JFC1993> I fried at algabra 2 and then I just started sucking
16:24:28 <xyuu> i'm studying math and it's hard as fuck
16:24:34 <lament> ddarius: I don't really remember, it might have been 11. Certainly not 10.
16:24:35 <ddarius> cknapp: Math doesn't get really, really hard until sometime after high school, maybe sometime after undergraduates.
16:24:39 <lament> (because IB starts at 11)
16:24:40 <JFC1993> xyuu what you in?
16:24:49 <cknapp> "IB is either the smartest thing a stupid person could do, or the stupidest thing a smart person can do"
16:25:01 <ddarius> lament: I took a Calculus class in 11th grade not "IB" or anything. [USA]
16:25:02 <Peaker> IB?
16:25:04 <xyuu> 5 weeks into first semester
16:25:04 <lament> math gets really, really hard in undergrad courses that are cross-listed with grad :)
16:25:10 <lament> ddarius: nice.
16:25:10 <cknapp> ddarius: most people disagree with "sometime after undergraduate." In my experience so far... I disagree with msot people.
16:25:22 <JFC1993> AP is a lot better than ib
16:25:22 <lament> ddarius: I took it in grade 9 but that was in Ukraine :)
16:25:24 <cknapp> (where "people" is defined as "math people")
16:25:35 <JFC1993> i am in ap stat and I get collage credits
16:25:48 <ddarius> Oh wait, it was AP, I didn't have any math classes senior year.
16:25:49 <cknapp> JFS1993: I disagree... I learned a lot more math in high school than most people I know who took AP classes
16:25:56 <lament> ddarius: ah
16:26:12 <JFC1993> cknapp But is this every used again?
16:26:24 <sinelaw> Cale, so we want the uniqueness, to ensure that there is no redundancy in M(A)?
16:26:28 <cknapp> JFC: If you go into math or anything which uses it...
16:26:31 <ddarius> JFC1993: Everything you learn in grade school (meaning K-12) is used.
16:27:40 <Cale> integral from y = 1 to 2 of (integral from x = 2 to 3 of (integral from z = 0 to 1 of 8 x y z)) = integral from y = 1 to 2 of (integral from x = 2 to 3 of (4 x y)) = integral from y = 1 to 2 of (2 3^2 y - 2 2^2 y) = integral from y = 1 to 2 of (10 y) = 5 2^2 - 5 1^2 = 3*5 = 15
16:27:44 <JFC1993> I did not know haskell was still popular
16:27:52 <sinelaw> still?
16:27:56 <cknapp> JFC1993: It's still getting more popular...
16:28:06 <JFC1993> Huh
16:28:07 <sinelaw> you mean with respect to the future?
16:28:31 <Cale> I obviously left out some steps there, but you get the idea.
16:28:39 <JFC1993> Is it like maple or matlab?
16:28:45 <cknapp> No...
16:28:48 <lament> Generalissimo Francisco Franco is still dead :)
16:28:51 <sinelaw> it starts with an 'H'
16:28:52 <Cale> JFC1993: It's not a CAS, it's a general purpose programming language.
16:29:04 <xyuu> i have a quiz in calculus on friday and i am so screwed
16:29:08 <JFC1993> Cale thank you a whole lot!
16:29:16 <JFC1993> You saved my night.
16:29:19 <Cale> JFC1993: But it is very mathematical, in the sense that functions in Haskell are proper mathematical functions.
16:29:30 <ddarius> proper mathematical (partial) functions
16:29:42 <cknapp> And mathematical... not necessarily numeric.
16:30:13 <JFC1993> Is it similar to any other language?
16:30:15 <cknapp> Hmm... I have too many papers to read.
16:30:18 <Cale> Well, yeah, the important thing being that there are some sets you can associate with datatypes, and every function between two Haskell datatypes is properly a function between those sets.
16:30:25 <dons> JFC1993: hehe "still"
16:30:27 <ddarius> cknapp: Unlikely.
16:30:27 <cknapp> JFC1993: Probably none that you know...
16:30:35 <dons> ?userrs
16:30:35 <lambdabot> Maximum users seen in #haskell: 583, currently: 532 (91.3%), active: 16 (3.0%)
16:30:40 <JFC1993> I know a few.
16:30:41 <Cale> (even if it's not the case the other way around -- at least you can use a bit of topology to say which functions are Haskell ones :)
16:30:41 <cknapp> ddarius: ?
16:30:42 <dons> take that #rubylang
16:30:42 <blackh> JFC1993: It's an exceedingly good general purpose programming language.
16:30:52 <ddarius> cknapp: If you wanted to avoid that you should have never touched Haskell.
16:31:13 <Cale> JFC1993: It's similar to Miranda and Clean, and a little more distantly, but still fairly similar to ML and F#
16:31:25 <cknapp> ddarius: I should quit acedemia before I get sucked in if I want to avoid always having too many papers to read...
16:31:33 <ddarius> cknapp: Exactly.
16:31:33 <blackh> JFC1993: Haskell is similar to OCaml
16:31:50 <cknapp> I never said I expected to eventually *not* have too many papers to read....
16:31:55 <Cale> well, by ML, I'm including O'Caml, SML, and variants :)
16:31:56 <dons> just more popular :)
16:31:57 <ddarius> cknapp: I'm not even an academic and I have way, way, way too many papers to read.
16:32:30 <cknapp> But the average undergraduate shouldn't have 30+ papers on his "I need to read this over break" list.
16:32:48 <cknapp> Especially when all those papers are recent...
16:32:57 <JFC1993> cknapp what you taking?
16:33:00 <ddarius> cknapp: I have no idea how many papers I have pending to read.  Probably > 200 or more.
16:33:06 <Cale> I should form such a list. I either read papers when I find them, or forget about them.
16:33:10 <ddarius> I've read about 2000 or so.
16:33:11 <cknapp> ddarius: hmm...
16:33:39 <cknapp> Cale: I forget about them too... but I put them in a "papers to read folder", so when I get time, I look through and find the most interesting sounding one, and go with that...
16:33:41 <JFC1993> Don't you like reading papers?
16:33:43 <ddarius> Cale: There are times where I make lists.  Currently I just have a ToRead and a Read directory
16:33:43 <Cale> Then again, I've been in no-obligations limbo for a few years now...
16:33:56 <cknapp> JFC1993: I *do* like reading papers... it just takes time.
16:34:00 <wchogg> Cale: What do you mean?
16:34:03 <Cale> I really ought to get back into academia proper :)
16:34:09 <ddarius> Cale: Why?
16:34:31 <_ry> cabal keeps saying  "It requires base >=4" when i try to install packages - what does this mean?
16:34:41 <Cale> wchogg: Finished undergrad and haven't done too much since then, apart from studying on my own.
16:34:59 <Pseudonym> The purpose of undergrad, surely, is to bootstrap.
16:35:02 <Cale> I'm not very well cut-out for the real world.
16:35:18 <Cale> So, academia is pretty much the only way I can expect to remain alive :)
16:35:19 <wchogg> Cale:  Heh.  Trying to work in the software industry?
16:35:20 <Pseudonym> Cale is like an amateur version of Dijkstra.
16:35:20 <tromp> time to order me some RWH
16:35:21 <dcoutts> _ry: that means it needs ghc-6.10 which comes with base 4
16:35:24 <sinelaw> So the general idea of a "universal mapping" is one which takes some underlying object and creates the "minimal" categorial object that you can use for homorphisms into any other one?
16:35:26 <Pseudonym> Or semi-pro, I guess.
16:35:35 <dons> _ry, some library that depends on a new version of the base library
16:35:43 <Cale> wchogg: Actual software is too annoying.
16:35:48 <Pseudonym> Dijkstra was a theoretical physicist who became a theoretical programmer.
16:35:57 <dons> hehe
16:36:13 <JFC1993> Whos a theoretical physicist ?
16:36:14 <ddarius> sinelaw: "Minimality" is aspect.  Or more categorically, initiality.
16:36:20 <ddarius> +an
16:36:20 <Cale> wchogg: I love *thinking* about software...
16:36:27 <JFC1993> I want to do that or be a laywer.
16:36:36 <Pseudonym> JFC, bit of a difference there.
16:36:44 <Pseudonym> Unless you want to be a theoretical lawyer.
16:36:47 <sinelaw> heh
16:36:47 <cknapp> JFC1993: Dijkstra was; an important comptuer scientist
16:36:48 <JFC1993> lol
16:36:57 <tromp>  Erlang Programming is 54 cents cheaper than  Real World Haskell :)
16:37:01 <Cale> sinelaw: It's sort of an 'initial' or 'terminal' thing in an appropriately-constructed category.
16:37:10 <sinelaw> http://www.cs.utexas.edu/users/EWD/
16:37:18 <Pseudonym> tromp: You mean RWH is 54 cents more valuable.
16:37:24 <cknapp> @where RWH
16:37:24 <lambdabot> is http://www.realworldhaskell.org/blog/
16:37:27 <cknapp> Free!
16:37:29 <cknapp> :D
16:37:30 <ddarius> sinelaw: I often visualize such limits/colimits as pulling a cone back as far as it can.  This doesn't really help calculationally.  I'm not sure why I do it at all.
16:37:58 <Cale> ddarius: Well, it's the right thing to think of order-theoretically...
16:38:05 <dons> tromp: that's weird.
16:38:31 <sinelaw> i lost you both there :) i'm still in the definition-deficiency stage
16:38:33 <dons> for those 54 cents  you get monads and applicative functors though, so seems like a bargain.
16:38:45 <Cale> I've become somewhat enamoured with the idea of categories as a simultaneous generalisation of preorders and monoids.
16:39:04 <sinelaw> 54 cents pre or post recession?
16:39:11 <JFC1993> Dijkstra ?
16:39:11 <ddarius> sinelaw: If you have some experience with lattice theory or order theory, then category theory naturally generalizes it (and in a pretty particular way)
16:39:16 <Cale> sinelaw: Is the part about preorders before or after where you are in the book?
16:39:18 <dons> there's no recession in haskell land.
16:39:25 <dons> we're encapsulated from the effects :)
16:39:25 <sinelaw> before
16:39:34 <Cale> ah, good :)
16:39:37 <Pseudonym> dons, but so many financial services companies use it.
16:39:44 <Pseudonym> So we're not recession-proof.
16:39:44 <dons> oops. sorry
16:39:47 <ddarius> Cale: I agree with others that the preorder view is by far the more helpful, though the monoid view definitely has areas where it excels.
16:39:49 <dons> we accidentally the recession
16:40:20 <blackh> dons: you accidentally the verb
16:40:27 <dons> the whole recession, yes.
16:40:40 <sinelaw> as a CT newbie, the most natural view for me is a generalization of functions
16:40:50 <dibblego> @users
16:40:50 <lambdabot> Maximum users seen in #haskell: 583, currently: 532 (91.3%), active: 21 (3.9%)
16:41:05 <Pseudonym> Vegging out at work is hard when you have no proxy.
16:41:08 <Cale> sinelaw: Did he mention the logical point of view (not sure why I'm asking this, I could just check ;)
16:41:26 <sinelaw> i think he did very briefly
16:41:35 <ddarius> "deductive systems"
16:42:04 <sinelaw> i liked Cayley. it's a little bit reassuring
16:42:05 <Cale> If you have any logic, you can take the statements in it and make those your objects, and have a unique arrow A -> B if A entails B logically.
16:42:35 <sinelaw> yes
16:42:35 <Cale> Of course, this is just another take on the order-theory way of looking at things :)
16:42:50 <cknapp> Cale: COOL!
16:43:05 * cknapp doesn't know much about category theory....
16:43:26 <cknapp> Category theory is painfully general....
16:43:44 <sinelaw> btw, the original thing that got me into this, is patches in a version control system. patches are objects, if they are applied in order on something there is an arrow A->B
16:43:45 <Cale> Products in this category are the conjunction of two statements, and coproducts, the disjunction. You can see that the definition for product and coproduct turns almost directly into the axioms for those.
16:43:47 <Pseudonym> That's why I think there needs to be a book on category theory that's practical.
16:43:56 <Pseudonym> Less topology and more Haskell.
16:44:07 <ddarius> @google "Computational Category Theory"
16:44:11 <lambdabot> http://www.cs.man.ac.uk/~david/categories/
16:44:11 <lambdabot> Title: Categories
16:44:12 <ddarius> But ugly ML.
16:44:15 <Pseudonym> Yes.
16:44:20 <Cale> I think we also need a Haskell which is more CT-aware.
16:44:31 <Pseudonym> You need one that shows how to use Haskell's type system to do theorem proving for you.
16:45:03 <Cale> I want to be able to define categories by axioms, and get an applicative notation for them, and then give them semantics using functors to the ordinary Haskell category :)
16:46:04 <ddarius> Representability, is, in my opinion, the way to go there.  Representability essentially pushes constructions within a category into constructions on sets given "primitive" homs.
16:47:34 <sinelaw> i'm really curious to know why someone from the Education faculty ordered a book on CT
16:47:45 <sinelaw> (the only copy of Awodey here)
16:50:40 <_ry> the timber language looks extremely cool. is there a mailing list for it?
16:52:19 <Cale> Btw, I have a searchable PDF of Awodey which I got from my friend... it may actually even be from the author, I'm not sure.
16:52:43 <Pseudonym> BRB
16:52:44 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
16:53:00 <pejo> ry, in a few days.
16:53:41 <Cale> pejo: hm?
16:53:50 <sinelaw> Cale, i have the book here. It has a note saying that it was ordered (purchased for the library on the request of) someone from Education
16:53:56 <Cale> pejo: There will be a mailing list for timber soon?
16:54:13 <pejo> Cale, there's apparently demand. :-)
16:54:24 <sinelaw> what's timber?
16:54:37 <dons> a strict pure language designed for real time embedded systems.
16:54:44 <_ry> sinelaw: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/timberc-1.0.1
16:54:46 <dons> based on haskell and then o'haskell
16:55:01 <ddarius> Holy crap!  They released the compiler?
16:55:08 <dons> it would have been erlang if erlang didn't exist, imo :)
16:55:21 <Pseudonym> Yay.  I can web browse via SSH tunneling.
16:55:26 <Pseudonym> Slacking off, here I come...
16:55:26 <dons> ddarius: on hackage.
16:55:37 <pejo> ddarius, tomorrow. There's a mistake in the cabal file which makes it not work with cabal-install right now.
16:55:41 <sinelaw> look interesting
16:55:42 <ddarius> dons: They've been saying they were going to do that for like four years now.
16:55:47 <dons> ddarius: yup.
16:55:55 <dons> bunch of slackers ;)
16:55:59 * dons looks around the office
16:56:06 <Cale> Now all we need is HOPS :)
16:56:09 <Cale> hehe
16:57:07 <roconnor> > ln(2)
16:57:09 <lambdabot>   Not in scope: `ln'
16:57:12 <roconnor> > log(2)
16:57:12 <Cale> > log 2
16:57:14 <lambdabot>   0.6931471805599453
16:57:14 <lambdabot>   0.6931471805599453
16:57:22 <roconnor> > atanh(1/3)
16:57:24 <lambdabot>   0.3465735902799726
16:57:27 <roconnor> > atanh(1/3)*2
16:57:29 <lambdabot>   0.6931471805599452
16:57:32 <Cale> (I hate that ln notation and am happy that Haskell does not use it ;)
16:57:55 <roconnor> I hate log notation, and am upset that Haskell uses it
16:58:02 <sinelaw> ;(
16:58:08 <Pseudonym> Yeah, log should be base 2 by default.
16:58:18 <sinelaw> and 2 should be 1
16:58:19 <Cale> I think we should abolish every other base but the natural one.
16:58:23 <roconnor> log is base 10, ln is base e, and lg is base 2
16:58:25 <Cale> The rest are just constant multiples.
16:58:39 <roconnor> actually I hate log entirely
16:58:59 <Pseudonym> Base 10 is pretty much useless.
16:59:03 <roconnor> log should be a function ([0,1] -> C/{0}) -> C
16:59:07 <cknapp> Yeah... pretty much useless
16:59:11 <sinelaw> Pseudonym, i have 10 fingers
16:59:11 <oklopol> base 10 should be killed
16:59:13 <Pseudonym> Actually, log should ve left unspecified.
16:59:21 <roconnor> or a binary function in case of real numbers
16:59:37 <Pseudonym> It's logarithm in _some_ base.
17:00:06 <roconnor> Pseudonym: I'm good with that
17:00:09 <luite> is it possible to get the inferred type of a function f in ghci when used in a 'outerf = ... where f =' context?
17:00:29 <roconnor> > logBase 10 3 - logBase 10 4
17:00:31 <lambdabot>   -0.12493873660829985
17:00:35 <roconnor> > logBase 2 3 - logBase 2 4
17:00:37 <lambdabot>   -0.4150374992788437
17:00:43 <Pseudonym> sinelaw: That's nice that you have 10 fingers.  Not everyone has.
17:00:45 <roconnor> oops
17:00:50 <roconnor> > logBase 10 3 / logBase 10 4
17:00:51 <Pseudonym> Accidents happen.
17:00:51 <lambdabot>   0.7924812503605783
17:00:57 <roconnor> > logBase 2 3 / logBase 2 4
17:00:58 <lambdabot>   0.7924812503605781
17:00:59 <ddarius> > log -3 :: Complex Double
17:01:00 <Cale> luite: hmm... I was going to say no, but possibly using the new debugger...
17:01:00 <lambdabot>   Couldn't match expected type `Complex Double'
17:01:15 <ddarius> > log (-3) :: Complex Double
17:01:16 <lambdabot>   1.0986122886681098 :+ (-3.141592653589793)
17:01:33 <Cale> luite: Usually you either lift the definition out, or occasionally, you can just have outerf = f temporarily to see what the type is.
17:01:42 <ddarius> We should teach kids binary so they can count up to 1023 on their fingers.
17:02:15 <lament> ddarius: 132
17:02:31 <SubStack> some of them can even count to 2047 or 4095
17:02:49 <SubStack> and there's tristates too
17:02:59 <SubStack> > 3 ^ 10
17:03:01 <lambdabot>   59049
17:03:04 <luite> Cale: yes, I usually do that, but when I add the inferred type of that function (when lifted out) as a type signature to the same function in the where context, I get some compile error
17:03:33 <ddarius> 136 would be a not particularly nice number.
17:03:33 <Cale> luite: Maybe there's some binding shadowing going on?
17:03:47 <ddarius> Oh wait, lament was right.
17:04:35 <Cale> > 14^2 - 1
17:04:37 <lambdabot>   195
17:04:56 <semmons99> I have a factorial function as follows
17:04:58 <semmons99> fact :: [Int]
17:05:03 <semmons99> fact = 1 : [ n * (fact !! (n - 1)) | n <- [1..] ]
17:05:14 <Cale> !! is slow
17:05:16 <semmons99> what do I need to do to convert it to
17:05:20 <semmons99> fact :: [Integer]
17:05:22 <Cale> you should use map
17:05:28 <luite> Cale: hm, I don't think there is. I should be able to get rid of any shadowing if I use unique identifiers, right?
17:05:35 <Cale> er, zipWith (*)
17:05:38 <Pseudonym> (!!) has the same complexity as just recomputing.
17:05:49 <Cale> luite: yeah
17:05:58 <Cale> luite: it was just an idea...
17:06:08 <semmons99> thanks, I'll try that
17:06:19 <Cale> > let fact = 1 : zipWith (*) fact [1..] in fact
17:06:20 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
17:07:19 <semmons99> Cale++
17:07:26 <Cale> semmons99: You can either leave the type signature out, in which case, Integer will be picked by numeric defaulting, or you can explicitly write fact :: [Integer]
17:07:27 <cknapp> seriously...
17:08:53 <Cale> luite: hmm... do you have scoped type variables on? I can't think of many reasons that it would fail to type...
17:08:58 <ikkebr> [1,2,4,8..]
17:09:18 <Cale> > iterate (*2) 1
17:09:19 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
17:09:24 <EvilTerran> > scanl (*) 1 [1..]
17:09:26 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
17:10:03 <EvilTerran> (yay golf)
17:10:09 <cknapp> :)
17:10:13 <mokus> semmons99: the reason you couldn't make the version using (!!) have type [Integer] is because (!!) :: [a] -> Int -> a
17:10:31 <mokus> which nails down the type of the whole expression to [Int]
17:10:52 <Cale> > let primes = 2 : [p | p <- [3,5..], isPrime p]; isPrime n = not (any (\p -> n `mod` p == 0) (takeWhile (\p -> p^2 <= n) primes)) in primes
17:10:53 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:11:00 <semmons99> could I somehow cast the results of (!!) to Integer?
17:11:18 <EvilTerran> semmons99, what type is it at the moment?
17:11:19 <mokus> what you'd want is to convert the 2nd param from integer
17:11:35 <Peaker> hmm.. what is cool about timber? It seems like a step back from FRP
17:11:35 <Cale> semmons99: Well, that's not the problem, it's that you need to convert your Integer to an Int to use it with (!!)
17:11:50 <Cale> semmons99: fromIntegral can do that
17:11:58 <semmons99> okay let me try that
17:11:59 <dmwit> :t genericIndex
17:12:00 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
17:12:01 <Cale> semmons99: But you should always look for a way to avoid using !!
17:12:21 <Cale> Because  xs !! n  takes O(n) steps to evaluate.
17:12:23 <Axman6> Cale: why? just curious
17:12:24 <dmwit> But if you're trying to use indices that would overflow an Int... you're doing it wrong.
17:12:26 <Axman6> ah
17:12:31 <luite> Cale: ah, I think there is just something wrong with the syntax of my type signature
17:13:32 <Cale> dmwit: The problem isn't with using indices that would overflow an Int so much as the fact that the usual !!, length, etc. impose Int constraints on things unnecessarily.
17:13:58 * dmwit nods
17:14:02 <dmwit> I've run into the problem myself.
17:14:04 <Cale> Besides, shouldn't it really be Word32 or something, if we really want to use an appropriate small type?
17:14:41 <Peaker> If Word was named UInt, it would probably be more clear
17:14:50 <pejo> Peaker, step back in what sense?
17:15:18 <Peaker> pejo: reverting to writing imperative callbacks, instead of functional event transformers
17:15:29 <Peaker> Cale: Maybe you want the "machine" UWord, and not commit to a size like 32?
17:15:40 <Cale> Peaker: sure, that'd do as well.
17:15:59 <Cale> Peaker: But really, I think it should be generic.
17:16:00 <Peaker> Cale: Aside for signed-ness, is there a difference between Int and machine-sized word?
17:16:14 <luite> how can I specify a type signature for ... where f x = do {...} :: (Monad m) => a -> m a  ?  (this works: where f = (\x -> do {...}) :: (Monad m) => a -> m a  , but I don't want to use a lambda if it's not necessary)
17:16:21 <Peaker> Cale: performance considerations, maybe?
17:16:33 <mm_freak> let 2 : filter isPrime [3..]
17:16:43 <Peaker> Cale: (Given that to address something in an address space of a limited size, why not use a limited type?)
17:16:59 <mm_freak> > let 2 : filter isPrime [3..]; isPrime n = and $ map (\x -> n `rem` x /= 0) $ takeWhile (\x -> x*x <= n) primes in primes
17:17:00 <lambdabot>   <no location info>: parse error on input `;'
17:17:13 <mm_freak> > let primes = 2 : filter isPrime [3..]; isPrime n = and $ map (\x -> n `rem` x /= 0) $ takeWhile (\x -> x*x <= n) primes in primes
17:17:14 <Axman6> luite: f x = do {..; return $ g x;}?
17:17:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:17:22 <Cale> Peaker: But often this is a premature optimisation, and via type inference, you end up silently screwing up some other calculation which does need big numbers.
17:17:34 <EvilTerran> luite, ... where f :: Monad m => a -> m a; f x = do ...
17:17:35 <luite> Axman6: no, I just mean the syntax of the type signature
17:17:35 <ikkebr> [1,1,2,3,5..]
17:17:50 <luite> EvilTerran: ah, thanks
17:18:02 <Cale> Peaker: I'm not saying there shouldn't be a specialised version of length, etc for when the type desired is an Int
17:18:16 <Cale> Peaker: But it should be generic.
17:18:51 <Cale> > fix ((0:) . scanl (+) 1)
17:18:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:19:19 <Cale> > let fibs = 0 : 1 : zipWith fibs (tail fibs) in fibs
17:19:21 <lambdabot>   Couldn't match expected type `[a]'
17:19:25 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:19:26 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:19:31 <chessguy> does cabal install automatically get dependencies?
17:19:37 <Cale> chessguy: yep
17:19:43 <gwern> hm, a post to RISKS on Data.Time
17:19:46 <chessguy> hm, that's nice
17:19:56 <Pseudonym> Oh, cool.
17:19:59 <Pseudonym> What's the RISK?
17:20:12 <Cale> mm_freak: You can use [3,5..] for a small boost in speed :)
17:20:34 <pejo> Peaker, does FRP depend on laziness in any way?
17:20:47 <Peaker> pejo: perhaps a particular implementation, but not in general
17:20:56 <mm_freak> Cale: well, you could just as well add a wheel =)
17:21:03 <Cale> Indeed.
17:21:14 <mm_freak> should be easy to do
17:21:39 <Peaker> brb
17:21:42 <Cale> Though making bigger and bigger wheels and switching between them as you generate primes seems tricky to get good performance from :)
17:21:49 <pejo> Peaker, if you feel strongly about using FRP your best bet is probably to stick with Haskell. It should be possible to implement in Timber too though.
17:21:59 <gwern> http://groups.google.com/group/comp.risks/browse_thread/thread/ca6ec81b4a7426aa#
17:22:02 <gwern> 'Actually, though, as well as being more than a little pedantic, this is I
17:22:05 <gwern> think a fairly brilliant example of good risk management: by forcing
17:22:07 <gwern> programmers to stop and make a choice between a DiffTime (which includes
17:22:10 <gwern> leap seconds) and a NominalDiffTime (which more or less pretends they don't
17:22:12 <gwern> exist), it also forces them to think for a moment about what exactly they're
17:22:15 <gwern> doing.
17:22:16 <Peaker> pejo: what is the advantage/novelty of timber? Glances at its examples seem ... not very interesting?
17:22:17 <gwern> So kudos to Ashley Yakeley, the rather smart author of this library. '
17:22:40 <Peaker> pejo: From first glance, it seems like Haskell actions and standard callbacks..
17:22:46 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/ <- I feel compelled to point this out.
17:22:56 <pejo> Peaker, there aren't that many strict and pure functional languages out there, I guess. Subtyping in HM isn't widely implemented either.
17:23:07 <mm_freak> Cale: after about three or four factors in the wheel, the difference becomes neglible anyway
17:23:23 <mm_freak> so you wouldn't want a dynamic wheel =)
17:23:38 <mm_freak> (in fact, this algorithm _is_ some sort of a dynamic wheel)
17:23:54 <gwern> 'We normally don't think much about this, but lately I've been doing a lot of
17:23:54 <gwern> programming in Haskell, and the folks who built the libraries being much too
17:23:54 <gwern> smart for their own (or, anyway, my) good, make this clear, not to mention
17:23:54 <gwern> push it a bit in your face:
17:24:05 <Peaker> pejo: oh, I see. I thought it was tackling the FRP problem domain, not the whole pure-strict-language domain
17:24:13 <Cale> mm_freak: yeah
17:24:35 <Cale> mm_freak: You end up removing too little to justify the additional memory cost.
17:24:36 <Pseudonym> Haskell library developers: Smarter than you.
17:24:49 <mm_freak> exactly
17:25:33 <pejo> Peaker, I'm not sure what "Haskell actions" are, but there's a short paper available about the reactive objects (of both O'Haskell and Timber). That paper has been discussed on LtU, with some clarifying comments.
17:25:36 <Pseudonym> BTW, I think that one of the most under-appreciated features of Haskell is also one of the simplest, and it's one that any programming language could implement but few do.
17:25:41 <Pseudonym> And that's newtype.
17:25:48 <Peaker> pejo: Haskell actions are values in a monad (usually the IO monad)
17:25:52 <Pseudonym> Compiler-checked type synonyms that have no runtime cost.
17:25:56 <gwern> what's so great about newtype?
17:26:20 <Philippa_> isomorphism
17:26:24 <Pseudonym> Right.
17:26:26 <Philippa_> as opposed to equality
17:26:29 <Pseudonym> And one that's free at run time.
17:26:36 <Philippa_> of course, with typeclasses we rather need it...
17:26:47 <Pseudonym> And, of course, phantom types if you want that too.
17:27:09 <Peaker> Philippa_: The instance declaration for "data" and "newtype" looks the same - the difference in handling bottoms seems like a nuance to me?
17:27:09 <mmorrow> if it wasn't for newtypes, things would be a lot less swell
17:27:14 <Pseudonym> But even without phantom types and typeclasses, newtype is so simple yet so useful.
17:27:34 <Cale> It's not really that hard for almost any programming language to add algebraic datatypes, and it's not like they're a new idea either.
17:27:36 <gwern> man, I want to add that link to proggit, but proggit is down quite badly
17:27:47 <Pseudonym> Cale, I think the problem is pattern matching.
17:27:51 <pejo> Peaker, well. The idea is to get rid from the evil I. http://www.csee.ltu.se/~nordland/EvilI.pdf
17:27:56 <Pseudonym> Without pattern matching, algebraic data types are not so useful.
17:28:01 <Cale> I suppose.
17:28:35 <Pseudonym> Have you ever tried writing a compiler with the visitor pattern?
17:28:39 <mmorrow> argh, after programming in haskell for a bit, i'm physically pained by programming in langs that don't have pattern matching (which is, like, pretty much all of them)
17:28:51 <Pseudonym> It's pretty horrid.
17:28:52 <Peaker> pejo: added to queue
17:29:29 <pejo> Peaker, this isn't my area of expertise at all though, so don't trust my word blindly.
17:29:35 <Pseudonym> I'm seriously considering re-implementing my RSL compiler this time to use view patterns.
17:29:55 <mmorrow> RSL?
17:30:01 <Pseudonym> RenderMan shading language.
17:30:07 <mmorrow> ah, cool
17:30:35 <Pseudonym> I have it sitting around, but it's currently targeting the renderer released by a former employer.
17:30:40 <Pseudonym> Which is commercial in confidence.
17:30:49 <daf> pattern matching is addictive
17:30:55 * Pseudonym keeps meaning to target Aqsis
17:32:51 <EvilTerran> unification is nearly as bad
17:32:58 <gwern> @tell dons interesting props to haskell time libaries: http://groups.google.com/group/comp.risks/browse_thread/thread/ca6ec81b4a7426aa
17:32:58 <lambdabot> Consider it noted.
17:33:14 <Pseudonym> That should probably get mentioned in HWN, too.
17:33:52 <ekidd> I just ported tmortel's typo:haskell plugin to Mephisto.
17:34:02 <basvandijk> Hello, I've a datatype that derives "Typeable" and "Data" using the "DeriveDataTypeable" extension. In my .cabal I have "Build-Depends: base >= 2". However when I "run-ghc Setup.lhs build" I get a "Could not find module `Data.Generics': it is a member of package base-3.0.3.0, which is hidden". What can be the problem?
17:34:20 <gwern> ekidd: typo:haskell?
17:34:37 <ekidd> tmoertel_away: Are you around?
17:34:51 <ekidd> gwern: http://blog.moertel.com/articles/2006/11/01/adding-haskell-syntax-highlighting-to-the-typo-blogging-system
17:35:00 <dcoutts> basvandijk: did you put the build-depends in the global section or the lib/exe section?
17:35:14 <ekidd> gwern: Very nice for people using the Typo blogging system.
17:35:15 <Cale> basvandijk: Perhaps it's picking base == 4 ?
17:35:38 <dcoutts> ah, yes, that's probably it
17:35:40 <gwern> ekidd: ironically, I opened that in dillo and so your haskell is all monochromatic for me :)
17:35:58 <basvandijk> dcoutts: in the global section
17:36:00 <Cale> basvandijk: Data.Generics got split into the syb package
17:36:23 <mmorrow> yeah, if you're gonna use base==4 juts add "syb" to the deps
17:36:28 <mmorrow> *just
17:36:37 <dcoutts> basvandijk: ok, make sure it's in the lib/exe section, and you might want to use build-depends: base >= 2 && < 4
17:36:52 <gwern> hm, sounds likely. base >= 2 turns into base == 4, and then syb isn't listed.
17:37:00 <gwern> (I'll have to remember that for the future)
17:37:05 <basvandijk> dcoutts: ok
17:37:21 <byorgey> @seen wy
17:37:22 <lambdabot> wy is in #haskell. I don't know when wy last spoke.
17:37:32 <BMeph> tromp: When are you writing a BCL plugin for lambdabot? ;)
17:37:35 <dcoutts> gwern: it's actually worse than that. cabal configure does one thing, cabal install another.
17:37:59 <mmorrow> so using base==4 is frowned upon currently? (or so i think i've gathered)
17:38:22 <dcoutts> mmorrow: if you need base 4 then use base == 4.*
17:38:34 <mmorrow> ah, i see
17:38:40 <gwern> dcoutts: tell me about it! I've suffered all sorts of problems with darcs cabal/darcs cabal-install/ghc 6.10
17:38:56 <dcoutts> gwern: I hope they're all reported :-)
17:39:06 <gwern> (like this bloody problem that every package I want to cabal-install eventually depends on packedstring/template-haskell)
17:39:18 <gwern> dcoutts: speaking of which, when do we get a sane th package? :)
17:39:40 <dcoutts> gwern: when you propose the change on the TH list and get resounding agreement ;-)
17:39:41 <mmorrow> gwern: what's the problem with that dep with cabal-install?
17:39:55 <mmorrow> (not that i'm saying there isn't one)
17:40:04 <mmorrow> out of curiosity
17:40:15 <gwern> dcoutts: but I've only been ignored. I forwarded my email like a week ago
17:40:27 <dcoutts> gwern: I didn't see any email to the template haskell list
17:40:29 <gwern> mmorrow: packedstring doesn't cabal install because of base problems
17:40:48 <dcoutts> gwern: oh, I'm wrong, there was
17:40:54 <mmorrow> don't you /already/ have it by default?
17:40:55 <dcoutts> gwern: ok, then make a libraries proposal
17:41:46 <gwern> mmorrow: no, apparently. cause everytime I try to cabal-install yi or gitit or happs or... the first deps are packedstring and cabal-install
17:41:52 <mmorrow> /usr/local/ghc/ghc-6.10.1/lib/ghc-6.10.1/./package.conf:
17:41:53 <mmorrow>     packedstring-0.1.0.1
17:41:58 <mmorrow> it came with my ghc
17:42:11 <gwern> even 'cabal install packedstring --constraint="base < 4"' doesn't work  - Data.Data is still hidden in base
17:42:35 <dcoutts> gwern: that's a bug, install ignores --constraint atm.
17:42:38 <mmorrow> i've found that adding "syb" to the build deps fixes that
17:42:41 <gwern> -_-
17:42:41 <dcoutts> it's on the TODO list
17:43:01 * gwern shakes fist in dcoutts's direction
17:43:15 <dcoutts> well, it's more of a missing feature than a bug
17:43:34 <gwern> if a program claims to do something, and it doesn't, it's a bug
17:43:37 <dcoutts> but it'd certainly be more orthogonal and useful for it to be there
17:43:39 <Pseudonym> BBS
17:43:49 <mmorrow> i think i read also that Data.Data doesn't exist (and is a bug) ((either that, or it just hasn't been added yet, but its name has))
17:44:07 <gwern> 'here's an program (OS, editor, browser...) for you. it doesn't run or do anything at all. but that's not a bug!'
17:44:39 <dcoutts> gwern: ok, advertising bug, but certainly it's a missing useful feature
17:44:49 <dcoutts> mmorrow: the module Data.Data exists in base-4
17:45:38 <mmorrow> dcoutts: ah, i see (in the syb pkg then i take it). i must have read that it doesn't exists in base-3
17:46:07 <dcoutts> mmorrow: no, in base-4 itself. It doesn't exist in base 3.
17:46:31 <dcoutts> mmorrow: the Data.Data is new and is the only thing relating to syb left in base 4, the rest is in the external syb package
17:46:43 <mmorrow> hmm, odd.
17:46:44 <mmorrow> ohh
17:47:23 <mmorrow> hmm, whenever i get that error, i just add syb to the build-depends: and it works. dunno really why, but i'm not complaining ;)
17:48:03 <chessguy> err, why can't i do "newtype Pattern a = Gr (a -> Bool) (a -> a -> Bool)"
17:48:40 <mmorrow> a newtype constructor can only has one arg
17:49:06 <mmorrow> you could put it in a tuple, but then you might as well just use data
17:49:07 <chessguy> so how do i say that they are isomorphic but distinguishable?
17:49:34 <mmorrow> data Pattern a = Gr (a -> Bool) (a -> a -> Bool)  -- ?
17:49:52 <chessguy> but Gr is from a library, it's not a new constructor
17:50:17 <Cale> chessguy: Oh, in that case, you forgot the newtype constructor
17:50:33 <Cale> newtype Pattern a = Pattern (Gr (a -> Bool) (a -> a -> Bool))
17:50:40 <mmorrow> ah
17:50:43 <chessguy> oh
17:50:56 <chessguy> oh yeah, i guess i need something to pattern match on
17:51:06 <Cale> newtype mostly behaves like a one-constructor-with-one-field data declaration.
17:52:15 <byorgey> but the Pattern constructor doesn't exist at runtime.
17:52:32 <byorgey> whereas it would with a data declaration.
17:54:50 <mmorrow> dcoutts: oh, i think i just understood what you just said. so you mean that some pkg needs Data.Data, but base-3 was chosen, so then by me adding syb to the build-depends i'm both forcing base-4 and adding the dep (syb) it would've asked for had base-4 been chosen initially (?)
17:54:58 <cknapp> byorgey: so it's more efficient to use  newtype?
17:56:45 <EvilTerran> http://haskell.org/haskellwiki/Newtype <- relevant
17:57:22 <EvilTerran> ?bot
17:57:22 <lambdabot> :)
18:00:28 <Cale> cknapp: typically... technically the semantics are a little different too
18:00:43 <Cale> cknapp: Certainly more memory efficient.
18:01:07 <Cale> Another good reason for newtype is that you have newtype-deriving
18:01:13 <dneuer> hi all
18:01:21 <Cale> Which can derive almost any typeclass which is implemented for the original type
18:01:26 <Cale> hello dneuer
18:05:24 * EvilTerran seems to recall confounding NewtypeDeriving with "newtype Mu f = In { out :: f (Mu f) } deriving (anything)"
18:05:53 <chessguy> @type any
18:05:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:06:11 <dolio> It's not surprising you can't derive things for that type.
18:06:23 <EvilTerran> yeah, i'm not sure if an "instance Show (f (Mu f)) => Show (Mu f)" would work, even with FlexibleInstances
18:06:36 <EvilTerran> it's undecidable for starters
18:06:36 <dolio> It does. It feels kind of messy, though.
18:06:37 <solrize> does anyone here use the hackage json module?
18:07:20 <dolio> What you really want is something like 'instance (forall a. Show a => Show (f a)) => ...'.
18:08:00 <EvilTerran> does the circularity between mine and, say, {instance Show a => Show (Id a) where show (Id a) = "Id " ++ show a} get resolved correctly by ghc?
18:08:28 <adu> hey
18:08:47 <adu> I'm really tired, how do I convert (Integer -> Double)?
18:08:56 <gwern> fromInt?
18:08:59 <EvilTerran> ?type fromInteger
18:09:00 <lambdabot> forall a. (Num a) => Integer -> a
18:09:03 <adu> ah
18:09:04 <adu> thanks
18:09:20 <EvilTerran> or fromIntegral
18:09:30 <gwern> > fromInteger ("1" :: Int) :: Double
18:09:31 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
18:09:37 <gwern> > fromInteger (1 :: Int) :: Double
18:09:38 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
18:09:45 <gwern> > fromIntegral (1 :: Int) :: Double
18:09:47 <lambdabot>   1.0
18:09:51 <gwern> (there we go)
18:09:54 <EvilTerran> ?type fromIntegral
18:09:55 <lambdabot> forall a b. (Num b, Integral a) => a -> b
18:10:06 <dolio> EvilTerran: Show a => Show (Id a) isn't really circular. It's more like structural induction.
18:10:27 <dolio> EvilTerran: Show (f (Mu f)) => Show (Mu f) is more like general recursion.
18:10:29 <EvilTerran> dolio, i mean that combined with "instance Show (f (Mu f)) => Show (Mu f)" would contain a circularity
18:10:51 <EvilTerran> Show (Mu Id) => Show (Id (Mu Id)) => Show (Mu Id)
18:11:27 <dolio> Oh. Yeah, the instance works and everything.
18:11:35 <EvilTerran> that's nifty
18:13:17 <dolio> I mean, despite it being like general recursion, it is just general recursion. :)
18:13:31 <dolio> If it didn't work, I doubt a lot of Oleg's type hackery would work. :)
18:14:04 <dolio> (Like implementing the lambda calculus at the type level).
18:14:47 <dolio> Maybe a lot would work, but certain things presumably wouldn't.
18:14:55 <mmorrow> ooh, speaking of Mu i just had to battle out a Show instance for that earlier (i'd seen that instance in here a while ago, but couldn't recall it..)  http://hpaste.org/12850
18:15:23 <mmorrow> that Show instance also is a "proper" one (it'll parenthesize like a derived one would)
18:15:26 <dolio> > In Nothing
18:15:27 <lambdabot>       No instance for (Show (Mu Maybe))
18:15:27 <lambdabot>        arising from a use of `show' a...
18:15:41 <dolio> , Mu Nothing
18:15:47 <lunabot>  luna: Not in scope: data constructor `Mu'
18:15:49 <adu> omg, where is an uncurry3 when you need it
18:15:51 <mmorrow> oh snap, we need showable Mu now!
18:15:58 <dolio> :)
18:16:06 <Cale> adu: lambda?
18:22:38 <adu> ok
18:23:18 <dolio> > (length "\(x,y,z) -> foo x y z", length "uncurry3 foo")
18:23:19 <lambdabot>   <no location info>:
18:23:19 <lambdabot>      lexical error in string/character literal at chara...
18:23:39 <dolio> > (length "\\(x,y,z) -> foo x y z", length "uncurry3 foo")
18:23:40 <lambdabot>   (21,12)
18:26:30 <BMeph> Is there a class like Enum, but with succ/pred/fromEnum/toEnum acting as if they were defined modulo? :)
18:27:04 <dons> pejo: this guy sbrown yammering on about whether timber is 'pure' is just nuts!
18:27:04 <lambdabot> dons: You have 13 new messages. '/msg lambdabot @messages' to read them.
18:27:32 <BMeph> dons: SUTL! :)
18:27:45 <mmorrow> dolio: i just added these two modules to the lunabot's scope: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=552
18:27:58 <dons> btw, people here played with gitit?
18:28:06 <dons> it is awesomely easy to deploy. very impressive stuff
18:28:07 <mmorrow> , toL [0..9]
18:28:17 <lunabot>  Mu (Cons 0 (Mu (Cons 1 (Mu (Cons 2 (Mu (Cons 3 (Mu (Cons 4 (Mu (Cons 5 (M...
18:28:27 <mmorrow> , toL [0..4]
18:28:32 <lunabot>  Mu (Cons 0 (Mu (Cons 1 (Mu (Cons 2 (Mu (Cons 3 (Mu (Cons 4 (Mu Nil))))))))))
18:28:38 <Axman6> what's Mu?
18:28:47 <mmorrow> newtype Mu f = Mu (f (Mu f))
18:29:13 <mmorrow> , muT [0..5]
18:29:17 <lunabot>  Mu (T (Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (...
18:29:27 <Axman6> >_<
18:29:32 <dolio> Nice.
18:29:55 <dolio> , src ''T
18:30:01 <lunabot>  data T a b = Nil | Tip a | T b b
18:30:08 <mmorrow> dolio: that function `muT' was what prompted all of this
18:30:23 <mmorrow> dolio: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=552
18:30:49 <mmorrow> i wanted to be able to fold up a list into a perfectly (as possible) balanced binary tree
18:31:31 <Axman6> ah, how handeh
18:31:44 <mmorrow> , (roseT . muT) [0..5]
18:31:44 <Axman6> , muT [0..3]
18:31:46 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe a -> b'
18:31:50 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
18:32:04 <mmorrow> , (roseT (const 0) . muT) [1..5]
18:32:08 <lunabot>  Node {rootLabel = 0, subForest = [Node {rootLabel = 0, subForest = [Node ...
18:35:52 <Axman6> , muT [0..2]
18:35:57 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (Tip 2)))
18:36:11 <mmorrow> , ppDoc `fmap` foldT [|0|] (\a b -> [|($a,$b)|]) (mapMuT lift . muT $ [0..7::Int]) id
18:36:15 <lunabot>  (((0, 1), (2, 3)), ((4, 5), (6, 7)))
18:36:32 <mmorrow> , muT [0..3]
18:36:36 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
18:50:58 <dolio> mmorrow: Did you ever get your lunabot @type in?
18:51:58 <hml> are there any "CAD for Microfluidics" programs written up in Haskell? If not, what's the closest? Lava for FPGA ?
18:53:44 <BMeph> mmorrow: Have you considered adding a Binary Lambda Calc, or Binary Comb Logic module for luna? :)
18:55:44 <solrize> :t lookup
18:55:45 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:56:12 <solrize> @hoogle forall a b. (Eq a) => a -> [(a,b)] -> [b]
18:56:12 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
18:56:13 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
18:56:13 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
19:07:35 <chessguy> @pl \x y z -> f (e x z) (e y z)
19:07:35 <lambdabot> (. e) . ap . (f .) . e
19:08:16 <chessguy> @pl \x y z -> e x z)&& e y z
19:08:17 <lambdabot> (line 1, column 16):
19:08:17 <lambdabot> unexpected ")"
19:08:17 <lambdabot> expecting variable, "(", operator or end of input
19:08:31 <chessguy> @pl \x y z -> e x z && e y z
19:08:32 <lambdabot> (. e) . ap . ((&&) .) . e
19:08:41 <BMeph> @pl \x y z -> e x z (e y z)
19:08:41 <lambdabot> (. e) . ap . e
19:09:41 <pumpkin> :t (f .) . (. g)
19:09:43 <lambdabot> forall c a b c1. (SimpleReflect.FromExpr b, Show a, SimpleReflect.FromExpr c, Show c1) => (b -> c1) -> a -> c
19:09:59 <pumpkin> :)
19:10:15 <pumpkin> > (f .) . (. g) (+ 1) 1
19:10:16 <lambdabot>       Overlapping instances for Show (a1 -> a -> c)
19:10:17 <lambdabot>        arising from a use...
19:10:21 <pumpkin> > (f .) . (. g) (+ x) y
19:10:22 <lambdabot>   Couldn't match expected type `a1 -> a -> b'
19:11:28 <wagle> hey pumpkin, what do you know about recovering hfs+ filesystems that had a new hfs+ written over the top of them?
19:11:43 <pumpkin> sounds painful
19:12:09 <pumpkin> not sure there's much to do... you might have to search by filetype and hope your files aren't too fragmented
19:12:16 <pumpkin> the metadata might be mostly gone, not sure
19:12:32 <pumpkin> run strings over your filesystem to see if your filenames are still there, that'll be a good sign
19:13:33 <wagle> tried two $100 recovery things, one couldnt find anything important, the other found a million files with some of my stuff buried in the middle of the mostly unnamed files
19:13:54 <wagle> search by contents..
19:14:32 <pumpkin> with hfs+ in my particular case, I found there are some structures you can pick out even if the metadata structure is screwed
19:14:39 <wagle> but it has a notion of the kinds of files its looking for..  it found some java source, but not any of the tcl source
19:17:09 <solrize> copy the entire drive over to another drive before you start messing with it
19:17:30 <Axman6> wagle: techtool pro might be able to do something, along with the other file recovery tool. not sure what this has to do with haskell though
19:17:39 <pumpkin> yeah, definitely... I made a 160gig disk image of my broken drive and made it read-only
19:18:46 <p_l> wagle: Check if there is a fsdb/debugfs like program for HFS+ and if it does have second superblock somewhere
19:18:51 <hml> http://hpaste.org/12872 <-- please help w/ simple newbie error
19:19:29 <p_l> wagle: Did wonders when >10M in the beginning of my ext3 partition got written with zeros thanks to idiotic fsck
19:20:53 <jsn> hml: remove the in
19:21:14 <hml> jsn: that fixed it; thanks; care to tell me why i'm screwing up>?
19:21:53 <blackh> jsn: The syntax for 'let' is slightly different in a do block - no 'in'.
19:22:05 <Axman6> hml: i'd probably use a where clause there
19:22:24 <jsn> blackh: yes, i know :)
19:22:27 <hml> Axman6: can you append to my hpaste code?
19:22:36 <blackh> blackh: Who said that?
19:22:38 <hml> I did
19:22:40 <hml> i'm the newb
19:22:45 <Axman6> actually, i don't think it'd work there
19:22:48 <wagle> Axman6, i'm amusing myself trying to wrap my brain around writing an ext2 recovery tool..  pumpkin mentioned he knew something about hfs+
19:23:04 <wagle> ext2 recovery tool in haskell, that is
19:23:13 <Axman6> nice
19:23:28 <hml> how do I convert a string to an integer? i.e. I wnat "0" -> 0, "1" -> 1, "2" -> 2 ...
19:23:35 <pumpkin> read
19:23:35 <Axman6> read
19:23:36 <pumpkin> :: Int
19:23:38 <roconnor> read
19:23:42 <Axman6> > read "0" :: Integer
19:23:42 <wagle> gotta figure out things like how to deal with limited memory
19:23:43 <lambdabot>   0
19:23:51 <wagle> > fix read
19:23:52 <lambdabot>   "* Exception: stack overflow
19:24:00 <pumpkin> :P
19:24:01 <jsn> hml: use reads if you want safety
19:24:05 <jsn> :t reads
19:24:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:24:21 <roconnor> > reads "0" :: ReadS Integer
19:24:22 <Axman6> why does it use a list?
19:24:22 <lambdabot>   Couldn't match expected type `ReadS Integer'
19:24:25 <pumpkin> yeah, read is kinda icky
19:24:44 <roconnor> Axman6: all possible parses
19:24:59 <Axman6> > reads "0a" :: [(Integer,String)]
19:25:01 <lambdabot>   [(0,"a")]
19:25:07 <jsn> Axman6: the list is for alternative parses in ReadS
19:25:17 <Axman6> eh?
19:25:29 <Axman6> i'm not sure what you mean
19:25:32 * roconnor tries to think of an example with multiple parses
19:25:54 <Axman6> > reads "01047" :: [(Integer,String)]
19:25:56 <lambdabot>   [(1047,"")]
19:26:03 <Axman6> > reads "0x1047" :: [(Integer,String)]
19:26:05 <lambdabot>   [(4167,"")]
19:26:32 <jsn> ReadS is a parser that allows multiple valid alternatives
19:26:53 <pumpkin> > reads "0123" :: [(Integer, String)]
19:26:55 <lambdabot>   [(123,"")]
19:26:59 <jsn> if you read the code for ReadP, iy makes more sense
19:27:14 <Axman6> @where ReadP
19:27:14 <lambdabot> I know nothing about readp.
19:27:28 <Axman6> @src ReadP
19:27:28 <lambdabot> Source not found. stty: unknown mode: doofus
19:27:31 <jsn> @hoogle ReadP
19:27:32 <lambdabot> module Distribution.Compat.ReadP
19:27:32 <lambdabot> module Text.ParserCombinators.ReadP
19:27:32 <lambdabot> Distribution.Compat.ReadP type ReadP r a = ReadP a
19:27:32 <blackh> > let maybeRead s = case reads s of {[(x, "")] -> Just x; _ -> Nothing}
19:27:33 <lambdabot>   <no location info>: parse error on input `;'
19:27:44 <blackh> Why does lambdabot hate me?
19:27:58 <Axman6> need an in
19:28:06 <Axman6> @let maybeRead s = case reads s of {[(x, "")] -> Just x; _ -> Nothing}
19:28:08 <lambdabot>  Defined.
19:28:10 <Axman6> or that
19:28:17 <blackh> Ah! Thanks.
19:28:19 <Axman6> > maybeRead "Hello!"
19:28:21 <lambdabot>   Nothing
19:28:36 <blackh> > maybeRead "777"::Maybe Int
19:28:37 <lambdabot>   Just 777
19:28:41 <Axman6> > maybeRead "0x1111" :: Maybe Integer
19:28:42 <lambdabot>   Just 4369
19:29:01 <bork> I have some code which compiles, but upon adding "import Control.Monad.Error", ghc gives me the errors @ http://hpaste.org/12874. Can anyone shed any light?
19:29:18 <dmwit> ghc --make
19:30:15 <bork> thanks!
19:30:21 <wagle> --make should be the default
19:30:37 <wagle> then you can have --unmake, or something..  8)
19:31:26 <centrinia> What do typeclasses correspond to w.r.t. Curry-Howard?
19:31:29 <centrinia> What does (+) :: (Num a) => a -> a -> a prove?
19:31:41 <dmwit> wagle: I believe it's switching over in 6.10 or 6.11.
19:32:15 <dmwit> Let's use Eq, it's a smaller class.
19:32:15 <dolio> Any "Foo a =>" can be encoded by instead passing a dictionary of all the methods of the class.
19:32:20 <dmwit> ...yeah, that.
19:32:25 * dmwit shakes fist
19:32:33 <dolio> So it's like 'Num a -> a -> a -> a'.
19:32:47 <Axman6> :t (+) . fromIntegral
19:32:49 <lambdabot> forall b a. (Integral a, Num b) => a -> b -> b
19:32:49 <dmwit> Anyway, Eq a => a -> b corresponds to (a -> a -> Bool) -> (a -> b).
19:32:54 <roconnor> > reads "0.0 :+ 0.0" :: [(Complex Double,String)]
19:32:55 <lambdabot>   [(0.0 :+ 0.0,"")]
19:33:02 <dmwit> Where the first argument is (==).
19:33:27 <dmwit> > read "0" :: Double
19:33:29 <lambdabot>   0.0
19:33:48 <roconnor> > reads "0.0 :+" :: [(Complex Double,String)]
19:33:50 <lambdabot>   []
19:33:59 <solrize> anyone think there's much desire in the haskell crowd for a super fast json parser?
19:34:02 <roconnor> > reads "0.0" :: [(Complex Double,String)]
19:34:04 <lambdabot>   []
19:34:10 <pumpkin> solrize: I'd like one
19:34:18 <pumpkin> not sure that counts as much desire though :)
19:34:23 <solrize> pumpkin that's a start
19:34:28 <blackh> solrize: I could probably find a use for it.
19:34:49 <jsn> solrize: it would be especially nice if it parsed to ExpQ
19:34:55 <solrize> what's ExpQ?
19:35:14 <Axman6> :t (,) . fromIntegral. fst
19:35:16 <lambdabot> forall b b1 a b2. (Num b1, Integral a) => (a, b2) -> b -> (b1, b)
19:35:22 <jsn> what template haskell can splice in
19:35:24 <roconnor> > 0 :: Complex (Complex Double)
19:35:25 <lambdabot>       No instance for (RealFloat (Complex Double))
19:35:25 <lambdabot>        arising from the li...
19:35:31 <solrize> aha, looking
19:35:32 <Axman6> :t (,) . (f :: a -> b) . fst
19:35:34 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
19:35:34 <lambdabot>       from the context ()
19:35:34 <lambdabot>       arising from a use of `f' at <interactive>:1:7
19:35:38 <jsn> then you could make gigantic static maps
19:35:50 <Axman6> :t (,) . (id) . fst
19:35:51 <lambdabot> forall b a b1. (a, b1) -> b -> (a, b)
19:35:56 <bender183> mmmmm giagantic static maps
19:36:01 <pumpkin> roconnor: that would've been interesting
19:36:02 <solrize> gigantic?
19:36:23 <dmwit> :t (,) . ?f . fst
19:36:24 <lambdabot> forall b c a b1. (?f::a -> c) => (a, b1) -> b -> (c, b)
19:36:45 <dolio> pumpkin: It'd be possible, too, if it weren't for... abs/signum?
19:37:03 <jsn> solrize: i think you would have to turn them into large case statements
19:37:11 <solrize> i'm not sure how typical it is, but the json records i want to parse usually have a dozen or so fields that are almost always the same, so i was thinking of putting those into an array and having a map for any spillover
19:37:27 <jsn> solrize: there's also dynamic uses, too
19:37:29 <pumpkin> dolio: RealFloat seems to want a lot of rather specific stuff, according to http://www.zvon.org/other/haskell/Outputprelude/RealFloat_c.html
19:37:35 <Axman6> @hoogle (a,b) -> (c,b)
19:37:35 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
19:37:35 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
19:37:35 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
19:37:41 <solrize> jsn for that situation you'd just get back a map, is that reasonable?
19:37:42 <Axman6> bah
19:37:47 <dmwit> :t first
19:37:48 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
19:37:59 <dolio> pumpkin: Yeah, but the reason the instance is "RealFloat a => Num (Complex a)" is due to abs/signum.
19:38:04 <jsn> solrize: well, you actually have to turn it into ExpQ representing a map, for TH to splice it in
19:38:09 <Axman6> is there an easy way to map over the first element in a tuple? (in a list say)
19:38:09 <dmwit> first :: (b ~> c) -> ((b, d) ~> (c, d))
19:38:17 <jsn> solrize: but i suppose i could work with what you make
19:38:26 <pumpkin> dolio: oh, yeah
19:38:29 <jsn> solrize: and put the templating on top of that
19:38:33 <dmwit> :t map . first
19:38:34 <Axman6> dmwit: yeah i have no idea what that mens
19:38:35 <lambdabot> forall b c d. (b -> c) -> [(b, d)] -> [(c, d)]
19:38:36 <Axman6> means*
19:38:53 <Axman6> ah, righto
19:39:02 <solrize> jsn expq might be the right thing, i just gotta figure out what it does
19:39:12 <solrize> i mean, how would you use it?
19:39:16 <dolio> @type runKleisli first
19:39:17 <lambdabot>     Couldn't match expected type `Kleisli m a b'
19:39:17 <lambdabot>            against inferred type `a1 b1 c -> a1 (b1, d) (c, d)'
19:39:17 <lambdabot>     In the first argument of `runKleisli', namely `first'
19:39:20 <dmwit> Axman6: A straight arrow (->) is just a special-case of a squiggly Arrow (~>). =)
19:39:24 <jsn> solrize: you use it at compile time, pretty much
19:39:34 <pumpkin> Axman6: those fancy arrow funtions allow you to work on fst, snd, or both at the same time, it's cool
19:39:34 <Axman6> sure...
19:39:38 <jsn> in conjunction with quasi-quoting, for example
19:39:49 <dolio> @type runKleisli . first
19:39:50 <lambdabot> forall (m :: * -> *) b c d. (Monad m) => Kleisli m b c -> (b, d) -> m (c, d)
19:39:54 <dmwit> Axman6: So first :: (b ~> c) -> ((b, d) ~> (c, d)) means also first :: (b -> c) -> ((b, d) -> (c, d)).
19:40:08 <solrize> jsn i still don't get it
19:40:26 <Axman6> ah i see. sho what is ~> then?
19:40:38 <solrize> the TH haddock is uninformative
19:40:39 <jsn> namesAges = [$toCaseStatment|  { 'joe' : 21 ; 'molli' : 32 }  |]
19:41:01 <jsn> solrize: that's for sure :)
19:41:04 <dmwit> Axman6: first :: Arrow (~>) => ...
19:41:10 <dmwit> Axman6: Arrow is a class.
19:41:11 <dolio> @type runKleisli . first . Kleisli
19:41:12 <lambdabot> forall d a (m :: * -> *) b. (Monad m) => (a -> m b) -> (a, d) -> m (b, d)
19:41:20 <centrinia> The -> is a straight arrow. The ~> is a crocked arrow.
19:41:23 <Axman6> and what are Arrows? seems about time i learnt
19:41:26 <pumpkin> dolio: can you give an example of that in use
19:41:41 <dolio> Of what?
19:41:42 <roconnor> > 0.0 := 0.0 : 0.0
19:41:44 <lambdabot>       No instance for (Fractional [Assoc t t1])
19:41:44 <lambdabot>        arising from the liter...
19:41:46 <roconnor> > 0.0 :+ 0.0 : 0.0
19:41:48 <lambdabot>       No instance for (Fractional [Complex t])
19:41:48 <lambdabot>        arising from the litera...
19:41:58 <pumpkin> dolio: where you'd use runKleisli . first . Kleisli :P
19:42:00 <solrize> jsn what code would you expect that template to expand to?
19:42:04 <roconnor> > 0.0 : 0.0 :+ 0.0
19:42:06 <lambdabot>   Couldn't match expected type `[t]'
19:42:13 <dolio> pumpkin: Nowhere. It's horribly verbose. :)
19:42:16 <dmwit> Axman6: Maybe try the arrow paper by Hughes?
19:42:17 <roconnor> > 0.0 : 0.0 :+ 0.0 : []
19:42:19 <lambdabot>   [0.0 :+ 0.0,0.0 :+ 0.0]
19:42:28 <blackh> Axman6: Take a look at http://www.haskell.org/haskellwiki/HXT - I found this to be good because it is a practical use of arrows.
19:42:28 <dmwit> :t liftM first
19:42:30 <lambdabot> forall (a :: * -> * -> *) b c d (m :: * -> *). (Monad m, Arrow a) => m (a b c) -> m (a (b, d) (c, d))
19:42:40 <Axman6> cheers blackh
19:43:29 <dolio> @type \f g -> runKleisli $ Kleisli f <<< Kleisli g
19:43:30 <lambdabot> forall (m :: * -> *) a b c. (Monad m) => (c -> m b) -> (a -> m c) -> a -> m b
19:43:31 <dmwit> buh-bye
19:43:36 <dolio> @type (<=<)
19:43:37 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
19:44:31 <jsn> solrize:      [| case name of { "joe" -> 21 ; "molli" -> Just 32 ; _ -> Nothing } |]
19:45:01 <Axman6> Just 21?
19:45:20 <jsn> Axman6: that's what i meant
19:45:34 <Axman6> just checking :)
19:46:17 <solrize> that's better than data.map?
19:47:28 <eyeris> I need to sort a list of strings. Hoogle can't seem to find a String -> String -> Ordering function for me though.
19:47:42 <solrize> :t sort
19:47:44 <lambdabot> forall a. (Ord a) => [a] -> [a]
19:47:46 <Axman6> why not juse use sort from Data.List?
19:47:51 <Axman6> > sort
19:47:53 <lambdabot>       Overlapping instances for Show ([a] -> [a])
19:47:53 <lambdabot>        arising from a use o...
19:48:10 <solrize> > sort ["huey", "duey", "luey"]
19:48:11 <lambdabot>   ["duey","huey","luey"]
19:48:16 <Axman6> > sort ["Hello", "World", "how", "are", "you"?]
19:48:17 <lambdabot>   <no location info>: parse error on input `]'
19:48:22 <Axman6> > sort ["Hello", "World", "how", "are", "you?"]
19:48:24 <lambdabot>   ["Hello","World","are","how","you?"]
19:48:27 <eyeris> Haha. I should have guessed it would be that easy.
19:48:48 <Axman6> @src String Ordering
19:48:49 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:48:58 <wagle> @faq can haskell sort?
19:48:58 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:02 <solrize> :t comparing
19:49:03 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:49:09 <roconnor> @src lex
19:49:10 <lambdabot> Source not found. Where did you learn to type?
19:49:12 <Axman6> @src String Ord
19:49:13 <lambdabot> Source not found. There are some things that I just don't know.
19:51:54 <Axman6> @src Ord
19:51:55 <lambdabot> class  (Eq a) => Ord a  where
19:51:55 <lambdabot>     compare      :: a -> a -> Ordering
19:51:55 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:51:55 <lambdabot>     max, min         :: a -> a -> a
19:52:43 <roconnor> > reads "0e0" :: [(Double,String)]
19:52:45 <lambdabot>   [(0.0,"")]
19:53:34 <roconnor> > reads "0e" :: [(Double,String)]
19:53:36 <lambdabot>   [(0.0,"e")]
19:54:16 <roconnor> > reads "0e+0" :: [(Double,String)]
19:54:18 <lambdabot>   [(0.0,"")]
19:56:31 * Megzlna deletes all haskell research papers from the internet
19:56:37 <dons> oh no.
19:56:47 <mmorrow> <dolio> mmorrow: Did you ever get your lunabot @type in?
19:56:51 <dons> oh wait. hang on. no you didn't! you trickster!
19:57:01 <Megzlna> There's too many of them
19:57:05 <Megzlna> I need only the best
19:57:10 <dolio> It's okay! I've downloaded them all, and will repost them!
19:57:10 <Cale> Oh no! Now I'll have to pay publisher's fees!
19:57:18 <Cale> Phew!
19:57:23 <roconnor> @src lexDigits
19:57:23 <lambdabot> Source not found. Are you on drugs?
19:57:28 <roconnor> @src Numeric.lexDigits
19:57:29 <lambdabot> Source not found.
19:57:34 <Cale> er, publishers' :)
19:58:14 <Philippa_> Megzlna: it doesn't really work that way. You might find that Pierce's Types and Programming Languages is worthwhile as a starting point and the original typeclass paper and one on fundeps is a good starting point...
19:58:19 <Philippa_> TaPL's a book
19:58:25 <EvilTerran> a good book
19:58:26 <dolio> mmorrow: Yes. I did say that.
19:58:28 <mmorrow> dolio: not yet, because i've gotta update the lunabot that's currently running in here (on a hosted webserver) and blah blah. i'm gonna push a bunch of stuff to my luna repo tomorrow or the next though, and am gonna update lubaot then
19:58:32 <mmorrow> dolio: heh
19:58:33 <Philippa_> not a bad brick, either
19:58:50 <dolio> Ah, okay.
19:59:24 <mmorrow> i was just trying to think how to hack it in though. i'm gonna try
19:59:37 <Megzlna> Philippa_: http://www.haskell.org/haskellwiki/Research_papers/Type_systems
19:59:40 <Megzlna> what about here?
19:59:45 <Cale> Yes, it does quite a good job of camouflaging itself as masonry, at least as far as books go :)
19:59:49 <mmorrow> the somewhat undesireable thing is though (which re-parsing and prettyprinting'd fix):
20:00:09 <mmorrow> forall t_a4ip. (t_a4ip -> t_a4ip) -> t_a4ip
20:00:15 <mmorrow> hehe, it comes out like that
20:00:32 <mmorrow> sigh :)
20:00:38 <Cale> Not that hard to run a variable prettifier over that :)
20:01:09 <wy> hey byorgey
20:01:11 <Megzlna> my OCD will lead me to read all these papers, this will be a nightmare
20:01:29 <Philippa_> heh. If it helps any, they'll make you a better coder over time
20:01:31 <mmorrow> yeah that's what i was thinking, but since i'm not as familiar with the various ghc ast's as i am with TH and haskell-src-exts, i was thinking of going -> String -> parse and pp with those
20:01:36 <dolio> You could just download them all and not read them like I do.
20:01:39 <Philippa_> lots of nifty ideas dotted around them
20:01:46 <dolio> Just leave 100 of them sitting in your home folder.
20:01:55 <mmorrow> dolio: that's my favorite!
20:02:00 <Cale> Megzlna: and once you're done with those, you can start in on category theory and abstract algebra!
20:02:11 <wchogg> Also known as the tasty stuff
20:02:41 <mmorrow> <BMeph> mmorrow: Have you considered adding a Binary Lambda Calc, or Binary Comb Logic module for luna? :)
20:02:49 <mmorrow> BMeph: how do you mean?
20:03:00 <mmorrow> ah gone
20:03:01 <Megzlna> Cale, did I show you the thing I'm converting over from C++?
20:03:10 <Cale> I don't think you did...
20:03:38 <mmorrow> @tell BMeph what do you mean by "a Binary Lambda Calc, or Binary Comb Logic module for luna?"?
20:03:38 <lambdabot> Consider it noted.
20:04:06 <Nafai> I just checked on Hackage and didn't see any, by chance is there any caldav client libraries for Haskell?
20:04:14 <gwern> 'Sadly, the GHC API is not thread safe. It uses IORefs all over the place – e.g., for global
20:04:17 <gwern> variables and some caches. Interface files are also loaded lazily so there’s a bit of
20:04:21 <gwern> unsafeLaunchMissile stuff.
20:04:46 <Cale> That is silly. GHC shouldn't have global variables in it, out of principle :)
20:05:15 <gwern> the scion package does sound interesting though
20:05:25 <gwern> sounds like a modernized shim
20:05:28 <Megzlna> Cale: http://img84.imageshack.us/img84/5977/foo1rt1.png
20:05:41 <Megzlna> It's recursive
20:05:49 <Megzlna> and transformational
20:06:15 <Cale> A music tracker?
20:06:17 <Leimy> Is there a version of interact that is of type (String -> IO String) -> IO()
20:06:18 <Megzlna> Yes.
20:06:23 <Cale> Cool :)
20:06:29 <Cale> Have you seen Haskore?
20:06:46 <Cale> You might find it interesting :)
20:06:51 <Megzlna> Yes but Haskore is too academic
20:07:14 <Megzlna> I'm terrified of serialism
20:07:30 <Philippa_> for a real tracker, Haskore's a bit too slow to do the basics in
20:07:44 <Philippa_> finding a way to combine the two'd be v.cool though
20:08:03 <Megzlna> I already was trying to implement haskell in C++ just to make my damn software
20:08:04 <harblcat> Is there a was to read just a single character, without having to worry about turning that character into a string?
20:08:13 <Megzlna> and realized it's an uphill battle
20:08:20 <gwern> @hoogle getChar
20:08:21 <lambdabot> Prelude getChar :: IO Char
20:08:21 <lambdabot> System.IO getChar :: IO Char
20:08:21 <lambdabot> System.IO hGetChar :: Handle -> IO Char
20:08:22 <Pseudonym> Megzlna, have you seen FC++?
20:08:27 <Pseudonym> ?go FC++
20:08:33 <lambdabot> http://www.cc.gatech.edu/~yannis/fc++/
20:08:33 <lambdabot> Title: FC++: The Functional C++ Library
20:08:55 <Megzlna> Functional C++ is junk from 10 years ago when templates were first being established and served as a model for later developments
20:08:56 * roconnor found no way to produce ambiguous ReadS parses in H98
20:09:04 <Megzlna> Not used anymore.
20:09:07 * Pseudonym nods
20:09:12 <Pseudonym> It should have been accepted into Boost.
20:09:18 <Pseudonym> In which case, it'd still be useful.
20:09:20 <Megzlna> It was denied
20:09:23 <dolio> roconnor: There aren't any.
20:09:30 <harblcat> gwern: No, not like that. I was speaking of read "1" :: Int, only like read '1' :: Int
20:09:31 <Megzlna> But, Phoenix was not denied
20:09:35 <Pseudonym> Yeah, a couple of people said: "Ugh.  Lisp.  FAIL."
20:09:41 <EvilTerran> ?hoogle digitToInt
20:09:41 <lambdabot> Data.Char digitToInt :: Char -> Int
20:09:51 <EvilTerran> > map digitToInt ['0' .. '9']
20:09:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
20:09:56 <EvilTerran> > map digitToInt ['a' ..]
20:09:58 <lambdabot>   [10,11,12,13,14,15,* Exception: Char.digitToInt: not a digit 'g'
20:09:58 <Megzlna> http://spirit.sourceforge.net/dl_docs/phoenix-2/libs/spirit/phoenix/doc/html/index.html#phoenix.preface
20:10:11 <dolio> roconnor: You could write your own Read instance that was ambiguous, though.
20:10:19 <EvilTerran> harblcat, how about that?
20:10:23 <roconnor> ya
20:10:34 <harblcat> EvilTerran: it does what I want.
20:11:00 <dolio> And that's properly handeled* which is nice (* different string passed to error).
20:11:11 <harblcat> Although eventually I'm just going to have to break down and study parsers.
20:11:12 <Cale> Kind of silly that they didn't continue digitToInt up to 'z'
20:11:42 <dolio> Or handled, even.
20:12:10 <dolio> Why not continue it up to base-64 encoding? :)
20:12:22 <pumpkin_> Cale: I think it should just take a base parameter, too
20:12:28 <pumpkin_> and maybe an alphabet
20:12:32 <pumpkin_> but who knows
20:12:49 <Cale> Well, the point of it is just to be convenient for that special case...
20:13:05 <dolio> If it takes an alphabet, it's practically just (!!).
20:13:08 <pumpkin_> :P
20:13:13 <pumpkin_> true
20:13:51 <solrize> i don't understand why add all this template madness to c++ to do functional programming, instead of programming in a sane language to begin with?
20:14:15 <dolio> Your boss will let you use C++.
20:14:16 <Leimy> I do
20:14:55 <bd_> dolio: and then the trick is making a functional language that looks enough like C++ to get past the boss? :)
20:15:01 <dolio> :)
20:15:10 <Leimy> Use Haskell to generate C++ code
20:15:17 <solrize> haskell has curly braces and a -> operator, what more do you want?
20:15:17 <Pseudonym> Leimy++
20:15:33 <Cale> Heh, that's sort of funny. You can get paid to write unreadable C++, but not clean Haskell simply because nobody can read Haskell.
20:15:37 <Pseudonym> Seriously, C++ ain't so bad.  Good things have been written in it.
20:15:48 <Leimy> I've done a LOT of C++
20:15:50 <Megzlna> solrize: People code C++ templates functionally because templates are functional, so that they can write compile time code, because they have no other choice for writing compile time code.
20:15:56 <Megzlna> Not because they want FP.
20:16:04 <bd_> anyway
20:16:05 <Pseudonym> C++ is my second-favourite language.
20:16:06 <Leimy> there's too much poop in that backyard, and no stick for your shoe
20:16:08 <solrize> but why do they do all that template programming?
20:16:14 <bd_> templates aren't C++. They're a compiler extension language :)
20:16:25 <Leimy> bd_: but they're part of the standard :-)
20:16:34 <solrize> c++ is sort of reasonable as "improved c" but by the time you're through metaprogramming it has turned into something cthulhu would use
20:16:37 <Pseudonym> solrize, templates are like a better preprocessor.
20:16:50 <Leimy> Haskell  is even better :-)
20:16:57 <Leimy> make it generate non-templated C++ code
20:16:59 <Pseudonym> Haskell is the best preprocessor ever.
20:17:01 <Megzlna> Templates are not a preprocessor, or a compiler extension.
20:17:07 <Megzlna> They're core c++
20:17:13 <Megzlna> just like "struct"
20:17:15 <Pseudonym> Megzlna: That's not what I meant.
20:17:26 <Leimy> It's pretty sick how in Haskell you can create operators and set their precedence... or is that just in GHC?
20:17:26 <Pseudonym> Templates are a code generation mechanism.
20:17:35 <Pseudonym> People use the C preprocessor for that, too.
20:17:41 <Philippa_> Leimy: it's Haskell98
20:17:44 <Pseudonym> C++ templates do it better.
20:17:50 <Leimy> Philippa_: awesome
20:18:09 <Leimy> I've seen people do things with operator overloading + templates to do things you get for free with Haskell
20:18:18 <Leimy> and get it wrong... a lot in C++
20:18:20 <Pseudonym> Or very cheap.
20:18:25 <Pseudonym> Oh, yes. that's the catch.
20:18:42 <gwern> hm. 'c++ulhu' - it almost works visually
20:18:45 <Pseudonym> C++ templates are hard to write and maintain for anything nontrivial.
20:18:52 <Leimy> So anyway, I think I need to write "interactIO"
20:19:01 <Leimy> (String -> IO String) -> IO ()
20:19:08 <Megzlna> I agree with everybody on all points
20:19:36 <Leimy> all categorical statements are crap!
20:19:44 <gwern> death to all extremists!
20:19:53 <Pseudonym> :t mfix
20:19:54 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
20:19:59 <Philippa_> I'll take the cake instead, thanks
20:20:15 <Leimy> that's close :-)
20:20:15 <bd_> Leimy: \m -> (hGetContents stdin >>= m) >>= putStr
20:20:56 <Leimy> bd_: perfect!
20:21:23 <Pseudonym> @pl \m -> (hGetContents stdin >>= m) >>= putStr
20:21:23 <lambdabot> (putStr =<<) . (hGetContents stdin >>=)
20:21:31 <dolio> "Initial objects are colimits of the empty diagram" <-- crap?
20:21:37 <Pseudonym> I like that, actually.
20:21:42 <Leimy> Oh wow
20:21:58 <Leimy> that's interesting... because everything I have in interact so far is already just function composition.
20:22:24 <sc101> does anyone have a moment to help out a first time haskell user?
20:22:56 <dibblego> sc101, wossup?
20:23:04 <EvilTerran> ?type (putStr =<<) . (=<< hGetContents stdin)
20:23:05 <lambdabot> Not in scope: `hGetContents'
20:23:05 <lambdabot> Not in scope: `stdin'
20:23:08 <mmorrow> success!
20:23:10 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
20:23:15 <lunabot>  forall t_aa62. (t_aa62 -> t_aa62) -> t_aa62
20:23:17 <EvilTerran> ?type (putStr =<<) . (=<< System.IO.getContents)
20:23:17 <sc101> i keep getting The last statement in a 'do' construct must be an expression is that because of incorrect indentation?
20:23:18 <lambdabot> (String -> IO String) -> IO ()
20:23:29 <mmorrow> ignore the ugly vars for now :)
20:23:34 <Pseudonym> sc101: Do you know about list comprehensions?
20:23:46 <sc101> no
20:23:47 <mmorrow> dolio: i got it in with hackery
20:23:53 <Pseudonym> OK, I won't use that analogy then.
20:23:58 <dolio> Hot.
20:24:01 <Pseudonym> The reason is that monads return a value.
20:24:13 <mmorrow> the quasiquoter `ty' returns the type as a Doc
20:24:20 <Pseudonym> If M is a monad, then the type of a do expression is M A for some type A.
20:24:38 <Pseudonym> The last statement needs to be an expression, because the expression as a whole needs that A.
20:24:47 <Leimy> that's just great!
20:24:54 <mmorrow> when i update teh bot i wanna have it return the type as a TH Type, so you can use it in expressions..
20:24:54 <sc101> whats a valid expression?
20:25:08 <Pseudonym> A "return" expression is common.
20:25:16 <mmorrow> , [$ty| \x -> x |]
20:25:21 <lunabot>  forall t_aa5P. t_aa5P -> t_aa5P
20:25:26 <Pseudonym> > do { x <- [1,2,3]; return (x+1) }
20:25:27 <lambdabot>   [2,3,4]
20:25:27 <Pseudonym> Say.
20:25:41 <Pseudonym> But it could also be a call.
20:25:44 <Philippa_> sc101: the important thing is that x <- foo isn't an expression
20:25:55 <Pseudonym> > do { x <- [1,2,3]; map (+x) [100] }
20:25:57 <lambdabot>   [101,102,103]
20:25:58 <Philippa_> at least, if you're hitting what I think you are
20:26:00 <pumpkin-> any OpenCL work for haskell?
20:26:02 <dolio> Sweet.
20:26:14 <Axman6> list comprehensions are just a form  of do notation right?
20:26:20 <Pseudonym> Axman: Yes.
20:26:40 <Pseudonym> [ x | p <- e ] == do { p <- e; return x }
20:26:41 <Axman6> but with an implicit return out the front?
20:26:52 <Leimy> Hmm emacs is crashing on me...
20:26:58 <Leimy> need Yi with an IRC buffer :-)
20:26:59 <mmorrow> , [$ty| [$ty| \x -> x \|] |]
20:27:02 <Pseudonym> Axman6: The other thing is guards.
20:27:04 <dolio> , [$ty| \f k -> f (\a _ -> k a) k]
20:27:05 <lunabot>  Text.PrettyPrint.HughesPJ.Doc
20:27:05 <Pseudonym> :t guard
20:27:07 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:27:07 <lunabot>  luna: lexical error in string/character literal at end of input
20:27:09 <dolio> , [$ty| \f k -> f (\a _ -> k a) k |]
20:27:10 <mmorrow> haha it worked!
20:27:14 <lunabot>  forall t_aa61 t_aa62 t_aa64 t_aa65.
20:27:14 <lunabot>  ((t_aa61 -> t_aa62 -> t_aa64) -> (t_aa61 -> t_aa64) -> t_aa65)
20:27:14 <lunabot>  -> (t_aa61 -> t_aa64)
20:27:18 <Axman6> ah yes, so guards don't work in do notation then?
20:27:37 <mmorrow> it can see QuasiQutotes + all valid hs syntax. zomg
20:27:53 <solrize> > do { x <- [1..10]; guard (even x); return x }
20:27:54 <lambdabot>   [2,4,6,8,10]
20:27:59 <Pseudonym> Yeah.
20:28:08 <Pseudonym> That's what "guard" is for.
20:28:18 <Axman6> ah, righto
20:28:26 <pumpkin-> :t guard
20:28:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:28:31 <Pseudonym> Also, let statements require explicit braces in list comprehension notation.
20:28:36 <mmorrow> the QQ `ty' is using the function `typ' internally
20:28:40 <Leimy> hmmm
20:28:41 <mmorrow> , [$ty| typ |]
20:28:43 <zloog> whats the command to have cabal auto install dependencies from hackage?
20:28:43 <Pseudonym> [ e | x <- xs; let { y = foo x } ]
20:28:46 <lunabot>  GHC.Base.String -> GHC.Base.String
20:28:47 <Leimy> that interactIO isn't working well
20:28:47 <dolio> , [$ty| Mu |]
20:28:49 <Axman6> so they just save typing guard and return i guess? (and the syntax is a little more clear about what's going on)
20:28:53 <lunabot>  forall (f :: * -> *). f (Luna.Mu.Mu f) -> Luna.Mu.Mu f
20:28:58 <mmorrow> hehe
20:29:03 <mmorrow> this is sweet
20:29:06 <Pseudonym> Axman6: Also, do-notation works for arbitrary monads, not just lists.
20:29:14 <Axman6> yeah
20:29:14 * mmorrow imagines the possibilities
20:29:26 <Axman6> mmorrow: what
20:29:34 <mmorrow> i dunno yet :)
20:29:37 <Axman6> what's all this [$x|Thing|] stuff?
20:29:39 <mmorrow> oh
20:29:41 <hydrapheetz> I never quite got Monads. :|
20:29:43 <Axman6> sorry :)
20:29:51 <Axman6> hydrapheetz: do you want to?
20:30:01 <hydrapheetz> Not right now, at least. :<
20:30:03 <dolio> [$x| ... |] is the quasiquote syntax.
20:30:13 <Axman6> which is... what?
20:30:24 <sc101> ok right now my last statement is "in show map chr decoded" how do i translate that into an expression? lol
20:30:27 <dolio> Lets you define your own parsers that produce haskell terms.
20:30:29 <hydrapheetz> As in, I'm not quite ready to mess with Monads.
20:30:33 <mmorrow> the QuasiQuoter `ty' uses ghc to compile the expression to the point where it can return its type, so [$ty| ... arbitrary expression |] will return that expression's type
20:31:06 <mmorrow> , [$ty| [Just [(),()]] `seq` \x -> x |]
20:31:10 <Axman6> ahh, so could you use that to get ghc to generate the types in the files for you?
20:31:11 <lunabot>  forall t_aa69. t_aa69 -> t_aa69
20:31:22 <mmorrow> the vars are ugly for the moment though
20:31:25 <Axman6> could do with some nicer naming...
20:31:31 <sc101> err "in map chr decoded"
20:31:46 <mmorrow> yeah, i've got to parse it, clean the names, then prettyprint it
20:31:58 <Axman6> aye.
20:32:14 <Axman6> seems like it would be nicer if it did that already
20:32:52 <pumpkin-> mmorrow: pretty print whtat?
20:33:01 <Pseudonym> sc101: I'm not sure what your intention is.
20:33:03 <Pseudonym> However...
20:33:08 <mmorrow> Axman6: yeah, you could do all kinds of stuff
20:33:13 <sc101> to print taht to the screen
20:33:13 <Pseudonym> return (chr decoded) might be what you want.
20:33:22 <sc101> i was going off an example from learn you a haskell
20:33:28 <mmorrow> pumpkin-: the type returned by [$ty| .. expression ... |]
20:33:30 <Pseudonym> URL?
20:33:38 <pumpkin-> mmorrow: what's your end-goal though?
20:33:44 <sc101> but trying to translate it to something that would run outside the interpreter
20:33:51 <Axman6> , [$ty|(>>=)|]
20:33:52 <sc101> http://learnyouahaskell.com/modules
20:33:57 <lunabot>  forall (m :: * -> *) a b.
20:33:57 <lunabot>  (GHC.Base.Monad m) =>
20:33:57 <lunabot>  m a -> (a -> m b) -> m b
20:33:57 <sc101> near the end of the page
20:34:09 <sc101> "encode"
20:34:11 <Axman6> that's much nicer...
20:34:16 <mmorrow> pumpkin-: i'm not sure. my first end goal was to have lunabot be able to do a @type
20:34:24 <pumpkin-> ah
20:34:27 <Pseudonym> ?hpaste
20:34:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:34:29 <mmorrow> but i haven't thought of what the next end-goal is
20:34:33 <leimy> dangit
20:34:34 <Pseudonym> sc101, you might like to paste your code there.
20:34:46 <leimy> http://hpaste.org/12876
20:34:55 <leimy> InteractIO didn't quite go the way I wanted :-)
20:35:19 <mmorrow> i'm going to upload the luna pkg to hackage as well after i update it (w/in a few days)
20:35:43 <sc101> http://hpaste.org/12877
20:36:28 <Pseudonym> sc101, I think you want putStrLn (map chr encoded)
20:36:31 <Pseudonym> Or something like that.
20:36:33 <Pseudonym> However.
20:36:45 <Pseudonym> Probably what you actually want is something like this...
20:36:51 <sc101> type error if i putstrln
20:37:17 <mmorrow> ,  ppDoc `fmap` (fromJust . fromDynamic . eval $ ("[t|" ++ (render [$ty|\x -> x|]) ++ "|]") :: TypeQ)
20:37:22 <lunabot>  forall t_aa5P_0 . t_aa5P_0 -> t_aa5P_0
20:37:25 <mmorrow> woot
20:37:47 <Axman6> sc101: print instead of putStrLn?
20:38:00 <sc101> type error as well lol
20:38:24 <Axman6> print (map chr msg)?
20:38:24 <Pseudonym> http://hpaste.org/12877#a1
20:38:31 <sc101> yea
20:38:45 <Axman6> i think you may need to read your data
20:38:47 <Pseudonym> Even this will work:
20:39:03 <Pseudonym> let result = map (if eod == 'e' then (+ shn) else (- shn)) ords
20:39:05 <Axman6> get* doesn't read anything, need readline
20:39:10 <Axman6> 'or readln
20:40:05 <Axman6> :t readLn
20:40:06 <lambdabot> forall a. (Read a) => IO a
20:40:34 <sc101> instead of getline or in addition too?
20:40:41 <Axman6> instead of
20:40:45 <Axman6> :t getLine
20:40:46 <lambdabot> IO String
20:41:01 <sc101> similarly is there a readChar?
20:41:09 <Pseudonym> @hoogle IO Char
20:41:09 <lambdabot> Did you mean: :: IO Char /count=20
20:41:09 <lambdabot> No results found
20:41:10 <Axman6> actually, i think i'm wrong
20:41:20 <Pseudonym> @hoogle :: IO Char
20:41:21 <lambdabot> Prelude getChar :: IO Char
20:41:21 <lambdabot> System.IO getChar :: IO Char
20:41:21 <lambdabot> System.IO hGetChar :: Handle -> IO Char
20:41:23 <leimy> as long as I don't want to prompt for input, I can keep my state stuff in State instead of StateT
20:41:40 <Pseudonym> No, there's no readChar because "read" means lightweight parsing.
20:41:57 <Axman6> > do {x <- getCha; return x} -- >_>
20:41:59 <lambdabot>   Not in scope: `getCha'
20:42:03 <Axman6> > do {x <- getChar; return x} -- >_>
20:42:04 <lambdabot>   * Exception: "<IO Char>"
20:42:09 <Axman6> errrorz!
20:42:20 <Pseudonym> Yeah, for obvious reasons.
20:42:27 <Pseudonym> > readFile "/etc/passwd"
20:42:29 <lambdabot>   * Exception: "<IO [Char]>"
20:42:31 <Pseudonym> FAIL
20:42:34 <sc101> so pseudo does w/ that edit does that compile for you?
20:42:41 <Pseudonym> I dunno, haven't tried it.
20:42:54 <Pseudonym> I was just answering your question. :-)
20:42:59 <mmorrow> ,  let t = unQ (fromJust . fromDynamic . eval $ ("[t|" ++ (render [$ty|\x -> x|]) ++ "|]") :: TypeQ) in ppDoc $ everywhere (mkT (\n -> case nameBase n of c:_ | isLower c -> (mkName . (:[]) . (['a'..'z']!!) . (`mod`25) . sum . fmap ord . nameBase $ n); _ -> n)) t
20:43:05 <lunabot>  forall p . p -> p
20:43:14 <sc101> Couldn't match expected type `a -> b' against inferred type `Int'
20:43:20 <mmorrow> heh, kinda cheating
20:43:22 * Pseudonym unfortunately does not have the facilities to test Haskell code at the moment; new PC is not fully set up
20:43:23 <sc101> any idea on that?
20:44:15 <leimy> huh maybe I just wanted (String -> IO ()) -> IO ()
20:44:54 <Axman6> , [$ty|render|]
20:45:00 <lunabot>  Text.PrettyPrint.HughesPJ.Doc -> GHC.Base.String
20:46:39 <Axman6> pumpkin-: did you see the OpenCL spec got released?
20:47:21 <pumpkin-> yeah, that's what prompted me to ask :)
20:47:30 <pumpkin-> it'd be fun if haskell got some of that fun
20:47:36 <pumpkin-> wow, that sounded dumb
20:47:39 <pumpkin-> but you know what I mean
20:47:43 <hml> :t flip
20:47:45 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
20:47:52 <hml> :src flip
20:47:56 <hml> ,src flip
20:47:57 <hml> @src flip
20:47:58 <lambdabot> flip f x y = f y x
20:47:58 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
20:48:16 <sc101> does anyone know a quick fix for Couldn't match expected type `a -> b' against inferred type `Char'
20:48:16 <sc101>     In the first argument of `map', namely `(- shc)'
20:48:16 <sc101>     In the expression: map (- shc) ords
20:48:16 <sc101>     In the definition of `decoded': decoded = map (- shc) ords
20:48:20 <mmorrow> lunabot's "src" should really be called ":info"
20:48:28 <mmorrow> , src 'flip
20:48:28 <hml> :info flip
20:48:33 <hml> :src flip
20:48:33 <lunabot>  flip :: forall a b c . (a -> b -> c) -> b -> a -> c
20:48:36 <pumpkin-> sc101: you're probably getting associativity wrong
20:48:44 <mmorrow> , [$ty|  flip  |]
20:48:49 <lunabot>  forall a b c. (a -> b -> c) -> b -> a -> c
20:48:53 <pumpkin-> sc101: looks like it's taking a function instead of the value it returns, you might need some extra parens or a $
20:49:00 <mmorrow> oh nice, that one wasn't mangled
20:49:14 <Cale> mangled?
20:49:17 <sc101> $ in front of var?
20:49:23 <mmorrow> heh
20:49:23 <Cale> oh, right
20:49:30 <Cale> , [$ty| fix |]
20:49:36 <lunabot>  forall a. (a -> a) -> a
20:49:41 <mmorrow> perhaps mangled is too strong a word :)
20:49:43 <Cale> er...
20:49:44 <pumpkin-> , [$ty| 5 |]
20:49:49 <lunabot>  forall t_aa5L. (GHC.Num.Num t_aa5L) => t_aa5L
20:49:51 <Cale> ah
20:49:55 <pumpkin-> why is lunabot so much slower than lambdabot?
20:50:04 <Cale> is it?
20:50:09 <Pseudonym> lambdabot is running on a beefy machine, I know that.
20:50:28 <pumpkin-> ah
20:50:33 <dons> ?version
20:50:34 <lambdabot> lambdabot 4.2.2
20:50:34 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:50:40 <dons> ?uptime
20:50:40 <lambdabot> uptime: 1d 7h 48m 39s, longest uptime: 1m 10d 23h 44m 29s
20:50:52 <dons> 20:50  dons> ?uptime
20:50:52 <dons> 20:50  lambdabot> uptime: 5m 11d 11h 50m 28s,
20:50:52 <mmorrow> since ghc has to compile to the point after typechecking, but before that, since the evaluator is started fresh for every request, it has to get a new "HscEnv" from ghc every time which takes a sec
20:50:55 <pumpkin-> > 5 * 5
20:50:55 <pumpkin-> , 5 * 5
20:50:56 <lambdabot>   25
20:50:57 <lunabot>  25
20:51:52 <mmorrow> also, lunabot's in a VM i think
20:51:56 <pumpkin-> ah
20:55:14 <zloog> @src map
20:55:14 <lambdabot> map _ []     = []
20:55:14 <lambdabot> map f (x:xs) = f x : map f xs
20:55:35 <mmorrow> but lambdabot should have to do the same think lunabot does, so it's probably just a matter of the machine(s)
20:55:42 <mmorrow> s/think/thing/
20:57:14 <sc101> sorry to be a bother, but can someone please explain to me why this wont compile and suggest a possible solution? http://hpaste.org/12877#a1
20:58:02 <Cale> sc101: I'll have a look
20:58:09 <sc101> thank you
20:58:12 <dolio> sc101: (- shn) isn't a function.
20:58:16 <dolio> It's negative shn.
20:58:26 <dolio> You want "subtract shn".
20:59:05 <Cale> yes
21:00:01 <zloog> Hrm
21:00:27 <sc101> when i replace that i get "the last statement in a 'do' construct must be an expression
21:01:01 <zloog> http://hpaste.org/12878 could you take a look at that for me as well? Its a three liner and ghci is complaining about parse error in pattern
21:02:42 <zloog> oops
21:02:51 <zloog> need to write that (x:xs) i guess
21:02:55 <Cale> zloog: yeah, parend
21:02:59 <Cale> parens*
21:03:03 <Cale> sc101: hmm...
21:03:08 <zloog> thx
21:03:22 --- mode: ChanServ set +o glguy
21:03:25 <Cale> sc101: perhaps try indenting the 'then' and 'else' by another space or two?
21:03:27 --- mode: glguy set -ob glguy *!*=48cf149f@gateway/web/ajax/mibbit.com/x-c4f9cb213b39ce17
21:03:38 <Cale> sc101: I can't see a reason for that message there.
21:03:50 <sc101> ok thanks
21:04:07 <Cale> sc101: It usually occurs when you end a do-block with something like  foo <- bar
21:04:17 <Cale> rather than just an action
21:04:31 <Cale> The result of a do-block is the result of the last action in it.
21:05:41 <leimy> >src? interact
21:05:53 <leimy> >src interact
21:06:17 <leimy> ?src interact
21:06:17 <lambdabot> interact f = do s <- getContents; putStr (f s)
21:06:39 <sc101> that worked, thanks so much
21:06:47 <zloog> hooray for #haskell
21:06:49 <leimy> hmmm
21:08:03 <Cale> leimy: If you're wondering how getContents works, it's slightly magical
21:08:13 <leimy> I realize this.
21:08:32 <dons> shapr: http://haskell.org/haskellwiki/Boston_Area_Haskell_Users'_Group/Volunteers
21:10:04 <pumpkin-> ooh
21:10:09 <leimy> I've got http://hpaste.org/12876#a1  <- lazy input, no interactive prompting, yet reads in a bowling game correctly using infinite lists.
21:10:33 <leimy> But I'd love to be able to tell prompt for input for a certain frame.
21:11:27 <leimy> I wanted to put prompting into threadBall
21:11:33 <leimy> but it's a no go it seems
21:11:57 <leimy> because once one goes StateT  with IO as the inner monad, you can forget using "interact"
21:12:34 <Cale> You might just be able to ensure that the prompt part of the output is available before input is needed.
21:13:05 <Cale> Of course, because you have LineBuffering, it'll have to be on a separate line.
21:13:16 <leimy> Yeah
21:13:22 <Cale> (since you can't explicitly hFlush stdout)
21:13:46 <leimy> I used the line buffering because I started getting back the 10th frame before I was done inputting it
21:13:54 <Cale> ah
21:13:58 <leimy> yeah.
21:14:07 <mmorrow> and since you're in IO anyway, you could always just use an MVar or equiv
21:14:14 <Cale> Yeah, lazy IO can be strange :)
21:14:16 <leimy> I felt as I was going down that road, it was bad :-)
21:14:39 <Cale> It's probably easier just to write a small IO loop for prompting and handle the rest as pure.
21:14:42 <leimy> tweaking buffering to get the behavior I wanted seemed incorrect... or bad to rely on.
21:14:51 <leimy> yeah... I had that
21:14:55 <leimy> and it was not pretty :-)
21:15:02 <Cale> oh?
21:15:03 <leimy> I was hoping to do something like interact
21:15:07 <leimy> well it worked fine
21:15:09 <leimy> and I understood it
21:15:13 <leimy> but it's kind of nasty
21:15:25 <Cale> It should only be a few lines different, perhaps.
21:16:12 <leimy> hmmm
21:16:41 <leimy> yeah I was just hoping to use interact, or something like it, because then I could just pretend all the input was being handled elsewhere :-)
21:16:58 <mmorrow> lazy IO scares me for anything other than in ghci and in main = putStr . .... =<< getContents
21:18:21 <leimy> I mean, the IO is going on, but I only have to deal with the string == pure
21:18:44 <leimy> Like http://hpaste.org/12876#a1  <-- pretty neat, just no prompting
21:19:00 <mmorrow> yeah, in those cases it is definitely nice
21:19:23 <leimy> also, I'm not sure how to calculate the scoreboard live on each frame's end
21:19:39 <leimy> I'd need my own "take" or something
21:19:58 <leimy> I feel that I'm entering some weird domain of functional programming
21:20:01 <mmorrow> does one frame directly correspond to one fixed-size input chunk?
21:20:06 <leimy> nope
21:20:10 <mmorrow> hmm
21:20:13 <leimy> a frame can end if it's number is < 10
21:20:16 <leimy> and it's a strike :-)
21:20:23 <leimy> but in the 10th frame you can have up to 3 "balls"
21:20:33 <leimy> if any of the first or second is a strike, or the second is a spare
21:20:39 <leimy> the rules are difficult :-)
21:20:43 <mmorrow> heh
21:20:50 <leimy> bowling is not easy to code cleanly.
21:21:04 <zloog> does the if keyword only work inside do blocks?
21:21:20 <solrize> > if 3 > 4 then "foo" else "bar"
21:21:20 <zloog> :t if
21:21:21 <leimy> zloog: nope
21:21:22 <lambdabot>   "bar"
21:21:22 <lambdabot> parse error (possibly incorrect indentation)
21:21:36 <zloog> leimy: hrm
21:22:01 <solrize> > 2 + (if 1 == 0 then 9 else 5)
21:22:03 <lambdabot>   7
21:22:08 <zloog> leimy: thx
21:22:16 <leimy> http://hpaste.org/12876#a2  <-- a game of all 5 balls.
21:22:33 <leimy>  / = spare
21:22:44 <solrize> ugh
21:23:21 <pumpkin-> solrize: hoping for 11? :P
21:23:58 <Cale> zloog: In fact, if doesn't actually need to be a keyword in Haskell. It could be a function, it's only a keyword for the nice syntax.
21:24:06 <leimy> but yeah... lazy IO is pretty crazy
21:24:16 <Cale> if True t e = t
21:24:22 <dons> but we use it in the shell all the  time.
21:24:22 <Cale> if False t e = e
21:24:24 <dons> so can't be too weird.
21:24:31 <leimy> yep
21:24:45 <zloog> Cale: yea, it was the syntax bit that made me think monad only
21:24:48 <solrize> these go to 11
21:25:02 <pumpkin-> solrize ?
21:25:14 <pumpkin-> :t join
21:25:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:25:20 <solrize> from spinal tap
21:25:23 <pumpkin-> @src [] join
21:25:23 <lambdabot> Source not found. You untyped fool!
21:26:21 <leimy> http://paste.lisp.org/display/71586  <-- the other version of this... complete, but a lot more code is in IO.
21:26:43 <leimy> Also uses continuations.
21:30:47 --- mode: ChanServ set +o glguy
21:31:08 --- mode: glguy set -ob+b glguy *!*@*.syr.edu!#haskell-ops *!*@syru153-183.syr.edu
21:31:17 <glguy> err
21:31:18 --- mode: ChanServ set +o glguy
21:31:32 --- mode: glguy set -b+b *!*@syru153-183.syr.edu %*!*@syru153-183.syr.edu
21:31:38 --- mode: glguy set -o glguy
21:41:54 <leimy> So I guess lazy evaluation isn't really quite the same as coroutines.
21:46:26 <mmorrow> i've begun to realized why that's the case recently
21:46:31 <mmorrow> *realize
21:48:32 <mmorrow> (however, i can't quite put it into words at the moment :)
21:48:59 * mmorrow needsleep
21:49:48 <pumpkin-> getsome
21:51:38 <shapr> dons: Whoa!
21:54:55 <wagle> what keyword am i looking for to get something like python's dict in haskell?
21:55:59 <lament> dict is not even a keyword, you're looking for Data.Map
21:58:19 <solrize> re
21:58:24 <wagle> keyword for google
21:58:40 <wagle> or search in the fine manual
21:58:50 <Axman6> @hoogle Data.Map
21:58:51 <lambdabot> module Data.Map
21:58:51 <lambdabot> Data.Map data Map k a
21:58:51 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
21:58:53 <Axman6> ^^ :)
21:59:06 <pumpkin-> roconnor: are there any plans to make colour support other color spaces?
21:59:17 <wagle> thanks
22:00:06 <solrize> so are record types anti-haskellish?
22:00:08 <leimy> ?src interact
22:00:08 <lambdabot> interact f = do s <- getContents; putStr (f s)
22:00:14 <Heffalump> solrize: no
22:00:23 <solrize> data X = X {x1 :: Int; x2 :: String; x3 :: [String]; x4 :: Whatsit .... x20 :: Thingie }
22:00:38 <Heffalump> though numbering like that is a bit evil :-)
22:00:49 <Heffalump> but it depends on whether that makes logical sense for your type or not
22:00:54 <solrize> well i'd use meaningful names, the point is that i want to use quite a lot of fields
22:00:59 <pumpkin-> how efficient are huge pattern matches on constants? what's the complexity of say, a pattern match on n constant strings (each string gives a different behavior)?
22:01:16 <lament> solrize: it's not anti-haskellish, it's just annoying
22:01:19 <Heffalump> solrize: I think that's fine. What's the alternative?
22:01:19 <solrize> and i'm wondering if the constructor and accessors would be efficient in this case
22:01:37 <lament> the only reason it's not anti-haskellish is that there isn't anything better :)
22:01:45 <solrize> heffalump, alternatives, hmm, use a big tuple, use data.map with some union types inside, etc
22:01:55 <solrize> or an array
22:02:08 <solrize> i mean i want the equivalent of a C struct
22:02:11 <Heffalump> both options sound far more evil
22:02:15 <Heffalump> a record is strongly typed
22:02:20 <Heffalump> a big tuple is a bit of a pain, IME
22:02:31 <lament> cadadadadddddr
22:02:35 <solrize> so hmm, i guess everything in that record would be a Maybe or an Either
22:02:41 <Heffalump> (and I speak from experience, because I work on a project that uses very big tuples)
22:03:28 <solrize> hmm
22:03:48 <roconnor> pumpkin-: I've almost completed support for arbitrary RGB spaces
22:04:14 <Axman6> Heffalump: yeah i'd rather avoid it if possible too
22:04:21 <roconnor> Unfortunately my thesis takes priority
22:04:25 <Axman6> mainly because you forget what position relates to what data
22:04:37 <solrize> oh nooo, a wootoff :-P
22:04:40 <Axman6> roconnor: what's the thesis on?
22:05:00 <roconnor> Axman6: half is on implementing complete metric spaces in Coq
22:05:11 <roconnor> the other half is proving the incompleteness theorem in Coq
22:05:20 <pumpkin-> roconnor: sounds neat :)
22:05:32 <roconnor> editing my thesis makes me want to claw out my eyes
22:05:35 <pumpkin-> roconnor: what about some of the more esoteric color spaces?
22:05:49 <roconnor> pumpkin-: next up in my plans are HLS HSV spaces
22:06:00 <roconnor> and YCbCr
22:06:22 <pumpkin-> sounds neat :)
22:06:48 <roconnor> oh and cieLAB and cieLUV
22:06:58 <roconnor> in no particular order
22:06:59 <Axman6> has anyone got any experience with CouchDB and/or the haskell CouchDB bindings?
22:07:01 <solrize> the classical incompleteness theorem?  not already proved in coq?
22:07:20 <roconnor> solrize: what do you mean?
22:07:47 <solrize> you're writing a thesis about proving the incompleteness theorem in coq?
22:07:53 <Axman6> solrize: shuch, no one's had the heart to tell roconnor the stuff in his thesis has already been done!
22:08:03 <solrize> axman6 :)
22:08:08 <Axman6> shush even
22:08:12 <roconnor> solrize: yes, half of my thesis
22:09:03 <roconnor> I mean, it is already done in Coq ... by me
22:09:12 <roconnor> that's why it goes into my thesis
22:09:32 <solrize> aha
22:09:36 <solrize> http://www.cs.ru.nl/~freek/100/index.html
22:09:38 <solrize> yep :)
22:09:53 <solrize> 6. Gödel's Incompleteness Theorem
22:09:53 <solrize>     * HOL Light, John Harrison
22:09:53 <solrize>     * Coq, contrib, Russell O'Connor
22:09:53 <solrize>     * nqthm, Natarajan Shankar
22:10:13 <solrize> cool :)
22:10:41 <roconnor> :)
22:10:58 <centrinia> How does one prove  Gödel's Incompleteness Theorem using only Peano arithmetic?
22:11:18 <roconnor> same way Gödel did
22:11:24 <roconnor> except with more details
22:12:07 <solrize> didn't it take a few more years for someone (rosser?) to prove that it went through in PA?
22:12:23 <roconnor> Hmm
22:12:31 <roconnor> I don't know the details of the timeline
22:12:53 <roconnor> Rosser is famous for droping the omega from the omega-consistency requirement
22:13:00 <solrize> yeah
22:13:31 <roconnor> solrize: but you could be right.  Godel mostly talked about Principia Mathematica in his paper
22:13:47 <roconnor> but there is no problem with applying his proof to PA
22:13:52 <solrize> right
22:13:53 <pumpkin-> is coq related to haskell at all?
22:14:04 <roconnor> The key trick is how he uses the chinese remainder theorem.
22:14:11 <roconnor> to encode recursion
22:14:12 <solrize> did you do it that way?
22:14:17 <roconnor> that that theorem holds in PA
22:14:31 <roconnor> pumpkin-: both are typed functional programming languages
22:14:40 <pumpkin-> ah :)
22:14:42 <roconnor> pumpkin-: Coq can sort of produce Haskell code
22:15:15 <roconnor> solrize: did I do it what way?
22:15:23 <mmorrow> Heffalump: i love TH + massive tuples, especially for db stuff
22:15:42 <mmorrow> , $(tupE . fmap lift $ [0..9::Int])
22:15:46 <lunabot>  (0,1,2,3,4,5,6,7,8,9)
22:15:54 <centrinia> Is it possible to prove Gödel's Incompleteness Theorem using only plane Euclidean geometry?
22:16:10 <pumpkin-> mmorrow: is there an "nth element of tuple" accessor in TH?
22:16:22 <Axman6> dons: you around? wondering what you know about the CouchDB bindings
22:16:33 <dons> Axman6: yes. no. don't know anything.
22:16:36 <mmorrow> , $(foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int]))
22:16:37 <solrize> roconnor, with the chinese remainder theorem, with 3^p 5^q etc.
22:16:39 <lunabot>  (0,(1,(2,(3,(4,(5,(6,(7,(8,(9,()))))))))))
22:16:44 <mmorrow> , $(foldl (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int]))
22:16:46 <lunabot>  (((((((((((),0),1),2),3),4),5),6),7),8),9)
22:16:53 <mmorrow> pumpkin-: yes, you can construct such a thing
22:17:07 <Axman6> dons: heh, ok, thanks. you mentioned it a while ago, and wasn't sure if you'd used it. i can't seem to figure out how it's supposed to be used :\
22:17:08 <solrize> i don't remember quite what messy thing godel did, but these days we'd do it with turing machines i'd think
22:17:10 <centrinia> :t  $(foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int]))
22:17:12 <lambdabot> parse error on input `$'
22:17:21 <pumpkin-> centrinia: you need to use lunabot
22:17:29 <jdavis> When I think in functional programming, I think much more in terms of sets than lists. Is there a reason that it's so common to use lists?
22:17:32 <centrinia> ,t  $(foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int]))
22:17:34 <lunabot>  luna: Not in scope: `t'
22:17:39 * peoppenheimer ?
22:18:03 * wagle looks for a set monad
22:18:06 <Axman6> , type fmap
22:18:08 <lunabot>  luna: parse error on input `type'
22:18:13 <Axman6> ,type 'fmap
22:18:15 <lunabot>  luna: parse error on input `type'
22:18:17 <Axman6> bah
22:18:19 <jml> jdavis: lists are easier to implement, basically.
22:18:26 <jdavis> jml: I see.
22:18:42 <jdavis> jml: it's too bad there isn't a set equivalent of a list comprehension.
22:18:55 <pumpkin-> wagle: I wish :)
22:19:13 <dons> jdavis: sets are a more complicated structure
22:19:16 <mmorrow> , $( let tup n i = newName "x" >>= \x -> lamE [tupP (replicate (i-1) wildP ++ [varP x] ++ replicate (n-i-1) wildP)] (varE x) in tup 47 12)   $(tupE (fmap lift [0..46::Int])
22:19:17 <lunabot>  luna: parse error (possibly incorrect indentation)
22:19:22 <mmorrow> , $( let tup n i = newName "x" >>= \x -> lamE [tupP (replicate (i-1) wildP ++ [varP x] ++ replicate (n-i-1) wildP)] (varE x) in tup 47 12)   $(tupE (fmap lift [0..46::Int]))
22:19:24 <lunabot>  luna: Couldn't match expected type `(t,
22:19:29 <mmorrow> wuh
22:19:36 <jdavis> dons: sets are simpler from a mathematical standpoint ;)
22:19:55 <dons> can you define their type plz?
22:20:00 <dons> data Set a = ...
22:20:12 <Axman6> Data.Set a
22:20:13 <Axman6> >_>
22:20:18 <pumpkin-> lol
22:20:20 <dons> data List a = Empty | Cons a (List a)
22:20:24 <dons> that's why we use lists :)
22:20:44 <dons> also, induction and recursion are natural ways to program. sets hmm. the set monad isn't intuitive.
22:20:46 <jdavis> dons: Ok, fair enough.
22:20:52 <wagle> mmmm..  sets of programs
22:21:01 <Megzlna> Does haskell have any form of automatic conversions?
22:21:09 <pumpkin-> wagle: sounds like our discussion the other day about equality on functions
22:21:10 <dons> Megzlna: it has type inference
22:21:14 <Axman6> Megzlna: between what and what?
22:21:14 <dons> > 1 :: Double
22:21:16 <lambdabot>   1.0
22:21:38 <Megzlna> That's an explicit conversion
22:21:48 <dons> well, not if there is surrounding context
22:21:49 <roconnor> solrize: I don't use prime decomposition like Goedel did.  I use the Cantor Pairing function to encode data structures.
22:21:52 <dons> i had to supply some context
22:21:54 <dons> > sqrt 1
22:21:55 <lambdabot>   1.0
22:21:56 <dons> see.
22:21:57 <Axman6> like [1..] !! (1 :: Integer)?
22:21:57 <centrinia> Don't all (Data.Set a) sets have a partial order?
22:22:11 <solrize> ic, that sounds cleaner
22:22:12 <jdavis> dons: well, a lot of the programming I do involves sets of things. I don't want to have to worry about accidentally inserting the same thing twice, for instance. That's why I use sets.
22:22:21 <pumpkin-> centrinia: should have a total one?
22:22:25 <dons> jdavis: yeah, sets are useful. you use Data.Set ?
22:22:26 <mmorrow> ah, fencepost error
22:22:29 <mmorrow> , $( let tup n i = newName "x" >>= \x -> lamE [tupP (replicate i wildP ++ [varP x] ++ replicate (n-i-1) wildP)] (varE x) in tup 47 12) $(tupE . fmap lift $ [46,45..0::Int])
22:22:30 <roconnor> solrize: but I still use the chinese remainder theorem to get recursion to work, the same way Godel did.
22:22:31 <dons> they're not default since they're more complex.
22:22:31 <lunabot>  34
22:22:38 <dons> ?users <-- shapr
22:22:39 <lambdabot> Maximum users seen in <-- shapr: 1, currently: 0 (0.0%), active: 0 (NaN%)
22:22:40 <jdavis> dons: yeah, that's what I use.
22:22:42 <dons> ?users
22:22:42 <lambdabot> Maximum users seen in #haskell: 583, currently: 507 (87.0%), active: 17 (3.4%)
22:22:48 <Megzlna> That auto conversion is only coz of typeclass Num, and no other language reasons, right?
22:22:49 <dons> shapr: ^^
22:22:50 <jdavis> dons: are there other options that I should look into?
22:22:50 <mmorrow> "select the 12th element of a 47-tuple"
22:23:00 <dons> Megzlna: right. our numbers are polymorphic until proven otherwise.
22:23:02 <dons> :t 1
22:23:03 <lambdabot> forall t. (Num t) => t
22:23:18 <mmorrow> sel :: Int -> Int -> ExpQ    which splices to
22:23:23 <dons> free agents until you place them in constraints
22:23:39 <mmorrow> , ppDoc `fmap` (let tup n i = newName "x" >>= \x -> lamE [tupP (replicate i wildP ++ [varP x] ++ replicate (n-i-1) wildP)] (varE x) in tup 6 3)
22:23:42 <lunabot>  \(_, _, _, x_0, _, _) -> x_0
22:23:49 <wagle> 1 is half int, half integer?
22:23:59 <pumpkin-> :t 1
22:23:59 <solrize> roconnor, yeah, the stuff with primes just struck me as messy when i looked at it years ago, i don't remember much detail
22:24:00 <lambdabot> forall t. (Num t) => t
22:24:04 <mmorrow> , ppDoc `fmap` (let tup n i = newName "x" >>= \x -> lamE [tupP (replicate i wildP ++ [varP x] ++ replicate (n-i-1) wildP)] (varE x) in tup 17 9)
22:24:05 <Axman6> wagle: no..
22:24:07 <lunabot>  \(_, _, _, _, _, _, _, _, _, x_0, _, _, _, _, _, _, _) -> x_0
22:24:08 <Axman6> it's a number
22:24:23 <centrinia> 1 is also a Double, a Float, and even a Rational.
22:24:26 <pumpkin-> wagle: it's whatever other things need it to be
22:24:33 <wagle> so it has more than two halves?
22:24:40 <pumpkin-> it's not halves :P
22:25:04 <wagle> ehh..  was trying to refer to schroedinger's cat
22:25:49 <wagle> it must have some internal representation though
22:26:06 <Axman6> well, it's also a Float, Double, Complex Float, Complex Double, CReal, Complex CReal, Ratio, Int8, Word8...
22:26:08 <wagle> [char]?
22:26:15 <pumpkin-> wagle: depends on its context
22:26:19 <dons> it's a set of possible types.
22:26:21 <Axman6> @src Integer
22:26:22 <lambdabot> data Integer = S# Int#
22:26:22 <lambdabot>              | J# Int# ByteArray#
22:26:26 <centrinia> It's too bad that {data FunSet a b = Data.Set (a -> b)} is not possible. :(
22:26:26 <dons> but if you observe it, it will only have one particular type
22:26:29 <wagle> :t 1
22:26:30 <lambdabot> forall t. (Num t) => t
22:26:35 <dons> sets!
22:26:38 <dons> they're everywhere .. in type land
22:26:43 <wagle> it had to store that 1 somehow
22:26:52 <dons> yes.
22:26:52 <pumpkin-> centrinia: it's possible for a subset of a -> b :P
22:26:55 <dons> > [1]
22:26:57 <lambdabot>   [1]
22:26:58 <dons> :t [1]
22:26:59 <lambdabot> forall t. (Num t) => [t]
22:27:01 <hydrapheetz> :t [1..10]
22:27:02 <lambdabot> forall t. (Enum t, Num t) => [t]
22:27:02 <dons> cute eh?
22:27:05 <wagle> ooo..  maybe its a church numeral
22:27:11 <pumpkin-> :o
22:27:16 <dons> parametric polymorphism ftw!
22:27:57 <mmorrow> i accidently the paramorphism!@
22:28:09 <Axman6> :t flip Just
22:28:10 <lambdabot>     Couldn't match expected type `b -> c'
22:28:10 <lambdabot>            against inferred type `Maybe a'
22:28:10 <lambdabot>     Probable cause: `Just' is applied to too many arguments
22:28:12 <centrinia> Does the J# constructor of Integer accept a length and a byte array of bytes of an arbitrary precision integer?
22:28:15 * mmorrow to sleeep
22:28:27 <Axman6> centrinia: i believe so
22:28:49 <centrinia> What if the length doesn't fit in an Int?
22:28:53 <dons> Prelude> :set -fno-monomorphism-restriction
22:28:57 <dons> Prelude> let xs = [1..]
22:28:57 <dons> Prelude> :t xs
22:28:57 <dons> xs :: (Num t, Enum t) => [t]
22:28:59 <dons> woot
22:29:04 <dons> relude> sqrt (head xs)
22:29:04 <dons> 1.0
22:29:07 <dons> ok..
22:29:09 <dons> Prelude> Char.chr (head xs)
22:29:09 <dons> '\SOH'
22:29:10 <hydrapheetz> Wouldn't [1..] go on forever?
22:29:17 <dons> laziness + polymorphism.
22:29:19 <dons> haskell rulez.
22:29:26 <hydrapheetz> Neat.
22:29:38 <wagle> >flip out
22:29:42 <dons> making programming more fun since April 1st, 1990
22:30:03 <hydrapheetz> I'm used to things not really being lazy.
22:30:04 <dons> duck typing looks like a kids toy now
22:30:05 <Axman6> dons: how long have you been working on haskell?
22:30:11 <dons> since 1999
22:30:13 <centrinia> That's an joke.
22:30:19 <Axman6> nice
22:30:23 <dons> centrinia: :)
22:30:36 <centrinia> Was Haskell really an April fool's joke?
22:30:46 <dons> well. it was release on April 1. a fine day.
22:30:57 <dons> fooling the imperative programmers
22:31:36 <dons> so, who's working on a new library?
22:32:08 <dolio> centrinia: Your question was: what if the number of bytes in your Integer is greater than the largest number an Int can represent? :)
22:32:15 <wagle> self stabilizing ext2 file systems
22:32:43 <dolio> > (2^8)^(maxBound :: Int)
22:32:52 <pumpkin> lol
22:32:59 <lambdabot>   thread killed
22:33:01 <bd_> dolio: Just make sure Int is big enough to reference your entire address space :D
22:33:03 <Axman6> that could take a while
22:33:10 <dons> > 1 ^ 1000
22:33:19 <lambdabot>   1
22:33:25 <pumpkin> > 8 * (maxBound :: Int)
22:33:27 <lambdabot>   -8
22:33:33 <dolio> > (2^8)^(maxBound :: Int) :: Double
22:33:34 <lambdabot>   Infinity
22:33:39 <pumpkin> > 8 * fromInteger (maxBound :: Int)
22:33:40 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
22:33:45 <dolio> > (2^8)^(maxBound :: Int) :: CReal
22:33:46 <centrinia> dons: Yes.
22:33:48 <pumpkin> > 8 * fromIntegral (maxBound :: Int) :: Integer
22:33:49 <lambdabot>   73786976294838206456
22:33:56 <wagle> need to rename Int to unsafeInt
22:34:00 <lambdabot>   thread killed
22:34:00 <dons> > 7 ^ 7 ^ 7
22:34:03 <lambdabot>   375982352678378853892213093089591081706633380598437696378766710286205037494...
22:34:16 <bd_> wagle: you mean UnsafeInt :)
22:34:23 <centrinia> > 256^(2^31)+1
22:34:23 <dons> hey, do all the new people know about the haskell reddit?
22:34:24 <dons> http://www.reddit.com/r/haskell/
22:34:39 <lambdabot>   thread killed
22:34:58 <wagle> bd_ see?  that's what happens when you use them
22:35:04 <dolio> > maxBound `div` 1024 `div` 1024
22:35:05 <lambdabot>   Add a type signature
22:35:09 <dolio> > maxBound `div` 1024 `div` 1024 :: Int
22:35:11 <lambdabot>   8796093022207
22:35:17 <dolio> > maxBound `div` 1024 `div` 1024 `div` 1024 :: Int
22:35:19 <lambdabot>   8589934591
22:35:24 --- mode: ChanServ set +o dons
22:35:28 --- topic: set to '["Real World Haskell: out now", "Haskell News: http://reddit.com/r/haskell" "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
22:35:32 --- mode: ChanServ set -o dons
22:35:42 <dolio> > maxBound `div` 1024 `div` 1024 `div` 1024 :: Int32
22:35:44 <lambdabot>   1
22:35:52 <centrinia> Yay, RWH is out now. :)
22:35:59 <solrize> whee!  stack traces!!
22:36:50 <wagle> git diff HEAD^..HEAD -- topic
22:37:07 <dolio> centrinia: Even if you're stuck with 32-bit Ints, that means your single integer is around 2 gigabytes.
22:37:08 <pumpkin> he added reddit
22:37:17 <dolio> At least.
22:37:20 <centrinia> > let {f (S# _) = 0;  f (J# n _) = n; } in f (3^33)
22:37:22 <lambdabot>   Not in scope: data constructor `S#'Not in scope: data constructor `J#'
22:37:40 <centrinia> Weird.
22:38:26 <centrinia> dolio: A 2 gigabyte limit on the size of an integer might be limiting. :(
22:38:46 <dolio> To whom?
22:38:51 <jdavis> I started with Ocaml, and I don't really have a feel for the style. Is it normal to have fairly long functions inside of other functions, or should I separate them somehow? All the examples I see using "let" are for very short expressions or functions.
22:39:02 <centrinia> To me. :(
22:39:13 <pumpkin> jdavis: most people like to keep them short and reusable, as far as I've seen
22:39:13 <dolio> I only have 2 gigabytes of memory total in this computer.
22:39:23 <wagle> dolio me
22:39:28 <dolio> You're using single integers that are larger than my entire memory?
22:39:42 <jdavis> pumpkin: is there a general strategy for separating them into some other namespace so they don't pollute your module?
22:39:50 <centrinia> Sometimes.
22:39:57 <quicksilver> jdavis: your module doesn't have to export all its functions
22:40:04 <wagle> goedelizing large programs
22:40:05 <quicksilver> jdavis: polluting the module != polluting its interface
22:40:20 <wagle> sorry, thought he was talking about int32
22:40:25 <jdavis> quicksilver: oh, ok. Thanks.
22:40:53 <dons> jdavis: so you getting a feel for haskell?
22:41:45 <jdavis> dons: kind of. I like it quite a bit. It's certainly interesting/enjoyable.
22:42:07 <jdavis> dons: but I don't really know enough to have an opinion yet.
22:42:14 <Axman6> @src Integer
22:42:14 <lambdabot> data Integer = S# Int#
22:42:14 <lambdabot>              | J# Int# ByteArray#
22:42:27 <Axman6> where'd Integer defined?
22:42:30 <Axman6> s*
22:42:43 <dolio> Depends on your GHC version.
22:43:05 <dolio> Or, base version, I suppose.
22:43:08 <Axman6> 6.10
22:43:12 <dolio> They moved it recently.
22:43:38 <harblcat> Is it easy to parse YAML with Haskell?
22:44:14 <dolio> Axman6: It's in GHC.Integer.Internals.
22:44:24 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference
22:44:38 <pumpkin> harblcat: it appears that the YAML reference implementation is in haskell :)
22:45:06 <pumpkin> however, it doesn't look like it builds on 6.10
22:45:37 <dons> harblcat: hehe. probably it does, pumpkin . hackage is just a bit lazy.
22:45:44 <harblcat> Haha, they wrote the reference in Haskell?
22:45:58 <dons> oh maybe not. very interesting error in the logs.
22:46:01 <dons> harblcat: yeah. of course.
22:46:04 <dons> as with all good things
22:46:07 <pumpkin> :D
22:46:21 <dons> like the perl6 reference.
22:46:56 <dons> so no one working on any new libraries?
22:47:14 <Axman6> dons: got any easy libraries i could start? :)
22:47:23 <Axman6> bit bored atm
22:47:43 <dons> hmm. what's your favorite library that doesn't exist at the moment?
22:47:48 <pumpkin> dons: nothing so organized yet, but several of the things I'm working on might eventually coalesce into a few libraries
22:47:50 <dons> binding to C libs is always a good start.
22:47:57 <dons> pumpkin: great! what kind of things?
22:48:25 <pumpkin> dons: machine learning stuff and static analysis of binaries (separate things), mostly so far
22:48:30 <Axman6> hmm, if only i knew some nice C libraries
22:48:37 <pumpkin> but I'd also like to write c bindings to TAO and PETSc
22:48:37 <dons> pumpkin: interesting.
22:48:39 * pumpkin winks at Axman
22:48:40 <jsn> dons: working on EC2 bindings
22:48:43 <dons> yes. bindings are good.
22:48:47 <dons> jsn: awesome!
22:48:50 <dolio> dons: How's that uvector update coming? :)
22:48:55 <dons> dolio: yes!
22:49:02 <Axman6> pumpkin: What do they do? i could give it a shot, aybeh
22:49:04 <Axman6> m*
22:49:06 <vegai> IRC library, Jabber library, silcnet library
22:49:08 <dons> been thinking hard about Binary and bytestring interfaces, dolio
22:49:09 <pumpkin> Axman6: they'
22:49:13 <dons> vegai: jabber would be sweet.
22:49:20 <pumpkin> http://www-unix.mcs.anl.gov/tao/
22:49:41 <dons> well, vacation coming up. hope everyone puts things on hackage...
22:49:44 <vegai> I could imagine xmpp being a bit pain-in-the-ass to implement
22:49:48 <pumpkin> Axman6: http://www-unix.mcs.anl.gov/petsc/petsc-as/
22:49:54 <dons> 912 packages.
22:50:08 <pumpkin> Axman6: basically, very useful for scientific computing, not much for most people :) but still very handy if you need optimiation
22:50:14 <Axman6> i'd quite like to see a haskell irc client actually
22:50:21 <Axman6> pumpkin: aye
22:50:22 <dons> there was one, ginsu
22:50:39 <dons> oh, gale chat, not irc, http://repetae.net/computer/ginsu/
22:50:48 <pumpkin> another challenging one that sounds interesting, could be CGAL
22:50:48 <dons> you could write a new one using gtk
22:50:52 <dons> make it nice and pretty
22:51:00 <pumpkin> but due to its insane template-ness in c++, it might be hard
22:51:06 <Axman6> i'd prefer a cli client tbh ;)
22:51:28 <pumpkin> has anyone attempted to make a CGAL clone, if not bind to CGAL itself in haskell?
22:51:34 <Axman6> pumpkin: yeah, i might pass on that ;)
22:51:37 <pumpkin> lol
22:51:56 <pumpkin> I hate c++, but CGAL is really pretty awesome
22:52:08 <pumpkin> being able to use it (or something similar) in a good language would be nice
22:52:17 <pumpkin> (where good language = haskell)
22:53:09 <jdavis> Ok, back to the style question: if I have a function that is only used for one specific part of a larger function, is it bad style to declare and define it later in the file, or should I at least declare it above the calling function?
22:53:29 <pumpkin> maybe there should be a wiki page for projects people would like to see started in haskell (where the suggestions could be turned into links once someone starts them)?
22:54:16 <Axman6> jdavis: i'd use a where clause
22:54:35 <jdavis> Axman6: Ok, thanks.
22:54:45 <Axman6> f x = g x []; where g a x = ...
22:54:49 <pumpkin> this library seems pointless
22:56:11 <wagle> is pointless a library?
22:56:17 <pumpkin> yeah :P
22:56:19 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointless-haskell
22:56:27 <centrinia> pumpkin: That's good. I would like to see more libraries having @pl applied to them. :)
22:56:30 <Axman6> seems to me something like SafePrelude could be useful. where things with errors would return Maybe's
22:57:17 <centrinia> pumpkin: Do you do pointless programming? :)
22:57:33 <pumpkin> I try my best to do it as much as possible, without making things too obscure
22:57:42 <pumpkin> a little obscurity is nice ;)
22:58:36 <Smokey`> I just read that pointless description - and I still have no idea what it does - nor how it'd be useful.
22:58:41 <Axman6> i'd rather give people the change to choose whether they want an error or not
22:58:45 <solrize> so is it unhaskell to have a large-ish sum type (dozens of branches) and select on it with case statements?  will the compiler turn the pattern match into a jump table?
22:58:48 <Axman6> i might try this...
22:58:50 <jdavis> Axman6: If I'm using a long list of "where" declarations for a complex function, am I doing something wrong, or is that normal.
22:58:53 <jdavis> ?
22:59:04 <Axman6> jdavis: paste the code?
22:59:34 <pumpkin> Smokey`: play with @pl in here
22:59:39 <jdavis> Axman6: work in progress still, I'll try to give an example.
23:00:04 <pumpkin> @pl \(x, y) -> f y x
23:00:05 <lambdabot> uncurry (flip f)
23:00:07 <centrinia> @pl \fl op b as' -> case as' of { [] -> b; (a:as) -> fl op (op b a) as; }
23:00:07 <lambdabot> (line 1, column 29):
23:00:07 <lambdabot> unexpected "{"
23:00:07 <lambdabot> expecting variable, "(", operator or end of input
23:00:29 <centrinia> @pl \fl op b as' -> case as' of [] -> b; (a:as) -> fl op (op b a) as
23:00:30 <lambdabot> (line 1, column 32):
23:00:30 <lambdabot> unexpected ">" or "-"
23:00:30 <lambdabot> expecting variable, "(", operator or end of input
23:00:56 <quicksilver> jdavis: not necessarily; it's a subjective question of style. I prefer to have interesting parts of my algorithm at top-level so I can test them independently, though
23:01:28 <Smokey`> sigh, how little haskell I reall know is ... scary
23:01:30 <pumpkin> dons: you think it would be appropriate to create a haskell wiki page on projects/bindings people would like to see started in haskell?
23:01:48 <pumpkin> Smokey`: basically, it's removing explicit references to parameters
23:01:49 <Smokey`> I knoe 'enough' to write various programs, yet centrinia just blew my mind ;P
23:01:55 <Smokey`> know*
23:02:14 <Smokey`> pumpkin: I understood yours :)
23:02:26 <pumpkin> but it can get out of hand sometimes
23:02:29 <jsn> pumpkin: i would like to see that page
23:02:34 <jsn> especially if people voted
23:02:35 <wagle> <quote>
23:02:37 <Axman6> Smokey`: you can turn f xs = map g xs into f = map g
23:02:38 <wagle> There is an old joke in the BSD fortune file about Brian Kernighan's car: its only instrument is a big question mark on the dashboard, which lights when something goes wrong. ``The experienced driver,'' Dr Kernighan is quoted as saying, ``will know what's wrong.''
23:02:43 <pumpkin> jsn: that would be nice too
23:02:52 <centrinia> @pl (\fl op b as' -> case as' of [] -> b; (a:as) -> fl op (op b a) as)
23:02:53 <lambdabot> (line 1, column 33):
23:02:53 <lambdabot> unexpected ">"
23:02:53 <lambdabot> expecting variable, "(", operator or ")"
23:03:02 <centrinia> God damn. :|
23:03:09 <jsn> pumpkin: let's make a reddit
23:03:23 <pumpkin> jsn: a whole new reddit?
23:03:24 <wagle> (in response to SafePrelude reducing all errors to "Nothing"
23:03:27 <centrinia> > fix (\fl op b as' -> case as' of [] -> b; (a:as) -> fl op (op b a) as) (+) 0 [1,2,3,4]
23:03:29 <lambdabot>   10
23:03:35 <Axman6> wagle: yup
23:03:48 <pumpkin> jsn: I've never made a new reddit :o
23:04:07 <pumpkin> ooh
23:04:10 <pumpkin> good idea :)
23:04:35 <pumpkin> except how would people make the proposal point to the actual project page once it was started?
23:05:13 <dons> people keep making these pages, but they go out of date. but maybe a reddit is a good idea!
23:05:16 <dons> vote up / down.
23:05:18 <dons> very interesting ideaa.
23:05:36 <jdavis> Axman6, quicksilver: http://haskell.privatepaste.com/71rz90soe0 here's a very brief idea of what I'm doing. The "where" part will end up being 90+% of the function, and the top-level part of the function will be only a few lines.
23:05:45 <pumpkin> how can we make it updateable?
23:06:00 <Axman6> pumpkin: huh?
23:06:07 <pumpkin> our new reddit
23:06:29 <Axman6> updatable in which way?
23:06:39 <Axman6> seems like comments would be the way to 'update'
23:06:41 <jdavis> Axman6, quicksilver: oh, and that might not make sense if the definitions in the "where" list can't see the variables in the top-level function.
23:07:07 <pumpkin> well, people should submit project ideas for haskell, that people can vote up and down... once someone decides to implement the project, it would be nice to have it link to the project page
23:07:15 <pumpkin> but I guess people can just peruse the comments and find the link there
23:07:26 <pumpkin> jsn: should I create it or will you?
23:07:41 <wagle> how about a list of projects that need finishing?
23:07:56 <vegai> oh hey. An Imap library would be nice
23:07:57 <Axman6> i'd like to see a CouchDB tutorial...
23:08:13 <wagle> easy to start a project..  pita to finish it
23:08:16 <pumpkin> :)
23:08:31 <dons> yes. that's the only problem. reddit gets old over time.
23:08:32 <sjanssen> vegai: there's a half-finished IMAP library in the HaskellNet project
23:08:37 <centrinia> jdavis: Try this: until (==) big_calculation my_set
23:08:42 <dons> but maybe it at least keeps all the submission ideas around
23:08:50 <dons> we need a trac + vote
23:08:56 <pumpkin> yeah, I like that
23:08:57 <sjanssen> vegai: I've played around with it a bit, in can do basic stuff
23:09:02 <dons> think hard. this is a cool idea
23:09:12 <dons> and might over come the problem with the wiki approach - it gets out of date
23:09:17 <jdavis> centrinia: interesting, didn't know I could do that.
23:09:30 <vegai> sjanssen: ssl?
23:09:33 <pumpkin> someone could code up a happs app to track project ideas nicely
23:09:44 <pumpkin> quite quickly, I'd imagine
23:10:00 <centrinia> Uh, until (\(a',a) -> a == a') (\(_,a) -> (a, big_calculation a))  (my_set, big_calculation my_set)
23:10:05 <centrinia> Sorry.
23:10:39 <solrize> i wish that hackage had a php.net-like question/suggestion forum feature
23:10:45 <dons> yes. happs might be easy
23:10:57 <solrize> that's probably the best feature of php, the python crowd has been envying it for years
23:11:01 <jdavis> centrinia: ok, thanks.
23:11:41 <jsn> pumpkin: http://www.reddit.com/r/haskell_proposals/comments/7ia3m/ec2_bindings_for_haskell/
23:11:50 <pumpkin> ooh
23:11:59 <Axman6> ok, we're discussing a potential rewrite of macports in #macports. do people agree that haskell would be an excellent language for it?
23:12:06 <jsn> Axman6: yes
23:12:08 <pumpkin> yup
23:12:16 <jsn> Axman6: oh, i am so happy to hear that
23:12:17 <pumpkin> one issue I see with projects is that most people will just vote stuff up
23:12:19 <jsn> i would help
23:12:24 <pumpkin> because everyone wants to see as much stuff as possible :P
23:12:27 <Axman6> jsn: yeah, they don't want to hear it -_-
23:12:29 <jsn> my registry is trashed, &c.
23:12:31 <centrinia> jdavis: Actually, you might want to use that eliminate_extraneous function instead of big_calculation.
23:12:55 <jsn> pumpkin: well, then we have to vote stuff down
23:13:01 <pumpkin> :D
23:13:13 <jsn> think about this, also
23:13:21 <jsn> they know, they are giving away karma
23:13:26 <jsn> and karma is power
23:13:27 <dolio> @seen mmorrow
23:13:27 <lambdabot> mmorrow is in #xmonad, #darcs, #ghc and #haskell. I last heard mmorrow speak 45m 13s ago.
23:13:46 <centrinia> > fix (\f op a b -> if a == b then a else f b (op b)) (\x -> (x^2) `mod` 101) 3 3
23:13:47 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
23:13:47 <lambdabot>      Proba...
23:13:56 <jsn> it might be nice just to have ideas and commentary organized like that
23:14:03 <centrinia> > fix (\f op a b -> if a == b then a else f op b (op b)) (\x -> (x^2) `mod` 101) 3 3
23:14:04 <lambdabot>   3
23:14:31 <centrinia> Sorry, my bad. :p
23:14:33 <jsn> i think the threaded forum models conversation much better than a wiki page, to be honest
23:14:43 <centrinia> > fix (\f op a -> if a == (op a) then a else f op (op a)) (\x -> (x^2) `mod` 101) 3
23:14:57 <jsn> Axman6: you could start by using the cabal file format
23:14:59 <lambdabot>   thread killed
23:15:00 <pumpkin> jsn: me too
23:15:12 <Axman6> jsn: i don't think they'd want to change the format...
23:15:18 <jsn> :(
23:15:37 <wagle> reading 10,000 messages from a forum is painful..  nice to have summaries?
23:15:41 <dolio> @tell mmorrow I think the continuation passing aspect of binary is in Builder, not Get or Put. Changing Put to a CPSed representation actually makes it slower for me.
23:15:42 <lambdabot> Consider it noted.
23:15:45 <jsn> well, it's full of TCL, so if you rewrote the system you'd likely have to change the format
23:16:19 <centrinia> > iterate (\x -> (x^2) `mod` 101) 3
23:16:21 <lambdabot>   [3,9,81,97,16,54,88,68,79,80,37,56,5,25,19,58,31,52,78,24,71,92,81,97,16,54...
23:16:21 <jsn> wagle: when we get a library proposal with even 100 messages, we'll worry about it
23:16:53 <wagle> oic... hmm
23:16:55 <jdavis> centrinia: yeah, that function does a lot of the work. The algorithm is basically about 8 functions, each about 5-10 lines. I'm just trying to make it as readable as possible. I can make it pretty much entirely "flat" by naming all the functions, or I could make it a little deeper by using more lambdas or let definitions.
23:17:09 <centrinia> Weird, x -> x^2 doesn't have a fixed point in Z_{101} ?
23:17:36 <pumpkin> jsn: shouldn't it be Haskell Proposals as the title? the underscore looks odd :)
23:17:46 <jsn> pumpkin: it is required
23:17:48 <centrinia> jdavis: Which algorithm is it?
23:17:55 <pumpkin> jsn: as part of the name, yeah, but the title?
23:18:00 <wagle> even 100 messages can contain a lot of info that is later rendered unimportant or wrong
23:18:41 <jsn> pumpkin: i am pretty sure they are exactly the same
23:18:52 <wagle> i'm not sure i have a position though
23:19:01 <centrinia> Are there Haskell User Groups (HUG)?
23:19:16 <jdavis> centrinia: well, I don't know if it has a name. I'm manipulating functional dependencies (relational database theory), and I sort of made it up. I think that it's known, but I don't know if it has a name.
23:19:16 <jsn> wagle: i don't understand what concrete steps i can take, given that reddit is what it is
23:19:44 <centrinia> jdavis: It should have a name.
23:19:47 <centrinia> What does it do?
23:20:10 <jdavis> centrinia: it already works fine in OCaml, but I'm rewriting it in Haskell (and changing it around somewhat) to learn it.
23:20:26 <jdavis> centrinia: it creates an irreducible cover.
23:20:50 <jdavis> centrinia: or maybe it would be more precise to say "an irreducible covering set of functional dependencies"
23:21:17 <centrinia> Oh, the minimal cover.
23:22:06 <jdavis> centrinia: _a_ minimal cover. It's not convenient to have a cononical form, but you can create a minimal cover, and test equivalence with other minimal covers.
23:22:49 <centrinia> Do you have a working closure algorithm?
23:23:16 <vegai> is vty still The Way to do console ascii 'graphics'?
23:23:18 * wagle looks at reddit
23:23:28 <wagle> wow..  timber lives!
23:23:47 <vegai> looked rather cool
23:24:42 <jdavis> centrinia: I have what I call (again, probably has a real name) a "partial closure" which is the closure with respect to some set of attribute sets (in this case, the union of the LHSs of the two FD sets I'm comparing)
23:25:22 <centrinia> That is called the closure of X with respect to Y.
23:26:00 <jdavis> centrinia: ok, that makes sense. I'll be renaming that then ;)
23:27:08 <jdavis> centrinia: that was quite easy, actually. The harder part was the irreducible cover (also not too hard, I have a working version in OCaml).
23:29:25 <wagle> jsn, i was responding to coming into a 83 message thread of long messages, most of which ended up being wrong..  nothing about reddit
23:29:31 <centrinia> Okay.
23:29:59 <jsn> oh
23:31:29 <jsn> so, if applicative functors model sequencing, is there something which models simultaneity?
23:31:55 <jdavis> centrinia: Going to sleep now, but thanks for the insights.
23:32:14 <centrinia> Sure.
23:38:17 <pumpkin> jsn: we need to advertise!
23:38:50 <pumpkin> I've submitted a couple of things I'd like to see
23:38:55 <jml> ok. that's it. I'm fed up with writing Python today
23:39:35 <mlesniak> Anyone here which has some initial experience with HSCurses?
23:40:11 <profmakx> @src words
23:40:12 <lambdabot> words s = case dropWhile isSpace s of
23:40:12 <lambdabot>     "" -> []
23:40:12 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
23:40:52 <jsn> pumpkin: good wine needs no sign :)
23:41:08 <wagle> jsn..   stumper..  best lead i can think of is "a clock"
23:42:14 <jsn> wagle: ?
23:42:42 <sjanssen> jsn: applicative functors don't necessarily model sequencing
23:42:56 <jsn> wagle: i understand now
23:43:00 <sjanssen> it is not difficult to imagine an AF that executes all actions in parallel
23:43:34 <jsn> sjanssen: hmm
23:43:37 <wagle> jsn, thought of a synchronous cellular automata, and some people claiming it needs a global clock
23:43:48 <wagle> AF?
23:43:55 <sjanssen> wagle: applicative functor
23:44:25 <sjanssen> in fact, it sounds interesting, I'll write that up real quick
23:45:11 <wagle> i was thinking "sequential" was a constraint.. and lack of constraint permits (but doesn't require) simultaneity
23:45:39 <jsn> i am still learning about applicative
23:46:06 <redditbot> fhtr: Distorted hex : Haskell + Cairo
23:46:11 <sjanssen> jsn: Applicative is actually less sequential than Monad
23:46:26 <pumpkin> > (,) <$> [1,2,3] <*> [4,5,6]
23:46:28 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:46:38 <jsn> sjanssen: less sequential? i thought the distinction had to do with binding
23:47:07 <jsn> which is to say, failure of one cause failure of all the rest
23:47:16 <sjanssen> jsn: (>>=) has more sequence requirements than (<*>)
23:47:37 <sjanssen> neither Monads nor Applicatives necessarily have anything to do with failure
23:47:47 <jsn> hmm, okay
23:48:10 <jsn> sjanssen: can you explain to me, what the difference in sequencing requirements is?
23:48:45 <sjanssen> @type (>>=)
23:48:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:49:00 <jsn> @type (<*>)
23:49:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:49:16 <sjanssen> jsn: in "m >>= f", the result of m must be passed to f
23:49:37 <sjanssen> essentially requiring that m be executed before f
23:49:45 <jsn> sjanssen: right
23:50:15 <jsn> oh, but applicative is backwards
23:50:32 <jsn> we must have the f a term to feed to the f (a -> b) term
23:51:09 <jsn> :t <$>
23:51:11 <lambdabot> parse error on input `<$>'
23:51:22 <jsn> :t (<$>)
23:51:24 <sjanssen> well, both arguments are wrapped in 'f', so they can be executed in either order
23:51:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:52:00 <sjanssen> ie. for any Applicative, you can write an alternate instance that executes the arguments in reverse order
23:52:00 <jsn> sjanssen: oh, you know, you are right
23:52:26 <Axman6> what does f <*> x <$> y <*> z end up as? (if that makes any sense)
23:52:28 <jsn> you don't need to the 'f a' to figure out what is in the 'f (a -> b)'
23:52:30 <sjanssen> (a Reverse newtype would also be neat, should write that too)
23:53:52 <jsn> so the fact that (<$>) works in the IO monad just has to do with it's instance of applicative
23:54:20 <Axman6> @instances Applicative
23:54:21 <jsn> well, no
23:54:22 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
23:54:26 <pumpkin> :t f <*> x <$> y <*> z
23:54:28 <lambdabot>     Couldn't match expected type `a -> a1' against inferred type `Expr'
23:54:28 <lambdabot>     In the second argument of `(<*>)', namely `x'
23:54:28 <lambdabot>     In the first argument of `(<$>)', namely `f <*> x'
23:54:36 <jsn> of course that doesn't matter, since the first term is pure
23:54:41 <sjanssen> jsn: (<$>) is just fmap, which is in the Functor class
23:54:42 <pumpkin> Axman6: I normally stick the <$> up front :P
23:54:58 <jsn> sjanssen: right, i was being silly
23:55:03 <sjanssen> http://hpaste.org/12886 Applicative that executes IO actions in parallel
23:55:09 <Axman6> pumpkin: yeah, well i have no idea how applicative it used :)
23:55:35 <pumpkin> Axman6: one example people used for me was to use it as a replacement for zipN
23:55:51 <Axman6> could you give me that example? :)
23:56:15 <pumpkin> > (,,,) <$> [1..] <*> [2..] <*> [3..] <*> [4..]
23:56:18 <lambdabot>   [(1,2,3,4),(1,2,3,5),(1,2,3,6),(1,2,3,7),(1,2,3,8),(1,2,3,9),(1,2,3,10),(1,...
23:56:34 <Axman6> that's not zipN...
23:56:48 <pumpkin> that's zip4
23:57:12 <Axman6> > zip3 [1..] [2..] [3..]
23:57:14 <lambdabot>   [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8),(7,8,9),(8,9,10),(9,10,11)...
23:57:21 <Axman6> should look more like that
23:57:37 <pumpkin> oh, you're right
23:57:43 <dolio> It's cartesian-product4.
23:57:45 <pumpkin> yup :P
23:57:47 <pumpkin> sorry
23:57:50 <dolio> You need some ZipLists in there to get zip.
23:57:57 <Axman6> > (,,,) <*> [1..] <$> [2..] <$> [3..] <$> [4..]
23:57:59 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
23:58:04 <Axman6> bah
23:58:33 <ksf> just freaking use zip
23:58:46 <Axman6> @hoogle zip
23:58:47 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
23:58:47 <lambdabot> Data.ByteString zip :: ByteString -> ByteString -> [(Word8, Word8)]
23:58:47 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
23:58:47 <pumpkin> lol
23:59:39 <Axman6> @hoogle zip4
23:59:39 <lambdabot> Data.List zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
23:59:39 <lambdabot> Data.List unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
23:59:43 <Axman6> @hoogle zip5
23:59:43 <lambdabot> Data.List zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
23:59:43 <lambdabot> Data.List unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
23:59:46 <Axman6> @hoogle zip10
23:59:47 <lambdabot> No results found
23:59:50 <Axman6> @hoogle zip9
23:59:50 <lambdabot> No results found
23:59:54 <pumpkin> Axman6: let me revise that to liftAn then :P
