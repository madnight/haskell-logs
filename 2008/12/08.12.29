00:00:22 <chelz> citizen_earth: oscommerce definitely is the most popular. not sure why that one guy doesn't like it.
00:08:14 <scriptdevil> I know that you cannot do x = x + 5 in haskell. But how does ghci assign "it"?
00:08:31 <vixey> scriptdevil, you can do that
00:08:51 <vixey> x = x + 5 = (x + 5) + 5 = ((x + 5) + 5) + 5 = ...
00:11:02 <idnar> scriptdevil: stuff typed in at the ghci prompt is sort of in the body of a big do statement
00:11:32 <scriptdevil> idnar: so.. we have to do a let lhs = rhs?
00:12:10 <scriptdevil> vixey: that will be an infinite loop...
00:12:56 <vixey> scriptdevil: I felt really pedantic I could define a screwy (+) for which it gave results :p
00:12:59 <scriptdevil> vixey: I meant something like it + 5 in ghc
00:13:01 <vixey> scriptdevil: in general yeah
00:13:20 <scriptdevil> it is not the loop kinda thing. it is a proper +
00:13:52 <Cale> scriptdevil: 'it' is simply bound to the result of the last expression you gave to ghci
00:14:01 <Cale> scriptdevil: It's not a proper part of the Haskell language.
00:14:59 <scriptdevil> Cale: Ok... That was something I was looking for. :D Thanks
00:16:31 <scriptdevil> I was kinda getting confused. Am I right in assuming it is assigned to the a monad that returns the previous result?
00:16:38 <francis> http://hpaste.org/13398
00:16:52 <francis> disclaimer: i really dont know much about haskell
00:17:08 <Cale> scriptdevil: There's nothing monadic about 'it'
00:17:31 <scriptdevil> I mean it <- prevVal()
00:17:47 <scriptdevil> Cale: I should say I am not good at expressing myself
00:17:50 <scriptdevil> :-|
00:17:54 <francis> im attempting to get a list of primes under n, perform a rotation on all the values, and then test the intersect between the rotated values and the original primes list
00:18:09 <Cale> scriptdevil: Oh, I suppose ghci itself is written in the IO monad, and there's some loop going on where the value of the last evaluation is passed as a parameter.
00:18:33 <Cale> Or possibly stored in an IORef or something like that, but most likely it's just a parameter.
00:18:42 <francis> just wondering if someone could look at my paste and tell me what im doing wrong :P
00:19:01 <Cale> Prelude> :t it
00:19:01 <Cale> <interactive>:1:0: Not in scope: `it'
00:19:01 <Cale> Prelude> 5
00:19:01 <Cale> 5
00:19:01 <Cale> Prelude> :t it
00:19:02 <Cale> it :: Integer
00:19:07 <Cale> francis: I'll have a look :)
00:19:16 <francis> thanks :)
00:19:39 <Cale> Your 'if' has no 'else'
00:20:10 <Cale> Also, there are tabs in your file, which you should be wary of
00:20:25 <Cale> (configure your editor so that it turns tabs into the appropriate number of spaces)
00:20:37 <francis> what if i dont want it to do anything in case the test fails?
00:20:42 <adrian> mixing tabs and spaces has often lead to very confusing errors
00:20:53 <francis> im working with a ginormous list (75,000) values
00:20:54 <Cale> francis: It's not *doing* anything in any case.
00:21:08 <adrian> francis: use a Maybe
00:21:13 <adrian> and return Nothing
00:21:16 <Cale> francis: It's resulting in a value. Which value should it result in if the test fails?
00:21:30 <francis> i just want it to print out the value
00:21:43 <Cale> francis: Then what do you need the 'if' for?
00:21:49 <francis> its a test
00:21:55 <Cale> mhm...
00:22:10 <francis> a very crude intersection test
00:22:34 <francis> basically, im trying to see if all rotations of a number also exist in the original list
00:22:43 <Cale> So if the length of those two things are equal, then the result of checkList s n is the second length
00:22:54 <Cale> What should checkList s n be if they're not equal?
00:22:59 <francis> nothing
00:23:05 <francis> i just want to see when they're equal
00:23:08 <Cale> An error?
00:23:14 <francis> nope, just ignore it
00:23:18 <Cale> What?
00:23:18 <francis> (if it can)
00:23:24 <Cale> It has to be a value
00:23:31 <vixey> francis: observe this:
00:23:33 <Cale> checkList s n is an Int
00:23:42 <francis> but i dont want it printing out 74000 values that i have no need for :/
00:23:43 <Cale> Which Int should it be if the test fails?
00:23:44 <vixey> > let x = 1 in   if x == 1 then "ok" else "not ok"
00:23:45 <lambdabot>   "ok"
00:23:49 <vixey> francis, and:
00:23:50 <vixey> > let x = 2 in   if x == 1 then "ok" else "not ok"
00:23:52 <lambdabot>   "not ok"
00:23:58 <Cale> francis: Then shouldn't checkList be a Bool?
00:24:01 <vixey> now what should:  let x = 2 in   if x == 1 then "ok"       be/do?
00:24:08 <Cale> francis: You could then filter the list of values you're testing.
00:24:31 <francis> oh wait
00:24:36 <adrian> > let x =2 in if x==1 then Just x else Nothing
00:24:37 <lambdabot>   Nothing
00:24:49 <adrian> > let x = 1 in if x==1 then Just x else Nothing
00:24:50 <francis> so checkList isnt printing out the result to stdout?
00:24:50 <lambdabot>   Just 1
00:24:57 <Cale> francis: map f xs always has the same length as xs
00:25:03 <Cale> francis: no it isn't
00:25:20 <vixey> @free length
00:25:21 <francis> its storing each result in a new list isnt it
00:25:21 <lambdabot> length = length . $map f
00:25:25 <Cale> francis: checkList is taking a couple of values s and n and giving an Int
00:25:30 <Cale> no
00:25:34 <Cale> It's not doing that either.
00:25:38 <francis> where does the int go?
00:25:42 <Cale> All that checkList does is turn s and n into an Int
00:26:43 <francis> hence the disclaimer i guess, im not very familiar with the workings of haskell :(
00:27:10 <Cale> Okay, you're applying map to checkList, which gives you a function that applies checkList to every value in a list.
00:27:24 <francis> yep
00:27:34 <Cale> However, as a function of two parameters, that means that the resulting list will be a list of functions.
00:27:38 <Cale> For instance...
00:27:45 <Cale> map checkList [1,2,3]
00:27:55 <Cale> = [checkList 1, checkList 2, checkList 3]
00:28:07 <francis> ah
00:28:22 <francis> so the output would be the int result of each checklist run?
00:28:24 <Cale> also, note that this list has the same length as the list [1,2,3]
00:28:26 <cizra> As a person interested in FP I ought to like curry but I don't )=
00:28:27 <francis> (in list format)
00:28:45 <Cale> map will never skip over some values.
00:28:52 <francis> so say checklist 1 returned a length of 5
00:28:59 <Cale> cizra: The food, or the idea?
00:29:06 <francis> but checklist 2 returned a 0 which i put in the "else"
00:29:10 <francis> i would get
00:29:15 <francis> [5,0.... ?
00:29:18 <Cale> francis: yes
00:29:22 <francis> fantastic
00:29:28 <Cale> francis: Of course, since checkList takes another parameter...
00:29:29 <francis> then i can just sum $ them
00:29:29 <cizra> Cale: food. Idea I'm entirely comfortable with. Actually, I "invented" it in around 6th grade to understand linear equation systems.
00:29:35 <Cale> francis: All you're getting are a bunch of functions
00:29:43 <francis> Cale: the other parameter is defined at the beginning
00:29:49 <francis> does that get passed on?
00:29:54 <Cale> Except that it's not in your code.
00:30:00 <francis> (without me explicitly defining it in each function)
00:30:09 <Cale> You'd want something like  map (checkList 5) ...
00:30:19 <Cale> To supply the 's' parameter
00:30:31 <francis> ah
00:30:42 <Cale> Except that's still not what you want.
00:30:51 <Cale> What you really want is for checkList to produce a Bool
00:30:58 <Cale> and you want filter, not map
00:31:08 <francis> i really need the length though
00:31:32 <Cale> Well, then  length (filter (checkList k) ...)
00:31:34 <francis> because between 0 and 1000000 you have anything ranging from 1 digit to 6 digits
00:32:19 <francis> aaaaaaaah
00:32:23 <francis> i see what you mean
00:32:37 <Cale> You want the number of values which meet the condition?
00:32:40 <Cale> That's how you'd get it.
00:32:56 <francis> that will generate a list containing all the values that pass the test
00:33:02 <francis> and then get the length
00:33:05 <Cale> yeah
00:33:08 <francis> super
00:34:17 <vixey> in lambda calculus, does  neutral  mean something specific?
00:35:08 <vixey> I'm guessing it means that there's no applications which could be reduced but I haven't seen any definition
00:35:21 <therp> vixey: that's the first time I hear that wrt lambda calculus
00:35:33 <therp> isn't that "normalized"
00:35:39 <francis> ok, how does this look then
00:35:39 <francis> http://hpaste.org/13398#a1
00:36:16 <francis> i guess i dont need the if/then anymore
00:36:59 <Cale> right, you don't, and they're True and False rather than TRUE and FALSE
00:37:21 <vixey> I guess so therp, so neutral probably doesn't mean what I guessesd
00:37:42 <Cale> also, filter (checkList n) -- the parens are not optional
00:38:49 <francis> http://hpaste.org/13398#a3 ? :)
00:39:51 <Cale> There are a lot of places left where you have both $ and parens...
00:39:59 <Cale> but otherwise, that looks okay
00:40:12 <therp> vixey: http://people.cs.uu.nl/andres/LambdaPi/LambdaPi.pdf - they use neutral as in: A value is either a neutral term, i.e., a variable applied to a (possibly empty) sequence of values, or it is a lambda abstraction.
00:40:48 <ik> Is there any sort of rule about when to use $ vs () ?  I guess it's just a style thing, but what's the regular Thing to Do?
00:41:14 <Cale> ik: I tend to write long composition chains like   f . g . h $ x
00:41:50 <idnar> ik: I tend to prefer $ when the code in () would be quite long
00:41:58 <Cale> and use parens when it doesn't work out, or when it's just one pair of parens
00:42:10 <Cale> Or yeah, if the ( is far away from the )
00:42:19 <francis> im still trying to get a grasp of the syntax
00:42:19 <idnar> whereas something like filter (checkList n) seems nicer than filter $ checkList n or whatever
00:42:25 <ik> idnar: yeah.. ' head $ lots of crap ' is usually what I end up doing
00:42:35 <ik> vs something (one thing) (another thing)
00:42:51 <ik> I guess it's fairly obvious.  I've just caught myself using more than a few '$' in places..
00:42:53 <francis> its pretty difficult without syntax highlighting
00:43:14 <Cale> http://hpaste.org/13398#a5
00:43:18 <francis> ok so ive got a bunch of warnings
00:43:22 <francis> well errors
00:43:23 <francis> testme.hs:177:108: Not in scope: `primesUnder'
00:43:30 <Cale> Well, you haven't written that.
00:43:30 <francis> for each function in my script
00:43:32 <Cale> ;)
00:43:42 <Cale> Where's the primesUnder function defined? :)
00:43:48 <ik> This already sounds like project euler
00:44:01 <francis> it is
00:44:09 <francis> im trying to solve all the problems with haskell
00:44:13 <Cale> francis: Not in that code it isn't.
00:44:20 <Cale> oh
00:44:29 <Cale> You were responding to ik :)
00:44:38 <loop> 99% of haskell code dealing with prime numbers is for project euler? =)
00:44:42 <francis> ya my bad
00:44:43 <ik> loop: yes :)
00:44:49 <francis> ya loop why else? lol
00:44:58 <ik> loop: or at least strange arbitrary things like "all the prime numbers under one million"
00:45:17 <ik> It's pretty easy to spot project euler problems, especially in this context
00:46:32 <francis> its not a bad thing is it?
00:48:33 <ik> nah
00:48:38 <francis> meh, still getting "not in scope" errors
00:48:41 <ik> I just felt the need to comment I guess
00:48:43 <vixey> I tried to write a program in Omega but it was so confusing, I couldn't understand if I was doing something wrong or if it was the Omega system not figuring out that the program really was ok
00:48:44 <ik> francis: does it exist yet?
00:48:46 <francis> http://hpaste.org/13398#a6
00:48:59 <francis> yes :P
00:49:15 <francis> might this have something to do with not importing data.list?
00:49:28 <ik> what's it say isn't in scope?
00:49:33 <vixey> some very impressive programs in the manual though
00:49:39 <francis> testme.hs:177:108: Not in scope: `primesUnder'
00:49:39 <francis> testme.hs:178:26: Not in scope: `intersect'
00:49:39 <francis> testme.hs:178:37: Not in scope: `rotatedPrimesListFor'
00:49:39 <francis> testme.hs:178:62: Not in scope: `primesUnder'
00:49:39 <francis> testme.hs:178:91: Not in scope: `rotatedPrimesListFor'
00:49:42 <francis> sorry for the spam
00:49:48 <yakov> hey
00:50:06 <francis> its complaining about intersect, but i realize why its doing that
00:50:19 <ik> well, rotatedPrimesListFor doesn't seem to exist.
00:50:28 <francis> what about primesUnder?
00:51:29 <francis> ive definitely defined that
00:52:51 <francis> bah this recursive definition stuff is mind-bending
00:53:56 <blackdog> seafood: what are you doing here, ocaml boy?
00:55:38 <Gracenotes> hm, is it a good idea to add appropriately-licensed hackage packages to http://www.google.com/codesearch?
00:56:25 <Gracenotes> (not just a few -- it would have to be a coordinated effort to get 'em all hosted...)
01:07:11 <seafood_> I want to write websites in this beautiful language.
01:07:35 <loop> go ahead, then
01:08:26 <seafood_> It's a work in progress :)
01:08:28 <vixey> of everything you could do,.. websites?
01:08:50 <seafood_> vixey: Yeah. Why not?
01:20:01 <francis> a function that takes an integer and outputs a list of integers would be defined as: function :: Integer -> [Integer] ?
01:20:27 <mbz> francis: yes
01:21:44 <francis> im getting a bunch of errors though :/
01:21:45 <francis> http://hpaste.org/13398#a7
01:22:13 <francis> i tried Integer -> Integer -> [Integer] as well and no luck
01:22:41 <arw> francis: try Integer -> [Integer]
01:22:59 <arw> you only have one argument and the return value.
01:23:11 <francis> when i had that
01:23:12 <francis> newtest.hs:181:74:
01:23:12 <francis>     Couldn't match expected type `Integer'
01:23:12 <francis>            against inferred type `[Integer]'
01:23:14 <francis> i got this
01:23:24 <Gracenotes> wow, Project Euler is somewhat addictive...
01:23:42 <francis> ya it is lol
01:23:57 <francis> soon as im done with this problem im trying #79
01:24:00 <francis> i hear its awesome
01:24:03 <arw> ah.
01:24:06 <Gracenotes> digging up my account I haven't touched in 2 years...
01:24:15 <Gracenotes> I've solved a total of 2 problems :P
01:24:16 <arw> takeWhile returns a list of course.
01:24:25 <francis> ya
01:24:26 <arw> na.
01:24:29 <arw> ignore that.
01:26:13 <francis> arw: http://hpaste.org/13398#a8
01:26:24 <francis> ah shit my bad
01:26:45 <nolrai_East> I am trying to get ghci-haskeline to install but i get "ld: cannot find -ledit".  What do I need to Install?
01:27:36 <arw> francis: is your primes-function ok? what type is it?
01:27:43 <francis> list
01:27:53 <francis> im using oneill
01:28:46 <vixey> arw, aww
01:29:01 <vixey> arw, you're reminding me that you can't have nice hypenated identifier names in haskell :(
01:29:37 <francis> http://hpaste.org/13398#a9
01:29:49 <francis> so fixing the definitions got rid of the other errors
01:29:57 <francis> just stuck with primesUnder now
01:30:03 <arw> yep, i hate those languages like haskell, which impose arbitrary restrictions on identifiers.
01:30:07 <francis> err rotatedPrimesListUnder
01:30:31 <arw> "oh, thats a type, please start with a capital letter, or i won't compile and sit in a corner crying"
01:31:35 <vegai> rather "learn my syntax, you moron"
01:31:38 <cizra> arw: It imposes a sort of style.
01:31:50 <francis> rotatedPrimesListUnder n = filter (checkList n) . map (take 4 . iterate (\(x:xs) -> xs ++ [x])) $ primesUnder n
01:32:03 <francis> that's taking an integer and returning a list
01:32:14 <cizra> arw: Whatever it is, if it's lowercase, it's a value.
01:32:23 <francis> so ive defined it as rotatedPrimesListUnder :: Integer -> [Integer]
01:32:29 <vegai> cizra: or function? :)
01:32:30 <arw> cizra: exactly, it imposes an arbitrary restriction somebody considered to be 'good style'...
01:32:40 <RayNbow> vegai: functions are also values :p
01:32:42 <cizra> vegai: Well, functions are values…
01:32:45 <yakov> could anybody help, does latest (darcs version?) cabal support hsc2hs ?
01:32:54 <vegai> aa, ok.
01:33:20 <cizra> arw: Yea. Whatever your aesthetic opinions on uppercase letters, it's _objectively_ good that you can distinguish types from values at a glance.
01:33:24 <arw> francis: well, the declaration of checkList says s is [Integer] because its the second parameter
01:34:19 <arw> francis: but you give s as the first parameter to rotatedPrimesListUnder which takes an Integer, no list.
01:34:21 <Cale> cizra: actually it's not to distinguish types from values, the uppercase/lowercase is to distinguish constructors from variables
01:34:47 <francis> aaaah
01:34:57 <cizra> Cale: Data constructors look just like regular functions to me…
01:35:02 <Cale> (for pattern matching, in the case of values, and for telling what's a type and what's a type variable in the case of types)
01:35:22 <Cale> They're not regular functions.
01:35:27 <Cale> You can pattern match against them.
01:35:54 <Cale> compare  f True = 0  with  f true = 0
01:36:15 <cizra> OK
02:11:56 <jberryman> what does it mean that I'm constantly finding I want to pattern match functions?
02:13:06 <luqui> jberryman, what do you mean you want to pattern match functions?
02:13:09 <luqui> I can't even picture that?
02:13:33 * vixey supposes  f (x ++ y) = ... ?
02:14:44 <luqui> oh, yeah, that'd be sweet.   Of course, we just use Coq and then prove that those things are satisfied.
02:14:50 <luqui> which is ever so much more work.
02:15:18 <vixey> o_O
02:16:00 <JoshTriplett> @pl \m x -> 1 <= x && x <= m
02:16:01 <lambdabot> liftM2 (&&) (1 <=) . flip (<=)
02:16:10 <vixey> jberryman, is that what you meant though?
02:16:24 * JoshTriplett tries to remember the lambdabot invocation for "what name does this function go by".
02:16:36 <jberryman> actually I was just having a really hard time figuring out what the heck I was talking about. I realized I mean function names, so I guess something like: f (+) = ...; f (-) = ...
02:16:51 <thoughtpolice> jberryman: you mean like view patterns?
02:17:01 <JoshTriplett> @help name
02:17:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:17:12 <JoshTriplett> @help @name
02:17:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:17:34 <jberryman> thoughtpolice: I dunno...?
02:17:44 <vixey> it's not like view patterns
02:17:55 <JoshTriplett> @pl \min max val -> min <= x && x <= max
02:17:55 <lambdabot> (const .) . (. (x <=)) . (&&) . (<= x)
02:17:55 <thoughtpolice> jberryman: view patterns allow you to write code like "f (g -> Just x) = ..."
02:18:06 <thoughtpolice> (where 'g' is a function)
02:18:51 <maltem> jberryman: do you want it like, data Op = Plus | Minus; f Plus = ...; f Minus = ...?
02:19:21 <JoshTriplett> @pl \(min, max) val -> min <= x && x <= max
02:19:22 <lambdabot> uncurry ((const .) . (. (x <=)) . (&&) . (<= x))
02:19:28 <Cthulhon> @hoogle inRange
02:19:28 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
02:19:28 <lambdabot> Distribution.Version withinRange :: Version -> VersionRange -> Bool
02:19:45 <JoshTriplett> Cthulhon: Hmmm, almost.  Thanks anyway, though.
02:20:18 <jberryman> maltem: I got that example from trying to do something like that, yeah.
02:21:05 <JoshTriplett> @hoogle (a, a) -> a -> Maybe a
02:21:05 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:21:05 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:21:05 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
02:21:52 <luqui> JoshTriplett, what do you mean almost?
02:22:00 <JoshTriplett> luqui: That requires Ix.
02:22:16 <luqui> JoshTriplett, oh instead of just Ord
02:22:26 <JoshTriplett> Right.
02:22:51 <jberryman> thoughtpolice: I'm trying to read the docs on view patterns, but can you explain what that pattern is doing?
02:22:58 <JoshTriplett> @pl \(min, max) val -> guard $ min <= x && x <= max >> x
02:22:59 <lambdabot> uncurry (((const . guard) .) . flip flip x . ((>>) .) . (. (x <=)) . (&&) . (<= x))
02:23:08 <JoshTriplett> Aieee, pl not helping at all. :)
02:23:26 <Cthulhon> You forgot to rename x in the body. :)
02:23:33 <JoshTriplett> Oh, that could do it. :)
02:23:43 <JoshTriplett> @pl \(min, max) val -> guard $ min <= val && val <= max >> val
02:23:44 <lambdabot> uncurry (((guard .) .) . flip flip id . (liftM2 (>>) .) . (. flip (<=)) . ap . ((&&) .) . (<=))
02:23:47 <JoshTriplett> Ow.
02:23:52 <Cthulhon> Much clearer!
02:23:56 <JoshTriplett> Riiiight.
02:24:10 <JoshTriplett> @type \(min, max) val -> guard $ min <= val && val <= max >> val
02:24:11 <lambdabot>     Couldn't match expected type `m a' against inferred type `Bool'
02:24:12 <lambdabot>     In the first argument of `(>>)', namely `min <= val && val <= max'
02:24:12 <lambdabot>     In the second argument of `($)', namely
02:24:36 <JoshTriplett> @pl \(min, max) val -> guard (min <= val && val <= max) >> val
02:24:37 <lambdabot> uncurry (flip flip id . (liftM2 ((>>) . guard) .) . (. flip (<=)) . ap . ((&&) .) . (<=))
02:24:42 <JoshTriplett> OK, a little better.
02:24:50 <JoshTriplett> pl apparently had no problem assuming bad types. :)
02:24:54 <JoshTriplett> @typew \(min, max) val -> guard (min <= val && val <= max) >> val
02:24:56 <lambdabot> forall (m :: * -> *) b. (MonadPlus m, Ord (m b)) => (m b, m b) -> m b -> m b
02:24:57 <lepassive> What is the difference between square :: Num a => a -> a and square :: Int -> Int
02:25:09 <JoshTriplett> lepassive: The former works on any Num, while the latter only works on Int?
02:25:29 <JoshTriplett> lepassive: So you could call the former on Integer instead.
02:25:33 <lepassive> JoshTriplett, well what does "=>" mean really ?
02:26:05 <JoshTriplett> lepassive: square :: Num a => a -> a means "square has the type a -> a for some Num a"
02:26:13 <JoshTriplett> Er, correction.
02:26:16 <JoshTriplett> lepassive: square :: Num a => a -> a means "square has the type a -> a for any Num a"
02:27:09 <JoshTriplett> lepassive: Haskell has a class "Num".  Instances of Num must provide certain functions, like (*).
02:27:34 <JoshTriplett> lepassive: So to look at it another way, "square can square anything for which (*) exists".
02:27:48 <lepassive> JoshTriplett, Thanks alot, the => doesn't makes sense to me the square:: Int -> Int is meaningfull, square takes an int and returns an int
02:28:23 <JoshTriplett> > let square :: Int -> Int ; square x = x * x in square 5
02:28:25 <lambdabot>   25
02:28:33 <JoshTriplett> > let square :: Int -> Int ; square x = x * x in square 0.5
02:28:34 <docelic> Hey folks, is there a thing like Pl/haskell for postgres?
02:28:35 <lambdabot>       No instance for (Fractional Int)
02:28:35 <lambdabot>        arising from the literal `0.5' ...
02:28:53 <JoshTriplett> > let square :: Num a => a -> a ; square x = x * x in square 5
02:28:55 <lambdabot>   25
02:28:57 <JoshTriplett> > let square :: Num a => a -> a ; square x = x * x in square 0.5
02:28:59 <lambdabot>   0.25
02:29:04 <JoshTriplett> lepassive: ^
02:29:13 <lepassive> JoshTriplett, yes. It's understandable but not the second (there are 3 a's in the expression)
02:30:41 <JoshTriplett> lepassive: Unlike ->, => does not represent a function parameter.
02:30:54 <JoshTriplett> lepassive: It represents a constraint on the type of a parameter.
02:30:56 <vixey> lepassive:  the hypothesis  Num a,  is assumed without requiring some actual 'witness'
02:31:13 <JoshTriplett> lepassive: So, clearly you can't write square :: a -> a, because you can't square every type a.
02:31:28 <JoshTriplett> lepassive: You need to say "I can square any a which has a given property".
02:32:01 <JoshTriplett> lepassive: Such as "I can square any a which represents an instance of Num".
02:32:08 <lepassive> Uha, JoshTriplett like declaring the type of that parameter first, old c declares the type after naming the parameters
02:32:25 <lepassive> JoshTriplett, vixey I fully got it Thanks alot :)
02:32:47 <int-e> lepassive: C is odd ;)
02:33:13 <JoshTriplett> lepassive: Actually, you shouldn't think of "Num a" as defining the type of a.  Think of it as declaring a variable "a" which represents a type.
02:33:13 <cizra> int-e: Haskell ain't completely even either.
02:33:45 <lepassive> Well now it works perfect for me :)
02:35:12 <JoshTriplett> @type \min max val -> if min <= val && val <= max then Just val else Nothing
02:35:13 <lambdabot> forall a. (Ord a) => a -> a -> a -> Maybe a
02:35:16 <JoshTriplett> @pl \min max val -> if min <= val && val <= max then Just val else Nothing
02:35:17 <lambdabot> flip flip Nothing . (flip .) . flip flip Just . (liftM2 if' .) . (. flip (<=)) . ap . ((&&) .) . (<=)
02:35:20 <lepassive> One more question, this expression, upperCase (x:xs) = toUpper x : upperCase xs  does the last xs mean xs without the current x ?
02:35:30 <adrian_> @src sort
02:35:30 <lambdabot> sort = sortBy compare
02:35:32 <vixey> yes
02:35:32 <JoshTriplett> lepassive: Yes.
02:35:37 <RayNbow> > even haskell
02:35:37 <adrian_> @src sortBy
02:35:38 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
02:35:38 <lambdabot>   True
02:36:02 <vixey> > let   upperCase (x:xs) = toUpper x : upperCase (x:xs)   in    upperCase "foo"
02:36:03 <lambdabot>   "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
02:36:04 <RayNbow> > odd c
02:36:05 <lambdabot>   True
02:36:10 <vixey> > let   upperCase (x:xs) = toUpper x : upperCase xs   in    upperCase "foo"
02:36:11 <lambdabot>   "FOO* Exception: /tmp/1912530142763238562:71:38-80: Non-exhaustive patterns...
02:36:17 <int-e> > c
02:36:19 <lambdabot>   c
02:36:25 <RayNbow> :t c
02:36:27 <lambdabot> Expr
02:36:28 <vixey> > even d
02:36:30 <lambdabot>   False
02:36:39 <int-e> > c `mod` 2
02:36:41 <lambdabot>   c `mod` 2
02:36:43 <int-e> > c `mod` 2 == 0
02:36:44 <vixey> @src even
02:36:44 <lambdabot> even n = n `rem` 2 == 0
02:36:45 <lambdabot>   False
02:36:46 <JoshTriplett> lepassive: "To uppercase a string consisting of a first character x followed by the remaining characters xs (plural x), toUpper the x and upperCase the xs"
02:36:46 <int-e> ah.
02:36:50 <vixey> > c `rem` 2
02:36:51 <lambdabot>   c `rem` 2
02:36:54 <vixey> > c `rem` 2 == 0
02:36:55 <lambdabot>   False
02:37:03 <int-e> that Eq instance is naughty :)
02:37:05 <JoshTriplett> > print c
02:37:07 <lambdabot>   * Exception: "<IO ()>"
02:37:21 <int-e> > odd b && odd c && odd (b+c)
02:37:23 <lambdabot>   True
02:37:26 <RayNbow> > fromIntegral 0 :: Expr
02:37:27 <lambdabot>   0
02:37:35 <lepassive> JoshTriplett, uha then it doesn't mean x belongs to xs
02:37:44 <JoshTriplett> lepassive: Correct.
02:37:53 <lepassive> it's x followed by more xs now it' clear
02:37:57 <JoshTriplett> lepassive: : means "prepend element to front of list".
02:38:07 <wjt> luqui: planet haskell doesn't provide links back to your blog posts; perhaps the attribute in « <guid isPermaLink="false">http://lukepalmer.wordpress.com/?p=663</guid> » (for instance) is at fault?
02:38:08 <JoshTriplett> > 'a' : "bcd"
02:38:10 <lambdabot>   "abcd"
02:38:17 <JoshTriplett> > 1 : [2, 3, 4]
02:38:19 <lambdabot>   [1,2,3,4]
02:38:34 <JoshTriplett> lepassive: An operation normally called "cons".
02:39:04 <lepassive> I've tried to look up cons / cdr meaning  (full name) didn't have any luck
02:39:13 <luqui> wjt, ack.  thanks, I'll look into it
02:39:19 <lepassive> Real Haskell book sounds too complicated to start with
02:39:22 <vixey> lepassive, Contents of Decrement Register
02:39:41 <vixey> lepassive, and CAR for Contents of Accumulator Register
02:39:51 <RayNbow> ah int-e, http://int-e.home.tlink.de/haskell/LinRec.hs <-- I was recently thinking about doing something with linear recurrences in Haskell... but it seems you already did that :p
02:39:52 <JoshTriplett> lepassive: cons means "construct"
02:39:53 <wjt> luqui: great, thanks.  it's very frustrating to see interesting first paragraphs in my feed reader and try to click through to read more and not be able to :)
02:39:56 <lepassive> vixey, now I wish i've never asked
02:40:28 <Raevel> lepassive: the names come from the ole days of lisp
02:40:38 <JoshTriplett> lepassive: And yeah, car and cdr come from the original IBM computer that ran the first implementation of lisp.
02:40:57 <luqui> wjt, I would prefer it just RSS'ed the fulltext. wordpress seems opposed to that, despite my coercions...
02:41:01 <JoshTriplett> lepassive: Funny how people call lisp a "high-level language". :)
02:41:07 <int-e> RayNbow: heh. how did you find that? I thought I had hid it well ;)
02:41:10 <lepassive> Raevel, JoshTriplett It's my first time functionl programming
02:41:20 <adrian_> @src insertBy
02:41:20 <lambdabot> insertBy _   x [] = [x]
02:41:20 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
02:41:20 <lambdabot>                                  GT -> y : insertBy cmp x ys'
02:41:20 <lambdabot>                                  _  -> x : ys
02:41:22 <RayNbow> int-e: fear Google :p
02:41:28 <wjt> luqui: doh
02:41:47 <lepassive> I code alot of python, and decided to pick up haskell from GVR's post
02:41:56 <maltem> lepassive: there are plenty of FP tutorials out there that are more introductory than RWH
02:41:58 <JoshTriplett> lepassive: Ah.
02:42:02 <RayNbow> int-e: I just happened to stumble upon http://www.mail-archive.com/haskell-cafe@haskell.org/msg20882.html
02:42:14 <Raevel> i read, uhm
02:42:22 <vixey> JoshTriplett: Yeah Lisp goes from below sea level right up up past Rigel 4
02:42:32 <int-e> RayNbow: ah. thanks, I had forgotten about this mail
02:42:32 <Raevel> this one: http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089/ref=pd_bbs_sr_4?ie=UTF8&s=books&qid=1230547338&sr=8-4
02:42:38 <JoshTriplett> maltem: Heh, I read that as "Reader-Writer-Haskell monad". :)
02:42:42 <wjt> luqui: keep on reactin' :)
02:42:55 <JoshTriplett> maltem: Which seems disturbingly close to the real meaning. :)
02:42:56 <luqui> wjt, damn.   all the settings seem fine.  as a slave to wordpress.com, I can't really hack on it to fix it.
02:43:05 <lepassive> maltem, Yes I found plenty in the wiki I'm trying to go along with
02:43:20 <maltem> JoshTriplett: wow
02:43:22 <wjt> luqui: doh :(
02:43:26 <lepassive> question q=just q ?
02:43:36 <lepassive> why to use just not q directly ?
02:43:56 <b_jonas> Control.OldException is the renamed compatibility library from what was called Control.Exception
02:44:11 <maltem> lepassive: context?
02:44:14 <blackdog> @seen seafood
02:44:14 <lambdabot> I saw seafood leaving #ghc and #haskell 1h 28m 15s ago, and .
02:44:20 <cizra> Hey, folks, I've got a problem with Cabal. I can do cabal install LambdaHack and it works, but I can't do runhaskell Setup.hs configure -f curses, because it says deps are missing: binary >=0.4, hscurses >=1.3. I'm absolutely certain they're installed via cabal install, though.
02:44:22 <b_jonas> in a package what's the right way to use it in a way that it works both in new ghc and the old one?
02:44:28 <lepassive> getString :: JValue -> Maybe String
02:44:28 <lepassive> getString (JString s) = Just s
02:44:49 <JoshTriplett> lepassive: Maybe represents a type which can either have Just value or Nothing.
02:44:59 <JoshTriplett> lepassive: In Python terms, Maybe represents a type which could have None in it.
02:45:08 <schme> g'day
02:45:25 <Raevel> Maybe is awesome
02:45:53 <JoshTriplett> > let divide _ 0 = Nothing ; divide x y = x `div` y in divide 6 2
02:45:55 <lambdabot>       No instance for (Integral (Maybe a))
02:45:55 <lambdabot>        arising from a use of `divi...
02:45:55 <Raevel> null pointers are terrible
02:46:04 <JoshTriplett> > let divide _ 0 = Nothing ; divide x y = Just (x `div` y) in divide 6 2
02:46:06 <lambdabot>   Just 3
02:46:11 <JoshTriplett> > let divide _ 0 = Nothing ; divide x y = Just (x `div` y) in divide 6 0
02:46:12 <lepassive> JoshTriplett, maybe means nullable, just mean just a, Nothing mean none ?
02:46:12 <lambdabot>   Nothing
02:46:26 <JoshTriplett> lepassive: Exactly.
02:46:29 <lepassive> okay why not just say getString (JString s) = s
02:46:36 <JoshTriplett> lepassive: Because getString might fail.
02:46:47 <Raevel> lepassive: JValues aren't all strings
02:47:05 <maltem> lepassive: s is a String, but Just s :: Maybe String
02:47:08 <JoshTriplett> Does lambdabot allow the definition of types?
02:47:21 <quicksilver> no.
02:47:33 <maltem> lepassive: the Just is just a way of saying "this is not Nothing, but contains a value, namely the argument to Just"
02:47:53 <lepassive> sorry bear with me, getString (JString s) = s getString is a function takes in s a JString so return it
02:48:09 <maltem> lepassive: it does not return a string, look at the type
02:48:09 <JoshTriplett> lepassive: getString (JString s) will always return Just s.
02:48:23 <JoshTriplett> lepassive: But getString (JSomethingElse foo) can't return a string.
02:48:27 <maltem> lepassive: it returns a Maybe String, rather
02:48:29 <JoshTriplett> lepassive: So it needs to return Nothing.
02:48:47 <cizra> lepassive: It's useful in pattern matching. Let me paste you a recent code chunk of mine:
02:48:50 <cizra> lepassive:   let number = case (lookup buddy lst) of
02:48:53 <cizra>                 Just linenr  -> linenr
02:48:55 <cizra>                 Nothing            -> 0
02:49:18 <RayNbow> int-e: do you plan on uploading your LinRec module to hackage?
02:49:23 <JoshTriplett> cizra: Also writable concisely as maybe 0 id $ lookup buddy lst :)
02:49:24 <cizra> lepassive: (lookup returns Int a => Maybe a)
02:49:46 <lepassive> now it's obvious
02:49:47 <luqui> cizra, Int a => Maybe a ?? what means this?
02:49:48 <cizra> JoshTriplett: "id"?
02:50:01 <JoshTriplett> cizra: id x = x
02:50:03 <cizra> luqui: Um, that was my weak attempt at ad-hoc typing
02:50:12 <cizra> JoshTriplett: What's the point of it?
02:50:15 <lepassive> sorry guys i've asked *many* questions, but they really sounded not clear
02:50:23 <JoshTriplett> @type maybe
02:50:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:50:39 <maltem> cizra: Just linenr -> id linenr
02:50:40 <cizra> JoshTriplett: Oh, it wants a function there. Hmm.
02:50:41 <JoshTriplett> cizra: maybe takes a constant to use if you have Nothing and a function to use if you have Just.
02:50:48 <adrian> Where do the libraries lie on OS X?
02:50:57 <vixey> cizra, you can say 'list' instead of lst it's not scheme :p
02:50:59 <JoshTriplett> adrian: Everywhere.  They lie all the time. :)
02:51:06 <Raevel> :-(
02:51:10 <Raevel> adrian: which libraries?
02:51:21 <adrian> Data.List for example
02:51:26 <cizra> vixey: Won't conflict with something outta standard libs?
02:51:30 <vixey> adrian, import Data.List
02:51:30 * luqui keeps filling in words making it sound like you guys are unsure.  "maybe [it] takes a constant to use if you have ..."
02:51:30 <maltem> vixey: that's why we always write the clear 'xs' :)
02:51:39 <vixey> cizra, even if it did, would that matter?
02:51:40 <adrian> I want to have a look at the source
02:51:47 <Raevel> here's mine
02:51:50 <JoshTriplett> luqui: Heh.
02:51:51 <quicksilver> adrian: the source doesn't come with GHC
02:51:53 <cizra> Hey, folks, I've got a problem with Cabal. I can do cabal install LambdaHack and it works, but I can't do runhaskell Setup.hs configure -f curses, because it says deps are missing: binary >=0.4, hscurses >=1.3. I'm absolutely certain they're installed via cabal install, though.
02:51:54 <quicksilver> adrian: it's on the web though
02:51:55 <vixey> cizra, you bind a new variable list here and don't use any library version called 'list'
02:51:57 <Raevel>  /opt/local/var/macports/software/ghc/6.10.1_8+darwin_9_i386/opt/local/lib/ghc-6.10.1/base-3.0.3.0/Data/List.hi
02:51:57 <adrian> ok
02:52:00 <adrian> thanks
02:52:03 <JoshTriplett> I often find myself wanting the function flip maybe id.
02:52:06 <quicksilver> adrian: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
02:52:16 <vixey> :t flip maybe id
02:52:17 <lambdabot> forall a. a -> Maybe a -> a
02:52:23 <luqui> JoshTriplett, fromMyabe?
02:52:26 <JoshTriplett> vixey: "use this default".
02:52:28 <vixey> :t fromMaybe
02:52:29 <lambdabot> forall a. a -> Maybe a -> a
02:52:34 <JoshTriplett> vixey: Oh, it exists!
02:52:34 <maltem> cizra: try --user
02:52:36 <JoshTriplett> vixey: Nice.
02:52:44 <adrian> I swear that source code link wasn't there when I looked
02:52:47 <vixey> I'd not call it fromMaybe though
02:53:00 <Raevel> vixey: hmm why not?
02:53:04 <vixey> I think I woudl call it default
02:53:06 <int-e> RayNbow: I had no such plans so far. I guess I could do it though.
02:53:06 <JoshTriplett> vixey: No.  I'd call it "defaultingTo".
02:53:09 <JoshTriplett> vixey: Or yeah.
02:53:15 <JoshTriplett> vixey: Something with default in it.
02:53:30 <luqui> fromMaybeWithDefault
02:53:33 <JoshTriplett> vixey: someMaybeValue `default` foo
02:53:34 <cizra> maltem: works!
02:53:44 <Raevel> luqui: obj-c!? :-)
02:53:44 <JoshTriplett> Er, not quite. :)
02:53:50 <JoshTriplett> Hmmm.
02:54:00 <JoshTriplett> vixey: I guess the flipped function proves useful too.
02:54:02 <luqui> JoshTriplett, unfortunately the arguments are in the wrong order for currying convenience
02:54:08 <JoshTriplett> luqui: Yeah.
02:54:19 <JoshTriplett> luqui: Well, it depends on what you want to curry.
02:54:24 <lepassive>   NOTE Saying that the type of fst is (a, b) → a does not necessarily
02:54:24 <lepassive> mean that it simply gives back the first element; it only means that it
02:54:24 <lepassive> gives back something with the same type as the first element.
02:54:24 <lepassive>  ??
02:54:28 <quicksilver> turkey, mostly, at this time of year.
02:54:40 <lepassive> sorry
02:54:42 <JoshTriplett> luqui: I *have* often needed to make the function "Maybe a -> a" given a default, so the argument order seems handy.
02:54:44 <Gracenotes> @unpl (0:) . scanl (+) 1
02:54:44 <lambdabot> (\ d -> 0 : (scanl (+) 1 d))
02:54:46 <luqui> JoshTriplett, I cannot think of any reason I would want the a -> a version...
02:54:55 <Raevel> lepassive: you could defined fst (a, b) = a+1
02:55:01 <JoshTriplett> luqui: Operator syntax.
02:55:10 <Raevel> lepassive: it wouldn't make sense for the implementation of fst because, but it is *possible*
02:55:18 <luqui> JoshTriplett, I mean in terms of currying.
02:55:19 <JoshTriplett> luqui: expression (returning a maybe value) `default` foo
02:55:23 <JoshTriplett> luqui: Oh, sure.
02:55:25 <Raevel> oh i can't even type today
02:55:29 <lepassive> Raevel, mean like overriding the default implementation ?
02:55:29 <maltem> Raevel: well strictly you could not :)
02:55:39 <vixey> JoshTRiplett, ok but why not  foo `default` (returning a maybe value)
02:55:52 <JoshTriplett> vixey: English fail. :)
02:56:05 <JoshTriplett> vixey: foo `asDefaultFor` (returning a maybe value)
02:56:07 <vixey> JoshTriplett, remember this is haskell
02:56:20 <JoshTriplett> vixey: Oh, I'd forgotten.  Thanks for the reminder. ;)
02:56:25 <Raevel> lepassive: the point is that (a, b) -> a is just a type signature, the function will return a value of type a, but you can't tell what the actual value will be without looking at the implementation
02:56:27 <vixey> JoshTriplett, no seriously
02:56:51 <vixey> JoshTriplett, naturally grammar changes look at some chains of point free expressions  f . g . h  and read them aloud
02:57:06 <Raevel> lepassive: but in a lot of cases you can just look at the type signature and figure it out anyway, using a little common sense
02:57:15 <lepassive> Raevel, ahaaa It means like return an a but not that a always
02:57:21 <maltem> lepassive: the point of that comment is to convey that given two values of type a, these values may be different, even though they have the same type
02:57:21 <maltem> lepassive: rather obvious actually, given what a type is
02:57:58 <JoshTriplett> lepassive: It means the function takes a pair of values of two different types, and returns a value of the first type.
02:58:23 <JoshTriplett> lepassive: For example...
02:58:29 <JoshTriplett> @t fst
02:58:30 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:58:34 <JoshTriplett> @type fst
02:58:35 <lambdabot> forall a b. (a, b) -> a
02:58:45 <JoshTriplett> > fst (5, 10)
02:58:47 <lambdabot>   5
02:59:03 <JoshTriplett> @type \(x, y) -> 2*x
02:59:05 <lambdabot> forall t t1. (Num t1) => (t1, t) -> t1
02:59:13 <JoshTriplett> Sigh, thank you haskell.
02:59:27 <lepassive> sorr what is @type ? I yet know :t and :type
02:59:31 <lepassive> sorry*
02:59:37 <JoshTriplett> lepassive: Just syntax for the bot in the channel.
02:59:47 <Gracenotes> @type (*2) . fst
02:59:49 <lambdabot> forall a b. (Num a) => (a, b) -> a
02:59:50 <JoshTriplett> lepassive: Means the same as ghci's :type
03:00:16 <JoshTriplett> Gracenotes: Yeah, that too.  But I realized that you can't really define any other useful functions without making a more specific. :)
03:00:23 <luqui> @thx
03:00:23 <lambdabot> you are welcome
03:00:32 <lepassive> crystal :)
03:00:53 <Gracenotes> JoshTriplett: a surprising number of things can be written without lambdas
03:01:04 <JoshTriplett> Gracenotes: Oh, I know.  I like to write pointless code whenever I can. :)
03:01:17 <JoshTriplett> Gracenotes: I just felt the pointful version would make a better example.
03:01:21 <luqui> JoshTriplett, really?  because you *always* can
03:01:26 <Gracenotes> oh, I see
03:01:41 <JoshTriplett> luqui: Sigh.  s/can/reasonably can/, then. :)
03:01:47 <lepassive> I'm graceful to python's functional stuff It cleared alot for me
03:01:51 <vixey> luqui, this is why we need FPH or whatever it's called
03:01:52 <Gracenotes> although... pointless can be unnecessarily abstruse at times.
03:01:57 <JoshTriplett> luqui: Leave it to a channel of Haskell programmers to demand precision in English. :)
03:02:08 <vixey> luqui, so we can rewrite all the ST using code pointfree :p
03:02:33 <luqui> JoshTriplett, there is a culture of people who believes you always can write reasonable pointfree code, given the right combinators
03:02:36 <Gracenotes> JoshTriplett: anyway, sorry for bugging. (eep)
03:02:45 <JoshTriplett> Gracenotes: No problem. :)
03:02:57 <JoshTriplett> luqui: I agree with that, assuming that you want to take the time to write the right combinators. :)
03:03:19 <luqui> I haven't yet found the right (reasonable) combinators that can handle the quadratic formula
03:03:31 <luqui> so I don't yet subscribe to this doctrine
03:03:54 <luqui> but many times it can be very pretty :-)
03:04:02 * vixey more worried about terms that cannot type when written point free
03:04:08 <JoshTriplett> luqui: You clearly need a "quadratic" combinator. :)
03:04:13 <luqui> vixey, you mean with rank n types?
03:04:21 <luqui> I put in the word reasonable for a reason
03:04:21 <vixey> yes
03:04:28 <luqui> as one would hope
03:04:40 <JoshTriplett> luqui: So yeah, the real problem comes in because you can't necessarily write all your combinators in point-free style.
03:04:57 <JoshTriplett> luqui: At the lowest level, good luck writing "id" in a point-free way without having id already available. :)
03:05:13 <luqui> JoshTriplett, you can, but theybecome less reasonable.  all you need are <*>, const, and fix
03:05:26 <luqui> > (<*>) const const 42
03:05:27 <lambdabot>   42
03:05:29 <JoshTriplett> @type <*>
03:05:30 <lambdabot> parse error on input `<*>'
03:05:34 <luqui> > fmap fix return 42
03:05:35 <lambdabot>   42
03:05:36 <JoshTriplett> @type (<*>)
03:05:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:05:48 <luqui> JoshTriplett, particularly I meant the (->) instance
03:05:49 <vixey> id x = x -- pseudo-pointfree
03:06:01 <JoshTriplett> Oh, <*> == &&& . \x -> (x,x) ?
03:06:04 <luqui> (it is the S combinator)
03:06:26 <JoshTriplett> Er, something like that.
03:06:35 <JoshTriplett> Looks a lot like the arrow machinery.
03:06:46 <JoshTriplett> @type (&&&)
03:06:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:06:53 <vixey> it's Applicative not ARrow
03:06:55 <luqui> JoshTriplett, eh.   s x y z = x z (y z)
03:07:00 <luqui> that's what <*> is on (r ->)
03:07:22 <lepassive> I've to go, Thanks alot for the help guys
03:08:11 <luqui> > pure <*> pure $ 42
03:08:12 <lambdabot>       Ambiguous occurrence `pure'
03:08:12 <lambdabot>      It could refer to either `Control.Appl...
03:08:15 <luqui> aww
03:08:32 <luqui> > const <*> const $ 42
03:08:33 <lambdabot>   42
03:08:54 <adrian> when I run a program with runhaskell, the library functions I call (e.g. Data.List.sort) use compiled code, right?
03:09:01 <JoshTriplett> @type const <*> const
03:09:02 <lambdabot> forall a. a -> a
03:09:13 <JoshTriplett> @type (<*>)
03:09:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:09:22 <luqui> :t const (<*>) <*> const  -- composition :-)
03:09:23 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
03:09:26 <JoshTriplett> @type (const <*>)
03:09:28 <lambdabot> forall a b. (a -> b) -> a -> a
03:10:21 <JoshTriplett> OK, I have *no* clue how (const <*>) got that type signature from its initial type signature.
03:10:24 <JoshTriplett> @type const
03:10:25 <lambdabot> forall a b. a -> b -> a
03:10:36 <JoshTriplett> Ah.
03:10:44 <JoshTriplett> Curried.
03:11:29 <luqui> :t (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
03:11:30 <lambdabot> forall r a b. (r -> a -> b) -> (r -> a) -> r -> b
03:12:26 <vixey> @type flip (<*>) const
03:12:27 <lambdabot> forall b a b1. (a -> (b1 -> a) -> b) -> a -> b
03:12:27 <JoshTriplett> Clearly I need to read about Applicative.
03:12:34 <JoshTriplett> Before I can understand this machinery.
03:12:37 <JoshTriplett> @info Applicative
03:12:38 <lambdabot> Applicative
03:12:43 <JoshTriplett> Gee, thanks. :)
03:12:52 <JoshTriplett> @kind Applicative
03:12:54 <lambdabot> Class `Applicative' used as a type
03:13:22 <luqui> here's a good one.  this is "flip":
03:13:24 <luqui> :t (<*>) ((<*>) (const ((<*>) (const (<*>)) const)) (<*>)) (const const)
03:13:25 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
03:13:48 <JoshTriplett> luqui: Gee, thanks. :)
03:14:06 <JoshTriplett> luqui: I believe you've made your point about "reasonable" pointless code.
03:14:17 <JoshTriplett> luqui: I wouldn't argue to write "flip" pointlessly.
03:14:30 <luqui> =P
03:14:39 <JoshTriplett> luqui: And in general I draw the "reasonable" line somewhere around "if I need flip to write it I shouldn't write it pointlessly".
03:14:40 <luqui> I'm not really making a point so much anymore :-)
03:15:00 <luqui> hmm, I wonder how good @pl is
03:15:04 <athos> merry christmas!
03:15:08 <JoshTriplett> luqui: In general I don't write pointless functions that require flip unless they just consist of "flip foo".
03:15:39 <luqui> @pl let s x y z = x z (y z); k x y = x in s (s (k (s (k s) k)) s) (k k)
03:15:39 <lambdabot> liftM2 (.) ap (const const)
03:15:48 <luqui> :t liftM2 (.) ap (const const)
03:15:50 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
03:15:54 <luqui> cool, another way to write flip :-)
03:16:04 <vixey> flip f y x = f x y
03:16:05 <schme> flip flop
03:16:06 <JoshTriplett> luqui: Yes, I know about SKI combinators. :)
03:16:06 <luqui> @pl-resume
03:16:06 <lambdabot> pointless: sorry, nothing to resume.
03:16:20 <luqui> no, I mean the liftM2 one
03:16:37 <luqui> the SK combinators is what I've been doing with <*> and const
03:16:39 <JoshTriplett> luqui: I meant in response to your earlier "all you need".
03:16:46 <JoshTriplett> luqui: Yeah.
03:16:47 <luqui> ah
03:17:08 <vixey> s and k are a basis for simple typed lambda calculus but haskell is not simple
03:17:18 <luqui> vixey, add fix and you're good
03:17:23 <JoshTriplett> luqui: I also find it telling that one of the IOCCC winners one year just implemented an SKI combinator handler and then wrote some code in SKI. :)
03:17:30 <vixey> :t runST
03:17:32 <lambdabot> forall a. (forall s. ST s a) -> a
03:17:37 <JoshTriplett> luqui: You don't need much work to obfuscate it. :)
03:17:44 <vixey> I'm referring to this stuff ^
03:17:58 <luqui> vixey, oh.  keep it H98, dude :-)
03:18:26 <luqui> I guess polymorphic recursion could still nail you
03:18:53 <Gracenotes> @src liftIO
03:18:53 <lambdabot> Source not found. That's something I cannot allow to happen.
03:18:56 <Gracenotes> D:
03:19:15 <luqui> @src MonadIO
03:19:16 <lambdabot> Source not found.
03:19:35 <Gracenotes> instance MonadIO IO where
03:19:38 <Gracenotes>     liftIO = id
03:19:56 <JoshTriplett> @type unsafePerformST
03:19:58 <lambdabot> Not in scope: `unsafePerformST'
03:20:29 <vixey> :t unsafeSTtoIO
03:20:30 <lambdabot> Not in scope: `unsafeSTtoIO'
03:20:31 <vixey> :t unsafeSTHoIO
03:20:32 <lambdabot> Not in scope: `unsafeSTHoIO'
03:20:36 <vixey> :t unsafeSTToIO
03:20:37 <lambdabot> Not in scope: `unsafeSTToIO'
03:20:41 <vixey> :t unsafeIOToST
03:20:42 <lambdabot> Not in scope: `unsafeIOToST'
03:20:47 <vixey> :t unsafeIOtoST
03:20:48 <lambdabot> Not in scope: `unsafeIOtoST'
03:21:12 <JoshTriplett> @type cast
03:21:14 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
03:21:15 <athos> @index unsafe
03:21:16 <lambdabot> Language.Haskell.TH.Lib, Language.Haskell.TH
03:21:23 <RayNbow> @hoogle safePerformIO
03:21:23 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:21:23 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:21:34 <RayNbow> what? no safe IO? :p
03:22:27 <RayNbow> preflex: int-e++
03:22:31 <RayNbow> preflex: @karma int-e
03:22:31 <preflex>  karma for int-e: 7
03:22:40 <RayNbow> for your awesome LinRec module :)
03:28:13 <JoshTriplett> Huh.
03:28:18 <JoshTriplett> @instances Typeable
03:28:18 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
03:28:24 <JoshTriplett> @instances-importing
03:28:24 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
03:28:32 <JoshTriplett> @instances-importing Typeable
03:28:33 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
03:32:13 <Baughn> How's the move-ghc-to-git thing going? I only ask because, well, last time I tried to check it out darcs ran out of memory..
03:33:30 <bao> why not move your code to C too then?
03:33:43 <Baughn> ..huh?
03:33:51 <vixey> because git is the C of RVCS
03:34:51 <Baughn> ..I don't see the resemblance
03:35:14 <Baughn> At any rate, I do rememeber the ghc maintainers were planning to switch from darcs to git, so..
03:35:34 <thoughtpolice> you should probably bug JaffaCake or Igloo or something when they're around
03:35:50 <bao> u mean 'or someone'
03:35:57 <thoughtpolice> the switch was going to happen after the GHC 6.10 branch forked, so it's probably somewhat close upon us by now
03:36:25 <olsner> "the switch" = darcs->git?
03:36:31 <thoughtpolice> yes
03:50:23 <cizra> After some practise, Haskell code seems almost readable, if it doesn't contain the perlisms…
03:50:40 <pumpkinator> which perlisms?
03:51:18 <olsner> cizra: perlisms make code unreadable in any language :P
03:51:30 <maltem> Baughn: If you're ony checking out, not sending patches, the the github mirror is very useful
03:53:11 <cizra> olsner: Well, yes, but it's a language design to have huge piles of unreadable operators
03:53:16 <cizra> pumpkinator: weird operators
03:53:27 <pumpkinator> weird operators are the best!
03:53:37 <pumpkinator> which operators do you consider weird?
03:53:50 <cizra> >>=
03:53:53 <pumpkinator> lol
03:54:16 <pumpkinator> if that's weird, so is + and *
03:54:17 <vixey> cizra, you can use do notation instead
03:54:35 <cizra> Well, it's nice to have shorthand notations
03:54:39 <cizra> … but it's not nice to learn them all.
03:54:41 <RayNbow> >>= is the reprogrammable semicolon :p
03:54:55 <pumpkinator> can semicolon be defined as an operator btw?
03:55:03 <int-e> pumpkinator: no
03:55:08 <pumpkinator> > let (;) = (+) in 5 ; 4
03:55:09 <lambdabot>   <no location info>: parse error on input `;'
03:55:10 <pumpkinator> boo
03:55:11 <pumpkinator> :P
03:55:16 <int-e> pumpkinator: it's part of the explicit layout ( { ; } )
03:55:22 <pumpkinator> ah, yeah
03:55:46 <int-e> > let (?) = \_ _ -> "what" in () ? ()
03:55:48 <lambdabot>   "what"
03:56:10 <pumpkinator> I like using varying numbers of question marks as operators myself
03:56:17 <pumpkinator> it adds a certain amount of mystery to my code
03:56:22 <Peaker> @pl (?) = \_ _ -> "what"
03:56:22 <lambdabot> (line 1, column 5):
03:56:22 <lambdabot> unexpected "="
03:56:22 <lambdabot> expecting variable, "(", operator or end of input
03:56:26 <int-e> cizra: a rich supply of infix operators is really a blessing imho - although it takes a while to get used to.
03:56:29 <Peaker> @pl f = \_ _ -> "what"
03:56:29 <lambdabot> f = const (const "what")
03:56:30 <vixey> @let (?) = cast
03:56:31 <lambdabot>  Defined.
03:56:49 <olsner> @ty cast
03:56:51 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
03:57:03 <cizra> int-e: Why is Perl ugly?
03:57:27 <pumpkinator> the my word
03:57:32 <pumpkinator> and postfix conditionals
03:57:33 <int-e> > let foldr (?) a [] = a; foldr (?) a (x:xs) = x ? foldr (?) a xs in foldr (+) 0 [1..100]
03:57:35 <lambdabot>   5050
03:58:17 <quicksilver> perl has a rather small collection of operators I think.
03:58:33 <cizra> quicksilver: Dunno, perhaps. Still it looks like someone's cursing.
03:58:44 <quicksilver> that's the sigils, probably.
03:58:48 <int-e> cizra: That's not a fair question. It depends on how well you know Perl. For me, Perl tends to become unreadable pretty quickly.
03:58:50 <quicksilver> $foo, @bar
03:58:52 <vixey> perls got a lot of predefined variables though
03:58:58 <vixey> $1 $_ etc
03:59:00 <cizra> int-e: I don't know a word of Perl.
03:59:05 <cizra> int-e: It just looks ugly to me.
03:59:15 <cizra> O, yes. Those magic variables.
03:59:18 * cizra groans
03:59:22 <int-e> cizra: And yes, that argument works against Haskell as well, if you want it to.
03:59:30 <int-e> :-P
03:59:33 <schme> Imagine a haskeller saying perl is ugly.
03:59:37 <quicksilver> http://99-bottles-of-beer.net/language-perl-737.html
03:59:41 <quicksilver> beauty incarnate.
04:00:04 <int-e> schme: worse, imagine a haskeller saying perl is beautiful and the end and all of programming languages.
04:00:04 <schme> Is not haskell often called the perl of fp ?
04:00:15 <cizra> quicksilver: FUCK
04:00:20 <quicksilver> alphabetical symbols like 'length'  have some natural meaning because of english.
04:00:24 <cizra> quicksilver: Things like that should be illegal
04:00:31 <cizra> quicksilver: You ruined my eyes.
04:00:47 <quicksilver> symbols like >>= and [] and ++ have no intrinsic meaning.
04:00:50 <quicksilver> you just have to learn them.
04:01:12 <quicksilver> it's a trade-off between conciseness of express and intuition.
04:01:20 <quicksilver> s/express/expression/
04:01:32 <cizra> Yes.. On the opposite, and IMHO worse side is Java and friends
04:02:06 <Baughn> Great.. my usb debugging attempts exhibit the quantum zeno effect
04:02:08 <idnar> eh, perl has quite a wahck of operators
04:02:14 <idnar> what with all the quoting operators and so on
04:02:19 <olsner> wow, awesome bug! (the module name thing)
04:02:37 <Peaker> Haskell doesn't have that many operators though
04:02:53 <Peaker> Well, sure there are a bazillion buried in libraries, but the stdlib has a sane amount
04:02:53 <idnar> possibly not as many as Haskell, though
04:03:02 <idnar> but Haskell's operators are a bit more uniform
04:03:27 <idnar> for example, they're all binary
04:03:32 <int-e> Apropos perl ... http://www.spoj.pl/problems/SIZECON/ is puzzling.
04:03:50 <quicksilver> haskell's operators are only all binary because that's how we define the word 'operator' :P
04:04:03 <quicksilver> which is fine, within the language, but a bit unfair in comparisons.
04:04:35 <quicksilver> is "if/then/else" not a trinary operator, and "case/of/->/->/->/->" an n-ary one?
04:05:02 <cizra> int-e: sum . (filter (> 0)) $ list ought to do this?
04:05:04 <int-e> (I have no idea how some people got away with only 6 non-"whitespace" characters there. I was happy to get down to 12.)
04:05:04 <vixey> if b then/else :: a -> a -> a -> a -> a
04:05:28 <idnar> quicksilver: I don't think the comparison is too unfair
04:05:40 <idnar> but really, the "problem" in Perl isn't the number of operators
04:05:43 <pumpkinator> vixey: what's the 4th?
04:05:44 <int-e> The rules for that problem are just flawed.
04:06:07 <idnar> the quoting operators in Perl make life a bit crazy, though
04:06:23 <idnar> because you get to use arbitrary characters as delimiters
04:06:33 <vixey> idnar, heh at least it's not  \\/(?s\\/\ed)\/\/
04:06:39 <quicksilver> I can't think perl's quoting operators would ever make my top10 list of problems.
04:06:52 <idnar> quicksilver: they're one of the factors that contributes towards "character density"
04:06:55 <quicksilver> The main problem with perl is endemic use of global scope + side effects.
04:06:57 <idnar> that and the sigils, I guess
04:07:04 <maltem> What's "scaring" about Haskell operators is that people tend to make up operator symbols of quite long a length, thus harder to memorize. >>= is quite long already
04:07:07 <idnar> granted, these are all quite superficial
04:07:15 <idnar> but it does make it rather unpleasant to eyeball Perl code
04:07:17 <quicksilver> idnar: which only matters if character density is seen as being a problem.
04:07:21 <quicksilver> I don't consider it so.
04:07:28 <idnar> I find it very unpleasant, visually
04:07:39 <Peaker> maltem: that operator is shift-right-assign in C and others :-)
04:08:15 <maltem> Peaker: oh right :) but there it is composed, actually, out of >> and =, while Haskell >>= is a single symbol, conceptually
04:08:20 <idnar> I guess maybe J users wouldn't mind ;P
04:08:46 <pumpkinator> > let (???????????????????) = ((succ . ) . (^)) in 5 ??????????????????? 7
04:08:46 <lambdabot>   78126
04:08:46 <pumpkinator> nothing wrong with that
04:08:47 <idnar> pumpkinator: ha ha
04:08:56 <maltem> Peaker: which means that it's possible to mix up, say, >>=, =>>, <<=, or whatever you want to come up with
04:09:16 <maltem> (hm does =>> exist?)
04:09:23 <int-e> @index (=>>)
04:09:24 <lambdabot> bzzt
04:09:29 <int-e> @hoogle (=>>)
04:09:30 <lambdabot> No results found
04:09:30 <Heffalump> I think the == is always on the side of the point of the >
04:09:40 <int-e> @hoogle (>=>)
04:09:41 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:09:59 <maltem> hah that one!
04:10:22 <maltem> well the = *is* on the side of the point of the > even there
04:10:26 <idnar> @type fmap (.)
04:10:28 <lambdabot> forall b c a (f :: * -> *). (Functor f) => f (b -> c) -> f ((a -> b) -> a -> c)
04:10:35 <idnar> oh, not really
04:10:35 <vixey> @type liftM2 (.)
04:10:36 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
04:10:42 <vixey> hm no
04:10:50 <Peaker> I think Perl's problems are: 1) No function arguments for minimal safety checking and introspection(!), 2) The scalar/reference/etc divisions is horrible/complicating (hash in hash? Make a reference, yikes!)  3) The types (actually tags) are too coarse (scalar instead of strings and ints? Yuck!)  4) The syntax has hundreds of operators you do have to remember, as well as too many built-in things and too many grammars to encode the same abstract syntax
04:10:55 <idnar> @src (>=>)
04:10:55 <lambdabot> Source not found. :(
04:11:24 <pumpkinator> @src (>->)
04:11:24 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:11:39 <vixey> f >=> g = (\x -> f x) >>= g ?
04:11:49 <vixey> :t (\x -> ?f x) >>= ?g
04:11:50 <lambdabot> forall a t b. (Monad ((->) t), ?g::a -> t -> b, ?f::t -> a) => t -> b
04:11:58 <vixey> no :/
04:12:00 <idnar> @type \f g -> (\x -> f x) >>= g
04:12:01 <lambdabot> forall t a b. (Monad ((->) t)) => (t -> a) -> (a -> t -> b) -> t -> b
04:12:01 <Peaker> where syntax built-ins are things like regexps
04:12:04 <idnar> but, no
04:12:14 <idnar> @type \f g x -> x >>= f >>= g
04:12:15 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> m a1) -> (a1 -> m b) -> m a -> m b
04:12:20 <idnar> hm, not quite
04:12:31 <idnar> @type \f g x -> (return x) >>= f >>= g
04:12:32 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> m a1) -> (a1 -> m b) -> a -> m b
04:12:36 <idnar> @pl \f g x -> (return x) >>= f >>= g
04:12:37 <lambdabot> flip . ((>>=) .)
04:13:03 <idnar> @pl \f g x -> (f x) >>= g
04:13:03 <lambdabot> flip . ((>>=) .)
04:13:27 <idnar> @type \f g x -> g =<< (f x)
04:13:29 <lambdabot> forall t a (m :: * -> *) b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
04:13:42 <idnar> er
04:13:44 <idnar> @pl \f g x -> g =<< (f x)
04:13:44 <lambdabot> flip ((.) . (=<<))
04:14:21 <idnar> @pl \x -> (f x) >>= g
04:14:22 <lambdabot> (g =<<) . f
04:14:34 <JoshTriplett> idnar: Aiming for something in particular?
04:14:50 <vixey> :t (>=>)
04:14:52 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:14:53 <vixey> :t (>>=)
04:14:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:15:12 <idnar> JoshTriplett: just thrashing about for something "cuter" than f >=> g = \x -> (f x) >>= g
04:15:44 <pumpkinator> if it helps, I thought it was pretty cute
04:15:50 <JoshTriplett> idnar: (f >=> g) x = (f x) >>= g
04:15:54 <JoshTriplett> idnar: Looks cuter.
04:15:54 <vixey> :t (flip (>>=) .) .)
04:15:55 <lambdabot> parse error on input `)'
04:15:59 <vixey> :t ((flip (>>=) .) .)
04:16:00 <lambdabot> forall (m :: * -> *) a b a1 a2. (Monad m) => (a2 -> a1 -> a -> m b) -> a2 -> a1 -> m a -> m b
04:16:14 <vixey> :t ((flip (>>=) ?g) . ?f)
04:16:15 <lambdabot> forall (m :: * -> *) a b a1. (?f::a1 -> m a, ?g::a -> m b, Monad m) => a1 -> m b
04:16:16 <idnar> JoshTriplett: oh, right
04:16:25 <vixey> @pl \f g -> ((flip (>>=) g) . f)
04:16:26 <idnar> that beats f >=> g = (g =<<) . f anyhow
04:16:26 <lambdabot> flip ((.) . (=<<))
04:16:38 <idnar> >=<=>=<=>=<=>=<
04:16:49 <vixey> flip (fmap fmap (=<<))
04:16:51 <vixey> :t flip (fmap fmap (=<<))
04:16:52 <lambdabot> forall (f :: * -> *) a (m :: * -> *) b. (Monad m, Functor f) => f (m a) -> (a -> m b) -> f (m b)
04:17:01 <idnar> looks like something from a nethack session
04:17:17 <idnar> :t flip (liftM liftM (=<<))
04:17:18 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) b. (Monad m1, Monad m) => m (m1 a) -> (a -> m1 b) -> m (m1 b)
04:17:25 <JoshTriplett> You open the tin.  It smells like curried function. :)
04:17:52 <vixey> :t flip (liftM fmap (=<<))
04:17:53 <lambdabot> forall (f :: * -> *) a (m :: * -> *) b. (Monad m, Functor f) => f (m a) -> (a -> m b) -> f (m b)
04:18:01 <idnar> JoshTriplett: haha
04:20:19 <JoshTriplett> :t const
04:20:20 <lambdabot> forall a b. a -> b -> a
04:20:20 <JoshTriplett> :t const.const
04:20:21 <lambdabot> forall b a b1. a -> b -> b1 -> a
04:21:02 <idnar> :t const const.const
04:21:03 <lambdabot> forall a b a1. a1 -> a -> b -> a
04:21:16 <cizra> Peaker: In short, fun. Well, the 4) applies equally well to Haskell, 'fraid.
04:21:28 <JoshTriplett> idnar: Yeah, put them together with or without . and you get the "pick" function. :)
04:22:01 <JoshTriplett> :t foldl
04:22:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:22:04 <vegai> haskell's syntax doesn't have many operators, though, cizra
04:22:19 <Peaker> cizra: Haskell does not have regexps in the syntax, or "the current global" (@_) or various other Perlisms, so its not quite as bad.  Also, @type (>=>)  will help if you forget an operator
04:22:33 <vixey> there is millions of them waiting to be defined
04:22:36 <cizra> vegai: OK, not many operators but still lots o' built-in things. At least in the standard libs.
04:22:40 <Peaker> cizra: and Haskell also does not have:  "unless" and "if" on either side, and various other silliness
04:22:56 <idnar> lots of built-in stuff is good; it means you don't have to define stuff yourself ;P
04:22:58 <JoshTriplett> Sadly, this doesn't work:
04:22:59 <JoshTriplett> :t \n -> foldl (.) id replicate n const
04:23:00 <lambdabot>     Couldn't match expected type `[a -> a]'
04:23:00 <lambdabot>            against inferred type `Int -> a1 -> [a1]'
04:23:00 <lambdabot>     In the third argument of `foldl', namely `replicate'
04:23:04 <cizra> idnar: Agreed!
04:23:07 <vegai> reservedop -> .. | : | :: | = | \ | | | <- | -> | @ | ~ | =>
04:23:09 <idnar> er, sorry
04:23:09 <vegai> :)
04:23:10 <JoshTriplett> :t \n -> foldl (.) id (replicate n const)
04:23:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
04:23:11 <lambdabot>     Probable cause: `const' is applied to too few arguments
04:23:11 <lambdabot>     In the second argument of `replicate', namely `const'
04:23:12 <idnar> lots of *standard* stuff is good
04:23:12 <Peaker> cizra: so Haskell's syntax is quite a bit smaller
04:23:17 <JoshTriplett> idnar: ^
04:23:22 <idnar> *built-in* stuff isn't so great, because it's special
04:23:28 <JoshTriplett> idnar: The constN function. :)
04:23:31 <Peaker> idnar: built-in _libraries_ are good, not lots of built-in syntax, especially syntax that is redundant to other syntax ("unless")
04:23:32 <idnar> JoshTriplett: haha
04:23:37 <JoshTriplett> idnar: Sadly untypeable.
04:23:46 <idnar> JoshTriplett: just write it as a type-level function :P
04:23:48 <JoshTriplett> idnar: Though easily writable in the untyped lambda calculus.
04:23:50 <cizra> Peaker: OK, understood
04:24:01 <idnar> Peaker: again, not *built-in*, just standard
04:24:24 <Peaker> cizra: indeed, Haskell's multitude of operators is a small problem, but :t in ghci or @type in lambdabot really makes it very bearable :)
04:24:27 <JoshTriplett> Peaker: You know that Haskell has an "unless" function, right? :)
04:24:28 <idnar> Peaker: there's a subtle difference; if you want to look at built-in code, you need to go poking around in compiler or interpreter innards
04:24:29 <JoshTriplett> @type when
04:24:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:24:31 <JoshTriplett> @type unless
04:24:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:24:38 <Peaker> JoshTriplett: its not syntax, though :-)
04:24:45 <JoshTriplett> Peaker: Yeah, fair enough.
04:24:48 <idnar> Peaker: as opposed to ordinary code that just happens to be shipped with the language implementation
04:24:54 <JoshTriplett> Actually, I find it a little surprising that Haskell has "if" syntax.
04:25:16 <vixey> yeah if sucks
04:25:19 <Peaker> JoshTriplett: yeah, it has this because people want keyword arguments for that common function.. I think someone ought to solve the keyword problem in Haskell
04:25:20 <idnar> I've yet to use an if expression in Haskell
04:25:30 <idnar> every time I considered doing it, I figured out a better way to do what I wanted, using pattern matching or whatever
04:25:37 <Peaker> JoshTriplett: its not even in the Prelude, btw
04:25:49 <JoshTriplett> idnar: case foo of True -> ... ; False -> ... :)
04:25:56 <idnar> JoshTriplett: well, not that :P
04:26:00 <vixey> it's very annoying not being able to call a variable 'type'
04:26:05 <Peaker> I wish Haskell didn't have open unqualified imports at all
04:26:30 <idnar> JoshTriplett: there's a meme of "if statement considered harmful" in some other languages, though, and it probably applies even more in Haskell where you have awesome pattern-matching and so on
04:26:36 <JoshTriplett> idnar: Agreed.
04:26:54 <Peaker> idnar: well, pattern matching on True/False deserves a special syntax? :-)
04:27:02 <Peaker> idnar: My answer is no, but its not that unreasonable
04:27:13 <idnar> Peaker: pattern matching on True/False is like an if statement, so it has the same "badness" :P
04:27:47 <idnar> the main idea behind that meme is that instead of translating some dispatch criterion into a boolean, and then dispatching on true/false, you should just dispatch on whatever you had to begin with
04:27:50 <JoshTriplett> idnar: Oooh.  case undefined of _ | condition -> foo ; | otherwise -> bar :)
04:27:58 <Peaker> idnar: what if I had a boolean to begin with?
04:28:16 <idnar> Peaker: then that's probably fine
04:28:27 <JoshTriplett> Peaker: Then you could use if' .
04:28:31 <JoshTriplett> @type if'
04:28:32 <lambdabot> Not in scope: `if''
04:28:37 <idnar> Peaker: but for example, you should usually have a separate function instead of a bool flag to an existing function
04:28:50 <JoshTriplett> Yes.  Or a Maybe, perhaps.
04:29:07 <idnar> and instead of "if null xs" you should probably pattern match on []
04:29:29 <JoshTriplett> idnar: Or use listToMaybe :)
04:29:36 <idnar> (that's an example of something that's harder to do in, say, python)
04:29:58 <JoshTriplett> do thehead <- listToMaybe xs ; workWith thehead
04:29:58 <vixey> idnar, same thing
04:30:09 <idnar> vixey: hmm?
04:30:10 <vixey> null [] = True ; null (_:_) = False
04:30:20 <idnar> vixey: yes, obviously they have the same behaviour
04:30:28 <Peaker> idnar: I agree, but there is a superficial cost to pattern matching a list with "case" vs an "if" which may be cheaper...
04:30:51 <JoshTriplett> Peaker: Uh, no.  The compiler desugars if to case. :)
04:30:52 <idnar> vixey: I'm just saying that foo [] = "empty"; foo xs = "full" is probably stylistically superior to foo xs = if null xs then "empty" else "full"
04:30:55 <Peaker> vixey: I think his point is that calling "null" only to later compare it with True/False is not as nice as just comparing the list with [] or (:)
04:31:07 <Peaker> JoshTriplett: The superficial cost is a syntactic one :-)
04:31:16 <JoshTriplett> Peaker: Ah.
04:31:17 <Peaker> JoshTriplett: As in, it takes more syntax to encode the same program
04:31:34 <JoshTriplett> @hoogle if'
04:31:34 <lambdabot> No results found
04:31:39 <pumpkinator> I still don't like if, I think we should have the if' that pl uses
04:31:42 <JoshTriplett> @hoogle cond
04:31:42 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
04:31:42 <lambdabot> Language.Haskell.TH.Syntax CondE :: Exp -> Exp -> Exp -> Exp
04:31:42 <lambdabot> Language.Haskell.TH condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
04:31:48 <idnar> @src if'
04:31:48 <lambdabot> Source not found.
04:31:50 <vixey> call it bool
04:31:54 <vixey> not "if'"
04:31:55 <idnar> tsk
04:31:59 <idnar> vixey: like "maybe"?
04:32:03 <vixey> yes
04:32:04 <Peaker> @let if' True t _ = t ; if' False _ f = f
04:32:06 <pumpkinator> that's true
04:32:06 <lambdabot>  Defined.
04:32:08 <idnar> I like that, actually
04:32:10 <Peaker> @type if'
04:32:11 <lambdabot> forall t. Bool -> t -> t -> t
04:32:12 <pumpkinator> me too
04:32:21 <idnar> it's the fold operation for Bool
04:32:24 <olsner> booleans could do it themselves, e.g. type Bool = a -> a -> a
04:32:27 <JoshTriplett> Or better yet...
04:32:27 <Peaker> @let bool = if'
04:32:29 <lambdabot>  Defined.
04:32:31 <JoshTriplett> olsner: Yes, that. :)
04:32:35 <pumpkinator> the ?!#@morphism for Bool?
04:32:40 <idnar> olsner: yeah, you can encode any data type as a fold over that data type :P
04:32:55 <JoshTriplett> @let true = if' True
04:32:56 <lambdabot>  Defined.
04:33:00 <JoshTriplett> @let false = if' False
04:33:01 <lambdabot>  Defined.
04:33:11 <idnar> that's a catamorphism, no?
04:33:17 <pumpkinator> I think so
04:33:18 <Peaker> JoshTriplett: those are just const and (flip const)
04:33:19 <JoshTriplett> > true 1 2
04:33:20 <lambdabot>   1
04:33:26 <Peaker> JoshTriplett: you doing LC? :)
04:33:27 <pumpkinator> idnar: but that's a bad word, don't be rude
04:33:28 <vixey> bool true false True = true ; bool true false False = false
04:33:29 <JoshTriplett> Peaker: Yup. :)
04:33:32 <pumpkinator> that's why I censored it
04:33:33 <idnar> pumpkinator: haha
04:33:44 <idnar> Anna Morphism
04:33:56 <JoshTriplett> Peaker: I've written an LC interpreter and then written that style of conditional, yes.
04:34:01 <pumpkinator> :)
04:34:19 <idnar> "In category theory, the concept of catamorphism denotes the unique homomorphism for an initial algebra. "
04:34:23 * idnar cries
04:34:28 <vixey> homomorphism??
04:34:29 <idnar> I know what a catamorphism is, more or less, but that sentence is gibberish to me
04:34:36 <olsner> JoshTriplett: haven't we all :P
04:34:37 <idnar> I should really learn category theory sometime
04:34:48 <vixey> how is a function from  Type -> a   a homomorphism?
04:35:12 <pumpkinator> do they make heteromorphisms?
04:35:17 <idnar> vixey: If (A, in) is the initial F-algebra for some endofunctor F (so in is a morphism from FA to A), and (X, f) is an F-algebra, there is a unique homomorphism from (A, in) to (X, f), which may be denoted cata f (leaving the "carrier" X implicit).
04:35:20 <vixey> Type -> Type  yes, but how does that go?
04:35:21 <pumpkinator> I know they have homeomorphisms
04:35:23 <idnar> vixey: according to wikipedia
04:35:27 <idnar> (that's still gibberish to me)
04:36:46 <JoshTriplett> @let true = const ; false = flip const ; if' = id
04:36:46 <lambdabot>  <local>:23:0:
04:36:46 <lambdabot>      Multiple declarations of `L.true'
04:36:46 <lambdabot>      Declared at: <loca...
04:36:58 <JoshTriplett> Does lambdabot have an "undefine"?
04:37:04 <idnar> @undef
04:37:05 <vixey> @undefine
04:37:09 <olsner> @help undefine
04:37:09 <lambdabot> undefine. Reset evaluator local bindings
04:37:09 <JoshTriplett> @undef true
04:37:10 <idnar> that zaps everything
04:37:13 <JoshTriplett> Oh.
04:37:18 <JoshTriplett> @let true = const ; false = flip const ; if' = id
04:37:19 <lambdabot>  Defined.
04:37:20 <vixey> @let bool true false True = true ; bool true false False = false
04:37:21 <lambdabot>  Defined.
04:37:26 <vixey> :t bool true false
04:37:27 <lambdabot> forall b. Bool -> b -> b -> b
04:37:34 <vegai> ohh, I hope Jeffwheeler's logo wins
04:37:41 <idnar> bool bool bool bool bool bool bool bool bool bool bool bool mushroom mushroom
04:37:49 <idnar> vegai: URL?
04:37:55 <vegai> http://media.nokrev.com/junk/haskell-logos/logo1.png
04:38:11 <mdiin> @src fileExist
04:38:11 <lambdabot> Source not found. You type like i drive.
04:38:13 <vegai> or some of its variants
04:38:20 <idnar> oh yeah, that one
04:38:29 <idnar> that's also definitely my favourite so far
04:38:35 <olsner> ooh, nice logo
04:38:39 <idnar> whining about syntax notwithstanding
04:39:45 <jeffz`> http://www.901am.com/wp-content/uploads/ealogo.jpg
04:39:53 <Eelis> has anyone proposed "no logo" ?
04:39:55 <maltem> vegai: with that logo I nearly miss the "made on a mac" line :)
04:40:10 <idnar> Eelis: but, but, what would you use for favicon.ico?
04:40:18 <Eelis> idnar: what's that?
04:40:33 <maltem> Eelis: "Ceci n'est pas un logo"?
04:40:34 <idnar> Eelis: the icon that gets displayed for a website in your browser's location bar
04:40:45 <Eelis> idnar: i couldn't care less about those, to be honest :)
04:40:58 <int-e> idnar: heh, that feature can be disabled. in any case, they're completely optional
04:41:01 <vegai> a logo is for the people outside more than for us
04:41:17 <idnar> Eelis, int-e: recalibrate your sarcasm detectors, gentlemen! :P
04:41:17 <vixey> it's for branding cows with
04:41:47 <idnar> vixey: now I'm tempted to go photoshop that logo onto the side of a cow
04:41:50 <idnar> or maybe a cat
04:42:02 <int-e> idnar: never!
04:42:09 <JoshTriplett> @let not = flip
04:42:09 <lambdabot>  Defined.
04:42:15 <JoshTriplett> > not true
04:42:16 <lambdabot>       Ambiguous occurrence `not'
04:42:16 <lambdabot>      It could refer to either `Data.Bool.not...
04:42:20 <JoshTriplett> Sigh.
04:42:27 <JoshTriplett> > L.not true
04:42:27 <idnar> > L.not true
04:42:27 <lambdabot>       Overlapping instances for Show (b -> a -> a)
04:42:27 <lambdabot>        arising from a use ...
04:42:28 <lambdabot>       Overlapping instances for Show (b -> a -> a)
04:42:28 <lambdabot>        arising from a use ...
04:42:29 <idnar> heh
04:42:37 <JoshTriplett> > L.not true 1 2
04:42:38 <lambdabot>   2
04:42:40 <JoshTriplett> > L.not false 1 2
04:42:41 <lambdabot>   1
04:42:42 <trygvis> ~.
04:42:46 <idnar> whee
04:44:28 <Peaker> idnar: hey have you also kinda lost interest in Python/Twisted after going deeper into Haskell? :)
04:44:31 <vixey> when you @let
04:44:45 <vixey> why doesn't lambdabot import ... hiding (<whatever you let>)
04:44:50 <idnar> Peaker: I wouldn't really say I've "lost interest"
04:45:11 <idnar> Peaker: Haskell has definitely been my "favourite language" for a long time now, but for a number of reasons, it's not practical to adopt for most of my projects
04:45:13 <int-e> vixey: why doesn't lambdabot import L qualified? :-P
04:45:39 <Peaker> idnar: I think it is practical, but I don't have enough experience to be sure, so I don't use it much yet
04:45:45 * int-e would rather have standard haskell code work without worrying about @let
04:45:50 <Peaker> idnar: I did start writing little tools for work with Haskell :)
04:46:14 <idnar> Peaker: 1) cost of reimplementing existing Python / Twisted libraries    2) lack of Haskell knowledge / experience on my part    3) extensive existing Python codebases
04:46:15 <Peaker> idnar: its taking me more time than it would in Python (I have about 8 years of intense Python experience, and much much less in Haskell), but I am much more pleased with the results
04:46:31 <JoshTriplett> @pl \x y -> x y false
04:46:31 <lambdabot> flip flip false
04:46:46 <idnar> Peaker: Haskell is so much "deeper" than Python, though
04:46:57 <JoshTriplett> @pl \x y -> x true y
04:46:57 <lambdabot> ($ true)
04:47:02 <JoshTriplett> Oooh.
04:47:08 <idnar> Peaker: I mean, I knew basically everything there is to know about Python after about 6 months of dabbling with it
04:47:24 <JoshTriplett> idnar: So you've written metaclasses, then? :)
04:47:25 <idnar> Peaker: I've been dabbling with Haskell for far longer than that, and I've only really scratched the surface
04:47:35 <Peaker> idnar: I think I was convinced, through a series of small incremental improvements, that Twisted really is not the right model, and that M:N coroutine/thread model (That the Haskell RTS uses) is a better one
04:47:40 <idnar> JoshTriplett: way too many :/
04:48:04 <Peaker> Metaclasses are quite useless, IMO. The only use to having something be a class instead of an instance, is for pickle to pickle it by reference
04:48:05 <idnar> Peaker: I don't think the coroutine model is practical in an imperative language
04:48:24 <idnar> no, the use to having something be a class is that you can use the class statement syntax :P
04:49:01 <Peaker> idnar: well, you could just use M:1 and have a huge coarse lock everywhere to get Twisted-like behavior (Note in Twisted when you run deferred callbacks, or call "far" code, you lose the same control you lose in a coroutine/thread context switch)
04:49:23 <idnar> class Foo(Interface): def bar(baz): """quux""" is a lot nicer than Foo = InterfaceClass(name='Foo', methods=FunctionSignature(name='bar', doc='quux', params=['baz'])) or whatever
04:49:23 <Peaker> idnar: I am not sure why "class syntax" is very useful, though..
04:49:25 <JoshTriplett> http://hpaste.org/13400
04:49:58 <idnar> er, add some [] in there
04:50:08 <Peaker> idnar: also, you can use class-decorators
04:50:17 <Peaker> idnar: Foo=Interface(Foo)
04:50:19 <JoshTriplett> idnar: Yeah, I think you nicely described the point of metaclass syntax.
04:50:32 <SamB_XP> Peaker: well, you have to admit it *is* prettier than what idnar says. personally, though, I find the bytecode it uses rather ... disturbing
04:50:39 <JoshTriplett> idnar: Take advantage of class syntax for your own purposes.
04:51:07 <Peaker> SamB_XP: that what is prettier? Metaclasses or class-decorators?
04:51:17 <Peaker> class syntax really isn't that nice :P
04:51:17 <idnar> Peaker: a huge coarse lock everywhere would be an automatic deadlock
04:51:31 <idnar> Peaker: the problem with the coroutine model in Python is that you have all this mutable shared state
04:51:35 <Peaker> idnar: with just 1 lock, how can there be a deadlock?
04:51:44 <SamB_XP> Peaker: I dunno ... I don't play with those Python features now that I've found Haskell ;-P
04:51:47 <idnar> so when you invoke a switching operation, all of that shared state can change under your feet
04:51:54 <idnar> if you lock all of that state, then nothing else can execute
04:52:18 <idnar> in Haskell, this isn't a problem, because just about everything is immutable to start with
04:52:27 <SamB_XP> I thought the GIL was a CPython thing, not a Twisted thing
04:52:48 <idnar> SamB_XP: we're not talking about the GIL, we're talking about something hypothetical
04:52:59 <SamB_XP> well, it sure sounds like the GIL to me ;-P
04:53:05 <hugo___> where can i learn about list comprehensions ?
04:53:08 <idnar> it's similar... but not :P
04:53:17 <Peaker> idnar: the lock is only locked in a thread/coroutine for as long as its reactor event is handling -- preventing other events from running at the same time.   threads+1 big lock  can emulate the Twisted model of execution
04:53:30 <idnar> Peaker: I don't think that would be useful
04:53:36 <SamB_XP> hugo___: you could read a tutorial, or you could look in the Report
04:53:40 <idnar> Peaker: since it doesn't address the main problem I have with "coroutine" style code
04:53:49 <SamB_XP> @go "Haskell list comprehensions"
04:53:51 <lambdabot> http://langexplr.blogspot.com/2007/02/list-comprehensions-across-languages_18.html
04:53:51 <lambdabot> Title: Exploring Beautiful Languages: List comprehensions across languages
04:53:58 <SamB_XP> @go Haskell "list comprehensions"
04:54:00 <idnar> Peaker: anyway, you can always use inlineCallbacks if you want that
04:54:00 <lambdabot> No Result Found.
04:54:07 <SamB_XP> WTH!!!
04:54:07 <hugo___> hehe
04:54:10 <SamB_XP> no result!
04:54:11 <Peaker> idnar: you don't "switch" to a different coroutine until you release the lock or "return to the reactor" as it is in Twisted
04:54:24 <hugo___> wth ? ahah
04:54:33 <Peaker> idnar: I think equivalence even on the superficial level can be shown
04:54:40 <idnar> Peaker: equivalence to what?
04:54:48 <JoshTriplett> @hoogle Omega
04:54:48 <lambdabot> package control-monad-omega
04:54:50 <idnar> Peaker: this is a syntactic issue, not an operational issue
04:54:58 <JoshTriplett> @type Omega
04:54:59 <lambdabot> Not in scope: data constructor `Omega'
04:55:00 <JoshTriplett> Awww.
04:55:09 <RayNbow> :t runOmega
04:55:09 <lambdabot> Not in scope: `runOmega'
04:55:12 <Peaker> idnar: do you prefer the syntax of explicit installation of callbacks?
04:55:17 <vixey> :t reflect
04:55:17 <lambdabot> forall a (m :: * -> *). (MonadLogic m) => Maybe (a, m a) -> m a
04:55:22 <idnar> Peaker: in Python, yes
04:55:25 <Peaker> idnar: that's the main reason I couldn't get most of my friends to try out Twisted
04:55:58 <JoshTriplett> @info MonadLogic
04:55:58 <lambdabot> MonadLogic
04:56:02 <Peaker> idnar: everyone hates the explicit addCallback/addErrback, Python already has constructs for that thing, and its kind of redundant
04:56:04 <JoshTriplett> @instances MonadLogic
04:56:04 <lambdabot> Couldn't find class `MonadLogic'. Try @instances-importing
04:56:12 <idnar> Peaker: it would be nice if Python had syntax like E's when (promise) { code }, but it's not a big deal
04:56:32 <idnar> Peaker: the problem with inlineCallbacks style code is that it obfuscates the switching somewhat, which is really rather dangerous
04:56:42 <JoshTriplett> vixey: Interesting!
04:56:58 <JoshTriplett> vixey: Oh, the Prolog monad.
04:57:00 <Peaker> @src MonadLogic
04:57:00 <lambdabot> Source not found. stty: unknown mode: doofus
04:57:01 <idnar> Peaker: so, there are two ways to solve that: 1) remove the obfuscation (ie. write explicit callbacks)   2) remove the danger (ie. get rid of mutable state)
04:57:03 <JoshTriplett> vixey: Less interesting. :)
04:57:21 <idnar> Peaker: 2) isn't really feasible in Python, but it would be in Haskell
04:57:22 <Peaker> idnar: Haskell thread style does neither of those...
04:57:27 <vixey> JoshTriplett, it's nothing like Prolog at all
04:57:35 <Peaker> idnar: well, I think 2 is really FRP
04:57:39 <idnar> Peaker: Haskell doesn't have uncontrolled mutable state
04:57:50 <Peaker> idnar: in IO, it does
04:58:03 <idnar> Peaker: it doesn't have any mutable state unless you explicitly make it mutable; so it's relatively easy to control
04:58:06 <quicksilver> even then it's rather clearly segregated.
04:58:13 <quicksilver> and it has a high degree of control
04:58:23 <quicksilver> an MVar can be its own lock, for many simple cases
04:58:24 <idnar> for example, you can easily verify that a particular portion of code doesn't rely on any mutable state at all
04:58:35 <idnar> so there's no way it could be affected by unexpected state changes
04:58:48 <pumpkinator> unless someone hid unsafePerformIO somewhere in one of the functions you're calling
04:59:19 <JoshTriplett> pumpkinator: Even then, by using unsafePerformIO they claim they don't rely on any state.
04:59:22 <Peaker> quicksilver: I think having many mvars in various places (without spending a lot of the time thinking about your design) is probably a recipe for deadlock
04:59:24 <JoshTriplett> pumpkinator: Of course, they might lie.
04:59:26 <pumpkinator> yeah :P
04:59:29 <idnar> well, sure, but we're not trying to defend against malicious code here
04:59:39 <idnar> or rather, against malicious intent
04:59:42 <pumpkinator> what if you're just stupid?
04:59:48 <pumpkinator> I mean
04:59:49 <pumpkinator> not you
04:59:56 <pumpkinator> but whoever wrote the unsafePerformIO :P
04:59:58 <Peaker> quicksilver: admittedly, this is a hunch and not experience with them, but still :)
05:00:04 <idnar> if all else fails, you can just grep for unsafePerformIO :P
05:00:15 <JoshTriplett> pumpkinator: I would argue that any Turing-complete language cannot make itself stupid-proof.
05:00:20 <quicksilver> Peaker: there are a variety of obvious ways to use MVars which are guaranteed deadlock free.
05:00:27 <Peaker> quicksilver: How?
05:00:34 <quicksilver> Peaker: the simplest one (for the kind of program I think we're discussing) is to only have one.
05:00:50 <quicksilver> another way is to only access one at once.
05:00:59 <Peaker> quicksilver: Well, that's why I said "many mvars in various places"..
05:01:04 <quicksilver> If you find yourself accessing multiple mvars at once, you probably want TVars
05:01:09 <quicksilver> I know. I wasn't disagreeing.
05:01:14 <quicksilver> I was elaborating.
05:01:36 <Peaker> quicksilver: I think we really want to get rid of the imperative code altogether, and use FRP or something :-)
05:02:07 <quicksilver> perhaps.
05:02:11 <quicksilver> maybe we want different things.
05:02:20 <quicksilver> sometimes its nice to take small steps.
05:02:21 <idnar> eh, you can write plenty of code in the IO monad (or in some subset) without any mutable state
05:02:49 <idnar> I mean, I like the idea of FRP, but you really don't have to get fancy to keep things under control
05:03:05 <idnar> I still need to write some real network code in Haskell, though
05:03:09 <idnar> take a look at HAppS, and so on
05:03:43 <quicksilver> FRP isn't fancy at all.
05:03:44 <quicksilver> (in use)
05:03:49 <quicksilver> implementing it is fancy, though.
05:03:52 <JoshTriplett> idnar: I haven't used HAppS, but I've written large programs with Network.CGI and Data.XHtml.
05:04:02 <JoshTriplett> quicksilver: Yeah, that sounds about right.
05:04:11 <JoshTriplett> idnar: Works beautifully.
05:04:15 <idnar> JoshTriplett: ugh, CGI :P
05:04:25 <JoshTriplett> idnar: Network.FastCGI, actually.
05:04:46 <idnar> JoshTriplett: you're not going to catch me writing any *CGI (or even WSGI) code any time soon
05:04:47 <hugo___> JoshTriplett: does it work with apache ?
05:04:56 <JoshTriplett> hugo___: Probably, but I run it with lighttpd.
05:05:02 <hugo___> sweet
05:05:22 <hugo___> can i see the code ? :P
05:06:06 <JoshTriplett> hugo___: Currently working on it with a friend and trying to have it ready to launch by the end of the year.
05:06:11 <hugo___> ok
05:06:21 <JoshTriplett> hugo___: And then yeah.
05:06:52 <hugo___> i've been using happs, but for personal use i have an account at the dreamhosting
05:07:08 <hugo___> and they don't allow me to start happs up :P
05:07:21 <hugo___> so, fastCGI is better than php... i ought look at it in my spare time
05:07:24 <hugo___> thanks
05:09:18 <idnar> Peaker: one thing I still don't have a good handle on is the usability of most Haskell libraries
05:09:39 <Peaker> idnar: There are lots of unusable things in/around Haskell :-(
05:09:48 <Peaker> idnar: lack of example code for libraries, too, IMO
05:09:51 <idnar> Peaker: I do find that I end up reinventing the wheel in Python on a depressingly regular basis, just because all of the existing libraries implement the square wheel or the triangular wheel
05:10:16 <idnar> I'm hoping the general level of code quality in Haskell-land is better, but I don't really have enough experience yet
05:10:47 <idnar> on the other hand, the few external dependencies that I do have in Python-land (Twisted / etc.) do represent a rather significant amount of effort
05:11:01 <JoshTriplett> idnar: I have run into the occasional stupid library annoyance in Haskell, but I find it pretty rare.
05:11:21 <JoshTriplett> idnar: I've hit a few with HDBC, for instance.
05:11:31 <JoshTriplett> idnar: And one with Control.Monad.Error.
05:12:21 <JoshTriplett> idnar: Actually, in both cases they related to unnecessary instances I had to write.
05:12:23 <Peaker> it took me ~4 hours to learn how to use the Haskell regexp libraries! :(
05:12:27 <idnar> JoshTriplett: the depressing part is that most Python code is just plain broken
05:12:29 <JoshTriplett> idnar: Or instances I didn't want to have to write.
05:12:32 <Peaker> (knowing regexps already)
05:12:40 <Peaker> probably took about 5 minutes to learn how to use Python's "re" module
05:12:48 <idnar> JoshTriplett: like, basically every network protocol implementation in the python standard library is unusable for anything serious, because it's just plain wrong or broken
05:13:05 <Peaker> I think 10-15 examples on some documentation page for the regexp stuff could help
05:13:17 <JoshTriplett> idnar: For instance?
05:13:27 <idnar> Peaker: why would you even want to learn Haskell regexp libraries when you have Parsec?
05:14:06 <idnar> JoshTriplett: uhm, I can't remember too many specific examples, since I've been staying clear of that code for so long
05:15:06 <Peaker> idnar: I don't know Parsec, but maybe I should have used that instead
05:15:13 <idnar> JoshTriplett: one example that comes to mind was a long-standing bug in urllib where trying to fetch a URL like "http://foo.com//bar" resulted in a Host: //bar header or something stupid like that
05:15:21 * JoshTriplett tries to figure out a cleaner way to write this cgi code: maybeFoo <- getInput "foo" ; when isJust foo $ ...
05:15:24 <Peaker> idnar: I don't like Parsec very much either, though
05:15:29 <Peaker> idnar: (from the little I do know)
05:15:51 <idnar> Peaker: I haven't used parsec much, but just about anything is better than regular expressions
05:16:19 <Peaker> idnar: That may be true, but there's no reason a regexp library will take more than a few minutes to learn to use
05:16:46 <idnar> Peaker: *shrug* the only reason I ever use regular expressions is that I don't have a decent parser library handy
05:17:31 <Peaker> idnar: Well, another example is the XML libraries.  Text.XML.Light was pretty great -- the types told me almost everything I wanted to know, and simple experimentation told me the rest.. the heavy-weight XML library, though, was just terribly complicated/unusable
05:17:38 <idnar> unfortunately your options in Python aren't so great, but Parsec seems pretty suitable for most tasks
05:17:40 <Peaker> @hoogle xml
05:17:41 <lambdabot> package xml
05:17:41 <lambdabot> package xml-parsec
05:17:41 <lambdabot> package xml2x
05:17:51 <idnar> Peaker: yeah, that's the kind of thing I haven't explored much, but doesn't look promising
05:18:20 <idnar> you find people saying "use this library", and the library implements some nice technique, except they only got halfway and the website / code hasn't been updated in the last 5 years
05:18:30 <idnar> and then you're left wandering "now what?"
05:19:01 <idnar> but I guess I'm used to that sort of thing in the other languages I've used
05:19:05 <maltem> JoshTriplett: maybe (return ()) foo =<< getInput "foo" -- is not even cleaner
05:19:25 <Peaker> I have:   maybeAction = maybe (return ())
05:19:55 <Peaker> though   unit = return ()   or some such could be nice too: maybe unit ...
05:20:19 <maltem> I think, too, that there's a Control.Monad.Cond module on hackage, defining things like whenM
05:20:21 <Peaker> idnar: XML is painful in all libraries/languages, though I think Text.XML.Light was the least painful :)
05:20:33 <vixey> instance Monad m => Unit (m ())
05:20:34 <idnar> Peaker: I find etree in Python quite nice
05:20:40 <JoshTriplett> "XML is like violence.  If it doesn't work, use more."
05:20:46 <idnar> JoshTriplett: hahaha
05:20:49 <TML> JoshTriplett: Nice
05:20:55 <Peaker> @src Unit
05:20:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:21:00 <idnar> Peaker: well, for parsing, anyhow; I tend to use Nevow for generating
05:21:02 <Peaker> @src unit
05:21:03 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:21:07 <Peaker> @hoogle unit
05:21:08 <lambdabot> Data.Generics data Unit
05:21:08 <lambdabot> Data.Generics Unit :: Unit
05:21:08 <lambdabot> Language.Haskell.Syntax unit_con :: HsExp
05:21:17 <Peaker> vixey: does that exist? what are the methods?
05:21:32 <vixey> no methods
05:21:32 <maltem> “So, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.”
05:21:37 <vixey> doesn't exist
05:21:38 <Peaker> idnar: I hate the dichotomy between parsing and generating. I want one specification to do both
05:21:48 <idnar> Peaker: hah
05:22:05 <Peaker> idnar: why "hah", its very possible
05:22:13 <idnar> Peaker: it's possible, I'm just not sure it's a great idea
05:22:19 <Peaker> idnar: why not?
05:22:33 <Peaker> idnar: it prevents code duplication and parser/builder compatibility bugs..
05:22:43 <idnar> Peaker: I think it's too difficult to reconcile the difference in priorities between someone writing a parser, and someone writing a generator
05:22:56 <idnar> Peaker: consider XHTML, for example
05:22:59 <Peaker> idnar: what are the different priorities?
05:23:19 <idnar> Peaker: when you're generating XHTML, you're concerned with your application's appearance and content
05:23:29 <JoshTriplett> @hoogle maybeToBool
05:23:29 <lambdabot> No results found
05:23:32 <idnar> when you're parsing XHTML in, say, a web browser, you're concerned about rendering it for the user to see
05:23:39 <vixey> Peaker: "it prevents code dup..." -- like, you actually got a working thing going?
05:23:43 <idnar> or whatever
05:24:02 <Peaker> idnar: either way, you just want to convert some XHTML structure to text or back, that part is definitely two-way
05:24:13 <idnar> Peaker: that's pretty low-level
05:24:18 <Peaker> vixey: not me, but others have
05:24:22 <idnar> I mean, sure, you can turn an XHTML document into an isomorphic data structure
05:24:23 <vixey> like who?
05:24:32 <JoshTriplett> maltem: In that example I gave, I don't actually need foo bound.
05:24:43 <idnar> but that achieves virtually nothing
05:25:04 <Peaker> vixey: Andrew Kennedy (pickler combinators) and a friend of mine (Yair Chuchem)
05:25:15 <idnar> you've got a data structure that's slightly easier to consume than the XML tree itself, that's all
05:25:29 <vixey> with code online?
05:25:36 <idnar> now, if the only way you have to consume the XML tree is the DOM API or something, then sure, that might be an attractive proposition
05:25:48 <Peaker> vixey: research.microsoft.com/en-us/um/people/akenn/fun/picklercombinators.pdf
05:25:53 <JoshTriplett> The problem with XML: it makes parsing almost as trivial as lexing, but then the abstract syntax tree looks like the input to a parser. :)
05:26:14 <vixey> I saw picklers but it is pretty much useless
05:26:14 <idnar> JoshTriplett: heh, yeah
05:26:23 <Peaker> idnar: XML DOM -> Render  is not "parsing",  XML Text -> DOM is parsing, and DOM -> XML Text can share the same code
05:26:43 <quicksilver> vixey: how is that "pretty much useless" ?
05:27:02 <Peaker> vixey: Well, its useless because "Binary" already does that.  It would be useful if it allowed specification of the exact format "on the wire"
05:27:06 <idnar> Peaker: yes, I'm just saying that that's very low-level
05:28:37 <Peaker> idnar: well, the "parsing" part here is low-level
05:29:32 <Peaker> idnar: still no reason to duplicate the specifications
05:29:34 <idnar> Peaker: sure, I guess what I'm talking about isn't really "parsing" per se
05:29:52 <vixey> you can't parse a programming language with it
05:30:02 <idnar> Peaker: on that level, I guess I agree with you; it's like constructors in Haskell also being deconstructors
05:30:31 <Peaker> vixey: you mean, it doesn't serialize/deserialize to/from text?
05:30:35 <JoshTriplett> I'd love to parse XML via pattern matching, if pattern matching had just a bit more power.
05:30:44 <olsner> Hmm, if I'm reading this correctly, this benchmark is compiled and run without threading support? http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=ghc&id=1
05:31:05 <JoshTriplett> I wonder if view patterns would make XML parsing work well?
05:31:36 <JoshTriplett> parseLink (Tag "a" (lookup "href" -> Just href)) = ...
05:31:57 <idnar> JoshTriplett: yeah, it could work like XPath
05:32:33 <olsner> and, wtf, the code is the single-threaded solution too?
05:32:35 <Peaker> btw, what are XML CRef's?  Text.XML.Light has: data Content = Elem Element | Text CData | CRef String
05:32:37 * olsner is confused
05:33:10 <JoshTriplett> Actually, of all the things that bug me about XML, the distinction between attributes and child elements tops the list.
05:33:26 <Rui> how would I make a prog that: receives a list of lists (EX: [[Null,Null,X,O],[Null,X,O,X]]) and a number. it then goes to the list which the number corresponds to (ex: 1 = [Null,Null,X,O] - 2 = [Null,X,O,X]) and then adds a new "X" to the rightmost Null, and returns the full list of lists
05:33:30 <idnar> Peaker: &foo; I guess?
05:33:32 <JoshTriplett> I mean, as a syntactic convention, sure.
05:33:41 <Peaker> XML is a tree of elements with 3 kinds of leafs: Text, Attributes, Elements
05:33:48 <vixey> Rui, do you know how to write !! ?
05:33:51 <idnar> hmm, maybe not
05:33:59 <Peaker> idnar: sounds likely, I'll check
05:34:07 <JoshTriplett> But I think <a href="..."> should parse identically to <a><href>...</href> .
05:34:07 <Rui> first 2 months so not well
05:34:26 <Peaker> idnar: yep, it is, cool
05:34:51 <JoshTriplett> Rui: Well, let's take it step by step.
05:34:52 <idnar> JoshTriplett: heh
05:34:56 <flux> joshtriplett, you'd like that kind of redundancy in XML?
05:35:16 <idnar> JoshTriplett: "data style" XML tends to avoid attributes like that
05:35:21 <JoshTriplett> idnar: Agreed.
05:35:28 <JoshTriplett> flux: I'd like to remove that kind of redundancy.
05:35:34 <idnar> whereas "markup style" has plenty of attributes
05:35:37 <JoshTriplett> :t (!!)
05:35:37 <lambdabot> forall a. [a] -> Int -> a
05:35:58 <JoshTriplett> Rui: So, let's start by writing a function which can modify one element of a list.
05:36:35 <Peaker> Rui: IMO, the nicest solution to your problem is with editor-combinators
05:37:07 <Rui> f board c =  board !! (c-1)
05:37:24 <Rui> ok that finds the list and returns it to me
05:37:27 <Peaker> @let nth 0 f (x:xs) = f x:xs ; nth n f (x:xs) = x:nth (n-1) f xs
05:37:28 <lambdabot>  Defined.
05:37:34 <JoshTriplett> @let modifyNth 0 f (x:xs) = f x : xs ; modifyNth n f (x:xs) = x : modifyNth (n-1) xs
05:37:35 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a -> a'
05:37:53 <JoshTriplett> Peaker: You beat me to it. :)
05:37:54 <Peaker> JoshTriplett: :)
05:38:18 <Peaker> Rui: see the above "nth" function?
05:38:19 <JoshTriplett> > nth 5 (*2) [1..10]
05:38:20 <lambdabot>   [1,2,3,4,5,12,7,8,9,10]
05:38:27 <JoshTriplett> > nth 5 (*10) [1..10]
05:38:28 <lambdabot>   [1,2,3,4,5,60,7,8,9,10]
05:38:32 <Peaker> JoshTriplett: funny, that's the _exact_ same example I used the other day when I first defined it
05:38:50 <JoshTriplett> Peaker: Heh.  It does seem like the obvious example. :)
05:39:20 <JoshTriplett> Rui: OK, now that you have a function to modify the nth element of the outer list, you need something that replaces the last Null.
05:39:29 <Peaker> > nth 1 (++["hello"]) [["a", "b", "c"], ["c","d","e"], ["f","g","h"]]
05:39:30 <lambdabot>   [["a","b","c"],["c","d","e","hello"],["f","g","h"]]
05:39:36 <Rui> think i probably explained it wrong
05:39:39 <athos> connection fixed :)
05:39:55 <JoshTriplett> Rui: Perhaps you could explain the problem you want to solve and we could help you find a better representation of it?
05:40:02 <Rui> yea
05:40:11 <Rui> ok imagine a board like connect 4
05:40:14 <Peaker> Rui: what do you mean by "adds a new X to the rightmost Null"?
05:40:15 <JoshTriplett> OK.
05:40:28 <JoshTriplett> Rui: OK, got it now. :)
05:40:33 <Rui> [[Null,Null,X,O],[X,X,O,X],[Null,O,X,X],[Null,Null,Null,O]]
05:40:36 <JoshTriplett> Rui: In that case, you have the wrong board representation. :)
05:40:38 <Rui> the lists are teh columns
05:40:50 <JoshTriplett> Rui: Don't have the Null values.
05:40:55 <Axman6> Rui: not othello is it?
05:41:04 <Peaker> Rui: btw: If you have Null | <more data constructors here>  it might be more useful to use Maybe instead
05:41:08 <Rui> null is just what i used to represent it
05:41:09 <Rui> type Board = [Row]
05:41:09 <Rui> type Row = [Moves]
05:41:09 <Rui> data Moves = Null
05:41:09 <Rui>             | X
05:41:09 <Rui>             | O
05:41:13 <JoshTriplett> Yeah, that too.
05:41:26 <JoshTriplett> data Side = X | O
05:41:31 <Rui> axman6: nope
05:41:38 <JoshTriplett> data Location = Maybe Side
05:41:43 <Axman6> what game is it?
05:41:56 <Peaker> Rui: data Piece = X | O ; type Row = [Maybe Piece]
05:42:04 <Rui> ive already worked with the rest of the game with Null and whatnot, graphically displaying hte board in haskell. made instances etc so, can we just stay with Null?
05:42:19 <vixey> Rui, Maybe Piece is way better
05:42:25 <Axman6> i'd stay with null
05:42:28 <Raevel> more better?
05:42:34 <Peaker> Axman6: why?
05:42:39 <mm_freak> (again, lists abused for something, where arrays are MUCH better)
05:42:49 <JoshTriplett> mm_freak: Yeah, that too.
05:42:56 <Axman6> because no everything has to use Maybes
05:43:01 <Rui> Axman6: just a game where you paly till the board is full. then count the number of lines. like if you have a line of 2 coins, its 5 points, 5 coinds, 10 points etc
05:43:17 <Rui> I think the rest of the game is fine with the Nulls I put it
05:43:24 <Rui> just imagine it as N X O then ><
05:43:27 <Peaker> Axman6: maybes have a lot of useful code you can reuse
05:43:46 <mm_freak> type PlayField = Array (Int,Int) (Maybe Piece)
05:43:50 <JoshTriplett> Rui: So, your board has a property that your types don't reflect.
05:43:52 <mm_freak> well, no
05:43:57 <mm_freak> type PlayField = UArray (Int,Int) (Maybe Piece)
05:43:57 <Rui> ?
05:44:08 <JoshTriplett> Rui: Namely, that you can't have "holes".
05:44:09 <vixey> use a grid comonad
05:44:11 <Axman6> Peaker: that might not need to be used, and i'm sure he'll learn more by defining how own data
05:44:17 <vixey> @go comonad game of life
05:44:19 <Axman6> assuming he's new to haskell
05:44:21 <lambdabot> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
05:44:21 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
05:44:25 <Peaker> Axman6: he can define his own Maybe then :-)
05:44:26 <Rui> yea I am new to haskell ><
05:44:28 <vixey> Rui, ^
05:44:31 <JoshTriplett> Rui: Pieces always fall to the lowest Null position.
05:44:36 <Rui> yes
05:44:51 <JoshTriplett> Rui: So rather than representing a column as [Null, Null, Null, X, O]...
05:44:53 <Rui> so after finding the column corresponding to the number, I want the new play, in this case an "X" to fall to the lowest Null
05:44:58 <JoshTriplett> Rui: You could represent it as [X, O].
05:44:58 <Axman6> Rui: go with what feels best to you, then learn other (possibly better) ways to do thing later
05:45:12 <Peaker> mm_freak: Is UArray mutable?
05:45:15 <JoshTriplett> Rui: If you do that, then you can add a new piece by just doing X:column or O:column.
05:45:19 <Rui> yea but when I run in to the program to graphically design the board, I need those Null values
05:45:21 <mm_freak> Peaker: no
05:45:26 <Axman6> JoshTriplett: no you can't, that doesn't represent any useful positions
05:45:30 <JoshTriplett> Rui: OK, but you can add those values when you draw the board.
05:45:31 <Peaker> mm_freak: then the copying might be expensive
05:45:31 <vixey> Rui, you can use Nothing in place of Null
05:45:35 <Peaker> mm_freak: why not Data.Map ?
05:45:47 <Axman6> though i could be missing how the game works
05:45:54 * Axman6 goes back to the IT crowd
05:46:04 <mm_freak> Peaker: UArray is quite fast, unless you have megabytes of an array
05:46:22 <EvilTerran> mm_freak, not for updates
05:46:23 <JoshTriplett> Rui: You can trivially do something like fillRow row = replicate (maxRowLength - length row) Null ++ row
05:46:37 <JoshTriplett> Rui: That will pad a row with Null out to maxRowLength.
05:46:43 <mm_freak> EvilTerran: ?
05:47:11 <JoshTriplett> Rui: Does that make sense?
05:47:12 <Peaker> I think I'd represent board as:  data Piece = X | O ; data Board = Board { pieces :: Map.Map (Int,Int) Piece ; highestInColumn :: Map.Map Int Int }
05:47:38 <EvilTerran> mm_freak, mutating a UArray is O(n); mutating a Data.Map is O(log n)
05:47:39 <Rui> not really ><
05:47:41 <JoshTriplett> Peaker: That seems useful too.
05:47:52 <JoshTriplett> Peaker: Though it doesn't give you good sharing between game states.
05:48:04 <EvilTerran> mm_freak, regardless, Data.Map's interface is generally nicer
05:48:09 <JoshTriplett> Rui: OK.
05:48:11 <Peaker> JoshTriplett: why not?
05:48:22 <mm_freak> EvilTerran: yeah, but UArray is still faster for something like tic tac toe or 4-game
05:48:30 <Rui> http://hpaste.org/13401 <- shows the program to generate the board in haskell
05:48:47 <Peaker> JoshTriplett: yeah, actually, an array of column lists makes more sense :)
05:48:58 <Peaker> JoshTriplett: (Int, Column lists) for keeping the length
05:49:06 <EvilTerran> mm_freak, er, wait, you're worrying about speed when your data set is that small?
05:49:28 <JoshTriplett> Peaker: Fair enough, if you care about speed. :)
05:49:40 <Rui> ok let me go to the begining
05:49:47 <EvilTerran> i call premature optimisation; a Data.Array might make more sense than a Data.Map for a fundamentally array-shaped board, but a UArray is overkill
05:49:48 <Rui> first i need to isolate the column I want correct?
05:49:48 <mm_freak> EvilTerran: it's not my data set, but Rui's
05:49:50 <Rui> would f board c =  board !! (c-1) work?
05:50:04 <Peaker> data Piece = X | O ; data Board = Board { columns :: Map.Map Int (Int, [Piece]) }
05:50:14 <vixey> Maybe Piece
05:50:18 <EvilTerran> a standard Array is lazier than a UArray
05:50:22 <mm_freak> yeah, Array may be better, but i'm sure there entire array needs to be computed after each move, anyway
05:50:28 <Peaker> vixey: nope, the list is from the bottom, and you prepend on top of it
05:50:29 <mm_freak> at least to print/show it
05:50:31 <vixey> oh even better
05:50:36 <Rui> f board c =  board !! (c-1) would grab the whole board [[...],[...]....] and return the column corresponding to the number
05:50:51 <JoshTriplett> Rui: That doesn't help you if you want to replace that column.
05:50:58 <JoshTriplett> One moment.
05:52:10 <Peaker> Rui: remember that the easiest modification of a list is prepending to it, and its also cheap.  So you can get a game move to just be a list prepend by representing each column as a list that prepends upwards
05:53:00 <Rui> prepending? >< I'm not an english speaker :p
05:53:17 <JoshTriplett> Rui: Putting at the beginning.
05:53:27 <JoshTriplett> > 1 : [2, 3, 4]
05:53:28 <lambdabot>   [1,2,3,4]
05:53:32 <Rui> ah ok
05:53:35 <JoshTriplett> "prepending 1 to the list [2, 3, 4]"
05:53:50 <JoshTriplett> Now, doesn't that look a lot easier than trying to find and replace the last Null? :)
05:53:58 <Rui> well then I got a question
05:54:04 <Rui> my whole program works with a list of rows
05:54:25 <Rui> so top left to right, next row left to right etc
05:54:40 <Rui> i made a transpose prog to make a list of columns now
05:54:47 <Rui> thinking, that it would be easier
05:54:52 <Rui> to add the new "coin" to the column
05:54:55 <Rui> instead of rows
05:55:55 <Rui> so instead of [[Null,Null,Null],[X,X,O],[O,O,X]] how everything else works, i traponsed it to [[Null,X,O],[Null,X,O],[Null,O,X]]
05:56:01 <Rui> so i can work with columns whne adding the new play
05:56:08 <idnar> jI associate Haskell with Zen, due to one of my favorite dialogues: "If it's
05:56:08 <idnar> purely functional, how do you *do* anything?" "You don't ;-)"   (Courtesy of
05:56:08 <idnar> Conal Elliott)
05:56:13 <idnar> er, wrong button :(
05:56:18 <Rui> does it simplify it or should i leave it to adding to the rows?
05:57:03 <JoshTriplett> Rui: You definitely want to keep each column as a list, because you can add to a column more easily, since coins fall down columns.
05:57:13 <vixey> @quote Zen
05:57:14 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
05:57:16 <JoshTriplett> Rui: You can just transpose for display, if you need to.
05:57:16 <vixey> @quote Zen
05:57:16 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
05:57:22 <Rui> kk so work with transpose while adding the new play
05:57:29 <Rui> i need the rest as rows for the other progs
05:57:31 <vixey> @remember conal If it's purely functional, how do you *do* anything? You don't ;-)
05:57:31 <lambdabot> I will remember.
05:57:43 <Rui> prof wants it xD
06:01:03 <Peaker> Rui: why do you need to "Transpose", why not always keep a container of columns (whether list, map, or array)?
06:01:24 <Rui> i need to work with a list of rows for other applications the prof wanted
06:01:29 <Rui> and then whe ni get to adding the new play
06:01:35 <Rui> i trasposed the rows to colums
06:01:43 <Rui> so i can add the new play easier
06:01:55 <Rui> which at the end, will then retranspose it back to rows
06:01:55 <vixey> why don't you tell him you are using a better way?
06:02:00 <Rui> lol
06:02:23 <Rui> i think its more of the fact that he wants us to know how the language works
06:02:31 <Rui> more then making the 100000000th connect 4 type game
06:02:41 <Peaker> Rui: learning how a language works by writing unidiomatic/bad code in it is a bad way to learn how it works ...
06:02:49 <Rui> <shrug>
06:03:01 * quicksilver disagrees strongly with Peaker 
06:03:10 <quicksilver> rui's prof wants him to learn various kinds of list manipulation
06:03:21 <quicksilver> the particular exercise may be quite contrived -- they often are
06:03:27 <Rui> for example, i need it in rows to easily check if the board is full
06:03:30 <Peaker> quicksilver: why not learn list manipulations with examples where they make sense as the best solution to some problem?
06:03:31 <quicksilver> but the lessons you learn are applicable in other situations.
06:03:37 <Rui> ex: if [[Null,Null,Null,Null],.......]
06:03:47 <Rui> have a prog to get the head of the board (the nulls) and check if there is any open spot
06:03:55 <Rui> if there is, the game continues
06:04:00 <quicksilver> Peaker: because it's hard to construct an example where they are, which doesn't also assume other things the class hasn't been taught.
06:04:11 <Rui> if it was rows, id have to get the head of every list, and then run in to check if its vacant
06:04:20 <olsner> meh, cabal-install wants to reinstall the 'containers' library with base-3 when I try to install 'parallel'
06:04:32 <Peaker> quicksilver: then they should just get these lists as input, and manipulate them to their representation of choice at input time
06:04:50 <Rui> if it was rows... [[Null,X,....],[Null,....],[Null,...],[Null,....]] id have to check every list
06:04:57 <Rui> instead of checking one list
06:05:07 <Peaker> Rui: map head columns  is an easy transformation though
06:05:33 <quicksilver> Peaker: lists are the easiest representation to teach and I would teach them first.
06:05:43 <Rui> well, i did only start learning haskell 2 months ago -.-
06:05:46 <Rui> so i wouldnt think of that
06:05:51 <quicksilver> arrays, maps and sequences are all substantially more fiddly to use.
06:06:15 <quicksilver> teaching inevitably involves choosing a sequence to expose subjects in and making compromises.
06:06:17 * EvilTerran doesn't see the problem with just teaching the list manipulations through fairly abstract problems
06:06:20 <Peaker> quicksilver: Well, I agreed with you - just saying that instead of forcing a bad representation on the students, he can force badly represented input, that they can convert to a good representation, and still learn all of the useful transformations, as well as the "right" way to do things
06:06:27 <EvilTerran> "write a function transpose :: [[a]] -> [[a]]"
06:06:32 <EvilTerran> or whatever
06:06:36 <quicksilver> EvilTerran: the problem is that fairly abstract problems are entirely unmotivating.
06:06:43 <EvilTerran> not entirely
06:06:48 <EvilTerran> lots of people do sudoku for fun
06:06:51 <quicksilver> EvilTerran: many students will then not be remotely interested and not do any work.
06:06:58 <quicksilver> EvilTerran: entirely unmotivating to many students.
06:07:00 <vixey> quicksilver: do you want to hear my story about (how badly it went wrong) parsing?
06:07:02 <Rui> like
06:07:03 <EvilTerran> meh
06:07:05 <Rui> i used isFull :: Board -> Bool
06:07:05 <quicksilver> more than half, in every class I've taught.
06:07:05 <Rui> isFull (x:xs) = (length filteredList) == 0
06:07:05 <Rui>                      where filteredList = filter (==Null) x
06:07:15 <Rui> grabs the head of the list of rows, and checks if its full
06:07:28 * EvilTerran prefers abstract problems, because they tend to be less contrived and/or waffley
06:07:28 <quicksilver> EvilTerran: you can say 'meh' and dismiss these people if you like. But teachers have a responsibility to teach the students they actually have.
06:07:32 <EvilTerran> but i'm weird like that
06:07:36 <quicksilver> not the ones they might choose.
06:07:46 <quicksilver> statistically, you are weird, yes :)
06:07:52 <quicksilver> in the context of this channel you probably aren't.
06:08:00 <quicksilver> vixey: sure
06:08:25 <luite_> Rui: usually, a length xs == 0 should be replaced by null xs
06:08:42 <Rui> the Null is a sign im using
06:08:48 <olsner> , or pattern matching against []
06:08:49 <EvilTerran> Rui, not Null, null
06:08:51 <EvilTerran> ?src null
06:08:51 <lambdabot> null []     = True
06:08:51 <lambdabot> null (_:_)  = False
06:08:54 <lunabot>  luna: Not in scope: `pattern'
06:09:01 <luite_> Rui: null xs tests whether a list is empty, without traversing the whole list if it's not
06:09:04 <olsner> lunabot--
06:09:08 <Peaker> Rui: btw:  isFull = null . filter (==Null) . head   :-)  (Take the head row, apply   filter (==Null)   on it, and then check if it is null [empty])
06:09:08 <Rui> Null,X,O... i need that Null to display the graphical image after
06:09:23 <Peaker> EvilTerran: he has his own Null instead of a Maybe PIece
06:09:33 <mpwd> ?src all
06:09:34 <lambdabot> all p =  and . map p
06:10:01 <vixey> quicksilver, so I started to find a PEG library but compiling frisby makes GHC segfault, but then I looked Shunting Yard algorthim.. it turned out to actually not be a totally correct parser. so then I just gave in a wrote it out with ReadP, when I finished /that/, it has some subtle bug with brackts!
06:10:03 <mpwd> Hmm... I don't like that
06:10:18 <mpwd> ?src and
06:10:18 <lambdabot> and   =  foldr (&&) True
06:10:44 <vixey> so every thing I tried went wrong :p
06:10:55 <quicksilver> heh.
06:11:03 <mpwd> > all even [1..]
06:11:04 <lambdabot>   False
06:11:08 <quicksilver> should have used polyparse ;)
06:11:17 <mpwd> Yet it should be scanning every integer?
06:11:19 <Peaker> Rui: all (/=Null)  might also be what you want
06:11:22 <mpwd> I'm very confused
06:11:43 <Axman6> mpwd: what's the [roblem?
06:11:43 <EvilTerran> mpwd, no, (&&) short-circuits when its left-hand-side is false
06:11:47 <Axman6> problem even
06:11:54 <mpwd> Axman6: I want to use all on a list
06:11:54 <Axman6> @src (&&)
06:11:54 <lambdabot> True  && x = x
06:11:54 <lambdabot> False && _ = False
06:11:54 <Peaker> Rui: instead of  null . filter (==Null)
06:11:55 <EvilTerran> > False && undefined
06:11:56 <lambdabot>   False
06:12:06 <Peaker> > True && undefined
06:12:07 <lambdabot>   * Exception: Prelude.undefined
06:12:11 <EvilTerran> > all (True : False : undefined)
06:12:12 <lambdabot>   Couldn't match expected type `a -> Bool'
06:12:18 <EvilTerran> > and (True : False : undefined)
06:12:20 <lambdabot>   False
06:12:21 <mpwd> Axman6: Erm, all on a set, rather
06:12:25 <EvilTerran> > and (True : True : undefined)
06:12:26 <lambdabot>   * Exception: Prelude.undefined
06:12:32 <Axman6> mpwd: so, all (==Null)?
06:12:54 <Peaker> > and (True : True : undefined : False : [])
06:12:55 <lambdabot>   * Exception: Prelude.undefined
06:13:01 <Peaker> using unamb trickery - this could be False :-)
06:13:30 <mpwd> Axman6: More like "all even Set.fromList [1..]" or something like that
06:13:48 <Rui> instead of isFull :: Board -> Bool
06:13:49 <Rui> isFull (x:xs) = (length filteredList) == 0
06:13:49 <Rui>                      where filteredList = filter (==Null) x
06:13:55 <Rui> i can do isFull l = all /= Null ?
06:14:01 <vixey> you can implement unamb as a pure function by the way, if you use a Monad
06:19:08 <Peaker> @pl isFull rows = all (/=Null) (head rows)
06:19:08 <lambdabot> isFull = all (Null /=) . head
06:19:36 <vixey> nothing = (== Nothing)
06:19:45 <vixey> something = not . nothing
06:19:52 <vixey> isFull = all something . head
06:22:50 <pumpkin> :t nothing
06:22:51 <lambdabot> Not in scope: `nothing'
06:22:54 <pumpkin> fail
06:22:59 <mpwd> I wish Set had an "all"
06:23:17 <mpwd> because I would love some short-circuiting
06:23:30 <pumpkin> @src all
06:23:31 <lambdabot> all p =  and . map p
06:23:46 <pumpkin> it doesn't short circuit for lists?
06:23:58 <pumpkin> @src any
06:23:58 <lambdabot> any p =  or . map p
06:24:05 <pumpkin> @src and
06:24:05 <lambdabot> and   =  foldr (&&) True
06:24:27 <mpwd> pumpkin: I'm pretty sure it doesn't
06:24:33 <pumpkin> > and [False, undefined]
06:24:34 <lambdabot>   False
06:24:36 <pumpkin> :o
06:24:51 <pumpkin> > or [True, False, undefined]
06:24:52 <lambdabot>   True
06:24:57 <pumpkin> o.O
06:24:57 <mpwd> pumpkin: Yeah, but I'm doing a lot of intersections and complementations
06:25:10 <pumpkin> yeah, just surprised that it's short circuiting there
06:25:38 <pumpkin> > all (even . (^2)) [2,4,6,undefined]
06:25:39 <lambdabot>   * Exception: Prelude.undefined
06:25:48 <pumpkin> > any (even . (^2)) [2,4,6,undefined]
06:25:49 <lambdabot>   True
06:25:54 <mpwd> pumpkin: if I wrote it, I'd make it short circuit
06:26:05 <mpwd> I wonder if the source lies
06:26:35 <pumpkin> > foldr (&&) True [False, undefined]
06:26:36 <lambdabot>   False
06:26:49 <pumpkin> > False && undefined
06:26:50 <lambdabot>   False
06:26:52 <pumpkin> guess not :)
06:26:55 <vixey> lol
06:27:03 <vixey> @src (&&)
06:27:03 <lambdabot> True  && x = x
06:27:03 <lambdabot> False && _ = False
06:27:20 <pumpkin> that would've saved me several minutes of unneeded investigation :P
06:27:21 <pumpkin> thanks :P
06:27:32 <mpwd> pumpkin: hehe, me too
06:27:40 <mpwd> thanks #haskell!
06:30:33 <vixey> you know how
06:30:38 <vixey> > undefined && False
06:30:39 <lambdabot>   * Exception: Prelude.undefined
06:30:41 <vixey> should really be False
06:31:04 <vixey> why don't they allow True  && x = x ; False && _ = False ; _ && False = False patterns
06:31:39 <pumpkin> that would be nice
06:31:44 <Olathe> Because to match the first two patterns, it explodes.
06:31:59 <pumpkin> omg explosion
06:32:08 <vixey> Olathe, but I mean a change of computation slightly
06:32:22 <Olathe> > let zAnd True x = x; zAnd False _ = False; zAnd _ False = False in zAnd undefined False
06:32:23 <lambdabot>   mueval: Prelude.read: no parse
06:32:23 <lambdabot>  mueval: UnknownError "GHC reported errors a...
06:32:36 <vixey> maybe you could even make the full    T & T = T ; T & F = F ; F & T = F ; F & F = F   completely lazy
06:33:17 <Olathe> > let zAnd True x = x; zAnd False _ = False; zAnd _ False = False in zAnd False undefined
06:33:18 <lambdabot>   mueval: Prelude.read: no parse
06:33:18 <lambdabot>  mueval: UnknownError "GHC reported errors a...
06:33:42 <Olathe> > let zAnd True x = x; zAnd False _ = False; zAnd _ False = False in zAnd
06:33:43 <lambdabot>       Overlapping instances for Show (Bool -> Bool -> Bool)
06:33:43 <lambdabot>        arising fr...
06:33:53 <Olathe> > let zAnd True x = x; zAnd False _ = False; zAnd _ False = False in zAnd False False
06:33:55 <lambdabot>   mueval: Prelude.read: no parse
06:33:55 <lambdabot>  mueval: UnknownError "GHC reported errors a...
06:34:02 <Olathe> > let zAnd True x = x; zAnd False _ = False; zAnd _ False = False in zAnd False
06:34:03 <lambdabot>       Overlapping instances for Show (Bool -> Bool)
06:34:03 <lambdabot>        arising from a use...
06:34:14 <Olathe> Hmm...
06:34:38 <vixey> Olathe, I'm thinking about a modification of the language though so it wont do it already
06:35:18 <Olathe> Ahh.
06:35:32 <adrian> I there some package with different sorting algorithms somewhere?
06:35:42 <adrian> Something like Data.List.Sort
06:37:25 <quicksilver> not aware of any package with different sorting algorithms.
06:37:35 <adrian> We should make one
06:37:49 <Olathe> If you have merge, I have merge sort.
06:37:52 <adrian> the standard sort is not very fast, and quite ram-hungry
06:37:57 <quicksilver> The classical ones are almost all inherently mutational; efficient pure sorts are rather different
06:38:16 <quicksilver> the standard one is merge, and as far as I know, it's fine.
06:38:40 <adrian> I could beat it on a random list with a mergesort of my own
06:38:44 <Olathe> According to some article, it's not merge sort.
06:38:52 <adrian> it is mergesort in ghc
06:39:06 <vixey> what uses of seq are there?
06:39:15 <vixey> I know the one about summing a huge list
06:39:17 <vixey> but any others?
06:39:19 <adrian> and quicksort is obviously much quicker, if you risk O(n^2) worst cases
06:39:24 <vixey> (or bang patterns etc)
06:39:39 <adrian> and then there is introsort
06:39:43 <quicksilver> adrian: quicksort requires ugly mutable array stuff though.
06:40:23 <Axman6> quicksilver: what about al those quicksort algorithms i've seen written in haskell then?
06:40:24 <quicksilver> adrian: if you can beat the system's merge sort with your own merge sort then something is wrong.
06:40:29 <quicksilver> Axman6: they're not quicksort.
06:40:44 <Axman6> how're they not?
06:40:44 <quicksilver> Axman6: they're something like an executable proof that quicksort is correct.
06:40:50 <Olathe> @let merge [] ys = ys; merge xs [] = xs; merge xxs@(x:xs) yys@(y:ys) = if x <= y then x:merge xs yys else y merge xxs yys
06:40:50 <Peaker> you can use quicksort until   (some_constant * mergeSort) time passes, then if its not done, switch to merge sort :-)
06:40:51 <lambdabot>  <local>:13:101:
06:40:51 <lambdabot>      Occurs check: cannot construct the infinite type:
06:40:51 <lambdabot>      ...
06:40:54 <Axman6> heh
06:40:59 <pumpkin> they always take the pivot from the front of the list?
06:41:03 <quicksilver> quicksort is a very specific mutational algorithm.
06:41:10 <Peaker> then you get the worst-case of merge sort, with a slightly worse average time than quicksort :)
06:41:17 <quicksilver> the partitioning is done in-place.
06:41:19 <Axman6> Peaker: y : merge///
06:41:22 <Axman6> ...*
06:41:26 <Peaker> Axman6: what?
06:41:50 <adrian> http://hpaste.org/13403
06:41:50 <Axman6> oh sorry, that was Olathe, line moved while i was reading
06:41:52 <Olathe> -- let merge [] ys = ys; merge xs [] = xs; merge xxs@(x:xs) yys@(y:ys) = if x <= y then x:merge xs yys else y:merge xxs yys
06:41:54 <Olathe> There.
06:41:58 <Olathe> So...
06:42:21 <Axman6> :t merge
06:42:21 <Rui> i was wanting to write a program that receives a list of lists and a number, and goes to that number of the list and "drops" a coin into that new list
06:42:22 <lambdabot> forall t. (Ord t) => [t] -> [t] -> [t]
06:42:27 <Rui> nth 1 f (x:xs) = f x:xs ; nth n f (x:xs) = x:nth (n-1) f xs
06:42:28 <adrian> quicksort takes 4 seconds, my mergesort 7, Data.List.sort 10
06:42:41 <Olathe> > let mergeSort xs = foldb merge [] xs in mergeSort [1, 5, 7, 1, 11, 3, 2]
06:42:43 <lambdabot>       No instance for (Num [t])
06:42:43 <lambdabot>        arising from the literal `1' at <inter...
06:42:44 <Rui> but that just finds the column corresponding to the number, and adds the coin to the top of the list
06:42:58 <Rui> but i need it to drop the the very bottom of the list
06:43:00 <Olathe> > let mergeSort xs = foldb merge [] xs in mergeSort
06:43:01 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
06:43:01 <lambdabot>        arising from a use...
06:43:45 <Axman6> :t foldb
06:43:46 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
06:44:05 <pumpkin> foldb? :o
06:44:08 <adrian> also, my quicksort and my mergesort work with 20.000.000 ints on my machine, whereas List.sort eats too much ram and starts swapping
06:44:12 <Axman6> > foldb (/) 1 [1..5]
06:44:13 <lambdabot>   7.5
06:44:25 <quicksilver> adrian: compiled with what options?
06:44:28 <adrian> -O2
06:44:30 <Axman6> > foldb (/) 1 [1..10]
06:44:31 <lambdabot>   1.2857142857142858
06:44:43 <pumpkin> Axman6: :o
06:44:45 <Axman6> > foldr (/) 1 [1..10]
06:44:47 <lambdabot>   0.24609375
06:44:54 <Axman6> > foldl (/) 1 [1..10]
06:44:55 <lambdabot>   2.7557319223985894e-7
06:45:10 <Axman6> wth does foldb do
06:45:15 <adrian> @src foldb
06:45:15 <lambdabot> Source not found. That's something I cannot allow to happen.
06:45:21 <quicksilver> adrian: you should post that on -cafe
06:45:28 <adrian> I will
06:46:06 <pumpkin> omg mysterious fold operation Axman6 made up
06:46:25 <Axman6> i swear it wasn't me!
06:46:31 <pumpkin> we know it
06:46:32 <luite> how should I convert a [[Int]] to a Ptr (Ptr CInt), in  way that makes sure that the memory is properly deallocated when the variable is not needed anymore?
06:46:37 <pumpkin> you're trying to corrupt us with your heathen folds
06:47:41 <quicksilver> adrian: Hmm. For me it stack overflows if I use List.sort
06:48:09 <adrian> Another argument for adrian-sort :D
06:48:15 <pumpkin> o.O
06:48:27 <Axman6> > foldb f x [a,b,c]
06:48:29 <lambdabot>   f x (f (f a b) c)
06:48:43 <Axman6> > foldb f x [a,b,c,d]
06:48:44 <lambdabot>   f x (f (f a b) (f c d))
06:48:50 <Axman6> wtf is that!
06:48:59 <pumpkin> lol
06:49:13 <quicksilver> binary partition fold
06:49:14 <Axman6> > foldb f x [1..8]
06:49:15 <lambdabot>   f x (f (f (f 1 2) (f 3 4)) (f (f 5 6) (f 7 8)))
06:49:25 <quicksilver> IIRC, dph uses things like that.
06:49:25 <Olathe> Ah hah !
06:49:31 <pumpkin> > foldb (+) 0 [1..8] :: Expr
06:49:32 <lambdabot>   0 + (1 + 2 + (3 + 4) + (5 + 6 + (7 + 8)))
06:49:43 <quicksilver> adrian: I can fix the stack overflow by forcing the list first.
06:49:44 <pumpkin> looks interesting
06:49:51 <Olathe> > let mergeSort xs = foldb merge [].map (:[]) $ xs in mergeSort [1, 3, 5, 11, 2, 4, 9, 8]
06:49:52 <quicksilver> adrian: something to do with the interleaved random calls I feel
06:49:53 <lambdabot>   [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
06:49:55 <Olathe> Hmm...
06:50:00 <Olathe> Not what I was hoping for.
06:50:09 <idnar> haha
06:50:19 <pumpkin> @hoogle foldb
06:50:19 <lambdabot> No results found
06:50:23 <pumpkin> so someone defined it?
06:50:45 <Olathe> > merge [2] [1, 3, 5]
06:50:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:50:51 <Olathe> No wonder.
06:51:39 <Olathe> @let merge [] ys = ys; merge xs [] = xs; merge xxs@(x:xs) yys@(y:ys) = if x <= y then x:merge xs yys else y:merge xxs ys
06:51:40 <lambdabot>  Defined.
06:51:47 <Axman6> :t merge2
06:51:48 <lambdabot> Not in scope: `merge2'
06:51:53 <Axman6> ok, it's not there anymore
06:52:07 <Olathe> @let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs))
06:52:09 <lambdabot>  Defined.
06:52:22 <Olathe> > let mergeSort xs = foldb merge [].map (:[]) $ xs in mergeSort [1, 3, 5, 11, 2, 4, 9, 8]
06:52:23 <lambdabot>   [1,2,3,4,5,8,9,11]
06:52:27 <Olathe> There
06:52:34 <Olathe> A proper merge sort.
06:52:53 <Axman6> i don't really like the map (:[]) though
06:53:04 <idnar> now do shell sort
06:53:07 <Axman6> monkeys should only write code, not be in it
06:53:07 <Olathe> Well, merge takes two lists, so it needs it.
06:53:10 <vixey> @let box = map return
06:53:11 <lambdabot>  Defined.
06:53:13 <Olathe> Heheh
06:53:24 <vixey> > box [1..11]
06:53:25 <lambdabot>       No instance for (Show (m t))
06:53:25 <lambdabot>        arising from a use of `show' at <in...
06:53:31 <vixey> aw...
06:53:36 <vixey> > box [1..11] :: [[Integer]]
06:53:36 <Olathe> foldb basically folds in a recursive manner.
06:53:37 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11]]
06:54:03 <Axman6> @hoogle foldb
06:54:04 <lambdabot> No results found
06:54:16 <Olathe> > showFold foldr
06:54:18 <lambdabot>   Not in scope: `showFold'
06:54:27 <Olathe> > showfold foldr
06:54:29 <lambdabot>   "fold (+) 0 [1..10] = (1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)...
06:54:32 <Olathe> > showfold foldb
06:54:34 <lambdabot>   "fold (+) 0 [1..10] = (0 + ((((1 + 2) + (3 + 4)) + ((5 + 6) + (7 + 8))) + (...
06:54:45 <Olathe> Which works nice for the merge sort.
06:55:41 <Axman6> :t box
06:55:42 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m a]
06:57:09 <idnar> @let box2 = fmap return
06:57:10 <lambdabot>  Defined.
06:57:18 <idnar> @type box2
06:57:19 <lambdabot> forall (f :: * -> *) a (m :: * -> *). (Monad m, Functor f) => f a -> f (m a)
06:59:20 <Olathe> Is there a monad where (>>=) x f = return (f x) ?
07:00:20 <int-e> then f x = return x >>= f = f (return x), so x = return x.
07:00:20 <dmwit> Olathe: Identity, maybe
07:00:50 <int-e> oh. missed one
07:00:53 <dmhouse> If you want return to be in that same monad then you'd need m a = a for the types to make sense.
07:01:08 <int-e> data Nil; instance Monad Nil where return _ = Nil; _ >>= _ = Nil
07:01:08 <dmwit> int-e: That first equation doesn't look right.
07:01:19 <int-e> dmwit: it's a monad law
07:01:56 <dmwit> ah, yeah
07:02:02 <mauke> data Nil _;
07:02:12 <int-e> mauke: thanks
07:02:13 <Tell360> There are Chinese-speaking it?
07:02:25 <pumpkin> Tell360: ?
07:02:36 <int-e> data Nil a = Nil -- there.
07:02:38 <cizra> pumpkin: He's probably asking if anyone here speaks Chinese.
07:03:23 <dmwit> Tell360: Not here. =/
07:03:24 <idnar> int-e: is that a legal data definition?
07:03:32 <dmwit> idnar: certainly
07:03:35 <Axman6> @seen lambdabot
07:03:35 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
07:03:35 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, ##freebsd, #gentoo-uy, #gentoo-haskell, #
07:03:35 <lambdabot> friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
07:03:37 <Tell360> pumpkin: There are problems to ask, but do not know English.
07:03:58 <idnar> holy hell
07:04:08 <pumpkin> is there a #haskell.zh ?
07:04:13 <dmwit> cz?
07:04:18 <pumpkin> czech republic
07:04:28 <mauke> preflex: ? .zh
07:04:28 <preflex>  factoid not found
07:04:36 <pumpkin> .cn is china
07:04:41 <BMeph> China (People's Republic)
07:04:45 <pumpkin> but .zh seems more correct for the language
07:05:35 <pumpkin> Tell360: sorry, it seems that no one speaks chinese :(
07:05:37 <Lemmih> I don't think anyone would mind if lambdabot left #jhc seeing as there's no-one there.
07:06:23 <vixey> can you build [jl]hc with ghc 6.10?
07:06:32 <Tell360> pumpkin: Thank you, your well-tips.
07:06:47 <pumpkin> :)
07:06:50 <Peaker> hmm, how do I get O(1)  (replicate n i ++)?  DList does not seem to have replicate, and using fromList will not be O(1)
07:06:52 <Lemmih> vixey: Yes, lhc builds with ghc-6.10.
07:07:31 <int-e> Peaker: use [(a,Int)] instead of [a]?
07:07:43 <Olathe> @src replicate
07:07:44 <lambdabot> replicate n x = take n (repeat x)
07:08:09 <quicksilver> Peaker: in what sense can replicate n i ever be O(1) ?
07:08:13 <Olathe> > replicate 5 "hello"
07:08:14 <quicksilver> it constructs n cons cells
07:08:14 <lambdabot>   ["hello","hello","hello","hello","hello"]
07:08:19 <quicksilver> (even in a DList representation)
07:08:45 <Olathe> @hoogle a -> [b] -> [b]
07:08:46 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:08:46 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
07:08:46 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
07:08:53 <Peaker> quicksilver: hmm.. I guess its not the O() that bothers me, true,  just the extra copying of the replicate list which may be large
07:08:56 <int-e> Peaker: You need a O(1) replicate n i, so the results of replicate will have to be encoded in constant space (in addition to its two arguments)
07:09:08 <Peaker> quicksilver: (constant factor)
07:09:15 <Peaker> quicksilver: if I gave replicate the tail to put in the last cons cell, it could avoid that copying
07:09:34 <vixey> Peaker, but it only goes i times then it's null
07:09:46 <pumpkin> will it copy if that replicate list isn't used anywhere else? it seems like it could detect that, and just modify the underlying list?
07:09:46 <int-e> Peaker: iterate (a:) xs !! n  wouldn't copy
07:10:03 <quicksilver> take n (cycle [x]) only uses one cell, in a sense
07:10:21 <quicksilver> but it uses space to store the counter
07:10:24 <Peaker> int-e: yeah, that's a better way to implement   (replicate n a) ++ xs
07:10:41 <Peaker> quicksilver: cycle [x] -> repeat x
07:10:45 <Olathe> @unsrc \n x -> take n (cycle x)
07:10:46 <lambdabot> Source not found. Are you on drugs?
07:11:08 <idnar> haha
07:12:20 <int-e> Peaker: it's not a good way really - it builds a rather large thunk instead, I think
07:12:24 <Peaker> int-e: Basically, anything that results in a finite list could instead of returning a finite list, take an argument of what "next" list to attach it to (e.g ShowS)
07:12:42 * vixey great... ghc: panic! (the 'impossible' happened)  (GHC version 6.11.20081031 for i386-unknown-linux):applyTypeToArgs
07:12:47 <Peaker> int-e: And iiuc, that's what DList does
07:12:59 <int-e> Peaker: right
07:13:28 <Peaker> int-e: but a DList replicate, which is built from take/repeat cannot be built on top of DList, because it hasn't got take
07:13:40 <Peaker> int-e: or can it? I am not sure
07:13:41 <int-e> Peaker: really, replicate n a ++ xs  isn't bad
07:13:59 <vixey> :t take ?n . fix ?dl
07:14:00 <lambdabot> forall a a1. (?dl::(a1 -> [a]) -> a1 -> [a], ?n::Int) => a1 -> [a]
07:14:06 <Peaker> int-e: I'm just interested if there's a way to get an "efficient" replicate with DLists
07:14:06 <int-e> Peaker: the 'replicate n a' list is produced while (++) consumes it.
07:14:07 <pumpkin> int-e: can it not do what I asked above?
07:14:12 <Peaker> efficient replicate++ that is
07:14:31 <vixey> :t fix
07:14:32 <lambdabot> forall a. (a -> a) -> a
07:14:40 <Peaker> int-e: I know, its the same O(), but an extra factor/copying
07:14:43 <vixey> :t take ?n (fix ?dl)
07:14:44 <lambdabot> forall a. (?dl::[a] -> [a], ?n::Int) => [a]
07:15:36 <Olathe> @type round ?a
07:15:38 <lambdabot> forall a b. (Integral b, RealFrac a, ?a::a) => b
07:15:52 <int-e> Peaker: so hard-code it.  foo a n xs = go n where go 0 = xs; go n = a : go (n-1)
07:16:29 <Peaker> int-e: for lists, sure. I am wondering about the possibility to do it with DLists
07:16:35 <vixey> > take 30 (fix ("foo"++))
07:16:36 <lambdabot>   "foofoofoofoofoofoofoofoofoofoo"
07:16:44 <Peaker> int-e: where things are generally tuned to avoid append-related copying
07:17:39 <int-e> Peaker: DL (foo a n)
07:17:52 <vixey> > (foldr (.) id (replicate 3 ("foo"++))) ""
07:17:54 <lambdabot>   "foofoofoo"
07:18:00 <int-e> the constructor is exported, you may just as well use it *shrugs*
07:18:00 <pumpkin> lol
07:18:14 <Peaker> int-e: it is? I thought it wasn't because of: http://hackage.haskell.org/packages/archive/dlist/0.3/doc/html/Data-DList.html
07:18:40 <int-e> Peaker: hmm
07:18:50 <Axman6> :t let foo = \x y -> foo in foo
07:18:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t2 -> t
07:18:52 <lambdabot>     Probable cause: `foo' is applied to too few arguments
07:18:52 <lambdabot>     In the expression: foo
07:19:02 * int-e was looking at http://code.haskell.org/~dons/code/dlist/Data/DList.hs
07:19:10 <Axman6> :t let foo = \x -> foo in foo
07:19:11 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
07:19:11 <lambdabot>     Probable cause: `foo' is applied to too few arguments
07:19:11 <lambdabot>     In the expression: foo
07:19:19 <Axman6> :t let foo = \x -> foo in foo 1
07:19:21 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
07:19:21 <lambdabot>     Probable cause: `foo' is applied to too few arguments
07:19:21 <lambdabot>     In the expression: foo
07:19:24 <Axman6> bah
07:19:47 <int-e> Peaker: which, interestingly, claims that DList is abstract, but exports the constructor anyway
07:19:50 <BMeph> A-ha! It's country vs. language codes, that's why there are overlapping instances there. :)
07:20:12 <ik> What's an infinite type?
07:20:25 <Peaker> int-e: bug, then
07:20:28 <maltem> ik: t -> t -> t -> t -> ...
07:20:39 <mauke> ik: a recursive type, basically
07:20:49 <ik> ok
07:20:50 <pumpkin> BMeph: ?
07:21:01 <mauke> like a list whose elements are lists of that type
07:21:10 <ik> ah
07:21:24 <mauke> if haskell had syntax for that, it might look like a@[a]
07:21:41 <BMeph> pumpkin: The "cn" vs. "zh" issue. The first is a country code (kind of...), and the second is a language code.
07:21:41 <guenni> hi, is there an editor that can "jump" to a definition? or highlight it?
07:21:56 <pumpkin> BMeph: yup :)
07:21:59 <pumpkin> that's what I said :P
07:22:03 <int-e> Peaker: why are you looking at 0.3? http://hackage.haskell.org/packages/archive/dlist/latest/doc/html/Data-DList.html
07:22:10 <ik> guenni: I'm sure vim /can/ if you poke it the right way
07:22:15 <ik> guenni: the question is actually getting it to do it
07:22:15 <Peaker> int-e: google :)
07:22:26 <int-e> don't google ;)
07:22:29 <Peaker> int-e: a google oops
07:22:29 <BMeph> pumpkin: Ah, okay; I just got into work, so I didn't see what else was involved. :)
07:22:34 <pumpkin> BMeph: !!!!
07:22:36 <maltem> guenni: ghci can generate ctags files to be used by vim or emacs
07:22:38 <Philonous> @type let f (x:xy) = (x,f xs) in f
07:22:39 <lambdabot> Not in scope: `xs'
07:22:42 <pumpkin> BMeph: I am mortally offended, and challenge you to a duel now
07:22:46 <Philonous> @type let f (x:xs) = (x,f xs) in f
07:22:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t1, t)
07:22:48 <lambdabot>       Expected type: t
07:22:48 <lambdabot>       Inferred type: (t1, t)
07:22:49 <Peaker> int-e: I guess exposing the constructor was a bug *fix* :)
07:22:52 <ik> pumpkin: are you andrew jackson in disguise?
07:22:54 <maltem> guenni: possibly other editors, too
07:22:55 <ik> pumpkin: I knew he wasn't dead :(
07:22:58 <Peaker> int-e: now things like that can be created efficiently :)
07:23:07 <guenni> ik: I was afraid you would say that
07:23:08 <pumpkin> ik: shh don't ask in public
07:23:18 <ik> guenni: see what mauke said, it's a better idea
07:23:37 <ik> pumpkin: can I have tupac's phone number?
07:23:38 <mauke> ik: I didn't say it, I only thought it
07:23:43 <ski_> mm_freak : sure
07:23:44 <ik> you considered it!
07:23:55 <mauke> sure, but that doesn't count
07:23:59 <pumpkin> ik: I'd give it to you, but you need a special phone to make interuniversal calls
07:24:04 <ik> And really, I have no way of knowing if you said it aloud or not.  I may as well assume!
07:24:12 <mauke> ok then
07:24:15 <guenni> ik: I can't see it, I just joined the channel
07:24:18 <BMeph> pumpkin: It's kind of crappy that other sections of the "non-People's" Republic of China that aren't Taiwan get ignored. That's just not nice.
07:24:28 <mauke> guenni: try "maltem"
07:24:33 <ik> oh!
07:24:38 <ik> I missed that somehow.
07:24:45 <ik> Sorry maltem :)
07:24:53 <maltem> eh?
07:25:01 <ik> I misidentified you
07:25:09 <maltem> ah
07:25:29 <maltem> who should I have been, then?
07:25:33 <guenni> the ctags, don't they become invalid once the file is edited?
07:25:34 <pumpkin> BMeph: you mean like macau?
07:26:22 <maltem> (nevermind, I figured :)
07:26:37 * mauke is now known as maltem
07:27:06 <maltem> guenni: yeah they do, that's why I usually don't bother with them, in spite of their usefulness
07:30:24 <guenni> so on the "IDE" front nothing new?
07:30:35 <vixey> you have to actually write one
07:30:52 <chylli> I just want to get the contents of one url but I didn't find one function like getContents url. must I write one by myself ?
07:31:14 <vixey> chylli, why don't you look on hackage for curl bindigs or similar
07:31:15 <pumpkin> as raganwald says, a feature that you need an IDE for is a shortocoming of your language ;)
07:31:26 <pumpkin> shortcoming
07:32:06 <Saizan> chylli: there's one like that in tagsoup, it comes with an huge warning though
07:32:38 <chylli> vixey: good idea. thanks. Saizan, ok let me try.
07:33:12 <quicksilver> I think the curl binding is a good bet.
07:33:29 <maltem> guenni: oh yi has the functionality in theory, via the ghc api, but they're going to switch the api frontend, so nothing stable to await there right now
07:34:28 <guenni> really strange when you think about, great language but no good tools for a long time now
07:34:29 <Saizan> "frontend"? scion instead of shim?
07:34:37 <pumpkin> > epsilon
07:34:38 <lambdabot>   Not in scope: `epsilon'
07:34:46 <Saizan> > exp 1
07:34:47 <lambdabot>   2.718281828459045
07:35:02 <Peaker> > exp 1 :: CReal
07:35:04 <lambdabot>   2.7182818284590452353602874713526624977572
07:35:06 <Olathe> epsilon is a bad idea.
07:35:12 <EvilTerran> chylli, Network.HTTP.Simple is pretty straightforward
07:35:18 <Peaker> why is CReal that specific amount of digits?
07:35:21 <Peaker> or is its Show truncating?
07:35:29 <quicksilver> guenni: correction, no really great tools.
07:35:39 <quicksilver> guenni: emacs is a good tool, and so is vim, and that's what people use
07:35:40 <pumpkin> Peaker: show on CReals defaults to 30 digits I think
07:35:50 <pumpkin> > showCReal 100 $ exp 1
07:35:51 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
07:35:54 <Olathe> > showCReal 5000 (exp 1)
07:35:57 <guenni> hi quicksilver
07:36:04 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
07:36:04 <Peaker> @src exp
07:36:05 <lambdabot> Source not found. I am sorry.
07:36:16 <chylli> EvilTerran: yeah, that's what I'm looking for!!
07:36:18 <Peaker> is exp in the Num class, and computed infinitely for CReal?
07:36:30 <Peaker> @type exp
07:36:31 <lambdabot> forall a. (Floating a) => a -> a
07:36:36 <Peaker> s/Num/Floating
07:36:40 <pumpkin> > exp (1 :+ 2)
07:36:41 <EvilTerran> shame MaybeT doesn't come as standard, it'd make using Network.HTTP.Simple much nicer
07:36:41 <lambdabot>   (-1.1312043837568135) :+ 2.4717266720048188
07:37:22 <pumpkin> > exp (0 :+ pi)
07:37:24 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
07:37:27 <quicksilver> Peaker: Yes. CReal has an arbitrary precision implementation of exp.
07:37:40 <Olathe> > exp (0::CReal :+ pi)
07:37:42 <lambdabot>   Not in scope: type constructor or class `:+'
07:37:45 <quicksilver> Peaker: and pi, and sin, and so on.
07:37:48 <Olathe> > exp ((0::CReal) :+ pi)
07:37:50 <lambdabot>   (-1.0) :+ 0.0
07:38:08 <EvilTerran> nice
07:38:09 <Peaker> quicksilver: what happens when some new mathematical constant of interest springs up? :)
07:38:12 <EvilTerran> ?index CReal
07:38:12 <lambdabot> bzzt
07:38:20 <Olathe> @where CReal
07:38:21 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
07:38:29 <Peaker> quicksilver: it gets added to existing classes, with a default of some specific precision?
07:38:30 <pumpkin> Data.Number.CReal
07:39:00 <pumpkin> Peaker: the show instance for CReal is just defined as showCReal 30 ?
07:39:05 <pumpkin> oh
07:39:08 <pumpkin> sorry, misunderstood
07:39:10 <EvilTerran> heh, "A tolerably efficient and possibly correct implementation of the computable
07:39:10 <EvilTerran>  reals"
07:39:10 <Olathe> You can see in the source there.
07:39:22 <quicksilver> Peaker: well the default implementation would normally be in terms of the other primitives.
07:39:28 <quicksilver> Peaker: so it would have the same precision as them
07:39:34 <Peaker> if (read . show) = id  -- showCReal violates that?
07:40:01 <Olathe> Of course.
07:40:02 <Peaker> quicksilver: assuming the constant can be defined using those other primitives
07:40:03 <quicksilver> e.g. phi = (1 + sqrt 5) / 2
07:40:07 <EvilTerran> the Show instances for floating point will violate that
07:40:13 <Peaker> quicksilver: how is pi defined?
07:40:21 <Olathe> You can see in the source.
07:40:27 <quicksilver> Peaker: the discovery of new primitives entirely independent of the others is a pretty rare event.
07:40:29 <Peaker> integral over \x -> (1-x*x) ? :)
07:40:39 <Olathe> pi = 16 * atan (fromRational (1%5))
07:40:39 <Olathe> - 4 * atan (fromRational (1%239))
07:40:41 <quicksilver> rare enough that rewriting type classes really isn't a big issue.
07:40:50 <pumpkin> can CReal compute omega?
07:41:03 <Olathe> @faq Can CReal compute omega ?
07:41:04 <lambdabot> The answer is: Yes! Haskell can do that.
07:41:04 <vixey> what do you htink
07:41:06 <pumpkin> (chaitlin's one)
07:41:09 <pumpkin> oh of course
07:43:22 <Olathe> > let pi' = 16 * atan (fromRational (1%5)) - 4 * atan (fromRational (1%239)) in (pi' :: Float, pi' :: Double)
07:43:24 <lambdabot>   Couldn't match expected type `Double' against inferred type `Float'
07:43:29 <Olathe> > let pi' = 16 * atan (fromRational (1%5)) - 4 * atan (fromRational (1%239)) in (pi' :: Float)
07:43:30 <lambdabot>   3.1415927
07:43:37 <Olathe> > pi :: Float
07:43:39 <lambdabot>   3.1415927
07:43:49 <mauke> > 355/113
07:43:51 <lambdabot>   3.1415929203539825
07:44:01 <vixey> > 356/113
07:44:03 <lambdabot>   3.150442477876106
07:44:49 <Olathe> @hoogle a -> Rational
07:44:50 <lambdabot> Prelude toRational :: Real a => a -> Rational
07:44:50 <lambdabot> Data.Time.LocalTime timeOfDayToDayFraction :: TimeOfDay -> Rational
07:44:50 <lambdabot> Data.Time.Clock getModJulianDate :: UniversalTime -> Rational
07:45:12 <Olathe> > approxRational 0.001 pi
07:45:14 <lambdabot>   0%1
07:45:18 <Olathe> > approxRational pi 0.001
07:45:20 <lambdabot>   201%64
07:46:36 <mbz> > approxRational pi 10
07:46:37 <lambdabot>   0%1
07:46:42 <pumpkin> > map (approxRational pi) (map (10**) [-1,-2..])
07:46:43 <lambdabot>   [16%5,22%7,201%64,333%106,355%113,355%113,75948%24175,100798%32085,103993%3...
07:46:56 <pumpkin> I guess I could've made that into a single map
07:47:28 <pumpkin> > map (approxRational pi . (10**)) [-1,-2..]
07:47:30 <lambdabot>   [16%5,22%7,201%64,333%106,355%113,355%113,75948%24175,100798%32085,103993%3...
07:47:44 <Twey> :t approxRational
07:47:45 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
07:49:54 <cnwdup> What happens if you request a draw which is overlapping the drawing area in X11? Is it ok if one just don't care?
07:50:22 <Peaker> > approxRational 1.23456 10
07:50:24 <lambdabot>   0%1
07:50:35 <Peaker> > approxRational 123 10
07:50:36 <lambdabot>   113%1
07:50:54 <Peaker> > approxRational 12.3 4.2
07:50:57 <lambdabot>   9%1
07:51:29 <Peaker> > approxRational 12.3 4
07:51:31 <lambdabot>   9%1
07:51:37 <int-e> > take 5 $ map (foldr (\x y -> fromIntegral (x :: Int) + if y == 0 then 0 else recip y) 0) . inits . map truncate . iterate (recip . snd . properFraction) $ pi :: [Rational]
07:51:39 <lambdabot>   [0%1,3%1,22%7,333%106,355%113]
07:52:17 <Raevel> wow, look at io go
07:52:22 <Raevel> Io> list(1,2,3) map (+1) select (<3)
07:52:23 <Raevel> ==> list(2)
07:52:51 <int-e> > filter (<3) . map (+1) $ [1..3]
07:52:53 <lambdabot>   [2]
07:54:06 <Twey> > [1, 2, 3] `flip id` map (+1) select (<3)
07:54:07 <lambdabot>   <no location info>: parse error on input `id'
07:54:11 <Twey> :<
07:54:24 <mauke> you cannot backtick expressions
07:54:24 <Raevel> boo
07:54:41 <Twey> > let to = flip id in [1, 2, 3] `to` map (+1) select (<3)
07:54:42 <lambdabot>   Not in scope: `select'
07:54:48 <Twey> > let to = flip id in [1, 2, 3] `to` map (+1) filter (<3)
07:54:48 <int-e> Raevel: no boo. what would a`a`a`a`a mean?
07:54:49 <lambdabot>   Couldn't match expected type `[a]'
07:54:59 <Twey> > let to = flip id in [1, 2, 3] `to` map (+1) . filter (<3)
07:55:00 <lambdabot>       precedence parsing error
07:55:00 <lambdabot>          cannot mix `to' [infixl 9] and `(.)' ...
07:55:01 <Raevel> int-e: that wasn't what i boo'd at
07:55:02 * Twey grumbles.
07:55:06 <Twey> I give
07:55:13 <mauke> int-e: a a (a a a)
07:55:18 <Olathe> Where is the source of Fractional online ?
07:56:06 <Raevel> anyway, i wonder how that works in io
07:56:55 <Olathe> @index approxRational
07:56:56 <lambdabot> Data.Ratio
07:57:03 <Olathe> @docs Data.Ratio
07:57:03 <int-e> Olathe: http://darcs.haskell.org/packages/base/GHC/Real.lhs ?
07:57:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
07:57:17 <mauke> preflex: calc (+ 2 2) * (7 4 -)
07:57:17 <preflex>  12
07:58:31 <quicksilver> Olathe: http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/GHC-Real.html
08:00:32 <redditbot> Simon Peyton Jones on why someone would choose Haskell for multicore work
08:00:32 <redditbot> Continuous Stream Fusion : Luke Palmer
08:00:32 <redditbot> Real World Haskell update | The Changelog
08:02:31 <cnwdup> Is there already a lifted version of (.)?
08:02:44 <quicksilver> lifted where?
08:02:55 <vixey> :t (>=>)
08:02:56 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:02:58 <vixey> like this ???
08:03:27 <cnwdup> Yep. Thank you.
08:06:53 <cnwdup> :t (.)
08:06:54 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:07:09 <cnwdup> :t flip (>=>)
08:07:10 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
08:07:18 <cnwdup> :t (<=<)
08:07:19 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
08:13:58 <mpwd> :t Data.Set.fromList
08:13:59 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
08:15:17 <mpwd> > all even [1..]
08:15:19 <lambdabot>   False
08:15:58 <mpwd> > all even $ S.toList $ S.fromList [1..]
08:15:59 <lambdabot>   /tmp/83126637437731391:70:47: Not in scope: `S.toList'/tmp/8312663743773139...
08:16:37 <pumpkin> it would be cool to have a Collection typeclass or something
08:16:45 <pumpkin> that would have toList and fromList
08:16:52 <pumpkin> that Data.Set and Map could be members of
08:17:08 <RayNbow> > all (liftM2 (||) odd even) [1..]
08:17:18 <pumpkin> although I guess they would impose Ord on the argument
08:17:23 <lambdabot>   thread killed
08:17:43 <mpwd> pumpkin:  Yeah.  Actually, I'm disappointed with those libraries
08:17:45 <pumpkin> > all (liftM2 (||) odd even) [1..10]
08:17:47 <lambdabot>   True
08:17:50 <pumpkin> mpwd: why?
08:18:36 <Raevel> @type all (liftM2 (||) odd even)
08:18:38 <lambdabot> forall a. (Integral a) => [a] -> Bool
08:18:45 <mpwd> pumpkin: Well, so as a mathematician I know that (Set a, Set b) is ismorphic to Set (a, b).  And I think you can translate back and forth in linear time
08:18:59 <mpwd> pumpkin:  But there's no "cart" in Set
08:19:19 <vixey> mpwd, you could implement it though
08:19:37 <mpwd> vixey:  Yeah, I googled it, it looks really easy
08:20:54 <mpwd> vixey:  I saw that there's a hack to get Set to be a Monad, even though it has a class restriction somehow...
08:29:08 <dmwit> (Set a, Set b) is not isomorphic to Set (a, b).
08:29:59 <quicksilver> no, it's isomorphic to Set (a+b)
08:30:38 <Peaker> ([a], [b]) is not isomorphic to [(a,b)] either?
08:30:40 <dmwit> Right.  Well, that isomorphism at least is easy to write with the Set library and the Either type.
08:30:41 <Olathe> @let capproxRational :: CReal -> Rational -> Rational; capproxRational n prec = approxRational (fromIntegral (round (n*fromRational d))%1/d) prec where d = 2*recip prec
08:30:43 <lambdabot>  Defined.
08:30:47 <dmwit> Peaker: no
08:30:57 <Peaker> dmwit: yeah, I mean why would it be?
08:31:05 <opqdonut> yeah, see (emptyset, nonemptyset)
08:31:06 <Olathe> > capproxRational pi (10**(-20))
08:31:08 <lambdabot>       No instance for (Floating Rational)
08:31:08 <lambdabot>        arising from a use of `**' a...
08:31:13 <opqdonut> the cartesian product is empty
08:31:25 <Olathe> > capproxRational pi (1%10^20)
08:31:28 <lambdabot>   21053343141%6701487259
08:31:56 <Olathe> > approxRational pi (1/10^20)
08:31:58 <lambdabot>   884279719003555%281474976710656
08:32:03 <dmwit> pumpkin: There's the Collection class in Edison.
08:32:19 <pumpkin> how does it deal with the Ord constraint on Set and Map?
08:32:42 <Olathe> > capproxRational pi (1%10^200)
08:32:45 <lambdabot>   372635949173498682109574731136224832868959750318822329502755734047930684925...
08:32:48 <Olathe> > approxRational pi (1/10^200)
08:32:51 <lambdabot>   884279719003555%281474976710656
08:33:02 <opqdonut> pumpkin: see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
08:33:04 <dmwit> ?where edison
08:33:05 <lambdabot> http://www.cs.princeton.edu/~rdockins/edison/home/
08:33:18 <opqdonut> and http://okmij.org/ftp/Haskell/RestrictedMonad.lhs
08:33:53 <Saizan> pumpkin: for something like toList/fromList you can easily use associated types or fundeps, toList :: Collection c => c -> [Elem c]
08:34:01 <dmwit> pumpkin: It just requires Ord on all collections.
08:34:13 <pumpkin> dmwit: that seems overly restrictive though
08:34:19 <dmwit> Not really.
08:34:23 <pumpkin> I could have an array of non-ord things?
08:34:33 <dmwit> List is basically the only collection you would want with unordered things.
08:35:33 <Peaker> > (1 :+ 2) > 0
08:35:35 <lambdabot>       No instance for (Ord (Complex t))
08:35:35 <lambdabot>        arising from a use of `>' at <...
08:35:45 <Peaker> dmwit: I wouldn't want a Set of Complex numbers?
08:35:59 <Peaker> (sure, I couldn't *have* one, but I might want one :-)
08:36:00 <dmwit> You can't have a Set of Complex numbers.
08:36:37 <Peaker> btw, for Set's purposes, the "deriving Ord" that could exist on Complex, would be good enough
08:37:23 <pumpkin> yeah, you could define a LameOrd for Complex
08:37:41 <dmwit> You could write a collection instance that transparently converts Complex to (Double, Double) as a Map key.
08:38:16 <opqdonut> choosable instances would be nice here
08:38:28 <opqdonut> well okay, collections are their primary use case anyway
08:38:29 <dons> spj on why you should use haskell for multicore, http://www.reddit.com/r/programming/comments/7m8pe/simon_peyton_jones_on_why_you_should_use_haskell/
08:39:50 <dons> ?users
08:39:51 <lambdabot> Maximum users seen in #haskell: 568, currently: 560 (98.6%), active: 17 (3.0%)
08:39:51 <Peaker> well, there could be LameOrd and Ord (someone find a better name for LameOrd :-)
08:40:08 <Peaker> and like virtually everything is Typeable, virtually anything that has Eq will also have LameOrd
08:40:28 <quicksilver> dons: that onruby interview proved useful in provoking an FP interest in a colleague.
08:40:30 <pumpkin> Peaker: you don't like my naming skills :(
08:40:52 <dons> quicksilver: wonderful!
08:41:07 <opqdonut> yeah, an inferred Ord instance based on the bit-pattern or so
08:41:15 <dons> quicksilver: its strange, we're just saying the same things we always say, but for some reason in an 'interview' context, people are more receptive.
08:41:26 <pumpkin> dons: do you have an overview of uvector anywhere? I was trying to find how/when to use it vs. stream-fusion. It sort of looks like one is a fusion enabled array and the other a list, but I can't really tell
08:41:35 <dons> that's right, pumpkin
08:41:42 <quicksilver> dons: the fact that an outsider is asking the questions helps, I think.
08:41:48 <dons> stream-fusion is a slightly older impl. for lists.
08:41:53 <dons> it is a drop in replacement for Data.List
08:41:56 <quicksilver> dons: and the slightly different answers from the three of you help broaden the view
08:42:00 <dons> uvector is a more aggressive version for arrays
08:42:01 <Peaker> opqdonut: well, deriving Ord works if you have just Ords in there, so  deriving LameOrd should work for basically everything
08:42:22 <dons> quicksilver: hmm. yes. the outsider questions help answer common questions/misconceptions
08:42:39 <Peaker> opqdonut: (as basically everything should have LameOrd, with same derive rules)
08:42:39 <pumpkin> dons: so is there any reason to use uvector over stream-fusion if I don't need O(1) indexing? I guess it's more space efficient too?
08:42:40 <dons> i saw one reddit comment to the effect "wow, they really emphasies practicality in that interview"
08:42:43 <dons> which is great.
08:42:50 <dons> pumpkin: do you primarily work with lists or arrays?
08:42:57 <dons> that's the question you should ask.
08:43:16 <dons> it is possible that uvector will be a bit more aggressive (== faster)
08:43:21 <pumpkin> I currently work with lists, but I'm not set in stone :P I haven't been using haskell for very long
08:43:32 <pumpkin> but I don't need !!
08:43:36 <dons> try using stream-fusion then, see if things get better
08:43:42 <pumpkin> okay
08:44:00 <pumpkin> thanks :)
08:50:51 <cads> hey, are there currently data parallel libraries in which one can write code that will scale equally well on anything between two cores, all the way up to thousands?
08:51:07 <leimy> yes
08:51:13 <leimy> but it depends on the code :-)
08:51:22 <leimy>  /problem
08:51:29 <cads> astounding
08:51:44 <leimy> but that's not new... I mean, MPI's been around a while.
08:51:52 <leimy> I don't know if there's anything like MPI for Haskell.
08:51:54 <dmwit> cads: The work is called -- wait for it, it's a really surprising name -- Data Parallel Haskell.
08:52:02 <cads> I haven't the slightest idea of how the shared memory model would fit in with thousands of cores
08:52:09 <leimy> I wouldn't do it :-)
08:52:16 <leimy> You'd want something NUMA at the least.
08:52:23 <cads> yeah
08:52:29 <dmwit> There's also NDP.
08:52:38 <leimy> hardware contention kills you ... hence Intel moving away from the traditional FSB
08:52:57 <leimy> it's a lot like what Opteron's have always had.
08:54:06 <cads> dmwit, I've heard of data parallel haskell but haven't used it
08:54:43 <cads> saw the video with SPJ explaining all of it in his excited british way
08:54:58 <cads> but I don't remember the benchmarks
08:56:35 <cads> in a lot of parallel bench marks I see, the graph actually has negative slope around 12+ cores, and i wonder if that's a failure of the programming model to do all the housekeeping efficiently, or it's the hardware not being able to supply all the cores with data
08:57:33 <leimy> possibly both :-)
08:57:34 <RayNbow> cads: 12+ cores on what kind of architecture?
08:58:33 <cads> I don't know, I see these 16 core benchmarks and I'm interested to see what processor has 16 cores, but the most recent one I saw didn't give machine specs
08:59:55 <cads> wonder if there's a way to simulate your program and get an idea of how well its performance would scale on generic multicore processors
09:00:59 <RayNbow> I guess it's fairly hard to get good simulation results
09:01:38 <pumpkin> cads: I think various sun SPARC machines have lots of cores
09:01:43 * RayNbow doesn't know if there's a good way to model cache hits/misses, for example
09:03:18 <cads> pumpkin, d'oh, of course :D
09:03:51 <cads> RayNbow, yeah, that alone is thought provoking
09:04:15 <leimy> pumpkin: you can get a SUN server that can run 32 hardware threads at once on 8 cores
09:04:25 <pumpkin> nice :)
09:04:28 <leimy> or is that 4 cores with 8 "thread units" I don't remember
09:04:36 <leimy> crappy floating point performance too :-)
09:05:24 <cads> who needs a crappy p-adic approximation to the real numbers, anyways?
09:05:31 <hcube> hi! is here anyone who's interested in H3D?
09:06:02 <cads> only cause you mention; what H3D is be?
09:06:09 <hcube> i'm currently working on ogre mesh loader
09:06:22 <pumpkin> :o
09:06:38 <leimy> cads: I've always felt that way...
09:06:50 <hcube> H3D is a wiki page, and it's about haskell based 3d applications
09:06:52 <leimy> the universe is discreet, just with infinitesimal units :-)
09:07:03 <RayNbow> yay, I still have shell access to http://www.cs.vu.nl/das3/overview.shtml :D
09:07:12 <hcube> http://www.haskell.org/haskellwiki/H3D
09:07:19 <leimy> You have shell access to an html file?
09:07:25 <pumpkin> leimy: discrete? :P
09:07:29 <pumpkin> discreet too
09:07:31 <leimy> yes
09:07:32 <leimy> sorry
09:07:37 <leimy> my sp33ling is the suck
09:07:37 <leimy> :-)
09:07:44 <cads> no, it's discrete
09:07:57 <pumpkin> well, if you think it's discrete, that's up to you
09:08:04 <cads> discreet is a 3d modelling software company
09:08:05 * RayNbow wonders if there's some MPI stuff in GHC...
09:08:19 <hcube> pfff :)
09:08:25 * leimy used to implement MPIs
09:08:28 <pumpkin> RayNbow: there is a haskell MPI thing I think, but I didn't like the look of it
09:08:29 <leimy> in a former life it seems
09:08:32 <pumpkin> I'd like a more haskellish mpi
09:08:44 <RayNbow> pumpkin: I just found something... from 2002 :p
09:08:50 <pumpkin> I think hal daumé had one
09:08:56 <pumpkin> is that the one you found?
09:09:27 <RayNbow> no, but it does link to Hal Daume's page
09:09:34 <RayNbow> http://www.cs.utah.edu/~hal/software.html
09:10:02 <pumpkin> ah yeah, he updated someone else's haskell mpi
09:10:05 <leimy> hMPI
09:10:13 <pumpkin> but yeah, I want a more haskelly one
09:10:22 <pumpkin> I put a request up for it on the haskell proposals reddit
09:11:15 <leimy> hmm
09:11:18 <maltem> what are the things MPI can do that ghc cannot? Is it about accessing non-shared, partitioned memory?
09:11:24 <leimy> kind of a weird use for reddit
09:11:26 <leimy> "voting" :-)
09:11:37 <RayNbow> http://www.reddit.com/r/haskell_proposals/comments/7ikcg/an_mpilike_distributed_computing_framework_for/ <-- this one, pumpkin? :)
09:11:40 <leimy> MPI is message passing
09:11:47 <leimy> but MPI2 is about more than that
09:11:56 <leimy> has things like windowed remote memory puts and gets
09:12:15 <leimy> things that certain network adapters are supposed to be able to DMA for.
09:12:25 <leimy> like Mellanox's Infiniband, or Myrinet.
09:12:40 <pumpkin> leimy: many people "would like to see" stuff in haskell, so jsn founded a new reddit so people can vote for stuff they want to see done
09:12:44 <leimy> Allows for Operating System bypass.
09:12:54 <pumpkin> RayNbow yup
09:13:06 <leimy> pumpkin: that's kind of cool, but I thought reddit was for links to stuff  on the internet? :-)
09:13:09 <vegai> hmm, I already use MPI with Chans
09:13:16 <maltem> oh, so you cannot do message passing with ghc?
09:13:22 <pumpkin> leimy: you can create your own reddits for any topic, so it seemed useful
09:13:32 <pumpkin> maltem: well, you can
09:13:33 <vegai> ah but not distributed through a network of course
09:13:33 <leimy> Sure... I'm not criticizing it... I just thought it was novel.
09:13:39 <RayNbow> leimy: you can link to "self" on reddit :p
09:13:44 <pumpkin> you can make it go over a network if you want
09:13:52 <pumpkin> but you'd need to write the communication code yourself, etc.
09:14:09 <maltem> oh it's the network communication code, ok
09:14:17 <leimy> Marshalling, packing, unpacking, unmarshalling
09:14:27 <maltem> leimy: Data.Binary :)
09:14:33 <leimy> yep..
09:14:50 <leimy> You can post receive requests in advance in MPI, then check them later
09:14:53 <leimy> it's like a lazy receive :-)
09:15:10 <leimy> but it has advantages in that you're telling the runtime about an incoming expected message
09:15:16 <leimy> so unexpected queues don't get overflowed.
09:15:22 <ski_> (cads : .. what about p-adic ?)
09:15:50 * maltem must learn MPI in a year or something
09:16:01 * leimy thinks MPI will be not so important soon
09:16:07 <leimy> I mean if you work for DOE it might be.
09:16:15 <leimy> as they still use fortran
09:16:23 <leimy> and MPI will probably never die there.
09:16:24 <pumpkin> leimy: why not?
09:16:29 <maltem> leimy: blame those who determine what courses are mandatory
09:16:34 <leimy> Because it's VERY low level :-)
09:16:35 <pumpkin> the cases in which MPI was used locally on a single machine will die
09:16:46 <pumpkin> but for erlang-like uses
09:17:02 <pumpkin> but yeah, I'm sure you know it a lot better than me :)
09:17:15 <leimy> I'm not saying MPI is uninteresting, I just think there's better languages/notations for doing MPI like stuff.
09:17:31 <pumpkin> what, besides erlang right now?
09:17:42 <leimy> Erlang is not really HPC :-)
09:18:06 <pumpkin> so what are the options? I'm looking for something :)
09:18:06 <leimy> There's a lot of work being done in parallel-C code, and other funky dialects
09:18:11 <pumpkin> ah
09:18:14 <leimy> and there's also stuff like VSIPL++
09:18:54 <leimy> which is Vector Signal Image Processing Library for c++ with "expression templates" (a way to do lazy stuff basically) and loop fusion, which can be stacked on MPI for distributed HPC computations.  (I worked on the standard)
09:19:44 <leimy> Well my company was funded to have someone work on the standard with folks at MIT's Lincoln Labs.  It was a lot of fun... but all the Expression Template stuff in C++ made me want to use lisp or something with good macros  instead :-)
09:20:20 <leimy> I believe CodeSourcery has a good implementation of that library.
09:20:29 <Saizan> HPC?
09:20:36 <leimy> high performance computing
09:20:37 <pumpkin> high performance computing
09:20:41 <cads> ski, I am probably wrong about floating points being p-adic numbers that approximate the reals. I don't remember the original quote, but it was a way of expressing that the theory of floating point numbers has some not so subtle drawbacks :D
09:20:45 <pumpkin> or haskell program coverage :P
09:21:03 <leimy> http://www.codesourcery.com/vsiplplusplus/benefits.html  <- there
09:21:11 <pumpkin> thanks :)
09:21:15 <roconnor> @quote
09:21:16 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
09:21:25 <pumpkin> :o
09:21:39 <llayland> would someone please look at my data structure in http://hpaste.org/13409.  including the family feels weird to me
09:21:48 <leimy> The guy that was working that with us left and went to Google :-)
09:21:55 <leimy> from CodeSourcery
09:22:36 <vixey> llayland, so don't (?)
09:22:38 <leimy> anyway I got some Erlang to write...
09:23:00 <pumpkin> :o
09:23:06 <cads> this Cilk++ is interesting: http://www.cilk.com/multicore-blog/bid/7412/Cilk-Sets-World-Record-for-Crypto-Hash-Function-Throughput
09:23:07 * leimy does that at his day job
09:23:28 <leimy> I made a convincing argument for functional programming after a downsizing at our software company.... and won :-)
09:23:46 <pumpkin> omg you took advantage of other people's misfortune!
09:23:51 <cads> "eh if it don't work we fire him next"
09:23:56 <wli> leimy: How so?
09:23:58 <guenni> as an ammendment to the editor problem: I have to admit that I do have a lot less code to keep in check with a good editor than in other languages so I guess that balances the equation ...
09:24:04 <leimy> Well we had a huge team of Java programmers
09:24:05 <sbahra> leimy, what do you think would replace MPI?
09:24:07 <maltem> Functional programming kills your job!!!
09:24:19 <leimy> which could be replaced by like a few good functional programmers who know lower level stuff too.
09:24:19 <RayNbow> Beware of the Lambda Killers :p
09:24:34 <RayNbow> I mean... Killer Lambdas
09:24:39 <pumpkin> functional programmers can't know low level stuff though
09:24:42 <pumpkin> that would be impure
09:24:47 <leimy> And sadly, they got rid of half our software company BEFORE they knew what to do next.
09:25:02 <leimy> I said "I can do all these pieces myself, if you let me write it in NOT java" :-)
09:25:03 <leimy> so I did
09:25:06 <sbahra> Yes, when looking for compute through-put, you usually want the low level details.
09:25:07 <wli> I do kernel programming for a living.
09:25:13 <maltem> leimy: oh so basically, many mediocre people were replaced by a few very smart
09:25:17 <sbahra> wli, what kernel?
09:25:22 <pumpkin> linux!
09:25:26 <leimy> sbahra: Unknown, I just don't think MPI programmers or MPI programs are that easily maintained :-)
09:25:34 <wli> Linux
09:25:46 <guenni> has anyone here done office automation with haskell *lately*?
09:25:48 <leimy> maltem: not replaced... I think a lot of people were cut because it was hard to manage them many many miles away
09:25:52 <llayland> vixey: seems like I need it though.  maybe its just me and functional programming
09:25:56 <leimy> and we were told to cut our budget by a huge sum.
09:26:17 <leimy> so it seemed we needed more productivity than Java could offer.
09:26:26 <sbahra> leimy, you're right.
09:26:34 <leimy> And functional languages are very easy to test.
09:26:42 <leimy> er functional programs
09:26:50 <cads> leimy, you guys are using erlang now?
09:26:50 <leimy> especially pure ones.
09:26:53 <leimy> yeah
09:26:55 <pumpkin> wli: how do you feel about the kernel going onto the iphone? :P
09:26:58 <leimy> since about April
09:27:00 <leimy> and I'm the only one
09:27:08 <leimy> but I'm trying to recruit more
09:27:16 <cads> what's the rest of the team do?
09:27:18 <leimy> our company's Chief Architect want me to tutor him a bit in it.
09:27:18 <Saizan> llayland: it's fine to keep the family there, the other solution would be using ids and having a separate graph structure
09:27:38 <leimy> cads: Mostly java
09:27:43 <wli> pumpkin: Probably not as relevant as the userspace parts of all that.
09:27:44 <leimy> hoping to get a lot of that replaced.
09:28:06 <maltem> leimy: lucky you. teaching collegues can give such a warm fuzzy feeling :)
09:28:11 <leimy> yeah
09:28:18 <leimy> that they're open to that stuff is great.
09:28:34 <pumpkin> llayland: why not just represent your families as a graph using fgl or Data.Graph and build on top of that?
09:28:34 <llayland> Thanks Saizan.  I thought about using some sort of id but rejected that because of the need to enforce a unique mapping from ids to graphs
09:28:51 <wli> pumpkin: It could be good for Linux.
09:28:57 <leimy> The problems of concurrency in Java are not all that widely well understood.
09:29:05 <leimy> that was one of the big reasons not to do the new stuff in Java.
09:29:31 <leimy> I mean there's good ways to write concurrent code in Java, but lots of pitfalls too.  Functional Programming is totally win win there.
09:29:38 * cads needs to play with erlang to get a feeling for all the hype.. it feels like those concurrency primitives aren't all that fancy and should be doable in other languages
09:29:38 <sbahra> It's hard to have a language with GC (as an implicit requirement) perform well on NUMA.
09:29:51 <pumpkin> wli: if you want to help out I know the guy running the project (and am supposed to be helping him but have been too busy)
09:29:59 <leimy> cads: yeah... there's a language based on Scheme that does Erlang like concurrency
09:30:01 <leimy> "Termite"
09:30:19 <Saizan> when i first read about "spurious signals" i wanted to cry
09:30:21 <sbahra> pumpkin, do you get a free iPhone?
09:30:31 <pumpkin> sbahra: lol, no
09:30:37 <pumpkin> I did though
09:30:59 * leimy has to run
09:31:00 <leimy> ttyl
09:31:04 <pumpkin> ciao
09:31:10 <llayland> pumpkin: I'm in "roll your own" mode now.  Later I'll compare against those to see how I did
09:31:14 <wli> pumpkin: I'm in deep enough doo doo I don't dare have ostensible "distractions."
09:31:27 <dnul_> question
09:31:38 <pumpkin> wli: ah ok :) hope you get out of the doo doo without too much stink
09:31:46 <pumpkin> llayland: fair enough :)
09:31:55 <dnul_> in list comprehension can i do something like [x | x not in [...]]
09:32:15 <idnar> dnul_: [x | x `notEleme [...]]
09:32:19 <idnar> er
09:32:21 <idnar> dnul_: [x | x `notElem` [...]]
09:32:26 <dnul_> thx
09:32:30 <idnar> but that might be more nicely written as:
09:32:46 <cads> what would that quantify x over?
09:32:57 <idnar> oh, true
09:33:02 <Saizan> x is free there
09:33:08 <idnar> [x | x <- [...], x `notElem` [...]]
09:33:28 <idnar> but anyhow, I'd probably go with: filter (`notElem` [...]) [...]
09:33:50 <Saizan> ?type (\\)
09:33:51 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:34:55 <Saizan> > [1,2,2,3] \\ [1,2]
09:34:56 <lambdabot>   [2,3]
09:34:59 <idnar> oh, even better
09:35:04 <idnar> or not
09:35:24 <Saizan> it's set subtraction if you don't have repetitions
09:35:33 <paper_cc1> > nub [1, 2, 2, 3] \\ [1, 2]
09:35:34 <lambdabot>   [3]
09:35:42 <pumpkin> multiset subtraction if you do?
09:35:53 <vixey> > ((\\)`on`nub) "foobar" oof"
09:35:54 <lambdabot>   <no location info>:
09:35:54 <lambdabot>      lexical error in string/character literal at chara...
09:35:54 <vixey> > ((\\)`on`nub) "foobar" "oof"
09:35:55 <lambdabot>   "bar"
09:35:57 <sbahra> > [1, 2] \\ [3,4]
09:35:58 <pumpkin> > [1,2,2,2,3,3,3,3] \\ [2,2,3,3,3]
09:35:58 <lambdabot>   [1,2]
09:35:59 <lambdabot>   [1,2,3]
09:36:03 <cads> > [x | x <- [0..], notElem x [1,1,2,3,5,8]]
09:36:04 <lambdabot>   [0,4,6,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
09:36:05 <pumpkin> > [1,2,2,2,3,3,3,3] \\ [2,2,3,3]
09:36:06 <lambdabot>   [1,2,3,3]
09:36:13 <dnul_> thx u
09:37:04 <dmwit> dnul_: That won't work if notElem's second argument is infinite, for obvious reasons.
09:37:23 <dmwit> dnul_: I've written ordElem and ordNotElem for that purpose, if that becomes important.
09:37:42 <idnar> dmwit: do those rely on the list being sorted?
09:38:32 <dmwit> Yes.
09:38:48 <pumpkin> dmwit: a collection of ord* infinite sorted "set" operations (union, intersection, subtraction) seems like it would be nice on hackage :o
09:39:24 <dmwit> hum
09:39:25 <pumpkin> I have union and intersection I wrote
09:39:27 <dmwit> Could be.
09:39:34 <pumpkin> but it seems like people write these quite often
09:39:38 <dmwit> right
09:39:46 <llayland> thanks all
09:45:25 * dmwit makes noises of agreement with all present
09:48:23 * mornfall is present.
09:48:49 * cizra makes a present-face but really isn't
09:49:22 <cizra> dmwit: Your nick reminds me of Lord Dimwit… Any connection?
09:50:33 <dmwit> Why yes!
09:50:37 <dmwit> It's connected by spelling.
09:50:52 * dmwit wishes he could have disagreed, but had already promised to agree with people
09:53:02 <Badger> dmwit: am I correct in supposing that you are a fool?
09:54:15 * cizra makes noises of agreement with Badger
09:59:11 <djahandarie> It's really starting to bug me with the use of acronyms in CamelCase...
09:59:12 <roconnor> @go "Lazy Functional Algorithms for Exact Real Functionals"
09:59:18 <lambdabot> http://citeseer.ist.psu.edu/16168.html
09:59:19 <lambdabot> Title: Lazy functional algorithms for exact real functionals - CiteSeerX
09:59:33 <djahandarie> Should the acronyms stay all capital or be treated as words?
09:59:49 <vixey> stay all capital
10:00:42 <blando> i treat them as words and use capitals only where one would use underscores otherwise
10:01:11 <Peaker> camelCase was popularized by Java, wasn't it?
10:01:42 <dublpaws> it was before java
10:01:50 <dublpaws> MacPaint
10:01:58 <esap> I've used camelCase before Java existed :-)
10:02:42 <Peaker> I think keyboards should have an underscore key, and we_should_use_underscores andNotCamelCase
10:02:59 <Peaker> well, until we get rid of text :)
10:03:18 <blando> heh... i love all lower and underscores.  just looks so much cleaner than mixed case
10:04:02 <esap> syntactic style is not very important though
10:04:08 <Peaker> the problem is that using - is ambiguous with subtraction, and using underscores requires the shift key because people are too lazy (or non-lazy?) to map underscore to a single key
10:04:42 * dublpaws invents a keyboard that makes caps when the user really hit the keys hard
10:05:06 <blando> dublpaws intends to aggravate my already aching fingers
10:05:09 <pumpkin> has anyone used the gnuplot package?
10:05:12 * vixey I like esaps view
10:05:14 <Saizan> "_" also takes horizontal space
10:07:36 <Riastradh> Peaker, - isn't ambiguous with subtraction if one requires the spaces that everyone writes anyway.
10:08:18 <mpwd> @src S.empty
10:08:18 <lambdabot> Source not found. That's something I cannot allow to happen.
10:26:27 <duaneb> so
10:26:37 <duaneb> I want to write a haskell pretty printer
10:26:47 <duaneb> i.e. a program that pretty prints haskell itself
10:27:06 <paper_cc> Language.Haskell.Pretty&
10:27:08 <duaneb> But, I want to be able to use type signatures to figure out how to handle each part
10:27:16 <paper_cc> s/&/?/
10:27:33 <duaneb> no, it's not really enough for what I want
10:27:47 <duaneb> can I use GHC as a library to view haskell as data?
10:28:25 <paper_cc> isn't haskell-src enough? (or some hacks around haddock)
10:28:35 <duaneb> hmm
10:28:38 <duaneb> I'll look into it
10:28:45 <duaneb> I'm just looking for a good way to approach this
10:30:09 <duaneb> basically
10:30:47 <duaneb> I want to write something that will output latex from haskell code
10:30:55 <RayNbow> @faq Can Haskell heat my room using the HeaterMonad?
10:30:55 <lambdabot> The answer is: Yes! Haskell can do that.
10:31:04 <pumpkin> duaneb: what if you're allergic to latex?
10:31:14 <pumpkin> can I have a pig intestine version?
10:31:17 <maltem> duaneb: like lhs2tex?
10:31:31 <duaneb> pumpkin: I'll support nylon as well
10:31:37 <duaneb> lhs2tex is VERY limited
10:32:06 <maltem> What will you do better, or add?
10:32:43 <pumpkin> pig intestine
10:32:48 <vixey> lhs2tex is not limited
10:32:49 <pumpkin> and nylon
10:32:50 <pumpkin> apparently
10:32:55 <maltem> (I'm all for tools that prettify Haskell papers)
10:33:33 <duaneb> vixey: no, it just turns the entire code set into math
10:33:36 <duaneb> and then aligns correctly
10:34:53 <mpeter> hello
10:37:22 * cizra goes through wild contortions to write a 's/foo/bar/g' in C
10:37:25 * cizra groans
10:37:41 <vixey> cizra, that's easy both strings are the same length
10:38:08 <cizra> Well, sorta
10:38:18 <cizra> But I'm spoiled with high-level languages now.
10:39:32 <blando> just think of c as a high level language with many more opportunities to write interesting algorithms
10:40:00 <cizra> Ooh. Went much easier at once.
10:41:30 <mpeter> what, no greeting?
10:42:05 <vixey> no
10:42:32 <mpeter> :(
10:42:41 <mpeter> > error "VIXEY"
10:42:42 <lambdabot>   * Exception: VIXEY
10:42:52 <vixey> don't do that
10:43:01 <mpeter> why not
10:44:59 * mpeter starts crying
10:52:59 <mpeter> > explode vixey
10:53:01 <lambdabot>   "vixey sucks!"
10:53:12 <mpeter> that'll show him
10:53:21 <vixey> don't do that
10:53:34 <mpeter> why not
10:53:35 <cizra> People love telling each other what they can and what they cannot do…
10:53:43 <cizra> vixey: don't do that
10:53:49 <mpeter> it's true, cizra
10:53:52 <mpeter> that's why anarchy is so awesome
10:54:09 <erso> cizra: societies are built upon, and fall on that premise alone
10:54:41 <mpeter> < foldr (+) 1 vixey
10:54:46 <mpeter> > foldr (+) 1 vixey
10:54:48 <lambdabot>   1220
10:54:57 <Twey> Hehe
10:54:59 <Twey> > vixey
10:55:01 <lambdabot>   [36,118,110,102,120,118,35,124,104,123,108,121]
10:55:15 <Twey> > map chr vixey
10:55:16 <lambdabot>   "$vnfxv#|h{ly"
10:55:21 <Twey> Hmn
10:55:24 <Twey> What's the key?
10:55:31 <Twey> :t explode
10:55:32 <lambdabot> [Int] -> [Char]
10:55:39 <cizra> Hey, Twey. What're you doing here?
10:55:50 <duaneb> > "vixey" :: [Int]
10:55:50 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
10:55:58 * duaneb grumbles
10:56:08 <mpeter> i'm getting deja vu
10:56:28 <mpeter> back to that time when me and my alien comrades
10:56:29 <mpeter> well
10:56:38 <mpeter> this isn't a story for mixed company
10:57:08 <Twey> doi la cizra ku mi ti xabju
10:57:18 <cizra> je'e
10:57:27 <shapr> Hey, this isn't #lojban
10:57:28 <mpeter> nous sommes d'ici
10:57:50 <Twey> Ouais
10:58:07 <jpcooper> tamam
10:58:31 <proq> hayir
10:58:34 <mpeter> jeg talar hundurenska!!!!!
10:58:45 <jpcooper> evet
10:58:47 <shapr> jag talar svenska?
10:58:56 <shapr> men... det aer inte #haskell.sv
10:59:06 <shapr> Perhaps #haskell.jbo ?
10:59:37 <lispyone> hello
10:59:45 <tonkman> well, its #haskell.se
10:59:49 <shapr> I also speak southern, but I have yet to create #haskell.dixie
11:00:11 <lispyone> I have been wrapping opencv for ghc and have a question
11:00:14 <shapr> tonkman: Good point.. but what about those swedish speakers who aren't in Sweden? We feel left out!
11:00:20 <Twey> Southern Finnish?
11:00:23 <shapr> lispyone: ooh, what's your question?
11:00:41 <agemo> could someone tell me what the haskell equivalent of sleep is and in which library i might find it?
11:00:45 <shapr> Twey: No, I'm from the Swedish speaking part of Alabama.
11:00:50 <agemo> i can't seem to find anything usefull on google
11:00:53 <lispyone> I have a struct and it contains an int array of lenght 4
11:00:56 <agemo> useful*
11:01:07 <lispyone> I have a storable instance declared
11:01:20 <lispyone> but I am a little confused on how to
11:01:21 <vixey> agemo, threadDelay
11:01:40 <agemo> ah, thanks :)
11:01:41 <lispyone> marshall the array values from C to the haskell datatype
11:01:55 <lispyone> and I am a newbie obviously
11:02:11 <lispyone> I have most of the functions wrapped and working
11:02:30 <lispyone> kind of cool-- computer vision library
11:03:03 <lispyone> can someone point me to an example
11:03:05 <lispyone> ?
11:04:19 * shapr hugs vixey
11:04:40 <lispyone> I have looked around and most of the examples I have found deal with CString* not a fixed length array
11:05:51 * vixey hug shapr
11:06:28 <vixey> I saw the Kacapo bird on Attenbourough show
11:06:44 <vixey> can't spell
11:07:04 <unskilled> good day. perhaps a silly, question, but i'm a beginner in haskell. so is it possible to "compile" my haskellcode so the user can just click an application which automatically runs the main-function in Module Main?
11:07:11 * mpeter sets fire to vixey
11:07:13 <mpeter> stop fucking around!
11:07:49 <paper_cc> unskilled: ghc --make -o <application name> Main
11:08:00 <paper_cc> or whatever you're using (if not Hugs)
11:08:05 <cizra> unskilled: yes
11:08:14 <cizra> unskilled: ghc does that, at least in Linux
11:08:32 <blando> lispyone: you can either store the Ptr CInt in the Storable directly, or manually peek/poke the array offsets into a list or record
11:09:19 <paper_cc> cizra: it does it Windows/OSX/<whatever platform it runs on> as well
11:10:08 <lispyone> ok so basically iterate through the ints and copy them to storage that I have allocated on Haskell side
11:10:12 <cizra> paper_cc: I'm redundant )= Should have read your text before typing
11:10:20 <lispyone> cool enough
11:10:31 <lispyone> thank you for your hely
11:10:35 <lispyone> help
11:10:53 <cnwdup> Why is my Haskell program running in many OS threads using forkIO und -threaded? I thought it'd run in only one thread.
11:11:02 <blando> lispyone: if the array has an identity beyond an anonymous set of values, you can create a sub datastructure for it and make it a Storable.  otherwise, yeah... just tear off each value individually
11:11:37 <shapr> vixey: Oh you saw a kakapo?! Cool!
11:11:46 <maltem> cnwdup: I think -threaded enables the concurrent garbage collector
11:11:50 <shapr> mpeter: hey man, watch yer language!
11:12:00 <vixey> shapr, only on tv, but yeah. strange antics
11:12:09 <mpeter> me?
11:12:11 <lispyone> I don't think storing the Ptr CInt will work for me because the function that takes a ptr to this structure checks the size of it and expects it to be 112 bytes
11:12:12 <shapr> vixey: Yeah, they boom and drum and do all sorts of nifty stuff.
11:12:16 <mpeter> he swore at me first ;)
11:12:18 <vixey> yes
11:12:32 <shapr> mpeter: Does not mean you should do it too
11:13:00 <mpeter> it did in this case
11:13:08 <shapr> mpeter: I disagree.
11:13:13 <maltem> cnwdup: There should be an extra flag to force how many threads the GC use
11:13:15 <mpeter> he privmsged me
11:13:24 <mpeter> you missed some of it
11:13:47 <shapr> mpeter: Definitely not a case to swear back in public then.
11:13:56 <cnwdup> maltem: I think I have to read those options up. Thanks.
11:14:01 <blando> lispyone: ah.  then yeah, push each value into the correct offset when marshalling to c
11:14:12 <mpeter> > moral value of swear at vixie
11:14:14 <lambdabot>   <no location info>: parse error on input `of'
11:14:56 <mpeter> i have to go feed my cat
11:14:58 <mpeter> enjoy #haskell
11:15:29 <enticingjelly> I really like SYB
11:15:37 <orbitz> :t moral
11:15:40 <lambdabot> Not in scope: `moral'
11:15:50 <mpeter> @let morals="stupid"
11:15:51 <lambdabot>  Defined.
11:15:56 <mpeter> > morals
11:15:57 <lambdabot>   Not in scope: `morals'
11:16:11 <mpeter> eh
11:16:34 <quylui> how would i go about getting emacs haskell-mode to work with winhugs?
11:16:45 <blando> lispyone: there is Foreign.Marshal.Array.pokeArray that will poke a haskell list into a Ptr
11:16:50 <unskilled> ghc --make doesn't work on windows :(
11:17:11 <paper_cc> why doesn't it work?
11:17:49 <paper_cc> (at least cabal builds are all right on Windows - please beat me if they don't use ghc --make)
11:18:09 <Saizan> (they do use --make)
11:19:10 <lispyone> just found that thanks
11:19:31 <lispyone> As soon as I get this finshed I will release it to the world
11:19:42 <lispyone> maybe someone will find it useful
11:19:49 <lispyone> or entertaining
11:22:37 <afabian> quylui: If you don't have some over-riding reason to use winhugs, go for ghc.  I came in here with hugs issues and got ghc recommendations.  Apparently, a lot of the old haskell material recommends hugs, but ghci (the interactive version of ghc) has caught up.  I've been using ghci with a tutorial and haven't encountered any problems, but I'm just a newbie.
11:23:54 <quylui> afabian: thanks. i actually did use ghci but couldn't get it to work for some reason (it wouldn't compile, oddly enough). so after i reformatted i just switched to winhugs. i'll take your advice and see if i can get it to work again.
11:32:32 <andyjgill> Does anyone know how to include a test with a cabal package, without making it say "library and program"?
11:46:15 <dnul_> function to make cross-product of a set ?
11:46:35 <cnwdup> How can I profile X11 programs? GHC is telling me no Graphics.X11.Xlib proofiling libraries were installed. Do I have to compile X11.Xlib with -prof myself?
11:47:26 <afabian> dnul_: You should be able to do it pretty easily with two list comprehensions, if you have the items of the set in a list L.  i.e., [ (x,y) | x <- L, y <- L].  Maybe there's a prelude function for it?  I dunno.
11:47:44 <vixey> > liftA2 (,) "xyz" "pqdb"
11:47:46 <lambdabot>   [('x','p'),('x','q'),('x','d'),('x','b'),('y','p'),('y','q'),('y','d'),('y'...
11:48:00 <afabian> Or, uhm, that.
11:48:15 <vixey> problem is, there's no Monad or Applicative for Set...
11:48:17 <phercek> Does anybody know why ghc 6.10.1 is still in testing in archlinux?
11:50:06 <vixey> :t (map (,) =<< "xyz")
11:50:06 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
11:50:06 <lambdabot>       Expected type: [[a]]
11:50:06 <lambdabot>       Inferred type: [Char]
11:50:09 <vixey> :t (map  .(,) =<< "xyz")
11:50:10 <lambdabot>     Couldn't match expected type `[a] -> a1'
11:50:10 <lambdabot>            against inferred type `[Char]'
11:50:10 <lambdabot>     In the second argument of `(=<<)', namely `"xyz"'
11:50:58 <vixey> :t unionManySets . map (flip mapSet ?l . (,))
11:50:59 <lambdabot> Not in scope: `unionManySets'
11:50:59 <lambdabot> Not in scope: `mapSet'
11:51:22 <pejo> afabian, that definition doesn't usually give what you want for infinite inputs
11:52:35 <vixey> :t (flip mapMonotonic ?l . (,))
11:52:36 <lambdabot> Not in scope: `mapMonotonic'
11:52:39 <vixey> :t (flip Se.mapMonotonic ?l . (,))
11:52:40 <lambdabot> Couldn't find qualified module.
11:52:43 <vixey> :t (flip Set.mapMonotonic ?l . (,))
11:52:44 <lambdabot> Couldn't find qualified module.
11:53:12 <paper_cc> cwdmap: on debian, there are -prof libraries for -dev ones
11:58:43 <ahunter> Quick question, having trouble finding older versions of libraries to check: was Data.List.intercalate added to Data.List recently?  Some code I gave someone won't build under ghc-6.6, can't find intercalate
12:03:21 <Saizan> ahunter: yes, it's recent
12:03:57 <ahunter> Saizan: in the future, is there an easy way to lookup when things get added to a library?  Short of doing binary search on the darcs repo?
12:06:26 <shapr> Would be neat if hayoo did that.
12:06:36 <C-Keen> when should I use a Hashtable instead of  a Map?
12:07:15 <C-Keen> as I understood I need ordering of my elements on a map whereas in a Hashtable I dont
12:07:21 <C-Keen> sorry don't
12:07:31 <Botje> hashtables in haskell are a really bad idea
12:08:04 <Botje> because there's very little sharing, so memory usage shares
12:08:22 <Botje> and defining ordering is generally as simple as "deriving Ord" :)
12:09:07 <earthy> botje: not always though
12:09:15 <earthy> but then you're doing crazy things ;)
12:09:49 <dmwit> C-Keen: My rule of thumb is "just always use a Map".
12:10:01 <earthy> c-keen: hashtables have no real advantages over maps
12:10:33 <earthy> unless you are in a setting where the ordering is much more expensive than the hash calculation
12:10:42 <earthy> and I do mean *much* more expensive
12:11:05 <earthy> unfortunately, a good has tends to be not as cheap as you'd hope
12:11:15 <earthy> hash
12:11:50 <shapr> That's true in food places as well.
12:15:42 <jeltsch> If I want to install Gtk2Hs from source, do I need GTK+ development files (header files and static libraries) or is an “ordinary GTK+” enough?
12:17:01 <Botje> you'll need the header files, yes
12:17:48 <ddarius> @google Zobel hash
12:17:52 <lambdabot> http://citeseer.ist.psu.edu/530453.html
12:17:52 <lambdabot> Title: Performance in Practice of String Hashing Functions - CiteSeerX
12:19:24 <jeltsch> Botje: Thanks.
12:20:28 * wli recommends hash tries.
12:21:13 <wli> They're radix trees with large branching factors whose nodes are "compressed" by structuring them as open-addressed hash tables.
12:22:36 <wli> earthy: Contiguous memory is better than pointer-chasing wrt. L2 cache pressure.
12:24:40 <wli> earthy: Hashing by separate chaining isn't so great for that, but hashing by open addressing (esp. with bounded in-array collision chains vs. always skipping by increments of the secondary hash function) rocks hard wrt. cache compactness, albeit at the cost of occasional whole-table flushes.
12:25:54 <wli> earthy: If the ordering is important, please go with B trees or B+ trees.
12:32:59 <enticingjelly> why doesn't emacs indent then and else correctly...
12:34:29 <pumpkin> haskell indentation is an uncomputable problem
12:41:14 <ray> it's not, just NP-complete
12:41:25 <pumpkin> nope, it's uncomputable!
12:41:40 <pumpkin> I can reduce haskell indentation to the halting problem
12:42:08 <C-Keen> thanks dmwit Botje earthy for your insights, I will stick to Data.Map :)
12:42:41 <cizra> I don't know if Haskell indentation is equivalent to halting problem or not, but I do know the solution would involve either time machines or mind-reading
12:43:16 <dmwit> pumpkin: um
12:43:24 <dmwit> pumpkin: Can you give a brief sketch of that reduction?
12:43:29 <Olathe> I can call up Doc Brown if you'd like.
12:43:40 <rwbarton> doesn't indenting haskell code properly require reading the programmer's mind?
12:43:45 <dmwit> ...or am I missing a joke again?
12:43:48 <pumpkin> dmwit: 1) um 2) ???? 3) indentation is uncomputable
12:44:03 <dmwit> okay =)
12:44:26 <dmwit> rwbarton: Not if/then/else.
12:44:37 <dmwit> rwbarton: If you want to generalize to blocks, then yes.
12:44:39 <ray> "halting problem" is shorter than "haskell indentation"
12:44:41 <rwbarton> Ah, that's probably true.
12:44:41 <ray> there's your reduction
12:44:45 <pumpkin> lol
12:44:57 <C-Keen> what's the syntax for requiring more than one class of a type? for example I have (Ord a) => [a] -> Bool how do I add Eq?
12:45:11 <mauke> you don't
12:45:16 <mauke> Ord is a superclass of Eq
12:45:16 <ozy`> (Ord a, Eq a) => ...
12:45:20 <ozy`> whoops
12:45:25 <dmwit> rwbarton: One of the Haskell' proposals describes a system that wouldn't have the problems we have right now for ifte.
12:45:32 <C-Keen> mauke: ah
12:45:49 <ddarius> mauke: subclass
12:46:01 <mauke> right :(
12:46:02 <dmwit> Ord implies Eq, but in case this was just an example, you can specify multiple class restrictions using tuple notation.
12:46:13 <mauke> subclass, superset
12:46:16 <ray> is that not a glasgow extension
12:46:23 <Olathe> Can you specify more than 62 classes ?
12:46:39 <ddarius> mauke: subclass subset or what are you considering the "sets"?
12:46:48 <dmwit> Olathe: heh
12:46:52 <mauke> ddarius: available operations
12:46:54 <dmwit> ray: Which thing?
12:47:16 <ray> the multiple classes thing
12:47:23 <Olathe> There are types in the report with multiple classes, I think.
12:47:25 <dmwit> ray: No, that's H98.
12:47:26 <ddarius> dmwit: There's a Haskell' proposal for programmer's to start being consistent?
12:47:29 <mauke> (Badger badger, Badger badger, Badger badger, Badger badger, Badger badger, Badger badger, Mushroom mushroom) => ...
12:47:33 <ray> ah ok
12:47:35 <Olathe> mauke: Heheh
12:48:12 <opqdonut> mauke: shouldn't that be: (Badger badger, Badger badger', Badger badger'', ...
12:48:17 <opqdonut> ;)
12:48:22 <ddarius> opqdonut: Why?
12:48:25 <dmwit> (Badger badger, Badger badger, Badger badger) => Mushroom mushroom; oh :: Snake
12:48:39 <opqdonut> to make the class constraint non-rendudnant
12:48:45 <opqdonut> gah, *redundant
12:48:46 <pumpkin> lol
12:48:52 <ddarius> opqdonut: Why does it have to be non-redundant?
12:49:00 <opqdonut> well dunno
12:49:03 <ray> the song is sure redundant
12:49:10 <opqdonut> indeed
12:50:05 <Olathe> @hoogle type
12:50:06 <lambdabot> keyword type
12:50:06 <lambdabot> Language.Haskell.TH data Type
12:50:06 <lambdabot> Language.Haskell.TH.Syntax data Type
12:50:30 <paper_cc> can anyone suggest something understandable and tutorial-ish on rank-2 polymorphism?
12:51:10 <opqdonut> the haskell.org wiki has something
12:51:12 <opqdonut> iirc
12:51:44 <opqdonut> the book types and programming languages has good stuff on how to embed objects etc. with rank-2
12:52:08 <paper_cc> the problem is forall. <=> exists. equivalence
12:52:14 <dmwit> paper_cc: There's not much to it.  You can represent types as trees.
12:52:31 <paper_cc> ahem
12:53:04 <dmwit> paper_cc: The rank of the polymorphism tells how many left-branches of arrows you can take and still get to a "forall".
12:53:33 <dmwit> As for the forall <=> exists equivalence, that comes from propositional logic, I guess.
12:53:38 <ddarius> dmwit: That doesn't really say anything about how you use it or what it means.
12:53:41 <dmwit> Do you know the DeMorgan laws for forall/exists?
12:53:45 <dmwit> ddarius: true enough
12:54:06 <dmwit> true enough
12:54:09 <dmwit> forgive me
12:54:48 <paper_cc> dmwit: you mean not (forall x. p(x)) = exists x. not p(x)?
12:54:55 <dmwit> exactly
12:55:12 <Olathe> @let oh x = (++" !").("It's a "++).show.dynTypeRep.toDyn $ x
12:55:13 <lambdabot>  Defined.
12:55:15 <paper_cc> but I don't see a 'not' involved in types anywhere =(
12:55:20 <dmwit> You can write (not x) in Haskell types as (forall x. x).
12:55:23 <Olathe> > oh (5::Int)
12:55:25 <lambdabot>   "It's a Int !"
12:55:37 <ddarius> dmwit: not a = a -> forall x.x
12:55:46 <dmwit> ah, right
12:55:54 <dmwit> (forall x. x) is "false", not "not"
12:56:04 <ddarius> And that deMorgan equivalence doesn't hold in Haskell, though it is a start.
12:56:10 <dmwit> I should maybe turn this explanation over to somebody who actually knows what they're talking about. =P
12:56:24 <ddarius> @google Lectures on the Curry Howard
12:56:28 <lambdabot> http://www.elsevier.com/wps/product/cws_home/706927
12:56:28 <lambdabot> Title: Lectures on the Curry-Howard Isomorphism, 149 - Elsevier
12:56:46 <paper_cc> thanks to all
12:57:06 <ddarius> http://folli.loria.fr/cds/1999/library/pdf/curry-howard.pdf
12:58:48 <paper_cc> Looks like I should get down to some academic investigation =) thanks
12:59:37 <pumpkin> that's the worst kind of investigation
12:59:47 <pumpkin> you should really call in sherlock holmes
13:00:16 <dmwit> I don't have his number. =/
13:00:54 <paper_cc> I should first try to deal with it myself and give up =)
13:01:09 <pumpkin> but yeah, stay away from academia, it burns
13:02:04 <roconnor> Given a sequence of bounded functions f_n defined on [0,1] such that lim (integral 0..1 f_n) exists, the is lim f_n defined almost everywhere?
13:02:05 <memento>    `DomainResult' is not applied to enough type arguments
13:02:11 <wchogg> if you think academia burns Haskell seems like an odd choice of language
13:02:14 <memento>     Expected kind `?', but `DomainResult' has kind `* -> *'
13:02:14 <memento> what does that mean?
13:02:15 <Olathe> dmwit: You're in luck: http://www.whitepages.com/10583/search/FindPerson?extra_listing=mixed&form_mode=opt_b&post_back=1&firstname_begins_with=1&firstname=Sherlock&name=Holmes&street=&city_zip=&state_id=&localtime=survey
13:02:27 <memento> too few argument for a return type?!
13:02:31 <mauke> memento: DomainResult is not a type
13:02:33 <enticingjelly> where can I find the source of, for example, the whole Control.Monad.Reader module?
13:02:33 <pumpkin> wchogg: :o
13:03:07 <paper_cc> enticingjelly: in darcs for ghc's base
13:03:17 <enticingjelly> paper_cc, quickly, using my browser?
13:03:22 <memento> mauke: but it is, i defined it with type DomainResult = StateT ...
13:03:28 <pumpkin> wchogg: I enjoy pain, particularly the burning kind
13:03:30 <paper_cc> there were hs-colour'ed sources somewhere. try to google site:haskell.org
13:03:36 <pumpkin> and haskell burns like no other
13:03:38 <mauke> memento: so? that doesn't mean it's a type
13:03:39 <enticingjelly> is there a lambdabot feature giving me the URL?
13:03:47 <mauke> memento: that just makes it a type constructor
13:04:16 <mauke> memento: e.g. type Foo = Maybe;  ... bar :: Foo is invalid, but bar :: Foo Int is ok
13:04:28 <memento> uh and what will make it to a type?:D
13:04:33 <paper_cc> enticingjelly: don't know =(
13:04:36 <mauke> memento: supplying the missing type argument
13:04:41 <memento> ahaa
13:04:49 <enticingjelly> ah
13:04:57 <enticingjelly> there's a link to the sourcecode in the documentation!
13:04:58 <memento> thx
13:05:05 <enticingjelly> http://hackage.haskell.org/packages/archive/mtl/1.1.0.1/doc/html/src/Control-Monad-Reader.html
13:05:12 <memento> so i need a data constructor for it
13:08:19 <ziman> ddarius, wow, that PDF you've just linked looks wonderful :) i think i know how i'm going to spend the evening ;)
13:08:26 <dmwit> ?source Control.Monad.Reader
13:08:26 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
13:08:35 <dmwit> enticingjelly: That link may or may not be outdated.
13:10:14 <ddarius> @hackage mtl
13:10:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
13:10:38 <enticingjelly> dmwit, I already got it from the documentation, there's a link to the source, but thanks anyway
13:10:59 <roconnor> is there a sequence of rational intervals, whose length goes to 0 while still hitting every rational number infinitely often?
13:12:48 <tromp_>  sure
13:13:12 <ddarius> roconnor: For each rational choose an interval around it of a given length, repeat for smaller and smaller lengths.
13:13:21 <rwbarton_> roconnor: is this about your previous question?
13:13:36 <rwbarton_> roconnor: you can take f_n(x) = x for n odd, f_n(x) = 1-x for n even
13:13:57 <dmwit> enticingjelly: It's just a generic way to answer this sort of question for yourself in the future. ;-)
13:14:22 <enticingjelly> dmwit, ah, sorry, didn't see that you typed in a command %)
13:14:33 <roconnor> ddarius: oh.  I think I need the lengths to go strictly to 0
13:15:09 <ddarius> Okay, decrease the length with each rational.
13:16:16 <roconnor> ddarius: right, but now I'm not sure the interval sequence will cover every rational number infinitely often
13:16:38 <ddarius> roconnor: Every rational is chosen infinitely often.  It can't not.
13:16:57 <enticingjelly> given a type T which has a record r of type R, how can I get a function with type T -> r -> T?
13:17:13 <dmwit> foo { x = bar }
13:17:19 <dmwit> It's not a function, admittedly.
13:17:20 <ddarius> Or maybe not, stupid infinity.
13:17:32 * ddarius rejects the Axiom of Infinity.
13:17:40 <dmwit> s/x/r/
13:18:18 <dmwit> You can get true functions in a generic way using funrefs.
13:18:19 <tromp_> you can cover each real number inf often
13:18:19 <dmwit> ?where funrefs
13:18:20 <lambdabot> I know nothing about funrefs.
13:18:23 <orbitz> does he want a function like get foo recordname ?or something
13:18:24 <dmwit> ?where funref
13:18:24 <lambdabot> I know nothing about funref.
13:18:26 <dmwit> boo
13:18:32 <dmwit> ?go twan functional references
13:18:39 <lambdabot> http://www.reddit.com/domain/twan.home.fmf.nl
13:18:39 <lambdabot> Title: twan.home.fmf.nl on reddit.com
13:18:52 <dmwit> wow
13:18:57 <dmwit> \bot is failing me really hard
13:19:11 <pumpkin> lol
13:19:18 <dmwit> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
13:19:26 <pumpkin> epic bot
13:21:26 <enticingjelly> dmwit, that's my problem. I want a function, for use with, for example, modify in Control.Monad.State
13:21:53 <pumpkin> I just saw doug mcilroy!
13:22:02 <pumpkin> inventor of pipes and destroyer of worlds
13:22:18 <mauke> (\x -> x{ field = y })
13:22:28 <enticingjelly> mauke, that's what I was afraid of...
13:22:33 <ddarius> pumpkin: http://www.cs.dartmouth.edu/~doug/powser.html
13:22:38 <enticingjelly> but if that's the way...
13:22:42 <pumpkin> ddarius: what about it?
13:23:12 <pumpkin> http://www.cs.dartmouth.edu/~sinclair/doug/
13:23:17 <dmwit> enticingjelly: Yep, that's one of Haskell's more annoying warts.
13:23:34 <dmwit> enticingjelly: Funrefs go a long way, but we really need a language change.
13:23:44 <blando> it even leads some to violent anger and outright abandonment
13:23:58 <enticingjelly> dmwit, so that's part of why everyone is talking about replacing the record system?
13:26:31 <dmwit> enticingjelly: yes
13:26:48 <dmwit> enticingjelly: The namespace pollution is also kind of annoying.
13:27:04 <dmwit> The module system helps a bit there, but there should be better solutions...
13:27:04 <enticingjelly> dmwit, I understand... well, I guess I'll just work my way around it
13:27:26 <enticingjelly> which means using more get and put than modify
13:27:36 * ddarius doesn't really think records should become a namespacing mechanism of their own (unless it's going to supplant modules)
13:27:46 <lispy> Uh oh, I have nick competition
13:28:15 <lispy> ddarius: how do you feel about C++ style namespaces?
13:28:53 <paper_cc> roconnor: |QxN| = |Q| = |N|. so if Answer = U(n in Q) { (n-1/k, n+1/k) | k in N }, Answer is still countable. so you can make a sequence from it
13:30:08 <ddarius> lispy: For C++ they're fine enough.
13:34:31 <ddarius> lispy: One could conflate yet more things into classes by instead making a way to import/export member names which would obviate the need for namespaces and provide a potentially useful feature.
13:44:22 <enticingjelly>     Couldn't match expected type `FunVal'
13:44:22 <enticingjelly>            against inferred type `BowlValue'
13:44:24 <enticingjelly> great.
13:44:35 <enticingjelly> i have no idea why it excepts a FunVal
13:45:20 <enticingjelly> especially since I'm really returning a BowlValue
13:45:46 <lispy> enticingjelly: hello! have you met hpaste.org yet?
13:45:58 <lispy> enticingjelly: if you show us some of the code by putting it there we could probably help
13:46:39 <enticingjelly> i was just babbling, sorry
13:46:50 <lispy> no problem
13:47:06 <lispy> BTW, are you related to ochurejelly by any chance?
13:47:26 <lispy> er sorry, ochre
13:48:17 <enticingjelly> lispy, no, don't even know him or her %)
13:48:53 <lispy> enticingjelly: twas a bad joke based on the game Angband so really, nevermind :)
13:49:37 <lispy> enticingjelly: http://www.thangorodrim.net/spoilers/monsters1.html#Ochre%20jelly
13:49:43 --- mode: irc.freenode.net set +o ChanServ
13:49:44 <enticingjelly> lispy, oh... sorry... though the name does come from nethack!
13:49:50 <enticingjelly> lispy, there are all kinds of jellys in nethack
13:50:03 <enticingjelly> lispy, so you weren't very far
13:50:10 <lispy> heh, nice
13:50:19 <Rui-> can someone help me with this problem: http://hpaste.org/13411#a0
13:50:20 <mauke> preflex: version
13:50:21 <preflex>  5.746
13:50:30 <lispy> enticingjelly: did you know there is a roglue like game or two being developed in Haskell?
13:50:34 <mauke> preflex: seen BONUS_
13:50:34 <preflex>  BONUS_ was last seen on #haskell 23 hours, 1 minute and 42 seconds ago, saying: basically i use it to post stupid inane jokes i come up with
13:50:36 <paper_cc> preflex: help
13:50:36 <preflex>  try 'help help' or see 'list' for available commands
13:50:39 <mauke> preflex: seen BONUS
13:50:40 <preflex>  BONUS was last seen on #haskell 22 hours, 48 minutes and 10 seconds ago, saying: i've seen pretty much just parsec and hutton's example and the StateT one
13:50:48 <paper_cc> oops, it's up now
13:51:18 <ddarius> roglue, where you play the role of a Kindergarten school child.
13:51:22 <Gracenotes>  hm. Reader sort of seems like State, except the initial state is instead immutable. Is that about right?
13:51:34 <enticingjelly> lispy, oh, no, I didn't know this! where?
13:51:46 <enticingjelly> Gracenotes, that's about right!
13:52:04 <lispy> enticingjelly: hackage lists a few of them, hackage.haskell.org
13:52:25 <ddarius> Gracenotes: And Writer is like state, except that the state isn't readable.
13:52:42 <ddarius> And Reader and Writer are both parts of the adjunction that gives rise to the state monad.
13:52:45 <Gracenotes> only appendable
13:52:59 <lispy> Rui-: it seems lie groupBy or group would be a natural choice for your problem
13:53:04 <Gracenotes> except, State doesn't require that the state be a monoid
13:53:05 <ddarius> Gracenotes: Choose the right monoid
13:53:16 <Rui-> can someone help me with something
13:53:26 <lispy> > groupBy (<=) [1,1,2,1,3,4,2,2]
13:53:28 <lambdabot>   [[1,1,2,1,3,4,2,2]]
13:53:34 <lispy> > group [1,1,2,1,3,4,2,2]
13:53:36 <lambdabot>   [[1,1],[2],[1],[3],[4],[2,2]]
13:53:38 <Gracenotes> ddarius: ah, that makes sense
13:53:46 <jsn> ddarius: can you explain more about the adjunction?
13:54:05 <ddarius> But yes, the "state-in-context" comonad is a more appropriate partner to the reader monad.
13:54:27 <lispy> Rui-: and then you could get the lengths by just mapping length over the groups
13:54:42 <dmwit> Rui-: Just ask, don't ask to ask. =)
13:54:44 <enticingjelly> lispy, nice, would love to take a look into it
13:54:46 <Rui-> ya i got that far
13:54:47 <Rui-> groupCountH [] = []
13:54:47 <Rui-> groupCountH (x:xs) = map (\x -> (head x, length x)) (group x) : groupCountH xs
13:54:52 <ddarius> :t Just ask
13:54:53 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => Maybe (m r)
13:55:04 <paper_cc> ddarius: brr
13:55:05 <Rui-> and made on for vertical too
13:55:12 <Gracenotes> :t local Just
13:55:12 <lispy> Rui-: diagonal?  hmm
13:55:13 <lambdabot>     Occurs check: cannot construct the infinite type: r = Maybe r
13:55:13 <lambdabot>       Expected type: r -> r
13:55:13 <lambdabot>       Inferred type: r -> Maybe r
13:55:14 <Rui-> no idea how I would do diagnol either
13:55:26 <Rui-> I have asked dmwit :(
13:55:26 <Gracenotes> aww. /me looks into
13:55:45 <Rui-> the problem is here: http://hpaste.org/13411#a0
13:55:55 <Rui-> wrote it out there so i can try to explain better
13:56:43 <lispy> Rui-: maybe an array would be better
13:56:45 <Gracenotes> oh, Just isn't exactly an (r -> r) function...
13:56:49 <ddarius> jsn: The adjunction usually taken as defining function spaces is \X.(A,X) -| \X.A -> X  Every adjunction gives rise to a monad which in this case is the state monad.
13:56:54 <dmwit> Ah, getting the diagonals of a [[a]].
13:57:19 <dmwit> Rui-: You might like the "tails" function.
13:57:38 <ddarius> Or its dual, the "sonic" function
13:57:44 <dmwit> heh
13:57:44 <Rui-> o.o
13:57:44 <lispy> > let sonic = [1..3] in tails sonic
13:57:46 <lambdabot>   [[1,2,3],[2,3],[3],[]]
13:58:05 <dmwit> > transpose . tails $ [1..3]
13:58:06 <lambdabot>   [[1,2,3],[2,3],[3]]
13:58:25 <paper_cc> dmwit: that's not the thing you want to meet without pencil and paper =)
13:58:27 <pumpkin> magic!
13:58:52 <jsn> ddarius:  so, to be sure i understand you, the monad that arises from adjunction defining function spaces is the state monad
13:58:57 <dmwit> > map (map (take 1)) . tails $ [[1..3], [4..6], [7..9]]
13:58:58 <lambdabot>   [[[1],[4],[7]],[[4],[7]],[[7]],[]]
13:59:07 <dmwit> whoops
13:59:13 <dmwit> > tails $ [[1..3], [4..6], [7..9]]
13:59:14 <lambdabot>   [[[1,2,3],[4,5,6],[7,8,9]],[[4,5,6],[7,8,9]],[[7,8,9]],[]]
13:59:23 <enticingjelly> SO SO SO stupid
13:59:26 <ddarius> jsn: from "the" adjunction, but yes.
13:59:30 <pumpkin> enticingjelly: yet enticing
13:59:40 <Gracenotes> is there a way to use an altered list monoid suh that mappend is flip (++) instead of (++)?
13:59:46 <dmwit> > map tails $ [[1..3], [4..6], [7..9]]
13:59:46 <jsn> ddarius: yes, "the" adjunction
13:59:46 <enticingjelly> pumpkin, 8)
13:59:47 <ozy`> I wish more punctuation was allowed for normal identifiers. it would force people to use more spaces, but that would help readability anyway
13:59:47 <lambdabot>   [[[1,2,3],[2,3],[3],[]],[[4,5,6],[5,6],[6],[]],[[7,8,9],[8,9],[9],[]]]
13:59:47 <Gracenotes> or would one have to do a newtype?
13:59:50 <jsn> ddarius: thank you
13:59:57 <ddarius> :k Dual [a]
13:59:59 <lambdabot> Not in scope: type variable `a'
14:03:23 <ozy`> Gracenotes: you could probably use import-hiding to define your own plumbing for the list monad
14:04:08 <Gracenotes> hm. what sort of notation would be used to hide an instance (in this case, MonadPlus of [a])
14:04:28 <mauke> you can't hide instances
14:04:35 <ozy`> well there goes that idea
14:04:53 <jsn> you can hide the class, though
14:05:23 <ozy`> mauke: you can't hide the module where an instance is defined?
14:05:36 <ozy`> or, it won't have an effect?
14:05:40 <jsn> ozy`: it would be fun if identifiers had spaces in them
14:06:16 <idnar> ozy`: you can't import a module without the instances in that module being "active"
14:06:28 <Gracenotes> I guess that's what newtype is for
14:07:47 <Rui-> any leads on my problem someone? ><
14:09:38 <paper_cc> Rui-: again, try arrays
14:09:48 <Rui-> im a noob with haskell
14:09:54 <Rui-> dont even know much about arrays
14:10:03 <Rui-> basically nothing :/
14:10:05 <dmwit> Rui-: You can do it with lists.
14:10:14 <dmwit> It's not too tricky; try doing it with explicit recursion first.
14:10:30 <dmwit> It might help you to try just writing a function that takes the "main diagonal" of a list of lists first.
14:10:45 <Rui-> well, the board is represented as a list
14:12:02 <dmwit> right
14:12:40 <tromp_> how big is the board?
14:12:45 <Rui-> any dimension
14:12:51 <Rui-> you choose before you play
14:12:56 <Rui-> the number of columns and lines
14:13:01 <dmwit> tromp_: I don't think efficiency is a concern here.
14:13:07 <pumpkin> you could map an iterated tail
14:13:13 <dmwit> tromp_: We're talking on the order of 10-15 elements on a side.
14:13:17 <dmwit> at a guess
14:13:40 <paper_cc> dmwit: imperative /me invented diagonal (x:xs) = (head x):(diagonal $ map tail xs)
14:13:43 <Rui-> yea it can be a 5x5 board, 8x8 9x6 2x10 etc
14:13:45 <tromp_> for smaller boards, bitboards are much easier to manipulate
14:13:55 <dmwit> paper_cc: Pretty much, yep.
14:14:30 <ddarius> diagonal ((x:_):xss) = x:diagonal (map tail xss)
14:15:09 <dmwit> paper_cc: From there, it's not hard to get a function to generate all the diagonals.
14:16:28 <conal> that diagonal definition looks like join in Data.Stream
14:16:44 <paper_cc> anyDiagonal (n+1) xs = anyDiagonal n $ map tail xs
14:17:08 <conal> @hackage Stream
14:17:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Stream
14:17:09 <paper_cc> (hmm. that's not any =( )
14:17:16 <dmwit> paper_cc: Don't forget the lower diagonals.
14:17:21 <pumpkin> conal: htere are two Data.Stream s :o
14:17:40 <conal> pumpkin: i think there used to be more
14:18:00 <conal> that hackage URL is the one i mean (Wouter's)
14:18:28 <paper_cc> dmwit: what's the opposite of take?
14:18:32 <pumpkin> give
14:18:45 <paper_cc> dropFirst would be better
14:18:50 <paper_cc> =)
14:18:55 <conal> @type take
14:18:56 <lambdabot> forall a. Int -> [a] -> [a]
14:18:57 <conal> @type drop
14:18:59 <lambdabot> forall a. Int -> [a] -> [a]
14:19:06 <paper_cc> aha
14:19:17 <pumpkin> how is drop the opposite though? you'd want to put back!
14:19:38 <conal> yep.
14:19:46 <paper_cc> no, I'd want to have exactly the opposite elements
14:19:48 <dmwit> paper_cc: drop
14:19:52 <dmwit> Oh.
14:19:55 <dmwit> I'm way late.
14:19:55 <pumpkin> paper_cc: opposite?
14:20:10 <paper_cc> xs = take n xs ++ drop n xs =)
14:20:11 <pumpkin> paper_cc: you want to take the last n elements?
14:20:12 <idnar> > take 5 [0..]
14:20:13 <lambdabot>   [0,1,2,3,4]
14:20:16 <idnar> > drop 5 [0..]
14:20:17 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
14:20:30 <dmwit> paper_cc: There's also splitAt.
14:20:40 <dmwit> xs = uncurry (++) (splitAt n xs)
14:20:50 <dmwit> > splitAt 5 [0..]
14:20:51 <lambdabot>   ([0,1,2,3,4],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
14:20:54 <paper_cc> dmwit: lowerDiagonal n xs = mainDiagonal . drop n
14:21:06 <dmwit> paper_cc: exactly right
14:21:10 <pumpkin> anyone have a good mnemonic for remembering what curry/uncurry do? I can never remember which is which
14:21:18 <dmwit> paper_cc: But leave that "xs" argument out. ;-)
14:21:27 <paper_cc> yes =)
14:21:43 <tromp_> why mnemonic if you can just ask :t curry?
14:21:50 <pumpkin> well, yeah
14:21:57 <pumpkin> but say I were writing haskell on a board!
14:22:04 <pumpkin> and writing :t on a board
14:22:07 <pumpkin> doesn't help me much
14:22:16 <pumpkin> and I'm too lazy to walk over to my laptop
14:22:18 <tromp_> :t curry
14:22:19 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:22:21 <Rui-> so
14:22:22 <Rui-> diagonal [] = []
14:22:23 <Rui-> diagonal ((x:y):xss) = x:diagonal (map tail xss)
14:22:23 <Rui-> lowerDiagonal n  = diagonal . drop n
14:22:23 <paper_cc> curry makes functions look as they look in Haskell, that's of Haskell Curry
14:22:24 <Rui-> ?
14:22:44 <schme> :t lambdabot
14:22:45 <lambdabot> Not in scope: `lambdabot'
14:22:57 <tromp_> curry is what introduces function returning function
14:23:05 <conal> while uncurry makes functions look uncool, as in ML
14:23:08 <pumpkin> > curry (succ *** pred) 5 6
14:23:08 <conal> ;)
14:23:09 <lambdabot>   (6,5)
14:23:18 <pumpkin> lol
14:23:39 <pumpkin> btw, something I've been meaning to ask
14:23:55 <ddarius> "What's wrong with those MLers?"
14:23:56 <pumpkin> why are those handy first, second, ***, &&& in Control.Arrow/
14:24:03 <ddarius> :t first
14:24:04 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:24:11 <pumpkin> well yeah
14:24:46 <pumpkin> I guess just because I don't use them to their full potential doesn't mean they shouldn't have it
14:25:50 <ddarius> :t loop first
14:25:51 <lambdabot>     Occurs check: cannot construct the infinite type: c = (c, d)
14:25:51 <lambdabot>       Expected type: (b, c) -> ((b, d), c)
14:25:51 <lambdabot>       Inferred type: (b, c) -> ((b, d), (c, d))
14:25:57 <ddarius> :t loop second
14:25:58 <lambdabot>     Occurs check: cannot construct the infinite type: c = (d, c)
14:25:58 <lambdabot>       Expected type: (b, c) -> ((d, b), c)
14:25:58 <lambdabot>       Inferred type: (b, c) -> ((d, b), (d, c))
14:26:00 <ddarius> :t loop
14:26:01 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
14:26:08 <paper_cc> dmwit: is there a way to write mainDiagonal without explicit recursion?
14:26:28 <ddarius> :t loop $ first ?a
14:26:29 <lambdabot> forall (a :: * -> * -> *) b c. (?a::a b c, ArrowLoop a) => a b c
14:26:31 <pumpkin> > loop (pred *** succ)
14:26:33 <lambdabot>       Overlapping instances for Show (a -> a)
14:26:33 <lambdabot>        arising from a use of `s...
14:26:46 <pumpkin> > loop (pred *** succ) 5
14:26:47 <lambdabot>   Add a type signature
14:27:23 <pumpkin> > loop (pred *** succ) (5 :: Int)
14:27:25 <lambdabot>   Add a type signature
14:27:41 <pumpkin> > loop (pred *** succ) 5 :: Int
14:27:43 <lambdabot>   Add a type signature
14:27:47 <pumpkin> :(
14:28:00 <dmwit> paper_cc: always
14:28:05 <dmwit> :t foldr
14:28:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:28:16 <ddarius> pumpkin: There's nothing constraining succ.
14:28:36 <idnar> :t succ
14:28:37 <lambdabot> forall a. (Enum a) => a -> a
14:28:59 <pumpkin> ddarius: yeah, but why does there need to be? I'm not "using" it am I?
14:29:15 <idnar> > loop (pred *** (succ :: Int -> Int)) 5
14:29:16 <lambdabot>   4
14:29:23 <ddarius> pumpkin: It still needs to generate code.  The type you have is (Enum a) => Int -> Int
14:29:31 <pumpkin> ah
14:29:33 <idnar> @type loop (pred *** succ) 5
14:29:34 <lambdabot>     Ambiguous type variable `d' in the constraint:
14:29:34 <lambdabot>       `Enum d' arising from a use of `succ' at <interactive>:1:15-18
14:29:34 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
14:29:47 <pumpkin> can't it just forget about the succ and realize the programmer is a dumbass?
14:29:48 <rwbarton_> > zipWith (!!) ["foo", "bar", "baz"] [0..]
14:29:50 <lambdabot>   "faz"
14:29:53 <idnar> I, uhm, don't understand loop
14:30:16 <baaba> @src foldr'
14:30:16 <lambdabot> Source not found. I feel much better now.
14:30:41 <baaba> @hoogle (a -> a -> a) -> [a] -> a
14:30:41 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
14:30:41 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
14:30:41 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
14:30:43 <ddarius> idnar: You have to mix the two components together to do something interesting and for the (->) arrow, loop is just a glorified fix.
14:30:47 <baaba> @src foldr1
14:30:47 <lambdabot> foldr1 _ [x]    = x
14:30:47 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
14:30:47 <lambdabot> foldr1 _ []     = undefined
14:31:30 <paper_cc> dmwit: foldr isn't going to work right away because of 'tail' at every recursion
14:33:12 <dmwit> paper_cc: You're right, it's much easier with a list comprehension:
14:33:44 <dmwit> > (\xss -> [xss !! a !! a | a <- [0..length xss - 1]]) [[1..3], [4..6], [7..9]]
14:33:45 <lambdabot>   [1,5,9]
14:33:55 <dmwit> This should be adaptable to the more generic, non-square form.
14:33:58 <pumpkin> fancy!
14:34:08 <rwbarton_> That's like my zipWith above
14:34:11 <pumpkin> yup
14:34:31 <paper_cc> rwbarton: wow
14:34:32 <dmwit> Yup, except the zipWith version is more efficient. =)
14:34:41 <dmwit> I didn't see it, thanks for pointing it out.
14:40:35 <pumpkin> what are the big haskell related conferences/journals that people submit papers to
14:40:36 <pumpkin> ?
14:40:45 <Gracenotes> @instances ArrowLoop
14:40:46 <lambdabot> (->), Kleisli m
14:41:19 <roconnor> icfp
14:43:14 <Arnar> hi all
14:43:43 <roconnor> hi
14:44:04 <paper_cc> dmwit: the (!!) versions don't seem to work on non-square boards
14:44:15 <Arnar> I need to parse a binary file with fixed-length records, with some exotic fields (dates packed in a *clever* way in 3 bytes, 24 bit ints etc).. and I know Parsec pretty well. Is Text.Parsec.ByteString for me?
14:44:17 <paper_cc> so that's not so beautiful =(
14:44:30 <pumpkin> Arnar I'd use Data.Binary
14:44:32 <pumpkin> .Get
14:44:32 <Elly> Arnar: parsec is probably not for you
14:45:13 <Arnar> pumpkin, Elly: ah, ok
14:45:17 * Arnar looks into Data.Binary
14:45:32 <chessguy> 'ello
14:45:37 <dmwit> paper_cc: Right, I did mention that.
14:45:50 <dmwit> paper_cc: It should be pretty easy to fix, but the zipWith version is better anyway.
14:47:02 <chessguy> > inits ([1..5] ++ undefined)
14:47:03 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]* Exception: Prelude.undefined
14:47:13 <paper_cc> dmwit: the zipWith version won't work too
14:47:41 <paper_cc> > (zipWith (!!)) ["abc", "foo", "bar", "xyz"]
14:47:42 <lambdabot>       Overlapping instances for Show ([Int] -> [Char])
14:47:42 <lambdabot>        arising from a ...
14:47:58 <pumpkin> you need to adjust the index
14:47:59 <paper_cc> (zipWith (!!) [0..]) ["abc", "foo", "bar", "xyz"]
14:48:05 <ozy`> :t (?)
14:48:06 <lambdabot> Not in scope: `?'
14:48:13 <paper_cc> bzzt
14:48:13 <pumpkin> and possibly the starting point, depending on where you want the diagonal
14:48:15 <paper_cc> >(zipWith (!!) [0..]) ["abc", "foo", "bar", "xyz"]
14:48:21 <rwbarton_> paper_cc: define "work"?
14:48:22 <dmwit> > zip ["foo", "bar", "baz", "quu"] [0..] >>= (\(xs, n) -> take 1 . drop n $ xs)
14:48:30 <Arnar> pumpkin: do you know any examples of Data.Binary.Get usage?
14:48:37 <paper_cc> phew
14:48:37 <BONUS_> oh you gotta flip that zipWith imho
14:48:44 * dmwit pokes \bot
14:48:46 <rwbarton_> > zipWith (!!) ["abc", "foo", "bar", "xyz"] [0..]
14:48:53 <paper_cc> lambdabot got stunned with all that =)
14:48:56 <pumpkin> Arnar: check the elf package on hackage for a clear one, I think
14:49:05 <BONUS_> i mean flip the (!!) yeah
14:49:07 <Arnar> pumpkin: great, thanks
14:49:12 <rwbarton_> ah I see
14:49:24 <dmwit> paper_cc: Try my one, anyway.
14:49:27 <paper_cc> BONUS_: yes, thanks
14:49:31 <rwbarton_> Neither did the recursive one I think
14:49:56 <paper_cc> the recursive will if you add a ([]:xs) = [] case
14:50:02 <pumpkin> , zipWith (!!) ["abc", "foo", "bar", "xyz"] [0..]
14:50:04 <rwbarton_> right
14:50:09 <lunabot>  luna: Prelude.(!!): index too large
14:50:13 <paper_cc> aha.
14:50:44 <dmwit> , zip ["foo", "bar", "baz", "xyz"] [0..] >>= (\(xs, n) -> take 1 . drop n $ xs)
14:50:45 <pumpkin> just cut off the matrix
14:50:46 <lunabot>  "faz"
14:50:49 * lispy thinks this problem should be a zipper
14:50:56 <dmwit> , zip ["foo", "bar"] [0..] >>= (\(xs, n) -> take 1 . drop n $ xs)
14:50:58 <lunabot>  "fa"
14:51:10 <paper_cc> brr
14:51:25 <paper_cc> instance Monad [] is horrifying...
14:51:34 <dmwit> Here, I'll write it without bind:
14:52:12 <dmwit> , concat . zipWith (\n xs -> take 1 . drop n $ xs) [0..] $ ["foo", "bar", "baz", "xyz"]
14:52:14 <lunabot>  "faz"
14:52:36 <dmwit> , concat . zipWith (\n -> take 1 . drop n) [0..] $ ["foo", "bar", "baz"]
14:52:38 <lunabot>  "faz"
14:53:13 <paper_cc> so take 1 . drop n is just a safe (!!)
14:53:32 <lispy> > take 10000 []
14:53:36 <lispy> > drop 1000000 []
14:53:50 * lispy kicks lambdabot 
14:53:59 <paper_cc> kick lunabot then =)
14:54:05 <pumpkin> , zipWith ((take 1 .) . drop) [0..] ["abc", "foo", "bar", "xyz"]
14:54:07 <lunabot>  ["a","o","r",""]
14:54:09 <paper_cc> @bot
14:54:09 <lunabot>  :)
14:54:12 <paper_cc> ahem
14:54:26 <pumpkin> , zipWith (head . (take 1 .) . drop) [0..] ["abc", "foo", "bar", "xyz"]
14:54:29 <lunabot>  luna: Couldn't match expected type `[a]'
14:54:33 <pumpkin> whoops
14:54:38 <dmwit> paper_cc: exactly
14:54:47 <paper_cc> looks like a quiz: "what does a function do?
14:54:53 <dmwit> pumpkin: head . take 1 is stupid.
14:54:59 <pumpkin> yeah :P
14:55:07 <rwbarton_> @pl head . take 1
14:55:10 <pumpkin> lol
14:55:14 <rwbarton_> oh right :P
14:55:15 <paper_cc> function = concat . zipWith (\n -> take 1 . drop n) [0..]
14:55:15 <pumpkin> just rub it in some more
14:55:23 <paper_cc> brr
14:55:25 <mauke> preflex: seen lambdabot
14:55:26 <preflex>  lambdabot was last seen on #haskell 7 minutes and 19 seconds ago, saying: Not in scope: `?'
14:56:01 <paper_cc> now he's not in scope, too =(
14:56:14 <paper_cc> s/he's/it's/
14:56:19 <Arnar> @hoogle Data.Word.Word8 -> Data.Word.Word16
14:56:28 <memento> ahah
14:56:34 <mauke> Arnar: fromIntegral
14:56:39 <Arnar> mauke: thx
14:56:47 <pumpkin> omg mauke's the new lambdabot!
14:56:54 <pumpkin> mauke: concat $ zipWith ((take 1 .) . drop) [0..] ["abc", "foo", "bar", "xyz"]
14:57:08 <mauke>  "skittles"
14:57:12 <pumpkin> :o
14:57:23 <rwbarton_> mauke: @pl \a x b s g w o -> b x a g o w a a a
14:57:24 <Arnar> timeout
14:57:49 <pumpkin> const .) .) . join (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . join (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) .
14:57:55 <pumpkin> or something like that
14:58:09 <pumpkin> type @more for more BS from pumpkin
14:58:19 <mauke> @less
14:58:23 <pumpkin> :(
14:59:58 <paper_cc> http://hpaste.org/13413
15:00:03 <paper_cc> needs beautifying though
15:00:10 <pumpkin> @quote Alanna
15:00:15 <pumpkin> :(
15:00:27 <mauke> preflex: quote
15:00:28 <preflex>  <hex> SEO! SEO! DAYLIGHT COME AND ME WAN GO HOME!  COME MISTER SEARCHY MAN OPTIMIZE ME KEYWORDS
15:00:39 <redditbot> OpenID for Haskell: courtesy of Trevor Elliott
15:01:19 <pumpkin> how do you ask lambdabot to remember a quote?
15:01:32 <dmwit> lowerDiagonal n = diagonal . map (drop n)
15:01:36 <pumpkin> aha
15:01:38 <dmwit> pumpkin: ?remember
15:01:43 <pumpkin> thanks :)
15:01:50 <pumpkin> @cpr
15:02:16 <dmwit> paper_cc: errr... where diagonal = mainDiagonal, of course ;-)
15:04:33 <dmwit> paper_cc: Also, you might be interested in "map mainDiagonal . tails".
15:05:10 <dmwit> > let diagonal = concat . zipWith ((take 1 .) . drop) [0..] in map diagonal . tails $ ["foo", "bar", "baz"]
15:05:15 <pumpkin> @you there?
15:05:19 <dmwit> agh
15:05:21 <dmwit> , let diagonal = concat . zipWith ((take 1 .) . drop) [0..] in map diagonal . tails $ ["foo", "bar", "baz"]
15:05:23 <lunabot>  ["faz","ba","b",""]
15:05:46 <pumpkin> who has bot powers?
15:05:57 <pumpkin> lambdabot must be saved!
15:06:51 <dmwit> , let diagonal = concat . zipWith ((take 1 .) . drop) [0..]; upperDiagonals = map diagonal . tails; diagonals xs = upperDiagonals xs ++ drop 1 (upperDiagonals (transpose xs)) in diagonals ["foo", "bar", "baz"]
15:06:53 <lunabot>  ["faz","ba","b","","or","o",""]
15:07:12 <Rui-> can some1 tell me what is wrong with this :  http://hpaste.org/13413
15:07:30 <dmwit> eh?
15:07:42 <dmwit> Oh, you mean the comment marker.
15:07:55 <dmwit> Stick a "{-" at the beginning of the second line.
15:08:04 <paper_cc> =(
15:08:18 <ozy`> > {- -}
15:08:32 <sjanssen> @botsnack
15:08:32 <lunabot>  :)
15:08:45 <rwbarton_> can I get Data.Map in lunabot?
15:09:31 <ozy`> @src (!)
15:09:42 <pumpkin> no bot
15:09:54 <ozy`> whoops
15:09:57 <rwbarton> (!) should be a class method of IArray
15:10:12 <pumpkin> <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
15:13:57 <zloog> Working on a very simple program that should talk to the network and then output "200 NEWS.GIGANEWS.COM" and then exit. When I try in ghci I get Prelude Main>EWS.COM on my screen and when I compiling it ghc throws out what appears to be linking errors
15:14:05 <zloog> does anyone know what could cause that
15:14:37 <paper_cc> Forgetting -package network will cause the last
15:14:45 <pumpkin> @botsnack
15:14:45 <pumpkinbot> :)
15:14:45 <lunabot>  :)
15:14:52 <paper_cc> o_O
15:14:58 <Raevel> are they reproducing now?
15:15:00 <pumpkin> until someone fixes lambdabot
15:15:31 <pumpkin> @quote ackbar
15:15:31 <pumpkinbot> ackbar says: it's a trap
15:15:49 <Gracenotes> hm... does Haskell use closures that aren't lexical?
15:16:11 * Gracenotes is really only used to lexical closures in other programming languages...
15:16:18 <ozy`> Gracenotes: what would give you that idea?
15:16:24 <mauke> zloog: sounds like a missing newline at the end
15:16:29 <mauke> combined with a carriage return
15:16:30 <zloog> paper_cc: Thanks, I never actually used the non interactive ghc before
15:16:42 <zloog> mauke: When doing it in ghci?
15:16:47 <mauke> generally
15:16:53 <Gracenotes> ozy`: just curious. If they're an abstraction, they shouldn't have to rely on grammar, I'd think
15:17:00 <mauke> also, don't bother with -package when there's --make :-)
15:17:16 <dmwit> Gracenotes: No, closures are lexical.
15:17:27 <zloog> Thanks, yall were right on both counts
15:17:28 <Gracenotes> oh, okay. That simplifies it a bit :)
15:17:29 <rwbarton> Gracenotes: since everything is immutable you can just think of a closure as a value like any other
15:17:46 <paper_cc> zloog: and maybe -package http or something (I don't remember
15:18:05 <dmwit> I'm also not sure why you think dynamic closures are somehow less dependent on the grammar.
15:18:27 <dmwit> paper_cc: --make pulls in the packages you need for you
15:18:48 <Gracenotes> dmwit: what do you mean by dynamic closure?
15:19:11 <dmwit> Isn't that the name for the other major kind of closure?
15:19:14 <Gracenotes> (in all likelihood a good class on programming language theory would clear this up, but I have yet to take one)
15:19:20 <dmwit> What do you call non-lexical closures?
15:19:23 <dmwit> I'm bad with names.
15:19:44 <Gracenotes> that's kind of what I'm wondering, what is the nature of a non-lexical closure
15:19:47 <philipp_> 00:14 < zloog> does anyone know what could cause that
15:19:52 <philipp_> sry
15:20:32 <paper_cc> dmwit: /me removes all these {-# OPTIONS -package #-} in files
15:20:50 <dmwit> Gracenotes: ah
15:21:05 <dmwit> Gracenotes: A dynamic closure is one where the value of the variable closed over takes the value of its caller.
15:21:11 <dmwit> s/of/in/
15:21:21 <dmwit> This is a very weird behavior, in my opinion.
15:21:26 <dmwit> For example, if you were to define
15:22:07 <dmwit> ...something that closed over the variable "xs", the value of "xs" wouldn't depend on the function defining the closure, it would depend on the function *using* the closure.
15:22:08 <dmhouse> The name "closure" seems inappropriate when it exhibits dynamic scope.
15:22:54 <dmwit> foo n = let xs = [0..n] in zipWith (+) xs
15:23:01 <mauke> let's call it ... disclosure
15:23:07 <ozy`> or openure
15:23:12 <Gracenotes> or somehing like... func xs = (\a -> map (const a) xs)?
15:23:14 <pumpkin> dmwit: there's a temporary bot
15:23:22 <pumpkin> if you want to use it
15:23:26 <dmwit> bar = let xs = [1..5] in foo 3 [1..5]
15:23:30 <dmwit> pumpkin: I don't, thanks.
15:23:33 <pumpkin> ah I see :)
15:24:07 <dmhouse> dmwit: I'm not sure that's entirely what dynamic scoping is.
15:24:10 <dmhouse> Isn't it more like:
15:24:39 <dmwit> Gracenotes: In the example I gave, a lexical closure yields bar = [1, 3, 5]; a dynamic closure would give bar = [2, 4, 6, 8, 10].
15:25:09 <dmwit> Sorry, [1, 3, 5, 7] for the lexical closure.
15:25:23 <dmhouse> x = 6; f n = x + n; y = let x = 3 in f 4;   ->   y = 7 with dynamic scoping, 10 with lexical.
15:25:45 <dmhouse> dmwit: I think in your example the local binding would shadow the one at wider scope even with dynamic scope.
15:25:46 <dmwit> dmhouse: Right, same idea.
15:26:13 <dmwit> dmwit: ah, you might be right about that
15:26:17 <dmwit> uh
15:26:23 <alexi5> hello all
15:26:25 <dmwit> That's a really stupid misfeature of tab-completion.
15:26:30 <Gracenotes> except Haskell generally doesn't support dynamic scope?
15:26:34 <dmwit> alexi5: Hiya!
15:26:40 <dmwit> Gracenotes: correct
15:26:47 <centrinia> How do mathematicians like Georg Cantor, Alan Turing, and Kurt Godel keep their sanity?
15:26:57 <dmwit> They're dead.
15:26:58 <rwbarton> s/generally/, thank god, /
15:26:58 <dmwit> It's easy.
15:27:00 <Gracenotes> what, Georg Cantor kept his sanity?
15:27:06 <alexi5> what type of applications is haskell normally used to make  ?
15:27:12 <Gracenotes> that's news to me
15:27:12 <dmwit> Hard ones!
15:27:18 <pumpkin> alexi5: good ones!
15:27:27 <centrinia> alexi5, lazy ones.
15:27:33 <Gracenotes> centrinia: all of them became deluded/insane at some point in their life, generally closer to the end
15:27:35 <dmhouse> dmwit: confirmed with Elisp: (defun f () (let ((n 1)) n))   (let ((n 2)) (f))   ->   1
15:27:50 <Cale> I don't think it's mathematics which drove Cantor mad, but probably the fact that Kronecker was a total jerk to him for years.
15:28:07 <dmwit> Cale: restart \bot! (please)
15:28:10 <alexi5> ok
15:28:11 <Cale> dmwit: okay
15:28:27 <Cale> alexi5: Lots of things.
15:28:28 <dmhouse> Also, I think closures have to be defined lexically, there's no such thing as a "dynamic closure".
15:28:32 <Cale> alexi5: It's general purpose.
15:28:49 <Cale> dmhouse: huh? A closure is just a data structure.
15:29:09 <mauke> now you're just arguing semantics
15:29:18 <Cale> dmhouse: It's some code together with an environment which may or may not be used to store the values of bindings in some lexical scope.
15:30:08 <dmhouse> Cale: can you name an example where someone means "closure" to mean code+environment which doesn't refer to a lexical subtree of a program?
15:30:28 <dmhouse> I.e. where that environment isn't a lexical one?
15:31:01 <Cale> Sure. Any of the cases where you have mutation quickly results in closure environments which don't come from any given scope.
15:31:05 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:31:12 <Cale> Also, you can use closures to implement objects.
15:32:09 <Cale> in which case the environment is filled up with values of properties, rather than the values of variables at some point in the program execution.
15:32:50 <Cale> You could also have a closure with a partial environment, leaving the other variables in the code to be dynamically bound.
15:32:51 <dmhouse> Okay. A closure is environment + code, possibly containing free variables possibly bound in the environment.
15:33:01 <dmhouse> (There's still no such thing as a "dynamic closure".)
15:33:15 <Cale> Yeah, I'm not sure what "dynamic closure" would mean.
15:34:04 <Cale> I suppose the environment, rather than being a mapping from variables to values, could be a mapping from variables to procedures for obtaining values.
15:34:21 <Cale> That's just a guess :)
15:36:53 <dmwit> ?quote avdi
15:36:53 <pumpkinbot> No quotes match. Do you think like you type?
15:36:53 <lambdabot> avdi says: I'm not sure if that's what I wanted, but... wow!  Maybe that's what I want now!
15:37:04 <pumpkin> whoops
15:37:08 <pumpkin> sorry, I'll get rid of it
15:38:00 * BMeph watches pumpkin give the pumpkinbot the pumpkinboot
15:38:09 <pumpkin> :P
15:38:14 <BMeph> :)
15:39:52 <Arnar> Data.Binary.Get.runGet expects an internal lazy bytestring.. am I not supposed to use runGet directly?
15:40:18 <mauke> ignore the "internal" part
15:40:51 <BMeph> Cale: Is there a special name for a closure, all of whose variables are to be dynamically bound? Besides this cognitively-jarring "dynamic closure"? :)
15:40:52 <Arnar> mauke: ok, so I *need* to pass it something read with Data.ByteString.Lazy.readFile then?
15:41:08 <mauke> what? no
15:41:22 <Arnar> sorry :/
15:41:34 <Arnar> it works that way though..
15:41:46 <mauke> you can pass it any lazy bytestring
15:42:08 <Arnar> ah, yes.. sorry - I should have worded my q better
15:42:37 <Arnar> (I have the answer) but I meant I have to use D.BS.Lazy.readFile and not D.BS.readFile
15:43:17 <mauke> well, you could also read the file strictly and convert later
15:43:30 <Arnar> ok, is there a reason to do that?
15:43:38 <Cale> BMeph: Well, it's basically just some code with free variables in that case...
15:43:43 <mauke> sometimes you don't want lazy IO
15:43:50 <Arnar> ok, I see
15:43:55 <dmhouse> BMeph: that doesn't really fit in with the standard notion of a closure, which is just code + a mapping of variables -> values (the environment)... I guess you could could leave the environment empty and modify the closure evaluation procedure to read scope dynamically, or something similar.
15:44:16 <Arnar> mauke: what would be the deciding factors?
15:44:27 <Arnar> e.g. in my case I have relatively small files (~3mb max)
15:45:40 <mauke> listen to your heart
15:46:09 <dmwit> I sometimes wonder what it would be like to get mauke drunk.
15:46:19 <Arnar> lol
15:47:01 <Arnar> mauke: thanks.. my brain makes more sense though, telling me that for my specific project it probably doesn't matter, but lazy IO might be unnecessary overhead for small files
15:47:28 <Cale> dmhouse: Yeah, I view a closure as that data structure alone -- how it's interpreted as a function or anything else is something separate.
15:47:41 <rwbarton> lazy IO makes it harder to manage the lifetime of file descriptors which can be a problem if you are reading many different files
15:47:54 <Cale> (and in particular, a closure is not the same thing as a first-class function -- the interface is different)
15:49:24 <NameAlreadyInUse> does anyone know anything about finite state automata?
15:49:35 <pumpkin> NameAlreadyInUse: maybe, what are you looking for?
15:49:49 <Arnar> NameAlreadyInUse: shoot
15:49:54 <NameAlreadyInUse> i am wondering how the concept is applicable in a programming context
15:50:06 <pumpkin> it's how people "run" regular expressions
15:50:10 <pumpkin> among other things
15:50:14 <NameAlreadyInUse> are there any examples of a finite state machine being used in haskell, for instance?
15:51:32 <pumpkin> http://www.di.uminho.pt/~jas/Research/HaLeX/HaLeX.html
15:51:37 <Arnar> NameAlreadyInUse: FSMs are all over the place, but often they are hidden behind some layers of abstractions
15:51:40 <Arnar> like RE's
15:52:16 <pumpkin> NameAlreadyInUse: there's all sorts of different kinds of finite state automata, anything in particular you're looking for?
15:53:45 <NameAlreadyInUse> that link is pretty good - my confusion is that i can't imagine how the mathematical description fits into a programming context
15:53:57 <pumpkin> you mean of the graph with states and transitions?
15:54:30 <pumpkin> they can be represented pretty close to the abstract model
15:55:01 <rwbarton> running a DFA is kind of like a fold
15:55:28 <NameAlreadyInUse> like this example from wikipedia (it is in C, if you don't mind): http://codepad.org/SrDwKmw7
15:55:31 <pumpkin> I imagine you could write an NFA quite nicely taking advantage of the bind operator in lists
15:55:53 <Cale> I wrote an NFA implementation using Data.Set
15:56:02 <Cale> It's quite easy.
15:56:03 <NameAlreadyInUse> what do the 3 states "before, inside, after" relate to? are they "symbols"?
15:56:15 <rwbarton> an NFA is foldM :)
15:56:24 <Arnar> this Data.Binary.Get stuff is pretty neat..
15:56:59 <Cale> http://cale.yi.org/share/Regular.hs
15:57:04 <pumpkin> NameAlreadyInUse: it's just a way of thinking about a computation, really... in this case I wouldn't call them symbols... you can think of the states as being states on a flowchart or something
15:57:21 <cads> is it possible to iterate through each of the unique ieee floating point numbers in a certain range?
15:57:25 * luqui has beef with Data.Binary
15:57:33 <Cale> That has an implementation of (epsilon) NFAs.
15:57:36 <Arnar> this Data.Binary.Get stuff is pretty neat..
15:57:38 <pumpkin> cads: I don't think so, easily, but I'd like to see that
15:57:41 <Arnar> ah sorry.. wrong window
15:57:49 <Cale> (no simplification algorithm though)
15:57:53 <pumpkin> Cale: that looks nice
15:57:55 <luqui> why didn't they tie together put and get as in the functional pearl?
15:58:02 <Heffalump> cads: it should be relatively easy to knock up yourself using encodeFloat and decodeFloat
15:58:23 <Arnar> I know this is probably pretty basic, but is there a way to "repeat" an action until it fails, collecting the successful results in a list?
15:58:33 <pumpkin> Arnar: an action?
15:58:41 <Arnar> pumpkin: a monad
15:58:45 <Arnar> e.g. an IO action
15:58:52 <Heffalump> what do you mean by fail, in that case?
15:58:53 <Heffalump> throws?
15:59:03 <NameAlreadyInUse> pumpkin: so the state is represented by either "before, inside, after", and and the transition functions would be "state = before;" and such?
15:59:03 <Arnar> Heffalump: no, just fail..
15:59:15 <Heffalump> as in the fail memory of the Monad class?
15:59:16 <Arnar> :t fail
15:59:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:59:21 <Arnar> yes
15:59:28 <Heffalump> there's no generally defined way of catching that.
15:59:37 <Heffalump> If you're in MonadPlus then it is defined.
15:59:39 <rwbarton> @quote fail
15:59:39 <lambdabot> dons says: hugs should spot the blackhole, or fail gracefully
15:59:40 <cads> Heffalump, I don't know how I'd explore the range.. yet
15:59:43 <rwbarton> @quote fail
15:59:43 <lambdabot> lambdabot says: Plugin `quote' failed
15:59:54 <Heffalump> @type decodeFloat
15:59:56 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
16:00:16 <Heffalump> cads: oh, hmm. It's fine if the exponent is the same at both ends.
16:00:25 <pumpkin> NameAlreadyInUse: here it looks like the transition function just checks if the next symbol is a space
16:00:25 <Heffalump> But otherwise you need to know the valid range of mantissas
16:00:46 <pumpkin> NameAlreadyInUse: I guess this is basically a DFA
16:00:50 <Arnar> ok.. more concrete q: I have  getFoo :: Get Foo (Get comes from Data.Binary.Get)
16:01:02 <Arnar> and I want to read a sequence of foos from a file until I hit the eof
16:01:31 <Heffalump> Arnar: ok, and what happens when it EOFs?
16:02:02 <Arnar> Heffalump: well, it is actually a bytestring, so I assume getFoo "fails"
16:03:21 <Heffalump> Arnar: is the Get monad a MonadPlus instance?
16:03:23 <Arnar> Heffalump: that seems to be the norm in Data.Binary.Get when there is not enough bytes in the bytestring
16:03:26 <Arnar> hang on
16:03:40 <rwbarton> Heffalump: I imagine you want to cook something up with isEmpty
16:03:44 <rwbarton> er, Arnar:
16:03:50 <Arnar> Heffalump: no
16:04:06 <Heffalump> ok, then I guess you need some custom function rather than a generic MonadPlus-based function.
16:04:07 <Arnar> rwbarton: ah, ok.. will do
16:04:11 <Arnar> right
16:04:14 <Arnar> np
16:04:15 <Arnar> thanks
16:04:16 <Heffalump> i.e. along the lines of rwbarton's idea
16:04:36 <Arnar> yeah.. just figured there was some higher level way of doing this for a generic monad
16:04:37 <cads> ah fuck! I need to write a minimal functional program for finding my wallet    : C
16:05:04 <Heffalump> only for ones which "fail" in a well-defined way, i.e. MonadPlus instances
16:05:08 <rwbarton> cads: filter (== wallet) universe
16:05:26 <ozy`> cads: it's exactly where you'd think is the most unintuitive place to put it, even taking into account the worst thing you could have done with it
16:06:28 <NameAlreadyInUse> pumpkin: so space is a symbol, but lets say i am not examining characters but am matching a string or something, would the string be the symbol in that case? if i change the state based on the equality of two numbers, would the numbers then be the symbols?
16:06:48 <pumpkin> you don't have to think of things as symbols necessarily
16:07:07 <pumpkin> you just have state transitions based on "stuff that happens" :P
16:08:52 <EvilTerran> NameAlreadyInUse, in the case of regexes, transitions correspond to characters in the string being matched
16:09:54 <EvilTerran> and "how far through the string we've got" is effectively an extra bit of state associated with the evaluation
16:10:07 <altmattr> trying to make an "Either Monad"
16:10:11 <cads> ozy, except any place i'd think was unintuitive to look would be the intuitive place to look if i thought of it, and therefore completely useless : (
16:10:21 <Cale> NameAlreadyInUse: You can view matching a character using a DFA as simply replacing the start state of the DFA with the state indicated by the transition at its current start state for that character.
16:10:28 <altmattr> I have a ton of code using Maybe Monad which returns 'Nothing' for an error
16:10:40 <altmattr> now I want more info in the error
16:10:42 <cads> but I found it!
16:10:52 <luqui> aleator, there already is one in Control.Monad.Error
16:10:55 <altmattr> but I can't create instance Monad Either
16:10:58 <altmattr> I figured as much
16:11:02 <altmattr> luqui:
16:11:03 <luqui> aleator, (not that it's not good practice to try)
16:11:06 <Cale> altmattr: instance Monad (Either e) where
16:11:31 <Cale> altmattr:   return x = Right x
16:11:39 <Cale> altmattr:   Left e >>= f = Left e
16:11:42 <NameAlreadyInUse> Cale: ok, i think i understand
16:11:44 <Cale> altmattr:   Right x >>= f = f x
16:12:00 <altmattr> Cale: the only bracket combo I didn't try :)
16:12:09 <roconnor> Right (f x)
16:12:09 <luqui> aye, Either has kind * -> * -> *  (two type arguments), but Monad takes types of kind * -> *, so you need to partially apply.
16:12:13 <NameAlreadyInUse> thanks for the help everyone. i will take a better look at the HaLeX link as well
16:12:17 <Cale> roconnor: nope
16:12:30 <altmattr> Cale: legend, thanks
16:12:41 <roconnor> @src Either (>>=)
16:12:41 <lambdabot> Left  l >>= _ = Left l
16:12:42 <lambdabot> Right r >>= k = k r
16:12:48 <roconnor> oh right
16:13:08 <pumpkin> are there any kinds that have something other than asterisks in them?
16:13:18 <Cale> @kind (->)
16:13:19 <lambdabot> ?? -> ? -> *
16:13:26 <Arnar> what's the language option again that lets me use type variables from a function to define the type of inner functinos?
16:13:26 <pumpkin> @kind Ord
16:13:28 <lambdabot> Class `Ord' used as a type
16:13:31 <Cale> That's a GHC-ism though.
16:13:33 <pumpkin> ah
16:13:40 <Cale> It has to do with unboxed types.
16:13:48 <pumpkin> @kind Complex
16:13:50 <lambdabot> * -> *
16:14:26 <Cale> Classes perhaps ought to have a kind as well...
16:14:42 <Cale> (but they aren't currently part of the kind system)
16:14:55 <pumpkin> what else can be in place of the asterisks? I was thinking I'd find a typeclass, but types don't usually have typeclasses restrictions on their constructors do they?
16:15:21 <Cale> pumpkin: Only a few other things which deal with unboxed types.
16:15:32 <Cale> pumpkin: At present, that's all there is to the kind system.
16:15:59 <pumpkin> ah
16:16:09 <roconnor> @sort *
16:16:10 <lambdabot> Maybe you meant: more part src
16:18:48 <roconnor> @sort (->)
16:18:48 <lambdabot> Maybe you meant: more part src
16:19:19 <Cale> There is no sort command.
16:19:33 <ddarius> There's no need for a sort system currently.
16:20:52 <dmwit> Arnar: Scoped type variables?
16:21:46 <dmwit> ?kind Int#
16:21:48 <lambdabot> Not in scope: type constructor or class `Int#'
16:21:57 <dmwit> ?kind GHC.Base.Int#
16:21:59 <lambdabot> #
16:22:05 <Arnar> dmwit: yes
16:22:19 <Arnar> dmwit: thanks
16:24:32 <memento> i starting to love haskell
16:25:15 <memento> i tried to do this with c++ and boost and now there it is
16:25:33 <hydo> memnto: you'll find that it is a recurring theme.
16:26:26 <memento> ahah yeah im sure:D
16:27:47 <memento> curiously recurring^^
16:28:29 <hoknamahn> http://www.hoknamahn.com/3.14159/water2.mp4
16:28:33 <hoknamahn> haskell in action
16:28:46 <hoknamahn> my first program in haskell :)
16:29:36 <pumpkin> http://codegolf.com/saving-time
16:30:15 <pumpkin> no haskell on leaderboard!
16:30:58 <hydo> hoknamahn: there's something mesmerizing about that.  Then again, I had it playing in a loop at 2560x1600 so I guess most things would be at that size.
16:31:45 <hoknamahn> hydo, problems with codec?
16:32:09 <hydo> hoknamahn: no, it works just fine.
16:32:33 <hoknamahn> okay cool
16:32:45 <hydo> I have a thing for water and cloth simulation... hence the mesmerizing factor, I guess.
16:33:58 <hoknamahn> maybe not enough samples
16:34:19 <hoknamahn> timestep could be smaller. anyway it was fun
16:35:56 <memento> pumpkin: You're not just limited to Perl either - PHP, Python and Ruby are all available too.
16:36:17 <pumpkin> they only allow those though :/
16:36:19 <pumpkin> that's mean
16:48:50 <chrisdone> `printf's arg list bytes me in the butt all the time
16:49:08 <chrisdone> "too few" or "too many" or "wrong type"
16:49:11 <mmorrow> use the TH printf. it'll highly superior
16:49:12 <chrisdone> is there a type-safe alternative?
16:49:17 <mmorrow> yesh
16:49:18 <chrisdone> zomg
16:49:26 <chrisdone> is it on hackage?
16:49:34 <mmorrow> i think there's one on hackage. i also pasted one a while ago
16:49:37 * mmorrow finds link
16:49:39 <mauke> or write a few programs in C
16:49:44 <mauke> that'll learn you to printf :-)
16:49:48 <osfameron> oooo, I met someone this evening that a) liked Perl and b) had studied haskell in his CS/Eng degree and liked it (though didn't believe you could use it for real world stuff)
16:49:48 <mmorrow> heh
16:50:03 <ddarius> It's highly superior until you want to pass in a format string at run-time !
16:50:47 <chrisdone> mauke: I know how to use printf, I just make mistakes. besides, gcc at least and other compilers tell you if your printf is wrong, IIRC
16:50:48 <mmorrow> ddarius: but non-TH printf cannot do that typesafely
16:51:44 <mmorrow> ddarius: if haskell could do dependent types, all of our problems would be solved, polar bears and penguins would get along, no one would be hungry, and i'd wake up tomorrow to find a ferrari in my parking spot.
16:51:50 <ddarius> chrisdone: Clearly the solution is for you to stop making mistakes.
16:52:12 <mauke> ddarius: that's what I do!
16:52:13 <chrisdone> I use a `query "SELECT .. WHERE foo = ? AND x > ?" [toSql value1, toSql value2] kind of thing to ensure type-safety for my sql stuff, but sadly the parameter length is still an issue
16:53:18 <Heffalump> mmorrow: how could even dependent types help if you wanted to pass in a format string at runtime?
16:53:24 <mmorrow> that's a bitch. i have a (select only) sql parser that works kind of. i need to clean that up and put it somewhere so maybe someone can help make it nice :)
16:53:51 <mmorrow> Heffalump: i don't know, but apparently that's possible (so people claim)
16:54:11 <Heffalump> you'd have to do the type-checking at runtime too
16:54:17 <chrisdone> ddarius: it's not like it happens often, it's just annoying when it does
16:54:19 <mmorrow> that's what i said!
16:54:23 <Heffalump> I guess a compiler that left around bits of type-checking to be done at runtime could do it.
16:54:29 <pumpkin> can anyone see a way of making this shorter?
16:54:30 <pumpkin> main=mapM(print.(\n->foldl1 lcm[1..(read n)]))=<<fmap lines getContents
16:54:38 <Heffalump> But a type error at runtime doesn't fit my definition of a type error, really.
16:54:48 <mmorrow> Heffalump: i guess so too. i'm very confused about some of the things i've been told one can do with dependent types.
16:54:52 <mmorrow> (at run time)
16:55:05 <Heffalump> in what way is creating world peace confusing?
16:55:07 <mauke> :t \n -> [1..read n]
16:55:08 <lambdabot> forall t. (Enum t, Read t, Num t) => String -> [t]
16:55:11 <mmorrow> Heffalump: heh
16:55:15 <sjanssen> pumpkin: main=mapM(print.(\n->foldl1 lcm[1..(read n)])).lines=<<getContents
16:55:17 <mauke> pumpkin: remove ( )
16:56:18 <mmorrow> chrisdone: not complete (wrt all the formatters) but easily made so: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=484#a485
16:56:19 <pumpkin> nice thanks :)
16:56:21 <mauke> main=mapM(\n->print$foldl1 lcm[1..read n]).lines=<<getContents
16:56:29 <sjanssen>    main=mapM(print. \n->foldl1 lcm[1..read n]).lines=<<getContents
16:57:03 <sjanssen> hmm, how about interact?
16:57:09 <pumpkin> ooh
16:57:25 <pumpkin> good idea
16:57:43 <mauke> interact$map(\n->show$foldl1 lcm[1..read n]).lines
16:57:54 <mauke> no, wait
16:57:57 <mauke> needs more unlines
16:58:26 <pumpkin> doesn't interact already do the lines?
16:58:36 <sjanssen> no
16:58:37 <mbz> @src interact
16:58:37 <lambdabot> interact f = do s <- getContents; putStr (f s)
16:58:39 <sjanssen> @type interact
16:58:40 <lambdabot> (String -> String) -> IO ()
16:58:43 <pumpkin> oh I see
16:58:55 <chrisdone> mmorrow: cheers, ears
16:59:36 <mmorrow> chrisdone: i heard that
16:59:54 <ddarius> Heffalump: There is a difference between static type checking at run-time and dynamic typing.
17:29:54 <Axman6> my RWH just arrived!
17:30:53 <rwbarton> Crazy idea: make "f x" be syntactic sugar for "apply f x", where apply :: Apply a b c => a -> b -> c
17:31:16 <sbahra> Why would that be useful?
17:32:03 <rwbarton> Well, if you have some value (say, an algebraic data type representation of a function) that you want to be able to apply directly
17:32:29 <luqui> rwbarton, but what if I wanted it to mean apply `apply` f `apply` x ? :-)
17:32:33 <sbahra> rwbarton, ah
17:32:43 <luqui> it's like Coq's coercions.  which can be handy...
17:32:56 <luqui> I think you'd run into gross inference issues though
17:33:17 <rwbarton> hmm, probably.  Gross type errors, certainly
17:33:37 <ray> eww, gross
17:35:09 <Heffalump> rwbarton: I found myself wanting precisely that recently
17:35:13 <mmorrow> heh, apply f x ==> apply .... (apply ... (apply ... apply) ... f) x
17:35:29 <Heffalump> mmorrow: no, in the same way that 5 ==> fromInteger 5 stops there
17:35:31 <mmorrow> assuming the application it tranforms to is the same
17:36:00 <mmorrow> yeah, you'd probably have to implem that in the compiler
17:36:20 <mmorrow> or else it'd be like a runaway rewrite rule
17:36:38 <rwbarton> Heffalump: Really?  Huh.
17:37:00 <rwbarton> Heffalump: I think I'm just going to name my eval function (Formula a b -> a -> b) '$$'
17:37:18 <Heffalump> rwbarton: I've been messing around with something that manipulates expressions a lot. So I have a concrete representation of functions, which I then find myself wanting to apply.
17:37:33 <rwbarton> Heffalump: Yep, same here
17:37:38 <mmorrow> that'd definitely be cool if there was a way to do this
17:38:16 <Heffalump> though since I haven't actually got round to overloading anything else (like arithmetic or boolean operators), I obviously don't care that much :-)
17:39:08 <ddarius> Heffalump: Some forms of behavioural reflection work by hooking the "apply" action of the language.
17:39:10 <mmorrow> we need a supriseMe function that surprises you by doing exactly what you didn't even know you wanted until it does it.
17:39:34 <mmorrow> i wonder that type it would have
17:39:35 <Heffalump> ddarius: sure.
17:40:05 <rwbarton> Heffalump: Overloading boolean operators?  You mean hiding Prelude.&& and making a new one as a method of some class?
17:40:08 <EvilTerran> that's GHC.Exts.dwim :: a
17:40:13 <Heffalump> rwbarton: yes
17:40:16 <ddarius> mmorrow: IO ().  It would just cause your computer to explode, though it may take a little longer for you to realize that's what you wanted that perhaps you intended.
17:40:59 <mmorrow> ddarius: isn't that GHC.Exts.explodes :: IO () though?
17:41:12 <rwbarton> With overlapping and incoherent instances maybe you could just make your formula type an instance of Apply in an appropriate way :)
17:42:35 <Heffalump> I don't follow what that would achieve.
17:42:35 <dmwit> "Incoherent instances" is such a good name for an extension.
17:43:33 <rwbarton> e.g. if x :: Formula a b and f :: b -> c have an instance Apply (b -> c) (Formula a b) (Formula a c) with apply = fmap
17:43:51 * luqui wants to rename UndecidableInstances to UndecidableInstancesDontBeSurprisedWhenTheCompilerDoesntTerminateThatsWhatUndecidableMeansSilly
17:44:02 <Heffalump> oh, right
17:44:05 <rwbarton> luqui: I know, that email made me laugh :)
17:44:14 <Heffalump> I don't think I'd be too fussed about also being able to use normal functions.
17:44:23 <knabb> how would I write dec as an minlambda, map (+2) [1..10] but (-1) doesnt work...
17:44:34 <Heffalump> I could just make everything live in my Formula universe.
17:44:51 <Heffalump> knabb: (`subtract` 1)
17:45:02 <ddarius> subtract 1
17:45:07 <Heffalump> err, yes, that
17:45:16 * Heffalump gets his argument order confused
17:45:56 <knabb> and if i want to square I need the whole (\x -> x*x) ?
17:46:08 <Heffalump> or something obfuscated like join (*)
17:46:10 <knabb> there is no shorthand like (% * %)
17:46:16 <EvilTerran> why not (^2)?
17:46:17 <Heffalump> there's no shorthand, no
17:46:32 <EvilTerran> > (^2) x
17:46:33 <lambdabot>   x * x
17:46:57 <ozy`> knabb: you can do map ((-) 1) [1..10]
17:47:05 <knabb> EvilTerran: ok but raised to the power of itself then?
17:47:46 <ddarius> > join (^) x
17:47:47 <Olathe> (subtract 1)
17:47:50 <Heffalump> ozy`: only if you want to calculate [1-1, 1-2, 1-3, ...]
17:48:00 <EvilTerran> knabb, indeed, there's no syntactic sugar for doing (\x -> x OP x) regardless of what OP is
17:48:10 <Olathe> > map (subtract 1) [1..5]
17:48:15 <ddarius> > join (^) x
17:48:16 <Heffalump> but you can use the join trick regardless of what OP is
17:48:20 <lambdabot>   [0,1,2,3,4]
17:48:43 <Olathe> subtract 1 subtracts one.
17:48:46 <EvilTerran> knabb, but you can fairly easily define a function to do (\op x -> x `op` x) if you like
17:48:58 <ddarius> > subtract 1 x
17:49:02 <EvilTerran> join happens to do this
17:49:05 * ddarius breaks the bot.
17:49:08 <lambdabot>   x - 1
17:49:09 <EvilTerran> ?bot
17:49:16 <lambdabot> :)
17:49:17 <sbahra> > map (+ x) [1 .. 10]
17:49:26 <lambdabot>   [1 + x,2 + x,3 + x,4 + x,5 + x,6 + x,7 + x,8 + x,9 + x,10 + x]
17:49:33 <EvilTerran> ddarius, i believe ^ doesn't work with a simple-reflect value on the right, unfortunatley
17:49:42 <EvilTerran> > 1 ^ x
17:50:03 <sbahra> :(
17:50:25 <Olathe> That's because (^) is defined evilly.
17:50:29 <EvilTerran> maybe we should stop doing that
17:50:35 <Gracenotes> > foldr1 (+) [x..x+4]
17:50:53 <sbahra> It's dead/dying.
17:50:56 <EvilTerran> Olathe, i was more under the impression that it was because the Eq instances for simple-reflect don't work right
17:51:02 <EvilTerran> ?bot
17:51:21 <rwbarton> , x
17:51:31 <lunabot>  x
17:51:37 <rwbarton> , x == 0
17:51:38 <Olathe> Well, (+) is a class function. (^) is defined on its own.
17:51:40 <sbahra> , map (+ x) [1 ..]
17:51:41 <lunabot>  False
17:51:45 <lunabot>  [1 + x,2 + x,3 + x,4 + x,5 + x,6 + x,7 + x,8 + x,9 + x,10 + x,11 + x,12 +...
17:51:50 <rwbarton> , even x
17:51:54 <lunabot>  False
17:51:57 <sbahra> , odd x
17:52:01 <lunabot>  True
17:52:06 <sbahra> :X
17:52:15 <ddarius> sbahra: x is obviously odd
17:52:16 <BONUS_> @src ()
17:52:23 <BONUS_> @src (^)
17:52:48 <Olathe> > let plus a 0 = a; plus a b = plus a (b - 1) in plus 1 x
17:53:01 <Olathe> I think the bot is dead :(
17:53:06 <Olathe> @bot
17:53:06 <lunabot>  :)
17:53:13 <roconnor> :)
17:53:20 <Olathe> Yay, roconnor is running !
17:53:37 <Olathe> roconnor: let plus a 0 = a; plus a b = plus a (b - 1) in plus 1 x
17:53:52 <roconnor> True
17:53:57 <sbahra> haha
17:54:10 <ddarius> Olathe: That clearly loops forever.
17:54:30 <sbahra> roconnor: 1
17:54:41 <roconnor> False
17:54:54 <Gracenotes> roconnor: reboot
17:54:58 <Gracenotes> something's wrong :/
17:55:10 <ddarius> roconnor: True
17:55:41 <sbahra> heh
17:55:50 <Olathe> How often does lambdabot's machine restart it ?
17:56:06 <sbahra> @help
17:56:22 <Olathe> sbahra: I need somebody !
17:56:41 <sbahra> So does lunabot have a help command?
17:56:43 <mmorrow> roconnor: runST (unsafeSTToIO (System.system "irc -s chat.freenode.net -c #haskell"))
17:56:45 <pumpkin> did lambdabot die again?
17:56:59 <mmorrow> crap
17:57:06 <mmorrow> s/STToIO/IOToST/
17:57:11 <pumpkin> @botsnack
17:57:11 <lunabot>  :)
17:57:14 <Gracenotes> and while we're at it... could someone @pl \a b->f (g a b)? :P I always forget what the idiom is
17:57:20 <Olathe> Yes, lambdabot is dead...again.
17:57:26 <pumpkin> pumpkinbot to the rescue!
17:57:34 <sbahra> wat
17:57:34 <Olathe> Gracenotes: (f.).g
17:57:38 <roconnor> The program 'irc' can be found in the following packages:
17:57:39 <roconnor>  * tirc
17:57:39 <roconnor>  * epic4
17:57:39 <roconnor>  * sirc
17:57:39 <roconnor>  * ircii
17:57:39 <roconnor> Try: sudo apt-get install <selected package>
17:57:43 <roconnor> :)
17:57:47 <Gracenotes> pumpkin has been preparing for this day his whole life
17:57:49 <pumpkin> @pl \a b->f (g a b)
17:57:49 <pumpkinbot> (f .) . g
17:57:53 <Gracenotes> Olathe: thanks :)
17:57:58 <Olathe> You're welcome :)
17:57:59 <roconnor> (f .) . g
17:58:01 <knabb> where is join? in which module?
17:58:02 <pumpkin> Gracenotes: lol, I brought it onto freenode earlier today when lambdabot failed
17:58:02 <Olathe> > x + 1
17:58:04 <pumpkinbot>   x + 1
17:58:08 <roconnor> x + 1
17:58:09 <Olathe> > let plus a 0 = a; plus a b = plus a (b - 1) in plus 1 x
17:58:11 <mmorrow> roconnor: heh
17:58:15 <roconnor> <<loop>>
17:58:17 <sbahra> Cool pumpkin
17:58:19 <Olathe> Yep, it can't do that one either.
17:58:23 <pumpkin> did you kill my bot too?
17:58:25 <pumpkinbot>   thread killed
17:58:29 <sbahra> pumpkin, how much memory is pumpkinbot taking right now?
17:58:33 <Olathe> So, since (^) is defined outside a class, it's not going to work with x on the right.
17:58:36 <pumpkin> sbahra: not sure, let me look
17:58:39 <Olathe> > 1 + 1
17:58:41 <pumpkinbot>   2
17:58:41 <roconnor> 2
17:58:45 <sbahra> > map ((.) x) [1 ..]
17:58:46 <pumpkinbot>   Couldn't match expected type `b -> c' against inferred type `Expr'
17:58:49 <Olathe> > exp 1 + 5
17:58:51 <pumpkinbot>   7.718281828459045
17:58:52 <Gracenotes> @unpl (. f) . g
17:58:53 <pumpkinbot> (\ d i -> g d (f i))
17:58:54 <pumpkin> lol, mueval is taking 100% cpu
17:58:55 <roconnor> type error
17:58:55 <Olathe> Do that, roconnor !
17:58:58 <Olathe> Hahaha
17:59:04 <pumpkin> about 100 megs of RAM
17:59:05 <knabb> where is join? in which module?
17:59:10 <Olathe> @index join
17:59:10 <pumpkin> @hoogle join
17:59:10 <pumpkinbot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:59:10 <pumpkinbot> Control.Monad join :: Monad m => m (m a) -> m a
17:59:10 <pumpkinbot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
17:59:10 <pumpkinbot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
17:59:11 <sbahra> @hoogle join
17:59:12 <pumpkinbot> Control.Monad join :: Monad m => m (m a) -> m a
17:59:12 <pumpkinbot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
17:59:14 <pumpkinbot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
17:59:16 <roconnor> Control.Monad
17:59:20 <sbahra> heh
17:59:31 <pumpkin> mueval has issues with certain code I guess?
17:59:48 <ziman> roconnor: let nonGoldbach n = null [(a,b) | a <- takeWhile (<n) primes, let b = n - a, isPrime b] in any nonGoldbach [4,6..]
17:59:50 <pumpkin> I killed that one
17:59:51 <ziman> :)
17:59:52 <Olathe> Yes, mueval seems to be incredibly buggy.
17:59:53 <mm_freak> > fix id 0
17:59:54 <mmorrow> @version
17:59:55 <pumpkinbot> lambdabot 4.2.2
17:59:55 <pumpkinbot> darcs get http://code.haskell.org/lambdabot
17:59:55 <pumpkinbot>   mueval: Prelude.read: no parse
17:59:55 <pumpkinbot>  mueval: *** Exception: stack overflow
18:00:03 <pumpkin> I just killed a mueval
18:00:07 <pumpkin> I'm not sure if that was bad :P
18:00:09 <mmorrow> > fix id
18:00:09 <roconnor> True
18:00:11 <pumpkinbot>   mueval: Prelude.read: no parse
18:00:11 <pumpkinbot>  mueval: *** Exception: stack overflow
18:00:11 <mmorrow> > fix error
18:00:13 <mmorrow> > fix id
18:00:14 <pumpkin> but it was gobbling up ram and cpu
18:00:16 <pumpkinbot>   mueval: Prelude.read: no parse
18:00:16 <pumpkinbot>  mueval: *** Exception: stack overflow
18:00:17 <mmorrow> > fix id
18:00:19 <pumpkinbot>   mueval: Prelude.read: no parse
18:00:19 <pumpkinbot>  mueval: *** Exception: stack overflow
18:00:20 <Olathe> > fix roconnor
18:00:21 <pumpkinbot>   mueval: Prelude.read: no parse
18:00:22 <mm_freak> > fix id 0
18:00:24 <pumpkinbot>   mueval: Prelude.read: no parse
18:00:24 <pumpkinbot>  mueval: *** Exception: stack overflow
18:00:27 <pumpkinbot>   thread killed
18:00:30 <pumpkin> my bot has some odd issues
18:00:32 <roconnor> no parse
18:00:42 <mmorrow> pumpkin: is mueval leaking zombies?
18:00:50 <roconnor> brainzzzzzzzzz
18:01:00 <pumpkin> mmorrow: yeah
18:01:08 <pumpkin> and there's a live one eating my CPU and memory too
18:01:13 <pumpkin> even though I killed the last one
18:01:18 <mmorrow> there has to _some_ piece of code that's calling forkProcess and not calling waitpid on the kid
18:01:37 <mmorrow> last time i looked though there was no calls to forkProcess
18:01:52 <mmorrow> i don't understand howtf the zombies are showing up
18:01:58 <pumpkin> I killed this one too
18:02:06 <mmorrow> oh, maybe it's from hint
18:02:14 <mmorrow> hmm
18:02:21 <pumpkin> hint?
18:02:26 <mmorrow> mueval uses hint
18:02:27 <sbahra> pumpkin, how much was it gobbling up?
18:02:39 <Olathe> Apparently, hint is a bad idea.
18:02:54 <pumpkin> sbahra: not that much, 100 megs the first time, around 60 the second time
18:02:56 <pumpkin> but 100% cpu
18:03:01 <pumpkin> and the memory was going up slowly
18:03:02 <sbahra> Ok.
18:03:36 <mmorrow> pumpkin: throw some rlimits on that thing!
18:03:41 <mmorrow> , fix id
18:03:43 <lunabot>  luna: out of memory (requested 2097152 bytes)
18:04:03 <knabb> Am I the only one who thinks Haskell is the best language in theory but in reality prefer other ones? I'm much more productive in Clojure even though I sometime shave to wade through Javadocs.
18:04:05 <mmorrow> , foldl' (+) 0 [0..]
18:04:11 <lunabot>  Killed.
18:04:26 <mmorrow> knabb: yes, you are. :)
18:05:07 <mmorrow> pumpkin: System.Posix.Resource
18:05:10 <pumpkin> ?
18:05:21 <mmorrow> though i think mueval is using that
18:05:39 <mmorrow> maybe you want to set the hard limits a little lower than what they are currently
18:05:46 <mmorrow> > fix id
18:05:47 <pumpkinbot>   mueval: Prelude.read: no parse
18:05:47 <pumpkinbot>  mueval: *** Exception: stack overflow
18:05:50 <pumpkin> you know what file that's in?
18:05:53 <mmorrow> fix error
18:05:55 <mmorrow> > fix error
18:06:04 <mmorrow> pumpkin: i don't recall, but i'll look
18:06:06 <pumpkin> also, while people are checking my bot
18:06:08 <pumpkin> :P
18:06:11 <pumpkinbot>   thread killed
18:06:18 <pumpkin> > second succ (1,5)
18:06:20 <pumpkinbot>   mueval: Prelude.read: no parse
18:06:24 <pumpkin> :t second
18:06:25 <pumpkinbot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
18:06:28 <sbahra> > map (+ 1) [1 ..]
18:06:30 <pumpkinbot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
18:06:37 <pumpkin> what's up with my arrow functions not working?
18:06:40 <mmorrow> pumpkin: does "fix error" birth a zombie?
18:06:44 <mmorrow> > fix error
18:06:44 <mmorrow> > fix error
18:06:45 <mmorrow> > fix error
18:06:46 <pumpkinbot>  Terminated
18:06:46 <pumpkinbot>  Terminated
18:06:55 <sbahra> @hoogle fix
18:06:55 <pumpkinbot> Data.Function fix :: (a -> a) -> a
18:06:55 <pumpkinbot> Control.Monad.Fix fix :: (a -> a) -> a
18:06:55 <pumpkinbot> module Control.Monad.Fix
18:06:59 <pumpkinbot>   thread killed
18:07:07 <mmorrow> fix f = f (fix f)
18:07:09 <mmorrow> or
18:07:15 <mmorrow> fix f = let x = f x in x
18:07:19 <pumpkin> mmorrow: yeah, two of them
18:07:22 <pumpkin> lol
18:07:23 <mmorrow> (the second one compiles to better code)
18:07:28 <sbahra> Prelude> :module +Data.Function
18:07:28 <sbahra> Bad interface file: /usr/local/lib/ghc-6.8.3/lib/base-3.0.2.0/Data/Function.hi
18:07:28 <sbahra>     magic number mismatch: old/corrupt interface file?
18:07:28 <sbahra> Prelude> Segmentation fault: 11 (core dumped)
18:07:37 <sbahra> Happens to me every once in a while.
18:07:42 <mmorrow> pumpkin: hmm, i think it has to be something with hint/ghc-api then.
18:07:56 <Olathe> I get lambdabot giving me spurious parse errors every once in a while.
18:08:00 <pumpkin> 29488 pts/2    ZN+    1:36 [mueval] <defunct>
18:08:00 <mmorrow> sbahra: ugh.
18:08:01 <pumpkin> mmm
18:08:04 <Olathe> It's quite nice.
18:08:16 <sbahra> mmorrow, nod, no idea why it happens (interface file is fine)
18:09:04 <mmorrow> sbahra: yeah, i hate those errors. they're usually something that has nothing to do with an interface file and is totally hard to figure out :(
18:11:04 <mmorrow> pumpkin: http://code.haskell.org/mubot/mueval/Mueval/Resources.hs
18:11:17 <Arnar> how do I get a String from a ByteString with a null-terminated string in it?
18:11:58 <mmorrow> B.takeWhile (/= 0) -- ?
18:12:14 <mmorrow> (or '\0' is you're using .Char8)
18:14:00 <mmorrow> pumpkin: i just looked and it looks like mueval's default memory usage limit is 6^12
18:14:08 <mmorrow> lunabot is using 150000000
18:14:15 <mmorrow> , 6^12
18:14:17 <lunabot>  2176782336
18:14:18 <mmorrow> , 150000000
18:14:20 <lunabot>  150000000
18:14:22 <Olathe> > 150000000
18:14:23 <pumpkinbot>   150000000
18:14:24 <mmorrow> yikes
18:14:29 <Olathe> Now pumpkinbot is too !
18:14:45 <ozy`> > 1_000
18:14:47 <pumpkinbot>   mueval: Prelude.read: no parse
18:14:50 <ozy`> damn
18:14:55 <sbahra> > 150000000000000000000000000000000000000.1
18:14:57 <pumpkinbot>   1.5e38
18:15:03 <Arnar> mokus: thx
18:15:06 <cads> tonight :: Programmer a => a -> alcohol -> (Drunken a, RighteousCode)
18:15:21 <rwbarton> > floor 150000000000000000000000000000000000000.1
18:15:23 <pumpkinbot>   150000000000000006067947700923341471744
18:15:34 * cads begins implementing
18:15:44 <sbahra> tonight >> tomorrow
18:15:44 <mmorrow> > maxBound :: Int
18:15:46 <pumpkinbot>   9223372036854775807
18:15:46 <sbahra> In my experience :-P
18:15:49 <Olathe> tonight :: Me a => a -> (GoodTime, Ball) -> Unstoppable
18:15:52 <pumpkin> mmorrow: what should I change those limits to then?
18:15:59 <mmorrow> one sec
18:16:05 <pumpkin> much smaller than 6^12?
18:16:09 <pumpkin> why base 6??
18:16:59 <roconnor> 6 fingers
18:17:17 <leimy> of whisky?
18:17:26 <mmorrow> pumpkin: i'd do:
18:17:30 <mmorrow> totalMemoryLimitSoft = ResourceLimit (15*10000000)
18:17:32 <mmorrow> and
18:17:39 <mmorrow> totalMemoryLimitHard = ResourceLimit (15*10000000)
18:17:55 <mmorrow> and see if that's ok for mueval (it might be too low, i'm not sure)
18:18:27 <mmorrow> i had to fiddle with lunabot a bit to find the smallest limit that doesn't prevent reasonable stuff to run
18:18:43 <mmorrow> s/to run/from finishing/
18:18:56 <pumpkin> that's 150 megs?
18:19:09 <mmorrow> i'm not sure actually :)
18:19:18 <mmorrow> it's bytes
18:19:32 <pumpkin> so roughly 150 megs minus the base discrepancy?
18:19:54 <mmorrow> wow, i guess you're right
18:20:00 <pumpkin> it's less than the 2 gigs before
18:20:02 <pumpkin> :P
18:20:06 <pumpkin> okay, I recompiled it
18:20:06 <mmorrow> (holy crap, ghc is a beast)
18:20:13 <pumpkin> I shouldn't have to relaunch lambdabot, right?
18:20:24 <mmorrow> i'm not sure, probably not
18:20:35 <mmorrow> > fix error
18:20:45 <mmorrow> > 42
18:20:46 <pumpkinbot>   42
18:20:50 <pumpkinbot>   thread killed
18:20:56 <mmorrow> > fix id
18:20:58 <pumpkinbot>   mueval: Prelude.read: no parse
18:20:58 <pumpkinbot>  mueval: *** Exception: stack overflow
18:21:15 <mmorrow> hmm, i don't know why thast fix id stack overflows while ghc-6.10 does
18:21:17 <mmorrow> , fix id
18:21:18 <pumpkin> 29655 pumpkin   39  19 87616  58m  22m R   89  5.7   0:07.18 mueval
18:21:18 <pumpkin> that fix error one is still running
18:21:20 <lunabot>  luna: out of memory (requested 2097152 bytes)
18:21:27 <pumpkin> even though it says thread killed
18:21:38 <mmorrow> pumpkin: ugh, hint is scaring me
18:22:06 <mmorrow> pumpkin: i'm gonna look at the hint code
18:22:10 <pumpkin> http://hpaste.org/13421
18:22:16 <pumpkin> that's as of a few seconds ago
18:22:23 <pumpkin> using 90ish% of cpu
18:22:43 <mmorrow> pumpkin: hmm, i guess that means that mueval's rlimits are useless against the code hint's running
18:22:53 <pumpkin> well I haven't hit the memory limit yet
18:23:03 <Olathe> > take 8.map (\x -> chr $ x mod 26 + ord 'A').randoms.mkStdGen $ 5
18:23:05 <pumpkinbot>       No instance for (Random ((a -> a -> a) -> t -> Int))
18:23:05 <pumpkinbot>        arising fro...
18:23:07 <mmorrow> there's a cputime rlimit as well
18:23:11 <pumpkin> ah, I didn't see that
18:23:17 <mmorrow> looks like 5 seconds hard
18:23:20 <Olathe> > randoms.mkStdGen $ 5
18:23:22 <pumpkinbot>   [7776561651304326943,2660592214809256573,-198934792153589140,-4772860058847...
18:23:41 <sbahra> > randoms.mkStdGen 5
18:23:43 <pumpkinbot>   Couldn't match expected type `a -> b'
18:23:45 <Olathe> > take 8.map (\x -> chr $ mod x 26 + ord 'A').randoms.mkStdGen $ 5
18:23:46 <pumpkinbot>   "XBOBUVQY"
18:23:50 <sbahra> :t randoms.mkStdGen
18:23:51 <pumpkinbot> forall a. (Random a) => Int -> [a]
18:24:32 <sbahra> adu cipher
18:26:43 * cads learned today that haskell functions really only ever take one argument
18:26:59 <sbahra> is cool
18:27:03 <cads> now pointless style makes sense
18:27:11 <cads> to a certain point
18:27:14 <Gracenotes> cads: I was somewhat shocked when I learned that, a few weeks ago...
18:27:38 <loupgaroublond> are all packages on hackage in .tar.gz format?
18:28:04 * shapr boings
18:28:06 <sbahra> As far as I've seen
18:28:08 <sbahra> Hi shapr
18:28:14 <shapr> hiya sbahra
18:29:11 <pumpkin> mmorrow: could that be related to the fact that I can't ctrl+c out of those expressions in ghci?
18:29:46 <sbahra> pumpkin, sounds more like a terminal issue
18:29:48 <pumpkin> I've been trying to work out what kinds of things are uninterruptible
18:29:54 <sbahra> Oh
18:29:56 <pumpkin> sbahra: I can ctrl+c out of most things
18:29:59 <sbahra> Those expressions
18:30:00 <pumpkin> but when it gets going
18:30:03 <pumpkin> it just won't stop :P
18:30:08 <sbahra> Sorry :) I've been jetlagged these days
18:30:12 <pumpkin> it's like pringle
18:30:13 <pumpkin> pringles
18:30:15 <sjanssen> loupgaroublond: yes, it is a requirment I believe
18:30:18 <cads> does ctrl-d work?
18:30:19 <pumpkin> :)
18:30:20 <sbahra> heh
18:30:26 <pumpkin> cads: nope
18:30:38 <cads> kill -9?
18:30:42 <mbz> try Ctrl-\
18:30:43 <pumpkin> yeah, I can kill it
18:30:59 <pumpkin> I just need to be able to type in kill in another terminal before it eats up all my ram :)
18:31:10 <georgevdd> qq: is hsgnutls at all reliable, and is anyone working on a pure Haskell TLS implementation?
18:31:27 <mmorrow> pumpkin: yes, it's exactly related to that.
18:31:29 <pumpkin> ctrl+z stops it
18:31:33 <pumpkin> and then I can kill it
18:31:50 <mbz> pumpkin, have you tried ctrl+\ ?
18:31:57 <pumpkin> mbz: what does that do?
18:32:11 <mbz> sends sigquit
18:32:12 <pumpkin> mmorrow: maybe lambdabot needs to take the initiative and kill its misbehaving children after a while?
18:32:15 <mbz> iirc.
18:32:34 <pumpkin> it ignores that too
18:32:55 <pumpkin> (just tried it)
18:33:55 <mmorrow> pumpkin: i think the crux is that whoever is forking the mueval processes (real threads) has to call waitpid on the kids once they die, or else zombies occur
18:34:06 <pumpkin> ah
18:34:24 <mmorrow> and it doesn't look like anyone is forkProcess'ing
18:34:30 <pumpkin> are there any active maintainers on lambdabot right now, or is it just a "whoever's looking at it" project?
18:34:32 <mmorrow> which is wtf x10
18:34:49 <Olathe> pumpkin: I think Cale's the guy.
18:35:04 <Olathe> At least, that's what the wiki says.
18:35:04 <mmorrow> pumpkin: Cale's the maintainer, but i think that is "fixes it when it doesn't run at all"
18:35:10 <Olathe> Yeah.
18:35:31 <mmorrow> it doesn't look like anyone is looking into the cause of the zombie
18:35:32 <mmorrow> s
18:39:01 <pumpkin> so I mean
18:39:03 <pumpkin> in something like http://code.haskell.org/lambdabot/Plugin/Eval.hs
18:39:08 <pumpkin> where it popens it
18:39:14 <pumpkin> clearly the timelimit mueval has isn't working
18:39:20 <pumpkin> but lambdabot could compensate and just kill it?
18:39:32 <Olathe> Yeah, ghci sometimes loses control of things.
18:39:35 <Olathe> Ctrl-C fails.
18:39:45 <pumpkin> would add a bit more complexity on that side of it, but would solve the immediate issue
18:40:09 <jeffwheeler> @plugs product [1..10]
18:40:09 <pumpkinbot> Unknown command, try @list
18:41:19 <pumpkin> mmorrow: or is that too inelegant? :P
18:41:59 <alc> , product [1..10]
18:42:01 <lunabot>  3628800
18:42:14 <alc> is this "lunabot" a lambdabot?
18:42:34 <pumpkin> nope
18:42:39 <pumpkin> it's a super special bot
18:42:44 <pumpkin> pumpkinbot is a lambdabot
18:43:44 <pumpkin> @hoogle popen
18:43:44 <pumpkinbot> package popenhs
18:43:50 <mmorrow> yeah, i don't know how it's managing to weasel around the rlimits
18:43:54 <pumpkin> @docs popen
18:43:54 <pumpkinbot> popen not available
18:43:55 <alc> yeah, i once installed and played with lambdabot
18:43:59 <mmorrow> also, that popen isn't using forkProcess
18:44:00 <mmorrow> http://code.haskell.org/lambdabot/lambdabot-utils/Lambdabot/Process.hs
18:44:01 <pumpkinbot> http://tinyurl.com/927jp2
18:44:07 <alc> is this lunabot a public project?
18:44:35 <mmorrow> alc: there's a darcs repo up (the bot part isn't there since it's a hack though)
18:44:51 <mmorrow> http://moonpatio.com/repos/luna/
18:44:51 <pumpkinbot> Title: Index of /repos/luna
18:45:02 <mmorrow> luna needs exactly ghc-6.10.1
18:45:07 <alc> thanks
18:45:08 <pumpkin> is luna meant to be a replacement of mueval?
18:45:56 <mmorrow> and (for now) haskell-src-exts <=  0.3.8
18:46:27 <mmorrow> pumpkin: i didn't write it to be, but the luna code could certainly be used as such
18:47:16 <alc> wish i could "cabal install lunabot" someday =)
18:47:19 <mmorrow> it's not quite as user-friendly as mueval though
18:47:38 <mmorrow> alc: me too. i will eventually get it done :)
18:48:54 <mmorrow> alc: actually, there really isn't anything preventing it from being so, other than me cleaning up the bot front-end, adding it to luna, and uploading it to hackage
18:49:07 <mmorrow> so it'll be sooner than later
18:50:08 * sbahra hopes configuration process of lunabot is minimal
18:50:36 * mmorrow kicks alternatingly kicks himself and likes himself for having an unmanageable number of projects going at all times ;)
18:50:40 <Olathe> What do you use to eval things ?
18:50:56 <pumpkin> @hoogle runInteractiveProcess
18:50:57 <pumpkinbot> System.Process runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
18:51:01 <mmorrow> (i couldn't think of a better antonym for kicks)
18:51:14 <mmorrow> sbahra: yeah, config is pretty minimal.
18:51:15 <Saizan> mmorrow: does luna still clones half of the ghc-api?
18:51:38 <pumpkin> mmorrow: can we add to that popen and make it kill the pid after a timeout?
18:51:40 <mmorrow> Saizan: heh, yes. i haven't changed the code since i got it working
18:51:50 <adekoba> ["ab".."bb"] should work, but it looks like it would be impossible to make [Char] an instance of Enum, yeah?
18:51:53 <pumpkin> I guess it's more of a pain than that because it's waitForPiding
18:52:14 <pumpkin> adekoba: don't see why it should be impossible
18:52:15 <mmorrow> pumpkin: i'm not sure though because a non-allocating bytecode infinite loop will freeze everything
18:52:17 <pumpkin> but maybe
18:52:20 <mmorrow> just like it does to ghci
18:52:25 <pumpkin> mmorrow: but it's a separate process
18:52:30 <pumpkin> how would that freeze it?
18:52:38 <mmorrow> it would have to be a separate OS process
18:52:41 <pumpkin> it is
18:52:48 <pumpkin> isn't it?
18:52:56 <pumpkin> I mean, I have lambdabot spawning all these mueval
18:52:57 <pumpkin> s
18:52:58 <mmorrow> hmm, do you mean from lambdabot's proc, or mueval's?
18:52:58 <pumpkin> that don't die
18:53:02 <pumpkin> I mean from lambdabots
18:53:10 <pumpkin> 's
18:53:20 <adekoba> pumpkin: because of fromEnum, you would need an infinite number of Int's
18:53:30 <adekoba> pumpkin: I think
18:53:42 <Saizan> i think maybe running mueval with +RTS -N2 might be enough?
18:53:59 <Saizan> so the other thread has a spare OS thread to run on and kill the process
18:54:07 <adekoba> pumpkin: wait, maybe not
18:54:32 <Saizan> what's an expression on which i can test this?
18:54:51 <mmorrow> hmm, that might be it! maybe it's runInteractiveProcess that's producing the zombies
18:54:52 <pumpkin> it gives you a pid and three handles
18:54:52 <mmorrow> i'm not sure what it's doing under the covers
18:54:52 <pumpkin>     e <- Control.Exception.catch (waitForProcess pid) (\_ -> return ExitSuccess)
18:54:52 <pumpkin> and that's what popen is doing
18:54:53 <pumpkin> where pid is the mueval pid
18:54:53 <mmorrow> hmm. i'd give it a try. time it out and kill -9 it maybe?
18:54:54 <pumpkin> is there a haskell killProcess?
18:54:59 <mmorrow> (but even if you kill it, it'll still zombify if you don't waitpid it..)
18:55:17 <sjanssen> pumpkin: terminateProcess
18:55:22 <pumpkin> Saizan: fix id
18:55:36 <pumpkin> Saizan's suggestion sounds easier
18:55:55 <mmorrow> Saizan: i wrote some sandbox code that i eventually intend to merge into luna(bot), and i found that forkProcess + kill -9 + waitpid was necessary to kill a non-allocating infinite loop (of bytecode)
18:56:08 <mmorrow> (and not have it end up a zombie)
18:56:27 <pumpkin> @hoogle sleep
18:56:28 <pumpkinbot> No results found
18:56:28 <mmorrow> that's the extent of my knowledge experience with this situation
18:56:34 * sbahra prepares for his first usage of hcurses
18:56:38 <sbahra> hscurses
18:56:57 <pumpkin> is there a simple way to sleep for a little? simplest would be to make a popenTimeout that takes an int, runs the process, sleeps for the interval, then kills
18:57:11 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=445
18:57:25 <sjanssen> pumpkin: threadDelay
18:57:44 <pumpkin> :t threadDelay
18:57:45 <pumpkinbot> Not in scope: `threadDelay'
18:57:51 <mmorrow> Int -> IO ()
18:58:06 <mmorrow> Control.Concurrent
18:58:09 <pumpkin> cool, that seems like the easiest thing to change
18:58:55 <Saizan> pumpkin, mmorrow: mueval -e 'fix id' +RTS -N2 terminates nicely on timeout
18:59:08 <pumpkin> Saizan: oh that's even easier, I'll try that first then
18:59:15 <mmorrow> Saizan: but the problem is the mueval + lambdabot combo
18:59:19 <mmorrow> > fix error
18:59:23 <mmorrow> causes a zombie
18:59:25 <mmorrow> > fix error
18:59:26 <mmorrow> > fix error
18:59:26 <mmorrow> > fix error
18:59:28 <pumpkinbot>  Terminated
18:59:28 <pumpkinbot>  Terminated
18:59:32 <mmorrow> 4 zombies
18:59:34 <pumpkinbot>   thread killed
18:59:37 <mmorrow> maybe 2 actually
18:59:39 <mmorrow> there's one
18:59:39 <Olathe> The error can't be fixed...sorry.
18:59:40 <pumpkinbot>   thread killed
18:59:42 <Saizan> mmorrow: mueval -e 'fix id' doesn't terminate
18:59:43 <mmorrow> 2
18:59:52 <Saizan> why 2 zombies there?
19:00:51 <sjanssen> Saizan: isn't muevale supposed to have CPU time limits?
19:00:52 <mmorrow> Saizan: pumpkin confirmed that "thread killed" == zombie
19:00:52 <pumpkin> yeah, I have several zombies now
19:00:54 <sjanssen> IIRC, lambdabot kills plugin threads that take too long to execute
19:01:00 <mmorrow> sjanssen: for some reason the mueval rlimits aren't influencing the muevals that turn into zombieszombies
19:01:08 <sbahra> whoizwaiting
19:01:20 <pumpkin> sjanssen: it doesn't seem to be doing that here :)
19:01:29 <pumpkin> I had to kill the muevals from those fix errors
19:01:31 <pumpkin> just now
19:01:41 <pumpkin> it'll say terminated, but it doesn't terminate
19:01:42 <Olathe> pumpkin: You killed them before you had enough for a zombie army ?
19:01:46 <Saizan> sjanssen: rlimits crash depending on the OS
19:01:52 <pumpkin> Olathe: damn, I'll have to collect more brains
19:02:18 <pumpkin> alright, I'm gonna restart my bot
19:02:27 <Saizan> ok, thread killed is about lambdabot killing the handler's threads, right?
19:02:34 <sjanssen> Saizan: yes, I think so
19:02:34 <mmorrow> Saizan: hmm, so maybe if lambdabot runs mueval with +RTS -N2 -RTS it'll be ok?
19:03:05 <mmorrow> yes, i think lambdabot killing the thread doesn't give runInteractiveProcess the opportunity to waitpid on it
19:03:06 <Saizan> mmorrow: yeah, because the process will terminate and the handler has a chance to wait()
19:03:09 <pumpkin> bah, it reset my online.rc
19:03:27 <sbahra> @hoogle euid
19:03:32 <mmorrow> s/thread/process/
19:03:37 <sbahra> God damn it, I forgot.
19:03:43 <mmorrow> and thus a zombie results
19:03:55 <sbahra> lambdabot is kind of important when you're working off of a crappy connection
19:03:57 <Saizan> no, you were right with thread
19:04:05 <pumpkin> sbahra: it'll be back as soon as I fix my online.rc
19:04:15 <mmorrow> Saizan: hmm, that's what i don't understand though.
19:04:31 <mmorrow> oh, you mean OS thread, right?
19:04:36 <Saizan> mmorrow: each request is handled by its own thread in lambdabot
19:04:59 <mmorrow> oh, i gotcha. lambdabot kills the forkIO thread that runInteractiveProcess is running in
19:05:08 <Saizan> and the one that runs the mueval process is getting killed before mueval terminates
19:05:19 <mmorrow> thereby preventing runInteractiveProcess from waitpid'ing on the process that it spawned
19:05:21 <Saizan> so the wait() can't collect it
19:05:24 <adekoba> pumpkin: http://hpaste.org/13422. Seems to me toEnum might be, because one wouldn't be able to differentiate between the different characters
19:05:37 <mmorrow> hmm
19:06:08 <Saizan> btw, runIntercativeProcess doesn't wait by itself, you've to use waitForProcess
19:06:08 <pumpkin> new and improved pumpkinbot is new and improved
19:06:16 <pumpkin> Saizan: yeah, it does that already
19:06:16 * sbahra wishes more libraries supported ByteStrings
19:06:25 <pumpkin> > fix error
19:06:28 <mmorrow> ahhh. so the waitpid call is in waitForProcess.
19:06:40 <pumpkinbot>   thread killed
19:06:41 <sjanssen> so we really should be using bracket here, to make sure the process is always terminated, and waited for
19:06:45 * mmorrow sees the light
19:06:45 <Olathe> > fix error in lambdabot
19:06:46 <pumpkinbot>   mueval: Prelude.read: no parse
19:06:51 <Olathe> No parse ?
19:06:55 <Olathe> Learn English !
19:07:03 <mmorrow> sjanssen: that sounds like it'd work to me
19:07:06 <pumpkin> mueval's still running ,despite the "threa killed" report
19:07:18 <pumpkin> (this is with Saizan's +RTS -N2"
19:07:29 <Saizan> it's weird, fix error doesn't give any problem here
19:07:38 <pumpkin> 6.8.2?
19:08:00 <pumpkin> Saizan: interpreted?
19:08:10 <mmorrow> Saizan: i guess though that lambdabot is killing the forkIO thread, but not the mueval process itself.
19:08:15 <jeffwheeler> Is there a full list of the fields for cabal files anywhere?
19:08:47 <pumpkin> @botsnack
19:08:47 <pumpkinbot> :)
19:08:47 <lunabot>  :)
19:09:25 <pumpkin> bah, why are lambdabot-utils separate :P
19:09:34 <pumpkin> now I need to recompile yet another cabal package :P
19:09:38 <Saizan> pumpkin: well, 6.10.1 with darcs hint and mueval
19:09:39 <ray> are they fighting over the botsnack?
19:09:48 <pumpkin> hmm
19:09:56 <Olathe> No.
19:10:30 <pumpkin> so is it worth trying to make a new popen for eval that sleeps then kills?
19:10:54 <Olathe> > take 2.repeat $ "botsnack"
19:10:55 <pumpkinbot>   ["botsnack","botsnack"]
19:10:59 <Olathe> That's what they used.
19:11:11 <sjanssen> pumpkinbot: I'd say not, just use killThread for that
19:11:23 <pumpkin> killThread kills a process?
19:11:31 <pumpkin> this is a separate process
19:12:11 <mmorrow> pumpkin: try with import System.Posix.Signals
19:12:16 <sjanssen> pumpkinbot: killThread kills a thread, which delivers an async KillThread exception
19:12:17 <mmorrow> and
19:12:20 <mmorrow> kill :: ProcessID -> IO ()
19:12:20 <mmorrow> kill = signalProcess sigKILL
19:12:40 <mmorrow> the scythe of death himself!
19:12:42 <sjanssen> terminateProcess is already in System.Process....
19:12:53 <pumpkin> sjanssen: the issue is that what's hanging is the result of     (inp,out,err,pid) <- runInteractiveProcess file args Nothing Nothing
19:12:59 <sjanssen> pumpkinbot: anyway, you can use an exception handler in popen to do the killing
19:13:12 <pumpkin> ah, I've never done exceptions :P
19:13:13 <sjanssen> pumpkinbot: no, I don't think that is right
19:13:15 <mmorrow> sjanssen: oh nice, i wasn't aware of that (terminateProcess)
19:13:22 <pumpkin> sjanssen: what is it then?
19:13:28 <sjanssen> what is hanging is waitForProcess
19:13:42 <pumpkin> ah yeah
19:13:51 <pumpkin> I was proposing to replace that with a sleep and terminateProcess
19:13:56 <Olathe> You need a kill method.
19:14:06 <sjanssen> popen has somewhat shitty code
19:14:21 <sjanssen> pumpkin: nah, no need for sleep IMO
19:14:33 <pumpkin> the child process needs some time doesn't it?
19:14:34 <Olathe> @let kill = const (fun "thread killed" :: Expr)
19:14:35 <pumpkinbot>  Defined.
19:14:45 <Olathe> > kill $ 1 + 1
19:14:47 <pumpkinbot>   thread killed
19:15:00 <mmorrow> @let zombie = fix error
19:15:02 <pumpkinbot>  Defined.
19:15:06 <pumpkin> onoes
19:15:08 <Olathe> > kill zombie
19:15:09 <pumpkinbot>   thread killed
19:15:15 <Olathe> See, no zombie.
19:15:17 <pumpkin> lol
19:15:20 <mmorrow> woot
19:15:21 <pumpkin> you're right!
19:15:24 <pumpkin> you solved the problem!!!!!
19:15:32 <Olathe> I take donations.
19:15:37 <sjanssen> pumpkinbot: yes, but lambdabot already delivers an async exception when a timeout is reached
19:15:59 <sjanssen> pumpkinbot: so we just need to terminateProcess only when that exception is thrown
19:16:01 <mbz> > kill kennedy
19:16:02 <pumpkinbot>   mueval: Prelude.read: no parse
19:16:06 <mbz> :(
19:16:14 <pumpkin> sjanssen: oh, so you mean replacing the return exitSuccess with a terminateProcess then?
19:16:24 <Olathe> @let kennedy = fun "kennedy" :: Expr
19:16:25 <pumpkinbot>  Defined.
19:16:26 <pumpkin> I don't quite get the exception stuff
19:16:28 <Olathe> > kennedy
19:16:29 <pumpkinbot>   kennedy
19:16:34 <Olathe> > kill kennedy
19:16:35 <sjanssen> pumpkinbot: something like that, yes
19:16:35 <pumpkinbot>   thread killed
19:16:49 <mmorrow> someone just needs to write a working popen
19:16:58 <sjanssen> yeah
19:17:56 <sjanssen> actually, is waitForProcess interruptible by an async exception?
19:18:08 <mmorrow> i'm not sure.
19:18:13 <pumpkin> so if I just changed  e <- Control.Exception.catch (waitForProcess pid) (\_ -> return ExitSuccess) to     e <- Control.Exception.catch (waitForProcess pid) (\_ -> terminateProcess pid >> return ExitSuccess) would that help?
19:18:23 <sjanssen> pumpkin: maybe
19:18:30 <pumpkin> let's find out
19:19:48 <mmorrow> also, i'm not sure if terminateProcess is actually a SIGKILL, and not just a SIGTERM
19:20:18 <mmorrow> because a SIGTERM won't due for e.g. a ghci that you've just run fix id in
19:20:26 <mmorrow> s/due/do/
19:20:31 <Olathe> Are there any nice processes that ignore sigterm ?
19:21:09 <sjanssen> mmorrow: yes, should definitely check that
19:21:32 <sjanssen> Olathe: lots of processes occasionally get wedged and ignore SIGTERM
19:21:48 <Olathe> I mean a process that does it by default you can use for testing.
19:21:54 <pumpkin> time to test
19:22:30 <mmorrow> > fix error
19:22:31 <mmorrow> > fix error
19:22:32 <mmorrow> > fix error
19:22:33 <pumpkinbot>  Terminated
19:22:33 <mmorrow> > fix error
19:22:35 <mmorrow> > fix error
19:22:36 <sjanssen> actually, I think where we're blocking is in the takeMVar stuff
19:22:45 <pumpkinbot>   thread killed
19:22:46 <pumpkinbot>   thread killed
19:22:48 <pumpkinbot>   thread killed
19:22:50 <pumpkinbot>   thread killed
19:22:53 <pumpkin> :(
19:22:57 <mmorrow> sjanssen: ooh, and that calls `block' as well
19:23:04 <pumpkin> I got me 4 muevals taking up 80% each
19:23:15 <mmorrow> zombie scum!!
19:23:15 <pumpkin> lol
19:23:17 <Olathe> > 80*4
19:23:19 <pumpkinbot>   320
19:23:25 <pumpkin> (it's a 4 cpu box :P)
19:23:27 <Olathe> 3.2 processors.
19:24:26 <Olathe> That last 0.8 is lost because hardware manufacturers use 4/5ths of a processor rather than the technical definition of 1.
19:24:32 <sjanssen> mmorrow: huh?  takeMVar is definitely interruptible
19:24:37 <Olathe> It's a pretty shoddy practice.
19:24:44 <mmorrow> sjanssen: yeah, you're right.
19:24:56 <pumpkin> hmm
19:25:08 <mmorrow> one of the MVar functions uses block ... unblock ... iirc
19:25:09 <pumpkin> any ideas why the one with terminateProcess might not work?
19:25:31 <mmorrow> sjanssen: i don't recall which, and i'm not sure if that's relevant here.
19:25:55 <sjanssen> mmorrow: modifyMVar?
19:25:55 <pumpkin> I guess I could have it print something in the exception handler to make sure it's doing the right thing
19:26:00 <alc> i dunno about haskell posix api, but one of common way to auto-collect zombies is: set up a SIGCHLD signal handler for the parent in which it does something like "while (waitpid(-1, &stat, NOHANG) > 0)"
19:26:07 <mmorrow> sjanssen: yeah, i think that's probably the one.
19:26:18 <arw> i wanted to try out dph. http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell said "get the src-extralibs or type ./sync-all...". but there doesn't seem to be a sync-all in the ghc source code.
19:26:18 <pumpkinbot> Title: GHC/Data Parallel Haskell - HaskellWiki
19:27:48 <sbahra> Hey.
19:28:09 <sbahra> Is there any nice equivalent to readFile that makes use of file locking?
19:28:50 <mmorrow> sbahra: i'm not sure if it's nice, but System.Posix.IO has some file locking stuff.
19:29:04 <pumpkin> ProcessHandle has no Show
19:29:28 <pumpkin> ah well
19:30:19 <sbahra> mmorrow, figured it was a no :(
19:30:19 <sbahra> Thanks
19:30:54 <mmorrow> alc: yeah, i think it'll be easier to write a custom popen that does this, since runInteractiveProcess is opaque
19:31:14 <mmorrow> (easier than shooting blind)
19:31:16 <cjs> Anybody know how ghc-6.10.1 under windows execs gcc? It's obviously doing something in terms of options or environment or something, because c:\ghc\ghc-6.10.1\gcc.exe does not run standalone, claiming that it cannot find cc1.
19:31:17 <pumpkinbot> cjs: You have 1 new message. '/msg pumpkinbot @messages' to read it.
19:32:06 <sjanssen> alc: I don't think we can use SIGCHLD here
19:32:27 <sjanssen> other plugins make processes, and signal handlers are global
19:32:34 <mmorrow> cjs: looks like with runInteractiveProcess: http://darcs.haskell.org/ghc/compiler/main/SysTools.lhs
19:32:53 <pumpkin> > fix error
19:33:08 <pumpkinbot>   thread killed
19:33:29 <pumpkin> sjanssen: that exception handler isn't getting called unless I'm missing something
19:33:51 <mmorrow> this worked for me
19:33:53 <mmorrow> waitpid :: Bool -> ProcessID -> IO (Either String (Maybe ProcessStatus))
19:33:53 <mmorrow> waitpid blk pid = catch (Right `fmap` getProcessStatus blk True pid)
19:33:53 <mmorrow>                         (\e -> (return . Left . show) e)
19:34:05 <mmorrow> the Bool is whether to block or not
19:34:27 <mmorrow> (that's the System.Posix.Process ProcessID)
19:34:35 <pumpkin> hmm
19:34:49 <pumpkin> how would I integrate that into my epic killing code?
19:35:04 <sbahra> flock is nicer.
19:35:06 <mmorrow> i think you're gonna have to completely rewrite popen
19:35:11 <pumpkin> lol ok
19:35:20 <mmorrow> (or rather s/have to/would be easier to/)
19:35:48 <mmorrow> to get the specific behavior you want here
19:35:55 <pumpkin> the exception handler isn't even being called
19:35:59 <pumpkin> does that mean something? :P
19:36:21 <sbahra> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-IO.html = 404
19:36:22 <pumpkinbot> http://tinyurl.com/7j3yfj
19:36:26 <mmorrow> this is why imo it'll be easier to rewrite. i have no idea why it's not getting called.
19:36:29 <sbahra> Linked from http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#7
19:36:29 <pumpkinbot> Title: System.Posix.IO, http://tinyurl.com/ypw9v7
19:37:13 <mmorrow> pumpkin: maybe some of these helper functions'll be useful http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=445
19:37:23 <jml> how could I have a heterogeneous list in Haskell?
19:37:41 <cjs> mmorrow: Thanks for the pointer to that file; I'll start hunting there. I'm really looking for what particular command line options, env vars, etc. it's setting up.
19:37:56 <pumpkin> jml: an Either would make it a little heterogeneous :P
19:38:01 <sjanssen> how does this look? http://hpaste.org/13424
19:38:06 <pumpkin> nested eithers would make it progressively more heterogeneous :P
19:38:10 <sjanssen> mmorrow, pumpkin: ^
19:38:14 <mmorrow> cjs: hmm, i'm not sure but if i had to guess they're probably in that file
19:38:16 <jml> ok. I guess that makes sense.
19:38:26 <arw> jml: something like a list of tuples with maybes in them
19:38:26 <pumpkin> jml: you can use existential types
19:38:39 <pumpkin> jml: but that's not very useful
19:38:59 <pumpkin> sjanssen: is that pretty much a drop-in replacement
19:38:59 <pumpkin> ?
19:39:03 <sjanssen> pumpkin: yes, should be
19:39:13 <pumpkin> I can give it a go
19:39:22 <sjanssen> you have to "import Prelude hiding (catch)"
19:39:40 <sjanssen> but we also have to check what signal terminateProcess uses
19:40:09 <pumpkin> isn't that doing pretty much what my modified version is doing?
19:40:31 <sjanssen> "On Unix systems, 'terminateProcess' sends the process the SIGKILL signal.
19:40:38 <pumpkin> it's a unix system
19:40:41 <sjanssen> SIGKILL is the forcible kill signal, right?
19:40:44 <pumpkin> yeah
19:40:56 <pumpkin> but I don't think the exception handler's even being called
19:41:00 <pumpkin> I stuck a putStrLn in there
19:41:08 <sjanssen> hmm
19:41:09 <pumpkin> and am running lambdabot in my shell
19:41:20 <pumpkin> and nothing's being output, even when lambdabot says it's terminating the process
19:41:20 <sjanssen> pumpkin: putStrLn as the very first action?
19:41:27 <pumpkin> it's after the terminateProcess
19:41:29 <pumpkin> would that change it?
19:41:33 <sjanssen> possibly
19:41:35 <pumpkin> it's before the waitProcess
19:43:07 <alc> just checked that System.Posix.Process.getAnyProcessStatus does something like waitpid(-1,
19:43:19 <mmorrow> sjanssen:
19:43:23 <sbahra> @hoogle getContents
19:43:23 <mmorrow> int
19:43:23 <pumpkinbot> Prelude getContents :: IO String
19:43:23 <mmorrow> terminateProcess (ProcHandle handle)
19:43:23 <mmorrow> {
19:43:23 <mmorrow>     return (kill(handle, SIGTERM) == 0); }
19:43:23 <pumpkinbot> Data.ByteString getContents :: IO ByteString
19:43:23 <pumpkinbot> System.IO getContents :: IO String
19:43:37 <sbahra> @hoogle hGetContents
19:43:37 <pumpkinbot> Data.ByteString hGetContents :: Handle -> IO ByteString
19:43:37 <pumpkinbot> System.IO hGetContents :: Handle -> IO String
19:43:37 <pumpkinbot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
19:43:40 <sbahra> yeye
19:43:53 <alc> if gobal signal handler being a problem,  as a workaround, you can set up a timer which does getAnyProcessStatus
19:43:56 <sjanssen> hmm, this popen still has problems with applications that close stdout and stderr but never terminate
19:43:59 <alc> global
19:44:02 <sjanssen> mmorrow: wow, that is such bullshit
19:44:07 <mmorrow> totally
19:44:26 <sjanssen> mmorrow: but good thing you checked :)
19:44:29 <mmorrow> i'm surprised there's not at least some way to SIGKILL
19:44:42 <sjanssen> well, the docs seem to think there should be...
19:45:04 <sjanssen> of course ProcessHandle is ridiculously opaque
19:45:08 <mmorrow> maybe they never got updated for the new process lib
19:45:18 <mmorrow> or there really never was :/
19:45:37 <sjanssen> looks like System.Posix is the only option now
19:46:22 <sjanssen> mmorrow: were you going to submit a bug for that, or should I?
19:46:45 * Saizan doesn't get why on the shell using -RTS -N2 works, but from lambdabot doesn't
19:46:46 <mmorrow> sjanssen: good point. i'll do it, as i have another bug i've been meaning to submit.
19:46:59 <pumpkin> lol
19:47:05 <Saizan> maybe the buffering?
19:47:07 <sjanssen> is lambdabot linked with -threaded?
19:47:14 <Saizan> yeah
19:47:22 <pumpkin> mueval though?
19:47:25 <pumpkin> mueval is the one who isn't dying
19:47:40 <pumpkin> I'm running mueval with +RTS -N2 but I didn't check it was building threaded
19:48:06 <sjanssen> if it isn't -threaded +RTS -N2 will cause it to exit immediately
19:48:07 <pumpkin> doesn't look like it :P
19:48:12 <pumpkin>            ghc-options:   -Wall -static -O2
19:48:20 <pumpkin> doesn't that mean no -threaded?
19:48:25 <Saizan> mine has -threaded there
19:48:28 <sjanssen> probably
19:48:43 <pumpkin> > fix error
19:48:44 <pumpkin> > fix error
19:48:45 <pumpkin> > fix error
19:48:45 <pumpkin> > fix error
19:48:45 <pumpkinbot>  Terminated
19:48:46 <pumpkinbot>  Terminated
19:48:58 <pumpkinbot>   thread killed
19:49:00 <pumpkinbot>   thread killed
19:49:04 <pumpkin> liar.
19:49:19 <pumpkin> 31060 pts/0    RN+    0:23 mueval -E --timelimit= 10 -l State/L.hs --expression=fix error +RTS -N2
19:49:23 <Saizan> btw, fix error should just print a page full of * Exception: * Exception ...
19:49:28 <pumpkin> yeah
19:49:40 <pumpkin> oh
19:49:53 <sjanssen> Saizan: we're redirecting stderr to a pipe
19:49:55 <pumpkin> is the +RTS -N2 not doing anything there in the command line?
19:50:07 <pumpkin> should I stick it at the  beginning with -RTS after it?
19:50:20 <pumpkin> > 5+ 5
19:50:22 <pumpkinbot>   10
19:50:27 <pumpkin> if I run mueval -E --timelimit= 10 -l State/L.hs --expression=fix error +RTS -N2 , I get the big usage page
19:50:44 <pumpkin> because obviously I didn't build threaded
19:50:49 <Saizan> sjanssen: but it prints that on stdout
19:51:03 <sjanssen> Saizan: same with stdout
19:51:21 <sjanssen> runInteractiveProcess creates handles for stdout, in, and err
19:51:29 <Saizan> sjanssen: yeah, my point is that it shouldn't loop actually
19:51:42 <Saizan> it should loop only with fix id
19:51:55 <sjanssen> mmorrow: are you already writing a popen that uses Posix?
19:51:58 <Saizan> but maybe the release on hackage is still buggy
19:52:13 <sbahra> throwErrnoPathIfMinus1
19:52:14 <sbahra> :(
19:52:16 <sbahra> so ugly
19:52:27 <pumpkin> > fix error
19:52:43 <pumpkinbot>   thread killed
19:52:49 <Saizan> > fix id
19:52:51 <pumpkinbot>   mueval: Prelude.read: no parse
19:52:51 <pumpkinbot>  mueval: *** Exception: stack overflow
19:53:11 <pumpkin> > 5 + 5
19:53:12 <pumpkinbot>   10
19:53:18 <pumpkin> > fix id
19:53:19 <pumpkinbot>   mueval: Prelude.read: no parse
19:53:19 <pumpkinbot>  mueval: *** Exception: stack overflow
19:53:30 <pumpkin> not sure about that
19:53:31 <pumpkin> > fix error
19:53:46 <pumpkinbot>   thread killed
19:53:58 <pumpkin> so now mueval is threaded but still doesn't behave
19:54:22 <pumpkin> actually let me try something else
19:54:32 <chessguy> @type ord
19:54:33 <pumpkinbot> Char -> Int
19:54:37 <Saizan> are we sure that it's getting +RTS -N2 correctly?
19:54:52 <pumpkin> no
19:54:54 <pumpkin> that's what I'm trying
19:55:29 <chessguy> > ord 'a'
19:55:42 <mmorrow> sjanssen: i'm not at the moment, but put it on my todo list for later when i get some time.
19:55:46 <pumpkin> @botsnack
19:55:46 <lunabot>  :)
19:56:08 <chessguy> harumph. i'll just go get my own ghci then
19:56:13 <pumpkin> bah, disconnect
19:57:05 <pumpkin> wow, I already have an out of control mueval
19:57:08 <pumpkin> and I haven't even run anything
19:57:11 <pumpkin> > fix error
19:57:26 <pumpkinbot_>   thread killed
19:57:37 <pumpkin> now I'm pretty sure it
19:57:45 <pumpkin> 's getting the +RTS -N2 correctly
19:57:54 <pumpkin> but nope, I have two out of control muevals now
19:58:34 <chessguy> @type concatMap (read . ord)
19:58:35 <pumpkinbot_>     Couldn't match expected type `String' against inferred type `Int'
19:58:35 <pumpkinbot_>       Expected type: Char -> String
19:58:35 <pumpkinbot_>       Inferred type: Char -> Int
19:58:43 <sbahra> Is there a way to force getContents/etc... not to read lazily?
19:58:56 <chessguy> @type concatMap (show.ord)
19:58:57 <pumpkinbot_> [Char] -> [Char]
19:59:39 <sjanssen> sbahra: evaluating the length will force the IO to happen
20:00:01 <chessguy> @type read . concatMap (show.ord)
20:00:02 <pumpkinbot_> forall a. (Read a) => [Char] -> a
20:00:20 <chessguy> @type sum . map fromEnum
20:00:22 <pumpkinbot_> forall a. (Enum a) => [a] -> Int
20:00:50 <sbahra> sjanssen, ekhhh
20:01:14 <pumpkin> maybe dons (who appears to have written the original code) has some idea on what's wrong here?
20:01:22 * pumpkin does the dons summoning dance
20:02:12 * pumpkin fails
20:02:33 <chessguy> pumpkin:  what are you doing?
20:03:03 <pumpkin> I have a replacement bot while lambdabot is busy feeling sorry for itself, but my bot has the same issue with mueval and we're trying to figure out what's wrong
20:03:20 <chessguy> oh, hm.
20:04:44 <pumpkin> sjanssen, mmorrow: btw, you should both have the ability to @part it from here if lambdabot comes back
20:04:51 <chessguy> hey ddarius , do i remember that you showed me one time a predicate or propositional logic module in haskell?
20:04:52 <pumpkin> (if I'm gone or something)
20:09:23 <ddarius> chessguy: I don't think so.  Heffalump wrote(?) one and others have been mentioned on Haskell-Cafe recently.
20:09:39 <chessguy> ddarius:  ok, sorry
20:12:41 <sbahra> god this is ugly
20:12:51 <pumpkin> sbahra?
20:14:02 <arw> http://pbot.rmdir.de/4eed06a9c40a1186dd3803590c392acf vs. http://pbot.rmdir.de/e74e5091d1ec8992f4f8651cbd64e699
20:14:04 <sbahra> locking
20:14:24 <arw> something is fishy, the second one doesn't give the right result...
20:15:03 * dmwit bets on overflow
20:15:03 <arw> http://pbot.rmdir.de/9dbb35c24e99cba36a7eefb1c4190db2
20:15:09 <arw> oh, right.
20:15:29 <arw> forgot, its not Integer on the first one :)
20:15:41 <arw> there are times, when type inference can bite you :)
20:15:41 <dmwit> Or rather, it *is* Integer on the first one.
20:16:10 <arw> hm.
20:20:57 <Saizan> pumpkin: btw, if mueval --rlimits doesn't crash on your system you could use that option
20:21:49 <pumpkin> let me try that
20:22:11 <pumpkin> that's not an RTS option, right?
20:22:21 <Saizan> no
20:23:19 * BMeph bets on double-overflow...
20:23:22 <pumpkin> > fix error
20:23:22 <pumpkinbot>   mueval: Prelude.read: no parse
20:23:23 <pumpkinbot>  mueval: L.hs: openBinaryFile: resource exha...
20:23:26 <pumpkin> :o
20:23:33 <pumpkin> > 5 + 5
20:23:33 <pumpkinbot>   mueval: Prelude.read: no parse
20:23:33 <pumpkinbot>  mueval: L.hs: openBinaryFile: resource exha...
20:23:34 <Saizan> > 10 + 10
20:23:34 <pumpkinbot>   mueval: Prelude.read: no parse
20:23:34 <pumpkinbot>  mueval: L.hs: openBinaryFile: resource exha...
20:23:35 <pumpkin> lol
20:23:43 <Saizan> d'oh
20:23:44 <pumpkin> looks like the resource limits I set that mmorrow told me about
20:23:47 <pumpkin> might've been too restrictive
20:23:53 <pumpkin> but they weren't being paid attention to before
20:25:55 <Saizan> > 1
20:25:56 <pumpkinbot>   mueval: Prelude.read: no parse
20:25:56 <pumpkinbot>  mueval: L.hs: openBinaryFile: resource exha...
20:26:17 <pumpkin> > 1
20:26:18 <pumpkinbot>   mueval: Prelude.read: no parse
20:26:18 <pumpkinbot>  mueval: L.hs: openBinaryFile: resource exha...
20:26:20 <pumpkin> lol
20:26:23 <pumpkin> I removed the limit
20:26:24 <roconnor> 1
20:26:30 <pumpkin> > 5 + 5
20:26:31 <pumpkinbot>   mueval: Prelude.read: no parse
20:26:31 <pumpkinbot>  mueval: L.hs: openBinaryFile: resource exha...
20:26:39 <roconnor> 10
20:26:47 <pumpkin> yay for roconnor
20:27:03 <francis> lol
20:27:16 <francis> what happened to lambdabot?
20:27:21 <pumpkin> it died
20:27:28 <francis> :o
20:27:34 <francis> @botsnack
20:27:35 <pumpkinbot> :)
20:27:35 <lunabot>  :)
20:27:39 <roconnor> :)
20:27:50 <pumpkin> anyone have any idea which resource limit it's hitting?
20:28:46 <Saizan> mueval: L.hs: openBinaryFile: resource exhausted (Too many open files)
20:28:49 <jeffz`> pumpkin: does it already have files open? lsof
20:29:18 <pumpkin> it says 7
20:29:21 <pumpkin> I'll try increasing it
20:29:35 <pumpkin> not sure why it'd need that many
20:29:41 <pumpkin> > 5 + 5
20:29:42 <pumpkinbot>   10
20:29:44 <pumpkin> :o
20:29:49 <roconnor> 10
20:29:54 <rwbarton>  10
20:29:57 <pumpkin> > fix error
20:30:03 <pumpkinbot>   mueval: Prelude.read: no parse
20:30:09 <pumpkin> it killed itself :o
20:30:12 <pumpkin> > fix error
20:30:13 <pumpkin> > fix error
20:30:13 <pumpkin> > fix error
20:30:14 <pumpkin> > fix error
20:30:17 <pumpkinbot>  Terminated
20:30:17 <pumpkinbot>  Terminated
20:30:18 <Gracenotes> >_>
20:30:21 <jeffz`> @unpl (foldl . foldl . foldl)
20:30:22 <pumpkinbot>   mueval: Prelude.read: no parse
20:30:22 <pumpkinbot> (\ c -> foldl (foldl (foldl c)))
20:30:22 <pumpkinbot>   mueval: Prelude.read: no parse
20:30:30 <pumpkin> wow, it really worked
20:30:34 <pumpkin> Saizan saved the day
20:30:41 <pumpkin> :)
20:30:48 <Gracenotes> > "> 5 + 5"
20:30:50 <pumpkinbot>   "> 5 + 5"
20:30:56 <pumpkin> a simple case of adding a string to a list :P
20:30:59 <Gracenotes> aww, that spacing
20:31:09 <Saizan> ok, now if only --rlimits worked on every distro..
20:31:19 <Gracenotes> not to mention the quotes :3
20:31:29 <rwbarton> Does hp2ps do color output somehow?  I can't distinguish 20 shades of gray...
20:31:44 <Saizan> rwbarton: yeah, see --help
20:32:17 <rwbarton> Saizan: ah, thanks.  It's not documented in the man page...
20:34:01 <pumpkin> anyway, if lambdabot comes back online, all the admins of lambdabot can ask pumpkinbot to part from here
20:34:32 <dmwit> s/all/any of/
20:34:39 <Axman6> > foldl (+) [1..10000000]
20:34:39 <dmwit> </grammar nazi>
20:34:40 <pumpkin> lol
20:34:40 <pumpkinbot>       Overlapping instances for Show ([[t]] -> [t])
20:34:40 <pumpkinbot>        arising from a use...
20:34:48 <Axman6> > foldl (+) 0 [1..10000000]
20:34:53 <pumpkinbot>   mueval: Prelude.read: no parse
20:34:54 <pumpkin> dmwit: no, I edited the code so they'd have to all do it simultaneously
20:35:01 <dmwit> =)
20:35:09 <pumpkin> it's to encourage friendship
20:35:15 <Axman6> heh
20:35:22 <pumpkin> > foldl (+) 0 [1..100000]
20:35:23 <pumpkinbot>   5000050000
20:35:28 <pumpkin> you only need small lists anyway
20:35:29 <Axman6> i got my copy of RWM today, been going though it
20:35:37 <Gracenotes> RWM?
20:35:42 <Axman6> RWH even
20:35:42 <dmwit> RWH, surely
20:35:50 <Gracenotes> Real World Miranda!
20:35:55 <dmwit> A Dvorak user!
20:35:55 <Axman6> it's a nice book, though slightly error prone :\
20:36:19 <Axman6> dmwit: heh, i nicked my girlfriend's old keyboard yesterday to turn it into a dvorak one
20:36:37 <pumpkin> was she surprised?
20:37:02 <dmwit> He nicked his old girlfriend's keyboard. ;-)
20:37:03 <Axman6> i asked first... and i did just buy her a $100AU logitech G15
20:37:41 <Gracenotes> Dvorak is best used with http://www.thinkgeek.com/computing/input/8396/
20:38:31 <Axman6> OS Requirements: Windows 3.1 or higher, Linux, or Mac OS X
20:38:36 <Olathe> A $130 keyboard ?
20:38:44 <Axman6> bah, i'm sure it'd work on OS 8
20:39:02 <Olathe> Does it synthesize music, too ?
20:39:03 <Axman6> Olathe: $130 = Best-in-class mechanical gold-plated key switches provide a tactile and audio click that makes typing pure joy.
20:39:16 <chessguy> > ord z
20:39:17 <pumpkinbot>   Couldn't match expected type `Char' against inferred type `Expr'
20:39:21 <Gracenotes> I'm a bit surprised USB works cleanly with Windows 3.1
20:39:25 <chessguy> > ord 'z'
20:39:26 <pumpkinbot>   122
20:39:31 <Gracenotes> on the other hand it might just "work"
20:40:08 <Axman6> i always wanted one of these: http://www.thinkgeek.com/computing/input/6c82/
20:42:11 <Saizan> how is a noisy keyboard a good thing?
20:42:18 <dmwit> Gracenotes: I'm pretty sure you have to install special drivers for 3.1 and 95.
20:42:49 <Gracenotes> ja, I'd think
20:43:07 <dmwit> Axman6: Oh, great, so now I can get RSI in only one wrist.
20:43:11 <Gracenotes> hm.
20:43:11 <Axman6> Saizan: i think it's more the feel, and the sound is rather old school, some people like it
20:43:13 <dmwit> But twice as fast...
20:43:19 <cjs> Does anybody know what "No (or multiple) ghc rts package is registered!!" means?
20:43:26 <Axman6> dmwit: but then you've got another one at 100% health!
20:43:34 <Gracenotes> I've found that noisy keyboards don't break that easily
20:43:43 <cjs> Cabal gives it to me when I add a .hsc as an "other-modules" to my build file.
20:44:13 <francis> > filter (<0) [1..]
20:44:19 <pumpkinbot>   mueval: Prelude.read: no parse
20:44:42 <Axman6> pumpkinbot: your bot phails :(
20:44:48 <Axman6> uh, pumpkin even
20:44:50 <pumpkin> Axman6: yeah, it does behave strangely even
20:44:53 <pumpkin> sometimes
20:45:00 <Gracenotes> pumpkinbot: your owner phails :(
20:45:01 <pumpkin> I'm not sure what's up with it
20:45:04 <Axman6> it's just lambdabot right?
20:45:04 <cjs> Hm. I guess we don't have a channel devoted to cabal.
20:45:04 <pumpkinbot> cjs: You have 1 new message. '/msg pumpkinbot @messages' to read it.
20:45:11 <Axman6> @quote
20:45:11 <pumpkinbot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
20:45:21 <Saizan> pumpkin: the hackage mueval
20:45:28 <Axman6> @remember pumpkinbot i suck
20:45:28 <pumpkinbot> Nice!
20:45:32 <Axman6> heh
20:45:39 <pumpkin> @quote ackbar
20:45:39 <pumpkinbot> No quotes match. That's something I cannot allow to happen.
20:45:45 <pumpkin> @remember ackbar it's a trap!
20:45:45 <pumpkinbot> Done.
20:45:46 <Axman6> @quote pumpkinbot
20:45:46 <pumpkinbot> pumpkinbot says: i suck
20:45:57 <pumpkin> @quote ackbar
20:45:57 <pumpkinbot> ackbar says: it's a trap!
20:46:09 <cjs> So, is pumpkinbot ever going to give up on that two-months-old message I've now read several times? :-)
20:46:36 <pumpkin> cjs: don't blame me, I guess someone committed the message to the lambdabot in hackage :P
20:46:47 <pumpkin> that would be funny :P
20:46:59 <Axman6> anyway, back to RWH
20:47:08 <pumpkin> lol
20:47:12 <pumpkin> it's full of people's private messages
20:47:20 <cjs> Oh dear.
20:47:28 <pumpkin> someone should probably fix that
20:47:33 <Axman6> @quote
20:47:33 <pumpkinbot> psnively says: All your Data.Foldable are belong to base.
20:47:39 <chessguy> hey Axman6 , how far into RWH are you?
20:47:40 <francis> lmao
20:47:45 <Saizan> ah, yeah, commiting such parts of the state to the repo in the first place doesn't look sane
20:47:58 <pumpkin> Saizan: yeah
20:48:03 <pumpkin> who owns the repo?
20:48:07 <Axman6> chessguy: page 99, i decided to skim all the stuff i already know (the part of folds was very informative though)
20:48:24 <Axman6> > folb (+) 0 [1..11] :: Expr
20:48:25 <pumpkinbot>   mueval: Prelude.read: no parse
20:48:29 <pumpkin> folb!
20:48:34 <Axman6> > foldb (+) 0 [1..11] :: Expr
20:48:35 <pumpkinbot>   mueval: Prelude.read: no parse
20:48:38 <Axman6> lame
20:48:45 <pumpkin> Saizan: is there some way to make my mueval behave more like the lambdabot one?
20:48:51 <pumpkin> @hoogle foldb
20:48:52 <pumpkinbot> No results found
20:48:52 <Axman6> @seen pumpkinbot
20:48:52 <pumpkinbot> Yes, I'm here. I'm in #haskell
20:48:58 <Saizan> pumpkin: the maintainer is Cale
20:49:02 <pumpkin> Axman6: I don't share state with Cale's bot
20:49:09 <pumpkin> ah
20:49:09 <Axman6> yeah :\
20:49:28 <chessguy> Axman6:  ah, nice. i'm trying to sort out chapter 5. i understand all the concepts, but i'm trying to follow along, and actually build the module, and getting confused as to what code they want in what file
20:49:29 <Axman6> though i think foldb is defined somewhere else
20:49:59 <Axman6> chessguy: you're referring to the --file: ch05/... lines right?
20:50:07 <Saizan> pumpkin: how did you solve the too many files open problem?
20:50:07 <chessguy> Axman6:  yah
20:50:16 <pumpkin> Saizan: I just increased the limit a little
20:50:22 <dmwit> foldb isn't anywhere in the standard libraries.
20:50:23 <dmwit> =/
20:50:32 <Axman6> i haven't tried out any of the code yet, because i know how most of it works
20:50:34 <Saizan> pumpkin: uhm, how do you do that?
20:50:43 <pumpkin> Saizan: it's in Resources.hs in mueval
20:50:44 <Axman6> dmwit: yeah i'm not sure where it comes from
20:50:58 <pumpkin> openFilesLimitSoft = openFilesLimitHard
20:50:58 <pumpkin> openFilesLimitHard = ResourceLimit 20
20:51:00 <chessguy> Axman6:  yeah, me too, i'd just like to actually build the module, for fun
20:51:03 <pumpkin> it was 7 by default
20:51:28 <dmwit> Axman6: It comes from Dmwit.hs, or hpaste.org in case you don't have my awesome file handy.
20:51:30 <dmwit> ;-)
20:51:40 <pumpkin> omg dmwit.hs
20:51:45 <Axman6> dmwit: ah heh :)
20:51:51 <pumpkin> that should be part of the standard lib
20:52:00 <dmwit> It's pretty handy!
20:52:06 <pumpkin> what else is in it?
20:52:09 <dmwit> I import it in all my one-off's.
20:52:14 <dmwit> Hold on, I'll paste it. ;-)
20:52:24 <Axman6> i don't know why, but i always read your nick as dwit. dyslexia++
20:52:29 <Axman6> @karma dyslexia
20:52:29 <pumpkinbot> dyslexia has a karma of 1
20:52:39 <pumpkin> @karma Axman6
20:52:39 <pumpkinbot> Axman6 has a karma of 0
20:52:43 <pumpkin> Axman6--
20:52:43 <pumpkin> @karma Axman6
20:52:44 <pumpkinbot> Axman6 has a karma of -1
20:52:47 <Axman6> see, your bot fails
20:53:01 <dmwit> pumpkin: http://hpaste.org/13425
20:53:06 <pumpkin> my bot can't ssh into Cale's box, yes, so I guess it fails :P
20:53:10 <Olathe> c++
20:53:14 <Olathe> @karma c
20:53:15 <pumpkinbot> c has a karma of 0
20:53:18 <Axman6> heh
20:53:20 <Cale> pumpkin: what?
20:53:24 <dmwit> Olathe: Special case. ;-)
20:53:25 <pumpkin> omg it's Cale
20:53:27 <Axman6> @karma c++
20:53:27 <pumpkinbot> c++ has a karma of 0
20:53:32 <Axman6> c++++
20:53:34 <Axman6> @karma c++
20:53:34 <pumpkinbot> c++ has a karma of 1
20:53:41 <pumpkin> Cale: lambdabot died again
20:53:45 <Cale> Oh?
20:53:46 <Axman6> c++--
20:53:49 <pumpkin> @botsnack
20:53:49 <pumpkinbot> :)
20:53:49 <lunabot>  :)
20:53:55 <Cale> Curious.
20:54:08 <pumpkin> Cale: on mine, it was enough to add --rlimit to the mueval call
20:54:23 <Cale> oh, it's just a runaway ghc process on this machine
20:54:30 <pumpkin> ah
20:54:52 <pumpkin> @part #haskell
20:55:01 <lambdabot> Not enough privileges
20:55:23 <pumpkin> Cale: also, I noticed that a lot of the @tell state is in the repo :P
20:55:26 <pumpkin> and also in the hackage package
20:55:52 <Cale> I don't really manage the hackage package.
20:55:57 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:55:57 <pumpkin> ah
20:56:01 <pumpkin> :P
21:00:12 <pumpkin> @part #haskell
21:00:13 <lambdabot> Not enough privileges
21:00:40 <pumpkin> any lambdabot admin + Saizan,mmorrow can summon it back, if lambdabot dies again
21:00:58 <cjs> Ah, right, so I need to list by hand in build-depends "rts" and every other package I depend on. Ouch.
21:02:17 <pumpkin> dmwit: I like doublify
21:02:33 <dmwit> You may have it!
21:02:42 <pumpkin> why thank you!
21:03:22 <Olathe> @check \xs -> not.null ==> head (sort xs) == minimum xs
21:03:25 <lambdabot>   Couldn't match expected type `Bool'
21:03:55 <dmwit> :t \f g xs ys -> f (uncurry g) (zip xs ys)
21:03:56 <lambdabot> forall a b c a1 b1 t. (((a, b) -> c) -> [(a1, b1)] -> t) -> (a -> b -> c) -> [a1] -> [b1] -> t
21:04:45 <dmwit> :t any
21:04:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:04:57 <dmwit> Wow.
21:05:00 <dmwit> That is clever.
21:05:04 <pumpkin> :o
21:05:04 * dmwit pats past self on the back
21:05:13 <pumpkin> ?
21:06:55 <rwbarton>   readMVar errorDone
21:07:01 <rwbarton> oops
21:07:06 <dmwit> :t \g xs ys -> any (uncurry g) (zip xs ys)
21:07:07 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
21:07:55 <rwbarton> Hey, speaking of which, anyone see why this code might be leaking memory? http://hpaste.org/13426
21:08:41 <JoshTriplett> I have a function to check two items of type Foo for equality.  (Not the same function as (==), so I can't use Eq.)  I want to compare lists of [Foo].  "any.zipWith equalFoo" almost works, but zipWith stops when the first list stops.  How can I write this function without doing explicit recursion or a separate "length" check?
21:09:28 <Olathe> What do you want it to do with the remaining items ?
21:09:52 <pumpkin> just make sure there are none?
21:09:59 <JoshTriplett> Olathe: return False.
21:10:02 <JoshTriplett> pumpkin: Yes.
21:10:32 <pumpkin> you could do an ugly fold :P
21:10:35 <pumpkin> over a pair
21:10:46 <JoshTriplett> pumpkin: Yes, but ewww.
21:10:46 <pumpkin> actually, an unfold
21:10:47 <pumpkin> lol
21:10:53 <pumpkin> yeah, it feels ugly even to me
21:11:11 <dmwit> rwbarton: The only thing I could think of is that the array creation is getting delayed somehow.
21:11:17 <JoshTriplett> I could write a function that takes [a] and gives an infinite list [Maybe a].
21:11:20 <dmwit> rwbarton: Other than that, your code looks totally reasonable.
21:11:28 <dmwit> rwbarton: Are you sure the leak is in that block?
21:11:30 <JoshTriplett> And zipWith that.
21:11:43 <rwbarton> dmwit: Well, I think that's what the heap profile is saying.
21:11:51 <JoshTriplett> (Oh, and I meant "all.zipWith")
21:12:07 <rwbarton> But maybe I should think more about what the rest of the code is doing with the solution
21:12:45 <pumpkin> you could cycle both of the lists and wait for a little ;)
21:12:56 <dmwit> JoshTriplett: I think twanvl has a blog post about writing these kinds of folds.
21:13:07 <dmwit> Let me see if I can find it for you.
21:13:47 <Cale> Of course, you could also just write it recursively.
21:13:58 <JoshTriplett> Cale: Yeah, I could.
21:14:02 <JoshTriplett> > let addNothings l = map Just l ++ repeat Nothing
21:14:03 <lambdabot>   <no location info>: parse error on input `;'
21:14:05 <BMeph> Where's mmorrow? We need some outfix operators inHaskell... ;)
21:14:08 <Cale> I don't think there's an existing function which really works satisfyingly for that.
21:14:09 <JoshTriplett> @let addNothings l = map Just l ++ repeat Nothing
21:14:10 <lambdabot>  Defined.
21:14:14 <pumpkin> it would be quite elegant recursively
21:14:16 <JoshTriplett> > addNothings [1,2,3]
21:14:17 <dmwit> JoshTriplett: http://twan.home.fmf.nl/blog/haskell/generic-merge.details
21:14:18 <lambdabot>   [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothi...
21:14:26 <Cale> It's an example of a generalised zipWith.
21:14:36 <JoshTriplett> > inits [1,2,3]
21:14:38 <lambdabot>   [[],[1],[1,2],[1,2,3]]
21:14:40 <Cale> (which takes functions for what to do with the tails)
21:14:41 <JoshTriplett> > tails [1,2,3]
21:14:42 <lambdabot>   [[1,2,3],[2,3],[3],[]]
21:14:56 <JoshTriplett> > map listToMaybe tails [1,2,3]
21:14:57 <lambdabot>   Couldn't match expected type `[[a]]'
21:15:01 <JoshTriplett> > map listToMaybe $ tails [1,2,3]
21:15:02 <lambdabot>   [Just 1,Just 2,Just 3,Nothing]
21:15:07 <JoshTriplett> Oooh, perfect.
21:16:29 <BMeph> JoshTriplett: If I were you, since your function is trying to do so much at once, you're likely better off just rolling your own. :)
21:16:33 <Olathe> > let allPairs p (x:xs) (y:ys) = p x y && allPairs p xs ys; allPairs _ [] [] = True; allPairs _ _ _ = False in allPairs (==) [1..3] [1..4]
21:16:34 <lambdabot>   False
21:16:37 <Olathe> > let allPairs p (x:xs) (y:ys) = p x y && allPairs p xs ys; allPairs _ [] [] = True; allPairs _ _ _ = False in allPairs (==) [1..3] [1..3]
21:16:38 <lambdabot>   True
21:16:45 <JoshTriplett> Cale: mergeByR requires an Ordering for elements, though.
21:16:53 <dmwit> JoshTriplett: See also http://hackage.haskell.org/cgi-bin/hackage-scripts/package/list-extras
21:17:15 <Olathe> > let allPairs p (x:xs) (y:ys) = p x y && allPairs p xs ys; allPairs _ [] [] = True; allPairs _ _ _ = False in allPairs (==) [1..3] [1, 4, 3]
21:17:17 <lambdabot>   False
21:17:21 <JoshTriplett> Olathe: Yeah, I guess that'll work.  I can split p into a separate function.
21:17:46 <JoshTriplett> Olathe: Thanks!
21:17:46 <rwbarton> @src [a] (==)
21:17:46 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:17:51 <Olathe> You're welcome.
21:18:08 <dmwit> "This module provides safe zipping functions which will fail (return Nothing) on uneven length lists."
21:18:23 <pumpkin> is it just me or is it impossible to find the date on that blog post?
21:18:34 <Olathe> Which blog post ?
21:18:39 <pumpkin> http://twan.home.fmf.nl/blog/haskell/generic-merge.details
21:19:39 <francis> in haskell, time is irrelevant
21:19:44 <Cale> :t let zipWith' f l r = g where g [] [] = []; g xs [] = l xs; g [] ys = r ys; g (x:xs) (y:ys) = f x y : g xs ys in zipWith'
21:19:45 <lambdabot> forall t t1 a. (t -> t1 -> a) -> ([t] -> [a]) -> ([t1] -> [a]) -> [t] -> [t1] -> [a]
21:19:45 <pumpkin> ah, true
21:20:00 <francis> lol
21:20:11 <Cale> er, actually, that doesn't quite work out.
21:20:24 <Cale> You want a more general continuation...
21:20:29 <dmwit> pumpkin: Fri 2008-08-15 02:49
21:20:42 <BMeph> pimpkon: Fri 2008-08-15 02:49
21:21:01 <Cale> :t let zipWith' f l r = g where g [] [] = []; g xs [] = l xs; g [] ys = r ys; g (x:xs) (y:ys) = f x y (g xs ys) in zipWith'
21:21:02 <lambdabot> forall t t1 a. (t -> t1 -> [a] -> [a]) -> ([t] -> [a]) -> ([t1] -> [a]) -> [t] -> [t1] -> [a]
21:21:08 <dmwit> Beatcha to it, and spelled his name right to boot. ;-)
21:21:09 <JoshTriplett> dmwit: That seems useful, yeah, but I don't want to bother importing an external module.
21:21:18 <pumpkin> where did you guys find that date, out of curiosity? :o
21:21:20 <Cale> :t let zipWith' z f l r = g where g [] [] = z; g xs [] = l xs; g [] ys = r ys; g (x:xs) (y:ys) = f x y (g xs ys) in zipWith'
21:21:21 <lambdabot> forall t t1 t2. t -> (t1 -> t2 -> t -> t) -> ([t1] -> t) -> ([t2] -> t) -> [t1] -> [t2] -> t
21:21:26 <dmwit> pumpkin: In the aether!
21:21:29 <Cale> There, that ought to be general enough ;)
21:21:30 <pumpkin> oh, there
21:21:40 <pumpkin> I always forget to check the aether
21:21:47 <francis> lmfao
21:21:54 <dmwit> JoshTriplett: I've always regretted it every time I decided not to import a module.  You end up writing the rest of the module one piece at a time... ;-)
21:21:56 <Cale> :t let zipWith' z f l r = g where g [] [] = z; g xs [] = l xs; g [] ys = r ys; g (x:xs) (y:ys) = f x y (g xs ys) in zipWith' True (==) (const False) (const False)
21:21:57 <lambdabot>     Couldn't match expected type `Bool -> Bool'
21:21:57 <lambdabot>            against inferred type `Bool'
21:21:57 <lambdabot>     Probable cause: `==' is applied to too many arguments
21:22:19 <Cale> :t let zipWith' z f l r = g where g [] [] = z; g xs [] = l xs; g [] ys = r ys; g (x:xs) (y:ys) = f x y (g xs ys) in zipWith' True (\x y z -> x == y && z) (const False) (const False)
21:22:20 <lambdabot> forall t. (Eq t) => [t] -> [t] -> Bool
21:22:31 <BMeph> dmwit: Are you going to import C.M.I, someday? :)
21:22:35 <francis> :o an arab!
21:22:36 <Cale> Sort of a zipWith and a fold at once :)
21:22:50 <dmwit> BMeph: Control.Monad.???
21:22:53 <dmwit> BMeph: Instances?
21:23:44 <rwbarton> dmwit: Turned out it had to do with how I was using the result after all.  Thanks.
21:23:52 <BMeph> dmwit: Right. :)
21:24:00 <Olathe> pumpkin: http://twan.home.fmf.nl/blog/2008/ has the date.
21:24:08 <pumpkin> Olathe: thanks :)
21:25:04 <dmwit> "What number appears in the name of this blog? (hint: the answer is 21)"
21:25:04 <Cale> I suppose a more initial thing to choose would be a function  zip' :: [a] -> [b] -> ([(a,b)], Maybe (Either [a] [b]))
21:25:07 <dmwit> twanvl++
21:25:08 <JoshTriplett> @hoogle a -> [(a, b)] -> Maybe b
21:25:09 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:25:09 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:25:09 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
21:25:14 <BMeph> pumpkin: "blog", followed by ^F merge, works Wonders. :)
21:25:18 <JoshTriplett> @hoogle a -> [(a, b)] -> (Maybe b, [(a, b)])
21:25:18 <lambdabot> No results found
21:25:21 <JoshTriplett> Hmmm.
21:25:28 <pumpkin> BMeph: yeah, I realized :P
21:25:36 <JoshTriplett> Cale: That looks useful.
21:26:32 <dmwit> Maybe (Either [a] [b]) is too big.
21:26:41 <dmwit> Nothing, Left [], and Right [] all have the same meaning.
21:26:59 <Cale> > let zip' [] [] = ([], Nothing); zip' xs [] = ([], Just (Left xs)); zip' [] ys = ([], Just (Right ys)); zip' (x:xs) (y:ys) = (let (zs, k) = zip' xs ys in ((x,y):zs, k)) in zip'
21:27:00 <lambdabot>       Overlapping instances for Show
21:27:00 <lambdabot>                                  ([t] ->...
21:27:00 <dmwit> But the right type is too unwieldy...
21:27:03 <Cale> :t let zip' [] [] = ([], Nothing); zip' xs [] = ([], Just (Left xs)); zip' [] ys = ([], Just (Right ys)); zip' (x:xs) (y:ys) = (let (zs, k) = zip' xs ys in ((x,y):zs, k)) in zip'
21:27:04 <lambdabot> forall t t1. [t] -> [t1] -> ([(t, t1)], Maybe (Either [t] [t1]))
21:27:45 <Olathe> @src (==) String
21:27:46 <lambdabot> Source not found. My mind is going. I can feel it.
21:27:48 <JoshTriplett> Does a function exist which acts like lookup but also removes the item from the list, returning the new list?
21:28:05 <JoshTriplett> Hmmm, I guess I don't actually want that, nevermind.  I can just compare the elements piecewise.
21:28:09 <pumpkin> alright, time for bed
21:28:20 <dmwit> data Remainder a b = Matched | ExtraLeft a [a] | ExtraRight b [b]
21:28:38 <JoshTriplett> dmwit: You know, you could just have the function promise to never return ExtraLeft []. :)
21:28:52 <dmwit> yep
21:28:54 <JoshTriplett> dmwit: Actually...
21:29:27 <JoshTriplett> dmwit: It seems like Haskell ought to let you do this: data Remainder a b = Matched | ExtraLeft (a:[a]) | ExtraRight (b:[b])
21:29:29 <dmwit> But if you're making promises, you might as well use [Either a b] or Either [a] [b].
21:29:33 <JoshTriplett> dmwit: Specify a constructor.
21:29:50 <Cale> JoshTriplett: There's (a,[a])
21:29:52 <dmwit> Specify a constructor?
21:30:04 <rwbarton> ExtraLeft is the constructor
21:30:12 <JoshTriplett> dmwit: Yeah.  Effectively saying you can only hold a cons, not a nil.
21:30:22 <JoshTriplett> rwbarton: The list constructor. :)
21:30:25 <dmwit> JoshTriplett: But that's exactly what "ExtraLeft a [a]" does!
21:30:28 <Cale> :t let zip' [] [] = ([], Nothing); zip' (x:xs) [] = ([], Just (Left (x,xs))); zip' [] (y:ys) = ([], Just (Right (y,ys))); zip' (x:xs) (y:ys) = (let (zs, k) = zip' xs ys in ((x,y):zs, k)) in zip'
21:30:29 <lambdabot> forall t t1. [t] -> [t1] -> ([(t, t1)], Maybe (Either (t, [t]) (t1, [t1])))
21:30:35 <JoshTriplett> dmwit: Yes, except you have to re-assemble the list.
21:30:39 <Cale> But that has an even less pretty type :)
21:30:58 <dmwit> Cale: Yeah, the right type is just too unwieldy to use. =/
21:31:29 <JoshTriplett> dmwit: If I want to handle the extra items with your approach, I have to do something like case ... of ExtraLeft x xs -> foo (x:xs) .
21:31:36 <Gracenotes> @hoogle (Floating a, Integral b) => a -> b
21:31:36 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
21:31:37 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
21:31:37 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
21:31:44 <dmwit> JoshTriplett: You have to do that anyway.
21:31:46 <JoshTriplett> dmwit: With the syntactic extension I just suggested you could do case ... of ExtraLeft l -> foo l
21:31:51 <dmwit> ah
21:31:54 <JoshTriplett> dmwit: And yet know that you don't have null l.
21:32:00 <dmwit> Now *that* is some pointless coding optimization, if I ever saw any.
21:32:06 <Cale> JoshTriplett: It's not just a syntactic extension.
21:32:11 <Cale> JoshTriplett: (which is what the trouble is)
21:32:25 <Cale> You'd be asking the compiler to prove that the list isn't null...
21:32:38 <JoshTriplett> Cale: The compiler need not prove anything.
21:32:50 <Cale> Or the user of the function
21:33:02 <Cale> Types are static, remember.
21:33:21 <JoshTriplett> Cale: Oh, I see your point.  ExtraLeft (a:[a]) effectively means ExtraLeft !(a:[a])
21:33:28 <JoshTriplett> Strict in finding out the constructor.
21:33:35 <JoshTriplett> Cale: Fair enough.
21:33:38 <Cale> uh, not quite...
21:33:52 <Cale> It's so strict that it must know that the list is nonempty at compile time.
21:34:00 <Cale> Before the program even gets to run.
21:34:17 <rwbarton> Does compiling with -prof -auto-all affect performance when run without +RTS -foo?
21:34:27 <JoshTriplett> Cale: OK, then require that constructing an ExtraLeft requires explicitly pattern matching.
21:34:37 <Cale> So when you have a type which expresses that "this is a list but it happens to be nonempty", and it's the type of parameter to a function, that means whoever uses the function needs to prove that the list they give isn't empty.
21:34:40 <JoshTriplett> Cale: Er, rather, explicitly constructing the field.
21:34:43 <JoshTriplett> Cale: Yeah.
21:34:56 <JoshTriplett> Cale: So don't allow ExtraLeft l, only allow ExtraLeft (x:xs).
21:35:00 <JoshTriplett> Cale: Seems easy enough.
21:35:09 <sjanssen> seems complicated
21:35:22 <sjanssen> JoshTriplett: should let z = x:xs in ExtraLeft z work?
21:35:33 <JoshTriplett> sjanssen: I'd argue no.
21:35:57 <sjanssen> JoshTriplett: I don't think I'd want to program in those semantics
21:35:59 <JoshTriplett> sjanssen: Make it as simple as possible.
21:36:16 <JoshTriplett> sjanssen: Effectively you have nothing more than syntactic sugar for ExtraLeft x xs .
21:36:20 <rwbarton> If I can write 'f x' but not 'let y = x in f y', that's not simple
21:36:41 <JoshTriplett> rwbarton: You can't write f x either.  You can only write f (x:xs).
21:36:52 <rwbarton> JoshTriplett: I mean, f and x represent some expressions
21:38:26 <sjanssen> JoshTriplett: how about data Z a = Z (a:[a]) (a:[a]); f = Z (0:[]) -- what is the type of f?
21:38:32 <JoshTriplett> So, effectively, a function with the signature (Integer:[Integer]) -> Integer really has the signature Integer -> [Integer] -> Integer with a little extra syntactic sugar.
21:38:43 <JoshTriplett> sjanssen: Parsing...
21:38:57 <sjanssen> (for simplicity, we can call 'a' Int)
21:39:38 <Gracenotes> I'd almost like to think a:[a] is of type [a]. almost :/
21:39:59 <JoshTriplett> OK, correction: it makes more sense to say that (Integer:[Integer]) desugars to (Integer,[Integer]) .
21:40:27 <JoshTriplett> sjanssen: So with that change f has type (Integer:[Integer]), which internally works out to (Integer,[Integer]).
21:40:43 <JoshTriplett> sjanssen: But I can then do ExtraLeft f
21:40:56 <JoshTriplett> Oh, sorry.
21:41:07 <JoshTriplett> It has type Z (Integer:[Integer]).
21:41:25 <rwbarton> Don't you mean (Integer:[Integer]) -> Z Integer ?
21:41:42 * JoshTriplett fails at parsing, clearly.
21:41:43 <JoshTriplett> Yes.
21:41:55 <sjanssen> JoshTriplett: what is the type of (1:[])?  [Int] or (Int:[Int])?
21:42:27 <rwbarton> Or Int:[], or 1:[], ... :)
21:42:53 <JoshTriplett> sjanssen: Yeah, effectively this introduces a type hierarchy.
21:43:11 <JoshTriplett> sjanssen: Yay for subtyping.
21:43:15 <rwbarton> What about (1+1):[]
21:43:28 <JoshTriplett> sjanssen: It has type (Int:[Int]), which you can treat as [Int] or as (Int:[Int]).
21:43:56 <JoshTriplett> rwbarton: Num a => (a:[a]) , which you can treat as that or as Num a => [a] ?
21:44:18 <rwbarton> Sorry, I was off on a tangent somewhat...
21:44:24 <JoshTriplett> I suspect subtyping introduces pain, yeah.
21:44:56 <sjanssen> JoshTriplett: so clearly we're beyond just "syntactic sugar" :)
21:45:00 <JoshTriplett> OK, so clearly this won't work without introducing what amounts to a hierarchy of types.
21:45:24 <JoshTriplett> Specifying a type as the constructor of a type specifies a sub-type of that type.
21:45:38 <JoshTriplett> Namely, the sub-type of things which can only use that constructor.
21:46:30 <JoshTriplett> sjanssen: Yes. :)
21:47:05 <JoshTriplett> sjanssen: It seems possible to treat it as syntactic sugar if you only allow it in the presence of explicit type signatures, or something.  But people do seem fond of inference. :)
21:48:11 <dmwit> You might be interested in the concept of dependent typing.
21:48:26 <dmwit> ...which allows exactly this kind of thing, but at the cost of basically no inference.
21:49:50 <Gracenotes> > let o = 10; o2 = ceiling $ o * sqrt 2 in [ (x,y,z) | x <- [1..o], y <- [1..o], z <- [1..o2], x < y, gcd x y == 1, x^2 + y^2 == z^2]
21:49:51 <lambdabot>   Add a type signature
21:49:54 <JoshTriplett> dmwit: Yeah, I've heard of it.
21:50:11 <Gracenotes> ...it seems the number types are foiling my plans again. What's happening here?
21:50:22 <rwbarton> :t let o = 10; o2 = ceiling $ o * sqrt 2 in [ (x,y,z) | x <- [1..o], y <- [1..o], z <- [1..o2], x < y, gcd x y == 1, x^2 + y^2 == z^2]
21:50:24 <lambdabot> forall t. (Integral t) => [(t, t, t)]
21:50:35 <rwbarton> uh
21:50:49 <rwbarton> :t gcd 10 22
21:50:50 <lambdabot> forall t. (Integral t) => t
21:50:54 <rwbarton> > gcd 10 22
21:50:55 <lambdabot>   2
21:51:17 <Olathe> > gcd (-1) (sum [1..])
21:51:18 <dmwit> There's a default for t, but not for (t, t, t) (and hence not for [(t, t, t)]).
21:51:31 <rwbarton> :t is lying
21:51:42 <lambdabot>   mueval: Prelude.read: no parse
21:51:42 <rwbarton> the problem has to do with sqrt 2
21:51:42 <lambdabot> Not in scope: `is'
21:51:42 <lambdabot> Not in scope: `lying'
21:51:43 <Olathe> It's lying ?
21:51:52 <dmwit> rwbarton: eh?
21:51:57 <Olathe> See, it's not even in scope !
21:52:00 <dmwit> rwbarton: Note the "ceiling".
21:52:05 <Gracenotes> may be relevant --
21:52:07 <Gracenotes> :t ceiling
21:52:08 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
21:52:09 <rwbarton> according to ghci the real type is (Integral b, Floating b, RealFrac b) => [(b, b, b)]
21:52:34 <rwbarton> which makes sense, 10 has to be an integer for gcd but can't be for sqrt 2.
21:52:37 <dmwit> rwbarton: Don't do those in two different lets.  The MR will bite you.
21:52:51 <dmwit> I thought let-polymorphism would allow that...
21:52:57 <rwbarton> Hmm, I just copied and pasted that whole line into ghci
21:53:08 <rwbarton> Ah, maybe :t has NoMR but not > ?
21:53:18 <dmwit> > let o = 10; o2 = ceiling o; o3 = [1,2,3] !! o in o
21:53:20 <lambdabot>       No instance for (RealFrac Int)
21:53:20 <lambdabot>        arising from a use of `ceiling' a...
21:53:24 <dmwit> huh
21:53:29 <rwbarton> Yeah, turning on NoMR changes the type to (Integral t) => [(t, t, t)] in ghci
21:53:42 <rwbarton> lambdabot is special...
21:53:45 <chessguy> ugh, i'm strating to get really annoyed with RWH
21:53:45 <Cale> Int...
21:53:47 <dmwit> Very special.
21:54:00 <Olathe> Especially special.
21:54:02 <Cale> ah, I see
21:54:03 <Cale> !!
21:54:06 <dmwit> yeah
21:54:06 <rwbarton> Can we please please please have :t and > use the same settings, kthx.
21:54:10 <rwbarton> please please
21:54:11 <Gracenotes> NoMR? monomorphism?
21:54:15 <dmwit> restriction
21:54:19 <Gracenotes> yeah
21:54:20 <Cale> and yeah, must be that the MR is turned on for some reason
21:54:25 <Olathe> "no" ++
21:54:54 <Gracenotes> still, a bit odd
21:56:01 <sjanssen> rwbarton: which settings are different?
21:56:20 <rwbarton> Well, NoMR for one, but also many imports, last I checked
21:56:30 <rwbarton> Let me see if I can remember an example
21:56:54 <Olathe> @type somethingioish
21:56:55 <lambdabot> Not in scope: `somethingioish'
21:56:56 <sjanssen> the monomorphism restriction will never apply to @type, since it doesn't create top level bindings
21:57:07 <sjanssen> it doesn't apply to > either
21:57:13 <Olathe> @hoogle file
21:57:13 <sjanssen>  @let, perhaps
21:57:14 <lambdabot> System.Posix.Types type FileID = CIno
21:57:14 <lambdabot> package FileManip
21:57:14 <lambdabot> System.Posix.Types type FileMode = CMode
21:57:15 <rwbarton> doesn't the monomorphism restriction apply inside a let also?
21:57:21 <sjanssen> rwbarton: no
21:57:23 <Olathe> @hoogle readfile
21:57:23 <lambdabot> Prelude readFile :: FilePath -> IO String
21:57:23 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
21:57:23 <lambdabot> System.IO readFile :: FilePath -> IO String
21:57:34 <Olathe> > readFile
21:57:35 <lambdabot>       Overlapping instances for Show (FilePath -> IO String)
21:57:36 <lambdabot>        arising f...
21:57:39 <Olathe> Ah hah
21:57:46 <rwbarton> try to eval " let o = 10; o2 = ceiling $ o * sqrt 2 in [ (x,y,z) | x <- [1..o], y <- [1..o], z <- [1..o2], x < y, gcd x y == 1, x^2 + y^2 == z^2] " in ghci with and without -XNoMonomorphismRestriction
22:04:39 <dibblego> one hundreds passengers await to board an aircraft with their seat allocation [1..100] however the first guy is crazy and will choose an arbitrary seat; if a subsequent passenger's seat is taken they will choose an arbitrary seat too. What is the probability of passenger 100 getting to their seat?
22:05:55 <Gracenotes> labeled balls in bins? ;)
22:07:32 <rwbarton> dibblego: Nice problem :)
22:07:39 <ben_h> dibblego: ooo nice problem
22:07:44 <oklodol> i would just love it if, just once, computing that the longer way would simply give a different result.
22:07:50 <oklodol> that math was wrong in that one case.
22:08:00 <ben_h> lol
22:08:22 <oklodol> well not that, anything.
22:08:28 <arw> oklodol: finding a contradiction in math shuts down this universe and reboots :)
22:08:43 <oklodol> :D
22:08:47 <oklodol> probably
22:09:03 <ben_h> well there are several things wrong with the world that a reboot might fix
22:09:05 <sereven> nah, just writes a log entry and forks
22:09:26 <ben_h> then again, Pink Floyd might not recur next time so I say we don't risk it
22:10:02 <Olathe> > sum $ zipWith (*) [2..100] (map (1%) [99..1])
22:10:04 <lambdabot>   0%1
22:10:10 <Olathe> Yay ! Zero !
22:10:24 <Olathe> > take 5 $ zipWith (*) [2..100] (map (1%) [99..1])
22:10:25 <lambdabot>   []
22:10:35 <Olathe> Wow...that's unexpected.
22:10:41 <BMeph> > sum $ zipWith (*) [2..100] (map (1%) [99,98..1])
22:10:43 <lambdabot>   29555521879065341838334306827217348426754707%697203752297124771645338089353...
22:10:47 <ben_h> lol
22:10:51 <Olathe> Ahh.
22:11:01 <BMeph> > take 5 $ zipWith (*) [2..100] (map (1%) [99,98..1])
22:11:03 <lambdabot>   [2%99,3%98,4%97,5%96,6%95]
22:12:00 <arw> yep, reboot would be nice. pi is too big, there is too much edge for any given size of pizza...
22:12:09 <ben_h> :)
22:12:22 <ben_h> π really should just be 3
22:12:43 <arw> na. pi should be 1. simplifies a lot :)
22:12:45 * dolio passes legislation to make it so.
22:12:58 <Olathe> pi should be 0.
22:13:08 <Olathe> That makes things even simpler.
22:13:19 <Gracenotes> what do you mean, 0? there shouldn't be a 0!
22:13:21 <mgregson> What about 1/pi?
22:13:28 <dmwit> dolio: You must live in Ohio.
22:13:30 <Olathe> Who uses 1/pi ?
22:13:37 <dolio> I do, actually.
22:13:38 <Olathe> pi r^2 = 0 for all r.
22:13:39 <rwbarton> another, vaguely related, problem is: I choose a random number between 1 and 100, say N_1.  then if it's more than 1, I choose a second number between 1 and N_1-1, say N_2.  repeat until some N_k is 1.  what is the average value of k?
22:13:48 <Olathe> Quite nice for area calculations.
22:13:48 <dibblego> find the diameter given the circumference, g'luck
22:14:08 <dmwit> dibblego: No problem, the circumference is always 0.
22:14:14 <Olathe> Well, the circumference is always zero, so you can't.
22:14:17 <dmwit> So it doesn't even matter what diameter I tell you.
22:14:31 <oklodol> dmwit: he's asking for the inverse
22:14:39 <Olathe> Inverses are for girls !
22:14:52 <ben_h> dibblego: the diameter is just defined as the length of the official SI piece of string
22:14:57 <dolio> Yeah, and c = πd, so d = c/π = 0/0 = nullity.
22:14:57 <dmwit> oklodol: And I'm giving it to him.
22:15:00 <arw> rwbarton: is your number an integer or a real?
22:15:01 <Olathe> Hahah
22:15:21 <ben_h> i assume you mean ints rwbarton
22:15:46 <rwbarton> arw: Sorry, every "number" is an integer
22:16:17 <Gracenotes> rwbarton: intuition is... lg 100?
22:16:52 <rwbarton> Gracenotes: You're in the right ballpark, but that's not quite right
22:17:17 <Gracenotes> off by a constant, I suspect
22:17:29 <Gracenotes> then again, any incorrect solution is off by a constant
22:17:46 <arw> 1+lg 100 or something?
22:18:04 <rwbarton> Well for one thing, the answer is a rational number :)
22:18:11 <dmwit> E_x[k] = sum_{i=1}^k 1/k E_i[k]
22:18:11 <int-e> hmmm 1/1 + 1/2 + ... + 1/99
22:18:26 <rwbarton> dmwit: Yes
22:18:28 <Gracenotes> lg 100 = 6.643856189774725
22:18:35 <rwbarton> dmwit: You can crunch it from there, but that is the hard way :P
22:18:38 <dmwit> So it's definitely rational, by induction on x.
22:19:11 <dmwit> rwbarton: I usually find that crunching the hard way reveals the easy way. ;-)
22:19:20 <dmwit> "easy"
22:19:20 <Gracenotes> or ~, although that confuses it with regex notation
22:19:32 <rwbarton> dmwit: Yes, that is often true
22:19:46 <Olathe> @bot
22:19:47 <lambdabot> :)
22:19:47 <lunabot>  :)
22:20:00 <dmwit> rwbarton: Are you allowed to choose your upper bound?
22:20:01 <Gracenotes> er, I meant ~=. no matter :/
22:20:15 <dmwit> i.e. could you have the sequence 100, 100, 100, 1?
22:20:25 <int-e> dmwit: that looks odd. What is x?
22:20:29 <rwbarton> dmwit: no
22:20:38 <rwbarton> dmwit: "N_1-1"
22:20:43 <dmwit> int-e: The upper bound.  I've just learned the equation is not just odd, but wrong. =)
22:20:44 <rwbarton> so 100, 99, 98, 1 is OK
22:21:00 <rwbarton> 100, 99, 99, 1 is not OK
22:21:20 <dmwit> E_x[k] = sum_{i=1}^{x-1} 1/(x-1) E_i[k]
22:21:35 <int-e> dmwit: you're missing a 1+
22:22:03 <dmwit> I don't think I am.
22:22:13 <dmwit> Although it should be 1/x, not 1/(x-1).
22:22:31 <dmwit> oh
22:22:35 <dmwit> Yeah, you're right. =)
22:23:46 <JoshTriplett> How can I most efficiently turn strings like "123,456,789" into [Maybe Integer] ?
22:24:08 <int-e> And let's call E_x[k], say, a_n.  a_n = 1 + 1/(n-1) sum(a_i, i = 1 to n-1) = 1 + a_(n-1)/(n-1) + (n-2)/(n-1) (a_(n-1) - 1) = a_(n-1) + 1/(n-1), and a_1 = 0, and we want a_101,
22:24:23 <JoshTriplett> I know that "read" tends to work pretty inefficiently.
22:24:29 <dmwit> Does it?
22:24:44 <dmwit> I don't think you'll do better than read for Strings.
22:24:54 <JoshTriplett> Hmmm.
22:24:57 <dmwit> You could do better (faster) with ByteStrings.
22:25:13 <dmwit> But you should try it with String first and make sure the speed is actually going to be a problem.
22:25:15 <rwbarton> int-e: right
22:25:16 <JoshTriplett> dmwit: Yeah, but I don't have ByteString, unfortunately.
22:25:35 <Axman6> JoshTriplett: look into reads
22:25:47 <rwbarton> int-e: Now there's also a direct, non-algebraic way to get the answer 1 + 1/2 + 1/3 + ... + 1/100
22:25:54 <Axman6> > reads "123,456,7,8" "" :: [(Integer,String)]
22:25:56 <lambdabot>   Couldn't match expected type `[Char] -> [(Integer, String)]'
22:26:00 <JoshTriplett> Axman6: Yeah, I guess I'll go with that.
22:26:09 <JoshTriplett> Axman6: I think I still need to split the string. :)
22:26:22 <Axman6> :t reads
22:26:24 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:26:31 <Axman6> > reads "123,456,7,8" :: [(Integer,String)]
22:26:35 <lambdabot>   mueval: Prelude.read: no parse
22:26:37 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
22:26:38 <Gracenotes> oh hello lambdabot
22:26:49 <dmwit> rwbarton: Ah!
22:26:51 <Axman6> hmmm
22:26:54 <dmwit> rwbarton: That is a very clever problem.
22:26:58 <rwbarton> dmwit: right
22:27:04 <rwbarton> dmwit: Now do dobblego's problem :)
22:27:11 <dmwit> okay =)
22:27:19 <Gracenotes> 1 + 1/2 + 1/3 + ... is interesting all by itself
22:27:22 <rwbarton> (that is, if you're thinking what I hope you're thinking)
22:27:46 <Axman6> > sum . map (1/) $ [1..100] :: CReal
22:27:49 <lambdabot>   5.187377517639620260805117675658253157909
22:27:55 <Axman6> > sum . map (1/) $ [1..1000] :: CReal
22:28:00 <dmwit> I'm pretty sure I am, since I just looked up and saw you wrote that the harmonic series is, indeed, the correct answer. =)
22:28:10 <lambdabot>   thread killed
22:28:13 <rwbarton> dmwit: Well, what's the "easy" solution?
22:28:15 <Axman6> > sum . map (1/) $ [1..500] :: CReal
22:28:30 <lambdabot>   thread killed
22:28:39 <Axman6> > sum . map (1/) $ [1..300] :: CReal
22:28:43 <lambdabot>   6.282663880299503461919485541047289283235
22:28:48 <int-e> Right, the probability of 'visiting' n is 1/n - consider the first visited number less than n+1; clearly all the n possibilities 1..n are equally likely, just by considering the last step.
22:28:55 <rwbarton> int-e: exactly
22:29:03 <int-e> rwbarton: if you ask me, the algebraic way is simpler :)
22:29:08 <Gracenotes> > map (\p -> (sum $ map (1/) [1..p])/(logBase 2 p)) [1..]
22:29:10 <lambdabot>   [Infinity,1.5,1.1567045482143385,1.0416666666666665,0.9833781409342475,0.94...
22:29:17 <Axman6> chessguy: still around?
22:29:22 <chessguy> Axman6:  yo
22:29:35 <Axman6> how far are you through chapter 5 now?
22:29:53 <Axman6> i'm stuck on the second exercise on page 130 :\
22:30:28 <Gracenotes> I did a proof once in which the sum from 1 to n of 1/k was ln n plus a constant factor. (once.... arghm)
22:30:41 <chessguy> oh, i didn't do those 2 exercises, but i did the rest of chapters 5 and 6
22:31:51 <chessguy> Axman6:  looks like exercise 2 wants you to re-write the 'fill' function from exercise 1?
22:32:36 <Axman6> possibly. but i'm not sure if i'm supposed to make it work in the context of the rest of the pretty printer
22:32:58 <dmwit> rwbarton: dibblego's is 1/2 chance
22:33:16 <rwbarton> dmwit: yeah, that's what I got too
22:33:20 <Axman6> like, if i run pretty on a doc, should it indent the things in arrays etc
22:33:25 <dmwit> Still trying to come up with the "easy" explanation, though.
22:33:48 <chessguy> Axman6: hm, there's an implementation in the online version
22:34:05 <newsham> is there a comonad equiv of ap?  something like "w a -> w (a -> b) -> w b" perhaps?
22:34:19 <Axman6> chessguy: http://book.realworldhaskell.org/admin/comments/comment/8268/ you mean?
22:34:58 <chessguy> Axman6:  that link doesn't work for me, but it's from "LungZeno"
22:35:11 <Axman6> yeah, that's the comment
22:35:22 <Axman6> ah, heh, admin link
22:36:01 <rwbarton> dmwit: my argument for dibblego's is somewhat more involved and hand-wavy
22:36:12 <chessguy> anyway, 2 am here. i suppose i should go to bed
22:36:18 <dmwit> The algebraic solution is quite straightforward. =)
22:36:18 <chessguy> good luck
22:36:32 <Axman6> sleep well
22:37:05 <rwbarton> dmwit: basically the only event which can affect the outcome is a random seat chooser choosing seat 1 or 100
22:37:17 <dmwit> Right.
22:37:32 <dmwit> Anything in between just makes it the same problem with a lower upper bound.
22:37:36 <rwbarton> Exactly.
22:43:46 <JoshTriplett> Axman6: Managed to do what I wanted with reads: http://hpaste.org/13427
22:45:28 <JoshTriplett> *Main> f "1,2,unknown,4"
22:45:28 <JoshTriplett> [Left 1,Left 2,Right "unknown",Left 4]
22:45:47 <Gracenotes> > sum $ zipWith (\a b -> 1/a * 1/b) [2..99] [3..100]
22:45:49 <lambdabot>   0.49
22:45:58 <rwbarton> JoshTriplett: This might sound strange, but your Left and Right are backwards :)
22:46:09 <Gracenotes> > sum $ zipWith (\a b -> 1/a * 1/b) [2..49] [3..50]
22:46:11 <lambdabot>   0.4799999999999999
22:46:14 <dibblego> > let p z | z > 1 = sum $ map (\n -> n * 1/z * 1/(z-1)) [1..z-1] in p 100
22:46:16 <lambdabot>   0.5
22:46:30 <Gracenotes> close enough to .48
22:46:38 <JoshTriplett> rwbarton: Good point.
22:46:40 <JoshTriplett> rwbarton: Thank you.
22:47:00 * rwbarton is glad he didn't have to explain that :)
22:47:25 <Gracenotes> dibblego: much more elegant way of putting it :)
22:48:03 <dibblego> how do you write a quick check such that you can say ~= 0.5 forall z?
22:48:23 <Gracenotes> induction? :P
22:49:21 <Gracenotes> for 3 people, the answer is 1/(2*3) + 1/3
22:49:41 <Gracenotes> for 4 people, 1/(2*3) + 1/(3*4) + 1/4
22:49:56 <Gracenotes> 5, 1/(2*3) + 1/(3*4) + 1/(4*5) + 1/5
22:50:45 <rwbarton> JoshTriplett: also, Parsec would work well here
22:50:47 <Gracenotes> oh, QuickCheck meaning the testing utility? never mind about that
22:50:50 <Gracenotes> sorry :/
22:51:00 <JoshTriplett> rwbarton: It might, but it seems like overkill for such a simple parse.
22:51:03 <dibblego> forall z. p z ~= 0.5
22:51:14 <dibblego> @check \z -> p z ~= 0.5
22:51:16 <lambdabot>   Not in scope: `~='
22:51:53 <rwbarton> JoshTriplett: f = sepBy (try number <|> many (noneOf ",")) (char ",") or something
22:52:09 <JoshTriplett> rwbarton: Nice.
22:52:24 <rwbarton> Well, with Left and Right thrown in
22:55:31 <Olathe> > let solve :: Integer -> Rational; solve 2 = 1%2; solve n = (1%n)*0 + (1%n)*1 + ((n - 2)%n)*solve (n - 1) in map solve [2..10]
22:55:34 <lambdabot>   [1%2,1%2,1%2,1%2,1%2,1%2,1%2,1%2,1%2]
22:56:46 <Olathe> I'm getting a slight hint of a pattern somewhere.
22:57:24 <oklodol> > let solve :: Integer -> Rational; solve 2 = 1%2; solve n = (1%n)*0 + (1%n)*1 + ((n - 2)%n)*solve (n - 1) in (map solve [2..]) !! 50000
22:57:30 <JoshTriplett> @hoogle a -> [a] -> Bool
22:57:31 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
22:57:31 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
22:57:31 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
22:57:31 <lambdabot>   1%2
22:57:40 <oklodol> might just be luck
22:57:44 <JoshTriplett> @hoogle (a -> a -> Bool) -> a -> [a] -> Bool
22:57:44 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
22:57:44 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:57:44 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:57:49 <Olathe> Yeah, you never know.
22:57:55 <Gracenotes> Olathe: the answer to the problem is answer(x) = { 42 if x = 5430590435493, otherwise 1/2 }
22:58:03 <Olathe> Ahh.
22:58:04 <JoshTriplett> Hmmm.  Not so much with "elemBy", unfortunately.
22:58:11 <Olathe> 42 is quite the probability.
22:58:22 <Olathe> It's like really, really probably.
22:58:30 <Gracenotes> what can you say, mathematics doesn't always model real life
22:58:49 <JoshTriplett> Gracenotes: Heretic.
22:58:49 <rwbarton> elemBy is called any
22:58:52 <rwbarton> @hoogle any
22:58:52 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
22:58:52 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
22:58:52 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
22:59:06 <Olathe> That's why I use doll houses to figure out real-life problems.
22:59:18 <JoshTriplett> rwbarton: Oh, I guess any (compareThingy foo) foos would work.
23:00:05 <Gracenotes> for example, try to derive a formula for the height of a ball falling off a 50-foot cliff after one millenium
23:01:05 <Olathe> Hmmm...
23:01:18 <Gracenotes> well, okay, it'll involve a minimum function somewhere. But still, the basic physical model doesn't always work. So it is with airplane passengers.
23:01:18 <Olathe> I'd say there's more than one height.
23:01:44 <Gracenotes> *maximum function
23:02:34 <int-e> rwbarton: for dibblego's problem, consider this modification: when a passenger finds his or her seat occupied, instead of picking a random seat for themselves, make the cazy passenger get up and choose a new seat. Now, when there are n passengers left, 100-(n+1) passengers are seated correctly, and the crazy one occupies one of the remaining 1/(n+1) seats - each with equal probability.
23:02:42 <Axman6> > scanl (+) [1..10]
23:02:44 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
23:02:44 <lambdabot>        arising from a u...
23:02:48 <Axman6> > scanl (+) 0 [1..10]
23:02:51 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
23:03:04 <Axman6> > scanl (+) 0 [1..10] :: [Expr]
23:03:05 <lambdabot>   [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5,0 ...
23:03:47 <int-e> rwbarton: err, 1/(n+1) --> n+1
23:03:58 <Olathe> int-e: That's crazy !
23:04:06 <Gracenotes> int-e: if, on any of the trials, the crazy dude picks seat 0, it's over. Alternatively, if he picks 100, it's over
23:04:58 <rwbarton> int-e: I see
23:05:13 <Gracenotes> (damn crazy dudes going onto airplanes)
23:05:15 <rwbarton> int-e: so the number of times the crazy dude moves is the problem I gave?
23:05:30 <int-e> rwbarton: pretty much, yep.
23:05:43 <Gracenotes> *seat 1, argh
23:05:46 <Olathe> Ahh.
23:05:53 <Olathe> Now, we're finding the number of seats.
23:06:32 <Gracenotes> int-e: wait, is this problem conflated with the 100th passenger one, or is it entirely different?
23:07:38 <Olathe> Well, with two seats, it's 3/2 instead of 1/2.
23:08:30 <Axman6> > pi ** (-2)
23:08:31 <lambdabot>   0.10132118364233778
23:08:42 <Axman6> > pi ^ (-2)
23:08:44 <lambdabot>   * Exception: Negative exponent
23:09:47 <Olathe> > (recip pi)^2
23:09:49 <lambdabot>   0.10132118364233779
23:09:59 <Axman6> > pi ^^ (-2)
23:10:01 <lambdabot>   0.10132118364233778
23:10:12 <Olathe> > pi ^^ iq
23:10:14 <lambdabot>   Not in scope: `iq'
23:11:34 <int-e> Gracenotes: they're not the same, and they're not completely different :)
23:11:54 <Axman6> @instances RealFrac
23:11:55 <lambdabot> Double, Float
23:12:12 <Gracenotes> int-e: ah, okay
23:17:41 <Gracenotes> Another fun problem: suppose one hundred people each pick a random number from 1-100 and to go the corresponding seat; only one person can actually get the seat, though. Then, all the people who didn't get a seat each pick another random number. On average, how many times will this happen before everyone gets seats?
23:18:28 <Gracenotes> I don't actually know the answer... I tried to find out the answer a few days ago and stuck :P so, eh.
23:18:32 <Axman6> ln 100?
23:19:03 <Olathe> Well, for two, it's 3/2
23:19:23 <int-e> Gracenotes: "pick another random number" - from 1 to 100 or from 1 to the number of remaining people?
23:19:41 <oklodol> probably from the empty chairs
23:19:55 <oklodol> seats
23:20:12 <Gracenotes> well, the problem I had in mind was from 1 to 100, although from the empty seats will work out too (although differently)
23:20:27 <Olathe> Ahh.
23:20:46 <oklodol> well if it's the first one, then it's much more than ln 100 methinks
23:22:01 <Olathe> Well, each person can be prelabelled with the seat he'll get.
23:22:40 <Olathe> What's the average number of draws before you get a specific number ?
23:22:43 <chylli> there are so many regexp packages. I just want to extract an substr, which one should I use /
23:22:44 <chylli> ?
23:23:11 <oklodol> Olathe: good point.
23:24:48 <int-e> Olathe: prelabeling like that rules out some draws though.
23:25:04 <Olathe> How so ?
23:25:08 <Olathe> > iterate ((+(1%100).(*(99%100))) (1%100)
23:25:10 <lambdabot>   <no location info>: parse error on input `;'
23:25:24 <Olathe> > iterate ((+(1%100)).(*(99%100))) (1%100)
23:25:25 <lambdabot>   [1%100,199%10000,29701%1000000,3940399%100000000,490099501%10000000000,5851...
23:25:36 <Olathe> > iterate ((+(1/100)).(*(99/100))) (1/100)
23:25:38 <lambdabot>   [1.0e-2,1.99e-2,2.9700999999999998e-2,3.940399e-2,4.9009950100000005e-2,5.8...
23:26:03 <int-e> Olathe: imagine that you have only two people: 1 and 2, and 1 will eventually sit on seat 1, and 2 on seat 2. Then it's impossible that 1 draws the number 2 while 2 draws the number 1.
23:26:14 <Olathe> Why ?
23:26:18 <Olathe> Oh.
23:27:14 <Olathe> Will the result differ ?
23:28:29 <Olathe> > map (showCReal 5) $ iterate ((+(1/100)).(*(99/100))) (1/100)
23:28:31 <lambdabot>   ["0.01","0.0199","0.0297","0.0394","0.04901","0.05852","0.06793","0.07726",...
23:28:52 <Olathe> > drop 100.map (showCReal 5) $ iterate ((+(1/100)).(*(99/100))) (1/100)
23:28:57 <lambdabot>   ["0.63763","0.64125","0.64484","0.64839","0.65191","0.65539","0.65883","0.6...
23:33:04 <Gracenotes> hm, looks like there isn't a Wikipedia article about balls and bins
23:33:59 <Olathe> Try stars and bars
23:34:58 <Gracenotes> ah, that works
23:35:02 <mgsloan> > showCReal 5 pi
23:35:04 <lambdabot>   "3.14159"
23:35:17 <mgsloan> > showCReal 100 pi
23:35:19 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
23:35:24 <mgsloan> ooh ahh ;)
23:35:58 <Gracenotes> although, not all balls+bins problems can be modeled that easily with stars+bars
23:37:16 <Gracenotes> e.g. in the airplane problem, about how many airplane seats will be empty after the first trial
23:38:39 <rwbarton> that you can work out though, it's 100 * (1 - 1/100)^100
23:39:09 <Gracenotes> yeah. unfortunately, though, bars+stars doesn't help too much
23:39:30 <Gracenotes> anyway, my airplane problem is really quite disparate from the others, heh
23:39:51 * Gracenotes will find the solution someday!
23:57:31 <nanothief> What are the best online sources for learning about category theory? Or is a good book necessary?
