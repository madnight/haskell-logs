00:00:05 <wli> I believe monad comprehensions' proof burdens were mostly Monad0 and Monad (Monad0 was distinct from MonadPlus then).
00:00:23 <Megzlna> dons: that's funny
00:00:26 <bogner> dons: that's frightening
00:00:29 <dons> > [ take x z | x <- [1..10], let y = x : z ; z = x : y ]
00:00:31 <lambdabot>   [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8,8...
00:00:51 <dons> haskell ftw.
00:01:05 <Megzlna> this is a crazy language
00:01:12 <dons> (i've got something to pull out next time someone talks about python's list comps :)
00:01:15 <Megzlna> I'm not sure when the surprises will stop
00:01:22 <wli> take 10 $ join replicate =<< [1..]
00:01:27 <johnnowak> Megzlna: when you leases expect it
00:01:30 <wli> > take 10 $ join replicate =<< [1..]
00:01:32 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
00:01:32 <johnnowak> least, damnit, damnit
00:01:39 * johnnowak ruins everything
00:01:53 <dons> my rental leases never expect mutual recursion.
00:02:23 <dons> sjanssen: i didn't know that was valid either. did anyone?
00:02:33 <dons> seems kinda obvious to allow it now.
00:02:34 <sjanssen> dons: doesn't seem surprising
00:02:40 <sjanssen> just a recursive let binding
00:02:46 <dons> yup. no problems.
00:02:52 <sjanssen> > [repeat x | x <- [1 .. 10]] -- is the same thing
00:02:53 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:03:19 <jsn> dons: that's an interesting approach to the non-empty list problem
00:03:19 <sjanssen> \x -> let y = x : z; z = x : y in z -- just a funny way of writing repeat
00:03:36 <dons> jsn: statically checked. no more bugs on that issue
00:03:41 <jsn> i tend to write around it by having a function take two parameters and such like
00:03:47 * sjanssen keeps grumbling about a HTML doc generator requiring 400MB of memory
00:03:48 <wli> Pattern matching and MonadZero were a big deal with the compiler intrinsics for monad comprehensions.
00:03:54 <wli> Monad0 rather.
00:03:56 <dons> oh, that's an interesting idea
00:04:01 <dons> encode the length in the arity
00:04:01 <jsn> instead of   f :: [a]    i have    f :: a [a]
00:04:10 <dons> :k (->)
00:04:11 <lambdabot> ?? -> ? -> *
00:04:20 <jsn> oh ack
00:04:31 <jsn> f :: a -> [a] -> x
00:04:41 <jsn> f :: [a] -> x
00:04:43 <dons> yeah. its a sort of unary length encoding
00:05:02 <sjanssen> it's HList, actually
00:05:08 <wli> I don't see an announcement for the hpaste post.
00:05:24 <sjanssen> wli: the IRC bot is busted, announcing doesn't work any more
00:05:26 <jsn> something has to catch the list and validate it somewhere, though -- i usually can't do without handling it
00:06:04 <centrinia> Don't most people learn the unary number system before learning higher radix number systems?
00:06:49 <jsn> centrinia: like, on our fingers?
00:06:59 <centrinia> Yeah. ;)
00:07:18 <sjanssen> okay, so fastest way to turn off haddock for a GHC build, anybody know?
00:07:23 <Megzlna> the first radix system you learn is base 1
00:08:06 <wli> centrinia: In a sense. The thing is, use and recognition of quasi-unary numbers is limited to small numbers. Passage to larger numbers is essentially all by non-unit radix.
00:09:02 <wli> centrinia: Human minds by and large aren't really capable of dealing with too many objects at once (e.g. unary numbers larger than some threshold).
00:11:30 <Megzlna> why did lambdas choose to use -> instead of = ?
00:11:48 <jsn> Megzlna: there is no LHS ?
00:12:06 <Megzlna> (\ x -> x + 1)   vs.   (\ x = x + 1)
00:12:14 <jsn> right
00:12:16 <pumpkin> x isn't x = 1
00:12:22 <pumpkin> :P
00:12:33 <pumpkin> whereas the named function is what you're =
00:12:38 <centrinia> > let x = x+1 in x
00:12:46 <sjanssen> Megzlna: hmm, traditionally lambda calculus would use "." there
00:12:49 <centrinia> Wow, x = x+1
00:12:50 <centrinia>  ;)
00:12:50 <wli> In lambda calculus a . is typically used.
00:12:54 <lambdabot>   thread killed
00:12:54 <jsn> Megzlna: we take = to define a name, generally
00:13:00 <dons> f x = x + 1 ; \ x = x + 1
00:13:11 <jsn> Megzlna: whereas no name is being defined there
00:13:12 <dons> f x . x + 1
00:13:21 <Megzlna> jsn, k
00:13:28 <jsn> Megzlna: it looks like it is defining the '\' operator if you use =
00:13:31 <wli> f x = x + 1 is just f x = \x -> x + 1
00:13:38 <wli> er
00:13:42 <sjanssen> \x.f x -- typical lambda calculus rendering
00:13:43 <wli> f x = x + 1 is just f = \x -> x + 1
00:13:45 <jsn> but there is no '\' operator
00:14:19 <dons> let x = v in e  vs   (\x . e) v
00:14:24 <jsn> it looks more like a case statement to me -- a pattern match and a resultant expression
00:14:32 <wli> Arguments on the LHS of an = are syntactic sugar for \'s on the RHS.
00:14:58 <Megzlna> wli: literally?
00:15:20 <sjanssen> Megzlna: yes, function definition de-sugars into lambda and case
00:15:26 <Megzlna> heh k
00:15:52 <sjanssen> (with a small exception for the monomorphism restriction)
00:16:42 <centrinia> > ap (const (+1)) x) 2
00:16:43 <lambdabot>   <no location info>: parse error on input `)'
00:16:43 <Megzlna> sjanssen: How does that exception work?
00:16:48 <centrinia> > ap ((const (+1)) x) 2
00:16:50 <lambdabot>       Ambiguous occurrence `x'
00:16:50 <lambdabot>      It could refer to either `L.x', defined a...
00:16:52 <Megzlna> Because it knows that you aren't making a constant
00:17:02 <Megzlna> so it doesn't incorrectly monomorphically restrict it
00:17:05 <centrinia> > ap ((const (+1)) id) 2
00:17:07 <lambdabot>       Overlapping instances for Show ((a -> b) -> b)
00:17:07 <lambdabot>        arising from a us...
00:17:13 <Megzlna>  ?
00:17:14 <sjanssen> Megzlna: yes
00:17:17 <Megzlna> k
00:17:18 <sjanssen> MR sucks so bad
00:17:42 <jsn> that's why i turn suck to off :)
00:17:59 <dolio> Yes, but why do you have arrow notation permanantly on?
00:18:13 <jsn> how do you know that?
00:18:21 <dolio> You posted it on haskell-cafe. :)
00:18:31 <sjanssen> I wonder if removing the DMR has any traction in Haskell'?
00:18:33 <jsn> oh i mailed that to everyone
00:18:46 <jsn> i think i thought it was cool and never use the keywords 'rec' or 'proc' so i forgot about it
00:18:54 <wli> sjanssen: If only we could get monad comprehensions back.
00:18:55 <sjanssen> huh?  People actually use Arrow syntax?
00:19:07 <sjanssen> wli: that is a non-sequitor
00:19:18 <dolio> Yeah. I was going to say, I don't think I've ever used arrow syntax other than to experiment with arrow syntax.
00:19:30 <sjanssen> wli: oh, sorry.  I read that as "only if" not "if only" :)
00:19:31 <centrinia> > (ap (const (+1)) id) 2 -- Shouldn't this be (\x -> x+1) 2  ?
00:19:32 <lambdabot>   3
00:19:37 <centrinia> Okay.
00:19:41 <sjanssen> wli: but yes, that would be nice
00:19:55 <Megzlna> I'm getting opposite behaviour here
00:20:00 <wli> sjanssen: Just thinking of another major loss associated with h98.
00:20:22 <Megzlna> @let ff = \x -> x + 1; gg x = x + 1
00:20:23 <lambdabot>  Defined.
00:20:25 <Megzlna> :t ff
00:20:26 <lambdabot> forall a. (Num a) => a -> a
00:20:26 <Megzlna> :t gg
00:20:27 <lambdabot> forall a. (Num a) => a -> a
00:20:29 <Megzlna> Ah
00:20:31 <centrinia> Does anyone write (ap (const (+1)) id) instead of (\x -> x+1)
00:20:59 <centrinia> @let hh = ap (const (+1)) id
00:21:01 <lambdabot>  Defined.
00:21:03 <Megzlna> Well, without NoMono enabled, the ff still defaults
00:21:04 <centrinia> :t hh
00:21:05 <lambdabot> forall b. (Num b) => b -> b
00:21:05 <sjanssen> centrinia: I think most would write (+1) :)
00:21:29 <centrinia> sjanssen: That's cheating. :(
00:21:35 <sjanssen> centrinia: also, succ
00:22:35 <jsn> there's also     head . [] . (+1)
00:22:42 <sjanssen> Megzlna: it looks like lambdabot has MR shut off for Let.hs
00:23:09 <Megzlna> Yes, Cale hates it too
00:23:14 <sjanssen> jsn: type error
00:23:24 <jsn> oh, duh
00:23:32 <sjanssen> > head . return . (+1) -- works
00:23:33 <lambdabot>       Overlapping instances for Show (a -> a)
00:23:33 <lambdabot>        arising from a use of `s...
00:23:38 <jsn> head . (:[]) . (+1)
00:23:49 <Megzlna> I was just saying, "..with a small exception: lambdas don't have the monomorphism restriction, because Haskell knows that you aren't making a constant, so doesn't incorrectly monomorphically restrict."   ---> Opposite is true:  let f = \x -> x + 1  will always Default
00:24:05 <Megzlna> without NoMr
00:24:08 <sjanssen> Megzlna: no exception for lambdas
00:24:25 <sjanssen> only functions defined as "f ... = ..." are exempt
00:24:33 <Megzlna> k
00:25:01 <arussel> inside emacs, can I a ghci shell or do I have to go through M-x shell -> ghci ?
00:25:12 <arussel> s/a/have
00:25:36 <arussel> or even better, is yi ready for use now ? :-)
00:25:39 <vininim> @let naiveSqrt = \ number -> let {prox a x = 0.5*(x + a/x); good (x:y:xs) = if abs(x - y) < 0.0000001 then y else good (y:xs) } in good $ iterate (prox number) (number/2)
00:25:40 <lambdabot>  Defined.
00:25:57 <vininim> there, put that on Prelude. :)
00:26:48 <vininim> > naiveSqrt 0
00:27:04 <lambdabot>   thread killed
00:29:21 <vininim> > NaN < 0
00:29:23 <lambdabot>   Not in scope: data constructor `NaN'
00:29:27 <centrinia> > let bisectSqrt' a x y = if abs (x-y) < 1e-5 then x else let m = (x+y)/2 in if m^2-a > 0 then bisectSqrt' a x m else bisectSqrt' a m y; bisectSqrt a = bisectSqrt' a (-a) (a) in bisectSqrt 2.0
00:29:30 <lambdabot>   1.4142074584960938
00:29:44 <centrinia> > let bisectSqrt' a x y = if abs (x-y) < 1e-8 then x else let m = (x+y)/2 in if m^2-a > 0 then bisectSqrt' a x m else bisectSqrt' a m y; bisectSqrt a = bisectSqrt' a (-a) (a) in bisectSqrt 2.0
00:29:46 <lambdabot>   1.4142135605216026
00:29:55 <pumpkin> so l33t
00:29:58 <centrinia> Mine actually works. ;)
00:30:13 <centrinia> > let bisectSqrt' a x y = if abs (x-y) < 1e-8 then x else let m = (x+y)/2 in if m^2-a > 0 then bisectSqrt' a x m else bisectSqrt' a m y; bisectSqrt a = bisectSqrt' a (-a) (a) in bisectSqrt (-2.0)
00:30:14 <vininim> > naiveSqrt 2
00:30:16 <lambdabot>   2.0
00:30:16 <lambdabot>   1.414213562373095
00:30:34 <centrinia> > let bisectSqrt' a x y = if abs (x-y) < 1e-8 then x else let m = (x+y)/2 in if m^2-a > 0 then bisectSqrt' a x m else bisectSqrt' a m y; bisectSqrt a = bisectSqrt' a (-a) (a) in bisectSqrt (-1.0)
00:30:36 <lambdabot>   1.0
00:30:40 <centrinia> Weird.
00:30:52 <centrinia> > naiveSqrt (-2)
00:31:04 <vininim> oh no, bad guy
00:31:08 <lambdabot>   thread killed
00:31:28 <centrinia> > let bisectSqrt' a x y = if abs (x-y) < 1e-8 then x else let m = (x+y)/2 in if m^2-a > 0 then bisectSqrt' a x m else bisectSqrt' a m y; bisectSqrt a = bisectSqrt' a (-a) (a) in bisectSqrt (10.0^(2*10))
00:31:38 <centrinia> Hmm.
00:31:44 <lambdabot>   thread killed
00:31:50 <centrinia> > let bisectSqrt' a x y = if abs (x-y) < 1e-8 then x else let m = (x+y)/2 in if m^2-a > 0 then bisectSqrt' a x m else bisectSqrt' a m y; bisectSqrt a = bisectSqrt' a (-a) (a) in bisectSqrt (10.0^(2*4))
00:31:53 <lambdabot>   9999.9999999989
00:32:00 <sjanssen> centrinia: might be time to take that to /msg?
00:32:08 <centrinia> > naiveSqrt (10.0^(2*4))
00:32:12 <lambdabot>   10000.0
00:32:17 <centrinia> sjanssen: Okay, sorry.
00:32:21 <vininim> newton wins!
00:34:04 <wli> Prelude> let naiveSqrt :: Double -> Double ; naiveSqrt x | x < 0 = undefined | x
00:34:05 <wli>  == 0 = 0 | otherwise = let ys = iterate (\y -> (y + x / y) / 2) 1 in snd . head
00:34:07 <wli> . dropWhile (\(x, y) -> abs (x - y) > 1.0e-14) $ zip ys (tail ys) in naiveSqrt 2
00:36:42 <wli> I used to have some nice Newton code with bounding intervals and fallback to bisection floating around somewhere.
00:37:07 <centrinia> Does anyone really communicate n distinct values where order is not important along with an integer inclusively between 0 and n!-1 in a sequence with the appropriate permutation of the values?
00:37:52 <vininim> wli: also multiplying by 0.5 is faster iirc, because FPU units have to inverse and multiply when doing division
00:37:55 <centrinia> wli: Why is it better to bisect after doing Newton iterations instead of before?
00:38:04 <thoughtpolice> oi
00:38:04 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
00:38:18 <centrinia> vininim: You can avoid diving by x altogether.
00:38:25 <thoughtpolice> @seen Lemmih
00:38:25 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
00:38:27 <thoughtpolice> :(
00:39:21 <wli> centrinia: The point is that you have upper and lower bounds on a root outside of which Newton may try to choose a new approximation to the root. The bounding interval maintained is treated as inviolable.
00:40:33 <thoughtpolice> @tell Lemmih ok so I looked into using that hinteger thing - I have both compiled the library itself with LHC (with a small demo application) that when run segfaults, and I also have an experimental branch with the pure haskell Integer lib baked right into the base library (Lhc.Integer,) but after updating all the names/primops, it seems as if that breaks compiling base, so I think I'm not updating something I shoul
00:40:33 <lambdabot> Consider it noted.
00:41:11 <centrinia> f(x) = x^(-2) - a; g(x) = x - f(x) / 'f(x) = x - (x^(-2)-a)/((-2)*x^(-3)) = x- (x^(-2)-a)*x^3/(-2) = x- (x -a*x^3) / (-2) = -3*x + a*x^3/2
00:41:24 <centrinia> The iterations of g(x) should compute 1/sqrt(a)
00:41:46 <wli> centrinia: The way I actually did it was to use cubic, quadratic, and linear Newton analogues in addition to bounding interval's boundaries and midpoints, and then choose the two of those where the function takes on opposite signs the distance between which is least.
00:42:00 <pumpkin> can anyone think of an efficient way to construct a static DAWG?
00:42:09 <centrinia> Dawg? ;)
00:42:23 <pumpkin> not again!
00:42:34 <jml> directed acyclic weighted graph, I assume
00:42:35 <pumpkin> :P
00:42:37 <pumpkin> word graph
00:42:43 <jml> word graph, bah.
00:42:53 <pumpkin> :)
00:43:12 <jml> what's a word graph?
00:43:20 <centrinia> Disconnected Antisymmetric Word Graph?
00:43:31 <pumpkin> jml: it's basically a trie with shared suffixes
00:43:43 <pumpkin> which makes it a DAG rather than a tree
00:43:55 <jml> makes sense.
00:44:43 <centrinia> wli: That sounds a little like the False Position method.
00:46:39 <wli> Regula falsi is quite different.
00:47:00 <wli> (obviously only the real roots are to be used)
00:49:23 <wli> I wrote one thing that used a rational function interpolating the values and first derivatives at the endpoints and midpoint to determine a rational function with cubic denominator and quadratic numerator whose roots are used as approximations to the function's roots, but didn't bother trying to use it anywhere.
01:15:22 <wli> centrinia: http://hpaste.org/13041
01:19:12 <wli> centrinia: This notably does not include a method of determining an initial bounding interval.
01:19:35 <centrinia> Okay.
01:21:25 <wli> centrinia: You can probably see from newtonIter that you can throw in a bunch of other methods for root approximations (e.g. Newton on the endpoints, higher-order Newton analogues) and just pick the pair of abscissae with opposing signs that's closest together.
01:47:24 <jsn> @tell pumpkin in the cedict package on haskell, i construct a large static trie out of a huge chinese dictionary
01:47:24 <lambdabot> Consider it noted.
01:47:54 <jsn> @tell pumpkin i had to use C arrays and pointers to work with it -- the compiler choked on it
01:47:55 <lambdabot> Consider it noted.
01:57:36 <jsn> @tell pumpkin http://github.com/jsnx/cedict/tree/master
01:57:37 <lambdabot> Consider it noted.
02:12:01 <wli> centrinia: fresh update to the Newton code
02:17:38 <wli> centrinia: The convergence criteria need work so that if one of the tolerances is satisfied, best effort occurs for the other.
02:20:45 <Lemmih> thoughtpolice: ping.
02:36:41 <nanothief> can haskell optimize == if two variables are known to be the same? eg let lst = ["this","is","A long test string", "zz"] in delete (lst !! 2) lst, would "A long test string" and (lst !! 2) need to be compared with == ?
02:38:53 <hasky> Hi, is it possible to perform vectorized assignments?  e.g. pseudocode  (ws, xs) = (ys, zs)
02:38:55 <dolio> Haskell doesn't assume anything about the (==) operator that could allow it to do that.
02:39:21 <dolio> It's just an ordinary, defined operator.
02:39:46 <Zao> > let (a,b) = (42, 3) in "yup"
02:39:48 <lambdabot>   "yup"
02:40:05 <hasky> Ooh, thanks :)
02:43:57 <hasky> Zao: sorry, what exactly does 'in' do?
02:47:04 <Lemmih> hasky: It's syntax. LET binds IN expression.
02:47:51 <hasky> Okay, will look up for info about `let' to get an understanding. :)
02:48:02 <hasky> By the way, I am experimenting with $! to get an understanding of /that,
02:48:14 <hasky> Apparently, f $! x = x `seq` f x
02:48:48 <hasky> What is a good way for me to test this out?  Writing my own f and x functions seems a bit long and I'm not entirely sure what to do with them, are there some good built-ins I could use here to demonstrate this?
02:49:25 <Lemmih> Demonstrate what?
02:50:03 <hasky> To demonstrate that f $! x = x `seq` f x
02:50:18 <hasky> I'm not entirely sure what the above expression means, so I'd like to test it out with an actual example
02:50:44 <Lemmih> > const 10 $! undefined
02:50:45 <lambdabot>   * Exception: Prelude.undefined
02:50:46 <Lemmih> > const 10 $ undefined
02:50:48 <lambdabot>   10
02:52:26 <Lemmih> hasky: Looking at strictness annotations probably isn't the best place to start learning Haskell.
02:53:46 <hasky> Lemmih: I'm not brand new to haskell, but my learning has really focused on primitive recursion etc. (university based, and I don't think university-based teaching for programming is ever optimal)
02:54:24 <hasky> So some of the nice syntax that make use of Haskell practical aren't known to me yet, only the `functional concepts' - my course is meant to teach the concepts not the language, unfortunately
02:58:28 <blackh> hasky: I think there's an interesting contrast between your situation and mine. :) I wanted to get a job done, and so I asked myself the question "What would be the best language?" In the process of answering that, I discovered Haskell.
02:59:03 <nj32> which is the tutorial out there which can help me write sizable code in Haskell in no time?
02:59:27 <nj32> i want to write something and see before i learn haskell.
03:00:10 <blackh> nj32: I didn't come across such a thing, but I have been writing sizable code in Haskell.
03:00:56 <nj32> any place where i can see common programs written in haskell
03:01:28 <dibblego> @where hackage
03:01:29 <lambdabot> http://hackage.haskell.org/
03:01:32 <dibblego> nj32^
03:01:36 <nj32> ok
03:01:59 <blackh> nj32: Is there some particular job you are wanting to do?
03:02:24 <nj32> no, i want to learn haskell. i have heard nice things.
03:02:31 <nj32> but i am not able to write code
03:02:39 <nj32> syntax is difficult
03:02:47 <Cale> nj32: Er, the point of learning Haskell would be so that you *could* write code...
03:02:49 <chrisdone> maybe one could use lambdabot to do a ‘Try Haskell!’ tutorial
03:02:51 <Cale> :)
03:03:33 <blackh> nj32: Real World Haskell (the book) and Learn You A Haskell (the tutorial) seem to be the recommended ones at the moment.
03:03:39 <blackh> nj32
03:03:42 <nj32> ok
03:03:46 <blackh> : They're the newest, at any rate. :)
03:03:58 <nj32> is there any K&R type book in Haskell?
03:03:59 <Cale> nj32: Or do you mean you'd like to read some code?
03:04:14 <nj32> Cale: yeah code too. simple ones.
03:04:20 <blackh> nj32: RWH is an O'Reilly book so it's in keeping with their general way of doing things.
03:04:22 <chrisdone> Real World Haskell is the best Haskell book right now. you must read it
03:04:57 <nj32> RWH is the open book, right?
03:05:03 <Cale> http://book.realworldhaskell.org/read/ -- best part is that it's available online :)
03:05:14 <nj32> oh great
03:06:05 <Cale> I have the sense that it may go a little quickly, so you might want to supplement it with tutorials along the way.
03:06:13 <hasky> blackh: out of interest, what kind of task are you looking to achieve?  A lot of people on my course (to which I disagree) are like: "haskell is pointless"
03:06:17 <Cale> (and of course you can always ask questions here :)
03:06:19 <nj32> Ok.
03:07:05 <chrisdone> hasky: haha
03:07:23 <chrisdone> hasky: and you correct them, “I prefer ‘point-free’”
03:07:59 <blackh> hasky: I am writing a fairly large (commercial) web application.  I started with 13,000 lines of Python, then I decided that Python was not for me (perhaps I should have decided earlier).  I've now translated almost all of that into Haskell.  12,500 lines so far.
03:08:32 <Cale> blackh: So it's coming out about the same line count? That's surprising actually.
03:08:43 <Cale> I suppose it depends on what it's doing.
03:09:06 <chrisdone> blackh: what are you using for the web application? FastCGI?
03:09:08 <blackh> hasky: You can't compare it because there's no point at which the two code bases do the same thing.
03:09:41 <blackh> chrisdone: I used FastCGI for a while, but it really doesn't work with Berkeley DBXML (which I'm using for the database), so I've switched to SCGI.
03:10:19 <blackh> ^ should have said "Cale:" above. :)
03:10:25 <chrisdone> blackh: sorry, I'm confused. what does Berkeley DBXML have to do with FastCGI?
03:10:55 <Cale> blackh: but you can compare the whole app, no?
03:11:09 <Cale> (or is the app different now)
03:11:15 <blackh> chrisdone: FastCGI likes to manage the life cycle of the application.  This really doesn't work with Berkeley DBXML and its deadlock detection and so forth.
03:11:55 <blackh> Cale: Not quite, because there's an admin interface that I haven't translated to Haskell, and also a large amount of newer stuff in the Haskell.
03:12:03 <Cale> ah, okay
03:12:12 <blackh> Cale: Python is fairly compact, but I'd say Haskell is even more compact.
03:12:14 <chrisdone> blackh: ah, I see
03:12:22 <chrisdone> blackh: have you been using Formlets‽
03:12:46 <chrisdone> The Way to do Web Forms™
03:13:51 <blackh> chrisdone: No, I haven't - I took a look just now.
03:14:44 <blackh> chrisdone: I've done it my own way... My reasoning is this: It's such a central part of the app, I want total control. :)
03:15:11 <chrisdone> blackh: check out the "Registration form" on this simple paste: http://paste.lisp.org/display/72066
03:15:24 <chrisdone> blackh: was your code as sweetly abstracted as that? :P
03:17:16 <blackh> chrisdone: My code has come out amazing.  I am just trying to get my head around the link you pasted above.
03:17:32 <blackh> chrisdone: Haskell really blew my head off when I was writing the web forms stuff.
03:17:43 <blackh> chrisdone: My code works like this:
03:19:11 <blackh> chrisdone: It's a DSL with a 'render' and a 'process' function.  There are combinators to add validators, change the data type, and to navigate around the data structure you're committing to.  I wouldn't be surprised if it wasn't too different from formlets.
03:19:25 <joelr1> good day
03:19:30 <blackh> chrisdone: And of course there's a 'validation' combinator.
03:20:12 <chrisdone> blackh: yeah, sounds similar. I had written my own, too, before discovering the Formlets library
03:21:34 <blackh> chrisdone: Thanks for that. I'll look into it more.
03:22:41 <blackh> chrisdone: Can you make a widget that takes you to another page and back?
03:22:49 <chrisdone> blackh: sure. I rave about this library a lot, haha. I'm going to write a blog post explaining it today. Chris Eidhof's is kind of out of date and doesn't have monadic validation
03:23:16 <chrisdone> blackh: I've never considered that. would that involve some kind of continuation?
03:23:45 <blackh> chrisdone: Mine is totally pure, which has been good but I am feeding stuff into it (from monad-land) during construction which is a bit wrong.
03:25:35 <chrisdone> blackh: right
03:26:54 <blackh> chrisdone: http://hpaste.org/13043
03:26:57 <chrisdone> blackh: are your forms composable? i.e. you might construct a ‘formlet’ which takes and validates a date of birth. can you then compose that with other ‘formlets’ to make a new, larger, validating formlet?
03:27:00 * chrisdone looks
03:27:35 <blackh> chrisdone: Very much composable. This is exactly the code that has made me realize how brilliant Haskell is.
03:28:04 <blackh> chrisdone: Some explanation of that paste: It's a "change password" button that takes you to another page, and this is in a composable manner.
03:28:10 <chrisdone> blackh: ah, indeed! handling forms is probably the best example of Haskell's composability!
03:28:50 <nj32> blackh:  Learn You A Haskell is good. Thanks.
03:31:15 <blackh> chrisdone: In some ways this code isn't such a good example - because I jump out of composability land and stick a custom 'process' method on.
03:31:31 <chrisdone> blackh: hmm. I'm not sure why changing the page is relevant to handling forms. can you explain? does it have to be a button? couldn't it be a hyperlink?
03:31:47 <blackh> chrisdone: Password validation breaks the model slightly in that you're validating on more than one input field.
03:32:17 <chrisdone> blackh: hmm. the validation is not composable?
03:32:37 <Tim-_> hi there! I need to write an essay about contracts in haskell, i understand the concept, but cant get it working in the ghci
03:32:38 <blackh> chrisdone: The point is that when you click the button, it commits your current form, and when you click OK or Cancel on the 'subpage', it takes you back to the original form.
03:33:17 <blackh> chrisdone: The validation is normally composable, but this assumes that you're validating a single field, whereas with a password you have to take two fields as input.
03:34:00 <vixey> @seen mmorrow
03:34:00 <lambdabot> mmorrow is in #darcs, #ghc and #haskell. I don't know when mmorrow last spoke.
03:34:42 <chrisdone> blackh: ah, I see
03:37:04 <chrisdone> blackh: in that case maybe I'll cover validating several fields for one value with Formlets in my blog entry
03:37:52 <nanothief> dolio: thanks (about the == thing, very delayed response :D)
03:39:06 <blackh> chrisdone: Tell me your blog's URL.
03:39:22 <chrisdone> blackh: http://chrisdone.com/blog/
03:43:51 <blackh> chrisdone: I had to look up Lojban.  I'm old school myself:  Esperanto estas mia homkrea lingvo.
03:44:21 <chrisdone> blackh: haha... yeah, ignore that stuff. just the Haskell tag :P
03:51:28 <Raevel> chrisdone: nice portrait
03:53:23 <chrisdone> Raevel: thanks :D
03:53:51 <Raevel> i gave my sicp to a friend, but i'm getting a hardback!
03:54:03 <chrisdone> ^_^!
04:02:29 * ksf got a hardback CTM in case he should need to slay a velociraptor.
04:06:42 <Raevel> ctm?
04:07:00 <vixey> heavy book
04:07:46 <ivanm> ksf: who was scared of velociraptors first, you or Randall? ;-)
04:08:21 <Raevel> we had an Ada exam that only contained velociraptor-related problems
04:08:29 <ivanm> Raevel: lol
04:10:15 <Dynetrekk> hi guys, anyone know why this fails? http://hpaste.org/13045
04:10:22 <hasky> What's the most efficient way of seeing if in a pair of values one or two are undefined?
04:10:30 <purple__> newbi question - SortBy expects the predicate to return an Ordering type rather than bool. How can I make this work --> sortBy (\ a b -> a < b) ([1 .. 10])
04:10:33 <mbz> ksf, what does CTM stand for?
04:10:35 <hasky> Not fussed about the number of undefined, just need to confirm both are defined
04:10:44 <vixey> hasky, I don't think there's _any_ way, let alone efficient
04:10:56 <vixey> hasky, why is it that you come across undefined values?
04:11:21 <hasky> vixey: I'm using primitive recursion and pattern patching, e.g. mergeSort (x:xs) (y:ys)
04:11:38 <Dynetrekk> the problem is related to library dependencies (unfortunately)
04:11:45 <hasky> vixey: the base case will be where x & y are undefined
04:11:45 <vixey> hasky, (it's actually an effect to detect undefined)
04:12:02 <ivanm> Dynetrekk: do you have gsl installed?
04:12:10 <Dynetrekk> ivanm:  yep
04:12:14 <ivanm> if so, did you upgrade it recently?
04:12:20 <ivanm> as in after installing hmatrix?
04:12:55 <Dynetrekk> ivanm:  http://hpaste.org/13045#a1
04:12:59 <ivanm> works here :s
04:13:18 <Dynetrekk> ivanm:  I just installed macports, and ghc + gsl from there, and cabal, and hmatrix via cabal.
04:13:19 <ivanm> did you try rebuilding hmatrix?
04:13:25 <Dynetrekk> ivanm:  I just built it
04:13:27 <hasky> vixey: well, I basically want to confirm that both x & y are defined before recursing again
04:13:28 <Dynetrekk> ivanm:  but sure
04:13:30 <ivanm> ahhhh, k
04:13:37 <ivanm> did you try hmatrix's tests?
04:13:41 <vixey> hasky, it's not possible to do so
04:13:55 <hasky> vixey: one way could be using pattern matching to do it, i.e. mergeSort [] _ / mergeSort _ [], but I'd rather use guards
04:13:55 <vixey> hasky, I mean practically and theoretically
04:14:05 <Dynetrekk> ivanm:  nope! how to?
04:14:14 <Dynetrekk> ivanm:  uh, and I don
04:14:18 <ivanm> it's in the hmatrix user guide IIRC
04:14:19 <Dynetrekk> t know how to rebuild in cabal
04:14:22 <Dynetrekk> aha
04:14:24 <vixey> hasky, by undefined, you mean "[]" ?
04:14:29 <vixey> hasky, [] is called nil
04:14:57 <ivanm> cabal install --reinstall hmatrix
04:15:02 <ivanm> Dynetrekk: ^^ that should do it
04:15:27 <hasky> vixey: the function takes list parameters - I could match those lists against nil in pattern matching, but I'd rather check their definedness after they've gone through the (x:xs) pattern match, i.e. check x
04:15:36 <vixey> hasky, by undefined, you mean "[]" .....?
04:15:37 <Dynetrekk> ivanm:  I'll try but I have a hard time understanding what the diference should be from last attempt
04:15:48 <vixey> hasky, undefined has a different meaning in haskell that []
04:15:56 <Dynetrekk> ivanm:  same error, yep
04:16:16 <ivanm> Dynetrekk: what version of gsl, lapack and blas do you have?
04:16:46 <hasky> vixey: yes yes.  But these are two different ways of achieving my goal.  Pattern matching for [] will confirm that the parameter is empty.  However, I'd rather not stop it at this point.  I'd rather my function check x after the match (x:xs), therefore lists are now irrelevant
04:16:56 <Dynetrekk> ivanm:  runtests in hmatrix gives same error
04:16:59 <Dynetrekk> ivanm: hm, let me check
04:17:04 <hasky> vixey: i.e. I'd like to only have a single pattern match
04:17:04 <vixey> hasky, are you calling [] undefined?
04:17:09 <Dynetrekk> ivanm:  it's the most recent one in macports 1.7 anyway
04:17:16 <hasky> vixey: don't worry about it.  I'm not.
04:17:46 <Dynetrekk> ivanm:  gsl 1.11 .... don't know about lapack and blas
04:17:50 <hasky> I was talking about x after (x:xs)
04:18:28 <hasky> Not considering [] of any form, I'd like to check whether after matched with (x:xs), x is defined or not
04:18:32 <kosmikus> why would x be undefined?
04:18:47 <Dynetrekk> ivanm:  it seems to me that gsl is the one that fails?
04:18:48 <hasky> Maybe I should post up what I've got
04:19:21 <hasky> http://pastebin.com/d12a0d1b8
04:19:25 <ivanm> Dynetrekk: yeah, and I'm wondering whether its because you don't have lapack and blas installed, and IIRC gsl requires them (well, blas at least)
04:19:33 <Dynetrekk> ivanm:  I seem to find something here: http://www.haskell.org/haskellwiki/GSLHaskell_on_MacOS_X
04:19:41 <Dynetrekk> ivanm:  BLAS and LAPACK are already in OS X
04:19:44 <vixey> I thought it was ocaml :P
04:20:02 <hasky> kosmikus: I pattern match my parameter with (x:xs), then recurse using xs again.  However, xs might not exist, if the originally list parameter had only one element
04:20:06 <ivanm> Dynetrekk: oh, yeah, macs a bit funny
04:20:14 <ivanm> Dynetrekk: did you follow those directions?
04:20:20 <Dynetrekk> ivanm:  funny? they come with stuff people need to run their applications :P
04:20:24 <vixey> hasky, it still exists it's [] not undefined!!
04:20:26 <kosmikus> hasky: you need a case for []
04:20:34 <vixey> hasky, Impossible to explain this to you ... lol
04:20:38 <Dynetrekk> ivanm:  I just found them. I'll try. thanks for your help anyway (I might bother you again though :))
04:20:48 <hasky> vixey: no idea why you're going on about [], I'm talking about x
04:20:58 <kosmikus> no, you're talking about xs
04:21:02 <vixey> hasky, you're so confused lol
04:21:06 <ivanm> Dynetrekk: funny as in the build instructions for hmatrix requires special instructions ;-)
04:21:08 <ski_> > let foo (x:xs) = (x,xs) in foo [0,1,2]
04:21:10 <lambdabot>   (0,[1,2])
04:21:12 <vixey> hasky, look [1,2,3] == 1 : (2 : (3 : []))
04:21:14 <ski_> > let foo (x:xs) = (x,xs) in foo [0]
04:21:15 <lambdabot>   (0,[])
04:21:20 <vixey> hasky, look [1,2,3] /= 1 : (2 : (3 : undefined))
04:21:23 <hasky> kosmikus: my original implementation indeed, but I'd prefer to not have extra pattern matches
04:21:40 <kosmikus> hasky: but you *need* an extra pattern match
04:21:49 <vixey> well you can do lisp style
04:21:50 <Dynetrekk> ivanm:  I'll get back to that...in the meantime: where do I find hmatrix.cabal?
04:21:52 <vixey> (if null xs then
04:21:55 <vixey>    []
04:21:57 <ivanm> hasky: what's wrong with an extra pattern match?
04:22:01 <vixey>    else merge ...)
04:22:03 <kosmikus> vixey: that's still a pattern match, just not explicit
04:22:17 <vixey> yeah true
04:22:25 <ivanm> Dynetrekk: you'll have to unpack ~/.cabal/packages/*/hmatrix.whatever
04:22:35 <ivanm> edit the cabal file
04:22:36 <Dynetrekk> ivanm:  right... but I have to change it before I install, I guess
04:22:38 <ivanm> then repack it
04:22:43 <Dynetrekk> really? that's it?
04:22:47 <hasky> Just prefering a uniform interface and don't want to pattern match every possibility (for I may expand the number of parameters in future)
04:22:50 <ivanm> AFAIK, that appears to be it
04:22:51 <Dynetrekk> how does this change my install?
04:23:05 <kosmikus> hasky: merge _ _ = []
04:23:19 <kosmikus> or beter: merge le _ _ = []
04:23:21 <ivanm> Dynetrekk: because the .cabal file is included in that tarball
04:23:22 <kosmikus> as a second case
04:23:30 <hasky> kosmikus: will that not pattern match everything, though?
04:23:40 <Dynetrekk> ivanm:  yeah, but does hmatrix use the stuff in the tarball?? confusing
04:23:51 <ivanm> so you edit the .cabal file in that tarball, then when cabal-install goes to install it, it unpacks that tarball and follows the build instructions in the .cabal file
04:23:52 <kosmikus> hasky: yes, and you probably don't want to return the empty list either
04:24:01 <Dynetrekk> ivanm:  allright..
04:24:01 <ivanm> Dynetrekk: the install instructions are packaged with the source ;-)
04:24:08 <hasky> I want to return an empty list to cease recursion
04:24:08 <kosmikus> hasky: but it's a way to at least get a total definition with just one more line
04:24:13 <ivanm> analogous to the Makefile for C-based projects, etc.
04:24:17 <Dynetrekk> ivanm:  right, but I just did "cabal install hmatrix"
04:24:27 <ski_> hasky : btw, `x : y ++ merge le xs ys' looks like a type-error to me (the other one as well)
04:24:44 <hasky> possibly yes, I'll go through that
04:25:09 <ivanm> Dynetrekk: so change the .cabal file in the tarball, then do "cabal install hmatrix --reinstall"
04:25:11 <vixey> hasky, but do you know exactly what [] is now?
04:25:15 <ivanm> and it will rebuild it with the new build format
04:25:16 <Dynetrekk> ivanm:  I see now
04:25:19 <ski_> @type let foo x y zs = (x : y ++ zs,y : x ++ zs) in foo
04:25:21 <lambdabot>     Occurs check: cannot construct the infinite type: a = [[a]]
04:25:21 <lambdabot>       Expected type: [[a]]
04:25:21 <lambdabot>       Inferred type: a
04:25:37 <hasky> ski_: yes, fixed it already
04:25:44 <ivanm> Dynetrekk: note that those instructions might need to be updated, as its obviously for an older version ;-)
04:25:57 <hasky> vixey: yes, but I wasn't talking about lists to start with, but x (which was extracted from my list)
04:26:13 <Dynetrekk> ivanm:  I'll try and see
04:26:31 <kosmikus> hasky: but x is always defined except if you call merge on very strange lists
04:27:12 <ski_> hasky : if you match `foo' against `x:xs', and the match succeeds, then `foo' cannot have been `[]' (since then the match would have failed)
04:28:05 <hasky> http://pastebin.com/m4eedad18 - at any rate, this works
04:28:47 <ski_> fsvo "works"
04:28:58 <kosmikus> hasky: well, you probably don't want to return [] in those two cases
04:29:35 <hasky> kosmikus: previous values from recursive calls will be prepended to it with : though, what else would it return?
04:29:49 <Dynetrekk> ivanm:  this is a ridiculous question, but: how on earth do you make a tar.gz archive in the terminal? I don't understand the man pages, obviously
04:29:55 <hasky> Main> merge le [1, 5, 8] [1, 3, 7]
04:29:59 <hasky> [1,1,3,5,7,8]
04:30:08 <ski_> hasky : try `merge (<=) [0,10,20,30] [5,40]'
04:30:08 <ivanm> Dynetrekk: I usually just use the atools package to do it for me ;-)
04:30:15 <Dynetrekk> hm, atools?
04:30:37 <ivanm> http://www.fatalmind.com/software/hatools/
04:30:40 <hasky> ski_: interesting :o
04:30:45 <hasky> ski_: [0,5,10,40]
04:30:45 <ivanm> wait, that's not it
04:31:01 <kosmikus> hasky: yes, we know :)
04:31:09 <ivanm> http://www.nongnu.org/atool/
04:31:13 <ivanm> Dynetrekk: ^^ that link ;-)
04:31:33 <hasky> Oh wait
04:31:38 <ski_> maybe a more explicit example is `merge (<=) [0,10,20,30] [5,40,7]'
04:31:44 <ski_> (try that as well :)
04:31:48 <hasky> I'm going from the presumption that both lists are the same length in my code
04:31:54 * hasky slaps forehead
04:33:01 <nj32> If i write:    num = 10   : is num a function or data?
04:33:13 <vixey> both
04:33:13 <ivanm> nj32: a variable
04:33:27 <ivanm> vixey: I thought functions had at least one argument...
04:33:35 <hasky> ski_: hmm.. how can I fix this?
04:33:39 <vixey> typeclass dispatch
04:33:41 <ski_> nj32 : the value of `num' will be a number
04:33:59 <nj32> what is num by itself?
04:34:00 <ski_> hasky : "this" being ?
04:34:26 <dbbddbdb> Hi!  I have a possibly silly question on categories…  http://en.wikibooks.org/wiki/Haskell/Category_theory in the first block of questions has «(Harder.) If we add another morphism to the above example, it fails to be a category. Why? Hint: think about associativity of the composition operation.»
04:34:32 <hasky> ski_: this as in the function that you're demonstrating to need fixing, i.e. merge
04:34:50 <dbbddbdb> But why is that?  f.(g.h) is equal to (f.g).h
04:35:15 <nj32> ivanm: is num = 10 a definition or a declaration?
04:35:15 <ski_> hasky : consider i give you two hands of cards, each sorted by value (1 to 12), how would you merge those two by hand ?
04:35:35 <Dynetrekk> ivanm: ~/.cabal/packages/hackage.haskell.org/hmatrix/0.5.0.1 $ apack -F .tar.gz hmatrix-0.5.0.1
04:35:36 <Dynetrekk> apack: hmatrix-0.5.0.1: refusing to overwrite existing file
04:35:36 <Dynetrekk> whut? there is no existing .tar.gz file!
04:36:06 <ski_> (dbbddbdb : nick perchance inspired by `bddbddb' ?)
04:36:07 <Dynetrekk> ivanm:  funny behavior :P
04:36:33 <ski_> nj32 : it defines `num', so ..
04:36:35 <ivanm> Dynetrekk: heh
04:36:36 <dbbddbdb> ski_: no, it's just number 13 encoded in binary
04:36:54 <hasky> ski_: comparing each card from each hand starting from lowest (less or equal than) and putting the appropriate card into a third pile
04:36:55 <Dynetrekk> ivanm:  I figured it out, but cryptic enough
04:37:06 <ivanm> heh
04:37:13 <hasky> er, appropriate card into the third pile before the other*
04:37:18 <hasky> actually, no
04:37:21 <ivanm> nj32: I normally don't bother with that level of semantics ;-)
04:37:28 <ivanm> but I'd say a definition, since it's immutable
04:37:42 <nj32> okay
04:37:57 <dbbddbdb> ski_: oh, no, it's ascii code for «e»
04:38:02 <hasky> ski_: could you modify my merge function (assuming it is a small change) to show it working correctly?  I'm having trouble understanding
04:38:18 <ski_> (dbbddbdb : i *was* starting to wonder which of use was insane ..)
04:38:27 <ski_> (s/e//)
04:38:43 <nj32> ski_, ivanm: thanks
04:39:19 <ski_> hasky : i could .. but would you be learning anything then ?
04:39:48 <hasky> ski_: yes, because I'll analyze the change
04:40:59 <vixey> hasky, drop the assumption that lists have the same length
04:41:26 <hasky> vixey: yes, I know to do that now, but unsure how to go about implementing this with different sized lists
04:42:02 <vixey> what's the head of the list  merge (<) (3 : morestuff) (7 : otherstuff)  ?
04:42:31 <hasky> 3..?
04:42:38 <vixey> yeah
04:42:43 <vixey> and what's the tail?
04:42:56 <ski_> bbdb : i'm not sure what "the above example" refers to
04:43:08 <hasky> that'd depend on the otherstuff, i.e. the largest value morestuff1 union morestuff2
04:43:35 <vixey> hasky, you can do it without looking at morestuff or otherstuff
04:43:45 <ski_> hasky : what is the head of the tail ?
04:44:23 <hasky> Oh, tail, I was thinking of last - head of tail would surely be 7
04:44:31 <hasky> I think.. >_<
04:44:31 <vixey> no it would not be 7
04:44:51 <vixey> merge (<) (3 : morestuff) (7 : otherstuff) = 3 : what
04:44:55 <vixey> what is what?
04:45:08 <Dynetrekk> ivanm:  after following instructions, I get it to find gsl, but not gslcblas.... hm.
04:45:12 <ski_> hasky : consider `merge (<) (3 : 4 : []) (7 : [])'
04:45:51 <Dynetrekk> ivanm:  sorry, now things changed :P
04:46:01 <ivanm> heh
04:46:10 <Dynetrekk> ivanm:  I need to set some env variable
04:46:18 <Dynetrekk> seems "hackish" but it works at least... :S
04:46:21 <ivanm> no idea, sorry... it Just Works (R) here ;-)
04:47:20 <Dynetrekk> ivanm: sure... great. it's export LD_LIBRARY_PATH=(...) anyway... I'm not sure if you know how that stuff works. I'm not sure if I should just put that into .bash_profile? does it sound reasonable to you?
04:47:30 <hasky> vixey: what is what?
04:48:08 <hasky> ski_: what about it?  The function generates expected output for that particular input
04:48:24 <vixey> that's why question :p
04:48:57 <ivanm> Dynetrekk: maybe just .bashrc if you're always going to do it from the command prompt anyway
04:49:06 <vixey> expected output should be a sorted list?
04:49:11 <hasky> yes
04:49:19 <Dynetrekk> ivanm:  what's the difference? .bashrc only works if I write bash in bash :P i.e. start a new shell
04:49:22 <ivanm> generally, .bash_profile is for stuff when you log in, .bashrc is for what to do from a prompt
04:49:27 <vixey> so 3 : what
04:49:28 <vixey> ?
04:49:34 <ivanm> Dynetrekk: and by default, .bash_profile evaluates .bashr
04:49:49 <bbdb> ski_: probably the other diagram with morphisms f and g.  But everything that composes in the diagram in the question box is associative.  Can it be an error?
04:49:49 <Dynetrekk> ivanm:  aha... not by default on a new mac, but it's easy to set up I guess
04:49:53 <hasky> Oh idk, I'm just getting more confused here.  With http://pastebin.com/d75cf7ee2 and "merge (<=) [0,10,20,30] [5,40,7]" I'm getting [0,5,10,20,30,40,7]
04:49:56 <hasky> Which is close..
04:50:01 <Dynetrekk> ivanm:  but then I could just as well put it into .bash_profile? no?
04:50:03 <ivanm> Dynetrekk: then again, macs are weird ;-)
04:50:06 <vixey> hasky think of this example ski gave
04:50:29 <Dynetrekk> ivanm:  depends on the eye that sees, I guess. it doesn't rely as much on the terminal, perhaps, and cares less, in some sense.
04:50:31 <ivanm> yeah, I'm just sued to keeping .bashrc clean and only have stuff to do on login, since it evaluates .bashrc anyway
04:50:53 <Dynetrekk> ivanm:  I see
04:51:05 <Dynetrekk> I'll just put it into .bas_profile with an intelligent comment for now
04:51:42 <ivanm> fair enough ;-)
04:52:26 <Dynetrekk> ivanm:  and, BLAS + LAPACK are easy to link to if you program on the mac. the problem occurs when "linux" software should be compiled/linked to these, at least as far as I can tell...
04:52:38 <hasky> vixey: I'm really not sure what you're getting at, he's given many examples, but in my most recent code the last element of the second list is going to the end of the "sorted" list
04:52:47 <hasky> Just need to work out why this is
04:52:50 <Dynetrekk> ivanm:  and I never had problems with non-haskell stuff, or at least vastly less
04:52:59 <ivanm> heh
04:53:14 <vixey> hasky, I think the example ski gave was a pretty good one in terms of working out why this is
04:53:27 <ski_> hasky : i'm sorry, my second example was actually a bit bogus, since the second input list wasn't sorted .. try `merge (<=) [0,10,20,30] [5,40,50]' instead
04:53:27 <Dynetrekk> ivanm:  most stuff Just Works (R)(C)(TM)
04:53:56 <Dynetrekk> ivanm:  you're using linux I guess?
04:54:01 <vixey> merge (<) (3 : 4 : []) (7 : []) -- what's wrong with this?
04:54:11 <ivanm> Dynetrekk: yup ;-)
04:54:12 <hasky> ski_: merge (<=) [0,10,20,30] [5,40,50]  works for me :\
04:54:17 <Dynetrekk> ivanm:  what distro?
04:54:23 <ivanm> and I wrote the gentoo ebuild for hmatrix, and it worked like a charm :D
04:54:25 <ivanm> gentoo
04:54:31 <Dynetrekk> aha, nicely hardcore
04:54:31 <hasky> ski_: [0,5,10,20,30,40,50] is output
04:54:50 <Dynetrekk> ivanm:  what's the charm of gentoo compared to (some-distro) ?
04:54:53 <ski_> hasky : also, afaics, your current last paste looks ok (but `merge le [] [] = []' is not needed)
04:54:59 <Dynetrekk> just curious
04:55:31 <ivanm> Dynetrekk: built from source, flexibility, rolling updates
04:55:34 <hasky> ski_: hmm, ah, I see why the 7 was going to the end now. :)  Wouldn't merge le [] []  occur if both lists are of equal lengths?
04:55:44 <ivanm> though it also means it can be easier to stuff something up and it takes longer to build stuff :s
04:55:54 <Dynetrekk> ivanm:  built from source -> infinite problems with libraries, compiling etc?
04:55:58 <Dynetrekk> right...
04:56:00 <ivanm> dons' beloved arch is similar in some aspects though
04:56:02 <ski_> hasky : yes but that's caught by one of the other base cases
04:56:03 <Dynetrekk> so you learn some things
04:56:11 <Dynetrekk> ivanm:  I see
04:56:14 <ivanm> Dynetrekk: I haven't had that many problems with libs
04:56:35 <Dynetrekk> ivanm: okay, I guess you still have a decent package manager?
04:56:41 <ivanm> arch is often considered a binary version of gentoo, since you have the option of building things from source but most things are binary
04:57:22 <ivanm> Dynetrekk: we have a choice of three ;-) one official, two unofficial
04:57:22 <Dynetrekk> ivanm: aha... sounds reasonable. I use macports, it builds everything from source too, but it's not entirely bug-free (nothing is, I guess)
04:57:35 <Dynetrekk> ivanm: good for you. 1 + 1 on the mac then, I guess :P
04:57:46 <hasky> ski_: oh, I see!  So merge le xs [] would match even if the 'xs' is [] :D
04:58:00 <ski_> hasky : sure, a variable pattern matches anything
04:58:09 <hasky> Thanks :)
04:58:31 <Dynetrekk> ivanm:  thanks for the help - now it's back to asymptotic integral expansions... see you around
04:58:52 <ivanm> heh
04:58:54 <ivanm> cya
05:03:19 <SamB_XP> no, no, you cann't have []:D
05:03:41 <SamB_XP> D isn't remotely typed like [a]
05:05:49 <ivanm> SamB_XP: lol
05:06:33 <ivanm> @remember SamB_XP <hasky> ... So merge le xs [] would match even if the 'xs' is [] :D <SamB_XP> no, no, you cann't have []:D <SamB_XP> D isn't remotely typed like [a]
05:06:34 <lambdabot> Done.
05:07:18 * SamB_XP wonders whether he is really a different person from SamB
05:08:08 <Olathe> They have some theories along that line these days.
05:08:33 <SamB_XP> that who you are depends on what computer you are on ?
05:08:52 <Olathe> Well, not exactly :)
05:08:55 <Olathe> http://www.amazon.com/Multiplicity-Science-Personality-Identity-Self/dp/031611538X
05:09:19 * SamB_XP almost said "sitting in front of", but remembered that he has them on a KVM
05:09:53 <Olathe> You use different brain regions for each, and personality comes from how the active region works.
05:10:06 <Olathe> So, it's possible you're a slightly different person.
05:10:57 <sabren> hi all. how can I convert an Integer into an Int?
05:11:11 <Olathe> I think fromIntegral
05:11:21 <Olathe> > (fromIntegral (1::Integer)) :: Int
05:11:23 <lambdabot>   1
05:11:27 <Olathe> :t (fromIntegral (1::Integer)) :: Int
05:11:29 <lambdabot> Int
05:11:32 <SamB_XP> and I can't really hack in Windows, either
05:11:42 <SamB_XP> heh
05:11:50 <SamB_XP> you needed to use :t on that ???
05:11:54 <Olathe> Heheh
05:12:06 <SamB_XP> well, at least it didn't give back Int :: Int
05:12:07 <Olathe> I suppose the compilability proved it.
05:12:11 <Olathe> Heheh
05:12:18 <SamB_XP> or Integer)) :: Int :: Int
05:12:30 <devragert> i have a question
05:12:44 <SamB_XP> ask it!
05:12:51 <nedko> hello
05:13:01 <devragert> how can i easily check whether some double is in fact integral?
05:13:22 <SamB_XP> first, a warning
05:13:24 <ivanm> devragert: \ d -> (fromIntegral $ round d) == d
05:13:27 <nedko> i compiled& installed ghc, but now when trying to configure darcs i get:
05:13:29 <nedko> checking for module Text.Regex( mkRegex, matchRegex, Regex )... no; and neither in package text
05:13:29 <nedko> checking for module Text.Regex( mkRegex, matchRegex, Regex )... no; and neither in package regex-compat
05:13:29 <nedko> configure: error: Cannot find Text.Regex; try installing the Haskell packages regex-compat or text?
05:13:48 <SamB_XP> devragert: after a certain size, they can't help but be integral
05:13:50 <nedko> how are those haskell packages distributed?
05:14:15 <devragert> i think the code from ivanm will help me out
05:14:19 <Olathe> devragert: Plus, due to rounding, it might be just slightly off an integer, but that got thrown away.
05:14:28 <Olathe> Yeah, that code should do great.
05:14:48 <luite_> devragert: i tested your code yesterday, but it seems to work fine on my computer
05:14:51 <devragert> well, it doesn't matter if it is not 100% precise
05:14:54 <SamB_XP> where are your numbers coming from ?
05:15:27 <devragert> thanks luite for your help
05:15:48 <devragert> i have already found the problem, it was in my definition of rewritingRules
05:18:18 <luite_> devragert: ah good
05:18:49 <Saizan> nedko: see hackage.haskell.org
05:19:09 <sabren> Olathe: thanks... I see why that function should work, but I don't get how to use it
05:19:36 <sabren> i'm still getting complaints that it can't match Int to Integer : http://hpaste.org/13046
05:20:25 <Olathe> sabren: Ahh.
05:20:38 <Olathe> What are you passing to tallyFromInt ?
05:20:45 <Olathe> An Int ?
05:20:48 <sabren> nothing yet
05:20:51 <sabren> it won't compile
05:20:54 <Olathe> Hmm...
05:20:59 <sabren> I was just trying to see if i could make my own Num
05:21:32 <sabren> I was going to try adding Tally "." + 1
05:21:53 <Olathe> I'd do: where j = fromIntegral i
05:21:55 <sabren> and it complained that I didn't have fromInteger, so I tried to make one :)
05:22:01 <Olathe> Without the type stuff written.
05:22:26 <sabren> !!! huh! that worked!!
05:22:42 <sabren> Tally "." + 1  ==>  Tally ".."  :)
05:22:58 <sabren> thanks!!
05:23:02 <Olathe> You're welcome.
05:23:10 <Olathe> The way I put it here was just to show it worked for that.
05:23:36 <nedko> Saizan: but in the index i see only alternative implementations of the package i seem to need, Text.Regex
05:24:25 <nedko> Saizan: i suspect i havent installed some base thing, not additional package
05:25:32 <Saizan> nedko: your error message says to install regex-compat http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-compat-0.92
05:26:16 <vixey> It's so annoying
05:26:31 <vixey> This Shunting Algorithm _does not work_
05:27:08 <SamB_XP> vixey: add wyes and deltas to your switchyard!
05:27:23 <vixey> is that a real thing?
05:27:41 <nedko> Saizan: yes, but it first checks for "text" package. It looks like some base package for me.
05:27:44 <SamB_XP> if you are trying to shunt trains, yes
05:27:58 <vixey> I'm trying to parse infix expressions :(
05:28:08 <Saizan> nedko: text is probably some old deprecated package
05:28:15 <vixey> I didn't find any correctness proof of shunting yard algorihm.. because it's not correct :p
05:28:28 <Saizan> nedko: darcs is also available as a Cabal package: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/darcs
05:28:42 <Saizan> nedko: there you've more explicit dependencies
05:28:47 * EvilTerran cracks his knuckles and sets about making a rudimentary shift-reduce parser
05:29:16 <vixey> I need to find some theory about shift-reduce parser
05:29:38 <SamB_XP> how about interpretive dance ?
05:29:40 <_zenon_> EvilTerran, you know cracking your knuckles will give your problems when you get old?
05:30:11 <b_jonas> vixey: read a book?
05:30:32 * SamB_XP wonders how one can perform an interpretive dance on IRC
05:30:49 <vixey> ............. thanks b_jonas lol
05:31:36 <EvilTerran> _zenon_, i believe the evidence is inconclusive about that
05:31:49 <dolio> _zenon_: That's a myth.
05:32:08 <SamB_XP> dolio: it can't be a myth if the evidence is merely inconclusive
05:32:13 <SamB_XP> it can only be a rumour
05:32:16 <vixey> it still m akes a horrid noise :S
05:32:18 <dolio> Heh.
05:32:38 <dolio> I know I've heard doctors on multiple tv shows say there's no evidence for it.
05:32:40 <vixey> but I don't think it's widely knows that actually shuntig yard doesn't work though??
05:32:46 <dolio> So it can't possibly be true.
05:32:58 <SamB_XP> dolio: that doesn't make any sense
05:33:00 <EvilTerran> i think it's known to cause stretched ligaments, but not arthritis
05:33:26 <SamB_XP> it could be true without actual conclusive evidence having been found, you know
05:33:29 <SamB_XP> lots of things are!
05:33:38 <dolio> Oh really?
05:33:41 <SamB_XP> yes
05:33:47 <vixey> shuft reduce looks like PEG!
05:33:56 <_zenon_> EvilTerran, well I said it will give you a problem, not which type.
05:34:01 <_zenon_> Untyped problem that is.
05:34:01 <SamB_XP> for instance, stuff we haven't figured out yet
05:34:19 <dolio> It is easy to have problems without types.
05:34:41 <EvilTerran> vixey, well, they do some variety of context-free-esque grammars
05:35:52 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=563 -- complete but unsound
05:36:02 <dolio> Isn't LR shift-reduce?
05:38:31 <EvilTerran> dolio, yeah, i think that's it
05:38:49 <EvilTerran> various types of LR, depending on how sophisticated your parsing table is
05:39:50 <_zenon_> EvilTerran, http://en.wikipedia.org/wiki/Cracking_joints
05:40:08 <EvilTerran> http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm <- vixey, this looks like it might be useful
05:40:16 <vixey> thank you
05:41:03 <EvilTerran> it mentions the shunting-yard algorithm, but it looks like it discusses some other things too
05:41:08 <EvilTerran> (like recursive descent parsing)
05:42:53 <chessguy> can someone please explain Applicative to me? i understand Functor as a general container on which you can apply a function to ever element
05:43:23 <dolio> Wow, 50 years cracking only one hand.
05:43:31 <dolio> That's dedication.
05:43:39 <_zenon_> dolio, yeah :)
05:43:52 <ehird> i crack pretty much every part of my hands :q
05:43:59 <devragert> does anyone know what this error means: Printf.printf: argument list ended prematurely
05:44:06 <_zenon_> The front of the chest is nice if you sit badly for hours
05:44:13 <EvilTerran> O.o
05:44:24 <dolio> Yeah I do that occasonially after sleeping weird.
05:44:25 <_zenon_> then sit up, and expand the chest, lean back
05:44:29 <_zenon_> and BAM
05:44:35 <vixey> zenon...
05:44:38 <vixey> please don't do that.....
05:44:58 <EvilTerran> chessguy, i tend to explain it via "class Functor f => Pointed f where pure :: a -> f a"
05:45:05 <vixey> I am expecting that one day you will crack something in a way it doesn't want to go
05:45:18 <chessguy> EvilTerran:  ok
05:45:22 <EvilTerran> with the requirement that forall f x. fmap f (pure x) = pure (f x)
05:45:29 <SamB_XP> devragert: your format string called for more arguments than were passed
05:45:46 <EvilTerran> which does the obvious; it's "return" by another name
05:45:46 <_zenon_> vixey, well... maybe, who knows. I'll have to try.
05:46:10 <Badger> to understand recursion, we must first define recursion.
05:46:16 <EvilTerran> ?type (<*>) -- and then this is the one peculiar to applicative
05:46:17 <_zenon_> "cracking the chest every day for 50 years."
05:46:17 <SamB_XP> EvilTerran: plus it conflicts with Control.Arrow.pure ;-P
05:46:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:46:24 <chessguy> EvilTerran:  yes, with you so far. i was surprised not to see something like that in Functor
05:46:33 <SamB_XP> _zenon_: but NOT the other chest
05:46:47 <SamB_XP> chessguy: that would be strange!
05:47:07 <devragert> SamB_XP: How come? I have just defined:
05:47:08 <EvilTerran> well, the existence of "pure" isn't a requirement of a functor in the category-theoretic sense
05:47:09 <devragert> printNumber d | (fromIntegral $ round d) == d = printf "%.0f%" d
05:47:10 <devragert> printNumber d                                 = printf "%.3f%" d
05:47:33 <_zenon_> SamB_XP, no, that would be weird...... graverobing and stuff
05:47:35 <SamB_XP> devragert: maybe it doesn't like the second %, actually
05:47:41 <b_jonas> indeed because (,) a is a functor and it does not have pure
05:47:42 <SamB_XP> try % instead
05:47:45 <SamB_XP> ARGGG
05:47:52 <SamB_XP> I typed %%
05:48:04 <SamB_XP> but my IRC client interpreted that as %
05:48:14 <chessguy> EvilTerran:  i'm with you so far
05:48:16 <SamB_XP> so to say %% I need to type %%%%, etc.
05:48:21 <devragert> ah, i didn't notice...
05:48:23 <EvilTerran> chessguy, i believe the term for a functor with that property is "pointed functor", hence me calling the class "Pointed"
05:48:40 <devragert> ok, thank you SamB_XP
05:48:45 <SamB_XP> so, anyway, try %% instead of just % in the last spot ;-)
05:49:00 <Badger> %%
05:49:03 <Badger> huh
05:49:29 <SamB_XP> well, my client lets you use % to enter color codes
05:49:31 <EvilTerran> chessguy, and, if we did it my way, we'd have "class Pointed f => Applicative f where (<*>) :: f (a -> b) -> f a -> f b"
05:49:32 <mauke> > ""++ printf "%.3g" pi
05:49:33 <lambdabot>   "3.142"
05:49:36 <SamB_XP> which I forgot
05:49:36 <mauke> > ""++ printf "%.3g" 3
05:49:38 <lambdabot>   "* Exception: Printf.printf: bad argument
05:49:44 <mauke> wtf
05:49:46 <mauke> > ""++ printf "%.3g" 3.0
05:49:48 <lambdabot>   "3.000"
05:50:00 <EvilTerran> with a load of properties demanded of <*>
05:50:04 <SamB_XP> that's not too nice!
05:50:34 <SamB_XP> but C printf would do worse ;-P
05:51:01 <Badger> printf("lies!\n");
05:51:28 <EvilTerran> chessguy, but, basically, to use the "actions and side-effects" terminology we use in terms of monads, "running" the action "f <*> x" would have the side-effects of running f, followed by those of running x, and then its result would be (result of f $ result of x)
05:51:39 <b_jonas> actually c printf is harder to mess up these days than one would think
05:51:58 <b_jonas> because of the compiler understanding it, and because libc printf handling errors sanely
05:52:13 <b_jonas> like not crashing on printf("%s",(char *)0)
05:52:38 <chessguy> EvilTerran:  ohhhh, ok
05:53:07 <mauke> b_jonas: I don't think that's sane
05:53:25 <EvilTerran> chessguy, this has an interesting property compared to monads, in that "what sub-actions will happen later as part of this action" can't be affected by the results of "sub-actions that have already happened"
05:53:33 <b_jonas> mauke: it does help debugging
05:53:35 <EvilTerran> ish
05:53:47 <chessguy> EvilTerran:  hm, now you lost m
05:53:48 <chessguy> e
05:53:48 <EvilTerran> it's a bit of a strange property to try to quantify
05:53:54 <EvilTerran> ?type (>>=)
05:53:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:53:56 <mauke> b_jonas: a segfault would be more helpful
05:54:43 <EvilTerran> chessguy, because "f" in "m >>= f" is a function returning a monadic action, and it gets the result of running "m" as a parameter, the action can be built up in terms of the result of m
05:54:51 <b_jonas> EvilTerran: yeah, sort of
05:55:58 <EvilTerran> chessguy, however, in "f <*> m", f's type is f(a -> b) (for some a,b,f), so its side-effects must happen *before* it does anything that depends on the value its getting as a parameter
05:56:32 <EvilTerran> (f :: f (a -> b)) <*> (x :: f a) :: f b
05:56:45 <EvilTerran> (f :: a -> f b) =<< (x :: f a) :: f b
05:57:07 <Asgaroth> Is there already a more lightweight string replacement function than subRegex or do I have to define one myself?
05:57:43 <EvilTerran> the difference boils down to whether the function parameter is "f (a -> b)" (for <*>) or "a -> f b" (for =<<)
05:57:51 <chessguy> EvilTerran:  ohhh, so like m in "f <*> m" can't be a conditional based on the resulting function of running f
05:58:20 <EvilTerran> because, in the first case, it's an action resulting in (a function that takes the parameter), so the action's effects can't be dependent on the parameter
05:59:01 <EvilTerran> while, in the case of =<<, it's (a function that takes the parameter) returning an action, so the effects of the action can vary in terms of the parameter
05:59:11 <chessguy> yeah
06:00:59 <ski_> > ((evalCont .) . composeM . map (Cont .)) (replicate 1 sumDown) `map` [0..]
06:01:00 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
06:01:03 <ski_> > ((evalCont .) . composeM . map (Cont .)) (replicate 2 sumDown) `map` [0..]
06:01:05 <lambdabot>   [0,1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,154...
06:01:07 <ski_> > ((evalCont .) . composeM . map (Cont .)) (replicate 3 sumDown) `map` [0..]
06:01:20 <ski_> ...
06:01:22 <lambdabot>   thread killed
06:04:08 <solrize_> :t evaluate
06:04:09 <lambdabot> Not in scope: `evaluate'
06:04:16 <ski_> @index evaluate
06:04:16 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
06:04:19 <chessguy> EvilTerran:  so in the case of [], the instance is something like Applicative [] where pure x = [x]; []; fs <*> xs = zipWith ($) fs xs
06:04:30 <chessguy> oops
06:04:39 <chessguy> s/[]; //
06:04:58 <ski_> no
06:05:02 <ski_> that's `ZipList'
06:05:16 <vixey> hi ski
06:05:18 <dolio> Except it's pure x = repeat x.
06:05:21 <ski_> er, actually, it's partially ziplist
06:05:24 <ski_> and partially list
06:05:32 <ski_> vixey : hiya
06:05:55 <EvilTerran> chessguy, that's almost a valid instance; the types would work, but the axioms (which i didn't list) wouldn't hold
06:05:57 <ski_> vixey : what do you think about the above `composeM' use ?
06:06:12 <ski_> vixey : wonderful, isn't it !? :)
06:06:20 <EvilTerran> chessguy, you'd either need to make "pure = repeat" or "fs <*> xs = [f x | f <- fs, x <- xs]" (but not both)
06:06:45 <vixey> let me see it
06:06:50 * vixey didn't read it yet
06:06:51 <EvilTerran> > [f,g,h] <*> [x,y,z] :: [Expr]
06:06:53 <lambdabot>       Ambiguous occurrence `x'
06:06:53 <lambdabot>      It could refer to either `L.x', defined a...
06:06:56 <EvilTerran> ?undef
06:07:15 <EvilTerran> ...
06:07:25 <ski_> > [f x | f <- [(*3),(^3)] | x <- [2,3]]
06:07:27 <lambdabot>   [6,27]
06:07:44 <vixey> @src composeM
06:07:44 <lambdabot> Source not found.
06:07:48 <vixey> :t composeM
06:07:49 <lambdabot> Not in scope: `composeM'
06:08:11 <vixey> :t ((evalCont .) . ?composeM . map (Cont .))
06:08:12 <lambdabot> Not in scope: `evalCont'
06:08:14 <ski_> vixey : sorry, i `@let' it be `composeM [] = return; composeM (f:fs) = composeM fs >=> f'
06:08:23 <vixey> oh ok
06:08:37 <ski_>   evalCont = (`runCont` id)
06:09:06 <EvilTerran> > [f,g,h] <*> [x,y,z] :: [Expr]
06:09:08 <lambdabot>   [f x,f y,f z,g x,g y,g z,h x,h y,h z]
06:09:10 <vixey> @let sumDown = sum . flip enumFromTo 1
06:09:10 <lambdabot>  Defined.
06:09:12 <vixey> > sumDown 10
06:09:13 <lambdabot>   0
06:09:16 <vixey> :(
06:09:31 <EvilTerran> > getZipList (ZipList [f,g,h] <*> ZipList [x,y,z]) :: [Expr]
06:09:33 <lambdabot>   [f x,g y,h z]
06:09:49 <vixey> > let sumDown = sum . enumFromTo 1 in sumDown 10
06:09:50 <lambdabot>   55
06:10:07 <vixey> @let (..) = enumFromTo
06:10:08 <lambdabot>   Parse error
06:10:10 <vixey> @let (...) = enumFromTo
06:10:11 <lambdabot>  <local>:2:8:
06:10:11 <lambdabot>      Ambiguous type variable `a' in the constraint:
06:10:11 <lambdabot>        `Enu...
06:10:20 <vixey> @set -XNoMonomorphismRestriction
06:10:21 <lambdabot>   Parse error
06:10:33 <ski_> > sumDown 5 $ \i -> i * 10 ^ (2*i)  where  sumDown n f = f n + if n == 0 then 0 else sumDown (n-1) f
06:10:35 <lambdabot>   50403020100
06:11:13 <vixey> I don't understand what the Cont does though
06:11:29 <vixey> hm it puts the result of this one into the next?
06:11:31 <ski_> @type let sumDown n f = f n + if n == 0 then 0 else sumDown (n-1) f in sumDown
06:11:32 <lambdabot> forall a a1. (Num a1, Num a) => a -> (a -> a1) -> a1
06:11:42 <ski_> @type let sumDown n f = f n + if n == 0 then 0 else sumDown (n-1) f in Cont . sumDown
06:11:44 <lambdabot> forall a r. (Num r, Num a) => a -> Cont r a
06:12:33 <ski_> > sumDown 5 $ \i -> sumDown i $ \j -> sumDown j $ \k -> 1  where  sumDown n f = f n + if n == 0 then 0 else sumDown (n-1) f
06:12:34 <lambdabot>   56
06:12:42 <chessguy> EvilTerran:  i think i have a little better understanding now, thanks
06:13:20 <ski_> (though i actually didn't use `const 1' above ..)
06:13:56 <ski_> > map (\n -> sumDown n $ \i -> sumDown i $ \j -> j) [0..9]  where  sumDown n f = f n + if n == 0 then 0 else sumDown (n-1) f
06:13:57 <lambdabot>   [0,1,4,10,20,35,56,84,120,165]
06:14:59 <vixey> oh!
06:15:04 <vixey> ok
06:15:21 <ski_> vixey : so `sumDown n $ \i -> f i' is basically "sum all `f i' where `i' ranges over (integers) from `0' to `n' (both inclusive)"
06:15:28 <vixey> yes
06:16:03 <ski_> the nice thing is that nesting these amounts to composing, in the `Cont' monad
06:16:05 <EvilTerran> chessguy, :)
06:16:41 * EvilTerran is still kinda confused by the Cont monad
06:17:09 <vixey> ski_, yes that's cool
06:17:14 <EvilTerran> ?src Cont
06:17:15 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
06:17:25 <vixey> ski_, did you read Shifting the Stage?
06:17:43 <EvilTerran> ?src Cont return
06:17:44 <lambdabot> return a = Cont ($ a)
06:17:50 <EvilTerran> of course
06:18:02 <EvilTerran> ?src Cont (>>=)
06:18:03 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
06:18:05 <EvilTerran> D:
06:18:17 <EvilTerran> ?src Cont callCC
06:18:18 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
06:18:37 * EvilTerran head a splode
06:19:01 <dolio> @djinn-add type Cont r a = (a -> r) -> r
06:19:01 <vixey> I guess stuff like callCC can't be written with the do notation
06:19:24 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
06:19:25 <lambdabot> f a b = a (\ c _ -> b c) b
06:20:15 <ski_> vixey : i started, but then forgot about it ..
06:22:00 * ski_ invokes a continuation in which EvilTerran's head has not (yet) exploded, and presents him/her with (a small) part of the "sploded" head
06:25:21 * EvilTerran follows the "escape" continuation
06:31:26 * ski_ escapes back to an earlier continuation, just where EvilTerran was about to use `/me', intercepts and replaces "a splode" with "explodes"
06:32:10 <olsner> @pl Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
06:32:10 <lambdabot> Cont (runCont =<< f . ((Cont . const) .))
06:32:23 <olsner> oh, klart som korvspad!
06:32:33 <ski_> javisst !
06:32:59 <luite_> hm, my swedish is a bit rusty :P
06:33:02 <olsner> @pl \f -> Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
06:33:02 <lambdabot> Cont . join . (runCont .) . (. ((Cont . const) .))
06:36:03 <ski_> EvilTerran : here's "Devils and Angels" <http://www.cs.chalmers.se/~augustss/AFP/problems/>, for your pleasure alone !
06:38:55 <EvilTerran> ... ok
06:38:57 * EvilTerran looks
06:53:56 <walski> hi
06:54:11 <walski> is there a function which returns exactly what you pass to it?
06:54:31 <mauke> @src id
06:54:31 <lambdabot> id x = x
06:54:37 <walski> danke!
07:00:37 <RayNbow> @pl id . id(id)(id)id . id
07:00:37 <lambdabot> id
07:04:20 <RayNbow> @. pl . djinn type foldl (.) id (repeat id)
07:04:21 <lambdabot> f = id
07:05:18 <Axman6> @pl \f g h x y z -> f z (g y (h z))
07:05:19 <lambdabot> ((const .) .) . (. (flip . ((.) .))) . (.) . (.) . ap
07:05:52 <Axman6> ". (.) . (.) ." what?
07:05:55 <Axman6> :t . (.) . (.) .
07:05:56 <lambdabot> parse error on input `.'
07:06:02 <Axman6> :t (. (.) . (.) .)
07:06:03 <lambdabot> parse error on input `)'
07:06:22 <taari> voodoo!
07:06:35 <mbz> ?t  ((.).(.))
07:06:35 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:06:41 <mbz> ?typ  ((.).(.))
07:06:43 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:06:46 <Axman6> yet again i say, stuff pointfree style
07:06:53 <mbz> ?typ  ((.).(.).)
07:06:54 <lambdabot>     The operator `.' [infixr 9] of a section
07:06:54 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
07:06:54 <lambdabot>         in the section: `((.) . (.) .)'
07:09:57 <b_jonas> urm
07:12:41 <hasky> What is the difference between Int and Integer?
07:13:46 <mbz> Int is a `native' integer
07:14:25 <b_jonas> Integer is a big-int, an arbitary precision integer
07:14:34 <b_jonas> Int has finite precision and can do anything when it overflows
07:26:04 <lunarisbluemoon> Hi, would anyone be able to tell me how to create a ByteArray#? Utterly ridiculous question I know - it is mentioned a lot in the array tutorials but I think I'm missing something..
07:26:34 <Shirakawasuna> sorry for the super newb question, but the super-beginner guide for haskell says that tuples have a fixed number of values.  What does that mean, exactly?
07:27:11 <Zao> Shirakawasuna: It means that (42,3) is a 2-tuple and (42,3,5) is a 3-tuple and never shall they be interchangable.
07:27:14 <Baughn> lunarisbluemoon: What do you need it for?
07:27:16 <lunarisbluemoon> Shirakawasuna: It means that you can't extend a pair to a triple for example
07:27:22 <lunarisbluemoon> As Baughn said
07:27:43 <Shirakawasuna> ah.  That implies that something else allows you to extend a pair to a triple?
07:27:49 <Baughn> Nope
07:27:49 <Shirakawasuna> sorry for being a newb ;)
07:27:57 <Baughn> The type of a tuple encodes its length
07:27:59 <Zao> Shirakawasuna: A tuple is a fixed length ordered set of heterogeneous values, while a list is a variable length sequence of homogeneous values.
07:28:09 <lunarisbluemoon> Baughn: I'm hacking GHC, but this is too nooby a question to ask in #ghc
07:28:27 <Zao> Shirakawasuna: Compare to [42,3] and [42,3,5], which are both [Integer]
07:28:29 <hasky> What exactly does this mean:   instance Capitalisable a => Capitalisable [a] where
07:28:30 <Baughn> Shirakawasuna: (Int,Double) is allowed. The price for this is that you can't just stick three values in a two-tuple.. actually, that's a feature.
07:28:44 <hasky> Before the => seems to be the `context', but I don't see how this fits together
07:28:58 <Asgaroth> hasky: It says that [a] if an instance of Capitalisable if a is one
07:29:07 <vixey> hasky, given Capitalisable a then Capitalisable [a]
07:29:07 <Asgaroth> *is an instance
07:29:09 <Shirakawasuna> zao, Baughn, thanks
07:29:10 <hasky> ah
07:29:18 <hasky> Thanks
07:29:29 <Baughn> hasky: Rather, it says that [a] is an instance of Capitalisable, and you should look at the instance for a to find out how to implement it
07:30:05 <Baughn> hasky: The difference is somewhat important. You can't instance it for [Int] or something jut because Int isn't an instance of Capitalisable; it'll still match the first instance
07:30:10 <vixey> http://www.brawer.ch/prolog/shiftred/ this is great
07:30:33 <Baughn> lunarisbluemoon: Hm. I'd look in the FFI modules
07:31:59 <lunarisbluemoon> Hm thanks Baughn.
07:32:02 <lunarisbluemoon> Will have a look.
07:32:32 <Baughn> lunarisbluemoon: There's also the old "grep the GHC sources for the type" trick
07:34:31 <lunarisbluemoon> Baughn: Yea, have also been investigating that.
07:34:35 <lunarisbluemoon> But there's a lot to digest.
07:34:44 <lunarisbluemoon> I think I just suck at Haskell ;)
07:35:27 <chrisdone> hells yeah, I am free to use Haskell for my web dev. work
07:35:31 <chrisdone> λ_λ!!
07:35:44 <edwardk> chrisdone: gratz ;)
07:35:55 * chrisdone high fives the channel
07:36:56 * lunarisbluemoon wonders if channels have hands to high five back with
07:37:16 * b_jonas high fives back
07:37:28 <pejo> lunarisbluemoon, have you looked at the videos from the GHC hackathons? SPJ is telling about the organization of the compiler sources.
07:38:00 <hasky> Why can I not do instance Capitalisable [Char] where ... ?
07:38:29 <lunarisbluemoon> pejo: Yes, I have seen most of them.
07:38:31 <Baughn> hasky: It'd overlap the Capitalisable [a] instance
07:38:40 <lunarisbluemoon> I'll do more digging.
07:38:51 <lunarisbluemoon> Lest I entail the RTFM response.
07:38:56 <lunarisbluemoon> Which I may have already.
07:38:58 <lunarisbluemoon> :/
07:39:01 <chrisdone> I'm writing a post about formlets, but I'm not sure if I'm going too far. is it too long? I want to do another example with monadic validation against an SQL database, and custom formlet inputs http://chrisdone.com/blog/2001/01/01/Haskell-Formlets:-Composable-web-form-construction-and-validation
07:39:07 <hasky> Baughn: at the moment I have only got:   instance Capitalisable Char where
07:39:19 <Baughn> hasky: Then you can.
07:39:20 <hasky> Baughn: it's forcing me to do  "instance Capitalisable a => Capitalisable [a] where"
07:39:25 <hasky> Hmm
07:39:31 <hasky> I logically would have thought so too
07:39:55 <hasky> Baughn: "Syntax error in instance head (variable expected)"
07:40:16 <hasky> OH, I think it's where I used a variable in the definition of the function used by the instance
07:40:23 <Baughn> hasky: The reason you can't have *both* Capitalisable [a] and Capitalisable [Char] is because, if you did, then the moment someone added Capitalisable Char (remember, classes are open; anyone can add an instance) the program semantics would be somewhat inconsistent
07:40:40 <Baughn> hasky: Well, you can actually override that, but.. don't.
07:41:14 <b_jonas> "forces" reminds me to "http://www.seebs.net/faqs/c-iaq.html#question-10.7"
07:41:29 <Baughn> (Overlapping instances might do it. If you turn that on, the compiler will have a demon pick the instance to use, and probably use different instances for [Char] in different calls.)
07:42:26 <hasky> Baughn: without considering [a] (which I'm not using), why does it expect a variable?
07:42:40 <hasky> instance Capitalisable [Char] where        ->     Syntax error in instance head (variable expected)
07:43:16 <b_jonas> hasky: maybe it's some kind of sytax issue around it. could you show us the whole code?
07:43:24 <hasky> Sure can, uno momento
07:43:26 <Baughn> hasky: I'm not sure. What does the class definition look like?
07:43:35 <EvilTerran> hasky, ah, "instance Capitalisable [Char] where" isn't valid in h98
07:43:48 <b_jonas> EvilTerran: wait, what?
07:44:07 <EvilTerran> but is valid with {-# LANGUAGE FlexibleInstances #-}, which is a widely accepted extension
07:44:11 <b_jonas> I never understood all this class and instance stuff and what's allowed and what is not
07:44:32 <EvilTerran> b_jonas, in h98, the head has to be "TyCon tyVar ... tyVar"
07:44:44 <hasky> EvilTerran: why not?  :(
07:45:40 <Baughn> EvilTerran: So you can't, say, instance Bounded Int?
07:46:06 <EvilTerran> Baughn, no, that's valid; when i say "tyVar ... tyVar", there can be none of those
07:46:28 <Baughn> EvilTerran: But how is that differnt from instance Bounded [Int]? -_-;
07:46:45 <EvilTerran> Baughn, because that's "instance Bounded ([] Int)", and Int isn't a type variable
07:46:49 <Baughn> Oh. Oh, I see.
07:47:00 <Baughn> ..that's awfully inflexible
07:47:22 <EvilTerran> you'd have to use a "newtype IntList = IntList [Int]" and "instance Foo IntList" to be completely h98
07:47:35 <EvilTerran> Baughn, that's why FlexibleInstances is so widely accepted
07:49:16 <chrisdone> ha
07:49:34 <b_jonas> or you could say 'instance (ListIsFoo) => Foo [a];' and add Int to the class ListIsFoo
07:49:43 <EvilTerran> http://haskell.org/onlinereport/decls.html#sect4.3.2
07:49:58 <b_jonas> but that would work only if there's just one argument of the tycon
07:50:32 <EvilTerran> "The general form of [an] instance declaration is (instance cx' => C (T u1 ... uk) where { d }) where k>=0. The type (T u1 ... uk) must take the form of a type constructor T applied to simple type variables u1, ... uk; furthermore, T must not be a type synonym, and the ui must all be distinct."
07:54:09 <ski_> vixey : reduce/2 looks strange in that it may choose to never reduce even if there are ways to reduce
07:54:47 <vixey> I don't know hwat you mean
07:55:16 <vixey> its'  reduce --> brule, reduce.  reduce --> [].
07:56:48 <ski_> `reverse(String,Gnirts),shift_reduce(String,[],Gnirts)' is always true
07:59:08 <byorgey> good morning, #haskell!
07:59:15 <ski_> evening, byorgey
07:59:27 * byorgey fries lambdas over-easy
07:59:36 <byorgey> hi ski_
08:00:27 <vixey> ski_, I don't think that's a problem
08:00:36 <EvilTerran> ?unmtl StateT s [] a
08:00:37 <lambdabot> s -> [(a, s)]
08:00:40 <devragert> when i want to do some debugging in my script, can i then do something like:
08:00:42 <devragert> f :: a - > b
08:00:43 <devragert> f x = y  and print y
08:00:44 <vixey> is it ?
08:00:45 <devragert> (so each time the function f is used, the result is printed in the terminal)
08:01:03 <ski_> vixey : i'm not sure .. it just feel strange that parsing may be id
08:01:04 <athos> hi
08:01:05 <EvilTerran> ?hoogle trace
08:01:06 <lambdabot> Debug.Trace trace :: String -> a -> a
08:01:06 <lambdabot> module Debug.Trace
08:01:06 <lambdabot> package traced
08:01:12 <athos> hi
08:01:18 <byorgey> devragert: use the 'trace' function
08:01:26 <vixey> ski_, It's only finished parsing when the stack 'Gnirts' is []
08:01:27 <devragert> how does trace work?
08:01:30 <EvilTerran> devragert, the function "trace :: String -> a -> a" in Debug.Trace would do the job
08:01:33 <ski_> (well, not exactly `id', but more or less)
08:01:42 <athos> oh, doublepost
08:01:47 <athos> :-)
08:02:01 <byorgey> devragert:   if you write  'trace "blah" x', it will evaluate to x, but print "blah" on the screen.
08:02:11 <byorgey> devragert: so you could define  f x = trace (show y) y
08:02:28 <athos> :t trace
08:02:29 <lambdabot> Not in scope: `trace'
08:02:31 <byorgey> hi athos
08:02:32 <EvilTerran> if you really meant "how", well, it cheats :P
08:02:33 <byorgey> hi athos
08:02:36 <byorgey> =)
08:02:40 <athos> =)
08:02:47 <devragert> ok, thanks!
08:03:06 <byorgey> it uses the-function-that-must-not-be-named
08:03:18 <vixey> @src trace
08:03:18 <lambdabot> trace string expr = unsafePerformIO $ do
08:03:18 <lambdabot>     hPutStrLn stderr string
08:03:18 <lambdabot>     return expr
08:03:22 <byorgey> arrrgghh!
08:03:26 <b_jonas> yeah
08:03:31 <ski_> @smack lambdabot
08:03:32 * lambdabot submits lambdabot's email address to a dozen spam lists
08:03:37 <superborg> metal it
08:03:47 <vixey> ...
08:04:34 <Badger> comes frm hell
08:04:50 <Beelsebob> @vixen what's your email?
08:04:51 <lambdabot> vixenlove@hotmail.com
08:04:54 <Beelsebob> haha
08:05:30 <ski_> (vixey : actually, it finishes parsing when the input string is exhausted ..)
08:05:39 <xhanjian> @src or
08:05:39 <lambdabot> or    =  foldr (||) False
08:06:41 <Badger> @src Maybe
08:06:42 <lambdabot> data Maybe a = Nothing | Just a
08:06:46 <Badger> ah, yes
08:07:17 <athos> @hoogle isPrime
08:07:18 <lambdabot> No results found
08:07:24 <athos> @hoogle prime
08:07:25 <lambdabot> Data.HashTable prime :: Int32
08:07:25 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
08:07:25 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
08:07:25 <lambdabot> a
08:08:54 <athos> > break (\x -> x `mod` 2 == 0) [1,3,5,6,2,3,4,9] == [[1,3,5],[6,2,3,4,9]]
08:08:56 <lambdabot>   Couldn't match expected type `([a], [a])'
08:09:02 <byorgey> athos: no built-in isPrime functions, but I believe there are such things in packages on Hackage
08:09:06 <vixey> ski_, I see what you mean yeah but it is not a broken program is it?
08:09:11 <athos> ah
08:09:11 <athos> its a pair
08:09:13 <athos> ;)
08:09:19 <athos> > break (\x -> x `mod` 2 == 0) [1,3,5,6,2,3,4,9] == ([1,3,5],[6,2,3,4,9])
08:09:21 <lambdabot>   True
08:09:44 <mpeter> whoa
08:09:47 <mpeter> i can understand that now!
08:10:00 <ski_> vixey : i don't think it's unsound, if that's what you're asking
08:10:01 <athos> > break ((mod 2) == 0) [1,3,5,6,2,3,4,9] == ([1,3,5],[6,2,3,4,9])
08:10:02 <lambdabot>   Couldn't match expected type `a -> Bool'
08:10:16 <EvilTerran> > break ((==0).(`mod` 2)) [1,3,5,6,2,3,4,9]
08:10:18 <lambdabot>   ([1,3,5],[6,2,3,4,9])
08:10:20 <vixey> ski_, I want to do formal proofs of parsing
08:10:25 <athos> EvilTerran: ah, thx
08:10:31 <EvilTerran> > break even [1,3,5,6,2,3,4,9]
08:10:33 <lambdabot>   ([1,3,5],[6,2,3,4,9])
08:10:37 <EvilTerran> ?hoogle even
08:10:37 <athos> ;)
08:10:37 <lambdabot> package event-list
08:10:37 <lambdabot> package codec-libevent
08:10:37 <lambdabot> package control-event
08:10:41 <vixey> ski_, so I had a go with shunting yard and it's not sound.... :(
08:10:43 <EvilTerran> ?hoogle+
08:10:45 <athos> that'd be way too simple ;P
08:10:47 <byorgey> mpeter: congrats! =)
08:10:56 <mpeter> > break odd [2,4,6,8,10,12,14,16,18,19,20]
08:10:57 <lambdabot>   ([2,4,6,8,10,12,14,16,18],[19,20])
08:11:22 <mpeter> what's the equivalent to an 'explode' function
08:11:29 <vixey> explode!?
08:11:34 <EvilTerran> mpeter, what does that do?
08:11:39 <ski_> (vixey : btw, i think you could rewrite with `brule,[s] --> vp,np.' (note order) ..)
08:11:41 <vixey> I thin kthats in Control.NuclearWar
08:11:43 <mpeter> aka separate the list into so many items based on the identification of a delimiter
08:11:51 <EvilTerran> ah
08:11:54 <byorgey> ah, you want split =)
08:11:56 <mpeter> or even a condition
08:11:57 <ski_> (s/vp,np/[vp,np]/)
08:11:57 <EvilTerran> you have to write that yourself
08:12:06 <mpeter> :t split
08:12:08 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
08:12:15 <mpeter> randomgen??
08:12:16 <byorgey> mpeter: the problem is, split doesn't exist
08:12:25 <mpeter> nobody wrote it yet?
08:12:32 <vixey> I wrote it once
08:12:32 <byorgey> mpeter: it's far and away the most-asked-for function that isn't in the standard libraries.
08:12:39 <EvilTerran> because there's so wide a design space for list splitting, no-one can agree on one implementation
08:12:47 <mpeter> that's true
08:12:47 <mpeter> ok
08:12:48 * vixey can agree on one implementation
08:12:51 <vixey> :D
08:12:53 <athos> .l.
08:12:54 <athos> :D
08:12:59 <EvilTerran> but it's fairly easy to write recursively with "break", say
08:13:08 <EvilTerran> depending on what behaviour you want
08:13:10 <EvilTerran> ?src words
08:13:11 <lambdabot> words s = case dropWhile isSpace s of
08:13:11 <lambdabot>     "" -> []
08:13:11 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
08:13:14 <EvilTerran> ?src lines
08:13:15 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:13:16 <EvilTerran> hm
08:13:18 <vixey> isn't there only one sensible implementation?
08:13:25 <vixey> the inverse of intercalate
08:13:28 <b_jonas> 's not the implementation but the interface we can't agree on
08:13:29 <EvilTerran> vixey, well, that depends on your choice of interface
08:13:31 <byorgey> someone should just write a 'Data.List.Split' module which implements every conceivable way of splitting a list.
08:13:40 <byorgey> then we can be done with it.
08:13:41 <EvilTerran> list splitting combinators!
08:13:43 <vixey> byorgey, that's not on hpaste already?
08:13:45 <byorgey> yeah!
08:13:49 <mpeter> sounds like there's only one interface that makes sense
08:13:52 <byorgey> vixey: oh, I don't know, it probably is =)
08:13:52 <vixey> :t intercalate
08:13:53 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:13:56 <mpeter> you haskell coders and your 'order'
08:14:01 <vixey> so split :: [a] -> [a] -> [[a]]
08:14:25 <byorgey> vixey: yeah, but you might conceivably want  split :: [a] -> (a -> Bool) -> [[a]] or other such things
08:14:37 <EvilTerran> mpeter, is the item you're splitting (say, a String) on a Char? a String? a (Char -> Bool)?
08:14:50 <vixey> well they can write it themselves?
08:14:50 <byorgey> a String -> Bool?
08:14:50 <idnar> byorgey: that would be splitBy
08:14:52 <vixey> oops
08:14:55 <vixey> that wasn't a question
08:15:00 <idnar> byorgey: or somethiwg
08:15:03 <byorgey> idnar: ok, fair enough.
08:15:09 <idnar> byorgey: but then the other question is how to handle adjacent split delimiters etc.
08:15:12 <vixey> ok call mine unintercalate then
08:15:14 <EvilTerran> if you're splitting on a predicate, do you want to retain the delimiters?
08:15:14 <byorgey> idnar: right.
08:15:16 <idnar> byorgey: see, for example, the difference between words and lines
08:15:18 <vixey> but it's pretty straightforward
08:15:25 <idnar> and what EvilTerran said
08:15:33 <vixey> you lot are making it too complex
08:15:34 * ski_ .oO(untercalate)
08:15:35 <idnar> it would still be nice to have all of them, though
08:15:36 <vixey> no wonder nothing gets done
08:15:49 <mpeter> evilterran: why wouldn't you just confine it to any sort of list
08:15:53 <mpeter> including strings
08:16:00 <idnar> failing that, the version Python implements would probably be useful for most people
08:16:02 <EvilTerran> if you're splitting on a ([a] -> Bool), does it try the shortest delimiters first, or the longest?
08:16:03 * byorgey adds Data.List.Split to his long list of things to hack on at some point
08:16:12 <athos> :D
08:16:16 <EvilTerran> mpeter, i was just using String as an example because it's easier to discuss than [a]
08:16:24 <vixey> byorgey, maybe a wiki page?
08:16:24 <athos> i bet there's a go bot on that lost too, byorgey :D
08:16:30 <vixey> @wiki Data.List.Split
08:16:30 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
08:16:31 <b_jonas> also do they want to retain empty ones at the end etc
08:16:32 <athos> s/lost/list
08:16:33 <idnar> 'foo.bar..baz.'.split('.') == ['foo', 'bar', '', 'baz', '']
08:16:48 <byorgey> athos: heh, somewhat surprisingly, there isn't =)
08:16:53 <EvilTerran> idnar, what about '.foo.'?
08:17:01 <b_jonas> and we may want a split that gets a [Bool] to tell where to split
08:17:02 <byorgey> athos: a go bot is just too much work, I'd never get anything reasonable done if I tried
08:17:08 <idnar> EvilTerran: ['', 'foo', '']
08:17:11 <b_jonas> (and there are also multiple variants of that)
08:17:12 <athos> byorgey: that may be true, yep :/
08:17:13 <EvilTerran> ok
08:17:17 * ski_ wishes for `untercalate d (xs ++ d ++ ys) = xs : untercalate d ys; untercalate _ xs = xs' ..
08:17:27 <idnar> although
08:17:35 <idnar> that's split :: [a] -> [a] -> [[a]]
08:17:36 * byorgey creates a Data.List.Split page on the wiki
08:17:55 <vixey> byorgey, I'm writing unintercalate to add to it :)
08:17:59 <b_jonas> ski_: heh
08:18:00 <EvilTerran> ski_, unfortunately, haskell doesn't do unification in pattern-matching :P
08:18:04 <idnar> '..foo..bar...baz....quux..'.split('..') == ['', 'foo', 'bar', '.baz', '', 'quux', '']
08:18:10 <b_jonas> maybe do it with views
08:18:21 <ski_> EvilTerran : nor running functions backward in patterns ..
08:18:43 <b_jonas> though haskell doesnt' have 'a == a = True; _ == _ = False;' either
08:19:00 <EvilTerran> well, i figure that'd be covered by unification
08:19:27 <vixey> no
08:19:32 * ski_ figures something like that could be made in Mercury
08:19:50 <vixey> it's unification and backtracking
08:19:57 <b_jonas> sik_: it can be made in Mathematica I think
08:20:01 <byorgey> ok, haskell.org/haskellwiki/Data.List.Split
08:20:01 <vixey> so all your functions that pattern match on functions end up with a [] like monad
08:20:04 <vixey> except with some state
08:20:06 <byorgey> please add code!
08:20:19 <athos> btw. if i'd be to write some simple viewing program for a mandelbrot set, and want to include some fancy zoom function (supported by various colouring algorithms).. would i need opengl for this stuff? or would something like cairo suffice?
08:20:34 <Baughn> athos: Well, you certainly wouldn't /need/ opengl
08:20:40 <ski_> (vixey : well, i also sneaked in committed choice ..)
08:20:48 <Baughn> On the other hand, a fancy opengl shader could do most of the work in the GPU
08:20:53 <ski_> (why state ?)
08:20:53 <superborg> except with some state
08:20:57 <vixey> oh I didn't notice that
08:21:04 <vixey> to hold the substitution
08:21:45 <b_jonas> do #haskellers masturbate^Wprocrastinate on inventing these kinds of ideas in the channel all day?
08:21:45 * ski_ looks around ..
08:21:45 <superborg> all the time, and talk all day?
08:21:50 <ski_> which substitution ?
08:22:07 <vixey> the unification one!
08:22:29 <ski_> i leave that to the language implementation :)
08:22:34 <vixey> yes
08:22:40 <vixey> thats why it's in a []-like mona
08:22:44 <vixey> d
08:22:46 <ski_> (just a "couple" of extensions)
08:22:49 <b_jonas> but by the way, the standard also doesn't have a [a]->[a]->Maybe Int list in list search index function
08:22:50 <superborg> you're the standard libraries.
08:23:01 <b_jonas> so why'd they want a split rightaway?
08:24:10 <ski_> (vixey : but .. i wasn't really thinking of it in terms of monads .. just a slightly generalized pattern-matching)
08:24:20 <vixey> ok
08:24:30 <ski_> b_jonas : who wanted `split', you say ?
08:24:30 <superborg> ?
08:24:35 <vixey> but your language is not pure now!
08:24:39 * ski_ has already forgotten
08:24:45 <vixey> well it wouldn't be anyway
08:24:45 <ski_> vixey : why not ?
08:24:55 <vixey> having effects like unification
08:25:02 <vixey> oh, or it is just matching?
08:25:02 <superborg> oh, y-you were finished?
08:25:57 <athos> Baughn: well, i mean, i'm not that experienced with opengl, so i don't want the opengl "handling" to be the bottleneck
08:26:32 <Baughn> athos: Opengl is pointless if all you want is a framebuffer.
08:26:48 <ski_> superborg: are you sure you're human ?
08:26:49 <superborg> a human would remain in helicopters
08:27:30 <Baughn> athos: For something like fractals, the only way it'd help is by moving some of the actual fractal calculations into the gpu. Which is perfectly reasonable, but probably not the best way to start learning opengl. (Worked for me, though)
08:27:55 <b_jonas> Baughn: eek
08:27:56 <Baughn> athos: But if you actually want to calculate the fractals in /haskell/, then just grab a normal framebuffer. Use SDL or something.
08:27:56 <superborg> not nice to first-run again or something.
08:28:18 <athos> Baughn: ok, thanks!
08:30:09 <ski_> (vixey : .. yes)
08:30:48 <EvilTerran> superborg, turing test
08:30:48 <superborg> test
08:31:03 <vixey> ugh
08:31:04 <EvilTerran> whose bot is this?
08:31:05 <superborg> what country are you guys think i'm your panties in this?
08:31:09 <vixey> I don't know my password on haskell wiki
08:31:25 <Baughn> Does your firefox know it?
08:31:33 <Botje> superborg: tramoline
08:31:42 <vixey> no
08:31:43 <Botje> no response, hmm
08:31:59 <EvilTerran> * [superborg] @##metal #mysql #haskell +#knightsofreason ##ProfessorF
08:32:00 <superborg> $join ##professorf
08:32:19 <ski_> EvilTerran : probably belongs to `metal' who joined about half an hour ago, and left shortly after
08:32:20 <superborg> an hour ago it hit me
08:32:28 <EvilTerran> $part #haskell
08:32:31 <EvilTerran> aww
08:32:52 <Baughn> $quit
08:33:08 <EvilTerran> maybe it needs an op to "encourage" it to leave
08:33:09 <superborg> it has nothing to wash your bot needs to learn from and remove a complete psycho
08:33:11 <superborg> metal
08:33:22 <vixey> metal
08:33:23 <superborg> metal is back from: bed
08:33:28 <vixey> metal
08:33:28 <superborg> metal sends hordes of extensions)
08:33:31 <bolrod> superborg: 1/0
08:33:35 <athos> :D
08:33:36 <b_jonas> lol
08:33:40 <metal> !part #haskell
08:33:44 <metal> Sorry!
08:33:47 <b_jonas> log(0)
08:33:57 <Baughn> sutats: Last digit of pi
08:34:41 <b_jonas> Baughn: smallest natural number that cannot be described in a hundred letters in English
08:34:51 <metal> vixey?
08:34:58 <vixey> metal
08:35:08 <Baughn> b_jonas: Empty set
08:35:12 <metal> yes vixey?
08:35:31 <b_jonas> Out[0] = {}
08:35:49 <vixey> how do you do haskel code in the wiki thing?
08:36:23 <byorgey> vixey: <haskell> ... </haskell>
08:36:42 <vixey> cool http://www.haskell.org/haskellwiki/Data.List.Split
08:36:46 <byorgey> or <hask> ... </hask> for small inline stuff
08:37:02 <byorgey> yay, some code!
08:37:10 <byorgey> vixey++
08:37:20 <vixey> :)
08:37:24 <athos> > unlines ["foo", "baz", "ba9"]
08:37:26 <lambdabot>   "foo\nbaz\nba9\n"
08:38:42 * EvilTerran notes that a "splitter combinator" module would be awfully like a general parser combinator module
08:39:38 <ski_> vixey : .. it occurs to me `intercalate d',`untercalate d' only forms a retraction situation
08:39:38 <vixey> EvilTerran, I thought that was the joke
08:40:06 <vixey> ski_, like how I wrote "inverse" with scare quotes?
08:40:26 <ski_> vixey : quite possibly :) (missed that)
08:40:29 <EvilTerran> vixey, well, i was thinking that it might be possible to write higher-level combinators that'd be particularly well-suited to splitting
08:40:56 <vixey> EvilTerran, I thought you were kidding :P
08:41:22 <EvilTerran> only half :P
08:41:39 <EvilTerran> maybe not exclusively splitting, but list-to-list transformations, anyway
08:43:02 <Megzlna> a day on Haskell Manor
08:46:04 <ozy`> oh joy
08:46:18 <ozy`> my linker is now generating bus errors
08:46:19 <chrisdone> yay!
08:46:45 <ski_> Happy Happy Joy Joy.
08:46:54 <chrisdone> haha... brilliant cartoon
08:49:28 <mauke> ghc--  # updating code without updating the documentation
08:53:49 <Zao> mauke: cvs-ghc@ is the documentation.
08:54:20 <mauke> no, http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception-Base.html#4 is
08:57:44 <joelr1> good day
08:57:52 <chrisdone> hello to you
09:00:00 <Baughn> @hoogle asks
09:00:01 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
09:00:06 <EvilTerran> ?src asks
09:00:07 <lambdabot> asks f = do
09:00:07 <lambdabot>     r <- ask
09:00:07 <lambdabot>     return (f r)
09:00:13 <mauke> so ... ghc-6.10 has extensible exceptions but none of the standard exception types are actually extensible
09:00:16 <mauke> is this right?
09:00:43 <EvilTerran> - ed
09:00:57 <Baughn> mauke: It is not, at any rate, right. It may be correct.
09:01:03 <EvilTerran> (sorry, obscure reference)
09:02:05 <Saizan> mauke: e.g. SomeException is extensible
09:02:08 * EvilTerran ponders...
09:02:29 <mauke> Saizan: that's not a real exception type; it's just the root of the "hierarchy"
09:02:35 <EvilTerran> is "Expr -> Expr -> StateT (Map Var Expr) [] ()" a suitable type for a unifier?
09:02:47 <EvilTerran> (given sensible definitions of Var and Expr)
09:03:05 <vixey> no
09:03:23 <EvilTerran> what's wrong with it?
09:03:51 <vixey> I was going to complain that you didn't newtype it ... but now I realize that's not really what you were asking
09:04:14 <vixey> you can do it that way but I would use ST instead
09:04:41 <EvilTerran> yeah, i'd newtype-abstract it if i were doing it properly; i tend to have an implicit "modulo isomorphisms" in my type-related questions :P
09:04:56 <vixey> (like http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62 )
09:05:10 <vixey> except this is not a newtype just a type :S
09:06:00 <mauke> well, I guess this is what GHC.* is for
09:07:27 <ski_> i just realized something
09:08:17 <ski_> in haskell's pair type, `(_|_,_|_)' and `_|_' is not the same thing ..
09:08:30 <opqdonut> wasn
09:08:44 <opqdonut> 't this the main difference between haskell's type system
09:08:46 <opqdonut> and some other one
09:08:55 <vixey> ski_, oh and eta reduction on pairs breaks confluence
09:08:56 <ski_> one could define a strict pair type such that `_|_' is the same as `Pair _|_ y' and `Pair x _|_'
09:08:59 <vixey> coincidence?
09:09:01 <ski_> for any `x',`y'
09:09:04 <mmorrow> preflex: C-decl int mutual(int(*f)(int,int(*)(int)),int(*g)(int,int(*)(int)));
09:09:15 <opqdonut> vixey: ?
09:09:26 <EvilTerran> preflex: list
09:09:26 <mmorrow> preflex: C-decl: int x;
09:09:26 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
09:09:28 <pejo> vixey, can you explain how?
09:09:30 <mmorrow> preflex: Cdecl: int x;
09:09:36 <vixey> yes I can
09:09:41 <EvilTerran> preflex: cdecl int mutual(int(*f)(int,int(*)(int)),int(*g)(int,int(*)(int)));
09:09:42 <preflex>  mutual: function(f: pointer to function(int, pointer to function(int) returning int) returning int, g: pointer to function(int, pointer to function(int) returning int) returning int) returning int
09:09:42 <mmorrow> preflex: Cdecl: int
09:09:45 <vixey> eta is the wrong name I guess but it's similar
09:09:53 <mmorrow> EvilTerran: thx
09:09:56 <ski_> but what if we want `Pair _|_ _|_' to be the same as `_|_' .. but `Pair _|_ y' and `Pair x _|_' should be different (for `x' and `y' not being bottom) ?
09:10:14 * mmorrow is testing if gcc does proper TCO
09:10:36 <mmorrow> (as was claimed the other day)
09:10:38 <EvilTerran> i suspect not if you're using function pointers
09:10:47 <mmorrow> EvilTerran: me neither
09:10:56 <Saizan> ski_: in principle you could make _|_ behave as (_|_,_|_) is now
09:10:57 <ski_> (vixey : i'm not sure `eta' is the wrong name .. but let me see)
09:11:09 <EvilTerran> although i guess it shouldn't be too hard to identify when a function pointer is invoked in tail position
09:11:09 <ski_> Saizan : yes .. but how to implement this ?
09:11:16 <vixey> hi mmorrow
09:11:28 <mmorrow> EvilTerran: yeah, i'm curious how this is going to turn out
09:11:33 <mmorrow> vixey: heya vixey
09:11:44 <vixey> mmorrow, Shunting Yard Algorithm is not correct :)
09:11:45 <EvilTerran> and then replace this invocation of a function on the stack with the call to the funptr
09:11:47 <pejo> vixey, ok, care to sketch how then?
09:11:49 <ski_> i was previously thinking one needed to spawn two threads forcing the parts, and terminate the other one as soon terminates
09:12:02 <athos> > length "foo\n"
09:12:04 <lambdabot>   4
09:12:24 <mmorrow> vixey: dang. how so?
09:12:47 <mmorrow> vixey: err, what do you mean?
09:12:49 <EvilTerran> it seems to me that you could make (a,b) have no _|_, only (_|_,b) and (a,_|_)
09:12:55 <vixey> pejo, if you reduce like pair_AxA(pi1(M), pi2(M)) ~~> M then  pair_BxB(pi_1(pair_AxA(a,a)), pi_2(pair_AxA(a,a))) ~~> (a,a) : AxA whereas it should be BxB
09:13:02 <dolio> eta is p = (fst p, snd p).
09:13:05 <EvilTerran> by making it implicitly irrefutably matched
09:13:10 <Saizan> ski_: in haskell you could hide the constructor and export only fst and snd
09:13:13 <EvilTerran> but that seems ugly
09:13:19 <Saizan> or what EvilTerran said
09:13:25 <vixey> mmorrow, it is complete wrt to my specification, but it is not sound
09:13:35 <Saizan> which is what Miranda did
09:13:37 <vixey> mmorrow, i.e. for any valid parse tree -- there is a shunting yard execution
09:13:49 <vixey> mmorrow, *but* every shunting yard execution does not mean a valid parse
09:13:50 <ski_> EvilTerran : exactly .. though you need to take some care with things like `(_,False)'
09:13:51 <b_jonas> but you can't hide seq
09:14:01 <ski_> death to `seq' !
09:14:11 <pejo> ski, The introduction to "Fast and Loose Reasoning is Morally Correct" contains your pair example, btw
09:14:19 <vixey> mmorrow: there is examples http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=563#a564
09:14:19 <roconnor> ski_: what happens if you represent pairs by continuations, and assume there is no seq?
09:14:27 <mmorrow> vixey: interesting
09:14:29 * mmorrow looks
09:14:48 <b_jonas> ski_: by continuations, do you mean functions of (a->b->c)->c ?
09:14:48 <ski_> vixey : that's an `eta' reduction, in my book
09:14:52 <vixey> ok
09:15:02 <b_jonas> oh yeah, that's continuations
09:15:25 <ski_> (`eta' is "elimination, followed by introduction, is the same as doing nothing")
09:15:30 <roconnor> forall c. (a->b->c)->c
09:16:43 <ski_> vixey : what's this `_AxA' and `_BxB' stuff ?
09:17:03 <vixey> annotations
09:17:13 <ski_> for ?
09:17:44 <ski_> (can't be types, since then `B' should be `A')
09:18:43 <EvilTerran> > do x | False <- Just 1; return x
09:18:44 <lambdabot>   <no location info>: parse error on input `|'
09:18:47 <EvilTerran> thought so
09:19:26 <ski_> > (\x | False -> ()) ()
09:19:27 <lambdabot>   <no location info>: parse error on input `|'
09:19:34 <mmorrow> @tell erikc didn't get around to updating src-meta last night. will do today.
09:19:34 <lambdabot> Consider it noted.
09:19:51 <pejo> b_jonas, Janis Voigtlnder has some recent articles on short cut fusion in the presence of seq. Not sure that is what you mean by 'hide' though.
09:20:16 <roconnor> > let x | False = () in x
09:20:18 <lambdabot>   * Exception: /tmp/4335872742002916928:71:36-49: Non-exhaustive patterns in ...
09:20:40 <mpeter> > fix (map sin [1..10] == map sin [1..10]:)
09:20:41 <lambdabot>       The operator `:' [infixr 5] of a section
09:20:41 <lambdabot>          must have lower prece...
09:20:46 <mpeter> damn
09:20:53 <mpeter> > fix ((map sin [1..10] == map sin [1..10]):)
09:20:54 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
09:21:19 <dolio> > fix(True:)
09:21:20 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
09:22:13 <mpeter> i wanted to make it big and clunky
09:22:29 <mpeter> > fix (False:)
09:22:30 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
09:24:14 <int-e> > fix ((map (ap (/) sin) [0..10] == map (ap (/) sin) [0..10]):)
09:24:16 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
09:24:52 <mpeter> i hereby propose that all equality tests are framed within an infinite list
09:25:00 <ski_> roconnor : i think `_|_' could be translated into `\k -> _|_', `(_|_,y)' into `\k -> k _|_ y', and `(_|_,_|_)' into `\k -> k _|_ _|_' .. which all seems (partially) different
09:25:43 <mpeter> http://kib2.free.fr/Haskell/HaskellQR.pdf
09:25:56 <roconnor> ski_: ah
09:26:13 <Sadache> Hello there
09:26:53 <Sadache> I was trying to use Happs and I noticed something strange for me inside a Component instance decleration
09:27:17 <Lemmih> Sadache: Oh?
09:27:34 <Sadache> there is a type defined inside the Component class type instance declaration
09:28:00 <ski_> @djinn (forall c. Either (a -> c) (b -> c) -> c) -> Either (b -> c) (a -> c) -> c
09:28:00 <lambdabot> -- f cannot be realized.
09:28:08 <Lemmih> Sadache: Yep, that's an indexed type.
09:28:15 <mpeter> > filter Char.isUpper "Girls Really Omit Sensible Sensuality"
09:28:16 <lambdabot>   /tmp/941407323659975460:70:39: Not in scope: `Char.isUpper'
09:28:23 <roconnor> djinn doesn't know forall
09:28:25 <mpeter> > filter isUpper "Girls Really Omit Sensible Sensuality"
09:28:26 <lambdabot>   "GROSS"
09:28:32 <mpeter> :D
09:28:34 <ski_> just remembered :/
09:28:36 <vixey> what's a good algorithm for djinn + forall?
09:28:54 <Sadache> Lemmih: is it an extension?
09:29:01 <ski_> dunno .. mayhaps lambdaProlog might give some ideas ?
09:29:05 <vixey> it is decideable?
09:29:10 <Lemmih> Sadache: Yes, it's a GHC extension.
09:29:12 <mpeter> > reverse filter isUpper "Girls Really Omit Sensible Sensuality"
09:29:13 <lambdabot>   Couldn't match expected type `[a]'
09:29:22 <mpeter> > reverse (filter isUpper "Girls Really Omit Sensible Sensuality")
09:29:23 <lambdabot>   "SSORG"
09:29:38 <ski_> mpeter : you might take this into private, yes ?
09:29:55 <mpeter> don't you want to watch?
09:30:15 <Sadache> ok then this leads to another question: how do you guys work? do you try to stick to standards or you follow latest GHC features?
09:30:32 <ski_> not particularly .. but i don't care that much
09:31:03 <Lemmih> Sadache: HAppS should work with both ghc-6.8 and ghc-6.10.
09:31:19 <roconnor> I stick to the standards unless using an extension is neessary to make the code elegant
09:31:36 <vixey> I use every extension I can :/
09:31:48 <ski_> (vixey : hm, it seems a direct prolog-like interpretation of the above query seems problematic ..)
09:32:02 * byorgey just writes code and turns on extensions when GHC suggests it =)
09:32:02 <Sadache> Lemmih:  ok but in general, I feel no one respects standars. In Java and C# it used to be much more straightforward
09:32:03 <roconnor> or if I'm doing a personal project, then I, of course, don't care what extenssions I use
09:32:28 * roconnor usually works on personal projects
09:32:54 <Sadache> but are latest GHC versions always stable?
09:33:02 <mmorrow> wrt what?
09:33:24 <Sadache> i mean wouldn't one GHC version delete prior features?
09:33:49 <mmorrow> no, there'd always be a deprecation phase
09:34:04 <Sadache> I feel like there is Haskell, and then there is GHC language that is a dialegt of haskell
09:34:09 <Deewiant> I try to be Hugs-compliant
09:34:15 <Sadache> in the same way that scheme is a dialect of lisp
09:34:17 <Lemmih> Sadache: Most of the extensions are fairly well established.
09:34:28 <Deewiant> Sadache: many of the extensions are implemented by practically all reasonable compilers
09:34:49 <ski_> Sadache : Lisp is not one language .. Haskell is
09:35:30 <b_jonas> hugs too has the saner extensions
09:35:51 <Sadache> ski_how do you see Haskell as a one language? GHC adds a lot more features
09:36:09 <ski_> Sadache : yes, but you can write useful programs in Haskell 98, yes ?
09:36:15 <pejo> Sadache, nothing is forcing you to use those features if you don't want them.
09:36:37 <Deewiant> pejo: it's easy to depend on a library which forces you to be GHC-only
09:37:03 <mauke> package base-3.0.3.0 requires base-4.0.0.0
09:37:04 <mauke> what
09:37:05 <Sadache> ski_ seems I can not do anything useful without using extensions
09:37:39 <int-e> mauke: base-3.0.3.0 is a (suposedly) base-3.0.1.0 compatible wrapper around base-4.0.0.0
09:37:42 <mmorrow> Sadache: personally i would be scared to use anything other than GHC for "production" code
09:37:49 <mauke> int-e: ah, I see
09:38:18 <int-e> mauke: supposedly, because it's incompatible due to the introduction of the Category class (and the corresponding Arrow split).
09:38:24 <Sadache> mmorrow: this is a useful note, thanks
09:38:34 <mauke> int-e: and exceptions, no?
09:39:08 <Saizan> mauke: no, Control.Exception from 3.0.3.0 is the same as 3.0.1.0
09:39:13 <int-e> mauke: no, there's a compatibility layer for the exceptions (basically Control.OldException of base-4.0.0.0)
09:39:40 <mauke> oh, that's what you mean
09:40:05 <int-e> mauke: in fact: module Control.Exception (module Control.OldException) where import Control.OldException
09:40:14 <mauke> now I just need to find out why binary-0.4.4 requires base-3.0.3.0 and how to fix it
09:40:56 <int-e> mauke: why do you have to?
09:41:13 <mauke> because everything else uses base-4.0.0.0
09:41:27 <Saizan> that shouldn't cause problems
09:41:28 <int-e> mauke: afaik Cabal and cabal (grudgingly) cope with that scenario now.
09:41:39 <mauke> Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
09:41:51 <int-e> mauke: yes, but it doesn't, in that particular case.
09:41:58 <mmorrow> i just ignore that since it happens all the time
09:42:02 <mauke> :/
09:42:08 <mmorrow> :/
09:42:11 <ozy`> :/
09:42:20 <Saizan> that Warning is valid for packages that aren't base
09:42:39 <Saizan> (or which don't depend on another version of themselves)
09:43:31 <mmorrow> it mostly happens with indirect paths to parsec2 and parsec3 in my experience
09:43:46 <int-e> mauke: it doesn't because base-3.0.3.0 is implemented in terms of base-4.0.0.0, so all the types are compatible. This is a highly unusual case. Normally, a new version of the libraries comes with copies of all the previous stuff.
09:43:58 <mauke> binary--  # doesn't let me browse the darcs repository
09:43:59 <int-e> mauke: and yes, it's ugly. I think nobody will disagree with that.
09:44:07 <mauke> ok, I understand
09:45:07 <mmorrow> (and QuickCheck is many times the straggler depending on base-3 in my experience as well)
09:45:56 <mauke> network--  # not exposing internals
09:45:58 <mmorrow> err, maybe s/base-3/parsec2/ there. i can't recall off the top of my head
09:46:09 <mauke> ffi++  # <3
09:46:13 <mmorrow> heh
09:46:15 <mmorrow> ffi++
09:46:34 <roconnor> ffi-- # hurmph
09:47:15 <mmorrow> mauke: i recently ffi imported recv/send into a current proj and couldn't be happier with the results
09:47:17 <Saizan> in bash, is there a way to broadcast a change to an env variable to all the open shells?
09:47:38 <mauke> mmorrow: hah, exactly
09:47:39 <Saizan> recv/send? why?
09:48:12 <mauke> oh FUCKING HELL
09:48:43 <mauke> ghc--  # can read into raw memory buffers and from file descriptors, but not both
09:49:10 <cjay> can someone tell me how to fix "unknow symbol" errors when using Plugins? The symbol is Utils_logInfo_closure, and there is a Utils module imported by Main and by the plugin with a function logInfo :: String -> IO ()
09:49:17 <mmorrow> so i could read/write to a Ptr Word8 with the full options that recv/send give in C
09:49:23 <mmorrow> (@Saizan)
09:49:39 <Saizan> cjay: did you use ghc --make?
09:49:40 <mmorrow> Network just has recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
09:49:45 <cjay> Saizan: yes
09:50:05 <mmorrow> sendBufTo :: Socket -> Ptr a -> Int -> SockAddr -> IO Int
09:51:49 <mauke> unix--  # mixes spaces and tabs
09:51:59 <cjay> Saizan: could it be because I call makeAll on the plugin file in Main?
09:52:46 <mauke> unix--  # O_NONBLOCK does not mean NonBlockingRead
09:53:44 <mmorrow> mauke: this pkg might be useful for copy/paste to save some busywork http://hackage.haskell.org/cgi-bin/hackage-scripts/package/c-io
09:54:06 <mauke> mmorrow: the names suck
09:54:11 <mmorrow> hehe
09:54:42 <mmorrow> change them
09:55:09 <cjay> hmm, compiling manually doesn't help
09:55:09 <mauke> also, the interface sucks: they shouldn't take file descriptors as Ints
09:55:23 <mauke> everything else uses CInt or Fd
09:55:41 <mmorrow> mauke: yeah, i was conflicted if i should use the Fd newtype from posix, define my own, or use Ints
09:56:05 <mauke> when in doubt, use CInt because that's what ends up in the FFI anyway :-)
09:56:09 <mmorrow> I chose ints so i didn't have to dep on posix + didn't make my own non-type-compatible newtype Fd
09:56:23 * ozy` tears his hair out
09:56:26 <mmorrow> mauke: yeah, that's a good idea actually
09:56:35 <ozy`> I upgraded to GHC 6.10 and it reformatted my cat >:|
09:56:40 <mmorrow> just import them and export the raw C interface
09:56:44 <b_jonas> O_NONBLOCK is used for like four different things
09:56:50 <b_jonas> which is a bit ugly
09:57:10 <mauke> mmorrow: I think I like the record encoding of bit flags more than the list variant
09:57:28 <mmorrow> mauke: ooh, i hadn't thought of doing that
09:57:53 <mauke> data OFlag = OFlag{ o_rdonly, o_wronly, ... :: Bool }
09:58:13 <cjay> are there any other possible reasons for unresolved symbols when using Plugins? I removed *.hi *.o and compiled everything with --make.
09:58:13 <mmorrow> I should redo that c-io pkg's interface, since i usually just copy/paste/modify that code when i want to use it rather than using that pkg as-is, so i guess that says something about the interface :)
09:59:14 <mmorrow> i've added mmap/munmap code to that pkg too since i've uploaded it..
09:59:52 <mmorrow> (bytestring-mmap doesn't expose or set MAP_EXEC)
10:01:23 <mmorrow> cjay: when are you getting the unrecolved syms? during dynamic loading, or compilation of your prog/pkg itself?
10:01:45 <cjay> mmorrow: dynamic loading
10:01:48 <mmorrow> (by dynamic loading i mean dynamically loading a .o)
10:01:51 <cjay> yeah
10:02:19 <mauke> bytestring++  # exposes internals
10:02:45 <mmorrow> cjay: hmm. are they c-syms or haskell-syms that you aren't finding?
10:02:55 <mmorrow> mauke: yeah. create(andTrim)++
10:03:06 <mauke> mmorrow: nope, fromForeignPtr++
10:03:11 <mmorrow> ooh, that too
10:03:17 <mmorrow> (in send :)
10:03:22 <mmorrow> on ho
10:03:27 <cjay> mmorrow: there is a function Utils.logInfo but it complains about not finding the symbol Utils_logInfo_closure
10:03:33 <mmorrow> toForeignPtr in send
10:04:09 <mmorrow> (i used mallocBytes and copyBytes the buffer into a ByteString with create each recv loop)
10:04:47 <eu-prleu-peupeu> http://kotaku.com/5107102/watch-a-portugese-dog-and-a-statue-of-napoleon-play-street-fighter
10:05:05 <vixey> eu-prleu-peupeu: is it anything to do with haskell
10:05:13 <cjay> Utils_logInfo_closure is probably something ghc creates internally, right? Maybe I should try a newer ghc, this is still 6.8.2
10:05:29 <mmorrow> cjay: hmm, i'm don't recall the plugins linker interface particulars off the top of my head. are you sure you called all/any of the functions for resolving deps?
10:06:03 * cjay looks at the documentation
10:07:27 <cjay> maybe I should have included "." in the search path
10:07:56 <mmorrow> ah, yeah iirc i hit that snag at first too
10:08:15 <mmorrow> "./Foo.o"
10:08:18 <vixey> @wiki Data.List.Split
10:08:18 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
10:08:40 <arussel> is yi usable know ? to write/run haskell code? as a normal text editor ?
10:08:46 <arussel> s/know/now
10:09:36 <mmorrow> arussel: i've started to use it and it's definitely useable. but it takes some effort for sure :)
10:10:11 <arussel> mmorrow: ok, thanks. I'll give it another go then.
10:10:15 <mauke> mmorrow: ah, the reason I want Fd instead of Int is threadWaitRead/threadWaitWrite
10:10:15 <mmorrow> (effort to learn how to customize your ~/.yi/yi.hs)
10:10:53 <newsham> Anonymous: I'd love to explain to you how to write hello world in Haskell, but first let me introduce you to basic category theory.
10:10:57 <newsham> haha!  awesome.
10:11:02 <mmorrow> mauke: ah, interesting. i saw someone's code that used that (don't recall where). where are you using that?
10:11:18 <mauke> mmorrow: I will probably use it in my main loop
10:11:19 <mmorrow> (i think i maybe should be too)
10:11:57 <Maciej> @pl \h f g x -> h (f x) (g x)
10:11:57 <lambdabot> liftM2
10:12:03 <ozy`> arussel: it's beta quality at best, and it's designed with the expectation that users already know haskell
10:12:18 <Maciej> How can I tell lambdabot to be more general on the type of h?
10:12:29 <newsham> more general than what?
10:12:29 <mauke> Maciej: huh?
10:12:34 <mmorrow> mauke: interesting. i'd love to see a snippet of your use of it when you're done if possible :)
10:13:02 <newsham> > liftM2 (+) (*2) (*3) 10
10:13:03 <lambdabot>   50
10:13:22 <Maciej> (->) is a monad?
10:13:40 <mmorrow> oh yeah, i just realized the problem with Int. Fd is newtype Fd = Fd CInt. oops
10:13:45 <roconnor> (->) e is a monad
10:13:50 <arussel> ozy`: but is it easy to run haskell from it ? or evaluate expression that I am writing
10:14:03 <mauke> mmorrow: existing uses of threadWaitRead: System.Miniplex, System.IO.Lock, System.Linux.INotify, System.Posix.Select
10:14:07 <cjay> mmorrow: thanks for the help, it seems to find the symbol, but it stil doesn't look into the installed ghc packages for other needed symbols. Plugins doesn't expect me to include installed packages in the search path, does it?
10:14:07 <Maciej> Ok, I see.
10:14:23 <roconnor> (->) is an arrow
10:14:32 <newsham> time flies like an arrow
10:14:37 <newsham> fruit flies like a banana
10:14:37 <ozy`> arussel: I never got that far with it when I was using it... and now that I'm trying to reinstall it I'm having all kinds of problems upgrading my toolchain
10:14:40 <ozy`> :\
10:15:12 <arussel> a deb package would be nice.
10:16:00 <mmorrow> cjay: i ran into that during some experimenting, and don't recall exactly how or if i got everything to work. i do have a (hacky) shell script to list .o deps for a haskell .o though (i'll paste it), so that makes me think i /did/ have to manually load those (but i'm not sure, because plugins's linker interface is supposed to chase deps for you..)
10:16:25 * ozy` sighs and considers just nuking his OS and reinstalling things in a saner way
10:16:41 <mauke> I think I'll go with write :: Fd -> ByteString -> IO Int
10:17:01 <Surma1> hey guys, why does ghc give me a parse error on `instance' with this line: ``data Expr= Var String | App Expr Expr | Lam String Expr | Nil instance Show Expr where Show=show_expr''
10:17:17 <mauke> Surma1: because it's a syntax error
10:17:20 <mmorrow> mauke: ah nice. i've never looked at the code to System.IO.Lock, so i must've seen it in (at least) one of the others
10:17:31 <Surma1> mauke: why? where?
10:17:48 <mmorrow> mauke: that's a nice sig
10:17:49 <arussel> I'll wait to finish my first haskell book before switching to yi :-)
10:17:59 <newsham> "\ninstance Show Expr where show = ..."
10:18:06 <mauke> Surma1: you turned two declarations in one
10:18:14 <vixey> Surma1, what's Expr for?
10:18:32 <newsham> "where Show=" is wrong because "Show" is not a function in the class Show
10:18:32 <mauke> vixey: isn't that obvious?
10:18:40 <vixey> mauke, no it is not obvious at all
10:18:43 <maltem> vixey: it, er, represents expressions?
10:18:44 <mauke> well, except for the Nil
10:18:55 <vixey> mauke, if you think it is obvious then you are assuming something that might well be false
10:18:57 <vixey> maltem, you too
10:19:05 <Surma1> Surma1: It's supposed to be an implementation of the Lambda-Calculus. It's just something i wanna try out
10:19:19 <mauke> vixey: er, that applies to every statement you make
10:19:21 <vixey> Surma1, implementation of reduction?
10:19:32 <mauke> you can't work without assumptions
10:19:35 <Surma1> mauke: oh, this actually was in it's own line, but seems like I indented it, which is wrong xD
10:19:53 <newsham> surma: you can use derive Show automatically
10:19:56 <Surma1> vixey: among other things, yes
10:20:15 <Surma1> newsham: I could, but I want to show these expressions in a way that is much shorter
10:20:37 <vixey> Surma1, for reduction you can drop the Var and use data Reducible = App Reducible Reducible | Lam (Reducible -> Reducible)
10:20:54 <Surma1> Instead of (Lam "x" (App (Var "x") (Var "y")) I'll get "(/x.xy)"
10:20:57 <vixey> Surma1, you can quote it back into Expr or DB also
10:21:19 <vixey> Surma1, but programming reduction on Expr is known to be horrendously painful
10:21:21 <newsham> whats the Show of Lam (Reducible -> Reducible) ?
10:21:35 <Surma1> vixey: it's not just reduction, it's supposed to become a whole parser and interpreter. I know, that haskell is already able to do that, but I just wanna do that from scratch for fun and profit ;)
10:21:48 <mmorrow> cjay: here's a (succesful) test of loading a .o from the current dir (which _doesn't_ have any external deps though)  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=566#a566
10:21:54 <mmorrow> still looking for that shell script..
10:22:01 <vixey> Surma1, if the parser outputs a Expr then the very first thing you want to do is convert it into Reducible or DB
10:22:26 <vixey> Surma1, DB ::= Var Integer | App DB DB | Lam (Scope DB) with newtype Scope a = Scope a
10:22:47 <mmorrow> cjay: also, in that function `myLoad', the stuff with the MVar isn't necessary as I found out, because Linker.{lhs,c} already do the equiv of that safety-measure
10:22:56 <mauke> vixey: why?
10:22:58 <vixey> Surma1, but any operation working on 'Expr' except parsing is going to buggy
10:23:39 <cjay> mmorrow: cool thanks
10:23:59 <vixey> mauke, it's not obvious
10:24:00 <vixey> ?
10:24:06 <mauke> vixey: no
10:24:14 <vixey> mauke, program correct beta reduction for all 3
10:24:33 <mauke> I mean, I've written a lambda calculus interpreter, and it's buggy, but I blame that on C++
10:24:59 <mmorrow> cjay: here's that (hacky and dubiously useful) shell script http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=566#a567
10:26:50 <mauke> vixey: eval :: Env -> Expr -> Value; eval env (Var v) = lookup env v; eval env (App f x) = apply (eval env f) (eval env x); eval env (Lam v b) = Fun (\x -> eval (extend (v, x) env) b)
10:27:00 <mmorrow> oh, that sh script uses a ./zdec prog that just un-zcodes its stdin
10:27:29 <ozy`> BAHAHAHAHAHAHA
10:27:36 * ozy` just nuked /opt and /usr/local
10:28:21 <mmorrow> preflex: zdec base_GHCziShow_zdwshowSignedInt_info
10:28:21 <preflex>  base_GHC.Show_$wshowSignedInt_info
10:29:08 * cjay never heared of zcode
10:29:35 <mauke> preflex: zenc http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=566#a567
10:29:35 <preflex>  httpZCzszsmoonpatiozicomZC8080zsfastcgizshpastezifcgizsviewz3fUidze566zha567
10:30:16 <mmorrow> ozy`: do
10:30:24 <mmorrow> $ objdump --syms MyHsFile.o
10:30:41 <int-e> preflex: zenc mtl-1.0.0.0:Control.Monad.Trans
10:30:42 <preflex>  mtlzm1zi0zi0zi0ZCControlziMonadziTrans
10:30:51 <ozy`> mmorrow: sorry?
10:31:02 <mmorrow> ozy`: to see zencoded strings
10:31:14 <int-e> cjay: ghc uses it to turn names like that into C symbols.
10:31:39 <mmorrow> ozy`: oh oops. that was supposed to be at cjay :
10:31:39 <cjay> I see
10:32:26 <mmorrow> ozy`: well, it was supposed to be at you, but you never said what i thought you did ;)
10:32:34 <cjay> I'll try to find a not-so hacky solution, maybe it's better with the latest ghc/plugins
10:33:10 <mmorrow> cjay: i'd ask dons about resolving deps. i never used that shell script for anything other that inspecting stuff by hand
10:33:31 <cjay> ok
10:35:29 <mmorrow> cjay: oh, wait is the sym you're missing in another .o in the pwd and not in an installed pkg? plugins doesn't chase /those/ deps for you.
10:36:06 <mmorrow> and the order in which you load .o's matters too
10:36:21 <cjay> mmorrow: I already solved that problem by including "." in the search path
10:36:31 <mmorrow> cjay: oh, so no more problems?
10:36:57 <cjay> mmorrow: there is still the problem with symbols from installed packages
10:37:09 <mmorrow> ah. yeah i'd ask dons :)
10:38:51 <cjay> will do, after shopping and trying with latest version :)
10:39:04 <mmorrow> cjay: cool, lemme know how it goes
10:39:13 <cjay> ok
10:41:16 <vixey> mauke, this "eval" :: Env -> Expr -> Value is exactly what I suggested
10:41:49 <vixey> mauke, reduction should really be Env -> Expr -> Expr,  I'm saying that you shsould convert representation to 'Value' or DB or whatever then do eval
10:41:55 <vixey> mauke, so you fused both together which works too
10:42:14 <vixey> but if you want to do diferent ops then you have to fuse in the conversion to everything
10:43:08 <mauke> no, Expr works just fine for pretty-printing
10:47:39 <Megzlna> How do you make a lambda which has no parameters?
10:47:45 <mauke> Megzlna: no
10:47:59 <mrd> all functions have one and only one parameter
10:48:10 <Megzlna> well, perhaps the innards of it were all provided by where bindings
10:48:14 <roconnor> what mrd said
10:48:16 <Megzlna> or some other closure
10:48:21 <mauke> Megzlna: irrelevant
10:48:26 <mrd> maybe it's not a function?
10:48:47 <Megzlna> ok, I'll rephrase
10:48:58 <ozy`> Megzlna: what's the point of making a lambda with no parameters? even if you could, it would be no lazier than the return value itself...
10:48:59 <Megzlna> how do you make an anonymous constant
10:49:10 <mrd> > 1
10:49:11 <lambdabot>   1
10:49:13 <roconnor> > 5
10:49:14 <mauke> > 2 + 2
10:49:15 <lambdabot>   5
10:49:15 <lambdabot>   4
10:49:41 <roconnor> > fix bitSize
10:49:42 <lambdabot>   64
10:49:45 <mrd> what's an anonymous constant besides a direct literal?
10:50:15 <Megzlna> coz I wanted something lazy inside of it.
10:50:24 <mauke> Megzlna: everything is lazy
10:51:00 <Megzlna> however, what if my lambda with no parameters used IO to produce values
10:51:09 <Megzlna> makerandom
10:51:11 <mauke> "lambda with no parameters" is an oxymoron
10:51:11 <ozy`> Megzlna: you don't seem to grasp the concept of laziness in haskell.
10:51:20 <mmorrow> , src ''IO
10:51:30 <mauke> Megzlna: then it's a constant
10:51:30 <mrd> Megzlna: makerandom = random (1, 10)
10:51:31 <roconnor> Megzlna: that is just a constant of type IO a
10:51:34 <mauke> :t randomIO
10:51:36 <lambdabot> forall a. (Random a) => IO a
10:51:36 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
10:51:36 <lunabot>                     (#,#) (State# RealWorld) a)
10:51:38 <mauke> which already exists
10:52:17 <roconnor> Megzlna: you understand how IO works in Haskell?
10:52:28 <roconnor> and how it it is completely different from ML?
10:52:30 <mauke> :t getChar
10:52:31 <lambdabot> IO Char
10:52:36 <mauke> look, a constant
10:52:59 <Megzlna> ozy`, I know how laziness works, but not in this context.. it stopped making sense with the IO RNG
10:53:03 <mmorrow> @type getLine
10:53:05 <lambdabot> IO String
10:53:11 <vixey> IO isn't lazy
10:53:15 <mauke> Megzlna: this is not about laziness
10:53:15 <mrd> Megzlna: throw out your reasoning about constants when dealing with the IO monad
10:53:18 <roconnor> IO is lazy
10:53:22 <mauke> mrd: no, don't!
10:53:24 <vixey> oh ??
10:53:29 <vixey> how
10:53:37 <mrd> Megzlna: every time you look at an "IO" constant, it can be different
10:53:44 <mauke> mrd: no, it can't
10:53:45 <roconnor> vixey: return undefined >> putStrLn "Lazy"
10:53:50 <vixey> mrd, that's sort of bizzare way to put it
10:53:53 <tomh-> anyone knows a nice matrix library for haskell with support for huge sparse matrices?
10:53:54 <mrd> mauke: don't be an ass
10:53:58 <byorgey> every time you *evaluate* an IO constant, it can *produce a different result*
10:53:58 <mauke> mrd: no u
10:54:03 <mauke> byorgey: no, it can't
10:54:03 <byorgey> but the constant itself is always the same.
10:54:09 <vixey> mrd, you're the one saying things that aren't true and don't make any sense...........
10:54:11 <mauke> evaluating a constant yields that constant
10:54:22 <roconnor> byorgey: every time you *execute* and IO constant ..
10:54:22 <byorgey> sorry, wrong word
10:54:24 <Lemmih> byorgey: s/evaluate/execute/
10:54:24 <mmorrow> every time you /run/ an IO action it can produce a different result
10:54:30 <mrd> he is "looking" at this with <- remember
10:54:47 <Megzlna> mauke: exactly thats why I wanted to call it a lambda
10:54:47 <Megzlna> and not a constant
10:54:47 <byorgey> right, that's what I meant =)
10:54:49 <ski_> > let x = 1 : x in x  -- anonymous constant
10:54:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:54:54 <mauke> Megzlna: but it is a constant
10:55:03 <Lemmih> Megzlna: You /do/ want a constant.
10:55:15 <vixey> roconnor, but print undefined >> putStrLn "Lazy"
10:55:15 <mauke> mrd: maybe he should stop doing that
10:55:16 <Megzlna> heheh a random constant
10:55:31 <mauke> Megzlna: look at C. "rand" is also a constant there
10:55:33 <mauke> so is printf
10:55:41 <Megzlna> so you guys disagreeing about IO being lazy / unlazy... please agree so I'm not confused?
10:55:51 <mauke> Megzlna: it's irrelevant for this :-)
10:55:52 <Lemmih> Megzlna: Yes, a constant that describes an action for generating random values.
10:55:52 <vixey> Megzlna, I'm not sure yet
10:56:05 <roconnor> vixey: sure, but only those parts of the expressions that are necessary for IO effects are evaluated.  Other thunks remain suspended.
10:56:13 <roconnor> vixey: that is the very definition of lazy
10:56:20 <vixey> roconnor, well I think that any _IO_ effects  A >> B  A will happen first
10:56:40 <vixey> roconnor, but effects like evaluation, they still occur in the lazy way
10:56:58 * ddarius wishes people would stop trying to say some particular monad is or is not lazy/strict.
10:57:01 <vixey> roconnor, yeah.. I don't know what to call this
10:57:38 <roconnor> vixey: The important point is to have people realize that IO doesn't make evaluation strict.
10:58:10 <roconnor> or rather doesn't make all evaluation strict
10:58:27 <mmorrow> Megzlna: they're saying that evualtion to a value of type (IO a) is lazy, just like 1+1 is lazy. but running/executing an action of type (IO a) can be lazy or not depending on how it's coded.
10:58:28 <ddarius> roconnor: It doesn't make any evaluation strict.  It doesn't affect evaluation at all.
10:58:39 <roconnor> ddarius: you are right
10:58:46 * roconnor returns to his first claim
10:58:59 <Megzlna> mmorrow: k
10:59:06 <mrd> > randomIO
10:59:08 <lambdabot>   Add a type signature
10:59:11 <mrd> > randomIO :: Int
10:59:13 <lambdabot>   Couldn't match expected type `Int' against inferred type `IO a'
10:59:16 <mrd> > randomIO :: IO Int
10:59:17 <lambdabot>   * Exception: "<IO Int>"
10:59:22 <roconnor> @wiki IO_Semantics
10:59:22 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
10:59:59 <roconnor> ``If a PutChar node is encountered, the character data contained at that node is output to the terminal and then its subtree is executed. It is only at this point that Haskell code is ever necessarily evaluated in order to determine what character should be displayed before continuing
11:00:08 <wli> What module exports the join that passes an arg twice to a function?
11:00:26 <vixey> if you have a >> b though, a is always taken to WHNF before b is
11:00:27 <mmorrow> Control.Monad
11:01:18 <roconnor> vixey: that depends on the implemenation of (>>)
11:01:28 <vixey> I'm talking about IO
11:02:20 <roconnor> vixey: if you define IO a to be (a -> IOTree) -> IOTree
11:02:27 <roconnor> then a is always in WHNF
11:02:37 <roconnor> because it is a lambda abstraction
11:02:44 <hoknamahn> guys, is it good book? is there anything better? http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&s=books&qid=1229194908&sr=8-1
11:02:52 <roconnor> oh
11:03:15 <roconnor> vixey: I suppose getting to WHNF could take some evaluation
11:03:38 <mauke> hoknamahn: it is good
11:04:49 <roconnor> but getting it in to WHNF probably doesn't entail very much becuase it is a lambda abstraction.
11:05:02 <vixey> a has type IO x
11:05:29 <hoknamahn> mauke, cool thanks
11:05:30 <mauke> roconnor: how does that follow?
11:06:02 <vixey> even if IO a = (a -> IOTree) -> IOTree, you still have to take the action into WHNF before executing the next one right?
11:06:05 <mauke> you only have a different exit condition; that doesn't tell you anything about how much work you have to do to get there
11:06:09 <roconnor> mauke: I maybe I'm wrong
11:06:42 <Megzlna> Why is it... that you can do:
11:06:47 <Megzlna> > (let x = 1; y = 2; in (x,y))
11:06:48 <lambdabot>   (1,2)
11:06:51 <Megzlna> but you cannot do:
11:06:54 <Megzlna> > ((x,y) where x = 1; y = 2)
11:06:55 <lambdabot>   <no location info>: parse error on input `where'
11:07:04 <mauke> Megzlna: because 'where' can't be attached to expressions
11:07:07 <vixey> Megzlna, you can do that
11:07:19 <Megzlna> how vixey?
11:07:19 <mauke> Megzlna: only to some declarations
11:07:20 <roconnor> vixey: duing execution, the run-time system in evaluting an IOTree, not an IO a
11:07:24 <roconnor> or an IO x
11:07:49 <Megzlna> I guess I'm wondering why where isn't more general and allowed on expressions?
11:07:59 <roconnor> > let p = (x,y) where x = 1; y = 2 in p
11:08:01 <lambdabot>   (1,2)
11:08:30 <mmorrow> Megzlna: and expression + where is no longer classified as an expression
11:08:33 <Megzlna> I guess it cant be general if it is allowed whole scope over functions across multiple guards
11:08:40 <mauke> > let f [] = y; f _ = y where y = 42 in f "hi"
11:08:41 <lambdabot>   42
11:08:47 <mauke> exactly
11:08:49 <vixey> roconnor, but still to execute  a >> b  , it must take a into WHNF if a means to exit the program then it will do that before taking b into WHNF shouldn't it?
11:08:58 <vixey> roconnor, I mean regardless of implementation
11:09:01 <Megzlna> mauke: xactly to which part?
11:09:22 <mauke> Megzlna: the special scoping rules
11:09:36 <mauke> > let f [] = y; f _ = y where y = 42 in f ""
11:09:37 <lambdabot>   y
11:09:40 <mauke> oh, oops
11:09:47 <mauke> (broken tests)--
11:11:42 <roconnor> vixey: to find out try evaluating runIO (a >> b) (\_ -> Done) and see what happens
11:12:05 <roconnor> runIO (a >> b) (\_ -> Done)
11:12:26 <Megzlna> roconner: that's what I was trying to do
11:12:26 <vixey> I on't know what runIO is
11:12:40 <newsham> ?seen conal
11:12:41 <lambdabot> I saw conal leaving #ghc and #haskell 8h 53m 55s ago, and .
11:12:41 <vixey> when I implement IO I don't use this IOTree way
11:12:46 <vixey> but a GADT with commands in it
11:13:08 <roconnor> (\k -> runIO a (\z -> runIO b k)) (\_ -> Done)
11:13:27 <vixey> ~~> runIO a (\z -> runIO b (\_ -> Done))
11:13:28 <roconnor> vixey: I'm refering to http://www.haskell.org/haskellwiki/IO_Semantics
11:13:36 <vixey> roconnor, runIO is not in there
11:13:46 <roconnor> newtype IO a = IO {runIO :: (a -> IOTree) -> IOTree}
11:13:55 <vixey> ohhh...............
11:14:06 <roconnor> yep
11:14:13 <vixey> I looked over and didn't see that ... I'm allergic to record syntax
11:14:15 <roconnor> looks like a end up in WHNF before b
11:14:34 <vixey> I don't see how that takes it to WHNF though
11:14:47 <roconnor> well first a is evaulated to HNF
11:14:51 <roconnor> exposing the IO constructor
11:14:57 <roconnor> or actually
11:15:00 <roconnor> sorry
11:15:03 <roconnor> it is a newtype
11:15:05 <mmorrow> i wonder if it'd be faster if GHC implemented IO using cps instead of (#,#)
11:15:09 <roconnor> so runIO and IO are nothing
11:15:15 <roconnor> so if we ignore them we have
11:15:25 <roconnor> a (\z -> b (\_ -> Done))
11:15:36 <mmorrow> (because of this http://moonpatio.com/repos/state-bench/)
11:15:40 <roconnor> so to reduce this we need to put a in WHNF
11:15:42 <roconnor> right?
11:15:46 <vixey> wait a second
11:15:47 <vixey> newtype IO a = IO {runIO :: (a -> IOTree) -> IOTree}
11:15:49 <vixey> is that even valid?
11:15:54 <vixey> actually
11:15:54 <ddarius>  Yes.
11:15:54 <tomh-> meh everytime i run runhaskell w/o parameters it crashes :/
11:16:05 <vixey> I guess that it means IO :: (a -> IOTree) -> IOTree -> IO a?
11:16:07 <mmorrow> type IO a = C IOTree a
11:16:10 <mmorrow> type IO a = Cont IOTree a
11:16:15 <vixey> ok I get it now
11:16:22 <roconnor> good
11:16:23 <ddarius> IO :: ((a -> IOTree) -> IOTree) -> a
11:16:24 <mauke> tomh-: works here
11:16:34 <ddarius> er IO a
11:16:37 <mmorrow> heh
11:16:44 <roconnor> IO :: ((a -> IOTree) -> IOTree) -> IO a
11:16:51 <vixey> I still don't really see what is the reason for this definition instead of
11:17:03 <mux> does GHC support compiling to armv5?
11:17:04 <vixey> data IO a where PutChar :: Char -> IO (); ...
11:17:10 <Megzlna> hheh... what the hell happened here?
11:17:12 <Megzlna> > let f [] = y; f _ = y where y = 42 in f ""
11:17:13 <lambdabot>   y
11:17:16 <Megzlna> y ???
11:17:18 <vixey> > y^6
11:17:20 <lambdabot>   y * y * (y * y) * (y * y)
11:17:33 <vixey> > foldr (+) z [1..10]
11:17:34 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + z)))))))))
11:17:40 <mauke> Megzlna: lambdabot runs code in an environment with definitions for all single-letter identifiers
11:17:40 <mmorrow> vixey: it doesn't assume a priori any particular IO functions
11:17:57 <vixey> mmorrow, yeah it does (?) IOTree
11:18:01 <roconnor> vixey: what you wrote doesn't seem quite right
11:18:02 <Megzlna> mauke: k
11:18:12 <mmorrow> vixey :: putChar :: Char -> IO ()
11:18:26 <mmorrow> heh, didn't mean to type that first "::"
11:18:34 <vixey> roconnor, why not?
11:18:42 <vixey> roconnor, why not?
11:18:44 <vixey> oops
11:19:08 <rieux> potentially easy GHCi question: is there a command line switch that will add a package module to the current target set (a la ":m +")?
11:19:28 <vixey> roconnor, I guess that with the commands version, you're really ensuring something strict is executing IO actions -- but with the Cont IOTree way then it's more functional.. I don't know
11:19:48 <roconnor> vixey: give me a sec to find that alarm ringing in my head
11:20:23 <mauke> "shh, my common sense is tingling!"
11:20:42 <roconnor> vixey: I assume bind is one of your constructors?
11:21:17 <vixey> yes and instance monad where  return = Return; (>>=) = (:>>=:)
11:21:40 <mmorrow> mux: i'm not sure, but i don't think so currently. from what i understand though that might be supported and/or doable with ghc-6.12
11:21:49 <hasky> records = [ x | x <- records, y <- field x]  -- shouldn't this return all the values of 'field' from all the supplied records?
11:22:05 <roconnor> vixey: one thing I don't like about that is you have to put an equivalence relation on your data.  But that isn't the alarm in my head
11:22:06 <hasky> Er, sorry, disregard "records = "
11:22:09 <mux> mmorrow: I'm highly tempted to try and have haskell plugins for s60 phones
11:22:36 <mmorrow> mux: that'd be sweet if you got it working :)
11:22:54 <roconnor> vixey: what is getChar ?
11:23:11 <roconnor> simply GetChar :: IO Char  ?
11:23:22 <mmorrow> what is this type "Char"? ;)
11:23:58 <vixey> data Char = 'a' | 'b' | ..
11:24:12 <mmorrow> ahh. :)
11:24:19 * wli is still trying to smoke out the best way to represent band diagonal matrices.
11:24:35 <mmorrow> wli: ooh, nice
11:24:41 <Saizan> rieux: target set?
11:24:45 <vixey> roconnor, yes
11:24:52 <opqdonut> wli: [(Int,[a])] not good enough?
11:24:55 <roconnor> vixey: okay, false alarm
11:25:02 <opqdonut> what sorts of access patterns are you after?
11:25:11 <mmorrow> wli: err, i didn't see "still"
11:25:12 <vixey> roconnor, the equiv. relation needed to make  (m >=> n) >=> o = m >=> (n >=> o)  is a concern though
11:25:14 <Megzlna> > let { f 1 = y; f 2 = y } where y = 3 in f 1           -- another where question. why doesnt this work?
11:25:16 <lambdabot>   <no location info>: parse error on input `where'
11:25:24 <vixey> roconnor, Cont IOTree resolves that?
11:25:27 <roconnor> vixey: my only objection is the use of an equivalence relation. It isn't a serious objection
11:25:29 <mauke> Megzlna: because you can't put 'where' there
11:25:34 <Megzlna> why not?
11:25:36 <wli> opqdonut: Linear combinations of matrices, matrix/matrix and matrix/vector multiplies.
11:25:48 <vixey> roconnor, no I think it's an important thing especially when looking for simplest semantics
11:25:49 <roconnor> vixey: I belive Cont IOTree uses the natural equivalence of functions.
11:25:51 <mmorrow> Megzlna: because of how the syntax is defined
11:26:11 <roconnor> vixey: the only problem with Cont IOTree is that it the type contains invalid programs
11:26:13 <Megzlna> well it works without the {  }
11:26:17 <ddarius> vixey: Cont r is a monad for any r.
11:26:20 <vixey> yeah well associativity of Cont is equivalent to eta
11:26:24 <roconnor> which I mention at the bottom of my IO_Semantics article
11:26:24 <mmorrow> , src 'LetS
11:26:38 <lunabot>  data Stmt = ... | LetS ([Dec]) | ...
11:26:38 <lunabot>  infixl 9
11:26:38 <vixey> s/equivalent/provable in terms of/
11:26:38 <Megzlna> It's just that, it looks really odd without the {  } because the where seems to bind to the second f 2
11:26:59 <mmorrow> , src 'ValD
11:27:01 <wli> opqdonut: Block  matrices are at least obvious how to represent blocks in, though data structures enabling efficient intersection searches are hairy (no idea what to use yet).
11:27:04 <vixey> ddarius, yeah I prove the monad laws for Cont and have to use eta
11:27:05 <lunabot>  data Dec = ... | ValD Pat Body ([Dec]) | ...
11:27:05 <lunabot>  infixl 9
11:27:20 <mmorrow> where [Dec] there is the "where"
11:27:25 <mmorrow> , src 'Body
11:27:27 <lunabot>  luna: Not in scope: data constructor `Body'
11:27:30 <mmorrow> ,src ''Body
11:27:34 <lunabot>  data Body = GuardedB ([(Guard, Exp)]) | NormalB Exp
11:27:42 <rieux> salzan: modules in scope
11:27:51 <rieux> salsan: like you add with ":m +"
11:28:01 <rieux> salzan: like you add with ":m +"
11:28:01 <mmorrow> , [|let foo = x where x = () in foo|]
11:28:04 <lunabot>  LetE [ValD (VarP foo_0) (NormalB (VarE x_1)) [ValD (VarP x_1) (NormalB (C...
11:28:37 <rieux> i didn't know it was called "target set" until i read the docs
11:28:47 <mmorrow> , src 'LetE
11:28:53 <lunabot>  data Exp = ... | LetE ([Dec]) Exp | ...
11:28:53 <lunabot>  infixl 9
11:29:02 <Megzlna> mmorrow: Nice strategy for investigation there!
11:29:06 <wli> opqdonut: The questions surrounding band diagonal matrices essentially has to do with those being parts of a larger matrix in some larger search structure then enabling efficient search for the subcomponents of matrices and vectors that intersect in ways needed for the computation of some result.
11:29:26 <opqdonut> wli: i see
11:29:39 <mmorrow> Megzlna: i find it very handy. in ghci i/one would do the same thing with ":i Foo"
11:29:49 <mmorrow> :i Language.Haskell.TH.Exp
11:29:51 <mmorrow> :i Language.Haskell.TH.Dec
11:29:53 <mmorrow> :i Language.Haskell.TH.Stmt
11:29:56 <mmorrow> oops
11:30:01 <mmorrow> :i Language.Haskell.TH.Syntax.Exp
11:30:03 <mmorrow> ..
11:30:31 <mmorrow> (you only have to fully qualify the names if you haven't :m + that module yet)
11:31:04 <Megzlna> I would expect where to work there, considering this works:
11:31:05 <Megzlna> > let { f = 2 } in f
11:31:06 <lambdabot>   2
11:31:22 <mmorrow> you can look at the AST for src syntax in GHC in the HsSyn, HsExpr, HsDecl, .... modules
11:31:50 <mmorrow> it doesn't work because the {f = 2} there is a [Dec]
11:32:13 <mmorrow> and where only works in a ValD which is of type Dec
11:32:23 <wli> opqdonut: 2D search trees only really work well for block matrices. A diagonal ends up spanning broad ranges along the index coordinate axes.
11:32:48 <Megzlna> mmorrow: you ever make any ghc patches?
11:32:54 <Megzlna> er, extensions
11:33:04 <Megzlna> TH seems a good way to get ready
11:33:41 <mmorrow> Megzlna: no patches/extensions to ghc itself, but i've been hacking around with ghc and dynamic eval/etc recently
11:34:02 <mmorrow> Megzlna: totally, TH wasa my first step
11:34:19 <wli> The 2D search trees are designed precisely for membership tests for coordinate axis -aligned blocks (I suspect not even handling intersection more generally).
11:35:57 <mmorrow> Megzlna: yeah, in order to use TH effectively you have to learn the abstract syntax of haskell and other such stuff, which is a prerequisite to hack on the language for sure
11:36:16 <Megzlna> > let p = (x,y) where { x = 1 ; y = 2 } in p
11:36:17 <lambdabot>   (1,2)
11:36:22 <mpeter> the abstract syntax?
11:36:23 <mmorrow> heh, nice
11:36:38 <mpeter> > let p = (1,2)
11:36:39 <lambdabot>   <no location info>: parse error on input `;'
11:36:45 <mpeter> ;)
11:36:51 <mpeter> i know you guys don't like the "update operator" eh
11:37:04 <mmorrow> mpeter: "how its source-level syntax is represented in the abstract" or however one would say that
11:37:08 <roconnor> update operator?
11:37:22 <mpeter> ro: as in the imperative 'update operator'
11:37:26 <mpeter> c=6;
11:37:27 <mpeter> c=7;
11:37:34 <mpeter> > c returns c=7
11:37:35 <lambdabot>   <no location info>: parse error on input `='
11:37:38 <mmorrow> writeIORef ref 42
11:37:50 <mmorrow> putMVar mvar 12
11:37:51 <roconnor> mpeter: you mean the assingment operators?
11:38:00 <roconnor> assignment
11:38:00 <mpeter> same difference
11:38:29 <mmorrow> let (.=) = writeIORef in x .= 42
11:38:32 <roconnor> it's true.  We have to write it out in big words like mmorrow does
11:39:03 <Megzlna> > let (x,y) = (x,y) where { x = 1; y = 2; }
11:39:03 <mmorrow> or use haskell's nice ability to define "operator" to make it pretty if one cares enough
11:39:04 <roconnor> mmorrow: to bad you can't call it :=
11:39:04 <lambdabot>   <no location info>: parse error on input `;'
11:39:10 <Megzlna> > let (x,y) = (x,y) where { x = 1; y = 2; } in x
11:39:11 <lambdabot>   1
11:39:20 <Megzlna> ow...
11:39:23 <mmorrow> yeah, i almost did that for a second there ;)
11:39:35 <roconnor> Megzlna: heh, I didn't know that
11:39:42 <roconnor> I guess that makes sense
11:40:25 <mmorrow> Megzlna: totally, the AST datatypes tell you everything you need to know
11:40:44 <Megzlna> i was just looking at the types on my ghci
11:41:12 <mmorrow> Megzlna: ":i" is friggin awesome and i'd be 10x less productive without it
11:43:21 <mpeter> uh-oh
11:46:54 <redditbot> Haskell Weekly News: December 13, 2008 | The Haskell Sequence
11:48:26 <roconnor> redditbot++
11:49:23 <august> what? no link?
11:51:46 <mpeter> > [0,-1..]
11:51:47 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
11:51:57 <mpeter> hmm
11:52:14 <mpeter> > foldr (+) 1 [0,-1..]
11:52:16 <lambdabot>   * Exception: stack overflow
11:52:21 <mpeter> > foldr (+) 0 [0,-1..]
11:52:23 <lambdabot>   * Exception: stack overflow
11:52:26 <mpeter> i'll overflow your stack
11:53:33 <jeffwheeler> Hoogle's deep-linking to specific variables and functions in Haddock pages doesn't seem to work in Safari.
11:53:41 <jeffwheeler> The ":" character in the name's are not encoded, like they should be.
11:53:49 <jeffwheeler> E.g., Prelude.html#v%3Abreak is correct, while Hoogle links to Prelude.html#v:break, which doesn't work.
11:54:55 <hydo> How do I pass flags to ghc through Setup ?  I tried --flags="xxx" but that seems to be cabal flags instead of for ghc...
11:56:35 <mmorrow> Megzlna: there's also the haddocks (i'm sure you know this, but just in case ;)  http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-Syntax.html
11:56:47 <mmorrow> main index: http://haskell.org/ghc/docs/latest/html/libraries/
11:57:17 <hasky> show $ exam student  -- shows "cons value"; how can I just get "value"?
11:57:54 <mmorrow> let Con value = exam student in show value
11:58:21 <jeffwheeler> Why isn't elem simply defined as an infix operator?
11:58:27 <mmorrow> or use a case expression... anything to pattern match on the result an extract the value
11:58:29 <jeffwheeler> The documentation even says that's how it's usually used.
11:58:45 <mauke> jeffwheeler: what would it be called?
11:58:50 <mmorrow> jeffwheeler: i've used the unicode standard math sym a few times
11:58:57 <jeffwheeler> mauke: elem ;)
11:59:04 <mauke> jeffwheeler: that's not an infix operator
11:59:12 * mmorrow looks it up in charmap
11:59:25 <jeffwheeler> mauke: oh, can normal names not be used? I didn't know that.
11:59:47 <mmorrow> , let (∈) = elem in 7 ∈ [0..9]
11:59:49 <lunabot>  True
12:00:19 <jeffwheeler> mmorrow: No need to use full-out Unicode for that; it's simply ASCII value x3A (http://asciitable.com/)
12:00:20 <mmorrow> let (∉) = not . elem in 7 ∉ [0..9]
12:00:31 <wli> jefffwheeler: Not enough symbol characters in non-unicode.
12:00:40 <roconnor> @type notElem
12:00:40 <mmorrow> , text . utf8enc $ "\x3a"
12:00:41 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:00:42 <lunabot>  :
12:00:43 <mauke> mmorrow: 0x3A is :
12:00:48 <mmorrow> heh
12:00:50 <mauke> er, sorry
12:00:55 <mmorrow> so it seems
12:01:12 <mmorrow> , "∈"
12:01:14 <lunabot>  "\8712"
12:01:22 <mmorrow> , showHex 8712 []
12:01:24 <lunabot>  "2208"
12:01:28 <mauke> U+2208 (e2 88 88): ELEMENT OF [∈]
12:01:49 <gwern> @quote lazier
12:01:50 <lambdabot> No quotes match.
12:02:02 <mmorrow> , text . utf8enc $ "\x2200"
12:02:05 <lunabot>  ∀
12:02:05 <gwern> @remember gwern the best way to optimize a program is to make it lazier or stricter.
12:02:06 <lambdabot> Nice!
12:02:09 <gwern> @quote lazier
12:02:09 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
12:02:13 <hydo> --ghc-options... which strangely wasn't in the ./Setup configure help message.
12:02:16 <opqdonut> @quote laz
12:02:17 <lambdabot> JonHarrop says: Is someone at Google using a lazy language?
12:02:29 <gwern> @quote blackh
12:02:30 <lambdabot> dons says: hugs should spot the blackhole, or fail gracefully
12:02:33 <gwern> @quote blackh
12:02:33 <lambdabot> dons says: hugs should spot the blackhole, or fail gracefully
12:02:41 <gwern> @remember blackh Haskell is great because of all the wonderful things you can't do with it.
12:02:42 <lambdabot> I will never forget.
12:02:44 <gwern> @quote blackh
12:02:45 <lambdabot> blackh says: Haskell is great because of all the wonderful things you can't do with it.
12:02:52 <gwern> @quote gitit
12:02:53 <lambdabot> No quotes match. Wrong!  You cheating scum!
12:03:07 <gwern> @remember JustinBogner gitit's 46 dependencies convinced me to install cabal-install, and now I couldn't be happier!
12:03:07 <lambdabot> Done.
12:03:10 <gwern> @quote gitit
12:03:10 <lambdabot> JustinBogner says: gitit's 46 dependencies convinced me to install cabal-install, and now I couldn't be happier!
12:03:27 <Megzlna> @quote ocaml
12:03:28 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
12:03:28 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
12:03:40 <Deewiant> ?users
12:03:40 <lambdabot> Maximum users seen in #haskell: 582, currently: 575 (98.8%), active: 20 (3.5%)
12:03:42 <gwern> @quote love
12:03:42 <lambdabot> Anonymous says: I'd love to explain to you how to write hello world in Haskell, but first let me introduce you to basic category theory.
12:03:55 <mmorrow> heh
12:04:13 <gwern> @quote (:[])
12:04:14 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
12:04:19 <gwern> @quote ook
12:04:20 <lambdabot> ook says: (:[])
12:04:28 <gwern> @quote oink
12:04:29 <lambdabot> oink says: <^(oo)^>
12:04:41 <gwern> @quote breathingMachine
12:04:42 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
12:05:10 <Megzlna> @quote subterfuge
12:05:10 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
12:05:21 <gwern> @remember gwern The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
12:05:21 <lambdabot> Okay.
12:05:30 <gwern> @flush
12:05:43 <roconnor> gwern: that makes more sense
12:06:53 <gwern> alas, the HWN version was out of context, so I took the liberty of modifying it slightly
12:09:05 <sjanssen> @keal
12:09:05 <lambdabot> i prove infinity never ends in both directions
12:09:30 <roconnor> @keal
12:09:30 <lambdabot> will it return [] if map gives fpu infinite list?
12:09:45 <mauke> preflex: be PoppaVic
12:09:46 <preflex>  I said what I meant: you expect others to save you and ridicule me, (which is fine), but now pick yer GOD.
12:14:07 <dons> gwern: done any mediawiki upgrades?
12:14:16 <gwern> myself? no
12:14:34 <dons> k. thanks
12:16:05 <gwern> although it's worth mentioning that a full upgrade of mediawiki and GeSHi would also get us better syntax highlighting, as I understand the current stable GeSHi correctly highlights operators like '-->'
12:29:42 <Baughn> @hoogle keysymToKeycode
12:29:42 <lambdabot> No results found
12:36:39 <teko> whadup peepsters!!
12:37:06 * roconnor peeps
12:37:19 <chessguy> @hoogle Either a b -> b
12:37:19 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
12:37:19 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
12:37:19 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
12:37:21 * august eats peeps
12:37:21 <chessguy> @bot
12:37:21 <lambdabot> :)
12:37:21 <lunabot>  :)
12:37:37 <chessguy> @more
12:37:43 <chessguy> @hoogle+
12:37:43 <lambdabot> Distribution.ReadE ReadE :: String -> Either ErrorMsg a -> ReadE a
12:37:43 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
12:37:43 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
12:37:48 <chessguy> hmph
12:39:26 <Megzlna> It's sad. My editor supports code folding for most all languages, except not Haskell.
12:39:32 <dons> hmm.
12:39:34 <dons> what editor?
12:39:37 <Megzlna> Notepad++
12:39:43 <Megzlna> SciTE based
12:39:55 <Megzlna> the scintilla just doesn't know how to fold Haskell.
12:41:32 <august> e-mate and install the haskell bundle
12:41:41 <august> e-editor
12:41:44 <august> whatever it is
12:42:32 <chessguy> is there no right :: Either a b -> b  ?
12:42:37 <dons> i think windows people should have a wiki page on the best tools to use.
12:43:20 <Saizan> ?type typeOf2
12:43:21 <lambdabot> forall (t :: * -> * -> *) a b. (Typeable2 t) => t a b -> TypeRep
12:43:53 <blueonyx> chessguy: doesnt it has to have at least Maybe as result?
12:44:05 <blueonyx> > right (Right 23)
12:44:06 <lambdabot>       No instance for (ArrowChoice Either)
12:44:06 <lambdabot>        arising from a use of `righ...
12:44:09 <orbitz> chessguy: what if you have a Left?
12:44:21 <byorgey> @type rights
12:44:23 <lambdabot> Not in scope: `rights'
12:44:29 <chessguy> @hoogle Maybe a -> a
12:44:29 <teko> jedit!!
12:44:29 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
12:44:29 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
12:44:29 <lambdabot> Data.Monoid First :: Maybe a -> First a
12:44:36 <byorgey> @type fromRight
12:44:36 <orbitz> :t right
12:44:38 <blueonyx> why dont you use case or pattern matching?
12:44:38 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
12:44:38 <lambdabot> Not in scope: `fromRight'
12:44:56 <chessguy> orbitz, blueonyx  it would be equivalent to fromJust
12:45:01 <byorgey> @type eitherToMaybe
12:45:02 <lambdabot> Not in scope: `eitherToMaybe'
12:45:04 <chessguy> @src fromJust
12:45:04 <lambdabot> fromJust Nothing  = undefined
12:45:05 <lambdabot> fromJust (Just x) = x
12:45:05 <teko> > [1..99]
12:45:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:45:10 <orbitz> :t fromJust
12:45:11 <lambdabot> forall a. Maybe a -> a
12:45:22 <orbitz> > fromJust Nothing
12:45:23 <lambdabot>   * Exception: Maybe.fromJust: Nothing
12:45:33 <mmorrow> @type either (const Nothing) Just
12:45:34 <lambdabot> forall a a1. Either a1 a -> Maybe a
12:45:52 <mmorrow> @type maybe [] (:[])
12:45:53 <lambdabot> forall a. Maybe a -> [a]
12:45:58 <chessguy> i'd rather see an exception
12:45:59 <mmorrow> @type maybe mzero return
12:46:00 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
12:46:17 <mmorrow> @type either (throwDyn . show) Just
12:46:18 <lambdabot> Not in scope: `throwDyn'
12:46:39 <chessguy> @hoogle throwDyn
12:46:40 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
12:46:40 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
12:46:44 <ac> If I was going to write a little program to load an image, draw some text on it, and save it, would it be easier to use Gtk2hs, GD, or something else?
12:46:57 <mmorrow> @hoogle catchDyn
12:46:57 <lambdabot> Control.Exception catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
12:47:49 <Megzlna> august: I tried e-editor, but it was lacking the most basic of text editor features
12:47:55 <august> haha
12:47:56 <august> really?
12:48:06 <mmorrow> @type \f -> either Left (Right . f)
12:48:07 <lambdabot> forall b a b1. (b1 -> b) -> Either a b1 -> Either a b
12:48:12 <chessguy> @type error
12:48:13 <lambdabot> forall a. [Char] -> a
12:48:22 <dons> an oldie, but a goodie, http://www.reddit.com/r/programming/comments/7jb37/eliminating_multiplearray_bound_checking_through/
12:48:28 <ac> note that I want contrast immune text (black outline with white center), so unless I can use a font for that, I'd have to fill and scale each letter
12:49:02 <mmorrow> @type either undefined id
12:49:03 <lambdabot> forall a b. Either a b -> b
12:49:10 <Megzlna> yeah, it cant do basic stuff, like move line up / move line down across all languages, as far as I was able to figure out before giving up
12:49:33 <Heffalump> dons: no sign of it arriving yet, but it was sent by the el-cheapo shipping so that's not particularly surprising
12:49:33 <mmorrow> @type either (const (error "YOUR OTHER RIGHT")) id
12:49:34 <lambdabot> forall a b. Either a b -> b
12:49:37 <Megzlna> they spent 100% of effort on the bundles but not on the text editor part.
12:49:51 <dons> Heffalump: but it has shipped?
12:50:01 <Heffalump> that's what they claimed on the 10th
12:50:08 <dons> great. fingers crossed..
12:50:19 <Heffalump> how are your sales numbers looking?
12:50:33 <ac> nevermind, this is stupid. I should be using imagemagick and a shell script for this
12:50:39 <dons> havent' seen them since last week. but staying in top 10 in category
12:50:55 <dons> so i imagine pretty good. it'd sold out in portland after 4 days
12:50:56 <mmorrow> dons: what category? "programming"?
12:51:07 <Heffalump> what are the absolute figures? Just wondering how they compare with the ones jdh claimed on his blog :-)
12:51:08 <dons> yeah, there's some categories it is in.
12:51:13 <dons> soft. eng, languages, etc.
12:51:13 * mmorrow doesn't know what any of the categories are
12:51:17 <mmorrow> ah, cool
12:51:25 <dons> Heffalump: oh, i should see his figures...
12:51:37 <Heffalump> http://flyingfrogblog.blogspot.com/2008/11/sales-of-f-books.html
12:52:04 <dons> ah. so we shipped twice his Q3 figure in the first week.
12:52:14 <Heffalump> lol
12:52:24 <dons> and more than the his estimate for F# in the quarter.
12:52:35 <dons> he's a silly person.
12:53:48 <dons> "a long way ahead of all of the conventional functional languages" mwhaha
12:54:17 * Heffalump struggles with type families yet again
12:56:04 <eu-prleu-peupeu> i want to say one thing...
12:56:11 <eu-prleu-peupeu> "A Joint will help you through times of no money far better than money will help you throught times of no joint. "
12:56:41 <mpeter> > true
12:56:42 <lambdabot>   Not in scope: `true'
12:56:53 <smtms> > True
12:56:55 <lambdabot>   True
12:56:58 * mpeter glares at smtms
12:57:12 <mmorrow> eu-prleu-peupeu: hehe
12:57:33 <mpeter> it was a play on what eu-prleu said, smtms
12:57:34 <dons> Heffalump: that post is jdh at his trollish worst.
12:57:55 <Heffalump> it's his usual mix of half-truth and bluster
12:57:57 <mpeter> how is smalltalk as a language
12:58:15 <dons> i feel slighty dirty every time he appears
12:59:11 <dons> mpeter: hmm. maybe is there a #smalltalk?
12:59:23 <dons> there's, for some reason, little overlap in the pure OO and pure FP communities
12:59:52 <mpeter> i'm in #smalltalk
12:59:57 <mpeter> nobody's talking
13:00:03 <mpeter> so i figured you guys might know
13:00:12 <eu-prleu-peupeu> i will go there, and we will talk
13:00:17 <athos> :t (&&&)
13:00:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:00:23 <eu-prleu-peupeu> because im good at talking and stuff
13:01:19 <dons> ah, eu-prleu-peupeu, noisy as always :)
13:01:21 <Megzlna> august: http://www.e-texteditor.com/wiki/index.php/Editing
13:01:34 <Megzlna> that's all the keys it has. Not even a key to delete line.
13:01:35 <dons> Heffalump: /me must resist urge to smite jdh
13:01:45 <august> Megzlna: i use TextMate
13:01:51 <eu-prleu-peupeu> dons: just doing the usual smalltalk :)
13:01:58 <Megzlna> can TextMate delete a line? :)
13:02:00 <hydo> ok, I'll bite... who is jdh?
13:02:13 <dons> weird troll in fp land.
13:02:17 <august> Megzlna: textmate is what e-texteditor is based on
13:02:23 <Megzlna> Yeah, I know
13:02:30 <august> k
13:02:45 <Megzlna> There's also Intype
13:02:48 <Megzlna> another clone
13:02:57 <Megzlna> http://intype.info/home/index.php
13:03:31 <dons> Heffalump: how is Heffalump Jnr. getting along?
13:04:15 <devragert> i have a question
13:04:16 <august> http://intype.info/faq/#faq-basic-6
13:04:21 <dons> devragert: ask ! :)
13:05:16 <devragert> somewhere in my code, i have:
13:05:18 <devragert> a = MyType "a"
13:05:20 <devragert> b = MyType "b"
13:05:22 <devragert> c = MyType "c"
13:05:24 <devragert> etc. for the whole alphabet, can i shorten this?
13:05:35 <opqdonut> with template haskell, yes
13:05:48 <ddarius> > [a,b,c, ...] = map MyType "abc..."
13:05:48 <lambdabot>   <no location info>: parse error on input `]'
13:05:57 <opqdonut> ddarius: heh :D
13:06:02 <opqdonut> but are you sure you need all those symbols?
13:06:10 <devragert> yes
13:06:26 <august> > [a,b,c, ..] = map MyType "abc.."
13:06:27 <lambdabot>   <no location info>: parse error on input `..'
13:06:32 <ddarius> Well, map (MyType . (:[]))
13:06:36 <devragert> ok, thanks
13:06:38 <august> > [a,b,c..] = map MyType "abc.."
13:06:39 <lambdabot>   <no location info>: parse error on input `..'
13:06:41 <august> aww
13:06:56 <hasky> Is it just me, or is notElem a stupidly redundant function?
13:07:04 <vixey> it's not just you
13:07:14 <roconnor> it's just you and vixey
13:07:25 <roconnor> notElem++
13:07:46 <vixey> :t notElem
13:07:46 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:07:50 <vixey> I didn't know that existed
13:07:57 <roconnor> (not .) . Elem is a pain to type
13:08:05 <dons> hasky: hey, all the functions are redundant. some just more stupidly than others
13:08:11 <ddarius> It's so you can say a `notElem` bs instead of having to say not (a `elem` bs) or something else equally annoying.
13:08:30 <roconnor> right
13:08:43 <dons> ?users
13:08:43 <lambdabot> Maximum users seen in #haskell: 582, currently: 582 (100.0%), active: 34 (5.8%)
13:08:44 <roconnor> a `(not .) . Elem` bs isn't even valid haskell
13:08:47 <dons> hey.
13:08:55 <dons> 582. huh.
13:09:00 <ddarius> Due to mattrepl
13:09:05 <Heffalump> dons: not bad. Still a bit stress-inducing :-)
13:09:18 <ddarius> Heffalump: Don't worry.  It will only get worse.
13:09:29 <dons> Heffalump: i can only imagine.
13:09:40 <hasky> roconnor: can you not simply say not $ Elem a [a] ?
13:09:43 <zaitcev> Finals are almost over, so how can it get worse.
13:09:44 <mattrepl> there should be a prize
13:09:54 <Heffalump> hasky: notElem is handy as an infix operator
13:09:57 <dons> so 582 is 10 up on weds. high score.
13:10:22 <roconnor> hasky: I can't do that if I don't want to apply it to anything
13:10:22 <vixey> Finals Shminals
13:10:50 <dons> so anyone doing some haskell programming?
13:10:56 <vixey> not me :(
13:11:01 <roconnor> > filter (`notElem` [5..10]) [1..15]
13:11:03 <lambdabot>   [1,2,3,4,11,12,13,14,15]
13:11:06 * ddarius is building circuits.
13:11:09 <Heffalump> I am. Struggling with type functions as usual.
13:11:14 <chessguy> dons:  i am, sort of
13:11:18 <dons> Heffalump and his type functions.
13:11:23 <roconnor> vs
13:11:26 <dons> chessguy: oh, goody. chess composition patterns?
13:11:28 <Megzlna> Heffalump: What's a type function?
13:11:33 <august> nobody actually programs in haskell, it's all a conspiracy
13:11:38 <roconnor> > filter (flip ((not .) . elem) [5..10]) [1..15]
13:11:39 <Megzlna> something working over TypeRep's?
13:11:40 <lambdabot>   [1,2,3,4,11,12,13,14,15]
13:11:40 <Raevel> :_/
13:11:43 <ddarius> @users
13:11:43 <lambdabot> Maximum users seen in #haskell: 582, currently: 581 (99.8%), active: 39 (6.7%)
13:11:53 <eu-prleu-peupeu> how long have you guys been coding in haskell ?
13:11:55 <chessguy> dons:  actually, i'm hoping it's a nice general pattern combinator library
13:12:06 <Megzlna> eu-prleu-peupeu: 5 days!
13:12:07 <devragert> but august and ddarius: what if Mytype doesn't take a char as input?
13:12:09 <dons> eu-prleu-peupeu: between 20 years and 1 day.
13:12:11 <Olathe> I've been programming for about three minutes, and it's great !
13:12:24 <ddarius> devragert: I already corrected it above
13:12:34 <Heffalump> Megzlna: no, the type families stuff in GHC 6.10
13:12:48 <roconnor> 6-8 years
13:12:52 <roconnor> I forget when I started
13:12:53 <devragert> ah ok
13:13:10 <roconnor> I was told about haskell in 1998 or so
13:13:15 * ddarius can pinpoint the data within about a week or so.
13:13:21 <ddarius> s/data/date
13:13:22 <amz> Does anyone have any suggestions on an IDE for Haskell? I see that Eclipse has a plugin for it, but it seems fairly primitive and I suspect that it has been abandoned
13:13:23 <roconnor> and I was like: meh, ML seems pretty good
13:13:28 <dons> Feb 2 , 1999.
13:13:35 <roconnor> I'll never get those lost years back
13:13:36 <roconnor> ;(
13:13:37 <eu-prleu-peupeu> 20 years! thats something!, in aprox. 10 months ill wrap my "first years as a haskell coder"
13:13:43 <dons> yay!
13:14:14 <Megzlna> One thing, that, even though I've learned a lot, requires still some gray matter sleeping time, is the complete implications of lazy
13:14:19 <dons> 04.08.17:08:56:22 <roconnor> False < True make no sense
13:14:33 <devragert> but i do have to type the whole alphabet twice, don't i?
13:14:35 <Olathe> It's great.
13:14:36 <dons> roconnor: http://math.berkeley.edu/~roconnor/cs488/sample.png
13:15:03 <chessguy> dons:  that's very anatomically....interesting
13:15:09 <Megzlna> Do you guys know of any article that will give you a lot of surprises about how Lazy works?
13:15:12 <august> 488? professional level class?
13:15:24 <devragert> is there some alphabetic analog of [1..n]?
13:15:27 <ddarius> devragert: If you want to avoid that, you'll need to use TH (or some other metaprogramming thing)
13:15:30 <dons> Lazy?
13:15:35 <ziman> > ['a'..'z']
13:15:36 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
13:15:39 <Heffalump> devragert: Char is in Enum, so it just works
13:15:42 <august> > ['a'..'z']
13:15:43 <Megzlna> devragert: ['a'..'z']++['A'..'Z']
13:15:44 <athos> :t unsafePerformIO
13:15:44 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
13:15:45 <lambdabot> Not in scope: `unsafePerformIO'
13:15:48 <athos> :t unsafePerformIo
13:15:48 <roconnor> dons: sample.png?
13:15:49 <lambdabot> Not in scope: `unsafePerformIo'
13:15:53 <athos> :[
13:15:54 <vixey> Megzlna, no but there is a nice example of lazyness for breadth first labelling trees
13:16:01 <ddarius> Well, yeah you can just do that.
13:16:11 <ziman> athos, unsafePerformIO :: IO a -> a
13:16:15 * ddarius goes back to his forest of resistors.
13:16:21 <athos> ziman: k :>
13:16:26 <Megzlna> vixey I just want a lazy mindfuck article covering various aspects i didn't consider yet
13:16:26 <roconnor> dons: as for False < True,  I didn't realize at the time that <= means ->
13:16:32 <dons> :)
13:16:40 <dons> just interesting seeing what people talk about intiially
13:16:42 <gwern> @seen davidwaern
13:16:42 <lambdabot> I haven't seen davidwaern.
13:16:50 <roconnor> dons: did I post that link?
13:16:51 <gwern> hm. what's waern's irc nick?
13:16:59 <dons> roconnor: yup.
13:17:02 <vixey> False < True aren't actually False and True though
13:17:10 <dons> 04.08.06:11:51:45 <RussellOConnor> my teapot: http://math.berkeley.edu/~roconnor/cs488/sample.png
13:17:10 <vixey> I mean False, True aren't actually False and True though*
13:17:23 <roconnor> dons: :)  I hope that was in context
13:17:26 <devragert> ok, thanks
13:17:53 <roconnor> vixey: they are bottom and top?
13:17:58 <vixey> no
13:18:01 <devragert> thank you all guys
13:18:01 <Liviu`> check it now wWw.E-ChaT.Tk or type /server irc.sidenet.org -j #ChaT if you feel like chating :)
13:18:07 <dons> 04.09.18:07:48:28 * roconnor is glad he is reading haskell IRC logs
13:18:15 <dons> and we're still doing it.
13:18:20 <roconnor> :)
13:18:24 <Raevel> i've installed hunit using cabal, but how can i make ghc find it?
13:18:34 <vixey> I am lost for words
13:18:37 <dons> Raevel: it should be foundd already if you installed with cabal
13:18:43 <b_jonas> where do I find an introduction to the haxml lib?
13:18:45 <dons> Raevel: confirm with: ghc-pkg list HUnit
13:18:47 --- mode: ChanServ set +o Heffalump
13:18:50 <vixey> they are just values with <illusionary> names
13:18:59 <vixey> misdirecting..?
13:19:00 --- mode: Heffalump set +b *!n=xpl0ziv@33.84-48-116.nextgentel.com
13:19:09 <dons> oh. well spotted, Heffalump
13:19:17 <roconnor> vixey: isn't that true for every value in haskell?
13:19:37 <vixey> oh I don't know :(
13:19:50 <vixey> I suppose it makes as much sense as anything else
13:19:51 <Raevel> dons: that listed HUnit, but ghc says "Could not find module `Hunit'"
13:19:56 <vixey> i.e. none
13:19:57 <ddarius> vixey: There's nothing special about true and false in set theory either, it's how they're related.
13:20:43 <gwern> @seen ndm
13:20:44 <lambdabot> I haven't seen ndm.
13:20:49 <gwern> drat
13:20:54 <dons> Raevel: Prelude> :m + Test.HUnit
13:20:54 <dons> Prelude Test.HUnit
13:20:59 <Lemmih> Raevel: Try with the correct spelling.
13:21:17 <dons> Lemmih: i'm writing some stuff for work in happs, btw.
13:21:32 <dons> i wish happs.org was a wiki so i could help update things
13:21:38 <Raevel> oh, that was a typo on irc, not in my source file :-)
13:21:54 <dons> Raevel: the module is Test.HUnit
13:22:07 <dons> see   the list here, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HUnit
13:22:24 <Raevel> ah, it works now, thanks!
13:22:29 <dons> :)
13:22:57 <gwern> St. Dons - among his powers are the driving out of heisenbugs
13:23:02 <Raevel> i compiled the hunit files manually earlier, and then import HUnit worked
13:23:37 <roconnor> me still finds it bizzare that (==) is associative
13:23:40 * roconnor still finds it bizzare that (==) is associative
13:23:41 <dons> maybe that was an old release, Raevel
13:24:04 <b_jonas> well, it's like xor
13:24:14 <Heffalump> but xor is /=
13:24:26 <b_jonas> wait, is it associative?
13:24:29 <b_jonas> um
13:25:17 <b_jonas> > 1==(2==0)
13:25:19 <lambdabot>       No instance for (Num Bool)
13:25:19 <lambdabot>        arising from the literal `1' at <inte...
13:25:27 <sjanssen> b_jonas: only on Bool
13:25:37 <Raevel> dons: true, 1.0
13:25:39 <b_jonas> uh huh
13:25:46 <Heffalump> it's associative on any type-correct expression
13:26:08 <pumpkin> > True == (2 == 0)
13:26:10 <lambdabot>   False
13:26:10 <lambdabot> pumpkin: You have 3 new messages. '/msg lambdabot @messages' to read them.
13:26:15 <Lemmih> dons: Good for you. I wish I was writing HAppS stuff for work.
13:26:29 <dons> Lemmih: how best can i help happs ?
13:27:35 <roconnor> @check \a b c -> ((a == b) == c) == (a == (b == c))
13:27:37 <lambdabot>   "OK, passed 500 tests."
13:27:44 <roconnor> @pl \a b c -> ((a == b) == c) == (a == (b == c))
13:27:45 <lambdabot> ap (ap . ((ap . ((==) .) . (==)) .) . (==)) ((. (==)) . (.) . (==))
13:27:49 <Heffalump> @smallcheck \a b c -> ((a == b) == c) == (a == (b == c))
13:27:49 <lambdabot> Unknown command, try @list
13:27:53 <Heffalump> hmph
13:27:59 <Lemmih> dons: No idea. I'm not terribly involved anymore.
13:28:16 <Heffalump> > and [((a == b) == c) == (a == (b == c)) | a <- [False, True], b <- [False, True], c <- [False, True]]
13:28:18 <lambdabot>   True
13:28:20 <dons> Lemmih: who has commit access?
13:28:50 <dons> Lemmih: i think there's some need to make clear who the authority is.
13:29:02 <ddarius> scheck
13:29:22 <Lemmih> dons: Me and a couple of other people. I'll push your patches if you sent them to me.
13:29:53 <dons> Lemmih: who are the other people? how would i update the main site?
13:30:23 <dons> there's grass roots interest, but it is unclear to me who is looking over things
13:30:51 <Lemmih> dons: Well, there are no active maintainers at the moment.
13:30:59 <eu-prleu-peupeu> i would really like to understand the stuff this guy writes: http://conal.net/blog/
13:31:13 <pumpkin> he hangs out in here
13:31:28 <dons> how would we audition new maintainers? in particular, i'd like to work on the website to collect things
13:31:31 <orbitz> here's her eright now...lurking...waiting
13:31:32 <chessguy> eu-prleu-peupeu:  wouldn't we all?
13:31:35 <eu-prleu-peupeu> i have ordered the real world haskell, so i can read it out on the train and the long commute times
13:31:37 <Lemmih> dons: The box has sensitive information so I can't give you access.
13:31:50 <dons> Lemmih: is the src for the site in a repo?
13:31:58 <dons> (like xmonad.org)
13:32:01 <eu-prleu-peupeu> in the hope i can understand him on a near future
13:32:08 <chessguy> eu-prleu-peupeu:  the authors of that are on here too
13:32:42 <Lemmih> dons: Yes. However, I think it would be easier to use a different box and then move the domain.
13:33:08 <dons> yes.
13:33:16 <dons> Lemmih: perhaps even code.haskell.org/happs ?
13:34:05 <dons> Lemmih: maybe i'll just start a web repo
13:34:05 <ehird> is there a Set without the Ord requirement>?
13:34:12 <dons> ehird: [a] ?
13:34:14 <Megzlna> there's a kinda odd disconnect between pattern matching of regular functions, and lambdas. Lambdas can only have one pattern, but when you emulate regular functions with lambdas, they also do something regular functions seemingly can't:
13:34:15 <Megzlna> let f = \a (x:xs) -> \b (x:xs) -> 1
13:34:23 <dons> ehird: (has union, intersect etc)
13:34:25 <Megzlna> pattern matching on a per-curry basis
13:34:31 <ehird> dons: That is not unordered and can contain duplicates. :P
13:34:43 <ddarius> ehird: You observe it via nub.
13:34:46 <Heffalump> Megzlna: that just name shadows
13:34:59 <Heffalump> it's equivalent to f a (x:xs) = let g b (x:xs) = 1 in g
13:35:02 <ddarius> (and up to permutation)
13:35:02 <Lemmih> ehird: mkSet = nub . sort?
13:35:09 <Megzlna> Heffalump: s/x:xs/y:ys/
13:35:20 <opqdonut> Lemmih: sort? hardly.
13:35:21 <Heffalump> that's the same as \a (x:xs) b (y:ys) -> 1 then
13:35:23 <ehird> Lemmih: Still, I don't require ordering and it'd be nice not to have to manually unique-ify it all the time.
13:35:33 <dons> ehird: but you cna't use Set ?
13:35:40 <ddarius> ehird: You don't have to.
13:35:42 <Lemmih> opqdonut: Ah, right. Not sort.
13:36:09 <ozy`> GHC 6.10 won't install even via macports >:|
13:36:10 <ddarius> A sensible thing would be to use a newtype wrapper and make it an abstract type.
13:36:27 <ddarius> Another possible representation supporting different options is (a -> Bool)
13:36:30 <ehird> dons: well, Ord doesn't really make sense for the types I'm using.
13:36:32 <Lemmih> dons: That would still be a static website. It would be nice to get gitit running somewhere.
13:36:50 <dons> Lemmih: agreed.
13:36:58 <mpeter> static websites are for manuals
13:37:04 <mpeter> and 11 year old girls
13:37:28 <conal> eu-prleu-peupeu: hi
13:37:28 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:31 <eu-prleu-peupeu> hey conal!
13:38:47 <eu-prleu-peupeu> i admire your stuff
13:40:14 <chessguy> eu-prleu-peupeu:  we all want to be conal :)
13:40:29 <conal> gee, thx :)
13:40:54 <eu-prleu-peupeu> well, i dont want to be conal, but i apreciate his work, much in admiration, since i dont have the theoritical foundations to understand it
13:41:01 <eu-prleu-peupeu> yet
13:41:14 <mpeter> i'm incapable of intimacy
13:41:32 <chessguy> conal:  my pattern combinator library is coming together. http://hpaste.org/13047 type-checks against my library
13:42:08 <mpeter> > map (\x-> chr(ord(x)+1))  "blah blah blah blah"
13:42:10 <lambdabot>   "cmbi!cmbi!cmbi!cmbi"
13:42:20 <mpeter> sweet
13:42:28 <mauke> > map succ "blah blah"
13:42:29 <lambdabot>   "cmbi!cmbi"
13:42:34 <conal> chessguy: awesome!
13:42:36 * mpeter frowns
13:42:49 <mpeter> that's way too easy
13:42:58 <Heffalump> chessguy: can it handle binding?
13:43:11 <mpeter> now how do i do that 13 times
13:43:28 <roconnor> mpeter: all haskell code can be made 10% shorter
13:43:35 <roconnor> so don't feel too bad
13:43:45 <eu-prleu-peupeu> even the code that has been made 10% shorter ?
13:43:52 <roconnor> eu-prleu-peupeu: yes :)
13:43:52 <chessguy> Heffalump:  what do you mean by "binding"?
13:44:07 <ziman> > let (✕) = replicate in 13 ✕ map succ "blah blah"
13:44:09 <lambdabot>   ["cmbi!cmbi","cmbi!cmbi","cmbi!cmbi","cmbi!cmbi","cmbi!cmbi","cmbi!cmbi","c...
13:44:12 <ziman> :)
13:44:33 <mpeter> mIRC =/= unicode
13:44:33 <Heffalump> chessguy: that code is fine for abstracting over patterns that either match or don't match
13:44:44 <mpeter> stupid windows
13:44:47 <Heffalump> but what I'd really like is to abstract over patterns that also bind some variables when they match
13:45:14 <mpeter> can't you just do that with guards
13:45:18 <mauke> Once you've installed a newer version of mIRC, to enable UTF-8 all you have to do is go to the Options-menu (Alt+O) and select IRC->Messages. Here you'll find a checkbox labeled UTF-8 display, make sure it's checked, and UTF-8 should be working.
13:45:38 <chessguy> Heffalump: ah, yes, that's the next thing i want to add, the ability to "select" an element. should be pretty easy
13:45:43 <mpeter> that's odd, it is checked
13:45:59 <Heffalump> really? I thought it's quite a hard problem.
13:46:00 <mauke> á€ß
13:46:04 <ddarius> The character is probably not in your font
13:46:05 <Megzlna> mpeter: mIRC is unicode
13:46:10 <mpeter> that would do it
13:46:28 <Megzlna> http://www.fixedsysexcelsior.com/information/scripts.gif
13:47:19 <vixey> nice image
13:47:42 <chessguy> Heffalump:  well, i haven't coded it yet, but it seems simple enough
13:48:00 <athos> > 5 .|. 3
13:48:02 <lambdabot>   Add a type signature
13:48:03 <august> what's with the coloring?
13:48:18 <mpeter> :t _|_
13:48:19 <lambdabot> parse error on input `|'
13:48:22 <mpeter> ;)
13:48:23 <athos> > 5 .|. 3 :: Int
13:48:24 <august> psychedelic
13:48:24 <lambdabot>   7
13:48:43 <chessguy> Heffalump:  the plan is to represent elements as nodes of a graph
13:48:50 <Megzlna> I use this font for all code
13:48:59 <chessguy> Heffalump: with predicats (a -> a -> Bool) as labels of edges between the nodes
13:50:42 <chessguy> Heffalump: of course, that all happens behind the scenes, abstracted out by the simple kind of interface i just showed
13:50:52 <teko> when should i use foldr instead of foldl ?
13:51:20 <ddarius> @wiki Stack overflow
13:51:20 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
13:51:24 <ddarius> teko: Read that.
13:51:38 <teko> but foldr also overflows
13:51:43 <teko> thats y u use foldl'
13:52:20 <athos> :t foldl'
13:52:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:52:27 <athos> @src foldl'
13:52:27 <lambdabot> foldl' f a []     = a
13:52:27 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:52:50 <evident> good evening everybody
13:52:58 <roconnor> teko:  you should use foldr f whenever the funciton f generates constructors
13:53:02 <athos> @src seq
13:53:03 <lambdabot> Source not found. Maybe you made a typo?
13:53:22 <teko> oh
13:53:29 <chessguy> lambdabot: Source not found. Maybe you're a blooming idiot?
13:53:33 <roconnor> example
13:53:36 <roconnor> @src concat
13:53:37 <lambdabot> concat = foldr (++) []
13:53:43 <roconnor> @src (++)
13:53:43 <lambdabot> []     ++ ys = ys
13:53:43 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:53:43 <lambdabot> -- OR
13:53:43 <lambdabot> xs ++ ys = foldr (:) ys xs
13:54:01 <roconnor> so (++) generates constructors in the second case
13:54:13 <roconnor> (generating a (:))
13:54:39 <mpeter> teko: constructors being the items that construct a list ;)
13:54:51 <mpeter> > 3 : 4 : 5 : 6 : []
13:54:52 <lambdabot>   [3,4,5,6]
13:55:04 <teko> kool ta
13:55:06 <roconnor> To be more techincal f x y must should a constructor where the value y occurs under that constructor.
13:55:11 <roconnor> s/must//
13:55:22 <teko> when should i use if then else instead of guards ?
13:55:23 <ddarius> roconnor: foldr1 const
13:55:25 <mpeter> i was going to say, that's not very technical
13:55:41 <roconnor> right
13:55:55 <roconnor> okay
13:55:57 <mwotton> does something like QuickCheck exist for C? I've been playing around with using QC and some haskell bindings, but if someone's done it already i'd rather not reinvent the wheel
13:56:01 <roconnor> in light of ddarius's example
13:56:06 <ddarius> teko: One's an expression, one's not.
13:56:12 <august> [x,y,..] is syntact sugar for x:y:..:[]
13:56:18 <roconnor> we want f x y to have every occurance of y under a constructor.
13:57:12 <teko> but which is better style ? ddarius ?
13:57:14 <byorgey> yaxu's livecoding performance is starting in 5 minutes!
13:57:16 <byorgey> http://toplap.org/index.php/ToplapStreams
13:57:41 <ddarius> teko: It's not a matter of style.  They aren't interchangeable.
13:58:09 <teko> ok
13:58:16 <teko> whats livecoding ?
13:58:57 <byorgey> teko: producing music/sound by writing code to produce it, live
13:59:08 <byorgey> teko: like playing an instrument, except your instrument is code
13:59:27 <teko> kool
13:59:47 <byorgey> IIUC, yaxu will be using an interpreter he wrote in Haskell for part of it
14:02:13 <evident> guys I have a little problem with strings and stacks:
14:02:14 <evident> http://hpaste.org/13048
14:02:21 <mpeter> i bet you do
14:02:23 <evident> would be great if you could help me
14:02:24 <evident> :)
14:02:54 <evident> any idea how to fix that?
14:03:05 <vixey> evident,instead of  "... <Tag1>...<Tag2>...</Tag2>...</Tag1>..."
14:03:05 <evident> what is wrong there?
14:03:15 <mpeter> looks like you need to define EmptyStk ;)
14:03:26 <vixey> evident, might be easier to operate on [Left "...", Right "Tag1", Left "...", Right "Tag2", ...]
14:03:33 <evident> but isnt it already defined in the other one?
14:03:45 <vixey> evident, err [Left "...", Right (Open "Tag1"), Left "...", Right (Open "Tag2"), ...]
14:04:04 <evident> why is taht easier?
14:04:40 <evident> what i was thinking of doing:
14:04:50 <vixey> evident, because the structure you want to inspect is expressed in data
14:04:56 <arjanb> evident: to import the constructors you need to use Stack(..)
14:05:36 <evident> take the first element of the list -> compare it with the topmost element in the stack -> if tagMatch -> take the top one in stack away, if no tagmatch, add the first list element to the stack
14:05:40 <evident> until the list is empty
14:05:49 <evident> then check whether the stack is empty
14:05:57 <evident> if it is -> true, if not -> false
14:06:09 <evident> where do I have to use Stack (...) ?
14:06:59 <arjanb> module Stack(Stack(..),
14:07:17 <vixey> module Stack(Stack(Stack(..),
14:08:37 <evident> sorry, i dont get it
14:11:42 <evident> isnt it already written like that?
14:11:57 <RayNbow> hmm, is there any restriction on natural languages used on the Haskell Wiki?
14:12:25 <evident> module Stack(Stack,push,pop,top,emptyStack,stackEmpty)
14:12:43 <mauke>  module Stack(Stack(..),
14:13:15 <evident> well i cant do taht till infinity...
14:13:37 <mauke> what
14:13:39 <cjay> is there any way to get hs-plugins with ghc-6.10.x yet? I don't understand the error message, Setup.lhs complains about missing "Cabal ==1.4.*", but the .cabal file only specifies Cabal >= 1.4 && < 1.5
14:13:59 <cjay> oh, that's what it says
14:14:04 <cjay> hmm
14:14:26 <evident> mauke: do you just want me to put another Stack( .... ) around the line Stack(Stack,push,pop,top,emptyStack,stackEmpty) ?
14:14:32 <mauke> evident: no
14:14:44 <evident> i havent done much with modules yet...
14:14:46 <mauke> I want you to write Stack(..) there
14:14:56 <evident> ahh
14:14:56 <evident> ok
14:15:41 <evident> and where exactly? still giving me errors
14:15:58 <evident> could you make a revision on my hpaste code? just the one line
14:16:21 <mauke> module Stack(Stack,push,pop,top,emptyStack,stackEmpty)
14:16:24 <mauke> er, sorry
14:16:45 <mauke> module Stack(Stack(..),push,pop,top,emptyStack,stackEmpty)  -- fixed
14:16:51 <evident> ahh
14:17:56 <evident> thx
14:18:39 <evident> i think i get how that works but i cant formulate how it does... could you maybe tell me what the change does, so that i am confirmed in my thoughts? :D
14:24:16 <rgr> I am trying to build hoogle from darcs.
14:24:32 <rgr> I get this form the configure stage:
14:24:34 <rgr> Setup: At least the following dependencies are missing:
14:24:34 <rgr>     safe -any, uniplate -any, time -any
14:24:34 <rgr>  
14:24:58 <rgr> Is there any documents to explain what this means and where to get them?
14:25:54 <athos> > let cons' = flip (:) in foldl cons' [] [1,2,3]
14:25:55 <lambdabot>   [3,2,1]
14:26:58 <athos> hmm.. i don't get why the list gets reversed.. i thought evaluation would look like: foldl cons' (((([] `cons'` 1) `cons` 2) `cons 3`) `cons` [])
14:27:30 <athos> eeh i mean  foldl cons' ((([] `cons'` 1) `cons` 2) `cons 3`) []
14:27:44 <mauke> cons doesn't exist, and `cons 3` is a syntax error
14:27:53 <athos> cons' is defined above
14:27:59 <mauke> irrelevant
14:28:24 <athos> i'm confused
14:28:37 <wolgo> Hey Real World Haskell is good!
14:28:38 <mauke> the evaluation looks like ((([] `cons'` 1) `cons'` 2) `cons'` 3)
14:28:46 <athos> yeah
14:28:50 <roconnor> > foldl f z [a,b,c]
14:28:52 <lambdabot>   f (f (f z a) b) c
14:29:00 <mauke> [] `cons'` 1 is [1]
14:29:04 <athos> and cons' is just flip (:), i thought it would get a bit ugly
14:29:05 <roconnor> > foldl (flip f) z [a,b,c]
14:29:06 <lambdabot>   f c (f b (f a z))
14:29:06 <mauke> [1] `cons'` 2 is [2,1]
14:29:15 <mauke> [2,1] `cons'` 3 is [3,2,1]
14:29:21 <athos> ah
14:29:22 <athos> i see
14:29:23 <athos> my bad
14:29:27 <athos> ;)
14:29:42 <athos> cons puts the new element at the front
14:29:55 <athos> of course... dumb question
14:29:57 <roconnor> @src reverse
14:29:58 <lambdabot> reverse = foldl (flip (:)) []
14:31:04 <b-04> lambdabot rulz
14:32:52 <sabren> anyone manage to get Glob.hs to compile correctly (8.7 in Real World Haskell)?
14:33:21 <sabren> GHCi keeps complaining that handle isn't defined correctly and I'm literally cutting and pasting the lines from safari... :/
14:36:42 <sabren> or better yet... can someone help me understand this error message (in the comment)   http://hpaste.org/13049
14:36:50 <chessguy> lambdabot++
14:38:05 <mauke> sabren: change Control.Exception to Control.OldException
14:38:06 <sjanssen> sabren: ah, this is due to some new stuff added in GHC 6.10
14:38:13 <cjay> @tell mmorrow plugins-1.3.1 successfully loads module dependencies from packages :)
14:38:14 <lambdabot> Consider it noted.
14:38:14 <chessguy> sabren: where is line 53?
14:38:18 <sjanssen> sabren: you can use OldException, or explicitly name the type of exception to handle
14:38:30 <sabren> huh
14:38:38 * sjanssen still doesn't like this change
14:38:42 <sabren> chessguy: it's the call to "handle"
14:38:44 <kpreid> savthe error means that by ignoring the argument (const) you're giving too little information to choose a typeclass
14:39:12 <sabren> OldException works
14:39:18 <rgr> trying to build hoogle. Get this error "Setup.hs: array.hoo: copyFile: does not exist (No such file or directory)". Any ideas?
14:39:31 <sabren> thanks guys
14:40:42 <sabren> kpreid: so... to use the current Exception, i"d have to put a :: Exception  after the const call somewhere?
14:41:57 <sabren> hrm.. that would mean knowing the type of the exception..
14:42:22 <mux> handle (const (return [])) $ do
14:42:23 <mmorrow> cjay: oh nice, so it was just a bug or just not implemented in previous versions?
14:42:24 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
14:42:30 <jberg-> uhm, shouldn't sin always be from -1.0 to 1.0 =
14:42:31 <jberg-> ?
14:42:51 <mux> changing to handle (\(e::SomeException) -> return []) $ do should work
14:42:53 <mauke> sabren: you can catch SomeException
14:42:59 <mux> but requires some extension
14:43:58 <sabren> so this is basically a very recent change to Control.Exception ? (since the book just came out?)
14:44:05 <cjay> mmorrow: no idea, the previous version was 1.2. 1.3.1 wanted a newer Cabal so at first I was reluctant installing it, but it turned out it's ok to have multiple Cabals (one in the system, one in the homedir)
14:44:16 <mux> it's the new Control.Exception from GHC 6.10
14:44:19 <mux> fairly recent indeed
14:44:59 <sabren> fair enough! :)
14:45:02 <sabren> thanks!
14:45:07 <mux> you're welcome
14:45:29 <evident> mauke i have another problem with the stack: the function is a homework which i have to hand in online and which is checked automatically... so it already has the the Stack.hs and i cant use my modified one... is there a way to change that without touching the Stack.hs ?
14:45:38 <mmorrow> cjay: cool. yeah, i even have multiple Cabals in the global packagedb
14:45:51 <evident> because now when i hand it in i get the error with the Undefined data constructor "EmptyStk" again
14:46:09 <evident> on my hugs here it all works fine now
14:46:28 <mauke> evident: emptyStack = EmptyStk
14:46:32 <mauke> just use that
14:46:44 <evident> ok
14:46:55 <redditbot> Eliminating Multiple-Array Bound Checking through Non-dependent types
14:47:07 <chessguy> @pl \p e -> n (nu (m p e))
14:47:07 <lambdabot> ((n . nu) .) . m
14:47:29 <evident> working... thanks a lot!!!!
14:48:55 <chessguy> @pl \p e -> (n . u) (m p e)
14:48:55 <lambdabot> ((n . u) .) . m
14:49:53 <mmorrow> man, i just joined #bash for the first time and have already picked up two tricks i'm going to use all the friggin time
14:49:56 <chessguy> hm. why is this not just n . u . m ?
14:50:14 * mmorrow becomes a regular member of #bash
14:50:29 <mauke> mmorrow: what are they?
14:51:02 <mmorrow> mauke: Here strings, and doing  f=\'   instead of (how i used to solve that problem) having a script that outputs a single '
14:51:07 <conal> (fmap.fmap) (n . nu) m
14:51:16 <conal> or (result.result) (n . nu) m
14:51:27 <mauke> mmorrow: wow, a script?
14:51:34 <mauke> I just escape ' by using '\''
14:51:41 <mmorrow> yeah, i can't believe i've never thought to assign it to a var
14:51:53 <mmorrow> mauke: but sometimes that's epic
14:51:54 <mauke> echo 'that'\''s right!'
14:52:22 <mauke> mmorrow: how does a variable help there?
14:53:13 <mmorrow> like, say you're wanting to wrap a string in single quotes (instead of escaping everything that needs it, possibly many levels deep) to eval later
14:53:32 <mmorrow> a var makes it simpler to look at
14:54:40 <mmorrow> your example is a perfect one
14:54:47 <mauke> er, what?
14:54:58 <mmorrow> eval 'echo $fthat$fs right!$f'
14:55:40 <mauke> that's horribly broken
14:55:55 * mmorrow works it out in the shell
14:56:05 <vixey> perl shell ??
14:56:17 <vixey> Und wech!"
14:56:23 <vixey> @translate de en Und wech!
14:56:23 <lambdabot> Unknown command, try @list
14:56:30 <mmorrow> mauke: the only time that's ever really came up as being useful was while trying to write a quine, but i try to do that often ;p
14:56:37 <mmorrow> i meant ;)
14:56:53 <mauke> http://mauke.ath.cx/stuff/sh/quine.sh :-)
14:56:55 <profmakx> Und wech means something like "I'm outta here", vixey
14:57:09 <b_jonas> wait
14:57:19 <mmorrow> mauke: nice, i think i have that one actually :)
14:57:23 <b_jonas> I'm reading this haxml tutorial at http://www.cs.york.ac.uk/fp/HaXml/icfp99.html
14:57:33 <ddarius> @babel de en Und wech!
14:57:34 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
14:57:40 <mmorrow> mauke: i've been trying to write a /one-liner/ quine off-and-on for a while now
14:57:54 <b_jonas> the introductory paragraph at point 2.2 Combinators totally doesn't makes sense, it's just a rambling, right?
14:58:38 <mmorrow> mauke: also, i can't seem to make this tail-recursive (it may be impossible as-is):
14:58:41 <wli> Isn't Haskell supposed to be more  reliable for various reasons? Prelude.head: empty list isn't helping that along that I can tell.
14:58:50 <mmorrow> a="b=\$((1+\`cat\`));echo \$b; echo \$b | eval \$a"; echo 42 | eval $a
14:59:16 <mmorrow> , iterate (+1) 42
14:59:18 <lunabot>  [42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,...
14:59:23 <b_jonas> wli: did you try compiling to bytecode? you may get better messages that way
14:59:41 <mauke> $ _=eval =>eval   # EXPERT PERL CODE
14:59:50 <HelgeS> Anyone using Ubuntu, knowing how to get the command "cabal"? I want to be able to do "cabal install wl-pprint" (Example in realworldhaskell, ch. 5)
15:00:17 <wli> b_jonas: Ask whoever's running lambdabot (that's what got the empty list).
15:00:38 <chessguy> wli: that's the exception, not the norm
15:00:39 <b_jonas> wait
15:00:40 <mmorrow> mauke: heh
15:00:52 <b_jonas> lambdabot crashed for you with that message?
15:01:00 <b_jonas> or what?
15:01:07 <mmorrow> > 42
15:01:08 <lambdabot>   42
15:01:15 <mmorrow> still living
15:01:17 <mauke> b_jonas--
15:01:21 <sjanssen> @hackage cabal
15:01:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal
15:01:23 <wli> b_jonas: It just put that message out on IRC a couple of minutes ago.
15:01:29 <sjanssen> @hackage cabal-install
15:01:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
15:01:47 <sjanssen> HelgeS: download and install the package at that URL ^^^
15:01:58 <wli> b_jonas: The babel plugin failed in that manner, to be specific.
15:02:37 <HelgeS> So there is no Cabal package in Ubuntu? It's kind of supposed to be a part of ghc6, but I'm not sure.
15:02:38 <chessguy> @babel en es foo
15:02:39 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
15:02:56 <chessguy> wli:  that's a bug, not the fault of haskell
15:03:15 <ddarius> @version
15:03:15 <lambdabot> lambdabot 4.2.2
15:03:15 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:03:36 <chessguy> wli:  you can do stupid things in any language, don't forget :)
15:03:55 <wli> It's the standard library API's that invite that sort of thing.
15:04:07 <wli> Granted, there is some tradition behind them.
15:04:20 <HelgeS> @hackage madeupname
15:04:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/madeupname
15:04:31 * chessguy giggles
15:06:30 <athos> @hoogle ord
15:06:30 <lambdabot> Data.Char ord :: Char -> Int
15:06:30 <lambdabot> module Data.Ord
15:06:30 <lambdabot> Prelude class Eq a => Ord a
15:07:37 <b_jonas> maybe "Und wech!" in german really means "Plugin `babel' failed with: Prelude.head: empty list"
15:07:46 <b_jonas> so it just gave a result, not an error
15:07:47 <vixey> hahaha!
15:08:03 <MyCatVerbs> jonas has a point. German does have some very specific nouns.
15:08:18 <b_jonas> what if we run it again?
15:08:55 <b_jonas> @babel de en Und wech!
15:08:56 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
15:08:57 <b_jonas> @babel de en Und wech!
15:08:58 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
15:09:47 <MyCatVerbs> @babel en de green sausages
15:09:48 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
15:09:55 <RayNbow> @seen dons
15:09:55 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 33m 4s ago.
15:11:49 <wli> I had a nutty idea of representing things as linear constraints like i_0 <= i <= i_1, -1 <= i - j <= 1, etc.
15:12:13 <ddarius> b_jonas: @babel has been broken for a long time, and not because it uses head.
15:12:16 <wli> Maybe even always using bounding boxes in addition to things.
15:13:20 <wli> i_0 <= i <= i_1, j_0 <= j <= j_1, then a_k*i + b_k*j <= c_k for various k. The only trick being there's no obvious indexing method beyond brute force.
15:13:22 <vixey> I do'nt think that is nutty
15:13:39 <athos> > foldl' f "baz"
15:13:40 <lambdabot>       Overlapping instances for Show ([b] -> [Char])
15:13:40 <lambdabot>        arising from a us...
15:13:44 <athos> > foldl' f 0 "baz"
15:13:45 <lambdabot>   Add a type signature
15:13:58 <athos> > foldl' f 0 [a, b, c]
15:14:00 <lambdabot>   Add a type signature
15:14:04 <wli> vixey: If there's nothing but bounding boxes, k-d trees etc. work well enough.
15:14:06 <athos> > foldl' f z [a, b, c]
15:14:08 <lambdabot>   f (f (f z a) b) c
15:14:33 <wli> vixey: With less regular regions there's trouble.
15:14:59 <ozy`> > foldr f z [a, b, c]
15:15:01 <lambdabot>   f a (f b (f c z))
15:17:38 <Raevel> what's a rigid type variable?
15:18:32 <olsner> sounds like you have received an error message :)
15:18:41 <Raevel> you bet!
15:19:10 <athos> > let f x y = x*10 + ord 'y' - ord '0' in foldl' f 0 "12345678987654321"
15:19:12 <lambdabot>   811111111111111103
15:19:15 <Raevel> i've got class Pack a where pack :: t -> a; unpack :: a -> t
15:19:22 <athos> > let f x y = x*10 + ord y - ord '0' in foldl' f 0 "12345678987654321"
15:19:24 <lambdabot>   12345678987654321
15:19:39 <mauke> Raevel: what's t?
15:20:06 <calsaverini> what's haskell?
15:20:32 <Raevel> i wanted different instances to be able to use different types instead of t
15:20:37 <mauke> calsaverini: how did you find this channel?
15:20:46 <Raevel> is it possible? is it stupid?
15:21:21 <mauke> Raevel: sounds like you want multiparameter typeclasses
15:21:31 <mauke> class Pack t a where pack :: t -> a
15:21:36 <chessguy> @pl \p -> m p ss
15:21:37 <lambdabot> flip m ss
15:21:45 <ozy`> mauke: calsaverini obviously just checked out one of the largest channels on the server
15:21:48 <dons> ?yow
15:21:48 <lambdabot> I represent a sardine!!
15:21:50 <dons> ?users
15:21:50 <lambdabot> Maximum users seen in #haskell: 586, currently: 566 (96.6%), active: 22 (3.9%)
15:22:18 <Raevel> hmm...
15:22:25 <athos> @pl \x y -> x*10 + ord y - ord '0'
15:22:26 <lambdabot> flip flip (ord '0') . ((-) .) . (. ord) . (+) . (10 *)
15:23:19 <dons> Raevel: or perhaps associated types
15:23:40 <dons> for what are you asking the question?
15:24:03 <chessguy> @pl determineMove ss ps = head $ concatMap (flip match ss) ps
15:24:03 <lambdabot> determineMove = (head .) . (=<<) . flip match
15:24:57 <Raevel> i have a type that i constantly pack/unpack in order to operate on the internal representation, and thought it could be neat to have a type class so i could use it for other types as well
15:25:39 <dons> sounds good.
15:25:47 <Raevel> yay
15:25:50 <olsner> hmm, that does sound like a multi-parameter type class with fundeps
15:26:00 <dons> so the type class operatoins would be ?
15:26:23 <dons> so what are people working on this weekend?
15:26:28 <dons> any cool new haskell projects?
15:26:38 <dons> i'm doing some work stuff in happs, and hacking on uvector
15:26:46 <Raevel> pack :: t -> a; unpack :: a -> t, where a is my type, and t the internal representation
15:26:59 <dons> Raevel: hmm.... thinking.
15:27:32 <dons> so there's a natural transformation between t and a ?
15:27:41 <mauke> why have both pack and unpack?
15:27:52 * RayNbow won't have much time for Haskell stuff for a few months... (working on research+MSc thesis)
15:27:57 <Raevel> dons: i'm not sure what you mean
15:28:00 <dons> reminds me a bit of:
15:28:00 <dons> class (Functor f, Functor g) => NatTrans f g where eta :: f a -> g a
15:28:12 <dons> class Model a b where model :: a -> b  -- get the abstract vale from a concrete value
15:28:22 <dons> instance Model Bool  Bool         where model = id
15:28:27 <dons> instance Model Int64 Int          where model = fromIntegral
15:28:29 <dons> etc.
15:28:55 <dons> instance Model f g => NatTrans ((,) f) ((,) g) where eta (f,a) = (model f, a)
15:29:06 <dons> -- And finally, we can take any (m a) to (n b), if we can Model m n, and a b
15:29:06 <dons> instance (NatTrans m n, Model a b) => Model (m a) (n b) where model x = fmap model (eta x)
15:29:16 <mauke> zomg hax
15:29:35 <dons> totally haxors
15:29:39 <RayNbow> dons: should I extend the Fibonacci hawiki page with an example on generalized Fibonacci sequences?
15:29:50 <dons> RayNbow: i think maybe a section at the bottom would be nice, yes.
15:30:08 * RayNbow adds it to his tomorrow's ToDo list
15:30:29 <dons> why do it tomorrow, when you can edit it now?
15:30:31 <dons> http://haskell.org/haskellwiki/The_Fibonacci_sequence#Naive_definition
15:30:44 <RayNbow> dons: because of the local time :p
15:30:48 <dons> ?time RayNbow
15:30:49 <lambdabot> Local time for RayNbow is Sun Dec 14 00:32:54 2008
15:30:51 <dons> ic!
15:31:22 <dons> mauke: so natTrans used to be in the gofer prelude
15:31:33 <dons> but the issue is the 'naturalness' of the transformation
15:31:37 <dons> too many choices.
15:31:59 <luite_> RayNbow: you said that you were going to watch a dvd (in another channel), so that really isn't an acceptable excuse ;)
15:32:18 <Raevel> i managed to get mauke's suggestion to compile at least :-) with -XMultiParamTypeClasses and -XFlexibleInstances
15:32:28 <RayNbow> luite_: watching DVDs don't require much brain power :p
15:32:51 <dons> if you practice your haskell, it will be as brainless as watching a dvd too
15:33:02 <dons> you can basically just switch off and hack
15:33:07 <Raevel> dons: sounds boring
15:33:18 <dons> well, you get to the fun stuff faster.
15:33:31 <dons> so its like watching a dvd. sit back and watches the lambdas come together
15:33:36 * dons is serious.
15:33:44 <dons> but i hack haskell instead of watching dvds fairly often
15:33:57 <dons> have a quiet beer and some haxoring
15:34:28 * RayNbow wants to hack some Haskell...
15:34:41 <RayNbow> but for serious hacking, I need a Linux machine :p
15:35:03 <dons> gotta practice every day to get good
15:35:06 * RayNbow should format his Netbook and put Arch Linux on it or something
15:35:11 <dons> remember: expertise takes 10,000 hours.
15:35:15 <dons> so about 7 years.
15:35:19 <wchogg> dons : I was just going to reference that
15:35:24 <dons> i think its entirely true.
15:35:31 <dons> there's a reason phd's tend to end up taking 7 years :)
15:35:33 <dons> mwhaa
15:35:35 <wli> BTW, for generalized 2nd-order linear recurrences, the same sort of trick as I used for the "Fastest Fibonacci in the West" also applies.
15:35:47 <RayNbow> http://norvig.com/21-days.html ? :p
15:35:56 <RayNbow> (10 years also sound reasonable)
15:36:05 <byorgey> > 10000 / (7 * 365)
15:36:06 <lambdabot>   3.9138943248532287
15:36:21 <byorgey> only 4 hours a day?
15:36:27 <wli> Basically you're just writing the matrix exponentiation in scalar form and then use bitreversal for fast exponentiation of the matrix.
15:36:47 * RayNbow has been programming for approx. 12-13 years now
15:36:49 <opqdonut> bitreversal?
15:36:57 <opqdonut> you mean russian peasants' algorithm?
15:37:15 <RayNbow> (but I didn't start functional... I started with VB...)
15:37:17 * RayNbow hides
15:37:25 <wchogg> Why should you hide?
15:37:30 <wli> opqdonut: Well, cf. the Fastest Fibonacci in the West bit in the Haskell Wiki.
15:37:32 <wchogg> I started with C++.
15:37:40 * wli started with C.
15:37:43 <RayNbow> wchogg: I don't want to remember the days :p
15:37:44 <opqdonut> wli: yeah i know the solution
15:37:49 * wli still does C.
15:37:54 * opqdonut started with perl but really learned programming in C
15:37:55 <wchogg> wli : nothing wrong with C
15:37:56 <RayNbow> my first VB program was goto-spaghetti :p
15:38:21 <wli> opqdonut: One of my solutions literally breaks down a number into [Bool] and then reverses the list.
15:38:23 <RayNbow> (but that's because I was used to goto in .bat files :p)
15:38:24 <byorgey> wasn't everyone's?
15:38:32 <opqdonut> wli: heh :)
15:38:55 <wchogg> byorgey : Real expert VB is a mess of onerror goto's
15:39:16 <RayNbow> On Error Resume Next REM w00t :p
15:39:19 <Raevel> okay, this i don't understand at all, i made an instance of the class, Pack [[Frac]] Matrix, but when i call unpack i get "No instance for (Pack [a3] Matrix)", what does it mean?
15:39:21 <wli> opqdonut: The second one uses testBit on a descending sequence of bit indices.
15:39:39 * dons is pleased to see RWH back on shelves in portland again.
15:39:41 <athos> > foldr f z [a,b,c]
15:39:43 <lambdabot>   f a (f b (f c z))
15:39:51 <wli> wchogg: The same is true for C.
15:40:13 <wli> dons: I'll need a while before I'm back on the West Coast, but I'll more likely be in the SFBA than PDX.
15:40:45 <Cale> Raevel: Perhaps it can't tell that the type a3 is really [Frac]?
15:40:58 <Cale> Raevel: Could it be ambiguous?
15:41:17 <chessguy> i'm pretty excited about how my pattern combinator library interface is turning out: http://hpaste.org/13052
15:41:22 <Raevel> Cale: hmm, what would make it ambiguous?
15:41:41 <Cale> Well, I don't know what the interface to this class looks like.
15:41:44 <Raevel> (so, yes, probably)
15:42:04 <Raevel> it's class Pack t a where unpack :: a -> t
15:42:14 <athos> @src groupBy
15:42:14 <lambdabot> groupBy _  []       =  []
15:42:14 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
15:42:14 <lambdabot>     where (ys,zs) = span (eq x) xs
15:42:20 <evident> Hi, could anybody explain to me what the functions showsPrec does? I hoogled it but dont understand... would be great...
15:42:33 <opqdonut> :t showsPrec
15:42:34 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
15:42:47 <Cale> Raevel: okay, so it needs to be certain here that the type of value being demanded is [[Frac]] in order to use the instance
15:42:48 <evident> and that means?
15:42:57 <opqdonut> it's used for showing stuff with different precedences
15:43:04 <opqdonut> it handles parenthesis and stuff
15:43:30 <opqdonut> the first arg is a precedence, the second a showable thing and the third a prefix string
15:43:37 <athos> @src cycle
15:43:38 <lambdabot> cycle [] = undefined
15:43:38 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:43:54 <evident> aha... and why exactly is it used in used in Show-instances?
15:43:57 <Cale> Raevel: In order for that to be the case, you need to either apply a function of type [[Frac]] -> X (for some type X) to the result of unpack, or you need to give an explicit type signature somewhere.
15:44:28 <dons> wli: well the snow is forecast tongith, so i wouldn't rush :)
15:44:31 <evident> trying to undestand this one:
15:44:32 <evident> instance (Show a) => Show (Set a) where
15:44:32 <evident> 	showsPrec _ (St s) str = showSet s str
15:45:07 <Cale> evident: show can be defined in terms of showsPrec better than showsPrec can be defined in terms of show. However, it is valid just to define show. The default implementation of showsPrec ignores the precedence parameter
15:46:12 <Cale> evident: It's also slightly more efficient to use shows/showsPrec when you would otherwise be concatenating a lot of strings.
15:46:31 <evident> ahh... slowly it begins to make sense...
15:46:32 <evident> thx
15:46:56 <redditbot> Data.List.split: provide your ideas and implementations, and maybe we'll get it!
15:46:57 <Cale> evident: However, in this case, there wouldn't be a lot of difference between defining show and what they did.
15:47:35 <RayNbow> hmm, odd...
15:47:42 <RayNbow> > let nfibs n = let r = replicate (n-1) 0 ++ 1 : 1 : zipWith ((-).(2*)) (drop n r) r in r in nfibs 2  -- this is correct and works here in GHCi
15:47:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:48:05 <RayNbow> > let nfibs n = let r = replicate (n-1) 0 ++ 1 : zipWith ((-).(2*)) (drop n r) r in r in nfibs 2  -- but when I omit a 1 "by accident", my ghci dies
15:48:20 <lambdabot>   thread killed
15:48:27 <RayNbow> (well, it dies after outputting "[0,1")
15:49:10 <Raevel> Cale: is this because there could be multiple instance definitions for Pack X Matrix?
15:49:24 <b_jonas> um
15:49:48 <b_jonas> what does the argument of the tycon Text.XML.HaXml.Element do?
15:51:04 <Megzlna> Why does foldr use (\x acc -> ...)  ?
15:51:30 <Megzlna> rather than        (\acc x -> ...)
15:51:33 <vixey> @src foldr
15:51:34 <lambdabot> foldr f z []     = z
15:51:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:51:51 <Megzlna> vixey: Why, not What
15:52:01 <vixey> Megzlna, foldr cons nil (x : (y : (z : []))) ~~> (cons x (cons y (cons z nil)))
15:52:17 <vixey> foldl is the one that use an accumulator
15:53:35 <Megzlna> @src cons
15:53:35 <lambdabot> Source not found.
15:54:09 <RayNbow> (:) is pronounced as cons
15:54:15 <Megzlna> Well, it would still work the same if foldr took  (\x acc -> ...)
15:54:39 <ozy`> @src cons
15:54:39 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:54:46 <ozy`> @let cons = (:)
15:54:47 <lambdabot>  Defined.
15:55:06 <RayNbow> @let nil = []
15:55:07 <lambdabot>  Defined.
15:55:12 <RayNbow> > foldr cons nil (x : (y : (z : [])))
15:55:13 <lambdabot>   [x,y,z]
15:56:29 <b_jonas> ah, I see
15:56:44 <b_jonas> it allows you to add tags to each atom in the xml
15:56:51 <b_jonas> parser uses that for location infromation
15:56:53 <b_jonas> funny
15:57:10 <ozy`> @src (?)
15:57:10 <lambdabot> Source not found. Take a stress pill and think things over.
15:57:19 <ozy`> @let (?) = ($)
15:57:20 <lambdabot>  Defined.
15:57:33 <lucca> what exactly are you trying to do
15:57:57 <ozy`> @let car = head
15:57:58 <lambdabot>  Defined.
15:58:01 <lucca> :t foldr (:) []
15:58:02 <lambdabot> forall a. [a] -> [a]
15:58:06 <ozy`> @let cdr = tail
15:58:07 <lambdabot>  Defined.
15:58:33 <lucca> foldr (:) [] is like id
15:58:54 <lucca> for lists, though
15:59:13 <MyCatVerbs> lucca: except that it consumes a bit more CPU time =)
15:59:17 <opqdonut> > take 3 $foldr (:) [] $ 1:2:3:undefined
15:59:19 <lambdabot>   Not in scope: `$�'
15:59:25 <opqdonut> > take 3 $ foldr (:) [] $ 1:2:3:undefined
15:59:27 <lambdabot>   [1,2,3]
15:59:49 <MyCatVerbs> lucca: and could, occasionally, be used to reduce sharing.
15:59:59 <lucca> MyCatVerbs: hence my confusion about what is being attempted here
16:00:36 <ozy`> > let pizza x = if null? x then nil else cdr x in pizza "etc."
16:00:38 <lambdabot>   "tc."
16:01:31 <lucca> is there a more general sharing reducer?
16:02:07 <lucca> i.e. something like id that deepcopies lists and tuples and other stuffs
16:02:30 <lucca> and is that sort of thing useful very often?
16:03:07 <b_jonas> night
16:04:07 <ozy`> I'm sure it's not needed all that often... but when you do need it, it'd be a huge pain to have to wrestle with
16:07:47 <Elly> w 2
16:07:49 <Elly> oops
16:10:38 <ozy`> http://www.scriptol.org/choose.php <== I like how they consistently misspell "ocalm" and label all newer languages as educational
16:11:29 <mauke> Perl - A scripting interpreted language. Readabillity and ease of use are not the goal.
16:11:40 <mauke> I'd strongly disagree about the "ease of use" part
16:11:58 <opqdonut> lol, scriptol
16:12:01 <ozy`> and some people find perl the most readable language
16:12:06 <lucca> looks biased and in need of editing
16:12:10 <opqdonut> BooThis is a new version of Python with some new features. It runs on .Net and Mono and thus, no compatibility problem.
16:12:13 <opqdonut> okay, horrible
16:16:13 <mmorrow> lucca: why would you want to /reduce/ sharing?
16:17:09 <mmorrow> (one way is to inline everything by hand and never use let or where ;)
16:18:17 <mmorrow> yeah, i don't see why reducing sharing would be helpful. if anything, it'd be harmful (for memory use and efficiency)
16:18:31 <lucca> mmorrow: in general, I wouldn't, but there are a few cases where it is very useful
16:18:39 <evident> does anyone know what this error means? http://hpaste.org/13054
16:18:43 <mmorrow> lucca: interesting. what are they?
16:19:09 <lucca> for example if you have large data structures, but only a small portion of them is now going to be reached
16:19:21 <mauke> evident: yes, it means remDuplicates requires set elements to be comparable with (==)
16:19:27 <evident> all i did was adding the remDuplicates function (which is equivalent to nub)
16:19:40 <mmorrow> lucca: hmm, i don't understand.
16:19:48 <mauke> evident: but your instance declaration says you can show every Set whose elements support show
16:19:56 <lucca> take a hypothetical array implementation
16:19:58 <evident> ahh ok
16:20:06 <mmorrow> lucca: ok
16:20:42 <lucca> and say you have a 2D array of numbers, 1000x1000, and have finished using most of it, but wish to use a small part of it for some other thing
16:20:55 <lucca> taking subsets of these things in a sharing way is easy
16:21:06 <evident> well, but:
16:21:07 <evident> data Set a = St [a]
16:21:08 <evident>    deriving Eq
16:21:15 <lucca> but then both the large array and the small array, say 10x10... both point to the same target structure internally
16:21:30 <evident> doesnt that mean that Set elements have to be comparable with (==)
16:21:31 <evident> ?
16:21:38 <mauke> evident: no
16:21:45 <lucca> unless the gc has deeper knowledge of what the higher level structures are doing, you'd gain from copying the smaller array out to reduce sharing
16:21:52 <evident> hmmm
16:21:55 <mauke> evident: that just means Set itself can be compared if their elements can be
16:22:08 <evident> ahh ok
16:22:15 <lucca> mmorrow: in a real world example...
16:22:18 <mmorrow> lucca: suppose [0]..[998] are shared. then that array's memory usage is that of two of its contained values
16:22:19 <hasenov> hello, is there on hackage a good implementation of finding factors of a number?
16:22:24 <wli> That's part of the block matrix stuff I'm trying to do.
16:22:54 <evident> so how can i add that elements must be comparable with (==)? Or am i going a completely wrong way?
16:23:01 <wli> hasenov: I've not seen such in hackage but in un-cabalized libraries there are some quite sophisticated algorithms.
16:23:09 <lucca> see Data.ByteString.copy
16:23:11 <mauke> evident: instance (Show a, Eq a) => Show (Set a) ...
16:23:35 <mmorrow> lucca: but that's copying the mallocForeignPtrs memory
16:23:44 <lucca> and the difference is?
16:23:49 <evident> ahh now i understand... thx...
16:24:08 <dons> lucca: relevant, http://www.haskell.org/pipermail/haskell-cafe/2008-December/051795.html
16:24:09 <evident> slowly I am getting how all that stuff works
16:24:10 <evident> :)
16:24:21 <Axman6> evident: you might also want Ord instead, depending on what you're trying to do
16:24:31 <mmorrow> lucca: that's doubling your memory use
16:24:41 <mmorrow> err, i don't mean total use
16:24:53 <mmorrow> that's duplicating the memory used for that value
16:25:04 <mmorrow> i might not understand what you're getting at
16:25:07 <lucca> hmmm
16:25:14 <lucca> dons: interesting!
16:25:17 <evident> well the task is to change the instance of Show so that duplicates are removed
16:25:25 <centrinia> mmorrow: Isn't O(2*n) the same as O(n) ?
16:25:28 <evident> it works now...
16:25:48 <evident> when would I need Ord?
16:25:55 <evident> Axman6
16:26:14 <lucca> mmorrow: the idea is given a gc that understands some simple type of structure, and only whether the whole thing is reachable or not, copying makes sense if you can help the gc collect things that Aren't really reachable
16:26:21 <lucca> doesn't seem useful in GHC at this point
16:26:39 <Axman6> if you want to not only test for equality. if you just need (==) then you don't need Ord
16:26:53 <ozy`> Axman6: hey, you on PPC?
16:27:07 <Axman6> nope, but i have a few around, why?
16:27:20 <ozy`> can't get 6.10 to build
16:27:20 <evident> ahh ok
16:27:31 <mmorrow> oh, i see what you're saying. so in your array example, you were assuming the array as a whole was either going to be collected or not at all by the gc
16:27:33 <Axman6> ozy`: MACPORTS?
16:27:37 <Axman6> uh, no caps
16:27:54 <ozy`> Axman6: and building from source myself
16:28:10 <Axman6> hmm, no idea. get any errors?
16:28:13 <ozy`> and if I try to build cabal with a binary install, it nukes the linker
16:28:19 <ozy`> lots of errors
16:28:26 <mmorrow> <centrinia> mmorrow: Isn't O(2*n) the same as O(n) ?
16:28:32 <ozy`> it usually barfs very quietly during bootstrapping
16:28:35 <mmorrow> centrinia: was that @me?
16:28:54 <ozy`> the errors are all usually like "Error"
16:28:55 <centrinia> Yes, you are talking about doubling memory use. ;)
16:28:58 <lucca> mmorrow: right.
16:29:11 <hasenov> wli: do u mean something like http://www.polyomino.f2s.com/david/haskell/articles.html?
16:29:13 <mmorrow> centrinia: sure, O(100000*n) == O(n) too
16:29:18 <Axman6> ozy`: what about the binaries? are there PPC versions?
16:29:20 <centrinia> Okay. :)
16:29:24 <mmorrow> :)
16:30:00 <ozy`> Axman6: yeah. that's what I tried first, since I didn't trust macports (all the PPC users on their end are still on 10.4)
16:30:07 <ozy`> (or, nearly all)
16:30:17 <Axman6> yeah fair enough
16:30:38 <centrinia> I thought Mac OS 10.5 didn't run on PowerPC processors that are not G5s.
16:30:51 <Axman6> or G4's
16:30:56 <wli> hasenov: Yes, although his factoring stuff is at http://www.polyomino.f2s.com/david/haskell/codeindex.html
16:31:19 <Axman6> needs altivec. and i think G4's need to be >650MHz or something
16:31:43 <wli> http://www.polyomino.f2s.com/david/haskell/hs/FactoringECM.hs.txt <-- especially this
16:31:53 * gwern runs into my old foe - equality between IO String and String
16:32:06 <ozy`> centrinia: the differences between the G4 and G5 (apart from bit width) are chiefly in terms of implementation, not interface
16:32:18 <gwern> @hoogle IO Bool
16:32:19 <lambdabot> Did you mean: :: IO Bool /count=20
16:32:19 <lambdabot> No results found
16:33:17 <mauke> http://dis.4chan.org/read/prog/1221358859/636
16:33:19 <hasenov> wli: yes, im trying it right now but I have an error stating that there is a non-exhaustive patterns in function
16:33:20 <Axman6> gwern: io >>= (return.(==str))?
16:33:40 <gwern> Axman6: man, I don't even understand that
16:33:54 <Axman6> that'll return an IO Bool
16:34:07 <gwern> if-then-else isn't happy with an IO Bool
16:34:35 <mauke> gwern: er, huh? how do you want to compare e.g. getLine and "hello"?
16:34:38 <Axman6> well you need to use a do expression or something
16:34:47 <centrinia> Why not  m >>= (\b -> if b then foo else bar)
16:35:16 <gwern> mauke: I'm doing some yi hacking. I call runShellCommand on 'hoogle foo', and if hoogle doesn't have any hits, it returns IO ["No results found"]
16:35:24 <eu-prleu-peupeu> what do you have to say about this: http://imonad.com/blog/2008/06/gpu-programming-in-haskell/ ?
16:35:27 <gwern> obviously I want to error out or something in that case
16:35:28 <ozy`> mauke: "It's lisp, paul graham, lisp, paul graham, all the way down." <== lulz
16:35:29 <centrinia> Wait, what does it mean to compare functions?
16:35:39 * wli puts more Newton stuff up for centrinia.
16:35:53 <wli> centrinia: Extensional vs. intensional equality.
16:36:33 <wli> centrinia: Essentially comparing the function results on inputs vs. comparing the function's code.
16:37:19 <Axman6> gwern: do s <- runShellCommand "hoogle foo"; if s == ["No results found"] then error "no retults" else return s?
16:37:20 <centrinia> Can't you show extensional equality of functions (Bool -> Bool) with 16 tests?
16:37:39 <hasenov> another thing is that they return only one number, a non-trivial factor, im not sure which one if there are multiple factors
16:37:39 <centrinia> Or 2 tests. :p
16:37:45 <wli> centrinia: Sure.
16:38:05 <wli> centrinia: Provided the functions are total, anyway.
16:38:22 <gwern> Axman6: wouldn't s be IO a, and so not comprable?
16:38:46 <Axman6> gwern: no, if get
16:39:14 <Axman6> gwern: no, if getIOThing :: IO a, then s::a in s <- getIOThing*
16:39:47 <wli> centrinia: You get into trouble when nontermination is possible.
16:41:13 <gwern> hm. when did ghci start supporting partially applied functions as results?
16:41:57 <centrinia> gwern: How do you show a partially applied function?
16:42:25 <gwern> '<function>', apparently
16:42:57 <wli> liftM2 (==) :: (Eq t, Monad m) => m t -> m t -> m Bool works just fine to compare things, in a sense.
16:42:59 <hoopy> if i want ghci on debian i'm going to have to compile from source, aren't i?
16:43:26 <gwern> hoopy: no, the percompiled ghc binaries should work fine
16:43:29 <Axman6> wli: in gwern's case, the second thing isn't an IO String
16:43:32 <gwern> at least, they did for me on ubuntu
16:43:33 <centrinia> Wait, do all partially applied functions have a corresponding Haskell expression?
16:43:44 <hoopy> when i type ghci it complains that it wasn't compiled to run interactively
16:43:58 <gwern> centrinia: I just noticed it when I tried to evaluate '(+1)'
16:44:28 <centrinia> Weird.
16:44:39 <gwern> funky - 'Data.Array.Base bOOL_WORD_SCALE :: Int# -> Int#
16:44:52 <Raevel> @pl (\(c, d) -> (negate c, d))
16:44:53 <lambdabot> first negate
16:44:56 <Raevel> :-)))))
16:45:06 <Raevel> @type first
16:45:07 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:45:16 <Axman6> :t first
16:45:17 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:45:19 <Axman6> whoops
16:45:36 <Axman6> :t first negate
16:45:36 <mmorrow> first f (a,b) = (f a,b)
16:45:37 <lambdabot> forall a d. (Num a) => (a, d) -> (a, d)
16:45:50 <centrinia> Is there a Prelude function that does what (\t a b -> if t then a else b) does?
16:45:53 <wli> Axman6: fmap . (==) :: (Eq t, Functor f) => t -> f t -> f Bool
16:46:01 <mauke> centrinia: no
16:46:09 <centrinia> Why not? :(
16:46:19 <Axman6> wli: sounds ok to me
16:46:19 <dons> hoopy: nope. ghc is all over debian.
16:46:25 <Raevel> centrinia: no, but if' t a b = if t then a else b
16:46:26 <dons> hoopy: the ghc6 package
16:46:56 <Axman6> > if' True 1 2
16:46:57 <lambdabot>   Not in scope: `if''
16:47:06 <Axman6> bleh, it's in Data.Bool right?
16:47:49 <Raevel> Axman6: doesn't look like it
16:49:25 <wli> print =<< (fmap . (==)) "hello" getLine -- seems to work here
16:49:43 <hoopy> dons: i have the ghc6 package installed
16:50:25 <mmorrow> or just        print . (=="hello") =<< getLine
16:50:37 <wli> I'm still miffed that map got renamed to fmap.
16:50:58 <mmorrow> i wish (++) was mappend
16:51:10 <mmorrow> (and that map was fmap)
16:51:11 <jsn> i'm looking for examples for the ST monad
16:51:22 <wli> mmorrow: fmap . (==) is by itself the comparator desired; the arguments are separated for clarity.
16:51:32 <dons> hoopy: you're set then. fire up ghci
16:51:43 <gwern> > take 1 "foo"
16:51:43 <mmorrow> wli: ah, i see what you were going for :)
16:51:44 <lambdabot>   "f"
16:52:16 <hoopy> dons: no, i've always had that package installed and it has always said it wasn't built to run interactively
16:52:22 <jsn> specifically, what's an example of the sort of thing that the second forall in    runST :: forall a . (forall s . ST s a) -> a   is used to prevent?
16:55:09 <hoopy> ghc-6.8.2: not built for interactive use
16:55:18 <wli> mmorrow: (++) used to be what's now called mplus :: MonadPlus m => m t -> m t -> m t
16:55:54 <wli> mmorrow: With the exception that MonadPlus didn't have mzero in it; there was a separate Monad0 for that.
16:56:45 <mmorrow> wli: hmm. it seems though that every MonadPlus (assuming mzero) can be made a Monoid though, thus enabling (++) to be used for mplus, but not vice-versa. so if (++) was mappend you could use it for more stuff
16:56:50 <idnar> I thought (++) was mappend
16:56:52 <wli> mmorrow: Incomplete pattern matches implicitly generated zero :: Monad0 m => m t (now called mzero) upon pattern match failure.
16:57:16 <mmorrow> wli: ah yeah, i just learned that the other day reading #haskell logs :)
16:57:27 <wli> mmorrow: Monad comprehensions were brilliant.
16:58:04 <mmorrow> ooh, i have kinda monad comprehensions (but that need MonadPlus)
16:58:41 <Axman6> > mappend [1,2,3] [4,5,6]
16:58:43 <lambdabot>   [1,2,3,4,5,6]
16:58:51 <wli> Well, they were syntactical constructs more than linguistic.
16:59:07 <centrinia> Why not define (++) = mappend ?
16:59:24 <mmorrow> , flip runState (0,1) [$mc| [ m | (m,n) <- get, put (n,m+n)] |]
16:59:26 <lunabot>  luna: Not in scope: `mc'
16:59:28 <Axman6> @src [] mappend
16:59:29 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:59:32 <mmorrow> , flip runState (0,1) [$mc| [ m | (m,n) <- get, () <- put (n,m+n)] |]
16:59:34 <lunabot>  luna: Not in scope: `mc'
16:59:40 <mmorrow> oh, i must've commented it out. one sec
17:00:32 <wli> List comprehension syntax used to be generalized  in such a manner that instead of lists you got any monad satisfying particular constraints (Monad0 IIRC, but maybe also MonadPlus).
17:01:35 <jeffwheeler> > unlines . map (head . words) . lines $ "abc def\nghi jkl" -- this is why Haskell is beautiful
17:01:37 <lambdabot>   "abc\nghi\n"
17:02:30 <mmorrow> , flip runState (0,1) [$mc| [ m | (m,n) <- get, () <- put (n,m+n)] |]
17:02:35 <lunabot>  luna: Exception when trying to run compile-time code:
17:02:38 <mmorrow> grr
17:02:45 <jeffwheeler> I quite like writing Python to look like Haskell; it's surprisingly possible.
17:03:05 <Badger> hah
17:03:31 <wli> What would be dreamy would be to undo a bunch of the Haskell 98 mistakes.
17:03:49 <jeffwheeler> Isn't that Haskell'?
17:03:51 <wli> Basically all centered around the Prelude and supporting compiler intrinsics.
17:03:58 <mmorrow> , elimCompQ "[ m | (m,n) <- get, () <- put (n,m+n)]"
17:04:03 <lunabot>  luna: Ambiguous occurrence `get'
17:04:06 <wli> jeffwheeler: No. Haskell' standardizes things that have already happened AIUI.
17:04:08 <mmorrow> ahh, the culprit
17:04:31 <jeffwheeler> wli: hmm, okay; I didn't know that.
17:04:47 <ozy`> wli: time for a new language altogether?
17:05:14 <mmorrow> , ppDoc `fmap` elimCompQ "[ m | (m,n) <- get, () <- put (n,m+n)]"
17:05:14 <wli> ozy`: Changing the Prelude and how various bits of syntax desugar is not quite enough for that.
17:05:19 <lunabot>  do (m_0, n_1) <- get
17:05:19 <lunabot>     () <- put (n_1, m_0 + n_1)
17:05:19 <lunabot>     return m_0
17:05:22 <mmorrow> hehe
17:05:25 <mmorrow> , flip runState (0,1) [$mc| [ m | (m,n) <- get, () <- put (n,m+n)] |]
17:05:30 <lunabot>  (0,(1,1))
17:05:38 <mmorrow> QuasiQuotes++
17:05:54 <wli> ozy`: It would more properly be called an alternate Prelude (and while we're at it, we might as well throw the Numeric Prelude into the mix.)
17:06:04 <ozy`> wli: well there's also the question of dependent types, parallelism, etc.
17:06:33 <wli> ozy`: Those things are way beyond the scope of what I'm on about.
17:06:38 * mmorrow wishes there was a way for a type to legitimately depend on a value in haskell (at least ghc haskell)
17:07:02 <wli> I forget if Cayenne is still maintained.
17:07:14 <mmorrow> wli: it very much works though :)
17:08:20 <wli> It doesn't look like Cayenne is still alive.
17:08:21 <mmorrow> , flip runState (0,1) (replicateM 10 [$mc|[ m|(m,n) <- get,() <- put (n,m+n)]|])
17:08:26 <lunabot>  ([0,1,1,2,3,5,8,13,21,34],(55,89))
17:08:39 <mmorrow> wli: yeah, it's not maintained or worked on (as far as i know)
17:09:02 <GNUlicious> @bot
17:09:02 <lunabot>  :)
17:09:02 <lambdabot> :)
17:09:10 <wli> The webpage suggests one look at Agda.
17:09:16 * mmorrow wants a /turing complete/ dependently typed lang
17:09:32 <augustss> mmorrow: like Cayenne :)
17:09:35 <sbahra> Hey mmorrow
17:09:39 <mmorrow> augustss: totally!
17:09:48 <mmorrow> sbahra: hey sbahra
17:09:50 <augustss> But Turing completeness is overrated
17:10:02 <centrinia> How so?
17:10:15 <mmorrow> augustss: hmm, it seems to me not being turing complete would be limiting?
17:11:10 <mmorrow> (limiting if you wanted to use it for "\"real\"" programming tasks)
17:11:15 <augustss> Yeah, but not in a really bad way.
17:11:54 <centrinia> Well, context sensitive languages are not Turing complete and they are capable of plenty. ;)
17:12:09 <mmorrow> hmm. what if you wanted to write an interpreter for that lang in the lang? i've heard this be called impossible.
17:12:24 <mmorrow> (but i'm not clear as to exactly why)
17:13:14 <Saizan_> mmorrow: balme goedel
17:13:18 <Saizan_> *blame
17:13:24 <mmorrow> Saizan_: curses!
17:13:31 <GNUlicious> I don't think a linear bound automaton is very different from a turing machine on finite hardware
17:14:01 <augustss> mmorrow: Well, it's impossible.  But you can make an interpreter that uses at most, e.g., 10^100 steps.
17:14:30 <mmorrow> augustss: ohhh. i see what "impossible" means now.
17:14:35 <wli> Finite hardware is even more limited than a linear-bounded automaton. It's essentially a FSM.
17:15:32 <augustss> mmorrow: also with codata you could imagine something that produces some kind of tick for every step it makes, and it can make an unbounded number of steps.
17:15:43 <GNUlicious> uh, I don't think so, expressiveness wise.
17:16:02 <augustss> mmorrow: But actually, non-termination is fine if confined to some monad, just like IO is in Haskell.
17:16:18 <jtootf> hi everybody; I'm having problems installing Reactive prerequisites, maybe someone already faced these ones. In libraries MemoTrie and TypeCompose I get an error "unknown flags in {-# OPTIONS #-} pragma -fenable-rewrite-rules" (GHC 6.8.2, MemoTrie 0.4.1, TypeCompose 0.6.3)
17:16:46 <jtootf> never used this pragma and cannot find any usable information regarding in in the net :(
17:17:41 <mmorrow> augustss: interesting. someone in here said the other day "totality is going to be the next purity", so you're saying it would be analogous to mutating stuff (or whatever) in haskell
17:17:58 <augustss> mmorrow: yes, indeed.
17:18:13 <mmorrow> i can deal with that
17:19:54 <Saizan_> yeah, haskell has only one implicit effect, non-termination
17:21:12 <wli> Pattern match failure?
17:21:28 <augustss> Saizan_: you can debate if it's effect or not.  But i'd like to see bottom banned. :)
17:21:58 <wli> Arithmetic exceptions (e.g. divide by 0)?
17:22:31 <augustss> mmorrow: also, if you've tried Agda you'll see that the totality checker is quite good.  Lots of normal Haskell code passes.
17:22:32 <centrinia> I thought that banning bottom would not give totality and enforcing totality would not remove bottom.
17:22:39 <augustss> wii: Banned!
17:22:45 <wli> Abnormal termination is a distinct implicit effect from nontermination.
17:22:46 <centrinia> Wii? :O
17:22:55 <mmorrow> augustss: i haven't tried Agda, but i've been meaning to.
17:23:07 <augustss> wii: No more exceptions.
17:23:12 <Saizan_> wli: those are usually lumped together with non-termination, since without compiler support you can only define error s = error s
17:23:17 <MyCatVerbs> What's the backend for Agda compilation, anyway?
17:23:35 <augustss> MyCatVerbs: Haskell
17:23:51 <mmorrow> wli: 1/0 is just Infinity (and an fpu exception ignored by haskell)
17:23:54 <MyCatVerbs> Ah, handy. *ponders*
17:24:04 <MyCatVerbs> Is the code it outputs monomorphic? :)
17:24:31 <Saizan_> Agda's ffi is haskell :)
17:24:40 <augustss> MyCatVerbs: it's full of unsafeCasts :)
17:24:45 <centrinia> augustss: What about (repeat 1) ?
17:25:02 <augustss> centrinia: that would be ok for codata
17:25:13 <jtootf> guys, can anyone answer my question about -fenable-rewrite-rules pragma? please :)
17:25:18 <centrinia> What about sum (repeat 1)?
17:25:22 <MyCatVerbs> augustss: eek.
17:25:26 <sjanssen> jtootf: what is the question?
17:25:34 <augustss> centrinia: that would be an error :)
17:25:40 <mmorrow> MyCatVerbs: from what i understand, as long as you use Any instead of forall a.a, unsafeCoerce is fine (assuming you're correct)
17:25:45 <jtootf> In libraries MemoTrie and TypeCompose I get an error "unknown flags in {-# OPTIONS #-} pragma -fenable-rewrite-rules" (GHC 6.8.2, MemoTrie 0.4.1, TypeCompose 0.6.3)
17:25:45 <jtootf> <jtootf> never used this pragma and cannot find any usable information regarding in in the net
17:25:55 <jtootf> this one
17:26:06 <sjanssen> jtootf: you can safely remove that
17:26:16 <augustss> jtootf: You can remove the flag, it will just be slower
17:26:26 <sjanssen> augustss: nah, Cabal compiles with -O nowadays
17:26:32 <jtootf> sjanssen: oh, thank you, that's clear
17:26:51 <augustss> Ah
17:27:03 <MyCatVerbs> mmorrow: I'm not even aware of what the issue is. :)
17:27:08 <sjanssen> jtootf: you should also tell the author of the package that -fenable-rewrite-rules is incompatible with GHC 6.8, and that it is automatically turned on with -O, which Cabal uses
17:27:20 <centrinia> Can one let 1=2?
17:27:23 <gwern> suppose I have two IO [String] - should 'liftM zip $ modules functions' work?
17:27:36 <sjanssen> @seen conal
17:27:36 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 2h 36m 19s ago.
17:27:55 <gwern> (it doesn't seem to for me, which makes me wonder what I'm doing wrong)
17:28:02 <Badger> ?seen Twey
17:28:02 <lambdabot> I saw Twey leaving #haskell 8d 5h 46m 25s ago, and .
17:28:08 <Badger> :(
17:28:15 <sjanssen> gwern: liftM lifts functions of arity 1, zip is of arity 2
17:28:17 <Badger> ?seen Twey_
17:28:18 <lambdabot> I saw Twey_ leaving #haskell 2m 7d 14h 2m 22s ago, and .
17:28:23 <augustss> liftM2
17:28:24 <sjanssen> gwern: ie. use liftM2
17:28:24 <gwern> no wait, it does. dammit Yi.Prelude!
17:28:44 <jtootf> sjanssen: another question if you don't mind; package unamb fails with the dependency on package base >= 4, cannot find even the version of the current base package :( GHC 6.8.2, I have 6.10 installed, but haven't switched on it yet
17:28:46 <sjanssen> Yi has its own Prelude, where liftM = liftM2?
17:28:47 <sjanssen> absurd
17:29:17 <sjanssen> jtootf: 6.8 comes with base 3, you can't use base 4 with it
17:29:22 <mmorrow> MyCatVerbs: http://haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html#t%3AAny
17:29:42 <jtootf> sjanssen: so I have to use GHC >= 6.10?
17:29:43 <gwern> yi must be doing something, as Prelude.zip fixes the issue
17:30:02 <sjanssen> jtootf: perhaps.  Or there might be an old version of unamb which is compatible?
17:30:16 <jtootf> sjanssen: I see, thank you much
17:30:18 <sjanssen> gwern: ah, so Yi has its own zip?  Scary.
17:30:41 <MyCatVerbs> mmorrow: interesting. Is that new?
17:31:39 <gwern> sjanssen: unless someone else is redfinig zip, I can't imagine whose fault it could be but yi's
17:31:47 <mmorrow> MyCatVerbs: the issue or the type Any? i don't think either is, but i may be wrong.
17:32:32 <mmorrow> i think the part(s) about ghc's execution model that make it necessary have been that way for a while
17:33:30 <mmorrow> gwern: doesn't Yi have Yi.Prelude which re-exports a bunch of Prelude functions? i think that might be your problem
17:33:34 <MyCatVerbs> mmorrow: I need to avoid looking at GHC.*.
17:33:49 <mmorrow> MyCatVerbs: dataToTag# is a fun one
17:33:51 <MyCatVerbs> mmorrow: the more I look into those areas of the libraries, the more I'm tempted to start using them. :)
17:33:56 <gwern> mmorrow: yes it does, I mentioned it before
17:34:21 <sheyll> hi can I export all stuff in a module without explicitly listing everything?
17:34:30 <mmorrow> gwern: ah, just scrolled back ;)
17:35:32 <dons> sheyll: leave off any export list
17:35:34 <dons> module M where
17:35:38 <Axman6> sheyll: just use module MyModule where
17:35:45 <sheyll> dons, thank you.
17:36:21 <orbitz> @pl \x y -> x + snd y
17:36:22 <lambdabot> (. snd) . (+)
17:40:58 <DrSyzygy> @type \o -> look at my muscles
17:40:58 <lambdabot> Not in scope: `look'
17:40:58 <lambdabot> Not in scope: `at'
17:40:58 <lambdabot> Not in scope: `my'
17:41:02 <DrSyzygy> Nope.
17:41:47 <Raevel> i have the perhaps-not-so-greatly-named function joinFork fork f f' v = (f v) `fork` (f' v), which i would like to generalize to let f and f' take multiple arguments, but am i right in thinking it isn't possible?
17:42:55 <ozy`> Axman6: http://pastie.org/338608
17:43:30 <augustss> Raevel: not without overloading
17:43:49 <Axman6> ozy`: that's odd indeed, tried googling the errors?
17:44:07 <olsner> @ty ($ ?v $ ?u)
17:44:08 <lambdabot> forall b a b1. (?u::a, ?v::a -> b1) => (b1 -> b) -> b
17:44:12 <Raevel> augustss: there's overloading? anywhere i can read about it?
17:44:31 <augustss> Raevel: class & instance
17:44:38 <ozy`> Axman6: tried and found nothing useful so far
17:44:43 <Raevel> augustss: oh.
17:44:44 <Axman6> :\
17:45:44 <Axman6> ozy`: could try #ghc maybe
17:45:51 <Raevel> should i make a class, or am i better off defining joinFork2..joinForkN? (doubt i'll ever need N>2)
17:46:15 <Axman6> brb
17:46:51 <olsner> if you only have to write joinFork2, that does sound like slightly less work than making a typeclass
17:46:57 <augustss> Raevel: unless you're going to use it a lot, I'd say just go for 2..N
17:47:03 <Axman6> man, i love having launchd start up irssi in screen for me
17:47:23 <Raevel> fair enough, thanks!
17:47:52 <ozy`> Axman6: ah, I'll have to go there when I return.... gotta leave for now
17:47:53 <ozy`> thankss
17:48:01 <Raevel> i'm making this one function pointless, it'll probably be twice as long, but hey, at least it's fun
17:48:39 <Axman6> Raevel: the correct term is pointfree, but pointless is a very good way of describing it
17:49:15 <olsner> Raevel: isn't it just liftM2 fork f f'? :P
17:49:32 <Raevel> i hope not!
17:49:59 <olsner> @ty \f f' v -> liftM2 ?fork f f' v
17:50:00 <lambdabot> forall t a1 a2 r. (Monad ((->) t), ?fork::a1 -> a2 -> r) => (t -> a1) -> (t -> a2) -> t -> r
17:50:20 <Raevel> :-s i can't tell if that's correct
17:50:39 <mmorrow> that doesn't solve your problem with giving f,f' multiple args though
17:50:41 <idnar> @unpl liftM2 fork
17:50:42 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (fork b a))
17:50:54 <idnar> doh, that won't work
17:51:08 <Raevel> @type fork
17:51:09 <lambdabot> Not in scope: `fork'
17:51:27 <Raevel> hah, i'm getting tired it seems
17:51:57 <sabren> hmm.. is there a way to load a module using a qualified name in GHCi?
17:52:17 <augustss> @pl joinFork fork f f' v = (f v) `fork` (f' v)
17:52:17 <lambdabot> joinFork = liftM2
17:52:45 <mbz_> ?t fork
17:52:45 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:52:49 <mbz_> ?typ fork
17:52:50 <lambdabot> Not in scope: `fork'
17:52:57 <augustss> @pl joinFork fork f f' v w = (f v w) `fork` (f' v w)
17:52:58 <lambdabot> joinFork = (liftM2 ap .) . (.) . (.)
17:53:11 <Raevel> augustss: haha no way :-(
17:53:34 <augustss> Raevel: trust the bot :)
17:53:48 <Raevel> lambdabot has indeed been more helpful than usual today
17:54:21 <augustss> Raevel: but joinFork2 seems trickier :)
17:54:41 <Raevel> hmm, what about what olsner said?
17:55:15 <olsner> Raevel: what I said was basically "joinFork = liftM2"
17:55:24 <Raevel> oh, right
17:56:00 <Raevel> at least i *know* what liftM2 does in this instance now
17:56:54 <Raevel> @pl curry . join (***)
17:56:54 <lambdabot> curry . join (***)
17:57:19 <augustss> :t curry . join (***)
17:57:21 <lambdabot> forall b c. (b -> c) -> b -> b -> (c, c)
17:57:35 <augustss> @djinn (b -> c) -> b -> b -> (c, c)
17:57:36 <lambdabot> f a b _ = (a b, a b)
17:57:50 <augustss> bah!
17:58:09 <Raevel> an extra argument?
17:58:24 <augustss> djinn needs a bigger search depth
17:58:26 <olsner> @ty \fork f f' v u -> on fork (flip ($ v) u) f f' -- if you don't mind unreadability
17:58:27 <lambdabot> forall c a b c1. (c1 -> c1 -> c) -> (a -> b -> c1) -> (a -> b -> c1) -> a -> b -> c
17:58:39 <Raevel> oh wait. n/m
17:58:55 <augustss> @djinn (c1 -> c1 -> c) -> (a -> b -> c1) -> (a -> b -> c1) -> a -> b -> c
17:58:55 <lambdabot> f a b c d e = a (b d e) (c d e)
17:59:22 <Raevel> i somehow prefer djinn's version :-P
17:59:49 <augustss> But it's not as pointless :)
18:00:09 <Raevel> i guess you have a point
18:00:22 <augustss> well, maybe it is, actually
18:00:33 <augustss> it's not as cryptic
18:01:11 <augustss> :t flip flip flip
18:01:12 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
18:01:27 <augustss> :t flip flip flip flip
18:01:28 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
18:02:27 <Olathe> :t bork bork bork
18:02:28 <lambdabot> Not in scope: `bork'
18:02:28 <lambdabot> Not in scope: `bork'
18:02:28 <lambdabot> Not in scope: `bork'
18:06:29 <Axman6> @unpl flip flip flip flip a b c d
18:06:30 <lambdabot> a b (\ k l m -> k m l) c d
18:07:38 <jakra> Hi, how can I read an int?  readLine of course expects [Char], I need to read to an Int, however
18:07:38 <augustss> @unpl flip flip flip flip flip a b c d
18:07:38 <lambdabot> a b (\ k l m -> k m l) c d
18:08:16 <blando> > read "1" :: Int
18:08:17 <lambdabot>   1
18:08:28 <jakra> blando: via IO?
18:08:51 <Olathe> > read "1" :: String
18:08:52 <augustss> jakra: readline >>= readIO
18:08:53 <lambdabot>   "* Exception: Prelude.read: no parse
18:09:06 <Olathe> > read "\"1\"" :: String
18:09:08 <lambdabot>   "1"
18:09:08 <jakra> augustss: I've not used >>= before, is there an alternative
18:09:29 <augustss> jakra: read the string first with readline, then use read on it
18:09:37 <Axman6> do x <- readLine; readIO?
18:09:43 <Axman6> do x <- readLine; readIO x -- even
18:09:48 <augustss> jakra: or (fmap read readLine)
18:10:11 <newsham> read <$> readLine
18:10:20 <jakra> newsham: what is <$> ?
18:10:36 <augustss> newfangled stuff :)
18:10:38 <newsham> ?src (<$>)
18:10:38 <lambdabot> f <$> a = fmap f a
18:10:38 <blando> more or less fmap
18:10:39 <Draconx> same as fmap.
18:10:52 <mmorrow> Raevel: you could use this template-haskell code to autogen joinFork2..joinForkN for whatever N http://hpaste.org/13055
18:10:53 <ddarius> (<$>) = fmap
18:11:16 <newsham> readIO =<< readLine
18:12:07 <teko> does haskell have something thats like java's RMI ??
18:12:07 <jakra> exam <- getLine            x <- (read exam :: Int)          -- gets a type error (Int does not match IO a)
18:12:34 <newsham> exam <- getLine; let x = read exam :: Int
18:12:38 <augustss> jakra: let x = read exam :: Int
18:12:49 <jakra> Why does <- not work like usual, in the do?
18:12:58 <augustss> read is not monadic
18:13:02 <newsham> ?type read
18:13:03 <lambdabot> forall a. (Read a) => String -> a
18:13:19 <newsham> if you're do-block is for the IO monad, all of the results must be IO x for some x
18:13:32 <augustss> readIO would work
18:13:34 <Raevel> mmorrow: :-)
18:13:50 <newsham> you could do   x <- return (read exam)
18:13:58 <newsham> which is omre or less what  "let x = read exam" is
18:14:07 <newsham> ?type return
18:14:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:14:24 <newsham> that would turn the Int into an IO Int
18:14:43 <mmorrow> Raevel: template-haskell saves sooo much work :) check out the "derive" pkg on haskell too. super handy
18:14:52 <teko> does haskell have something thats like java's RMI ??
18:15:03 <mmorrow> what's RMI?
18:15:08 <newsham> remote method invocation
18:15:09 <newsham> sorta like rpc
18:15:10 <teko> remote method invocation
18:15:17 <mmorrow> hmm, i don't know
18:15:20 <augustss> no
18:15:26 <teko> is JSON like that ?
18:15:44 <Axman6> not afaik
18:15:53 <augustss> JSON allows you to serialize data, but it has no invokation part
18:16:00 <mmorrow> Raevel: err, i meant s/haskell/hackage/
18:17:20 <teko> can u use SOAP with haskell ?
18:17:50 <doublec> teko, there's an xml-rpc library
18:17:59 <teko> k
18:18:32 <doublec> search for 'rpc' on hackage
18:18:39 <doublec> there's also network-rpca
18:18:51 <doublec> HaXR is the xml-rpc library
18:18:57 <Saizan_> ?hackage cabal-install
18:18:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
18:20:50 <Gracenotes> oh, Haskell. Let me understand you better.
18:21:03 <Gracenotes> <_<
18:22:50 <augustss> Gracenotes: Haskell is really a very simple language
18:23:31 <Axman6> Gracenotes: what don't you get?
18:23:42 <augustss> It's just difficult to foresee the consequences of its simplicity. :)
18:23:45 <cjb> augustss: so, that's totally untrue :)
18:23:52 <Gracenotes> at the moment I'm trying to work my way up to monads.
18:24:09 <Gracenotes> every single description I've seen of them has made no sense, so it's been my goal to have them make sense
18:24:13 <Axman6> Gracenotes: i have some great exercises to help with that, if you want
18:24:23 <Gracenotes> (and I'll probably use Haskell beyond that)
18:24:42 <mauke> Gracenotes: my advice: ignore "monads", just start writing programs in haskell
18:24:56 <Axman6> Gracenotes: http://blog.tmorris.net/20-intermediate-haskell-exercises/ work through those, and they might make more sense
18:24:59 <augustss> Gracenotes: Don't worry about monads.  The general concept of a monad has very little content so it's hard to grok.
18:25:16 <Gracenotes> Yes, I have written a few programs here and there. It's mostly the academic challenge of comprehending them.
18:25:44 <mauke> it's like trying to understand groups without having seen numbers or anything
18:25:55 <Axman6> Gracenotes: go through those exercises, and see if they help. ask questions here (but make sure you let people know you don't want answers, just help ;)
18:26:35 <augustss> Gracenotes: If you think you'll ever get to know what they truly are, I think you're hoping for too much.  But you'll get used to seeing examples of them, and you can see that they all have something in common.
18:27:37 <augustss> I don't understand what they are any more than I understand what a monoid is.  It's just something that obeys certain laws.
18:27:44 <Gracenotes> fair enough. The idea is to gain at least a superficial academic fluency in functional paradigms :) learning a useful new language won't hurt either
18:28:30 <augustss> Gracenotes: have you read sigfpe's tutorial?
18:28:59 <Gracenotes> No... I'm working mostly from RWH
18:29:14 <augustss> Gracenotes: his is my favourite
18:29:35 <newsham> you must write your own monad tutorial before you can truely understand!
18:29:48 <augustss> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:30:23 <Gracenotes> neat. *reads*
18:30:50 <Gracenotes> I'll finish RWH ch. 9 first, though ;)
18:30:57 <mauke> preflex: seen dpiponi
18:30:58 <preflex>  dpiponi was last seen on #haskell 185 days, 6 hours, 32 minutes and 31 seconds ago, saying: Looks like the >=1.2 was wrong as a newer version builds category-extras fine. Thanks.
18:31:14 <newsham> dpiponi was last seen on Nova 35 days ago
18:33:24 <augustss> Nova?  As in the PBS show?
18:33:47 <newsham> yah, he was on this episode: http://www.pbs.org/wgbh/nova/fractals/program.html
18:34:22 <newsham> he's credited here: http://www.pbs.org/wgbh/nova/fractals/bios.html
18:34:53 <augustss> Cool!  He's theonly Oscar winner I've met. :)
18:35:25 <Raevel> a good days work? :-( http://hpaste.org/13056
18:36:05 <augustss> I like before better
18:36:10 <Raevel> no kid
18:37:20 <augustss> newsham: bah!  Can't watch it outside the US
18:37:28 <newsham> bummer. :(
18:37:53 <augustss> I need to set up a tunnel to a machine over there.
18:37:55 <newsham> perhaps someone has it on torrent or hulu?
18:37:57 <newsham> or youtube?
18:38:42 <Axman6> just find a web proxy
18:39:09 <newsham> pbs spends tons of money on hdtv.. they shoulda just spent it on streaming over the webs
18:39:47 <wli> Well, PBS has other, more serious problems.
18:41:01 <newsham> is the restriction done in the web form or on the site streaming the content?
18:42:22 <Axman6> augustss: http://tinyurl.com/nova-fractals-1 should work
18:43:01 <augustss> Cool!  Thanks!
18:44:44 <newsham> hmm.. why dont i see him in the transcript?  I saw the show and saw him on it
18:44:44 <olsner> @type \o-> look at my muscles
18:44:45 <lambdabot> Not in scope: `look'
18:44:45 <lambdabot> Not in scope: `at'
18:44:45 <lambdabot> Not in scope: `my'
18:47:44 <gwern> excellent. I am nearly done with my yi hacking which gives me a function which: reads the current word being typed; asks hoogle for its best guess as to what function is meant; pastes it in; and also flashes a message to the user what module the guessed-function is in
18:48:01 <gwern> indeed, it is all quite satisfactory. except for that one use of unsafePerformIO... :)
18:48:43 <augustss> maybe i should give yi a try again
18:49:04 <olsner> that's an unsafePerformIO that connects to hoogle and looks up a function name? :P
18:49:12 <gwern> olsner: yeah, basically
18:49:30 <gwern> I had to add it because I just can't handle the interactions between the 3 monads of IO, BufferM, and YiM
18:50:19 <gwern> hopefully jpb knows how to do things
18:50:36 <mmorrow> gwern: snap, are you gonna put that code somewhere? i'd love to see an example of making yi do stuff
18:51:04 <gwern> mmorrow: I'm recompiling and going to test it a little more, then I'm going to send it in
18:51:16 <mmorrow> gwern: cool. (send it where?)
18:51:17 <gwern> (with an accompanying plea for someone to fix the unsafePerformIo)
18:51:22 <gwern> yi-devel, natch
18:51:45 <mmorrow> oh nice, i had no idea about yi-devel
18:51:47 <gwern> I've discovered that yi can do a surprising amount of haskell-related stuff, but there's no documentation at all on it
18:52:06 <jakra> I'm trying to `show' a    getStudent :: IO MyDataType   function.  Error is "getStudent :: IO CS190student, *** Instance   : Show (IO CS190student)"
18:52:12 <jakra> How can I resolve this?
18:52:19 <gwern> for example, until I went pokign through the shim sources, no one mentioned that yi could paste into the buffer the inferred type of a function!
18:52:23 <jakra> Sorry, replace CS190student with MyDataType
18:52:38 <kpreid> jakra: you probably want to execute it and show the result
18:53:09 <jakra> kpreid: when I execute it without `show', no actual output appears
18:53:23 <kpreid> that's why I said "and show the result"
18:53:32 <mmorrow> gwern: yeah, i've been playing with yi in ghci a bit. i quickly found out that vty and ghci don't play well together
18:53:39 <Toxaris> jakra: do result <- getStudent; print result
18:53:45 <kpreid> in particular, you might like ...what Toxaris said
18:53:45 <augustss> show just converts to a string
18:53:53 <gwern> maybe he could use 'liftM show stuff', assuming his datatype has show derived
18:53:54 <jakra> kpreid: I also said that there's an error when using `show', I'm unsure exactly what you mean
18:53:56 <Toxaris> jakra: getStudent >>= print -- the very same thing, but so much easier!
18:54:04 <gwern> mmorrow: really? vty yi works fairly well for me
18:54:05 <jeffwheeler> gwern: yeah, I hvae no idea how to use those features, still. :-/
18:54:13 <kpreid> jakra: right, you have to execute it
18:54:13 <mmorrow> gwern: in /ghci/
18:54:24 <kpreid> jakra: "show getStudent" does not execute it
18:54:27 <gwern> jeffwheeler: well, you could look at my config
18:54:46 <mmorrow> gwern: i think vty is taking over signal handlers and other stuff
18:54:47 <kpreid> fmap show getStudent will execute it and apply show, but not do anything with the string...
18:54:51 <jeffwheeler> gwern: I'll start there; first I'll see the compilation requirements for Shim stuff
18:54:56 <gwern> (I'm slowly tryign to assemble a usable emacs haskell-mode in my config)
18:55:02 <kpreid> so getStudent >>= print is probably what you want
18:55:24 <mmorrow> gwern: but i'm not too concerned, was just messing around learning the api anyway
18:55:39 <gwern> jeffwheeler: well, give it a try?
18:55:56 <jeffwheeler> gwern: will do; is it just -fghcAPI?
18:56:09 <gwern> yes
18:56:30 <jakra> Toxaris: why does that work but not print getStudent ?
18:57:04 <dancor> :t (>>=)
18:57:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:57:11 <kpreid> jakra: because getStudent is not something you can print
18:57:32 <jakra> kpreid: it return()s a value, I thought I'd be able to print that
18:57:40 <kpreid> jakra: its result is not itself
18:57:49 <kpreid> you can print the result of getStudent; you cannot print getStudent
18:58:10 <kpreid> (and note that "can print" is identical to "has a Show instance")
18:59:22 <Toxaris> jakra: you are able to print the value returned by getStudent, you just have to do it the right way :)
19:00:02 <Toxaris> jakra: one can see something like getStudent (that is, something of type (IO Whatever)) as a representation of a program, which will produce a result when eventually run
19:00:19 <Toxaris> jakra: now, you do not want to print the program, but the result
19:00:30 <Toxaris> jakra: so (print getStudent) is not what you want
19:00:51 <Toxaris> jakra: instead, you want to produce a slightly bigger program, which, when eventually run, will produce a result, and print it
19:01:06 <Toxaris> jakra: you can do so using do-notation, or using the >>= operator as shown above.
19:02:22 <Toxaris> jakra: now the cool thing is, that in reality, you do not have to wait for the program to be run eventually at some point in the future, but it is run just in time. but you can still think of it as first constructing a program, then running it, which sometimes is a good way of thinking about your code
19:02:59 <jeffwheeler> gwern: ack; it really doesn't like -fhacking. ;)
19:06:49 <jtootf> does anybody knows any simple but complete examples for the Conal Eliott's Reactive? I've found only this one so far: http://www.mail-archive.com/haskell-cafe@haskell.org/msg36402.html
19:07:17 <jtootf> and it's a bit more complicated than I actually want :)
19:07:45 <jtootf> http://netsuperbrain.com/blog contains neat examples, but they are quite not complete - there is only the event machine definitions, but not usage
19:08:06 <jsn> i'm reading the lazy functional state threads paper
19:08:15 <jtootf> maybe someone has an experience in Reactive usage and some snippets to test it?..
19:08:30 <jsn> on page 4, there's a simple example of references escaping that is claimed to be problematic
19:08:43 <jsn> in that example, is there any actual terrible consequence?
19:08:48 <newsham> jtootf: http://netsuperbrain.com/blog/
19:08:50 <dons> hmm. have to dig up the paper.
19:08:58 <jsn> just a sec
19:09:01 <dons> jsn: in general, the higher ranked type prevents refs. escaping.
19:09:18 <dons> so when you use ST , all the effects are statically checked to stay inside the local scope
19:09:24 <gwern> jeffwheeler: I've never used -fhacking
19:09:27 <gwern> that useful?
19:09:30 <jsn> dons: yes, i know
19:09:35 <jsn> http://www.dcs.gla.ac.uk/fp/papers/lazy-functional-state-threads.ps.Z
19:09:45 <jsn> dons: i'm trying to explain this all to a friend
19:09:47 <mmorrow> gwern: here's one of my goes hacking around with Yi http://hpaste.org/13057
19:09:51 <jeffwheeler> gwern: I like it, but I use it somewhat sporadically.
19:09:56 <jsn> and i want to have a good motivating example
19:10:11 <jsn> the one in the paper seems like actually, we don't care
19:10:14 <dons> well, the motivation is the ability to mutate stuff, but ensure it is pure from the outside.
19:10:19 <mmorrow> that creates a new vty UI, which echos keys to the screen, and exits on 'q'
19:10:19 <newsham> jtootf: also http://www.haskell.org/pipermail/reactive/2008-November/000022.html
19:10:29 <jtootf> newsham: they are simple, but not complete; no event machine usage. e.g. how should I make an output in IO when event is catched?
19:10:31 <dons> so we can go directly onto the machine, but keep nice properties.
19:10:36 <jsn> dons: ah
19:10:42 <dons> btw, the author is my boss now :)
19:10:48 <jsn> dons: so returning references is bad for this because...
19:10:57 <jsn> ...the references are not actually the same each time
19:11:01 <dons> well. harmless, since you can't do anything with the references
19:11:02 <jsn> which violated the purity?
19:11:14 <dons> but if you could, it would be possible to violate purity
19:11:20 <jsn> dons: ah
19:11:37 <jsn> because depending on when it was dereferenced
19:11:39 <mmorrow> gwern: i wanted something like that for ghci to interactively to "stuff" (i don't know what), but i couldn't seem to exit from vty back to ghci, because ending the UI (via its suspend or exit functions) kill ghci as well
19:11:39 <jtootf> newsham: reactive tetris is interesting :) I'll look at it, thank you
19:11:52 <dons> so we get the hardware support machines have for mutable cells, and the compiler to check the referential transparency for us
19:11:55 <dons> so win both ways
19:12:00 <jsn> aye
19:12:22 <dons> the array libraries are mostly implemented on top of ST.
19:12:26 <dons> like uvector.
19:12:27 <jsn> dons: oh?
19:12:49 <dons> yeah, so you can manipulate raw memory, but 'freeze' the result, and treat it as a pure , persistant value
19:13:00 <dons> (with all the goodness that provides, like thread safety and easy parallelism)
19:13:31 <dons> would be a good way to do hashtables too
19:14:03 <teko> i want to write a function that looks like this:    permute n =       where if i pass it a value of 2 it gives as output ["00","01","10","11"]
19:14:18 <jtootf> newsham: maillist archive seems very promising, I'll try to find something useful there. anyway, thank you much ;)
19:14:25 <fusss> hey, how does one send a haskell expression from an emacs buffer to an inferior haskell process for evaluation? as in Lisp
19:14:37 <fusss> i'm using haskell-mode
19:14:52 <gwern> fusss: the entire buffer ok? C-c C-l iirc
19:15:26 <teko> any ideas on the permute function ????
19:15:44 * jeffwheeler wants to finally be able to cabal install hoc.
19:16:21 <jsn> dons: so the function    deref :: STRef a -> a   must be illegal, in other words
19:16:54 <jsn> or rather STRef s a -> a
19:18:11 <Toxaris> teko: whats your question?
19:19:21 <jsn> wow
19:19:38 <jsn> i really had to think about references before i could figure what might be wrong with them :)
19:19:44 <dons> jsn: STRef s a -> Ref a
19:19:53 <jsn> dons: what's that?
19:20:05 <dons> well, that would be some kind of mutable, stateless variable
19:20:10 <dons> the state thread detached, 's'
19:20:21 <dons> STRef s a -> a is just dereferencing
19:20:28 <jsn> dons: right
19:20:28 <dons> it takes a ptr a, and gives a a
19:20:35 <jsn> right
19:20:43 <dons> the 's' thing is the unforgable 'local scope' token
19:20:49 <jsn> right
19:20:50 <dons> that is unique in each runST block
19:20:54 <jsn> right
19:21:19 <jsn> so if we had    STRef s a -> a   that would be the equivalent of unsafeRunST
19:21:33 <jsn> if we could return actual STRefs, that is
19:21:46 <dons> yeah, if you could get  the ref out somehow.
19:22:06 <jsn> i am trying to motivate this business of scoping the references
19:22:20 <jsn> but i now realize that every imperative programmer knows what i am talking about
19:22:33 <jsn> and i used to, when i had to think about it, which has been awhile
19:23:18 <ikegami__> "Real world Haskell" is carried via Amazon to my room in Japan just now :)
19:23:35 <dons> YAY!
19:23:49 <dons> wow, that's the first one in japan that I know of.
19:24:05 <dons> I hope you enjoy it, ikegami__
19:24:24 <ikegami__> dons: thanks for authors and you
19:24:49 <Toxaris> > let permute = replicateM <*> enumFromTo '0' . chr . (47 +) in permute 2 -- works as you said, but that's not really permutation, is it?
19:24:51 <lambdabot>   ["00","01","10","11"]
19:25:02 <Gracenotes> I'm enjoying it very much online already -- just wondering what the motivation for the $45 cost is. Or is that standard of O'Reilly?
19:25:09 <Gracenotes> *for
19:27:04 <dons> Gracenotes: seems typical, i think
19:27:13 <papermachine> I wonder if Amazon ships to China.
19:27:45 <dons> papermachine: amazon.cn probably does...
19:28:55 <gwern> hiya Gracenotes
19:29:06 <dons> hey ikegami__, RWH is #1 in language books in japan, http://www.amazon.co.jp/gp/bestsellers/english-books/90224011/ref=pd_zg_hrsr_fb_1_4_last
19:29:19 <Gracenotes> ello, gwern
19:29:26 <gwern> Gracenotes: I suspect the 45$ is a bit high because its niche and new; my emacs o'reilly was more like 25 dollars, but that had been selling well and for a long time
19:29:41 <gwern> Gracenotes: given your situation, why not use the haskell wikibook instead? ;)
19:29:44 <dons> programming perl is 49.
19:29:49 <erikc> for some reason RWH is super cheap in canada, $31
19:29:49 <lambdabot> erikc: You have 1 new message. '/msg lambdabot @messages' to read it.
19:30:00 <dons> $49.
19:30:06 <gwern> dons: so... perl programmers are suckers?
19:30:08 <dons> so i think that's just  the standard price.
19:30:21 <jsn> gwern: no
19:30:34 <Gracenotes> gwern: I used it on my first attempt :) I stopped for some reason before, but I'm persevering in this case. hopefully.
19:30:36 <jsn> it's just, perl is becoming kind of like comic books
19:30:52 <jsn> old comic books, from when you were a kid
19:31:01 <gwern> jsn: people are speculating in perl manuals?
19:31:02 <Gracenotes> I've been looking at wikibooks also
19:31:22 <lucca> gwern: or people fly around wearing only regexes
19:31:37 <jsn> i'll be able to sell $_ to people for probably a few hundred a pop when i'm older
19:31:38 <jakra> Perl is cool in its own way and seems hugely unique, like Haskell
19:31:41 <Olathe> The Programmer's New Clothes.
19:32:10 * gwern shudders at the thought
19:32:29 <gwern> Gracenotes: well, the wikibook is like all wikibooks, could use some love. and as a wikipedian you are honorbound!
19:32:40 <gwern> honoour demands satisfaction!
19:33:04 <Gracenotes> either that, or cowardice
19:33:48 <Gracenotes> how anticlimatic :|
19:34:05 <MyCatVerbs> Gracenotes: that's dishonour.
19:34:10 * gwern sighs. my new Yi.Hoogle module is buggy. how ungrateful, after all I've done for it.
19:34:56 <Gracenotes> One man's honor is another dishonor; one's pride, another's shame
19:35:35 <joed> Gracenotes: suffice to say, you are to blame...
19:35:41 <MyCatVerbs> Gracenotes: no it isn't. Stoicism is practically uniform.
19:35:59 <jsn> hmm
19:36:27 <llayland> I just can't handle stoicism
19:36:34 <Gracenotes> stoicism in what?
19:36:50 <doublec> dons, you wanted to see rwh on my phone: http://www.bluishcoder.co.nz/rwh1.jpg
19:37:14 <dons> oh, that is very cool!
19:37:19 <erikc> gwern: is writing yi modules relatively easy?
19:37:20 <gwern> Gracenotes: Hellenic philosophy, presunmably
19:37:28 <doublec> that's using the mobireader version
19:37:29 <gwern> erikc: not for me
19:37:46 * gwern can't really compare with writing vim or emacs modules, though, on the other hand
19:38:14 <Gracenotes> oh. Don't mind me, I'm just a philosophical philistine
19:38:23 <dons> doublec: does that mean a copy made it to kiwi land?
19:38:36 <doublec> dons, yep - I ordered direct from o'reilly
19:38:38 <dons> sweet.
19:38:41 <joed> gwern: that is something that permeated quite a few cultures.
19:39:34 <FunctorSalad> philosophy time \o/
19:39:47 <gwern> joed: I'd be wary of generalizing stoicism too generally. the stoics were sophisticated and subtle philosophies; perhaps some of their general recommendations are echoed elsewhere, but I doubt their detailed arguments were all that prevalent
19:40:12 <gwern> *subtle philosophers
19:40:30 <joed> gwern: That I'd happily buy.
19:41:14 <Gracenotes> I've been too jaded by people using philosophy haphazardly to take the effort to learn it properly
19:41:30 <gwern> eg. virtue is the only good, is practically a universal tenet among ascetics and many many religious types
19:41:35 <papermachine> philosophy time m(-_-)m
19:41:40 <gwern> Gracenotes: a pity. SB has good philosophy classes
19:41:58 <newsham> gracenotes: and in doing so, formed your own little philosophy on philosophy
19:42:13 <MyCatVerbs> gwern: that sounds counterintuitive. People do good things by mistake and are sometimes even remembered well for it.
19:42:55 <gwern> MyCatVerbs: yes, it does. the stoic position implies that a virtuous man would be happy even if unjustly convicted and was being tortured to death
19:43:21 * joed slowly backs off and decides to buy a tuning kit for his MC, enough philosophy..
19:43:38 <FunctorSalad> midnight commander? ;)
19:43:47 <gwern> (this was very hard to accept indeed, which is why groups like the peripatetics said that virtue was necessary but not sufficient - you needed worldly pleasures as well)
19:43:51 <Gracenotes> newsham: I would comment to that, if I had ever heard a serious response query "What is philosophy?" in, say, a 101 course
19:43:54 <joed> FunctorSalad: Yeah, surely :)
19:43:55 <Gracenotes> *on
19:43:59 <MyCatVerbs> gwern: what *is* stoicism, rigi... hang on, maybe I should ask you in #-blah instead. :)
19:44:10 <Gracenotes> *to the query. well, that was a mess
19:44:22 <newsham> philosophy is the bs we add on top of the sciences ;-)
19:44:58 <gwern> philosophy is the fertilizer the plants of science grow out of - there's a lot of BS in it, but it's still valuable and necessary
19:45:42 <gwern> (on the plus side, filtering out the BS is fairly easy - by default, scrap anything French for example)
19:45:43 <Gracenotes> Kind of like anything that's not a hard science or an art.
19:46:24 <Gracenotes> Linguistics, psychology, etc.
19:46:52 <gwern> funny you pick those - both of those only grew out of philosophy a century or two ago
19:47:24 <gwern> eg. I was reading William James' _Principles of Psychology_, from the 1890s, and it contains an awful lot of philosophy, since psychology hadn't yet grown out completely
19:47:59 <joed> Wouldn't it be more what Jeeebus Juice provides such as Ethic, MetaPhysics etc?
19:48:00 <gwern> (woot, my hoogle completer is now not buggy. excellent.)
19:48:17 * gwern has no idea what joed means there
19:48:27 <FunctorSalad> psychology may not be a hard science (yet) but it's very relevant
19:48:39 <gwern> (or take linguistics - look at Rousseau's work on linguistics. still philosophy)
19:49:10 <Gracenotes> it doesn't mean hard sciences can't be used with psychology, either
19:49:30 <Gracenotes> notably factor analysis, more basic types of correlation
19:49:31 <joed> gwern: the main catagories of Philosophy would be MetaPhysics, Epistemolog, Ethics, Politics and so on.
19:49:44 <gwern> and?
19:49:52 <mmorrow> does philosophy have an `eval'?
19:50:24 <joed> No and, just in reference to psychology and it being new. I added I guess useless noise supporting your comment.
19:50:25 * mmorrow has no idea what that was supposed to mean, but went with it
19:51:17 <Gracenotes> honestly using factor analysis with psychology seems to be more of a "because we can, and because it sorta works" kind of thing
19:51:25 <Gracenotes> anyway...
19:51:33 * gwern takes a break; chore to do alas
19:52:55 * FunctorSalad sometimes prefers unscientific but insightful psychology to correlation studies that don't really tell us anything, but are advertised as if they were about causation ;)
19:53:50 <FunctorSalad> rigorous methods are preferable in principle, but if they can't be properly applied...
19:55:59 <Gracenotes> and then we get into the philosophical question of whether the correlations really exist, or are merely our superficial constructions
19:56:05 <Gracenotes> or at least, I'd like to think we do.
19:59:15 <FunctorSalad> Gracenotes: hmm. observing correlations seems relatively unproblematic unless you want to get extremely sceptical and question perceptions etc...
20:02:47 <Gracenotes> I'm more thinking of whether something like 'neuroticism' exists, in an existentialist sense, or is merely the convergance of some numbers. An utterly pointless exercise, really
20:08:12 <Gracenotes> so, haskell. *reads*
20:08:32 <Gracenotes> @src flip
20:08:32 <lambdabot> flip f x y = f y x
20:13:31 <Axman6> Gracenotes: did you give those exercises i posted earlier a go?
20:16:56 <Gracenotes> I'm not sure I know enough to grok them. the class/instance structure is simple enough, but the details (esp. some of the more complicated types) come up blank
20:17:39 <Gracenotes> bookmarked it, though.
20:18:07 <Gracenotes> indeed I did, bookmarked it very enthusiastically and vivaciously.
20:20:33 <august> attractively, lively and animated?
20:21:43 <Axman6> Gracenotes: well, i'd start with the list ones, they're the easiest to define most of the time
20:22:40 <Axman6> Gracenotes: for example, what has the signature (a -> b) -> [a] -> [b]? (technicallt this is functors i think, but still, useful stuff :)
20:23:04 <jsn> august: LOLz
20:23:47 <Gracenotes> er, map
20:23:59 <Olathe> :t map
20:24:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:24:06 <solrize_> @pl \f x y -> f y x
20:24:07 <lambdabot> flip
20:24:11 <solrize_> uggh :(
20:25:47 <Gracenotes> I don't quite recall what (a -> b) -> f a -> f b means, particularly the application of f
20:25:54 <Axman6> Gracenotes: does that match furry :: (a -> b) -> f a -> f b ?
20:26:10 <Olathe> :t (repeat .) . (. head)
20:26:12 <lambdabot> forall c a. (a -> c) -> [a] -> [c]
20:26:27 <Axman6> well, your f is just []
20:26:57 <Axman6> replace f with [], and if you want, rewrite is as [a] instead of [] a
20:27:42 <Gracenotes> > ([]) 4 -- this probably won't work?
20:27:43 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
20:28:01 <dibblego> > let x :: [Int]; x = [1,2,3] in x
20:28:02 <lambdabot>   [1,2,3]
20:28:07 <dibblego> > let x :: [] Int; x = [1,2,3] in x
20:28:08 <lambdabot>   [1,2,3]
20:28:27 <Gracenotes> ah, type notation.
20:28:36 <Axman6> yeah, that's al
20:28:37 <Axman6> l
20:31:29 <Gracenotes> so then one could do furry negate [3,4]. mm.
20:31:43 <dibblego> correct
20:32:32 <Axman6> Gracenotes: for reference, furry == fmap
20:33:22 <august> furries?
20:33:28 <Gracenotes> yes, my first though :/
20:33:31 <Gracenotes> +t
20:33:51 <Adamant> I don't think I want to hear a conversation about your first furry, thanks.
20:34:36 <Gracenotes> Adamant: I have Haskell to thank for it
20:34:52 <august> Adamant: hahaha
20:37:36 <Axman6> Gracenotes: ok, what about Furry Maybe?
20:37:51 <Axman6> first thing is, what would be the type signature of furry?
20:38:13 <Gracenotes> (a -> b) -> Maybe a -> Maybe b
20:38:19 <Axman6> sounds good :)
20:38:35 <Gracenotes> Maybe being either Just or Nothing...
20:38:43 <Axman6> yep
20:38:44 <gwern> @seen jeffwheeler
20:38:48 <lambdabot> I saw jeffwheeler leaving #haskell 44m 56s ago, and .
20:38:48 <Axman6> well, Just a or Nothing
20:39:00 <gwern> oh well. he'll see my patches on yi-devel
20:39:36 <Gracenotes> great opportunity for pattern matching, it should seem
20:41:02 <Axman6> Gracenotes: yup
20:41:45 <Gracenotes> furry negate (Just 3) succeeded
20:42:25 <Gracenotes> hm, I think I see the difference between $ and . <_<
20:43:23 <Axman6> Gracenotes: what about furry f Northing?
20:43:37 <Gracenotes> what you meant, yes.
20:43:48 <Megzlna> How do you get the bot to print out associativity for:
20:43:49 <Megzlna> > ff $ a $ b $ c
20:43:50 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Expr'
20:46:19 <Gracenotes> next one seems to be (a -> b) -> (t -> a) -> (t -> b)
20:46:55 <dibblego> does that signature look familiar?
20:47:15 <Gracenotes> I wish ;)
20:47:28 <dibblego> you've not seen (.) ?
20:47:34 <Axman6> dibblego: oi
20:47:38 <dibblego> oyo
20:47:45 <Axman6> help, don;t give answers ;)
20:47:59 <dibblego> the signature is once-inhabited
20:48:03 <mriou> hi, I'm playing with the ST monad and STRefs and have a question
20:48:07 <dibblego> so it *is the answer* :)
20:48:12 <Gracenotes> seen (.), but not been aware of the particulars of type
20:48:18 <mriou> how one would go about creating a map where each value is a STRef
20:48:19 <mriou> ?
20:48:21 <Axman6> :t (.)
20:48:22 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:48:31 <Gracenotes> mm. let me write a trivial implementation anyway
20:48:45 <araujo> hello
20:49:26 <araujo> why, makeRegex "string" , isn't working for me? ... it says it needs an instance declaration for [Char] ...
20:49:27 <araujo> ?
20:50:07 <mriou> I've tried M.Map String (forall s. STRef s WyType) which didn't quite work
20:50:53 <Gracenotes> great, furry func a = (\x -> func (a x)).
20:50:54 <Axman6> mriou: M.Map String (STRef a WyType)?
20:51:10 <Gracenotes> although... hm. that might have some problems
20:51:17 <Axman6> Gracenotes: looks good
20:51:33 <Axman6> :t let furry func a = (\x -> func (a x)) in furry
20:51:34 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
20:51:35 <mriou> axman6: tried it, fails complaining that a isn't bound
20:52:12 <Axman6> mriou: do you need to actually define thsi type? can;t you just use it? (and let ghc tell you what the type is)
20:52:31 <Gracenotes> oh, I thought it might fail if a had more than one parameter. By definition, I guess it can't
20:52:43 <Gracenotes> and I guess currying would take effect anyway
20:53:07 <mriou> Axman6: I can try
20:53:08 <Gracenotes> (in some cases) hm, let's see
20:54:36 <sabren> so how come ghc and hugs  don't come with cabal pre-installed?
20:55:24 <gwern> they come with cabal the library
20:55:27 <gwern> ghc anyway
20:56:05 <sabren> yeah, but can I use that to automatically download packages?
20:56:36 <gwern> no. that's cabal-install
20:56:58 <doublec> how do I convert a lazy ByteString to a non-lazy bytestring?
20:57:01 <sabren> :) yeah... installing which seems to be a rather cumbersome process
20:57:28 <doublec> toChunks, followed by a join?
20:57:50 <gwern> doublec: the haddocks say. there's some fromChunks . toChunks short expression which strictifys it
20:58:06 <doublec> thanks gwern
20:58:46 <Axman6> Gracenotes: do you see how what you defined is just a verbose way or saying furry func a = func . a ?
20:59:00 <Axman6> @pl (\x -> func (a x))
20:59:01 <lambdabot> func . a
20:59:25 <dibblego> furry func a = (.) func a
20:59:28 <dibblego> furry func = (.) func
20:59:32 <dibblego> furry = (.)
21:00:25 <august> when did this turn into anthropomorphic animal channel?
21:01:02 <dibblego> on the hypothesis that anthropomorphism appeases the irrational fear of otherwise obtuse terminology
21:01:04 <sereven> :t putStrLn "" >>= return -- WarmFuzzyPurr ()
21:01:05 <lambdabot> IO ()
21:01:21 <Megzlna> How do I parse this signature?
21:01:30 <Gracenotes> Axman6: yes, I saw it was func . a ... I just wanted to implement it 'trivially'
21:01:31 <Megzlna> :t (1 $)
21:01:32 <lambdabot> forall a b. (Num (a -> b)) => a -> b
21:01:46 <gwern> august: since someone joked abotu renaming monads warm fuzzy things
21:01:57 <dibblego> Megant, a -> b such that there is a Num instance for (a -> b)
21:02:11 <Axman6> mriou: that doesn't make any sense though
21:02:12 <Gracenotes> although dibblego helped with the former ;)
21:02:40 * gwern notes that just about everythign sounds dirty when phrased properly. 'august: would you like to touch my warm furry things?'
21:02:41 <Megzlna> dibblego: What does that mean exactly?
21:02:55 <Megzlna> Can you show me a function that can make use of  (1$)
21:03:01 <dibblego> Megant, I'm not sure how to state that more exactly
21:03:11 <Megzlna> cause you can't:
21:03:21 <Megzlna> (1 $) (+ 1)
21:03:22 <dibblego> no since I can't give you a Num instance for forall a b. a -> b
21:03:23 <Megzlna> > (1 $) (+ 1)
21:03:23 <Axman6> mriou: there are none, since 1 does not have the type a -> b
21:03:24 <lambdabot>       No instance for (Num ((a -> a) -> b))
21:03:24 <lambdabot>        arising from the literal `...
21:03:28 <Megzlna> > (1 $) (1 +)
21:03:29 <lambdabot>       No instance for (Num ((t -> t) -> b))
21:03:29 <lambdabot>        arising from the literal `...
21:03:31 <Axman6> :t ($)
21:03:32 <lambdabot> forall a b. (a -> b) -> a -> b
21:03:49 <Axman6> ($ 1) makes sense, but that's exactly the same as writing a
21:03:53 <Axman6> s/a/1
21:04:02 <Megzlna> not ($ 1)
21:04:04 <Megzlna> (1 $)
21:04:24 <Gracenotes> gwern: fuzzy? <_<
21:04:47 <Gracenotes> oh, furry. Not sure whether that's better or worse.
21:05:06 <Megzlna> what on earth is this about furries?
21:05:09 <Megzlna> I HATE FURRIES
21:05:11 <Megzlna> seriously
21:05:27 <Axman6> we're talking about http://blog.tmorris.net/20-intermediate-haskell-exercises/
21:05:53 <Megzlna> I used to have these furry neighbours who were really paranoid and at the same time wanted their windows open so people could see (and be disgusted by) furry sex
21:06:25 <Axman6> that makes them paranoid how?
21:06:37 <Megzlna> involving a skunk and some kind of dog thing
21:07:10 <mriou> Axman6: sorry was trying stuff, what doesn't make any sense?
21:07:13 <SubStack> awesome
21:07:13 <Megzlna> and the guy called himself "Meowsen"
21:07:21 <SubStack> what an interesting neighborhood
21:07:33 <Axman6> mriou: i might have hilighted you when i meant Megzlna, sorry
21:07:52 <mriou> Axman6: no worries :)
21:08:05 <Axman6> Megzlna: you understand how (1 $) makes no sense right?
21:08:08 * Gracenotes lols heartily
21:09:23 <Megzlna> (1 $) cannot make sense because you can't pass an infix function to it, since there's no such thing as an infix function beyond the parsing of text
21:10:30 <Axman6> it makes no sense because 1 is not a function of the type a -> b
21:10:37 <Axman6> :t ($)
21:10:38 <lambdabot> forall a b. (a -> b) -> a -> b
21:11:10 <Megzlna> > ((\x -> x + 1) $) 1
21:11:11 <lambdabot>   2
21:11:16 <Gracenotes> :t ($ 1)
21:11:17 <lambdabot> forall a b. (Num a) => (a -> b) -> b
21:11:33 <Gracenotes> :t (1 $)
21:11:34 <lambdabot> forall a b. (Num (a -> b)) => a -> b
21:11:43 <Gracenotes> hm
21:12:20 <august> damn it, now you've got me swapping 'forall' with 'furryall'
21:13:05 <joed> Xmas! /me buys august a furyall set of thongs.
21:13:21 <august> thongs with tails?
21:13:29 <joed> If you wish...
21:20:15 <rhencke> can anyone recommend a starting point for learning haskell for someone from an imperative programming background?  i've tried gentle introduction to haskell, but it was honestly a bit advanced for me.
21:20:53 <Axman6> @where lyah
21:21:05 * Axman6 pokes lambdabot 
21:21:08 <araujo> rhencke, you could try YAHT
21:21:18 <lambdabot> www.learnyouahaskell.com
21:21:18 <araujo> yet another haskell tutorial
21:21:35 <rhencke> learn you a haskell... for great good.  hah. :)
21:21:48 <Axman6> rhencke: www.learnyouahaskell.com is quite good. there's also a haskell tutorial for C programmers somewhere
21:21:52 <Gracenotes> oh wow, it's 12:21 already
21:21:55 <joed> rhencke: I would try YAHT, I'd also poke around for implementations, Like http clients and such where you can compare daily bread to what you do.
21:22:01 <Axman6> @go haskell for C programmers
21:22:08 <rhencke> thanks araujo, lambdabot, axman, and joed
21:22:14 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
21:22:14 <lambdabot> Title: Haskell for C Programmers
21:22:22 <Axman6> that one
21:22:27 <rhencke> thank you :)
21:22:39 <rhencke> i will give these a shot
21:24:00 <Axman6> rhencke: also, #haskell is an excellent place to ask questions
21:24:11 <rhencke> ...in hindsight, i should have probably realized lambdabot is a bot
21:24:23 <Axman6> indeed ;)
21:24:47 <rhencke> axman6: cool... and i'm already here.  epic convenience.   thanks :)
21:24:58 <Axman6> :)
21:26:29 <august> @bot
21:26:30 <lunabot>  :)
21:26:30 <lambdabot> :)
21:40:46 * thoughtpolice yawns
21:40:46 <lambdabot> thoughtpolice: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:41:27 <thoughtpolice> @seen Lemmih
21:41:27 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
21:46:58 <ac> what sort of affine transform would simply scale by 50%?
21:47:59 <Axman6> [[0.5,0,0],[0,0.5,0],[0.0,0.0,0.0]]?
21:48:21 <Axman6> just an identity matrix scaled by 0.5
21:48:35 <Axman6> or 1.5 is you want to make it bigger
21:49:28 <ac> Axman6: right, thanks
21:49:53 <Gracenotes> here's a basic glob module I finished, from RWH's Chapter 8 exercises - http://hpaste.org/1305 ...any suggestions about style?
21:50:55 <Gracenotes> hm, I guess I could have used _ in more places
21:52:30 <rhencke> you sure you don't mean 13058?
21:53:00 <thoughtpolice> @tell Lemmih the PureInteger test fails on both my macbook (core2) and with linux inside vmware on OS X - also, building applications using -fdebug does not currently work on OS X 10.5.5 it seems, due to a very strange linking err ('gcc -g' builds all other apps fine?)
21:53:00 <lambdabot> Consider it noted.
21:53:31 <Gracenotes> that number is oddly familiar.
21:53:37 <mibby> Hi, I'm having trouble understanding the difference between f $ g and f . g (I understand with $ perfectly)
21:53:47 <thoughtpolice> @tell Lemmih i've built lhc on linux so I can use the debugger on the application :/
21:53:47 <lambdabot> Consider it noted.
21:53:49 <mibby> How could I best demonstrate use of them both?
21:54:02 <thoughtpolice> :t (.)
21:54:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:54:06 <thoughtpolice> :t ($)
21:54:07 <lambdabot> forall a b. (a -> b) -> a -> b
21:54:44 <thoughtpolice> mibby: the (.) operator is composition, while ($) is simply function application
21:55:05 <mibby> I know that much - how can I best demonstrate them producing different outputs?
21:55:20 <mibby> (But I can't quite grip what it means by `composition', compared)
21:55:30 <Eridius> different outputs? if you swap one for the other, you'll get a type error
21:55:59 <Eridius> composition means: (f . g) x == f (g x)
21:56:00 <thoughtpolice> mibby: if you have 'f(g(x))', saying '(f . g) x' is the same thing
21:56:35 <mibby> How does that differ from f $ g x, then?
21:56:43 <thoughtpolice> it doesn't
21:56:51 <thoughtpolice> Lemmih: hi :>
21:57:04 <mibby> f $ g x == f (g x) == (f . g) x
21:57:14 <mibby> Now I'm confused, as they seem to be the same
21:57:33 <Eridius> mibby: f . g x would be an error though
21:57:37 <thoughtpolice> (.) just allows you to make new functions out of two already existing functions
21:57:51 <thoughtpolice> look at the type of (.):
21:57:53 <thoughtpolice> :t (.)
21:57:54 <Axman6> mibby: often you'll use f.g.h.i $ x
21:57:54 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:59:02 <thoughtpolice> mibby: if you apply only two arguments, i.e. 'f . g', then it returns something of type 'a -> c'
21:59:11 <thoughtpolice> so, you can say
21:59:20 <thoughtpolice> let wibble = f . g
21:59:21 <thoughtpolice> wibble x
21:59:42 * Axman6 wouldn't say wibble
21:59:43 <Axman6> >_>
22:00:24 <thoughtpolice> mibby: (.) is just a useful way to compose functions from new functions - hence it's the composition operator
22:00:36 <thoughtpolice> er, compose new functions from old functions
22:00:59 <thoughtpolice> OTOH, ($) is just function application as we already know.
22:06:39 <Megzlna> How do you compose a constant, like this:
22:06:42 <Megzlna> > (+ 1) . (* 2) . (\_ -> 1) $ undefined
22:06:44 <lambdabot>   3
22:06:57 <Megzlna> properly
22:08:27 <pumpkin> hmm?
22:08:48 <Megzlna> just a lazy value
22:09:01 <Megzlna> > (+ 1) . (* 2) . 1 -- wont work
22:09:02 <lambdabot>       No instance for (Num (a -> b))
22:09:02 <lambdabot>        arising from the literal `1' at <...
22:09:25 <ozy`> > (\() -> 1) ()
22:09:27 <lambdabot>   1
22:09:31 <Megzlna> lol
22:09:35 <Axman6> > (+ 1) . (* 2) $ 1
22:09:36 <lambdabot>   3
22:09:44 <Megzlna> Axman6: That's application.
22:09:54 <pumpkin> > const 5
22:09:55 <lambdabot>       Overlapping instances for Show (b -> t)
22:09:55 <lambdabot>        arising from a use of `s...
22:10:03 <Axman6> i don't understand what you want then
22:10:21 <pumpkin> > (+ 1) . (* 2) . const 5 $ undefined
22:10:22 <lambdabot>   11
22:10:30 <pumpkin> @src const
22:10:30 <lambdabot> const x _ = x
22:11:07 <Gracenotes> :type (const . const)
22:11:12 <Gracenotes> :t (const . const)
22:11:13 <lambdabot> forall b a b1. a -> b -> b1 -> a
22:11:17 <pumpkin> lol
22:11:23 <pumpkin> superconst
22:11:43 <Gracenotes> > (const . const) 1 2 3
22:11:45 <lambdabot>   1
22:11:51 <Megzlna> const is right
22:11:53 <Megzlna> cool
22:11:59 <rhencke> :t ((.).(.))
22:12:00 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
22:12:01 <pumpkin> > const (const 5) 7 $ 12
22:12:02 <lambdabot>   5
22:13:09 <rhencke> man, it's easy to make functions that break one's brain
22:13:26 <pumpkin> lol
22:13:50 <Megzlna> what do people usually use to pull the constant out?
22:13:54 <Megzlna> with const
22:13:56 <rhencke> pliers
22:13:58 <Megzlna> undefined?
22:14:03 <Axman6> no...
22:14:41 <Axman6> it's often used as something like sum . map (const 1) (which is a form of length function
22:15:12 <jeffwheeler> > :t (,)
22:15:13 <lambdabot>   <no location info>: parse error on input `:'
22:15:17 <jeffwheeler> err
22:15:21 <pumpkin> :t (,)
22:15:22 <lambdabot> forall a b. a -> b -> (a, b)
22:15:53 <Gracenotes> ah, so 'const x' instead of, say, (\a -> x)
22:16:20 <Gracenotes> nice
22:16:24 <dibblego> and \_ -> x
22:27:43 <Megzlna> > let f xs = sum . map (const 1) xs
22:27:44 <lambdabot>   <no location info>: parse error on input `;'
22:27:50 <Megzlna> > let f xs = sum . map (const 1) xs in f [1,2,3]
22:27:51 <lambdabot>   Couldn't match expected type `a -> [a1]'
22:28:12 <pumpkin> you need a $
22:28:19 <pumpkin> > let f xs = sum . map (const 1) $ xs in f [1,2,3]
22:28:21 <lambdabot>   3
22:28:24 <Megzlna> Yeah, I just wrote all variations
22:28:29 <pumpkin> :)
22:28:46 <Megzlna> let f xs = sum (map (const 1) xs)
22:28:46 <Megzlna> let f = sum (map (const 1)) -- error
22:28:46 <Megzlna> let f xs = sum . map (const 1) $ xs
22:28:46 <Megzlna> let f = sum . map (const 1)
22:28:46 <Megzlna> let f xs = sum $ map (const 1) xs
22:28:47 <Megzlna> let f = sum $ map (const 1)	-- error
22:29:40 <Megzlna> But, that one is weird.
22:29:50 <Megzlna> the third one
22:29:58 <pumpkin> why?
22:30:52 <Megzlna> cause, why can't the xs just be closured in?
22:30:57 <dons> ?users
22:30:57 <lambdabot> Maximum users seen in #haskell: 586, currently: 529 (90.3%), active: 15 (2.8%)
22:31:07 <dons> Megzlna: how's the haskell experience been so far?
22:31:24 <dons> dibblego: any sign of RWH in .au yet, do you know?
22:31:25 <Megzlna> dons, highest level language I've done
22:31:29 <Megzlna> moreso than Lua, and JS
22:31:33 <Gracenotes> lots of fun too
22:31:37 <dons> yeap, Megzlna.
22:31:38 <Cale> If it helps, f xs = sum . map (const 1) $ xs can be rewritten as f xs = (sum . map (const 1)) xs
22:31:45 <dons> unless you've done some Epigram or Agda or Coq.
22:31:49 <dons> Gracenotes: yay!
22:32:23 <Megzlna> And it's interesting how Haskell is higher level than untyped languages, because by their lack of strong typing, they lose on polymorphism
22:32:27 <dons> i wonder what the correlation between generality/abstraction/lack of annoying corner cases and fun is.
22:32:43 <dons> Megzlna: yeah, we have this type system making some abstractions tractable
22:32:47 <dibblego> dons, I've ordered it from Amazon; the Australian retailers are way overpriced
22:32:47 <Megzlna> s/untyped/dynamic typed/
22:32:54 <dons> you don't see monads elsewhere, so much.
22:33:01 <dons> dibblego: yeah. :/ its ridiculous.
22:33:01 <dibblego> dons, http://www.fishpond.com.au/Books/Computers/Programming/General/product_info/12316290/?cf=3&rid=258828266&i=1&keywords=real+world+haskell
22:33:20 <dons> i heard a couple of guys ordered back in july when the dollar was ok.
22:33:20 <Megzlna> Cale: hmmmmm
22:33:51 <dons> dibblego: that's about double what it goes for here.
22:33:55 <Megzlna> Cale: I see, I just made a paren mistake !
22:34:05 <dibblego> dons, yep hence Amazon :)
22:34:07 <newsham> the paren trap
22:34:08 <Cale> ah, okay :)
22:34:21 * dons has no idea how the system works. 
22:34:58 <dons> Cale: getting cold out, btw?
22:35:15 <Gracenotes> newsham: *groans*
22:35:19 <Cale> yeah... it's -1 C.
22:35:26 <Cale> and raining...
22:35:36 <Cale> Pretty miserable weather here :P
22:35:39 * Gracenotes takes some punicillin
22:35:43 <Megzlna> > let f = sum (map (const 1))
22:35:44 <lambdabot>   <no location info>: parse error on input `;'
22:35:48 <Megzlna> > let f = sum (map (const 1)) in f [1,2,3]
22:35:49 <lambdabot>   Couldn't match expected type `[a]'
22:35:51 <dons> oh, there's some -40F/C coming up i saw. North Dakota, and a big chunk of canada
22:36:01 <Megzlna> Oops
22:36:18 <Megzlna> How do you put in a placeholder?
22:36:38 <pumpkin> placeholder?
22:36:39 <lucca> -40 is Cold
22:36:41 <Megzlna> that one's impossible right.
22:36:58 <Megzlna> there's no way to have a "curry placeholder" inside of nested ()'s
22:36:59 <pumpkin> dons: when?
22:37:03 <Megzlna> like
22:37:08 <dons> monday, tuesday.
22:37:18 <Megzlna> let f = sum (map (const 1) _arg)
22:37:18 <pumpkin> Megzlna: well, you can just make a lambda but I guess that's not the same
22:37:23 <Megzlna> except a lambda
22:37:29 <Megzlna> k
22:37:32 <dons> this cold air pushing down, http://www.wunderground.com/global/Region/CN/pxTemperature.html
22:37:41 <Cale> The forecast for this week around here is all hovering around 0 C.
22:37:52 <pumpkin> looks scary
22:38:03 <dons> some weird weather event, apparently
22:38:05 <Gracenotes> Megzlna: or perhaps you could do something with flip (.) ...?
22:38:09 <pumpkin> we're hovering in the 10˚ F area
22:38:12 <lucca> megzlna: \x -> sum $ map $ const 1 x ?
22:38:15 <Gracenotes> that would be awesomely messy though
22:38:15 <pumpkin> Gracenotes: you can, but it's super ugly
22:38:20 <Cale> Ah, yeah, out west it looks cold :)
22:38:22 <lucca> probably some pointless (@pl) transformation
22:38:25 <Megzlna> the lambda one is easy heh
22:38:33 <pumpkin> @pl \x -> sum $ map $ const 1 x
22:38:34 <lambdabot> sum . map . const 1
22:38:34 <dons> Cale: i always just assume you're in the middle somewhere
22:38:34 <lucca> @pl \x -> sum $ map $ const 1 x
22:38:35 <lambdabot> sum . map . const 1
22:38:36 <Megzlna> Im just trying to enumerate all the expressions of it
22:38:39 <pumpkin> :P
22:38:44 <lucca> oh that's fairly smooth
22:38:51 <Cale> dons: I'm in southern Ontario, the pointy bit :)
22:39:09 <lucca> 52F here :p
22:39:17 * pumpkin 's jealous
22:39:18 <Cale> On that animated map it's cyan :)
22:39:25 <pumpkin> it's 9 F here
22:39:28 <dons> ah, so not real canada.
22:39:35 <Cale> hehe
22:39:54 <dons> i actually thought you were in calgary
22:40:03 <Megzlna> 62 F
22:40:05 <Cale> My sister was out in Calgary for a bit.
22:40:14 <Megzlna> Los Angeles
22:40:27 <lucca> 52F San Diego!
22:40:41 <Megzlna> And looking for an old geezer
22:40:47 <Cale> One of my uncles is up in the Yukon.
22:41:03 <pumpkin> > msum [Just 1, Just 3, Nothing, Just 4]
22:41:04 <lambdabot>   Just 1
22:41:22 <pumpkin> > msum [[1,2,3], [2,3,4], [5,6,7]]
22:41:23 <lambdabot>   [1,2,3,2,3,4,5,6,7]
22:41:30 * pumpkin feels fancy
22:41:37 <dons> hehe
22:41:40 <dons> cute trick.
22:41:57 <pumpkin> one of these days I'll be speaking of catamorphisms too!
22:42:06 <pumpkin> then I'll be truly fancy
22:42:20 <Megzlna> Is there any possible way to make a polymorphic type that will accept:  [1,2,Nothing,4] ?
22:42:23 <dons> oh no. cata-s are just entry level.
22:42:31 <dons> black belt level gets kinda weird.
22:42:37 <dons> histo-zygo-prepo-...
22:42:40 <Gracenotes> @src msum
22:42:40 <lambdabot> msum =  foldr mplus mzero
22:42:42 <dibblego> @type [1,2,Nothing,4]
22:42:44 <lambdabot> forall a. (Num (Maybe a)) => [Maybe a]
22:42:45 <pumpkin> dons: yeah, but they sound fancy :)
22:42:48 <Cale> Megzlna: Only if (Maybe t) was an instance of Num
22:42:54 <pumpkin> dons: also, is foldl a catamorphism too, or is it just foldr?
22:43:07 <dons> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Zygo.html
22:43:07 <Megzlna> Cale: So, can't I use newtype, and duplicate a few things
22:43:17 <dons> foldr's the natural one. not sure how to characterise foldl
22:43:23 <pumpkin> Algebra f b
22:43:26 <pumpkin> oh wow :)
22:43:33 <pumpkin> :t zygo
22:43:34 <lambdabot> Not in scope: `zygo'
22:43:38 <pumpkin> boo
22:43:38 <dons> g_prepro_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> (f :~> f) -> FixF f -> a	Source
22:43:42 <dons> a generalized zygomorphic prepromorphis
22:43:49 <Cale> Megzlna: If 1 and Nothing are the same type...
22:43:49 <pumpkin> now my head really can explode
22:43:50 <dons> abstraction. we has it.
22:44:27 <Cale> Megzlna: Then there must be an instance Num (Maybe t) for some t.
22:44:34 <Cale> :t [1,2,Nothing,4]
22:44:35 <lambdabot> forall a. (Num (Maybe a)) => [Maybe a]
22:44:58 <Megzlna> (Num (Maybe a)) =>   -- beyond me
22:45:17 <Cale> Well, all the elements of the list must be the same type
22:45:40 <Megzlna> How does (Num (Maybe a)) parse into english?
22:45:43 <Cale> and so 1 :: (Num a) => a  must be the same type as Nothing :: Maybe b
22:45:56 <Cale> Megzlna: (Maybe a) is an instance of the typeclass Num
22:45:58 <dibblego> @info getArgs
22:45:59 <lambdabot> getArgs
22:46:02 <dibblego> @index getArgs
22:46:03 <lambdabot> System.Environment
22:47:00 <Cale> So if we set a = Maybe b and unify, we get  1 :: (Num (Maybe b)) => Maybe b
22:47:13 <Cale> (in that list)
22:47:44 <Cale> But since there is no such instance, it'll give us an error if we try to use that list, unless we're also willing to write one.
22:48:13 <Megzlna> What is the distinction there for why it doesn't formulate as:  forall a. (Num a) => [Maybe a]
22:48:52 <Cale> Perhaps because 1 isn't a value of type Maybe a
22:49:03 <Cale> (unless Maybe a is an instance of Num)
22:49:10 <Megzlna> Heh!
22:49:23 <Megzlna> So if we added it to Num, it would say  (Num a) => [Maybe a]   ?
22:49:37 <Cale> If we wrote an instance (Num a) => Num (Maybe a)
22:49:39 <Megzlna> or just  (Num a) => [a]   ?
22:49:53 <Cale> then it would come out to  (Num a) => [Maybe a]
22:50:00 <Megzlna> wow
22:54:38 <cygnus_> domro lambdagoto mr lambaboto
22:54:45 <pumpkin> lol
22:55:26 <pumpkin> dons: your crazy zylos don't scare me anymore
22:55:29 <pumpkin> I know their secret
22:55:30 <pumpkin> type Zygo = (,)
22:55:32 <pumpkin> lol
22:55:42 <pumpkin> *Zygo
22:58:11 <dons> hehe
22:58:29 <dons> lots of goodness flows from (,) or (->) or ([])
22:58:45 <pumpkin> :)
22:58:50 <dons> (:)
22:58:53 <pumpkin> how do Monoids differ from MonadPluses?
22:59:01 <rhencke> forgive a newbie question.. but why is 'let X = 1' an error?
22:59:07 <pumpkin> rhencke: uppercase X
22:59:11 <dons> rhencke: upper case is only for types and constructors.
22:59:15 <dons> not value-level variables
22:59:17 <rhencke> Ah...
22:59:19 <dons> or type variables
22:59:20 <rhencke> okay, thank you
22:59:22 <dibblego> is there a mapM equivalent in Control.Applicative/Traversable?
22:59:28 <Gracenotes> oh, *that's* why gedit highlights uppercase the same way
22:59:40 <dons> dibblego: yeah.
22:59:44 <dons>         mapM :: Monad m => (a -> m b) -> t a -> m (t b)
22:59:44 <dons>         mapM f = unwrapMonad . traverse (WrapMonad . f)
22:59:55 <dibblego> ah thanks
23:00:06 <dons> class Monoid a where mempty  :: a -- ^ Identity of 'mappend' mappend :: a -> a -> a -- ^ An associative operation mconcat :: [a] -> a
23:00:30 <Gracenotes> :t mapM
23:00:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:00:31 <dons> while,
23:00:32 <dons> class Monad m => MonadPlus m where mzero :: m a mplus :: m a -> m a -> m a
23:00:55 <dons> pumpkin: note how MonadPlus operates on 'container' types.
23:01:06 <pumpkin> I see
23:01:08 <dons> Monoid is simpler, a, a -> a -> a
23:01:10 <pumpkin> Monoid is more general?
23:01:22 <dons> different?
23:01:31 <pumpkin> ok :)
23:01:44 <dons> we do have
23:01:44 <dons> instance MonadPlus [] where mzero = [] mplus = (++)
23:01:54 <dons> instance Monoid [a] where mempty  = [] mappend = (++)
23:02:04 <cygnus_> how do you tell wehther to dedicate your life to c++ or haskell
23:02:13 <dons> or satan.
23:02:20 <dons> its a tough questoin
23:02:22 <cygnus_> satan is one of those
23:02:25 <dons> heh
23:02:43 <dons> are you a good person, cygnus_ ?
23:02:49 <dons> or does fear rule your heart?
23:03:03 <cygnus_> i fear
23:03:15 <ddarius> Dedicating your life to a programming language would be pretty pathetic.
23:04:37 <dons> its like hmm.. dedicating your life to a specific form of carpentry
23:04:53 <cygnus_> how can you tell what you like
23:04:53 <dons> but without a market for antiques
23:04:56 <cygnus_> before you becoming a master of it
23:05:09 <dons> try things. see what you enjoy.
23:05:12 <ddarius> cygnus_: How do you tell what food you like?
23:05:15 <dons> look for what others do...
23:05:17 <cygnus_> sampler
23:05:33 <cygnus_> but i can eat foods so easy
23:05:49 <dons> practice. i guess.
23:05:51 <ddarius> It's not hard to learn languages (though, not as easy as eating, I will admit)
23:06:15 <dons> our brains are not as well adapted to programming, as to eating.
23:06:33 <dons> we need to make programming a matter of survival, then let natural selection weed out the weaklings.
23:06:51 <cygnus_> programming is for very few people
23:06:53 <thetallguy> lol
23:07:02 <thetallguy> Man, I haven't checked in here in weeks
23:07:04 <dons> well, few until we make it a survival skill.
23:07:09 <dons> thetallguy: hehe
23:07:12 <thetallguy> And look what I find when I do.
23:07:19 <rhencke> survivor: programming edition
23:07:23 <cygnus_> aha
23:07:24 <dons> ddarius and don yabbering?
23:07:29 <cygnus_> the haskell team will surely win
23:07:31 <rhencke> concatenate these lists... for food!
23:07:33 <dons> (is yabbering a word in american?)
23:07:38 <Adamant> no
23:07:42 <Adamant> yammering is
23:07:54 <cygnus_> sounds like a new language
23:08:10 <dons> http://www.thefreedictionary.com/yabbering
23:08:21 <thetallguy> dons: I am not descended from the apes.  Grace Hopper reached out and created us all...
23:08:22 <cygnus_> it's free cause it sucks
23:08:35 <dons> i find it hard to determine when i've slipped an aussie-ism into a conversation
23:08:46 <dons> other than looks of incomprehension
23:08:56 <dons> for example, "that code looks like a dog's breakfast", dibblego
23:09:03 <Adamant> what a yobbo, you bogan
23:09:06 <cygnus_> aha
23:09:08 <thetallguy> dons: funny, I just watched Cate Blanchett on Inside the Actor's Studio
23:09:14 <dons> haha.
23:09:16 <ddarius> jabbering is also an American word
23:09:20 <dons> she's got a surprisingly strong accent.
23:09:27 <thetallguy> dons: every time she made a joke, she did it in an American accent
23:09:32 <dons> oh heh
23:09:46 <cygnus_> are you losing your accent dons
23:09:51 <thetallguy> dons: it turns out it's because her fundamental exposure to comedy was watching MASH
23:09:57 <dons> somewhat. enough that my parents notice.
23:10:05 <thetallguy> dons: so she says all her jokes in Alan Alda's voice.
23:10:07 <dons> and i say things like gas and cellphone
23:10:08 <Adamant> dog's breakfast works in American, it's just very uncommon outside of certain professions
23:10:13 <dons> thetallguy: haha
23:10:21 <cygnus_> haskell is a gas
23:10:26 <Adamant> usually military-related ones
23:10:42 <thetallguy> The soccer announcers keep saying ``He made a meal of it.''
23:10:44 <ddarius> I think most people would be able to gather the intent.
23:10:58 <Adamant> of course
23:11:04 <thetallguy> I've never heard an etymology of that.
23:11:12 <Adamant> but there's active use of it in the military
23:11:28 <ddarius> Adamant: I haven't noticed it.
23:11:29 <dons> "fortnight" was another one.
23:11:44 <Adamant> yeah, that is consider archaic here
23:11:50 <dons> i was surprised by that.
23:12:12 <dons> "arvo" is another good one.
23:12:26 <Adamant> arvo = afternoon?
23:12:28 <dons> yeah
23:12:42 <cygnus_> how did throw a shrimp on the barbie get started
23:12:44 <cygnus_> we don't say shrimp
23:12:53 <Adamant> it's a joke
23:12:55 <dons> advertising campaign in the 80s
23:13:01 <Adamant> from the movie "Dumb And Dumber"
23:13:05 <dons> no no.
23:13:13 <dons> kids these days.
23:13:17 <thetallguy> I know a guy who went to U. Waterloo.  He said they always joked that Guelph sounded like a dog vomiting.
23:13:26 <Adamant> oh, so they got if from the advertising campaign
23:13:28 <thetallguy> Any relation to a dog's breakfast?
23:13:37 <Adamant> exactly
23:13:48 <dons> http://www.youtube.com/watch?v=i2kzjxq0uuQ
23:14:13 <cygnus_> the land of wunda
23:14:51 <dons> its all normal until he talks about "shrimp".
23:14:57 <cygnus_> what a dick
23:15:04 <Adamant> lol
23:15:10 <dons> it'd be rissoles or bangers or chops
23:15:14 <Adamant> why do Aussie love to hate Paul Hogan?
23:15:21 <dons> heh. over exposure
23:15:24 <cygnus_> cause he doesn't say prawn
23:15:25 <Adamant> I thought you called them prawns
23:15:27 <Adamant> ah
23:15:43 <Adamant> I think prawns are something different here
23:15:46 <dons> yeah, but you don't have prawns that often. and not on a bbq
23:15:48 <Adamant> can't remember
23:16:00 <cygnus_> it's the same
23:16:31 <jeffwheeler> In the US, I think prawns usually refer to something slightly larger.
23:16:31 <jeffwheeler> Perhaps just large shrimp?
23:16:38 <Adamant> cygnus_: I know they're used for shrimp, but I think they're also used for another animal
23:16:50 <cygnus_> yabbis?
23:17:12 <thetallguy> Prawns are a different critter
23:17:33 <Adamant> dons: does Outback Steakhouse make you laugh or make you stabby?
23:17:42 <thetallguy> similar, but different, so I think there's a lot of confusion.
23:17:42 <dons> stabby.
23:17:56 <cygnus_> there is outback stakehouse in australia now
23:17:59 <dons> hah
23:18:10 <thetallguy> They have a cool theme song.
23:18:11 <Adamant> OMG
23:18:20 <thetallguy> At least, the original was pretty cool.
23:18:23 <Adamant> on behalf of America, I apologize.
23:18:27 <dons> 'sok. i have a giant jar of vegemite. i'll survive.
23:18:29 <cygnus_> do you have a youtube link to it?
23:18:49 <Adamant> Outback Steakhouse in the US is one thing
23:19:04 <Adamant> exporting it to Australia is madness
23:19:05 <dons> the ads have an over-the-top accent
23:19:12 <dons> hogan-esque.
23:19:15 <thetallguy> The Europeans use Nutella as survival food, the Australians vegemite, the British marmite.
23:19:19 <cygnus_> ye i wanna punch him
23:19:56 <Adamant> unfortunately they don't serve fried chicken in European mess halls, so Southerners are SOL
23:20:02 <dons> btw, here's a photo of me age 7 with my pet kangaroo. http://galois.com/~dons/images/farm/new/Don_Ruby_Roo_1987.jpg
23:20:14 <dons> which apparently didn't like getting a hug.
23:20:25 <Adamant> pettting zoo?
23:20:29 <Adamant> or actual pet?
23:20:34 <dons> pet. that's my backyard.
23:20:38 <Adamant> whoa
23:20:46 <Adamant> I didn't know you could keep them as pets.
23:20:54 <thetallguy> I have no images to counter that.
23:20:59 <ddarius> dons: Are you trying to kill it?
23:21:02 <cygnus_> ahah
23:21:18 <dons> well, they jump around a lot, ddarius
23:21:21 <jsn> dons: aren't they dangerous?
23:21:23 <dons> esp. when happy.
23:21:28 <Megzlna> What exactly is () in the context of (\() -> 1) ()  ...it appears to indicate an empty tuple in the way that  (), 1, (1,2), (1,2,3)  sequence.  no?
23:21:29 <dons> jsn: when they're bigger
23:21:32 <Adamant> the adults definitely are
23:21:36 <Adamant> they get claws and shizz
23:21:43 <dibblego> Megant, correct, also called "the unit value"
23:21:45 <cygnus_> they can kick you in the scrotum and you die
23:21:53 <dons> one of the guys at work said "that's a huge rabbit!"
23:21:59 <Megzlna> Why "the unit value" ?
23:22:00 <Adamant> ow
23:22:11 <Cale> Megzlna: Because it's the unit for (,)
23:22:21 <dons> > () :: ()
23:22:22 <lambdabot>   ()
23:22:23 <Megzlna> oh
23:22:24 <dons> yay singletons
23:22:26 <Cale> (a,()) is (roughly) isomorphic to a
23:22:33 <thetallguy> dons: you're sure he wasn't talking about you?
23:22:34 <jsn> Megzlna: there can be only one
23:22:38 <dons> thetallguy: :P
23:22:57 <thetallguy> I'm puzzled by how small the shadow of the head is.
23:23:14 <cygnus_> photoshopped nicely spotted
23:23:18 <dons> hah
23:23:33 <dons> but not by  the giant rabbit?
23:23:58 <Adamant> I am horrible with determining Photoshopped or not
23:24:01 <thetallguy> also, ``dons'' right forearm looks significantly larger than his left
23:24:07 <Adamant> is that Photoshopped or not?
23:24:11 <Megzlna> Cale: why Roughly?
23:24:12 <Adamant> for realz
23:24:37 <dons> no, its not. dear oh dear.
23:24:38 <thetallguy> And there's a UFO in the upper right hand corner
23:24:48 <Adamant> I want to believe that you can keep a kangaroo as a pet
23:24:56 <Adamant> and put boxing gloves on him
23:24:59 <thetallguy> Clearly, the whole thing is a conspiracy.
23:25:11 <Adamant> and make him welterweight boxing champion of the world
23:25:12 <Cale> Megzlna: Because _|_ and (a, _|_) are not the same thing
23:25:31 <Cale> Megzlna: (a,()) has a few too many values when you consider partially-defined things
23:26:09 <Megzlna> Too many values when viewed from what other part of Haskell?
23:26:10 <thetallguy> btw, I actually stopped by to ask...
23:26:31 <thetallguy> what's the best associated type reference/tutorial around?
23:26:39 <dons> thetallguy: hmm. there's been some blog posts.
23:26:58 <dons> but probably the wiki
23:27:01 <Megzlna> I mean to say, can Haskell know that? Or can you only think it in theory
23:27:09 <dons> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions ?
23:27:14 <thetallguy> I've been having a deuce of a time with types in HSP, and I finally gave up and decided I needed to open the hood and look...
23:27:31 <dons> does HSP use associated types?
23:27:37 <dons> haskell server pages?
23:27:38 <thetallguy> ...and damned if I didn't find associated types, which was a complete surprise.
23:27:49 <thetallguy> Yes, HSX/HSP
23:27:52 <dons> huh.
23:27:53 <thetallguy> The XML types
23:28:02 <dons> oh, in hsx, all the arrows-ish stuff?
23:28:06 <thetallguy> HSX uses classes to represent the XML
23:28:20 <thetallguy> Hmm.
23:28:30 <thetallguy> We plan to make it AFish, not arrow ish
23:28:31 <dons> Heffalump has been doing a lot over the years, in terms of applying them in practice. he might be a good recommender
23:28:42 <dons> thetallguy: so extending hsx?
23:28:48 <thetallguy> but it's all monad transformers right now, which is overkill.
23:28:55 <thetallguy> Cleaning it up, really.
23:29:08 <thetallguy> stepcut has sketched it out, but not implemented it.
23:29:22 <dons> mmm. interesting.
23:29:37 <thetallguy> His suspicion is that the associated types go away if the monads are replaced by AF
23:29:38 <Cale> Megzlna: You can tell
23:29:56 <thetallguy> I haven't studied it as closely as he, but I definitely get that feeling
23:30:11 <Cale> > fst (1, undefined)
23:30:12 <lambdabot>   1
23:30:33 <thetallguy> The need for IO, state and reader access is all tied together and it doesn't really need to be
23:30:33 <Cale> > fst (1, ())
23:30:34 <lambdabot>   1
23:30:42 <Cale> > snd (1, ())
23:30:43 <lambdabot>   ()
23:30:46 <thetallguy> HSP is great until you get a type error.
23:30:47 <Cale> > snd (1, undefined)
23:30:48 <lambdabot>   * Exception: Prelude.undefined
23:31:23 <thetallguy> I steadfastly refused to explore underneath the hood for a long time, because I didn't want to swap in that complexity.
23:31:46 <thetallguy> But when we started to do heavier stuff, there was simply no choice.
23:31:57 <dons> you rely on heavy types?
23:32:04 <dons> so e.g. not using the galois xml lib?
23:32:13 <thetallguy> no, HSP has it's own
23:32:35 <thetallguy> HSX uses classes to represent XML, HSP has the concrete data type.
23:32:55 <thetallguy> It's closely tied to the whole parsing set up.
23:33:26 <thetallguy> It would be nice if one didn't have to make a choice.
23:33:45 <thetallguy> but the world of XML and Haskell is enough to give one brain damage.
23:33:54 <thetallguy> So we settled one HSP.
23:33:59 <thetallguy> s/one/on
23:34:02 <erikc> XML alone is enough to give brain damage
23:34:11 <thetallguy> erikc: ack
23:34:22 <erikc> ;)
23:34:33 <thetallguy> worse, I'm wrangling CSS
23:35:07 <thetallguy> The language used to format XML, the universal language, which was not used to represent CSS.
23:35:25 <Megzlna> well, the tuple of unit values has a value itself
23:35:33 <Megzlna> > let f ((),()) = 1 in f
23:35:34 <lambdabot>       Overlapping instances for Show (((), ()) -> t)
23:35:34 <lambdabot>        arising from a us...
23:35:39 <thetallguy> It's a good think I don't know anyone who works for the W3C.
23:35:47 <Megzlna> > let f ((),()) = 1 in f ((),())
23:35:48 <lambdabot>   1
23:36:25 <Megzlna> ((),()) is like the value '2'
23:36:31 <thetallguy> Oh, here's a fun exercise.
23:36:58 <thetallguy> write uncamel,which takes a string such as CamelCaseVariableName
23:37:17 <thetallguy> and puts spaces between the words.
23:37:28 <thetallguy> using combinators from Data.List
23:37:57 <thetallguy> I found it trivial to write using a recursive function with pattern matching
23:38:25 <thetallguy> but five minutes spent poring over Data.List did not give me an elegant solution.
23:38:49 <thetallguy> no leading space.
23:38:55 <Megzlna> This is interesting:
23:38:58 <Megzlna> > let f ((),(),(),(),()) = 5; f _ = 4
23:38:59 <lambdabot>   <no location info>: parse error on input `;'
23:39:14 <Megzlna> > let f ((),(),(),(),()) = 5; f _ = 4 in f 1
23:39:15 <lambdabot>       No instance for (Num ((), (), (), (), ()))
23:39:15 <lambdabot>        arising from the lite...
23:39:19 <erikc> i'd do a concat of an iterate of a takeWhile...but the takeWhile needs to be takeWhile2nd to accept a first capital letter
23:39:33 <thetallguy> erikc: yeah, I thought of that.
23:39:35 <Megzlna> well, on my GHCI, it said:   Warning: Pattern match(es) are overlapped
23:39:43 <Megzlna> Because there's no other possible type for (())
23:39:44 <thetallguy> but it didn't fit my definition of elegant.
23:39:48 <erikc> hehe
23:40:52 <Megzlna> @let fff ((),(),(),(),()) = 5; fff _ = 4
23:40:53 <lambdabot>  <local>:9:0:
23:40:53 <lambdabot>      Warning: Pattern match(es) are overlapped
23:40:53 <lambdabot>               In...
23:41:20 <thetallguy> I often find the problems that need a window of values to be a little trickier.
23:41:33 <thetallguy> Although I think I just got the answer
23:42:35 <Megzlna> heh back on task with useful Haskell ;)
23:43:12 <erikc> parsing DWARF in haskell is such a joy
23:44:19 <dons> oh, you going to add it to  the elf library/
23:44:43 <dons> working on a whole set of executable parsers?
23:44:54 <erikc> yea, i think im gonna do a whole set
23:45:08 <dons> getElf :: ByteString -> Elf
23:45:12 <dons> beautiful
23:45:16 <erikc> but the dwarf will be a separate lib, you use libmacho/libcoff/libelf to pull the dwarf sections out
23:45:26 <erikc> then you pass the dwarf sections to libdwarf
23:45:27 <thetallguy> it's a fold.
23:45:48 <thetallguy> Cheers.
23:46:00 <dons> i'm so glad that worked, erikc. its a classic example of when to use Data.Binary
23:46:06 <dons> unGet getElf_Ehdr $ L.fromChunks [b]
23:46:08 <dons>  is just great.
23:46:32 <dons> i'd probably strictify and unpack the atomic components of all the types
23:46:37 <dons> e.g.    , elfSectionAddr      :: Word64
23:46:40 <dons> to     , elfSectionAddr      :: !Word64
23:46:52 <dons> otherwise, perfect.
23:46:52 <erikc> ok
23:46:57 <erikc> any tips you have are welcome :)
23:47:01 <dons> (compile with -funbox-strict-fields -O2)
23:47:12 <dons> performance ok?
23:47:24 <erikc> yea, elfs dont have many sections, ~50
23:47:30 <dons> its a ridiculously elegant parser :)
23:47:53 <dons> oh, that's interesting:
23:47:53 <dons>   map B.w2c $ B.unpack
23:48:03 <dons> I think that's C.unpack ?
23:48:08 <dons> Data.ByteString.Char8 ?
23:48:39 <erikc> oh, can i intermix a bytestring and a bytestring.char8?
23:48:43 <dons> unpack = P.map w2c . B.unpack
23:48:46 <dons> yes.
23:48:49 <erikc> k
23:48:53 <dons> they're the same type. but Char8 adss w2c conversions
23:49:07 <dons> e.g.
23:49:07 <dons> map :: (Char -> Char) -> ByteString -> ByteString
23:49:07 <dons> map f = B.map (c2w . f . w2c)
23:49:32 <cygnus_> who invented map
23:49:43 <dons> the elder ones.
23:50:30 <pumpkin> it would be nice to put things like map into a Mappable typeclass
23:50:43 <pumpkin> to avoid X.map
23:50:59 <dons> in Traversable?
23:51:11 <dons> fmap /
23:51:23 <dons> > fmap toUpper "haskell"
23:51:24 <lambdabot>   "HASKELL"
23:51:28 <dons> :t fmap
23:51:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:51:48 <dons> bytestrings don't have enough type structure though
23:51:56 <dons> they're opaque, atomic-ish types.
23:52:14 <erikc> dwarf is fun cause its a very compressed encoding for a graph of property bags, and to know how to parse the blob of bags, each bag is an index into a table of binary layout descriptors
23:52:23 <pumpkin> ah
23:52:36 <erikc> so i build up Get actions at runtime based on the descriptor table
23:53:22 <Megzlna> It's kind of odd how point-free / pointless style is full of points.
23:54:18 <Megzlna> f = g . h . i . j 10 -- now why on earth would somebody call this pointless.
23:55:55 <intrados> is anyone familiar with the various sound packages from hackage, and if so, how did you go about learning them because most of them seem to be rather poorly documented?
23:56:22 <pumpkin> Megzlna: http://www.haskell.org/haskellwiki/Pointfree
23:58:24 <Megzlna> thanks
23:58:36 <erikc> intrados: do you mean opengl?
23:58:38 <erikc> err, openal
