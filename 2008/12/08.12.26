00:00:01 <buu> The movie. Jesus.
00:00:04 <FunctorSalad> Elly: ah. didn't know there was a difference between @ and :
00:00:06 <Elly> oh, that
00:00:11 <buu> You nerd.
00:00:23 <FunctorSalad> movie?
00:00:26 <Elly> buu: *you're* in #haskell
00:00:28 <Elly> buu: *you* nerd :P
00:00:35 <buu> Elly: I'm, uh, looking for someone.
00:00:46 <Elly> uh-huh
00:00:56 <Elly> admit it! You are enticed by the purity and the higher-order functions!
00:00:58 <FunctorSalad> 26$ in his hand
00:01:02 <mmorrow> bryan1: this is a really useful function for Map
00:01:09 * mmorrow scrolls back in history
00:01:09 <Elly> to say nothing of the zygomorphic prepromorphisms
00:01:25 <mmorrow> collect (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
00:01:32 <mmorrow> @type collect_
00:01:33 <lambdabot> forall a b k. (Ord k) => (a -> a -> a) -> (b -> k) -> (b -> a) -> [b] -> M.Map k a
00:01:43 <buu> Elly: No, I was enticed by your bot
00:01:53 <mmorrow> (Ord b) => (c -> c -> c) -> (a -> b) -> (a -> c) -> [a] -> Map b c
00:02:10 <mmorrow> (i had to use collect_ since collect is already take in lambdabot)
00:02:20 <ddarius> :t collect
00:02:21 <lambdabot>     Ambiguous occurrence `collect'
00:02:21 <lambdabot>     It could refer to either `L.collect', defined at <local>:10:0
00:02:21 <lambdabot>                           or `Test.QuickCheck.collect', imported from Test.QuickCheck
00:02:27 <Elly> :t Control.Morphism.Zygo.distZygoT
00:02:28 <lambdabot> Couldn't find qualified module.
00:02:32 <Elly> :t Control.Morphism.Zygo
00:02:33 <lambdabot> Couldn't find qualified module.
00:02:33 <pumpkin> oh wow, bible on dvd ad on tv
00:02:35 <Elly> interesting
00:02:38 <mmorrow> > collect_ (+) fst snd [(111,1),(111,2),(113,4)]
00:02:39 <lambdabot>   fromList [(111,3),(113,4)]
00:02:52 <mmorrow> > collect_ (++) fst ((:[]) . snd) [(111,1),(111,2),(113,4)]
00:02:53 <lambdabot>   fromList [(111,[2,1]),(113,[4])]
00:03:24 <mmorrow> > collect_ IntSet.union fst (IntSet.singleton . snd) [(111,1),(111,2),(113,4)]
00:03:25 <lambdabot>       Failed to load interface for `IntSet':
00:03:25 <lambdabot>        Use -v to see a list of t...
00:03:33 <ddarius> > collect_ (++) fst (return . snd) [(111,1),(111,2),(113,4)]
00:03:33 <mmorrow> > ISet.empty
00:03:34 <lambdabot>   fromList [(111,[2,1]),(113,[4])]
00:03:34 <lambdabot>       Failed to load interface for `ISet':
00:03:34 <lambdabot>        Use -v to see a list of the...
00:03:39 <mmorrow> > IS.empty
00:03:41 <lambdabot>   /tmp/8549199191086303523:70:32: Not in scope: `IS.empty'
00:03:47 <mmorrow> > Set.empty
00:03:48 <lambdabot>   fromList []
00:03:55 <mmorrow> > collect_ Set.union fst (Set.singleton . snd) [(111,1),(111,2),(113,4)]
00:03:56 <lambdabot>   fromList [(111,fromList [1,2]),(113,fromList [4])]
00:04:13 <buu> Elly: Can you make the lambdabot do plugin composition?
00:04:19 <mmorrow> @.
00:04:19 <lambdabot> Not enough arguments to @.
00:04:20 <pumpkin> :t collect_
00:04:21 <lambdabot> forall a b k. (Ord k) => (a -> a -> a) -> (b -> k) -> (b -> a) -> [b] -> M.Map k a
00:04:27 <mmorrow> @. elite nixon
00:04:27 <lambdabot> \/0tErS QUiCkLy ph0R937 w|-|a7 a /\/\4N zAyz.
00:04:32 <cjs> http://hpaste.org/13330
00:04:32 <pumpkin> lol
00:04:44 <mmorrow> elite nixon always makes me lol
00:04:56 <Elly> buu: no idea; it's not mine
00:05:09 <buu> mmorrow: What does that do?
00:05:11 <mmorrow> buu: with @.
00:05:15 <pumpkin> @. pl djinn (a -> b) -> b
00:05:16 <lambdabot> (line 1, column 1):
00:05:16 <lambdabot> unexpected "-"
00:05:16 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:05:20 <pumpkin> hmm
00:05:28 <cjs> Is Num appropriate for b? I don't think there's anything more general.
00:05:32 <buu> mmorrow: Is that two commands, nixon and elite?
00:05:36 <mmorrow> yes
00:05:39 <buu> lambdabot: nixon
00:05:39 <mmorrow> @nixon
00:05:40 <lambdabot> Your boys will be home for Christmas.
00:05:44 <cjs> Though a should really be Just Eq, not Ord, except I'm lazy and use sortBy.
00:05:49 <buu> mmorrow: What does the '.' mean?
00:05:50 <pumpkin> @elite ohai iz in ur botz, writin ur msgs
00:05:51 <lambdabot> oh4I Is in ur BOTZ, wRi+iN ur MsG5
00:05:52 <mmorrow> @elite forty two
00:05:52 <lambdabot> FoR7Y TW0
00:06:01 <Elly> I'd just like to point out, lest we get large egos, that the type of g_zygo is (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> FixF f -> a
00:06:11 <mmorrow> @. vixen nixon
00:06:11 <lambdabot> i'm 19
00:06:14 <mmorrow> haha
00:06:17 <mmorrow> @. vixen nixon
00:06:17 <lambdabot> there are a lot of weirdos on here
00:06:17 <pumpkin> @vixen
00:06:18 <lambdabot> hahaha.
00:06:26 <pumpkin> @help vixen
00:06:26 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
00:06:30 <FunctorSalad> @vixen who?
00:06:30 <lambdabot> that's a good question, who?
00:06:42 <mmorrow> @vixen have you ever scuba in aruba???
00:06:42 <lambdabot> no
00:06:52 <mmorrow> @vixen have you ever not scuba in aruba???
00:06:52 <lambdabot> i think you know the answer to that one, silly
00:07:02 <mmorrow> @vixen have you ever not scuba in unaruba???
00:07:02 <lambdabot> nevermind about that
00:07:03 <ddarius> mmorrow: She has you there.
00:07:13 <mmorrow> ddarius: hah, she really does.
00:07:39 <buu> mmorrow: Anyway, what was the function of the . part of the @. command?
00:07:52 <mmorrow> the plugin is called "." :)
00:07:56 <FunctorSalad> @help .
00:07:57 <lambdabot> . <cmd1> <cmd2> [args].
00:07:57 <lambdabot> . [or compose] is the composition of two plugins
00:07:57 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
00:08:28 <Elly> haha
00:08:32 <Elly> I like the use of >>= there
00:08:37 <Elly> @botsnack
00:08:37 <lambdabot> :)
00:08:38 <buu> It only works on two commands?
00:08:38 <lunabot>  :)
00:08:46 <Elly> buu: you can compose .s :)
00:08:53 <buu> Oh, er.
00:08:57 <buu> Right.
00:09:05 * buu gains enlightenment.
00:09:07 <mmorrow> @. vixen . vixen nixon
00:09:08 <lambdabot> really!?
00:09:24 <ddarius> @help @
00:09:25 <lambdabot>  @ [args].
00:09:25 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
00:09:25 <lambdabot>  The commands are right associative.
00:09:25 <lambdabot>  For example:    @ @pl @undo code
00:09:25 <lambdabot>  is the same as: @ (@pl (@undo code))
00:09:32 <Elly> hehe
00:09:34 <Elly> I love @pl
00:09:41 <crathman> I've a question from my recent efforts to clean up my Haskell translation for SICP  http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages
00:09:47 <Elly> @djinn (a -> b -> c) -> (a * b -> c)
00:09:47 <lambdabot> Cannot parse command
00:09:48 <crathman> I have:
00:09:49 <crathman> carmichael n = do
00:09:51 <crathman>    t <- (fast_prime n 100)
00:09:51 <Elly> oh, I did it wrong
00:09:52 <crathman>    return (t && not (prime n))
00:09:58 <ddarius> crathman: Hey Chris
00:10:14 <Elly> @djinn (a -> b -> c) -> (a, b) -> c
00:10:15 <lambdabot> f a (b, c) = a b c
00:10:16 <ddarius> @djinn f :: (a -> b -> c) -> (a,b) -> c
00:10:16 <lambdabot> Cannot parse command
00:10:20 <Elly> there we go
00:10:25 <Elly> @djinn just takes a type
00:10:25 <lambdabot> -- f cannot be realized.
00:10:30 <Elly> unless you do that
00:10:30 <crathman> how do I write the carmichael function without do notation?  and how to get rid of the temp variable?  Thanks
00:10:52 <FunctorSalad> carmichael n = filter (not . prime) (fast_prime n 100)          -- crathman
00:11:25 <ddarius> carmicheal n = (&& not (prime n)) <$> fast_prime n 100
00:11:32 <ddarius> s/ea/ae
00:11:55 <crathman> FunctorSalad:  yes that would be a better solution (but I am trying to stay semi-faithful to the scheme)
00:12:18 <FunctorSalad> crathman: sorry, I misunderstood fast_prime (thought it returned all fast primes up til 100(
00:12:19 <FunctorSalad> )
00:12:19 <FunctorSalad> )
00:12:48 <mmorrow> @src Cont callCC
00:12:49 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
00:12:56 <mmorrow> @. djinn type \f -> Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
00:12:58 <lambdabot> f a =
00:12:58 <lambdabot>     Cont (\ b ->
00:12:58 <lambdabot>           case a (\ c -> Cont (\ _ -> b c)) of
00:12:58 <lambdabot>           Cont d -> d b)
00:13:05 <crathman> ddarius and FunctorSalad...  thanks
00:13:38 <Elly> @djinn a => Maybe a
00:13:38 <lambdabot> Cannot parse command
00:13:41 <Elly> aw :(
00:13:44 <Elly> I wrong did it again
00:13:49 <mmorrow> @djinn a -> Maybe a
00:13:50 <lambdabot> f = Just
00:14:29 <mmorrow> @djinn ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
00:14:29 <lambdabot> f a b = a (\ c _ -> b c) b
00:14:39 <mmorrow> @src Cont callCC
00:14:39 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
00:14:46 <mmorrow> @unmtl Cont
00:14:46 <lambdabot> err: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
00:14:49 <mmorrow> @unmtl Cont r a
00:14:49 <lambdabot> (a -> r) -> r
00:15:04 <mmorrow> @. djinn unmtl Cont r a
00:15:05 <lambdabot> -- f cannot be realized.
00:15:24 <mmorrow> @. djinn unmtl ReaderT env (Cont r) a
00:15:24 <lambdabot> -- f cannot be realized.
00:15:29 <mmorrow> @unmtl ReaderT env (Cont r) a
00:15:29 <lambdabot> env -> (a -> r) -> r
00:15:30 <ddarius> @unmtl a -> Cont r a
00:15:30 <lambdabot> a -> Cont r a
00:15:41 <mmorrow> @unmtl ReaderT a (Cont r) a
00:15:41 <lambdabot> a -> (a -> r) -> r
00:15:46 <mmorrow> @. djinn unmtl ReaderT a (Cont r) a
00:15:47 <lambdabot> f a b = b a
00:16:15 <mmorrow> nice, i didn't know @unmtl can handle any type sig
00:16:31 <mmorrow> err, i guess it can't really
00:16:37 <FunctorSalad> crathman: what I had in mind was: carmichaelUpTo m = filter (\n -> not (prime n) && fast_prime n 100) [1..m]
00:16:38 <mmorrow> @. unmtl unmtl a -> Cont r a
00:16:39 <lambdabot> a -> Cont r a
00:17:00 <FunctorSalad> crathman: of course that's not what you were looking for but I couldn't let my previous nonsense stand ;)
00:17:09 <mmorrow> @unmtl State (a -> Cont r a) a
00:17:09 <lambdabot> (a -> Cont r a) -> (a, a -> Cont r a)
00:17:13 <ddarius> @@ a -> (@unmtl Cont r a)
00:17:14 <lambdabot>  a -> (a -> r) -> r
00:17:17 <mmorrow> nice
00:17:22 <mmorrow> @help @
00:17:22 <lambdabot>  @ [args].
00:17:22 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
00:17:22 <lambdabot>  The commands are right associative.
00:17:22 <lambdabot>  For example:    @ @pl @undo code
00:17:22 <lambdabot>  is the same as: @ (@pl (@undo code))
00:17:36 <mmorrow> zomg
00:18:01 <ddarius> mmorrow: @@ allows arbitrary computation for @ commands
00:19:46 <mmorrow> @@ @run (\s -> unwords . ("\\":) . fmap (\w -> if w=="=" then "->" else w) . drop 1 . words $ s) @src Cont callCC
00:19:47 <lambdabot>       Overlapping instances for Show (String -> String)
00:19:47 <lambdabot>        arising from a...
00:20:07 <mmorrow> @@ @run id @src Cont callCC
00:20:08 <lambdabot>       Overlapping instances for Show (a -> a)
00:20:08 <lambdabot>        arising from a use of `s...
00:20:08 <Elly> @src Data.Maybe.Maybe.>>=
00:20:09 <lambdabot> Source not found. I feel much better now.
00:20:17 <mmorrow> @@  @src Cont callCC
00:20:27 <ddarius> > id
00:20:28 <lambdabot>       Overlapping instances for Show (a -> a)
00:20:28 <lambdabot>        arising from a use of `s...
00:20:33 <mmorrow> oh
00:20:35 <Elly> @help @unmtl
00:20:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:20:42 <Elly> @help unmtl
00:20:43 <lambdabot> unroll mtl monads
00:20:48 <mmorrow> @@ @run (id (@src Cont callCC))
00:20:49 <lambdabot>       Overlapping instances for Show (a -> a)
00:20:49 <lambdabot>        arising from a use of `s...
00:20:54 <mmorrow> @@ @run (@src Cont callCC))
00:20:55 <lambdabot>   <no location info>: parse error on input `)'
00:20:56 <mm_freak_> @unmtl State s
00:20:57 <lambdabot> err: `State s' is not applied to enough arguments, giving `/\A. s -> (A, s)'
00:21:01 <mm_freak_> @unmtl State s a
00:21:02 <lambdabot> s -> (a, s)
00:21:09 <mmorrow> @@ @run let (@src Cont callCC) in callCC
00:21:10 <lambdabot>       Overlapping instances for Show (((a -> m b) -> m a) -> m a)
00:21:10 <lambdabot>        aris...
00:21:18 <mmorrow> @@ @type let (@src Cont callCC) in callCC
00:21:19 <lambdabot>  forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
00:21:28 <ddarius> @@ @run reverse "(@src Cont callCC)"
00:21:29 <lambdabot>   ")CCllac tnoC crs@("
00:21:36 <ddarius> kuso
00:21:38 <mm_freak_> @unmtl StateT s m a
00:21:39 <mmorrow> that's what i'm looking for
00:21:39 <lambdabot> s -> m (a, s)
00:21:50 <mmorrow> @@ @run (\s -> unwords . ("\\":) . fmap (\w -> if w=="=" then "->" else w) . drop 1 . words $ s) "@src Cont callCC"
00:21:51 <lambdabot>   "\\ Cont callCC"
00:22:05 <mmorrow> @@ @run (\s -> unwords . ("\\":) . fmap (\w -> if w=="=" then "->" else w) . drop 1 . words $ s) "(@src Cont callCC)"
00:22:06 <lambdabot>   "\\ Cont callCC)"
00:22:10 <mm_freak_> @unmtl StateT s (StateT s Maybe) a
00:22:11 <lambdabot> s -> s -> Maybe (a, s, s)
00:22:29 <mmorrow> @@ @run "(@src Cont callCC)"
00:22:30 <lambdabot>   "(@src Cont callCC)"
00:22:42 <mmorrow> oh, i'm retahded
00:23:21 <mmorrow> doesn't look like what i'm trying to do is possible (?)
00:23:34 <ddarius> mmorrow: It's possible... somehow.
00:23:50 <crathman> <$>
00:23:52 <ddarius> @@ @run reverse (@src Cont callCC)
00:23:53 <lambdabot>       Overlapping instances for Show ([a] -> [a])
00:23:53 <lambdabot>        arising from a use o...
00:23:58 <mmorrow> ddarius: that's the spirit
00:24:02 <ddarius> @@ @run reverse @echo (@src Cont callCC)
00:24:03 <lambdabot>   <no location info>: parse error on input `;'
00:24:10 <ddarius> @@ @echo (@src Cont callCC)
00:24:11 <lambdabot>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "ddarius!n=derek@74.196.23.233", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo (@src Cont callCC)"]}
00:24:11 <lambdabot> rest:""
00:24:11 <mmorrow> @echo 4242
00:24:11 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "mmorrow!n=link@c-98-193-60-208.hsd1.il.comcast.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo 4242"]
00:24:12 <lambdabot> } rest:"4242"
00:24:19 <mmorrow> haha
00:25:45 <mmorrow> @type id
00:25:46 <lambdabot> forall a. a -> a
00:26:00 <ddarius> @@ "@src Cont callCC"
00:26:00 <lambdabot>  "@src Cont callCC"
00:27:03 <FunctorSalad> trying to get Parsec... is there a less clumsy way of writing this? http://haskell.pastebin.com/m593685db
00:28:26 <FunctorSalad> the use of Maybe appears like a hack
00:29:02 <mmorrow> @help
00:29:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:29:12 <mmorrow> @plugins
00:29:13 <lambdabot> Unknown command, try @list
00:29:16 <mmorrow> @list
00:29:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:30:32 <FunctorSalad> oh wait, think I got it
00:31:00 <mmorrow> @. echo run 4*2
00:31:02 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "mmorrow!n=link@c-98-193-60-208.hsd1.il.comcast.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@. echo run
00:31:02 <lambdabot> 4*2"]} rest:"  8\n\n"
00:31:27 <mmorrow> @@ @echo @run 4*2
00:31:27 <vegai> FunctorSalad: isn't that the same as skipMany?
00:31:28 <lambdabot>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "mmorrow!n=link@c-98-193-60-208.hsd1.il.comcast.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo @
00:31:28 <lambdabot> run 4*2"]} rest:"  8\n"
00:31:32 <mmorrow> bah
00:31:40 <ddarius> @@ @run reverse @show @src Cont callCC
00:31:41 <lambdabot>   ""
00:32:02 <ddarius> @@ @show @src Cont callCC
00:32:02 <lambdabot>  ""
00:32:12 <ddarius> @@ @show (@src Cont callCC)
00:32:12 <lambdabot>  ""
00:33:27 <FunctorSalad> vegai: yeah, but skipMany doesn't return the terminating match... much simpler version: http://haskell.pastebin.com/m6572f489   :)
00:36:36 <ddarius> mmorrow: There's something bizarre with the @src command when used with @@
00:36:41 <ddarius> @@ - @src Cont callCC
00:36:52 <lambdabot>  -
00:37:02 <mmorrow> ddarius: yeah, it seems like it's outputting in a way that @@ can't see
00:37:11 <mmorrow> or something somehow
00:37:16 <mmorrow> ddarius: yeah, it seems like it's outputting in a way that @@ can't see
00:38:59 <ddarius> mmorrow: Okay, so what you want might not be possible because @src is ill behaved.
00:39:32 <mmorrow> zomg, workaround
00:39:34 <mmorrow> @@ @run (concat . lines) @show @hoogle callCC
00:39:35 <lambdabot>   "Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m...
00:40:32 <pumpkin> omg haskell redditors to the rescue! someone has called our fabulous language suck!
00:40:33 <pumpkin> http://www.reddit.com/r/programming/comments/7lpqg/source_code_to_the_original_pascal/
00:42:08 <mmorrow> @@ @djinn @run (unwords . fmap (\w -> if w == "m" then "Cont r" else w) . words . drop 1 . dropWhile (/='>') . concat . lines) @show @hoogle callCC
00:42:09 <lambdabot>  Cannot parse command
00:42:17 <mmorrow> @@ @djinn @run (text . unwords . fmap (\w -> if w == "m" then "Cont r" else w) . words . drop 1 . dropWhile (/='>') . concat . lines) @show @hoogle callCC
00:42:18 <lambdabot>  f a =
00:42:18 <lambdabot>     Cont (\ b ->
00:42:18 <lambdabot>           case a (\ c -> Cont (\ _ -> b c)) of
00:42:18 <lambdabot>           Cont d -> d b)
00:42:23 <mmorrow> victory!
00:42:35 <mmorrow> so hacktastic
00:45:23 <ddarius> @@ @pl @djinn @run (text . unwords . fmap (\w -> if w == "m" then "Cont r" else w) . words . drop 1 . dropWhile (/='>') . concat . lines) @show @hoogle callCC
00:45:24 <lambdabot>  (line 1, column 5):
00:45:25 <lambdabot> unexpected "="
00:45:25 <lambdabot> expecting variable, "(", operator or end of input
00:46:04 <ddarius> @@ @pl @djinn @run (unwords . fmap (\w -> if w == "m" then "Cont r" else w) . words . drop 1 . dropWhile (/='>') . concat . lines) @show @hoogle callCC
00:46:05 <lambdabot>  Cannot parse command
00:46:21 <mmorrow> ddarius: heh, i was just trying that in a /msg. i think the problem is that @pl doesn't understand case
00:46:43 <mmorrow> @@ @run (text . unwords . ("\\":) . fmap (\w -> if w == "=" then "->" else w) . words) @show @djinn @run (text . unwords . fmap (\w -> if w == "m" then "Cont r" else w) . words . drop 1 . dropWhile (/='>') . concat . lines) @show @hoogle callCC
00:46:46 <lambdabot>   \ f a -> Cont (\ b -> case a (\ c -> Cont (\ _ -> b c)) of Cont d -> d b)
00:46:52 <mmorrow> @pl \ f a -> Cont (\ b -> case a (\ c -> Cont (\ _ -> b c)) of Cont d -> d b)
00:46:52 <lambdabot> (line 1, column 67):
00:46:52 <lambdabot> unexpected ">"
00:46:52 <lambdabot> expecting variable, "(", operator or ")"
00:50:15 <mmorrow> @@ @type @run (text . unwords . ("\\":) . fmap (\w -> if w == "=" then "->" else w) . words) @show @djinn @run (text . unwords . fmap (\w -> if w == "m" then "Cont r" else w) . words . drop 1 . dropWhile (/='>') . concat . lines) @show @hoogle callCC
00:50:19 <lambdabot>  forall t a r a1. t -> ((a -> Cont r a1) -> Cont r a) -> Cont r a
00:51:00 <mmorrow> oh
00:51:14 <mmorrow> @@ @type @run (text . unwords . ("\\":) . drop 1 . fmap (\w -> if w == "=" then "->" else w) . words) @show @djinn @run (text . unwords . fmap (\w -> if w == "m" then "Cont r" else w) . words . drop 1 . dropWhile (/='>') . concat . lines) @show @hoogle callCC
00:51:17 <lambdabot>  forall a r a1. ((a -> Cont r a1) -> Cont r a) -> Cont r a
00:51:21 <mmorrow> woot
00:51:33 * mmorrow gets back to not wasting time
00:52:51 <Raynes> mmorrow: Wasting time is an art.
00:53:43 <Raynes> > 2+2
00:53:44 <lambdabot>   4
00:53:46 <mlesniak_> I'm compiling ghc 6.10.1 -- should it build readline support automatically if libreadline-dev exists?
00:54:04 <mmorrow> Raynes: that's the truth
00:54:22 <mmorrow> mlesniak_: 6.10.* uses editline instead of readline now :(
00:54:45 <mlesniak> mmorrow: Oh, thanks
01:06:10 <wli> Did that lose a Windows port of the line editing lib (IIRC readline worked on Windows)?
01:13:11 <azathoth99> once I get good at haskell can I forget bash shel scrits?
01:13:23 <azathoth99> can haskell do the shell scripting?
01:13:33 <pumpkin> it can do anything a shell script does :P
01:13:51 <pumpkin> in a different way, though,although chains of pipes are kinda functional
01:17:24 <Beelsebob> it would be nice to get a DSL for shell scripting though, and a shell that used runhaskell on anything you typed in
01:18:02 <pumpkin> how does runhaskell work?
01:18:20 <pumpkin> it just interprets a buffer?
01:18:37 <pumpkin> a stream, rather
01:18:48 <b_jonas> yeah
01:18:59 <b_jonas> runhaskell <<<'main = putStrLn "hello, world"'
01:19:17 <b_jonas> it's more commonly known as runghc
01:19:23 <Beelsebob> it is?
01:19:27 <b_jonas> the big problem is that it's SLOW
01:19:33 <b_jonas> it loads really slowly
01:19:52 <b_jonas> they say that's because of the package descriptions
01:20:38 <azathoth99> yah
01:20:47 <azathoth99> I mean if I can spend same hours learning haskell
01:21:01 <azathoth99> and end up being able to to repetitive aks n all with it
01:21:05 <azathoth99> then its a win eh
01:21:22 <Beelsebob> that is after all the idea of a programming language ;)
01:21:36 <azathoth99> is programming in haskell by hutton < learn you a haskell for gr8 good?
01:21:52 <Beelsebob> I've not read it personally but it's meant to be good
01:21:58 <Beelsebob> simon thompson's book is also good
01:22:05 <pumpkin> missing instance Ord for haskell readings
01:22:47 <b_jonas> for gr8 justice it is, right?
01:23:40 <pumpkin> > "programming in haskell" < "learn you a haskell for gr8 good"
01:23:41 <lambdabot>   False
01:24:05 <Beelsebob> > "programming in haskell by hutton" < "learn you a haskell for gr8 good"
01:24:07 <lambdabot>   False
01:25:27 <azathoth99> ok
01:26:31 <b_jonas> > Just "learning haskell" > Nothing
01:26:31 <azathoth99> I have these two: programming in haskell by hutton, and the haskell school of expression
01:26:33 <lambdabot>   True
01:26:59 <azathoth99> "just learning" meaning writing programs?
01:29:10 <Beelsebob>  I'd recommend the hutton book over the hudak book
01:29:30 <Beelsebob> but that's mostly because I know I don't like the hudak book much
01:29:44 <azathoth99> I really only have done bash up until now,  and am not so great even at that
01:29:46 <b_jonas> how about both?
01:29:51 <azathoth99> loops and some conditionals
01:30:23 <Beelsebob> azathoth99: well, be preparted for a bit of culture shock
01:30:23 <schme> g'day
01:30:28 <Beelsebob> Haskell is a *very* different language
01:30:45 <b_jonas> no, it's _bash_ that's a very different language
01:30:58 <b_jonas> or maybe both are, but in different ways
01:30:59 <Beelsebob> hehe
01:32:07 <azathoth99> well I like computers
01:32:11 <azathoth99> I work as linux admin
01:32:20 <azathoth99> and I am trying to go outisde my normal stuff
01:32:27 <azathoth99> to learn to control the servers I setup
01:32:37 <azathoth99> perhaps build some interactive websites
01:32:41 <Beelsebob> Haskell sounds like a good plan for you then -- it's very much outside most people's norm
01:32:54 <b_jonas> (of course you might try to learn a more down to earth programming language first and haskell only later)
01:33:07 <Beelsebob> I don't know of people who use it for server control, but I know a lot of people who consider it an excellent web engine language
01:33:36 <Beelsebob> b_jonas: My (limited) teaching experience tells me that if you ever want to learn Haskell, that's a bad plan
01:34:09 <azathoth99> I do have some thoughts that the actual computation people want done is small........like sorting or searching msotly.......and that a functional language seems to be a good idea if it lets one try to capture waht those calculations are.......reuse them.....and stuff....
01:34:25 <schme> azathoth99: haskell sounds completly useless for controlling servers imo :)
01:34:30 <b_jonas> Beelsebob: but just learning haskell can't be the goal
01:34:38 <schme> azathoth99: You want the sed and gawk and the bash ;)
01:34:55 <Beelsebob> azathoth99: I would probably say that FP's biggest strength is composability -- it really lets you break down your program into *tiny* parts, all of which easily plug together
01:35:08 <azathoth99> ok
01:35:13 <azathoth99> so for web haskell is nice
01:35:23 <azathoth99> I want to learn to produce dynamic web pages
01:35:24 <pumpkin> it's nice for lots of stuff :)
01:35:46 <Beelsebob> then yeh, Haskell is good for the server side stuff involved there azathoth99
01:35:55 <Beelsebob> once you've learned the language, look at HApps
01:36:15 <azathoth99> I know grep find cron a bit of sed
01:36:47 <schme> wow.
01:37:27 <azathoth99> sed -i s/xyz/abc/ file is very nice
01:38:26 <schme> no it's not :)
01:38:36 <schme> It's totally unportable ;)
01:38:49 <jeffz`> sed is probably on more platforms than Haskell schme
01:39:08 <Beelsebob> jeffz`: yeh, but with different syntax on every one is what schme meant I think
01:39:24 <jeffz`> oh right, yeah.. bsd sed and stuff aren't so great as GNU sed
01:40:11 <schme> jeffz`: Of course sed is everywhere.
01:40:24 <schme> jeffz`: There is just no -i on most seds :)
01:40:45 <schme> azathoth99: I say hack some haskell, but don't expect it to make your admin job any nicer :)
01:41:06 <b_jonas> but perl is everywhere so you can use perl -wpi -e s/xyz/abc/ anywhere
01:41:13 <schme> Indeed!
01:41:14 <Raynes> I've read "Learn you a Haskell for the great good!"
01:41:23 <Raynes> It's a very exception tutorial disguising as a book.
01:41:24 <Raynes> exceptional*
01:41:47 <Raynes> Or vice versa actually.
01:49:38 <cjs> It is being very exceptional, yes?
01:50:08 <cjs> Do you have a link to that?
01:50:14 <ksandstr> the name suggests lolcats
01:50:27 <cjs> Oh, found it.
01:50:28 <ksandstr> it seems to be at http://learnyouahaskell.com/ .
01:51:24 <pumpkin> it's along the same lines as the poignant guide to ruby, I think
01:51:56 <Raynes> It takes a comedic approch at teaching Haskell, without being as rediculous as Why's poignant guide to ruby.
02:06:43 <vegai> s/rediculous/funny/ if you ask me :-)
02:07:55 <Raynes> vegai: Oh don't get me wrong. It's a wonderful book. I learned ruby with it a good while ago. It's just the storys are so long, that they eventually lose their point and get boring. Most of the concepts he explains with the storys turn out to be extremely simple.
02:09:23 <smg> how about pragmatic ruby guide?
02:09:27 <Raynes> But, either way. Starmonkeys!
02:09:27 * vegai nods.
02:15:27 <hugo___> hi
02:23:09 <b_jonas> the pragmatic programmer's guide to ruby is seriously out of dater
02:23:26 <cjs> Version 2 you mean? Version 1 certainly is.
02:24:22 <hugo___> :P
02:24:37 <hugo___> isn't ruby seriously out of date  ?
02:25:10 <smg> perl6 ftw
02:25:34 <mmorrow> "... but having a program that automatically loops as long as it has to and no longer by virtue of relying on its watchers stopping correctly, that is truly a thing of beauty."
02:26:05 <mmorrow> this is an entertaining read, even if you aren't interested in using libev http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod
02:28:57 <mmorrow> also, the .css for that page is killer
02:29:17 <hugo___> i was here reading the haskell sequence, and found out this tool called "Hlint" :)
02:30:12 <hugo___> ahh, it only works with ghc 6.10.1 :( ubuntu is still behind that
02:31:10 <vegai> so are we others
02:31:19 <b_jonas> what?
02:31:23 <b_jonas> what would that do?
02:31:39 <vegai> reads through a .hs and tries to find style mistakes
02:31:40 <b_jonas> haskell is as statically typed as it can, I can't see what you could lint on it anymore
02:31:51 <b_jonas> oh, so it's like that pbp thing
02:32:14 <b_jonas> I don't want none of those
02:32:35 <b_jonas> though I'd be happy if ghc would find obviously wrong circular definitions
02:32:44 <vegai> for instance, it can tell you that f x = g x <=> f = g
02:32:45 <b_jonas> like foo = foo;
02:33:00 <hugo___> heheh
02:33:08 <b_jonas> no really
02:33:10 <b_jonas> I did that once
02:33:15 <Cthulhon> A lot of the examples I saw were pointing out where there could be eta reduction.
02:33:17 <b_jonas> and had to hunt it for half an hour
02:33:17 <hugo___> just check it output example, seems quite good actually: http://www-users.cs.york.ac.uk/~ndm/hlint/
02:33:32 <vegai> yeah, eta reduction. That's the fancy term :)
02:33:44 <vegai> sometimes good, sometimes pointless (ha!)
02:33:50 <hugo___> :)
02:34:32 <hugo___> i specilly like the point-free suggestions :)
02:34:43 <hugo___> s/specilly/specialy
02:34:47 <Cthulhon>   take 1 path == "~"
02:34:49 <Cthulhon> Why not:
02:34:49 <Cthulhon>   (1 == length "~") && ("~" `isPrefixOf` path)
02:35:02 <Cthulhon> Cleaqrly there are still bugs.
02:35:03 <vegai> yeah, that's weird.
02:35:07 <Cthulhon> *clearly
02:35:54 <jeffz`> hlint found a lot of uneeded parens in my code, nothing much else
02:36:22 <hugo___> i just ran hlint on my code, it outputed: "your code is perfect"
02:36:23 <vegai> I got some useful eta reduce stuff. -Wall -Werror was much more useful, really :)
02:37:41 <b_jonas> this is reinventing a zygohystomorphic prepromorphism, Why not: just use that from the library?
02:38:14 <pumpkin> what is?
02:39:03 <b_jonas> no, I'm just mocking the lint thing
02:39:14 <pumpkin> oh lol
02:39:29 <Cthulhon> *Zygohistomorphic :)
02:40:12 * hugo___ wonders about what "Zygohistomorphic" might be..
02:40:20 <Raynes> That's a big word.
02:40:33 <b_jonas> (unless you want a generalized zygomorphism.)
02:40:35 <Cthulhon> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
02:44:43 <pumpkin> lol, http://www.haskell.org/haskellwiki/Real_World
02:50:47 <hugo___> i think the new tagline for haskell should be: "Haskell, deprecating your favourite programming language since 1998"
02:50:49 <cizra> Haha
02:51:08 <b_jonas> why 98?
02:51:16 <hugo___> because of the report ?
02:51:22 <b_jonas> oh, that's when the standard is from
02:51:23 <b_jonas> yeah
02:52:47 <leadnose> 12:50:41 < hugo___> i think the new tagline for haskell should be: "Haskell, deprecating your favourite programming language since 1998"
02:52:53 <leadnose> oops, sorry
02:53:29 <pumpkin> @src concatMap
02:53:29 <lambdabot> concatMap f = foldr ((++) . f) []
02:53:58 <b_jonas> nice hook
03:01:13 <blackdog> does hlint not work with bang patterns?
03:01:33 <Martijn> @pl \r f a -> f %: r a
03:01:33 <lambdabot> flip ((.) . (%:))
03:14:23 <mmorrow> hehe  "... (note also that glib is the slowest event library known to man)"
03:14:50 <pumpkin> mmorrow: aren't you in the US?
03:15:01 <pumpkin> I thought I was the only one with a totally messed up sleep schedule
03:16:12 <mmorrow> pumpkin: yes and no :)
03:16:15 <b_jonas> slow event library... messed up sleep schedule
03:16:17 <b_jonas> hmm
03:16:37 <mmorrow> coincidence??
03:17:30 <pumpkin> lol
03:22:07 <Peaker> glib is an event library? I thought it was a superfluous libc extension
03:22:29 <b_jonas> Peaker: it's a library that tries to do everything, like Wx
03:22:40 <Peaker> with definitions like gint=int, and GObject that does nothing
03:22:41 <b_jonas> it has an event loop too
03:22:57 <b_jonas> but you know what it's like
03:23:08 <b_jonas> you can have lots of libraries but only one event loop in one program
03:23:21 <b_jonas> so the event loop is harder to discard
03:23:29 <b_jonas> which is why they have to support it a bit
03:24:18 * boegel installs GHC after over 2 years of not using Haskell
03:25:02 <b_jonas> wow
03:26:34 <boegel> I have several projects in mind to use Haskell for, one being implementing a genetic algorithm in it
03:26:50 <boegel> another being winning the Netflix contest using Haskell, wouldn't that be cool!
03:27:26 <mmorrow> heh
03:29:54 <pumpkin> I wonder how much information is contained in that netflix dataset
03:29:55 <boegel> the good thing is, I have experience with SVD related techniques that have worked pretty good for the other teams
03:30:14 <boegel> and I have some ideas on stuff to try that they (maybe) haven't thought about :)
03:30:15 <pumpkin> it'd be nice to prove a theoretical maximum that could be achieved on that dataset
03:30:33 <boegel> pumpkin: hmm, yeah, but the question is, can you :)
03:30:45 <pumpkin> quantify it? of course not :P
03:31:09 <pumpkin> or do better than netflix? probably a bit
03:31:19 <pumpkin> not sure I could do 10% though :P
03:32:58 <boegel> pumpkin: :)
03:33:16 <boegel> pumpkin: maybe they have a way of determining a theoretical max
03:33:25 <boegel> pumpkin: and they know you can't go above 10% :P
03:33:49 <jsn> in the framework of the lambda cube, is subtyping plain terms-depending-on-types?
03:33:52 <pumpkin> lol, I doubt they have a way of determining how much information is in that dataset, unless they generated it synthetically, and even then it's hard to quantify
03:34:18 <boegel> (lunch)
03:39:00 <cnwdup> :t fmap (a, b)
03:39:01 <lambdabot>     Couldn't match expected type `a -> b'
03:39:01 <lambdabot>            against inferred type `(Expr, Expr)'
03:39:01 <lambdabot>     In the first argument of `fmap', namely `(a, b)'
03:39:38 <mmorrow> @src fmap ((,) a)
03:39:38 <lambdabot> Source not found. Sorry.
03:40:03 <cnwdup> Is there a high-order function, that applies a function to each element of the 2-tupel?
03:40:13 <Raynes> Good morning BONUS.
03:40:17 <mmorrow> @type join (***)
03:40:18 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
03:40:26 <mmorrow> @type join (***) :: (a -> b) -> (a,a) -> (b,b)
03:40:28 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
03:41:02 <cnwdup> I think I have to read up Arrows.
03:41:55 <cnwdup> Thanks you, mmorrow.
03:43:22 <maltem> Why doesn't DEL work in a libedit-enabled ghci?
03:43:45 <Cale> add:  bind ^[[3~ ed-delete-next-char
03:43:46 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:43:50 <Cale> to your .editrc
03:44:43 <maltem> Cale: that works, thanks!
03:45:55 <maltem> (even though it behaves curiously if the cursor is at the end of the line... libedit is strange :)
03:46:40 <Cale> yeah
03:49:04 <paulvisschers_> I'm having some problems with scoped type variables in conjunction with associated types
03:49:22 <paulvisschers_> As in it won't work
03:51:58 <BONUS> good morning!! :]
03:56:41 <dancor> why does coq use its own language instead of theorem prover in haskell
03:57:11 <paulvisschers_> Pasted the problem at http://hpaste.org/13332
03:58:30 <paulvisschers_> dancor: That's like asking why C# doesn't use Python
03:59:36 <paulvisschers_> dancor: But if you want something that's a lot like Haskell, I suggest you try agda
03:59:52 <dancor> i guess i'm asking why dependent types are needed to make it kewl
04:00:28 <dancor> agda also has dependent types
04:01:06 <paulvisschers_> dancor: Typechecking is done at compile time, so the more you can do there, the less you need to do at runtime
04:01:42 <paulvisschers_> dancor: So a theorem prover in Haskell will work at runtime only
04:02:17 <paulvisschers_> dancor: Or you'd have to do so much type hackery that you'll wish for dependent types
04:04:39 <boegel>  /me continues his read of Real World Haskell
04:05:01 * boegel realizes his IRC skills aren't what they used to be
04:05:13 <paulvisschers_> :)
04:05:57 <Raynes> Good book.
04:05:58 <mattam> dancor: Haskell's type system is too weak to do formal mathematics with it.
04:06:39 <dancor> would supporting lists in djinn have to be heuristic (i.e. is it halting problem)
04:07:19 <boegel> Raynes: yeah, I like it too, but it has some annoying inconsistencies in the examples
04:07:32 * boegel moves to the couch
04:07:34 <Raynes> I have trouble concentrating while reading it.
04:07:53 <mattam> It's first-order so I think it would remain complete (there are decision procedures for the theory of lists).
04:08:19 <dancor> what about arbitrary recursive datatypes
04:10:30 <mattam> If it's arbitrary I guess not. You'd have to look into the automated reasoning literature. I think the theory of constructors (i.e. more or less algebraic datatypes) is decidable.
04:20:22 <boegel> does anyone know if Kevin Ellis sometimes drops by in here?
04:20:49 <boegel> Raynes: I don't, at all, I think it reads really easily
04:22:11 <hoknamahn> guys could you tell what's wrong with this type signature?
04:22:13 <hoknamahn> hffloop :: ([Point], [Point]) -> IO ()
04:22:29 <hoknamahn> ghci says Illegal signature in pattern: (u, v)
04:23:02 <jsn> hoknamahn: you need to give us more context
04:23:35 <ziman> hoknamahn, you might want to use http://hpaste.org
04:23:56 <hoknamahn> thanks i'll check it
04:24:12 <boegel> has anyone used hgalib by any chance?
04:28:14 <yakov> hey
04:28:54 <hoknamahn> got it. it was my fault :)
04:41:02 <abuiles> hi, I'm trying to install hsx package  but I got always the next error : src/HSX/Transform.hs:75:11:
04:41:02 <abuiles>     Constructor `Module' should have 7 arguments, but has been given 5
04:41:02 <abuiles>     In the pattern: Module s m mes is decls
04:41:03 <lambdabot> abuiles: You have 1 new message. '/msg lambdabot @messages' to read it.
04:41:40 <abuiles> any suggestion ?
04:41:47 <paulvisschers_> Why won't this work: http://hpaste.org/13332
04:45:58 <idnar> @type (&&&)
04:45:59 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:46:01 <idnar> @type (***)
04:46:02 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:47:40 <dublpaws> pumpkin: the netflix dataset decompressed is 2 GB.
04:52:26 <abuiles> someone knows the flag to tell runhaskell to use another different version of ghc rather than the last one installed ?
04:56:25 <ivanm> abuiles: runhaskell is just a wrapper script installed by ghc, etc.
04:56:58 <scook0> runhaskell: syntax: runghc [-f GHC-PATH | --] [GHC-ARGS] [--] FILE ARG...
04:57:58 <ivanm> scook0: oh? the runhaskell and runghc scripts seem to be hard-coded wrapper ones to me...
05:07:19 <abuiles> ivanm: Ok thanks, I trying to install hsx, but got an error when I'm building, when configure everything is ok, now, I tried to configure using a different version of the compiler and now it says that there are some dependencies missing, but I have those dependencies installed, do you now what can I do?
05:08:00 <boegel> dublpaws: so? (on netflix)
05:08:25 <ivanm> abuiles: which OS/distro do you use?
05:10:30 <abuiles> ivanm: ubuntu intrepid
05:11:01 <ivanm> abuiles: hmmmm.... so did you install it all yourself, or use distro packages?
05:12:15 <abuiles> I'm installing myself
05:12:38 <abuiles> ivanm:  I'm installing myself
05:12:47 <leadnose> sudo apt-get install myself
05:13:32 <ivanm> abuiles: OK, so did you just build the packages with your latest ghc, or is ghc upgraded since installing the libs?
05:13:43 <ivanm> abuiles: check out: ghc-pkg list
05:15:18 <abuiles> ivanm: I'm building the packages with the latest ghc,,,
05:16:04 <ivanm> abuiles: if the package is listed in the output of "ghc-pkg list", then ghc knows about it
05:16:13 <ivanm> if it isn't there, then ghc doesn't know about it
05:16:51 <abuiles> ivanm: the package e, Im trying to install it, I think the problem is
05:17:11 <abuiles> ivanm: forget about the last thing..
05:17:15 <ivanm> heh
05:17:58 <abuiles> ivanm: if I have 2 versions of ghc, does they go to the same package list ?
05:18:04 <ivanm> no
05:18:24 <ivanm> only whichever version was used to build it
05:18:30 <abuiles> ivanm: So I think the problem is there
05:18:51 <abuiles> how can I link  that?
05:19:10 <ivanm> rebuild all packages that were built with the old version of ghc
05:19:19 <ivanm> (where the new version is the one installed later...)
05:19:45 <abuiles> ivanm: ;(
05:20:23 <ivanm> abuiles: with the exception of gtk2hs, haskell packages generally build quickly
05:20:23 <pejo> abuiles, cabal-install will do a lot of this automatically for you
05:20:27 <ivanm> so it's not that big a deal
05:21:25 <ivanm> pejo: oh, yeah, that thing ;-)
05:21:33 * ivanm forgot about cabal-install
05:22:52 <abuiles> ivanm:  I tried with cabal, but I don't know why, It didn't recognize the packages like installed, because of that I started to build them by hand
05:23:07 <ivanm> abuiles: then it will build them... >_>
05:24:12 <abuiles> <;
05:25:14 <dnul> can anyone help me , i cant display an IArray and i cannot convert it to a list
05:26:35 <dnul> import Data.Array.IArray
05:26:36 <dnul> divisors x = [z | z <- [1,2..x] , mod x z == 0 ]
05:27:23 <ivanm> dnul: infinite array?
05:28:09 <ivanm> you'll never be able to create the array, let alone do anything with it!
05:29:22 <dnul> sorry, that line i pasted was no part of the array
05:29:43 <dnul> the problem i have is that Array type does work but IArray doesnt
05:30:41 <ivanm> dnul: uhhh...... Array is a type of IArray IIRC....
05:30:49 <ivanm> dnul: care to paste the real code up somewhere?
05:30:52 <dnul> http://www.hpaste.com/show_6.html
05:30:58 <dnul> sorry, im kinda noob
05:31:20 <cnwdup> I have a program which normal means doesn't terminate. Can I still profile it using GHC by, for instance, letting it run only 10 minutes?
05:31:37 <adh0c> hi
05:31:51 <ivanm> dnul: my guess is that it's still going to take way to long to create the list let alone create the array
05:31:53 <cnwdup> hello
05:32:03 <adh0c> what exactly is this line supposed to do?
05:32:04 <adh0c> mapEveryOther f = zipWith ($) (cycle [f,id])
05:32:26 <dnul> what i meant, is , that if using Data.Array using GHCI i can show the array in ghci but using Data.Array.IArray cant display the array
05:32:27 <ivanm> adh0c: cycle creates a list that looks like [f, id, f, id, f, id, ...]
05:33:04 <dnul> ivanm: how can i display an IArray in ghci ?
05:33:06 <adh0c> ivanm, but when I run cycle [<anyfunction>, id] in ghci it gives me an error
05:33:07 <ivanm> adh0c: so what zipWith does is take two lists, and apply the function to the elements of that list
05:33:14 <ivanm> dnul: same as for Array...
05:33:24 <cnwdup> mapEveryOther should take 2 args if I'm not mistaken, and it creates a list consisting of [f x, id x, f x, id x...] for x being the second argument.
05:33:26 <ivanm> adh0c: yes, because you can't print a function
05:33:43 <ivanm> cnwdup: not quite....
05:33:45 <adh0c> but there's nothing else left
05:33:54 <adh0c> it's only the function passed and the id function
05:34:12 <adh0c> I don't understand how this should work
05:34:12 <ivanm> it does [f a, id b, f c, id d, f e ... ]
05:34:21 <cnwdup> ivanm: Right
05:34:43 <dnul> ivanm: i guess im having some kind of trouble with that it gives me 'no instance for show' thats why i've been trying to make a list from it
05:34:50 <ivanm> adh0c: mapEveryOther (+) creates a function that takes in a list
05:35:15 <dnul> ivanm: but not succeded, (using elems function)
05:35:33 <adh0c> ivanm: why is the ($) in there?
05:35:47 <ivanm> adh0c: ($) is the application function
05:35:56 <cnwdup> adh0c: It's used to just apply the function (either f oder id) to the element of the second list.
05:35:57 <ivanm> > ($) (+1) 3
05:35:58 <lambdabot>   4
05:36:33 <ivanm> dnul: let me have a look at the array stuff again
05:37:03 <dnul> ivanm: thank you
05:37:19 <adh0c> oh I see it now
05:37:22 <adh0c> thanks
05:38:26 <ivanm> dnul: did you try with a smaller number?
05:39:10 <dnul> ivanm: err yes,  think so , but i think its not related to the number, cause if i use the Data.Array  i can display it ok
05:39:21 <dnul> ivanm: will check
05:39:39 <ivanm> dnul: ummm.... what's Mod?
05:39:45 <ivanm> did you mean mod? ;-)
05:41:26 <Raynes> Mawd.
05:42:16 <dnul> ivanm: test= array(1,2) [(1,1),(2,2)] doesnt work either
05:43:00 <ivanm> dnul: I just /msg'd you why
05:43:12 <ivanm> it's because you need to state what instance of IArray you were using
05:43:18 <ivanm> I thought it'd be something like that
05:43:47 <ivanm> note that Array is an instance of the typeclass IArray (but the Array module doesn't export the entire IArray interface)
05:45:08 <wli> > assocs (array ((1,1),(2,2)) [((1,1),1),((1,2),2),((2,1),2),((2,2),3)])
05:45:09 <lambdabot>   [((1,1),1),((1,2),2),((2,1),2),((2,2),3)]
05:45:42 <ivanm> :t array (1,2) [(1,'a'), (2,'b')]
05:45:43 <lambdabot> forall t. (Ix t, Num t) => Array t Char
05:46:25 <dnul> ivanm: im sorry, so , its the same to use Data.Array or Data.Array.IArray ?
05:47:16 <ivanm> dnul: import Data.Array.IArray, but give type signatures using Array (e.g. for sumdivisors2 you want: Int -> Array Int Int)
05:47:29 <ivanm> note that you can use Integral if you really want
05:47:48 <ivanm> IArray re-exports all of Array
05:48:20 <paulvisschers_> Why won't this work: http://hpaste.org/13332?
05:48:39 <chrisdone> is there a special syntax that allows us to bind from a {do} action straight into a case, without having to give the value a name?
05:49:10 <paulvisschers_> case (f >>=) where?
05:49:36 <chrisdone> :t (f >>=)
05:49:38 <lambdabot> forall (m :: * -> *) a b. (Monad m, SimpleReflect.FromExpr (m a)) => (a -> m b) -> m b
05:49:50 <chrisdone> can't pattern match functions
05:50:06 <chrisdone> wait, `where'? is that valid?
05:50:08 <ivanm> chrisdone: for example?
05:50:25 <chrisdone> do blah <- doesFileExist "file.ttxt"; case blah of True -> ..
05:50:26 <paulvisschers_> chrisdone: no that should be 'of', my bad
05:50:49 <chrisdone> ivanm: I can't think of a good value with good pattern matching right now
05:51:19 <ivanm> chrisdone: ahh, I don't think there's a way of simplifying that...
05:51:24 <wli> Is d n = sum [k | k <- [1 .. n], n `mod` k == 0] or d n = sum [k | k <- [2 .. n - 1], n `mod` k == 0] ?
05:51:52 <ivanm> wli: for what?
05:52:03 <ivanm> they do two different things...
05:52:07 <wli> Sum of divisors.
05:52:23 <ivanm> oh....... I was just caring about dnul's code, not what it was doing ;-)
05:52:26 <wli> ivanm: d n - d' n = n + 1, but anyway.
05:52:29 <ivanm> but I'd say the former
05:53:06 <wli> I forgot if d(n) was the sum of proper divisors or just divisors.
05:53:15 <paulvisschers_> Why won't this work: http://hpaste.org/13332?
05:53:42 <ronny> hi
05:53:58 <paulvisschers_> Hey
05:54:02 <ronny> can anyone sugest a nice haskell libs for doing 3d game?
05:54:13 <ronny> +s
05:54:29 <papermachine> HOpenGL, Reactive
05:54:49 <Axman6> HGL
05:55:07 * Axman6 sleeps
05:55:53 <ivanm> paulvisschers_: hmmm..... I think you need existential qualification as well
05:56:18 <ronny> papermachine: which one of them is more geared torwars making games?
05:56:24 <dnul> ivanm: it is working now , thx you.... can you explain me again why i have to give type signatures?
05:56:37 <papermachine> ronny: No, you'll want both of those
05:56:44 <paulvisschers_> ivanm: In what sense?
05:56:59 <ivanm> dnul: because it can't work out which type of IArray you want
05:57:00 <papermachine> HOpenGL is the Haskell OpenGL bindings, and Reactive is a library for doing time-dependent things
05:57:11 <ivanm> paulvisschers_: as another extension
05:57:28 <wli> d(m*n) = d(m)*d(n) when (m,n)=1 works for d n = sum [k | k <- [1 .. n], n `mod` k == 0]
05:57:31 <papermachine> You can do without Reactive and write everything in an imperative style, though. Look for the tutorial on Tetris using HGL.
05:57:34 <ronny> papermachine: i discovered fieldtrip, and i think that + reactive will work fine
05:57:56 <ronny> http://haskell.org/haskellwiki/FieldTrip <- looks like the stuff i want
05:58:08 <dnul> ivanm: ok. thx
05:58:24 <paulvisschers_> ivanm: Do you know the flag for it?
05:58:37 <ronny> hmm
05:59:05 <ivanm> paulvisschers_: ExistentialQualification ;-)
05:59:14 <ronny> is there any reasonable way to get a recent haskell + libs on a debian/ubuntu without going out of the package manager
05:59:18 <ivanm> put it in your {-# ... #-} section
05:59:29 <ivanm> ronny: not AFAIK
05:59:32 <paulvisschers_> ronny: The problem with both fieldtrip and reactive is that they are brand new, so there isn't a lot of documentation out there and there are some bugs
05:59:36 <ronny> dammit
05:59:57 <paulvisschers_> ronny: But they do look promising
06:00:00 <Mr-Cat> ronny: On debian - maybe there is a separate repo of .deb packages with recent haskell
06:00:01 <ivanm> ronny: AFAIK, the only distros that maintain up-to-date packages (well, usually unofficially) are gentoo and arch
06:00:17 <ronny> hmk
06:00:27 <Mr-Cat> You should google
06:00:35 <ronny> hmm
06:00:48 <paulvisschers_> ivanm: test.hs:2:1: unsupported extension: ExistentialQualification
06:01:03 <ronny> Mr-Cat: well, i found some haskell repos for debian, but nothing recent
06:01:06 <ivanm> sorry, Quantification
06:01:09 <ivanm> not Qualification
06:01:37 <Mr-Cat> Anyway, sticking to, say, ubuntu official repo is not for you if you like having recent versions of stuff
06:01:47 <paulvisschers_> ivanm: Okay, now it gives the same error as before
06:02:17 <ronny> Mr-Cat: well, i'll just switch to a more pleasant distro, ubuntu is way too much pain in various ways
06:02:20 <ivanm> *shrug* no idea then sorry
06:02:49 <Mr-Cat> ronny: That's a good idea
06:03:07 <paulvisschers_> ivanm: I actually think that ScopedTypeVariables turns on ExistentialQuantification, or you would get an error at the first function
06:03:19 <paulvisschers_> ivanm: Well thanks for trying at least :)
06:03:35 <ivanm> *shrug* I generally use extensions only when people tell me they'll fix my problem ;-)
06:03:46 <Heffalump> paulvisschers_: one sec, I think I know your problem
06:04:24 * paulvisschers_ waits in anticipation
06:05:22 <Heffalump> if it's what I think it is, it's actually fairly fundamental - since associated type synonyms aren't guaranteed fundamental, the type checker can't unify the Assoc a in the sig of h with the Assoc a in the signature of the Test class declaration and prove that they are actually the same two 'a's
06:05:49 <Heffalump> sorry, guaranteed injective, not fundamental
06:06:57 <paulvisschers_> Heffalump: So it might work with associated data types?
06:07:05 <Heffalump> yes, it should
06:07:07 <ziman> would every function have a fixpoint even if ve removed _|_ from the types?
06:07:13 <Heffalump> ziman: no
06:07:20 <Heffalump> f True = False ; f False = True
06:07:36 <paulvisschers_> Heffalump: I actually wanted to use those before, but there I can't derive Typeable
06:07:44 <ziman> hm, thanks
06:07:59 <paulvisschers_> Heffalump: That's actually a bug though, instead of a fundamental problem
06:08:16 <paulvisschers_> Heffalump: I'll try it out
06:08:48 <paulvisschers_> Heffalump: Thanks
06:08:50 <dolio> Having _|_ gives more functions fixed points.
06:08:52 <Heffalump> it would be nice to be able to declare things injective somehow, I've discussed it with Simon PJ a bit. Once they have superclass constraints implemented you'll be able to use them to declare inverses, which will be a reasonable workaround, IIRC.
06:09:01 <dolio> Since the fixed point of Heffalump's function is _|_.
06:10:27 <paulvisschers_> Heffalump: You were correct, it works with associated data types
06:10:29 <Heffalump> paulvisschers_: btw, I'm not 100% certain that's your problem, but it looks very much like it. It took me a lot of head-scratching and questions on ghc-users to understand it when it happened to me.
06:10:32 <paulvisschers_> Heffalump: thanks again
06:10:34 <Heffalump> ah, cool
06:11:50 <paulvisschers_> Heffalump: Now it's just a matter of writing my own instances of Typeable for each instance, which is annoying but should at least work
06:16:02 <pejo> paulvisschers, are all ghc-releases buggy in that respect, or just the one you're using?
06:16:39 <paulvisschers_> All
06:17:34 <paulvisschers_> pejo: Well technically only 6.10.1 has a working implementation of type families, and that one has the problem that it can't derive typeable
06:18:04 <paulvisschers_> pejo: Possibly Data as well, but it doesn't seem to have any problem deriving the others
06:18:05 <Heffalump> associated datatypes are supported in 6.8, I thought
06:18:23 <pejo> paulvisschers, can DrIFT be used to overcome that?
06:18:25 <Heffalump> and associated synonyms don't really work very well even in 6.10, though it's a lot better than 6.8
06:19:20 <paulvisschers_> Heffalump: I tried them in 6.8 and it didn't really work well if you used the associated data types in functions that weren't part of the class iirc
06:19:28 <Heffalump> fair enough
06:19:45 <paulvisschers_> pejo: Possibly
06:20:32 <paulvisschers_> pejo: Although if it does, it seems weird that it's not already built-in
06:21:09 <paulvisschers_> Does anyone know of a good example for manually making instances of typeable and typeable1 etc.?
06:21:25 <Heffalump> there's some Template Haskell around to do it, I think
06:21:49 * Heffalump tries to remember where. Someone gave it to me on IRC a while back.
06:22:41 <paulvisschers_> Heffalump: But will those work with associated data types?
06:22:54 <Heffalump> good point, probably not
06:24:44 <paulvisschers_> Also it might be difficult to implement seeing that for data Assoc a, Assoc isn't actually in the Typeable1 class
06:25:11 <paulvisschers_> so you can't use typeOfDefault
06:28:27 <dnul> Im having some type issue in http://www.hpaste.com/show_7.html
06:28:40 <dnul> im too noob to solve it
06:29:42 <Heffalump> what's the error?
06:30:08 <Raynes> What's the error?
06:30:15 <Raynes> Oh, didn't see you type that.
06:30:19 <dnul> expected type (i,i) ...against (Int,Int)
06:30:27 <Heffalump> what line?
06:30:41 <dnul> 12
06:30:49 <paulvisschers_> Heffalump: http://hpaste.org/13332#a1 Does this seem sensible (most notably the Typeable instance)?
06:31:19 <dnul> ixmap its troubling
06:31:36 <Heffalump> paulvisschers_: to the extent I am familiar with manualyl writing Typeable, which is a bit but not very much, yes it seems right
06:32:22 <paulvisschers_> Heffalump: ok thanks for the second opinion
06:35:23 <dnul> Raynes: any clue?
06:35:32 <Raynes> Nope.
06:36:04 <dnul> :t ixmap
06:36:05 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
06:36:09 <Raynes> It's ixmap
06:36:35 <Raynes> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
06:37:24 <dnul> can you use ixmap in an example?
06:37:35 <dnul> i cant find a function that works with ixmap
06:37:47 <Raynes> I've never used it before, I'm not sure of it's correct example.
06:37:53 <Raynes> s/example/usage/
06:38:25 <pejo> Is it safe to pull ghc from darcs now, or is it currently broken?
06:41:56 <augustss> dnul: ixmap simply applies a function to the index before indexing.
06:43:10 <augustss> dnul: so in your hpaste your amicable works on pairs, but the array is indexed by an Int, so there's a type error.
06:50:27 <maltem> pejo: No idea personally, but I've experienced the ghc head to rest in a farily stable state, generally
07:01:19 <leimy> when one says
07:01:46 <leimy> data Blah = S { foo :: Int -> Int}
07:01:53 <leimy> does the compiler generate that "foo" function?
07:02:05 <Stephan202> yes
07:02:27 <Stephan202> foo :: Blah -> Int -> Int
07:02:31 <leimy> That's what I thought... however how does it know what the mapping Int -> Int is supposed to do ?
07:02:42 <leimy> hmmm
07:02:47 <Zao> leimy: Int -> Int is just a function taking an int and returning an int.
07:02:52 <leimy> right
07:03:00 <leimy> but doing what to that Int?  Nothing?
07:03:10 <leimy> or is it only partially defined?
07:03:13 <maltem> leimy: when you declare the data type, you don't have a function of type Int -> Int yet
07:03:38 <maltem> leimy: you need a value of that type in order to say something about its behaviour
07:03:45 <leimy> huh...
07:03:47 <BONUS> you can do
07:03:48 <Zao> let b = Blah (+2)
07:03:54 <BONUS> S (+3)
07:03:55 <leimy> Ohhhh!
07:04:03 <leimy> ok that's how you can supply the "guts" to runState
07:04:05 <leimy> or execState
07:04:08 <BONUS> (not Blah (+2), Blah is a type constructor, not the value constrctor)
07:04:16 <Zao> BONUS: Indeed. I misread it.
07:04:17 <leimy> and it just gives you the ability to slap a State into that function.
07:04:37 <leimy> that suddenly makes more sense than it did.
07:04:49 <Stephan202> leimy: exactly
07:05:00 <Zao> let x = (+2) -- the type of x is (likely) Integer -> Integer
07:05:01 <leimy> Ok, I think I just needed to walk through that once to get it.
07:06:14 <Zao> You can apply any function to the first argument to get a function taking the remaining arguments.
07:06:37 <leimy> Right... that makes sense
07:08:11 <Zao> So if you apply foo to a Blah, you get a (Int -> Int) value back, which is the function you had shoveled into it in the first place.
07:08:16 <leimy> I can say
07:08:21 <leimy> S { foo = (+2) }
07:08:24 <leimy> also right?
07:08:30 <leimy> you basically say "here is how foo is defined"
07:08:43 <maltem> right.
07:08:47 <leimy> just like you would any other field in the record syntax.
07:08:47 <saml> left.
07:08:54 <Zao> functions are first class values.
07:09:04 <Zao> Rather handy, actually :)
07:09:06 <leimy> yes
07:09:17 <maltem> saml: ?
07:10:19 <leimy> So in that syntax "foo" becomes a rather generic way to say "use the function I specified in the constructor"?
07:10:49 <saml> foo is syntactic sugar i bet
07:11:05 <saml> data A = A { foo :: Int }    this foo?
07:11:09 <leimy> basically allowing you to later deconstruct the function from the "wrapper"
07:11:16 <leimy> saml:  sort of yes :-)
07:11:20 <saml> foo (A 1)
07:11:25 <leimy> data Blah = s { foo :: Int -> Int}
07:11:43 <saml> foo is in module's namespace
07:12:03 <paper_cc> (S (+1)) 2 == 3
07:12:07 <saml> you can't have name conflicts.   data Blah2 = Blah2 { foo :: ... wrong
07:12:40 <paper_cc> * sorry, (foo $ S (+1)) 2 == 3
07:12:50 <saml> i think it's a shortcut. without foo, you have to do things like getFooFromBlah (Blah foo) = foo
07:13:09 <leimy> yeah
07:13:25 <leimy> But anyway, that part I always bumped into for some reason when looking at monads
07:13:36 <saml> so i think it's a syntactic sugar.   data A = A { foo :: Int }  becomes  data A = A Int ;  foo (A i) = i
07:13:38 <leimy> I mean, I "get it" but I didn't get some of the subtleties of that syntax.
07:14:16 <saml> you mean  newtype MyMonad a = MyMonad { unpack :: a }  or something?
07:14:35 <saml> @hoogle Identity
07:14:35 <lambdabot> module Control.Monad.Identity
07:14:35 <lambdabot> Control.Monad.Identity newtype Identity a
07:14:35 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
07:14:37 <maltem> (er... OT: what is broken if, when invoked from a shell, 'program' behaves differently from 'LANGUAGE=$LANGUAGE program'?)
07:15:04 <paolino> also data A = A1 {b::B} | A2 {b::B, c::C} is allowed
07:15:07 <Heffalump> does $LANGUAGE have spaces in it or other symbols the shell might interpret?
07:15:14 <Heffalump> what about LANGUAGE='$LANGUAGE' program ?
07:15:26 <Ferdirand> "$LANGUAGE" rather
07:15:41 <leimy> i guess since this has just the one field it could be newtype eh?
07:15:57 <leimy> And that'd supposedly be more efficient for some compilers that couldn't optimize it to be newtype
07:16:11 * leimy has this habit of using "data" a lot.
07:16:42 <Heffalump> it's a bit more complicated than syntactic sugar, because of record update syntax
07:16:54 <Heffalump> and newtype and data have subtle semantic differences to do with strictness
07:17:08 <maltem> Heffalump: LANGUAGE="$LANGUAGE" behaves the same LANGUAGE=$LANGUAGE, and no, I have LANGUAGE set to eo.utf8:de_DE.utf8
07:17:15 <maltem> s/the same/the same as/
07:17:38 <Heffalump> so a one argument one constructor data behaves differently from newtype, because the data will be consistent with multi-argument multi-constructor data declarations, and the newtype will behave just like it's not there
07:18:47 <mercury^> maltem: isn't the variable called LANG?
07:19:17 <maltem> mercury^: LANG is the main locale, LANGUAGE can include a number of locales
07:19:46 <mercury^> I don't know LANGUAGE, but LC_ALL takes precedence over LANG.
07:19:50 <mercury^> Maybe you have that set.
07:20:49 <paper_cc> LANGUAGE takes precedence over LC_ALL (at least `info gettext` says so)
07:21:32 <maltem> hm... anyways, LANG is respected by 'program', but LANGUAGE isn't
07:21:46 <Heffalump> but the question is why re-setting it to the same value would make any difference
07:21:56 <maltem> yeah right
07:22:07 <maltem> because then it suddenly gets respected
07:22:33 <Heffalump> how does  export LANGUAGE=$LANGUAGE ; program behave?
07:23:39 <maltem> Heffalump: oh wow, that does the same as LANGUAGE=$LANGUAGE program
07:23:57 <Heffalump> ok, so now in that shell I guess program will behave
07:24:06 <Heffalump> (without redoing the export command)
07:24:13 <paper_cc> maltem, then LANGUAGE is initially local to your shell and is not exported
07:24:14 <Heffalump> so now the question is how that shell is now different from a fresh shell
07:24:16 <saml> maybe LANGUAGE is empty
07:24:19 <Heffalump> ahh
07:24:20 <Heffalump> paper_cc has it
07:24:22 <saml> but LANGUAGE=$LANGUAGE  is ''
07:24:29 <maltem> Heffalump: hm turns out I forgot to export LANGUAGE in my .profile
07:24:33 <Heffalump> saml: no, maltem says it's not
07:24:38 <Heffalump> maltem: ah, right
07:24:41 <Heffalump> shell variables confuse me
07:24:55 <maltem> paper_cc: ah I didn't know about shell-local variables, that would of course explain it
07:26:02 <paper_cc> the thing is just that the shell doesn't export its env[] unless you explicitly ask it to do this (by export, env or `A=B foo` syntax)
07:26:33 <paper_cc> OT does anyone know how to use ARB_framebuffer_object in HOpenGL?
07:26:54 <maltem> paper_cc: I see, thanks, so I got it fixed
07:28:57 <jeffz`> paper_cc: perhaps http://article.gmane.org/gmane.comp.lang.haskell.hopengl/546
07:34:32 <paper_cc> jeffz`, thank you
07:34:59 <paper_cc> is there something about {ARB,NV}_{fragment,vertex}_program out there*
07:35:10 <paper_cc> s/there\*/there\?/
07:39:44 <jeffz`> paper_cc: not sure
07:41:37 <paper_cc> it would be nice to do GPGPU things from Haskell, but it's nearly impossible with only fixed-pipeline API. so it looks like I need to go and patch HOpenGL :/
07:42:09 <paper_cc> (GLSL but no ARBfp - that's strange indeed)
07:42:30 <jeffz`> paper_cc: from what I can gather the maintainer of HOpenGL has been stretched for time for the past year or two and hasn't been able to do much work on the library
07:45:56 <jeffz`> paper_cc: from 2005, http://thread.gmane.org/gmane.comp.lang.haskell.hopengl/396/focus=402
07:47:17 <paper_cc> thank you, I've already seen it. what I don't like here is that it's 2005...
07:49:06 <jeffz`> I was thinking about posting to the haskell proposals reddit suggesting a review of HOpenGL to better plan for future work incase it were suitable for gsoc or what not, but I really don't know much opengl stuff beyond the basics.
07:49:07 <gwern> hopengl is the opengl package?
07:49:11 <jeffz`> yeah.
07:49:37 <gwern> what's wrong with it? don't believe I've seen any bugs in any of the haskell progams using it I've messed with
07:49:48 <gwern> (suchas monadius, tetris, shu-thing...)
07:49:57 <jeffz`> nothing beyond some missing features
07:50:01 <paper_cc> it'
07:50:30 <paper_cc> it's just out of date sometimes
07:50:33 <Zao> gwern: I can't stand reading the code for my accelerated Tetris clone.
07:50:40 <Zao> gwern: It's from my early Haskell days :P
07:51:38 <gwern> Zao: you mean the xtris? which I keep bugging you to release?
07:51:51 <mmorrow> got enough of libev bound to do (half of) the libev C example in haskell: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=687#a687
07:52:00 <Zao> gwern: Yes.
07:53:00 <Zao> Last I touched it I was abstracting the UI away from the game code, with so-so results :)
07:53:30 <mmorrow> libev is sweet
07:53:31 <mmorrow> http://software.schmorp.de/pkg/libev.html
07:53:39 <vixey> Zao, I wonder whath happens when there is nothing left to abstract
07:55:26 <Zao> vixey: Then it's Haskellic and all is good.
07:55:52 <Saizan> mmorrow: isn't more convenient to use threads rather than event loops in haskell?
07:56:31 <Peaker> does flip fmap have a name?
07:56:54 <Zao> I had some trouble getting my user input into the game, I think I ended up shoveling it through the incoming network actions STM chan.
07:57:03 <Saizan> Peaker: only for ->
07:57:13 <Peaker> Saizan: No I need it for IO
07:57:14 <vixey> :t flip fmap
07:57:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
07:58:13 <Peaker> mmorrow: http://hpaste.org/13333#a1
07:59:24 <mmorrow> Saizan: with libev you have the choice of select/poll/epoll/kqueue/devpoll
07:59:30 <redditbot> blog.kfish.org: Type-Level Instant Insanity
07:59:39 <mmorrow> instead of just select, which ghc's io manager uses
08:00:27 <mmorrow> Saizan: and i can still use threads with it. i haven't quite decided on my strategy yet
08:00:45 <mmorrow> Saizan: (i'm doing this in particular for a webserver)
08:00:59 <Saizan> i see
08:02:05 <mmorrow> Peaker: heh, totally. i'm in hack-first-and-look-later mode at the moment ;)
08:02:31 <Peaker> mmorrow: your code seems very nice FWIW :)
08:03:27 <mmorrow> @yow
08:03:27 <lambdabot> INSIDE, I have the same personality disorder as LUCY RICARDO!!
08:06:01 <saml> > > > > >
08:06:01 <lambdabot>   <no location info>: parse error on input `>'
08:06:28 <saml> > let _ = 1 in _
08:06:29 <lambdabot>   Pattern syntax in expression context: _
08:06:49 <saml> > let undefined = undefined in undefined
08:07:04 <lambdabot>   thread killed
08:07:24 <saml> > let thread killed = thread killed in thread "killed"
08:07:39 <lambdabot>   thread killed
08:07:47 <augustss> excellent!
08:14:53 <defun> Maybe I'm stupid, but what is the point of 'guards'? I've read the explanations in real world haskell and in the haskell wiki. I just can't seem to understand why I would use these things. Anyone care to enlighten me?
08:15:33 <Zao> defun: They are convenient when you have completely different function bodies depending on some preconditions.
08:16:05 <vixey> defun, imagine something like
08:16:06 <Zao> Nicer than having a case immediately inside the function.
08:16:07 <vixey> f A = ...
08:16:16 <vixey> f (B e) = if p e then ... else ...
08:16:21 <vixey> f C = ...
08:16:43 <defun> ok...
08:17:17 <vixey> defun, actually let me change it a little
08:17:19 <vixey> f (B e) = if p e then ... else foo
08:17:22 <vixey> f C = foo
08:17:36 <vixey> so you can split the B case into two using a guard
08:17:53 <vixey> f (B e) | p e = ... | otherwise = foo
08:18:10 <vixey> but you can save an equation in this case if you have
08:18:13 <vixey> f (B e) | p e = ...
08:18:15 <vixey> f _ = foo
08:18:39 <vixey> the guard lets you add a predicate in the pattern match condition
08:18:40 <adrian> you use them because if then else doesn't look very nice
08:18:46 <vixey> adrian, no
08:18:59 <adrian> I do, at least
08:19:04 <vixey> well it is one use
08:19:26 <adrian> especially if you need more than one condition
08:19:46 <adrian> guards improve readability
08:20:26 <defun> thanks.
08:20:31 <Zao> http://hpaste.org/13213
08:20:33 <jkff> defun: For example, fileType fileName | ".hs" `isSuffixOf` fileName = HaskellSource | ".a" `isSuffixOf` fileName = DynamicLibrary | ...
08:20:49 <Zao> Ignore that case 2 and 3 are inefficient :P
08:21:22 <adrian> no x<=y?
08:21:35 <adrian> you can save an otherwise
08:21:59 <adrian> ah, you eliminate duplicates
08:23:23 <defun> "print $ merge (sort [42,3,5]) (sort [3,6,5])" Why do we use the '$'?
08:23:37 <Zao> defun: To avoid excessive parens.
08:23:56 <jkff> defun: Without $ this becomes application of print to 3 arguments: merge, (sort ..) and (sort ..)
08:24:14 <jkff> > (+1) $ (+) 2 3
08:24:16 <lambdabot>   6
08:24:20 <jkff> > (+1) (+) 2 3
08:24:20 <Zao> Without $, you'd have to do print (merge (sort [42,3,5]) (sort [3,6,5]))
08:24:22 <lambdabot>       No instance for (Num (a -> a -> a))
08:24:22 <lambdabot>        arising from the literal `1'...
08:24:28 <Zao> Which is way too close to lisp for my tastes :P
08:24:33 <defun> ok, i get it.
08:24:38 <jkff> > (+1) ((+) 2 3)
08:24:40 <lambdabot>   6
08:24:59 <Zao> You could use a $ to get rid of the last paren pair, but I prefer the two arguments to look the same to ease reading.
08:25:06 * vixey (merge `on` sort) list list'
08:25:21 <paper_cc> :t on
08:25:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:25:29 <defun> thanks, guys.
08:25:59 <Zao> Ooh, handy little thing. I can't say that I'd grokked that from the signature alone.
08:28:01 <maltem> Zao: do you mean 'on'? actually it's quite obvious from the type signature
08:28:04 <jkff> Zao: I've been thinking forever on a neat symbol for that function before I saw it in all its elegance. I wanted '..', used 'o', and some more
08:28:08 <vixey> yes in this case the definition is clearer than the type
08:28:09 <vixey> @src on
08:28:10 <lambdabot> (*) `on` f = \x y -> f x * f y
08:28:28 <vixey> (b -> b -> c) ->
08:28:32 <vixey>   (a -> b)
08:28:38 <vixey> (a -> a -> c).
08:28:59 <vixey> missing arrow, ..
08:29:37 <maltem> the function takes two as, the only thing it can do with them is apply the (a -> b) function to it, and to get a c, it must apply the (b -> b -> c) function on the results
08:31:04 <vixey> ?djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
08:31:04 <lambdabot> f a b c _ = a (b c) (b c)
08:31:15 <koeien> hi #haskellers. re http://hpaste.org/13334 . why do i have to add a type signature?
08:31:34 <maltem> there should be way to tell djinn it mustn't throw away any arguments...
08:31:36 <vixey> koeien, because you are using a GADT
08:31:44 <Peaker> g `on` f = (f ~> f ~> id) g
08:31:45 <vixey> maltem, linear types I guess
08:31:55 <koeien> vixey: but, why can't it infer the fact that it's an Int there?
08:32:04 <koeien> vixey: it works in ghc 6.8.2...
08:32:44 <koeien> only not in the latest & greatest ghc 6.10.1
08:33:58 <maltem> vixey: hm those would be slightly different
08:34:15 <baaba> @src (~>)
08:34:15 <lambdabot> Source not found.
08:34:16 <vixey> (b -o b -o c) -o !(a -> b) -o a -o a -o c
08:34:24 <baaba> :t (~>)
08:34:24 <vixey> oops
08:34:25 <lambdabot> Not in scope: `~>'
08:34:28 <vixey> (b -o b -o c) -o !(a -o b) -o a -o a -o c
08:34:37 * vixey tries it out on iLeanTap
08:39:12 <Peaker> @let argument f = (.f)
08:39:14 <lambdabot>  Defined.
08:39:15 <Peaker> @let result f = (f.)
08:39:17 <lambdabot>  Defined.
08:39:22 <vixey> :t argument
08:39:23 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
08:39:24 <vixey> :t result
08:39:25 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:39:53 <Peaker> @let infixr 2 ~> ; f ~> g = result g . argument f
08:39:55 <lambdabot>  Defined.
08:39:57 <Peaker> @type (~>)
08:39:59 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
08:40:06 <vixey> why is it called argument/result?
08:40:45 <Peaker> vixey: for the same reason "first" and "second" have their names -- it "edits" a function so that it applies in the value's argument or in its result
08:41:09 <Peaker> vixey: if   (first (+1))   makes a function apply to the first in a tuple,      (result (+1))  makes a function apply to the result of a function
08:41:11 <vixey> > argument (+1) (*2) 3
08:41:13 <lambdabot>   8
08:41:16 <vixey> > result (+1) (*2) 3
08:41:18 <lambdabot>   7
08:41:30 <vixey> ok
08:41:36 <maltem> koeien: They changed the GADT implementation in ghc, this must be some glitch
08:41:47 <maltem> koeien: http://hackage.haskell.org/trac/ghc/ticket/2206 looks related
08:41:56 <vixey> could this (first,second) and (first->second) be part of something ?
08:42:36 <Peaker> vixey: there's also (element = map) for this reason, and a few others, and then you can compose them nicely:  (first . element . argument . result)  would "go into" first of tuple, then apply in each element, then go into the argument, and so on. Its sort of a "path"
08:42:42 <adrian> @hoogle (a->b) -> (a,a) -> (b,b)
08:42:42 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
08:42:43 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
08:42:43 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
08:42:59 <Peaker> vixey: I am not sure I understand the question,  (first, second) and (first->second)?
08:43:11 <koeien> maltem: there is an obvious workaround (that works), but it would be nice if the inference worked.
08:43:15 <Peaker> @type (length ~> length ~> id) compare
08:43:17 <lambdabot> forall a a1. [a] -> [a1] -> Ordering
08:43:46 <koeien> maltem: but that bug is reported in 6.8.2; i'm observing a problem in 6.10.1; 6.8.2 works for my example
08:44:01 <Peaker> @let element = map
08:44:04 <lambdabot>  Defined.
08:44:47 <Peaker> > let f = (first . element . result) in f (+2) ([const 5, const 6], 1) undefined
08:44:49 <lambdabot>   Couldn't match expected type `a -> t'
08:45:14 <Peaker> @type let f = (first . element . result) in f (+2) ([const 5, const 6], 1)
08:45:16 <lambdabot> forall b a t. (Num t, Num b) => ([a -> b], t)
08:45:36 <Peaker> @type let f = (first . element . result) in f (+2) ([const 5, const 6], 1) undefined
08:45:38 <lambdabot>     Couldn't match expected type `a -> t'
08:45:38 <lambdabot>            against inferred type `([a1 -> b], t1)'
08:45:44 <maltem> koeien: I was actually just referring to the first comment to that ticket, but granted, I'm not into this stuff
08:46:15 <Peaker> @type let f = (first . element . first) in f (+2) ([(5,'a'), (6,'b')], 1)
08:46:17 <lambdabot> forall b t. (Num t, Num b) => ([(b, Char)], t)
08:46:21 <Peaker> > let f = (first . element . first) in f (+2) ([(5,'a'), (6,'b')], 1)
08:46:23 <lambdabot>   ([(7,'a'),(8,'b')],1)
08:46:33 <koeien> maltem: ok. i'll search the bug tracker for related stuff
08:46:37 <koeien> thanks
08:46:45 <Peaker> (go into the first element of the big tuple, then go into each element, then go into the first of each element, and apply (+2) there)
08:46:45 <pejo> I would really like to prompt myself for input (1 bit is sufficient), but I'm not in the IO monad. Can I break it somehow, without having the compiler mess with things? (Instead of Debug.Trace I want Debug.Input).
08:47:06 <Peaker> pejo: you need to refactor your program.. can you paste it?
08:48:01 <Peaker> maybe element should be named each
08:48:06 <Peaker> @let each = map
08:48:08 <lambdabot>  Defined.
08:48:29 <Peaker> > let f = (first . each . first) in f (+2) ([(5,'a'), (6,'b')], 1)
08:48:32 <lambdabot>   ([(7,'a'),(8,'b')],1)
08:48:47 <Peaker> > let f = second in f (+2) ([(5,'a'), (6,'b')], 1)
08:48:49 <lambdabot>   ([(5,'a'),(6,'b')],3)
08:49:07 * Peaker finds this idea very cute :-)
08:51:11 <xenoblitz1> is there a method in gtk2hs so that a keypress works only once?
08:51:19 <Peaker> > let nth 0 f (x:xs) = (f x:xs) ; nth n f (x:xs) = x:nth (n-1) f xs in nth 5 (*2) [1..10]
08:51:22 <lambdabot>   [1,2,3,4,5,12,7,8,9,10]
08:51:33 <maltem> pejo: You could try muddling around with unsafePerformIO. I suppose it's only moderately evil for debugging purposes
08:51:34 <Peaker> @let nth 0 f (x:xs) = (f x:xs) ; nth n f (x:xs) = x:nth (n-1) f xs
08:51:37 <lambdabot>  Defined.
08:51:44 <pejo> Peaker, sure, here's the main entry: http://hpaste.org/13336
08:51:56 <Peaker> > let f = (first . nth 1 . first) in f (+2) ([(5,'a'), (6,'b')], 1)
08:51:59 <lambdabot>   ([(5,'a'),(8,'b')],1)
08:52:02 <Peaker> :-)
08:52:04 <pejo> Peaker, it's inside drive that I would like the user input.
08:53:58 <Peaker> pejo: but your function is in IO, what's the problem?
08:54:17 <pejo> Peaker, initUs_ drops it into UniqSM
08:55:26 <vixey> How does this relate to zippers
08:55:28 <vixey> ?
08:57:43 <mm_freak_> why isn't there a general type cast class?
08:57:49 <mm_freak_> class Cast a b where cast :: a -> b
08:57:58 <augustss> mm_freak_: Typeable
08:58:09 <vixey> mm_freak_, because fromIntegral is so beautiful
08:58:29 <augustss> mm_freak_: or maybe you have a different cast in mind
08:58:36 <vixey> mm_freak_, just compare this ugly  mean xs = sum xs / length xs  over this great  mean xs = sum xs / fromIntegral (length xs)
08:59:10 <roconnor> @pl mean xs = sum xs / fromIntegral (length xs)
08:59:10 <lambdabot> mean = liftM2 (/) sum (fromIntegral . length)
08:59:18 <mm_freak_> augustss: mine is different
08:59:30 <mm_freak_> just look at the type of Data.Typeable.cast
08:59:36 <mm_freak_> :t cast
08:59:38 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
08:59:43 <maltem> vixey: you would optimize that to traverse the list only once anyways :P
09:00:03 <mm_freak_> vixey: a general typecast class would replace 'fromIntegral' by 'cast'
09:00:06 <maltem> vixey: wait, that wouldn't change the situation at all.. just ignore me
09:01:06 <augustss> mm_freak_: a class like Cast is very difficult to use without getting ambiguities
09:01:19 <mm_freak_> augustss: yeah, i figured
09:01:55 <augustss> mm_freak_: basically, you'd have to give type signatures all over the place when using it.
09:02:59 <mm_freak_> yeah, or constrain your formulas to concrete types
09:06:48 <Olidu> Hi all, is there any "Haskell Cookbook" online?
09:08:34 <saml> @google haskell cookbook
09:08:37 <lambdabot> http://www.haskell.org/haskellwiki/Cookbook
09:08:37 <lambdabot> Title: Cookbook - HaskellWiki
09:09:17 <Olidu> I found that one, not a lot there.
09:09:20 <fernando_sanches> woah, is there somethig this lambdabot can't do?
09:09:30 <maltem> @coffee
09:09:30 <lambdabot> Unknown command, try @list
09:09:58 <fernando_sanches> eh, nice one! someone should implement that tho
09:10:26 <maltem> I think the shipping would turn out to be a problem
09:11:42 <fernando_sanches> well, since programmers can turn coffee into code, maybe it could deliver as code instead
09:14:16 <jkff> I guess it would be like lambdabot :: Code a -> (Coffee -> Code b) -> Code b ; creating and codifying code on the server side.
09:14:26 <jkff> *codifying coffee
09:17:00 <saml> > '☕'
09:17:01 <lambdabot>   '\9749'
09:22:22 <vixey> > showHex "" 9749
09:22:23 <lambdabot>       No instance for (Integral [Char])
09:22:23 <lambdabot>        arising from a use of `showHex...
09:22:26 <vixey> > showHex  9749 ""
09:22:27 <lambdabot>   "2615"
09:22:51 <mm_freak_> > map f [a,b,c]
09:22:52 <lambdabot>   Add a type signature
09:22:58 <mm_freak_> > map f [a,b,c] :: Expr
09:22:59 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
09:24:18 <saml> http://wekeywiki.googlepages.com/coffee.html  try this
09:27:05 <jberg> > showHex 254 "0x"
09:27:06 <lambdabot>   "fe0x"
09:29:08 <chessguy> 'ello
09:29:23 <paper_cc> 'es
09:32:11 <RayNbow> > map f [a, b, c] :: [Expr] -- mm_freak_
09:32:13 <lambdabot>   [f a,f b,f c]
09:32:35 <saml> > [a] >>= [b] :: [Expr]
09:32:36 <lambdabot>   Couldn't match expected type `Expr -> [Expr]'
09:32:50 <saml> > do {[a] ; [b]} :: [Expr]
09:32:51 <lambdabot>   [b]
09:33:04 <saml> > do { x <- [a] ; x [b]} :: [Expr]
09:33:05 <lambdabot>   Couldn't match expected type `[Expr] -> [Expr]'
09:33:33 <saml> > [a] >>= (\x -> [x b]) :: [Expr]
09:33:34 <lambdabot>   Couldn't match expected type `Expr -> Expr'
09:33:51 <saml> haskell is so hard
09:36:01 <saml> > [a] =<< [b]
09:36:02 <lambdabot>   Couldn't match expected type `a -> m b'
09:36:29 <Olathe> > [f] >>= (\x -> [x b]) :: [Expr]
09:36:30 <lambdabot>   [f b]
09:36:33 <Olathe> @type a
09:36:34 <lambdabot> Expr
09:36:35 <Olathe> @type f
09:36:37 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:53:07 <catechu> I'm trying to compile a file using hackage's WordNet library. But I am getting the compile error "main:WordNet differs from name found in the interface file WordNet-0.1.2:NLP.WordNet." Any ideas?
09:56:51 <pejo> catechu, did you build the library with some other version of ghc?
09:57:30 <mm_freak_> > liftM2 (,) [a,b,c] [d,e,f] :: [(Expr,Expr)]
09:57:32 <lambdabot>   [(a,d),(a,e),(a,f),(b,d),(b,e),(b,f),(c,d),(c,e),(c,f)]
09:57:52 <catechu> pejo: no, it was the same version -- that's why I'm confused
09:57:54 <Olathe> > f.f
09:57:55 <lambdabot>       Overlapping instances for Show (a -> c)
09:57:55 <lambdabot>        arising from a use of `s...
09:57:58 <mreh> hello all
09:58:05 <Olathe> > f.f :: Expr
09:58:06 <lambdabot>   Couldn't match expected type `Expr' against inferred type `a -> c'
09:58:10 <mm_freak_> > liftM2 (a :: Expr) Nothing Nothing
09:58:10 * boegel bows
09:58:11 <lambdabot>   Couldn't match expected type `a1 -> a2 -> r'
09:58:15 <Olathe> > f :: Expr
09:58:17 <lambdabot>   f
09:58:34 <mm_freak_> > liftM2 const Nothing (Just 3)
09:58:35 <lambdabot>   Nothing
09:58:41 <mm_freak_> > liftM2 const (Just 2) (Just 3)
09:58:43 <lambdabot>   Just 2
09:58:47 <mm_freak_> > liftM2 const (Just 2) Nothing
09:58:49 <lambdabot>   Nothing
09:59:10 <boegel> I have a nice question for you Haskell-magicians...
09:59:11 <mreh> anyone know any good distance learning courses?
09:59:26 <Olathe> > liftM2 (+) (Just 2) (Just 3)
09:59:28 <lambdabot>   Just 5
09:59:37 <boegel> it's been a while since I've actually used Haskell (over 2 years now), but I've been thinking of joining the Netflix contest
09:59:46 <boegel> and using Haskell to win the $1M :)
10:00:45 <catechu> boegel: the machine learning contest?
10:01:11 <boegel> my first concern is handling the huge amount of data, i.e. the 17,770 x 480,189 sparse matrix of ratings
10:01:28 <boegel> does anyone have any pointers on what would be the best ways to tackle this?
10:01:53 <mm_freak_> boegel: in what way is this a concern?
10:01:56 <boegel> reading in the data can be somewhat slow, but I need data extraction (i.e. a rating for user X, movie Y) to be fast
10:02:04 <boegel> catechu: yes, that one
10:02:25 <boegel> mm_freak_: well, it's a lot of data, and I need to be able to query it quickly
10:02:36 <mm_freak_> boegel: read it into a Data.Map
10:03:13 <boegel> mm_freak_: would that be the best option?
10:03:35 <boegel> mm_freak_: I'm not questioning your answer, just looking for alternatives and the pros/cons of each
10:03:44 <mm_freak_> boegel: for queries through a certain field of the data, probably yes
10:03:44 <cnwdup> Does Data.Map operate lazily?
10:03:52 <mm_freak_> cnwdup: yes
10:04:03 <boegel> mm_freak_: hmm, ok, I'l look into that one
10:04:12 <boegel> mm_freak_: any other possibilities?
10:04:23 <jkff> Ehh, no, I don't think Data.Map will do
10:04:30 <jkff> How many elements actually are in the matrix?
10:05:20 <mm_freak_> actually, if it is a matrix, Array may be suitable
10:05:27 <mreh> does anyone have an suggestions for a specialisation to learn fp? I would like to do a masters, or at least some further study
10:05:34 <gwern> grrr. ghci sucks for scripting
10:05:48 <mreh> i had a look at machihne learning in conneticut
10:05:55 <jkff> mm_freak_: How are you going to create an array with N elements, where N =
10:06:00 <jkff> > 17770 * 480189
10:06:01 <lambdabot>   8532958530
10:06:12 <jkff> So, an array with 8532958530 elements?
10:06:22 <cnwdup> > Map.lookup (100*100) $ Map.fromList $ zip [1..] [ x*x | x <- [1..]]
10:06:23 <lambdabot>       No instance for (Show (m a))
10:06:23 <lambdabot>        arising from a use of `show' at <in...
10:06:41 <cnwdup> > fromJust $ Map.lookup (100*100) $ Map.fromList $ zip [1..] [ x*x | x <- [1..]]
10:06:57 <lambdabot>   thread killed
10:07:16 <sclv> ?seen conal
10:07:16 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 12h 3m 20s ago.
10:07:23 <boegel> jkff: over 100 million
10:07:37 <mreh> ?seen augustss
10:07:37 <lambdabot> augustss is in #haskell. I last heard augustss speak 1h 5m 42s ago.
10:07:52 <paper_cc> that's a job for asm not haskell... at least for storage
10:08:09 <jkff> boegel: If you have enough RAM (~1-2G), probably an unboxed array used as a hashtable may do
10:08:36 <boegel> jkff: well, my machine only has 1G of RAM right now, and I don't want ot trash it :)
10:08:47 <boegel> jkff: it does need a RAM update though
10:09:03 <jkff> boegel: Then why don't you just use an instance of sqlite or bdb?
10:09:11 <paper_cc> boegel: you can only have 4GB of virtual memory on x86
10:09:15 <boegel> jkff: that sounds slow to me
10:09:28 <boegel> paper_cc: I know, but that should be enough really :)
10:09:43 <jkff> boegel: Maybe then you have to organize your data access so that many things are performed in the db in batch
10:09:52 <boegel> paper_cc: in fact, you can only use 3G of it, 1G is reserved for the kernel afaik
10:09:54 <paper_cc> hmm. 17770 * 480189 = 8532958530 ~ 8GB
10:10:01 <jkff> boegel: Or you may organize the hash on disk and use a memory-mapped file
10:10:11 <paper_cc> that sounds better
10:10:26 <boegel> jkff: organize the hash?
10:10:26 <paper_cc> but then you'll have to manage mapping regions and all this...
10:10:27 <jkff> boegel: However, since it's a hash, you'll be thrashing like crazy because disk access will be completely random
10:10:46 <jkff> boegel: Or, you may organize a B-tree but then you're reimplementing sqlite.
10:11:03 <stu8ball> If you're going to have in on disk then you may as well just keep it as a normal array and let it swap out to disk, no?
10:11:07 <jkff> boegel: You have to think hard about your actual data access patterns before deciding on a storage strategy.
10:11:16 <stu8ball> s/have in/have it/
10:11:22 <boegel> jkff: yeah, you might be right
10:11:31 <jkff> stu8ball: Yes, but if it will not fit in RAM, it will be on disk, and you will still be thrashing like crazy.
10:11:35 <boegel> jkff: the thing is, I don't really know yet how I'll access the data
10:11:39 <mm_freak_> jkff: indeed
10:12:00 <mm_freak_> well, Data.Map can help here, but the true magic comes from efficient storage of that matrix
10:12:01 * boegel scratches his head
10:12:02 <jkff> boegel: Then try it with sqlite and optimize until satisfied :)
10:12:11 <boegel> jkff: :)
10:12:17 <mm_freak_> so yes, i was just going to mention sqlite =)
10:12:41 <boegel> maybe I should write a small C program as an interface to the data
10:13:08 <boegel> I mean, the data is user ratings from 1-5, so a 3-bit value is enough per rating is enough
10:13:14 <jkff> I doubt that the C program will have less storage concerns
10:13:23 <paper_cc> a _small_ C program isn't going to be faster than an Array
10:13:24 <boegel> jkff: well, I'm not sure...
10:13:34 <boegel> paper_cc: you sure? :)
10:13:41 <jkff> Haskell has packed bit arrays out of the box
10:13:46 <paper_cc> it should be a big program then. cruel world :(
10:13:52 <jkff> UArray _ Bool is a packed bit array.
10:14:37 <boegel> I'd prefer an all-Haskell approach though
10:15:46 <duaneb> Lists are linked lists, no?
10:15:58 <duaneb> Are they ever compiled to an array in some cases instead?
10:16:21 <vixey> duaneb, sometimes they are compiled away completely and cease to exist
10:16:54 <Zao> Conceptually they're forward-linked lists.
10:17:02 <trhj> it would be a cool optimisation, though
10:17:05 <vixey> who would want a list to be an arary?
10:17:13 <vixey> why trhj? I can't really understand why it would be good
10:17:37 <pejo> vixey, locality of data
10:17:58 <gwern> people who abuse lists as random access data structures :)
10:18:04 <cizra> vixey: Arrays are faster than lists
10:18:09 <vixey> cizra, lol
10:18:26 <trhj> vixey: when you need random access.
10:18:27 <cizra> vixey: They really are, for both random and sequential access.
10:18:33 <vixey> cizra, my car is faster than your bike -- except both are collecting dust in a garage
10:18:44 <gwern> argh, I'm so close to getting :hlint working
10:18:52 <Asztal> a good memory manager will allocate the nodes mostly sequentially, ayway.
10:18:58 <gwern> but at the last step I can't get :! to read from a variable >.<
10:19:00 <cizra> vixey: As pejo said, the reason is in CPU caches -- a list is highly unlikely to fit into the L2
10:19:06 <cizra> vixey: .. whereas an array is much more likely
10:19:27 <gwern> (there must be some way to get a :! that will read from a variable!)
10:19:54 <pejo> Asztal, the pointer to the next element is taking up space.
10:20:04 <mm_freak_> it would be a neat optimization, but it would not eliminate the need for arrays
10:20:15 <jkff> cizra: There is an optimization that transforms lists to chunked lists, but I am not sure whether it is in GHC
10:20:20 * jkff looks up how it is called
10:20:26 <mm_freak_> lists simply aren't arrays…  other than that they can be infinite, they have no advantage over arrays
10:20:30 <gwern> stream fusion?
10:20:47 <cizra> jkff: Most of everything can be made better.
10:20:52 <vixey> what's an L2
10:20:56 <sclv> you can get fusion with arrays.
10:20:58 <boegel> vixey: L2 cache
10:21:06 <vixey> OH right now I understand........ :p
10:21:08 <cizra> mm_freak_: easy inserting is a definite advantage
10:21:14 <jkff> gwern: No. The optimization packs several CONS cells into one with the elements layed sequentially as a small array
10:21:15 <boegel> vixey: a CPU has several levels of cache, L1 being the fastest/smallest
10:21:25 <gwern> 'Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable. '
10:21:26 <mm_freak_> cizra: arrays are the wrong structure here
10:21:28 <vixey> how do you guys know what a CPU does/works
10:21:48 <boegel> vixey: because I'm pursuing a Phd on computer architecture (amongst others) :P
10:21:50 <cizra> mm_freak_: Well, if you want easy insertion, lists are the way to go. If you want random access, arrays..
10:21:55 <gwern> jkff: hm. doesn't sound like anything I've heard of, unless I've misunderstood hashconsing
10:21:56 <trhj> cizra, how do u insert into a haskell list quickly?
10:22:00 <Zao> Physical machines are uninteresting.
10:22:09 <mm_freak_> cizra: what about Data.Map?
10:22:10 <cizra> trhj: Um, I dunno. I'm a Haskell newbie
10:22:14 <cizra> mm_freak_: have no idea
10:22:30 <mm_freak_> cizra: lists and arrays aren't the only structures in haskell =)
10:22:47 <jkff> gwern: What does hash consing do?
10:23:01 <cizra> mm_freak_: Never claimed it
10:23:04 <mm_freak_> if you need fast random insertion and fast random extraction, Data.Map or hash tables are the way to go
10:23:22 <sclv> cdr-coding is what I think jkff is speaking of?
10:23:28 <pejo> vixey, this stuff is taught in the first course on computer architecture
10:23:40 <cizra> mm_freak_: C++ maps disappointed me.. they're log(N)-time
10:23:53 <mm_freak_> cizra: what's wrong with log n?
10:23:54 <cizra> mm_freak_: I hoped they would be O(1) average case
10:24:10 <sclv> http://www.faqs.org/faqs/lisp-faq/part2/section-9.html
10:24:12 <cizra> mm_freak_: I really needed that good average case and didn't care much about worst case
10:24:21 <mm_freak_> hash tables have O(1) insertion and extraction, but they are memory intensive and unsafe
10:24:39 <cizra> mm_freak_: C++ maps aren't hash tables but rather some kind of trees
10:24:51 <wli> Chunked lists can be used. In C, they're basically #define LIST_CHUNK_ELEMS 16 struct my_type_node; struct my_type_node { struct my_type elems[LIST_CHUNK_ELEMS]; struct my_type_node *next; unsigned long present_bitmap; };
10:25:03 <mm_freak_> cizra: yes, O(log n) suggests that, but there is really nothing wrong with O(log n)
10:25:08 <mm_freak_> that's very fast
10:25:14 <vixey> what's present_bitmap?
10:25:20 <vixey> oh right, how many bits of it exist
10:25:22 <sclv> hash tables have O(hashing function) insertion and extraction
10:25:50 <cizra> mm_freak_: well, for large maps indeed
10:25:56 <Zao> sclv: Give or take a bit of collision overhead.
10:26:00 <pejo> sclv, that basically looks like pointer tagging?
10:26:01 <cizra> mm_freak_: but I needed small maps and fast search instead.
10:26:04 <wli> vixey: It lets you have absent entries in the array in each node.
10:26:06 <cizra> mm_freak_: and they failed me horribly there.
10:26:09 <sclv> and potentially O(collisions*collisioncost) for bad hash functions
10:26:28 <sclv> where collisions is actually collisionrate
10:26:33 <wli> The locality of reference hit for hashing by separate chaining is immense.
10:27:05 <sclv> pejo -- sorta, but somewhat fancier the the special case i think?
10:27:09 <mm_freak_> cizra: maps provide fast extraction (if this is your idea of 'search')
10:27:24 <cizra> mm_freak_: By fast I meant O(1), not O(log n).
10:27:35 <mm_freak_> O(log n) extraction can almost only be beaten by hash tables for a randomly insertible structure
10:27:48 <cizra> mm_freak_: Although, now I'm not so sure anymore if the log was really the culprit...
10:28:06 <wli> O(1) but with a huge constant factor overhead for cache locality hits.
10:28:07 <sclv> not to mention which, when a map is wrong, its more likely that a trie is right than a hashtable.
10:28:32 <mm_freak_> tree traversal is a very fast operation
10:29:45 <sclv> we really need a haskell faq page on the whole map/hashtable nonsense.
10:29:48 <conal> sclv: hi
10:29:53 <sclv> hi conal!
10:29:57 <wli> Hash tries get interesting. Linked binary trees actually share the huge locality of reference hit for hashing by separate linked chaining.
10:30:15 <sclv> so I think I have a solution to what I was looking for, but haven't coded it up yet...
10:30:27 <conal> sclv: what were you looking for?
10:30:36 <sclv> The trick is to pack the dictionary into the datatype.
10:30:51 <sclv> so you can get Poly [Double] (a->Double) (Double->b)
10:31:19 <sclv> Which is essentially an adjunction from Hask to Doubles
10:31:39 <sclv> and then you can recover Functor instances and such
10:31:54 <conal> sclv: what does the type mean?  what roles do the fields play?
10:32:01 <sclv> This is all by way of replacing :-># with something better.
10:32:21 <mm_freak_> something better than :->#?
10:32:23 <sclv> a :-># b = Poly [Double] (a->Double) (Double-> b) |
10:32:28 <mm_freak_> i like =)
10:32:30 <sclv> AnyFun (a->b)
10:32:35 <mm_freak_> but i hate :-)
10:33:09 <sclv> The missing piece is still that :-> looks essentially the same.
10:33:17 <wli> You guys know about hashing by open addressing?
10:33:19 <sclv> and the list gets very inefficient when it gets huge.
10:33:33 <gwern> @undo runShellCommand cmd = do { sh <- shellFileName; popen sh [shellCommandSwitch, cmd] Nothing }
10:33:33 <lambdabot> runShellCommand cmd = shellFileName >>= \ sh -> popen sh [shellCommandSwitch, cmd] Nothing
10:33:48 <sclv> so if there's been any work done on producing some sort of trie encoding?
10:33:52 <mmorrow> libev binding almost useable http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=688#a688
10:34:25 <sclv> Conal: the list of doubles is a list of terms for a polynomail.
10:34:29 <sclv> erm, polynomial.
10:34:46 <sclv> We operate on them with the stuff from "Power Series, Power Serious"
10:34:49 <conal> sclv: coefficients?
10:34:53 <sclv> yep
10:35:02 <conal> and the other fields?
10:35:09 <vixey>   withWatcher IOT (\ioW ->
10:35:26 <vixey> interesting
10:35:27 <wli> Numerical evaluation gets interesting.
10:35:29 <sclv> you need something generically "a->b" so they provide a mapping from a to double and double to b.
10:35:32 <duaneb> anyone here use a mac
10:35:38 <duaneb> AND wxwidgets?
10:35:48 <sclv> otherwise you can't get a functor instance.
10:36:04 <mmorrow> vixey: GADTs ftw :)
10:36:12 <sclv> (the Real constraint for realToFrac would kill it)
10:36:19 <mm_freak_> IOT?  the transformer variant of IO?
10:36:23 <vixey> aha!
10:36:46 <mmorrow> mm_freak_: it's just a constructor, as in "of I/O Type"
10:36:47 <mm_freak_> unsafePerformIOT :: Monad m => IOT m a -> m a
10:36:51 <vixey> I'm still being impressed at how much expressivity GADT give
10:36:51 <mm_freak_> =P
10:37:02 <defun> does anyone *really* use folds? And why, besides for writing textbooks on haskell?
10:37:06 <sclv> mmorrow: looks pretty nifty.
10:37:10 <vixey> defun, programming
10:37:13 <mm_freak_> mmorrow: i was just joking
10:37:26 <duaneb> defun: I used one just a minute ago
10:37:31 <mmorrow> vixey: it's really handy that once you match a constructor, you know that certain things are impossible/whatever
10:37:34 <duaneb> defun: is that bad? :|
10:37:38 <mmorrow> mm_freak_: heh
10:37:41 <yav> defun: it's like asking why people use loops
10:37:50 <mmorrow> sclv: i'm starting to get excited about it
10:37:52 <mm_freak_> defun: most operations on lists are folds, just that they are predefined special cases…  if such a case is missing for my problem, i use a fold
10:38:00 <mm_freak_> btw, i use foldM a lot
10:38:27 <duaneb> mapM_ is better
10:38:47 <vixey> mmorrow, been playing with the idea of putting functions signatures into GADTs to write polyvariadics
10:38:58 <trhj> why can't we catch an error from a function?
10:38:59 <defun> ok. thanks. I guess it's back to the drawing board. I was hoping I could skip over that section. Bummer.
10:39:11 <sclv> trhj: we can, but only in the IO monad.
10:39:15 <newsham> defun: does anyone really write accumulator loops?
10:39:22 <newsham> how often does that really happen in programming?
10:39:26 <sclv> so if we have pure code that throws an error, and we execute it in IO, the handler can go in IO
10:39:38 <mm_freak_> duaneb: mapM_ is not always suitable
10:39:43 <mm_freak_> foldM is more general
10:39:44 <mmorrow> vixey: cool. i'm not sure if i know exactly how you mean, but i can imagine.
10:39:56 <duaneb> mm_freak_: possibly. :)
10:39:57 <newsham> ?src forM_
10:39:58 <lambdabot> forM_ = flip mapM_
10:40:02 <newsham> mmmmmm
10:40:19 <mm_freak_> defun: folds are truely a virtue, as soon as you understand them =)
10:40:25 <trhj> sciv: i understand, but putting all code in the IO monad... *shudder*
10:41:07 <mm_freak_> defun: just think of a generalized notion of a 'loop'
10:41:24 <sclv> trhj: exceptions are an IO construct by definition though...
10:41:32 <sclv> or at least an "effect"
10:42:06 <trhj> mm_freak_: fold , IMHO, is a specialised case of a loop
10:42:10 <mm_freak_> maybe my next tutorial will be about folds =)
10:42:12 <sclv> if pure code throws an error, that is, or should be, only the result of programmer error.
10:42:24 <trhj> sclv: ?
10:42:28 <duaneb> ?src fold
10:42:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:42:32 <duaneb> ?src foldr
10:42:32 <lambdabot> foldr f z []     = z
10:42:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:42:44 <sclv> > head []
10:42:45 <lambdabot>   * Exception: Prelude.head: empty list
10:42:51 <sclv> that's programmer error.
10:42:59 <sclv> don't take head of an empty list.
10:43:23 <duaneb> hehe
10:43:26 <duaneb> > tail []
10:43:26 <sclv> if your code is pure, you can or should be able to guarantee that it is total (i.e. that all paths are valid)
10:43:28 <lambdabot>   * Exception: Prelude.tail: empty list
10:43:33 <mm_freak_> trhj: indeed, but they are more general than the usual notion of reducing a list to a value
10:43:57 <newsham> > tail [1..]
10:43:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:44:03 <newsham> > last [1..]
10:44:23 <lambdabot>   thread killed
10:44:41 <trhj> sclv: if the code is pure, why can we invoke an IO action from it?
10:44:41 <vixey> trhj, you use recursion not loops
10:45:01 <sclv> we can't. we can invoke it *from* an IO action.
10:45:10 <trhj> because compiler can't guarantee
10:45:25 <trhj> the absence of calls to error
10:45:35 <sclv> trhj: no. but you can.
10:45:50 <vixey> mmorrow, if you have a function like   f :: G a -> a,  then what does a constructor M :: G (G a -> a) mean?
10:46:07 <sclv> ?hoogle evaluate
10:47:16 <FunctorSalad> it seems more logical (though less convenient) to me too that error should be of type "String -> IO a"
10:47:29 <trhj> sclv: that's IMHO, against the spirit of Haskell.Compilers are to check our code
10:47:37 <sclv> error doesn't mean "throw an exception?
10:47:46 <mm_freak_> trhj: there is nothing wrong with error calls, is it?
10:47:52 <sclv> it means "terminate the program because it is undefined"
10:48:00 <trhj> we can't math against an error
10:48:02 <hugo___> hey ppl
10:48:03 <sclv> (with an accidental side effect that we print something)
10:48:16 <trhj> sorry, match
10:48:27 <idnar> if you don't want error, then don't invoke partial functions
10:48:36 <sclv> trhj: the general style is to avoid using partial functions and to avoid calling error.
10:48:43 <oklopol> trhj: heh, thought you meant "there's no pretty mathy solution to errors" :P
10:48:46 <mm_freak_> trhj: but you can consider a bottom outcome
10:48:53 <sclv> unless you have, you think, a guarantee that error will never be called.
10:49:00 <oklopol> "we can't math against them"
10:49:08 <mm_freak_> bottom can't be observed directly, so there is no point in matching against it
10:49:15 <hugo___> the haskell tagline should be changed to "Haskell: deprecating your favourite programming language since 1998"
10:49:16 <sclv> and of course we can't match against an error, because that would be the same as testing for nontermination.
10:49:28 <duaneb> so
10:49:29 <vixey> you can match against an error
10:49:33 <vixey> @src MonadError
10:49:38 <duaneb> when are we voting on haskell logos? :D
10:49:53 <FunctorSalad> vixey: I think MonadError is the pure way to deal with errors
10:50:02 <FunctorSalad> so it's not related to "error"
10:50:29 <FunctorSalad> @type noMsg
10:50:35 <mmorrow> vixey: i found that one way GADTs are useful is in how they can propogate the type 'a' in (G a), like in  eval :: G a -> a. so in G (G a -> a), (wrt this use of GADTs) you don't really gain anything with respect to the type it's carrying since you have 'a' already in (G a).
10:50:35 <trhj> but why can't we test? Like : case (head a) of x -> x; error -> 0;
10:50:55 <vixey> mmorrow, it isn't eval though..
10:50:59 <newsham> trhj: catch it in IO :)
10:50:59 <lambdabot> Control.Exception evaluate :: a -> IO a
10:51:00 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
10:51:00 <lambdabot> class (Monad m) => MonadError e m | m -> e where
10:51:02 <lambdabot>     throwError :: e -> m a
10:51:04 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
10:51:07 <lambdabot> forall a. (Error a) => a
10:51:16 <vixey> mmorrow, you get  f M = f
10:51:29 <mmorrow> vixey: so i guess you could say that using them to propogate type and having the 'a' in (G a) be (G (f a)) are moving along two different axes
10:51:40 <mm_freak_> trhj: 'error' throws an exception, which is an impure concept, so would need to catch it in IO
10:52:11 <FunctorSalad> @botsnac
10:52:11 <lambdabot> :)
10:52:11 <lunabot>  :)
10:52:26 <FunctorSalad> they're so cute
10:52:26 <idnar> botsanc?
10:52:46 <trhj> mm_freak_: why error is allowed in pure code then?
10:52:59 <sclv> error is just undefined
10:53:06 <mm_freak_> trhj: what's wrong with that?  bottom is also allowed
10:53:06 <mmorrow> vixey: going with what you were getting at, it's nice how you can "lie" about what's inside a particular Con, and give it the type that it'll /eventually become/ after you eval or something
10:53:21 <mmorrow> rather than what it actually is
10:53:21 <sclv> and then haskell's imprecise exceptions give you some extra ways to deal with it in the presence of IO
10:53:22 <yav> trhj: error is used to inidcate that your program has a bug.  it shold not be used for proper error handling
10:53:24 <mm_freak_> trhj: in pure code, there is no difference between 'error' and bottom
10:54:00 <mmorrow> Foo :: [G a b] -> G [a] [b]
10:54:05 <mmorrow> or some such
10:54:07 <FunctorSalad> yav: what is the recommended way for proper handling?
10:54:21 <Olidu> hi, a very newbie question, how do I get a list of random numbers?
10:54:30 <vixey> yeah there's that too
10:54:33 <sclv> ?hoogle randoms
10:54:33 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
10:54:50 <duaneb> >randoms
10:54:52 <Olidu> what's hoogle?
10:54:54 <sclv> Olidu: the documentation for System.Random as a whole should provide the answers you need
10:54:59 <duaneb> > randoms
10:55:00 <yav> FunctorSalad: depends on what kinds of errors can occur, and what you want to do when they do.
10:55:01 <lambdabot>       Overlapping instances for Show (g -> [a])
10:55:01 <lambdabot>        arising from a use of ...
10:55:05 <sclv> hoogle is google for haskell functions
10:55:07 <newsham> trhj: if error wasnt allowed:    head (x:xs) = x; head [] = fix id   ?
10:55:20 <duaneb> > randoms >> mapM putStrLn
10:55:21 <lambdabot>       Overlapping instances for Show ([String] -> IO [()])
10:55:21 <lambdabot>        arising fro...
10:55:24 <duaneb> hm
10:55:25 <duaneb> ok
10:55:30 <yav> FunctorSalad: I tend to use either the "pure" way with error values in a datatype, or IO errors etc, with catch
10:55:31 <duaneb> back to practicing my haskell :)
10:55:47 <newsham> > let h (x:xs) = x; h [] = fix id in h []
10:55:49 <mmorrow> vixey: oh, i just parsed what you said earlier correctly
10:55:49 <lambdabot>   * Exception: stack overflow
10:55:59 <mmorrow> if you have a function like   f :: G a -> a,  then what does a constructor M :: G (G a -> a) mean?
10:56:05 <mmorrow> i'm not sure
10:56:09 <mmorrow> :)
10:56:19 <vixey> mmorrow, I've been thinking about it a bit
10:56:19 <mm_freak_> duaneb: lambdabot doesn't let you run IO stuff
10:56:20 <trhj> again: can we test whether a value is bottom in pure code? I don't see anything impure here. Just an extra data constructor.
10:56:20 <duaneb> > randoms >>= mapM putStrLn
10:56:21 <lambdabot>   Couldn't match expected type `g -> b' against inferred type `IO ()'
10:56:23 <vixey> it's a fun question
10:56:27 <duaneb> mm_freak_: ahh
10:56:30 <duaneb> sadness
10:56:37 <FunctorSalad> yav: I meant a comfy way to use pure errors... I guess MonadError
10:56:49 <mmorrow> vixey: i guess you'd need a context for it to mean something /in/
10:56:59 <mmorrow> ooh, maybe not
10:57:00 <mmorrow> hmm
10:57:02 <newsham> trhj: if you want to test for partial functions, why not use Maybe or Error to make them total ?
10:57:05 <mm_freak_> > randoms (mkStdGen 0) :: [Int]
10:57:07 <lambdabot>   [-117157315039303149,-8854136653200549331,-2598893763451025729,-21049421333...
10:57:07 * mmorrow disappears
10:57:11 <yav> FunctorSalad: yeah something like that.  I use monadLib
10:57:19 <vixey> > build (S 1) (S True) (S "foo") Z
10:57:20 <vixey> (1,(True,("foo",())))
10:57:20 <lambdabot>   Not in scope: `build'Not in scope: data constructor `S'Not in scope: data c...
10:57:21 <newsham> trhj: Just/Nothing is your extra constructor
10:57:24 <vixey> mmorrow, this sort of stuff ^
10:57:35 <mmorrow> @type S
10:57:36 <lambdabot> Not in scope: data constructor `S'
10:57:36 <vixey> is typeable
10:57:43 <mm_freak_> trhj: pattern-matching against bottom is equivalent to the halting problem
10:57:49 <mm_freak_> but maybe you've got a solution =)
10:57:55 <trhj> newsham: Maybe is tedious
10:58:04 <newsham> trhj: exactly!
10:58:28 <mm_freak_> what's wrong with Maybe?  (people constantly forget that it is a monad)
10:58:56 <sclv> "pattern matching against bottom" ~= pervasive null pointers.
10:59:22 <opqdonut> sclv: good point
10:59:25 <sclv> i.e. you go from some things are partial to everything is partial.
10:59:57 <newsham> or you could require that all programs have proofs that they are total :)
11:00:06 <trhj> indeed, can't we just test whether a pointer is NULL, or whatever bottom is implemented
11:00:17 <leimy> > take 100 $ System.Random.randomRs (0,100) $ System.Random.mkStdGen 19312991
11:00:19 <lambdabot>   [23,90,58,69,46,24,39,27,32,83,71,85,37,27,90,68,15,7,14,47,18,78,93,83,77,...
11:00:22 <newsham> trhj: yup.   Either String a
11:00:24 <mm_freak_> well, if i consider that bottom is the result of a function, which never returns, i don't see how error/undefined/bottom make a function non-total
11:00:33 <mercury^> trhj: you cannot pattern match bottom
11:00:43 <newsham> you can pattern match on "error"
11:00:54 <newsham> if you turn all values into Error values
11:00:54 <mercury^> Yes, but only practically.
11:00:57 <vixey> trhj, data Computation a = Now a | Later (Computation a)
11:01:07 <newsham> and you can do this without modifying haskell at all
11:01:11 <newsham> (if you just rewrite all of the libraries)
11:01:20 <vixey> trhj, if you view computations like this.. bottom is (Later (Later (Later (... always says Later but never shows up
11:01:26 <trhj> newsham: at least Prelude.
11:01:47 <newsham> trhj: so there you have your solution.  have at it :)
11:01:59 <mm_freak_> you guys are discussing making bottom observable…  bottom is not supposed to be observable
11:02:13 <koeien> that would be solving the halting problem
11:02:14 <mm_freak_> catching an 'error' in IO is just a convenient feature
11:02:17 <newsham> mm_freak: i think mostly he just wants 'error' to be observable
11:02:26 <yav> mm_freak_: the thing is that we can't make it observable :-)  does this program stop?
11:02:33 <vixey> trhj, the reason you cannot ever pattern match against it is because any question you can pose that takes either a finite time to answer or goes into an infinite loop (returns Later (Later ( ... = bottom) would be answerable
11:02:39 <mm_freak_> newsham: but why?  we've got Maybe and Either
11:02:46 <mm_freak_> there is no reason for 'error' to be observable
11:02:47 <newsham> mmfreak: thats what i'm telling him.
11:02:50 <leimy> > System.Random.getStdGen >>= ( \g -> return ( take 100 $ System.Random.randomRs (1,100) g))
11:02:52 <lambdabot>   * Exception: "<IO [Integer]>"
11:03:08 <vixey> trhj, does this makes sense so far?
11:03:23 <duaneb> gah
11:03:27 <duaneb> prolog makes my head hurt
11:03:34 <trhj> halting problem or whatever, I think error should be banned
11:03:35 <cizra> Haskell makes mine hurt
11:03:35 <newsham> > take 100 $ System.Random.RandomRs (1,100) $ System.Random.mkStdGen 1
11:03:36 <lambdabot>       Not in scope: data constructor `System.Random.RandomRs'
11:03:49 <vixey> trhj: I take that as "no"
11:03:51 <newsham> > take 100 $ System.Random.randomRs (1,100) $ System.Random.mkStdGen 1
11:03:53 <lambdabot>   [98,89,28,30,21,90,77,98,23,91,4,28,57,74,99,76,45,93,19,37,57,70,83,67,70,...
11:03:54 <mm_freak_> trhj: why?
11:04:14 <newsham> trhj: there are programming languages that are free of bottom
11:04:23 <koeien> yes. but they're not turing complete
11:04:27 <newsham> some of them are even similar to haskell
11:04:29 <trhj> mm_freak_: error is an excellent tool for making nasty bugs
11:04:42 <vixey> koeien, you can't express a turing machine in them?
11:04:43 <mercury^> turing completeness is overrated.
11:04:44 <mm_freak_> trhj: it is an excellent tool for catching them
11:04:56 <mm_freak_> trhj: how would you handle an 'impossible' case without 'error'?
11:05:01 <koeien> mercury^: ok. fine. but you give up something. you should be aware of that
11:05:13 <koeien> as a language implementer/designer or user
11:05:36 <mercury^> Sure.
11:05:50 <trhj> mm_freak_:everything is possible :)
11:05:51 <koeien> express the following function in your non-turing complete language: f n | n `mod` 2 == 0 = n `div` 2; f n = 3*n+1
11:06:00 <vixey> koeien not talking to me or something
11:06:01 <beso29> mercury^: do u know language mercury?
11:06:02 <koeien> can you do it? :) i don't know
11:06:27 <mm_freak_> trhj: if you find that 'error' should be banned, don't use it =)
11:06:31 <vixey> koeien: that's utterly trivial
11:06:32 <mm_freak_> i don't use it either
11:06:38 <mercury^> beso29: yes, I know the language.
11:06:50 <trhj> but why error was ever devised?
11:07:02 <leimy> fail!
11:07:08 <newsham> trhj: have you heard of http://www-users.cs.york.ac.uk/~ndm/catch/ ?
11:07:13 <mm_freak_> trhj: because a "pattern match failure" is harder to understand than "head on empty list"
11:07:15 <koeien> vixey: why?
11:07:17 <paulrus_> > 3 + 5
11:07:19 <lambdabot>   8
11:07:19 <yav> trhj: error is convenient to signal that your program has a bug.  that's all.
11:07:21 <duaneb> anyone know if python 3000 has lambda expressions still?
11:07:30 <mm_freak_> head [] = error "head on empty list"
11:07:46 <mm_freak_> > head []
11:07:47 <lambdabot>   * Exception: Prelude.head: empty list
11:07:56 <leimy> > take 1 []
11:07:58 <lambdabot>   []
11:08:16 <vixey> duaneb: #haskell
11:08:31 <newsham> duaneb: the whatsnew page doesnt say its been removed
11:08:40 <newsham> http://docs.python.org/3.0/whatsnew/3.0.html
11:08:54 <vixey> koeien: "why" what I'm bored of your doctrine
11:09:19 <xenoblitz1> :t permutations
11:09:20 <lambdabot> Not in scope: `permutations'
11:09:29 <trhj> newsham: catch seems interesting.
11:10:08 <leimy> :t Data.List.permutations
11:10:10 <lambdabot> Not in scope: `Data.List.permutations'
11:10:36 <mm_freak_> permutations came with GHC 6.10, but lambdabot is still at an earlier version
11:10:38 <leimy> @hoogle permutations
11:10:38 <lambdabot> No results found
11:10:46 <mm_freak_> , permutations "abc"
11:10:54 <lunabot>  ["abc","bac","cba","bca","cab","acb"]
11:10:58 <duaneb> vixey: what
11:11:00 <duaneb> ?
11:11:05 <trhj> But i don't think that programmers should bother how a result of non-terminating computation is represented
11:11:13 <duaneb> vixey: I assume at least one person on this channel knows my answer
11:11:22 <mm_freak_> trhj: they don't need to
11:11:37 <mm_freak_> they only know about the possibility that a function never returns, and this is natural
11:11:53 <mm_freak_> that's how there is semantically no difference between bottom and 'error'
11:12:14 <xenoblitz1> , permutatons [1..7]
11:12:16 <lunabot>  luna: Not in scope: `permutatons'
11:12:32 <mercury^> xenoblitz1: you're missing an i
11:12:32 <xenoblitz1>  , permutations [1..7]
11:12:44 <xenoblitz1> mercury: yeah silly tipo :P
11:12:58 <xenoblitz1> wow its taking some time or ...?
11:13:13 <leimy> , permutations "hi"
11:13:15 <lunabot>  ["hi","ih"]
11:13:22 <leimy> xenoblitz1: you had a leading space
11:13:28 <leimy> , permutations "foobar"
11:13:31 <lunabot>  ["foobar","ofobar","oofbar","oofbar","ofobar","foobar","boofar","obofar",...
11:13:46 <tromp_> , permutations []
11:13:48 <trhj> wouldn't be it more practical to consider error as a data constructor
11:13:48 <xenoblitz1> leimy: never used luna :)
11:13:48 <lunabot>  [[]]
11:13:57 <leimy> I bytestring version of that would be neat :-)
11:13:59 <C-Keen> :t ByteString
11:14:00 <lambdabot> Not in scope: data constructor `ByteString'
11:14:02 <leimy> s/I/A
11:14:06 <C-Keen> :t Data.ByteString
11:14:07 <lambdabot> Couldn't find qualified module.
11:14:13 <C-Keen> @src Data.ByteString
11:14:14 <lambdabot> Source not found.
11:14:14 <andun> why doesn't hoogle have the source code anymore? :/
11:14:30 <yav> trhj: this is what the error monad does
11:14:36 <mm_freak_> trhj: then you could just as well use an error-tracking monad like Maybe or Either
11:15:06 <xenoblitz1> i was trying to use permutations but i am still working with 6.8.3 since 6.10.1 does not have gtk2hs support yet... any elegant implementation of permutations anyone knows of?
11:15:55 <yav> xenoblitz1: permute the tail of the list, and insert the head in all possible places?
11:15:57 <b_jonas> xenoblitz1: I think we talked about that once
11:16:00 <b_jonas> let me check the logs
11:16:04 <trhj> mm_freak:yes, but in proposed version i don't need to write Just everytime!
11:16:18 <xenoblitz1> yav: nice idea
11:16:23 <xenoblitz1> b_jonas: wasn't around
11:16:47 <yav> trhj: being explicit about what can go wrong is why we way that haskell has no _side_ effects.
11:16:54 <b_jonas> but that was perhaps months ago
11:17:03 <gwern> '>   50. file://localhost/home/brent/hacking/hwn/20081225.html' hee
11:17:05 <b_jonas> do I have to download all logs if I want to search in them?
11:17:08 <b_jonas> I've no idea when it was
11:17:12 <mm_freak_> trhj: if you need to do that with Maybe, you're doing something wrong
11:17:19 <mm_freak_> trhj: remember that Maybe is a monad!
11:17:25 <gwern> b_jonas: I find google does pretty well at hitting #haskell logs when necessary
11:17:55 <mm_freak_> trhj: maybe you want to beta-read my monads tutorial…  the motivation is related to your problem =)
11:17:57 <b_jonas> gwern: thanks, I'll try
11:19:14 <gwern> b_jonas: although for some reason doing a site: in the query to restrict it to tunes.org hasn't seemed to work for me
11:19:30 <xenoblitz1> also which algorithm was picked for permutations 6.10.1?
11:19:56 <mercury^> @src permutations
11:19:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:20:16 <mercury^> @src Data.List.permutations
11:20:16 <lambdabot> Source not found. My brain just exploded
11:20:59 <xenoblitz1> , src Data.List.permutations
11:21:02 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
11:21:07 <tromp_> @src join
11:21:08 <lambdabot> join x =  x >>= id
11:21:29 <mm_freak_> , select "abc"
11:21:32 <lunabot>  luna: Not in scope: `select'
11:22:36 <b_jonas> still searching
11:23:17 <dnul> question
11:23:17 <yav> xenoblitz1: still looking for permutations?
11:23:33 <xenoblitz1> yav: yeah
11:23:38 <xenoblitz1> trying to work it your way :)
11:23:43 <yav> perms []        = [ [] ]
11:23:43 <yav> perms (x : xs)  = concatMap (ins x) (perms xs)
11:23:43 <yav>   where
11:23:43 <yav>   ins x ys        = (x : ys) : case ys of
11:23:43 <yav>                                  [] -> []
11:23:44 <yav>                                  z : zs -> map (z:) (ins x zs)
11:23:56 <tromp_> @let perms
11:23:56 <tromp_> = join (evalStateT . mapM (const (StateT pick))) where pick [] = []; p
11:23:56 <tromp_> ick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
11:23:56 <lambdabot>   Parse error
11:24:11 <tromp_> @let permute = join (evalStateT . mapM (const (StateT pick))) where pick [] = []; p
11:24:12 <tromp_> ick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
11:24:12 <lambdabot>   Parse error
11:24:20 <b_jonas> yav: I still am, not because I can't implement it but because I want to find those logs now
11:24:25 <tromp_> @let permute = join (evalStateT . mapM (const (StateT pick))) where pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
11:24:27 <lambdabot>  Defined.
11:24:33 <dnul> if using an array , and using amap (map for arrays) how can i make a function that gets to know the element index  ?
11:24:56 <xenoblitz1> yav: thanks
11:24:59 <tromp_> > permutations "abcd"
11:25:01 <lambdabot>   Not in scope: `permutations'
11:25:16 <tromp_> , permutations "abcd"
11:25:19 <lunabot>  ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","b...
11:25:27 <tromp_> , permutate "abcd"
11:25:30 <lunabot>  luna: Not in scope: `permutate'
11:25:33 <tromp_> > permutate "abcd"
11:25:35 <lambdabot>   Not in scope: `permutate'
11:25:41 <tromp_> > permute "abcd"
11:25:42 <mm_freak_> dnul: unfortunately there is no function for this…  you'll need to use assocs
11:25:43 <lambdabot>   ["abcd","abdc","acbd","acdb","adbc","adcb","bacd","badc","bcad","bcda","bda...
11:25:53 <tromp_> hmm, not that algorithm
11:29:54 <dnul> thx u
11:31:24 <b_jonas> oh no why can't I find it
11:31:47 <dnul> can i make an array of tuples?
11:31:55 <b_jonas> dnul: yes, you can
11:34:15 <EvilTerran> > zip [0..] "abracadabra"
11:34:16 <lambdabot>   [(0,'a'),(1,'b'),(2,'r'),(3,'a'),(4,'c'),(5,'a'),(6,'d'),(7,'a'),(8,'b'),(9...
11:34:20 <EvilTerran> dnul, you can map over that
11:34:50 <EvilTerran> > reverse $ zip [0..] "abracadabra" -- the result of zipping has the length of the shorter of the two input lists
11:34:51 <lambdabot>   [(10,'a'),(9,'r'),(8,'b'),(7,'a'),(6,'d'),(5,'a'),(4,'c'),(3,'a'),(2,'r'),(...
11:35:22 <EvilTerran> ?type zip [0..] "abracadabra"
11:35:23 <lambdabot> forall t. (Enum t, Num t) => [(t, Char)]
11:37:56 <dnul> EvilTerran: what do you mean? my problem was that i need to map over an array with a function that knows the element index, i solved in an unefficient way by making an element (index,element)
11:38:21 <dnul> EvilTerran: so the array is (index,(index,element)) :(
11:39:05 <idnar> an array, or a list?
11:39:12 <b_jonas> dnul: I thought there was a function for that
11:39:33 <b_jonas> assocs
11:39:38 <dnul> b_jonas: for doing what precisely?
11:39:56 <b_jonas> getting a list of pairs of array index and element
11:39:57 <dnul> :t assocs
11:39:58 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
11:40:18 <dnul> i dont want a list i want an array :)
11:40:29 <defun> I am having trouble understanding this example from real world haskell (http://hpaste.org/13341). Would someone be able to explain it to me (particularly the '<-' and '->') or point me to some documentation, tutorial, handbook, etc that *can* explain this. RWH is very unclear, imho, in this particular example.
11:40:47 <b_jonas> dnul: then write a function using zip like Evil says
11:41:14 <dnul> b_jonas: zip is for lists... isnt it?
11:41:21 <b_jonas> defun: the problem is that -> means lots of different things, it's general punctation
11:41:25 <paper_cc> defun, will you understand a Python translation?
11:41:34 <defun> sure.
11:41:50 <b_jonas> defun: -> can be punctation in case, punctation in lambda, the type constructor of function types, and more
11:42:01 <b_jonas> in here it's punctuation for a case statement
11:42:17 <defun> i see.
11:42:19 <newsham> defun: the book should have explained what "<-" means inside of do-blocks (ie. when doing IO)
11:42:26 <gwern> interact on files? interesting
11:42:30 <newsham> the "->" is part of the "case" syntax
11:42:55 <defun> oh, i get it. thanks. d'oh!
11:42:57 <b_jonas> a case statement does pattern matching, 'case FOO in { BAR -> QUX; ...' the FOO is an expression that is matched to BAR, if it matches successfully the value of the case expression is the expression QUX which can use the bindings from the pattern matchings
11:42:57 <newsham> anyway, the "<-" indicates a binding of the result of the IO action.
11:43:18 <b_jonas> yeah, luckily <- isn't used for that many things so far
11:44:10 <b_jonas> only binding in do blocks and related things (list comprehensions, mdo, arrow notation)
11:46:34 <conal> i'm installing the curl package on linux (ubunut), and i don't know which which debian packages to install first.  i see libcurl4-gnutls-dev and libcurl4-openssl-dev.  i don't see a -dev for libcurl3, which i have installed.  any advice?
11:47:09 <newsham> the apt-get tool should install the requisite dependencies if you select one that requires another
11:47:47 <newsham> i imagine you need either but not both of the libcurl4 one's if you want libcurl4
11:47:54 <newsham> its weird that theres no -dev for libcurl3
11:48:00 <koeien> conal: yes, apt should figure this out
11:48:40 <koeien> the difference between -gnutls and -openssl is the underlying library for SSL
11:48:53 <conal> newsham, koeien: i think apt will grab additional dependencies.  i'm wondering which -dev to start with.  maybe it doesn't matter.
11:49:15 <newsham> i would personally go with openssl over gnutls
11:49:29 <conal> ok.  thanks.
11:49:55 <newsham> hmmm.. my system (somewhat older) lists "libcurl3-dev" when I "apt-cache search libcurl"
11:50:20 <newsham> and also separate libcurl3-gnutls-dev and libcurl3-openssl-dev
11:50:28 <newsham> i imagine the first one has no ssl support configured?
11:50:41 <koeien> libcurl-dev seems to be a virtual package
11:51:12 <koeien> newsham: on debian testing there is no such package. i guess ubuntu wont have one as well
11:52:09 <newsham> (this is ubuntu 6.10)
11:52:49 <dv_> hmm
11:53:10 <dv_> let x = ('a', [5, 10])  snd(x) [1] <- how do I do the latter one right?
11:53:55 <paper_cc> snd(x) !! 1 -- I suppose
11:54:03 <newsham> > let x = ('a', [5, 10]) in snd x !! 1
11:54:05 <lambdabot>   10
11:54:15 <mmorrow> here's the src to Data.List.permutations from ghc-6.10.1 http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=689#a689
11:54:19 <dv_> thanks
11:54:23 <newsham> ?hoogle [a] -> Int -> a
11:54:24 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:54:24 <lambdabot> Data.List (!!) :: [a] -> Int -> a
11:54:24 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
11:58:04 <newsham> ?djinn ([b], [a]) -> a
11:58:04 <lambdabot> Error: Undefined type []
12:02:12 <defun> btw, is it normal for ghci not to recognize backspace, delete, ^C and the arrow keys?
12:02:19 * boegel looks into ways of efficiently handling huge static sparse matrices in Haskell
12:02:49 <newsham> defun: i wouldnt say its "normal"
12:03:08 <defun> damn
12:03:46 <b_jonas> defun: have you just upgraded to 6.10?
12:03:53 <defun> yes
12:03:57 <b_jonas> defun: it's still not normal but it's happened to other people too
12:04:01 <b_jonas> to me as well
12:04:10 <b_jonas> it sucks
12:04:16 <defun> yes it does.
12:04:17 <b_jonas> I could fix it though
12:04:22 <defun> how?
12:04:38 <b_jonas> I think I had to recompile it with 6.10 and maybe some haskell modules installed
12:05:00 <b_jonas> let me see
12:05:05 <b_jonas> that must be in the irc logs as well
12:05:11 <b_jonas> I can't remember the whole thing
12:05:27 <dnul> why is REPL shell much more slower than ghc?
12:05:52 <newsham> ghci runs an interpretter instead of compiled code i think
12:06:15 <paper_cc> ghci runs bytecode
12:06:57 <b_jonas> defun: http://tunes.org/~nef/logs/haskell/08.11.08
12:07:16 <b_jonas> defun: oh, I think I needed to install a c library too
12:07:36 <b_jonas> editline or something similar (but it's tricky for there are two libraries of very similar name and I don't know their exact relation)
12:07:48 <newsham> gnu readline?
12:07:53 <defun> thanks.
12:08:19 <mmorrow> install libedit(-dev)
12:08:53 <vixey> oh I have a question
12:08:59 <b_jonas> newsham: no, that was what they used before 6.10 and that _worked_
12:10:01 * boegel wonders if NDP is something he could use for his sparse matrices
12:10:26 <vixey> has anyone used ReadP for anything real?
12:10:27 <b_jonas> defun: ok, I'm still not sure even from that logs but I think installing that C library and then rebuilding and reinstalling 6.10 should work
12:10:50 <vixey> because if so I guess you must have written a lot of extensions to ReadP
12:12:10 <boegel> @hoogle readP
12:12:10 <lambdabot> module Distribution.Compat.ReadP
12:12:10 <lambdabot> module Text.ParserCombinators.ReadP
12:12:10 <lambdabot> Distribution.Compat.ReadP type ReadP r a = ReadP a
12:13:00 <newsham> if its any consolation, 6.10 ghci line editing is fine in the win32 bins :)
12:14:45 <pejo> Worked out of the box for me too, sshing from solaris -> OSX.
12:18:54 <b4taylor> hpaste allows empty strings to be pasted?
12:19:21 <sw17ch> Where do the Functor instances for (,) (,,) etc... hide?
12:19:34 <b_jonas> sw17ch: prelude?
12:19:42 <sw17ch> it doesn't appear so...
12:19:49 <sw17ch> > fmap (+1) (1,2,3)
12:19:50 <lambdabot>       No instance for (Functor ((,,) t t1))
12:19:50 <lambdabot>        arising from a use of `fma...
12:19:52 <sw17ch> :(
12:20:02 <vixey> sw17ch, well they aren't functors
12:20:13 <sw17ch> vixey: i figured that'd be the answer :)
12:20:21 <newsham> > fmap (+100) (1,2)
12:20:22 <lambdabot>   (1,102)
12:20:31 <sw17ch> oh, that's right...
12:20:39 <sw17ch> i had this discussion with some one a while ago...
12:20:49 <vixey> (,) e is not (,)
12:21:10 <sw17ch> it ended with "just because you could write an instance doesn't mean you should"
12:21:29 <newsham> ?src ((,) a) fmap
12:21:30 <lambdabot> Source not found. :(
12:21:35 <newsham> ?src fmap ((,) a)
12:21:35 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:21:41 <vixey> sw17ch, oh it's actually possible to make an instance for them? how?
12:22:44 <newsham> to be an instance of functor it has to be a type with one parameter
12:22:49 <newsham> right?
12:23:42 <newsham> (,) has two type parameters
12:23:56 <paper_cc> newsham, make an instance for (,) a a
12:24:15 <b_jonas> @src (,) fmap
12:24:16 <lambdabot> fmap f (x,y) = (x, f y)
12:24:23 <paper_cc> brr
12:24:24 <b_jonas> yes, the instance is for (,)a
12:24:29 <b_jonas> but the lambdabot syntax is this
12:24:40 <b_jonas> because in classic h89 this is unambiguous
12:24:48 <b_jonas> newsham: hilite
12:26:13 <sw17ch> ah, yes, i remember now...
12:26:24 <sw17ch> kind issues bother me... i wish we could do kind-level polymorphism
12:26:38 <b_jonas> oh no, not that please
12:27:00 <mmorrow> vixey: here's some messy-parts-broken-in-progress-but-should-load-in-ghci code that uses ReadP as a starting point
12:27:16 <newsham> it would be neat/weird/etc.  if you could  "fmap (+1) (x,y)" for any Num x, Num y (x not necessarily y)
12:27:22 <paper_cc> at last, what do you want fmap (+1) (1, 2, 3) evaluate to?
12:27:28 <mmorrow> vixey: i'm trying to work out a nice incremental parser
12:27:39 <mmorrow> vixey: pain and suffering :)
12:27:42 <vixey> mmorrow, I guess nobody has written this but it's not a problem
12:27:51 <mmorrow> haha
12:27:52 <vixey> mmorrow, instead of run :: ReadP a -> String -> a
12:27:52 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=690#a691
12:28:00 <mmorrow> i almost forgot the link
12:28:08 <mmorrow> vixey: ok
12:28:12 <vixey> mmorrow, I will use run :: ReadP a -> String -> (a, TextPosition, String)
12:28:26 <mmorrow> hmm, cool. so what is TextPosition
12:28:27 <mmorrow> ?
12:28:38 <vixey> a bad name :/
12:28:43 <vixey> anyay = (Row, Column)
12:28:57 <mmorrow> ah, nice. that'd be very convenient
12:29:16 <mmorrow> have you seen the Parsek darcs repo that's ReadP tricked out like Parsec?
12:29:18 <vixey> oh you've reimplemented it for bytestring
12:29:50 <mmorrow> vixey: i tried to make it so you could swap anything in there
12:29:56 <vixey> no where is Parsek?
12:30:08 <mmorrow> oh yeah, it's in augustss's darcs repos
12:30:41 <mmorrow> http://www.augustsson.net/Darcs/Parsek/
12:31:17 <mmorrow> that one has the full Parsec interface, plus is ReadP underneath, but with the String not hardcoded
12:31:20 <ddarius> newsham: (,) isn't a functor in both arguments (simultaneously) unless they are the same type.
12:32:04 <newsham> ddarius: hence neat/weird
12:32:06 <ddarius> newsham: Also (,) is a functor in each component individually so that would be ambiguous.
12:32:53 <newsham> a dynamic language would have no problem mapping (+1) across a tuple of various numeric types
12:33:04 <vixey> mmorrow ugh now I have too many choice
12:33:27 <ddarius> newsham: The problem isn't doing it, the problem is specifying what you mean.
12:33:34 <vixey> mmorrow, I can already parse syntactically correct pages of code but I don't know what to do for errors
12:33:39 <mmorrow> vixey: definitely a double-edged sword
12:33:54 <newsham> ddarius: *nod* and I wonder if it would be possible to make sense of such a thing
12:34:11 <newsham> (obviously not in haskell's type system)
12:34:42 <vixey> newsham: GADT  fmap' TUP_1_LEFT (+1) (3,2) ~~> (4,2)
12:34:56 <mmorrow> vixey: check out the data decl for P in Parsek. it uses (Fail [String] [String]) instead of just Fail, for "Expected" and "something-or-other"
12:35:28 <newsham> vixey: now try    fmap'' (+1) (1.0 :: Float, 1 :: Int)
12:35:35 <vixey> newsham, no
12:35:51 <vixey> newsham, you miss the *crucial* thing
12:35:56 <mmorrow> so you can give nice error msgs with    pfail ["int","a `c' Char","5 eofs"] ["maybe do this"]
12:35:57 <newsham> to get (2.0 :: Float, 2 :: Int)
12:36:06 <vixey> mmorrow, that makes no sense to me
12:36:09 <newsham> from (+1) :: Num a => a -> a
12:36:13 <mmorrow> vixey: heh
12:36:14 <adekoba> there seems to be only two serialization packages on hackage that offer error handling support: HCodecs and binary-strict. Binary just runs `error`. Can anyone attest to this?
12:36:17 <vixey> mmorrow, pfail does barktracking
12:36:24 <mmorrow> pfail fails
12:36:27 <vixey> mmorrow, not error barking
12:36:32 <mmorrow> heh
12:36:40 <vixey> so how can anything do _both_?
12:36:47 <vixey> I don't know a Prolog system that says more than "no."
12:36:52 <paper_cc> ErrorT maybe&
12:36:59 <paper_cc> s/be&/be?/
12:37:00 <mmorrow> i guess i only use pfail with look now that i think of it
12:37:33 <sclv_> barktracking? does that growl when cut?
12:37:35 <mmorrow> vixey: check out the Parsek code, i'm sure there're example of how you're supposed to report errors
12:37:40 <mmorrow> (i have no idea ;)
12:38:14 <sclv_> i sketched out a barktracking monad once, but it was sort of ruff.
12:38:18 * sclv_ is so sorry.
12:38:25 <mmorrow> @remember vixey pfail does barktracking, not error barking
12:38:25 <lambdabot> It is stored.
12:38:38 <mmorrow> sclv_: heh
12:39:56 <wli> vixey: Prolog Technology Theorem Provers (PTTP's) do the iterative deepening etc. -based complete searches.
12:44:46 <mmorrow> vixey: wait, i just realized something essential. since ReadP does bfs, it's constantly pfailing, and in each of those cases you have an opportunity to add the the [Expected] [Warning] lists, and mplus for P probably accumulates that.
12:45:20 <mmorrow> and the errors would only ever be shown if /all/ possible paths pfail
12:45:49 <mmorrow> i dunno how Parsek handles the Fail constructor ottomh though..
12:46:26 <mmorrow> i do know it has a (<?>) or something
12:47:57 <vixey> ok so if you have a text 100 chars long
12:48:11 <vixey> and maybe there is a missing open quote
12:48:32 <vixey> I can't imagine that [Expected] [Warning] would be informative
12:48:52 <vixey> maybe I am visualising it wrong
12:49:18 <vixey> because i.e. a lot of these will come up in a good parse
12:49:28 <vixey> so how do you know which ones are actually bad?
12:53:34 <vixey> idk what to do now :/
12:56:32 <lucca> parsec handles fail by returning Left with the fail message appended to the other stuff
12:59:14 <vixey> lucca, yeah
13:03:27 <pk__> hey
13:04:29 <pk__> How could I know what is the actual type meant by Scalar (Behaviour (Vector3 Double)) ?
13:04:39 <pk__> I thought it was Behavior Double
13:05:21 <yav> pk__: check the instance?
13:06:15 <pk__> ok
13:06:19 <pk__> thx
13:08:34 <vixey> ?where catch
13:08:34 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
13:12:50 <ksf> @seen conal
13:12:50 <lambdabot> I saw conal leaving #haskell and #ghc 43m 13s ago, and .
13:12:53 <ksf> argh.
13:12:53 <lambdabot> ksf: You have 1 new message. '/msg lambdabot @messages' to read it.
13:14:58 <ksf> did anyone else ever observe reactive-fieldtrip behaving differently under ghc --make and ghci? (not displaying anything but black in the latter case)
13:15:45 <sclv_> vixey: you're lp, right?
13:15:56 <vixey> what
13:16:05 <sclv_> oh, guess not.
13:16:12 <sclv_> luke
13:16:22 <vixey> @seen luqui
13:16:22 <lambdabot> I saw luqui leaving #haskell 15h 25m 37s ago, and .
13:16:29 <sclv_> oh, thanks.
13:17:24 <kublar> preflex: ? whois:luqui
13:17:25 <preflex>  factoid not found
13:22:46 <procyon> can someone explain why the following doesnt work:
13:23:03 <kublar> not enough goats
13:23:07 <vixey> lol
13:23:09 <procyon> x (a, b, c) = a
13:23:10 <procyon> x (a, b)    = a
13:23:14 <kublar> different types
13:23:20 <vixey> procyon, apples and oranges
13:23:25 <kublar> what would the type of 'x' be?
13:23:26 <b_jonas> no, the first guess was right, not enough goats
13:23:37 <vixey> procyon, how about:  x (a, (b, c)) = a ; x (a, b) = a
13:23:48 <kublar> overlapping but compiles
13:24:39 <ksf> Haskell doesn't like people who don't like Curry.
13:24:54 <ddarius> vixey: You of course realize that the second case covers both
13:25:13 <b_jonas> no, it's the first case that covers both
13:25:18 <ddarius> ksf: Curry didn't like Haskell.
13:25:22 <b_jonas> um, almost
13:25:33 <b_jonas> the first case dies if the second is bottom
13:25:39 <ksf> (and that it doesn't matter as both are equivalent to x (a, _) = a or, rather, fst.
13:25:40 <vixey> o_________________________________________________o
13:25:47 <pumpkin> wow wide vixey
13:25:52 <b_jonas> but if you add some |guards, they might be different then
13:26:41 * ksf refuses to regard a bottom-exception as legal semantic value.
13:27:44 <ksf> defining programs in terms of brokenness is pascal's domain, not haskell's.
13:28:15 <pumpkin> they kinda sound similar though
13:29:09 <ksf> not if you pronouce the a in pascal like it's supposed to be pronounced.
13:29:37 <kublar> paskull
13:29:47 <ksf> it's not written paiscelle, after all.
13:30:31 <vixey> time me change things but you can't change time
13:30:52 <wli> String-based errors suck. String rendering should be deferred until it's time to do IO.
13:31:06 <wli> strMsg pains me therefore.
13:31:20 <sclv_> ok so here's the weird datastructure I need.
13:31:24 <kublar> throw "I <3 C++";
13:31:51 <sclv_> Given an an associative list, ascending in its keys...
13:32:16 <sclv_> create a data structure that is spine lazy and supports ranged lookup.
13:32:48 <sclv_> so I can find the first element whose key is less than some value.
13:33:09 <sclv_> I know some sort of trie on the naturals is the only way to go, but I'm still not sure how to create this.
13:33:31 <b_jonas> is the list finite?
13:33:40 <sclv_> potentially infinite.
13:33:45 <b_jonas> hmm
13:33:48 <b_jonas> harder then
13:33:58 <wli> hash tries are particularly nice
13:34:13 <sclv_> the spine-lazy multiqueue thread gave me some ideas
13:34:28 <wli> The basic idea is tries with large branching factors where hashing by open addressing is used to compress the nodes.
13:35:18 <ddarius> sclv_: lookupLessThan 0 (makeFoo $ zip [1..] $ repeat 'a')
13:35:30 <wli> More advanced methods use variable bitslicing instead of fixed branching factors.
13:35:53 <sclv_> ddarius: nontermination is acceptable in that circumstance...
13:36:15 <wli> I don't believe these are very lazy.
13:36:16 <sclv_> although in reality the first element is always 0
13:36:58 <ksf> wut? there's no way to set a material for a 2d geometry in fieldtrip without using IO?
13:49:50 <sclv__> anyway the point being to get a better representation for :-> than [:->#]
13:51:35 <ksf> what's the state of truetype support for fieldtrip? do-it-yourself?
13:52:53 <ksf> conal, I might have messed up reactive-glut a bit with that non-freeglut patch.
13:53:18 <ksf> that is, displaying stuff with ghci doesn't really work here.
13:53:54 <vixey> ReadPP.hs:72:1: lexical error at character 'i'
13:53:58 <vixey> #ifdef __GLASGOW_HASKELL__
13:54:03 <vixey> .............
13:54:03 <conal> ksf: truetype for fieldtrip would be a very welcome contribution
13:54:05 <vixey> great
13:54:26 <conal> fieldtrip hasn't been getting tlc lately.  i've been focused on reactive.
13:54:59 <ddarius> vixey: Add the flag for the preprocessor
13:55:00 <conal> ksf: you're not getting graphics displayed with non-freeglut ?
13:55:09 <ksf> not with ghci, no.
13:55:25 <ksf> didn't do any extensive testing, though.
13:55:45 <conal> ksf: hm.  weird.  how about trying with that freeglut line commented out?
13:55:56 <ksf> then it's going to crash.
13:56:00 <ksf> erm...
13:56:23 <ksf> i guess you meant commenting out the call, not just the catch.
13:56:54 <vixey> ddarius, but then it says ghc: could not execute:
13:57:47 <ksf> nope, no luck
13:59:22 <defun> just a quick survey, how many spaces do you indent your haskell code? i.e. how wide are your tabs?
13:59:32 <ksf> 4
13:59:32 <vixey> I don't use tabs
13:59:37 <Olathe> Tabs are Satanic !
13:59:39 <ksf> ...expanded to spaces.
13:59:46 <Olathe> I use two, though.
14:00:14 <defun> good 2 know.
14:00:19 <defun> thnx
14:00:45 <Olathe> You can look on hpaste.
14:01:02 <h3raLd> Hello, I'm having problems installing yi. Could anyone help me? (I'm new to Haskell and Cabal)
14:01:06 <Olathe> Lots of data on spacing there.
14:05:40 <dejones> Hello, I'm confused how to get out of the Monad transformer type, CGIT IO URI to IO URI.
14:06:03 <kublar> runCGIT
14:06:12 <kublar> -- answer untainted by knowledge or experience
14:06:34 <dejones> kublar: runCGIT :: Monad m => CGIT m a -> CGIRequest -> m (Headers, a)
14:06:52 <kublar> there we go
14:06:57 <dejones> kublar: I'm not sure where how to supply the second argument, the CGIRequest...?>
14:07:06 <kublar> me neither :-)
14:07:08 <dejones> heh.
14:08:32 <vixey> how do you just run the ghc preprocessor?
14:08:38 <vixey> and get the haskell file out at the end
14:09:26 <Heffalump> -E -cpp
14:09:50 <sw17ch> if i want a UTCTime from Data.Time to be expressed as nanoseconds/seconds/Integral(s) since 1970, how does one do that?
14:09:55 <sw17ch> i do'nt see any easy conversion functions...
14:10:00 <vixey> thank you
14:10:22 <kublar> doesn't it already do that?
14:11:47 <kublar> hmm
14:12:32 <pumpkin> anyone have any info on gpugen?
14:14:26 <kublar> sw17ch: step 1 would be to get 1.1.1970 as a UTCTime
14:14:38 <pumpkin> wow, galois died REALLY young
14:15:02 <cizra> Yeah )=
14:15:10 <cizra> What he could have achieved if he had lived longer…
14:15:11 <sw17ch> kublar, i got that far, i was just curious why there isn't a standard way to extract this info
14:15:18 <pumpkin> damn duel
14:15:28 <kublar> sw17ch: I don't see one :/
14:15:36 <kublar> :t readTime
14:15:36 <lambdabot> Not in scope: `readTime'
14:15:42 <sw17ch> kublar, me either, so i asked :)
14:17:07 <vixey> what shouold I call that pair of Row/Column number of in a text file?
14:17:14 <kublar> sw17ch: oh, there's an easy way for whole seconds
14:17:18 <pumpkin> coordinates?
14:17:51 <kublar> formatTime defaultTimeLocale "%s"
14:18:16 <jkff> vixey: like, RowCol?
14:18:19 <pejo> vixey, SrcLoc
14:18:31 <vixey> thanks
14:18:37 <ksf> (.text+0x6b2): undefined reference to `ftglRenderFont'
14:18:39 <ksf> onoes.
14:20:33 <vixey> @src Reads
14:20:33 <lambdabot> Source not found. Maybe you made a typo?
14:20:34 <vixey> @src ReadS
14:20:34 <lambdabot> Source not found. That's something I cannot allow to happen.
14:21:05 <conal> pumpkin: i'm also looking for gupgen info.
14:21:20 <pumpkin> ?
14:21:22 <pumpkin> oh
14:21:25 <pumpkin> yeah :)
14:21:45 <trygvis> if I want something like "for each a in [a]", should I use map? or is there something more appropriate?
14:21:53 <trygvis> I just want to call a function for every element in a list
14:22:02 <conal> andyjgill: hi.
14:22:03 <vixey> trygvis, to what end?
14:22:04 <jkff> trygvis: what does this function do?
14:22:05 <kublar> trygvis: depends on what you want to do with the results
14:22:17 <jkff> trygvis: does it have side effects?
14:22:26 <trygvis> I don't care about the result of the function. no, no side effects
14:22:35 <vixey> :t map
14:22:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:22:37 <jkff> trygvis: Then, is your function of type IO a ?
14:22:45 <kublar> trygvis: then don't do anything
14:22:56 <kublar> if you don't use the results, nothing happens
14:23:20 <jkff> :t map putStrLn [1,2,3]
14:23:22 <lambdabot>     No instance for (Num String)
14:23:22 <lambdabot>       arising from the literal `1' at <interactive>:1:14
14:23:22 <lambdabot>     Possible fix: add an instance declaration for (Num String)
14:23:24 <pumpkin> trygvis: the point is that what you should use depends on what you're doing in the body of that loop
14:23:30 <jkff> :t map (putStrLn . show) [1,2,3]
14:23:31 <lambdabot> [IO ()]
14:23:34 <trygvis> hm, true. ok, so I care about the results
14:23:41 <trygvis> so map is probably appropriate then
14:23:45 <sw17ch> kublar, missed it, how does one do that?
14:23:46 <jkff> :t mapM (putStrLn . show) [1,2,3]
14:23:48 <lambdabot> IO [()]
14:23:53 <pumpkin> trygvis: you want to get a new list of the same size then?
14:23:59 <trygvis> yep
14:24:02 <kublar> sw17ch: formatTime defaultTimeLocale "%s"
14:24:12 <pumpkin> jkff: shouldn't mapM_ be better for that?
14:24:19 <jkff> pumpkin: yes
14:24:23 <kublar> :t mapM_ print [1,2,3]
14:24:24 <lambdabot> IO ()
14:24:46 <jkff> Then just use map. But if your function is an IO action, then you'll get a list of IO actions. To perform them in sequence, you'll have to use (surprise!) 'sequence'.
14:24:55 <jkff> A shorthand for sequence . map f is mapM f
14:25:12 <trygvis> hm, ok (I *think* I understand)
14:25:24 <jkff> :t sequence
14:25:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:25:36 <trygvis> I'll run the function over the list first and then print the results (which would result in a list of IO actions)
14:25:56 <jkff> So, you want to print the results of a function on a list?
14:26:07 <kublar> well, you could just use 'print'
14:26:17 <kublar> :t print (map (* 2) [1 .. 10])
14:26:18 <lambdabot> IO ()
14:26:25 <trygvis> it is an intermediate, I want to print it for debugging
14:26:28 <ksf> for a c library, libftgl.so.0's symbol table looks suspiciously like c++.
14:26:28 <vixey> mmorrow, well I have:  readP_to_S' (0,0) (munch (const True)) "foo" ~~> [(((3,0),"foo"),"")]
14:26:33 <pumpkin> you could also use Debug.trace and "stay pure" but I'm sure someone will get pissed at me for suggesting that :P
14:26:43 <trygvis> O:o
14:27:19 <jkff> trygvis: So, you really just need some debug output and you want the whole thing to be pure?
14:27:26 <vixey> pumpkin: that's a rubbish suggestion
14:27:33 <pumpkin> that's what I thought
14:27:34 <vixey> pumpkin: that's a great suggestion*
14:27:38 <pumpkin> oh no :(
14:27:40 <Heffalump> Debug.trace isn't very pure at all, but it's very convenient
14:27:50 <pumpkin> Heffalump: but it looks pure :P
14:27:50 <trygvis> yes. though at the very end I'll need to print it
14:28:10 <jkff> Then Debug.Trace.trace is ok
14:28:21 <kublar> a refreshing desert in the oasis of referential transparency
14:28:23 <trygvis> great, thanks!
14:28:34 <jkff> let x = 5 in trace ("x is " ++ show x) $ x
14:29:11 <jkff> However, the actual output may very well appear at an unexpected moment and cause some changes in the complexity of your program
14:29:25 <jkff> Because it will cause the whole list to be fully and deeply evaluated to print it.
14:29:38 <jkff> Without trace, your program may have not needed the whole list.
14:30:07 <jkff> For example, if you'll trace (show [1..]), the program will start printing the infinite list of naturals
14:30:32 <jkff> let x = [1..] in trace (show x) $ head x - here trace changes the semantics cardinally
14:31:04 <trygvis> right
14:32:46 <jkff> ...Maybe is *now* anyone online who can decipher the output of ghc -ddump-inlinings?...
14:37:15 <jkff> Oh well. Probably Morpheus will explain me.
14:37:17 * jkff goes to sleep
14:37:18 <pejo> jkff, that's a long list of what it considers inlining, various properties of it, and the choice of the inliner?
14:37:22 <jkff> Oh!
14:37:30 <jkff> pejo: Yes
14:37:45 <jkff> Precisely, I don't understand what do the 'guidance' lines mean, and they seem to be the most meaningful
14:37:58 <mae_work> hello
14:38:31 <jkff> I understand that NEVER means NEVER and IF_ARGS means 'if arguments are good enough', but I don't understand the other stuff and I don't understand what it means for an argument to be good.
14:38:35 <ksf> how do I get ghc --make to use a linker that groks c++ mangling?
14:39:14 <jkff> mae_work: hi
14:41:24 <pejo> jkff, from backwards: discount, size, (discount for val_binders), number of value binders
14:41:43 <mae_work> why don't we form a central bank of haskell, and pay haskellers for their contributions in "currys"
14:41:47 * jkff takes a look
14:42:25 <pejo> jkff, that paper you were reading yesterday (?) talks about the discounts iirc.
14:43:05 <jkff> pejo: Actually I didn't read it yet :-/ Thanks for the reply, you put me to shame and now I'll read it thoroughly :)
14:44:07 <pejo> jkff, I don't remember the paper that well, it might not talk about it. :-)
14:45:11 <jkff> It does
14:45:18 <jkff> On page 15
14:45:52 <jkff> All in all, the paper seems to be exactly what I'm seeking for
14:46:54 * ksf thinks the ftgl guys just don't do c bindings, anymore.
14:47:12 <ksf> stumbling across a copy of the lib in the blender cvs isn't a good omen.
14:47:41 <pumpkin> :o
14:47:45 <pumpkin> blender uses cvs?
14:48:11 <ksf> dunno. some rcs with a web interface.
14:50:03 <trygvis> I doubt that this recursion base case is the best: http://rafb.net/p/4emOc669.html, anyone got a tip?
14:50:29 <dibblego> mapM_
14:50:49 <trygvis> hm
14:51:03 <jkff> printMenu = mapM_ putStrLn
14:51:09 <trygvis> right
14:51:19 <jkff> Better roll your implementation of mapM_ rather then of printMenu
14:51:28 <jkff> That will be pedagogically more useful and interesting
14:51:59 <dmhouse> jkff: return () is the canonical IO action that does nothing, btw.
14:52:07 <dibblego> putStrLn . ("Name: " ++) . name
14:52:28 <dmhouse> But yes, yours is a classic application of mapM_
14:53:30 <jkff> dmhouse: I know :) Were you speaking to trygvis?
14:53:40 <dmhouse> Yes. :) trygvis, as above.
14:55:08 <trygvis> :)
15:22:18 <pumpkin> so, I'm kinda scared of asking this
15:22:22 <pumpkin> but what the hell is http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms ?
15:23:03 <oklopol> someone translated that to me once
15:23:07 <oklopol> it's nothing that complex
15:23:28 <oklopol> (don't ask me *what* it means though, i don't remember :-P)
15:23:50 <vixey> why it's just a zygohistomorphic prepromorphism. . .
15:24:02 <vixey> @w80 zygo
15:24:14 <lambdabot> No match for "zygo".
15:24:14 <Heffalump> isn't it a joke?
15:24:19 <Olathe> @w80 zygo-
15:24:20 <pumpkin> I thought so
15:24:21 <lambdabot> No match for "zygo-".
15:24:23 * Heffalump reads the page
15:24:23 <vixey> it's from Control.Category
15:24:57 <asgaroth> A usage example would definitely be nice on that page.
15:24:57 <Heffalump> I still think it's a joke
15:25:08 <pumpkin> yeah, it is
15:25:11 <asgaroth> (a more elaborate, practical one)
15:25:18 <vixey> it's not a joke!
15:25:22 <Saizan> Heffalump: edward gave a definition of one though
15:25:24 <pumpkin> or if nothing else, an example of ridiculous terminology to scare noobs with
15:25:25 <Olathe> 1. Yoke; pair: zygodactyl.
15:25:25 <Olathe> 2. Union: zygospore.
15:25:32 <Heffalump> thought the imported modules do actually exist
15:25:33 <Olathe> That's what zygo- means.
15:25:39 <Heffalump> vixey: well, what use is it?
15:25:54 <vixey> Heffalump, ... when you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor
15:26:14 <pumpkin> mmm deep functor action
15:26:30 <Heffalump> vixey: sure...
15:26:42 <Heffalump> and what's "semi-mutual recursion", and what does "deeper into the functor" mean?
15:26:46 <oklopol> hmm. okay that's probably not the thing someone explained to me then :P
15:27:02 <oklopol> may have been one of the other xxxmorphisms
15:27:10 <pumpkin> hylomorphism?
15:27:26 <oklopol> hihi high-low morphism
15:27:30 <pumpkin> lol
15:27:34 <oklopol> ... sorry
15:27:39 <kublar> wood shaped
15:27:43 <Olathe> Superultrologomorphism
15:27:47 <kublar> wait
15:28:11 <pumpkin> teletryzomorphism
15:28:24 <Olathe> That's a morphism that transforms concepts into weird, superlong names.
15:28:48 <pumpkin> lol
15:29:17 <pumpkin> how bout an amorphism?
15:29:18 <Heffalump> or the troglomorphism
15:29:53 <Heffalump> that translates your code into C++ (as used by cave-dwellers)
15:30:06 <Olathe> Heheh
15:30:13 <Olathe> I want to make one of those.
15:30:45 <pumpkin> lol
15:30:50 <augustss> what about the reverse?
15:30:55 <Cale> How about translating concepts into awkward code which doesn't really fully implement them?
15:31:07 <pumpkin> what's Caleskell?
15:31:07 <vixey> lambda calculus in C++ templates with correctness proof
15:31:13 <vixey> @go lambda calculus in C++ templates with correctness proof
15:31:16 <lambdabot> http://www.cs.swan.ac.uk/~csetzer/articles/rosebergersetzerFunctionalConceptsCplusplus.ps
15:31:28 <Heffalump> augustss: unfortunately you just have to wait several thousand years
15:31:56 <Cale> pumpkin: That's what people call my couple of prelude modifications which used to be in lambdabot, but which are currently disabled because hint doesn't/didn't properly support qualified module importe
15:31:59 <Cale> imports*
15:32:07 <pumpkin> :o
15:32:20 <kublar> pumpkin: (.) = fmap, (++) = mappend, basically
15:32:22 <Cale> I replaced (.) with fmap, and (++) with mappend
15:32:28 <pumpkin> :o
15:32:33 <pumpkin> terrible!
15:32:37 <Cale> oh?
15:32:39 <kublar> AWESOME
15:32:40 <pumpkin> EVIL!
15:32:40 <vixey> hey
15:32:43 <pumpkin> :P
15:32:44 <vixey> why don't you add them back in?
15:32:49 <pumpkin> no, I kinda like it actually :P
15:33:09 <augustss> great idea if Haskell does it too.  Bad idea in a didactic lb
15:33:12 <Cale> vixey: Does hint support importing the Prelude and other modules qualified yet?
15:33:26 <vixey> idk
15:33:27 <vixey> ?hackage hint
15:33:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
15:33:56 <Cale> My opinion regarding learning/teaching is that there's already enough differences between lambdabot and what you get by loading GHC by default.
15:34:07 <Cale> (that a few more doesn't really hurt so much)
15:35:01 <luite_> how can I add some module to the lambdabot imports? I noticed that Control.Arrow is not imported in my own lambdabot
15:35:24 <vixey> looks like it Cale
15:35:25 <vixey>                                  H.typeChecks "g" @@? "g is hidden"
15:35:25 <vixey>     where mod_text = unlines ["module T(f) where", "f = g", "g = id"]
15:35:29 <vixey> is in one of the unit tests
15:35:52 <vixey>  H.setTopLevelModules ["T"] and stuff
15:35:57 <Cale> luite_: It's annoying. You have to add it to the list of imports in Pristine.hs/L.hs, as well as to a list of modules in mueval
15:36:05 <Cale> (you have to edit the mueval source as well)
15:36:11 <vixey> why don't you use H.setImports ["Prelude"]
15:36:42 <Cale> vixey: Er... what good will that do?
15:36:51 <vixey> well not with ["Prelude"]
15:36:56 <vixey> but with whatever it is you meant instead
15:36:58 <luite_> Cale: ah I think I got only the mueval one right, thanks
15:37:21 <Saizan> having to edit two places to change an import is just wrong
15:37:36 <Cale> vixey: The problem is that in order to redefine things from Prelude/Data.List, you need to import those modules qualified.
15:39:02 <vixey> Cale, but you put that in your normal haskell file
15:39:21 <vixey> and then just import that module
15:39:30 <vixey> (import it from hint)
15:39:39 <Cale> Saizan: Yeah, I know, but there doesn't seem to be an easy way to do what ghci does to put everything in a given module and what it imports in scope, without also implicitly importing absolutely everything qualified.
15:40:25 <Saizan> vixey: up to now setTopLevelModules wasn't working properly (i don't recall the details though), if it now is fine then it shouldn't be hard
15:40:49 <Saizan> Cale: ah, yeah, that was the problem
15:41:12 <vixey> setTopLevelModules is used in the example
15:41:38 <Saizan> yeah, but it didn't work without also allowing the user to refer to any module by its full qualified name
15:41:46 <Saizan> i think that's fixed in 6.10
15:42:03 <vixey> omg I hate cabal so much
15:42:10 <vixey> Configuring hint-0.2.4.1...
15:42:10 <vixey> Setup.lhs: At least the following dependencies are missing:
15:42:10 <vixey> ghc-paths -any, utf8-string -any
15:42:15 <vixey> % cabal install utf8-string
15:42:16 <vixey> Resolving dependencies...
15:42:16 <vixey> No packages to be installed. All the requested packages are already installed.
15:42:27 <vixey> cabal is the worst POS ever in haskell.......
15:42:31 <pumpkin> lol
15:43:11 <Saizan> are you sure the two invocations are seeing the same ghc? and same packagedb?
15:43:18 <vixey> I had to use cabal configure instead of runhaskell Setup.lhs
15:43:26 <Saizan> yeah
15:43:29 <vixey> I get further with that:
15:43:30 <vixey> src/Hint/Parsers.hs:7:21: Module `GHC' does not export `Session'
15:43:31 <vixey> .......
15:43:33 <Saizan> it's just that the default is different
15:43:44 <vixey> and peoplee actually use haskell for real stuff???? lol
15:43:53 <Saizan> vixey: the hint package on hackage doesn't build on 6.10+ :)
15:43:57 <Saizan> that's no news :)
15:43:58 <vixey> I bet half the crap on hackage doesn't even build
15:44:17 <vixey> (and this is the same half I happen to use)
15:45:54 <luite_> Cale: thanks, works now (it was the mueval one that still needed to be changed)
15:48:06 <augustss> I'm looking forward to the Haskell platform, so you can get a bunch of packages that actually build and work together
15:48:13 <hugo___> hello
15:48:26 <Cale> hi
15:48:28 <vixey> that would be great
15:48:29 <ddarius> augustss: They just won't be any of the packages vixey uses.
15:48:37 <vixey> I wish I understood how people got into such a mess
15:48:40 <filcab42> hi all
15:48:48 <Heffalump> backwards compatibility takes a lot of effort
15:48:49 <hugo___> hi filcab42
15:48:54 <Heffalump> it slows down development a lot
15:48:56 <augustss> ddarius: as long as it's the packages I use...
15:49:01 <vixey> back compatability is trivial
15:49:05 <vixey> instead of going from
15:49:20 <vixey> Control.Exception --> Control.Exception/Control.OldException
15:49:22 <vixey> you go
15:49:24 <vixey> Control.Exception --> Control.Exception/Control.NewException
15:49:34 <augustss> vixey: yes, I agree
15:49:37 <vixey> I wish GHC implementors could realize this
15:49:44 <Heffalump> in that case it would have been possible, yeah
15:49:49 <vixey> and I wish I could spell "implementers" :/
15:49:49 <Heffalump> but in general it's very painful
15:50:06 <idnar> vixey: "implementors" works better
15:50:11 <kublar> vixey: that sucks :-/
15:50:15 <vixey> I'm trying to think of one time when I download some haskell code and it works
15:50:40 <kublar> that way you end up with modules called NewFoo and NewNewFoo and they're all old and deprecated
15:50:56 <Heffalump> kublar: they'd have to have swapped the names at some point, but not immediately
15:51:08 <kublar> (cf. newgetopt.pl in perl)
15:51:17 <augustss> The exception mess is very annoying.  It broke every package using exceptions. :(
15:51:28 <vixey> augustss: It's astounding
15:51:30 <kublar> they didn't break enough
15:51:31 <idnar> yeah, that's seriously not cool
15:51:39 <idnar> and also not very conducive to actually getting anything done
15:51:43 <kublar> they should have made a new exception hierarchy
15:51:54 <vixey> kublar, which is exactly what I'm saying
15:51:55 <idnar> worse than python, even
15:52:01 <Heffalump> of course, people could have just used base 3
15:52:05 <vixey> kublar, NewException isn't literally, but this is idea
15:52:15 <Saizan> but there's base-3.0.3.0 ..
15:52:17 <augustss> Heffalump: yes, some of us do
15:52:17 <kublar> vixey: no, the module name is fine
15:52:28 <Saizan> and cabal even picks it for you
15:52:30 <kublar> vixey: I'm talking about extensible IOErrors and that kind of stuff
15:53:43 <vixey> how about making a _well typed_ build system
15:53:56 <Heffalump> like nix?
15:54:03 <vixey> I don't know nix
15:54:09 <Saizan> preflex: zdec Cabalzm1zi6zi0zi1_LanguageziHaskellziExtension_a315_closure
15:54:09 <preflex>  Cabal-1.6.0.1_Language.Haskell.Extension_a315_closure
15:54:50 <hugo___> is there any package for partial derivatives and integration in haskell ?
15:55:10 <saml> i bet there are
15:55:38 <ksf> hmmm. FTGL needs a proper version check for libftgl.
15:55:44 <sclv> hugo: see the linear map library
15:55:44 * vixey I wonder if anyone's going to write a haskell compiler that is written in haskell and readable/hackable
15:55:48 <saml> are they aboout calculus?
15:56:26 <saml> i think it's impossible to write readable/hackable program if the program is complicated.. like mozilla
15:56:27 <sclv> but that doesn
15:56:34 <sclv> erm, doesn't do integration as i recall.
15:56:43 <vixey> saml, I don't
15:56:50 <ddarius> vixey: I thought YHC wasn't too bad?
15:57:01 <hugo___> allright, thanks sclv
15:57:03 <vixey> ddarius, well I have not really looked into it
15:57:04 <ddarius> There's also Bernie Pope's Baskell
15:57:13 <vixey> yeah I didnt' like Baskell though
15:59:25 <ksf> conal, http://hpaste.org/13353
15:59:35 * conal looks
15:59:40 <ksf> admittedly, some more magic would be nice.
15:59:45 <dcoutts> Heffalump: the base3 -> 4 transition has actually been relatively painless I think
15:59:58 <pumpkin> is there a ttf/otf decoder lib in pure haskell?
16:00:16 <Heffalump> relative to the base2 -> 3 transition, yeah..
16:00:20 <conal> ksf: cool!  thanks.
16:00:22 <dcoutts> Heffalump: we've got almost all packages using base 3 and it's just devs switching them over when they choose to, rather than one mass breakage and forced migration
16:00:53 <dcoutts> Heffalump: we'll get hackage to require package authors to put an upper bound on the base version and it could be even smoother next time
16:01:08 <dcoutts> wrong! : build-depends: base >= 3
16:01:12 <Heffalump> yeah
16:01:26 <dcoutts> right! : build-depends: base == 3.*
16:01:31 <conal> ksf: might be nice to hook it up to lazy dynamic tessellation
16:05:11 <ksf> ftgl knows a lot of rendering modes, I'm going to figure out what to use when as I go along.
16:05:35 <ksf> like, you usually don't need full 3d geometry, bitmaps should be quite adequate.
16:06:45 <conal> ksf: i installed FTGL and ran that paste.  I get: Loading package FTGL-1.1 ... can't load .so/.DLL for: ftgl (libftgl.so: cannot open shared object file: No such file or directory)
16:07:11 <ksf> get it at http://ftgl.wiki.sourceforge.net/
16:08:02 <conal> ksf:  apt says i have libftgl2
16:08:36 <ksf> I needed to get 2.1.3_rc5, that is, a version that's masked in portage.
16:08:42 <trygvis> where should I go to find the source code of the base libraries?
16:08:51 <sclv> conal: I'm not sure I understand your withThread, and wonder if its the source of your error?
16:09:03 <conal> ksf: thx.  i'll give it a try.
16:09:04 <sclv>    withThread u v = bracket (forkIO u) killThread (const v)
16:09:16 <hugo___> is there any way to download the most important packages of hackage in a bundle ?
16:09:16 <conal> sclv: do you know about bracket?
16:09:18 <sclv> This should fork the action u, and immediately kill it and return v?
16:09:31 <sclv> I'm pretty sure that can't be what you want.
16:09:37 <conal> sclv: it sure isn't
16:09:54 <Heffalump> hugo___: that's what the Haskell Platform will do
16:09:56 <sclv> what are the semantics for withThread you want? I'll cook one up.
16:10:01 <conal> @type bracket
16:10:03 <lambdabot> Not in scope: `bracket'
16:10:07 <sclv> ?hoogle bracket
16:10:07 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
16:10:07 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
16:10:07 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
16:10:19 <sclv> It got rid of the parens :-(
16:10:26 <conal> oops
16:10:29 <sclv> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:10:41 <Heffalump> there's a bug in haddock
16:11:10 * conal double-checks the definition of bracket
16:11:11 <hugo___> hmm seems nice Heffalump
16:11:56 <Heffalump> dcoutts/dons: how's that going, btw?
16:11:56 <adekoba> anyone know why binary-strict has been marked deprecated? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-strict
16:13:27 <conal> sclv: i think that withThread def kills the thread after executing the action or when the action gets interrupted.
16:14:09 <sclv> the thread is launched in the initial argument, then immediately the middle clause is called, which is just a const...
16:14:29 <sclv> and as soon as the middle clause returns, which is immediately, then the final clause is called, which kills the thread.
16:16:28 <mm_freak_> is Data.BerkeleyDB faster than Data.Map with ByteStrings?
16:17:02 <sclv> Ah I see.. but the const is in fact an IO action
16:17:30 <sclv> gotcha. now it makes sense.
16:17:39 <conal> sclv: ok
16:17:54 <conal> the const is because the action doesn't depend on the thread id
16:18:05 <pumpkin> mm_freak_: I doubt it, unless you're using one of their in-memory ones
16:18:30 <pumpkin> mm_freak_: but it's definitely more persistent :P
16:18:31 <mm_freak_> pumpkin: Data.BerkeleyDB _is_ in-memory, as far as i've understood
16:19:02 <pumpkin> hmm, interesting
16:20:42 <pumpkin> looks like Lemmih made it
16:30:51 <mm_freak_> what is a good place to announce new tutorials and find some beta-readers?
16:31:20 <pumpkin> the haskell reddit?
16:31:32 <pumpkin> maybe the haskell wiki
16:32:02 <sjanssen> mm_freak_: haskell-cafe@haskell.org would also be okay
16:32:27 <mm_freak_> wouldn't it be a bit too sassy to add it to the haskell wiki?
16:32:46 <mm_freak_> sjanssen: where can i subscribe to that again?
16:33:40 <mm_freak_> found it, thanks
16:36:11 <hugo___> is anyone here planning to go to hacking at random in netherlands ?
16:36:21 <hugo___> https://har2009.org/index.php?p=68
16:37:05 <Heffalump> I'll go to the Haskell hackathon at Utrecht if possible.
16:37:17 <JohnnyL> hey guys, i'm halfway through a haskell book. so i grok a little of it. I want to develop indie games independently because I'm out of a job. I figure haskell is good for competition because it doesn't require as much code. should I go with what I know in c++ or should i continue learning haskell and write my games in it?
16:37:56 <pejo> Heffalump, vacation, or sponsored by employer?
16:38:09 <Heffalump> not sure :-)
16:38:19 <Heffalump> the last one was work time but my money
16:38:33 <hugo___> JohnnyL: you have loads of c++ opensource libs and game engines ...
16:38:44 <mm_freak_> JohnnyL: it takes a bit more time to become a haskell game programmer than it takes to become a C++ game programmer, but it certainly pays off
16:38:57 <pejo> I'm still amazed by how open minded the investment banks are, but it's all good.
16:39:05 <hugo___> in haskell be prepared to code them by yourself :P
16:39:31 <mm_freak_> hugo___: there is no quake engine in haskell, but it would be easy to write one ;)
16:40:01 <hugo___> i would not go to haskell if i wanted some quick money making games... or quick return on investment in games, but that is me...
16:40:24 <mm_freak_> hugo___: i would, because game development in haskell is more productive
16:40:56 <mm_freak_> for quick money making games you've got everything you need:  a game engine and FRP
16:41:08 <hugo___> there isn't even an image loading/writing library, neither a font loading/writing library... much less collada support, or whatever...
16:41:18 <hugo___> game engine ?
16:41:20 <hugo___> like what ?
16:41:43 <JohnnyL> mm_freak_ FRP?
16:41:53 <mm_freak_> hugo___: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Imlib
16:41:54 <hugo___> so... im just saying, in haskell it is going to be a long ride...
16:42:10 <mm_freak_> hugo___: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FTGL
16:42:21 <mm_freak_> hugo___: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FunGEn
16:42:28 <mm_freak_> there you go =)
16:42:51 <mm_freak_> JohnnyL: functional reactive programming for time-varying values (i.e. objects in your game)
16:43:17 <conal> ksf: i've built and installed ftgl-2.1.3-rc5, and i'm still getting: Loading package FTGL-1.1 ... can't load .so/.DLL for: ftgl (libftgl.so: cannot open shared object file: No such file or directory)
16:44:24 <conal> ksf: i do see /usr/local/lib/libftgl.so as a symlink to libftgl.so.2.1.3, which exists
16:45:04 <hugo___> mm_freak_: you are not serious, are you ? :P
16:45:07 <pejo> conal, is /usr/local/lib in your LD_LIBRARY_PATH?
16:45:12 <mm_freak_> hugo___: i am
16:45:17 <hugo___> hmm
16:45:26 <ksf> just wanted to ask that.
16:45:28 <conal> pejo: :) that was the problem.  thanks.
16:45:53 <hugo___> well, those are good efforts, but i wouldn't use them in production code... still a long way to go, and specially not on a "game engine"
16:45:58 <ksf> currently, I'm guesstimating that the haskell bindings heavily leak memory as I don't see anything resembling finalizers anywhere.
16:46:05 <hugo___> but that is me :P
16:46:11 <ksf> I've never done such ffi stuff, though.
16:46:18 <conal> ksf: eep.  sounds like a problem.
16:46:35 <mm_freak_> hugo___: as said, there is no quake engine yet, but i'd prefer to use the quake engine through FFI rather than using C++
16:46:47 <ksf> otoh, it's insane to load a ttf every frame, anyway.
16:47:21 <hugo___> mm_freak_: do you know how much effort would be to get the bindings for the quake engine ? have you looked at its source-code ?
16:47:27 <Axman6> mm_freak_: so, you're working on an FFI interface to the quake engine yes?
16:47:34 <pumpkin> hugo___: did you see the quake 3 lookalike in haskell?
16:47:36 <conal> ksf: sure is.  that Renderable interface is a placeholder.
16:47:50 <mm_freak_> hugo___: or writing an engine from scratch just like in 'frag' (would be faster probably) =)
16:47:56 <mm_freak_> Axman6: no =P
16:48:02 <Axman6> bah :P
16:48:25 <conal> ksf: the createPolygonFont call could be moved out and unsafePerformIO'd
16:48:28 <hugo___> i saw one project that loaded quake3 map files... and that was about it...
16:48:33 <pumpkin> I'd really like an OTF/TTF pure haskell lib though
16:48:37 <conal> ksf: so that it's done just once.
16:48:41 <mm_freak_> hugo___: that was frag
16:48:48 <ksf> ...or created by an gadt.
16:48:54 <bmh> hello
16:49:05 <Cale> bmh: hello
16:49:30 <bmh> does anyone have any insight into why Data.List has subsequences but not substrings?
16:49:36 <mm_freak_> hugo___: frag is a little game…  not very useful or thrilling, but it shows that it's well possible
16:49:45 <conal> ksf: and since the font is immutable.
16:49:52 <Cale> bmh: as in map inits . tails ?
16:49:54 <mm_freak_> and just look at the development time, considering that they wrote almost everything from scratch, including the FRP engine
16:50:20 <ksf> it doesn't seem to be, there's all those setFontXXX calls.
16:50:22 <hugo___> mm_freak_: i have even read the thesis associated with frag... it points out several performance problems in the rendering stage...
16:50:22 <ksf> IO ones.
16:50:27 <sjanssen> bmh: no reason, probably
16:50:43 <Cale> (or vice versa, depending on what order you want them in)
16:50:56 <mm_freak_> hugo___: i don't know, but it ran well for me
16:51:35 <hugo___> anyway, i'm totally in favor of a purely functional haskell rendering engine... but it would take lots of time :/
16:51:49 <ksf> I don't think so.
16:51:50 <hugo___> specially if one would want to get away from c/c++ libs
16:52:11 <ksf> there's much stuff in place you can build on, and much stuff that can be added as you go.
16:52:17 <Cale> I would think it's because substrings is a simple combination of the things already there, while subsequences is a little more tricky (though it is available using filterM cleverly from Control.Monad)
16:52:31 <mm_freak_> hugo___: the problem is that everybody thinks that C++ is more suitable…  as long as this attitude remains ubiquitous, there will be no useful haskell game engine
16:52:46 <Cale> permutations is really the tricky one to write by contrast
16:53:05 <ksf> mm_freak_, just send pizzas to conal.
16:53:11 <Cale> (as far as basic combinatorial things on lists)
16:53:28 <conal> :)
16:53:37 <bmh> Cale: understandable. I'm not too concerned with correctness -- I can get that right. I'm just interested in the 'correct' way to do things, performance wise
16:53:52 <hugo___> yeh, thats a problem :/ C++ isn't more suitable thats for sure... but it does have the advange of having lots of libs available
16:54:10 <Cale> bmh: I would say that either concatMap inits . tails or concatMap tails . inits would be just fine.
16:54:51 <mm_freak_> hugo___: however, pushing haskell forward in other places will certainly make people interested in haskell game development =)
16:55:31 <hugo___> yes
16:55:49 <Cale> Or perhaps concatMap (drop 1 . inits) . tails
16:56:34 <Cale> (to exclude all the empty cases)
16:56:59 <bmh> Cale: still seems like a lot of bother for "substrings" :)
16:57:15 <bmh> if we're going to have subsequences, we might as well have substrings
16:57:19 * bmh shakes his fist at the prelude
16:57:20 <pejo> mm-freak, there's at least some soft realtime stuff necessary for games, Haskell might be hard to predict.
16:57:21 <Cale> I suppose.
16:57:30 <hugo___> i think it would be great to have a project like pd or max/msp/jitter in haskell :)
16:57:30 <Cale> subsequences was *just* added
16:57:34 <hugo___> those things are really trendy
16:57:49 <Cale> > filterM (const [True,False]) "hello"
16:57:50 <lambdabot>   ["hello","hell","helo","hel","helo","hel","heo","he","hllo","hll","hlo","hl...
16:57:50 <hugo___> it would contribute a lot for the haskell popularity
16:58:06 <Cale> That's subsequences.
16:58:31 <hugo___> > filterM (const [True,False]) "hello"
16:58:32 <lambdabot>   ["hello","hell","helo","hel","helo","hel","heo","he","hllo","hll","hlo","hl...
16:58:33 <bmh> Cale: I don't quite understand what's going on there
16:58:37 <pumpkin> I want sublists :o
16:58:45 <Cale> bmh: For each element, either keep it, or don't.
16:59:11 <pumpkin> Cale: that's pretty elegant :P
16:59:13 <Cale> bmh: It's in the list monad, and the decision about whether to keep each element is made by selecting from the list [True,False]
16:59:37 <bmh> pumpkin: I'm with you on this one.
16:59:41 <Cale> (and this list is used regardless of the value of the element)
16:59:53 <Cale> (which is the explanation for the presence of const)
17:00:31 <pumpkin> bmh: I normally do filter (not . null) . concatMap tails . inits
17:00:37 <pumpkin> but it's not very pretty
17:00:48 <hugo___> time to go to bed, i will definetly dream with filterM (const [True,False]) "hello" :P
17:00:56 <Cale> > concatMap (drop 1 . inits) . tails $ "hello"
17:00:57 <lambdabot>   ["h","he","hel","hell","hello","e","el","ell","ello","l","ll","llo","l","lo...
17:01:13 <pumpkin> is that all of them?
17:01:20 <pumpkin> and does it work on infinite lists?
17:01:28 <bmh> > concatMap (drop 1 . inits) . tails $ [1..]
17:01:29 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
17:01:36 <bmh> sure ;-)
17:01:38 <pumpkin> lol
17:01:49 <Cale> On infinite lists, that ordering isn't so fair.
17:01:53 <pumpkin> yeah
17:02:00 <pumpkin> the one I did works more nicely on infinite lists
17:02:03 <Cale> But you could instead of concatMap, use map, and then some interleaving.
17:02:20 <Cale> (or just leave it nested)
17:02:23 <pumpkin> but I don't like the filter not null
17:02:24 <conal> linux newbie question: where can i put my LD_LIBRARY_PATH def so that it's picked up and passed into my emacs environment, which is started automatically at log in?  i've put export LD_LIBRARY_PATH="/usr/local/lib:$LD_LIBRARY_PATH" in my ~/.bashrc, which is sourced from .profile.  i pick it up when i start a shell, but it's not known in my emacs process.
17:02:38 <bmh> conal: in #linux
17:02:43 <pumpkin> lol
17:02:53 <conal> :)
17:02:54 <JohnnyL> thanks guys.
17:03:19 <Heffalump> how is emacs started automatically at login?
17:03:48 <Saizan> isn't it .bash_profile ?
17:03:57 <jeffz`> set it as your shell?
17:04:28 <conal> Heffalump: i don't know the underlying mechanics.  i use the "sessions preferences" applet in ubuntu to list start-up programs.
17:05:33 <mm_freak_> is there an NNTP interface to haskell-cafe?
17:06:14 <yav> conal: try putting it in the profile
17:06:33 <conal> yav: .bash_profile ?
17:06:58 <yav> i think just .profile (but there are so many of them :-)
17:07:09 <Axman6> conal: which OS?
17:07:13 <Cale> pumpkin: concatMap init . map tails . inits is perhaps ever so slightly better
17:07:17 <conal> Axman6: ubuntu 8.10
17:07:22 <Axman6> ah, ok
17:07:28 <pumpkin> :t init
17:07:29 <lambdabot> forall a. [a] -> [a]
17:07:36 <pumpkin> > init [1..4]
17:07:37 <lambdabot>   [1,2,3]
17:07:46 <pumpkin> ah, that's one I didn't know about
17:08:00 <bmh> > teachMeToLoveAgain
17:08:01 <lambdabot>   Not in scope: `teachMeToLoveAgain'
17:08:38 <bmh> I assume that lambda bot won't do things like open connections?
17:08:50 <Axman6> @let teachMeToLoveAgain = doc "I shall always love you!"
17:08:51 <lambdabot>  <local>:26:21: Not in scope: `doc'
17:08:54 <Axman6> bah
17:08:54 <Olathe> It shouldn't
17:09:12 <Olathe> @let teachMeToLoveAgain = fun "I shall always love you!" :: Expr
17:09:13 <lambdabot>  Defined.
17:09:17 <Olathe> > teachMeToLoveAgain
17:09:18 <lambdabot>   I shall always love you!
17:09:25 <kublar> > var "var"
17:09:26 <Cale> pumpkin: (that is, than using filter)
17:09:26 <lambdabot>       Ambiguous occurrence `var'
17:09:26 <lambdabot>      It could refer to either `Data.Number.S...
17:09:30 <pumpkin> Cale: yeah
17:11:04 <bmh> > System.Cmd.system "/usr/games/fortune"
17:11:05 <lambdabot>       No instance for (Typeable GHC.IOBase.ExitCode)
17:11:05 <lambdabot>        arising from a us...
17:11:10 <bmh> oh jesus.
17:11:18 <bmh> that's bad.
17:11:31 <Heffalump> > System.Cmd.system "/usr/games/fortune" >> return ()
17:11:32 <lambdabot>   /tmp/2309375962725253691:70:32: Not in scope: `System.Cmd.system'
17:11:46 * Heffalump looks confused. How did it know the type if it's not in scope?
17:11:54 <Heffalump> :t System.Cmd.system "/usr/games/fortune" >> return ()
17:11:56 <lambdabot> IO ()
17:12:03 <Heffalump> :t System.Cmd.system "/usr/games/fortune"
17:12:04 <lambdabot> IO GHC.IOBase.ExitCode
17:12:14 <Heffalump> I guess it might type-check in a different environment.
17:12:16 <Cale> bmh: It's not really.
17:12:26 <Cale> bmh: That's an IO action. Evaluating it does nothing.
17:12:39 <Heffalump> oh, duh
17:12:45 <Cale> (even if it were in scope)
17:12:57 <bmh> Cale: shucks, I was hoping to "System.Cmd.system "killall lambdabot""
17:13:01 <Cale> > readFile "/usr/games/fortune"
17:13:02 <lambdabot>   * Exception: "<IO [Char]>"
17:13:14 <Cale> I'm not sure why that's an exception.
17:13:29 <Cale> It used to just show as <IO [Char]>
17:14:55 <Saizan> Cale: remove the Show (IO a) instance from the show package :)
17:16:08 <Saizan> i couldn't convince gwern to do that, since he wanted mueval to exit with an non-zero code if IO is mentioned
17:18:14 <ksf> I'm about one hesitation away from just changing all of FTGL to use ForeignPtr's.
17:18:32 <Saizan> FTGL?
17:18:38 <mmorrow> what does it use now?
17:19:04 <ksf> even if you do imperative gl coding, manual memory management is an insult.
17:19:09 <ksf> plain ptr's.
17:19:15 <ksf> ...for malloced structures.
17:19:21 <bmh> manual memory management is daft...
17:20:23 <mmorrow> then again, you can control exactly when the mem is released (if that is important)..
17:20:33 <mmorrow> @src ForeignPtr
17:20:33 <lambdabot> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
17:20:37 <mmorrow> @src ForeignPtrContents
17:20:38 <lambdabot> data ForeignPtrContents = PlainForeignPtr !(IORef [IO ()])
17:20:38 <lambdabot>                         | MallocPtr (MutableByteArray# RealWorld) !(IORef [IO ()])
17:20:38 <lambdabot>                         | PlainPtr  (MutableByteArray# RealWorld)
17:21:50 <kohwj> cabal gives the strange error when trying to solve dependencies- "There is no available version of base that satisfies >=4". does anyone know what to do with it?
17:22:00 <mreh> hello all
17:22:19 <Axman6> kohwj: do you have ghc-6.10 installed?
17:22:29 <ksf> hmmmm....
17:22:33 <kohwj> Axman6: oh, no
17:22:42 <ksf> I bet those c++ bindings have a copy constructor, somewhere.
17:23:09 <mreh> has anyone here experimented with a sub-note-book?
17:23:17 <mreh> so they give you eyestrain?
17:23:41 <kublar> how is that a haskell qustion?
17:23:51 <mreh> :(
17:23:59 <bmh> kublar: does xmonad alleviate the eyestrain? ;)
17:24:03 <mreh> i want to get linux on a laptop, so i can write haskell
17:24:49 <mreh> manufacturers have started shipping subnotebooks with linux installed
17:24:57 <kohwj> Axman6: installing it now :)
17:25:30 <mreh> seems like a good idea, instead of ordering a laptop and turning it into an expensive paper weight / cheese board
17:26:21 <mreh> is there a fp chatroom?
17:26:31 <Axman6> mreh: i'd do it, but i have a macbook pro that does everything i need
17:26:47 <Axman6> and it's compact enough for me
17:26:50 <mreh> you have lots of money and you're also not afraid of looking like a sheep
17:27:18 <mreh> i have to be different im afraid
17:27:26 <Axman6> i'm not a sheep, i've been using macs since waybefore they were cool ;)
17:27:44 <Heffalump> that doesn't stop you looking like a sheep :-)
17:28:19 <mreh> and if you try and say that you'll just emit a loud bleating sound
17:28:28 <Axman6> meh, there's not many people with macbook pro's around, i feel safe in that regard. plus, i have a better and lighter laptop than any of my friends, so meh
17:28:48 * koeien has a Thinkpad T42 with debian
17:29:00 <Axman6> anyway, there's far more dells,a dn especially EeePC's out there these days
17:29:07 <Axman6> and * wow
17:29:08 * Heffalump has a Thinkpad T22 with debian
17:29:34 * luite_ has a Thinkpad T61p with ubuntu
17:29:50 <Axman6> thinkpads are the only PC laptops i've ever liked. they're sort of the other end of the laptop spectrum from macbooks and such, and i love they way they look
17:30:31 <Heffalump> they're also really solid, mine is over 7 years old and still going strong
17:30:42 <Heffalump> the Vaio I had before died after 2 or 3 years
17:30:52 <Axman6> i hear the lenovo ones aren't so well built though
17:30:58 <luite_> my T41p died because of the gpu overheating, after just over 3 years :(
17:31:05 <Heffalump> I'd heard the converse (that they are just as good)
17:31:13 <mreh> so should I buy a dell mini 12?
17:31:20 <koeien> they are quite solid. my university has a laptop program, i bought one via that program, so /me has 5 yrs warranty
17:31:22 <Heffalump> they were building them for years before they bought the actual branding
17:31:31 <koeien> yes, that's true
17:31:32 <Axman6> mreh: heh, and you're calling me a sheep :P
17:31:53 <pumpkin> lol
17:32:00 <sjanssen> mreh: my mom got a mini 9 for christmas, and it is pretty sweet
17:32:12 <pumpkin> it's getting to be more sheepish to call mac users sheep than the mac users are themselves
17:32:13 <sjanssen> as far as I could tell from an hour or so of playing with it
17:32:15 <mreh> i want to make an informed decision, not react to peer pressure
17:33:02 <Heffalump> I don't think mac users are sheep, but I think the ones that claim to be getting a nice UNIX environment are deluded, given the numerous compatibility problems it seems to have
17:33:20 <mreh> they bloody are
17:33:20 <pumpkin> Heffalump: it isn't too bad though, and ends up being a decent compromise
17:33:24 <Axman6> Heffalump: i think you're wrong, especially with 10.5
17:33:31 <pejo> Heffalump, compatibility problems?
17:33:36 <pumpkin> #oswars
17:33:49 <koeien> there are also "compatibility problems" between openbsd and gnu/linux
17:33:52 <Heffalump> just observation of all the discussion about making things work on it, e.g. GHC
17:34:13 <Heffalump> koeien: sure, but MacOS X seems to be an order of magnitude further away
17:34:23 <Axman6> Heffalump: yeah, well it's not linux. that doesn't make it incompatible, just different to linux.
17:34:35 <mreh> has anyone here done any distance learning?
17:34:43 <pumpkin> is that a learning algo?
17:34:50 <lucca> mreh: by the way, this is a haskell channel
17:34:53 <augustss> Heffalump: most well written Unix apps work fine on MacOS X.  But Linux people are often sloppy. :)
17:34:54 <Axman6> pumpkin: heh
17:35:03 <luite_> I hope the new 2.6.28 kernel and (hopefully) driver improvements will finally make linux desktop graphics acceleration as fast as the competitors from redmond and cupertino
17:35:04 <jeffz`> mreh, you might try #haskell-blah for non-haskell chat
17:35:05 <pejo> Heffalump, it's pretty much like Solaris in that respect -- not all computers in the world are linuxmachines, but the programmers haven't realized yet.
17:35:22 <mreh> this is a chat room for haskell programmers right?
17:35:29 <mreh> i want to talk to haskell programmers
17:35:33 <mreh> so i came here
17:35:36 <augustss> mreh: you are.
17:35:38 <jeffz`> mreh, it's a channel for discussing haskell
17:35:39 <Olathe> mreh: I'm a Haskell programmer !
17:35:40 <Heffalump> pejo: again, Solaris seems way closer than MacOS. Even simple things like filesystem layout are miles away.
17:35:48 <lucca> mreh: you have it backwards
17:35:53 <mreh> is that lennart?
17:35:55 <Axman6> Heffalump: how so?
17:35:59 <Heffalump> but I don't have any deep personal experience to back this up with, it's just a general feeling
17:36:06 <augustss> mreh: Well, I am, yes.
17:36:10 <pumpkin> lol
17:36:11 <mreh> a friend of mine was telling me about what your did at credit suisse
17:36:26 <Axman6> all the normal unix directories are there, used like all the rest
17:36:34 <augustss> mreh: hmmm, i hope it was good
17:36:36 <Heffalump> Axman6: doesn't a lot of stuff live outside them, though?
17:36:43 <Axman6> then they're the side the users see, which is very well organised
17:36:58 <sjanssen> Heffalump: essentially everything the user interacts with are outside the typical Unix stuff
17:37:06 <Heffalump> mreh: and then he abandoned it, leaving 8-tuples littered all over the place :-)
17:37:08 <mreh> yeah, he was giving me an example of professionals who have successfully used fp in a corporate env
17:37:12 <sjanssen> Unix interaction is constrained to a ghetto in OS X
17:37:24 <Axman6> Heffalump: yes, it's supposed to. .apps aren't usix apps, and you want to keep that away from the inportant stuff under the hood
17:37:28 <augustss> 8-tuples is not even close to the ghc limit!
17:37:35 * mmorrow belatedly notes that he has an X60 with fedora
17:37:49 <pejo> Heffalump, not that you're bitter in any way. :-)
17:37:50 <koeien> ah, X series :)
17:37:59 <Heffalump> they get painful when two people add an element at the same time and need to merge, though :-) (luckily we realised in time and made a record)
17:38:05 <bmh> augustss: When would you /want/ to use 8-tuples?
17:38:18 <Heffalump> usually, when you start with a 2 or 3 tuple and add things bit by bit
17:38:24 <augustss> bmh: when 7-tuples is just one elemt to small
17:38:27 <sjanssen> @remember augustss 8-tuples is not even close to the ghc limit!
17:38:28 <lambdabot> I will remember.
17:38:30 * bmh groans
17:38:37 <Olathe> 62 !
17:38:44 <mreh> augustss: do you reckon there are prospects for someone who can program in the functional style, albeit i dont have any professional experience
17:38:48 <mreh> where did you start?
17:38:54 <Heffalump> I can't really talk, I was responsible for turning a different 8 (ish) tuple he wrote into a 12 (ish) tuple
17:39:15 <mmorrow> , $(tupE (fmap lift [1..63::Int]))
17:39:18 <lunabot>  luna: A 63-tuple is too large for GHC
17:39:21 <Heffalump> our users have code with 50 or 60-tuples, for slightly convoluted reasons
17:39:31 <augustss> mreh: where did I start? well, I started a long time ago.  I wrote a Haskell compiler so I would be able to try out Haskell.
17:39:57 <yav> conal: it seems that .bash_profile works, if you are still having trouble with setting environmental variables
17:40:03 <mreh> undergraduates have it all on a plate these days it seems
17:40:17 <augustss> mreh: but to answer your question.  yes, I think there are prospects
17:40:22 <Heffalump> mreh: only if you're willing to use existing languages
17:40:43 <mreh> i cant find them
17:40:46 <pumpkin> mreh: back in my day, we had to trudge through the snow and cut the potatoes out of the frozen earth, with no shoes on, before going to our exams
17:40:49 <pumpkin> which we had every day
17:40:50 <weilawei> so... for those vim users out there, are there any plugins/scripts/colors/etc that you consider essential for working with haskell?
17:40:53 <Olathe> @src tupE
17:40:53 <lambdabot> Source not found. Where did you learn to type?
17:41:05 <kohwj> what does the "-ghcquickbuild" flag do (gentoo-haskell overlay), other than building ghc quickly?
17:41:16 <mmorrow> , [$ty| tupE |]
17:41:20 <mmorrow> , src 'tupE
17:41:25 <mmorrow> , src 'TupE
17:41:26 <lunabot>  ([] ExpQ) -> ExpQ
17:41:31 <lunabot>  tupE :: ([ExpQ]) -> ExpQ
17:41:34 <sjanssen> kohwj: you might get better help in #gentoo-haskell
17:41:34 <Olathe> , you're a weird bot, lunabot
17:41:36 <lunabot>  data Exp = ... | TupE ([Exp]) | ...
17:41:36 <lunabot>  infixl 9
17:41:38 <lunabot>  luna: Not in scope: `you're'
17:41:45 <kohwj> thanks sjanssen
17:41:52 <mreh> to cut a long story short, im looking for work using fp
17:42:09 <bmh> mreh: I hear ITA uses lisp
17:42:13 <koeien> weilawei: i use plain vim
17:42:21 <mreh> where i am right now use alot of java frameworks, apart from one technology, xslt, which caught my eye
17:42:25 <augustss> mreh: It's too bad it's a recession.  Few are hiring right now.
17:42:40 <Heffalump> Barcap are
17:42:50 <augustss> oh really?
17:42:51 <mmorrow> Olathe: she is lunar after all
17:42:52 <bmh> let's hope I can get into a nice ol' PhD program.
17:43:03 <Heffalump> well, a recruiter called me about them a couple of weeks ago
17:43:04 <weilawei> bmh: piled higher and deeper :)
17:43:36 <bmh> weilawei: maybe in comparative bovine fecology, but not in computational biology
17:43:53 <weilawei> haha @ bmh
17:43:54 * mmorrow can't help but think of most bots as she with that picture of lambdabot drooling with a headset on his stuck in his head forever
17:44:16 <weilawei> mmorrow:  @_o link?
17:44:16 <pumpkin> lambdabot has a picture?
17:44:21 <mmorrow> heh
17:44:39 <mmorrow> http://haskell.org/haskellwiki/Lambdabot
17:44:50 <mmorrow> http://haskell.org/sitewiki/images/1/13/Lambdabot.png
17:44:50 <weilawei> excellllllent
17:45:20 <mreh> are barcap looking for fp devs?
17:45:22 <mmorrow> the pigtail wings are a nice touch
17:45:30 <mreh> got a link or some info?
17:45:31 <andyjgill> member:bmh: where are you thinking of doing a PhD?
17:46:38 <bmh> andyjgill: basically every solid CS/comp bio program in a livable location -- sorry CMU
17:46:46 <pumpkin> lol
17:47:09 <mreh> do it online
17:47:32 <andyjgill> And what is the Haskell connection?
17:48:02 <sclv> ?seen conal
17:48:02 <lambdabot> I saw conal leaving #haskell and #ghc 12m 12s ago, and .
17:48:23 <bmh> andyjgill: There isn't one. I'm just a FP'nerd
17:48:27 <drbean> @haskell Bool -> Bool
17:48:27 <lambdabot> Unknown command, try @list
17:48:38 <pumpkin> @hoogle Bool -> Bool
17:48:38 <lambdabot> Prelude not :: Bool -> Bool
17:48:38 <lambdabot> Data.Bool not :: Bool -> Bool
17:48:38 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
17:48:40 <mreh> they're right about haskell programmers, you must not make side effects or you vill be shot
17:48:44 <andyjgill> Have you considered Kansas?
17:49:31 <bmh> andyjgill: rockclimbing.com lists zero routes in Kansas. I don't think I could live there :)
17:50:03 <andyjgill> I'm teaching a graduate level Haskell class next semester with 28 students signed up so far.
17:50:39 <andyjgill> There is nothing rock climbing-ish here, though, unless you travel to Colorado.
17:51:31 <Axman6> bmh: sounds like you'd live australia
17:52:29 <bmh> Axman6: the only place outside of the US I'm looking at is EPFL
17:52:33 <Axman6> either ANU where i'm at, or UNSW where a crapload of haskell research is going on (dons uses to be there, and there's lore more). plus the blue mountains has some of the best rock climbing in the world
17:52:39 <andyjgill> UNSW has a great Haskell program.
17:52:49 <Axman6> andyjgill: yeah, i
17:52:54 <bmh> you guys are zealots ;)
17:52:58 <Axman6> i'd kinda like to go there sometime
17:53:48 <weilawei> bmh: mind if I PM you? interested in rock climbing, but rather not do this in an FP chan
17:54:13 <Axman6> dying has side effects!
17:54:21 <bmh> like decay?
17:54:30 <mmorrow> for one
17:54:39 <Axman6> funerals etc
17:54:40 <yav> Axman6: but what's its value?
17:54:54 <Axman6> yav: IO ()
17:55:06 <Axman6> or IO Autopsy
17:55:16 <Axman6> if you need information back
17:55:41 <luite_> so does anyone know a good place for a cs/fp phd in europe, at a location good for mountain biking and skiing? ;)
17:56:18 <yav> oh my, the requirements are accumulating :) EPFL probably mathces these though.
17:56:59 <bmh> uh-oh! competition is a-brewing!
17:57:22 <yav> i'd consider doing another phd at a place with skiing, biking, and a beach... any ideas?
17:57:32 <bmh> (EPFL's early application deadline is Jan 15)
17:57:41 <bmh> yav: EPFL is right on Lake Geneva...
17:57:58 <yav> bmh: i know, my sister actually is just finishing a masters there
17:57:58 <augustss> yav: sounds like you need to be in CA
17:58:34 <yav> augustss: i wonder how many requirements do i need to add before no can come up with a suggestion :)
17:58:37 <Axman6> yav: you could do most of those at UNSW probably. though Australia's skiing isn't that great
17:58:54 <yav> they do have awesome beaches though...
17:58:55 <xEpicFailGuyx> I'm going to the University of Buffalo next semester myself
17:58:57 <augustss> yav, just add Haskell :)
17:59:02 <xEpicFailGuyx> Finally done with comm. college hell
18:00:56 <bmh> xEpicFailGuyx: EpicPassGuy?
18:01:15 <xEpicFailGuyx> Yes
18:01:35 <xEpicFailGuyx> You know I almost got a poor grade in my one computer science class
18:02:15 <Axman6> i got poor grades in out comp course. dominated CCNA though. the difference was, comp was painfully easy and boring, and CCNA was chalenging
18:02:24 <Axman6> our*
18:02:25 <pumpkin> CCNA?
18:02:28 <xEpicFailGuyx> Axman6: Bingo
18:02:38 <xEpicFailGuyx> That's why I almost sucked at 'Comp Sci II'
18:02:43 <pumpkin> why is there so much haskell-fu down under anyway?
18:02:46 <bmh> what pumpkin said: CCNA?
18:02:51 <Axman6> pumpkin: Cisco Certified Networking Associate 9i think)
18:02:53 <pumpkin> :o
18:03:07 <xEpicFailGuyx> The hardest thing we did in that class was quicksort
18:03:09 <Axman6> pumpkin: because dons came from down under :P
18:03:22 <Axman6> the hardest thing we did was Access -_-
18:03:26 <pumpkin> really?
18:03:29 <augustss> Axman6: I think you have cause and effect confused
18:03:30 <pumpkin> real CS is hard
18:03:32 <bmh> the hardest thing we did was implement Prolog
18:03:39 <Axman6> augustss: bah!
18:03:53 <xEpicFailGuyx> pumpkin: Yeah hopefully further classes will get less boring
18:04:09 <Axman6> this was in college (years 11 and 12 here)
18:04:22 <pumpkin> ah, your definition of college is different from mine
18:04:44 <xEpicFailGuyx> You implemented Prolog as a lower undergraduate?
18:04:47 <mreh> I wrote a prolog parser in Java
18:04:48 <xEpicFailGuyx> That's good man!
18:05:17 <Axman6> mreh: sounds like a step backwards
18:05:24 <mgsloan> http://haskell.pastebin.com/m676f75ee
18:05:27 <mreh> i called it slolog
18:05:30 <bmh> xEpicFailGuyx: well, my implementation had a horrible, horrible bug... but mostly.
18:05:58 <mgsloan> here's a fun little program that takes some text, and writes a rendering of it to a bitmap, using a very tiny, 3x5 pixel font
18:06:22 <xEpicFailGuyx> Ok, since I'm a Haskell newb I have a little question ... why can't I apply two Integer arguments to (product . enumFromTo) ?
18:06:31 <Axman6> mreh: o.O
18:06:39 <xEpicFailGuyx> It seems I have to partially apply enumFromTo ...
18:06:49 <Axman6> :t (product . enumFromTo)
18:06:50 <lambdabot>     Couldn't match expected type `[a]'
18:06:50 <lambdabot>            against inferred type `a1 -> [a1]'
18:06:50 <lambdabot>     Probable cause: `enumFromTo' is applied to too few arguments
18:06:55 <Axman6> that's why
18:06:58 <xEpicFailGuyx> cool
18:07:18 <xEpicFailGuyx> So I know now I have to partially apply enumFromTo ... but why?
18:07:19 <augustss> @pl \ x y -> product (enumFromTo x y)
18:07:19 <lambdabot> (product .) . enumFromTo
18:07:24 <Axman6> you need something like ((product .) . eumFromTo) but that's ugly, don't use pointfree for that
18:07:31 <xEpicFailGuyx> hhaha
18:07:49 <bmh> consecutive '.'s are bad mojo
18:07:51 <Axman6> \ x y -> product (enumFromTo x y) is far clearer
18:07:57 <xEpicFailGuyx> that is exceedingly ugly
18:08:03 <pumpkin> bmh: why?
18:08:11 <bmh> pumpkin: just look at 'em!
18:08:25 <Axman6> xEpicFailGuyx: i far prefer readability
18:08:26 <pumpkin> @unpl (x .) . (. y)
18:08:26 <lambdabot> (\ e h -> x (e (y h)))
18:08:30 <xEpicFailGuyx> Axman6: Me too
18:09:07 <xEpicFailGuyx> > (product . enumFromTo 1) 6
18:09:10 <lambdabot>   720
18:09:12 <xEpicFailGuyx> cool
18:09:15 <bmh> speaking of down under: what's up with Australia? http://maps.google.com/?ie=UTF8&ll=-34.255514,117.766571&spn=0.392169,0.479279&t=h&z=11
18:09:28 <adekoba> anyone know why binary-strict has been marked deprecated? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-strict
18:09:56 <Axman6> bmh: what about it?
18:10:12 <bmh> Axman6: it looks surreal.
18:10:27 <pumpkin> it's false color
18:10:33 <pumpkin> zoom in more and you'll see the real thing
18:10:46 <bmh> pumpkin: I meant the shape and distribution of lakes, rather than the color
18:11:20 <sclv> \x y -> product [x..y] -- clearest!
18:11:49 <pardus> @pl \x y -> product [x..y]
18:11:49 <lambdabot> (product .) . enumFromTo
18:11:50 <Axman6> pumpkin: i think the zoomed in pic is when they've dried up
18:12:06 <pumpkin> it looks false color anyway, zoomed out
18:12:32 <xEpicFailGuyx> I mean generally speaking, when I do something like (f . g), g can only be a unary function?
18:12:50 <stu8ball> Looks like that acid trip out of 2001.
18:12:50 <Axman6> yes
18:12:53 <lucca> what's the right way to turn something like [Just 0, Just 1, Just 2] into Just [0, 1, 2], and to take lists with any Nothing into Nothing?
18:13:06 <Axman6> but you can do things like f . g x .h y $ z
18:13:14 <sclv> ?ty (.)
18:13:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:13:18 <sclv> ?src (.)
18:13:18 <lambdabot> (f . g) x = f (g x)
18:13:24 <Axman6> lambdabot: catMaybes
18:13:27 <Axman6> uh, lucca *
18:13:30 <sclv> those two should explain why
18:13:37 <sclv> that's not catmaybes
18:13:37 <lucca> aha
18:13:46 <Axman6> >t catMaybes
18:13:47 <sclv> > catMaybes [Just 1, Nothing, Just 2]
18:13:48 <lambdabot>   [1,2]
18:13:52 <Axman6> :t catMaybes
18:13:53 <lambdabot> forall a. [Maybe a] -> [a]
18:14:08 <lucca> yeah, not quite
18:14:09 <bmh> sounds like lift to me.
18:14:22 <Axman6> lucca: oh, sorry, that's sequence
18:14:28 <sclv> > sequence [Just 1, Nothing, Just 2]
18:14:29 <lambdabot>   Nothing
18:14:32 <sclv> bingo!
18:14:35 <Axman6> > sequence [Just 4, Just 5]
18:14:36 <lambdabot>   Just [4,5]
18:14:38 <Axman6> > sequence [Just 4, Just 5, Nothing]
18:14:40 <lambdabot>   Nothing
18:14:43 <lucca> ahhh, perfect
18:14:59 <Axman6> missed the Just [...]
18:14:59 <sclv> ?src sequence
18:14:59 <lambdabot> sequence []     = return []
18:14:59 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:14:59 <lambdabot> --OR
18:14:59 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:15:02 <pumpkin> :t sequence
18:15:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:15:05 <augustss> sequence strikes again!
18:15:17 <sclv> sequence is freaking awesome.
18:15:29 <xEpicFailGuyx> fold takes some work getting used to
18:15:48 <lucca> yeah, I was expecting a fold/lift thing...
18:15:53 <sclv> ?ty \f z -> foldr (liftA2 f) (pure z)
18:15:54 <lambdabot> forall a c (f :: * -> *). (Applicative f) => (a -> c -> c) -> c -> [f a] -> f c
18:16:00 <lucca> but couldn't quite get the typing right
18:16:03 <bmh> xEpicFailGuyx: I dream in folds. One day I'll dream in monads.
18:16:14 <sclv> dreaming is a monad.
18:16:24 <bmh> can someone make lambdabot remember that?
18:16:29 <xEpicFailGuyx> I believe in the Monad
18:16:34 <xEpicFailGuyx> I'm a Neoplatonist
18:16:53 <Axman6> @remember bmh I dream in folds. One day I'll dream in monads.
18:16:54 <lambdabot> Done.
18:17:11 <bmh> @remember sclv dreaming is a monad.
18:17:11 <lambdabot> Done.
18:17:12 <Axman6> @remember sclv dreaming is a monad.
18:17:12 <lambdabot> Done.
18:17:16 <Axman6> oh noes!
18:17:19 <bmh> uh oh
18:17:21 <Axman6> @quote sclv
18:17:22 <lambdabot> sclv says: dreaming is a monad.
18:17:24 <Axman6> @quote sclv
18:17:24 <lambdabot> sclv says: dreaming is a monad.
18:17:25 <Axman6> @quote sclv
18:17:26 <lambdabot> sclv says: dreaming is a monad.
18:17:29 <Axman6> oh god!
18:17:36 <mmorrow> nightmare!
18:17:37 <bmh> > explode
18:17:37 <lambdabot>   Not in scope: `explode'
18:17:57 <mmorrow> @define explode = fix error
18:17:58 <augustss> where's the xkcd strip that shows dreaming is a monad?
18:18:06 <mmorrow> @let explode = fix error
18:18:07 <lambdabot>  Defined.
18:18:21 <sclv> if you fix the error, then you don't explode!
18:18:26 <Axman6> > explode
18:18:27 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:18:35 <bmh> that's going in my .plan along with "Why do you base case when you die?"
18:18:41 <mmorrow> @go xkcd monad dream
18:18:42 <lambdabot> No Result Found.
18:18:50 <mmorrow> @help go
18:18:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:19:01 <mmorrow> @help google
18:19:02 <lambdabot> google <expr>. Search google and show url of first hit
18:19:21 <mmorrow> @go fix error
18:19:23 <lambdabot> No Result Found.
18:19:41 <Axman6> @google fix error
18:19:43 <lambdabot> No Result Found.
18:19:47 <Axman6> strange
18:19:48 <xEpicFailGuyx> @google monad
18:19:51 <lambdabot> http://en.wikipedia.org/wiki/Monad
18:19:51 <lambdabot> Title: Monad - Wikipedia, the free encyclopedia
18:19:54 <xEpicFailGuyx> ah
18:19:58 <mmorrow> @google cyclops
18:19:59 <xEpicFailGuyx> @google xkcd monad
18:20:00 <lambdabot> http://en.wikipedia.org/wiki/Cyclops
18:20:00 <lambdabot> Title: Cyclops - Wikipedia, the free encyclopedia
18:20:02 <lambdabot> No Result Found.
18:21:05 <ksf>     Illegal foreign declaration: requires via-C or native code generation (-fvia-C)
18:21:07 <xEpicFailGuyx> This channel is really nice
18:21:07 <ksf> _or_?
18:21:14 <ksf> what else is ghc doing?
18:21:58 <xEpicFailGuyx> ksf: Maybe GHC renders machine code directly?? :O
18:22:00 <pumpkin> xEpicFailGuyx: yup
18:22:16 <xEpicFailGuyx> pumpkin: It's a *lot* better than #lisp
18:22:38 <augustss> ksf: are you trying to load a file in ghci?
18:22:44 <pumpkin> most channels are full of grumpy ***holes who love to abuse newcomers :)
18:22:46 <ksf> erm... yes.
18:22:59 <xEpicFailGuyx> pumpkin: #vectorlinux is cool
18:23:03 <ksf> dammit.
18:23:04 <augustss> ksf: if it's not been compiled then ghci will interpret it
18:23:12 <ksf> just wanted to check a type.
18:23:25 <ksf> how do I tell it to compile it?
18:23:42 <CakeProphet> > die
18:23:43 <lambdabot>   Not in scope: `die'
18:23:44 <augustss> ksf: just use ghc -c --make File.hs
18:23:52 <drbean> @let merge x:xs y:ys | x < y = x :merge xs y:ys
18:23:52 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsIdent "merge"))
18:24:37 <CakeProphet> @let die = (repeat "*flop*")
18:24:37 <lambdabot>  Defined.
18:24:45 <ksf> thx, works.
18:26:13 <Axman6> > merge [2..10] [1..10]
18:26:14 <lambdabot>   Not in scope: `merge'
18:26:28 <xEpicFailGuyx> What like mergesort
18:26:39 <pumpkin> that merge function is extremely handy
18:26:58 <xEpicFailGuyx> Is it defined in the prelude?
18:27:20 <Axman6> @let merge xss@(x:xs) yss@(y:ys) | x < y = x : merge xs yss | otherwise = y : merge xss ys
18:27:20 <lambdabot>  Defined.
18:27:21 <pumpkin> nope
18:27:24 <Axman6> > merge [2..10] [1..10]
18:27:25 <lambdabot>   [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10* Exception: <local>:3:0-84: Non-exhau...
18:27:31 <pumpkin> Axman6: fail
18:27:58 <sclv> it works fine on infinite streams...
18:28:07 <Axman6> @let merge2 xss@(x:xs) yss@(y:ys) | x < y = x : merge2 xs yss | otherwise = y : merge2 xss ys; merge2 [] ys = ys; merge2 xs [] = xs
18:28:08 <lambdabot>  Defined.
18:28:12 <Axman6> > merge2 [2..10] [1..10]
18:28:13 <lambdabot>   [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
18:28:38 <drbean> OK
18:29:06 <mreh> is that @ a binding?
18:29:17 <mreh> i.e. xss@(x:xs)
18:29:21 <Axman6> yes
18:29:49 <Axman6> so xss gets bound to (x:xs)
18:30:01 <Axman6> saves some typing
18:30:04 <mreh> miranda doesnt have that
18:30:06 <luite_> is there a function to convert an Integer to a list of bits?
18:30:17 <JoshTriplett> How can I build a package with multiple executables using Cabal, such that the executables use different packages and don't get linked to the packages they don't need?
18:30:18 <Olathe> > foldb merge2 [] $ map (\x -> [x]) [1, 5, 2, 3, 7]
18:30:20 <lambdabot>   [1,2,3,5,7]
18:30:20 <Axman6> Data.Bits might have something
18:30:57 <JoshTriplett> I specified the build-depends in the executable sections of the cabal file, but cabal seems to build each executable with all the build-depends.
18:31:09 <luite_> Axman6: can't find one in Data.Bits. guess I'll just roll my own then
18:31:17 <Axman6> yeah :\
18:31:44 <ksf> what's that program called to visualize heap profiles?
18:31:52 <Olathe> @pl \xs -> foldb merge2 [] $ map (\x -> [x]) xs
18:31:52 <lambdabot> foldb merge2 [] . map return
18:31:58 <JoshTriplett> ksf: hp2ps
18:32:29 <mreh> is there a nice way to write a single guard statement for every pattern?
18:32:37 <xEpicFailGuyx> _ ?
18:33:01 <Axman6> mreh: what do you mean?
18:33:04 <JoshTriplett> mreh: Can you give an example with the duplication you'd like to eliminate?
18:33:10 <mreh> im trying to think of an example
18:33:13 <Olathe> @let mergeSort = foldb merge2 [].map (:[])
18:33:15 <lambdabot>  Defined.
18:34:07 <CakeProphet> :t return
18:34:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:34:09 <JoshTriplett> luite_: I know I've seen a function like that.  Checking.
18:34:15 <Olathe> @type mergeSort
18:34:16 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:34:22 <CakeProphet> :t return :: [a]
18:34:23 <lambdabot>     Couldn't match expected type `[a]'
18:34:23 <lambdabot>            against inferred type `a1 -> m a1'
18:34:29 <mreh> like this:
18:34:43 <JoshTriplett> :t return 1 :: List Integer
18:34:45 <lambdabot> Not in scope: type constructor or class `List'
18:34:51 <JoshTriplett> :t return 1 :: [Integer]
18:34:53 <lambdabot> [Integer]
18:34:57 <Olathe> @t return a :: [Expr]
18:34:58 <mreh> fac x = 1, if x<=0
18:34:58 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:35:00 <JoshTriplett> (OK, that didn't prove much.)
18:35:01 <CakeProphet> > return 1 :: [Int]
18:35:02 <lambdabot>   [1]
18:35:03 <Olathe> @type return a :: [Expr]
18:35:05 <lambdabot> [Expr]
18:35:40 <JoshTriplett> return in the list monad means \x->[x] .
18:36:11 <CakeProphet> > ([1] >>= \x -> x) 3
18:36:12 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[b]'
18:36:29 <CakeProphet> > ([1] >>= \x -> x) [3]
18:36:30 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[b]'
18:36:45 <pumpkin> > ([1] >>= \x -> x)
18:36:46 <lambdabot>       No instance for (Num [b])
18:36:46 <lambdabot>        arising from the literal `1' at <inter...
18:36:52 <Olathe> @type ([1] >>= \x -> x)
18:36:54 <lambdabot> forall b. (Num [b]) => [b]
18:37:06 <Olathe> > [1] [3]
18:37:07 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
18:37:23 <CakeProphet> How does Haskell know that it has to be a Num?
18:37:28 <pumpkin> :t 1
18:37:29 <lambdabot> forall t. (Num t) => t
18:37:40 <BMeph> CakeProphet: your (\x -> x) isn't of the type (a -> m b). :)
18:37:43 <Axman6> CakeProphet: types have a Num instance defined for them
18:37:57 <pumpkin> > ([1] >>= \x -> return x)
18:37:58 <lambdabot>   [1]
18:38:01 <ksf> hmmm.I guess libftgl is too smart to leak memory in my simple example of repeatedly creating the same font.
18:38:01 <pumpkin> whee
18:38:12 <CakeProphet> so does x = 1?
18:38:22 <Olathe> Yes.
18:38:27 <pumpkin> > ([1,2] >>= \x -> return x)
18:38:28 <lambdabot>   [1,2]
18:38:34 <CakeProphet> ....what is x there?
18:38:46 <Olathe> ([1,2] >>= \x -> [x + 1, x^500])
18:38:47 <JoshTriplett> CakeProphet: One element.
18:38:47 <pumpkin> > ([1,2] >>= return) :: Maybe Int
18:38:49 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `[a1]'
18:38:54 <CakeProphet> ah okay... like map.
18:38:55 <Axman6> CakeProphet: do you underastand that \x ->  return x is  function?
18:38:59 <Axman6> a*
18:39:01 <CakeProphet> Axman6:  ...yes.
18:39:02 <JoshTriplett> CakeProphet: No, like list comprehension.
18:39:14 <Olathe> ([1,2] >>= \x -> [x + 1, x^500])
18:39:16 <Olathe> > ([1,2] >>= \x -> [x + 1, x^500])
18:39:18 <lambdabot>   [2,1,3,32733906078961418700131896968275991522166420460430647894832913680961...
18:39:25 <CakeProphet> JoshTriplett:  is that not equivalent?
18:39:42 <JoshTriplett> CakeProphet: More general.  You can do more with a list comprehension than you can with a map.
18:39:46 <pumpkin> Olathe: that's extreme!
18:39:53 <Olathe> Extreme exampling !
18:39:54 <CakeProphet> JoshTriplett:  Ah right. like filter.
18:39:56 <CakeProphet> map and filter.
18:40:05 <JoshTriplett> CakeProphet: Like every list function you can think of. :)
18:40:07 <pumpkin> conatMap too
18:40:08 <JoshTriplett> CakeProphet: Combined.
18:40:10 <pumpkin> concat
18:40:13 <pumpkin> there's lots of them :P
18:40:15 <JoshTriplett> CakeProphet: For instance, you can't use map to generate 5 elements for every 1.
18:40:21 <CakeProphet> how?
18:40:24 <Olathe> > concatMap (\x -> [x + 1, x^500]) [1..3]
18:40:26 <lambdabot>   [2,1,3,32733906078961418700131896968275991522166420460430647894832913680961...
18:40:28 <pumpkin> CakeProphet: look at olathe's example
18:40:30 <Olathe> zomg !
18:40:49 <pumpkin> > ([1,2] >>= \x -> [x + 1, x^500]) -- [Olathe 2008]
18:40:51 <JoshTriplett> > [10, 20, 30] >>= (\x -> [x, x+1, x+2, x+3, x+4])
18:40:51 <lambdabot>   [2,1,3,32733906078961418700131896968275991522166420460430647894832913680961...
18:40:52 <lambdabot>   [10,11,12,13,14,20,21,22,23,24,30,31,32,33,34]
18:41:05 <Olathe> Ooh ! I'm being referenced !
18:41:05 <CakeProphet> ah okay
18:41:13 <JoshTriplett> Or, better yet...
18:41:18 <pumpkin> Olathe: yup!
18:41:31 <CakeProphet> the function has to return a list monad, and it concats the result to the rest of it.
18:41:49 <pumpkin> @src [] >>=
18:41:49 <lambdabot> Source not found. Where did you learn to type?
18:41:51 <JoshTriplett> > let f x = [10*x, 10*x+1] in [0, 1] >>= f
18:41:52 <lambdabot>   [0,1,10,11]
18:41:54 <BMeph> CakeProphet: Almost right! :)
18:41:56 <JoshTriplett> > let f x = [10*x, 10*x+1] in [0, 1] >>= f >>= f
18:41:58 <lambdabot>   [0,1,10,11,100,101,110,111]
18:42:01 * ksf shivers when hearing "returns a monad"
18:42:01 <pumpkin> @src ([]) >>=
18:42:01 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:42:02 <JoshTriplett> > let f x = [10*x, 10*x+1] in [0, 1] >>= f >>= f >>= f
18:42:03 <CakeProphet> BMeph:  explain.
18:42:03 <lambdabot>   [0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111]
18:42:06 <Axman6> @src [] (>>=)
18:42:06 <lambdabot> xs >>= f     = concatMap f xs
18:42:08 <JoshTriplett> CakeProphet: ^
18:42:14 <Axman6> pumpkin: phail
18:42:16 <Axman6> :P
18:42:17 <pumpkin> :(
18:42:18 <JoshTriplett> CakeProphet: Look at the examples I just typed.  That should make it clearer.
18:42:49 <BMeph> @src (State s) (>>=)
18:42:49 <lambdabot> Source not found. stty: unknown mode: doofus
18:42:52 <CakeProphet> JoshTriplett:  it wouldn't have been clear at all had I not already understood. ;)
18:42:58 <CakeProphet> too much clutter.
18:42:59 <ksf> like, "returns an inheritance". "returns a design pattern"
18:43:09 <pumpkin> lol
18:43:11 <JoshTriplett> ksf: Heh.
18:43:28 <bmh> %s/design\ pattern/buzz\ word/g
18:43:43 <pumpkin> what syntax is that?
18:43:44 <Axman6> JoshTriplett: that's... awesome. well done :)
18:43:50 <bmh> vim regexp
18:43:59 <JoshTriplett> Axman6: Thanks. :)
18:44:27 <ksf> mine usually have the form :1,$s/foo/bar/g
18:44:32 <CakeProphet> JoshTriplett:  now how do you make it repeat forever?
18:44:35 <augustss> pumpkin: Or ex, to give more history.
18:44:54 <augustss> ksf: you're an ed man!
18:45:47 <CakeProphet> ?src foldl
18:45:47 <lambdabot> foldl f z []     = z
18:45:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:46:11 <ksf> I could feel like plugging up and logging into my headless ultrasparc any moment. gotta be prepared in case my $TERM should be "linux".
18:46:28 <CakeProphet> > let f x = [10*x, 10*x+1] in foldl (>>=)  [0, 1] (repeat f)
18:46:30 <saml> hey give me a one liner that generates all ip addresss
18:46:38 <JoshTriplett> CakeProphet: Well, the example I gave won't really work forever.  If you nest f three levels deep, the first element returned by the whole monadic construct represents 10*10*10*0 .
18:46:39 <lambdabot>   mueval: Prelude.read: no parse
18:46:45 <saml> > [x | x <- [0..255]]
18:46:50 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:47:19 <ddarius> let x = [0..255] in liftM4 (,,,) x x x x
18:47:34 <augustss> > sequence $ replicate 4 [0..255]
18:47:35 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,0,0,3],[0,0,0,4],[0,0,0,5],[0,0,0,6],[0,0...
18:48:00 <BMeph> @ty mfix
18:48:03 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:48:04 <CakeProphet> > let f x = [10*x, 10*x+1] in (take 10 (foldl (>>=)  [0, 1] (repeat f))
18:48:05 <lambdabot>   <no location info>: parse error on input `;'
18:48:14 <saml> awesome!!!
18:48:22 <Axman6> > let octec = [0..255] in  [(a,b,c,d) | a <- octet, b <- octet, c <- octet, d <- octet]
18:48:23 <lambdabot>   Not in scope: `octet'Not in scope: `octet'Not in scope: `octet'Not in scope...
18:48:24 <JoshTriplett> CakeProphet: That won't work.
18:48:29 <mmorrow> , foldr interleave [] (repeat [0..])
18:48:32 <lunabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16...
18:48:33 <CakeProphet> JoshTriplett:  Why not?
18:48:35 <Axman6> > let octet = [0..255] in  [(a,b,c,d) | a <- octet, b <- octet, c <- octet, d <- octet]
18:48:36 <lambdabot>   [(0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,0,3),(0,0,0,4),(0,0,0,5),(0,0,0,6),(0,0...
18:48:43 <bmh> give me a one liner that given a day predicts the exchange between the dollar and the pound at noon the follow day for all days.
18:48:49 <Axman6> but ddarius takes the cake :)
18:48:58 <Axman6> > let x = [0..255] in liftM4 (,,,) x x x x
18:49:00 <lambdabot>   [(0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,0,3),(0,0,0,4),(0,0,0,5),(0,0,0,6),(0,0...
18:49:00 <augustss> bmh: -5%
18:49:08 <pumpkin> > [0..(2^32 - 1)] -- there, all IP addresses
18:49:09 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:49:11 <mmorrow> , diagonal (repeat [0..])
18:49:12 <JoshTriplett> CakeProphet: In order to find the first element, the list monad has to run every function, so if you use "repeat f" then the list monad has to run f an infinite number of times before it can return the first element.
18:49:13 <lunabot>  [0,1,0,2,1,0,3,2,1,0,4,3,2,1,0,5,4,3,2,1,0,6,5,4,3,2,1,0,7,6,5,4,3,2,1,0,...
18:49:22 <bmh> IPv6?
18:49:38 <pumpkin> saml: ^
18:49:39 <JoshTriplett> > [0..(2^128 - 1)] -- there, all IPv6 addresses
18:49:41 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:49:42 <Olathe> > join (join (join (liftM4 (,,,)))) [0..255]
18:49:44 <lambdabot>   [(0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,0,3),(0,0,0,4),(0,0,0,5),(0,0,0,6),(0,0...
18:49:57 <ddarius> augustss: replicateM
18:50:02 <Olathe> > join.join.join.liftM4 (,,,) $ [0..255]
18:50:03 <lambdabot>       Occurs check: cannot construct the infinite type: m = (->) (m a4)
18:50:03 <lambdabot>      ...
18:50:05 <augustss> bmh: or did you want something that correctly predicts it?
18:50:07 <Olathe> Bah.
18:50:16 <CakeProphet> JoshTriplett:  hmmm... so you would need to construct an infinite list where each element is the (>>=f) of the last.
18:50:28 <strht> @type liftM4
18:50:29 <bmh> augustss: correct, please. I'll modify the CouchDB bindings to your liking in exchange.
18:50:29 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
18:50:30 <JoshTriplett> > join $ join $ join $ liftM4 (,,,) $ [0..255]
18:50:31 <lambdabot>   Couldn't match expected type `(->) [a4]' against inferred type `[]'
18:50:39 <strht> what does that do, exactly
18:50:47 <strht> before i have to read this god-foresaken type signature
18:50:59 <Olathe> > liftM2 (,) [1..3] [100..102]
18:51:00 <lambdabot>   [(1,100),(1,101),(1,102),(2,100),(2,101),(2,102),(3,100),(3,101),(3,102)]
18:51:01 <pumpkin> @src liftM2
18:51:01 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:51:04 <Olathe> Something like that.
18:51:09 <augustss> bmh: I think I could get more out of a correct prediction than that ;)
18:51:09 <pumpkin> very simple, and liftM4 is similar :)
18:51:11 <Olathe> > liftM2 (+) [1..3] [100..102]
18:51:12 <strht> yuck
18:51:13 <lambdabot>   [101,102,103,102,103,104,103,104,105]
18:51:53 <JoshTriplett> CakeProphet: Yeah, I think that would work.  You want to return all the elements obtained by running f once, then twice, then ...
18:51:55 <Axman6> strht: lets you apply a function to multiple monads basically
18:52:01 <strht> > join (map (\x->[x,x+1,x+2,x+3]) [100..102)
18:52:05 <lambdabot>   <no location info>: parse error on input `)'
18:52:09 <CakeProphet> JoshTriplett:  I don't know how to represent that though. :((
18:52:10 <strht> > join (map (\x->[x,x+1,x+2,x+3]) [100..102]
18:52:11 <lambdabot>   <no location info>: parse error on input `;'
18:52:25 <strht> > join (map (\x->[x,x+1,x+2,x+3]) [100..102])
18:52:27 <lambdabot>   [100,101,102,103,101,102,103,104,102,103,104,105]
18:52:28 * strht sighs
18:52:30 <Axman6> strht: you're not using join correctly
18:52:37 <Cale> "to multiple monads"?
18:52:38 <strht> you're not using join correctly
18:52:45 <Axman6> Cale: yeah, badly phrased
18:52:58 <strht> @src join
18:52:58 <lambdabot> join x =  x >>= id
18:52:59 <pumpkin> multimonad!
18:53:04 <strht> alright
18:53:20 <augustss> I thought any type correct use of join was a correct use of it
18:53:21 <pumpkin> > join (*) 5
18:53:22 <lambdabot>   25
18:53:32 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
18:53:35 <strht> <3 augustss
18:53:39 <lambdabot>   [1,2,3,4,5,6,7,8]
18:53:42 <pumpkin> > ((*) >>= id) 5
18:53:48 <Cale> The combination of join with map like that is the same as bind
18:53:52 <lambdabot>   25
18:54:13 <Cale> (and, if you generalise map to fmap, this is true in any monad)
18:54:16 <pumpkin> > ((+) >>= id) 5
18:54:17 <Axman6> ah yes, join is concat for [] isn't it
18:54:17 <lambdabot>   10
18:55:03 <pumpkin> > ((^) >>= id) 5
18:55:04 <lambdabot>   3125
18:55:35 * strht throws up
18:56:05 <Axman6> anyone know a nice haskelly way to write a tetration function? x `tetrate` 5 = x^(x^(x^(x^(x^(x)))))
18:56:05 <CakeProphet> >  let f x = [10*x, 10*x+1] in iterate (>>=f)  [0, 1]
18:56:06 <lambdabot>   [[0,1],[0,1,10,11],[0,1,10,11,100,101,110,111],[0,1,10,11,100,101,110,111,1...
18:56:08 <JoshTriplett> > let f x = [10*x, 10*x+1] in sequence $ iterate (>>=f) [0,1]
18:56:09 <CakeProphet> oh ho
18:56:11 <lambdabot>   * Exception: stack overflow
18:56:12 <strht> i don't get these "monad" deals
18:56:17 <strht> my throat is both hands in the molten gold
18:56:19 <JoshTriplett> CakeProphet: Hah, we had the same idea at about the same time.
18:56:24 <Olathe> > join (join (join (liftM4 (\a b c d -> concat $ intersperse "." [a, b, c, d])))) $ map show [0..255]
18:56:26 <JoshTriplett> > let f x = [10*x, 10*x+1] in sequence $ iterate (>>=f) [0,1]
18:56:26 <lambdabot>   ["0.0.0.0","0.0.0.1","0.0.0.2","0.0.0.3","0.0.0.4","0.0.0.5","0.0.0.6","0.0...
18:56:29 <lambdabot>   * Exception: stack overflow
18:56:31 <CakeProphet> JoshTriplett:  forgot about iterate. Handy
18:56:34 <Olathe> > last $ join (join (join (liftM4 (\a b c d -> concat $ intersperse "." [a, b, c, d])))) $ map show [0..255]
18:56:47 <ttmrichter> strht: Monads are a complete mystery.  Until you grok them.  Then they're merely inexplicable.
18:56:50 <lambdabot>   thread killed
18:56:55 <strht> i sort of grok them
18:57:04 <strht> i don't get how they're applied to haskell though
18:57:17 <CakeProphet> JoshTriplett:  it actually makes sense how list is a monad now. lists created stat very much like for loops in imperitive languages.
18:57:21 <Axman6> i only get how they're applied to haskell :\
18:57:25 <CakeProphet> *state
18:57:44 <ttmrichter> strht: Dans did a good explanation of how to view monads once, calling them "executable semicolons".
18:57:50 <strht> dans or dons????
18:57:58 <ttmrichter> strht: Dons.  Sorry.
18:58:07 <strht> ewww
18:58:10 <ttmrichter> Google on the phrase and see if that blog entry is still up and accessible.
18:58:17 <bmh> ttmrichter: are you using davorak?
18:58:28 <ttmrichter> bmh: No.  Why?
18:58:29 <Axman6> dvorak no?
18:58:29 <pumpkin> dvorak?
18:58:33 <bmh> er, yeah.
18:58:37 <pumpkin> pronounced dvorjak or so
18:58:39 <Olathe> Nova ! Nooo !
18:58:40 <pumpkin> ;:P
18:58:49 <ttmrichter> I am LISTENING to Dvorak, however.  Does that help?  ;)
18:58:56 <bmh> ttmrichter: just curious, "o" is 9 keys away from "a" in qwerty
18:59:00 <pumpkin> ttmrichter: make sure you pronounce it right :P
18:59:16 <ttmrichter> bmh: I just got up.  You expect my brain to be working?
18:59:38 <redditbot> Want a job working in Haskell on web stuff with HAppS?
18:59:40 <CakeProphet> > Random 5
18:59:42 <lambdabot>   Not in scope: data constructor `Random'
18:59:49 <pumpkin> redditbot: omg
18:59:59 <CakeProphet> how do I get about getting Random and all of its friends?
19:00:03 <Axman6> pumpkin: it's hard to type in english how dvorak sounds imo
19:00:09 * ksf once took a vow not to do web apps, ever.
19:00:11 <mmorrow> @pl \f m -> join (fmap f m)
19:00:11 <lambdabot> (=<<)
19:00:26 <BMeph> Cale: Is there anything substantively different between lists and stacks? :)
19:00:33 <Axman6> dvorjak looks like it should be it should be said dvor-jak
19:00:45 <Axman6> or dvor-jack
19:00:47 <mmorrow> @pl flip (\f m -> join (fmap f m))
19:00:47 <lambdabot> (>>=)
19:00:48 <pumpkin> dvo-rj-ak :P
19:00:53 <CakeProphet> o lawd. There's a <<=
19:01:01 <mmorrow> @pl \m f -> join (fmap f m)
19:01:01 <lambdabot> (join .) . flip fmap
19:01:02 <CakeProphet> ... =<<
19:01:03 <mmorrow> heh
19:01:04 <Axman6> :t (<<=)
19:01:06 <lambdabot> Not in scope: `<<='
19:01:10 <strht> ksf: why?
19:01:12 <Olathe> @type (>{
19:01:13 <Olathe> @type (>)
19:01:14 <lambdabot> parse error on input `{'
19:01:14 <pumpkin> Axman6: I had a czech gf who made sure I pronounced it right :P
19:01:15 <strht> because you have to code without making mistakes? ;)
19:01:16 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:01:17 <Olathe> @type (<)
19:01:19 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:01:20 <Axman6> CakeProphet: =<< is just >>= backwards
19:01:28 <Olathe> @src (=<<)
19:01:28 <lambdabot> f =<< x = x >>= f
19:01:29 <Axman6> pumpkin: haha, nice :P
19:01:35 <mmorrow> @type ((join .) . flip fmap
19:01:37 <lambdabot> parse error (possibly incorrect indentation)
19:01:45 <Axman6> zomg, palindromic definition!
19:01:48 <mmorrow> @type (join .) . flip fmap
19:01:50 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
19:01:54 <mmorrow> @type flip ((join .) . fmap)
19:01:56 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
19:02:05 <Olathe> If only they'd used some reflective character instead of f.
19:02:06 <mmorrow> @pl (join .) . flip fmap
19:02:06 <lambdabot> (join .) . flip fmap
19:02:09 <CakeProphet> :t =<<
19:02:10 <BMeph> pumpkin: So, when you cashed your czech, did she bounce? 8D
19:02:11 <lambdabot> parse error on input `=<<'
19:02:11 <mmorrow> @pl flip ((join .) . fmap)
19:02:12 <lambdabot> (>>=)
19:02:18 <CakeProphet> :t (=<<)
19:02:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:02:24 <pumpkin> BMeph: *facepalm* :P
19:02:25 <saml> so... what are you doing?
19:02:26 <mmorrow> heh, @pl needs to add that special case too apparently
19:02:42 <ksf> strht, for about the same reasons I won't ever do SAP or use delphi.
19:03:07 <pumpkin> what is SAP?
19:03:18 <pumpkin> I've seen ads for it on CNN international I think
19:03:22 <ksf> www.sap.com
19:03:24 <mmorrow> , [$ty|(join .) . flip fmap|] == [$ty|flip ((join .) . fmap)|]
19:03:29 <lunabot>  luna: No instance for (GHC.Classes.Eq Text.PrettyPrint.HughesPJ.Doc)
19:03:30 <CakeProphet> Axman6:  oh... literally backwards? I thought you meant inverse operations.
19:03:38 <pumpkin> ksf: yeah, I've been there, but it doesn't really say anything
19:03:41 <CakeProphet> the function just comes first and the monad second.
19:03:49 <Axman6> CakeProphet: no, literally backwards :)
19:03:51 <mmorrow> , [$tyQ|(join .) . flip fmap|] == [$tyQ|flip ((join .) . fmap)|]
19:03:56 <lunabot>  True
19:03:58 <Axman6> @src (=<<)
19:03:58 <lambdabot> f =<< x = x >>= f
19:04:13 <CakeProphet> that definition doesn't make sense to me.
19:04:16 <Axman6> that definition scares me a little. it's too perfect
19:04:23 <mmorrow> @type \g f -> (g .) . flip f
19:04:24 <pumpkin> CakeProphet: it's using pattern matching
19:04:24 <lambdabot> forall c a a1 c1. (c1 -> c) -> (a -> a1 -> c1) -> a1 -> a -> c
19:04:26 <Axman6> CakeProphet: why not?
19:04:33 <mmorrow> @type \g f -> flip ((g .) . f)
19:04:34 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a -> a1 -> c
19:04:38 <ksf> pumpkin, "enterprise solutions" says it all.
19:04:39 <CakeProphet> what is x?
19:04:43 <CakeProphet> oh wait...
19:04:46 <CakeProphet> I was just reading it wrong.
19:04:47 <pumpkin> CakeProphet: says "if you encounter f =<< x", then it's equal to x >>= f
19:04:53 <CakeProphet> I was reading
19:05:00 <mmorrow> @free (b -> c) -> (a1 -> a -> b) -> a -> a1 -> c
19:05:00 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
19:05:06 <mmorrow> @free fix
19:05:08 <lambdabot> f . g = h . f => f (fix g) = fix h
19:05:09 <CakeProphet> (f) = (<< x) = (x) >> (=) f
19:05:12 <mmorrow> @free join
19:05:13 <pumpkin> ksf: yeah, and nothing at the same time :P
19:05:13 <lambdabot> Expected variable or '.'
19:05:15 <CakeProphet> which didn't look like valid Haskell
19:05:17 <CakeProphet> but now I see it.
19:05:21 <Axman6> ah haha
19:05:25 <mmorrow> @help free
19:05:26 <lambdabot> free <ident>. Generate theorems for free
19:05:27 <pardus> @src (>=>)
19:05:27 <lambdabot> Source not found.
19:05:37 <pardus> @typ (>=>)
19:05:38 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:05:38 <CakeProphet> (f=<<x) = (x >>= f)
19:05:39 <pumpkin> omg free theorems
19:06:00 <pumpkin> @free x = y
19:06:00 <pardus> @free x
19:06:01 <lambdabot> x = x
19:06:01 <lambdabot> Extra stuff at end of line
19:06:05 <CakeProphet> so can Haskel do function equality or is it not that awesome yet?
19:06:11 <CakeProphet> +l
19:06:11 <pumpkin> I call that one pumpkin's theorem
19:06:22 <pumpkin> CakeProphet: it's not possible, in general :P
19:06:24 <mmorrow> g <=< f = (g =<<) . f
19:06:33 <CakeProphet> aw... so no
19:06:40 <mmorrow> g <=< f = (g =<<) . f = (\a -> g =<< f a)
19:06:47 <CakeProphet> > flip.(=<<) == >>=
19:06:48 <lambdabot>   <no location info>: parse error on input `>>='
19:06:49 <CakeProphet> :(
19:06:57 <CakeProphet> > flip.(=<<) == (>>=)
19:06:58 <lambdabot>       Occurs check: cannot construct the infinite type:
19:06:58 <lambdabot>        b = (b -> b1) ...
19:07:05 <pumpkin> don't compose it with it
19:07:07 <ksf> basically, it's a big api to do all kinds of stuff enterprise enterprise deskjockeys then get paid for to click around in.
19:07:10 <augustss> > (+) == (+)
19:07:11 <lambdabot>       No instance for (Eq (a -> a -> a))
19:07:11 <lambdabot>        arising from a use of `==' at...
19:07:22 <pumpkin> ksf: sweet, sounds awesome
19:07:22 <mmorrow> , [$tyQ|   flip.(=<<)    |]       ==      [$tyQ|      (>>=)        |]
19:07:25 <ksf> s/se enterprise/se /
19:07:27 <lunabot>  False
19:07:50 <mmorrow> , [$tyQ| flip (=<<) |]    ==   [$tyQ| (>>=) |]
19:07:55 <lunabot>  False
19:08:00 <CakeProphet> hmmm... but in a functional programming language there's no side-effects... so it seems like it could be at least /more/ possible than in other languages.
19:08:14 <pumpkin> CakeProphet: it's a fundamentally impossible problem :P
19:08:15 <CakeProphet> to determine if two functions are semantically the same.
19:08:15 <mmorrow> that doesn't actually work for alpha-equiv types
19:08:20 <ksf> ...leading to such situations as management stopping developers to put up a wiki to collect knowledge.
19:08:22 <mmorrow> , [$tyQ| flip (=<<) |]
19:08:25 <mmorrow> , [$ty| flip (=<<) |]
19:08:27 <lunabot>  ForallT [a,b,c] [AppT (ConT Monad) (VarT b)] (AppT (AppT ArrowT (AppT (Va...
19:08:32 <lunabot>  forall a b c . Monad b => (b c) -> (c -> b a) -> b a
19:08:39 <mmorrow> , [$ty| (>>=) |]
19:08:44 <lunabot>  forall a b c . Monad c => (c b) -> (b -> c a) -> c a
19:08:47 <mmorrow> ah
19:08:54 <Axman6> mmorrow: you need to make that monad m
19:08:54 <pumpkin> CakeProphet: even for restricted things like grammars/PDAs, it's impossible to decide if they recognize the same language
19:08:55 <conal> CakeProphet: you're right.  it's only half as impossible in functional languages.
19:09:00 <Axman6> so it's less confusing
19:09:16 <ksf> "see, we got this licence contract, we really don't pay anything if you use it. you're really lucky!"
19:09:53 <mmorrow> Axman6: hmm, i guess i could have some special cases for typevars of particular classes
19:09:59 <CakeProphet> pumpkin:  Haskell doesn't even have identity equality for functions?
19:10:08 <CakeProphet> (+) == (+) ?
19:10:11 <augustss> CakeProphet: no
19:10:12 <pumpkin> nope
19:10:14 <mmorrow> Monad ==> m, n, mm, nn, ...
19:10:17 <pumpkin> what would be the point?
19:10:17 <Axman6> mmorrow: yeah, Monad m, Functor f etc
19:10:28 <mmorrow> Functor ==> f, g, ff, gg, ...
19:10:34 <mmorrow> what else?
19:10:50 <CakeProphet> pumpkin: hmm.. I guess it might be less useful in Haskell, but I use it a lot with particularly meta-y algorithms in Python.
19:10:51 <Axman6> does it still do strange things with [a] -> [] a?
19:10:58 <pumpkin> CakeProphet: how?
19:10:58 <mmorrow> oh yeah, that too.
19:11:18 <mmorrow> err, it might not, but maybe it does in some places
19:11:21 <ksf> I don't think dispatching on a function could ever be useful.
19:11:37 <augustss> CakeProphet: it would wreak havoc with the Haskell semantics
19:11:41 <mmorrow> the TH prettyprinter (not related to [] a vs. [a]) is kinda buggy
19:11:48 <ksf> ...you pass in functions not to have to dispatch, after all.
19:11:50 <CakeProphet> pumpkin:  ...I have no particular example, actually. So maybe I'm just confabulating here.
19:11:54 <pumpkin> :)
19:12:03 <mmorrow> i should try to fix it
19:12:20 <Axman6> mmorrow: :)
19:12:54 <mmorrow> this is amusing (a failed attempt at applying a heuristic by me):
19:12:55 <mmorrow> , src ''[]
19:13:00 <lunabot>  data [] a = [] | a `(:)` ([a])
19:13:08 <Axman6> :|
19:13:08 <mmorrow> `(:)`
19:13:11 <mmorrow> hehe
19:13:57 <mmorrow> i had to mod it to add (sometimes superfluous) parens so that it would at least be correct
19:14:25 <mmorrow> but i haven't narrowed it down to the real problem in the prettyprinter
19:15:26 <pumpkin> wow, epic comment: http://developers.slashdot.org/comments.pl?sid=1073773&cid=26237203
19:16:08 <BMeph> BBL, still making my comp behave. :|
19:16:21 <CakeProphet> @let repeat' x =  iterate (id) (return x)
19:16:23 <lambdabot>  Defined.
19:16:40 <CakeProphet> I don't even know why I used return, let's see what happens.
19:16:48 <CakeProphet> > repeat' 5
19:16:49 <lambdabot>       No instance for (Show (m t))
19:16:49 <lambdabot>        arising from a use of `show' at <in...
19:17:00 <CakeProphet> > repeat' 5 :: [Int]
19:17:01 <lambdabot>   Couldn't match expected type `Int' against inferred type `m t'
19:17:17 <mmorrow> @let repeat'' = fix . (:)
19:17:18 <lambdabot>  Defined.
19:17:19 <pumpkin> :t repeat'
19:17:20 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> [m a]
19:17:32 <CakeProphet> hmmm... what's :?
19:17:33 <pumpkin> > repeat' 5 :: [[Int]]
19:17:35 <lambdabot>   [[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5...
19:17:43 <pumpkin> > repeat' 5 :: [Maybe Int]
19:17:45 <lambdabot>   [Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just...
19:17:56 <CakeProphet> ?src :
19:17:56 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:18:04 <CakeProphet> ?src (:)
19:18:04 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:18:04 <pumpkin> CakeProphet: it's the cons operator
19:18:07 <Axman6> @instances Monad
19:18:07 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:18:09 <CakeProphet> oh right.
19:18:15 <pumpkin> CakeProphet: it's the type constructor for list
19:18:19 <mmorrow> fix . (:) == \x -> fix (x:) == \x -> let go = x : go in go
19:18:19 <CakeProphet> -nod-
19:18:24 <CakeProphet> ?src fix
19:18:25 <lambdabot> fix f = let x = f x in x
19:18:39 <CakeProphet> ...why is there even a let expression there.
19:18:46 <mmorrow> , let xs = 0 : xs in xs
19:18:48 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:19:03 <mmorrow> , let repeat x = let xs = x : xs in xs in repeat 42
19:19:05 <lunabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
19:19:10 <mmorrow> , fix (42:)
19:19:12 <lunabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
19:19:34 <Olathe> @let repeat''' x = fun (concat.intersperse ", ".iterate (++"'") $ "repeat") :: Expr
19:19:37 <lambdabot>  Defined.
19:19:37 <mmorrow> , let foo = fix . (:) in foo 42
19:19:39 <lunabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
19:19:40 <Olathe> > repeat''' 5
19:19:42 <lambdabot>   repeat, repeat', repeat'', repeat''', repeat'''', repeat''''', repeat''''''...
19:19:45 <CakeProphet> :t fun
19:19:47 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
19:20:17 <mmorrow> > show (a::Expr)
19:20:18 <lambdabot>   "a"
19:20:40 <CakeProphet> :t fun repeat
19:20:41 <lambdabot>     Couldn't match expected type `String'
19:20:41 <lambdabot>            against inferred type `a -> [a]'
19:20:41 <lambdabot>     In the first argument of `fun', namely `repeat'
19:20:44 <CakeProphet> > fun repeat
19:20:45 <lambdabot>   Couldn't match expected type `String'
19:20:46 <mmorrow> > fmap (length . dropWhile isAlpha . show) . repeat''' $ 5
19:20:47 <lambdabot>   Couldn't match expected type `f a' against inferred type `Expr'
19:20:53 <Olathe> @type fun
19:20:55 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
19:20:56 <xEpicFailGuyx> Quick question if you don't mind
19:21:16 <Olathe> @instances SimpleReflect.FromExpr
19:21:17 <lambdabot> Couldn't find class `SimpleReflect.FromExpr'. Try @instances-importing
19:21:46 <xEpicFailGuyx> To make some type an instance of a class, do I need to write 'deriving' in its definition AND do 'instance Class Type where bla bla bla'?
19:21:57 <CakeProphet> xEpicFailGuyx:  noep
19:21:59 <mmorrow> just one or the other
19:22:01 <xEpicFailGuyx> Ok
19:22:13 <mmorrow> but you can only derive certain classes
19:22:14 <xEpicFailGuyx> If I only write 'deriving', what is it going to assume
19:22:27 <CakeProphet> I'm not entirely sure what deriving does... like how it knows how to implement each function.
19:22:35 <xEpicFailGuyx> lol ok
19:22:40 <mmorrow> if you write "deriving (Show)", it'll auto-generate the code for "instance Show ...." for you
19:23:01 <ksf> it's compiler magic.
19:23:13 <Axman6> well Show is pretty easy, and Eq too
19:23:22 <mmorrow> CakeProphet: it can figure out how to implement each function because it has the full info about your data declaration available to it (it := compiler)
19:23:31 <xEpicFailGuyx> mmorrow: Really? Cool
19:23:34 <Axman6> Enum isn't too hard ro figure out, or Ord i guess
19:23:46 <ksf> Actually, It'd be nice to be able to to custom derivable classes using TH.
19:23:51 <mmorrow> xEpicFailGuyx: well sure, it has to parse your code :)
19:23:53 <xEpicFailGuyx> Ord is basically the same thing as partial ordering?
19:24:07 <mmorrow> ksf: check out the derive package on hackage. it's super.
19:24:12 <xEpicFailGuyx> oh guess not
19:24:16 <CakeProphet> xEpicFailGuyx:  it implements <, >, etc
19:24:23 <xEpicFailGuyx> yeah I see
19:24:25 <Axman6> @src Ord
19:24:25 <lambdabot> class  (Eq a) => Ord a  where
19:24:25 <lambdabot>     compare      :: a -> a -> Ordering
19:24:25 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:24:25 <lambdabot>     max, min         :: a -> a -> a
19:24:37 <Axman6> @instances Ord
19:24:38 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:24:42 <xEpicFailGuyx> hm ... what if I only wanted partial ordering?
19:24:49 <pumpkin> what'a Dual?
19:24:52 <pumpkin> @info Dual
19:24:52 <lambdabot> Dual
19:24:55 <pumpkin> thanks
19:24:55 <xEpicFailGuyx> @src Dual
19:24:55 <lambdabot> Source not found. You speak an infinite deal of nothing
19:24:57 <Axman6> @src Dual
19:24:57 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:24:59 <Axman6> bah
19:25:02 <Olathe> @src Dual
19:25:03 <lambdabot> Source not found. Wrong!  You cheating scum!
19:25:05 <pumpkin> @index Dual
19:25:05 <lambdabot> bzzt
19:25:11 <Olathe> @hoogle Dual
19:25:11 <lambdabot> Data.Monoid newtype Dual a
19:25:11 <lambdabot> Data.Monoid Dual :: a -> Dual a
19:25:11 <lambdabot> Data.Monoid getDual :: Dual a -> a
19:25:15 <CakeProphet> xEpicFailGuyx:  hmmm... I'm not sure what that means, but it sounds like you'd want to write your own instance of Ord definition.
19:25:20 <pumpkin> aha
19:25:27 <Olathe> > Dual 5
19:25:29 <lambdabot>   Dual {getDual = 5}
19:25:32 <ksf> scary cofoo stuff, it seems to be.
19:25:36 <pumpkin> @hoogle Last
19:25:36 <lambdabot> Data.Monoid newtype Last a
19:25:36 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
19:25:36 <lambdabot> Prelude last :: [a] -> a
19:25:38 <Olathe> > getDual (Dual 5)
19:25:40 <lambdabot>   5
19:25:43 <Olathe> zomg !
19:25:46 <pumpkin> lol
19:26:00 <pumpkin> @hoogle Sum a
19:26:01 <lambdabot> Did you mean: :: Sum a /count=20
19:26:01 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
19:26:01 <Axman6> > Dual 3 < Dual 4
19:26:02 <lambdabot>   True
19:26:05 <Axman6> > Dual 3 < Dual 2
19:26:06 <lambdabot>   False
19:26:17 <Axman6> seems like an id monad...
19:26:27 <Axman6> @Src Ordering
19:26:27 <lambdabot> Maybe you meant: rc src
19:26:28 <xEpicFailGuyx> CakeProphet: A partially-ordered set is one which has a relation that is reflexive, antisymmetric and transitive
19:26:32 <Axman6> @src Ordering
19:26:32 <lambdabot> data Ordering = LT | EQ | GT
19:26:33 <mmorrow> ksf: et voila! http://hpaste.org/13354
19:26:50 <CakeProphet> xEpicFailGuyx:  yeah, just define >, < etc to do as you please.
19:26:52 <CakeProphet> I guess.
19:26:55 <xEpicFailGuyx> CakeProphet: In other words, a set with just <=
19:27:07 <CakeProphet> hmmm... oh, like lattices?
19:27:10 <Axman6> @src (<)
19:27:10 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
19:27:11 <xEpicFailGuyx> Maybe
19:27:16 <xEpicFailGuyx> I don't know what lattices are
19:27:27 <mmorrow> CakeProphet, xEpicFailGuyx: check out http://hpaste.org/13354 to see examples of the code GHC might generate for derived instances
19:27:27 <Axman6> i think you only need to define compare for Ord
19:27:28 <CakeProphet> they have a <= operation but nothing else.
19:27:32 <Axman6> @src Ord
19:27:32 <lambdabot> class  (Eq a) => Ord a  where
19:27:32 <lambdabot>     compare      :: a -> a -> Ordering
19:27:32 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:27:32 <lambdabot>     max, min         :: a -> a -> a
19:27:35 <Olathe> "The dual of a monoid, obtained by swapping the arguments of mappend."
19:27:38 <xEpicFailGuyx> mmorrow: Ah thx
19:27:39 <Axman6> @src max
19:27:40 <lambdabot> max x y = if x <= y then y else x
19:27:40 <mmorrow> (and that derive prog is in
19:27:44 <mmorrow> @hackage derive
19:27:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
19:27:48 <mmorrow> )
19:28:26 <CakeProphet> xEpicFailGuyx:  just make it an instance of Ord and make everything error except <= perhaps?
19:29:00 <xEpicFailGuyx> So it seems the compiler is able to autogenerate class code for a type if that type is itself based on fundamental types which the compiler already knows
19:29:03 <xEpicFailGuyx> CakeProphet: Maybe
19:29:18 <mmorrow> xEpicFailGuyx: exactly
19:29:24 <xEpicFailGuyx> cool
19:29:26 <xEpicFailGuyx> very cool
19:29:46 <CakeProphet> ?src Arbitrary
19:29:46 <lambdabot> Source not found. Where did you learn to type?
19:29:54 <xEpicFailGuyx> and no need for macros in this language either, alleluia
19:30:12 <Axman6> xEpicFailGuyx: some types don't need to depend on known types for derive instances, like Enum
19:30:21 <mmorrow> CakeProphet: Test.QuickCheck
19:30:28 <CakeProphet> mmorrow:  wat?
19:30:34 <xEpicFailGuyx> Axman6: I see
19:30:53 <mmorrow> Test.QuickCheck is the pkg that Arbitrary's from
19:31:09 <Axman6> data Foo = A | B | C | D deriving (Show, Ord, Enum, Eq) would work fine (i think)
19:31:15 <mmorrow> @check \x -> x == (x::Integer)
19:31:16 <lambdabot>   "OK, passed 500 tests."
19:31:31 <Olathe> > appEndo (Endo id) 5
19:31:32 <lambdabot>   5
19:31:37 <Olathe> Appendo !
19:31:46 <mmorrow> @check \x y z-> (x + y) + z == x + (y + z::Double)
19:31:47 <lambdabot>   "Falsifiable, after 8 tests:\n4.0\n3.3333333333333335\n-4.5\n"
19:31:52 <int-e> @check \x -> (x :: Integer) /= 42
19:31:54 <lambdabot>   "Falsifiable, after 130 tests:\n42\n"
19:31:57 <mmorrow> @check \x y z-> (x + y) + z == x + (y + z::Integer)
19:31:58 <lambdabot>   "OK, passed 500 tests."
19:32:14 <CakeProphet> ?src Just
19:32:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:32:16 <Axman6> @check \x y z-> (x + y) + z == x + (y + z::CReal)
19:32:17 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
19:32:17 <lambdabot>          ...
19:32:21 <Axman6> bah
19:32:22 <Olathe> @check reverse xs == xs
19:32:23 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
19:32:28 <Olathe> @check \xs -> reverse xs == xs
19:32:29 <lambdabot>   "OK, passed 500 tests."
19:32:34 <Olathe> Yay !
19:32:37 <Axman6> o.O
19:32:47 <mmorrow> it usually will default to () if it can
19:32:54 <Olathe> Good thing, too.
19:33:00 <Axman6> ha
19:33:16 <Axman6> @check \xs -> reverse xs == (xs::[Integer])
19:33:17 <lambdabot>   "Falsifiable, after 1 tests:\n[1,-3,2]\n"
19:33:42 <mmorrow> @src Maybe
19:33:42 <lambdabot> data Maybe a = Nothing | Just a
19:33:45 <Asztal> > filterM (const [True, False]) [1,2,3,4]
19:33:46 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
19:33:53 <mmorrow> @type Just
19:33:54 <lambdabot> forall a. a -> Maybe a
19:34:05 <Axman6> :t filterM
19:34:06 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
19:34:13 <Olathe> @check \xs -> xs == map (\x -> (x^5000)**(1.0/5000.0)) xs
19:34:14 <lambdabot>   "Falsifiable, after 0 tests:\n[-3.5,0.0,0.0]\n"
19:34:36 <Olathe> @check \xs -> xs == map (\x -> (x^5000)**(1.0/5000.0::CReal)) xs
19:34:37 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
19:34:37 <lambdabot>          ...
19:34:50 <Olathe> ...
19:34:59 <Axman6> can't use CReals in QC
19:35:20 <Olathe> Ahh.
19:35:38 <dons> cool, haskell (via cryptol) on slashdot, http://developers.slashdot.org/article.pl?sid=08/12/26/1725208
19:35:42 <xEpicFailGuyx> haha, I'm browsing a somethingawful thread on Haskell and finding cool links along the way
19:35:44 <xEpicFailGuyx> http://forums.somethingawful.com/showthread.php?threadid=2841145&userid=0&perpage=40
19:36:14 <pumpkin> dons: I posted one of the comments in here earlier, it was awesome
19:36:15 <pumpkin> :P
19:36:50 <Axman6> dons: that something you've been working on?
19:36:58 <pumpkin> dons: know anything about that gpugen I saw was giving a talk at galois a while back? it looks interesting but I can't find any info anywhere on it
19:37:02 <pumpkin> ( http://developers.slashdot.org/comments.pl?sid=1073773&cid=26237203 is the comment btw)
19:37:05 <CakeProphet> > take 5 (reverse [..100])
19:37:06 <lambdabot>   <no location info>: parse error on input `..'
19:37:08 <dons> Axman6: only a little, but its a long term galois project.
19:37:10 <CakeProphet> teehee
19:37:15 <Axman6> nice
19:37:28 <CakeProphet> psh, Haskell can't even make a list with no beginning?
19:37:32 <pumpkin> lol
19:37:32 <xEpicFailGuyx> Is it possible to use Bird scripts in GHC?
19:37:36 <CakeProphet> what kind of language is this?
19:37:42 <CakeProphet> srsly.
19:37:53 <Axman6> > [100,99..]
19:37:54 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
19:38:00 <Axman6> > reverse [100,99..]
19:38:02 <dons> pumpkin: yeah, the authors are about to release it
19:38:09 <xEpicFailGuyx> > [10,9,..]
19:38:09 <pumpkin> dons: awesome!
19:38:20 <xEpicFailGuyx> > [10,9..]
19:38:21 <pumpkin> xEpicFailGuyx: epic fail guy
19:38:24 <lambdabot>   thread killed
19:38:31 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,...
19:38:41 <xEpicFailGuyx> ah, that goes on forever
19:38:51 <xEpicFailGuyx> > take 5 [10,9..]
19:38:53 <lambdabot>   [10,9,8,7,6]
19:39:04 <xEpicFailGuyx> > take 5 (reverse [10,9..])
19:39:11 <pumpkin> > [10, 9..] :: [Word8]
19:39:13 <lambdabot>   mueval: Prelude.read: no parse
19:39:15 <bmh> I think you mean
19:39:17 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
19:39:20 <bmh> > last [1..]
19:39:27 <lambdabot>   mueval: Prelude.read: no parse
19:39:28 <xEpicFailGuyx> lol
19:39:34 <CakeProphet> > [1,1,2,3,5,8..]
19:39:37 <lambdabot>   <no location info>: parse error on input `..'
19:39:38 <CakeProphet> :3
19:39:43 <CakeProphet> > [1,1,2,3,5,8...]
19:39:44 <lambdabot>   <no location info>: parse error on input `]'
19:39:52 <CakeProphet> rofl.
19:39:58 <CakeProphet> I was expecting it to be a special case.
19:40:06 <pumpkin> > scanl1 (+) [1,3..]
19:40:08 <CakeProphet> just for fun.
19:40:08 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:40:17 <Olathe> > ([1,1,2,3,5,8])...
19:40:18 <xEpicFailGuyx> > last [ x | x <- [1..], x <= 10 ]
19:40:18 <lambdabot>   <no location info>: parse error on input `;'
19:40:22 <Olathe> > ([1,1,2,3,5,8]...)
19:40:25 <lambdabot>   [1,1,2,3,5,8,8,-6,-55,-173,-410,-835,-1539,-2638,-4276,-6628,-9903,-14347,-...
19:40:31 <pumpkin> Olathe: epic
19:40:34 <lambdabot>   thread killed
19:40:39 <Olathe> > ([1,4,9]...)
19:40:41 <CakeProphet> Olathe:  :o
19:40:41 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:40:52 <CakeProphet> how?
19:41:00 <pumpkin> it's magic
19:41:08 <Olathe> @let (...) [x] = repeat x; (...) x@(x0:xs) = scanl (+) x0 ((zipWith (-) xs x)...) --by Newsham
19:41:10 <lambdabot>  <local>:17:0:
19:41:10 <lambdabot>      Multiple declarations of `L....'
19:41:10 <lambdabot>      Declared at: <local...
19:41:16 <CakeProphet> oh okay... a postfix operator.
19:41:53 <xEpicFailGuyx> I wonder whether The Daily Show is on today
19:42:01 <pumpkin> …
19:42:14 <mmorrow> , "…"
19:42:16 <CakeProphet> I didn't even know you could have postfix operators?
19:42:17 <lunabot>  "\8230"
19:42:18 <mmorrow> , utf8enc "…"
19:42:18 <bmh> is John Stewart interviewing Simon?
19:42:19 <Olathe> If not, the title is incorrect.
19:42:20 <lunabot>  "\226\128\166"
19:42:28 <Olathe> It's a regular operator.
19:42:30 <Olathe> > (2+)
19:42:32 <lambdabot>       Overlapping instances for Show (t -> t)
19:42:32 <lambdabot>        arising from a use of `s...
19:42:36 <Olathe> Works great :)
19:43:14 <CakeProphet> Olathe:  so it's not postfix?
19:43:27 * CakeProphet is confused.
19:43:37 <Olathe> Well, you can do (thingy operator)
19:43:44 <Olathe> > (2+) 5
19:43:47 <lambdabot>   7
19:43:51 <Olathe> > map (2+) [1..10]
19:43:54 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
19:43:56 <CakeProphet> hmmm
19:44:05 <CakeProphet> @let @ x = x
19:44:05 <lambdabot>   Parse error
19:44:12 <CakeProphet> @let (@) x = x
19:44:12 <lambdabot>   Parse error
19:44:21 <CakeProphet> @let (%) x = x
19:44:22 <lambdabot>  <local>:7:42:
19:44:22 <lambdabot>      Ambiguous occurrence `%'
19:44:22 <lambdabot>      It could refer to either `L...
19:44:28 <CakeProphet> ...oh.
19:44:30 <CakeProphet> > 100%
19:44:32 <lambdabot>   <no location info>: parse error on input `;'
19:44:33 <Olathe> @let (<<<<<<<) x = x
19:44:37 <lambdabot>  Defined.
19:44:42 <CakeProphet> ...thank you.
19:44:58 <Olathe> > (5<<<<<<<)
19:45:00 <lambdabot>   5
19:45:16 <CakeProphet> cool.
19:45:22 <CakeProphet> > 5!
19:45:23 <lambdabot>   <no location info>: parse error on input `;'
19:45:29 <CakeProphet> > (5!)
19:45:31 <lambdabot>       Overlapping instances for Show (i -> e)
19:45:31 <lambdabot>        arising from a use of `s...
19:45:41 <CakeProphet> no factorial operator defined?
19:45:43 <Olathe> ! is an array operator.
19:45:48 <CakeProphet> ...oh lawl.
19:45:49 <Olathe> @type (!)
19:45:51 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
19:47:18 <Axman6> dons: what do galois actually do anyway?
19:47:51 <bmh> Axman6: they write code using haskell, duh
19:48:55 <CakeProphet> Haskell has a large amount of syntax... is there any known cases of ambiguity?
19:49:03 <CakeProphet> if not, that's pretty impressive.
19:49:27 <Axman6> none that i know of
19:49:42 <Axman6> you mean things like !?
19:49:52 <idnar> the rules are pretty simple, just powerful
19:50:02 <idnar> (for the most part)
19:50:11 <CakeProphet> nah. Like where the syntax could easily mean two things.
19:50:45 <araujo> CakeProphet, large amount of syntax?, you think so?
19:50:45 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
19:50:54 <araujo> haskell's syntax is very simple
19:50:55 <roconnor> there is that damn do if then else parsing craziness
19:50:56 <pumpkin> yeah
19:51:18 <pumpkin> let's get rid of if statements anyway
19:51:28 <roconnor> it's not ambiguous, but it is confusing
19:51:30 <araujo> they are expressiones
19:51:33 <pumpkin> whatever :P
19:51:41 <Axman6> CakeProphet: haskell actually has a pretty small syntax, everything is defined as functions or datatypes
19:51:42 <pumpkin> I still don't like them
19:51:43 <araujo> hah ok
19:51:43 <pumpkin> they look ugly
19:51:52 <araujo> they are useful
19:51:57 <pumpkin> that if' function
19:52:01 <tahir_hhh> Hi, I used to program is Haskell at university.  Are there any IDEs that you guys would recommend?
19:52:02 <araujo> not ugly if you don't abuse them
19:52:11 <bmh> tahir_hhh: vim
19:52:13 <pumpkin> araujo: not ugly if you don't use them either :P
19:52:15 <luite_> tahir_hhh: emacs!
19:52:24 <pumpkin> but I like the if' function that @pl spits out
19:52:26 <luite_> sorry had to respond as someone said vim ;)
19:52:29 <araujo> pumpkin, they come in handy in certain situations
19:52:31 <bmh> > putStr "luite_ must die"
19:52:33 <lambdabot>   * Exception: "<IO ()>"
19:52:38 <bmh> oops...
19:52:42 <bmh> > "luite_ must die"
19:52:43 <tahir_hhh> bmh: the raw vim mode or "cream"?
19:52:44 <lambdabot>   "luite_ must die"
19:52:46 <pumpkin> > text "ohai"
19:52:48 <lambdabot>   ohai
19:53:01 <bmh> tahir_hhh: cream?
19:53:24 <CakeProphet> Axman6: well it has a lot of context-based syntax, like when defining function patterns or in list comprehensions, or in data-type definitions.
19:53:40 <tahir_hhh> bmh: it emulates the normal keybindings for ( control + v )  = paste etc
19:53:45 <CakeProphet> Axman6: but yeah, semantically it's all functions/datatypes, so I guess it's easy to think in.
19:53:46 <Axman6> but that's about it, and do notation
19:54:21 <bmh> tahir: never used it. Long ago, one of my friends told me that the other kids would make fun of me if I kept using nano, so I learned to use vim.
19:54:22 <araujo> CakeProphet, they all follow the same principle
19:54:31 <bmh> then he rooted me and nuked my home directory.
19:54:35 <CakeProphet> Axman6:  I guess since I just got done playing with io it has a lot. It's certainly not a problem to have a lot of syntax, if it's usable.
19:54:56 <araujo> of scoping and expression declarations
19:55:11 <Axman6> CakeProphet: yeah it's got more than Io, but it's very easy to remember
19:55:37 <idnar> erk, nano
19:55:41 <araujo> very easy and intuitive i'd say
19:55:44 <CakeProphet> -nod- I remember most of it. I occasionally forget some choice functions (like iterate a while ago...)
19:55:55 <CakeProphet> but that's not syntax.
19:56:20 <idnar> nano is one of those "killall $EDITOR to escape" editors for me
19:57:23 <Axman6> i wouldn't use nano for writing code, but small edits it's excellent for
19:58:28 <CakeProphet> I use pico when I have to log into a remote server and change config files.
19:58:38 <CakeProphet> but yeah, definitely not an IDE.
19:59:15 <idnar> I'm very much a vim guy, although I know emacs well enough to do basic editing
19:59:39 <redditbot> Cryptol makes it to Slashdot (been a while since we've seen a Haskell project there!)
19:59:39 <redditbot> A Plea For "cabal install"
19:59:45 <idnar> all that chording just kills me, though; I can't use emacs for more than about 30 minutes before my hands start cramping :P
19:59:51 <CakeProphet> Axman6: I think !! is an odd operator symbol for list indexes... but I end up indexing individual list items very rarely.
20:00:03 <Axman6> aye
20:00:14 <Axman6> what would you prefer?
20:00:22 <Axman6> list[index]?
20:00:26 <CakeProphet> not even sure.
20:00:31 <mmorrow> CakeProphet: yeah, parsing haskell isn't trivial for sure
20:00:34 <jeffz`> idnar: maybe you need stronger hands...
20:00:37 <CakeProphet> nah... that would break things.
20:00:39 <CakeProphet> I think?
20:00:44 <Axman6> probably
20:00:55 <idnar> jeffz`: I probably just need smaller hands :/
20:01:26 <CakeProphet> Axman6:  @?
20:01:33 <jeffz`> idnar: I can use emacs for hours on end, on the other hand playing the piano takes more strength
20:01:35 <Axman6> already used
20:01:44 <Axman6> f xss@(x:xs)
20:01:56 <idnar> jeffz`: I can play the piano for hours without any problems, so it's not that
20:01:59 <CakeProphet> it could be used in both places without ambiguity, couldn't it?
20:02:15 <luite_> idnar: you can remap caps lock to ctrl (in linux at least), that helps a bit
20:02:25 <jeffz`> idnar: hm, weird...
20:02:30 <Axman6> i find Emacs very awkward to use, hence why i'm trying to learn to use Vim
20:02:51 <CakeProphet> if not @ then @@... maybe? it makes more sense than !!.
20:03:01 <CakeProphet> -shrug- but it's not really a problem.
20:03:06 <mmorrow> yeah, (@) doesn't work
20:03:19 <mmorrow> , let (@) = (!!) in [0..]@12
20:03:20 <lunabot>  luna: parse error on input `@'
20:03:22 <idnar> luite_: well, at any rate, even if my hands didn't get all twisted up, I think it would still be a fair amount slower than vim commands
20:03:27 <mmorrow> , let (@@) = (!!) in [0..]@@12
20:03:29 <lunabot>  12
20:03:51 <Axman6> CakeProphet: you can always define it though, as mmorrow showed :)
20:04:06 <idnar> @let x = 5 in 5@x
20:04:06 <lambdabot>   Parse error
20:04:07 <CakeProphet> Axman6:  not with @ though.
20:04:13 <Axman6> well yeah
20:04:14 * ddarius plays guitar and banjo and has no desire to use emacs.
20:04:14 <idnar> @let x = 5 in x@5
20:04:14 <lambdabot>   Parse error
20:04:18 <Axman6> it's actually syntax
20:04:32 <luite_> idnar: I recall there are some vim keybindings for emacs, for some basic commands probably. I'm not sure what the point of using emacs is then, but still ;)
20:04:35 <CakeProphet> @let (@@) = (!!)
20:04:37 <lambdabot>  Defined.
20:04:41 <CakeProphet> :o
20:04:51 <ddarius> luite_: There's Viper mode, but from what I hear noone likes it.
20:04:52 <mmorrow> > [0..]@@42
20:04:53 <lambdabot>   42
20:04:58 <idnar> luite_: yeah, I must give viper a try again sometime
20:05:11 <idnar> luite_: the point of emacs would be to get broader functionality :P
20:05:19 <luite_> ddarius: ah that's what it's called, never used it though :)
20:05:23 <Axman6> using @@ for concatenation in OCaml confuses me
20:05:34 <CakeProphet> I like ++
20:05:37 <Axman6> me too
20:05:48 <ddarius> luite_: I considered learning emacs at some point using Viper mode, but when I read about it I figured it would just piss me off.
20:05:56 <Axman6> implies addition, without messing up the Num class for +
20:06:01 <CakeProphet> -nod-
20:06:07 <mmorrow> , let (∈) = elem in 42 ∈ [0..]
20:06:09 <lunabot>  True
20:06:15 <Axman6> BeelsebobWork! oi!
20:06:25 <ddarius> length is a monoid homomorphism from the free monoid to the naturals.
20:06:33 <CakeProphet> what's unicode for sigma?
20:06:48 <Axman6> epsilon no?
20:07:02 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
20:07:03 <lambdabot>  Defined.
20:07:16 <CakeProphet> Axman6:  sigma is just sigma... but I don't have the symbol lying around to copypasta.
20:07:31 <ddarius> Σ σ
20:07:34 <CakeProphet> ah, found it
20:07:35 <CakeProphet> ...
20:07:36 <idnar> CakeProphet: uppercase is Σ, lowercase is σ / ς
20:07:48 <CakeProphet> thanks.
20:08:15 <Axman6> > let ∑ = sum in ∑ [1..100]
20:08:16 <lambdabot>   <no location info>: parse error on input `∑'
20:08:23 <Axman6> bah
20:08:33 <ddarius> Axman6: Σ would be a constructor anyway
20:08:44 <Axman6> CakeProphet: oh, i read what's as that's, my bad :)
20:08:45 <idnar> ddarius: nah, you can cheat
20:08:46 <mmorrow> @check \xs ys -> lengh (xs++ys) == length xs + length ys
20:08:46 <idnar> > let (∑) = sum in ∑ [1..100]
20:08:47 <lambdabot>   Not in scope: `lengh'
20:08:47 <Axman6> damn dyslexia
20:08:48 <lambdabot>   <no location info>: parse error on input `∑'
20:08:54 <idnar> oh, wrong sigma
20:09:00 <mmorrow> @check \xs ys -> length (xs++ys) == length xs + length ys
20:09:02 <lambdabot>   "OK, passed 500 tests."
20:09:02 <idnar> or, not
20:09:02 <idnar> hmm
20:09:04 <CakeProphet> @let (Σ) = sum
20:09:05 <lambdabot>  <local>:20:1: Not in scope: data constructor `�'
20:09:11 <CakeProphet> :o
20:09:14 <mmorrow> it's a letter
20:09:17 <idnar> @let (∑) = sum
20:09:19 <lambdabot>  Defined.
20:09:30 <idnar> > ∑ [1..100]
20:09:31 <lambdabot>   <no location info>: parse error on input `∑'
20:09:33 <mmorrow> , "Σ∑"
20:09:35 <lunabot>  "\931\8721"
20:09:39 <Axman6> hmm
20:09:41 <mmorrow> , fmap utf8enc "Σ∑"
20:09:42 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char]'
20:09:46 <idnar> oh duh
20:09:47 <Axman6> ∑ is opt-w on OS X
20:09:50 <mmorrow> , fmap (utf8enc . (:[])) "Σ∑"
20:09:53 <lunabot>  ["\206\163","\226\136\145"]
20:09:55 <idnar> > (∑ ) [1..100]
20:09:57 <lambdabot>   5050
20:10:00 <idnar> there we go
20:10:12 <CakeProphet> sigma would be like a combination of take and drop
20:10:14 <idnar> Σ is GREEK SMALL LETTER SIGMA, ∑ is N-ARY SUMMATION
20:10:15 <CakeProphet> and sum
20:10:24 <CakeProphet> because of the upper/lower bound parameters.
20:10:28 <bmh> good thing I have a sigma key on my keyboard
20:10:50 <Axman6> @let „ = (,,)
20:10:50 <lambdabot>   Illegal character ''\8222''
20:10:53 <Axman6> bah
20:11:03 <Axman6> @let π = pi
20:11:05 <lambdabot>  Defined.
20:11:12 <mmorrow> @let („) = (,,)
20:11:13 <lambdabot>   Illegal character ''\8222''
20:11:15 <Axman6> > π * 10 * 10
20:11:16 <lambdabot>   314.1592653589793
20:11:23 <Axman6> > π * 10 * 10 :: CReal
20:11:25 <lambdabot>   314.1592653589793238462643383279502884197169
20:11:36 <bmh> is & in use?
20:11:36 <mmorrow> heh, as obvious as that is, i don't think i've ever seen anyone do that
20:11:37 <idnar> huh, why is that illegal?
20:11:43 <mmorrow> (with pi)
20:11:44 <ddarius> bmh: No
20:11:56 <idnar> @type (&)
20:11:57 <Axman6> @hoogle &
20:11:57 <lambdabot> Not in scope: `&'
20:11:57 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
20:11:57 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
20:11:57 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
20:12:04 <mmorrow> @type (.&.)
20:12:05 <lambdabot>     Ambiguous occurrence `.&.'
20:12:05 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
20:12:05 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
20:12:05 <ddarius> mmorrow: I've seen it before multiple times.
20:12:06 <Olathe> > ([1..100]∑)
20:12:08 <lambdabot>   5050
20:12:25 * mmorrow gives ddarius a cookie
20:12:28 <mmorrow> ;)
20:12:59 <Olathe> > let ∑ _ x = sum x in (∑[1..100]) "zomg"
20:13:01 <lambdabot>   <no location info>: parse error on input `∑'
20:13:01 <idnar> , let („) = (,,) in („) 1 2 3
20:13:03 <lunabot>  luna: lexical error at character '\8222'
20:13:04 <Olathe> Bah.
20:13:12 <idnar> that operator wouldn't really be much use anyway
20:13:39 <idnar> 1 „ 2 3 is just plain weird :P
20:13:56 <Axman6> > 1 (,,) 2 3
20:13:57 <lambdabot>       No instance for (Num ((a -> b -> c -> (a, b, c)) -> t -> t1 -> a1))
20:13:57 <lambdabot>    ...
20:14:07 <Axman6> > 1 `(,,)` 2 3
20:14:08 <lambdabot>   <no location info>: parse error on input `('
20:14:13 <CakeProphet> what's sqrt in Haskell?
20:14:17 <Axman6> sqrt
20:14:18 <Olathe> > 1 ,, 2 3
20:14:19 <sjanssen> > srqt 1
20:14:20 <idnar> @type sqrt
20:14:20 <lambdabot>   <no location info>: parse error on input `,'
20:14:21 <CakeProphet> alright.
20:14:21 <lambdabot>   Not in scope: `srqt'
20:14:21 <lambdabot> forall a. (Floating a) => a -> a
20:14:38 <Olathe> > sqrt pi
20:14:40 <lambdabot>   1.7724538509055159
20:14:41 <CakeProphet> @let ϕ = (1 + sqrt 5) / 2
20:14:43 <lambdabot>  Defined.
20:14:49 <CakeProphet> > ϕ
20:14:51 <lambdabot>   1.618033988749895
20:15:04 <pumpkin> > let (,,) = (,,,) 666 in (5,4,5)
20:15:05 <lambdabot>       Constructor `(,,)' should have 3 arguments, but has been given 0
20:15:05 <lambdabot>      I...
20:15:26 <Olathe> You...
20:15:28 <pumpkin> > let (,,) a b c = (,,,) 666 a b c in (5,4,5)
20:15:28 <idnar> oh hell, why are there two PHIs?
20:15:29 <lambdabot>   Couldn't match expected type `(t, t1, t2)'
20:15:47 <pumpkin> :(
20:15:47 <idnar> ϕ is GREEK PHI SYMBOL, Φ is GREEK CAPITAL LETTER PHI
20:15:56 <pumpkin> idnar: unicode is weird :P
20:15:58 <sclv> > sqrt ϕ
20:16:00 <lambdabot>   1.272019649514069
20:16:10 <Axman6> :t (1,)
20:16:11 <lambdabot> parse error on input `)'
20:16:13 <sclv> > exp ϕ
20:16:14 <idnar> Dear Unicode, Whisky Tango Foxtrot
20:16:14 <lambdabot>   5.0431656433600285
20:16:28 <Olathe> ＷＴＦ
20:16:31 <sclv> I'm particularly fond of LAMDA
20:16:43 <Axman6> lambda?
20:16:46 <Olathe> Ｌｉｋｅ ｓｒｓｌｙ， ＷＴＦ ？
20:16:48 <bmh> sclv: I was just going to mention λ
20:16:49 <sclv> not in unicode it ain't.
20:17:09 <sjanssen> sclv: yeah, it makes it very hard to find in Unicode databases
20:17:25 <idnar> GREEK SMALL LETTER LAMDA
20:17:26 <Axman6> sclv: heh, indeed
20:17:26 <Olathe> Ｕｎｉｃｏｄｅ－－
20:17:30 <idnar> oh boy
20:17:33 <sclv> fascinating: http://www.danielmoth.com/Blog/2007/03/lambda-vs-lamda.html
20:17:56 <Axman6> λx → √x
20:18:32 <bmh> hey, if I could write haskell in LaTeX, I'd be happy with that
20:19:09 <idnar> sclv: I'm not sure I agree with his argument
20:19:15 <Axman6> sclv: interesting, i'll take note of that :)
20:19:32 <Axman6> bmh: like lhs?
20:19:34 <sclv> U+034F COMBINING GRAPHEME JOINER -- The name does not describe the function of this character. Despite its name, it does not join graphemes. For more infomation, see Section 7.9 Combining Marks, of the Unicode Standard.
20:19:37 <idnar> sclv: sure, "lambda" doesn't make sense as a transliteration, but it doesn't have to be a transliteration
20:19:38 <sclv> http://unicode.org/notes/tn27/
20:19:43 <Olathe> I like the keymapping argument.
20:19:55 <pumpkin> lol
20:20:00 <bmh> axman6: mhmm. I've never written anything long enough to make it worthwhile
20:20:02 <Cale> sclv: another strange thing is that we have a specific idea about what alpha looks like which they don't. Many of our lowercase a's are acceptable alphas to them.
20:20:30 <Cale> (I'm not certain about the ones with a 'hood' over them though)
20:20:44 <strht> hey cale
20:20:47 <strht> explain monads to me
20:20:48 <Cale> hey
20:20:51 <Cale> sure
20:20:53 <Axman6> heh
20:20:56 <ddarius> Cale: They don't have to distinguish their alpha from our as often as we have to do the opposite?
20:21:02 <idnar> heh, in this font Α and A render as the same glyph
20:21:04 <bmh> monads -- I'm all ears!
20:21:22 <Cale> ddarius: Well, perhaps in technical fields, but not elsewhere.
20:21:27 <luite_> sclv: hm, interestingly, 'lambda' can be spelled in dutch as 'labda', leaving out the wrong letter :)
20:21:46 <Cale> idnar: Not just the uppercase one
20:21:47 <ddarius> Cale: Elsewhere you don't see alpha at all.
20:21:56 * strht wakes up
20:21:59 <strht> huzzah
20:22:00 <Cale> ddarius: In Greek writing you do :)
20:22:06 <strht> what's a monad?
20:22:16 <idnar> Cale: yeah, I know what you meant, I just got momentarily confused when I copied the greek one in from elsewhere
20:22:37 <Cale> strht: A monad is a type constructor together with some functions -- a common sort of interface that comes along with it.
20:22:48 <ddarius> Cale: Greek writing doesn't (usually) also have English writing
20:22:50 <Olathe> A monad contains data. It lets you apply functions to the data in spiffy ways.
20:23:06 <strht> so it's a class?
20:23:11 <Olathe> Each monad applies functions a bit differently.
20:23:17 <Cale> ddarius: But in Greek typefaces, lowercase alpha doesn't always look like a fish.
20:23:21 <strht> an ultra-mega-class
20:23:30 <Cale> strht: It's a particular class, yes.
20:23:31 <Axman6> sclv: no, just a class
20:23:36 <Cale> strht: (in Haskell)
20:23:52 <ddarius> Cale: That's fine.  Greek typefaces aren't designed to distinguish themselves from English ones.
20:24:31 <Cale> ddarius: Yes, it's just confusing for Greek mathematics students in an English environment where we distinguish lowercase alpha from lowercase a.
20:25:03 <Cale> strht: Sorry for the interruption :)
20:25:10 <ddarius> Cale: it would be confusing to English mathematics students in a Greek enviroment where they wouldn't.
20:25:25 <CakeProphet> what's cube root in Haskell?
20:25:31 <Cale> strht: Okay... so there are a number of equivalent ways I can define this interface for you. Do you happen to already know how IO works in Haskell?
20:25:35 <ddarius> ^^(1/3)
20:25:36 <Axman6> x**(1/3)
20:25:36 <bmh> x ** 1/3
20:25:42 <CakeProphet> ...oh rite.
20:25:47 <Cale> ddarius: that too
20:25:49 <ddarius> I guess it would be **
20:25:58 <strht> i know that iO works through the IO monad ;)
20:26:06 * bmh high-fives all around
20:26:20 <strht> let's take this to #haskell-overflow
20:26:22 <pumpkin> :t (^^)
20:26:23 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:26:23 <Cale> strht: Well, yeah, it helps to know some examples of monads before you learn about the general interface.
20:26:25 <strht> where the candy is sweeter
20:26:34 <strht> and the sun sets on both hands in the molten gold
20:27:05 <BMeph> Cale: Just curious, but did you have an answer for the Q I asked about lists & stacks? :)
20:27:17 <Cale> strht: Because it really is just a general interface to a bunch of libraries, and it's rather abstract and hard to describe what all these libraries have in common. You'll hear people say things like that they're all "types of computations", but unless you already know what a monad is, that doesn't help.
20:27:25 <Cale> BMeph: I didn't see that question...
20:27:57 <Cale> BMeph: Or I don't remember it...
20:28:35 <Cale> strht: Okay, so I'll define what functions are part of the interface, and then we can look at some examples.
20:28:53 <Cale> class Monad m where
20:28:57 <Cale>   return :: a -> m a
20:29:11 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
20:29:24 <CakeProphet> @let ρ = (1/2 + 1/6*(23/3)**(1/2))**(1/3) + (1/2 - 1/6*(23/3)**1/2)**(1/3)
20:29:26 <lambdabot>  Defined.
20:29:29 <CakeProphet> > ρ
20:29:30 <lambdabot>   NaN
20:29:34 <CakeProphet> ...
20:29:51 <Cale> The latter operation is called bind. Its type is a bit much to take in all at once perhaps, but as you see examples, it'll get simpler to understand.
20:29:59 <strht> so >>= takes a monad with a as an argument
20:30:05 <strht> turns it into a function that takes a as an argument
20:30:09 <Cale> The monad here is m itself.
20:30:13 <Cale> (that is, the type constructor)
20:30:14 <strht> and turns that into a monad that takes b as the argument?
20:30:30 <strht> did i get that correctly
20:30:33 <Cale> Values of type m a are called m actions, or m computations, or values typed in m
20:31:00 <Axman6> > ρ :: CReal
20:31:01 <lambdabot>   * Exception: log of negative number
20:31:07 <Axman6> :O
20:31:10 <idnar> s
20:31:12 <idnar> oops
20:31:16 <ddarius> t
20:31:18 <strht> i don't understand
20:31:19 <CakeProphet> ....I didn't even use log...
20:31:25 <ddarius> CakeProphet: Sure you did.
20:31:28 <Cale> You tend to think of the 'a' as the type of value which the computation produces as a result, or that the "container" (for sufficiently flexible notions of container) contains.
20:31:43 <Axman6> CakeProphet: the computation would have though
20:31:50 <strht> what does it contain
20:32:20 <Cale> strht: Well, the type constructor for lists, [] (not the empty list), is a monad.
20:32:36 <CakeProphet> strht:  for example [1] is a List Int monad.
20:32:37 <Cale> With that monad, we have  return :: a -> [a]
20:32:41 <Cale> no!
20:32:44 <Cale> [1] is not a monad
20:32:47 <CakeProphet> ...er.
20:32:50 <CakeProphet> right.
20:32:50 <Axman6> heh
20:32:58 <Axman6> monoid?
20:32:59 <CakeProphet> but it is a List Int.
20:33:00 <Cale> Axman6 gets this wrong often.
20:33:03 <idnar> [] is the monad
20:33:03 <Cale> ;)
20:33:08 <Axman6> i do?
20:33:13 <Cale> The type constructor for lists is a monad.
20:33:14 <bmh> monoid? metroid?
20:33:15 <pumpkin> > ρ :: Complex CReal
20:33:16 <strht> so [] is the type constructor for lists
20:33:23 <strht> yes?
20:33:27 <Axman6> Cale: is [1] a monoid?
20:33:28 <Cale> yeah
20:33:28 <bmh> has anyone used galois's fs?
20:33:30 <lambdabot>   thread killed
20:33:31 <Cale> [] t = [t]
20:33:35 <strht> and the monad contains [] and
20:33:40 <strht> ...
20:33:48 <strht> > [] t
20:33:50 <lambdabot>   Couldn't match expected type `Expr -> t'
20:33:57 <strht> @let this = 6
20:33:58 <Cale> This is at the type level
20:34:00 <lambdabot>  Defined.
20:34:02 <strht> > [] this
20:34:03 <Cale> Not the value level.
20:34:04 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
20:34:08 <Cale> A monad is a type level thing
20:34:14 <Cale> > [1,2,3] :: [] Integer
20:34:16 <lambdabot>   [1,2,3]
20:34:16 <strht> show me with lambdabot
20:34:21 <Cale> :k []
20:34:23 <lambdabot> * -> *
20:34:25 <Cale> :k [] Integer
20:34:26 <Axman6> strht: what you're after would be (:[]) btw
20:34:27 <lambdabot> *
20:34:42 <Cale> So [] is a type constructor, and [] Integer, usually written [Integer], is a type.
20:34:51 <Cale> Perhaps Maybe would be an easier example
20:34:59 <Cale> (because it has less special syntax)
20:35:04 <Cale> Maybe is a monad
20:35:05 <Axman6> agreed
20:35:14 <Axman6> sure this isn't better in #haskell-overflow ?
20:35:21 <ddarius> @google matroid
20:35:24 <lambdabot> http://en.wikipedia.org/wiki/Matroid
20:35:24 <lambdabot> Title: Matroid - Wikipedia, the free encyclopedia
20:35:26 <strht> everythin is better in #haskell-overflow
20:35:26 <Cale> Axman6: Forgive me if it's not you who gets it wrong -- someone with an A... ;)
20:35:31 <Cale> okay
20:36:08 <pumpkin> holy crap, http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0198568614 is expensive
20:36:33 <ddarius> pumpkin: I've seen much worse.
20:36:36 <bmh> pumpkin: you haven't been in college for a while, have you?
20:36:38 <pumpkin> me too
20:36:45 <pumpkin> bmh: oh, I am currently :P
20:37:00 <bmh> pumpkin: you must take a lot of cs courses without books ;)
20:37:33 <bmh> I made it though algorithms and models of computation on library books.
20:37:34 <pumpkin> bmh: oh, I've spent lots of money on books, but it's still rather expensive :P
20:37:59 <chrisdone> anyone got a page about why a left-associative $ would be better?
20:38:20 <idnar> Axman6: [1] isn't a monoid, but [Integer] is one
20:39:05 <Axman6> i see
20:40:39 <luite_> pumpkin: there is a PDF of that book
20:40:41 <Axman6> http://blog.tmorris.net/haskell-exercises-for-beginners/ hooray :)
20:40:44 <pumpkin> luite_: I know :)
20:41:03 <pumpkin> luite_: that's what made me look for the dead tree version
20:41:14 <bmh> what's worse than textbooks is journal articles.
20:41:20 <luite_> pumpkin: ah, I just use the pdf
20:41:55 <luite_> pumpkin: maybe I'll buy it once I'm rich and famous (rich being the most important factor) :P
20:41:57 <pumpkin> bmh: thankfully I get them for free
20:42:25 <bmh> pumpkin: well, we don't get them for free. our university site licenses get them :-\
20:42:45 <pumpkin> bmh: yeah :P
20:49:18 <paynito> Prelude> boomBangs xs = [if x <10 then "BOOM!" else "BANGo" | x <- xs, odd x]
20:49:20 <paynito> <interactive>:1:13: parse error on input `='
20:49:22 <paynito> what's wrong with me?
20:49:41 <blackdog> hey. almost certain i've done something stupid, but when i do ghc-pkg list, i get ghc and Cabal listed in parentheses. 'sudo ghc-pkg expose ghc' doesn't seem to change anything, and i can't install packages because they complain that ghc isn't there. any ideas?
20:50:29 <Olathe> > let boomBangs xs = [if x <10 then "BOOM!" else "BANGo" | x <- xs, odd x] in boomBangs [1..10]
20:50:31 <lambdabot>   ["BOOM!","BOOM!","BOOM!","BOOM!","BOOM!"]
20:50:38 * Olathe dies.
20:50:57 <Olathe> paynito: You need let
20:51:15 <blackdog> paynito: but that form's fine if you're defining it in a source file.
20:51:22 <Olathe> Prelude> let boomBangs xs = [if x <10 then "BOOM!" else "BANGo" | x <- xs, odd x]
20:51:28 <paynito> thank you
20:51:33 <Olathe> You're welcome.
20:51:43 <Axman6> woah, big storm brewing here
20:52:35 <paynito> any short reason why haskell is "better" than LISP ?
20:53:10 <pumpkin> no
20:53:12 <blackdog> paynito: static typing helps you model things correctly in some domains, but quite often you want different tools for different tasks
20:53:33 <Olathe> I like Haskell's laziness.
20:53:44 * blackdog likes the fact that it's almost impossible to start a religious war in #haskell
20:53:51 <Olathe> Plus, ghc uses GMP for fast integer stuff.
20:54:03 <Olathe> But Lisp is decent enough.
20:54:24 <paynito> that makes some sense, so Integers won't become strings behind my back
20:54:38 <Olathe> Yeah, they won't.
20:54:58 <ddarius> Neither any of the (modern) lisps nor Haskell is tcl.
20:57:59 <Axman6> paynito: wow... languages do that? o.O
20:58:12 <paynito> I came across the word laziness yesterday talking about reg. exp. in perl
20:59:40 <redditbot> Haskell exercises for beginners
20:59:49 <paynito> i was just wondering what not-static typing would be and guessing, I just started learning programming maybe 3 wks ago, i'm real week on the theory
21:00:53 <idnar> Axman6: JavaScript is especially awful about that
21:01:19 <idnar> Axman6: for example, == coerces both arguments to a string and then compares them
21:01:38 <Axman6> idnar: i'd hope they don't do that these days. i'd expect things like SquirrelFish Extreme would use machine numbers etc
21:01:49 <Axman6> idnar: dear god :(
21:01:58 <idnar> Axman6: they can't change the language specification without breaking everything
21:02:12 <Axman6> hmm
21:02:12 <idnar> Axman6: I mean, they can do whatever they want behind the scenes, obviously, but they have to provide the same semantics
21:02:20 <Axman6> well yeah
21:02:34 <idnar> anyhow, so "5" + "5" is "55"
21:02:46 <idnar> so is "5" + 5 and 5 + "5"
21:02:47 <idnar> but % + 5 is 25
21:02:50 <idnar> er, 5 + 5
21:03:54 <idnar> and it gets even more fun than that
21:04:04 <idnar> [1,2,3] + 4 is "1,2,34"
21:04:10 <pumpkin> wait, 5 +5 is 25?
21:04:14 <pumpkin> their language is seriously fucked
21:04:17 <idnar> pumpkin: er, sorry, 10
21:04:18 <pumpkin> :P
21:04:34 <idnar> pumpkin: it's just my mental arithmetic that's seriously fscked :P
21:04:52 <idnar> another fun one
21:04:57 <pumpkin> :)
21:05:05 <idnar> Array("foo") is ["foo"]
21:05:11 <idnar> Array(1, 2, 3) is [1, 2, 3]
21:05:24 <idnar> but Array(4) is [undefined, undefined, undefined, undefined]
21:05:32 <pumpkin> lol
21:05:37 <pumpkin> that's cringeworthy
21:05:54 <idnar> anyhow, I guess that sort of thing is usually called "weak typing"
21:06:40 <idnar> you've got types at runtime, but coercion between types happens at the drop of a hat, silently, behind your back
21:06:51 <idnar> whereas, for example, "5" + 5 or [1,2,3] + 4 raise a TypeError exception in Python
21:08:01 <Axman6> idnar: Array(4) is [undefined, undefined, undefined, undefined] <<-- disgusting
21:08:25 <centrinia> Maybe there is an (+) :: (Integral a) => String -> a -> a or (+) :: (Integral a) => [a] -> a -> a
21:08:48 * centrinia has no idea what type ([1,2,3] + 4) is supposed to be.
21:11:28 <idnar> oh, I can't resist a few more examples
21:11:29 <Axman6> centrinia: well, couldn't match the type of (+) in haskell at least
21:12:26 <idnar> null + "" is "null", undefined + "" is "undefined", but null == undefined is true
21:13:16 <idnar> then null + null is 0, undefined + undefined is NaN
21:13:26 <Axman6> jesus christ man
21:13:32 <Axman6> i'm gonna have nightmares :(
21:13:41 <idnar> and of course, [1,2,3] + undefined is "1,2,3undefined"
21:14:06 <CakeProphet> ?src putStrLn
21:14:06 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
21:14:10 <idnar> writing JavaScript code is (part of) what I do for a living, so you can imagine what *my* nightmares are like :(
21:14:17 <CakeProphet> ?src putStr
21:14:18 <lambdabot> putStr s  = hPutStr stdout s
21:14:28 <CakeProphet> ?src hPutStr
21:14:28 <lambdabot> Source not found. Take a stress pill and think things over.
21:14:38 <CakeProphet> psh.
21:15:12 <CakeProphet> idnar, ew....
21:17:09 <CakeProphet> ?src stdout
21:17:09 <lambdabot> Source not found. Are you on drugs?
21:17:16 <CakeProphet> :t stdout
21:17:17 <lambdabot> Not in scope: `stdout'
21:17:29 <centrinia> ?src putStrLn
21:17:30 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
21:17:30 <idnar> [1] == 1 is true, [1,2] == "1,2" is true, but [1,2,3] == [1,2,3] is false, although x = [1,2,3]; x == x is true
21:17:46 <Olathe> @src putStr
21:17:46 <lambdabot> putStr s  = hPutStr stdout s
21:17:53 <Olathe> @src hPutStr
21:17:54 <lambdabot> Source not found. Just try something else.
21:19:09 <idnar> > mzero :: Maybe t -- for CakeProphet
21:19:11 <lambdabot>   Nothing
21:19:35 <CakeProphet> ?src mzero
21:19:35 <lambdabot> Source not found. There are some things that I just don't know.
21:19:35 <idnar> of course, that only works for MonadPlus instances
21:19:43 <CakeProphet> ?src MonadPlus
21:19:43 <lambdabot> Source not found. Where did you learn to type?
21:19:44 <idnar> @type mzero
21:19:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
21:19:49 <idnar> it's a method of MonadPlus
21:20:00 <idnar> > mzer :: [t]
21:20:01 <lambdabot>   Not in scope: `mzer'
21:20:02 <idnar> argh
21:20:02 <Olathe> > just 5
21:20:04 <lambdabot>   Nothing
21:20:05 <CakeProphet> is MonadPlus just extension functions formonads?
21:20:10 <idnar> > mzero :: [t]
21:20:11 <lambdabot>   []
21:20:28 <idnar> CakeProphet: it adds mzero and mplus
21:20:31 <Olathe> > map just [1..10]
21:20:33 <lambdabot>   [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,No...
21:20:42 <idnar> > Just 5 `mplus` Just 10
21:20:43 <lambdabot>   Just 5
21:20:54 <idnar> > Nothing `mplus` Just 10
21:20:55 <lambdabot>   Just 10
21:21:02 <CakeProphet> hmmm... what does mplus do.
21:21:09 <Olathe> @src mpluc
21:21:09 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:21:10 <Olathe> @src mplus
21:21:11 <paynito> is there an equiv. of Perl's qw/jon mary sam/ = ["jon", "mary", "sam"] ?
21:21:11 <lambdabot> Source not found.
21:21:19 <idnar> CakeProphet: that depends on the monahd
21:21:22 <Olathe> @src Maybe mplus
21:21:23 <lambdabot> Nothing `mplus` ys = ys
21:21:23 <lambdabot> xs      `mplus` ys = xs
21:21:26 <idnar> CakeProphet: there's also some controversy
21:21:37 <CakeProphet> idnar: what is it in general supposed to do?
21:21:37 <Olathe> @src [] mplus
21:21:38 <lambdabot> mplus = (++)
21:21:44 <idnar> CakeProphet: there are (at least) two different answers to that question
21:22:03 <CakeProphet> idnar:  hmmm... can you give me some specific results. I can't figure out what mplus does for Maybe.
21:22:11 <idnar> CakeProphet: so some people think there should be a MonadZero typeclass with just mzero, and then two other type classes for the two "kinds" of mplus
21:22:36 <idnar> CakeProphet: mplus for Maybe is a kind of "failure avoidance"
21:23:09 <pumpkin> "but wait, don't fail, try this first!"
21:23:09 <centrinia> > get `mplus` char 'a'
21:23:11 <lambdabot>   Couldn't match expected type `m a' against inferred type `Doc'
21:23:33 <centrinia> > mzero :: ReadP
21:23:35 <lambdabot>   Not in scope: type constructor or class `ReadP'
21:23:36 <pumpkin> @let unseq = flip seq
21:23:38 <lambdabot>  Defined.
21:23:43 <pumpkin> that's useful one
21:23:46 <centrinia> :t unseq
21:23:48 <lambdabot> forall b a. b -> a -> b
21:23:54 <idnar> CakeProphet: if we have a Just x value on the left, then we keep that; if we have Nothing, then we try the right-hand side instead
21:24:03 <CakeProphet> ah.
21:24:05 <idnar> > Nothing `mplus` Nothing `mplus` Nothing
21:24:07 <lambdabot>   Nothing
21:24:08 <centrinia> > unseq (1+2) 3
21:24:10 <lambdabot>   3
21:24:15 <idnar> > Nothing `mplus` Nothing `mplus` Just 5
21:24:16 <lambdabot>   Just 5
21:24:18 <centrinia> That is useful. :)
21:24:20 <idnar> > Nothing `mplus` Just 10 `mplus` Just 5
21:24:22 <lambdabot>   Just 10
21:24:25 <idnar> so, that's the one kind of mplus
21:24:26 <CakeProphet> idnar:  ah... useful for recursive definitions... like find(Index)
21:24:40 <pumpkin> centrinia: I like your example :P
21:24:42 <idnar> the other kind of mplus is the one we see in []
21:24:48 <pumpkin> centrinia: really makes it clear
21:24:52 <pumpkin> :D
21:24:52 <idnar> > [1,2] `mplus` [5,6]
21:24:54 <lambdabot>   [1,2,5,6]
21:25:02 <idnar> which is a sort of "concatenation"
21:25:04 <CakeProphet> ++?
21:25:14 <idnar> for lists, it's ++
21:25:24 <CakeProphet> that's two completely different semantic qualities there.
21:25:50 <nj32> attempting to use module `Prelude' (Prelude.hs) which is not loaded. Failed, modules loaded: none.
21:25:57 <CakeProphet> idnar:  does IO define mplus?
21:26:07 <nj32> that is what i get when i load a haskell file on ghci
21:26:09 <Axman6> @instances MonadPlus
21:26:09 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
21:26:09 <idnar> CakeProphet: nope
21:26:13 <idnar> oh
21:26:24 <idnar> where the heck does that instance come from?
21:26:39 <Axman6> nj32: are you trying to import Prelude?
21:26:40 <pumpkin> magick
21:26:57 <nj32> Axman6: no, i just wrote a function in the .hs file
21:26:58 <idnar> Control.Monad.Error, apparently
21:27:30 <idnar> anyhow, it's similar to the Maybe instance
21:27:40 <nj32> Axman6: and i was loading it into ghci with :l file.hs
21:27:41 <CakeProphet> except with IO () instead of Nothing?
21:27:51 <idnar> CakeProphet: well, no, it's IO a
21:27:59 <idnar> > mzero :: IO a
21:28:00 <lambdabot>   Add a type signature
21:28:03 <CakeProphet> right
21:28:03 <idnar> > mzero :: IO Integer
21:28:05 <lambdabot>   * Exception: "<IO Integer>"
21:28:09 <idnar> oh, that won't help
21:28:12 <mmorrow> @src MonadPlus
21:28:12 <lambdabot> Source not found. Sorry.
21:28:17 <idnar> but mzero is "Exception: user error" or something
21:28:26 <CakeProphet> basically, with the failure check version of mplus
21:28:26 <mmorrow> , src ''MonadPlus
21:28:39 <lunabot>  class (Monad m) => MonadPlus m where
21:28:39 <lunabot>          mzero :: forall a . m a
21:28:39 <lunabot>          mplus :: forall a . m a -> m a -> m a
21:28:47 <CakeProphet> if the monad on the left is the thing produced by mzero for that monad, then it returns the one on the right, unless it's also mzero
21:29:00 <mmorrow> , [0..4] `mplus` [5..9]
21:29:03 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
21:29:03 <idnar> CakeProphet: [] or IO or whatever is the monad, the thing on the left is a value
21:29:07 <idnar> CakeProphet: but yeah
21:29:11 <mmorrow> , mzero :: [a]
21:29:13 <lunabot>  []
21:29:20 <CakeProphet> idnar:  er, right.
21:29:23 <mmorrow> , mzero :: Maybe a
21:29:26 <lunabot>  Nothing
21:29:48 <idnar> CakeProphet: I can't remember the proposed names for the separated typeclasses / functions
21:29:54 <pumpkin> > Left 5 `mplus` Right 4
21:29:56 <lambdabot>   Add a type signature
21:29:57 <CakeProphet> idnar:  hmmm, I could see why there should be two different versions of mplus.
21:30:03 <mmorrow> @src IO mplus
21:30:03 <lambdabot> m `mplus` n = m `catch` \_ -> n
21:30:08 <mmorrow> @src IO mzero
21:30:08 <lambdabot> mzero       = ioError (userError "mzero")
21:30:18 <Olathe> @type Left 5
21:30:20 <lambdabot> forall t b. (Num t) => Either t b
21:30:30 <idnar> CakeProphet: I think the idea was to keep calling the list version MonadPlus
21:30:42 <Olathe> > Left 5 `mplus` Right 4 :: Either Int Int
21:30:43 <lambdabot>       No instance for (Error Int)
21:30:43 <lambdabot>        arising from a use of `mplus' at <in...
21:30:52 <idnar> CakeProphet: but call the other one MonadOr, and the function morelse
21:30:57 <Olathe> > Left 5 `mplus` Right "FOUR !"
21:30:58 <lambdabot>   Add a type signature
21:31:07 <Olathe> > Left 5 `mplus` Right "FOUR !" :: Either Int String
21:31:09 <lambdabot>       No instance for (Error Int)
21:31:09 <lambdabot>        arising from a use of `mplus' at <in...
21:31:17 <pumpkin> ah yeah
21:31:19 <pumpkin> that's the failmplus
21:31:25 <mmorrow> the IO MonadPlus instance doesn't really follow the "rules" it's supposed to
21:31:26 <CakeProphet> is Either a monad too?
21:31:29 <pumpkin> that assumes that Either always gives Error
21:31:29 <Olathe> > Left "FIVE !" `mplus` Right 4 :: Either String Int
21:31:30 <idnar> > Left "FOUR !" `mplus` Right 5 :: Either Int String
21:31:31 <lambdabot>   Right 4
21:31:32 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
21:31:33 <mmorrow> maybe by a technicality
21:31:42 <idnar> CakeProphet: it is, but the instance is stupid
21:31:52 <CakeProphet> oh lawd
21:31:59 <idnar> CakeProphet: well, actually, Either isn't a monad (wrong kind), but Either a could be
21:32:11 <idnar> CakeProphet: but the instance is only defined for (Error a) => Either a
21:32:16 <CakeProphet> :k Either
21:32:17 <lambdabot> * -> * -> *
21:32:22 <Olathe> Lefty losee Righty winnee
21:32:28 <CakeProphet> :k Right
21:32:29 <lambdabot> Not in scope: type constructor or class `Right'
21:32:33 <mmorrow> :k (->)
21:32:34 <lambdabot> ?? -> ? -> *
21:32:36 <CakeProphet> :k Either a
21:32:37 <lambdabot> Not in scope: type variable `a'
21:32:45 <idnar> CakeProphet: basically, it's the same as Maybe
21:32:49 <CakeProphet> what is ->
21:32:54 <mmorrow> a -> b
21:32:57 <CakeProphet> idnar:  ah okay.
21:32:57 <idnar> CakeProphet: except that Just x is Right x
21:33:01 <idnar> CakeProphet: and Nothing is Left x
21:33:01 <CakeProphet> -nod-
21:33:06 <idnar> CakeProphet: (so you can describe the "failure")
21:33:17 <mmorrow> Either () a === Maybe a
21:33:20 <CakeProphet> right. I know how Maybe works, just wonder if it defined return and bind.
21:33:23 <CakeProphet> *wondering
21:33:28 <mmorrow> Maybe () === Bool
21:33:34 <idnar> CakeProphet: (->) is the kind of type functions
21:33:49 <idnar> er
21:33:54 <idnar> not the kind
21:33:55 <mmorrow> @type undefined :: (->) a b
21:33:56 <lambdabot> forall a b. a -> b
21:34:06 <idnar> let me try that again
21:34:06 <mmorrow> it's the type constructor for functions
21:34:16 <idnar> what mmorrow said
21:34:23 <CakeProphet> ...aaaah
21:34:25 <mmorrow> like [] or Maybe
21:34:39 <CakeProphet> so the -> technically isn't special type syntax
21:34:43 <CakeProphet> it's a constructor.
21:34:43 <idnar> I can never remember what ?? and ? are, but they're * + some unboxed stuff
21:35:05 <mmorrow> [] might be slightly misleading though, since [] is also one of the data constructors for the ([] a) type
21:35:07 <idnar> CakeProphet: it's sort of special, kinda like (:) is special
21:35:19 <CakeProphet> how is : special?
21:35:30 <mmorrow> just in that you can't redefine it
21:35:32 <ddarius> CakeProphet: It's also a kind constructor, but in this case, there is nothing special about it except that it is built in.
21:35:43 <mmorrow> , let (:) = (+) in 4 : 5
21:35:44 <lunabot>  luna: Constructor `:' should have 2 arguments, but has been given 0
21:35:47 <CakeProphet> ah
21:35:48 <idnar> CakeProphet: it's part of the language syntax
21:36:02 <idnar> CakeProphet: conceptually isn't not really special, though
21:36:08 <idnar> *it's
21:36:19 <mmorrow> likewise with () (,) (,,) (,,,) ...
21:36:21 <CakeProphet> can you do anything neat with ->?
21:36:28 <CakeProphet> other than making type signatures.
21:36:29 <mmorrow> , let () = 42 in ()
21:36:31 <lunabot>  luna: No instance for (GHC.Num.Num ())
21:36:40 <idnar> @kind (->) Integer
21:36:42 <lambdabot> ? -> *
21:37:04 <mmorrow> CakeProphet: not really (that i can think of)
21:37:07 <idnar> CakeProphet: (->) r is a monad :)
21:37:12 <CakeProphet> oh lawd
21:37:12 <idnar> CakeProphet: does that count?
21:37:18 <CakeProphet> the question is what /isn't/ a monad.
21:37:27 <mmorrow> (->)
21:37:32 <Olathe> I am not a monad !
21:37:42 <mmorrow> since a monad has kind * -> *
21:37:46 <CakeProphet> Olathe: I bet in some abstract way you are.
21:37:46 <idnar> CakeProphet: anything that's not of type * -> * isn't a monad :P
21:37:49 <Gracenotes> Olathe: but you contain monads!
21:37:49 <Olathe> Be seeing you.
21:37:52 <idnar> CakeProphet: er, of kind
21:37:57 <Gracenotes> everyone has monads, in the chemical sense
21:38:04 <CakeProphet> Gracenotes:  oh lawd.
21:38:05 <Olathe> Gracenotes: Yes, but those are private.
21:38:10 <idnar> CakeProphet: the (->) r monad is great for all sorts of pointfree fun
21:38:20 <pumpkin> @kind (Ord a) => a -> a
21:38:21 <lambdabot> *
21:38:34 <CakeProphet> a function that takes type r as input is a monad?
21:38:43 <Olathe> > ((+) >>= (*)) 4
21:38:44 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
21:38:44 <lambdabot>        Exp...
21:38:48 <Olathe> Lies !
21:38:52 <Olathe> > ((+5) >>= (*)) 4
21:38:54 <lambdabot>   36
21:39:05 <idnar> CakeProphet: yeah
21:39:08 <Olathe> > ((+5) >>= (*) >>= subtract) 4
21:39:10 <lambdabot>   -32
21:39:14 <CakeProphet> oh lawd
21:39:16 <idnar> @src (>>=) (->) r
21:39:16 <lambdabot> Source not found. That's something I cannot allow to happen.
21:39:20 <CakeProphet> that's ridiculous
21:39:22 <idnar> @src (>>=) (r ->)
21:39:22 <lambdabot> Source not found. It can only be attributed to human error.
21:39:24 <idnar> bleh
21:39:30 <idnar> > join (*) 5
21:39:31 <lambdabot>   25
21:39:34 <Olathe> @src (->) (>>=)
21:39:34 <lambdabot> f >>= k = \ r -> k (f r) r
21:39:35 <mmorrow> @src (->e) (>>=)
21:39:35 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:39:37 <Axman6> @src ((->) a) (>>=)
21:39:37 <lambdabot> Source not found. :(
21:39:41 <idnar> Olathe: ah, thanks
21:39:43 <CakeProphet> I'm pretty sure you could make any * -> * into a monad and no one would complain
21:39:44 <Olathe> -> is a weird monad.
21:39:48 <mmorrow> @src (->) return
21:39:48 <lambdabot> return = const
21:39:49 <idnar> although that definition is really confusing
21:40:15 <Gracenotes> @type ((+5) >>=)
21:40:16 <lambdabot> forall a b. (Num a) => (a -> a -> b) -> a -> b
21:40:34 <Axman6> :t h f k = \ r -> k (f r) r
21:40:35 <lambdabot> parse error on input `='
21:40:45 <Axman6> :t h f k = \ r -> k (f r) r in h
21:40:46 <lambdabot> parse error on input `='
21:40:51 <Axman6> :t let h f k = \ r -> k (f r) r in h
21:40:52 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
21:41:00 <Olathe> @type \h f k r -> k (f r) r in h
21:41:02 <lambdabot> parse error on input `in'
21:41:03 <Gracenotes> so it's like a fold of sorts. in a sense.
21:41:05 <CakeProphet> Olathe:  are there any normal monads?
21:41:15 <Olathe> [] and Maybe are nice.
21:41:18 <mmorrow> @type (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
21:41:19 <lambdabot> forall e a b. (e -> a) -> (a -> e -> b) -> e -> b
21:41:25 <ddarius> Olathe: How is (r->) weird?
21:41:27 <Olathe> -> just sort of applies the argument over and over and over.
21:41:35 <CakeProphet> hmmm
21:41:52 <CakeProphet> > (5+) >>= subtract
21:41:54 <lambdabot>       Overlapping instances for Show (t -> t)
21:41:54 <lambdabot>        arising from a use of `s...
21:41:55 <Olathe> > ((+4) >>= (+) >>= (+)) 4
21:41:57 <lambdabot>   16
21:41:58 <mmorrow> @src (->) Functor
21:41:58 <lambdabot> Source not found. Sorry.
21:42:02 <CakeProphet> > ((5+) >>= subtract) 3
21:42:03 <Olathe> > ((+4) >>= (+) >>= (+)) a
21:42:04 <lambdabot>   -5
21:42:05 <lambdabot>   a + 4 + a + a
21:42:06 <mmorrow> @src (->e) Functor
21:42:06 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:42:14 <CakeProphet> ...that's weird.
21:42:15 <Olathe> > ((+a) >>= (*) >>= subtract) a
21:42:17 <lambdabot>   a - (a + a) * a
21:42:22 <Olathe> > ((+b) >>= (*) >>= subtract) a
21:42:24 <lambdabot>   a - (a + b) * a
21:42:27 <pumpkin> -> is what allows us to do join on (+) and (*), right?
21:42:36 <Olathe> I think so.
21:42:42 <idnar> pumpkin: yeah
21:42:42 <xEpicFailGuyx> @src showList
21:42:43 <lambdabot> Source not found. Just try something else.
21:42:49 <Olathe> @src join
21:42:49 <lambdabot> join x =  x >>= id
21:42:50 <idnar> @unpl join f
21:42:50 <lambdabot> (f >>= \ a -> a)
21:42:52 <CakeProphet> > ((5+) >>= (/)) 3
21:42:53 <lambdabot>   2.6666666666666665
21:42:54 <idnar> oops
21:42:58 <CakeProphet> I don't understand that.
21:42:59 <pumpkin> @src (->) (>>=)
21:42:59 <lambdabot> f >>= k = \ r -> k (f r) r
21:43:03 <CakeProphet> > ((5+) >>= (subtract)) 2
21:43:05 <lambdabot>   -5
21:43:12 <Olathe> > ((a+) >>= (/)) b
21:43:14 <lambdabot>   (a + b) / b
21:43:15 <mmorrow> , (3 + 5) / 3
21:43:16 <pumpkin> aha, now it makes sense
21:43:16 <CakeProphet> > map ((5+) >>= (subtract)) [1..10]
21:43:17 <lunabot>  2.6666666666666665
21:43:18 <lambdabot>   [-5,-5,-5,-5,-5,-5,-5,-5,-5,-5]
21:43:30 <idnar> @type join :: (r -> a -> a) -> (r -> a)
21:43:31 <lambdabot>     Couldn't match expected type `a' against inferred type `r'
21:43:31 <lambdabot>       `a' is a rigid type variable bound by
21:43:31 <lambdabot>           the polymorphic type `forall r a. (r -> a -> a) -> r -> a'
21:43:35 <idnar> @type join :: (r -> r -> a) -> (r -> a)
21:43:36 <lambdabot> forall r a. (r -> r -> a) -> r -> a
21:43:37 <CakeProphet> so it disregards input and applies subtract to 5?
21:43:39 <Gracenotes> > ((3:) >>= (:)) []
21:43:40 <pumpkin> > join (^) 11
21:43:41 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
21:43:42 <lambdabot>        Expect...
21:43:42 <lambdabot>   285311670611
21:43:45 <Gracenotes> hm.
21:43:45 <CakeProphet> > map ((5+) >>= (+)) [1..10]
21:43:46 <idnar> CakeProphet: you're confusing subtract with negate
21:43:47 <Olathe> CakeProphet: Nope.
21:43:47 <lambdabot>   [7,9,11,13,15,17,19,21,23,25]
21:44:04 <Olathe> > ((a+) >>= (subtract)) b
21:44:06 <lambdabot>   b - (a + b)
21:44:11 <idnar> CakeProphet: it first applies (5+) to the input
21:44:11 <Olathe> It does that, which gives -a
21:44:12 <Axman6> > join (^) 100
21:44:13 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
21:44:15 <idnar> CakeProphet: that gives us 8
21:44:16 <CakeProphet> ah
21:44:23 <CakeProphet> it applies b to both functions
21:44:27 <idnar> CakeProphet: it then applies subtract to the input, and the previous result
21:44:47 <idnar> er, other way around
21:44:49 <mmorrow> it does   f >>= k ===> \x -> (k (f x))  x
21:44:58 <idnar> wait
21:45:02 <idnar> > 5 `subtract` 10
21:45:03 * Olathe waits.
21:45:03 <lambdabot>   5
21:45:11 <CakeProphet> ...wat.
21:45:17 <Olathe> subtract is backwards.
21:45:20 <Olathe> @src subtract
21:45:20 <lambdabot> subtract x y = y - x
21:45:21 <CakeProphet> oh
21:45:29 <CakeProphet> oh
21:45:30 <idnar> okay, right, it applies subtract to the previous result, and the input
21:45:35 <CakeProphet> "subtract 5 from 10" is how it reads.
21:45:36 <Olathe> It makes subtract work like (+)
21:45:40 <idnar> input - previous result = 3 - 8 = -5
21:45:59 <CakeProphet> so >>= is similar to .?
21:46:00 <Axman6> subtract x == \y -> y - x
21:46:05 <CakeProphet> for (a->)?
21:46:14 <idnar> CakeProphet: it's vaguely similar, I guess
21:46:27 <mmorrow> CakeProphet: ah yeah, so subtract is one case where ambiguity (with -) bites
21:46:33 <idnar> CakeProphet: but (.) is actually fmap
21:46:37 <mmorrow> well, (-) is one case...
21:46:48 <mmorrow> which is worked around when needed with subtract
21:46:49 <idnar> > (+5) `fmap` (*2) $ 5
21:46:51 <lambdabot>   15
21:47:09 <CakeProphet> hmmm
21:47:16 <CakeProphet> >>= is actually kind of like $
21:47:25 <CakeProphet> but backwardsish
21:47:26 <idnar> I find it easiest to think of (r->) in terms of fmap, bind, and return
21:47:29 <mmorrow> instance Functor (-> a) where fmap = (.)
21:47:33 <idnar> fmap is (.), return is const
21:47:45 <idnar> and join f = \x -> f x x
21:47:48 <ddarius> mmorrow: (-> a) isn't a functor
21:47:50 <CakeProphet> fmap
21:47:53 <CakeProphet> :t fmap
21:47:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:47:56 <ozy`> so it seems Tim Sweeney likes Haskell better than he used to
21:48:00 <ddarius> Well not a Functor
21:48:00 <idnar> mmorrow: instance Functor (r ->)
21:48:06 <mmorrow> ddarius: ah yeah, i meant (a->)
21:48:13 <Olathe> @src Functor
21:48:13 <lambdabot> class  Functor f  where
21:48:13 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
21:48:16 <mmorrow> or ((->)a)
21:48:31 <Olathe> @instances Functor
21:48:33 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:48:44 <CakeProphet> fmap (+5) -> (+)
21:48:47 <CakeProphet> > fmap (+5) -> (+)
21:48:48 <lambdabot>   <no location info>: parse error on input `->'
21:48:48 <idnar> CakeProphet: f is (r ->), so f a is (r -> a)
21:48:49 <mmorrow> is (a->) even valid syntax?
21:48:56 <ddarius> mmorrow: Sort of.
21:48:58 <mmorrow> (or (->a) for that matter)
21:48:59 <CakeProphet> :k (a->)
21:48:59 <idnar> CakeProphet: so we have (a -> b) -> (r -> a) -> (r -> b)
21:49:00 <lambdabot> parse error on input `)'
21:49:02 <ddarius> Not in H98 though.
21:49:02 <idnar> @type (.)
21:49:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:49:12 <mmorrow> hmm
21:49:28 <CakeProphet> idnar:  ah
21:49:36 <Olathe> Dammit Jim, (->)'s a type name, not a constructor !
21:49:56 <mmorrow> and () (,,) (,,,) ... are all both
21:50:00 <CakeProphet> fmap (+5) negate 5
21:50:04 <CakeProphet> > fmap (+5) negate 5
21:50:06 <lambdabot>   0
21:50:15 <CakeProphet> oh ho
21:50:23 <mmorrow> , ((+5) `fmap` negate) 5
21:50:26 <lunabot>  0
21:50:34 <ddarius> mmorrow: There are type constructors.
21:50:37 <CakeProphet> what is fmap for []'s?
21:50:42 <Olathe> @src [] fmap
21:50:43 <lambdabot> fmap = map
21:50:44 <Cale> CakeProphet: map
21:50:51 <mmorrow> ddarius: ?
21:50:51 <ddarius> Olathe is technically right that -> is syntactically not a (type) constructor.
21:50:54 <CakeProphet> how is map even similar to (.)?
21:51:09 <Olathe> CakeProphet: fmap applies the function to the data in the monad.
21:51:24 <mmorrow> ddarius: yeah, (->) is special like [] and (:) () ..
21:51:40 <idnar> CakeProphet: map applies the function to the contents of the list
21:51:50 <ddarius> mmorrow: : is syntactically a constructor and it's not a type constructor.
21:52:02 <idnar> CakeProphet: in the case of (.), you can think of the "contents" as the potential result from the function
21:52:05 <mmorrow> i mean in that they are both special syntax
21:52:06 <Olathe> CakeProphet: The (->) monad is supposed to contain a function, so you apply a function to that by using (.).
21:52:17 <mmorrow> (->) is a tycon, as is () (,) []
21:52:20 <ddarius> mmorrow: [] and () are completely special cases, they are not syntactically type names or constructors otherwise.
21:52:27 <mmorrow> () (,) [] are /also/ datacons
21:53:17 <idnar> CakeProphet: you could compare it with the IO monad
21:53:31 <nj32> Prelude> :l file.hs   --> file.hs:1:0:    attempting to use module `Prelude' (Prelude.hs) which is not loaded       Failed, modules loaded: none.
21:53:36 <mmorrow> , src ''()
21:53:38 <idnar> CakeProphet: return 5 :: IO Integer is an IO action that results in 5 when run
21:53:41 <lunabot>  data () = ()
21:53:41 <Olathe> @src IO fmap
21:53:41 <lambdabot> fmap f x = x >>= (return . f)
21:53:42 <mmorrow> , src '()
21:53:47 <lunabot>  data () = ... | () | ...
21:53:47 <lunabot>  infixl 9
21:53:52 <CakeProphet> -nod- it sort of makes sense. They're just so abstract similar it's hard to even generalize what fmap does in all cases.
21:53:56 <paynito_> error doing type decl in ghc http://hpaste.org/13358#a0
21:53:58 <paynito_> Prelude> circ :: Float->Float
21:54:01 <CakeProphet> -similar
21:54:03 <pumpkin> @hoogle ->
21:54:03 <lambdabot> keyword ->
21:54:07 <pumpkin> where is -> defined?
21:54:08 <idnar> CakeProphet: so (+5) `fmap` (return 5) is an IO action that results in 10 when run
21:54:12 * ddarius wonders what else lunabot thinks is in ().
21:54:16 <Olathe> @index (->)
21:54:17 <lambdabot> bzzt
21:54:22 * Saizan too
21:54:23 <Olathe> Hmm...
21:54:28 <Olathe> @hoogle (->)
21:54:29 <lambdabot> keyword ->
21:54:32 <mmorrow> ddarius: heh. meet my prettyprinting hackery :)
21:54:33 <ozy`> there ought to be a () monad
21:54:37 <Olathe> Thank you, lambdabot.
21:54:46 <ddarius> ozy`: The kind is not correct.
21:55:02 <ddarius> ozy`: You can make a monad out of Const () though, though it is not a "notion of computation" a la Moggi.
21:55:04 <ozy`> ddarius: realized that as soon as I said it :p
21:55:04 <CakeProphet> ozy`:  there ought to be a Monad Monad
21:55:09 <idnar> CakeProphet: if you're trying to figure out what fmap should be for a particular functor, just look at the type
21:55:17 <ozy`> CakeProphet: that would be pretty sweet
21:55:32 <idnar> CakeProphet: that'll usually help out even if your intuition isn't whispering anything in your ear
21:55:47 <idnar> CakeProphet: of course, there are often many ways to satisfy the type
21:55:48 <nj32> why won't ghci load Prelude by default? why should it fail?
21:55:50 <CakeProphet> idnar:  I still have to play around with the function to figure out what happens for that type.
21:55:57 <CakeProphet> idnar:  yeah.
21:56:01 <idnar> CakeProphet: for example, it shouldn't be too hard to come up with an fmap for lists that isn't map
21:56:06 <Saizan> paynito_: let circ :: Float -> Float; circ r = 2 *pi *r
21:56:07 <idnar> CakeProphet: but it probably won't be as useful as map
21:56:39 <paynito_> thank you
21:56:43 <ddarius> Well since (r ->) is a monad and a (2-)monad in C is Lax[1,C] you may be able to make a monad of monads.
21:56:44 <Olathe> @type [] fmap
21:56:44 <idnar> CakeProphet: eg. fmap f xs = [f (head xs)] would be the right type
21:56:45 <lambdabot>     Couldn't match expected type `((a -> b) -> f a -> f b) -> t'
21:56:45 <lambdabot>            against inferred type `[a1]'
21:57:05 <Olathe> fmap _ _ = []
21:57:27 <idnar> or that
21:57:45 <CakeProphet> idnar:  if think an infinite list of functions is a nice way to conceptualize input operations.
21:57:57 <CakeProphet> --sort of a tangent?
21:57:58 <Olathe> fmap f xs = mergeSort $ map f xs
21:58:24 <bd_> Olathe: what?
21:58:47 <idnar> Olathe: whee, SortedList
21:58:50 <idnar> Olathe: except that has the wrong type :(
21:58:58 <Olathe> Ahh.
21:59:06 <bd_> Olathe: that doesn't satisfy the requirement that fmap id = id
21:59:34 <Olathe> I'm such a lawbreaker.
21:59:35 <idnar> bd_: with a little massaging, it does
21:59:43 <bd_> idnar: howso?
21:59:47 <Olathe> let id = ...
21:59:54 <bd_> Olathe: that's cheating :)
21:59:59 <idnar> bd_: wrap [] in a SortedList newtype or something
22:00:00 <bd_> fmap (\x -> x) = (\x -> x) then
22:00:02 * Olathe whistles innocently.
22:00:19 <bd_> idnar: sure, but then we're not writing a fmap for a list
22:00:19 <idnar> bd_: and make sure there are no ways to construct an unsorted list
22:00:26 <bd_> oh, okay then :)
22:00:29 <idnar> bd_: that's what I meant by massaging :)
22:00:44 <idnar> but unfortunately, you still can't write that instance
22:01:07 <bd_> idnar: because you'd have to restrict fmap to ordered output types
22:01:13 <idnar> yeah
22:01:29 <bd_> hmmm
22:01:32 <CakeProphet> my challenge: to make a practical program that, somewhere in the source code, uses (map (map) x)
22:02:48 <roconnor> @type map map
22:02:50 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
22:03:03 <roconnor> CakeProphet: not fmap fmap ?
22:03:20 <CakeProphet> noep... too easy
22:03:29 <pumpkin> > map ($ [5,4]) (map (map) [(+1), (*5), (^3)])
22:03:31 <lambdabot>   [[6,5],[25,20],[125,64]]
22:03:40 * idnar wonders what you'd de with a list of functions [a] -> [b]
22:03:53 <CakeProphet> map apply to them, apparently.
22:04:36 <idnar> > map ($ [1..5]) $ map (map) [(+5), (*2)]
22:04:37 <lambdabot>   [[6,7,8,9,10],[2,4,6,8,10]]
22:04:56 <pumpkin> > ap (map (map) [(+1), (*5), (^3)]) [[5,6], [1,2]]
22:04:56 <idnar> but there are easier ways to do that
22:04:57 <lambdabot>   [[6,7],[2,3],[25,30],[5,10],[125,216],[1,8]]
22:05:10 <pumpkin> oh no, I forgot the m
22:05:11 <pumpkin> :P
22:05:35 <CakeProphet> > map ((take 5).($ [1..])) $ map (map) [(+5), (*2)]
22:05:36 <lambdabot>   [[6,7,8,9,10],[2,4,6,8,10]]
22:05:42 <CakeProphet> beautiful.
22:05:59 <CakeProphet> time to write a Haskell code obfuscator
22:06:00 <pumpkin> just what you always wanted, eh
22:06:01 <CakeProphet> in Haskell.
22:06:21 <Saizan> and then obfuscate it?
22:06:31 <CakeProphet> that just expands everything into ridiculous, incomprehensible expressions uses >>=, return, map, infinite lists, etc.
22:06:34 <CakeProphet> yep
22:06:41 <Olathe> You could also go the other route.
22:06:56 <idnar> CakeProphet: sounds like a description of @pl :P
22:06:57 <pumpkin> CakeProphet: try to make a given piece of code as short as possible
22:06:59 <CakeProphet> and basic expressions like 2+2 becomes pages long.
22:07:11 <Olathe> Go down the definitions of functions until you get pure, recursive, intro to Scheme style functions.
22:07:17 <CakeProphet> pumpkin:  sounds genetic-algorithm-y
22:07:19 <idnar> @pl \x y z -> (z ++ [y], x, x, z)
22:07:19 <lambdabot> flip flip id . (ap .) . (flip =<< (flip .) . flip (flip . ((,,,) .) . flip (++) . return))
22:07:28 <idnar> CakeProphet: ^^^ :D
22:07:40 <CakeProphet> pretty close.
22:07:56 <idnar> not that my silly little function makes any sense
22:08:09 <Olathe> Like map (+2) [1..10] -> let f [] = []; f (x:xs) = (+2) x:f xs in f [1..10]
22:08:19 <CakeProphet> so @pl basically makes the equivalent of what you give it if there were no argument names specified?
22:08:25 <Olathe> CakeProphet: Yep.
22:08:30 <CakeProphet> that's kind of cool.
22:08:45 <Olathe> It's nice for getting rid of old, tiresome arguments.
22:08:56 <idnar> hahaha
22:09:31 <f4hy> Hey, is this an appropriate place to ask questions about xmonad? or does it have its own channel?
22:09:54 <Saizan> there's #xmonad
22:10:09 <f4hy> alright i'll head over there
22:10:11 <CakeProphet> I think my next step is to see some real applications written in Haskell, and see the components they tend to rely on.
22:10:42 <nj32> Axman6: My mistake. I had a sample Prelude.hs in my current directory, which somehow was creating the problem.
22:10:44 <Saizan> and then obfuscate those?
22:11:05 <CakeProphet> well... I don't have an obfuscator yet.
22:11:17 <CakeProphet> but, yes.
22:11:19 <CakeProphet> in time.
22:11:40 <xEpicFailGuyx> @src List.permutations
22:11:40 <lambdabot> Source not found.
22:12:03 <CakeProphet> a complex code obfuscator is actually in the realm of compiler theory
22:12:17 <CakeProphet> as far as how you would design one.
22:12:21 <CakeProphet> not in the end goal.
22:13:17 <CakeProphet> you need to parse the program, structure it into a tree, and convert certain patterns into more complex patterns
22:13:27 <CakeProphet> then pass over that tree with the same algorithm several more times.
22:21:53 <pumpkin> obfuscating the binary representation is fun too
22:24:07 <Olathe> Making the source look like binary is also fun.
22:24:25 <ddarius> @google DanFest 2004
22:24:28 <lambdabot> http://lambda-the-ultimate.org/node/2080
22:24:28 <lambdabot> Title: DanFest 2004 videos online | Lambda the Ultimate
22:28:40 <CakeProphet> main unparse $ map (.) (replicate npasses obfuscate) (parse source)
22:28:47 <CakeProphet> main = unparse $ map (.) (replicate npasses obfuscate) (parse source)
22:29:10 <CakeProphet> wow... an actual code obfuscator in Haskell might have that in its source.
22:29:13 <CakeProphet> ....
22:29:23 <CakeProphet> from there it's just defining all of that.
22:29:52 <ddarius> CakeProphet: That's a type error.
22:29:57 <CakeProphet> ...rofl.
22:30:07 <mm_freak_> CakeProphet: foldl (.)
22:30:09 <ddarius> CakeProphet: Also, it is unlikely that you'd run multiple passes.
22:30:14 <CakeProphet> assuming unparse returns a string
22:30:16 <CakeProphet> oh
22:30:18 <ddarius> (of the same tranformation)(
22:30:19 <CakeProphet> yeah... foldl
22:30:34 <pumpkin> you could just pull the nth item out of an iterate of obfuscate
22:30:51 <mm_freak_> or do it infinitely
22:31:01 <pumpkin> oh wow, infinite obfuscation
22:31:13 <Olathe> It's like infinite recursion only more confusing.
22:31:42 <CakeProphet> how do you get command line options and the like?
22:31:44 <mm_freak_> fix (. obfuscate)
22:31:58 <pumpkin> getArgs I think
22:32:00 <pumpkin> or something like that
22:32:01 <CakeProphet> what does fix do?
22:32:02 <pumpkin> @hoogle getArgs
22:32:02 <lambdabot> System.Environment getArgs :: IO [String]
22:32:08 <pumpkin> CakeProphet: voodoo
22:32:12 <ddarius> @src fix
22:32:12 <lambdabot> fix f = let x = f x in x
22:32:14 <pumpkin> > fix (5:)
22:32:15 <mm_freak_> CakeProphet: System.Environment.getArgs and System.Console.GetOpt
22:32:15 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
22:32:18 <Olathe> > getArgs
22:32:20 <lambdabot>   Not in scope: `getArgs'
22:32:20 <CakeProphet> pumpkin:  that's my favorite kind of function.
22:32:21 <ddarius> > fix f
22:32:22 <lambdabot>   Add a type signature
22:32:27 <ddarius> > fix f :: Expr
22:32:28 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
22:32:32 <CakeProphet> ....oh
22:32:36 <pumpkin> CakeProphet: it's pretty awesome
22:32:41 <CakeProphet> infinite compose?
22:32:43 <pumpkin> it magically finds you a fixpoint!
22:32:45 <pumpkin> lol
22:32:57 <mm_freak_> > fix (. (+1)) 0
22:33:06 <lambdabot>   mueval: Prelude.read: no parse
22:33:31 <mm_freak_> > fix (\k x -> k (x+1)) 0
22:33:35 <CakeProphet> > fix (+5) 0
22:33:37 <lambdabot>       No instance for (Num (t -> a))
22:33:37 <lambdabot>        arising from the literal `5' at <...
22:33:55 <CakeProphet> ...wat
22:34:02 <mm_freak_> @pl \k x -> k (x+1)
22:34:35 <CakeProphet> ...
22:34:35 <Olathe> > 5
22:34:37 <lambdabot>   mueval: Prelude.read: no parse
22:34:37 <lambdabot> (. (1 +))
22:34:43 <lambdabot>   mueval: Prelude.read: no parse
22:34:43 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
22:34:52 <mm_freak_> why no parse?!
22:34:53 <Olathe> > getArgs
22:34:55 <lambdabot>   * Exception: "<IO [[Char]]>"
22:35:04 <pumpkin> mm_freak_: epic fail
22:35:06 <mm_freak_> it should loop forever
22:35:07 <CakeProphet> > fix (. (1 +))
22:35:08 <lambdabot>       Overlapping instances for Show (b -> c)
22:35:08 <lambdabot>        arising from a use of `s...
22:35:16 <CakeProphet> I don't understand then, what fix does...
22:35:22 <Olathe> @src fix
22:35:23 <lambdabot> fix f = let x = f x in x
22:35:26 <Olathe> It does that.
22:35:29 <mm_freak_> CakeProphet: fix f = f (f (f (f (f …
22:35:38 <CakeProphet> > map (fix (. (1 +))) [1..10[
22:35:39 <lambdabot>   <no location info>: parse error on input `;'
22:35:49 <mm_freak_> CakeProphet: it can be used to implement recursion in typed lambda calculus
22:35:50 <Olathe> > fix (const 5) 5
22:35:52 <lambdabot>       No instance for (Num (t -> a))
22:35:52 <lambdabot>        arising from the literal `5' at <...
22:35:52 <CakeProphet> > map (fix (. (1 +))) [1..10]
22:36:01 <Olathe> @type fix
22:36:05 <lambdabot>   mueval: Prelude.read: no parse
22:36:07 <pardus> @index fix
22:36:08 <lambdabot> forall a. (a -> a) -> a
22:36:08 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
22:36:14 <mm_freak_> > fix (\k x y -> if y == 0 then x else k y (x `mod` y)) 12 15
22:36:18 <lambdabot>   3
22:36:24 <Olathe> @fix (const 5) 5
22:36:25 <lambdabot> Maybe you meant: bid faq ft id thx
22:36:27 <Olathe> > fix (const 5) 5
22:36:29 <lambdabot>       No instance for (Num (t -> a))
22:36:29 <lambdabot>        arising from the literal `5' at <...
22:36:43 <Olathe> > fix (const 5)
22:36:45 <lambdabot>   5
22:36:45 <mm_freak_> have fun, cya =)
22:37:05 <CakeProphet> > fix (negate) 5
22:37:06 <lambdabot>       No instance for (Num (t -> a))
22:37:06 <lambdabot>        arising from a use of `negate' at...
22:37:21 <mm_freak_> and to keep you busy…
22:37:22 <CakeProphet> what am I doing wrong.
22:37:31 <Olathe> @type fix
22:37:33 <lambdabot> forall a. (a -> a) -> a
22:37:40 <Olathe> It takes a function and gives a result.
22:37:44 <Olathe> There's only one argument.
22:37:51 <pardus> > fix (\f x -> if x < 2 then 1 else x * f(x-1)) 5
22:37:53 <lambdabot>   120
22:37:55 <CakeProphet> > fix (negate)
22:37:56 <pardus> it works
22:37:56 <lambdabot>   * Exception: stack overflow
22:38:06 <CakeProphet> right, but it returns a function doesn't it?
22:38:09 <Olathe> > fix fix
22:38:11 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
22:38:11 <lambdabot>      Proba...
22:38:13 <mm_freak_> > let f k p 0 = p; f k p x = k (x*p) (x-1); factorial = fix f in factorial 6
22:38:15 <lambdabot>       Overlapping instances for Show (t -> t)
22:38:15 <lambdabot>        arising from a use of `s...
22:38:20 <Olathe> CakeProphet: Not really.
22:38:27 <pardus> > fix (\f x -> if x < 2 then 1 else x * f(x-1)) 5 :: Expr
22:38:28 <lambdabot>   5 * ((5 - 1) * ((5 - 1 - 1) * ((5 - 1 - 1 - 1) * 1)))
22:38:31 <Olathe> (a -> a) -> a means it takes an a -> a function and gives a.
22:38:35 <dnul> :t )fix (negate) 5) 5
22:38:37 <lambdabot> parse error on input `)'
22:38:38 <mm_freak_> > let f k p 0 = p; f k p x = k (x*p) (x-1); factorial = fix f 1 in factorial 6
22:38:39 <lambdabot>   720
22:38:41 <dnul> :t (fix (negate) 5) 5
22:38:42 <lambdabot> forall t t1 t2. (Num t2, Num t, Num (t -> t2 -> t1)) => t1
22:38:50 <Olathe> > 5 + 5 :: Expr
22:38:52 <lambdabot>   5 + 5
22:38:54 <mm_freak_> > let f k p 0 = p; f k p x = k (x*p) (x-1); factorial = fix f 1 in factorial 100
22:38:55 <CakeProphet> Olathe:  I get the type signature now, but not how it derives a result from a function.
22:38:56 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
22:39:00 <dnul> isnt that the way?
22:39:11 <pumpkin> CakeProphet: it rarely does :P
22:39:16 <Olathe> @src fix
22:39:17 <lambdabot> fix f = let x = f x in x
22:39:18 <pumpkin> CakeProphet: in the case of lists, it's easy for it to do so
22:39:34 <pumpkin> > fix (a:) :: [Expr]
22:39:35 <lambdabot>   [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
22:39:43 <pumpkin> > fix (f) :: [Expr]
22:39:44 <lambdabot>       No instance for (SimpleReflect.FromExpr [Expr])
22:39:44 <lambdabot>        arising from a u...
22:39:48 <pumpkin> > fix (f) :: Expr
22:39:49 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
22:40:07 <pumpkin> > fix (1 :) :: [Expr]
22:40:08 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:40:10 <pumpkin> boo
22:40:11 <CakeProphet> how does it know to stop in the case of const?
22:40:16 <Olathe> CakeProphet: With fix (const 5), it doesn't care what the rest of the nested ifs give.
22:40:20 <pumpkin> it never knows to stop
22:40:21 <Olathe> nested fs
22:40:45 <CakeProphet> so how can Haskell return 5 for fix (const 5)
22:40:55 <Olathe> Well, trace it.
22:41:20 <Olathe> let x = (const 5) x in x
22:41:30 <Olathe> It doesn't know what x is yet.
22:41:39 <Olathe> But it doesn't care, since const throws that away.
22:41:44 <Olathe> So, x = 5.
22:41:49 <Olathe> in x.
22:42:09 <CakeProphet> I see how it logically makes sense... but how does Haskell know that const will always return 5...
22:42:10 <Olathe> Laziness++
22:42:16 <pumpkin> CakeProphet: it's lazy
22:42:18 <Olathe> @src const
22:42:18 <lambdabot> const x _ = x
22:42:24 <CakeProphet> that makes sense for lazy lists... but not for fix.
22:42:26 <pumpkin> if the function doesn't ask for its second argument, it doesn't bother evaluating it
22:42:27 <Olathe> It knows that it throws away the second argument.
22:42:34 <Olathe> Functions are lazy, too.
22:42:37 <Olathe> Not just lists.
22:42:41 <CakeProphet> right.
22:42:47 <CakeProphet> hmm...
22:43:03 <Olathe> So, const 5 whatever just gives 5 without figuring out what whatever is.
22:43:16 <Olathe> It doesn't need to compute it, so it doesn't.
22:43:16 <CakeProphet> @let lol x _ = x + 5
22:43:18 <lambdabot>  Defined.
22:43:26 <pumpkin> > const 5 undefined
22:43:27 <lambdabot>   5
22:43:34 <pumpkin> it never asks for the undefined
22:43:59 <CakeProphet> ...I understand all that, I'm just trying to figure out how calling a function recursively forever can actually derive a number as a result.
22:44:09 <pumpkin> it doesn't call it recursively forever
22:44:10 <Olathe> CakeProphet: It never recurses the first time.
22:44:13 <idnar> CakeProphet: because the recursion never happens
22:44:19 <Olathe> CakeProphet: It only does that if it needs to.
22:44:29 <pumpkin> it only recurses if the second argument is used
22:44:37 <Olathe> In the f (f ( hall of mirrors thing, it had to do that.
22:45:03 <Olathe> To stop recursion, break second argument.
22:45:14 <CakeProphet> const(const(const(const(...?
22:45:16 <CakeProphet> or is it
22:45:18 <pumpkin> nope
22:45:25 <CakeProphet> (const 5)(const 5)...
22:45:37 <pumpkin> it would be (const 5 (const 5 (const 5 ...
22:45:44 <pumpkin> if the second argument were ever evaluated
22:46:04 <CakeProphet> > fix (lol 10)
22:46:05 <lambdabot>   15
22:46:33 <CakeProphet> so other than generating infinite lists what can you use fix for?
22:47:02 <pumpkin> finding fixpoints
22:47:13 <idnar> it's not really all that useful except form a theoretical perspective
22:47:14 <CakeProphet> wat
22:47:22 <idnar> most of the time, you want to use higher-level recursion mechanisms
22:47:43 <ddarius> idnar: And the remainder you want to use explicit recursion.
22:47:44 <Lemmih> > fix (\s l -> case l of [] -> 0; (x:xs) -> x+s xs) [1..100]
22:47:45 <lambdabot>   5050
22:47:49 <Olathe> > fix sqrt
22:47:51 <lambdabot>   * Exception: stack overflow
22:47:55 <idnar> ddarius: heh
22:48:09 <Olathe> No fix points for sqrt.
22:48:23 <ddarius> > sqrt 1
22:48:23 <pumpkin> really?
22:48:24 <lambdabot>   1.0
22:48:37 <Olathe> Just kidding :)
22:48:42 <Olathe> There's also that 0.0 one.
22:48:42 <mm_freak_> CakeProphet: 'fix f' is the function 'f' called with itself as its first argument
22:49:12 <ddarius> mm_freak_: Not quite.
22:49:23 <ddarius> Or you have to be more clear about "itself"
22:49:33 <idnar> it's the function 'f' called with 'fix f' as its first argument
22:49:37 <mm_freak_> with "itself" i meant 'fix f'
22:50:00 <pumpkin> aha, two possible itselves
22:50:07 <idnar> itselven!
22:50:10 <pumpkin> :P
22:50:12 <CakeProphet> also, I don't really understand why I wouldn't make multiple passes in a code obfuscator.
22:50:26 <CakeProphet> it would exponentially increase obfuscation.
22:50:31 <pumpkin> CakeProphet: that's a good thing!
22:50:39 <Olathe> That's a bad thing !
22:50:45 <ddarius> CakeProphet: You might run it to fix point, but you wouldn't run it some arbitrary number of times.
22:51:09 <dibblego> installing lambdabot is as easy as cabal-install? gotta see that to believe it
22:51:10 <CakeProphet> npasses would just be a command line option... with a default value otherwise.
22:51:14 <CakeProphet> probably just once.
22:51:17 <pumpkin> dibblego: not on 6.10
22:51:19 <ddarius> CakeProphet: If you look at that DanFest like I googled earlier, there is actually a talk on obfuscation.
22:51:29 <dibblego> pumpkin, of course not :)
22:51:32 <pumpkin> :P
22:51:58 <CakeProphet> I still haven't gotten lambdabot to install
22:52:51 <mm_freak_> i don't understand why we need to obfuscate code in the first place
22:52:53 <Gracenotes> > init [1..10]
22:52:55 <lambdabot>   [1,2,3,4,5,6,7,8,9]
22:53:07 <pumpkin> mm_freak_: to stop l33t hax0rz fr0m und3rst4nd1ng 1t
22:53:18 <Cthulhon> It doesn't stop that...
22:53:24 <pumpkin> mm_freak_: although that's more binary 0bfusc4t10n
22:53:27 <pumpkin> :P
22:53:40 <mm_freak_> if you really want to obfuscate code, use insane theoretic constructs in your code
22:53:48 <Cthulhon> I've broken every Java obfuscation tool I've encountered, for example.
22:53:53 <CakeProphet> well, generally it's just fun to see how a programming language, when misused, can create horrid readability.
22:54:01 <Cthulhon> At the real binary level, packers are a lot more popular.
22:54:04 <Olathe> There was one zygodecohomoundermorphism thingy before.
22:54:04 <pumpkin> Cthulhon: I should set you on the fairplay code
22:54:08 <Olathe> You could probably use that.
22:54:14 <ddarius> Cthulhon: Most obfuscation tools are just arbitrary mungings.
22:54:20 <Cthulhon> Right.
22:54:29 <Cthulhon> Which is why they're very ineffective.
22:54:30 <mm_freak_> CakeProphet: http://blog.ertes.de/2008/11/obscure-c-from-new-perspective.html
22:54:30 <CakeProphet> but I suppose there are some pratical purposes, like simple encryption without having an actual decryption step required.
22:54:32 <mm_freak_> =)
22:54:41 <pumpkin> or try fairplay :P
22:54:50 <Cthulhon> Packers with real encryption are much better, but even that doesn't stand up to a simple debugger.
22:54:52 <ddarius> Cthulhon: You can actually make a theory of obfuscation and prove that it does make certain analyses harder.
22:55:02 <Gracenotes> hm... trying to figure out Fibonacci with fix. proving interesting >_>
22:55:09 <CakeProphet> and I suppose you could use obfuscated code to test compiler optimization.
22:55:22 <Cthulhon> Well, define 'certain types of analysis'.  Sure you can make some automated comprehension tools fail.
22:55:30 <Cthulhon> But I'm talking about if there's a human looking at it.
22:55:42 <pumpkin> Cthulhon: have you looked at fairplay? :P
22:55:45 <mm_freak_> > fix (\k x y -> x : k y (x+y)) 0 1
22:55:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:55:49 <Cthulhon> The Apple DRM?
22:56:01 <pumpkin> yup
22:56:11 <Gracenotes> mm_freak_: ah, I was considering passing along just an array, not two arguments
22:56:15 <Cthulhon> Not really, but I thought it had been broken.
22:56:20 <pumpkin> not really
22:56:32 <Gracenotes> I guess you don't need to pass it around to have it constitute the result
22:56:39 <ddarius> Cthulhon: You get to choose the analysis, but it has to be a formal thing.  You obviously can't annihilate all knowledge of how it works (and still have it be useful).  So you can't make it impossible to understand, just harder.
22:56:46 <mm_freak_> Gracenotes: i don't understand what you mean
22:57:14 <Gracenotes> okay, this is terribly slow as written, but it does work
22:57:18 <Gracenotes> > fix (\a b -> let c1 = last b; c2 = last $ init b in (init b) ++ a [c1, c1 + c2]) [0,1]
22:57:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:57:41 <mm_freak_> > fix (\k a -> a!!1 : k a!!2 (a!!1+a!!2)) (listArray (1,2) [0,1])
22:57:43 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
22:57:43 <lambdabot>        Expect...
22:57:46 <Olathe> > fix unbroken
22:57:46 <Gracenotes> I do mean very slow, as in each iteration it crawls through the list about 5 times
22:57:47 <lambdabot>   *** EXPLOSION ***
22:57:54 <pumpkin> lol
22:57:55 <mm_freak_> > fix (\k a -> a!1 : k a!2 (a!1 + a!2)) (listArray (1,2) [0,1])
22:57:56 <lambdabot>   Couldn't match expected type `Array i [e]'
22:58:11 <mm_freak_> > fix (\k a -> a!1 : k (a!2) (a!1 + a!2)) (listArray (1,2) [0,1])
22:58:12 <lambdabot>       Occurs check: cannot construct the infinite type: e = Array i e
22:58:12 <lambdabot>        ...
22:58:25 <Cthulhon> ddarius: The question is how usefully harder you can make it.  You might as well call things like RSA 'just making it harder', but when we start talking about timescales in which universes are born and die, I think we can call it secure.  But while we can estimate brute force times for certain encryptions, obfuscation remains extraordinarily ineffectual.
22:58:30 <mm_freak_> > fix (\k a -> (a!1) : k (a!2) ((a!1) + (a!2))) (listArray (1,2) [0,1])
22:58:32 <lambdabot>       Occurs check: cannot construct the infinite type: e = Array i e
22:58:32 <lambdabot>        ...
22:58:48 <mm_freak_> d'oh
22:58:54 <Gracenotes> you could do it as pairs
22:59:02 <Gracenotes> as you seem to be doing :)
22:59:03 <Cthulhon> If an obfuscation tool required the hacker to take even a month to work it out, that would be a huge success.
22:59:12 <pumpkin> Cthulhon: like fairplay :P
22:59:22 <pumpkin> Cthulhon: it's stopped major hackage of their drm for quite a while now
22:59:28 <Cthulhon> As it is, it takes at most a day, even on large codebases.
22:59:35 <ddarius> Cthulhon: Again, with respect to some analysis (and formally obfuscation only makes sense with respect to some analysis) you presumably can make it NP-hard (in relevant cases) for the analysis to recover the information.
22:59:40 <Cthulhon> pumpkin: Yeah, but Fairplay is encryption, right?
23:00:08 <pumpkin> Cthulhon: yes, but you have the key on your machine somewhere, and the code that uses the key to decrypt the encrypted file... the problem is that their code is obfuscated to hell
23:00:22 <Cthulhon> ddarius: Give me an example, or some sort of details.
23:00:23 <Gracenotes> all we need to do is show that we can efficiently solve an NP-hard problem, and encryption will be useless the next day :P
23:00:34 <Cthulhon> You can say it's theoretically possible, and I can't directly dispute that.
23:00:47 <ddarius> Cthulhon: I gave a link that I've referenced twice above with a talk given by someone who works on such things professionally.
23:01:06 <pumpkin> but even in unprovable manners, a good binary obfuscation tool is quite effective
23:01:46 <mm_freak_> Gracenotes: you said arrays =P
23:01:54 <Cthulhon> Binary obfuscation usually means packers, most of which have a simple hole.  I suppose if you get it just right, it could be NP-hard.
23:02:04 <pumpkin> Cthulhon: not necessarily packers
23:02:11 <ddarius> Cthulhon: Also, I haven't said anything about copy-protection and such.  If the goal were to hide trade secrets, even doing nothing is quite effective and normal compilation even moreso.
23:02:15 <pumpkin> just things that make stuff a real pain to disassemble
23:02:24 <pumpkin> Cthulhon: none of apple's stuff is "packed"
23:02:36 <Gracenotes> mm_freak_: oh! possible as well ;)
23:02:41 <mm_freak_> > fix (\k a -> a!1 : k (a // [(1, a!2), (2, a!1 + a!2)])) (listArray (1,2) [0,1])
23:02:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:02:46 <mm_freak_> hah!
23:02:56 <Gracenotes> indeed, a success
23:03:09 <Cthulhon> pumpkin: Yeah, I know Apple's stuff isn't packed, but I don't know enough specifics about it to really discuss it.
23:03:40 <pumpkin> I'm just saying, it's very effective, so you can't dismiss packers just because their transformation is easily reversible with a debugger
23:03:47 <pumpkin> or rather, you can dismiss packers
23:03:54 <pumpkin> but you can't dismiss obfuscation just because packers aren't effective
23:04:20 <Cthulhon> I'm not dismissing obfuscation, as such.  I'm just saying that I don't think any current techniques are anywhere close to effective.
23:04:31 <Cthulhon> I'm still following up on ddarius's link, though.
23:04:32 <pumpkin> well I've given you an example of one :P
23:05:10 <Cthulhon> Well, I can't agree that it's effective without doing more research.
23:06:43 <CakeProphet> > unbroken 5
23:06:45 <lambdabot>   *** EXPLOSION ***
23:06:55 <CakeProphet> > fib
23:06:56 <lambdabot>   Not in scope: `fib'
23:07:01 <CakeProphet> :(
23:07:59 <Cthulhon> pumpkin: According to Wikipedia, Fairplay has been broken a number of times, although Apple has kept up with patching it each time.
23:08:33 <pumpkin> yup, but in its current state, it's unbroken, and it's extremely easy for apple to make a change requiring a few months of reverse engineering on the part of the "hackers"
23:08:48 <pumpkin> you can see the same issue with the related ipod hash issues
23:09:21 <pumpkin> being unable to make recent ipods accept databases without this "hash" computed by itunes when it writes it
23:13:28 <Gracenotes> > let filter f xs = fix (\a b -> case b of [] -> []; (x:xs) -> if (f x) then x:(a xs) else (a xs)) xs in filter even [1..10]
23:13:30 <lambdabot>   [2,4,6,8,10]
23:13:49 <Gracenotes> probably more verbose than it needs to be, but it works :)
23:13:50 <Cthulhon> ddarius: The video via the DanFest page seems to be gone.
23:14:01 <Cthulhon> Google doesn't point out any mirrors.
23:15:00 <Cthulhon> Ah, the download option from Google Video appears intact.
23:15:01 <Gracenotes> the xs argument is unneeded, for one...
23:15:08 <CakeProphet> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
23:15:10 <lambdabot>  Defined.
23:15:59 <CakeProphet> @let unfib n = reverse (take n fibs)
23:16:01 <lambdabot>  Defined.
23:16:06 <CakeProphet> > unfib 1000
23:16:07 <lambdabot>   [26863810024485359386146727202142923967616609318986952340123175997617981700...
23:17:13 <CakeProphet> @let fibAt = (fibs!!)
23:17:15 <lambdabot>  Defined.
23:21:21 <bos> @seen dons
23:21:21 <lambdabot> dons is in #haskell, #xmonad, #darcs, #concatenative, #ghc and #arch-haskell. I last heard dons speak 3h 43m 19s ago.
23:24:16 <CakeProphet> > unfib 10
23:24:18 <lambdabot>   [34,21,13,8,5,3,2,1,1,0]
23:24:38 <CakeProphet> @let fibs = 1 : zipWith (+) fibs (tail fibs)
23:24:38 <lambdabot>  <local>:33:0:
23:24:38 <lambdabot>      Multiple declarations of `L.fibs'
23:24:38 <lambdabot>      Declared at: <loca...
23:24:44 <CakeProphet> @undefine fibs
23:25:05 <idnar> CakeProphet: it doesn't take a param, it always undefines everything
23:25:20 <CakeProphet> you can't just undefine one?
23:25:35 <CakeProphet> @help undefine
23:25:35 <lambdabot> undefine. Reset evaluator local bindings
23:25:36 <Gracenotes> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); unfib n = reverse (take n fibs) in unfib 10 `seq` unfib 12
23:25:37 <lambdabot>   [89,55,34,21,13,8,5,3,2,1,1,0]
23:25:47 <idnar> CakeProphet: basically the definitions just get dumped into a file or something
23:25:56 <idnar> CakeProphet: and then undefine wipes that file
23:26:23 <CakeProphet> @let fibAt = (fibs!!)
23:26:23 <lambdabot>  <local>:1:9: Not in scope: `fibs'
23:26:51 <CakeProphet> such a bold little program.
23:26:57 <CakeProphet> fibs!!!!!
23:27:53 <CakeProphet> @let (?) x = Just x
23:27:54 <lambdabot>  Defined.
23:28:08 <CakeProphet> :t 5?
23:28:09 <lambdabot> parse error (possibly incorrect indentation)
23:28:22 <CakeProphet> :t (5?)
23:28:24 <lambdabot> forall t. (Num t) => Maybe t
23:28:59 <idnar> > (5?)
23:29:01 <lambdabot>   Just 5
23:29:11 <idnar> > (5!)
23:29:12 <lambdabot>       Overlapping instances for Show (i -> e)
23:29:12 <lambdabot>        arising from a use of `s...
23:29:13 <idnar> :P
23:31:22 <CakeProphet> @let (!!!) x = (show x) ++ repeat "!"
23:31:23 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
23:31:30 <CakeProphet> @let (!!!) x = (show x) ++ repeat '!'
23:31:31 <lambdabot>  Defined.
23:31:57 <CakeProphet> > (30!!!)
23:31:59 <lambdabot>   "30!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
23:32:14 <adrian> > (great !!!)
23:32:15 <lambdabot>   Not in scope: `great'
23:32:23 <adrian> > ("great" !!!)
23:32:25 <lambdabot>   "\"great\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
23:32:40 <CakeProphet> I remember what the equivalent function would have looked like in Python, and I now respect Haskell slightly more.
23:33:10 <CakeProphet> in my quest to reach new pinnacles of infinite exclaimation.
23:33:16 <Gracenotes> what, something like str(x) + '!'*100 ?
23:33:26 <Gracenotes> although that's not quite infinite
23:33:28 <pumpkin> what happened to the ... function?
23:33:36 <Gracenotes> infinity is a bit difficult in Python
23:34:23 <CakeProphet> there's generators... but that doesn't quite produce a string.
23:39:44 <adrian> http://hpaste.org/13359?lines=true
23:39:51 <adrian> why does that stack-overflow?
23:40:23 <adrian> I suspect line 13, since that's not tail-recursive
23:40:39 <adrian> but that should only be executed log n times
23:42:01 <pumpkin> sum likes to overflow
23:42:09 <pumpkin> try replacing it with foldl' (+) 0
23:43:03 <adrian> still overflows
23:45:03 <CakeProphet> does it integer overflow or stack overflow?
23:45:09 <adrian> stack overflow
23:46:03 <adrian> is there some :set show-overflow-location?
23:46:39 <Gracenotes> > length $ map (:[]) [1..1000000]
23:46:40 <lambdabot>   1000000
23:48:39 <CakeProphet> adrian:  you could set a breakpoint and then run it in a number of steps at a time until it overflows.
23:49:19 <adrian> how do I run it a number of steps at a time?
23:49:57 <nanothief> is there a script or function that can be used to format the output of a show function (automatically derived)? For complex types with many nested types, it becomes hard to read it
23:50:37 <adrian> nanothief: Text.PrettyPrint?
23:51:13 <CakeProphet> adrian:  does ghcis debugger not let you step a large number of times?
23:51:25 <adrian> I don't know
23:53:09 <nanothief> adrian, I'm not sure what method to use for that. Eg I have a type Project which derives Show, can I pretty print it without a lot of extra code?
23:55:07 <adrian> y something on the wiki about it
23:55:38 <adrian> tz, I need more ram. It ate what I typed
23:56:01 <adrian> nanothief: there probably something on the wiki about it. I've never used PrettyPrint
23:56:13 <nanothief> adrian, ok thanks
23:58:09 <adrian> now that's interesting
23:58:25 <adrian> without random numbers
23:58:31 <adrian> it doesn't overflow
23:58:37 <adrian> let l = [1000000,999999..1] works fine
23:59:16 <Gracenotes> adrian: changing kindaFold's first definition to kindaFold f (a:b:as) = let fab = f a b in fab `seq` fab : kindaFold f as
23:59:25 <Gracenotes> it also seems to prevent overflow
23:59:36 <Gracenotes> it takes a long time on ghci, but there's no overflow
