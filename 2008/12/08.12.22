00:03:43 <dancor> salviamobile
00:10:10 <dons> i find that 'car' example werid
00:11:24 <Axman6> dons: http://www.cs.caltech.edu/~mvanier/hacking/rants/cars.html might put it in a slightly better context
00:11:42 <Axman6> i did like "FORTH LOVE IF HONK THEN !"
00:12:58 <dons> bos, nice news on HTTP 4, http://www.reddit.com/r/haskell/comments/7ky7v/initial_performance_numbers_for_the_new/2bh6
00:14:28 <bos> dons: yeah, good to see.
00:17:48 <adrian> the wikibook says:
00:17:50 <adrian> This, in Haskell-speak, is fix id, which is denotationally _|_. So we see that as soon as we introduce fix to the untyped lambda calculus, the property that every well-typed term reduces to a value is lost.
00:18:04 <adrian> shouldn't that be "typed lambda calculus"?
00:18:21 <adrian> http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion at the very bottom
00:20:01 <quicksilver> adrian: yes.
00:20:33 <adrian> I'll change it then
00:20:46 <adrian> "fix" it :)
00:21:28 <Axman6> heh
00:21:32 <Axman6> :t fix
00:21:33 <lambdabot> forall a. (a -> a) -> a
00:32:48 <adrian> you shouldn't try out the "fix and recursion" exercises
00:33:00 <adrian> fix reverse crashed my computer
00:33:12 <adrian> because ghci doesn't react to ^C
00:33:35 * jeffwheeler tries it.
00:34:21 <porges> anyone know what Neil is referring to in Hints.hs with the comment about RecMatch?
00:34:27 <porges> (re: hlint)
00:34:37 <ziman> ghci> fix reverse
00:34:37 <ziman> *** Exception: stack overflow
00:34:38 <ziman> hm.
00:34:50 <adrian> over here it ate all my ram
00:35:00 <adrian> > fix reverse
00:35:01 <lambdabot>   * Exception: stack overflow
00:35:06 <adrian> hm
00:35:23 <adrian> > fix id
00:35:24 <lambdabot>   * Exception: stack overflow
00:35:35 <jeffwheeler> It is owning me, too.
00:35:43 <adrian> > fix (const id)
00:35:44 <lambdabot>       Overlapping instances for Show (a -> a)
00:35:44 <lambdabot>        arising from a use of `s...
00:35:56 <adrian> > fix (const id) "yay"
00:35:57 <lambdabot>   "yay"
00:36:23 <porges> adrian: it reacts to ^Z
00:36:32 <adrian> good to know
00:36:48 <ziman> i just close the terminal, usually
00:36:56 <ziman> when something similar happens
00:37:07 <porges> it reacts to ^C as well but not always
00:37:16 <adrian> on os x the terminal asks you if you really want to kill the process running in it
00:37:16 <porges> must be something to do with what it's doing
00:38:52 <idnar> ^\ (SIGQUIT) might work better
00:39:24 <adrian> I often need a function similar to map, which takes n-elements out of the list calls f on them and puts the last n-1 back
00:39:37 <ziman> even sigquit does not work for me sometimes
00:39:43 <adrian> is there something like that in the libraries?
00:40:36 <ziman> > map (+1) . tail $ [1..10]
00:40:37 <lambdabot>   [3,4,5,6,7,8,9,10,11]
00:41:09 <BeelsebobWork> noting ofc that this doesn't do any putting back
00:41:13 <BeelsebobWork> it just returns the new list
00:41:42 <idnar> also that was the whole list, not n elements
00:42:04 <adrian> map3 f (a:b:c:rs) = f a b c : map3 f (b:c:rs)
00:42:24 <idnar> > liftM2 (++) (map (+1) . take 5) (drop 5)
00:42:25 <lambdabot>       Overlapping instances for Show ([a] -> [a])
00:42:25 <lambdabot>        arising from a use o...
00:42:30 <idnar> > liftM2 (++) (map (+1) . take 5) (drop 5) $ [1..10]
00:42:31 <lambdabot>   [2,3,4,5,6,6,7,8,9,10]
00:42:44 <idnar> > liftM2 (++) (tail . map (+1) . take 5) (drop 5) $ [1..10]
00:42:45 <lambdabot>   [3,4,5,6,6,7,8,9,10]
00:43:54 <idnar> that seems like a weird thing to do, though
00:44:33 <porges> @let what n f = uncurry (++) . ((tail . map f . take n) &&& (drop n))
00:44:34 <lambdabot>  Defined.
00:44:46 <porges> what (+1) 5 $ [1..10]
00:44:49 <porges> > what (+1) 5 $ [1..10]
00:44:50 <lambdabot>       The section `(+ 1)' takes one argument,
00:44:50 <lambdabot>      but its type `Int' has none
00:45:00 <porges> > what 5 (+1) $ [1..10]
00:45:01 <lambdabot>   [3,4,5,6,6,7,8,9,10]
00:45:53 * idnar ponders liftM2 vs (&&&)
00:45:59 <sjanssen> > typeOf what
00:46:00 <lambdabot>   Add a type signature
00:46:08 <porges> @type what
00:46:09 <lambdabot> forall b. Int -> (b -> b) -> [b] -> [b]
00:46:12 <BeelsebobWork> idnar: <$> and <*> -- more general!
00:46:17 <adrian> :t &&&
00:46:17 <lambdabot> parse error on input `&&&'
00:46:24 <adrian> :t (&&&)
00:46:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:46:54 <idnar> BeelsebobWork: hmm, for some reason <$> <*> seem weird when used on an operator
00:47:16 <BeelsebobWork> idnar: so use <^ and ^> instead -- that's exactly why I created the InfixApplicative package
00:48:14 <idnar> <^(++)^> is a bit disturbing
00:48:21 <porges> dead kirby?
00:48:29 <BeelsebobWork> nah, it's the appending pig
00:48:35 <idnar> it doesn't look like something you'd want to meet in a dark alley
00:48:51 <BeelsebobWork> hehe
00:49:07 <BeelsebobWork> I'd rather meet the appending pig than the robot monkey
00:49:48 <mbz> robot monkey? what's that?
00:49:55 <BeelsebobWork> (:[])
00:50:28 <idnar> (:[{- OM NOM NOM NOM NOM -}])
00:50:29 <mbz> nice :)
00:51:44 <porges> does lambdabot have infixapplicative?
00:51:48 <BeelsebobWork> no :(
00:51:54 <BeelsebobWork> I asked cale a while back, but didn't get a response
00:51:57 <BeelsebobWork> can always @let it
00:52:14 <BeelsebobWork> @let a <^ f = fmap f a
00:52:15 <lambdabot>  Defined.
00:52:24 <BeelsebobWork> @let f ^> a = f <*> a
00:52:25 <lambdabot>  Defined.
00:52:45 <BeelsebobWork> > [1,2] <^(:)^> [[],[9,3,4]]
00:52:46 <lambdabot>   [[1],[1,9,3,4],[2],[2,9,3,4]]
00:52:55 <porges> @let what n f = <^ (++) ^> . ((tail . map f . take n) &&& (drop n))
00:52:56 <lambdabot>   Parse error
00:52:58 <idnar> > tail . map (+1) . take 5 <^(++)^> drop 5 $ [1..10]
00:52:58 <lambdabot>       precedence parsing error
00:52:58 <lambdabot>          cannot mix `(.)' [infixr 9] and `(<^)...
00:53:08 <idnar> > (tail . map (+1) . take 5) <^(++)^> (drop 5) $ [1..10]
00:53:09 <lambdabot>   [3,4,5,6,6,7,8,9,10]
00:53:17 <porges> @let what n f = (<^ (++) ^>) . ((tail . map f . take n) &&& (drop n))
00:53:17 <lambdabot>   Parse error
00:53:32 <porges> cry
00:53:33 <BeelsebobWork> porges: unfortunately it can't be used as an operator on its own
00:53:45 <BeelsebobWork> it needs at least one of <^ and ^> to be fully applied
00:54:07 <BeelsebobWork> that one would have to end up being liftA2
00:54:47 <idnar> that definition didn't make any sense anyway
00:55:55 <idnar> unless I'm missing something
00:56:30 <adrian> haskell: language of thousand operators
00:56:47 <BeelsebobWork> adrian: yep, great in't it
00:57:23 <BeelsebobWork> the only downside, is stuff like ⊕ and ⊆ are really hard to type
00:57:35 <adrian> and as a bonus you need to study maths to understand what they all do
00:57:44 <adrian> indeed
00:57:46 <BeelsebobWork> not at all
00:58:15 <redditbot> Bryan and Lennart's new LLVM bindings for Haskell: safe, high level, useful!
00:58:25 <BeelsebobWork> > let ∫ x = x in ∫ x -- does this come out as prefix or infix
00:58:26 <lambdabot>   <no location info>: parse error on input `∫'
00:58:58 <BeelsebobWork> > let (∫) x y = x in 1 ∫ 2 -- does this come out as prefix or infix
00:59:00 <lambdabot>   1
00:59:02 <BeelsebobWork> lame :(
00:59:15 <porges> > isSymbol '∫'
00:59:16 <lambdabot>   True
00:59:20 <BeelsebobWork> oh, neat
00:59:22 <BeelsebobWork> also, lame
00:59:38 * BeelsebobWork wanted to be able to use ∫ to mean integral in reactive programs
00:59:48 <porges> you can you just have to always use ()
01:00:00 <porges> let (∫) x = x in (∫) x
01:00:02 <BeelsebobWork> could then neatly end up this integrals actually coming out as let pos = ∫ vel dt
01:00:02 <klinkers> is there an R binding for haskell?
01:00:25 <BeelsebobWork> porges: yeh, just doesn't look quite as shiny
01:09:11 <adrian> does anyone know how to write inline list-comprehensions in lhs2Tex?
01:09:40 <adrian> the | in the list-comprehension is interpreted als end-of-code character
01:11:30 <porges> is there any collection of extra hints for hlint being worked on?
01:13:07 * dancor always uses like IO (Maybe a) everywhere first and then has to go back and change to ErrorT String IO a
01:14:11 <dancor> one problem is Maybe -> Either String.  but the main one is that i want to combine IO and Maybe/Either later on than i realize
01:14:35 <dancor> (the -> was "has to be converted" not function)
01:15:13 <dancor> and monad transformers are different enough from monads that it's this massive refactor
01:15:20 <dancor> does anyone have advice/pity
01:22:34 <cjs> One wants automated refactoring tools for that sort of thing, I think.
01:24:16 <klinkers> is there an R binding for haskell?
01:24:27 <klinkers> is there a haskell-compiler for the JVM?
01:26:54 <adrian> klinkers: http://www.cs.rit.edu/~bja8464/lambdavm/
01:27:41 <adrian> I doubt its usability though
01:27:52 <jsn> dancor: i have pity
01:28:39 <dancor> the real problem is i don't understand fully why monad transformers have to be different from monads as they are
01:29:03 <dancor> it's easier to accept change if are sure it's necessary
01:29:12 <jsn> in what way are they different?
01:30:12 <quicksilver> well IO (Maybe a) is morally MaybeT IO a
01:30:19 <quicksilver> but you weren't using it in that form
01:30:32 <dancor> well why can't a have f :: a -> IO (Maybe a) and g :: a -> IO (Maybe a) and still get something similar to (do {x1 <- f x0; g x1}) to work
01:30:46 <quicksilver> I presume the most annoying thing is having to lift all the IO?
01:31:02 <quicksilver> dancor: because, essentially, there are two monad instances for IO (Maybe a).
01:31:12 <jsn> dancor: because you have it in two monads
01:31:13 <quicksilver> the first is the IO instance, (value type = a)
01:31:21 <quicksilver> damn
01:31:23 <quicksilver> said that wrong :)
01:31:29 <quicksilver> the first is the IO instance, (value type = *Maybe* a)
01:31:40 <quicksilver> the second is the MaybeT IO instance, where the value type is only 'a'
01:31:47 <quicksilver> they have slightly different behaviour
01:31:54 <quicksilver> and the type system has to know which one to pick.
01:31:59 <dancor> i guess i'm wondering if there's something to be said for making two-monad mechanics work somehow
01:32:05 <quicksilver> the way the haskell type system works, we need a newtype (MaybeT)
01:32:12 <quicksilver> for when we want the second case.
01:32:41 <cnwdup> @pl foldl (flip ($))
01:32:41 <lambdabot> foldl (flip id)
01:32:45 <dancor> what if i go extreme the other way and never have m (n a)
01:32:54 <klinkers> can one do statistics and linear algebra in haskell on a professional level? ie are the libraries complete and robust?
01:32:58 <dancor> and always pre-empt with nT m a  while coding
01:33:04 <dancor> do you think i'll run into bad situations
01:34:56 <quicksilver> dancor: no, that's a better idea probably
01:35:00 <quicksilver> you might get annoyed by the lifting.
01:35:13 <quicksilver> dancor: please note it's trivial to convert from nT m a and m (n a) and back
01:35:29 <quicksilver> so it's not really a big deal if you have some functions in one form and others in the other.
01:36:28 <dancor> quicksilver: it's not trivial
01:36:52 <dancor> Left err becomes throwError err
01:36:56 <dancor> idk
01:37:27 <quicksilver> it's trivial, given a function
01:37:35 <dancor> it didn't feel trivial when i did it in this entire program just now.  do you think it's automatable
01:37:42 <quicksilver> that's not what I mean.
01:37:48 <quicksilver> I mean *without* rewriting any code
01:38:21 <quicksilver> it's trivial to use the two different types together
01:38:30 <quicksilver> if you have a function "oldstyle :: m (n a)"
01:38:44 <quicksilver> then you just write "NT oldstyle" to have it as "nT m a"
01:39:03 <quicksilver> conversely, if you have newstyle :: nT m a and you want to interoperate with the other style, you can just use
01:39:15 <quicksilver> "runNT newstyle" which will have the type m (n a) again.
01:41:03 <dancor> :t ErrorT
01:41:04 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
01:42:12 <dancor> a changer automater would be cool too.  i'm not aware of too many hs-code-transformers, seems like there should be a lot given the metaness of the userbase
01:43:03 <quicksilver> no argument there.
01:43:14 <quicksilver> Although, haskell isn't as much in need of refactoing tools as, say, Java.
01:43:21 <quicksilver> which might explain why they're less advanced.
01:43:36 <dancor> another thing that seems missing is a way to get the type of something inside a function, ghci :t only does top-level vars
01:45:12 <quicksilver> dancor: in general that's not very easy. The type might have free variables.
01:45:21 <quicksilver> but you're right it can be annoying
02:10:46 <cjs> They're also less advanced merely due to having seen much less work. The one for which I did read both paper and source, which is now several years old, looked pretty decent, though. Some things, I seem to recall, it did better than any Java refactoring tool I'd seen.
02:11:52 <quicksilver> cjs: dewfinitely.
02:18:33 <osfameron> could (&&) be defined as `mappend` ?
02:20:19 <osfameron> ah, Bool isn't a Monoid
02:25:49 <quicksilver> osfameron: given that bool has two perfectly good monoids it's probably a bit harsh to choose one over the other.
02:26:24 <quicksilver> I think Conor defines them both as newtypes, calling them Might and Must.
02:26:50 <osfameron> what do they do?
02:27:27 <quicksilver> well, one is && and one is ||
02:28:28 <sjanssen> Data.Monoid calls them Any and All
02:29:35 <Raevel> is it possible to describe a cfg by using another cfg?
02:29:59 <sjanssen> > getAny . mconcat $ [Any False, Any True]
02:30:00 <lambdabot>   True
02:31:04 <centrinia> Does (&&) and (||) short circuit?
02:31:42 <centrinia> > (and $ repeat False) || True
02:31:43 <lambdabot>   True
02:32:14 <mux> > True || undefined
02:32:15 <lambdabot>   True
02:33:14 <mib_fw0wvw42> > undefined || True
02:33:16 <lambdabot>   * Exception: Prelude.undefined
02:33:38 <centrinia> Hmm.
02:34:29 <quicksilver> centrinia: yes, they do.
02:34:33 <quicksilver> centrinia: from the left.
02:34:40 <quicksilver> True || short circuits
02:34:44 <quicksilver> and so does False &&
02:34:56 <quicksilver> given the nature of haskell evaluation you have to pick a bias.
02:34:56 <sjanssen> @src (||)
02:34:56 <lambdabot> True  || _ =  True
02:34:56 <lambdabot> False || x =  x
02:35:18 <quicksilver> conal has an 'unamb' extension to haskell for unbiased short-circuiting.
02:35:19 <centrinia> How can you make an unbiased disjunction?
02:35:48 <quicksilver> centrinia: by running to threads in parallel.
02:35:50 <quicksilver> two.
02:39:14 <centrinia> Is it a good idea to find cycle lengths of a function by inserting value-length pairs into a map like this: http://hpaste.org/13249
02:40:17 <centrinia> For some reason it takes longer than a minute to compute all the cycles of values between 1 and one million.
02:42:38 <sjanssen> centrinia: it's actually faster to not memoize
02:42:59 <centrinia> How do I not memoize?
02:43:12 <sjanssen> for some reason, Euler 14 is frequently asked about
02:43:17 <sjanssen> centrinia: don't use a Data.Map
02:43:37 <centrinia> What should I use?
02:43:47 <cizra> Hi. I'm trying to build cabal-install, but some dependency seems to be missing OSLT. How to debug?
02:43:52 <cizra> HTTP >=3000 && <3002, network >=1 && <3, unix >=2.0 && <2.4
02:43:59 <centrinia> Wait, people have tried this before?
02:44:13 <Dynetrekk> sjanssen: you guys doing euler 14?
02:44:23 <centrinia> No, I am.
02:44:32 <Axman6> cizra: install HTTP, network and unix?
02:44:44 <sjanssen> centrinia: I think you're the 5th person I've helped with this problem :)
02:45:00 <cizra> Axman6: um, how? Hunt for them in Hackage and install separately?
02:45:09 <centrinia> Okay, I'll read the IRC logs then. :)
02:45:14 <Dynetrekk> centrinia: I seem to have solved it and displaced my code :P
02:45:19 <centrinia> Thanks in advance. ;)
02:45:45 <sjanssen> centrinia: the best solution just uses a simple recursive function
02:45:48 <Axman6> cizra: cabal install should be able to do it. though there is a new HTTP library, try installing network and unix, and getting HTTP < 3002
02:45:49 <Dynetrekk> centrinia:  I can give you the number if you want :P
02:46:16 <sjanssen> centrinia: I have a hard time figuring out what buildmap n = snd $ until (\(i,m) -> length (filter (<= n) (keys m)) >= n) (\(i,m) -> (i+1,finditem m i)) (2,singleton 1 1)
02:46:20 <sjanssen> is supposed to do
02:46:27 <adrian> @src fix
02:46:27 <lambdabot> fix f = let x = f x in x
02:46:28 <Dynetrekk> centrinia: don't bother trying out both evens and odds, though
02:46:32 <Axman6> Dynetrekk: don't do that, it's cheating, and defeats the purpose
02:46:49 <centrinia> Dynetrekk, don't give me the answer. :(
02:46:51 <Dynetrekk> Axman6: sure, sure. it was a joke
02:47:01 <Axman6> good :)
02:47:16 <Dynetrekk> anyways, it doesn't matter (at least for me) if I have the number. I always try to find the _solution_...
02:47:24 <sjanssen> oh, I get it now
02:47:35 <sjanssen> centrinia: "length (filter (<= n) (keys m)) >= n" is really slow, don't do that
02:47:47 <cizra> Axman6: There's no such program as cabal in my box.
02:47:54 <centrinia> Okay.
02:48:02 <Axman6> cizra: oh, you don't have cabal-install installed?
02:48:16 <Dynetrekk> centrinia:  anyways, you can cut half the numbers by not considering both evens and odds (I think)
02:48:24 <Axman6> cizra: instal cabal install ;)
02:48:26 <Axman6> ll
02:48:38 <centrinia> Dynetrekk, I'm just putting cycle lengths in a Map.
02:48:47 <cizra> Axman6: 12:44 < cizra> Hi. I'm trying to build cabal-install
02:48:49 <centrinia> It should reduce more computations.
02:48:57 <Dynetrekk> centrinia: sounds useful.
02:48:59 <cizra> Axman6: But never mind, I'm already building the deps.
02:49:03 <jsn> ?localtime cirza
02:49:08 <Axman6> cizra: oh haha, sorry, i missed that part. yes get the packages off hackage, sorry :)
02:49:21 <jsn> hmm
02:49:55 <Axman6> @help localtime
02:49:56 <lambdabot> time <user>. Print a user's local time. User's client must support ctcp pings.
02:50:06 <Axman6> ?time Axman6
02:50:10 <lambdabot> Local time for Axman6 is Mon Dec 22 21:50:07 2008
02:50:14 <jsn> ?time jsnx
02:50:18 <jsn> ?time jsn
02:50:18 <lambdabot> Local time for jsn is 2008-12-22 02:50:18 -0800
02:50:20 <Axman6> how handeh
02:51:01 <jsn> i wonder why my localtime looks different
02:51:13 <cizra> ?time cizra
02:51:16 <lambdabot> Local time for cizra is Mon Dec 22 12:51:59 2008
02:51:27 <jeffz`> ?time jeffz`
02:51:29 <lambdabot> Local time for jeffz` is Mon Dec 22 21:51:29 2008
02:51:30 <cizra> Hmm, weird. Looks like a feature of IRC protocol.
02:51:39 <Axman6> cizra: it is
02:52:00 <Axman6> CTCP VERSION reply from cizra: irssi v0.8.12 :)
02:52:47 * cizra struggles with the syntax
02:52:59 <cizra>  /ctcp version Axman6 doesn't work
02:53:05 <adrian> I have a function f :: [Int] -> [Int]. It does some magic with the ints, the resulting list is longer. Due to rounding it eventually stops adding more ints
02:53:15 <cnwdup> cizra: /ctcp axman6 version, isn't it?
02:53:16 <abbe> cizra: /ctcp Axman6 version :P
02:53:31 <Axman6> it's irssi guys
02:53:44 <adrian> is there a tricky way to use fix to find the first occurence of the nonchanging value?
02:53:45 <abbe> :-D
02:54:22 <adrian> fix f gives the obvious fixed-point: bottom
02:54:36 <cizra> heh
02:54:37 <lilac> fix always gives the least(-defined) fixed point
02:54:48 <adrian> but I'd like to give f something to start with, like [1,2,3]
02:55:04 <Axman6> i saw an interesting quicksort written using fix earlier today
02:55:05 <lilac> so if you want to use fix, you need to ensure that your function has only the desired fixed point
02:55:19 <lilac> which means, for one thing, that the result on _|_ cannot be _|_
02:55:23 * Axman6 sees if he can remember it
02:55:28 <osfameron> quicksilver: sorry, went afk - hadn't realised that && and || were competing monoids... interesting (I only just began to understand what a monoid is, from the RWH explanation)
02:55:33 <Axman6> heh, no :(
02:55:48 <adrian> yes, but how would I do that?
02:56:10 <adrian> other than returning a list like iterate f [1,2,3] would
02:56:31 <lilac> you could start with \xs -> 1:2:3:drop 3 (f xs)
02:56:47 <adrian> interesting!
02:57:13 <lilac> fix on that will return you 1:2:3:_|_ for most values of f, though
02:57:13 <quicksilver> Axman6: he's trying to, that's the point :P
02:57:23 <quicksilver> Axman6: oops, replying scrolled up
02:57:26 <quicksilver> bad quicksilver
02:57:39 <Axman6> quicksilver: heh, what was that actually a reply to?
02:58:00 <Axman6> ah, cizra's thing, yes. m'bad
02:58:04 <lilac> adrian: but if each element of the list depends only on previous elements, that could work
02:58:11 <quicksilver> Axman6: you telling cizra to install cabal-install in respnse to his problems getting libraries installed so he could install cabal-install.
02:58:20 <quicksilver> Axman6: now, tht would be a good time to use 'fix' ;)
02:58:43 <Axman6> cabal install cabal-install; recursion: see recursion
02:58:53 <RayNbow> @seen dons
02:58:53 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 2h 43m 23s ago.
02:59:18 <fasta> cizra: what OS?
02:59:22 <cizra> fasta: Debian
02:59:43 <fasta> cizra: are you trying the script that was posted on the GHC mutterings blog?
02:59:51 <fasta> cizra: (since that one worked here)
02:59:57 <cizra> no, I'm trying to install cabal-install.
03:00:19 <fasta> cizra: then find the blog post and just do what is being said there.
03:00:34 <fasta> cizra: then you will have cabal-install in a few minutes.
03:00:36 <cizra> mm.. OK
03:01:14 <fasta> cizra: remember to read the comments, since there was a small bug in the script. It's a simple replacement that might already have been fixed.
03:02:41 <Axman6> > iterate (\n -> 1/(2+n)) 2
03:02:42 <lambdabot>   [2.0,0.25,0.4444444444444444,0.40909090909090906,0.4150943396226415,0.41406...
03:02:47 <Axman6> > iterate (\n -> 1/(2+n)) 2 :: Ratio
03:02:49 <lambdabot>       `Ratio' is not applied to enough type arguments
03:02:49 <lambdabot>      Expected kind `?',...
03:02:56 <RayNbow> @pl (\n -> 1/(2+n))
03:02:56 <lambdabot> (1 /) . (2 +)
03:03:00 <Axman6> > iterate (\n -> 1/(2+n)) 2 :: Rational
03:03:02 <lambdabot>   Couldn't match expected type `Rational' against inferred type `[a]'
03:03:08 <Axman6> > iterate (\n -> 1/(2+n)) 2 :: [Rational]
03:03:09 <lambdabot>   [2%1,1%4,4%9,9%22,22%53,53%128,128%309,309%746,746%1801,1801%4348,4348%1049...
03:03:54 <lilac> adrian: i think i'd do something like this: until (uncurry (==)) (\(_, xs) -> (xs, f xs)) ([],[1,2,3])
03:04:49 <adrian> put that much less arcance magic you have there
03:04:55 <adrian> *arcane
03:05:00 <Axman6> @hoogle ToDigit
03:05:00 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
03:05:00 <lambdabot> Data.Char intToDigit :: Int -> Char
03:05:16 <Axman6> @hoogle Char -> Int
03:05:17 <lambdabot> Data.Char digitToInt :: Char -> Int
03:05:17 <lambdabot> Data.Char ord :: Char -> Int
03:05:17 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
03:05:36 <adrian> axman6: toEnum and fromEnum
03:06:21 <lilac> adrian: if you prefer, until (x:y:_ -> x == y) tail $ iterate f [1,2,3]
03:09:39 <lilac> let vs = iterate f [1,2,3] in fst . head . filter (uncurry (==)) $ zip vs (tail vs)
03:10:09 <Axman6> hmm, i'm getting this algorithm wrong.
03:11:24 <Axman6> iterate (\n -> 1/(2+n)) 2 =/= 1+1/2 , 1+1/(2+1/2), 1+1/(2+1/(2+1/2)...
03:11:35 <Axman6> well, without the 1 out the front...
03:12:00 <Axman6> ah, just need the 1/2 istead of 2. my bad
03:17:20 <lilac> > iterate (\k -> 1+1/(1+k)) 1 :: [Rational]
03:17:22 <lambdabot>   [1%1,3%2,7%5,17%12,41%29,99%70,239%169,577%408,1393%985,3363%2378,8119%5741...
03:17:30 <ezrakilty> I have a function to contribute to Control.Applicative. How can I do it?
03:18:03 <lilac> ezrakilty: what's the function?
03:18:18 <ezrakilty> sequenceA, the counterpart to "sequence" for monads
03:18:50 <ezrakilty> > let sequenceA [] = pure []; sequenceA (x:xs) = (pure (:)) <*> x <*> (sequenceA xs)
03:18:51 <lambdabot>   <no location info>: parse error on input `;'
03:18:58 <lilac> there's already Data.Traversable.sequenceA
03:19:20 <ezrakilty> interesting
03:20:05 <ezrakilty> i suppose that does the trick; thanks!
03:20:45 <Peaker> @src sequence
03:20:45 <lambdabot> sequence []     = return []
03:20:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:20:45 <lambdabot> --OR
03:20:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
03:21:11 <lilac> @src sequenceA
03:21:11 <lambdabot> Source not found.
03:21:14 <Peaker> that sequenceA = foldr (liftA2 (:)) (pure [])
03:21:36 <quicksilver> ezrakilty: Traversable and Applicative are dual in an important way.
03:21:59 <quicksilver> ezrakilty: Applicatives are the most general things you can sequence, whilst Traversables are the most general things you can sequence over.
03:22:20 <quicksilver> [Foldables are the most general thing you can sequence_ over, with critical _ ]
03:22:31 <ezrakilty> intersting; is that written up anywhere?
03:23:03 <augustss> > fromRational (iterate (\k -> 1+1/(1+k)) 1 :: [Rational] !! 100)
03:23:04 <lambdabot>   Only unit numeric type pattern is valid
03:23:36 <augustss> > fromRational (iterate (\k -> 1+1/(1+k)) 1  !! 100)
03:23:37 <lambdabot>   1.4142135623730951
03:23:40 <Peaker> @src Foldable
03:23:40 <lambdabot> Source not found. I am sorry.
03:23:42 <Peaker> @src Traversable
03:23:42 <lambdabot> class (Functor t, Foldable t) => Traversable t where
03:23:42 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
03:23:42 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
03:23:43 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
03:23:43 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
03:24:25 <vegai> can I turn off specific warnings with a {-# LANGUAGE  specification?
03:24:29 <Peaker> Haskell' won't have all this duplication, right?
03:24:36 <augustss> vegai: no
03:24:37 <Peaker> vegai: which warning is annoying you?
03:24:55 <augustss> vegai: use {-# OPTIONS_GHC ...
03:25:09 <vegai> "Definition but no type signature for 'xxx'" is rather annoying for my modules using Parsec and HXT. Desirable for everything else, though.
03:25:31 <Peaker> hmm.. a script that uses -Wall output to add the type signatures could be nice :-)
03:25:40 <Peaker> though -Wall output is buggy and has wrong-inferred types
03:26:03 <augustss> Peaker: they are mostly ok
03:26:06 <vegai> I'd like to have global -Wall though... just limit it for specific cases a bit.
03:26:11 <centrinia> I had to write my Euler 14 solver in Python to solve it. :(
03:26:20 <lilac> > undefined :: 1
03:26:21 <lambdabot>       No instance for (Show Unit)
03:26:21 <lambdabot>        arising from a use of `show' at <int...
03:27:00 <vegai> augustss: oh, right. Yes. Point being that I can do *something* like this per-file
03:27:18 <augustss> centrinia: why?
03:27:34 <centrinia> The Haskell version took too long. :(
03:27:50 <centrinia> It also caused too many stack overflows. :(
03:27:51 <augustss> centrinia: compiled with -O2?
03:28:21 <lilac> @type undefined :: (1 + 1) ** (1 + 1 + 1)
03:28:22 <lambdabot> forall (** :: * -> * -> *) (+ :: * -> * -> *). ** (+ Unit Unit) (+ (+ Unit Unit) Unit)
03:28:25 <Peaker> augustss: I got restriction-free types in the "inferred type ..." -Wall output when it most definitely needed them (and copy&paste of the type also failed)
03:28:46 <Peaker> vegai: why is it important not to have the types specified?
03:28:52 <lilac> @type undefined :: let (+) = Either; (**) = (,) in (1 + 1) ** (1 + 1 + 1)
03:28:54 <lambdabot> parse error on input `let'
03:29:14 <vegai> Peaker: they clutter the code for these two specific cases
03:29:32 <centrinia> augustss, yes.
03:29:49 <vegai> Peaker: for instance: ParsecT [Char] u Identity [([Char], Either [Char] ([Char], [Char]))]
03:30:59 <Peaker> vegai: Doesn't ParsecT ... Identity have an alias: Parsec?  Don't these types have some nice aliases so it looks more sane?
03:31:16 <vegai> mm, could be.
03:35:07 <kosmikus> adrian: lhs2TeX: | in inline code can be escaped by writing ||
03:36:56 * dancor loves the 3x+1 problem
03:39:18 <RayNbow> @hoogle Unit
03:39:18 <lambdabot> Data.Generics data Unit
03:39:18 <lambdabot> Data.Generics Unit :: Unit
03:39:18 <lambdabot> Language.Haskell.Syntax unit_con :: HsExp
03:40:38 <quicksilver> vegai: type alisases can help but they are not as expressive as you would liike sometimes.
03:40:46 <quicksilver> mostly when you have lots of class contexts, I think.
03:42:48 <RayNbow> where/how does GHC translate the literal 1 into GHC.Generics.Unit?
03:42:58 <Axman6> > foldl' max 0 [1..10]
03:42:59 <lambdabot>   10
03:43:16 <Axman6> > foldl' max 0 ([1..10] ++ [1,7,3,7,3,21,8,9])
03:43:18 <lambdabot>   21
03:46:18 <cizra> Hmm.. What's this package named base?
03:46:29 <cizra> cabal: cannot configure vty-3.1.6. It requires base ==4.*
03:46:29 <cizra> There is no available version of base that satisfies ==4.*
03:46:38 <augustss> centrinia: takes about 2s to compute in Haskell if you memoize a little.
03:47:15 <quicksilver> cizra: that means that pacakge needs GHC 6.10, basically.
03:47:35 <cizra> quicksilver: Oh poopy. It's not in Debian Unstable, even.
03:47:49 <dcoutts> cizra: there's probably an older vty that works
03:48:00 <centrinia> augustss, I memoized a lot. :(
03:48:10 <Axman6> :t max`on`snd
03:48:12 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> b
03:48:17 <cizra> dcoutts: Sounds plausible. Is there an archive of them somewhere? Or do I have to dig in darcs history?
03:48:17 <augustss> centrinia: with an array?
03:48:20 <dcoutts> cizra: cabal install --dry-run 'vty < 3.1.6' and keep lowering the number til you find one that works
03:48:24 <centrinia> No. :(
03:48:33 <centrinia> I used a Map and then an IntMap
03:48:39 <Axman6> @src maximumBy
03:48:39 <lambdabot> Source not found. Just try something else.
03:48:51 <centrinia> @src maximum
03:48:51 <lambdabot> maximum [] = undefined
03:48:51 <lambdabot> maximum xs = foldl1 max xs
03:48:54 <jsn> Is there a way to "evaluate" a type synonym (type function, i guess)
03:48:56 <jsn> ?
03:49:05 <augustss> centrinia: I think the intermediates overflow Int
03:49:07 <cizra> dcoutts: oh, nice
03:49:11 <jsn> from GHCi, for example
03:49:16 <centrinia> How do you evaluate a type?
03:49:32 <jsn> type Paired a = (a, a)
03:49:41 <augustss> centrinia: huh?
03:49:49 <jsn> :t Paired Int    ----->    (Int, Int)
03:49:50 <lambdabot> Not in scope: data constructor `Paired'
03:49:50 <lambdabot> Not in scope: data constructor `Int'
03:50:00 <cizra> dcoutts: I guess it works. Thanks.
03:50:25 <dcoutts> cizra: I'll fix cabal install to handle that better in future. I think I know how to do it.
03:50:33 <centrinia> Oh, I was responding to jsn. ;)
03:51:00 <jsn> oh, i guess i could always use undefined
03:51:39 <quicksilver> dcoutts: I think it might help if cabal-install was explicitly aware than some packages are irretrievably tagged to certain compiler versions.
03:51:46 <centrinia> It also causes stack overflows if I used Map.
03:51:57 <jsn> so basically, i have a typeclass that has an associated monad
03:52:01 <quicksilver> dcoutts: "base-4 requires GHC 6.10 or NHC 12.12 - if the user has any earlier version, don't recommend it" ?
03:52:08 <jsn> and i am stacking monads with it
03:52:15 <hugo___> hello
03:52:17 <jsn> and it seems not to be working :)
03:52:19 <augustss> centrinia: http://hpaste.org/13251
03:52:20 <quicksilver> jsn: :i
03:52:22 <jsn> hugo___: hello
03:52:58 <quicksilver> jsn: should tell you what a synonym is, is that what you're afteR?
03:53:28 <dcoutts> quicksilver: perhaps, but it's hard to get that information.
03:53:36 <malcolmw> quicksilver: dcoutts: nhc98 does not care about which version of base you have - the compiler is not tied to it in the slightest
03:54:01 <dcoutts> quicksilver: the right thing is for the resolver to ignore packages that cannot be configured at all under any circumstance
03:54:07 <jsn> quicksilver: well, actually, i want to know, for example, that Paired Int is an (Int, Int)
03:54:20 <dcoutts> malcolmw: but is it sensible to upgrade base with nhc98 ?
03:54:38 <quicksilver> jsn: that is what :i will tell you.
03:54:44 <malcolmw> dcoutts: sure, no problem
03:54:52 <Axman6> :t compare`on` min.snd
03:54:53 <dcoutts> malcolmw: in theory or in practise?
03:54:53 <quicksilver> jsn: ah, you want the substitution. hmm.
03:54:53 <lambdabot> forall a b. (Ord b, Ord (b -> b)) => (a, b) -> (a, b) -> Ordering
03:54:55 <jsn> well, no it doesn't seem to
03:54:58 <centrinia> augustss, thanks. :)
03:55:02 <jsn> quicksilver: right
03:55:10 <quicksilver> malcolmw: well, that was an example number.
03:55:22 <Axman6> :t compare`on` (min.snd)
03:55:23 <lambdabot> forall a b. (Ord b, Ord (b -> b)) => (a, b) -> (a, b) -> Ordering
03:55:28 <centrinia> That memoization is a lot better than folding over a Map.
03:55:30 <quicksilver> malcolmw: I was just trying to be non-GHC specific and say 'there might be other compilers which do or do not support base-4'
03:55:32 <Axman6> :t maximumBy
03:55:33 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:55:34 <malcolmw> dcoutts: OK, granted there is currently no mechanism to upgrade base (until Cabal is tested to work with nhc98), but in theory, yeah, no problem
03:55:37 <dcoutts> malcolmw: eg for ghc cabal-install puts an explicit block on upgrading base on the theory that 1. it's unlikely to work and 2. it's probably not what the user intended.
03:56:05 <quicksilver> dcoutts: it wouldn't be hard to get that information if we chose to make it available ;)
03:56:14 <dcoutts> quicksilver: I think it's the wrong way round anyway
03:56:18 <quicksilver> dcoutts: "base.cabal: Compiler-Versions: ghc 6.10"
03:56:21 <quicksilver> perhaps
03:56:27 <quicksilver> the other way around might work too :)
03:56:46 <Axman6> @index on
03:56:46 <lambdabot> bzzt
03:56:53 <Axman6> @hoogle on
03:56:54 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:56:54 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
03:56:54 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:56:55 <dcoutts> quicksilver: we know that ghc cannot upgrade base, so we simply exclude all other versions of base with the reason (to use in error messages) that base cannot be upgraded.
03:57:23 <quicksilver> dcoutts: fair enough. I'm just trying to suggest this could somehow be present in the metadata, rather than hardwired.
03:57:41 <dcoutts> quicksilver: but it's not hardwired about base versions or ghc versions
03:57:51 <Axman6> (compare`on` (min.snd)) (1,4) (5,3)
03:57:55 <Axman6> > (compare`on` (min.snd)) (1,4) (5,3)
03:57:57 <lambdabot>       No instance for (Ord (b -> b))
03:57:57 <lambdabot>        arising from a use of `compare' a...
03:57:58 <dcoutts> quicksilver: it's just hardwired about a compiler and if it can upgrade base or not.
03:58:03 <Axman6> hmm
03:58:20 <dcoutts> quicksilver: and we've already got plenty of 'hardwired' info about compilers, though hopefully reasonably factored.
03:58:30 <Axman6> bleh, all i needed was compare`on` second
03:58:32 <Axman6> snd8
03:58:35 <augustss> Axman6: whats that min doig in there?
03:58:52 <Axman6> failing
03:58:56 <augustss> :)
03:58:59 <ronny> hi
03:59:22 <augustss> Axman6: on is a handy function
03:59:22 <ronny> anyone aware of tools that help with ide integration of haskell?
03:59:48 <cjs> Gragh! 'withCStringLen' and 'withCWStringLen' are not at all the same thing.
04:00:10 <jsn> cjs: that is surprising?
04:00:18 <cjs> Err....yes?
04:00:20 <ronny> [12:58]          igli | !pida specifically
04:00:20 <ronny> [12:58]  friendlyToas | PIDA is an excellent lightweight pyGTK IDE. ``PIDA loves *you*!'' (we might not tho ;)  http://pida.co.uk/ or #pida
04:00:25 <ronny> ops damn
04:00:30 <cjs> Why would the APIs have very similar names, yet be different?
04:00:32 <ronny> sorry, x11 paste
04:05:50 <Axman6> "For example, the current Big Bang model of the Universe suggests that it is 13.7 billion years (4.3 × 1017 seconds) old, and that the observable universe is 93 billion light years across (4.65 × 1026 metres)" hmm, that to me suggests that we ca see past the edge of the universe? being 13.7 billion years old, couldn't things only possibly be 27.4 billion lightyears apart in that time?
04:06:55 <quicksilver> Axman6: the fabric of space time itself is expanding, like a bubble blowing up, is I believe the orthodox explanation.
04:06:56 <Axman6> there are supposed to be some powers of 10 in those brackets, not that that affects what i'm on about :)
04:07:27 <quicksilver> Axman6: whether you believe that or not is up to you :P
04:07:54 <Axman6> see, this is why i'm glad i only had to do one semester of physics. i love the topics, but some of it just messes up your brain
04:08:01 <MiniCow> Axman6: If not the universe is only about 5 miles wide :-P
04:09:20 <Axman6> MiniCow: well that would be handy
04:09:29 <centrinia> Axman6, I was a little worried when you said that the Universe is 4.31017 seconds old. :p
04:09:42 <Axman6> heh
04:10:28 <quicksilver> @faw Can haskell see beyond the observable universe?
04:10:29 <lambdabot> The answer is: Yes! Haskell can do that.
04:10:39 <centrinia> Axman6, the universe might not have just expanded due to your usual Hubble expansion.
04:10:43 <centrinia> It could have inflated too.
04:10:54 <quicksilver> Axman6: http://en.wikipedia.org/wiki/Metric_expansion_of_space
04:11:29 <centrinia> @faq Can the expansion of the Universe be lazily evaluated by Haskell?
04:11:29 <lambdabot> The answer is: Yes! Haskell can do that.
04:13:06 * MiniCow is signing the Galaxy Song (http://uk.youtube.com/watch?v=OcTHBOjnUss)
04:15:51 <PeakerWork> I wrote a whole bunch of code in the Maybe monad, but then I discover that I want more elaborate error reporting than just Nothing.. In IO I'd just print something there -- Would you suggest converting a lot of code to be in the Either monad instead?
04:16:06 <Axman6> quicksilver: i asked in ##physics and got pretty much the same answer
04:16:17 <vixey> just replace mzero with throwError ""
04:16:29 <quicksilver> Axman6: did they also call you rude things?
04:16:41 <quicksilver> vixey: that's roughtly what mzero already is.
04:16:41 <Axman6> no, they were quite nice :0
04:16:42 <Axman6> :)*
04:16:51 <quicksilver> if he'd been using mzero he wouldn't have much to change.
04:16:53 <vixey> yes quicksilver
04:17:39 <PeakerWork> @src MonadError
04:17:40 <lambdabot> class (Monad m) => MonadError e m | m -> e where
04:17:40 <lambdabot>     throwError :: e -> m a
04:17:40 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
04:18:18 <PeakerWork> vixey: Yeah, also better fix a lot of the types from Maybe to some more abstract type name
04:18:41 <Axman6> ok, here's a nice mathematical problem: say i have two large numbers, raised to large powers (x10^6 sized base and exponents). what would be a goo way of comparing those numbers efficiently?
04:19:19 <vixey> > 3 < 5 -- > 3*10^6 < 5*10^7
04:19:20 <lambdabot>   True
04:20:08 <jsn> write the numbers to a file
04:20:18 <jsn> first test the length of the file
04:20:25 <Axman6> > 632382^518061 > 519432^525806
04:20:28 <lambdabot>   True
04:20:36 <jsn> if one file is shorter than the other, then you know
04:20:44 <Axman6> need to do that for 100 numbers
04:21:03 <Axman6> (yes this is for project euler, i'm more interested in the maths of this problem though)
04:21:11 <jsn> do you have the exponents separated from the numbers?
04:21:23 <Axman6> yes
04:21:23 <jsn> they are floating point or integer?
04:21:28 <Axman6> integer
04:21:37 <jsn> negative exponents?
04:21:41 <Axman6> nope
04:23:49 <jsn> all the mantissas are six digits?
04:23:57 <zoq> Axman6: use logs
04:24:19 <Axman6> zoq: yeah i was thinking that, i coudn't see an obvious way to do it in my current tired state though
04:24:30 <Axman6> jsn: some are 5
04:24:37 <jsn> curses
04:24:48 <zoq> a^b = exp(b*log a)
04:25:06 <Axman6> jsn: they could be filtered out though no?
04:25:22 <zoq> So, a^b < c^d  <==> b*log a < d*log c
04:25:29 <jsn> well, no, you have to normalize somehow if they aren't all the same length :)
04:25:32 <Axman6> ah, excelent
04:25:36 <jsn> string sort is not going to do it
04:26:24 <vixey> > let (a^b) = b*log a in 632382^518061 > 519432^525806
04:26:25 <lambdabot>   <no location info>: Parse error in pattern
04:26:30 <vixey> > let a^b = b*log a in 632382^518061 > 519432^525806
04:26:31 <lambdabot>   True
04:28:08 <vixey> has anyone read Simply Easy?
04:30:39 <augustss> vixey: yes
04:30:48 <Ferdirand> aha, someone doing project euler :)
04:30:49 <augustss> I think it's neither :)
04:31:09 <vixey> yeah they presentation is strange, with the inferable/checkable distinction
04:31:45 <Ferdirand> i find the "sort by ascending difficulty" option horribly misleading
04:31:51 <augustss> vixey: oh, that part doesn't bother me so much as all the machinery they have.  with a lot of duplication
04:32:37 <vixey> the quotation stuff?
04:33:01 <augustss> vixey: yeah
04:33:21 <augustss> vixey: duplicating things on the value and expression level
04:33:52 <paolino> what extensions are needed to instantiate  MonadState?
04:34:09 <vixey> I was thinking about how tto change it for a type directed conversion check
04:34:34 <vixey> (for proof irrelevance and eta, I think you can do it with type directed conversion)
04:34:43 <paolino> I'm confused by the fundep there also...
04:35:03 <jsn> @src MonadState
04:35:03 <lambdabot> Source not found.
04:35:28 <paolino> class (Monad m) => MonadState s m | m -> s where
04:35:28 <paolino>   get :: m s
04:35:28 <paolino>   put :: s -> m ()
04:35:44 <vixey> but it's not very straightforward.. getting rid of values would probably help
04:36:11 <augustss> vixey: The way they do things might be good for a larger system, but for didactic purposes I think it's suboptimal.
04:37:15 <adh0c> hi
04:37:45 <adh0c> so, how would I go about applying a String function to a FilePath type?
04:38:04 <Axman6> thanks zoq, this should work great (took a little while because i found a bug in my text editor)
04:38:21 <paolino> I understand the fundep as only m is needed to define an instance
04:38:58 <paolino> which should avoid the MultiParamTypeClasses flag
04:39:12 <Axman6> zoq: yep, worked great, ran in 0.072s, thanks
04:39:25 <BeelsebobWork> hmm, is there somewhere instance Monoid b => Monoid (a -> b)?
04:39:39 <Axman6> @instances Monoid
04:39:40 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:39:44 <BeelsebobWork> ah, cool
04:39:46 <Axman6> yes >_>
04:39:51 <BeelsebobWork> I didn't know lambdabot did that already
04:40:04 <zoq> Axman6: :)
04:40:05 <BeelsebobWork> @src (a -> b) mempty
04:40:06 <lambdabot> Source not found. There are some things that I just don't know.
04:40:15 <BeelsebobWork> @src ((->) a b) mempty
04:40:15 <lambdabot> Source not found. My mind is going. I can feel it.
04:40:18 <BeelsebobWork> >.<
04:40:38 <augustss> @src mempty (a -> b)
04:40:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:40:43 <adh0c> so could anyone help me?
04:41:00 <Axman6> > "test" :: FilePath
04:41:02 <lambdabot>   "test"
04:41:12 <augustss> BeelsebobWork: I'm guessing it's id
04:41:12 <paolino> @src FilePath
04:41:12 <lambdabot> type FilePath = String
04:41:18 <Axman6> > map toUpper ("test" :: FilePath)
04:41:20 <lambdabot>   "TEST"
04:41:33 <Axman6> :t map toUpper ("test" :: FilePath)
04:41:34 <lambdabot> [Char]
04:41:34 <BeelsebobWork> augustss: my hope is that it's mempty = const . mempty; mappend = \x -> f x `mappend` g x
04:41:48 <Axman6> adh0c: does it somplain when you try and do it?
04:41:54 <adh0c> yes
04:42:13 <augustss> BeelsebobWork: yes, but functions are monoid with . and id
04:42:31 <augustss> BeelsebobWork: Endo might be the one you want
04:42:42 <augustss> @src Endo
04:42:43 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
04:42:49 <Axman6> > let f :: FilePath -> String; f = map id in f ("test" :: FilePath)
04:42:51 <lambdabot>   "test"
04:42:57 <BeelsebobWork> augustss: :(
04:42:58 <Axman6> :t let f :: FilePath -> String; f = map id in f ("test" :: FilePath)
04:43:00 <lambdabot> String
04:43:06 <BeelsebobWork> oh well, my own monoid def then
04:43:08 <Deewiant> @src (->) mempty
04:43:09 <lambdabot> Source not found. :(
04:43:10 <Axman6> :t let f :: FilePath -> String; f = map id in f
04:43:12 <lambdabot> FilePath -> String
04:43:18 <Axman6> adh0c: how about that?
04:43:23 <adh0c> hm
04:43:28 <adh0c> now it seems to shut up
04:43:30 <augustss> BeelsebobWork: Well, what are you supposed to do when something can be a monoid in many ways?  Like the integers.
04:43:34 <Axman6> :t let f :: FilePath -> String; f = id in f
04:43:35 <lambdabot> FilePath -> String
04:43:42 <adh0c> ok, another problem
04:43:46 <Axman6> adh0c: ^^ even better :P
04:43:47 <BeelsebobWork> augustss: good question
04:43:48 <BeelsebobWork> > mempty 5
04:43:50 <lambdabot>   ()
04:43:53 <BeelsebobWork> ah, interesting
04:44:00 <BeelsebobWork> > mempty 5 :: [Int]
04:44:01 <lambdabot>   []
04:44:08 <BeelsebobWork> cool, that is const mempty by the looks of it
04:44:12 <paolino> anyone has ideas on the MonadState needed flags ?
04:44:22 <augustss> BeelsebobWork: maybe it's the one you want after all.  Yeah, it must be
04:44:30 <adh0c> I would like to display contents of a folder entry by entry, but haskell won't let me map putStrLn over getDirectoryContents' results
04:44:37 <BeelsebobWork> > (const [5]) `mappend` (const [10]) 5
04:44:38 <lambdabot>   Couldn't match expected type `b -> [t]'
04:44:46 <BeelsebobWork> > ((const [5]) `mappend` (const [10])) 5
04:44:47 <augustss> BeelsebobWork: silly me, a->b is not a monoid, a->a is.  And that's Endo
04:44:47 <lambdabot>   [5,10]
04:44:52 <paolino> adh0c: that's an IO issue
04:44:54 <BeelsebobWork> ah, cool
04:44:59 <BeelsebobWork> so yay, that is the instance I want :)
04:45:02 <adh0c> yes I know
04:45:10 <paolino> :t getDirectoryContents
04:45:11 <lambdabot> Not in scope: `getDirectoryContents'
04:45:22 <augustss> adh0c: mapM
04:45:27 <paolino> use mamM
04:45:30 <adh0c> I would like to know if there is another method of dealing with IO types instead of do blocks with <- assignments
04:45:30 <Axman6> adh0c: getDirectoryContents >>= return [].putStrLn maybeh?
04:45:43 <Axman6> or sequence_
04:45:50 <Axman6> :t sequence_
04:45:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:46:08 <Axman6> :t sequence_ putStrLn
04:46:09 <lambdabot>     Couldn't match expected type `[m a]'
04:46:09 <lambdabot>            against inferred type `String -> IO ()'
04:46:09 <lambdabot>     In the first argument of `sequence_', namely `putStrLn'
04:46:17 <Axman6> ah yeah, my bad
04:46:18 <augustss> adh0c: getDirectoryContents >>= mapM_ putStrLn
04:46:31 <Axman6> what augustss said
04:47:02 <augustss> adh0c: or do fs <- getDirectoryContents; mapM_ putStrLn fs
04:47:44 <adh0c> I said I wanted to find a more elegant way
04:47:46 <adh0c> anyway
04:47:54 <adh0c> mapM_ and mapM bitch at me
04:48:02 <Axman6> @undo do fs <- getDirectoryContents; mapM_ putStrLn fs
04:48:03 <lambdabot> getDirectoryContents >>= \ fs -> mapM_ putStrLn fs
04:48:09 <adh0c> expected [String] inferred IO [FilePath]
04:48:44 <Axman6> what's wrong with do notation? it makes it clear what you're doing
04:48:57 * paolino gives up undderstanding MonadState needed flags
04:49:05 <adh0c> it's borderline imperative
04:49:14 <PeakerWork> @type Data.Map.mayMaybe id
04:49:14 <Axman6> it is imperative
04:49:15 <lambdabot> Not in scope: `Data.Map.mayMaybe'
04:49:20 <PeakerWork> @type Data.Map.mapMaybe id
04:49:21 <lambdabot> forall b k. (Ord k) => M.Map k (Maybe b) -> M.Map k b
04:49:26 <PeakerWork> cool :)
04:49:32 <adh0c> well, that's kind of the point
04:49:54 <PeakerWork> any nicer way to do: if Map.null result then Nothing else Just . Branch $ result
04:50:01 <adh0c> if haskell is a purely functional language like it claims, there should be a way of doing what I want to do without the do block
04:50:05 <Axman6> adh0c: you're working with IO, you'll probably need to use do notation
04:50:21 <vixey> adh0c, lol
04:50:31 <adh0c> so in other words I have to use <- ?
04:50:37 <Axman6> adh0c: do blocks are just sugar for the monad notation of >> and >>=
04:50:55 <PeakerWork> adh0c: The IO DSL in Haskell *is* an imperative language
04:51:06 <Axman6> no, you can use getDirectoryContents >>= mapM_ putStrLn
04:51:17 <augustss> adh0c: As I first showed, you don't need 'do'.  But when doing imperative things, imperative notation can be easier to use.
04:51:39 <adh0c> I see
04:51:49 <adh0c> one last question (I think)
04:52:12 <adh0c> is there a nice way of filtering out elements of a list with one filter?
04:52:30 <adh0c> I've seen filter (`notElem` <list>) on realworldhaskell
04:52:40 <adh0c> but that somehow doesn't work
04:53:05 <vixey> > filter (`notElem` "aoeui") ['a'..'z']
04:53:06 <lambdabot>   "bcdfghjklmnpqrstvwxyz"
04:53:08 <augustss> > filter (`notElem` [1,2]) [1,2,3,4,5]
04:53:09 <lambdabot>   [3,4,5]
04:53:15 <Axman6> > filter (`notElem` [1,2,3]) [1,4,2,5,3,76,2,7]
04:53:16 <lambdabot>   [4,5,76,7]
04:53:22 <skorpan> > filter (`notElem` "abc") "abc"
04:53:23 <lambdabot>   ""
04:53:27 <skorpan> see, i can too!
04:53:27 <Axman6> > filter (`elem` [1,2,3]) [1,4,2,5,3,76,2,7]
04:53:29 <lambdabot>   [1,2,3,2]
04:53:31 <b_jonas> wow
04:53:55 <augustss> So many people who know filter!
04:54:09 <adh0c> it doesn't work with filter (`notElem` [".",".."]) getDirectoryContents <path>
04:54:25 <augustss> adh0c: It's the monad thing again
04:54:35 <skorpan> > :t filterM
04:54:36 <lambdabot>   <no location info>: parse error on input `:'
04:54:36 <b_jonas> adh0c: that's boh a paren error and a type error
04:54:40 <skorpan> :t filterM
04:54:40 <Axman6> adh0c: because getDirectoryContents is type IO [FilePath] right?
04:54:41 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:54:49 <b_jonas> skorpan: no
04:54:52 <adh0c> yes
04:54:58 <b_jonas> you don't need filterM there
04:55:12 <b_jonas> filerM is for when the condition is an action
04:55:18 <skorpan> ah
04:55:20 <Axman6> adh0c: basically, there's quite a few errors in your code, want to paste it so we can annotate it? (on hpaste)
04:55:31 <augustss> adh0c: do fs <- getDirectoryContents; let fs' = filter (`notElem` [".",".."]) fs; print fs'
04:55:44 <adh0c> Axman6, it's just the line
04:55:49 <blackh> adh0c: "getDirectoryContents" is of type IO [FilePath] which means that it is not a list of filepaths, - rather, it's "a computation that hasn't been executed yet"
04:56:06 <lilac> adh0c: liftM (filter (`notElem` [".",".."])) $ getDirectoryContents <path>
04:56:14 <baaba> @hoogle Maybe a -> a
04:56:14 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
04:56:14 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
04:56:14 <lambdabot> Data.Monoid First :: Maybe a -> First a
04:56:21 <adh0c> is there a command that will force it to execute, blackh?
04:56:28 <PeakerWork> baaba: maybe is nice
04:56:32 <PeakerWork> @type maybe
04:56:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:56:42 <lilac> adh0c: or nicer: filter (`notElem` [".", ".."]) <$> getDirectoryContents <path>
04:56:46 <Axman6> adh0c: just so you know, IO feels very strange to begin with, but once you understand what's going on, you'll be sweet
04:56:56 <skorpan> <$> is "ap", no?
04:56:57 <lilac> adh0c: the latter uses <$> from Control.Applicative, which is a synonym for fmap
04:57:00 <adh0c> Axman6, I hope so
04:57:01 <PeakerWork> skorpan: <$> is fmap
04:57:03 <skorpan> darn it
04:57:05 <skorpan> what is ap?
04:57:07 <EvilTerran> <*> is ap
04:57:11 <skorpan> i see
04:57:11 <blackh> adh0c: If you do fs <- getDirectoryContents "path" it'll execute
04:57:22 <lilac> well, <*> is to Applicative as ap is to Monads
04:57:30 <Axman6> adh0c: took me a while. but playing with do notation does help. so i advise you try using it.
04:57:31 <adh0c> I wish I had more time to learn all of this
04:57:48 <baaba> > let f = fromMaybe 1234 in loeb $ Just f
04:57:48 <lambdabot>   Not in scope: `loeb'
04:57:56 <baaba> :(
04:58:15 <blackh> adh0c: People are mentioning various tricks to make the syntax shorter, but it's best to start with plain old <-, and quite often that's the best way to do things anyway, because it's clear.
04:58:20 <baaba> > let f = fromMaybe 1234; loeb xs = fmap (\x -> x (loeb xs)) xs in loeb $ Just f
04:58:21 <lilac> @let loeb x = fmap (\a -> a (loeb x)) x
04:58:22 <lambdabot>  Defined.
04:58:32 <ehird> are we _still_ loebing?
04:58:35 <lambdabot>   thread killed
04:58:44 <b_jonas> not loeb again!
04:58:45 <lilac> ehird: loeb is /cool/ :)
04:58:47 <Axman6> what's loeb?
04:58:52 <ehird> Axman6: loeb is loeb.
04:58:54 <adh0c> realworldhaskell gets kind off convoluted around the IO part :S
04:58:58 <lilac> Axman6: http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
04:59:03 <blackh> adh0c: If you want to learn quickly, ask more questions here.
04:59:03 <b_jonas> Axman6: some thing with fix
04:59:38 <Axman6> adh0c: want me to try and explain it to you in a basic way?
04:59:56 <adh0c> yes please
05:01:37 <lilac> adh0c: "IO a" is a computation which produces an a, in much the same way that "Int -> a" is a computation which produces an a
05:01:41 <Axman6> ok, well probably the best way to start thinking about is, is when you see a function f :: IO a, think of it containing an a, which is the result of the IO you're doing. other functions can't work on it directly when it's of type IO a, so you need to use do { x <- f; ...}. you can think of that as setting the x to the a inside the IO a, just taking it out of its box
05:01:45 <b_jonas> how was the definition of loeb with fix?
05:02:07 <adh0c> ok
05:02:48 <Axman6> adh0c: so, say you have g :: IO String, a function that has the type String -> Bool obviously can;t work on that, right?
05:02:56 <adh0c> yes
05:02:59 <Cale> If f :: IO a, then f is not itself a function.
05:03:13 <Axman6> so, you need to take the string out of the box, and then apply g to it
05:03:26 <Axman6> Cale: don't confuse things :P
05:03:33 <Cale> okay :)
05:03:41 <adh0c> so would f >>= g work?
05:03:44 <Cale> (It is an action)
05:03:46 <b_jonas> @let loeb f = fix (\a -> fmap ($a) f)
05:03:47 <lambdabot>  <local>:4:0:
05:03:47 <lambdabot>      Warning: Pattern match(es) are overlapped
05:03:47 <lambdabot>               In...
05:03:49 <Axman6> i find it easier to first get an understanding of how to use things like IO, then find out what's actually going on
05:04:00 <b_jonas> @run loeb [const 3, fmap(*2)(!!0)]
05:04:02 <lambdabot>   [3,6]
05:04:04 <lilac> I'm not sure IO-as-values-in-boxes is useful -- the IO action /hasn't happened yet/ so there's no value yet
05:04:06 <b_jonas> that was it, yeah
05:04:13 <Axman6> adh0c: not quite, since g would have to have the type g :: String -: IO String
05:04:15 <b_jonas> @unpl ($a)
05:04:15 <lambdabot> (\ b -> b a)
05:04:19 <b_jonas> @pl (\b -> b a)
05:04:19 <lambdabot> ($ a)
05:04:22 <blackh> adh0c: Something of type "IO a" represents a thing that can give you an a when you explicitly execute it.
05:04:28 <Cale> adh0c: Think of a value of type (IO t) as a program which if it was to be run, would produce for you a value of type t.
05:04:32 <Cale> yeah
05:04:34 <Axman6> lilac: it helps to think about it for a beginner though
05:04:43 <Axman6> you're all making it confusing >_<
05:04:50 <adh0c> D:
05:05:09 <Axman6> just trying to get adh0c to the point where he can use IO, then what's actually going on can be explained later
05:05:12 <lilac> Axman6: the difference between an IO value and a hygenically boxed value is essential though, otherwise "a >> a" is going to be baffling
05:05:16 <augustss> I think that regarding IO t as a t in a box is not a bad idea.  It makes you realize you can operate on the t directly.
05:05:25 <b_jonas> adh0c: if you're asking a channel don't expect the whole channel to have the same opinion on what the best way to explain something is
05:05:40 <Axman6> lilac: which i'll get to :)
05:05:46 <b_jonas> some lurkers aren't yet integrated to the hivemind yet
05:06:03 <augustss> lilac: opening the box can wreak havoc, of course ;)
05:06:28 <Axman6> augustss: yes, that's why i'm explaining it that way :)
05:06:30 <b_jonas> what on earth is this boxed thing?
05:06:53 <adh0c> it's a thing in a box
05:06:54 <augustss> All monads are boxes.  Or space suits.
05:07:00 <Cale> heh
05:07:07 <Axman6> adh0c: yep :P
05:07:15 <b_jonas> to me, boxed is like
05:07:17 <b_jonas> +-+
05:07:21 <b_jonas> |a|
05:07:22 <b_jonas> +-+
05:07:24 <b_jonas> that's a boxed a
05:07:33 <adh0c> ASCII graphics :o
05:07:48 <EvilTerran> this is #haskell, not #epigram!
05:07:56 <b_jonas> ok, then
05:08:04 <b_jonas> > Identity 'a'
05:08:05 <lambdabot>       No instance for (Show (Identity Char))
05:08:05 <lambdabot>        arising from a use of `sh...
05:08:07 <ehird> a# ->
05:08:07 <ehird> a
05:08:09 <adh0c> you mean #haskell can't be #fun from time to time?
05:08:09 <ehird> it escapes!
05:08:43 * EvilTerran wonders why there isn't an instance Show a => Show (Identity a)
05:08:46 <Cale> adh0c: Here's how I'd explain it (at least for IO)... a value of type (IO t) is a program, or action, which if run will produce a value of type t. Normal Haskell evaluation doesn't cause an IO action to run.
05:09:06 <Axman6> adh0c: so, do you want to try something? how about (using do notation because it'll be easier) you make a function myPrint :: IO (), which uses getLine to take a line from the terminal, and then prints it out using putStrLn
05:09:21 <Axman6> :t getLine
05:09:22 <lambdabot> IO String
05:09:28 <Axman6> :t putStrLn
05:09:29 <lambdabot> String -> IO ()
05:10:08 <adh0c> do { x <- getLine; putStrLn x}
05:10:13 <Axman6> yep :)
05:10:28 <Cale> adh0c: Yeah, and eventually, you define main to be one of these IO actions.
05:10:44 <Cale> (it's not really right to call them functions because they have no parameters)
05:10:59 <Axman6> so x <- 'takes the string out', and putStrLn uses that String to print
05:11:22 <Axman6> adh0c: ok, what about taking in two lies, and out putting them, concatenated together?
05:11:23 <Cale> Another way to say it is that x <- getLine  *runs* the action getLine to produce x.
05:11:44 <Cale> Whereas if you wrote  let x = getLine, it would define x to be the same action as getLine
05:12:11 <adh0c> do { x <- getLine; y <- getLine; putStrLn (concat ([x]++[y]))}
05:12:32 <Axman6> Cale: from my experience learning IO, i know that being told it was all programs that got run to ... well that's where i got lost. the boxes idea works for me :)
05:12:47 <Axman6> adh0c: well, putStrLn (x++y) would work too :P
05:12:53 <Axman6> but yes
05:13:32 <adh0c> afk for a while, dinner
05:13:38 <Axman6> ok
05:14:46 <Axman6> Cale: it's like teaching electrical engineering using the idea of water through pipes. the anology breaks down pretty quickly, but it's very useful for many parts of it.
05:15:24 <b_jonas> I still don't get how the boxing goes to IO
05:16:07 <Axman6> b_jonas: something of type IO a is an a, inside an IO box. you use x <- f :: IO a to take the a out, and work with it
05:16:39 <Axman6> like Maybe a has an a inside it (half the time >_>)
05:16:58 <b_jonas> oh, so it's like Shroedinger boxes for which you don't know what you'll get out till you actually open them?
05:17:14 <Axman6> yeah, that works :0
05:17:17 <Axman6> :)*
05:18:30 <Axman6> hmm, i'm starting to think i could write a nice tutorial on IO, i'm sure no one else has done it >_>
05:18:46 <Badger> go go go :)
05:19:18 <Axman6> hmm, to lhs or not lhs
05:19:40 <Axman6> gahh, i wish it was christmas already so i could get my iLap
05:19:41 <b_jonas> as in literal programming?
05:20:01 <Axman6> b_jonas: if that's the same as literate haskell, then yes...
05:20:03 <mapreduce> literate, I expect.
05:20:13 <b_jonas> literate, yeah
05:20:30 <adh0c> I wish Haskell would be allowed as a language on matura exams
05:20:37 <b_jonas> that thing where you have to runghc Setup.lhs if Setup.hs doesn't exist
05:20:44 <adh0c> we only have C, C++ and Pascal (ewwwwwwww)
05:20:55 <Axman6> ew :(
05:21:00 <b_jonas> adh0c: run haskell from C with the ffi
05:21:08 <Axman6> we learnt haskell as our first language in uni
05:21:13 <ehird> b_jonas: ouch.
05:21:15 <adh0c> we used to have Java available, but apparently someone thought it was too innovatory and removed it
05:21:23 <ehird> adh0c: . . .
05:21:32 <ehird> Your life must be awful. :D
05:21:37 <b_jonas> ehird: if you write almost everything in haskell then the interfacing won't get compilcating
05:21:39 <adh0c> nah
05:21:56 <mapreduce> adh0c: Perhaps choosing a different education establishment might be smart.
05:22:01 <adh0c> I'll try and get high scores on SATs and ACTs and IELTS and apply to a western uni
05:22:15 <adh0c> mapreduce, obviously you don't know much about Polish education system
05:22:43 <mapreduce> I know that Polish people are entitled to get their education in other EU countries.
05:22:50 <b_jonas> adh0c: if you want to come here as a foreign student all you need is money, no tests
05:22:54 <b_jonas> lots of money though
05:22:57 <adh0c> what
05:23:04 <b_jonas> well, almost
05:23:09 <b_jonas> there are some tests
05:23:09 <ehird> mapreduce: I'm not sure "not allowing Haskell" is a justifiable reason to go to a university in another country.
05:23:27 <hugo___> in what cases would i use the monad reader ?
05:23:29 <mapreduce> ehird: It wasn't so much what wasn't allowed as what was.
05:23:31 <b_jonas> but those are needed only if you want to complete education, not just start it
05:23:45 <mapreduce> Though you can certainly do a lot with C++.
05:23:49 <adh0c> Polish universities are mostly diploma mills that treat students as something that you should get rid of as fast as you can so you can fill in more grant papers
05:23:57 <ehird> mapreduce: I'd rather have a C/C++/Pascal school than a Java school
05:24:12 <adh0c> ehird, me too, but that's not the point
05:24:20 <ehird> :-P
05:24:22 <b_jonas> hugo___: when you don't like the name "id" and want a longer but more abstract name for it?
05:24:25 <mapreduce> ehird: I'd rather not have either.  I find it hard to choose the worst.
05:24:30 <b_jonas> no wait
05:24:37 <ehird> mapreduce: Hey, I like C. :P
05:24:42 <adh0c> I was just talking about discriminating against languages that aren't ancient
05:24:42 <pejo> mapreduce, the other universities doesn't have to accept people though.
05:24:56 <b_jonas> hugo___: if you want to pass around an implicit parameter and you're working in monads anyway
05:25:01 <mapreduce> ehird: So do I, it's cute in a backward kind of way.
05:25:13 <ehird> mapreduce: Oh please. :P
05:25:15 <mapreduce> But I do think people should learn in at least one language that has GC.
05:25:25 <ehird> Boehm. *is mauled*
05:25:34 <adh0c> I think computer engineering should definitely teach very low level stuff
05:25:49 <ehird> Anyway, this is quite the detour.
05:25:56 <mapreduce> adh0c: Yes, and computer science should teach high level stuff.
05:25:56 <adh0c> but not base the whole curriculum on it and not acknowledge anything that isn't older than half of the staff
05:25:57 <b_jonas> I think they should teach both low-level and high-level
05:26:06 <hugo___> hmm, my app initialization starts by building a state (by storing lots of static fileIO into memory data structures), this state is then fed into the functions im using... is this a good case for a reader monad ?
05:26:22 <b_jonas> high-level so you can get fun and low-level so they don't expect linear search in a long xml to run in constant time
05:26:23 <PeakerWork> ghc decided that I have a kind mismatch in some good old code, after adding bad new code - how do I know why/where ghc figures the kind to be what it is?
05:26:35 <cnwdup> @pl (\xs y -> (fst y) `elem` (map fst xs))
05:26:36 <lambdabot> flip (elem . fst) . map fst
05:27:23 <ivanm> pandoc fails when building with 6.10 because waitforprocess has a duplicate definition :s
05:27:40 <b_jonas> > var
05:27:41 <lambdabot>       Ambiguous occurrence `var'
05:27:41 <lambdabot>      It could refer to either `Data.Number.S...
05:29:21 <b_jonas> that's strange because the file says 'import SimpleReflect hiding (var)'
05:29:26 <b_jonas> maybe someone changed that
05:30:23 <mapreduce> b_jonas: I think you could teach only high level and not expect students to think linear search in a long xml file runs in constant time.
05:30:31 <mapreduce> That's not to say you should teach only high level.
05:31:12 <adh0c> knowing the low level stuff is a must if someone wants to claim to be a computer scientist/engineer
05:31:31 <mapreduce> I like the idea of teaching, say, Scheme and assembler at the same time, then ML/Haskell and C, then C#, kind of converging between high and low extremes.
05:31:45 <adh0c> without it, you're like a car mechanic that can only talk about rims and windshields
05:32:07 <hugo___> adh0c: low level stuff, like what ?
05:32:32 <ehird> Scheme is a high extreme?
05:32:34 <b_jonas> hugo___: like bytes instead of lambdas
05:32:49 <mapreduce> ehird: Yes.
05:32:51 <adh0c> start with theory of computers, then go through real examples of processors and memory addressing, then gradually increase abstraction
05:33:10 <ehird> mapreduce: Err, more so than Haskell??
05:33:15 <ehird> I must disagree.
05:33:18 <hugo___> b_jonas: for that i just use Data.ByteString :)
05:33:22 <mapreduce> ehird: Yes.
05:33:33 <b_jonas> because even though lambdas are very much real, our computers cannot handle them natively so they emulate them by throwing bytes around
05:33:43 <ehird> "Scheme is more high-level than Haskell" - another entry for the "unlikely things heard in #haskell" list
05:33:45 <b_jonas> and bytes are what flow in the pipes
05:33:49 <b_jonas> of the internet
05:33:54 <adh0c> you mean tubes
05:33:55 <b_jonas> or tubes
05:33:58 <b_jonas> yeah, tubes
05:34:02 <hugo___> youtubes ?
05:34:07 <hugo___> yahoo pipes ?
05:34:11 <hugo___> im not getting it...
05:34:11 <b_jonas> a lambda wouldn't clog the tubes
05:34:15 <ehird> hugo___: the internets.
05:34:19 <hugo___> ah ok
05:34:36 <b_jonas> intertubes (http://xkcd.com/181/)
05:34:37 <adh0c> I had the Internet sent to me by my staff at 9:30 Friday morning and I got it yesterday
05:34:39 <cnwdup> @pl (\fs -> foldl (\map (_,f,gs) -> foldl (\map g -> Map.insertWith (++) g [f] map) map gs) Map.empty fs)
05:34:40 <lambdabot> (line 1, column 25):
05:34:40 <lambdabot> unexpected ","
05:34:40 <lambdabot> expecting letter or digit, operator or ")"
05:34:40 <lambdabot> ambiguous use of a non associative operator
05:34:51 <hugo___> what flows in the pipes is electrons, shapped according to manchester encoding, or whatever...
05:35:14 <adh0c> actually it's all tiny gnomes but shhhhhhhhhhh
05:35:20 <ehird> b_jonas: intertubes didn't come from xkcd. :P
05:35:29 <hugo___> oh well, lunch time
05:35:36 <adh0c> hardly anything came out of xkcd
05:35:40 <mornfall> ...
05:35:47 <mapreduce> ehird: Scheme is more high level for a beginning programmer, where "high level" means "I don't have to deal with unimportant stuff".
05:36:02 <ehird> mapreduce: Like monads!!
05:36:12 <mapreduce> ehird: Unless someone is already a mathematician, types are probably "unimportant stuff" at the very beginning.
05:36:24 * ehird shrug; I'd disagree.
05:36:34 <ehird> Although admittedly Haskell is prolly not the best intro language...
05:36:37 <mornfall> mapreduce: There are types in scheme. You just treat them ad-hoc.
05:36:39 <ehird> Doesn't mean it's lower-level than scheme.
05:37:20 <b_jonas> ehird: sure
05:37:20 <mornfall> Untyped languages are generally quite useless. Cf. brainfuck. *hides*
05:37:30 <b_jonas> ehird: xkcd just demonstrates them well
05:37:35 <mapreduce> ehird: That only depends on your definition of high level.  I gave mine above.
05:37:36 <ehird> mornfall: As an #esoteric denizen I take great offense to that statement!
05:37:38 <adh0c> whitespace > *
05:37:39 <b_jonas> like in http://xkcd.com/454/ you can actually see the tubes
05:37:48 <cizra> Hey, peeps. chrisdone suggested me Real World Haskell.
05:38:06 <ehird> cizra: i like learnyouahaskell.com
05:38:07 <adh0c> I suggest asking here while you read it
05:38:08 <cizra> Since (quoting), "This work is licensed under a Creative Commons Attribution-Noncommercial 3.0 License."
05:38:20 <adh0c> yea, und?
05:38:22 <ehird> learnyouahaskell is under that too
05:38:23 <ehird> :P
05:38:31 <cizra> .. I took the liberty of wgetting it, ripping out JavaScript etc and making it readable offline.
05:38:32 <Axman6> let him finish guys
05:38:34 <cizra> Anyone want it?
05:38:49 <ehird> not me. I live in 2008
05:38:55 <Axman6> cizra: i'd rather wait until my cops arrives
05:39:02 <Axman6> copy*
05:39:05 <cizra> Tables of contents in the beginning of chapters broke, of course.
05:39:10 <PeakerWork> mapreduce: One definition of types says that terms are typed, not values.. In Scheme values are typed, not terms
05:39:21 <b_jonas> Axman6: nice freudian slip
05:39:29 <Axman6> b_jonas: i thought so :P
05:39:43 <mapreduce> PeakerWork: I don't know why you're telling me that, but afaiac Scheme is untyped.
05:39:58 <ehird> mapreduce: it is not.
05:40:00 <adh0c> Axman6, here comes the party van
05:40:00 <Axman6> cizra: the authors are regulars in here, and we all think it's a book buying, or at least reading.
05:40:07 <ehird> mapreduce: It is strongly, dynamically typed
05:40:08 <mapreduce> Is the untyped lambda calculus untyped?
05:40:12 <ehird> yes.
05:40:16 <Axman6> adh0c: hmm?
05:40:20 <b_jonas> scheme is REALLY untyped
05:40:24 <mapreduce> How does Scheme differ from that to make Scheme typed?
05:40:25 <ehird> no it's not
05:40:26 <b_jonas> much more than some other untyped languages
05:40:27 <ehird> (+ "a" "b")
05:40:29 <adh0c> Axman6, obscure internet humor
05:40:30 <Axman6> adh0c: btw, you got me onto writing a haskell IO tutorial :)
05:40:31 <ehird> => assplode
05:40:35 <PeakerWork> mapreduce: oh, sorry, it was mornfall who said it was ad-hoc typed
05:40:40 <mornfall> b_jonas: What all those people have with Freud's pieces of woman's sleeveless undergarment?
05:40:40 <PeakerWork> mornfall: One definition of types says that terms are typed, not values.. In Scheme values are typed, not terms
05:40:42 <adh0c> Axman6, I feel so proud
05:40:55 <mornfall> PeakerWork: I said you work with the types ad-hoc, not that the language is so.
05:41:21 <mornfall> PeakerWork: The types are there, they get in the way less than in haskell, and they help you less.
05:41:24 <PeakerWork> untyped LC is typed, its just that type of all terms is *any* :)
05:41:57 <mapreduce> That's like saying that "yes, I do drive on the correct side of the road.  I drive on the TOP of it".
05:41:58 <b_jonas> so untyped is when you have only very few types
05:42:02 <cizra> Axman6: My point was about offline readability.
05:42:28 <Axman6> cizra: thats cool :)
05:42:28 * ehird has a stable internet connection.
05:42:31 <PeakerWork> mornfall: if "types" are "restrictions on the values a certain term can hold" then the types aren't there at all
05:42:34 <ehird> :p
05:43:09 <mornfall> PeakerWork: *scratches head*
05:43:11 <PeakerWork> mornfall: well, with inference, _some_ of the terms may be restricted..
05:43:12 <b_jonas> PeakerWork: I don't think of types like that
05:43:23 <blackh> adh0c: I keep thinking about writing an IO tutorial, too, but I am not sure whether it's a good idea - there are dozens already!
05:43:26 <mornfall> b_jonas: Ditto.
05:43:34 <PeakerWork> b_jonas: what are types then?
05:43:37 <b_jonas> rather types tell how you interpret the values
05:43:39 <ehird> I should write a tutorial so I can look at it and facepalm about how much I suck
05:43:45 <cizra> Axman6: If the readers are regulars, perhaps the offline version could be placed on the same site?
05:43:49 <b_jonas> I mean, a function can return anything
05:43:52 <b_jonas> any value
05:43:54 <b_jonas> mostly
05:44:10 <Axman6> cizra: what do you mean?
05:44:24 <mornfall> PeakerWork: Can you invert your definition?
05:44:33 <mornfall> PeakerWork: Types describe what might come out of a term...
05:44:39 <b_jonas> but if it is typed to return integer you use the value in the accumulator as an integer, if it returns float you won't use integer and I might even look at a different register
05:44:48 <b_jonas> for the accumulator register would hold junk
05:44:48 <PeakerWork> mornfall: yeah
05:45:03 <cizra> Axman6: Place the offline version for easy downloading onto the same site
05:45:09 <b_jonas> that doesn't usually restrict on what values it can put to where (it may restrict it a bit in a few cases but that's not the main thing)
05:45:25 <b_jonas> that's not a really functional programming point of view, I admit
05:45:29 <Axman6> cizra: i think most people find the online version easy enough to get to
05:45:33 <Ferdirand> how to interpret values is more of an implementation detail, no ?
05:45:34 <b_jonas> but in functional programming too you have ghost types
05:45:50 <cizra> Axman6: Well, "most". There exists a minority such as myself who prefer to read things offline.
05:45:51 <Ferdirand> it hides the fact that we must represent two values with different semantics with the same low-level data
05:46:00 * mornfall raises eyebrows a little... where did we go?
05:46:10 <b_jonas> (or is that shade or vampire or mummy or zombie types or whatever undead they're named of)
05:46:32 <mapreduce> PeakerWork: You might like Types and Programming Languages by Benjamin Pierce.
05:47:00 <quicksilver> and if you don't (like TAPL) you probably shouldn't admit it here.
05:47:05 <blackh> adh0c: When you have got a handle on how to use do blocks and <- and such, and you're really ready to see how it all works - take a look at the state monad.  Then you'll realize that Haskell doesn't have any syntax trickery.  It's just a devilishly simple but ingenious design.
05:47:05 <mornfall> Well, as far as I am concerned, practical world is typed.
05:47:19 <mapreduce> PeakerWork: It might disavow you of the idea that it's useful to talk about Scheme being typed.  (Pierce says that values are tagged rather than typed, which is a nice distinguisher).
05:47:27 <mornfall> "Everything is a set" is great idea, but types help the world with workability.
05:47:49 <PeakerWork> mapreduce: I didn't say Scheme was typed
05:48:50 <b_jonas> .oO( I think I should use more names of fictional creatures in naming variables and stuff in code )
05:49:58 <b_jonas> mornfall: that's a nice topic to argue about
05:51:14 <mornfall> b_jonas: Do you happen do disagree? : - ]
05:51:15 <adh0c> b_jonas, fictional creatures, eh?
05:51:37 <adh0c> nothing beats every single Pascal code example I've seen
05:51:43 <adh0c> one-letter variables ftw
05:55:41 <vegai> hyperVerboseVariableNamesAreNotSoMuchBetter_Though
05:55:53 <adh0c> that reminds me
05:56:46 <adh0c> http://thedailywtf.com/Comments/Really-Descriptive-Names.aspx
05:57:08 <cnwdup> http://hpaste.org/13254 Can anyone tell me what X11's "Locking assertion failures" are?
05:57:17 <adh0c> getSalesOrderProductSupplierCopayDrugStrengthFormCountryManufacturerPharmacyCopayProductPrice
05:58:52 <adh0c> was it something I said?
06:01:13 <cnwdup> Hum, can't I poll for X11 events from a thread forked by forkIO?
06:06:21 <Cale> adh0c: GAP has long names like that, but they are even more scary because they are about computational group theory. Things like CanonicalRepresentativeDeterminatorOfExternalSet
06:06:53 <Cale> and ColumnIndexOfReesZeroMatrixSemigroupElement
06:07:31 <adh0c> Cale, that sounds horrendously horrible
06:07:33 <centrinia> What is a Rees Zero Matrix ?
06:07:50 <centrinia> Why did Rees get a Zero matrix named after him/her?
06:08:54 <Cale> Let me paste the documentation for this ;)
06:09:45 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=673#a673
06:10:19 <centrinia> Oh.
06:11:04 <Cale> I think you basically have to know ;)
06:11:46 <Cale> There are probably only a handful of people in the world who understand what that function does.
06:12:01 <adh0c> are they sane?
06:14:34 <BeelsebobWork> my brain's fallen out my ear... can anyone see what's going on here? http://hpaste.org/13255
06:14:58 <Axman6> Cale: that code hurts my eyes >_<
06:15:08 <Cale> Axman6: heh, sorry about that...
06:15:09 <adh0c> that's a nice line noise you've got there
06:15:12 <Cale> http://www.dpmms.cam.ac.uk/~bt219/ref/CHAP048.htm#SECT006
06:15:28 <Cale> Found the actual documentation online :)
06:16:06 <centrinia> Why didn't we learn about semigroups in the Modern Algebra course about groups?
06:16:13 <lilac> BeelsebobWork: flip . uncurry $ (^/) ?
06:16:23 <lilac> BeelsebobWork: shouldn't that be uncurry . flip $ (^/) ?
06:16:28 <Cale> centrinia: Because their study is a lot more difficult.
06:16:29 <lilac> @type (^/)
06:16:31 <lambdabot> Not in scope: `^/'
06:16:49 <Cale> centrinia: Groups are the nicest possible kind of semigroup.
06:16:57 <Axman6> anyone want to take a quick look over my haskel IO tutorial?
06:17:00 <BeelsebobWork> lilac: no -- (^/) works on two arguments -- I want it to work on pairs, where the arguments are in the wrong order
06:17:07 <Cale> There's almost nothing you can say about *all* semigroups.
06:17:08 <BeelsebobWork> oh wait
06:17:11 <BeelsebobWork> no I see what you're saying now
06:17:15 <BeelsebobWork> and yes, I think it should
06:17:15 <Cale> Though there's a bit.
06:17:39 <BeelsebobWork> lilac: genious, thanks
06:17:43 <lilac> Cale: the operator is associative. that's all i've got :)
06:17:44 <BeelsebobWork> It would have taken me all day to find that
06:18:18 <lilac> BeelsebobWork: no problem :)
06:18:39 <centrinia> Are magmas even harder to have a general study of?
06:18:55 <Axman6> no one? :\
06:19:07 <Cale> Basically, magmas and semigroups break down into a study of various special kinds of those.
06:19:18 <Cale> Because you can't really do much with so few axioms.
06:22:10 <lilac> Cale: isn't the class of semigroups basically the same as the class of monoids (by adding an extra 'identity' element)?
06:22:54 <Cale> Well, yes, you can always add an identity to get a monoid.
06:23:00 <centrinia> Does it make sense to talk about a magma that has an identity element and no other axioms?
06:23:12 <Cale> centrinia: you could...
06:23:24 <centrinia> What is it called?
06:23:32 <cnwdup> Why isn't xftDrawString not listed in hackage's API documentation although it's exported by Graphics.X11.Xft?
06:23:33 <Cale> I don't think it has a name.
06:23:40 <centrinia> Oh.
06:23:42 <cnwdup> s/isn't/is/
06:23:46 <wli> free magma with identity
06:23:47 <lilac> "magma with identity"?
06:24:00 <Cale> Yeah, you'd just say what lilac said :)
06:24:07 <centrinia> Okay.
06:24:15 <lilac> the free magma with identity is something more specific
06:24:56 <wli> I took "no other axioms" to mean "no relations amongst generators."
06:25:08 <centrinia> What do you call a magma-like algebra whose operation is not total?
06:25:58 <wli> Division?
06:26:17 <centrinia> Divison?
06:26:30 <centrinia> Uh, what about division?
06:26:35 <lilac> centrinia: that's really not much more than a set plus a ternary relation
06:27:04 <centrinia> lilac, yeah.
06:28:21 <Cale> One nice axis of generalisation goes from monoid to category and group to groupoid.
06:28:36 <Cale> You could consider that axis as making the operation not be total in a specific way.
06:29:11 <wli> Universal algebra gets involved here.
06:32:32 <centrinia> Is there a concept of a "normal monoid" of a monoid?
06:32:47 <centrinia> Or a "normal submonoid" of a monoid?
06:33:57 <wli> Set equality between left and right cosets is not so unreasonable. Try it.
06:34:41 <Axman6> would someone like to look over http://hpaste.org/13256 for me? it's the beginnings of a beginner's IO tutorial
06:35:12 <Axman6> (hpaste doesn't like long lines apparently...)
06:35:23 <centrinia> Okay, is there a study of simple finite monoids that is as complete as the study of simple finite groups?
06:36:16 <wli> Yes. Consider <x> in a finite monoid.
06:37:21 <chrisdone> haskell docs don't work on Opera
06:37:24 <chrisdone> wahhhhhhhhh
06:37:30 * chrisdone looks in the haddock source
06:38:32 <cizra> Looks just fine here
06:38:36 <Axman6> adh0c: want to check out the beginnings of my tutorial? http://hpaste.org/13256
06:38:38 * cizra is looking at http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo-SVG.html
06:38:52 <chrisdone> cizra: click the anchored links
06:39:04 <cizra> Mm.. yes.. The requested URL /opt/ghc/share/doc/ghc-6.6.1/html/libraries/base/System-IO.html was not found on this server.
06:39:40 <cizra> Well, that particular link didn't work in Firefox any better.
06:39:50 <chrisdone> I mean, take this: http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html#v%3AmkRegex
06:39:51 <orbitz> Axman6: needs more energy
06:40:06 <chrisdone> takes you to mkRegex in Firefox, doesn't in Opera
06:40:21 <chrisdone> I wonder if the anchoring is nonstandard or something
06:40:30 <Axman6> "Haskell, fuck yeah, let's do this shit!!!!!"? :\
06:41:02 <wli> centrinia: Unless the monoid has zero divisor -like elements, if it's finite it's a group (no zero divisor -like elements is "cancellativity").
06:41:15 <cizra> chrisdone: I bet the %3A is bad there
06:41:44 <cizra> chrisdone: I bet it gets transformed into : by Opera
06:42:21 <Cale> centrinia: Apparently, while there is a notion of a quotient monoid, you don't tend to get a set of elements to mod out by.
06:42:30 <orbitz> Axman6: more energy!!!!
06:42:35 <Cale> centrinia: Instead, you quotient by an equivalence relation.
06:42:35 <centrinia> wli, the integers modulo 4 with multiplication.
06:42:40 <orbitz> Cale: i heard you can speak for horus about how fail is fail in Monads
06:42:50 <Cale> orbitz: Not for hours...
06:42:53 <Axman6> orbitz: "HOLY FUCK YOU'RE GOING TO DIE UNLESS YOU LEARN THIS SHIT, SO LISTEN UP!"?
06:42:54 <chrisdone> cizra: hm. let's see
06:43:03 <Cale> orbitz: But it is annoying.
06:43:04 <orbitz> Axman6: MORE ENERGY!
06:43:08 <Axman6> excuse my french
06:43:13 <orbitz> Cale: is it annoying ot the point of uselessness?
06:43:17 <orbitz> Axman6: now i'm all pumped up
06:43:25 <orbitz> Axman6: let's go lift some weights and talk about ahskell!
06:43:31 <Cale> orbitz: fail doesn't belong in the Monad class.
06:43:32 <wli> orbitz: Counterproductivity.
06:43:34 <Axman6> YEAHHH!
06:43:41 <Cale> orbitz: Putting it in its own class would be okay.
06:43:42 <centrinia> Lift some weights into tho IO monad!
06:43:45 <centrinia> Booyah!
06:44:01 <Cale> orbitz: But I liked the old translation of the do-notation better.
06:44:11 <xenoterracide> is ghc itself written in haskell?
06:44:12 <orbitz> Cale: what was the old translation?
06:44:15 <Cale> xenoterracide: yes
06:44:18 <ehird> xenoterracide: Yes.
06:44:21 <chrisdone> cizra: now I'm really confused. does this anchor work for you on opera? http://chrisdone.com/Text-Regex.html#v%3AmkRegex
06:44:22 <Cale> xenoterracide: In GHC Haskell, specifically.
06:44:24 <orbitz> xenoterracide: no
06:44:26 <orbitz> xenoterracide: i mean...yes
06:44:29 <dancor> do other ppl agree that (threadDelay (-1)) hanging silently is bug?
06:44:33 <cizra> chrisdone: yes
06:44:43 <b_jonas> @t threadDelay
06:44:44 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:44:46 <dancor> i guess you might want infinite hang, hm
06:44:49 <xenoterracide> hmm...  must figure out source of issue
06:44:55 <dancor> :t threadDelay
06:44:57 <Cale> dancor: I think I might agree with that, though now that you mention it, it's very handy.
06:44:58 <lambdabot> Not in scope: `threadDelay'
06:45:00 <cizra> chrisdone: What's so confusing about it?
06:45:00 <chrisdone> cizra: I saved the page with firefox, heh. humph
06:45:15 <orbitz> why is it handy?
06:45:17 <Cale> dancor: A lot of things which would cause a thread to block forever will throw an exception and kill the thread.
06:45:23 <chrisdone> cizra: I'm wondering why it works whereas the official page doesn't. firefox must've translated something when saving it
06:45:29 <b_jonas> docs say: threadDelay :: Int -> IO ()
06:45:36 <Cale> (an exception which you'd often wish were silent)
06:45:48 <dancor> still seems like Maybe Int to allow inf-hang is waaay better
06:45:50 * chrisdone does a diff
06:45:51 <Cale> But threadDelay is the wrong place for that
06:45:58 <dancor> ya
06:46:05 <b_jonas> dancor: yeah, the thread should just be garbage-collected
06:46:19 <Saizan> Axman6: seen this? http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
06:46:37 <Axman6> i have
06:47:31 <cizra> chrisdone: I tell ya, the %3A gets translated into :
06:47:39 <b_jonas> otoh some threading systems by default ignore all exceptions in threads other than the main thread, killin that thread silently but continuing the others, and that's REALLY annoying
06:47:58 * quicksilver uses "forever (threadDelay maxBound)"
06:47:59 <b_jonas> I've seen at least two thread systems do that
06:48:03 <quicksilver> for a hang.
06:48:11 <chrisdone> cizra: how do we fix haddock then?
06:48:19 <Axman6> Saizan: i think it was one of the better tutorials i read. i just thought that my explanation might be helpful to those confused about getting the a out of IO a, like i was
06:48:26 <ehird> I use let x = x in putStrLn x
06:48:27 <ehird> <.<
06:48:30 <cizra> chrisdone: The easiest way: don't use : in anchor names
06:48:30 <Cale> There are three principles on which a good understanding of how IO works in Haskell can rest: 1) IO actions are values whose evaluation doesn't cause the action to occur, they just describe it. 2) Do-blocks combine simple actions into more complex ones. 3) The value 'main' defined by a program is an IO action, and will be executed.
06:48:46 <centrinia> Why do some people get frightened by the Moggi paper?
06:48:49 <cizra> chrisdone: Also an easy way: write literal : instead of %3A
06:48:49 <quicksilver> b_jonas: haskell doesn't *ignore* exceptions in other threads, but it does indeed send them to that threads, and if it doesn't handle them, it will be killed silently.
06:49:07 <b_jonas> quicksilver: it too? pity
06:49:23 <Cale> and most of the work there is in 2
06:49:43 <cizra> chrisdone: According to http://en.wikipedia.org/wiki/Url_encode, unreserved characters include alphanumerics and -_.~
06:49:44 <Axman6> hmm, my battery went from 25% to 33%, without me plugging in the adapter
06:49:56 <ehird> ~ seems like a good bet
06:49:57 <cizra> Axman6: Must have been cosmic rays.
06:49:58 <dancor> Axman6: is it oil powered and you went up a hill
06:49:59 <b_jonas> I prefer that when a thread doesn't handle an exception that counts as a BIG error and then an exception is raised in all threads
06:50:18 <Axman6> hmm, both plausible suggestions
06:50:37 <ehird> > fix (2:)
06:50:37 <centrinia> Static electric shocks to the battery terminals. ;)
06:50:38 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
06:50:42 * Axman6 investigates by tipping the laptop while driving to his uni's particle accelerator
06:50:57 <ehird> > fix ((++) "ok" . head)
06:50:58 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
06:51:12 <Axman6> > (fix (1:)) !! maxBound
06:51:20 <ehird> > fix (\xs -> xs ++ ["ok" ++ last xs])
06:51:28 <lambdabot>   thread killed
06:51:29 <ehird> Axman6: You killed lambdabot!
06:51:34 <b_jonas> it might be a bit better if the exception gets re-raised only in the parent thread, and if that doesn't handle it then its parent etc, and only when the main thread doesn't handle it does a (likely fatal) exception get sent to all threads
06:51:35 <lambdabot>   thread killed
06:51:45 <centrinia> ehird, so did you.
06:51:50 <ehird> :D
06:52:01 <chrisdone> cizra: oh, I get it.
06:52:04 <ehird> > fix (\xs -> ("ok" ++ head xs) : xs)
06:52:06 <lambdabot>   ["okokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokoko...
06:52:11 <Axman6> ehird: it's just a pupet, we only cut two of its strings
06:52:11 <ehird> Whoops.
06:52:19 <b_jonas> and there's the alternative of this happening to disowned threads only and owned threads re-raising the expcetions on join
06:52:22 <b_jonas> etc
06:52:23 <ehird> > fix (\xs -> "ok":xs)
06:52:24 <b_jonas> I dunno which one is the best
06:52:25 <lambdabot>   ["ok","ok","ok","ok","ok","ok","ok","ok","ok","ok","ok","ok","ok","ok","ok"...
06:52:29 <b_jonas> but I hate the silent one
06:52:43 <Cale> 2.0) A do block is a sequence of statements. 2.1) A statement consisting of just an action means to run that action and discard its result. Do blocks must end with one of these, and the result of the do-block is the result of this action. 2.2) A statement of the form v <- x means to run the action x and name its result v in the following statements. 2.3) A statement of the form "let <declarations>" will make the decla
06:52:44 <Cale> rations scope over the remainder of the do-block.
06:52:44 <ehird> > fix (\xs -> "ok" : map ("ok" ++) xs)
06:52:45 <lambdabot>   ["ok","okok","okokok","okokokok","okokokokok","okokokokokok","okokokokokoko...
06:52:46 <dancor> last chance to stop my from wasting more ppl's time by report this (threadDelay (-1)) thing as a bug (can't find other reports of it)
06:52:48 <chrisdone> cizra: Firefox shows <a name="v:mkRegex"></a> in the source, whereas Opera shows: <A NAME="v%3AmkRegex"></A>. so Opera converts it to a ':', but it's not that in Opera's anchor name
06:53:02 <ehird> > fix (\xs -> "o" : map ("ok" ++) xs)
06:53:03 <lambdabot>   ["o","oko","okoko","okokoko","okokokoko","okokokokoko","okokokokokoko","oko...
06:53:07 <ehird> Yay.
06:53:09 <ehird> @pl fix (\xs -> "o" : map ("ok" ++) xs)
06:53:09 <lambdabot> fix (("o" :) . map ("ok" ++))
06:53:13 <Cale> After that, it's just learning specific actions you have available to you :)
06:53:23 <ehird> > fix (("o" :) . map ("ok" ++))
06:53:25 <lambdabot>   ["o","oko","okoko","okokoko","okokokoko","okokokokoko","okokokokokoko","oko...
06:53:30 <cizra> > let right a b = b in foldl right 0 [1..]
06:53:50 <lambdabot>   thread killed
06:53:53 <vixey> right = flip const
06:53:54 <cizra> chrisdone: don't use : in URLs
06:54:04 <ehird> @pl (\x y -> fix (x . map y))
06:54:04 <lambdabot> (fix .) . (. map) . (.)
06:54:16 <ehird> Yuck, pointless soup. :-)
06:54:26 <b_jonas> Cale: what I don't like in that description is that it doesn't explain why you can just put an expression (like an if) giving a do block as a statement inside another do block
06:54:28 <Axman6> > map length ["right a b = b","right = flip const"]
06:54:29 <ehird> @let wat x y = fix (x . map y)
06:54:34 <lambdabot>  Defined.
06:54:35 <lambdabot>   [13,18]
06:54:43 <ehird> > wat ("o" :) ("ok" ++)
06:54:44 <lambdabot>   ["o","oko","okoko","okokoko","okokokoko","okokokokoko","okokokokokoko","oko...
06:54:48 <quicksilver> b_jonas: exceptions are the *only* mechanism for killing haskell threads, though, that's why :)
06:54:48 <Cale> b_jonas: Because the result of the if expression is an action.
06:55:03 <ehird> > wat (["o","a"] ++) ("ok" ++)
06:55:04 <lambdabot>   ["o","a","oko","oka","okoko","okoka","okokoko","okokoka","okokokoko","okoko...
06:55:04 <b_jonas> quicksilver: can't a haskell thread just return?
06:55:06 <quicksilver> b_jonas: it's relatively simple to wrap your fork in something which catches + rethrows if you want.
06:55:06 <cizra> > let left a b = a in foldr left 0 [1..]
06:55:08 <lambdabot>   1
06:55:14 <chrisdone> cizra: haha, here we are: http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html#v%253AmkRegex
06:55:15 <ehird> > wat reverse ("ok" ++)
06:55:16 <lambdabot>   * Exception: stack overflow
06:55:16 <cizra> Hey, people, why does it work?
06:55:19 <quicksilver> b_jonas: it can 'just stop' yes
06:55:20 <Cale> (and do-blocks just combine simple actions into more complex ones)
06:55:24 <BONUS> > itarate (++"ko") "o"
06:55:26 <lambdabot>   Not in scope: `itarate'
06:55:26 <quicksilver> b_jonas: but the only wau to kill it is to send an exception to it.
06:55:29 <BONUS> > iterate (++"ko") "o"
06:55:31 <lambdabot>   ["o","oko","okoko","okokoko","okokokoko","okokokokoko","okokokokokoko","oko...
06:55:32 <b_jonas> quicksilver: but it's jsut as simple to wrap a thread in something which catches and stops
06:55:32 <ehird> BONUS: yeah, yeah, iterate, I know :-P
06:55:39 <BONUS> oh wait
06:55:39 <quicksilver> b_jonas: indeed.
06:55:44 <ehird> > wat (reverse . ("a" :)) ("ok" ++)
06:55:45 <BONUS> yeah :]
06:55:45 <lambdabot>   * Exception: stack overflow
06:55:47 <b_jonas> quicksilver: and I prefer that all expcetions mean a fatal error unless I specifically catch it
06:55:48 <cizra> chrisdone: umm.. what?
06:55:52 <ehird> > wat (("a" :) . reverse) ("ok" ++)
06:55:53 <lambdabot>   ["a"* Exception: stack overflow
06:55:57 <Axman6> > foldr f x [a,b,c,d] -- cizra
06:55:58 <b_jonas> quicksilver: that's the semantics in unthreaded programs
06:55:59 <chrisdone> cizra: %25 is the url encoding for ':'  =)
06:55:59 <lambdabot>   f a (f b (f c (f d x)))
06:56:07 <chrisdone> cizra: it works in opera, yes?
06:56:14 <Axman6> > foldr const x [a,b,c,d] -- cizra
06:56:15 <lambdabot>   a
06:56:20 <ehird> > wat f g
06:56:20 <cizra> chrisdone: yeah
06:56:21 <lambdabot>       No instance for (SimpleReflect.FromExpr [a])
06:56:21 <lambdabot>        arising from a use ...
06:56:28 <ehird> (Wait, what?)
06:56:33 <ehird> > wat f g :: Expr
06:56:35 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
06:56:37 <ehird> > wat f g :: [Expr]
06:56:38 <lambdabot>       No instance for (SimpleReflect.FromExpr [Expr])
06:56:38 <lambdabot>        arising from a u...
06:56:40 <b_jonas> Cale: maybe... yes
06:56:41 <ehird> :\
06:57:02 <b_jonas> quicksilver: and then you can catch only the kind of exception that you intend to kill the thread
06:57:07 <cizra> chrisdone: WTF
06:57:10 <cizra> chrisdone: %25 is NOT :
06:57:21 <Axman6> > 2^275 :: Expr
06:57:23 <lambdabot>   2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)))...
06:57:31 <ehird> Who wants to figure out what's wrong with
06:57:32 <chrisdone> cizra: sorry, I meant '%'
06:57:34 <ehird> > wat f g :: [Expr]
06:57:34 <ehird> :P
06:57:35 <lambdabot>       No instance for (SimpleReflect.FromExpr [Expr])
06:57:35 <lambdabot>        arising from a u...
06:57:42 <Axman6> :t wat
06:57:44 <lambdabot> forall b a. ([b] -> [a]) -> (a -> b) -> [a]
06:57:48 <ehird> @src wat
06:57:48 <lambdabot> Source not found. You untyped fool!
06:57:50 <ehird> err
06:57:50 <cizra> chrisdone: Weirdity. Why do these ugly things? Why not replace the anchors?
06:57:52 <ehird> @let wat x y = fix (const x . map y)
06:57:53 <lambdabot>  Couldn't match expected type `[a]'
06:57:56 <adekoba> is there a way to disable the "Synopsis" heading in haddock for a module?
06:57:57 <ehird> err
06:57:58 <ehird> @let wat x y = fix (x . map y)
06:57:59 <lambdabot>  <local>:5:0:
06:57:59 <lambdabot>      Warning: Pattern match(es) are overlapped
06:57:59 <lambdabot>               In...
06:58:04 <ehird> Right, right, yes
06:58:43 <cizra> Axman6: Hmm, yeah, I see it now. It just spits out the thing and leaves the invinite list in bed.
06:59:00 <Axman6> yep :)
06:59:07 <ehird> Hrm..
06:59:13 <ehird> > fix (f . map g)
06:59:14 <lambdabot>       No instance for (SimpleReflect.FromExpr [a])
06:59:16 <lambdabot>        arising from a use ...
06:59:20 <ehird> Okay, that's odd. i think
06:59:25 <Axman6> cizra: you get how foldl1 (flip const) works?
06:59:31 <chrisdone> cizra: I was just confirming that Opera names the anchor as it is given, i.e. "#v%3AmkRegex". it literally has to match that, and the URL encoding for "#v%3AmkRegex" is "#v%25%3AmkRegex", see? but Firefox interprets the anchor name as a url encoded value, so it has to match "#v:mkRegex". I wonder which one is correct behaviour
06:59:51 <Axman6> @src const
06:59:52 <lambdabot> const x _ = x
07:00:12 <cizra> chrisdone: Dunno. But don't use weird characters in links when you can avoid it.
07:00:28 <chrisdone> cizra: yes, I acknowledge that
07:00:30 <cizra> Axman6: nope, but then I haven't thought about it either.
07:00:50 <Axman6> > foldl1 (flip const) [a,b,c,d,x]
07:00:52 <lambdabot>   x
07:00:58 <chrisdone> cizra: perhaps "v.mkRegex" is a better format
07:01:20 <cizra> chrisdone: Any from -_.~
07:01:22 <chrisdone> cizra: or "v-mkRegex"
07:01:37 <Axman6> > let dang x y = dang y x in dang 0 0
07:01:43 * chrisdone grabs haddock source
07:01:52 <lambdabot>   thread killed
07:02:32 <Axman6> ok, it's 2AM, bed time. night all
07:02:47 <ehird> ~ is way better
07:02:51 <ehird> because v~mkRegex looks neat.
07:02:57 <opqdonut> :)
07:03:05 <chrisdone> b_b
07:03:11 <chrisdone> mmkay
07:07:07 <sbahra> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlint
07:07:10 <sbahra> What's up with the page?
07:08:28 <chrisdone> oh dear
07:09:02 <chrisdone> cizra: src/Haddock/Utils.hs:anchorNameStr name | isValOcc name = "v:" ++ occNameString name
07:09:07 <chrisdone> cizra: foooound iiiit
07:09:35 <cizra> chrisdone: now do a svn blame or whatever you use...
07:10:36 * chrisdone gets the darcs version
07:14:40 <PeakerWork> why aren't (a+b+) sections allowed?
07:15:08 <wli> Associativity, commutativity?
07:15:08 <PeakerWork> (a+b*) --> (a+) . (b*)
07:15:49 <quicksilver> they are in certain cases
07:15:57 <vixey> > let bar :: (forall x. x) -> c; bar = \ x -> x x in ()
07:15:58 <lambdabot>   ()
07:16:08 <quicksilver> > (1+2+) 3
07:16:09 <mbac> i'm trying to use a function foo :: [a] -> IO [a]  but i'm not clear on how to unwrap the IO part from the return value
07:16:09 <lambdabot>   6
07:16:11 <quicksilver> PeakerWork: ^^
07:16:34 <sbahra> > (1 + 2 *) 3
07:16:35 <lambdabot>       The operator `*' [infixl 7] of a section
07:16:35 <lambdabot>          must have lower prece...
07:16:43 <quicksilver> > (1*2+) 3
07:16:44 <lambdabot>   5
07:16:45 <cizra> How to convert an IBM into HAL?
07:16:46 <PeakerWork> > ("hello" ++ "blah" ++) "bleh"
07:16:47 <lambdabot>       The operator `++' [infixr 5] of a section
07:16:47 <lambdabot>          must have lower prec...
07:16:47 <cizra> > let minus a = a - 1 in map minus "IBM"
07:16:48 <lambdabot>       No instance for (Num Char)
07:16:48 <lambdabot>        arising from a use of `minus' at <int...
07:16:58 <quicksilver> PeakerWork: because ++ is r-assoc
07:17:15 <quicksilver> > (++" there " ++ " Peaker") "hi"
07:17:17 <lambdabot>   "hi there  Peaker"
07:17:29 <PeakerWork> quicksilver: it could be generalized though?
07:17:51 <wli> Lower precedence etc.
07:18:18 <quicksilver> possibly. I've never thought about it very hard.
07:18:51 <Axman6> mbac: i just wrote a tutorial if you want to check it out (it's not done yet though...) http://hpaste.org/13256
07:19:02 <adrian> > pred 'B'
07:19:03 <lambdabot>   'A'
07:19:12 <adrian> > map pred "IBM"
07:19:13 <lambdabot>   "HAL"
07:19:17 <adrian> funny
07:19:33 <b_jonas> Cale: actually to me the state monad helps a lot because I already considered functions as values so this way I could imagine actions as values easier
07:19:41 <adrian> @src pred
07:19:41 <lambdabot> Source not found. My brain just exploded
07:19:54 <adrian> @src Prelude.pred
07:19:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:20:20 <wli> @info Enum
07:20:20 <lambdabot> Enum
07:20:46 <Axman6> @src Enum
07:20:46 <lambdabot> class  Enum a   where
07:20:46 <lambdabot>     succ                     :: a -> a
07:20:46 <lambdabot>     pred                     :: a -> a
07:20:46 <lambdabot>     toEnum                   :: Int -> a
07:20:46 <lambdabot>     fromEnum                 :: a -> Int
07:20:48 <b_jonas> it's  amethod
07:20:48 <lambdabot> [3 @more lines]
07:20:53 <b_jonas> @src Int pred
07:20:54 <lambdabot> Source not found. You untyped fool!
07:21:00 <Axman6> @src Char pred
07:21:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:21:03 <b_jonas> @src Ordering pred
07:21:03 <lambdabot> Source not found. Wrong!  You cheating scum!
07:21:10 <b_jonas> @src Ordering Enum
07:21:11 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:21:28 <wli> @src Ordering Enum
07:21:28 <lambdabot> Source not found. You type like i drive.
07:21:36 <wli> @src Enum Ordering
07:21:37 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:21:44 <wli> @src pred Ordering
07:21:45 <lambdabot> Source not found. stty: unknown mode: doofus
07:23:03 <vixey> @src pred
07:23:03 <lambdabot> Source not found. Take a stress pill and think things over.
07:23:12 <vixey> @instances Enum
07:23:13 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
07:23:14 <PeakerWork> regex-dfa does not support non-greedy matches such as .*? -- so its not a complete regexp engine. Does it support [0-9]{4}  for 4 digits?
07:23:21 <PeakerWork> or better yet, \\d{4} ?
07:23:31 <vixey> non-greedy isn't regular
07:24:03 <PeakerWork> well, regexps aren't regular :)
07:25:13 <quicksilver> perl regexps can do anything.
07:25:19 <quicksilver> E.g. : http://99-bottles-of-beer.net/language-perl-737.html
07:27:21 <ehird> :t \f g -> fix (f . map g)
07:27:22 <lambdabot> forall a b. ([b] -> [a]) -> (a -> b) -> [a]
07:28:21 <PeakerWork> vixey: I find it unintuitive that greediness affects regularity.. where can I read about it?
07:29:16 <quicksilver> PeakerWork: well it's simply definitional.
07:29:43 <quicksilver> regular langauges are those parseable by regexps (in the original, technical, sense of regexp)
07:29:54 <quicksilver> add greediess and you can parse more languages
07:29:59 <quicksilver> so that's not regular anymore
07:30:03 <adrian> quicksilver: examples?
07:30:03 <quicksilver> because that's what regular means
07:30:09 <quicksilver> s/greediness/non-greedines/
07:30:32 <Saizan> thinking in terms of automatons, to implement non-greediness you need backtracking or lookahead, and DFAs don't have those
07:30:35 <PeakerWork> quicksilver: ok, but can regular + greediness be parsed by a deterministic state machine in O(n+m) (n=length string, m=length regexp) or such?
07:31:06 <PeakerWork> Saizan: that's what I find unintuitive -- you don't need backtracking if everything's greedy, but you do need it if its not?
07:32:14 <quicksilver> the top of http://en.wikipedia.org/wiki/Regular_language gives the multitude of equivalenet formulations of regularity.
07:33:05 <quicksilver> one of the cute properties of regular languages is that they only need constant decision space.
07:33:05 <adh0c> is there a way to filter a list of filepaths to only have files with specific strings in name?
07:33:13 <PeakerWork> What's the resolution of Data.Time.Clock.UTCTime ?
07:33:15 <quicksilver> intuitively they "only think locally"
07:33:36 <quicksilver> PeakerWork: various by platform.
07:33:37 <quicksilver> PeakerWork: somewhere between 1us and 100ms probably ;)
07:33:40 <adh0c> filter (`elem` <strings>) <filepathlist> only returns the <strings> it finds
07:34:02 <PeakerWork> quicksilver: it doesn't have show.. How do I easily use the value?
07:34:05 <quicksilver> adrian: filter (string `isInfixOf) <list>
07:34:11 <PeakerWork> quicksilver: (see the absolute value, not a diff)
07:34:14 <quicksilver> PeakerWork: it does have show, in Data.Time.Format.
07:34:23 <quicksilver> adh0c: sorry, that was for you.
07:34:24 <PeakerWork> oh! thanks
07:34:30 <adh0c> thx
07:34:33 <quicksilver> adh0c: is an example for only one string.
07:34:38 <quicksilver> for many strings you want something like
07:34:43 <adh0c> so map then?
07:34:51 <quicksilver> something with 'any'
07:34:53 <quicksilver> probably
07:35:41 <quicksilver> filter (\x -> any (\y -> y `isInfixOf` x) <strings>) <filepathlist>
07:35:42 <quicksilver> perhaps
07:35:51 <quicksilver> but I didn't think about that very carefully before typing it.
07:35:53 <adh0c> will try
07:36:00 <cizra> > let minus a = a - 1 in map minus "IBM" -- how to convert a IBM into a HAL? This one doesn't work, unfortunately.
07:36:01 <lambdabot>       No instance for (Num Char)
07:36:01 <lambdabot>        arising from a use of `minus' at <int...
07:36:06 <lilac> quicksilver: that's more-or-less the same solution i had :)
07:36:13 <lilac> s/\y -> y //
07:36:19 <adrian> cizra: use pred
07:36:56 <fasta> Is anyone of you a markdown user and do you know whether markdown has a blocklevel escape function? Thus <escape>###### </escape> would internally translate to \#\#\# and so on ?
07:37:09 <adrian> > let minus = toEnum.(-1).fromEnum in map minus "IBM"
07:37:11 <lambdabot>       No instance for (Num (Int -> Int))
07:37:11 <lambdabot>        arising from the literal `1' ...
07:37:11 <adh0c> quicksilver, no need to map
07:37:18 <adh0c> filter will just return the list I need
07:37:24 <quicksilver> right
07:37:34 <quicksilver> it's the nested "Any" if you have multiple strings to check against
07:38:05 <adh0c> hm
07:38:24 <ehird> > let oko = "o" : ("ok" ++ head oko) in oko
07:38:25 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
07:38:34 <adh0c> coudln't you use filter (isInfixOf ["wa","ka"]) <filepathlist>?
07:38:35 <ehird> > let oko = "o" ++ ["ok" ++ head oko] in oko
07:38:36 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
07:38:42 <ehird> > let oko = "o" : ["ok" ++ head oko] in oko
07:38:44 <lambdabot>   ["o","oko"]
07:38:45 * ehird is stupid
07:38:55 <ehird> > let oko = "o" : map ("ok" ++) oko in oko
07:38:56 <lambdabot>   ["o","oko","okoko","okokoko","okokokoko","okokokokoko","okokokokokoko","oko...
07:39:09 <ehird> > fix ("ok" ++)
07:39:10 <quicksilver> adh0c: no, isInfixOf wants a single string for its first arg
07:39:10 <lambdabot>   "okokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokok...
07:39:13 <quicksilver> adh0c: not a list of them
07:39:17 <Badger> @src fix
07:39:17 <lambdabot> fix f = let x = f x in x
07:40:26 <adh0c> so that would be filter (any(isInfixOf) <list>) <filepathslist> ?
07:40:50 <PeakerWork> do I really need to fetch the currentLocale from System.Locale to use FormatTime.formatTime?
07:41:32 <cizra> How to convert a character into the corresponding integer value, assuming pure ASCII?
07:42:02 <adh0c> cizra, ord?
07:42:27 <cizra> >ord 'a'
07:42:29 <ehird> > let oko n = "o" ++ replicate "ko" n in oko 1
07:42:30 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
07:42:37 <cizra> >ord "a"
07:42:41 <ehird> > let oko n = "o" ++ replicate n "ko" in oko 1
07:42:42 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
07:42:47 <cizra> > ord 'a'
07:42:48 <lambdabot>   97
07:42:50 <ehird> :t replicate
07:42:52 <lambdabot> forall a. Int -> a -> [a]
07:42:52 <cizra> ooh, cool.
07:42:57 <ehird> :t repeat
07:42:58 <lambdabot> forall a. a -> [a]
07:43:05 <ehird> @hoogle Int -> [a] -> [a]
07:43:06 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:43:06 <lambdabot> Prelude take :: Int -> [a] -> [a]
07:43:06 <lambdabot> Data.List drop :: Int -> [a] -> [a]
07:43:11 <ehird> bah.
07:43:23 <ehird> > let oko n = "o" ++ take (n*2) (repeat "ko") in oko 1
07:43:24 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
07:44:51 <ehird> > let oko = "o" : ("ok" ++ head oko : oko) in oko
07:44:52 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
07:45:01 <ehird> ...huh
07:45:13 <ehird> > let oko = "o" : ("ok" ++ (head oko) : oko) in oko
07:45:14 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
07:45:19 <ehird> > let oko = "o" : (("ok" ++ head oko) : oko) in oko
07:45:20 <lambdabot>   ["o","oko","o","oko","o","oko","o","oko","o","oko","o","oko","o","oko","o",...
07:45:21 <cizra> > map (chr . ord) "Haskell coolness!"
07:45:22 <lambdabot>   "Haskell coolness!"
07:45:28 <Saizan> what's an example of a regular expression where non-greediness changes the language?
07:46:00 <lilac> Hmm. (ZipList a) is semantically equivalent to (Natural -> a)
07:50:08 <lilac> Saizan: are we matching only finite strings?
07:50:13 <quicksilver> cizra: incidentally ord doesn't assume ascii, it gives you a unicode code point.
07:50:24 <quicksilver> cizra: that coincides with ascii for values < 127 though.
07:50:57 <wli> > let s = "George W. Bush" in sum [ord (toLower c) - ord 'a' | c <- s, isAlpha c]
07:50:59 <lambdabot>   119
07:51:18 * wli foresees a Haskell numerology module.
07:51:21 <cizra> quicksilver: hmm. OK.
07:51:26 <ehird> > let s = "Barry Soetoro" in sum [ord (toLower c) - ord 'a' | c <- s, isAlpha c]
07:51:27 <lambdabot>   159
07:51:37 <ehird> 159. That's one digit away from 119.
07:51:39 <Saizan> lilac: yeah
07:51:39 <ehird> Dun dun DUN
07:51:49 <wli> > let s = "William Lee Irwin" in sum [ord (toLower c) - ord 'a' | c <- s, isAlpha c]
07:51:51 <lambdabot>   159
07:51:57 <lilac> Saizan: in that case, i think the languages must be the same
07:52:11 <ehird> wli: YOU ARE BARACK OBAMA :O
07:52:43 <lilac> Saizan: you can form a mapping between chunks of the regexp and substrings they match
07:52:54 <lilac> Saizan: a string is in the language iff such a mapping exists
07:53:06 <lilac> Saizan: and any mapping which works for a greedy regexp works for a lazy one and vice versa
07:53:17 <lilac> s/lazy/non-greedy/
07:53:44 <Saizan> it does?
07:53:54 <wli> map (\s -> sum [ord (toLower c) - ord 'a' | c <- s, isAlpha c]) ["Barack Hussein Obama", "William Jefferson Clinton", "Henry Kissinger", "Richard Cheney"]
07:54:13 <lilac> Saizan: however, when matching substrings of strings, the same doesn't hold
07:54:27 <lilac> that is, when you want to know /which/ substring matched
07:55:08 <lilac> for instance, "(.*)" and "(.*?)" match different substrings of "abc (def) ghi (jkl) mno"
07:55:21 <Saizan> yeah, i agree with that
07:55:35 <lilac> however "(foo) (bar)" is in both languages
07:55:39 <Saizan> but i don't get what you meant by mappings then
07:56:35 <lilac> well, "(foo) (bar)" is in both languages because it's of the form "(" <stuff> ")"
07:56:42 <PeakerWork> Annoying that string literals are strings, and not some (Str a => a) that has instances for String/ByteString, very clumsy to work with String and ByteString
07:56:42 <lilac> and it doesn't matter that <stuff> also contains a ")"
07:56:56 <lilac> because either that'll lead to a match in the non-greedy version, or it won't
07:57:05 <lilac> in the former case, the string matches, and in the latter case, the string matches
07:57:08 <Saizan> lilac: right, but i think that doesn't hold if you have more complex expressions
07:57:26 <SamB_XP> Peaker: you aren't the first to think that
07:57:43 <wli> map (\s -> sum [ord (toLower c) - ord 'a' | c <- s, isAlpha c]) ["Martin Odersky","William Lee Irwin"]
07:57:44 <SamB_XP> in fact, I there's an extension based on that general idea ...
07:57:44 <PeakerWork> I think by definition the "?" controlling greediness will not affect whether stuff is generally matched, but only the size of the match groups
07:57:48 <lilac> Saizan: i think the property you need is that backtracking will eventually try all options
07:58:11 <lilac> Saizan: and the list of options is the same in both patterns; only the order in which they're tried is affeted
07:58:18 <redditbot> xmonad does it again!
07:58:18 <redditbot> Any good editor (or preferably a Vim plugin) that can display pretty symbols (e.g. \ to λ, -> to →)?
07:58:20 <cizra> > "http://" ++ let conv i = "%" ++ showHex i "" in foldl (++) "" $ map (conv . ord) "web.archive.org/web/20010309130834/http://goatse.cx/hello.jpg"
07:58:21 <lambdabot>   "http://%77%65%62%2e%61%72%63%68%69%76%65%2e%6f%72%67%2f%77%65%62%2f%32%30%...
07:58:33 <wli> Just slap together a name database and form numerological equivalence classes to dredge the field for such things.
07:58:36 <cizra> Took some research, but there it is! My (almost) first Haskell program!
07:58:50 * cizra looks around, surprised at the poor enthusiasm
07:59:02 <lilac> Saizan: this property, for instance, wouldn't hold if the language had cuts in it
07:59:19 <Saizan> cuts?
07:59:30 <lilac> "no backtracking after this point"
07:59:48 <Botje> cizra: get with the time, there's better goatse mirror ;)
07:59:59 <Saizan> oh, prolog cuts, do they have those in regexps too?
08:00:01 <cizra> Botje: Where?
08:00:08 <Botje> goat.cz i think
08:00:20 <cizra> Botje: wrong
08:00:28 <Botje> not anymore
08:00:28 <Botje> boo!
08:00:30 <Botje> booooooooooooo!
08:00:31 <osfameron> Saizan: Perl has ($<...) to not backtrack into the block
08:01:26 <Botje> cizra: anyway, foldl ... $ map ... is probably better written as concatMap
08:01:42 <lilac> Saizan: no, there are no cuts in normal regexps. but if you add them, then the set of languages matched by greedy versus non-greedy Kleene star are different.
08:02:59 <gwern> what self-respecting language lacks a clone of tetris?
08:03:04 <gwern> not haskell anymore: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tetris
08:03:35 <cizra> Version 2.0:
08:03:37 <cizra> > "http://" ++ let conv i = "%" ++ showHex i "" in concatMap (conv . ord) "web.archive.org/web/20010309130834/http://goatse.cx/hello.jpg"
08:03:38 <lambdabot>   "http://%77%65%62%2e%61%72%63%68%69%76%65%2e%6f%72%67%2f%77%65%62%2f%32%30%...
08:03:56 <vixey> Peaker, nongreedy/greedy is like cbv/cbn
08:04:08 <vixey> it's not part of what the language is just execution
08:04:24 <Botje> and conv really is just ('%':) . showHex
08:04:26 <orbitz> gwern: did it take a 12 page paper too?
08:04:35 <gwern> orbitz: fortunately no
08:04:38 <gwern> it took a blog post
08:04:42 <orbitz> haha
08:04:46 <Botje> so "http://" ++ concatMap (('%':) . showHex . ord) ....
08:05:37 <cizra> > "http://" ++ concatMap (("%" ++) . ord) "web.archive.org/web/20010309130834/http://goatse.cx/hello.jpg"
08:05:38 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Int'
08:05:41 <Zao> I thought the RFC mandated that encoding characters that did not need to be encoded was wrong?
08:05:51 <Botje> you forgot the showHex part
08:05:54 <cizra> > "http://" ++ concatMap ((("%" ++) . showHex) . ord) "web.archive.org/web/20010309130834/http://goatse.cx/hello.jpg"
08:05:56 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `ShowS'
08:06:13 <cizra> > "http://" ++ concatMap ((('%':). showHex) . ord) "web.archive.org/web/20010309130834/http://goatse.cx/hello.jpg"
08:06:14 <gwern> lambdabot has ShowS?
08:06:14 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `ShowS'
08:06:37 <cizra> Botje: I'm confused now.
08:06:49 <gwern> next step: since the author was so agreeable and willing to be cabalized and uploaded, I go after Super Nario Bros!
08:07:00 <maltem> gwern: well the Prelude has, if I'm not mistaken
08:07:02 <Zao> Ah no, any character may be encoded, unless it has special meaning.
08:07:15 <gwern> @info ShowS
08:07:16 <lambdabot> ShowS
08:07:16 <lilac> Saizan: if it helps, you can define a regular language as follows: a regular language is a set of strings which is either (1) any single character, (2) any concatenation of finitely many regular languages, (3) any union of two regular languages or (4) the Kleene star of any regular language
08:07:24 <PeakerWork> how do I use the groups in Text.Regex.DFA?  It has a data-type MatchResult which has them, but no function that makes a MatchResult?
08:07:25 <gwern> @hoogle ShowS
08:07:25 <lambdabot> Prelude type ShowS = String -> String
08:07:25 <lambdabot> Text.Show type ShowS = String -> String
08:07:25 <lambdabot> Prelude shows :: Show a => a -> ShowS
08:07:37 <gwern> ah so it is
08:08:15 <Zao> "Encoding a character reserved for a particular scheme may change the semantics of a URL."
08:08:44 <lilac> Saizan: because it's merely a set, it doesn't matter in which order you try / eliminate the options
08:08:52 <gwern> dang, super nario bros is slow
08:09:18 <cizra> Botje: Help?
08:09:25 <maltem> @hoogle MatchResult
08:09:25 <lambdabot> No results found
08:09:29 <SamB_XP> gwern: it doesn't go as fast without the rest of the m
08:09:30 <PeakerWork> Text.Regex is simpler, but is not generalized to ByteStrings as well :(
08:10:03 <SamB_XP> more seriously, did someone finally try to write a cycle-accurate NES emulator in Haskell ?
08:10:22 <wli> That would be interesting.
08:10:32 <gwern> SamB_XP: well given that the level doesn't end and you have to throw yourself into the abyss, I am fairly sure that it is a clone not an emulator
08:10:34 <wli> I'm not sure how timed operations work.
08:11:04 <SamB_XP> gwern: are you sure that isn't just the minus world ?
08:11:09 <gwern> also, turtle shells no longer kill turtles
08:11:20 <wli> "Carry out this unfoldr until a timeout occurs."
08:11:40 <SamB_XP> wli: what are you responding to ?
08:11:56 <wli> SamB_XP: The NES emulator question.
08:12:22 <SamB_XP> I thought so until you said that thing about unfoldr ...
08:12:44 <wli> SamB_XP: The unfoldr would be a simplified example of something timing-sensitive.
08:13:44 <SamB_XP> wli: when I say "cycle accurate", I'm talking about the handling of interactions between the CPU core and the rest of the hardware ...
08:14:03 <SamB_XP> especially the PPU
08:14:11 <PeakerWork> Hmm.. The Regex.DFA code that I imported has: "instance RegexContext Regex String String"  -- but ghci claims: "No instance for (RegexContext Regex [Char] target)" -- why is that?
08:14:15 <wli> I thought enough to make games playable (which goes into real time).
08:14:40 <Saizan> lilac: that's what i usually take as definition :)
08:14:46 <chessguy> HI YA'ALL
08:14:50 <chessguy> whoops
08:14:54 <Riastradh> PeakerWork, what's `target'?
08:15:01 <PeakerWork> Riastradh: open type-variable, I guess?
08:15:19 <Riastradh> Well, is there an instance of RegexContext for a free type variable there?
08:15:19 <wli> SamB: I have an idea that the CPU/peripheral timing issues can be done in a different way.
08:15:20 <PeakerWork> Riastradh: does it mean it has to be open in the instance too?
08:15:20 <lilac> Saizan: you could show it by induction over that construction if you prefer.
08:15:23 <SamB_XP> you don't have to actually synch with the real time except around IO
08:15:33 <SamB_XP> wli: different from what ?
08:15:40 <Saizan> PeakerWork: when it has to eliminate the RegexContext context, ghci needs to pick a type for "target" and it does no guesses
08:15:50 <PeakerWork> ah, cool, thanks!
08:16:05 <wli> SamB_XP: Different from making the emulator run at the original hardware's speed.
08:16:32 <SamB_XP> wli: the important thing is that if the CPU writes something to the PPU, it should impact the rendering in exactly the same way as it would on the real thing
08:17:14 <lilac> SamB_XP: are you thinking of the Donkey Kong Country-type tricks, where the palette is updated during the horizontal retrace?
08:17:16 <SamB_XP> this basically means you have to know at what cycle the write occurs, and not have run the PPU emulation beyond the point at which it would have read that value
08:18:40 <SamB_XP> you also have to ensure that the CPU doesn't run past where the PPU would trigger an interrupt ...
08:19:07 <lilac> SamB_XP: fwiw, this sounds like an ideal candidate for the use of FRP :)
08:19:54 <SamB_XP> I did have that thought as I was reading conal's blog recently
08:19:59 <SamB_XP> or was it that paper ...
08:20:11 <gwern> yo dawg we heard u liek slowdowns so we put a FRP in ur highlevel emulation so u can slowdown while you slowdown
08:20:36 <lilac> gwern: rofl :)
08:20:38 <SamB_XP> gwern: these new "event" things might make it faster
08:20:48 <PeakerWork> does Text.Regex.DFA not support group matches?
08:20:53 <PeakerWork> I can't find any way to extract the groups
08:21:22 <quicksilver> all the regex backends support the same shared frontends don't they?
08:21:31 <quicksilver> group extraction is a function of the frontend
08:21:32 <SamB_XP> :: [String] ?
08:21:49 <gwern> SamB_XP: a little faster. but still nowhere near fast enough I suspect. playable emulators are hard enouh to write in c or asm without doing them in haskell *and* using fancy abstractions like FRP libs
08:22:08 <luite> in copyMU (uvector), is the Int index the position where it starts reading, or where it starts writing? "Copy the contents of an immutable unboxed array into a mutable one from the specified position on"
08:22:32 <PeakerWork> quicksilver: I can't find the interface that does that.. I thought it would be "submatches" but its not that
08:22:42 <SamB_XP> gwern: well, it seems to be headed vaguely in the right direction
08:23:22 <SamB_XP> it might be possible to adapt that FRP stuff to help out with the high-level organization
08:24:07 <PeakerWork> Text.Regex itself only works with Strings, and not ByteStrings ... :-(
08:24:41 <gwern> if wishes were fishes beggars would fry
08:25:04 <quicksilver> PeakerWork: which variety of match are you using?
08:25:28 <PeakerWork> quicksilver: I tried using various types for the match, from Text.Regex.DFA
08:25:39 <quicksilver> ( RegexLike a b => RegexContext a b (b, b, b, [b]) )
08:25:42 <PeakerWork> quicksilver: Is that what you mean?
08:25:50 <quicksilver> ^^ is one of the ones which reports substrings
08:25:58 <quicksilver> the API did vary slightly between versions
08:26:32 <PeakerWork> quicksilver: that's a class, not an API? :)
08:27:22 <quicksilver> yes, but the api is in terms of RegexContext instances
08:27:26 <quicksilver> at least, one of them is.
08:27:38 <PeakerWork> quicksilver: which instance gives me access to the groups?
08:27:41 <cizra> > map \x -> ('%':) . showHex \x "" 1 -- why doesn't it work?
08:27:42 <lambdabot>   <no location info>: parse error on input `\'
08:27:48 <PeakerWork> quicksilver: I can't find one
08:28:17 <quicksilver> PeakerWork: the one I just pasted.
08:28:36 <PeakerWork> the 4-tuple?
08:28:41 <quicksilver> cizra: you just want x, not \x, the scond time.
08:28:42 <quicksilver> Yes.
08:28:52 <quicksilver> the [b] component of the 4-tuple is the groups
08:28:59 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/regex-base/Text-Regex-Base-Context.html
08:29:03 <chrisdone> I've always wondered why \x -> .. isn't the same as $ \x -> ..
08:29:06 <PeakerWork> > match (makeRegex "(h)(e)llo"::Regex) "hello" :: (String, String, String, [String]) -> ("","hello","",[])
08:29:07 <lambdabot>   <no location info>: parse error on input `"'
08:29:23 <cizra> > map \x -> ('%':) . showHex x "" 1 -- yay
08:29:24 <lambdabot>   <no location info>: parse error on input `\'
08:29:25 <chrisdone> > flip map [1..10] \x -> (x+1)
08:29:26 <lambdabot>   <no location info>: parse error on input `\'
08:29:33 <chrisdone> > flip map [1..10] $ \x -> (x+1)
08:29:34 <PeakerWork> quicksilver: that seems to give an empty list there?
08:29:34 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
08:29:58 <quicksilver> PeakerWork: yeah, that looks broken.
08:30:02 <quicksilver> odd.
08:30:08 <chrisdone> :t showHex
08:30:09 <lambdabot> forall a. (Integral a) => a -> String -> String
08:30:30 <PeakerWork> quicksilver: DFA is broken. PCRE works! yay, thanks
08:30:38 <chrisdone> :t showHex undefined "" 1
08:30:40 <lambdabot>     Couldn't match expected type `t1 -> t'
08:30:40 <lambdabot>            against inferred type `String'
08:31:01 <wli> > map (\x -> '%' : showHex x "") [8..12]
08:31:03 <lambdabot>   ["%8","%9","%a","%b","%c"]
08:31:17 <quicksilver> PeakerWork: ;)
08:31:35 <PeakerWork> quicksilver: this was hard... whew
08:31:53 <quicksilver> I think the regexp api is an... unusual design.
08:32:02 <quicksilver> Its author had reasons for the choices though.
08:32:40 <cizra> > map \x -> ('%':) . showHex x "" [1] -- hmm..
08:32:41 <lambdabot>   <no location info>: parse error on input `\'
08:33:05 <cizra> > map (\x -> ('%':) . showHex x "") [1] -- hmm!
08:33:06 <lambdabot>   Couldn't match expected type `a -> [Char]'
08:33:26 <chrisdone> :t showHex undefined ""
08:33:27 <lambdabot> String
08:33:39 <chrisdone> :t id . ""
08:33:40 <lambdabot>     Couldn't match expected type `a -> b'
08:33:40 <lambdabot>            against inferred type `[Char]'
08:33:40 <lambdabot>     In the second argument of `(.)', namely `""'
08:34:08 <chrisdone> you're using (.), but ‘showHex x ""’ isn't a function
08:34:21 <chrisdone> it's a [Char]/String
08:34:34 <chrisdone> :t (.)
08:34:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:35:20 <chrisdone> try removing (.)
08:36:27 <cizra> chrisdone: Oh, right.
08:36:30 <PeakerWork> quicksilver: its the typeclass-heaviest interface I've ever seen
08:36:37 <PeakerWork> quicksilver: very big learning curve - no examples whatsoever to be found
08:36:59 <PeakerWork> quicksilver: also, some of the interface is inconsistently specific about its types, rather than being elegantly type-classed, and not in the Maybe monad properly
08:38:30 <quicksilver> PeakerWork: well, my dislike of typeclasses is well recorded :)
08:38:40 <gwern> dcoutts_: any idea when gtk2hs will be released for 6.10?
08:38:49 <dcoutts_> gwern: no idea
08:39:03 <dcoutts_> gwern: ask on the gtk2hs-users mailing list
08:39:16 <dcoutts_> or pgavin if you catch him around
08:39:23 * gwern thought dcoutts_ was tight and all that shiznit with gtk2hs's devs
08:39:27 <PeakerWork> quicksilver: I like them, but I have not written that much code yet.. :)
08:39:51 <dcoutts_> gwern: I've not been hacking on gtk2hs for a while now, pgavin took over as release manager
08:40:15 <gwern> ah.
08:40:18 <gwern> @seen pgavin
08:40:18 <lambdabot> pgavin has changed nick to pgavin-away.
08:40:18 <lambdabot> Last time I saw pgavin-away was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-
08:40:18 <lambdabot> hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #
08:40:18 <lambdabot> haskell_ru, #jhc, #jtiger, #macosx, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 4m 2d 14h 39m 18s ago, and .
08:40:50 <quicksilver> preflex: seen pgavin
08:40:51 <preflex>  pgavin was last seen on #haskell 38 days, 4 hours, 2 minutes and 54 seconds ago, saying: anyone here familiar with the paper "Notions of computation and Monads" by E. Moggi?
08:43:59 <PeakerWork> quicksilver: PCRE seems to support non-greedy matching too
08:45:05 <chrisdone> are ByteString chunks always the same size?
08:46:43 <quicksilver> PeakerWork: yes, because libpcre does/
08:46:55 <quicksilver> PeakerWork: libpcre supports almost everything perl does
08:47:00 <quicksilver> that's what the p stands for.
08:47:03 <quicksilver> chrisdone: no.
08:47:08 <chrisdone> mmkay
08:47:16 <quicksilver> chrisdone: but if they're created by, for example, file IO, they will be some standard szie.
08:47:34 <quicksilver> chrisdone: if you create them yourself (e.g. by "pack") then they will be whatever size you put in.
08:47:41 <quicksilver> and `mappend` never merges chunks.
08:47:57 <chrisdone> sure. alright, I'll just make my algorithm chunk length agnostic
08:48:03 <quicksilver> (of course even with file IO there will be a trailing chunk which is shorter)
08:48:15 <chrisdone> true
08:48:20 <quicksilver> unless all your files are a multiple of chunk size precisely
08:55:11 <centrinia> Why isn't (sum (repeat 0) == 0) ?
08:55:53 <chrisdone> will it halt?
08:56:00 <centrinia> No.
08:56:32 <Tobsan> @src sum
08:56:32 <lambdabot> sum = foldl (+) 0
08:57:03 <oskarM> sum (repeat 0) == _|_
08:57:08 <Botje> centrinia: why isn't it 1 ?
08:58:03 <vixey> centrinia, define 0 repeat sum and == as GADTs
08:58:30 <chessguy> centrinia:  think of it this way, what should be the result of "sum (repeat 2)"? your expression is evaluated the same way
08:58:32 <centrinia> vixey, how does that help?
08:58:38 <vixey> it doesn't :(
08:58:47 <chessguy> @slap vixey
08:58:47 * lambdabot orders her trained monkeys to punch vixey
08:58:53 <vixey> in mathematics, sum (repeat 0) isn't actually 0 is it?
08:59:03 <centrinia> It isn't?
08:59:12 <vixey> I'm not sure
08:59:15 <chessguy> can you sum an infinite set?
08:59:33 <quicksilver> vixey: the most reasonable answer is 'yes, it is'
08:59:34 <pizza_> sure, it just takes a while
08:59:38 <lilac> vixey: it depends what you mean by sum, but the partial sums are absolutely convergent, so probably
08:59:48 <quicksilver> of course an infinite sum is not defined, technically
08:59:56 <quicksilver> but that sum defines an infinite series which converges
08:59:59 <athos> :t repeat
09:00:00 <lambdabot> forall a. a -> [a]
09:00:07 <athos> > repeat 0
09:00:08 <quicksilver> so people woudl tend to abuse notation and say the infinite sum is defined, and is 0.
09:00:08 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:00:12 <vixey> so really there an axiom
09:00:35 <chessguy> hm, i wonder if there would be a way to 'mark' values as infinite or finite, at a type level
09:00:42 <lilac> Note: sum (repeat 0) = sum (0:repeat 0) = 0 + sum (repeat 0). Every value is a fixed point of this.
09:00:51 <quicksilver> chessguy: Yes. It's a popular subject of research.
09:00:58 <quicksilver> chessguy: infinite values are called "codata".
09:01:19 <chessguy> i suppose i should have known better than to ask :)
09:01:30 <quicksilver> you get the property that programs written entirely over "data" and using only a restricted form of recursion, are guaranteed to terminate.
09:01:43 <quicksilver> Turner wrote a relatively recent review paper if you're interested :
09:01:44 <chessguy> oh interesting
09:01:46 <quicksilver> :)
09:02:22 <chessguy> it's ok, i'm sure it's over my head anyway :)
09:02:34 <lilac> quicksilver: got a link?
09:03:30 <centrinia> quicksilver, is this the same Turner as the author of the 1979 paper on how to do lazy evaluation with combinators?
09:03:34 <quicksilver> yes.
09:03:42 <quicksilver> he wrote the lazy language 'Miranda'
09:03:43 <vixey> oh if you prove a sum is cauchy convergent then maybe it is ok to identify it with a real number
09:03:49 <quicksilver> well, I'm sure he didn't do all the work, but much of it.
09:03:52 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haxr -- is it just me, or is this a blank page?
09:03:54 <centrinia> Oh.
09:04:27 <centrinia> Cale, it is just us two. :(
09:04:28 <chessguy> Cale: looks blank to me
09:04:50 <chessguy> shouldn't it say "This page unintentionally left blank"?
09:04:58 <SamB_XP> chessguy: no
09:05:10 <centrinia> chessguy, that would be paradoxical. :(
09:05:22 <SamB_XP> that would be (a) false and (b) a lie
09:05:23 <quicksilver> lilac: http://www.cs.mdx.ac.uk/staffpages/dat/
09:05:32 <quicksilver> lilac: the 2004 paper linked there
09:05:33 <SamB_XP> if you marked it, that would mean you intended it to be as it was
09:05:41 <chessguy> centrinia, SamB_XP, that was the point. don't take me so seriously
09:05:54 <quicksilver> as I recall it's an easy read.
09:05:58 <SamB_XP> if you say it's left blank, that's a lie
09:06:20 <chessguy> 2004 is recent?
09:06:26 <quicksilver> yes :)
09:06:31 <centrinia> "This page unintentially left blank except for this notice." :)
09:06:44 <SamB_XP> centrinia: who would believe that ?
09:06:52 <chessguy> centrinia:  now you're getting into the spirit!
09:06:55 <quicksilver> Cale: wget reports a 200 status code but a 0 byte content. Odd.
09:07:25 <lilac> quicksilver: thanks!
09:08:08 <Cale> "This page was supposed to be left blank, but we wrote this notice here by mistake."
09:08:17 <SamB_XP> what page is it ?;
09:08:21 <PeakerWork> can I get ghc to statically link with gmp?
09:08:25 <chessguy> Cale:  :)
09:08:32 <SamB_XP> oh, that hackage url
09:08:40 <chessguy> Cale:  the page evolved by random chance
09:09:06 <centrinia> I think it was intelligently designed.
09:09:22 <SamB_XP> for comparison, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haxrrr gives a 404
09:10:44 <centrinia> Where can we download the HackageDB source code?
09:12:56 <Saizan> centrinia: http://darcs.haskell.org/hackage-scripts/ current
09:13:22 <Saizan> centrinia: http://code.haskell.org/hackage-server/ what's going to replace it
09:14:04 <centrinia> Saizan: Thank you.
09:16:09 <PeakerWork> trying to build with -optl-static: /home/ian/6.10.1/ghc-6.10.1/libffi/build/src/dlmalloc.c:2486:0: undefined reference to `pthread_mutex_lock'
09:16:25 <PeakerWork> funny I can see the homedir name of the ghc builder :-)
09:17:41 <klinkers> are there any implementations of svm or rbm in haskell?
09:18:24 <frasav> ciao
09:18:30 <frasav> lista!
09:18:42 <quicksilver> klinkers: bayesian stuf?
09:18:49 <pumpkin> klinkers: support vector machine?
09:19:02 <pumpkin> what's the r in rbm though?
09:20:23 <cizra> Quoting Real World Haskell:
09:20:29 <cizra>  laziness ensures that the list will only be sorted enough to find the k minimal elements.
09:20:32 <cizra> minima k xs = take k (sort xs)
09:20:36 <cizra> How the hell is this possible?
09:20:56 <quicksilver> depends on the sort implementation used.
09:21:08 <quicksilver> you know how a merge sort works?
09:21:13 <cizra> yes
09:21:26 <quicksilver> well when you're merging sublists, you can stop once you've produced k elements.
09:21:37 <quicksilver> you still have done quite a lot of the work
09:21:40 <quicksilver> but not quite all of it.
09:22:05 <cizra> Mm.. let's take Quicksort instead, it's easier
09:22:10 <cizra> I think I get it.
09:22:11 <quicksilver> quicksort would have a similar property, but would depend on which pivot you chose
09:22:20 <quicksilver> (as quicksort always does)
09:22:25 <cizra> Take a high enough pivot, throw away the high side, sort only the low side.
09:22:31 <quicksilver> right.
09:22:42 <quicksilver> at some point your pivot has more than k elts to the left of it
09:22:44 <quicksilver> (hopefully)
09:22:46 <cizra> Oh, right.
09:22:51 <quicksilver> and then you can give up on the rest of it.
09:22:57 <klinkers> pumpkin: yes. rbm = restricted boltzmann machines
09:22:59 <cizra> I thought the book says they can do it in less than O(N) time.
09:23:03 <quicksilver> nah
09:23:06 <quicksilver> it's O(N)
09:23:13 <quicksilver> it's just not the entire O(N log N)
09:23:17 <wli> cizra: Comparisons make things Omega(n) but the Theta(n*lg(n)) part is cut down by not having to fully reorder the tail of the list.
09:23:19 <quicksilver> it's around O(N log K), I believe.
09:23:24 <cizra> It's more than O(N), I'd argue
09:23:33 <quicksilver> yes
09:23:34 <pumpkin> klinkers: unfortunately not that I know of
09:23:36 <quicksilver> appros N log K
09:24:20 <quicksilver> but obviously N log K < N log N.
09:24:21 <cizra> wli: Theta is pretty precise estimate.. are you sure?
09:24:37 <cizra> quicksilver: sure. Thanks.
09:24:41 <PeakerWork> quicksilver: I see why its N log K as K approaches N, but is it really N log K at the beginning?
09:24:43 <wli> cizra: In C, you do this by maintaining a finite heap with at most k+1 elements ordered so the maximum may be dequeued. When it has k elements in it, enqueueing is followed by dequeueing to ensure there are no more than k in the heap.
09:24:56 <quicksilver> PeakerWork: I'm too lazy to work that out.
09:25:02 <quicksilver> PeakerWork: quite possibly not ;)
09:25:17 <cizra> wli: I'd really rather do Quicksort, it'd be much easier
09:25:23 <cizra> wli: (I guess)
09:25:33 <wli> cizra: n*lg(k) follows immediately. In Haskell, laziness accomplishes this without having to explicitly write anywhere near as much.
09:25:39 <cizra> wli: hmmm, not sure again..
09:25:54 <cizra> OK, thanks everybody!
09:26:26 <quicksilver> recursive chains of thunks model heaps, under some circumstances.
09:26:39 <quicksilver> I think this fact is subtle and I've never seen it spelled out clearly.
09:26:39 <pumpkin> what's a "shape" of quicksort input that gives it quadratic time?
09:26:48 <quicksilver> pumpkin: all pivots at one end.
09:26:54 <cizra> pumpkin: Yeah, bad pivots
09:26:59 <centrinia> Or the other. ;)
09:27:02 <quicksilver> (so, whatever input gives you that, depending on your pivot choice)
09:27:08 <centrinia> You can alternate between each end.
09:27:15 <quicksilver> if pivot choice is a[0] then sorted is bad.
09:27:22 * wli doesn't like quicksort because he keeps running into worse-than-average cases.
09:27:25 <quicksilver> for any other pivot choice algorithm there is a worst-case, though.
09:27:28 <pumpkin> the typical implementation I've seen in haskell picks the pivots from the head of the list
09:27:37 <quicksilver> it has to, yes
09:27:44 <quicksilver> that's the only point it has O(1) access to :)
09:27:45 <pumpkin> yup
09:27:52 <centrinia> If the pivot choice is a[rand() & 1 ? size-1 : 0] then it is equally bad.
09:27:55 <cizra> wli: They say that the average time of Quicksort still beats everything else.
09:28:00 <quicksilver> the haskell implementation of quicksort is nothign like quicksort.
09:28:07 <pumpkin> ok :)
09:28:14 <quicksilver> the haskell implementation of quicksort is actually more like a proof that quicksort is correct.
09:28:19 <quicksilver> which is not surprising, I guess.
09:28:20 <PeakerWork> quicksilver: its going to do O(N) division by pivot, its allowed to take O(N) to choose the pivot :)
09:28:32 <wli> There are true quicksorts in Haskell using arrays.
09:28:34 <pumpkin> cizra: how about bogosort! define "beats" ;) I like my sorting slow
09:28:39 <quicksilver> PeakerWork: yes, but it's trying to only do log N divisions...
09:28:51 <quicksilver> wli: of course, yes.
09:28:59 <quicksilver> wli: I was just assuming that's not the one we've been talking about ;)
09:29:04 <cizra> pumpkin: You mean, take an array, check if the values are the same ones as in the original, check if it's sorted?
09:29:07 <centrinia> quicksilver, we were both wrong. Selecting the maximum or the minimum element is bad. ;)
09:29:22 <pumpkin> cizra: and shuffle if not, yup
09:29:25 <cizra> centrinia: Picking the average would be ideal
09:29:28 <wli> Selection sort is my usual preferred way to sort arrays in a dumber-than-thou obviously-correct way.
09:29:29 <quicksilver> centrinia: yes, that's what I meant by 'at one end'
09:29:32 <centrinia> cizra, no.
09:29:44 <centrinia> Picking the median is best.
09:29:48 <PeakerWork> quicksilver: yeah, why not use xs!!(length xs/2)   I don't think it ruins the complexity?
09:30:02 <pumpkin> centrinia: now how do you get the median without sorting
09:30:12 <PeakerWork> pumpkin: there's an O(N) algorithm to find the median
09:30:13 <quicksilver> PeakerWork: don't forget you redo that on each side.
09:30:14 <pumpkin> oh yeah
09:30:16 <PeakerWork> pumpkin: its quite a crazy one though
09:30:18 <pumpkin> the order statistic thing
09:30:18 <cizra> pumpkin: by counting, O(N)
09:30:22 <quicksilver> PeakerWork: you pick O(N) pivots in the end.
09:30:23 <PeakerWork> pumpkin: not even statistically
09:30:25 <centrinia> pumpkin, you can sort subarrays.
09:30:48 <quicksilver> PeakerWork: its' not just log N pivots you choose...
09:30:51 <centrinia> You can sort subarrays of size sqrt(N).
09:30:54 <PeakerWork> quicksilver: out of ever-decreasing N's though
09:31:03 <centrinia> Pick the median of each subarray and sort that.
09:31:03 <quicksilver> PeakerWork: sure, but increasingly many of them.
09:31:09 <quicksilver> PeakerWork: it's O(N) in the end
09:31:18 <quicksilver> PeakerWork: because in the end, all your arrays are down to 3 elements (say)
09:31:23 <quicksilver> PeakerWork: so that's N/3 pivots.
09:31:25 <centrinia> The median of subarray medians is the median of the array.
09:31:30 <quicksilver> or whatever base case you choose to stop.
09:31:39 <PeakerWork> quicksilver: yeah I see
09:33:21 <sinelaw> what sort of work has been done to statically analyze haskell programs?
09:33:30 <sinelaw> manually/automatically
09:33:44 <wli> I like heapsort because it's nice and deterministic.
09:34:23 <adekoba> is there any way to handle decode (http://hackage.haskell.org/packages/archive/binary/0.4.4/doc/html/Data-Binary.html#v%3Adecode) in pure code without having to deal with catch?
09:34:46 <adekoba> I'm really wishing right now decode was ByteString -> Maybe a
09:35:07 <wli> I wrote an analogue of sort(1) that does selection of the k smallest at one point.
09:35:16 <pumpkin> is there an easy way to go from a "square" list-of-lists to a "triangular" one, by moving along its diagonals?
09:35:39 <wli> pumpkin: It's not easy, but I've written it.
09:36:50 <Saizan> adekoba: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-strict ?
09:36:57 <centrinia> let permsort xs = let inorder [] = True; inorder xs = and $ zipWith (<=) xs (tail xs) in head $ filter inorder $ permutations xs
09:37:17 <centrinia> > let permsort xs = let inorder [] = True; inorder xs = and $ zipWith (<=) xs (tail xs) in head $ filter inorder $ permutations xs -- That is my favorite sorting algorithm.
09:37:18 <lambdabot>   <no location info>: parse error on input `;'
09:37:42 <adekoba> Saizan: I don't know that binary-strict would be any different from binary in terms of the way it handles errors
09:38:22 <Saizan> adekoba: it is http://hackage.haskell.org/packages/archive/binary-strict/0.3.0/doc/html/Data-Binary-Strict-Get.html#v%3ArunGet
09:39:11 <adekoba> Saizan: well, look at that. Do you know if it is stable?
09:40:53 <Saizan> adekoba: i don't know
09:45:25 <gwern> I have a question; which construct guarantees sharing, that a function won't be called multiple times? 'let policy = getPolicy h in...' or '... where policy = getPolicy h'?
09:45:46 <quicksilver> both.
09:46:08 <quicksilver> they are the same, module syntactical issue about which is actually legal to write where in a syntactic form.
09:46:20 <quicksilver> where is rewritten to let in the front-end.
09:46:35 <quicksilver> ^^ both - assuming policy is monomorphic.
09:46:42 <gwern> ah. for some reason I thought they had different behaivours
09:46:44 <quicksilver> (or parametrically polymorphic, is fine)
09:47:09 <quicksilver> "case getPolicy h of policy -> ..." will work too ;)
09:47:15 <quicksilver> so many choices.
09:48:05 <gwern> case is just obfuscating now; the issue is that otherwise there are 5 or 6 writings of 'getPolicy h' andthat seems inefficient
09:48:25 <sbahra> Cale, ping?
09:48:31 <Cale> hi
09:49:05 <sbahra> Cale, hi
09:49:17 <sbahra> Cale, could you add #haskell-FreeBSD to lambdabot's join list?
09:49:28 <Cale> sbahra: Again?
09:49:29 <gwern> http://code.tupil.com/voting/ <-- nice
09:49:37 <Cale> sbahra: Oh
09:49:42 <Cale> sbahra: That's a different one :)
09:50:07 <sbahra> Yes
09:50:42 <Cale> okay
09:50:54 <quicksilver> gwern: case wasn't a serious suggesting, it's too syntactically noisy.
09:51:00 <quicksilver> gwern: it was just for completeness.
09:51:11 <quicksilver> of course, you have to use case if getPolicy h unlocks a GADT or an existential.
09:51:13 <sbahra> Cale, thanks!
09:51:19 <quicksilver> (that is, if a new type comes into scope)
09:51:40 <Cale> lambdabot: @join #haskell-freebsd
09:53:11 <Badger> o_O
09:55:19 <gio123>  Cale, ping?
09:58:19 <redditbot> Use of the Bird-Meertens Formalism (like the original paper, but uses pseudo-Haskell notation instead of Squiggol) [PDF]
09:58:27 <dons> ?users
09:58:27 <lambdabot> Maximum users seen in #haskell: 573, currently: 568 (99.1%), active: 27 (4.8%)
10:00:34 <mornfall> Hm. Is there a way to make a haskell program forget a computed value, forcing re-evaluation upon next use? (I don't anticipate any further use tho...).
10:00:46 <adekoba> dons: is there a reason for just using "error" instead of Maybe or Either for "fail" in the binary package?
10:00:54 <dons> mornfall: parameterise it by something
10:01:05 <dons> adekoba: yeah, Either or Maybe would make it strict
10:01:11 <dons> its a tricky issue
10:01:16 <adekoba> dons: ah, I see.
10:01:18 <mornfall> dons: Don't understand. :|
10:01:29 <PeakerWork> mornfall: I think you can use:  f () = <blah>      instead of  f = <blah>
10:01:30 <dons> mornfall: make it a function
10:01:48 <mornfall> Hmmm.
10:01:54 <shapr> dons: What's the current high water mark?
10:02:03 <mornfall> So I make a list of functions and when I evaluate it, the actual values won't be stored?
10:02:14 <dons> 586, shp
10:02:17 * mornfall tries.
10:02:24 <dons> mornfall: why od you wanto reevaluate a pure value?
10:02:42 <adekoba> dons: will strict bytestrings be included in the binary package, or will that be left for binary-strict?
10:02:53 <mornfall> dons: Because it'd make the memory use O(1) instead of O(n) in the list length.
10:03:21 <vixey> mornfall, let it go, the GC will deal with it
10:03:22 <dons> adekoba: i think it'll stay with binary-strict
10:03:26 <mornfall> vixey: It won't.
10:03:27 <dons> mornfall: interesting
10:03:36 <vixey> mornfall, use C and free() then
10:03:44 <mornfall> vixey: Not applicable.
10:04:36 <mornfall> dons: Well, the problem is that darcs is walking a list of patches, applying them *and* changing some. The GC won't collect the unchanged patches though, since they are in a list with values that'll be needed later.
10:06:08 <mornfall> Well, I could possibly work around that by only accumulating changed patches, but I'm not sure what to do with those then.
10:12:39 <PeakerWork> @type getArgs
10:12:41 <lambdabot> Not in scope: `getArgs'
10:12:46 <PeakerWork> @type System.Environment.getArgs
10:12:47 <lambdabot> IO [String]
10:12:51 <PeakerWork> Does this inlcude argv[0] (the progname)?
10:14:21 <Zao> try it and see?
10:14:44 <sebaseba> PeakerWork: no
10:14:52 <PeakerWork> thanks
10:15:23 <PeakerWork> how hard is it to use ghc as a cross-compiler?
10:16:10 <augustss> PeakerWork: That's not been streamlined at all AFAIK.
10:16:59 <augustss> The current ghc has too many #ifdefs. :(
10:17:37 <PeakerWork> I always wondered why compilers are so biased in their code generation towards the platform they happen to be running on :)
10:17:57 <Zao> PeakerWork: Efficiency.
10:18:41 <PeakerWork> Zao: why does it help efficiency?
10:18:51 <dons> http://www.reddit.com/r/programming/comments/7l4ix/controlling_llvm_from_haskell_safe_high_level/ go  go
10:19:04 <tristes_tigres> vixey: hi, where does the name "omega race" come from ? Some paper ?
10:19:19 <vixey> yes
10:19:37 <tristes_tigres> vixey: google doesn't seem to know about it
10:19:58 <tristes_tigres> lots of hits about some arcade game
10:20:11 <vixey> I took the names and some code from www.informatik.uni-bonn.de/~ralf/WG2.8/22/slides/tarmo.pdf
10:20:29 <tristes_tigres> vixey: thanks
10:21:21 <quicksilver> PeakerWork: it gives you a cheap way to check various things like int size and C ABI and so on.
10:21:31 <quicksilver> PeakerWork: I'm not sure that's a particularly good reason.
10:21:53 <quicksilver> I don't know what the key tradeoffs are which make GHC not have cross-compilation support.
10:24:02 <rene> nabend
10:25:45 <rene> bye bis morgen
10:26:52 <quicksilver> veyr polite.
10:28:57 <vixey> "we have enough knowledge to depart from the old world but we don’t yet know enough to produce a well-organized alternative. . ."
10:29:59 <SamB_XP> where'd you read that ?
10:32:48 <vixey> SamB: On the meaning of logical rules I
10:35:22 <_ar> i am trying to understand seq. if seq forces evaluation of a thunk, why does it take two arguments?
10:35:36 <dons> evaluation is a side effect
10:35:59 <dons> so you're saying 'eval x' then continue doing y
10:36:15 <_ar> oh i see, for something like cps?
10:36:36 <hugo___> i dont understand how the monad reader works
10:36:56 <hugo___> it seems like magic
10:37:00 <hugo___> amazing :)
10:37:17 <augustss> hugo___: do you understand how the state monad works?
10:37:46 <hugo___> i mean, i did a "read-only state" using the monad reader, and im amazed that it works :)
10:37:47 <augustss> _ar: what would it return if it didn't have two arguments?
10:38:03 <hugo___> i dont understand the state monad also... maybe i should read about it
10:38:31 <augustss> hugo___: if you understand state, then reader and write are special cases of that.
10:38:39 <hugo___> hmm ok
10:38:41 <_ar> augustss, an evaluated version of the argument? like identity but with forced evaluation
10:38:47 <hugo___> what is the best place to read about it ?
10:39:10 <augustss> _ar: but that's what id does already
10:39:13 <quicksilver> _ar: but that itself would only be called lazily. So that wouldn't help.
10:39:28 <quicksilver> f (strict_id x)
10:39:53 <quicksilver> ^^ strict_id can force the evaluation of x, but that's no use, since the whole (strict_id x) thunk will not get evaluated until (if ever) f demands it.
10:39:56 <augustss> _ar: you only call id when you need the value.  The same with seq, you only call it when you need the value.
10:40:17 <augustss> quicksilver: also strict_id == id
10:40:27 <quicksilver> augustss: indeed, I know that :)
10:40:37 <quicksilver> I just felt that was a good way to explain it.
10:40:40 <pumpkin> if you call longList `seq` 5, it'll only evaluate the head of longList, or the entire thing?
10:40:41 <hugo___> if there is a monad reader, and a monad writer, what about a monad nothing ?
10:40:48 <quicksilver> pumpkin: not even that.
10:40:49 <augustss> quicksilver: yes
10:41:02 <quicksilver> pumpkin: just whether or not it is empty ([]) or a cons-cell (:)
10:41:06 <pumpkin> ah
10:41:09 <augustss> hugo___: yes, there's the identity monad
10:41:16 <hugo___> hehe :)
10:41:16 <hugo___> nice
10:41:23 <hugo___> oh well, time to leave
10:41:28 <hugo___> see ya tomorrow ppl
10:41:30 <hugo___> thanks
10:41:42 <drdozer> hi
10:41:52 <_ar> so why is seq not subject to the same restrictions as strict_id; specifically becoming embedded in a thunk itself?
10:41:56 <_ar> or am i missing the point?
10:42:00 <augustss> _ar: it is
10:42:03 <drdozer> is there a cheep way to sample a particular random permutation of a list?
10:42:16 <dons> drdozer: an interesting question!
10:42:17 <luite> drdozer: no
10:42:25 <augustss> _ar: the first argument is not evaluated until the seq thunk is evaluated
10:42:30 <chrisdone> http://img518.imageshack.us/img518/165/goofyhaskellfa9.png
10:42:36 <drdozer> my initial plan of 'uniformSample $ permutations list' spins for large lists :)
10:42:46 <drdozer> presumably because there are a bazillion permutations
10:43:24 <augustss> drdozer: yeah, that's not the best way to make a random list permutation.
10:43:37 <Japsu> yeah, basic combinatorics tells you any plan that starts with "generate all permutations of x" is bound to fail ;)
10:44:24 <luite> drdozer: there is a simple way of making a random permutation of a list: zip it with a list of random numbers, sort on the random numbers. but that is not perfectly uniform
10:44:50 <augustss> > const 1 (seq (error "no") 2)
10:44:51 <lambdabot>   1
10:45:05 <augustss> _ar: like that^
10:45:30 <pyNem> drdozer, this should help you http://okmij.org/ftp/Haskell/perfect-shuffle.txt
10:46:16 <luite> drdozer: if you really need something fast, a list is probably not the right data structure for making permutations
10:46:59 <drdozer> thanks all
10:47:47 <_ar> augustss, i see
10:48:15 <luite> drdozer: for fast permutations of unboxed arrays, you can use this: http://www.hpaste.org/13186#a3
10:49:23 <Olidu> Real World Haskell is good
10:49:30 <dons> Olidu: yay!
10:50:02 <Olidu> if any of the contributors are here, thank you!!
10:50:08 <dons> Olidu: :) thanks. we're all here.
10:50:21 <dons> well, bos and jgoerzon not at the moment, but often
10:50:53 <Olidu> dons=Don Stewart?  WOW!
10:51:05 <augustss> dons: you need more titles, Real World Haskell goes West, Real World Haskell vs. Predator, Real World Haskell Returns, etc.
10:51:17 <dons> Real World Haskell: The Lambdapocalypse!
10:51:19 <SamB_XP> Olidu: oh, you mean he isn't listed as dons on the cover ?
10:51:28 <dons> Son on Real World Haskell
10:51:40 <sbahra> Don "dons" Stewart
10:51:41 <dons> Real World Haskell vs Godzilla
10:51:50 <dons> battle of the large compilers
10:51:51 <Japsu> Real World Haskell: The Imperative Strikes Back
10:51:56 <sbahra> Japsu, haha
10:52:00 <luite> Japsu: hee
10:52:07 <dons> oh noes!
10:52:13 <Japsu> ^_______^
10:52:13 <Olidu> dons, you got time to both chat and write such a nice book?
10:52:15 <solrize> i was a teenage monad
10:52:37 <dons> Olidu: i drift in and out
10:52:41 <SamB_XP> vixey: so this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.3025
10:53:04 <vixey> SamB_XP: yes
10:53:20 <SamB_XP> (they really need to do better at telling the difference between a title and an abstract!)
10:58:47 <BMeph> dons: Eh? Is John giving up the CosmicRay handle, then? :)
10:59:42 <dons> ?users
10:59:42 <lambdabot> Maximum users seen in #haskell: 575, currently: 572 (99.5%), active: 24 (4.2%)
11:00:01 <athos> > foldr (:) "bar" "foo"
11:00:02 <lambdabot>   "foobar"
11:02:05 <augustss> SamB_XP: Girard is quite a character.
11:02:25 <rtjd> @type fst
11:02:26 <lambdabot> forall a b. (a, b) -> a
11:02:44 <rtjd> @type uncurry fst
11:02:46 <lambdabot> forall b b1 c. ((b1 -> c, b), b1) -> c
11:03:22 <augustss> @type curry fst
11:03:23 <lambdabot> forall a b. a -> b -> a
11:03:30 <rtjd> @eval ((+ 5) . (* 2)) 10
11:03:53 <rtjd> @run ((+ 5) . (* 2)) 10
11:03:54 <lambdabot>   25
11:04:16 <Zao> PeakerWork: Knowing things like platform register count and suchlike early in the compilation process may be beneficial.
11:04:41 <centrinia> I tried to render the HTML for the Hackage page for haxr. It was not empty. :(
11:06:54 <athos> @type mapReduce
11:06:55 <lambdabot> Not in scope: `mapReduce'
11:07:06 <chrisdone> I know, sisface. I love the Lake District, too
11:09:19 <BMeph> alsonk: awake? :)
11:09:34 <alsonk> BMeph: awake and highly caffeinated
11:09:46 <BMeph> alsonk: Yee-HAW! ;)
11:09:49 <alsonk> ;)
11:11:27 <BMeph> alsonk: I was wondering if you had some kind of "why I made these design decisions" for Turbinado.
11:11:58 <BMeph> alsonk: Also, I was wondering if you've pinned down why/where 6.10 breaks it.
11:12:00 <vixey> augustss, I was just reading that mustard watches earler http://iml.univ-mrs.fr/~girard/mustard/article.html
11:12:14 <alsonk> BMeph: I do, but they're all stuck in my head right now...  I need to write up that Architecture page...
11:12:33 <BMeph> @type uncurry (const id)
11:12:33 <lambdabot> forall a a1. (a1, a) -> a
11:12:35 <alsonk> BMeph: "hs-plugins" is broken in 6.10, so I need to migrate to "ghc-api"
11:12:39 <chrisdone> hahaha
11:13:27 <alsonk> BMeph: unfortunately, ghc-api isn't too well documented, so it'll take me a bit of time.  Also, Debian unstable is still 6.8.
11:14:36 <alsonk> BMeph: do you have any particular arch questions about Turbinado?  I'd love to hear them and any suggestions/gripes.
11:14:40 <athos> > foldr (flip (:)) "" "foobar"
11:14:41 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
11:14:41 <lambdabot>        Expect...
11:14:49 <athos> > foldl (flip (:)) "" "foobar"
11:14:51 <lambdabot>   "raboof"
11:14:51 <athos> :()
11:15:09 <BMeph> alsnk: Yea, Debian's schedule does seem to be out of sync with the GHC devel cycle.
11:15:31 <SamB_XP> BMeph: how about changing the GHC devel cycle to match ?
11:17:02 <BMeph> alsonk: Well, my main arch issue is that I'm a lazy bar steward, and would love to devel Turbinado in a Windows environment. I'm love to get my "pet" engineer to appreciate other programming environments besides Visual Basic, but that one's more of a long-term thing, I fear. ;p
11:18:12 <BMeph> SamB_XP: How about telling that to the folks in #ghc, who have a closer than fifth-degree of separation of interest? ;)
11:18:33 <BMeph> s/I'm/I'd/
11:18:33 <alsonk> BMeph: when I get Turbinado updated to 6.10, it should work again with Windows.  hs-plugins wasn't working on my Windows box.
11:18:39 <SamB_XP> but then I would have to switch to my other computer
11:18:45 <SamB_XP> or join the channel here
11:19:24 <BMeph> SamB_XP: Eh? Your IRC client won't let you into more than one chan at a time? =8*O
11:19:32 <SamB_XP> it will
11:19:39 <SamB_XP> but I haven't joined it here
11:19:42 <centrinia> Does anyone in here have a Erdos number?
11:20:09 <pumpkin> nope, but I know people who do, I guess :P
11:20:15 <SamB_XP> I don't even have a Gödel number
11:20:17 <centrinia> Same here.
11:20:20 <quicksilver> centrinia: many people I would imagine, yes.
11:20:42 <SamB_XP> but I've recently discovered how to type that in Windows, at least
11:20:48 <_ar> i have an erdos number of 3
11:20:51 <quicksilver> just about everyone who's authored a joint CS paper has an Erdos number
11:20:54 <SamB_XP> I wonder if it's possible to get third-party input methods for Windows ...
11:21:11 <dmwit> Bar steward?  Is that the hip new jive for a fatherless child?
11:21:39 <SamB_XP> what is Erdos ?
11:21:47 <vixey> a mathematician
11:21:53 <BMeph> dmwit: Exactly. ;)
11:22:00 <centrinia> Who turned coffee into theorems.
11:22:01 <_ar> Paul Erdos was a prolific mathematician
11:22:15 <dmwit> A *homeless* prolific mathematician.
11:22:20 <_ar> http://en.wikipedia.org/wiki/Paul_Erd%C5%91s
11:22:40 <_ar> who heavily used stimulants late into his life
11:22:59 <SamB_XP> so ... is a person's erdos number the number of papers you have to go through to get from them to erdos?
11:23:02 <Olidu> what editor/IDE you guys use for haskell?
11:23:10 <pumpkin> I use ed
11:23:14 <pejo> SamB, it's like the Bacon number, but papers, yeah.
11:23:15 <centrinia> SamB_XP, yes.
11:23:20 <_ar> SamB_XP, yeah... it's like 6 degress to kevin bacon
11:23:29 <Olidu> ed, no kidding?
11:23:30 <centrinia> Paul Erdos has an Erdos number of 0.
11:23:54 <SamB_XP> I declare my erdos number to be aleph
11:23:55 <dmwit> Olidu: vim/emacs
11:24:02 <_ar> I wrote a paper with Michael Khoury who wrote one with somebody who wrote one with Erdos
11:24:27 <BMeph> Olidu: I bounce around between Notepad++ and Emacs. I never got into vi(m), it's a personal prejudice of mine. :)
11:24:37 <pumpkin> Olidu: I was kidding, I use textmate
11:24:47 <dmwit> Olidu: :set ai, ts=4, sw=4, et, ft=haskell
11:25:18 <Olidu> dmwit: huh?  sorry, I'm so new, what's that?
11:25:31 <dmwit> Olidu: That's my vim setup for Haskell hacking. =)
11:26:00 <Olidu> I'm more an emacs person
11:26:15 <dmwit> ai -> autoindent, ts -> tabstop, sw -> shiftwidth, et -> expandtab, ft -> filetype
11:26:30 <dmwit> ah, k
11:26:36 <Olidu> I recently do everything in Eclipse, but that FP plugin seems to have some problems
11:26:46 <dmwit> Try yi. z-)
11:26:50 <dmwit> s/z/;/
11:27:03 <dmwit> I hate switching between dvorak and qwerty.
11:27:20 <Olidu> hmm, I downloaded yi,   should I compile it?
11:27:29 <dmwit> dunno
11:27:40 <dmwit> I hear it has nice indentation support, which basically nothing else has.
11:27:50 <cizra> dmwit: Then why do you do switch, I wonder..?
11:27:56 <chrisdone> anyone got a fast isInfixOf for ByteString?
11:28:01 <SamB_XP> dmwit: it HAS
11:28:01 <SamB_XP> ???
11:28:20 <SamB_XP> why hasn't someone figured out how to use it from emacs yet ?
11:28:32 <dmwit> cizra: My Dvorak keyboard is too bulky to travel with, and my xmodmap skills are too weak.
11:28:39 <cizra> dmwit: Want mine?
11:28:49 <dmwit> OK!
11:29:01 <SamB_XP> dmwit: you could just set up GNOME or KDE to use dvorak
11:29:16 <cizra> dmwit: Or plain old X
11:29:23 <SamB_XP> Even I do that, though I don't actually start GNOME proper
11:29:45 <skorpan> setxkbmap dvorak
11:29:48 <dmwit> hum
11:29:54 <dmwit> It failed. =/
11:30:06 <chrisdone> sudo setxkbmap dvorak # :P
11:30:13 <skorpan> no need to sudo that
11:30:21 <dmwit> skorpan: Oh, that's easy.
11:30:22 <cizra> yeah, no sudo please
11:30:28 <dmwit> skorpan++
11:30:30 <chrisdone> zoom
11:30:48 <chrisdone> hmm. a regexp library which uses bytestring should be sufficient, I guess, rather than implementing isInfixOf
11:30:51 <Olidu> Is there any interface to R?
11:31:01 <dmwit> chrisdone: The base regex library does ByteString.
11:31:20 <dmwit> Olidu: I don't know of one, though there's an interface to Matlab.
11:31:38 <chrisdone> dmwit: which is the base regex library?
11:31:42 <Olidu> any interface to Octave?
11:31:47 <dmwit> Text.Regex.Base, I think
11:31:49 <SamB_XP> well, I mean, I don't have it set to use dvorak -- but I do use gnome to set my keyboard settings
11:31:51 <dmwit> ?index =~
11:31:51 <lambdabot> bzzt
11:31:56 <dmwit> ?index (=~)
11:31:56 <lambdabot> bzzt
11:32:37 <chrisdone> ah
11:32:52 <chrisdone> oh, cool. did that come with 6.10?
11:32:59 * dmwit has it in 6.8.3
11:37:21 <orbitz> it's not in 6.6 AFAIK
11:37:41 <athos> @type handle
11:37:41 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
11:37:47 <athos> @src handle
11:37:47 <lambdabot> handle = flip catch
11:37:51 <athos> :-)
11:37:52 <chrisdone> I remember it just being Text.Regex, not this abstracted interface. good stuf
11:38:17 <orbitz> chrisdone: isn't it all super overloaded?
11:38:19 <centrinia> dmwt, where can I buy a bulky Dvorak keyboard?
11:38:29 <orbitz> =~ does liek 100 dfif things depending on its type
11:38:55 <chrisdone> orbitz: yeah, it seems so
11:39:05 <mkrauskopf> Olidu: There is nice plugin for Vim with code-completion, ability to go to documentation for element under cursor, error listing and iterating through them, ... : http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html
11:39:26 <chrisdone> orbitz: which is kind of neat
11:39:40 <orbitz> chrisdone: it certainly is...interesting :)
11:39:47 <chrisdone> hehe
11:39:51 <chrisdone> it's like the database libraries
11:40:59 <drdozer> I'm still experiencing code running in the random monad slowing down
11:41:05 <chrisdone> someone makes MyDB library. someone else makes MySuperAbstractDBLibrary with MySuperAbstractDBLibrary.MyDB, then someone makes MyMegaAbstractDBLibraryCauseThisIsReallyNeeded with MySuperAbstractDBLibrary.MyMegaAbstractDBLibraryCauseThisIsReallyNeeded
11:41:18 <chrisdone> uh, s/whatever
11:42:18 <dmwit> centrinia: The Human Touch has the best prices, I think.
11:42:27 <drdozer> anyway, the program ran well enough to convince my polish neighbour that evolution can work
11:42:37 <dmwit> centrinia: I love my Kinesis Advantage; I bought two of them.
11:43:14 <Cale> drdozer: What are you evolving?
11:43:33 <drdozer> Cale: just a variation on many monkeys typing on many typewriters
11:43:36 <dmwit> s/Touch/Solution/ maybe
11:43:42 <Cale> hehe
11:43:54 <centrinia> dmwit, thanks. :)
11:44:02 <drdozer> Cale: but each generation gets slower and slower, despite no change in population or genome size
11:44:13 <Cale> hmm
11:44:29 <Cale> I'd have a look, but I need to sleep for a bit
11:44:56 <dmwit> drdozer: Perhaps your organisms are doing better (and lasting longer).
11:45:06 * dmwit doesn't know anything about the application
11:45:27 <drdozer> dmwit: nothing that complex - each organism is just a string, there's nothing in a generation that gets bigger or smaller
11:46:02 <drdozer> but I do need to fix this performance issue before I start working on richer stochastic simulations
11:46:23 <augustss> vixey: those mustard watches are hilarious if one has ever read jean-yves writings :)
11:46:36 <drdozer> Cale: sleep is important :D can I give you the URL to the code, so that you can look at it when you are more awake?
11:46:48 <drdozer> Cale: are you facebooked?
11:47:30 <pumpkin> :o
11:47:42 <pumpkin> facebook talk in #haskell ... what is the world coming to!
11:47:58 <SamB_XP> well, there *is* a #haskell group on facebook
11:48:03 <pumpkin> really? :o
11:48:05 * pumpkin looks
11:48:10 <ushdf> don't use it
11:48:20 <ushdf> don't join it
11:48:27 <chessguy> 'ello
11:48:34 <ushdf> you'll wind up on the list of "programmers who seek to undermine democratic institutions" that chris hughes hands to obama
11:48:44 <SamB_XP> heh
11:49:09 <pumpkin> http://www.facebook.com/group.php?gid=2213713570 ?
11:49:21 <Peaker> Zao: You can know them without having COMPILATION_HOST == TARGET_HOST ?
11:50:13 <sereven> Yet Another Haskell Tut^w Logo submission -- http://haskell.org/haskellwiki/Image:Hs_logos_sereven.png
11:50:22 <chessguy> wait, is that haskell or #haskell
11:51:36 <ushdf> http://haskell.org/sitewiki/images/7/7b/Haskell.png do you guys like mine :D
11:52:07 <Peaker> ushdf: I don't understand it
11:53:23 <chessguy> heh. so haskell is related to python somehow
11:53:46 <SamB_XP> chessguy: you mean the feature python stole ?
11:53:56 <Peaker> Python is my 2nd favorite language, its related that way?
11:54:14 <chessguy> SamB_XP: i'm looking at the "related groups" on http://www.facebook.com/group.php?gid=2213713570
11:54:31 <ushdf> you don't understand it?
11:55:46 <solrize> drdozer the simplest way is with a block cipher
11:55:54 <solrize> wikipedia: [[pseudorandom permutation]]
11:58:03 <Olidu> What's the web app that http://book.realworldhaskell.org runs?　
11:58:12 <solrize> sereven your logo looks nice but i'm not sure how that graphic is related to haskell... ushdf's is cool as artwork but not really logo-like
11:58:12 <bos> Olidu: a small custom django app
11:58:35 <Olidu> bos, is it possible to get the source code?
12:00:19 <SamB_XP> argh. WHY OH WHY does citeseer garble character sets of correction data across logins ...
12:01:08 <bos> Olidu: i'll release it soonish, in my copious spare time.
12:02:03 <Olidu> bos, where can I find it after you release?
12:02:11 <bos> Olidu: i'll announce it.
12:02:33 <Olidu> announce here?  or you have a blog?
12:02:42 <bos> on my blog, most likely.
12:02:59 <Olidu> which is?
12:03:07 <solrize> http://realworldhaskell.org/blog sounds like a good place :)
12:03:08 <bos> http://www.serpentine.com/blog/
12:03:40 <Olidu> thanks
12:07:00 <solrize> who posted that girard url?  it is great, the most insane thing by him that i have read so far, and that's saying quite a lot ;)
12:07:37 <solrize> aha, vixey :)
12:09:00 <augustss> solrize: I wonder who wrote it.
12:09:22 <solrize> it looks like classic girard
12:09:47 <solrize> i've tried reading locus solum and it looks way interesting and i feel unfortunate that i can't understand much of it
12:09:47 <jdrake> @src zipWith
12:09:48 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:09:48 <lambdabot> zipWith _ _      _      = []
12:09:48 <vixey> hehe
12:10:02 <vixey> I have attempted to read locus solum twice now
12:10:24 <solrize> this stuff reminds me of situationism
12:10:41 <drdozer> thx solrise
12:10:46 <drdozer> thx solrize
12:10:59 <_ar> what's the point of the mustard watches thing?
12:11:03 <_ar> or is it a joke?
12:11:22 <vixey> _ar, it's faxlore
12:12:25 <_ar> vixey i guess i missed that era
12:13:40 <augustss> solrize: It's meant to look like classic Girard, but I'm not sure he's a man that could make fun of himself that way.
12:15:14 <chrisdone> I want my haskell program to be as fast as grep at finding lines in a file
12:15:22 <chrisdone> do you think the regexps are the bottle neck here? http://hpaste.org/13262
12:15:30 <chrisdone> or C.lines, perhaps?
12:16:08 <Asztal> how much slower is it?
12:16:38 <chrisdone> oh, my bad
12:16:48 <chrisdone> grep takes 0.008s, this takes 0.017s
12:17:24 <chrisdone> that's fine
12:18:36 <Asztal> http://cryp.to/blockio/fast-io.html is a good read, anyway... (probably)
12:18:51 <chrisdone> nice. PCRE is 0.017 on average, whereas Posix is 0.031s
12:18:56 <chrisdone> cheers Asztal
12:19:44 <porges> Does ghc allow λ -> for \ -> ? <http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource> makes no mention of it
12:20:09 <solrize> drdozer if the set you want to permute isn't a power of 2 in size, there is a cute trick (maybe due to schroeppel) where you iterate a standard block cipher until the result is in range.  i can explain that further if you want.
12:21:10 <chrisdone> Asztal: (I'm noting that such simple source code being half the speed of grep, a heavily optimised C program, is still really fucking fast)
12:21:40 <solrize> i think gnu grep uses boyer-moore search so it doesn't even examine all the input... i'm not aware of any regexp library that does that
12:22:38 * wli is not aware of that and isn't sure it can do that with its additional functionality.
12:22:39 <chrisdone> I like that I can just change the module name of the ByteString, or the Regex library, and I get a whole new implementation in the background
12:23:44 * wli ponders using stack automata or linear-bounded automata for extended regexes.
12:23:55 <porges> does importing Data.List.Stream change performance at all?
12:24:12 <augustss> Bah!  It seems hackage doesn't generate haddock docs if the package compilation fails.  Feeble!
12:25:02 <ozy`> porges: not last I checked
12:25:39 <porges> ozy`: referring to chrisdone's code (just making sure you're talking about the same thign :) )
12:26:06 <ozy`> porges: heh, missed that question. no, I meant the lambda thing
12:26:20 <solrize> that blockio paper looks like a precursor of iteratee
12:26:38 <porges> ozy`: ok :)
12:26:38 <augustss> alex doesn't handle Unicode (last I looked), so you need something before the lexer to expans Unicode symbols.  But it should be easy.
12:29:14 <porges> aha! found it: http://www.haskell.org/pipermail/haskell/2005-March/015555.html
12:29:53 <chrisdone> profmakx: I'll see
12:31:24 <chrisdone> porges: using stream fusion it's the same performance. either there's no advantage here or there's a bottleneck elsewhere
12:31:39 <chrisdone> porges: I consistently get 0.017s on my data set
12:32:03 <chrisdone> $ wc jbovlaste.xml => 18238   95952 1108447 jbovlaste.xml
12:34:07 <chrisdone> hm, for a proper regex it goes up to 0.300-400s as opposed to grep which takes 0.008. but for one single word (which is what I'm after), it's on par with grep, so I'm happy
12:35:05 <SamB_XP> is importing Data.List.Stream *supposed* to change performance ?
12:36:51 <chrisdone> dunno
12:38:13 <porges> SamB_XP: do you mean in this case or in general
12:38:17 <SamB_XP> ever
12:38:31 <porges> Data.List.Stream should give performance >= current performance
12:38:38 <porges> it is the module for stream fusion
12:40:36 <SamB_XP> uh, I'm fairly certain that the idea is to have Data.List and Prelude export functions that already have RULES for stream fusion
12:40:43 <SamB_XP> without having to import anything extra
12:41:10 <Saizan> yeah, but until that happens..
12:41:27 <SamB_XP> as of now, I don't think just importing Data.List.Stream gets you anything ?
12:41:31 <porges> currently: " To use, simply import Data.List.Stream in place of Data.List, and hide list functions from the Prelude. "
12:41:38 <SamB_XP> ah.
12:41:44 <SamB_XP> THAT will get you something, yes ;-P
12:41:51 <SamB_XP> you left that bit out
12:42:11 <porges> well I assumed that :P
12:42:35 <porges> anyway if you just import it GHC will complain that it doesn't know which functions you're using :)
12:42:41 <SamB_XP> point
12:43:10 <SamB_XP> I can't keep those modules straight though, so I thought maybe that was an internals module
12:44:31 <porges> http://www.haskell.org/pipermail/haskell/2005-March/015555.html Seems to be a lie
12:44:46 <porges> mathematical lambda doesn't work
12:46:53 <gwern> porges: why not?
12:48:48 * bos waves to matthewp
12:49:50 <matthewp> bos: Hey there!  Just watching while coding up some QuickCheck as well as HLint
12:50:53 <porges> gwern: how am I supposed to know that :S
12:51:23 <gwern> porges: well, unicode is sort of supported in files
12:51:27 <gwern> I think there's a pragma for that
12:51:58 <porges> yeah I just tried it. the other symbols work (→,⇒, etc)
12:53:00 <gwern> do any lambda symbols work?
12:53:29 <Saizan> there's not lambda symbol that currently works
12:53:31 <Saizan> *no
12:53:33 <SamB_XP> oh ?
12:53:41 <SamB_XP> suckage
12:53:43 <SamB_XP> why's that ?
12:54:00 <gwern> SamB_XP: well we obviously can't use the greek lambda
12:54:08 <gwern> but I don't see why we couldn't use the math lambda
12:54:09 <SamB_XP> well, I guess not
12:55:59 <vixey> @w80 divulgated
12:56:00 <lambdabot> No match for "divulgated".
12:56:34 <gwern> divulgate?
12:57:39 <porges> trans. To make commonly known; to publish abroad.
12:57:43 <gwern> https://secure.wikimedia.org/wiktionary/en/wiki/divulgation <-- huh. I assumed it was from 'divulge'
12:59:04 <porges> seems divulgate ~= divulge
12:59:44 <gwern> wow, wiktionary's word of the day is certainly specific
12:59:49 <gwern> 'madarotic adj 	  help, file
12:59:50 <gwern> 1. Of or pertaining to the loss of eyebrows or eyelashes.
13:00:51 <gwern> ah, wiktionary claims divulgation is derived from divulge
13:01:11 <porges> OT, but anyone know if it is possible to get xim to reload .XCompose without restarting the session
13:01:16 <gwern> thus, divulgated is redundant- it'd just be 'divulged'
13:09:44 <porges> must be sleeping hours
13:20:11 <J-roen> Hi. When using runhaskell on Windows, gcc gets stuck on the location of the temporary files (C:\Documents and Settings\...):
13:20:12 <J-roen> gcc: D:/Documents: No such file or directory
13:20:12 <J-roen> gcc: and: No such file or directory
13:20:23 <J-roen> How can I change the folder for temporary files?
13:20:32 <J-roen> (C: should be D:)
13:22:12 <J-roen> I tried to set the TMP and TEMP environment variables to C:\Temp, but it still uses D:\Documents and Settings\...
13:25:44 <gwern> reddit is teh broke?
13:26:59 <alexsuraci> gwern: seems like it
13:29:13 <blackh> J-roen: I can't offer much help (being a Linux user), but try listing your environment variables, with a command... perhaps 'set' or 'env'
13:30:06 <blackh> J-roen: One of them will give "Documents and Settings".  Try changing those till one works.  One that I do know contains this is USERPROFILE.  There must be a neat tidy solution to this problem, but I don't know what it is.
13:30:33 <blackh> He's gorn!!!!!!
13:33:54 <qebab> blackh: actually, these days I think you have to go to Control Panel -> System -> Advanced or something equally absurd to find environment vars...
13:34:21 * qebab boots up virtual machine
13:34:37 <bsod> have fun
13:34:58 <blackh> bsod: Hey, with a nick like that, you should be answering the Windows questions!
13:35:15 <bsod> i'm a haskell noob
13:35:27 <blackh> bsod: Doesn't it stand for "blue screen of death" ?
13:35:35 <bsod> yes
13:36:02 <qebab> yeah, Control Panel -> System -> Advanced -> Environment Variables
13:36:07 <qebab> I wonder why I knew this
13:36:35 <blackh> qebab: Maybe globally changing USERPROFILE isn't the answer, though. :)
13:36:58 <qebab> blackh: there are *probably* better ways to do it, but then again he could also use a sane operating system
13:37:02 <qebab> :)
13:37:29 <blackh> qebab: Sounds like a bad bug to me if ghc can't handle spaces in the path.
13:37:41 <qebab> blackh: indeed
13:37:46 <qebab> anyway, good night
13:37:51 <blackh> qebab: i.e. we have to try harder to find ways to blame Windows.
13:38:03 <bsod> cya qebab
13:38:03 <blackh> qebab: Good night!
13:38:25 * bsod &
13:49:06 <mbac> Axman6: neat. o
13:49:08 <mbac> i'll check it out
14:08:10 <yakov_> hey
14:08:45 <vixey> hi yakov
14:09:21 <yakov_> how can it be that having OpenGL+GLUT installed (this is what cabal-install tells) my cabal Setup.lhs can't find build-depends for OpenGL, GLUT? :/
14:09:34 <yakov_> I do can ghc --make that source without any trouble
14:09:58 <yakov_> i mean build-depends is OpenGL, GLUT
14:10:17 <dcoutts> yakov_: probably because you're using runghc Setup.hs configure instead of cabal configure or runghc Setup.hs configure --user
14:10:44 <dcoutts> yakov_: given that you've got the 'cabal' program there is no need to use runghc Setup
14:11:57 <yakov_> I actually use 'Setup.lhs configure' ..
14:11:59 <yakov_> aha..
14:12:21 <yakov_> thx dcoutts!
14:12:57 <dcoutts> yakov: np. The technical reason is that the default for 'runghc Setup configure'  is --global while for 'cabal' it is --user
14:13:06 <yakov_> i see
14:13:19 <dcoutts> and when doing a global install it's not safe to consider packages installed in the per-user package db.
14:13:20 <yakov_> i've somehow missed that..
14:19:20 <gwern> dcoutts: http://www.reddit.com/r/haskell/comments/7ky7v/initial_performance_numbers_for_the_new/2rob
14:19:45 <gwern> dcoutts: there are a fair number of tarballs on hackage 5mb or greater aren't there?
14:20:04 <dcoutts> gwern: not many
14:21:24 <dcoutts> gwern: someone posted patches for cabal-install to use http-4000
14:21:31 <gwern> sweet
14:21:36 <gwern> have they been applied yet?
14:21:40 <dcoutts> no
14:22:01 <dcoutts> they need some tweaking to split out unrelated changes
14:22:24 * gwern ponders. what's the angry emoticon?
14:22:35 * dcoutts wonders if http-4000 works with ghc-6.6
14:22:57 <gwern> ah, (ò.ó)
14:23:10 <Saizan> can you find the binary-strict package on http://hackage.haskell.org/packages/archive/pkg-list.html ?
14:23:24 <gwern> ironic that all the first google hits are for images of angry faces, and not an actual text emoticon
14:23:32 <ivanm> gwern: ` :@ ' is the angry emoticon I believe
14:23:55 <gwern> ivanm: dunno. looks like someone chowing down
14:24:07 <dcoutts> Saizan: nope, but the package itself is there
14:24:17 <gwern> Saizan: I don't see it
14:25:06 <gwern> 'Preprocessing library binary-strict-0.3.1...
14:25:08 <ivanm> gwern: http://en.wikipedia.org/wiki/Emoticon <-- according to wikipedia, you can also use variations of >:(
14:25:08 <gwern> src/Data/Binary/Strict/BitPut.hs:39:11: parse error on input `{-# UNPACK'
14:25:26 <gwern> hm. I was going to tell Saizan 'you can cabal-install it though', but I guess I can't :)
14:26:02 <gwern> dcoutts: but still, hackage is at least 50 megs of tarballs, and it'd be nice to cut download time by an order or so
14:26:37 <dcoutts> gwern: of course
14:26:47 <dcoutts> gwern: turns out only one package is over 5M
14:26:53 <gwern> frag?
14:26:57 <dcoutts> yep
14:27:07 <dcoutts> with hxt @ 3.9M
14:27:10 <ivanm> because of the images?
14:27:14 <dcoutts> no idea
14:27:20 <gwern> ivanm: yes
14:27:28 <gwern> those textures are big files, even compressed
14:28:52 <dcoutts> gwern: yes of course, we've been holding out using the pure-haskell HTTP lib in the hope that someone would convert it to use bytestring so this is a very good thing.
14:29:03 <dcoutts> rather than switching to a curl based lib
14:29:11 <dcoutts> which would be a massive pita on windows
14:29:25 <gwern> dcoutts: well, it was converted back in '07
14:29:33 <gwern> I'm not really sure what the hold up has been
14:29:40 <dcoutts> doing it properly I think
14:30:04 <dcoutts> for some reason people were not satisfied with the last conversion. I don't know the details.
14:30:18 <dcoutts> I'm not sure the http-4000 approach is the right one tbh
14:30:23 <dcoutts> it makes the api quite complex
14:30:25 <gwern> I never saw it discussed, so I don't know either
14:30:36 <dcoutts> I think it should have just switched String -> ByteString
14:30:46 <dcoutts> and any users who really wanted String could just unpack
14:30:56 <dcoutts> rather than the whole api being parameterised by the string type
14:31:05 <gwern> probably could've done something with Stringable
14:31:31 <gwern> honestly I find the whole string situation in haskell somewhat unsatisfactory, to say the least
14:31:37 <dcoutts> aye
14:31:46 <dcoutts> and we'll soon be adding a new string type :-)
14:31:54 <gwern> why can't we have performant UTF strings which play well with lazy evaluation FP tricks?
14:32:05 <dcoutts> we probably can
14:32:16 <Badger> @src .
14:32:16 <lambdabot> (f . g) x = f (g x)
14:32:28 <dcoutts> gwern: that'd be a lazy unicode packed string
14:32:55 <dcoutts> ie lazy bytestring but utf-X (where X = 8 or 16 depending on whichever is faster)
14:32:56 <gwern> and once we had it, we could just drop it into GHC as a String replacement. maybe via rewrite rules, dunno
14:33:04 <dcoutts> heh
14:33:06 <dcoutts> nope
14:33:06 <gwern> but the current situation is just ridiculous
14:33:21 <dcoutts> [Char] has quite different properties
14:33:38 <dons> gwern: we need String.
14:33:42 <dons> they're entirely different structures
14:33:45 <gwern> 'ok, so you have String. lazy Data.ByteString, strict ByteString, strict UTF8 bytestring...' actually, now I'm lost
14:33:56 <dons> it would be as silly as silently replacing Array with IntMap
14:33:58 <dons> or worse even
14:34:07 <dons> the world is complex.
14:34:12 <gwern> dons: I've never used the arrays so that sounds sensible to me
14:34:33 <dcoutts> gwern: there's 5, String, and then packed string with all combinations of unicode and strict/lazy
14:34:33 <gwern> dons: memory management is complex too, but when was the last time I used malloc in haskell?
14:34:45 <dons> use String then.
14:34:48 <kfish> dons: (g'morning) is there a howto guide of when to use which string?
14:35:00 <dons> if length x > 10k, use bytestrings
14:35:00 <dcoutts> kfish: it's quite simple really
14:35:04 <dons> else use String
14:35:34 <dcoutts> kfish: if you need unicode use String, remember that ByteString means what it says, it's for bytes.
14:35:47 <dcoutts> then there's the difference between lazy and strict bytestrings
14:35:50 <dons> yeah, so no japanese, unless you use a utf8 or similar encoding
14:36:03 <gwern> dons: and accept slowdowns like the 35x of http3 vs http4? am I hearing this from dons himself
14:36:23 <dons> gwern: it is not as simple as you suggest
14:36:26 <dcoutts> kfish: which is a semantic difference, one allows infinite streams the other does not. On the other hand one supports constant time indexing the other does not.
14:36:32 <dons> they are simply not equivalent types.
14:37:03 * dcoutts notes that we have not yet properly explored finger trees of chunks
14:37:15 <dcoutts> as a representation for strings of bytes or chars
14:37:53 <dcoutts> they have much nicer asymptotic bounds, but worse constant factors
14:37:58 <dons> gwern: fwiw, HTTP should always have used lazy bytestrings
14:38:06 <dons> but we didn't have them when it was written
14:38:38 <dcoutts> dons: yes, which is why I don't get why http-4000 uses all three in a slightly ad-hoc way. Why not just use lazy bytestring and let other users convert (it's just one function)
14:38:38 <dons> it is not ok though, to silently rewrite *all*  String code to bytestrings. it makes no sense.
14:38:53 <Saizan> then comes oleg
14:39:03 <Saizan> and iteratee
14:39:05 <SamB_XP> dons: why not ?
14:39:29 <dcoutts> Saizan: which is of course quite compatible with strict and lazy bytestrings, just not lazy IO
14:39:37 <dcoutts> which is of course the point
14:39:41 <gwern> dons: so ghc should never be changing types based on semantics? isn't this analogous to strictness analysis?
14:39:47 <SamB_XP> well, I mean, aside from actually being quite loud
14:40:01 <SamB_XP> 'cause of all the type errors ;-P
14:40:22 <dcoutts> gwern: doing it without changing semantics is pretty much impossible in general I think. There are some cases where it would be possible by cunning strictness analysis and transformation.
14:40:31 <sjanssen> gwern: the problem is that almost all cases of turning String -> ByteString will change semantics
14:40:32 <gwern> SamB_XP: well I have a vague idea that ghc will when you give it integers compute with ints
14:41:29 <SamB_XP> sjanssen: well, how about lazy ones then ... and not Byte*, but something Unicode-friendly
14:43:10 <sjanssen> SamB_XP: even lazy ByteStrings have much different strictness properties
14:43:29 <SamB_XP> is that bad ?
14:43:50 <sjanssen> SamB_XP: it is if it will change the semantics of your program
14:45:32 <sjanssen> take 10 $ map (\x -> if x == 10 then undefined else succ x) ['0' ..] -- not _|_ with [Char], probably _|_ with lazy ByteString
14:46:15 <SamB_XP> ... so what ?
14:46:40 <sjanssen> SamB_XP: changing successful programs into failing programs is not acceptable
14:47:24 <sjanssen> do you really want your programs to start crashing only when -O or -O2 is on?
14:48:22 <SamB_XP> I was actually thinking that "type String = [Char]" is ... er ... in need of retirement
14:49:29 <sjanssen> oh, that might actually be feasible
14:49:39 <sjanssen> of course it will break pretty much every Haskell program ever written
14:49:54 <SamB_XP> I fail to see the problem
14:50:20 <sjanssen> SamB_XP: how many programs have you written that don't use any list manipulation functions on String?
14:50:40 <SamB_XP> ... yes, but where did the problem come in ?
14:50:50 <sjanssen> concat, take, map, filter, (++), (:) (including pattern matching), all work on [a], not ByteString
14:51:26 <sjanssen> so unless you're going to change the definitions of those at the same time ...
14:51:28 <SamB_XP> we could do this at the same time as fixing the inheritance hierarchy for Monad, etc.
14:51:32 <vixey> you need lisp macros
14:51:41 <sjanssen> vixey: no
14:51:43 <vixey> turn all that [a] stuff into ByteString stuff
14:51:57 <vixey> oh no need for lisp macros when you can hack the GHC codebase? :)
14:52:14 <dons> it is an interesting task to state the conditions under which bytestring and [] Char are identical.
14:52:27 <dons> and where it would be not possible to observe which type was used.
14:52:56 <SamB_XP> I don't think an adequate replacement is available at this time, actually
14:52:59 <dcoutts> I think it can be stated as a strictness property
14:53:01 <sjanssen> SamB_XP: changing the Functor/Monad thing will break way fewer programs than String /= [Char]
14:53:06 <dcoutts> and a type property
14:53:08 <SamB_XP> it would have to support Unicode, for one ...
14:53:16 <SamB_XP> sjanssen: true
14:53:19 <dons> types, strictness, which inhabitants.
14:54:08 <SamB_XP> I think we'd want to overload ++
14:54:23 <sjanssen> SamB_XP: and dozens of other functions
14:54:28 <dcoutts> I think we'd mostly want to avoid ++ :-)
14:54:33 <SamB_XP> eh ?
14:54:39 <sjanssen> Cale wants (++) = mappend
14:54:40 <vixey> sjanssen, why not have macros?
14:54:44 <SamB_XP> sjanssen: yes
14:54:45 <SamB_XP> me too
14:54:53 <dcoutts> aye
14:54:56 <sjanssen> SamB_XP: (++) is far from the only commonly used String function
14:55:19 <dcoutts> bytestring and even lazy bytestring is not optimised for ++
14:55:44 <dcoutts> where as for text, ++ is probably the most common constructive function
14:55:55 <SamB_XP> hmm
14:56:07 <SamB_XP> it could be optimized ;-P
14:56:11 <dcoutts> so perhaps finger trees of chunks would be a good default representation
14:56:25 <dcoutts> though that does not allow for infinite lazy strings
14:56:26 <sjanssen> finger trees can't be lazy, though
14:56:29 <SamB_XP> but the "byte" bit is totally unsuitable for a String replacement
14:56:54 <dcoutts> SamB_XP: yes, obviously we want a packed unicode string type too
14:57:09 <dcoutts> which we've been calling Data.Text
14:57:18 <sjanssen> SamB_XP: it's really not hard to generalize ByteString to Storable a (StorableVector has already done it)
14:57:37 <dcoutts> SamB_XP: that's what sioraiocht did his MSc project on, a fusable Data.Text impl
14:57:40 <sjanssen> not the most efficient representation, of course
14:57:59 <dcoutts> sjanssen: and it does not allow for UTF8 or 16
14:58:17 <bos31337> dcoutts: any sign of life out of that young rtharper?
14:58:23 <sioraiocht> hi
14:58:23 <wli> Divorcing fail from Monad and mzero from MonadPlus would be nice. What's the Functor vs. Monad push for? Decoupling the two within the Prelude's class hierarchy?
14:58:30 <bos31337> sioraiocht: you live!
14:58:32 <dcoutts> sioraiocht: where is you code! :-)
14:58:36 <dcoutts> you/your
14:58:38 <sioraiocht> hiya to both =p
14:58:41 <dcoutts> :-)
14:58:47 <SamB_XP> fail and mzero, of course, belong in MonadZero
14:58:49 <sjanssen> dcoutts: not as an in-memory encoding, it is easy to translate between UTF-32 and UTF-8/16 when doing IO
14:58:49 <bos> we've got our rubber hoses ready, you know.
14:58:57 <sioraiocht> I had some family issues (mum had a brain tumour) that set me back a bit this winter ;)
14:59:04 <bos> oh my. sorry to hear that.
14:59:09 <dcoutts> sioraiocht: oh, sorry to hear that
14:59:10 <sioraiocht> she's alright, now
14:59:13 <SamB_XP> sjanssen: I'm not sure if UTF-32 is the best in-memory encoding to use
14:59:21 <sioraiocht> but the surgery, etc was quite a big deal, left the UK for a while, etc
14:59:26 <dcoutts> sioraiocht: right
14:59:36 <sioraiocht> also, get absurdly
14:59:40 <sioraiocht> *got absurdly
14:59:41 <sioraiocht> set back
14:59:42 <sjanssen> dcoutts: I'm not saying UTF-32 is the best in-memory encoding, just saying that "Unicode ByteString" is easy, at a first approximation
14:59:54 <SamB_XP> oh, sure
14:59:56 <dcoutts> sjanssen: yes, the api is not that hard.
15:00:00 <sioraiocht> post new year, mid Jan, I want to deliver the code, though ;)
15:00:04 <ehird> >fix show
15:00:09 <ehird> > fix show
15:00:10 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
15:00:14 <ehird> > fix error
15:00:16 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
15:00:16 <dcoutts> sioraiocht: can we help? is there a darcs repo?
15:00:23 <sioraiocht> not a public one
15:00:25 <ehird> > fix fix
15:00:26 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
15:00:26 <lambdabot>      Proba...
15:00:36 <sioraiocht> and am leaving the internext tomorrow for 2 weeks, when I get back i'll put one up
15:00:37 <dcoutts> sioraiocht: you don't need to have a finished product before you can open the code
15:00:46 <sjanssen> dcoutts: implementation is also easy, if you're willing to use UTF-32
15:00:54 <sioraiocht> dcoutts: indeed, I won't wait, when I get back on 7 Jan i'll open up the code
15:01:00 <bos> we'd really be happy to have the code early
15:01:06 <dcoutts> sioraiocht: we'll not be banging on your door to fix things, we just want something to start hacking on
15:01:15 <sioraiocht> alright ;)
15:01:43 <dcoutts> sioraiocht: if you get us a tarball we'll make a darcs repo on code.haskell.org and add you me and bos as project members
15:01:49 <dcoutts> sioraiocht: or any other suggestion you might have
15:01:49 <sioraiocht> okay
15:01:57 <wli> Depends on if the more complex encodings' CPU/etc. overheads are worse for you than the space/cache overhead.
15:02:03 <sioraiocht> that's a lot easier than setting up a hosting solution myself
15:02:12 <SamB_XP> tarball of the darcs repo, of course
15:02:23 <dcoutts> sioraiocht: code.h.o is a good place for something we expect to become a core library
15:02:38 <sjanssen> wli: most of the Unicode experts claim that UTF-16 is the best, but I don't think it has been empirically tested
15:02:45 <sioraiocht> sjanssen: I have tested it
15:02:50 <sioraiocht> it depends on what "best" means
15:02:57 <SamB_XP> well, duh
15:02:59 <sjanssen> sioraiocht: naturally :)
15:03:02 <dcoutts> and it depends on the language you're using
15:03:06 <sioraiocht> but it is the most balanced wrt to a general solution
15:03:18 <dcoutts> I mean the programming language
15:03:31 <sjanssen> dcoutts: oh, why is that?
15:03:41 <dcoutts> sjanssen: eg in C the cost of all those conditionals inherent in UTF8 is less bad
15:03:54 <dcoutts> sjanssen: we do not have so much control over branch prediction, so that stuff hurts us
15:04:08 <sjanssen> dcoutts: mmm
15:04:08 <sioraiocht> sjanssen: conditionals are most of the work, and UTF-8 has twice as many as UTF-16 ;)
15:04:10 <dcoutts> in theory with good enough ghc code gen there would be no difference
15:04:13 <wli> How do you find the n-th character/glyph/whatever with a variable-length encoding?
15:04:19 <SamB_XP> most C programs do not have branch prediction control ...
15:04:26 <dcoutts> wli: you typically do not bother :-)
15:04:27 <sjanssen> UTF-8 is also important for backwards compatibility in C
15:04:31 <sioraiocht> wli: linear at worst, sublinearly at best
15:04:41 <solrize> i think python and java use utf-16 because they were designed at a time when unicode itself was supposed to be a 16 bit character set
15:04:48 <lispy> wli: usually you store it internally in a per-glyph encoding
15:04:52 <sjanssen> wli: do real programs actually use string indexing? (especially in Haskell)
15:05:11 <SamB_XP> solrize: I thought Python basically only did that on Windows
15:05:16 <SamB_XP> because that's what Windows does
15:05:18 <sioraiocht> wli: the most significant bits of a UTF word tell if how many of the following words are part of the same character
15:05:21 <sjanssen> solrize: yes, and Java even exposes that fact by having weird "half characters"
15:05:28 <lispy> wli: But, I like your question because Java is UTF-16 for its char type
15:05:28 <sioraiocht> s/if/you/
15:05:43 <dcoutts> sioraiocht: that's still linear, it's just a good constant factor like 1/2 :-)
15:05:48 <sioraiocht> dcoutts: uh, right
15:05:50 <sioraiocht> whatever
15:05:52 <sioraiocht> =p
15:05:56 <dcoutts> ;-)
15:06:29 <dcoutts> lispy: at least Haskell gets that correct, Char is a genuine unicode code point
15:06:42 <solrize> probably almost all unicode data is in bmp-16 (the first 16 bit plane) but any that use a lot of non-bmp characters will lose horribly
15:07:08 <dcoutts> solrize: any that use *any* non-bmp chars will loose horribly
15:07:09 <solrize> samb_xp i think there is some way to compile python to use real unicode but i dunno that anyone uses it, even in linux
15:07:28 <solrize> dcoutts, in java yes, in python i'm not sure what happens
15:08:00 <solrize> there is also a weird java "modified utf-8" which is specified to handle non-bmp chars, so i'm not sure what happens if you actually use them
15:08:10 <dcoutts> sioraiocht: btw, did you use darcs or git or anything during development of your code?
15:08:11 <lispy> dcoutts: Well, using 3-4 bytes per char might be too expensive though :)
15:08:14 <sjanssen> I wonder if an implementation that uses UCS-2 by default but automatically switches to UCS-4 when non-BMP characters are used would be efficient
15:08:22 <sioraiocht> dcoutts: git
15:08:34 <solrize> sjanssen i'd be satisfied with some kind of pragma that selected
15:08:46 * dcoutts wonders if there's a git->darcs tool that preserves history
15:09:00 <Zao> sjanssen: Or just use UTF-16, as it's largely that.
15:09:01 <sjanssen> dcoutts: I think tailor can do that
15:09:10 <dcoutts> sjanssen: people often wonder that. My intuition is that there is no real advantage.
15:09:17 <dcoutts> sjanssen: oh, good.
15:09:20 <lispy> dcoutts: yeah, tailor
15:09:29 <sjanssen> Zao: I'm specifically addressing the casses where they're different :)
15:09:30 <SamB> nm --dynamic /usr/lib/libpython*.so | grep UCS
15:09:57 <sjanssen> Zao: with an adaptable scheme like that, you can always have constant indexing
15:09:57 <solrize> samb i dunno that you'd find it that way
15:10:07 <dcoutts> sjanssen: given that random indexing is irrelevant I don't see any advantage of using UCS-2 + UCS-4 over UTF16
15:10:25 <blackh> How about an implementation that can use several internal encodings, but has a default one, which can be set globally? This would minimize unnecessary conversions.  And we don't want to have to re-compile the whole system to use Chinese!
15:10:33 <solrize> ucs-2 is different from utf16 how?
15:10:34 <sjanssen> SamB: UCS is deprecated, as it only supports part of the Unicode range
15:10:52 <Zao> sjanssen: type Codepoint = UTF16_Unit | UTF32_Unit ?
15:11:05 <dcoutts> solrize: it only supports the first 16bits of the unicode chars
15:11:14 <blackh> I can see a problem with standardizing on UTF16 that 32-bit characters will not get tested properly.
15:11:19 <sjanssen> Zao: no, data Chunk = UCS4 BunchaBytes | UCS2 BunchaBytes
15:11:26 <solrize> http://docs.python.org/c-api/unicode.html
15:11:29 <Zao> UCS-2 doesn't do surrogates, and can thus not encode planes 1-16.
15:11:31 <dcoutts> blackh: that's what a testsuite is for :-)
15:11:36 <sjanssen> dcoutts: you would be able to avoid branches in inner loops
15:11:42 <solrize> Python’s default builds use a 16-bit type for Py_UNICODE and store Unicode values internally as UCS2. It is also possible to build a UCS4 version of Python (most recent Linux distributions come with UCS4 builds of Python). These builds then use a 32-bit type for Py_UNICODE and store Unicode data internally as UCS4.
15:11:49 <bos> this thing will be tested like crazy.
15:11:52 <solrize> Note that UCS2 and UCS4 Python builds are not binary compatible. Please keep this in mind when writing extensions or interfaces.
15:11:55 <dcoutts> sjanssen: which are supposed to be free if predicted correctly
15:12:04 <sjanssen> dcoutts: eg. map f (Ucs4 bs) = mapUCS4 f bs; map f (UCS2 bs) = mapUSC2 f bs
15:12:08 <sjanssen> dcoutts: hmm, true
15:12:22 <dcoutts> blackh: it's totally hidden by the Text API, so you do not need to do anything special to support chars outside the BMP
15:12:27 <wli> dcoutts: Not everything that seeks wants byte offsets. Boyer-Moore?
15:13:06 <blackh> dcoutts: That's the important thing - to make the API so it's impossible to make 16-bit assumptions.
15:13:22 <dcoutts> wli: ok, for Boyer-Moore we're typically indexing into the search word right? not into the search text. So we can use a Char array.
15:13:36 <sjanssen> wli: you can actually use the standard Boyer-Moore algorithm on strings of bytes rather than strings of Char
15:13:48 <blackh> dcoutts: I'm doing an internationalized web site in Haskell and we will be using Chinese.
15:13:51 <dcoutts> blackh: the Text api is at the level of a sequence of Char, so encoding issues are not visible.
15:14:02 <solrize> if you're using boyer-moore at all you've probably lost horribly if you've expanded the original input into a char array
15:14:03 <dcoutts> blackh: there are conversions to/from ByteString in UTF8, 16 etc
15:14:40 <sjanssen> wli: or, in the case of UTF-16, strings of Word16
15:15:00 <blackh> dcoutts: I missed the beginning of this conversation. What's the name of this project?
15:15:46 <dcoutts> blackh: For ages we've agreed we need a fast unicode string type. sioraiocht did an implementation for his MSc project and we now want to develop that into a standard lib.
15:16:04 <dcoutts> blackh: we tentatively called the type Text and the module Data.Text
15:16:31 <SamB_XP> sjanssen: well, the symbols include UCS2 in python23.dll ...
15:16:33 <blackh> dcoutts: Thanks. I'll keep any eye on it and if I can find any time I might try to help.  I can be an early adopter, at any rate. :)
15:16:40 <dcoutts> blackh: it provides list-like operations on a sequence of unicode code points and does not expose the internal encoding.
15:17:04 <dcoutts> though it provides conversion functions to/from standard unicode encodings as byte strings
15:17:30 <wli> sjanssen/dcoutts: Not a good example. Maybe crossword puzzles.
15:17:38 <blackh> dcoutts: Have you got a nice 'ShowS'-type interface for banging out large amounts of html quickly?
15:17:52 <dcoutts> wli: fine, use an array
15:18:26 <blackh> dcoutts: Maybe I'll do some XML stuff on top of your project or something, because that's one of the things I'll need.
15:18:42 <dcoutts> blackh: not yet, there are a few possibilities there, either a string buffer (like the Binary Builder type) or we could use a finger tree of chunks
15:20:01 <bos> Does Builder work lazily? I don't remember.
15:20:20 <bos> ISTR it's a difference list.
15:20:26 <dcoutts> bos: yes, both
15:20:37 <blackh> dcoutts: Maybe I can help in some way.
15:20:51 <dcoutts> blackh: having some good performance use cases would be handy
15:21:16 <sjanssen> dcoutts: does GHC HQ have a plan for branch prediction?  A {-# LIKELY #-} pragma would be frickin sweet
15:21:35 <blackh> dcoutts: That would be a good way for me to help. I'll make some out of my web application.
15:21:37 <dcoutts> sjanssen: not yet, I've asked for such things before but it depends on progress in the code gen
15:22:10 <SamB_XP> where exactly would the pragma belong ?
15:22:18 <dcoutts> sjanssen: also threading such hints all the way through the AST, core is a bit of work
15:22:23 <blackh> dcoutts: The only problem is, I've only got English at the moment.  We'll come back to that.
15:22:29 <dcoutts> SamB_XP: on case branches probably
15:23:10 <SamB_XP> or after the equals sign in a function definition case ?
15:23:26 <dcoutts> I'd be happy with just case
15:23:31 <dcoutts> it's only rarely needed
15:24:14 <sjanssen> SamB_XP: it probably makes more sense to put it before the = or ->
15:24:27 <SamB_XP> hmm ?
15:24:38 <sjanssen> it's more of an annotation on the pattern than the expression
15:24:45 <SamB_XP> hmm, true
15:24:59 <SamB_XP> before or after the | ?
15:25:06 <SamB_XP> (both ?)
15:25:19 <sjanssen> either, probably
15:25:33 <sjanssen> since a pattern with | is actually two conditionals (or more
15:56:21 <rtjd> q
15:56:35 <BMeph> r
16:13:33 <chessguy> zzzzz
16:15:14 <Peaker> > replicate 5 'z'
16:15:15 <lambdabot>   "zzzzz"
16:15:45 <dons> ghc 6.10 on the shootout, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
16:15:53 <dons> climbed ahead of gcc by switching to 6.10 from 6.8.2
16:15:56 <dons> JaffaCake: well done.
16:16:07 <dons> and that's all with only a few entries parallelised.
16:16:13 <ivanm> dons: did all the haskell progs work without fixing?
16:16:16 <dons> a concerted effort now would help cement things i think
16:16:26 <dons> ivanm: yep
16:16:31 <chessguy> oh, for a second there i thought you said "from 6.10 to 6.8.2"
16:19:13 <idnar> now to defeat java
16:19:24 <ivanm> you mean Java is beating us? :o
16:19:49 <athos> :t replicate
16:19:50 <lambdabot> forall a. Int -> a -> [a]
16:19:51 <gwern> like a red-headed stepchild?
16:20:06 <idnar> ivanm: that's what the page says :P
16:20:13 <mwotton> unpossible. a garbage collected language running faster than C? rhubarb rhubarb rhubarb...
16:20:16 <ivanm> yeah, I just went and looked at it for myself :s
16:20:24 <ivanm> mwotton: it's the server version
16:20:31 <idnar> what the heck is java -Xint?
16:21:02 <Zao> idnar: "Operate in interpreted mode only"
16:21:05 <mwotton> ivanm: is it particularly different?
16:21:08 <idnar> sounds painful
16:21:12 <gwern> hm, regex-dna is still broken
16:21:22 <ivanm> mwotton: faster, less of a startup lag AFAIK
16:21:44 <Zao> http://java.sun.com/javase/6/docs/technotes/tools/windows/java.html
16:21:51 <Zao> See the "non-standard options" bit.
16:22:39 * rgr pasted "how to get xmproc into the config?" at http://paste2.org/p/119747
16:23:09 <rgr> could someone take a look at my xmonad.hs and explain how I get xmproc to work inside myConfig please?
16:23:32 <rgr> (same for gpproc and dynHooksref)
16:23:50 <ivanm> rgr: maybe #xmonad would be a better channel? ;-)
16:24:04 <gwern> ouch. on knucleotide c++ is 10x faster and 66x less memory? what are we doing wrong there?
16:24:12 <rgr> is xmonad.hs not haskell?
16:24:22 <rgr> I tried there but couldnt really get an explanation i could follow.
16:24:26 <gwern> it is, but #xmonad is sort of intended ofr that
16:24:57 <ivanm> rgr: xmonad has special commands, etc.
16:25:22 <rgr> its ok, I spent enough time on it. Think I'll just revert to what works,
16:27:29 <gwern> k-nucleotide is #10... yes, that's hurting the rank alright
16:31:04 <dons> yeah, needs fixing.
16:31:18 <dons> you can tell by removing it from the rankings to see what effect it has
16:31:27 <dons> also, we've an easy parallel solution to regex-dan
16:33:04 <ivanm> regex-dan? is he some guy who's really good at regexes?
16:33:07 <ivanm> ;-)
16:33:21 <dons> yeah. he rocks
16:35:27 <opqdonut> :D
16:48:42 <athos> good night guys
16:54:13 <TML> Is this an appropriate place to discuss issues with Cabal-1.6.0.1?
16:54:18 <dons> yes
16:54:58 <TML> On debian testing, I had to manually fetch 'network' in order to get it to install. Is this a flaw in the debian packaging, or in bootstrap.sh?
16:55:50 <RayNbow`> dons: is there an errata wiki/page for RWH?
16:56:12 <cjb> dons: speaking of which, what's with not indenting C blocks inside for/while loops?  :)
16:56:18 <dons> RayNbow`: yes, vi athe oreilly page
16:56:26 <TML> When setting up "HTTP-3001.1.3", it would die with "Setup: At least the following dependencies are missing: network -any"
16:56:48 <dons> you're missing the network library
16:57:36 <TML> dons: Right - and I was able to figure that out and get it installed, I'm just wondering if that's a bug in the bootstrap.sh that comes with Cabal 1.6.0.1, or if that's something the Debian packager forgot to include.
16:57:36 <RayNbow`> dons: ah, found it... :)
16:57:45 <int-e> network is an extra lib, hmm
16:57:47 <dons> cjb: ?
16:57:49 <TML> Just wondering where to file the bug
16:58:04 <RayNbow`> dons: should errata also be posted there if someone else has commented on it on the RWH site?
16:58:11 <dons> cjb: no idea what you're talking about, sorry.
16:58:20 <dons> RayNbow`: the site is for comments prior to Nov or so.
16:58:22 <dcoutts> TML: there's no bug as such, you just need to install the ghc network package that is provided by debian
16:58:50 <Liskni_si> TML: I guess the most appropriate action would be to file a bug requesting cabal to be packaged ;)
16:58:51 <cjb> dons: np, will find example
16:58:53 <dcoutts> TML: the cabal-install bootstrap.sh assumes it is already installed. Perhaps it should not, but it also should not install it itself since it's more of a system package.
16:58:54 <TML> dcoutts: A fair answer :)
16:59:21 <dcoutts> TML: yes as Liskni_si says, debian should package cabal-install
16:59:27 <dcoutts> that's the real bug
16:59:38 <cjb> dons: pages 87/88, the C loop examples
16:59:47 <int-e> TML: network is sort-of-bundled with ghc: it's in its extra libraries tarball. I guess bootstrap.sh was written with the assumption that those are installed.
17:00:08 <cjb> dons: let me know if I should file it at the ORA site, happy to do that.  thought it might have been someone's preference.
17:00:23 <int-e> (dcoutts will tell me if I'm wrong ;) )
17:01:01 <dcoutts> int-e: aye, we've got a funny situation where we have a standard set of packages but no distro meta-package. That's what the platform will provide.
17:01:11 <Liskni_si> cjb: seems like a tabstop width issue
17:01:26 <cjb> also pages 85, 91; probably anywhere there's C code.
17:02:12 <cjb> Liskni_si: I don't see how
17:02:16 <dons> cjb: i doubt it. might be a typo. checking my copy
17:02:35 <cjb> Liskni_si: see page 88, for example.  the further tab stop clearly exists, because it's used for the for loop
17:02:40 <cjb> but the if statement the for loop is inside is unindented
17:02:50 <dons> oh interesting.looks like an "indent-o"
17:03:02 <cjb> dons: yeah; seems to be in every example, though, odd.
17:03:08 <Liskni_si> cjb: stuff that should be indented by 8 spaces is indented by 4, 12 becomes 8, 4 stays 4
17:03:27 <int-e> Liskni_si: so a tab size mismatch :(
17:03:28 <Liskni_si> that's clearly what a tabstop width of 4 would do
17:03:42 <Liskni_si> yeah
17:03:57 <Liskni_si> i wouldn't know this if i hadn't read it in the book :)
17:04:05 <Liskni_si> they say tab is 4 on windows
17:04:06 <cjb> oh, neat, okay
17:04:14 <dons> Cale: any idea what this guy is on about? http://twitter.com/KCorax/status/1072741563
17:04:44 <opqdonut> wat :D
17:05:03 <int-e> dons: sounds like using lists as arrays
17:05:17 <strht> how do i capture an input stream inside of a loop
17:05:19 <strht> any experts?
17:05:37 <dons> int-e: oh, so he's confusing lists with lazy eval?
17:05:54 <jeffwheeler> In Ch. 12 of RWH (http://book.realworldhaskell.org/read/barcode-recognition.html), there's a warning "Beware the partial functions!"
17:05:57 <blackh> strht: What sort of input stream and what sort of loop?
17:05:57 <roconnor> strht: say again?
17:06:15 <jeffwheeler> What do partial functions have to do with that? Isn't it just a function that can return an error?
17:06:17 <strht> the keyboard and mo.use input stream
17:06:29 <strht> and the sort of loop that checks to see what's changed inside of those streams
17:06:44 <strht> or what's depressed or whatnot
17:06:57 <int-e> dons: Well, I think he must be confusing lazy evaluation with something. It just makes no sense as stated. Lists are just a guess.
17:07:09 <roconnor> strht: what package are you using for this keyboard and mouse stream?
17:07:17 <strht> i don't know, what packages are there?
17:07:38 <strht> i am rummaging through hackage
17:07:41 <roconnor> Fran, Yampa, Gagets ...
17:07:52 <Nyax> How do I go about using "let" expressions where I can reuse variables.
17:07:54 <strht> fran i think
17:07:58 <strht> is what i want
17:08:04 <strht> i remember it mentioned in this context
17:08:10 <dons> int-e: i think you might be right re. lists.
17:08:11 <jeffwheeler> @src Data.Map.insertWith'
17:08:12 <lambdabot> Source not found.
17:08:25 <Nyax> let {x=5;y=10-x}, for instance
17:08:26 * roconnor leaves this question for the fran experts
17:08:51 <jeffwheeler> Nyax: what's wrong with that?
17:09:01 <Nyax> It doesn't work.
17:09:19 <jeffwheeler> > let {x=5;y=10-x} in y
17:09:20 <lambdabot>   5
17:09:22 <Nyax> Hrm.
17:09:27 <Nyax> I may be dumb.
17:09:56 <strht> ah, reactive and fieldtrip
17:09:59 * jeffwheeler thinks insertWith' could be brilliantly useful.
17:10:04 <EvilTerran> > let x = [] in let x = 1 : x in x -- this may not behave as expected
17:10:05 <mgsloan1> hrmm:
17:10:05 <mgsloan1> cabal: cannot configure hxt-8.2.0. It requires base >=4
17:10:05 <mgsloan1> There is no available version of base that satisfies >=4
17:10:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:10:20 <EvilTerran> > let x = [] in let y = 1 : x in y -- ie, differently to this
17:10:21 <lambdabot>   [1]
17:10:28 <pejo> mgsloan1, using ghc 6.10?
17:10:47 <strht> evilterran: ?
17:10:50 <Nyax> Is there any way to define a function that can take an arbitrary number of arguments?
17:10:57 <strht> oh nevermind
17:11:00 <strht> didn't see the --
17:11:01 <mgsloan1> pejo: 6.8.2
17:11:04 <int-e> > let nats = 0 : [nats !! (n-1) + 1 | n <- [1..]] in nats -- dons, perhaps with a context like this in mind
17:11:04 <Nyax> For instance, max(1,2,3) or max(1,2,3,4)
17:11:05 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:11:07 <dibblego> @where polyvariadic
17:11:08 <lambdabot> I know nothing about polyvariadic.
17:11:15 <jeffwheeler> Nyax: no.
17:11:16 <Saizan> mgsloan1: try installing an earlier version of hxt, you can see the ones available on the hackage page
17:11:19 <dcoutts> mgsloan1: use an older version of hxt, eg try cabal install --dry-run 'hxt < 8.2' and keep lowering the version til you find one that works.
17:11:26 <mgsloan1> ah alright thanks :)
17:11:28 <strht> > let blah g = g: succ g
17:11:29 <lambdabot>   <no location info>: parse error on input `;'
17:11:29 <dibblego> Nyax, yes look up polyvariadic functions
17:11:34 <Nyax> Okay.
17:11:46 <jeffwheeler> Nyax: you an accept lists and such; it makes no sense with currying and the way function application works to have variable-length arguments.
17:11:47 <dcoutts> mgsloan1: hopefully I'll make the next cabal-install release do that automagically.
17:12:06 <mgsloan1> dcoutts - ooh, that'd be awesome
17:12:07 <dibblego> Nyax, http://okmij.org/ftp/Haskell/types.html#polyvar-fn
17:12:15 <mgsloan1> cabal install is awesome, btw, usually flawless
17:12:19 <dibblego> @where+ polyvariadic http://okmij.org/ftp/Haskell/types.html#polyvar-fn
17:12:19 <lambdabot> Done.
17:12:41 <jeffwheeler> Okay, well, not in your day-to-day code; be weary of using this regularly.
17:12:54 <solrize> :t printf
17:12:56 <lambdabot> forall r. (PrintfType r) => String -> r
17:12:57 <dcoutts> mgsloan1: that's good to hear. I usually only hear about the problems :-)
17:13:32 <strht> oh, of course
17:13:33 <strht> @let hhm g = g : hhm (succ g)
17:13:34 <lambdabot>  <local>:1:0:
17:13:34 <lambdabot>      Warning: Pattern match(es) are overlapped
17:13:34 <lambdabot>               In...
17:13:38 <strht> @undefine
17:13:39 <strht> @let hhm g = g : hhm (succ g)
17:13:40 <lambdabot>  Defined.
17:13:43 <strht> > hhm 320962
17:13:44 <lambdabot>   [320962,320963,320964,320965,320966,320967,320968,320969,320970,320971,3209...
17:15:14 <strht> hmm...
17:15:35 <augustss> > hhm LT
17:15:36 <lambdabot>   [LT,EQ,GT,* Exception: Prelude.Enum.Ordering.succ: bad argument
17:15:37 <strht> > zip (hhm 320962) (map sqrt (hhm 320962))
17:15:38 <lambdabot>   [(320962,566.535082761871),(320963,566.5359653190608),(320964,566.536847874...
17:16:17 <augustss> strht: what's wrong with [320962..]?
17:16:26 <strht> oh yeah, i forgot about that
17:17:17 <strht> @let hmm h = [h,sqrt(h)..]
17:17:18 <lambdabot>  Defined.
17:17:21 <strht> > hmm 3
17:17:23 <lambdabot>   [3.0,1.7320508075688772,0.4641016151377544,-0.8038475772933684,-2.071796769...
17:17:30 <strht> > hmm 0.5
17:17:32 <lambdabot>   [0.5,0.7071067811865476,0.9142135623730951,1.1213203435596428,1.32842712474...
17:17:38 <strht> nifty!
17:18:03 <int-e> > iterate sqrt 0.5
17:18:04 <lambdabot>   [0.5,0.7071067811865476,0.8408964152537146,0.9170040432046712,0.95760328069...
17:18:05 <EvilTerran> > iterate sqrt 3 -- this is something else
17:18:06 <lambdabot>   [3.0,1.7320508075688772,1.3160740129524924,1.147202690439877,1.071075483072...
17:18:22 <Peaker> > throwError "error!" :: Either String a
17:18:23 <lambdabot>   Left "error!"
17:18:31 <strht> > hmm (foldr (+) 1 (hhm 3))
17:18:33 <lambdabot>   [* Exception: stack overflow
17:18:41 <strht> > hmm (foldr (+) 1 (take 20 (hhm 3)))
17:18:43 <lambdabot>   [251.0,15.842979517754856,-219.3140409644903,-454.47106144673546,-689.62808...
17:19:09 <strht> hmph
17:20:19 <strht> back to the tutorials
17:26:59 <augustss> > iterate cos 1
17:27:00 <lambdabot>   [1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.79348035874...
17:27:17 <Heffalump> > drop 20 $ iterate cos 1
17:27:18 <lambdabot>   [0.7391843997714936,0.7390182624274122,0.7391301765296711,0.739054790746917...
17:27:32 <luite_> is there a way to reset haskell-mode (in emacs)? When ghci segfaults and I try to reload the file, it restarts ghci, but it starts in the wrong directory and always hangs when I try to load the file after manually changing the dir
17:28:36 <luite_> it's kind of annoying having to restart emacs all the time :)
17:32:10 <ivanm> luite_: kill the ghci buffer, then create it again
17:32:33 <ivanm> (you might want to do a "pkill ghc" whilst you're at it)
17:33:29 <luite_> ivanm: ah that works, thanks
17:34:04 <luite_> now I just need to find this segfault bug :)
17:34:12 <ivanm> heh
17:35:40 <luite_> should copyMU be safe when the array you're copying from is longer than the space in the target array?
17:35:45 <porges> :/
17:35:51 <porges> any plans for hpaste to support unicode
17:35:57 <porges> <http://hpaste.org/13268>
17:38:10 <CakeProphet> where/what is Haskell's reduce function (like in Python)
17:38:30 <Zao> CakeProphet: foldl/foldr?
17:39:55 <CakeProphet> ah
17:41:01 <CakeProphet> so then
17:41:01 <CakeProphet> foldr (++) listofStrings
17:41:01 <CakeProphet> would join a list of strings?
17:41:12 <lispy> :t intercalate
17:41:13 <lambdabot> forall a. [a] -> [[a]] -> [a]
17:41:17 <lispy> CakeProphet: ^^
17:41:26 <mgsloan1> :src intercalate
17:41:34 <mgsloan1> ?src intercalate
17:41:34 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
17:41:41 <CakeProphet> ah, got it. nevermind
17:41:43 <mgsloan1> ?src concat
17:41:43 <lambdabot> concat = foldr (++) []
17:41:45 <mgsloan1> :)
17:42:32 <porges> CakeProphet: you have to provider the initializer. if you want it exactly like python's reduce use fold(r/l)1
17:42:42 <CakeProphet> ah
17:42:51 <porges> so your example would be foldr1 (++) listOfStrings
17:43:02 <porges> but this will fail if the list is empty :)
17:43:05 <CakeProphet> apparently other people have needed this function and decided to give it a name.
17:44:43 <lispy> > intercalate " " ["I", "like", "pizza"]
17:44:44 <lambdabot>   "I like pizza"
17:44:59 <lispy> > unwords ["I", "like", "pizza"]
17:45:01 <lambdabot>   "I like pizza"
17:47:57 <CakeProphet> I have a feeling once I get my first Haskell programming working this will become much simpler
17:48:43 <lispy> CakeProphet: I recommend learning to use lambdabot, she makes haskell programming a lot easier
17:49:00 <lispy> CakeProphet: she can lookup functions for you by type, help you refactor and all kinds of neat things
17:49:44 <CakeProphet> I'm still trying to interpret the type errors.
17:49:44 <CakeProphet> ...got it.
17:49:44 <CakeProphet> but it breaks if I change the module to something other than Main
17:50:23 <lispy> CakeProphet: I forget the details, but I think only Main.hs is allowed to define main :: IO ()
17:51:00 <luite_> ah, apparently copyMU doesn't use any range/bounds testing at all
17:51:55 <orbitz> how come main isn't main :: IO Int?
17:52:11 <Zao> orbitz: You have exitWith for that.
17:52:29 <Zao> lispy: --main-is?
17:52:38 <orbitz> is exitWith like return or does it pull out of te program anywhre?
17:52:46 <SamB_XP> it isn't actually required to be :: IO ()
17:52:49 <SamB_XP> orbitz: anywhere!
17:52:55 <orbitz> IEEEE!!
17:53:15 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html#v:exitWith
17:53:17 <SamB_XP> no, it doesn't have anything to do with floating point arithmatic
17:53:21 <gwern> well if you just want to return a value just return the value
17:53:47 <porges> lambdabot isn't building via cabal :/
17:54:13 <gwern> porges: how so
17:54:30 <CakeProphet> http://hpaste.org/13269
17:54:30 <CakeProphet> so why does this break if I change the module name
17:54:35 <porges> Plugin/Eval.hs references stuff not imported
17:54:35 <CakeProphet> lispy:  so is there another way to have my program spit out a bunch of hearts without being called "Main"?
17:54:53 <orbitz> man, why does national geographic channel have a show calel d"UFOs: Seeing is beleiving" wtf
17:55:46 <orbitz> isn't that how haskell knows it is the moduel with the main method?
17:56:04 <porges> CakeProphet: works when mine isn't "Main"
17:56:32 <porges> did you put a lowercase name or something?
17:57:07 <gwern> isn't there a --main-is option one could use?
17:58:02 <orbitz> well i guess we should have asked "how does it break?"
17:58:03 <CakeProphet> Failed to load interface for `Main':
17:58:31 <orbitz> how did you compile it?
17:58:42 <CakeProphet> no.
17:58:42 <CakeProphet> that's the message I get
17:58:52 <orbitz> from doing what?
17:59:18 <CakeProphet> I'm just using runhaskell
17:59:49 <orbitz> did you using --main-is to tell it your new module is the main module?
18:00:32 <porges> I changed it to "module Ain where..."
18:00:36 <porges> runhaskell still works
18:01:03 <orbitz> porges: does the file have to be named a.hs?
18:01:18 <porges> file is test2q1asdz.hs
18:01:20 <porges> :P
18:01:35 <orbitz> porges: are you using runhaskell?
18:01:46 <porges> yeah
18:01:55 <orbitz> porges: then i'm all out of ideas! crap
18:02:29 <porges> CakeProphet: what exactly did you change in the file?
18:02:49 <porges> between <http://hpaste.org/13269> and your non-working version
18:03:06 <rwbarton> CakeProphet: If you have a module declaration, it has to match the file name, I think
18:04:24 <orbitz> did we lose him?
18:04:26 <rwbarton> CakeProphet: If you just want to run a short, single-file program, then you can skip the module declaration, and name the file anything that ends in .hs
18:05:19 <CakeProphet> with GHC
18:05:19 <CakeProphet> it says to run with -v to see the files being searched for.
18:05:19 <CakeProphet> I'll paste the result of that
18:05:19 <CakeProphet> http://hpaste.org/13270
18:06:12 <pumpkin> can map-reduce be thought of as a hylomorphism?
18:06:16 <pumpkin> or is that stretching it?
18:06:47 <tehgeekmeister> trying to shorten up some of those insanely long lines some of you balked at: what's the rule for indenting a case statement?
18:07:06 <porges> orbiz, rwbarton: either of you have 6.8.2 installed? maybe it's a difference between that and 6.10
18:07:37 <rwbarton> I'm running 6.8.2; but also my comments are just from memory
18:08:03 <rwbarton> But I'm not surprised at http://hpaste.org/13270; if you use module declarations, main needs to be in the Main module, unless you use --main-is
18:08:07 <orbitz> i'm running 6.10
18:08:45 <int-e> rwbarton: the file name doesn't have to match the module name. however, if they don't match, ghci, ghc -make and the like won't automatically find the module when it's indirectly imported.
18:08:48 <porges> I tried what CakeProphet pasted and it works fine for me
18:08:49 <orbitz> http://hpaste.org/13270#a1
18:08:51 <orbitz> worked ok for me
18:09:50 <orbitz> i feel like cake isnt' showing us everything, his error is referecnign Main which is not in lol.hs he gave us at all
18:10:34 <rwbarton> porges: Try runhaskell lol.hs
18:10:51 <porges> rwbarton: I did
18:10:51 <int-e> porges: main has to be in a module called Main (unless you want to play with -main-is (or is it --main-is?))
18:10:58 <orbitz> runhaskell works for me as well
18:11:09 <porges> that's why I said it might be a 6.10 change
18:11:21 <porges> 6.8 might need what int-e said
18:11:51 <int-e> runghc is special, hmm.
18:12:22 * orbitz is off to do some reading, seeya
18:12:27 <rwbarton> this is what I get from runhaskell: http://hpaste.org/13270#a2
18:12:50 <porges> so it must be 6.8 vs. 6.10 :P
18:12:51 <orbitz> rwbarton: does it work if you do --main-s?
18:13:05 <int-e> runghc accepts that since ... 6.8.3? hmm.
18:13:28 <porges> so 6.8.2 vs 6.8.3
18:13:31 <porges> :)
18:15:57 <porges> so the reason is: your module containing the "main" function has to be called Main (up until GHC version 6.8.2)?
18:16:47 <CakeProphet> ah
18:16:59 <CakeProphet> alright... next step: monads (of course)
18:18:21 <CakeProphet> I'll read up on some stuff first before I ask in here
18:19:49 <rwbarton> orbitz: I got ghc to accept -main-is, but not runhaskell
18:21:20 <int-e> The responsible patch is "Tweak runghc" from January 20th 2008.
18:26:58 <gaze> happy isn't being so happy.
18:27:19 <int-e> (http://darcs.haskell.org/ghc/_darcs/patches/20080120184639-3fd76-d44a1e01934f4f0b7079c8413c306cc35aa3601a.gz if anybody is still interested)
18:28:01 <gaze> http://hpaste.org/13272 any idea what's going on? Parser.hs is generated by happy
18:29:47 <porges> what happened to NoMethodError? almost got lambdabot compiling except for that
18:32:04 <porges> looks like I need to get Plugin.Compose to import Control.Exception rather than GHC.IOBase
18:32:04 <int-e> gaze: hard to say without more information - have you checked Parser.hs near line 1876? Maybe it's some of your own code from Parser.y?
18:32:53 <gaze> yeah, not my code though. I'm trying to figure out what tokens it's processing around there to maybe figure out what part of my grammar is causing happy to generate that code
18:36:04 <porges> lambdabot installed :D~
18:36:41 <porges> just have to ensure haskell-src-exts is < 0.4 and edit Plugin.Compose & Plugin.Base to import Control.Exception rather than GHC.IOBase
18:42:29 <kristofer> yo
18:42:30 <kristofer> http://hpaste.org/13273
18:42:40 <kristofer> I"m having a type issue
18:43:59 <jeffz`> kristofer: x <- many
18:44:01 <jeffz`> kristofer: many what?
18:44:29 <kristofer> many char's
18:45:29 <jeffz`> kristofer: if that's what you mean then you should change your code.
18:46:05 <porges> you want "many anyChar" then
18:47:01 <kristofer> jeffz`, maybe you need to see another function.. my goal is to have the parser replace the escape characters with the actual characters
18:47:17 <augustss> kristofer: but I don't really think anyChar is what you want.
18:47:46 <kristofer> can I edit my paste?
18:48:04 <jeffz`> kristofer: huh? I've pointed out the error in your code
18:48:13 <porges> you can click annotate
18:48:19 <porges> but pastes aren't mutable ;)
18:48:41 <pumpkin> hmm, any good libs for factoring small numbers in haskell? not terribly small, but bigger than what the Primes package at http://www.polyomino.f2s.com/david/haskell/numbertheory.html allows
18:49:08 <augustss> kristofer: there are many errors in your code
18:49:27 <pumpkin> oh I think I found something in that same package
18:50:31 <augustss> pumpkin: there are many factoring algorithms in it
18:52:12 <sclv> pumpkin: look for the lazy wheel sieve for a cool algorithm
18:53:07 <sclv> http://www.haskell.org/haskellwiki/Prime_numbers
18:53:42 <sclv> that's just prime generation though, not factoring i suppose
18:57:13 <Axman6> whoot, my RWH has shipped!
18:57:27 <sclv> the quad sieve and dixon's algorithm are both fun to implement for the heck of it too.
18:57:58 <sclv> i wanted to write a general number field sieve algorithm but my math-fu was too weak.
18:58:55 <sclv> oh, pollard's rho is also easy, and fun.
18:59:43 * tehgeekmeister is confused
18:59:54 <tehgeekmeister> i change the indentation on some code, and i get a kind error because of it...
19:00:13 <sclv> well, at least it's not a harsh error...
19:00:20 <tehgeekmeister> =P
19:00:45 <Axman6> heh
19:01:26 <tehgeekmeister> it says i'm probably applying maybe to too many arguments here:
19:01:27 <tehgeekmeister> maybe (return 0) (lift . (\a -> (print $ pageCount st) >> print ((fromIntegral $ pageCount st)/1768758) >> insert a)) (page st)
19:01:39 * blackh has received RWH today too. Yay!
19:01:41 <tehgeekmeister> but as far as i can tell, that's just as many arguments as needed and in the right order, even!
19:01:58 <solrize> i got mine a few days ago
19:02:05 <CakeProphet> Harsh error = "What are you even thinking - check your type signatures, dummy"
19:02:12 <solrize> hey i just installed fedora 10 on my travel laptop.... what ghc should i put on it?  still 6.8.3?
19:02:26 * tehgeekmeister might buy the ebook version of RWH soon
19:02:53 <SamB_XP> tehgeekmeister: try a more pointful approach
19:04:03 <SamB_XP> also it looks like you're applying maybe to 3 args to me ...
19:04:36 <SamB_XP> @type maybe
19:04:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:04:43 <tehgeekmeister> SamB_XP: it takes three
19:04:45 <SamB_XP> oh, that's normal
19:04:47 <SamB_XP> huh
19:04:48 <SamB_XP> that's odd
19:05:00 <SamB_XP> what type has the middle argument ?
19:05:25 <tehgeekmeister> in this case?  Page -> IO ()
19:05:48 <porges> IO () /= IO Int?
19:05:58 <tehgeekmeister> oh, wait
19:06:03 <tehgeekmeister> meant IO Int
19:06:11 <aluink> http://pastebin.com/d637affe3
19:06:12 <tehgeekmeister> SamB_XP: the odd part is that this same exact code works in a differently indented version of the code.
19:06:20 <aluink> that code compiles, i don't understand the last line
19:06:29 <SamB_XP> tehgeekmeister: what ?
19:06:35 <aluink> can someone explain how (return . users) is a function?
19:06:37 <SamB_XP> tehgeekmeister: I guess you indented it wrong
19:06:55 <tehgeekmeister> SamB_XP: i guess?  but i've rechecked it multiple times, i can't find anything wrong yet...
19:07:44 <Asztal> aluink: it's equal to (\x -> return (users x))
19:07:49 <porges> return . f = (\x -> return (f x))
19:07:53 <porges> rah!
19:08:19 <aluink> porges: yes, i know, but users :: Data.Map.Map String User
19:08:37 <aluink> users isn't a function, how can you do composition on it?
19:08:44 <Asztal> no, users :: State -> M.Map String User
19:09:05 <aluink> AHHH!!!! i get it now
19:09:21 <aluink> when i ran :type on users, it gave me State -> ...
19:09:55 <aluink> ok...so how is it State -> M.Map ...? why is it not just a map? how does it become a funciton like that?
19:11:53 <Asztal> it needs a State object to get the users from, so it becomes a function that takes that State object as an argument
19:12:06 <aluink> i'm fine with being directed to docs that can explain it ;), i've just read tons about monads and typeclasses, and i'm still not getting it
19:12:31 <aluink> hmmm, how is that State object given, cause askUsers doesn't take any params?
19:12:52 <porges> users is a record accessor, which is really a function (State -> Map String User)
19:12:58 <SamB_XP> aluink: when you define a record field, an accessor function of the same name gets defined that takes an object of the record type as argument
19:13:38 <porges> if you were to write it with an argument
19:13:48 <porges> askUsers x = return . users =<< ask x
19:14:53 <porges> oops
19:14:57 <porges> ignore that ;P
19:15:02 <Asztal> @src liftM
19:15:03 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:15:21 <Asztal> @. undo src liftM
19:15:21 <lambdabot> ()
19:15:27 <Asztal> bleh!
19:16:57 <SamB_XP> @undo \f m1 -> do { x1 <- m1; return (f x1) }
19:16:57 <lambdabot> \ f m1 -> m1 >>= \ x1 -> return (f x1)
19:17:14 <aluink> I GET IT!!!
19:17:18 <SamB_XP> @. pl undo \f m1 -> do { x1 <- m1; return (f x1) }
19:17:18 <lambdabot> fmap
19:17:25 <SamB_XP> heh
19:17:30 <porges> aluink: askUsers = do state <- ask; return (users state)
19:17:32 <SamB_XP> figures
19:17:42 <aluink> user (State users _ ) = users
19:17:43 <aluink> yes?
19:17:54 <aluink> well users (State...
19:18:22 <SamB_XP> I guess so
19:18:31 <Quylui> <-- new to haskell. trying to compile something and i'm running into an error. this should be simple to fix, could i pm a volunteer here for help?
19:18:39 <SamB_XP> modulo any issues from binding the same name as you are defining in that pattern ;-P
19:18:50 <aluink> users State (sessions users) = users
19:18:51 <SamB_XP> Quylui: no!
19:18:53 <SamB_XP> you must ask HERE
19:19:12 <Quylui> alright.
19:20:55 <aluink> alright, after many hours of working on this line...i can sleep now!!!
19:20:59 <Quylui> http://hpaste.org/13274 <-- pasted here. i'm unaware of the error, but winhugs can't seem to compile it.
19:21:12 <tehgeekmeister> this is even weirder;; ghc is expecting type (->) (Maybe Page) for some reason
19:21:15 <strht_> your first problem is using windows
19:21:21 <tehgeekmeister> i don't even understand that type, but i think somehow i'm in the wrong monad
19:21:22 <strht_> your second problem is not having an error at hand ;)
19:21:39 <SamB_XP> Quylui: if you would paste the error message, we'd be much more able to help you
19:22:00 <Quylui> indeed. ERROR file:.\intern.hs:6 - Syntax error in expression (unexpected `<-')
19:22:06 <rwbarton> Quylui: Your outer 'if' needs a 'do' in the 'then' branch, and also an 'else' branch
19:22:17 <SamB_XP> heh
19:22:26 * SamB_XP was expecting a type error
19:22:28 <blackh> Quylui: After 'then' you need a do, but make sure all your statements after 'do' are indented the same amount.
19:22:40 <Quylui> thank you.
19:23:11 <blackh> Quylui: That is, you can't say "then do putStrLn" followed by "name <-".  Your "putStrLn" and "name <-" must have the same indentation.
19:24:16 <Quylui> to clarify, "name <-" must be aligned beneath "putStrLn" and not "then"?
19:24:32 <tehgeekmeister> http://hpaste.org/13275 <== am in in the right monad in the EndTag branch on the highest level case statement here?
19:24:34 <blackh> Quylui: That's right.
19:24:48 <tehgeekmeister> (right monad being StateT IO something something...)
19:25:04 <tehgeekmeister> (yes.  something something.  =P )
19:25:13 <blackh> Quylui: The rule is that after certain keywords - 'do' being one - the next token determines the indentation level that means "start of a statement"
19:25:42 <Quylui> ah, i was unaware. thank you for the information
19:25:42 <Saizan> tehgeekmeister: the problem is (\_ -> Nothing)
19:25:58 <tehgeekmeister> Saizan: huh?
19:26:41 <Saizan> tehgeekmeister: you've that expression as a statement in your do block
19:26:45 <blackh> Quylui: That drove me nuts until I figured it out! The four magic keywords are do, let, where and of.
19:27:19 <Saizan> tehgeekmeister: so it tries to unify (a -> Maybe b) with your monad type
19:27:28 <tehgeekmeister> Saizan: originally that was a updatePage (\_ -> Nothing), but then i realized i was doing updatePage from every branch of the case expressions, so i moved that up to the top
19:27:50 <Quylui> blackh: Hah, well I still have hardly scratched the surface of Haskell's capabilities, I'm sure. I'll have more questions shortly as I begin to modify this a little bit (your suggestion fixed my problem, as expected)
19:27:55 <tehgeekmeister> Saizan: i never understood the "unify" bit, what does that mean?
19:28:48 <orbitz> @hoogle Monad Maybe
19:28:48 <lambdabot> Did you mean: :: Monad (Maybe a) /count=20
19:28:48 <lambdabot> No results found
19:28:50 <Saizan> tehgeekmeister: unification is the process of taking two types and seeing if there's a least common one
19:29:01 <orbitz> @hoogle Monad (Maybe a)
19:29:02 <lambdabot> Warning: Unknown type Monad
19:29:02 <lambdabot> Prelude Nothing :: Maybe a
19:29:02 <lambdabot> Data.Maybe Nothing :: Maybe a
19:29:17 <Saizan> tehgeekmeister: i.e. (a -> b) unifies with (Int -> Bool) by taking a = Int, b = Bool
19:29:26 <tehgeekmeister> Saizan: ah, okay
19:29:27 <strht_> if your code is indented poorly
19:29:41 <strht_> it's likely as a result of your lack of understanding
19:29:49 <strht_> of what exactly you want the code to do
19:29:50 <Saizan> tehgeekmeister: however, in which monad are those do-blocks supposed to be?
19:30:09 <tehgeekmeister> Saizan: State is the outer monad, IO inside it
19:30:19 <strht_> if you don't understand the scope of an element of your program
19:30:34 <strht_> you likely don't understand its function as well
19:31:07 <strht_> assuming your indentation represents scope, of course (which it oughtta)
19:31:31 <Saizan> tehgeekmeister: ok, so, you can't just put an expression as the last line of a do-block to return that as a value, you've to use "return"
19:31:47 <tehgeekmeister> Saizan: oh, right.  *tries
19:31:50 <Saizan> i.e. "return (\_ -> Nothing)"
19:31:52 <Saizan> also
19:32:06 <Saizan> you need to extract the result with <-
19:32:13 <Saizan> before you can pass it to updatePage
19:32:29 <tehgeekmeister> hum.  that means it's not really simplifying my code any
19:33:03 <Saizan> well, you can also use =<< instead of $ there
19:33:25 <tehgeekmeister> Saizan: yes, but every other branch doesn't have a do block at that level, you see what i mean?
19:33:32 <Saizan> <- desugars to =<< anyway (or >>= which is just the same but with the arguments flipped)
19:34:00 <Saizan> tehgeekmeister: you can use return without the "do" keyword
19:34:09 <Quylui> blackh, what do i do if i want the program to return to "getLine" after the user inputs an invalid response
19:34:21 <tehgeekmeister> Saizan: ah, so i return from every branch, including the one with the do block
19:34:21 <Saizan> that's needed only if you sequence multiple actions
19:34:22 <tehgeekmeister> okay
19:34:33 <pumpkin> can mapreduce be considered a hylomorphism?
19:34:56 <pumpkin> or is map not unfoldish enough
19:35:08 <tehgeekmeister> heh.  unfoldish.
19:35:14 <Quylui> blackh, do i have to define a function and re-use it?
19:35:16 <blackh> Quylui: You've got several options. One is to call yourself recursively but you might need to split your function in two so you can recurse back to the right bit.
19:36:47 <Quylui> that's what i was thinking. though i'm afraid i'll mess something up (as far as the syntax is concerned, i'll attempt it first and keep you informed of the results)
19:37:15 <blackh> Quylui: There's no "while" construct for monadic code, as such.  It's easy to write your own one if you want to.
19:37:41 <tehgeekmeister> Saizan: what it looks like to me, then, is in order to pull updatePage out to the top level, i've gotta put return in every place updatepage was at before, so i'm really not factoring anything out, am i?
19:38:29 <blackh> Quylui: Make a new function starting with "response <- getLine", then have it call itself if the user input is invalid.
19:38:51 <Saizan> tehgeekmeister: well if you later want to change updatePage with something else you've to edit only one place in your code, though
19:39:35 <tehgeekmeister> Saizan: hmm, true, i suppose, but since updatePage is defined in parseElement, i could just change the definition of updatePage itself
19:40:05 <Quylui> blackh, for the record, this is my first time coding.... ever. first language, etc. so preemptive apologies if i struggle to keep up
19:40:38 <Saizan> tehgeekmeister: btw, that fmap in the Content branch doesn't look right
19:41:12 <tehgeekmeister> Saizan: i was previously calling fmap from every branch below Content, so i moved it up as well
19:41:39 <blackh> Quylui:  Then you don't have to worry about Haskell being different to other languages.  Let me know how it all goes for you.  I'm one of the more common ones that learnt other languages first, so it's interesting to compare experiences.
19:41:51 <tehgeekmeister> Saizan: oh, wait, no, i was calling it from all but the last branch, but i figured since the last branch was just calling id, it should be okay
19:42:31 <Saizan> tehgeekmeister: it was like "fmap appendToTitle s" ?
19:42:53 <tehgeekmeister> Saizan: originally, last working version, it was updatePage $ fmap $ appendToTitle s
19:43:10 <tehgeekmeister> then i started factoring the common calls out
19:43:15 <Saizan> ah ok
19:43:42 <Quylui> blackh, i have a non-working rough draft... mind if i submit it to you for debugging?
19:43:57 <blackh> Quylui: Sure! Go right ahead.
19:44:24 <Quylui> http://hpaste.org/13276
19:44:34 <tehgeekmeister> Saizan: you'll notice that the Content branch is the only one that ever reaches inside the Page, which is inside a Maybe, hence the use of fmap there only
19:45:45 <blackh> Quylui: on line 16 you need a do - "else do putStrLn..."
19:46:17 <blackh> Quylui: Also in several other places.  You need 'do' wherever you've got more than one statement.
19:46:37 <Quylui> ah.
19:47:05 <blackh> Quylui: Another gotcha: Your 'else' on line 18 needs to be indented, because the compiler will see it as another statement otherwise, rather than part of the if.
19:47:05 <Quylui> however, is the formatting correct overall?
19:47:26 <Quylui> i see
19:48:00 <blackh> Quylui: The first if will need an else. Put "return ()" after it - which means "do nothing".
19:48:32 <rainmann> @src when
19:48:32 <lambdabot> when p s = if p then s else return ()
19:48:54 <blackh> Quylui: If you want to leave out the else, you can use a thing called "when".  This is like an if without an else, but it has different syntax, so try that when you've mastered "if".
19:48:57 <gwern> (rainmann beat me to it; but hlint would've caught it anyway)
19:49:15 <gwern> 'when () ()', not that hard
19:49:16 <Quylui> blackh, "return ()" after the "if" and before "response"?
19:49:35 <gwern> when is, in fact, easier to learn since it's a normal function not some builtin syntax
19:50:00 <blackh> Quylui: No... I'm saying that the first if "if response == "Y"" will need an else right down the bottom, and that will need to say "else return ()"
19:50:32 <Quylui> i see
19:50:46 <blackh> Quylui: But make sure it is indented further than the "if", due to the indenting rule.  This stuff takes a little getting used to.
19:51:04 <gwern> identned further? doesn't idnenting to the same column work?
19:51:18 <rwbarton> blackh: the 'else' near the middle is intended to go with that outer 'if', I think
19:51:18 <blackh> Quylui: What I do is start a new line after 'do' but that's just up to your own sense of style.
19:51:24 <SamB_XP> gwern: not in a do, no
19:51:52 <gwern> SamB_XP: so out of a do works?
19:52:00 <blackh> rwbarton: Ah, you're right.  Quylui: I was expecting the "else" to line up with the "then" so I didn't read it properly.
19:52:20 <blackh> Quylui: So ignore what i said about the extra else.
19:52:26 <Quylui> ok
19:53:10 <Quylui> also, i'm going to have to change this one more time
19:53:17 <Quylui> i've made a mistake.
19:53:50 <Quylui> instead of going from "invalid name" to entering another name, it goes to "invalid response"
19:54:04 <Quylui> or rather "you did not enter a valid answer"
19:55:09 <Quylui> i've made "you did not enter a valid answer" do to "doResponse" which makes them enter Y or N again
19:55:19 <Quylui> so i'll have to change that. (sorry for flooding the channel)
19:56:18 <blackh> Quylui: I like the self destruct. Reminds me of the Haskell in-joke about "do ; launchMissiles".
19:58:14 <SamB_XP> unsafePerformIO launchMissles
20:00:16 <orbitz> where is the monad instance for Maybe and [] defined?
20:00:42 <SamB_XP> Prelude ?
20:01:57 <orbitz> eep why is th tain prelude?
20:02:05 <blackh> SamB_XP: I thought of another version: unsafePerformIO (forever $ forkIO launchMissile)
20:02:35 * tehgeekmeister w00t!  it compiles again.  =D
20:02:54 <SamB_XP> orbitz: well, why not ?
20:03:11 <Quylui> blackh, hah. in other news, i'm getting kind of sloppy/tired. try to see if you can help me with this part... http://hpaste.org/13277
20:03:14 <orbitz> SamB_XP: i'd expect it to be in Data.Maybe
20:03:32 <SamB_XP> then it would be orphaned!
20:03:33 <Quylui> i'm not really familiar with how the compiler parses the data, so disabuse me if you will.
20:03:39 <orbitz> SamB_XP: what do you mean?
20:04:15 <SamB_XP> orphaned instances are instances that are defined seperately from both the class and the datatype
20:04:50 <SamB_XP> I think
20:04:52 <blackh> Quylui: The compiler doesn't like your indenting on line 11 (if name ==). I suggest you start by turning tabs off in your editor.
20:04:58 <orbitz> SamB_XP: isn't Maybe also defien din Data.Maybe?
20:05:09 <SamB_XP> heck no!
20:05:27 <blackh> Quylui: "name <-" needs to line up with "if name ==" (lines 10 & 11)
20:06:00 <Quylui> ah, careless error
20:06:07 <Quylui> i see that now
20:06:20 <blackh> Quylui: I think ghc assumes tabs are 8 but many editors use 4. Best to avoid tabs altogether.
20:06:31 <Quylui> i've set my tabs to 9
20:06:32 <Quylui> 8*
20:07:14 <Quylui> using notepad++ (i've heard emacs is better, but i'm honestly far too naive to know the difference)
20:07:45 <Chile`> doesn't really matter what your tabs are as long as they're consistent
20:07:46 <blackh> Quylui: 8 should be OK. I don't use them. Great stuff!  It looks like you have the right idea with this code.
20:07:51 <tehgeekmeister> http://hpaste.org/13278 <== that look like sane indentation/formatting/etcetera?
20:08:43 <Quylui> blackh, it works! thanks so much for the help
20:08:47 <orbitz> SamB_XP: look slike it IS in Data.Maybe, Prelud ejust exports it
20:09:03 <SamB_XP> orbitz: oh ... is that how it works ?
20:09:06 <sjanssen> blackh: (\tag -> put $ Just $ EndTag tag)
20:09:16 <orbitz> SamB_XP: ghc 6.10.1 atleast
20:09:16 <sjanssen> blackh: that is more readable as (put . Just . EndTag)
20:09:27 <orbitz> SamB_XP: nless you'r ebeing sarcastic with me
20:09:28 <SamB_XP> I can never remember which modules are on which side of Prelude ...
20:09:43 <tehgeekmeister> sjanssen: did you mean me?
20:10:07 <sjanssen> tehgeekmeister: erm, yes I did :)
20:10:11 <sjanssen> blackh: disregard, I can't read
20:10:23 <tehgeekmeister> sjanssen: you're right, point free would be better there.  thanks.
20:10:40 <blackh> sjanssen: I usually know it's time to go to bed when I start talking to myself.
20:11:04 <SamB_XP> blackh: lol
20:11:07 <sjanssen> tehgeekmeister: parseElement is really big, any way to split it up?
20:11:21 * cizra ponders about left-associativity of Haskell functions. Why? It seems so non-intuitive to me. And results in a bunch of extra parens.
20:11:27 <tehgeekmeister> sjanssen: i'd like to, but no ideas have come to mind yet.
20:11:59 <sjanssen> cizra: wouldn't right associativity result in many more parens for multi-argument functions?
20:12:22 <tehgeekmeister> hmm, i can't do a point free of (\tag attrs -> put $ Just $ StartTag tag) sanely, can i?
20:12:26 <cizra> sjanssen: dunno.. I'm a Haskell newb, anyway, so my opinion doesn't count (much).
20:12:49 <tehgeekmeister> cizra: i once thot the same as you, but with a bit more time i changed my mind.
20:13:43 <sjanssen> cizra: say we have a three argument function: "f x y z" with left-associative application
20:14:05 <tehgeekmeister> sjanssen: perhaps i could have an XMLChunk handler that does the main pattern matching?
20:14:16 <sjanssen> cizra: this would be "((f x) y) z" with right-associative application, which would be a bit annoying
20:14:35 <cizra> sjanssen: Hmm, I see, yes.
20:14:47 <tehgeekmeister> sjanssen: that'd cut parseElement down to six lines, but i'd still have all the code somewhere else...
20:22:23 <afabian> I'm trying to write a type declaration for a list type (for learning purposes.)  data List a = List a | List (a : [a]) isn't quite.. ah, legal syntax.  Anyone know how to write what it looks like I'm thinking?
20:23:00 <cizra> > readFile "/dev/urandom"
20:23:01 <lambdabot>   * Exception: "<IO [Char]>"
20:23:04 <sjanssen> afabian: a few problems there
20:23:14 <cizra> > readFile "/etc/shadow"
20:23:15 <lambdabot>   * Exception: "<IO [Char]>"
20:23:18 <sjanssen> afabian: you're using the name 'List' for two different constructors
20:23:19 * cizra pouts
20:23:32 <blackh> afabian: Try something like: data List a = EndOfList | List a (List a)
20:23:34 <sjanssen> afabian: the name of the second constructor should actually be ':'
20:23:39 <afabian> sjanssen: Ahh.. okay, I .. wasn't sure that was legal.  I see.
20:23:48 <tehgeekmeister> how do i turn a (\x y -> ...) where i'm not using the second argument at all, it's just needed for the type, into a points free?
20:23:49 <mbz> > readFile "/proc/self"
20:23:50 <lambdabot>   * Exception: "<IO [Char]>"
20:23:58 <sjanssen> afabian: the second component of the second constructor should be a 'List a', not [a]
20:24:10 <tehgeekmeister> oh!  stuff . (\x _ -> x)
20:24:11 <sjanssen> afabian: and your definition does not allow empty lists
20:24:12 <tehgeekmeister> ?
20:24:29 <sjanssen> tehgeekmeister: const
20:24:49 <tehgeekmeister> oh!
20:24:50 <tehgeekmeister> nice.
20:24:51 <sjanssen> > const 'x' 'y'
20:24:52 <lambdabot>   'x'
20:25:00 <ivanm> > const 'x' undefined
20:25:01 <lambdabot>   'x'
20:25:12 <tehgeekmeister> is there a similar one that flips arguments?
20:25:20 <tehgeekmeister> or would you just do flip const?
20:25:20 <ivanm> tehgeekmeister: flip const
20:25:21 <sjanssen> tehgeekmeister: flip const
20:25:26 <tehgeekmeister> okay
20:25:30 <ivanm> @pl \ x y -> y
20:25:30 <lambdabot> const id
20:25:33 <BMeph> I would do swap! ;p
20:25:43 <sjanssen> BMeph: hmm?
20:25:43 <ivanm> BMeph: absorb? ignore?
20:27:04 <BMeph> Hiya, conal! :)
20:28:29 <tehgeekmeister> hmm.  (put . Just . StartTag . const) doesn't work
20:28:54 <tehgeekmeister> complains about const being applied to too few arguments
20:29:00 <tehgeekmeister> but it's not being applied there!  just composed
20:29:12 <ivanm> tehgeekmeister: you need an extra .
20:29:20 <tehgeekmeister> at the end?  oh.
20:29:21 <tehgeekmeister> right.
20:29:36 <ivanm> ((put . Just . StartTag . ) const) <-- something like that
20:30:00 <ivanm> use @pl to work out what
20:32:02 <tehgeekmeister> @pl (\tag attrs -> put $ Just $ StartTag tag)
20:32:03 <lambdabot> const . put . Just . StartTag
20:32:13 <tehgeekmeister> const at the end?!
20:32:20 <tehgeekmeister> *scratches head
20:32:36 <ivanm> tehgeekmeister: you end up constructing/expanding the first arg to const with that whole func chain
20:33:39 <tehgeekmeister> ivanm: i don't understand what you said, sorry.  could you rephrase?
20:33:52 <ivanm> @unpl const . put . Just .StartTag
20:33:52 <lambdabot> (\ d _ -> put ((Just) ((StartTag) d)))
20:33:53 <SamB_XP> @pl ((put . Just . StartTag . ) const)
20:33:53 <lambdabot> put (Just (StartTag . const))
20:34:02 <ivanm> that make more sense now?
20:34:09 <SamB_XP> not it!
20:34:37 <mbz> How much free space do I need to build ghc-6.10 from sources?
20:34:52 <SamB_XP> mbz: how much have you got ?
20:34:53 <mbz> I have about 5gibs, is it enough?
20:35:03 <SamB_XP> sure!
20:35:13 <mbz> okay, thanks.
20:35:29 <SamB_XP> I think it only takes a few hundred
20:35:31 <cizra> I'm sure lots o' people use Vim for haskellization, right? Is there some auto-indenting plugin available?
20:35:53 <tehgeekmeister> ivanm: i'm even more confused now.
20:35:54 <ivanm> cizra: heh, I know there's a syntax highlighter for vim...
20:36:05 <ivanm> tehgeekmeister: you basically want to ignore attrs, right?
20:36:11 <tehgeekmeister> ivanm: yep
20:36:18 <cizra> ivanm: Yes, I see it. Nice and colorful.
20:36:24 <ivanm>  @pl said ` const . put . Just . StartTag '
20:36:34 <ivanm> let's take it a step at a time:
20:36:48 <tehgeekmeister> ivanm: i just figured that const would need to go at the right end of the chain, that's where everything starts, right?
20:37:30 <ivanm> (const . put . Just . StartTag) tag => (const . put . Just) (StartTag tag) => (const . put ) (Just (StartGat  tag)) => const (put (Just (StartTag tag)))
20:37:43 <ivanm> when using . , you take one argument at a time
20:38:03 <ozy`> cizra: vim's indent support blows decapitated rabbit chunks, for the most part.
20:38:13 <ozy`> well
20:38:17 <ozy`> that's not quite fair
20:38:18 <ivanm> this way, all those functions after const absorb tag and form the first argument to const
20:38:51 <ivanm> there is a way of having const at the end, but it looks something like ((put . Just . StartTag .) . const) , which IMHO is uglier
20:38:58 <ozy`> it preserves the indent from the previous line, increases indent by one shiftwidth if the previous line ends in an operator, and handles certain keywords correctly
20:39:00 <procyon112> is there a way to pull down latest GHC with cabal or the like?
20:39:25 <ivanm> procyon112: not with cabal, since ghc isn't packaged/built with cabal
20:39:25 <ozy`> but it won't line up | with =
20:39:33 <ozy`> among other minor annoyances
20:39:35 <ivanm> mainly due to bootstrapping issues AFAIK
20:40:06 <procyon112> ivanm: thx
20:40:13 <tehgeekmeister> ivanm: i'm starting to get it, it's because (.) takes two one argument functions, but const is a two arg function
20:40:13 <ivanm> no worries
20:40:22 <mbz> cizra, try this: http://pastebin.ca/1292033
20:40:23 <ivanm> tehgeekmeister: yeah
20:40:50 <tehgeekmeister> ivanm: so this is some perverse combination of partial application and composition?
20:41:05 <ivanm> heh, you could possibly see it that way
20:41:36 <ozy`> mbz: is that the standard haskell indent file?
20:42:13 <mbz> ozy`: dunno.
20:42:22 <ozy`> mbz: it looks like it
20:42:34 <tehgeekmeister> @src const
20:42:35 <lambdabot> const x _ = x
20:43:21 <tehgeekmeister> @src (.)
20:43:21 <lambdabot> (f . g) x = f (g x)
20:43:40 <tehgeekmeister> okay, so it's partial application.  and composition.  ew.  =P
20:44:05 <sjanssen> tehgeekmeister: it is not unusual to combine those things
20:44:22 <tehgeekmeister> sjanssen: yes, but it's evilly confusing for me.
20:45:40 <cizra> mbz: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
20:45:45 <mbz> ozy`: I'm using vim7.2.65 and there is no standard haskell indent file
20:45:51 <cizra> mbz: After some configuration, the vimfiles/haskellmode-20081031.vba works frikkin' fine!
20:46:11 <ivanm> sjanssen: heh, sounds like a Tom Jones classic ;-)
20:46:42 <cizra> mbz: .. except for indent
20:46:45 <cizra> I'm testing with this line
20:46:49 <cizra> myDrop n xs = if n <= 0 || null xs
20:47:00 <cizra> Pressing enter oughta indent me to "if".
20:47:24 <sjanssen> ivanm: heh
20:47:38 <ozy`> cizra: it only handles certain keywords. and I've never seen anyone end a line with "if"
20:47:43 <ivanm> cizra: no, it would be _nice_ if it indents, but there's no "oughta"
20:48:16 <cizra> ivanm: Programs oughta do what I want them to do. That's what they are for.
20:48:28 <ozy`> cizra: hack that into yi if you like
20:48:45 <ivanm> cizra: no, they do what they were designed to do
20:48:46 <cizra> ozy`: What? Cheat my beloved Vim with yi?
20:51:04 <ivanm> if you think it should do something else, fix it
20:51:05 <cizra> ivanm: Indeed they do. But they oughta do what I want them to do.
20:51:09 <mbz> cizra: the indent mode I've pasted places cursor right under 'n' in this case
20:51:15 <cizra> And yes, work in progress, ivanm (;
20:51:19 <ivanm> cizra: what, the world revolves around you then?
20:51:21 <ozy`> "Vimscript is my wedded wife, and Haskell is my mistress"
20:51:51 <cizra> ivanm: Of course not. But my computer oughta.
20:52:02 <ozy`> (ITT, I mangle quotes from Chekhov)
20:52:29 <ivanm> ozy`: of Star Trek fame?
20:52:35 <tehgeekmeister> is there some easy way around having to type Prelude.* every time you wanna work with a list when you're using bytestrings?
20:52:49 <ivanm> tehgeekmeister: import qualified bytestrings
20:52:51 <ozy`> ivanm: the other one
20:52:57 <ivanm> ozy`: which other one?
20:53:01 <cizra> mbz: About not ending a line with if.. Real World Haskell does this in http://book.realworldhaskell.org/read/types-and-functions.html#funcstypes.if
20:53:20 <tehgeekmeister> ivanm: i'm currently doing import Data.ByteStrings.Lazy as BS, but that's not doing it
20:53:40 <blackh> tehgeekmeister: add 'qualified
20:53:42 <ivanm> tehgeekmeister: "import qualified Data.Bytestings.Lazy as BS"
20:53:44 <ozy`> ivanm: Anton Chekhov, as in "Chekhov's gun"
20:53:51 <tehgeekmeister> ivanm: ah, thank you
20:53:53 <ivanm> never heard of it
20:54:10 <mbz> cizra: I was ozy`, not me
20:54:11 <cizra> ivanm: Not that I want to bash you, but that kind of attitude won't make software better.
20:54:19 <cizra> mbz: oops
20:55:00 <ivanm> cizra: what kind of attitude?
20:55:00 <mbz> cizra: I just said that the mode I've pasted places cursor on the next line right under 'n' in 'if n'
20:55:21 <ivanm> that software should automatically do what I want without it knowing what you want?
20:55:43 <cizra> ivanm: "no, they do what they were designed to do" about programs. Programs aren't some holy cow, immutable like Haskell variables.
20:55:53 <ivanm> AFAIK, we still haven't managed to develop a DWIM function
20:56:07 <ivanm> cizra: s/designed/programmed/
20:56:19 <ivanm> which is literally and strictly correct
20:56:30 <cizra> ivanm: I was VERY surprised to see swi-prolog muttering something about "couldn't correct your code with DWIM" to me.
20:56:39 <ivanm> heh
20:56:54 <jeffz`> cizra: immutable variable, that's an oxymoron isn't it?
20:57:05 <cizra> ivanm: It seems we understand the nice non-English world "oughta" differently.
20:57:10 <ozy`> jeffz`: variables don't. constants aren't.
20:57:13 <cizra> jeffz`: hah, well, Real World Haskell uses it
20:57:20 <ivanm> cizra: could be
20:57:39 <ivanm> jeffz`: a variable is a named placeholder for a given value
20:57:48 <ivanm> as in mathematics
20:58:23 <jeffz`> ivanm: lexical binding sounds much better to me.
20:58:56 <tehgeekmeister> how do i pass in a string like db=name as a command line argument?  i've tried quoting and escaping various ways but i'm not getting it right
20:59:01 <ivanm> or that ;-)
20:59:33 <ivanm> tehgeekmeister: as in you don't know how to read args, or how to parse them?
20:59:45 <ozy`> jeffz`: well I for one prefer "contextually sensitive symbolic representation"... so there
20:59:57 <tehgeekmeister> ivanm: oh the haskell bit is easy, it's getting the shell to actually pass it in un-mangled that's the problem
21:00:28 <ozy`> tehgeekmeister: do you not know how to use single-quoted strings?
21:00:29 <jeffz`> ozy`: heh, I still find mutable and immutable contextually sensitive symbolic representation much more pleasant than variable :)
21:00:33 <ivanm> tehgeekmeister: ahhh
21:01:00 <tehgeekmeister> ozy`: oh!  no, i just forgot.  i only get time to play with computers every once in a while, so i forget these things and have to relearn them
21:01:23 <ozy`> tehgeekmeister: 'in this string I don''t have to escape any characters except the apostrophe'
21:01:27 <cizra> tehgeekmeister: My shell (zsh) just passes them right
21:01:29 <ozy`> note the ''
21:01:42 <pumpkin> Axman6: you around?
21:08:45 <mae> hello there
21:10:58 <blackh> mae: Hello!
21:11:07 <mae> how are you this fine day?
21:11:33 <blackh> mae: How do you know what the weather is like here? Are you standing behind me?
21:11:43 <mae> i have my ways
21:11:49 <mae> (rfid chips)
21:12:04 <blackh> mae: I am having a great time!
21:12:09 <mae> lookup "blackh" global_rfid_dict
21:12:27 <mae> ; )
21:12:45 <mae> anyone tried out gitit the wiki in happs?
21:14:18 <mbz> cizra: for editting haskell files with vim I use this kludge for "improving" backspace behaviour - http://pastebin.ca/1292056
21:15:17 <cizra> mbz: Sounds ugly from the description
21:15:18 <blackh> mae: Some people were talk about how amazing gitit is, on more than one occasion, but I haven't tried it myself.
21:15:45 <mbz> cizra, yep :\
21:16:05 <mbz> it now takes into accound the starting position of the previous lines. so it is easy to line up the code
21:16:13 <tehgeekmeister> @src showString
21:16:13 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:16:19 <tehgeekmeister> bah
21:19:58 <tehgeekmeister> @src (++)
21:19:58 <lambdabot> []     ++ ys = ys
21:19:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:19:58 <lambdabot> -- OR
21:19:58 <lambdabot> xs ++ ys = foldr (:) ys xs
21:21:20 <tehgeekmeister> @src List
21:21:21 <lambdabot> Source not found. :(
21:21:26 <tehgeekmeister> aw.  worth a try.
21:21:54 <mae> there is nothing amazing about gitit
21:21:57 <mae> but it is a solid start
21:22:28 <tehgeekmeister> how is List defined, again?  data List a = [] | a : List a
21:22:29 <tehgeekmeister> ?
21:22:44 <conal> BMeph: hi there
21:23:23 <mae> also, the git backend is a nice concept -- but I don't understand why a dscm is needed unless they are going to provide some type of multi-branch merge capability
21:24:50 <ozy`> tehgeekmeister: that's not a legal definition since the list stuff is all built in, but that's how it would be, yeah
21:25:40 <tehgeekmeister> ozy`: okay, that's good enough, then.  i'm writing up a blog post about the string concatenation problem i had yesterday, so other people can figure out how to solve that problem easier in the future with google.
21:27:08 <blackh> mae: Why not darcs, I wonder, but then I suppose it doesn't matter.  I might look at it, as I need a wiki.
21:27:35 <mbz> ozy`: problem with string concatenation? what's wrong with it?
21:27:35 <mae> : )
21:27:46 <mbz> s/ozy`/tehgeekmeister
21:28:24 <tehgeekmeister> mbz: well, if you use it the way i was, it's horrible for performance.
21:28:49 <tehgeekmeister> mbz: i had to accumulate a string chunk by chunk, and i was appending with (++) each time
21:29:06 <tehgeekmeister> mbz: as a result my code spent 95% of it's time appending
21:29:31 <tehgeekmeister> mbz: after i switched to composing calls to showString, almost none of my time was in appending.
21:29:58 <mbz> hm.
21:31:26 <tehgeekmeister> mbz: are you familiar with why ++ is slow?
21:32:01 <mbz> because of its implementation? ;)
21:32:27 <sjanssen> mbz: because it has to allocate O(n) cons cells
21:32:38 <cizra> tehgeekmeister: Because it creates new strings every time, instead of expanding the old one?
21:32:42 <tehgeekmeister> mbz: yes.  good answer.
21:32:48 <tehgeekmeister> mbz:  =P
21:33:20 <tehgeekmeister> data List a = [] | a : List a -- this isn't really how list is defined, but it's similar to that
21:33:31 <tehgeekmeister> because a list is always either the empty list, []
21:33:35 <tehgeekmeister> or a pair of a value of type a
21:33:39 <tehgeekmeister> and a list of values of type a
21:33:49 <tehgeekmeister> we can only ever access the head of a list directly
21:33:58 <tehgeekmeister> so to append two lists
21:34:10 <tehgeekmeister> we have to deconstruct the entire list to access each value
21:34:21 <tehgeekmeister> and build up a new one
21:34:37 <tehgeekmeister> (ghc might be doing smarter stuff than that in the background, but that's how i understand it.)
21:35:27 <tehgeekmeister> sjanssen: is that an accurate explanation?
21:35:52 <mbz> I thought that ghc might use vlist or something like that.
21:35:55 <blackh> Each time you add a bit onto the end, it must traverse the whole string.  So it ends up being O(N^2). Yecch!
21:37:03 <tehgeekmeister> mbz: i believe there are good arguments for using this more elegant definition of list, but you've gotta be aware that that's what lists really are, or else you'll get bit by it.
21:38:06 <sjanssen> tehgeekmeister: yes
21:38:11 <sjanssen> mbz: vlist?
21:38:24 <mbz> http://en.wikipedia.org/wiki/VList
21:38:42 <sjanssen> tehgeekmeister: and usually, GHC isn't being smarter than that
21:38:43 <mbz> tehgeekmeister: yeah you are 100% right.
21:39:15 * wli is, in general, a fan of more complex data structures than lists; however, lists in so many cases encode what control stacks do in imperative languages that I use them more than anything else in Haskell anyway.
21:39:19 <tehgeekmeister> sjanssen: what about ShowS, do you know anywhere that explains that really well?  the documentation doesn't really explain how it works.
21:39:51 <tehgeekmeister> sjanssen: it really only says that it's faster and you should use it.
21:40:31 <sjanssen> tehgeekmeister: ShowS is different that it isn't really a sequence, but a description of how to build one
21:40:42 <ozy`> tehgeekmeister: the other thing you could have done is store the entire string in reversed form, and prepend the accumulated bits instead of putting them on the end
21:40:48 <sjanssen> different in that it
21:41:30 <tehgeekmeister> sjanssen: so is it only deconstructing those lists once, as opposed to once per append?
21:41:38 <conal> and the dlist package (on hackage) generalizes the ShowS trick
21:41:39 <tehgeekmeister> ozy`: oh, that would've done it too.  good idea.
21:41:42 <sjanssen> mbz: the singly linked list is good because it is very simple, and has great constant factors for all the primitive operations
21:42:17 <sjanssen> tehgeekmeister: yes, ("asdf"++) is only traversed once, when the final list is created
21:43:20 <sjanssen> mbz: where the primitive operations are head, tail, cons, and null
21:43:38 <mbz> sjanssen: I'm not saying that usual singly linked lists are bad. each data type has its own pros and cons
21:43:46 <tehgeekmeister> sjanssen: so appending isn't really that bad in itself, it's just appending multiple times in a row that's a problem, because you keep having to iterate thru each element, and you've got more elements to iterate thru each time?
21:43:57 <mbz> and each data type doesn't fit to all possible problems
21:44:20 <sjanssen> tehgeekmeister: what is bad is "(x ++ y) ++ z", "x ++ (y ++ z)" is fine
21:44:38 <tehgeekmeister> sjanssen: oh man, now i'm lost
21:44:49 <sjanssen> tehgeekmeister: the ShowS trick makes the former impossible, forcing you to always use the latter
21:45:03 <sjanssen> tehgeekmeister: (++) is O(n) wrt. the first argument
21:45:35 <tehgeekmeister> oh, i think i get it
21:46:34 <tehgeekmeister> that's basically what i was saying up there, you don't want to keep appending to the same list, because you keep having to traverse all the same elements again
21:46:48 <sjanssen> yes
21:46:51 <wli> theCompleteWorksOfShakespeare ++ "merrily to my doom go I"
21:47:46 <pumpkin> @src concat
21:47:46 <lambdabot> concat = foldr (++) []
21:47:53 <pumpkin> which is I guess why that's a foldr?
21:48:27 <wli> foldl would eat space and foldl' choke on infinite lists
21:48:32 <pumpkin> yup
21:48:44 <sjanssen> pumpkin: yep
21:49:11 <sjanssen> more evidence that foldr is The One True Fold :)
21:49:15 * ozy` pictures foldl' as a student in functional university, choking to death on its own vomit at an infinite list party
21:49:23 <pumpkin> lol
21:49:29 <tehgeekmeister> ozy`: beautiful metaphor
21:50:12 <mbz> yuk.
21:50:32 * wli envisions fold' as the second of two loves, which dare not speak its name ...
21:50:34 <mae> i know right?
21:50:36 <wli> foldl' that is
21:50:57 <mwotton> wli: aw, i thought you were about to reveal an exciting new combinator
21:51:38 <wli> mwotton: unfoldl is already in the "Fastest Fib in the West" article.
21:52:09 <mbz> @index unfoldl
21:52:09 <lambdabot> bzzt
21:52:12 <sjanssen> wli: unfoldl, eh?
21:52:17 <pumpkin> :o
21:52:18 <mbz> @index unfold
21:52:18 <lambdabot> bzzt
21:52:22 <pumpkin> r
21:53:18 <wli> sjanssen: It generates the list elements in the reverse order from unfoldr.
21:55:22 <mwotton> wli: where would one find such a marvelous beast?
21:55:31 <mwotton> Data.List disavows knowledge
21:55:45 <pumpkin> :t unfoldl
21:55:46 <lambdabot> forall t a. (t -> Maybe (a, t)) -> t -> [a]
21:55:47 <pumpkin> :D
21:55:57 <pumpkin> mwotton: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
21:56:09 <wli> mwotton: Search for Fibonacci numbers in the Haskell wiki, and then go to the "Fastest Fib in the West" subsection.
21:56:35 <cizra> > last [0, 0..]
21:56:44 <lambdabot>   mueval: Prelude.read: no parse
21:57:08 <cizra> wli: IIRC the fastest Fibonacci algo was the matrix multiplication.
21:57:17 <wli> Given the lengths of the lists involved I might as well have reversed the list.
21:57:33 <cizra> wli: Oh. It seems to be the one.
21:57:45 <pumpkin> well I defined unfoldl for the benefit of anyone brave enough to try it
21:57:51 <pumpkin> as per wli's code
21:58:06 <mwotton> wli: ah, fair enough.
21:58:12 <pumpkin> but beware! it's the fastest gunslinger in the channel
21:58:32 <wli> cizra: I don't know. I've not heard of new results overturning the results in the mailing list thread establishing it as such.
21:58:56 <cizra> wli: It's the matrix multiplication algo you're implementing there, I believe.
21:59:13 <wli> In a very fuzzy sort of equivalence, sure.
21:59:41 <mae> pragmatically, does this equation hold true? (foldl (+) 0) == sum
21:59:55 <dibblego> pragmatically?
21:59:59 <wli> The matrix multiplication has a very real constant factor loss vs. the duplication recurrences.
22:00:34 <mae> meaning .. this does not work because these functions are not instances of Eq .. but are these two functions basically the same thing?
22:00:38 <mgsloan> wouldn't powers of phi be the fastest fibonacci?
22:01:24 <wli> mgsloan: They break down for larger integers barring higher-precision floating point which ends up worse than arbitrary-precision integers.
22:01:41 <dibblego> mae, ignoring the lack of meaning in the attempt to prescribe meaning, yes they are the same
22:01:44 <mbz> > let unf x y f = let x' = f x y in x' : unf x' x f in unf 1 1 (+)
22:01:45 <lambdabot>   [2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711...
22:01:52 <mbz> err.
22:02:21 <mgsloan> wli - ah
22:02:41 <mae> dibblego, not quite following what you mean by this, but I am just trying to familiarize myself with the core functions.. by the same measure (foldl (*) 1) would be the same as product
22:02:48 <tehgeekmeister> http://tehgeekmeister.wordpress.com/2008/12/22/fast-string-appendingconcatenation-in-haskell/ <== before i misinform a lot of helpless people who don't know better, if anyone wants to take a look at that explanation and correct me, feel free.
22:03:23 <mgsloan> wli - what if we used a Real representation? infinitely precise numerics, then brought the calculation to the precision necessary to determine which integer it corresponds to
22:03:31 <mgsloan> then again.. that's a lot of calc
22:03:35 <mgsloan> maybe matrix is good :)
22:03:37 <dibblego> mae, pragmatism roughly means "to stop thinking and start entertaining fallacy", so ignoring that and ignoring "these functions are not instances of Eq" (which does not make sense), then yes these two functions are the same
22:03:41 <dibblego> @src sum
22:03:41 <lambdabot> sum = foldl (+) 0
22:04:00 <ivanm> mgsloan: you mean Maybe Matrix? data types have to be capitalised, after all! :p
22:04:20 <wli> mgsloan: Matrices have some overheads vs. pairs of numbers with duplication recurrences.
22:04:39 <solrize> tehgeekmeister is that the same thing as the writer monad?
22:04:45 <pumpkin> wli: how're your fancy matrices coming along?
22:04:53 <tehgeekmeister> solrize: i really don't think so.
22:04:56 <pumpkin> wli: do you have a ... blog? :P
22:05:00 <tehgeekmeister> solrize: but don't quote me.
22:05:12 <wli> pumpkin: Lousily. Looks like no progress to date and the next few days are shot in advance.
22:05:31 <wli> Goddamn Hanukkah/Christmas/Ramadan/whatever.
22:05:43 <pumpkin> yeah :/
22:05:50 <Quylui> Hey, Kwanzaa too!
22:05:54 <Quylui> >.<
22:06:09 <tehgeekmeister> solrize: no, it's not
22:06:27 <wli> Quylui: According to Futurama, Kwanzaabot won't start reading those brochures for another 600 years.
22:07:54 <Quylui> Hm.
22:09:47 <mae> Hoogle or Hayoo!, that is the question
22:11:48 <pumpkin> @hoogle (Integral a) => a -> a -> a
22:11:48 <lambdabot> Prelude div :: Integral a => a -> a -> a
22:11:48 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
22:11:48 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
22:14:53 <Quylui> might i query as to what the recommended text editor is?
22:15:04 <pumpkin> yi? vi? emacs? textmate!
22:15:07 <Quylui> currently i'm using notepad++
22:15:08 <ozy`> Quylui: probably emacs. sorry dude
22:15:18 <ozy`> pumpkin: I would recommend against textmate
22:15:23 <pumpkin> why?
22:16:47 <wli> nvi doesn't seem to be happening on cygwin so I've been using gVim
22:16:48 <ozy`> the indentation model is pathological for non-ALGOL-style languages
22:16:59 <pumpkin> ozy`: true
22:18:20 <Quylui> Is there an emacs release for Vista?
22:18:23 * Quylui ducks
22:18:37 <Quylui> I'm googling it, can't find a link.
22:18:55 <ozy`> Quylui: emacs will run on any platform, even those with no OS
22:19:10 <ozy`> I run emacs on my neighbor's dog
22:19:27 <ivanm> ozy`: not all.... I don't think it will run on microcontrollers, etc.
22:19:29 <wli> Some claim that emacs is an OS. I ask where its device drivers are.
22:19:39 <ozy`> however, emacs is still abusive and unusable
22:20:11 <ivanm> Quylui: 22.3 is meant to be available for Vista
22:20:11 <BMeph> Quylui: Is there something wrong with Notepad++? I use it often (TBH, I use it more for its coloring than tabbing).
22:20:16 <wli> Eighty Gigabytes And Continually Swapping? ;)
22:20:16 <ivanm> @slap ozy`
22:20:16 * lambdabot activates her slap-o-matic...
22:20:17 <ivanm> ;-)
22:20:21 <ozy`> I await the day when a usable interface (a la vim) is attached to a non-unusable ouch
22:21:14 <wli> Lambdabot is a woman?
22:21:26 <tehgeekmeister> wli: yes.
22:21:27 <Quylui> BMeph, not at all, I just wanted to hear the opinions of some more experienced users, perhaps regarding issues I'll have in the future. I really wouldn't know the difference.
22:21:32 <rwbarton> @vixen a/s/l
22:21:33 <lambdabot> 19/f/California
22:21:50 <Quylui> I began coding *today*.
22:21:51 <wli> I hope not a genetic one.
22:22:00 <jsn> weird
22:22:01 <ivanm> ozy`: since when did vim have a usable interface?
22:22:17 <jsn> ivanm: i think it is usable if you know it
22:22:20 <wli> ivanm: vim has an interface?
22:22:29 <jsn> ivanm: i mean, i actually love vimperator
22:22:36 <Chile`> ouch, where's the vim love?
22:22:39 <ozy`> vim has a highly usable interface to an unusable program
22:22:40 <tehgeekmeister> wli: yes, vim has an interface.
22:22:48 <ozy`> in reality all text editors are unusable
22:22:49 <ivanm> jsn: yes, if you know it
22:22:56 <jsn> i think vim could be expanded to be a file explorer
22:22:59 <ozy`> some are just less unusable than others
22:23:05 <wli> That's horrible. I'm porting nvi to cygwin now.
22:23:10 <Chile`> jsn: vifm, there already is :)
22:23:18 <jsn> Chile`: neat
22:23:23 * tehgeekmeister recommends ed
22:23:26 <ivanm> ozy`: oh? anyone who knows the basics of a WIMP system can navigate their way around simple ones like notepad, leafpad, mousepad, etc.
22:23:30 <jsn> ivanm: i think vim could be better segmented
22:23:38 <Chile`> segmented?
22:23:44 <wli> tehgeekmeister: ed(1) is, after all, the standard UNIX editor.
22:23:59 <jsn> the abundance of stream manipulation functions, numeric functions, &c.
22:24:01 <tehgeekmeister> wli: yep!  how can you argue with the standard.
22:24:09 <ozy`> ivanm: if you have to use the mouse, the program is unusable
22:24:09 <jsn> it's all just lumped in there together
22:24:28 <ivanm> ozy`: ummmm..... you can use the program, hence its usable
22:24:32 <Chile`> ah. true.
22:24:34 <ivanm> it might not be the _most_ usable, etc.
22:24:35 * wli still uses line editors including ed(1) though also ex(1).
22:24:40 <jsn> it should be a language/interface for allocating buffers, loading and storing buffers and passing buffers to and from external commands
22:24:43 <ivanm> but you can indeed use it (on GUI systems)
22:24:57 <ivanm> even emacs at least tells you when it starts up how to exit!
22:25:01 <ozy`> ivanm: I'm using a non-strict definition of unusable
22:25:13 <mbz> wli: how do you use ed? only for scripting or not?
22:25:17 <ivanm> which means?
22:25:18 <ozy`> arguably, my definition is unusable
22:25:22 <ivanm> lol
22:25:23 <pumpkin> okay, enough euler for today
22:25:31 <Chile`> ivanm: doesn't the vim intro screen give instructions now?
22:25:33 <Axman6> pumpkin: i am now
22:25:40 <wli> mbz: For text editing when I'm fed up with "visual" editors going berserk.
22:25:40 * Chile` has the intro screen turned off, so can't check
22:25:43 <pumpkin> Axman6: solved the one I was going to ask you about :)
22:25:48 <Axman6> ah
22:25:51 <Axman6> which one?
22:25:55 <pumpkin> 108
22:25:56 <jsn> you know, though, the actual stream functions should be kept
22:25:58 <ivanm> Chile`: no idea, I don't have vim installed here
22:26:04 <Chile`> ivanm: lies:  type  :q<Enter>               to exit
22:26:12 <Chile`> :intro confirms it :)
22:26:20 <ivanm> Chile`: yes, but when I first ran vim I had no idea what to do to exit!
22:26:21 <Axman6> ivanm: my RWH shipped today!
22:26:22 <jsn> vim would then be interactive sed with buffer management
22:26:28 <ivanm> Axman6: \o/
22:26:34 <jsn> \o/
22:26:37 <ozy`> ivanm: seriously, though, if you spend more time operating the interface of the program than producing output, I consider it unusable
22:26:42 <ivanm> Axman6: so you'll be getting it end of next week?
22:26:51 <wli> jsn: eh? sed(1) is already interactive and already has buffer management.
22:26:53 <Axman6> pumpkin: ah right, yeah that one was annoying
22:27:01 <ivanm> ozy`: customisation is only worth it if you're going to be using that app often
22:27:03 <jsn> wli: it's only got a hold buffer
22:27:10 <pumpkin> Axman6: yeah it was taking forever but I figured out how to do it efficiently
22:27:16 <tehgeekmeister> ozy`: i'd say i spend the majority of my time in vim producing output, very little time fighting vim itself.
22:27:30 <Chile`> ozy`: once you get used to it, its easier to use the vim navigation than mouse or arrow keys in other editors
22:27:34 <Axman6> pumpkin: care to share? i can;t remember how i did it (i'll check, probably used Rationals)
22:27:35 <ozy`> tehgeekmeister: which is why I said the interface to vim is usable ;)
22:27:36 <jsn> wli: and it's not really interactive in the sense that you can start it up, load a few files, see what it does, save them or no...
22:27:45 <Chile`> ozy`: and quick things like dd save a massive amount of time.
22:27:47 <tehgeekmeister> ozy`: oh, sorry, i lost track of the sides
22:27:48 <Axman6> ivanm: yeah they said between the 29th and the 1st
22:27:53 * Chile` shrugs
22:27:53 <jsn> ozy`: really, it's a fine tool
22:27:58 <ozy`> Chile`: .... I'm advocating vi-keys, criticizing emacs :p
22:28:02 <jsn> i think i would have agreed with you once
22:28:12 <ivanm> Axman6: well, mine came a day early.... so you might be lucky as well!
22:28:20 <jsn> i mean, i started coding with subethaedit, on macintosh
22:28:25 <ivanm> (though a day early would make it arrive on Sunday... so I doubt it)
22:28:27 <pumpkin> Axman6: I was using rationals at first, but that only got me some of the way... it really boils down to a good way of computing the divisor function in the end (and using it to make the divisor function do what you want)
22:28:32 <Chile`> use viper for emacs, then you get the best of both worlds ;)
22:28:38 <jsn> so needless to say, i had to undergo some evolution before i could appreciate vim
22:28:40 <ozy`> jsn: I started coding in clarisworks. no joke.
22:28:46 <jsn> wow
22:29:06 <jsn> ozy`: what did you write in ClarisWorks?
22:29:13 <jsn> applescript?
22:29:14 <ivanm> ozy`: as in the word processor?
22:29:16 <ozy`> duke nukem 3D mods
22:29:16 <Quylui> Emacs doesn't appear to handle haskell code very well. Then again, I have no idea what I'm talking about.
22:29:29 <pumpkin> Axman6: I can give you more info if you want it in pm, but it's a fun one to do efficiently
22:29:30 <ozy`> ivanm: yep. saved as plain text.
22:29:50 <jsn> i am introducing a friend to programming over break
22:29:53 <Chile`> I really only use emacs for tex these days. vim just doesn't cut it for natural text.
22:30:00 <solrize> i use haskell-mode.el, works nice
22:30:01 <sclv> emacs has the best haskell mode around.
22:30:07 <jsn> and at first i was like, let's use HaXE and do some cool flash stuff
22:30:14 * tehgeekmeister started coding in (q/gw)basic.  as i remember qbasic had it's own editor...
22:30:15 <jsn> and i found a mac editor that was nice and all that
22:30:16 <shapr> I like Emacs and Vi... as long as I'm writing haskell!
22:30:22 <mgsloan> hmm, so I've just finished modifying Text.Highlighting.Kate to allow incremental highlight updating (by caching context).. should I email the author (John Macfarlane) a patch?
22:30:25 <jsn> but then i thought, hmmm, no
22:30:25 <tehgeekmeister> shapr: win.
22:30:27 <Axman6> ozy`: wow, respect
22:30:38 <Axman6> jsn: what do you use now? (sorry if i missed it)
22:30:38 <wli> I started coding with vi on a Sequent Symmetry 2000, using a Sun IPC with a monochrome display as a terminal. My first program was computing the gamma function at complex arguments via parallel evaluation of the infinite product expansion of the complex gamma function (I was not yet aware of Lanczos' expansion).
22:30:42 <sclv> anything with tabs as spaces is good enough for haskell, actually.
22:30:42 <jsn> let's use "The UNIX Programming Environment"
22:30:43 <shapr> Sadly, I spent 66 hours last week writing C#
22:30:54 <jsn> Axman6: i use MacVim
22:30:55 <sclv> tiny code = editor matters less.
22:30:56 * Axman6 hugs shapr 
22:30:59 <Quylui> sclv: true, but it doesn't seem to have syntax highlighting.
22:31:00 <mbz> pumpkin: problem 108 looks like a diophantine equation, doesn't it?
22:31:09 <shapr> Axman6: Thanks, I needed that :-)
22:31:12 <sclv> nope, it has great syntax highlighting if you turn it on.
22:31:19 <sclv> you just need to install haskell mode.
22:31:26 <Quylui> Can it be done on windows?
22:31:30 <sclv> yep!
22:31:45 <Quylui> I'm currently reading the instructions... they appear to be writting for a linux os.
22:31:45 <pumpkin> mbz: it is, but just "solving" it without taking advantage of special structure won't get you very far I don't think (I couldn't see how to, anyway)
22:31:49 <shapr> Quylui: Yeah, I've done it.
22:31:52 <wli> Well, I did do a one-off Runge-Kutta affair in BASIC on a PC at some point earlier but it had no connection to sustained programming activity.
22:31:53 <jsn> so i think we'll actually start editing with vim
22:31:56 <shapr> I'm using EmacsW32 on Windows XP at work.
22:32:04 <sclv> all emacs modes are portable
22:32:10 <jsn> to get in the mentality of programming to even start programming
22:32:11 <ozy`> Quylui: emacs predates windows' existence
22:32:13 <sclv> emacs is its own platform
22:32:20 <Axman6> i use TextMate for all my coding. its haskell bundle could do with improving, but i don't mind it
22:32:25 <Quylui> written* btw
22:32:52 <ozy`> Axman6: textmate's haskell bundle is abysmal. pretty colors, no brains.
22:32:55 <tehgeekmeister> Axman6: i love textmate, but you're right about the haskell bundle
22:33:00 <Axman6> the only snippet i use is mod<tab> to get module Main where \n\m main = putStrLn "Hello world"
22:33:03 <Quylui> sclv: Could I do it?
22:33:06 <shapr> ozy`: Hey, everybody gets to use what they like.
22:33:08 <sclv> yep!
22:33:29 <Axman6> shapr: nah ozy` is pretty right about TM's haskell bundle :P
22:33:32 <sclv> you just need to put the haskell-mode files wherever you like, and add the requisite lines with the appropriate path to them to your .emacs file
22:33:33 <Quylui> But it doesn't seem very simple. I don't even know what an init file is.
22:33:38 <shapr> Well, I've never tried it...
22:33:41 <Axman6> i like it anyway though, TM is a nice editor
22:33:44 <Quylui> See, I don't know how to do that. :\
22:33:53 <wli> ozy`: I could say the same of vim's Haskell syntax highlighting. It goes berserk with unterminated string literals.
22:34:08 <ozy`> shapr: I've tried to implement haskell indentation for TM. when I realized I'd have to parse the entire file every time the user hit tab, I gave up.
22:34:15 <shapr> ozy`: ouch
22:34:21 <tehgeekmeister> Axman6: my only complaint about tm is that it doesn't have the ability to jump around the file nicely via keyboard, like emacs/vim
22:34:29 <tehgeekmeister> Axman6: or if it does i didn't know about it
22:34:36 <shapr> Has anyone here tried acme for real programming?
22:34:39 <Axman6> tehgeekmeister: jump how?
22:34:55 <wli> 24j
22:35:02 <jsn> i have some vimscript for generating a haskell module name from the current file name, lining up =, <-, ::, -> and it has command completion
22:35:05 <tehgeekmeister> Axman6: equivalent stuff to 20j or 5e in vim, jumping multiple lines/words/etcetera
22:35:10 <wli> 13wc$
22:35:21 <tehgeekmeister> wli: what does that one do?
22:35:22 <Axman6> ah, sounds nice
22:35:42 <wli> % is my favorite vi (not vim) movement key.
22:35:42 <ozy`> tehgeekmeister: there are a few obscure keyboard shortcuts, and there's a (very buggy, incomplete) open source plug-in to make it have a vi-like interface
22:36:14 <shapr> The only thing that confuses me about vim is that the commands aren't commutative. I expect :wq to be the same as :qw
22:36:18 <wli> tehgeekmeister: Move 13 words right, then edit from the cursor to the end of the line.
22:36:42 <dmwit> 13wC
22:36:44 <tehgeekmeister> wli: oh!  i was only aware of cw, you can use a different target for the end of the space to edit?
22:36:46 <jsn> shapr: it really should be    w >> q
22:36:53 <dmwit> tehgeekmeister: any motion
22:37:01 <shapr> jsn: Oh, that does make sense.
22:37:10 <wli> tehgeekmeister: Yes. c% edits between matching braces, for instance.
22:37:17 <sjanssen> shapr: why should they be commutative?
22:37:19 <jsn> mim  --   monadic vim
22:37:26 <tehgeekmeister> jsn: lul
22:37:42 <shapr> sjanssen: I guess I see them as a batch of commands to execute, until jsn just pointed out that they ordered.
22:37:52 <Axman6> ooo, didn't know TM had hoogle integration :)
22:37:52 <shapr> are*
22:38:06 <tehgeekmeister> Axman6: it does?!  nice!
22:38:17 <Axman6> tehgeekmeister: ctrl-shift-h :)
22:38:39 <jsn> when mac applications do something, they tend to do it right
22:39:02 <Axman6> jsn: well, depends on the developer
22:39:07 <wli> When UNIX applications do something...
22:39:20 <jsn> let's hope they do it on the command line
22:39:24 <Axman6> a lot of the Adobe stuff feels terrible to me (though i have never used it enough)
22:39:27 <jsn> or not at all :)
22:39:44 <Quylui> sclv: do you mind lending a hand here? I kinda want to see this working.
22:39:59 <sclv> you have to find out where your .emacs file is and edit it.
22:40:07 <ozy`> Axman6: I'm sure that's partly because it's all written with a windows slant
22:40:12 <Quylui> Yeah... I can't find it :(
22:40:13 <mae> Can someone explain why I get an exception here? I am trying to read a string into a bytestring
22:40:14 <mae> http://haskell.pastebin.com/m429cccf2
22:40:16 <Axman6> ozy`: indeed
22:40:20 <sclv> its usually in programs and docments/yourname/program settings.
22:40:21 <Quylui> Nor would I know what to do if I could.
22:40:50 <jsn> > empty :: ByteString
22:40:51 <lambdabot>       Ambiguous occurrence `empty'
22:40:51 <lambdabot>      It could refer to either `Text.Pretty...
22:40:57 <sclv> you edit it to put in the lines that the documentation tells you to.
22:41:03 <sclv> you find it by reading the emacs documentation.
22:41:13 <jsn> > Data.ByteString.empty
22:41:14 <lambdabot>   ""
22:41:19 <ozy`> Adobe writes its apps for an API, which in turn interfaces (via their own translation layer) to platform-specific (mac or windows) APIs
22:41:20 <Quylui> Emacs doesn't appear to be installed; rather, I'm running it from a file on my desktop
22:41:22 <jsn> > show Data.ByteString.empty
22:41:23 <lambdabot>   "\"\""
22:41:33 * tehgeekmeister is sad that  his wikipedia dump importer didn't end up beating the perl version
22:41:44 <jsn> > read "\"\"" :: ByteString
22:41:45 <lambdabot>       Not in scope: type constructor or class `ByteString'
22:41:47 <Axman6> tehgeekmeister: :(
22:41:56 <Axman6> tehgeekmeister: got to keep working on it then!
22:42:03 <jsn> > read "\"\"" :: Data.ByteString.ByteString
22:42:05 <lambdabot>   ""
22:42:11 <tehgeekmeister> Axman6: i think it's because i'm doing a lot of boxing/unboxing
22:42:17 <jsn> mae: you need to put in quotes
22:42:21 <Axman6> tehgeekmeister: fix it!
22:42:25 <mae> ok so .. thats a bit confusing .. empty is a type?
22:42:40 <mae> ahh
22:42:40 <sclv> http://www.gnu.org/software/emacs/windows/Installing-Emacs.html#Installing-Emacs
22:42:45 <jsn> mae: no, empty is the empty ByteString
22:42:48 <sclv> that tells you where init files go
22:42:56 <sclv>     (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
22:42:57 <sclv>     (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
22:43:02 <jsn> mae: it is the easiest one to experiment with
22:43:05 <sclv> Those are the two lines you stick in it.
22:43:09 <mae> jsn, so what is the best way to simply convert a string literal or haskell string into a bytestring
22:43:15 <jsn> > read "Foo" :: String
22:43:16 <lambdabot>   "* Exception: Prelude.read: no parse
22:43:22 <Axman6> i should play more with Vim, i quite liked it
22:43:24 <sclv> oh, sorry, first you put in this:     (load "~/lib/emacs/haskell-mode/haskell-site-file")
22:43:30 <jsn> > read "\"Foo\"" :: String
22:43:31 <lambdabot>   "Foo"
22:43:33 <sclv> with the appropriate path, that is.
22:43:38 <ozy`> Axman6: I highly recommend it
22:43:39 <rwbarton> mae: pack
22:43:44 <weakish> Quylui: c:\Documents and Settings\user\Application Data\.emacs or _emacs
22:43:49 <jsn> if it's not quoted, it doesn't look like a string
22:43:55 <tehgeekmeister> Axman6: but that's not my real project; this was just a script to load up the data so i could start my real project.  it'd be silly to focus on the importer now.  i might play with it more later, tho -- it'd be fun to see if i can make it a lot faster without getting rid of the high level feal.
22:43:57 <tehgeekmeister> *feel
22:44:00 <ozy`> the only thing I really miss from textmate is the scope system
22:44:03 <jsn> mae: look at Data.String.ByteString.Char8
22:44:10 <mae> rwbarton, for a lazy bytestring it requires a Word8 not a string
22:44:12 <jsn> mae: it should have a "fromString"
22:44:31 <Quylui> Ah, thank you, sclv. I was looking for that.
22:44:32 <rwbarton> mae: Data.ByteString.Lazy.Char8.pack then
22:44:37 <jsn> oh wait, maybe that is in Data.ByteString.UTF8
22:44:37 <mae> jsn, ok then, if i use Char8 -- how do i get that to a lazy bytestring?
22:44:38 <mae> ahh
22:44:46 <sclv> glad to help.
22:44:49 <rwbarton> mae: or, something more unicode-savvy, yeah
22:45:07 <mae> rwbarton, what is more unicode savvy?
22:45:13 <jsn> check out the package UTF8 string
22:45:14 <rwbarton> mae: beats me
22:45:18 <mae> : )
22:45:21 <jsn> @where utf8-string
22:45:21 <lambdabot> I know nothing about utf8-string.
22:45:24 <jsn> bah
22:45:40 <jsn> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
22:46:24 <jsn> here you go
22:46:25 <jsn> http://hackage.haskell.org/packages/archive/utf8-string/0.3.3/doc/html/Data-ByteString-Lazy-UTF8.html
22:46:40 <tehgeekmeister> how much deforestation does ghc do for you automatically?  any?
22:46:52 <mae> um
22:47:24 <mae> rwbarton, so uh, can I use the Data.ByteString and Data.ByteString.Lazy libraries interchangeably on the datatype?
22:47:49 <rwbarton> mae: Data.ByteString and Data.ByteString.Lazy export different types both called ByteString
22:47:49 <sjanssen> tehgeekmeister: certain functions will fuse with -O, see the GHC handbook for more details
22:48:24 <rwbarton> mae: they are not interchangeable.  Sometimes the haddock documentation is confusing, because it doesn't show the qualified names
22:48:50 <mae> haddock doesn't even show Lazy.Char8
22:49:14 <mae> ahh nm
22:50:50 <Quylui> sclv, mind if I pm you?
22:51:03 <Quylui> I can't seem to figure this out.
22:51:12 <sclv> sorry, turning in for the night, you'll need to find someone else to help. :-(
22:51:17 <Quylui> alright
22:51:22 <Quylui> no worries
22:51:28 <Axman6> Quylui: what's the problem?
22:51:48 <Quylui> Axman6, i'll try google real quick, but i'm trying to get emacs' haskell mode on windows
22:51:54 <Axman6> ah
22:52:04 <Axman6> right, yeah nothing i know about ;_
22:52:07 <Axman6> ;)*
22:54:06 <Quylui> Me neither which is exactly the problem.
22:56:35 <jdrake> If there were an opposite operation to 'cons' what would it be called?
22:56:48 <dmwit> snoc
22:56:48 <Axman6> head?
22:56:49 <dmwit> tail
22:56:51 <dmwit> head
22:56:55 <dmwit> These are all options.
22:57:09 <rwbarton> uncons
22:57:11 <rwbarton> list
22:57:15 <vegai> oppositeOfCons
22:57:25 <Axman6> -cons
22:57:27 <loop> dest? :)
22:57:32 <dmwit> jdrake: You'll have to narrow down the behavior a bit more before we can give a correct answer. =)
22:57:33 <Axman6> pros
22:57:52 <loop> CONStruct, DESTruct :P
22:58:01 <Axman6> pros and cons, obviously
22:58:06 <jdrake> hmm
22:58:10 <dmwit> loop: Just "des," then. ;-)
22:58:17 <loop> dmwit: well yes :)
22:58:28 <BMeph> @go haskell-mode
22:58:30 <lambdabot> http://www.haskell.org/haskell-mode/
22:58:30 <lambdabot> Title: Haskell Mode for Emacs
22:58:33 <dmwit> ?go go go!
22:58:36 <lambdabot> http://www.scienceagogo.com/
22:58:36 <lambdabot> Title: Science News, Research And Discussion
22:58:41 <gray> go
22:59:07 <vegai> hmm, how well does that
22:59:07 <vegai> 2
22:59:20 <vegai> ... emacs + unicode + haskell-mode thing work?
22:59:31 <jdrake> I think I have a solution to my problem.
23:00:03 <Axman6> jdrake: what was the actual behaviour you were after?
23:00:11 * rwbarton learned today that the let layout-thingy works in list comprehensions
23:00:43 <Quylui> Apparently quite well. Is .emacs.d a folder or a file? Presumably it's a file, and yet all I can find is a .emacs.d folder...
23:01:01 <jdrake> Axman6, It was a push, but the predefined word for it (in the particular language that shall go unnamed) didn't quite work the way I wanted.
23:01:25 <loop> Quylui: folder
23:01:27 <dmwit> "word"... sounds like factor or forth or whatever that f one is
23:01:36 <loop> Quylui: .emacs is the initialization file
23:01:44 <dmwit> jdrake: You need a Hoogle for that language. =)
23:01:54 <jdrake> dmwit, you are quite correct
23:02:04 <Quylui> I figured as such. I need to edit it to recognize my haskell-mode files.
23:02:21 <jdrake> push is like ( n seq -- ) when I want ( n seq -- seq ); so I just did my own word for it :P
23:02:22 <Axman6> pumpkin: had any fun easy problems?
23:02:30 <Quylui> Though step 1, i.e. locating it, has yet to consummate.
23:02:36 * tehgeekmeister just realized he might be able to turn his parser into a fold
23:02:42 <pumpkin> Axman6: hmm, can't even remember which ones I did recently
23:02:42 <jdrake> I just thought some training in RPN sort of mode might be of use.
23:02:52 <pumpkin> Axman6: the tetration one, but I think you had that one
23:03:04 <Axman6> pumpkin: what sort of comp sci experience do you have anyway?
23:03:17 <Axman6> yeah i did the tetration one, with help. it sucked -_-
23:03:22 <jdrake> Haskell is a little bit more complicated than factor is, but the experience is surprisingly similar.
23:03:41 <pumpkin> Axman6: a BS (bullshit) degree in it
23:03:50 <pumpkin> actually, I think it's technically an AB :P
23:03:57 <Axman6> AB?
23:04:23 <Axman6> i'm hoping that by the end of uni, project euler problems will be a lot easier :P
23:04:30 <pumpkin> Artium Baccalaureus, supposedly
23:04:40 <Axman6> righto
23:04:41 * jeffwheeler wonders whether #haskell has the highest percentage of PhDs of any irc room.
23:04:42 <vegai> awww, terminus doesn't have the unicode ::
23:04:53 <pumpkin> jeffwheeler: probably :P
23:05:13 <Axman6> i was watching the google tech talk on factor, it didn't look very impressive to me
23:05:56 * luqui wonders about #math
23:05:59 <vegai> are there any good more unicody coding fonts than terminus?
23:06:07 <pumpkin> Axman6: 72 isn't too bad
23:06:46 <Axman6> not loading -_-
23:06:52 <Axman6> i hate our internet
23:06:53 <pumpkin> yeah, same here :(
23:06:56 <pumpkin> oh it loaded
23:07:09 <jdrake> Axman6, I haven't seen any tech talk on factor but I can say that initial impressions are what I expected.
23:07:19 <Quylui> loop: .emacs simply does not seem to exist.
23:07:50 <Axman6> pumpkin: yeah my answer for that was not pretty
23:08:50 <Axman6> pumpkin: oh, actually, that's not the one i've done, heh
23:08:53 <loop> Quylui: just create it, then :)
23:09:02 <pumpkin> Axman6: 87 also isn't too painful, and doesn't look like you've done it
23:09:02 <loop> Quylui: M-x customize propably creates it too
23:09:14 <loop> speaking of emacs, does anyone use etags with haskell?
23:11:01 <Quylui> loop: what do you mean M-x? (excuse my ignorance)
23:11:09 <mbz> alt-x
23:11:27 <mbz> C-x -> control-x
23:11:28 <mbz> etc
23:11:36 <Quylui> ok
23:12:31 <Quylui> Should my .emacs.d folder be empty? (not including save files)
23:12:49 <loop> yes, if you haven't put anything there ;)
23:13:06 * Quylui throws fists to the sky
23:13:17 <Axman6> pumpkin: huh, seems i've written something for 72, but it doesn't seem to relate to the problem at all o.O
23:13:34 <pumpkin> Axman6: it's a mystery! what does your solution appear to be doing?
23:13:58 <Quylui> loop: m-x is undefined.
23:14:16 <Axman6> pumpkin: want to have a look? i'm not sure what answer it would give
23:14:22 <pumpkin> sure
23:14:29 <Axman6> ew, my primes function is awfully inefficient
23:14:43 <pumpkin> Axman6: I use a module called ONeillPrimes to generate mine
23:14:45 <loop> Quylui: oh? should see "M-x" in minibuffer after pressing M-x
23:14:48 <pumpkin> although for 87 you don't need ver ymany
23:15:15 <Axman6> pumpkin: http://hpaste.org/13281
23:15:22 <loop> Quylui: what does emacs say? "M-x is undefined" ?
23:15:26 <Quylui> Found it! Yay!~
23:15:45 <Quylui> That's what it said yea, but I've got it... now to attempt to edit it appropriately.
23:17:43 <Quylui> loop: Now, do I just cut-paste the lisp strings into the .emacs file, or do they need to be modified in any way?
23:17:56 <loop> Quylui: just c&p
23:18:37 <pumpkin> Axman6: that looks like another problem, trying to remember which one
23:18:42 <Axman6> yeah
23:18:55 <pumpkin> oh wait, it is 72
23:19:00 <Axman6> is it?
23:19:19 <Axman6> there's a sum there...
23:19:22 <pumpkin> yeah
23:19:35 <Axman6> hmm, let me see if i can follow what i did :P
23:19:48 <Axman6> i have a feeling it's not very efficient
23:20:06 <pumpkin> you did it pretty similarly to mine, but your primes and your length . coprimes are definitely not as efficient as they could be :P
23:20:15 <Axman6> indeed
23:21:12 <Quylui> loop: I broke emacs.
23:21:19 <loop> Quylui: :(
23:21:31 <Chile`> error?
23:21:32 <Axman6> pumpkin: well luckily, i'm not using primes at all in it XD
23:21:36 <ozy`> Quylui: use vim to edit your .emacs file
23:21:39 <ozy`> to fix it
23:21:43 <Quylui> -.-
23:21:50 <Axman6> use notepad!
23:21:53 <Chile`> emacs is never really dead, it just spews errors at you if you mess something up
23:21:59 <Chile`> but yes, I do in fact use vim to edit my .emacs :p
23:22:16 <pumpkin> Axman6: oh you're right :) but length . coprimes has a name and there's more efficient ways to compute it :) check http://www.polyomino.f2s.com/david/haskell/numbertheory.html for helpful code
23:22:28 <tehgeekmeister> can you fold over IO actions?
23:22:33 <Axman6> cheers :)
23:22:37 <tehgeekmeister> you'd just need to use lift somewhere, right?
23:22:50 <tehgeekmeister> err
23:22:51 <tehgeekmeister> wait
23:22:51 <tehgeekmeister> no
23:22:54 <loop> Chile`: vim doesn't have "evaluate buffer in emacs" -feature :P
23:23:38 <tehgeekmeister> i'm thinking of something like foldl :: a -> (a -> IO b) -> [IO b]
23:23:38 <Chile`> its true. but I don't remember the keystroke for it, so its faster to edit it in vim & restart emacs :P
23:23:46 <Axman6> pumpkin: happen to know which function length.coprimes is? :\
23:24:04 <Quylui> is this correct? (load "C:\Program Files\emacs-22.3\haskell-mode\haskell-mode.el")
23:24:11 <Quylui> for the "load" command
23:24:19 <pumpkin> it's called eulerTotient in the code on that site :) or euler's totient function, or phi(n)
23:24:47 <Axman6> ah i see, thanks :)
23:25:39 <Quylui> Here are the instructions, pastebinned: http://pastebin.ca/1292111
23:25:50 <Chile`> Quylui: I usually use (setq load-path (append load-path '("/my/path/to/whatever"))) firs
23:26:45 <Quylui> Chile`, I wouldn't know the difference.
23:26:49 <loop> Chile`: (add-to-list 'load-path "whatever") is shorter =)
23:27:00 <Quylui> I'm just trying to get this to work. I'll try it your way
23:27:53 <Chile`> loop: so it is. I'm lisp-retarded though :)
23:28:27 <Chile`> loop: I use emacs for latex and that's about it. over the years I've managed to make it work roughly as I like it, but I regard the .emacs file as some sort of black magic
23:28:34 <Axman6> pumpkin: is there an easy to install this stuff?
23:28:52 <pumpkin> Axman6: I just downloaded all his .hs files and put them somewhere handy, and run ghci off of them :P
23:29:04 <pumpkin> I should probably do it more nicely, but I don't think it's on cabal
23:30:11 <Quylui> loop: i didn't get any errors when I loaded emacs, does that mean it was done correctly?
23:30:35 <Quylui> Also, it doesn't appear that syntax highlighting is enabled.
23:30:43 <loop> try M-x haskell-mode
23:31:04 <jeffz`> Quylui: if syntax highlighting isnt on but haskell-mode is, M-x font-lock-mode
23:31:28 <Quylui> How do I verify that haskell-mode is on
23:31:37 <jeffz`> Quylui: load a .hs file
23:31:37 <cjb> look in the bottom bar
23:31:56 <Quylui> jeffz`, done.
23:32:05 <Quylui> cjb, I don't see anything indicative.
23:32:33 <Quylui> loop: M-x haskell-mode [no match]
23:33:02 <Quylui> I must have done something incorrectly.
23:33:15 <loop> Quylui: do you have (load "haskell-mode.el") ?
23:33:25 <loop> Quylui: or do you only add the directory to the load path? :)
23:33:44 <Quylui> here's my emacs file pastebinned http://pastebin.ca/1292114
23:34:02 <procyon112> Does anyone know how Cabal gets it's default datadir?
23:34:04 <Quylui> and the instructions, again http://pastebin.ca/1292111
23:34:15 <loop> Quylui: add (load "haskell-mode.el")
23:34:20 <Quylui> to where?
23:34:27 <loop> Quylui: after the add-to-list -line
23:34:40 <loop> Quylui: so you first add the directory to the load path and then load the file
23:35:19 <Quylui> Got an error: "cannot open haskell-mode.el"
23:36:09 <loop> Quylui: oh, the add-to-list -line is incorrect
23:36:10 <Quylui> more accurately: "cannot open load file, haskell-mode.el
23:36:14 <strht> > hmm (foldr (+) 1 hhm)
23:36:15 <lambdabot>   Couldn't match expected type `[a]'
23:36:24 <strht> uhh
23:36:39 <loop> Quylui: you should have (add-to-list 'load-path "directory where haskell-mode.el is")
23:36:40 <strht> > etc
23:36:42 <lambdabot>   * Exception: EXCEPTION!!!! EXCEPTION!!!!
23:36:45 <Quylui> Ah
23:37:46 <Quylui> Same error.
23:38:03 <Quylui> File error: cannot open load file, haskell-mode.el
23:38:06 <strht> > hmm 42
23:38:07 <lambdabot>   [42.0,6.480740698407857,-29.038518603184286,-64.55777790477643,-100.0770372...
23:38:15 <strht> oo
23:38:17 <strht> pretty
23:38:26 <strht> look at it!
23:38:57 <strht> > hmm (foldr (+) 1 (take 25 (hhm 2))
23:38:59 <lambdabot>   <no location info>: parse error on input `;'
23:39:06 <strht> > hmm (foldr (+) 1 (take 25 (hhm 2)))
23:39:08 <lambdabot>   [351.0,18.73499399519517,-313.53001200960966,-645.7950180144145,-978.060024...
23:39:37 <Quylui> loop: http://pastebin.ca/1292116
23:40:07 <loop> Quylui: does it work?
23:41:23 <Quylui> Not currently. I feel like I'm missing something simple. Like, maybe I'm not loading the right file?
23:41:29 <mbz> @hoogle termios
23:41:30 <lambdabot> System.Posix.Internals type CTermios = ()
23:42:02 <Quylui> I know that the files aren't corrupted.
23:43:10 <jeffz`> gee, your paste site is slow Quylui
23:43:21 <jeffz`> not loading for me
23:43:45 * jeffz` dies of old age
23:43:53 <Quylui> Hah, I'm sorry. Got an alternative?
23:43:59 <Quylui> hpaste perhaps?
23:44:06 <jeffz`> yeah, hpaste
23:44:24 <jeffz`> oh, its back now, maybe you need to use \\ as the path seperator in your string
23:44:30 <jeffz`> \ escaping \ or so...
23:45:41 <strht> i'm approaching the point where haskell is more concise for me than english :(:(:(
23:47:31 <strht> well
23:47:34 <strht> time to kill myself
23:48:43 <Quylui> loop: I thought that it might be because I was using haskell-mode.el instead of haskell-site-file.el like in the tutorial. However, adjusting that still did not change the error. Emacs will not process the files.
23:49:55 <loop> hmm, does emacs lisp need some funky escaping for \ in strings
23:50:18 <rwbarton> you should be able to just use a / instead
23:50:34 <Quylui> The README says otherwise. I feel like this should be extremely simple.
23:51:14 <Quylui> It should be (load "file location") correct? (assuming the right file is located)
23:52:12 <gnman> so how is haskell?
23:52:16 <gnman> hows it going folks
23:52:47 <gnman> haskell web broswer coming soon?
23:52:53 <gnman> haskell dns server?
23:53:01 <gnman> haskell distributed filesystem?
23:53:13 <gnman> clone of world of warcraft done in haskell?
23:53:16 <loop> any day now.
23:53:58 <gnman> haskell based distributed databse?
23:54:20 <Quylui> creating a GUI interface in Visual Basic... in haskell?
23:54:50 <gnman> any cool irc clients in haskell?
23:54:54 <gnman> I am on netbsd
23:54:56 <gnman> :)
23:55:27 <Cale> Quylui: Well, there's Glade which you can use with Gtk2Hs :)
23:55:31 <gnman> I love free software
23:55:43 <wli> "MR. THE RAT: CAN YOU HELP ME RUN NETBSD? I WANT TO RUN INTERNET EXPLORER!"
23:56:04 <wli> etc.
23:56:21 <gnman> theo is openBSD
23:56:26 <gnman> duhhh
23:56:49 <wli> Internet Explorer isn't OpenBSD either. ;)
23:57:01 <blackh> gnman: I feel so mainstream! I am on Ubuntu.
23:57:03 <wli> gnman: It *was* in quotes.
23:58:18 <mbz> @typ openFd
23:58:21 <lambdabot> Not in scope: `openFd'
23:58:25 <mbz> @hoogle openFd
23:58:25 <lambdabot> No results found
23:58:30 <mbz> rawr
23:58:38 <Quylui> loop are we giving up?
23:58:39 <vegai> somebody wrote a filesystem already, not sure if it was distributed
23:58:52 <vegai> and happs-state is quite close to being a distributed db in some sense
23:59:08 <loop> Quylui: did you try changing \ to / ?
23:59:09 * vegai swallows the bait and hook
