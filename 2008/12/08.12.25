00:05:35 <procyon112> Any cabal gurus around?
00:06:12 <vixey> haskell!
00:06:56 <pumpkin> vixey!
00:07:21 <mbz> pumpkin!
00:08:42 <vixey> oh here's a puzzle for anyone
00:08:56 <vixey> (I couldn't get it)
00:09:12 <vixey> Is it possible to write a hetro-variadic function without typeclasses?
00:09:39 <vixey> something like   foo (X 3) (X "foo") (X True) ~~> (3, ("foo", (True, ())))
00:09:53 <vixey> doesn't have to be exactly that but that's the idea
00:10:25 <Olathe> I think there's dynamic typing.
00:10:34 <Olathe> @hoogle dynamic
00:10:35 <lambdabot> module Data.Dynamic
00:10:35 <lambdabot> Data.Dynamic data Dynamic
00:10:35 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
00:10:38 <vixey> no not dynamic typing
00:10:41 <Olathe> Oh.
00:10:46 <vixey> cheating :p
00:10:53 <Olathe> Like varargs ?
00:10:56 <vixey> also Dynamic uses typeclasses
00:11:00 <Olathe> Ore what ?
00:18:16 <Saizan> vixey: the set of types must be open?
00:18:58 <Saizan> i guess so, since you could just extend the homo-variadic gadts with more constructors if not
00:19:00 <vixey> Saizen, can't see why closed would make a different without typeclasses
00:19:33 <Saizan> "Saizan" btw
01:19:56 <mornfall> Ho-hum. Is there a portable variant of getProcessID?
01:24:29 <Gracenotes> I forget -- how does one get the infixity of an operator in ghci?
01:24:43 <Lemmih> Gracenotes: :i
01:24:49 <centrinia> @info (+)
01:24:49 <lambdabot> (+)
01:24:54 <Gracenotes> thanks
01:25:16 <Gracenotes> ah, among other information
01:28:28 <pumpkin> > let 2 + 2 = 5; a ???? b = a * (2 + 2) * b in 4 ???? 5 -- most useful function ever
01:28:29 <lambdabot>   100
01:28:46 <vixey> I like that name ????
01:29:13 <vixey> and ! is good
01:29:23 <pumpkin> well it helps you define the ???? before profit
01:29:35 <Gracenotes> 5 * 5 * 4 == 100
01:29:35 <centrinia> > let (?????) = unsafePerformIO (randomIO) in (?????)
01:29:36 <lambdabot>   Not in scope: `unsafePerformIO'
01:29:46 <Gracenotes> so it should seem
01:30:35 <Gracenotes> > let 2 + 2 = 100 in 3 - 1 + 2
01:30:35 <centrinia> The most useful pair of functions are const and ap. :)
01:30:36 <lambdabot>   * Exception: /tmp/5784269928216422093:71:68-78: Non-exhaustive patterns in ...
01:30:44 <Gracenotes> oh, heh.
01:30:45 <vixey> LOL
01:31:07 <vixey> @vera logic
01:31:13 <vixey> @w80 logic
01:31:18 <lambdabot> No match for "logic".
01:31:25 <lambdabot> *** "logic" wn "WordNet (r) 2.0"
01:31:25 <lambdabot> logic
01:31:25 <lambdabot>      n 1: the branch of philosophy that analyzes inference
01:31:25 <lambdabot>      2: reasoned and reasonable judgment; "it made a certain kind of
01:31:25 <lambdabot>         logic"
01:31:27 <lambdabot> [5 @more lines]
01:31:52 <vixey> I got sick of this
01:31:54 <Gracenotes> > let 2 + 2 = 100; a + b = a-(0-b) in 3 - 1 + 2
01:31:56 <lambdabot>   0
01:31:57 <centrinia> > let { 2 ?? 3 = 6; x ?? y = x+y; } in [x ?? y | x <- [1..3], y <- [2..4]]
01:31:58 <lambdabot>   [3,4,5,4,6,6,5,6,7]
01:32:07 <vixey> do a <- m; b ; c ; e <- x ; return (comb a e)
01:32:10 <vixey> this kind of pattern
01:32:16 <pumpkin> > run [think, (????), profit]
01:32:17 <lambdabot>   1000
01:32:46 <centrinia> @w80 monad
01:32:47 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
01:32:47 <lambdabot> monad
01:32:47 <lambdabot>      n 1: an atom having a valence of one
01:32:47 <lambdabot>      2: a singular metaphysical entity from which material
01:32:47 <lambdabot>         properties are said to derive [syn: {monas}]
01:32:49 <lambdabot>      [also: {monades} (pl)]
01:32:55 <centrinia> Hmm.
01:33:06 <Gracenotes> > let 2 + 2 = 100; a + b = a-(0-b) in (3 - 1) + 2 --last one
01:33:08 <lambdabot>   100
01:33:12 <Gracenotes> ah, success.
01:33:36 <Gracenotes> something must have happened with the infixity of my + operator :P
01:33:39 <pumpkin> Gracenotes: that's pretty hot
01:33:54 <Gracenotes> and technically that a+b part isn't quite needed...
01:34:08 <pumpkin> it isn't?
01:34:32 <centrinia> > let f x = 2^x in iterate f (1 :: Int)
01:34:33 <lambdabot>   [1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,...
01:34:52 <pumpkin> omg magic
01:34:59 <centrinia> > let f x = 2^x in iterate f (1 :: Integer) -- I hope this doesn't overflow. :)
01:35:00 <lambdabot>   [1,2,4,16,65536,20035299304068464649790723515602557504478254755697514192650...
01:35:08 <pumpkin> what do you expect :P
01:35:15 <Gracenotes> > let 2 + 2 = 100; 2 - 2 = 2 in 2-2+2
01:35:16 <lambdabot>   100
01:35:25 <pumpkin> lol
01:39:07 <centrinia> @let primes = let { sieve (x:xs) = x : sieve [y | y <- xs, (y `mod` x) /= 0] } in sieve [2..]
01:39:08 <lambdabot>  Defined.
01:39:33 <pumpkin> that looks efficient :P
01:39:33 <vixey> @let primes' = extendSequence [2,3,5,7]
01:39:34 <lambdabot>  Defined.
01:39:36 <vixey> > primes'
01:39:38 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
01:39:42 <pumpkin> lol
01:39:52 <vixey> unsafePerformPrimes!
01:40:05 <pumpkin> is there just a special case in extendSequence?
01:40:07 <Gracenotes> > let 2 + 100 = 42; 2 + a = 2 - (a+1); 2 - a = 2 + (a+1) in (2 + 20)
01:40:09 <lambdabot>   * Exception: /tmp/7013112620982275672:71:96-126: Non-exhaustive patterns in...
01:40:15 <Gracenotes> meh
01:40:30 <centrinia> > head $ dropWhile (\x y -> x == y) $ zip primes primes'
01:40:31 <lambdabot>       The lambda expression `\ x y -> x == y' has two arguments,
01:40:31 <lambdabot>      but its...
01:40:45 <centrinia> > head $ dropWhile (\(x,y) -> x == y) $ zip primes primes'
01:40:47 <lambdabot>   * Exception: Prelude.head: empty list
01:40:54 <vixey> @check primes == primes'
01:40:54 <lambdabot>   Not in scope: `primes'Not in scope: `primes''
01:40:58 <centrinia> Hmm. Why is that empty?
01:41:00 <vixey> @scheck primes == primes'
01:41:00 <lambdabot>   Not in scope: `primes'Not in scope: `primes''
01:41:07 <vixey> @quckcheck primes == primes'
01:41:08 <lambdabot> Unknown command, try @list
01:41:13 <vixey> that's rubbish.......
01:41:18 <centrinia> quck. :)
01:41:34 * pumpkin qucks
01:42:38 <Gracenotes> > let m 1000000 = 42; m a = n (a+1); n a = m (a+1) in m 20
01:42:40 <lambdabot>   42
01:43:01 <Gracenotes> > let m 2 1000000 = 42; m 2 a = n 2 (a+1); n 2 a = m 2 (a+1) in m 2 20
01:43:04 <lambdabot>   42
01:43:07 <centrinia> @let (public_n,private_p,private_q) = let (p,q) = (primes !! 1000, primes !! 1042) in (p*q,p,q)
01:43:09 <lambdabot>  Defined.
01:43:34 <Gracenotes> > let (+) 2 1000000 = 42; (+) 2 a = (-) 2 (a+1); (-) 2 a = (+) 2 (a+1) in (+) 2 20
01:43:35 <lambdabot>   * Exception: /tmp/526363653161386477:71:112-152: Non-exhaustive patterns in...
01:44:02 <Gracenotes> hm, I suspect the let statements aren't looking at each other correctly :/
01:44:13 <baaba> (+) 6 4
01:44:28 <Gracenotes> (or in the expected way, given the redefinition of the + and - operators)
01:45:22 <baaba> > let (+) 2 a = 42; (+) a 2 = 54; (+) a b = 66 in 1 + 2
01:45:24 <lambdabot>   54
01:47:26 <centrinia> @let extgcd ((u,v),(a,b)) = if b == 0 then ((u,v),a) else let q = a `div` b in extgcd ((v,u-v*q),(b,a-b*q))
01:47:27 <lambdabot>  Defined.
01:48:55 <vixey> @pl list x = [x]
01:48:55 <lambdabot> list = return
01:48:58 <vixey> @pl list x y = [x,y]
01:48:58 <lambdabot> list = (. return) . (:)
01:49:01 <vixey> @pl list x y z = [x,y,z]
01:49:02 <lambdabot> list = (. ((. return) . (:))) . (.) . (:)
01:49:07 <vixey> @pl list x y z w = [x,y,z,w]
01:49:08 <lambdabot> list = (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
01:49:22 <Gracenotes> @hackage matrix
01:49:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/matrix
01:49:32 <vixey> @pl tup x = (x,())
01:49:32 <lambdabot> tup = flip (,) ()
01:49:36 <vixey> @pl tup x y = (x,(y,()))
01:49:37 <lambdabot> tup = (. flip (,) ()) . (,)
01:49:40 <vixey> @pl tup x y z = (x,(y,(z,())))
01:49:41 <lambdabot> tup = (. ((. flip (,) ()) . (,))) . (.) . (,)
01:49:49 <centrinia> @let invmod m a = let ((u,v),g) = extgcd ((1,0),(m,a `mod` m)) in ((v) `mod` m)
01:49:50 <lambdabot>  Defined.
01:50:00 <Gracenotes> hm
01:50:09 <Gracenotes> is there a standard matrix library in Haskell?
01:50:22 <Gracenotes> (well, not standard, just any such library)
01:50:47 <Gracenotes> ah, hmatrix, apparently
01:52:07 <centrinia> @let private_totient = (private_p-1) * (private_q - 1)
01:52:08 <lambdabot>  Defined.
01:52:58 <centrinia> @let public_e = head [e | e <- [2..], gcd e private_totient == 1]
01:52:59 <lambdabot>  Defined.
01:53:21 <centrinia> @let private_d = invmod private_totient public_e
01:53:23 <lambdabot>  Defined.
01:53:36 <pumpkin> lol
01:53:52 <pumpkin> implementing rsa in lambdabot?
01:54:36 <Gracenotes> hm, the matrix library seems to have a c base, though (makes sense, I suppose)
01:54:49 <centrinia> @let expmod m a e = if e == 0 then 1 else if e `mod` 2 == 0 then (expmod m a (e `div` 2))^2 `mod` m else ((expmod m a (e `div` 2))^2 `mod` m) * a `mod` m
01:54:51 <lambdabot>  Defined.
01:55:22 <centrinia> @let private_decrypt x = expmod public_n x private_d
01:55:23 <lambdabot>  Defined.
01:55:28 <pumpkin> Gracenotes: wli is looking to make a pure haskell one (mostly for sparse matrices it sounds like)
01:55:40 <centrinia> @let public_encrypt x = expmod public_n x public_e
01:55:42 <lambdabot>  Defined.
01:55:48 <centrinia> > public_n
01:55:50 <lambdabot>   65881297
01:55:55 <Gracenotes> ah, neat
01:56:07 <centrinia> > private_decrypt (public_encrypt 100)
01:56:08 <lambdabot>   46771191
01:56:15 <pumpkin> aw
01:56:15 <centrinia> Damn. :(
01:56:23 <pumpkin> epic fail :)
01:57:41 <blackdog> @seen gwern
01:57:41 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 4h 7m 25s ago.
01:58:08 <centrinia> > (public_e, private_d, public_n)
01:58:10 <lambdabot>   (7,7,65881297)
01:58:15 <pumpkin> ah
01:58:17 <centrinia> Oh.
01:58:26 <blackdog> is containers-0.2.0.0 broken? all i could find about it was hpaste.org/12293
01:58:35 <centrinia> > private_totient
01:58:37 <lambdabot>   65865060
01:58:38 <blackdog> complains about not finding Data.Data
01:59:15 <Gracenotes> Data.Data should be in base... apparently
01:59:48 <yakov> hey
02:00:11 <blackdog> the weirdest bit is that if you take the tarball and do the ./Setup configure dance manually, it all works
02:00:25 <blackdog> but nothing sees it when you try to install packages that rely on it
02:00:30 <Gracenotes> > Right 4 >>= \s -> Left "item"
02:00:32 <lambdabot>   Left "item"
02:00:42 <Gracenotes> > Right 4 >>= \s -> Right s+5
02:00:43 <lambdabot>       No instance for (Num (Either a t))
02:00:43 <lambdabot>        arising from the literal `5' ...
02:00:50 <Gracenotes> > Right 4 >>= \s -> Right (s+5)
02:00:51 <lambdabot>   Add a type signature
02:01:10 <Gracenotes> @type (Right 4 >>=)
02:01:12 <lambdabot> forall t a b. (Error a, Num t) => (t -> Either a b) -> Either a b
02:01:29 <Gracenotes> hrm
02:02:08 <pumpkin> it seems weird to force the Left of an Either to be an Error
02:03:01 <Gracenotes> @type Error
02:03:03 <lambdabot> Not in scope: data constructor `Error'
02:04:11 <Gracenotes> > Right 4 >>= \s -> Right (s+5) :: Either String Integer
02:04:12 <lambdabot>   Right 9
02:05:26 <Gracenotes> pumpkin: hm, what do you mean?
02:05:35 <pumpkin> forall t a b. (Error a, Num t) => (t -> Either a b) -> Either a b
02:05:36 <pumpkin> that
02:06:07 <pumpkin> @type (Right 4 >>=)
02:06:09 <lambdabot> forall t a b. (Error a, Num t) => (t -> Either a b) -> Either a b
02:06:39 <Gracenotes> @type (Right [] >>=)
02:06:40 <lambdabot> forall a a1 b. (Error a1) => ([a] -> Either a1 b) -> Either a1 b
02:07:18 <Gracenotes> ..in my ghci it's (Monad (Either a), Num t) => (t -> Either a b) -> Either a b
02:07:46 <pumpkin> Gracenotes: same here, maybe they changed it :)
02:08:06 <centrinia> @let extgcd' a b = if a `mod` b == 0 then (0,1) else let (x,y) = extgcd' b (a `mod` b) in (y,x-y*(a `div` b))
02:08:07 <pumpkin> @info Either
02:08:07 <lambdabot>  Defined.
02:08:07 <lambdabot> Either
02:08:12 <pumpkin> lol
02:08:17 <Gracenotes> ah, them, always changing things.
02:08:31 <pumpkin> yeah, they're always up to mischief
02:08:40 <pumpkin> @type (Left 4 >>=)
02:08:41 <lambdabot> forall t b b1. (Error t, Num t) => (b -> Either t b1) -> Either t b1
02:08:59 <centrinia> @let invmod' m a = let (u,v) = extgcd' m a in ((v) `mod` m)
02:09:00 <lambdabot>  Defined.
02:09:05 <Gracenotes> @info Error
02:09:05 <lambdabot> Error
02:09:27 <Gracenotes> perennially helpful
02:09:28 <centrinia> @let private_d' = invmod private_totient public_e
02:09:30 <lambdabot>  Defined.
02:09:34 <vixey> @go type compose
02:09:37 <lambdabot> http://www.xulplanet.com/references/xpcomref/comps/c_commandlinehandlergeneralstartup1typecompose.html
02:09:37 <lambdabot> Title: Component @mozilla.org/commandlinehandler/general-startup;1?type=compose
02:09:40 <vixey> @wiki Type Combinators
02:09:40 <lambdabot> http://www.haskell.org/haskellwiki/Type_Combinators
02:10:05 <centrinia> > expmod pubilc_n (expmod public_n 100 public_e) private_d
02:10:05 <lambdabot>   Not in scope: `pubilc_n'
02:10:15 <Gracenotes> > ["most", "odd"] :: Error [String]
02:10:16 <centrinia> > expmod public_n (expmod public_n 100 public_e) private_d
02:10:17 <lambdabot>       Class `Error' used as a type
02:10:17 <lambdabot>      In the type `Error [String]'
02:10:17 <lambdabot>      In ...
02:10:18 <lambdabot>   46771191
02:10:30 <centrinia> > expmod public_n (expmod public_n 100 public_e) private_d'
02:10:32 <lambdabot>   46771191
02:10:45 <centrinia> What the?
02:10:46 <Gracenotes> @instances Error
02:10:46 <lambdabot> IOError, String
02:10:50 <centrinia> @let private_d'' = invmod' private_totient public_e
02:10:52 <lambdabot>  Defined.
02:10:59 <centrinia> > expmod public_n (expmod public_n 100 public_e) private_d''
02:11:01 <lambdabot>   100
02:11:07 <centrinia> Yay!!!
02:11:25 <centrinia> @let private_decrypt' x = expmod public_n x private_d''
02:11:26 <lambdabot>  Defined.
02:11:36 <Gracenotes> @src Either (>>=)
02:11:37 <lambdabot> Left  l >>= _ = Left l
02:11:37 <lambdabot> Right r >>= k = k r
02:11:49 <centrinia> Okay, someone send me a message with public_encrypt. :)
02:11:54 <vixey> I need type level (.) and identity :(
02:12:08 <newtohaskell> hi i have a question, how can i use bytestring in list comprehension or list like pattern matching?
02:12:14 <vixey> > public_encrypt "happy tuesday"
02:12:15 <lambdabot>   Couldn't match expected type `Integer'
02:12:19 <vixey> > public_encrypt 2131 "happy tuesday"
02:12:20 <lambdabot>   Couldn't match expected type `[Char] -> t'
02:12:29 <centrinia> vixey, just send a number.
02:14:39 <centrinia> > public_encrypt 42
02:14:41 <lambdabot>   20675045
02:14:49 <centrinia> > private_decrypt 20675045
02:14:51 <lambdabot>   9867974
02:14:58 <centrinia> > private_decrypt' 20675045
02:14:59 <lambdabot>   42
02:16:37 <pumpkin> > stringToInt "abcd"
02:16:38 <lambdabot>   107890
02:16:46 <Gracenotes> @src stringToInt
02:16:47 <lambdabot> Source not found.
02:16:51 <Gracenotes> indeed.
02:16:53 <pumpkin> I just wrote it :P
02:16:59 <pumpkin> I did @let stringToInt = foldl ((. ord) . (+) . (10 *)) 0
02:17:14 <Gracenotes> ah, that must have been what I was looking for... if less convoluted
02:17:31 <pumpkin> be careful to not use strings greater than the modulus
02:17:37 <pumpkin> :P
02:17:42 <centrinia> pumpkin, that is not very effective for any alphabet with over 10 symbols.:(
02:17:43 <newtohaskell> for instance, i have function bReads ('i':s) = ... how can i convert to use bytestring?
02:17:54 <pumpkin> centrinia: good point :P
02:17:57 <Gracenotes> using (. f) and (f .) is still somewhat confusing
02:18:00 <pumpkin> @undefine stringToInt
02:18:22 <centrinia> > public_encrypt 1337
02:18:23 <lambdabot>   Not in scope: `public_encrypt'
02:18:28 <centrinia> Hmm.
02:18:34 <pumpkin> there
02:18:36 <Gracenotes> newtohaskell: if I recall correctly, using : in pattern matching is specifically defined in standards, whereas ByteString is just another library
02:18:41 <pumpkin> > stringToInt "abcd"
02:18:42 <lambdabot>   1614791170
02:18:56 <pumpkin> now I'm just unfriendly to anything larger than 255 :P
02:19:05 <pumpkin> I could make it 0x10ffff
02:19:12 <pumpkin> but it's not very efficient
02:19:16 <Gracenotes> source, again? :D
02:19:16 <centrinia> > [stringToInt (chr 2^x) | x <- [1..10]]
02:19:17 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
02:19:29 <centrinia> > [stringToInt (chr $ 2^x) | x <- [1..10]]
02:19:30 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
02:19:33 <pumpkin> fail
02:19:38 <centrinia> > [stringToInt [chr $ 2^x] | x <- [1..10]]
02:19:39 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
02:19:43 <centrinia> > [stringToInt [chr $ 2^x] | x <- [1..60]]
02:19:45 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
02:19:51 <centrinia> Okay, that's nice.
02:19:59 <augustss_> newtohaskell: If you want to pattern match on individual characters you need to use unpack on the ByteString.  If you want to pattern match of a ByteString you can turn on -XOverloadedStrings
02:20:08 <Peaker> > map (chr . (2^)) [1..60]
02:20:09 <lambdabot>   "\STX\EOT\b\DLE @\128\256\512\1024\2048\4096\8192\16384\32768\65536\131072\...
02:21:31 <Peaker> oh cool, there is an IsString class
02:21:56 <pumpkin> ‚Ä¶
02:22:11 <centrinia> > let intToString' x = if x == 0 then [] else (chr $ x `mod` 0x10ffff):intToString' (x `div` 0x10ffff) in intToString' $ stringToInt "foobar!"
02:22:12 <lambdabot>   "\1005636\380882\22690"
02:22:40 <vixey> > tup () (X True) (X "foo") (X 3) W
02:22:40 <centrinia> pumpkin, what was the base again?
02:22:40 <lambdabot>   Not in scope: `tup'Not in scope: data constructor `X'Not in scope: data con...
02:22:41 <vixey> (3,("foo",(True,())))
02:22:48 <pumpkin> centrinia: a bad one :P
02:22:50 <vixey> I didn't think it was possible!
02:22:54 <pumpkin> [05:18:00] <pumpkin> @let stringToInt = foldl ((. ord) . (+) . (255 *)) 0
02:23:04 <pumpkin> vixey: :o
02:23:07 <centrinia> > let intToString' x = if x == 0 then [] else (chr $ x `mod` 0xff):intToString' (x `div` 0xff) in intToString' $ stringToInt "foobar!"
02:23:09 <lambdabot>   "!raboof"
02:23:18 <pumpkin> :t tup
02:23:19 <lambdabot> Not in scope: `tup'
02:23:28 <pumpkin> oh that's not real almbdabot
02:23:39 <Peaker> hmm.. ByteStrings aren't instances of IsString, though
02:23:41 <centrinia> @let intToString = let intToString' x = if x == 0 then [] else (chr $ x `mod` 0xff):intToString' (x `div` 0xff) in reverse . intToString'
02:23:42 <lambdabot>  Defined.
02:23:56 <vixey> pumpkin, using GADTs, but it's too fun to give away how it works
02:23:58 <augustss_> Peaker: yes they are
02:24:01 <pumpkin> ah
02:24:05 <Peaker> augustss_: where's the instance?
02:24:11 <vixey> pumpkin, start with  oh AND AND AND AND NOTHING ~~> ()
02:24:22 <pumpkin> :o
02:24:33 <newtohaskell> by using -XOverloadedStrings what will the next line transform into?
02:24:33 <newtohaskell> beReads ('i':s) = [(BInteger x, rs) | (x, 'e':rs) <- intReads s]
02:24:34 <pumpkin> @instances IsString
02:24:35 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
02:24:37 <augustss_> Peaker: at least the right kind of ByteStrings.  There are so many
02:24:50 <Peaker> augustss_: Strict, Lazy, and Char8, right?
02:25:00 <augustss_> Char8 should be
02:25:09 <Peaker> ah, indeed it is. How does it handle unicode?
02:25:39 <augustss_> Not at all.
02:25:52 <centrinia> It should handle Unicode the same way any Unicode oblivious byte based computer handles Unicode. :)
02:26:12 * vixey wonders if it can be turned inside otu
02:26:21 <Peaker> augustss_: it does (`mod`0x100) :-)
02:26:39 <Peaker> augustss_: on the input chars
02:26:42 <augustss_> Peaker: Try it, I'm guessing yes.
02:26:49 <Peaker> augustss_: yeah, that's from trying it
02:27:01 <pumpkin> ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶
02:27:33 <philipp_> any idea what might cause this build failure: http://hpaste.org/13321 ?
02:27:54 <Peaker> augustss_: ByteString.UTF8 could be nicer than ByteString.Char8
02:27:59 <Peaker> (more useful)
02:28:24 <Peaker> (Only affecting fromString/toString, not trying to be wise about character indexing)
02:28:27 <augustss_> Wasn't someone working on that?
02:28:36 <centrinia> What should I do: stay in #haskell or solve more Euler Project problems?
02:28:43 <vixey> stay in #haskell
02:28:48 <vixey> turn on the light
02:28:53 <pumpkin> centrinia: how many do you have?
02:28:54 <blackdog> centrinia: exclusive or inclusive or?
02:28:55 <augustss_> centrinia: both
02:29:02 <vixey> go north
02:29:20 <blackdog> a wizard has turned you into a monad. is this awesome (y/n)?
02:29:26 <centrinia> Okay, I'll do both. :D
02:29:30 <pumpkin> centrinia: omg, I still have more than you!
02:29:37 <centrinia> Yeah.
02:29:40 <pumpkin> centrinia: you can pick easy ones to do by looking at my list ;)
02:29:58 <newtohaskell> is there any reason to use [Word8] instead of [Char] when doing bynary data?
02:30:12 <pumpkin> newtohaskell: char is much bigger than word8
02:30:19 <Peaker> newtohaskell: Char is a unicode code point, Word8 is just an unsigned int of 8 bits
02:30:20 <pumpkin> > maxBound :: Char
02:30:21 <lambdabot>   '\1114111'
02:30:33 <Peaker> > maxBound :: Word8
02:30:33 <augustss_> > maxBound :: Word8
02:30:34 <lambdabot>   255
02:30:35 <lambdabot>   255
02:30:37 <Peaker> > maxBound :: Int8
02:30:38 <lambdabot>   127
02:30:42 <centrinia> > ord maxBound
02:30:43 <lambdabot>   1114111
02:30:55 <Peaker> @let bounds = (minBound, maxBound)
02:30:56 <lambdabot>  Defined.
02:31:06 <Peaker> > bounds :: (Int8, Int8)
02:31:07 <centrinia> >bounds
02:31:07 <lambdabot>       Ambiguous occurrence `bounds'
02:31:07 <lambdabot>      It could refer to either `L.bounds',...
02:31:14 <augustss_> > printf "%x" (maxBound :: Char) :: String
02:31:16 <lambdabot>   "10ffff"
02:31:38 <centrinia> Where did you get the printf? :O
02:31:46 <Peaker> > showHex (maxBound :: Char)
02:31:47 <lambdabot>       Overlapping instances for Show (String -> String)
02:31:47 <lambdabot>        arising from a...
02:31:58 <centrinia> > printf "%x %d" 17 17
02:31:59 <lambdabot>   Add a type signature
02:32:00 <Peaker> > showHex (maxBound :: Char) ""
02:32:01 <lambdabot>       No instance for (Integral Char)
02:32:01 <lambdabot>        arising from a use of `showHex' ...
02:32:07 <centrinia> > printf "%x %d" 17 17 :: String
02:32:09 <lambdabot>   "11 17"
02:32:15 <centrinia> Wow.
02:32:15 <newtohaskell> but when I read data from socket will char read try to convert bytes to unicode?
02:32:24 <Peaker> > showHex $ fromIntegral . (maxBound :: Char) ""
02:32:25 <lambdabot>   Couldn't match expected type `t -> a -> b'
02:32:31 <augustss_> centrinia: ?
02:32:32 <Peaker> > showHex . fromIntegral $ (maxBound :: Char) ""
02:32:33 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `Char'
02:33:09 <Peaker> > showHex . ord $ (maxBound :: Char) ""
02:33:10 <lambdabot>   Couldn't match expected type `t -> Char'
02:33:32 <Peaker> > (showHex . ord) (maxBound :: Char) ""
02:33:34 <lambdabot>   "10ffff"
02:34:29 <pumpkin> centrinia: I can recommend fun ones if you want :P
02:35:04 <newtohaskell> when i do readFile will this try to read unicode or consider every byte a character?
02:35:20 <pumpkin> it's hard to "read unicode"
02:35:28 <pumpkin> you need an encoding :/
02:35:58 <pumpkin> centrinia: 79 was fun :)
02:37:00 <newtohaskell> pumpkin: i want to read raw binary data so i want no encoding what so ever, should i use [word8] instead of string?
02:37:19 <pumpkin> newtohaskell: use the ByteString file reading functions
02:38:13 <newtohaskell> pumpkin: but using the readFile will corrupt data?
02:38:42 <pumpkin> nope
02:39:42 <newtohaskell> pumpkin: so every byte from the file will be one char, right?
02:39:51 <pumpkin> should be, try it :)
02:40:05 * vixey this GADT ridiculousness is my new toy :D
02:40:42 <centrinia> Okay.
02:41:00 <newtohaskell> pumkin: ok thankx.
02:41:07 <newtohaskell> pumkin++
02:41:07 <pumpkin> I wonder if it would be worth making a hackage package (my first) for sorted set operations on infinite lists
02:41:35 <pumpkin> it'd be tiny and super simple, but I haven't found one already there
02:42:24 <vixey> :t ((,) ?o . ?k)
02:42:25 <lambdabot> forall a b a1. (?k::a1 -> b, ?o::a) => a1 -> (a, b)
02:47:31 <augustss_> vixey: what's ridiculous about GADTs?
02:47:45 <vixey> augustss_, what I am doing with them
02:47:51 <augustss_> ah
02:47:58 <vixey> this is so fun
02:49:14 <vixey> it's like solving a sokoban
02:49:42 <Associat0r> does anyone know if visual haskell is gonna be updated for VS 2008?
02:55:37 <vixey> if anyone is bored:
02:55:42 <vixey> > build (S 3) (S "foo") (S ()) (S True) Z
02:55:43 <lambdabot>   Not in scope: `build'Not in scope: data constructor `S'Not in scope: data c...
02:55:44 <vixey> (3,("foo",((),(True,()))))
02:55:54 <vixey> you can try to program that "build" function
02:56:44 <vixey> (without using a typeclass)
02:57:22 <mattam> It's varyadic?
02:57:47 <vixey> yes
02:57:56 <vixey> hetro/polyvariadic
02:58:29 <mattam> Did you just coin "polyvariadic"?
02:58:46 <vixey> I steal it from Oleg.. It's catchy
02:58:54 <mattam> Indeed.
02:59:07 <vixey> :p bbs
02:59:49 <C-Keen> hm, I want to write a simple monochrome graphics file (like cellular automata graphs) what graphics lib should I use?
03:00:42 <pumpkin> graphviz is simplest, if you can call it a lib
03:01:57 <C-Keen> pumpkin: graphviz draws graphs only no? I just need white square, white square, black square, white square, ...
03:02:29 <pumpkin> hmm
03:03:24 <C-Keen> I have found http://www.haskell.org/haskellwiki/Library/PNG but I wonder whether I could use something more nice and something available on hackage
03:03:50 <Axman6> my first uni assignment was a cellular automata one, which used ANU's ANUPlot library to show it using OpenGL
03:05:40 <C-Keen> ah no opengl, my graphics card does not support it
03:05:53 <Axman6> how old is your graphics card? :\
03:06:10 <C-Keen> it's just an onboard one about 4 years old
03:06:33 <augustss_> Has anyone made a cabal package of Fritz Henglein's generic O(n) sort?
03:06:38 <C-Keen> and my os does not have a nice accelerated X driver fo it
03:06:46 <pumpkin> generic O(n) sort? :o
03:06:58 <Axman6> ah right
03:07:04 <pumpkin> radix sort or something?
03:07:06 <augustss_> pumpkin: yes
03:07:35 <augustss_> pumpkin: O(n) in the number of input bits
03:07:41 <pumpkin> ah :)
03:08:10 <augustss_> But it's not a comparison based sort
03:08:25 <pumpkin> yeah
03:19:46 <vixey> heading = KEEP name! KEEP parameters! DROP (wstring ":")! KEEP term! DROP finish! STORE==> (,,)
03:20:05 <vixey> using GADTs I got this alternative notation for parsers
03:20:45 <vixey> it's = do n <- name ; p <- parameters ; wstring ":" ; t <- term ; finish ; return (n,p,t)
03:21:20 <mapreduce> Every problem seems to turn into a possible combinators lib.
03:21:50 <vixey> now I have to find something else to GADTify...
03:24:04 <jsn> so, i am trying to understand the difference between second and first order logic
03:24:17 <jsn> the wikipedia page is a little hard to penetrate
03:25:14 <Saizan> propositional or predicative?
03:26:25 <vixey> jsn, do you know simple typed lambda calculus and also polymorphic lambda calculus?
03:26:38 <jsn> vixey: i read about those yesterday
03:26:57 <jsn> vixey: how ever, it would be exaggerating to say i "know" them :)
03:27:21 <jsn> Saizan: well, i am not familiar with the difference there
03:27:43 <jsn> Saizan: there are propositional and predicative forms of second order and first order logic?
03:29:46 <Saizan> jsn: yes
03:31:15 <vixey> jsn, so you see that terms of simple typed lambda calculus corresponds to proofs of sentances of propositional logic?
03:32:09 <Saizan> jsn: in propositional logic you only have propositional variables that can be true or false, and second order here means that you can quantify over them, i.e. you've forall and exists, like haskell types
03:32:28 <jsn> vixey: yes
03:32:37 <jsn> vixey: well, i have not proven it for myself
03:33:04 <jsn> Saizan: well, first order logic has quantification though, right?
03:33:33 <Saizan> first order propositional doesn't
03:33:38 <jsn> aha
03:34:30 <Saizan> irst order predicative has quantifiers over term variables, i.e. ones that you apply a predicate to
03:34:35 <jsn> on wikipedia, it says "...second-order logic is an extension of first-order logic, which itself is an extension of propositional logic."
03:34:36 <jsn> http://en.wikipedia.org/wiki/Second-order_logic
03:35:20 <vixey> jsn: well In second order you can quantify over "type constructors" but in first order logic you can quantify over types only
03:35:32 <jsn> interesting
03:35:49 <vixey> is P :: * -> *, is a "type constructor".. so you can write  forall P, P(x) => P(y) in second order, but not in first
03:36:21 <jsn> what vixey says seems to be in agreement with what the wikipedia page says
03:36:37 <jsn> as there, it says there there are more kinds of quantification
03:38:02 <Saizan> i think wikipedia is mixing predicative and propositional orders
03:38:22 <Saizan> or at least using "first order logic" as short for first order predicative logic
03:38:34 <jsn> Saizan: yes, i will look into that
03:39:20 <Saizan> the second order lambda calculus is System F_2, which indeed allows you to only quantify over types, not type constructors
03:39:35 <jsn> hmm
03:39:36 <Saizan> http://en.wikipedia.org/wiki/System_F
03:39:41 <jsn> right
03:39:48 <jsn> that's why i'm even asking about this :)
03:40:06 <Saizan> because the first order one is STLC which doesn't allow any quantification
03:40:50 <jsn> so system F_2 corresponds to what Saizan is calling 2nd order
03:41:04 <Saizan> anyway this mostly a matter of definitions..
03:41:05 <jsn> what corresponds to what vixey is calling 2nd order?
03:41:08 <jsn> yes
03:41:22 <jsn> i am just trying to understand the curry-howard correspondence
03:41:37 <jsn> i don't really care whether it's _called_ 2nd order or not
03:41:55 <jsn> i just would like to know more about what kinds of formula are in correspondence
03:42:24 <jsn> so System F_2 corresponds to logic with existential and universal quantification?
03:42:49 <jsn> and System F_1 (simply typed lambda calculus) corresponds to propositional logic?
03:42:57 <Saizan> yes
03:43:31 <Saizan> but even F_2 is about propositional quantification, which is different from predicative
03:43:38 <jsn> hmmm
03:43:55 <jsn> okay, i should understand that better
03:44:36 <jsn> what is this stuff about "higher-kinded" quantification?
03:44:43 <vixey> simply typed lambda calculus is the proof system for propositional logic
03:44:45 <vixey> no quantifiers
03:44:55 <jsn> yes
03:45:05 <vixey> it is probably worth noting that it's intuitionistic logic, not classical
03:45:11 <jsn> interesting
03:45:20 <jsn> okay, so that's something else to read up on
03:45:32 <vixey> polymorphic lambda calculus with quantifiers over types with kind * only is first order
03:45:49 <vixey> quantifing over any type constructor is second order
03:45:52 <Saizan> well, forall a. a -> a <- here 'a' is a proposition, something that can be true of false, forall x. Human(x) -> Mortal(x) <-- here 'x' is a member of some universe we're talking about
03:46:28 <vixey> for higher order logics you can not only quantify over things but actually compute things inside types
03:46:51 <Saizan> in first order _predicative_ you have the latter type of quantification
03:46:51 <vixey> (that is literally compute types from other types or values)
03:47:56 <Saizan> vixey: so in your definition STLC is zeroth order or something?
03:48:17 <vixey> I suppose you could say that, I just call it propositional logic
03:48:27 <jsn> interesting
03:48:32 <Saizan> well propositional is ambiguos
03:48:39 <vixey> yes
03:48:44 <jsn> ?
03:48:47 <Saizan> System F is still propositional logic
03:48:51 <vixey> and it's not really logic either, because there's no logical connectives
03:49:11 <Saizan> no logical connectives?
03:49:19 <vixey> like /\ ..
03:49:29 <Saizan> you have -> in STLC, no?
03:49:33 <vixey> same with combinatory logic
03:50:17 * cm_ nomeatas slap around a bit with a large endofunctor
03:51:28 <jsn> "<vixey> and it's not really logic either..."  --  what's not really logic?
03:55:12 <jsn> unfortunately, it appears that the only end of the pool here is the deep end :)
03:56:19 <jsn> wikipedia does seem to be consistent with vixey -- "While propositional logic deals with simple declarative propositions, first-order logic additionally covers predicates and quantification."
03:56:20 <jsn> http://en.wikipedia.org/wiki/First-order_logic
03:58:25 <jsn> however, the System F page is in agreement with Saizan
03:59:06 <jsn> so i should really try to move away from the terms "1st order" and "2nd order" logic if i want to avoid befuddlement
03:59:34 <mbz_> befud what?
03:59:45 <vixey> jsn, a great intro text is Lectures on the Curry-Howard Isomorphism
04:03:11 <centrinia> Why is it called an isomorphism?
04:06:05 <jsn> "...minimal propositional logic corresponds to simply typed Œª-calculus, first-order logic corresponds to dependent types, second-order logic corresponds to polymorphic types..."
04:06:31 <jsn> so, this is a little more involved than i expected
04:07:11 <jsn> it is surprising to me that dependent types are expressible by a "lower" logic than the one that expresses polymorphic types
04:07:36 <jsn> anyways, i have my reading cut out for me
04:08:15 <jsn> it would be nice to return and clean up the wikipedia page -- it is lamentable that such seemingly simple terminology is in fact a rat's nest of ambiguity
04:11:53 <solrize> :t sequence
04:11:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:12:02 <solrize> :t sequence_
04:12:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:12:38 <solrize> > sequence [[1],[2]]
04:12:39 <lambdabot>   [[1,2]]
04:12:48 <solrize> > sequence [[1],["x"]]
04:12:49 <lambdabot>       No instance for (Num [Char])
04:12:49 <lambdabot>        arising from the literal `1' at <in...
04:15:33 <solrize> :t ST
04:15:35 <lambdabot> Not in scope: data constructor `ST'
04:15:36 <solrize> :k ST
04:15:37 <lambdabot> * -> * -> *
04:15:51 <solrize> :t ST Int
04:15:52 <lambdabot> Not in scope: data constructor `ST'
04:15:52 <lambdabot> Not in scope: data constructor `Int'
04:15:55 <solrize> :t ST Int Int
04:15:56 <lambdabot> Not in scope: data constructor `ST'
04:15:56 <lambdabot> Not in scope: data constructor `Int'
04:15:56 <lambdabot> Not in scope: data constructor `Int'
04:18:18 <mbz_> @index ST
04:18:19 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
04:18:50 <EnQ-Leil> Le haskell c'est juif ca ?
04:19:15 <schme> Please only swedish.
04:19:21 <schme> none of that spanish.
04:19:37 <Stephan202> You mean French?
04:19:43 <schme> Sure.
04:21:03 * centrinia only knows the Swedish words knulla and slida. :(
04:25:42 <Saizan> jsn: i think it's just that not much people talk about first order propositional, so first order logic is implicitly predicative, in fact dependent types does correspond to predicative logic
04:27:12 <jsn> well, that is still vexing
04:27:22 <solrize> "monad" is swedish, originally spelled m√∏n√•d
04:27:41 <jsn> solrize: so maybe it was orginally greek...
04:27:56 <Tobsan> what? monad is swedish?
04:28:13 <Tobsan> mˆnÂd?
04:28:30 <jsn> if it were actually germanic in origin it would have (eine|eigen).+
04:28:30 <solrize> yeah, i saw it in a monty python film.  a m√∏n√•d once bit my sister...
04:28:39 <Tobsan> i can say as a native swede i have never heard it
04:28:52 <Tobsan> lol
04:29:18 <jsn> Saizan: well, so what system F2 corresponds to is propositional logic?
04:29:31 <jsn> and that is why it does not encompass dependent types?
04:29:39 <Saizan> exactly
04:29:44 <vixey> jsn, what's "dependent types"?
04:29:58 <jsn> vixey: the type of numbers less than 7 and such
04:30:14 <vixey> no
04:30:19 <jsn> no?
04:30:22 <jsn> doh!
04:30:37 <baaba> dependent types are types indexed by values
04:30:38 <vixey> you can axiomatize peano arithemetic in first order logic
04:30:50 <vixey> the reals in System F
04:31:50 <Saizan> again, which first order logic?
04:32:05 <jsn> ah, okay
04:32:18 <jsn> i do not have a formal understanding of dependent types
04:32:32 <vixey> you should read the book I recommended :p
04:32:43 <jsn> well, i'm not done with it yet
04:32:52 <Saizan> dependent types are those where you can have values inside types
04:33:01 <jsn> oh?
04:33:18 <jsn> but dependent types can express things like, a list that is non-empty, right?
04:33:30 <vixey> you can express that in haskell
04:34:10 <jsn> vixey: i can make a newtype, yeah
04:34:20 <Saizan> in dependent types you can have e.g. Vec a n, where n :: Nat is a value of type Nat, instead of an encoding of a natural in at the type-level
04:34:30 <jsn> vixey: if there is some other way, i would like to see it, though
04:35:08 <Saizan> and Vec a n is a list of lenght n, btw
04:35:17 <augustss_> jsn: have a look at Tim Sheard's Omega
04:35:39 <augustss_> he has some good examples of what can be done with Haskellish types
04:35:44 <jsn> Saizan: would you actually be able to substitute Vec a n for a [a] ?
04:36:32 <augustss_> jsn: not in general, since you can't know the length in general
04:36:35 <Saizan> jsn: it's usually defined as a separate type
04:36:57 <augustss_> jsn: e.g. filter is difficult
04:37:22 <jsn> i guess i have been under the impression that dependent types allow for arbitrary sub-typing using conditions on the values
04:37:38 <vixey> I don't know any implementations that have got subtyping
04:37:55 <mattam> jsn: that too. You can define Vec a n := { l : list A | length l = n }.
04:38:04 <augustss_> jsn: well, yes, some kind of subtyping.  But you have to provide proof.
04:38:12 <vixey> (maybe I mean coercive subtyping or something)
04:38:15 <mattam> vixey: PVS has.
04:38:39 <vixey> cool
04:39:04 <jsn> mattam: i guess that's the use case i always think of -- in that case you could use Vec a n with filter, map and so on
04:39:13 <mattam> The number hierarchy starts from the reals and gradually add constraints via nested subset types.
04:39:41 <mattam> jsn: indeed, this encoding has a number of advantages.
04:42:25 <mattam> augustss_: Basically the Haskell tricks don't work when the value (i.e. the length) changes dynamically?
04:44:33 <augustss_> mattam: those cases can be difficult with real dependent types as well.  Sometimes you need an existential to wrap up the fact that you don't know the exact value when type checking.
04:45:34 <mattam> Indeed.
04:47:31 <Heffalump> oh, interesting christmas present from augustss (lambdacube)
04:48:15 <schme> centrinia: Those are the only words you need.  Though generally one would use "fitta" instead of "slida".  The second one there is very.. hmm... clinical.
04:48:17 <augustss_> Heffalump: well, I forgot to put it on hackage a year ago. :)
04:48:24 <Heffalump> :-)
04:49:21 <Heffalump> h/me fails to get it to do much
04:49:42 <Heffalump> but I'm going to be dragged off for physical christmas presents shortly.
04:49:57 <augustss_> We had ours yesterday.
04:50:15 <Heffalump> weird Swedish customs :-)
04:50:24 <Heffalump> Tobias said it felt very strange to be at work.
04:50:39 <augustss_> It would feel impossible for me.
04:50:48 <Heffalump> I think he had zero holiday left
04:50:48 <centrinia> schme, thank's for the tip. ;)
04:51:20 <schme> centrinia: I think if you go around saying "knulla slida" people will think you're trying to attract 7 year old girls :(
04:51:32 <centrinia> Oh.
04:51:40 <centrinia>  :(
04:51:53 <schme> Yeah. Not so hot.
04:51:56 <centrinia> knulla fitta. :)
04:52:15 <schme> Ya that will land you women real easy.
04:52:22 <augustss_> You might have trouble in general if you go around saying that in Sweden.
04:52:29 <schme> pfft!
04:52:42 <schme> You go to the wrong clubs ;)
04:52:45 <augustss_> lol
04:52:57 <jsn> why would the clinical term imply you are after seven year olds?
04:53:14 <schme> Well I dunno if anyone above the age of 7 uses that other word.
04:53:18 <ziman> what is knulla slida? :)
04:53:26 <schme> at 8 they learn the proper word, so I dunno.
04:53:31 <schme> It just sounds that way to me :)
04:53:42 <schme> ziman: It's "fuck vagina"
04:54:01 <ziman> oh i see
04:55:19 <centrinia> Our Swedish roommate used to teach us a lot more Swedish phrases. It has been a while and I forgot most of them. :(
04:55:32 <thoughtpolice> augustss_: btw, your blog on the lambda cube was brilliant, in case the comments you recieved didn't notify you of that. :) thanks for the hackage release
04:56:35 * centrinia comes up with a few more axes and extends the lambda hypercube. :)
04:57:26 <Igloo> How is the kn pronounced in Swedish?
04:58:41 <schme> Hmm..
04:58:56 <centrinia> I always thought the 'k' was silent.
04:59:00 <schme> It's not.
04:59:09 <centrinia> Hmm.
04:59:36 <schme> I'm trying to magic up some english word that has the same phoneme.
04:59:43 <Igloo> Is it like Kenickie from Grease?
04:59:51 <centrinia> Knuth?
05:00:02 <schme> Ya Knuth works.
05:00:05 <solrize> canola
05:00:22 <schme> canola is brilliant :)
05:00:34 <solrize> same word spelled different :)
05:00:48 <schme> Knola I'd go with.
05:01:01 <solrize> where is the lambda cube blog?
05:01:32 * centrinia wonders what reaction one would receive by asking for canola oil in Sweden.
05:01:47 <solrize> lol
05:01:55 <schme> centrinia: If you ever go to sweden remember that to say "hello, how do you do?"  you'd say  "va fan glor du p√•, din dumme fan! ska du ha p√• k√§ften?"  ;)
05:02:30 <mbz_> "dumme"?
05:02:51 <schme> Uhm yes.
05:02:58 <Igloo> I thought the Swedish for "hello, how do you do" is "Talar du Engelska"  :-)
05:03:06 <schme> hahaha.
05:03:12 <schme> That is probably safer.
05:03:27 <thoughtpolice> solrize: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
05:03:42 <solrize> tx
05:03:42 <schme> Well I'll stop the OT :)
05:05:26 <ziman> i suspect it might be dangerous to catch swedish from this channel ;)
05:06:00 <schme> Possibly (:
05:15:03 <jsn> schme: i put that through Google translate
05:15:24 <schme> Did it come out ok?
05:16:02 <jsn> "what the hell are you looking at, your stupid shit! are you going to shut up?"
05:16:11 <schme> hmm..
05:16:15 <schme> that's almost right.
05:16:30 <schme> do you want a punch in the face?  would be more correct :)
05:17:13 <schme> gold star for jsn !
05:17:15 <jsn> the subtranslations are interesting
05:17:49 <jsn> "ska du" -> "you should"
05:18:06 <schme> "din dumme fan" was a bit funny. Taken out of context "your stupid shit" would be just fine. But in the whole phrase it's "you" and not "your" :)
05:18:45 <jsn> "ha p√• k√§ften" -> "have to shut up"
05:18:55 <jsn> ("have to have your ass kicked"?)
05:18:59 <schme> hahaha.
05:19:14 <jsn> why is the posessive used in "din dumme fan" ?
05:19:26 <schme> Well just "k√§ften" could easily be translated as "shut up". But not with "ha p√•" in front.
05:19:44 <schme> Right.  If that was the whole sentence, it would be the possessive.
05:20:09 <schme> "din ko" =>  "your cow".
05:20:31 <schme> but make it part of something, throw a comma in there.  Then its just calling names :)
05:20:39 <jsn> well, din is the second person nominative possessive, right?
05:20:54 <schme> Yes.
05:21:03 <schme> among other things :)
05:21:31 <jsn> how is is that, iodiomatically, "thy dumb shit" is "thou are a dumb shit"?
05:21:40 <jsn> or din is more than one word, you are saying?
05:22:07 <schme> if you'd say maybe.. "din j√§kel!", as one often says in a friendly manner anyway.. it's literally "you devil"  and not "youR devil"
05:22:19 <jsn> interesting
05:22:26 <schme> I think it's related to if it's part of a bigger sentence..
05:23:47 <schme> "din j√§kel!" just like that makes no grammatic sense. But maybe "den √§r gul, din j√§kel"   (it's yellow, you devil!).  But 'course spoken language seldom makes perfect grammatic sense.. I'd go with "din" is something else when it's a ehm.. no idea what one calls it. :)
05:25:23 <schme> jsn: That's funny. I've never thought about it. I can't explain why it is the way it is, it just is :)  Every native speaker knows it is that way. (:
05:26:20 <jsn> well, there's no reason offhand to believe this falls into the "makes no sense" category
05:27:23 <jsn> i'm sure there is even a good paper on it
05:27:28 <schme> nono.. It makes perfect sense to say "bla bla bla, din bla bla".  Just in normal spoken swedish one would out of nowhere just go "din bla bla".. with the other stuff implied or so :)
05:27:41 <schme> Probably.
05:28:07 <jsn> the germanic languages have enjoyed the richest self-scrutiny of any family of languages
05:28:47 <schme> Indeed.
05:29:16 <schme> I think it's related to the majority of the 6000 or so languages world wide not being spoken by very many, and lacking the written part.. so it makes it kinda hard I guess :)
05:29:27 <schme> Or we're just crazy.
05:29:51 <augustss_> or both
05:30:01 <schme> ya. I'll go with crazy.
05:30:04 <schme> BWAHATKHAHKKK!!
05:30:38 <schme> Seriously though, I actually have a haskell related question.  How well does the ghc function on the arm?
05:31:43 <jsn> schme: well, much of recent philology was accomplished by the english or the germans
05:32:07 <schme> Indeed :)
05:32:31 <Spockz|lap> Happy christmas everybody! :)
05:32:45 <centrinia> Are you going to compile Haskell programs for an ARM device?
05:33:05 <schme> Ya merry holiday to you too Spockz|lap.
05:33:26 <schme> centrinia: Well really I'm wondering if GHC builds and works ok on ARM.
05:33:43 <centrinia> Happy Christmas and Merry New Year to everyone! ;)
05:34:05 <schme> I'd try it out if I could find my cable.
05:34:11 <schme> :)
05:34:30 <PeakerWork> Why is ErrorT not named EitherT?
05:34:42 <schme> oh there even is a debian package for arm. great. It should be no problem then.
05:35:07 <PeakerWork> Given ghc can go through C, it probably runs okay on the ARM, at worst through C?
05:35:36 <schme> Well that is fine :)  I was more wondering if ghc actually was buildable on it.
05:35:42 <schme> But it would seem so.
05:36:32 <jsn> consider the first-order logic sentence:    ‚àÉx( Person(x) ‚àß ‚àÄy( time(y) ‚Üí Canfool(x, y) ) )
05:37:01 <jsn> is this "there is a person who can be fooled at every time"?
05:37:21 <schme> That renders as complete crap :)
05:37:30 <schme> (for me)
05:37:56 <jsn> schme: you have UTF-8 disabled?
05:38:01 <schme> I guess.
05:38:18 <jsn> ‚àÉx(Person(x) ‚àß ‚àÄy (time(y) ‚Üí Canfool(x, y)))
05:38:27 <jsn> hmm, oops
05:38:31 <maltem> PeakerWork, re ErrorT: because it's Either e a rather than Either a, I suppose
05:38:36 <schme> Maybe it's the terminal I'm sshing in :)
05:38:56 <opqdonut> probably just a charset mismatch
05:39:05 <jsn> Ex( Person(x) ‚àß Ay( time(y) ‚Üí Canfool(x, y) ) )
05:39:34 <schme> ok.
05:39:40 <schme> (:
05:39:41 <jsn> Ex( Person(x) ‚àß Ay( time(y) -> Canfool(x, y) ) )
05:39:45 <jsn> there
05:40:45 <jsn> PeakerWork: ErrorT also has a bunch of "throwError" operations attached to it, and has the restriction that "e" must be in typeclass Error
05:41:08 <jsn> ?localtime schme
05:41:10 <lambdabot> Local time for schme is Thu Dec 25 14:40:41 2008
05:41:20 <jsn> is :) backwards in Sweden?
05:41:29 <schme> Nope.
05:41:38 <jsn> what is (:
05:41:40 <jsn> ?
05:41:45 <schme> I've been typing (: the right way since 1991 and I'm not quitting.
05:41:48 <schme> Everyone else is broken.
05:42:04 <jsn> >:3
05:42:16 <schme> cept that one other guy I bumped into on some channel. He is ok.
05:42:17 <schme> ;)
05:42:27 <luite> it's because the () are shifted on the swedish keyboard, compared to the US layout ;)
05:42:43 <schme> Maybe.
05:43:02 <jsn> okay, so, maybe you guys can tell me whether i'm interpreting the sentence correctly
05:43:23 <schme> jsn: I have a logic failure here. wikipedia says that's right, I'm siding with it.
05:43:46 <jsn> it's given as the encoding of "there is always someone who can be fooled" but it seems to be saying, "there is some who can always be fooled"
05:43:59 <jsn> s/some who/someone who/
05:44:14 <opqdonut> jsn: yes, the quantifiers are the wrong way around
05:44:53 <schme> luite: I think maybe I use (: because :) strikes me as you're an extreme left wing communist standing way over to the left lookin' at us nice capitalist people standing on the right looking at the communists (:   ;)
05:46:25 <schme> oh ya.. there is someone who can always be fooled.  That is what wiki says too :)
05:46:47 <jsn> oh, yeah
05:47:05 <jsn> i guess if that's what they meant, yeah
05:48:20 <jsn> how do you write, "there is always someone (not necessarily the same) who can be fooled"?
05:48:58 <PeakerWork> @type throwError
05:48:59 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
05:49:08 <PeakerWork> jsn: EitherT could be MonadError
05:49:41 <schme> I'm thinking  swap the tmie(y) and person(x) around :)
05:51:01 <jsn> Ay( Time(y) & Ex( Person(x) -> Canfool(y, x) ) )
05:51:20 <schme> So.. I'm reading here that I need ghc to build ghc ?
05:51:55 <jsn> so i guess what i don't get is, are the scoping rules such that we get a fresh x for each y in the above?
05:52:23 <schme> jsn: You do too complicated stuff :)
05:55:41 <jsn> :t ErrorT
05:55:42 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
05:55:53 <jsn> weird
05:58:53 <jsn> PeakerWork: it's actually the instances for ErrorT (Monad, MonadFix, MonadTrans, &c.) that introduce the constraint (Error e)
06:00:18 <jsn> schme: i've read the GHC for ARM page and the most recent progress is actually with JHC
06:00:20 <jsn> http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc#jhcSuccess
06:00:50 <jsn> oh, our benighted, over-complicated compiler
06:01:24 <jsn> i'm not sure what applications actually justify having native-code generation instead of using LLVM, for example
06:02:03 <jsn> of course, it's supported on a number of platforms already
06:04:39 <schme> hmmm..
06:04:43 <schme> No idea what JHC is :)
06:05:44 <schme> jsn: The GHC webpage claims there is a debian package for ARM debian so it should be all ok.
06:06:23 <jsn> schme: JHC is another Haskell compiler
06:06:36 <schme> ok.. and it is preferable to GHC ?
06:07:37 <BONUS> nah, GHC is pretty much the norm
06:07:53 <schme> Great.
06:07:59 <Raynes> GHC is the flagship compiler. And the most popular.
06:08:23 <schme> The site suggests it is a bitch to build it though :)
06:09:16 <Raynes> Rayne is a windowsfag, I didn't have to build anything :>
06:09:20 <adrian> ghc is very simple to build
06:09:27 <schme> adrian: Great. :)
06:09:29 <adrian> ./configure; make; make install
06:09:57 <schme> adrian: I'm just worried about where it says "It is possible to build GHC using just a C compiler, and indeed some distributions of GHC do just that, but it isn't the best supported method, and you may encounter difficulties." :)
06:10:13 <adrian> hm
06:10:31 <adrian> I remember having installed ghc6.6 just with gcc
06:10:40 <schme> great.
06:10:41 <Raynes> Try it, all it can do is fail.
06:10:49 <schme> Yeees. as soon as I locate my cable.
06:10:51 <maltem> schme: that's the process required for bootstrapping, if you don't have an old ghc available on a given architecture
06:10:59 <schme> maltem: I don't.
06:11:14 <adrian> schme: what system are you on?
06:11:21 <schme> Well I want this for arm linux.
06:11:31 <adrian> oh, well
06:11:43 <adrian> no package available?
06:11:49 <schme> and it should be no problem. I mean debian has arm packages for it.
06:11:56 <maltem> oh, ARM is an architecture :)
06:11:57 <schme> Not any other than the debian packages.
06:12:14 <adrian> and you have tried installing one of those?
06:12:17 <schme> maltem: indeed!
06:12:54 <schme> adrian: I have not no. I'd rather not have to find all bizarre dependencies it has built in and install those by hand :)
06:13:06 <schme> I haven't tried anything at the moment, I'm looking for my cable.
06:14:19 <schme> Why on earth does ghc require perl?
06:14:37 <Raynes> schme: It has an addiction.
06:14:43 <jsn> schme: the evil mangler
06:14:55 <schme> That's a bitch.
06:15:20 <maltem> perl is quite an ugly build dependency indeed.
06:15:42 <adrian> I heard we wanted to get rid of the evil mangler
06:15:43 <schme> I'd rather not have it on my system at all :)
06:16:01 <jsn> schme: i guess someone got some haskell on to their openmoko: https://www.joachim-breitner.de/blog/archives/300-guid.html
06:16:11 <pejo> Perl is availabl e
06:16:13 <pejo> Perl is availabl e
06:16:15 <pejo> Sorry.
06:16:21 <jsn> schme: i don't any Linux system can run without perl at present
06:16:22 * schme googles openmoko.
06:16:29 <pejo> Perl is available on almost any platform, and even comes installed with Solaris.
06:16:33 <jsn> s/i don't/i don't think/
06:16:49 <schme> jsn: Ok. I run linux systems without perl.
06:16:56 <jsn> schme: which ones?
06:16:59 <schme> Yes perl is available, I just don't want it.
06:17:17 <jsn> i tried mightily to get perl off my gentoo system
06:17:27 <schme> jsn: Huh.. "schme's crosscompiled linux system built using scratchbox" ?
06:17:33 <schme> Right.
06:17:35 <jsn> but i believe the autotools require it -- i gave up
06:17:49 <schme> That is quite possible. I suspect most distros require it.
06:17:55 <jsn> schme: what are the quotemarks?
06:18:11 <schme> ?
06:18:16 <schme> Not following you here :)
06:18:27 <jsn> when is said "any linux system" i should have said "any linux distro"
06:18:31 <schme> oh!
06:18:34 <schme> Ya that makes sense.
06:18:53 <jsn> oh, i see -- the name of your distro is "schme's crosscompiled linux system built using scratchbox"
06:19:00 <schme> Right.
06:19:08 <schme> I generally build what I need.
06:19:19 <schme> 'cept this machine where I'm stuck with the pain of debian ;)
06:19:27 <schme> oh openmoko is some phone :)
06:19:52 <schme> well time to feed the cats
06:21:21 <adrian> cabal install's magic is not powerful enough to install hlint it seems...
06:21:59 <dcoutts> adrian: mm?
06:22:18 <adrian> either it doesn't find any package named hlint
06:22:28 <adrian> or it doesn't install all the dependencies
06:22:41 <adrian> depending on the phase of the moon I suppose
06:23:34 <maltem> adrian: if it doesn't find it, did you cabal update? (hlint has only recently been released iiuc)
06:23:53 <adrian> I cabal-updated a some days ago
06:23:53 <maltem> the current version anyways
06:24:02 <adrian> but that may be the culprit
06:24:15 <maltem> before or after Dec 20? ;)
06:24:23 <adrian> hm, hard to say
06:25:45 <dcoutts> adrian: it just worked perfectly for me
06:25:54 <adrian> good to know
06:26:12 <dcoutts> it installed haskell-src-exts, uniplate and hlint-1.0.0.1
06:26:49 <dcoutts> adrian_away: let us know the details some time
06:28:48 <nroot7> How do I configure vim for Haskell. I need features like omni complete and auto-indent
06:29:30 <aeolist> nroot7: you need lhaskell.vim
06:29:44 <nroot7> OK
06:29:47 <nroot7> Thanks
06:32:06 <adrian> dcoutts: cabal update fixed things
06:32:25 <adrian> I think it tried installing an older version and got confused with the dependecies
06:33:45 <dcoutts> adrian: did it fail like:
06:33:46 <dcoutts> rc/Main.hs:14:7:
06:33:46 <dcoutts>     Could not find module `Ignore':
06:34:13 <adrian> no, it tried tried installing happy and later could not find it
06:34:18 <dcoutts> ahh
06:34:22 <dcoutts> separate issue
06:34:36 <adrian> s/tried//
06:34:41 <dcoutts> that's kind of the fault of cabal-install
06:34:53 <dcoutts> since by default where it installs binaries is not in the $PATH
06:35:08 <adrian> I put ~/.cabal in my path
06:35:40 <dcoutts> adrian: ok, then it may have been an old happy version which had buggy packaging
06:35:48 <dcoutts> we had a problem with that a while ago
06:36:20 <adrian> does hlint work with literate haskell?
06:36:49 * dcoutts has no idea
06:36:53 <dcoutts> try it
06:37:02 <adrian> It gives me a parse error
06:37:07 <adrian> but only on line 162
06:37:22 <adrian> i'll de-literate the file and try again
06:42:27 <adrian> the parse error persists
06:46:37 <adrian> it seems it *needs* whitespace around operators
06:56:01 <adrian> that's quite annoying
06:57:29 <adrian> has eta-reduction any advantages?
06:58:06 <Saizan> about operators that's probably going to be fixed in the next release of haskell-src-exts, or you can report it as a bug to it
06:58:48 <Saizan> only stylistic advantages
07:00:00 <adrian> I like f $ g $ h x more than f.g.h
07:00:12 <adrian> sometimes at least
07:02:02 <Saizan> f.g.h is more refactorable though
07:03:21 <adrian> hm yes
07:03:38 <Saizan> e.g. f.g is a meaningful expression, f $ g isn't
07:04:41 <Saizan> hard to tell if it actually helps you spotting patterns in your code etc. or not :)
07:13:42 <adrian> is it better to build a list by prepending and doing a reverse or by appending?
07:13:49 <adrian> depends on the use, doesn't it?
07:14:13 <adrian> reverse isn't lazy
07:15:14 <Saizan> you can have fast appending if you compose functions of type [a] -> [a]
07:15:27 <Saizan> well
07:15:35 <Saizan> look at DList :)
07:35:16 <jsn> <Saizan> you can have fast appending if you compose functions of type [a] -> [a]
07:35:26 <jsn> only by using DList or there is another way?
07:36:06 <b_jonas> I still think that's false
07:36:35 <b_jonas> that kind of fast appending doesn't work if most of the parts appended are empty
07:36:51 <jsn> what kind of fast appending?
07:37:03 <b_jonas> you need a bit more complicated strucure in that case, a binary tree that removes empty parts
07:37:21 <b_jonas> jsn: fast appending of lists with [a]->[a] appender functions
07:38:35 <jsn> like this?    (++ [6]) . (++ [5]) $ [0..4]
07:39:05 <b_jonas> yeah
07:39:06 <b_jonas> like that
07:39:08 <jsn> it gets delayed until you evaluate the list, i guess
07:39:17 <b_jonas> or like how shows works
07:39:23 <jsn> why would empties mess that up?
07:39:24 <jsn> oh
07:39:30 <b_jonas> actually no
07:39:30 <jsn> so that's why show does that!
07:39:34 <b_jonas> it doesn't work that way
07:39:39 <b_jonas> it only works the other way I think
07:39:54 <b_jonas> like ([6] ++) . ([5] ++ $ [0..4]
07:40:05 <jsn> that's prepending, though
07:40:05 <b_jonas> but maybe I'm wrong
07:40:09 <b_jonas> sure
07:40:13 <b_jonas> but if you compose the other way
07:40:22 <b_jonas> wait
07:40:31 <b_jonas> > (shows 42) "foo"
07:40:33 <lambdabot>   "42foo"
07:40:36 <b_jonas> it prepends
07:41:03 <b_jonas> still I think you need a tree if you have lots of empty prepends
07:41:10 <b_jonas> it's not too hard to write eithe
07:41:43 <b_jonas> just a binary tree, unbalanced except for that empty nodes are removed if they can
07:41:49 <maltem> How is (++ [6]) . (++ [5]) $ [0..4] fast?
07:42:19 <b_jonas> maltem: it's not
07:42:28 <maltem> ok :)
07:42:29 <jsn> well, i am trying to figure what this "fast appending" is
07:42:40 <b_jonas> it should be ([5] ++) . ([6] ++) . [0..4] I think
07:42:49 <jsn> but that is prepending!
07:42:52 <b_jonas> sure
07:42:55 <jsn> we already have fast prepending
07:42:57 <joelr1> merry christmas everyone
07:43:06 <jsn> joelr1: you too
07:43:21 <joelr1> dons: hi don! do you install takusen using cabal /at work/?
07:43:32 <b_jonas> jsn: the point is that if you store all the lists as prepender functions instead of lists,
07:43:40 <b_jonas> then you have concatenation of lists as . for free
07:43:51 <b_jonas> and you don't have to write it yourself
07:43:56 <b_jonas> joelr1: to you as well
07:44:25 <jsn> i guess i don't see where there is an actual speed up as a result of this
07:44:50 <jsn> "...concatenation of lists as . for free"
07:44:51 <Saizan> jsn: if you keep your lists as [a] -> [a] then you can append with \xs ys -> xs . ys
07:45:04 <jsn> ah
07:45:05 <maltem> jsn: in other words, [5] ++ ([6] ++ [7]) is better than ([5] ++ [6]) ++ [7].
07:45:21 <jsn> and so, there is only one traversal at the end?
07:45:30 <b_jonas> yep
07:45:35 <b_jonas> it's linear time in the number of elements
07:45:35 <Saizan> jsn: and you get a  speedup only significant if you're doing several appends
07:45:47 <jsn> right
07:45:49 <b_jonas> provided there aren't too much ([] ++) in it
07:45:52 <jsn> okay, interesting
07:46:04 <b_jonas> whereas with appends it _could_ be quadratic, sometime
07:46:27 <b_jonas> instead of functions you could just as well have a tree and traverse it at the end
07:46:40 <b_jonas> binary tree
07:46:52 <jsn> hmm
07:46:56 <b_jonas> you concatenate two such trees by adding them under a new root (unless one of them is empty)
07:47:00 <b_jonas> that's linear too
07:47:07 <mib_vvzkm4> @hoogle sha1 :: String->String
07:47:08 <lambdabot> No results found
07:47:10 <b_jonas> but with the functions you don't have to write as much code
07:47:16 <b_jonas> and it looks cooler
07:47:23 <jsn> so, does the machinery of lazy evaluation not help here at all?
07:47:24 <b_jonas> so that's what they chose for shows
07:47:50 <b_jonas> jsn: not much
07:47:57 <b_jonas> jsn: it could help reducing memory usage though
07:48:13 <b_jonas> because if the string representation of objects is large, you don't have to keep it all in memory
07:48:17 <augustss_> jsn: lazy evaluation only helps time-wise if some parts of the computation are not needed.
07:48:22 <b_jonas> you can even print it without generating all the list
07:48:58 <b_jonas> @hoogle sha1
07:48:58 <lambdabot> No results found
07:49:13 <jsn> so, if i understand lazy evaluation correctly, then when i build a list like this :   ([1] ++ [2]) ++ [3]
07:49:34 <Heffalump> (which you shouldn't :-)
07:49:38 <jsn> there is actually an expression waiting to be evaluated until i demand it
07:49:42 <Heffalump> correct
07:50:00 <jsn> the runtime is not able to rewrite it to    [1] ++ ([2] ++ [3]) ?
07:50:10 <Heffalump> nope
07:50:15 <jsn> !!
07:50:15 <Heffalump> why would it?
07:50:20 <Heffalump> or rather, how would it?
07:50:22 <b_jonas> jsn: the problem is not that simple case of just three lists of course
07:50:30 <Heffalump> the compiler might be able to in theory in some cases, but certainly not in general
07:50:33 <b_jonas> jsn: it's when you concatenate lots of small lists in the wrong direction
07:50:45 <jsn> Heffalump: it could for all of (++), yes?
07:50:50 <Heffalump> jsn: how?
07:51:03 <augustss_> Heffalump: well, the hbc runtime did under some circumstances
07:51:49 <jsn> well, (++) is commutative and associative
07:51:56 <Heffalump> augustss_: cool, but how? You don't even know if there is another (++) without doing some evaluation sometimes.
07:52:03 <Heffalump> Or was it when it could see that without evaluation?
07:52:07 <maltem> jsn: it's not commutative
07:52:08 <jsn> since haskell is a purely functional language
07:52:15 <jsn> maltem: oh, you're right
07:52:21 <jsn> maltem: i'm a goofus
07:52:26 <jsn> it's only associative
07:52:28 <augustss_> Heffalump: it only did it on output and when it spotted (x++y)++z
07:52:47 <Heffalump> What do you mean by output?
07:52:51 <maltem> jsn: maybe ++ is a bad name, because of this
07:53:16 <b_jonas> > drop 29900 (foldr (++) [] (replicate 5000 "hello ")) -- fast
07:53:17 <Heffalump> jsn: sure, it's a valid transformation, but I don't know how a runtime can spot it in general.
07:53:17 <lambdabot>   "llo hello hello hello hello hello hello hello hello hello hello hello hell...
07:53:17 <jsn> maltem: well, in many languages, it's just '+'
07:53:21 <augustss_> Heffalump: the top level in the trs that write the characters to screen (file).
07:53:22 <b_jonas> > drop 29900 (foldl' (++) [] (replicate 5000 "hello ")) -- slow
07:53:27 <lambdabot>   "llo hello hello hello hello hello hello hello hello hello hello hello hell...
07:53:31 <Heffalump> augustss_: ah, right
07:53:32 <b_jonas> > drop 29900 (foldl (++) [] (replicate 5000 "hello ")) -- slow
07:53:37 <lambdabot>   "llo hello hello hello hello hello hello hello hello hello hello hello hell...
07:53:52 <Heffalump> and only when all the bits were already evaluated? Or did it force things to check?
07:54:35 <jsn> okay, well, that is an interesting technique to have, i guess
07:54:37 <b_jonas> jsn: actually concatenation has more than ten names in different languages
07:54:40 <b_jonas> I counted it once
07:54:40 <augustss_> Heffalump: only when the bits were already evaluated
07:54:51 <jsn> b_jonas: yes, it can be all kinds of stuff
07:55:07 <jsn> b_jonas: i personally prefer <<
07:55:16 <augustss_> jsn: what you want is possible in principle, but it's doubtful how much good it does in practice.
07:55:21 <Heffalump> augustss_: wouldn't you expect them not to be in general? How often did it actually fire?
07:55:26 <jsn> indeed
07:56:05 <augustss_> Heffalump: for a few programs that constructed the result with lots of ++ it made a lot of difference, but not in general.
07:56:44 <augustss_> Heffalump: also, it never actually performed the concatenation, of course.  Since the characters were about to be printed anyway.
07:56:52 <Heffalump> right
07:56:55 <jsn> i just always try to do lists with ':' of course, and i think that is best
07:57:05 <b_jonas> it can be: plus, amperasand, dot, dotdot, lessgreater, doubleverticalbar, doubleplus, tilde, hat, doubleslash, comma, dollarplus, nothing (juxtaposition), comma parenthisized.
07:57:20 <Heffalump> so you just kept a stack of expressions that would have been concatenated?
07:57:23 <jsn> interesting -- hat
07:57:36 <jsn> i am trying to remember, which languages allow nothing
07:57:37 <augustss_> Heffalump: basically, yes
07:57:39 <jsn> python?
07:57:42 <jsn> oh, and C
07:57:48 * Heffalump realises that his questions about "already evaluated" were a red herring, since you only have to look at the things you'd be about to evaluate anyway
07:57:50 <b_jonas> jsn: I think hat is standard ml
07:57:54 <b_jonas> jsn: nothing is awk
07:58:03 <jsn> ah
07:58:11 <Heffalump> if the thunk you want to print is a (++), then just keep recursing into its left argument until it isn't any more
07:58:21 <Heffalump> and if you just evaluated it, you'd have to do exactly the same thing.
07:58:38 <jsn> dollarplus?
07:58:56 * Heffalump is now less convinced that the runtime couldn't do it, assuming that giving the runtime special knowledge of ++ was desirable.
07:59:02 <augustss_> Heffalump: also, hbc represented strings in a packed form that was unpacked on demand.  so when printing there was no need to unpack.
07:59:04 <Heffalump> couldn't do it in general, that is
07:59:07 <jsn> comma parenthesized?
07:59:25 <Heffalump> augustss_: sounds far too efficient for a Haskell compiler.
07:59:50 <augustss_> Heffalump: I think these little tricks is why hbc still beats ghc on some benchmarks. :)
08:00:35 <jsn> double slash?
08:01:06 <b_jonas> it's also nothing in shells
08:01:40 <b_jonas> double slash and dollar plus are new to me as well, some page says some newer fortran has double slash as concatenation (I don't believe that, how can they call it fortran if it has strings?)
08:02:07 <b_jonas> and dollar plus is for "mirc scripting language" which I'm not sure I can believe either
08:02:43 <b_jonas> by comma parenthisized I mean [a,b,c] means a concatenated with b concatenated with c, which is the syntax in matlab and octave, and
08:02:52 <b_jonas> the commas can be replaced with spaces if that's unambiguous
08:02:59 <augustss_> b_jonas: Real FORTRAN has no string operations!
08:03:05 <b_jonas> augustss_: that's what I'm saying too
08:03:28 * Heffalump has used the mirc scripting language, though I forget the details.
08:03:31 <b_jonas> and of course some languages only have alphabetically named functions for concatting (prologs, lisps, schemes)
08:03:36 <augustss_> FORTRAN IV was the last real FORTRAN
08:04:09 <gweiqi> Heffalump: were you a winnie the pooh fan?
08:04:16 <Heffalump> not particularly
08:04:20 <Heffalump> I like elephants though.
08:04:23 <b_jonas> also many languages have two concatenation operators
08:04:35 <gweiqi> i see
08:04:46 <b_jonas> because in standard ml strings are iarrays of char and hat concatenates those, whereas I dunno what concatenates lists
08:05:02 <augustss_> @ ?
08:05:02 <b_jonas> and in perl comma concatenates lists and dot concatenates strings
08:05:17 <b_jonas> augustss_: can't remember
08:05:19 <b_jonas> maybe
08:05:24 <augustss_> @ concatenates lists in original ML
08:05:44 <augustss_> which has . as cons
08:06:12 <b_jonas> what? isn't cons :: in ml?
08:06:21 <augustss_> Not in original ML
08:06:51 <augustss_> Edinburgh ML ca 1979
08:07:07 <b_jonas> also some languages (maple, sql, basic) have multiple concatenation operators for historical reasons
08:07:47 <augustss_> Haskell instead has multiple exponentiation operators. :)
08:08:09 <b_jonas> oh yeah
08:08:27 <b_jonas> as I said some languages have two or more concate operators for they serve different purposes
08:08:34 <b_jonas> perl and ml has two for two data types as we've seen
08:08:45 <Heffalump> you can think of (.) as a concatenation operator in Haskell :-)
08:08:48 <b_jonas> matlab/octave has horizontal and vertical concatenation
08:10:45 <b_jonas> mathematica has <> for catting strings, ~~ for catting regexen, but still no non-alphabetic op for catting lists I think
08:11:08 <b_jonas> not that you'd often want it either for lists are iarrays in mathematica so you don't want to concatenate them much
08:11:44 <b_jonas> instead you want to map and possibly flatten like in apl or collect elements without getting intermediate results
08:11:51 <b_jonas> for which they have useful functions
08:11:53 <centrinia> The (.) operator can concatenate list generating functions. ;)
08:12:35 <b_jonas> actually some people want (.) to mean fmap and (++) to mean mappend (monoids) in haskell I think
08:12:44 <b_jonas> lambdabot has one of these hacks active
08:12:48 <b_jonas> @type (++)
08:12:50 <lambdabot> forall a. [a] -> [a] -> [a]
08:12:57 <b_jonas> @type (.)
08:12:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:13:09 <Heffalump> a lot of people complained, so perhaps it was turned off
08:13:09 <b_jonas> hmm no
08:13:31 <jsn> :t (<$>)
08:13:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:13:34 <jsn> is even better
08:13:47 <jsn> i think the new category module has hijacked (.)
08:13:50 <Heffalump> jsn: how does that differ from fmap?
08:13:57 <b_jonas> Heffalump: it's the same
08:14:01 <Heffalump> jsn: yeah. It's bloody annoying.
08:14:02 <b_jonas> applicative exports it
08:14:20 <jsn> Heffalump: i mean, it's better than taking over (.) for that purpose
08:14:21 <b_jonas> because Applicative is a friend of Functors and needs the function
08:14:29 <Heffalump> jsn: oh, sure
08:15:32 <b_jonas> actually I think in applicatives, a <$> b = pure a <*> b
08:18:26 <jsn> what does @ do in haskell?
08:18:39 <jsn> oh, wait
08:18:40 <jsn> duh
08:18:44 <Beelsebob> jsn: it allows you to specify two patern matches at once
08:18:56 <Beelsebob> (against the same part of the term you're matching)
08:18:59 <jsn> a@(x:xs)
08:19:00 <Heffalump> hmm. If I have a simple type class instance with no superclasses, I can arrange for the definitions to contain top-level CAFs by doing something like foo = let x = <expensive thing> in \a -> ...
08:19:01 <jsn> &c.
08:19:12 <Heffalump> is there any way I can get the same effect for instances with superclasses?
08:31:46 <mib_vvzkm4> what license is Crypto?
08:34:55 <centrinia> Cryptol?
08:36:16 <mib_vvzkm4> no, the Crypto module
08:36:18 <mib_vvzkm4> hackage
08:36:28 <_dolio> Doesn't it say?
08:36:37 <mib_vvzkm4> "OtherLicense" or something.
08:39:16 <_dolio> Oh. Might be MIT.
08:39:23 <_dolio> You'll have to check the license file in the package.
08:39:30 <mib_vvzkm4> none that i can find
08:40:37 <dolio> Hmm.
08:42:31 <dolio> The ReadMe.tex file has license information.
08:42:48 <dolio> Some BSD, some GPL.
08:43:11 <dolio> Depends on the module, apparently.
08:44:45 <mib_vvzkm4> yeah apparently the md5 impl is based on a gpl one
08:44:45 <mib_vvzkm4> grr
08:47:06 <Gabbie> Don't like GPL?
08:47:50 <Beelsebob> not really a discussion for #haskell, but it does the oposite of what it claims
08:48:07 <Beelsebob> it claims to give freedom, and reality gives you shackles -- just shackles on your feet instead of your hands
08:48:28 <Beelsebob> if you want freedom, you want BSD
08:48:39 <dolio> I think it does what RMS wants it to pretty well.
08:48:50 <Beelsebob> yeh -- but not what he claims it to
08:49:05 <Heffalump> I think it gives precisely the freedom he claims.
08:49:14 <dolio> Well, he has a particular definition of "freedom".
08:49:16 <Heffalump> He's never claimed to be interested in letting people close things up.
08:49:31 <Beelsebob> and you can't close things up with a BSD licenced project either
08:49:40 <Beelsebob> the BSD licenced parts always will be BSD licenced
08:49:41 <Beelsebob> and open
08:49:59 <Beelsebob> it just happens that you can build non-BSD licenced things and still interact with it
08:50:15 <Heffalump> you can change it and relicence the changes..
08:50:33 <Beelsebob> yes -- exactly -- and the BSD licenced parts will remain open
08:50:45 <Beelsebob> it just doesn't require that I publish all my code as well as yours
08:50:58 <Heffalump> it doesn't require that you publish anything
08:51:02 <Beelsebob> (I would publish mine, but that doesn't mean I shouldn't have the right to do what I like with my code)
08:51:16 <Beelsebob> no -- but the BSD licenced code will still be available from it's original source
08:51:28 <Beelsebob> I can't magically take that away
08:51:34 <kublar> you can do anything you want with your own code
08:51:38 <gwern> GPL doesn'
08:51:44 <gwern> t give you the freedom to close
08:51:50 <Beelsebob> kublar: except link with GPL code and then do what I like
08:51:54 <gwern> in the same way a free society doesn't give you the freedom to murder
08:52:07 <kublar> Beelsebob: oh, you can link just fine, you just can't distribute
08:52:21 <Beelsebob> kublar: true, got me on a technicality
08:52:40 <kublar> but yeah, that's pretty much why I prefer (L)GPL
08:52:56 <Beelsebob> that's pretty much why I go BSD all the time
08:53:16 <Beelsebob> if I'm gonna give people the freedom to do what they like with my code, I'm gonna do it properly
08:53:39 <kublar> I don't want to give people that freedom
08:53:54 <gwern> Beelsebob: BSD? how selfish. i use public domain
08:53:56 <Beelsebob> of note -- the company I work for is contributing *really large* amounts of code to BSD based project
08:53:59 <Beelsebob> projects*
08:54:06 <Philonous> Are records more than tuples + sugar?
08:54:10 <Beelsebob> but nothing to GPL ones -- because we can't use them in our end project
08:54:12 <mib_vvzkm4> My program is non-GPL licensed.
08:54:15 <CurrentEval> yet I keep being abandoned
08:54:18 <mib_vvzkm4> I cannot therefore use any GPL library in this.
08:54:23 <dolio> Philonous: They're algebraic data types + sugar.
08:54:27 <mib_vvzkm4> I hate the GPL but my grr is more practical: i need to find a non-GPL one.
08:54:48 <Philonous> dolio: ok thanks
08:57:32 <Aizen_Sama> you guys are way over my head, right now I am really impressed with the ghci and playing with the scope and putting breaks at different lines lol
08:57:47 <Aizen_Sama> <-newb
09:03:31 <dolio> mib_vvzkm4: You do see the other two MD5 libraries on hackage, right?
09:03:36 <dolio> Both of which are BSD.
09:03:43 <mib_vvzkm4> dolio: yes, I'm investigating them
09:12:06 <mib_vvzkm4> @hoogle String->ByteString
09:12:07 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
09:12:07 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
09:12:07 <lambdabot> Prelude read :: Read a => String -> a
09:12:53 <mib_vvzkm4> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString <-- pack is [Word8] -> ByteString...
09:13:05 <kublar> mib_vvzkm4: no, it isn't
09:13:14 <mib_vvzkm4> > :t pack pack :: [GHC.Word.Word8] -> ByteString
09:13:15 <lambdabot>   <no location info>: parse error on input `:'
09:13:31 <kublar> you didn't load Data.ByteString.Lazy.Char8
09:13:38 <mib_vvzkm4> o
09:13:56 <mib_vvzkm4> but, should I?
09:14:02 <mib_vvzkm4> I just want to use regular bytestrings.
09:15:43 <mib_vvzkm4>     Couldn't match expected type `Data.ByteString.Internal.ByteString'            against inferred type `ByteString'
09:15:44 <mib_vvzkm4> :S
09:15:51 <mib_vvzkm4> when using a bytestring-using lib
09:16:15 <kublar> do you want strict or lazy bytestrings?
09:16:25 <mib_vvzkm4> I'm not sure. :)
09:22:54 <CakeProphet> so to install lambdabot I need to change its .cabal file so that it depends on a different version of base?
09:23:00 <CakeProphet> so to install lambdabot I need to change its .cabal file so that it depends on a different version of base?
09:23:20 <Philonous> I'm trying to build a monad for delayed IO, i.e. a monad action creates a "request" of some sort (basically some ADT with information what the functions wants) which is stored in a list or something else, handled by a function which for example builds a GTk window and feeds the input user data back into the second part of the monad action which builds an IO action that is than executed. But I can't figure out how to feed the dat
09:23:24 <mib_vvzkm4> CakeProphet: you also have to say things twice
09:23:25 <mib_vvzkm4> CakeProphet: you also have to say things twice
09:23:53 <mib_vvzkm4> Philonous: you got cutt off at "feed tha da"
09:23:54 <CakeProphet> mib_vvzkm4:  sorry... I'm getting odd lag and I thought I hadn't entered the channel yet the first time I said it. :)
09:24:12 <Philonous> ...  feeds the input user data back into the second part of the monad action which builds an IO action that is than executed. But I can't figure out how to feed the data back in a typesafe way. I don't really want runtime checks.
09:24:14 <CakeProphet> what version should I change base to?
09:24:45 <mib_vvzkm4> Philonous: Uh, you can't typecheck runtime data at compile time.
09:24:54 <Cale> CakeProphet: I'd tell you, but I'm not sure. The machine which lambdabot runs on still has 6.8.2
09:25:04 <Cale> (or 6.8.3, I can't remember)
09:25:10 <Philonous> Right, but I figure I don't need to because the requesting functions are completely determined at compile time
09:25:25 <duaneb> could someone help me with this annoying indentation problem?
09:25:41 <Cale> CakeProphet: If you can get it working with base 4, that would be cool.
09:25:41 <duaneb> (I think)
09:25:42 <mib_vvzkm4> Philonous: if you don't have the info right there at compile time, you cannot use the type system to guarantee anything about it
09:25:47 <Cale> duaneb: sure
09:26:03 <duaneb> http://hpaste.org/13322
09:26:18 <duaneb> it does not compile for some reason :/
09:26:23 <duaneb> ahh, right
09:26:34 <duaneb> on line 12
09:26:40 <duaneb> it 'car' is not in scope :/
09:26:52 <mib_vvzkm4> car doesn't exist
09:26:53 <mib_vvzkm4> try head
09:27:03 <mib_vvzkm4> oh
09:27:22 <Cale> grr, hpaste is so slow
09:27:28 <Cale> People should use hpaste 2 :)
09:27:29 <Philonous> mib_vvzkm4: The structure (i.e. the types) are completely determined at compile time
09:27:29 <mib_vvzkm4> duaneb: that parses as (do x<- y;) <|> (...)
09:27:41 <mib_vvzkm4> Philonous: not sure then
09:27:46 <mib_vvzkm4> duaneb: so the x is in the scope of the doblock
09:28:06 <Cale> right
09:28:17 <duaneb> damn smilies
09:28:17 <Cale> car isn't in scope in the second do-block
09:28:26 <mornfall> Let me repeat my question, now that there are people alive... Is there a portable variant of getProcessID? All I need is a string or number unique per running process...
09:28:29 <C-Keen> hm, I try to install a package with cabal and it tells me I have no ghc-prim installed. This is with a darcs cabal  and ghc-6.6.1
09:28:30 <duaneb> mib_vvzkm4: thanks
09:28:34 <mornfall> And I'd like it to work on win32.
09:29:35 <Cale> mornfall: The calls in System.Process give you something called a ProcessHandle
09:29:39 <duaneb> mib_vvzkm4: ok, I guess my question is: what's the solution?
09:29:40 <Cale> which may be what you want
09:29:50 <mornfall> Cale: I need to get that for the current process though...
09:30:00 <duaneb> I suspect I need to surround something in parentheses, but I'm not sure what ;)
09:30:05 <Cale> What are you trying to do with it?
09:30:17 <mornfall> Cale: The code at hand creates files like <hash>-
09:30:21 <mornfall> Err, premature EOL.
09:30:29 <Cale> duaneb: maybe around the try and the rest of the block?
09:30:34 <jsn> so, just to be sure: this page describes 2nd order /predicate/ logic    http://en.wikipedia.org/wiki/Second-order_logic
09:30:42 <mornfall> Cale: The code at hand creates files like <hash>-new. Now if two processes run, they may both create same <hash>-new. I'd like that to be <hash>-new.<pid>...
09:30:52 <duaneb> Cale: yea :/
09:30:54 <jsn> but System F corresponds to 2nd order /propositional/ logic
09:31:16 <jsn> so the link from the wikipedia page on System F is actually an error
09:31:27 <mornfall> Cale: The problem is that there's little connection between the code that produces the file and the one that consumes it... specifically, there's no way to pass extra information like a random string or ID.
09:31:31 <Cale> mornfall: I'm pretty sure there's an api for creating a file with a unique name.
09:31:49 <mornfall> Cale: Right, but that's not it.
09:32:02 <mornfall> I need a rather deterministic name.
09:32:10 <Philonous> I think what it boils down to is to find a good way to for given functions f :: a -> b, g:: c->d find a datastructure x and functions f':: x->b and g' x->d such that f'x = f a and g' x = g c in an automated way
09:32:32 <mornfall> I know, the code sucks, but it's something that's hard to fix non-intrusively.
09:32:59 <Cale> mornfall: How is it supposed to know your program's PID from another copy of your program's PID?
09:33:15 <mornfall> Cale: It's not a different copy..?
09:33:29 <Cale> "The code at hand creates files like <hash>-new. Now if two processes run, they may both create same <hash>-new. I'd like that to be <hash>-new.<pid>..."
09:33:39 <mornfall> The program creates the file, then crunches something for a while and a relatively unrelated piece of code picks up that file.
09:33:48 <dolio> x = (a,b), f' = f . fst, g' = g . snd?
09:34:18 <mornfall> Cale: Right, I just want to avoid naming conflict for the files, but can't create the usual tempfiles, because the rest of the code will never figure which file they should take.
09:34:48 <Cale> That's what I was asking -- how does the other piece of code know which PID is the right one?
09:35:01 <Cale> Is it searching the process list for your program?
09:35:12 <mornfall> It's still the same process.
09:35:15 <dolio> Sorry, (a,c)
09:35:22 <mornfall> So it can just ask for its own pid.
09:35:23 <Cale> Oh, then why not just hang on to the string?
09:35:26 <duaneb> excellent, compiles
09:35:27 <duaneb> thanks!
09:35:39 <mornfall> So let me repeat.
09:35:52 <mornfall> It's hard to restructure the code so that the knowledge passes from the first piece of code to the latter.
09:36:03 <Cale> hmm
09:36:11 <kublar> environment variable
09:36:24 <Cale> I suppose the trouble I'm having is with why that would be :)
09:36:26 <mornfall> kublar: Hm.
09:36:38 <Cale> Isn't it just adding a few extra parameters?
09:37:36 <mornfall> Cale: Well, the first piece of code schedules a download of something. The other end is something that fetches files sequentially, and it just looks if it's already downloaded by the scheduler and picks up the <hash>-new thing.
09:37:54 <mornfall> Cale: It's not inherently hard, but I don't want to add extra changes just to fix that stupid bug.
09:37:58 <mornfall> I'll do it properly later...
09:38:09 <mornfall> (It's for darcs, and 2.2 is already frozen...)
09:38:25 <mornfall> On unix, it's quite simple, the win32 part is that puzzles me.
09:38:26 <Philonous> dolio: Yes, thanks, pretty obvious. Sometimes you don't see the wood for the trees.
09:38:50 <duaneb> is there a doc somewhere about haskell's numerical tower?
09:38:55 <dolio> Philonous: Well, your sentence is a lot like the categorical definition of a product, which I've beat into my head several times.
09:39:03 <dolio> Not exactly the same, but similar.
09:39:25 <Cale> mornfall: I suppose you could record it in a file, or as someone suggested, an environment variable.
09:39:43 <Cale> (so long as we're doing things in a hacky way :)
09:39:44 <mornfall> Cale: Yeah, but is it really impossible to get a process ID under win32?
09:40:01 <Cale> mornfall: I don't think it's something for which a particularly portable interface has been invented.
09:40:11 <Cale> You could use CPP and an #ifdef I suppose.
09:40:27 <Cale> I could be wrong, but it would be news to me.
09:40:42 <mornfall> I could. It'd probably still hurt less than envvars.
09:40:55 <mornfall> But I haven't found the piece of API that'd work under win32 at all.
09:41:19 <mornfall> The only "portable" code that I have found by using google resorted to #if windows let pid = "windows" #endif which is ... creative.
09:42:40 <mornfall> I am glad I can find out the colour of active border, but a process Id seems much more elusive.
09:43:42 <wcstok> the windows api call is, surprisingly enough, GetCurrentProcessId, http://msdn.microsoft.com/en-us/library/ms683180(VS.85).aspx.  Looks no more complicated than the getpid syscall under unixen
09:44:24 <mornfall> wcstok: Cool. The question is, is it somewhere in System.Win32?
09:44:43 <wcstok> heh, for that you're on your own
09:45:15 <mornfall> Hm.
09:45:16 * wcstok is still clumsily flopping around with haskell hello worlds
09:45:28 <mornfall> That makes me unhappy.
09:47:32 <mib_vvzkm4> @hoogle hsetbuffering
09:47:32 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
09:49:01 <duaneb> ok, so I'm trying to implement the scheme numerical tower
09:49:03 <mib_vvzkm4> @hoogle buffermode
09:49:03 <lambdabot> System.IO data BufferMode
09:49:20 <duaneb> basically, there are four datatypes: Complex, Real, Rational, and Integer
09:49:31 <duaneb> and the first three can be 'exact' or 'inexact'
09:49:43 <duaneb> how might I create a datatype for this? :P
09:50:56 <mib_vvzkm4> isn't linebuffering stdin the default?
09:57:13 <luqui> duaneb, what is an exact real?
09:57:47 <lilac__> luqui: 12.8 is an exact real :)
09:58:05 <mattam> Arbitrary precision i suppose.
09:59:56 <luqui> duaneb, do you want this to be dynamic or static?
10:00:12 <luqui> dynamic is easy, you just make a data with all the cases you want
10:00:35 <BMeph> luqui: Dynamic of static _what_? :)
10:00:40 <BMeph> *or
10:01:09 <luqui> choice of numeric type
10:02:25 <C-Keen> which ghc version does cabal-install need?
10:03:14 <cizra> C-Keen: 6.6 is too old
10:03:19 <cizra> C-Keen: 6.8 should be fine, though.
10:03:28 <C-Keen> alright
10:04:17 <cizra> Also, haven't I seen you around before?
10:04:20 <cizra> ISTR that name.
10:04:33 <C-Keen> cizra: could be :)
10:04:50 <b_jonas> well, obviously he's named from Commander Keen
10:04:57 <b_jonas> so no wonder you've heared it
10:05:17 <cizra> No, I seem to recall you having visited #lojban or something.
10:05:52 <C-Keen> cizra: that's right I do hang around in #lojban now and then
10:06:40 <cizra> oh.
10:10:38 <duaneb> so
10:11:37 <duaneb> can I use a typeclass in a type signature?
10:12:29 <luqui> duaneb, what do you mean by that?
10:12:39 <luqui> :t (==)  -- the usual way you do
10:12:41 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:15:38 <dejones> I'm confused how to fix this error     Couldn't match expected type `IO t'
10:15:38 <dejones>            against inferred type `CGIT IO URI'
10:15:38 <dejones>  -- I don't know how to get the variable out of the CGIT monad transformer???
10:17:51 <luqui> dejones, "lift" will get you in.  Whatever run function is provided will get you out (I've never used it)
10:18:13 <luqui> :t lift
10:18:15 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
10:18:18 <bd_> :t liftIO
10:18:20 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
10:18:23 <ziman> i think it should be runCGIT
10:18:49 <dejones> luqui, ziman:  Ahh, yea, I kept finding lift functions, but didn't realize that run it the counterpart.  :)
10:18:52 <dejones> thanks!
10:23:54 <duaneb> how can I define  a type in ghci?
10:24:30 <jkff> I guess you can't
10:25:40 <jkff> ...And as for me, I have trouble with regex-pcre under Windows: I've downloaded the pcre library from gnuwin32 and pointed the regex-pcre cabal package to its include and lib dirs, built, installed, and now when I try to run a program that uses it in ghci, I get a "can't load .so/.DLL for:pcre"
10:26:04 <luqui> duaneb, unfortunately you can't.
10:26:09 <jkff> With a message 'Module not found'
10:26:17 <jkff> (an OS message, in my language)
10:26:38 <duaneb> damn
10:26:43 <duaneb> haskell's repl sucks
10:26:45 <duaneb> no offense :./
10:26:49 <duaneb> but
10:26:51 <luqui> yeah, we know
10:26:53 <duaneb> it's rather limited
10:27:04 <duaneb> hmm
10:27:07 <duaneb> I'll try Hugs
10:27:30 <dnul> hi , im new here
10:27:43 <byorgey> hi dnul, welcome =)
10:27:52 <luqui> did somebody ask for lots of newcomers for christmas?  :-)  welcome
10:28:02 <dnul> haha
10:28:06 <byorgey> maybe lots of people got RWH for Christmas =)
10:28:13 <luqui> oh, that is more logical
10:28:38 <dnul> hey, i'm quite a noob with haskell , i've been trying to do some stuff for projecteuler but keep failing
10:28:52 <dnul> i've wonder if you could help me
10:28:59 <byorgey> dnul: don't worry, failing is normal =)
10:29:11 <byorgey> dnul: paste some code on hpaste.org and we'll have a look
10:29:21 <byorgey> or ask whatever questions you like.
10:29:27 <dnul> ok, thx u
10:29:40 <dnul> im trying to do some memoization
10:29:41 <jkff> Project Euler is an extraordinarily cool way to train new languages
10:29:54 <dnul> definetly
10:30:44 <byorgey> ah, memoization =)
10:31:11 <byorgey> dnul: sometimes, an easier way to do that in Haskell is to build a recursively-defined immutable array
10:31:16 <byorgey> but it depends what you're trying to do.
10:31:22 <byorgey> which problem is this in particular?
10:31:57 <dnul> right now im trying to do number 21
10:32:46 <dnul> but i've tried doing memoization with other problems and i had to move to python.
10:32:50 <jkff> And what are your difficulties, in particular?
10:32:55 <dnul> cause i didnt know
10:33:03 <abuiles> HI, Guys! Could someone please explain me what does mean base >3 in this : "Build-Depends:          base>3, mtl, haskell-src-exts==0.4.*, utf8-string " ?
10:33:24 <dnul> byorgey: I've an example of the fibonacci made that way , the one with zipwith
10:33:48 <byorgey> dnul: oh, you mean  fibs = 0 : 1 : zipWith (+) fibs (tail fibs) ?
10:33:57 <dnul> byorgey: exactly
10:33:59 <byorgey> dnul: that's actually not what I was referring to.
10:34:05 <C-Keen> abuiles: probably base-4.0.0 which is part of ghc-6.10
10:34:07 <byorgey> dnul: that's building up a recursively defined *list*
10:34:16 <dnul> byorgey: aha, keep talking
10:34:28 <byorgey> dnul: the difference being that an array gives you O(1) access to any element
10:34:38 <jkff> dnul: You usually need something like 'memoRes = array (0,n) [(i, f i) | i <- [0..n]]', where f may also reference elements of memoRes
10:34:46 <byorgey> dnul: whereas you have to traverse an entire list to get to a particular element since they are linked lists
10:34:54 <dons> woo http://www.reddit.com/r/programming/comments/7lo4v/haskell_weekly_news_cairo_cryptol_llvm_tries/
10:34:57 <dons> byorgey++
10:35:12 <byorgey> dnul: using a list works for fibonacci since you only need the previous two elements to compute the next.
10:35:32 <byorgey> dons: =)
10:35:38 <dons> ?users
10:35:38 <lambdabot> Maximum users seen in #haskell: 568, currently: 545 (96.0%), active: 17 (3.1%)
10:35:45 <jkff> For example, fibArray n = let arr = array (0,n) [(i,f i) | i <- [0..n]] where f 0 = 1; f 1 = 1; f n = arr!(n-1) + arr!(n-2)
10:35:58 <jkff> ... in arr
10:36:04 <byorgey> dons: good thing I didn't get around to putting it out yesterday, Cryptol just snuck in under the wire =)
10:36:08 <abuiles> C-Keen: Thanks
10:36:22 <dons> byorgey: hehe
10:36:26 <byorgey> dnul: so what exactly are you trying to memoize in #21?
10:36:39 <dnul> jkff: its array part of prelude
10:37:20 <dnul> jkff: i wasnt familiar with array, i've tried to use Map instead, but that its like a hash table i suppose
10:37:52 <jkff> array is part of the Data.Array module
10:38:06 <byorgey> dnul: Map actually uses something like binary search trees
10:38:09 <jkff> Data.Map is a balanced tree, which is about as fast as hash tables usually are.
10:38:15 <byorgey> although it's a quite clever implementation
10:38:31 <dons> anyone benchmarked bytestring-trie against Map Bytestring yet?
10:38:33 <duaneb> so
10:38:34 <byorgey> dnul: for immutable array stuff, take a look at http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-IArray.html
10:38:36 <duaneb> anyone use cairo?
10:38:46 <byorgey> duaneb: I've used it a bit
10:38:46 <duaneb> is there a good cross-platform api that can use it?
10:38:53 <dons> duaneb: yeah
10:38:57 <dons> the gtk api?
10:39:21 * duaneb dislikes gtk
10:39:23 <duaneb> is that it?
10:39:28 <duaneb> how about wx?
10:39:29 <duaneb> tk?
10:39:39 <byorgey> dnul: mutable arrays are considerably more complicated to learn how to use, since you need IO or ST
10:39:50 <jkff> dnul: There are also 'unboxed arrays', Data.Array.Unboxed - but with them you can't have elements of the array be mutually defined
10:40:03 <jkff> However they are an order of magnitude faster.
10:40:27 <byorgey> dnul: but if you just want to incrementally compute & cache the values of a function, i.e. many memoization/dynamic programming algorithms, building a recursively-defined immutable array is the way to go.
10:40:56 <cizra> Hey
10:41:07 <cizra> How easy or difficult is it to call C libraries from Haskell?
10:41:08 <dnul> byorgey: my approach on problem 21 was very silly, i wanted to have a list where each element contain the sum of its divisors. By building it i would compute for number 23 the sum of its divisors X. then i would go to X to see the sum of its divisors , if element X match 23 then X and 23 are amicable.
10:41:38 <jkff> cizra: It is rather easy; take a look at the FFI chapter of RWH: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
10:41:40 <dnul> number 23 ie
10:41:49 <cizra> jkff: Thanks!
10:42:02 <byorgey> dnul: that's not silly.
10:42:03 <duaneb> dons: do you live on reddit?
10:42:35 <byorgey> dnul: if you build up an immutable array containing the sum of the divisors of all numbers from 1 to 10000, then scan through it looking for amicable numbers, I think that should be quite fast
10:42:49 <dolio> Hey, HWN finally.
10:43:24 <byorgey> dolio: yeah, I've been finals-ing, traveling etc. =)
10:43:32 <dolio> Ah. :)
10:43:49 <byorgey> dnul: using a list isn't a good idea because it has O(n) random access.
10:44:01 <dnul> byorgey: okey , but i dont see a lot of optimization by memoizing.
10:44:10 <dons> duaneb: hmm, no. but i use ita fair bit to track haskell stuff
10:44:12 <dnul> byorgey: am i wrong?
10:44:43 <byorgey> dnul: well, in this case the optimization is not the memoization per se, but the fast lookup when trying to find amicable numbers
10:45:23 <dnul> byorgey: okey , but then wouldnt be quite the same if i didnt memoize the values
10:45:51 <dons> oh, thingie is now Hieroglyph. confusing
10:46:01 <dnul> byorgey: im sorry, i've got confused
10:46:17 <dnul> byorgey: Now i'll try to make it using an array
10:46:33 <byorgey> dnul: ok.  if you get stuck paste your code on hpaste.org and ask for help =)
10:46:48 <dnul> thank you
10:47:56 <byorgey> dons: yeah, I think Jeff wanted to release it before he had come up with a name, so he just called it "Thingie"
10:48:06 <byorgey> definitely confusing =)
10:48:41 <aconbere> so... I'm getting stumped on a some typing here. I have a Vector type that has there data elements. I'd like those data elements to be essentially Floats, (divisible for instance)
10:48:54 <aconbere> so I defined it data Vector = Vector Float Float Float deriving (Eq, Show)
10:49:18 <byorgey> aconbere: Double is more common than Float, but that looks OK
10:49:31 <aconbere> ah, well when I impliment a scaler division function
10:49:38 <aconbere> it's not happy about passing an Int in
10:49:42 <dons> always use ! on those kind of types, and -funbox-strict-fields
10:49:51 <byorgey> aconbere: of course not, you can't divide by Ints =)
10:49:54 <dons> data Vector = Vector !Double !Double !Double
10:50:02 <byorgey> aconbere: apply fromIntegral to it first, to convert it to a Float
10:50:08 <byorgey> @quote fromIntegral
10:50:09 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
10:50:09 <aconbere> hmmm
10:50:13 <dons> mm
10:50:46 <byorgey> aconbere: do you really only want to be able to do scalar division by an Int, instead of by a general Float?
10:51:06 <aconbere> byorgey: I want to be able to divide the number in my Vector
10:51:07 <duaneb> is there a 'real' pi value?
10:51:14 <duaneb> I.e. a value where pi is lazily computed?
10:51:15 <aconbere> I don't care if they're floats or whatever :)
10:51:21 <duaneb> in haskell's stdlib?
10:51:39 <opqdonut> duaneb: look at this
10:51:45 <opqdonut> > pi :: CReal
10:51:47 <lambdabot>   3.1415926535897932384626433832795028841972
10:51:58 <Taejo> what is CReal?
10:52:03 <opqdonut> CReals are "Computable Reals"
10:52:03 <byorgey> duaneb: not in the stdlib, but in some packages on Hackage there is
10:52:08 <aconbere> byorgey: I started by defining a type variable so my vector class was definably some kind of numeric type (usually specified with a Num)
10:52:13 <byorgey> which package is CReal in again?  numbers?
10:52:20 <aconbere> byorgey: but found that I had to start really doing nasty annotations
10:52:32 <opqdonut> CReals are basically lazy generators for the decimal expansion
10:52:36 <opqdonut> arbitrary precision
10:52:45 <dolio> Yes, numbers.
10:52:47 <byorgey> aconbere: well, Num in general doesn't support division
10:53:01 <byorgey> aconbere: if you want something that supports division you should use Floating instead
10:53:06 <aconbere> byorgey: I know... so things started bying (Num t, Floating t)
10:53:11 <byorgey> right =)
10:53:26 <aconbere> byorgey: so then I was like... well... why not just make Vector floats
10:53:31 <byorgey> note that anything that is Floating must also be Num
10:53:34 <aconbere> but now I have this issue with Ints
10:53:48 <byorgey> aconbere: note also that Float is not the same as Floating
10:53:53 <aconbere> Ooooo
10:54:00 <byorgey> Float is the type of single-precision floating point numbers
10:54:09 <byorgey> Floating is a type class of things that support division.
10:54:15 <byorgey> Float and Double are both instances of Floating
10:54:22 <Taejo> :t (/)
10:54:23 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:54:31 <byorgey> oh, Fractional.
10:54:35 <Taejo> :t pi
10:54:36 <byorgey> I always get those confused.
10:54:36 <lambdabot> forall a. (Floating a) => a
10:54:42 <dolio> @src Floating
10:54:42 <lambdabot> class  (Fractional a) => Floating a  where
10:54:42 <lambdabot>     pi                                                      :: a
10:54:42 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
10:54:42 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
10:54:42 <lambdabot>     (**), logBase                                           :: a -> a -> a
10:54:42 <opqdonut> yeah, floating is for exp and so on
10:54:49 <byorgey> ah, right
10:55:00 <Taejo> @src atan2
10:55:02 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:55:07 <byorgey> for example, Rational is an instance of Fractional but not Floating
10:55:17 <dolio> Floating is for a bunch of stuff that doesn't necessarily have to do with floating point representation. :)
10:55:21 <byorgey> right =)
10:55:24 <Taejo> :t atan2
10:55:25 <lambdabot> forall a. (RealFloat a) => a -> a -> a
10:55:31 <Taejo> @src RealFloat
10:55:32 <lambdabot> Source not found. It can only be attributed to human error.
10:55:38 <byorgey> seems like it ought to be called 'Real' instead of Floating.
10:55:44 <byorgey> but, of cousre, Real is something else.
10:55:53 <byorgey> I forget what.
10:55:54 <duaneb> haskell has arbitrary precision reals, right>?
10:55:57 <dolio> > pi :: Complex Float
10:55:58 <lambdabot>   3.1415927 :+ 0.0
10:56:01 <byorgey> duaneb: not built-in, no.
10:56:04 <Taejo> duaneb: in a library
10:56:07 <byorgey> but there are libraries for that.
10:56:08 <duaneb> ...it links to GMP
10:56:09 <aconbere> okay... family time
10:56:17 <aconbere> I might go bug you about how to do this later :)
10:56:22 <byorgey> duaneb: that's for arbitrary-precision integers.
10:56:40 <byorgey> does GMP do stuff with arbitrary-precision reals too?
10:56:46 <byorgey> if so, Haskell doesn't use that part
10:57:06 <byorgey> > 2^9999
10:57:07 <lambdabot>   997531558440379192441871081341792541911748415943096227426004474926471941511...
10:57:09 <Olathe> CReal can be downloaded.
10:57:23 <Olathe> @where creal
10:57:24 <lambdabot> I know nothing about creal.
10:57:28 <duaneb> byorgey: gmp does indeed use arbitrary precision rals
10:57:29 <duaneb> reals*
10:57:52 <Olathe> @where ghc
10:57:53 <lambdabot> http://haskell.org/ghc
10:57:54 <Philonous> lambdabot just gave me a listing of it's working directory.
10:58:16 <Philonous> It shouldn't do that, should it?
10:58:46 <Olathe> @where creal
10:58:46 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
10:58:49 <Olathe> There we go.
10:59:14 <redditbot> Haskell Weekly News: December 25, 2008 | The Haskell Sequence
10:59:38 <Olathe> Philonous: Nope.
10:59:48 <Olathe> Philonous: Let Cale know, please.
11:00:31 <Philonous> Cale: ping
11:00:47 <Philonous> How can I reach him/her?
11:00:51 <Olathe> @help tell
11:00:52 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:01:06 <Philonous> Ok, thanks
11:01:15 <pyNem> what exactly does return () mean .. for a list of Ints say?
11:01:23 <Olathe> Philonous: In private with lambdabot, you can do @tell Cale I got lambdabot to tell me ... by ...
11:01:38 <pyNem> how is it different from [] (mzero for the list monad)
11:01:38 <Olathe> > return () :: [Int]
11:01:39 <lambdabot>   Couldn't match expected type `Int' against inferred type `()'
11:02:08 <Olathe> > return () :: [()]
11:02:09 <lambdabot>   [()]
11:02:11 <pyNem> If it helps, I am trying to understand guard
11:02:35 <Olathe> I haven't really learned guard yet.
11:02:38 <pyNem> > concat [ [3], [()] ]
11:02:39 <lambdabot>       No instance for (Num ())
11:02:39 <lambdabot>        arising from the literal `3' at <intera...
11:02:57 <pyNem> oh .. Olathe no issue then :)
11:03:19 <TML> :t pi
11:03:20 <lambdabot> forall a. (Floating a) => a
11:03:24 <TML> cool :)
11:03:42 <opqdonut> pyNem: the return value of () is not really used anywhere
11:03:48 <pyNem> opqdonut, ok ..
11:03:54 <Olathe> > showCReal 100 pi
11:03:55 <opqdonut> the failure is return-value independent
11:03:56 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
11:03:59 <opqdonut> see:
11:04:07 <pyNem> How does it help with the concatMap that the list monad uses
11:04:18 <opqdonut> > guard (1==0) >> return 1 :: Maybe Int
11:04:19 <lambdabot>   Nothing
11:04:24 <pyNem> if the guard fails .. it returns ()
11:04:25 <opqdonut> > guard (1==1) >> return 1 :: Maybe Int
11:04:27 <lambdabot>   Just 1
11:04:35 <opqdonut> pyNem: no, if it pases, it returns ()
11:04:38 <opqdonut> and execution continues
11:04:45 <opqdonut> if it fails, it fails in some monad-dependent way
11:04:51 <opqdonut> for example the Nothing above
11:04:55 <pyNem> sorry.. yeah ..
11:05:01 <pyNem> how does execution continue?
11:05:12 <pyNem> because of return () >>= f not being a constant
11:05:15 <opqdonut> well, with ">>" so to speak
11:05:19 <pyNem> whereas mzero >>= f = mzero
11:05:22 <ski_> > guard (1==0) >> error "boo !" :: Maybe Int
11:05:22 <pyNem> ?
11:05:23 <lambdabot>   Nothing
11:05:48 <opqdonut> pyNem: if guard is on a row of it's own in do-notation, the next row is combined to it with >>
11:05:57 <Taejo> I'm looking for a very fast RNG (low-quality is fine)
11:06:00 <opqdonut> if you want >>= you need to do x<-guard foo
11:06:01 <ski_> @src guard
11:06:01 <lambdabot> guard True  =  return ()
11:06:01 <lambdabot> guard False =  mzero
11:06:02 <opqdonut> which you never see
11:06:08 <pyNem> opqdonut, oh .. I got it :) .. basically once an mzero is created .. it propogates through the >>=
11:06:14 <opqdonut> yep
11:06:16 <pyNem> and you get only an mzero
11:06:19 <dons> http://www.reddit.com/r/programming/comments/7lo8x/hayoo_very_fancy_haskell_api_search_using_ajax/ hayoo is underappreciated
11:06:31 <opqdonut> Taejo: use a linear congruential generator, with constants from TAOCP or so
11:06:32 <pyNem> however with the return () >> return (what you normally would) you get the value you desire
11:06:37 <pyNem> thanks opqdonut :)
11:06:47 <opqdonut> pyNem: exactly :)
11:06:49 <byorgey> pyNem: right, think of return () as a no-op
11:06:49 <Olathe> @hayoo Int -> [a] -> a
11:06:49 <lambdabot> Unknown command, try @list
11:06:56 <opqdonut> Taejo: or then just the Prelude one
11:07:04 <Olathe> @where hayoo
11:07:04 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:07:05 <opqdonut> Taejo: or have you found it too slow?
11:07:24 <pyNem> byorgey, yup :) ..
11:07:33 <pyNem> ok .. so ()::a for all a?
11:07:33 <Taejo> opqdonut: I'm coding in C, and my program is basically a random walk
11:07:42 <opqdonut> pyNem: no, ()::()
11:07:52 <opqdonut> but mzero :: m a for all a
11:07:55 <Taejo> so the speed is directly related to the speed of rand
11:07:56 <opqdonut> (and m a monad)
11:08:05 <Taejo> :t mzero
11:08:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
11:08:06 <opqdonut> Taejo: oh okay, linear cong it is then
11:08:14 <baaba> :t ()
11:08:15 <lambdabot> ()
11:08:16 <TML> Taejo: MT is pretty fast, as I understand it
11:08:25 <opqdonut> MT is complex to code
11:08:27 <pyNem> opqdonut, so I cant have functions like f n = if n == 2 then 2 else ()
11:08:28 <opqdonut> but yeah, fast
11:08:35 <pyNem> obviously
11:08:44 <baaba> pyNem, () is a type, and () is the only value of that type
11:08:45 <opqdonut> Taejo: see http://en.wikipedia.org/wiki/Linear_congruential_generator
11:08:52 <Taejo> opqdonut: thanks
11:08:59 <baaba> it's not a null value or anything
11:09:03 <baaba> it's a type like any other
11:09:10 <opqdonut> well put :)
11:09:31 <byorgey> pyNem: right, you can't.  the reason  return ()  works in the middle of a do-block is that the type of the return value can be different for each line.
11:09:32 <opqdonut> yeh, if you want a "null", you should use a monad, for example Maybe
11:09:34 <byorgey> @type >>=
11:09:35 <lambdabot> parse error on input `>>='
11:09:38 <byorgey> @type (>>=)
11:09:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:09:42 <pyNem> byorgey, oh .. :)
11:09:50 <opqdonut> @type (>>)
11:09:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:09:55 <pyNem> that cleared everything up .. no wonder monads have to be parametrised
11:09:56 <byorgey> note that the 'a' and 'b' are different in the type of (>>=)
11:10:00 <opqdonut> see, the a get's thrown out
11:10:01 <pyNem> baaba, yup.. got that now
11:10:09 <byorgey> so 'a' could be ()  and 'b' could be a different types
11:10:12 <byorgey> *type
11:10:36 <byorgey> pyNem: right, exactly =)
11:10:38 <baaba> :t return ()
11:10:39 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
11:11:09 <opqdonut> :t return () >> return 1
11:11:10 <lambdabot> forall (m :: * -> *) t. (Num t, Monad m) => m t
11:11:37 <opqdonut> you use >> with guard because you only care about the side effects
11:11:42 <opqdonut> just like print
11:11:44 <opqdonut> :t print
11:11:45 <lambdabot> forall a. (Show a) => a -> IO ()
11:12:29 <luqui> is it a law that mzero >> a = mzero ?
11:12:53 <luqui> yes.
11:13:33 <Olathe> @src (>>)
11:13:33 <lambdabot> m >> k      = m >>= \_ -> k
11:13:54 <ski_> @wiki MonadPlus
11:13:55 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
11:14:01 <ski_> @wiki MonadPlus_Reform_Proposal
11:14:02 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_Reform_Proposal
11:14:25 <opqdonut> dead link
11:14:34 * BMeph really wishes do and fail were in MonadZero.
11:14:35 <Taejo> it seems glibc uses in LCM in its rand() implementation anyway
11:14:54 <opqdonut> BMeph: do??
11:14:59 <ski_> opqdonut : er, right, that second should be
11:15:15 <ski_> @wiki MonadPlus_reform_proposal
11:15:15 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
11:15:20 <opqdonut> Taejo: ah, heh :)
11:15:29 <opqdonut> well you could gain something by inlining
11:15:46 <Olathe> @wiki Special:Version
11:15:46 <lambdabot> http://www.haskell.org/haskellwiki/Special:Version
11:15:56 <ski_> @where MonadPlus
11:15:57 <lambdabot> I know nothing about monadplus.
11:16:16 <ski_> @where+ MonadPlus <http://www.haskell.org/haskellwiki/MonadPlus>,<http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal>
11:16:17 <lambdabot> Done.
11:16:29 <Olathe> @where MonadPlus
11:16:30 <lambdabot> <http://www.haskell.org/haskellwiki/MonadPlus>,<http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal>
11:16:44 <Olathe> mIRC can't handle that.
11:16:59 <Olathe> It goes to http://www.haskell.org/haskellwiki/MonadPlus>,<http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal>
11:17:46 <Olathe> @where MonadPlus
11:17:47 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus or http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
11:17:54 <gwern> byorgey: you messed up your email
11:17:59 <gwern> byorgey: the workign link is http://sequence.complete.org/hwm/20081225
11:18:02 <gwern> not hwn
11:18:39 <BMeph> opqdonut: do uses fail, but doesn't tell you about it. Therefore, I want to throw do on the MZero heap (and not tell _it_). ;)
11:19:22 <byorgey> gwern: whoops!  thanks, should be fixed now
11:19:35 <byorgey> I messed up the link, not the email =)
11:19:53 <duaneb> haskell files can be ut8, no?
11:19:54 <byorgey> Haskell Weekly... Musings?
11:20:32 <dnul> amap not in scope , what module should i import?
11:21:08 <byorgey> @index amap
11:21:09 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
11:21:25 <byorgey> probably Data.Array.IArray
11:21:32 <arcatan> what's loquacracy?
11:22:16 <byorgey> arcatan: a system of government in which power is derived from verbosity =)
11:22:26 <byorgey> @wn loquacious
11:22:28 <gwern> 'augustss: ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.'
11:22:34 <gwern> @quote deleted
11:22:36 <lambdabot> *** "loquacious" wn "WordNet (r) 2.0"
11:22:36 <lambdabot> loquacious
11:22:36 <lambdabot>      adj : full of trivial conversation; "kept from her housework by
11:22:36 <lambdabot>            gabby neighbors" [syn: {chatty}, {gabby}, {garrulous},
11:22:36 <lambdabot>            {talkative}, {talky}]
11:22:38 <lambdabot> No quotes match. Sorry.
11:22:59 <luqui> gwern, that's my favorite quote this week :-)
11:23:16 <gwern> @remember augustss ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
11:23:16 <lambdabot> Okay.
11:23:20 <gwern> @quote deleted
11:23:20 <lambdabot> augustss says: ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
11:23:25 <gwern> @flush
11:23:35 <BMeph> arcatan: Or to be less loquacious about it, "Rule by the chattiest". :)
11:23:35 <arcatan> good to know
11:24:20 <dnul> byorgey: ERROR "/usr/lib/hugs/packages/hugsbase/Hugs/ST.hs":51 - Syntax error in type expression (unexpected `.')
11:24:34 <dnul> when importing data.IArray
11:24:54 <BMeph> dnul: Hugs is de Debbil! ;p
11:25:00 <dnul> hahaha
11:25:03 <byorgey> dnul: weird.
11:25:03 <PeakerWork> hugs also can't define "data" :-(
11:25:14 <gwern> people still use hugs?
11:25:20 <byorgey> dnul: wait, importing "data.IArray" ?
11:25:27 <byorgey> dnul: that should be "Data.Array.IArray"
11:25:39 <byorgey> or were you just abbreviating?
11:25:40 <dnul> import Data.Array.Iarray
11:25:52 <dnul> yep
11:26:01 <PeakerWork> gwern: I just apt-got it to see if it could handle "data"
11:26:26 <byorgey> dnul: well, weird, it looks like an error in the Hugs libraries
11:26:29 <dnul> what do you use instead of hugs?
11:26:33 <byorgey> dnul: I recommend using ghc instead
11:26:45 <dnul> okey no problem
11:26:47 <dnul> thx
11:27:01 <luqui> however, dnul is looking for a way to define data types in the repl, which neither can do :-(
11:27:30 <dnul> what is the repl?
11:27:33 <byorgey> huh?
11:27:41 <PeakerWork> dnul: The interactive shell
11:27:45 <byorgey> dnul: Read-Eval-Print-Loop
11:27:59 <dnul> hahah
11:28:09 <byorgey> I don't think that's what dnul was trying to do... is it?
11:28:38 <gwern> data types in the repl? but you can't define datatypes in the function which is the repl
11:28:40 <dnul> no , i was trying to use the amap function on an array
11:28:52 <byorgey> ok, right, that's what I thought
11:29:12 <byorgey> dnul: what OS are you using?
11:29:18 <dnul> ubuntu
11:29:31 <byorgey> dnul: ok, you can just  apt-get install ghc6
11:29:46 <dnul> done :P
11:29:56 <byorgey> and you may want a few other libraries which all start with  libghc6-*
11:30:06 <byorgey> but you can probably install those as you need them
11:30:19 <dnul> byorgey: will do
11:30:50 <PeakerWork> gwern: why not?
11:30:58 <PeakerWork> gwern: compile them and load them into the "environment" of the REPL
11:31:03 <PeakerWork> gwern: that the REPL sees
11:31:44 <PeakerWork> I see problems with the fact that ghci is a "single-pass" over your statements, whereas a file is multi-pass, so recursive data-types will be a bit of a problem..  ghci could allow definition "blocks" (instead of semicolon one liners)
11:32:10 <Cale> Though, ubuntu still has 6.8.2 or 6.8.3 iirc. You might want to consider downloading the generic linux binary for 6.10 at some point.
11:32:10 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:32:29 <gwern> PeakerWork: because ghci is just engineered to be the guts of an IO monad
11:32:58 <gwern> this is why stuff like 'x <- readFile foo' make any sense in it
11:33:25 <PeakerWork> gwern: it can bind the compiled (IO a) actions into its own main, sure
11:33:39 <gwern> is this ideal? probably not, but a hybrid of a module toplevel with the guts of a io monad is an odd beast and noone's gotten aroudn to it apparently
11:34:16 <pyNem> Just a doubt .. why are there both rem and mod in the prelude which do the same thing?
11:34:28 <Olathe> pyNem: They handle negative inputs differently.
11:34:29 <PeakerWork> > -2 `rem` 3
11:34:30 <luqui> > (-3) `rem` 2
11:34:30 <lambdabot>   -2
11:34:31 <lambdabot>   -1
11:34:33 <PeakerWork> > -2 `mod` 3
11:34:34 <lambdabot>   -2
11:34:43 <luqui> watch your precedence
11:34:43 <PeakerWork> > (-3) `mod` 2
11:34:44 <lambdabot>   1
11:34:53 <PeakerWork> > (-2) `mod` 3
11:34:55 <lambdabot>   1
11:34:55 <pyNem> Olathe, oh :) ..
11:34:56 <Olathe> Or your precedence will watch YOU !
11:35:09 <PeakerWork> mod makes sense, and "rem" is kinda useless :-)
11:35:26 <newtohaskell> in bytestring documentation says that it implements read but just importing Data.ByteString.Lazy doesn't help. do i need to import anything else?
11:35:27 <luqui> rem compiles to a single machine instruction though, so if you absolutely need the speed...
11:35:30 <pyNem> PeakerWork, seems so
11:35:33 <pyNem> :)
11:35:34 <PeakerWork> > (-3) `quot` 2
11:35:35 <lambdabot>   -1
11:35:38 <PeakerWork> > (-3) `div` 2
11:35:39 <lambdabot>   -2
11:35:57 <pyNem> > :t quot
11:35:58 <lambdabot>   <no location info>: parse error on input `:'
11:36:02 <PeakerWork> :t quot
11:36:03 <lambdabot> forall a. (Integral a) => a -> a -> a
11:36:40 <PeakerWork> @check \x y -> (x `quot` y) * y + (x `rem` y) == x
11:36:41 <lambdabot>   "* Exception: divide by zero
11:36:43 <pyNem> thanks @ PeakerWork :)
11:36:53 <PeakerWork> @check \x y -> if x == 0 then x else (x `quot` y) * y + (x `rem` y) == x
11:36:54 <lambdabot>       No instance for (Integral Bool)
11:36:54 <lambdabot>        arising from a use of `quot' at ...
11:37:02 <PeakerWork> @check \x y -> if y == 0 then x else ((x `quot` y) * y + (x `rem` y) == x)
11:37:03 <lambdabot>       No instance for (Integral Bool)
11:37:03 <lambdabot>        arising from a use of `quot' at ...
11:37:10 <PeakerWork> @check \x y -> if y == 0 then True else ((x `quot` y) * y + (x `rem` y) == x)
11:37:11 <lambdabot>   "OK, passed 500 tests."
11:37:13 <luqui> do people not know about ==>
11:37:18 <PeakerWork> @check \x y -> if y == 0 then True else ((x `quot` y) * y + (x `mod` y) == x)
11:37:19 <lambdabot>   "Falsifiable, after 12 tests:\n-2\n3\n"
11:37:24 <PeakerWork> @check \x y -> if y == 0 then True else ((x `div` y) * y + (x `mod` y) == x)
11:37:25 <lambdabot>   "OK, passed 500 tests."
11:37:31 <luqui> @check \x y -> y /= 0 ==> ((x `quot` y) * y + (x `rem` y) == x)
11:37:31 <PeakerWork> @type (==>)
11:37:32 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:37:32 <lambdabot>           ...
11:37:33 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
11:37:47 <PeakerWork> luqui: I don't yet use Quickcheck much, its my first ever @check called :)
11:37:57 <luqui> oh.  it's quite addictive.
11:38:03 <dcoutts> C-Keen: did you manage to install the package you wanted in the end?
11:38:27 <C-Keen> dcoutts: I am building 6.8.3 right now
11:38:40 <C-Keen> dcoutts: is it possible to use cabal-install with 6.6?
11:38:46 <PeakerWork> @check (\f g x y -> y /= 0 ==> ((x `f` y) * y + (x `g` y) == x)) div mod
11:38:47 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:38:47 <lambdabot>           ...
11:38:50 <dcoutts> C-Keen: yes, that's the min version
11:39:21 <C-Keen> dcoutts: ok, then what should I do about that 'ghc-prim' missing message?
11:39:22 <PeakerWork> how do you use ==> there then?
11:39:50 <dcoutts> C-Keen: ghc-prim is a package that comes with ghc-6.10, however in previous versions the 'ghc-prim' package was part of the 'base' package
11:40:24 <dcoutts> C-Keen: so what that means is that you might be able to make changes to the package to enable it to build with ghc older than 6.10
11:40:52 <C-Keen> dcoutts: hm, ok
11:40:53 <dcoutts> C-Keen: first step would be to remove ghc-prim from the build-depends and try building and see what compile issues you run into
11:41:16 <C-Keen> a lot of packages depend on ghc >6.6 it seems
11:41:16 <newtohaskell> never mind my bad.
11:42:06 <duaneb> ok
11:42:07 <duaneb> help
11:42:12 <defun> Hi. What is the difference between a type constructor, value constructor, and data constructor?
11:42:13 <dcoutts> C-Keen: 6.8.x has been the standard version everyone's been using for the last year or so, 6.10 is relatively new
11:42:20 <duaneb> how can I store a vairable in the middle of a 'do' block?
11:42:42 <C-Keen> dcoutts: I see
11:42:50 <duaneb> I mean
11:42:51 <C-Keen> dcoutts: thanks for your explanation!
11:43:01 <maltem> defun: a type constructor gives you a type, a data constructor constructs data of some type
11:43:05 <duaneb> you can use the '<-' operator for storing the results of monads
11:43:05 <duaneb> but
11:43:30 <defun> maltem: and value constructor?
11:43:43 <maltem> defun: possibly synonymous to data constructor
11:43:56 <defun> maltem: thanks
11:44:38 <Gracenotes> > do { a <- [1,c]; b <- [3,4]; return (a,b) } where c = 2
11:44:40 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
11:44:55 <Gracenotes> @duaneb
11:44:55 <lambdabot> Unknown command, try @list
11:45:01 <Gracenotes> uh, heh
11:45:13 <duaneb> thanks
11:45:15 <augustss_> > do { a <- [1,c]; b <- [3,4]; return (a,b) }
11:45:15 <byorgey> duaneb: use 'let'
11:45:17 <lambdabot>   [(1,3),(1,4),(c,3),(c,4)]
11:45:35 <duaneb> so '<-' is not restricted to monads?
11:45:39 <duaneb> I thought I was learning something :/
11:45:45 <byorgey> > do {a <- [1..3]; let b = a^2 + 1; return (a,b)}
11:45:46 <lambdabot>   <no location info>: parse error on input `}'
11:45:47 <byorgey> duaneb: it is.
11:45:53 <augustss_> duaneb: yes it is
11:45:55 <Gracenotes> "let" also works... where and let are essentially equivalent (except one is an expression and one isn't)
11:46:14 <Gracenotes> also, duaneb, if the value depends on the result of other things in the monad, then it should be in a monad. Just do something like a <- return (your expression), I think
11:46:16 <BMeph> Has there been any interest expressed in a 'mapWithIndex'-style function? :)
11:47:00 <Gracenotes> there might be a cleaner way to do it depending on what the expression is... :/
11:47:52 * BMeph 'Never-Minds' himself and goes to the GHC Trac...
11:49:01 <centrinia> Would someone with no programming experience find imperative programming to be more intuitive than functional programming or vice versa?
11:49:34 <duaneb> I've thought about this
11:49:39 <Gracenotes> centrinia: are they a mathematician? ;) (don't quite know, though)
11:49:44 <duaneb> and it does make more sense to the way the human mind works
11:49:51 <duaneb> I mean, think about driving instructions
11:49:56 <duaneb> they're given in an imperative manner
11:49:57 <twanvl> I think functional programming is more intuitive, in my experience it takes a *lot* of effort to understand mutable variables
11:50:21 <duaneb> I think that the functional programming mindset is more intuitive to *mathematicians*
11:50:33 <centrinia> That makes sense.
11:51:04 <Gracenotes> it seems to me that each monad bind adds an additional closure. Similarly, you can think of imperative programming as each assign statement adding a new "closure" where everything up to a point is in the scope of everything before it.
11:51:04 <centrinia> I've seen some math students get worried with the expression { x = x + 1; }
11:51:07 <bd_> Or those with that sort of mindset :)
11:51:09 <duaneb> Also, I find myself frustrated that I can't control the flow of the program when I program in a functional manner for too long
11:51:18 <Gracenotes> in that sense, the "do" statement makes sense. does that seem right?
11:52:45 <mattam> duaneb: why would you care about the flow? it's the values that matter :)
11:52:45 <bd_> Gracenotes: well, the difference between monad bind and mutating assignment is the latter tends to persist over flow control structures
11:53:29 <Gracenotes> yes. It would match more closely to a relatively simple model of imperative programming where everything is either an assignment or a statement
11:56:17 <Olathe> @botsmack
11:56:17 <lunabot>  :)
11:56:17 <Olathe> > 45
11:56:18 <duaneb> mattam: if something is slow and you don't know why because you're unsure how the compiler treats the code, then you want to control the flow
11:56:18 <duaneb> that's when I switch to c :P
11:56:18 <lambdabot> :)
11:56:18 <lambdabot>   45
11:56:18 <duaneb> where you can hand compile the code if you so wish
11:56:22 <Asztal> BMeph: if I want a mapWithIndex function, I generally just zip with [0..].
11:59:05 <BONUS> lol http://hackage.haskell.org/trac/ghc/ticket/2884
11:59:07 <BONUS> this is lol
12:01:12 <Botje> what does the name of a function have to do with the inliner :/
12:01:36 <mattam> duaneb: of course, the computation model is more complicated.
12:02:52 <Botje> @pl mapWithIndex f l = map (uncurry f) $ zip [0..] l
12:04:36 <BONUS> epic split
12:04:56 <BONUS> hmm. i often wish filterIndex was in the standard libs
12:05:22 <Saizan> type?
12:05:32 <BONUS> lets see
12:05:50 <BONUS> (Num a) => (a -> Bool) -> [b] -> [b]
12:05:53 <BONUS> i think
12:06:05 <BONUS> basically keep the elements whose index satisfies the predicate
12:06:15 <BONUS> wait, make that Integral
12:06:38 <Saizan> ?src Integral
12:07:16 <asgaroth> Aren't list indices always Int?
12:07:27 <nolrai_East> Whats the best way to split a list in half?
12:07:40 <luite> nolrai_East: in which halves? :)
12:08:09 <Saizan> list indices are whatever you want them to be
12:08:12 <opqdonut> nolrai_East: don't use a list if you want to split it into a front and rear half ;)
12:08:13 <asgaroth> nolrai_East: splitAt (length lst `div` 2) if you want to split it in the middle
12:08:36 <opqdonut> splitting into odd and even indices is nicer
12:08:37 <BONUS> let filterIndex p xs = map snd . filter (p . fst) . zip [0..] $ xs
12:08:39 <BONUS> something like this
12:08:40 <nolrai_East> luite: I'm changing a list into binary trie.
12:08:47 <BONUS> ah, this can be done with Num a, Enum a
12:09:17 <luite> nolrai_East: ah, you will probably need partition
12:09:44 --- mode: irc.freenode.net set +o ChanServ
12:09:47 <BONUS> nolrai_East: i just implemented a few trie functions a few days ago in haskell
12:09:51 <BONUS> i can show you them if you want
12:09:56 <nolrai_East> asgaroth: thanks
12:10:28 <lambdabot>   Couldn't match expected type `[a] -> Ordering'
12:10:38 <nolrai_East> BONUS: That would be cool.
12:11:11 <BONUS> http://hpaste.org/13325
12:11:15 <BONUS> :]
12:11:51 <BONUS> to convert a list into a trie, i just do foldr trieInsert emptyTrie
12:14:27 <nolrai_East> hmm
12:15:44 <smg> wtf is trie?
12:15:59 <BONUS> a tasty indonesian dish
12:16:01 <BONUS> j/k
12:16:01 <BONUS> http://en.wikipedia.org/wiki/Trie
12:16:48 <smg> ah prefix trie nice
12:17:38 <aconbere> If you want to use a typeclass (like Fractional) in a data type definition, how does one go about that?
12:18:35 <opqdonut> data Fractional a => Foo a = Bar a a Int
12:18:44 <opqdonut> if you want to qualify an argument type
12:18:56 <opqdonut> you can also do existential types like
12:19:06 <opqdonut> data Foo = Fractional a => Bar a a Int
12:19:23 <opqdonut> so that the concrete a is hidden, all you know is taht it is a Fractional
12:19:55 <twanvl> don't do that
12:20:34 <opqdonut> yeh the latter might get hairy
12:21:13 <twanvl> also, the first option is worse than useless
12:21:19 <paolino> mmh, how can it be useful in the first case ?
12:22:09 <aconbere> twanvl: do you have a recomendation?
12:22:42 <twanvl> just put the required contexts in the types of the functions that work with the data type
12:22:54 <aconbere> twanvl: I want to create a vector data type that stores elements that can be divided (by floats or ints or..)
12:22:54 <opqdonut> yeah you need them there too
12:23:22 <twanvl> aconbere: why can it only store those types?
12:23:42 <BONUS> usually making instances of the numeric typeclasses is tedious and tricky
12:24:11 <aconbere> twanvl: it doesn't have to, I would just rather avoid putting the type it takes in all my type definitions. And I keep running into weird stuff like Floats being Divided by ints errors :P
12:24:52 <aconbere> <- is new at this so, willing to accept that the "correct" way would be to annotate his functions
12:25:00 <aconbere> that just seemed exceptionaly tedious and error prone
12:25:14 <twanvl> aconbere: you will likely need the context in the functions' types regardless
12:25:35 <BONUS> try writing the data type without the class constraints and then just write the functions without the type declarations
12:25:41 <BONUS> and then check them out, see what they tell you :)
12:28:03 <mattam> Why is the second option problematic?
12:28:05 <chessguy> @bot
12:28:06 <lambdabot> :)
12:28:06 <lunabot>  :)
12:28:59 <BONUS> for instance if you have data Vector a = Vector a a a then you can do (Vector a b c) *^ scalar= Vector (a*scalar) (b*scalar) (c*scalar)
12:29:17 <BONUS> just introduce your own operators
12:29:34 <BONUS> interesting, i found it much easier to do a Vector class in python than in haskell :[
12:30:22 <BONUS> cause you could just overload the operators without worrying too much about types and you could check the type of the second operand of * to determine if you want a dot product or scalar multiplication
12:30:38 <aconbere> BONUS: that's basically the pain I'm going through right now
12:30:39 <aconbere> :)
12:31:09 <aconbere> and I'm running into other things I think of as "icky" like how that type variable extends out into other types I define using Vector
12:31:18 <BONUS> yeah basically making a vector data type and giving it easy operations like (Vector 1 2 3) * 4 is harder in haskell than it seems
12:31:24 <aconbere> like a Sphere type
12:31:35 <BONUS> its one of those weird cases
12:31:41 <aconbere> the sphere type takes a vector that's its center, and etc.
12:31:49 <BONUS> yeah but that's what kind of keeps the type system together though
12:31:51 <aconbere> but now my Sphere type class has to pass that type variable in
12:32:35 <nj32> Can anybody suggest a good book on number theory for self-learning? I know this is not the most appropriate place to ask but...
12:32:47 <aconbere> it feels like one of those things that's a pain while I'm learning, but not so bad once I'm more familiar with the type system
12:33:10 <aconbere> nj32: are you sure you want a number theory book? What are you trying to learn?
12:33:15 <mattam> You could define a Multiplication typeclass on a, b with an operation a -> b -> a and overload it for scalar multiplication and dot product. Not sure that's a terribly good idea to overload here.
12:33:28 <nj32> factorization, primality etc
12:33:41 <BONUS> mattam: yeah, thats one way, but then you have multiparam typeclasses
12:33:44 <BONUS> and maybe fundeps
12:33:59 <dolio> You want a -> b -> c
12:33:59 <mattam> Yes.
12:34:00 <BONUS> and it gets a bit hairy
12:34:18 <aconbere> hmmm
12:34:19 <dolio> So that Vector a -> Vector a -> a is possible.
12:34:31 <aconbere> nj32: I'm not seeing the book I used on amazon
12:34:33 <mattam> dolio: indeed.
12:35:09 <jsn> i think that it would be important to warn against   Float -> Float -> Int    and such
12:36:02 <jsn> the nice thing about explicit, lossy numeric conversions is you can't accidentally stick yourself with them
12:36:53 <nj32> aconbere: what book was it?
12:37:28 <mattam> Hence my remark about overloading not being the best idea here. Mathematical convention is not always the best guide.
12:38:18 <aconbere> nj32: if I could only remember :) (I'm not at home so can't grab it off my shelf). The springer series is really well liked, so their Elementry Number Theory is probably quite good.
12:39:30 <nj32> aconbere: okay
12:43:52 <jsn> mattam: with the infinite precision types, though, it would be fine
12:44:09 <jsn> mattam: if we could put them in separate classes, maybe that would be better
12:51:50 <jkff> Hmm, I was going to measure the timing of my program and now I can't find anything resembling java's 'System.currentTimeMillis()' in the standard libraries. Is there?
12:53:50 <jkff> Ouch, I found it myself.
12:53:56 <jkff> It's System.CPUTime.getCPUTime
12:57:22 <abuiles> Hello, I'm trying to run turbinado, I installed the missed dependencies with cabal, but it still say that there are missing, and it says the ones which I already installed.  any suggestion ?
13:03:07 <dolio> getCPUTime probably isn't the same as currentTimeMillis.
13:03:19 <dolio> Unless I'm forgetting what the latter is.
13:03:49 <dolio> getCPUTime tells you how much time your program has spent running, or something of the sort.
13:04:06 <dolio> Not wall clock time.
13:04:45 <dolio> Not sure if that includes time spent in system calls and the like.
13:05:38 <jleedev> ?index epochTime
13:05:39 <lambdabot> System.Posix.Time, System.Posix
13:05:41 <dolio> Of course, it may arguably be better for benchmarking certain things.
13:06:23 <gwern> abuiles: cabal install installs locally usually perhaps you need the --user option
13:07:56 <abuiles> gwern: Thanks, I'll check it
13:10:08 <dnul> cant import data.Array.IArray
13:10:23 <dnul> i get an error on one of the sentences , but it does work with data.Array
13:10:34 <dnul> wtf , i need to use amap
13:10:40 <dolio> It's Data.Array, not data.Array.
13:10:44 <jkff> Hey, is it true that I can't profile my program if at least one module that it uses is compiled without -prof?
13:11:07 <dnul> sorry, mistake ... it still doesnt work
13:11:30 <dolio> Not sure what the problem is, then.
13:11:45 <jkff> dolio: Sorry, missed your answer; I already figured out using getPOSIXTime
13:11:52 <dnul> import Data.Array.Base
13:11:52 <dnul> import Data.Array.MArray
13:11:52 <dnul> import Data.Array.IArray
13:11:55 <dnul> sorry
13:13:08 <jkff> The doc says "To make use of the profiling system all modules must be compiled and linked with the -prof option". That seems pretty shitty. Is there any way at all to profile something, apart from using -prof, then?
13:13:43 <dnul> sumdivs2 = array (1,10000) [(i, (sum.divisors) i) | i<-[1..10000]] works with Data.Array but doesnt with Data.Array.IArray
13:13:53 <dnul> any guess?
13:14:15 <blackdog> jkff: you can do it by hand-rolling some test harnesses and timing how long it takes. it's stone tools, though... why can't you recompile with -prof?
13:15:36 <jkff> Well, I guess I can, since the only thing the compiler complains about is PCRE and I can build it with -prof, but hey, why on earth should I recompile all third-party libraries?
13:15:48 <jkff> What if I have a hundred of them?
13:16:00 <dons> you have to compile prof versions of them.
13:16:02 <dolio> Have them build profiling libraries when you install them.
13:16:07 <dons> in normal cases, you'd have done that when you install htem.
13:16:12 <dons> assuming you're a dev of haskell.
13:16:16 <dons> cabal install -p foo
13:16:16 <blackdog> if you're doing active development, it's probably sensible to install prof versions - cabal-install has a flag for them
13:16:28 <Saizan> yeah, enable profiling by default in ~/.cabal/config
13:16:32 <dons> yup
13:16:46 <blackdog> that majestic stereo sound...
13:17:12 <ttt--_> does anyone like my haskell logo? http://img411.imageshack.us/img411/9608/hask2er1.gif  ;)
13:17:24 <dons> interesting
13:18:13 <jkff> Whoops, my network went down
13:18:24 <jkff> ...Let me take a look at the logs
13:19:29 <jkff> OK, so if I compile a library with -prof, it *won't* be slower unless I compile my main program with -prof?
13:19:43 <blackdog> jkff: yeah
13:19:52 <blackdog> it installs two versions of the libraries
13:19:59 <jkff> Thanks, that makes sense then.
13:20:43 <dolio> Saizan: What do you put in the config file to make it always build profiling libraries?
13:21:03 <dons> -- library-profiling: False
13:21:10 <dons> uncomment, change to True
13:21:39 <blackdog> dolio: heh, i'd just given up searching. thanks for asking :)
13:22:25 <Saizan> since 0.6 (iirc) cabal-install dumps commented defaults in the config file, so you can see all the options
13:22:49 <Saizan> when it first generate it, i mean
13:22:49 <dolio> Ah. I guess I already had one that prevented that.
13:22:55 <koeien> hi, i'm having a problem with FastCGI; runFastCGIConcurrent' fails with "FCGX_Accept_r failed with error code: -88"
13:23:39 <koeien> perror 88 => 'socket operation on non-socket'
13:24:02 <koeien> anybody any idea what causes this?
13:26:53 <jkff> Aargh, seems like most of the libraries I installed are without profiling... That's a pity that cabal can't reinstall other libraries with '-p' when building one dependent on them with '-p'
13:31:36 * jkff has rewritten his simple Java class file parser in Haskell and is investigating why it is N times slower than the java version
13:31:45 <dons> heh.
13:31:51 <dons> yeah, unacceptable for parsing.
13:31:56 <dons> you using Data.Binary?
13:32:04 <jkff> I'm using the strict ByteString
13:32:10 <dons> ok. should be fine.
13:32:17 <dons> as long as you don't do silly things:)
13:32:26 <jkff> And a hand-rolled parser monad, although a very simple one, and I don't do things like lookahead, the parsing is all linear
13:32:43 <dons> mm.
13:32:56 <_ar> jkff maybe buffer mode?
13:33:00 <dons> maybe use a proper parser for bytestrings, a la atto-parsec?
13:33:07 <dons> or Data.Binary..
13:33:13 <jkff> _ar: what do you mean?
13:33:18 <jkff> dons: what will they give me?
13:33:28 <dons> pre-tuned parser combinators for bytestrings
13:34:04 <jkff> All I do is mostly reading 16-bit words, dropping them off the beginning of the bytestring and reading 16-bit words and substrings from the middle of a bytestring
13:34:14 * jkff takes a look
13:34:59 <jkff> Hmm, compiling with -prof tells me that 65% of the (own, not even inherited) time is spent in a function that does very few by itself and is called very few times
13:35:31 <dons> add {-# SCC "foo" #-} pragmas to that function, to narrow it down
13:35:36 <dons> for examples, see the RWH chapter on profiling
13:36:10 <jkff> Oh yes, I forgot about SCC-ing the innerings of an expression.. Thank you, I'll try it
13:36:20 <dons> you can always ask for help on haskell-cafe@ too
13:36:21 <dnul> ghci cannot show IArray, how is de derive in show sentence?
13:36:30 <dons> anything along the lines 'this is slower than X' generally gets help :)
13:36:38 <_ar> jkff: like with hSetBuffering
13:36:39 <mmorrow> IArray is a class
13:36:41 <dons> dnul: hmm. toList it?
13:37:09 <Saizan> ?type listArray (0,1) [1,2]
13:37:11 <lambdabot> forall t t1. (Ix t, Num t1, Num t) => Array t t1
13:37:12 <jkff> _ar: I am using B.readFile where B is Data.ByteString
13:37:24 <mmorrow> or give it an explicit type that's an instance of Show
13:37:28 <jkff> And then I am using the zip-archive package. So there's nowhere to insert buffering
13:37:46 <_ar> jkff: what does hGetBuffering return?
13:37:46 <luite> I still have a problem with a package, that is about 1000x slower when I remove a test function (a function that I never use). I assume that this is because of specializations generated because of this test function, but I haven't been able to get it fast again using SPECIALISE pragma's. is there a way to find out exactly what's specialized?
13:37:54 <mmorrow> , listArray (0,1) [1,2]
13:37:56 <lunabot>  luna: No instance for (GHC.Show.Show (a t t1))
13:38:00 <mmorrow> , listArray (0,1) [1,2] :: Array Int Int
13:38:03 <lunabot>  array (0,1) [(0,1),(1,2)]
13:38:05 <dons> luite: oh yes, using ghc-core
13:38:09 <dons> or using ghc with the appropriate flags.
13:38:14 <dons> i recommend the ghc-core util
13:38:19 <dons> it will print what is specialised and how
13:38:40 <luite> oh, didn't know that it would show that info, thanks
13:39:06 <dnul> IArray has a elems method but doesnt work either
13:39:09 <dnul> get this error
13:39:31 <mmorrow> it probably needs to know what type in particular it's dealing with
13:39:43 <mmorrow> , return 42 :: [Int]
13:39:45 <lunabot>  [42]
13:39:47 <mmorrow> , return 42 :: Maybe Double
13:39:49 <lunabot>  Just 42.0
13:39:54 <mmorrow> , return 42 :: IO Float
13:39:56 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO GHC.Types.Float))
13:40:15 <mmorrow> each of those returns is a different function in actuality
13:41:03 <mmorrow> (and each of those 42s)
13:41:26 <dnul> ambiguous type variable i in the contraints 'Num I' 'Enum I' ...
13:41:43 <schme_> evenin'
13:41:49 <mmorrow> give you index an explicit type, like
13:42:07 <mmorrow> @type listArray (0,1::Int) [1,2::Double]
13:42:08 <lambdabot> Array Int Double
13:42:14 <mmorrow> @type listArray (0,1::Integer) [1,2::Double]
13:42:15 <lambdabot> Array Integer Double
13:42:26 <mmorrow> @type listArray (0,1) [1,2::Double]
13:42:26 <dnul> great , thx u
13:42:27 <lambdabot> forall t. (Ix t, Num t) => Array t Double
13:42:45 <mmorrow> np
13:47:01 <mmorrow> sweet, cryptol is freely downloadable
13:47:34 <dons> mmorrow: do a morrow-bot binding to the interpreter?
13:47:46 <dons> its purely functional, no side effects whatsoever
13:47:53 <mmorrow> dons: oh cool, that's an idea
13:48:02 <dons> the cryptol interpreter is basically ghci-ish
13:48:29 <mmorrow> nice. downloading it now
13:51:55 <Philonous> Can I use class restrictions in type synonyms??
13:52:18 <Philonous> -?
13:54:39 <aconbere> so, here's where my dividing stuff problems come from
13:54:41 <aconbere> http://paste.pocoo.org/show/96747/
13:54:49 <aconbere> if anyone can help me with that
13:55:02 <dons> using fromIntegral to promote integral values to floating ones?
13:55:55 <aconbere> well I'm not sure what's failing
13:56:05 <aconbere> or how to fix it
13:56:09 <aconbere> when I use fromIntegral
13:56:11 <aconbere> that fails too
13:56:44 <aconbere> http://paste.pocoo.org/show/96748/
13:58:07 * jkff sped up class file parser 2-fold by *correctly* using the zip-file API
14:00:50 <conal> does anyone here know how ghc's black-hole detection works or where i can look to find out?  i think it's being fooled by my unamb implementation, and i wonder how black-hole detection deals with concurrency.
14:01:17 <Heffalump> I was under the impression that it just marked thunks and checked for re-entering them.
14:01:24 <Heffalump> Also, I think a bug in that area was fixed quite recently.
14:01:35 <Heffalump> So you might want to check with HEAD if you're not already using that.
14:01:38 <mmorrow> conal: i know it doesn't work in ghci-6.10.1 with (e.g.) fix id
14:01:41 <mmorrow> yeah
14:02:08 <mmorrow> but the bug was only in bytecode i believe
14:02:47 <conal> mmorrow: oh, interesting.  maybe my code works fine when compiled.
14:06:09 <aconbere> dons: any ideas?
14:12:44 <mlesniak> Can anyone give me a hint (paper, blog, general link) how "ns = 1 : map (+1) ns" is evaluated? I understand it intuitively but can not come up with something semi-formal.
14:13:08 <vixey> if you want something unrelated to reality
14:13:10 <vixey> ns = 1 : map (+1) ns
14:13:18 <vixey>    = 1 : map (+1) (1 : map (+1) ns)
14:13:36 <vixey>    = 1 : 2 : (map (+1) (map (+1) ns))
14:13:39 <vixey> and so on..
14:13:55 <mlesniak> vixey: I see, but when does the 2 get calculated?
14:13:58 <vixey> just rewriting the equation over and over gives the right result
14:14:22 <vixey> mlesniak, that's the think about lazy evaluation, it doesn't matter/make sense to ask what order things are evaluated in
14:15:01 <mlesniak> vixey: yes, and that's what makes it a bit complicated coming from an imperative background :) But I'll play a bit with your rewriting, thanks
14:15:11 <mlesniak> s/imperative/strict/
14:15:22 <vixey> closer to reality, view all the equations edges of a graph
14:15:31 <vixey> evaluation is rewriting on the nodes of the graph
14:15:50 <vixey> (this makes a big diff. in complexity for fibs = zipWith (+1) fibs (tail fibs))
14:16:05 <mlesniak> hmmm, I see, any links to something more detailed?
14:16:16 <vixey> @go tail calls don't exist
14:16:18 <lambdabot> No Result Found.
14:16:48 <mlesniak> vixey: hmm
14:16:57 <vixey> first hit on google for: tail calls don't exist
14:16:59 <mlesniak> vixey: ok, will search for tail calls in google :)
14:17:12 <mlesniak> thanks!
14:17:13 <vixey>  not sure why lambdabot is objecting to it
14:17:21 <dnul> im sorry to keep you bothering with such noob stuff, i still cant get an IArray to show
14:17:44 <vixey> dnul, why don't you write a function to present it as a string instead of show
14:18:32 <dnul> i just want to make a list from it
14:19:07 <dnul> but elems method doesnt work
14:19:22 <dnul> can you give me a simple example
14:19:56 <vixey> :t elems
14:19:57 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
14:20:14 <vixey> @jargo  doesn't work
14:20:15 <lambdabot> No match for "doesn't".
14:20:15 <lambdabot> No match for "work".
14:21:07 <dnul> i want to generate an array from a list comprehenended list alike  listArray (1,100) [(i,i)| i<-[1..100]]
14:21:59 <dnul> then show it using elems
14:25:52 <wli> Don't arrays already have Show instances?
14:26:13 <dnul> arrays do , IArray dont
14:26:23 <dnul> arrays dont have amap
14:26:27 <BMeph> mlesniak: Here's a question for you? Why does it matter to you to know when it gets evaluated, as long as it gets evaluated at some time before you use it? :)
14:28:19 <jkff> Anyone know what does the 'guidance IF_ARGS 2 [6 0] 2 0' stuff from GHC inliner mean?
14:28:26 <mlesniak> BMeph: Just out of curiosity -- lazy evaluation has this touch of magic and brings a big WOW to my mind :)
14:29:16 <jkff> I have a couple of very small functions called very frequently, and they don't get inlined. May that be the case because they use ByteString functions? I was hoping that B.uncons will get reduced to 2-3 machine instructions
14:29:33 <xxgodsmackxx321> http://bux.to/?r=xxgodsmackxx321
14:31:16 <pumpkin> bah
14:32:56 <jkff> OK, a more general question then. Are library functions ever inlined in my code?
14:33:08 <jkff> Or do they remain function calls forever?
14:36:22 <ddarius> jkff: Yes, they are inlined.
14:36:43 <augustss_> they are sometimes inlined
14:36:54 <jkff> ddarius: Thanks, that revives my hope :) Why can it then be the case that even B.uncons is never inlined in my case?
14:37:33 <augustss_> the compiler has different criteria for inlining
14:39:02 * jkff reads the 1999 paper about GHC Inliner, but it must be very outdated already
14:39:25 <pejo> jkff, functions get inlined if they are "small" and not frequently used.
14:39:39 <pejo> jkff, there's a JFP paper from 2002 about it too, which is probably less outdated.
14:40:24 <jkff> Does 'frequently' mean 'frequently in time' or 'many times in the source'?
14:40:25 <Philonous> I think maybe the type of >>= should be relaxed to m a -> (a -> n b) -> n b for certain "related" monads m and n
14:40:57 <vixey> Philonous, did you prototype it?
14:41:00 <pejo> jkff, the paper gives a pretty good description of the heuristics, but if the compiler believes that the code size will increase too much it won't inline.
14:41:05 <pumpkin> jkff: I'd imagine many times in the source
14:41:45 <Philonous> That way for example list with type-encoded length could make use of the monad infrastructure
14:41:55 <afabian> Hmm.  Is this illegal?  ghci says possibly incorrect indentation: let x = 5; in let y = 6; in x * y  (I know there's no reason to do that; just playing around with what's possible, or .. not possible, as the case may be.)
14:41:56 <Philonous> vixey: No, just thinking about it
14:42:17 <afabian> (I didn't really use semicolons.)
14:42:23 <jkff> Hm, things still are strange: I've got a half-a-line function readByte = Parser $ \s -> fromJust (B.uncons s), it's used probably 10 times in the program, and it doesn't get inlined. Parser is a newtype.
14:42:34 <vixey> fromJust (B.uncons  nice
14:42:42 <roconnor> afabian: let {x = 5; in let y = 6;} in x * y
14:42:54 <roconnor> or let {x = 5; in let y = 6} in x * y
14:43:02 <roconnor> > let {x = 5; in let y = 6;} in x * y
14:43:03 <lambdabot>   <no location info>: parse error on input `in'
14:43:08 <roconnor> > let {x = 5; in let y = 6} in x * y
14:43:09 <lambdabot>   <no location info>: parse error on input `in'
14:43:13 <roconnor> oh oops
14:43:23 <roconnor> > let {x = 5; y = 6} in x * y
14:43:25 <lambdabot>   30
14:43:30 <roconnor> > let {x = 5; y = 6;} in x * y
14:43:32 <lambdabot>   30
14:43:42 <roconnor> > let x = 5 in let y = 6 in x * y
14:43:44 <lambdabot>   30
14:43:58 <afabian> Hmm.  I see.  Thanks.
14:44:14 <pumpkin> > let x = 5; y = 6 in x * y
14:44:15 <lambdabot>   30
14:44:22 <roconnor> oh
14:44:32 <roconnor> pumpkin: I didn't know that
14:44:46 <pumpkin> muahahahaha n00b r00lz
14:44:52 <pumpkin> :P
14:44:59 <roconnor> :D
14:45:09 <pumpkin> I wonder at what point I should stop calling myself a noob
14:45:17 <pumpkin> I guess once I have The Answer
14:45:34 <Gracenotes_> hm... is there a way to unwrap tuples via lambdas?
14:45:37 <roconnor> the answer to ... what is the monad?
14:45:48 <pumpkin> roconnor: not sure yet, once I have it I'll know though :)
14:45:52 <Gracenotes_> something like (\(a, b) -> something)
14:45:55 <roconnor> > (\(a,b) -> b) (1,2)
14:45:57 <lambdabot>   2
14:45:59 <pumpkin> I know what a monad is, but not The monad
14:46:00 <augustss_> Gracenotes_: exactly like that
14:46:07 <Gracenotes_> ...what? How did that not work for me before? heh
14:46:09 <Gracenotes_> thanks
14:46:18 * Gracenotes_ thanks uncurry and throws it away
14:46:20 <pumpkin> Gracenotes_: you can pattern match in lambdas too
14:46:29 <pumpkin> as you see :P
14:46:32 <dons> ?yow
14:46:32 <lambdabot> There is no TRUTH.  There is no REALITY.  There is no CONSISTENCY.
14:46:32 <lambdabot> There are no ABSOLUTE STATEMENTS.   I'm very probably wrong.
14:46:39 <roconnor> pumpkin: I wanted to say, "what is a monad?", but that didn't have the same Neo ring to it.
14:46:51 * Gracenotes_ eyes lambdabot suspiciously
14:47:03 <pumpkin> oh no, I "get" monads now, but I'm still missing The Answer
14:47:14 <roconnor> pumpkin: oh?
14:47:23 <roconnor> @what is The Answer
14:47:23 <lambdabot> I know nothing about is.
14:47:24 <jkff> pumpkin: Is 42 ok?
14:47:37 <pumpkin> jkff: oh sweet, now I'm not a haskell noob anymore
14:47:47 <pumpkin> > answer
14:47:48 <lambdabot>   42
14:48:05 <jkff> Wow
14:48:13 <mmorrow> > fix (const answer)
14:48:14 <lambdabot>   42
14:48:14 <jkff> > answer
14:48:16 <lambdabot>   42
14:48:28 <jkff> I didn't think that lambdabot was so knowledgeable
14:48:30 <pumpkin> > theAnswer
14:48:32 <lambdabot>   42
14:48:33 <Gracenotes_> pumpkin: it's easier if you think of monads as monoids, in a way ;)
14:48:39 <roconnor> > 42
14:48:41 <lambdabot>   42
14:48:42 <jkff> > question
14:48:43 <lambdabot>   Not in scope: `question'
14:48:45 <pumpkin> :o
14:48:50 <jkff> Haha
14:48:54 <pumpkin> I like me monoids fresh
14:48:59 <augustss_> > question
14:49:00 <lambdabot>   Not in scope: `question'
14:49:16 <Gracenotes_> yes, a computer hasn't calculated the question yet
14:49:19 <sereven> > Universe.Life.Everything.question
14:49:20 <lambdabot>       Failed to load interface for `Universe.Life.Everything':
14:49:21 <lambdabot>        Use -v ...
14:49:33 <mmorrow> > question
14:49:34 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:49:41 <pumpkin> it's probably stored in the IO monad's state though, somewhere
14:49:43 <jkff> Gracenotes: Probably with GHC 42.0?
14:49:58 <Gracenotes_> heh. any software that gets to version 42...
14:49:59 <Mr-Cat> Gracenotes_: It's difficult to think of monads as of monoids...
14:50:25 <Gracenotes_> Mr-Cat: monoid-like, then.
14:51:14 <jkff> Mr-Cat: In monoids, you compose two values like this: --| |--. In a monad, you stick one value into another: --> >--
14:51:22 <jkff> I mean, --> >-->
14:51:38 <jkff> And |--| |--| in monoids.
14:51:40 <pumpkin> ouch, that looks painful
14:51:50 <Mr-Cat> In fact I thought of monoids in algebra
14:51:58 <jkff> Me too
14:52:16 <jkff> In monoids the values have the same type and you just stick them together.
14:52:20 <Gracenotes_> one can think of a return/bind combination as (a -> m a) -> (a -> m b) -> (m b)
14:52:27 <mmorrow> @type \m f -> join (f `fmap` m)
14:52:28 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => m a -> (a -> m a1) -> m a1
14:52:29 <jkff> In monads, a value --> produces a parameter to feed into the >-->
14:52:41 <jkff> And together they produce a value ---->
14:52:52 <jkff> :t (>>=)
14:52:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:53:10 <Mr-Cat> Well, I see now
14:53:13 <mmorrow> @type \m f -> join (f `fmap` m) :: (Functor m, Monad m) => m a -> (a -> m b) -> m b
14:53:14 <lambdabot>     Inferred type is less polymorphic than expected
14:53:15 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
14:53:15 <lambdabot>         f :: a1 -> m a -> (a -> m b) -> m b (bound at <interactive>:1:3)
14:53:28 <pumpkin> tsk tsk, you never give it enough polymorphism mmorrow
14:53:33 <mmorrow> grr
14:53:35 <pumpkin> gotta be more generous
14:53:53 <mmorrow> @type (\m f -> join (f `fmap` m)) :: forall a b m. (Functor m, Monad m) => m a -> (a -> m b) -> m b
14:53:54 <lambdabot> forall (m :: * -> *) a b. (Monad m, Functor m) => m a -> (a -> m b) -> m b
14:54:12 <pumpkin> that's a pretty specific type you gave it there
14:54:19 <pumpkin> specific in its generality!
14:54:37 * mmorrow cues the after-joke-drum-thing
14:54:42 <Gracenotes_> jkff: what is the meaning of | and > in your notation?
14:55:36 <mmorrow> @pl \m f -> join (f `fmap` m)
14:55:37 <lambdabot> (join .) . flip fmap
14:55:45 <Gracenotes_> something like, | is a combination of symmetric types and > is a combination of composable types?
14:56:05 <jkff> Hmm. I think that a better analogy for monoids would be just --
14:56:09 <mmorrow> @type flip ((join .) . fmap)
14:56:10 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
14:56:21 <jkff> As for >, yes.
14:56:28 <mmorrow> @pl flip ((join .) . fmap)
14:56:29 <lambdabot> (>>=)
14:56:37 <mmorrow> @pl (join .) . flip fmap
14:56:37 <lambdabot> (join .) . flip fmap
14:56:39 <jkff> --> is a 'salted' --
14:56:43 <mmorrow> @pl (join .) . fmap
14:56:43 <lambdabot> (=<<)
14:56:49 <mmorrow> nice
14:57:18 <jkff> Ouch, I can't draw a convincing analogy :(
14:57:19 <Mr-Cat> Imho -- looks "too commutative"
14:57:26 <pumpkin> lol
14:57:49 <jkff> Yes, probably one just has to 'get it' :)
14:58:38 <Gracenotes_> (a -> m a) -> (a -> m b) is congruent to (a -> m b)... if that makes any sense, heh
14:58:54 <mmorrow> @type (>=>)
14:58:55 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:59:41 <mmorrow> @pl \f k -> (k =<<) . f
14:59:42 <lambdabot> flip ((.) . (=<<))
15:00:00 <mmorrow> @pl \f k a -> f a >>= k
15:00:01 <lambdabot> flip . ((>>=) .)
15:00:07 <pumpkin> that's the best thing ever, to compose the dot itself
15:00:16 <mmorrow> heh
15:00:24 <Gracenotes_> @type return 4 >>= return . negate
15:00:25 <lambdabot> forall b (m :: * -> *). (Monad m, Num b) => m b
15:00:47 <mmorrow> @type negate `fmap` return 4
15:00:48 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f, Num a) => f a
15:00:53 <ddarius> :t (.) . (.)
15:00:54 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:01:03 <pumpkin> I dare anyone to come up with a meaningful use of (.) . (.) . (.) . (.)
15:01:07 <mmorrow> @type fmap `fmap` fmap :: forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:01:09 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:01:32 <mmorrow> , (fmap . fmap . fmap) (*2) [[[0..4],[8..3]]]
15:01:34 <lunabot>  [[[0,2,4,6,8],[]]]
15:01:35 <Gracenotes_> ddarius: now now, isn't this a family-friendly channel?
15:02:37 <mmorrow> , (fmap . fmap . fmap . fmap) (*2) [[[0..4],[8..3]]]
15:02:39 <lunabot>  luna: No instance for (GHC.Enum.Enum (f a))
15:02:45 <mmorrow> , (fmap . fmap . fmap) (*2) [[[0..4],[8..3]]]
15:02:47 <lunabot>  [[[0,2,4,6,8],[]]]
15:02:49 <mmorrow> 'um
15:02:54 <mmorrow> wuh
15:03:07 <mmorrow> , (fmap . fmap . fmap) (*2) [[Nothing, Just 42]]
15:03:09 <lunabot>  [[Nothing,Just 84]]
15:03:49 <mmorrow> >  (fmap . fmap . fmap) (*2) [[[0..4],[8..3]]]
15:03:50 <lambdabot>   [[[0,2,4,6,8],[]]]
15:03:55 <mmorrow> wtf
15:04:00 <mmorrow> oh
15:04:04 <mmorrow> > [8..3]
15:04:05 <lambdabot>   []
15:04:07 <mmorrow> heh
15:04:18 <mmorrow> , (fmap . fmap . fmap) (*2) [[[0..4],[8..11]]]
15:04:20 <lunabot>  [[[0,2,4,6,8],[16,18,20,22]]]
15:04:22 <Gracenotes_> that bit me just an hour ago :/
15:04:34 <mmorrow> for a second there i thought i was losing my mind
15:04:35 <ddarius> pumpkin: All you need is a four argument function.
15:04:51 <pumpkin> yup :P
15:05:44 <pumpkin> > (+5) (.) . (.) . (.) . (.) (\x y z -> x * y * z) $ 5 6 3
15:05:45 <lambdabot>       Overlapping instances for Show
15:05:45 <lambdabot>                                  ((a -> ...
15:05:52 <pumpkin> oh  Ileft one out
15:06:01 <pumpkin> > (+5) (.) . (.) . (.) . (.) (\w x y z -> w * x * y * z) $ 12 5 6 3
15:06:02 <lambdabot>       Overlapping instances for Show
15:06:02 <lambdabot>                                  ((a -> ...
15:06:07 <pumpkin> :(
15:06:13 <Gracenotes_> why the +5?
15:06:47 <pumpkin> I must be failing
15:06:53 <pumpkin> @type (.) . (.) . (.) . (.)
15:06:54 <lambdabot> forall a a1 a2 b c a3. (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
15:07:09 <ddarius> ((.) . (.) . (.) . (.)) (+5) (\w x y z -> w*x*y*z) 12 5 6 3
15:07:17 <ddarius> > ((.) . (.) . (.) . (.)) (+5) (\w x y z -> w*x*y*z) 12 5 6 3
15:07:18 <lambdabot>   1085
15:07:31 <pumpkin> ah, I can't use that monstrosity infix?
15:07:39 <pumpkin> I guess that makes sense
15:08:27 <Gracenotes_> > ((.) . (.)) (`div` 6) (\a b -> a * b) 3 4
15:08:29 <lambdabot>   2
15:09:00 <mmorrow> , foldr (.) id (replicate 4 (.)) (+5) (\w x y z -> w*x*y*z) 12 5 6 3
15:09:01 <lunabot>  luna: Occurs check: cannot construct the infinite type: b = a -> b
15:09:18 <r2q2> Is the patch algebra that darcs uses an algebraic data type?
15:09:19 <gwern> @tell abuiles -p is one of the profiling flags. you probably don't wnat that
15:09:19 <Gracenotes_> finding operators that make emoticons is always fun in any programming language
15:09:19 <lambdabot> Consider it noted.
15:09:19 <mmorrow> , foldr1 (.) (replicate 4 (.)) $ (+5) (\w x y z -> w*x*y*z) 12 5 6 3
15:09:21 <lunabot>  luna: Occurs check: cannot construct the infinite type: b = a -> b
15:09:26 <mmorrow> grr\
15:10:05 <mmorrow> , $(foldr (|.|) [|id|] (replicate 4 (|.|))) (+5) (\w x y z -> w*x*y*z) 12 5 6 3
15:10:08 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
15:10:35 <vixey> , (foldr (.) id (replicate 4 (.))) (+5) (\w x y z -> w*x*y*z) 12
15:10:37 <lunabot>  luna: Occurs check: cannot construct the infinite type: b = a -> b
15:10:41 <vixey> aha
15:11:01 <mmorrow> ohh
15:11:13 <mmorrow> , $(foldr (|.|) [|id|] (replicate 4 [|(.)|])) (+5) (\w x y z -> w*x*y*z) 12 5 6 3
15:11:23 <lunabot>  1085
15:11:35 <mmorrow> , [$ty| (|.|) |]
15:11:40 <lunabot>  ExpQ -> ExpQ -> ExpQ
15:11:44 <mmorrow> , [$ty| [|(.)\|] |]
15:11:45 <roconnor> I was taught to use foldr ($) x instead of foldr (.) id
15:11:50 <lunabot>  ExpQ
15:12:06 <mmorrow> roconnor: yuk :)
15:12:37 <mmorrow> g |.| f = [|$g . $f|]
15:12:52 <mmorrow> (not in stdlibs)
15:13:07 <mmorrow> ((fyi))
15:13:27 <roconnor> it was the first time were I saw foldr used without an identity element for []
15:14:30 <mmorrow> , ppDoc `fmap` (\(e:es) -> foldl appE e es) ([|42|] : (replicate 4 [|id|]))
15:14:32 <lunabot>  42 id id id id
15:14:37 <mmorrow> crap
15:14:42 <mmorrow> , ppDoc `fmap` (\(e:es) -> foldr appE e es) ([|42|] : (replicate 4 [|id|]))
15:14:45 <lunabot>  id (id (id (id 42)))
15:16:03 <mmorrow> , ppDoc `fmap` (\(e:es) -> foldr (\f x -> [|$f $x|]) e es) ([|42|] : (replicate 4 [|id|]))
15:16:05 <lunabot>  id (id (id (id 42)))
15:16:13 <mmorrow> , ppDoc `fmap` (\(e:es) -> foldr (\f x -> [|$f $ $x|]) e es) ([|42|] : (replicate 4 [|id|]))
15:16:15 <lunabot>  id $ (id $ (id $ (id $ 42)))
15:16:34 <Gracenotes_> @src <$>
15:16:34 <lambdabot> f <$> a = fmap f a
15:16:42 <Gracenotes_> @src <*>
15:16:43 <lambdabot> Source not found. You speak an infinite deal of nothing
15:17:03 <baaba> :t <*>
15:17:04 <lambdabot> parse error on input `<*>'
15:17:10 <baaba> :t (<*>)
15:17:10 <mmorrow> , [$i| (,,) "foo" "bar" "baz" |]
15:17:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:17:15 <lunabot>  luna: Ambiguous occurrence `i'
15:17:19 <mmorrow> sigh
15:18:41 <vixey> mmorrow, I got a new notation for parsers
15:19:03 <vixey> instead of do n <- name ; ws ; t <- term ; foo ; return (n,t)
15:19:28 <vixey> KEEP name! DROP ws! KEEP term! DROP foo! STORE=+> (,)
15:20:01 <BMeph> vixey: Have you been hanging out with slava again? ;)
15:22:25 <jkff> Wow. I should use Data.Binary instead of my hand-rolled bytestring parser.
15:22:33 * jkff goes to sleep and meditate over that
15:23:14 <mmorrow> vixey: haha
15:24:33 <mmorrow> HAI! CAN HAS name! NOT CAN HAS ws! CAN HAS term! HOT CAN HAS foo! EATS WITH (,)!
15:24:43 <pozic> [a,b] = [zipWith f `ap` tail| f <- [(<),(>)]] -- GHC seems to be too stupid to understand this
15:25:00 <pozic> Even with all the bells and whistles enabled.
15:25:16 <mmorrow> @type [zipWith f `ap` tail| f <- [(<),(>)]]
15:25:17 <lambdabot> forall a. (Ord a) => [[a] -> [Bool]]
15:25:33 <mmorrow> > length [zipWith f `ap` tail| f <- [(<),(>)]]
15:25:34 <lambdabot>   2
15:25:50 <pozic> I have it in a module, and it won't load.
15:25:55 <mmorrow> > let [a,b] = length [zipWith f `ap` tail| f <- [(<),(>)]] in (1 `a` 3, 42 `b` 12)
15:25:56 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Int'
15:26:02 <pozic> 6.8.2
15:26:06 <mmorrow> ohh
15:26:22 <pumpkin> , let [a,b] = length [zipWith f `ap` tail| f <- [(<),(>)]] in (1 `a` 3, 42 `b` 12)
15:26:25 <lunabot>  luna: Couldn't match expected type `[t]'
15:26:29 <mmorrow> > let [a,b] = length [zipWith f `ap` tail| f <- [(<),(>)]] in (a [1..4], b (reverse [0..9]))
15:26:30 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Int'
15:26:46 <pozic> I get: Ambiguous type variable `a' in the constraint:
15:26:55 <mmorrow> hmm
15:27:10 <mmorrow> > let [a,b] = length [zipWith f `ap` tail| f <- [(<)::Int->Int->Bool,(>)]] in (a [1..4], b (reverse [0..9]))
15:27:11 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Int'
15:27:13 <pozic> `Ord a' arising from a use of `<' at <location>
15:27:16 <pozic> Probable fix: give these definition(s) an explicit type signature
15:27:24 <pozic> The type signature does not help.
15:27:29 <Axman6> mmorrow: get rid of the length
15:27:34 <mmorrow> ohhh, haha
15:27:43 <mmorrow> > let [a,b] = [zipWith f `ap` tail| f <- [(<)::Int->Int->Bool,(>)]] in (a [1..4], b (reverse [0..9]))
15:27:44 <lambdabot>   ([True,True,True],[True,True,True,True,True,True,True,True,True])
15:27:50 <mmorrow> > let [a,b] = [zipWith f `ap` tail| f <- [(<),(>)]] in (a [1..4], b (reverse [0..9]))
15:27:51 <lambdabot>   ([True,True,True],[True,True,True,True,True,True,True,True,True])
15:28:06 <pozic> I already know that it was a conscious decision to not have this work by default, but I really don't like this kinds of limitations.
15:28:18 <pumpkin> pozic: works fine in my ghci
15:28:21 <mmorrow> pozic: it seemed to just work?
15:28:23 <pozic> All the static typing stuff should be optional.
15:28:30 <mmorrow> heh
15:28:39 <b_jonas> what on earth?
15:28:39 <vixey> pozic, it is optional
15:28:42 <Axman6> pozic: it is
15:28:43 <mmorrow> pozic: that's what unsafeCoerce is for!
15:28:50 <pumpkin> pozic: the monomorphism restriction thing?
15:28:59 <defun> Hey, I installed ghc 6.10.1, but I would also like to install software via Hackage/CABAL. Can someone tell me how to, or point me to a resource that can tell me how to install CABAL?
15:29:01 <Axman6> well, defined static types at least
15:29:02 <b_jonas> ah, I see
15:29:06 <b_jonas> there's an in hiding there
15:29:14 <Axman6> defun: google cabal-install
15:29:17 <pozic> pumpkin, yes, and I already load ghc/i with all the extensions.
15:29:20 <Axman6> @where cabal-install
15:29:21 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
15:29:24 <Axman6> ^^
15:29:59 <mmorrow> pozic: maybe your using that in a way that the monomorphism restriction is biting you
15:30:10 <pumpkin> if you don't let ... in
15:30:14 <mmorrow> {-# LANGUAGE NoMonomorphismRestriction #-} might help
15:30:16 <pumpkin> it assumes () is the input
15:30:27 <mrehayden> merry christmas agoraphobics
15:30:48 <mrehayden> @hoogle
15:30:49 <lambdabot> No query entered
15:30:49 <lambdabot> Try --help for command line options
15:30:51 <pozic> mmorrow, I already have that.
15:31:05 <mrehayden> @hoogle int -> [char]
15:31:12 <lambdabot> Did you mean: Int -> [Char] /count=20
15:31:12 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
15:31:12 <lambdabot> Prelude repeat :: a -> [a]
15:31:20 <pozic> mmorrow, I  copied your line to a new ghci instance, and it said it was missing (Monad ((->) [a]))
15:31:20 <aconbere> these numeric types are killing me
15:31:21 <aconbere> :(
15:31:33 <pozic> mmorrow, so, maybe it was a bug that was fixed in a newer version.
15:31:36 <pumpkin> Prelude Control.Monad Control.Applicative> let [a,b] = [zipWith f `ap` tail| f <- [(<),(>)]]
15:31:36 <pumpkin> Prelude Control.Monad Control.Applicative> :t a
15:31:36 <pumpkin> a :: [()] -> [Bool]
15:31:44 <pumpkin> is that your issue?
15:31:48 <b_jonas> so (zipWith (<) `ap` tail)  is comparing each element to the last one?
15:32:04 <mrehayden> is there a library function in haskell that will do int to [char] for me?
15:32:04 <b_jonas> > (zipWith (,) `ap` tail) "hello"
15:32:06 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
15:32:10 <b_jonas> mrehayden: show?
15:32:12 <mrehayden> or do i have to write it myself?
15:32:26 <mmorrow> pozic: possibly
15:32:29 <b_jonas> ah, I see
15:32:38 <b_jonas> it's not to the last one but the next one
15:32:40 <vixey> mrehayden, show
15:32:44 <mmorrow> pozic: well, i believe lambdabot is using ghc-6.8.something
15:32:52 <mrehayden> i.e. 321 -> ['3', '2', '1']
15:32:53 <b_jonas> > (zipWith (,) `ap` replicate . head) "hello"
15:32:54 <lambdabot>       precedence parsing error
15:32:54 <lambdabot>          cannot mix `ap' [infixl 9] and `(.)' ...
15:33:00 <b_jonas> > (zipWith (,) `ap` (replicate . head)) "hello"
15:33:01 <lambdabot>   Couldn't match expected type `[b]' against inferred type `a -> [a]'
15:33:03 <EvilTerran> pozic, have you done ":m + Control.Monad.Instances"?
15:33:05 <pumpkin> mrehayden: what vixey said
15:33:06 <mmorrow> pozic: ohhh, just saw what you said about (Monad ((->) [a]))
15:33:12 <vixey> > (zipWith (,) `ap` (repeat . head)) "hello"
15:33:13 <mmorrow> that's in Control.Monad.Instances
15:33:13 <lambdabot>   [('h','h'),('e','h'),('l','h'),('l','h'),('o','h')]
15:33:14 <pumpkin> mmorrow: you need applicative
15:33:18 <pumpkin> oh, or that too
15:33:20 <b_jonas> vixey: yeah, taht
15:33:29 <b_jonas> makes sense
15:33:34 <mmorrow> applicative probably (possibly indirectly) exports that module
15:33:36 <mrehayden> show 300
15:33:37 <pumpkin> yup
15:33:39 <b_jonas> so with tail it compares each to the next
15:33:40 <pozic> EvilTerran, ok, then it works in ghci, now let's see whether the module works...
15:33:42 <vixey> "300"
15:33:43 <b_jonas> great
15:33:54 <mrehayden> haha
15:34:13 <pumpkin> pozic: don't you get [()] -> [Bool] ?
15:34:19 <mmorrow> , fmap chr [42..]
15:34:22 <mrehayden> i suppose it isn't that hard to write a show, im going to have a go
15:34:22 <lunabot>  "*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnop...
15:34:38 <pumpkin> > show 300
15:34:39 <lambdabot>   "300"
15:34:45 <vixey> > divMod 10 300
15:34:46 <lambdabot>   (0,10)
15:34:49 <mrehayden> >show 987654321
15:34:50 <vixey> > divMod 300 10
15:34:51 <mmorrow> , fmap (:[]) . show "45678765"
15:34:52 <lambdabot>   (30,0)
15:34:53 <lunabot>  luna: Couldn't match expected type `a -> f a1'
15:34:55 <mmorrow> , fmap (:[]) . show $ "45678765"
15:34:57 <lunabot>  ["\"","4","5","6","7","8","7","6","5","\""]
15:35:06 <pozic> Is there any way to see what ghci thinks the options for a certain module are?
15:35:08 <mmorrow> , fmap (:[]) . show $ 45678765
15:35:10 <lunabot>  ["4","5","6","7","8","7","6","5"]
15:35:32 <mrehayden> has anyone read the new o'reilly practical haskell book?
15:35:57 <mmorrow> pozic: i'm not sure there is
15:36:04 <EvilTerran> sometimes it tells you
15:36:25 <mmorrow> oh yes, there is
15:36:45 <mmorrow> :show packages              show the currently active package flags
15:36:45 <mmorrow>    :show languages             show the currently active language flags
15:36:49 <mmorrow> :?
15:37:59 <pozic> mmorrow, did you try to see whether it works in a module?
15:38:07 <pozic> It seems to be impossible to get it to work here.
15:38:14 <mmorrow> i did not
15:38:26 <pozic> I will try it in a minimal one.
15:38:56 <EvilTerran> pozic, in a module, you need to "import Control.Monad.Instances" instead of ":m + ..."
15:39:07 <pozic> EvilTerran, I already did that.
15:39:17 <EvilTerran> what happens?
15:39:43 <pozic> EvilTerran, the mono stuff.
15:41:01 <sbahra> mrehayden, you mean "Real World Haskell"?
15:41:03 <pozic> Nope, even with ghci -fno-monomorphism-restriction I cannot get it to work in a minimal module.
15:41:15 <mrehayden> sbahra: yup
15:41:33 <sbahra> mrehayden, I have, so have several others. In fact, most of the authors of the book (at the least) hang out here. :-)
15:42:01 <mrehayden> i cant work out if that is very cool, or extremely sad
15:42:12 <sbahra> Why would it be extremely sad?
15:42:25 <EvilTerran> pozic, do you still get the monomorphism restriction error with that flag?
15:42:53 <pozic> EvilTerran, Possible cause: the monomorphism restriction applied to the following:, so yes.
15:43:32 <pozic> It's an error message that should never be listed, since I specified already that there shouldn't be such a restriction.
15:43:57 <mrehayden> > show fac 10
15:43:59 <lambdabot>   Not in scope: `fac'
15:44:13 <EvilTerran> indeed
15:44:34 <EvilTerran> looks like a bug in the error message text
15:44:43 <pozic> Also, the lack of consistency between defining the functions in ghci and loading them from a file is bug.
15:44:48 <EvilTerran> although it only says "possible cause"
15:44:50 <pozic> is a*
15:45:02 <sbahra> pozic, hrm?
15:45:05 <pozic> EvilTerran, yes, but clearly it is not possible :)
15:45:13 <pozic> sbahra, read back, please.
15:45:32 <sbahra> pozic, I have.
15:45:40 <sbahra> pozic, but why is it a bug?
15:46:11 * sbahra stopped reading at ``you need to "import Control.Monad.Instances" instead of ":m + ..."''
15:46:38 <pumpkin> pozic: it's not a bug, it's a well known consequence of how ghci works :P
15:46:40 <pozic> sbahra, :m + should correspond to import and let foo = bar should correspond to ghci -fglasgow-exts <SomeFile> modulo type defaulting.
15:47:25 <pumpkin> or in other words, "it's not a bug, it's a feature!"
15:47:25 <EvilTerran> pozic, the only bug i see there is continuing to suggest the MR to be at fault when it's been disabled
15:47:38 <pozic> This function has a very simple type and it is not being correctly deduced, while it is a computable type. If that's not a bug, then I need to find a different language implementation or a different language.
15:47:40 <sbahra> pozic, have you written a patch for this? Maybe others might be interested in this.
15:47:44 <EvilTerran> pozic, the actual problem you have there, AFAICT, is that your expression seems to be in need of higher-rank types
15:47:45 * sbahra isn't, personally
15:48:07 <EvilTerran> pozic, ... unless you explicitly type-annotate away the mid-type-expression forall
15:48:19 <EvilTerran> not sure why it's working in ghci; defaulting, maybe
15:48:24 <pozic> EvilTerran, but there is nothing undecidable about this.
15:48:38 <mrehayden> can i use those profiling libraries in GHC to do interactive profiling?
15:49:10 <vixey> pozic, "This function has a very simple type and it is not being correctly deduced" ? yeah right
15:49:28 <pozic> vixey, what do you mean?
15:49:35 <aconbere> so ... I believe this is the root of all my issues with Numeric types. That and infrencing that creates Integer values and thus can't be divided.
15:49:38 <aconbere> http://paste.pocoo.org/show/96758/
15:49:43 * aconbere sighs
15:49:47 <pozic> vixey, are you suggesting it is not simple?
15:50:44 <pumpkin> aconbere: you either need `div` or fromIntegral
15:50:54 <pumpkin> :t (/)
15:50:55 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:51:05 <pumpkin> the / operator wants a Fractional value, which Integer isn't
15:51:05 <mrehayden> anyone here know how to do interactive profiling, say in GHCi?
15:51:07 <vixey> pozic: I think you should juts program in a untyped language if types get in the way but also your assessment is probably false (about the type checking/inference)
15:51:07 <pumpkin> :t div
15:51:08 <lambdabot> forall a. (Integral a) => a -> a -> a
15:51:09 <b_jonas> which function?
15:51:25 <pozic> vixey, why would it be "probably false"?
15:51:58 <pozic> vixey, It's either true or false, not probably false. That contains no information.
15:52:15 <vixey> pozic: oh yeah I forgot I was a binary robot
15:52:25 <pozic> vixey, also this statement about the untyped language stuff is ridiculous.
15:53:30 <mrehayden> anyone here know how to do interactive profiling/
15:53:40 <Gracenotes_> hm... Plugin `quote' failed with: getRandItem: empty list
15:53:46 <Gracenotes_> I don't think that's a quote, is it? :)
15:54:13 <blackdog> mrehayden: it'd be a bit of a hack - usually you have to pass a bunch of options to the GHC runtime engine. not sure if you can do that from ghci (could be wrong, though)
15:54:23 <aconbere> pumpkin: so... how would you use fromIntegral here, it looks like div does modulo
15:54:50 <pumpkin> aconbere: div just truncates, so you'd do (fromIntegral x / a) (fromIntegral y / a), etc.
15:54:51 <aconbere> (not so useful, I just want integers to divide my doubles/floats/whatever and return a double/float/whatever)
15:55:07 <aconbere> pumpkin: awesome
15:55:08 <aconbere> :)
15:55:17 <pumpkin> oh wait, is a the integral?
15:55:19 <pumpkin> or x?
15:55:23 <pumpkin> if a is, stick fromIntegral on it
15:55:28 <pumpkin> you'll need parentheses
15:55:32 <aconbere> pumpkin: It always seems to depend!
15:55:36 <pumpkin> (x / (fromIntegral a))
15:55:42 <aconbere> stupid type infrencing
15:55:43 <aconbere> :P
15:55:54 <pumpkin> lol, why are you using integers at all?
15:56:03 <aconbere> because one comes from length
15:56:13 <pumpkin> oh, then you should fromIntegral it before getting into the divide
15:56:15 <aconbere> I need to divide a vector with the length of a list of vectors
15:56:21 <b_jonas> (or use genericLength)
15:56:22 <aconbere> that doesn't seem to work
15:56:23 <pumpkin> it would make sense for divide to keep the type it already has
15:56:37 <pumpkin> aconbere: what's the code there?
15:56:38 <pumpkin> it should
15:56:41 <pumpkin> :t genericLength
15:56:42 <lambdabot> forall b i. (Num i) => [b] -> i
15:57:08 <aconbere> oh... fromIntegral also isn't in my scope in the shell
15:57:15 <pumpkin> :o
15:57:16 <b_jonas> wHAT?
15:57:18 <aconbere> I can do $ fromIntegral 10
15:57:24 <aconbere> but not (fromIntegral 10)
15:57:32 <aconbere> maybe I don't understand how it works
15:57:32 <pumpkin> o.O
15:57:35 <b_jonas> then you typoed one of them
15:57:37 <sbahra> genericLength :D
15:57:41 <sbahra> cool
15:59:22 * blackdog realises he has two competing versions of ghc installed and that's why cabal is acting weirdly. bugger.
15:59:25 <b_jonas> aconbere: can you reproduce it? if so, can you show us the full expressions?
15:59:54 <dcoutts> blackdog: multiple different versions is ok, multiple same version is a bit dodgy
16:00:24 <aconbere> hehe, well fromIntegral is okay, but it doesn't seem to help my situation
16:00:31 <aconbere> divide x (fromIntegral (length [1,2]))
16:00:37 <blackdog> dcoutts: yeah. installed differently, weird paths, etc etc etc. just bad news.
16:00:38 <aconbere> gives me that same (Fractional Integer)
16:00:41 <aconbere> error
16:00:44 <aconbere> that I read about on the web
16:00:47 <aconbere> and offers no help :P
16:01:41 <aconbere> The issue might be that the Vector I'm using is being instantiated as a vector of Ints
16:01:53 <aconbere> or maybe fromInteger isn't working like I think it should
16:01:56 <aconbere> or divide is broken
16:02:05 <pumpkin> http://hpaste.org/13326 so this is pozic's problem and I'm curious
16:02:08 <aconbere> narrowing down what's wrong here is driving me crazy
16:02:37 <aconbere> the type infrencing is making it harder, but limiting the vector type to some set of numbers cause a ton of problems as well
16:02:45 * aconbere sighs
16:03:18 <pozic> pumpkin, if is anything, it is type defaulting or a bug.
16:03:31 <pozic> if it*
16:03:43 <b_jonas> no
16:03:50 <b_jonas> it's the monomorphism restriction
16:03:51 <b_jonas> I think
16:04:01 <enticingjelly> is it possible to derive a type class, but override only specific patterns?
16:04:01 <b_jonas> or not?
16:04:03 <b_jonas> wait
16:04:39 <pozic> The [()] type is clearly bogus.
16:04:40 <b_jonas> yeah, it's monomorphism restriction
16:04:44 <b_jonas> pozic: it's defaulting
16:04:50 <b_jonas> pozic: just add a type signature
16:04:50 <pozic> b_jonas, and what did I say?
16:05:01 <pozic> b_jonas, I said it was type -defaulting or a bug.
16:05:12 <pozic> b_jonas, in other words, I already gave the answer.
16:05:17 <b_jonas> pozic: no, the problem is why it has to default
16:05:23 <b_jonas> and that's because of the monomorphism restriction
16:05:32 <pumpkin> b_jonas: but I turned off the monomorphism restriction and it's still defaulting?
16:05:33 <pozic> b_jonas, yes, I also know that.
16:05:49 <b_jonas> pozic: if you use it in a program it won't have to defualt after that one line
16:05:51 <pozic> b_jonas, and the problem was to get it to work in a module.
16:06:00 <b_jonas> pozic: just add a type sig then
16:06:08 <b_jonas> a :: [a] -> [Bool]
16:06:10 <pozic> b_jonas, I did. It doesn't work.
16:06:14 <b_jonas> b :: [a] -> [Bool]
16:06:17 <b_jonas> doesn't work how?
16:06:19 <pozic> b_jonas, that's the incorrect type.
16:06:26 <pozic> b_jonas, it needs an Ord constraint.
16:06:34 <b_jonas> ok, add the correct type then
16:06:37 <pozic> I did!
16:06:40 <pumpkin> it still defaults
16:06:41 <pumpkin> to ()
16:06:55 <pumpkin> even with -XNoMonomorphismRestriction
16:07:09 <pozic> Which is why _I_ consider it a bug.
16:07:10 <b_jonas> let me try
16:07:12 <aconbere> AH HA!
16:07:21 <aconbere> my zero fector function used 0 instead of 0.0
16:07:27 <aconbere> which caused all sorts of integer havok
16:07:37 <pumpkin> aconbere: 0 doesn't have a specific type though
16:07:37 <pumpkin> :t 0
16:07:38 <lambdabot> forall t. (Num t) => t
16:07:44 <pumpkin> it'll become whatever it needs to be
16:07:54 <aconbere> pumpkin: it must have been infrencing an Int then?
16:08:17 <aconbere> pumpkin: there's no reason for it to be anything but double really
16:08:24 <aconbere> I have no idea why it would be Int
16:08:31 <pumpkin> pozic: yeah, the monomorphism restriction is definitely off, I tried one of the more canonical monomorphism definitions and it worked as expected
16:08:42 <pumpkin> hmm
16:09:10 <pozic> Actually, I know they removed support from it from the compiler a year ago or so.
16:09:21 <pozic> It used to work and there is a new flag for it.
16:09:52 <pozic> That was done to please some expert users, IIRC, but I am not sure whether the flag is still there in newer versions.
16:09:53 <pumpkin> I mean, I definitely turned off the monomorphism restriction in ghci, but I'm still getting your issue, so either it isn't (it looks like it though) that, or it's a bug as you said
16:11:15 <pozic> I found it, but since you all know Haskell so very well, you can find it for yourself :) I gave enough hints.
16:11:26 <augustss_> pumpkin: what's the problem?
16:11:38 <pumpkin>  http://hpaste.org/13326
16:11:38 * pozic bets augustss_ knows the issue
16:12:23 <pumpkin> augustss_: I've verified that the monomorphism restriction is indeed off, but it still defaults to [[()] -> [Bool]] with or without an explicit type
16:12:47 <augustss_> It's the extended defaulting that kicks in, but I'm not sure why.
16:12:52 <Heffalump> ghci does its own defaulting
16:12:58 <Heffalump> don't test there, test in a real program
16:13:09 <pumpkin> Heffalump: that's how this started from pozic
16:13:26 <b_jonas> I started to manipulate it and now it isn't even well typed
16:13:28 <pozic> Now, it's only intellectual masturbation.
16:13:35 <pozic> The problem has been solved already.
16:13:46 <pumpkin> well yeah, you can always add explicit type signatures
16:13:50 <augustss_> Yeah, ghci has some extra werid defaulting.
16:14:01 <augustss_> And I don't know how it treats let.
16:14:01 <pozic> augustss_, this is about loading a module from a file.
16:14:06 <pozic> augustss_, not interactive stuff.
16:14:13 <pumpkin> augustss_: even without the let it defaults
16:14:31 <augustss_> pozic: oh.  do you have an example?
16:14:47 <pozic> augustss_, yes, the one pumpkin pasted.
16:14:55 <pozic> augustss_, put it in a module and try to load it.
16:15:29 <b_jonas> @type let { [a,b] = [zipWith f `ap` tail| f <- [(<),(>)]]; } in a
16:15:31 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
16:15:50 <b_jonas> how did you get the () exactly?
16:16:01 <pumpkin> exactly as pasted :P
16:16:08 <pumpkin> mine is ghci 6.10.1
16:16:21 <Heffalump> ghci isn't interesting, though
16:16:40 <pumpkin> well it's exhibiting the exact same behavior as ghc, and is easier to play with :P
16:16:55 <Heffalump> but we've already pointed out that ghci is known to have that behaviour
16:17:02 <Heffalump> whereas we don't think ghc should
16:17:16 <Heffalump> at least, I don't. I don't necessarily speak for anyone else :-)
16:18:38 <augustss_> Oh, the the change in behaviour of overloaded pattern bindings.  Simon PJ changed that a while ago.
16:18:41 <b_jonas> strange
16:18:47 <Heffalump> oh, right
16:18:47 <pozic> augustss_, we have a winner.
16:18:51 <b_jonas> if I load Control.Monad and Control.Monad.Instnaces
16:18:52 <Heffalump> I thought it was agreed to change it back?
16:19:02 <augustss_> Heffalump: I thought so too.
16:19:16 * pozic is fairly sure that was not the case.
16:19:16 <b_jonas> and then I do ':t let { [a,b] = ... } in a' I get the right type
16:19:31 <pozic> Basically the argument was that almost nobody uses it.
16:19:32 <b_jonas> but if I do 'let { [a,b] = ... }' and then ':t a' I get the wrong one
16:19:33 <augustss_> But perhaps Simon didn't change it back.
16:19:42 <pumpkin> b_jonas: weird
16:20:00 <augustss_> b_jonas: yeah, because they are treated differently
16:20:01 <Heffalump> -fno-mono-pat-binds is what you want, anyway
16:20:12 <pozic> Heffalump, yes, I knew that already :)
16:20:33 <pozic> But the language pragma for that option doesn't work in a file.
16:20:42 <Heffalump> ah.
16:20:50 <Heffalump> I'm sure they decided not to do it that way for Haskell'.
16:20:50 <augustss_> It's probably a static flag.
16:21:03 <Heffalump> so I guess they just need prodding to change it back
16:21:22 <augustss_> yeah
16:21:45 <augustss_> I don't really care much, though.
16:34:49 <Gracenotes_> can it ever make sense to do a >>= b >> c?
16:35:00 <mak__> is there any chance that hs-plugins will be useable in near future?
16:35:09 <Gracenotes_> that is, doing a (>>) after a (>>=)
16:35:46 <dons> mak__: it is not maintained. the best way forward is to develop a similar api on top of ghc-api
16:36:04 <dons> it is asked so often, i might have to do it, since no one else is :/
16:36:52 <sbahra> Gracenotes_, does it ever make sense to do a >> b?
16:37:31 <Gracenotes_> hm, I suppose it does.
16:37:33 <Gracenotes_> :)
16:39:29 <Gracenotes_> @src ([]) (>>)
16:39:29 <lambdabot> Source not found. My mind is going. I can feel it.
16:40:55 <sbahra> @src [] (>>)
16:40:55 <lambdabot> xs >> ys      = concatMap (const xs) ys
16:41:17 <sbahra> @src [] (>>=)
16:41:17 <lambdabot> xs >>= f     = concatMap f xs
16:45:48 <mak__> dons: if you will do it, it will be great ;]
16:48:21 <Olathe> > 'A' >> [1..3]
16:48:23 <lambdabot>   Couldn't match expected type `m a' against inferred type `Char'
16:48:30 <Olathe> > "A" >> [1..3]
16:48:32 <lambdabot>   [1,2,3]
16:49:12 <Olathe> > map (const "A") [1..3]
16:49:14 <lambdabot>   ["A","A","A"]
16:49:20 <Olathe> > concatMap (const "A") [1..3]
16:49:22 <lambdabot>   "AAA"
16:49:30 <Olathe> O-o
16:49:43 <dibblego> > concat (map (const "A") [1..3])
16:49:44 <lambdabot>   "AAA"
16:49:54 <pumpkin> > map (const 'A') [1..3]
16:49:55 <lambdabot>   "AAA"
16:50:06 <Olathe> > ("A" >> [1..3]) == (concatMap (const "A") [1..3])
16:50:08 <lambdabot>       No instance for (Num Char)
16:50:08 <lambdabot>        arising from the literal `1' at <inte...
16:50:30 <Olathe> I take it that means they're not equal.
16:50:41 <twanvl> > [1..3] >> "A"
16:50:42 <lambdabot>   "AAA"
16:51:04 <Olathe> @src (>>)
16:51:04 <lambdabot> m >> k      = m >>= \_ -> k
16:51:16 <mmorrow> @pl concatMap
16:51:17 <lambdabot> (=<<)
16:51:25 <Olathe> That's not the same.
16:51:34 <Olathe> @src [] (>>)
16:51:35 <lambdabot> xs >> ys      = concatMap (const xs) ys
16:51:45 <Olathe> That has concatMap (const ys) xs
16:51:49 <pumpkin> what unicode classes are allowed as operators?
16:52:01 <mmorrow> @src [] (>>=)
16:52:01 <lambdabot> xs >>= f     = concatMap f xs
16:52:14 <mmorrow> @src (>>)
16:52:15 <lambdabot> m >> k      = m >>= \_ -> k
16:52:18 <twanvl> Olathe: (const xs) is the same as (\_ -> xs)
16:52:24 <Olathe> Right.
16:52:27 <Olathe> The arguments are backwards.
16:53:32 <Olathe> m >> k ... m >>= \_ -> k ... m >>= const k ... concatMap (const k) m
16:53:38 <Olathe> @src [] (>>)
16:53:38 <lambdabot> xs >> ys      = concatMap (const xs) ys
16:53:51 <Olathe> m >> k ... concatMap (const m) k
16:56:32 <EvilTerran> Olathe, you're comparing concatMap and (>>=); @pl gave concatMap = (=<<), not (>>=)
16:59:06 <Olathe> EvilTerran: Perhaps, but the source is messed up.
16:59:13 <Olathe> @src [] (>>)
16:59:13 <lambdabot> xs >> ys      = concatMap (const xs) ys
16:59:15 <EvilTerran> ah, yes, i see
16:59:30 <EvilTerran>  @src [] (>>=) is wrong
16:59:47 <EvilTerran> ... no, wait
17:00:14 <Olathe> I think the source for []'s >> is just a convenience, since it uses >>= instead.
17:00:25 <Olathe> But the people who put it there got the arguments backwards.
17:00:27 <EvilTerran> >>'s the one that's wrong, too
17:00:44 <mmorrow> @src [] (>>=)
17:00:44 <lambdabot> xs >>= f     = concatMap f xs
17:00:47 <EvilTerran> with you now. yeah, that's not right
17:01:01 <mmorrow> (>>=) is correct
17:01:08 <mmorrow> @pl concatMap
17:01:08 <lambdabot> (=<<)
17:01:11 <mmorrow> is correct
17:01:23 <mmorrow> @src [] (>>)
17:01:23 <lambdabot> xs >> ys      = concatMap (const xs) ys
17:01:37 <mmorrow> ah
17:02:04 <mmorrow> @pl concatMap (\_ -> x) xs
17:02:04 <lambdabot> xs >> x
17:02:14 <mmorrow> >> is wrong
17:03:41 <ziman> why?
17:03:56 <ziman> > "hello" >> "aa"
17:03:57 <lambdabot>   "aaaaaaaaaa"
17:04:08 <mmorrow> http://code.haskell.org/lambdabot/State/source
17:04:25 <mmorrow> ziman: just the source entry for [] (>>) in ^^^
17:05:06 <mmorrow> @type let xs >> ys      = concatMap (const xs) ys in (>>)
17:05:07 <lambdabot> forall b a. [b] -> [a] -> [b]
17:05:24 <mmorrow> @type xs >> ys      = concatMap (const ys) xs in (>>)
17:05:25 <lambdabot> parse error on input `='
17:05:30 <mmorrow> @type let xs >> ys      = concatMap (const ys) xs in (>>)
17:05:31 <lambdabot> forall a b. [a] -> [b] -> [b]
17:06:01 <mmorrow> good catch Olathe, i didn't even notice
17:06:02 <ziman> oh, i see.
17:06:35 <ziman> indeed :)
17:10:42 <mmorrow> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
17:10:42 <lambdabot> f a =
17:10:42 <lambdabot>     Cont (\ b ->
17:10:42 <lambdabot>           case a (\ c -> Cont (\ _ -> b c)) of
17:10:42 <lambdabot>           Cont d -> d b)
17:10:50 <mmorrow> @src Cont callCC
17:10:50 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
17:12:33 <mmorrow> (i added Cont as data instead of newtype because i don't think newtypes are supported)
17:13:19 * mmorrow is looking through http://code.haskell.org/lambdabot/State/source
17:13:25 <mmorrow> @src Char (==)
17:13:25 <lambdabot> (C# c1) == (C# c2) = c1 `eqChar#` c2
17:13:25 <lambdabot> (C# c1) /= (C# c2) = c1 `neChar#` c2
17:13:52 <mmorrow> @src Either mfix
17:13:52 <lambdabot> mfix f = let a = f $ case a of
17:13:52 <lambdabot>                         Right r -> r
17:13:52 <lambdabot>                         _       -> error "empty mfix argument"
17:13:52 <lambdabot>          in a
17:14:52 <mmorrow> @src unsafeIOToST
17:14:52 <lambdabot> unsafeIOToST (IO io) = ST $ \ s -> (unsafeCoerce# io) s
17:14:59 <mmorrow> @src unsafeSTToIO
17:14:59 <lambdabot> unsafeSTToIO (ST m) = IO (unsafeCoerce# m)
17:15:25 <mmorrow> @src ForeignPtr
17:15:26 <lambdabot> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
17:15:31 <mmorrow> @src ForeignPtrContents
17:15:31 <lambdabot> data ForeignPtrContents = PlainForeignPtr !(IORef [IO ()])
17:15:31 <lambdabot>                         | MallocPtr (MutableByteArray# RealWorld) !(IORef [IO ()])
17:15:31 <lambdabot>                         | PlainPtr  (MutableByteArray# RealWorld)
17:16:00 <mmorrow> @src forkIO
17:16:01 <lambdabot> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
17:16:01 <lambdabot>     where action_plus = catchException action childHandler
17:16:59 <mmorrow> @src modifyMVar_
17:16:59 <lambdabot> modifyMVar_ m io = block $ do
17:16:59 <lambdabot>     a  <- takeMVar m
17:16:59 <lambdabot>     a' <- Exception.catch (unblock (io a)) (\e -> do putMVar m a; throw e)
17:16:59 <lambdabot>     putMVar m a'
17:17:39 <mmorrow> heh
17:17:42 <mmorrow> @src isInfixOf
17:17:43 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
17:18:41 <mmorrow> @index Splittable
17:18:42 <lambdabot> GHC.Exts
17:18:51 <mmorrow> never seen that one before
17:18:57 <mmorrow> @src Splittable
17:18:57 <lambdabot> class Splittable t where
17:18:57 <lambdabot>     split :: t -> (t,t)
17:19:05 <pumpkin> :o
17:19:12 <pumpkin> :t split
17:19:13 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
17:19:43 <mmorrow> @index split
17:19:43 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
17:20:55 <mmorrow> @src catchException
17:20:55 <lambdabot> Source not found. :(
17:21:13 <mmorrow> i wonder if a forkST would be useful
17:22:14 <Heffalump> sounds dubious to me
17:22:17 <mmorrow> (\x -> runST (forkST x)) :: a -> ThreadId
17:22:24 <mmorrow> Heffalump: hmm
17:22:39 <Heffalump> I don't think ST computations are supposed to be non-deterministic.
17:23:03 <mmorrow> ah true, the ThreadId would be diff every time
17:23:09 <Heffalump> not just that :-)
17:23:24 <mmorrow> hmm, i don't see it
17:23:34 <Heffalump> the interleaving of the threads would be non-deterministic..
17:23:45 <mmorrow> wouldn't that be similar to par though?
17:23:53 <Heffalump> par doesn't work on side-effecting things
17:24:20 <mmorrow> but what if forkST :: a -> ST s ThreadId
17:24:28 <Heffalump> you can use par on an ST computation, but not the execution of the computation, IYSWIM
17:24:42 <mmorrow> @go IYSWIM
17:24:45 <lambdabot> No Result Found.
17:24:49 <Heffalump> if you see what I mean
17:24:56 <mmorrow> :)
17:25:53 <mmorrow> par a b = runST (forkST a) `seq` b  -- ?
17:26:20 <Heffalump> I don't understand what you're driving at.
17:26:49 <mmorrow> neither do i exactly
17:27:03 <Heffalump> I guess from the type sig above that you want forkST to run pure computations in a new thread
17:27:10 <mmorrow> so you're saying that forkST would violate the
17:27:11 <mmorrow> yes
17:27:13 <Heffalump> but how do you get the result back?
17:27:34 <mmorrow> ah, i'm picturing that it just evaluates it in another thread
17:27:50 <Heffalump> why is this any more useful than par then?
17:27:53 <mmorrow> hmm, i guess
17:27:57 <mmorrow> yeah, true
17:28:18 <mmorrow> but, it would (more or less) /be/ par (in a sense) then (?)
17:28:41 <mmorrow> i guess that's what i was trying to drive at
17:28:47 <Heffalump> apart from the ThreadID return value, yes, only more complicated and more confusing :-p
17:28:53 <mmorrow> heh
17:59:22 <redditbot> Haskell Twitter package; tweet from GHCi
18:01:50 <ozy`> sweet, I nabbed a fairly generic username on a popular e-mail service which will remain unnamed
18:04:38 <mrehayden> Couldn't match expected type `String'
18:04:38 <mrehayden>        against inferred type `a -> String'
18:04:50 <mrehayden> can anyone explain that to me?
18:05:18 <mrehayden> this is the context
18:05:19 <mrehayden> main = putStrLn show fac 100
18:05:27 <Heffalump> you're missing some brackets
18:05:42 <mrehayden> isn't this all done in applicative order?
18:05:44 <Heffalump> that parses as main = ((putStrLn show) fac) 100
18:07:31 <mrehayden> why?
18:07:41 <Heffalump> because it does :-)
18:07:49 <Heffalump> application associates to the left. It's just how it works.
18:07:59 <mrehayden> my lambda calculus tells me otherwise
18:08:15 <mrehayden> in my mind
18:08:20 <Heffalump> as in SKI combinators?
18:08:24 <Heffalump> I'm sure they associate to the left too.
18:08:35 <Heffalump> as does application in lambda calculus, actually
18:08:45 <Heffalump> I think your mind needs retraining :-)
18:08:59 <mrehayden> lambda expressions take one argument
18:09:15 <mrehayden> so everything to the left of the first expression is an argument to putStrLn
18:09:32 <mrehayden> so it should go putStrLn (show (fac 100))
18:09:53 <geezusfreeek> notice that the way it actually parses also gives each function application one argument
18:09:54 <mrehayden> this works, im not disputing that
18:10:11 <mrehayden> yeah, true
18:10:52 <geezusfreeek> > let f x y = x + y in f 2 3
18:10:53 <lambdabot>   5
18:10:56 <afabian> mrehayden: Function application has the highest precedence and left associativity; nothing more or less to it.  If you make it an infix operator, you can change the precedence and associativity.
18:10:59 <geezusfreeek> > let f x y = x + y in f (2 3)
18:11:00 <lambdabot>       Overlapping instances for Show (a -> a)
18:11:00 <lambdabot>        arising from a use of `s...
18:11:01 <ddarius> mrehayden: You want to write (add 3) 4 instead of add 3 4.  What you suggest would have it parse as add (3 4) which makes no sense.
18:12:15 <mrehayden> sure, but im still not convinced
18:12:26 <geezusfreeek> > let f x y = x + y in (f 2) 3
18:12:27 <lambdabot>   5
18:12:47 <geezusfreeek> :t let f x y = x + y in f 2
18:12:48 <lambdabot> forall t. (Num t) => t -> t
18:13:08 <mmorrow> @type putStrLn . show . (*2) . negate $ 12
18:13:08 <mrehayden> now i get it
18:13:09 <lambdabot> IO ()
18:14:06 <mrehayden> why cant i write everything in infix then nicely? like im doing a calculation in hsilop notation?
18:14:25 <mrehayden> not infix, prefix
18:14:47 <mmorrow> @unpl h . g . f $ x
18:14:47 <lambdabot> (h (g (f x)))
18:14:58 <mmorrow> @unpl h . g . f
18:14:58 <lambdabot> (\ c -> h (g (f c)))
18:15:08 <mmorrow> @pl (\ c -> h (g (f c)))
18:15:09 <lambdabot> h . g . f
18:15:42 <mrehayden> nice
18:15:53 * mrehayden needs to study
18:17:10 <mrehayden> that's almost mathematical notation really isnt it
18:17:19 <mrehayden> f o g = f(g)
18:17:22 <mmorrow> yeah, composition
18:17:41 <mmorrow> (f o g) x === f (g x))
18:17:46 <mmorrow> (f o g) x === f (g x)
18:18:47 <mmorrow> (.) is indispensable
18:19:11 <mmorrow> main = putStr . length . lines =<< getContents
18:19:17 <mrehayden> i've only just finished doing an entry level FP course
18:19:25 <mrehayden> id like to get some real experience
18:19:28 <koeien> in haskell?
18:19:31 <mmorrow> cat | wc -l
18:19:32 <mrehayden> miranda
18:19:35 <koeien> ok
18:19:40 <mmorrow> whoa, miranda
18:19:44 <koeien> my entry level FP course was in Haskell :)
18:19:44 <mrehayden> almost identical from what i've seen
18:19:54 <mmorrow> i didn't think anyone still used miranda
18:19:54 <geezusfreeek> you went through a whole FP course without using composition?! how do you live?
18:19:58 <koeien> yeah, miranda had a non-free compiler/interpreter right?
18:20:05 <mrehayden> typing, purely functional, lazy eval
18:20:17 <mrehayden> free (miranda) = amanda
18:20:22 <mmorrow> koeien: from what i understand, yeah. although i've never used it
18:20:27 <Heffalump> where was the course?
18:20:28 <koeien> mmorrow: me neither
18:20:32 <mrehayden> you only seem to be able to find it through my university website
18:20:41 <mrehayden> CS:UCL
18:21:00 <bos> miranda's been moribund for about 20 years.
18:21:05 <Heffalump> I wonder why anyone still bothers teaching that.
18:21:17 <Heffalump> bos: that's an exaggeration :-)
18:21:32 <mrehayden> well, it ain't bad
18:21:37 * geezusfreeek <3 haskell
18:21:39 <mrehayden> which is good enough for some
18:21:46 <mmorrow> moribund's a great word though
18:21:47 <Heffalump> sure, but Haskell basically completely subsumes it now
18:21:47 <bos> Heffalump: only by a small margin
18:22:04 * koeien tried to learn a bit of OCaml as well, but after a while didn't see the point :)
18:22:05 <mrehayden> it was in the classroom
18:22:36 <geezusfreeek> yeah i started FP using ocaml and quickly abandoned it and tried haskell because i felt like i was just using fancy C :P
18:22:38 <mrehayden> anyway, i want to use fp for real, someone recommends the o'reilly book
18:22:45 <mrehayden> real world haskell
18:22:46 <ozy`> ocaml is no more exotic or expressive than lisp
18:22:49 <mmorrow> http://www.engineering.tech.nhl.nl/engineering/personeel/bruin/data/
18:22:49 <ozy`> maybe even less so
18:22:54 <mmorrow> this link? ^^^
18:23:02 <mrehayden> lisp = confusing syntax
18:23:02 <koeien> lisp is... different :)
18:23:05 <mmorrow> http://www.cs.ucl.ac.uk/teaching/3C11/amanda.html
18:23:05 <Heffalump> mrehayden: don't go near it, the authors are all idiots ;-)
18:23:24 <koeien> mmorrow: hey, that's dutch
18:23:26 <mrehayden> someone also said they hang out here last time i asked
18:23:29 <Heffalump> (that's a joke because bos is here, in case that's not obvious)
18:23:40 <bos> :-)
18:23:41 <geezusfreeek> lisp's syntax can surely get ugly if you aren't careful, but confusing? it's really quite simple
18:23:46 <mrehayden> i cant decide if that's very cool, or very sad
18:23:47 <ozy`> mrehayden: yeah, I don't know how anyone could possibly keep track of all the esoteric syntax rules that lisp uses in every single line of code
18:23:48 <ddarius> Heffalump: Nice cover
18:24:19 <geezusfreeek> ozy`, :P
18:24:27 <bork1> can anyone shed any light on what I'm doing wrong here in my definition of f?  http://hpaste.org/13327
18:24:32 <hiredman> ozy`: which lisp are you calling lisp?
18:24:32 <mrehayden> my parenthesies fingers get worn out too quickly
18:24:43 <mrehayden> seriously, the list thing in lisp just wears me out
18:24:53 <geezusfreeek> i can agree with that
18:25:29 <bos> Heffalump: we have pretty thick skins after 18 months of reading reviews from people reading drafts of the book :-)
18:25:48 <mrehayden> i found your book online
18:25:49 <Heffalump> hehe
18:26:03 <Heffalump> is the site uptodate for comments on the printed version, btw?
18:26:06 <mrehayden> on your own website
18:26:10 <koeien> bork1: your x
18:26:17 <bos> no, the site is a few months behind on copyediting and the like.
18:26:26 <koeien> bork1: should be both a "RealFrac" (like a real number)
18:26:38 <koeien> bork1: and an "Integral" (whole number) at the same time
18:26:39 <bos> o'reilly has a different workflow than we did, so it's a pain to integrate their edits back into our source.
18:26:43 <mrehayden> did you realise that people dont have to buy the book now you've put it online
18:26:52 <bos> mrehayden: precisely the point, really.
18:26:52 <koeien> bork1: because sqrt expects a RealFrac, and mod expects an integral
18:27:03 <Heffalump> I found an error in the printed one I'd like to report, also it might be nice to be able to deal with the inevitable "keeping up to date with the world" issues
18:27:08 <ozy`> mrehayden: I read the book online and only then decided to buy it
18:27:09 <geezusfreeek> that won't stop too many people from buying the book :P
18:27:09 <gwern> mrehayden: and yet people who read it online also have bought it
18:27:12 <bos> mrehayden: but actually, it's the best-selling o'reilly book in a few years.
18:27:15 <Olathe> bork1: sqrt(fromIntegral x) I think.
18:27:22 <gwern> mrehayden: perhaps people find value in physical copies
18:27:24 <koeien> Olathe: that is a solution, yes
18:27:25 <mrehayden> i want to buy it actually
18:27:33 <gwern> bos: have you really been writing RWH for 18 months now?
18:27:35 <mrehayden> it looks like a good-un
18:27:40 <geezusfreeek> i still haven't bought it either, but i intend too
18:27:46 <Heffalump> it's also quite cheap
18:27:46 <gwern> somehow it doesn't feel like it's been that long
18:27:50 <geezusfreeek> too many people i know who i would like to lend it to :)
18:28:04 <mrehayden> im going to go to #perl and tell them it's better than that camel book trite
18:28:05 <blackdog> so,
18:28:24 <bork1> Olathe: thanks =)
18:28:27 <blackdog> I have some operations on an IntMap that's taking a large percentage of my runtime and allocation
18:28:30 <bos> gwern: we started in april 2007, and ended in sep 2008.
18:28:40 <blackdog> is the next move moving it to STArray?
18:28:42 <koeien> is there a dutch importer of RWH? or do I have to order at amazon or something?
18:28:54 <bos> koeien: i don't know, sorry.
18:29:04 <mrehayden> so is RWH a good book to learn optimisation?
18:29:04 <gwern> bos: oh wow. I'll remember that if I ever get the insane urge to write a technical book!
18:29:21 <blackdog> mrehayden: yeah. check it out on the web, there's a really good chapter on profiling.
18:29:23 <bos> gwern: and writing it in 18 months was *really* fast for its size.
18:29:24 <geezusfreeek> mrehayden, i believe there is a rather large section devoted to optimization
18:29:30 <blackdog> bos: 'pologies for flattery
18:29:32 <bos> graham hutton took 7 years to write his haskell book!
18:29:42 <bos> blackdog: np :-)
18:29:54 <mrehayden> profiling is a laborious task, better to invest time in learning how to do it properly
18:30:08 <Olathe> bork1: You're welcome.
18:30:09 <gwern> 7 years? but surely he was doing research and teaching also
18:30:40 <bos> gwern: we were working full-time while writing our book, too
18:31:00 <mrehayden> i honestly thing fp ruined my life
18:31:14 <mrehayden> im saying that as a java programmer
18:31:16 <geezusfreeek> mrehayden, it ruined mine :P i don't want to use anything else
18:31:46 <geezusfreeek> but i use mostly C/C++ at work without too much touble
18:31:47 <Olathe> ghc needs to compile to Java code.
18:31:49 <geezusfreeek> *trouble
18:32:13 <geezusfreeek> the hardest thing is avoiding using some functional idioms on a team project
18:32:27 <mrehayden> with fp you dont need a team
18:32:31 <mrehayden> that's my dream
18:32:32 <geezusfreeek> ;)
18:32:48 <mrehayden> not because i'm a sociopath
18:32:55 <geezusfreeek> still better with a team though. just... hopefully one that does FP
18:33:05 <mrehayden> although being sociopathic doesn't help
18:34:01 <mrehayden> i saw a paper from an american student who write a 3D game engine in haskell as part of his degree
18:34:25 <mrehayden> either he was an overmasterbating agorophobic, or just a clever guy
18:34:50 <mrehayden> clever to choose such a powerful way to program, one in which you can do amazing things singlehanded
18:35:03 <gwern> mrehayden: frag?
18:35:07 <mrehayden> aye
18:35:18 <blackdog> i think it's a matter of choosing all the advantages you can. i'd much rather hack haskell with other people.
18:35:20 <mrehayden> i was very impressed
18:35:38 <mrehayden> but how many hackers do you know that can program in haskell?
18:35:49 <blackdog> i went to UNSW, so quite a lot :)
18:36:04 <mrehayden> i went to UCL, so i can count them on one handd
18:36:19 <mrehayden> UCL = java for dummies
18:37:01 <blackdog> yeah, i was pretty lucky. UNSW had dons, chak, gabi keller, seafood, ... heaps of smart haskell hackers
18:38:38 <mrehayden> i dont know them
18:39:14 <blackdog> don wrote RWH with bos, chak wrote chunks of GHC...
18:40:03 <mrehayden> what is it written in?
18:40:11 <mrehayden> dont tell me, haskell
18:41:06 <blackdog> no no, english. mostly.
18:42:09 <blackdog> ... i'll get me coat
18:43:39 <geezusfreeek> yeah, mostly haskell
18:46:17 <afabian> Mostly, programming is an exercise in managing complexity.  No matter what, you eventually hit the wall.  But if your programs are easier to reason about, more compartmentalized, and testable in small units, the wall should be further out.  Also, I think it'll be good to know a functional language in the multi-core trend continues.
18:46:58 <mrehayden> the beauty of fp is that you dont make side-effects, the complexity just isn't there anymor
18:50:16 <mrehayden> im interested about how I can apply it to real problems, i still have the von Neumann architecture in my head
18:52:03 <mrehayden> any xslt gurus here?
18:52:09 <gwern> I think we need to remember the distinction between intrinsic and accidental complexity
18:53:21 <mrehayden> if your reasoning about a language in such a pure manner, the complexity of the problem will become quite apparent
18:53:26 <defun> what is the difference between "data <some-type-name>" and "type <some-type-name>"?
18:53:39 <gwern> the advantage of haskell is that it removes a lot of the accidental compelexity of forcing lowlevel concepts on one (an approach generally accepted by the likes of python ruby lisp etc), but we *also* beleive always specifying evaluation order, even when it is unnecessary, is a previously unrecognized source of accidental complexity
18:53:51 <gwern> laziness then forces us to be pure
18:55:09 <mrehayden> but if you program in perl, there is no forgiveness
18:55:52 <blackdog> i have an incriminating quote:
18:55:52 <blackdog> 13:54 <shapr> I think in C
18:55:55 <shapr> nooo
18:55:58 <blackdog> burn the heretic
18:55:58 <gwern> haskell does nothing about the intrinsic complexity of a program
18:56:01 <shapr> I was talking about Centigrade!
18:56:10 <gwern> shapr: a likely story!
18:56:14 <mrehayden> bahaha
18:56:17 * shapr begs for his life
18:56:34 * blackdog grins evilly
18:56:45 <shapr> Bah, back to packing...
18:56:45 <blackdog> no-one expects the functional inquisition
18:56:54 * shapr throws spiky lambdas at blackdog
18:57:00 <mrehayden> "but programming in C lets me cast byte arrays into anything i like"
18:57:05 <mrehayden> SILENCE heretic
18:57:43 <mrehayden> there's only one good thing for C, boot strapping haskell compilers
18:57:57 <Gracenotes_> :3
18:59:34 <Gracenotes_> so, I believe this is terribly inefficient (with nextR :: State Int Int)...
18:59:39 <Gracenotes_> allRandom seed lim = unfoldr (\s -> let num = execState s seed in Just (num `mod` lim, s >> nextR)) nextR
19:00:12 <Gracenotes_> because, for every next item in the list, it runs through the entire sequence of seeds until that point
19:00:29 <Gracenotes_> allRandom is supposed to be a lazy list of psuedorandom numbers, by the way, and this is more of a self-exercise
19:00:40 <Gracenotes_> any way to make it *not* terribly inefficient?
19:00:48 <ddarius> mrehayden: GHC was bootstrapped by HBC which was bootstrapped by LML which was bootstrapped in assembly I believe.
19:03:25 <gwern> and jehosopat begat samuel and samuel begat Zechariah, and Zechariah begat Maniel and Zippa, who begat...
19:04:11 <Gracenotes_> gwern: dipping your toes in 1 Chronicles?
19:04:21 <gwern> not a fan of th gospels eh
19:05:06 <Gracenotes_> there are two geneologies in the New Testament. nowhere near enough!
19:05:16 <mreh> my religion is based upon larry niven books
19:05:20 <gwern> more than enough...
19:05:32 <gwern> mreh: is the first command TANJ?
19:05:37 <gwern> pessimistic religion
19:05:45 <gwern> but at least it has a ready theodicy :)
19:07:32 * Gracenotes_ mellows out and listens to some Mahler
19:07:48 <mreh> TANJ?
19:07:51 <Gracenotes_> (it is possible to do both at the same time, I believe)
19:08:41 <gwern> you don't know tanj? then your claim is a sham!
19:08:57 <buu> Hey, I'm looking for some information on 'lambdabot's dynamic function composition'
19:09:00 <buu> Can anyone share any details?
19:09:13 <mreh> i read a book by larry niven
19:09:16 <mreh> ojay
19:09:29 <gwern> buu: dynamic function composition? which does what exactly?
19:09:34 <buu> gwern: I have no idea.
19:09:50 <mreh> right now im into my philosophy
19:09:56 <buu> "Lambdabot is written in Haskell, and supports plugins for adding new commands. It has many plugins, including:  [...] #  Dynamic plugin composition "
19:10:15 <mreh> descartes is currently on my bedsite table
19:10:28 <gwern> hm. it's possible to fead @stuff into other @stuffs, I think I once saw done
19:10:40 <mreh> the meditations are quite ghastly
19:11:06 <gwern> mreh: descartes is a bit overdone. why don't you go read some cicero? his _On Moral Ends_ is quite interesting in its discussions of stoicism and epicureanism
19:11:19 <puusorsa> descartes was a mron
19:11:26 <Gracenotes_> *moran
19:11:29 <puusorsa> and i can type + am not drunk
19:11:50 <puusorsa> well maybe not moron, but the homonculus thing is silly
19:12:08 <puusorsa> endeless recursion until heads explode, everybody dead
19:12:28 <gwern> Gracenotes_: well played
19:12:43 <gwern> puusorsa: descartes was not a moron.
19:12:50 <mreh> cartestian circle?
19:12:58 <mreh> he founded the basis of modern knowledge
19:13:03 <mreh> one based upon doubt
19:13:18 <buu> mreh: Hey, do you know how lambdabot's function composition works?
19:13:24 <buu> Or rather, plugin.
19:13:24 <gwern> he was, if we are going to pin blame, a victim of his circumstances as a christian. his illicit philosophical moves are strictly done to support catholic orthodoxy
19:13:51 <puusorsa> duno really, onyl met him once or twice briefly
19:13:51 <gwern> if he had followed his reasonings to their logical ends, he would've beaten Hume, among others, to the punch by centuries
19:13:58 <mreh> "are they people i can see walking out my window? how do i now know they are not just hats and coats shuffling about" favourtie quote
19:14:05 <Olathe> I'd say Bacon was the founder of modern knowledge.
19:14:12 <puusorsa> or it could'eve been the other other one
19:14:21 <puusorsa> who knows, i know i don\t
19:14:34 <pumpkin> Olathe: bacon? http://www.bbqaddicts.com/blog/recipes/bacon-explosion/
19:14:39 <Olathe> Heheh
19:14:48 <mreh> Francis Bacon, painter
19:14:56 <pumpkin> ohh
19:14:59 <pumpkin> I prefer back bacon
19:15:08 <mreh> streaky
19:15:10 <puusorsa> btu after reading to omuch dennet i think descartes wasn't the brightest
19:15:13 <Gracenotes_> pumpkin: *blergh*
19:15:15 <mreh> this is descending into lunacy
19:15:18 <pumpkin> Gracenotes_: lol
19:15:24 <Gracenotes_> oh my god. ew.
19:15:26 <pumpkin> Gracenotes_: I'm going to make one of those now
19:15:37 <pumpkin> or try, at least
19:15:37 <puusorsa> CHUBKY BNACOKO!N
19:15:40 <BMeph> pumpkin: You should make your own brand of bacon - call it "Francis Painter"! ;p
19:15:44 <pumpkin> lol
19:16:18 <mreh> descarte wasn't really what you would have called an orthodox christian
19:16:21 <gwern> why does every philosophy discussion here degenerate into bacon? :(
19:16:40 <mreh> he appeared at a christening claiming to be the father of the bastard girl being baptised
19:16:42 <Gracenotes_> still, I do see people often criticize Descartes for some of his published ideas
19:16:49 <gwern> mreh: heck of a lot more orthodox that the skeptical atheistical materialist his arguments lead to
19:17:16 <Gracenotes_> it's almost like he's the universal straw man of religious argument :/
19:17:20 <mreh> eitherway, i dont think his ideas were motivated by emotion
19:17:25 <Gracenotes_> (well, maybe not universal)
19:18:42 <gwern> one good thing about descartes is that he's so easy to read
19:18:45 <puusorsa> ahving some smaller person inside ones head doing all the consciousness experiencing things and such not to forget the other other thing
19:18:45 <mreh> did you know he never woke up before 12, had a permanent cough, and liked to work in a oven
19:18:50 <puusorsa> as is generally known
19:19:11 <puusorsa> is most notvery unfnnny
19:19:28 <gwern> mreh: my understanding was that he woke up at a normal time but worked in bed
19:19:32 <puusorsa> as need of another even smaller one is realized inside the one beore the scond
19:19:38 <gwern> a wise practice, given that getting up early killed him
19:19:43 <mreh> he advocated not getting up early
19:19:55 <Gracenotes_> gwern: he still had to venture out of his bed to get food, though
19:20:00 <puusorsa> i advocate gettign up whem you wake up
19:20:06 * Gracenotes_ sighs
19:20:06 <puusorsa> around 17:00 or someting is ine
19:20:08 <puusorsa> fine
19:20:37 <gwern> Gracenotes_: maybe not. he wasn't poor, and human labor was much cheaper back then
19:20:52 <mreh> he was of semi noble birth i think anyway
19:21:22 <mreh> actually, he served in the army
19:21:31 <Gracenotes_> anyway, would any recommend any Mahler symphonies...? I've been listening to Broadway musical soundtracks for the past few weeks, so any change would be welcome
19:21:35 <Gracenotes_> *anyone
19:21:53 <mreh> dutch army, wikipedia says
19:21:54 <puusorsa> no. try someting like merzbow instead
19:22:02 <mreh> hell no
19:22:07 <mreh> try something GOOD
19:22:18 <puusorsa> like candy
19:22:26 <puusorsa> or squirrels
19:22:28 <mreh> like some buddy rich
19:22:29 <Gracenotes_> I like late Romanticism a lot
19:22:56 <puusorsa> i pretend to like all kinds of horrible shit to get attention!
19:23:13 <puusorsa> IS IT WORKING IS IT IS IT??A)
19:23:18 <Gracenotes_> puusorsa: how can you live with yourself?
19:23:24 <mreh> haha
19:23:33 <puusorsa> i can't
19:23:46 <puusorsa> that's why itook an overdose of pills and drank all the booze
19:23:52 <puusorsa> shouldn't take long now
19:24:26 <mreh> anyone tried Nietzsche?
19:24:30 <Gracenotes_> if you can't live with yourself, you could always just rent another apartment.
19:24:51 <gwern> mreh: tried?
19:24:54 <roconnor> @instances MonadFix
19:24:55 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:24:55 <puusorsa> mreh, read the books, didn't know if they made a musical of them
19:25:02 <gwern> mreh: dude, today I got a 'Nietzsche is my copilot' tshirt
19:25:04 <puusorsa> if ou mean is he any good between the sheets, then no
19:25:09 <roconnor> Cont isn't a member of MonadFix?
19:25:39 <Gracenotes_> puusorsa: I do agree, though, saying that one likes a musical movement is sort of a vacuous thing to say.
19:25:56 <mreh> have you read any?
19:26:03 <gwern> of course
19:26:06 <mreh> would he make a good co-pilot
19:26:14 <gwern> the ubermost
19:26:33 <mreh> you would say "pre-flight checks"
19:26:37 <gwern> and certainly better than jesus
19:26:45 <mreh> and he would decontruct everything you just said
19:26:49 <puusorsa> dunno, never did jesus
19:27:21 <mreh> there is no objective moral sense in flying this plane
19:27:31 <mreh> so im ejecting all of our fuel
19:27:51 <gwern> that isn't really what nietzsche would do
19:27:53 <mreh> stuff happens, i cant be held responsible
19:28:03 <puusorsa> i'd like to die in my sleep peacefully, like my uncle
19:28:12 <puusorsa> nto screaming in horror like all his passengers
19:28:18 <gwern> puusorsa: old, very old
19:28:25 <mreh> seriously mate, take it somewhere else
19:28:28 <puusorsa> yeah, like jesus
19:29:17 <mreh> is Neitzsche a useful philosopher?
19:30:22 <mreh> that's really the question of philosophy, reality is dictated by what people say, which is im sure what he would agree with, possibly on a different semantic level
19:30:36 <mreh> am i alone in this discussion? shall we move onto a different topic
19:30:53 <gwern> useful?
19:30:59 <gwern> I'd need to know what you mean by that
19:31:13 <mreh> is he pragmatic
19:31:32 <mreh> i know he would say "what is useful" right
19:31:40 <gwern> he can be inspiring; his eternal return can be either depressing or a spur to do what you know you ought to; his assaults on religion are interesting; but useful?
19:31:40 <araujo> quite much i'd say
19:31:43 <gwern> dunno
19:31:44 <mreh> but all philopshy is an art of coping
19:31:46 <Gracenotes_> hrm. what *is* one's motivation for studying philosophy?
19:31:51 <araujo> more than jesus if you want to put it that way :-)
19:31:56 * Gracenotes_ doesn't feel terribly motivated :/
19:31:59 <puusorsa> he's like batshit crazy and still/because of that makes a lot more sense than the so called sane ones
19:31:59 <araujo> but .. this conversation probably belongs somewhere else
19:32:45 <gwern> Gracenotes_: getting new ways of looking at things, I value it for
19:32:57 <mreh> it passes the time before you die
19:33:41 <Gracenotes_> hm.
19:33:43 <mreh> anyone here beleive in life after death?
19:33:56 <puusorsa> anyone here believe in life before death?
19:34:32 <mreh> awww
19:35:13 <mreh> look up monad in the dictionary
19:35:34 <puusorsa> warm fuzzy thing?
19:35:38 <gwern> @wn monad
19:35:39 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
19:35:39 <lambdabot> monad
19:35:39 <lambdabot>      n 1: an atom having a valence of one
19:35:39 <lambdabot>      2: a singular metaphysical entity from which material
19:35:39 <lambdabot>         properties are said to derive [syn: {monas}]
19:35:41 <lambdabot>      [also: {monades} (pl)]
19:36:08 <gwern> surprised it didn't attribute to leibniz. I mean, if it had room to list plurals and synonyms...
19:36:32 <Gracenotes_> meh, I can't access OED from home
19:36:33 <mreh> haha
19:36:43 <gwern> Gracenotes_: why I own a Compact one
19:36:45 * araujo likes Leibniz monad definition
19:36:47 <gwern> no DRM there
19:36:55 <polveroj> well, wordnet is a database of word relationships, so it makes sense it'd have all the plurals/synonyms even if the definition wasn't in-depth
19:37:13 <Gracenotes_> heh. yeah. and it seems I can't SSH into my school's servers, as far as I can tell
19:37:35 <Gracenotes_> nvm.
19:37:36 <gwern> Gracenotes_: why not go through the library website? they do cookie logins if you aren't from a SBU IP
19:38:16 <mreh> anyway im off
19:38:18 <Gracenotes_> oh, yes
19:38:18 <mmorrow> @src Cont mfix
19:38:19 <lambdabot> Source not found. Are you on drugs?
19:38:20 <gwern> as do most schools
19:38:26 <mreh> atheists unite! allah akbah!
19:38:39 <Gracenotes_> the wonders of technology
19:38:57 <mreh> hare krishna
19:39:01 * araujo thinks atheism is other form of religion
19:39:02 <Gracenotes_> now I'm handily connected to dictionary.oed.com.libproxy.cc.stonybrook.edu
19:39:13 <araujo> anyway
19:39:17 <araujo> In Haskell We trust
19:39:22 <mmorrow> , \f -> mdo x <- f x; (return::a->Cont r a) x
19:39:23 <lunabot>  luna: No instance for (Control.Monad.Fix.MonadFix
19:39:25 <mreh> yeah, dawkings lecture titled "atheist's call to arms"
19:39:33 <mreh> hmmm
19:39:43 <gwern> mreh: does 'allah akbar' mean god is not great, since one dropped a 'u'?
19:39:58 <Gracenotes_> oh, damn, I need to finish the makeup assignment for my first year seminar course
19:40:00 <mreh> no
19:40:04 <mreh> i cant spell
19:40:13 * Gracenotes_ shouldn't have missed all those classes
19:40:31 <gwern> Gracenotes_: they're being generous even letting you do it this late, sounds like
19:41:02 * araujo throws a monad into the channel
19:41:09 <puusorsa> god delusion was nice
19:41:09 <Gracenotes_> yeah. :/ it doesn't factor into my GPA, but I should still finish it anyway.
19:41:17 <mreh> didnt read it
19:41:23 <mreh> all i know is that alot of people have read it
19:41:43 <mreh> and nothing else, a bit like THE BIBLE
19:41:45 <gwern> I found god delusion boring
19:41:46 <puusorsa> changed y mind about 83498 times
19:41:56 <gwern> I suppose I've read too much material on religion
19:41:58 * mmorrow (const (fix error) =<<)
19:42:29 <Gracenotes_> mreh: people read the bible?
19:42:30 <puusorsa> bt n the end nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn aifj iseim wasnt as bad as i thought
19:42:54 <mreh> yeah
19:43:00 <mreh> it's a good peice of literature
19:43:10 <araujo> where?
19:43:11 <puusorsa> nothing wrong with god(s)
19:43:14 <mreh> if i was part of a religion, id like a good peice of literature behind it
19:43:27 <puusorsa> it's the people who elieve that's the problem
19:43:45 <mreh> yeah, that's right, you tell them
19:43:49 <mreh> religions start wars
19:44:02 * araujo doesn't know why he read that like star wars
19:44:03 <araujo> btw
19:44:04 <puusorsa> i've met him/her/it,whatever, nice whatever it is
19:44:08 <araujo> that is almost another religion
19:44:09 <araujo> hah
19:44:10 <dolio> If I were part of a religion, I wouldn't be brining it up randomly in this channel.
19:44:11 <Gracenotes_> so if no one believed in gods, then we wouldn't have problems
19:44:21 <Gracenotes_> but then the gods might get angry, which would be a problem
19:44:30 <puusorsa> btu then i was real fcking high atm
19:44:35 <mreh> oh... hang on, have you heard of the jacobians?
19:44:40 * araujo thinks the concept of god(s) make more problems than it solves
19:44:42 <puusorsa> it's the sober persons meeting god that's sary
19:44:43 <mreh> they were atheists!
19:44:44 <mmorrow> speaking of wars, i've on-and-off thought of a good game for bots to play against each other in an irc channel (where the losers die of course)
19:44:48 <mreh> and they killed each other
19:45:10 <mmorrow> #botwar would be amusing x10
19:45:19 <puusorsa> araujo, personalified universe then
19:45:20 <mmorrow> losers are banned
19:45:22 <mreh> the only thing that drivers war is a human desire of absolute certainty
19:45:28 <Gracenotes_> mmorrow: so there would have to a moderator bot
19:45:34 <Gracenotes_> at least one moderator bot
19:45:35 <mmorrow> Gracenotes_: yes, exactly
19:45:39 <araujo> puusorsa, are you asking me .. that?
19:45:44 <mreh> how do botwars work? i've heard about them?
19:45:45 <puusorsa> can't think of better, god is close enough
19:45:50 <puusorsa> araujo, maybe
19:45:52 <mreh> do you war to gain control?
19:45:55 <mmorrow> but i can't think of a good game for them to play
19:45:59 <araujo> puusorsa, why should we personify universe?
19:46:05 <mmorrow> i'm not sure, but that's a good start actually
19:46:10 <puusorsa> i'm not saying we should
19:46:10 <gwern> werewolf
19:46:13 <Gracenotes_> ultimately botwars would come down to latency
19:46:25 <mreh> it would be like playing an RPG
19:46:29 <puusorsa> but if you find yourself unsober enoiugh and the bastard does so
19:46:29 <mreh> boooooring
19:46:30 <mmorrow> Gracenotes_: we'd have to make it so that's not a factor
19:46:34 <araujo> puusorsa, and if that's what god(s) make ... it still creates more problems than what it solves
19:46:45 <Gracenotes_> unless a game could be designed in which the bot with the most intelligent heuristics wins
19:46:54 <mreh> the turing test?
19:46:58 <araujo> only with a god concept... you still have the question .. who created god?
19:46:59 <mmorrow> mreh: but you don't get to play, your bot does. that would make it very interesting i'd think
19:47:04 <puusorsa> even if god is not exact match , it's close enough
19:47:12 <Gracenotes_> for instance, guessing a word.
19:47:20 <Gracenotes_> bots register guesses, and the moderator gives partial information
19:47:31 <mmorrow> and if you "lose" (whatever that would mean), your bot's ip gets banned for a day or something
19:47:35 <araujo> a god concept only delays such a question (of who created the universe) one step back ... so it is not really valid argument to solve it
19:47:42 <Gracenotes_> the bot that pieces together all the information the best wins
19:47:46 <mmorrow> hmm
19:47:54 <mreh> sounds fun
19:48:08 <mmorrow> i was thinking an element of bot-to-bot-combat would be essential
19:48:09 <mreh> what about real human contact?
19:48:24 <mreh> are you all from america?
19:48:30 <Gracenotes_> mmorrow: bots would gleam information from the others' guesses
19:48:41 <puusorsa> mreh, almost
19:48:50 <defun> In haskell (obviously), what is deconstruction?
19:48:52 <mreh> anyone from london here?
19:49:04 <puusorsa> they;ll take over funland in a few years and then i will be
19:49:06 <mmorrow> Gracenotes_: interesting
19:49:57 <Gracenotes_> perhaps private messages to the bots could be used so that not all information is common
19:50:13 <mreh> can you write bots in haskell?
19:50:20 <mmorrow> , [0..]
19:50:23 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
19:50:23 <mmorrow> > [0..]
19:50:24 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:50:38 <Gracenotes_> writing some kind of IRC bot in haskell is one of my longterm projects...
19:50:47 <mreh> > fold [0..] +
19:50:47 <lambdabot>   <no location info>: parse error on input `;'
19:50:52 <mreh> haha
19:51:11 <Gracenotes_> which, of course, has not materialized at all
19:51:15 <Gracenotes_> thus far
19:51:36 <gwern> Gracenotes_: I'd tackle smaller projects
19:51:38 <gwern> first
19:51:40 <pumpkin> mreh: even the ##c++ bot is written in haskell :P
19:51:48 <Gracenotes_> yes, I think so :)
19:51:48 <mreh> hahaha
19:51:51 <mmorrow> naw, bots aren't very hard at all
19:52:02 <mmorrow> (to get a minimally functional bot)
19:52:06 <Gracenotes_> it's mostly the concurrency/IO combination
19:52:06 <pumpkin> says the botmeister
19:52:29 <Gracenotes_> one must output and input simultaneously
19:52:38 <mmorrow> pumpkin: if you saw the bot-part of lunabot you'd puke in your mouth a little bit
19:52:45 <Gracenotes_> although in freenode, you can get by without responding to PINGs for a few hours
19:52:56 <pumpkin> :o
19:53:18 <mmorrow> one can get a working bot in 10 minutes with this:
19:53:20 <Gracenotes_> longer than that I think
19:53:20 <mmorrow> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
19:53:33 <mmorrow> also, there's:
19:53:34 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
19:53:38 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ircbouncer
19:53:41 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/infinity
19:53:59 <mreh> anyone from London here?
19:54:27 <mmorrow> mreh: a bunch of people (but maybe not at the moment)
19:54:46 <pumpkin> mreh: I was born there, if that counts :P
19:54:54 <pumpkin> why?
19:55:20 <mreh> does lennart hang here?
19:55:27 <pumpkin> I think so
19:55:32 <mmorrow> preflex: seen augustss
19:55:33 <preflex>  augustss was last seen on #haskell 1 day, 2 hours, 44 minutes and 31 seconds ago, saying: Lua in the lead, huh.
19:55:37 <mreh> im just interested in talking to people who do FP in this country
19:55:38 <gwern> augustss_ you mean?
19:55:47 <mmorrow> preflex: seen augustss_
19:55:47 <preflex>  augustss_ was last seen on #haskell 3 hours, 34 minutes and 3 seconds ago, saying: I don't really care much, though.
19:55:57 <mreh> sweet
19:56:09 <mmorrow> oh yeah, another bot:
19:56:12 <mreh> friend of mine suggested i talk to him
19:56:13 <mmorrow> preflex: 8ball
19:56:14 <preflex>  what
19:56:28 <mreh> does he still work for credit swisse?
19:56:28 <mmorrow> preflex: 8ball will i get a pony for christmass ???!!?
19:56:28 <preflex>  cannot predict now
19:56:59 <gwern> mreh: believe so
19:57:42 <mmorrow> ah, here's the full code to don's ircbot tutorial
19:57:43 <mmorrow> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
19:59:11 <mmorrow> here's a quicky (and working) irc msg parser copy/paste ready  http://hpaste.org/12802
19:59:14 <Gracenotes_> what are all the *Ts? ReaderT, WriterT, StateT
19:59:35 <mmorrow> monad transformers
19:59:36 <Gracenotes_> mmorrow: heh, it seems I bookmarked that a few weeks ago for some reason
19:59:43 <mmorrow> Gracenotes_: :)
20:00:00 <Gracenotes_> oh, I see. I have seen the idea of monad transformers thrown around previously.
20:00:04 <mmorrow> @unmtl StateT s m a
20:00:05 <lambdabot> s -> m (a, s)
20:00:09 <mmorrow> @unmtl State s a
20:00:09 <lambdabot> s -> (a, s)
20:00:40 <mmorrow> basically  SomeMonadT foo Identity bar == SomeMonad foo bar
20:00:58 <mmorrow> runSomeMonadT = runIdentity . runSomeMonad
20:01:38 <bd_> mmorrow: other way
20:01:44 <bd_> runSomeMonad = runIdentity . runSomeMonadI
20:01:53 <mmorrow> @type \m s -> runIdentity (runState m s)
20:01:54 <lambdabot>     Couldn't match expected type `Identity a'
20:01:54 <lambdabot>            against inferred type `(a1, s)'
20:01:54 <lambdabot>     In the first argument of `runIdentity', namely `(runState m s)'
20:02:08 <mmorrow> bd_: oh, oops
20:02:14 <Gracenotes_> is there a MaybeT?
20:02:19 <mmorrow> @type \m s -> runIdentity (runStateT m s)
20:02:20 <lambdabot> forall s a. StateT s Identity a -> s -> (a, s)
20:02:22 <mreh> see you later
20:02:26 <mmorrow> see ya
20:03:07 <mmorrow> @unmtl Identity a
20:03:07 <lambdabot> a
20:03:18 <mmorrow> i wish it was called Id
20:03:28 <mmorrow> Identity is so verbose
20:03:35 <mmorrow> especially given what it is
20:03:39 <shapr> @yow !
20:03:39 <lambdabot> You can't hurt me!!  I have an ASSUMABLE MORTGAGE!!
20:03:43 <shapr> @users
20:03:44 <lambdabot> Maximum users seen in #haskell: 568, currently: 502 (88.4%), active: 15 (3.0%)
20:04:00 <mmorrow> Gracenotes_: yes, there's a MaybeT on hackage
20:04:43 <b800> so i'm kind of a haskell newbie, and I was playing around with trying to abstract stuff, and I ran into a problem
20:04:52 <b800> would anyone be willing to take a look if i pastebin it?
20:05:00 <mmorrow> i'm sure :)
20:05:05 <Gracenotes_> mm_freak_: Firefox tells me I've visited the page http://www.haskell.org/haskellwiki/New_monads/MaybeT, not sure why though >_>
20:05:09 <Gracenotes_> er, mmorrow
20:05:23 <Gracenotes_> iirc someone else was asking for it.
20:05:35 <b800> http://hpaste.org/13328
20:06:16 <b800> i'm using Takeable to try to abstract the idea of something that can be stepped with some function, and some value extracted out at some step
20:06:35 <geezusfreeek> :t join (***)
20:06:36 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
20:06:51 * geezusfreeek wants ^ in a standard lib somewhere
20:07:51 <b800> anyway, so i've annotated it w/ the problem
20:08:09 <b800> it doesn't seem to me like it should need to be able to deduce (Num b)
20:08:16 <mmorrow> b800: ah, so this is the catch that doesn't allow (e.g.) Set to be a monad
20:08:35 <b800> which is that?
20:08:49 <mmorrow> so you either have to add Num b to  step :: (Num b) => t b -> t b
20:09:02 <polveroj> b800: it needs to deduce (Num b) to do the multiplication in step
20:09:15 <b800> I don't want to have to restrict step to (Num b) though
20:09:18 <dolio> You can only use (*) on things in Num.
20:09:39 <mmorrow> actually, that's seems to be your only option without changing how you're doing things
20:09:48 <b800> mmorrow: that's what I feared
20:10:11 <b800> is there a better way to do things that pops right out?
20:10:34 <b800> other than not generalize Takeable, which is a waste w/ just the one instance
20:10:35 <mmorrow> b800: the problem is that you're making Oscillator an instance of Takeable _forall a_ Oscillator a, and what if a isn't an instance of Num?
20:10:42 <mmorrow> (since you're using (*))
20:11:18 <mmorrow> Oscilator String wouldn't make sense with you current def
20:11:51 <b800> yeah, I tried once something like 'instance (Num b) => Takeable (Oscillator b)', but that didn't work, obv
20:11:53 <mmorrow> (assuming you haven't made String an instance of Num, but even if you had s/String/another type not an instance of Num/)
20:12:39 <b800> so there's no way to explicitly restrict (Num b) in Oscillator b ?
20:12:43 <mmorrow> b800: the problem is that there's no way to constrain the typevar 'a' in the instance head, because it's not there
20:12:48 <mmorrow> yeah, exactly
20:13:26 <mmorrow> so it's a limitation of the syntax/implem of classes really i guess
20:13:27 <b800> so is there an obviously better way to abstract Takeable so that i can instantiate it resonably?
20:13:56 <mmorrow> maybe instead of having a class for Takeable, have a data
20:14:30 <mmorrow> data Takeable f a = Takeable { extract :: f a -> f, step :: f a -> f a }
20:14:35 <b800> constructed out of an extract and a step function
20:14:40 <b800> aha, just as i was typing it
20:14:40 <geezusfreeek> b800, is there ever a circumstance where it would make sense for the a in Oscillator a to not be an instance of Num?
20:14:45 <mmorrow> then pass the "dictionary" explicitly
20:14:48 <dolio> Takeable t is just saying that t b is a stream coalgebra.
20:14:53 <b800> geezusfreeek: no, not as far as i can tell
20:15:19 <b800> geezusfreeek: so it would be totally reasonable to restrict (Num b) in Oscillator b, but apparently i can't
20:15:27 <dolio> So just have the class be: class Takeable t where toStream :: t b -> Stream b
20:15:31 <dolio> Or [b] if you like.
20:15:55 <b800> is Stream an existing type?
20:16:00 <dolio> No.
20:16:15 <dolio> data Stream a = Cons a (Stream a)
20:16:41 <mmorrow> or Stream a = Nil | Cons a (Stream a)
20:16:43 <b800> agh, 'class Takeable t where toStream :: t b -> Stream b' is making my head hurt, one second
20:17:09 <dolio> Of course, using toStream as primitive doesn't give you back some t b after taking an arbitrary number of bs.
20:17:12 <b800> the main thing i have trouble with, in general, is anything not of kind *
20:17:34 <dolio> mmorrow: Those are lists, not streams.
20:17:40 <Gracenotes_> yay infinite data structures...
20:17:45 <mmorrow> dolio: ahh, i see.
20:18:31 <dolio> Despite the fact that "stream fusion" uses that type, essentially.
20:19:06 <b800> well, it's becoming more clear to me how a data for Takeable is more of a right thing
20:19:34 <mmorrow> b800: yeah, a data seems to me the easiest/lightest-weight way to go here
20:20:17 <mmorrow> it'll add a param to all your functions that were (Takeable t) =>, but so it is
20:20:52 <mmorrow> that's what the class was doing under the covers anyhow
20:21:04 <dolio> Anyhow, if you define "anaStream :: (s -> a) -> (s -> s) -> s -> [a] ; anaStream hd tl s = hd s : anaStream hd tl (tl s)"
20:21:31 <mmorrow> banananananana
20:21:43 * mmorrow couldn't help himself
20:21:43 <dolio> Then "anaStream extract step :: Takeable t => t a -> [a]"
20:21:51 <geezusfreeek> > "ba" ++ cycle "na"
20:21:52 <lambdabot>   "banananananananananananananananananananananananananananananananananananana...
20:21:57 <ddarius> mmorrow: Anamorphisms are lenses.
20:21:57 <mmorrow> dolio: ooh, nice
20:22:22 <mmorrow> ddarius: but a 'b' in front of anananananana was just too irresistable
20:22:45 <geezusfreeek> > 'b' : cycle "na" -- duh
20:22:46 <lambdabot>   "bnanananananananananananananananananananananananananananananananananananan...
20:22:52 <geezusfreeek> > 'b' : cycle "an" -- duh
20:22:53 <lambdabot>   "banananananananananananananananananananananananananananananananananananana...
20:22:54 <mmorrow> heh
20:24:25 <blackdog> does using uvector buy me anything over using UArrays and the ST monad?
20:24:45 <dolio> Marginally better optimization.
20:25:04 <blackdog> can you do the same things? ie, efficient localised mutable array ops
20:25:05 <blackdog> ?
20:25:26 <dolio> Are you talking about UArrays or STUArrays?
20:25:34 <blackdog> STUArrays, probably.
20:25:45 <dolio> uvector isn't good for UArray like stuff, since the pure arrays are for stream fusion.
20:25:52 <dolio> (And lookup isn't O(1))
20:25:56 <blackdog> i'm trying to work out what to convert my pure, elegant, lovely, IntMap-based, hopelessly slow code...
20:26:00 <blackdog> *to
20:26:13 <dolio> However, the mutable arrays produce slightly better code, because of Ix class woes, I believe.
20:27:35 <blackdog> ok, i'll have a hack at uvector. thanks.
20:27:59 <dolio> At least, something in STUArray fails to get specialized fully, so it ends up slower in extreme performance cases.
20:28:34 <mmorrow> blackdog: if you're doing a lot of indexing though, STUArray might be better i guess (since it's O(1))
20:28:51 <dolio> So is MUArr.
20:28:54 <dolio> It's UArr that isn't.
20:29:02 <mmorrow> ahh
20:29:05 <dolio> The pure arrays.
20:29:13 <mmorrow> i gotcha
20:29:26 <dolio> Because it gets turned into stream code, and stream lookup is O(n).
20:29:32 <mmorrow> dolio: were your patches to uvector ever merged in?
20:29:51 <dolio> Not yet, I don't think.
20:30:04 <dolio> They're not that critical.
20:30:18 <dolio> They give introsort a reason to exist. :)
20:30:27 <mmorrow> heh
20:30:43 <dolio> Since with the memcpy patch, mergesort beats it.
20:30:47 <dolio> *And* it's stable.
20:31:32 <mmorrow> that reminds me of this cool visualization of mergesort i re-came across the other day
20:31:38 * mmorrow finds it
20:31:40 <mmorrow> it's sweet
20:32:38 <mmorrow> http://www.edwardtufte.com/bboard/images/00027o-2540.jpg
20:32:42 <mmorrow> it's on this page:
20:32:48 <mmorrow> http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR&topic_id=1
20:33:03 <dolio> Of course, introsort could do better, but that requires GHC's optimizer to be improved, which is a little harder to accomplish..
20:33:06 <mmorrow> got there from  hackage hsparklines -> author's blog -> prev link
20:33:15 <dolio> For me, at least.
20:33:49 <mmorrow> hmm, what in particular would the optimizer need to optimize to achieve that
20:33:56 <mmorrow> (just the case of introsort)
20:34:01 <mmorrow> out of curiosity
20:34:19 <dolio> There are some tupled returns that don't get fully unboxed.
20:34:26 <mmorrow> the caption for that image is: "Here are the results of 7 sequential passes to sort a 200 element file in bottom-up merge sort:"
20:35:02 <mmorrow> dolio: hmm
20:37:35 <dolio> Specifically, there's missed optimization on calls to partition the array.
20:37:43 <dolio> I don't know how much performance that actually loses.
20:38:17 <mmorrow> so does this mean that (,) isn't getting turned into (#,#) ?
20:38:26 <mmorrow> or..?
20:40:09 <dolio> I'd have to go back and look at the specifics, but I think it's that (Int, Int) doesn't get turned into (# Int#, Int# #) or something of the sort.
20:40:27 <dolio> Just (# Int, Int #).
20:40:29 <mmorrow> hmm
20:40:31 <mmorrow> ah
20:41:11 <dolio> Which is needless allocation when the receiver immediately turns those back into Int#s.
20:41:24 <mmorrow> i wonder if data Tup a = Tup {-# UNPACK #-} !a {-# UNPACK #-} !a would fix that
20:41:37 <mmorrow> + -funbox-strict-fields
20:41:43 <dolio> And when the return is like: f x = ... ( I# i, I# j)
20:41:50 <mmorrow> ugh
20:41:58 <dolio> So you box and immediately unbox.
20:42:30 <mmorrow> that reminds me of how StateCPS is soooo much faster than State and State(#,#)
20:42:40 <mmorrow> or rather, s/how/why/
20:42:41 <dolio> And, first, you can't unback polymorphic fields like that.
20:42:49 <dolio> Unpack, even.
20:42:55 <mmorrow> oh yeah, well s/a/Int/ then
20:43:18 <dolio> Second, the source of all this is returning in the ST monad, which uses tuples internally, so I can't invent a custom tuple type that will get appropriately unpacked.
20:43:31 <mmorrow> too bad
20:43:41 <dolio> Yeah. There's a ticket in about it.
20:43:52 <dolio> So it'll probably get fixed eventually.
20:43:56 <mmorrow> oh i see, so it's in the (#,#) in
20:44:00 <mmorrow> , src ''ST
20:44:06 <lunabot>  luna: Not in scope: type constructor or class `ST'
20:44:10 <mmorrow> you know
20:44:14 <mmorrow> , src ''IO
20:44:21 <mmorrow> @src ST
20:44:21 <lambdabot> newtype ST s a = ST (STRep s a)
20:44:25 <mmorrow> @src STRep
20:44:25 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
20:44:26 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
20:44:26 <lunabot>                     (#,#) (State# RealWorld) a)
20:44:41 <mmorrow> err, no i guess that wouldn't be it
20:44:49 <mmorrow> whatever, i hear you
20:46:08 <mae> merry xmas
20:46:19 <dolio> mmorrow: http://hackage.haskell.org/trac/ghc/ticket/2387
20:46:20 <mmorrow> man, lunabot gets slowed to a crawl with ghc reading the package.conf + linking/loading imports for each expression
20:46:55 <mmorrow> + being on a horrendously slow machine to begin with
20:47:09 <mmorrow> linking anything with ld is a tediously long affair
20:47:19 <mmorrow> i'm not sure why (it's hosted)
20:47:39 <mmorrow> dolio: interesting
20:56:10 <Gracenotes_> @src [] msum
20:56:10 <lambdabot> Source not found. I am sorry.
20:56:39 <Gracenotes_> hrm. it would be something like concatMap id, though.
20:57:49 <dolio> @src msum
20:57:49 <lambdabot> msum =  foldr mplus mzero
20:58:47 <Gracenotes_> ah... why make instances when you can generalize quite nicely...
20:59:17 <mmorrow> preflex: seen conal
20:59:18 <preflex>  conal was last seen on #haskell 6 hours, 56 minutes and 37 seconds ago, saying: mmorrow: oh, interesting.  maybe my code works fine when compiled.
21:00:27 <mmorrow> @tell conal re: blackholes and bytecode: http://hackage.haskell.org/trac/ghc/ticket/2786 (the link therein to 2783 gives further good info)
21:00:27 <lambdabot> Consider it noted.
21:08:15 <Gracenotes_> @hoogle asks
21:08:15 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
21:10:09 <pumpkin> what does asks do?
21:14:00 <geezusfreeek> looks like it takes a function and returns a reader monad version of it
21:14:13 <Gracenotes_> apparently it can be used well with Handles
21:14:46 <geezusfreeek> :t ask
21:14:47 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
21:15:16 <geezusfreeek> i guess `asks f` is like `f =<< ask`
21:17:49 <mmorrow> return . f =<< ask
21:17:59 <mmorrow> or       f `fmap` ask
21:18:37 <mmorrow> where f is many times a record field selector
21:19:30 <mmorrow> Gracenotes_: getting ready for #botwars? ;)
21:20:13 <Gracenotes_> oh, not quite yet :P One needs a good moderator bot!
21:20:14 <Gracenotes_> asks socket >>= listen
21:20:25 <Gracenotes_> ^ is a line from the "roll your own IRC bot" that seems a bit odd
21:20:50 <Gracenotes_> listen is of type Handle -> Net (), where type Net = ReaderT Bot IO
21:20:56 <Gracenotes_> and data Bot = Bot { socket :: Handle, starttime :: ClockTime }
21:21:25 <Gracenotes_> just what does asks mean there?
21:21:27 <mmorrow> so  asks socket :: ReaderT Bot IO Handle
21:21:40 <mmorrow> h :: Handle <- asks socket
21:22:02 <mmorrow> oh, just saw the type syn
21:22:10 <mmorrow> asks socket :: Net Handle
21:23:03 <Gracenotes_> hm, I think I need to look into monad transformers
21:23:30 <mmorrow> asks basically is just for convenience when you've got a record type as your env in a Reader monad
21:24:12 <mmorrow> so you can do    asks someField    instead of    do env <- ask; let a = someFiled env; ..... a ....
21:25:32 <mmorrow> > flip runReader ([0..], "foo") (do xs <- asks (take 4 . fst); s <- asks snd; return (s,xs))
21:25:33 <lambdabot>   ("foo",[0,1,2,3])
21:26:03 <mmorrow> > flip runReaderT ([0..], "foo") (do xs <- asks (take 4 . fst); s <- asks snd; return (s,xs)) :: Maybe (String,[Int])
21:26:04 <lambdabot>   Just ("foo",[0,1,2,3])
21:26:23 <_roconnor> what is a loquacracy?
21:26:43 <mmorrow> @type (do xs <- asks (take 4 . fst); s <- asks snd; return (s,xs)) :: ReaderT ([Int],String) Maybe (String,[Int])
21:26:44 <lambdabot> ReaderT ([Int], String) Maybe (String, [Int])
21:26:50 <mmorrow> @type (do xs <- asks (take 4 . fst); s <- asks snd; return (s,xs)) :: ReaderT ([Int],String) IO (String,[Int])
21:26:51 <lambdabot> ReaderT ([Int], String) IO (String, [Int])
21:27:39 <luqui> _roconnor, from loquatious
21:27:58 <mmorrow> , flip runState (0,1) $ replicateM 10 (get >>= \(m,n) -> put (n,m+n) >> return m)
21:28:00 <lunabot>  luna: Ambiguous occurrence `get'
21:28:05 <luqui> _roconnor, er, loquacious
21:28:08 <Gracenotes_> whoever speaks the most gets heard the most?
21:28:33 <luqui> in quicksilver's words, "rule by the chattiest"
21:28:39 <mmorrow> heh
21:33:55 <_roconnor> :D
21:34:00 <Gracenotes_> I should note there are no results for loquacracies, although this will shortly change
21:34:21 <_roconnor> @go loquacracy
21:34:24 <lambdabot> http://planet.haskell.org/
21:34:24 <lambdabot> Title: Planet Haskell
21:34:39 <_roconnor> word of the year for 2009
21:35:04 <Gracenotes_> time to start lobbying Merriam-Webster
21:35:33 <dipmas> merry dipmas
21:36:21 <dipmas> I just got started with Haskell after getting very disappointed in Scheme
21:36:24 <dipmas> pretty cool
21:36:24 <Gracenotes_> hm, it is still Christmas in the Western US
21:37:32 <mmorrow> does anyone know of a good reference (preferably online) for garbage collect{ors,tion}?
21:38:07 <dipmas> mmorrow: What do you need specifically?
21:38:13 <mmorrow> i'm looking for a quick-but-complete-enough overview + implem details
21:38:16 <dipmas> I don't know offhand but I'm good at research
21:38:21 <dipmas> What, like Boehm GC?
21:38:29 <dipmas> Any specific algorithm?
21:38:45 <mmorrow> sure, i know relatively little about GC at all
21:38:46 <wli> Ochlocracy?
21:39:03 <wli> Maybe not in the event of "silent majorities."
21:39:17 <mmorrow> dipmas: what are some of the "standard" (but modern) algos?
21:39:34 <dipmas> mmorrow: Well, Boehm is a specific and popular one
21:39:39 <jql> http://tunes.org/wiki/garbage_20collection.html is a decent GC bibliography
21:39:44 <mmorrow> dipmas: also, i'm curious about incremental/concurrent collection
21:39:45 <procyon112> Ok, so I'm on Windows.  I'm using all the latest GHC.  I want bzlib from cabal, so I install cabal-install and pull it. I get a dependency on process-1.0.1.1 and the fun begins...
21:39:47 <dipmas> There are several general techniques as well
21:40:04 <mmorrow> jql: cool, thanks.
21:40:13 <procyon112> process requires "sh" to install.  Fabulous.  I install mingw and msys for this 1 package.
21:40:23 <dipmas> haha
21:40:26 <mmorrow> dipmas: the "tri-color abstraction" seems to be used quite a bit
21:40:34 <procyon112> It now still wont install with: ghc-pkg.exe: dependency base-4.0.0.0 doesn't exist
21:40:44 <Axman6> mmorrow: re: GC's, Apple recently released the one they use in their Objective-C runtime if you're interested. it's supposed to be pretty robust and easy to spply to other uses
21:40:52 <procyon112> Any pointers, other than the obvious "abandon windows"?
21:41:00 <dipmas> mmorrow: See here, as well: http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#External_links
21:41:03 <dipmas> Merry Dipmas
21:41:26 <mmorrow> thanks
21:41:44 <pumpkin> oh wow, I found mmorrow
21:41:51 <dipmas> There has to be something on freetechbooks.com in this vein...
21:41:52 <mmorrow> ?
21:41:56 <pumpkin> http://www.fhs.sfu.ca/portal_memberdata/mmorrow
21:42:07 <Axman6> pumpkin: don't abandon windows totally, but get a *nix box for haskell work?
21:42:07 <mmorrow> hmm, an imposter!
21:42:13 <Axman6> uh, procyon112 even
21:42:14 <pumpkin> Axman6: ?
21:42:15 <mmorrow> haha
21:42:17 <pumpkin> lol
21:42:41 <Gracenotes_> mmorrow, a community psychology PhD?
21:42:47 <Gracenotes_> mazel tov, sir :P
21:42:48 <pumpkin> yeah, who'da thunk?
21:43:12 <mmorrow> not quite, but now i have a site to direct unsuspecting people to :)
21:43:32 <procyon112> Axman6: I'm trying to interface GHC into my Win32 build env... Getting it working on Linux won't help there :)
21:44:02 <mmorrow> dipmas: oh nice, i didn't know about freetechbooks.com
21:44:10 <Axman6> procyon112: fwiw, i've had issues with having process-1.0.1.1 installed
21:44:44 <conal> mmorrow: thanks for the ghc bug pointer.  strangely, i think i'm finding just the reverse: ghci *is* reporting a black hole when there isn't one.
21:44:44 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
21:44:45 <dipmas> mmorrow: Other good places to look are: freecomputerbooks.com, freescience.info, and, if you don't object to piracy, pdfchm.net
21:44:55 <procyon112> Axman6: So, is there any way to shadow this package, so cabal-install won't see this version?
21:45:17 <mmorrow> conal: wow, really? does ghci report "<<loop>>"?
21:45:19 <dipmas> Excuse me, pdfchm.com
21:45:41 <mmorrow> dipmas: great, thx.
21:46:01 <conal> mmorrow: yes.
21:46:17 <conal> mmorrow: i'm also running compiled code, though.
21:46:24 <mmorrow> conal: cool, i don't think i've ever gotten it to do that. do y
21:46:25 <mmorrow> ohh
21:46:31 <mmorrow> maybe that's it
21:46:34 <dipmas> mmorrow: No problem ... in fact, I'm trying to build the world's greatest bookmarks collection here: http://sites.google.com/site/efg2009/Home/bookmarks
21:46:36 <conal> mmorrow: yeah
21:46:37 <mm_freak_> unsafePerformIOT :: Monad m => IOT m a -> m a
21:46:45 <procyon112> Axman6: I've used portage, and it's got an easy text file to make it pretend that "XYZ-1.2.3" does not exist... a cabal version of that would be ideal.
21:46:51 <mmorrow> dipmas: heh, a noble goal
21:47:09 <dipmas> mmorrow: Indeed
21:47:22 <conal> mmorrow: i'd like to find out what the black-hole detection algorithm is.  i suspect that it's failing for my situation.
21:47:29 <dipmas> Look at the demotivational posters section and click on 'The Chinese'
21:48:47 <mmorrow> conal: i'd love to find that out too. i looked over Interpreter.c because i thought it might be in there, but i don't think so after reading the description of the bug.
21:49:09 <ddarius> conal: Basically, when a (recursive) thunk is entered, the thunk is overwritten with a pointer to the blackhole handler.  If the thunk is then entered again before being updated, you get the blackhole exception.
21:49:29 <ddarius> I'm not sure how that is changed in the face of sparks and such.
21:49:38 <mmorrow> dipmas: heh
21:49:58 <ddarius> I would think a blackhole exception would just (silently) kill a spark.
21:50:10 <dipmas> research skills are cool
21:50:11 <mmorrow> ddarius: yes, but where in ghc is the relevant code for interpreted code? :)
21:50:44 <conal> ddarius: i'm wondering what happens when one evaluating thread gets killed.
21:50:53 <conal> ddarius: and a second evaluation comes along.
21:51:18 <conal> that seems to be the case with unamb.  i think the result is a false positive for black hole.
21:51:25 <conal> and the evaluation never completes.
21:51:58 <mmorrow> ddarius, conal: this might be a clue: "At some point we regressed on detecting simple black-hole loops.  This  happened due to the introduction of duplicate-work detection for  parallelism: a black-hole loop looks very much like duplicate work,  except it's duplicate work being performed by the very same thread.  So we have to detect and handle this case."
21:52:15 <mmorrow> from: Mon Nov 17 06:45:15 PST 2008  Simon Marlow <marlowsd@gmail.com>
21:52:15 <mmorrow>   * Fix #2783: detect black-hole loops properly
21:53:09 <mmorrow> conal: maybe the reverse problem is showing up, that a duplicate work loop is looking like a black-hole loop (shot in the dark)
21:53:55 <dipmas> bbl
21:54:03 <mm_freak_> which package implements MaybeT?
21:54:06 <conal> mmorrow: thx.  sounds relevant indeed.
21:54:33 <mmorrow> conal: let me know if you find anything interesting. i'm very interested in this as well. :)
21:54:45 <conal> mmorrow: will do.  you too, please.
21:54:56 <mmorrow> sure thing
21:55:19 <mmorrow> mm_freak_: i think maybet (speling?) on hackage
21:57:08 <mm_freak_> indeed, thanks
21:59:44 <ddarius> conal: I think your analysis is on spot.
22:03:41 <conal> ddarius: i wonder how ghc deals with this situation for concurrency and why it's failing for me.
22:03:55 <conal> i am using unsafePerformIO, since unamb has pure semantics.
22:07:31 <tcleval> hello, i cant install YI coz of container package failing to install with 'cabal install'. any sujestions or solutions ?
22:08:00 <ozy`> tcleval: what's the error you get?
22:09:22 <tcleval> Building containers-0.2.0.0...
22:09:25 <tcleval> Data/IntMap.hs:182:7:
22:09:25 <tcleval>     Could not find module `Data.Data':
22:09:25 <tcleval>       it is a member of package base, which is hidden
22:09:39 <tcleval> sorry for pasting here.. i forgot about hpaste ^^
22:10:29 <wli> Is hpaste.org down?
22:10:43 <tcleval> no no... i forgot to paste there
22:10:46 <tcleval> sorry
22:10:56 <tcleval> i am all sleepy here.
22:11:49 <apsod> This seems like such a trivial thing, but I can't figure out how to coerce a CInt to an Int :<
22:11:59 <ddarius> fromIntegral
22:11:59 <mmorrow> fromIntegral
22:12:03 <apsod> I guess ``unmarshall'' is a better word.
22:12:04 <apsod> Thanks :3
22:13:54 <wli> http://hpaste.org/13329 <-- selecting the k least
22:14:27 <Gracenotes_> @hoogle emptyFM
22:14:28 <lambdabot> No results found
22:14:46 <Gracenotes_> hm
22:15:48 <Gracenotes_> ah, I see, just "empty" is used nowadays
22:16:27 <mmorrow> mempty is nice too, especially since you (almost always) have to do M.empty
22:16:33 <Gracenotes_> http://www.haskell.org/all_about_monads/examples/example4.hs could perhaps be updated; it is GPL after all.
22:16:47 <mmorrow> > mempty :: (Ord a) => Map a b
22:16:48 <lambdabot>   Not in scope: type constructor or class `Map'
22:16:49 <Gracenotes_> once I comprehend it better as it is :)
22:16:53 <mmorrow> > mempty :: (Ord a) => Map.Map a b
22:16:54 <lambdabot>   fromList []
22:18:04 * wli likes the heap-based selection of the k minimal elements of a list.
22:18:52 <mmorrow> > foldl' (\m c -> Map.insertWith' (+) c 1 m) mempty (take 100000 $ randomRs ('a','z') (mkStdGen 343))
22:18:53 <lambdabot>   fromList [('a',3846),('b',3839),('c',3795),('d',3913),('e',3754),('f',3865)...
22:19:17 <Gracenotes_> wli: O(n lg n)?
22:19:38 <mmorrow> > foldl' (\m (i,c) -> Map.insertWith' (++) c [i] m) mempty $ zip [0..] (take 100000 $ randomRs ('a','z') (mkStdGen 343))
22:19:40 <lambdabot>   fromList [('a',[99995,99947,99937,99935,99929,99920,99915,99900,99858,99833...
22:19:49 <mmorrow> is an idiom that i find super useful
22:20:02 <wli> Gracenotes: O(n*lg(k)) at best. I suspect O(n*k).
22:20:53 <mmorrow> @type let collect (<>) f g = foldl' (\m a -> Map.insertWith' (<>) (f a) (g a) m) mempty in collect
22:20:54 <lambdabot> Couldn't find qualified module.
22:20:56 <wli> Gracenotes: Or O(n*k*lg(k)) even.
22:21:05 <mmorrow> collect (<>) f g = foldl' (\m a -> Map.insertWith' (<>) (f a) (g a) m) mempty
22:21:38 <Gracenotes_> hm. using a partition method yields omega(n*k), iirc
22:21:38 <mmorrow> :: (Ord b) => (c -> c -> c) -> (a -> b) -> (a -> c) -> [a] -> Map b c
22:22:13 <mmorrow> @let collect (<>) f g = foldl' (\m a -> Map.insertWith' (<>) (f a) (g a) m) mempty
22:22:14 <lambdabot>  <local>:9:35: Not in scope: `Map.insertWith''
22:22:18 <mmorrow> grr
22:22:39 <wli> Gracenotes: After a little more contemplation, definitely O(n*k*lg(k)).
22:22:47 <mmorrow> > let collect (<>) f g = foldl' (\m a -> Map.insertWith' (<>) (f a) (g a) m) mempty in collect (++) id (:[]) [0..9]
22:22:49 <lambdabot>   fromList [(0,[0]),(1,[1]),(2,[2]),(3,[3]),(4,[4]),(5,[5]),(6,[6]),(7,[7]),(...
22:23:02 <mmorrow> hmm, i guess L.hs doesn't have that stuff imported or something
22:23:40 <mmorrow> @let foooofofoo = mempty :: Map.Map Int Int
22:23:41 <lambdabot>  <local>:9:23: Not in scope: type constructor or class `Map.Map'
22:23:42 <Gracenotes_> wli: hm. How do you figure? (I don't exactly know the algorithm, unless it's just putting it in a heap and removing the bottom k times)
22:23:49 <mmorrow> @let foooofofoo = mempty :: Map Int Int
22:23:50 <lambdabot>  <local>:9:23: Not in scope: type constructor or class `Map'
22:23:54 <mmorrow> @let foooofofoo = mempty :: M.Map Int Int
22:23:55 <lambdabot>  Defined.
22:23:56 <mmorrow> ahh
22:24:05 <mmorrow> @let collect (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
22:24:06 <lambdabot>  Defined.
22:24:30 <wli> Gracenotes: k*lg(k) for extraction of all k values from the heap of size k at the end of the algorithm.
22:24:55 <mmorrow> > collect (+) id (const 1) . take 1000000 . randomRs (0,2::Int) . mkStdGen $ 4242442
22:24:56 <lambdabot>       Ambiguous occurrence `collect'
22:24:56 <lambdabot>      It could refer to either `L.collect...
22:25:04 <mmorrow> wut
22:25:16 <mmorrow> @let collect_ (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
22:25:17 <lambdabot>  Defined.
22:25:21 <mmorrow> > collect_ (+) id (const 1) . take 1000000 . randomRs (0,2::Int) . mkStdGen $ 4242442
22:25:24 <lambdabot>   fromList [(0,333320),(1,333744),(2,332936)]
22:25:33 <Gracenotes_> wli: the heap is size k? why not size n?
22:26:00 * Gracenotes_ must be confused about something
22:27:08 <Gracenotes_> hm, the heaping must be more sophisticated than I thought. nvm
22:28:04 <wli> Gracenotes: The logarithmic factor would be lg(n) if the whole set were kept in the heap. It's just kept in a max heap of size bounded by k, always replacing the largest element in the heap, until the end, when the sorting of the heap is flipped (in imperative contexts it's done with a secondary heap and deletion with a pointer).
22:28:38 <wli> Gracenotes: I should probably have written it with an array-based heap or some such in Haskell with e.g. an STArray.
22:29:04 <wli> Gracenotes: In such a manner the imperative heaps could be precisely emulated.
22:30:28 <wli> Gracenotes: There, at the end, all you do is the final pass of heapsort on the secondary (min) heap and throw away the max heap.
22:32:42 <Gracenotes_> hm. recursively using a quicksort-esque partition on the list gives you the answer in O(n) time, best case, for the kth smallest element. so repeated applications would give you O(n*k), and you might be able to make small optimizations here and there
22:34:11 <Gracenotes_> only problem is that (unless randomized) partition isn't always O(n)... heh. you could probably use an array for that too.
22:34:26 <Gracenotes_> the heapsort idea does strike me as a lot more elegant though :)
22:34:39 <Gracenotes_> (partial heapsort, anyway)
22:41:38 <Gracenotes_> anyway... a lot to learn. moving right along
22:41:43 <chrisdone> mmorrow: haha, you also have an academic double. here's my Chris Done: http://www.dur.ac.uk/physics/staff/profiles/?username=dph0cd
22:42:20 <pumpkin> are you not academics? :o
22:42:29 <chrisdone> I'm not
22:44:29 <pumpkin> haven't had any new posts on http://www.reddit.com/r/haskell_proposals/ for a while :(
22:45:22 <cjs> Hey, is ghci 6.8 ok on 64-bit Linux boxes?
22:45:54 <jeffz`> cjs, works for me
22:45:56 <cjb> cjs: sure, why not?
22:46:36 <cjs> Just wanted to make sure. I'm putting together a new 8-core box to start playing around with how much parallelism I can get out of ghc, and just thought I'd keep life interesting and go 64-bit at the same time.
22:46:54 <cjs> (Well, actually, it seemed an easy solution to my space leaks.... :-))
22:50:59 * ddarius only has a musician double.
22:51:10 <pumpkin> I have a photographer double
22:51:26 <pumpkin> or maybe the photographer has an academic double
22:51:34 <pumpkin> :o
22:52:09 <cjs> Momus had a great song about a double of his that committed sexual crimes, where the blame fell on him.
22:52:21 <cjs> Dopplegangerbanger, it was called.
22:53:43 <mmorrow> this seems to  be the assumed-to-have-been-read paper in papers on incremental garbage collection  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.1458
22:53:51 * mmorrow reads
22:56:11 <mmorrow> chrisdone: heh
22:57:20 <mmorrow> cjs: nice, i'm going 64bit for sure once i find the time to wipe my harddrive and install a 64bit distro
22:58:01 * mmorrow has a Core2 x2
22:59:12 <mmorrow> so many more registers for ghc for one
22:59:24 <mmorrow> *for one thing
22:59:38 <pumpkin> it uses them all?
23:00:17 <mmorrow> it should use as many as it can possibly grab i believe
23:00:18 <Axman6> mmorrow: aka: Core 2 Duo?
23:00:38 <mmorrow> Axman6: yes that too ;)
23:00:43 <Axman6> :P
23:01:01 <Axman6> i really wish ghc would compile as 64-bit on OS X
23:01:23 <mmorrow> pumpkin: x86-32 has barely any regs to work with
23:01:30 <pumpkin> yeah, I know :)
23:01:33 <mmorrow> which is sucky for ghc
23:01:59 <mmorrow> i think this tranlates into much faster code
23:02:31 <mmorrow> (and i've heard people say that they saw a noticeable increase in speed going 32->64)
23:02:43 <sjanssen> mmorrow: on the other hand, all data takes twice as much memory
23:02:47 <mmorrow> i'm guessing that more regs has something to do with this
23:02:59 <pumpkin> what does it mean when I get ghc giving me linker errors to   "_syb_DataziGenericsziSchemes_zdseverywhereM_info", referenced from:
23:03:24 <sjanssen> pumpkin: you forgot to give a -package flag
23:03:25 <mmorrow> sjanssen: true, but i'd take that hit for more things passed in real regs
23:03:29 <sjanssen> pumpkin: alternatively, use --make
23:03:34 <pumpkin> sjanssen: I did use --make
23:04:35 <sjanssen> hmm
23:04:41 <sjanssen> pumpkin: I guess something is broken, then :)
23:04:52 <pumpkin> must be related to my derive instances for NFData
23:04:56 <pumpkin> I guess I don't need them
23:05:40 <mmorrow> pumpkin: from what i understand, ghc uses graph coloring to find an optimal (wrt the algo, which favors registers to stack) calling convention between basic blocks
23:05:44 <cjs> A noticable increase when going 32->64? Really? Very cool.
23:06:10 <mmorrow> cjs: yes. i'm hoping i see it too :)
23:06:55 <cjs> Well, I may even be able to tell you in an hour or two, once my guy gets finished building the machine.
23:07:22 <mmorrow> nice, /me waits on the edge of his seat
23:09:29 <apsod> pfft, UI.HSCurses.Curses doesn't appear to expose a way to refresh individual windows (but it does expose newwin).
23:09:59 <apsod> Is there an easy way for me to submit patches to hackage? >_>
23:10:15 <mmorrow> pumpkin: so i think that means that every register is in use across every control transfer between any two basic blocks
23:10:20 <pumpkin> people don't use makefiles with haskell much, do they?
23:10:47 <apsod> Nevermind, found the maintainer's link for patches :3
23:10:52 <mmorrow> pumpkin: i think that's the fallback when cabal can't handle their needs
23:13:59 <pumpkin> ah
23:17:45 <mm_freak_> my monads tutorial is finished‚Ä¶  if anyone is interested:  http://blog.ertes.de/2008/12/understanding-haskell-monads.html
23:18:24 <mmorrow> is anyone familiar with the pros/cons of select vs. poll ?
23:18:59 <mm_freak_> mmorrow: select() works on sockets only, while poll() works on every FD
23:19:23 <mm_freak_> con for poll():  it's less portable than select()
23:19:37 <mmorrow> really? i'm pretty sure select work on any FD
23:19:52 <mm_freak_> that would be non-portable
23:20:01 <mmorrow> ah, i see
23:21:04 <Riastradh> POSIX's select(2) works on any file descriptors.
23:21:49 <mmorrow> in particular, i'm interested in how select is O(n) in number of FDs, while poll is O(1?)
23:22:19 <mmorrow> so, poll is O(1) then?
23:22:49 <mm_freak_> mmorrow: Riastradh is right, i was misinformed
23:22:59 <Riastradh> They are both linear in the number of file descriptors.  The only substantial difference in performance between select(2) and poll(2) is that select(2) requires space proportional to the *range* of the file descriptors, whereas poll(2) requires space proportional to the *number* of file descriptors.
23:23:10 <Riastradh> poll(2) also offers more precise information about the state of the file descriptors.
23:23:25 <mmorrow> hmm, interesting
23:24:09 <Riastradh> However, on some systems (notably Darwin, at least as of Tiger and possibly also in Leopard), poll(2) is broken on non-socket file descriptors, in violation of POSIX.
23:24:25 <mmorrow> ugh
23:24:37 <mmorrow> Riastradh: great, i appreciate the info. :)
23:25:22 <Riastradh> If you are concerned about running times of the algorithms involved, you should use epoll(2) on Linux and kqueue(2) on BSD.
23:25:22 <pumpkin> mm_freak_: yay :)
23:26:06 <Riastradh> And Solaris has /dev/poll, which I know little about, and among the other Unices (if you care about them) there are, I think, a couple more different I/O multiplexing system calls.
23:26:07 <pumpkin> mm_freak_: if you don't mind me asking, where's your name from? :o
23:26:20 <mmorrow> Riastradh: ah nice, i was just looking into those.
23:26:27 <mmorrow> (epoll/kqueue)
23:26:42 <Riastradh> And, by the way, if you want to deal with Windows, you would be better off researching efficient techniques for suicide.
23:26:45 <jql> libev and libevent have various documentations about how each various OS's optimal polling solution sucks in its own special way
23:26:47 <mm_freak_> pumpkin: turkey
23:26:53 <pumpkin> ah cool :)
23:27:13 <Riastradh> Fortunately, libev already knows about most of these systems, and their various shortcomings, and how they interact, and how to mix them for best results.
23:27:14 <mmorrow> Riastradh: haha. yeah, i'm not worrying about Windows thankfully.
23:27:34 <jql> yeah, I'm a fan of libev
23:27:46 * mmorrow looks into libev
23:27:55 <wli> I'd normally be the last one to "defend" Windows, but it's not really that different from everything else.
23:28:02 <mm_freak_> pumpkin: well, i'm almost german‚Ä¶  i don't even speak turkish anymore =)
23:28:24 <pumpkin> mm_freak_: I saw you had posts in german, but your name puzzled me :)
23:28:34 <jql> Windows does have an inherently awesome WaitForAnything2Ex function
23:28:37 <Riastradh> For example, on OS X, one can still take advantage of kqueue(2) (which is broken on non-socket file descriptors) by using the kqueue file descriptor in a select(2) set that contains the non-socket file descriptors.
23:28:49 <pumpkin> jql: is that its real name?
23:28:52 <Riastradh> And libev already knows how to do this.
23:29:03 <jql> no, I exaggerated. slightly
23:29:10 <jql> MsgWaitForMultipleObjectsEx
23:29:49 <mm_freak_> ah, welcome to Windows identifiers
23:30:10 <mm_freak_> the D3D identifiers are even crazier
23:30:58 <mmorrow> nice, libev looks like it may be super useful
23:32:09 <mm_freak_> D3D10CreateDeviceAndSwapChain
23:32:11 <Riastradh> wli, yeah, because everywhere else but Windows, select(2) is limited to socket file descriptors, and there are ridiculous limits on the other waiting methods such as about sixty-four descriptors per set, beyond which one must chain multiple sets together, or something absurd like that.  (My memory is rusty -- but from what I recall, this area of Windows is not exempt from the brain damage.)
23:35:32 * Riastradh coughs.
23:38:08 * mmorrow puts his FFI shoes on
23:41:25 <mmorrow> nice
23:41:27 <mmorrow> [m@ganon libev]$ wc -l *.{c,h} | tail -1
23:41:27 <mmorrow>   6804 total
23:41:44 <jql> that's half the reason it's so awesome. :)
23:41:45 <mmorrow> not bad for C
23:41:53 <mmorrow> jql: totally
23:42:03 <jql> do one thing. do it well
23:42:35 <jql> latest release: dec 24. heh
23:50:39 <bryan1> How can I take a list of [(x,y)] and return a list of x y where x is uniq and the y's are the sum. ie. [(111,1),(111,2),(113,4)] -> [(111,3),(113,4)]
23:51:01 <Elly> well
23:51:04 <Elly> what's your first instinct?
23:51:23 <cjs> Go to IRC and plead for help!
23:51:37 <Elly> if that is it, what's your *second* instinct? :P
23:51:47 <pumpkin> I would do a Map.fromListWith
23:52:03 <crathman>  putStrLn $ "hello"
23:52:17 <crathman> what is the purpose of the $
23:52:26 <Elly> crathman: zipWith ($)
23:52:27 <pumpkin> in this case, it doesn't get you much :)
23:52:28 <rainmann> @src ($)
23:52:28 <lambdabot> f $ x = f x
23:52:29 <cjs> I was contemplating some sort of clever list comprehension myself.
23:52:35 <bryan1> Elly: zip
23:52:40 <cjs> Oh, wait, you could sort the list, and then merge the adjacent values.
23:52:41 <FunctorSalad> there must be something in the parsec library for "drop tokens until this parser succeeds" ?
23:52:41 <Elly> bryan1: what does zip do?
23:52:47 <Elly> :t zip
23:52:49 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
23:52:51 <pumpkin> cjs: groupBy or something?
23:53:01 <pumpkin> but fromListWith on Data.Map would be really easy
23:53:04 <crathman> Elly: thanks
23:53:09 <pumpkin> fromListWith (+)
23:53:22 <rainmann> bran_, what about [(111,1),(113,4),(111,2)] ?
23:53:24 <Elly> > zipWith ($) (cycle [toLower, id]) 'A' .. 'Z'
23:53:25 <lambdabot>   <no location info>: parse error on input `..'
23:53:32 <Elly> > zipWith ($) (cycle [toLower, id]) ['A' .. 'Z']
23:53:33 <lambdabot>   "aBcDeFgHiJkLmNoPqRsTuVwXyZ"
23:53:38 <Elly> crathman: ^
23:53:46 <cjs> It's kind of a groupBy feeling kinda thing, but not quite.
23:54:17 <Elly> :t groupBy
23:54:18 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
23:54:22 <dancor> i think it's pretty common also to see e.g.   putStrLn $ "hi " ++ name
23:54:24 <Elly> hm...not quite :P
23:54:32 <pumpkin> Prelude Data.Map> toList . fromListWith (+) $ [(111,1),(111,2),(113,4)]
23:54:32 <pumpkin> [(111,3),(113,4)]
23:54:40 <Elly> crathman: it also saves you parens :)
23:54:41 <FunctorSalad> , parseTest (manyTill anyChar digit) "aaaa5foo"
23:54:43 <lunabot>  luna: Not in scope: `parseTest'
23:54:53 <pumpkin> rainmann: ^^
23:55:03 <rainmann> pumpkin, right
23:55:07 <FunctorSalad> looking for sth. like manyTill, but it should return the *terminating* thing
23:55:14 <Elly> :t fromListWith
23:55:16 <lambdabot> Not in scope: `fromListWith'
23:55:20 <Elly> er
23:55:24 <Elly> :t Data.Map.fromListWith
23:55:25 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
23:55:33 <Elly> hm...intriguing
23:55:39 <rainmann> > let x = [(111,1),(111,2),(113,4)] in toList (fromListWith (+) x)
23:55:40 <lambdabot>   Not in scope: `toList'Not in scope: `fromListWith'
23:55:52 <pumpkin> I tried running it, but lambdabot didn't let me
23:55:58 <mmorrow> > foldl' (\m (x,y) -> Map.insertWith' (+) x y m) Map.empty [(111,1),(111,2),(113,4)]
23:55:59 <lambdabot>   fromList [(111,3),(113,4)]
23:56:06 <rainmann> > let x = [(111,1),(111,2),(113,4)] in Map.toList (Map.fromListWith (+) x)
23:56:07 <lambdabot>   [(111,3),(113,4)]
23:56:07 <pumpkin> oh it's under map
23:56:12 <mmorrow> > Map.fromList . foldl' (\m (x,y) -> Map.insertWith' (+) x y m) mempty $ [(111,1),(111,2),(113,4)]
23:56:13 <lambdabot>   Couldn't match expected type `[(k, a)]'
23:56:14 <crathman> elly: reading Real World Haskell...  see where they use it...  but either missed the explanation or haven't stumbled on it yet
23:56:20 <mmorrow> > Map.toList . foldl' (\m (x,y) -> Map.insertWith' (+) x y m) mempty $ [(111,1),(111,2),(113,4)]
23:56:21 <lambdabot>   [(111,3),(113,4)]
23:56:28 <pumpkin> mmorrow: why not fromListWith though?
23:56:35 <pumpkin> @src Map.fromListWith
23:56:36 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:56:52 <mmorrow> i guess you could to that too
23:56:58 <Elly> pumpkin: you want Data.Map.fromListWith
23:57:04 <mmorrow> personally, i've never used fromListWith
23:57:13 <pumpkin> Elly: yeah, but he just used Map.insertWith
23:57:15 <mmorrow> also, it's probably not as strict as
23:57:20 <mmorrow> foldl' and insertWith'
23:57:26 <mmorrow> which is a space leak
23:57:39 <pumpkin> space leak?
23:57:52 <mmorrow> in the same way that
23:57:57 <mmorrow> foldl (+) 1
23:58:01 <mmorrow> is a space leak
23:58:08 <mmorrow> 0 i meant
23:58:18 <pumpkin> in terms of stack?
23:58:19 <mmorrow> > foldl (+) 0 [0..100000000]
23:58:23 <Elly> use foldr!
23:58:36 <lambdabot>   mueval: Prelude.read: no parse
23:58:40 <mmorrow> yeah, it doesn't keep its accumulator one level deep
23:58:43 <FunctorSalad> @i (<<)
23:58:44 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
23:58:45 <mmorrow> > foldl' (+) 0 [0..100000000]
23:58:50 <FunctorSalad> @t (<<)
23:58:50 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:58:53 <lambdabot>   5000000050000000
23:58:55 <FunctorSalad> meh.
23:59:07 <mmorrow> Elly: heh
23:59:15 <FunctorSalad> @type (<<)
23:59:18 <lambdabot> Not in scope: `<<'
23:59:19 <Elly> FunctorSalad: you want :t
23:59:21 <Elly> I think?
23:59:21 <buu> Elly: ?!
23:59:24 <Elly> :t (<<)
23:59:25 <FunctorSalad> I must have hallucinated that this exists.
23:59:25 <lambdabot> Not in scope: `<<'
23:59:27 <Elly> buu: hello sir!
23:59:29 <FunctorSalad> (the (<<))
23:59:31 <buu>  /gasp
23:59:34 <Elly> buu: how goes?
23:59:40 <buu> Elly: The Spirit is pretty A+
23:59:55 <Elly> buu: The Spirit?
