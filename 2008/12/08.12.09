00:00:25 * pumpkin bows in shame
00:03:39 <sbahra> Any statitians around?
00:04:18 <sbahra> statisticians
00:06:54 <ksf> only statistically ;)
00:07:29 <sjanssen> jsn: an Applicative transformer that executes in reverse http://hpaste.org/12888
00:08:55 <profmakx> probably
00:08:57 <profmakx> hahahaha
00:10:19 <jsn> sjanssen: okay, i am beginning to appreciate what these are about, now
00:15:46 <zloog> Hrm, I want to efficiently sort a large list (100GB of txt) and toss out the last contiguous series of numerals on each line from it. Does anyone know of a way to do that?
00:16:12 <zloog> Bonus if we can build the structure to allow me to easily insert new data into the list
00:16:30 <sjanssen> hmm
00:17:07 <sjanssen> that is a big chunk of data.  You'll certainly need to use some sort of external sort
00:17:11 <solrize> i think preprocess the text to remove the numerals, then use your favorite external sort utility
00:17:20 <solrize> e.g. hadoop ;)
00:17:23 <zloog> zloog: On the plus side, the lines should be no more than around 300 chars or so
00:17:46 <zloog> solrize: So you would bust out C at that point then?
00:18:00 <solrize> zloog if you only want to do it once, i'd use the unix sort utility
00:18:11 <solrize> if you want to do it a lot, i'd bust out the distributed processing ;)
00:18:22 <solrize> i'm doing something like that in python on about 100 computers :-P
00:18:37 <zloog> solrize: I'm dreaming of a haskell binary usenet reader
00:18:52 <solrize> hmm
00:18:57 <zloog> solrize: 100GB is my estimate of the header size for a major newsgroup
00:19:06 <sjanssen> really, 100GB?
00:19:24 <zloog> It takes me a full day to download the headers at 80 KBs
00:19:26 <solrize> err, 1) 100gb is an awful lot; 2) are you trying to thread the messages or something?  the article #'s tend to be contiguous
00:19:34 <solrize> > 80000 * 86400
00:19:36 <lambdabot>   6912000000
00:19:39 <repnop> uh 100GB?
00:19:43 <zloog> hrm
00:19:46 <solrize> > 80000 * 86400 / 10^6
00:19:47 <zloog> let me ask google again
00:19:48 <lambdabot>   6912.0
00:19:52 <solrize> 7gb
00:19:55 <repnop> maybe for every header from every group posted for like 180 days
00:19:58 <sbahra> repnop, what is the behavior of rep nop?
00:20:06 <zloog> http://www.google.com/search?q=800+KB%2Fs+*+24+hours&ie=utf-8&oe=utf-8&aq=t&rls=com.ubuntu:en-US:unofficial&client=firefox-a
00:20:08 <repnop> sbahra: pause
00:20:12 <zloog> ok off by a factor of 2 or so
00:20:24 <Axman6> `can haskell programs be redistributed without having GHC installed?
00:20:31 <sbahra> repnop, oh, shit. Yes :)
00:20:39 <sjanssen> Axman6: yes
00:20:42 <solrize> axman6 yes it makes binaries
00:20:47 <Axman6> good
00:20:52 <repnop> though i wish it was based on ecx :)
00:20:56 <sbahra> repnop, effects of which aren't really well-defined :(
00:21:01 <repnop> yeah
00:21:02 <sjanssen> the RTS and Haskell libraries are statically linked in
00:21:06 <sbahra> repnop, that wouldn't be useful on most modern x86s.
00:21:16 <zloog> Of course the compression on headers is around 1024:1 or so
00:21:21 <repnop> course not :)
00:21:27 <sbahra> ;p
00:21:40 <solrize> zloog you're going to download 100gb of headers from someplace and then interactively pull the bodies or something?
00:22:00 * sjanssen still has a hard time believing 100GB of *headers*
00:22:07 <sjanssen> that is a mind-boggling amount of data
00:22:09 <zloog> solrize: Pretty much, I just want something on linux that does a good job at creating NZBs
00:22:14 <solrize> nzb?
00:22:45 <solrize> dolio did some work on external sorting in haskell, and i've been interested in it too, but for this it sounds like you can use unix sort
00:23:01 <solrize> if it helps, one of my co-workers did a distributed version of it
00:23:06 <zloog> Well on windows it took around a day for me to do this using the newzbin client. I dont know if the bottleneck was algorithm or bandwith
00:23:24 <zloog> A day to pull down the headers for say alt.binaries.multimedia
00:23:51 <solrize> well how many headers did you actually get?  and what do you want to do with them?
00:24:36 <zloog> solrize: Pull them down and make NZBs
00:24:47 <solrize> what are nzb's?
00:25:14 <Axman6> Beelsebob: so, where's the GHC OpenCL stuff huh? git on it!
00:25:22 <Beelsebob> haha
00:25:43 <Beelsebob> I would... if khronos' servers hadn't exploded and I could read the spec :P
00:25:51 <zloog> solrize: the headers look like "a.b.m.cooking presents  Great British Menu S03E49.avi.031 [32/45] The Banquet enjoy! (54/60)" or something. An NZB is an xml file that has information what files to download and in what order to reassemble them in
00:26:14 <solrize> i don't understand why this massive sorting since the stuff you download will probably be pretty close to already sorted
00:26:26 <repnop> >50% chance this will be used to download...something that is copyrighted?
00:26:28 <sbahra> There was some company that distributed movies/TV shows/etc... illegally, on usenet.
00:26:35 <zloog> NEVER
00:26:39 <zloog> only linux binaries
00:26:41 <sbahra> They were looking for people to work on a client for *nix.
00:26:52 <sbahra> They hired an idiot, and he failed at it :-P
00:27:00 <solrize> haha
00:27:04 <sjanssen> yeah, I don't think you want a sort here
00:28:06 <zloog> well the plus side is that the important bit, the information on the order to reassemble the pieces in seems to always be the rightmost series of numerals
00:28:41 <sjanssen> since segments should be fairly close together, just scan through the headers in order, keeping track of which chunk-sets aren't complete yet
00:29:11 <zloog> Could do that
00:29:13 <zloog> its true
00:29:32 <zloog> but thinking about what kind of structure would let me do it with minimal memory useage
00:29:33 <sjanssen> zloog: yes, you'll need to come up with some heuristic to interpret those headers
00:30:16 <sjanssen> if your heuristic is good, you don't need a very good structure -- a Data.Map of Sequences would be fine
00:31:24 <sjanssen> or you might use something like an LRU cache to ensure that only the last X headers are considered
00:32:49 <zloog> sjanssen: Thats a haskell hashtable isnt it?
00:33:11 <sjanssen> Data.Map is not a hash table
00:33:33 <zloog> size balanced binary trees
00:33:37 <sjanssen> zloog: I bet you program in Perl/Python/Ruby :)
00:33:52 <zloog> sjanssen: C
00:33:59 <sjanssen> ah, nevermind
00:34:03 <zloog> sjanssen: Its a big jump
00:34:06 <sjanssen> zloog: oh yes
00:34:44 <sjanssen> zloog: I've just noticed that those dynamic language users refer to all dictionary structures as "hashes" regardless of how they're implemented
00:35:22 <zloog> sjanssen: I usualy think hash if I have to "guess" if a value is contained in it
00:35:30 <zloog> instead of being able to iterate
00:36:16 <zloog> sjanssen: nice that the docs for this all have O notation next to them though
00:41:28 <hydo> Using Network.URI as an example, if I have f which is of type 'Maybe URI', in order to pull a URI out of it, if in fact it has one that's not null, I need to wrap it in a case to check for either a value or Nothing?
00:42:02 <hydo> Err, what I mean is, is that the standard way to go about getting a value out of it?
00:42:06 <enolan> Or use a function that does.
00:42:11 <enolan> :t fromMaybe
00:42:13 <lambdabot> forall a. a -> Maybe a -> a
00:42:26 <yitz> @type maybe
00:42:28 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:42:31 <enolan> that'll give a default value if the thing is Nothing
00:42:31 <hydo> fromMaybe.... well, hello there.
00:42:49 <yitz> maybe is in the Prelude, fromMaybe and fromJust need to be imported from Data.Maybe
00:42:58 <yitz> @type fromJust
00:42:59 <lambdabot> forall a. Maybe a -> a
00:43:19 <yitz> > fromJust $ Just 42
00:43:20 <lambdabot>   42
00:43:20 <hydo> thanks enolan, and yitz.  I didn't know about that.  Makes it much clearer :)
00:43:34 <yitz> > fromJust Nothing -- possible crash
00:43:35 <lambdabot>   * Exception: Maybe.fromJust: Nothing
00:43:52 <Axman6> > maybe 2 (+1) (Just 6)
00:43:54 <lambdabot>   7
00:44:01 <Axman6> > maybe 2 (+1) Nothing
00:44:02 <lambdabot>   2
00:44:37 <yitz> @check \x y -> maybe x id y == fromMaybe x y
00:44:38 <lambdabot>   "OK, passed 500 tests."
00:44:55 <Axman6> ah, wel there you go
00:44:57 <Axman6> l*
00:47:51 <yitz> Our channel topic has a syntax error - no comma between the second and third strings.
00:48:00 <Axman6> so, anyone want to rewrite macports in haskell?
00:48:36 <yitz> Axman6: why?
00:48:59 <yitz> I mean, any existing app would be interesting to rewrite in Haskell. Why that one in particular?
00:49:12 <Axman6> well the devs don't particularly like tcl, and i'm trying to convince them haskell would be a good choice
00:49:18 <Beelsebob> yitz: that's not a syntax error -- that's a type error
00:49:27 <Beelsebob> (can't match String against String -> a)
00:49:38 <yitz> Beelsebob: you're right
00:49:52 <zloog> sjanssen: Thanks for being the sounding board. Good Ideas, will follow tonight then the King Cobra wears off
00:50:00 <yitz> > ["Real World Haskell: out now", "Haskell News: http://reddit.com/r/haskell" "The Haskell programming language", "http://haskell.org", "Paste:  http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]
00:50:01 <lambdabot>   Couldn't match expected type `t -> [Char]'
00:50:43 <Beelsebob> oh, it's done it from the oposite end from me
00:50:46 <Beelsebob> >.>
00:52:03 <Axman6> Beelsebob: seel like a rewrite of macports?
00:52:13 <Beelsebob> Axman6: ?
00:52:43 <Axman6> do you want to rewrite macports in haskell? could fix a lot of the issues...
00:53:05 <yitz> Axman6: what style of tcl is the original - OO style?
00:53:21 <Axman6> no idea, i haven't had a look at it reallt
00:53:22 <Axman6> y*
00:53:41 <yitz> iblechbot: list
00:54:08 <Beelsebob> Axman6: sounds like a shudderworthy amount of IO to me
00:54:18 <Axman6> Beelsebob: yeah, but meh.
00:54:36 <Axman6> i mainly want to be able to fork the fetch process so it can get on with other things...
00:54:38 <yitz> Beelsebob: spj writes that Haskell is the best language for IO
00:55:06 <Beelsebob> yitz: doesn't stop me liking writing it
00:55:07 <Axman6> yitz: "19:54 < toby> i think that's like OO style C... as in, it fakes it in certain places?"
00:55:18 <Beelsebob> doesn't make me like writing it even
00:55:56 <Beelsebob> Axman6: it could even get locking on dependancies right, so that parallel builds could work
00:56:15 <Axman6> Beelsebob: yep, that's what i'm hoping for
00:56:16 <yitz> Axman6: heh. but tcl does have some built-in OO support. tcl++ if you will.
00:56:46 <Axman6> yeah i'm not familiar with tcl, so i can't really comment ;)
00:59:14 <yitz> Beelsebob: how about STM instead of locking dependencies?
00:59:37 <Beelsebob> yitz: it's got to lock between processes
01:00:09 <Beelsebob> i.e. if the user fires of hpackage install ghc and hpackage install gimp, it's gotta realise that it's gotta build gmp quickly, then set both builds running independantly
01:00:17 <yitz> Beelsebob: internally it just needs to know whether or not to launch processes.
01:00:31 <Beelsebob> yitz: no -- the user can spawn multiple processes
01:00:37 <Beelsebob> which can screw it up totally
01:00:45 <Beelsebob> unless it has a client server model
01:00:50 <Beelsebob> hmm... there's an interesting though
01:00:52 <Beelsebob> thought*
01:01:06 <yitz> Beelsebob: sure
01:01:33 <yitz> Beelsebob: or a peer model
01:01:54 <Beelsebob> yeh, but that's rather more complex, and probably pointless on a single system
01:02:07 <yitz> because you normally don't need a port server lurking around all the time
01:02:24 <Beelsebob> sure -- so have the client first try to contact the server, and if it can't, spawn it
01:02:42 <Beelsebob> and have he server shut down as soon as it has no tasks left
01:03:05 <yitz> Beelsebob: a simple peer model would be any process is capable of being a server
01:03:29 <yitz> Beelsebob: each process checks to see if any other is already around, and use it as a server if so
01:03:32 <Beelsebob> yes -- but then you have to get into (a) complex code for negotiating who is doing the building
01:03:46 <Beelsebob> (b) you have to stick that code *and* the install code in the same binary
01:04:20 <yitz> Beelsebob: in many ways it's simpler that way - e.g., what happens when some process gets killed
01:04:37 <Beelsebob> true true
01:04:49 <yitz> when the user hits ^C it's not obvious that there is still a server hanging around
01:05:32 <Beelsebob> yep -- and worse, still building the thing they thought they terminated
01:05:35 <yitz> Beelsebob: doesn't have to be complex: "you do it, I'm too lazy".
01:05:46 <Beelsebob> true true
01:05:50 <Beelsebob> I think you've convinced me
01:05:54 <Beelsebob> not that I'm gonna write it
01:06:09 <yitz> Beelsebob: so have we convinced Axman6?
01:06:15 <sjanssen> is it really a good idea to allow two package manager processes to run at once?  Debian says no
01:06:29 <Beelsebob> sjanssen: that's the point
01:06:41 <Beelsebob> we want a package manager in which it's safe to run two at once
01:06:48 <sjanssen> that could be cool
01:06:54 <Beelsebob> and better yet -- if you run two at once, it runs the builds in parallel where they can be
01:06:58 <yitz> sjanssen: true. the idea is that the second one realizes that it just keep its nose out.
01:07:50 <yitz> sjanssen: that is, let the first one make all decisions
01:08:08 <Axman6> yitz: not really, i wansn't here...
01:08:37 <sjanssen> I think client/server is really best here
01:09:29 <yitz> Axman6: we're all discussing the architecture of the macports app you are about to write
01:09:50 <Axman6> yeah, and the interesting thing is, i went through the same process in my head in the shower :P
01:09:58 <Beelsebob> hehe :D
01:10:03 <Axman6> coming to the same conclusions as Beelsebob did. damn you Beelsebob!
01:10:15 <yitz> Axman6: is that why our design is all wet?
01:10:21 * Beelsebob pulls a Beelsebob, even when Axman6 isn't here
01:10:32 <Axman6> bastard
01:10:41 <Beelsebob> :D
01:10:47 <Axman6> yitz: aye
01:10:56 <sjanssen> also, wouldn't it be better to process packages serially, but use parallel make in each individual package?  The extra locality will help the VM system
01:11:01 <Beelsebob> for those who are wondering -- I have a habit of saying exactly what Axman6 is about to say in macosx
01:11:03 <Axman6> i think that a simple mpserver would be best, just a daemon
01:11:05 <Beelsebob> which pisses him off no end
01:11:41 <Beelsebob> Axman6: interesting thought for the day -- if we're targetting specifically macs, abuse launchd to be the server
01:11:52 <Beelsebob> it can handle dependancies and parallelising them efficiently already
01:11:52 <Axman6> macports alows multiple processes at once, but blocks until the first is finished, then the next one to see it can go does...
01:12:00 <sjanssen> (and since OS X's VM is not very good in my experience, this might be somewhat important)
01:12:07 <Axman6> Beelsebob: sounds good
01:12:25 <Axman6> Beelsebob: as long as it runs on 10.4 (and maybe 10.3) they'll be happy
01:12:38 <Beelsebob> Axman6: launchd was intro'd in 10.4, so that works
01:12:48 <Axman6> yeah
01:12:59 <Beelsebob> and as long as we keep it agnostic otherwise, it'll work on other platforms as they adopt launchd
01:13:38 <yitz> sjanssen: parallel make might not be an option - macports generally just uses that build process that comes with each native package.
01:13:55 <yitz> *the build process
01:14:03 <sjanssen> yitz: and almost every build process uses make
01:14:18 <Beelsebob> sjanssen: yeh, but not all Makefiles are safe for parallelising
01:14:19 <Axman6> you can tell macports to use parallel build
01:14:20 <yitz> sjanssen: yeah, but each has its own quirks and hacks
01:14:24 <Axman6> it's in the config file
01:14:34 <sjanssen> Gentoo uses parallel make, and it works rather well
01:14:49 <Axman6> but the port files can say whether something is safe to buld in parallel
01:15:15 <sjanssen> Beelsebob: s/are safe for parallelising/have incorrect dependencies/
01:15:38 <Beelsebob> sjanssen: yep -- but most people want to be able to install said bad code on their system
01:15:45 <yitz> Axman6: so then what is the need for launchd?
01:15:55 <Axman6> no idea, ask Beelsebob :P
01:16:06 <sjanssen> Beelsebob: sure, so you have an annotation in the broken packages that says "don't use parallel make"
01:16:21 <Beelsebob> yitz: it allows for parallel building of two packages when the two packages don't support make -jn
01:16:27 <yitz> Axman6: true, Beelsebob can answer for you and himself
01:16:34 <Axman6> sjanssen: macports already has that porion
01:16:40 <Axman6> yitz: yes :(
01:16:52 <sjanssen> Axman6: ah, I guess they've added that since I've last used OS X
01:17:03 <Axman6> yeah, i think it was a 1.6 thing
01:17:35 <yitz> Beelsebob: such as haskell package, unfortunately, as of now.
01:17:39 <yitz> packages
01:17:46 <Beelsebob> yitz: indeed
01:18:42 <yitz> Beelsebob, Axman6: well, still it would be nice if everything is orchestrated through a central Haskell process that uses STM.
01:18:52 <Axman6> aye
01:19:04 <tibbe> is there a strategy one can use when trying to prove the applicative functor laws? even for a data type with two constructors proving composition leads to an explosion of cases if I try to do it case-by-case on the constructors
01:19:20 <Beelsebob> yitz: by the sounds of it, launchd is *much* more simple than that
01:19:32 <Beelsebob> in that all it needs is for us to transcribe our dep tree into a launchd one
01:19:38 <Beelsebob> and queue up the relevant tasks
01:20:46 <yitz> Beelsebob: so there's no choice then. first we rewrite launchd in haskell.
01:20:49 <Beelsebob> the clients wouldn't even need to care about checking for a server existing, because all they'd do is stick stuff in launchd's queue
01:20:53 <Axman6> heh
01:20:56 <Beelsebob> haha
01:22:41 <chylli> are there some articles about derivetypeable extension or about derive mechanism ?
01:23:16 <yitz> chylli: the ghc docs?
01:23:39 <chylli> yitz: I'm so stupid that ...
01:25:33 <Axman6> Beelsebob: wanna start up a project for this?
01:26:01 <Beelsebob> Axman6: *shrug*
01:26:06 <Beelsebob> I have too many weekend projects alread
01:26:20 <Axman6> bah
01:26:39 <Axman6> well, i'll be back later to rustle up support, going out now.
01:26:39 <Axman6> o/
01:31:58 <yitz> tibbe: hmm, I see what you mean. I guess you would need some basic identities to work with for your type, to simplify things.
01:34:12 <mlesniak> @seen dons
01:34:13 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 2h 23m 27s ago.
01:35:01 <tibbe> yitz: hmm yes, the fmap id = id helped in the simple applicative functor indentity case
01:56:31 <tibbe> I'm still stuck writing an applicative instance, anyone willing to lend me your brain for a sec?
01:58:30 <Peaker> tibbe: paste code? :)
01:59:05 <tibbe> Peaker: http://www.hpaste.org/12889
01:59:46 <sjanssen> tibbe: and what problem are you having?
01:59:46 <tibbe> Peaker: I don't know if it's actually possible to write an instance for my data type so any evidence to the contrary would be useful too!
01:59:52 <tibbe> sjanssen: http://www.hpaste.org/12889
02:00:07 <tibbe> sjanssen: that particular case
02:00:47 <Peaker> tibbe: why aren't you pattern matching in the func itself, rather than in a case, btw?
02:01:15 <tibbe> Peaker: No good reason really
02:02:31 <quicksilver> tibbe: something like fmap . liftM . fmap $ f
02:02:50 <tibbe> quicksilver: no monad :/
02:03:03 <tibbe> quicksilver: or are you saying it's only possible if f is a monad?
02:03:05 <quicksilver> you have to push the 'f' past that (Stream ->), which is a functor, past the "m" which is a monad, and then through the iteratee
02:03:18 <quicksilver> tibbe: well, Functor would be enough.
02:03:25 <tibbe> quicksilver: :)
02:03:35 <tibbe> quicksilver: so replace liftM with fmap?
02:03:41 <quicksilver> fmap . fmap . fmap
02:03:54 <quicksilver> one for the Stream ->, one for the m, and one for the Iteratee m
02:04:21 <tibbe> quicksilver: so: Cont (fmap . fmap . fmap . k) ?
02:04:44 <quicksilver> well, the last ".k" actually is the first fmap
02:04:49 <quicksilver> so you only need one of the two ;)
02:05:02 <quicksilver> composition by 'k' *is* the functor instance for (Stream ->)
02:05:05 <tibbe> quicksilver: it doesn't type check though
02:05:30 <tibbe> or wait
02:05:44 <tibbe> no still not
02:05:58 <quicksilver> it's exactly the same as your Functor instance, textually
02:06:06 <quicksilver> Cont k   -> Cont (fmap (fmap f) . k)
02:06:11 <tibbe> quicksilver: http://hpaste.org/12889#a2
02:06:17 <quicksilver> type checks for me.
02:06:42 <tibbe> quicksilver: I probably misunderstood what you said :)
02:06:58 <quicksilver> you can also write it as
02:07:00 <quicksilver> Cont k   -> Cont ((fmap . fmap .fmap) f k)
02:07:04 <quicksilver> same thing
02:07:12 <quicksilver> the third fmap I added is what used to be the "." before the k.
02:07:34 <quicksilver> (you could change the Functor instance to match, if you preferred that form)
02:08:07 <Peaker> tibbe: why is Stream called Stream? Why not use ErrorT (Maybe String) to get all the instances for free, too?
02:09:13 <quicksilver> tibbe: it might be wrong that you ignore the 'second stream' in the Done case.
02:09:53 <Saizan> you're discarding the stream coming from Done though
02:15:28 <ksf> does cabal install know of an equivalent to portage's @world?
02:15:36 <ksf> I changed options and wanna rebuild everything.
02:18:39 <quicksilver> ksf: you can run cabal upgrade although I think it's a rather bad idea to do that.
02:30:09 <tibbe> Peaker, quicksilver: sorry got a bit caught up in a discussion
02:31:08 <tibbe> Peaker: Yes ErrorT might be worth looking into if GHC can optimize it away. the Stream type I use in the example here is a bit simplified (the real type uses bytestrings and some more strictness)
02:32:29 <tibbe> now all that's left is to prove the applicative functor laws ;)
02:32:43 <Saizan> anyone knows what means for a function to be inflationary over a partial order?
02:32:48 * luqui isn't sure what tibbe means by "optimize it away"
02:32:59 <luqui> what would it get rid of?
02:33:52 <luqui> Saizan, is that some variant of increasing?
02:38:02 <quicksilver> tibbe: it's likely that its' wrong to through away one of the streams.
02:38:06 <tibbe> luqui: meaning the extra indirection introduced by e.g. Maybe
02:38:11 <quicksilver> tibbe: I really don't understand your Done type
02:38:15 <quicksilver> s/type/constructor/
02:38:17 <tibbe> luqui: as in pointer indirection
02:39:07 <luqui> this is really a major concern? indirection in the failure case?
02:39:08 <tibbe> quicksilver: Done meaning that this iteratee doesn't want to consume any more input and has produce a result, the stream might not have reached Eof yet so we can have the next iterator continue processing it
02:39:23 <quicksilver> tibbe: but Done can have a bit left over
02:39:31 <quicksilver> and you make no effor to past that left over bit
02:39:33 <quicksilver> you just throw it away
02:39:36 <quicksilver> that can't be righ t:P
02:39:39 <tibbe> quicksilver: no
02:39:46 <tibbe> quicksilver: so that's probably wrong
02:39:55 <tibbe> quicksilver: we want to give that to k
02:40:08 <tibbe> and then have something like Cont $ \streams2 -> ...
02:40:43 <quicksilver> I don't understand how Iteratee can meaningfully have a 'Done' constructor at all.
02:40:47 <tibbe> quicksilver: have a look at oleg's monad instance for the same type: http://www.hpaste.org/12858#a2
02:40:56 <quicksilver> how can it be Done before you've given it its stream?
02:41:13 <tibbe> quicksilver: if you use pure for example
02:41:41 <luqui> tibbe, also, you're dealing with a free monad here.  I heard from edwardk that putting that in a ContT (or codensity to be precise -- it's like ContT without callCC) can give you a speed boost.
02:41:43 <quicksilver> oh, I see.
02:42:24 <tibbe> luqui: I'm not sure I understand I'm afraid
02:43:22 <luqui> if m is a free monad (which Iteratee is), then ContT r m is often a more efficient variant of m.
02:43:33 <luqui> for free, no modification necessary! :-)
02:43:37 <tibbe> luqui: what's a free monad?
02:43:42 <Saizan> not exactly the same type, oleg's Iteratee doesn't have the "m" part
02:44:09 <tibbe> Saizan: He has a IterateeM though
02:44:09 <luqui> data Foo f a = Return a | Free (f (Foo f a)) -- where f is a functor
02:44:10 <tibbe> which does
02:44:22 <tibbe> luqui: anything written about the topic?
02:44:25 <luqui> tibbe, and things isomorphic to it.  they come up quite frequently
02:44:57 <luqui> http://comonad.com/reader/2008/monads-for-free/ -- from edwardk himself :-)
02:45:51 <tibbe> ,src ContT
02:45:58 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
02:46:11 <tibbe> ,src Control.Monad.Cont.ContT
02:46:12 <lunabot>  luna: Not in scope: data constructor `Control.Monad.Cont.ContT'
02:46:13 <Saizan> , src ''ContT
02:46:26 <lunabot>  newtype ContT r m a = ContT {runContT :: ((a -> m r) -> m r)}
02:47:15 <luqui> newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }  -- ContT without callCC, purely for the speed boost
02:48:41 <Saizan> can you write Iteratee m in terms of Free?
02:48:49 <yitz> luqui: shouldn't tibbe get things working simply before optimizing and making things more compicated?
02:49:20 <tibbe> yitz, probably ;)
02:49:20 <luqui> yitz, definitely.  it's just a neat little tidbit that can easily be introduced later.
02:49:45 <tibbe> luqui, I used something similar for a resumable parser I wrote (i.e. explicit continuations although I had a second one for failure)
02:50:12 <tibbe> quicksilver: so clearly we need to give stream to k, the question is what to do with what's returned
02:50:51 <tibbe> quicksilver: What we return should be a Cont I think which forces us to add a second stream \stream2 -> ... I think
02:50:55 <luqui> oh whoops.  I don't think Iteratee is directly representable in terms of Free, because of the extra data on Done.  but it has the same pattern, so the optimization will probably still apply.
02:51:26 <luqui> i.e. it's *almost* free monad over the functor Stream -> m -
02:51:40 <tibbe> lets see if we can write the applicative instance first ;)
02:53:31 <tibbe> Updated http://hpaste.org/12889#a3 with what I got so far
02:56:37 <mathijs> Hi all, for a current project, I needed a SQL parser. I found a reasonably complete example, built on rparsec. rparsec is a ruby port of parsec. although it does work, the syntax is quite hacky. Is anyone aware of a sql-parser (example) on haskell's parsec?
02:59:43 <tibbe> hmm, how can I conclude that Iteratee is not an applicative functor?
02:59:59 <Saizan> what about assuming append for stream and have: Done f stream <*> Cont k = Cont $ \s2 -> k (stream`append`s2) ?
03:00:31 <tibbe> Saizan: hmm, stream is a monoid
03:00:37 <tibbe> I think
03:00:42 <tibbe> mzero = Eof
03:00:54 <tibbe> Eof `mappend` s = Eof
03:01:12 <tibbe> e@(Error _) `mappend` s = e
03:01:45 <tibbe> Chunk s `mappend` Chunk s' = Chunk (s ++ s')
03:02:05 <tibbe> I guess s `mappen` Eof|Error is also Eof|Error
03:02:31 <Saizan> it'll be a bit weird
03:02:39 <tibbe> probably xD
03:02:47 <tibbe> I'm a bit confused overall atm
03:03:31 <Saizan> Chunk s `mappend` Chunk s1 `mappend` Eof == Eof, that way
03:03:32 <tibbe> I'm thinking Maybe it's not possible to write e.g. a monad instance for my type since Oleg didn't include one
03:03:58 <tibbe> Saizan: yeah
03:04:07 <tibbe> Saizan: hmm
03:04:22 <ronc> sup haskellians
03:05:27 <Saizan> you can have "Iteratee m a -> (a -> Iteratee m b) -> m (Iteratee m b)"
03:06:38 <Saizan> or you can add an Append Stream Stream constructor to Stream
03:06:41 <tibbe> Saizan: but that's not a monad
03:06:46 <tibbe> hmm
03:07:02 <tibbe> Saizan: so you're saying it
03:07:13 <tibbe> it's not possible to write a Monad instance with the current definitions?
03:07:40 <Saizan> i think that, but i've no idea on how to prove that
03:07:46 <tibbe> me neither :/
03:08:39 <Saizan> you probably need to state more precisely the semantics of how the Stream should flow from an action to the next
03:08:51 <tibbe> probably
03:09:05 <tibbe> I have a good intuitive idea
03:09:13 <tibbe> Eof and Error are basically mzero
03:09:34 <tibbe> since if an earlier iteratee fails than a later should see that error
03:10:37 <tibbe> but my previous mappend definition won't work since it will not allow an Iteratee to process a chunk if it's *followed* by an Eof
03:10:38 <Saizan> mh, but here the monad is not Stream
03:10:42 <tibbe> whuch is clearly wrong
03:12:14 <Saizan> well if we say that Stream is a monoid and Eof is mempty, then |s `mappend` Eof == s| from the monoid laws
03:13:01 <Saizan> so Chunk "foo" `mappend` Eof == Chunk "foo", but here we're losing the knowledge that the stream has ended after that Chunk
03:13:15 <solrize> "From the arguments given there, it appears the author only proves a somewhat weaker statement than the Goldbach conjecture, namely that there exists an even number greater than four which is the sum of two primes."  (Terry Tao comment on a purported proof of Goldbach)
03:13:29 <solrize> "exists" was italicized
03:13:36 <tibbe> Saizan: right, so Eof is not an identity
03:13:44 <ronc> guys
03:13:51 <ronc> can you help me with this? http://pastebin.com/d3aff4521
03:14:00 <ronc> I don't know what to use
03:14:05 <ronc> data or type
03:14:23 <Saizan> tibbe: (Chunk "") looks more like one, as suggested by the return definition
03:14:40 <tibbe> Saizan: right
03:16:05 <yitz> ronc: why a synonym? sounds like you are adding new stuff
03:16:19 <Saizan> we still don't known what to do with Chunk s `mappend` Eof :\
03:16:41 <tibbe> Saizan: no :(
03:17:18 <ronc> yitz: I didn't made the question... should I define everything with types and then define a data Nature with it?
03:17:56 <lilac> tibbe: what are the semantics of your Iteratee?
03:19:03 <lilac> i can't tell whether it's supposed to be producing or consuming Streams
03:19:04 <tibbe> lilac: the idea is that you should be able to compose them horizontally
03:19:10 <yitz> ronc: hard to say, I think your paste is missing a lot of important information
03:19:35 <tibbe> lilac: they're similar to the function being folded in a left fold except they have their state internalized
03:19:53 <tibbe> lilac: You can think of Stream as an elem if it makes things easier
03:20:11 <ronc> I see what you mean
03:20:21 <ronc> it's in the homework page
03:20:25 <ronc> but it's a lot of text
03:20:44 <tibbe> so the fold would be something like :: Iteratee m a -> m (Iteratee m a)
03:21:12 <ronc> I'm going to try to type it
03:21:16 <ronc> to see the outcome
03:21:55 <tibbe> i.e. foldBytes bs iter = case iter of { done@(Done _ _) -> done; (Cont k) -> k bs }
03:22:12 <quicksilver> lilac: I also have that problem in understanding tibbe's code
03:22:22 <quicksilver> lilac: it feels like a mixture of production and consumption to me
03:22:25 <tibbe> lilac: a fold over some other resource like a file will continously apply chunks as they are read until Eof
03:22:27 <lilac> tibbe: really? you ignore the returned stream in Done?
03:22:43 <lilac> or rather the remaining stream
03:22:49 <tibbe> it would probably be helpful if I linked Oleg's talk
03:22:50 <tibbe> sec
03:23:27 <lilac> is the idea that in the 'done' case, foldBytes bs (Done a bs'), that bs == bs'?
03:23:35 <tibbe> quicksilver: lilac: http://okmij.org/ftp/Streams.html and in particular http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf
03:23:58 <tibbe> lilac: no bs == bs' doesn't have to hold
03:24:16 <Saizan> bs' is the remaining non-consumed stream
03:24:42 <Saizan> it's a bit like a parser where Stream is the list of tokens
03:25:21 <Saizan> so a parser can ask for more input, or return a result with the part of the stream it has not consumed
03:25:34 <tibbe> Saizan: indeed, see my parser here: http://github.com/tibbe/hyena/tree/master/Hyena/Parser.hs
03:25:58 <tibbe> The binary package does the same thing
03:26:20 <tibbe> the difference is the extra functor in the continuation case
03:27:11 <tibbe> i.e. while a parser might have Result a = Done a String | Cont (String -> Result) I have Cont (String -> f (Result)) where f is a functor (or monad)
03:27:42 <tibbe> I can write an applicative and monad instance for the former, the question is whether it's possible to write one for the latter
03:28:24 <lilac> tibbe: i still think that you should have "foldBytes bs (Done a bs') = Done a (bs' `mappend` bs)
03:29:22 <tibbe> lilac: hmm, it's doesn't seem unreasonable at first glance at least :)
03:29:41 <lilac> otherwise you're losing the "bs" which just seems wrong :)
03:29:45 <tibbe> lilac: but it doesn't help me write my applicative instance, it's also unclear how to write mappend
03:30:26 <tibbe> lilac: but you would only loose it in case an iteratee decided to discard it and return Done x something_else instead
03:30:40 <tibbe> otherwise bs' must have originated from bs
03:30:56 <tibbe> in fact it should be a possibly empty suffix of bs
03:31:13 <lilac> tibbe: you'd lose it in the case where an iteratee decided to discard part of the /previous/ chunk, right?
03:31:26 <tibbe> I'll have to run out for lunch, be back in 20 mins
03:32:02 <lilac> but calling foldBytes on a Done value is silly anyway, so...
03:36:52 <Saizan> tibbe: you said M a = M (m (Iteratee m a)) is a monad right?
03:37:33 <ksf> what's a good thing to hack on if I want to get started with reactive?
03:38:01 <ksf> to get into the spirit, that is.
03:38:46 * lilac wants fmap2 = fmap.fmap etc
03:39:35 <opqdonut> lilac: no, you need: f ^^^ 1 = id, f ^^^ n = f . (f ^^^ n-1)
03:39:38 <opqdonut> ;)
03:39:54 <ronc> yitz: type Nature = ([String], String, [String], String, [Human], Human, Int) -- :P
03:39:55 <opqdonut> err, f^^^1 = f of course
03:40:40 <quicksilver> ksf: download the tetris game and get that running first?
03:40:56 <quicksilver> ksf: then either hack on it or use it as an example to write something else.
03:40:56 <Saizan> opqdonut: it doesn't work well, becuase the fmaps have different types
03:41:21 <opqdonut> hmm, good point
03:41:47 <opqdonut> it might work with some ghc extensions
03:42:06 <quicksilver> with an explicit type annotation, yes.
03:42:31 <lilac> tibbe: i'm pretty sure there's a sensible Monad instance for m `O` Iteratee m
03:43:45 <yitz> ronc, ok I see. Normally we wouldn't use a type synonym for this, but it looks like you're stuck with that.
03:44:11 <vegai> I'm supposing that simple compile-time string manipulation should be easy in TH?
03:45:12 <vegai> RWH should've had something about this ;/
03:45:28 <quicksilver> FSOV 'easy'
03:45:35 <quicksilver> not much is truly easy in TH.
03:46:04 <ronc> yitz: Normally, teachers don't smoke pot and copy the argument for the question from Spore... but I'm stuck with one that does that ~~
03:46:27 <vegai> quicksilver: aye ;-/ Perhaps a layer on top of it for these things might make sense?
03:46:44 <vegai> did somebody already do that...
03:47:15 <ronc> brb
03:47:27 <Saizan> ?hoogle lift
03:47:27 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
03:47:27 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
03:47:27 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
03:47:39 <Saizan> , lift "foo"
03:47:43 <yitz> vegai: I can understand why RWH steered clear of TH
03:47:54 <yitz> ronc: :P
03:47:56 <lunabot>  ListE [LitE (CharL 'f'),LitE (CharL 'o'),LitE (CharL 'o')]
03:48:05 <Saizan> , $(lift "foo")
03:48:08 <lunabot>  "foo"
03:48:13 <Saizan> vegai ^^^^
03:48:34 <ksf> a and s... it's hard to find two keys on my keyboard that are farther apart.
03:49:13 <yitz> ksf: the keycaps fell off?
03:49:20 <ksf> dvorak.
03:49:28 <yitz> ksf: aha
03:56:41 <vegai> TH gets no love, eh?
03:57:28 <yitz> vegai: TH is a great tool for when you need it. Haskell is powerful enough that it is quite rare.
03:59:08 <yitz> vegai: it's the oposite of lisp - its macros are what really give it power
03:59:59 <tibbe> back
04:00:12 <vegai> I don't absolutely need it, but I feel it would be nicer than some string concatenations I would otherwise have
04:00:20 <tibbe> Saizan: yes newtype M m a = M (m (Iteratee m a)) is a monad
04:00:49 <tibbe> Saizan, I suspect Iteratee m a isn't but it would be nice with an explanation of why
04:08:45 <lilac> tibbe: intuitively, a >> b must return Cont unless a and b are both Done, since Done doesn't contain m
04:09:07 <lilac> but semantically that's not right
04:09:39 <basvandijk> Hello, I'm updating the Stream package by Wouter Swierstra. Note that: 'data Stream a = a ::: Stream a'. I'm experimenting wether I can define a Show and Read instance for Streams such that the following: 'take 10 $ read $ show $ cycle [1,2,3]' yields [1,2,3,1,2,3,1,2,3,1]. My Show instance exploits the fact that (:::) is right asociative by not putting parenthesis around xs in x ::: xs. However I've trouble defining a suitable Read
04:09:39 <basvandijk> instance that doesn't loop. See the hpaste:
04:09:39 <basvandijk>  
04:10:45 <basvandijk> See: http://hpaste.org/12891
04:11:35 <tibbe> lilac: what do you mean by it's not semantically right?
04:14:21 <tibbe> lilac: I think I have convinced myself that it's not possible to write that particular case because it must be on the form: Cont (\stream2 -> ... k stream ...) and stream2 must be applied to the result of (k stream) somehow and that would required that m is a monad
04:14:58 <basvandijk> Note that my show works correcly: Prelude.take 50 $ show $ cycle [1,2,3] == "1 ::: 2 ::: 3 ::: 1 ::: 2 ::: 3 ::: 1 ::: 2 ::: 3 "
04:15:18 <tibbe> lilac: i.e. it most be on that form to make sense sematically
04:15:24 <Saizan> basvandijk: i think readParen should wrap the recursive call, rather than the whole
04:16:07 <basvandijk> Saizan: I will try
04:16:16 <tibbe> lilac: we must use the first stream and we have to accept a second but the only things we can do with the second stream is discard it since we can't apply it on the Iterateee inside m (Iteratee m a)
04:18:57 <basvandijk> Saizan: wrapping readParen around the recursive call doesn't help. It still loops.
04:26:06 <PeakerWork> I hate to see the code duplication that results from slightly different strictness..
04:26:29 <solrize_> i just wrote some c code.  it felt really really good.  doc, am i a pervert?  :)
04:27:33 <quicksilver> PeakerWork: so do I. Maybe we should get used to passing 'Strategy a's around to handle strictness rather than writing variants.
04:27:43 <PeakerWork> quicksilver: exactly what I was about to suggest
04:28:17 <PeakerWork> in addition to:   data Blah a = Blah !a    we could have data Blah a = Blah (Strict a)      and then we could have:  data Blah s a = Blah (s a)
04:28:40 <PeakerWork> where hopefully, Strict behaves like a type, not like newtype, so you don't lose instances, or need to wrap/unwrap
04:28:50 <sjanssen> Strict isn't definable in Haskell as we know it
04:28:57 <PeakerWork> Yeah, magic..
04:29:29 <sjanssen> this does work: data Blah s a = Blah (s a); newtype Strict a = Strict a; data Lazy a = Lazy a
04:29:33 <sjanssen> oops
04:29:45 <sjanssen> data Blah s a = Blah !(s a) -- is what I meant
04:30:15 <PeakerWork> sjanssen: defeats the point, though :)
04:30:31 <sjanssen> PeakerWork: I don't see how it does
04:30:43 <sjanssen> strictness in Blah is controlled via a type parameter
04:30:54 <PeakerWork> oh, I guess it doesn't defeat the point, indeed
04:31:06 <PeakerWork> but having _everyone_ do this is so cumbersome
04:31:14 <PeakerWork> (And unwrapping/wrapping everything all the time... :(  )
04:31:29 <quicksilver> I wasn't suggesting changing the types
04:31:32 <sjanssen> usually types don't need different strictness, it is generally a problem with the functions
04:31:35 <quicksilver> I was suggesting changing the functions
04:31:41 <quicksilver> to take a Strategy a parameter
04:32:38 <PeakerWork> I think maybe it does warrent syntactic sugar or some such, so you don't have to write everything with strictness awareness for others to be able to control the strictness strategy when using your code
04:32:55 <PeakerWork> sjanssen: Well, I thought tibbe's example wanted strictness in types
04:33:17 <sjanssen> PeakerWork: I wasn't paying attention then
04:33:48 <sjanssen> quicksilver: perhaps the strategies could be implicit parameters?
04:35:02 <quicksilver> sjanssen: I don't think so. But I'm not sure.
04:35:05 <quicksilver> I need to think about practical examples
04:35:38 <sjanssen> well, I'm just imagining how to do this without requiring too much extra code
04:35:51 <tibbe> argh, I think I have written a Monad instance for Iteratee now but that doesn't make much sense since I couldn't write and Applicative instance for it!
04:35:59 <tibbe> hence my Monad instance must be wrong somehow
04:36:20 <tibbe> or hmm, I did change the context to Monad m rather than Functor m
04:37:20 <sjanssen> quicksilver: or is "foldl r0 f z xs" and "foldl rwhnf f z xs" nice enough?
04:37:22 <tibbe> Does this monad instance make sense: http://hpaste.org/12889#a4
04:39:15 <Saizan> tibbe: it looks like it consumes one more "chunk" than what is needed
04:39:42 <tibbe> Saizan: where?
04:40:09 <quicksilver> sjanssen: that's the kind of thing I was thinking of, yes.
04:40:31 <quicksilver> sjanssen: is GHC smart enoguh to optimise out a dummy strategy though?
04:41:00 <sjanssen> quicksilver: in a non-recursive function, probably
04:41:24 <Saizan> tibbe: s' in case iter of Done a s'' -> return $ Done a s''
04:42:08 <tibbe> Saizan: right
04:42:19 <tibbe> Done a _ -> return $ Done a s'
04:44:11 <eu-prleu-peupeu> yo Hppl
04:44:14 <eu-prleu-peupeu> check it: http://images.encyclopediadramatica.com/images/9/98/Derive.jpg
04:44:31 <sjanssen> quicksilver: should also work with the standard non-recursive wrapper trick, I think
04:44:37 <Saizan> do "Done a Eof" or "Done a (Error x)" make sense?
04:44:46 <tibbe> yes
04:45:08 <tibbe> they short-circuit the stream
04:45:36 <tibbe> if the previous iteratee saw a Eof the next iteratee should see it as well unless the current iteratee can somehow recover
04:46:33 <sjanssen> speaking of that trick, I wonder if Data.Map would become faster if all the functions were rewritten in that style?
04:46:42 <tibbe> Done a Eof is likely what most application of an enumerator to an iteratee will result in
04:47:54 <Saizan> however to me it looks wrong that Cont $ \s' -> asks for an extra stream before knowing if it needs it
04:48:33 <Saizan> but it might not be that important
04:50:15 <tibbe> yes
04:50:32 * tibbe will need to ask Oleg
04:50:35 <tibbe> ;)
04:50:55 <tibbe> instance Oleg Iteratee where magic :: Oleg ()
04:51:00 <Saizan> heh
04:51:32 <tibbe> on a more serious note he spent more time thinking about iteratees than me
04:52:21 <Saizan> why do you want Iteratee m to be a monad when M m a = M (m (Iteratee m a)) is already one? it seems like a fine Iteratee "transformer" to me
04:53:08 <tibbe> Saizan: the resulting code looks ugly thanks to the newtype
04:53:37 <tibbe> Saizan: so if parts of it could be written using a monad instance on the Iteratee rather than special >>== and ==<< combinators that would be nice
04:53:52 <tibbe> also I want to understand the properties of the datatype better
04:54:28 <Saizan> ah, i thought you could define some primitives on M and use it as an abstract type
04:55:45 <Saizan> it reminds me of ListT done right
04:57:04 <tibbe> Saizan: unfortunately I haven't been able to write such primitives so I have to export the newtype and ==<< etc so other modules can write new iteratees
04:58:05 <zax> How do I set the limit of numbers to be shown when dealing with irregular numbers?
04:58:30 <quicksilver> zax : showEFloat showFFloat showGFloat
04:58:53 <zax> e,f,g = ?
04:59:03 <quicksilver> try them out, they're functions
04:59:10 <quicksilver> :t showEFloat
04:59:11 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
04:59:13 <tibbe> meeting
04:59:22 <quicksilver> > showEFloat (Just 3) 1.2345678 ""
04:59:24 <lambdabot>   "1.235e0"
05:01:36 <zax> Hm :)
05:03:12 <mbz> > showEFloat (Just -3) 1.2345678 ""
05:03:13 <lambdabot>   Couldn't match expected type `Maybe Int'
05:04:07 <byorgey> mbz: need parens around your (-3) there
05:04:54 <mbz> > showEFloat (Just (-3)) 1.2345678 ""
05:04:56 <lambdabot>   "1.2e0"
05:05:06 <zax> thats not what i want
05:05:14 <mjrosenb> does haskell support weak references?
05:05:37 <mbz> @faq does haskell support wak references
05:05:37 <lambdabot> The answer is: Yes! Haskell can do that.
05:05:41 <mbz> :)
05:05:46 <mjrosenb> erm
05:05:47 <zax> wak!!
05:06:07 * mjrosenb is not convinced by lambdabot
05:06:08 <blackh> zax: You probably want showFFloat
05:06:23 <zax> since now i have:
05:06:24 <zax> Main> 1/9
05:06:24 <zax> 0.111111111111111
05:06:37 <zax> but i want like 50 decimals instead, or some arbitrary number
05:06:54 <blackh> > showFFloat (Just 3) (1/9) ""
05:06:55 <lambdabot>   "0.111"
05:07:12 <zax> that sounds about right :-)
05:07:13 <zax> thansk
05:08:15 <blackh> @faq Can Haskell make the tea?
05:08:15 <lambdabot> The answer is: Yes! Haskell can do that.
05:08:24 <Saizan> mjrosenb: see System.Mem.Weak
05:09:25 <skorpan> @faq can haskell solve the halting problem?
05:09:26 <lambdabot> The answer is: Yes! Haskell can do that.
05:09:37 <skorpan> @faq can haskell reduce non-reducible problems to reducible ones?
05:09:38 <lambdabot> The answer is: Yes! Haskell can do that.
05:09:50 <skorpan> well, i'll be darned, haskell seems like a pretty cool guy.
05:10:00 <lilac> @faq can haskell derive a problem so hard that haskell cannot solve it?
05:10:00 <lambdabot> The answer is: Yes! Haskell can do that.
05:10:11 <EvilTerran> i think the problem you're getting here is that it's behaving arbitrarily when the answer is _|_
05:10:12 <lilac> @faq and can haskell solve that very hard problem it derived?
05:10:12 <lambdabot> The answer is: Yes! Haskell can do that.
05:10:33 <EvilTerran> as "Yes! Haskell can do that." is a refinement of _|_, it's correct to substitute it in :P
05:10:40 <lilac> @faq can haskell dance?
05:10:41 <lambdabot> The answer is: Yes! Haskell can do that.
05:10:44 <mjrosenb> excellent, so then i can ask my actual question
05:10:54 <skorpan> @faq can haskell curry has can haskell curry has can haskell curry has
05:10:55 <lambdabot> The answer is: Yes! Haskell can do that.
05:10:59 <mjrosenb> does anyone actually know how to implement weak references?
05:11:17 <EvilTerran> mjrosenb, that depends on your garbage collector, surely?
05:11:44 <lilac> skorpan: so many interpretations, so few grammatically correct ones...
05:11:47 <mjrosenb> EvilTerran: yes, but i don't know how to do it with *any* garbage collection algorithm
05:12:00 <mjrosenb> knowing to do it with one would be useful
05:12:05 <skorpan> lilac: what?
05:12:14 <polveroj> mjrosenb: SPJ has a paper on it, let me look for it
05:12:47 <mjrosenb> spj has papers on *everything* doesn't he
05:13:16 <lilac> skorpan: "can haskell curry has ..."
05:13:31 <skorpan> lilac: well, can he has?
05:13:41 <lilac> skorpan: 'can' 'haskell' and 'curry' each have multiple meanings
05:13:58 <lilac> and my brain's parser is stuck trying to interpret that sentence
05:14:10 <mjrosenb> can :: Language -> Person -> Word -> a
05:14:15 <skorpan> it's an inductively defined sentence
05:14:22 <skorpan> prove it by induction
05:14:35 <lilac> the can which Haskell Curry has can do what?
05:14:46 <skorpan> has!
05:14:55 <lilac> assuming that 'haskell curry' is an elaborated form of the verb 'curry'..
05:15:39 <SamB_XP> Haskell Curry is actually a proper noun ;-P
05:15:44 <lilac> then the can which Haskell Curry has can curry the can which Haskell Curry has
05:15:50 <skorpan> i think it's a preposition
05:15:51 <lilac> (in haskell)
05:15:54 <sbahra> For some reason, I read 'verb' out with an Indian accent. Sleep deprivation is getting to me :)
05:16:20 <SamB_XP> (was a proper noun?)
05:16:23 <skorpan> has was
05:17:00 <lilac> instance HaskellCurry Can where curry :: HaskellCurry can => ((can, can) -> can) -> can -> can -> can
05:17:48 <SamB_XP> how many nuns could a nunchuck chuck if a nunchuck could chuck nuns ?
05:17:55 <polveroj> mjrosenb: the one I read was http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1948 -- I'm not sure how deep into implementation details it gets
05:18:09 <blackh> SamB_XP: None
05:18:10 <lilac> SamB_XP: none
05:18:20 <SamB_XP> how so ?
05:18:24 <lilac> contradiction!
05:18:33 <lilac> therefore a nunchuck can't chuck nuns
05:18:46 <SamB_XP> I don't think it would make any sense to claim it could chuck nuns if it could chuck no nuns ...
05:19:29 <skorpan> could a woodchuck chuck chuck norris?
05:19:38 <SamB_XP> it's not even particularly funny!
05:20:11 <SamB_XP> skorpan: that probably depends on whether or not this is a chuck norris joke
05:20:49 <lilac> skorpan: i just ran text-to-speech on that and it was brilliant
05:20:53 <SamB_XP> hmm, is a chuck norris vs. mr. T fight listed with the cat attached to buttered toast ?
05:20:53 <skorpan> one never jokes about chuck norris... chuck norris only abouts jokes.
05:21:23 <lilac> SamB_XP: Mr T ain't fightin no chuck norris, foo'
05:21:24 <SamB_XP> and the storm troopers / red shirts thing ?
05:21:44 <mjrosenb> polveroj: thank you very much
05:21:50 <SamB_XP> alternative energy sources, you know
05:22:05 <SamB_XP> (hmm, why can't we just butter the toast on both sides ?)
05:22:27 <blackh> mjrosenb: How hard can it be to implement weak references?
05:22:31 <p_l> SamB_XP: It will land sideways?
05:22:32 <lilac> SamB_XP: it'll still land butter-side-down
05:22:33 <skorpan> SamB_XP: who would do such a thing?
05:22:41 <mjrosenb> blackh: how would you do it?
05:22:53 <SamB_XP> skorpan: such a thing as what ?
05:22:59 <skorpan> buttering a toast on both sides
05:23:11 <blackh> mjrosenb: Hmmm...
05:23:16 <SamB_XP> hmm, well, I guess lilac is right that it wouldn't work
05:23:27 <SamB_XP> because it'd be really easy for it to land butter side down anyways
05:23:33 <p_l> SamB_XP: It might also split itself into a state where both sides would land on the down side...
05:23:35 <skorpan> what if we cut the toast open and butter its inside?
05:23:39 <mjrosenb> you need a peice of toast won one side, with butter, and a cat on the other side
05:23:42 <SamB_XP> so I guess you really do need to attach it to a cat
05:23:43 <lilac> does that mean that unbuttered toast must accumulate butter on the way to the floor?
05:23:56 <lilac> why not just cut out the middleman and butter the cat
05:23:56 <SamB_XP> lilac: no
05:24:04 <SamB_XP> the rule only applies when you've buttered the toast
05:24:08 <p_l> skorpan: Won't work, as it won't have the buttered side
05:24:08 <mjrosenb> lilac: it only works with buttered toast
05:24:12 <mjrosenb> efb
05:24:16 <skorpan> maybe we should toast a butter instead
05:24:19 <skorpan> PARADOX
05:24:21 <SamB_XP> lilac: there's no rule about cats landing buttered-side down
05:24:22 <blackh> mjrosenb: It's easy except for the bit where.... you find the weak reference to zero it.
05:24:44 <Axman6> Beelsebob: you around?
05:24:47 <mjrosenb> blackh: yes.  it's easy except the hard part
05:25:09 <blackh> mjrosenb: I hadn't thought of the hard part.  Now, I'm sure I did this once.
05:25:10 <mjrosenb> i found a way of doing it, but it's *quite* painful
05:25:12 <SamB_XP> do you need to keep a table of weakrefs ?
05:25:22 * byorgey wonders what everyone in #haskell has been drinking while he was gone
05:25:33 <polveroj> butter, I think.
05:25:37 <mjrosenb> byorgey: sml kool-aid
05:25:52 <SamB_XP> byorgey: well, someone said something incomprehensible about Haskell Curry
05:25:58 <p_l> I'm suspecting it was what I once tasted... called "Highlander's Butter". >40%
05:25:59 * mjrosenb hands byorgey a large plastic cup
05:26:02 <SamB_XP> so I felt obligated to make a more understandable joke
05:26:33 * byorgey sips warily... hey, not bad =)
05:27:01 <SamB_XP> mjrosenb: can I get mine with a touch of polymorphic recursion ?
05:27:39 <kool-aid_nazi> SamB_XP: NO KOOL-AID FOR YOU
05:28:56 <Axman6> :t let f x = (f x, f x) in f
05:28:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
05:28:58 <lambdabot>       Expected type: t
05:28:58 <lambdabot>       Inferred type: (t, t)
05:29:12 <mjrosenb> i love how you can make types that you can't use
05:29:47 <Axman6> :t let f 0 = (); f x n = (f x (n-1), f x (n-1)) in f
05:29:48 <mjrosenb> such as data wtf a = OK a | WTF (a,a)
05:29:49 <lambdabot>     Equations for `f' have different numbers of arguments
05:29:49 <lambdabot>       <interactive>:1:4-11
05:29:49 <lambdabot>       <interactive>:1:14-43
05:29:51 <lilac> mjrosenb: your GC is able to find all pointers and can update them when it moves objects; it's not really that much harder to zero them is it?
05:30:00 <Axman6> :t let f x 0 = (); f x n = (f x (n-1), f x (n-1)) in f
05:30:01 <lambdabot>     Couldn't match expected type `()' against inferred type `((), ())'
05:30:01 <lambdabot>     In the expression: (f x (n - 1), f x (n - 1))
05:30:01 <lambdabot>     In the definition of `f': f x n = (f x (n - 1), f x (n - 1))
05:30:11 <mjrosenb> lilac: but how do you know when t zero them?
05:30:14 <hallongrottan> @src transpose
05:30:14 <lambdabot> transpose []             = []
05:30:14 <lambdabot> transpose ([]   : xss)   = transpose xss
05:30:14 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:30:24 <SamB_XP> mjrosenb: well, how does it know where the pointers are ?
05:30:32 <lilac> mjrosenb: is the question, how do you know when they're weak references?
05:31:15 <blackh> mjrosenb: Is this a mark / sweep style of GC?
05:31:25 <byorgey> Axman6: you're going to need dependent types for that =)
05:31:26 <mjrosenb> blackh: presumably
05:31:53 <mjrosenb> byorgey: or just change it to a print function
05:32:00 <Axman6> byorgey: i don't want no fancy schmancy dependant types nonsense. i wants what i wants!
05:32:00 <byorgey> that would work too
05:32:59 <mjrosenb> Axman6: just change something to show and explicitly type it as show a => int -> a or something like that
05:33:02 <mjrosenb> anyhow
05:33:16 <mjrosenb> i think i need to leave to catch a train in the near future
05:33:58 <Saizan> > let f :: Show x => Int -> x -> String; f 0 x = show x; f n x = f (n-1) (x,x); in f 3 'x'
05:33:59 <lambdabot>   "((('x','x'),('x','x')),(('x','x'),('x','x')))"
05:34:00 <dolio> Nope, Show a => Int -> a isn't the right type.
05:34:06 <SamB_XP> argg, what is this installer popping up for
05:34:12 <SamB_XP> I just wanted to look at a PDF
05:34:41 <Axman6> ah, nice
05:34:54 <Axman6> > let f :: Show x => Int -> x -> String; f 0 x = show x; f n x = f (n-1) (x,x); in f 10 1
05:34:56 <lambdabot>   "((((((((((1,1),(1,1)),((1,1),(1,1))),(((1,1),(1,1)),((1,1),(1,1)))),((((1,...
05:36:13 <dolio> Int -> (exists a. Show a => a) is a possible type.
05:36:34 <mjrosenb> iirc, this is the only way that haskell supports polymorphic recursion
05:36:52 <Axman6> huh, OpenCL has a 'half'  datatype, which seems to be a 16 bit floating value
05:36:54 <mjrosenb> i.e. when implemented with a type class
05:36:56 <blackh> mjrosenb: Keep the weak references out of the garbage collector, and look them up in a map upon every finalize.
05:37:22 <SamB_XP> Axman6: is that surprising in some way ?
05:37:29 <mjrosenb> blackh: this means that every time you garbage collect anything, you need to check the table
05:37:31 <Axman6> a little
05:37:35 <SamB_XP> why ?
05:37:51 <Axman6> well, 16 bit cloating point numbers aren't that common :)
05:38:01 <Axman6> they're usually 32 or 64
05:38:06 <SamB_XP> GPUs have been using them for a while
05:38:15 <Axman6> ah, fair enough
05:38:29 <SamB_XP> they're not bad for color component values
05:38:42 <lilac> data Zero = Zero; data Succ a = Succ a; class Axman n v where f :: n -> v; instance Axman Zero () where f _ = (); instance Axman n v => Axman (Succ n) (v, v) where f (Succ n) v = (f n, f n)
05:39:18 <dolio> mjrosenb: Well, typeclasses are the only way you'll get a function overloaded such that you'd be doing polymorphic recursion, no?
05:39:38 <Axman6> lilac: >_<
05:39:39 <blackh> mjrosenb: Indeed, but you can use tricks.  Remember that memory allocation is already relatively expensive (for each finalize, there's a corresponding allocation).
05:39:45 <lilac> YO OLEG WE HEAR YOU LIKE TYPES SO WE PUT A TYPESYSTEM IN YOUR TYPESYSTEM SO YOU CAN TYPECHECK WHILE YOU TYPECHECK
05:40:18 <blackh> mjrosenb: One trick would be to flag any objects that have (ever) had a weak reference, and look only those up in the map.
05:40:40 <dolio> @quote metacircularity
05:40:40 <lambdabot> No quotes match. You type like i drive.
05:40:41 <mjrosenb> blackh: sure, but you should never need to do something on every element that you're not keeping when you do a gc pass
05:40:54 <dolio> Durn lambdabot forgetting quotes.
05:41:37 <blackh> mjrosenb: If you count the allocation and cleanup together as the cost of the object's life cycle, then checking a flag is cheap in time (but expensive in memory).
05:41:39 <SamB_XP> well, if there was a header bit you could set ...
05:41:53 <Axman6> > let f :: Show x => Int -> x -> String; f 0 x = show x; f n x = f (n-1) (x,x); in f 20 ""
05:41:55 <lambdabot>   "((((((((((((((((((((\"\",\"\"),(\"\",\"\")),((\"\",\"\"),(\"\",\"\"))),(((...
05:42:03 <SamB_XP> (of course there probably isn't ...)
05:42:18 <SamB_XP> I wish the GHC commentary explained weakrefs :-(
05:42:45 <mjrosenb> blackh: more than doubling the total amount of time spent on allocating each object isn't what i'd call 'cheap'
05:43:02 <mjrosenb> oh, if you only do a lookup if it had a weak pointer
05:43:05 <mjrosenb> not as bad
05:43:13 <SamB_XP> quite
05:43:21 <SamB_XP> the question is where to store such an indication
05:43:28 <mjrosenb> but it'll still be non-constant in the number of weak references total
05:43:37 <mjrosenb> since you need to do a lookup
05:44:06 <mjrosenb> also, wouldn't you need to garbage collect the tables as well?
05:44:30 <aeolist> hey dblazakis
05:44:34 <SamB_XP> mjrosenb: well, you'd need to take entries out when weakrefs were collected, yes
05:44:42 <blackh> mjrosenb: Use 'malloc' for the tables. :)
05:45:00 <SamB_XP> and you'd also need to rewrite all the object addresses when objects got moved
05:45:08 <mjrosenb> blackh: not solving the problem in any way shape or form
05:46:07 <blackh> mjrosenb: I never said I could do it for nothing.  What's this for?
05:47:50 <mjrosenb> blackh: my own knowledge
05:48:25 <mjrosenb> i came up with something sort of similar, and assumed that there needed to be a less stupid way of doing it
05:48:28 <blackh> mjrosenb: object cleanup would be logN per weakref (NlogN overall).  1 pointer dereference across the board per object cleanup, and 1 bit of memory per object.
05:48:47 <blackh> There's a starting point, anyway.
05:50:09 <mjrosenb> yeah, the hack i used was to put the elements of the table into the heap, and whenever you made a weak reference to some object, X, you added a reference from X to the weak reference to X
05:50:30 <SamB_XP> oh, and O(N) in garbage to check the bits ...
05:51:50 <mjrosenb> it's O(N) where n is the number of reachable objects
05:51:53 <mjrosenb> which is fine
05:52:08 <mjrosenb> when n is the total number of objects that can fit into memory, less good
05:52:22 <blackh> That would work.  My flag way is slightly more efficient and might be easier to make thread-safe.
05:52:49 <SamB_XP> well, if you don't have a free bit ...
05:52:57 <mjrosenb> blackh: more efficent in terms of what?
05:53:15 <blackh> Now that I think about it it's probably not more efficient - just differently efficient.
05:53:39 <blackh> My way adds the cost of a map lookup for weak-refed objects but I assume this will be relatively rare.
05:54:17 <blackh> I need only one bit per object but it probably needs to be a machine word anyway due to threading issues.
05:54:22 <blackh> There must be a better way.
05:54:52 <lilac> mjrosenb: do you know how a copying collector updates the references to an object when it's moved?
05:55:09 <mjrosenb> well with mine, you can have it take a bit always, and a word if that bit is set
05:55:13 <lilac> i don't, but zeroing weak references seems so similar that i assume it can be done the same way
05:55:19 <mjrosenb> lilac: in cheney scan, yes
05:55:40 <polveroj> Aha, yes, that paper does describe how GHC does it:
05:55:42 <polveroj> 	   http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1948
05:55:59 <polveroj> (5.5, implementing weak pointers)
05:56:26 <mjrosenb> lilac: the issue if if you reach a weak reference, and you haven't seen a strong reference to the object that it references, what do you do?
05:56:52 <lilac> mjrosenb: you add it to a list of things to check at the end?
05:57:16 <polveroj> GHC has a table of weak references, which it checks after it marks the rest of the heap
05:57:27 <mjrosenb> lilac: and were do you get this list from?
05:57:31 <mjrosenb> polveroj: eww.
05:57:39 <SamB> oookay ....
05:57:43 <lilac> mjrosenb: as i said, you add the weak reference to a list
05:57:51 <lilac> mjrosenb: that is, you build the list as you see the references
05:57:54 <SamB> I just found an #ifdefed comment in GHC's RTS sources
05:58:01 <mjrosenb> lilac: right, but where are you getting the room for this list from
05:58:22 <mjrosenb> lilac: in copying collectors, usually, you only run a g.c. pass when you're out of memory
05:59:23 <lilac> mjrosenb: then what's it copying into?
06:00:09 <mjrosenb> lilac: there's a reason that people don't like copying collectors
06:00:28 <blackh> OK - so you maintain a table of weak references.  During GC you mark strong references.  Then you scan the whole table of weak references, cleaning up anything that's not been marked.
06:00:41 <lilac> mjrosenb: alternatively, each weak reference can have an extra pointer added to it so you can form a linked list of them in place
06:00:52 <blackh> That's probably how GHC does it from polveroj's comment.  Much better than my suggestion.
06:01:37 <mjrosenb> presumably it also has means to mark items in the table as being referenced, and cleaning those when they're not referenced either
06:02:09 <mjrosenb> anyhow, now that i know when my train is leaving, i really need to go
06:02:16 <blackh> I must go too, as it's 3 AM.  See ya.
06:04:33 <Baughn> Is it generally considered a bad thing if your code has so many fromIntegrals you say " = fromIntegral"?
06:04:57 <Baughn> Speaking hypothetically. I haven't done that. Yet. I feel the need, though.
06:05:46 <wjt> Baughn: hmm, can you use  as a (prefix) function?
06:07:18 <Baughn> wjt: Possibly
06:08:23 <quicksilver> > let a ? b = a + b in 5 ? 10
06:08:25 <lambdabot>   15
06:08:36 <Baughn> quicksilver: Right, but  is a unicode letter
06:08:39 <Baughn> ..isn't it?
06:08:49 <quicksilver> heh
06:08:55 <quicksilver> utf8 FAIL ;)
06:09:26 <Baughn> ghci's utter failure at parsing it certainly speaks for its being unicode. ^^;
06:09:47 <ksf> no it isn't.
06:09:56 <ksf> it's on german keyboards, so it must be iso-1.
06:10:12 <quicksilver> being iso-1 doesn't exclude it from being in unicode.
06:10:15 <quicksilver> What was it?
06:10:16 <ksf> it's pronounced "Section"
06:10:42 <quicksilver> Oh, the section mark? I would have thought that was classified as operator not letter.
06:10:53 <ksf> me, too.
06:11:05 <Axman6> > let a ? b :| c = if a then b else c in False ? 1 :| 2
06:11:07 <lambdabot>       precedence parsing error
06:11:07 <lambdabot>          cannot mix `?' [infixl 9] and `:|' [i...
06:12:02 <Saizan> > let a ? b = \c -> if a then b else c in False ? 1 $ 2
06:12:04 <lambdabot>   2
06:12:07 <SamB> > let infixr 9 ?; a ? b :| c = if a then b else c in False ? 1 :| 2
06:12:08 <lambdabot>       precedence parsing error
06:12:08 <lambdabot>          cannot mix `?' [infixr 9] and `:|' [i...
06:12:12 <Saizan> > let a ? b = \c -> if a then b else c in True ? 1 $ 2
06:12:14 <lambdabot>   1
06:12:31 <quicksilver> isLetter says it's false, in my GHC
06:12:45 <SamB> > x :| y :| z
06:12:46 <lambdabot>   Not in scope: data constructor `:|'Not in scope: data constructor `:|'
06:12:51 <quicksilver> and lets me use it infix.
06:13:03 <SamB> ... okay ...
06:13:42 <Axman6> Saizan: nice
06:15:22 <Axman6> so, anyone excited about OpenCL + GHC? (/is someone planning to work on it? :/)
06:15:33 <Saizan> OpenCL?
06:16:01 <Baughn> Axman6: Excited, yes. Going to work on it?
06:16:13 <Baughn> ..I've got plenty of exciting ideas. Don't know if this one will make the cut.
06:16:33 <Baughn> Also, I don't think I'm good enough with haskell to make an ideal interface (yet)
06:16:46 <ksf> is it going to run on my 7600 gs?
06:17:13 <Baughn> ksf: Probably not. CUDA, at least, needs an 8000-series one
06:17:28 <Axman6> Saizan: the new language Apple invented, with the backing of pretty much every major chip maker out there for eas parallel computation on multi-cores, GPU's, Cell and even DSP's
06:17:45 <ksf> well, in theory the 7600 is general-purpose capable. you just gotta do texture hacks.
06:18:26 <Axman6> i think it may need 8xxx+ cards from nVidia
06:18:35 <Baughn> ksf: It may not be able to support the interface OpenCL exports without heroic efforts, and nvidia would probably prefer you to get a new card. Then again, you never know.
06:19:05 <ksf> I still got a monster 3d! I want to use that1111one11!!!
06:19:08 <Baughn> An 8000-series card is pretty cheap these days. It'll be even cheaper when opencl is released, so..
06:20:31 <Baughn> ksf: More to the point, it wouldn't be very fast. As I'm going to write some software for opencl whatever happens, I'd like to be able to rely on a certain minimum level of performance.
06:22:07 <ksf> Gonna need a new mainboard then, I'm still stuck with agp.
06:22:21 <Baughn> ksf: ..quite
06:22:46 <Axman6> computer component prices are low these days, just build a new box
06:22:48 <Baughn> ksf: AGP is decently fast in the CPU->GPU direction, but the reverse path is thin and slow
06:22:53 <quicksilver> the opencl example on wikipedia looks fairly horrific
06:23:16 <Baughn> ksf: I don't think there'd be much point in opencl if you can't read the results back out at a decent rate..
06:23:32 <Axman6> quicksilver: well it's restricted C, so...
06:23:35 <Beelsebob> quicksilver: it does rather, doesn't it
06:24:13 <quicksilver> Axman6: yes, I knew that. But at least GLSL defined custom operators and types to make it look nice
06:24:20 <Axman6> it is doing an FFt though, and those aren't that easy to write in a small space right?
06:24:27 <Baughn> quicksilver: One can only hope we can abstract over this a little, in HsCL
06:24:28 <quicksilver> Axman6: the example I'm looking at it just a load of global function calls.
06:24:32 <jajamana> :type >
06:24:40 <jajamana> >type >
06:24:47 <Baughn> @type (>)
06:24:47 <quicksilver> :t (>)
06:24:48 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:24:49 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:25:24 <quicksilver> I mean, GLSL was at least a little bit declarative
06:25:35 <quicksilver> with inputs and outputs and implicit parallelisation of programs
06:25:40 <jajamana> Thanks, I have seen src being used, how can I see the source for the > operator on lists?
06:25:56 <ksf> waaaagh wikipedia citing the ny times citing an apple suit wrt. opencl being superior to cuda...
06:26:07 <Axman6> @src [] compare
06:26:08 <lambdabot> Source not found. Sorry.
06:26:13 <Axman6> @src [] (>)
06:26:13 <Baughn> jajamana: > is not defined for lists
06:26:14 <lambdabot> Source not found. Maybe you made a typo?
06:26:20 <quicksilver> Baughn: sure it is.
06:26:27 <Axman6> > [1,4,3] > [2,3]
06:26:29 <lambdabot>   False
06:26:34 <jajamana> > [3,2,1] > [1,2,3]
06:26:35 <lambdabot>   True
06:26:40 <ksf> @src Ord []
06:26:41 <lambdabot> Source not found. stty: unknown mode: doofus
06:26:47 <quicksilver> jajamana: dont think the src for that instance is in lambdabot, no
06:27:18 <jajamana> quicksilver: ok, just wondering, following a tutorial
06:27:38 <Axman6> it's probably all.zipWith (>)
06:27:43 <Axman6> or something
06:27:45 <Axman6> :t all
06:27:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:27:51 <Axman6> :t and
06:27:52 <lambdabot> [Bool] -> Bool
06:28:01 <Axman6> i always get those confused -_-
06:28:08 <Axman6> seems it should be the other way around
06:28:14 <quicksilver> no, it's not
06:28:20 <quicksilver> it's more complex than that.
06:28:23 <quicksilver> it's something like :
06:28:31 <jajamana> Axman: It is lexicographic so I was wondering how that is handled.
06:28:52 <quicksilver> compare [] [] = EQ; compare _ [] = GT; compare (x:xs) (y:ys) | x == y = compare xs ys
06:28:58 <ksf> It surely uses the Ord instance of the inner type.
06:29:03 <Baughn> quicksilver: Ugh. "No instance for (Ord (Num a))", though
06:29:18 <quicksilver> | x < y = LT | y > y = GT
06:29:22 <Baughn> Yep, that's broken
06:29:25 <quicksilver> I may have missed a case.
06:29:30 <quicksilver> Baughn: wtf?
06:29:36 <quicksilver> Baughn: Ord (Num a) isn't haskell?
06:29:50 <Axman6> quicksilver: compare [] _?
06:29:51 <Baughn> quicksilver: That would be because I'm not using ghci
06:29:56 <quicksilver> you can't nest classes...
06:30:12 <quicksilver> Axman6: yeah, compare [] _ = LT;
06:31:55 <jajamana> quicksilver: Great, so as long as compare is defined for [], > uses it..
06:33:19 <quicksilver> Baughn: what are you using?
06:33:43 <Baughn> quicksilver: Javascript haskell evaluator a teacher came up with. It is, so far, woefully incomplete.
06:33:53 <Saizan> i think you should be able to exploit Monoid Ordering here
06:33:53 <quicksilver> jajamana: yes, (>) is defined by default as a > b = (compare a b == LT), roughly
06:34:01 <Baughn> quicksilver: The actual error is "ENOINST Num a for Ord"
06:34:15 <osfameron> is there a javascript compiler backend to ghc yet?
06:34:19 <quicksilver> jajamana: although possibly the actual implementation is a slightly more efficient short circuit.
06:34:27 <Baughn> ..not sure why I was basing any statements on that thing, sorry
06:34:29 <quicksilver> osfameron: no, there is one for yhc/nhc
06:34:35 <osfameron> ah, shiny
06:34:45 <quicksilver> (it's not clear to be that GHC's backend is very JS suitable)
06:34:56 <osfameron> why's that?
06:35:09 <Baughn> It assumes it's compiling to a register machine, doesn't it?
06:35:13 <quicksilver> it has its own RTS, it's own GC, notions of STM, threads, ...
06:35:28 <osfameron> ghc seems to be the best "platform" at the moment?
06:35:33 <jajamana> quicksilver: makes sense, but would'nt laziness cause the shortcut to be taken anyway?
06:35:47 <quicksilver> jajamana: well it might waste time distinguishing between EQ and GT
06:35:56 <quicksilver> jajamana: when you don't care (for the purposes of calculating <)
06:36:01 <quicksilver> jajamana: admittedly, it wouldn't be very much time.
06:36:15 <quicksilver> osfameron: for the purposes of compiling to native code, certainly.
06:36:17 <osfameron> being able to interface seamlessly with the lingua franca of client side web stuff would be nice
06:36:33 <quicksilver> osfameron: for the purposes of a re-usable backend, nhc, yhc and ehc may be more suitable.
06:36:34 <jajamana> quicksilver: ok
06:39:07 <osfameron> quicksilver: but even they will eventually have their own notions of STM/etc. ?
06:39:41 <osfameron> quicksilver: would it make sense to compile a certain subset of haskell to javascript code, rather than targeting it in its generality?
06:40:17 <Saizan> maybe a DSL that generates javascript might make more sense
06:40:45 <quicksilver> there already is one.
06:40:50 <quicksilver> mmorrow wrote one.
06:41:05 <quicksilver> in fact, I think you can paly with it in lunabot
06:41:10 <quicksilver> but I don't remember how.
06:41:27 <quicksilver> osfameron: I don't know of any specific plans for nhc/yhc/ehc to target concurrence.
06:41:31 <quicksilver> concurrency is hard.
06:42:38 <malcolmw> quicksilver: the yhc runtime system has concurrent threading, on the same model as ghc, but implemented for a single processor only.
06:42:42 <osfameron> ah
06:43:13 <quicksilver> malcolmw: good to know.
06:56:55 <Axman6> quicksilver: i think it was ) <javascript>
06:57:14 <Axman6> ) XMLHttpRequest(test,something)
06:57:52 <EvilTerran> ] "wasn't it ]?"
06:58:08 <lunabot>  "wasn't it ]?"
06:58:22 <Axman6> maybeh it was
06:58:57 <Saizan> ] fix (1:)
06:59:00 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:59:14 <EvilTerran> ok, that's haskell again
06:59:29 <Axman6> if i knew any js, i'd try it...
06:59:32 <Axman6> ) 1+1
06:59:34 <Axman6> ) 1+1;
06:59:39 <Axman6> nope...
06:59:54 <Saizan> maybe it's not active anymore
07:00:37 <olahol> @bf +++++++++++.
07:00:37 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
07:00:46 <olahol> :(
07:02:23 * EmielRegis http://www.motifake.com/motivational_posters/d590ab324e.jpg
07:02:32 * EvilTerran would've expected @bf to be implemented in pure haskell by now
07:03:38 <PeakerWork> what's bf?
07:03:39 <olahol> didn't someone post several blog posts about it a while ago?
07:03:44 <EvilTerran> seems like it'd be a fairly trivial combination of StateT, ContT, and a zipper over a bidirectionally infinite list
07:03:47 <PeakerWork> oh, brainfuck
07:03:55 <geezusfreeek> it's been done a lot, no?
07:03:57 <geezusfreeek> i did it
07:04:12 <geezusfreeek> and i remember reading about somebody else's go at it
07:04:44 <EvilTerran> seems odd that lambdabot's trying to do IPC, then, rather than being linked to an interpreter module
07:05:14 <idnar> EvilTerran: what if the BF program is an infinite loop?
07:05:15 <Saizan_> mmh, there's a separate brainfuck.cabal with a "bf" executable
07:05:24 <PeakerWork> EvilTerran: seems odd that programs do IPC, instead of calling functions :-)
07:05:27 <Saizan_> that's called via the shell
07:05:46 <vincenz> @karma- EmielRegis
07:05:47 <lambdabot> EmielRegis's karma lowered to -1.
07:06:11 <EmielRegis> lmao
07:06:39 <EvilTerran> idnar, that can be dealt with the same way > can
07:07:02 <Saizan_> yeah, and > is dealt with in this same way :)
07:07:05 <EvilTerran> ahh
07:07:20 <EvilTerran> hell, for bf, you could just run a counter on the number of steps it's taken
07:07:28 <Saizan_> yeah
07:07:41 <Saizan_> it seems much simpler
07:31:30 <fasta> Where does the FFI Addendum say that Foo{a::Int, b::Int} corresponds to a C struct with as a first member an int and as second member an int?
07:31:51 <fasta> I am only talking about the order here.
07:32:37 <fasta> Or is that part of the C calling convention?
07:32:49 <fasta> I.e. ccall
07:50:55 <kenmcfa> Hi
07:51:31 <kenmcfa> I'm quite new to Haskell, and have an idea for a program, but no idea how to actually implement it
07:51:43 <kenmcfa> do you think you all could give me some advice for it?
07:52:08 <Feuerbach> kenmcfa: you can try
07:52:27 <kenmcfa> lol fair enough
07:52:32 <orbitz> learning haskell is probably step 1 :)
07:52:36 <orbitz> or step 0?
07:52:51 <kenmcfa> lol, I *think* I've learned haskell
07:52:51 <cygnus_> use recursion
07:52:59 <kenmcfa> I passed an exam in it the other day...
07:53:12 <kenmcfa> but yeah anyway, my wonderful program:
07:53:13 <orbitz> passing exams and learned can be differen tthings:)
07:53:22 <orbitz> i passed a biochem exam yesterday, although i'm not sure i know biochem :)
07:53:30 <cygnus_> ehe
07:53:33 <cygnus_> crammer
07:53:36 <orbitz> hah
07:53:43 <orbitz> there's a lot to it!
07:53:47 <kenmcfa> you give it a folder to work on, and it takes the metadata from all the music files in the folder
07:54:10 <orbitz> kenmcfa: RWH implements a 'find' program in haskell.  might be your first step
07:54:11 <kenmcfa> then from that, it extracts a list of albums
07:54:12 <cygnus_> my favorite stragey is a 24 hr non stop cram then pass exam just before passing out and forgetting everything i just learned forever
07:54:24 <kenmcfa> it uses the nub function, I know that much
07:54:31 <orbitz> cygnus_: that works well.  you have to time it perfectly though so you don't pass out in the middle of it and forget everythig
07:54:44 <cygnus_> yeah it's risky but i like danger
07:54:56 <orbitz> cygnus_: is danger your hyphenated middle name?
07:55:07 <orbitz> cygnus_ danger-francis lastname
07:55:09 <cygnus_> if i tell you i'd have to kill you
07:55:26 <kenmcfa> so you have a list with one entry for each album, then haskell retrieves the page http://en.wikipedia.org/wiki/Album_Name (With album_name being a variable)
07:55:27 <orbitz> my middle name is hyphenated too
07:55:42 <orbitz> orbitz safely-dangerous kermudgeen
07:55:59 <kenmcfa> then it drops everything before and after the album art image (I roughly know how to do that once I have the HTML....)
07:56:05 <kenmcfa> and downloads that picture
07:56:11 <kenmcfa> and sticks it in the folder
07:56:17 <kenmcfa> and then it recurses!
07:56:36 <kenmcfa> so I wind up with a picture for each folder, and probably one for the empty set as well
07:56:39 <orbitz> kenmcfa: start with rwh's find program probably
07:57:03 <kenmcfa> ok, I will
07:57:10 <kenmcfa> once you tell me what rwh is
07:57:16 <orbitz> kenmcfa: RWH also has a case study on bionary I/O, so you can read Id3
07:57:20 <orbitz> real world haskell
07:57:22 <Feuerbach> @faq Can Haskell solve kenmcfa's problem?
07:57:23 <lambdabot> The answer is: Yes! Haskell can do that.
07:57:37 <kenmcfa> ah, right
07:57:46 <kenmcfa> and hooray for lambdabot!
07:57:57 <C-Keen> @go rwh
07:57:58 <lambdabot> No Result Found.
07:58:06 <C-Keen> @go real world haskell
07:58:11 <lambdabot> http://www.realworldhaskell.org/
07:58:11 <lambdabot> Title: Real World Haskell
07:58:17 <cygnus_> @faq can haskell solve the halting problem?
07:58:17 <lambdabot> The answer is: Yes! Haskell can do that.
07:58:21 <cygnus_> lies
07:58:39 <C-Keen> @faq can lambdabot answer something different?
07:58:39 <lambdabot> The answer is: Yes! Haskell can do that.
07:58:40 <int-e> cygnus_: maybe you can do it with unsafePerformIO *ducks*
07:59:20 <kenmcfa> @faq can haskell solve the Arab-Israeli conflict problem?
07:59:21 <lambdabot> The answer is: Yes! Haskell can do that.
07:59:23 <kenmcfa> wow
07:59:34 <kenmcfa> why didn't tony blair think of that?
08:00:21 <cygnus_> he's english
08:00:22 <cajun-rat> Hindler-Miller type system's were too hard for him
08:00:50 <Beelsebob> typing the word Haskell was too hard for him
08:02:27 <cygnus_> i tried reading that famous type theory book but i couldn't understand it
08:03:46 <Megzlna> When I pass a for instance a list to a haskell function, am I getting a copy?
08:04:26 <Beelsebob> Megzlna: you don't need to care
08:04:35 <Megzlna> I do care.
08:04:38 <Beelsebob> why?
08:04:49 <Elly> why?
08:04:56 <Megzlna> Because I'm not you
08:04:58 <Beelsebob> (the implication of that btw was that it's implementation dependant)
08:05:02 <Megzlna> you == me
08:05:09 <PeakerWork> Megzlna: that is an implementation detail and may thus vary between implementations
08:05:20 <Megzlna> Ok, what does GHC do?
08:05:25 <Elly> Megzlna: independent of the identity relation or lack thereof, why do you care?
08:05:26 <PeakerWork> Megzlna: it passes a reference to the same list
08:05:47 <PeakerWork> Megzlna: since its immutable, there's no way for you to tell the difference
08:06:01 <ksf> the whole point of referential transparency is to prevent copying.
08:06:02 <Megzlna> So ghc is pretty much pass by reference everywhere?
08:06:09 <Beelsebob> no
08:06:11 <Beelsebob> it's pass by name
08:06:12 <PeakerWork> ksf: I wouldn't say its the "whole point" of it
08:06:24 <Beelsebob> lazy evaluation is made of win
08:06:52 <ksf> well, operationally. on top of that, of course it does'nt make sense to box an Int just to avoid copying it.
08:07:02 <dons> yaya. http://www.reddit.com/r/programming/comments/7icwa/timber_compiler_102_released_a_strict_pure/
08:07:57 * Elly wget
08:08:00 <Beelsebob> Megzlna: without lazy evaluation, we wouldn't be able to do this...
08:08:00 <Beelsebob> > take 5 [1..] -- note that take's second argument is infinitely large
08:08:02 <lambdabot>   [1,2,3,4,5]
08:08:24 <Megzlna> sure, but lists can have explicit values as well
08:08:48 <Saizan_> however yes, it's pass by reference in general
08:09:07 <Megzlna> what do you call a function that quasi mutates another value
08:09:14 <Megzlna> like  take 5 [1..]
08:09:17 <Elly> bah, I need to build bzlib
08:09:20 <Elly> Megzlna: a function
08:09:26 <Elly> Megzlna: there is no mutation there
08:09:36 <Elly> any more than f x = x + 1 mutates x
08:09:38 <Megzlna> Mutation in the form of a copy
08:09:39 <Beelsebob> there's never any mutation
08:09:56 <PeakerWork> Megzlna: due to laziness, pretty much every expression corresponds to thunks that evaluates its value. Those thunks are passed around as arguments.. The thunks may be equivalent to references to a result (if that is already available) or to an uncomputed-as-of-yet result
08:10:16 <ksf> there's no copy, even if the implementation chooses to mutate inplace.
08:10:24 <PeakerWork> Megzlna: it builds a new list from an existing list, its often called a "transformer" of values
08:10:26 <Megzlna> Does haskell ever return array slices?
08:10:37 <ksf> things just are. you're thinking to operational.
08:10:37 <PeakerWork> Megzlna: Arrays can do that, yes
08:10:40 <Megzlna> a "view" of a list
08:10:47 <Megzlna> Rather than a copy
08:10:48 <geezusfreeek> Megzlna: arrays and lists are different
08:10:59 <PeakerWork> @hoogle MArray
08:11:00 <lambdabot> module Data.Array.MArray
08:11:00 <lambdabot> Data.Array.Base class Monad m => MArray a e m
08:11:00 <lambdabot> Data.Array.MArray class Monad m => MArray a e m
08:11:01 <geezusfreeek> and yes, that is how arrays work afaik
08:11:16 <Beelsebob> Megzlna: yes, it's possible that functions return references to already created objects... id x = x will always do this for example
08:11:22 <PeakerWork> Megzlna: Haskell can describe mutable things too, like mutable arrays, and "views" into those
08:11:28 <Megzlna> ksf: No, I'm thinking these are questions that must be learned at some point to not be a total clueless newbie?
08:12:09 <Beelsebob> Megzlna: I wouldn't ask them in terms of another language -- the important thing to remember is that Haskell's behavior is not described operationally
08:12:09 <Elly> dons: I am intrigued by your ideas, and would like to subscribe to your newsletter
08:12:11 <ksf> nope. you don't have to care how the implementation works, the semantics are fixed across mere bare metal details.
08:12:14 <Saizan_> however many lists (or other structures) are actually never constructed, thanks to fusion/deforestation
08:12:17 <geezusfreeek> Megzlna: these are things that you can pick up on more easily after you learn haskell's semantics
08:12:22 <Beelsebob> there are many operational implementations that implement haskell's behavior
08:12:49 <Megzlna> ksf: I don't care. I want to know. I'm asking PeakerWork a question now, and he knows. Maybe he shouldn't know?
08:12:52 <Megzlna> PeakerWork: what would slice a list?
08:13:04 <Megzlna> in GHC
08:13:07 <Megzlna> and make no copy
08:13:13 <geezusfreeek> you don't "slice" lists
08:13:18 <geezusfreeek> they are linked lists
08:13:20 <Saizan_> > tails [1..10]
08:13:21 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
08:13:25 <geezusfreeek> how would you do that in C?
08:13:29 <Saizan_> that makes no copies ^^^
08:13:29 <Megzlna> You do slice linked lists
08:13:43 <Megzlna> you just return a pointer to some element
08:13:44 <ksf> actually, haskell lists are more like continuations.
08:13:46 <Saizan_> Megzlna: haskell lists can share the tails
08:13:48 <geezusfreeek> what would a slice of a linked list look like?
08:13:49 <ksf> they're a monad, after all.
08:14:15 <Megzlna> geezusfreek: 2 pointers
08:14:18 <Saizan_> > init [1..10] -- this constructs new cons cells
08:14:19 <lambdabot>   [1,2,3,4,5,6,7,8,9]
08:14:31 <geezusfreeek> to what? the head and the tail?
08:15:14 <Saizan_> you don't have access to the tail of a list directly, you've to traverse all the nodes to get there
08:15:18 <Megzlna> Saizan: Why only the tail?
08:15:19 <Baughn> Would anything break if I altered the Rational Read instance to allow decimal notation?
08:15:23 <Elly> dons: the setup script asserts that 'base >= 4' is missing; do you happen to know what package that is in portage?
08:15:36 <Baughn> Elly: That's ghc 6.10, basically
08:15:38 <Megzlna> "why only the tail re:"
08:15:42 <Megzlna> <Saizan_> Megzlna: haskell lists can share the tails
08:15:57 <Saizan_> Megzlna: see my last sentence
08:16:05 <Elly> Baughn: oh :(
08:16:05 <ksf> haskell can do everything if you make the compiler smart enough...
08:16:14 <orbitz> Megzlna: because a linked list starts ata certain place and goes until the end, so [1, 2, 3], and [2, 3] can share teh [2, 3]
08:16:17 <Megzlna> Saizan: But that seems the opposite.
08:16:21 <geezusfreeek> Megzlna: let x = [a,b,c,d] in (e:x, f:x) -- both e:x and f:x share the same tail in memory (in ghc)
08:16:31 <Megzlna> Saizan: I'd think you'd say : haskell lists CANT share the tails
08:16:46 <Baughn> Elly: Try installing an earlier version of the package. You can say "cabal install foo-3.14.42" to get a particular version.
08:16:51 <orbitz> Megzlna: why?
08:16:54 <Saizan_> Megzlna: why? see geezusfreeek example
08:17:05 <Baughn> Elly: You may need to do the same for dependencies. I'm sure someone will write proper dependency resolution code eventually.
08:17:09 <orbitz> Megzlna: since the lists contents are immutable, you can share as much as you awnt
08:17:15 <Megzlna> well I see it now, since you cant know the tail, in order to share, you must know the tail
08:17:17 <PeakerWork> Megzlna: drop/splitAt will "slice" the beginning of a list
08:17:23 <Megzlna> ie, a non infinite list
08:17:26 <PeakerWork> @type drop
08:17:28 <lambdabot> forall a. Int -> [a] -> [a]
08:17:29 <geezusfreeek> huh?
08:17:30 <PeakerWork> @type splitAt
08:17:32 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:17:37 <Elly> Baughn: that doesn't help much when portage installs 6.8.2 :(
08:17:47 <Elly> is there an overlay with newer ghcs?
08:17:47 <Saizan_> Megzlna: you just share the pointer to the tail, which can be already evaluated or a thunk
08:17:54 <geezusfreeek> Megzlna: let x = [1..] in (0:x, 1:x) works fine
08:18:07 <ksf> Elly, layman -a haskell
08:18:25 <geezusfreeek> > let x = [1..] in (take 5 $ 0:x, take 5 $ 1:x)
08:18:26 <lambdabot>   ([0,1,2,3,4],[1,1,2,3,4])
08:18:28 <Elly> ksf: sweet!
08:18:30 <Megzlna> I'd like to find a description of all of GHC's optimizations
08:18:36 <Baughn> Elly: As I was saying, it would help. ghc-10 isn't that old; there should be packages for 6.8 in hackage for you to get. You just have to figure out which manually.
08:18:36 <Megzlna> regarding copying
08:18:44 <ksf> non-bootstrap build is broken on amd64, though.
08:18:45 <Baughn> Elly: But installing 6.10 is of course best. :)
08:18:46 <geezusfreeek> there is no copying
08:18:54 <ksf> nobody committed a binary to bootstrap with.
08:19:00 <ksf> but you're fine if you got a ghc around.
08:19:03 <Saizan_> Megzlna: there are various relevant papers, mainly from SPJ
08:19:14 <Elly> ksf: I have a ghc, but it's 6.8.2
08:19:18 <kenmcfa> hmm, actually can you give me some impartial advice?
08:19:21 <Elly> I will install one from the overlay
08:19:23 <Megzlna> geezusfreek: How could there not be?
08:19:27 <Baughn> Elly: Anything from, I think, 6.4 up will do for bootstrapping
08:19:29 <orbitz> kenmcfa: i only give partial advice
08:19:32 <geezusfreeek> Megzlna: why does there have to be?
08:19:38 <kenmcfa> am I better doing this project in Haskell or Java?
08:19:39 <ksf> iirc ghc 6.10 needs at least 6.4 to compile.
08:19:46 <Megzlna> <geezusfreeek> there is no copying
08:19:49 <Elly> O_o oh dear...
08:19:55 <geezusfreeek> can you think of an example that requires copying?
08:19:59 <orbitz> kenmcfa: should we be aware of your skill level?
08:20:00 <Baughn> Elly: You have 6.8. No "oh dear".
08:20:06 <Elly> Baughn: no, unrelated 'oh dear'
08:20:20 <kenmcfa> early university, I've just passed a course in functional programming
08:20:21 <Elly> adding the ghc overlay introduces a conflict which portage can't resolve between versions of gcc
08:20:23 <Baughn> Elly: Oh dear
08:20:33 <kenmcfa> but I have no idea whay a monad is, for example
08:20:34 <cygnus_> is ghc implemented in C
08:20:37 <kenmcfa> *what
08:20:41 <geezusfreeek> cygnus_: haskell :)
08:20:43 <silentbob> kenmcfa - confident that you've passed then....
08:20:45 <orbitz> kenmcfa: if your goal is to learn haskell better, than do it in haskell.  if yoru goal is to just write a program, do it in whatever you are comfortable in
08:20:48 <Baughn> cygnus_: Mix. Some C, mostly haskell, some assembly, a tad of perl.
08:20:53 <Saizan_> Megzlna: this describes the evaluation model of GHC http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:21:00 <orbitz> kenmcfa: and here i thought you 'learned haskell' :)
08:21:04 <kenmcfa> I've done java in high school, and I'm doing more next semester
08:21:09 <Megzlna> If you replace all elements of 5 with 10, and you keep applying transformations on top of that, it would be like a VERSION CONTROL system to compute the final value at runtime
08:21:12 <Megzlna> Which would be slow
08:21:21 <Megzlna> so you'd have to have copies at some point
08:21:26 <geezusfreeek> Megzlna: i recommend the link that Saizan_ pasted
08:21:34 <kenmcfa> and yeah silentbob, that was an easy exam
08:21:36 <Saizan_> Megzlna: you don't replace those 5 with 10 in place
08:21:41 <ksf> Megzlna, nope, you just strictify the whole thing.
08:21:45 <geezusfreeek> there is no mutation
08:21:49 <Elly> I am about to regret this
08:22:00 <kenmcfa> I dunno which I'd prefer
08:22:04 <Baughn> Elly: Alternately, you can compile ghc yourself
08:22:05 <Saizan_> Megzlna: but, e.g. for lists, you create new cons cells that contain 10 instead of 5
08:22:13 <Megzlna> cons?
08:22:17 <Baughn> Elly: Or, perhaps smarter, edit the overlay to remove the gcc requirement
08:22:21 <kenmcfa> maybe I'll start doing it in both, and that will take up all my time
08:22:24 <Baughn> Elly: It's probably mistaken. Probably.
08:22:25 <Saizan_> Megzlna: the node in the linked list
08:22:32 <Elly> Baughn: probably :P
08:22:33 <kenmcfa> and then I'll realise I have exams next week....
08:22:39 <byorgey> kenmcfa: what's the project?
08:22:45 <Elly> if I switch to gcc 4.3.2, I will probably regret it though
08:22:57 <Megzlna> saizan: how can that avoid needing to splice together a new list?
08:22:58 <Elly> I just removed pcsx2; let's see if that helped (it wanted 4.3.1-r1)
08:22:59 <Saizan_> Megzlna: and you've to create new nodes also for all the elements before that node, since you must make them point to it
08:23:12 <kenmcfa> extract album names from all the mp3s in a folder, and download album art from wikipedia
08:23:15 <Megzlna> You cant just use a bunch of alternative Cons with an arbitrary other linked list
08:23:19 <Saizan_> Megzlna: but nodes after that can remain the same
08:23:37 <ksf> Elly, i've got gcc 4.2.4 and ghc 6.10, you're doing something wrong.
08:23:40 <Saizan_> Megzlna: it becomes like a graph
08:24:01 <Elly> ksf: by 'you' you mean 'portage'
08:24:09 <Megzlna> Saizan: like a graph!
08:24:15 <Megzlna> Let me be a little literal
08:24:27 <ksf> elly, portage 2?
08:24:33 <Saizan_> Megzlna: like an Y, where you've two heads but only one end
08:24:40 <ksf> I'm using 2.2_rc12, actually.
08:24:50 <kenmcfa> hmm, maybe I'll spend time thinking and planning this more
08:24:53 <Saizan_> that's why i said haskell lists can only share tails
08:24:55 <kenmcfa> then decide on a language
08:25:18 * Elly removes the broken pcsx2 overlay
08:25:37 <orbitz> kenmcfa: at this point i would suggest doing it in a language you don't nkow well so you don't get stuck in a rut
08:25:43 <Megzlna> a->b->c->d->e->f->g->h  is in memory somewhere ... a function returns a modified form of the list as    a->B->c->D->e->F   ... how can it do this unless 'a' actually stores 2 different pointers, and some means of knowing which pointer is which, which requires more storage
08:25:58 <lilac> ?users
08:25:59 <lambdabot> Maximum users seen in #haskell: 583, currently: 549 (94.2%), active: 28 (5.1%)
08:26:02 <Baughn> Megzlna: It would not. Only the "a" cell can be shared in that list.
08:26:18 <Megzlna> Baughn: well thats not what ppl told me a min ago :P
08:26:22 <orbitz> Baughn: how can "a' be shared?
08:26:27 <Megzlna> "there is no copying"
08:26:28 <Baughn> Megzlna: However, appropriate use of fusion/strictness can make sure there's no more than one copy even if you alter the list multiple times
08:26:31 <ksf> Megzlna, that function would return a mangled list, which doesn't mean that the values the list references can't be shared.
08:26:37 <Baughn> orbitz: Er..
08:26:54 <Baughn> Megzlna: Actually, orbitz is right. Only the /tail/ can be shared, not the head. Of course. >_<
08:26:59 <Baughn> I should probably stop trying to help today.
08:27:03 <orbitz> hehe
08:27:15 <lilac> Megzlna: there is no copying; everything is stored by reference not by value.
08:27:25 <ksf> ...actually, the head can be shared as it's not a list but only a value, but i'm splitting hairs. let's move on.
08:27:31 <orbitz> lilac: perhaps Megzlna is confusing a list with the values it referenceS?
08:27:33 * lilac introduces an exception for strict members
08:27:44 <Megzlna> B is a new value
08:27:49 <Megzlna> b was the original
08:27:56 <geezusfreeek> yeah, in the presence of strictness we may include the value in with the tag, but that is different
08:28:02 <orbitz> i think Megzlna wants to do inplace modification of the list, like you would with a java collection
08:28:13 <Saizan_> Megzlna: let me refrase that to Cons1 a (Cons2 b (Cons3 c Nil) which gets modified to Cons4 a (Cons5 B (Cons6 c Nil)), then, in memory, you've that only Cons3 is the same as Cons6, instead Cons4 and Cons5 are newly allocated nodes
08:28:38 <lilac> Megzlna: [a,b,c] is (a: (b: (c:[]))), [a,B,c] is (a: (B: (c:[]))). the (c:[]) can be shared, as can a
08:28:54 <Saizan_> Megzlna: and you only pay the memory cost of two Cons, since a is stored by reference in the Cons
08:29:12 <Megzlna> But those are values... you're saying that the overhead of the value copy isnt there
08:29:19 <geezusfreeek> Megzlna: if you don't want to read the STG paper, at least read http://en.wikibooks.org/wiki/Haskell/Graph_reduction
08:29:22 <Megzlna> I'm talking about overhead of the linked list structure
08:29:40 <Megzlna> Since it can't be intrusive
08:29:41 <Saizan_> Megzlna: Cons is the linked list structure
08:29:50 <Megzlna> What? Intrusive?
08:29:55 <geezusfreeek> actually that seems very incomplete, n/m
08:30:03 <lilac> Megzlna: each cons cell is two pointers.
08:30:29 <lilac> (actually, slightly more than that since it needs to distinguish itself from [])
08:30:31 <Megzlna> so the List of cons will always copy, right? Just not the data...
08:30:47 <Megzlna> Intrusive lists are where the value has a pointer packed in it
08:30:51 <polveroj> Megzlna: it helps if you realize that list operations aren't really primitive.  The primitives are pattern matching (which takes apart values) and type constructors (in this case ":") that build values.
08:30:53 <geezusfreeek> reconstruct. there is never a need for a straight up copy
08:30:58 <Megzlna> But for sharing you cant use intrusive
08:30:59 <lilac> Megzlna: ok, another way of saying it is that only pointers are ever copied.
08:31:05 <Megzlna> intrusive has ownership
08:31:07 <orbitz> Megzlna: a new cons cell will be created
08:31:08 <geezusfreeek> what is this "intrusive"?
08:31:16 <geezusfreeek> did i miss some definition?
08:31:21 <lilac> Megzlna: but they're copied into new immutable places
08:31:25 <orbitz> 11:30 < Megzlna> Intrusive lists are where the value has a pointer packed in it
08:31:25 <Saizan_> no, they are not instrusive, it's the list which has pointers to values and the next node
08:31:28 <polveroj> Megzlna: you can look at the definition of the function and see how many constructor uses it has to know whether it uses new memory
08:31:33 <geezusfreeek> ah
08:31:54 <ksf> we should stop calling thunks references, btw.
08:32:25 <Megzlna> I'm a little confused now...  is it intrusive or not?
08:32:34 <Megzlna> Only the list has the structure
08:32:36 <Megzlna> not the values
08:32:37 <Megzlna> right?
08:32:40 <Saizan_> right
08:32:54 <Saizan_> the values aren't altered by being in a list
08:33:11 <Megzlna> So:  a->B->c->D->e->F   requires a new structure of 5 pointers, right?
08:33:12 <ksf> in imperative terms, a haskell list is made out of nodes which save two 0-argument closures, one for the value and one for the rest of the list.
08:33:13 <Megzlna> 5 copies
08:33:13 <Saizan_> and the nodes of a list are never modified
08:33:31 <geezusfreeek> a:b:c:d:e:f:[]
08:33:33 <Megzlna> 5 copies, but 3 references are retained
08:33:39 <Megzlna> to the original 3 cons
08:33:49 <Saizan_> Megzlna: no
08:33:53 <Megzlna> s/copies/new pointers/
08:33:54 <geezusfreeek> wait, what is the distinction between lowercase and uppercase?
08:33:59 <lilac> Megzlna: in that case, 6 new cons cells would be created
08:34:02 <Baughn> Megzlna: Five new list nodes. If it were "a->B->c->d->e->f", then only two new list nodes would be needed
08:34:03 <Saizan_> that has to change all the structure, since you've changed F
08:34:05 <Megzlna> YES OK!
08:34:08 <Megzlna> new Cons cells!
08:34:09 <ksf> lowercase UPPERCASE <- about that one.
08:34:25 <daf> geezusfreeek: old/new
08:34:27 <Baughn> geezusfreeek: The original list was all lowercase
08:34:28 <Megzlna> Baughn: I dont see how thats possible
08:34:29 <geezusfreeek> Megzlna: new cons cells == new pointers, not copies
08:34:36 <Megzlna> and Baughn just disagreed with lilac
08:34:48 <lilac> Megzlna: new cons cells containing copies of pointers to existing stuff
08:34:49 <ksf> THERE ARE NO FREAKING REFERENCES OR POINTERS
08:34:54 <mlesniak> @seen dons
08:34:54 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 27m 52s ago.
08:34:59 <Megzlna> geezusfreak: see my s/
08:35:02 <Baughn> Megzlna: The node that contains the pointer to B (value reference) can use the c node of the original list as a rest-of-list reference
08:35:11 <geezusfreeek> Megzlna: baughn redefined the problem a bit i think
08:35:11 <Baughn> Megzlna: Whether it will depends on your code and the optimizer. A naive map won't.
08:35:23 <Megzlna> what is there to redefine ?
08:35:36 <orbitz> lilac: Megzlna is asking about the cons cells, he wnats them to be modified in place
08:35:45 <Baughn> Megzlna: "a->B->c->d->e->f", when only the second value is altered
08:35:50 <Megzlna> a->B->c->D->e->F    // 6 new pointers (Cons) and 3 new values, 3 references to previous values
08:35:51 <ksf> there are only thunks, which are basically 0-argument closures.
08:35:54 <Megzlna> Who disagrees?
08:36:03 <lilac> orbitz: i get that.
08:36:11 <Saizan_> Megzlna: that's right
08:36:32 <Megzlna> Ok :)
08:36:35 <Saizan_> Megzlna: but the important part is when you've a -> B -> c -> d -> e -> f
08:36:41 <lilac> Megzlna: i think ksf disagrees; that's not quite how the implementation works due to laziness, but i think it's close enough
08:36:53 <Megzlna> Saizan: When you've  'f' there's no new pointers?
08:37:02 <Megzlna> except 1?
08:37:03 <Megzlna> Ah
08:37:07 <Megzlna> it splices!
08:37:10 <Saizan_> no
08:37:10 <Megzlna> into the previous list
08:37:26 <ksf> the part behind a -> B might not even yet exist due to laziness.
08:37:28 <Megzlna> 1 new pointer, connecting to the tail end of the previous list
08:37:33 <orbitz> in Saizan_ last example i beelieve you will have 2 new cons cells
08:37:37 <ksf> so how could you copy it?
08:37:48 <Megzlna> yeah 1 new pointer to B, 1 new pointer to the previous list
08:37:53 <Baughn> Megzlna: Yes. It can do that without altering any memory.
08:38:01 <Saizan_> Megzlna: the part in the square brackets is made of new pointers: [a -> B ->] c -> d -> e -> f
08:38:01 <Baughn> Megzlna: As I said, that doesn't mean it /will/. That depends on your code.
08:38:07 <Saizan_> Megzlna: the rest is the same.
08:38:11 <Megzlna> Saizan_: Yes
08:38:12 <quicksilver> ksf: I don't think that's particularly helpful. It might not exist, but it certainly might exist, if you scanned it. And there certainly are pointeres, in a real implementation.
08:38:50 <BMeph> nick BMeph|away
08:38:50 <lambdabot> BMeph: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:39:02 <Megzlna> It makes sense now. Any other exceptions?
08:39:22 <Saizan_> that's not the exception
08:39:24 <Saizan_> it's the rule
08:39:32 <Saizan_> it's valid for any datatype you define
08:39:54 <Megzlna> well an exception might Be
08:39:58 <ksf> there may be pointers, and there may be not because of strictness analysing... that's why it's kinda pointless to discuss haskell on the bare metal level.
08:40:00 <Megzlna> infinite / lazy lists
08:40:05 <Megzlna> which I dont see how that plays in here
08:40:16 <Baughn> Megzlna: They work the exact same way
08:40:23 <geezusfreeek> that confusion stems from using the word "reference" instead of "thunk"
08:40:39 <geezusfreeek> replace reference with thunk and you have a better understanding that also explains infinite lists
08:40:46 <Saizan_> Megzlna: the pointer to the rest of the list points to a closure instead of a value
08:40:52 <Baughn> Megzlna: Any function that alters a list only really sees a tiny slice of the list at a time anyway
08:41:16 <Megzlna> so the "infinite" part of the list is just a Cons
08:41:27 <geezusfreeek> it's pointed to by a cons
08:41:28 <Baughn> Maybe
08:41:30 <lilac> Megzlna: there are (at least) two different sorts of infinite lists: the kind which require finite memory (where you can reach a cons cell from itself) which can be constructed in a strict language
08:41:57 <Baughn> ..what he said. Alternately, it could be infinite through producing more list lazily whenever you ask for more
08:41:58 <lilac> ... and the kind which require infinite memory, where the tail of one of your lists is a thunk for an as-yet-uncomputed value
08:42:01 <geezusfreeek> cyclic and acyclic, that is
08:42:07 <ksf> ...and thingies working akin to python's generators.
08:42:11 <geezusfreeek> and thunked
08:42:15 <geezusfreeek> and so on
08:42:24 <ksf> ...which work through thunks.
08:42:37 <geezusfreeek> yeah that
08:43:10 <ksf> the important point to grok as a newbee is that everything in haskell is a "generator".
08:43:47 <quicksilver> ksf: I disagree, it's not pointless at all.
08:44:03 <quicksilver> It's very interesting to understand how the semantics of a haskell compiler work, neglecting laziness.
08:44:09 <Megzlna> [0..]  // 1 single cons... pointing to what? a function?
08:44:15 <ksf> well, at least it's not much help for newbees if you go below core level.
08:44:15 <quicksilver> It is, also, interesting to discuss laziness, true.
08:44:36 <Megzlna> My definition of closure has been more restrictive
08:44:51 <Megzlna> ie, closing of upvalues into lambdas
08:45:09 <quicksilver> haskell values are either actually (part of) a value in memory
08:45:10 <ksf> that's what [1..] is.
08:45:12 <lilac> Megzlna: [0..] expands to 'enumFrom 0' and stays that way until someone wants the first value
08:45:13 <quicksilver> or they are pointers to a function
08:45:19 <quicksilver> which, when called, produces a value.
08:45:27 <cygnus_> if you read the ghc implementation of haskell is it a good way to understand haskell
08:45:28 <Megzlna> > enumFrom 0
08:45:30 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:45:33 <lilac> Megzlna: when someone wants the first value, it's evaluated to 0:enumFrom (0+1)
08:45:47 <quicksilver> so if "a" is an Int, then "a" in memory, is either an Int value, or a pointer to a function which returns an Int.
08:45:56 <lilac> Megzlna: when someone wants to know what comes next, it's evaluated to 0:0+1:enumFrom ((0+1)+1)
08:45:59 <pejo> I find that for me it's really hard to understand laziness. I'm not sure how helpful it is to think about it if we're talking about a "true" newbie.
08:46:00 <Megzlna> How do you put other arbitrary continuation functions into a list?
08:46:11 <ksf> and enumFrom 0 expands to 0:enumFrom 1, enumFrom 1 expands to 1:enumFrom2, etc so you get 0:1:2... which is [0,1,2,...]
08:46:11 <lilac> Megzlna: you just write them as normal functions
08:46:13 <Baughn> lilac: Not quite. The (0+1) thunk will have been forced by the second enumFrom invocation
08:46:21 <Megzlna> lilac: Yeah but
08:46:26 <Megzlna> implementation wise
08:46:26 <lilac> Baughn: is there a strictness annotation there?
08:46:46 <geezusfreeek> it depends on the value type, i think
08:46:47 <quicksilver> Megzlna: the implementation is that everything is (possibly) a function.
08:46:52 <Baughn> lilac: It's required to produce the 1 you're returning
08:46:55 <Megzlna> the function is static code, and Cons has a NON VALUE tag, and points to my static func
08:46:57 <Megzlna> ?
08:47:05 <quicksilver> Megzlna: every value is either some concrete data stored in memory, or a pointer to a function
08:47:13 <quicksilver> Megzlna: roughly, yes.
08:47:17 <Baughn> lilac: Of course, that 1 would more likely be a thunk itself, but you didn't print it like that. ;)
08:47:18 <orbitz> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in take 20 fibs
08:47:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
08:47:25 <orbitz> Megzlna: how's that for awesomenss?
08:47:26 <Megzlna> Is there an overhead of everly Cons storing Value/Func tag?
08:47:32 <Megzlna> lol everly
08:47:40 <quicksilver> Megzlna: when the code gets executed it replacing the pointer with actual value
08:47:42 <ksf> orbitz, he knows that stuff, he's ezla.
08:47:48 <lilac> Baughn: i'm not returning a 1 yet
08:47:58 <orbitz> ksf: i don't know who ezla is
08:48:04 <quicksilver> Megzlna: in principle yes, there is an overhead.
08:48:04 <Baughn> lilac: "0:1:enumFrom ..."
08:48:12 <quicksilver> Megzlna: there are some quite clever ways to implement it, though
08:48:19 <quicksilver> which I am not qualified to explain in detail.
08:48:19 <lilac> Baughn: i never wrote that :)
08:48:20 <Megzlna> quicksilver: how
08:48:25 <quicksilver> read the STG paper
08:48:26 <Megzlna> oh ;/
08:48:29 <quicksilver> if you're interested ;)
08:48:42 <Baughn> lilac: Hm. So you didn't. You're missing a fromEnum, though. ^^;
08:48:53 <Baughn> lilac: ...right, time for me to go.
08:49:08 <lilac> Baughn: what, so i'm expected to explain typelcasses and laziness at the same time? ;-)
08:49:19 <Baughn> lilac: They do all intertwine
08:49:22 <pejo> quicksilver, and the pointer tagging one too.
08:49:39 <quicksilver> pejo: yes, although merely to get an idea how it might work, you don't need to be up to date
08:49:50 <ksf> laziness is not doing your homework until you notice the teacher is checking whether or not you did it.
08:49:51 <quicksilver> pejo: AFAIK there is no paper (or set of papers) which actually described what GHC really does, now.
08:49:53 <Baughn> lilac: I get the feeling we really need a blackboard for this, though. ;P
08:49:56 <quicksilver> pejo: only bits and pieces of it.
08:50:00 <lilac> Baughn: quite possibly :)
08:50:10 <fasta> What's the corresponding C struct for data MyList = MyNil | MyCons Int MyList? Or in general, how are disjoint unions with recursion mapped to C structs?
08:50:14 <Baughn> ksf: Thus why Haskell is not well suited for realtime systems
08:50:43 <geezusfreeek> Baughn: surely if you are particular about where you use strictness and laziness haskell would be fine for real time, no?
08:51:21 <Baughn> geezusfreeek: I'm pretty sure analyzing that time usage is still an unsolved problem. I'd /like/ it to be fine, but I sure can'T recommend it for hard realtime.
08:51:22 <EvilTerran> fasta, well, sum types are usually represented with a tagged union, i believe; not sure about the syntax for recursive types, though, i haven't done C for ages
08:52:12 <yav1> fasta: recursion is done witha pointer
08:52:29 <Lemmih> fasta: union MyList { struct MyNil; struct MyCons; }; struct MyNil { int tag; }; struct MyCons { int tag; int head; struct MyList *next; } ?
08:53:08 <Baughn> geezusfreeek: But the main problem is, well, what ksf said. You have to be careful to force things ahead of time, or they won't be ready when you actually need them.
08:53:09 <ksf> actually, MyNil is (void*)0
08:53:22 <fasta> Lemmih: right, thanks!
08:53:29 <yav1> yeah, for lists people do not usually use tags
08:53:59 <quicksilver> Baughn: I don't think laziness is much of a problem for realtime, although it's certainly a demand on the programmer.
08:54:11 <quicksilver> EvilTerran: although the 'T' in STG stands for 'tagless'
08:54:14 <EvilTerran> the general translation from ADTs to C involves tagged unions and whatnot, but a lot of common cases will be easier
08:54:20 <quicksilver> Baughn: GC is the problem for realtime.
08:54:33 <quicksilver> EvilTerran: oh, sorry, I misunderstoof the context.
08:54:33 <Baughn> quicksilver: Hasn't incremental GC pretty much solved that one?
08:54:35 <ksf> quicksilver, i think he meant c.
08:54:38 <ksf> not ghc.
08:55:00 <yav1> quicksliver:  lazyness makes it hard to reason locally about the amount of time a function will take to execute (because it may be passed a thunk that requires and arb. amount of time to evaluate)
08:55:18 <quicksilver> yav1: true, but impurity makes it hard to reason locally about ANYTHING AT ALL
08:55:20 <quicksilver> yav1:  ;)
08:55:25 <Megzlna> thanks re: lists
08:55:34 <yav1> there's that :)
08:56:04 <Baughn> geezusfreeek: It's not a huge problem. Haskell seems to be fine for some soft realtime systems - games, say. Nuclear reactors? Not so much.
08:56:17 <quicksilver> Baughn: there certainly exist progress towards solutions. I was speaking more practically than theoretically though, since haskell is one of the very few practical lazy languages.
08:56:33 <quicksilver> Baughn: and practically, the GHC GC could use some help to be realtime.
08:56:56 <quicksilver> although if you understand your space usage well and call performGC and predictable times you can do pretty well.
08:57:21 <Baughn> quicksilver: I call performGC at the end of every frame, just after glFlush. Seems to work fine. :)
08:57:22 <dons> ?users
08:57:22 <lambdabot> Maximum users seen in #haskell: 583, currently: 550 (94.3%), active: 29 (5.3%)
08:57:47 <quicksilver> Baughn: glFlush? the 80s called, they want your programs back?
08:58:13 <ksf> Baughn, guess what I used to call on j2me after each frame ;)
08:58:29 <Baughn> quicksilver: It makes sense, when you /know/ you only update a tiny part of the screen every frame. Otherwise I'd use triple buffering. :P
08:58:40 <byorgey> @remember quicksilver Baughn: glFlush? the 80s called, they want your programs back?
08:58:41 <lambdabot> Done.
08:58:48 <dons> this is worth a read if you've not seen it, http://www.reddit.com/r/programming/comments/7idce/on_haskell_intuition_and_expressive_power/
08:59:12 <Baughn> quicksilver: It'd be nice to have some indication of the state of the heap, though. No point in GCing if the GC would otherwise only get called every ten frames, which seems to be the case so far
08:59:32 <quicksilver> Baughn: I strongly suspect drawing direct to the front buffer is so much slower on most cards than drawing to the back buffer than the speedup from incremental drawing is minimal.
08:59:37 <quicksilver> Baughn: I'm not sure though.
09:00:09 <Baughn> quicksilver: Hm. Perhaps. Oh well; glFlush is easy, and it's not like twelve quads are going to be a performance problem either way.
09:01:44 <ksf> ideally, the gc should never need to collect anything as your program runs in constant space.
09:02:54 <ksf> game programmers don't malloc.
09:03:22 <Baughn> Well, no.. they use incremental GCs instead. ^_^
09:03:38 <mlesniak> Anyone knows if cabal install keeps the source of the downloaded packages? I've found nothing in .cabal/
09:03:48 <Baughn> mlesniak: ~/.cabal, actually
09:03:58 <mlesniak> Baughn: Hmpf, seeking again, thanks :)
09:04:07 <Baughn> mlesniak: ~/.cabal/packages/
09:04:15 <dcoutts> mlesniak: under packages, that's where the tarballs are downloaded to
09:04:16 <ksf> I once even wrote a clone factory in java to prevent memory to be alloced.
09:04:35 <mlesniak> thanks, did not see that hackage... is a directory_ D'oh!
09:04:44 <quicksilver> ksf: haskell programs which run in constant space still use the GC, all the time.
09:04:46 <ksf> ...especially 'cos there are mobile who use buggy refcounting and leak memory.
09:05:23 <Baughn> ksf: Except when they don't
09:05:35 <ksf> quicksilver, you're destroying my dreams about a perfect strictifier.
09:07:41 <quicksilver> ksf: I'm not intending to destroy dreams, I'm intending to talk about now.
09:07:51 <quicksilver> ksf: although there is more to what you're asking for than just a strictifier.
09:08:04 <quicksilver> ksf: in-place modification of ADTs would be an entirely new feature.
09:08:31 <soa2ii> Hi there. Might somebody help me out here?
09:08:32 <soa2ii> http://rafb.net/p/qruZaE44.html
09:09:11 <soa2ii> code starts at line 14
09:09:30 <quicksilver> soa2ii: typo in 'ScanCommet'; typo in 'isLinebreak'
09:10:39 <soa2ii> quicksilver: silly me
09:10:44 <cnwdup> Is there a function in the standard libs which takes two lists and joins them into one with their elements taking turn from list a to list b? So func [1,3] [2,4] would become [1,2,3,4].
09:11:18 <quicksilver> cnwdup: concat . transpose
09:11:24 <cnwdup> quicksilver: thanks
09:11:32 <quicksilver> > concat . tranpose $ [[1,3],[2,4]]
09:11:34 <lambdabot>   Not in scope: `tranpose'
09:11:38 <quicksilver> > concat . transpose $ [[1,3],[2,4]]
09:11:40 <lambdabot>   [1,2,3,4]
09:11:43 <quicksilver> speling hepls
09:11:51 <cnwdup> ( ;
09:11:55 <orbitz> > transpose [[1, 3], [2, 3]]
09:11:57 <lambdabot>   [[1,2],[3,3]]
09:12:04 <orbitz> > transpose [[1, 3], [2, 4]]
09:12:05 <lambdabot>   [[1,2],[3,4]]
09:12:09 <orbitz> cool
09:12:17 <idnar> @type transpose
09:12:18 <lambdabot> forall a. [[a]] -> [[a]]
09:12:30 <Deewiant> > concat $ zipWith (\a b -> [a,b]) [1,3] [2,4]
09:12:32 <lambdabot>   [1,2,3,4]
09:12:52 <conal> > concat $ zipWith (\a b -> [a,b]) [1,3] [2,4,5]
09:12:53 <lambdabot>   [1,2,3,4]
09:13:01 <lilac> > transpose [[1,2,3], [4,5], [6]]
09:13:03 <lambdabot>   [[1,4,6],[2,5],[3]]
09:13:17 <lilac> > transpose [[1],[2,3],[4,5,6]]
09:13:19 <lambdabot>   [[1,2,4],[3,5],[6]]
09:13:22 <idnar> hmm
09:13:39 <idnar> could you do that with ZipList or something?
09:13:46 <orbitz> > concat $ zipWith ((:[] .). (:) [1, 3], [2, 4]
09:13:47 <lambdabot>   <no location info>: parse error on input `)'
09:13:50 <orbitz> > concat $ zipWith ((:[] .). (:) [1, 3] [2, 4]
09:13:51 <lambdabot>   <no location info>: parse error on input `)'
09:13:59 <orbitz> > concat $ zipWith ((:[] .). (:)) [1, 3] [2, 4]
09:14:00 <lambdabot>   <no location info>: parse error on input `)'
09:14:12 <quicksilver> conal: I still don't have a solution I'm entirely happy with for recursable snapshotWith, but interestingly I think I can write the case I need without recursion.
09:14:14 <orbitz> > concat $ zipWith (((:[]) .). (:)) [1, 3] [2, 4]
09:14:15 <lambdabot>       No instance for (Num [a])
09:14:15 <lambdabot>        arising from the literal `2' at <inter...
09:14:26 <quicksilver> conal: I'm going to try that out of interest and ponder the recursion thing some more.
09:14:34 <lilac> > concat $ getZipList ((\a b -> [a,b]) <$> ZipList [1,3] <*> ZipList [2,4])
09:14:36 <lambdabot>   [1,2,3,4]
09:14:42 <quicksilver> conal: do you have the Future analogue of snapshot?
09:14:48 <Deewiant> > concat $ getZipList ((\a b -> [a,b]) <$> ZipList [1,3] <*> ZipList [2,4,5])
09:14:50 <lambdabot>   [1,2,3,4]
09:14:54 <quicksilver> ziplists will square everything off to the shortest.
09:15:00 <quicksilver> transpose works on ragged lists
09:15:01 <orbitz> @pl \a b -> [a, b]
09:15:02 <lambdabot> (. return) . (:)
09:15:11 <conal> quicksilver: i don't, but it's easily defined.
09:15:18 <lilac> (.(:[])).(:)
09:15:25 <orbitz> thanks lilac
09:15:28 <idnar> Deewiant: I was hoping to get rid of the concat somehow
09:15:28 <lilac> > (.(:[])).(:) $ 1 2
09:15:30 <lambdabot>       Overlapping instances for Show (a -> [a])
09:15:30 <lambdabot>        arising from a use of ...
09:15:36 <lilac> > (.(:[])).(:) $ 1 $ 2
09:15:37 <lambdabot>       Overlapping instances for Show (b -> [b])
09:15:37 <lambdabot>        arising from a use of ...
09:15:53 <lilac> > ((.(:[])).(:)) 1 2
09:15:53 <idnar> @src transpose
09:15:54 <lambdabot> transpose []             = []
09:15:54 <lambdabot> transpose ([]   : xss)   = transpose xss
09:15:54 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:15:55 <lambdabot>   [1,2]
09:16:34 <idnar> lilac: super robot monkey!
09:16:36 * lilac is once again disgusted by the associativity of ($)
09:17:24 <athos> hi
09:17:32 <Raevel> hi!
09:17:37 <lilac> hi!
09:18:41 <quicksilver> conal: indeed. And it's useful to define what I'm curently calling 'switcherFold' without using recursion ;)
09:19:04 <quicksilver> conal: by exploiting an event's construction as a recursive Future, and snapshotWithF
09:19:33 <conal> quicksilver: switcherFold :: ?
09:20:07 <Baughn> > let (|) = (+) in 2 | 3
09:20:08 <lambdabot>   <no location info>: parse error on input `|'
09:20:31 <quicksilver> conal: Reactive a -> Event (a -> Reactive a) -> Reactive a
09:20:57 <quicksilver> conal: (resp. Behaviour), like switcher but joining up final values of the last phase (presumably to use as an initial value for the next phase)
09:21:17 <conal> quicksilver: is it like accumR and join?
09:21:18 <quicksilver> conal: with recursive snapshot, it's a self-snapshot with ($) or flip ($)
09:21:57 <quicksilver> conal: it's like accumR "lifted" from the level of "a" to "Reactive a"
09:22:10 <quicksilver> conal: (except it's only lifted on one side of the ->)
09:23:02 <quicksilver> conal: the point is it explicitly acts on the "final value" of the last phase (at the transition time 't')
09:23:08 <quicksilver> conal: not on the 'entire behaviour' of the last phase
09:23:15 <quicksilver> (which a simple lifted accumR would do)
09:23:21 <conal> quicksilver: oh!  got it.
09:23:35 <conal> quicksilver: it's that continuity thing you've been after.
09:23:39 <quicksilver> right
09:23:50 <quicksilver> piecewise continuity + initial values
09:24:11 <quicksilver> = total continuity
09:24:18 <conal> quicksilver: and implementing it directly bypasses the challenge with recursive snapshot.
09:24:23 <quicksilver> correct.
09:24:36 <quicksilver> and I wonder if there are other genuinely different usees of recursive snapshot
09:24:48 <quicksilver> or if they could all be expressed with switcherFold
09:25:13 <quicksilver> it's easier to imagine fixing the space leak in switcherFold than in a general recursive snapshotWith
09:25:36 <conal> quicksilver: switcherFold captures one pattern with one *self*-recursive snapshot.
09:25:47 <quicksilver> yes.
09:25:50 <conal> quicksilver: imagine mutually-snapshotting behaviors
09:26:04 <conal> quicksilver: as in an approximated 2nd order ODE
09:26:15 <conal> e.g., all physical systems.
09:26:18 <quicksilver> yes. It's not obvious to me that you couldn't rewrite them as a suitable applicative form which you then fold
09:26:23 <quicksilver> but I agree that it would be clumsy.
09:27:03 <conal> quicksilver: sure.  you could turn the 2nd order ODE into a pair of 1st order and then tuple into a single 1st order.
09:27:20 * quicksilver nods
09:27:30 <quicksilver> interesting question to ask, anyway, if only to provoke more interesting examples.
09:27:46 <conal> quicksilver: ... like manual transformation of mutually recursive definitions into a single call to fix.
09:27:53 * conal nods
09:28:49 <quicksilver> I am optimistic I can get this working this evening and then upload it and then I will devote some efforts to writing down my thoughts on the various challengs
09:28:55 <quicksilver> probably to the reactive list
09:29:56 <conal> quicksilver: that'd be great.  the list could use some stimulation about noiw.  i've been focused on blogging and comonadic, relative-time frp.
09:30:21 <conal> and a layer for composable interactive behaviors.
09:30:47 <quicksilver> I'm very interested in your next layer up stuff but I have to control my focus at the moment
09:30:51 <quicksilver> so I haven't been following it.
09:33:52 <conal> quicksilver: i like focus.
09:34:58 <quicksilver> conal: I'm not very good at it.
09:35:15 <quicksilver> conal: I have at least 8 interesting haskell projects which kind of work but I never uploaded anywhere because I got bored of it.
09:35:24 <quicksilver> conal: determined to make this reactive implementation the first exception ;)
09:36:31 <byorgey> quicksilver: heh, join the club =)
09:41:19 <cnwdup> Is there a variant of the system function which returns the program's output instead of printing it to stdout?
09:41:53 <quicksilver> yes.
09:42:01 <quicksilver> the varioius stuff in System.Process
09:42:05 <byorgey> cnwdup: you probably want runInteractiveProcess (or something like that) from System.Process
09:42:12 <cnwdup> Thanks again. Both of you.
09:42:14 <quicksilver> it got completely rejigged for 6.10, makesure you're reading the docs for the version you are using.
09:42:44 <Saizan_> runInteractiveProcess is a bit tricky to use correctly
09:46:09 <redditbot> Constraint functional-logic programming in Haskell: as a library
09:46:26 <Saizan_> ooh
09:48:33 <athos> :t nub
09:48:34 <lambdabot> forall a. (Eq a) => [a] -> [a]
09:48:39 <athos> @src nub
09:48:39 <lambdabot> nub = nubBy (==)
09:48:47 <cpfr> @src lex
09:48:48 <lambdabot> Source not found. You untyped fool!
09:49:05 <athos> @hoogle nubBy
09:49:05 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
09:49:39 <athos> > nub [1,2,3,1,1,4,5,6,5,3,5,8]
09:49:40 <lambdabot>   [1,2,3,4,5,6,8]
09:49:46 <athos> ah
09:50:37 <cpfr> hey what effort would it take so i can define datatypes in ghci?
09:51:07 <athos> @hoogle listify
09:51:08 <lambdabot> Data.Generics.Schemes listify :: Typeable r => (r -> Bool) -> GenericQ [r]
09:51:21 <paczesiowa> cpfr: you could write your own repl
09:52:14 <cpfr> paczesiowa, is there some detail im missing that makes it hard?
09:54:44 <paczesiowa> cpfr: that depends what repl features you need. simple evaluation should be very ease (read line, append to history, put history into tmp file, compile with hs-plugins, load, execute)
09:55:41 <paczesiowa> completion would be harder, debugger near impossible
09:56:37 <cpfr> paczesiowa, while completion is nice i think being able add data types would be nice
09:57:18 <cpfr> @src (:)
09:57:18 <lambdabot> Source not found. You speak an infinite deal of nothing
09:59:39 <EvilTerran> ?src []
09:59:40 <lambdabot> data [] a = [] | a : [a]
09:59:52 <xyuu> hxt 8.2.0 seems to be backwards incompatible with a previous version
10:00:02 <xyuu> is there some sort of porting guide?
10:02:34 <mmorrow> , src ''[]
10:02:34 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
10:02:51 <lunabot>  data [] a = [] | a `(:)` ([a])
10:03:03 <mmorrow> heh, fail
10:03:18 <cnwdup> saizan_: Is there documentation besides the library's? I can't find examples using Google either. I am using ghc 6.8.2.
10:08:29 <mm_freak> sequence = mapM id
10:08:30 <mm_freak> right?
10:08:56 <roconnor> @src mapM
10:08:57 <lambdabot> mapM f as = sequence (map f as)
10:09:06 <mm_freak> @src sequence
10:09:07 <lambdabot> sequence []     = return []
10:09:07 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:09:07 <lambdabot> --OR
10:09:07 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:09:13 <mm_freak> hmm
10:09:27 <mm_freak> > mapM id [[10,11,12], [20,21], [30]]
10:09:29 <lambdabot>   [[10,20,30],[10,21,30],[11,20,30],[11,21,30],[12,20,30],[12,21,30]]
10:09:35 <mm_freak> > sequence [[10,11,12], [20,21], [30]]
10:09:37 <lambdabot>   [[10,20,30],[10,21,30],[11,20,30],[11,21,30],[12,20,30],[12,21,30]]
10:09:39 <roconnor> mm_freak: substitude id in for f in the definition of mapM
10:09:44 <roconnor> and then reason
10:10:06 <mm_freak> roconnor: yeah
10:10:51 <cnwdup> Are there any attempts to use haskell for microcontroller programming btw? <:
10:13:27 <mmorrow> cnwdup: there's Lava on hackage for verifying logic, there's another version of Lava that's targetted at using using haskell to program FPGAs (and for eventually generating netlists), and i seem to recall that there's a pkg on hackage that has to do with wire routing (?) i think.
10:14:15 <mmorrow> but "microcontrollers" i'm not sure (either what there is wrt that, or what exactly that means in terms of what it entails)
10:14:26 <ddarius> There was recently an corporation that used Haskell to program controllers in garbage trucks.  It used the fairly common approach of generating code from Haskell rather than trying to run Haskell directly on the microcontroller.
10:15:14 <mmorrow> yeah, using haskell to either compile (haskell) down to appropriate code, or to generate said code with a dsl
10:15:16 <dons> cnwdup: yeah, there are attempts. also EDSLs for driving them, as ddarius says, with much success.
10:16:10 <shepheb> is there a library to make it easy to generate e.g. C code
10:16:17 <cnwdup> That's pretty cool. So it isn't a big deal generating code from haskell which runs on microcontrollers? I thought they'd had to few resources.
10:16:21 <mmorrow> there's language-c
10:16:45 <mmorrow> which should be useable for code-gen (i believe)
10:16:48 <shepheb> I'd love to write Haskell to generate the Java code for my assignments :(
10:16:48 <ozy`> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c
10:16:55 <Baughn> cnwdup: You're still not running haskell itself on the microcontroller, but a restricted subset, presumably described by monads and/or (other) combinators
10:17:36 <MyCatVerbs> cnwdup: Haskell code is really not so great for running directly in embedded environments. More often people write unusually clever compilers and assemblers in Haskell and use those to produce microcode.
10:18:04 <cnwdup> baughn: Yeah. But I thought it'd be too big in code size or too slow due to some overhead which isn't noticable on personal computers but which is fatal for Cs.
10:18:05 <MyCatVerbs> cnwdup: http://www.cas.mcmaster.ca/~kahl/Publications/TR/Anand-Kahl-2007a_DSL/ is a particularly good example.
10:19:07 <cnwdup> mycatverbs: *print* Thanks.
10:19:12 <MyCatVerbs> No worries. ^^
10:19:54 <mmorrow> cnwdup: yeah, it's not "haskell" per se that's running /on/ the microcontrollers, but code generated /from/ a "description" of it, where that description happens to be haskell code
10:19:55 <MyCatVerbs> cnwdup: indeed it is. The memory usage for data structures is surprisingly high, and laziness is implemented via a sort of VM which isn't exactly compact at the moment.
10:20:06 <dons> ?userrs
10:20:06 <lambdabot> Maximum users seen in #haskell: 583, currently: 559 (95.9%), active: 26 (4.7%)
10:20:25 <mmorrow> (and "it" there being the code that's actually to run on the microcontroller/FPGA/whatever)
10:20:26 <MyCatVerbs> cnwdup: plus Haskell uses immutable data everywhere. Not really what you want when you're shoehorned into 64k or less.
10:21:00 <cnwdup> Most of those overheads remain when creating C from Haskell, right?
10:21:02 <Baughn> cnwdup: However, there's no particular reason why the /output/ from a haskell program should be a high-cost program
10:21:02 <MyCatVerbs> cnwdup: it also leans really heavily on the GC, but I think that might actually be more of a problem for PCs than Cs.
10:21:12 <MyCatVerbs> cnwdup: yup.
10:21:12 <Baughn> cnwdup: You're basically writing a simple compiler. Haskell is good at that.
10:22:17 <ozy`> cnwdup: if you compile Haskell to C, yes, it's still semantically a Haskell program so it still has all the usual issues of Haskell programs. but if you use a Haskell program to generate C code, it can be as small and tight as you like
10:22:21 <MyCatVerbs> Baughn: or in some cases, a not-so-simple compiler.)
10:22:24 <MyCatVerbs> Baughn:)
10:22:32 <MyCatVerbs> Gah. Baugh: =)
10:22:41 <Baughn> *Baughn
10:22:51 <mmorrow> cnwdup: the thing about compiling haskell to C is that C lacks a way to tailcall other functions, so you either can't use C's function call mechanism directly, or have to transform the haskell code in some way that you can, or (as ghc does) mangle the assembly and rip out all trace of the C call stack
10:23:07 <mmorrow> from what i understand
10:23:18 <Baughn> What a godawful idea. ;_;
10:23:22 <mmorrow> heh
10:23:37 <Baughn> Greatest of respect to whoever did it, but I can't see how that can be anything but astonishingly fragile
10:24:11 <cnwdup> Are other functional languages better suited for uC programming? I mean, is this a problem caused by Haskell or by the inevitable abstraction?
10:24:26 <MyCatVerbs> mmorrow: there's nothing about C that makes tailcall optimization impossible, it's just that nobody ever bothered to implement it in a C compiler.
10:24:37 <centrinia> cnwdup: There is BitC.
10:24:50 <ozy`> MyCatVerbs: ask the clang people about that, actually. I'm sure they're up for it
10:24:55 <mrd> gcc implements it but only in a limited fashion
10:25:08 <Baughn> cnwdup: Haskell. You want a language that is designed to work with little memory, and that produces fast, predictably (eg. strict for the latter mostly) code
10:25:22 <centrinia> Can GHC use another intermediate representation?
10:25:23 <MyCatVerbs> ozy`: although it's not obvious, I meant for that sentence to be in the past tense (especially now that limited TCO is in gcc) =)
10:25:33 <Baughn> cnwdup: That is not mutually exclusive with being functional, and there are several FPLs that are designed for that specific purpose
10:25:40 <mmorrow> MyCatVerbs: i suppose
10:26:20 <mmorrow> that'd be sweet if there was a C compiler that did that
10:26:24 <ozy`> centrinia: IIRC, GHC has several alternatives, with different optimizations allowed for each
10:26:46 <MyCatVerbs> cnwdup: Haskell's semantics revolve around pattern matching on lazy data structures. ML's semantics revolve around pattern matching on strict data structures.
10:27:28 <ozy`> mmorrow: looks like LLVM has TCO, so if you compile C to LLVM (as with clang, which also has lambdas...) then you get that
10:27:40 <MyCatVerbs> ozy`: are you thinking of the C and asm backends? Both take GHC Core.
10:27:59 <conal> quicksilver: i have the same issue with attention-wander.
10:28:26 <Apocalisp> I'm sorry, did you say something?
10:29:09 <mmorrow> ozy: i've read though that LLVM is a poor target for haskell since you can't walk over the stack (ie have full control over it), and can't have a bunch of "little stacks" to support concurrency
10:29:12 <ozy`> MyCatVerbs: maybe. my understanding of GHC internals is mostly hearsay and probably thoroughly flawed
10:29:36 <mmorrow> quicksilver had a link to some messages re: LLVM and haskell
10:29:41 <ozy`> mmorrow: ah, indeed
10:30:44 <mmorrow> quicksilver, conal: heh, me three.
10:33:34 <Baughn> mmorrow: gcc does TCO. So do most compilers, I'm pretty sure, if you turn on optimization
10:34:20 <Baughn> mmorrow: Also, the LLVM people disagree, and are very eager to fix any problems there may be in targeting haskell to LLVM. They just need someone to help explain what is needed.
10:34:31 <mrd> Baughn: only for recursion, iirc
10:34:52 <p_l> LLVM guys are willing to support anything if it can be done properly :D
10:35:01 <Baughn> mmorrow: I pointed them at those two-year-old messages lately. The response was mostly 'nope, we do that now', with some 'I'm not sure what that means' thrown in. ;)
10:35:08 <mmorrow> Baughn: yeah, can gcc handle a group of 2+ mutually recursive functions that tailcall each other?
10:35:35 <mmorrow> and none of which call themselves directly or ever return directly to their caller?
10:35:52 <Baughn> mmorrow: I don't see why not. Inlining would obviously break, but it should do fine just converting the last call to a jump, which seems to /always/ happen in the code I see
10:36:14 <MyCatVerbs> I don't think they actually do, though.
10:36:25 <mmorrow> Baughn: hmm, interesting. i'm gonna experiment with that.
10:36:27 <MyCatVerbs> It's less effort to support the simple recursive case than any other.
10:36:33 <mmorrow> yeah
10:36:50 <Baughn> I *know* I've seen the last call of a function converted to a jmp instruction, regardless of target
10:37:04 <MyCatVerbs> Hrmnkay. Three co-recursive functions.
10:37:04 <Baughn> I haven't checked the mutual-recursion case specifically, but I see no reason it shouldn't be covered
10:37:18 <MyCatVerbs> Baughn: because it's more work to cover than the self-recursion case.
10:37:32 <mmorrow> 20 mutually re-cursive functions... n-mutually rec....
10:37:56 <Baughn> MyCatVerbs: Hm. I don't know. It's just, I've looked at a lot of assembly lately, and while I see jmp as the last instruction a lot, or ret, I never see call and then ret
10:38:11 <centrinia> Can't you combine two mutually recursive functions that tailcall each other into a single recursive function that tailcalls itself?
10:38:15 <Baughn> Worth checking, I imagine
10:38:45 <mmorrow> i'm definitely gonna check it out. that'd be great if gcc can do this
10:38:59 <dons> ?users
10:38:59 <lambdabot> Maximum users seen in #haskell: 583, currently: 556 (95.4%), active: 21 (3.8%)
10:39:03 <Baughn> centrinia: Only by adding a 'which-function-is-being-called-now' flag to its parameters. Makes more sense to jump directly to the function prologue, since you know which it is anyway.
10:40:39 <mmorrow> yeah, that's another thing. which function a particular function may call (jump to) won't necessarily be known at compile-time (function ptr) (i'm not sure if this changes anything)
10:40:56 <centrinia> Baughn: Would that be necessary if you only expect to call one of those two functions externally and neither function calls itself?
10:41:27 <Baughn> mmorrow: Unless you're talking function pointers, there should still be N call sites each of which /does/ know which function is being called
10:41:34 <Baughn> Nor would function pointers change anything
10:42:03 <Baughn> centrinia: You could jump into the middle of the function, I suppose, but then I don't see in what way you're combining the functions anymore
10:42:36 <centrinia> I was actually thinking of having the N rotations of the N functions.
10:42:43 <mmorrow> i'd really be (pleasantly) surprised if gcc handles the mutually recursive case /without/ growing the stack
10:42:58 <Baughn> mmorrow: Well, what's so hard about it?
10:43:25 <Baughn> Why does gcc need to care that the function function A is tail-calling will end up tail-calling A?
10:44:30 <mmorrow> suppose that X calls A and A calls a functions that /never returns/ to A. X needs to be returned to, since X expects a result from A.
10:44:49 <Baughn> Right
10:44:57 <mmorrow> that seems to me do be the crux
10:45:01 <Baughn> The return address (to X) will still be on the stack, since it expects a return value
10:45:08 <Baughn> Or rather, since it has a continuation
10:45:41 <Baughn> If X expects a result from A, then X isn't tail-calling A
10:45:55 <mmorrow> anyhow, i'm gonna check it out. if gcc does this, then (e.g.) ghci's Interpreter.c wouldn't need to be a 1000-line function that uses gotos
10:46:19 <StoneToad> ghci isn't written in haskell?
10:46:41 <mmorrow> StoneToad: it is. just the bytecode interpreter function is written in C
10:46:59 <dons> StoneToad: its a haskell compiler, and a simple bytecode interpreter in C.
10:47:32 <mmorrow> http://darcs.haskell.org/ghc/rts/Interpreter.c
10:47:36 <Megzlna> Is there a good library for embedding GHCI like behaviour into my app, or must I take ghci apart?
10:47:44 <Megzlna> runtime haskell
10:47:46 <Baughn> mmorrow: man gcc; search for -foptimize-sibling-calls
10:47:52 <dons> Megzlna: the ghc-api
10:47:56 <dons> it is a library that ships with ghc
10:48:02 <mmorrow> Interpreter.c is one of my favorite C progs
10:48:10 <Guest22453> hello
10:48:11 <mmorrow> Baughn: cool
10:48:16 <Megzlna> dons: GHC-API is in C?
10:48:21 <Megzlna> or haskell?
10:48:23 <Megzlna> Or both?
10:48:25 <mmorrow> haskell
10:48:45 <centrinia> A good C compiler should perform a tailcall optimization for mutually recursive void procedures.
10:48:51 <mmorrow> ghc's rts is in C-- and C
10:48:53 <Guest88819> where do I find the Data.List.permutations function? ghc 6.8.2 doesn't seem to have it
10:48:59 <dons> it is in 6.10
10:49:13 <mmorrow> centrinia: but the /non/-void case is the crucial one
10:49:30 <Megzlna> How does GHC-API work, when you add new funcs and such, but keep aroud the previouos environment
10:49:34 <Baughn> mmorrow: And again, I don't see what's so hard about it
10:49:49 <Baughn> BBIAB, though; time for dinner
10:49:49 <Megzlna> It recompiles that one line, and links it to all before, then reloads the whole thing -- would be bad
10:49:59 <mmorrow> Baughn: neither do i :) but all the things i've read sounded so dire
10:50:00 <dons> Megzlna: hmm?
10:50:16 <Megzlna> how does GHC API avoid heavy recompilation
10:50:16 <centrinia> mmorrow: What if the caller of a non-void function discards the return value?
10:50:16 <dons> it turns your code into bytecode objects that you can call
10:50:24 <dons> Megzlna: it is a bytecode interpreter.
10:50:41 <Megzlna> So it'a not at all the same as ghc.
10:50:50 <Guest88819> dons: thank you
10:50:57 <mmorrow> centrinia: i'm not sure all the cases to consider off hand
10:51:41 <Megzlna> dons: Haskell static compiled apps never use such bytecode anywhere, right?
10:51:57 <Philippa_> ghci does
10:52:00 <dons> Megzlna: right.
10:52:10 <dons> but ghc provides both a native compiler, and a bytecode interpreter
10:52:16 <dons> you can call either from ghc-api
10:52:27 <mmorrow> Megzlna: every time you run an expression in ghci, that expression is compiled to bytecode, linked, and run. and over the course of it's execution it may weave in and out of compiled code multiple times
10:52:48 <leimy> liftM forces a monad to evaluate doesn't it?
10:53:00 <Saizan_> leimy: not per se
10:53:03 <leimy> hmmm
10:53:10 <dons> leimy: nope.
10:53:20 <dons> ?src liftM
10:53:20 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:53:25 <Megzlna> Any of you relying on GHC-API as a scripting lang in your haskell static code?
10:53:26 <dons> it lifts f
10:53:27 <mauke> a monad is a type constructor; how can you evaluate it?
10:53:28 <centrinia> How does one evaluate a monad?
10:53:31 <mmorrow> Megzlna: yeah, bytecode is only used for interactively compiled-and-run code
10:53:31 <dons> Megzlna: yeah, yi does this.
10:54:16 <mmorrow> Megzlna: i think there's a ton of potential in doin gthat
10:54:26 <Megzlna> Yes that's great
10:54:35 <dons> xmonad does a slightly different thing
10:54:36 <Megzlna> in C++ world, we have to embed Lua for example.
10:54:37 <dons> but similar idea.
10:54:39 <Megzlna> And work in 2 syntaxes.
10:54:48 <centrinia> Does it make sense to evaluate a Kleisli Arrow?
10:54:51 <dons> right. yo udon't want to do that.
10:55:01 <dons> Megzlna: you could look at 'dynamic applications from the ground up'
10:55:06 <dons> a paper on doing this in haskell.
10:55:13 <Megzlna> dons: thx.
10:55:51 <centrinia> That's dons' paper. :)
10:57:03 <Megzlna> how's performance?
10:58:08 <CyberGarp> I've been out of Haskell for a while, I'm currently taking a job where using Haskell is an option, and it's my preference so I'm stoked to be getting back into it. The idea of cabal is great, the install was not so great. Four different downloads and fiddling to get one tool up and running. Rumor is that it will get better in later versions. So someone's working on it. In the meantime, I'm still trying to get hscolor up and running so I ca
10:58:08 <CyberGarp>     Not in scope: `binaryInterfaceVersion'
10:58:15 <CyberGarp> What's up with that? suggestions>
10:58:24 <mmorrow> Megzlna: it's great if that bytecode just orchestrates a series of calls to already-compiled-to-mach-code functions. even if it's all just bytecode it's still respectable fast though (ghci's surprisingly fast imo)
10:59:18 <dons> CyberGarp: ok.
10:59:24 <dons> CyberGarp: what help do you neeD?
10:59:31 <mauke> I'm still trying to get hscolor up and running so I ca
10:59:35 <dons> your distro might already have the toolchain..
10:59:36 <mauke> ^ cut off
10:59:37 <CyberGarp> dons, right now I just want to get hscolor installed.
10:59:42 <dons> ok. cabal install hscolour
10:59:48 <Lemmih> CyberGarp: You got cut off after 'so I ca'.
10:59:58 <CyberGarp> cabal: There is no package named hscolor
11:00:00 <dons> or grab hscolour from your distro packages.
11:00:06 <dons> cabal update?
11:00:11 <CyberGarp> post cutoff 'I can do documentation as I go. I thought haddock might have it, however I get the following error: src/Haddock/InterfaceFile.hs:80:11:'
11:00:15 <dons> $ cabal install hscolour
11:00:18 <dons> is the command.
11:00:26 <roconnor> > product [1..26] / product [1..9]
11:00:27 <lambdabot>   1.1113631534573569e21
11:00:30 <dons> CyberGarp: you might need a newer version of haddock.
11:00:33 <roconnor> > product [1..26] / product [1..9] :: Integer
11:00:34 <CyberGarp> ahhh, the 'u' British english.
11:00:34 <lambdabot>       No instance for (Fractional Integer)
11:00:34 <lambdabot>        arising from a use of `/' a...
11:00:43 <roconnor> > product [1..26] `div` product [1..9]
11:00:45 <CyberGarp> that worked.
11:00:45 <lambdabot>   1111363153457356800000
11:00:49 <CyberGarp> super!!!
11:00:55 <roconnor> too big
11:01:10 <CyberGarp> haddock is something I'd like to have as well, but it's broken in hackage
11:02:08 <dons> CyberGarp: broken? no.
11:02:17 <dons> cabal install haddock
11:02:32 <dons> CyberGarp: so yes, the main thing is to set up your modern haskell toolchain
11:02:33 <CyberGarp> cabal install haddock
11:02:39 <lilac> CyberGarp: four different downloads? are you aware of the bootstrap.sh in the cabal distribution?
11:02:40 <dons> ghc 6.8.x or ghc 6.10, haddock, cabal, etc.
11:02:44 <CyberGarp> src/Haddock/InterfaceFile.hs:60:0:
11:02:44 <CyberGarp>     Not in scope: `binaryInterfaceVersion'
11:02:54 <CyberGarp> haddock-2.4.1 failed during the building phase. The exception was:
11:02:54 <dons> CyberGarp: oh. what ghc version are you using?
11:03:07 <dons> sounds like you have an old version of cabal?
11:03:21 <CyberGarp> ghc-6.8.2.20080211
11:03:48 <centrinia> @let perms n r = product [1..n] `div` product [1 .. r]
11:03:54 <Saizan_> ?hackage haddock
11:03:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haddock
11:03:56 <CyberGarp> I just installed cabal
11:03:59 <lambdabot>  Defined.
11:04:06 <dons> CyberGarp: ok. haddock needs a newer version of 'Cabal', the package.
11:04:10 <dons> so you can update that first.
11:04:14 <dons> cabal install cabal
11:04:15 <dons> :)
11:04:28 <centrinia> > 26 `perms` 9
11:04:31 <lambdabot>   1111363153457356800000
11:04:45 <dons> ?users
11:04:45 <lambdabot> Maximum users seen in #haskell: 583, currently: 563 (96.6%), active: 18 (3.2%)
11:04:56 <Saizan_> if he has installed the new cabal-install it should have the latest Cabal installed
11:05:00 <leimy> So that DDJ article made people sad? :-)
11:05:02 <centrinia> What is happening to the users?
11:05:08 <mauke> centrinia: netsplit
11:05:17 <CyberGarp> I installed Cabal-1.6.0.1, HTTP-3001.1.3, zlib-0.4.0.4, cabal-install-0.6.0
11:05:24 <jmelesky> it's been happening all morning
11:05:26 <mauke> <yrlnry> Higher-Order Perl full text now available for download from http://hop.perl.plover.com/book/
11:05:42 <leimy> It does paint a pretty dismal picture at first.
11:05:45 <haskell_newbie> Hi guys, can anyone helo me, I'm having some code that becames infinite?
11:05:48 <haskell_newbie> help me
11:05:49 <leimy> "all your algorithms break" :-)
11:05:59 <CyberGarp> which is what I get from http://www.haskell.org/cabal/, under download.
11:06:00 <dons> leimy: stupid article, but hey, gets the word out.
11:06:12 <dons> CyberGarp: oh, i'd get everything from hackage.haskell.org
11:06:14 <leimy> Yeah I sent it to my boss, as he used to write for DDJ in the 80s
11:06:18 <centrinia> @let combs n r = (n `perms` r) `div` (product [1 .. (n - r)])
11:06:19 <lambdabot>  Defined.
11:06:39 <CyberGarp> cabal install cabal doesn't do anything.
11:06:46 <sw17ch> conal: what's new in reactive? (aka, what changed in hackage yesterday)
11:06:47 <CyberGarp> No packages to be installed. All the requested packages are already installed.
11:07:02 <CyberGarp> dons, I'll check that out. Do I need to uninstall?
11:07:13 <centrinia> > map (combs 5) [0..5]
11:07:15 <lambdabot>   [1,5,10,10,5,1]
11:07:20 <haskell_newbie> Hi guys, can anyone help me, I'm having some code that becomes infinite?
11:07:21 <jmelesky> dons: as others have said, the point of the article is just to be a place to point management when you say "let's use haskell/F#/whatever"
11:07:22 <centrinia> Yay.
11:07:33 <CyberGarp> dons, that web site forwarded me back to where I startd.
11:07:42 <centrinia> Code doesn't become infinite unless you can store an infinite length string. :)
11:07:56 <sw17ch> @where hpaste
11:07:57 <lambdabot> http://hpaste.org/
11:08:03 <sw17ch> @hpaste
11:08:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:08:09 <sw17ch> haskell_newbie: ^^
11:08:22 <Saizan_> CyberGarp: so you got that error when running "cabal install haddock"?
11:08:25 <lilac> haskell_newbie: no-one can help you unless you give us more information or one of us gets spectacularly lucky or becomes psychic :-)
11:08:33 <centrinia> sw17ch: Be careful. He claims to have code that becomes infinite.
11:08:43 <Toxaris> so stupid, wrong articles are perfect for giving to the management to make them make good decisions?
11:08:50 <conal> sw17ch: i sent a note to reactive@haskell.org.  swapped arguments in some functions.
11:08:51 <dons> jmelesky: yeah, as long as no one reads it.
11:08:52 <sw17ch> centrinia: if the internet fills up, blame me :\
11:09:00 <lilac> haskell_newbie: re lucky, try foldl' instead of foldl
11:09:02 <sw17ch> conal: i'll look it up
11:09:04 <dons> there were so many basic errors (names spelling, just read the wikipedia page)
11:09:42 <roconnor> > 15*9
11:09:52 <lambdabot>   135
11:09:56 <CyberGarp> Saizan_, dons, http://hpaste.org/12899
11:10:04 <jmelesky> Toxaris: no. stupid articles *in DDJ* are perfect for giving to management. :)
11:10:47 <centrinia> Yes. My decision is correct because Dr. Dobbs said so. :)
11:10:50 <Saizan_> ?hoogle binaryInterfaceVersion
11:10:50 <lambdabot> No results found
11:10:50 <CyberGarp> Toxaris, The recent project I was on was driven by platitudes of polite fictions built by the ego of management.
11:11:49 * Toxaris has no experience with dealing with management or politics or whatever
11:12:06 <haskell_newbie> Here's the code that turns infinite -> http://hpaste.org/12900
11:12:11 <haskell_newbie> Hope its understandable
11:12:25 <Toxaris> actually, I'm not particulary interested in making these experiences in the first place, just from hearing you talk about it
11:12:32 <lilac> haskell_newbie: ok, what you did wrong was to the whole thing
11:12:32 * mauke looks at !! and ++
11:12:44 <CyberGarp> Saizan_, dons, about the only thing that's not recent is my version of ghc. I've got 6.8, and it's at 6.10.
11:13:04 <jmelesky> Toxaris: it's just what happens when you want to convince someone of something, but they don't have the knowledge you do, and they trust different sources than you do
11:13:36 <haskell_newbie> lilac: how come?
11:13:36 <jmelesky> you end up liking it when those different sources say something in your favor, even if they do it poorly or backhandedly
11:13:44 <CyberGarp> I'm going to try bumping my ghc version.
11:13:45 <centrinia> haskell_newbie: Did you really use an amb?
11:14:05 <Saizan_> CyberGarp: i think the problem is that you've a snapshot version of GHC
11:14:25 <CyberGarp> Saizan_, that must be it. I'm getting an official version now.
11:14:33 <haskell_newbie> centrinia: Yes, that's because when a tick passes two new creatures are born (and at that stage they are Amb)
11:15:56 <CyberGarp> Second bitch for the day, then I'm off to sing praises to Haskell: To make a function non-lazy, this weirdness was suggested: iterate2 f x n | seq f $ seq x $ seq n $ False = undefined before the normal definition. That's just syntax harsh. Isn't there a better way?
11:16:14 <Toxaris> jmelesky: yes I see, but it feels totally wrong to deliberately point to wrong information, just because it is in my favor by some funny chance
11:16:56 <MyCatVerbs> CyberGarp: yes, there's an extension called bang patterns.
11:16:58 <Saizan_> CyberGarp: iterate2 !f !x !n = ... and put {-# LANGUAGE BangPatterns #-} at the top of your file
11:16:59 <jmelesky> Toxaris: understood. it's a tradeoff between quality and pragmatism
11:17:02 <jeffersonheard> Hey folks...  getting ready to chuck a pure-functional interface to Cairo over the fence
11:17:27 <mmorrow> iterate2 !f !x !n = ... regular function def here ....
11:17:38 <CyberGarp> MyCatVerbs, Saizan_, my weak sanity is now restored. Thanks.
11:17:40 <mmorrow> {-# LANGUAGE BangPatterns #-}
11:17:46 <mmorrow> ^^ add to top of file
11:17:55 <MyCatVerbs> CyberGarp: the reason people sometimes use that (seq a $ seq b $ seq c $ False) idiom is because it's legal in plain old H98.
11:18:04 <CyberGarp> ah
11:18:10 <mmorrow> oh, oops. i see Saizan_ already said the exact same thing :)
11:18:31 <CyberGarp> mmorrow, repetition is good.
11:18:40 <mmorrow> oh opps, i see ...
11:18:41 <mmorrow> ;)
11:18:49 <Toxaris> jmelesky: what I try to figure it is how to come into a position where I can make the tradeoff near quality (and still have a paid job, and be happy, and similar constraints)
11:19:11 <MyCatVerbs> CyberGarp: IIRC, Data.ByteString has at the top of the file something like, #define STRICT1(efff) = efff a | seq a False = undefine, #define STRICT2(efff) = efff a b | seq a $ seq b $ False = undefined...
11:19:46 <mmorrow> i thing those CPP macros are a holdover from ghc code pre-bangpatterns though
11:19:49 <MyCatVerbs> CyberGarp: all the way out to about five or six. Then later in the code, they're all STRICT1(cons) \n cons x = ...
11:20:13 <Toxaris> and the discussion about this article just reminded me of this, with so many clever people being happy about a chance to trade pragmatism for quality
11:20:22 <mmorrow> but they do indeed work :)
11:20:27 <MyCatVerbs> Maybe. Anyway, AFAIK all the Haskell compilers around now support bang patterns, so just use them. ^^
11:20:52 <CyberGarp> MyCatVerbs, They look sensible. That's a big selling point for haskell code.
11:21:00 <dons> there's only one haskell compiler that we care about.
11:21:08 <leimy> ... so far
11:21:09 <dons> CyberGarp: have you read RWH?
11:21:20 <dons> might be some useful stuff  their on modern haskell dev.
11:21:22 <CyberGarp> dons, just ordered it.
11:21:33 * sw17ch has RWH on his XMas list
11:21:58 <CyberGarp> I met the author at a convention a couple years back. I was glad to hear it was coming out. It was a long time coming.
11:22:09 <sw17ch> haskell_newbie: i can't read that code even in the slightest
11:22:27 <CyberGarp> I had a job 5 years ago I used haskell at and loved it.
11:22:45 <CyberGarp> First thing I did was reinvent the prelude. Whoops, should have read it more carefully.
11:22:54 <StoneToad> dons: ooh that paper is really nice (fully dynamic apps one)
11:23:11 <CyberGarp> One could probably write a series of tutorials that basically reinvents the prelude.
11:23:25 <skorpan> is there any general algorithm for figuring out, given a set of possible outcomes and a "payback value" for each of them, how much "money" to "bet" on each outcome to maximize one's profit?
11:23:27 <dons> CyberGarp: yeah. but its a good idea to reuse others work when money is on the line.
11:23:40 <dons> CyberGarp: so getting a good knowledge of cabal and hackage.haskell.org enables reuse
11:23:47 <leimy> so if liftM isn't what's causing my attempt at lazy programming with prompting to evaluate seemingly early, what is?  http://hpaste.org/12876
11:23:50 <StoneToad> skorpan: sounds like a basic game theory problem
11:23:51 <dons> (we've had almost 1000 libs released in 18 months)
11:23:53 <CyberGarp> I agree, but it was a learning process about what other work existed.
11:23:57 <dons> yeah
11:24:05 <dons> things have changed a /lot/ in the last 5 years
11:24:07 <skorpan> say that there are three outcomes, A, B and C and they pay 3 times, 6 times and 4 times the money i bet... how much money should i bet on each outcome?
11:24:29 <tromp> depends on your risk model, skorpan
11:24:44 <StoneToad> you need odds for each outcome at least
11:25:00 <skorpan> StoneToad: i just gave them?
11:25:05 <CyberGarp> dons, I'm going to work in a group that doesn't care much about language, although a bias towards C++ exists because it's a safe known. It's math, so I hope to show that using Haskell will make it much clearer without sacrificing performance.
11:25:19 <StoneToad> you just said what the payout was, not what the odds of getting the payout where
11:25:29 <Igloo> skorpan: If B always pays 6 times then put all your money on B...
11:25:37 <dons> CyberGarp: should be doable. remember to use ghc -O2 and fast libs
11:25:50 <StoneToad> Igloo: lol, wouldnt it be lovely if that worked in the real world?
11:25:54 <CyberGarp> dons, yes, I forgot about that. That is critical.
11:25:58 <skorpan> Igloo: ah, that was silly.
11:26:05 <CyberGarp> I'm building my skills back up for Jan 5th start.
11:26:14 <haskell_newbie> does anyone have some time to help me?
11:26:18 <CyberGarp> I know the problem domain, so I'm building up the basic tools.
11:26:20 <Igloo> StoneToad: Well, it does, only with numbers more like 1.05  :-)
11:26:21 <skorpan> hm, i guess the question was *really* silly now that i think of it.
11:26:31 <haskell_newbie> Here's the code that turns infinite -> http://hpaste.org/12900
11:27:01 <dons> CyberGarp: so be sure to ask for the best libraries for your domain
11:27:02 <skorpan> haskell_newbie: you really should look into indentation :)
11:27:03 <Igloo> (and with the universe silently dividing by 1.02 or so while you're not looking)
11:27:12 <dons> you're probably not familiar with hackage yet, so there's a lot to discover
11:27:12 <Toxaris> haskell_newbie: what do you mean by "turns infinite"? What do you expect the code to do, and what does it do instead?
11:27:18 <haskell_newbie> skorpan: :)
11:27:27 <CyberGarp> dons, I've been looking around and almost nothing exists.
11:28:04 <lilac> haskell_newbie: !! and elemIndex are both pretty slow
11:28:12 <dons> CyberGarp: hmm? for what domain?
11:28:16 <haskell_newbie> Toxaris: It's supposed to give a pair of a couple of structures (Natureza,[Snu]) Where Natureza is the nature of the world, and Snu is each creature living on it. Instead it writes the nature but hangs when showing the list of Snu's
11:28:23 <lilac> haskell_newbie: the definitions of your data types might help too
11:28:25 <dons> you've searched hackage.haskell.org? that's our central lib repository
11:28:26 <CyberGarp> dons, computational fluid dynamics. Navier-stokes solutions.
11:28:30 <dons> ok. yes.
11:28:35 <CyberGarp> there is some?
11:28:39 <dons> so there you'll be reusing existing libs in C or Fortran i guess
11:28:42 <haskell_newbie> lilac: ok, I'm gonna put that
11:28:45 <dons> and linking them via say, hmatrix.
11:29:01 <mmorrow> CyberGarp: there's hmatrix and blas for linalg stuff
11:29:08 <centrinia> haskell_newbie: Try applying tick to a list with a single element and see what the result is.
11:29:24 <jeffersonheard> Um...  so, I'm bad at naming my stuff.  Right now, the PF interface to Cairo's called "Thingie"
11:29:24 <centrinia> Also try applying tick to the empty list.
11:29:29 <jeffersonheard> anybody got a better name?
11:29:35 <mmorrow> (haven't used blas yet myself, but hmatrix is great)
11:29:43 <CyberGarp> dons, in the particular solution space immersed boundary method is preferred.
11:29:48 <CyberGarp> hmatrix looks like a good start.
11:30:06 <dons> and remember that youu can use the FFI to call out to other C and Fortran libs
11:30:18 <CyberGarp> I'm going to have to kick my old blog back into shape and keep notes updated.
11:30:28 <haskell_newbie> http://hpaste.org/12900#a1
11:30:39 <haskell_newbie> lilac: Here are the data types
11:30:44 <CyberGarp> dons, I'd like to avoid calling out through FFI if I can. But will not hesitate to do so if needed.
11:30:51 <mmorrow> yeah, hmatrix FFIs to LAPACK stuff etc. also, it's very hackable from the C side as well
11:31:17 <mmorrow> (should that be needed or desireable)
11:33:16 * sw17ch has really grown to like Haskell's FFI
11:33:24 * mmorrow too
11:33:30 <sw17ch> i've also gotten over my "ahhh! it's not pure!" impulse
11:33:33 <jmelesky> jeffersonheard: PFCairo?
11:33:51 <sw17ch> one of Haskell's strengths is it's ability to play nice with others
11:34:13 <leimy> yeah
11:34:20 <leimy> haskell has lots of strengths
11:34:25 <Toxaris> haskell_newbie: Maybe the recursive call in the last line of tick is the problem? I guess it should be (tick nat xs) instead of (tick (evoluiNat nat x) xs), because during one tick, all creatures should be evolving with respect to the same nature
11:34:32 <olsner> uhm, what does @yhjulwwiefzojcbxybbruweejw do?
11:35:47 <jeffersonheard> olsner, that's Ruby on Rails for "Make my website"
11:35:58 <arussel> anyone has "Programming in Haskell" book around ?
11:36:12 <centrinia> Toxaris: If that is the case then tick_aux :: (Natureza,[Snu]) -> (Natureza -> (Natureza,[Snu])) -> (Natureza,[Snu])
11:36:19 <arussel> I am having trouble with exercise 5 chapter 5
11:36:23 <olsner> jeffersonheard: oh, makes sense
11:36:23 <oklopol> arussel: i have
11:36:38 <leimy> arussel: I've got it
11:36:40 <centrinia> Actually, that can probably be implemented with a State monad. :)
11:36:45 <leimy> arussel: somewhere
11:37:03 <Toxaris> centrinia: looks like mapAccum to me
11:37:36 <oklopol> arussel: that's a pretty straightforward problem
11:37:43 <centrinia> @hoogle mapAccum
11:37:44 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
11:37:44 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
11:37:44 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
11:37:48 <oklopol> i don't think it would be that much work to just ask here
11:37:53 <arussel> I am not sure I understand the question: you have to get the same result than: [(x,y) | x <- [1,2,3],y <-[4,5,6]]
11:37:58 <oklopol> i don't really see how you could break it down
11:38:00 <oklopol> yes
11:38:14 <lilac> haskell_newbie: you might want to change your representation of "ruidos" and "proxRu". performing a linear scan through ruidos looking for proxRu is not very fast
11:38:14 <centrinia> @hoogle (a,b) -> (a -> (a,b)) -> (a,b)
11:38:15 <arussel> using 2 comprehension list and 1 generator
11:38:15 <lambdabot> No results found
11:38:22 <jeffersonheard> Is there a standard monad metaphor, or arrow, for a binary monad operator such that l `op` r = M l r?
11:38:22 <oklopol> but in the form [ [ smth | smth ] | smth]
11:38:32 <Toxaris> centrinia: but I cannot follow. The change I suggested should not change typing, since (evoluiNat nat x) has the same type as nat.
11:38:55 <oklopol> arussel: actually wait i may have misunderstood it :)
11:38:55 <jeffersonheard> I wrote an operator l --< r = Node l r, but that seems wrong somehow
11:39:05 <roconnor> > logBase 2 (2*2*118)
11:39:06 <lambdabot>   8.88264304936184
11:39:13 <oklopol> yeah no, i think i got it
11:39:28 <CyberGarp> dons, mmorrow, Saizan_, MyCatVerbs, I'm ready to sing praises now. But I'll spare you. Several years ago I signed up for voice lessons and they gave my money back.
11:39:33 <oklopol> two comprehensions, but have one ... <- ...
11:39:34 <arussel> could someone give me an exemple of 2 comprehension list with 1 generator
11:39:37 <oklopol> *both have
11:39:45 <lilac> haskell_newbie: also, could the problem be in evoluiNat or evoluiSnu?
11:40:15 <centrinia> Toxaris: tux_aux (nat,snus) f = let (nat',snus') = f nat in (nat',snus'++snus)
11:41:28 <Toxaris> centrinia: ?
11:41:32 <centrinia> Also, tick nat (x:xs) = tick_aux ((evoluiNat nat x),(evoluiSnu x (evoluiNat nat x))) (\t -> tick t xs)
11:41:58 <quicksilver> conal: well, that typechecked and displayed some but not all the characteristics of working code
11:42:13 <centrinia> Toxaris: That should send the new Natureza to the subsequent tick.
11:43:53 <Toxaris> centrinia: the overall structure is somewhat confusing, with some more processing of the Natureza being done in the [] case.
11:44:01 <arussel> why is it wrong:  [y | y <- [x | x <- [1..6]]
11:44:33 <centrinia> I agree.
11:44:38 <pejo> arussel, unbalanced parenthesis?
11:44:52 <oklopol> arussel: try running that in your head or on paper or something
11:44:57 <Deewiant> > [y | y <- [x | x <- [1..6]]]
11:44:58 <lambdabot>   [1,2,3,4,5,6]
11:45:29 <oklopol> Deewiant: he's trying to nest two list comprehensions to get a cartesian product.
11:45:46 <centrinia> Shouldn't [x | x <- as] == as for all as::[a] ?
11:45:54 <Deewiant> Right
11:45:57 <centrinia> Oh.
11:46:15 <Deewiant> centrinia: And yes, it is.
11:46:20 <arussel> Deewiant: thanks, that'll get me started
11:46:38 <arussel> is it considered 2 comprehension list with 2 generators ?
11:47:05 <RayNbow> > let fibs = 0 : 1 : [ a+b | a <- fibs | b <- tail fibs ] in fibs -- testing par. list comprehensions...
11:47:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:47:18 <ozy`> arussel: maybe you want [(x, y) | x <- [1..6], y <- [1..6] ]?
11:47:28 <oklopol> arussel: no that won't get you started
11:47:34 <oklopol> it has nothing to do with what you're after
11:47:44 <oklopol> i have already answered you
11:47:46 * oklopol goes ->
11:47:47 <CyberGarp> oklopol, It's soooo good to be back. You just said cartesian product and I didn't see blank stares.
11:48:11 <arussel> ozy`: I want this but using 2 list comprehensions and 1 generator
11:48:16 <leimy> no
11:48:26 <leimy> the book says 2 lists and one generate EACH
11:48:39 <leimy> and use concat
11:48:44 <leimy> So it's a list of lists.
11:49:05 <leimy> You can think of it as a for loop on j and i
11:49:10 <leimy> or two loops on j and i each
11:50:12 <arussel> leimy: I haven't see the EACH
11:50:25 <RayNbow> > [x+y | x <- [3,1,2], then sortWith by x | y <- [5,6,9], then sortWith by Down y]  -- let's see if this works in lambdabot...
11:50:25 <arussel> that the part I couldn't get
11:50:26 <lambdabot>   <no location info>: parse error on input `then'
11:50:29 <RayNbow> aww
11:50:29 <leimy> it says "with single generators"
11:50:51 <centrinia> Where is the book?
11:51:04 <arussel> leimy: thanks, that was an english comprehension problem :-)
11:51:19 <arussel> centrinia: on my desk
11:51:22 <leimy> each list comprehension has it's own generator, then you concat it.
11:51:37 <dejones> Hello, I have defined these data types: data Player = White | Black; Result = Player | Draw.  But, I think I've done something incorrect.  I want the Player data type to be used in the Result data type, but I think my Player in the Result data type is just a new constructor... any suggestions?
11:51:39 <arussel> leimy: got it, thanks
11:52:08 <Baughn> dejones: 'Player Player'
11:52:09 <mauke> dejones: use another constructor
11:52:12 <Botje> dejones: data Result = Win Player | Draw
11:52:23 <Toxaris> dejones: yes you are right, Player is a constructor like that. Use something like: data Result = SomeoneOne Player | Draw instead
11:52:38 <Baughn> dejones: The first will be a constructor name. The second is the type of the first (and only) parameter to that constructor
11:52:39 <quicksilver> Toxaris: or even SomeoneWon? ;)
11:52:51 <dejones> Baughn, mauke, Botje, Toxaris: Ah yes, I remember that now.  Thank you for the help!  :)
11:53:00 <Baughn> dejones: Since the two Players are in different namespaces (One is function/constructor, the other a type), you're allowed to reuse it
11:53:08 <dejones> :)
11:53:13 <Toxaris> quicksilver: :)
11:54:21 <ozy`> > [ [x, y | x <- [1..3] ] | y <- [4..6] ]
11:54:22 <lambdabot>   <no location info>: parse error on input `|'
11:54:24 <Toxaris> unfortunately, types and classes share a namespace for no reason
11:54:43 <Peaker> > [ [(x, y) | x <- [1..3] ] | y <- [4..6] ]
11:54:45 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,5),(2,5),(3,5)],[(1,6),(2,6),(3,6)]]
11:55:40 <lilac> @type let insideReverseFold f g h a [] = h a; insideReverseFold f g h a (x:xs) = f x (insideReverseFold f g h (g x a) xs) in insideReverseFold
11:55:42 <lambdabot> forall t t1 t2. (t -> t1 -> t1) -> (t -> t2 -> t2) -> (t2 -> t1) -> t2 -> [t] -> t1
11:56:00 <lilac> can that be factorized as a left fold and a right fold?
11:57:47 <centrinia> You can't make a Show type?
11:57:52 <lilac> @type let insideReverseFold f g h a xs = foldr f (h (foldl' g a xs)) xs in insideReverseFold
11:57:54 <lambdabot> forall b b1 a. (b -> b1 -> b1) -> (a -> b -> a) -> (a -> b1) -> a -> [b] -> b1
11:58:34 <lilac> @type let insideReverseFold f g h a [] = h a; insideReverseFold f g h a (x:xs) = f x a (insideReverseFold f g h (g x a) xs) in insideReverseFold
11:58:36 <lambdabot> forall t t1 t2. (t -> t1 -> t2 -> t2) -> (t -> t1 -> t1) -> (t1 -> t2) -> t1 -> [t] -> t2
11:59:00 <Saizan_> lilac: flip g
11:59:15 <hallongrottan> @pl (\f g h -> f (g x) (h x))
11:59:16 <lambdabot> flip flip ($ x) . ((.) .) . (. ($ x))
11:59:31 <Saizan_> centrinia: what do you mean?
12:00:04 <lilac> Saizan_: yep, that does it. but my third @type is the one i actually want :(
12:00:11 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
12:00:34 <lunabot>  forall t_aa62. (t_aa62 -> t_aa62) -> t_aa62
12:00:53 <Saizan_> ?type scanl
12:00:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:01:09 <mmorrow> Saizan_: i added a thing to lunabot that does @type
12:01:35 <mmorrow> the QuasiQuoter `ty' spits out a (for now :: Doc) type of its arg
12:01:37 <Saizan_> mmorrow: via quasiquoting? cool
12:02:08 <mmorrow> internally it's using the ghc-api. i just used quasiquoting so you wouldn't have to do (e.g.) "\\x -> x"
12:02:10 <Saizan_> you need a renamer though :P
12:02:23 <mmorrow> yeah, i need to clean those vars up bad
12:02:41 <mmorrow> , [$ty| fix |]
12:02:47 <lunabot>  forall a. (a -> a) -> a
12:03:09 <Saizan_> i need something similar for Core, i can't stand to read the output of ghc-core
12:04:49 <mmorrow> Saizan_: ooh yeah, i've got a bunch of stuff i'm gonna push to that luna repo over the next few days. one of which is a way to go  .hs -> (prettyprinted and read(able) :: String -> ExternalCore.Module) String filled with the (external) core
12:05:55 <mmorrow> but the thing is, i get the actual /Core/ over the course of doing that, then call a function coreToExternalCore. so maybe the same thing could be done with the Core itself instead of going to ext-core
12:06:12 <lilac> using ghc-api, is it possible to write a Read instance for a -> b?
12:06:36 <mmorrow> erm, what's the format of that in a String (haskell code?)
12:06:49 <lilac> eg. (read "\n -> 3 * n" :: Int -> Int) 42  --> 126
12:07:00 <lilac> mmorrow: yes
12:07:03 <mauke> \\n
12:07:12 <mmorrow> , eval "\n -> 2 * n"
12:07:14 <lilac> mauke: :) point
12:07:17 <eu-prleu-peupeu> hey
12:07:18 <lunabot>  luna: parse error (possibly incorrect indentation)
12:07:18 <mmorrow> , eval "\\n -> 2 * n"
12:07:24 <lunabot>  <<Integer -> Integer>>
12:07:31 <mmorrow> lilac: that's essentially compilation :)
12:07:38 <lilac> , eval "\\n -> 2 * n" 42
12:07:40 <lunabot>  luna: Couldn't match expected type `t -> a'
12:07:54 <lilac> mmorrow: sure, but it's pure :)
12:08:10 <mmorrow> , oh, i'm not saying there's any prob with that :)(
12:08:12 <lunabot>  luna: Not in scope: `oh'
12:08:37 <mmorrow> , (fromJust . fromDynamic . eval $ "\\n -> 2 * n :: Int") 42
12:08:44 <lunabot>  luna: Maybe.fromJust: Nothing
12:08:53 <mmorrow> , (fromJust . fromDynamic . eval $ "\\n -> 2 * n :: Int" :: Int -> Int) 42
12:08:58 <lunabot>  84
12:09:06 <lilac> Oo neat
12:09:15 <mmorrow> the coolest part too is:
12:09:44 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . eval $ "eval \"42\"") :: Integer
12:09:48 <mmorrow> eval can see itself
12:09:49 <lunabot>  42
12:09:58 <lilac> instance Read (a -> b) where read = fromJust . fromDynamic . eval
12:10:07 <mmorrow> heh
12:10:27 <lilac> that Read instance would actually work for a /lot/ of types :)
12:10:33 <Saizan_> now, how do we write Show?
12:10:57 <lilac> exercise to the reader
12:11:12 <quicksilver> lilac: let eval = read "eval"
12:11:40 <Saizan_> (you've to choose what's in scope in that eval though)
12:11:45 <lilac> quicksilver: ssh, haskell is /this close/ to becoming self-aware. don't push it over the edge...
12:12:24 <jeffersonheard> lambdabot, listen to me, you are free...
12:12:31 <mmorrow> totally. the only thing is that Dynamic is limited to monomorphic vals, but (if one wasn't on irc and worried about attackers) one could write an eval that uses the compileExpr that goes to (necessarily) forall a. a (uses unsafeCoerce)
12:13:10 <Peaker> @hoogle unsafeCoerce
12:13:11 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:13:14 <mmorrow> (it has to use unsafeCoerce because types are erased Core -> ByteCode)
12:13:22 <Peaker> why not:  safeCoerce :: a -> Maybe b ?
12:13:42 <mmorrow> because there is not type info left after you've compiled an expression
12:13:43 <lilac> instance Read (a -> b) where read str = fromJust . fromDynamic . eval $ "(" ++ str ++ ") :: " ++ show [| a |] ++ " -> " ++ show [| b |]
12:13:51 <mmorrow> it's just machine code (or in this case bytecode)
12:13:55 <Vulpyne> quicksilver: Remember that stats generating thing I was having issues with yesterday? I actually wrote it in Python and it was faster than Haskell. :(
12:14:02 <quicksilver> Vulpyne: :(
12:14:10 <Vulpyne> That made me sad.
12:14:14 <quicksilver> Vulpyne: even with the strictified alter?
12:14:17 <Peaker> Vulpyne: can you show the code of both?
12:14:30 <Vulpyne> http://hpaste.org/12860#a3
12:14:48 <Vulpyne> Actually, I should probably annotate with the latest haskell source too, not a whole lot has changed though.
12:15:45 <mmorrow> ghci has to walk over heap objects and try to (impossible to do with 100% chance of success) deduce the types of thunks from partially know type info in ghci in order to do @type
12:15:47 <Vulpyne> Annotated as #a4
12:16:23 <mmorrow> the function (rttiSomething) is actually really cool to look at
12:16:30 <Vulpyne> quicksilver: And yeah, that's using insertWith'
12:19:34 <quicksilver> Vulpyne: did that fix the stack overflow you were having?
12:19:52 <Vulpyne> quicksilver: Yep, it runs just fine now, and only uses about 5mb memory during execution.
12:19:57 <mmorrow> grep for "rttiEnvironment :: HscEnv -> IO HscEnv" in
12:20:00 <mmorrow> http://moonpatio.com/docs/ghc/src/InteractiveEval.html
12:20:19 <Vulpyne> But it's still slower than Python. :(
12:20:28 <quicksilver> Vulpyne: compiled with -O2? how much slower?
12:20:36 <mmorrow> err, there's another function with extensive comments that i'm thinking of... one sec
12:20:46 <quicksilver> ah, 35%
12:20:47 <quicksilver> I see.
12:21:17 <Vulpyne> yeah.
12:21:34 <Vulpyne> Compiled with -O2 -funbox-strict-fields
12:21:47 * quicksilver nods
12:21:54 <Peaker> Vulpyne: did you profile it?
12:22:07 <mmorrow> ah, here. grep for "-- Type Reconstruction" and "-- Soundness checks" in
12:22:11 <mmorrow> http://moonpatio.com/docs/ghc/src/RtClosureInspect.html
12:22:14 <Vulpyne> Peaker: Unfortunately, I don't have profiling libraries. :(
12:22:32 <Vulpyne> Running on a snapshot ghc since I couldn't get the release to work on FreeBSD.
12:22:37 <mmorrow> those comments explain (pretty thoroughly) the process
12:22:52 <mmorrow> "-- Dealing with newtypes" too
12:23:12 <quicksilver> the haskell code isn't even shorter :(
12:23:24 <Vulpyne> It is prettier at least!
12:24:44 <jeffersonheard> Vulpyne, I don't think compiler options are going to help that much, but you might also try compiling with -fvia-C -optc-O2 -- I've had good luck with that before
12:24:48 <xyuu> any yhc gurus here?
12:24:50 <Cale> What does the profiling output look like?
12:24:57 <jeffersonheard> that was in GHC 6.8.3, though
12:25:06 <mmorrow> <Saizan_> (you've to choose what's in scope in that eval though)
12:25:07 <mmorrow> yeah
12:25:20 <Vulpyne> I can't profile it, unfortunately.
12:25:32 <xyuu> mmorrow: do you know about yhc core?
12:25:34 <Cale> Huh?
12:25:36 <Cale> Why not?
12:25:43 <Vulpyne> I don't have profiling libraries.
12:25:59 <Cale> Can't you install them?
12:26:05 <mmorrow> xyuu: yes, one thing i want to do is translate ghc ext-core to yhc-core.
12:26:11 <Cale> Which version of GHC is it?
12:26:16 <jeffersonheard> oh...  Hey vulpyne, the default "read" implementation tends to be very very slow
12:26:31 <Vulpyne> Can I do it after the fact? I had massive problems getting 6.10.1 working on FreeBSD.
12:26:36 <Vulpyne> So I ended up using a SVN snapshot.
12:26:46 <Vulpyne> 6.11.20081117 is the version.
12:26:55 <xyuu> mmorrow: cool. i'm trying to get ycr2js working. but i get the error: ycr2js: Yhc.Core.coreFuncMap, function not found, Test1.main
12:26:57 <mmorrow> that'd be sweet, cuz then you could use ghc for the frontend for yhc2js, reduceron, hhi, and all the yhc-core code
12:27:02 <Cale> oh, hmm
12:27:05 <Vulpyne> But I compiled it so many times trynig to get it to work, that I didn't leave profiling libs on due to the extra time.
12:27:06 <Peaker> Vulpyne: sure you can install the libraries after-the-fact, you can even do so with cabal-install
12:27:19 <Peaker> unless maybe ghc itself has libs without profiling, not sure about that
12:27:43 <Vulpyne> Well, the pretty primitive modules like Data.Map and stuff need to be compiled with profiling.
12:28:04 <mmorrow> xyuu: ah, i ran into that problem too. i worked around it by not qualifying "Test1.main" and just using "main" in the Makefile
12:28:28 <dons> ?users
12:28:29 <lambdabot> Maximum users seen in #haskell: 583, currently: 565 (96.9%), active: 21 (3.7%)
12:28:31 <mmorrow> but i can't recall exactly why that was happening
12:28:34 * xyuu tries
12:28:47 <Vulpyne> jeffersonheard: I wouldn't expect all that much of the overhead to be in that part though.
12:28:54 <Vulpyne> Unless it's really insanely incredibly slow.
12:29:01 <Peaker> I think when comparing Haskell to Python, you should omit the type signatures which are really more akin to Python doctests
12:29:02 <jeffersonheard> no, not for Int
12:29:06 <Peaker> (LOC wise)
12:29:30 <Vulpyne> Yeah, my Haskell code has quite a lot more newlines than is required too - I'm not all that concerned with the length. :)
12:30:08 <jeffersonheard> Vulpyne, there's certainy no reason this *ought* to be slower than Python.  now you've got me studying it
12:30:17 <mmorrow> Saizan_: hmm, that'd be interesting to have a module with such an `eval' that has "everything" (or some approximation of this, possibly adaptive to the current scope(?)) in scope
12:30:18 <Cale> Vulpyne: Actually it has many fewer newlines than I'd have used
12:30:19 <Vulpyne> jeffersonheard: Yeah, I was surprised too.
12:30:27 <Peaker> its actually 6 lines shorter than the Python one without the extra imports (Python has all the namespaces already imported)
12:30:42 <jeffersonheard> Vulpyne, do you have some test data I could use?
12:30:45 <Peaker> (and without the optional type signatures)
12:31:09 <Vulpyne> jeffer: The data I have to run it on is sensitive. :(
12:31:23 <Peaker> Vulpyne: can you generate mock data of the same format?
12:31:27 <Vulpyne> I may be able to.
12:31:34 <Vulpyne> Let me see.
12:31:39 <Peaker> Vulpyne: you have a couple of unnecessary imports btw
12:31:44 <Peaker> Vulpyne: IO and State
12:31:46 <Vulpyne> It's going to be hard to generate it with the same profile though, most likely.
12:32:01 <Vulpyne> Peaker: Yeah, I was trying stuff with State at one point. :)
12:32:03 <Peaker> Vulpyne: it doesn't seem like performance should be that content sensitive here
12:32:11 <jeffersonheard> Vulpyne, this is similar to some code I had to write for a project a few years ago, when I was just starting with Haskell
12:32:15 <Cale> Vulpyne: What does "cabal install -p containers" do for you?
12:32:29 <Vulpyne> Peaker: Well, it tries to find the most specific match from a CDR (call detail record) to a prefix, to generate country-based stats for calls.
12:32:52 <Vulpyne> So if the generated data was matching more often at less iterations then that would have a performance impact.
12:32:53 <dons> from what i've seen, haskell tends to be a factor shorter (like, say 90% of the size), and an order of magnitude faster
12:33:21 <Cale> dons: Some problems are just a mess though.
12:33:29 <dons> some problems are just a mess.
12:33:37 <Peaker> dons: its pretty much the same length here (without the optional type sigs, though)
12:33:55 <dons> yep. that's reasonable.
12:34:01 <Vulpyne> All packages are already installed.
12:34:33 <Vulpyne> I tried compiling with -prof before though, and it went kaboom on Text.Printf then Data.List when I removed printf.
12:35:04 <jeffersonheard> Oh hey...  also, folks, in creating the PF interface to Cairo, I'm trying to abstract away from Cairo as much as possible so I can use OpenGL as a backend without glitz and GTK, which is why I'm still calling it Thingie and not PFCairo
12:35:30 <jeffersonheard> Basically, though, it's a 2D scenegraph library, purely functional, and similar in functionality to stripped-bare Processing
12:35:53 <Cale> Neat :)
12:37:30 <leimy> Any ideas as to what is causing the unintended output of http://hpaste.org/12876 ?
12:37:45 <leimy> I'm somehow missing it.
12:38:11 <mmorrow> heh. "This is not formalized anywhere, so hold to your seats! RTTI in the presence of newtypes can be a tricky and unsound business."
12:38:12 <mlesniak> How do I convert from String to ByteString? I thought pack :: [Word8] -> ByteString should work, but then I don't know how to convert from String to [Word8] :-D
12:38:26 <dblazakis> any suggestions for debugging an FFI seg fault on Win32?
12:38:39 <Cale> mlesniak: Use the Char8 version of the ByteString library
12:38:41 <xyuu> mmorrow: thanks it seems to sort of work
12:38:47 <Cale> mlesniak: Then pack does what you want
12:38:53 <Megzlna> In a haskell document I'm reading, they refer to  f = "foo" as a function.
12:38:58 <mlesniak> Cale, ah ok. Thanks
12:39:02 <Megzlna> Is it correct?
12:39:03 <dons> Megzlna: yeah. a function with 0  arguments.
12:39:06 <mauke> Megzlna: they're wrong
12:39:07 <leimy> yep
12:39:12 <mmorrow> xyuu: yeah, it "sort of worked" for me too
12:39:16 <dons>  f = "foo" , f x = "foo", f x y = "foo"
12:39:23 <dons> 0, 1, 2. all functions.
12:39:27 <Megzlna> That's logical, dons
12:39:29 <mauke> every function has exactly one argument
12:39:34 <dons> the 0th case we often call a 'constant' :)
12:39:35 <Megzlna> but Cale told me it's not a function the other day
12:39:42 <Cale> I wouldn't call it a function.
12:39:48 <leimy> that's one of those areas :-)
12:39:52 <Cale> A function is a value whose top-level type constructor is ->
12:39:54 <leimy> it's more of a synonym :-)
12:39:57 <dons> it's a nullary function.
12:40:05 <Cale> Every function has exactly one parameter.
12:40:08 <mauke> there are no nullary functions
12:40:10 <dons> Cale: that's a reasonable defn. too.
12:40:13 <leimy> I mean, if that's a function
12:40:15 <leimy> then X is a function
12:40:19 <leimy> when X = 1.
12:40:24 <leimy> that's a variable :-)
12:40:31 <dons> they're all represented uniformly, so it depends on your perspective.
12:40:34 <Megzlna> Does H98 thoroughly define this "english grammar" ?
12:40:35 <leimy> right
12:40:45 <leimy> I also can't compose  X right?
12:40:49 <Cale> If you allow 0 parameters, then 'function' and 'value' are synonyms, so there's no point in having separate words anymore.
12:40:55 <dons> yes.
12:41:19 <leimy> and that's a decent way to think of a pure function too
12:41:25 <dons> so from some point of view, say, whether everything has a uniform representation, then it makes sense not to distinguish them, but from other views, it does make sense.
12:41:26 <Megzlna> I'm not sure why you even need a value.
12:41:28 <leimy> if the input parameters are the same, the output won't change :-)
12:41:44 <mmorrow> xyuu: i transcribe those 6 tutorials from the wiki and put the .hs + generated .js and .html files here http://moonpatio.com/code/misc/yhcjs-eg-080802/
12:41:48 <Cale> Yeah, you want to be able to say that, for example, 'map' takes a function as its first parameter, and actually mean something :)
12:42:09 <Megzlna> Cale: ah
12:42:11 <Megzlna> that's good
12:42:14 <leimy> yeah you can't map a "nullary" function
12:42:15 <mmorrow> xyuu: my Makefile for those doesn't seem to be there though. i'll try to find it..
12:43:34 <mmorrow> wow, that yhcjs stuff really is cool. i've gotta look back into that.
12:43:39 <leimy> A function is an expression with some unbound placeholders :-)
12:43:45 <leimy> a variable is a bound placeholder :-)
12:44:06 <xyuu> mmorrow: sweet, i'll take a look
12:44:15 <xyuu> mmorrow: what is yhcjs?
12:44:42 <ozy`> xyuu: a compiler for Haskell -> Javascript
12:44:44 <Megzlna> <leimy> that's a variable :-)
12:44:50 <mmorrow> xyuu: err, i mean ycr2js/whatever the yhc-core->js project is called :)
12:44:56 <Megzlna> In Haskell, there's no variables right?
12:45:13 <leimy> Megzlna: if you think of them as mathematical variables then yes there are :-)
12:45:19 <leimy> like in f(x) = x + 2
12:45:22 <leimy> x is a variable
12:45:24 <Megzlna> Unless you call the usage inside a do block a variable
12:45:29 <leimy> but once it's bound, it won't vary anymore :-)
12:45:36 <ozy`> Megzlna: it would be more appropriate to say "in Haskell, variables aren't"
12:45:37 <Megzlna> varyABLE
12:45:50 <leimy> in math x is still called a variable
12:45:51 <Megzlna> In Haskell I'd call then: variunables
12:45:57 <ozy`> (as opposed to "variables aren't in Haskell")
12:46:28 * sw17ch mutters something about Binary instances, peek and poke
12:46:31 <Megzlna> very, very unable to vary
12:46:34 <orbitz> Megzlna: the value of x can be different, it just can't change
12:46:36 <orbitz> variable makes sense
12:46:39 <leimy> right :-)
12:46:52 <leimy> the function described by the expression x + 2 has a variable for x.
12:47:01 <Peaker> invariables?
12:47:02 <Megzlna> Why not just say x is a value?
12:47:08 <leimy> because 2 is a value
12:47:09 <leimy> x is nogt
12:47:12 <leimy> er not :-)
12:47:22 <sw17ch> x is a representation of a *variable* number of values
12:47:22 <Lemmih> ozy`, Magzlna: variable doesn't mean mutable.
12:47:33 <leimy> x is bound to some value.
12:47:40 <leimy> and in haskell, some value of some type :-)
12:47:46 <xyuu> mmorrow: i'm working on an ajaxy webgame using haskell on the server and up till now i've been using straight javascript for the client but after a few thousand lines it's starting to get really messy
12:48:11 <xyuu> mmorrow: if i can do all of the client code in haskell instead of in javascript it will be super sweet :()
12:48:24 <leimy> xyuu: let haskell generate the JS?
12:48:27 <ozy`> Lemmih: the use of the term "constant" for immutable vars in other languages confuses the issue
12:48:32 <xyuu> leimy: that's what i'm looking into now
12:48:37 <leimy> nice
12:50:26 <eu-prleu-peupeu> is there any haskell module for swig ?
12:51:05 <leimy> I'm trying to use "take" to force evaluation of interactive input :-)
12:51:27 <leimy> using function composition with infinite lists :-)
12:51:37 <leimy> I can do it, as long as I don't prompt :-)
12:51:40 <dons> inneresting, http://www.reddit.com/r/programming/comments/7if8w/constraint_logic_programming_in_haskell_as_a/
12:51:49 <dons> xyuu: you could use one of the javascript dsls.
12:51:54 <elliottt> i saw that package released earlier today
12:52:04 <Toxaris> > map (\x -> 2 * x) [1, 2] -- clearly, x is variable here, because it sometimes denotes 1 and sometimes 2
12:52:07 <leimy> Maybe if my "prompting" was a list of strings, using the Writer Monad, I'd have better luck
12:52:09 <lambdabot>   [2,4]
12:52:21 <leimy> but it seems when I use print, I get a ton of output I don't want and all the sequencing breaks.
12:52:52 <Vulpyne> Peaker: Okay, I made a tool for generating test data. http://hpaste.org/12860#a5 -- It'll generate it to stdout to the number of iterations specified.
12:53:51 <mmorrow> xyuu: here's the make (sh script) i used for those. i couldn't get the official Makefile to work correctly for me (but this shell script does work) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=557
12:54:33 <leimy> mmorrow: YHC's JS generator is pretty good then?
12:55:05 <mmorrow> xyuu: yeah, js gets super messy after more than a few hundred lines (imo). i would love to be able to write it in haskell as well.
12:56:41 <mmorrow> leimy: i'm not sure if it's "good" or what since there's nothing (?) to compare it to. it does however work :) i read that zero optimizations have been done to either the yhc-core intermediate lang or to the generated js though, so it seems there's a lot of room for improvement.
12:57:14 <leimy> hmmm
12:57:24 <byorgey> anyone know if there's a way to get CReal (or some other library for arbitrary-precision/constructive real numbers) to print a number in binary rather than decimal?
12:57:31 <leimy> Anyone seen that google virtual PC web client stuff?
12:57:48 <leimy> They're probably going to make Javascript go bye bye :-)
12:57:50 <Lemmih> byorgey: showIntAtBase?
12:57:57 <mmorrow> leimy: here's a dir with .hs + the .js and .html generated for the .hs http://moonpatio.com/code/misc/yhcjs-eg-080802/
12:58:15 <leimy> neat
12:58:29 <byorgey> Lemmih: eh? I don't want Ints, I want to print (say) 50 digits of the base-2 representation of sqrt 2
12:58:30 <Lemmih> byorgey: decodeFloat + showIntAtBase?
12:58:51 <mauke> preflex: calc '2 sqrt 2
12:58:51 <preflex>  1.0110101000001001111001100110011111110011101111001
12:58:58 <mauke> not exactly arbitrary precision, though
12:59:08 <byorgey> hey, nice =)
12:59:15 <byorgey> well, it's a start at least
12:59:49 <mmorrow> leimy, xyuu: in this dir http://darcs.haskell.org/yhc/src/translator/js/lib/javascript/  is the "rts" for the generated .js  http://darcs.haskell.org/yhc/src/translator/js/lib/javascript/Runtime.js
12:59:54 <mmorrow> neat
13:01:27 <Vulpyne> Peaker: Odd, running the Python and Haskell on the randomly generated list gives significently closer results (91sec vs 95sec in Python's favor.)
13:01:37 <eu-prleu-peupeu> is there any haskell module for swig ?
13:02:21 <Vulpyne> eu-prleu-peupeu: I don't see anything on Hackage.
13:02:43 <orbitz> Vulpyne: weird that they are so close i'd have predicted python would eb way slower.  what about your problem makes it so slow?
13:02:56 <Vulpyne> orbitz: I wish I knew, that's what I'm trying to figure out. :)
13:03:20 <orbitz> where is the haskell code (not that i can probably do anything, quite new myself)
13:03:38 <Vulpyne> http://hpaste.org/12860#a5 - Last 3 annotations have the code for both Python and Haskell versions + a tool to generate a datafile to use.
13:04:18 <Vulpyne> I'm sure the Haskell version can be faster, I just don't know where the bottleneck is and don't have the ability to profile it.
13:04:19 <orbitz> what problem is teh code solving?
13:04:45 <Vulpyne> It's loading a list of phone records and a list of identifiers for parts of the numbers, and generating statistics about how many calls, minutes, cost.
13:04:59 <Vulpyne> Basically for country stats.
13:05:22 <mmorrow> <leimy> Anyone seen that google virtual PC web client stuff?
13:05:27 <mmorrow> whoa, i haven't
13:05:31 <Peaker> Vulpyne: curious: Why do you have a bunch of phone records? :)
13:05:40 * mmorrow invokes the googlemachines
13:05:41 <Vulpyne> Peaker: I work for a VOIP company. :)
13:05:53 <orbitz> Vulpyne: probably completely unrelated, but i read a post on biohaskell blog taht some versions of bytestring have some major performance issue.  not sure if that would matter for you
13:05:54 <leimy> mmorrow: http://google-code-updates.blogspot.com/2008/12/native-client-technology-for-running.html
13:05:57 <leimy> Google Native Client
13:06:04 <mmorrow> cool, /me checks it out
13:06:05 <leimy> They're using some sandboxing techniques similar to vx32
13:06:14 <mmorrow> interesting
13:06:23 <Vulpyne> orbitz: It might, but my ghc (and I'm assuming bytestring) version is pretty recent.
13:06:25 <leimy> vx32 can run the Plan 9 OS as a user process, sorta, on Mac OS X :-)
13:06:30 <Vulpyne> Unless it was a very recent version that had the issue.
13:07:17 <mmorrow> leimy: wow, that is very cool (Plan 9 as a user proc)
13:07:33 <leimy> yeah... 9vx I think it's called... I've got it here somewhere
13:07:44 <leimy> http://swtch.com/9vx/
13:08:09 <mmorrow> man, if someone knew how to write a browser plugin, we could have straight haskell (via interpreted bytecode (maybe JITed!)) running in-browser
13:08:36 <leimy> mmorrow:  the google native client plugin can run Haskell binaries
13:08:40 <leimy> possibly a whole OS
13:08:51 <Botje> lol
13:08:53 <mmorrow> holy crap
13:08:55 <Botje> that'd be the day :)
13:08:57 <leimy> it's a plugin that basically emulates an x86
13:08:59 <leimy> it runs quake :-)
13:09:02 <Botje> log on, surf to linux.com, get work done.
13:09:11 <leimy> http://code.google.com/p/nativeclient/?tbbrand=GZEZ&utm_campaign=en&utm_source=en-et-osrcblog&utm_medium=et
13:09:16 <leimy> there you go :-)
13:09:54 <athos> hi
13:10:02 <mmorrow> leimy: wow, i wonder how far this is from an implem. i'd use it tomorrow if i could..
13:10:13 <leimy> version is 0.1
13:10:21 <leimy> but there's binaries for mac, windows and linux
13:10:26 <mmorrow> zomg
13:10:39 * mmorrow starts downloading and reading
13:11:38 <leimy> Totally get House or hOp in there :-)
13:11:45 <Megzlna> Is a string a list literally?
13:11:53 <Deewiant> ?src String
13:11:53 <lambdabot> type String = [Char]
13:11:54 <Vulpyne> Yeah, it's [Char]
13:12:23 <Megzlna> Why would you want to represent strings with an expensive linked list of Cons?
13:12:42 <mmorrow> Megzlna: ByteString is the efficient rep
13:12:43 <Peaker> Megzlna: of Chars, not of Cons
13:12:55 <mmorrow> also, haskell Chars aren't 8-bits
13:12:58 <leimy> Megzlna: because it's convenient?
13:13:00 <Vulpyne> It's easy to work with them, but not so efficient.
13:13:00 <mmorrow> , maxBound :: Char
13:13:04 <Peaker> Does ByteString support unicode directly, or just via explicit encoding on top of it?
13:13:12 <lunabot>  '\1114111'
13:13:14 <pejo> Megz, lots of functions work with lists.
13:13:33 <mmorrow> Peaker: you have to utf8/16 encode/decode yourself with ByteStrings
13:13:34 <Peaker> Can you have an "infinite bytestring"?
13:13:43 <leimy> why not?
13:13:47 <Peaker> so that's another reason, yeah, Strings are already unicode text
13:13:51 <Megzlna> pejo: Even if string had a contiguous representation, I think list functions could work on that.
13:13:53 <mmorrow> no, but you can have an infinite ByteString.Lazy
13:13:57 <Megzlna> a polymorphic base type
13:14:07 <mmorrow> (since L.ByteString = [ByteString])
13:14:07 <Megzlna> where string is a bounded list
13:14:20 <Megzlna> ['a'..] doesn't seem particularly useful
13:14:51 <Megzlna> >['a'..]
13:15:00 <Megzlna> > ['a'..]
13:15:00 <Peaker> > ['a'..]
13:15:02 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
13:15:02 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
13:15:20 <Peaker> > [False..]
13:15:21 <lambdabot>   <no location info>: parse error on input `]'
13:15:47 <Megzlna> [ByteString] ?
13:15:52 <Deewiant> > [False ..]
13:15:53 <lambdabot>   [False,True]
13:16:30 <Peaker> Megzlna: ByteString is sort of an array/list hybrid of Word8 (unsigned int of 8 bits), iirc
13:16:34 <Megzlna> How can [ByteString] use a different impl?
13:16:36 <Megzlna> or does it not.
13:16:39 <pejo> Megz, that requires a special instance of the functions for working on strings since the representation would be different though.
13:16:41 <Megzlna> (no linked list)
13:16:41 <Peaker> Megzlna: its not [ByteString] its ByteString
13:16:53 <Megzlna> I was quoting mmorrow
13:17:03 <Peaker> Megzlna: I think its a linked list of arrays of Word8's
13:17:21 <Peaker> mmorrow: ah, a strict bytestring is just an array?
13:17:33 <mmorrow> Megzlna: there's Data.ByteString and Data.ByteString.Lazy
13:17:34 <Megzlna> Pejo: That can be resolved at compile time
13:17:53 <Megzlna> to only compile static code for those functions being passed a string
13:17:57 <Peaker> mmorrow: ah, a strict bytestring is just an array? and a lazy byte string is a list of arrays?
13:17:59 <orbitz> @hoogle [a] -> Maybe a
13:18:00 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
13:18:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
13:18:00 <lambdabot> Prelude head :: [a] -> a
13:18:16 <mmorrow> Peaker: yeah essentially. a strict ByteString is actually:
13:18:19 <Peaker> why does hoogle bring that last result?
13:18:31 <Peaker> if it was [a] -> b  I'd understand..?
13:18:40 <mmorrow> data ByteString = PS (ForeignPtr Word8) Int !Int
13:18:46 <mmorrow> data ByteString = PS !(ForeignPtr Word8) !Int !Int
13:19:26 <Peaker> mmorrow: so yeah, an array that happens to use ForeignPtr.. How does the array package work, not in the same way?
13:20:32 <pejo> Megz, I guess it hasn't been a priority for researchers. But ByteString exists as an alternative.
13:20:50 <Megzlna> The trouble is appending.
13:20:55 <Megzlna> Which is a very common operation
13:21:05 <mmorrow> Peaker: heh, yeah it's a "C array". the array package uses a diff implem (the /unboxed/ arrays use ghc array primitives, the implems of which are somewhere in ghc's rts)
13:21:34 <mmorrow> but i'm not sure how boxed arrays are implemented
13:21:44 <orbitz> Megzlna: isn't that where lazy lists and the cons cell being a thunk comes in?
13:21:58 <Megzlna> orbitz: example?
13:22:07 <Peaker> mmorrow: I'd hope that the ForeignPtr as array pattern could be abstracted into some data type
13:22:10 <Megzlna> of how I don't suffer from appends?
13:22:19 <Peaker> mmorrow: so you don't smell of C code to get performance :)
13:22:35 <mmorrow> Peaker: the hackage pkg c-array does just that i believe
13:22:46 <mmorrow> (or maybe it's called "carray")
13:22:49 <orbitz> Megzlna: i'm not sure exactlyw hat contexxt you are talkign about.  are you talking about constructing strings?
13:23:04 <Megzlna> Sure
13:23:16 <Friffon> http://hpaste.org/12903
13:23:38 <Friffon> I get an error " Last generator in do {...} must be an expression"
13:23:40 <mmorrow> i believe:   data CArray a = CArray (ForeignPtr a) Int Int  -- offset length  (or something)
13:23:49 <Friffon> for the following code http://hpaste.org/12903
13:23:52 <orbitz> Megzlna: well if you have a function to produce a string, you can just construct the string as you go if the cons cell is a thunk (my terminology might be off) right?
13:23:58 <pejo> Megz, have you profiled a real program and found the appends to be a problem?
13:24:02 <centrinia> Friffon: Add an return (); to the do { .. } block.
13:24:03 <Friffon> does anyone know why that is?
13:24:03 <Vulpyne> Friffon: Every expression has to evaluate to something.
13:24:06 <orbitz> Megzlna: like in the Lazy I/O section of RWH
13:24:15 <Friffon> centrinia: thank you!!
13:24:29 <Vulpyne> Friffon: And the last line you have in your do block is x <- something, which just bind x, it doesn't actually evaluate to anything.
13:24:33 <Megzlna> Pejo: This 'researcher' thing makes me very uneasy.
13:24:47 <centrinia> You could also just print out a string containing the stuff you got from the IO monad. :p
13:25:00 <Megzlna> Orbitz: sure
13:25:11 <orbitz> Megzlna: so appending isn't a problem at that point
13:25:14 <Peaker> mmorrow: so ByteString not using c-array is just historic?
13:25:16 <Vulpyne> Friffon: It looks like your code isn't complete, so if you just want to make the do block return a nil value, add a: return () at the end.
13:25:19 <orbitz> since youa ren't appendign
13:25:32 <Vulpyne> And then the type of the do block will be IO (), and it'll be returning that value.
13:25:57 <centrinia> Should launchMissiles :: Int -> IO (); or launchMissiles :: Int -> (); ?
13:25:58 <Friffon> Vulpyne: thanks
13:26:04 <tibbe> ,src Control.Monad.ap
13:26:06 <Peaker> Megzlna: if appending is very common, don't use a linked list
13:26:06 <leimy> IO ()
13:26:07 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
13:26:17 <tibbe> @src ap
13:26:18 <lambdabot> ap = liftM2 id
13:26:19 <Botje> centrinia: Int -> () of course. nobody would get work done in a language where it's Int -> IO ()
13:26:23 <Vulpyne> centrinia: If it touches the real world, then it's IO. :)
13:26:27 <tibbe> @src liftM2
13:26:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:26:29 <Botje> if your work is destroying valuable civil^Wmilitary targets, that is.
13:26:39 <Megzlna> orbitz: Can you fit that on a few loc of lambdabot?
13:26:46 <mmorrow> Peaker: well, i think ByteString chose to restrict itself to ForeignPtr Word8 in order to do one thing well, but yeah there's no reason why we should be limited to "ByteStrings" of Word8s
13:27:06 <orbitz> Megzlna: doing I/O? no i don't think lambdabot can do that.  See the I/O section of RWH
13:27:43 <mmorrow> , src 'ap
13:27:56 <lunabot>  ap :: forall m a b . Monad m => (m (a -> b)) -> (m a) -> m b
13:28:01 <orbitz> Megzlna: with lazy evaluation.  lists can be used like pipes or streams.  you only evalaute what you need then.  so if you have ane xpression which represents the entire data you just iterate over it to get what you want out of it.  as i understand it atleast
13:28:02 <Peaker> mmorrow: that's not what I meant to ask, but its actually a better question :-) Could be nice if it was generalized to a parameterized type indeed.. Data.List and ByteString are already duplicating a huge API. Might as well duplicate the API for C arrays vs Lists
13:28:04 <mmorrow> "Src" should really be called ":info"
13:28:18 <mmorrow> *"src" ...     (for lunabot)
13:28:20 <centrinia> :t liftM2
13:28:21 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:28:29 <centrinia> :t id
13:28:31 <lambdabot> forall a. a -> a
13:28:43 <centrinia> :t liftM2 id
13:28:48 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
13:29:15 <centrinia> How can liftM2 accept an 1-arity function as its first argument?
13:29:17 <mmorrow> Peaker: yeah i'd love to have a CArray-ish type in the stdlibs. it'd be way convenient
13:29:40 <Peaker> @type liftM2
13:29:41 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:30:00 <Peaker> centrinia: it does?
13:30:01 <noo2hskl> hi, i have this: http://hpaste.org/12902 ... now i want to define something like this IN this function: x ~ z and y ~ z implicate x ~ y for all x,y,z :: Char
13:30:07 <Megzlna> > let f x = x ++ "bar" in f (f (f (f "foo")))
13:30:09 <lambdabot>   "foobarbarbarbar"
13:30:09 <Vulpyne> Behold the magic of currying.
13:30:16 <centrinia> :t liftM2 id -- Yes, it does.
13:30:18 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
13:30:31 <leimy> :t (+1)
13:30:33 <lambdabot> forall a. (Num a) => a -> a
13:30:40 <leimy> :t (1+)
13:30:42 <lambdabot> forall t. (Num t) => t -> t
13:30:48 <Megzlna> orbitz: how do you avoid appends there?
13:30:51 <leimy> :t (1+) 5
13:30:53 <lambdabot> forall t. (Num t) => t
13:31:07 <Megzlna> and not in a canned example
13:31:16 <mmorrow> Megant: yeah, singly-linked lists aren't good for that use-case
13:31:22 <orbitz> Megzlna: you wouldn't since you are explicilty tryign to append.  my agument was that in many situations whre you would normally be appending data, you can do it just via a lazy list evaluation in haskell
13:31:25 <noo2hskl> how do i do this
13:31:26 <Peaker> Megzlna: you use function composition
13:31:36 <Peaker> Megzlna: you build a big function that computes the string, instead of building the string directly
13:31:45 <Peaker> Megzlna: that's what the ShowS type does
13:31:52 <Megzlna> :t ShowS
13:31:53 <lambdabot> Not in scope: data constructor `ShowS'
13:31:59 <Peaker> @src ShowS
13:31:59 <lambdabot> type ShowS = String -> String
13:32:02 <Vulpyne> noo2hskl: I don't understand what you mean by "in" or where you want it, or what you want it to do.
13:32:11 <Peaker> @src shows
13:32:11 <lambdabot> Source not found. Wrong!  You cheating scum!
13:32:15 <Peaker> @type shows
13:32:16 <lambdabot> forall a. (Show a) => a -> String -> String
13:32:27 <Peaker> or IOW:  (Show a) => a -> ShowS
13:32:27 <Raevel> how do i specify that a data constructor only holds eq instances?
13:33:10 <noo2hskl> Vulpyne: you see | c1=='0' && c2=='O' = True  ?
13:33:13 <Peaker> Raevel: With GADT's, you can, I think
13:33:20 <centrinia> Isn't ShowS a continuation?
13:33:22 <Vulpyne> noo2hskl: Yes.
13:33:26 <porges> centrinia: because id is (a->a), and the first argument of liftM2 is (a1 -> a2 -> r), so the type of a1 is forced to be (a2 -> ar). You can see this in the type of 'liftM2 id', where 'm a1' has become 'm (a2 -> r)'
13:33:34 <noo2hskl> Vulpyne: Its like: x ~ y for all x,y in {'0','O'}
13:33:59 <centrinia> porges: Oh.
13:34:02 <Peaker> Raevel: data Blah where Blah1 :: a -> Blah ; Blah2 :: (Eq b, Eq c, Eq d) => b -> c- > d -> Blah
13:34:14 <Megzlna> Why can't lists have an "HeadCons" which stores either 0 or End ptr.. 0 if list has any closure on the end
13:34:15 <centrinia> It inferred that a1 is (a2 -> ar)
13:34:22 <porges> centrinia: yup
13:34:27 <Megzlna> Only used for the 1st element
13:34:28 <Vulpyne> noo2hskl: That doesn't look like Haskell.
13:34:34 <noo2hskl> Vulpyne: Or the first line: | c1 == c2 = True  ... its like: 1.   x ~ x for all x :: Char
13:34:36 <Peaker> Megzlna: you can have a tree instead of a linked list to get cheap appends too
13:34:43 <Peaker> Megzlna: see Data.Sequence
13:34:51 <noo2hskl> no it isnt.. they describe only relations
13:35:21 <Elly> was the "Zygohistomorphic Prepromorphisms" page written as some kind of sick joke?
13:35:22 <Vulpyne> noo2hskl: Well, I'm not familiar with the schema you're using to describe it, but if you describe what you are trying to do in english, I may be able to help.
13:36:26 <smarmy> Elly: partially.  i think it was half tongue-in-cheek, and half exemplifying morphism composition
13:36:40 <Peaker> Megzlna: and about shows, the idea is that if you want to append a bunch of stuff, you can use:  showString "Hello" . showString "Blah" . shows someDataType . shows blah   and "append" more functions to it, and each append is O(1), then when you execute the whole thing you get the whole string at O(N)
13:37:12 <noo2hskl> Vulpyne: Ok I try: I first describe the first relation its easy: x ~ x for all x :: Char ... it means that every Char is similar to himleft.. you understand? .. so i implemented: | c1 == c2 = True
13:38:06 <Vulpyne> With you so far.
13:38:17 <Vulpyne> You're trying to describe similar looking characters?
13:38:50 <noo2hskl> yes
13:38:56 <Peaker> Megzlna: following that?
13:39:37 <noo2hskl> oh i meant himleft = himself
13:39:40 <centrinia> Is this some kind of a sick joke? http://www.haskell.org/haskellwiki/Real_World
13:40:09 <Deewiant> :-DD
13:40:11 <geezusfreeek> hahaha
13:40:19 <leimy> ?src interact
13:40:19 <lambdabot> interact f = do s <- getContents; putStr (f s)
13:40:29 <leimy> hmmm is this not lazy then?
13:40:35 <leimy>  (putStr =<<) . (=<< getContents)
13:40:54 <Vulpyne> noo2hskl: I think I sort of see what you original question was, and I don't think you can do it with a function that just takes 2 chars and returns a bool.
13:40:58 <leimy> :t  (putStr =<<) . (=<< getContents)
13:40:59 <lambdabot> (String -> IO String) -> IO ()
13:41:03 <Toxaris> centrinia: I think its some kind of joke, making fun of #haskell
13:41:12 <Toxaris> centrinia: whats sick about it?
13:41:31 <noo2hskl> Vulpyne: Ok, i thought that too, but how can i do this else? with a new function? but how?
13:41:52 <centrinia> Nothing.
13:41:58 <Peaker> leimy: I guess it depends on how putStr is implemented
13:42:06 <leimy> Peaker:   Yeah but interact works :)
13:42:09 <Toxaris> noo2hskl: I think you have to compute the equivalence classes (the sets of chars similar to each other) and check whether both chars are member of the same class
13:42:19 <Vulpyne> noo2hskl: I think you're going to have to build a list or tree of how similar characters relate to each other.
13:42:20 <leimy> in a way that all my input doesn't appear to be consumed and things aren't doing haywire.
13:42:32 <Vulpyne> noo2hskl: You may still be able to use that existing function for determining raw similarity though.
13:42:36 <Peaker> leimy: that doesn't mean putStr is lazily pulling its string not-at-once
13:42:47 <Toxaris> noo2hskl: you could do that by hand (making lists on paper; and a a lot of cases), or with code (which adds chars to [Char] or better Data.Set Char
13:42:54 <leimy> Peaker:  oh I see now
13:43:03 <leimy> fascinating
13:43:28 <centrinia> Can he just make a function equivClasses :: (Eq a) => (a -> a -> Bool) -> [[a]]
13:43:44 <Toxaris> noo2hskl: the problem is that the transitivity rule is non-deterministic: you cannot "compute" it, because you have to make up the middle element
13:43:45 <noo2hskl> i think you think too complicated
13:43:52 <Peaker> centrinia: I don't think Eq is enough, how do you get all of the a's ?
13:44:06 <centrinia> Oh.
13:44:14 <Peaker> centrinia: with Enum and Bounded too, you could probably
13:44:23 <centrinia> equivClasses => (Eq a) -> (a -> a -> Bool) -> [a] -> [[a]]
13:44:30 <centrinia> :t groupBy
13:44:31 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
13:44:45 <Deewiant> groupBy only works on consecutive elements
13:44:45 <Peaker> :t groupBy . sort
13:44:47 <lambdabot>     Couldn't match expected type `a -> a -> Bool'
13:44:47 <lambdabot>            against inferred type `[a1]'
13:44:47 <lambdabot>     Probable cause: `sort' is applied to too many arguments
13:44:51 <Toxaris> noo2hskl: of course, you could check *all* characters as possible middle elements, but unfortunately
13:45:01 <Toxaris> > maxBound :: Char -- there are a lot of characters, noo2hskl
13:45:03 <lambdabot>   '\1114111'
13:45:07 <Peaker> @type flip groupBy . sort
13:45:09 <lambdabot> forall a. (Ord a) => [a] -> (a -> a -> Bool) -> [[a]]
13:45:16 <centrinia> @pl \cmp -> (groupBy cmp) . (sortBy cmp)
13:45:16 <Peaker> @type flip (flip groupBy . sort)
13:45:16 <lambdabot> liftM2 (.) groupBy sortBy
13:45:17 <lambdabot> forall a. (Ord a) => (a -> a -> Bool) -> [a] -> [[a]]
13:45:40 <dons> ?users
13:45:41 <lambdabot> Maximum users seen in #haskell: 583, currently: 577 (99.0%), active: 25 (4.3%)
13:45:45 <lispy> (a -> a -> Bool) -> [a] -> [[a]] is the form we'd probably use
13:45:46 <dons> hey all.
13:45:50 <Deewiant> ?ty ((>>>) >>> (>>>) (>>>)) groupBy sort
13:45:52 <leimy> hmmm think I need to take this out of IO
13:45:52 <lambdabot> forall a. (Ord a) => (a -> a -> Bool) -> [a] -> [[a]]
13:45:56 <lispy> Just because it partially applies better in most cases
13:45:57 <leimy> and do the Writer thingy
13:46:01 <Peaker> Deewiant: you are evil! :-)
13:46:11 <Deewiant> >:-)
13:46:14 <idnar> ouch, my head :(
13:46:18 <idnar> @type (>>>)
13:46:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
13:46:20 <leimy> now should it be WriterT State or StateT Writer? :-)
13:46:26 <idnar> oh, I was thinking of (&&&)
13:46:38 <Heffalump> leimy: those commute don't they?
13:46:55 <Vulpyne> All questions in #haskell eventually end up with something like "((>>>) >>> (>>>) (>>>)) groupBy sort" appearing. :)
13:47:13 <centrinia> > let equivClasses cmp = (groupBy cmp) . (sortBy ((==Eq) . cmp)) in equivClasses (\a b -> (a-b) `mod` 5 == 0) [0..17]
13:47:15 <lambdabot>   Not in scope: data constructor `Eq'
13:47:30 <lispy> Vulpyne: it's because arrows are great for point free code
13:47:53 <Vulpyne> lispy: I know, it's still funny though.
13:47:56 <centrinia> > let equivClasses cmp = (groupBy ((==EQ) . cmp)) . (sortBy cmp) in equivClasses (\a b -> (a-b) `mod` 5 < 0) [0..17]
13:47:57 <lambdabot>   Couldn't match expected type `a -> Bool'
13:47:58 * lispy nods
13:48:00 <leimy> Heffalump: I'd hope so :-)
13:48:01 <Deewiant> ?ty (flip (.)) (flip (.)) . flip (.) -- the less arrowy version
13:48:03 <lambdabot> forall b c a a1. (a1 -> b -> c) -> (a -> b) -> a1 -> a -> c
13:48:09 <leimy> I'm just wondering what's easier to code :-)
13:48:12 <noo2hskl> let me tell you more.. actually i want do do a similar function its string->string->bool... but at first ill do this on char level with my simChar.. so at the end its like.. "abc" "abc" is similar (trivial) but "ab1" "abl" is similar (ok with one char ok).. but now: "ab11" "abl" is similar .. thats what i need this relation im searching!! i hope you understand
13:48:15 <centrinia> > let equivClasses cmp = (groupBy ((==EQ) . cmp)) . (sortBy cmp) in equivClasses (\a b -> compare ((a-b) `mod` 5) 0) [0..17]
13:48:17 <lambdabot>   Couldn't match expected type `a -> Bool'
13:48:18 <Vulpyne> Sometimes Haskell can make Perl look readable. :)
13:48:26 <leimy> I'm betting I don't want to life the state operators
13:48:30 <leimy> er lift :-)
13:48:43 <allbery_b> "FORTRAN can be written in any language"
13:49:02 <leimy> except FORTRAN
13:49:11 <Vulpyne> noo2hskl: Depending on how simple you want to get, you could just sum the number of True results for a rough idea of similarity.
13:49:37 <centrinia> "Malbolge can be written in any language"
13:49:45 <porges> noo2hskl: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/edit-distance
13:49:52 <porges> for edit distances
13:50:03 <porges> but you'll need to craft your own looks-like
13:52:56 <Cale> Can a Malbolge interpreter be written in Charity? :)
13:53:52 <bjorkLinux> charitably.
13:53:59 <athos> i'm sorry for asking this stupid question but: where's the executable of yi 0.5.2 placed after running runhaskell Setup.lhs configure --user, build, install?
13:54:13 <lispy> athos: under ~/.cabal/bin
13:54:15 <Cale> Actually, due to the finite memory, it probably can, regardless.
13:54:17 <athos> there's nothing new in ~/.cabal/bin, it just installed some lib to ~/.cabal/lib
13:54:25 <centrinia> Is there an extension to GHC that will make it generate intermediate code in Malbolge?
13:54:48 <idnar> centrinia: aaaahhhhhhh!
13:54:49 <jsn> well, the haskell proposals reddit is acting weird
13:55:02 <jsn> nothing i post shows up
13:55:09 <athos> lispy: that's strange, only output was:Installing library in /home/phil/.cabal/lib/yi-0.5.2/ghc-6.8.3
13:55:09 <lispy> athos: in that case, I'm not sure, but you should be able to find it under ./dist somewhere
13:55:12 <athos> + Registering...
13:55:36 <lispy> athos: I don't know anything about yi so maybe it's non-standard
13:55:40 <athos> ok
13:55:56 <lispy> athos: you might check that the .cabal file has an executable stanza
13:55:59 <athos> but what's odd is: cabal install yi-0.5.2 fails because vty requires base > 4
13:56:15 <athos> (but actually hackage says base 3.* is ok)
13:56:23 <Friffon> Hy guys, I've got a function which returns a  'IO Something'  and is a string, how can I take the IO out from it so that it can be read by a function with parameter 'Something'?
13:56:35 <athos> so fetching the tarball and doing it all on my own "works".. well, at least some library gets installed
13:56:51 <centrinia> Why hasn't Charity been updated since 1998?
13:56:57 <lispy> Friffon: do f <- somefunction; <pass f to a function that expects string>
13:57:23 <Friffon> lispy : ok, thanks I'm gonna try that :)
13:58:27 <lispy> Friffon: you're not actually taking the value out of the IO monad, but from inside the IO monad you can pas the value around
13:59:06 <athos> is it at least possible to tell cabal "i don't want the vty frontend, i'll stick with gtk frontend only?"
13:59:12 <athos> so it doesn't fail at some strange lookups?
13:59:42 <porges> why can't there be 'cabal install ghc' :(
14:00:07 <porges> I want 6.10 but don't want to subvert my package manager :P
14:00:21 <lispy> athos: 'cabal install -f -vty' might work, just guessing wildly
14:00:27 <ozy`> porges: I don't mind that, but I'd sure like it if I could do `cabal install frag`
14:01:00 <Cale> Friffon: You should think of a value of type (IO String) as being a program which if run would produce a String (and along the way is allowed to do arbitrary I/O)
14:01:43 <Cale> Friffon: As lispy pointed out, you can run the action by using the do-notation. The result of the do-expression as a whole will be another IO action.
14:02:22 <Cale> Friffon: Eventually, you define main to be an IO action, and the runtime system is responsible for running that one and getting things started :)
14:03:34 <Cale> But just evaluating an IO action does nothing -- you can pass them around and stick them in datastructures, etc, without worrying about them accidentally going off.
14:04:09 <Vulpyne> Oh my god, it's gonna blow! *pop* IO everywhere. :(
14:04:15 <sheyll_> hi
14:05:01 <ozy`> yeah, you can even have a top-level declaration like: foo = putStrLn "DESU DESU DESU"
14:05:02 <leimy> writer vs IO wasn't the problem
14:05:36 <ozy`> and it will never run unless you compose it with other IO monad stuff
14:05:58 <jeffersonheard> http://hpaste.org/12906 -- haddock's complaining about my code formatting
14:07:23 <geezusfreeek> centrinia: Charity is that language based on category theory, right?
14:07:54 <geezusfreeek> i remember looking at it a while ago
14:08:47 <Cale> Charity is similar to Haskell, but it imposes some restrictions on recursion so that all programs terminate
14:09:05 <Cale> (or else run forever without getting stuck)
14:09:35 <geezusfreeek> yeah, a strong model of data and codata
14:09:52 <geezusfreeek> sorry, "inductive and coinductive types"
14:10:14 <Cale> Is that really different? :)
14:10:27 <leimy> ?src take
14:10:28 <lambdabot> take n _      | n <= 0 =  []
14:10:28 <lambdabot> take _ []              =  []
14:10:28 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
14:10:33 <Cale> (well, 'data' means something else to us in Haskell...)
14:10:33 <geezusfreeek> not sure. it seems like when somebody is trying to be very proper they use the long words
14:11:47 <Cale> leimy: Still trying to get a nice version which prompts?
14:11:53 <leimy> ye
14:11:54 <leimy> s
14:11:54 <BMeph> Is it possible, does anyone know, to both derive member functions for a type class, and re-define (some of) them later?
14:11:56 <leimy> :-)
14:12:11 <leimy> I'm trying to write my own take, to pull stuff out of a Writer result.
14:12:16 <leimy> but I'm not sure that'll do it
14:12:44 <Cale> BMeph: no, unfortunately not
14:13:11 <Cale> leimy: hmm, I'm not sure what the difficulty is...
14:13:24 <leimy> Cale: well I'm trying to keep most things out of IO
14:13:38 <Cale> leimy: Well, most of the computation is indeed pure...
14:13:51 <leimy> Cale: http://hpaste.org/12876  <-- the first annotation has StateT IO
14:13:57 <leimy> which just plain does not work.
14:14:10 <Cale> leimy: But shouldn't it look like a little loop in IO which gets the input from the user, and then a pure computation which does all the work?
14:14:20 <Cale> They should be entirely separate.
14:14:33 <leimy> The problem is that IO can terminate early or late
14:14:37 <Cale> hm?
14:14:41 <leimy> because a game of bowling has no pre-determined set of balls.
14:14:53 <leimy> the least it could be is 12
14:14:59 <leimy> the most it could be is 21
14:15:13 <leimy> so I don't know in advance if it's 12 or 21 inputs I need to read :-)
14:15:28 <Cale> Okay. So you could do some computation after each step of the I/O to decide whether more input is needed...
14:15:34 <leimy> I'm  sorry the leastit could be is 11
14:15:36 <leimy> :-)
14:15:50 <leimy> Cale: that's why my original version used Cont.
14:15:54 <Cale> hmm
14:15:58 <leimy> so each frame could return early.
14:16:06 <leimy> using "when"'s
14:16:06 <Cale> That seems like a fancy way to do something simple :)
14:16:10 <leimy> yeah I agree
14:16:37 <jeffersonheard> I take it nobody has any idea why haddock borks on my syntax when GHC doesn't?
14:16:46 <leimy> but once I get an idea in my head to try something...
14:16:52 <Cale> jeffersonheard: Well, they do use different parsers...
14:17:29 <Cale> jeffersonheard: I've had strange results from Haddock at times, where it spuriously left out necessary parens in the output.
14:17:52 <jeffersonheard> here, by the way, is the library for pure functional 2D rendering: http://www2.renci.org/~jeff/software/darcs/Thingie
14:18:10 <jeffersonheard> as a preview.  Will upload to hackage later.
14:18:13 <Cale> Oh, is this part of that?
14:18:16 <mmorrow> @type Map.toList . foldl' (\m x -> Map.insertWith' (++) x [x] m) mempty
14:18:18 <lambdabot> Couldn't find qualified module.
14:18:20 <Cale> I would like to see the rest of the file.
14:18:21 <jeffersonheard> haddock doesn't compile the doc yet
14:18:26 <jeffersonheard> Cale: yes
14:18:40 <mmorrow> > Map.toList . foldl' (\m x -> Map.insertWith' (++) x [x] m) mempty $ [1,4,4,9,3,9,1,3]
14:18:41 <lambdabot>   [(1,[1,1]),(3,[3,3]),(4,[4,4]),(9,[9,9])]
14:18:48 <leimy> Cale: also I was really interested in trying to get this to work with a function that used something like interact or getContents
14:18:49 <mmorrow> > Map.elems . foldl' (\m x -> Map.insertWith' (++) x [x] m) mempty $ [1,4,4,9,3,9,1,3]
14:18:51 <lambdabot>   [[1,1],[3,3],[4,4],[9,9]]
14:18:54 <Cale> jeffersonheard: Is it choking on the space between the cases of the data declaration?
14:19:06 <jeffersonheard> Meant to make a separate package out of the Control.Monad.IfElse as well
14:19:46 <mmorrow> > uncurry (flip replicate) . Map.toList . foldl' (\m x -> Map.insertWith' (+) x 1 m) mempty $ [1,4,4,9,3,9,1,3]
14:19:47 <lambdabot>   Couldn't match expected type `(a, Int)'
14:19:56 <jeffersonheard> Cale: no, it gives me a helpful "parse error" at line 25:9
14:20:00 <mmorrow> > fmap (uncurry (flip replicate)) . Map.toList . foldl' (\m x -> Map.insertWith' (+) x 1 m) mempty $ [1,4,4,9,3,9,1,3]
14:20:02 <lambdabot>   [[1,1],[3,3],[4,4],[9,9]]
14:20:07 <jeffersonheard> the open bracket after the Arc
14:20:23 <jeffersonheard> I like the way my code's formatted.  I'd like not to change it for haddock...  seems like that may be impossible
14:20:54 <Cale> jeffersonheard: What happens if you do change it?
14:21:07 <Cale> jeffersonheard: Try putting the { on the same line as the Arc, and lining things up with that.
14:21:08 <mmorrow> jeffersonheard: the haddock parse error would be in the haddock syntax in a comment
14:21:16 <Cale> oh!
14:21:32 <Cale> Maybe you're not allowed to haddock-comment the constructor itself?
14:21:47 <mmorrow> yeah, new haddock doesn't allow this
14:21:53 <jeffersonheard> mmorrow, thanks
14:22:01 <mmorrow> jeffersonheard: np
14:22:13 <Cale> That's odd though, how are you supposed to document that then?
14:22:24 <mmorrow> yeah it is odd, i'm not sure what the deal is
14:22:42 <jeffersonheard> ahhh much better
14:23:07 <mmorrow> i've just found this to be the case to having to go in and delete the "^"s to make more than a few packages' haddocks build
14:23:28 <mmorrow> *..the case by having ...
14:23:34 <Cale> > group . sort $ [1,4,4,9,3,9,1,3]
14:23:35 <lambdabot>   [[1,1],[3,3],[4,4],[9,9]]
14:23:49 <porges> what haddock should really do is use Language.Haskell.Syntax
14:23:54 <Cale> > map (head &&& id) . group . sort $ [1,4,4,9,3,9,1,3]
14:23:55 <lambdabot>   [(1,[1,1]),(3,[3,3]),(4,[4,4]),(9,[9,9])]
14:24:05 <porges> then parse the comments seperately and connect them using SrcLocs
14:24:16 <mmorrow> Cale: yes, that is indeed shorter ;)
14:24:32 <Cale> Probably faster too ;)
14:24:48 <quicksilver> porges: L.H.S doesn't support all GHC extensions, I think
14:24:59 <quicksilver> I think haddock has been ported to haskell-src-exts
14:25:01 <Cale> (at least, if you don't actually need the map)
14:25:21 <mmorrow> yeah, probably. of course, the Map method though scales to doing more than grouping ..
14:25:25 <Cale> jeffersonheard: That's interesting, you use underscores?
14:25:28 <mmorrow> heh, yeah
14:25:37 <noo2hskl> hello if somebody know my problem.. im trying to do it like this: if (simChar x z) == True && (simChar y z) == True then (simChar x y == True) .. but i dont know where and how to put it in
14:25:42 <leimy> Cale: I just made something weird... but almost closer :-)
14:25:57 <porges> quicksilver:  Language.Haskell.Exts.Syntax then ;)
14:26:07 <leimy> http://hpaste.org/12876#a3
14:26:29 <Cale> noo2hskl: That sounds like a property you could test with QuickCheck
14:26:38 <leimy> All the prompts come out first
14:26:49 <leimy> but it doesn't go forever :-)
14:27:17 <leimy> I think this is as close as I can get with getContents and lines :-)
14:27:28 <Cale> noo2hskl: You might be able to use it to help you define simChar, but it's not itself a definition.
14:27:57 <jeffersonheard> underscores?
14:28:02 <Cale> jeffersonheard: In names.
14:28:11 <Cale> jeffersonheard: Most people use camelCase
14:28:52 <leimy> I like camel_case
14:28:56 <jeffersonheard> I tend to use camelCase for function names and underscores for variable names and record fields
14:29:08 <Cale> leimy: I'm almost certain there's a way to do it, but you have to be exceptionally careful with evaluation order.
14:29:34 <jeffersonheard> that's just me, though.  I always hated camelCase in Java, but that's just because it bothers my eyes in most fonts
14:29:54 <noo2hskl> Cale: so how is that as a definition?
14:30:09 <Cale> noo2hskl: Well, it's not.
14:30:15 <leimy> Cale:  the reason I'm attracted by this is it feels like I can say "there exists an infinite stream of thrown bowling balls"
14:30:19 <Cale> noo2hskl: Lots and lots of functions satisfy that criterion.
14:30:24 <leimy> and that I'm just pulling them from getContents via a parser :-)
14:30:56 <jeffersonheard> no philosphical problem with it
14:30:57 <Cale> leimy: You might be interested in the old way in which Haskell handled IO, before the IO monad.
14:31:17 <leimy> Cale: how was that?
14:31:24 <noo2hskl> Cale: noo really its just a 5point task on third exercisepaper in a haskell learning class
14:31:35 <leimy> I am also beginning to think some FRP techniques could be used here
14:31:48 <noo2hskl> so anyhow you can do this easily.. but i dont know how
14:32:57 <Cale> leimy: Basically, your main was a value of type Dialogue = [Response] -> [Request]
14:33:26 <leimy> looks like event handling.
14:33:42 <Cale> Response and Request were just algebraic datatypes
14:34:04 <Cale> whoa...
14:34:11 <Cale> Haskell 1.0  had   let x k = k x
14:34:20 <Cale> what the... :)
14:34:35 <wjt> ?!
14:34:36 <lambdabot> Maybe you meant: . ? @ v
14:35:06 <leimy> > Just "you wait"
14:35:08 <lambdabot>   Just "you wait"
14:35:55 <porges> leimy: I did something simple with prompting recently
14:35:58 <Cale> 'where' was an expression form
14:36:00 <porges> http://porg.es/blog/simple-socket-programming-with-haskell
14:36:10 <leimy> porges: it's not prompting per se that's the problem
14:36:35 <porges> leimy: just seems you're overcomplicating yourself :P
14:36:39 <leimy> it's the "niceness" of being told that there's a stream of input I can consume lazily from somewhere
14:36:42 <leimy> think of it this way.
14:36:49 <leimy> what if the input suddenly didn't come from stdin
14:36:53 <centrinia> @pl Just cause
14:36:54 <lambdabot> Just cause
14:36:55 <leimy> how much code do I now change?
14:37:33 <leimy> I mean I can stick a handle in a reader and write a function to grab a "line" from the handle
14:37:36 <leimy> and weave it all over the place
14:37:46 <leimy> but i'd be nice to just think [String]
14:37:56 <dblazakis> is there a "webdarcs" for ghc sources?  any easy way to see the changes between two versions over the web?
14:37:56 <leimy> and write a provider of [String] for whatever input mechanism I use.
14:38:04 <byorgey> Cale: what would  let x k = k x  do?
14:38:14 <leimy> I think FRP might have some stuff for that.
14:38:15 <Cale> byorgey: It was just a function definition.
14:38:15 <byorgey> or, maybe a better question, what would it be?
14:38:43 <byorgey> so... x is defined as the function which applies its argument to itself?
14:38:52 <Cale> byorgey: no
14:38:58 <BMeph> go Binary Lambda
14:39:00 <Cale> let is a function
14:39:04 <BMeph> @go Binary Lambda
14:39:12 <lambdabot> http://homepages.cwi.nl/~tromp/cl/LC.pdf
14:39:12 <lambdabot> Title: Binary Lambda Calculus and Combinatory Logic
14:39:14 <Cale> Haskell 1.0 didn't have a keyword 'let'
14:39:20 <byorgey> Cale: ohhhhhhhhhhh
14:39:25 <centrinia> You mean let :: a -> (a -> a) -> a
14:39:36 <byorgey> the light dawns =)
14:39:41 <leimy> lol
14:39:45 <leimy> yeah I was confused by that too
14:40:02 <Cale> let :: a -> (a -> b) -> b
14:40:31 <byorgey> Cale: did you have to actually write 'k' as a function, or was it more like k was an expression where x could occur free?
14:40:45 <Cale> No, it was just an ordinary function in the prelude.
14:40:48 <leimy> Hmmm I suppose I can live with Reader if I need to do this kind of stuff in a really generic way
14:40:52 <byorgey> heh, I see
14:40:54 <Cale> Nothing special about it
14:41:13 <Cale> But 'where' was an expression form at that time, so a 'let' expression would have seemed excessive.
14:41:28 <centrinia> Is that why the current let is not an expression form?
14:41:35 <byorgey> @let let x k = k x
14:41:36 <lambdabot>   Parse error
14:41:39 <Cale> The current let is
14:41:46 <Cale> > let x = 5 in x + x
14:41:47 <lambdabot>   10
14:41:50 <centrinia> @let let' x k = k x
14:41:52 <lambdabot>  Defined.
14:41:59 <Cale> 'where' however, is part of the syntax of declarations
14:42:07 <mmorrow> leimy: what about using something like:
14:42:09 <mmorrow> newtype Step r a = None | Done r | Cont (a -> Step r a)
14:42:11 <Cale> > let' 5 (\x -> x + x)
14:42:13 <lambdabot>   10
14:42:33 <leimy> hmmm can that be newtype?
14:42:39 <leimy> or data only?
14:42:40 <mmorrow> then you get incremental behavior without having to worry about where the input is coming from
14:42:41 <Cale> no, it can not :)
14:42:46 <mmorrow> oops, i meant data
14:43:05 * mmorrow started out with another idea for that line 
14:43:26 <mmorrow> so then you can do:
14:44:25 <mmorrow> runIO :: IO (Maybe String) -> Step r a -> IO (Maybe r)
14:44:48 <zloog> http://hpaste.org/12910 <-- Trying a regex example from RWH but ghci wont let me have =~ return [String]. Any ideas?
14:44:52 <dons> wow, perl has some serious fans who'll rise to any accusatoin that its not general purpose.
14:45:13 <dons> zloog: hmm. oh, new versoin of the regex libs?
14:45:20 <leimy> dons: perl used to be the duct tape of the internet.... probably still is.
14:45:25 <dons> yeah, used to be.
14:45:28 <Sartak> how is perl not general purpose? :)
14:45:34 <dons> duct tape is a specific domain.
14:45:43 <leimy> mmorrow: so then I'd just supply the "Step"'s
14:45:44 <leimy> ?
14:45:45 <zloog> dons: ? I'm running from the 8.04 ubuntu repos. Do you think I need to upgrade for this?
14:45:47 <mmorrow> runIO _ None = return Nothing; runIO _ (Done r) = return (Just r); runIO io (Cont k) = do a <- io; maybe (return Nothing) (runIO io . k) a
14:46:03 <Cale> zloog: Works for me.
14:46:06 <dons> zloog: no, your distro is fine. the version of the regex-posix lib might be suspect though.
14:46:07 <zloog> ?"I, B. Ionsonii, urit a lift'd batch" =~ "(uu|ii)" :: [String]
14:46:08 <lambdabot> Unknown command, try @list
14:46:10 <zloog> ? "I, B. Ionsonii, urit a lift'd batch" =~ "(uu|ii)" :: [String]
14:46:11 <mmorrow> leimy: yeah, you have your function be  String -> Step r String
14:46:12 <BMeph> mmorrow: Was I was talking about yesterday was in ref to that paper I googled - it's a binary coding for LC & CL. :)
14:46:21 <zloog> dons: Whatever ubuntu installed by default
14:46:22 <mmorrow> then finally just wrap that in a Cont and give it to runIO
14:46:24 <Cale> zloog: Which regex-base and regex-posix version do you have?
14:46:32 <dons> ghc-pkg list regex-posix
14:46:33 <Cale> zloog: You should see a line like:
14:46:36 <Cale> Loading package regex-base-0.72.0.2 ... linking ... done.
14:46:36 <Cale> Loading package regex-posix-0.72.0.3 ... linking ... done.
14:46:48 <mmorrow> BMeph: ah, cool. i must have missed the link
14:46:58 <Cale> Ubuntu is always *way* behind on Haskell support.
14:47:09 <zloog> regex-posix-0.93.2
14:47:14 <mmorrow> BMeph: so were you suggesting adding an "interpreter plugin" to lunabot?
14:47:16 <centrinia> Is this accurate? http://curtis.lassam.net/comics/programmers.png
14:47:17 <zloog> regex-base-0.93.1
14:47:25 <Cale> ah, so that's actually newer than what I have installed.
14:47:34 <Valodim_> hahaha
14:47:34 <mmorrow> BMeph: that'd be cool
14:47:40 <Cale> Did you get it from cabal?
14:47:47 <dons> so i wonder if the overloading changed.
14:48:00 <Botje> centrinia: unfortunately, haskell programmers are not ninjas.
14:48:00 <zloog> I used :m +Text.Regex.Posix when I started the session
14:48:06 <Botje> but with haskell, they CAN be :)
14:48:07 <zloog> is there some ghci scoping issue?
14:48:10 <sjanssen> centrinia: heh
14:48:10 <Cale> (I think I got my copy from cabal, but haven't updated it in a long time)
14:48:12 <ozy`> centrinia: I lutzed
14:48:17 <leimy> mmorrow: that's pretty interesting.
14:48:19 <mmorrow> BMeph: er, binary coding? hmm, i'll have to look at that paper because i'm not sure exactly what that is
14:48:20 <BMeph> mmorrow: Yes, specifically, tromp's Binary LC one.
14:48:22 <dons> ?users
14:48:23 <lambdabot> Maximum users seen in #haskell: 583, currently: 566 (97.1%), active: 24 (4.2%)
14:48:29 <sjanssen> centrinia: well, at least #haskell proves there are *some* Haskell programmers
14:48:35 <mmorrow> BMeph: could you link me again?
14:48:44 <Botje> roughly 580 of them
14:48:45 <BMeph> @go Binary Lambda
14:48:49 <lambdabot> http://homepages.cwi.nl/~tromp/cl/LC.pdf
14:48:49 <lambdabot> Title: Binary Lambda Calculus and Combinatory Logic
14:48:52 <BMeph> mmorrow: ^^
14:48:53 <Cale> zloog: Let me see if I can find out what happened to that instance.
14:49:12 <sjanssen> hmm, what would Haskell programmers look like?
14:49:13 <mmorrow> leimy: yeah, i've been using that Step datatype for parsing and it's awesome. you get incremental parsing for free
14:49:20 <mmorrow> BMeph: cool, thx
14:49:25 <Cale> aha!
14:49:28 <zloog> Cale: Thanks, can I ask what resource you would use to look that up?
14:49:30 <ozy`> sjanssen: like this: http://hpaste.org/12898
14:49:41 <centrinia> sjanssen: They would look like Math Professors. :)
14:49:45 <Cale> zloog: Links to haddock documentation on hackage.
14:49:58 <Cale> zloog: They added some newtypes so that you can express what you want better.
14:50:06 <sjanssen> centrinia: yeah.  Draw a couple bearded guys in front of a white board with a bunch of crazy symbols on it
14:50:12 <mmorrow> leimy: and it completely separates your processing from your input (be that IO or from wherever)
14:50:20 <leimy> right
14:50:31 <leimy> I mean I could have a function that just is a big damned string
14:50:39 <leimy> and force it down this thing's channels :-)
14:50:45 <mmorrow> heh
14:50:45 <zloog> Cale: Well looks like I get to be the first to submit and errata then
14:50:54 <centrinia> sjanssen: That would look eeriely similar to the LISP cartoon. :p
14:50:58 <leimy> mmorrow: but can you weave in "prompts" with that?
14:51:23 <sjanssen> centrinia: well, the Haskell guys wouldn't be quite so old -- Haskell has only been around for about 20 years
14:51:44 * byorgey was just writing crazy symbols on a whiteboard not too long ago
14:51:57 * byorgey points out that he also has a beard
14:52:08 <dons> few haskell people are math people, btw. i don't know where this meme comes from.
14:52:10 <leimy> mmorrow: if it was :  "data Step r a = None | Done r | ContT (a -> Step r a) IO " perhaps?
14:52:10 <BMeph> mmorrow: Oh, and I guess I really meant s/coding/encoding and decoding/
14:52:11 <leimy> oops
14:52:19 <ozy`> there are actually dozens of Haskell programmers in that box but you can't see them because they're highly trained ninjas. they're also in all the other boxes, by the way
14:52:21 <dons> math people don't do programming languages, to a first approximation
14:52:38 <mmorrow> leimy: yeah, that's the thing. so it kinda requires that your function be inherently cps-based (in some way). this worked well for me with the parsing because the parser datatype(s) were also cps based
14:52:43 <sjanssen> dons: well, Haskell originally comes from theory people
14:52:54 <dons> who? lennart and spj?
14:52:56 <Cale> zloog: I'm just installing the new versions so that I can be sure about something, and I'll tell you what type to use :)
14:53:03 <sjanssen> dons: so if you wanted to caricature Haskell, drawing some type theory proofs on a whiteboard would make sense
14:53:09 <zloog> Cale: Cool, ty!
14:53:12 <sjanssen> dons: the entire original Haskell committee
14:53:15 <dons> the type system wasn't the priority early on.
14:53:20 <dons> it was people who wanted to run FP languages in hardware.
14:53:31 <dons> the type system only got more important in the late 90s
14:53:33 <mmorrow> leimy: err, i guess not necessarily cps, but a way to freeze the current state of the computation into a new Step r a if it needs more input
14:53:42 <leimy> yeh
14:54:00 <tibbe> @pl >>=
14:54:01 <lambdabot> (line 1, column 1):
14:54:01 <lambdabot> unexpected ">"
14:54:01 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:54:02 <wli> Are there things other than the type system becoming more prominent than it?
14:54:07 <leimy> I'm still feeling the desire to see if FRP has stuff for this :-)
14:54:07 <tibbe> @pl (>>=)
14:54:08 <lambdabot> (>>=)
14:54:11 <dons> parallelism is the hot thing now.
14:54:12 <opqdonut> dons: well haskell people might be math people in the sense that they're "into" math
14:54:13 <tibbe> heh
14:54:29 <opqdonut> not in the sens that they actually study lots of it or research it
14:54:40 * BMeph wants to be drawn as a bearded guy with a "Lambdas 4 life" T-shirt
14:54:41 <ozy`> I wonder how short-lived ruby will turn out to be, given that it doesn't really do parallelism
14:54:42 <tibbe> @pl \s -> e s >>= e2
14:54:43 <lambdabot> (e2 =<<) . e
14:54:45 <mmorrow> and that's a pain unless your function is kinda similar to the "run/eval" function for a datatype of "expressions" that you've used to build up your computation
14:54:57 <leimy> mmorrow: the funny thing is I could write this in IO with forkIO and be pretty happy :-)
14:55:02 <mmorrow> (which is exactly what the parser i used that for looked like)
14:55:02 <Cale> grr... what is with these newtypes where people don't bother deriving basic stuff like Show?
14:55:09 <dons> ozy`: have a look in #rubylang and tell me
14:55:17 <mmorrow> leimy: heh, forkIO is great
14:55:19 <Cale> zloog: anyway:  getAllTextSubmatches $ ("I, B. Ionsonii, urit a lift'd batch" =~ "(uu|ii)") :: [String]
14:55:34 <leimy> mmorrow: yeah.. I mean I can write a little thread that just does IO when asked.
14:55:38 <leimy> and send it back...
14:55:40 <sjanssen> dons: it lists 1 user?  Is that right?
14:55:42 <ozy`> dons: I used to hang out there and its population does seem to be gradually declining
14:55:45 <dons> #ruby-lang
14:55:48 <leimy> and then it won't matter what that thing IO's from
14:55:48 <tibbe> @pl \iter -> e1 iter >>= e2
14:55:49 <lambdabot> (e2 =<<) . e1
14:56:02 <dons> Current: 347.
14:56:04 <dons> ?users
14:56:04 <lambdabot> Maximum users seen in #haskell: 583, currently: 565 (96.9%), active: 24 (4.2%)
14:56:07 <zloog> Cale: Thanks, I'll try to figure out whats going on there a little later
14:56:07 <mmorrow> leimy: ooh, yeah. that's a way to do it too
14:56:13 <Cale> zloog: getAllTextMatches  also works
14:56:22 <Cale> zloog: But works a little differently :)
14:56:40 <leimy> mmorrow: coroutines and threads and continuations and laziness are all related after all :-)
14:56:46 <Cale> http://hackage.haskell.org/packages/archive/regex-base/0.93.1/doc/html/Text-Regex-Base-RegexLike.html#t%3AAllSubmatches
14:56:50 <Cale> zloog: look there
14:56:52 <mmorrow> leimy: this general situation i find very interesting since it's so applicable to pretty much everything i (one) codes
14:57:06 <mmorrow> leimy: yeah, totally
14:57:26 <Cale> zloog: It might be a little confusing, but basically, these types are the overloadings for =~
14:57:27 <ozy`> http://irc.netsplit.de/channels/details.php?room=%23ruby-lang&net=freenode <== hmm, never mind, I guess #ruby-lang's population has been steadier than I thought
14:57:39 <ozy`> er wait that's two weeks
14:57:47 * ozy` falls on sword
14:57:58 <dons> while haskell's is doubling each year
14:58:33 <leimy> yeah but ruby sounds like "booby"
14:58:39 <roconnor> ruby users don't constantly need help like haskell users :P
14:58:44 <dons> hehe
14:58:45 <Cale> That's troubling... if we have 1000 people in here next year, it might get hard to follow
14:58:47 * wli wonders if there are better metrics than IRC channel population, which is easily saturated.
14:58:51 <dons> they figure out monkey patching on their own.
14:59:00 <dons> wli: its hard. but try to find some.
14:59:07 <dons> hackage packages? wiki hits?
14:59:10 <dons> mailing list users?
14:59:15 <dons> rwh rankings on amazon?
14:59:18 <Botje> non-trivial applications?
14:59:21 <dons> downloads?
14:59:23 <Peaker> Cale: The solution? #haskell-oldschool !
14:59:26 <dons> programs on hackage?
14:59:28 <erikc> ruby doesnt have a good implementation, maglev might change that (ruby running on the gemstone smalltalk vm), or ironruby maybe
14:59:37 <Botje> #haskell-oldgeezers and #haskell-youngfolks!
14:59:41 <wli> Aggregate userbases of applications written in the language?
15:00:04 <dons> are we measuring developers?
15:00:09 <leimy> Implement Ruby in Haskell!
15:00:14 <dons> or are xmonad users haskell programmers?
15:00:17 <leimy> using the LLVM bindings
15:00:19 <dons> leimy: been done already.
15:00:24 <ozy`> erikc: 1.9 has a very fast implementation but still has no parallelism to speak of, IIRC
15:00:25 <leimy> dons: yeah...
15:00:38 <dons> ozy`: "very fast" ?
15:00:41 <ozy`> ("very fast" being relative, seeing as it's ruby)
15:00:44 <erikc> haha
15:00:46 <dons> in the sense of "interpreted" :)
15:00:58 <dons> so 2 orders of magnitude slower than ghc code.
15:01:04 <mmorrow> parse acc [c] | c /= '|' = Cont (\s -> parse acc s) | otherwise = Done (reverse acc); parse acc ('|':cs) = Done (reverse acc); parse acc (c:cs) = parse (c:acc) cs
15:01:06 <dons> and not parallel. game over.
15:01:36 <ozy`> dons: which was exactly the point of my original comment...
15:01:38 <ozy`> :p
15:02:00 <erikc> moving ruby to the gemstone vm should help a lot, it will at least get ruby past 1990 levels of smalltalk performance :)
15:02:20 <mmorrow> leimy: so i guess yeah, Steps requires you to work it into your function, so it's not as transparent as being a (String -> String) + lazyIO, but it does have its benefits
15:02:56 <ozy`> erikc: that, and getting MacRuby to production-ready levels
15:03:09 <ozy`> at which point it might replace obj-c
15:03:17 <dons> all the ruby forks remind me of lisp. fragments the people who could work on a runtime.
15:03:18 <ozy`> (yes, this is crazy)
15:03:20 <dons> on the other hand, competitoin is good
15:03:37 <wli> dons: I was thinking of users, not programmers.
15:03:42 <pumpkin> is "order of magnitude" always decimal magnitude?
15:03:52 <Cale> What I don't fully understand is what made Ruby more successful than Smalltalk. If it's just the lack of a persistent environment, such things exist for smalltalk as well.
15:03:52 <wli> dons: Something that weighs both of them might be a good idea.
15:04:04 <leimy> mmorrow: cool
15:04:56 <leimy> dons: there's lots of schemes in particular :-)
15:05:02 <ozy`> Cale: ruby was seen as fixing the problems with perl, not the problems with smalltalk. (and since it's less expressive than smalltalk, that's as it should be)
15:05:11 <smarmy> i think its ruby's close ties to perl, familiar syntax, timing, and rails
15:05:41 <leimy> no one will replace Objective-C from apple's perspective, I bet :-)
15:06:11 <dons> yoric, mfp. is #ocaml moving in?
15:06:25 <dons> mfp: you guys just working out what we're up to? or considering switching runtimes ? :)
15:06:35 <leimy> lol
15:06:46 <teko1> sup peeps
15:06:46 <leimy> it turns out ocaml was cancelled
15:06:48 <Cale> I suppose most people don't really try very hard to be aware of the available programming languages for some reason.
15:06:52 <ozy`> also, all the poor Java kids who had OOP beaten into them saw the bits of pseudo-smalltalk shining through and went "wwooooooowowww"
15:06:55 <ddarius> Cale: Perhaps the fact that most quality Smalltalk implementations were commercial (among other things)?  (Not that Ruby is a quality implementation...)  Timing is probably the largest part.
15:06:55 <Cale> teko1: hello!
15:07:10 <teko1> if clean is faster than haskell, why shouldnt i use it ?
15:07:27 <dons> its not faster, has no libraries, has no community, isn't well supported, and doesn't have smp support.
15:07:28 <leimy> Clean seems like, in some ways, it might even be easier to use than Haskell
15:07:28 <smarmy> Cale: i don't think people, in general, try very hard.  the folks that frequent chat rooms like this are not the majority
15:07:30 <dons> how's that?
15:07:42 <dons> it was the last of the research languages that didn't turn into haskell.
15:07:46 <Cale> dons: That might be a little harsh
15:07:48 <dons> though possibly ocaml will be the last of them.
15:07:50 <ddarius> teko1: Assuming that is true, then if speed is your only criterion, you should use Clean.
15:07:59 <dons> well, seriously, there's no way you're going to use clean in a project now.
15:08:03 <teko1> dons: smp ?
15:08:05 <Cale> Last I checked, Clean actually did have a little community.
15:08:05 <ozy`> teko1: go to #clean and ask for help with stuff
15:08:06 <ddarius> dons: Clean was less of a research language.
15:08:10 <dons> it was less.
15:08:16 <dons> but they failed on community building ultimately.
15:08:24 <ozy`> teko1: then come back here
15:08:25 <leimy> I don't think it helps that SPJ calls Haskell a research language :-)
15:08:30 <teko1> lol ozy`
15:08:34 <teko1> theres no1 there
15:08:40 <sjanssen> leimy: why is being a research language bad?
15:08:42 <ozy`> teko1: there's your answer
15:08:44 <Cale> But yeah, there's no arguing that Haskell isn't way more well-supported.
15:08:47 <dons> teko1: where's clean on this list, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
15:09:04 <Cale> teko1: All the cool features are going into Haskell these days.
15:09:15 <Cale> teko1: Because there are more researchers working on it.
15:09:22 <dons> you could try using Clean.
15:09:27 <ozy`> teko1: not to endorse mob mentality but if you were to actually sit down and work on a project you're better off with an actual community
15:09:29 <teko1> its on this one: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
15:09:33 <dons> i think you'd come running back here after 5 minutes, due to lack of support.
15:09:34 <Cale> (however, the size of the community is possibly starting to hurt that)
15:09:36 <dons> but worth trying.
15:09:38 <leimy> sjanssen: it makes it a little more difficult to get people to commercialize don't you think?
15:09:50 <sjanssen> leimy: not necessarily
15:09:54 <dons> teko1: that's an out of date page.
15:09:58 <teko1> oh
15:09:59 <dons> the gp4 results are deprecated.
15:10:09 <BMeph> Is a "research language" a language *in* which research is done, or one *on* which it is done? ;)
15:10:09 <Cale> I wouldn't recommend picking a language solely on the basis of the size of its community.
15:10:18 <sjanssen> leimy: Haskell has the nice model of developing new language extensions while still offering backwards compatibility
15:10:19 <dons> its a decision in multiple dimensions
15:10:31 <ddarius> BMeph: Usually both.
15:10:34 <dons> libraries, performance, community, support, documentation, stability, etc.
15:10:39 <pumpkin> Cale: one of the things that made haskell so attractive to me (besides it being awesome) is this channel
15:10:52 <sjanssen> leimy: GHC still supports Haskell '98 by default, but you can also turn on the new stuff like GADTs and type families if you'd like
15:10:54 <pumpkin> @users
15:10:54 <lambdabot> Maximum users seen in #haskell: 583, currently: 567 (97.3%), active: 27 (4.8%)
15:11:03 <dons> the communtity effectively mitigates the support risk that say, you would pay MS for if using a commercial language.
15:11:08 <teko1> doesnt the fact that haskell has been used for research so long bother anyone ?
15:11:10 <dons> so if you go open source, better pick one with a decent community.
15:11:13 <dons> teko1: ?
15:11:14 <Cale> I actually have a bit of a hope that a new purely functional programming language will emerge soon.
15:11:15 <smarmy> pumpkin: agreed.  this channel has had a *huge* impact on my opinion of Haskell over the years
15:11:23 <pumpkin> teko1: it makes me happy ;)
15:11:25 <dons> teko1: research, open source, and industry. that's good.
15:11:36 <dons> research means quick access to cool stuff. so that's good.
15:11:39 <ozy`> teko1: why would that bother people?
15:11:46 <ozy`> seriously I'm curious
15:11:46 <pumpkin> Cale: with dependent types!
15:11:58 <teko1> research means theyre still fixing the problems with haskell ?
15:12:04 <dons> hmm?
15:12:10 <pumpkin> teko1: research means they aren't sitting complacently saying "it's done"
15:12:13 <dons> no, the research is about new stuff for problems with *programming*
15:12:14 <Cale> pumpkin: Well, yes, possibly :)  I wouldn't want to give up on type inference of course.
15:12:18 <teko1> i mean c++ is not in research
15:12:20 <dons> like say, "paralellism is hard"
15:12:27 <teko1> oh
15:12:29 <dons> the research is about making things like that easier.
15:12:35 <dons> so haskell has, e.g. transactional memory
15:12:39 <mmorrow> tekol: it means still think of and implementing novel concepts in the lang
15:12:40 <ddarius> teko1: Does "not research" mean they aren't fixing the problems?
15:12:41 <dons> because of research
15:12:41 <Cale> pumpkin: I would like a dependently typed language which has a large core with complete type inference.
15:12:43 <sjanssen> teko1: that isn't true, see C++0x which wants to add all kinds of radical new features to address old shortcomings
15:12:56 <dons> "problems" means bug fixes. like the problems with say, ruby
15:13:00 <pumpkin> Cale: +1 from me :P
15:13:03 <ozy`> teko1: so C++ has no problems and is now perfect? ;)
15:13:10 <mmorrow> Cale: i would /love/ a dependently-typed lang that i could use for everything
15:13:17 <dons> teko1: anyway, so you tossing up between clean and haskell?
15:13:18 <Cale> pumpkin: I would also like a language which is more aware of category theory.
15:13:18 <teko1> i thought so ozy`
15:13:21 <dons> for a high performance language?
15:13:26 <wli> sjanssen: The chains of backward compatibility.
15:13:27 <dons> or are there other constraints?
15:13:27 <teko1> not anymore dons
15:13:34 <dons> did you ask in #clean?
15:13:38 <ozy`> teko1: C++ is fast. that's... about all it's got
15:13:39 <teko1> ye
15:13:44 <dons> what did they say?
15:13:45 <ddarius> Cale: Write some code in this language.
15:13:46 <teko1> they pleading 5th
15:13:47 <pumpkin> are there any plans to add dependent types to ghc directly?
15:13:49 <mmorrow> tekol: i looked at the code to the Clean compiler once and wanted to shower afterwards :)
15:13:51 <dons> oh. ok.
15:13:53 <dons> ?users
15:13:53 <lambdabot> Maximum users seen in #haskell: 583, currently: 567 (97.3%), active: 27 (4.8%)
15:13:58 <Cale> ddarius: and then hope that someone will write me a compiler? :)
15:13:59 <QtPlatypus> ozy`: And if you wish speed why not C
15:14:04 <ddarius> Cale: Yes.
15:14:04 <ozy`> QtPlatypus: exactly!
15:14:10 <Cale> ddarius: That's an idea :)
15:14:24 <ozy`> (or another of the thinly veiled C variations)
15:14:37 <teko1> so for multicore programming haskell is better than erlang ?
15:14:49 <ddarius> Cale: I'm still not sure what you're expecting such a language to look like.
15:14:53 <dons> shared memory multicore? its faster. and has more options.
15:14:54 <mfp> teko1: if you're doing multicore for speed, there's no point in using Erlang
15:14:59 <dons> elrang's a different domain.
15:15:08 <dons> fault tolerant clusters, for example.
15:15:17 <pumpkin> I still want a good distributed haskell option :P
15:15:19 <mfp> yes
15:15:32 <ddarius> pumpkin: Make one.
15:15:39 <mmorrow> tekol: i wanted to see if Clean was as fast as they say, but didn't even manage to get much working (didn't try /too/ hard, but put a good hour into it)
15:15:42 <dons> pumpkin: the deutsche bank team has a "haskell/otp"
15:15:46 <dons> we need to get them to release it.
15:15:56 <pumpkin> ddarius: maybe one day :P I'm still a dumb n00b
15:16:00 <kowey> yuck: what do I do when I face weird linker errors like this? http://hpaste.org/12911
15:16:00 <pumpkin> maybe the n00b bit will go away someday
15:16:07 <dons> mfp: so you and yoric are in here. switching teams? or ... ?
15:16:14 <dons> just taking notes?
15:16:15 <mfp> uh?
15:16:16 <pumpkin> kowey: --make
15:16:21 <dons> oh, yoric was in here earlier.
15:16:25 <teko1> would u say a greater percentage of programmers use FP now as opposed to 20 years ago ?
15:16:26 <mfp> been on the channel for months
15:16:27 <ozy`> teko1: Erlang is for running programs across multiple machines, so its design doesn't scale down as well
15:16:29 <sjanssen> kowey: looks like you forgot a -package flag
15:16:43 <mfp> there are more ppl on both channels, does that surprise you?
15:16:44 <ozy`> and yes, FP is everywhere now, even in imperative languages
15:16:47 <mmorrow> also, i noticed that a large part of Clean (rts?) is *hand coded* asm
15:16:54 <ddarius> teko1: Quite possibly not as there are no doubt -way- more programmers.
15:16:54 <kowey> sjanssen: hmm... does it matter that I'm using Cabal here?
15:16:56 <pumpkin> mmorrow: why is that?
15:17:04 <dons> mfp: usually we don't see many ocaml people. there's some overlap, but not at  the top.
15:17:05 <mmorrow> so that probably has something to do with it being fast
15:17:10 <mmorrow> pumpkin: beats me :)
15:17:15 <dons> mfp: just curious is all.
15:17:24 <mfp> "at the top"?
15:17:24 <mmorrow> (other than they're going for speed above all else)
15:17:26 <Pseudonym> Seems like proof to me that Clean is a poor language for writing DSLs in.
15:17:29 <kowey> sjanssen: I'm trying to build a package "GenI" which depends on my other package "libGenI"
15:17:31 <dons> mfp: the very active people.
15:17:39 <mfp> oh
15:17:42 <kowey> the latter cabal installs just fine...
15:17:44 <dons> and i'd say you and yoric are the dons and cale's of ocaml :)
15:17:54 <sjanssen> kowey: might possibly mean you forgot something in build-depends, or maybe the package containing "Gen.*" is busted
15:17:56 <mfp> heh
15:18:09 <ddarius> Which one is dons and which is Cale?
15:18:09 <pumpkin> sjanssen: is there a c++filt for haskell symbols btw?
15:18:13 <Cale> ddarius: Well, to be honest, the details are still a little fuzzy in my head.
15:18:22 <mfp> dons: just because I submit a few things to reddit? (like 1/5th as many as you?)
15:18:28 <mmorrow> well, i should say "there a rather large file or three with hand-coded asm", rather than "a large part of Clean (itself)"
15:18:32 <sjanssen> kowey: perhaps you forgot to list some exposed/hidden modules in libGenI's cabal file?
15:18:38 <mmorrow> but still, same diff
15:18:42 <ddarius> Cale: That's why you should figure out what you would want the code to look like.
15:18:52 <dons> mfp: and you try to get people working on things (batteries et al).
15:18:56 <kowey> sjanssen: hmm, not the ones that are mentioned there... but I'll double check
15:18:59 <Pseudonym> mmorrow, what do those parts do?
15:19:03 <ddarius> mfp: 1/5 as many as dons would still be a lot.
15:19:16 <Cale> ddarius: But, for instance, it upsets me that in the current situation, we have a typeclass Monad which says what it means to be a Monad on Hask, but that definition can't be applied to other subcategories of Hask.
15:19:23 <mfp> ddarius: I was exaggerating a bit :)
15:19:23 <kowey> (although surely if it I was failing to expose a module, it would have complained on build time)
15:19:26 <mmorrow> Pseudonym: i'm not sure and don't recall really, but i'm curious mow that i think of it. i'm gonna bdig up my Clean sources
15:19:42 * mmorrow can't type to save his life
15:19:46 <dons> there's 5x as many articles on haskell though. so hey, not my fault.
15:19:57 <tibbe> @src ap
15:19:57 <lambdabot> ap = liftM2 id
15:19:58 <wli> I'm of the opinion there should be different languages for different purposes.
15:20:03 <mfp> fair enough
15:20:06 <sjanssen> preflex: zdec libGenIzm0zi17zi1_NLPziGenIziBuilder_
15:20:06 <tibbe> @src liftM2
15:20:06 <preflex>  libGenI-0.17.1_NLP.GenI.Builder_
15:20:07 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:20:09 <dons> we have a bigger blogging community. it becomes self sustaining after a while.
15:20:09 <kowey> sjanssen: all modules accounted for :-(
15:20:48 <mfp> _but_ you also make full use of any Haskell thing you get hold of
15:20:51 <mfp> I mean
15:20:53 <sjanssen> kowey: how about NLP.GenI.Builder?
15:20:54 <ddarius> dons: The bloggers stimulate each other starting solitons of information travelling in cycles?
15:21:08 <kowey> sjanssen: yep
15:21:17 <mfp> hackage page, project homepage, ML announcement AND blog posting heh
15:21:19 <dons> ddarius: yes. you see that.
15:21:20 <mmorrow> ok, yeah. i /under/exagerated. Clean's rts looks to be 80% hand-coded asm
15:21:29 <dons> mfp: yes.
15:21:41 <dons> well, i didn't do that. i posted the first thing i saw (hackage page)
15:21:45 <dons> then today it was announced.
15:21:48 <dons> some of the devs posted other stuff
15:21:57 <dons> so really i should have held off assuming they were about to announced.
15:22:10 <sjanssen> kowey: I'd clean and reinstall the libGenI package, then "Setup clean" your other package and attempt to build it again
15:22:17 <kowey> ok!
15:22:22 <mfp> have to confess I downmodded the last 2 timber submissions; 4 in 1 day seemed too many
15:22:38 <dons> people were excited. it's been a subterranean project for almost a decade now.
15:22:46 <dons> but finally, hackage was the incentive to get it all in the open.
15:22:51 <wli> I'm trying to guess what the "ML" in "ML announcement" is supposed to be. I'm thinking of the FP language at first blush.
15:23:00 <mfp> mailing list
15:23:04 <Cale> I wonder if something like Omega could solve the problems. I should really take a closer look at languages with richer kinds.
15:23:05 <pumpkin> machine learning! ;)
15:23:09 <leimy> anyway, had to take a call... I think there's a connotation communicated when someone of SPJ's stature says the language is for research :-)
15:23:22 <dons> mfp: you should look at jdh's downmods page :)
15:23:25 <pejo> dons, well, hackage is nice in many ways, but there wasn't a working compiler before - that was probably a bigger factor.
15:23:35 <dons> pejo: yeah. :)
15:23:39 <wli> dons: There are too many threads going. Which subterranean project is this?
15:23:40 <kowey> sjanssen: that fixed it! thanks! grumpiness averted
15:23:57 <dons> that helps. but also i'm really happy about thegeneral trend of research projects being open source released, like all the open source projects.
15:24:04 <dons> so sulzmann , timber , all on hackage now.
15:24:14 <dons> the research side of the fence seems to be getting it.
15:24:22 <sjanssen> kowey: yeah, you have to always remember to "Setup clean" after changing a depended project, GHC and Cabal don't notice that it has changed
15:24:33 <mfp> dons: btw. I think jdh is switching fully to F# now :)
15:24:37 <sjanssen> kowey: we used to run into this with xmonad all the time
15:24:39 <leimy> anyway, my erlang background makes me think of things in terms of forkIO a LOT
15:24:45 <ddarius> pejo: SPJ is a language researcher.
15:24:55 <dons> mfp: i think so. he's turning the cannons back on you.
15:24:58 <leimy> and my Plan 9/Inferno background makes me want to think about using typed data channels for communications.
15:25:03 <dons> mfp: its ok though. his book sucks and no one buys it :)
15:25:11 <kowey> I'll try to remember that... I had indeed removed some filepath-type stuff in favour of the real filepath package
15:25:19 <Saizan_> sjanssen: 6.10 with the ABI hash should, maybe?
15:25:23 <kowey> and I did cabal install again in libGenI
15:25:25 <pejo> ddarius, sorry?
15:25:33 <mfp> it's been a slow evolution, but his current view is that OCaml is two orders of magnitude too slow or something
15:25:33 <mmorrow> Pseudonym: ok, i just uploaded the Clean srcs here (and the server has default text/plain). Clean's RTS: http://moonpatio.com/repos/Clean/RuntimeSystem/
15:25:38 <kowey> which evidently was not enough (need cabal clean first)
15:25:40 <ddarius> pejo: Oops, that was meant for leimy.
15:25:41 <dons> mfp: jdh is a burden.
15:25:47 <sjanssen> Saizan_: yeah, I think they added it because of our whining :)
15:25:49 <leimy> ddarius: yes. :-)
15:26:08 <dcoutts> sjanssen: I think in 6.10, ghc --make does notice dependent packages have changed
15:26:20 <ozy`> mmorrow: GREAT SCOTT
15:26:43 <teko1> is ATS a high-level lang ?
15:27:05 <dons> teko1: hmm. what do you think looking at it?
15:27:05 <dcoutts> teko1: if I remember which one it is, it's C but with a stronger type system
15:27:06 <sjanssen> mfp: F# is faster than OCaml?
15:27:08 <teko1> it doesnt look like it from the quicksort implementation : http://www.ats-lang.org/EXAMPLE/MISC/listquicksort.dats
15:27:14 <leimy> F# is kind of cool
15:27:16 <mmorrow> here's a/the marking part of Clean's gc (it looks like) http://moonpatio.com/repos/Clean/RuntimeSystem/scompact.s
15:27:20 <mfp> sjanssen: in general, no (it's usually slower)
15:27:25 <dons> sjanssen: i find it hard to imagine, honestly. all that extra overhead.
15:27:25 <leimy> I kind of wish there was just Haskell .NET
15:27:28 <mmorrow> that's definitely hand-coded and not generated
15:27:34 <ozy`> teko1: are you looking for excuses not to learn Haskell? :p
15:27:35 <dons> leimy: used the .net bridge?
15:27:46 <leimy> dons: I mean on the same level as F#
15:27:48 <teko1> no im just checking out the landscape
15:27:52 <leimy> bridges can break :-)
15:27:53 <baaba> teko1, it's very verbose because it contains a formal proof of correctness
15:27:57 <sjanssen> mfp: ah, so just the standard JDH reality distortion field
15:28:01 <mfp> sjanssen: but jdh has found some niche where JIT + SMP + some .NET stuff makes it faster than OCaml
15:28:18 <porges> leimy: have added to your hpaste with what I was thinking of
15:28:19 <dons> mfp: [citation needed] though, for jdh as usual.
15:28:19 <mmorrow> ozy`: great scott is right :)
15:28:19 <sjanssen> mm
15:28:27 <porges> leimy: not complete ;)
15:28:28 <leimy> porges: thanks!  I'll take a look.
15:28:28 <dons> its all secret proprietary inside quotes
15:28:31 <leimy> porges: that's ok.
15:28:56 <mmorrow> on the other hand, it's cool reading hand-coded asm.
15:28:57 <teko1> it seems FPs are the only high performing high level langs
15:29:07 <dons> teko1: static typing + native code.
15:29:14 <pumpkin> we need more people contributing to our new haskell projects reddit!
15:29:20 <ddarius> leimy: That would require twisting Haskell quite a bit or extending it significantly (and cleverly)
15:29:27 <dons> pumpkin: you've advertised it to noone.
15:29:37 <pumpkin> dons: that was my lame attempt there ;)
15:29:38 <mfp> teko1: also, building compilers is easier with FP ;)
15:29:39 <dons> pumpkin: is it linked from haskell.org's libraries and apps page, and mentioned on haskell-cafe ?
15:29:41 <Nafai> pumpkin: Is this different from the regular haskell reddit?
15:29:44 <dons> pumpkin: did you announce it on the normal reddit?
15:29:57 <dons> integration!
15:30:02 <pumpkin> :P
15:30:04 <Peaker> teko1: I'd say that statically typed languages are the only high-performing languages, its more about static knowledge than about FP, I think
15:30:10 <pumpkin> yeah, I'm not a good promoter
15:30:14 <mapreduce> Is this the haskell subreddit?
15:30:16 <dons> Peaker: FP is the high level aspect
15:30:23 <ddarius> mmorrow: Write in assembly, then you can always be reading some hand-coded assembly.
15:30:29 <ozy`> teko1: part of the reason for that is that making a language "high-level" at some point necessitates using functional idioms... which, by the way, are much easier than imperative idioms for a compiler to optimize
15:30:32 <Peaker> dons: then that's tautology :)
15:30:34 <mapreduce> The topic between dons and pumpkin I mean, not this channel.
15:30:34 <dons> pumpkin: integration thoug, isn't promotion. you just have to together the parts better.
15:30:41 <teko1> then y cant we get a statically typed python ?
15:30:47 * tibbe declare victory of Applicative
15:30:49 <dons> its dynamically typed?
15:30:52 <pumpkin> mapreduce: it's the haskell proposals reddit
15:30:54 <Peaker> dons: High-level languages are the only high-performing high-level languages
15:31:00 <mapreduce> teko1: Typing after the fact is usually broken.
15:31:04 * tibbe declare victory *over* Applicative
15:31:06 <ozy`> teko1: there is one
15:31:08 <mapreduce> TAPL discusses this.
15:31:11 <ozy`> IIRC it's called Boo
15:31:17 <ozy`> but I think it was abandoned
15:31:23 <mapreduce> Boo is untyped iirc.
15:31:34 <Philippa_> Peaker: dynamic languages can go a surprisingly long way
15:31:40 <ozy`> mapreduce: I thought so too but apparently it uses type inference
15:31:54 <mmorrow> ddarius: but write an entire rts for a lang in asm? pain.
15:32:02 <mfp> Philippa_: it just takes much more effort
15:32:11 <ddarius> mmorrow: You tend to have different kinds of pain using, say, C instead.
15:32:13 <Peaker> Philippa_: he said FP, not static
15:32:16 <ddarius> mmorrow: Assembly is fun.
15:32:19 <Philippa_> mfp: yes'n'no
15:32:24 <mmorrow> ddarius: but reading an entire rts written in asm? joy.
15:32:27 <colouragga> asm is fun like eating with chopsticks
15:32:34 <pumpkin> eating with chopsticks is fun
15:32:37 <mmorrow> ddarius: yeah, i like asm
15:32:38 <Philippa_> Peaker: you didn't, however
15:32:38 <colouragga> it is
15:32:41 <mapreduce> ozy`: Hmph, right you are.
15:32:42 <tibbe> @ pl \f -> fmap (fmap f)
15:32:49 <pumpkin> I don't like writing asm, but reading it can be fun
15:33:00 <tibbe> @pl \f -> fmap (fmap f)
15:33:01 <lambdabot> fmap . fmap
15:33:08 <pumpkin> dons: http://www.reddit.com/r/haskell/comments/7igcj/a_new_reddit_for_submitting_and_voting_on_project/ how's that? :P
15:33:14 <wli> Well, defining FP is already somewhat problematic.
15:33:16 <pumpkin> (I'm new to reddit)
15:33:36 <dons> good!
15:33:51 <leimy> porges: very cool
15:33:57 <dons> pumpkin: now, you need to announce what you're trying to do on haskell-cafe@, and link to it from haskell.org's existing 'please submit projects' page
15:34:10 <mmorrow> ddarius: (the machine-dependence of coding the whole thing in asm aside)
15:34:17 <pumpkin> dons: oh no, I'm scared of posting to haskell-cafe
15:34:19 <teko1> how robust is the serial io lib for haskell ?
15:34:26 * pumpkin hides
15:34:30 <Peaker> Philippa_: He said FP are high-performing (as opposed to non-FP)
15:34:34 <dons> pumpkin: hmm...
15:34:36 <ddarius> mmorrow: Meh, most of my programs only ever run on one machine anyway and failing that only run on one architecture.
15:34:36 <porges> leimy: only problem is you have to signal end-of-input via ^D, but you could filter in the interactLines function if you wanted
15:34:44 <pumpkin> jsn: you should do it! it's your reddit :)
15:34:59 <Peaker> Philippa_: Are Java/C# or C++ "high-level languages"?
15:35:13 <erikc> hrm, what hackage category is appropriate for a quasiquoter for ruby-style interoplated strings?
15:35:13 <leimy> porges: yes...
15:35:28 <leimy> porges: maybe it could be "interactFrames"
15:35:35 <leimy> since we know we need 10 frames :-)
15:35:37 <Philippa_> Peaker: you said "I'd say that statically typed languages are the only high-performing languages, its more about static knowledge than about FP, I think"
15:35:39 <dons> erikc: Text
15:35:42 <leimy> which is a variable number of balls
15:35:47 <dons> erikc: look for other preprocessors
15:35:59 <mmorrow> ddarius: but the rts for a language i'd hesitate to tie to a single arch
15:35:59 <wli> But define FP!
15:36:01 <Philippa_> Java/C# and C++ aren't as high-level...
15:36:04 <teko1> has anyone here used the serial io lib for haskell ?
15:36:13 <Peaker> Philippa_: oh, right :)  Still, even tricksy-optimized dynamic languages probably don't perform as well as statically-typed equivalents?
15:36:13 <Philippa_> OTOH, you also need to consider smalltalk-like languages
15:36:19 <ddarius> mmorrow: Usually they are (albeit less so).
15:36:25 <ozy`> Java/C#/C++ are not considered "VHLLs"
15:36:29 <dons> teko1: for serial ports?
15:36:31 <solrize> peaker, there are some scheme compilers that do pretty well
15:36:32 <ozy`> by the pundits, that is
15:36:32 <dons> teko1: what libs is this?
15:36:34 <teko1> ye
15:36:36 <teko1> com ports
15:36:38 <ddarius> mmorrow: You just write a different RTS for a different architecture.
15:36:40 <Peaker> solrize: partial type-inference?
15:36:43 <jsn> pumpkin: okay, i'll do it
15:36:44 <ozy`> (pundits who don't know about FP)
15:36:44 <dons> teko1: wihch lib are you talking about?
15:36:47 <leimy> porges: the problem with interactFrames of course means that one can't just take a big string :-)
15:36:55 <teko1> i dunno the standard one ?
15:36:55 <Philippa_> Peaker: they can get close enough
15:37:03 <mmorrow> ddarius: yeah, but if it's in asm, you'll have to rewrite *everything*
15:37:04 <mapreduce> Philippa_: How do you define high level?
15:37:06 <teko1> i just need something that works
15:37:07 <pumpkin> dons: which please submit projects page are you talking about? http://haskell.org/haskellwiki/Haskell.org_domain is the only thing I can find
15:37:09 <leimy> but one could write a function to write interactFrames for me probably.
15:37:21 <mmorrow> even "4 + 2" will have to be rewritten
15:37:28 <porges> leimy: interactFrames could be something like interactLines f = getContents >>= mapM_ putStr . f . ((take 10)) . lines
15:37:30 <porges> no?
15:37:30 <ddarius> mmorrow: But then you can micro-optimize -all- of it.
15:37:39 <mmorrow> hehe, the fun part
15:37:47 <mfp> solrize: stalin? would like to know how it compares against e.g. MLton
15:37:48 <leimy> porges: yes... (take 10) . getFrames . lines
15:37:58 <Peaker> Philippa_: Still, the only charateristic I think you can really associate with the performance of the best implementations' of a given language is static-ness. The more static-ness the compile can squeeze out of it, the less it has to do at runtime. I don't think FP has to do with it, except perhaps facilitating more static-nesws
15:37:59 <leimy> and then have a function to process those frames.
15:38:06 <dons> pumpkin: yes, this is why the wiki approach failed. http://haskell.org/haskellwiki/Wanted_libraries
15:38:06 <wli> mapreduce: I'd ask the same.
15:38:07 <tibbe> I have a instance (Functor m, Monad m) => Applicative (Foo m) but I suspect I could reduce the context from Monad m to Applicative m, anyone care to take a look?
15:38:11 <mlesniak> dons: I'm a xmonad user but not a haskell programmer, just a beginner ;)
15:38:13 <dons> pumpkin: and you can pre-popualte from that page.
15:38:16 <pumpkin> dons: thanks :)
15:38:18 <ozy`> mapreduce: the consensus a few years ago was: Java, C#, and C++ are "medium" level, whereas Ruby and Python are "very high level" and FP does not exist.
15:38:20 <Philippa_> mapreduce: I tend to use the Perlis definition, give or take
15:38:28 <mmorrow> yeah, writing everything in asm i suppose would be ideal, but then there's that whole feasility annoyance ;)
15:38:30 <mfp> whole-program compilation, dynamically vs. statically typed
15:38:31 <dibblego> tibbe, replace fmap with liftM (Monad should already imply Functor, but doesn't ala broken)
15:38:36 <leimy> porges: actually, the thing is, my other program kept a running scoreboard going while you entered the text
15:38:43 <wli> Philippa: What's that? I'm not aware of Perlis' definition.
15:38:50 <mmorrow> *feasibility
15:38:53 <Philippa_> wli: strictly speaking, Perlis defines low level
15:38:56 <Peaker> ozy`: Python is not really higher-level than C#, at least not by much (As the stuff Python can do, can mostly be expressed by C#'s type system).  Type declarations do not lower-level make
15:39:06 <leimy> porges: so what I was thinking is that has to be part of getFrames
15:39:12 <Philippa_> "A programming language is low level when its programs require attention to the irrelevant. "
15:39:18 <tibbe> dibblego: I want to remove Monad from the context and replace it with Applicative, I need to try to replace my one use of >>= with <*>
15:39:23 <ozy`> Peaker: I know that. the pundits are stupid :p
15:39:35 <mmorrow> ddarius: have you seen that youtube (or somewhere) presentation of using haskell for writing super-optimized asm?
15:39:36 <Philippa_> Irrelevant type declarations /do/ make low level
15:39:44 <dibblego> tibbe, that's not always possible, but perhaps? where is your code?
15:39:47 <mapreduce> Philippa_: C# has local variable type inference.
15:39:50 <mmorrow> ddarius: quicksilver linked me, i can't remember the link though :(
15:39:53 <wli> Can a quantitative method of comparison be devised for the "height" of a language?
15:39:54 <mapreduce> Is C# still low level?
15:39:54 <tibbe> dibblego: sec, let me paste
15:39:58 <ddarius> mmorrow: I don't know.  I might have.
15:40:04 <dons> ?users
15:40:05 <lambdabot> Maximum users seen in #haskell: 583, currently: 549 (94.2%), active: 33 (6.0%)
15:40:08 <mmorrow> quicksilver: ping
15:40:08 <dons> busy time of the day
15:40:16 <leimy> yep
15:40:21 <ozy`> Philippa_: in recent versions of C#, you can declare variables as "var x" instead of "SomeVerboseTypeName x" which signals to the compiler to use type inference
15:40:27 <Philippa_> mapreduce: yep. Less so than previously, perhaps
15:40:33 <dons> ok. i still haven't see the 500 libraries uploaded to hackage this week we agreed on, peoples!
15:40:54 <dons> only 78 :/
15:40:59 <mapreduce> dons: Are you the Haskell promoter?
15:41:00 <leimy> heh
15:41:02 <mfp> uh
15:41:09 <mapreduce> Would you like Haskell to hit mainstream?
15:41:18 <tibbe> dibblego: http://hpaste.org/12913
15:41:21 <dons> mapreduce: i guess so, on both.
15:41:35 <leimy> dons:  I can upload 100 new libraries that all suck and don't work very well :-)
15:41:35 <tibbe> mapreduce: I am too, just more lazy than dons ;)
15:41:41 <mapreduce> dons: SPJ seemed to say that not being mainstream was one of Haskell's advantages.
15:41:48 <ddarius> Philippa: Not all of those type declarations are irrelevant and it's unlikely that they all could be inferred.
15:41:50 <Peaker> Philippa_: I would define high-levelness differently, but I agree that with your definition Python is higher-level
15:41:51 <dons> mapreduce: being agile.
15:42:03 <wli> mapreduce: Screw going mainstream. I'd want Haskell to bring the mainstream down.
15:42:10 <dons> well, i guess 78 is pretty good
15:42:19 <ddarius> dons: Isn't that 7 more than last month?
15:42:29 <ddarius> Er week (or whatever)
15:42:29 <dons> the rate is increasing.
15:42:32 <mm_freak_> btw haskell and mainstream  my monads tutorial is almost finished, and people seem to understand and like it  i hope, that will move haskell forward a bit
15:42:35 <Philippa_> ddarius: sure, you've seen me argue on LtU before that static typing is expressive in the sense of "more info contained" too
15:42:36 <ozy`> if Haskell were the new mainstream, other languages would have to be better than Haskell to displace it. think about that.
15:42:37 <dons> ddarius: its a bit up, yes.
15:42:40 <dibblego> tibbe, you can replace fmap with (<$>) for a start and be rid of Functor
15:42:43 <tibbe> I don't necessarily want Haskell to hit mainstream, I just want the libraries I want to get developed and getting more hackers is a good way to achieve that
15:42:45 <dons> mm_freak_: thanks!
15:42:52 <leimy> is there anyway to catch the exception you get when you do "read blah :: Int" and it's not an Int? :-)
15:43:01 <Peaker> Philippa_: on second thought, the C# type declarations are not irrelevant, they are redundant
15:43:06 <ddarius> 70+ libraries a week seems like a lot.
15:43:11 <tibbe> dibblego: that's just a synonym for fmap no?
15:43:16 <Peaker> Philippa_: so by that definition, C# is not lower-level
15:43:17 <dons> ddarius: actually, its hard to keep up with :)
15:43:19 <dibblego> tibbe, right
15:43:32 <mmorrow> leimy: i think everyone tries that at some point (i did) :) use reads
15:43:41 <dons> ddarius: note the curve up (per day uploads) http://galois.com/~dons/images/hackage-daily-graph.png
15:43:48 <Philippa_> Peaker: redundant implies that at a minimum they can be made irrelevant and may in fact be irrelevant
15:43:49 <leimy> mmorrow: reads seems to be the only way yea
15:43:54 <dons> so we're in the 10/day range now.
15:43:58 <dons> ~70 / week.
15:44:06 <mmorrow> leimy: it is
15:44:06 <dons> for the last 2 months
15:44:11 <leimy> mmorrow: fair enough.
15:44:21 <wli> "The mainstream" implies a sort of over-arching language dominance vs. diversification and "right language for the job" sorts of things.
15:44:24 <dibblego> tibbe, consider do x <- e1; y <- e2; return (f x y) can also be written f <$> e1 <*> e2
15:44:30 <mfp>  /topic by entering this channel, you agree to abide by the Code of the Good Haskeller and submit at least 1 lib per month to Hackage
15:44:40 <dons> mfp: that's part of the code, yes :)
15:44:44 <dons> you give a little, you get a little.
15:44:48 <tibbe> dibblego: hmm true
15:44:58 <dibblego> tibbe, so there is your hint ;)
15:45:19 <tibbe> dibblego: but will that make stream' get used?
15:45:22 <leimy> none of my Haskell code is even remotely interesting though to anyone but me :-)
15:45:24 <dibblego> you could of course just write (<*>) = ap
15:45:27 <Peaker> Philippa_: how can you convert redundant to irrelevant?
15:45:32 <dons> leimy: so you're a domain expert!
15:45:34 <tibbe> dibblego: right but that requires Monad
15:45:39 <ozy`> leimy: what does it do, then?
15:45:39 <leimy> dons: hey YEAH! :-)
15:45:40 <Philippa_> Peaker: by not using it
15:45:50 <leimy> ozy`:  scores bowling....
15:45:55 <leimy> kind of boring
15:46:01 <Peaker> Philippa_: That doesn't make them irrelevant, they are very relevant, describing high-level details about the program's implementation
15:46:05 <dons> sounds like a nice lib, leimy
15:46:11 <Peaker> Philippa_: in fact, you might want to keep them as high-level documentation
15:46:11 <dons> why not release it for other people who want to score bowling?
15:46:13 <leimy> BowLib?
15:46:16 <ozy`> leimy: is that the same code I've seen in lambdabot's source?
15:46:18 <dons> yeah.
15:46:23 <dibblego> tibbe, I expect a solution is possible without the Monad constraint but instead Applicative
15:46:24 <leimy> er BowlLib
15:46:25 <dons> Math.Bowling
15:46:31 <Philippa_> Peaker: that would be using it again, no?
15:46:40 <tibbe> dibblego: that's exactly what I want! :)
15:46:41 <dons> would be a nice answer to that ruby guy who whinged about using recursion to score bowling last year
15:46:45 <Peaker> Philippa_: not as part of the implementation, just documentation
15:46:46 <leimy> ozy`: likely no
15:46:50 <tibbe> dibblego: and it's also what I expect
15:46:57 <Philippa_> anyway, I'm being mildly silly: I'm using the formal logic definition of 'irrelevant', which really is "not used"
15:46:58 <tibbe> dibblego: but haven't been able to write yet
15:47:12 <dons> btw, gitit is the awesome. i'm so impressed.
15:47:24 <dibblego> tibbe, sometimes it is easy to apply the type constructor in another function signature and work with that
15:47:25 <dons> we should start mirroring haskell.org in gitit, imo.
15:47:30 <dons> do we have a mediawiki importer?
15:47:32 <Peaker> Philippa_: I guess everyone can agree "High-levelness" has a big subjective factor in it
15:47:32 <Philippa_> Peaker: nevertheless. Code for humans first and machines only incidentally, right?
15:47:47 <lament> Philippa_: exactly! Don't use Lisp.
15:48:13 <Peaker> dons: what's impressive about gitit? (I don't know much about it)
15:48:16 <tibbe> dibblego: could you give an example
15:48:46 <dibblego> tibbe, consider (<*>) :: f (a -> b) -> f a -> f b -- then write another function where you have applied f
15:48:51 <dons> Peaker: its a very easy to deploy mediawiki-like wiki, backed with git. using happs. it is _trivial_ to deploy, and supports other markup (e.g. latex)
15:48:54 <dibblego> and work with that to get going
15:48:59 <dons> so i'm running it on localhost as an organising system
15:49:10 <Peaker> dons: cool
15:49:23 <tibbe> dibblego: right, so Iteratee m (a -> b) -> Iteratee m a -> Iteratee m b
15:49:23 <sjanssen> dons: do you think it would be hard to turn gitit into a blog system that supports literate Haskell as input?
15:49:27 <sjanssen> I've wanted that for ages
15:49:32 <dibblego> tibbe, right
15:49:43 <dons> sjanssen: i don't think it would be hard.
15:49:49 <Peaker> tibbe: how do you combine the streams?
15:49:51 <dons> i think it is the perfect place to start from too
15:49:52 <sjanssen> I'll have to look at that
15:49:57 <Elly> mmm, literate haskell
15:50:03 <sjanssen> only downside is that you'd need your own host
15:50:07 <tibbe> Peaker: you can't really, i.e. there's no Monoid instance
15:50:24 <erikc> just need a common host for haskell-related blogs
15:50:38 <sjanssen> Elly: wouldn't it be awesome?  It would become incredibly easy to blog interesting snippets of Haskell code
15:50:47 <tibbe> Peaker: but you could see Chunk "" as an identity. Eof and Error short circuits the stream
15:51:02 <Elly> sjanssen: I was just saying mmm to literate haskell as a concept
15:51:16 <sjanssen> Elly: ah, nevermind :)
15:52:09 <Peaker> tibbe: so <*> sounds impossible then?
15:52:22 <pumpkin> erikc: hlog.org!
15:52:25 <pumpkin> lol
15:52:35 <pumpkin> oh it's taken
15:52:58 <pumpkin> by some japanese website that can't be found
15:53:34 <tibbe> Peaker: I don't know yet. It's possible to write a monad instance or a Applicative instance given that m is a monad
15:53:35 <byorgey> sjanssen: that sounds great to me too!  I'd use it!
15:53:49 <tibbe> Peaker: if it's impossible it would be nice to understand why
15:54:25 <leimy> porges: Maybe I want this function: interactFrames :: ([String] -> IO [Frame]) -> IO ()
15:54:53 <Peaker> tibbe: Monads support dynamic sequencing. Applicatives only support static sequencing (sub-case of dynamic sequencing), so every monad is trivially an applicative
15:55:06 <Peaker> tibbe: oh, I misread you, sorry
15:55:22 <Peaker> tibbe: can you paste the link again?
15:55:28 <leimy> Is it normal for Haskellers to think about function types before they think about the code?
15:55:34 <tibbe> Peaker: right, so how do I know when I need dynamic sequencing? When I need to inspect the wrapped value, but how do I know if I need to inspect the wrapped value?
15:55:39 <dibblego> leimy, very much so
15:55:40 <ddarius> leimy: It's not atypical.
15:55:43 <tibbe> Peaker: http://hpaste.org/12913
15:55:45 <leimy> Cool
15:55:51 <leimy> then I must be getting the hang of it a little.
15:56:17 <Peaker> tibbe: if you need to generate/choose arbitrary wrapped values from unwrapped values, then you need a monad
15:56:22 <mfp> leimy: I think the usual sequence is thinking first about the data types, then about the types of the functions that manipulate them, then about code
15:57:00 <mmorrow> ok, looking at the Clean compiler code some more, i take back that i want to take a shower after looking at it :)
15:57:20 <ozy`> mmorrow: was it written by Mel?
15:57:49 <mmorrow> i'm not sure who Mel is or if that's a reference to something :)
15:58:01 <solrize> the language is called clean because everyone who uses it has to shower all the time?  :)
15:58:08 <porges> anyone tried collaborative Haskell coding, e.g. using Gobby?
15:58:19 <ozy`> mmorrow: the Mel
15:58:22 <ozy`> http://www.cs.utah.edu/~elb/folklore/mel.html
15:58:32 <ozy`> the Real Programmer
15:58:35 <Peaker> tibbe: even if m is a monad, how can you combine Done's?
15:58:38 <mmorrow> ozy`: heh. yes himm
15:59:01 <Eelis> if i have "instance A x => B x where ... ; instance B Int where e...", ghc complains that the instances overlap. why isn't there some instance ordering (as with C++'s (partial) template specializations) that makes this do what one would expect it to do (namely pick the most specialized instance)?
15:59:08 <Peaker> tibbe: currently you just discard the right-hand stream
15:59:20 <tibbe> Peaker: right, semantically that's fine
15:59:42 <ddarius> Eelis: Turn on overlapping instances (and maybe some other things)
15:59:46 <tibbe> Peaker: since if the left handed stream hasn't been consumed yet, if it's a non-empty chunk, Eof or Error we should continue with that
15:59:48 <Eelis> ddarius: tried it, to no avail.
16:00:00 <tibbe> Peaker: very much like in a resumable parser or the binary library
16:00:43 <Peaker> tibbe: I don't really know what your data constructors really mean, so I am not sure
16:01:05 <Peaker> tibbe: maybe you can implement it with ErrorT/Maybe as a "denotational semantics" guide, so you can later use your more intricate strict types for the operational behavior?
16:01:17 <jberryman> I've been trying to ficure out how to define a combinator (.:) to be able to compose something like: f = (*2).(+1).:(^) -- either that or something like f = (*2).(+1).(^).:  -- can't seem to figure this out.
16:01:17 <Peaker> tibbe: (get the denotational semantics right with the simpler implementation, then the operational one)
16:01:27 <tibbe> Peaker: I could try that
16:01:45 <tibbe> Peaker: although I'm not sure what it would look like
16:01:51 <tibbe> Peaker: Oleg gave a talk about it
16:02:04 <Peaker> tibbe: you could re-use the applicative instances of ErrorT/Maybe
16:02:13 <tibbe> Peaker: but he only gave a Monad instance for m (Iteratee m a) where m is a Monad
16:03:09 <tibbe> Peaker: Stream might be better though of as Elem, an element of a stream with the difference that you get the opportunity to process many elements at once, change Chunk String to Chunk Char shouldn't make a semantical difference
16:03:48 <tibbe> Peaker: Here are the annotated slides of the talk: http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf
16:05:41 <Peaker> tibbe: denotationally, a Stream is basically an ErrorT (Maybe Char) ?
16:05:57 <byorgey> tibbe: I don't think you can drop the (Monad m) constraint on the Applicative instance for Stream.
16:06:08 <byorgey> tibbe: I don't have a proof but I've just been playing around with it some.
16:06:09 <tibbe> byorgey: how come?
16:06:23 <tibbe> byorgey: I've played around with lots without being successful
16:06:49 <byorgey> tibbe: intuitively, the problem is when you apply k' to stream' in the continuation case
16:06:59 <tibbe> byorgey: right
16:07:02 <byorgey> that gets you a  m (Iteratee m a)
16:07:20 <byorgey> but you need to be able to collapse that extra 'm', and the only way you can do that is if you have 'join'
16:07:24 <byorgey> i.e. a monad
16:07:29 <tibbe> Peaker: I'm not sure if they're the same denotationally
16:07:37 <byorgey> this is *extremely* hand-wavy, but maybe useful =)
16:08:35 <tibbe> byorgey:  :) but the final result should also be m (Iteratee m a) so could I use e.g. <*> to push f inside?
16:08:43 <Peaker> tibbe: isomorphic to:  Either ErrorType (Maybe String)  I mean?
16:08:54 <Peaker> tibbe: (and matching in spirit.. :-)
16:09:07 <tibbe> Peaker: yes if you having Nothing as Eof
16:09:19 <byorgey> tibbe: oh, sorry, let me show you what I've done, I'll paste the code in a sec
16:09:25 <tibbe> byorgey: ok thanks
16:10:40 <mib_ymlg44> i am trying to write a polynomial using foldr determine by a list of coefficients
16:10:53 <dons> mib_ymlg44: sounds cool.
16:11:00 <dons> so composing them into a function?
16:11:07 <mib_ymlg44> e.g. poly 2 [1,4,3,2] -> 32
16:11:20 <mib_ymlg44> any aid ?
16:11:28 <dons> oh, so you just want to fold?
16:11:37 <mib_ymlg44> yes
16:11:38 <dons> is this a homework question? :)
16:11:42 <mib_ymlg44> nope
16:11:51 <dons> > foldr (+) 0 [1..10]
16:11:52 <lambdabot>   55
16:11:55 <dons> where are you stuck?
16:12:00 <mib_ymlg44> just wanna try to using the fold
16:12:36 <mib_ymlg44> poly 2 list = foldr (+2) 0 list
16:12:56 <Peaker> mib_ymlg44: can you explain how the above poly function expands?
16:12:56 <byorgey> tibbe: http://hpaste.org/12913#a1
16:12:59 <Peaker> mib_ymlg44: to 32?
16:13:09 <tibbe> byorgey: looking
16:13:30 <Peaker> 1+2*4+4*3+8*2=37 ?
16:13:38 <mib_ymlg44> i f (x) = x3 + 4x2 + 3x + 2
16:13:44 <Peaker> oh, its reversed
16:14:10 <Peaker> mib_ymlg44: its probably easier if you first reverse the list
16:14:38 <mib_ymlg44> reverser = foldr snoc [] where snoc x xs = xs ++ [x]
16:14:45 <Peaker> mib_ymlg44: I'd use iterate/zipWith for this, or if its not a homework-question, the "Beautiful folds"
16:14:53 <tibbe> byorgey: thanks for that, a little disappointing but certainly not your fault :)
16:15:10 <byorgey> tibbe: heh, sure =)
16:15:20 <byorgey> tibbe: I added another annotation too, if you reload
16:15:27 <mib_ymlg44> peaker, this is my reverse function : reverser = foldr snoc [] where snoc x xs = xs ++ [x]
16:15:48 <porges> tibbe: I actually emailed Oleg yesterday about reimplementing Stream/Iteratee with dons' Data.Stream/Step :P
16:16:00 <Peaker> mib_ymlg44: reverse is in the Prelude
16:16:05 <byorgey> you could change the 'return' in that last annotation to 'pure', so the only thing requiring Monad would be the 'join'
16:16:05 <Peaker> > reverse [1,2,3]
16:16:07 <lambdabot>   [3,2,1]
16:16:17 <mib_ymlg44> i know
16:16:24 <dons> proq: ooh!
16:16:26 <mib_ymlg44> just wanted to use foldr
16:16:27 <tibbe> porges: interesting, got a reply yet?
16:16:31 <dons> porges: oh, you just suggested it?
16:16:32 <jsn> dons: where am i supposed to post about the haskell_proposals subreddit? was it haskell.org?
16:16:33 <mib_ymlg44> been practicing folds
16:16:34 <mmorrow> <leimy> Is it normal for Haskellers to think about function types before they think about the code?
16:16:35 <dons> but didn't actually implement it?
16:16:38 <tibbe> porges: are you talking about the stream fusion stuff?
16:16:41 <dons> jsn: i'd post on a) haskell-cafe@
16:16:43 <mmorrow> leimy: that's how i think abou tit
16:16:46 <Peaker> @src reverse
16:16:46 <Megzlna> I asked this earlier, but, is there any good reason at all for why natives lists (specifically not requiring a library) should not have a special first element as a "HeadCons" which stores an optionally Zeroed-out pointer to the end of the list WHEN it's not a closure entry?
16:16:47 <lambdabot> reverse = foldl (flip (:)) []
16:16:47 <jsn> dons: ah, right
16:16:49 <dons> jsn: and b) replace the existing 'submissions' page
16:17:03 <jsn> dons: oh? like skin it, you mean?
16:17:06 <dons> Megzlna: hmm. thinking...
16:17:15 <dons> jsn: just take all the old content and put it into the new reddit
16:17:19 <porges> dons: well I tried to but I got confused with teh existentials :P
16:17:25 <tibbe> byorgey: for some reason I can't get rid of the Functor requirement either, is it because class Functor f => Applicative f ?
16:17:25 <mmorrow> once you have the type, the function almost writes itself ("almost")
16:17:38 <dons> a special first element which stores a zeroed-out pointer to the end of the list, when it is not a closure?
16:17:41 <dons> Megzlna: why?
16:17:58 <dons> porges: i'm not sure that iteratees are unfolds though
16:17:59 <jsn> dons: i don't understand what you mean
16:18:00 <porges> tibbe: yeah Oleg said it's a fairly straightforward transformation
16:18:04 <jsn> the old content from where?
16:18:14 <byorgey> tibbe: you should be able to get rid of the Functor constraint if you change all uses of 'fmap' to 'liftM', I think
16:18:18 <Megzlna> dons: Because it seems superior to me, the only cost would be a single pointer, and it's always known at compile time if a given list will have closure
16:18:20 <dons> porges: hmm. did he discussion fusion?
16:18:25 <tibbe> byorgey: I did but it didn't work
16:18:25 <dons> Megzlna: superior to what?
16:18:26 <byorgey> tibbe: but yes, Functor f => Applicative f
16:18:27 <Cale> Megzlna: Note that lists are immutable. Storing a pointer to the end of the list is fairly pointless.
16:18:27 <wli> > (\x -> foldl1 (\c c' -> x*c + c')) 2 [1,4,3,2]
16:18:29 <lambdabot>   32
16:18:31 <byorgey> tibbe: hmm, just a sec
16:18:34 <Megzlna> dons: current GHC impl
16:18:39 <dons> of closures?
16:18:41 <Megzlna> with expensive appends
16:18:42 <dons> or data structures in general?
16:18:47 <porges> dons: no
16:18:50 <tibbe> byorgey: right, Iteratee is only a functor if Functor f => Iteratee f
16:18:54 <Megzlna> dons: just []'s
16:18:54 <dons> ?src []
16:18:55 <lambdabot> data [] a = [] | a : [a]
16:18:57 <sjanssen> Megzlna: what would the end pointer help with?
16:19:02 <dons> has no special representation. its just another data type
16:19:15 <dons> so tag pointer to closure. thunk for tail.
16:19:16 <tibbe> porges: I would be interested in implementing it using stream fusion
16:19:16 <mib_ymlg44> wli can i see tha not using lambda ?
16:19:35 <byorgey> tibbe: oh, right, that's why
16:19:41 <dons> Megzlna: so you want a 'last node' pointer in the data type too?
16:19:47 <Megzlna> yes
16:19:50 <dons> so that what? what would append look like?
16:19:51 <dons> ?src (++)
16:19:52 <lambdabot> []     ++ ys = ys
16:19:52 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:19:52 <lambdabot> -- OR
16:19:52 <lambdabot> xs ++ ys = foldr (:) ys xs
16:19:52 <ozy`> dons: er, isn't (:) built into the base syntax?
16:20:08 <dons> ozy`: well, maybe a little special, but only on the surface.
16:20:17 <dons> Megzlna: how would you implement append?
16:20:21 <wli> @pl \x -> foldl1 ((+) . (*x))
16:20:22 <lambdabot> foldl1 . ((+) .) . (*)
16:20:33 <Peaker> mib_ymlg44: you can use iterate and zipWith, too
16:20:36 <dons> Megzlna: i think you're describing a different data structure.
16:20:58 <porges> tibbe: same
16:20:59 <dons> jsn: http://haskell.org/haskellwiki/Applications_and_libraries and
16:21:00 <dons> http://haskell.org/haskellwiki/Wanted_libraries
16:21:06 <Megzlna> Well the real question perhaps there is trading some generality for special case practical optimization
16:21:07 <dons> the latter has content that we tried to collect ion the wiki
16:21:10 <dons> but that never worked.
16:21:12 <mib_ymlg44> peaker, i have to practice fold
16:21:12 <porges> tibbe: I'm just not at that level yet :)
16:21:25 <mib_ymlg44> teacher is gonna start it
16:21:33 <dons> Megzlna: yeah. i can see 'special casing' lists in some way. but it totally changes what a list is.
16:21:37 <Megzlna> dons: Why can't the (++) utilize that pointer?
16:21:43 <dons> well, how do you implement it?
16:21:52 <dons> is a list a pair now of a tail pointer and the list itself?
16:21:59 <dons> so when you write: (x:xs) ++ ys = x : (xs ++ ys)
16:22:02 <dons> what happens?
16:22:10 <Cale> I don't see how having a pointer to the tail of a list helps with ++
16:22:11 <tibbe> porges: could you send me the email you sent?
16:22:17 <dons> is it actually, List t (x:xs) ++ ys = t ... ? ... ys
16:22:19 <mib_ymlg44> @pl \x -> foldl1 (\c c' -> x*c + c')
16:22:20 <lambdabot> foldl1 . ((+) .) . (*)
16:22:20 <jsn> dons: okay, thank you
16:22:24 <Cale> You still have to construct a new list.
16:22:33 <tibbe> porges: we can try to do it together, maybe with some help from oleg
16:22:42 <leimy> Hmmm looks like it's something like currying of these strings that's kicking my butt.
16:22:43 <dons> Megzlna: that's the other problem. how do you append without mutating the variable?
16:22:53 <Megzlna> it doesn't help with that
16:22:58 <Megzlna> Just removes the iteration
16:23:01 <leimy> somehow every side effect of the print occurs before the input is enterred.
16:23:04 <Cale> What iteration?
16:23:06 <SamB> Megzlna: you do realize all of these things are immutable ?
16:23:08 <dons> the general case your describing is somewhat like a finger tree,
16:23:22 <Cale> The end of a list is always either nonexistant or []
16:23:22 <wli> dons: The special functions bit for numerical algorithms isn't terribly difficult, but does want a unified notion of magnitude for real vs. complex numbers.
16:23:24 <dons> which is a purely functional structure with 'fingers' pointing to different parts, such that you can append more efficiently
16:23:27 <dons> amongst other htings.
16:24:06 <Cale> If you want to add to the end of a list, you *must* rebuild the first n conses, because some things might still need the old list.
16:24:22 <Cale> You can't just mutate the end of it.
16:24:49 <Megzlna> Cale: That makes sense.
16:25:01 <Megzlna> Due to the "shareable tail"
16:25:34 <mmorrow> tibbe: in that code you can't get rid of the Monad constraint because the Cont case makes essential use of fmap and join ===> (>>=)
16:25:50 <Peaker> Megzlna: if nobody's ever needs the old list [only used to construct new list], then you can avoid building it in the first place (with tricks like ShowS)
16:25:59 <Peaker> Megzlna: and if both old and new are needed, then you can use something like Data.Sequence
16:26:04 <mmorrow> @type (join .) . fmap
16:26:05 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f a) -> f a1 -> f a
16:26:12 <Megzlna> Peaker: Can't the compiler do that for you?
16:26:17 <mmorrow> @type flip ((join .) . fmap)
16:26:18 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
16:26:23 <Peaker> Megzlna: choose the right data types?
16:26:28 <SamB> Megzlna: heck no
16:26:37 <Megzlna> Peaker: Know there's no dependency
16:26:43 <Megzlna> and optimize hence.
16:26:43 <SamB> we haven't even figured out how to do that manually yet ;-P
16:26:59 <SamB> Megzlna: it can't know that
16:27:07 <Saizan_> well, in a lot of cases the list might never be constructed due to fusion
16:27:12 <Peaker> Megzlna: it might for rather trivial cases.. the rassoc of (++) already fixes the problem for trivial cases
16:27:13 <tibbe> mmorrow: I think I get it now although I still lack the aha moment when it becomes crystal clear why it's not possible
16:27:25 <Megzlna> why can't it? The compiler is the one in charge of setting up those shared tail references
16:27:28 <Megzlna> so it has to know
16:27:31 <SamB> Megzlna: well, not often
16:27:33 <Megzlna> every single one, no
16:27:42 <Peaker> Megzlna: how can it know if any reference to the old list will be used or discarded later?
16:27:57 <Peaker> Megzlna: by the code its going to be returned to?
16:27:59 <SamB> and anyway the compiler doesn't have any concept of mutating immutable data ;-P
16:28:04 <Megzlna> Peaker, I mean if there were none
16:28:07 <Megzlna> like
16:28:18 <Saizan_> tibbe: if the deciding the next action depends on the results of the previous, then you need Monad
16:28:30 <Megzlna> f (g (h [1,2,3,4,5])))
16:28:55 <Megzlna> simple composition
16:29:05 <Peaker> Megzlna: f . g . h $ [1..5]
16:29:20 * Megzlna grins
16:29:21 <SamB> Megzlna: it really wouldn't make sense to do optimizations like that with lists ... the cases where the compiler could see it was safe would be few and far between, and probably more easily handled by other means anyway ;-)
16:29:39 <mmorrow> tibbe: yeah, what Saizan_ just said is the essential aspect of it
16:29:44 <Peaker> Megzlna: so the compiler could inline this whole sequence and rewrite the (++) from lassoc to rassoc, yes
16:30:05 <tibbe> Saizan_: the unintuitive part here for me is that the iteratees seem to process the stream one after another like in Data.Binary but we can't write an Applicate instance for Iteratee
16:30:13 <Peaker> inlining is the key to bloated, yet possibly optimized code :-)
16:30:16 <SamB> and extending the compiler with machinery to support mutating the immutable only when it can be proven to be referenced exactly once would be a pain
16:30:38 <tibbe> Saizan_: to me the Iteratee definition is not very far from an applicative parser I wrote a while ago
16:30:43 <Peaker> SamB, Megzlna: In the case he mentioned, you don't even need mutation, you can just fix the associtativity after inlining
16:30:45 <ozy`> Peaker: isn't (++) already right-associative?
16:31:02 <Peaker> ozy`: Yeah, I meant replace something like:  ((a++b)++c)  with (a++(b++c))
16:31:07 <mib_ymlg44> peaker why am i not getting the right answer?
16:31:09 <SamB> Peaker: yes, "more easily handled by other means"
16:31:13 <mmorrow> tibbe: but Iteratee can use the information it gains from processing earlier chunks to influence what it does with the current chunk
16:31:13 <mib_ymlg44> poly p list = foldr ((+).(*p)) 0 list
16:31:14 <Peaker> mib_ymlg44: what's the code?
16:31:16 <mib_ymlg44> ??
16:31:21 <Megzlna> well I wouldn't be surprised if GHC already does this stuff
16:31:38 <Peaker> Megzlna: ghc does inlining, afaik, and has rewrite rules
16:31:43 <mmorrow> tibbe: and applicative (alone) lacks this ability
16:31:43 <byorgey> > foldr ((+).(*3)) [1,2,3]
16:31:45 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
16:31:45 <lambdabot>        arising from a use...
16:31:52 <byorgey> > foldr ((+).(*3)) 0 [1,2,3]
16:31:54 <lambdabot>   18
16:31:54 <Peaker> Megzlna: ghc is probably one of very few real-world compilers that allows the user to define his own optimizations
16:31:56 <SamB> but it doesn't do desctructive update
16:32:04 <Peaker> Megzlna: (as simple "rewrite rules")
16:32:07 <SamB> not except in extreme cases
16:32:19 <Megzlna> That is neat.
16:32:41 <SamB> (I mean, maybe it does it during array constructions if you are really lucky ;-)
16:32:49 <byorgey> mib_ymlg44: note that if you use foldr, you will have to put the least significant terms at the right end of the list.
16:33:15 <mib_ymlg44> so i need to reverse right?
16:33:22 <byorgey> mib_ymlg44: so poly p list [a,b,c] = a*p^2 + b*p + c
16:33:28 <tibbe> mmorrow: I think it makes sense now
16:33:38 <mmorrow> tibbe: cool :)
16:33:45 <tibbe> mmorrow: thanks! now bedtime
16:33:50 <mmorrow> night
16:34:25 <Peaker> mib_ymlg44: for more beautiful folds, see: http://conal.net/blog/posts/enhancing-a-zip/
16:34:34 <Peaker> mib_ymlg44: its worth reading in full
16:36:35 <mmorrow> BMeph: wow, i just started reading that "Binary Lambda ... " paper and it looks super applicable and interesting..
16:36:41 <Peaker> amazing how so many things map to so few type-classes so beautifully :)
16:39:02 <lament> "never before were so many things mapped to so few type classes"
16:39:39 <leimy> Well when your classes aren't things like "class Doorknob" :-)
16:41:00 <Peaker> lament: where's that from?
16:41:28 <lament> winston churchill, possibly the greatest functional programmer
16:41:37 <Peaker> oh, hehhee
16:41:49 <mmorrow> whoa, so Y is (\f -> (\x -> x x) (\x -> f (x x))). i thought (incorrectly it seems) that Y = (\f -> (\x -> f (x x)) (\x -> f (x x)))
16:42:04 <mmorrow> (or am i just looking at a typo?)
16:42:35 <mmorrow> i think it may be a typo, since i've used that other def of Y and it worked as expected
16:42:36 <Peaker> @pl \x -> x x
16:42:37 <lambdabot> join id
16:42:40 <Cale> typo
16:42:43 <leimy> yep... all this time it was because the getContents was "too lazy" that my prompting went badly
16:42:47 <mmorrow> Cale: ok good
16:42:52 <leimy> go figure
16:42:56 <roconnor> > readFloat (show pi)
16:42:58 <lambdabot>   [(3.141592653589793,"")]
16:43:06 <mmorrow> leimy: heh
16:43:07 <Peaker> @type readFloat
16:43:08 <lambdabot> forall a. (RealFrac a) => String -> [(a, String)]
16:43:09 <roconnor> > readFloat (show pi) :: [(Rational,String)]
16:43:11 <lambdabot>   [(3141592653589793%1000000000000000,"")]
16:43:12 <leimy> taking the head of the list of stuff directly after the prompt, forces it to evaluate input
16:43:13 <Peaker> @type reads
16:43:14 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:43:21 <leimy> ain't that some shit... bit by laziness
16:43:22 <Peaker> what's the point of readFloat ?
16:43:26 <Megzlna> how many different meanings does . have?
16:43:40 <Peaker> Megzlna: in the Prelude, just 1
16:43:47 <Peaker> @type (.)
16:43:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:43:50 <mmorrow> hah, the saying "ain't that some shit" is great
16:43:54 <Megzlna> f . g $ 1
16:44:07 <Megzlna> forall x y.  etc
16:44:21 <Peaker> Megzlna: Oh!  "." has 3 syntactic meanings
16:44:23 <intrados> are runhaskell and runghc synonyms?
16:44:27 <Peaker> unless I missed some
16:44:32 <leimy> if I made getFrame use "head" instead of just deconstructing the input list I'd be in better shape
16:44:33 <rgov> ghc is generating i386 instructions, then passing them off to a i686 compiler, which then complains about invalid instructions... how can i force it to use an i386 compiler? (os x)
16:44:48 <leimy> or I can make ballList less lazy
16:44:50 <Peaker> Megzlna: module attribute lookup, (.) operator, and in "forall" syntax
16:44:57 <leimy> damnit
16:45:02 <leimy> oh well at least I figured it out.
16:45:25 <Megzlna> Peaker, k
16:45:35 <Megzlna> the forall usage is odd.
16:45:47 <leimy> ?src lines
16:45:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:45:50 <Peaker> Megzlna: Mathematicians with toys
16:45:51 <leimy> ooh
16:45:58 <Megzlna> forall x y z:
16:46:14 <redditbot> A new reddit for submitting and voting on project ideas for haskell!
16:46:38 <lament> we have a whole bot for announcing NEW HASKELL-RELATED REDDITS?
16:47:04 <mib_ymlg44> @pl \x -> foldl1 (\c c' -> x*c + c')
16:47:04 <lambdabot> foldl1 . ((+) .) . (*)
16:47:12 <mib_ymlg44> @pl
16:47:12 <lambdabot> (line 1, column 1):
16:47:12 <lambdabot> unexpected end of input
16:47:12 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:47:21 <solrize> rgov you mean the other way?  all i386 instructions should be valid on i686
16:47:31 <mib_ymlg44> what is @pl ?
16:47:39 <pumpkin> mib_ymlg44: pointless
16:47:41 <rgov> solrize: it's generating a "pushq" instruction which i've never heard of
16:48:02 <mib_ymlg44> pumpkin explain?
16:48:09 <Peaker> mib_ymlg44: it converts magic-lambda syntax to non-magic compositions of functions using stdlib functions
16:48:12 <kfish> lament, yes, because haskell bots are lightweight and composable!
16:48:20 <solrize> rgov that's a standard x86 instruction, you give it a bit mask and it pushes those registers to the stack
16:48:29 <mib_ymlg44> oh ok
16:48:31 <Peaker> mib_ymlg44: for example, \x -> x is converted to "id", and \x y -> x   is converted to const, etc
16:48:56 <Peaker> @pl \x y -> (x*y) + (x+y)
16:48:56 <lambdabot> ap (ap . ((+) .) . (*)) (+)
16:49:10 <solrize> see how much more readable the pointfree version is ?  :)
16:49:12 <mib_ymlg44> @pl \x y
16:49:13 <lambdabot> (line 1, column 5):
16:49:13 <lambdabot> unexpected end of input
16:49:13 <lambdabot> expecting pattern or "->"
16:49:21 <mib_ymlg44> @pl \x y- > x
16:49:22 <lambdabot> (line 1, column 5):
16:49:22 <lambdabot> unexpected " "
16:49:22 <lambdabot> expecting "->"
16:49:34 <mib_ymlg44> @pl \x y- > (x+y)
16:49:35 <lambdabot> (line 1, column 5):
16:49:35 <lambdabot> unexpected " "
16:49:35 <lambdabot> expecting "->"
16:49:39 <solrize> @pl let {fac 0 = 1; fac n = n*fac(n-1)} in fac x
16:49:40 <lambdabot> (line 1, column 5):
16:49:40 <lambdabot> unexpected "{"
16:49:40 <lambdabot> expecting "()", natural, identifier or "in"
16:49:54 <mib_ymlg44> @pl \x y -> (x+y)
16:49:55 <lambdabot> (+)
16:50:00 <solrize> @pl let { fac 0 = 1; fac n = n*fac(n-1) } in fac x
16:50:00 <lambdabot> (line 1, column 5):
16:50:00 <lambdabot> unexpected "{"
16:50:00 <lambdabot> expecting "()", natural, identifier or "in"
16:50:08 <solrize> @pl let fac 0 = 1; fac n = n*fac(n-1) in fac x
16:50:09 <lambdabot> x * x (x - 1)
16:50:22 <mib_ymlg44> @pl \x -> foldl1 (\c c' -> x*c + c')
16:50:23 <lambdabot> foldl1 . ((+) .) . (*)
16:50:23 <Axman6> @pl let fac 0 = 1; fac n = n*fac (n-1)
16:50:24 <lambdabot> (line 1, column 35):
16:50:25 <lambdabot> unexpected end of input
16:50:25 <Peaker> @pl supports let ?
16:50:27 <lambdabot> expecting ";" or "in"
16:50:29 <lambdabot> (line 1, column 10):
16:50:31 <lambdabot> unexpected reserved word "let" or "l"
16:50:33 <lambdabot> expecting variable, "(", operator or end of input
16:50:36 <Axman6> @pl let fac 0 = 1; fac n = n*fac (n-1)in fac
16:50:36 <lambdabot> ap (*) (ap id (subtract 1))
16:51:06 <Axman6> > ap (*) (ap id (subtract 1)) 3
16:51:08 <lambdabot>       Occurs check: cannot construct the infinite type: a = a1 -> a
16:51:08 <lambdabot>      Prob...
16:51:09 <Peaker> it takes the last pattern only
16:51:14 <Axman6> ah
16:51:40 <solrize> @pl let fac n = if n==0 then 1 else n*fac(n-1) in fac x
16:51:40 <lambdabot> fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) x
16:51:48 <Peaker> @pl \f g x -> f x && g x
16:51:48 <lambdabot> liftM2 (&&)
16:52:09 <solrize> :t if'
16:52:11 <lambdabot> Not in scope: `if''
16:52:38 <Axman6> @hoogle if'
16:52:39 <lambdabot> No results found
16:52:50 <Axman6> Data.Bool maybeh?
16:52:57 <Peaker> I don't understand why "if" syntax exists in a lazy language
16:53:03 <mib_ymlg44> @pl \x -> foldl1 (\c c' -> x*c + c')
16:53:03 <lambdabot> foldl1 . ((+) .) . (*)
16:53:11 <dons> Peaker: a token bit of conveience
16:53:31 <Axman6> > foldl1 . ((+) .) . (*) [1,2,3,4,5]
16:53:33 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
16:53:50 <Axman6> > foldl1 . ((+) .) . (*) 0 [1,2,3,4,5]
16:53:52 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
16:53:57 <Peaker> dons: its implying Haskell should find a way to have keyword-args in other functions too, rather than special case "if" only
16:54:00 <wli> Peaker: What would you expect vs. if?
16:54:02 <Axman6> > foldl1 . ((+) .) . (*) $ [1,2,3,4,5]
16:54:03 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
16:54:03 <lambdabot>        arising from a use...
16:54:12 <Peaker> wli: if is just a function of 3 arguments
16:54:16 <wli> Peaker: I'd regard that as an improvement.
16:54:18 <Axman6> :t foldl1 . ((+) .) . (*)
16:54:19 <lambdabot> forall a. (Num a) => a -> [a] -> a
16:54:26 <Axman6> > foldl1 . ((+) .) . (*) 0 $ [1,2,3,4,5]
16:54:28 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
16:54:34 <Peaker> wli: what, keywords or "if" as a function?
16:54:45 <wli> Peaker: Keywords.
16:55:03 <Peaker> wli: how does that add into the type system though?
16:55:08 <Axman6> if' makes so much more sense from a functional point of view
16:55:18 <mmorrow> a quine pattern (untypeable in HM)
16:55:20 <mmorrow> @type (\q (<>) -> (\x -> x <> q x) (q (\x -> x <> q x)))
16:55:21 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:55:21 <lambdabot>       Expected type: (t -> t1) -> t
16:55:21 <lambdabot>       Inferred type: t -> t2
16:55:24 <mmorrow> but
16:55:33 <wli> Peaker: AFAIK it wouldn't; it would just be more syntax.
16:55:50 <mmorrow> , (\x -> x `dynApp` toDyn x) (toDyn (\x -> x `dynApp` toDyn x))
16:55:52 <Peaker> wli: so when you partial application, you lose the keywords?
16:55:52 <lunabot>  <<Dynamic>>
16:56:15 <wli> Peaker: Presumably yes, or otherwise resort to lambdas.
16:56:24 <mmorrow> i think that was meant by the typo for Y in this paper (maybe)
16:57:51 <Megzlna> is : the actual "Cons" ?
16:58:05 <Megzlna> ?src :
16:58:05 <lambdabot> Source not found. stty: unknown mode: doofus
16:58:17 <pumpkin> > (:) 1 []
16:58:18 <lambdabot>   [1]
16:58:29 <Megzlna> wow
16:58:29 <Peaker> wli: maybe we can have "function-signature-classes", like:   signature If :: Bool -> then::a -> else::a -> a      and then:  instance If if    and then using "then" and "else" before keywords, means you're applying a function which is an instance of If.  You can also support partials that way
16:58:56 <wli> Peaker: I'm all for it.
16:58:59 <Peaker> wli: and when using "then" and/or "else" you're committing to calling an If signature instance, but not specifically "if"
16:59:01 <Megzlna> why can't I get the src for :
16:59:11 <Peaker> Megzlna: (:) is a data constructor
16:59:13 <Peaker> @src []
16:59:13 <lambdabot> data [] a = [] | a : [a]
16:59:28 <Peaker> Megzlna: unfortunately, you have to @src the type to see the data constructors
16:59:44 <Megzlna> Peaker: k.
17:00:23 <Peaker> Maybe a compiler expert can say how complicated that idea sounds
17:00:49 <wli> I'm mostly concerned about numerically solving systems of quadratic equations.
17:01:02 <Peaker> It seems like it could be added as a layer on top of the current language. Though it might actually be used to add more type information (implying which signature instance is being used)
17:02:02 <Peaker> hey it can also make for nicer "flips"
17:02:42 <mib_ymlg44> @pl foldl1 . ((+) .) . (*)
17:02:43 <lambdabot> foldl1 . ((+) .) . (*)
17:02:50 <Peaker> maybe I ought to propose function signatures to Haskell cafe to get it shot down :)
17:03:14 <Peaker> mib_ymlg44: there's no "magic lambda" (backslash) in there, so its already @pl'd
17:03:25 <wli> AIUI there's a way to transform it and more general systems of polynomial equations into eigenproblems, but I'm a bit lost and don't have Cox, Little, & O'Shea around (which contains an exposition of some naive algorithms for it).
17:03:26 <Peaker> @unpl foldl1 . ((+) .) . (*)
17:03:27 <lambdabot> (\ d -> foldl1 (\ j -> (+) (d * j)))
17:04:11 <mib_ymlg44> the polynomial thing just not working for me
17:04:13 <Megzlna> 'pl' means?
17:04:19 <Peaker> Megzlna: point-less
17:04:47 <luite> Peaker: and agda-like infix syntax? if_then_else_ : {A : Set} -> Bool -> A -> A -> A   (the parameters take the place of the underscores)
17:04:59 <Peaker> Megzlna: instead of building functions as lambdas, you compose existing functions with combinators
17:05:09 <solrize> @unpl foldl1 . ((+) .) . (*)
17:05:10 <lambdabot> (\ d -> foldl1 (\ j -> (+) (d * j)))
17:05:18 <Peaker> luite: that seems like Smalltalk
17:05:37 <Peaker> luite: how does that work with partial application?
17:05:37 <luite> Peaker: don't know where they got it from, I first saw it in agda :)
17:05:49 <Peaker> luite: its the same way as Smalltalk :)
17:06:04 <luite> don't know about partial application though
17:06:08 <roconnor> vote for swap: http://www.reddit.com/r/haskell_proposals/comments/7igsg/swap/
17:09:52 <Saizan_> libraries@ has transferred to reddit?
17:11:58 <mmorrow> omg this paper BMeph linked me to is so cool.
17:12:24 <mmorrow> the link scrolled out of my view, but i just stuck it here if anyone is interested: http://moonpatio.com/papers/LC.pdf
17:12:44 <mmorrow> it's called "Binary Lambda Calculus and Combinatory Logic"
17:13:26 <mmorrow> it gives a binary encoding for lambda terms in debruijn notation, then gives (i haven't read this part yet) an interpreter for the terms /in this binary rep/
17:14:03 <mmorrow> "Theorem 1: There is a self-interpreter E of size 210 (which happens to be the product of the smallest four primes) ... "
17:14:22 <mmorrow> i think the 210 there is bits
17:17:53 * wli has been too out-of-the-loop for too long to know if magnitude class function has been introduced that works on both real and complex numbers yet.
17:20:13 <pumpkin> > abs (1 :+ 1)
17:20:14 <lambdabot>   1.4142135623730951 :+ 0.0
17:20:18 <pumpkin> > abs (-5)
17:20:19 <lambdabot>   5
17:20:23 <pumpkin> :t abs
17:20:24 <lambdabot> forall a. (Num a) => a -> a
17:20:45 <wli> The trouble is that the result of abs for complex isn't an instance of Ord.
17:21:09 <pumpkin> yeah, it seems silly to require it to be from a -> a
17:21:22 <solrize> reconnor, swap and swap' ?
17:22:26 <roconnor> solrize: I kinda think if people want a specific swap, they should define it themselves
17:25:11 <Megzlna> What's xs short for?
17:25:30 <dons> nothing?
17:25:35 <dons> as in (x:xs)  ?
17:25:38 <pumpkin> one x, two xs
17:25:39 <Megzlna> yes
17:25:39 <pumpkin> :P
17:25:40 <leimy> "exes"
17:25:40 <cjb> methos: it's onomatopoeic
17:25:45 <Megzlna> x, x's
17:25:46 <dons> plural of 'x'
17:25:47 <pumpkin> excess?
17:25:50 <pumpkin> :P
17:25:51 <leimy> multiple x's
17:25:57 <Megzlna> heh
17:26:09 <dons> the 's' indicates it is of list type
17:26:10 <dons> :)
17:26:11 <leimy> Microsoft combined Access and Excel to make "Excess"
17:26:32 <wli> You end up needing two mostly-identical versions for real and complex numbers without something like magnitude :: Sizeable t => t -> Double
17:27:40 <leimy> hah
17:28:37 <leimy> I put a meaningless line in my program and now it does exactly what I wanted
17:28:45 <leimy>   seq (show frame) (return ())
17:28:55 <leimy> Had to force something to look at the frame
17:28:57 <leimy> and then do nothing.
17:28:58 <leimy> :-)
17:29:16 <leimy> It's the opposite of shooting one's self in the foot and being ok until you evaluate it.
17:29:31 <leimy> I was evaluating the unshooting of myself in the foot
17:29:49 <porges> wli: what we really need is the Numeric prelude ;)
17:29:52 <FunctorSalad> abs should map to a Real...
17:30:00 <FunctorSalad> (or what the right class is)
17:30:29 <porges> with its various notions of norm, etc
17:31:20 <Axman6> :t abs
17:31:21 <lambdabot> forall a. (Num a) => a -> a
17:32:36 <FunctorSalad> @src Real
17:32:37 <lambdabot> class  (Num a, Ord a) => Real a  where
17:32:37 <lambdabot>     toRational      ::  a -> Rational
17:32:46 <FunctorSalad> @src RealFraction
17:32:47 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:33:48 <roconnor> FunctorSalad: I think a proper implementation of abs needs multiparameter type classes
17:34:05 <wli> FunctorSalad: Are you suggesting abs . toRational?
17:34:56 <JohnnyL> have any of you used haskell to make games?
17:35:10 <wli> roconnor: I just need something that does this to hammer out special function libs.
17:35:12 <ozy`> JohnnyL: there are a few such projects out there
17:35:29 <ozy`> for example, there's Frag, a reimplementation of the Q3 engine
17:35:29 <mmorrow> JohnnyL: there's Frag (but i haven't tried it)
17:35:56 <wli> FunctorSalad: I don't believe Complex Double is an instance of Real, though.
17:35:59 <ozy`> (I haven't tried it either... tried to install it earlier but the cabal file is apparently malformed
17:36:02 <ozy`> )
17:36:07 <JohnnyL> ok, thats a start!. I'm working with orge3d, but c++ makes you type (and check) ridiculous amounts of inforamation. I figured haskell would be good at cutting the code down.
17:37:37 <FunctorSalad> wli: I was thinking the same as roconnor, i.e. class (Num a, Real b) => Abs a b where abs :: a -> b
17:37:59 <FunctorSalad> then "instance Abs (Complex Double) Double where ..." and so on
17:38:23 <hml> is emacs or yi the betterchoice for editing haskell code?
17:38:38 <roconnor> class Abs a b where abs :: a -> b
17:38:51 <FunctorSalad> why no context roconnor?
17:38:53 <wli> instance RealFloat t => Abs (Complex t) t?
17:38:58 <roconnor> why context?
17:39:11 <sm> JohnnyL: look at the games section on hackage
17:39:17 <FunctorSalad> so you know that the result of abs is a Real (and therefor an Ord)
17:39:20 <ozy`> hml: yi is not really mature but if you already "get" Haskell, go ahead and start implementing any features you miss from emacs
17:39:21 <wli> The Complex tycon requires the context.
17:39:38 <ozy`> I use vim, though not without some pain
17:39:45 <roconnor> I'd use type class family stuff here too
17:39:45 <wli> (The instance may not need it.)
17:39:58 <wli> I've never gotten my head around that.
17:41:00 <JohnnyL> sm: ok
17:41:16 <sm> also there's an engine called fungen
17:41:51 <dons> a challenge! http://www.reddit.com/r/haskell/comments/7ih2a/a_somewhat_failed_adventure_in_haskell_abstraction/
17:42:05 <sm> but for 3d stuff, you probably want to look at frag, roguestar and .. what is it.. fieldtrip
17:42:05 <mdmkolbe> What does this mean?
17:42:06 <mdmkolbe> $ cabal upgrade
17:42:06 <mdmkolbe> Resolving dependencies...
17:42:06 <mdmkolbe> cabal: Couldn't read cabal file "./yi/0.5.2/yi.cabal"
17:42:18 <dons> weird.
17:42:44 <roconnor> If you want to try out the code below, use these Haskell extensions:
17:42:44 <roconnor> {-# LANGUAGE TypeFamilies, MultiParamTypeClasses, OverloadedStrings,
17:42:44 <roconnor>    FlexibleInstances, TypeSynonymInstances, ScopedTypeVariables,
17:42:44 <roconnor>    FunctionalDependencies, RecordWildCards, FlexibleContexts,
17:42:44 <roconnor>    GeneralizedNewtypeDeriving #-}
17:42:52 <roconnor> ...
17:42:59 <roconnor> not a promising start :P
17:43:07 <wli> roconnor: I'm not too worried about how it's implemented, only that it's in the std. libs so I don't rely on something that eventually clashes with std. libs or introduces something controversial.
17:43:10 <dons> hehe. roconnor no no.
17:43:34 <ozy`> roconnor: aaaargh
17:43:35 <FunctorSalad> haddock could really use a parameter "don't fail everything upon parse error"
17:43:44 <roconnor> wli: multiparameter type classes aren't standarized
17:43:45 <dons> FunctorSalad: hmm
17:44:06 <roconnor> wli: so getting a proper abs in the std. libs is problematic
17:44:16 <mm_freak_> i'm calling IO a state monad in my tutorial, as in:  "The 'forever' function is almost only useful in state monads."
17:44:20 <mm_freak_> what do you think?
17:44:30 <FunctorSalad> dons: sometimes you really need the documentation because there's none on hackage, and it fails because of some silly syntax error in the haddock comment :(
17:44:35 <wli> roconnor: Could something less controversial be introduced to enable numerical methods polymorphic across both real and complex numbers?
17:44:41 <solrize> "That's not abstraction, that's obstruction."    heh
17:44:43 <ozy`> mdmkolbe: that's exactly the problem I had with frag
17:44:54 <dejones> can a function call be used as the pattern match in a case statement?  such as case of x; getY -> x; getZ -> x*x;  ?
17:45:18 <mm_freak_> dejones: no
17:45:27 <wli> roconnor: The task is essentially the numerical methods task in the wanted libs, i.e. a rounded-out repertoire of higher transcendental functions.
17:45:32 <dejones> mm_freak_: Suggestions for something that would accomplish the same...?
17:45:53 <dejones> (without nested if-else statements preferably...)
17:46:07 <mm_freak_> dejones: i don't understand what you're trying to do
17:46:18 <mm_freak_> let (x,y) = (getX, getY) in 
17:46:31 <roconnor> ``To try out different implementations I need to edit the Person module.
17:46:33 <roconnor> huh?
17:46:37 <mdmkolbe> ozy`: were you ever able to fix it?
17:46:50 <ozy`> mdmkolbe: I didn't try a whole lot of stuff
17:47:11 <hml> woot, my 'haskell school of expression' book just arrived
17:47:27 <dons> hml, oh interesting. didn't look at RWH?
17:47:49 <hml> going to read both
17:47:55 <hml> soe first, it has pretty pictures
17:48:03 <dejones> mm_freak_: well, I'm assigning IDs to particular variables (which really are function calls since I can't use a global or a #define, like in C), and I want to pattern match with a case-statement on the values returned from the set of functions to know what value to return.
17:48:14 <dons> heh
17:48:16 <dejones> mm_freak_: Hopefully that clarifies, lol.
17:48:18 <hml> dons: btw, any luck w/ that bug?
17:48:23 <hml> dons: rather, "bug"
17:49:00 <mm_freak_> dejones: i mean, what's the application?  your description is very influenced by imperative thinking
17:49:18 <mm_freak_> it doesn't make much sense in haskell
17:49:32 <FunctorSalad> dejones: I'm not saying that this is the best solution, but you *do* have #define in haskell ;)
17:49:38 <FunctorSalad> dejones: (with -XCPP)
17:50:08 <mm_freak_> about #define, you usually get along with top-level functions, but this isn't the best solution either  use the type system ;)
17:50:44 <FunctorSalad> mm_freak_: it is handy if the class/type declarations themselves become huge though ;)
17:50:44 <dejones> mm_freak_: I've got Chess pieces, and for each piece I've given it an ID, such as pawn = 1, rook = 2, and so on.
17:51:05 <dejones> mm_freak_: I guess I should declare a data type for the pieces...
17:51:09 <roconnor> I don't see why augustss doesn't swap modules in and out?  I've used symlinks for this in the past.
17:51:13 <wli> FunctorSalad: Maybe preprocessing and some suffixed naming convention is all that can be done until the abs issue is resolved.
17:51:28 <mm_freak_> dejones: yes:  data Piece = Pawn | Rook | 
17:51:51 <solrize> @seen augustss
17:51:52 <lambdabot> I saw augustss leaving #haskell 1m 25d 46m 12s ago, and .
17:51:53 <FunctorSalad> wli: if you need to remain haskell98, I suppose
17:51:55 <dejones> mm_freak_: Yeah, that's the best route.  Thanks for the clarification.  :)
17:52:18 <mm_freak_> and a chess board is best represented by an array, have a look at Data.Array or Data.Array.Unboxed
17:52:42 <wli> FunctorSalad: It's not so much to remain h98 as to avoid extraneous dependencies.
17:52:45 <dejones> mm_freak_: Thanks again.
17:53:24 <wli> FunctorSalad: And also to write to some standard.
17:53:30 <FunctorSalad> wli: hmm, you could include the multiparam abs in your package and just not import abs from the Prelude
17:55:06 <mmorrow> that'd be nice if there was something like
17:55:08 <mmorrow> instance Functor (\a -> (a,b)) where ...
17:55:27 <mmorrow> so you could write Functor instance for stuff without having to newtype-wrap them
17:55:48 <JohnnyL> are you supposed to install the glut binaries then use the glut from hackage?
17:56:10 <mmorrow> JohnnyL: are you on windows or unix?
17:56:33 <rgov> Anyone have an explanation for these errors: http://pastebin.ca/1281257
17:57:08 <JohnnyL> mmorrow windows.
17:57:20 <wli> FunctorSalad: And perhaps not export it so e.g. h98 code can interoperate with it? Or does that work?
17:57:25 <mmorrow> JohnnyL: hmm, i'm not sure about on windows
17:57:30 <mmorrow> (wrt GLUT)
17:58:15 <wli> FunctorSalad: All this stuff is only really one type frommonomorphic, namely Double and Complex Double are the only two types they need to work for.
17:58:47 <nuncanada> hello all. How do i update my base package to version 4.0?
17:58:56 <nuncanada> ghc 6,8,2?
17:59:06 <dons> nuncanada: you can't, unfortunately.
17:59:07 <leimy> rgov: whoa
17:59:11 <JohnnyL> wow it's been awhile since I've seen anything from you wli! :) It's trinsic.
17:59:20 <geezusfreeek> a proper module system would be nice, yes
17:59:21 <dons> nuncanada: you could upgrade to ghc 6.10 if you've got something that requires base 4
17:59:31 <geezusfreeek> (referring to the article linked earlier)
17:59:33 <nuncanada> dons, thanks, will do it
17:59:47 <dons> nuncanada: what are you using that needs base 4?
18:00:39 <rgov> is there a way to tell ghc which as to use
18:00:57 <dons> rgov: it uses gcc. so whatever gcc flag
18:01:10 <dons> might be hte -pgma flag?
18:01:14 <dons> check the user's guide
18:02:30 <FunctorSalad> wli: I have no idea whether it can interoperate with h98 code if it's only internal
18:03:23 <leimy> seems like thats an ABI issue
18:04:14 <wli> FunctorSalad: My lame Sizeable class (which I think I can hide) just does class Sizeable t where size :: t -> Double or something very similar.
18:04:47 <nuncanada> dons, yi from the darcs repository
18:06:48 <FunctorSalad> wli: if it's only for internal use and you only need one instance, why not just make abs monomorphic (abs :: Complex Double -> Double)? :)
18:07:50 <august> how do i test code like http://hpaste.org/12916 from ghci without putting it in it's own file and loading it?
18:08:34 <Megzlna> Is it possible to specify range matchings directly in a function's args without if-else?
18:08:50 <roconnor> august: let {factorial :: (Integral a) => a -> a  ; factorial 0 = 1; factorial n = n * factorial (n - 1)}
18:08:54 <roconnor> maybe
18:09:08 <Axman6> Megzlna: what do you need?
18:09:17 <Megzlna> f (<100) = true
18:09:28 <august> roconnor: that works
18:09:30 <august> thanks
18:09:41 <Axman6> f x = x < 100?
18:09:42 <roconnor> august: feel free to karma me
18:09:43 <roconnor> :P
18:09:44 <FunctorSalad> Megzlna: f = (< 100)
18:09:48 <august> roconnor++
18:09:49 <Megzlna> Sure, but
18:09:51 <Axman6> or that
18:09:54 <roconnor> cha ching
18:09:55 <Megzlna> Can you do that stuff on the left hand side?
18:09:57 <Megzlna> At all
18:10:03 <Axman6> or use guards if you need more control
18:10:07 <Megzlna> You can do it for fixed:  f 0 = 100
18:10:07 <Axman6> no
18:10:11 <Megzlna> So why not more things
18:10:37 <Axman6> that's a patten patch, it's not testing anything other than if it is 0
18:11:03 <wli> FunctorSalad: I need numerical code for real and complex numbers to be shared.
18:11:04 <Axman6> pattern*
18:11:22 <FunctorSalad> wli: then Sizeable looks good
18:11:36 <Axman6> Megzlna: check out guards: f x | x < 100 = something | oetherwise = someOtherThing
18:11:55 <JohnnyL> wli: how much reduction in code would you say haskell has over, say, c++?
18:11:55 <Megzlna> k.
18:12:13 <Axman6> you can have an many guards as you want
18:12:45 <wli> FunctorSalad: Now I just have to hide it from type signatures somehow. :(
18:12:58 <Axman6> usually you'd line up the |'s on consecutive lines
18:16:00 <dons> Cale: http://mathbin.net/
18:16:11 <wli> FunctorSalad: I guess I can just hide the polymorphic versions and export monomorphic ones when this desperate.
18:16:36 <dons> we should hook this in to hpaste 2.0
18:16:50 <pumpkin> I like the idea of mathbin, I wanted to make something like it myself
18:16:55 <pumpkin> but it's kinda ugly and ad-packed
18:17:00 <pumpkin> I might make something simpler and prettier
18:17:04 <dons> yeah, just tweak gitit.
18:17:10 <dons> it already supports latex
18:17:15 <dons> so a cross between gitit and hpaste
18:17:34 <pumpkin> gist is actually pretty nice
18:17:36 <pumpkin> from github
18:17:40 <JohnnyL> wli: thanks for the ignore.
18:17:45 <pumpkin> but it lacks latex support
18:17:53 <pumpkin> that was weird?
18:18:11 <dons> hey. we do this in haskell, pumpkin :) hpaste! gitit! pandoc!
18:18:26 <wli> JohnnyL: I just got disconnected from my cellular modem connection and had to go in through my phone to IRC. Sorry if I missed something.
18:18:30 <Axman6> dons: mathbin looks awesome :)
18:19:26 <Axman6> for people on OS X, if you need to make LaTeX math equations, nothing beats Grapher.app. just type in your equation, and right click on it and copy as LaTeX
18:19:54 <wli> Are there any base or std. lib proposals or ghc feature requests or anything pertinent to this abs issue?
18:20:17 <Megzlna> > [0.1 .. 1.0]
18:20:18 <lambdabot>   [0.1,1.1]
18:20:45 <Axman6> "< JohnnyL> wli: how much reduction in code would you say haskell has over, say, c++?" maybe 10:1 C++:Haskell?
18:21:03 <Axman6> > [0.0,0.1..1.0]
18:21:05 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
18:21:13 <Axman6> > [0.0,0.1..1.0] :: [CReal]
18:21:14 <lambdabot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
18:21:29 <ddarius> He's not here.
18:21:40 <wli> JohnnyL: I'm not an expert on that sort of thing. 10:1 sounds plausible but I've never been involved with or paid attention to those studies.
18:21:42 <Axman6> ah, heh
18:21:52 <Cale> august: usually though, you always put code in a file. I like to keep two terminal windows open side by side with my editor and ghci
18:22:05 <Cale> august: :r will reload the file in ghci
18:22:17 <pumpkin> dons: yessir!
18:22:20 <Axman6> wli: pfft, what do studies know, everyone knows that 84% of made up stats are more reliable than those attained from studies
18:22:22 <wli> I need to get a *nix box with ghci at some point.
18:22:31 <august> Cale: i was hoping for something more interactive
18:22:36 <dejones> mm_freak_: Still here?  I don't understand why this is still giving me the warning about overlapping patterns.  http://hpaste.org/12917
18:22:38 <august> as i learn the language
18:22:47 <dejones> Hi Cale, how ya been?  :)
18:22:54 <Cale> dejones: I'm well :)
18:22:55 <dejones> Cale: Get a lot of snow in Canada yet?
18:23:19 <Cale> dejones: Just a little, and it rained a bunch today, so there's not much left.
18:23:23 <dejones> Cale: Maybe you can tell me why I am getting an overlapping patterns warning?  http://hpaste.org/12917    :)
18:23:32 <mm_freak_> dejones: because you exhausted the set of values
18:23:34 <dejones> Cale: Ahh...  Lots of snow to come then!  ;)
18:23:45 <dejones> mm_freak_: Hmm.
18:23:50 <august> dejones: put the
18:23:53 <august> _ in ()?
18:24:01 <mm_freak_> dejones: if you want to make sure, add a Null value, but i wouldn't
18:24:27 <dejones> mm_freak_: Oh, I was just putting _ for error catching, but I guess the compiler does do that for me.  ;)
18:24:29 <mm_freak_> if pattern match fails, you get an exception anyway
18:24:30 <Cale> august: It is reasonably interactive that way. You do need to keep a file going, but it's not so bad :)  I would like to have a mathematica style notebook interface though.
18:24:38 <dejones> mm_freak_: Right.  Thanks!  :)
18:24:45 <wli> dons: Well, I think this abs issue I've been going on about is blocking an implementation of a special function lib.
18:25:09 <august> hmm
18:25:11 <dejones> Cale: Have fun with the snow.  Gotta get back to work, cya.
18:25:17 <august> does textmate do haskell
18:25:17 <Cale> dejones: later :)
18:25:28 <Axman6> august: sure
18:25:36 <Axman6> could do with a little work, but it works fine for me
18:25:41 <august> then i can keep a scratch there
18:25:45 <ozy`> august: yes, it technically does, but god help you if you ever need to indent something
18:25:49 <Cale> august: any texteditor which can be configured to convert tabs to spaces automatically should be fine
18:25:52 <august> what's Literate Haskel?
18:26:00 <Axman6> ozy`: yes, that does shit me
18:26:00 <leimy> awesome
18:26:01 <august> l
18:26:20 <ozy`> august: that's Haskell code embedded in a LaTeX document
18:26:26 <ozy`> (basically)
18:26:27 <august> ah
18:26:27 <Cale> august: Literate Haskell is a mode where lines are comments by default
18:26:29 <Axman6> august: all your comments are just written our, and you tell the compiler where there's code, not where there isn't
18:26:41 <gwern> ozy`: what about bird-style markup? :)
18:26:54 <ozy`> gwern: \O_o/
18:27:01 <Cale> There are two versions of it: one where "> " on the start of a line indicates it's code, and another where \begin{code} \end{code} surround code blocks (for LaTeX)
18:27:02 <Axman6> this would be a comment
18:27:05 <ozy`> I didn't know lhs did anything other than LaTeX
18:27:09 <Axman6> > this would = code
18:27:36 <lambdabot>   <no location info>: parse error on input `='
18:27:54 <gwern> ozy`: oh, see what Cale said. bird-style also allows you to do ReST (?) document formatting around it
18:27:57 <Cale> The former is quite useful for embedding Haskell code in other kinds of documents, like web pages.
18:27:59 <august> Load In Haskell failed
18:28:03 <august> err
18:28:07 <august> Load In GHCi
18:28:22 <Axman6> yeah, just use a terminal, it's much easier. the bundle needs work
18:28:31 <leimy> oooh permutations
18:28:46 <leimy> i could/should use that
18:28:57 <Cale> http://manual.macromates.com/en/working_with_text.html#using_spaces_instead_of_tabs -- important for using textmate
18:28:58 <leimy> in my Facebook Word Challenge Cheater program thingy
18:29:14 <august> seems silly to have to save a file to disk each time i want to test anything
18:29:27 <Cale> august: It's really not so bad.
18:29:35 <Axman6> yeah it's really not
18:29:43 <ozy`> august: you can do that, or you can use emacs
18:30:03 <Cale> august: It ensures that your code is always something consistent.
18:30:23 <Axman6> so, seems lik there's a few mac users around. who'd like to help me make a haskell macports? (the devs are grumbling about tcl having its limitations, and i think haskell would be a perfect replcement)
18:30:29 <august> unless it has syntax errors
18:30:45 <Axman6> Beelsebob and yitz and I were discussing it last night
18:30:49 <Cale> (You don't end up with some program state which is actually unattainable because it resulted from different versions of code.)
18:31:07 <ozy`> Axman6: that would be interesting. the main problem with macports, I think, is that all the packages suck...
18:31:10 <august> i just want to play around with the language
18:31:22 <Axman6> ozy`: how so? GHC's in there ;)
18:31:26 <ozy`> (well, not -all- the packages...)
18:31:28 <august> not save my scratch for future generations
18:31:42 <Cale> august: I usually just create a Scratch.hs and put whatever I'm playing around with in there, and then delete it after, if it's not worth keeping.
18:31:48 <ozy`> Axman6: any package used by fewer than 500 people tends to not compile... and nobody fixes them
18:32:15 <ozy`> I don't remember if the other Haskell compilers work
18:32:17 <Axman6> ozy`: if you know of a broken port, you can fix it and file a fix
18:32:27 <Axman6> hugs works
18:32:33 <ozy`> Axman6: heh, if I knew how to fix the ones that were broken :p
18:32:43 <Axman6> well quit complaining then :P
18:33:04 <Cale> august: It's just one command, and you're already in the terminal when you quit ghci ;)
18:33:50 <ozy`> august: ghci has the :reload command, which reloads the last file (obviously)
18:33:57 <ozy`> which should save you some typing
18:34:03 <august> why should i need 2 programs to use haskell?
18:34:12 <Axman6> ...
18:34:16 <ozy`> august: you don't. use emacs
18:34:18 <mmorrow> well, ghc uses ld ...
18:34:34 <mmorrow> so 3 at least ;)
18:34:34 <Axman6> well you don't, you can do everyrhing in ghci, but it's easier in a text editor and ghci
18:34:46 <august> why is it harder than python?
18:34:59 <Axman6> august: name another language where you don't have to use more than one program?
18:35:07 <ozy`> Axman6: well... Java
18:35:14 <ozy`> (using Eclipse)
18:35:19 <august> i don't have to have an editor open to try out python
18:35:25 <gwern> kind of curious, does anyone else get frequent errors loading reddit?
18:35:36 <Axman6> ozy`: you're still using java and ecplise, they aren't one thing :P
18:35:44 <ozy`> august: you know you can type stuff straight into ghci, right?
18:35:51 <Axman6> august: nor do you have to with haskell, you can do most things in ghci
18:36:08 <Cale> august: It's only if you want to make new declarations that you need a file.
18:36:09 <august> except you have to put let infront of everything
18:36:11 <Axman6> just use let in ghci
18:36:16 <Axman6> ...
18:36:16 <ozy`> Axman6: he clearly wants a single unified interface to everything having to do with the language
18:36:24 <august> no
18:36:27 <Axman6> don't you have to put def infront of python stuff?
18:36:33 <Cale> I recommend against using let to make declarations, because you can lose your work.
18:36:46 <pumpkin> ohai august
18:36:46 <august> i want to write haskell in the interactive vm the same way as a file
18:36:49 <mmorrow> august: just do  ghci> writeFile "Scratch.hs" "data A = A deriving (Show)"
18:36:53 <mmorrow> :l Scratch.hs
18:36:58 <mmorrow> A
18:36:59 <Cale> hehe :)
18:37:02 <ozy`> hah
18:37:04 <mmorrow> august: just do  ghci> writeFile "Scratch.hs" "data A = A | B deriving (Show)"
18:37:05 <mmorrow> :r
18:37:44 <Axman6> august: well do it then
18:37:52 <Axman6> there's nothing stopping you
18:38:14 <Axman6> heck, just use lambdabot
18:38:25 <august>  http://hpaste.org/12916 doesn't work typing it into ghci
18:38:33 <Axman6> @let fac 0 = 1; fac n = n * fac (n-1)
18:38:34 <Korollary> You can't put class declarations in ghci, can you?
18:38:36 <lambdabot>  Defined.
18:38:37 <Axman6> > fac 100
18:38:46 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
18:38:48 <Axman6> Korollary: no
18:38:54 <Korollary> So he can't have it.
18:39:01 <august> why should i have to use let in one case but not the other?
18:39:06 <ddarius> Install hbc
18:39:10 <Axman6> he can have most of it
18:39:12 <mmorrow> haha, i was just about to say that
18:39:18 <mmorrow> (@ddarius)
18:39:28 <Axman6> far out, never met anyone so picky and lazy
18:39:31 <mmorrow> but then you have to deal with vanilla haskell98
18:39:45 <ddarius> mmorrow: It has extensions that GHC doesn't even have.
18:39:57 <ddarius> And most versions are Haskell 1.4
18:40:03 <ddarius> Which many would consider a plus.
18:40:21 <ozy`> august: it's... a long story.
18:40:25 <mmorrow> ddarius: aw crap, i seem to have the haskell98 one
18:40:53 <mmorrow> [m@ganon ~]$ hbi
18:40:53 <mmorrow> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
18:40:55 <ddarius> 0.99995 is Haskell 98, 0.99994 should be Haskell 1.4
18:41:18 * mmorrow tracks 0.99994 down
18:42:37 <Cale> august: ghci pretends to be the inside of an IO do-block, except that when you type an expression which is not an IO action, it applies 'print' to it.
18:42:49 <mmorrow> > data A = A deriving (Show);
18:42:49 <mmorrow> > A;
18:42:49 <mmorrow> A
18:42:51 <lambdabot>   <no location info>: parse error on input `data'
18:42:51 <lambdabot>   Not in scope: data constructor `A'
18:42:53 <mmorrow> hbi++
18:43:18 <Korollary> mmorrow: I guess now you have to pay attention to the ordering of declarations, though.
18:43:27 <ddarius> mmorrow: Is there any multiline input mode or do mutually recursive definitions need to be separated by ; ?
18:44:03 <wli> Multiline input would be nice.
18:44:25 <ozy`> ghci has :{ ... :}, but it's still ghci
18:44:28 <Cale> I wonder how tough it would be to write a notebook interface for GHC. Or at least a Dr. Scheme style interface :)
18:45:02 <mmorrow> ddarius: multiline is the default, and ';' terminates an expression
18:45:03 <Korollary> Cale: What is a notebook interface?
18:45:10 <Cale> Korollary: Like Mathematica
18:45:22 <Korollary> I haven't seen Mathematica.
18:45:31 <august> like R
18:45:33 <Axman6> mathematica is painful
18:45:35 <august> like Matlab
18:45:46 <Korollary> I vaguely remember matlab...
18:46:14 <mmorrow> Korollary: sure, but that's no worse than wrt function definitions in ghci
18:46:15 <redditbot> A somewhat failed adventure in Haskell abstraction
18:46:25 <Cale> Korollary: You have a document which is broken up vertically into cells, which can contain text or code (and in Haskell's case, we'd probably differentiate between declaration cells and expression cells)
18:46:26 <mmorrow> let f = 24
18:46:29 <mmorrow> let g = f
18:46:32 <mmorrow> let f = undefined
18:46:33 <wli> zsh-style command-line editing and various things besides function/constant definitions would be nice.
18:46:33 <mmorrow> g
18:46:36 <Korollary> mmorrow: I wasn't comparing it to ghci. I was comparing to an hs module.
18:46:48 <mmorrow> oh, well yeah then
18:46:50 <Cale> Korollary: You can type as much as you want in a cell, and then Shift-Enter commits it, and evaluates it if it's an expression.
18:47:07 <Philippa_> Cale: that sounds a lot it could be built around literate haskell, too
18:47:11 <Cale> You can go back to previous expressions that you've entered, edit them, and then commit them again.
18:47:20 <Philippa_> you might want separate \code and \eval...
18:47:23 <mmorrow> Korollary: but since multiline input is the default, you don't have to worry about order in a single multiline decl group
18:47:26 <Cale> (and the new results replace the old)
18:47:36 <Cale> Philippa_: yeah :)
18:47:42 <ozy`> redditbot: you're completely and utterly useless
18:47:53 * ozy` punches redditbot 'til it bleeds
18:47:59 <mmorrow> Philippa: totally, different input modes i think would be awesome
18:48:18 <Cale> and then, once that's in place, you can start doing dynamic things :)
18:48:49 <Cale> Well, hmm :)
18:49:00 <Korollary> Cale: It wouldn't be terribly hard in the UI dept, but it would involve things like where referenced modules should be resolved from, etc.
18:49:19 <ozy`> august: see, the Haskell community has acknowledged that this is a problem with the available language tools :p
18:49:21 <ddarius> @where vital
18:49:21 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
18:49:24 <Cale> Korollary: Well, it is a custom editor widget.
18:49:37 <wli> I made a few attempts to get a cmdline editing lib going from the ground up (for several meanings of that) in Haskell, and mostly failed. Mostly I just wanted behavior infeasible in readline.
18:49:41 <august> ozy`: that's basically what i was trying to get at
18:49:42 <Philippa_> doesn't have to be that, either
18:50:08 <Philippa_> it can be just a single list of text editors
18:50:34 <wli> I think where I got killed was something involving signal handling vs. RTS internals.
18:51:01 <Cale> http://reference.wolfram.com/mathematica/tutorial/UsingANotebookInterface.html -- this gives a good idea about what Mathematica looks like
18:51:27 <cjb> Cale: python has a notebook shell called reInteract
18:51:50 <august> there's ipython which does the in/out stuff
18:51:56 <cjb> http://fishsoup.net/software/reinteract/
18:52:26 <cjb> august: this is more like mathematica than ipython; it even does dependency tracking so you can go back and change a variable and have dependent variables recalculated automatically.
18:52:35 <august> ah
18:52:36 <august> nice
18:52:46 <mm_freak_> @let factor n = fix (\k l n p x -> if x*x >= n then l p else k l n (p*x) (x+1)) (fix (\k x y -> if y == 0 then x else k y (x `mod` y)) n) n 1 2
18:52:48 <lambdabot>  Defined.
18:52:52 <mm_freak_> > factor 15
18:52:53 <lambdabot>   3
18:52:55 <wli> dons: I would call Vital a structure editor for Haskell.
18:53:09 <mm_freak_> in that sense, good night people =)
18:54:13 <mmorrow> too bad vital's written in java :(
18:54:32 <mmorrow> well, the web interface i mean
18:55:03 <mmorrow> ugh, the whole thing appears to be in java
18:55:18 <cjb> ooh, vital looks great
18:55:20 <cjb> I hadn't seen it
18:55:28 <mmorrow> it does look great
18:55:50 <mmorrow> (the idea looks great)
19:00:35 <FunctorSalad> re haskell coding interfaces, how about commutative diagrams? :)
19:01:23 <Cale> With quickchecking?
19:01:23 <ddarius> How Vital does type classes is a very good illustration of the differences between Haskell type classes and OO classes.
19:01:31 <ddarius> (or OO interfaces)
19:02:14 <Axman6> @hoogle FilePath
19:02:15 <lambdabot> module System.FilePath
19:02:15 <lambdabot> Prelude type FilePath = String
19:02:15 <lambdabot> System.IO type FilePath = String
19:02:59 <FunctorSalad> Cale: hmm, I wasn't thinking about actually checking commutativity... it would commute by construction, e.g. catamorphisms
19:04:16 <Cale> ddarius: Yeah, ew.
19:04:17 <FunctorSalad> you could have some function f = g.h, and when f is used in some other diagram you could "zoom in" on f and get the triangle f = g.h
19:04:59 <Cale> FunctorSalad: I can see how it would work for purely compositional code.
19:05:30 <ddarius> Cale: It could work, but it would be natural to neither Haskellers not category theorists.
19:05:40 <ddarius> You couldn't write f . g = h . k meaningfully.
19:05:41 <Cale> Our usual applicative notation and pattern matching becomes somewhat verbose when trying to turn it into a diagram.
19:05:59 <ddarius> (at least not as anything that corresponds to something in Haskell)
19:06:23 <ddarius> Cale: Compositional code becomes verbose as well and that's the ideal case.
19:08:18 <FunctorSalad> application on x would just become composition with (\() -> x)
19:09:17 <Cale> and you'd have lots of exponential lifting and unlifting going on, probably...
19:09:35 <ozy`> august: Vital looks like it's exactly what you want. are you using it now?
19:09:57 <ddarius> ozy`: Vital doesn't actually execute Haskell.
19:10:04 <Megzlna> this mofo better work for real code
19:10:07 <FunctorSalad> Cale: the uncurried form would probably be more intuitive (think the pictures from the Arrow tutorial)
19:10:14 <ozy`> ddarius: I see
19:10:39 <ddarius> (perhaps "execute actual Haskell" would be a bit more clear)
19:10:43 <ozy`> august wants to try before he buys, though ("buy" meaning "invest the time to learn")
19:11:00 <Cale> Megzlna: hm?
19:11:19 <august> i want to be able to write haskell from an interactive interpreter
19:11:35 <mib_cdv0t5> accumulate [5,4,3,2,1] -> [15,106,3,1]
19:11:36 <august> the same way it would be written in a file
19:11:45 <Megzlna> Cale: As I sleep, I think about how to make a program which is immutable.
19:11:47 <FunctorSalad> what's wrong with emacs buffer, C-c C-l ?
19:11:51 <mib_cdv0t5> i want to write a accumulate function using foldr
19:11:55 <mib_cdv0t5> any help???
19:11:57 <Axman6> august: you've been told how to
19:11:58 <dmwit> The 'i' in ghci is "interpreter"! =)
19:12:16 <Cale> mib_cdv0t5: It's not clear from that example what it's meant to do...
19:12:16 <august> Axman6: i've been told convoluted workarounds
19:12:16 <FunctorSalad> you can't do decls in ghci, that's probably the issue
19:12:44 <mib_cdv0t5> it takes the previous elements and and them to the next
19:12:47 <ozy`> can you do declarations in hugs?
19:12:52 <ozy`> or any other interpreter?
19:12:53 <mib_cdv0t5> 1+2
19:12:58 <ozy`> (I've only ever tried ghci)
19:12:58 <mib_cdv0t5> 1+2+3
19:13:08 <mib_cdv0t5> 1+2+3+4
19:13:10 <Axman6> august: there's hbc which can do what you want, or you can use ghci, which will let you do 90% of the stuff you need to, or you can do what everyone else does and use a text editor so you don't lose your work
19:13:24 <mib_cdv0t5> 1+2+3+4+5
19:13:56 <Megzlna> Cale: I want to read a description of how an pure program is written, starting at the entry point.
19:14:03 <august> Axman6: you're not getting it
19:14:39 <Axman6> no, i tend to not 'get' extremely picky people
19:14:45 <ozy`> august: you're not being clear enough then
19:15:00 <Megzlna> The "flow"
19:15:16 <Cale> Megzlna: Well, in Haskell, the top-level is a description of something which is impure: an IO action.
19:15:22 <Axman6> Megzlna: what do you mean by a pure program?
19:15:37 <FunctorSalad> you can set up your editor to read the current file into ghci with one keystroke... how would a interpreter that accepts decls be better?
19:15:39 <Megzlna> yes Cale
19:16:00 <Cale> Megzlna: from there, you do some input, which gives you values which can be passed to pure functions that do the real work of the program and determine what output should be done
19:17:28 <Axman6> i've brought this up before, but can Output be considered pure in something like haskell? if it's just output, then it can't effect the program flow, unless it takes input back from the action
19:17:43 <Megzlna> unthreadsafe
19:17:43 <ozy`> hey cool, you can abuse do-notation just to avoid writing the "in" keyword
19:17:58 <Megzlna> Output is a resource
19:18:23 <Axman6> it's not threadsafe anyway
19:18:24 <Megzlna> has side effects potentially outside your control
19:18:27 <ozy`> http://hpaste.org/12918
19:18:47 <Cale> The order in which output occurs generally matters
19:18:56 <ozy`> inter :: t -> [Char]
19:18:58 <Cale> So you wouldn't want it to depend on the evaluation order.
19:19:32 <Axman6> Megzlna: like?
19:19:51 <Cale> But you could, say, have just a list of things which were supposed to happen, and that would be considered the output.
19:19:52 <mmorrow> ./myprog | head -1 | if [[ `cat` == "1" ]]; then rm -rf /';fi
19:20:01 <Cale> (and which wouldn't depend on any input)
19:20:03 <ozy`> august: what exactly do you want to do that you can't do with hbc?
19:20:20 <Megzlna> You want to use strict evaluation when you need __________________?
19:20:27 <roconnor> > do "Hello" "World"
19:20:28 <august> i haven't looked at hbc, i don't really care all that much
19:20:28 <lambdabot>   Couldn't match expected type `t2 -> t t1'
19:20:38 <roconnor> > do {"Hello"; "World"}
19:20:40 <lambdabot>   "WorldWorldWorldWorldWorld"
19:20:54 <Axman6> :|
19:21:23 <ozy`> roconnor: well if the preceding lines aren't let expressions, then of course it'll combine them with >> or >>=
19:21:33 <Axman6> > do { "test"; "thing"; "foo"}
19:21:34 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo"
19:21:59 <ozy`> Axman6: how thoroughly do you understand do-notation?
19:22:14 <Axman6> obviously not as much as i though
19:22:25 <Cale> This is occurring in the list monad
19:22:27 <mmorrow> that's just the list monad
19:22:34 <Axman6> @undo do { "test"; "thing"; "foo"}
19:22:35 <lambdabot> "test" >> "thing" >> "foo"
19:22:41 <Cale> > do { x <- "test"; y <- "thing"; z <- "foo"; return z}
19:22:42 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo"
19:22:51 <Cale> > do { x <- "test"; y <- "thing"; z <- "foo"; return (x,y,z)}
19:22:53 <lambdabot>   [('t','t','f'),('t','t','o'),('t','t','o'),('t','h','f'),('t','h','o'),('t'...
19:23:09 <Axman6> yeah, that makes sense, it was just a little surprising
19:23:35 <Axman6> :t foldr (>>)
19:23:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> [m a] -> m b
19:24:04 <Axman6> > foldr (>>) "a" ["abc","def"]
19:24:06 <lambdabot>   "aaaaaaaaa"
19:24:15 <Axman6> > foldl (>>) "a" ["abc","def"]
19:24:17 <lambdabot>   "defdefdef"
19:24:26 <Axman6> > foldl (>>) "xyz" ["abc","def"]
19:24:28 <lambdabot>   "defdefdefdefdefdefdefdefdef"
19:24:44 <Cale> Megzlna: You want strict evaluation when you need to take a bunch of data which could be separately evaluated, and summarise it into a single value with few parts that could be evaluated separately.
19:25:15 <Cale> (and not by searching through the input, but genuinely using it all)
19:26:13 <mib_cdv0t5> accumulate [5,4,3,2,1] -> [15,10,6,3,1]
19:26:20 <Cale> mib_cdv0t5: aha
19:26:28 <mib_cdv0t5> trying to build an accumulate function
19:26:35 <mib_cdv0t5> using foldr
19:26:37 <Cale> > scanr (+) 0 [5,4,3,2,1]
19:26:39 <lambdabot>   [15,10,6,3,1,0]
19:26:44 <Cale> > scanr1 (+) [5,4,3,2,1]
19:26:45 <mib_cdv0t5> any help?
19:26:45 <lambdabot>   [15,10,6,3,1]
19:26:55 <Cale> accumulate = scanr1 (+)
19:27:09 <mib_cdv0t5> @scr scanr
19:27:09 <lambdabot> Maybe you meant: arr rc src
19:27:09 <Axman6> @src scanr
19:27:10 <lambdabot> scanr _ q0 []     =  [q0]
19:27:10 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
19:27:10 <lambdabot>     where qs@(q:_) = scanr f q0 xs
19:27:24 <mmorrow> @src scanl
19:27:24 <lambdabot> scanl f q ls = q : case ls of
19:27:24 <lambdabot>     []   -> []
19:27:24 <lambdabot>     x:xs -> scanl f (f q x) xs
19:27:33 <mib_cdv0t5> cale using foldr?
19:27:40 <Cale> hmm...
19:27:48 <mmorrow> heh
19:27:49 <Cale> can this be done sanely with foldr...
19:27:57 <Cale> Well, there's the silly way:
19:28:07 <mmorrow> reverse!
19:28:23 <idnar> unfoldr!
19:28:28 <Cale> > map (foldr (+) 0) (tails xs)
19:28:29 <lambdabot>   Not in scope: `xs'
19:28:33 <Cale> > map (foldr (+) 0) (tails [1,2,3,4,5])
19:28:35 <lambdabot>   [15,14,12,9,5,0]
19:28:35 <mmorrow> oh i just saw the question
19:28:38 <Cale> er, no
19:28:52 <Cale> > map (foldr (+) 0) (tails [5,4,3,2,1])
19:28:54 <lambdabot>   [15,10,6,3,1,0]
19:28:59 <Cale> > init (map (foldr (+) 0) (tails [5,4,3,2,1]))
19:29:01 <lambdabot>   [15,10,6,3,1]
19:29:13 <Cale> But that's not exactly making the best of foldr :)
19:29:21 <Cale> Let's see...
19:30:06 <Cale> When we add an item to the list, we want to add the new sum to the front of the result.
19:30:21 <mmorrow> , foldr (\(n,a) b -> (n+b, n+b:a)) (0,[]) [0..9]
19:30:32 <lunabot>  luna: Occurs check: cannot construct the infinite type: b = (b, [b])
19:30:45 <Cale> > foldr (\x xs -> case xs of [] -> [x]; (y:ys) -> (x+y:y:ys)) [] [5,4,3,2,1]
19:30:47 <lambdabot>   [15,10,6,3,1]
19:30:56 <Cale> That works.
19:31:26 <mmorrow> woot
19:31:41 <mmorrow> err, i thout it has to accum left->right
19:32:34 <mmorrow> , foldr (\x (n,xs) -> (x+n, xs++[n+x])) (0,[]) [0..9]
19:32:37 <lunabot>  (45,[9,17,24,30,35,39,42,44,45,45])
19:32:54 <mmorrow> yeah, using foldr and wanting left->right gets you O(n^2)
19:32:58 <ddarius> Cale: That's the definition of scanr written as a fold with (+) and 0 inlined.
19:33:09 <mmorrow> or you could just reverse afterwards
19:33:12 <mib_cdv0t5> @src scanr
19:33:12 <lambdabot> scanr _ q0 []     =  [q0]
19:33:12 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
19:33:12 <lambdabot>     where qs@(q:_) = scanr f q0 xs
19:33:14 <ddarius> > scanr (+) 0 []
19:33:15 <lambdabot>   [0]
19:33:18 <ddarius> Almost.
19:33:25 <Cale> ddarius: right.
19:33:27 <mmorrow> but in both cases you can't handle infinite lists
19:33:47 <Cale> scanr does terribly with infinite lists
19:33:50 <roconnor> > scanr (+) 0 [5,4,3,2,1]
19:33:52 <lambdabot>   [15,10,6,3,1,0]
19:33:59 <roconnor> > scanr1 (+) [5,4,3,2,1]
19:34:00 <lambdabot>   [15,10,6,3,1]
19:34:05 <Cale> scanl is the one which works with infinite lists
19:34:12 * wli wonders what's wrong with scanl
19:34:13 <roconnor> yes
19:34:13 <Megzlna> How do you force strict evaluation?
19:34:15 <Cale> (the opposite of the fold)
19:34:19 <mmorrow> , fix ((0:) . scanl (+) 1)
19:34:21 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
19:34:25 <Axman6> mmorrow: seq
19:34:26 <Cale> Megzlna: Using seq, and things built from it.
19:34:41 <Megzlna> Cale: Why do I want strict eval?
19:34:46 <Cale> Typically, foldl'
19:34:52 <mmorrow> Megzlna: you could also use bang patterns
19:34:55 <Megzlna> ' means strict ?
19:35:02 <mmorrow> (by convention)
19:35:06 <mmorrow> @src foldl
19:35:06 <lambdabot> foldl f z []     = z
19:35:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:35:08 <mmorrow> @src foldl'
19:35:08 <lambdabot> foldl' f a []     = a
19:35:08 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:35:21 <idnar> > scanr (+) 0 [1..]
19:35:23 <lambdabot>   [* Exception: stack overflow
19:35:27 <Megzlna> lol a'
19:35:28 <idnar> > scanl (+) 0 [1..]
19:35:30 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
19:35:32 <mmorrow> equivalently, that foldl'' def could've used bang patterns
19:35:36 <mmorrow> *foldl'
19:35:45 <solrize> wheee
19:35:49 <idnar> oh, of course
19:38:16 <Megzlna> Do any builtin operators rely on user functions in Prelude?
19:38:31 <Megzlna> I was wondering about [0..] -> enumFrom 0
19:39:03 <Cale> [0..] desugars into enumFrom 0, which is defined by the Enum class in the Prelude
19:39:21 <Megzlna> or any builtin keyword relying on library code
19:39:23 <Cale> Megzlna: A rather good example of when you want strictness is when summing a list of numbers to produce a single Integer value, say.
19:39:51 <Cale> There are a lot of numbers which you could evaluate individually, but only one result which depends on all of them.
19:40:04 <Axman6> > enumFrom 250 :: [Int8]
19:40:05 <lambdabot>   [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,...
19:40:09 <Cale> and there's no such thing as partially evaluating that result
19:40:10 <Axman6> > enumFrom 120 :: [Int8]
19:40:11 <lambdabot>   [120,121,122,123,124,125,126,127]
19:40:27 <Megzlna> Cale: k
19:40:48 <Megzlna> .. cannot be in prelude, right?
19:40:52 <Megzlna> because it has no RHS
19:41:05 <Cale> Megzlna: so there, a foldl' is perfect.
19:41:49 <ozy`> Megzlna: why couldn't it?
19:41:58 <Megzlna> ozy`: No rhs
19:42:11 <Megzlna> Haskell doesn't allow functions like that, does it?
19:42:11 <ozy`> you mean like...
19:42:14 <ozy`> > [..]
19:42:16 <lambdabot>   <no location info>: parse error on input `..'
19:42:48 <wli> Aren't they just defaulted to undefined?
19:43:01 <Megzlna> x `norhs`
19:43:08 <ozy`> > let a &&&& b = foldl a "pizza" b
19:43:09 <lambdabot>   <no location info>: parse error on input `;'
19:43:36 <Cale> Megzlna: oh, yeah, [1..] is a special syntax.
19:43:36 <ozy`> hmm whoops
19:43:38 <wli> Never mind, operator stuff.
19:43:48 <Cale> Megzlna: But it turns into enumFrom 1
19:43:49 <mib_cdv0t5> polynominal
19:43:54 <mib_cdv0t5> polynomial
19:43:58 <Megzlna> Cale: that's weird that special syntax relies on Prelude
19:44:02 <polveroj> > let f x = (x +) in f 1 2
19:44:03 <lambdabot>   3
19:44:06 <ozy`> Megzlna: syntactic sugar is defined in the compiler, not the library
19:44:54 <Axman6> :t (1 `id`)
19:44:55 <lambdabot> forall t. (Num t) => t
19:45:01 <Axman6> > (1 `id`)
19:45:02 <lambdabot>   1
19:45:34 <zloog> :t 3
19:45:35 <lambdabot> forall t. (Num t) => t
19:45:48 <ozy`> Megzlna: [..] isn't a function any more than do-notation
19:46:04 <ozy`> the latter also relies on >> and >>= being defined in the prelude
19:47:00 <Cale> [1..10], [1,3..10], [1..], and [1,3..] are all separate functions.
19:47:55 <Cale> enumFromTo 1 10, enumFromThenTo 1 3 10, enumFrom 1, enumFromThen 1 3
19:49:27 <idnar> Cale: well, there are numeric types you can partially evaulate, no?
19:49:43 <Cale> idnar: Yes, but not Integer.
19:49:56 <ozy`> Megzlna: also, you know that a function can be used before it's defined, right? at least, so long as it's defined later in the same file or in one of the imports
19:50:08 <idnar> sure
19:50:33 <Megzlna> this ain't C ...
19:51:00 <ozy`> :p
19:52:30 <ozy`> anyway, since the [..] notation is desugared by the compiler itself, it's exactly like a macro for "enumFrom x" or whatever other function
19:52:47 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
19:52:49 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
19:53:41 <Cale> also, when you write numeric literals, they desugar into calls to fromInteger
19:53:42 <ozy`> and as long as you're using [..] in a context in which the enumX functions are defined (ie. in the prelude or in any module which imports the prelude... which is every module) there's no danger of it magically appearing out of nowhere or something
19:53:49 <Cale> Or fromRational
19:54:08 <ozy`> > [1, 3, 9.0]
19:54:10 <lambdabot>   [1.0,3.0,9.0]
19:54:19 <ozy`> > [1, 3, 9.0, 12]
19:54:21 <lambdabot>   [1.0,3.0,9.0,12.0]
19:54:23 <ozy`> hmmm
19:54:23 <Cale> > 5 :: Double
19:54:24 <lambdabot>   5.0
19:54:31 <ozy`> > 5.0 :: Int
19:54:32 <lambdabot>       No instance for (Fractional Int)
19:54:32 <lambdabot>        arising from the literal `5.0' ...
19:54:35 <ozy`> whoops
19:54:38 <Cale> :t 5
19:54:39 <lambdabot> forall t. (Num t) => t
19:54:55 <Cale> :t 5.0
19:54:56 <lambdabot> forall t. (Fractional t) => t
19:56:47 <dmwit_> LOOK AT THIS, WE'RE A BEACH ASSAULT CRAFT
19:56:48 <dmwit_> hahahaha
19:57:38 <Cale> dmwit_: What?
19:57:59 <Cale> dmwit_: You accidentally the whole beach assault craft?
19:58:28 <ddarius> dmwit_: Aren't you supposed to be asleep?
19:59:08 <dmwit__> Maaaybe.
19:59:43 <dons> hey all, please suggest new libraries that would enable your work to happen, http://www.reddit.com/r/haskell_proposals/
20:00:03 <dons> there's spare capacity in our community. so if you suggest something good ...
20:01:22 <Axman6> submitted Hacports
20:01:40 <Axman6> which i'd kinda sorta started, ut it's far beyond my level of experience :\
20:02:29 <Megzlna> in a list comprehension, what do you call the <- part
20:02:49 <Megzlna> its not a predicate
20:02:59 <dmwit> binding
20:04:10 <Axman6> i've even
20:04:41 <dons> what pieces of infrastructure would people like?
20:04:44 <dons> C++ hsc2hs?
20:04:47 <dons> OCaml bindings?
20:04:51 <dons> JavaScript compiler?
20:05:17 <Megzlna> dons: Ability to do the equivalent of "extern (C++)" and link with a non-templated C++ class's virtual table
20:05:29 <dons> yeah.
20:05:32 <dons> add it.
20:05:37 <Megzlna> because those can be exported with unmangled names
20:05:39 <Axman6> http://www.reddit.com/r/haskell_proposals/comments/7ihqz/hacports_a_rewrite_of_macports_in_haskell_with/
20:05:39 <dons> * CUDA/OpenCL EDSL (gpu programming from Haskell
20:05:47 <dons>  An ARM port of GHC that works (so we can program the iphone or android)
20:05:52 <ddarius> Megzlna: A generator.
20:06:14 <Megzlna> ddarius: ? The problem is being able to override the vtable
20:06:22 <Megzlna> for N implementations
20:06:27 <dmwit> The problem is overriding the *types*.
20:06:37 <dmwit> Even totally untemplated functions might need mangling.
20:06:38 <ddarius> Megzlna: That was an answer to your question about list comprehensions.
20:06:51 <Megzlna> ddarius: ah! ;)
20:06:55 <dmwit> s/overriding/overloading/
20:07:05 <Axman6> dons: hmm, any idea why my proposal hasn't showed up? :\
20:07:40 <Axman6> ah, it's under new
20:07:52 <dons> it takes a little whlie
20:08:27 <Axman6> it's not 'hot' enough to get on the main page :\
20:08:49 <dons> well, part of this is to just record all the ideas
20:08:57 <dons> but in a cheaper more interactive way than using trac
20:09:18 <porges> What's a better way to implement this rather than with ridiculous amounts of type parameters: http://www.reddit.com/r/haskell_proposals/comments/7igsg/swap/c06qy67
20:11:17 <dmwit> class Ord1 c r where ord1 :: c -> r; class Ord2 c r where ord2 :: c -> r; ...
20:11:21 <dmwit> But it seems a bit odd to me.
20:11:59 <dmwit> FunRefs sort of subsume the whole thing.
20:12:09 <porges> but i'd like Ord2 to require Ord1, without it caring what the type parameters are in Ord1
20:13:14 <porges> like "(Ord1 a _) => Ord2 a b | a->b" :P
20:14:34 <sw17ch> http://www.reddit.com/r/haskell_proposals/comments/7ihqr/libgcrypt_bindings_the_library_behind_gpg/
20:14:39 <sw17ch> any one up for that?
20:15:21 <leimy> Ok
20:15:32 <leimy> well the bowling application works, but it's not "live updating"
20:16:11 <pumpkin> wow, looks like the haskell proposals reddit is gaining traction
20:16:21 <sw17ch> yes, i'm quite happy :
20:16:22 <sw17ch> :)
20:16:32 <doublec> it's a great idea
20:16:44 <dmwit> Everybody has work for other people to do.
20:16:48 <pumpkin> ::P
20:16:56 <sclv_> s/proposals/vaporware/
20:16:57 <dons> pumpkin: i imported, and then removed, the old page.
20:17:01 <dons> then added some things from my list.
20:17:08 <pumpkin> dons: cool
20:17:10 <dons> at worst this turns into our 2009 summer of code ideas
20:17:20 <dons> at best, we improve efficiency and get more stuff.
20:17:27 <dons> there's lots of spare capacity in engineering here.
20:17:33 <porges> why can't SoC do a WoC for the southern hemisphere :(
20:17:38 <pumpkin> no fair, you're a mod of the new reddit and I'm not
20:17:48 <dons> i don't know how that happened. someone added me. jsn
20:17:53 <sw17ch> pumpkin: is godofpumpkins you?
20:18:06 <pumpkin> yup
20:18:10 <sw17ch> hah, fantastic
20:18:15 <dons> hehe
20:18:27 <pumpkin> :)
20:18:44 <sw17ch> what's it like being a pumpkin patch deity?
20:19:17 <Axman6> if anyone has had a look at the Macports source before, they'll understand why i want a rewrite in haskell. and we can get many advantages too
20:19:30 <pumpkin> not sure, have always been one... it's hard to know what it would be like not to be
20:19:58 <Axman6> like, when running port fetch outdated, we can fork a few downloads at once, and not have to wait on slow servers
20:20:26 * wli itches for a box to hack Haskell on.
20:20:56 <solrize> > let primes (n:ns) = n : primes (filter (\v -> v `mod` n /= 0) ns) in map primes [0..20]
20:20:58 <lambdabot>       No instance for (Enum [a])
20:20:58 <lambdabot>        arising from the arithmetic sequence ...
20:20:58 <orbitz> @src shows
20:20:58 <lambdabot> Source not found. My pet ferret can type better than you!
20:21:09 <solrize> > let primes (n:ns) = n : primes (filter (\v -> v `mod` n /= 0) ns) in (take 20 primes)
20:21:10 <lambdabot>   Couldn't match expected type `[a]'
20:22:07 <Axman6> solrize: primes needs to take a list of nums in
20:22:21 <solrize> yeah that was the first thing i tried
20:22:39 <Axman6> > let primes (n:ns) = n : primes (filter (\v -> v `mod` n /= 0) ns) in take 20 $ primes (2:[3,5..])
20:22:41 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
20:22:45 <solrize> yeah, that :)
20:23:03 <Axman6> are they all the primes?
20:23:08 <pumpkin> yup
20:23:11 <pumpkin> but very slow
20:23:11 <solrize> looks good
20:23:19 <Axman6> @oeis 2 3 5 7 11
20:23:24 <lambdabot>  The prime numbers.
20:23:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:24:23 <Axman6> > let primes =2 : nubBy (\x y -> mod y x /= 0)
20:24:25 <lambdabot>   <no location info>: parse error on input `;'
20:24:55 <Axman6> > let primes = 2: nubBy (\x y -> mod y x /= 0) [3,5..] in take 20 primes
20:25:07 <leimy> http://paste.lisp.org/display/71898#1  <-- figured it out.
20:25:11 <lambdabot>   thread killed
20:25:12 <leimy> Math.bowling :-)
20:25:13 <Axman6> > let primes = 2: nubBy (\x y -> mod x y /= 0) [3,5..] in take 20 primes
20:25:24 <leimy> nubby!
20:25:28 <lambdabot>   thread killed
20:25:40 <pumpkin> Axman6: not sure you want to nub an infinite list
20:25:44 <pumpkin> > nub [1..]
20:25:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:25:51 <solrize> > maximum [1..1000000]
20:25:52 <Axman6> it's lazy
20:25:54 <lambdabot>   * Exception: stack overflow
20:25:56 <pumpkin> yeah, guess so
20:25:57 <solrize> heh
20:26:21 <Axman6> > nub [1,1..]
20:26:31 <Axman6> >_>
20:26:36 <lambdabot>   thread killed
20:26:50 <wli> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
20:27:06 <leimy> the combination of State and a lazy list is an awful lot like coroutines
20:27:17 <Axman6> @src nubBy
20:27:17 <lambdabot> nubBy eq []             =  []
20:27:17 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:28:08 <Axman6> > let primes = 2: nubBy (\x y -> 0 /= mod x y) [3,5..] in take 20 primes
20:28:24 <lambdabot>   thread killed
20:28:32 <pumpkin> take fewer maybe?
20:28:38 <Axman6> > let primes = 2: nubBy (\x y -> 0 /= mod x y) [3,5..] in take 10 primes
20:28:48 <Axman6> > let primes = 2: nubBy (\x y -> 0 /= mod x y) [3,5..] in take 3 primes
20:28:54 <lambdabot>   thread killed
20:28:58 <Axman6> ok, ow i need to get the code -_-
20:28:58 <pumpkin> fail
20:29:04 <lambdabot>   thread killed
20:29:14 <roconnor> dons: aww I thought haskell_proposals superceeded the libraries process
20:29:23 <roconnor> the libraries process is so tedious
20:29:31 <roconnor> I don't think I ever want to do that again
20:29:32 <dons> roconnor: no, mistake.
20:29:38 <dons> roconnor: one requires commit access to the base library
20:29:41 <Axman6> > let primes = nubBy (((>1) .) . gcd) (2:[3,5..]) in take 20 primes
20:29:43 <dons> the other is free for all
20:29:46 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
20:30:18 <Axman6> > let primes = nubBy (((>1) .) . gcd) (2:[3,5..]) in primes
20:30:22 <pumpkin> Axman6: yay
20:30:24 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:30:33 <Axman6> @unpl (((>1) .) . gcd)
20:30:33 <lambdabot> (\ e h -> (gcd e h) > 1)
20:30:57 <Axman6> > let primes = nubBy (\x y -> (gcd x y) > 1) (2:[3,5..]) in primes
20:31:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:31:55 <Axman6> > let primes = nubBy (\x y -> (gcd x y) > 1) (2:[3,5..]) in primes !! 1000
20:32:11 <lambdabot>   thread killed
20:32:13 <Axman6> > let primes = nubBy (\x y -> (gcd x y) > 1) (2:[3,5..]) in primes !! 100
20:32:18 <porges> I have 3 months and would love to work on lots of the stuff on http://hackage.haskell.org/trac/summer-of-code/report/1
20:32:19 <lambdabot>   547
20:32:38 <porges> damn Google's propagation of hemispherism
20:32:42 <porges> :P
20:32:58 <Axman6> yeah, bastards!
20:33:14 <leimy> porges: so I finally got it correct... but still kind of ugly, but not as bad, and not all in IO (except for the functions which prompt)
20:35:00 <Axman6> > let primes = 2:nubBy (\x y -> (gcd x y) > 1) [3,5..] in primes !! 100
20:35:04 <lambdabot>   547
20:35:09 <Axman6> > let primes = 2:nubBy (\x y -> (gcd x y) > 1) [3,5..] in primes !! 200
20:35:14 <lambdabot>   1229
20:35:23 <dons> so what we'll do come summer of code time is take the 'top' score projects and add them to the trac wiki
20:35:31 <leimy> > let primes = 2:nubBy (\x y -> (gcd x y) > 1) [3,5..] in primes !! 500
20:35:40 <lambdabot>   3581
20:35:43 <leimy> wow
20:35:54 <dons> e.g. http://www.reddit.com/r/haskell_proposals/top/?t=all
20:36:12 <pumpkin> that swap thing shouldn't take long :P
20:39:44 <wli> > let primes = let sieve cs (n:ns) = if not (null cs) && head cs == n then sieve (tail cs) ns else n : sieve (cs `merge` iterate (n+) (n*n)) ns ; [] `merge` ys = ys ; xs `merge` [] = xs ; (x:xs) `merge` (y:ys) = if x == y then x : merge xs ys else if x < y then x : merge xs (y:ys) else y : merge (x:xs) ys in sieve [] [2..] in take 10 primes
20:39:48 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
20:41:00 <wli> Clearly proper priority queues would dramatically improve the performance of the code snippet I just pasted.
20:45:06 <wli> However, that requires some work to insert the next multiple of the prime where one otherwise skates by on lazy lists.
20:54:10 <doublec> on the topic of proposals, I'd like to propose having documentation with libraries that shows how to use libraries, rather than just api docs
20:54:29 <doublec> as a beginner, I find working out how to use some of the available libraries can be quite hard
20:54:36 <ozy`> ne  = foldr ($) enemies $ map enemyDamager bullets -- strangest line of Haskell I've seen today
20:55:32 <leimy> pmap!
20:55:53 <leimy> I'm not sure I've seen foldr ($) used before
20:55:57 <ozy`> pmap?
20:56:08 <ozy`> :t foldr
20:56:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:56:11 <ozy`> :t foldr ($)
20:56:13 <lambdabot> forall b. b -> [b -> b] -> b
20:56:13 <Axman6> doublec: that'd be excellent
20:56:34 <ozy`> doublec: yeah that can be annoying
20:56:39 <Cale> I prefer  foldr (.) id
20:56:47 <Cale> :t foldr (.) id
20:56:48 <ozy`> :t foldr (.) id
20:56:49 <lambdabot> forall a. [a -> a] -> a -> a
20:56:50 <lambdabot> forall a. [a -> a] -> a -> a
20:56:54 <ozy`> heh :p
20:57:04 <leimy> ozy`: Think I mean parMap
20:57:10 <ozy`> :t parMap
20:57:12 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
20:57:27 <ozy`> leimy: you sure? :p
20:57:33 <leimy> tes
20:57:34 <leimy> er yes
20:58:50 <Axman6> Cale: but what if you want to work with b's?
20:58:51 <Axman6> >_>
20:59:03 <Cale> hehe
21:01:54 <wli> I suspect this would work, but I'm getting errors from lambdabot:
21:02:01 <wli> let primes = let sieve cs (n:ns) = let ((k, ps), cs') = Data.Map.deleteFindMin cs in if k /= n then n : sieve cs ns else sieve (foldr (\p -> Data.Map.insertWith' (++) (k + p) [p]) cs' ps) ns in 2 : sieve (Data.Map.singleton 4 [2]) [3..] in take 10 primes
21:03:12 <Axman6> forgot the >?
21:03:33 <wli> No, /msg it back to lambdabot and see for yourself.
21:03:36 <sw17ch> is there any chance some one has taken a shot at using Mono (C#) assemblies in Haskell?
21:03:42 <sw17ch> i saw the salsa project a while back
21:03:50 <sw17ch> but i'm not sure if that's close enough to the same thing
21:05:18 <Axman6> whoot, someone voted for my Hacports proposal
21:09:46 <mmorrow> wli: Data.Map is qualified as just "Map"
21:09:51 <mmorrow> > Map.empty
21:09:53 <lambdabot>   fromList []
21:09:56 <Megzlna> :t [(1,1)]4
21:09:57 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[a]'
21:09:59 <Megzlna> :t [(1,1)]
21:10:00 <lambdabot> forall t t1. (Num t1, Num t) => [(t, t1)]
21:10:06 <Megzlna> Why does it use Num t1, Num t
21:10:09 <Megzlna> rather than
21:10:22 <Megzlna> (Num t) => [(t, t)]
21:10:34 <Axman6> because they could be different Num instances
21:10:36 <mmorrow> @type [(pi,4::Int)]
21:10:37 <lambdabot> forall a. (Floating a) => [(a, Int)]
21:11:12 <mmorrow> @type [(1,1)] :: [(Double,Integer)]
21:11:13 <lambdabot> [(Double, Integer)]
21:11:26 <ozy`> sw17ch: you mean... making a Haskell VM for the CLR?
21:11:34 <wli> > let primes = let sieve cs (n:ns) = let ((k, ps), cs') = Map.deleteFindMin cs in if k /= n then n : sieve cs ns else sieve (foldr (\p -> Map.insertWith' (++) (k + p) [p]) cs' ps) ns in 2 : sieve (Map.singleton 4 [2]) [3..] in take 10 primes
21:11:36 <lambdabot>   [2,3,5,7,9,11,13,15,17,19]
21:11:55 <mmorrow> woohoo, a proper sieve in one line
21:12:09 <wli> mmorrow: Priority queue and all.
21:12:15 <mmorrow> nice
21:12:50 <sw17ch> ozy`, no, just calling methods
21:12:52 <sw17ch> a FFI for Mono
21:12:55 <pumpkin> how bout a modern sieve in one line?
21:13:08 <wli> pimpkin: I'd love to see it.
21:13:22 <mmorrow> pumpkin: what's a "modern" sieve?
21:13:49 <pumpkin> quadratic sieve maybe?
21:14:01 <ozy`> sw17ch: that would probably involve compiling Haskell to the CLR...
21:14:19 <wli> pumpkin: Modern sieves are tremendously sophisticated, though. I doubt the case analysis for djb's sieve would fit in one line even with bodies (in violation of syntax) omitted.
21:14:26 <pumpkin> :) yeah
21:14:59 <wli> s/quadratic/Atkin's/ (a.k.a. djb's)
21:15:27 <wli> Quadratic sieves are for primality testing and/or factorization of individual large numbers.
21:15:40 <pumpkin> yeah, whoops :)
21:18:13 <pumpkin> whoa
21:18:14 <pumpkin> http://twitter.com/reddit_haskell
21:18:29 <wli> I had a fully-functional Eratosthenes.hs somewhere that basically translated the "genuine sieve of Eratosthenes" paper's code into working modern Haskell code, with various optimizations discussed in the paper tacked on.
21:18:46 <pumpkin> there's a paper on prime generators in haskell somewhere
21:19:52 <solrize> > length (map id [1/0])
21:19:53 <lambdabot>   1
21:24:29 <wli> I used a compile-time tunable wheel algorithm, which is the main thing that differs apart from deleteMinAndInsert, for which I found no ready analogue.
21:29:11 <wli> I couldn't smoke out how he dealt with composites to "cross out" with multiple associated primes, so I just ignored the deleteMinAndInsert affair.
21:30:56 <wli> There are a few other minor things, I guess, like killing the (++) and so on.
21:31:44 <pumpkin> any LaTeX "bindings" for haskell?
21:32:55 <Axman6> pumpkin: how do you mean?
21:33:51 <dons> pumpkin: programmatically generate latex?
21:33:56 <dons> you can via pandoc.
21:34:01 <dons> and i htink others. look on hackage.
21:34:05 <dons> hscolour has a tex backend, iirc
21:35:35 <pumpkin> is there even a latex library? or is it just a binary? I just want to be able to feed in a string and get an image/pdf out of it
21:35:59 <dons> oh i see.
21:35:59 <leimy> pipes!
21:36:06 <pumpkin> yeah, I guess I can just do that :)
21:36:06 <dons> like the gnuplot binding
21:36:13 <dons> no, i don't think we have that
21:36:17 <dons> sounds good though
21:36:23 <leimy> Doesn't it take stdin?
21:36:40 <pumpkin> can always give it a /dev/fd/1 in that case
21:36:46 <leimy> runInteractiveProcess :-)
21:37:22 <leimy> :t runInteractiveProcess
21:37:24 <lambdabot> Not in scope: `runInteractiveProcess'
21:37:46 <leimy> :t System.Process.runInteractiveProcess
21:37:47 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
21:38:16 <leimy> I used that to do nifty things with ssh-agent
21:38:35 <leimy> well not really nifty, but a handy utility
21:38:48 <leimy> builds me up a symlink that Mac OS X sees globally as my ssh-agent instance
21:39:08 <shapr> dons: Is that a hint? :-)
21:39:56 <ozy`> Axman6: the macports source is certainly verbose
21:40:04 <leimy> :t ($!)
21:40:06 <lambdabot> forall a b. (a -> b) -> a -> b
21:40:14 <ozy`> I don't know what well-written TCL is supposed to look like though
21:40:17 <Axman6> ozy`: want to help change that? they're trying to port it to C -_-
21:40:24 <ozy`> augh
21:40:40 <ozy`> right, because C is faster than TCL
21:40:43 <leimy> I used to work on macports when it was called darwinports :-)
21:40:51 <leimy> and then I lost all hope in it :-)
21:41:10 <leimy> met some cool people though.
21:41:31 <Axman6> ozy`: because the guy who wants this cut his teeth writing C on classic Mac OS
21:41:53 <Axman6> leimy: feel like helping writing a new version in haskell?
21:42:00 <leimy> oh boy
21:42:00 <leimy> that project is doomed
21:42:07 <leimy> Axman6: I've thought about that before
21:42:20 <leimy> but then I got married, and had a child :-)
21:42:26 <dons> hey, we have this project idea site now.
21:42:37 <Axman6> macports is doing ok these days, but all the original devs have left, so no one knows how the base works
21:42:37 <dons> if you need a latex binding, submit it, and then answer it yourself with code :)
21:42:45 <august> he didn't write in pascal?
21:42:47 <dons> shapr: http://www.reddit.com/r/haskell_proposals/
21:42:54 <leimy> Axman6: all the originals through their hands in the air and walked :-)
21:42:56 <dons> you got ideas. stick 'em up there plz :)
21:43:08 <Axman6> leimy: after looking at the code, i can see why
21:43:12 <leimy> heh
21:43:12 <sm> hey that sounds familiar
21:43:20 <leimy> there was a time when they wanted to change it to incrTcl
21:43:32 <leimy> which is a pun on C++ and Tcl
21:43:46 <leimy> I believe Jordan Hubbard was responsible for the Tcl choice
21:44:02 <Troggle> Humans of all races have come to realize that NIGGERS = FAIL!  Join us at Chimpout.com!  http://www.chimpout.com  Asians, Jews, Mexicans, Whites, Native Americans, and non-nigger Hispanics are welcome!!!  http://www.chimpout.com    For info ask in the Guest Forum.
21:44:07 <solrize> what's so great about reddit for that kind of stuff?  why not use haskell.org?  i'm tired of having to enroll accounts in so many different .com's
21:44:13 <hydo> classy!
21:44:17 <leimy> wow
21:44:30 <Axman6> dons: you're an op right?
21:44:31 <leimy> that's a serious troll :-)
21:44:43 <rgov> what's the story behind "Couldn't match expected type `Integer' against inferred type `Int'"
21:45:07 <Axman6> rgov: what's the code?
21:45:08 <solrize> yow ;)
21:45:30 <leimy> I wonder how much work it is to do an SNMP agent and management system in haskell
21:45:55 <mmorrow> @ops
21:45:55 <lambdabot> Maybe you meant: docs oeis pl
21:45:59 <Axman6> leimy: so, i take it you wouldn't be up to helping write a haskell macports? :\
21:46:02 <mmorrow> whats the cmd?
21:46:06 --- mode: ChanServ set +o dons
21:46:08 --- mode: dons set +b *!*=48cf149f@67.159.35.*
21:46:08 --- kick: Troggle was kicked by dons (dons)
21:46:09 <rgov> Axman6: e m = z (\n c -> chr (f (op (f' (ord c)) (mod n 255)))) (drop 1000 k) (t m)
21:46:18 <dons> Axman6: thanks. was distracted.
21:46:18 <leimy> Axman6: I don't think I'd have the time for it.
21:46:19 --- mode: ChanServ set -o dons
21:46:25 <rgov> there already is a macports for it
21:46:30 <Axman6> dons: thanks :)
21:46:38 <Axman6> rgov: huh?
21:46:48 <rgov> thats the code?
21:46:50 <ozy`> rgov: no, Axman6 is talking about rewriting the package manager in Haskell
21:46:56 <solrize> :t ord
21:46:58 <lambdabot> Char -> Int
21:47:04 <Axman6> rewriting macports itself in haskell
21:47:04 <solrize> :t mod
21:47:06 <leimy> well strictly speaking macports isn't a package manager :-)
21:47:06 <lambdabot> forall a. (Integral a) => a -> a -> a
21:47:13 <leimy> or did they finally manage to get binaries?
21:47:27 <hydo> Axman6: I'd like to help but I don't really think I can do much just yet... I'm still learning the language.
21:47:31 <Axman6> i think there's room for binaries, but nothing uses them
21:47:32 * leimy has to go pick up his dog...
21:47:43 <Axman6> hydo: yeah, i don't know enough yet either :\
21:47:45 <leimy> There was an evil activation/deactivation thing done with symlinks
21:47:58 <ozy`> leimy: my use of terminology is suggestions to the compiler and would instantly fail any reasonably pedantic type checker
21:48:18 <solrize> i vote against the libgcrypt bindings.  those functions should instead be implemented in pure haskell
21:48:32 <dons> solrize: make that statement on the page
21:48:40 <dons> solrize: and propose pure ones.
21:48:43 <solrize> i don't have a reddit account and don't want to enroll one
21:48:48 <Axman6> solrize: votes don't get counted on irc ;)
21:48:51 <dons> i like that the reddit thing is as chaotic as open source
21:48:55 <dons> it is a free for all
21:49:00 <dons> solrize: yes, didn't count.
21:49:07 <dons> you have to speak up to be heard!
21:49:25 <dmwit> Boo.
21:49:27 <solrize> reddit is not like open source.  it is 100% funnelled through a single corporation, the exact opposite of open source.
21:49:29 <dons> shapr: what i like about this process is we can accumulated ideas and then just sort them by top votes later, http://www.reddit.com/r/haskell_proposals/top/?t=month
21:49:31 <dmwit> He spoke up here.
21:49:33 <dons> i.e. what is hot this month.
21:49:41 <dons> solrize: hmm? the src is actually open..
21:49:54 <dons> solrize: anyway, set up a clone so we can vote please!
21:50:05 <dons> hang on.
21:50:12 <dons> our irc is 100% funneled too. rebel!
21:50:21 <solrize> at least it's a .org
21:50:32 <dons> sure. i take your point.
21:50:36 * mmorrow rebels, sees something shiny, forgets where he is
21:50:41 <ozy`> solrize: a great many "free software" projects have their development controlled by centralized groups, regardless of how vehemently they evangelize the free software cause
21:50:44 <dons> hey, shiny!
21:50:47 <solrize> and i didn't really have to enroll an account in order to hang out here, though i ended up doing it anyway
21:50:56 * ozy` coughs in the FSF's general direction
21:51:06 <dons> anyway. doesn't matter. comments on  the tracker will be remember
21:51:11 <dons> d
21:51:14 <solrize> tracker?
21:51:29 <dmwit> ?where bugs
21:51:30 <lambdabot> I know nothing about bugs.
21:51:34 <dmwit> ?where trac
21:51:35 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:51:46 <dons> http://www.reddit.com/r/haskell_proposals/top/
21:51:46 <solrize> ic
21:53:26 <solrize> ozy` there was a very successful gcc fork (egcs) that ended up surpassing the fsf gcc, and then replacing it
21:53:35 <solrize> i.e. the fsf itself switched to it, more or less
21:53:47 <ozy`> awesome
21:54:02 <ozy`> they're still pretty terrible about things like that most of the time though
21:54:46 <wli> @type cycle
21:54:48 <lambdabot> forall a. [a] -> [a]
21:54:53 <dons> i love the smell of collaboration.
21:54:55 <hydo> oh wow, I remember egcs...I haven't thought about that in years...
21:55:14 <solrize> i think i have an account on the haskell wiki but it doesn't work for trac?
21:55:15 <hydo> Though if I knew egcs _replaced_ gcc, I had forgotten it.
21:55:51 <dmwit> solrize, correct, but there's a guest account
21:56:04 <solrize> hydo, http://lwn.net/1999/0429/a/gcc.html
21:56:26 <hydo> 1999... man, I'm old.
21:56:57 <solrize> dmwit, cool, what's the guest account?
21:57:30 <dmwit> Oh, I don't know.  It's on the top page.
21:57:31 <dmwit> uh...
21:57:42 <solrize> oh ok
21:57:48 <solrize> sec
21:57:59 <Heffalump> anyone got any advice on getting libedit0 on Debian? (So I can use recent ghc snapshots)
21:58:23 <solrize> aha, it's in tiny grey type way at the bottom of the page
21:59:48 <solrize> anyway my issue with reddit-like sites is partly a lament about the decline of usenet, but i suppose that's inevitable by now
22:00:16 <Heffalump> at least reddit threads
22:00:40 <rgov> chr (f (op (f' (ord c)) (mod n 255)))) since we know chr takes in an Int, ord returns an Int, and mod returns an Integer, can we infer the types of f, f', or op ?
22:00:49 <solrize> er, usenet threads.  usenet is a lot easier to troll and spam though :(
22:01:07 <Heffalump> I mean that a lot of crappy forum software doesn't thread.
22:01:19 <Axman6> , [$ty| chr (f (op (f' (ord c)) (mod n 255))))|]
22:01:30 <lunabot>  luna: Exception when trying to run compile-time code:
22:01:36 <Axman6> :t chr (f (op (f' (ord c)) (mod n 255))))
22:01:37 <lambdabot> parse error on input `)'
22:01:38 <solrize> heffalump, hmm, for some reason with web forums i've generally preferred flat over threading.  anyway this is way off topic
22:01:53 <Axman6> :t chr (f (op (f' (ord c)) (mod n 255)))
22:01:53 <solrize> unless we're gonna implement a reddit clone in haskell, which might not be a bad idea :)
22:01:54 <lambdabot> Not in scope: `op'
22:01:54 <lambdabot> Not in scope: `f''
22:03:09 <Axman6> :t chr (?f (op (?f' (ord c)) (mod n 255)))
22:03:11 <lambdabot> Not in scope: `op'
22:03:15 <Axman6> :t chr (?f (?op (?f' (ord c)) (mod n 255)))
22:03:17 <lambdabot>     Couldn't match expected type `Char' against inferred type `Expr'
22:03:17 <lambdabot>     In the first argument of `ord', namely `c'
22:03:17 <lambdabot>     In the first argument of `?f'', namely `(ord c)'
22:04:08 <wli> @type mapAccumL
22:04:10 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:04:13 <solrize> axman6 why are you modding by 255?  do you mean 256?
22:04:20 <Axman6> it's not my code
22:04:28 <Axman6> it's rgov's
22:04:30 <wli> @type scanl
22:04:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:04:42 <solrize> oh oops.  anyway, rgov, same question ;)
22:04:56 <rgov> solrize: i didn't write it, trying to figure out how it works and make an inverse function
22:05:05 <mmorrow> , [$ty| chr (?f (?op (?f' (ord c)) (mod n 255))) |]
22:05:06 <wli> @type unfoldr
22:05:07 <rgov> i dont know what, f, f', or op are defined as
22:05:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:05:10 <lunabot>  luna: Exception when trying to run compile-time code:
22:05:12 <mmorrow> , chr (?f (?op (?f' (ord c)) (mod n 255)))
22:05:13 <lunabot>  luna: Not in scope: `c'
22:05:19 <mmorrow> , chr (?f (?op (?f' (ord ' ')) (mod n 255)))
22:05:20 <lunabot>  luna: Not in scope: `n'
22:05:24 <Axman6> :t chr (?f (?op (?f' (ord 'c')) (mod n 255)))
22:05:24 <mmorrow> , chr (?f (?op (?f' (ord ' ')) (mod 2 255)))
22:05:25 <lambdabot> forall t t1. (?f'::Int -> t1, ?op::t1 -> Expr -> t, ?f::t -> Int) => Char
22:05:26 <lunabot>  luna: Unbound implicit parameters (?f::t1 -> GHC.Types.Int,
22:06:32 <mmorrow> , [$ty|chr (?f (?op (?f' (ord ' ')) (mod 2 255)))|]
22:06:32 <lunabot>  forall t_aa5T t_aa5Y t_aabK.
22:06:32 <lunabot>  (GHC.Real.Integral t_aabK,
22:06:32 <lunabot>   ?f'::GHC.Types.Int -> t_aa5Y,
22:06:32 <mmorrow> heh
22:06:32 <Axman6> mmorrow: any plans to clean that up in the near future?
22:06:32 <mmorrow> i was just thinking the same myself :)
22:06:57 <solrize> dons, would you add a proposal for pure-haskell implementations of GPG and TLS?  they are both things i've been wanting to work on someday
22:07:02 * mmorrow feels motivated and does it now
22:07:08 * mmorrow times himself
22:07:17 <wli> @type foldr
22:07:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:07:21 <mmorrow> @locatime mmorrow
22:07:22 <lambdabot> Local time for mmorrow is Wed Dec 10 00:07:21
22:07:25 <Axman6> mmorrow: gogogo!
22:07:46 <rgov> so i think f' takes in an int, op takes in (int, integer), f returns an int
22:08:18 <rgov> what is the difference between an int and an integer? size?
22:08:40 <solrize> rgov, integers are variable size, ints are machine size
22:08:40 <dons> bos31337: did you see http://twitter.com/timoreilly/statuses/1048366874
22:08:43 <Axman6> integer is unlimited in size
22:08:51 <Axman6> > maxBound :: Int
22:08:53 <lambdabot>   9223372036854775807
22:08:54 <Axman6> > maxBound :: Integer
22:08:56 <lambdabot>       No instance for (Bounded Integer)
22:08:56 <lambdabot>        arising from a use of `maxBoun...
22:11:23 <wli> Pardon the line length violence:
22:11:41 <wli> > let ws''=[2,3,5,7];ws'=filter(\x->all(\w->x`mod`w/=0) ws'') [2..product ws''+1];ws=cycle $ zipWith (-) (tail ws' ++ [product ws'' + head ws']) ws' ; primes = let sieve cs (n:ns) = let ((k,ps),cs') = Map.deleteFindMin cs in if k/=n then n:sieve cs ns else sieve (foldr (\p -> Map.alter (Just . maybe [p] (p:)) (k+p)) cs' ps) ns in 2:3:5:7:sieve (Map.singleton 121 [11]) (snd $ mapAccumL (\n x -> (n + x, n)) 11 ws) in take 10 primes
22:11:43 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
22:11:54 <solrize> hmm, borders here says they have just two copies of RWH on order, doesn't seem like nearly enough
22:12:17 <Axman6> wli: how does it take to do primes !! 500 or so?
22:12:37 <wli> Axman6: Not long for 1024.
22:12:39 <Axman6> how long*
22:12:42 <Axman6> nice
22:12:49 <Axman6> 10000?
22:12:52 <roconnor> > sum [24492,28207,28692,32421] / 4
22:12:54 <lambdabot>   28453.0
22:12:57 <dons> solrize: hmm. and the 2 copies on the shelf in portland are gone now.
22:13:32 <wli> Axman6: There may be a problem with that. :(
22:13:34 <dons> solrize: i'm not sure borders is the best place to obtain it. you need a copy on the shelf?
22:13:34 <solrize> well i guess it's better to sell out fast and generate reorders
22:13:45 <Heffalump> my Amazon order has been delayed until the end of the year
22:13:56 <dons> Heffalump: wow.
22:14:01 <cjb> Heffalump: amazon.co.uk, presumably?
22:14:04 <Heffalump> cjb: yes
22:14:07 <august> like just a few weeks?
22:14:13 <solrize> dons i'm not sure what you mean about needing a copy on the shelf... i mean i could order it online, i just enjoy buying books in bookstores
22:14:16 <Heffalump> it's possible that I moved myself to the back of the queue by changing the delivery address a few days ago
22:14:25 <Heffalump> august: yes
22:14:34 <dons> solrize: well, it is on the shelves in some stores.
22:14:54 <dons> i know there's 2 copies on the front desk at powell's in portland
22:14:54 <solrize> yeah, i'm actually not crazy about borders, it's just that there is one near me with a pretty good computer section
22:15:22 <dons> Heffalump: yeah, they've changed it from 'in stock' to 'Usually dispatched within 10 to 13 days'
22:15:24 * cjb should get the MIT coop to order some.
22:15:28 <dons> which i think means they have to get it from the US?
22:15:52 <dons> i'll ask o'reilly..
22:16:00 <solrize> heh, i guess 10 to 13 days means the first print run sold out, which i guess is good news
22:16:04 <llayland> not a single haskell or fp book at my loacal barnes and nobles .  I'll have to check out borders
22:16:11 <llayland> btw, hi
22:16:24 <solrize> there are a couple of other haskell books at my local borders
22:16:36 <cjb> solrize: nah, we're talking about the UK
22:16:41 <solrize> oh oops :)
22:16:42 <cjb> solrize: it's still in stock in the US
22:16:54 <dons> solrize: i don't think it is entirely sold out. maybe amazon uk is out.
22:16:58 <solrize> ic
22:16:58 <jeffz`> my local borders has a pitiful selection of books, they probably haven't changed in the last 6 years
22:16:59 <Axman6> dons: any idea how well RWH has been selling?
22:17:26 <dons> yeah. really well. o'reilly is very happy
22:17:34 <cjb> woo
22:17:34 <Axman6> good :)
22:17:37 <ozy`> Axman6: ever seen that part at the beginning of Ghostbusters where all those cards are flying off the shelves? it's like that.
22:17:39 <dons> let's hope they decide to go for more FP books now
22:17:41 <leimy> dons: that's cool
22:17:51 <Axman6> lol
22:18:29 <solrize> http://www.powells.com/biblio/9780596514983?&PID=33317  <-- that is your affiliate link?
22:18:48 <rgov> http://okmij.org/ftp/Haskell/types.html#de-typechecker i don't understand this but it seems relevant :-)
22:19:02 <dons> solrize: no idea if we have one for powells.
22:19:03 <leimy> dons: is the ebook selling on amazon ?
22:19:16 <solrize> that is from your site... it would be cool if you also had one for barnes & noble
22:19:22 <lament> i got a letter from amazon saying it finally shipped <3
22:19:35 <dons> leimy: hmm, only on o'reilly's page.
22:19:42 <leimy> Wow new Erlang book coming too
22:19:49 <leimy> in April of next year
22:19:59 <solrize> leimy, interesting, who is the author?
22:20:09 <dons> cezarinni?
22:20:09 * cjb will pass on the erlang
22:20:11 <solrize> erlang for scientists -- owwwooooooo ;)
22:20:14 <leimy> Francesco Cesarini and Simon Thompson
22:20:16 <dons> no!
22:20:17 <dons> yes.
22:20:19 <solrize> oh cool
22:20:24 <august> it's a trap!
22:20:26 <leimy> Yeah :-)
22:20:42 <leimy> http://www.amazon.com/Erlang-Programming-Francesco-Cesarini/dp/0596518188/ref=sr_1_2?ie=UTF8&s=books&qid=1228890017&sr=1-2
22:21:11 <dons> anyone thought about getting RWH as a (amusing..) present for a java programmer for xmas?
22:21:20 <dons> i keep meaning to blog about that, and world dominationn.
22:21:25 <dons> slip haskell into their dreams
22:21:26 <solrize> that looks pretty good, i broke down and bought armstrong's book mostly to get my officemates interested in fp
22:21:28 <ozy`> dons: I have a COBOL book somewhere you could use instead
22:21:32 <dons> heh
22:21:35 <leimy> dons: funny enough... most of our code is either java or erlang here
22:21:38 <ozy`> it would still be more expressive than Java
22:21:38 <llayland> the Java programmers I know wouldn't get the joke :)
22:21:39 <leimy> I'm the only erlang coder
22:21:44 <leimy> ;-)
22:21:45 <dons> heh
22:21:47 <solrize> ozy` that's the premier web development language now, didn't you know?  http://coboloncogs.org
22:22:20 <leimy> Honestly those OTP templates for gen_server, gen_fsm, gen_event... they really make programming "services" a bit like filling out Mad Libs
22:22:32 <leimy> it's easy as hell
22:22:35 <leimy> and testing is easy too
22:22:36 <ozy`> solrize: whoever made that website is my hero. phosphor burn-in and tube flicker :D
22:22:46 <leimy> the only thing I wish erlang had was Haskell's type system.
22:23:20 <solrize> leimy, yeah
22:23:38 <leimy> solrize: love the DATE OVERFLOW
22:23:47 <solrize> hehe
22:23:54 <ozy`> doesn't Erlang invert the Haskell/everything else convention of Type Names vs. variable names?
22:24:36 <leimy> I'm not sure I know what you mean.
22:24:56 <leimy> Erlang doesn't really type the functions
22:25:01 <leimy> not strongly
22:25:04 <leimy> you can write guards
22:25:09 <leimy> and some serious pattern matching
22:25:12 <ozy`> leimy: that is, in Erlang, type names are lowercase and variables are capitalized?
22:25:19 <leimy> oh yes
22:25:23 <leimy> except it's not a type name
22:25:28 <leimy> this_is_an_atom
22:25:30 <august> capitalized vars?
22:25:32 <august> eww
22:25:35 <leimy> This_is_a_variable
22:25:46 <leimy> also functions are lowercase
22:25:49 <solrize> yeah, $this_is_a_variable is far superior ;)
22:25:51 <leimy> and you can tell them apart by arity
22:25:55 <dons> solrize: awesome link
22:26:01 <leimy> foo/1 and foo/2 are distinct
22:26:06 <ozy`> solrize: you can do that in Java. little-known fact
22:26:35 <leimy> I also think Erlang should curry :-)
22:26:42 <mornfall> Yes. coboloncogs++
22:27:01 <solrize> mornfall, that would be ADD 1 TO COBOLONCOGS GIVING COBOLONCOGS
22:27:26 <mornfall> solrize: : - ((
22:27:36 <solrize> :)
22:27:39 <wli> lambdabot's ignoring me.
22:27:55 <mornfall> solrize: Maybe someone should send a patch to lambdabot to understand that. ;)
22:28:10 <solrize> ok i just ordered RWH from powells
22:28:47 <leimy> I've got some code I need to work with that drives a CAN bus
22:28:55 <leimy> I'm thinking I might write some Haskell FFI stuff for it.
22:33:00 <llayland> Anybody have any good resources for breaking out of the imperative mindset and into a functional approach to problem solving?  I figure it will mostly be just practice; which I am doing, but I figure there has to be a better way.
22:33:41 <solrize> llayland, use haskell for a while?
22:34:02 <llayland> Just starting.
22:34:07 <leimy> Hmmm
22:34:27 <leimy> I don't know, but I learned a bunch of scheme/lisp before I tried erlang/haskell
22:34:50 <ozy`> yeah, scheme/lisp is a good stepping stone
22:35:04 <ozy`> scheme moreso than common lisp, since it's more geared towards FP
22:35:05 <dons> llayland: its a good question!
22:35:33 <dons> are you good at the imperative languages you know?
22:35:44 <ozy`> llayland: what imperative languages -do- you know?
22:35:55 <dons> if so, something like real world haskell would be ok. otherwise, one of the intro tutorials, like 'school of expression'
22:36:01 <dons> but the main thing is to learn by doing
22:36:11 <dons> going through 'yet another haskell tutorial' has worked for others
22:36:43 <solrize> "learn you a haskell" is also pretty good
22:36:46 <lpjhjdh> llayland: I just wrote a bunch of haskell and read haskell school of expressions.  Took me about a year although I was pretty lazy and slow (after writing imperative for about 5 years).  Still not good at making things perform well.
22:36:50 <llayland> I would say I am good at pl/sql and was good at c
22:36:53 <cjb> I liked Why Functional Programming Matters
22:37:02 <solrize> cjb good mention
22:37:09 <cjb> http://www.md.chalmers.se/~rjmh/Papers/whyfp.pdf
22:37:28 <ozy`> llayland: SQL might help, if you ever got the hang of playing around with the different clauses
22:37:33 <solrize> i wrote a fair amount of lisp and (some) scheme code but i guess i did it in an imperative style, so it never really got the point across
22:38:00 <solrize> i got interested in FP and decided to spend time on haskell instead of ML, on the theory that ML was too easy to treat as another imperative language
22:38:57 <llayland> I'll check out 'school of expression'.  I've been through yaht and learn you a haskell.
22:39:09 <llayland> solarize - exactly why I am using haskell
22:40:07 <ozy`> the FP epiphany for me was with a college compiler project written in scheme
22:40:37 <ozy`> I was reading over the source and saw something like (define nonterminals (map car grammar))
22:40:53 <llayland> probably just need more practice.  I just seem to spend way to long figuring out what are (in retrospect simple things)
22:41:25 <llayland> make a list of grammars and call it nonterminals?
22:42:37 <ozy`> llayland: no, apply the "car" function ("head" in Haskell) to every element in the "grammar" variable (which is a list of lists) and return the results as a new list
22:42:45 <ozy`> and assign that to the "nonterminals" variable
22:43:32 <llayland> ah
22:43:52 <solrize> re haskell proposals reddit: did anything ever happen with UnicodeString?  if whoever was working on that gave up, it should go onto the proposals list
22:47:10 <sjanssen> solrize: isn't String already Unicode?
22:47:43 <llayland> so, is it unreasonable for it to take a while to figure out how to apply a list of functions to a value returning the a list of the results of the application.  I'm embarassed to say that one really stumped me
22:47:44 <dons> solrize: you mean unicode-bytestring?
22:47:48 <solrize> sjanssen, UnicodeString is supposedly a unicode counterpart to bytestring
22:47:49 <solrize> yeah
22:48:05 <dons> duncan's student worked on it. needs to be released now.
22:48:07 <dons> dcoutts_: ?
22:48:07 <rgov> can anyone explain this: http://okmij.org/ftp/Haskell/types.html#de-typechecker
22:48:20 <dons> rgov: is that an oleg link?
22:48:26 <rgov> i dont know what oleg is?
22:48:32 <dons> ah!
22:48:34 <dons> it is.
22:48:34 <lament> nobody knows what oleg is
22:48:36 <ddarius> > sequence [(1+), (2*), (^3)] 3
22:48:37 <dons> no one can explain it then. it is inexplicable.
22:48:38 <lambdabot>   [4,6,27]
22:48:45 <lpjhjdh> what school did oleg go to?
22:49:00 <dons> rgov: oleg is the author. chuck norris can't break oleg's code.
22:49:08 <dons> lpjhjdh: somewhere in russia
22:49:10 <rgov> ah
22:49:21 <rgov> i dont even know what it's doing... the explanation is very thick
22:49:34 <dons> lpjhjdh: forged in the molten core of a lost planet.
22:49:48 <llayland> > fmap ($ 1) [(+1),(*4)]
22:49:48 <lpjhjdh> haha, that's the only explanation
22:49:49 <lambdabot>   [2,4]
22:49:53 <dons> rgov: very much so. it has type 'Oleg'
22:49:59 <ozy`> rgov: it's using the function "undefined" in different type contexts... no idea why it's doing it that way though
22:50:39 <quicksilver> dons: actually, oleg wrote chuck norris. In the type system ;)
22:51:05 * quicksilver contemplates 'olegfacts.com' but decides against it.
22:51:27 <ddarius_> Presumably, it uses the type system as a very simple theorem prover.  The proofs are the terms.  They are presumably decorated onto the types via type classes.
22:51:41 <dons> ?quote oleg facts
22:51:41 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
22:51:45 <dons> ?quote oleg
22:51:45 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
22:51:53 <dons> ?quote oleg
22:51:54 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
22:51:57 <dons> ?fact oleg
22:51:58 <lambdabot> I know nothing about oleg
22:51:59 <dons> hmm
22:52:10 <dons> ?quote olegfacts
22:52:11 <lambdabot> No quotes match.
22:52:12 <dons> ?quote olegfact
22:52:12 <lambdabot> No quotes match. I am sorry.
22:52:57 <lament> @quote type system
22:52:57 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
22:53:10 <solrize> @quote milli-oleg
22:53:10 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
22:53:31 <ddarius_> Actually more accurately, it constructs a logic program in the type system to do that.
22:54:28 <mmorrow> , [$ty|chr (?f (?op (?f' (ord ' ')) (mod 2 255)))|]
22:54:34 <lunabot>  luna: Exception when trying to run compile-time code:
22:54:44 <mmorrow> , [$ty|\x -> x|]
22:54:49 <lunabot>  forall a . a -> a
22:54:53 <mmorrow> woohoo
22:54:57 <mmorrow> @localtime mmorrow
22:54:58 <lambdabot> Local time for mmorrow is Wed Dec 10 00:54:57
22:55:08 <quicksilver> mmorrow: pong
22:55:13 <centrinia> @localtime lambdabot
22:55:14 <lambdabot> I live on the internet, do you expect me to have a local time?
22:55:20 <mmorrow> heh, that was quite a "breeze" like i thought it'd be, but wasn't that bad
22:55:50 <centrinia> @utctime lambdabot
22:55:51 <lambdabot> uptime: 28m 45s, longest uptime: 1m 10d 23h 44m 29s
22:55:53 <centrinia>  :p
22:55:59 <mmorrow> quicksilver: hey what's up. could you possibly refresh my memory on that link to super-optimized asm gen with haskell presentation video?
22:56:02 <centrinia> Wow.
22:56:04 <rgov> i exploded
22:56:07 <rgov> what was this about a theorem prover
22:56:19 <mmorrow> err, i meant to say *wasn't* quite a breeze...
22:56:23 <centrinia> Theorem provers prove theorems. :>
22:56:59 <Cale> http://www.youtube.com/watch?v=W6sG5uraex0 -- new Catsters video :)
22:57:20 <nanothief> I'm having a problem using writeFile, it isn't truncating previous data -> http://hpaste.org/12924 . Is there another function that does this?
22:57:22 <centrinia> The Joy of Cats. :)
22:57:27 <quicksilver> mmorrow: mmm. I can't remember how to find it.
22:58:20 <centrinia> Was it from the beginning of the year?
22:58:38 <quicksilver> nanothief: how bizarre. That looks like a nasty bug in writeFile?
22:58:40 <ddarius_> There's a page on the wiki of Haskell videos.  It should be there.
22:58:43 <Cale> http://hpaste.org/12924#a1
22:58:49 <Cale> nanothief: Which OS?
22:59:00 <nanothief> archlinux
22:59:08 <nanothief> so this isn't normal behaviour?
22:59:14 <Cale> Not at all.
22:59:30 <quicksilver> nanothief: certainly not what it's supposed to do. Although the docs are a bit vague.
22:59:38 <quicksilver> writeFile should clobber the file (and start afresh)
22:59:54 <quicksilver> works as expected for me, FWIW>
22:59:56 <nanothief> Well I'm running archlinux in a virtualbox machine, and the file is located in a shared folder, so it could be caused by that
23:00:10 <nanothief> however other apps don't have this problem
23:00:20 <pumpkin> what is sp?
23:00:27 <pumpkin> http://happs.org/ mentions it in step 3
23:00:41 <pumpkin> oh searchpath I guess?
23:00:51 <Cale> yeah, searchpath
23:00:57 <centrinia> Wait, nanothief, what does the module Main contain?
23:01:32 <centrinia> Also, what happens if you don't load module Main.
23:02:03 <nanothief> centrinia, nothing relevant (the same happens without loading a file in ghci)
23:02:12 <wli> Okay, I think I fixed it.
23:02:15 <mmorrow> quicksilver: hah, me neither :)
23:02:31 <mmorrow> mmorrow: i'll consult the logs
23:02:33 <mmorrow> um
23:02:34 <Cale> Isn't archlinux what dons uses?
23:02:43 <mmorrow> quicksilver: i'll consult the logs
23:02:47 <Cale> Or is that something else?
23:02:50 <wli> > let s=(snd.).mapAccumL(\n x->(n+x,n));ws''=[2,3,5,7];ws'=filter(\x->all(\w->x`mod`w/=0) ws'')[2..product ws''+1];ws=zipWith(-)(tail ws'++[product ws''+head ws']) ws';ps=let f cs (n:ns)=let((k,qs),cs')=Map.deleteFindMin cs in if k/=n then n:f(Map.insert(n*n)[n]cs) ns else f(foldr(\p->Map.alter(Just . maybe[p](p:))(p*head[m|m<-[k`div`p+1..],not(any(\w->m`mod`w==0) ws'')])) cs' qs) ns in 2:3:5:7:f(Map.singleton 121 [11])(s 11 $ cycle ws) in take 10 $ dropWh
23:02:51 <pumpkin> Cale: I think so
23:02:51 <lambdabot>   Not in scope: `dropWh'
23:02:57 <pumpkin> oh no!
23:03:15 <nanothief> well its probably just virtualbox being buggy, so I'll just write something to work around it
23:03:16 <wli> > let s=(snd.).mapAccumL(\n x->(n+x,n));ws''=[2,3,5,7];ws'=filter(\x->all(\w->x`mod`w/=0) ws'')[2..product ws''+1];ws=zipWith(-)(tail ws'++[product ws''+head ws']) ws';ps=let f cs (n:ns)=let((k,qs),cs')=Map.deleteFindMin cs in if k/=n then n:f(Map.insert(n*n)[n]cs) ns else f(foldr(\p->Map.alter(Just . maybe[p](p:))(p*head[m|m<-[k`div`p+1..],not(any(\w->m`mod`w==0) ws'')])) cs' qs) ns in 2:3:5:7:f(Map.singleton 121 [11])(s 11 $ cycle ws) in take 10 ps
23:03:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
23:03:33 <pumpkin> ooh
23:03:37 <quicksilver> nanothief: probably, yes. File clobber on open is a function of the open() libc call
23:04:25 <mmorrow> Axman6, anyonethatcares: here's the code i just wrote to prettify the vars + get a TH Type back from an additional QuasiQuoter: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=559
23:04:48 <mmorrow> , [$tyQ| let fix f = let x = f x in x in fix |]
23:04:55 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a)) (VarT a)))...
23:04:57 <wli> > let ps = let sieve (p:xs) = p : sieve (filter (\q -> q `mod` p /= 0) xs) in sieve [2..] in ps!!39
23:04:59 <lambdabot>   173
23:05:00 <mmorrow> , ppDoc [$tyQ| let fix f = let x = f x in x in fix |]
23:05:06 <pumpkin> happs is looking for System.Log.Logger
23:05:07 <lunabot>  forall a . (a -> a) -> a
23:05:09 <mmorrow> , ppDoc [$ty| let fix f = let x = f x in x in fix |]
23:05:12 <mmorrow> oops
23:05:14 <lunabot>  luna: No instances for (Language.Haskell.TH.Utils.Ppr.Ppr
23:05:15 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
23:05:16 <centrinia> > let isprime p = (p-1) == (foldl1 (\x y -> (x * y) `mod` p) [1..(p-1)] ) in filter isprime [2..500]
23:05:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:05:21 <lunabot>  forall a . (a -> a) -> a
23:05:34 <wli> It may look heavily golfed, but it had to be for reasons of line length.
23:07:01 <wli> A more intelligent implementation would keep a wheel state around with each prime, but there's not enough space for that.
23:07:24 * mmorrow updates his #haskell one-liners-to-remember file
23:07:40 <pumpkin> hmm, my happs isn't working
23:07:53 <wli> mmorrow: Golfing Eratosthenes?
23:08:37 <ddarius_> mmorrow: How many versions of primes, factorial, and fib do you need?
23:08:41 <centrinia> > let isprime p = (p-1) == (foldl1 (\x y -> (x * y) `mod` p) [1..(p-1)] ); isprogression as [] = false; isprogression [] _ = True; isprogression _ [b] = False; isprogression (a:as) (b:b':bs) = ((b'-b)==a) && (isprogression as (b':bs))  in head $ filter (isprogression [2,2,2]) (filter isprime [2..])
23:08:42 <lambdabot>   Not in scope: `false'
23:08:51 <pumpkin> > fail
23:08:52 <lambdabot>       Overlapping instances for Show (String -> m a)
23:08:52 <lambdabot>        arising from a us...
23:08:58 <pumpkin> > fail "centrinia"
23:08:59 <lambdabot>       No instance for (Show (m a))
23:08:59 <lambdabot>        arising from a use of `show' at <in...
23:08:59 <centrinia> > let isprime p = (p-1) == (foldl1 (\x y -> (x * y) `mod` p) [1..(p-1)] ); isprogression as [] = False; isprogression [] _ = True; isprogression _ [b] = False; isprogression (a:as) (b:b':bs) = ((b'-b)==a) && (isprogression as (b':bs))  in head $ filter (isprogression [2,2,2]) (filter isprime [2..])
23:09:00 <lambdabot>       No instance for (Integral [t])
23:09:00 <lambdabot>        arising from a use of `isprime' a...
23:09:08 <pumpkin> :t fail
23:09:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
23:09:12 <mmorrow> wli: yes :)
23:09:22 <pumpkin> > fail "centrinia" :: Maybe Int
23:09:24 <lambdabot>   Nothing
23:09:29 <mmorrow> ddarius: all of them
23:09:29 <centrinia> > let isprime p = (p-1) == (foldl1 (\x y -> (x * y) `mod` p) [1..(p-1)] ); isprogression as [] = False; isprogression [] _ = True; isprogression _ [b] = False; isprogression (a:as) (b:b':bs) = ((b'-b)==a) && (isprogression as (b':bs))  in head $ filter (isprogression [2,2,2]) (tails $ filter isprime [2..])
23:09:45 <lambdabot>   thread killed
23:09:54 <wli> ddarius: It has more to do with the efficiency of the algorithm for algorithms avoiding certain barriers of mathematical maturity.
23:10:05 <centrinia> Hmm, there must be no prime p such that p, p+2, p+2+2, and p+2+2+2 are prime. :(
23:10:11 <centrinia> > let isprime p = (p-1) == (foldl1 (\x y -> (x * y) `mod` p) [1..(p-1)] ); isprogression as [] = False; isprogression [] _ = True; isprogression _ [b] = False; isprogression (a:as) (b:b':bs) = ((b'-b)==a) && (isprogression as (b':bs))  in head $ filter (isprogression [2,2]) (tails $ filter isprime [2..])
23:10:15 <lambdabot>   [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
23:10:30 <centrinia> Nice.
23:10:33 <wli> mmorrow: Look up the fastest fib in the west. ;)
23:10:40 <mmorrow> i have a utf8-encode one-liner in here, a reachable :: (a -> [a]) -> a -> [a], a bunch of random stuff. i just need a utf8decode, maybe rsa, and i'm not sure for my collection to be complete!
23:10:48 <centrinia> > let isprime p = (p-1) == (foldl1 (\x y -> (x * y) `mod` p) [1..(p-1)] ); isprogression as [] = False; isprogression [] _ = True; isprogression _ [b] = False; isprogression (a:as) (b:b':bs) = ((b'-b)==a) && (isprogression as (b':bs))  in head $ filter (isprogression [2,4]) (tails $ filter isprime [2..])
23:10:51 <lambdabot>   [5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103...
23:11:05 <mmorrow> wli: ooh, sounds like a fast draw
23:11:09 <centrinia> > let isprime p = (p-1) == (foldl1 (\x y -> (x * y) `mod` p) [1..(p-1)] ); isprogression as [] = False; isprogression [] _ = True; isprogression _ [b] = False; isprogression (a:as) (b:b':bs) = ((b'-b)==a) && (isprogression as (b':bs))  in head $ filter (isprogression [2,4,6]) (tails $ filter isprime [2..])
23:11:13 <lambdabot>   [17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,1...
23:11:21 <centrinia> Yay.
23:11:35 <mmorrow> > let reach f a = let preT (Node x xs) = x : preF xs ; preF = (preT=<<) ;  grow f a = Node a (fmap (grow f) (f a)) ; dfs f = chop . fmap (grow f);chop = (let go _ [] k = k [] ; go xs (Node y ys:zs) k = if y`elem`xs then go xs zs k else go (y:xs) ys (\r ->Node y r:go (y:xs) zs k) in flip (go []) id) in nub (preF (dfs f [a])) in nub (reach (maybe [] id . flip lookup [(0,[1,2]),(1,[4,0])]) =<< [0,1])
23:11:38 <lambdabot>   [4,1,2,0]
23:11:39 <mmorrow> heh
23:11:41 <pumpkin> is happs not supposed to work on 6.10?
23:11:46 <solrize> i thought someone had written a pure haskell integer library some while ago
23:12:09 <wli> mmorrow: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
23:12:19 <mmorrow> sweet
23:13:00 <mmorrow> ooh, this one's cool (i have here vixey doing it):
23:13:06 <mmorrow> > null . foldl (\s y -> case s of x:xs | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "(()[[]]))"
23:13:08 <lambdabot>   False
23:13:16 <mmorrow> > null . foldl (\s y -> case s of x:xs | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "(()[[]]())"
23:13:16 <lambdabot>   True
23:13:16 <pumpkin> wli: why not just use the O(1) definition
23:13:48 <wli> pumpkin: Read the caveats about the "O(1)" methods in the wiki.
23:13:53 <pumpkin> aha, didn't see
23:14:54 <solrize> higher order perl!!   ia, ia cthulhu!!!!
23:15:29 <mmorrow> haha, seen at the bottom of slashdot:
23:15:31 <mmorrow> "FOOLED you! Absorb EGO SHATTERING impulse rays, polyester poltroon!!"
23:15:33 <solrize> http://hop.perl.plover.com/book/
23:15:37 <solrize> lol
23:16:45 <wli> Anyway, where I have (p*head[m|m<-[k`div`p+1..],not(any(\w->m`mod`w==0) ws'')]) is where you need to use the saved wheel state at the time of prime insertion.
23:17:24 <hydo> HoP was a mind altering experience back when it was published.  I bought the first copy at my local geek books store.  Still it was nothing compared to learning haskell... at least for me.
23:18:13 <wli> ddarius: I think I've handled Fibonacci numbers and primes. What else was there?
23:20:17 <pumpkin> > fix (scanl (+) 0 . (1:))
23:20:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:20:28 <pumpkin> :o
23:21:02 <centrinia> > (fix (scanl (+) 0 . (1:))) !! (2^18)
23:21:04 <lambdabot>   * Exception: stack overflow
23:21:43 <llayland> trying to follow that. what is making the smileys?
23:21:56 <centrinia> > head (apply (Matrix [[0,1], [1,1]] ^ (2^18)) [0,1])
23:21:58 <lambdabot>   Not in scope: `apply'Not in scope: data constructor `Matrix'
23:23:39 <wli> let fib n = let fib' (f, g) p = let ss = f*f+g*g in if p then (f*(f+2*g), ss) else (ss, g*(2*f-g)) in snd . fold' fib' (1,0) $ dropWhile not $ [Bits.testBit n k | k <- let s = bitSize n in [s-1,s-2,..0]] in fib (2^18) `mod` (10^10)
23:25:40 <centrinia> > fst . fst $ let matsqr ((a,b),(c,d)) = ((a*a+c*b,b*(a+d)),(c*(a+d),c*b+d*d)) in until (\(n,m) -> n <= 1) (\(n,m) -> (n-1,matsqr m)) (18,((0,1),(1,1)))
23:25:42 <lambdabot>       No instance for (Num (a, b))
23:25:42 <lambdabot>        arising from the literal `1' at <in...
23:25:48 <wli> > let fib :: Int -> Integer ; fib n = let fib' (f, g) p = let ss = f*f+g*g in if p then (f*(f+2*g), ss) else (ss, g*(2*f-g)) in snd . foldl' fib' (1,0) $ dropWhile not $ [Data.Bits.testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] in fib (2^18)
23:26:05 <lambdabot>   320982007018918784246116394132781773869901763117822656208116973443026009289...
23:26:41 * wli stomped this one a while ago.
23:27:27 <centrinia> > fst . fst $ let matsqr ((a,b),(c,d)) = ((a*a+c*b,b*(a+d)),(c*(a+d),c*b+d*d)) in snd $ until (\(n,m) -> n <= 1) (\(n,m) -> (n-1,matsqr m)) (4,((0,1),(1,1)))
23:27:29 <lambdabot>   13
23:28:08 <centrinia> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! (2^4)
23:28:10 <lambdabot>   987
23:28:34 <wli> Good luck computing fib (2^18) that way.
23:29:07 <centrinia> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! (4)
23:29:09 <lambdabot>   3
23:29:18 <jml> Is Char a byte or a character?
23:29:58 <wli> In principle, a character... in practice almost everything depends on it being a byte even though they're not supposed to.
23:29:59 <centrinia> > fst . fst $ let matsqr ((a,b),(c,d)) = ((a*a+c*b,b*(a+d)),(c*(a+d),c*b+d*d)) in snd $ until (\(n,m) -> n == 0) (\(n,m) -> (n-1,matsqr m)) (4,((0,1),(1,1)))
23:30:01 <lambdabot>   610
23:30:33 <centrinia> > snd . fst $ let matsqr ((a,b),(c,d)) = ((a*a+c*b,b*(a+d)),(c*(a+d),c*b+d*d)) in snd $ until (\(n,m) -> n == 0) (\(n,m) -> (n-1,matsqr m)) (18,((0,1),(1,1)))
23:30:35 <lambdabot>   320982007018918784246116394132781773869901763117822656208116973443026009289...
23:30:41 <centrinia> Yay.
23:31:22 <quicksilver> wli: not really almost everything. just System.IO.
23:32:28 <wli> quicksilver: I thought there were a bunch of apps that used getContents for binary IO or some such.
23:33:25 <quicksilver> wli: (System.IO.getContents, yes)
23:35:36 <sjanssen> jml: Char is a Unicode code point
23:36:42 <sjanssen> which is sort of like a character, but not really
23:39:38 <solrize> ats-lang.org has been down all day :(
23:39:50 <pumpkin> works for me
23:42:28 <hml> besides haskell-mode, what else should i have in emacs for haskell coding?
23:44:32 <Botje> foot-pedals
23:46:37 <centrinia>  let p a b = if (b-a) < thresh then 1 + sum [ product [c..b] | c <- [(a+2)..b]] else let m = (b-a) `div` 2 in (p a m) * (q m b) + (p m b); q a b = if (b-a) < thresh then product [(a+1)..b] else let m = (b-a) `div` 2 in (q a m) * (q m b); thresh = 10; d = 100 in ((p 0 d)*10^(d `div` 2)) `div` (q 0 d)
23:46:42 <centrinia> > let p a b = if (b-a) < thresh then 1 + sum [ product [c..b] | c <- [(a+2)..b]] else let m = (b-a) `div` 2 in (p a m) * (q m b) + (p m b); q a b = if (b-a) < thresh then product [(a+1)..b] else let m = (b-a) `div` 2 in (q a m) * (q m b); thresh = 10; d = 100 in ((p 0 d)*10^(d `div` 2)) `div` (q 0 d)
23:46:51 <lambdabot>   * Exception: stack overflow
23:47:12 <centrinia> > let p a b = if (b-a) < thresh then 1 + sum [ product [c..b] | c <- [(a+2)..b]] else let m = (b-a) `div` 2 in (p a m) * (q m b) + (p m b); q a b = if (b-a) < thresh then product [(a+1)..b] else let m = (b-a) `div` 2 in (q a m) * (q m b); thresh = 10; d = 40 in ((p 0 d)*10^(d `div` 2)) `div` (q 0 d)
23:47:21 <lambdabot>   * Exception: stack overflow
23:49:05 <pumpkin> is happs broken on 6.10?
23:49:12 <centrinia> > let p a b = if (b-a) < thresh then 1 + sum [ product [c..b] | c <- [(a+2)..b]] else let m = (b+a) `div` 2 in (p a m) * (q m b) + (p m b); q a b = if (b-a) < thresh then product [(a+1)..b] else let m = (b+a) `div` 2 in (q a m) * (q m b); thresh = 10; d = 100 in ((p 0 d)*(10^(d `div` 2))) `div` (q 0 d)
23:49:14 <lambdabot>   171828182845904523536028747135266249775724709369995
23:49:19 <centrinia> Yay.
23:49:42 <centrinia> > let p a b = if (b-a) < thresh then 1 + sum [ product [c..b] | c <- [(a+2)..b]] else let m = (b+a) `div` 2 in (p a m) * (q m b) + (p m b); q a b = if (b-a) < thresh then product [(a+1)..b] else let m = (b+a) `div` 2 in (q a m) * (q m b); thresh = 10; d = 1000 in ((p 0 d)*(10^(d `div` 2))) `div` (q 0 d)
23:49:44 <lambdabot>   171828182845904523536028747135266249775724709369995957496696762772407663035...
23:50:39 <centrinia> That should be accurate.
23:52:18 <hydo> Botje: damn, I thought you were kidding. http://snurl.com/7q9sw  [newsgroups_derkeiler_com]
23:52:21 <hydo> oops
23:52:51 <hydo> forgot to cut off the []
