00:01:57 <Quylui> loop, yep
00:02:20 <jeffz`> Quylui: did you try my suggestion?
00:02:21 <porges> where do we file hpaste bugs?
00:02:24 <loop> Quylui: what does it say, "can't load file" or what?
00:03:19 <Quylui> verbatim: cannot open load file
00:03:28 <Quylui> followed by the directory of the file of my choosing
00:03:40 <vegai> hmm, that's weird.
00:04:01 <vegai> I use terminus in both emacs and terminal, but UCS 8210 ( "↢" ) shows fine in terminal but not emacs
00:04:48 <porges> what terminal is it?
00:05:00 <vegai> rxvt-unicode
00:05:40 <vegai> one might think that unicode doesn't work at all in emacs, but some characters do work. Like regular left and right arrows
00:05:57 <vegai> ah, the size is different
00:06:21 <vegai> wasn't the cause, though.
00:06:27 <porges> I'd assume that the non-existent characters are getting mapped to different fonts
00:06:34 <porges> and not so in emacs
00:06:54 <vegai> ah, now that you mentioned it. Yes
00:07:09 <vegai> terminus is a bitmap font, but ↢ clearly isn't here.
00:07:39 <vegai> I wonder if there are any bitmap fonts that include these characters
00:08:03 <porges> there's a good site for unicode-coverage in fonts
00:08:21 <porges> www.unifont.org/fontguide/
00:08:46 <porges> not sure if they cover bitmap ones
00:10:50 <porges> maybe try GNU Unifont which apparently covers the entire BMP
00:11:03 <porges> (wow)
00:11:09 <vegai> that's quite impressive
00:11:14 <vegai> although the font looks a bit ugly
00:11:15 <procyon112> is there a prelude or Data.List function to filter all duplicate values?
00:11:31 <mgsloan> procyon112: nub!
00:12:17 <procyon112> thx mgsloan!
00:13:39 <vegai> heh, trying to use inconsolata on my emacs aborts it
00:20:10 <porges> typical ;)
00:21:07 <vegai> xft support not quite up there yet in version 22.3.1
00:21:45 <gaze> @src snoc
00:21:45 <lambdabot> Source not found. Are you on drugs?
00:22:39 <porges> snoc is part of ByteString, no?
00:22:57 <gaze> I'm not too sure what it is...
00:23:06 <dibblego> DList I think
00:23:10 <porges> @hoogle snoc
00:23:11 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
00:23:11 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
00:23:11 <lambdabot> Data.ByteString.Lazy snoc :: ByteString -> Word8 -> ByteString
00:24:11 <gaze> ah... so it just shoves stuff on the end of a list... cons backwards :-D
00:24:12 <porges> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/src/Data-ByteString.html#snoc
00:25:19 <porges> $ → <$>
00:25:23 <porges> . → ???
00:25:55 <dibblego> . ~= <$>
00:27:06 <porges> (<.>) :: (Functor f) => (b -> c) -> (a -> b) -> f a -> f c
00:27:08 <porges> ?
00:29:35 <luqui> or maybe
00:29:40 <luqui> :t liftA2 (.)
00:29:42 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
00:29:57 <porges> that would be more useful
00:30:10 <porges> :)
00:34:23 <porges> now, just need a sane way to add "bracketing" functions to haskell :D
00:34:55 <porges> ⌈x⌉ + ⌊y⌋
00:35:18 <cizra> porges: What's that weird encoding?
00:35:39 <cizra> â -- what's it supposed to be?
00:35:41 <luqui> porges, I would like something like that for lifting, if it could be arranged
00:35:53 <porges> cizra: in the last line?
00:36:03 <porges> meant to be ceiling & floor brackets
00:36:08 <cizra> porges: yes
00:36:11 <porges> should be being sent in UTF-8...
00:36:14 <cizra> Suggest using UTF-8 like the rest of the world
00:36:15 <luqui> i.e. (+) <$> x <*> y    becomes   |x| + |y|   or somesuch
00:36:33 * luqui sees it fine
00:36:35 <cizra> porges: Hmm, you do? Lemme check, perhaps I've broken something.
00:38:19 <baaba> @pl \x -> a ++ x ++ b
00:38:21 <lambdabot> (a ++) . (++ b)
00:40:08 <Axman6> how do you switch between buffers in Vim (or macvim, looking at you ozy`)
00:40:40 <sjanssen> Axman6: ctrl-w j/k
00:40:45 <Axman6> cheers
00:40:45 <baaba> @pl \(x, y) -> a ++ (show x) ++ (f x) ++ b ++ y
00:40:46 <lambdabot> uncurry (((a ++) .) . ap ((.) . (++) . show) ((. (b ++)) . (++) . f))
00:41:39 <cizra> porges: Excuse my bashing. Somebody removed my locale and so it defaulted to C, which doesn't do Unicode.
00:41:54 <cizra> (um, if it was you I was bashing)
00:43:02 <gnman> would haskell ever operate as an operating system?
00:43:40 <flux> gnman, have you seen House/hOp?
00:44:11 <porges> luqui: it would probably be doable for some characters, IIRC Unicode actually says whether something is a "left" or a "right" parenthesis (left/right logically, because of right-to-left scripts)
00:44:14 <sjanssen> gnman: there have been a few operating systems written in Haskell
00:44:59 <cizra> gnman: I can't see any difficulty.. Unlikely to be blazing fast, but definitely possible.
00:45:02 <flux> unfortunately, about hOp: "The biggest obstacle you may find when trying to set up House & hOp is that hOp is based upon a modified version of a very old GHC and from the last time I looked at it the GHC runtime has changed enough that making a new hOp will be non-trivial."
00:45:49 <luqui> plus hOp is nothing special, because it's all IO-ridden
00:45:50 <sjanssen> luqui: I think |x + y| would make more sense
00:45:54 <flux> but apparently someone has done the job
00:46:13 <luqui> if you're going to make an OS in Haskell, why not go the extra mile and get rid of the FFI layer (IO)
00:46:25 <luqui> all programs are pure functions
00:46:25 <sjanssen> luqui: forall x. x is nothing special because x is IO-riddent?
00:46:31 <sjanssen> seems an extreme viewpoint
00:46:42 <luqui> see my supporting point
00:47:05 <cizra> luqui: Excuse me, but how do you tell your programs have run?
00:47:19 <cizra> luqui: Or perhaps you don't, you let them lazily not run and have no way of checking.
00:47:30 <cizra> luqui: Revolutionary speeds indeed.
00:47:51 <sjanssen> luqui: what about networking, reading and writing to disk, etc.?
00:47:55 <luqui> cizra, nothing runs in a functional program.
00:48:12 <luqui> those things are abstracted by the OS
00:48:18 <luqui> the OS is free to do IO
00:48:29 <luqui> but the syscalls are all pure functions
00:48:30 <sjanssen> well, ideally you'd write those abstractions in Haskell too
00:48:36 <luqui> we're working on it :-)
00:48:56 <luqui> nice thing about an OS is that you don't have to worry about interop with an imperative world behind you
00:49:03 <cizra> luqui: Well, suppose you want to write a Minesweeper game. How do you show the field to the user? It's a side effect, after all.
00:49:09 <luqui> (well, except in the case of networking)
00:49:12 <luqui> cizra, like hell
00:49:23 <cizra> luqui: Excuse me, do you claim it's not?
00:49:24 <luqui> cizra, an image is a side-effect?
00:49:41 <cizra> luqui: The event of displaying an image is.
00:50:09 <ivanm> damn entropy! :@
00:50:13 <luqui> cizra, okay, just to be sure we're talking about the same thing
00:50:23 <luqui> the implementation of the OS may do IO
00:50:34 <luqui> just the API layer is to be purely functional
00:50:41 <luqui> does your objection still apply?
00:50:50 <cizra> luqui: I think I'm missing a point.
00:51:24 <cizra> luqui: Suppose you want to show the game field. You'll have to say something like import Os, displayImage "tiles.png"
00:51:32 <luqui> really
00:51:34 <luqui> could you not say:
00:51:40 <luqui> game = image "titles.png"
00:52:08 <luqui> (well, you wouldn't say "titles.png", because that is just a string, whereas you want to refer to the actual image, but you know what I mean)
00:52:24 <cizra> luqui: Assuming "image" is an OS system call,
00:52:31 <cizra> how can it be pure if it exhibits a side effect?
00:52:39 <luqui> how does it exhibit a side effect
00:52:45 <luqui> it is simply a value which represents an image
00:52:54 <cizra> Oh. OK
00:53:11 <cizra> This I can swallow. But how do you show it to the user, anyway?
00:53:21 <Axman6> i still don't think that output needs to be something that's not pure
00:53:37 <luqui> using TVs maybe?
00:54:00 <luqui> i.e. the act of "viewing" a "program" (which is just a value) is executing it
00:54:03 <Axman6> it can't really effect the programme running, only input can really
00:54:19 <sjanssen> cizra: luqui is moving the "do it" problem from the program to the OS
00:54:47 * cizra scratches his head
00:55:16 <luqui> (this, by the way, is my dream, and every recent project is in some way a baby step toward it)
00:56:34 <sjanssen> Axman6: I don't see how input can be pure
00:56:48 <sjanssen> Axman6: erm, I mean output
00:56:53 <Axman6> sjanssen: neither do i, but that's not what i said
00:56:55 <Axman6> ah, heh
00:56:57 <fasta> Do messages on Haskell-Cafe that do not originate from a subscriber go through a manual approval process?
00:57:12 <sjanssen> fasta: yes, I think so
00:57:26 <sjanssen> fasta: though they might even be blocked outright, not sure about that
00:57:43 <chrisdone> I'm subscribed but it says I don't have access to post
00:57:46 <Axman6> sjanssen: well, not pure then, but i don't think it needs to be as problematic as input
00:57:53 <chrisdone> I emailed about it a week ago but got no response
00:57:57 <luqui> sjanssen, heard of FRP?
00:58:06 <sjanssen> luqui: yes
00:58:08 <chrisdone> oh well, I do more reading than desiring to talk back, anyway
00:58:17 <luqui> sjanssen, oh, you switched to "output"
00:58:24 <luqui> same diff, really, though
00:58:48 <luqui> though I'm not really sure what you're saying
01:00:21 <sjanssen> luqui: we can describe and model IO purely, but we can't actually do it purely
01:00:33 <luqui> because first you need to define "do"
01:00:47 <luqui> it's kind of irrelevant
01:01:05 <luqui> you can actually think of executing a Haskell program as simply viewing it through a very strange lens
01:01:24 <luqui> the issue is more that IO is so imperatively-stated
01:01:34 <luqui> it reads like "do" rather than "be"
01:01:55 <wli> Operational semantics-based interpretation?
01:02:10 <luqui> wli, right.  very complex operational semantics at that.
01:02:55 <wli> Maybe fire up a language project based on a simple operational semantics if its simplicity is so important.
01:03:25 <wli> Or maybe on keeping the operational semantics simple.
01:03:26 <sjanssen> wli: I think luqui would prefer denotational semantics instead
01:03:26 <luqui> oh, you were responding to defining "do".  but an operational semantics is still just maths, it is still just being.  a semantics doesn't do anything either.
01:03:55 <luqui> yes, I don't like to think about operation.  Computers are pretty necessarily complex in their operation, because so much abstraction is going on.
01:04:11 <luqui> but we can abstract to very simple mathematical models if we don't think about what's actually happening.
01:04:25 <wli> sjanssen: Then go for full abstraction so they coincide.
01:05:01 <luqui> wli, sure, denotational semantics is just a very vague sort of operational semantics, in some sense :-)
01:05:34 <wli> luqui: "Full abstraction" is a technical term for the operational and denotational semantics coinciding.
01:05:46 <luqui> ahh.
01:06:22 * luqui wonders... in a denotational OS, the OS is allowed to do system-wide optimization
01:06:49 <rgr> ":type [1,2,3]" in ghci gives "[1,2,3] :: (Num t) => [t]". In English how would you read the (Num t) bit?
01:07:07 <luqui> {-# RULES  right_id: x | cat ==> x #-}
01:07:13 <sjanssen> rgr: "t is an instance of Num"
01:07:26 <Cale> rgr: Or more Englishy, t is a numeric type
01:07:47 <rgr> and [t] is therefore a list of num instances?
01:08:03 <Axman6> rgr: it's a list of numbers ;)
01:08:16 <rgr> Define a number though.
01:08:19 <wli> luqui: For sufficiently simplistic languages it boils down to case statements matching multiple tags in parallel, e.g. f = \x y -> case (x, y) of { (True, _) -> True ; (_, True) -> True ; (_, _) -> False } has f undefined True = True where e.g. Haskell would not.
01:08:22 <luqui> rgr, no, [t] is a list of ts, where t is an instance of Num.    So it's a list of Ints, or a list of Doubles, or ...
01:08:34 <Cale> rgr: If t is a numeric type, then [1,2,3] is a list of values of type t
01:08:37 <luqui> but not a list of (Ints or Doubles or ...)
01:08:41 <Cale> (so they're all the same type)
01:08:49 <rgr> luqui: thahats what I thought. so Axman6 was wrong or unclear?
01:08:58 <Axman6> rgr: how would you define a number? as far as ghc(i) knows, they're just numbers, could be Floats, Integers, CReals etc
01:09:01 <rgr> its a list of one type of numbers
01:09:09 <osfameron> can you have a list of heterogenous Num types?
01:09:22 <rgr> is type the right word in haskell?
01:09:28 <cjs> So I'm a little confused about call graphs in profiling. Can someone explain this one to me? http://hpaste.org/13282
01:09:41 <luqui> osfameron, yeah, but it's pretty useless
01:09:48 <luqui> osfameron, Integer is inital for Num
01:09:54 <cjs> Oh, hang on, need the code, too....
01:10:17 <luqui> rgr, yeah in this case it is.  Int is a type.
01:10:24 <sjanssen> rgr: in Haskell, lists always contain only one type
01:11:06 <Axman6> :t [1,2,3] :: [Double]
01:11:06 <sjanssen> @type 1 -- start more simply
01:11:08 <lambdabot> forall t. (Num t) => t
01:11:08 <lambdabot> [Double]
01:11:16 <Axman6> :t [1,2,3] :: [CReal]
01:11:17 <lambdabot> [CReal]
01:11:22 <Axman6> :t [1,2,3] :: [Rational]
01:11:23 <lambdabot> [Rational]
01:11:23 <cjs> There's all that time spent below the "call-changes" call point, but where did it go? None of the things below it either use or inherit that much time.
01:11:23 <luqui> osfameron, oh, wait, we are looking for terminality I think, in which case I believe (String,String) is terminal.  (show x, show (negate x))
01:11:40 <Axman6> :t [1,2,3] :: [Complex Float]
01:11:42 <lambdabot> [Complex Float]
01:11:51 <osfameron> luqui: hmm?
01:11:53 <luqui> osfameron, (basically I am looking for all the things you can do to a number without knowing what specific type it is)
01:11:57 <osfameron> ah I see
01:12:10 <luqui> and then just use a list of that instead.
01:12:13 <Axman6> > [1,2,3] :: [Complex Float]
01:12:15 <lambdabot>   [1.0 :+ 0.0,2.0 :+ 0.0,3.0 :+ 0.0]
01:12:28 <cjs> Or does the inherited include the individual, in which case, what the heck is using all that time (and memory) at call-changes?
01:12:39 <osfameron> ah, because you can't guarantee that you can add (or whatever) 2 arbitrary instances of Num
01:12:43 <rgr> Axman6: thanks.
01:12:47 <Axman6> > cis pi
01:12:48 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
01:12:50 <luqui> osfameron, exactly
01:12:52 <cjs> Oops, I mean orderChanges.
01:12:57 <Axman6> > cis pi :: Complex CReal
01:12:59 <lambdabot>   (-1.0) :+ 0.0
01:13:00 <luqui> oh! I'm wrong though
01:13:05 <luqui> because you can add it to itself
01:13:10 <Axman6> > cis (pi/3) :: Complex CReal
01:13:12 <lambdabot>   0.5 :+ 0.8660254037844386467637231707529361834714
01:13:25 <luqui> CReal is the DEVIL!
01:13:30 <rgr> >:type pi
01:13:30 <osfameron> (Though coming from Perl it feels like you should be able to... it's clearer that you can't sort a list of heterogenous Ords)
01:13:37 <Axman6> :t pi
01:13:38 <lambdabot> forall a. (Floating a) => a
01:13:46 <rgr>  :type pi
01:13:48 <Axman6> :t cis
01:13:50 <lambdabot> forall a. (RealFloat a) => a -> Complex a
01:13:56 <luqui> > ((0::CReal) == 10^-100)
01:13:57 <lambdabot>   Not in scope: `^-'
01:14:01 <Axman6> rgr: just :t
01:14:02 <luqui> > ((0::CReal) == 10^(-100))
01:14:06 <lambdabot>   * Exception: Negative exponent
01:14:08 <rgr> :t 1.0
01:14:10 <luqui> > ((0::CReal) == 10^^(-100))
01:14:12 <lambdabot> forall t. (Fractional t) => t
01:14:14 <rgr> ??
01:14:16 <lambdabot>   True
01:14:18 <luqui> WRONG!
01:14:29 <sjanssen> luqui: whoa, how does it get that wrong?
01:14:37 <luqui> sjanssen, because CReal is a bad implementation
01:14:43 <Axman6> > 10^^(-100) :: CReal
01:14:44 <lambdabot>   0.0
01:14:52 <sjanssen> luqui: is (==) just approximate?
01:15:02 <rgr> Axman6: weird, nothing back
01:15:11 <Axman6> > drop 100 showCReal 300 $ 10^^(-100)
01:15:12 <lambdabot>   Couldn't match expected type `[a]'
01:15:12 <rgr> :t [1,2,3]
01:15:13 <lambdabot> forall t. (Num t) => [t]
01:15:14 <cjs> Maybe just because it's being called so often, it's just call overhead....
01:15:16 <luqui> yeah, could be. exact (==) is cosemidecidable (can never return True)
01:15:19 <sjanssen> > 10 ^ 100 :: CReal
01:15:20 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
01:15:21 <Axman6> > drop 100 . showCReal 300 $ 10^^(-100)
01:15:22 <lambdabot>   "01"
01:15:31 <sjanssen> > 1 / ( 10 ^ 100 :: CReal)
01:15:32 <lambdabot>   0.0
01:15:37 <luqui> yow
01:15:42 <sjanssen> hmm
01:15:47 <luqui> oh
01:15:50 <rgr> whats with the ">" prefix?
01:15:53 <sjanssen> > 1e-100 :: CReal
01:15:55 <lambdabot>   0.0
01:15:55 <luqui> > 1 / (10 ^^ (-100) :: CReal)
01:15:57 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
01:16:06 <Axman6> > 1 % (10^100)
01:16:08 <lambdabot>   1%1000000000000000000000000000000000000000000000000000000000000000000000000...
01:16:08 <luqui> okay, it must be that (==) is approx
01:16:28 <sjanssen> > toRational (1e-100 :: CReal)
01:16:29 <lambdabot>   * Exception: CReal.toRational
01:16:38 <sjanssen> great.
01:17:54 <sjanssen> > showCReal maxBound (1e-100 :: CReal)
01:17:55 <lambdabot>   "* Exception: Negative exponent
01:18:15 <sjanssen> > showCReal 1000 (1e-100 :: CReal)
01:18:16 <lambdabot>   "0.000000000000000000000000000000000000000000000000000000000000000000000000...
01:18:23 <fasta> Anyone interested in seeing how Python can call Haskell?
01:18:24 <chrisdone> @hoogle getProduct
01:18:24 <lambdabot> Data.Monoid getProduct :: Product a -> a
01:18:53 <sjanssen> luqui: yes, looks like (==) only checks to a certain precision
01:19:19 <sjanssen> luqui: which is somewhat reasonable
01:19:35 <luqui> well I'm not a fan, but ok...
01:20:05 <luqui> it's kind of aesthetic, though it breaks the unspoken convention that Eq is for observational equality
01:20:05 <fasta> Anyway, [SPAM] http://gamr7.com/blog/?p=65 [/SPAM] :)
01:20:07 <sjanssen> luqui: the showCReal demonstrates that they're not actually the same value
01:20:10 <Axman6> arbitrary precision numbers should have arbitrary precision (==)!
01:20:20 <sjanssen> at least we know that the arithmetic isn't broken
01:20:38 <sjanssen> luqui: yes, I'm not saying it is nice
01:20:39 <luqui> sjanssen, well, no we don't.  but at least it's not broken like I thought it was.
01:20:41 <Axman6> fasta: was that the thing on reddit?
01:20:55 <fasta> Axman6: this is the second post. I.e. new.
01:21:03 <luqui> Axman6, you mean an (==) which takes an extra argument?
01:21:03 <Axman6> ah
01:21:23 <Axman6> luqui: no, i mean if the number goes on forever, so should the testing!
01:21:58 <Axman6> > showCReal 100 pi
01:21:59 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
01:22:19 <sjanssen> data CReal = Data.Number.CReal.CR (Int -> Integer) -- I wonder how it actually works?
01:22:58 * sjanssen uses some unsafeCoerce#
01:23:05 <luqui> Axman6, so you mean infinite precision numbers should have infinite precision (in)equality
01:23:34 <mapreduce> pumpkin: No, I cannot be considered a hylomorphism. :)
01:23:34 <Axman6> i had a look at the source a while ago, it was rather... well beyond my knowledge
01:23:38 <Axman6> luqui: of course!
01:23:49 <luqui> Axman6, agreed
01:23:54 <luqui> have you seen ASD?
01:24:06 <Axman6> i was joking btw. and no?
01:24:21 <luqui> oh, but I agree anyway.
01:24:51 <luqui> ASD = Abstract Stone Duality. Formalization of computable topology, in which they talk about real numbers and equality and stuff.
01:24:56 <Axman6> so you think that (== pi) should never terminate
01:24:56 <Axman6> ?
01:24:58 <luqui> It's my current obsession
01:25:07 <luqui> Axman6, what?  it should!
01:25:11 <luqui> pi == pi shouldn't.
01:25:16 <idnar> luqui: why not?
01:25:26 <luqui> idnar, because it's undecidable
01:25:32 <sjanssen> > pi == pi
01:25:33 <lambdabot>   True
01:25:40 <idnar> luqui: not necessarily
01:25:49 <sjanssen> > pi == (pi :: CReal)
01:25:50 <lambdabot>   True
01:25:53 <luqui> idnar, well extensionally speaking it is
01:26:03 <osfameron> why would making that comparison useless help?
01:26:05 <idnar> luqui: you just need a suitable internal representation
01:26:09 <luqui> i.e., pi == sum (... some formula of pi ...)
01:26:11 <luqui> idnar, like?
01:26:21 <luqui> idnar, (and can this internal representation handle all computable reals?)
01:26:32 <luqui> obviously if you're working in Q[pi] or something then you can.
01:26:48 <idnar> luqui: pi == pi can terminate without pi == sum (... some formula of pi ...) terminating :)
01:26:57 <luqui> idnar, but that breaks referential transparency
01:27:08 <idnar> luqui: why?
01:27:09 <quicksilver> well, not necessarily.
01:27:16 <quicksilver> depends on the storage format chosen.
01:27:18 <luqui> because sum (.. some formula of pi .. ) = pi, by definition
01:27:31 <luqui> (that's what I mean by "extensionally speaking")
01:27:42 <quicksilver> that doesn't meant referential transparency is broken
01:27:47 <quicksilver> it justs means == is partial
01:27:54 <idnar> luqui: that doesn't have anything to do with referential transparency
01:28:01 <quicksilver> referential transparency is denotational, it's not a property about ==
01:28:12 <sjanssen> ah, so n is represented as \x -> n * 2^x
01:28:23 <luqui> okay okay... if pi == pi terminates, that is a bug in ==
01:28:40 <idnar> I don't see why it has to be considered a bug
01:28:47 <luqui> because == does not preserve extensionality of numbers
01:29:05 <luqui> pi == pi  = True in one case, but pi == pi = _|_ in another case
01:29:08 <sjanssen> luqui: looks like CReal can't even be certain 1 == 1
01:29:13 <luqui> so there must be some pi /= pi
01:29:19 <luqui> sjanssen, true
01:29:24 <idnar> luqui: no
01:29:32 <idnar> luqui: there must be some pi /= pi == _|_ :P
01:29:32 <johnnowak> this is why I do all my work in base-pi .. easier comparisons
01:29:33 <luqui> sjanssen, on computable reals, (==) can only ever return False
01:29:41 <idnar> er, =
01:29:46 <luqui> idnar, heh, I meant /= in the mathematical sense.
01:29:56 <luqui> er.
01:29:59 <porges> did anything ever come of http://haskell.org/haskellwiki/Quantified_contexts
01:30:02 <sjanssen> luqui: so you'd prefer that CReal was not an instance of Eq?
01:30:08 <sjanssen> luqui: sadly Haskell won't let us do that
01:30:21 <luqui> sjanssen, nah it can be.
01:30:22 <sjanssen> (if we want Num)
01:30:24 <idnar> luqui: mathematically, pi == pi
01:30:27 <luqui> just (==) should never return True
01:30:32 <quicksilver> well you can do instance Eq CReal where (==) = error "Don't do that you idiot"
01:30:40 <idnar> luqui: so pi == pi = _|_ is already a little off the path
01:30:48 <luqui> yeah that works too, because error "Don't do that you idiot" is _|_
01:31:10 <luqui> idnar, indeed, but we already have [1..] == [1..] = _|_
01:31:18 <luqui> so I assume Eq is allowed to be partial
01:31:36 <idnar> luqui: yes, but is that actually *desireable*
01:32:01 <luqui> so you are a perl programmer now, preferring some vague notion of usefulness over correctness?
01:32:14 <idnar> luqui: what is "correct" about [1..] == [1..] = _|_?
01:32:32 <luqui> idnar, IMO it's more correct than [1..] == [1..] = True.
01:32:41 <idnar> luqui: by what standard?
01:32:44 <idnar> that's all I'm getting at
01:32:55 <luqui> because you cannot in general replace [1..] with another definition of [1..] and get the same answer.
01:33:21 <idnar> er, why not?
01:33:27 <luqui> because of the halting problem.
01:33:46 <idnar> I don't follow; if you get a different answer, then it's not [1..]
01:33:57 <sjanssen> 1 : if halts p then [2 ..] else []
01:33:58 <luqui> [1..] == map (`div` 2) numbers_representable_as_a_sum_of_two_primes
01:34:15 <sjanssen> where p is an arbitrary program
01:34:55 <idnar> luqui: okay, so maybe that's still
01:34:59 <idnar> luqui: okay, so maybe that's still _|_
01:35:36 <sjanssen> idnar: how do we define which will be _|_, and which will be True?
01:36:04 <idnar> sjanssen: what standard guides the current implementation?
01:36:08 <sjanssen> is [1 ..] == 1 : [2 ..] True or _|_?
01:36:16 <sjanssen> @src (==) []
01:36:16 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:36:37 <idnar> sjanssen: what rule says "comparing infinite lists for equality *must* be _|_"?
01:37:00 <sjanssen> idnar: [] == [] = True; (x:xs) == (y:ys) = x == y && xs == ys; _ == _ = False
01:37:21 <idnar> sjanssen: but that's just the implementation
01:37:38 <luqui> idnar, I'd say the rule is, if a == b = True, then a = b.
01:37:49 <luqui> and if a == b = False, then a /= b
01:37:59 <idnar> luqui: my suggestion doesn't violate either of those
01:37:59 <luqui> that's actually stricter than I require for my argument
01:38:05 <luqui> idnar, it sure does
01:38:08 <idnar> luqui: how?
01:38:19 <idnar> [1..] == [1..] = True, and [1..] = [1..]
01:38:41 <luqui> because [1..] == map (`div` 2) ...
01:38:45 <luqui> er,
01:38:51 <luqui> because [1..] = map (`div` 2) ...
01:38:56 <sjanssen> idnar: what you want will necessarily violate referential transparency
01:39:12 <johnnowak> idnar: there's no way to compare [1..] with an any equivalent expression in finite time
01:39:25 <idnar> johnnowak: not with the current implementation, no
01:39:26 <johnnowak> or rather, with an arbitrary equivalent expression
01:39:30 <luqui> where equivalent is defined *extensionally*, *denotationally*
01:39:30 <johnnowak> not with any implementation
01:39:40 <idnar> luqui: [1..] == map (`div` 2) ... is _|_, so neither of your rules apply
01:39:48 <luqui> idnar, true
01:40:01 <luqui> but that would mean that ([1..] == [1..]) /= ([1..] == map (`div` 2))
01:40:14 <luqui> which is the violation of referential transparency, because those right arguments are *the same*
01:41:47 <quicksilver> that's not what referential transparency means. referential transparency just means you can replace things with their definitions.
01:42:06 <quicksilver> it doesn't speak about expressions which might be denotationally the same according to some external mathematical oracale.
01:42:30 <johnnowak> aye
01:43:26 <luqui> quicksilver, alright, I have been misusing the term.
01:43:47 <luqui> it violates the denotational semantics then
01:44:09 <sjanssen> so isn't the real problem the definition of []?
01:44:13 <sjanssen> @src []
01:44:14 <lambdabot> data [] a = [] | a : [a]
01:44:28 <paolino> @src Control.Monad.Reader.Reader
01:44:28 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:44:37 <sjanssen> given that, we can't determine that [1 ..] is [1 ..] in finite time
01:44:54 <quicksilver> I'm not really sure what mechanism is being suggested for making [1..] ==  [1..] true
01:45:03 <quicksilver> one which springs to mind is:
01:45:12 <luqui> sjanssen, yeah, if it were defined as some suitable subset of recursively enumerable sequences then we could
01:45:19 <quicksilver> data [] a = NatFromOne | [] | a : [a]
01:45:35 <quicksilver> then there is nothing wrong with instance Eq where NatFromOne == NatFromOne = True
01:45:39 <luqui> quicksilver, with the provision that NatFromOne /= [1..] ?
01:45:48 <luqui> from a denotational standpoint?
01:46:03 <quicksilver> that's up to you. Pick the denotation of your choice :P
01:46:18 <sjanssen> luqui: presumably you'd adjust the Enum instance to create NatFromOne
01:46:28 <quicksilver> denotational semantics is not a unique natural thing: there are often quotients around.
01:46:39 <quicksilver> You can imagine a denotational semantics which denotes Data.Set by actual sets
01:46:40 <luqui> quicksilver, okay, but the point is that NatFromOne must not be denotationally equal to some other recursive sequence
01:46:40 <sjanssen> but you'd still have problems with "iterate succ 1"
01:46:48 <quicksilver> and another wthihc denotes them by trees
01:56:03 <paolino> why lambdabot isn't explaining the difficulties in finding the sources instead of mimics a clever mind ?
01:56:45 <sjanssen> paolino: someone thought it would be funny to add insults to failing commands
01:56:50 <sjanssen> personally, I find them annoying
01:56:54 <idnar> they're way over the top
01:57:07 <Raevel> sometimes it makes me cry?
01:57:08 <sjanssen> especially in the case of @src when lambdabot is usually the stupid one
01:57:20 <idnar> I mean, if there were something funny about them, I might laugh
01:57:23 <idnar> but they're just random insults
01:58:55 <paolino> anyway, is the kernel of State and Reader and Writer always  Box (a -> (b,a)) ?
01:59:13 <quicksilver> paolino: No.
01:59:26 <quicksilver> Writer is (w,a) and Reader is (r -> a)
01:59:37 <quicksilver> you could implement them both with state, but that is not how they are implemented.
02:00:27 <redditbot> Bridging Python and Haskell (part2)
02:00:42 <quicksilver> (and if you implement Writer with State, you lose the ability to observe infinite actions)
02:01:22 <paolino> ah, that is a point
02:03:01 <quicksilver> all monads which can be implemented in pure haskell, can be formed by a tower of ContT and StateT.
02:03:05 <quicksilver> I can't prove that :-S
02:03:46 <paolino> quicksilver: infinite actions are observable with WriterT w m , for any m ?
02:04:13 <luqui> paolino, no, not for monads with a strict bind like IO
02:04:38 <quicksilver> luqui: infinite IO actions are observable by the RTS though
02:04:46 <luqui> touche :-)
02:04:50 <quicksilver> slightly different sense of 'observable'
02:05:09 <luqui> well, in particular, you'll never get the "w" out
02:05:19 <quicksilver> paolino: I think you want it the other way around
02:05:29 <quicksilver> paolino: MT (Writer w) a
02:05:34 <quicksilver> that should be ok.
02:05:38 <mbz> how long does it take to compile ghc-6.10 with extra libs?
02:05:47 <quicksilver> mbz: 15 minutes to an hour ?
02:05:51 <quicksilver> longer on a slow machine.
02:05:59 <luqui> quicksilver, assuming MT has observation...
02:06:23 <quicksilver> luqui: not necessarily. You will always be able to observe your "lift tells"
02:06:29 <Raevel> took an hour for me i think, on a 2ghz c2d
02:06:30 <quicksilver> luqui: because the (w,) is outermost.
02:07:03 <luqui> quicksilver, oh right, using the other MonadWriter operations
02:07:13 <luqui> I was assuming only "tell" was available
02:07:36 <mbz> quicksilver: that's with make -j <number of cores *2> ? or just make w/o multiple jobs?
02:09:11 <quicksilver> mbz: with -j somethign or other
02:09:50 <paolino> the lazyness of runWriter implies the appending at the tail of w ?
02:10:44 <quicksilver> paolino: well you need a monoid with the right properties
02:11:04 <quicksilver> paolino: you need a monoid such that you can observe (part of) "a `mappend` _|_"
02:12:11 <paolino> > take 1 $ [1] `mappend` _|_
02:12:12 <lambdabot>   <no location info>: parse error on input `|'
02:12:44 <luqui> > take 1 $ [1] `mappend` undefined
02:12:46 <lambdabot>   [1]
02:13:21 <quicksilver> ironically, although you can do that with list, the complexity it forces is horrible.
02:13:28 <quicksilver> and if you switch to DLists to solve the complexity
02:13:34 <quicksilver> you lost the partial observation.
02:13:37 <quicksilver> D'oh!
02:14:15 <luqui> though only under certain uses is the complexity of list horrible
02:14:46 <luqui> if your binds are mostly right-associative (which they have to be for infinite actions), you'll be fine
02:15:53 <luqui> quicksilver, also, you might be delighted to hear that I disagree
02:16:08 <luqui> > foldr1 (.) [ (x:) | x <- [1..] ] []
02:16:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:19:09 <quicksilver> luqui: oh, that's interesting.
02:19:17 <quicksilver> luqui: cute.
02:19:26 * quicksilver really didn't expect that to work for some reason.
02:20:15 <quicksilver> I guess if it didn't, CPS transform would break laziness
02:20:20 <quicksilver> so of course it works :)
02:20:32 <luqui> it is a common myth that CPS transform does break laziness
02:20:41 <Heffalump> it presumably depends on (.) being declared infixr
02:20:47 <Heffalump> oh, no, duh
02:21:28 <quicksilver> luqui: it's not a myth that I conciously believed :)
02:21:36 <quicksilver> luqui: I just didn't expect DList to work.
02:21:39 * quicksilver slaps quicksilver 
02:22:09 <luqui> sure.  but I see people saying that "CPS is a way to force order of evaluation", which is only barely true
02:22:58 <sjanssen> > foldr1 (.) [ f x | x <- [1..] ] z
02:22:59 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
02:24:09 <hugo___> hello
02:24:21 <luqui> buenos dias
02:25:17 <hugo___> how is everything ?
02:25:24 <jsn> it's fine
02:26:17 <luqui> well, I've been depressed lately.  My life is just out of control, you know?  My job is ...  <insert 10 minutes of melancholy complaining here>
02:26:26 <luqui> (be careful what you ask)
02:27:09 <lchaplin> wow,  imust say it out loud, i've never seen so many ppl at once unhappy with their current job
02:27:20 <lchaplin> in a other chan, same topic atm
02:27:28 * cizra is happy with his current job \o/
02:28:03 <lchaplin> cizra: what do you do and wheer? :)
02:28:13 * luqui doesn't have a job, and is very happy with his work, to be honest.  I was just finding the least fixed point of hugo___'s question
02:28:20 <hugo___> :)
02:28:24 <hugo___> im programming in haskell for a life
02:28:30 <hugo___> i guess that is good
02:28:39 <hugo___> im getting paid 700 euros/month
02:28:42 <hugo___> tax-free
02:28:50 <hugo___> which is okey in portugal
02:29:10 <hugo___> specially since im just learning it
02:29:53 <cizra> lchaplin: I maintain and rarely develop new C++ systems. Mostly one-of-a-kind servers etc. Sometimes also quickie hacks in Ruby etc. Where? Well, the company name wouldn't tell you anything, I guess
02:30:08 <hugo___> hehe
02:31:22 <lchaplin> :)
02:31:40 <jsn> hugo___: wow, how did you swing that?
02:32:07 <jsn> i recently lost my job, actually
02:32:16 <jsn> we weren't able to get an angel
02:32:44 <desp> I'm trying to install some haskell packages on gentoo, and the process appears to hang during "Linking setup ..."
02:32:53 <hugo___> jsn: well, i met two hotel managers that needed an app, one of them has a course on informatics, and i said i would help them do it as long as it is in haskell... (i just thought it would be good to learn a functional language along the project development)
02:33:05 <desp> Any ideas why ld would gobble up all available memory?
02:33:34 <desp> Does it really need more than 256MB just to compile, for example, haddock?
02:33:50 <sjanssen> desp: Haskell packages usually use split objects, and ld needs lots of memory to link many split objects
02:33:59 <sjanssen> desp: yes, much more than that actually
02:34:01 <desp> Crap.
02:34:18 <desp> No haskell on my slicehost :(
02:34:48 <sjanssen> desp: you could just not use haddock
02:35:06 <desp> sjanssen: I was actually just trying to compile darcs.
02:35:16 <hugo___> i can't count the number of java/C# jobs that i've said no to... most of them paying the double of what im earning now "im young, i can spare one year getting badly paid in order to learn a new language" thats what i thought :/
02:35:27 <desp> Oh well, thanks for the explanation.
02:35:29 <hugo___> some days i regret it, some days i feel happy about it...
02:36:03 <cizra> hugo___: Think about it. If you know Java/C# AND Haskell, you'll be forever ahead of those who only know Java/C#.
02:36:40 <cizra> hugo___: Although I write C++, I'm thinking about purity, for example, if I can.
02:36:50 <hugo___> cizra: yes, the thing is that now i know haskell, im not planing on going back to java/C# :/
02:37:04 <hugo___> hmm my last job offer was in a game dev company, coding c++
02:37:31 <hugo___> they saw some projects i worked out while at univ. and contacted me :/ i guess the world is small in portugal
02:38:13 <lchaplin> portugal you say?
02:38:39 <cizra> hugo___: Life isn't all about money. You have no family to support, I suppose?
02:38:59 <hugo___> i have some... but i mostly live by myself
02:40:02 <cizra> hugo___: I mean, does someone other depend on your income? Do you give money to others who need it?
02:40:45 <cizra> hugo___: If not, you can just pee onto the money issue from a high fir. We hackers know where true happiness is, in hacking (=
02:40:46 <hugo___> no
02:41:06 <hugo___> an icecream and cinema ticket for my girlfriend here and there :) and thats about it
02:41:13 <hugo___> ahah
02:42:19 <cjs> I wish I had a little magic function I could aim at things to instantly evaluate them to NHF.
02:42:58 <cizra> NHF?
02:43:21 <cjs> "Normal Head Form". I.e., a fully-evaluated data value, with no unevaluated thunks inside it.
02:44:00 <cizra> w00t! Thanks to Real World Haskell I know what a thunk is \o/
02:44:12 <sjanssen> cjs: have you seen Control.Parallel.Strategies.NFData?
02:44:18 <chrisdone> is pandoc fairly well used outside of the Haskell community?
02:44:27 <chrisdone> cizra: yay /o/
02:44:42 <cjs> Ah, they do have WNHF in the index of RWH.
02:45:01 <sjanssen> cjs: isn't that usually abbreviated WHNF?
02:45:01 <cjs> sjanssen: Yup. Used it.
02:45:21 <sjanssen> cjs: you'd just prefer a more general type?
02:45:32 <cjs> No, WNHF means that the particular item is evaluated, but may still have unevaluated thunks in data structures inside it.
02:45:41 <quicksilver> which is why he suggested NFData?
02:45:58 <quicksilver> which doesn't have that problem.
02:46:00 <cjs> Oh, sorry, I mispelled; that's what you were saying.
02:46:12 <quicksilver> Of course you can't specify useful NFData instances for many types
02:46:17 <cjs> quicksilver: Yeah, we went through this all about five or six months ago, remember? :-)
02:46:20 <quicksilver> especially those with -> and IO in them.
02:46:33 <quicksilver> ;)
02:47:39 <cjs> Anyway, yeah, I'm going to go do the NFData thing on this particular bit that's bugging me, but it seems so much work, compared to a special super-magical language construct which just says "NHF, here and now!"
02:48:01 <cjs> (Where I don't have to think about the real meaning of "here" and "now" in pure code. :-))
02:48:30 <cjs> Actually, having it a function in IO would make it unmagical, don't you think?
02:48:37 <sjanssen> what is so much work about "rnf thething"?
02:48:46 <quicksilver> sjanssen: defining the NFData instances, I suppose?
02:48:48 <sjanssen> I guess you have to write the instances, which is annoying
02:48:54 <cjs> Defining the instances.
02:48:59 <sjanssen> there is Data.Derive for that
02:49:13 <cjs> Hm. Maybe it's time for me to look in to that.
02:50:09 <quicksilver> Is Data.Generics expressible enough to implement NFData?
02:50:13 <quicksilver> (from Data)
02:51:34 <osfameron> is wxHaskell a good first choice for getting started with GUI programming?
02:52:06 <cizra> wx has traditionally been butt-ugly
02:52:21 <cizra> Or was that TK? Who knows.
02:52:27 <osfameron> cizra: ugly code, or ugly output?
02:52:37 <osfameron> Tk is definitely horrid to look at
02:52:42 <cnwdup> osfameron: I started with GTK and used gtk2hs on haskell. Don't know if it's a good choice, but I don't regret it.
02:52:55 <cizra> osfameron: ugly to look at/output
02:53:03 <ikegami__> how about SDL?
02:53:22 <cizra> osfameron: But I might be mistaken.
02:53:32 <qebab> SDL isn't really made for GUI programming...
02:54:01 <osfameron> certainly not for widgety guis
02:54:03 <qebab> I mean, you can probably use it to make a GUI toolkit, but it's not one in its own right
02:54:49 <quicksilver> I played with wx a bit
02:54:51 <quicksilver> it seems nice
02:54:53 <Peaker> I wrote a tiny JavaFX-like toolkit in Python for SDL
02:55:08 <quicksilver> (I mainly chose it because gtk native on OSX is a hassle)
02:55:17 <cizra> osfameron: I take my words back. wx looks just as averagely ugly as anything else.
02:55:20 <osfameron> if I have time, I'll try to write a crossword player gui over christmas
02:55:26 <osfameron> cizra: hehe
02:55:50 <Peaker> I think all the "standard" toolkits are horrible... emulating paper forms is a bad idea
02:57:16 <Raevel> oh i finally "got" parsec
02:57:28 <cizra> Peaker: Do you have an example of something not horrible?
02:57:41 <Peaker> cizra: the iPhone, and iGo's interface
02:57:54 <jsn> Peaker: by "paper forms" you mean, emulating like, official forms, or do you mean paper based artistic forms?
02:58:05 <jsn> like, for example, illuminated books and such?
02:58:09 <Peaker> jsn: I mean having a bunch of "fields" you "tab" through and fill with numbers and letters
02:58:16 <jsn> got it
02:58:18 <Peaker> cizra: for a keyboard/mouse interface, quicksilver is nice
02:58:27 <osfameron> if I'm emulating a crossword puzzle, there's not really much else I'd want to do than emulate a paper form...
02:58:35 <Peaker> Emacs's "ido" is also a relatively nice interface
02:59:08 <cizra> Peaker: Only seen an iPhone from afar. iGo? first time seeing that name. Quicksilver? Also unfamiliar..
02:59:42 <Peaker> cizra: iGo is navigation software for Windows mobile devices -- it stands in huge contrast to Microsoft applications -- in that its actually usable
02:59:50 <cizra> a computer utility software program for Mac OS X, made by Blacktree Software and distributed freely -- this?
02:59:53 <cjs> Raevel: congrats!
03:00:01 <Peaker> cizra: Quicksilver is one guy's work on the Mac originally, but clones for Gnome, KDE and probably Windows sprung up
03:00:08 <Peaker> cizra: yeah
03:00:37 <cizra> Hm, OK
03:01:05 <Raevel> i stopped using quicksilver when spotlight stopped sucking
03:01:40 <Peaker> cizra: Optimizing simple parameters like: A) Amount of screen showing useful information / noise. (StN on screen)  B) Amount of input device space covered by useful actions (StN on keyboard)  C) Amount of interaction required to input something  D) No async surprises changing the meaning of all your inputs,   etc
03:02:15 <Peaker> These parameters are all horrible for the typical toolkit application, and pretty great for iPhone/iGo/quicksilver
03:03:05 <Peaker> C is truly horrible, for example, when you have to go through a list of icons to select something, rather than pressing a fixed key or fixed screen position -- not having to even read the computer's output (which is mentally exhausting)
03:03:31 <cizra> C?
03:03:40 <Peaker> the above item I numbered as "C"
03:03:44 <cizra> oh.
03:04:02 <Raevel> a fine number
03:04:19 * cizra prefers urxvt for his user-interface needs
03:04:23 <Peaker> cizra: that's why keyboard control is so great (though it can be done on screen too, its more difficult) -- because you can press the keys to do stuff, without having to first consult with an icon list or such -- motor memory is so much faster
03:04:47 <cizra> Peaker: Indeed. ♡xmonad♥
03:04:56 <Peaker> cizra: rxvt/terminal emulators allow keyboard keys to do predictable things without having to read output first.. its one of the reasons people hate GUI's and like CLI's, but GUI's don't have to be this way
03:05:09 <Peaker> I really ought to try xmonad out :)
03:05:13 <Peaker> I'm too lazy though
03:05:38 <cjs> Lots of WMs besides xmonad are great for keyboard control. I'm an fvwm guy myself. I just can't live without overlapping windows.
03:05:58 <quicksilver> there is a very substantial conflict between power (for a user who knows the controls) and discoverability.
03:06:14 <quicksilver> Blender has a truly excellent interface by the first metric, and a dire one by the second.
03:06:38 <quicksilver> the iPhone is good at both, but then its goals are far more limited in scope so it's not such a fair comparison.
03:06:39 <cizra> cjs: I use overlapping windows in XMonad as well. I just have to rip them out of the grid.
03:06:40 <Peaker> quicksilver: Do you know gmail's "?" ?
03:06:47 <quicksilver> Peaker: no.
03:07:00 <Peaker> quicksilver: in gmail, there are keyboard shortcuts for everything, and you can see them by pressing ?
03:07:05 <cjs> cizra: really? Maybe I should have a look at it again one day, then.
03:07:05 * quicksilver nods
03:07:13 <Peaker> quicksilver: I think that's a simple conflict resolution :-)
03:07:26 <Peaker> emac's "show keyboard bindings" feature too
03:07:28 <cizra> cjs: mplayer, for example, is launched out of the grid, out of the box.
03:07:32 <Peaker> (though it itself is not discoverable!)
03:07:35 <quicksilver> Peaker: I'm not claiming the conflict is irresolvable.
03:07:51 <quicksilver> Peaker: but there's a little more to it than saying "gmail's ? solves it"
03:08:03 <quicksilver> Peaker: a complex application has more functionality than could ever be displayed onscreen at once.
03:08:26 <quicksilver> and cluttering the screen up with discoverability may detract from what the screen is *supposed* to be displaying
03:08:27 <Peaker> quicksilver: I am not sure the right quality we're comparing here is "power", btw, assuming the same set of actions, you have the same power.. perhaps UI efficiency?
03:08:28 <osfameron> ooo I didn't know gmail's "?"
03:08:31 <quicksilver> (the current document or whatever)
03:09:05 <cizra> quicksilver: My preferred way is to keep simple things simple. Advanced users can dig in the docs themselves. See GNU screen.
03:09:43 <Peaker> screen has  C-a, ?
03:10:00 <quicksilver> Peaker: efficiency might be a better word. Since humans have limited intelligence and patience however, efficiency translates to power.
03:10:13 <quicksilver> Peaker: emacs is a powerful editor because its UI is efficient, enabling me to do complex tasks quicky.
03:10:28 <Peaker> quicksilver: I think the concept of "application" itself is a bad one -- we should be talking about widgets -- and widget discoverability should be able to fit on-screen
03:10:42 <cizra> Peaker: Missed my point. Screen is extremely easy to use for newbs, with about 5 minutes of introduction.
03:10:46 <Peaker> quicksilver: emacs has actual features that others don't have that increase power
03:10:56 <quicksilver> cizra: well "docs" is a continuum. The kind of discoverability features Peaker is discussing are a kind of documentation.
03:11:00 <cizra> Peaker: vim (and God forbid, vi), OTOH, is extremely difficult.
03:11:22 <quicksilver> I don't really think that's a reasonable comparison.
03:11:41 <qebab> cizra: my use of screen is basically "screen irssi" every few months, C-a d and "screen -rd" every few days
03:11:44 <qebab> :)
03:12:01 <quicksilver> screen is only easy to use in that sense that three commands (^a^a ^a0 and ^ac) are enough to accomplish a useful task.
03:12:11 <quicksilver> any program which can be useful with only three commands is easy to learn.
03:12:14 <quicksilver> most people can learn three :)
03:12:16 <Peaker> What's an "application" anyway? A hard-wiring of widgets to some input/output (for example, output to a sound device, or input from a file)?  That sucks, wiring widgets to input/output should be done by the user
03:12:34 <quicksilver> Peaker: No. An application is program which lets me do something I want to do.
03:12:36 <Peaker> quicksilver: ^ad  is the most useful feature of screen :)
03:12:49 <cizra> qebab: There are LOTS of fun things you can do. Like splitting one screen into two side-by-side views. And multi-user screening, to help newbs. etc.
03:12:50 <Peaker> quicksilver: A widget is a program that lets you do what you want :)
03:12:53 <quicksilver> Peaker: create a 3D model. create a web page. do my accounts.
03:13:05 <quicksilver> I never use ^ad.
03:13:07 <qebab> cizra: Yeah, but I don't need those things :)
03:13:12 <quicksilver> I just close the terminal. Or the laptop.
03:13:28 <quicksilver> or walk away from the computer.
03:13:32 <cizra> qebab: Sure. And my grandfather didn't need anything but a stone axe either. That's why I refuse to use computers and microwave ovens.
03:13:42 <Peaker> quicksilver: Application is an artificial and limiting blob, a set of menus, and hard-wiring of inputs/outputs around an otherwise useful set of widgets and functionality
03:14:15 <Peaker> quicksilver: As conal said,  libraries are a means to an end, applications are an end, but they're a dead end :)
03:14:25 <qebab> cizra: That's not really a fair comparison.
03:15:28 <jsn> i think conal's idea of composable applications is really the ideal, yeah
03:15:34 <Peaker> quicksilver: part of the horribleness of UI's today is that things are jailed inside "applications", which communicate via files (horribly UI to do this) or D&D which is very limited
03:15:48 <jsn> D&D ?
03:15:52 <Peaker> drag&drop
03:15:55 <jsn> ah
03:16:11 * jsn was about to put on his robe and wizard's hat...
03:16:22 <qebab> you have a wizard's hat?
03:16:23 <Peaker> Another problem is that we need a whole separate application if we're decoding an mp3 into a file, or if we're decoding an mp3 into the audio device -- why?
03:16:26 <qebab> that's awesome
03:16:48 <Peaker> Each have their own "menus" (menus are a horrible UI concept too!) and hard-wirings
03:16:52 <quicksilver> Peaker: well I do sort of know what you mean, and I'm partly playing devil's advocate by poking at your ideas.
03:16:54 <jsn> Peaker: why do we need a separate application for that -- I don't understand?
03:17:12 <quicksilver> Menus are not terrible UI.
03:17:17 <quicksilver> Menus are excellent UI.
03:17:29 <quicksilver> they enable you to explore and discover related features and functionality.
03:17:44 <jsn> Peaker: i think you are just raining down the fire and bromstone
03:17:54 <Peaker> jsn: we have a music decoding function -- we want to connect its output to a file or to the audio device -- why is the UI to do these functionally similar things so different?
03:18:47 <jsn> well, i'm there is a UNIX program that allows you to pipe the decoded audio into a file as well as a device
03:18:58 <Peaker> quicksilver: menus are only good for discoverability - and even there, it could be better.  Menus are too arbitrary that everyone just goes through them all (the hierarchy is meaningless except for those who already know it) -- and they are not associated with whatever object they operate on, in a way that suggests what they do/affect
03:18:59 <jsn> s/there/sure there/
03:19:16 <Peaker> jsn: yep, the Unix pipe way is great in this regard..
03:19:16 <quicksilver> Peaker: you're conflating badly designed menus with menus.
03:19:22 <cnwdup> peaker: Maybe because they're only similar from a technical point of view but not from the end-user's which is often designed to resemble the real world where folders and audio devices are not the same.
03:19:32 <paolino> there are contextual ones also
03:19:46 <Peaker> quicksilver: context menus are somewhat better, but the technical way they work is pretty bad
03:20:17 <cjs> Gah. I have to write rnf for UTCTime, which means for a whole bunch of types in Data.Time.
03:20:25 <jsn> i spent all this downloading audio for the icelandic lazytown, and none of my media players can play it!
03:20:56 <quicksilver> Peaker: you can imagine sensibly designed menus which have a meaningful hierarchy. You can also imagine problesm for which there is no good hierarchy. But that's OK. I'm not saying menus are the solution to everything.
03:20:56 <jsn> cjs: rnf is basically "deep strict"?
03:21:02 <cjs> Yup.
03:21:13 <quicksilver> cjs: rnf t = seq (show t)
03:21:23 <quicksilver> cjs: cute hack which works for most types you don't want to fight.
03:21:29 <quicksilver> erm
03:21:34 <quicksilver> cjs: rnf t = rnt (show t)
03:21:36 <Peaker> cnwdup: they are similar from a technical point of view, but this similarity can translate to discoverability -- people understand hooking up the wires between their TV devices because the technical reasons there are well understood by users and a UI can exploit this
03:21:37 <quicksilver> cjs: rnf t = rnf (show t)
03:21:38 <quicksilver> !!
03:21:42 <quicksilver> 3rd time lucky?
03:21:48 <cjs> quicksilver: Cool!
03:21:53 <quicksilver> a little bit slow
03:21:59 <quicksilver> but depending what you're doing, it may be good enough.
03:21:59 <Peaker> quicksilver: I am not sure I can imagine any non-trivial problem for which a hierarchy makes sense
03:22:15 <cjs> Yeah, but I tried show already: definitely not as slow as my space leak. :-)
03:22:16 <cizra> qebab: Perhaps. But more options are always good. For example, today I learned how to run IRC and MUD in the same screen, both visible at once. Very comfortable for looking at both simultaneously.
03:22:45 <Peaker> cizra: There's a google tech talk whose entire point is that "more options are not always good" :)
03:22:47 <quicksilver> Peaker: an 'edit' menu makes perfect sense in a text editing widget. A 'Buffer' menu makes perfect sense in emacs.
03:22:55 <paolino> what I find annoying in SO is that they should tailor the contextual actions to what I would probably do, based on my past doing
03:23:02 <quicksilver> Peaker: there are definitely occasions when menus work well.
03:23:08 <cnwdup> peaker: Jup. I am not trying do defend this development. But most users are lazy and expect being able to do things without learning new concepts. At least that's mostly the sole point of GUIs at all.
03:23:11 <Peaker> quicksilver: so you have "edit", and "insert", or "insert" is a submenu of edit?
03:23:14 <qebab> cizra: Well, I use like three computer programs in total... :)
03:23:27 <quicksilver> Peaker: I do understand the problem. I just think you're overstating it.
03:23:35 <Peaker> quicksilver: you will definitely have operations that relate both to files and editing, which should it go to?
03:23:36 <jsn> i think we would be better off if someone had just hidden all that GUI stuff when it first came out
03:23:42 <Peaker> quicksilver: "File" or "Edit"?
03:23:45 <jsn> curses is nice enough
03:23:46 <Peaker> quicksilver: hierarchies suck, IMO
03:24:03 <qebab> cizra: Make that five, actually.
03:24:08 <jsn> we could teach people about pipes -- as long as they really had to learn
03:24:18 <cizra> Peaker: Possibly, if they confuse the user. screen's "more options" are nicely hidden and politely staying out of your way.
03:24:36 <cizra> qebab: um, so what? I don't see how it's relevant.
03:24:44 <Peaker> cnwdup: Yes, but ironically, they have to learn _more_ concepts like the concept of "Winamp", and "Nero burning ROM", instead of just the concept of "connecting" their "music" with some "output" (CD or Audio device)
03:25:19 <jsn> Peaker: well, some sort of GUIfied pipe connection is obviously right
03:25:33 <jsn> who can argue with that?
03:25:36 <Peaker> cnwdup: because they now need 10 applications for various input/output connections they can make, they have to learn so much more than just how to connect stuff and what stuff is available to connect
03:26:21 * quicksilver notes that iTunes for example, can burn CDs and play music with a pretty uniform interface.
03:26:24 <qebab> cizra: The only one of those five that's suitable for running in screen is really irssi. Of course, I realize now that I use far more than five (forgot things like ghci, ipython, and so on) and that some of those actually are suitable for screen... ):
03:26:26 <cizra> Peaker: Actually, I agree with you on this: when all the 7-zips, TortoiseThises and TortoiseThats all register a dozen Explorer.exe context menu items, it takes me 15 minutes just to find the damn "SVN checkout" button.
03:26:35 <osfameron> Peaker: they all have different internal representations, you couldn't just use the same File/Edit menu items
03:26:40 <luite_> does using a specific instance of polymorphic functions cause an optimized version to be compiled? I see a speed difference of more than a factor 1000 between to almost equal files. The only difference is a test function that I never even use
03:26:56 <quicksilver> luite_: yes.
03:27:03 <luite_> I spent the the whole day yesterday optimizing this program, before noticing this :o
03:27:09 <quicksilver> luite_: there is a specialisation optimisation.
03:27:11 <jsn> interesting
03:27:13 <cizra> qebab: I run some command-line emulators in screen -- they must survive X restarts, so persistence.
03:27:14 <Peaker> quicksilver: I think that for each menu item - the UI developer needs to think what nouns/verbs it relates to, and try to associate the operation with those. Then, a "context menu" containing them there is fine, though I would use some other presentation of a "context menu" (not a volatile window that hides stuff temporarily in an arbitrary position near the mouse)
03:27:16 <quicksilver> you can invoke it specifically by a pragma.
03:27:29 <cizra> qebab: Then, IRC and MUD -- that's the detaching-reattaching-from-ssh-login feature.
03:28:09 <jsn> i think we should describe a collection of categories, and assign objects to the categories
03:28:13 <luite_> quicksilver: will the inline pragma cause the compiler to build a specialization anyway?
03:28:28 <jsn> when the object is selected, the arrows from the category are available
03:28:28 <Peaker> quicksilver: if there isn't any particular noun/verb it relates to, then an artificial one to represent that concept should be created
03:28:49 <jsn> you could assign objects to more than one category, i guess
03:29:05 <jsn> we can call it ... monadsoft
03:29:12 <qebab> Speaking of which, I'm actually pretty happy about irssis UI. Though I guess it might count as textual, not graphical?
03:29:24 <quicksilver> luite_: not exactly, although that could be a possible side effect.
03:29:30 <jsn> qebab: or maybe programmable?
03:29:31 <quicksilver> luite_: better to use SPECIALIZE if that's what you want.
03:29:50 <qebab> jsn: Both, I guess :)
03:29:51 <jsn> instead of a little dog, we'll have a cat
03:30:06 <quicksilver> Peaker: yes, I do agree. I just think you're firing arrows a little indiscriminantly.
03:30:08 <Peaker> qebab: irssi is not a textual interface (==CLI)
03:30:18 <dancor> does HSH have any machinisms to deal with stderr, or is there something like HSH that does
03:30:26 <quicksilver> there are a lot of UI concepts out there. They're not all shit.
03:30:39 <jsn> i think that the only good UI is Halo
03:30:45 <jsn> you only have two guns
03:30:53 <jsn> there's jump, shoot, duck, open
03:30:55 <cizra> Peaker: I'd argue it is.. You give it commands like /join #haskell, all in text
03:31:00 <qebab> oh my god
03:31:03 <jsn> you can describe all apps with those
03:31:07 <qebab> the cat just fell into the fishbowl
03:31:12 <qebab> what an idiot
03:31:16 <Peaker> quicksilver: sure (the iPhone is great) but I don't think I've ever been satisfied with a menu.. or a click-on-icon-from-list, or various other things that repeat in so many UI's
03:31:17 <qebab> bbl
03:31:33 <luite_> quicksilver: ok thanks :)
03:31:33 <jsn> qebab: hope the cat is alright
03:31:53 <cizra> qebab: hope the fishies are alright
03:31:59 <Peaker> cizra: it has CLI'ish input, and GUI'ish output.  It also has some GUI'ish input too (libreadline is in fact part CLI part GUI in general :-)
03:32:06 <jsn> for entering text, halo might seem a little slow
03:32:16 <Peaker> cizra: I haven't used irssi in a while, but it does have windows/split/etc you can switch between with the keyboard, right?
03:32:21 <jsn> but if you're good, you can probably shoot 10-15WPM
03:32:39 <cizra> Peaker: yes, it can hold multiple channels open in windows. But I haven't seen it split anything.
03:32:56 <jsn> Peaker: it can do that, yes
03:33:00 <Peaker> cizra: that's not CLI output..   telnet to port 6667 would be CLI IRC :-)
03:33:10 <dancor> cizra: it can split.  pretty buggy tho
03:33:20 <jsn> so take IRSSI
03:33:29 <jsn> i can use "jump" to move up a window
03:33:30 <Peaker> so IRSSI is definitely a GUI with a bit of CLI control too
03:33:37 <jsn> "duck" to move down a window
03:33:54 <jsn> then i can "throw 'nade" at IRC commands
03:33:54 <dancor> well there is one bug, where it's sometimes hard to unsplit and resplit
03:34:06 <jsn> while using "shoot" to type
03:34:13 <cizra> jsn: I find it much easier to type 1 to move to window 1
03:34:19 <cizra> etc
03:34:37 <jsn> cizra: come on, man, you are not even giving it a chance
03:34:59 <cizra> jsn: Just did. It doesn't recognize commands like /duck.
03:35:04 <cizra> jsn: What am I doing wrong?
03:35:17 <jsn> now, if i "switch weapons" then i can "shoot" IRC channels
03:35:21 <kig> cizra: the perfect UI for irc will make you not want to irc and then you will get more work done
03:35:39 <cizra> kig: Now that's a sharp point.
03:35:48 <mapreduce> emacs' built in IRC client, erc, looks a lot like irssi, but keeps the text entry line with the channel so you don't type things in the wrong channel.
03:36:13 <mapreduce> And it's nice to have paren-matching when you're in programming channels. :)
03:36:18 * cizra ponders if emacs has built-in bathroom emulation as well
03:36:39 <Raevel> also, it freezes emacs if  your network connection goes down \o/
03:36:41 <mapreduce> cizra: M-x battery exists, M-x bathroom doesn't.
03:37:03 <mapreduce> Raevel: I haven't noticed that.  You should be able to get out of it with C-g though.
03:37:03 <mbz_> does M-x editor exist?
03:37:15 <Raevel> mapreduce: perhaps!
03:37:20 <mapreduce> No.
03:37:26 <cizra> mbz_: *snicker*
03:37:30 <mbz_> so there is no editor in emacs.
03:37:32 <cizra> mapreduce: How do you edit files then?
03:38:10 <Raevel> i just look at my zenburn colors
03:38:33 <mapreduce> cizra: The same way I'm typing this to you now.  I use the keyboard shortcuts for insert-char.
03:38:48 <cizra> M-x insert-left-paren
03:38:55 <jsn> have any of you folks looked at the SFIO paper?
03:38:58 <cizra> -- like that?
03:39:04 <jsn> it's pretty interesting
03:39:06 <mapreduce> cizra: No, I use the shortcut for that.
03:39:10 <mapreduce> Which is the ( key.
03:39:18 <mapreduce> well, shift-9
03:39:36 <cizra> Haha, oh. It's so fun to poke fun at emacs.
03:39:48 <cizra> Gone are the times when Eight Megabytes And Constantly Swapping meant anything, though..
03:39:49 <jsn> http://www.cs.princeton.edu/courses/archive/fall97/cs595/sfio.ps
03:39:56 <cizra> and Vim is just as bloated nowadays, which sucks.
03:40:26 * dancor still isn't kwl enough to use Yi consistently
03:40:30 <jml> cizra: also, both are dwarfed by firefox, so it's no big deal
03:40:33 <mapreduce> cizra: I honestly have never noticed sloth from either editor.  Except there's a twitter client in emacs that won't go away.  I might have to actually restart emacs. :(
03:40:42 * Axman6 is in the process of trying to learn vim at the moment. doubt i'll get anywhere with it though
03:40:51 <mapreduce> A twitter client I installed, that is.
03:41:12 <Peaker> cizra: escape meta alt control shift
03:41:21 <jsn> Axman6: it's not so tough
03:41:44 <cizra> mapreduce: I sure have noticed sloth from Vim. Its startup times are fugly long. Like, penis longa, vita brevis est. Gimme my damn editor and continue loading highlight plugins in background.
03:41:45 <jsn> you need to use the escape key a lot
03:42:03 <cizra> mapreduce: Never tried more than an occasional mislaunch of emacs, though, so I can't honestly compare.
03:42:11 <Peaker> emacs has vim inside it (viper) ? :)
03:42:11 <Axman6> i'll keep going with the tutorial thing
03:42:32 <Peaker> emacs tramp/ido are awesome too
03:42:33 <cizra> Axman6: Honest suggestion: drop the tutorial
03:42:36 <mapreduce> cizra: I just popped upon a terminal window in emacs and launched vim from it; it took less than a second.
03:42:42 <qebab> tramp-mode is very good, yes
03:42:48 <cizra> Axman6: Learn the absolute basics -- how to get into and out of modes, how to save files, quit without saving.
03:42:56 <Axman6> cizra: why?
03:42:58 * dancor currently prefers the vim keymap but hates both extensions langs pretty substantially
03:43:01 <cizra> Axman6: Then, periodically, check the tutorial again to learn new things.
03:43:15 <cizra> Axman6: Simply because otherwise it's easy to get overwhelmed and lose interest.
03:43:20 <Peaker> In emacs, I type /ssh: -- I get an interactive completion list of hosts - I type part of a name, enter, password if necessary, then I get an interactive completion on a remote host
03:43:29 <Axman6> i'm quite happy using textmate though. thought i'd see what the fuss about vim was  (i hate using ctrl, so emacs is out)
03:43:32 <Peaker> then I can open remote files, run remote greps, shells, etc
03:43:42 <Peaker> all as if they were local
03:43:44 <jsn> Axman6: this could be helpful to you: http://github.com/jsnx/dots/tree/master/source/vimrc
03:43:44 <cizra> Peaker: zsh does that
03:43:54 <osfameron> dancor: yeah, I love vim for the keymappings, but hate scripting it, and despise vimball
03:44:06 <Axman6> jsn: what's that for?
03:44:10 <Peaker> cizra: lets you work with local + remote files at the same time? Treating some ssh place as a directory?
03:44:10 * dancor wonders if textmate is the 3rd most widely used editor among discriminating hackers
03:44:13 <jsn> Peaker: that's interesting
03:44:22 <jsn> Axman6: that has helpful defaults set
03:44:31 <jsn> Axman6: and has Haskell specific commands
03:44:40 <cizra> Peaker: um, no. It can just tab complete remote files.
03:44:47 <Axman6> nice. i installed the haskell mode thing too
03:44:50 <cizra> mapreduce: vim -c ':q' haskell/LambdaHack-0.1.20080413/Frequency.hs  0,13s user 0,02s system 94% cpu 0,152 total
03:45:04 <cizra> mapreduce: Seems I was mistaken about the sloth.
03:45:13 <dancor> osfameron: holy wow, had never heard of vimballs
03:45:13 <Peaker> cizra: oh, not quite the same :-) In emacs I have dired (directory editor) and all the usual features, with "tramp" (ssh, sudo, etc support) as my file system, rather than the local file system
03:45:52 <osfameron> dancor: they're supposed to be a solution to the fact that installing vim scripts required hacking various configs.  But actually they're broken pieces of crap.
03:46:10 <cizra> Peaker: sounds nice.. I wonder if mc can do that.
03:46:11 <dancor> i believe it
03:46:27 <Peaker> cizra: midnight commander?
03:46:29 <paolino> Peaker, that is nice but really should be a feature behind the editor
03:46:33 <cizra> Peaker: yep
03:46:50 <Peaker> paolino: mount points is the usual feature, but they are in the kernel and require super-user
03:46:58 <Peaker> paolino: KDE has its own feature for this purpose, and so does emacsw
03:47:02 <jsn> Axman6: it also has stuff to scrape all your passwords and send them to my Gmail
03:47:17 <cizra> Peaker: sshfs-fuse works in user privileges
03:47:17 <Peaker> paolino: I guess it would make sense to have this as a feature implemented in/above libc as an adapter
03:47:19 <paolino> fish:// protocol yes
03:47:35 <Axman6> jsn: what language are those files written in anyway?
03:47:41 <jsn> vimscript
03:47:43 <Peaker> cizra: oh right, when is "mount" generally allowed, when the device is a user-accessible one?
03:47:50 <jsn> the language of vim
03:47:59 <jsn> it's a cool language
03:48:01 <Axman6> fair enough
03:48:04 <cizra> Peaker: Not sure.. but fuse doesn't use mount, but rather fusermount
03:48:07 <jsn> it makes you evil to know it
03:48:09 <Peaker> cizra, paolino: sshfs requires a "static" mount to exist though, rather than creating/destroying one on-the-fly while you access it
03:48:16 <Peaker> cizra: what's fusermount?
03:48:24 <cizra> Peaker: The fuse mounting utility
03:48:29 <Axman6> jsn: seen http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
03:48:29 <Axman6> ?
03:48:50 <paolino> Peaker : really I don't want any program I use to develop it's own submounter
03:49:11 <jsn> Axman6: oh, wow
03:49:17 <Axman6> heh
03:49:32 <Axman6> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html for what it can do
03:50:01 <Peaker> paolino: it should be in user-space, though, no need to involve the kernel, except for ACL checking, but that implies the mounter itself is root
03:51:40 <jsn> wow
03:53:32 <Axman6> jsn: you can thank me later :P
03:53:55 <jsn> thank you, Axman6
03:54:13 <Axman6> seems pretty nice
03:54:14 <Raevel> i'm writing a parser for a simple data format using parsec, and i want to allow whitespace between tokens pretty much anywhere, how can i do this in a good way?
03:54:37 <opqdonut> yes, write a lexer first
03:54:59 <opqdonut> that is, have parsec consume a higher-level token type than Char
03:55:15 <opqdonut> or, that's one solution at least
03:56:05 <Raevel> this is a lexer actually
03:56:09 <Raevel> (sorry)
03:57:33 <Raevel> hmm perhaps i can strip most or all of the whitespace right off the bat
04:00:16 <fasta> Raevel: the problem is that you need to define "pretty much".
04:00:57 <Raevel> right
04:01:20 <fasta> Raevel: since in practice it's not everywhere, you just have to create a function which takes a parser and does it for you.
04:01:34 <fasta> Raevel: that is atleast one way of defining it.
04:03:15 <fasta> Something like spaceMe p = do spaces; x <- p; spaces;return p -- I do always forget what exactly constitutes a space in Parsec, so you probably need to change it.
04:03:22 <fasta> er return x
04:04:53 <Raevel> i think that'll do, thanks!
04:05:32 <Raevel> (space is any of " \v\f\t\r\n")
04:06:33 <quicksilver> "spaces *> p <* spaces"
04:06:41 <quicksilver> is a cute way to write that without a do block
04:06:53 <quicksilver> although you'll need to import Control.Applicative to get those operators.
04:06:59 <opqdonut> :)
04:07:12 <Raevel> oh right, just saw those in rwh
04:08:17 <gaze__> @src (!!)
04:08:18 <lambdabot> xs     !! n | n < 0 = undefined
04:08:18 <lambdabot> []     !! _         = undefined
04:08:18 <lambdabot> (x:_)  !! 0         = x
04:08:18 <lambdabot> (_:xs) !! n         = xs !! (n-1)
04:09:02 <gaze__> @src (!!!)
04:09:02 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:09:12 <quicksilver> Raevel: mnemonic: the >< points towards the bit you want the return type of.
04:09:31 <Raevel> quicksilver: yep! rwh said that also :-)
04:15:21 <quicksilver> rwh++
04:23:36 <paolino> :t (*>)
04:23:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
04:24:58 <paolino> @src Control.Applicative.(*>)
04:24:58 <lambdabot> Source not found. You untyped fool!
04:25:46 <cizra> @src You're funny.
04:25:46 <lambdabot> Source not found. :(
04:25:50 <cizra> @src hehe
04:25:50 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:26:37 <paolino> strange it's so difficult to find sources
04:26:58 <cizra> @src of Amazon
04:26:58 <lambdabot> Source not found. My brain just exploded
04:27:06 <cizra> @src of river Nile
04:27:06 <lambdabot> Source not found. Sorry.
04:27:17 <quicksilver> the src in @src is jsut a hardcoded list
04:27:23 <quicksilver> it doesn't even particularly try to tell the truth.
04:27:32 <quicksilver> however, all the lirbary source is online.
04:27:51 <cizra> @sr lirbary
04:27:51 <lambdabot> Source not found.
04:27:59 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/Control-Applicative.html#*%3E
04:34:25 <cjs> quicksilver: Have you done much with FFI?
04:36:12 <quicksilver> not really.
04:36:19 <quicksilver> I added a couple of functions to wxHaskell once
04:37:59 <cjs> Ah, you're missing out. I just wrote a Haskell interface to the MS DDEML library, callbacks, massively screwed up data types, Windows general idiocy, and all. It was amazing.
04:38:03 <cjs> Not a line of C.
04:39:12 <cjs> And you can actually do all of the C stuff in Haskell, with much better type checking and the usual easy Haskell helpfulness. I swear, I had an orgasm when I was done.
04:40:10 <quicksilver> ;)
04:40:13 <quicksilver> It is true.
04:40:20 <quicksilver> Haskell is not only the best pure functional language.
04:40:24 <quicksilver> it is also the best imperative language :)
04:40:37 <cjs> It's the best C language, too!
04:41:01 <jsn> hehe
04:42:04 <paolino> for a type Kernel s a = s -> (a,s) , it is not possible  to write the Monad instance due to the partial application of a synonym, but (>>=) f g would be uncurry g . f
04:43:10 <paolino> is it possible to reuse this definition for the boxed one State s a = State (Kernel s a) ?
04:43:26 <cjs> In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in the system), and come out having *enjoyed* myself? Praise to the Lord!
04:43:43 <blueonyx> hi
04:43:44 <quicksilver> paolino: I don't understand your question.
04:44:08 <quicksilver> paolino: (>>=) (State f) (State g) = State (uncurry g . f)
04:44:09 <quicksilver> ?
04:44:21 <paolino> uhm wrong
04:44:26 <jsn> cjs: LOLz
04:44:30 <paolino> :t (>>=)
04:44:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:44:39 <jsn> @help quote
04:44:39 <lambdabot> quote <nick>
04:44:39 <lambdabot> remember <nick> <quote>
04:44:39 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:44:50 <augustss_> @quote
04:44:50 <lambdabot> nomeata says: Haskell is basically Swiss: Small, Efficient, and it's fun to explore the higher parts.
04:44:59 <opqdonut> :D
04:45:00 <jsn> remember cjs In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in the system), and come out having *enjoyed* myself? Praise to the Lord!
04:45:02 <quicksilver> paolino: what was wrong?
04:45:09 <Axman6> jsn: @remember
04:45:18 <jsn> @remember cjs In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in the system), and come out having *enjoyed* myself? Praise to the Lord!
04:45:18 <lambdabot> I will remember.
04:45:21 <jsn> hehe
04:45:36 <jsn> @quote
04:45:36 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
04:45:45 <paolino> your (>>=) implementation is not typechecking the Monad method
04:45:47 <cjs> Wow, that's two quotes this year.
04:45:55 <jsn> @quote cjs
04:45:55 <lambdabot> cjs says: In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in
04:45:55 <lambdabot> the system), and come out having *enjoyed* myself? Praise to the Lord!
04:45:57 <cjs> Shoulda mentioned FFI, though.
04:46:14 <augustss_> @quote
04:46:15 <lambdabot> samc says: monads are hard. let's go shopping!
04:46:16 <Axman6> @quote cjs
04:46:16 <lambdabot> cjs says: In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in
04:46:16 <lambdabot> the system), and come out having *enjoyed* myself? Praise to the Lord!
04:46:24 <cjs> Maybe my old one got lost.
04:46:33 <Axman6> any idea what it was?
04:46:38 <b_jonas> I've got a question
04:46:43 <Axman6> i have one, but i don;t like it :(
04:46:50 <cjs> Oh, it's there.
04:46:53 <cjs> @quote cjs
04:46:53 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
04:46:53 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
04:47:12 <b_jonas> is it true that the (simplest) definition of (>>=) in ContT doesn't refer to the (>>=) in the underlying monad, only the lift in ContT does?
04:47:21 <Axman6> cjs: heh
04:47:34 <b_jonas> @src Monad ContT
04:47:34 <lambdabot> Source not found. :(
04:47:40 <b_jonas> @src (>>=) ContT
04:47:40 <lambdabot> Source not found. That's something I cannot allow to happen.
04:47:52 <Axman6> @src ContT (>>=)
04:47:53 <lambdabot> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
04:48:03 <paolino> quicksilver: f >>= g = uncurry g . f  is (>>=) :: Kernel s a -> (a -> Kernel s b) -> Kernel s b
04:48:04 <b_jonas> good
04:48:06 <cjs> Yeah, all of these coule be improved. I bet Perlis got a chance to edit his quotes before they were published in CACM or wherever.
04:48:12 <b_jonas> @src ContT lift
04:48:12 <lambdabot> Source not found.
04:48:25 <quicksilver> paolino: oh, right.
04:48:26 <b_jonas> it doesn't work for me...
04:48:42 <b_jonas> anyway, yeah, it seems that >>= indeed doesn't use the >>= under it
04:48:49 <b_jonas> I think that's revealing
04:49:04 <b_jonas> are any other monad transformers like that?
04:49:19 <Axman6> what are monad transofrmers anyway?
04:49:29 <ehird> Axman6: they transform monads.
04:49:35 <cjs> It lets you glue monads together.
04:49:37 <Axman6> oh right, thanks
04:49:37 <b_jonas> perhaps let me ask it like this
04:49:42 <b_jonas> um no
04:49:46 <b_jonas> I mean
04:49:48 <Axman6> heh
04:49:55 <b_jonas> if you don't define callcc only lift and return and >>=
04:50:03 <b_jonas> and a suitable run
04:50:04 <cjs> E.g., you want to use the State monad, but also the IO monad, at the same time, so you make a StateT IO.
04:50:11 <b_jonas> then you've basically got an Identity monad
04:50:20 <b_jonas> that spares the calls to the underlying >>=
04:50:47 <b_jonas> which indeed confirms what someone said eariler that you only need one >>= call per primitive action call
04:51:13 <Axman6> cjs: got a non State/IO example?
04:51:23 <Axman6> State still confuses me a little
04:51:26 <b_jonas> why doesn't it give the src of lift though?
04:51:27 <cjs> But I find monad transformers a little awkward myself; too much lifting. Maybe it's just me (and I'm quite inexperienced with them), but I have heard this complaint once or twice elsewhere, as well. I often find myself just writing a new monad when I need something like that. Then again, I need the practice anyway.
04:51:47 <cjs> Axman6: Hm, I was going to say State and Writer....
04:52:00 <ivanm> b_jonas: isn't lift dependent on the monad definition?
04:52:02 <ivanm> @src Monad
04:52:03 <lambdabot> class  Monad m  where
04:52:03 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
04:52:03 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
04:52:03 <lambdabot>     return      :: a -> m a
04:52:03 <lambdabot>     fail        :: String -> m a
04:52:05 <b_jonas> ivanm:
04:52:10 <b_jonas> @src ContT lift
04:52:10 <lambdabot> Source not found. There are some things that I just don't know.
04:52:15 <ivanm> hmmm..... maybe not then... I thought it was
04:52:15 <cjs> Axman6: you want to go to #haskell-overflow and talk about it?
04:52:16 <Axman6> i have no idea what Reader and Writer are either (please do enlighten me if you feel like it though)
04:52:17 <b_jonas> ivanm: yes, it's in the class MonadTrans
04:52:23 <Axman6> sure
04:52:32 <ivanm> b_jonas: then again, I didn't look back, just saw that one comment of yours ;-)
04:53:40 <quicksilver> paolino: you need \(State f) g -> State (uncurry (unState . g) . f)
04:54:07 <augustss_> cjs: I agree, monad transformers have many lifts.
04:55:06 <quicksilver> cjs: the typeclasses like MonadState and MonadWriter solve the lift problem.
04:55:14 <quicksilver> the worst problem is mostly in IO
04:55:18 <paolino> quicksilver: isn't there some kind of functor to help unState g without touching the Kernel (>>=) definition ?
04:55:30 <quicksilver> we'd ideally like all functions .... -> IO a
04:55:39 <quicksilver> to be MonadIO m => ..... -> m a
04:55:46 <quicksilver> then we wouldn't need all the liftIOs
04:55:51 <quicksilver> this doesn't solve the callback problem though.
04:56:15 <quicksilver> paolino: well that is using the functor, yes.
04:56:22 <quicksilver> (unState .) is (fmap unState)
04:56:26 <quicksilver> for the -> functor
04:56:28 <cjs> quicksilver: Really? I need to look this up.
04:56:32 <ehird> quicksilver: lies
04:56:34 <ehird> :t (.)
04:56:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:56:38 <ehird> ...
04:56:44 <ehird> where did caleskell go?
04:56:55 <paolino> fired
04:57:10 <Cale> hint didn't support qualified imports
04:57:19 <quicksilver> \(State f) g -> State (uncurry (fmap unState g) . f)
04:57:22 <ehird> this is unacceptable
04:57:23 <quicksilver> also works
04:57:25 <quicksilver> if you prefer
04:58:41 <paolino> quicksilver: we still have to modify bindKernel, so no physical reuse, just logical
04:59:35 <quicksilver> we can reuse it if you like
04:59:50 <b_jonas> instance MonadTrans (ContT r) where lift m = ContT (m >>=)
05:00:00 <quicksilver> State (bindKernel (unState . g) f)
05:00:07 <b_jonas> ok, great
05:00:42 <paolino> where (.) is fmap, great, thanks
05:00:54 <quicksilver> yes.
05:01:21 <quicksilver> \f g -> State (bindKernel (fmap unState g) (unState f))
05:01:28 <quicksilver> ...where I renamed f
05:01:38 <quicksilver> instead of unwrapping it in the parameter as before.
05:01:50 <quicksilver> Note that unState f is also fmap Unstate f for the identity monad
05:01:54 <quicksilver> if you like the symettry of that.
05:02:24 <Peaker> a few days ago I sparked a chat about the relationship of Functor and Category, and then I left -- was there a conclusion about any way to unify them, or perhaps which is more general, Category's (.) or Functor's fmap?
05:02:39 <Peaker> (Different kinds make the comparison more difficult, of course)
05:02:39 <b_jonas> Peaker: there's a channel log
05:02:57 <Peaker> b_jonas: indeed, but it has taken some tangents and became a long conversation regarding other things too :)
05:03:11 <Peaker> IOW, I just want to ask it again, and see if people have developed opinions since :)
05:03:15 <cnwdup> @pl (\m (k, v) -> Map.insertWith (++) k [v] m)
05:03:15 <lambdabot> (`ap` snd) . (. fst) . flip (flip . (. return) . Map.insertWith (++))
05:03:50 <paolino> quicksilver: I'm almost sure in 2009 I will get monads in my sack
05:04:14 <Peaker> @unpl (`ap` snd)
05:04:14 <lambdabot> (\ a -> a >>= \ c -> snd >>= \ b -> return (c b))
05:04:49 <cnwdup> If I want to refer from two places to the same value IORefs are much better than name based Map lookups, right?
05:08:27 <Cale> cnwdup: In the IO monad?
05:08:48 <cnwdup> cale: yes
05:09:26 <Cale> It's a little bit of a strange comparison... an IORef gives you access to one mutable cell, while a Map acts like a whole heap of named values of the same type.
05:09:46 <Axman6> @redo (\ a -> a >>= \ c -> snd >>= \ b -> return (c b))
05:09:47 <lambdabot> (\ a -> do { c <- a; b <- snd; return (c b)})
05:10:53 <Cale> Another way to do it is just to pass the value as a parameter.
05:11:06 <ski_> @pl \a p -> a p (snd p)
05:11:07 <lambdabot> (`ap` snd)
05:11:14 <cnwdup> cale: I have a data type which is stored in two other data types and I want to store the *same* data type (as it might change later). I store the name and lookup the type in a Map or I could store the IORef. I feel strongly about the Map approach being wrong, but I wanted to confirm that.
05:11:42 <Cale> Actually, I usually prefer using a Map.
05:12:01 <cnwdup> cale: But won't this add unnecessary overhead?
05:12:08 <Cale> But I'm not sure what the first part of what you said actually means.
05:13:20 <cnwdup> cale: A parser generates a set of actual values and a set of functions (which will later be forked) which return that value parsed. The parsed value might change later and I want the thread still return the same value, not the originially parsed one. Is this clearer?
05:14:30 <cnwdup> "thread returning" might be confusin as well, it's updating a MVar constantly.
05:14:32 <Cale> Er...
05:14:46 <Cale> The functions always return the value which was parsed?
05:14:55 <Cale> (in that case, why are they functions?)
05:15:03 <cnwdup> Nope. The value which might later be changed.
05:16:13 <cnwdup> Because they're updating a IORef and then telling the main thread to update the data depending on those values.
05:16:21 <Cale> mm...
05:16:32 <Cale> I'm not so used to thinking in terms of mutation :)
05:16:42 <Cale> (I think of a value as a constant)
05:18:01 <Cale> So your parser initially parses some value. That much is pure, right?
05:18:21 <Cale> And then you stick that value into an IORef, and you have a bunch of actions which act on it?
05:19:01 <cnwdup> Mh, simpler: My X11 app is seperated in fields which get drawn seperately. I thread might tell the main thread: redraw field x. Should the thread return the name of field x which gets looked up in a map or should it return an IORef to the field (or the field itself using an IORef).
05:19:29 <cnwdup> cale: I think my first explaination was a little confusing. I hope the second one isn't any more.
05:19:44 <Cale> Why not the value directly?
05:20:07 <cnwdup> Because the main thread might change the value.
05:20:15 <Cale> ah, okay
05:20:34 <Cale> So the value itself is an IORef?
05:21:03 <Cale> If you have a Map, it's a constant.
05:21:33 <Cale> When you do an update in a Data.Map, you get a new Data.Map (which happens to share all but O(log n) of its structure with the original)
05:21:34 <cnwdup> Well I could update the value of a certain key in a Map.
05:22:26 <Cale> Okay, I think I see what you mean.
05:22:44 <ski_> if you won't need to collectively get access to all the mutables, i'd think using references would be simpler
05:22:45 <Cale> Either should work out okay. The Data.Map might be more convenient for some things.
05:23:13 <Cale> As ski_ says, if something needs to access all the elements, the Data.Map gives you a convenient way to pass them all around.
05:23:21 <cnwdup> But wouldn't the lookup add overhead which wouldn't be added if I'd use a IORef?
05:23:31 <Cale> It's only a negligible amount.
05:23:38 <Cale> O(log n)
05:23:55 <cnwdup> Okay. Thanks you, guys.
05:24:05 <Cale> So do what's most convenient for you.
05:28:15 <ivanm> has anyone managed to build pandoc with 6.10.1?
05:29:42 <chrisdone> > (a <*> b) <*> c
05:29:43 <lambdabot>   Couldn't match expected type `f (a1 -> a -> b)'
05:29:50 <chrisdone> > a <*> (b <*> c)
05:29:52 <lambdabot>   Couldn't match expected type `f (a -> b)'
05:30:27 <chrisdone> > (id <$> a) <*> b
05:30:28 <lambdabot>   Couldn't match expected type `f (a -> b)'
05:30:37 <ski_> ?
05:30:50 <chrisdone> :t (<*>)
05:30:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:33:55 <chrisdone> :t ((id <$> undefined) <*>)
05:33:56 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b
05:37:38 <cjs> Oh, brilliant!
05:38:05 <cjs> Next time I need to do some glue between Ruby and C, I just realized, I can write it all in Haskell.
05:39:53 <athos> hi
05:41:38 <Axman6> o/
05:49:56 <cnwdup> @pl (\f (x, y) z -> f x y z)
05:49:57 <lambdabot> (`ap` snd) . (. fst)
05:50:42 <orbitz> :t ap
05:50:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:52:00 <BeelsebobWork> cnwdup: curry?
05:52:24 <cnwdup> beelsebobwork: My function has three arguments
05:52:38 <BeelsebobWork> > let f (a,b) c = a + b + c in (curry f) 5 6 7
05:52:39 <lambdabot>   18
05:52:50 <BeelsebobWork> no it doesn't
05:52:52 <BeelsebobWork> it has one argument
05:52:54 <BeelsebobWork> it's a tuple
05:53:01 <BeelsebobWork> and it returns a function
05:53:53 <cnwdup> beelsebobwork: Thanks. That's working. (-:
05:59:40 <cnwdup> @pl (\f (x, y) -> (x, f y))
05:59:40 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
05:59:49 <ozy`> Axman6: you still around? I don't use the buffer controls much... I put everything in tabs
06:00:01 <Axman6> fair enough
06:00:01 <BeelsebobWork> cnwdup: second?
06:00:02 <ozy`> :tabe, :tabnew, ^WT
06:00:03 <BeelsebobWork> or fmap
06:00:12 <Axman6> yeah, i was going to say fmap
06:00:15 <BeelsebobWork> > second (+1) (1,2)
06:00:16 <lambdabot>   (1,3)
06:00:21 <BeelsebobWork> > fmap (+1) (1,2)
06:00:22 <Axman6> > fmap (+1) (2,3)
06:00:23 <lambdabot>   (1,3)
06:00:24 <lambdabot>   (2,4)
06:00:29 <Axman6> og ffs BeelsebobWork!
06:00:31 <Axman6> oh even
06:00:32 <BeelsebobWork> haha
06:00:39 <BeelsebobWork> note -- second is slighly more lazy than fmap
06:00:43 <BeelsebobWork> > second (+1) undefined
06:00:44 <lambdabot>   (* Exception: Prelude.undefined
06:00:49 <BeelsebobWork> > fmap (+1) undefined
06:00:49 <cnwdup> beelsebobwork: thanks again. A little more help from you and my line of code will fit in one line. ^^
06:00:50 <lambdabot>       No instance for (Show (f a))
06:00:50 <lambdabot>        arising from a use of `show' at <in...
06:01:05 <Axman6> heh
06:01:05 <BeelsebobWork> cnwdup: :)
06:01:16 <BeelsebobWork> > fmap (+1) undefined :: (a,b)
06:01:17 <lambdabot>       Could not deduce (Num b) from the context ()
06:01:17 <lambdabot>        arising from the li...
06:01:20 <BeelsebobWork> > fmap (+1) undefined :: (a,Int)
06:01:21 <lambdabot>   * Exception: Prelude.undefined
06:01:29 <BeelsebobWork> note -- second produced the tuple
06:01:31 <BeelsebobWork> fmap didn't
06:04:14 <BONUS> does second use lazy patterns internally
06:04:24 <BeelsebobWork> I think it just uses fst and snd
06:04:26 <BeelsebobWork> @src second
06:04:26 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:04:43 <BeelsebobWork> @src ((->) a) second
06:04:43 <lambdabot> Source not found. Sorry.
06:04:44 <BONUS> ah it does
06:04:46 <BONUS> second f = arr swap >>> first f >>> arr swap
06:04:47 <BONUS> 			where	swap ~(x,y) = (y,x)
06:04:59 <BeelsebobWork> ah, okay
06:05:03 <BeelsebobWork> fmap isn't allowed to do it
06:05:05 <Badger> arr
06:05:07 <Badger> heh
06:05:11 <BeelsebobWork> because it would break the whole fmap id x = x thing
06:05:15 <BONUS> yeah
06:05:38 <BeelsebobWork> although I think that's rather open to interpretation
06:05:51 <cnwdup> @pl (map (second (:[])) $ concat $ map snd)
06:05:51 <lambdabot> map (second return) (join (map snd))
06:05:59 <BeelsebobWork> _|_ after all can be *anything* in reality
06:06:01 <cnwdup> Sweet. ^^
06:06:12 <BeelsebobWork> so you could argue that _|_ *does* equal (_|_,_|_)
06:06:26 <cnwdup> @src join
06:06:26 <lambdabot> join x =  x >>= id
06:06:55 <Axman6> :t snd
06:06:56 <lambdabot> forall a b. (a, b) -> b
06:06:58 <Axman6> :t  join snd
06:06:59 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a1, b) -> a
06:06:59 <lambdabot>     Probable cause: `snd' is applied to too many arguments
06:06:59 <lambdabot>     In the first argument of `join', namely `snd'
06:07:07 <Peaker> BeelsebobWork: only because (,) has just one data constructor?
06:07:12 <Axman6> :t  join (map snd)
06:07:14 <lambdabot>     Couldn't match expected type `(->) [(a, b)]'
06:07:14 <lambdabot>            against inferred type `[]'
06:07:14 <lambdabot>     Probable cause: `map' is applied to too many arguments
06:07:15 <BeelsebobWork> Peaker: yeh
06:07:19 <cnwdup> :t join
06:07:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:07:24 <BeelsebobWork> cnwdup: in all honesty -- I'd say that that your input was better than its output
06:07:36 <Peaker> @src (,)
06:07:36 <lambdabot> Source not found. Take a stress pill and think things over.
06:08:17 <cnwdup> beelsebobwork: I still think I could use standard functions to make it both more readable and shorter. Or at least I hope so.
06:08:37 <BeelsebobWork> cnwdup: possibly -- but not the way it suggested
06:12:11 <lilac> @type (map (second (:[])) $ concat $ map snd)
06:12:13 <lambdabot>     Couldn't match expected type `[[a]]'
06:12:13 <lambdabot>            against inferred type `[(a1, b)] -> [b]'
06:12:13 <lambdabot>     In the second argument of `($)', namely `map snd'
06:12:56 <lilac> @type (map (second (:[])) . concat . map snd)
06:12:58 <lambdabot> forall b d a. [(a, [(d, b)])] -> [(d, [b])]
06:13:22 <cnwdup> :t concat $ map (second (:[]) . snd)
06:13:24 <lambdabot>     Couldn't match expected type `[[a]]'
06:13:24 <lambdabot>            against inferred type `[(a1, (d, b))] -> [(d, [b])]'
06:13:24 <lambdabot>     In the second argument of `($)', namely
06:15:26 <lilac> @type (>>= ((second (:[]) <$>) . snd))
06:15:27 <lambdabot> forall b d (f :: * -> *) a. (Monad f, Functor f) => f (a, f (d, b)) -> f (d, [b])
06:16:34 <BeelsebobWork> @type fmap (second (`mappend` mempty)) . concat . fmap snd
06:16:35 <lambdabot> forall b d a. (Monoid b) => [(a, [(d, b)])] -> [(d, b)]
06:16:40 <BeelsebobWork> oh, concat
06:16:47 <Peaker> BeelsebobWork: if that equivalence is established, then newtype is no longer necessary and a bunch of stuff become simpler...
06:16:49 <BeelsebobWork> @type fmap (second (`mappend` mempty)) . (>>=) . fmap snd
06:16:50 <lambdabot> forall d b a b1. (Monad ((,) d), Monoid b) => (d, (a, b1)) -> (b1 -> (d, b)) -> (d, b)
06:16:53 <Peaker> BeelsebobWork: (I think)
06:17:07 <BeelsebobWork> Peaker: hmm? I don't follow?
06:17:25 <BeelsebobWork> Peaker: incidentally -- conal was saying he thinks the famous "joinE" bug will be gone by tonight
06:17:25 <lilac> @type (>>= (snd.((fmap.fmap.fmap) return)))
06:17:26 <lambdabot> forall a (f :: * -> *) a1 (f1 :: * -> *) (m :: * -> *). (Monad f, Monad m, Functor f1, Functor f) => f (a, f (f1 a1)) -> f (f1 (m a1))
06:17:39 <BeelsebobWork> hehe, good point lilac
06:17:44 <Peaker> BeelsebobWork: if  _|_ == SingleDataConstructor _|_ _|_ ...  (N args to constructor), then  data == newtype ?
06:17:59 <BeelsebobWork> Peaker: oh, yeh, fair point
06:18:16 <Peaker> BeelsebobWork: cool. I wonder if conal plans to put in my reactive-glut patch (allowing access to keydown/keyup events)
06:18:23 <BeelsebobWork> but no, I don't think that makes newtype useless
06:18:26 <quicksilver> Peaker: technically no.
06:18:32 <BeelsebobWork> I think it just says that (,) shouldn't be defined as data
06:18:34 <BeelsebobWork> but as newtype
06:18:36 <quicksilver> Peaker: newtype is different from strict data.
06:18:51 <BeelsebobWork> well, a varient on newtype
06:18:57 <BeelsebobWork> that allows two argument constructors
06:19:16 <quicksilver> even on one argumetn, there is a subtle difference between newtype and strict data.
06:19:33 <Peaker> quicksilver: only because there are two distinct bottoms, though, no?
06:19:38 <quicksilver> no.
06:19:39 <Peaker> quicksilver: (the external and internal bottoms)
06:19:47 <quicksilver> there are not two distinct bottoms, with a strict data.
06:19:54 <pejo> What is the difference between an internal and external bottom?
06:19:55 <Saizan> quicksilver: newtype is the same as "lazy" data, i.e. where all the pattern matches are irrefutable
06:20:04 <xenoterracide> does ghc support unicode?
06:20:22 <quicksilver> Saizan: yes
06:20:24 <quicksilver> xenoterracide: yes.
06:20:33 <Peaker> Saizan: so if I use data with strict fields and only irrefutable pattern matches, it has the same effect as newtype?
06:20:51 <jsn> xenoterracide: well, yes
06:20:58 <jsn> xenoterracide: haskell supports unicode
06:21:10 <jsn> xenoterracide: if you want to work with UTF8, use utf8-string
06:21:17 <xenoterracide> ok
06:21:21 <b_jonas> that doesn't depend on the language, it's a library thing
06:21:40 <quicksilver> ghc supports UTF8 .hs files.
06:21:42 <Saizan> Peaker: without strict fields
06:22:02 <lilac> @type \a -> (fmap.fmap.fmap.fmap) pure a >>= snd
06:22:03 <quicksilver> Saizan: no, you need strict fields otherwise `seq` can tell them apart.
06:22:04 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (f2 :: * -> *) a1. (Monad f, Applicative f2, Functor f1, Functor f) => f (a1, f (f1 a)) -> f (f1 (f2 a))
06:22:08 <lilac> @pl \a -> (fmap.fmap.fmap.fmap) pure a >>= snd
06:22:09 <lambdabot> (snd =<<) . fmap (fmap (fmap (fmap pure)))
06:22:14 <xenoterracide> guess I was just noting Unicode support for text I/O. on http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
06:22:14 <quicksilver> Saizan: you need strict fields *and* irrefutable patterns.
06:22:29 <Peaker> Saizan: if I use it without strict fields, don't I get an added bottom?
06:22:50 <lilac> @type (>>= snd) . (fmap.fmap.fmap.fmap) pure
06:22:51 <lambdabot> forall a (f :: * -> *) a1 (f1 :: * -> *) (f2 :: * -> *). (Applicative f2, Functor f1, Functor f, Monad f) => f (a, f (f1 a1)) -> f (f1 (f2 a1))
06:22:56 <quicksilver> xenoterracide: that just refers to the standard library (putStrLn and friends) not using a good encoding.
06:23:02 <Saizan> quicksilver: but with strict fields if i have foo ~(Bar x y) = x, foo (Bar 1 undefined) == ?
06:23:11 <xenoterracide> quicksilver: ah
06:23:20 * xenoterracide is new here, obviously ;)
06:23:24 <lilac> @type (>>= snd) . (fmap.fmap.fmap.fmap) pure :: [(a, [(b, c)])] -> [(b, [c])]
06:23:25 <lambdabot> forall a b c. [(a, [(b, c)])] -> [(b, [c])]
06:24:57 * Saizan tries it at home
06:26:10 <dcoutts> @yarr!
06:26:10 <lambdabot> What be a priate's favourite cheese?
06:26:10 <lambdabot> Yarrlsburg!
06:26:39 * dcoutts notes that hackage is now enforcing cabal-version accuracy better
06:27:43 <Saizan> Peaker: so, for datas with a single field i think irrefutable patterns+strict field has the same semantics of newtype
06:28:09 <dcoutts> Saizan: that sounds right
06:28:18 <quicksilver> althouhg of course there's no way in the language to enforce "this thing should only be matched irrefutably"
06:28:33 <Peaker> quicksilver: sure there is, with a newtype :)
06:28:33 <quicksilver> and until there is a way to do that, you can't really expect compilers to optimise it the way you hope they will.
06:28:42 <quicksilver> Peaker: well, yeah ;)
06:32:42 <Saizan> fro multiple fields i think the nicest semantic is given by just requiring irrefutable patterns, and limiting seq somehow, but it probably can't be implemented efficently
06:33:22 <dcoutts> Saizan: I want unlifted types
06:34:22 <Saizan> dcoutts: those are with (_|_,_|_) behaving like current _|_ or vice versa?
06:34:42 <dcoutts> Saizan: no, ones that have no _|_ at all! :-)
06:35:27 <dcoutts> so no general recursion in that type, no way of constructing a _|_ value of that type
06:35:31 <dcoutts> total type
06:37:29 <Saizan> is it possible to introduce those as an extension to a language like haskell?
06:38:08 <quicksilver> well, GHC has unboxed types behind the scenes.
06:38:13 <Saizan> i've only seen the opposite, starting with a total language and adding a non-termination monad
06:38:30 <quicksilver> Int# can't contain _|_ I don't think?
06:40:30 <Saizan> can you return an Int# from a function?
06:41:24 <Saizan> in that case it seems that general recursion is allowed but they are just strictly evaluatede
06:42:41 <Saizan> i'm not sure if it makes sense to disallow general recursion for some types
06:43:12 <vixey> what do you mean?
06:43:28 <vixey> general recursion in _types_?
06:45:27 <quicksilver> Saizan: I think you can't return one from a function, no.
06:45:36 <Saizan> vixey: no, assuring that all the expressions of a certain type are strongly normalizing
06:45:40 <quicksilver> Saizan: (only certain primitive functions have Int# as their return type)
06:45:52 <Saizan> vixey: in an otherwise turing complete language
06:46:01 <vixey> maybe you could introduce a new kind for that
06:46:16 <quicksilver> that is indeed what they did, yes.
06:46:23 <quicksilver> Int# :: #
06:46:27 <quicksilver> also, ? and ??
06:46:35 <quicksilver> and (#)
06:46:51 <quicksilver> :k (->)
06:46:52 <lambdabot> ?? -> ? -> *
06:50:37 <Saizan> so while (->) returns *, we could have (->#) which returns # and where general recursion is not allowed
06:52:24 <vixey> well termination checking like that is automatic yes/no kind of thing
06:52:51 <vixey> oh except would it make that bit of code strict?
06:54:34 <Saizan> why?
06:55:03 <quicksilver> Prelude GHC.Prim GHC.Base> :t \(I# i) -> i
06:55:03 <quicksilver> \(I# i) -> i :: Int -> Int#
06:55:11 <quicksilver> Saizan: I wasn't expecting that to work.
06:55:20 <quicksilver> Saizan: probably there is something I don't understand going on ;)
06:55:31 <quicksilver> maybe you're allowed to construct them, on the condition that they get inlined away.
06:55:40 <quicksilver> but you're not allowed to export a function of that type.
06:55:59 <quicksilver> JaffaCake: can you explain about unboxed values and GHC and what you're allowed to return?
06:57:53 <SamB_XP> quicksilver: why were you thinking that wasn't allowed?
06:58:15 <quicksilver> SamB_XP: because you can't put an _|_ in an unboxed Int#, I though
06:58:15 <Saizan> :k (->)
06:58:16 <lambdabot> ?? -> ? -> *
06:59:17 <Saizan> uhm, i was interpreting that kind in the wrong way
07:00:33 <SamB_XP> quicksilver: so?
07:00:33 <Saizan> ?type undefined :: Int#
07:00:34 <lambdabot> Not in scope: type constructor or class `Int#'
07:00:52 <quicksilver> Saizan: so, you shouldn't be allowed to construct an arbitrary function of type a -> Int#
07:00:59 <quicksilver> Saizan: because that might result in a thunkm.
07:01:16 <quicksilver> \(I# i) -> solve_halting_problem `seq` i
07:01:21 <Saizan> right
07:01:31 <quicksilver> sorry, that was meant to direct at SamB_XP
07:02:24 <SamB_XP> quicksilver: I don't see the issue there
07:02:40 <SamB_XP> if it just doesn't terminate, then there's no operational trouble ;-P
07:03:41 <quicksilver> SamB_XP: but there is no place to store teh thunk?
07:03:50 <quicksilver> a normal haskell function of type (a -> b) just returns a thunk of type 'b'
07:03:54 <quicksilver> we can't do that with Int#
07:04:05 <quicksilver> are you suggesting functions of type (a -> Int#) are evaluated strictly instead?
07:04:13 <SamB_XP> YES
07:04:32 <SamB_XP> yes I am :-)
07:05:00 <fasta> Does anyone know a wordpress plugin for LaTeX that works? EasyLaTeX doen't work for $$ x \mod 4 == 0, x > 1, x $$ minimal
07:05:16 <SamB_XP> anyway, it's not the function that returns the thunk -- the function would be required to return something in WHNF
07:05:47 <SamB_XP> even for lifted types
07:06:07 <quicksilver> sure, btu a lambda is WHNF
07:06:10 <quicksilver> for lifted types
07:06:21 <quicksilver> but presumably a lambda isn't WHNF if its return type is unlifted.
07:06:38 <Saizan> a lambda is, but an applied lambda isn't
07:06:48 <quicksilver> oh, sorry.
07:06:49 <quicksilver> Duh.
07:07:06 <quicksilver> anyhow, I wasn't speaking very clearly, I guess.
07:07:11 <SamB_XP> the thunk would be allocated by the caller
07:07:18 <quicksilver> the point is that function application under lazy evaluation doesn't *do* anything per se
07:07:27 <quicksilver> it just wraps up a closure/thunk.
07:07:39 <quicksilver> but with an unlifted return type you would, in fact, have to jump to the code.
07:07:47 <SamB_XP> well, the function isn't called until the result is desired
07:08:10 <quicksilver> yup; but you couldn't do that any more
07:08:14 <quicksilver> you'd have to call it immediately.
07:08:19 <SamB_XP> true
07:08:39 <Saizan> but i guess that's the point of unboxed types
07:08:41 <fasta> Hmm, I guess the problem is that amsmath is not installed.
07:08:42 <SamB_XP> probably why you aren't allowed to use unlifted types in lets ;-P
07:08:46 <Saizan> avoid allocation in inner loops
07:09:56 <SamB_XP> a better conundrum is:
07:10:22 <SamB_XP> (\I# i -> i) (error "_|_")
07:11:11 <SamB_XP> perhaps JaffaCake could enlighten us as to how THAT works ?
07:11:14 <defun> Hey, guys. I have problem when I try to compile a simple hs program. GHS says: "ghc-6.6: could not execute: gcc". I don't use gcc for compiling programs. I use solaris cc.
07:11:28 <defun> *ghc
07:11:41 <Saizan> (it feels so weird thinking that function application does something..)
07:11:57 <Botje> defun: -pgmc cc
07:12:10 <Botje> or link cc to gcc somewhere in your path
07:12:26 <defun> Botje: as in ghc -pgmc cc test.hs?
07:12:30 <Botje> think so
07:12:40 <defun> thanks, trying now.
07:12:41 <quicksilver> SamB_XP: Couldn't match kind `#' against `*'
07:12:45 <quicksilver> SamB_XP: is what it says for me.
07:12:47 <fasta> defun: also: 6.6 has a lot of bugs.
07:12:49 <quicksilver> sounds like the right error.
07:12:57 <Botje> or you can use -fasm, but that will generate sucky code for older GHCs
07:13:24 <quicksilver> SamB_XP: strangely, though it type checks.
07:13:29 <defun> Nope still same error. I'll try linking.
07:13:51 <quicksilver> SamB_XP: pretty odd to have a type-correct expression which gives a kind error when you execute it.
07:13:55 <pejo> defun, did you build your ghc, or downloaded a binary package?
07:14:22 <Saizan> quicksilver: you probably can't apply show to it
07:14:36 <quicksilver> hmm
07:14:48 <quicksilver> Saizan: no, that's not it.
07:15:03 <quicksilver> Saizan: I get the same error with (\(I# i) -> i) (error "_|_") `seq` ()
07:15:45 <Saizan> ?type seq
07:15:46 <lambdabot> forall a t. a -> t -> t
07:16:02 <defun> pejo: I downloaded the bin.
07:16:08 <Saizan> probably that a is implicitly a :: * ?
07:16:37 <quicksilver> hrm.
07:16:54 <Saizan> it makes sense operationally..
07:17:01 <lilac> ghci permits this: (\(Just (I# i)) -> i) Nothing
07:17:56 <lilac> ... but you can't do much with the result, since it's of kind #
07:18:44 <defun> The link thing fails too, with: Assembler:
07:18:44 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 34 : Syntax error
07:18:44 <defun>         Near line: "    .long   swZ_srt-(swZ_info)+0"
07:18:44 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 79 : Warning: Fill parameter ignored for executable section        "/tmp/ghc1003_0/ghc1003_0.s", line 80 : Syntax error
07:18:44 <defun>         Near line: "    .long   Main_main_srt-(Main_main_info)+0"
07:18:46 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 126 : Warning: Fill parameter ignored for executable section
07:18:47 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 127 : Syntax error
07:18:49 <defun>         Near line: "    .long   ZCMain_main_srt-(ZCMain_main_info)+0"
07:18:51 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 157 : Warning: Fill parameter ignored for executable section
07:18:54 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 164 : Warning: Fill parameter ignored for executable section
07:18:55 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 170 : Warning: Fill parameter ignored for executable section
07:18:57 <defun>         "/tmp/ghc1003_0/ghc1003_0.s", line 175 : Syntax error
07:19:00 <defun>         Near line: ".section .note.GNU-stack,"",@progbits"
07:19:01 <defun> cc: assembler failed for /tmp/ghc1003_0/ghc1003_0.s
07:19:13 <quicksilver>  I# ((\(I# i) -> i) (error "_|_"))
07:19:16 <quicksilver> gives the exception.
07:19:17 * cizra points at the topic
07:19:28 <quicksilver> defun: sounds like your ghc installation is all messed up.
07:19:29 <Axman6> defun: hpaste please :(
07:19:30 <lilac> "I# $ (\(Just (I# i)) -> i +# i) Nothing" gives an exception too
07:19:51 <defun> Axman6: what is hpaste?
07:20:05 <Axman6> ?hpaste
07:20:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:20:16 <defun> cool. thanks.
07:21:04 <lilac> so does '#' mean that all _|_s are exceptions, rather than that there are no _|_s?
07:21:08 <defun> BTW, I'm going to start rebuilding GHC, as it seems that I don't have much choice. Binary packages aren't what they used to be.
07:21:29 <ehird> Is there a template haskell tutorial? For idiots like me? :-)
07:22:34 <lilac> so, functions are codata. is there a dual which is data?
07:22:57 <pejo> defun, I dont' think many people use your configuration. Have you considered using gcc instead?
07:23:52 <defun> pejo: I'm going to try that as well.
07:24:34 <defun> If that doen't work, I'll rebuild ghc.
07:28:44 <vixey> why is -> codata?
07:29:04 <vixey> are you looking at it like a infinite product?
07:29:45 <xhanjian> @src instance Show Char
07:29:45 <lambdabot> Source not found. You untyped fool!
07:30:11 <xhanjian> @src Show Char
07:30:11 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:30:35 <Axman6> @src Char Show
07:30:35 <lambdabot> Source not found. Wrong!  You cheating scum!
07:30:48 <Axman6> if it had the sourse, that should've worked
07:31:21 <xhanjian> :(
07:31:32 <vixey> show = return
07:31:53 <quicksilver> nope.
07:32:10 <Axman6> needs to add the 's
07:32:12 <quicksilver> show = ("'" ++) . (++ "'") . return
07:32:16 <quicksilver> for simple cases
07:32:21 <quicksilver> but it does escaping and stuff
07:32:25 <quicksilver> for non basic ascii cars
07:38:03 <xhanjian> @src show
07:38:04 <lambdabot> show x = shows x ""
07:44:36 <C-Keen> does gtk2hs build with ghc 6.10.1?
07:45:14 <dcoutts> C-Keen: you need the darcs version of gtk2hs
07:45:53 <C-Keen> dcoutts: ah ok thanks
07:48:49 <vixey> "Not to speak of algebraic semantics (the interpretation of a system in itself by changing the typeset ..."
07:59:48 <saml> > magicquote "'"
07:59:49 <lambdabot>   Not in scope: `magicquote'
08:00:12 <ehird> so is there a th tutorial for idiots? :P
08:30:07 <hugo___> how do i setup an initial state for the reader monad ?
08:30:21 <hugo___> im doing lots of asks, but on an empty state :P
08:30:43 <quicksilver> you have to give it an initial state.
08:30:47 <quicksilver> You have no choice
08:30:49 <quicksilver> that's how you run it.
08:31:08 <hugo___> oh ok
08:31:56 <quicksilver> :t do { x <- asks fst; y <- asks snd; return ("x was " ++ show x ++ " and y was " ++ show y) }
08:31:57 <lambdabot> forall (t :: * -> *) a b. (MonadReader (a, b) t, Show a, Show b) => t [Char]
08:32:14 <quicksilver> but how do I actually run that?
08:32:18 <quicksilver> by giving it a value:
08:32:19 <hugo___> runreader
08:32:26 <quicksilver> do { x <- asks fst; y <- asks snd; return ("x was " ++ show x ++ " and y was " ++ show y) } (3,'a')
08:32:32 <quicksilver> > do { x <- asks fst; y <- asks snd; return ("x was " ++ show x ++ " and y was " ++ show y) } (3,'a')
08:32:33 <lambdabot>   <no location info>: parse error on input `('
08:32:51 <quicksilver> > do { x <- asks fst; y <- asks snd; return ("x was " ++ show x ++ " and y was " ++ show y) } $ (3,'a')
08:32:52 <lambdabot>   "x was 3 and y was 'a'"
08:33:02 <quicksilver> actually I don't know why that was a parse error.
08:33:36 <quicksilver> hugo___: I just used the implicit Reader, which actually *is* (r -> a)
08:33:49 <paolino> where is the source of ((->) r) instance of functor ?
08:33:53 <quicksilver> as opposed to the explicit Reader, which is a newtype over (r -> a)
08:34:15 <hugo___> hmm, i see
08:34:19 <hugo___> let me check it this works :P
08:34:54 <quicksilver> paolino: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Monad-Instances.html
08:37:07 <paolino> quicksilver: can I jump to source from there ?
08:39:16 <C-Keen> hm I have messed up my ghc-pkg database. How can I start from scratch?
08:39:23 <quicksilver> paolino: Yes.
08:39:29 <quicksilver> paolino: there is a 'source' link at the top-right.
08:39:40 <quicksilver> C-Keen: (1) go to shop (2) buy computer (3) install GHC
08:39:56 <quicksilver> :P
08:40:13 <quicksilver> C-Keen: you can try to unregister the broken packages with "ghc-pkg unregister"
08:40:18 <maltem> C-Keen: the user package conf is below ~/.ghc
08:40:32 <C-Keen> maltem: ah that's what I have been looking for thnks
08:40:44 <maltem> C-Keen: selectively unregistering could be smarter of course
08:45:03 <hugo___> hmm
08:45:31 <hugo___> does this sig for a function makes any sense: getStaticFileContents :: FilePath -> Reader StaticState (Maybe (IO BS.ByteString))
08:45:32 <hugo___> ?
08:45:47 <hugo___> is there anyway i can take out that IO over there ? :P
08:46:17 <gwern> 2'    I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to ...
08:46:17 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
08:46:23 <gwern> ... implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. In recent years, a number of program analysers like PREfix and PREfast in Microsoft have been used to check references, and give warnings if there is a risk they may be non-null. More recent programming languages like Spec# have introduced declarations for non-null references. ...
08:46:29 <gwern> ... This is the solution, which I rejected in 1965.
08:46:32 <gwern> @messages
08:46:32 <lambdabot> b4taylor said 9h 13m 8s ago: I'll add those dzen things tomorrow night and email you a patch. I spent too long mucking with archlinux today to do anything.
08:46:39 <maltem> hugo___: it should probably be at least IO (Maybe ByteString) instead of Maybe (IO ByteString), no?
08:46:54 <hugo___> i can paste the code :P
08:47:01 <hugo___> i think it is quite spargheti
08:47:48 <quicksilver> hugo___: ignoring the maybe for a moment, that is "ReaderT StaticState IO ByteString"
08:47:51 <maltem> hugo___: well this is mainly about thinking what the function should do. Maybe (IO ...) means that you have only maybe something to execute
08:47:55 <quicksilver> which gives you a better monad instance.
08:48:18 <augustss_> gwern: Is that a quote from Wirth?
08:48:19 <quicksilver> and, congrats, you've discovered monad transformers :)
08:48:27 <quicksilver> at least, you've discovered what they're for.
08:48:29 <hugo___> here it is (it is the bottom two functions) http://hpaste.org/13286
08:48:44 <chessguy> it's valid to just say 'class Foo', right?
08:48:50 <chessguy> without any functions
08:48:54 <augustss_> chessguy: yes
08:48:55 * fasta notices that there should be a priority feature on the Web, so that the one owning the website can see it :) 
08:49:00 <chessguy> is it frowned upon?
08:49:07 <augustss_> chessguy: no
08:49:30 <augustss_> chessguy: if that's what you need then that's what you do
08:50:12 <hugo___> my idea is to cache certain files in memory over a directory hierarchy
08:50:42 <maltem> hugo___: hm you haven't used IO in there
08:50:51 <hugo___> i haven't ?
08:50:59 <gwern> augustss_: no, from hoare
08:51:12 <gwern> ' *  HConf: Documentation, implement reloading, introduce some bugs' <-- yeah, that's gonna get applied :)
08:51:23 <hugo___> maltem: i can't take that IO from the data type definition :/
08:51:26 <RayNbow> hmm, what is meant with "For polymorphic recursion, Haskell 98 requires an explicit type declaration, whereas Mercury allows polymorphic recursion with type inference[...]"? ( http://www.cs.mu.oz.au/research/mercury/information/comparison_with_haskell.html )
08:51:26 <augustss_> gwern: ah, that makes sense
08:51:38 <hugo___> because im reading it from harddisk
08:51:49 <hugo___> (in StaticFile)
08:52:07 <augustss_> RayNbow: do you know what polymorphic recursion is?
08:52:43 <hugo___> my haskell skillz really need a push-up
08:52:51 <RayNbow> augustss_: I'm not sure if I know
08:53:06 <maltem> hugo___: I mean, in getStaticFileContents, you aren't actually reading anything
08:53:22 <hugo___> im not yes
08:53:49 <maltem> hugo___: so what does the IO do in its type signature then?
08:53:53 <hugo___> thats why the IO appears inside the Maybe
08:53:58 <augustss_> RayNbow: It's when a recursive function does a call to itself, but at a different type than it's defined at.  Obviously you need polymorphism for this to make any sense.
08:54:09 <hugo___> well, IO is saying that the data is read from IO
08:54:16 <hugo___> from the harddisk
08:54:19 <maltem> hugo___: ah I see now, you have an IO in data StaticFile
08:54:23 <hugo___> yes
08:54:32 <maltem> didn't spot that ;-/
08:54:51 <augustss_> RayNbow: In Haskell such functions need a type signature, in Mercury I guess they don't.  (Which either mean the Mercury type checker sometimes fails or sometimes loops.)
08:55:00 <RayNbow> ah
08:55:21 <augustss_> RayNbow: Polymorphic recursion type inferebce is undecidable.
08:55:22 <RayNbow> I can't think of any concrete (useful) examples right now though :p
08:55:34 <quicksilver> augustss_: the mercury type checker has a (tunable) recursion limit to make it terminate.
08:55:47 <quicksilver> but I thought haskell could infer some kinds of polymorphic recursion.
08:56:05 <augustss_> RayNbow: Try writing a map function for this list: data TwistList a b = Nil | Cons a (TwistList b a)
08:56:08 <quicksilver> the show a = show (a,a) type.
08:56:27 <vixey> For polymorphic recursion, Haskell 98 requires an explicit type declaration, whereas Mercury allows polymorphic recursion with type inference, using a user-tunable iteration limit to ensure termination of the type inference process
08:56:33 <quicksilver> (that isn't sensible in itself, but some variants of it are)
08:56:46 * RayNbow starts hacking...
08:57:08 <augustss_> RayNbow: it needs two function parameters
08:57:41 <RayNbow> augustss_: one for as and for bs? :)
08:57:43 <augustss_> vixey: OK, so I assume you can give a signature in Mercury for the cases where it runs out of recursion?
08:57:44 <quicksilver> "Mercury supports existentially typed functions, and existentially typed data types, whereas Haskell 98 doesn't (Hugs, ghc and other Haskell implementations support existentially typed data types, but not existentially typed functions)"
08:57:49 <augustss_> RayNbow: yes
08:57:55 <quicksilver> augustss_: do you know that that means?
08:58:02 <quicksilver> ghc doesn't support existentialy typed functions?
08:58:16 * quicksilver doesn't think that's true for what he thinks an existentially typed functio nis.
08:58:20 <quicksilver> is.
08:58:39 <augustss_> quicksilver: I guess Mercury has an exist quantifier for types.
08:58:53 * quicksilver nods
08:59:00 <augustss_> quicksilver: so you can write functions like f :: a -> (exists b . b)
08:59:28 <quicksilver> but surely you "can do" that in ghc too? I mean, it requires a slighly clumsy wrapper type
08:59:30 <augustss_> quicksilver: In Haskell you'd have to wrap up the result in a data type.
08:59:36 * quicksilver nods
08:59:48 <quicksilver> doesn't really seem like an expressibility problem to me, just a convenience issue.
08:59:53 * maltem contemplates about a -> (exists b. b) vs. exists b. a -> b vs. a -> (forall b. b)
08:59:57 <augustss_> quicksilver: exactly
09:00:13 <maltem> (which of these are equivalent?)
09:00:39 <augustss_> maltem: the two first
09:00:42 <RayNbow> ah...
09:00:55 <RayNbow> without explicit type signature
09:01:00 <RayNbow> GHC infers: mapTL :: (t -> b) -> (t -> b) -> TwistList t t -> TwistList b b
09:01:11 <RayNbow> augustss_: thanks :)
09:01:16 <augustss_> RayNbow: np
09:01:22 <maltem> augustss_: ok that makes sense... now how are the first two expressed without "exists"?
09:02:07 <maltem> augustss_: or would I need an ex. data type for that?
09:02:23 <conal> Peaker: ("<Peaker> BeelsebobWork: cool. I wonder if conal plans to put in my reactive-glut patch (allowing access to keydown/keyup events)").  See http://hackage.haskell.org/packages/archive/reactive-glut/0.1.6/doc/html/FRP-Reactive-GLUT-Adapter.html#v%3AkeyAction .
09:03:26 <BeelsebobWork> win :)
09:04:14 <crathman> Hoping someone will have sympathy for the newbie...  I can't figure out how to use random numbers...  http://hpaste.org/13287
09:04:23 <Saizan> maltem: cps-style: forall a r. a -> (forall b. b -> r) -> r
09:04:49 <fasta> conal:  do you have private messages disabled?
09:05:06 <hugo___> can i do a "do" inside a "do" ?
09:05:14 <conal> fasta: no.  i got your message a few minutes ago.
09:05:18 <Qoppa> what does the error "Occurs check: cannot construct the infinite type: a  = [a] mean?-
09:05:49 <adh0c> hi
09:05:52 <chessguy> Qoppa:  that question would be easier to answer in context
09:06:18 <maltem> Saizan: ah ok, so one has to put b on the left of a function arrow, so to say
09:06:25 <adh0c> is there any haskell book that is less confusing around the middle than real world haskell?
09:06:26 <Qoppa> i have a function remove duplicates in a list...  foldl1 (\acc x -> if x `elem` acc then acc else x:acc)
09:06:26 <chessguy> hugo___:  i think you can, but trying to do so usually means you're doing something wrong
09:06:40 <vixey> :t elem
09:06:40 <Qoppa> remdups :: (Eq a) => [a] -> [a]
09:06:40 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:07:04 <Saizan> ?type foldl1
09:07:05 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:07:33 <Saizan> Qoppa: that type means that the accumulator has to be of the same type as the list elements
09:07:39 <augustss_> maltem: you can code the existential with a data type, or cps style for forall.
09:07:44 * maltem is always unsettled by existential qualification
09:07:44 <Saizan> Qoppa: i guess you want foldl (...) []
09:07:54 <augustss_> Qoppa: nub
09:08:06 <maltem> augustss_: ok thx
09:08:15 <Qoppa> what does the error "Occurs check: cannot construct the infinite type: a -that works, thanks
09:08:32 <Qoppa> I started haskell only 2 days ago, so yeah, nub
09:08:38 <lilac> Qoppa: more generally, that message means that it's decided two types must be the same, but they can't be
09:08:47 <vixey> lol
09:08:57 <vixey> Qoppa, nub is a function in haskell
09:09:00 <vixey> > nub "fooooooo"
09:09:01 <lambdabot>   "fo"
09:09:02 <maltem> Qoppa: it means that you have a type a and a type f a (or something similar) and that you are mixing those types up
09:09:04 <Saizan> the error means that you're using something of type [a] where something of type a is expected (or viceversa)
09:09:07 <chessguy> crathman:  what are you trying to do?
09:09:15 <lilac> Qoppa: this particular form means they can't be because if they were there'd be an infinite type
09:09:15 <chessguy> @type randomRIO
09:09:16 <lambdabot> forall a. (Random a) => (a, a) -> IO a
09:09:16 <Qoppa> haha, wow go me
09:09:20 <adh0c> is there any haskell book that is less confusing around the middle than real world haskell?
09:09:28 <crathman> chessguy:  I am trying to translate sicp
09:09:33 <augustss_> Qoppa: foldl1 is rarely the function you want.  It you example, it requires acc and x to have the same type.
09:09:34 <Saizan> adh0c: around the middle?
09:09:40 <hugo___> here: http://hpaste.org/13288  how do i remove the do inside the do ?
09:09:53 <crathman> chessguy:  this is just a stripped down use of the random number generator
09:09:58 <adh0c> yeah, when rwh gets to functors it somehow gets a little bit unreadable
09:10:21 <lilac> > \x -> x == [x] -- Qoppa: this might make it more obvious what the error message is saying
09:10:21 <Saizan> hugo___: that's perfectly fine
09:10:21 <augustss_> hugo___: why do you want to remove it?  it does no harm.
09:10:22 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
09:10:22 <lambdabot>        Expect...
09:10:24 <maltem> hugo: it's ok to have it there
09:10:24 <adh0c> too much theory and very little examples
09:10:27 <chessguy> crathman:  ok, see how the type of randomRIO results in an IO a ?
09:10:29 <maltem> wow late
09:11:03 <hugo___> since this is all IO, i thought that removing the do would make it "nicer" :/
09:11:07 <crathman> chessguy:  yes...  I know it is wrapped in the IO a monad...
09:11:30 <chessguy> crathman:  ok, you need to pull it out of IO before you feed it to try_it
09:12:00 <maltem> hugo: well you *could* write, buildStaticFile path s >>= return . Just . (takeFileName path,)
09:12:05 <crathman> chessguy:  ok.  makes sense.  I just need some pointers how to do that.
09:12:17 <stepcut> ?getshapr
09:12:18 <lambdabot> shapr!!
09:12:22 <chessguy> @type do { x <- randomRIO (1, 3); return (try_it x) }
09:12:24 <lambdabot> Not in scope: `try_it'
09:12:32 <maltem> hugo: if Haskell had sections for pairs :)
09:12:36 <quicksilver> that looks like Just . takeFileName path <$> buildStaticFile path s
09:12:52 <chessguy> @type do { x <- randomRIO (1, 3); return ((+1) x) }
09:12:54 <lambdabot> forall a. (Random a, Num a) => IO a
09:13:13 <chessguy> crathman:  ^^
09:13:41 <adh0c> also, is there some function that would convert read file contents to hexadecimal?
09:13:49 <chessguy> crathman:  a shorter form would be: randomRIO (1, 3) >>= return . try_it
09:14:05 <crathman> chessguy: thanks..  will try that and see if it gets me further along
09:14:07 <vixey> (,) and flip (,)
09:14:07 <maltem> > showHex 11 ""
09:14:09 <lambdabot>   "b"
09:14:12 <chessguy> crathman:  good luck
09:15:53 <Axman6> :t curry
09:15:55 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
09:16:05 <Axman6> :t uncurry
09:16:07 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:16:21 <Axman6> :t uncurry (flip (,))
09:16:23 <lambdabot> forall b a. (a, b) -> (b, a)
09:16:54 * dcoutts notes that gwern is on noob .cabal duty
09:17:11 <dons> ?yow
09:17:11 <lambdabot> MMM-MM!!  So THIS is BIO-NEBULATION!
09:17:27 <hugo___> hehehe
09:17:33 <hugo___> lambdabot is crazy
09:17:34 <dcoutts> @yarr!
09:17:34 <lambdabot> Yeh scurvy dog...
09:17:40 <chessguy> @vixen
09:17:41 <lambdabot> tell me a joke.. I like men that makes me laugh
09:17:41 <Saizan> what did he wrote?:)
09:18:19 <dcoutts> @vixen hugo___ says you're crazy. You're not crazy are you?
09:18:19 <lambdabot> nope, i'm sane
09:18:41 <chessguy> @vixen are you sane?
09:18:42 <lambdabot> i truely am
09:18:53 <chessguy> @vixen are you sure?
09:18:53 <lambdabot> i truely am
09:19:02 <chessguy> @vixen are you insane?
09:19:03 <lambdabot> yes, i am
09:19:08 * chessguy giggles
09:19:25 <hugo___> :D
09:20:33 <hugo___> i think the Maybe stuff is really neat and clean
09:20:55 <dons> ?users
09:20:56 <lambdabot> Maximum users seen in #haskell: 581, currently: 564 (97.1%), active: 25 (4.4%)
09:21:25 <hugo___> i feel no stress in letting possible errors propagate through several modules and all... very nice good
09:26:15 <paolino> :t on
09:26:16 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:26:29 <lilac> hugo___: a MonadT in base would be nice though
09:26:34 <lilac> MaybeT rather
09:27:18 * hugo___ runs to see what it does :P
09:27:24 <augustss_> adh0c: there's also printf
09:27:55 <lilac> is there a GHC extension for tuple sections?
09:28:10 <quicksilver> nope.
09:28:18 <quicksilver> it was a deliberate omission
09:28:21 <vixey> (,) and flip (,)
09:28:29 <quicksilver> trailing tuples being considered a likely kind of typo.
09:28:31 <defun> Hi I just installed gcc, and tried to compile a program called test.hs which contained this: (main = putStrLn "G'day, world!"). I then ran ghc test.hs as user and got this error: http://hpaste.org/13289
09:28:36 <quicksilver> sorry, trailing commas.
09:28:57 <augustss_> There should be tuples sections.  I need them all the time.
09:29:23 <augustss_> There's an obvious syntax, and no ambiguity.
09:29:27 <crathman> chessguy:  I think this is what I was aiming for...  http://hpaste.org/13287
09:29:30 <quicksilver> yup.
09:29:44 <quicksilver> It's only the possible typo misinterpretation, as far as I know.
09:29:58 <quicksilver> and lord knows haskell is so bad for that anyway
09:30:06 <quicksilver> I don't really think one more will make a difference :)
09:30:14 <augustss_> quicksilver: the type argument would apply to any kind of section
09:30:18 <Saizan> defun: do you have libgmp installed?
09:30:19 <augustss_> typo
09:30:29 <chessguy> crathman:  good
09:30:48 <quicksilver> augustss_: yup, I was told that tuples were considered particularly at risk.
09:30:57 <quicksilver> augustss_: because of the 'one element per line copy paste thing'
09:31:17 <augustss_> quicksilver: I think it's nonsense.  It'll be a type error anyway.
09:31:30 <quicksilver> augustss_: I agree. I'm only repeating what I was told.
09:31:51 <maltem> honestly I think that a tuple section does look like a typo. accustomed to never seeing it I guess
09:32:29 <quicksilver> (x,) is python syntax for a 1-element tuple, I think
09:32:45 <maltem> there, I'm doing too little python ;)
09:33:07 <quicksilver> augustss_: would you also permit (x,,y) ?
09:33:40 <quicksilver> defun: your GHC installation is totally broken, I'm sorry I can't be more specific.
09:33:53 <quicksilver> perhaps a binary GHC which expects gmp in a different place to where you have it.
09:33:54 <augustss_> quicksilver: That's a separate question.  I rarely miss that, whereas section with pairs I need all the time.
09:34:12 <quicksilver> augustss_: I know it's a separate question, that's why I asked it separately :)
09:34:47 <quicksilver> the lack of tuple sections doesn't bother me too much, but it certainly seems a nice idea.
09:35:19 <maltem> defun: don't you have libgmp, or in an unusual place or something?
09:36:17 <augustss_> quicksilver: I'm more dubious about the general tuple sections.  Pairs would be good though.
09:37:18 <defun> saizan: yes. It is located in /lib/libgmp.so. I also have libgmp.a and libgmp.la and libgmp.so.3.4.2.
09:37:43 <defun> quicksilver: oh. thanks. So rebuild it is. ;)
09:38:05 <quicksilver>  /lib?
09:38:09 <quicksilver> that's a funky place for libgmp
09:38:17 <defun> where should it be?
09:38:34 <quicksilver> /usr/lib would be more expected.
09:38:45 <quicksilver> But ideally, it should be where your distribution wants it to be
09:38:55 <quicksilver> and you use your distribution's package of ghc too ;)
09:40:27 <defun> Oh. bummer. My distro seems to lack a working package of ghc. This ghc IS the distro's ghc. My distro (Solaris10 + blastwave) is quite dumb, imho.)
09:40:43 <defun> Thanks for the help.
09:41:09 <defun> I'll be back ;)
09:47:53 <hugo___> is the monads paper by philip walder worth reading ?
09:48:02 <jkff> Yes
09:48:13 <quicksilver> any paper by wadler is worth reading.
09:48:15 <quicksilver> twice.
09:48:19 <hugo___> hehe
09:48:20 <hugo___> okey
09:48:21 <hugo___> thanks
09:48:51 <jkff> Despite being the first paper on monads in programming, it is one of the clearest and yet deep and less trivial ones.
09:49:51 <lilac> quicksilver: i'd want (a,,b). but i'd also want , as a standard infix operator :)
09:50:11 <lilac> data a,b = a:,b; (,) = (:,)
09:50:29 <lilac> or allow , as a constructor perhaps
09:51:10 <maltem> lilac: consequently, tuples would be handled recursively?
09:51:25 <lilac> maltem: yes. but it's a pain since it adds lots of _|_s to n-tuples
09:51:45 <lilac> plus, (a,,b) and (,)-as-binary-only are kinda at odds with each other
09:51:59 <Cale> You could perhaps have  data (,) a b = (,) a !b
09:52:19 <Cale> Or maybe (,) should be special and unlifted?
09:52:22 <lilac> Cale: that has the wrong strictness too, unless you add a () terminator
09:52:27 <Cale> yeah
09:52:40 <Cale> (you probably would want one too)
09:52:42 <lilac> but i'd be reasonably happy with data a , b = !a , !b
09:52:58 <lilac> though that would break a /lot/ of code i think
09:53:09 <Cale> I think an unlifted but lazy pair is the right thing.
09:53:14 <maltem> with data a , b = a , !b, a pair would have to be (a,(b)), where (b) is a one-tuple
09:53:37 <maltem> oh we had that above
09:53:47 <Cale> That is, we'd have _|_ = (_|_, _|_)
09:53:55 <vixey> what's wrong with what we got right now?
09:54:04 <Cale> But (_|_, b) and (a, _|_) would not be _|_
09:54:09 <vixey> > let (*) = (,) in (1 * 2 * 3 * 4)
09:54:10 <lambdabot>   (((1,2),3),4)
09:54:24 <vixey> > let (*) = (,) in ((1 *) . (2 *) . (3 *)) 4
09:54:25 <lambdabot>   (1,(2,(3,4)))
09:54:45 <vixey> just a syntax thing?
09:54:50 <Cale> I don't think (,) as it stands is actually the categorical product, and () is not really the unit for it.
09:55:06 <lilac> Cale: is that the equivalent of a multi-argument newtype constructor?
09:55:11 <Cale> lilac: yes
09:55:21 <maltem> vixey: they are discussing (a,b,c) vs. ((a,b),c) behaviour concerning bottoms
09:55:22 * lilac wonders why we don't have those in general
09:55:27 <Cale> and maybe we ought to have multi-arg newtypes
09:55:44 <vixey> why care about bottoms?
09:56:08 <Cale> Well, it does subtly affect things from time to time.
09:56:16 <hugo___> and this one: "Functional Programming with Overloading and Higher-Order Polymorphism" by Mark P Jones, is it worth reading ?
09:56:34 <hugo___> im printing them to read on commute times
09:56:46 <Cale> hugo___: That rings a bell, but I don't recall which one it is.
09:57:12 <hugo___> it is the one on monad reader
09:57:12 * Cale looks
09:57:48 <lilac> hugo___: MPJ is, I think, very well-respected. so it's likely to be worth reading :)
09:58:13 <hugo___> hmm, i just dont like those highly mathematical papers on haskell :/
09:58:38 <Cale> http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf  if it's this, it looks like a good intro
09:58:43 <hugo___> okey, thats the one
09:58:50 <hugo___> going to the print queue
09:59:49 <stepcut> whee!! I combined monads and applicative functors to make some horrible, but useful, chimera
10:00:16 <redditbot> fast string appending/concatenation in haskell
10:00:34 <stepcut> if >>= is pronounced 'bind', how is >> pronounced ?
10:00:42 <hugo___> right shift :P
10:00:48 <Valodim> "then"?
10:00:52 <stepcut> hugo___: :p
10:00:57 <Valodim> good question, I never thought about that :|
10:01:09 <hellige> "semi-colon"
10:01:13 <hugo___> its called the "sequence"
10:01:23 <hugo___> "in sequence with" or whatever
10:01:41 <stepcut> ugh, too bad sequence also means something else in Haskell already
10:01:49 <byorgey> stepcut: hm? all monads are already applicative functors.
10:02:08 <maltem> hugo: Take care regarding the date in that MPJ paper, though. The code samples do look like Haskell 98, but there may be some hidden differences
10:02:09 <stepcut> byorgey: yes, but not like this
10:02:47 <maltem> "then" is most often cited
10:03:11 <stepcut> maltem: then will work for now I guess
10:03:56 <hugo___> hmm ok
10:03:59 <hugo___> thanks maltem
10:04:00 <stepcut> maltem: or not... apparently I can not make a function named 'then'
10:04:24 <hugo___> im currently reading the "generalising monads to arrows" from john hughes
10:04:27 <hellige> stepcut: you asked for a pronunciation, not an alternative name..
10:04:33 <hellige> ;)
10:04:35 <stepcut> byorgey: I will be posting my chimera on the mailing list later -- perhaps there is a better way to achieve the same result
10:05:00 <stepcut> hellige: well, I was hoping to come up with a name based on the pronunciation
10:05:15 * stepcut opts for bind_
10:05:24 <hellige> stepcut: try "andThen"
10:05:28 <hugo___> i tried reading the "functional pearl: applicative programming with effects" but i didn't quite managed through it :/ even though i've used some applicative functors here and there...
10:05:32 <stepcut> hellige: that will work
10:06:18 <dons> woo, 'on ruby' interview about rwh and haskell, http://on-ruby.blogspot.com/2008/12/author-interview-real-world-haskell.html
10:06:18 <lambdabot> dons: You have 13 new messages. '/msg lambdabot @messages' to read them.
10:06:24 <hugo___> i like the way john hughes writes... he kind of makes it simple from the start...
10:06:39 <hellige> hugo___: take your time, be patient... some papers you might have trouble with now, but you might not have trouble in a few years.
10:07:52 <hugo___> thanks hellige
10:08:27 <hugo___> i just feel that i would like to know every bit of haskell as fast as possible, but i sense that a lot of experience will be required
10:08:57 <hellige> hugo___: yeah. i mean, go as fast as you can, but don't be discouraged when something seems incomprehensible
10:09:30 <hugo___> i have just printed 4 papers, so i can switch when i dont understand something, and hopefully come back after to understand it :)
10:10:37 <hellige> hugo___: perfect. :)
10:10:38 <hugo___> oh well, time to leave, bye ppl, thanks for the support
10:11:57 <matthewp> dons: nice interview!
10:12:14 <defun> I moved libgmp to /usr/lib and now everything works! Thanks for all your help. I'll be back if I have any more problems. This channel is very helpful.
10:13:19 <matthewp> anyone use selenium 1.0 with the selenium haskell package? Can't quite get it to work with the examples, throwing session exceptions
10:13:30 <quicksilver> defun: hurrah :)
10:16:18 <defun> Is a finite map in haskell the equivalent of a dictionary in python?
10:19:15 <quicksilver> defun: Data.Map, yes
10:19:31 <defun> thanks
10:19:52 <quicksilver> although you can get some way with a list of pairs [(a,b)]
10:20:05 <quicksilver> (a == key b== value)
10:20:10 <quicksilver> :t lookup
10:20:10 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:20:21 <quicksilver> but that is pretty slow for lists longer than a handful
10:24:15 <byorgey> @index spawnPipe
10:24:16 <lambdabot> bzzt
10:29:19 <gwern> 'So, portability, native code, high level. The same reasons Linspire used Haskell for their distro scripts.' <-- linspire wound up scrapping their haskel lstuff, didn't they?
10:31:45 <chessguy> @hoogle spawnPipe
10:31:45 <lambdabot> No results found
10:31:47 <alexsuraci> Any ideas why I'd be getting this output when trying to compile? http://gist.github.com/39412
10:32:31 <augustss_> gwern: the Haskell guys at Linspire left and did a startup.
10:34:02 <thedward> alexsuraci: ghc --make -o todo todo.hs
10:34:06 <paolino> ::t ap
10:34:09 <paolino> :t ap
10:34:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:34:45 <Saizan_> alexsuraci: use --make
10:36:12 <paolino> @pl \x -> g (f x) x
10:36:12 <lambdabot> g =<< f
10:36:36 <alexsuraci> Oh, there we go. Thanks.
10:37:18 <quicksilver> paolino: @pl knows about the reader monad :)
10:37:40 <paolino> eating my tail
10:42:23 <CakeProphet> is there an easier way to get cabal than by manually compiling all these dependencies?
10:42:54 <paolino> should do with HTTP and zlib only
10:43:04 <CakeProphet> HTTP need network and Parsec
10:43:17 <CakeProphet> Parsec needs bytestring and mtl
10:43:30 <byorgey> CakeProphet: I think the cabal-install tarball has a 'bootstrap' script
10:43:38 <byorgey> just run that, and it will download all the dependencies for you
10:44:02 <byorgey> CakeProphet: oh, wait, how did you install ghc?
10:44:10 <byorgey> sounds like you don't have the extralibs
10:44:23 <CakeProphet> I used apt-get to install ghc
10:45:27 <byorgey> apt-get install ghc6?
10:45:56 <CakeProphet> I just typed ghc, which gave me that, yes.
10:46:01 <byorgey> strange, I thought that installed the extralibs
10:46:05 <quicksilver> nope
10:46:10 <quicksilver> they're all separate pacakges under apt
10:46:14 <CakeProphet> I'm running the  bootstrap right now
10:46:14 <quicksilver> apt-get search ghc6
10:46:18 <byorgey> ah, right
10:46:19 <quicksilver> should show you a bunch of them
10:46:23 <CakeProphet> alright. I'll get those too
10:46:32 <paolino> apt-cache
10:46:45 <byorgey> CakeProphet: so you'll want to do things like  apt-get install libghc6-parsec, libghc6-mtl, etc.
10:47:16 <byorgey> you might need to install those before running the bootstrap
10:47:24 <CakeProphet> ah.
10:47:51 <shapr> stepcut: ?
10:53:33 <BMeph> Damn, I just got up an hour or so ago, and saw Wadler's "unsafe"-dump blog entry. I'm glad my coffee was away from my face! ;)
10:55:04 <dons> matthewp: thanks!
10:56:38 <dons> ?users
10:56:39 <lambdabot> Maximum users seen in #haskell: 581, currently: 561 (96.6%), active: 18 (3.2%)
10:57:40 <ikkebr> bah
10:57:44 <ikkebr> now 19 active
10:57:46 <ikkebr> :p
10:58:22 <BMeph> ikkebr: I'm drinking a latte with an espresso shot - I can be hyperactive if you need it... ;p
10:59:38 <ikkebr> too hot to drink that here :|
10:59:56 <ikkebr> almost 38C
11:00:17 <redditbot> On Ruby: Author Interview: Real World Haskell
11:00:28 <CakeProphet> > putStrLn intercalate " " (take 5 (repeat "<3"))
11:00:29 <lambdabot>   Couldn't match expected type `String'
11:00:39 <BMeph> ikkebr: Holy HE-double-Hockey Sticks! Where are you, Darwin? ;)
11:01:02 <CakeProphet> ... :(
11:01:12 <vixey> > intercalate " " (take 5 (repeat "<3"))
11:01:13 <lambdabot>   "<3 <3 <3 <3 <3"
11:01:23 <BMeph> > putStrLn . intercalate " " (take 5 (repeat "<3"))
11:01:24 <CakeProphet> ah
11:01:25 <lambdabot>   Couldn't match expected type `a -> String'
11:01:30 <quicksilver> dons: nice artical.
11:01:34 <CakeProphet> doesn't want an IO ()
11:01:38 <quicksilver> nice article, too.
11:01:45 <BMeph> > putStrLn . intercalate " " . take 5 . repeat $ "<3"
11:01:47 <lambdabot>   * Exception: "<IO ()>"
11:02:09 <BMeph> >  intercalate " " . take 5 . repeat $ "<3"
11:02:10 <lambdabot>   "<3 <3 <3 <3 <3"
11:02:35 <byorgey> take n . repeat === replicate n
11:02:51 <CakeProphet> ah. Forgot about replicate.
11:03:43 <CakeProphet> hmmm... the bootstrap file complains about not finding zlib.h
11:03:48 <CakeProphet> and then fails to compile
11:04:01 <quicksilver> you need zlib-dev then
11:04:04 <quicksilver> or whatever it's called.
11:05:03 <CakeProphet> zliblg-dev I think is the one I want
11:05:08 <blackh> zlib1g-dev
11:06:18 * CakeProphet gives thanks for apt-get.
11:06:32 <porges> (data|type) families make head sore
11:07:29 <chessguy> alexsuraci:  dons or dcoutts_  might know something about the state of Bytestring that might help
11:07:47 <CakeProphet> ew... I was root when I ran the bootstrap so it put everything in /root/.cabal
11:07:54 <gaze__> I'm having trouble understanding the composition operator... is a (b (c d)) the same as d.c.b.a?
11:07:57 <CakeProphet> do you think it would be safe to mv .cabal to my home path?
11:08:21 <chessguy> @pl \d -> a (b (c d)))
11:08:22 <lambdabot> (line 1, column 18):
11:08:22 <lambdabot> unexpected ")"
11:08:22 <lambdabot> expecting variable, "(", operator or end of input
11:08:22 <baaba> @unpl a . b . c . d
11:08:23 <lambdabot> (\ g -> a (b (c (d g))))
11:08:32 <stepcut> shapr: getshapr was taking to long, I sent you a message via linkedin instead
11:08:37 <Saizan_> CakeProphet: you'd also have to mv .ghc and chown everything
11:08:48 <CakeProphet> ...I'll just run it again.
11:08:54 <chessguy> \d -> a (b (c d))
11:08:58 <chessguy> @pl \d -> a (b (c d))
11:08:58 <lambdabot> a . b . c
11:09:15 <gaze__> ahh! okay
11:09:18 <gaze__> thanks
11:09:19 <chessguy> gaze__:  ^^
11:09:26 <baaba> it's the other way when compared with mathematics
11:09:52 <chessguy> i always thought mathematics was backwards in that notation, personally
11:10:00 <baaba> *shrug*
11:10:07 <baaba> i have no preference really :P
11:10:21 <porges> it's the same as mathematics?
11:10:45 <chessguy> @src (.)
11:10:46 <lambdabot> (f . g) x = f (g x)
11:10:59 <porges> ... isn't it
11:11:04 <porges> have I been living a lie
11:11:10 <baaba> no in math generally it's the reverse
11:11:19 <baaba> the one on the left is applied first
11:11:24 <Saizan_> ..no
11:11:40 <porges> (g ∘ f)(x) = g(f(x))
11:11:46 <porges> it's the same
11:14:25 <ski_> (chessguy : .. or `->' is backwards)
11:14:50 <CakeProphet> > let ph = negate.log
11:14:51 <lambdabot>   <no location info>: parse error on input `;'
11:15:17 <ski_> > let ph = negate.log in ph 8
11:15:18 <lambdabot>   -2.0794415416798357
11:15:53 <porges> CakeProphet: if you want lambdabot to define a function, use @let
11:16:01 <CakeProphet> ah.
11:16:11 <dons> also on reddit, enjoy the haskell press! http://www.reddit.com/r/programming/comments/7lcqw/on_ruby_interviews_real_world_haskell_team/
11:16:16 <porges> @let ph = negate . log
11:16:18 <lambdabot>  Defined.
11:16:21 <porges> > ph 8
11:16:23 <lambdabot>   -2.0794415416798357
11:18:07 <ski_> > (do x <- ph; (**) (1 - x)) 8
11:18:09 <lambdabot>   8086.781574506924
11:20:00 <augustss_> > ph 1e-10
11:20:02 <lambdabot>   Not in scope: `ph'
11:20:37 <ski_> @djinn Maybe (Maybe a -> a) -> Maybe a
11:20:37 <lambdabot> f a =
11:20:37 <lambdabot>     case a of
11:20:37 <lambdabot>     Nothing -> Nothing
11:20:37 <lambdabot>     Just b -> Just (b (Just (b Nothing)))
11:21:01 <ski_> @djinn Not (Not a -> a) -> Not a
11:21:02 <lambdabot> f a b = a (\ _ -> b)
11:21:11 <CakeProphet> @let molarityH = (10^).negate
11:21:12 <lambdabot>  Defined.
11:21:25 <augustss_> bizarre
11:21:25 <augustss_> :)
11:21:28 <sbahra> CakeProphet, what is that?
11:21:37 <sbahra> I mean, what do you use that for?
11:21:49 <sbahra> Or even better, in what context do you use that? ;-p
11:21:54 <CakeProphet> > ph.molarityH 8
11:21:55 <lambdabot>   Not in scope: `ph'
11:22:00 <CakeProphet> well
11:22:08 <CakeProphet> it's supposed to be the reverse of finding ph
11:22:14 <BMeph> sbahra: chemistry, maybe? :)
11:22:23 <augustss_> @let ph = negate . logBase 10
11:22:25 <lambdabot>  Defined.
11:22:34 <augustss_> > ph 1e-10
11:22:35 <lambdabot>   10.0
11:22:45 <CakeProphet> yeah
11:22:54 <BMeph> > pH 8
11:22:56 <lambdabot>   -2.0794415416798357
11:22:57 <ski_> @type \f -> fix $ \fa -> ($ fa) `fmap` f
11:22:58 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
11:23:02 <porges> does lambdabot expire definitions?
11:23:18 <CakeProphet> > ph.molarityH 8
11:23:19 <lambdabot>       No instance for (Num (a -> b))
11:23:19 <lambdabot>        arising from a use of `molarityH'...
11:23:21 <ski_> porges : with `@undefine', yes
11:23:40 <CakeProphet> ...I still can't read Haskell error messages.
11:23:52 <gwern> they're hard to read, admittedly
11:24:01 <ski_> > (ph . molarityH) 8
11:24:02 <lambdabot>   * Exception: Negative exponent
11:24:08 <porges> that one says (a -> b) isn't an instance of Num
11:24:10 <Vulpyne> I'm guessing this isn't really possible, but... In interfacing C with Haskell by creating a Haskell shared object, is it possible for that Haskell object to export symbols that look like C structures?
11:24:13 <porges> ie. functions aren't numbers
11:24:28 <CakeProphet> but what is (a -> b)
11:24:40 <porges> a function from any type 'a' to any different type 'b'
11:24:41 <sbahra> I see
11:24:46 <CakeProphet> oh right.
11:24:52 <sbahra> thanks
11:24:54 <porges> or 'b' could be 'a'
11:24:55 * ski_ wants a `reify' ..
11:25:04 <CakeProphet> -nod- right.
11:25:13 <CakeProphet> ah okay... functions aren't numbers.
11:25:29 <BMeph> Vulpyne: Export symbols to where? :)
11:25:44 <porges> the error you're getting is because function application is higher precedence than any operator
11:25:48 <porges> so
11:25:54 <augustss_> @let molarityH = (10**).negate
11:25:55 <lambdabot>  <local>:4:0:
11:25:55 <lambdabot>      Multiple declarations of `L.molarityH'
11:25:55 <lambdabot>      Declared at: <...
11:26:03 <CakeProphet> ah okay
11:26:06 <porges> > ph . molarityH 8
11:26:07 <lambdabot>       No instance for (Num (a -> b))
11:26:07 <lambdabot>        arising from a use of `molarityH'...
11:26:09 <CakeProphet> it's applying before it composes.
11:26:09 <augustss_> @undefine MolarityH
11:26:09 <Vulpyne> bmeph: Well, you can do "foreign export ccall ..." to export a function, such that you can dlopen the Haskell code and call that function.
11:26:14 <porges> CakeProphet: yup
11:26:18 <ski_> @help undefine
11:26:19 <lambdabot> undefine. Reset evaluator local bindings
11:26:19 <augustss_> @let molarityH = (10**).negate
11:26:21 <lambdabot>  Defined.
11:26:22 <Vulpyne> BMeph: I want to also be able to export data.
11:26:42 <orbitz> ph . molarityH $ u would work too
11:26:42 <augustss_> > ph . molarityH $ 8
11:26:43 <lambdabot>   Not in scope: `ph'
11:26:53 <Vulpyne> The reason for this, is I want to use Haskell modules for another project, instead of the C modules it usually uses, and it expects to find symbols that define what functions are exported and such.
11:27:04 <augustss_> @let ph = negate . logBase 10
11:27:05 <lambdabot>  Defined.
11:27:12 <augustss_> > ph . molarityH $ 8
11:27:13 <lambdabot>   8.0
11:27:29 <CakeProphet> there we go
11:27:30 <porges> cabal install chemistry
11:28:09 <augustss_> logBase and (**) are the functions that go together
11:28:09 <ski_> @check \x -> ph . molarityH $ x == id
11:28:11 <lambdabot>   Not in scope: `ph'Not in scope: `molarityH'
11:28:29 <augustss_> :t ph
11:28:31 <lambdabot> forall b. (Floating b) => b -> b
11:28:38 <ski_> @check \x -> L.ph . L.molarityH $ x == id
11:28:39 <lambdabot>       Failed to load interface for `L':
11:28:40 <lambdabot>        Use -v to see a list of the fi...
11:28:42 <Vulpyne> BMeph: There's functions in Haskell for doing things the other way around (accessing C structs from Haskell), but I don't see how you could export a data structure from the Haskell, which looks like a C struct to the C code.
11:28:43 <ski_> bah!
11:28:48 <porges> lambdabot hates you
11:28:53 <ski_> @botsmack
11:28:53 <lambdabot> :)
11:28:53 <lunabot>  :)
11:29:12 <porges> Vulpyne: what about writing a C struct and then filling it from Haskell
11:29:29 <Vulpyne> porges: Yeah, there are nasty ways of getting around it... But they are nasty.
11:29:34 <CakeProphet> @let `id = ph . molarityH
11:29:35 <lambdabot>   Parse error
11:29:43 <CakeProphet> @let id` = ph . molarityH
11:29:43 <lambdabot>   Parse error
11:29:45 <CakeProphet> :D
11:29:55 <CakeProphet> oh
11:29:56 <Vulpyne> It's static data I want to export mainly, anyhow, so I could just do that from a C wrapper I link in.
11:29:59 <CakeProphet> Haskell doesn't understand `?
11:30:06 <orbitz> CakeProphet: '
11:30:06 <ski_> > '\'' == '`'
11:30:08 <lambdabot>   False
11:30:19 <CakeProphet> @let id' = ph . molarityH
11:30:20 <lambdabot>  Defined.
11:30:22 <porges> ` is used for infix functions
11:30:30 <CakeProphet> ah.
11:30:53 <porges> (a `plus` b) rather than (plus a b)
11:31:07 <porges> nicer in some contexts
11:31:21 <porges> e.g. testing list membership:
11:31:22 <CakeProphet> > map (id') [1..10]
11:31:23 <lambdabot>   [0.9999999999999998,1.9999999999999996,2.9999999999999996,3.999999999999999...
11:31:28 <porges> > 2 `elem` [0..]
11:31:29 <lambdabot>   True
11:31:49 <CakeProphet> @undefine id'
11:31:55 <CakeProphet> not an accurate name. ;)
11:32:50 <gwern> @seen dcoutts_
11:32:51 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts_ speak 1d 2h 9m 8s ago.
11:33:26 <gwern> @ask dcoutts_ what would you make of 'extensions:' in .cabals becoming a cabal check warning? since per-file pragmas enable ghci where that doesn't
11:33:27 <lambdabot> Consider it noted.
11:33:41 <ski_> > sum . map (\x -> (id' x - x) ** 2) $ [1..10]
11:33:42 <lambdabot>   Not in scope: `id''
11:34:15 <CakeProphet> wooo. I finally got cabal installed
11:34:23 <CakeProphet> I don't even remember what I was going to use it for.
11:34:30 <porges> > sum . map (\x -> (ph . molarityH $ x - x) ** 2) $ [1..10]
11:34:31 <lambdabot>   Not in scope: `ph'Not in scope: `molarityH'
11:34:46 <BMeph> CakeProphet: The name is accurate (to a degree), then floating-point numbers in between,... no-so-much. ;)
11:34:56 <BMeph> s/then/the/
11:34:56 <ski_> @pl \x -> (ph . molarityH $ x - x) ** 2
11:34:57 <lambdabot> (** 2) . ph . molarityH . const 0
11:34:58 <CakeProphet> oh right. lambdabot
11:35:03 <CakeProphet> that's why I wanted cabal.
11:35:32 <porges> which version of ghc?
11:36:10 <CakeProphet> Glasgow Haskell Compiler, Version 6.8.2, for Haskell 98,
11:36:16 <saml> > __VERSION__
11:36:17 <lambdabot>   Not in scope: `__VERSION__'
11:36:26 <BMeph> Ironic, though, that "pH" is a legitimate function name, but no one uses it... ;)
11:36:44 <ski_> @index pHd
11:36:45 <lambdabot> bzzt
11:37:07 <orbitz> @hoogle Monda []
11:37:07 <lambdabot> Did you mean: :: Monda [a] /count=20
11:37:07 <lambdabot> Prelude undefined :: a
11:37:07 <lambdabot> Data.Array.Base arrEleBottom :: a
11:37:12 <orbitz> @hoogle Monad []
11:37:12 <lambdabot> Did you mean: :: Monad [a] /count=20
11:37:12 <lambdabot> Prelude undefined :: a
11:37:12 <lambdabot> Data.Array.Base arrEleBottom :: a
11:38:41 <CakeProphet> hmmm... cabal is complaining that I don't have "base". but I can't find an apt-get package that resembles it.
11:38:43 <Tobsan> @src cycle
11:38:43 <lambdabot> cycle [] = undefined
11:38:43 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:39:19 <SamB_XP> CakeProphet: is it not complaining that you don't have base 4?
11:39:26 <porges> CakeProphet: I think you need to install an older version of lambdabot for 6.8.2
11:39:29 <CakeProphet> yeah
11:39:40 <SamB_XP> or < 4
11:39:42 <SamB_XP> or something
11:39:57 <CakeProphet> =< 4... -pedantic-
11:40:07 <SamB_XP> =< 4 ?
11:40:13 <SamB_XP> that's an interesting requirement!
11:40:16 <CakeProphet> probably >
11:40:17 <CakeProphet> ...
11:40:23 <CakeProphet> sdfiojsortjosirjt. isn't it?
11:41:18 <CakeProphet> should I go ahead and get a newer version of ghc without apt-get?
11:41:26 <CakeProphet> or just get an older lambdabot?
11:41:50 <porges> I gave in eventually; kept wanting ghc 6.10 stuff
11:41:54 <porges> I assume you're on ubuntu?
11:42:02 <CakeProphet> yep
11:42:11 <CakeProphet> hey, what's that supposed to mean. ;)
11:42:13 <orbitz> i would instal lit locally, modify path
11:42:25 <orbitz> so once it comes out you can easily move to it via apt-get
11:42:26 <porges> just download the binary install of 6.10 and use checkinstall to install it
11:42:30 <orbitz> but that's just me
11:42:58 * CakeProphet is still waiting for Python 2.6 to be on apt-get.
11:43:01 <Komaniak> Please enter this site www.komaniak.xaa.pl
11:43:02 <porges> orbitz: if you use checkinstall it will turn into a package that you can just uninstall it later :)
11:43:10 <orbitz> porges: cool
11:44:11 <CakeProphet> waiting for a new language version is like waiting for Christmas when you were like 8
11:44:28 <porges> CakeProphet:  http://haskell.org/ghc/dist/6.10.1/ghc-6.10.1-i386-unknown-linux-libedit2.tar.bz2 :D
11:44:43 <porges> it seems like it will be forever for debian/ubuntu to get it as an actual package
11:45:31 <CakeProphet> why does it take so long?
11:45:46 <gwern> the maintainers on debian are not very active
11:46:00 <gwern> note sid is still on 6.8.2 last I checked
11:46:20 <SamB_XP> gwern: what about ubuntu
11:46:37 <opqdonut> gwern: err ghc?
11:46:37 <porges> SamB_XP: ubuntu gets its packages from debian
11:46:43 <opqdonut> etch (stable) (devel): GHC - the Glasgow Haskell Compilation system
11:46:43 <opqdonut> 6.6-3: alpha amd64 arm hppa i386 ia64 mips mipsel powerpc s390 sparc
11:46:51 <opqdonut> sid (unstable) (devel): GHC - the Glasgow Haskell Compilation system
11:46:51 <opqdonut> 6.8.2-7: alpha amd64 arm armel hppa i386 ia64 kfreebsd-i386 mips mipsel powerpc s390 sparc
11:47:02 <opqdonut> ah, nvm
11:47:05 <opqdonut> 6.8.2 not 6.2
11:47:08 * opqdonut hides
11:50:57 <dons> its fun seeing the people on twitter "tempted" to Haskell from OCaml. You can see the pressure is on :)
11:51:48 <SamB_XP> porges: oh, no WONDER it takes so long
11:51:54 <SamB_XP> you get the Debian slowness + delay!
11:54:17 <maltem> Woot, does ubuntu get *all* its package updates from Debian? Hardly possible
11:56:50 <opqdonut> not all
11:57:03 <opqdonut> but non-mainstream packages mostly yes
11:59:54 <CakeProphet> surely other repos exist with a newer GHC package.
12:00:16 <redditbot> Why we use the threaded runtime system...
12:00:16 <redditbot> Where GHC's multicore support is heading
12:00:52 <SamB_XP> redditbot: where are the URLs?
12:01:12 <vixey> I wish someone would kick out redditbot
12:18:33 <avarus> hi
12:19:08 <orbitz> hi
12:21:32 <shapr> stepcut: Ah, I see. I don't know for sure, but when my plans get finalized, I'll tell you.
12:22:04 <stepcut> shapr: sweet!
12:22:19 <shapr> stepcut: Would be nice to finally meet you :-)
12:22:29 <stepcut> shapr: :p
12:37:40 <Daz> http://www.anonimowosc.com/index.php?q=uggc%3A%2F%2Ffghqrapxvuhzbe.cy%2Fenaxvat.cuc%3Fvq%3D5791&hl=2f9
12:40:04 <Botje> sigh
12:40:11 <Botje> don't click daz's link
12:40:17 <Botje> it's some kind of voting site
12:41:35 <kalven> but the url looks so tempting
12:41:42 <blackh> Botje: Is that cartoon funny?
12:41:57 <TwoPointOh> http://tinyurl.com/3c62n2
12:42:04 <Botje> didn't click it, just unrotted it
12:42:46 <blackh> Botje: It looks funny, but I can't read Polish.
12:45:26 <roconnor> @hoogle assoc
12:45:26 <lambdabot> Control.Parallel.Strategies data Assoc a b
12:45:26 <lambdabot> Text.Parsec.Expr data Assoc
12:45:26 <lambdabot> Text.ParserCombinators.Parsec.Expr data Assoc
12:45:37 <roconnor> @hoogle assocList
12:45:37 <lambdabot> No results found
12:45:48 <roconnor> @hoogle [(a,b)] -> a -> b
12:45:49 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:45:49 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:45:49 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
12:46:41 <shapr> adekoba: Boston?
12:46:51 <adekoba> shapr: yes
12:47:04 <shapr> adekoba: Cool, I'm in Somerville.
12:47:10 <adekoba> shapr: neat. Medford here.
12:47:25 <shapr> So, know of any Haskell users group in the area?
12:47:32 <adekoba> no, haha
12:47:43 <shapr> Too bad, there should be one.
12:47:48 <adekoba> start one!
12:47:54 <shapr> hm, ok!
12:48:10 <shapr> Do you know anyone else in the area who uses/likes Haskell?
12:48:32 <adekoba> aside from a friend in Andover, no.
12:48:40 <shapr> Well, that's three...
12:48:53 <jkff> btw is there maybe a map with circles where haskellers live? If there isn't, I'm sure there's a free service out there that could help do it easily
12:49:11 <shapr> jkff: I think there was a hand generated thing at one point, and a frappr map
12:49:16 <shapr> I haven't seen anything lately.
12:49:31 * stepcut will be in Westford (next to Lowell, 495, etc)
12:50:22 <roconnor> > let {az = ['a'..'z']; rot13 x = maybe x (flip lookup (do {(i,o) <- zip az (drop 13 (cycle az)); [(i,o),(toUpper i,toUpper o)]}) x)} in map rot13 "fghqrapxvuhzbe.cy"
12:50:23 <lambdabot>   Couldn't match expected type `a -> Char'
12:50:46 <roconnor> @type maybe
12:50:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:50:57 <roconnor> @type fromMaybe
12:50:58 <lambdabot> forall a. a -> Maybe a -> a
12:51:07 <roconnor> > let {az = ['a'..'z']; rot13 x = fromMaybe x (flip lookup (do {(i,o) <- zip az (drop 13 (cycle az)); [(i,o),(toUpper i,toUpper o)]}) x)} in map rot13 "fghqrapxvuhzbe.cy"
12:51:08 <lambdabot>   "studenckihumor.pl"
12:51:44 <jkff> Here it is http://www.frappr.com/haskellers/map
12:52:04 <roconnor> > let {az = ['a'..'z']; rot13 x = fromMaybe x (flip lookup (do {(i,o) <- zip az (drop 13 (cycle az)); [(i,o),(toUpper i,toUpper o)]}) x)} in map rot13 "enaxvat.cuc"
12:52:05 <lambdabot>   "ranking.php"
12:54:28 <roconnor> @pl \az -> zip az (drop 13 (cycle az))
12:54:29 <adekoba> is there a function that would simplify this: getWord8 >>= \a -> getWord8 >>= \b -> return (a,b)
12:54:29 <lambdabot> ap zip (drop 13 . cycle)
12:54:30 <Beelsebob> jkff: it appears to spin indefinately loading the map
12:54:40 <jkff> Yep. Besides, the map is only for America.
12:54:50 <Beelsebob> it is?
12:54:54 <Beelsebob> why?
12:54:58 <jkff> Oh, no, my map loaded finally
12:55:09 <jkff> ..And it isn't :)
12:55:10 <roconnor> zip`ap`(drop 13.cycle) is the Aztec god of rot13
12:55:18 <jkff> I was wrong.
12:57:01 <Saizan__> adekoba: liftM2 (,) getWord8 getWord8
12:57:17 <Saizan__> adekoba: or join (liftM2 (,)) getWord8
12:58:11 <Beelsebob> getWord8 <^(,)^> getWord8
12:58:14 <stepcut> roconnor: you can shorten it by one char if you use <*> instead of `ap`, though that requires Control.Applicative to be imported :-/
12:58:45 <Beelsebob> otoh stepcut -- it would also make it more general
12:58:53 <Saizan__> <*> doesn't read like an aztec god
12:59:17 <Saizan__> ?type zip<*>(drop 13.cycle)
12:59:19 <Beelsebob> and doesn't require Control.Monad to be imported
12:59:19 <lambdabot> forall a. [a] -> [(a, a)]
12:59:19 <stepcut> Saizan__: ah... I think I understand now
13:00:16 <Saizan__> ?type asks zip <*> asks (drop 13.cycle) -- you need this to make it more general
13:00:18 <lambdabot> forall (f :: * -> *) a. (MonadReader [a] f, Applicative f) => f [(a, a)]
13:00:31 <stepcut> Saizan__: :p
13:01:01 <Saizan__> ?type arr zip &&& arr (drop 13.cycle)
13:01:02 <lambdabot> forall b (a :: * -> * -> *) a1. (Arrow a) => a [a1] ([b] -> [(a1, b)], [a1])
13:01:14 <Saizan__> ah, no, ap..
13:01:53 <vixey> hey jkff
13:03:04 <Saizan__> ?type (arr zip &&& arr (drop 13.cycle)) >>> arr (uncurry id) -- for completeness
13:03:05 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a [b] [(b, b)]
13:03:50 <geezusfreeek> woah that's an interesting expression. it looks like i came in just late enough to miss what it's for
13:04:26 <Saizan__> "zip`ap`(drop 13.cycle) is the Aztec god of rot13" :)
13:04:29 <baaba> whuh?
13:04:36 <baaba> :t uncurry id
13:04:37 <lambdabot> forall b c. (b -> c, b) -> c
13:05:56 <dons> ?userrs
13:05:56 <lambdabot> Maximum users seen in #haskell: 581, currently: 572 (98.5%), active: 21 (3.7%)
13:06:09 <vixey> @quote
13:06:09 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
13:06:09 <lambdabot> squad, but he declined.
13:06:17 <shapr> haha
13:06:22 <shapr> I put that one in, of course.
13:06:26 * shapr hugs vixey 
13:06:31 * vixey hugs shapr
13:06:36 <shapr> yay!
13:06:39 <baaba> :t curry $ uncurry id
13:06:40 <lambdabot> forall b c. (b -> c) -> b -> c
13:07:00 <FunctorSalad> hugs for great justice
13:07:20 <Botje> but everyone uses ghci!
13:07:52 <vixey> shapr disappeared
13:09:01 <luqui> How does the garbage collector know to clean up threads like:   newEmptyMVar >>= takeMVar
13:09:35 <geezusfreeek> huh, so curry and uncurry are not really inverses?
13:09:49 <luqui> you mean adjoints?
13:10:16 * geezusfreeek still doesn't know enough category theory to say anything intelligently
13:10:19 <FunctorSalad> curry and uncurry implement the isomorphism involved in the adjunction
13:10:22 <vixey> :t curry
13:10:23 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:10:24 <vixey> :t uncurry
13:10:25 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:10:29 <vixey> :t curry . uncurry
13:10:30 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
13:10:36 <vixey> :t uncurry . curry
13:10:36 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
13:10:41 <vixey> of course they are inverses
13:10:46 * luqui wonders
13:10:49 <geezusfreeek> :t id
13:10:50 <lambdabot> forall a. a -> a
13:10:51 <FunctorSalad> which is of course, (A,B) -> C  ~  A -> B -> C
13:10:55 <geezusfreeek> :t curry $ uncurry id
13:10:55 <Saizan__> geezusfreeek: well id is not _a_ function, but a family of functions, and by applying uncurry to it you're picking one of them
13:10:56 <lambdabot> forall b c. (b -> c) -> b -> c
13:11:02 <geezusfreeek> ah
13:11:07 <Saizan__> geezusfreeek: and then curry gives that one back
13:11:16 <luqui> > (uncurry . curry $ \(x,y) -> 42) undefined
13:11:16 <vixey> geezusfreek, um,  id :: (b -> c) -> b -> c
13:11:18 <lambdabot>   42
13:11:26 <luqui> HA!  they're not inverses
13:11:42 <vixey> luqui, what would happen if they were?
13:11:53 <luqui> > (\(x,y) -> 42) undefined
13:11:54 <vixey> > (\(x,y) -> 42) undefined
13:11:55 <lambdabot>   * Exception: Prelude.undefined
13:11:55 <lambdabot>   * Exception: Prelude.undefined
13:11:59 <vixey> > (\ ~(x,y) -> 42) undefined
13:12:00 <lambdabot>   42
13:12:07 <Saizan__> ?src uncurry
13:12:08 <lambdabot> uncurry f p = f (fst p) (snd p)
13:12:14 <FunctorSalad> doesn't undefined break all the categorical propeties anyway luqui ?
13:12:36 <jsn> i think it is okay to say they are inverses with respect to terminating haskell programs
13:12:39 <luqui> I don't think in general.  It's the lifted tuples which do it.
13:12:58 <jsn> though of course you never know which programs those are
13:13:01 <luqui> (which this is an example of)
13:13:08 <FunctorSalad> ISTR someone said that with undefined, (,) is not even a categorical product
13:13:11 <vixey> luqui, should I qualify near everything I say about haskell by  (except for undefined) ?
13:13:28 <luqui> vixey, sounds like you should be working in coq :-)
13:13:32 <vixey> FunctorSalad, wasn't that about strict pairing?
13:14:00 * luqui objects to the widespread intentional ignorance of undefined, as if it's something magical or special, and rules don't have to apply to it.
13:14:02 <vixey> data (a,b) = (!a,!b) type thing
13:14:31 <FunctorSalad> luqui: intentional ignorance?
13:14:33 <luqui> FunctorSalad, that's true, but only because (,) is lifted
13:14:52 <luqui> FunctorSalad, if _|_ = (_|_,_|_) then it would be, AFAIK
13:15:20 <wchogg> luqui : pretty sure you're right
13:15:21 <luqui> FunctorSalad, I wanted to use the "ignore" root of "ignorant"
13:15:30 <FunctorSalad> :)
13:16:04 <FunctorSalad> > length [(undefined,undefined)]
13:16:06 <lambdabot>   1
13:16:12 <luqui> length [undefined]
13:16:19 <luqui> > length [undefined]
13:16:20 <lambdabot>   1
13:16:20 <vixey> luqui, I think my programming in haskell is not usual, but I do not take _|_ into account
13:16:29 <FunctorSalad> yeah that was a bad argument on my side
13:16:51 <FunctorSalad> (wanted to see that _|_ != (_|_,_|_))
13:16:56 <vixey> luqui, (because I try to make everything I wrote well defined.., and consider it a bug if it is not)
13:16:58 <luqui> > (\(x,y) -> 42) undefined
13:16:59 <lambdabot>   * Exception: Prelude.undefined
13:17:13 <luqui> > (\(x,y) -> 42) (undefined,undefined)
13:17:14 <lambdabot>   42
13:17:26 <FunctorSalad> :)
13:17:37 <vixey> categorical notion of pair is that  pi1 (a,b)  = a, and pi2 (a,b) = b isn't it?
13:17:37 <geezusfreeek> nontermination is not well-defined?
13:17:55 <FunctorSalad> I guess _|_ behaves just like pointed spaces categorically?
13:17:59 <vixey> geezusfreeek: absolutely not, it is the one effect haskell did not banish into a monad
13:18:06 <FunctorSalad> with morphisms of pointed spaces being the strict functions
13:18:31 <gwern> if we banished bottom into a monad, I guess that'd make the rest of haskell total then
13:18:32 * luqui thinks _|_ is well-defined, but it sure does muck up the semantics a lot
13:18:36 <vixey> will someone say a bit about what it means to be a categorical pair or whatever you talk about?
13:19:09 <luqui> on the other hand, _|_ in the semantics is what allows reasoning about infinite lists, and we don't want to give that up
13:19:23 <wchogg> bottom is a neccesary evil
13:19:28 <vixey> ok well-defined is sufficently meaningless, but I just object to _|_ but it is an effect that tramples on your otherwise meaningful program
13:19:33 <geezusfreeek> i have always considered _|_ to be well-defined. it is just not expressed in haskell's type system
13:20:09 <luqui> geezusfreeek, the alternative would be a partiality monad or something?
13:20:24 <geezusfreeek> maybe. i have thought about this before, but not very extensively
13:20:33 <vixey> if you write only programs that terminate/produce, and reason only as if they did -- you can safely ignore bottom
13:20:48 <vixey> of course when you make a mistake and everything breaks, you know exactly why
13:20:51 <luqui> wouldn't that be swell:  data FiniteList a = Nil | Cons a (FiniteList a);  data PossiblyInfiniteList a = Nil | Cons a (Partial (FiniteList a))
13:20:55 <augustss_> vixey: _|_ does not have to be considered an effect (I agree it should be banished, though).  It behaves in a non-effectful way in the denotational semantics of Haskell.
13:21:00 <luqui> er, Partial (PossiblyInfiniteList a)
13:21:22 * luqui does not want to program in a total language without dependent types
13:21:26 <FunctorSalad> vixey: fst :: x -> a1, snd :: x -> a2    is a categorical product if for each f1 : w -> a1, f2 : w -> a2, there is a unique f : w -> x such that fst f = f1 and snd f = f2
13:21:45 <FunctorSalad> (x is the product of a1 and a2 then)
13:21:50 <luqui> and really... yeah, I'm using Haskell instead of Coq because it has just the right balance of rigor and usefulness by being partial
13:21:52 <vixey> augustss_, for something to behave effectful, does it mean that you just cannot write out denotation semantics?
13:22:38 <wchogg> augustss_ : not sure if I understand how you could banish _|_ from Haskell.
13:22:45 <vixey> FunctorSalad, I see, thanks, and fst f is notation for fst . f?
13:22:54 <FunctorSalad> vixey: right, missed that
13:22:55 <augustss_> vixey: no, I just mean that when considering pointed domains there's nothing fishy about _|_
13:22:56 <luqui> wchogg, don't compile programs which don't terminate
13:23:17 <augustss_> wchogg: No, for Haskell I think it's too late to banish _|_
13:23:49 <cizra> What's _|_?
13:23:52 <FunctorSalad> vixey: if you call functions into y "the elements of y", then it becomes "the elements of x correspond to pairs (element of a1, element of a2)" :)
13:24:02 <wchogg> luqui : well I was presuming he meant something other than giving up turing completeness.  :p
13:24:15 <Saizan__> luqui: you can have infinite lists without _|_, just use codata
13:24:20 <FunctorSalad> so plain products are the special case where the domain of the elements is ()
13:24:42 <geezusfreeek> as i have recently been learning, codata introduces some problems of its own
13:24:50 <vixey> wchogg, (shouldn't we say mu-recursive or something? instead of 'turing complete' being functional programming and all)
13:25:11 <wchogg> vixey : I use terms up to isomorphism. ;)
13:25:15 <geezusfreeek> although the causes of those problems are still mysterious to me
13:25:22 <jeffwheeler> How do you say "monoid"? "Mono-Id" or "Muh-No-Id"?
13:25:32 <vixey> mon-oid
13:25:46 <luqui> Saizan__, true.  Eew  (I think the reasoning theory of codata has a long way to go before I will look upon it favorably)
13:26:08 <jeffwheeler> "Oid" like, annoyed"
13:26:15 <luqui> jeffwheeler, "mahn-oid"
13:26:15 <jeffwheeler> err, last a quotation mark
13:26:26 <jeffwheeler> "oid" as in "annoyed"?
13:26:32 <luqui> yeah
13:26:42 <luqui> or humanoid...
13:26:42 <FunctorSalad> monoyed
13:26:47 <jeffwheeler> ah, I've been saying it wrong all along; oh well :D
13:27:02 <luqui> "mo-no-ad"
13:27:02 <augustss_> monoyed
13:27:13 <augustss_> monnoyed
13:27:19 <luqui> oh, to be clear
13:27:24 <luqui> "MAHN-oid"
13:27:32 <luqui> in contrast to ann-OYED
13:27:33 <wchogg> Also, I'd like to on record as being fundamentally against pronouncing monad as "moan-ad".  We don't say "moan-oid" or "moan-o-morphism" or any other such silliness.
13:27:59 <geezusfreeek> we don't?
13:28:00 <luqui> wchogg, noted.
13:28:20 <augustss_> wchogg: agreed
13:28:21 <wchogg> luqui : thank you, sir.
13:28:26 <augustss_> wchogg: blame Phil
13:28:27 <FunctorSalad> @remember wchogg We don't say "moan-oid" or "moan-o-morphism" or any other such silliness.
13:28:28 <lambdabot> Good to know.
13:28:55 <BMeph> wchogg: Genny-hater! ;p
13:29:15 <FunctorSalad> the happymorphisms chase the moan-o-morphisms away....
13:29:20 <vixey> geezusfreeek: what problems?
13:29:35 <Botje> moan-o-morphism techhnician?
13:29:38 * luqui does not want to use the dual of happymorphism
13:29:54 <wchogg> augustss_ : Oh wow, is it seriously traced back to him?  I find that more amusing than I probably should.
13:29:54 <augustss_> combinator is another word everyone mispronounces
13:30:03 * BMeph thinks wchogg or luqui need to tell Eugenia Cheng to "learn to speak English", then...
13:30:17 <pumpkin> :o
13:30:18 * FunctorSalad just pronounces it "kombinator" ;)
13:30:27 <wchogg> BMeph : I didn't say other people don't do it.  I'm saying that I'm against it.
13:30:31 <pumpkin> I like her accent!
13:30:31 <avarus> german -> english :)
13:30:32 * luqui says com-BINE-uh-tore
13:30:56 <geezusfreeek> vixey: see http://pauillac.inria.fr/pipermail/coq-club/2008/003675.html and http://article.gmane.org/gmane.comp.lang.agda/226 for examples
13:30:56 <wchogg> BMeph : and I happen to love the Catsters videos. :p
13:31:02 <augustss_> wchogg: I'm pretty sure.  I can't even remember how Moggi said monad, because he's Italian accent is pretty, ummm, itailian.
13:31:04 <Botje> MORTAL KOMBINATOR, FIGHT!
13:31:05 <pumpkin> augustss_: how should it be pronounced?
13:31:14 <vixey> geezusfreeek: why is this a problem of codata?
13:31:30 <wchogg> I'm just saying that until Saunders MacLane rises from the grave and slaps me I'm not going to pronounce monad that way.
13:31:41 <vixey> geezusfreeek: as opposed to a problem of implementation
13:31:47 <augustss_> pumpkin: According to Curry it's starts out like the word combine, combine-ator
13:31:52 <luqui> @saundersmaclaneslap
13:31:52 <lambdabot> Unknown command, try @list
13:32:00 <jeffwheeler> com BINE uh tor sounds like a Spanish bull-fight, to me.
13:32:13 <geezusfreeek> i have read around that it is with codata itself and not implementation. if you want some details, i am definitely *not* the one to ask
13:32:17 <luqui> augustss_, uh huh
13:32:21 <pumpkin> augustss_: that sounds like a lame superhero name :P
13:32:39 <augustss_> pumpkin: I'm not arguing :)
13:32:42 <luqui> I have heard that codata should be reasoned about like a coalgebra
13:32:44 <vixey> geezusfreeek: I've not studied this stuff but I don't believe it
13:32:52 <luqui> rather than an algebra, which is what the notation suggests
13:33:38 <wchogg> well isn't codata the greatest fixed point of your functor instead of the least fixed point, when working in something other than CPO so that the two are the same?
13:33:47 <wchogg> Or am I remembering completely worng?
13:33:58 * BMeph says is like "KOM-bin ate her".
13:34:12 * BMeph meant s/is /it /
13:34:24 <wchogg> Actually...I think I am remembering wrong, never mind me.
13:34:30 <avarus> BMeph, same here
13:34:34 <luqui> i.e., you don't say a codata list is either Nil or Cons x (List x); instead you say a codata list has the projection: List x -> Maybe (List x)
13:34:34 <avarus> is that wrong?
13:34:46 * geezusfreeek also says it like BMeph
13:34:47 <luqui> hmm, that seems the same.  I want to say there are two projections...
13:34:55 * luqui digs in the coq archives
13:35:31 <geezusfreeek> luqui: i would be interested in a link to whatever you find on that. i like the idea there
13:35:42 <vixey> @go Shin Cheng Mu codata
13:35:44 <lambdabot> No Result Found.
13:36:01 <BMeph> luqui: Wouldn't a codata List not even have a Nil option? :)
13:36:17 <vixey> BMeph, you can define it with or without
13:36:35 <vixey> it's just that fix Succ is actually inhabited by codata and not by inductive data
13:36:36 <FunctorSalad> isn't it that in an algebra a term can be evaluated to a value while in a coalgebra a value can be exploded into a term?
13:36:40 <BMeph> vixey: Ah, that works, then. Thank you. :)
13:36:48 <FunctorSalad> ;)
13:37:13 <luqui> BMeph, you're talking about a stream?
13:37:24 <luqui> I'm just talking about possibly-infnite lists
13:37:44 * BMeph imagines a letter to God from vixey's last stmt: "Dear God, fix Succ. Love,..."
13:37:49 <FunctorSalad> (I suggest "asploded" as a technical term here)
13:38:25 <wchogg> FunctorSalad : seconded!
13:38:37 <geezusfreeek> i accidentally a infinite list!
13:38:47 <luqui> geezusfreeek, http://pauillac.inria.fr/pipermail/coq-club/2008/004152.html
13:38:48 <geezusfreeek> the whole thing!
13:38:57 <geezusfreeek> luqui: thank you
13:39:04 * BMeph imagines the fun of Jeff Foxworthy describing "asploded" in his next "Redneck Dictionary" routine...
13:39:09 <wchogg> geezusfreeek_ : you got your 4chan in my #haskell
13:41:32 <adekoba> is there any point in using binary (as opposed to binary-strict) if the result must be evaluated?
13:41:53 <dons> yes, binary may be fasttter
13:42:03 <dons> (it's maintained somewhat more actively)
13:43:10 <adekoba> arg. Even if they were both actively maintained, would binary be faster?
13:44:30 <dons> adekoba: not necessarily.
13:44:37 <dons> the strict one could be optimised further, imo.
13:46:01 <vixey> I wonder if someone has done a proper study of codata
13:46:12 <vixey> and derived an algorithm for typechecking it
13:46:34 <vixey> how do you think the algorithms which breaks on that example works?
13:46:36 <luqui> as opposed to the ad-hoc stuff in agda and coq...
13:46:56 <vixey> luqui, it is definitely ad-hoc? I assume so but I don't really know how it's implemented
13:47:30 <luqui> well checking for productivity is purely syntactic, which is kind of silly
13:47:46 <luqui> and they have not formalized whatever the dual of well-foundedness is
13:48:13 <vixey> luqui, isn't it just well foundedness, again?
13:48:31 <vixey> if you write  f = foo f, then as long as foo is well founded induction on something, it's productive (right?)
13:48:34 <luqui> maybe, but it is not implemented if so
13:48:57 <luqui> vixey, surely id is well-founded?
13:49:10 <vixey> yeah termination of id is immediate
13:49:19 <luqui> but f = id f is not productive
13:49:26 <vixey> oh ok
13:50:06 <wabash> Hi.
13:50:08 <vixey> but any ideas where the implementations in coq and agda come from?
13:50:19 <luqui> I don't know enough to answer that
13:50:22 <wabash> I'm investigating Haskell.
13:50:29 <pumpkin> investigate away!
13:50:30 <wabash> Is there a REPL for the haskell interpreter?
13:50:33 <pumpkin> ghci
13:50:38 <wabash> cool.
13:50:40 <luqui> or hugs.  but ghci is cooler.
13:50:47 <pumpkin> it's not quite the same as haskell in a text file
13:50:51 <pumpkin> but it's pretty similar
13:51:02 <wabash> Can I keep data structures in memory in the REPL, and then call compiled Haskell functions on the data?
13:51:06 * luqui wonders what it would take to allow ghci to be like haskell in a text file
13:51:13 <luqui> wabash, yes
13:51:18 <wabash> Cool.
13:51:22 <luqui> wabash, set local variables with "let"
13:51:28 <luqui> ghci> let x = 42
13:51:32 <luqui> ghci> x
13:51:33 <luqui> 42
13:51:34 <wabash> like scheme.
13:51:36 <wabash> cool.
13:51:47 <wabash> when you say that ghci is different than files, in whhat way?
13:51:51 <wabash> language is the same, right?
13:52:05 <ehird> yeah but
13:52:08 <luqui> wabash, yeah, but eg. you can't define new algebraic data types in ghci
13:52:09 <opqdonut> ghci is like being inside an IO-monad do block
13:52:09 <ehird> ghci is in a do expression
13:52:12 <ehird> it's MONADS
13:52:15 * ehird scares newbie
13:52:18 <luqui> haha
13:52:29 <opqdonut> :D
13:52:36 <pumpkin> > let (????) = (+) in 5 ???? 6
13:52:37 <lambdabot>   11
13:52:48 <ehird> pumpkin: That is one confused monad you got there.
13:52:50 <luqui> wabash, and your definitions need to start with "let"   (in normal haskell you just write f x = x+1, instead of let f x = x + 1)
13:52:58 <pumpkin> ehird: :)
13:52:58 <wabash> I see.
13:53:05 <geezusfreeek> it's not quite as if in the IO monad. it implicitly runs show on the result of pure expressions
13:53:12 <wabash> It's because of the pure methods and monads distinction, correct?
13:53:18 <ehird> Essentially, yep.
13:53:22 <wabash> Excellent.
13:53:23 <opqdonut> essentially, no
13:53:27 <luqui> wabash, actually no.
13:53:28 <ehird> Hrm. You should be more scared.
13:53:29 <opqdonut> but you can pretend it is
13:53:37 <ehird> opqdonut: "Essentially" = handwaving.
13:53:37 <wabash> Hey, how come you guys are so much nicer than the RoR people?
13:53:47 <luqui> wabash, SHUT UP
13:53:50 <opqdonut> :D
13:53:52 <wabash> ?
13:53:52 <ehird> wabash: GO AWAY
13:53:56 <wabash> Oh, I get it.
13:54:02 <wabash> Sorry. a bit slow today.
13:54:03 <geezusfreeek> wabash: the RoR people suck!
13:54:04 <ehird> :-)
13:54:06 <geezusfreeek> ;)
13:54:20 <ehird> i think the rails peeps are just insecure :D
13:54:21 <wabash> geezusfreeek: Yeah, empirically, that's my conclusion too.
13:54:25 <noteventime> I wouldn't be nice either if I was using RoR
13:54:30 <ehird> heh
13:54:31 <stepcut> noteventime: haha
13:54:33 <luqui> it's because we are underdogs, and cling to every prospective haskeller like a girlfriend breaking up with us
13:54:34 <wabash> I've just had bad experiences with it.
13:54:48 <FunctorSalad> @karme++ luqui
13:54:49 <lambdabot> luqui's karma raised to 2.
13:54:49 <ehird> luqui: you guys should kick me out
13:54:53 <wabash> luqui: I guess i'm in the same boat, then. I cling to desperation.
13:54:55 <ehird> i do things like yell monads all the time
13:54:56 <blackdog_> luqui: ssh, ssh, you'll scare them off
13:55:14 <vixey> dammit you lot got me interested in codata :/
13:55:25 * luqui wonders to where he should ssh
13:55:26 <geezusfreeek> i think the real reason we are so nice here is because we generally have a genuine interest in this stuff while many of the RoR people are more concerned with their individual tasks than good conversation
13:55:28 <vixey> I was happily ignoring it before
13:55:35 <whisky> \exit
13:55:39 <ehird> whisky: it's a /
13:55:40 <blackdog_> wabash: i think the other factor is that everyone remembers there was a pretty steep learning curve for this stuff
13:55:42 <ehird> yw
13:55:57 <whisky> thanks :)
13:55:58 <luqui> it's because I use IRC as a way to not bang my head against the wall about the problem I'm currently trying to solve
13:56:08 <ehird> blackdog_: haha, once you learn haskell you can't stop using it because you wasted too much time trying to understand monads
13:56:21 <ehird> don't want it to be wasted :-)
13:56:21 <noteventime> Are there any good books/papers on functional software architecture (or whatever the term may be)?
13:56:34 <luqui> ehird, true.  and then you see monads floating in your C#, and just get frustrated when you can't formalize them
13:56:46 <ehird> monad soup
13:56:59 <vixey> geezusfreek, hey look http://pauillac.inria.fr/pipermail/coq-club/2008/003698.html
13:57:00 <avarus> noteventime, http://book.realworldhaskell.org/read/ perhaps?
13:57:03 <geezusfreeek> luqui: amen
13:57:11 <FunctorSalad> ehird: you mean you don't want it to have been wasted in vain? ;)
13:57:26 <noteventime> avarus: I've read some of it, didn't much care for it
13:57:33 <luqui> noteventime, functional software architecture = math
13:57:38 <avarus> too bad, I wanted to read it
13:57:50 <vixey> that pretty much settles it about implementation I think
13:58:21 <noteventime> luqui: True, to a point, though discussing it in terms of mathematics seems rather inefficient
13:58:29 <vixey> "Calculus of Infinite Constructions"
13:58:46 <luqui> noteventime, how so?
13:59:16 <ehird> noteventime: haskell programs are just mathematics
13:59:25 <geezusfreeek> vixey: ah, yes, thanks
13:59:48 <noteventime> luqui + ehird: I (still) don't find thinking about software design in terms of lambda abstraction very intuitive
14:00:08 <ehird> i don't exactly find it easy either
14:00:09 <vixey> one thing I wonder, and it's probably very related to what luqui said, is you know how to derive eliminators (like folds) for inductives, but there's no dual notion for coinductive types?
14:00:10 <ehird> noteventime: my suggestion--
14:00:13 <vixey> or is there? but I haven't seen any
14:00:19 <ehird> read some real-world, not-very-complex haskell apps
14:00:21 <ehird> and just work from there
14:00:24 <ehird> pick up bits as you go
14:00:29 <ehird> it's what I'm doing
14:00:32 <FunctorSalad> ehird: hmm math is a lot 'cleaner' I think...
14:00:41 <luqui> noteventime, who said anything about lambda extraction?
14:00:44 <ehird> FunctorSalad: Haskell is pretty clean :-P
14:00:45 <noteventime> ehird: Any good suggestions?
14:00:57 <ehird> noteventime: That's the hard part! :-)
14:01:02 <FunctorSalad> ehird: you don't write pages of datatypes for arguments to a shell command in math ;)
14:01:04 <ehird> I think there are some links on the haskell wiki somewhere
14:01:08 <noteventime> luqui: It just used it to symbolise the higher mathematics involved :)
14:01:16 <FunctorSalad> ehird: it's not haskell's fault, it's computing
14:01:38 <luqui> noteventime, ah I see.  I'm talking about "semantic design", in which you implement complex data to emulate simpler ideas.
14:01:41 <ehird> noteventime: I'm not exactly proficient in mathematical wizardry so I don't think it'll cause you too much of a problem :)
14:01:48 <luqui> more efficiently or computably, usually.
14:01:49 <mattam> vixey: ah that great question...
14:01:57 <geezusfreeek> in my experiences, there isn't much "architecture" in a haskell program
14:02:30 <luqui> it's just a weaving together of abstractions, where each one could easily be a hackage package
14:02:40 <mattam> vixey: Note that Barras is also of the opinion that fixing the equality is the right way to go :)
14:02:42 <luqui> that's my idea of a well-designed program at least
14:03:11 <ehird> noteventime: actually, I think I might know of an app that could help get a feel of the structure when you've learned the actual language
14:03:25 <pejo> noteventime, there was an article about hoogle in "The Monad Reader", which talked briefly about good design principles for haskell programs.
14:03:25 <ehird> it's written by a person in another channel I frequent and its code is very clean but it hasn't seen public release yet
14:03:32 <geezusfreeek> i think haskell's purity the the main contributor to this. there isn't any state, so separating things into logical modules is just very natural
14:03:34 <ehird> you could take a look at it
14:03:36 <pshc> Man, I just learned about liftIO
14:03:46 <pshc> Up until now I'd been stacking tons of lifts together
14:03:48 <pshc> blah :)
14:03:51 <noteventime> ehird: Do you have some kind of link? :)
14:04:04 <ehird> noteventime: yeah, sec
14:04:05 <noteventime> pejo: I'll check it out
14:04:20 <luqui> geezusfreeek, to some extent true.  but if you aren't thinking the right way, it's still easy to make your abstractions leak all over the place.
14:04:26 <luqui> what *not* to expose is a very important question
14:05:12 <SamB_XP> luqui: yes, but taking global mutable state off the table helps immensely ;-)
14:05:15 <geezusfreeek> luqui: true, but it seems to be a rather easy question to answer in most cases
14:05:30 <luqui> geezusfreeek, I think it is.  you just have to remember to ask it.
14:05:34 <geezusfreeek> as long as you don't default to exporting everything
14:05:42 <FunctorSalad> the wiki says that global mutable state is necessary sometimes...
14:05:57 <luqui> FunctorSalad, does it defend this claim?
14:05:58 <geezusfreeek> i wish haskell forced you to explicitly export, in fact
14:06:06 <SamB_XP> well, ALMOST off the table
14:06:39 * luqui wishes there were a nice interface for exporting, where I didn't have to type all the exports at the top of the file, but I could still easily see all the exports and their type sigs
14:07:19 <FunctorSalad> luqui: yes http://www.haskell.org/haskellwiki/Top_level_mutable_state
14:07:20 <geezusfreeek> i'd be fine with just annotating functions to be exported and using haddock to see a consolidated list of them
14:07:21 <luqui> if I keep talking about this, it will doubtless descend into my rant about wanting Haskell not to be text files...
14:07:57 <FunctorSalad> luqui: they say it's good for efficiency-realted stuff, ffi stuff, representing resources that are actually unique...
14:08:05 <SamB_XP> luqui: we are never going to get a computer to be able to line up our code the way we want it, you know
14:08:08 <FunctorSalad> I wouldn't know since I haven't done it in haskell
14:08:21 <luqui> FunctorSalad, ah, yeah, when you're working in imperative Haskell, you need imperative evil
14:08:34 <luqui> FunctorSalad, I am considering Haskell to be missing the IO monad these days...
14:08:45 <luqui> IO is just a temporary hack until we find something better, in my mind
14:09:04 <vixey> haskell is just a temporary hack until we implement something better :P
14:09:08 <SamB_XP> it's actually a permanent-temporary hack
14:09:11 <luqui> SamB_XP, what do you mean?
14:09:20 <FunctorSalad> life is just a temporary hack until... eh nvm
14:09:26 <luqui> about not getting a computer to line up our code the way we want it...
14:09:35 <geezusfreeek> like FRP! (although i think FRP has a loooong way to go and is in need of a more formal treatment than it has been given so far)
14:09:50 <ehird> Haskell actually quite nicely follows Worse is Better.
14:09:54 <vixey> I really wish you anti-text people would bloody get on with, I think you have got some great ideas but you have not implemented them afaict
14:09:54 <ehird> So I don't think it's going away.
14:09:55 <SamB_XP> luqui: well, think about it ... we are so picky about what we want to line up with what!
14:09:55 <luqui> I say temporary because once we find something better, we will abstract away IO and haskell programs will look like main = somethingBetter main'
14:10:07 <ehird> vixey: I remember peaker's endless rants.
14:10:08 <ehird> Good days.
14:10:18 <vixey> that is you luqui and Peaker and a lot of others
14:10:20 <JoshTriplett> Can Cabal build plain C programs, with no Haskell bits?
14:10:25 <vixey> why don't you all work together ?
14:10:31 <JoshTriplett> I have a project which needs a small standalone C helper program.
14:10:34 <ehird> JoshTriplett: errrr, probably not.
14:10:45 <luqui> SamB_XP, that's true.  I want to be able to aesthetically craft my code.  I just don't want it to be in a text editor.  or if it is in a text editor, a very very fancy one that knows a *lot* about Haskell
14:11:01 <vixey> lequi, oh like a compiler!
14:11:12 <ehird> luqui: worse is better
14:11:13 <geezusfreeek> i am in that camp as well, but i also would rather devote my time to something else
14:11:21 <pejo> JoshTriplett, if you set your build type to Custom you can use a bunch of hooks, pre/post-{copy, install, ..}
14:11:23 <ehird> haskell's file format is interoperable, works well with tool
14:11:23 <ehird> s
14:11:26 <luqui> but I don't think pure text is the right medium.  certainly letters and numbers, just not the whole program as text.
14:11:28 <vixey> is it a somthing else you've decided on yet?
14:11:32 <ehird> and gives enough semantic/syntactical infoa
14:11:38 <opqdonut> flat text is natural
14:11:39 <ehird> and also lets us humans decide the best formatting
14:11:41 <JoshTriplett> pejo: Hmmm, that might work.
14:11:42 <ehird> like we should
14:11:43 <ehird> also
14:11:44 <luqui> ehird, I have heard that argument, and I disagree.
14:11:49 <ehird> you anti-text guys, you always say
14:11:54 <FunctorSalad> vixey: "anti-text"?
14:11:54 <ehird> intermediatry invalid programs are bad!!
14:11:57 <ehird> but they're not, they're natural
14:11:58 <luqui> ehird, why shouldn't Haskell be represented as something with more structure than text?
14:12:01 <pejo> JoshTriplett, and there's a hook for running a configure script right after the cabal stuff is configured, if the file exists and it's not on windows.
14:12:04 <luqui> ehird, like a data structure, for example.
14:12:07 <ehird> FunctorSalad: "I want an editor operating on an AST. with ponies!"
14:12:09 <ehird> luqui: worse is better
14:12:11 <luqui> that would work better with Haskell functions.
14:12:29 <luqui> Haskell is bad at working with text, compared to how it is at working with structured data.
14:12:41 <JoshTriplett> pejo: I don't need a configure script.  I just need to compile a single .c file and link it to a given library.
14:12:45 <ehird> hmm, it's the same anti-text speech we hear every month.
14:12:49 <luqui> also, I don't consider slogans to be cohesive arguments.
14:13:01 <luqui> uh yeah it is
14:13:04 <SamB_XP> worse is better is a mere slogan now ?
14:13:06 <luqui> I"m going to shut up now
14:13:17 <geezusfreeek> better is better!
14:13:24 <luqui> by reflexivity!
14:13:30 <geezusfreeek> ftw
14:13:32 <ehird> worse is better essentially embodies the philosophy of minimalism.
14:13:49 <ehird> i happen to subscribe to it, most of the time. if you don't, you suck :P
14:13:51 <SamB_XP> I'm not saying I don't think that exports can't stand to be handled in a more automated fashion, I just think that the program should still be in a textfile
14:14:17 <luqui> ehird, I do to.  but it still remains to be shown that text is the right form of minimalism.  okay, actually shutting up now.
14:14:27 <geezusfreeek> i have no problem with either of "worse/better is better". they actually are worded to conflict even though ideally they shouldn't
14:15:27 <ehird> the writer of the worse is better essay doesn't actually subscribe to it
14:15:34 <luqui> oh, damnit, I just can't.  blah blah blah.  if you work with text, you have to have parsing, operator precedence, ordering, all-at-once type checking, ....
14:15:37 <ehird> it was part of a larger piece on lisp
14:15:43 <ehird> luqui: if you work with asts,
14:15:44 <luqui> text doesn't seem to be that minimal
14:15:44 <ehird> you have to have:
14:15:47 <geezusfreeek> isn't it the same writer who wrote better is better?
14:15:49 <ehird> complex graphical serialization
14:15:56 <ehird> complex editing methods
14:16:00 <ehird> you have to make them both intuitive
14:16:06 <ehird> you have to have complex indentation/formatting structurers
14:16:08 <luqui> ehird, I don't understand what about ASTs needs complex graphical serialization.
14:16:09 <ehird> that always get it right
14:16:13 <ehird> (etc)
14:16:24 <ehird> luqui: users are not quite yet equipped to read ASTs directly from memory.
14:16:26 <FunctorSalad> ascii art ASTs?
14:16:38 <ehird> Most importantly:
14:16:41 <luqui> I think the main point of difference is that text is minimal from the user's perspective, but very complex from the program's perspective
14:16:43 <luqui> and vice versa
14:16:56 <luqui> so if you want code to be manipulated by *programs*, an AST seems the better choice
14:17:00 <ehird> Text is here today, right now, it's intuitive to humans (we LIKE making things invalid when restructuring them -- it's natural)
14:17:03 <ehird> and text is widely supported
14:17:03 <luqui> and an editor is a program... hmm...
14:17:08 <ehird> And finally, text is _good enough_.
14:17:17 <stepcut> any idea if I can implement this using the existing Monad/Applicative Functor classes (or some other existing classes), instead of making the weird chimera? http://hpaste.org/13293
14:17:21 <luqui> ehird, if you want to block out of your mind how much better it could be.
14:17:23 <luqui> :-)
14:17:33 * ehird sigh
14:17:35 <luqui> but I understand the follies of my idealism.
14:17:56 <FunctorSalad> ehird: we are highly trained at handling text, but arguably geometry is even more intuitive
14:18:02 <luqui> i'm conscientiosly unreasonably idealist; that's how I'm either going to change the world or waste my life =P
14:18:09 <ehird> FunctorSalad: Trefunge! Trefunge!
14:18:20 <ehird> We live in 3D space, we should program in it too!
14:18:30 <ehird> It's programming and Second Life in one!
14:18:33 <ehird> :D
14:18:33 <Beelsebob> stepcut: I'm not sure what you're trying to do, but your name sounds suspicious -- all Monads are Applicatives
14:18:33 <vixey> you're either going to create something or talk about it all the time
14:18:35 <stepcut> having run into many programs that failed because they did not check errno after read()/write(), I would have to say worse is not better
14:18:49 <ehird> stepcut: that's a detail
14:18:50 <stepcut> Beelsebob: yes, but you can only use the Applicative part when you do that
14:18:54 <luqui> ehird, incidentally, taken to the very extreme, I agree.  As long as it is understood that rendering 3D on a 2D screen is *not* 3D.
14:18:54 <ehird> its the generic philosophy I like.
14:19:03 <Beelsebob> stepcut: when you do what?
14:19:11 <ehird> luqui: Sticky styrofoam code!
14:19:16 <opqdonut> luqui: human vision is not 3d
14:19:17 <luqui> ehird, YES!
14:19:17 <ehird> Maybe we could sculpt code.
14:19:19 <luqui> =P
14:19:33 <luqui> opqdonut, truth, so obviously there is more to programming in 3D than seeing.
14:19:34 <ehird> "Here is my masterpiece, 'hello wUrld.\r'"
14:19:55 <luqui> opqdonut, there must be moving, touching, ...
14:20:24 <FunctorSalad> opqdonut: but proprioception is, isn't it? :)
14:20:31 <FunctorSalad> (sp?)
14:20:38 <FunctorSalad> the sense of where you are spatially
14:20:49 <opqdonut> luqui, FunctorSalad: yeah but still
14:20:58 <opqdonut> grasping the whole of an untrivially 3d structure is hard
14:21:31 <stepcut> Beelsebob: if you do, (,) <$> getLine <*> putStrLn. IO is Monad and an Applicative Functor, but you can not get the value from the 'getLine' to the 'putStrLn' because AFs do not let you do that
14:21:43 <geezusfreeek> i would love to be able to program by manipulating real objects... assuming the abstraction perfectly models the program... :\
14:21:50 <luqui> opqdonut, harder than grasping the whole of a complex textual program?
14:21:58 <Beelsebob> stepcut: no -- that's what the Monad instance is for
14:22:33 <pumpkin> stepcut: what would that do?
14:22:35 <luqui> text has no zooming, for example.  you can not stand back and get an overview, and then look closer to get details.  you just see the details.
14:23:07 <wli> Worse is worse. It cannot be other than what it is, especially not what is defined as its diametric opposite, precisely what it is not, namely better.
14:23:24 <FunctorSalad> worse_1 is better_2
14:23:26 <b_jonas> freedom is slavery
14:23:27 <geezusfreeek> wli: are you just being pedantic?
14:23:37 <luqui> wli, lol
14:23:57 <luqui> if worse is better, then the space of goodness must be the trivial space
14:23:58 <luqui> =P
14:24:14 <adityam> @pl f x = g x == A
14:24:15 <lambdabot> f = (A ==) . g
14:24:27 <stepcut> Beelsebob: yes, but in the example code, you can not implement a Formlet monad which has the right semantics because you end of having the Html you are generating depend on the values the user is going to submit
14:24:34 <FunctorSalad> luqui: isn't it enough that worse=better=0?
14:24:35 <geezusfreeek> war is peace, freedom is slavery, ignorance is strength
14:24:40 <geezusfreeek> and worse is beter
14:24:43 <geezusfreeek> *better even
14:24:52 <wli> It was humor.
14:24:58 <FunctorSalad> there could be goodnesses unreachable by just becoming better or worse
14:25:16 <geezusfreeek> wli: we take humor very seriously ;)
14:25:26 <luqui> FunctorSalad, hmm, yes.  I suppose I was assuming some sort of linearity.
14:25:43 <luqui> nonstandard models of goodness (gracious)
14:26:05 <luqui> humor is far too unimportant to be taken unseriously
14:27:31 <vixey> where could I find some very good examples of ReadP(rec)?
14:27:50 <vixey> I worry a bit that what I write is horrendous in terms of efficiency but I don't realize
14:27:50 <stepcut> Beelsebob: the ApplicativeMonad computes two values. The first value can not depend on the result of a previous function (so it can only be combined like Applicative Functors, <*>), the second value can depend the results of previous computations (and hence behaves like Monad, (>>=))
14:28:15 <stepcut> s/previous function/previous computation/
14:29:06 <luqui> vixey, I don't know of any.  if you have any benchmarks to share, that would be appreciated
14:29:20 <luqui> I was under the impression that ReadP is pretty efficient in most cases.
14:29:24 <vixey> I write a sexp parser and a infix op thingy
14:29:29 <vixey> yeah I'm just wondering though
14:30:05 <vixey> it's got a really nice simple implementation
14:30:28 <ehird> 22:20 <geezusfreeek> i would love to be able to program by manipulating real objects... assuming the abstraction perfectly models the program... :\
14:30:29 <stepcut> Beelsebob: if you look at the type sig for 'm (a -> b) x -> (x -> m a y) -> m b y' you will see it is a mixture of both '(>>=) :: (Monad m) => m x -> (x -> m y) -> m y' and '(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b'
14:30:37 <ehird> That will be interesting for porn site developers.
14:30:43 <wli> My algorithmic analysis knowledge is mostly useless outside imperative contexts.
14:30:53 <pumpkin> is there a way to import qualified in ghci?
14:30:53 <opqdonut> stepcut: or rather, >>= and ap
14:31:02 <stepcut> opqdonut: yes...
14:31:16 <b_jonas> I hate writing s-expression parsers
14:31:31 <b_jonas> for some reason they are harder to write than parsers for sane languages with infix and stuff
14:31:39 <b_jonas> I don't know why but that's my experience
14:31:40 <opqdonut> stepcut: ah nvm, m is two-ary
14:32:01 <stepcut> opqdonut: right, that two-ary thing is the interesting part I think
14:32:15 <nolrai_East> @pl h a b = g (f a) (f b)
14:32:16 <lambdabot> h = (. f) . g . f
14:32:20 <luqui> stepcut, that is a neat looking thingy.  what is it?
14:32:28 <geezusfreeek> ehird: that isn't quite what i meant :P
14:32:38 <stepcut> luqui: http://hpaste.org/13293
14:32:39 <wli> Don't you just match parentheses?
14:34:10 <stepcut> luqui: there are many answers to your question. The specific thing is a type-safe method for generated html forms and the corresponding code to parse the data when it is submitted. The ApplicativeMonad is a weird class I had to make in order to implement the html generating stuff.
14:34:12 <Beelsebob> stepcut: shouldn't return return a value to the applicative half too -- you know, because it's a monad, so it's also an applicative
14:34:50 <seydar> monads need better tutorials
14:34:51 <oklopol> reading rwh online waiting for my physical book, what's the deal with the "X comments" thingies, can i read those comments somewhere, why do they show?
14:34:54 <wli> b_jonas: Don't you just match parentheses?
14:34:59 <seydar> anyone have any that they want to show me?
14:35:03 <opqdonut> oklopol: it's a link...
14:35:17 <luqui> stepcut, hmm.  What *is* a Formlet xml a x?  What do the params represent?
14:35:18 <oklopol> opqdonut: oh, didn't work for me
14:35:25 <ehird> oklopol: click them
14:35:30 <b_jonas> wli: yes, in theory
14:35:33 <ehird> with your mouse--expression--mobile
14:35:36 <stepcut> Beelsebob: maybe -- it was not needed for the example I was developing, but there are certainly loose ends like that.
14:35:40 <b_jonas> wli: I think they're cursed or something
14:35:40 <ehird> applying pressure helps
14:36:07 <stepcut> luqui: The long answer is here, http://groups.inf.ed.ac.uk/links/formlets/, I recommend 'And idioms guide to formlets'
14:36:20 <seydar> stepcut: linkrot
14:36:30 <oklopol> ah, it opens them on the same page.
14:36:43 <oklopol> used open in new tab in IE, doesn't work
14:36:50 <ehird> oklopol: you shouldn't have mentioned IE.
14:36:55 <jeffwheeler> Is fail in Monad merely for historical reasons?
14:37:01 <b_jonas> it's possible in 10 lines full with tokenizer but it still is hard to write somehow
14:37:03 <ehird> now we're contractually obligated to kill you.
14:37:03 <oklopol> ehird: why?
14:37:06 <oklopol> :)
14:37:12 <hugo___> hello again
14:37:47 <oklopol> ehird: well doesn't matter, FF fails just as well
14:38:46 <stepcut> luqui: Formlets return 2 (or in this case 3) values, a rendering of the form (aka, <form><input>...</input></form>) and a collector (a function, [(String, String)] -> a, which takes the key/value strings that the browser submits and turns it into a Haskell value), and (in my code) a arbitrary value returned by the formlet.
14:38:47 <nolrai_East> @hoogle (a -> b) -> (b -> b -> c) -> a -> a -> c
14:38:48 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:38:48 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
14:38:48 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
14:39:21 <oklopol> never would've come up with clicking on them, i never open links in the same tab
14:39:51 <luqui> stepcut, so it is Formlet a b = (Form, [(String,String)] -> a, b)  (modulo reparameterization?)
14:41:16 * luqui wonders what the b buys you
14:41:21 <stepcut> luqui: Formlets can be composed with other formlets to build larger formlets. Because the generation of the 'rendering' and the 'collector' come from the same combinators, you never have the problem that you add a field to the form, but forget to update the code that processes the form submission. Also, the names of the input elements can be uniquely generated to avoid clashes when you reuse formlets more than once in a form)
14:41:51 <luqui> stepcut, uh huh
14:42:01 <stepcut> luqui: yes, basically, newtype Formlet xml a x = Formlet (Env -> State Int (xml, Env -> Maybe a, x))
14:42:16 <luqui> that is quite more complex than what i just said...
14:42:26 <luqui> so I'm wondering where "yes" came from ;-)
14:42:39 <luqui> oh, you need name generation
14:43:24 <stepcut> luqui: "yes" means that your guess at the type was pretty close
14:44:10 <luqui> so you added the "x" in order to... make it more monady?
14:44:35 <stepcut> luqui: the b/x is useful when you want later form elements to depend on some value that was computed earlier. For example, you might want to refer to the 'id'  of an element that was generated earlier.
14:44:53 <Saizan__> stepcut: why not allow Collector to be manipulated in a monadic way too?
14:44:55 <luqui> ah that makes sense
14:44:58 <stepcut> luqui: in the original formulation of Formlets with Applicative Functors, there is no way to get that information (that is the whole point of AFs)
14:44:58 <wli> Someone remind me to write a panegyric for mnemonic type variable names.
14:45:17 <stepcut> Saizan__: because, if the first element of your form failed to validate, then you would not be able to validate the rest of the form
14:45:30 <luqui> stepcut, in fact, it looks like this is a MonadFix, so you could even refer to the id of an element generated later :-)
14:45:52 <Saizan__> stepcut: ah, i see
14:46:36 <stepcut> luqui: yes, I would like to use mdo for that. But, I don't see how to implement Formlet as a monad while retaining the same semantics
14:46:48 <Saizan__> stepcut: it looks like a richly typed Writer monad where instead of a monoid you've an applicative functor, btw
14:47:11 <luqui> Saizan, good observation
14:47:17 <ben123> has anyone setup HStringTemplate with GHC 6.10.1?
14:47:18 <stepcut> Saizan__: hrm, I'll play with that
14:48:20 <ben123> i'm getting an error on 'Data.Generic.Aliases' being in a hidden module
14:48:42 <wli> Russell & Whitehead would feel vindicated beyond words if they could see this channel.
14:48:54 <stepcut> Saizan: i think the problem is that with the Writer monad I would have to combine things of the same type. Not a mixture like, (a -> b), a, etc
14:49:15 <Saizan> that was the richly typed part :)
14:49:30 <stepcut> Saizan: ah... can Haskell do that ?
14:50:15 <Saizan> i guess you need a parametrized monad
14:50:32 <luqui> the type of join for ApplicativeMonad is pretty neat:  join :: m (a -> b) (m a y) -> m b
14:50:35 <luqui> er, m b y
14:50:40 <Saizan> but i think there's no need to have a bind that does both of what >>= and <*> do
14:51:06 <Saizan> you could just have a primitive to manipulate the monoid, and define your bind in terms of that, if it's convenient
14:51:51 <stepcut> Saizan: hrm, I'm not sure I understand
14:52:04 <Saizan> s/monoid/applicative functor/
14:52:07 <jsn> ben123: well, if it's in a hidden module you need to change the cabal file
14:52:21 <luqui> I would just make it a monad, and then define the above join.
14:52:52 <luqui> (I find join a great deal easier to think about than bind in many cases)
14:54:14 <stepcut> luqui: this is as far as I got, instance Monad (Formlet xml
14:54:23 <ben123> jsn: any pointers on how to change the cabal file?
14:55:00 <jsn> well, you could post it to hpaste.org and i can look at it
14:55:06 <luqui> stepcut, really, you can't make  instance (Formlet xml a)?
14:55:12 <luqui> er, instance Monad (Formlet xml a)
14:55:23 <stepcut> luqui: I am double checking
14:55:47 <ben123> jsn: the offending source file?
14:55:53 <dmwit> ?remember stepcut this is as far as I got: instance Monad (Formlet xml
14:55:53 <lambdabot> Okay.
14:55:57 <jsn> the cabal file
14:55:57 <luqui> oh, hmm, I guess you can't, since there is not a join m a (m a y) -> m a y, since a has to be a function type
14:56:34 <luqui> (and also the LHS of itself)
14:56:46 <stepcut> luqui: yeah. That seems similar to the problem I ran into when I was trying to use my bind to make a Monad instance for Formlet
14:57:10 <jsn> ben123: it is something or other .cabal
14:57:12 <luqui> maybe its time to rethink your algebra?
14:57:33 <ben123> jsn: http://hpaste.org/13295
14:57:51 <gchin> hello, a question on variable naming convention: http://hpaste.org/13294
14:58:04 <stepcut> luqui: heh. This *is* the result of rethinking the algebra ;)
14:58:37 <luqui> ah.  well maybe this is the result then.  it is certainly pretty in a few ways :-)
14:59:35 <dmwit> gchin: How about namespacing the "height" accessor and just calling it height?
14:59:43 <stepcut> maybe I should do it in Agda instead ;)
14:59:48 <luqui> stepcut, I wonder if there are other useful instance of ApplicativeMonad.  I wonder if they enjoy any nice composition properties...
14:59:48 <dmwit> module Box where data Box = Box { height :: Int }
15:00:02 <dmwit> f box = let height = Box.height box in ...
15:00:19 <stepcut> luqui: dunno, I am still hoping I just reinvented something that already exists ;)
15:00:30 <luqui> dmwit, you're making me want first-class modules!
15:00:35 <luqui> or even lightweight modules
15:00:53 <gchin> dmwit: so you would import the box module qualified, and just name boxHeight "height"?
15:01:12 <dmwit> Yes.
15:01:30 <luqui> stepcut, Is this the same:  m a x -> (x -> m b y) -> m (a,b) y ?
15:01:49 <gchin> hmm, that seems like a decent solution. do you know how widespread this practice is?
15:02:37 <stepcut> luqui: seems similar...
15:02:49 <luqui> you have an operation: (a -> b) -> m a x -> m b x, right?
15:03:45 <luqui> gchin, attribute records are not that widespread in practice.
15:04:27 <jsn> ben123: so, try adding "syb" to the build-depends
15:04:28 <stepcut> luqui: not as a primitive, but you can make something like that using pur and bind I think (similar to how <$> is built from <*> and pure)
15:04:42 <luqui> stepcut, okay, then those two are the same
15:05:01 <ehird> Where's the haddock docs for generics again?
15:05:09 <jsn> just put a line above the first if, right below the line that says "library"
15:05:19 <jsn> add a line that says "build-depends: syb"
15:05:20 <stepcut> luqui: it seems like in the former $ is used to combine the values and in the latter (,) is used to combine the values
15:05:38 <luqui> stepcut, that means that you have:  instance (Monoid a) => Monad (Formlet xml a)
15:05:52 <luqui> where you map mappend over the result of a bind
15:06:09 <ben123> jsn: still the same failure
15:06:16 <Saizan> map mappend?
15:06:20 <jsn> it should say what package it is a part of
15:06:32 <luqui> Saizan, where map :: (a -> b) -> m a x -> m b x
15:06:42 <ben123> it's base-3.0.3.0 package
15:06:43 <jsn> ehird: http://www.haskell.org/ghc/docs/latest/html/libraries/syb/Data-Generics-Aliases.html
15:06:50 <ehird> ah, thanks
15:06:55 <luqui> really map (uncurry mappend), of course
15:07:12 <jsn> ben123: can you post the entire error message?
15:07:30 <ben123> jsn: Preprocessing library HStringTemplate-0.4.3...
15:07:30 <ben123> Building HStringTemplate-0.4.3...
15:07:30 <ben123>  
15:07:30 <ben123> Text\StringTemplate\GenericStandard.hs:12:7:
15:07:33 <ben123>     Could not find module `Data.Generics.Aliases':
15:07:36 <ben123>       it is a member of package base-3.0.3.0, which is hidden
15:07:40 <ben123>  
15:07:53 <jsn> what compiler are you using?
15:08:02 <ben123> ghc 6.10.1
15:08:18 <Saizan> ben123: are you installing it with cabal-install?
15:08:35 <stepcut> luqui: I could implement a Monad instance like that, but I think I would only be able to use >>= when the monads on both sides had the same type for 'a' which is not very useful in my application
15:08:36 <ben123> i did runhaskell setup configure, then build
15:08:56 <Saizan> ben123: ok, use runhaskell Setup configure --constraint="base < 4" and then build
15:09:09 <luqui> stepcut, fair enough.  but I think that is the most general constraint you need to make Formlet a monad.
15:09:39 <luqui> stepcut, and remember you can map around to make them the same...
15:09:59 <ben123> Saizen, that worked, thanks, so does the constraint option expose the hidden module?
15:11:09 <stepcut> luqui: but, I don't want them the same, I want them applied to each other
15:11:24 <luqui> stepcut, isn't that what you bind does then?
15:11:27 <Saizan> ben123: Cabal works by deciding a set of modules basing on build-depends and hiding everything else
15:11:50 <stepcut> luqui: yes
15:11:54 <Saizan> ben123: with --constraint="base < 4" you make it pick base-3.x instead of base-4.x
15:12:03 <luqui> so what's the problem?
15:13:21 <luqui> I suspect Saizan is right, and you have simply generalized the Writer monad to have additional type structure.  The fact that someone hasn't made a typeclass of it yet is incidental...
15:13:35 <luqui> if you're looking for something more general, I'll bet edwardk would know :-)
15:13:45 <ben123> Saizen, thanks
15:14:21 <stepcut> luqui: perhaps nothing. I was just trying to figure out if there was a better solution that would allow me to capture the semantics I want and leverage existing useful things like mdo. But if the answer is no, then the answer is no :)
15:14:53 <ben123> is there a way to automatiaclly finding and install packages from hackage during compilation?
15:15:07 <luqui> stepcut, i think you could leverage monad notation (including mdo perhaps?) with -fno-implicit-prelude, but that's kind of evil
15:15:08 <stepcut> ben123: cabal-install
15:15:19 <stepcut> luqui: yes, but I have considered it several times :)
15:15:29 <Saizan> ?hackage cabal-install
15:15:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
15:16:28 <luqui> I think too much desire for do notation is an indication of not enough abstraction in the client code
15:23:44 <Saizan> it's a shame we can't abstract the way the applicative values need to combine out of the monad interface
15:24:37 <luqui> How would one make a monad to do that.  You'd need some sort of type-level monoid for the annotations.
15:24:43 <luqui> which could be done I think
15:28:23 <BMeph> stepcut: Still on? :)
15:30:03 <BMeph> Looks like you guys are talking about Matthew Sackman's session types. Is there more being developed with them? :)
15:30:05 <ben123> ?package Database.HDBC.sqlite3
15:30:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Database.HDBC.sqlite3
15:30:43 <Saizan> BMeph: we're talking about http://hpaste.org/13293, indexed monads are related i guess
15:30:59 <ben123> so i did cabal install HDBC, but i'm still mising Database.HDBC.sqlite3
15:31:05 <ben123> is that a different package?
15:31:54 <Saizan> ben123: yes http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HDBC-sqlite3
15:32:42 <Saizan> to be more precise Database.HDBC.Sqlite3 is a module of the package HDBC-sqlite3
15:32:50 <BMeph> Saizan: Yeah, those look like session types. I haven't heard anything more done with them for a while.
15:33:07 <BMeph> Has someone started doing something else with them? :)
15:33:37 <Saizan> well, session types are specifically about typing communication protocols, afaiu
15:34:27 <Saizan> http://groups.inf.ed.ac.uk/links/formlets/ <- those are formlets instead
15:34:55 <ben123> Saizan, thanks, though it seems that 6.10.1 isn't working for sqlite3
15:36:06 <Saizan> ben123: it installed fine here, what problem did you get?
15:36:48 <tristes_tigres> hi
15:36:54 <ben123> Saizen: http://hpaste.org/13296
15:37:28 <ben123> maybe there are missing packages again, but it's not clear from the error msg
15:37:36 <Saizan> Database\HDBC\Sqlite3\Statement.hsc:40:21: sqlite3.h: No such file or directory
15:37:44 <tristes_tigres> how come a package has documentation page on haskell.org, but the docs are not included into the distribution ??
15:37:54 <Saizan> ben123: you're missing the sqlite3.h C library
15:38:24 <agemo> i'm having some trouble: i've got a function
15:38:30 <agemo> s x y z = x z (y z)
15:38:30 <Saizan> ben123: if you're on debian/ubuntu you've to install the -dev sqlite3 package
15:38:44 <ben123> Saizan, i'm on windows
15:38:49 <agemo> and when i give it id twice, it doesn't do quite what i expect
15:38:51 <chessguy> @pl \x y z -> x z (y z)
15:38:51 <lambdabot> ap
15:39:03 <Saizan> ben123: ah
15:39:05 <agemo> could somebody help me understand what happens there?
15:39:06 <chessguy> @type ap id id
15:39:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
15:39:07 <lambdabot>     Probable cause: `id' is applied to too few arguments
15:39:07 <lambdabot>     In the second argument of `ap', namely `id'
15:39:15 <BMeph> agemo: Um, expect the right thing; Problem Solved! ;p
15:39:42 <BMeph> @type ap id
15:39:42 <ben123> Saizen, where do i download the .h file, and how do i make it available to cabal/ghc build?
15:39:43 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
15:39:47 <Saizan> tristes_tigres: they are built from the sources if you pass --enable-documentation to cabal install, or use cabal haddock directly
15:39:53 <agemo> BMeph: i'd love to do that :p
15:40:28 <tristes_tigres> Saizan: building docs is not on by default ?
15:40:36 <agemo> i just expect it to do this: s id = id z (y z) = z (y z)
15:40:41 <srush> has anyone used libSDL for getting image data?
15:40:42 <agemo> then with the second id
15:41:09 <agemo> s id id = id z (id z) = z (id z) = z z
15:41:12 <Saizan> tristes_tigres: no, you can change that in your ~/.cabal/config file
15:41:15 <agemo> what's wrong with that?
15:41:30 <BMeph> @pl \z -> z z
15:41:31 <lambdabot> join id
15:41:46 <tristes_tigres> saizan: thanks
15:41:56 <BMeph> @pl \y z -> z (y z)
15:41:57 <lambdabot> ap id
15:42:08 <tristes_tigres> no on to trying to find ~ on Windows :-)
15:42:15 <Saizan> ben123: i don't know the details, i've never done that, you'd probably have to install something like msys, however i guess you've to google :)
15:42:29 <agemo> @type ap id
15:42:30 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
15:42:46 <Saizan> tristes_tigres: %AppData% on windows, iirc
15:43:08 <Zao> Saizan: SHGetSpecialFolderPath if you want to do it the right way.
15:43:24 <agemo> @pl \z -> z z
15:43:24 <lambdabot> join id
15:43:27 <agemo> @type ap id
15:43:28 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
15:43:58 * agemo is still not getting it :s
15:44:08 <Saizan> ?type let s x y z = x z (y z) in s
15:44:09 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
15:44:27 <Saizan> agemo: typed combinators are more limited than untyped ones
15:44:32 <Saizan> ?type let s x y z = x z (y z) in s id
15:44:44 <lambdabot> forall t t1. ((t -> t1) -> t) -> (t -> t1) -> t1
15:44:54 <BMeph> agemo: The main problem is that S is untyped, and Haskell is not. :)
15:44:57 <roconnor> It doesn't take much fuzzing around KTorrent to make get it's information out of sync.  Stupid impertive programs.
15:45:10 <roconnor> If only KTorrent was written with GuiTV.
15:45:38 <chessguy> BMeph:  err, s is not ap?
15:45:46 <chessguy> @pl \x y z -> x z (y z)
15:45:46 <lambdabot> ap
15:45:48 <agemo> so it should work if i give s the right type sig? or not?
15:46:11 <Saizan> i'm not sure if you can give it the type signature you want
15:46:21 <agemo> i was afraid of that :)
15:46:34 <chessguy> agemo:  what type signature are you wanting to give it?
15:46:38 <BMeph> chessguy: No, it isn't. 'ap' works the way S does, were S typed, but it isn't the same. :)
15:46:55 * chessguy scratches his head
15:47:05 <chessguy> why does making it typed affect how it works?
15:47:12 <BMeph> chessguy: Under certain circumstances, that is.
15:47:15 <agemo> chessguy: i haven't got a clue really, i was just thinking maybe i could find one that would make it work :)
15:47:38 <Saizan> chessguy: the typedness was initially introduced to remove non-terminating programs
15:48:07 <Saizan> chessguy: but at the same time we have to remove some useful programs
15:48:27 <chessguy> interesting. i don't get why, though
15:48:34 <BMeph> chessguy: Similarly, 'id' and '$' are not the same function, although they do the same thing, with certain arguments.
15:49:04 <chessguy> hm, i thought that was just a question of precedence
15:49:15 <Saizan> no, $ has a different type
15:49:18 <Saizan> less general
15:49:28 <dmwit> chessguy: Consider this.
15:49:42 <dmwit> chessguy: if True then 0 else False -- this "works" in an untyped world
15:50:02 <dmwit> chessguy: Moreover, "if" works the same way in the typed and untyped worlds, *when it is well-typed*.
15:50:20 <dmwit> But it need not always be well-typed of course.
15:50:28 <dmwit> If it were, the type system wouldn't be worth much. =)
15:50:41 <chessguy> i see
15:50:51 <dmwit> There's a similar argument for "ap".
15:51:12 <dmwit> You can apply "ap" to arguments that don't match its type; if you actually evaluated the program, it might run fine, but it wouldn't be well-typed anyway.
15:51:49 <geezusfreeek> i like to envision it as a venn diagram. there is a circle for well behaved programs and a circle for well typed programs, and they overlap a lot but not perfectly
15:51:57 <agemo> @type \z -> z z
15:51:58 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
15:51:58 <lambdabot>     Probable cause: `z' is applied to too many arguments
15:51:58 <lambdabot>     In the expression: z z
15:52:06 <geezusfreeek> the ultimate goal is to make them overlap perfectly
15:52:10 <agemo> @pl \z -> z z
15:52:11 <lambdabot> join id
15:52:14 <agemo> buh
15:52:16 <dmwit> And programming language research is about making the overlap more and more perfect, eh geezusfreeek? ;-)
15:52:34 <dmwit> :t join id
15:52:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
15:52:35 <lambdabot>     Probable cause: `id' is applied to too many arguments
15:52:35 <lambdabot>     In the first argument of `join', namely `id'
15:52:40 <geezusfreeek> dmwit: :)
15:52:46 <dmwit> agemo: You can actually write a well-typed term that does that.
15:52:59 <dmwit> agemo: But you need to use recursive types to reflect the recursive nature of the term. =)
15:53:20 <dmwit> agemo: The "occurs" check merely prevents the type-checker from trying to construct the recursive types itself.
15:53:20 <oskarM> :t (join id :: (forall a.a) -> b)
15:53:21 <lambdabot> forall b. (forall a. a) -> b
15:53:40 <dmwit> (That helps ensure termination of the type-checking.)
15:53:58 <agemo> aha, i see
15:54:10 <agemo> thanks :)
15:55:37 <Saizan> ?type let d f x x = f x x in d id :: (forall a. a) -> b
15:55:38 <lambdabot>     Conflicting definitions for `x'
15:55:38 <lambdabot>     In the definition of `d'
15:55:48 <Saizan> ?type let d f x = f x x in d id :: (forall a. a) -> b
15:55:50 <lambdabot> forall b. (forall a. a) -> b
15:57:02 <agemo> ?type join
15:57:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:57:12 * Saizan is surprised by ghc 
15:57:34 <geezusfreeek> surprised?
15:57:55 <tristes_tigres> Saizan: the docs aren't supposed to register with main library index in ghc docs ?
15:59:00 <Saizan> tristes_tigres: no, there's an open ticket about that on the cabal trac, for now there's a different index for each library
15:59:28 <Saizan> geezusfreeek: i wouldn't have expected it to instantiate d impredicatively
15:59:37 <tristes_tigres> Saizan: thanks again
15:59:45 <ben123> help: missing Data.TupleLevel module
15:59:55 <ben123> which package is that included in?
16:00:40 <Saizan> tristes_tigres: you can find where it's located by ghc-pkg field $pkg haddock-html
16:02:14 <catechu> I have a really simple question about side-effectful computations in Haskell. How are things like IORef consistent with the purity of the language? I understand their encapsulation via monads, but I am still confused. I am not able to find a good explanation of this on the web.
16:02:30 <Botje> catechu: you can only use IORefs inside the IO monad
16:02:36 <Botje> and inside the IO monad, everything goes :)
16:02:39 <Cale> catechu: IO actions are values which merely describe things to be done
16:02:39 <tristes_tigres> Saizan: yep, shows it all right, although I already found it anyways
16:02:43 <opqdonut> catechu: there is a pure model for the io-monad
16:02:50 <opqdonut> the "world state"
16:02:53 <opqdonut> are you familiar with this?
16:02:56 <Cale> catechu: They might describe things to be done with an IORef
16:02:56 <vixey> catechu, I didn't realyl get IORef but STRef
16:03:07 <vixey> catechu, how ST works is very interesting and more isolated
16:03:11 <Cale> opqdonut: ugh, please no ;)
16:03:23 <opqdonut> Cale: well it helps some people
16:03:27 <Cale> I suppose.
16:03:30 <opqdonut> helped me, at least
16:03:43 <Cale> It's easier just to think of IO actions as values which describe some stuff to do.
16:03:58 <Cale> Evaluating them just evaluates the description of what to do, it doesn't cause it to happen.
16:04:04 <opqdonut> it's a useful perspective too
16:04:11 <Cale> So the language remains pure.
16:04:19 <Elly> mmm, monads
16:04:29 <Elly> I always think of monads as producing chains of continuations
16:04:37 <Cale> It's really just the IO monad which is like this
16:04:41 <Elly> which actually a) sequence the effects and b) defer them until "the end" of your program
16:04:43 <opqdonut> Elly: even the Maybe monad?-)
16:05:02 <opqdonut> I just think of monads as a type class, frankly
16:05:04 <Elly> sure
16:05:07 <Elly> maybe can be continuations
16:05:11 <Cale> (and I suppose monads built on top of it)
16:05:43 <Plouj> hi
16:05:46 <Cale> catechu: anyway, does that make sense? We represent effects to be carried out by inert values.
16:05:52 <Plouj> what can I do about this error: http://hpaste.org/13297 ?
16:06:02 <Cale> catechu: Eventually, the 'main' of the program is one of these, and the runtime system executes that one.
16:06:09 <Cale> (which is an impure operation)
16:06:18 <Cale> But evaluation of Haskell expressions is pure.
16:06:18 <ben123> Couldn't find module 'Data.TupleLevel', can anyone point me to where to find/install it?
16:06:25 <StoneToad> Cale: only because the real world is dirty :)
16:07:08 <Cale> StoneToad: Well, also because it is big, and modelling things like the nondeterminism of concurrency is impossible otherwise.
16:07:18 <tristes_tigres> I think that it IS confusing to call Haskell "pure". It is more accurate to say that pure and impure are differentiated at type level
16:07:36 <Cale> It's correct to say that evaluation of Haskell expressions is pure.
16:07:40 <opqdonut> yeah
16:07:43 <dons> yay, xmonad's now more popular than ion, http://tinyurl.com/96o5wk
16:07:57 <Cale> But there are two processes involved in running a Haskell program, which I tend to call evaluation and execution.
16:07:58 <dons> the dragon is slain.
16:08:06 <Cale> Evaluation is reducing expressions to values.
16:08:09 <opqdonut> 0206.25  dons$ the dragon is slain.
16:08:12 <Cale> Execution is carrying out IO actions.
16:08:12 <opqdonut> oops
16:08:14 <StoneToad> what module do I need to import for mapAccumL?
16:08:23 <dons> ?hoogle mapAccum
16:08:23 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
16:08:23 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
16:08:23 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
16:08:25 <Cale> StoneToad: Data.List
16:08:29 <dons> ?hoogle+
16:08:29 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:08:29 <lambdabot> Data.ByteString.Char8 mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
16:08:29 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
16:08:32 <opqdonut> dons: imo xmonad has a lousy windowing model
16:08:42 <ziman> @index mapAccumL
16:08:42 <lambdabot> Data.List
16:08:45 <StoneToad> ahh, I was trying data.traversable :/
16:08:52 <dons> opqdonut: thanks for the insight!
16:09:07 <opqdonut> ion's hierarchical model is better than the ring-buffer-of-ring-buffers that xmonad uses
16:09:08 <dons> you didn't compile with -flousy did you?
16:09:15 <dons> "better" ?
16:09:20 <opqdonut> yes
16:09:23 <dons> less popular?
16:09:27 <dons> more complicated?
16:09:28 <Elly> dons: xmonad is more popular than ion?
16:09:37 <dons> on debian, at least.
16:09:42 <opqdonut> as in I like it more and it allows for richer navigation
16:09:44 <dons> http://tinyurl.com/96o5wk as of today.
16:09:51 <Elly> asparagus now more articulate than zucchini? ;)
16:09:58 <dons> opqdonut: its a different model. i don't think it instances Ord.
16:10:11 <dons> one I personally found less useful, as it wasn't sufficiently automated
16:10:25 <dons> xmonad constrains the range of operation to an automatable subset of layouts
16:10:32 <opqdonut> dons: yes, that's why I said "imo -- bettter --"
16:10:33 <dons> which i think is better.
16:10:37 * Cale just can't stand tiling window managers ;)
16:10:50 * Elly kind of likes the heirarchial model
16:10:52 <opqdonut> of course the fundamental difference is static layout vs dynamic layout
16:10:54 <dons> anyway, thanks for all the support. its good to see haskell apps doing well.
16:11:00 <Elly> although I suspect that what I do would work fine in xmonad too
16:11:02 <Plouj> is OpenGL package the right one to supply the GL module?
16:11:02 * Elly ponders trying it
16:11:08 <opqdonut> i've never abided dynamic ones
16:11:20 <opqdonut> Elly: well xmonad can be made to emulate most ion usage with plugins
16:11:30 <Elly> I don't use most of the things ion can do
16:11:37 <opqdonut> but yeah, xmonad is a sweet haskell application
16:11:39 <Cale> I want a programmable version of Metacity written in Haskell :)
16:11:39 <opqdonut> and a good wm
16:11:43 * erikc prefers xmonad cause there was documentation/plugins for seamlessly replacing metacity with it
16:11:45 <opqdonut> i just think it's overrated :)
16:11:59 <dons> ion's dead, anyway.
16:12:03 <opqdonut> dons: sorry if I seemed aggressive
16:12:21 <dons> i accept that there are , for some reason, lots of personal preferences with user interfaces.
16:12:29 <Elly> dons: dead? it's still running here :P
16:12:30 <dons> xmonad implements a particular model, emphasising automation
16:12:37 <Cale> erikc: Except, not so seamless, because you're more or less stuck with tiling.
16:12:42 <dons> Elly: not active as a project. look at the graphs.
16:12:47 <Cale> ;)
16:13:00 <Elly> dons: oh, I know; tuomov is done with it
16:13:06 <opqdonut> yeah ion3 is maintained, not developed
16:13:09 <Elly> and his code is, shall we say, 'sufficiently interesting'
16:13:33 <mib_syvo2g> hey guys trying to build lambdabot on my home pc using the the cabal source and i am getting some errors
16:13:39 <opqdonut> well it's certainly highly original
16:13:50 <Elly> he has his own object system and such
16:13:53 <opqdonut> but it's also good C, and lua is a good choice for an extension language
16:13:54 <Elly> all implemented in C with macros
16:14:03 <opqdonut> but we're going off on a tangent
16:14:10 <Elly> yep
16:15:00 <Elly> darcs is also really good
16:15:05 <dons> i'm not sure how great it is though. there's not that active an extensions suite. maybe people don't/find it harder to distribute ion extensions?
16:15:17 <dons> while xmonad tries to ensure safe, type correct extensions all from one central repo.
16:15:24 <dons> so we're a bit better at bundling and centralising extensions
16:15:27 <Elly> dons: honestly? the only ion extensions I've ever seen are the lua scripts on the website
16:15:28 <opqdonut> yeah the community around xmonad is better
16:15:39 <Elly> and those are all simple "put the contents of a thing in /proc in the status bar"
16:15:49 <Saizan> is there a description of the ion's hierarchical model somewhere?
16:15:57 <dons> Elly: right, while there's hundreds of things for xmonad, some fairly big engineering projects
16:15:57 <Elly> Saizan: the man page
16:16:04 <opqdonut> Saizan: the "Configuring and extending ion3 with lua" manual
16:16:09 <opqdonut> on the web site
16:16:14 <dons> maybe haskell's better for building complicated extensions, or our embedding is deeper?
16:16:22 <Elly> maybe both
16:16:24 <Elly> no idea
16:16:28 <opqdonut> dons: this is also because xmonad is "designed" to be extended with layouts etc
16:16:31 <Elly> hm
16:16:32 <dons> yeah.
16:16:34 <Elly> xmonad didn't build
16:16:37 <opqdonut> ion's design is much more self-contained
16:16:44 <dons> it wasn't accidental, xmonad blurs the library/extension line
16:17:03 <Elly> Module 'Control.Exception' does not export 'Exception(ExitException)'
16:17:08 * Elly ponders this turn of events
16:17:13 <Plouj> hello?
16:17:21 <dons> Elly: --constraint='base<4'
16:17:21 <mib_syvo2g> the cabal build of lambdabot is not installing
16:17:24 <SQlvpapir> haha this rocks :D http://www.fianceexposed.com/index.php?c=viral&m=index&id=4b9baa900fba41b4151ac0f19d0cf590 :D:D
16:17:38 <Saizan> mib_syvo2g: which problems are you having?
16:17:42 --- mode: ChanServ set +o dons
16:17:43 <opqdonut> dons: btw isn't popcon automated and based on apt?
16:17:52 <Elly> dons: passed to what?
16:17:57 --- mode: dons set +b *!*n=teis@*.virnxx10.dynamic.dsl.tele.dk
16:17:57 --- kick: SQlvpapir was kicked by dons (dons)
16:18:01 --- mode: ChanServ set -o dons
16:18:04 <opqdonut> most people compile their ion manually because of the packaging and licensing problems about a year agou
16:18:06 <dons> opqdonut: i think it is op-in.
16:18:09 <Elly> evidently configure
16:18:15 <Elly> yes, my ion is hand-compiled
16:18:17 <dons> opqdonut: well, that might be. you'd have to show that.
16:18:21 <Elly> the one in apt is years and years old
16:18:24 <Elly> or was last time I looked
16:18:25 <dons> (and show xmonad's not similar)
16:18:36 <dons> its an interesting point.
16:19:23 <mib_syvo2g> hsmodule  not in scope
16:19:34 <mib_syvo2g> getting some not in scope errors:::::
16:19:57 <Elly> hm... xmonad doesn't install so well as non-root :(
16:20:09 <opqdonut> well anyway, i'm off to sleep
16:20:11 <dons> Elly: cabal install
16:20:17 <Saizan> Elly: pass --user to configure
16:20:22 <Elly> oh, oops
16:20:24 <dons> Elly: its entirely happy as non-root. cabal will use --user by default
16:20:30 <Elly> I didn't use cabal
16:20:46 <Saizan> mib_syvo2g: which version of ghc are you using?
16:20:50 <dons> ah well. there's your problem :)
16:20:55 <dons> you'd be home by now if you had.
16:20:56 <mib_syvo2g> 6.10.1
16:21:00 <Elly> there we go
16:21:03 <Elly> brb, xmonad :)
16:21:25 <gwern> Elly: xmonad installs fine as nonroot. I run everything haskell as nonroot
16:21:36 <gwern> as people are saying you just need the prefix and user options
16:21:37 <ben123> Couldn't find module 'Data.TupleLevel', can anyone point me to where to find/install it?
16:21:39 <geezusfreeek> s
16:21:43 <geezusfreeek> oops, sorry
16:21:47 <dons> TupleLevel ?
16:21:47 <dons> mm
16:21:51 <Plouj> how do I remove a cabal-installed package?
16:22:14 <ben123> dons: yes
16:22:19 <dons> Plouj: ghc-pkg --remove foo
16:22:25 <ben123>     Could not find module `Data.TupleLevel':
16:22:25 <ben123>       locations searched:
16:22:25 <ben123>         Data\TupleLevel.hs
16:22:25 <ben123>         Data\TupleLevel.lhs
16:22:28 <dons> ben123: sounds like something from hackage.
16:22:29 <ben123>  
16:22:30 <Saizan> unregister i think
16:22:33 <dons> unregister, sorry
16:22:36 <dons> brain-o
16:22:57 <ben123> dons: so how do i check, simple googling didn't yield anything
16:23:02 <dons> go to hackage.haskell.org
16:23:06 <dons> click on packages
16:23:08 <dons> and then search
16:25:03 <ben123> dons: nothing there
16:26:03 <dons> ben123: what package is this you're trying to build?
16:26:34 <ben123> i was trying to build the HVAC package, and i
16:26:39 <Elly> hehe
16:26:43 <Elly> I probably should've asked this earlier
16:26:49 <ben123> saw this 'import Data.TupleLevel' statem
16:26:52 <ben123> statement
16:26:56 <Elly> but how does one spawn terminals in xmonad?
16:27:02 <dons> Elly: mod-shift-return
16:27:09 <Elly> ah
16:27:13 <Elly> that was, er, my next guess :P
16:27:16 <dons> (or other ways, e.g. prompts, et al)
16:27:22 <dons> Elly: go through the tutorial
16:27:33 <dons> ben123: talk to the hvac author
16:27:38 <dons> might be an untracked dependnecy
16:27:39 <matthewp> dons: have you updated the selenium package for Selenium 1.0 at all?  Can't get mine to work without session exceptions
16:27:44 <dons> matthewp: hey.
16:27:48 <dons> mm. no, i don't think so.
16:27:53 <dons> we've not been using it recently.
16:27:57 <gwern> hvac doesn't seem to be on hackage.
16:28:03 <matthewp> dons: ok, thanks, just curious
16:28:11 <dons> matthewp: i can get the repo online, if you're interested
16:28:20 <matthewp> dons: sure
16:28:21 <dons> oh, it already is.
16:28:49 <dons> http://code.haskell.org/selenium/
16:28:53 <matthewp> dons: I downloaded last night to play around with it. was seeing how far you got there
16:29:08 <dons> we did a fair bit with it about this time last year.
16:29:13 <dons> but haven't needed it much since then
16:29:22 <dons> so welcome patches
16:29:29 <ben123> i guess i'll have to send the author a note
16:29:32 <matthewp> dons: ok, I'll have to tinker around with it
16:29:34 <dons> ben123: yeah
16:29:37 <dons> matthewp: sweet.
16:29:57 <Elly> dons: where's the tutorial?
16:30:07 <dons> Elly: xmonad.org/ documentation/ tour
16:30:12 <Elly> thanks!
16:30:18 <dons> there's also a few videos
16:30:21 <ben123> dons: is hvac the best lightweight webframework for haskell today? i didn't like happs
16:30:30 <dons> ben123: i've never heard of anyone using hvact.
16:30:48 <dons> happs is heavy, but powerful. kibro and turbinado are gaining followers.
16:30:58 <gwern> @where hvac
16:30:58 <lambdabot> I know nothing about hvac.
16:31:10 <ben123> oh, so besides happs, what is being used for production?
16:31:12 <gwern> hvac is a terrible name
16:31:14 <ben123> or stable enough
16:31:26 <gwern> isn't turbinado's author using it as part of his job?
16:31:29 <dons> ben123: fastcgi+xhtml+{...misc libs...}
16:31:35 <dons> happs also used in production
16:31:42 <dons> gwern: yep
16:31:42 <Elly> oh, cool!
16:31:44 <Elly> mod-space
16:31:50 <dons> Elly: yeah, cycle through layouts
16:31:55 <dons> you can add or write your own
16:32:04 <dons> yay for automation
16:32:05 <gwern> hvac is cabalized. wonder why it's not on hackage
16:32:09 <Saizan> mib_syvo2g: in lambdabot.cabal's build-depends change "haskell-src-exts>=0.3.6" to "haskell-src-exts>=0.3.6 && < 0.4"
16:32:14 <dons> gwern: inneresting. talk to the author
16:32:16 <gwern> @seen sclv
16:32:17 <lambdabot> sclv is in #ghc, #haskell-blah, #haskell, #scala and #darcs. I last heard sclv speak 17h 41m 38s ago.
16:32:37 <dons> oh, sclv's the author?
16:32:47 <gwern> @ask sclv hey, why isn't hvac on hackage if it's cabalized?
16:32:48 <lambdabot> Consider it noted.
16:32:52 <dons> well, i'd definitely think about it then. may even be used at work..
16:32:54 <gwern> dons: well, the repo for it is apparently: http://community.haskell.org/~sclv/hvac/
16:32:57 <gwern> you tell me :)
16:33:01 <dons> prob. just not done yet.
16:33:07 <dons> but talk to him sweetly
16:33:11 <ben123> @ask sclv what is Data.TupleLevel
16:33:11 <lambdabot> Consider it noted.
16:33:13 <mib_syvo2g> gwern: i have haskell-src-exts 0.4.6 installed
16:33:23 <gwern> then we shall chant 'release early, release often' at sclv until he submits
16:33:41 * dons has 184 new packages to update for Arch.
16:33:48 <dons> would people stop releasing so much haskell code!?
16:33:58 <blackdog_> we are the knights who say 'git push'
16:34:01 <gwern> dons: I keep tellign you man, just set up a cron job :)
16:34:09 <Elly> dons: what are the attractions of arch over gentoo?
16:34:10 <dons> gwern: yeah.
16:34:18 <dons> Elly: mm. I use it? :)
16:34:19 <gwern> blackdog_: you said it! oh no
16:34:21 <mib_syvo2g> Saizan i have haskell-src-exts 0.4.6 installed
16:34:31 <Elly> dons: yeah; I've been toying with the idea for a while
16:34:35 <Elly> my current system is gentoo
16:34:35 <gwern> 'cabal: cannot configure hvac-0.1. It requires staticrecord -any
16:34:37 <gwern> hm
16:34:53 <gwern> ah, http://community.haskell.org/~sclv/staticrecord/
16:35:02 <Saizan> mib_syvo2g: yeah, that's too new
16:35:02 <dons> ah
16:35:14 <mib_syvo2g> oh
16:35:34 <dons> 940 haskell packages on hackage...
16:35:35 <Saizan> mib_syvo2g: i've just built it with 0.3.12
16:35:41 <dons> we'll hit 1k just in the new year i think
16:36:11 <ben123> has anyone looked at hvac from here?
16:36:21 <dons> sclv has.
16:36:24 <dons> :)
16:36:30 <dons> its unreleased though, so prob. not.
16:36:35 <Elly> hm
16:36:40 <dons> hmm!!
16:36:42 <Elly> this is really slick, but I think I will stick with ion3
16:36:48 <dons> Elly: wow, that was quick.
16:37:02 <Elly> I have been playing with it
16:37:12 <Elly> well, I guess I will play with xmonad a while longer
16:37:13 <dons> Elly: think about the long term trend though. what is this telling you: http://tinyurl.com/96o5wk
16:37:16 <gwern> @hoogle CalendarTime
16:37:17 <lambdabot> No results found
16:37:32 <pejo> dons, since there's just 500 of us here that means we have to make 2 packages each to reach 1000!
16:37:34 <Elly> dons: that software with more users is always better!
16:37:40 <saoqw> ?src map
16:37:41 <lambdabot> map _ []     = []
16:37:41 <lambdabot> map f (x:xs) = f x : map f xs
16:37:43 <dons> pejo: we only need 60 new packages..
16:37:47 <dons> Elly: yes!!
16:37:55 <dons> more users == more extensions == more stable == better docs.
16:37:59 <ben123> what about turbindo?
16:38:06 <Elly> dons: so, about this windows thing...
16:38:06 <dons> its new, it is crunchy?
16:38:21 <dons> Elly: yeah, lots of users, lots of extensions, lots of bug fixes (and new bugs), and lots of docs.
16:38:27 <gwern> Elly: as dons says, in the long run, # of users is an important proxy for it being maintained, bugfree, and understandable
16:38:29 <dons> you might want to keep code size in mind.
16:38:40 <dons> ion is about 20k lines of C++, xmonad is about 1k lines of Haskell.
16:38:44 <Elly> code size for haskell vs C is cheating :P
16:38:54 <dons> well, if haskell's 20x more concise, yes.
16:38:55 <gwern> @hoogle CalendarTime
16:38:55 <lambdabot> No results found
16:39:05 <dons> 20x less bugs, since bugs are constant per line of code?
16:39:12 <gwern> I is confused about CalendarTime :(
16:39:22 <Elly> hm
16:39:26 <Elly> I like having vim keys for movement
16:39:26 <dons> ion has one maintainer, xmonad has a dozen devs
16:39:34 <dons> so do i. vim keys are awesome.
16:39:35 <gwern> 'Database/StaticRecord.hs:164:42: Not in scope: type constructor or class `CalendarTime'
16:39:41 <gwern> where is CalendarTime ???
16:39:53 <gwern> http://www.haskell.org/onlinelibrary/time.html has it, but I can't find it anywhere
16:40:20 <dons> time lib?
16:40:31 * araujo just released the last himerge version of this year 
16:40:37 <dons> yay araujo !
16:40:39 <dons> well done.
16:40:42 <dons> premier haskell app.
16:40:45 <gwern> staticrecord already depends on oldtime, and throwing in 'time' to builddepends doesn't work
16:40:53 <araujo> dons, haha, thanks!
16:41:01 <gwern> ironically, I never got a chance to use himerge when I was on gentoo. gtk problems
16:41:38 <araujo> dons, plenty of new features and bug fixes, btw, i have received emails from people interested to get new GUI apps in haskell .. I hope we can see some of these new projects for next year :-)
16:41:56 <Elly> hm
16:42:03 <dons> hmm!
16:42:09 <Elly> I miss my status bar :(
16:42:17 <dons> you get to choose your own with xmonad.
16:42:22 <dons> no particular one is wired in.
16:42:28 <Elly> yeah
16:42:32 <Elly> but I don't know how to do that yet :P
16:42:35 <dons> i use dzen. some use xmobar, or tray apps of various kinds
16:42:45 <dons> its more unixy not to wire in this stuff,  imo.
16:42:55 <dons> keeps open the market for a better status bar app
16:42:57 <Elly> yep
16:43:23 <Elly> it's intriguing that the defauly layout produces the layouts I usually use
16:44:04 * araujo also expects next year to be the year of getting a cabal-install front-end!
16:44:05 <dons> :)
16:44:10 <Elly> ack, mocp is stupid
16:44:12 <dons> Elly: simplicity, optimised for humans.
16:44:17 <Elly> it refuses to start in a terminal it considers "too small"
16:44:19 <Elly> even if the UI fits
16:44:48 <dons> try floating it
16:44:57 <dons> mod-left-click drag
16:44:59 <Elly> I just tricked it instead
16:45:02 <Elly> floating it is stupid though :\
16:45:08 <Elly> it's a console app, it shouldn't care
16:45:24 <dons> yeah.
16:45:31 <Elly> oh, hey, I have the mocp source tarball right here
16:45:32 * Elly fixes
16:46:39 <Elly> there we go
16:46:53 <Elly> damn you dons
16:47:03 <Elly> I had things I wanted to do tonight but now I will spend the night learning about xmonad :P
16:47:12 <dons> haha
16:47:49 <dons> opqdonut: another happy lambda
16:47:56 <gwern> Elly: now you have a new thing you want to do?
16:48:46 <CakeProphet> lambdabot-4.2.2 depends on haskell-src-exts-0.4.6 which failed to install.
16:49:04 <CakeProphet> I've already installed libghc6-src-exts through apt-get...
16:49:40 <CakeProphet> and if I do cabal install haskell-src-exts it says:
16:49:49 <CakeProphet> cabal: happy version >=1.17 is required but it could not be found.
16:51:10 <pejo> Cake, is happy installed and in your path?
16:51:55 <cizra>     Occurs check: cannot construct the infinite type: a = [a]
16:51:58 <cizra> -- what does this mean?
16:52:15 <cizra> > penult :: [a] -> a
16:52:16 <cizra> > penult l = take 1 (drop 1 (reverse l))
16:52:17 <lambdabot>   Not in scope: `penult'
16:52:17 <lambdabot>   <no location info>: parse error on input `='
16:52:36 <cizra> > let penult l = take 1 (drop 1 (reverse l)) in penult [2, 3, 4]
16:52:38 <lambdabot>   [3]
16:52:56 <CakeProphet> pejo, don't know if it's in my path or not. I keep setting .cabal/bin to my path but it goes away
16:53:07 <cizra> It works and seems generic enough for me, but for some weird reason GHC compiler complains about my type declaration. Why?
16:53:07 <mib_syvo2g> lambdabot is still not compiling
16:53:14 <mib_syvo2g> :(
16:53:20 <mib_syvo2g> :(
16:53:23 <Elly> w00t, I fixed mocp
16:55:24 <CakeProphet> :t take
16:55:25 <lambdabot> forall a. Int -> [a] -> [a]
16:55:26 <dmwit> (That helps ensure termination of the type-checking.)
16:55:30 <dmwit> uh
16:55:35 <CakeProphet> cizra:  take returns a [a]
16:55:41 <dmwit> cizra: The actual type is [a] -> [a].
16:55:43 <dmwit> yeah
16:55:52 <dmwit> :t take 1 . drop 1 . reverse
16:55:53 <lambdabot> forall a. [a] -> [a]
16:56:25 <dmwit> :t head . tail . reverse
16:56:26 <lambdabot> forall a. [a] -> a
16:56:32 <cizra> Aha!
16:56:38 <cizra> I get it.
16:56:50 <dmwit> :t (!!1) . reverse
16:56:51 <lambdabot> forall a. [a] -> a
16:57:12 <dmwit> :t length >>= (!!)
16:57:13 <lambdabot>     Couldn't match expected type `Int' against inferred type `[a]'
16:57:13 <lambdabot>       Expected type: Int -> [a1] -> b
16:57:13 <lambdabot>       Inferred type: [a] -> Int -> a
16:57:13 <chessguy> > reverse [1.]
16:57:14 <lambdabot>   <no location info>: parse error on input `]'
16:57:19 <chessguy> > reverse [1..]
16:57:24 <dmwit> oh
16:57:26 <dmwit> :t length >>= flip (!!)
16:57:28 <lambdabot>   mueval: Prelude.read: no parse
16:57:32 <lambdabot> forall a. [a] -> a
16:57:40 <chessguy> > kill the thread
16:57:42 <lambdabot>   Not in scope: `kill'Not in scope: `the'Not in scope: `thread'
16:57:55 <dmwit> > (length >>= flip (!!)) [1..30]
16:57:57 <lambdabot>   * Exception: Prelude.(!!): index too large
16:58:03 <dmwit> quite
16:58:13 <dmwit> > (length >>= flip (!!) . subtract 2) [1..30]
16:58:14 <lambdabot>   29
16:58:19 <CakeProphet> what is >>=
16:58:24 <dmwit> :t (>>=)
16:58:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:58:27 <dmwit> It's monadic bind.
16:58:31 <dmwit> In the Reader monad,
16:58:35 <dmwit> it has this type:
16:58:37 <CakeProphet> ah... still haven't learned monads yet.
16:58:38 <mib_syvo2g> ghci.iobase does not export Exception () ???
16:58:43 <mib_syvo2g> anyone??
16:58:49 <dmwit> :t (>>=) :: (e -> a) -> (a -> e -> b) -> (e -> b)
16:58:50 <lambdabot> forall e a b. (e -> a) -> (a -> e -> b) -> e -> b
16:59:13 <CakeProphet> I've never seen forall in a function signature.
16:59:19 <dmwit> CakeProphet: You can probably imagine how to write that function just from its type.
16:59:26 <dmwit> (You can safely ignore the forall at the beginning.)
16:59:26 <luqui> CakeProphet, it's redundant in this case
16:59:30 <Elly> hm...the xmonad write-a-config-file tutorial is incorrect - it refers to XMonad.Util.EZConfig, which doesn't exist here
16:59:43 <dmwit> Elly: Have you installed XMonadContrib?
16:59:45 <CakeProphet> hmmm...
16:59:48 <Elly> probably not :P
16:59:49 <dmwit> ?hackage xmonad-contrib
16:59:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xmonad-contrib
16:59:51 <Elly> this is the one portage installed
16:59:53 <CakeProphet> I can see how the types interact... but not what it accomplished
16:59:58 <luqui> actually... there is only one total implementation of that function
16:59:59 <dmwit> Elly: These questions would probably go best on #xmonad.
17:00:02 <Elly> oh, oops
17:00:06 <dmwit> Elly: Just to prevent from cluttering up this channel. =)
17:00:34 <dmwit> luqui: Up to contextual equivalence, I guess.
17:00:46 <CakeProphet> :i (>>=)
17:00:51 <CakeProphet> ...
17:00:51 <dmwit> No :i here.
17:00:55 <CakeProphet> ah
17:01:06 <CakeProphet> :k Int
17:01:06 <lambdabot> *
17:01:08 <luqui> dmwit, what do you mean by that?
17:01:08 <CakeProphet> :D
17:01:20 <CakeProphet> :k IO
17:01:21 <lambdabot> * -> *
17:01:22 <luqui> > fix error
17:01:24 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
17:01:41 <dmwit> luqui: Well, id = \x -> x and id = (\y -> y) (\x -> x) are different total implementations of the (a -> a) type.
17:01:55 <CakeProphet> do you ever get anything but *'s in a kind?
17:01:58 <dmwit> luqui: But I think most people would agree that they are not sufficiently different to warrant any special notice.
17:02:02 <luqui> dmwit, *extensional*.  geez am I the only one who thinks that way?
17:02:10 <augustss_> CakeProphet: * and ->
17:02:10 <dmwit> ;-)
17:02:15 <CakeProphet> and ()'s
17:02:23 <dmwit> CakeProphet: *, #, ?, and ??
17:02:30 <CakeProphet> what are the others.
17:02:30 <dmwit> CakeProphet: No ()'s.
17:02:35 <dmwit> # - unboxed types
17:02:42 <augustss_> dmwit: CakeProphet: Those are ghc specific
17:02:44 <CakeProphet> example?
17:02:47 <CakeProphet> oh
17:02:50 <dmwit> augustss_: Well, right.
17:02:51 <Elly> gack, xmonad-contrib from the haskell overlay doesn't build!
17:03:12 <CakeProphet> :t return
17:03:13 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:03:27 <CakeProphet> what does forall do?
17:03:30 <gwern> Elly: hackage xmoand and xmc are broken with 6.10. use darcs
17:03:44 <dmwit> CakeProphet: It explicitly scopes type variables.
17:03:48 <Elly> gwern: oh
17:03:54 <augustss_> CakeProphet: It's universal quantification
17:04:13 <CakeProphet> hm.... so it takes a kind description thing?
17:04:18 <dmwit> For example, in the type (forall a. a) -> a, the a's before and after the (->) are "different" a's.
17:04:27 <dmwit> Optionally, yes.
17:04:56 <luqui> it's kinda like lambda at the type level (not exactly though...)
17:05:01 <augustss_> CakeProphet: you can ignore the foralls for now
17:05:06 <CakeProphet> alright.
17:05:35 <CakeProphet> hmmm... oh wait. but wouldn't (forall a. a) specify nothing?
17:05:38 <augustss_> luqui: It's not like lambda at the type level, except that it's a binder
17:05:48 <augustss_> CakeProphet: that's right
17:05:57 <dmwit> CakeProphet: In vanilla Haskell, all types have their "forall"s at the very beginning.
17:06:06 <luqui> augustss_, heh, yeah, thus "not exactly"...
17:06:16 <dmwit> So, yeah, you can mostly ignore them.
17:06:21 <luqui> I mean, and it represents a substitution
17:06:43 <CakeProphet> dmwit:  well it does tell me that m in return specifies a type constructor
17:06:49 <CakeProphet> but I can infer that from a -> m a
17:07:04 * dmwit nods
17:07:05 <luqui> CakeProphet, sure, as you can infer that the type of \x -> x is a -> a
17:07:10 <luqui> we write it anyway...
17:07:17 <luqui> (but we usually don't for types)
17:07:20 <dmwit> You can also infer it from the annotation (Monad m) => ...
17:08:23 <CakeProphet> is there a way to get information about what functions instances of a typeclass implement?
17:08:26 <CakeProphet> via lambdabot?
17:08:31 <dmwit> ?src Monad
17:08:31 <lambdabot> class  Monad m  where
17:08:31 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:08:31 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:08:31 <lambdabot>     return      :: a -> m a
17:08:31 <lambdabot>     fail        :: String -> m a
17:08:33 <augustss_> CakeProphet: if you want to know more, you can take a look at System F, or the lambda cube
17:08:37 <CakeProphet> ah.
17:08:58 <CakeProphet> augustss_:  how would I go about doing that?
17:09:33 <luqui> for a great book, Types and Programming Languages by Pierce. I'm sure there are excellent online resources too.
17:10:16 <CakeProphet> hmmm...
17:10:53 <augustss_> CakeProphet: I have some blog entries about the lambda cube, http://augustss.blogspot.com
17:10:55 <CakeProphet> > fail "lol fail" :: IO ()
17:10:56 <lambdabot>   * Exception: "<IO ()>"
17:11:07 <CakeProphet> > fail "lol fail"
17:11:08 <lambdabot>       No instance for (Show (m a))
17:11:08 <lambdabot>        arising from a use of `show' at <in...
17:11:15 <luqui> Honestly though, I found most of it obvious, at least enough to use it and have a model of what's going on.  Implementation is a bit more subtl.e
17:11:22 <CakeProphet> :t fail "lol fail"
17:11:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
17:11:25 <luqui> obvious once I got used to it, that is
17:11:32 <CakeProphet> I can't figure out what fail does
17:11:46 <luqui> > fail "lol fail" :: [Int]
17:11:48 <lambdabot>   []
17:12:08 <CakeProphet> ?
17:12:11 <luqui> CakeProphet, it is called automatically when a pattern match <- fails in do notation
17:12:19 <CakeProphet> oh
17:12:33 <luqui> > do { Just x <- return Nothing}  -- same as fail
17:12:34 <lambdabot>   <no location info>:
17:12:34 <lambdabot>      The last statement in a 'do' construct must be an ...
17:12:37 <augustss_> CakeProphet: fail is an abomination.  It's best ignored. :)
17:12:39 <luqui> > do { Just x <- return Nothing; return x }  -- same as fail
17:12:39 <Saizan> CakeProphet: it's supposed to represent a failing computation, some monads have an useful value for that
17:12:41 <lambdabot>       No instance for (Show (t a))
17:12:41 <lambdabot>        arising from a use of `show' at <in...
17:13:08 <luqui> it is nice that it exists for practical purposes, but really it should not so much be in Monad as MonadFail or somesuch
17:13:09 <CakeProphet> so what exactly happens when you <- in do
17:13:22 <CakeProphet> I know what it does for IO
17:13:24 <CakeProphet> but in general.
17:13:30 <porges> it depends on the monad
17:13:34 <luqui> it gets rewritten to >>=.
17:13:34 <Saizan> ?undo do { Just x <- return Nothing; return x }
17:13:35 <lambdabot> return Nothing >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
17:13:36 <pumpkin> >>=
17:13:43 <luqui> Saizan, very nice
17:14:27 <CakeProphet> hmmm
17:14:39 <CakeProphet> ?undo 2+2
17:14:39 <lambdabot> 2 + 2
17:14:44 <CakeProphet> ...
17:14:50 <Saizan> every monad defines its own >>= and return
17:14:54 <luqui> undo undoes do notation
17:14:58 <CakeProphet> so how does <- map to >>=
17:15:31 <Saizan> do x <- foo; bar == foo >>= \x -> bar
17:16:25 <CakeProphet> what's the semicolon and I think I'll get that.
17:17:07 <Saizan> the semicolon is to disable layout, so you can write multiple lines in one
17:17:18 <Saizan> do x <- foo
17:17:22 <Saizan>    bar
17:17:27 <CakeProphet> ...oh...
17:17:28 <Saizan> that's the same ^^^
17:17:55 <CakeProphet> can lambdabot take input?
17:18:07 <pumpkin> not in the stdin sense
17:18:15 <CakeProphet> hmmm...
17:18:17 <CakeProphet> that would be nice.
17:18:40 <Saizan> IO is not allowed
17:19:01 <CakeProphet> how can I make the equivalent of typing in input?
17:19:04 <CakeProphet> in my code.
17:19:35 <CakeProphet> :t IO String
17:19:37 <lambdabot> Not in scope: data constructor `IO'
17:19:37 <lambdabot> Not in scope: data constructor `String'
17:19:43 <Saizan> :t getLine
17:19:45 <lambdabot> IO String
17:19:58 <Axman6> @info IO
17:19:58 <lambdabot> IO
17:20:02 <Saizan> i'm not sure i get waht you're asking
17:20:09 <trygvis> anyone know how the ghc build system figure out which binary to use as its assembler?
17:20:18 <CakeProphet> I basically want to make a program that gets input but uses >>= instead of <-
17:20:27 <CakeProphet> so I can figure out how >>= works for IO
17:20:41 <CakeProphet> and then how it works for monads.
17:20:45 <CakeProphet> in general.
17:20:55 <pumpkin> just use @undo to undo your normal do statement
17:20:59 <Saizan> well, try "getLine >>= \x -> putStrLn x" for example
17:21:01 <pumpkin> and write the output into your program
17:21:05 <Axman6> @undo do str <- getLine; putStrLn.map toUpper str
17:21:05 <lambdabot> getLine >>= \ str -> putStrLn . map toUpper str
17:21:13 <pumpkin> ohai Axman6
17:21:23 <Axman6> uuuuuuurrrrggggggghhhhh
17:21:29 <porges> is there a good solution to "do I implement 'class (A b) => B b where ...' or 'class B b where ...' + 'instance (A b) => B b where ...'
17:21:30 <Axman6> just woke up >_<
17:21:59 <Axman6> @pl getLine >>= \ str -> putStrLn . map toUpper str
17:22:00 <lambdabot> (putStrLn .) . map toUpper =<< getLine
17:22:03 <CakeProphet> oh okay... hmmmm
17:22:04 * porges wants http://haskell.org/haskellwiki/Class_system_extension_proposal
17:22:13 <Saizan> CakeProphet: this article describes how to translate do-notation to >>= in detail http://www.haskell.org/haskellwiki/Monads_as_computation
17:22:22 <dmwit> porges: /me too
17:22:36 <Axman6> CakeProphet: i often find that using do notation for IO is much clearer for most tasks
17:22:37 <CakeProphet> Saizan:  alright. I'll give it a read.
17:22:50 <CakeProphet> Axman6:  I'm just trying to figure out monads.
17:22:59 <CakeProphet> but I think I get it for IO
17:23:08 <porges> dmwit: has it been submitted as a feature request for GHC?
17:23:33 <CakeProphet> the IO goes on the right side and a function that handles the line of input goes on the right side.
17:23:39 <augustss_> CakeProphet: the translation from <- to >>= is really simple.  It described in many places.
17:26:26 <CakeProphet> > (return "meow") >>= (\x -> putStrLn x)
17:26:28 <lambdabot>   * Exception: "<IO ()>"
17:26:52 <CakeProphet> :t return
17:26:53 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:26:54 <Axman6> CakeProphet: or just return "meow" >>= putStrLn
17:27:02 <CakeProphet> ...oh right.
17:27:14 <CakeProphet> :t return "meow" >>= putStrLn
17:27:15 <lambdabot> IO ()
17:27:26 <CakeProphet> so then...
17:27:32 <Axman6> can't do IO in lambdabot, for good reason ;)
17:27:43 <CakeProphet> return getLine >>= putStrLn
17:27:47 <pumpkin> :t say
17:27:48 <lambdabot> Not in scope: `say'
17:27:48 <CakeProphet> is the cat program
17:27:49 <duaneb> so
17:27:50 <Axman6> > launchMissiles >> putStrLn "Success!"
17:27:51 <lambdabot>   Not in scope: `launchMissiles'
17:27:52 <pumpkin> > say "ohai"
17:27:53 <lambdabot>   Not in scope: `say'
17:27:57 <duaneb> I'm doing the write-a-scheme-in-48-hours thing
17:28:00 <pumpkin> :t text
17:28:01 <lambdabot> String -> Doc
17:28:06 <pumpkin> > text "ohai"
17:28:07 <duaneb> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
17:28:07 <lambdabot>   ohai
17:28:08 <duaneb> and
17:28:15 <duaneb> I'm trying to do the numerical tower
17:28:21 <duaneb> you guys have any suggestions?
17:28:31 <duaneb> I'm stumped on a good way of handling it.
17:28:40 <dmwit> CakeProphet: Not quite.
17:28:56 <dmwit> CakeProphet: forever (getLine >>= putStrLn) -- this would do
17:29:04 <dmwit> CakeProphet: getContents >>= putStr -- this, too
17:29:08 <Axman6> @src forever
17:29:09 <lambdabot> Source not found. My brain just exploded
17:29:20 <duaneb> @src lambadbot
17:29:20 <lambdabot> Source not found. That's something I cannot allow to happen.
17:29:20 <Olathe> @hoogle forever
17:29:20 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
17:29:29 <dmwit> CakeProphet: return getLine >>= putStrLn -- this will be a type error, because it will try to treat the *IO action* "getLine" as a String.
17:29:37 <Olathe> lambadabot !
17:29:45 <Olathe> It dances all night long !
17:29:48 <dmwit> forever m = m >> forever m
17:29:49 <CakeProphet> dmwit:  did I try to do that?
17:30:11 <baaba> > forever [1]
17:30:12 <lambdabot>   * Exception: stack overflow
17:30:21 <Axman6> heh
17:30:29 <dmwit> CakeProphet: I think so.  Above, you asked if "return getLine >>= putStrLn" was the "cat" program.
17:30:33 <geezusfreeek> :t forever
17:30:34 <Axman6> > forever (Just 1)
17:30:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
17:30:38 <CakeProphet> no
17:30:40 <CakeProphet> I didn't mean return
17:30:42 <CakeProphet> if I typed that
17:30:49 <lambdabot>   thread killed
17:31:01 <dmwit> okay =)
17:31:44 <CakeProphet> and yet this works:
17:31:46 <CakeProphet> take 5 (forever "lol")
17:31:51 <dmwit> Yep!
17:31:55 <dmwit> Lists are a monad, too. =)
17:32:01 <CakeProphet> hmmm
17:32:05 <baaba> > take 5 (forever "lol")
17:32:07 <dmwit> > "lol" >>= "lol"
17:32:09 <lambdabot>   * Exception: stack overflow
17:32:09 <lambdabot>   Couldn't match expected type `Char -> [b]'
17:32:13 <dmwit> whoops
17:32:16 <dmwit> > "lol" >>= const "lol"
17:32:17 <baaba> not really it seems :P
17:32:18 <lambdabot>   "lollollol"
17:32:20 <CakeProphet> > [1] >>= /x -> print x
17:32:22 <lambdabot>   <no location info>: parse error on input `/'
17:32:27 <CakeProphet> > [1] >>= \x -> print x
17:32:29 <lambdabot>   Couldn't match expected type `[b]' against inferred type `IO ()'
17:32:29 <dmwit> CakeProphet: Lists are not the IO monad.
17:32:41 <CakeProphet> dmwit:  how does their >>= work?
17:32:45 <dmwit> CakeProphet: So you can't do IO in a list's "do" block.
17:32:45 <orbitz> > do { x <- "hi"; y <- "hello"; return ([x,y]) }
17:32:48 <lambdabot>   ["hh","he","hl","hl","ho","ih","ie","il","il","io"]
17:32:49 <dmwit> CakeProphet: (>>=) = concatMap
17:32:52 <dmwit> :t concatMap
17:32:52 <baaba> > forever $ putChar 'o'
17:32:54 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:32:54 <lambdabot>   * Exception: "<IO ()>"
17:32:57 <Olathe> @src [] (>>=)
17:32:57 <lambdabot> xs >>= f     = concatMap f xs
17:33:09 <dmwit> ?src concatMap
17:33:09 <lambdabot> concatMap f = foldr ((++) . f) []
17:33:11 <dmwit> ew
17:33:15 <dmwit> concatMap f = concat . map f
17:33:25 <augustss_> yeah
17:33:25 <Olathe> @src concat
17:33:25 <lambdabot> concat = foldr (++) []
17:33:30 <Axman6> heh
17:33:38 <Olathe> @src map
17:33:38 <lambdabot> map _ []     = []
17:33:38 <lambdabot> map f (x:xs) = f x : map f xs
17:33:51 <CakeProphet> hmmm
17:33:54 <augustss_> map should be foldr too
17:33:56 <dmwit> CakeProphet: Take a second to digest this, then run (don't walk!) to You Could Have Invented Monads (and Maybe You Already Did!)
17:33:59 <Olathe> Can ghc fuse foldr and map ?
17:34:04 <Olathe> Or whatever you call it.
17:34:07 <dmwit> ?go you could have invented monads
17:34:10 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
17:34:10 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
17:34:15 <tristes_tigres> hi, anyone remebers the web form where you could paste haskell and get HTML for colorized prettyprinting ?
17:34:17 <augustss_> Olathe: yes
17:34:22 <Olathe> I could have invented monads AND HTML ?
17:34:23 <gwern> hpaste?
17:34:28 <Axman6> concatMap _ [] = []; concatMap f (x:xs) = f x ++ concatMap f xs -- just because
17:34:40 <gwern> Olathe: heck, you could have invented the surreal numbers, too
17:34:48 <Olathe> tristes_tigres: http://hpaste.org/
17:34:53 <CakeProphet> > return [1]
17:34:53 <duaneb> ok
17:34:55 <lambdabot>       No instance for (Show (m [t]))
17:34:55 <lambdabot>        arising from a use of `show' at <...
17:34:57 <duaneb> I want a haskell website
17:35:03 <dmwit> > return 1 :: [Int]
17:35:04 <duaneb> i.e., a website with haskell as the backend
17:35:06 <lambdabot>   [1]
17:35:06 <tristes_tigres> olathe: the coe will stay there
17:35:08 <duaneb> what thing should I use?
17:35:08 <chessguy> ?where happs
17:35:09 <lambdabot> http://happs.org
17:35:10 <dmwit> > return [1] :: [[Int]]
17:35:12 <lambdabot>   [[1]]
17:35:12 <Axman6> duaneb: hpaste
17:35:15 <CakeProphet> ah okay.
17:35:17 <chessguy> duaneb:  ^^
17:35:27 <Olathe> > return [1] :: Evil Int
17:35:27 <wabash> Hey, does Haskell have exceptions like Java, Ruby, etc?
17:35:28 <tristes_tigres> the code will remain permanently on hpaste
17:35:29 <lambdabot>   Not in scope: type constructor or class `Evil'
17:35:34 <dmwit> > return [1] :: e -> [Int]
17:35:36 <lambdabot>       Overlapping instances for Show (e -> [Int])
17:35:36 <lambdabot>        arising from a use o...
17:35:37 <dmwit> wabash: Yes.
17:35:38 <gwern> duaneb: do you like wikis? you could look into gitit. pretty cool
17:35:41 <dmwit> wabash: But don't use them, okay?
17:35:47 <wabash> dmwit: Ok, sure!
17:35:52 <tristes_tigres> and for the disposable fragments that doesn't make sense
17:36:00 <chessguy> wabash:  check out http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
17:36:11 <duaneb> gwern: no, I mean a web framework
17:36:12 <gwern> duaneb: gitit uses git as a backend, and it uses pandoc for crazy exporting abilities of articles in like 15 formats
17:36:13 <duaneb> or something
17:36:20 <dmwit> wabash: We have the ErrorT monad, it's way better than mere exceptions. ;-)
17:36:20 <wabash> dmwit: Actually, my interest is this: If I do arithmetic and cause an overflow, will I know? Or do I have to check a flag like in C?
17:36:26 <dmwit> wabash: ah
17:36:28 <duaneb> gwern: Yea, but i'm not looking for a wikish thing :P
17:36:29 <gwern> duaneb: but... but... wikis! :(
17:36:34 <dmwit> wabash: You will not know.
17:36:36 <CakeProphet> > (return [1] :: e -> [int]) 2
17:36:37 <lambdabot>       Could not deduce (Num int) from the context ()
17:36:37 <lambdabot>        arising from the ...
17:36:45 <dmwit> wabash: Moreover, that does not throw an exception; as proof:
17:36:50 <dmwit> > 2 ^ 3000 :: Int
17:36:52 <lambdabot>   0
17:36:55 <chessguy> CakeProphet:  case matters
17:36:58 <wabash> dmwit: Oh, that sucks.
17:37:01 <CakeProphet> > (return [1] :: e -> [Int]) 2
17:37:04 <CakeProphet> chessguy:  oh right
17:37:04 <lambdabot>   [1]
17:37:14 <Elly> > 2 ^ 3000 :: Integer -- though
17:37:14 <wabash> dmwit:  so how do you do math in Haskell?
17:37:15 <Axman6> > 2^3000 -- wabash this works fine though :)
17:37:16 <CakeProphet> > (return [1] :: e -> [Int]) 5
17:37:17 <lambdabot>   123023192216111717693155881327675251464071389573683371576611802916005880061...
17:37:19 <lambdabot>   [1]
17:37:19 <dmwit> wabash: with Inhteger
17:37:19 <lambdabot>   123023192216111717693155881327675251464071389573683371576611802916005880061...
17:37:23 <CakeProphet> so...
17:37:26 <dmwit> wabash: which *never* overflows =)
17:37:37 <CakeProphet> return [1] :: e -> [Int]
17:37:39 <CakeProphet> makes
17:37:40 <wabash> dmwit: Ok, wait. Integer class is arbitrary big?
17:37:41 <dmwit> wabash: (Although it could theoretically run you out of memory if you screw up.)
17:37:45 <Axman6> wabash: haskell is all about maths ;)
17:37:48 <dons> haha
17:37:49 <chessguy> wabash:  right
17:37:50 <CakeProphet> ... \x -> [1]
17:37:50 <dmwit> wabash: The Integer *type* is arbitrarily big.
17:37:57 <gwern> wabash: Int is limited though
17:37:58 <chessguy> @users
17:37:58 <wabash> Yep! that's what I heard... I really am starting to lean toward it.
17:37:58 <lambdabot> Maximum users seen in #haskell: 581, currently: 539 (92.8%), active: 22 (4.1%)
17:38:01 <dmwit> wabash: The Integral *class* makes no guarantees.
17:38:09 <pumpkin> wabash: there's also a CReal for arbitrarily large non-integral computations
17:38:10 <dons> go go go!
17:38:12 <gwern> > maxBound :: Int
17:38:14 <pumpkin> > pi :: CReal
17:38:16 <lambdabot>   3.1415926535897932384626433832795028841972
17:38:16 <lambdabot>   9223372036854775807
17:38:24 <Axman6> > showCReal 100 pi
17:38:26 <gwern> CReal amuses me. sounds like cereal
17:38:27 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
17:38:33 <chessguy> #haskell is becoming quite the busy place
17:38:37 <chessguy> @index CReal
17:38:38 <lambdabot> bzzt
17:38:43 <chessguy> @hoogle CReal
17:38:44 <lambdabot> No results found
17:38:44 <geezusfreeek> ?users
17:38:44 <lambdabot> Maximum users seen in #haskell: 581, currently: 538 (92.6%), active: 21 (3.9%)
17:38:45 <wabash> dmwit:  Well, does it work like Ruby, where you have a native integer type bounded by the architeture, and then it automatically converts it to the big numer type on overflow?
17:38:49 <gwern> 'what was the multiple murderer's favorite numeric type? CReal!'
17:38:49 <dmwit> > (9223372036854775808, 9223372036854775808) :: (Int, Integer)
17:38:52 <CakeProphet> > (return [1] :: e -> [Char]) 3
17:38:52 <lambdabot>   (-9223372036854775808,9223372036854775808)
17:38:54 <lambdabot>       No instance for (Num Char)
17:38:54 <lambdabot>        arising from the literal `1' at <inte...
17:38:58 <pumpkin> wabash: nope
17:39:01 <dmwit> wabash: No, all conversions must be explicit.
17:39:05 <wabash> Ok.
17:39:07 <CakeProphet> ah okay... it has to be a Num
17:39:11 <dmwit> wabash: We do have both native and bignum versions, namely Int and Integer.
17:39:14 <CakeProphet> > (return [1] :: e -> [Float]) 3
17:39:17 <lambdabot>   [1.0]
17:39:21 <wabash> So I'm gonna assume that 2^31 is the biggest int?
17:39:21 <geezusfreeek> wabash, well, the _implementation_ might do that, but there is no change in type
17:39:29 <pumpkin> wabash: that depends on your arch
17:39:29 <dmwit> wabash: Bad assumption.
17:39:30 <Olathe> The native version is the work of SATAN !
17:39:31 <chessguy> @remember gwern what was the multiple murderer's favorite numeric type? CReal!
17:39:32 <lambdabot> Okay.
17:39:36 <dmwit> wabash: maxBound is the biggest int
17:39:38 <pumpkin> > maxBound :: Int
17:39:38 <wabash> dmwit: ok.
17:39:38 <dmwit> > maxBound :: Int
17:39:41 <lambdabot>   9223372036854775807
17:39:41 <lambdabot>   9223372036854775807
17:39:44 <dmwit> wabash: You are guaranteed at least 29 bits.
17:39:46 <CakeProphet> > (return ["lol"] :: e -> [String]) 3
17:39:47 <dons> wow, haskell-openafp is huge
17:39:47 <wabash> dmwit: Is that like MAX_INT in C?
17:39:48 <lambdabot>   ["lol"]
17:39:49 <dons> 230 modules
17:39:52 <Axman6> lambdabot is 64 bit though
17:39:54 <Olathe> > maxBound :: Word8
17:39:54 <dmwit> wabash: Similar, but it works for other types:
17:39:56 <CakeProphet> ....what a strange function to produce.
17:39:56 <lambdabot>   255
17:39:57 <dmwit> > maxBound :: Char
17:39:58 <wabash> ok.
17:40:00 <lambdabot>   '\1114111'
17:40:01 <gwern> what does haskell-openfap do?
17:40:07 <pumpkin> openfap? :P
17:40:09 <Olathe> > maxBound :: [Int]
17:40:11 <lambdabot>       No instance for (Bounded [Int])
17:40:11 <lambdabot>        arising from a use of `maxBound'...
17:40:13 <dons> mm
17:40:13 <wabash> And if I do a max size number * a max size number, what's the result type?
17:40:16 <CakeProphet> ...rofl. openfap.
17:40:19 <Elly> does hscurses not build with 6.10?
17:40:24 <gwern> -_- hush yall
17:40:27 <Olathe> wabash: The same type you started with.
17:40:27 <dmwit> wabash: (*) returns the same type as its arguments.
17:40:27 <gwern> Elly: dunno. does it?
17:40:29 <chessguy> wabash:  the type doesn't change, but it overflows
17:40:41 <Elly> well, hscurses died building: Class 'Exception' used as a type
17:40:41 <Olathe> Don't go overflowing data types.
17:40:42 <geezusfreeek> > maxBound * maxBound :: Int
17:40:43 <dmwit> > maxBound * maxBound :: Int
17:40:45 <lambdabot>   1
17:40:46 <lambdabot>   1
17:40:49 <dmwit> jinx!
17:40:49 <chessguy> > let x = maxBound :: Int in x * x
17:40:49 <gwern> Elly: easy fix. base < 4
17:40:50 <Axman6> > maxBound * maxBound :: Int
17:40:52 <lambdabot>   1
17:40:52 <CakeProphet> is it actually useful to generate a function that returns the same value for any input.
17:40:53 <lambdabot>   1
17:40:54 <Axman6> damn it
17:40:55 <Olathe> Please stick to the unbounded integers you're used to.
17:40:57 <wabash> chessguy: I see. And then, what would a seasoned Haskell user do to detect and handle overflows?
17:40:58 <dmwit> geezusfreeek: Now you owe me a coke.
17:40:59 <pumpkin> wabash: also note that number literals aren't of specific types
17:41:00 <pumpkin> :t 5
17:41:01 <Elly> gwern: trying to install from portage :(
17:41:02 <lambdabot> forall t. (Num t) => t
17:41:05 <geezusfreeek> blast
17:41:08 <chessguy> wabash:  use Integer
17:41:11 <gwern> CakeProphet: yes. const, for example
17:41:19 <CakeProphet> :t const
17:41:21 <lambdabot> forall a b. a -> b -> a
17:41:24 <gwern> > map (const 1) [2..10]
17:41:26 <CakeProphet> ah
17:41:27 <wabash> chessguy: So basically, you guys all use the Integer type, and never have overflow?
17:41:27 <lambdabot>   [1,1,1,1,1,1,1,1,1]
17:41:31 <dmwit> wabash: Yes.
17:41:34 <wabash> Ok, got it.
17:41:42 <wabash> Thanks for spending the time to explain to a newbie
17:41:42 <Olathe> wabash: Integer is very fast, since it's based on GMP.
17:41:44 <CakeProphet> ah that's cool
17:41:44 <chessguy> wabash:  if there's any chance of an overflow, yes
17:41:48 <Axman6> wabash: depends on what you're doing really
17:41:49 <geezusfreeek> wabash, well, we don't _always_ use Integer
17:41:52 <gwern> wabash: we're supposed to. in practice people use lots of Int stuff, since Int is so common a return type
17:42:03 <wabash> chessguy: If there's no chance, what would the benefit be to using a bounded type?
17:42:14 <dmwit> speed
17:42:16 <wabash> ok.
17:42:20 <chessguy> wabash: the best rule of thumb i've heard is that usually you would use Int for quantities, and Integer for values
17:42:28 <Axman6> the compiler can keep Ints in registers
17:42:30 <wabash> I appreciate the glimpse into this.
17:42:30 <Olathe> There's also some algorithms that require fixed sized numbers, like MD5 and so on.
17:42:35 <wabash> chessguy: ok.
17:42:36 <Saizan> Elly: pass --constraint="base < 4"
17:42:39 <wabash> Axman6: Ah, I see.
17:42:45 <geezusfreeek> chessguy, oh that's a nice rule of thumb
17:42:49 <gwern> Saizan: I understand --constraint doesn't actually work
17:42:52 <Axman6> and, well, registers == fast :)
17:43:04 <chessguy> geezusfreeek: it's not original, wish i could remember who to credit
17:43:08 <dmwit> wabash: I guess Integer is about 2-4 times slower than Int.  Just a guess, but a mildly educated one.
17:43:12 <Saizan> gwern: it works for runghc Setup
17:43:12 <wabash> just out of curiousity, what do people come from that go to Haskell?
17:43:13 <geezusfreeek> not sure i agree with it, but it's a start ;)
17:43:21 <wabash> dmwit: I see. Yeah, makes sense.
17:43:24 <chessguy> wabash:  everywhere
17:43:33 <MyCatVerbs> wabash: academia. ;)
17:43:35 * dmwit came from reddit
17:43:38 <Olathe> wabash: I came from the lovely world of Ruby.
17:43:39 <CakeProphet> I came from Python.
17:43:41 <Axman6> MyCatVerbs: heh
17:43:41 <Saizan> gwern: ans with cabal-install hw won't need it here
17:43:50 <wabash> E.G, Java ppl to Ruby, C ppl to C++, C++ people back to C after reading Torvalds' posts, etc.
17:44:02 <gwern> Saizan: cabal-isntall I meant didn't respect --constraint
17:44:05 <Olathe> It's a regular directed graph !
17:44:08 <wabash> Olathe: Ok, I see. I come from Ruby (not Rails much though; seriously, Ruby)
17:44:10 <Axman6> wabash: it's pretty much a one way from to haskell ;)
17:44:11 <geezusfreeek> i came from Ruby and Io, mostly
17:44:13 <gwern> wabash: I came from nowhere to haskell
17:44:18 <Olathe> Yeah, I don't like Rails too much.
17:44:22 <wabash> gwern: Really? First language?
17:44:24 <chessguy> yeah, but haskell is an ending state :)
17:44:26 <geezusfreeek> but more of a C background before those
17:44:28 <pumpkin> wabash: I did everything non-performance-critical in ruby before haskell
17:44:38 <gwern> wabash: yep. unless you want to count small competency in shell as a language
17:44:40 <wabash> Olathe: I like the ORM for small things. It's flexible and fun.
17:44:43 <Olathe> I tried to do math stuff in Ruby...hahahaha
17:44:45 <Axman6> haskell is the first language i've tried to learn seriously
17:44:51 <Olathe> wabash: Ahh.
17:44:55 <wabash> gwern: Awesome. It's good encouragement for me.
17:45:03 <blackh> wabash: Haskell is one-way. Turn back now!! There is no escape!!!
17:45:10 <chessguy> haskell is my primary personal programming language.
17:45:15 <Axman6> once you're in, you're hooked!
17:45:15 <Olathe> I'm glad Haskell takes the difficulty out of using GMP.
17:45:21 <wabash> blackh:  Almost too late. I seem to hear the siren call.....
17:45:23 <chessguy> blackdog_: that's implicit from the monad laws
17:45:29 <MyCatVerbs> wabash: er, I mean, when a lady and a gentleman love each other very very much...
17:45:31 <chessguy> blackh:  ^^
17:45:33 <gwern> wabash: I always had trouble looking at examples of state, so pure, non-monadic haskell was relatively easy to learn, and once I had made it that far, monadic haskell was handleale
17:45:38 <chessguy> blackdog_:  sorry, mis-nick
17:45:49 <wabash> gwern:  I think you and I have the same idea.
17:46:05 <wabash> FP seems trivial and intuitive; stateful programming frustrating.
17:46:06 <Axman6> wabash: the basics of haskell are very easy to learn. to become an expert often requires a PhD though :P
17:46:08 <blackh> chessguy: blackdog_ is my dog
17:46:20 <chessguy> umm, ok :)
17:46:22 <Olathe> Your dog is on IRC ?
17:46:27 <Axman6> wabash: indeed. though you can have state in haskell too
17:46:31 <gwern> he is a very intelligent dog
17:46:31 <pumpkin> Axman6: would that PhD be in Haskellometry?
17:46:32 <geezusfreeek> i disagree. to become a master _makes_ you a PhD :P
17:46:33 <mgsloan> > showCReal 190 ((1 + sqrt 5) / 2)
17:46:36 <lambdabot>   "1.618033988749894848204586834365638117720309179805762862135448622705260462...
17:46:37 <blackh> Olathe: If I had a dog, then he would be.
17:46:37 <Olathe> I see :)
17:46:39 <CakeProphet> I've always stuck to Python... but my transgression went something like this Python -> C -> esoteric languages no one has ever heard of (brainfuck, befunge) -> Lisp, Perl, Ruby, io, everything else.
17:46:40 <mgsloan> Phi!
17:46:45 <Olathe> Haha, OK.
17:46:48 <wabash> Another question: How about a way to call compiled C code?
17:46:57 <gwern> CakeProphet: how did you get anything done in esolangs?
17:46:57 <pumpkin> wabash: very elegant
17:46:59 <wabash> I'm thinking about CUDA for example, with a big fat GPU
17:46:59 <chessguy> CakeProphet:  you really think other people haven't heard of bf?
17:47:01 <Axman6> wabash: use the FFI
17:47:04 <gwern> wabash: the FFI hand;es that well
17:47:14 <blackh> wabash: The FFI is very good (Foreign Function Interface)
17:47:15 <CakeProphet> gwern, well... I didn't /do/ anything in them, per se.
17:47:24 <geezusfreeek> CakeProphet, i think of those, Io is probably the least known
17:47:27 <wabash> Axman6: gwern, blackh thanks.
17:47:28 <pumpkin> wabash: I dare say even more elegant than ruby's c module system :P which is a lot better than many other languages'
17:47:30 <CakeProphet> some of them can actually be used.
17:47:34 <gwern> wabash: welcome
17:47:34 <geezusfreeek> but also one of the most interesting
17:47:42 <Axman6> wabash: i'm hoping someone will develop ian interface for OpenCL once it's actually out
17:47:54 <wabash> CakeProphet: interesting path.
17:48:01 <CakeProphet> geezusfreeek:  I like io, the only problem is that it still feels like it's in alpha.
17:48:05 <geezusfreeek> haskell's ffi is my favorite ffi that i have run into
17:48:16 <arkx> So, how can I easily call my Haskell modules from Python?
17:48:22 <dons> via the python bridge
17:48:24 <chessguy> wabash:  http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
17:48:27 <geezusfreeek> CakeProphet, i fear that it will eternally feel that way
17:48:31 <dons> people have been blogging about this all week :)
17:48:49 <pumpkin> the channel feels particularly active right now
17:48:50 <pumpkin> @users
17:48:50 <lambdabot> Maximum users seen in #haskell: 581, currently: 540 (92.9%), active: 24 (4.4%)
17:48:55 <gwern> Elly: darcs hscurses works with 6.10
17:49:01 <Axman6> arkx: http://gamr7.com/blog/?p=24
17:49:11 <chessguy> pumpkin:  yeah, it seems like time to talk about splitting the channel more
17:49:13 <CakeProphet> any more cool lambdabot commands I should know?
17:49:17 <chessguy> @quote
17:49:18 <lambdabot> Philippa says: <vincenz> Philippa: forget theory, it's about pragmatics <Philippa> we're talking FP, they tend to be the same thing
17:49:19 <Elly> gwern: apparently the haskell overlay is not tracking darcs very well :(
17:49:21 <arkx> dons, Axman6: thanks!
17:49:25 <pumpkin> someone should help subvert ##c++ by joining lambdabot to it ;)
17:49:33 <gwern> Elly: well, the 6.10 patches went in about dec 1st
17:49:38 <Olathe> @pl \a -> omg a a
17:49:39 <lambdabot> join omg
17:49:39 <gwern> a month isn't *too* bad
17:49:41 <chessguy> @seen lambdabot
17:49:42 <lambdabot> Yes, I'm here. I'm in #haskell-freebsd, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp,
17:49:42 <lambdabot> #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, ##freebsd, #gentoo-uy, #gentoo-haskell, #
17:49:42 <lambdabot> friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
17:50:20 * Axman6 thinks that #unicycling is some cult channel, and refuses to join. He strongly suspects they have nothing to do with unicycling!
17:50:26 <CakeProphet> what's pl
17:50:29 <Elly> poland
17:50:33 <Olathe> @help pl
17:50:34 <lambdabot> pointless <expr>. Play with pointfree code.
17:50:34 <pumpkin> CakeProphet: pointless
17:50:46 <CakeProphet> ...wat.
17:50:47 <Olathe> It gets rid of the input variables.
17:50:56 <Olathe> @pl \a -> a (f a a)
17:50:56 <lambdabot> ap id (join f)
17:51:03 <Olathe> See, no as left.
17:51:06 <gwern> @pl f a b = a
17:51:06 <lambdabot> f = const
17:51:13 <Axman6> @pl f x y z = g x (g y) (h z)
17:51:13 <lambdabot> f = flip flip h . ((.) .) . (. g) . g
17:51:14 <Olathe> No as or bs there.
17:51:20 <Olathe> No xs, ys, or zs.
17:51:29 <chessguy> CakeProphet: it's a way of automatically simplifying code, sometimes
17:51:30 <CakeProphet> @pl  f x y z = g z y x x
17:51:30 <lambdabot> f = flip =<< (flip .) . flip (flip . flip g)
17:51:39 <CakeProphet> ...rofl. that's awesome.
17:51:40 <geezusfreeek> @pl \f x -> f x x x x
17:51:40 <lambdabot> join . join . join
17:51:43 <CakeProphet> it's also a code obfuscator.
17:51:48 <Olathe> @unpl join . join . join
17:51:48 <lambdabot> (\ c -> ((c >>= \ k -> k) >>= \ i -> i) >>= \ d -> d)
17:51:54 <geezusfreeek> it can be
17:51:58 <Olathe> @unpl f \ join . join . join
17:51:59 <lambdabot>  Parse error at "\" (column 3)
17:52:02 <Olathe> @unpl f = join . join . join
17:52:02 <lambdabot> f c = ((c >>= \ k -> k) >>= \ i -> i) >>= \ d -> d
17:52:09 <Olathe> Bah.
17:52:14 <gwern> I wonder if hlint catches f a b = a == const
17:52:18 <Axman6> @pl \ q w e r t y u i o p -> t y p e w r i t e r
17:52:20 <CakeProphet> lambdabot is probably the most impressive bot I've ever seen.
17:52:22 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .)
17:52:22 <lambdabot>  .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . (
17:52:22 <lambdabot> (flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
17:52:22 <lambdabot> optimization suspended, use @pl-resume to continue.
17:52:25 <Axman6> mwahahaha!
17:52:26 <chessguy> @. pl . unpl f = join . join . join
17:52:26 <geezusfreeek> woah
17:52:27 <lambdabot> Plugin `compose' failed with: Unknown command: "f"
17:52:30 <duaneb> CakeProphet: bucket is better
17:52:32 <Olathe> @pl-resume
17:52:38 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . (flip .) . ((flip .) .)) .)) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .
17:52:38 <lambdabot> ) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . ((
17:52:38 <lambdabot> (flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
17:52:38 <lambdabot> optimization suspended, use @pl-resume to continue.
17:52:43 <Axman6> Olathe: nooooooooooooooo!
17:52:43 <Olathe> Evil.
17:52:46 <Olathe> Heheh
17:52:52 <duaneb> @pl-resume
17:53:05 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . join . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . (((((flip .) .) .) .)
17:53:05 <lambdabot>  .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (
17:53:05 <lambdabot> flip .) . ((flip .) .) . flip (flip . (flip .))))
17:53:05 <lambdabot> optimization suspended, use @pl-resume to continue.
17:53:06 <Axman6> i take no responsibility!
17:53:06 <Olathe> I think it gives up eventually.
17:53:11 <ddarius> pumpkin: http://www.xs4all.nl/~weegen/eelis/geordi/
17:53:19 <Axman6> anyway, i need breakfast
17:53:22 <pumpkin> oh I know about geordi
17:53:25 <pumpkin> I enjoy geordi
17:53:29 <Saizan> Olathe: it can loop
17:53:35 <dblazakis> any good pointers on writing a cross platform cabal config?
17:53:47 <pumpkin> ddarius: I was trying to subvert them by putting haskell in their channel though
17:53:49 <CakeProphet> @pl \x y z -> z y x
17:53:49 <lambdabot> flip (flip . flip id)
17:53:51 <pumpkin> but wcstok might not like that
17:53:59 <ddarius> pumpkin: geordi is written in Haskell
17:54:00 <duaneb> dblazakis: 0xfeedface
17:54:03 <wcstok> hmm?
17:54:09 <pumpkin> ddarius: yeah, I know, but it doesn't run haskell :P
17:54:16 <duaneb> dblazakis: 0x126f6e48
17:54:19 <wcstok> oh, right, go die
17:54:23 <ddarius> pumpkin: It will if you write a complex enough C++ expression.
17:54:33 <augustss_> @type \x y z -> z y x
17:54:35 <pumpkin> wcstok: :(
17:54:36 <lambdabot> forall t t1 t2. t -> t1 -> (t1 -> t -> t2) -> t2
17:54:48 <augustss_> @djinn t -> t1 -> (t1 -> t -> t2) -> t2
17:54:49 <lambdabot> f a b c = c b a
17:54:50 <dblazakis> duaneb: those are some *bad* pointers
17:54:51 <CakeProphet> > saveWorld
17:54:53 <lambdabot>   Not in scope: `saveWorld'
17:54:57 <Olathe> Interesting.
17:55:03 <Olathe> @unpl
17:55:03 <lambdabot> ()
17:55:06 <Olathe> @unpl flip (flip . flip id)
17:55:06 <lambdabot> (\ b c f -> f c b)
17:55:19 <Olathe> @type join . join . join
17:55:21 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m a))) -> m a
17:55:23 <CakeProphet> that's pretty impressive.
17:55:31 <Olathe> @djinn (Monad m) => m (m (m (m a))) -> m a
17:55:32 <lambdabot> Error: Class not found: Monad
17:55:35 <CakeProphet> does @type differ from :t?
17:55:36 <Olathe> @djinn m (m (m (m a))) -> m a
17:55:36 <lambdabot> -- f cannot be realized.
17:55:41 <pumpkin> CakeProphet: yeah, wait until you see djinn
17:55:41 <ddarius> CakeProphet: No
17:55:42 <geezusfreeek> @. pl . djinn t -> t1 -> (t1 -> t -> t2) -> t2
17:55:43 <lambdabot> Plugin `compose' failed with: Unknown command: "t"
17:55:45 <augustss_> CakeProphet: no
17:55:56 <chessguy> CakeProphet:  it's all pattern-matching, basically
17:55:59 <Olathe> @type works in private, though.
17:56:01 <lambdabot> parse error on input `in'
17:56:03 <Olathe> :t doesn't.
17:56:05 <lambdabot> parse error (possibly incorrect indentation)
17:56:07 <gwern> @hoogle fst
17:56:08 <lambdabot> package fst
17:56:08 <lambdabot> Prelude fst :: (a, b) -> a
17:56:08 <lambdabot> Data.Tuple fst :: (a, b) -> a
17:56:16 <Olathe> @hoogle (a, b) -> a
17:56:17 <lambdabot> Prelude fst :: (a, b) -> a
17:56:17 <lambdabot> Data.Tuple fst :: (a, b) -> a
17:56:17 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
17:56:34 <gwern> @pl f a b = a
17:56:34 <lambdabot> f = const
17:56:36 <Olathe> So, if I want to get an element out of a list...
17:56:46 <Olathe> @pl Int -> [a] -> a
17:56:46 <lambdabot> (line 1, column 5):
17:56:46 <lambdabot> unexpected ">" or "-"
17:56:46 <lambdabot> expecting variable, "(", operator or end of input
17:56:50 <pumpkin> !! ?
17:56:52 <Olathe> @hoogle Int -> [a] -> a
17:56:53 <lambdabot> Prelude (!!) :: [a] -> Int -> a
17:56:53 <lambdabot> Data.List (!!) :: [a] -> Int -> a
17:56:53 <lambdabot> Prelude drop :: Int -> [a] -> [a]
17:57:01 <gwern> @djin Int -> [a] -> a
17:57:02 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
17:57:03 <pumpkin> > [1..10] !! 4
17:57:05 <gwern> @djinn Int -> [a] -> a
17:57:06 <lambdabot>   5
17:57:06 <lambdabot> Error: Undefined type Int
17:57:07 <Olathe> Yeah, but @hoogle is nice for finding stuff.
17:57:13 <pumpkin> oh :)
17:57:16 <gwern> oh, right. djinn doesn't know lists
17:57:27 <augustss_> gwern: nor Int
17:57:41 <augustss_> djinn has a very small brain
17:57:42 <CakeProphet> what is djinn
17:57:45 <ddarius>  @djinn n :: Int would have a lot of proofs
17:57:49 <chessguy> @help djinn
17:57:50 <lambdabot> djinn <type>.
17:57:50 <lambdabot> Generates Haskell code from a type.
17:57:50 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
17:58:02 <geezusfreeek> @help @.
17:58:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:58:09 <chessguy> @djinn Int
17:58:10 <lambdabot> Error: Undefined type Int
17:58:17 <gwern> @djinn (a,b) -> a
17:58:18 <lambdabot> f (a, _) = a
17:58:18 <geezusfreeek> @help .
17:58:18 <lambdabot> . <cmd1> <cmd2> [args].
17:58:18 <lambdabot> . [or compose] is the composition of two plugins
17:58:18 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
17:58:19 <augustss_> @djinn Bool
17:58:20 <lambdabot> f = False
17:58:28 <geezusfreeek> @. pl djinn t -> t1 -> (t1 -> t -> t2) -> t2
17:58:28 <lambdabot> f = flip (flip . flip id)
17:58:30 <gwern> @djinn (a,b) -> b
17:58:30 <lambdabot> f (_, a) = a
17:58:46 <gwern> CakeProphet: figure it out yet?
17:58:53 <geezusfreeek> @. pl djinn (a,b) -> b
17:58:53 <lambdabot> f = snd
17:58:55 <CakeProphet> it simplifies code?
17:59:08 <geezusfreeek> @djinn a -> b -> a
17:59:08 <lambdabot> f a _ = a
17:59:10 <augustss_> @djinn Mayba a -> (a -> Maybe b) -> Maybe b
17:59:11 <lambdabot> Error: Undefined type Mayba
17:59:20 <CakeProphet> oh...
17:59:21 <gwern> CakeProphet: no. some types are *so* specific and restrictive that there is only one possible way to write a function satisfying it.
17:59:25 <geezusfreeek> mayba you typod
17:59:26 <augustss_> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
17:59:26 <lambdabot> f a b =
17:59:26 <lambdabot>     case a of
17:59:26 <lambdabot>     Nothing -> Nothing
17:59:26 <lambdabot>     Just c -> b c
17:59:28 <CakeProphet> it can make functions out of type signatures?
17:59:37 <geezusfreeek> yes!
17:59:46 <geezusfreeek> with limitations
17:59:51 <CakeProphet> :t >>=
17:59:53 <lambdabot> parse error on input `>>='
17:59:53 <gwern> CakeProphet: thus you can go from the function to the type in every case, but in some cases, you can go from the type to the function! djinn is a demonstration that that is possible and doable
17:59:54 <augustss_> many limitations
17:59:59 <geezusfreeek> :t (>>=)
18:00:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:00:28 <CakeProphet> @djinn forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:00:28 <lambdabot> Cannot parse command
18:00:30 <CakeProphet> ...
18:00:39 <augustss_> CakeProphet: no monads
18:00:46 <geezusfreeek> djinn won't do the forall and won't do the monad
18:01:07 <augustss_> But you can get the code for >>= for specific monads
18:01:18 <geezusfreeek> @src Maybe (>>=)
18:01:18 <lambdabot> (Just x) >>= k      = k x
18:01:18 <lambdabot> Nothing  >>= _      = Nothing
18:01:28 <CakeProphet> @djinn (a -> b -> c) -> (b -> a -> c)
18:01:28 <lambdabot> f a b c = a c b
18:01:45 <gwern> CakeProphet: djinn is more useful as a demonstration of a theoretical result than for actually writing things.
18:01:50 <geezusfreeek> @. pl djinn (a -> b -> c) (b -> a -> c)
18:01:50 <lambdabot> Error : kind error : (KArrow KStar (KVar 3), KStar)
18:01:58 <geezusfreeek> @. pl djinn (a -> b -> c) -> (b -> a -> c)
18:01:58 <lambdabot> f = flip
18:02:03 <CakeProphet> oh sweet...
18:02:06 <CakeProphet> a compose command.
18:02:07 <CakeProphet> ?
18:02:10 <geezusfreeek> yup
18:02:11 <augustss_> yes
18:02:16 <dons> dcoutts_, gwern any ideas what's going on here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Glob-0.3.2
18:02:20 <dons> hlint et al are also like this
18:02:31 <CakeProphet> it would be nice to have a command for embedding command output into other commands. ;)
18:02:35 <CakeProphet> a more general version of @.
18:02:44 <dons> @.
18:02:44 <lambdabot> Not enough arguments to @.
18:02:52 <geezusfreeek> @help .
18:02:53 <lambdabot> . <cmd1> <cmd2> [args].
18:02:53 <lambdabot> . [or compose] is the composition of two plugins
18:02:53 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
18:03:19 <gwern> dons: you are seeing an empty page?
18:03:26 <dons> yeah
18:03:56 <ddarius> gwern: All of the Cont monad can be created using Djinn.
18:04:14 <ddarius> @help @
18:04:14 <lambdabot>  @ [args].
18:04:14 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
18:04:14 <lambdabot>  The commands are right associative.
18:04:14 <lambdabot>  For example:    @ @pl @undo code
18:04:14 <lambdabot>  is the same as: @ (@pl (@undo code))
18:04:19 <gwern> dons: cabal-install downloads it
18:04:38 <gwern> looks like a html generation problem, not the tarball's fault
18:05:03 * gwern shrugs. I have little to do with the adminning the actual webserver. you'll have to wait for dcoutts_ I guess
18:05:03 <geezusfreeek> @ @pl (@djinn (a -> b -> c) -> (b -> a -> c))
18:05:10 <geezusfreeek> @@ @pl (@djinn (a -> b -> c) -> (b -> a -> c))
18:05:10 <lambdabot>  f = flip
18:05:17 <geezusfreeek> there we go, CakeProphet ^
18:05:33 <duaneb> >length [1 ..]
18:05:46 <duaneb> > length [1 ..]
18:05:51 <ddarius> @@ @pl (@run reverse "x y <- y x/")
18:05:51 <duaneb> hrum
18:05:54 <crathman> stuck again on my translation:  http://hpaste.org/13298  ... can get the carmichaels to print out via ghci ....  but can't figure out how to get them to print out from within the main function...
18:05:57 <duaneb> > :t 4
18:06:05 <oklopol> > length [1..]
18:06:07 <duaneb> uhoh
18:06:09 <duaneb> yea
18:06:09 <CakeProphet> beautiful
18:06:10 <geezusfreeek> you killed lb
18:06:15 <duaneb> geezusfreeek: I did :|
18:06:21 <duaneb> lambdabot: sorry!
18:06:25 <ddarius> @@ @pl (@run reverse "x y <- y x\")
18:06:27 <oklopol> what
18:06:28 <geezusfreeek> @yow
18:06:30 <gwern> for some reason enough looping muevals will kill lb
18:06:31 <oklopol> why did it die?
18:06:31 <lambdabot> Plugin `compose' failed with: Missing ')' in nested command
18:06:36 <gwern> > length [1..]
18:06:37 <lambdabot> America!!  I saw it all!!  Vomiting!  Waving!  JERRY FALWELLING into
18:06:41 <CakeProphet> I smell quine time.
18:06:43 <lambdabot> your void tube of UHF oblivion!!  SAFEWAY of the mind ...
18:06:45 <dons> gwern: haskeline too.
18:06:47 <augustss_> > 5 :: Natural
18:06:52 <dons> gwern: wanna ping ross?
18:06:56 <gwern> augustss_: Natural?
18:07:01 <lambdabot>   5
18:07:07 <duaneb> man
18:07:13 <gwern> dons: not particularly. I just finished a long java session and need to get off me computer
18:07:13 <duaneb> something is dragging lambdabot down :/
18:07:17 <dons> ok
18:07:22 <duaneb> dons: you the dude from reddit?
18:07:28 <augustss_> > genericLength [1..] > (5::Natural)
18:07:29 <duaneb> dons: I'm the guy who didn't like RWH
18:07:39 <sjanssen> everybody get 'im!
18:07:39 <lambdabot>   True
18:07:42 <duaneb> dons: i have a question reguarding the (your?) book
18:07:44 <CakeProphet> what's the shortest known Haskell quine?
18:07:45 <augustss_> yay!
18:07:56 <duaneb> regarding*
18:08:07 <duaneb> dons: do you have a pdf version?
18:08:11 <duaneb> dons: I bought the book!
18:08:18 <augustss_> gwern: yes, Natural numbers.  Lazy naturals.
18:08:37 <CakeProphet> ?src Natural
18:08:41 <lambdabot> Source not found. Do you think like you type?
18:08:42 <CakeProphet> :o
18:08:42 <dons> duaneb: there's a .pdf "e-book"
18:08:45 <sjanssen> @keal
18:08:51 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
18:09:07 <duaneb> dons: is that freely available?
18:09:11 <dons> gwern: i'm surprised "tetris" wasn't taken, http://aur.archlinux.org/packages.php?ID=22474
18:09:17 <dons> duaneb: not at the moment. only the html vers.
18:09:27 <dons> gwern: isn't "tetris" patented?
18:09:35 <duaneb> dons: ahh, sadness
18:09:48 <dons> if you have the hard copy i beleive the ebook is free
18:09:50 <duaneb> dons: tetris is patented, but they're having trouble protecting it
18:09:51 <dons> check the back cover
18:09:58 <ddarius> > ap(++)show"ap(++)show"
18:09:59 <duaneb> dons: excelletn
18:10:00 <lambdabot>   "ap(++)show\"ap(++)show\""
18:10:02 <duaneb> excellent*
18:10:13 <dons> there's some 30 day thing where you get the online vers.
18:10:18 <SamB_XP> duaneb: they should be!
18:10:37 <augustss_> ddarius: that's a nice one!
18:10:45 <CakeProphet> > let q s = putStrLn $ s ++ show s in q "let q s = putStrLn $ s ++ show s in q "
18:10:47 <lambdabot>   * Exception: "<IO ()>"
18:10:51 <CakeProphet> :(
18:11:11 <augustss_> CakeProphet: No IO in lb
18:11:40 <dons> augustss_: haskell-llvm natively packaged, http://aur.archlinux.org/packages.php?ID=18018
18:11:59 <CakeProphet> > let q s = s ++ show s in q "let q s = s ++ show s in q "
18:12:00 <lambdabot>   "let q s = s ++ show s in q \"let q s = s ++ show s in q \""
18:12:11 <FunctorSalad> > 1
18:12:13 <lambdabot>   1
18:12:14 <augustss_> dons: Cool.  Even cooler had I been a linux user ;)
18:12:32 <duaneb> dons: damn, just built that >.<
18:12:51 <dons> augustss_:  :P
18:13:12 <CakeProphet> @@ @run (@run (@run let q s = putStrLn $ s ++ show s in q "let q s = putStrLn $ s ++ show s in q "))
18:13:15 <lambdabot>   <no location info>: parse error on input `<'
18:14:04 <CakeProphet> hmmm?
18:14:18 <CakeProphet> oh right
18:14:29 <CakeProphet> @@ @run (@run (@run let q s = s ++ show s in q "let q s = s ++ show s in q "))
18:14:33 <lambdabot>   "let q s = s ++ show s in q \"let q s = s ++ show s in q \""
18:16:17 <sjanssen> oh great, the "upvote if" cancer has spread to Haskell Reddit
18:17:20 <duaneb> woah
18:17:22 <duaneb> redditors
18:17:25 <duaneb> on irc
18:17:27 <duaneb> talking about haskell
18:17:40 <sjanssen> duaneb: why is this strange?
18:17:45 <CakeProphet> I don't even know what reddit is.
18:17:46 <ivanm> sjanssen: :o
18:18:38 <sjanssen> CakeProphet: reddit.com, kind of like Digg or Slashdot
18:18:44 <CakeProphet> ah
18:18:47 <sjanssen> @where haskellreddit
18:18:47 <lambdabot> I know nothing about haskellreddit.
18:19:14 <sjanssen> @where+ haskellreddit http://haskell.reddit.com
18:19:14 <lambdabot> It is stored.
18:19:54 <duaneb> sjanssen: I don't run into many reddit users OR haskell users OR irc users
18:19:59 <duaneb> so all three in the same place....
18:20:19 <sjanssen> duaneb: oh, you'll run into lots haskell AND irc users here :)
18:20:28 <dons> fwiw, Arch Linux has nearly 200 more haskell packages than python packages :)
18:20:31 <sjanssen> lots of #haskell is on reddit too
18:20:40 * dons just updated them.
18:20:43 <augustss_> dons: you've been busy :)
18:20:57 <dons> if we can be that bit more efficient than everyone else, we'll win :)
18:21:26 <duaneb> wait
18:21:34 <duaneb> new to haskell—is (||) lazy?
18:21:51 <sjanssen> duaneb: it is lazy in the second argument if the first argument is True
18:21:58 <sjanssen> > True || undefined
18:22:00 <lambdabot>   True
18:22:01 <duaneb> sjanssen: thanks
18:22:03 <sjanssen> > False || undefined
18:22:04 <lambdabot>   * Exception: Prelude.undefined
18:23:01 <augustss_> @src (||)
18:23:02 <lambdabot> True  || _ =  True
18:23:02 <lambdabot> False || x =  x
18:24:07 <CakeProphet> @@ (@@ (@run intercalate " " (replicate 5 "(@run") ++ "\"lol\"" ++ (intercalate "" (replicate 5 ")")))))
18:24:09 <lambdabot>   "(@run (@run (@run (@run (@run\"lol\")))))"
18:24:09 <lambdabot> )
18:24:14 <CakeProphet> :(
18:25:57 <CakeProphet> @@ (@@ (@run reverse.tail.reverse.tail.intercalate " " (replicate 5 "(@run") ++ "\"lol\"" ++ (intercalate "" (replicate 5 ")")))))
18:25:58 <lambdabot>   Couldn't match expected type `a -> [a1]'
18:25:58 <lambdabot> )
18:30:14 <CakeProphet> @@ (@@ (@run reverse (intercalate" " (replicate 5 "(@run ") ++ "\"lol\"" ++ (intercalate "" (replicate 5 ")"))) "\"" "" )))
18:30:15 <lambdabot>   Couldn't match expected type `[Char] -> [Char] -> t'
18:30:15 <lambdabot> )
18:30:48 <CakeProphet> I give up.
18:31:23 <CakeProphet> oh wait!
18:31:36 <CakeProphet> @@ (@@ (@run replace (intercalate" " (replicate 5 "(@run ") ++ "\"lol\"" ++ (intercalate "" (replicate 5 ")"))) "\"" "" )))
18:31:37 <lambdabot>   Not in scope: `replace'
18:31:37 <lambdabot> )
18:31:55 <CakeProphet> :m Data.List
18:32:16 <CakeProphet> no replace function?
18:32:34 <sjanssen> CakeProphet: no
18:32:44 <CakeProphet> easier way?
18:32:58 <sjanssen> CakeProphet: also, might be time to take that into /msg.  It is a bit noisy
18:33:19 <CakeProphet> alright, but what's the easiest way to do a replace?
18:33:34 <sjanssen> if you only need to replace one character, use map
18:33:51 <CakeProphet> wait, filter would work...
18:33:55 <CakeProphet> I just need to get rid of it entirely.
18:33:58 <CakeProphet> thanks.
18:34:15 <sjanssen> CakeProphet: I don't think you'll be able to produce programs for @run to run
18:34:40 <roconnor> woah, a new release of wxhaskell
18:34:42 <sjanssen> as @run uses show on the result, which quotes strings
18:35:14 <roconnor> does this mean I don't have to port GuiTV to gtk2hs?
18:36:04 <seydar> hey all
18:36:34 <seydar> i stole this example from RWH, and am trying to figure out how to use it in a do block. can anyone show me an example?
18:36:35 <seydar> http://hpaste.org/13299
18:36:40 <CakeProphet> sjanssen:  /msg doesn't seem to be working
18:38:10 <sjanssen> CakeProphet: you have to be registered with NickServ
18:38:21 <Lemmih> seydar: 'do x <- return 10; return (x+20)'
18:38:54 <augustss_> CakeProphet: perhaps you should just fire up ghci for experimentation.
18:38:55 <CakeProphet> sjanssen:  but yeah, you're right. There's no way to get the quotes off.
18:39:09 <CakeProphet> augustss_:  I was just playing around with @@ and @run.
18:39:22 <CakeProphet> I'm done now though.
18:39:50 <duaneb> so
18:39:55 <duaneb> I have this type
18:40:08 <duaneb> List [LispVal]
18:40:25 <duaneb> how can I get at the list within List without pattern matching?
18:40:52 <sjanssen> duaneb: what is the defn. of List?
18:41:25 <duaneb> data LispVal = Atom String | List [LispVal]
18:41:39 <sjanssen> duaneb: pattern matching is the best way here
18:41:48 <duaneb> On a slightly related note, how do you declare datatypes in ghci?
18:41:50 <pumpkin> you could also use the record syntax to define it, if you wanted to, I think
18:41:53 <duaneb> sjanssen: there's no other way? :/
18:42:05 <pumpkin> but record syntax is kinda ugly :)
18:42:15 <augustss_> duaneb: you need to load a file with the data type defn
18:42:29 <CakeProphet> duaneb:  just make a function that pattern matches it and returns it, so you don't have to do it a lot.
18:42:54 <sjanssen> but, you can also do: data LispVal = Atom String | List {theList :: [LispVal]}
18:43:07 <sjanssen> duaneb: that automatically creates a function called 'theList' that will extract a list
18:43:12 <jleedev> hooray for partial functions
18:43:18 <sjanssen> duaneb: however, it will fail when it is passed an Atom
18:43:22 <augustss_> duaneb: Also beware that you need to make sure you don't have an Atom before you try to get the list.  This is why pattern matching is advisable
18:43:24 <pumpkin> jleedev: what's a partial function?
18:43:33 <sjanssen> duaneb: this is why pattern matching is best here
18:43:36 <jleedev> > head []
18:43:37 <lambdabot>   * Exception: Prelude.head: empty list
18:43:51 <augustss_> pumpkin: one that is not defined for all inputs.  Like head.
18:43:55 <pumpkin> ah
18:44:49 <duaneb> sjanssen: ahh
18:44:52 <duaneb> sjanssen: much thanks
18:46:39 <CakeProphet> ?src Cons
18:46:39 <lambdabot> Source not found. That's something I cannot allow to happen.
18:47:18 <gwern> dons: tetris may be trademarked, but I wouldn't worry about it. there's a reasonable case it's been genericized
18:47:59 <defun> Hi, I just tried to install ghc 6.10.1 from sources. I get the following message when make fails: http://hpaste.org/13301. I am using gcc-3.4.3 and gnu make 3.80.
18:48:26 <duaneb> dons: just don't say 'tetris' and you'll be fine
18:48:38 <augustss_> defun: looks like GMP might not be installed on your system
18:48:48 <duaneb> dons: Quinn survived a huge lawsuit over tetris: http://simonhaertel.de/
18:49:22 <defun> augustss_: do you mean libgmp? That's definitely in /usr/lib.
18:49:25 <duaneb> woah
18:49:31 <duaneb> a reddit employee responded to me
18:49:45 <augustss_> defun: hmm, then I don't know
18:49:59 <defun> anyone?
18:51:07 <sclv> gwern: hvac is conceptually flawed at the moment.
18:51:16 <sclv> the rts can't handle the things it wants to do with STM.
18:51:55 <sclv> so its not a viable path, unfortunately. :-(. Lots of the ideas behind it and in it are nice, but I'd probably do them different if I was actively working on it.
18:54:05 <seydar> defun: http://gcc.gnu.org/ml/gcc-help/2008-06/msg00228.html
18:54:08 <sclv> also, the tuplelevel stuff I was doing wasn't all that useful in retrospect. i'd use a stronger type level encoding (hlists, probably) if I gave it another go. but the general concept for an record-driven haskell orm built over syb is still sound.
18:56:08 <gwern> sclv: so? there's plenty of code on hackage that is flawed. are you letting the perfect be the enemy of the good?
18:56:44 <sclv> the main problem is stm. if you write something in it now, it will eventually, and unpredictably, do horrible things to the rts.
18:56:45 <duaneb> > :t liftM_
18:56:46 <lambdabot>   <no location info>: parse error on input `:'
18:56:56 <duaneb> :t liftM_
18:56:57 <lambdabot> Not in scope: `liftM_'
18:56:59 <defun> seydar: am having a deeper look into gmp and gcc now. Thanks.
18:57:00 <duaneb> :/
18:57:10 <luite_> is there a simple way to see which specializations are generated because of a function? I have a module with a monad that runs around 1000x slower when I remove a test function from the module, but I haven't been able to get it fast again with SPECIALISE pragma's
18:57:21 <sclv> until 6.12 maybe, unsafeIOToSTM is seriously unsafe.
18:57:47 <SamB_XP> gwern: maybe we should have a scrapheap for things that aren't really all that useful but could be reworked ...
18:59:04 <seydar> pumpkin: are you the same pumpkin from #rubinius?
19:00:09 <redditbot> New release of wxHaskell!
19:00:20 <seydar> Lemmih: I'm having trouble using this in a do block. http://hpaste.org/13302 I take it `do s <- state` isn't correct usage?
19:00:23 <sclv> gwern: instead of hackaging things for a bit, maybe you could hack on hackage itself? make it easy to categorize and mark things as deprecated, "interesting but flawed," some of the rating type things, etc.
19:00:49 <gwern> sclv: my next project is darcs support for gitit, not hackage
19:00:56 <CakeProphet> > ['z'..'Z']
19:00:57 <lambdabot>   ""
19:01:02 <SamB_XP> gwern: add throttling, that sort of thing
19:01:05 <CakeProphet> uppercase before lower?
19:01:12 <CakeProphet> > ['Z'..'z']
19:01:13 <duaneb> > ['Z' .. 'z']
19:01:14 <lambdabot>   "Z[\\]^_`abcdefghijklmnopqrstuvwxyz"
19:01:15 <lambdabot>   "Z[\\]^_`abcdefghijklmnopqrstuvwxyz"
19:01:27 * CakeProphet remembers that
19:01:40 <defun> btw, does it make a difference if I use gcc3 with recent versions of ghc, as opposed to gcc4?
19:01:41 <CakeProphet> for some reason I wasn't expecting Haskell to mimic ASCII.
19:01:42 <gwern> sclv: and if I was going to hack on that stuff, I'd prioritize http4000 support for cabal-install
19:01:45 <Lemmih> seydar: 'do s <- state; return ()' would be correct.
19:01:46 <duaneb> how can I pattern match against a non-empty vs empty list?
19:01:48 <duaneb> basically
19:01:54 <sclv> oh, cool, no prob. it's just a general thing as hackage gets more populated that its harder to keep track of it, and especially when we get the next thousand packages up it'll take some serious work to keep it usable.
19:01:55 <duaneb> I have a chain of recursive calls
19:01:57 <CakeProphet> f [] = ...
19:02:00 <CakeProphet> f l = ...
19:02:01 <duaneb> and I want to know if I'm on the last one
19:02:04 <duaneb> |?
19:02:08 <sclv> I have no idea what http4000 is
19:02:09 <CakeProphet> L
19:02:12 <duaneb> ah
19:02:14 <CakeProphet> but lowercase.
19:02:19 <Axman6> duaneb: f [] = ...; f (x:xs) = ... f xs
19:02:21 <Lemmih> seydar: You can't end the do block with an '<-'.
19:02:22 <CakeProphet> basically if f [] didn't match
19:02:27 <gwern> sclv: you know HTTP, the package?
19:02:30 <CakeProphet> then you know it's full
19:02:33 <seydar> Lemmih: oh!
19:02:35 <CakeProphet> unless it's not a list at all
19:02:37 <Axman6> duaneb: if you want the last element, you use f [x]
19:02:50 <sclv> oh, gotcha! I thought it was some new protocol or something...
19:02:55 <sclv> :-)
19:03:04 <duaneb> > let sexpr lst = "(" ++ (sexpr' lst) ++ ")"; sexpr' (x:xs) = x ++ " " ++ (sexpr' xs); sexpr' (x:[]) = x; in sexpr ["1", "2", "3"]
19:03:06 <lambdabot>   mueval: Prelude.read: no parse
19:03:06 <lambdabot>  mueval: UnknownError "GHC reported errors a...
19:03:20 <duaneb> well
19:03:22 <duaneb> it doesn't work :P
19:03:25 <gwern> sclv: 4000 is ridiculously faster than 3k; think 30x faster and a similar improvement in memory usage
19:03:26 <Axman6> duaneb: order is important
19:03:36 <Axman6> sexpr lst will match everything
19:03:36 <duaneb> Axman6: really? damn :/
19:03:43 <defun> btw, does it make a difference if I use gcc3 with recent versions of ghc, as opposed to gcc4?
19:03:50 <sclv> super! does it use the enumerator stuff?
19:04:11 <duaneb> let sexpr lst = "(" ++ (sexpr' lst) ++ ")"; sexpr' (x:[]) = x; sexpr' (x:xs) = x ++ " " ++ (sexpr' xs); in sexpr ["1", "2", "3"]
19:04:12 <CakeProphet> it would be nice if ranges could go backward
19:04:15 <duaneb> > let sexpr lst = "(" ++ (sexpr' lst) ++ ")"; sexpr' (x:[]) = x; sexpr' (x:xs) = x ++ " " ++ (sexpr' xs); in sexpr ["1", "2", "3"]
19:04:17 <lambdabot>   "(1 2 3)"
19:04:22 <CakeProphet> but I suspect it has something to do with them working on any enum
19:04:23 <duaneb> beautiful
19:04:25 <gwern> sclv: dunno. it's basedo n 2007 work, and I thinker enumerator is more recent
19:04:30 <seydar> Lemmih: can i mix monads in a do block?
19:04:41 <Lemmih> seydar: Nope.
19:04:53 <seydar> gablork!
19:05:13 <Axman6> duaneb: ah, missed the sexpr' part, s'all good :)
19:05:14 <SamB_XP> CakeProphet: more to do with wanting [0..n-1] to give a list of length n, I think
19:06:41 <CakeProphet> [a..b] = let next = succ a in (if next/=b then next ++ [next..b] else next)
19:06:48 <CakeProphet> is how I would implement ranges in Haskell
19:07:37 <CakeProphet> hmm... are all enums also ords? I don't remember.
19:07:44 <dons> nope.
19:07:54 <seydar> Lemmih: so i'm now toying with main2 - how would i make use of s? do i apply something to it or pass it to a func like readSM?
19:08:56 <Lemmih> seydar: And 's' is?
19:10:03 <chessguy> @let f a b = let next = succ a in (if (next /= b) then (next ++ (f next b)) else next
19:10:04 <lambdabot>   Parse error
19:10:40 <seydar> Lemmih: sorry. s is in `do s <- state ... `
19:10:52 <defun> btw, does it make a difference if I use gcc3 with recent versions of ghc, as opposed to gcc4?
19:11:58 <Lemmih> seydar: I don't understand the problem. What do you want to do with 's'?
19:12:07 <seydar> defun: play it safe and use gcc4
19:12:17 <seydar> Lemmih: I don't really know. i'm trying to figure out what i CAN do with it
19:13:37 <SamB_XP> defun: you asked that already!
19:13:59 <defun> seydar: the only available gcc4 version is gcc 4.0.5. Is that considered good enought?
19:14:05 <Lemmih> seydar: You can try: do s <- state; return (map toUpper s)
19:14:29 <CakeProphet> dons, enums have a succ and a pred right?
19:14:46 <CakeProphet> dons, so how could they not be ords?
19:14:54 <seydar> Lemmih: how can i make use of updateSM?
19:15:18 <seydar> !!!!!!!
19:15:20 <seydar> i get it!
19:15:27 <chessguy> CakeProphet: for one thing, Int is not an enum
19:15:31 <seydar> the do block passes around a state object
19:15:42 <seydar> but what, what supplies the first state object?
19:15:43 <chessguy> CakeProphet:  for another your code doesn't typecheck
19:15:59 <CakeProphet> ?src Int
19:15:59 <lambdabot> data Int = I# Int#
19:16:01 <Lemmih> seydar: runSM.
19:16:15 <chessguy> CakeProphet:  for yet another, once it does typecheck, it doesn't include the initial value (a)
19:16:57 <seydar> Lemmih: thank you! can i apply the first state as an argument to main2?
19:16:57 <seydar> Lemmih: or is it `runSM 4 main2
19:16:57 <seydar> `
19:17:19 <dons> CakeProphet: that's right.
19:17:22 <Saizan> > succ (1::Int)
19:17:24 <lambdabot>   2
19:17:28 <dons> check the definition of the Enum class
19:17:33 <Lemmih> seydar: You haven't shown me what 'main2' is.
19:17:38 <Saizan> ?src Enum
19:17:39 <lambdabot> class  Enum a   where
19:17:39 <lambdabot>     succ                     :: a -> a
19:17:39 <lambdabot>     pred                     :: a -> a
19:17:39 <lambdabot>     toEnum                   :: Int -> a
19:17:39 <lambdabot>     fromEnum                 :: a -> Int
19:17:41 <lambdabot> [3 @more lines]
19:17:56 <chessguy> @instances-importing Enum
19:17:58 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
19:17:59 <seydar> Lemmih: sorry please don't hate me: http://hpaste.org/13304
19:18:03 <chessguy> oh, hm, Int is there
19:18:11 <CakeProphet> yep
19:18:14 <CakeProphet> Int has succ and pred
19:18:23 <dons> CakeProphet: http://hpaste.org/13305
19:18:27 <CakeProphet> that's why they can be ranges
19:18:30 <Lemmih> seydar: You can do: runSM S main2.
19:18:38 <chessguy> seydar:  main2 = state >>= return . map id
19:18:47 <Lemmih> seydar: 'S' is the only state you can have.
19:19:39 <seydar> Lemmih: ah. I see that
19:20:36 <cads> what language is GHC implemented in?
19:20:43 <Axman6> haskell
19:20:58 <CakeProphet> dons, so then my question still remains... how can something that has both a successor and predecessor not also have an ordering to it?
19:21:29 <CakeProphet> @instances-importing Ord
19:21:29 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:21:54 <chessguy> @src Ord
19:21:55 <lambdabot> class  (Eq a) => Ord a  where
19:21:55 <lambdabot>     compare      :: a -> a -> Ordering
19:21:55 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:21:55 <lambdabot>     max, min         :: a -> a -> a
19:22:23 <seydar> what do I have to do to get the funcs defined in this file (http://hpaste.org/13304) available to ghci?
19:22:39 <Axman6> seydar: load the file?
19:22:44 <Axman6> :l filename.hs
19:23:30 <srush> I'm stuck on how to load an image file
19:23:39 <CakeProphet> @instance-of
19:23:39 <lambdabot> Unknown command, try @list
19:23:42 <CakeProphet> @list
19:23:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:23:43 <augustss_> CakeProphet: It's not quite clear what succ does in all cases (this is only vaguely related to Ord), e.g. for Double
19:23:47 <Axman6> seydar: hmm, afaik, you don't normally define >>, as it's defined as m >> n = m >>= \_ -> n
19:23:50 <srush> anyone know how?
19:24:07 <jeffz`> srush: what do you mean by "image file" and "load"?
19:24:09 <dons> > succ pi
19:24:11 <lambdabot>   4.141592653589793
19:24:11 <augustss_> Axman6: that's right
19:24:19 <srush> get the pixel data of an image file
19:24:24 <srush> let's say png
19:24:34 <srush> there are a couple libs on hackage
19:24:34 <jeffz`> srush: the pngload on hackage works for 24bit rgb(a) pngs
19:24:40 <crathman> is there a function to get the current time in milliseconds?
19:24:52 <CakeProphet> augustss_:  ah okay.
19:24:52 <SamB_XP> jeffz`: picky!
19:24:57 <seydar> Axman6: it's auto-defined?
19:24:57 <dons> crathman: yeah. getCPUTime
19:25:00 <srush> jeffz`: the interface is kind of lame
19:25:04 <Axman6> seydar: yes
19:25:07 <jeffz`> SamB_XP: it is, someone needs to implement support for the the other types of PNGs
19:25:08 <crathman> dons: thanks
19:25:09 <CakeProphet> > succ True
19:25:10 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
19:25:10 <Axman6> @src (>>)
19:25:11 <lambdabot> m >> k      = m >>= \_ -> k
19:25:13 <jeffz`> srush: eh, it works for me, I'm using it with opengl
19:25:14 <CakeProphet> > succ False
19:25:16 <lambdabot>   True
19:25:24 <seydar> Axman6: awesome sauce. Do I need a `module Thing where...` header at the top?
19:25:25 <CakeProphet> > succ Nothing
19:25:26 <Axman6> > succ True
19:25:27 <lambdabot>       No instance for (Enum (Maybe a))
19:25:27 <lambdabot>        arising from a use of `succ' at...
19:25:28 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
19:25:32 <srush> how do you deal with Word8's
19:25:39 <srush> what's the conversion to rgb
19:25:50 <Axman6> seydar: you shouldn't, if you're just messing around in ghci
19:26:03 <CakeProphet> > [False..True]
19:26:04 <augustss_> CakeProphet: But I agree, if it has Enum, it should have some orderimg.
19:26:04 <lambdabot>       Failed to load interface for `False':
19:26:04 <lambdabot>        Use -v to see a list of th...
19:26:13 <srush> imageData :: PNGImage -> StorableArray (Int, Int) Word8
19:26:18 <seydar> Axman6: but i'm trying to load my functions into it
19:26:30 <augustss_> > [False .. True]
19:26:32 <lambdabot>   [False,True]
19:26:35 <jeffz`> srush: you use withStorableArray
19:26:40 <Axman6> seydar: yes, just use :l filename.hs
19:26:41 <seydar> > [True .. False]
19:26:42 <lambdabot>   []
19:26:49 <CakeProphet> augustss_:  what a useless deriving of Enum
19:26:54 <jeffz`> srush: the data is PixelData RGBA UnsignedByte
19:26:57 <CakeProphet> I can't even imagine why you would want to use succ on a Bool
19:27:02 <seydar> Axman6: huzzah!
19:27:23 <augustss_> CakeProphet: It's there for completeness
19:27:41 <augustss_> > [minBound .. maxBound] :: [Bool]
19:27:42 <lambdabot>   [False,True]
19:28:19 <augustss_> CakeProphet: You can do handy things with types that are in Bounded and Enum.  So there is no reason to exclude Bool.
19:28:28 <CakeProphet> one argument functions in typeclasses always take a second for me to comprehend.
19:28:31 <CakeProphet> *zero argument
19:28:45 <CakeProphet> when I see them used.
19:29:01 <CakeProphet> > [minBound .. maxBound] :: [Ordering]
19:29:03 <lambdabot>   [LT,EQ,GT]
19:29:11 <Cale> > pi
19:29:12 <lambdabot>   3.141592653589793
19:29:12 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:29:39 <Cale> > pi :: Float
19:29:40 <lambdabot>   3.1415927
19:29:44 <CakeProphet> > generalCategory "-"
19:29:45 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
19:29:53 <CakeProphet> > generalCategory '-'
19:29:54 <lambdabot>   DashPunctuation
19:29:55 <CakeProphet> o rite
19:30:34 <CakeProphet> :t generalCategory '-'
19:30:36 <lambdabot> GeneralCategory
19:30:53 <CakeProphet> [minBound..maxBound] :: GeneralCategory
19:31:10 <CakeProphet> [minBound..maxBound] :: [GeneralCategory]
19:31:16 <CakeProphet> > [minBound..maxBound] :: [GeneralCategory]
19:31:17 <lambdabot>   [UppercaseLetter,LowercaseLetter,TitlecaseLetter,ModifierLetter,OtherLetter...
19:31:19 <CakeProphet> -facepalm-
19:31:57 <CakeProphet> hmmm, apparently GeneralCategory is Bounded
19:32:10 <CakeProphet> > UppercaseLetter > LowercaseLetter
19:32:12 <lambdabot>   False
19:32:12 <augustss_> seems reasonable
19:32:25 <CakeProphet> the question however
19:32:36 <CakeProphet> is why there is a category for dashPunctuation
19:32:40 <CakeProphet> when there is only one dash
19:32:58 <augustss_> You should ask on #unicode :)
19:33:08 <CakeProphet> .......o rite.
19:33:17 <SamB_XP> > generalCategory 'A'
19:33:19 <lambdabot>   UppercaseLetter
19:33:34 <scodil> aren't there multiple dashes? em-dash and whatnot?
19:33:50 <augustss_> yeah, there's several kinds of deshes
19:33:52 <augustss_> dashes
19:34:12 <CakeProphet> yeah. I'm so used to thinking in ASCII I forgot all about Unicode.
19:34:15 <CakeProphet> which is a silly thing to forget.
19:34:26 <SamB_XP> > filter ((== TitlecaseLetter) . generalCategory) [
19:34:27 <lambdabot>   <no location info>: parse error on input `;'
19:34:34 <SamB_XP> > filter ((== TitlecaseLetter) . generalCategory) ['\0'..]
19:34:35 <lambdabot>   "\453\456\459\498\8072\8073\8074\8075\8076\8077\8078\8079\8088\8089\8090\80...
19:34:43 <SamB_XP> huh
19:34:45 <SamB_XP> what ARE those ?
19:35:07 <CakeProphet> > filter (==TitlecaseLetter) [minBound..maxBound] :: [Char]
19:35:08 <lambdabot>   Couldn't match expected type `Char'
19:35:47 <CakeProphet> > filter ((==TitlecaseLetter).generalCategory) [minBound..maxBound] :: [Char]
19:35:48 <lambdabot>   "\453\456\459\498\8072\8073\8074\8075\8076\8077\8078\8079\8088\8089\8090\80...
19:36:08 <CakeProphet> ah. so Char in Haskell is Unicode?
19:36:15 <augustss_> yes
19:36:42 <Quylui> is there an online haskell compiler which can also execute code
19:36:47 <hiredman> ♥
19:37:01 <CakeProphet> > filter ((==TitlecaseLetter).generalCategory.chr) [0..255]
19:37:02 <lambdabot>   []
19:37:07 <CakeProphet> thought so.
19:37:32 <CakeProphet> > filter ((==DashPunctuation).generalCategory.chr) [0..255]
19:37:33 <BMeph> Besides, CakeProphet, there are at least _three_ kinds of dashes. ;p
19:37:33 <lambdabot>   [45]
19:38:04 <Axman6> could someone have a look at the definition of parseAtom in http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing and tell me if the otherwise makes sense in it?
19:38:09 <CakeProphet> > map ord (filter ((==MathSymbol).generalCategory.chr) [0..255])
19:38:10 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
19:38:16 <Axman6> i don't see how a list can match a bool
19:38:34 <CakeProphet> > map chr (filter ((==MathSymbol).generalCategory.chr) [0..255])
19:38:36 <lambdabot>   "+<=>|~\172\177\215\247"
19:39:33 <roconnor> can lambdabot normalize unicode strings?
19:39:55 <duaneb> axman: it does
19:40:00 <duaneb> Axman6: it does
19:40:04 <Axman6> why?
19:40:23 <duaneb> it matches two possible strings
19:40:25 <Axman6> @src otherwise
19:40:25 <pumpkin> Axman6: I think the otherwise = False thing isn't the case here
19:40:25 <lambdabot> otherwise = True
19:40:26 <duaneb> OR it returns an atom
19:40:33 <pumpkin> I mean = True :)
19:41:03 <Axman6> huh
19:41:05 <CakeProphet> sweet.
19:41:07 <Axman6> how strange
19:41:14 <CakeProphet> otherwise could make for some fun Haskell poetry. :D
19:41:22 <jeffz`> Quylui: codepad.org
19:41:32 <pumpkin> Axman6: I think that's only used as the definition in guards, not in pattern matches
19:41:39 <pumpkin> as functions don't get executed in pattern matches
19:42:02 <Axman6> hmm, i don't like seeing inconsistancy in haskell
19:42:11 <pumpkin> I dunno, I could be wrong :)
19:42:43 <CakeProphet> @let f otherwise = True
19:42:44 <lambdabot>  Defined.
19:42:53 <CakeProphet> > f True
19:42:54 <lambdabot>       Ambiguous occurrence `f'
19:42:54 <lambdabot>      It could refer to either `L.f', defined a...
19:42:58 <Axman6> :t f
19:42:59 <lambdabot>     Ambiguous occurrence `f'
19:42:59 <lambdabot>     It could refer to either `L.f', defined at <local>:10:0
19:42:59 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:73:0-32
19:43:01 <augustss_> using otherwise in a pattern will bind a variable, not compare against True.
19:43:12 <Axman6> CakeProphet: don't define f with @let please :)
19:43:14 <augustss_> there's no inconsistency there
19:43:14 <pumpkin> yeah
19:43:21 <CakeProphet> ...ah. noted.
19:43:23 <pumpkin> it's equivalent to _
19:43:29 <pumpkin> since it's not being used
19:43:34 <Axman6> augustss_: ah yes, that does make sense :)
19:43:53 <pumpkin> so they really just used otherwise there to confuse us
19:44:01 <Axman6> bastards!
19:44:03 <pumpkin> into thinking of it like a guard-like pattern
19:44:06 * Axman6 changes it back to _
19:44:32 <BMeph> Sorry, 'cause it's OT, but has anyone looked at Google's 3D modeller, SketchUp?
19:44:39 <Axman6> i have
19:44:52 <Axman6> it's awesome, used it for making diagrams for a few engineering projects
19:45:02 <CakeProphet> is _ special syntax or is it convention for uneeded matches
19:45:10 <SamB_XP> it's been awesome longer than it's been google's, from what I hear ;-P
19:45:18 <Axman6> indeed
19:45:23 <augustss_> CakeProphet: in case you wonder about f, it's already defined so you can do handy things like
19:45:24 <Axman6> that's why google bought it :P
19:45:35 <Axman6> @unlet
19:45:37 <lambdabot>  Defined.
19:45:39 <augustss_> > foldr f z [x,y]
19:45:41 <lambdabot>       Ambiguous occurrence `f'
19:45:41 <lambdabot>      It could refer to either `L.f', defined a...
19:45:45 <Axman6> @unlet f
19:45:46 <lambdabot>   Parse error
19:45:46 <augustss_> @undefine f
19:45:53 <Axman6> that's the one
19:46:01 <augustss_> > foldr f z [x,y]
19:46:03 <lambdabot>   f x (f y z)
19:46:03 <Axman6> > foldr f x [a,b,c]
19:46:05 <lambdabot>   f a (f b (f c x))
19:46:09 <BMeph> Axman6: Do you find it ironic that it calls for a browser...but not the Google browser? ;p
19:46:21 <Axman6> it calls for a browser?
19:46:24 <pumpkin> gfail
19:46:30 <CakeProphet> augustss_:  ah okay. It expands an expression?
19:46:33 <Axman6> and no, chrome is way to buggy atm
19:46:37 <BMeph> SamB_XP: Ah, that might explain it, then. :)
19:46:45 <CakeProphet> > map f [1..5]
19:46:46 <lambdabot>   Add a type signature
19:46:57 <Axman6> BMeph: yeah google bought sketch up
19:47:05 <augustss_> CakeProphet: it has a weird type that allows a certain amount of reflection
19:47:12 <CakeProphet> :t f
19:47:13 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:47:24 <augustss_> > map f [1..5] :: [Expr]
19:47:24 <pumpkin> > map f [1..5] :: [Expr]
19:47:26 <lambdabot>   [f 1,f 2,f 3,f 4,f 5]
19:47:26 <lambdabot>   [f 1,f 2,f 3,f 4,f 5]
19:47:38 <CakeProphet> ?src SimpleReflect
19:47:38 <lambdabot> Source not found.
19:47:45 <CakeProphet> ?src SimpleReflect.FromExpr
19:47:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:47:54 <CakeProphet> ?src Expr
19:47:55 <lambdabot> Source not found. My pet ferret can type better than you!
19:48:08 <augustss_> CakeProphet: you can find it on hackage
19:48:43 <augustss_> > foldr (.) id [f,g,h] x
19:48:45 <lambdabot>   f (g (h x))
19:48:54 <CakeProphet> :t z
19:48:55 <lambdabot> Expr
19:49:01 <CakeProphet> :t a
19:49:02 <lambdabot> Expr
19:49:09 <CakeProphet> is the whole alphabet defined like that?
19:49:13 <augustss_> yes
19:49:27 <augustss_> except f,g,h
19:49:55 <CakeProphet> is this a LB thing or a Haskell thing?
19:49:55 <SamB_XP> > f i
19:49:56 <lambdabot>   Add a type signature
19:49:59 <SamB_XP> LB
19:50:05 <pumpkin> CakeProphet: lambdabot
19:50:08 <SamB_XP> :t f i
19:50:09 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
19:50:16 <augustss_> CakeProphet: It's a Haskell package that is in scope in lb
19:50:30 <SamB_XP> :t i
19:50:31 <lambdabot> Expr
19:50:32 <CakeProphet> ah okay.
19:50:48 <SamB_XP> kinda lame that we can't do
19:51:02 <SamB_XP> > a : b
19:51:03 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Expr'
19:51:25 <augustss_> SamB_XP: yeah :(
19:51:35 <CakeProphet> I didn't know type signatures expanded functions.
19:51:46 <SamB_XP> CakeProphet: what ?
19:51:46 <CakeProphet> oh wait...
19:51:47 <augustss_> CakeProphet: ?
19:51:52 <CakeProphet> : = list.
19:52:03 <SamB_XP> > a :: b
19:52:04 <lambdabot>   Couldn't match expected type `b' against inferred type `Expr'
19:52:04 <augustss_> yeah.  Haskell has it the wrong way around
19:52:13 <SamB_XP> augustss_: it's not wrong
19:52:18 <SamB_XP> it's right for Haskell
19:52:29 <augustss_> SamB_XP: it's a choice.  I think it's wrong for Haskell
19:52:33 <BMeph> CakeProphet: ':' = 'cons', i.e., put an element on the front of a list(you give the element and the list). :)
19:52:35 <SamB_XP> you do ?
19:52:50 <CakeProphet> BMeph:  right
19:52:51 <augustss_> SamB_XP: : for has type has tradition and is shorter.
19:53:08 <Axman6> SamB_XP: what would ou expect the result of a : b woud be?
19:53:10 <Axman6> l*
19:53:36 <augustss_> I write many more type signatures than conses
19:53:52 <BMeph> augustss: Yeah, it goes against the general FP convention, and especially against the ML convention. I blame you for this! ;p
19:54:00 <SamB_XP> well, it's not as bad as it would be if Haskell were dependently typed
19:54:07 <SamB_XP> BMeph: why do you blame him ?
19:54:10 <CakeProphet> I think Haskell should become something like a combination of C# and Java
19:54:15 <CakeProphet> and this discussion would be null.
19:54:16 <augustss_> BMeph: I was not on the committee when that was decided
19:54:22 <koninkje_away> dons: yes (though I've been gone for a few days)
19:54:28 <SamB_XP> CakeProphet: we have C# for that
19:54:29 <SamB_XP> silly
19:54:41 <BMeph> auguustss: You should've kicked up a bigger fuss about it and saved us! ;)
19:54:59 <augustss_> BMeph: yeah, I should.
19:55:08 <CakeProphet> SamB_XP:  Are you implying that C# is infinitely Java?
19:55:12 <pumpkin> worse fates have been had :)
19:55:19 <BMeph> augustss: O RLY? And it still flew? Hmm, I smell a Conspiracy... ;p
19:55:21 <koninkje> dons: (re wren thornton being here)
19:55:47 <CakeProphet> C# = C# + Java = C# + Java + Java = Java + Java ...
19:55:49 <CakeProphet> ....
19:55:51 <mmorrow> somewhat interesting http://x86.org/articles/branch/branchprediction.htm
19:56:11 <BMeph> augustss: O well, it's not like anyone's kicking you out of the Pantheon, or anything, we still <3 ya. :)
19:56:31 <SamB_XP> CakeProphet: I was assuming you meant \union
19:56:58 <BMeph> SamB_XP: You _do_ know who augustss is, right? :)
19:57:19 <augustss_> mmorrow: branch prediction is still an art
19:57:42 <CakeProphet> this conversation reminds me back in the day when I was on the C committee... and I convinced everyone void * was a good syntax for null pointers.
19:58:02 <CakeProphet> and all was well in the programming world from then on
19:58:22 <mmorrow> augustss_: do you know of any good links?
19:58:47 <sbahra> Hi mmorrow
19:58:54 <bd_> CakeProphet: what was the alternative?
19:58:55 <mmorrow> sbahra: hey, whats up
19:58:58 <augustss_> mmorrow: sorry, I don't.  I've not been keeping up-to-date with what's happening there
19:59:00 <SamB_XP> CakeProphet: oh, yes, and I suppose your favorite editor is a horshoe magnet ?
19:59:18 <sbahra> mmorrow, not much. Ingested some alcohol for the first time in some busy months :-P Flying half way around the world tomorrow.
19:59:23 <sbahra> mmorrow, and yourself?
19:59:24 <CakeProphet> bd_:  I don't know. if there was one I would have advocated it instead!
19:59:47 <mmorrow> augustss_: cool. i'm trying to get at least minimally informed about it
19:59:50 <CakeProphet> SamB_XP:  Nah. I like gedit.
20:00:03 <mmorrow> sbahra: heh, sounds like fun.
20:00:12 <tcleval> hi, does anyone know how to display  λ on vim while editing (\ ? i want vim to substitue the character, but only on the display, not on the file.
20:00:14 <mmorrow> sbahra: not much. how did exams and all that end up?
20:00:15 <SamB_XP> are you serious about the C commitee?
20:00:29 <sbahra> mmorrow, I failed most of them
20:00:35 <srush> jeffz`: I still can't figure out how to use the Ptr Word8
20:00:44 <hiredman> tcleval: emacs can do that sort of thing, don't know if vim can
20:00:45 <sbahra> mmorrow, will you have time to work on this project?
20:00:48 <jeffz`> srush: thought so... let me paste something
20:00:51 <mmorrow> sbahra: that's what everyone thinks i think
20:00:56 <CakeProphet> SamB_XP:  that depends on your definition of serious.
20:00:58 <srush> thanks
20:01:01 <pumpkin> mmorrow: I don't think you think that
20:01:02 <sbahra> mmorrow, no, no...the results are in :)
20:01:15 <sbahra> I got an A for underachievement, though.
20:01:29 <mmorrow> sbahra: well, i'm kinda overloaded on stuff at the moment, so not right now i won't have time. but i'm still very much interested in it.
20:01:37 <sbahra> Ok, great.
20:01:37 <mmorrow> sbahra: aww crap ;)
20:01:52 <sbahra> Hopefully I'll be able to hack some cool things this coming week. I'll have nothing but that in my free time.
20:02:03 <tcleval> hiredman i want to know just for vim.. I know emacs can do it coz i saw something about it on a scheme tutorial, but i dont want to learn emacs now. ^^ maybe later
20:02:06 <CakeProphet> tcleval: might be a good extension to a haskell mode for vim.
20:02:15 <mmorrow> sbahra: cool.
20:02:31 <sbahra> mmorrow, BTW, if you're interested in computer architecture, a *great* book is "Computer Architecture: A Quantitative Approach"
20:02:49 <mmorrow> sbahra: nice, i'll look that one up.
20:06:13 <jeffz`> srush: http://hpaste.org/13308
20:07:13 <jeffz`> tcleval: maybe you should ask in the vim channel
20:11:06 <cads> hey all. I'd like to write a message digest function that works on directory trees. Like the md5 function for files, it should be able to tell you with pretty good certainty when two directory trees are bit for bit identical
20:11:20 <duaneb> are there any other languages that are comprable to haskell?
20:11:36 <cads> duaneb, clean?
20:12:56 <pstickne> "in what aspects?"
20:13:07 <duaneb> any aspects
20:13:46 <pstickne> any is one of those terms... what are they called?
20:13:55 <SamB_XP> cads: well, you could use git's model
20:13:56 <duaneb> 1hat?
20:13:58 <duaneb> what?
20:14:07 <pstickne> "were any character traits of Adolf Hitler redeeming?"
20:14:17 <pstickne> I mean, *shrug* :)
20:14:30 <mmorrow> duaneb: brainfuck and haskell are both turing complete ;)
20:15:12 <Chile`> cads: do you want the *files* in the directories to be the same, or just the names?
20:15:27 <cads> c'mon, I'm sure he's asking about languages with hindley myer type inferrence and pattern matching and [1..10] for sequences and all those goodnesses
20:15:28 <mmorrow> cads: i was just about to ask the same thing Chile` just did
20:16:08 <cads> Chile` I want the files to be identical bitwise, but otherwise in name or metadata they can be different
20:16:30 <SamB_XP> cads: what ???
20:16:37 <SamB_XP> that's going to make it VERY tricky
20:17:01 <Chile`> cads: do you care about position in the directory?
20:17:15 <cads> oh crap that does make it tricky
20:17:17 <mmorrow> cads: i guess (==) :: Tree a -> Tree a -> Bool could be considered as being the same thing that's done to unify types in a sense
20:17:44 <Axman6> could someone who knows about pasring/parsec give me a hand with exercise 2 in http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing ?
20:18:10 <mmorrow> you just zip the Trees
20:18:18 <Chile`> cads: as a basic rule, gather all the information you want to be included in the hash, organize it in a unique way, represent it as a string (files can be represented by their own hashes, I think -- could be an issue with that) and hash that.
20:19:02 <srush> jeffz`: this is neat, but it's so complicated
20:19:19 <cads> Chile, I had the idea of taking the md5 hashes of the files in a directory, concatenating them according the alphabetical order of the files, and applying the md5 hash to that in order to create the hash for the directory.. if a directory had subdirectories the first part would have to be applied recursively
20:19:29 <orbitz> do { x <- "hi"; y <- "hello"; return [x, y]}
20:19:31 <mmorrow> oh nice, yeah you could have  (==) :: Tree MD5 -> Tree MD5 -> Bool
20:19:35 <orbitz> > do { x <- "hi"; y <- "hello"; return [x, y]}
20:19:35 <jeffz`> srush: well, you only have to write it once
20:19:36 <lambdabot>   ["hh","he","hl","hl","ho","ih","ie","il","il","io"]
20:19:42 <cads> but I see that would give different hashes to trees that have files named differently
20:19:42 <koninkje> does anyone know of a good way to get C's fall-through case behavior in Haskell?
20:19:57 <SamB_XP> cads: so you want the directory structures to be identical but with different names ?
20:20:01 <Chile`> cads: right.
20:20:04 <cads> koninkje, that's terrible
20:20:05 <srush> yeah, I guess.
20:20:14 <Chile`> cads: which is why you need to gather all the information you want to be included first ;)
20:20:37 <koninkje> cads: in general, yes. But it's appropriate for certain types of bit-bashing
20:21:00 <Axman6> koninkje: doesn't sound very nice or haskellish
20:21:04 <SubStack> koninkje: http://en.wikipedia.org/wiki/Switch_statement#Haskell
20:22:06 <koninkje> SubStack: I was meaning in the assembly code. Just getting the behavior is easy, I'm trying to optimize and I'm wondering whether I should just write this function in C
20:22:31 * koninkje thinks there's a better way than if-then-else chaining
20:22:42 <SubStack> Data.Map?
20:23:11 <SamB_XP> I'm pretty sure you can't get fall-through in the assembler
20:23:18 <SamB_XP> at least not on purpose
20:23:24 <Axman6> in parsec, would many ((char "\\" >> oneOf "\"nrt\\") <|> noneOf "\"") match strings and allow \" in side the string? (there'a more code, but only for the "'s at the ends)
20:23:27 <koninkje> SamB_XP: alas
20:23:35 <koninkje> SamB_XP: thanks though
20:23:47 <Axman6> uh that'd need to be char '\' wouldn't it
20:23:55 <SamB_XP> but I doubt if modern CPUs care that much
20:24:09 <SamB_XP> a JMP is probably as good as a fallthrough
20:25:11 <duaneb> SamB_XP: long or local?
20:25:23 <duaneb> SamB_XP: back or forward?
20:25:35 <cads> Chile`, I know, I'll order the concatenation according to the md5s of the files themselves, smallest to largest. And for empty directories define the hash as 0.. should this scheme still give a low chance for hash collisions?
20:25:35 <SamB_XP> duaneb: does it really matter that much for a JMP?
20:25:41 <koninkje> SamB_XP: I have code like do { y <- f y ; jmpZero y End ; y <- f y ; jmpZero y End ;... End = return y } using some arbitrary pseudo-assembly.
20:25:41 <duaneb> SamB_XP: a fallthrough is ALWAYS faster
20:25:43 <SamB_XP> I mean, it would be fairly short
20:25:53 <SamB_XP> duaneb: once it's decoded ?
20:25:55 <SamB_XP> I doubt it
20:26:06 <duaneb> SamB_XP: there's always an extra cycle to process the jump
20:26:06 <koninkje> it's a constant-size entirely-unrolled loop
20:28:06 <jeffz`> cads, why md5 and not sha-1?
20:28:09 <Chile`> cads: that's the part I'm not sure about.
20:28:29 <Chile`> cads: i'm guessing its still good enough for practical uses
20:28:44 <Axman6> anyone familliar with parsec? :\
20:28:52 <jeffz`> Axman6: yes, but I don't like that tutorial
20:28:52 <gwern> 'Tue Dec 23 12:06:21 EST 2008  Duncan Coutts <duncan@haskell.org> * Ban ghc-options: --make I dunno, some people...
20:28:56 <gwern> hee hee
20:29:05 <Chile`> cads: you could put in a bit length checksum for reassurance :)
20:29:17 <Axman6> jeffz`: well would you at least be able to answer my question? :\
20:29:27 <Axman6> i'm not sure hos to test my new parser
20:29:28 <CakeProphet> @quote
20:29:29 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
20:29:52 <Chile`> cads: I'd guess that the bit length of every file in the directory tree + a hash of the hashes of all the files in the directory tree would give you a solid indication.
20:30:06 <Chile`> and its not like the bit length takes any more time to compute
20:30:18 <Axman6> how*
20:30:18 <cads> right
20:30:20 <jeffz`> Axman6: I used parsec to write the lexer for my PostScript interpreter, I used hunit to write tests
20:30:22 <duaneb> jeffz`: why do you not like that tutorial
20:30:45 <cads> jeffz, as for md5 versus sha-1, you're probably right
20:31:01 <jeffz`> duaneb: I don't know about the wikibook, but I ran into errors in the original text plus the html was broken and it made the text bright red in opera so I gave up on it and used a different parsec tutorial.
20:31:10 <Axman6> :t >>= >>=
20:31:11 <lambdabot> parse error on input `>>='
20:31:17 <Axman6> :t >>= (>>=)
20:31:19 <lambdabot> parse error on input `>>='
20:31:24 <Axman6> :t (>>= (>>=))
20:31:25 <duaneb> jeffz`: ahh
20:31:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => ((a -> m b) -> m a) -> (a -> m b) -> m b
20:32:07 <jeffz`> Axman6: have you read Daan Leijen
20:32:11 <jeffz`> Axman6: 's parsec doc?
20:32:15 <Axman6> nope
20:32:29 <jeffz`> Axman6: http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.html
20:32:55 <jeffz`> Axman6: it should make some of the basics clearer than the scheme tutorial does
20:32:57 <cads> Chile`, the bitlength is not likely to make it much more secure against a collision attack, but it would help me feel safer in practical use :D
20:33:05 <Axman6> hmm, ok
20:33:32 <CakeProphet> oh wow. I might /finally/ get lambdabot to install
20:33:34 <koninkje> Axman6: alas, it's neither nice nor haskellish. Architecture-dependent bit-bashing never is
20:33:50 <Axman6> :\
20:34:28 <koninkje> indeed.
20:34:54 <pumpkin> > x ^ 15 -- what's up with the weird parentheses here?
20:34:55 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * x))
20:35:07 <Axman6> @src (^)
20:35:08 <lambdabot> x ^ 0            =  1
20:35:08 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
20:35:08 <lambdabot>   where f _ 0 y = y
20:35:08 <lambdabot>         f x n y = g x n
20:35:08 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
20:35:09 <lambdabot>                       | otherwise = f x (n-1) (x*y)
20:35:12 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
20:35:23 <cads> Chile, the original problem is to restore a directory structure after a script went through it randomly copying random subdirectories to other random subdirectories  :D]
20:35:44 <StoneToad> cads: dont run the script in the first place?
20:35:48 <StoneToad> XD
20:36:45 <cads> StoneToad, it's a hypothetical script :D
20:36:51 <mmorrow> cads: it seems to me that in order to restore it you'd have to have a backup copy of the original dir structure, so then why not just rm -rf the modified one and restore via the backup?
20:37:41 <mmorrow> because the best you could do with a hash function is tell if the dirtree has been modified
20:38:09 <cads> the original directory structure is still contained in the modified structure, it just that random parts of itself have been added to itself in random places
20:39:04 <mmorrow> cads: hmm, so you want to be able to restore it then from just having an (e.g.) Tree MD5 as backup. interesting problem
20:39:06 <loupgaroublond> is greencard still supported?
20:39:21 <mmorrow> i bet the general phrasing of this problem would be pretty cool
20:39:22 <loupgaroublond> taht is, is it still supported in ghc 6.10?
20:39:40 <sjanssen> loupgaroublond: I think greencard has been bitrotten for a long time
20:39:54 <porges> I think we should use umlauts rather than suffixing everything monadic with M
20:40:03 <porges> mapM → mäp
20:40:26 <pumpkin> lol
20:40:29 <SamB_XP> lïft
20:41:05 <cads> mmorrow, that _is_ an interesting take on it.. I was thinking of generating the hashes for each of the directories in the modified tree, as a simple way for checking of two directories are duplicates of each other and therefore possibly affected by the copy virus :D
20:41:06 <mmorrow> cads: well, if the script is only allowed to /add/ subtrees to the original tree, that should be easy. just zip the backup tree and the new tree and prune any new subtrees. you wouldn't even have to bother with md5's.
20:41:18 <loupgaroublond> sjanssen, are any easy ways for doing FFI other than by hand then?
20:41:37 <pumpkin> there's an autoconverter somewhere
20:41:42 <pumpkin> that does a lot of the work for you
20:41:47 <SamB_XP> c2hs
20:41:54 <SamB_XP> is probably what you mean ?
20:42:03 <loupgaroublond> probably
20:42:07 <mmorrow> cads: hmm, this is a nice one, i'm gonna think about it
20:42:13 <bogner> how can I tell ghc --make to use my cabal libs?
20:42:33 <Axman6> bogner: t should already
20:42:35 <Axman6> it*
20:42:36 <bogner> (that is, the libraries I've installed using cabal)
20:42:59 <bogner> Axman6: it doesn't seem too, perhaps there's another problem. I'll investigate
20:43:08 <porges> library path?
20:43:24 <cads> mmorrow, there isn't a backup tree, the restoration algorithm just has to use heuristics and hope that it doesn't run into a hopeless case. I ran into this guy in another chatroom that had accidentally kludged his directory structure in this way during a data loss recorvery and was manually (with his human heuristics) sorting through it in wishing for a better way :D
20:43:40 <mmorrow> heh
20:43:46 <loupgaroublond> SamB_XP, thanks
20:44:11 <CakeProphet> @bf
20:44:11 <lambdabot>  Done.
20:44:17 <CakeProphet> ...sweet.
20:44:25 <SamB_XP> @bf .
20:44:26 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
20:44:28 <SamB_XP> @bf ,
20:44:29 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
20:44:37 <porges> @bf ++++++++
20:44:38 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
20:44:53 <SamB_XP> Cale: it's broken!
20:44:54 <CakeProphet> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
20:44:54 <pumpkin> no brainfuck
20:44:54 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
20:45:02 <CakeProphet> ...:(
20:45:04 <SamB_XP> or ... itś broken
20:45:24 <int-e_> hmm, Hello World!
20:45:29 <porges> @bf
20:45:30 <lambdabot>  Done.
20:45:51 <CakeProphet> is there a way to restart it?
20:45:54 <Axman6> @bf +.
20:45:54 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
20:46:07 <SamB_XP> áćéíĺńóŕśúýź
20:46:17 <int-e_> bogner: ghc -package-conf <whereever cabal put its package.conf file>
20:46:19 <cads> mmorrow, your idea of restoring an altered tree in order to recapture an earlier hash of the tree makes for an interesting logical problem
20:46:38 <SamB_XP> äëïöüÿ
20:46:41 <int-e_> CakeProphet: restarting it likely won't help - it's probably missing the brainf*ck interpreter
20:46:44 <int-e_> > 1
20:46:45 <lambdabot>   1
20:47:16 <CakeProphet> int-e_:  then I have no choice... I must write an interpreter in Haskell
20:47:28 <CakeProphet> and dump it in with @let
20:47:31 <SamB_XP> àèìòù
20:47:34 <porges> haskell :: (Mönad m) →  RÖCK
20:48:26 <CakeProphet> > _
20:48:27 <porges> ⇒ even
20:48:27 <lambdabot>   Pattern syntax in expression context: _
20:48:42 <CakeProphet> ah okay. So _ is special syntax instead of just convention
20:49:11 <Axman6> > (\_ -> 1+_) 3
20:49:12 <lambdabot>   Pattern syntax in expression context: _
20:49:13 <SamB_XP> > €
20:49:14 <lambdabot>   <no location info>: parse error on input `€'
20:49:24 <Axman6> > (\(_) -> 1+(_)) 3
20:49:25 <SamB_XP> > 1 € 2
20:49:25 <lambdabot>   Pattern syntax in expression context: _
20:49:26 <lambdabot>   Not in scope: `€'
20:49:32 <int-e> CakeProphet: yep. it has to be, or  let f _ _ = 42  would be a duplicate binding and thus an error.
20:49:33 <Axman6> CakeProphet: yep
20:49:35 <SamB_XP> whoa!
20:49:36 <SamB_XP> neat!
20:49:39 <int-e> > let f a a = 42 in f 1 2
20:49:40 <lambdabot>       Conflicting definitions for `a'
20:49:40 <lambdabot>      In the definition of `f'
20:49:46 <int-e> > let f _ _ = 42 in f 1 2
20:49:47 <CakeProphet> ah
20:49:47 <lambdabot>   42
20:50:17 <porges> let € = const error in "hello" € "world"
20:50:24 <porges> > let € = const error in "hello" € "world"
20:50:26 <lambdabot>   <no location info>: parse error on input `€'
20:50:30 <porges> > let (€) = const error in "hello" € "world"
20:50:32 <lambdabot>   * Exception: world
20:52:04 <CakeProphet> does lambdabot use GHC or does it need a special interpreter to make it secure?
20:52:17 <dons> ghc
20:52:34 <dons> it imposes a type constraint that the code isn't in the IO monad
20:52:47 <dons> simple, robust type-based safety
20:53:39 <SamB_XP> dons: I thought it used "grep" on the type
20:53:40 <Gracenotes> doesn't it append the code to be executed at the bottom of a text file containing imports?
20:53:52 <Gracenotes> L.hs, iirc
20:54:06 <CakeProphet> hmmm... so lambdabot compiles all the way up to Eval.hs
20:54:13 <CakeProphet> and then it complines about things not being in scope
20:54:14 <koninkje> dons: you called a few days back?
20:58:48 <CakeProphet> Plugin/Eval.hs:70:14: Not in scope: data constructor `HsModule'
20:58:57 <CakeProphet> this is the first error I got when compiling lambdabot
21:00:31 <pumpkin> CakeProphet: it's painful
21:00:47 <dmwit> CakeProphet: How are you trying to build it?
21:00:53 <CakeProphet> with cabal install
21:01:04 <pumpkin> CakeProphet: you can change the .cabal file to depend on src-exts < 0.4 or something
21:01:09 <dmwit> Bummer, I was going to suggest cabal install. =P
21:01:12 <CakeProphet> using GHC 6.10
21:01:13 <pumpkin> that'll get you past that error, but others will make it painful
21:02:01 <Request> Free Programming E-books With Direct Links & Request Ebooks http://www.request-ebooks.blogspot.com/
21:02:09 <CakeProphet> pumpkin:  where is said file?
21:02:17 <porges> CakeProphet: just open the tar.gz
21:02:28 <porges> erm
21:02:48 <porges> what I did yesterday was to ensure an older version of src-exts was installed (0.3.12 I think)
21:02:54 <CakeProphet> pumpkin:  .cabal/config?
21:03:08 <pumpkin> CakeProphet: nope, in the tgz file
21:03:09 <dmwit> Any ops want to take care of Request?
21:03:25 <porges> then open the .tar.gz and change Plugin/Base.hs and Plugin/TheOtherThingThatItComplainedAbout.hs
21:03:26 <dmwit> I guess it's not really that urgent.
21:03:32 <pumpkin> ircops can probably take care of him too
21:03:36 <CakeProphet> pumpkin:  what tgz file? the .tgz that has cabal in it?
21:03:38 <Axman6> > sum [1..]
21:03:51 <dmwit> thread killed
21:03:52 * pizza_ makes explosion sounds
21:04:04 <pumpkin> CakeProphet: each cabal package is really  .tar.gz with a .cabal file inside it, taht describes how the package works
21:04:06 <porges> changing GHC.WhateverItComplainedAbout to Control.Exception
21:04:14 <Axman6> i got "mueval: Prelude.read: no parse" when i tried it in another chan :|
21:04:24 <pizza_> haskell should be smarter than that; if infinite list then return Infinity;
21:04:29 <pumpkin> lol
21:04:40 <dmwit> Axman6: That means it errored out, and \bot didn't know how to read the error.
21:04:51 <porges> [1..] would have to generate a datastructure
21:04:52 <dmwit> pizza_: Halting problem, no?
21:05:07 <SamB_XP> , sum (repeat 0)
21:05:10 <lunabot>  luna: out of memory (requested 1048576 bytes)
21:05:19 <porges> data ListComprehensions = EnumFrom n | EnumFromTo n n | EnumFromThenTo n n n | EnumFromThen n n
21:05:37 <dmwit> Also, yeah, Infinity isn't always the right answer.
21:06:32 <CakeProphet> pumpkin:  how do I get the .tar?
21:06:49 <pumpkin> CakeProphet: it's probably sitting in your .cabal/packages folder somewhere
21:06:54 <pumpkin> can't remember the exact structure
21:06:54 <pizza_> dmwit: there's no halting problem for sum [1..]
21:06:54 <porges> it's in .cabal/packages/hackage*/lambdabot*/
21:07:04 <scook0> http://www.reddit.com/r/programming/comments/7lf1u/coding_challenge_divide_a_list_into_n_sublists/
21:07:08 <gwern> find .cabal -name "*.tar.gz" |grep package, I usually do
21:07:08 <pumpkin> pizza_: in general, though
21:07:12 <CakeProphet> pumpkin:  so change that, recompress it, and then what do I tell cabal to do?
21:07:16 <scook0> ^^ any improvements for my Haskell version?
21:07:19 <pumpkin> an infinite list can be the result of any computation
21:07:39 <pumpkin> CakeProphet: don't even bother recompressing it, change it, then type cabal install (nothing else) in the decompressed package dir
21:07:56 <CakeProphet> ah okay
21:07:57 <porges> CakeProphet: you don't have to uncompress/recompress it, just open it in file-roller, edit the file, file-roller will ask you if you want to update the file
21:15:00 <Axman6> scook0: i like it, nice ans simple
21:15:12 <Axman6> and*
21:16:14 <scook0> the funny thing is that I came across the transpose thing entirely by accident
21:16:23 <Axman6> heh
21:16:28 <porges> scook0: a little cheaty; I'd presume that they want contiguous sublists :)
21:16:39 <idnar> sum (repeat 0 ++ [1]) -- >:)
21:16:52 <scook0> porges: I would have assumed that too, but PG's solution doesn't respect that
21:16:57 <pumpkin> scook0: what's a sublist?
21:17:00 <scook0> so I decided to beat him at his own game
21:17:12 <porges> :D
21:17:29 <scook0> the original question doesn't actually define it
21:17:39 <mmorrow> CakeProphet: so haskell-src-exts underwent a (breaking) API change recently. looks like lambdabot is using the old interface. you'll need to get version </me looks> of older
21:17:47 <mmorrow> s/of/or/
21:18:04 <scook0> however, the elements in each of my "sublists" appear in the same order as in the original list
21:18:23 <mmorrow> CakeProphet: you need haskell-src-exts <= 0.3.8
21:18:28 <scook0> they just aren't guaranteed to be contiguous sublists
21:19:02 <porges> CakeProphet: I did it this way: "cabal install haskell-src-exts-0.3.12", remove the other haskell-src-exts (make sure you remove it from .ghc/...6.10.../package.conf)
21:19:17 <porges> CakeProphet: then open lambdabot.tgz in file-roller and change two imports
21:19:20 <mmorrow> you can get it from hackage of course, but i have a darcs repo (i just copied an old version to here) of 0.3.8 at http://moonpatio.com/repos/haskell-src-exts/
21:19:21 <porges> then it worked :P
21:19:27 <mmorrow> (fwiw)
21:21:04 <mmorrow> cads: totally, i want to figure out a nice general phrasing of this problem
21:21:20 <porges> mmorrow: you can just cabal-install old versions by appending the version
21:21:42 <gwern> I'm sure he knows that
21:21:50 * mmorrow doesn't use cabal-install very much :)
21:21:58 <pumpkin> I think there's a newer lambdabot in darcs that doesn't rely on the old interface
21:22:05 <mmorrow> (not that it isn't awesome of course ;)
21:22:06 <pumpkin> there was a wiki page on installing it on ghc 6.10
21:23:06 <porges> pumpkin: not as of yesterday :P
21:23:13 <pumpkin> hmm
21:23:35 <porges> scook0: you'll get less "tokens" if you write it pointfully :)
21:23:50 <scook0> porges: really? heh
21:23:52 <pumpkin> *fewer ;)
21:24:10 <porges> :P
21:24:12 <scook0> I didn't bother checking, since I assumed pointless would be better
21:24:37 <scook0> you'll notice the numeric parameter is still pointful
21:24:40 <porges> going by PG's counting
21:24:50 <porges> (he ignores parentheses)
21:25:13 <porges> and assuming (.) counts as a "token"
21:25:43 <mmorrow> @type let lex' x = let (y,ys) = let x in takeWhile (not . null) (y : lex ys) in length . lex'
21:25:46 <lambdabot> parse error on input `in'
21:26:04 <mmorrow> um
21:26:41 <mmorrow> > let tokens = let lex' x = let (y,ys) = let x in takeWhile (not . null) (y : lex ys) in length . lex' in tokens "g . f"
21:26:42 <lambdabot>   <no location info>: parse error on input `in'
21:26:45 <scook0> I'm particularly fond of using takeWhile (not . null) instead of having a termination condition in the unfoldr
21:26:49 * mmorrow is baffled
21:26:56 <mmorrow> oh
21:27:03 <mmorrow> @type let lex' x = let (y,ys) = lex x in takeWhile (not . null) (y : lex ys) in length . lex'
21:27:04 <lambdabot>     Couldn't match expected type `(t, t1)'
21:27:04 <lambdabot>            against inferred type `[(String, String)]'
21:27:04 <lambdabot>     In the expression: lex x
21:27:14 <sclv> @seen vikey
21:27:15 <lambdabot> I haven't seen vikey.
21:27:19 <sclv> @seen vixey
21:27:20 <lambdabot> Last time I saw vixey was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #funtoo, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
21:27:20 <lambdabot> haskell-blah, #haskell-books, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #
21:27:20 <lambdabot> haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 18d 7h 7m 34s ago, and .
21:27:59 <porges> scook0: if splitAt returned Nothing if n >= length list the solution would be tinier :D
21:28:01 <mmorrow> @type let lex' x = case lex x of [] -> []; [(y,ys)] -> y : lex' ys in length . lex'
21:28:02 <lambdabot> String -> Int
21:28:22 <mmorrow> @let tokens = let lex' x = case lex x of [] -> []; [(y,ys)] -> y : lex' ys in length . lex'
21:28:23 <lambdabot>  Defined.
21:28:28 <mmorrow> > tokens "g . f"
21:28:43 <lambdabot>   thread killed
21:28:48 <mmorrow> crap
21:29:21 <mmorrow> > tokens' = let lex' x = case lex x of [] -> []; [(y,ys)] -> y : lex' ys in length . takeWhile (not . null) . lex' in tokens' "g . f"
21:29:22 <lambdabot>   <no location info>: parse error on input `='
21:29:24 <Axman6> > lex "f . g"
21:29:25 <mmorrow> > let tokens' = let lex' x = case lex x of [] -> []; [(y,ys)] -> y : lex' ys in length . takeWhile (not . null) . lex' in tokens' "g . f"
21:29:27 <lambdabot>   3
21:29:27 <lambdabot>   [("f"," . g")]
21:29:35 <mmorrow> @let tokens' = let lex' x = case lex x of [] -> []; [(y,ys)] -> y : lex' ys in length . takeWhile (not . null) . lex'
21:29:36 <lambdabot>  Defined.
21:29:41 <mmorrow> > tokens' "g . f"
21:29:43 <lambdabot>   3
21:30:17 <mmorrow> @pl \a b c d e -> g (f a b (h e d c))
21:30:18 <lambdabot> ((((g .) .) .) .) . flip flip (flip (flip . flip h)) . (((.) . (.) . (.)) .) . f
21:30:27 <mmorrow> > tokens' "((((g .) .) .) .) . flip flip (flip (flip . flip h)) . (((.) . (.) . (.)) .) . f"
21:30:29 <lambdabot>   44
21:31:23 <mmorrow> > tokens' "\\a b c d e -> g (f a b (h e d c))"
21:31:24 <lambdabot>   19
21:31:34 <porges> you need to make it ignore parentheses ;)
21:32:12 <mmorrow> yeah, that'd make it more interesting
21:32:26 <dmwit> :t (lex, unfoldr, iterate)
21:32:27 <lambdabot> forall b a a1. (String -> [(String, String)], (b -> Maybe (a, b)) -> b -> [a], (a1 -> a1) -> a1 -> [a1])
21:32:47 <dmwit> :t unfoldr (listToMaybe . lex)
21:32:48 <lambdabot> String -> [String]
21:32:57 <mmorrow> @let toks = lex' x = case lex x of [] -> []; [(y,ys)] -> y : lex' ys in takeWhile (not . null) . lex'
21:32:58 <lambdabot>   Parse error
21:33:03 <dmwit> > unfoldr (listToMaybe . lex) "a b i"
21:33:05 <lambdabot>   ["a","b","i","","","","","","","","","","","","","","","","","","","","",""...
21:33:09 <dmwit> yipe
21:33:20 <dmwit> > lex ""
21:33:22 <lambdabot>   [("","")]
21:33:23 <mmorrow> maybe mzero mplus
21:33:25 <dmwit> booo
21:33:59 <dmwit> Anyway, unfoldr (listToMaybe . lex) is way cooler than pattern matching. ;-)
21:34:07 <mmorrow> heh
21:34:14 <mmorrow> @let toks = lex' x = case lex x of [] -> []; [(y,ys)] -> y : lex' ys in takeWhile (not . null) . lex'
21:34:15 <lambdabot>   Parse error
21:34:17 <mmorrow> gah!
21:34:40 <ddarius> > unfoldr ((>> guard (not . null)) . listToMaybe . lex) "a b i"
21:34:42 <lambdabot>   Couldn't match expected type `Bool'
21:34:58 <mmorrow> @let toks = takeWhile (not . null) . unfoldr (maybe mzero mplus . lex)
21:34:59 <lambdabot>  Couldn't match expected type `Maybe (m a)'
21:35:13 <mmorrow> oh
21:35:27 <porges> hmm
21:35:30 <int-e> > unfoldr (liftM2 (>>) (guard . not . null) (listToMaybe . lex)) "a b c"
21:35:30 <porges> why is there no takeUntil
21:35:31 <lambdabot>   ["a","b","c"]
21:35:37 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
21:35:39 <lambdabot>  Defined.
21:35:43 <dmwit> :t maybe mzero mplus
21:35:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, MonadPlus ((->) (m a))) => Maybe (m a) -> m a -> m a
21:35:50 <dmwit> That part is wrong.
21:36:17 <dmwit> > takeWhile (not . null) . unfoldr (listToMaybe . lex) $ "a b i"
21:36:19 <lambdabot>   ["a","b","i"]
21:36:24 <mmorrow> @type let toks = takeWhile (not . null) . unfoldr (list mzero (\a _ -> return a) . lex) in toks
21:36:25 <lambdabot> String -> [[Char]]
21:36:32 <mmorrow> @let toks = takeWhile (not . null) . unfoldr (list mzero (\a _ -> return a) . lex) in toks
21:36:32 <lambdabot>   Parse error
21:36:36 <mmorrow> @let toks = takeWhile (not . null) . unfoldr (list mzero (\a _ -> return a) . lex)
21:36:37 <lambdabot>  Defined.
21:36:41 <mmorrow> finally
21:36:51 <mmorrow> now i forget what i was even doing that for
21:36:52 <dmwit> > toks "a b i"
21:36:54 <lambdabot>   ["a","b","i"]
21:36:58 <mmorrow> oh yeah
21:36:59 <dmwit> :t list
21:37:01 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
21:37:06 <mmorrow> list cata
21:37:17 <int-e> > toks ('"' : repeat ' ')
21:37:25 <int-e> *twiddles thumbs*
21:37:28 <mmorrow> heh
21:37:38 <mmorrow> > sum [0..]
21:37:44 <dmwit> > filter (const False) [0..]
21:37:51 <dmwit> *twiddles thumbs*
21:37:56 <mmorrow> > fix id
21:38:03 * dmwit pokes lambdabot
21:38:07 <int-e> error: id can't be fixed.
21:38:09 <mmorrow> lambdabot is puking her guts out right now
21:38:29 <mmorrow> poor lambdabot
21:38:31 <mbz> @bot
21:38:31 <lunabot>  :)
21:38:37 <dmwit> I guess that's the sane response to a poke.
21:38:37 <mbz> heh
21:38:46 <dmwit> ping -> pong; poke -> puke
21:38:59 <mmorrow> yeah, sounds logical
21:39:24 <dmwit> dmwit -> dmwut
21:39:57 <lambdabot>   thread killed
21:40:00 <mmorrow> yay
21:40:06 <mmorrow> @bot
21:40:06 <lunabot>  :)
21:40:09 * dmwit -> bed -- doesn't fit the pattern, but is more true
21:40:13 <int-e> > let please = id in please sum [1..10]
21:40:35 <dolio> OMG INTERCAL!
21:40:40 <mmorrow> > let pepto = fix; bismo = id in pepto bismo
21:40:49 <mmorrow> oh oops ;)
21:41:12 * mmorrow couldn't resist
21:41:18 <int-e> Data.Bits is lacking interleave and select :)
21:41:25 <int-e> so, not really intercal
21:41:37 * mmorrow googles INTERCAL
21:41:39 <int-e> (not to forget the unary binary operators)
21:41:44 <ddarius> mmorrow: Holy crap
21:41:55 <mmorrow> holy crapfork!
21:42:11 <int-e> intercal is perhaps most infamous for its come from statement :)
21:42:44 <int-e> (there's a threaded intercal extension that allows coming from the same origin in more than one place. I loved that.)
21:42:45 <lambdabot> :)
21:42:45 <lambdabot> :)
21:42:51 <mmorrow> wow, i guess i shoulda known about intercal
21:42:54 <lambdabot>   55
21:42:55 <lambdabot>   * Exception: stack overflow
21:42:55 <lambdabot>   * Exception: stack overflow
21:42:55 <mmorrow> "the canonical esoteric programming language"
21:43:00 <lambdabot>   thread killed
21:43:00 <lambdabot>   thread killed
21:43:01 <ddarius> mmorrow: Yes, you should have.
21:43:10 * mmorrow hangs his head in shame
21:43:43 <int-e> please abstain from giving up. please abstain from reinstating. :)
21:44:00 <mmorrow> @let tokens_ = length . filter (not . (`elem`"()")) . toks
21:44:31 <int-e> mmorrow: type mismatch? `elem` ["(", ")"]
21:44:35 <ddarius> mmorrow: You're going to run out of nonce characters eventually.
21:44:38 <mmorrow> shit
21:44:58 <mmorrow> this definition of tokens_ has been extremely epic
21:45:19 <int-e> > toks "`a`"
21:45:22 <pumpkin> extreme epicism
21:45:23 <mmorrow> @let tokens_ = length . filter (not . (`elem`["(",")"])) . toks
21:45:59 <mmorrow> lunabot's greatest deficiency is not having an @let equivalent
21:46:17 <lambdabot>  thread killed
21:46:17 <lambdabot>   thread killed
21:46:17 <lambdabot>  thread killed
21:46:43 <pizza_> also the phonesex feature is $.99/minute
21:46:46 <mmorrow> it's into the dry-heave stage now. almost done
21:46:56 <int-e> hmm, interesting - why did it put two spaces before 'thread killed' in one of those lines?
21:47:07 <int-e> @vixen hi
21:47:07 <lambdabot> hi
21:47:13 <mmorrow> > 42
21:47:14 <int-e> @vixen curry?
21:47:15 <lambdabot>   42
21:47:15 <lambdabot> whoa whoa whoa, one question at a time!
21:47:20 <mmorrow> @let tokens_ = length . filter (not . (`elem`["(",")"])) . toks
21:47:22 <lambdabot>  Defined.
21:47:27 <mmorrow> sweet
21:47:38 <mmorrow> > tokens_ "((((g .) .) .) .) . flip flip (flip (flip . flip h)) . (((.) . (.) . (.)) .) . f"
21:47:40 <lambdabot>   22
21:47:44 <int-e> > toks "`a`"
21:47:46 <lambdabot>   ["`","a","`"]
21:47:46 <mmorrow> > tokens_ "\\a b c d e -> g (f a b (h e d c))"
21:47:48 <lambdabot>   15
21:48:45 <pumpkin> I hate it when my macbook air decides to go on strike
21:48:50 <mmorrow> > toks "2 + 4"
21:48:51 <lambdabot>   ["2","+","4"]
21:51:52 <Axman6> pumpkin: you have a MBA? ew
21:51:58 <pumpkin> :P
21:52:08 <pumpkin> it was so purty
21:52:11 <pumpkin> I just had to have it
21:52:16 <pumpkin> even if I couldn't afford it
21:52:27 <mmorrow> @@ run (\x -> (tokens_ x, tokens_ (@pl x))) "\\x -> x"
21:52:28 <lambdabot>  run (\x -> (tokens_ x, tokens_ x)) "\\x -> x"
21:52:39 <Axman6> they cost more than a MBP, and are less powerful than a macbook, i have absolutely no use for one :0
21:52:41 <mmorrow> i forget how to do that
21:52:48 <pumpkin> Axman6: I also have a MBP
21:53:10 <Axman6> good
21:55:52 <pumpkin> but not one of the news ones :(
21:55:54 <pumpkin> -s
21:56:17 <Axman6> mine's one of the first santa rosa ones. im happy with it
21:56:25 <pumpkin> same here
21:56:31 <pumpkin> but my fan's started making nasty noises
21:56:43 <Axman6> with 10.5.6?
21:56:50 <pumpkin> it's just a physical thing
21:56:53 <Axman6> ah
21:56:58 <pumpkin> I think it needs lubin up, or has some gunk in it
21:57:03 <Axman6> mine started revving high when it wasn't that hot :\
21:57:23 <Axman6> anyway, i'm getting an iLap and a 320GB 7200rpm drive for it tomorrow :)
21:57:32 <pumpkin> ooh
21:58:31 <solrize> get a 500gb theyre cheap
21:58:56 <erikc> pumpkin: ill probably post a mach-o parser library by new years
21:58:58 <solrize> oh 7200rpm, hmm, hot.
21:59:03 <pumpkin> erikc: omg!
21:59:16 <pumpkin> erikc: that's cool :)
21:59:40 <erikc> been writing it while i read the docs on mac internals
21:59:52 <pumpkin> erikc: it would be nice to have a "common interface" sitting above the object format readers that allowed you to read things like symbol names and get code and where it should be in memory, without worrying about the underlying format
22:00:20 <Axman6> my main problem was speed more than anything
22:00:26 <Axman6> 5400 is just too slow :(
22:00:58 <erikc> yup, that'll have to be built on top of the raw binary parsing layer
22:01:14 <solrize> get an intel flash drive if you want speed
22:01:25 <scook0> @src transpose
22:01:25 <lambdabot> transpose []             = []
22:01:25 <lambdabot> transpose ([]   : xss)   = transpose xss
22:01:25 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
22:01:27 <Axman6> i need the space too
22:01:30 <pumpkin> erikc: I enjoy reverse engineering so easy well designed libraries to work on top of are always welcome :)
22:01:34 <Axman6> and reliability would be good.
22:01:35 <solrize> two drives?
22:01:43 <Axman6> solrize: for a MBP?
22:02:00 <solrize> not sure, can you do that?  pull the dvd and put in a 2nd hdd?
22:04:10 <ozy`> solrize: not likely. say what you want about Apple but they're good at using every cubic millimeter of their laptops for stuff that's important
22:04:31 <ozy`> you might have to cut a hole in the case to get another hard drive to fit, even with the optical drive removed
22:04:37 <Axman6> this is pretty awesome http://forums.introversion.co.uk/introversion/viewtopic.php?t=1837
22:05:03 <Axman6> you can replace the DVD drive with another HDD actually
22:05:20 <Axman6> there's some company that makes a bay thing for it
22:06:02 <Axman6> they even give you a case to put the DVD drive in so you have a FW DVD drive still
22:06:04 <solrize> ditch the dvd, get the bay thing
22:06:18 <ozy`> that's cool
22:06:18 <solrize> a 4gb usb stick is 7 bucks, dvd's are obsolete
22:09:46 <scook0> @pl \x -> transpose . splitEvery x
22:09:47 <lambdabot> (transpose .) . splitEvery
22:10:30 <pumpkin> @unpl (x .) . (. y)
22:10:31 <lambdabot> (\ e h -> x (e (y h)))
22:10:31 <BMeph> Ditch the bay, get a 23-in-1 card reader, or a 4/5/7-port USB hub. ;)
22:10:41 <jeffz`> @pl crenderuxsIn colour xs  = crenderuxs $ zip xs (repeat colour)
22:10:42 <lambdabot> crenderuxsIn = (crenderuxs .) . flip zip . repeat
22:11:57 <Axman6> flip zip . repeat... hmm, reminds me of a saying i heard for taking a piss... "zip flip drip flip zip" don;t mess up the order
22:14:56 <Axman6> http://www.mathrix.org/experimentalAIT/TuringMachine.html needs a haskell entry
22:15:33 <Axman6> aww, supposed to be C++, how stupid
22:18:50 <roconnor> Axman6: even worse it has to be a Turing Machine
22:18:58 <roconnor> shortest universal machine would be cooler
22:19:29 <Axman6> i played around with making a turing machine in haskell a while ago, and then writing programs in it
22:19:33 <BMeph> Axman6, roconnor: I say we enter tromp's BLC into the mix! ;)
22:19:36 <Axman6> i could do addition
22:19:48 <Axman6> BMeph: say what now?
22:20:03 <BMeph> @go tromp binary
22:20:07 <lambdabot> http://citeseer.ist.psu.edu/368685.html
22:20:07 <lambdabot> Title: J.Tromp Binary Snapshots - CiteSeerX
22:20:15 <cads> Axman6, why c++ as the target language?
22:20:19 <BMeph> Not quite... :\
22:20:24 <Axman6> cads: no idea
22:20:25 <BMeph> @go tromp lambda
22:20:28 <lambdabot> http://homepages.cwi.nl/~tromp/cl/cl.html
22:20:28 <lambdabot> Title: John's Combinatory Logic Playground
22:20:30 <roconnor> We put up a clothes line and made a turing machine by hand at a party once
22:20:38 <roconnor> ... that is the sort of parties I go to.
22:20:42 <Axman6> haha
22:20:58 <Axman6> @remember roconnor We put up a clothes line and made a turing machine by hand at a party once ... that is the sort of parties I go to.
22:20:59 <lambdabot> Okay.
22:21:00 <cads> roconnor, how do I meet people like that?
22:21:00 <BMeph> There we go. :)
22:21:04 <roconnor> http://www.deor.org/~jlv/writings/turing_machines_are_people.html
22:21:35 <roconnor> cads: go to the University of Waterloo.
22:23:53 <roconnor> "Soon they'll be breeding us like cattle! You've got to
22:23:53 <roconnor> warn everyone and tell them! Turing machines are made of people! You've got to
22:23:53 <roconnor> tell them! Turing machines are people!"
22:24:31 <sclv> ?src (**)
22:24:31 <lambdabot> Source not found. There are some things that I just don't know.
22:24:33 <cads> I think people are at the very best turing equivalent
22:24:37 <sclv> ?src **
22:24:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
22:24:47 <Adamant> I thought people were Connection Machines
22:24:51 <sclv> ah. a class method.
22:25:13 <Axman6> @src (^)
22:25:14 <lambdabot> x ^ 0            =  1
22:25:14 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
22:25:14 <lambdabot>   where f _ 0 y = y
22:25:14 <lambdabot>         f x n y = g x n
22:25:14 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
22:25:16 <lambdabot>                       | otherwise = f x (n-1) (x*y)
22:25:17 <roconnor> cads: at the party the turing machine was made of us.
22:25:18 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
22:25:48 <cads> roconnor, did you guys know if y'all'd terminate?
22:26:02 <cads> :)
22:26:24 <roconnor> cads: we were implementing one of the busy beaver programs on found on the web
22:26:29 <roconnor> but there was a typo
22:26:36 <roconnor> and we ended up in an infinite loop
22:26:38 <roconnor> :(
22:26:51 * sclv just realized that there's not a simple solution for taking a polynomial to a fractional power. oops.
22:27:00 <cads> I'm sure alcoholic beverages could have been implemented to fix that bug
22:27:01 <roconnor> I wrote to the guy to point out the error
22:27:08 <roconnor> then he asked why I was interested
22:27:17 <roconnor> so then I had the explain I was at this party ...
22:27:26 <roconnor> had to explain
22:27:53 <porges> Entscheidungsproblem ist Menschenfleisch! Entscheidungsproblem ist Menschenfleisch!
22:28:05 <roconnor> :D
22:28:16 <sclv> or rather you get an infinite series.
22:28:19 <roconnor> @bab de en Entscheidung
22:28:25 <sclv> i feel silly now.
22:28:29 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
22:28:49 <roconnor> sclv: you probably want to use one of the lazy power series packages
22:29:10 <sclv> roconnor: right. i'm stealing liberally from them.
22:29:24 <porges> I think that sentence thoroughly exhausted my german vocabulary
22:29:25 <cads> sclv, that operation is closed for the algebraic numbers, I think there are useful modules for dealing with arbitrary precision algebraic irrationals
22:29:33 <Axman6> @help babel
22:29:34 <lambdabot> babel <lang1> <lang2> <phrase>.
22:29:34 <lambdabot> Translate a phrase in lang1 to lang2.
22:29:34 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
22:29:43 <nolrai_East> @pl fork a b = forkIO a >> b
22:29:43 <lambdabot> fork = (>>) . forkIO
22:29:51 <Axman6> @babel german english Entscheidung
22:29:52 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
22:30:13 <nolrai_East> @help babel
22:30:13 <lambdabot> babel <lang1> <lang2> <phrase>.
22:30:13 <lambdabot> Translate a phrase in lang1 to lang2.
22:30:13 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
22:30:21 <ozy`> is there any particular reason you have to enclose an infixified function name in a pair of backquotes, rather than just using one?
22:30:31 <porges> ozy`: it looks nicer
22:30:41 <porges> `ozy`: rather
22:30:50 <dolio> > 5 `    elem    ` [1,2,3,4,5]
22:30:51 <lambdabot>   True
22:31:07 <roconnor> oh god
22:31:08 <sjanssen> porges: the decision problem is human flesh?
22:31:16 <roconnor> that should be illegal
22:31:37 <cads> sjanssen, it's made of peeeeople!
22:31:38 <ozy`> hmmmmm
22:31:39 <sjanssen> a play upon "soylent green is people", I suppose?
22:31:51 <ozy`> > 4 `(2 +)`
22:31:52 <lambdabot>   <no location info>: parse error on input `('
22:31:52 <sjanssen> I've actually never seen that movie.  Is it good?
22:31:56 <ozy`> dammit
22:32:09 <roconnor> sjanssen: ah, that's what I thought.
22:32:11 <porges> sjanssen: I was first introduced to the movie via an industrial song which sampled it (in German, of course)
22:32:16 <sjanssen> ozy`: only qnames may appear in ``
22:32:17 <kfish> On Computable Numbers, with an Application to Menschenfleisch
22:32:35 <cjs> So when I'm passing values to another thread, through a channel or whatever, what's a clever way to delay the delivery of them by 50 ms. after they were sent?
22:32:37 * bos does a little book sales victory dance.
22:32:40 <MrStamp> does anyone know if gtk2hs will work on OS X using the native gtk+, not the X11 version?
22:32:59 <porges> the catchphrase in the German Version is “Soylent Grün ist Menschenfleisch!”
22:33:00 <ozy`> sjanssen: yeah, thought so. that's why I asked my question, partly
22:33:04 <roconnor> cjs: wouldn't it be easier to delay it before it is sent?
22:33:06 <ozy`> MrStamp: some people have done it
22:33:08 <ozy`> I forget who
22:33:09 <sjanssen> cjs: threadDelay before sending them?
22:33:14 <cads> ozy, I think it would look too lispy
22:33:50 <MrStamp> thanks ozy`, I suppose I'll try to make it work
22:34:31 <cjs> I can delay before it's sent, sure, though I have other things to do with the value as well, that need to be done right away. So no, the threadDelay thing doesn't work.
22:34:31 <sjanssen> cjs: also, that is sort of a weird question
22:34:37 <cjs> Really?
22:35:15 <sjanssen> forkIO (threadDelay 50ms >> writeChan x)?
22:35:31 <cjs> And I of course have to deal with messages that come in during the delay time. E.g., my sending thread receives them at 0ms, 3ms, 8ms, 27ms, and the receiver should get them at 53ms, 58ms, 77ms.
22:35:33 <roconnor> I'm told threads are cheap
22:35:38 <roconnor> so use 100000 if you want
22:35:47 <cjs> Oh, a new thread for every message? Hey, that works for me!
22:36:03 <cjs> Yeah, I knew they were cheap, but it just didn't occur to me.
22:36:24 <sjanssen> cjs: yes, or do something more clever with an MVar (Map TimeToReceive ValueType)
22:36:30 <sjanssen> or TVar, perhaps
22:37:26 <porges> class (Functor m) ⇒ Monad m where
22:37:29 <porges> 	(⤜) :: m a → (a → m b) → m b
22:37:35 <cads> in haskell is it possible to curry against a functions second argument and leave the first and remaining arguments unbound?
22:37:51 <cjs> Actually, I've already implemented a "DelayQueue" that basically does that. No MVar needed, you just hand it an item with the current time to queue, and give it just the current time to dequeue everything that's ready.
22:37:57 <StoneToad> cads: check flip
22:38:08 <BMeph> Based off of Harry Harrison's story, "Make Room, Make Room" it's a goodie - heck, they make a movie out of it, didn't they? :)
22:38:11 <StoneToad> cads: lets you flip the arguments to a function
22:38:19 <sjanssen> cads: also, you're misusing the word "curry"
22:38:43 <Axman6> :t let f :: a -> b -> c -> d in flip f
22:38:44 <lambdabot>     Misplaced type signature: f :: a -> b -> c -> d
22:38:44 <lambdabot>     You cannot give a type signature for an imported value
22:38:50 <Axman6> bah
22:39:00 <cjs> Everybody does. Come on people, it's called Schönfinkelisation!
22:39:05 <Axman6> :t let flip (f :: a -> b -> c -> d)
22:39:07 <lambdabot> parse error (possibly incorrect indentation)
22:39:10 <StoneToad> lol cjs
22:39:12 <porges> currying is A^(B*C) == (A^B)^C
22:39:14 <Axman6> :t flip (f :: a -> b -> c -> d)
22:39:15 <lambdabot>     Could not deduce (SimpleReflect.FromExpr d, Show c, Show b, Show a)
22:39:16 <lambdabot>       from the context ()
22:39:16 <lambdabot>       arising from a use of `f' at <interactive>:1:6
22:39:24 <Axman6> :t flip (t :: a -> b -> c -> d)
22:39:26 <lambdabot>     Couldn't match expected type `a -> b -> c -> d'
22:39:26 <lambdabot>            against inferred type `Expr'
22:39:26 <lambdabot>     In the first argument of `flip', namely `(t :: a -> b -> c -> d)'
22:39:32 <Axman6> god damn you lambdabot
22:39:54 <sjanssen> Axman6: hint: undefined
22:40:06 <Axman6> :t flip (undefined :: a -> b -> c -> d)
22:40:08 <lambdabot> forall a b c d. b -> a -> c -> d
22:40:16 <Axman6> :t flip flip (undefined :: a -> b -> c -> d)
22:40:18 <lambdabot> forall a c a1 b c1 d. (a -> (a1 -> b -> c1 -> d) -> c) -> a -> c
22:40:30 <Axman6> >_>
22:40:47 <StoneToad> wha...
22:41:02 <porges> :t flip $ flip (undefined :: a -> b -> c -> d)
22:41:04 <lambdabot> forall a b c d. b -> a -> c -> d
22:42:01 <cads> my understanding of currying is you map f :: (AxB) -> C to  f_a :: B -> C for some element a of A
22:42:16 <BMeph> porges: You got that all whomperjawed, it's (A8B)^C <==> A^(B^C) :)
22:42:34 <sjanssen> cads: that is application, or "partial application"
22:42:37 <BMeph> s/A8B/A*B
22:43:00 <porges> BMeph: no I didn't :/
22:43:12 <sjanssen> cads: currying is changing (a,b) -> c to a -> b -> c
22:43:20 <dolio> (AxB) -> C is C^(AxB)
22:44:23 <BMeph> porges,dolio: I sit corrected, thanks! :)
22:45:30 <dolio> Which gives you C^(AxB) = (C^B)^A
22:45:34 <cads> so if f :: (AxB) -> C,   curry(f) :: A -> (B -> C)
22:45:45 <sjanssen> cads: and you can also say that "a -> b -> c" is in the "Curry style"
22:45:49 <sjanssen> @type curry
22:45:50 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:45:53 <sjanssen> cads: yes :)
22:46:20 <mmorrow> @pl \(a,b)->(b,a)
22:46:21 <lambdabot> uncurry (flip (,))
22:46:36 <cads> @source uncurry
22:46:36 <lambdabot> uncurry not available
22:46:38 <porges> :t (flip . flip)
22:46:39 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
22:46:50 <mmorrow> @type flip id
22:46:52 <lambdabot> forall b c. b -> (b -> c) -> c
22:46:56 <cads> :t uncurry
22:46:57 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
22:46:59 <mmorrow> @type (flip . flip) id
22:47:00 <lambdabot> forall b c. (b -> c) -> b -> c
22:47:08 <porges> :t (flip . flip) (undefined :: a -> b -> c)
22:47:09 <cads> @type uncurry
22:47:11 <lambdabot> forall a b c. a -> b -> c
22:47:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
22:47:24 <porges> :t flip $ flip (undefined :: a -> b -> c)
22:47:25 <lambdabot> forall a b c. b -> a -> c
22:47:30 <mmorrow> uncurry f (a,b) = f a b
22:47:31 <porges> buh :|
22:47:53 <nolrai_East> one can change a "m (IO a)" into a "(IO (m a))" for all monads m, right?
22:47:57 <chrisdone> unsafePerfummenEntscheidungsproblem
22:48:19 <nolrai_East> porges: flip . flip == id for fuctions.
22:48:28 <BMeph> nolrai_East: Most certainly not! :|
22:48:31 <sjanssen> nolrai_East: no
22:48:39 <porges> why doesn't ((flip . flip) (undefined :: a -> b -> c)) === (flip (flip (undefined :: a -> b -> c)))
22:48:57 <nolrai_East> eh!
22:49:02 <porges> are the type variables not the a,b,c I'm using?
22:49:08 <porges> :t flip $ flip (undefined :: x -> y -> z)
22:49:10 <lambdabot> forall a b z. b -> a -> z
22:49:11 <sjanssen> porges: perhaps GHC is renaming your type variables?
22:49:12 <mmorrow> nolrai_East: i guess the property for that is commutativity
22:49:21 <porges> sjanssen: looks like it :)
22:49:25 <porges> phew.
22:49:30 <mmorrow> i know State isn't commutative
22:50:00 <cjs> So having a thread is cheap, but is forking a thread cheap?
22:50:02 <nolrai_East> :t (flip . flip)
22:50:03 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
22:50:20 <sjanssen> cjs: fairly cheap, yes
22:50:35 <dolio> It's id up to seq.
22:50:49 <sjanssen> cjs: but if you're going to do this very frequently, I'd consider using some sort of priority queue
22:51:01 <cads> is the result of partial application of a function's first argument the same as currying a function and then applying it to the same first argument?
22:51:19 <nolrai_East> What does (flip . flip) do then?
22:51:25 <sjanssen> cads: yes
22:51:28 <dolio> > (flip . flip $ undefined) `seq` ()
22:51:29 <cjs> sjanssen: Quite frequently, so I think you're right.
22:51:29 <lambdabot>   ()
22:51:34 <dolio> > (undefined) `seq` ()
22:51:35 <lambdabot>   * Exception: Prelude.undefined
22:51:44 <cjs> And ooo, a priority queue. Finally I get to use a data structure out of Osaki's book.
22:51:45 <sjanssen> cads: though most functions in Haskell are already in the Curry style
22:51:47 <StoneToad> nolrai_East: it flips the first pair of arguments twice
22:52:15 <porges> seq must die
22:52:19 <dolio> :)
22:52:25 <cads> sjanssen, thanks for clearing it up for me
22:52:26 * sjanssen <3 seq
22:52:45 <solrize> there's a heap module on hackage
22:52:45 <mmorrow> > foldl (*) 1 [1..10000000]
22:53:00 <lambdabot>   thread killed
22:53:01 <nolrai_East> mmorrow: you cant in genral go the other way, say IO [a] to [IO a].
22:53:02 <mmorrow> > foldl' (*) 1 [1..10000000]
22:53:17 <nolrai_East> StoneToad: How is that not id?
22:53:21 <lambdabot>   thread killed
22:53:41 <StoneToad> nolrai_East: I don't know?
22:53:42 <mmorrow> nolrai_East: i guess the other way would also be the same consideration
22:55:05 <sjanssen> nolrai_East: going from (t (m a)) to (m (t a)) is possible when t is a 'Traversable'
22:55:08 <porges> does seq force to WHNF? if so, what is WHNF for a functino
22:55:10 <sjanssen> @docs Data.Traversable
22:55:10 <lambdabot> Data.Traversable not available
22:55:37 <dons> this should get some attention, http://www.reddit.com/r/programming/comments/7lg8y/a_strict_lazy_snake_calling_haskell_from_python/
22:55:40 <sjanssen> porges: seq does evaluate to WHNF
22:55:42 <nolrai_East> sjanssen: Thanks!
22:55:57 <llayland> > let fn (+) = 1; fn x = 2 in fn 1
22:56:01 <lambdabot>   mueval: Prelude.read: no parse
22:56:01 <lambdabot>  mueval: UnknownError "GHC reported errors a...
22:56:19 <mmorrow> , (\x -> [closureType x, x `seq` closureType x]) id
22:56:21 <porges> > (undefined :: a -> b -> c) `seq` ()
22:56:24 <lambdabot>   * Exception: Prelude.undefined
22:56:30 <llayland> hmm
22:56:36 <whisky> has anybody used haskell for linear programming and/or numerical analysis?
22:56:42 <lunabot>  [Fun,Fun]
22:56:56 <mmorrow> , (\x -> [closureType x, x `seq` closureType x]) (1 + 1)
22:57:01 <lunabot>  [AP,Constr]
22:57:14 <porges> closureType (flip . flip $ undefined)
22:57:17 <mmorrow> , (\x -> [isFullyEvaluated x, x `seq` isFullyEvaluated x]) id
22:57:18 <porges> > closureType (flip . flip $ undefined)
22:57:20 <lambdabot>   Not in scope: `closureType'
22:57:23 <lunabot>  [False,False]
22:57:24 <mmorrow> , (\x -> [isFullyEvaluated x, x `seq` isFullyEvaluated x]) (1 + 1)
22:57:25 <porges> , closureType (flip . flip $ undefined)
22:57:30 <lunabot>  [False,True]
22:57:35 <lunabot>  AP
22:57:37 <cjs> whisky: I do do a reasonable amount of numerical stuff for an options trading model in an automated trading program I'm writing.
22:57:43 <porges> , closureType (undefined :: a -> b -> c)
22:57:48 <lunabot>  Thunk 22
22:57:48 <mmorrow> those functions are (unsafePerformIO
22:57:52 <quicksilver> porges: WHNF for a function is when the \ is visible.
22:57:53 <mmorrow> 'd versions of)
22:57:56 <porges> THUNK 22!
22:58:03 <quicksilver> profmakx: (at the top leve, I mean)
22:58:18 <dons> heyaa cjs
22:58:19 <cjs> But it's no huge amount; the CPU time that takes is dwarfed by the time I spend parsing data and shoveling it around.
22:58:22 <mmorrow> RtClosureInspect.{(tipe `fmap`) . getClosureInfo,isFullyEvaluated}
22:58:26 <cjs> Hey Don!
22:58:32 <porges> quicksilver: thanks
22:58:36 <dolio> mmorrow: Your bot just gets nuttier and nuttier.
22:58:41 <porges> @src flip
22:58:41 <cjs> Bought another copy of your book yesterday. Bos was quite happy.
22:58:41 <lambdabot> flip f x y = f y x
22:58:47 <dons> yeah, mmorrow's bookk is crazy-bot.
22:58:50 <dons> bot.
22:58:55 <mmorrow> dolio: that's teh plan!
22:58:56 <dons> cjs: oh hehe.
22:59:05 <dons> cjs: its doing very well. apparently haskell rocks. :)
22:59:13 <cjs> BTW, brave of you to put the negative number stuff right up front. :-)
22:59:20 <porges> so that would be (\x y -> (\x y -> undefined y x) y x) vs. (undefined)
22:59:36 <dons> cjs: hehe.
22:59:57 <mmorrow> dons: yeah, i haven't seen RWH get anything other than rave reviews
22:59:58 <dolio> porges: Right.
23:00:13 <dons> mmorrow: what's the plan with your bot? hackage?
23:00:17 <dons> or avoid that trap :)
23:00:36 <Nafai> I wish my pet projects didn't have to be in Java :/
23:00:48 <cjs> But if you're going to introduce someone to FP, you should be fair. Give them a copy of both RWH and Practical OCaml, and let them come to their own decision.
23:00:50 <mmorrow> dons: i need to put it on hackage.
23:01:01 <dons> generally, very good reviews, yes. the _only_ slight negatives were some beginner programmers who were a bit overwhelmed
23:01:14 <porges> mmorrow: does it have a completely offline component
23:01:14 <dons> more suited for say, Craft of FP.
23:01:22 <porges> mmorrow: suitable for, say, ghci
23:01:31 <dons> cjs: interesting. i'd not thought of that.
23:01:35 <mmorrow> dons: i need to make an interface like the one Yi used to have for the ever-volatile ghc-api though
23:01:43 <dons> i saw some comments to the effect that only in haskell could we cover so much in one volume.
23:01:52 <mmorrow> porges: yes, in fact the bot is just a hacky shell over stuff in here:
23:02:07 <mmorrow> http://moonpatio.com/repos/luna/
23:02:07 <cjs> Well, it's not exactly a small volume.
23:02:13 <dons> true.
23:02:21 <mmorrow> porges: that repo /only/ works with ghc-6.10.1
23:02:33 <cjs> I bought a second copy in EPUB format so I could carry it around in my Sony Reader, rather than having to lug around the paper copy.
23:02:36 <mmorrow> (and haskell-src-exts <= 0.3.8)
23:02:37 <dons> oh cool.
23:02:44 * dons -> bbl
23:03:53 <porges> mmorrow: I already downgraded src-exts for lambdabot >:|
23:03:54 <porges> :D
23:04:00 <Axman6> @hoogle bbl -> a
23:04:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:04:02 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:04:02 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
23:04:06 <Axman6> >_>
23:04:19 <nolrai_East> @help i
23:04:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:04:26 <nolrai_East> @help instances
23:04:27 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
23:04:38 <nolrai_East> @instances Traversable
23:04:40 <llayland> This seems odd to me - Can someone explain why ghci returns 1 for the following: let fn (+) = 1; fn x = 2 in fn 1
23:04:40 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
23:04:48 <cads> don, the content of the book is freely available?
23:05:13 <quicksilver> cads: yes, depending what you mean by 'free'.
23:05:20 <quicksilver> it's available without charge on the internet.
23:05:23 <cads> free as in free beer :D
23:06:16 <porges> :t fn (+) = (+)
23:06:17 <cads> not that FOSS craziness
23:06:18 <lambdabot> parse error on input `='
23:06:32 <porges> :t (\(+) -> (+))
23:06:33 <lambdabot> forall t. t -> t
23:06:44 <porges> llayland: there's the answer :)
23:06:56 <porges> (+) isn't necessarily a binary operator
23:07:33 <Axman6> llayland: (+) just gets bound to 1, it's not the plus operator
23:08:22 <porges> perhaps this is something that a warning could be added to ghc for?
23:08:38 <porges> using a symbol as something not necessarily a binary operator
23:09:04 <mmorrow> porges: heh, yeah i've gotta fix all the various code i have that uses haskell-src-exts to use the new API
23:09:35 <mmorrow> i thought it'd be really easy at first, but it won't quite be trivial
23:09:40 * mmorrow sighs
23:09:52 <mmorrow> but the new haskell-src-exts is sweet
23:10:02 <mmorrow> (sweetER) ;)
23:14:16 <porges> http://hackage.haskell.org/trac/ghc/ticket/2896 :)
23:15:15 <nolrai_East> @ unmlt StateT s [] r
23:15:26 <nolrai_East> @unmtl StateT s [] r
23:15:27 <lambdabot> s -> [(r, s)]
23:16:14 <nolrai_East> @unmtl ListT (State s) r
23:16:15 <lambdabot> s -> ([r], s)
23:17:04 <mmorrow> @unmtl ReaderT r (WriterT w (State s)) a
23:17:05 <lambdabot> r -> s -> (a, w, s)
23:17:18 <mmorrow> @unmtl ReaderT r (StateT s (Writer w)) a
23:17:18 <lambdabot> r -> s -> (a, s, w)
23:17:31 <mmorrow> @unmtl StateT s (ReaderT r (Writer w)) a
23:17:31 <lambdabot> s -> r -> (a, s, w)
23:17:41 <dolio> @unmtl RWST r s w a
23:17:41 <lambdabot> err: `RWST r s w a' is not applied to enough arguments, giving `/\A. r -> w -> a (A, w, s)'
23:17:46 <mmorrow>  @unmtl special-cases RWS
23:17:50 <dolio> @unmtl RWS r s w a
23:17:51 <lambdabot> r -> w -> (a, w, s)
23:18:04 <mmorrow> @unmtl ReaderT r (WriterT w (State s)) a
23:18:04 <lambdabot> r -> s -> (a, w, s)
23:18:33 <mmorrow> @unmtl WriterT w (State s) a
23:18:33 <lambdabot> s -> (a, w, s)
23:18:53 <mmorrow> @unmtl WriterT w m a
23:18:53 <lambdabot> m (a, w)
23:19:09 <mmorrow> @unmtl State s a
23:19:09 <lambdabot> s -> (a, s)
23:19:20 <nolrai_East> @unmtl StateT s Reader a
23:19:21 <lambdabot> err: `Reader (a, s)' is not applied to enough arguments, giving `/\A. a -> s -> A'
23:19:23 <mmorrow> s -> ((a, w), s)
23:19:28 <nolrai_East> @unmtl StateT s Reader e a
23:19:29 <lambdabot> err: `Reader (e, s)' is not applied to enough arguments, giving `/\A. e -> s -> A'
23:19:37 <nolrai_East> @unmtl StateT s (Reader e) a
23:19:38 <lambdabot> s -> e -> (a, s)
23:19:58 <porges> @unmtl @unmtl
23:19:59 <lambdabot> err: Parse error
23:20:10 <mmorrow> i guess @unmtl doesn't special case RWS per-se, but flattens nested tuples
23:20:57 <mmorrow> and in doing so makes some stacks seem commutative that aren't
23:21:28 <mmorrow> ((a,b),c) --> (a,b,c) <-- (a,(b,c))
23:21:33 <nolrai_East> mmorrow: do they have different behavior other than bottom?
23:21:43 <mmorrow> i don't believe so
23:24:22 <mmorrow> err, i shoulda said s/commutative/equivalent/
23:27:04 <sjanssen> @seen conal
23:27:05 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 2h 45m 23s ago.
23:27:58 <conal> sjanssen: hi
23:28:21 <sjanssen> conal: I think your problem is unsafePerformIO
23:28:42 <pumpkin> > unsafePerformBrainSurgery
23:28:42 <lambdabot>   Not in scope: `unsafePerformBrainSurgery'
23:28:45 <pumpkin> :(
23:28:55 <conal> sjanssen: yeah?
23:29:04 <sjanssen> conal: but I'm having a hard time grasping exactly why
23:29:42 <sjanssen> oh, actually it's pretty straightforward
23:30:09 <mmorrow> sjanssen, conal: i'm intrigued, is the relevant code pasted somewhere?
23:30:21 <sjanssen> mmorrow: http://conal.net/blog/posts/smarter-termination-for-thread-racing/#comment-13223
23:30:33 <mmorrow> sjanssen: thx
23:31:39 <conal> sjanssen: i had to revert to my original definition.  even that last version (with unblock removed) fails in some examples.
23:32:09 <conal> sjanssen: which is not cool, since i may have a lot of loose threads.
23:32:39 <conal> strangely, with my original def, i'm getting a lot of "ghc: <<loop>>".  i don't know what could be causing them.
23:32:57 <porges> how long has <<loop>> been in?
23:33:00 <conal> i know they come from NonTermination
23:33:00 <porges> just since 6.10?
23:33:31 <sjanssen> porges: quite some time, 6.6 at least, perhaps earlier
23:33:46 <conal> i think it usually means a black hole
23:33:57 <sjanssen> conal: loop is thrown when GHC detects that the evaluation of a thunk depends on the thunk
23:34:00 <conal> but maybe something else as well.
23:34:00 <sjanssen> yeah, black holes
23:34:37 <porges> sjanssen: just that I've never seen it before, and now I've seen several people mention it in a week
23:34:48 <conal> for now i've "fixed" unamb to catch and silence NonTermination exceptions.  but i'm uneasy about them.
23:35:52 <strht> @type foldr
23:35:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:35:56 <strht> hahahaha
23:35:58 <strht> i get it!
23:36:08 * strht smiles
23:36:25 <pumpkin> yay
23:37:53 <conal> Svrog: hi
23:38:05 <Svrog> hi conal :)
23:38:45 <sjanssen> conal: in (v `unamb` 1) `seq` v, if '1' returns first, then 'v' becomes _|_
23:39:04 <sjanssen> if v returns first, v is not bottom
23:39:31 <conal> sjanssen: really?  how does that work?
23:40:28 <sjanssen> conal: oh, and this is only true when 'v' is some thing using unsafePerformIO
23:41:10 <conal> sjanssen: as in the inner call, f 1
23:41:21 <sjanssen> conal: right
23:41:26 <JoshTriplett> lambdabot: pl (\x -> (x,x))
23:41:36 <sjanssen> join (,)
23:41:54 <sjanssen> JoshTriplett: needs an @ prefix
23:41:59 <sjanssen> @pl \x -> (x, x)
23:41:59 <lambdabot> join (,)
23:41:59 <JoshTriplett> "And playing the role of lambdabot today we have sjanssen"
23:42:01 <JoshTriplett> Thanks. :)
23:42:17 <JoshTriplett> @type join
23:42:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:43:40 <conal> sjanssen: i wonder if my unkilled threads bug is required to avoid the v-becomes-_|_ bug.
23:43:55 <sjanssen> conal: I think it might be
23:44:41 <JoshTriplett> Hmmm.
23:44:54 <JoshTriplett> > join (,) 1
23:44:55 <lambdabot>   (1,1)
23:45:01 <sjanssen> dons: do you know what happens to sparked values that are never referenced again?
23:45:02 <JoshTriplett> That doesn't seem to work with ghci.
23:45:04 <JoshTriplett> sjanssen: ^
23:45:12 <sjanssen> dons: eg. v `par` thingthatneverusesveveragain
23:45:13 <JoshTriplett> No instance for (Monad ((->) a))
23:45:33 <sjanssen> JoshTriplett: that instance can be found in Control.Monad.Instances
23:45:39 <JoshTriplett> Oh.
23:45:48 * JoshTriplett wonders what exactly it means.
23:46:02 <sjanssen> conal: I'm wondering if you can use/abuse par for this
23:46:38 <sjanssen> JoshTriplett: join uses the ((->) a) Monad instance
23:46:43 <conal> sjanssen: that'd be cool.  it's looking like i don't yet have a solid & efficient unamb implementation.  and i depend on it quite a lot.
23:46:57 <porges> @src Monad (->) join
23:46:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:47:38 <porges> I don't know how to look up specific implementations :P
23:47:41 <sjanssen> JoshTriplett: when m = ((->) a), join f = \x -> f x x
23:47:48 <porges> @src Monad (->) (>>=)
23:47:49 <lambdabot> Source not found. It can only be attributed to human error.
23:47:51 <sjanssen> porges: join isn't a class method, so you can't
23:47:55 <sjanssen> @src join
23:47:55 <lambdabot> join x =  x >>= id
23:47:56 <porges> poo
23:48:15 <porges> sorry small sister -_-
23:48:43 <sjanssen> f >>= g = \x -> g (f x) x
23:48:50 <porges> sjanssen: it'd be nice for join to be a class method
23:48:59 <sjanssen> porges: yes
23:49:01 <porges> so you could choose your method of implementing the monad
23:49:18 <strht> functions, functions everywhere
23:49:19 <mgsloan> hrmm, so does Data.FingerTree's measure stuff allow one to have declarative caching of some associative operation?
23:49:20 <strht> not a drop to drink
23:49:42 <porges> x ⤜ f = join (f ⊙ x)
23:49:42 <JoshTriplett> sjanssen: Thanks for the clarification.
23:49:44 <porges> join m = m ⤜ (\x -> x)
23:49:50 <sjanssen> mgsloan: yes, that is exactly what it does
23:49:56 <mgsloan> excellent :)
23:50:21 <strht> > addOnePlusOne 1
23:50:23 <lambdabot>   "Didn't add up, forgot to carry a zero"
23:50:54 <JoshTriplett> sjanssen: Now I've managed to write an incredibly obscure function pointlessly (and I do mean that in both senses):
23:50:58 <JoshTriplett> > let (f::String -> [String]) = uncurry (>>) . ((guard.not.null) *** (return)) . join (,)
23:51:00 <lambdabot>   <no location info>: parse error on input `;'
23:51:06 <JoshTriplett> > let (f::String -> [String]) = uncurry (>>) . ((guard.not.null) *** (return)) . join (,) in f "hello"
23:51:08 <lambdabot>   ["hello"]
23:51:08 <sjanssen> conal: only idea that comes to mind is to use Unix's fork(), but that would be borderline insanity :)
23:51:13 <JoshTriplett> > let (f::String -> [String]) = uncurry (>>) . ((guard.not.null) *** (return)) . join (,) in f ""
23:51:14 <lambdabot>   []
23:51:18 <conal> sjanssen: yeah!
23:51:31 <conal> sjanssen: is this what's going on with my unamb example: v gets evaluated to 'unsafePerformIO <abort>', which is bottom?
23:51:48 <sjanssen> conal: yes, something like that
23:52:26 <JoshTriplett> sjanssen: (The actual function in question actually using the string as the value of a Text.XHtml.Strict "class" attribute, and I didn't want to output class="".)
23:52:31 <quicksilver> sjanssen: I would imagine that a spark doesn't count as a strong reference and such sparks can in principle be GC'ed before they are ever evaluated.
23:52:35 <JoshTriplett> sjanssen: I don't plan to keep the pointless version though. :)
23:52:40 <quicksilver> sjanssen: that's just my guess, though.
23:52:47 <conal> sjanssen: thanks.  that helps a lot.  i don't know how to fix the problem, but at least i have a sense of where to look.
23:54:18 <strht> how does the (x:xs) notation work
23:54:51 <quicksilver> conal: I'm trying to write some tests to evidence the shortcomings in my reactive impl, but currently I don't seem to be able to even prove the non-deterministic mappend bug I know is there :)
23:55:58 <conal> quicksilver: hm.  can you create simultaneous distinct occurrences and check for left-bias?
23:56:05 <porges> strht: in what way?
23:56:19 <porges> strht: if you're using it in a function e.g. "f (x:xs) =..."
23:56:35 <porges> strht: then the first element of the list is bound to 'x' and the rest of the list to 'xs'
23:56:38 <quicksilver> conal: in principle I have a worse problem than that. In principle there is a race which allows events to land out of order
23:56:48 <mmorrow> sjanssen, conal: hmm, that's a really interesting problem (and directly applicable to a ton of stuff)
23:57:04 * mmorrow experiments with it too
23:57:05 <quicksilver> conal: (race condition) - but I've added a synthetic delay which doesn't seem to be enough to force the race as I thought it would.
23:57:27 <cads> strht, x:xs gives us the notion of a list which consists of a head element (x) appended to the remainder of the list (xs)... normally : appends an element to a list, but when used in pattern matching x:xs will match a nonempty list and bind the parts of that list to variables for use in the function at the same time
23:57:33 * sjanssen thinks unamb is evil, but enjoys figuring out the technical problems behind it
23:57:34 <conal> quicksilver: yeah.  if occurrences are nearly simultaneous, you can get the later one first.
23:57:44 <sjanssen> 1 `unamb` 2 -- frightens me
23:58:02 <mmorrow> on this topic, TIMBER looks like it'd be perfect for getting the timeliness/etc guarantees that're hard/impossible to get from ghc
23:58:28 <conal> sjanssen: it's like fromAscList in Data.Map or like declaring a class instance and not having the compiler verify the class laws.
23:59:04 <conal> sjanssen: dependent types could solve these problems someday.
23:59:18 <strht> porges: i mean how does it reduce to assembly, really
23:59:21 <sjanssen> conal: unamb feels worse to me.  fromAscList will always return the same result, even though the result doesn't make sense
23:59:26 <mmorrow> conal: i hope sooner than later
23:59:34 <conal> mmorrow: me too!
23:59:44 <strht> how does the parser see (x:xs) and pop off the first element
23:59:50 <sjanssen> conal: unamb can return whichever value depending on how heavily loaded your computer is
