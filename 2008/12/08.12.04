00:14:16 <osfameron> who's planet haskell these days, dons?
00:14:41 <osfameron> I got a comment on blog saying ~"please stop spamming planet.haskell with perl stuff"~
00:15:24 <osfameron> originally ISTR there being small print along the lines of "we want to know what you're blogging about in general" and I thought I also suggested the /tags/haskell feed if you wanted purely haskell-related stuff
00:15:40 <osfameron> but I can resubmit with that if the non-haskell content is annoying :-)
00:18:38 <osfameron> I know, I'll email planet@ to ask
00:19:19 <osfameron> ah, on second thoughts, it's in the FAQ, I'm covered.  But if anyone does object to my perl witterings, please let me know
00:46:20 <mapreduce> $_
00:47:07 <mapreduce> I was surprised my Java stuff ended up on Planet Scala.  If I was administering Planet X I'd filter for X in the title.
01:00:53 <ivanm> mapreduce: generally, planet.x sites are there for more than just stuff on x
01:01:15 <ivanm> but also to give other people an idea of what other people are doing (i.e. trying to prove themselves "normal" :p )
01:01:28 <osfameron> true
01:01:37 <osfameron> though does blogging about perl classify you as normal? ;-)
01:02:15 <Korollary> planets are an old idea anyway. The haskell reddit makes more sense.
01:03:02 * luqui likes planets
01:03:28 <luqui> it's nice to see what haskell-minded folks do in ruby, for example
01:03:36 <mapreduce> Panic?
01:03:44 <luqui> =P
01:03:52 <Korollary> You could see that without a planet.
01:04:33 <luqui> Korollary, oh?
01:04:51 <luqui> (I'm assuming you're not responding to the panic joke...)
01:05:03 <Korollary> I don't panic. I write a lot of perl at work.
01:13:09 * jkff gradualy starts to somewhat succeed in coqifying free theorems
01:13:26 <Cale> Oh, nice example of a non-constructive proof for which no constructive one is known: starting with an n-by-m grid of cookies, players take turns eating a cookie, plus all those above and to the right of it. The lower left cookie is poisoned. (The first person to eat it loses.)
01:14:11 <opqdonut> so the proof is for a winning strategy?
01:14:39 <Cale> The first player always has a winning strategy for this game. Either the top right cookie is a winning strategy, or the second player has a move afterward which puts him in a winning position. But if that's the case, the first player could have eaten that cookie instead.
01:15:45 <jkff> I think that it should be easy to prove the *existence* of a constructive proof
01:15:54 <Cale> Apparently the general winning strategy for this game is unknown (although the square case, and the 2-by-n case have been done.)
01:15:56 <Korollary> heh
01:17:01 <jkff> Everything is finite, so even the set of games  is finite, so a strategy would be to just enumerate all the games starting from now and choose one where all the outcomes are winning.
01:17:11 <jkff> However that poses the question of constructively proving that one exists :)
01:17:21 <jkff> That could probably be proven by recursion on n and m
01:17:42 <opqdonut> err
01:17:43 <jkff> Where am I wrong?
01:17:51 <Cale> jkff: There are an infinite number of games you're trying to do it for though.
01:17:52 <opqdonut> in the finite step
01:17:59 <opqdonut> but yeah, induction might work
01:18:11 <jkff> Why is the number of games infinite for a finite grid?
01:18:20 <opqdonut> m and n are parameters...
01:18:37 <jkff> But an enumerating strategy can be built for any m and n
01:18:46 <opqdonut> yes of course
01:18:50 <Cale> Any individual m and n
01:18:56 <opqdonut> for a finite game we can just go through the game tree
01:19:01 <jkff> Precisely
01:19:04 <Cale> But the question is whether the first player wins for all m and n.
01:19:25 <opqdonut> yep
01:20:10 <Korollary> Is this game really on a rectangle? To me it sounds like it's on a line.
01:20:18 <jkff> Is a constructive proof just unknown or is it proven to be non-existent?
01:20:26 <Cale> jkff: unknown.
01:20:45 <jkff> Probably its existence is orthogonal to our system of axioms :)
01:20:50 <opqdonut> Korollary: well effectively on two lines at once
01:20:51 <Cale> Korollary: It's a rectangle, though my use of 'above' was perhaps a little awkward.
01:21:13 <opqdonut> Korollary: or rather, we play to line-versions of that game at once
01:21:14 <Korollary> Does above mean all cookies with higher y values?
01:21:33 <Cale> Oh, by "all the cookies above and to the left" I mean the whole rectangle.
01:21:34 <opqdonut> all cookies with higher x anr higher y
01:21:38 <opqdonut> yeah
01:22:07 <Cale> oh, here's a page with nice pictures...
01:22:13 <Cale> http://plus.maths.org/issue14/xfile/
01:22:17 <lambdabot> Title: Mathematical mysteries: Chomp
01:23:21 <Cale> It can be generalised to be played on an arbitrary poset, where a player eats all the points of the poset greater than or equal to the chosen point.
01:23:57 <Cale> (and then if there's a maximum element, the strategy stealing argument shows that it's a first player win again)
01:25:32 <opqdonut> how about omega x omega
01:25:34 <Cale> So you can construct a proof that the first player wins (we know the first player will win because of the nonconstructive proof), for any individual m and n, by constructing the game tree explicitly. But the trick is constructively showing that it'll always come out to a first player win.
01:26:14 <Cale> opqdonut: Oh, that's an interesting case :)
01:26:26 <opqdonut> i'd say player two wins
01:27:21 <opqdonut> or hmm, it's not that straightforward
01:27:43 <Korollary> How does the 1st player lose?
01:28:30 <opqdonut> Korollary: i was thinking that no2 can play so that on her turn there is a maximal element
01:29:26 <luqui> that game is nim by sprague-grundy, no?
01:29:37 <Cale> luqui: It's certainly related...
01:29:40 <jkff> I guess first player wins for (n,m)>(1,1)? Because he loses if n=m=1
01:30:00 <Cale> jkff: oh, yes, of course :)
01:30:15 <jkff> Is that the only condition?
01:30:19 <Cale> yeah
01:31:35 <Cale> luqui: Oh, yes.
01:32:02 <jkff> Shouldn't the poset be a lattice?
01:32:25 <Cale> jkff: Depends on how much you'd like to generalise :)
01:33:05 <jkff> Well, if we're talking about posets, seems like the precise condition for the theorem to be true is that the poset must be a lattice with more than 1 element.
01:33:18 <jkff> If it isn't a lattice, the theorem may not be true
01:34:24 <Cale> A poset with a maximal element and at least one other seems to work.
01:34:33 <Cale> er, maximum element
01:34:58 <BeelsebobWork_> Peaker/quicksilver either of you about?
01:35:07 <BeelsebobWork_> oh, luqui you might do -- have you tried building reactive recently?
01:35:21 <jkff> But the condition says that a player loses if he eats the minimum element, so it's also needed.
01:35:50 <Cale> Apparently omega x omega x omega chomp is an open problem.
01:36:02 <Cale> jkff: You could also make it the last element.
01:36:10 <jkff> Ah, ok then
01:36:39 <Cale> "All varieties of Chomp can also be played without resorting to poison by using the mis√®re play convention"
01:36:42 <Cale> hehe
01:37:56 <luqui> BeelsebobWork_, no, I've been hubristic building my own frp system, as usual
01:38:09 <BeelsebobWork_> yeh, I thought your probably would have
01:38:50 <Peaker> BeelsebobWork_: I just cabal upgrade'd and it successfully installed reactive-0.9.8
01:39:36 <BeelsebobWork_> hmm, I think my bug is down to an old TypeCompose (not sure yet), but I'm getting errors about zipWith, and I didn't get a configure error about my TypeCompose version
01:39:42 <Cale> Aha, omega x omega is a first player win
01:39:48 <BeelsebobWork_> I wonder if conal forgot to bump the dependancy in the cabal file
01:40:04 <Cale> The first player picks (1,1), and then responds to (a,0) with (0,a) and vice versa.
01:41:14 <quicksilver> BeelsebobWork_: damn! I can now replicate the problem conal had with my joinE
01:41:26 <BeelsebobWork_> oh? lame :(
01:41:37 <quicksilver> BeelsebobWork_: for me it works fine with simple event streams, but it deadlocks on recursive ones
01:41:55 <quicksilver> such as the one you get implicitly when you try to use snapshot recursively
01:42:10 <quicksilver> obviously something isn't quite "productive enough"
01:42:15 <BeelsebobWork_> yeh
01:42:20 <quicksilver> but a train journey's poking didn't lead me to the right bit, yet.
01:42:22 <BeelsebobWork_> hmm, I wonder if that's the bug Peaker was having actually
01:42:40 <quicksilver> was Peaker's behaviour recursive?
01:43:06 <Peaker> BeelsebobWork_, quicksilver: my bug was in the implementation of snapshotWith_, apparently.. I didn't have recursive behaviors
01:43:13 * quicksilver nods
01:43:16 <BeelsebobWork_> oh, okay
01:43:23 <BeelsebobWork_> I didn't know yours had been solved
01:43:24 <quicksilver> well mine is also to do with snapshotWith
01:43:29 <Peaker> in the implementation of snap/snapshot actually
01:43:31 <quicksilver> but only when I use it recursively.
01:43:42 <Peaker> BeelsebobWork_: its partially solved, the "solution" has a space leak, but at least it functions
01:43:46 <quicksilver> joinE works fine when I use it to implement catMaybesE
01:43:57 <quicksilver> and snapshotWith works fine non-recursively
01:44:00 <quicksilver> but combine the two...
01:44:08 <Peaker> BeelsebobWork_: Now I've got a severe performance issue
01:45:11 <BeelsebobWork_> Peaker: because of the space leak?
01:45:48 <Peaker> BeelsebobWork_: nope, I think its because I'm using monoidB on an ever-increasing sequence of geometry3 disks
01:46:14 <quicksilver> that sounds like you're using increasingly more space
01:46:17 <quicksilver> rather than a space leak as such
01:46:17 <BeelsebobWork_> indeed
01:46:22 <Peaker> BeelsebobWork_: I'd expect every redraw to be a bit slower (having to draw more disks) but even drawing thousands of disks with OpenGL should be pretty cheap
01:46:24 <BeelsebobWork_> and increasingly more time to render them
01:46:43 <BeelsebobWork_> Peaker: remember that they're not just disks -- they're tesselated disks
01:46:47 <Peaker> quicksilver: yeah, I do use increasingly more space, the space leak is in lilac's solution to my problem, regardless of my use of space
01:47:25 <Peaker> actually its only a space leak if the snapshot event never/lately comes (which is not in my case, so there's no space leak from that in my case)
01:48:23 <Peaker> BeelsebobWork_: they're very small, my game is basically "pune", little "worms" drawing themselves on the screen, progressing forward (the tail is not deleted in that game)
01:48:57 <BeelsebobWork_> oh, it's tron like?
01:49:10 <BeelsebobWork_> yeh, I would expect that to be nice and fast
01:49:45 <quicksilver> Peaker: oh that's interesting. I have that space leak too.
01:50:18 <quicksilver> snapshots with rarely-occurring events will accumulate space until the event occurs.
01:50:27 <quicksilver> I assumed that one was easy to fix, but I havne't looked at it yet :)
01:50:35 <Peaker> BeelsebobWork_: sort of, with 2 major differences: Direction is a double (angular), rather than 0..3 (only right angles), and (not yet implemented) there will be "holes" in all the worms you can pass through, (and the tail does not disappear)
01:50:45 <quicksilver> recursive snapshots not working at all, is more important to me.
01:50:56 <BeelsebobWork_> Peaker: ah, fun fun
01:51:06 <Peaker> BeelsebobWork_: its an awesome game, very addictive :-)
01:51:18 <Peaker> BeelsebobWork_: and its amazing how much strategy can arise from the simple game
01:51:21 <quicksilver> Peaker: http://roobarb.jellybean.co.uk/~jules/Picture%20173.png
01:51:25 <BeelsebobWork_> quicksilver: fingers crossed, peter and chrighton's discussion about integral will get that moving
01:51:33 <BeelsebobWork_> hehe, that's fun
01:51:33 <quicksilver> Peaker: watch the memory usage drop every time I click a button ;)
01:51:39 <BeelsebobWork_> also, how did you get colour quicksilver?
01:51:41 <BeelsebobWork_> and thin lines!
01:51:55 <quicksilver> colour is hp2ps -c
01:52:04 <quicksilver> thin lines I don't know? side effect of using ps2pdf?
01:52:10 <BeelsebobWork_> possibly
01:52:12 <quicksilver> or side effect of the scale?
01:52:12 * BeelsebobWork_ tries
01:52:13 <Peaker> quicksilver:  :-)
01:52:51 <quicksilver> BeelsebobWork_: OSX's built in postscript to PDF convert is incredibly slow and a bit buggy
01:52:58 <quicksilver> ps2pdf is much better.
01:53:02 <quicksilver> I don't know why, though...
01:53:02 <BeelsebobWork_> ah yeh
01:53:07 <BeelsebobWork_> ps2pdf did indeed do a better job
01:53:10 <ToRA|MSR_> quicksilver: can opaqueord even (safely) exist with between-run inconsistent behaviour and no io?
01:53:25 <quicksilver> ToRA|MSR_: I'm not entirely sure.
01:53:46 <quicksilver> ToRA|MSR_: I think it ought to be possible to design a typeclass which works in cooperation with an efficient map library
01:53:57 <quicksilver> ToRA|MSR_: without exposing the inconsistencies
01:54:00 <quicksilver> ToRA|MSR_: but I'm not sure how.
01:54:09 <BeelsebobWork_> Peaker: don't suppose you could compile reactive with -p --ghc-option=-auto-all, and profile your program, I'd be interested to see the heap profile of it
01:54:14 <ToRA|MSR_> trusted base of code springs to mind
01:54:21 <quicksilver> BeelsebobWork_: no need for profiling
01:54:27 <BeelsebobWork_> hmm?
01:54:27 <quicksilver> BeelsebobWork_: -hT works with a non-profiling compile
01:54:38 <quicksilver> pretty neat little known feature
01:54:46 <quicksilver> -hT gives you closure profiling without a profiling compile.
01:55:01 <BeelsebobWork_> yeh, but I want to know about cost centres within reactive
01:55:06 <BeelsebobWork_> (hence the -auto-all too)
01:55:13 <quicksilver> oh, fair enough.
01:55:19 <quicksilver> I find closures are often good enough.
01:55:37 <quicksilver> you'll still see things like FRP.Reactive.Stepper
01:55:54 <BeelsebobWork_> yeh, it's the exact function name I want to know
01:56:17 * BeelsebobWork_ ponders why when you use -M in hp2ps, it doesn't let the paths take up the whole first sheet
01:56:21 <BeelsebobWork_> it still limits them to the same width
01:56:26 <Peaker> BeelsebobWork_: I think the new reactive broke my program (version dependency hell) :)
01:56:33 <BeelsebobWork_> Peaker: oh, lame :(
01:56:57 <Peaker> reactive-0.9.6:FRP.Reactive.Internal.Behavior.BehaviorG  VS  R.BehaviorG
01:57:10 <BeelsebobWork_> oh, that means you haven't re-configured/built something
01:57:16 <BeelsebobWork_> probably reactive-glut or reactive-fieldtrip
01:57:22 <Peaker> how can I remove ghc-pkg's? Can I only "hide" but not remove them?
01:57:31 <Peaker> BeelsebobWork_: I tried "cabal install" in the darcs repo's of both
01:57:34 <BeelsebobWork_> ghc-pkg unregister
01:57:40 <Peaker> BeelsebobWork_: does that remove the package files?
01:57:49 <BeelsebobWork_> I don't think so no
01:57:53 <quicksilver> no, just hides it
01:58:07 <quicksilver> erm, hide is slightly different
01:58:08 <BeelsebobWork_> hmm, I would ping dcoutts about that, because cabal install should have sorted out that dep
01:58:14 <quicksilver> but no it doesn't remove it
01:58:20 <quicksilver> (phsyically)
01:58:57 <BeelsebobWork_> hide says "keep the package registered so I can get it back easily, but don't let programs see it", while unregister says "I don't want this any more"... it just happens to be conservative about deleting files on your system
01:59:04 <BeelsebobWork_> that's my interpretattion of it at least
01:59:44 <Peaker> now that's a space leak :)
01:59:50 <Saizan> hidden packages don't matter to cabal, btw
02:00:13 <Peaker> ok I got rid of all the older reactive stuff, now it compiles
02:00:21 <BeelsebobWork_> win :)
02:00:27 <Peaker> but its broken now, let me see if I remember how I broke it ;)
02:00:42 <BeelsebobWork_> hehe
02:01:02 <BeelsebobWork_> wait... I'm a noo
02:01:04 <BeelsebobWork_> noob
02:01:08 <quicksilver> Saizan: not even in terms of which one it chooses for an unversioned dependency?
02:01:21 <BeelsebobWork_> yesterday I was asking if anyone could see a better way of writing uncurry (&&) . (isForAll *** (not . isVar)
02:01:37 <BeelsebobWork_> but it is ofc isForAll <^(&&)^> (not . isVar)
02:01:39 <Saizan> i think for managing libs spread over multiple packages the best solution might be a modified hackage-server that interfaces with darcs
02:01:59 <BeelsebobWork_> oh, wait, no it isn't
02:02:21 <Saizan> quicksilver: you mean if there are multiple versions available it might prefer the not hidden one? i'm not sure
02:02:38 <BeelsebobWork_> hmm, which is better... ((isForAll . fst) <^(&&)^> (not . isVar . snd)) or uncurry (&&) . (isForAll *** (not . isVar)
02:02:42 <Saizan> available and matching the required version range
02:02:44 <quicksilver> Saizan: that is what I meant. I also don't know the answer.
02:03:16 <quicksilver> BeelsebobWork_: I think I prefer the second.
02:03:26 <quicksilver> BeelsebobWork_: prefer to avoid explicit use of fst and snd where possible.
02:03:32 <BeelsebobWork_> yeh, ditto
02:03:42 <BeelsebobWork_> otoh, I also prefer to avoid uncurry where possible :/
02:03:49 <Peaker> BeelsebobWork_: ok, now it runs... I need to find your command again now
02:03:51 <quicksilver> BeelsebobWork_: although "uncurry (&&)" would make me pause for a moment.
02:03:53 <quicksilver> right.
02:04:30 <Peaker> BeelsebobWork_: ghc: unrecognised flags: -p --ghc-option=-auto-all
02:04:30 <BeelsebobWork_> Peaker: runhaskell Setup.hs configure -p --ghc-option=-auto-all
02:04:38 <Peaker> BeelsebobWork_: I don't have a Setup.hs...
02:04:41 <Peaker> BeelsebobWork_: just a single .hs file
02:04:45 <BeelsebobWork_> Peaker: when configuring reactive I mean
02:04:47 <Peaker> oh
02:05:00 <Peaker> BeelsebobWork_: can those options be passed to "cabal install" ?
02:05:01 <BeelsebobWork_> and then build your program with ghc --make -prof -auto-all singleFile
02:05:08 <BeelsebobWork_> Peaker: oh, pass
02:05:10 <Peaker> (or should I just run configure/build/install on my own, instead)
02:05:21 <BeelsebobWork_> I have no idea how that will interact with cabal install
02:05:44 <Peaker> BeelsebobWork_: that seems to want the deps to also be compiled with -p
02:06:15 <BeelsebobWork_> yep, it will do
02:06:25 <BeelsebobWork_> having said that -- it's useful to have -p turned on for all your libraries
02:06:26 * Peaker compiles the entire world with -p then
02:06:30 <BeelsebobWork_> hehe >.<
02:06:38 <BeelsebobWork_> I would hope that means cabal install -p
02:06:40 <Saizan> quicksilver: just tested, and it doesn't matter
02:06:41 <BeelsebobWork_> but I don't know
02:07:20 <Peaker> I had a ^ ^ ^ ^ ^^ line appended into a .cabal file -- is that darcs being silly?
02:07:35 <BeelsebobWork_> it sounds like it yes
02:07:42 <BeelsebobWork_> it sounds like you had a conflict at some point
02:08:47 <quicksilver> Saizan: interesting thanks
02:09:25 <quicksilver> Saizan: good to know so that I can explain it here if it ever comes up.
02:09:42 * quicksilver doesn't actually use cabal install, or indeed packages from hackage much.
02:10:02 <Saizan> btw, "cabal install" accepts all the "runghc Setup configure" flags in priciple, in practice --constraint is not implemented for cabal-install
02:10:46 <Peaker> BeelsebobWork_: wouch, lots of recompilations required :)
02:10:54 <BeelsebobWork_> ouch, sorry
02:11:17 <Ezla> how do you implement a singleton in Haskell?
02:11:31 <Peaker> BeelsebobWork_: at least with "cabal" recompiling is kinda fun :)
02:11:37 <BeelsebobWork_> haha
02:11:42 <Peaker> yay, I have reactive installed with -p
02:11:47 <Peaker> (and -auto-all)
02:12:21 <quicksilver> Ezla: well a top-level value is a singleton.
02:12:54 <quicksilver> although for certain kinds of initialisation pattern you need to create it inside IO, in which case it won't be global.
02:13:01 <quicksilver> haskell tends to avoid global mutable state.
02:13:04 <Ezla> quicksilver that doesn't really solve the problem
02:13:16 <Ezla> what if you have 4 haskell object files each compile separately
02:13:16 <quicksilver> I'm unlikely to be able to solve your problem if you don't tell me what it is.
02:13:25 <Ezla> or 3...
02:13:26 <Peaker> BeelsebobWork_: how do I profile it now?
02:13:39 <opqdonut> Ezla: well one just exports a "variable"
02:13:40 <BeelsebobWork_> Peaker: ./myProg options +RTS -hC
02:13:44 <opqdonut> that contains the "singleton"
02:13:52 <BeelsebobWork_> then hp2ps myProg
02:13:55 <Ezla> A, B, C... A is a logger... now C starts up, triggering B... B now lazily instanciates A, the logger
02:14:13 <Peaker> BeelsebobWork_: "options" literally?
02:14:18 <Ezla> simply exporting is not enough, because they have to start up in some order
02:14:18 <Peaker> BeelsebobWork_: or <options> ?
02:14:24 <BeelsebobWork_> Peaker: no, any options you would normally pass to your program
02:14:27 <Peaker> BeelsebobWork_: ah, ok
02:14:36 <quicksilver> there's no analogue for 'file-scope static constructors' in haskell
02:14:41 <opqdonut> yeah
02:14:48 <Peaker> BeelsebobWork_: invalid heap profile option: -hC
02:14:49 <quicksilver> ...you woudln't be able to control the initialisation order if there was.
02:14:57 <quicksilver> instead, you control the initialisation explicitly
02:15:03 <quicksilver> presumably in your main action somehow.
02:15:08 <Ezla> You can't control initialization order, and that's why you need a singleton
02:15:17 <Ezla> it lazily instanciates
02:15:25 <Ezla> and then shuts down based on closed dependencies
02:15:31 <quicksilver> I understand what you're saying.
02:15:33 <sjanssen> Ezla: singletons are not a very nice assumption, usually
02:15:38 <Peaker> Ezla: if the initialization is an IO action, you can either go "hacky" and use unsafePerformIO to create it globally, or you can do the "right thing" and just explicitly initialize it in your main and pass it along
02:15:55 <quicksilver> I'm just saying, that's not an idiomatic construct in haskell.
02:16:07 <quicksilver> GHC provides enough rope to hang yourself
02:16:12 <quicksilver> with unsafePerformIO and so on
02:16:16 <quicksilver> but that's not the path I'd recommend.
02:16:16 <Ezla> how can it not be an idiomatic construct? You have global A, and global B
02:16:22 <sjanssen> Ezla: isn't it reasonable to assume that your application might want to distinct loggers active?
02:16:22 <Peaker> Ezla: globals are anti-patterns
02:16:32 <quicksilver> global mutable variables are not idiomatic haskell.
02:16:44 <quicksilver> (global immutable values are fine, of course)
02:16:55 <Ezla> you can't avoid globals for static resources, without needing to snake some variable in thousands of places throughout your codebase
02:17:03 <Ezla> say for example, that your app has a "Configuration" singleton
02:17:09 <Ezla> its a map of config settings to values
02:17:14 <Ezla> in a tree
02:17:15 <quicksilver> monads are the idiomatic haskell solution to the snaking
02:17:15 <Peaker> Ezla: mutable globals are a bad idea - pass them as arguments. Fortunately, Haskell has abstractions not available in other languages that allow you to pass your arguments to a lot of functions much more easily
02:17:28 <Ezla> If you do not use a global, you have to pass a "cfg" reference *EVERYWHERE*
02:17:36 <Peaker> Ezla: in weaker languages, that's true, in Haskell, you can use the Reader monad
02:17:38 <Ezla> so No, globals are not an antipattern...
02:17:41 <quicksilver> monads are a way to hide an arbitrary amount of snaking and plumbing.
02:17:42 <sjanssen> Ezla: in Haskell, you'd create that Configuration object and pass it to each function that needs it (or use a Monad that automates that passing)
02:17:53 <quicksilver> (and related abstractions like Applicative)
02:17:59 <Ezla> sjanssen: that's unmaintainable
02:18:04 <Peaker> Ezla: in Haskell, passing "cfg" reference *everywhere* does not require explicitly mentioning it in the parameter and argument lists everywhere as it would in weaker languages
02:18:15 <Ezla> Peaker: why/how
02:18:32 <Ezla> isnt that just a global then?
02:18:34 <Ezla> lol
02:18:39 <Peaker> Ezla: Because monad binding can do things like pass arguments you want to pass, and the monad type can do things like describe the arguments you want passable
02:18:40 <sjanssen> Ezla: how experienced are you in Haskell?  It is very common to use ReaderT for configurations, and it works very well
02:18:41 <jeffz`> Ezla: hi gavino
02:18:42 <blackh> This is what I like about Haskell! Finally a language that doesn't let you do singletons. I'm a real muesli head when it comes to programming.
02:18:54 <jeffz`> sjanssen: he's experienced at trolling #haskell
02:19:16 <Peaker> Ezla: its not global, no, because the monad bind is passing it, and you could of course pass something else
02:19:22 <sjanssen> jeffz`: are you sure Ezla is gavino?
02:19:37 <jeffz`> sjanssen: 98%.
02:19:46 <Ezla> who the fuck is Gavino
02:19:53 <Ezla> I'm Ezla
02:20:00 <sjanssen> jeffz`: if you can cite that somehow, it would be useful
02:20:00 <quicksilver> meta-discussions are not productive, jeffz`
02:20:13 <quicksilver> especially not in-channel.
02:20:19 <quicksilver> Ezla is asking interesting questions.
02:20:26 <Ezla> k anyways ;)
02:20:27 <blackh> Haskell is great because of all the wonderful things you can't do with it.
02:20:42 <Ezla> So, regarding what you said about monads
02:20:47 <sjanssen> @remember blackh Haskell is great because of all the wonderful things you can't do with it.
02:20:47 <lambdabot> Good to know.
02:20:54 <Peaker> Ezla: so for example, if a lot of your program is in IO (), and you want it to have access to a mutable global state, you could define a type like: type EzlaMonad = (StateT IO) -- and thus functions which are of this type "implicitly" take this global state argument, and when you call functions its implicitly passed.  Using "get" and "put" you can access that state, but you can also abstract that away to only allow get and certain modules to "put"
02:21:01 <Ezla> You don't have to put "cfg" in each function?
02:21:06 <sjanssen> let's hope that blackh is not being sarcastic
02:21:20 <quicksilver> sjanssen: the quote is good whatever the original intention ;)
02:21:22 <Ezla> Peaker: I see
02:21:28 * blackh is definitely not being sarcastic.
02:21:29 <sjanssen> Ezla: the monad will automate the argument passing
02:21:29 <Ezla> so its binding is inherited
02:21:43 <quicksilver> Ezla: essentially everything that was going to be of type "IO a" is instead of type "EzlaMonad a"
02:21:48 <quicksilver> that's the main change.
02:21:55 <quicksilver> although actually you often don't want everything to be the same type
02:22:00 <Ezla> sounds good
02:22:05 <Ezla> Quicksilver: yeah, so
02:22:06 <quicksilver> you want the type system to annotate that some functions can only read from it, not change it
02:22:17 <Ezla> how do you make refinements of EzlaState ?
02:22:18 <quicksilver> so you get better documentation/safety of your intentions.
02:22:40 <Peaker> Ezla: To illustrate *roughly* how that works, in Haskell you can have something like:  type Reader a = EzlaGlobal -> a ;  and then you can define your functions as  myFunc :: Blah -> Reader Int  ;  and then the "EzlaGlobal" and any others are not mentioned in the param list.
02:22:47 <sjanssen> and you also get more flexibility than a singleton
02:22:49 <Ezla> quicksilver: cant I make a monad of the EzlaMonad ?
02:22:55 <Ezla> to further refine types?
02:23:17 <Peaker> Ezla: EzlaMonad is already a monad
02:23:24 <Ezla> peak: a monad of a monad
02:23:31 <blackh> Ezla: I did some useful stuff with monads. I'm writing a web applications and I made a group of monads that let me do things like this:
02:23:49 <tomh> hey if i got a list of a list with tuples and i want to sort it on 3 different tuples like ("author",value) ("price",value) and ("place",value) would implementing Ord be appropriate? because i will have to sort it 3 times
02:23:53 <blackh> - stuff that can only be done when there's a user logged in
02:24:08 <blackh> - database writes in a separate section to page output
02:24:16 <sjanssen> Ezla: I don't understand what you mean about "a monad of a monad"
02:24:16 <quicksilver> Ezla: yes, you can. You can have various refinements and join them together
02:24:25 <blackh> It took a bit of setting up, but it's very convenient to use and gets rid of lots of potential bugs.
02:24:31 <quicksilver> sjanssen: I believe what he wants is a refinement which only permits get (say)
02:24:51 <Ezla> <quicksilver> although actually you often don't want everything to be the same type   <--- so this isnt a flaw, you're just saying I need to further refine
02:24:59 <quicksilver> yeah, not a flaw
02:25:03 <quicksilver> just a further elaboration
02:25:06 <quicksilver> on what is possible
02:26:12 <Ezla> what's haskell's equivalent of the "standard library" ?
02:26:47 <Saizan> @docs
02:26:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:26:50 <quicksilver> the Prelude is like a very compact standard library
02:26:59 <quicksilver> and then there is a larger standard which used to be called 'extralibs'
02:27:10 <quicksilver> and it's now going to be replaced by something called 'the haskell platform'
02:27:13 <quicksilver> which isn't quite ready yet.
02:27:26 <quicksilver> binary installers of 6.8 come with a bunch of extralibs.
02:27:35 <sjanssen> haven't heard much about HP lately, I wonder how that is going
02:27:39 <Ezla> http://www.haskell.org/haskellwiki/Haskell_Platform
02:27:39 <quicksilver> 6.10 doesn't, which is one reason I don't really recommend 6.10 until the platform is finished.
02:27:40 <lambdabot> Title: Haskell Platform - HaskellWiki
02:27:54 <Ezla> what the hell?
02:28:05 <quicksilver> I think it was a mistake to release 6.10 without extralibs, without HP being ready.
02:28:08 <quicksilver> but heck, I don't do the work :P
02:28:10 <Ezla> ", by taking the best libraries from the more than 900 libraries of haskell.org. It provides a"
02:28:15 <quicksilver> someone had to make a call.
02:28:27 <Ezla> how can you possibly have an overall "design" and architecture, consistent set of Concepts and requirements for Concepts,
02:28:35 <Ezla> when you combine from a set of 900 libraries?
02:28:49 <sjanssen> Ezla: they won't use all 900
02:28:58 <Ezla> obviously, but
02:29:09 <Ezla> it the example of C++'s std:
02:29:17 <sjanssen> Ezla: and they don't necessarily have to have a single design, as long as they're orthogonal
02:29:41 <sjanssen> Ezla: HP is going to be much more inclusive than C++'s standard library
02:29:59 <Ezla> std defined "Concepts" which are a type interface that must be met... for Container A to work with algorithm B, A needs to satisfy various "Concepts" -- for example, LessThanComparable in order to be sortable in an ordered manner
02:30:11 <Ezla> and the whole entire library was perfectly unified under these concepts
02:30:26 <Ezla> where such a large project like "The Haskell Platform" is more of a loose knit collection?
02:30:27 <BeelsebobWork_> sorry Peaker -- got grabbed by my boss
02:30:34 <BeelsebobWork_> is that all it said about -hC?
02:30:44 <opqdonut> Ezla: of course the Prelude is consistent
02:30:47 <Saizan> Ezla: we have classes like those in the base package, e.h. Ord, Monad, Foldable ...
02:30:52 <opqdonut> and defined basic classes such as Ord etc
02:31:23 <Saizan> also, it's easy to add an instance for a type, if it's missing
02:31:25 <Ezla> does Haskell have a fundamental notion of Concepts in syntax of the language itself?
02:31:33 <Ezla> because Concepts are polymorphism for static types
02:31:43 <Ezla> they provide an interface that a type must meet
02:31:46 <opqdonut> err yes
02:31:49 <sjanssen> Ezla: C++0x's concepts are actually based on a Haskell feature called "type classes"
02:31:50 <opqdonut> typeclasses are exactly that
02:31:57 <opqdonut> :
02:31:58 <opqdonut> )
02:32:09 <Ezla> So, does the base package use typeclasses?
02:32:16 <Ezla> Ord?
02:32:19 <sjanssen> Ezla: also, I don't want to seem rude, but I bet some of these questions would be answered if you tried working through a Haskell tutorial for a little while :)
02:33:02 <opqdonut> Ezla: Ord is the "concept" of an ordering
02:33:05 <Ezla> and, does "The Haskell Platform" connect together perfectly with typeclasses
02:33:14 <opqdonut> and yes, the base package uses and defines them
02:33:21 <opqdonut> well as perfectly as it can
02:33:24 <Ezla> opqdonut: But... does the "concept" use a typeclass?
02:33:29 <opqdonut> libraries are programmeed by individuals
02:33:43 <opqdonut> Ezla: because a concept is a typeclass
02:33:57 <opqdonut> a typeclass is just an "interface" that a type has to implement
02:34:11 <Ezla> neat
02:34:28 <Twey> But those 'interfaces' can include default implementations.
02:34:45 <opqdonut> yes
02:34:59 <opqdonut> and with associated types they can do even more
02:36:12 <Twey> :t compare
02:36:14 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
02:36:31 <Twey> The first two arguments mean 'any type that implements Ord'
02:36:49 <Ezla> so do haskell people consider "type class" to be what provides static type polymorphism?
02:36:58 <opqdonut> (and data Ordering = LT | GT | EQ
02:36:59 <opqdonut> )
02:37:14 <sjanssen> Ezla: type classes are a method of providing ad hoc overloading
02:37:25 <Twey> But in a slightly more controlled fashion :-P
02:37:30 <sjanssen> (in the least ad hoc way possible)
02:37:40 <opqdonut> and a tool for (parametric?) polymorphism
02:38:06 <sjanssen> parametric polymorphism is another thing in Haskell
02:38:15 <opqdonut> parametric is type variables?
02:38:18 <sjanssen> C++ templates mix the two
02:38:34 <opqdonut> i can never remember the distinctions between the different polymorphisms
02:38:50 <sjanssen> opqdonut: parametric polymorphism are types that are parameterized on types
02:38:55 <sjanssen> like Maybe, or lists
02:39:01 <blackh> Type classes are seriously fun. I like the fact that the methods can be polymorphic on the return type so e.g. you can declare a 'defaultValue' function that returns a default value of a specific type, with no argument.
02:39:06 <opqdonut> sjanssen: ah
02:39:10 <mapreduce> Parametric polymorphism is dispatch on type.  Polymorphism as in OO is dispatch on value (class).
02:41:03 <Twey> In C++-like OO languages, class is type
02:41:07 <Saizan> parametric polymorphism is no-dispatch
02:41:15 <Saizan> typeclasses are dispatch on types
02:41:29 <Peaker> BeelsebobWork_: it followed that with the entire usage
02:42:39 <Ezla> there's hardly any information on the haskell platform
02:42:49 <opqdonut> *choke*
02:42:52 <Twey> What is the 'Haskell platform'?
02:43:08 <Badger> house!
02:43:11 <sjanssen> @google inurl:haskellwiki Haskell platform
02:43:13 <Twey> Hahaha
02:43:13 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Platform
02:43:13 <lambdabot> Title: Haskell Platform - HaskellWiki
02:43:18 <Ezla> THAT page has nothing
02:43:18 <blackh> There are two main ways to make a set of polymorphic OO-style objects:  A single data structure containing several functions, or multiple data structures with a type classes adding common functionality between them.
02:43:24 <Ezla> i followed every link from there
02:43:30 <Ezla> and already read the whole thing
02:43:33 <sjanssen> Ezla: it isn't actually out yet
02:43:36 <Twey> Oh arr
02:43:39 <Twey> That's interesting
02:43:43 <Badger> yarrrr.
02:43:45 <blackh> But only with the first kind can you put different ones in the same list!
02:44:08 <sjanssen> Ezla: if you want to have a look at the libraries distributed with GHC, this link is better:
02:44:11 <sjanssen> @docs
02:44:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:44:22 <Ezla> sjanssen: Not the GHC ones
02:44:28 <Ezla> I wanted a list of stuff slated for T H P
02:44:40 <sjanssen> Ezla: you'll see a list when the list is done.
02:45:17 <Peaker> Ezla: did you go through a Haskell tutorial?
02:45:26 <Ezla> Peaker, I didn't finish yet
02:45:34 <Ezla> is GHC 90% as fast as it can be, or 40% ?
02:45:43 <opqdonut> THP is quite a new concept
02:46:03 <Peaker> Ezla: on some code, its 100% as fast as it could be, and on some its 0.001% as fast as it could be
02:46:08 <sjanssen> Ezla: this is not a useful question.  Who can say what the theoretical best is for GHC?
02:46:10 <Peaker> (probably less!)
02:46:10 <Ezla> in the next 10 years.. will we see a doubling, or just scraping a little bit here and there
02:46:40 <opqdonut> well a doubling in floating point code generation probably
02:46:42 <Peaker> Ezla: Low-level Haskell code already performs pretty much like C.  The interesting question is how well can we make High-level code perform, and that's improving all the time
02:46:43 <Toxaris> blackh: I wouldn't count the second choice (multiple data structures instantiating the same type class) as that much similiar to OO-style objects, because there is no dynamic dispatch
02:46:50 <opqdonut> + in the performance of +
02:46:50 <Ezla> sjanssen: Those kinds of estimations, I'd think, come from years of using the thing and knowing so much you can get a feel for it
02:47:30 <blackh> Toxaris: Ah, true.
02:47:31 <Peaker> Ezla: I don't think anyone can predict how it will improve in the following years, but SPJ/et al seem to me like they are focused on getting multi-core stuff to perform well now
02:47:32 <Toxaris> blackh: unless you count every call of a higher order function as dynamic dispatch, then almost every FP program is OO style :)
02:47:46 <sjanssen> Ezla: well, if past releases of GHC are any indication, there is more potential to be tapped.  GHC 6.8 added optimizations like pointer tagging and spec constr which can be hugh performance wins in certain applications
02:48:13 <Ezla> why does GHC need to use C-- at all?
02:48:34 <blackh> I think multi-cores will be a Big Deal in five years and the industry will not know what hit it.
02:49:07 <sjanssen> Ezla: look at past proceedings of ICFP and the Haskell Symposium.  Just about every year you'll see a paper from the Simons describing new things they've added to GHC
02:49:13 <Saizan> it uses C-- as portable assembly, roughly
02:49:28 <flux> isn't c-- exactly intended for the purpose ghc uses it for?
02:49:43 <Ezla> Saizan: so GHC doesn't do direct x86 opcode emission?
02:50:07 <Saizan> Ezla: it does, compiling C-- to assembly
02:50:16 <sjanssen> GHC doesn't exactly use C--.  It has a phase that is called "Cmm" that is rather similar to C--
02:50:27 <BeelsebobWork_> oh wow
02:50:37 <vegai> oh my, yi is rather impressive these days
02:50:39 <BeelsebobWork_> conal's changes last night introduced a *major* space/time leak for me
02:50:42 <blackh> Ultimately I think Haskell will get a just-in-time compiler like Java HotSpot. Then it will really clean up.
02:51:00 <Badger> BeelsebobWork_: you are now outside the confines of the known universe?
02:51:07 <Saizan> in the past the default was Haskell -> Core -> Cmm -> C -gcc-> asm -> mangling -> final asm
02:51:17 <Saizan> afaiu
02:51:28 <Peaker> BeelsebobWork_: I'm on ghc 6.10.1, btw, there doesn't seem to be a -hC
02:51:38 <Peaker> BeelsebobWork_: Usage says: -hT      Heap residency profile (output file <program>.hp)
02:51:47 <blackh> If Haskell had a really good JIT it could automatically parallelize. That would take some serious engineering but it could be done.
02:51:48 <Ezla> what the hell
02:51:58 <Ezla> Cmm was a subset of C? compiled by GCC?
02:52:00 <BeelsebobWork_> Peaker: I'm on 6.10.1 too, and -hC deff outputs a heap profile with cost centres
02:52:06 <Ezla> then how can it even do proper tail call recursion
02:52:08 <Lemmih> blackh: s/Haskell/GHC/. There isn't just one Haskell compiler.
02:52:09 <BeelsebobWork_> :/
02:52:11 <Ezla> C-- was made to allow that stuff
02:52:15 <Ezla> where gcc straight does not
02:52:28 <blackh> Lemmih: That's why I said Haskell, not GHC
02:52:45 <Ezla> c-- was unbridaled by functional restrictions
02:52:54 <Peaker> BeelsebobWork_: The +RTS usage help only shows -hT, and -hC is an "invalid heap profile option"
02:53:04 <sjanssen> Ezla: meet the Evil Mangler: it mangles gcc's output to add things like tail calls
02:53:12 <Ezla> wtf
02:53:13 <Ezla> lol
02:53:25 <Saizan> Cmm was compiled to C by GHC, btw
02:53:29 <Lemmih> blackh: When you compile Haskell to, say, JavaScript, does it make sense to have a JIT compiler?
02:53:30 <Ezla> But things aren't like that anymore, huh?
02:53:37 <BeelsebobWork_> Peaker: wierd -- I get this... http://hpaste.org/12682
02:53:50 <sjanssen> Ezla: it is still around, but isn't used by default.  They're working on getting rid of it for good
02:53:59 <Peaker> BeelsebobWork_: maybe -auto-all was not passed on correctly, somewhere?
02:54:01 <Ezla> ah
02:54:18 <BeelsebobWork_> Peaker: did you compile your program with ghc --make -prof -auto-all myProg?
02:54:22 <sjanssen> the current default process goes something like: Haskell -> Core -> Cmm -> asm
02:54:22 <Lemmih> blackh: Adding such features to a specific implementation might make sense but not to the language as a whole.
02:54:28 <Peaker> BeelsebobWork_: yeah
02:54:32 <blackh> Lemmih: You could compile it to Java and get a JIT compiler for free, but it wouldn't be a very good one.
02:54:39 <Peaker> BeelsebobWork_: oh, no -prof
02:54:41 <quicksilver> Ezla: the default path is now Cmm -> native code
02:54:41 <blackh> ...for Haskell's purposes, I mean
02:54:48 <Ezla> cool
02:54:50 <quicksilver> Ezla: the Cmm -> C -> mangler was pretty sick ;)
02:55:01 <Peaker> BeelsebobWork_: ah, now I find more dependencies need compilation
02:55:08 <sjanssen> blackh: what would a JIT offer over the current ahead-of-time compilation to native code?
02:55:12 <BeelsebobWork_> Peaker: lol >.<
02:55:13 * Twey gives medicine to the mangler.
02:55:21 <BeelsebobWork_> that's so not good :(
02:55:30 <Ezla> JIT offers nothing
02:55:33 <Ezla> except eval
02:55:44 <Ezla> loading of new code at rt.
02:55:47 <quicksilver> sjanssen: just-in-time inlining and specialisation
02:55:52 <blackh> sjanssen: JITs are capable of giving a vast performance increase, because they give the optimizer information it can't possibly guess at compile time.
02:55:56 <Peaker> Ezla: Why do you say that?
02:56:07 <sjanssen> quicksilver: specialization could be nice
02:56:18 <Ezla> ah, well what blackh said I agree with
02:56:21 <blackh> Haskell would benefit from a JIT far more than Java does...
02:56:22 <quicksilver> sjanssen: fusion could apply to more cases than it currently does if RULES could be invoked just-in-time after a specialise/inline phase
02:56:28 <Ezla> except in the case of profile guided optimizations
02:56:28 <Lemmih> blackh: You're missing the point. You obviously can't output Java if JavaScript (or ISO C, for that matter) is your target.
02:56:42 <Ezla> where you trace that stuff through test runs
02:56:50 <blackh> Because Haskell could use it to determine granularity of operations for efficient parallelization...
02:56:52 <Lemmih> blackh: Haskell compilers can be /very/ different.
02:56:53 <Peaker> Ezla: profile-guided optimizations will be biased towards some arbitrary profile whereas JIT will optimize that which *actually* runs at that time
02:56:57 <blackh> ...which can't be done by a static compiler.
02:57:14 <Ezla> Peaker: while the JIT itself has to spend time compiling
02:57:27 <Ezla> but, it's a noble cause
02:57:32 <Peaker> Ezla: yes, but it can do so only if it pays off
02:57:41 <Peaker> Ezla: (if something runs a lot, recompile that)
02:57:43 <sjanssen> question: GHC is kind of slow, do we really want to execute it at run time? :P
02:57:57 <quicksilver> sjanssen: the current architecture isn't really suited for it, IMO.
02:58:04 <blackh> sjanssen: JITs are not bad from this point of view.
02:58:11 <quicksilver> sjanssen: but it's interesting to imagine one which was...
02:58:12 <Toxaris> sjanssen: but JIT would work on some bytecode level, not on Haskell
02:58:13 <Peaker> sjanssen: consider that a lot of text parsing/linking slowness will not be necessary in a JIT
02:58:14 <Ezla> is there an LLVM-haskell project?
02:58:15 <blackh> ....because....
02:58:20 <quicksilver> sjanssen: obviously typechecking would be done already.
02:58:29 <quicksilver> Ezla: I think EHC has an LLVM target
02:58:31 <blackh> 95% of the time is spent executing 5% of the code.
02:58:45 <quicksilver> Ezla: EHC is more for education and experimentation than deployed usage though.
02:59:15 <quicksilver> Ezla: the GHC devs have some strong reasons why they did not think llvm was appropriate. I don't know if some of them have changed since it was last investigated though.
02:59:24 <blackh> So you just interpret 95% of your "Haskell bytecodes" and JIT compile the remaining 5%
02:59:34 <Peaker> BeelsebobWork_: compiling OpenGL, GLUT, FieldTrip, .... :-)
03:00:00 <blackh> The other way to make Haskell fast is to compile direct to FPGA. Now that would be cool. Get rid of the data bus!
03:01:23 <quicksilver> blackh: enter the reduceron
03:01:24 <Ezla> blackh: that's not really optimal for all kinds of use
03:01:28 <Ezla> say you make an...
03:01:29 <Ezla> fps game?
03:01:53 <blackh> I was going to mention the Reduceron but I forgot what it was called.  That is the kind of thing that gets me very upbeat and stoked.
03:01:55 <Ezla> and not very often, do you run into an Vector-man
03:02:00 <Ezla> but when you do, FPS drops to nil
03:02:40 <blackh> What we want is a self-modifying FPGA with a little itinerant JIT floating about in it.
03:03:05 <blackh> Unless that wouldn't work, which is quite probable.
03:03:07 <solrize_> sjanssen, yes, there's applications i'd like to write (long running servers) where runtime ghc would be great no matter how slow it is
03:03:49 <golubovsky> Hi, Dimitry here
03:03:52 <sjanssen> solrize_: well, ideally we could just arrange for the magic optimizations to happen at compile time
03:04:04 <blackh> Hello Dimitry!
03:04:18 <sjanssen> gentlemen, the answer is more SPECIALIZE pragmas!
03:04:32 <golubovsky> Who is currently in charge for Haskell community code server?
03:04:44 <solrize_> sjanssen, not always possible, i may want to build up some function at run time, f = g . (map h xs) . ...
03:04:51 <solrize_> where that's a messy stream pipeline
03:05:05 <solrize_> and i'd want to have all the stream fusion stuff happen
03:05:22 <blackh> golubovsky: Do you mean Hackage?
03:05:34 <sjanssen> s/stream fusion/fusion
03:05:41 <golubovsky> blackh: I mean code.haskell.org
03:05:45 <sjanssen> GHC doesn't offer stream fusion for lists right now
03:05:57 <solrize_> e.g. for text processing, i'd want to runtime configure something like (f = convert each word to lower case) (g = strip suffixes according to the selected language) (h = unicode normalization) etc
03:06:10 <quicksilver> solrize_: just use hs-plugins
03:06:16 <quicksilver> solrize_: (or ghc-api)
03:06:17 <solrize_> quicksilver, hmm
03:06:24 <blackh> g: I don't know
03:06:33 <quicksilver> solrize_: that gives you access to the whole compilation service including the optimisations.
03:06:49 <solrize_> quicksilver, maybe that's what i want, i will look into it
03:06:59 <quicksilver> solrize_: I was considering use it for a similar purpose (translating a custom query language into haskell, and then using GHC's optimiser to make it fuse)
03:07:00 <Peaker> how do people compile anything with -prof?  The entire world needs to be recompiled!
03:07:22 <golubovsky> @seen dcoutts
03:07:22 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
03:07:25 <Peaker> sjanssen: doesn't it offer it partially via rewrite rules? (map composition, map id, etc)?
03:07:29 <sjanssen> golubovsky: http://community.haskell.org/admin/ "    *
03:07:29 <lambdabot> Title: Haskell Community Server
03:07:33 <sjanssen> For anything else, please e-mail support [AT] community.haskell.org. "
03:07:40 <quicksilver> Peaker: fusion, just not stream fusion
03:07:45 <sjanssen> Peaker: GHC uses foldr/build fusion, not stream fusion
03:07:51 <quicksilver> Peaker: stream fusion is a specific technique.
03:08:00 <Twey> solrize_: getPipeFunction key = fromMaybe (error "No such pipe") (lookup key pipes) where pipes = [("f", map toLower), ("g", stripSuffices), ("h", normaliseUnicode)]
03:08:10 <solrize_> quicksilver do i then have to actually generate haskell source code and call the compiler?  i just want a function like optimize :: (a->b) -> (a->b)   where i build up some function through normal compositon, binding, etc. then hand it off to the optimizer and get a fast version back
03:08:21 <Peaker> quicksilver, sjanssen: What's the difference?
03:08:39 <solrize_> twe hmm
03:08:45 <quicksilver> solrize_: you have to generate source code and call the compiler.
03:08:55 <Peaker> quicksilver: map f . map g --- fused two lists/streams, no?
03:08:55 <golubovsky> sjanssen: OK, thanks, I'll try this email. I thought somebody is online.
03:08:57 <solrize_> i guess that's tolerable
03:08:58 <quicksilver> solrize_: haskell functions are opaque, you can't runtime optimize them
03:09:03 <Twey> Oh, was I over-simplifying?
03:09:09 <quicksilver> Peaker: yes, it's just not called stream fusion.
03:09:18 <sjanssen> Peaker: they're just different systems, see the relevant papers for detailed information
03:09:18 <Twey> Can't one tweak them with TH?
03:09:25 <quicksilver> Peaker: "stream fusion" is a specific algorithm described in a paper.
03:09:26 <Peaker> sjanssen: ah, ok
03:09:32 <Peaker> quicksilver: I see
03:09:42 <solrize_> quicksilver, well if there were a compiler flag to keep the Core representation attached to some functions...
03:10:01 <golubovsky> bye
03:10:11 <quicksilver> solrize_: which phase? ;)
03:10:28 <quicksilver> solrize_: sounds complicated to get write. generating source code and compiling it is easy (if boring)
03:10:32 <quicksilver> s/write/right/
03:10:34 <sjanssen> solrize_: you'd also have to link in all of GHC...
03:10:44 <sjanssen> into your application, I mean
03:10:50 <solrize_> yeah, i guess.  i just know there are lisp systems that are like that
03:11:11 <ivanm> who did the camp video on youtube?
03:11:24 <quicksilver> sjanssen: which is what ghc-api and hs-plugins do after all :)
03:11:43 <quicksilver> solrize_: GHC is quite different from "those lisp systems" in many many many ways.
03:11:48 <quicksilver> ivanm: iggly_
03:11:48 <solrize_> true
03:11:51 <quicksilver> ivanm: Igloo
03:11:56 <quicksilver> ivanm: (stupid tab complete)
03:12:03 <ivanm> quicksilver: lol
03:12:31 <hugo___> hi
03:12:49 <blackh> Hello hugo___
03:13:15 <sjanssen> that camp video was very interesting.  I was surprised to learn that other DVCS don't support the sort of branching darcs does
03:13:26 <sjanssen> I've become very attached to that feature
03:13:28 <solrize_> can hs-plugins call functions across the plugin boundary, i mean upwards (the plugin calling into the app)?
03:14:00 <quicksilver> solrize_: yes.
03:14:05 <quicksilver> solrize_: if you pass the plugin a callback
03:14:09 <quicksilver> (or whatever)
03:14:27 <solrize_> ic, i will look at the docs, it sounds like i can use this
03:14:31 <quicksilver> sjanssen: is it possible to briefly explain what "that sort of branching" is?
03:16:04 <sjanssen> quicksilver: the ability to work on two features in a single branch, and the ability to cherry pick only one feature or the other
03:16:43 <osfameron> is that because it's a bad idea?
03:16:48 <osfameron> it certainly sounds like one
03:16:53 <sjanssen> osfameron: I haven't had trouble with it
03:17:09 <sjanssen> I do experimental changes along with bugfixes in xmonad all the time
03:17:15 <osfameron> don't you have to go through each change cherry-picking whether it relates to feature X or feature Y ?
03:17:26 <quicksilver> sjanssen: I certainly consider that a bad idea
03:17:29 <osfameron> I can see cases were that's useful...
03:17:34 <quicksilver> although I know it's a commonly requested facility for bzr
03:17:44 <quicksilver> (and there is a partial support for it)
03:17:44 <osfameron> but I'm uncomfortable with it as a general practise
03:17:48 <sjanssen> osfameron: darcs determines dependencies in many cases (patches which modify the same line are automatically dependent, for example)
03:18:00 <osfameron> I believe git has some support for cherry-picking no?
03:18:02 <quicksilver> it seems bad to work on a feature in an environment (patchset) which is different from that you expect it to be used.
03:18:07 <quicksilver> sjanssen: yes, but that's obviously broken
03:18:11 <osfameron> sjanssen: ah ok: that might be the missing link that I don't get
03:18:18 <quicksilver> sjanssen: since it can't possibly understand code dependencies properly
03:18:25 <osfameron> then again, I find branching/git/etc. confusing enough as it is
03:18:27 <quicksilver> why pretend that this crude line-based approach is useful?
03:18:41 <sjanssen> quicksilver: no, not all of them.  You can add explicit dependencies on patches also
03:18:46 <quicksilver> you can
03:18:49 <quicksilver> btu I bet people don't
03:18:54 <sjanssen> quicksilver: patches which edit the same line are dependent out of necessity
03:18:59 <quicksilver> sjanssen: obviously yes.
03:19:01 <sjanssen> (you're right, people don't use that feature)
03:19:10 <quicksilver> but it's a crude lower bound
03:19:21 <quicksilver> the only way you can know for sure is by testing that particular combination
03:19:35 <sjanssen> or having some clue about your code
03:19:37 <quicksilver> and if you're going ot make the combination - to test it - why not just use that combination to commit from?
03:19:42 <quicksilver> that's what I do with bzr
03:19:51 <quicksilver> make many cheap closely related branches
03:19:57 <quicksilver> and pull commits over when I choose to.
03:20:05 <quicksilver> but only work on one 'thing' per branch.
03:20:05 <sjanssen> you have to decide ahead of time whether you need to branch or not
03:20:16 <quicksilver> I don't think I do.
03:20:18 <sjanssen> with darcs, you are allowed to branch after the fact
03:20:21 <quicksilver> I can branch at a moment's notice
03:20:47 <osfameron> how do you not get confused about which code is in which branch?
03:21:07 <quicksilver> sjanssen: *nod* I can obviously see that the programmer can understand his code in principle.
03:21:14 <quicksilver> and so he can make this call himself.
03:21:23 <quicksilver> but personally I wouldn't be sure , until I'd tested it.
03:21:33 <quicksilver> and if I'm going to test it, why not just work in that branch
03:21:37 <sjanssen> say you're working on a large new feature, but you notice a small error that you'd like to quickly fix.  The feature might take a long time until it's ready for upstream, but you can make the bug fix in seconds.  What do you do?
03:21:59 <quicksilver> sjanssen: immediately branch from the previous committed version, and commit the fix
03:22:15 <quicksilver> and then merge that fix to all other branches to which it applies.
03:22:22 <sjanssen> quicksilver: seems like an annoying interruption
03:22:36 <sjanssen> in darcs, I make the edit, record only that small change, darcs push/send
03:22:51 <quicksilver> but then you haven't tested that change in isolation
03:22:58 <luqui> why are you not incrementally committing during your large change?
03:23:03 <quicksilver> you've only tested it in the context of your other (uncomitted) large change
03:23:12 <kfish> luqui, exactly
03:23:18 <quicksilver> one day that will bite you.
03:23:29 <luqui> plus, in git, you just git stash :-)
03:23:33 <sjanssen> luqui: I might be recording locally, but I can't commit upstream because the feature totally breaks everything
03:23:48 <quicksilver> I guess it's very easy to get used to a particular workflow and then find it hard to understand other people's.
03:23:52 <quicksilver> Which is why I asked the question.
03:24:03 <quicksilver> but I'm personally very happen with the notion of extremely cheap branching
03:24:03 <kfish> so make a quick branch, commit that, return to your working branch, and rebase
03:24:17 <quicksilver> and testing small bug fixes in the appropriately cheaply made branch.
03:24:22 <quicksilver> just like kfish just said, in fact.
03:24:25 <sjanssen> quicksilver: if I'm afraid the change might be bad, I'd make a quick branch from upstream, pull only the bugfix change from my working repo, then test
03:24:32 <quicksilver> right.
03:24:37 <sjanssen> but usually I know what I'm doing, and this is not necessary
03:24:50 <quicksilver> at that point you might as well have done what I did.
03:24:54 <blackh> quicksilver: Cheap branching ... do you mean making a new copy with darcs init / darcs pull in a new directory?
03:24:57 <ksf> in fact, both git and darcs have their advantages, i'd love to see a rcs that can natively support both's workflow, as it's then going to be the one rts that transcendends the last rts dichtonomy there is.
03:25:05 <quicksilver> blackh: I use bzr.
03:25:17 <quicksilver> blackh: I'm not sure the darcs syntax for a cheap branch.
03:25:26 <lilac> quicksilver: cp
03:25:33 <sjanssen> blackh: "darcs get" on a local repo is very fast (uses hard links to share files where necessary)
03:25:33 <opqdonut> yep
03:25:34 <SKuhn> hi, how can I specify that a must implement Eq ? http://haskell.pastebin.com/m3a31b256
03:25:34 <lilac> or darcs get
03:25:36 <quicksilver> (I don't know the git syntax either, but I know that git is capable of this)
03:25:37 <sjanssen> lilac: wrong, use darcs get
03:25:47 <opqdonut> branching in darcs is a PITA
03:25:52 <opqdonut> i don't want multiple working copies
03:26:01 <sjanssen> I actually like that
03:26:05 <opqdonut> also checking out/tagging old revisions is as painful as in svn
03:26:07 <opqdonut> i love git
03:26:08 <ksf> git branch consists of writing a hash into a file.
03:26:16 <sjanssen> I think I'd forget about branches if they were in the same directory
03:26:17 <quicksilver> SKuhn: add the Eq a => constraint to all your functions (empty, member, insert, delete, etc)
03:26:30 <quicksilver> SKuhn: so insert :: Eq a => a -> Set a -> Set a
03:26:34 <SKuhn> quicksilver: can't I just add it to the constructor?
03:26:35 <quicksilver> SKuhn: and similarly for the others.
03:26:43 <quicksilver> SKuhn: that turns out not to be useful, no.
03:27:14 <quicksilver> opqdonut: I don't find multiple working copies a pain.
03:27:19 <quicksilver> in fact, I find them very helpful.
03:27:23 <SKuhn> is it just possible for member?
03:27:25 <opqdonut> i find them ugly
03:27:25 <blackh> quicksilver: How does bzt cheap branching differ from git stash?
03:27:27 <opqdonut> also
03:27:34 <quicksilver> I have about 10 working copies of our repo.
03:27:35 <opqdonut> i can't push all my branches to a single public repo
03:27:40 <quicksilver> blackh: it's not quite as fast ;) But it's OK.
03:27:41 <opqdonut> i have to have multiple public repos
03:27:46 <lilac> sjanssen: it depends whether you interpret 'cheap' to mean 'small disk space' or 'fast to type' :)
03:27:47 <yitz> opqdonut: why don't you want multiple working copies when you branch?
03:27:59 <opqdonut> I might want them
03:28:03 <opqdonut> i don't want to be forced to have them
03:28:09 <yitz> opqdonut: imo this is one of the nicest feature of darcs
03:28:10 <quicksilver> blackh: it's certainly a similar principle.
03:28:20 <opqdonut> yitz: see what i said about public repos
03:28:51 <blackh> I have 4 working copies of my svn (which sucks relative to the newer rcs's) repository for my day job - that hogs a lot of disk space because it's a big project. This is the downside of not branching in place.
03:29:10 <yitz> opqdonut: you can have exactly the number of public repos that you want. what's the problem?
03:29:13 <blackh> (svn won't branch in place either.)
03:29:21 <opqdonut> yitz: well managing them is the problem
03:29:27 <quicksilver> blackh: bzr has a format which shares the "repo part" I.e. the histories.
03:29:32 <opqdonut> it's just like having to have trunk/ and tags/ in svn
03:29:33 <ksf> blackh, you can use git to do that, it can sync backs to svn and even make it useable.
03:29:33 <quicksilver> blackh: it doesn't share working copies.
03:29:35 <sjanssen> quicksilver: oh, the camp video says that GHC uses darcs cherry picking.  Bug fixes are generally committed to the head, which are then pulled to the stable branch
03:29:38 <opqdonut> git just takes care of this stuff for me
03:29:55 <athos> sjanssen: which video are you referring to?
03:29:56 <sjanssen> quicksilver: that might be a more convincing real life example
03:30:01 <quicksilver> blackh: as it happens I don't really have a disk space problem.
03:30:17 <quicksilver> sjanssen: I know they do that. I think they are wrong to do so. I was wondering if you could convince me they were not ;)
03:30:38 <quicksilver> sjanssen: I always commit bug fixes to stable, test in stable, and then merge back to head.
03:31:02 <quicksilver> athos: the 'Camp' video
03:31:09 <sjanssen> athos: http://projects.haskell.org/camp/unique
03:31:10 <lambdabot> Title: Camp
03:31:16 <athos> sjanssen: thx
03:31:41 <sjanssen> quicksilver: well, they have an extensive test suite that is supposedly run before every commit
03:31:43 <athos> quicksilver: i bet you'd explain recursion like: to define what recursion is, one must first define recursion
03:31:46 <athos> 8)
03:32:28 <kowey> kosmikus: hi! any details about the next Haskell Hackathon (as in dates?)
03:32:57 <sjanssen> quicksilver: anyway, darcs supports your workflow too.  I think it is nice to at least have the option
03:33:29 <sjanssen> it is also a bit surprising that other systems don't support it
03:35:04 <mib_px7y7l> What's the nth bit of an Int? Does it depend on the platform? I am referring to the FFI.
03:35:32 <sjanssen> mib_px7y7l: the size of Int does depend on the platform
03:35:41 <Twey> Platform-dependent, yes
03:35:53 <Twey> maxBound will tell
03:35:57 <sjanssen> mib_px7y7l: you should never ever use Int when interfacing with C, use CInt and friends
03:36:37 <mib_px7y7l> sjanssen: what's the first bit of 01?
03:36:51 <blackh> mib: bit 0 = least significant
03:37:18 <mib_px7y7l> blackh: ok
03:37:44 <blackh> mib: This is the "standard" meaning of the nth bit of an integer
03:37:53 <Ezla> > 10 * -1
03:37:54 <lambdabot>       precedence parsing error
03:37:54 <lambdabot>          cannot mix `(*)' [infixl 7] and prefi...
03:37:57 <Ezla> ???
03:38:06 <quicksilver> > 10 * (-1)
03:38:08 <lambdabot>   -10
03:38:09 <sjanssen> > 10 * negate 1
03:38:09 <Ezla> that's enough reason not to use haskell
03:38:10 <lambdabot>   -10
03:38:15 <quicksilver> unary minus in haskell is an embarrasment
03:38:16 <sjanssen> Ezla: don't troll
03:38:19 <Ezla> I'm serious
03:38:23 <Ezla> what a fundamental flaw
03:38:28 <Ezla> how can that be acceptable
03:38:32 <ivanm> Ezla: there's probably other languages that have the same issue
03:38:44 <ivanm> Ezla: because how many times do you have a literal negative value?
03:39:02 <Ezla> the 10 * -1 thing completely changes my perspective on Haskell
03:39:04 <sjanssen> Ezla: it is annoying, but is not a major problem in practice
03:39:29 <sjanssen> Ezla: then you're a very superficial, and perhaps slightly silly, person :)
03:39:34 <blackh> Ezla: Does "map (-1) ns" change it back again?
03:39:45 <sjanssen> map (-1) ns won't work
03:39:50 <Ezla> sjanssen: there's no reason for that flaw
03:39:50 <opqdonut> indeed.
03:39:52 <sjanssen> > (-1) -- is always negate
03:39:53 <lambdabot>   -1
03:39:58 <blackh> Oops
03:40:01 <roderyk> having trouble with a gtk2hs skeleton app, so I narrowed it down to something like this: http://hpaste.org/12683  Am I missing some kind of sync/paint function? The drawArea remains gray and does not render any Render () I set it too. What am I missing?
03:40:01 <Ezla> it shows a profound lack of core design
03:40:02 <quicksilver> Ezla: there is, of course, a reason.
03:40:05 <sjanssen> Ezla: there are reasons, learn something before making these assertions
03:40:10 <mjrosenb> is % a function or a constructor?
03:40:16 <quicksilver> mjrosenb: a function
03:40:20 <mjrosenb> oh..
03:40:23 <quicksilver> mjrosenb: which is a fairly thin wrapper around a constructor
03:40:25 <sjanssen> mjrosenb: it is a function that pretends to be a constructor on occasion
03:40:26 <quicksilver> (:%)
03:40:33 <sjanssen> @src (%)
03:40:34 <lambdabot> x % y = reduce (x * signum y) (abs y)
03:40:36 <Ezla> if Haskell can't even function as a simple calculator... I don't know how I could take Haskell seriously
03:40:45 <opqdonut> Ezla: well neither can c++
03:40:52 <SKuhn> http://haskell.pastebin.com/m6ad095c9 , how can I make union right? My own type doesn't match [] ;(
03:40:54 <Ezla> of course C++ can
03:40:56 <opqdonut> one has to _compile_ it for heavens sake
03:41:00 <sjanssen> Ezla: spell "-" as "negate", all problems solved
03:41:04 <opqdonut> write a _main_ function
03:41:07 <opqdonut> shudder
03:41:29 <sjanssen> > map (+3) [0 ..] -- can your C++ do this?
03:41:30 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
03:41:38 <Ezla> sjanssen: yes
03:41:40 <mjrosenb> Ezla: so if - is negate, then what do you use to subtract
03:41:52 <Toxaris> Ezla: do you have an alternative proposal regarding the parsing of "-"?
03:41:53 <mjrosenb> Ezla: or is a b shorthand for a + b?
03:42:17 <Ezla> why can't - bind to b and also function as an infix
03:42:22 <Ezla> in a context dependent way
03:42:28 <opqdonut> because that's ugly
03:42:31 <Ezla> umm
03:42:34 <Ezla> how so?
03:42:35 <opqdonut> it would be a special case operator
03:42:42 <mjrosenb> Ezla: because context free grammars are so much nicer
03:43:03 <Toxaris> opqdonut: hmm, and currently "-" is not a special case?
03:43:07 <Ezla> that's not even requiring a context free grammar
03:43:18 <Ezla> context free grammars can do  a + b and  a + -b
03:43:20 <sjanssen> Ezla: it complicates the grammar very much.  Should "4 * - 3" mean something different from "4 * -3"?
03:43:33 <opqdonut> yeah one can differentiate between prefix and infix - with a cfg
03:44:06 <mjrosenb> also, there's currently a rather well established syntax for $infix_operator $expression
03:44:29 <mjrosenb> like using (:[])
03:44:43 <mjrosenb> or (^2) and (+1)
03:44:56 <Ezla> and, um, if you have to make one tiny "exception" in all of Haskell, to allow numbers to work properly
03:45:03 <Ezla> by all means, let basic mathematics come first
03:45:43 <sjanssen> Ezla: (-) works the way it does because Haskell has operator sections, other languages don't
03:45:50 <yitz> Ezla: that's already the case with -, and many people don't like it.
03:45:57 <zipMe> So 2 day ago I log in here and Ezla is trolling... I come back today and who is there ?? Have you been there all this time Ezla ???
03:46:22 <sjanssen> the designers decided operator sections are more important than small annoyances with (-)
03:46:56 <mjrosenb> isn't - also required for the definition of Num a?
03:46:58 <yitz> I'm fine with - the way it is, but some people would rather dump it and just use negate
03:47:12 <opqdonut> mjrosenb: yep
03:47:30 <mjrosenb> at which point you'd need to also special case - for declaring functions
03:47:37 <Ezla> show me an example where operator sections are ambiguous with -1
03:47:40 <sjanssen> yitz: I'd consider dropping (-) as negate, but also add it to the lexical syntax for number literals
03:47:57 <sjanssen> Ezla: (-1), operator section or negative one?
03:48:00 <yitz> sjanssen: yeah, that would be a nice compromise
03:48:07 <opqdonut> sjanssen: well that wouldn't fix a * -b
03:48:12 <Ezla> -1 literal
03:48:22 <blackh> This is the way I see it: The positives of Haskell vastly outweigh the negatives.  I don't even care about oddities with -. The only thing that annoys me about Haskell is namespace clutter with named data structure fields.
03:48:23 <sjanssen> Ezla: why?
03:48:27 <mjrosenb> Ezla: and if i want it to be an operator section?
03:48:29 <Ezla> so I can see your rationale
03:48:38 <sjanssen> Ezla: (+1) is an operator section, why shouldn't (-1) be?
03:48:47 <Ezla> don't use (+1)
03:48:50 <Toxaris> Ezla: consider this simple code: map (-1) [1, 2, 3]
03:48:50 <Ezla> (plus 1)
03:48:50 <opqdonut> :D
03:49:00 <Ezla> don't break *NUMBERS* so you can have functions
03:49:01 <osfameron> haskell minus is a horrid wart
03:49:03 <Ezla> that's nonsense
03:49:08 <blackh> Correct me if I'm wrong (sombody already did) but (-1) isn't a section.
03:49:13 <mjrosenb> :t plus
03:49:14 <lambdabot> Not in scope: `plus'
03:49:20 <yitz> @remember blackh The positives of Haskell vastly outweigh the negatives.  I don't even care about oddities with -.
03:49:20 <lambdabot> I will remember.
03:49:21 <sjanssen> blackh: you're right, it isn't
03:49:30 <Toxaris> blackh: no it's not currently, but that's sometimes bad, sometimes good
03:49:46 <Ferdirand> 3/wi15
03:49:48 <Toxaris> blackh: so we have a fould compromise now, and Ezla wants some other fould compromise
03:49:48 <Ferdirand> oops
03:50:10 <Toxaris> but Haskell is a *functional* language, not a *numeric* language, so functions are more important then numbers, and that's it :)
03:50:23 <loriel> This is what happens when you depart from C-style curly braces syntax
03:50:26 <SKuhn> how can I make unions working? http://haskell.pastebin.com/m6ad095c9
03:50:26 <loriel> confusion and despair
03:50:27 <Ezla> let operator functions be named, and number literals be as they are in every other language
03:50:35 <RayNbow> > let merge = mergeByR compare (const (:)) (:) (:) []; merge3 as bs cs = merge as (merge bs cs); hammings = 1 : merge3 (map (2*) hammings) (map (3*) hammings) (map (5*) hammings)    in   hammings   -- fear the power of recursive definitions :p
03:50:37 <lambdabot>   [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,7...
03:50:38 <Ezla> don't try to rock the boat on numbers
03:50:39 <blackh> Also: - oddities do not contribute to bugs, and neither does namespace clutter.  The deficiencies of other languages contribute to bugs.
03:51:11 <mjrosenb> Ezla: "every other language"?
03:51:17 <quicksilver> I think the current situation could be greatly improved if - had much higher precedence
03:51:23 <quicksilver> (as a prefix)
03:51:26 <mjrosenb> Ezla: i will stab you for that statement
03:51:40 <sjanssen> Ezla: how about you try Haskell for a little bit longer before becoming so despondent.  (-) is really not a big deal in practice
03:51:46 <quicksilver> we have supposedly given up sections on - for negative numbers
03:51:55 <quicksilver> and yet, negative numbers don't even work.
03:52:00 <quicksilver> I think it was the wrong compromise.
03:52:04 <opqdonut> :P
03:52:09 <opqdonut> true that
03:52:34 <mjrosenb> Ezla: i've had to deal with why the C spec is so god-damned vague about what -const is supposed to mean
03:52:34 <quicksilver> as a prefix, - should have higher precedence than all infix ops.
03:52:37 <yitz> blackh: it doesn't cause bugs because of the type checker. But I *still* get minus-related type errors regularly, and that is a minor annoyance.
03:52:39 <quicksilver> just like all other prefix functions do.
03:52:43 <mjrosenb> for the last 3 weeks
03:53:08 <Ezla> mjrosenb: You're alone on that one, buddy
03:53:18 <mjrosenb> Ezla: so if i were to have
03:53:22 <mjrosenb> -nan
03:53:26 <mjrosenb> what is that?
03:53:37 <blackh> That's curry and rice.
03:53:39 <mjrosenb> better yet
03:53:55 <Ezla> There's sufficiently few enough of such cases in order to define each one explicitly in the standard
03:53:58 <Ezla> it's irrelevant
03:54:02 <mjrosenb> double x = -nan;
03:54:46 <RayNbow> > let nan = 0/0 in -nan
03:54:48 <lambdabot>   NaN
03:54:48 <mjrosenb> Ezla: ok, so i'll make sure that if you have -nan in your source, then it'll compile to rm -rf /
03:55:21 <Ezla> you will fail, cause I run MSDOS
03:55:30 <Stephan202> kids...
03:55:30 <Peaker> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however -- but "ghc-6.10.1" is not really a package, why does it depend on it?
03:56:00 <sjanssen> Peaker: probably the GHC API package?
03:56:08 <Saizan> Peaker: wrong build-depends in category-extras
03:56:09 <Ezla> about this horrible, horrible -1 problem. Haskell will NEVER change?
03:56:13 <Saizan> if it's about reactive
03:56:14 <Ezla> it would break all code
03:56:48 <Peaker> Saizan: thanks
03:57:49 <Peaker> Saizan: hmm.. I can't seem to find what's wrong in extras' cabal file, what's the problem in there?
03:58:16 <Saizan> Peaker: that it has ghc in build-depends :)
03:58:33 <Peaker> Ezla: dude, the (-1) problem is a minor, superficial, syntactical issue that is easy to work around
03:58:54 <Ezla> makes me lose interest in Haskell
03:58:55 <Peaker> Ezla: its not a big deal, and in the natural evolution of languages, when we get rid of ascii text as a medium to serialize source code, will disappear :)
03:59:14 <zipMe> Ezla : it's unlikely Haskell will change just because you want it to look like C++
03:59:22 <cpfr> Peaker, ala squeak ?
03:59:31 <blackh> Ezla: Try programming Python for a while. That'll get your interest in Haskell back.
03:59:33 <ivanm> with that whole gmp license issue on -cafe... mathematica apparently uses gmp, so how does it get away with it?
03:59:35 <Peaker> cpfr: squeak still represents source code as ascii text
03:59:38 <Ezla> later, the language looked interesting, but I cannot handle no -1
03:59:42 <Peaker> Ezla: if you lose interest over syntactical silly issues, that's fine...
03:59:51 <repnop> haha serious? or just trolling...
04:00:00 <Peaker> I think he THINKS he's not trolling :-)
04:00:02 <ivanm> Ezla: if you hate a language just because of the syntactic issues regarding negative numbers... then quite frankly I pity you
04:00:04 <Twey> Heh
04:00:11 <blackh> I am only bashing Python because I wrote 13,000 lines of it.
04:00:15 <zipMe> Ezla : well that's a pity, hope you come back some time :)
04:00:30 <Goober> he left
04:00:39 <Peaker> Saizan: oh, cool :-)
04:00:40 <blackh> Lost forever!
04:00:43 <sjanssen> wow
04:00:46 <blackh> Oh nooooooooooooooooooo!
04:00:50 <Peaker> Saizan: that was a source of much confusion!
04:00:51 <repnop> he'll be back :)
04:00:53 <zipMe> you see -1 was a GOOD idea !!!
04:00:56 <repnop> one would hope
04:01:01 <Twey> I think that it should be possible to write (-3) and get a type that can be interpreted as either (Num a) => a -> a or (Num a) -> a
04:01:01 <yitz> Peaker: if Haskell is written with typesetting markup, the indentation rule could be defined based on visible indentation
04:01:04 <repnop> maybe not if that is a big issue for him...
04:01:11 <ivanm> blackh: you lost all 13000 lines of it? :o
04:01:15 <blackh> Let him write 13,000 lines of Python, then he will come CRAWLING back!
04:01:16 <Twey> Can't that be done with some type-class hackery?
04:01:27 <quicksilver> I think we should have a separate operator for unary negation
04:01:36 <quicksilver> but if we're not going to do that, I still think we got the precedence wrong.
04:01:36 <Twey> `negate`?
04:01:50 <Peaker> hey, we could have m1 = negate 1; and then just *m1 :-)
04:01:58 <Twey> Heh
04:02:00 <quicksilver> I'm not aware of any good reason to give prefix - lower precedence than infix *
04:02:00 <jeffz`> @seen dons
04:02:01 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
04:02:03 <quicksilver> > 10 * -1
04:02:05 <lambdabot>       precedence parsing error
04:02:05 <lambdabot>          cannot mix `(*)' [infixl 7] and prefi...
04:02:14 <quicksilver> ^^ there is no excuse for that not working, actually.
04:02:17 <quicksilver> it's just broken.
04:02:29 <Saizan> Peaker: i've sent a patch to edwardk's to remove it, it'll be fixed in the next release
04:02:40 <jeffz`> @seen mauke
04:02:41 <lambdabot> mauke is in #xmonad and #haskell. I last heard mauke speak 4h 36m 38s ago.
04:02:41 <RayNbow> ¬¨1  -- how about this operator for negation? :p
04:02:53 <ivanm> RayNbow: not on the standard keyboard I'm afraid :(
04:03:01 <quicksilver> doesn't ocaml use "~" ?
04:03:04 <wjt> ivanm: it is in en_GB :)
04:03:04 <ski_> RayNbow : `0-' would look better to me ..
04:03:05 <quicksilver> some language does.
04:03:09 <int-e> > 0-10
04:03:10 <lambdabot>   -10
04:03:22 <yitz> quicksilver: perhaps it should even have higher precedence than prefix function application. (or did you already say that?)
04:03:27 <RayNbow> ivanm: true, but I know it's ASCII code for my locale (0172)
04:03:29 <RayNbow> *its
04:03:36 <ivanm> wjt: :o with what key combo?
04:03:37 <Peaker> (0-) is fine too, I guess
04:03:50 <mapreduce> > negate 4
04:03:51 <wjt> ivanm: shift-[key to the left of 1]
04:03:51 <lambdabot>   -4
04:03:51 <quicksilver> yitz: I don't mind that so much. although "- f x" probably only has one sensible interpretation
04:03:52 <ksf> Twey, yeah! n-kindedness.
04:04:02 <yitz> quicksilver: or f - x
04:04:05 <yitz> oh
04:04:07 <int-e> @pl 0*id
04:04:07 <ivanm> wjt: so where's the tilda?
04:04:07 <lambdabot> 0
04:04:08 <yitz> hmm
04:04:09 <ski_> (and `1/' for `recip', obviously)
04:04:13 <quicksilver> yitz: in which case, it should be higher than all infixes but "just" lower than normal prefix.
04:04:19 <wjt> ivanm: on the # key, which is next to Enter
04:04:24 <ksf> speak of varargs and coisomorphism between (.) and (:)
04:04:25 <wjt> ivanm: we have an extra key over en_US
04:04:27 <ksf> isomorphism?
04:04:41 <yitz> quicksilver: like ::
04:04:42 <quicksilver> yitz: but I'd settle for it just being higher than all infix
04:04:42 <ksf> I don't feel like figuring out the direction right now.
04:04:44 <wjt> hmm, actually, i think that key may be the ||¬¶¬¶¬¶|`'
04:04:48 <quicksilver> wjt: that's ~
04:04:53 <wjt> argh! i've lost my backslash
04:04:55 <quicksilver> wjt: which is not what RayNbow typed.
04:05:11 <ski_> ksf : `coisomorphism' ?
04:05:15 <quicksilver> (~ is on the # key, on an en_GB pc keyboard)
04:05:22 <Peaker> what package does hs2ps come from?
04:05:23 <wjt> argh! my dvorak/en_gb switching stuff is busted
04:05:29 <quicksilver> Peaker: it's called hp2ps
04:05:35 <quicksilver> Peaker: (and it's part of GHC as far as I know)
04:05:42 <Peaker> oh, heh
04:05:44 <ksf> hmmm... "Isomorph to its dual"... wait...
04:05:46 <Peaker> quicksilver: ya, found it
04:05:49 <ksf> just ignore the co.
04:05:52 <wjt> quicksilver: i was referring to logical not, which is shift-`
04:05:54 <RayNbow> > let (‚ò¢) = (+) in 3 ‚ò¢ 4
04:05:56 <lambdabot>   7
04:06:07 <quicksilver> wjt: oh. Yes, that's shift ` indeed.
04:06:10 <wjt> except i've apparently broken my keyboard layouts and lost my backslash and arrrgh
04:06:13 <quicksilver> not on en_GB mac keyboards though ;)
04:06:18 <mib_px7y7l> I am getting bitten by this: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-November/015945.html
04:06:19 <lambdabot> Title: ANNOUNCE: GHC version 6.10.1 - EditLine / terminalincompatibility?, http://tinyurl.com/57oo9z
04:06:23 <Goober> if you increased the priority of - would it break all code?
04:06:38 <Peaker> BeelsebobWork_: I finally got it profiled, you there?
04:06:41 <quicksilver> Goober: Hmm. what code could rely on it's lower precedence?
04:06:50 <yitz> Goober: it probably wouldn't break anything
04:06:52 <quicksilver> Goober: I'm not sure.
04:06:52 <ksf> in fact, dons already did that one in stream fusion.
04:06:57 <ski_> (ksf : would you elaborate on "(.) and (:)" ?)
04:07:02 <int-e> quicksilver: every code:  a - b  would be parsed as a (-b)
04:07:13 <yitz> Goober: people always put in parens to get that effect anyway
04:07:40 <ksf> ski_, more -> and (:). allowing Nary types.
04:07:42 <yitz> Goober: if you don't put in the parens, your code doesn't type check
04:07:43 <quicksilver> int-e: I don't understand that.
04:07:48 <cpfr> stream fusion is a bit clunky
04:08:00 <ksf> dang should have written $ not .
04:08:10 <Goober> the - has to bind to a literal in Clangs
04:08:14 <quicksilver> int-e: but then I never really understood the details of the - unary binary resolution.
04:08:16 <ski_> ksf : Nary `->' and `:' operators ?
04:08:17 <Goober> 8 * - 1 is a syntax errr
04:08:18 <Peaker> quicksilver: how did you convert the pdf to a jpg?
04:08:26 <Goober> only -1 is a literal
04:08:27 <Saizan> mib_px7y7l: try this -> http://www.haskell.org/pipermail/glasgow-haskell-users/2008-November/016112.html
04:08:28 <Peaker> quicksilver: I use imagemagick but it makes a real small jpg
04:08:29 <lambdabot> Title: ghci-haskeline (was: Re: ANNOUNCE: GHC version 6.10.1 - EditLine / terminal inco ..., http://tinyurl.com/68n9o5
04:08:30 <quicksilver> Peaker: I took a screenshot.
04:08:33 <int-e> quicksilver: in other words, giving unary minus a higher precedence than binary minus will not work without adding another hack to the grammar / precedence handling
04:08:33 <Peaker> quicksilver: oh
04:08:41 <ksf> sometimes thoughts just want do burst out and scatter all terminology doing so.
04:08:50 <Twey> Heh
04:08:57 <ksf> ski_, a -> b -> c == a:b:c:[]
04:08:57 <quicksilver> int-e: ah, right. Bugger.
04:09:08 <quicksilver> int-e: I still thing we took the wrong copmpromise.
04:09:20 <int-e> quicksilver: the unary - is included as an extra rule in the grammar at precedence level 5.
04:09:21 <blackh> int-e: Thanks for that.
04:09:21 <quicksilver> Peaker: cmd-shift-4 on a mac, or 'import' on linux
04:09:26 <ksf> or, rather a -> b -> c == c:b:a:[]
04:09:40 <SKuhn> why is the constructor not in scope?
04:09:41 <SKuhn> module Set (Set, empty, isEmpty, member, insert, delete) where
04:09:41 <SKuhn>     data Stree a = Null | Fork (Stree a) a (Stree a)
04:09:41 <SKuhn>     empty :: Set a
04:09:41 <SKuhn>     empty = Null
04:09:41 <Peaker> quicksilver: Yeah, I can take a screen shot but that seems... primitive :)  I want to get "convert" to generate a decently sized jpg
04:09:45 <ski_> ksf : ? .. why would you equate a curried function type with a list value ?
04:09:49 <ksf> that's of course unsyntactical in the current sysntem.
04:09:53 <yitz> > -2 ^ 4
04:09:53 <quicksilver> Peaker: I"m sure it has commandline options for that ;)
04:09:54 <lambdabot>   -16
04:10:01 <int-e> quicksilver: I think so, too. unary minus shouldn't be in the language, except perhaps as part of the number literal syntax. (which would make space significant. but I could live with that)
04:10:09 <yitz> quicksilver: hmm do you think anyone writes code that uses that?
04:10:27 <quicksilver> yitz: probably.
04:10:32 <yitz> yuck
04:10:37 <ksf> ski_, because a lambda takes n arguments before it is fully applied, and a list has n arguments before it is empty.
04:10:37 <quicksilver> yitz: I expect there are instances of (-1^n) in the wild
04:11:11 <Twey> Peaker: You can specify a size when converting
04:11:12 <yitz> (-1^n) is probably broken
04:11:22 <Twey> -geometry WxH
04:11:29 <Peaker> Twey: Yeah, -size doesn't work, -geometry works
04:11:29 <int-e> quicksilver: the other effect that I'm unhappy about is that -1 desugars to negate (fromInteger 1) instead of  fromInteger (-1)
04:11:40 <ski_> ksf : i'm sorry to say i don't understand what the function type has to do with the list value ..
04:12:05 <quicksilver> int-e: I'm unhappy that "map (-1) [1..4]" and "5 * -1" both don't work.
04:12:14 <quicksilver> int-e: I think a good compromise would make at least one of those work ;)
04:12:16 <ksf> ski_, a list function takes a list of arguments.
04:12:19 <ski_> (ksf : maybe, if you can't explicate it enough for my feeble mind to understand it, it might be better to drop it ..)
04:12:19 <Peaker> preferred image upload site?  imageshack?
04:12:20 <int-e> > map (-1+) [1..4]
04:12:21 <lambdabot>   [0,1,2,3]
04:12:30 <int-e> (doesn't work in hugs. don't use it *ducks*)
04:12:43 <quicksilver> int-e: I have a slight preference for the left one working, but either would be better than neither.
04:13:10 <RayNbow> > map (-1-) [1..4]
04:13:12 <lambdabot>   [-2,-3,-4,-5]
04:13:14 <ksf> i.e. (sum a b c) = sum:a:b:c:[] = sum:args = (apply sum args)
04:13:41 <ksf> actually i'm not shure that's quite lisp.
04:13:57 <ksf> scheme is (apply (eval sum) (map eval args))
04:14:13 <ski_> why `eval' ?
04:14:29 <int-e> quicksilver: could you live with (- 1)?
04:14:35 <ksf> ...because scheme and lisp are explicit about it.
04:15:06 <ksf> otherwise, apply wouldn't get a function as argument but an s-expr.
04:15:50 <ksf> in other words, its the reason why quote exists: (eval (quote foo)) = foo
04:16:08 <ski_> (if `sum' denotes the summation procedure itself, then no `eval'uation would be needed .. maybe you're thinking of a pure interpreter, in which `sum' would denote an identifier, to be evaluated into the summation procedure by calling an `eval' procedure on it ?)
04:16:15 <Saizan> SKuhn: you haven't defined a Set type there, but a STree
04:16:33 <ksf> ski_, yes, semantically every lisp and scheme is interpreted.
04:16:45 <ski_> what does that mean ?
04:17:17 <ksf> that code is just data.
04:17:32 <quicksilver> int-e: probably
04:18:04 <ski_> if i'm not mistaken (and i'm not) there exists compilers both for Scheme and for Common Lisp
04:18:08 <Peaker> BeelsebobWork_: http://img98.imageshack.us/img98/5985/punesq8.jpg
04:18:11 <ksf> but that's beside the point, you can see the same stuff happening in int main(int argc, string *argv[])
04:18:38 <ksf> ...or "real", that is, syntactic, c varargs.
04:19:05 <Peaker> all languages are interpreted, some just happen to be interpreted by CPU's directly
04:19:07 <ski_> just because an `eval' procedure is (possibly) available at run-time does not mean that the lisp in question is "semantically interpreted"
04:19:21 <ski_> or do you claim that Haskell is "semantically interpreted" ?
04:19:22 <ksf> imagine you could define the type "(a : b : c : [d])
04:19:40 <ivanm> ksf: what would that mean?
04:19:52 <ivanm> a is of type (bi is of type (c is of type [d]))?
04:20:08 <ski_> (not to mention that languages by themselves are neither interpreted or compiled .. an implementation thereof might use compilation vs. interpretation to various degrees)
04:20:11 <ivanm> what kind of type is `c is of type [d]' ?
04:20:26 <Stephan202> [d]
04:20:27 <Stephan202> ?
04:20:31 <ksf> meaning the same as ds -> c -> b -> a -> (dammit I left out the result in (( a : b : c : [d] ) -> e)) )
04:21:02 <ivanm> duh, I was thinking of :: instead of :
04:21:13 <ivanm> ksf: so : == flip (->) ?
04:21:16 <ksf> (the s of ds meaning no more than "it's a list)
04:21:21 <ksf> :t (->)
04:21:22 <lambdabot> parse error on input `->'
04:21:40 <ivanm> ksf: well, -> isn't a function ;-)
04:21:46 <yitz> languages in which you can build source code as data at run time and execute it are essentially interpreted
04:21:53 <ski_> @kind (->)
04:21:54 <lambdabot> ?? -> ? -> *
04:22:01 <ivanm> not flip, either.... my haskell-fu is weak tonight :(
04:22:08 <ksf> i'm not sure what'd be the best direction.
04:22:09 <yitz> except machine code :)
04:22:11 <Peaker> can I generate nice images from a .prof profile output?
04:22:27 <ksf> yitz, there's 3-lisp.
04:22:30 <ivanm> Peaker: there's a prof2dot tool or something that does so
04:22:43 <yitz> ksf: 3-list?
04:22:46 <yitz> ksf: 3-lisp?
04:22:54 <Peaker> ivanm: thanks
04:23:04 <ksf> ...in which you don't have nested evals, but one infinite tower of them.
04:23:07 <Peaker> the table formatting in the .prof file is all broken :-(
04:23:08 <ivanm> Peaker: no worries ;-)
04:23:14 <ivanm> Peaker: :(
04:23:21 <ivanm> a tab issue?
04:23:40 <Peaker> ivanm: seems like its formatted with only spaces
04:23:42 <ivanm> Peaker: are you using a monospace font?
04:23:47 <Peaker> ivanm: ya
04:23:51 <ivanm> wierd :s
04:24:03 <ivanm> care to hpaste a portion so we can see this butchered prof output?
04:24:05 <Peaker> ivanm: I profiled with -p -P the bottom tree looks great. The top table looks awful
04:24:10 <ivanm> weird even
04:24:13 <ivanm> hmmm...
04:24:19 <ivanm> what does -P do?
04:24:43 <Peaker> http://hpaste.org/12684
04:24:49 <Peaker> ivanm: "more time profile output"
04:24:58 <Peaker> "-P       More detailed Time/Allocation profile"
04:25:31 <ksf> anyway, with that scheme, you can, as yitz pointed out, solve the unary minus problem by having different specialisations for (-) :: a -> a and (-) :: a -> a -> a, both of which can be defined simultaneously.
04:25:40 <ksf> _inside_ the type system, that is, not as a hack.
04:25:42 <Peaker> the qualified names are just too long
04:25:45 <ivanm> Peaker: I'm guessing that the module name is longer than expected
04:26:04 <Peaker> ivanm: surely hierarchial modules will always result in that
04:26:19 <Peaker> I think it should be ordered from shortest column to longest, so the numbers should be on the left
04:26:31 <ivanm> Peaker: well, most hierarchical modules are only of single depth...
04:27:04 <Peaker> ivanm: these are too: "Graphics.FieldTrip", "FRP.Reactive" (the third name is the name inside the module, not a module)
04:27:30 <ivanm> oh? so what's Transform3 then?
04:27:48 <ivanm> I thought Graphics.FieldTrip.Transform3 was the actual module...
04:29:22 <Peaker> ivanm: Transform3 is a type
04:30:06 <ivanm> maybe I just can't remember what profiling output looks like :s
04:31:23 <Saizan> ksf: err, except that typechecking happens after parsing
04:32:13 <zever> hi guys, I get the following compile error:  Couldn't match expected type `Type' against inferred type `a b' from the use of a runState, what is type `a b' ??
04:32:35 <ivanm> zever: depends on what your code is ;-)
04:32:49 <ivanm> it's lowercase, so it's something polymorphic
04:33:07 <zever> ok, I will paste code :)
04:34:09 <zever> http://hpaste.org/12685 : the use of runState is in the function start
04:34:45 <zever> it's the first time I use state monad, so it could be something stupid
04:35:02 <ivanm> can you annotate that paste with the entire error message?
04:35:06 <Peaker> ivanm: prof2dot generates a HUUUGE image
04:35:07 <ivanm> esp line number! ;-)
04:35:17 <quicksilver> zever: well that's a do block.
04:35:18 <ivanm> Peaker: heh, you must have a HUUUUGE profile output ;-)
04:35:25 <quicksilver> zever: and yet its type is 'Type'
04:35:32 <quicksilver> zever: I don't think that's what you wanted.
04:35:37 <Peaker> ivanm: can I filter low cost centers?
04:35:44 <ivanm> Peaker: I've never used it myself
04:35:46 <zever> ivanm: done
04:36:11 <quicksilver> zever: I think you wanted start te e = fst (runState (infer e) (TS te [] 0))
04:36:17 <ivanm> zever: what quicksilver said ;-)
04:36:29 <quicksilver> zever: although fst (runState ....) is actually just eval/execstate, I can't remember which.
04:36:38 <zever> evalState yes
04:36:53 <ivanm> @src eval/execstate
04:36:54 <lambdabot> Source not found.
04:36:54 <ivanm> ;-)
04:37:11 <zever> wow, thanks guys 4 minute answer :O !!
04:38:56 <zever> still a question, does that code automatically "puts" the TS te [] 0, so it can get it later?
04:39:28 <quicksilver> zever: well, not really.
04:39:31 <quicksilver> zever: it's just a local thing.
04:39:47 <quicksilver> zever: State isn't magic, it's just another way of constructing and using functions (s -> (a,s))
04:39:55 <quicksilver> if you through that 's' away at the end : well, you've thrown it away.
04:40:02 <quicksilver> it's not stored globally or anything.
04:41:25 <loriel> Well, perhaps it should be
04:41:25 <loriel> :|
05:09:14 <goober> So, I read the "learn you a haskell" and I don't really see how that helps you... WRITE A PROGRAM
05:09:38 <goober> it's all math and lists, really
05:09:42 <ziman> have you seen Real World Haskell?
05:09:46 <goober> and functions for working on them
05:09:52 <ziman> @where RWH
05:09:52 <lambdabot> is http://www.realworldhaskell.org/blog/
05:09:57 <Lemmih> goober: Programs are all math and lists (:
05:10:19 <goober> I want to know how to write haskell programs, not do list tricks
05:11:15 * oklopol just wants to do list tricks
05:11:22 <EvilTerran> goober, lists are frequently used in haskell where you'd use a loop in an imperative language
05:11:41 <yitz> goober: yeah, so then you really want RWH, like ziman said
05:11:51 <EvilTerran> goober, because what'd often be expressed as a loop can be expressed in terms of some basic list functions
05:11:52 <SamB_XP> you can just read it online ;-P
05:12:13 <goober> but this doesnt cover linkage, program design, modules, ways of translating "object oriented" thinking into haskell, etc
05:12:23 <SamB_XP> but if you do, you might feel drawn to spend hours commenting on it
05:12:30 <EvilTerran> you don't translate OO thinking into haskell
05:12:39 <goober> SamB_XP: read what online
05:12:43 <SamB_XP> RWH
05:12:45 <EvilTerran> that'd be like trying to translate haskell thinking into Java
05:12:52 <goober> SamB_XP: doesnt appear to be free
05:13:02 <quicksilver> goober: sure, LYAH is just a beginner tutorial.
05:13:07 <SamB_XP> @where RWH
05:13:07 <lambdabot> http://www.realworldhaskell.org/blog/
05:13:10 <goober> http://www.realworldhaskell.org/blog/  "BUY ONLINE" it says
05:13:11 <quicksilver> other things are more suited to practical advice.
05:13:12 <lambdabot> Title: Real World Haskell
05:13:15 <EvilTerran> http://book.realworldhaskell.org/read/
05:13:19 <quicksilver> it is indeed for sale
05:13:20 <lambdabot> Title: Real World Haskell
05:13:21 <quicksilver> but it is also free
05:13:26 <quicksilver> welcome to paradox city!
05:13:31 <goober> ah I see cool
05:13:48 <yitz> goober: if you like it, buy it also on dead trees.
05:13:53 <quicksilver> if you like what you read, buy a copy later, and dons will get to eat tomorrow.
05:13:55 <quicksilver> ;)
05:14:02 <SamB_XP> o'reilly likes to sell free books, you know ;-P
05:14:24 <quicksilver> EvilTerran: I think it's very sensible to discuss how to translate OO thinking into haskell.
05:14:43 <quicksilver> EvilTerran: some of the concepts map poorly, but it remains a productive thing to discuss.
05:14:51 <quicksilver> to help teach other ways to approach the problems.
05:15:18 <goober> so "real world haskell" is the only book about writing a real haskell program
05:15:22 <Saizan> it's not very productive to start designing your application as OO and translating that to haskell though
05:15:40 <SamB_XP> no ;-P
05:16:09 <quicksilver> goober: it's the only published dead-tree book that focusses on application programming, I think.
05:16:12 <EvilTerran> quicksilver, eh. i find those discussions tend to end up with both the HMers and the OOers vehemently defending their type systems :P
05:16:43 <SamB_XP> EvilTerran: I thought the OOers were always complaining about theirs!
05:16:57 <goober> aren't you guys a bit overly enthusiastic about the whole "functional" thing... I mean seriously, if I am making a Gorilla, he's a Noun. And he has bananas, meanness, and a color
05:17:04 <goober> the ideas of IS-A and HAS-A are human
05:17:15 <loriel> SamB_XP: Coming from C++, I am valiantly defending all my type sysem craziness
05:17:19 <quicksilver> EvilTerran: that depends on who you're talking to and how teh conversation proceeds, sure.
05:17:21 <goober> so arguing against "OO" is just a bunch of iconoclasm
05:17:23 <SamB_XP> OO doesn't really translate those ideas too well
05:17:24 <EvilTerran> "fragile base class problem!" "aah! ... exponential worst case typechecking!" "ack!" ...
05:17:59 <vegai> data Gorilla = ...
05:18:01 <quicksilver> EvilTerran: but if you have a skilled OO programmer who wishes to become a skileld haskell programmer, it's very logical to address how to solve problems
05:18:05 <vegai> class Noun a where ...
05:18:06 <loriel> goober: You are not making gorillas, you are making programs :|
05:18:24 <vegai> instance Noun Gorilla where ...
05:18:25 <quicksilver> EvilTerran: of course, sometimes the solutions are analagous in an obvious way,a nd sometimes a quite different one suggests itself.
05:18:33 <goober> vegai: THATS OO!
05:18:37 <goober> duh
05:18:42 <EvilTerran> quicksilver, yeah, that's true; it helps if no-one's feeling argumentative
05:18:45 <vegai> goober: so?
05:18:50 <Toxaris> How is a Gorilla a noun? I would say a Gorilla is an animal
05:19:08 <loriel> goober: It is not OO just because it says "class" and "instance"
05:19:09 <goober> well i keep hearing you guys rant that its not
05:19:21 <quicksilver> goober: although haskell uses the words 'class' and 'instance' it's really not like C++ classes and instances.
05:19:21 <Peaker> goober: Haskell has "has-a" and "is-a" relationships, that's not the defining property of OO
05:19:24 <goober> loriel: that's overly reactive and serves no truth
05:19:29 * EvilTerran calls troll on goober
05:19:30 <vegai> goober: I might rant that OO doesn't mean anything, though
05:19:30 <goober> just because it doesn't say "class"
05:19:33 <quicksilver> goober: it's probably a poor choice of words, from that respect.
05:19:35 <Saizan> goober: i suggest that you stay away from OO vs. functional arguments and see yourself what functional programming can and can't do for you
05:19:43 <loriel> goober: I am saying it does say "class" and is not OO anyway.
05:19:49 <Peaker> goober: Haskell has all the good things from OO, without the bad ones
05:20:12 <quicksilver> in fact, haskell 'class'es are a way to do adhoc overloading
05:20:25 <quicksilver> which is a little bit like C++ polymorphism, but actually not that like it, when you look closely.
05:20:33 <Peaker> goober: Haskell has OO's interfaces (Good), but not OO's subclassing (Bad)
05:20:39 <quicksilver> "almost but not entirely unlike", I would categorise it.
05:21:24 <jay> hello
05:21:33 <goober> Well, I think a masterful haskell programmer who knows various languages would look beyond the immature reaction of "ITS NOT OO! IT DOESNT SAY 'CLASS'" but rather instead see it in a more pure light of is-a, has-a, Typeclasses, etc, and explain it very rationally in terms of the relation between human thought of items and their adjectives
05:21:36 <ksf> ski_, did I send you to term&proof-land?
05:21:41 <goober> whereas a newbie would say, "Haskell isnt OO"
05:21:41 <Peaker> goober: one of the purposes of Subclassing is having different kinds of data in the same type -- that's what algabraic types do - better.  Another purpose of subclassing is specifying an interface is implemented, and that's done better by a specific primitive to do that.  sub-classing also mixes up the namespaces of various modules, which is a bad thing
05:22:01 <mib_dcmpfh> Saizan: I get ^J in Haskell mode. Does it also help against that?
05:22:07 <ksf> "is-a" is inherently flawed.
05:22:08 <Peaker> goober: Again, Haskell has these relationships, but it does not have the defining properties of OO, one of which is inheritance
05:22:10 <Saizan> mib_dcmpfh: yes
05:22:13 <ski_> ksf : meep ?
05:22:18 <mib_dcmpfh> Saizan: ok, I will try it.
05:22:26 <ksf> "implements-a" is what you're looking for, approximately.
05:22:30 <SamB_XP> ksf: a good strong statement ;-P
05:22:43 <SamB_XP> Peaker: inheritance ?
05:22:45 <Peaker> goober: it has encapsulation, data hiding, and is-a/has-a relationships though, and those are good things
05:22:48 <SamB_XP> since when is that defining ?
05:22:52 <ksf> all generalisations are false.
05:23:08 <Peaker> SamB_XP: OO is generally defined as: 1. Encapsulation, 2. Inheritance (as a vehicle for 3) 3. Polymorphism
05:23:09 <EvilTerran> ksf, lunch generalisations doubly so?
05:23:09 <ksf> ^^my favourite paradox
05:23:17 <Peaker> SamB_XP: at least, that's what used to go around in the 90's
05:23:29 <Toxaris> Peaker: I disagree. I think: OO is generally undefined.
05:23:42 <ski_> afternoon Guest15001
05:23:45 <ksf> there is no true nor false, both are illusions.
05:23:56 <Toxaris> Peaker: some authors may define it so, but there is no general consensus
05:23:59 <mib_dcmpfh> Saizan: thanks, but that gives me: darcs failed:  Failed to download URL http://code.haskell.org/~judah/ghci-haskeline/_darcs/inventory : HTTP error (404?)
05:24:00 <Peaker> Toxaris: well, when people say OO they either mean the above 3 (that's what appeared as a definition in many books in the 90's), or "message-passing polymorphism"
05:24:08 <goober> Toxaris you're arguing pedantic details there
05:24:11 <goober> OO is defined
05:24:12 <mib_dcmpfh> Saizan: but that's probably some proxy problem?
05:24:21 <SamB_XP> goober: heh
05:24:28 <EvilTerran> goober, and you aren't?
05:24:46 <goober> OO is defined as the set of commonality amongst 90% of supposedly-OO languages
05:24:47 <Saizan> mib_dcmpfh: i'm not sure, it works for me
05:24:48 <Peaker> goober: why do you care about the definition of a word? Why not ask questions about actual things?
05:24:50 <ksf> you cannot have a two-valued logic without introducing a third concept, which is that of the distinction of those two. you cannot have a three valued logic without intro....
05:25:05 <goober> Peaker: I was replying to toxaris...
05:25:22 <Saizan> mib_dcmpfh: i mean, darcs get works
05:25:30 <ksf> the key's to find a common distinction that stops the recursion.
05:25:31 <Peaker> goober: Another one of the defining features of OO is that it is imperative. While Haskell has imperative DSL's, it encourages purely-functional programming
05:25:37 <Toxaris> goober: I find it hard to discuss about something without first defining it -- probably because I'm pedantic. But nevertheless, it sometimes help
05:26:02 <goober> Toxaris: alright, take it to mean "the commonality"
05:26:04 <Saizan> mib_dcmpfh: maybe you need a newer version of darcs?
05:26:09 <Philonous> Peaker: Doesn't ocaml do a good job in being both functional and oo?
05:26:12 <Saizan> mib_dcmpfh: i've 2.1.0 here
05:26:13 <mib_dcmpfh> Peaker: there is a Scheme object system that is functional.
05:26:17 <quicksilver> I don't think OO is generally defined (in a useful way)
05:26:17 <Peaker> Philonous: I don't know OCaml very well
05:26:34 <quicksilver> I tend to interpret OO as "like C++" unless the speaker obviously has something more specific in mind.
05:26:38 <Peaker> mib_dcmpfh: objects are not stateful?
05:26:46 <ksf> goober, a singleton set isn't topologically interesting, make that a value.
05:26:50 <Philonous> Peaker: Well, you can do purely functional yet object oriented programming it it
05:26:52 <ski_> http://community.schemewiki.org/?object-oriented-programming
05:26:53 <Peaker> quicksilver: "I invented the term OO and C++ was not what I intended" ? :-)
05:26:54 <mib_dcmpfh> Saizan: 1.0.9 (release) here
05:26:59 <lambdabot> Title: object-oriented-programming
05:27:05 <Peaker> Philonous: OCaml is pure in any meaningful way?
05:27:19 <mib_dcmpfh> Saizan: it must be the network admin that's annoying me, since it did work a few days ago.
05:27:32 <quicksilver> Peaker: when terms have been (ab)used in such a wide way for so long, it matters little what the inventor wanted it to mean.
05:27:38 <goober> to define OO, just look at C++, Java, C#, Javascript, Python
05:27:39 <Saizan> mib_dcmpfh: you can try downloading this: http://code.haskell.org/~Saizan/ghci-haskeline-0.1.tar.gz
05:27:40 <goober> they all do the same
05:27:49 <ski_> goober : how about CLOS ?
05:27:50 <quicksilver> goober: now that is certainly not true.
05:27:53 <Saizan> mib_dcmpfh: i've made that tarball from the same repo
05:27:57 <Peaker> goober: They do things so very differently
05:28:03 <quicksilver> goober: javascript and C++ have extremely different OO systems
05:28:10 <goober> No, I've spent at least a year in each of those languages
05:28:11 <quicksilver> it's one of the interesting things about javascript.
05:28:18 <goober> they're the same
05:28:21 <quicksilver> (I prefer the javascript system to the C++ one myself)
05:28:22 <ksf> there's also a haskell object system that's purely functional, it's called records. we just left the dirty stuff out of OO, which is utterly broken inheritance semantics.
05:28:30 <Peaker> goober: Java/C# are roughly the same. Javascript is not even generally accepted to be "OO".
05:28:32 <goober> quicksilver: the prototypical inheritance system isnt all that different
05:28:41 <Peaker> goober: Anyhow, Haskell is better than all of these languages :-P
05:28:47 <quicksilver> I would characterise it as very different.
05:28:54 <quicksilver> you can change methods at runtime
05:28:56 <Philonous> Peaker: It doesn't force you to write pure programmes, but you can, if you want. There is even a distinction of stateful objects and functional objects in ocaml.
05:29:00 <quicksilver> create hybrids and so on
05:29:04 <goober> Javascript's prototypical inheritance is identical to the rest, except that a function is a class which constructs the type
05:29:05 * vegai sees SPJ use genetive "its" as "it's"
05:29:13 <ksf> goober, did you mean to say "they appear to have the same capabilities and semantics to me"?
05:29:13 <Peaker> Philonous: so data is tainted as stateful, but not functions?
05:29:22 <goober> and duck typing
05:29:23 <mib_dcmpfh> Saizan: according to wget it's forbidden to get it. You have done enough already. Thanks a lot.
05:29:24 <goober> that's only because JS can afford to do so
05:29:37 <quicksilver> goober: it's not identical because JS objects contain their methods at runtime
05:29:41 <quicksilver> and can look them up at runtime
05:29:44 <Peaker> goober: Duck Typing sucks, why not take the "duck type" and put it in an interface?
05:29:45 <quicksilver> and you can change them.
05:29:50 <ksf> vegai, no wonder, he''s a hacker.
05:29:58 <quicksilver> C++'s methods are fixed statically by the concrete class.
05:30:08 <goober> quicksilver: D can do that.
05:30:10 <telexicon> Peaker, because then you can do type checking!
05:30:12 <goober> and Java has reflection.
05:30:19 <quicksilver> You may be right about D.
05:30:22 <paolino> l/
05:30:31 <quicksilver> But nonetheless this is a large difference between C++ and javascript.
05:30:33 <telexicon> Peaker, its much trendier to do that at runtime
05:30:40 <Peaker> goober, telexicon: in a language like Java, ducktype->interface wouldn't work because you have to specify that the interface is implemented by each type that does, you can't do it for 3rd-party interfaces
05:30:42 <ksf> java hasn't much of reflection, rather introspection.
05:30:52 <ksf> think smalltalk.
05:30:55 <Peaker> s/java/java,python,etc
05:31:06 <Peaker> I guess Java is a bad example because it doesn't have duck typing :)
05:31:08 <ksf> which is what you should be talking about when talking OO.
05:31:20 <Saizan> mib_dcmpfh: i had forgotten to chmod a+r it, you can try again if you want
05:31:32 <Peaker> goober: anyhow, what did you come to find out?
05:31:42 <mib_dcmpfh> Saizan: now it worked
05:31:53 <Philonous> Peaker: As I understand it it's just two different ways to handle the same thing. I still think Ocaml shows you can do OO functionally, even when it isn't purely functional
05:32:13 <goober> the way Javascript diverges most from the others is that OO is a set of legos.. you build your own scheme. there's various systems people use. Doug Crockford promotes one system which Mozilla does not
05:32:21 <goober> and others yet, rewrote the syntax entirely
05:32:28 <goober> to make it resemble C++/java
05:32:32 <Peaker> Philonous: Haskell has both (all data is immutable, IORefs are mutable, and functions are also in/out of IO)
05:32:59 <Peaker> goober: Most of us don't think OO is that great an idea here, I think
05:33:14 <Peaker> goober: I used to think it was great, until I learned about Haskell solves the same problems
05:33:15 <vixey> Phlonous: I thought it was well known that mutable closures and objects were equivalent
05:33:33 <SamB_XP> I think OO might be okay for GUIs ... but not much else
05:33:33 <ksf> instance Object Foo where recv :: Mesg a -> b
05:33:43 <quicksilver> vixey: that's a fairly boring sense of equivalent, though, isn't it?
05:33:49 <Peaker> SamB_XP: GUI's are better expressed by FRP, IMO
05:33:56 <ksf> but then, why would one want to limit oneself to that kind of inheritance?
05:34:13 <quicksilver> vixey: only slightly better than saying "all this stuff is numbers in a computer, so they're all equivalent"
05:34:26 <SamB_XP> Peaker: could be, but isn't that still in infancy ?
05:34:26 <Peaker> ksf: are you calling instances a "kind of inheritance"? :-)
05:34:48 <ksf> nope, the coupling of certain Foos to certain Mesgs
05:34:59 <ksf> that's basically the scheme scheme.
05:35:11 <Peaker> SamB_XP: Yeah.  Even so, I'm not sure OO adds much value to a simple imperative Haskell program for a GUI
05:35:11 <ksf> ...which does'nt spell out the foo and dynamically types mesg.
05:35:12 <vixey> quicksilver, I think it's a bit more fundamental than that, but it isn't some amazing insight
05:35:15 <Peaker> SamB_XP: (if at all)
05:35:33 <quicksilver> vixey: yes, it's not quite the same. But it's not very insightful.
05:35:41 <goober> why is GUI's in Haskell in infancy?
05:35:42 <SamB_XP> Peaker: well, the gui toolkits already have OO interfaces ;-P
05:35:48 <Peaker> goober: FRP is in its infancy, not GUI's
05:35:54 <goober> FRP ?
05:35:58 <ksf> it constructs a Foo by simply constructing an off-the-shelf closure.
05:36:00 <Peaker> goober: yes, Functional Reactive PRogramming
05:36:13 <goober> what is that...
05:36:28 <Peaker> SamB_XP: I'd say the interfaces are not OO, they're just named funny :-)  (by their first arg type)
05:36:28 <ksf> in a nutshell, dataflow programming.
05:36:29 <mib_dcmpfh> Saizan: I didn't even have lideditline installed.
05:36:36 <Peaker> SamB_XP: You don't have to "inherit" to use them
05:37:10 <Peaker> goober: its a rather-new paradigm that allows declaratively expressing reactive systems, rather than imperatively
05:37:13 <SamB_XP> well, sure, but the inheritance ...
05:37:17 <goober> a few years back, I checked out this haskell program and I cannot remember what it's called.
05:37:27 <goober> It had a canvas, which scrolled in all directions
05:37:38 <goober> and you could write kinds of equations and set stuff
05:37:43 <goober> and they'd just render there
05:37:45 <goober> it was dynamic
05:37:57 <goober> you could build stuff on the canvas
05:38:14 <ksf> goober, http://www.youtube.com/watch?v=faJ8N0giqzw
05:38:15 <lambdabot> Title: YouTube - Tangible Functional Programming
05:38:31 <goober> what app was thtat?
05:40:07 <oklopol> ksf: i don't think i'll watch that, the comments of experts told it sucks
05:40:20 <ksf> wut?
05:40:29 <vixey> quicksilver: Well I can't find it but there was some commentary about it by Sussman
05:40:29 <ksf> experts on ignorance of fp?
05:40:42 <Peaker> oklopol: what experts?
05:40:47 <oklopol> you know these people who rate youtube videos!
05:40:48 <yitz> heh, the scheme OO page referenced by ski_ has a link to oleg
05:40:56 <oklopol> no not rate
05:40:59 <oklopol> i mean the commentors
05:41:07 <vegai> goober: not fenfire, I suppose?
05:41:31 <ksf> yitz, oleg is the root of all arguments by authority.
05:41:47 <goober> vegai: no, that looks like dataflow
05:42:01 <goober> All the guys on #Haskell told me about it a few yrs back
05:42:08 <goober> everyone seemed to know it
05:42:09 <Saizan> mib_dcmpfh: ah, i still get ^J in haskell-mode even with editline with the standard ghci
05:42:23 <dreixel> can anyone confirm that http://hpaste.org/12686?lines=true is a bug?
05:42:25 <goober> they gave it to me as a interesting example of a haskell app
05:42:35 <dreixel> (Type checker loops with type families, overlapping and undecidable instances)
05:43:07 <vixey> goober, you put UndecidableInstances on and think it's a bug that the typechecker loops? :)
05:43:38 <vixey> oops
05:43:47 <vixey> s/goober/drexiel/ sorry
05:43:53 <mib_dcmpfh> Saizan: it doesn't work. I get unknown symbol <name of module><name of identifier><closure>
05:44:06 <yitz> vixey: it's supposed to give up after a while
05:44:10 <dreixel> well, should it loop?
05:44:14 <goober> when you wrote stuff on the canvas, it would render forever
05:44:17 <Saizan> mib_dcmpfh: are you compiling it with cabal?
05:44:19 <goober> you could scroll thousands of pixels
05:44:27 <goober> like results would just keep going
05:44:32 <mib_dcmpfh> Saizan: the compilation worked.
05:44:32 <goober> indefinitely
05:44:44 <mib_dcmpfh> Saizan: but this is what happens when I load my program in it.
05:44:51 <Toxaris> yitz: Oleg does a lot of interesting Scheme stuff
05:44:59 <mib_dcmpfh> Saizan: or to be more precise when I evaluate a simple function.
05:45:14 <yitz> dreixel: does it just hang, or complain that it went into a loop?
05:45:14 <mib_dcmpfh> Saizan: a function defined in a source file, to be precise.
05:45:31 <dreixel> no, it goes on consuming all my memory.
05:45:36 * ksf wants a ghc flag -Ostalin
05:45:45 <dreixel> yitz: no, it goes on consuming all my memory.
05:45:47 <vixey> quicksilver, aha! http://www.kimbly.com/blog/000063.html
05:45:56 <lambdabot> Title: Closures, Objects, and Poor Men
05:46:03 <Saizan> mib_dcmpfh: it works for me
05:46:26 <yitz> dreixel: sounds like a bug to me. ask on #ghc or ghc-users.
05:46:27 <Saizan> mib_dcmpfh: how are you invoking it?
05:46:32 <dreixel> in http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances it says that "Termination is ensured by having a fixed-depth recursion stack"
05:46:42 <lambdabot> Title: 8.6.ÔøΩClass and instances declarations, http://tinyurl.com/245leb
05:46:42 <ski_> goober : maybe you meant Vital <http://www.cs.kent.ac.uk/projects/vital/overview/index.html> (or maybe Haxcel <http://www.mrtc.mdh.se/projects/Haxcel/>) ?
05:46:51 <mib_dcmpfh> Saizan: I use something with a foreign export declaration. Maybe that's the problem?
05:46:59 <vixey> not sure why I thought it was by Sussman
05:47:03 <mib_dcmpfh> Saizan: a new file works.
05:47:06 <dreixel> yitz: thanks
05:47:31 <Saizan> mib_dcmpfh: i'd expect a foreign import to cause that problem
05:47:40 <mib_dcmpfh> Saizan: (without the export declaration)
05:47:50 <mib_dcmpfh> Saizan: yes, me too, but it really is here :)
05:47:53 <Saizan> mib_dcmpfh: which i'd solve by passing the object file where the symbol is defined on the command line
05:47:55 <goober> That's it
05:47:58 <goober> it was Vital
05:48:10 <goober> thx
05:48:44 <Saizan> mib_dcmpfh: i've never use export declarations myself, so i'm not of big help here
05:48:47 <goober> why... is it done in Java!
05:48:47 <mib_dcmpfh> Saizan: final link ... ghc: linking extra libraries/objects failed
05:48:51 <goober> i thought this was haskell
05:48:53 * ksf blinks and wonders why he interprets a line-drawing of a rhombic dodecahedron as a tesseract.
05:49:36 <mib_dcmpfh> Saizan: the default ghci shows the same problem.
05:49:46 <mib_dcmpfh> Saizan: it wasn't there before.
05:49:54 <mib_dcmpfh> Saizan: I will investigate myself.
05:50:27 <ksf> vital looks cool, basically a mathematica-style ui for haskell.
05:51:16 <ksf> not hackageised, though.
05:54:19 <nn64> Could not find module `Control.Arrow.Transformer.All' ::: does anyone know in what package is located??
05:54:33 <byorgey> nn64: that's in the 'arrows' package
05:56:23 <nn64> byorgey, thanks
05:56:31 <nn64> botsnack
05:56:37 <nn64> ...
05:56:57 <byorgey> @botsnack
05:56:58 <lunabot>  :)
05:56:58 <lambdabot> :)
05:57:18 <kristofer> yo
06:00:30 <goober> does Haskell do introspection?
06:00:33 <goober> or even reflection
06:00:39 <goober> at compile time
06:01:03 <gbacon> so when defining a Functor instance for Either e, why do you have to write fmap f (Left l)  = Left l and not fmap f l = l?
06:02:02 <Saizan> gbacon: because the first (Left e) has type (Either e a) while the second has type (Either e b)
06:02:47 <gbacon> Saizan: ah, thanks
06:03:34 <nn64> Any one know how to do somthing complicated useing lambdabot?
06:03:48 <goober> >
06:03:52 <Saizan> what do you mean with complicated?
06:04:15 <Saizan> > fix ((1:) . scanl (+) 1)
06:04:16 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:04:44 <nn64> I'm really having a hard time relating Haskell to C#
06:05:08 <nn64> I read the manual but I'm still lost on how it works
06:05:25 <Saizan> which manual?
06:05:46 <goober> the one with Microsoft Haskell Express
06:06:14 <kristofer> I'm trying to write myself a scheme in 48 hours.. I need to rewrite parseNumber in do notation. parseNumber = liftM (Number . read) $ many1 digit
06:06:31 <nn64> the wiki books one
06:06:38 <nn64> yaht i think it was
06:06:45 <Saizan> ah
06:06:57 <goober> nn64,
06:07:05 <goober> I was told about the 2 following books
06:07:07 <goober> do in this order:
06:07:21 <Saizan> kristofer: do you know what liftM does?
06:07:22 <Toxaris> kristofer: (liftM f a)  is equivalent to  do x <- a; return (f x)
06:07:25 <nn64> Where exactly is the start point in a haskell program?
06:07:40 <goober> http://learnyouahaskell.com/  ->  http://book.realworldhaskell.org/read/
06:07:47 <lambdabot> Title: Learn You a Haskell for Great Good!
06:07:48 <Saizan> nn64: it's the function main defined in the Main module
06:07:55 <Toxaris> nn64: the main function in the Main module is evaluated and should yield an IO action, which is executed
06:08:13 <Toxaris> nn64: so hello world is:  main = putStr("hello world")
06:08:20 <goober> how does a Haskell program "continue"
06:08:34 <goober> rather than evaluating and returning a result immediately
06:08:43 <loriel> goober: Like all other programs :|
06:09:00 <Toxaris> goober: just return an IO action from main which needs a long, or even infinite amount of time to execute
06:09:07 <Twey> Uhm
06:09:13 <Twey> Those brackets are misleading, Toxaris
06:09:14 <Saizan> you recurse till you're satisfied :)
06:09:23 <Twey> main = putStrLn "hello world"
06:09:26 <goober> what's an "IO Action" ?
06:09:31 <Toxaris> Twey: oups, too much java
06:09:37 <Twey> Heh
06:09:46 <nn64> > acc = 6788 +9999
06:09:48 <lambdabot>   <no location info>: parse error on input `='
06:09:52 <loriel> goober: How do you "continue" in C, rather than returning immediately?
06:09:58 <nn64> > acc = 6788+9999
06:10:00 <lambdabot>   <no location info>: parse error on input `='
06:10:02 <nn64> ?
06:10:15 <goober> loriel: with an event loop
06:10:22 <goober> but Haskell doesnt have loops
06:10:23 <yitz> does it still make sense to post comments on RWH now that it's in print?
06:10:23 <Twey> goober: An IO action is a value that represents an impure (IO-using) action.
06:10:31 <Twey> goober: Haskell has recursion
06:10:49 <Twey> And higher-order functions and infinite lists :)
06:10:54 <goober> how does that not catch your computer on fire?
06:11:02 <goober> you cant recurse forever
06:11:05 <loriel> Okay you just have to be trolling at this point
06:11:08 <Saizan> sure you can
06:11:12 <Toxaris> goober: in Haskell you can
06:11:19 <goober> so you're saying it has tail calls
06:11:20 <Twey> goober: The GC is clever.  :)
06:11:22 <yitz> goober: there are very high-level constructs that allow you to avoid event loops
06:11:25 <Twey> Tail call optimisation helps, too.
06:11:26 <quicksilver> you certainly can recurse forever. Servers are often like taht.
06:11:34 <goober> When you are recursing forever thats not even recursion heh
06:11:38 <quicksilver> main = do processRequests ; main
06:11:38 <goober> its more of a loop
06:11:47 <Twey> Think of it how you like :)
06:11:47 <quicksilver> it is indeed a loop. It is also recursion.
06:11:55 <quicksilver> recursion is how haskell implements loops.
06:11:56 <ksf> @remember bucky A pattern has an integrity independent of the medium by virtue of which you have received the information that it exists
06:11:57 <lambdabot> I will remember.
06:12:04 <goober> this channel is really closed minded in certain ways
06:12:15 <goober> everybody gets called a Troll at the slightest thing they say
06:12:17 <Saizan> or loops is like GHC implements some recursions :)
06:12:28 <quicksilver> goober: no, actually, only you get called a troll.
06:12:34 <nn64> Could not find module `Control.Monad.Logic'
06:12:35 <quicksilver> perhaps there's a reason for this pattern?
06:12:36 <yitz> goober: think of it as a badge of honor :)
06:12:43 <kristofer> Toxaris, what does the $ do?
06:12:50 <goober> the "troll" thing is only used by people who aren't smart
06:12:54 <vixey> I think it's really important to note that it's not operating in O(1) stack -beacuse- it's a tail call
06:13:08 <quicksilver> vixey: indeed, it's not a tail call.
06:13:10 <Toxaris> kristofer: (f $ x) is equivalent to (f x)
06:13:18 <vixey> TCO happens on the STG crap that is turned into assembly, but thats not the level we program *haskell* in
06:13:20 <Stephan202> goober: google "tail recursion"
06:13:22 <quicksilver> vixey: (main = processRequests >> main) isn't a tail call.
06:13:39 <kristofer> Toxaris,  alright, so everything after the $ is the second argument to liftM?
06:13:46 <Toxaris> kristofer: but you can sometimes avoid writing parentheses by using $
06:13:48 <Toxaris> kristofer: exactly
06:13:50 <goober> what would a miniature event loop look like in haskell?
06:14:02 <goober> or "event infinite recursion" as you might call it.......
06:14:05 <goober> lol
06:14:08 <yitz> goober: haskell is disruptively different in it's way of thinking, so we do get a lot of trolls. that makes people sensitive. please don't be insulted.
06:14:09 <Toxaris> goober: main = do event <- getEvent; handleEvent event; main
06:14:21 <Stephan202> ^ tail recursion on main
06:14:34 <goober> Toxaris: I thought haskell has no statements?
06:14:34 <quicksilver> Stephan202: (or technically, not ;)
06:14:38 <vixey> Stephan202: *groan*
06:14:44 <Stephan202> :o!?!
06:14:51 <Stephan202> Did I say something stupid?
06:14:54 <nn64> can lambdabot use varables and recall them later ?
06:14:56 <goober> why would haskell need more than just an expression
06:14:57 <quicksilver> goober: people use the word 'statement' for the things inside do blocks
06:15:03 <quicksilver> goober: they are technically expressions.
06:15:04 <byorgey> nn64: sure, use @let
06:15:12 <vixey> Stephan202, no you didn't
06:15:15 <Toxaris> goober: do notation is just syntactic sugar, you can write the very same thing like this: main = getEvent >>= handleEvent >> main
06:15:17 <quicksilver> goober: but nonetheless sometimes you hear them called satements.
06:15:19 <goober> what is "handleEvent event" ?
06:15:21 <ksf> main = getEvent >>= handleEvent >> main
06:15:23 <luite_> goober: forever eventHandler
06:15:27 <quicksilver> I tend to call them 'actions'
06:15:54 <Botje> @pl \x -> tell (Sum 1) >> return x
06:15:55 <lambdabot> (tell (Sum 1) >>) . return
06:16:04 <Toxaris> goober: handleEvent is a function which takes an event and returns the IO action to be performed in reaction to this event
06:16:09 <ksf> handleEvent Quit -> Foo; handleEvent MouseLeft -> ...
06:16:15 <Botje> hmm, is that right?
06:16:36 <vixey> Botje, yes it looks right
06:16:42 <Botje> okay, thanks
06:16:42 <byorgey> Botje: why not?
06:16:43 <ksf> ^^ignore syntax, it's borked.
06:16:45 <goober> so handleEvent isnt a part of haskell
06:16:51 <goober> its just the name you're using
06:16:54 <Toxaris> goober: exactly
06:16:59 <Toxaris> goober: the same for getEvent
06:17:06 <goober> can Haskell do reflection?
06:17:07 <ksf> ...and main.
06:17:11 <ksf> at least partwise.
06:17:15 <vixey> goober, no
06:17:18 <ksf> could be called mainLoop.
06:17:20 <goober> why not
06:17:23 <nn64> @let abc = 8899 + 888
06:17:23 <orbitz> does any of the biohaskell guys hang out where?
06:17:24 <lambdabot>  Defined.
06:17:29 <quicksilver> goober: types are compiled away, which means it can't do true reflection.
06:17:29 <nn64> >abc
06:17:33 <vixey> goober, why not what?
06:17:40 <nn64> > abc
06:17:42 <lambdabot>   9787
06:17:48 <nn64> ok cool
06:17:49 <quicksilver> goober: however, it has metaprogamming facilities which enable you to do surprisingly large parts of reflection.
06:18:02 <goober> D can do reflection... you cana get the members of a class -- I am asking about metaprogramming stuff
06:18:11 <Saizan> it also has Data.Typeable with is a limited form of reflection
06:18:24 <mapreduce> goober: Reflection is necessary for metaprogramming in languages with poor typesystems.
06:18:36 <ksf> "limited form of reflection" in the haskell sense is > reflection in the java sense
06:18:37 <mapreduce> goober: Haskell can do a lot of that stuff before runtime.
06:18:38 <kynky> like ruby
06:18:55 <goober> mapreduce: by reflection, i mean compile time reflection
06:19:07 <Saizan> for compile time we've macros
06:19:09 <orbitz> mapreduce: do you have an analogous example of some sort of reflection one woudl want to do in one language that can eb done in haskell?
06:19:11 <goober> for example, in D, it has something called CTFE -- compile time function evaluation
06:19:19 <goober> you can write functions that generate types
06:19:20 <kynky> good thing you can redistribute ghc quite freely, compared with other compilers or interpretors for other languages
06:19:21 <ksf> compile time reflection?
06:19:24 <goober> or generate strings of code
06:19:25 <mapreduce> orbitz: Pattern matching.
06:19:36 <ksf> that's afaik solely 3-lisp territory.
06:19:36 <goober> a CTFE function in D could write a whole D module
06:19:37 <Saizan> goober: yeah, we call that Template Haskell
06:19:48 <orbitz> goober: ist ha tliek a functor in ocaml
06:20:17 <goober> well, in D a CTFE function just runs at compile time, generates classes, types, whatever
06:20:22 <goober> can haskell "templates" do that?
06:20:23 <mapreduce> orbitz: Forget pattern matching actually.  I can't give such an example, because I'm a poor Haskeller.
06:20:23 <nn64> Could not find module `Control.Monad.Writer' ... Cant find the package this is in
06:20:24 <goober> perfectly?
06:20:27 <mapreduce> @quote posh
06:20:27 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
06:20:30 <mapreduce> (that's me)
06:20:32 <Saizan> goober: yes
06:20:51 <Saizan> goober: it's an extension implemented in GHC
06:21:00 <Saizan> goober: you can even define new syntax
06:21:04 <orbitz> Functors in Ocaml are functinos that take some sort of input and produce a module as output
06:21:06 <goober> is it implemented _well_ ?
06:21:15 <orbitz> define well?
06:21:32 <ksf> goober, compared to everything except scheme's define-syntax, brilliantly.
06:21:35 <goober> for example, can you literally generate a string of code
06:21:42 <goober> and have that be haskell code.
06:21:57 <mapreduce> You can do that for Java. :)
06:22:16 <kynky> b4 the bytecode stage ?
06:22:21 <goober> you can do that for D as well, at compile time as I said, it has nothing to do with VM's
06:22:24 <mapreduce> kynky: http://www.iam.unibe.ch/~akuhn/blog/2008/roman-numerals-in-your-java/
06:22:26 <lambdabot> Title: For.example ¬ª Blog Archive ¬ª Roman Numerals, in your Java, http://tinyurl.com/5zpke5
06:22:38 <vixey> goober, Haskell isn't D by the way
06:22:46 <Saizan> goober: yes, even if you usually generate the AST
06:22:50 <ksf> you can actually do it in assembly or opcodes.
06:22:52 <vixey> goober, If you want to program in D using Haskell is probably not a good way
06:22:55 <Saizan> generating strings of code seems painful
06:23:08 <kynky> even arcane ?
06:23:14 <goober> its not arcane
06:23:23 <ksf> Saizan, I guess he means quasiquote syntax
06:23:23 <goober> a mixin might simply do
06:23:29 <nn64> can some one help me with my lambdabot :::: join my irc :: linuxmain.net/6667 #linux
06:23:38 <goober> "Foo." ~ T ~ ".f()";
06:23:43 <goober> where otherwise that would be impossible
06:24:01 <ksf> goober, that is'nt typesafe.
06:24:04 <yitz> goober: Template Haskell does work well, but in practice you very rarely need it.
06:24:10 <goober> ksf: Of course it is
06:24:12 <goober> 100% typesafe
06:24:16 <ksf> you could say "@(*&%&^*&"  ~ T ~ ".f()";
06:24:18 <luite_> nn64: what's wrong with it? (sorry too lazy to join ;) )
06:24:20 <goober> again, it's *at cmpile time*
06:24:31 <Saizan> nn64: seen the online.rc file?
06:24:32 <byorgey> goober: yes, you can do that with Template Haskell.
06:24:36 <goober> It just gets evaluated first
06:24:43 <goober> into regular typesafe code
06:24:44 <ksf> you will get a strange error in the generated code, not inside your codegen.
06:24:47 <orbitz> goober: so in CTFE's you returan  string that will then be compiled?
06:24:47 <goober> then the second pass goes through
06:24:51 <goober> ksf: No you don't.
06:24:54 <goober> the errors, are perfect.
06:24:56 <Saizan> nn64: you've to edit it and start lambdabot with -e 'rc online.rc'
06:25:10 <goober> don't speculate
06:25:10 <orbitz> ksf: since this is part of D i would hope the compiler knows how to give a decent eor message...hoepfully
06:25:27 <kristofer> what's wrong with this? http://hpaste.org/12688
06:25:34 <luite_> nn64: lambdabot (or mueval?) does have some dependencies that are not listed in the cabal files, so it will probably complain when you try to execute something
06:25:36 <orbitz> goober: so are you trying to decide if you shoudl switch to haskell from d? or if haskell is worth learning? or just intersted ina comparison?
06:25:38 <loriel> It is D, the compiler is probably just going to segfault somewhere
06:25:49 <vixey> kristofer, why would there be something wrong with it?
06:25:52 <ksf> can you say stuff like "Foo.\""Foo." \~ T \~ ".f()\"; ~ T ~ ".f()";?
06:26:02 <ksf> that is, quasiquoting?
06:26:09 <byorgey> kristofer: perhaps you mean  (Number . read) x ?
06:26:27 <byorgey> Number . read x  parses as  Number . (read x)
06:26:28 <Saizan> ksf: in TH? yes
06:26:41 <ksf> i meant in d.
06:26:41 <goober> basically, D has the most powerful template system of any C language, and that's only because of a *reaction* against the limitations of the past 30 years... where walter bright, who wrote the COMEAU c++ compiler, went back and removed every limitation
06:26:48 <goober> whereas Haskell hasn't had a "reaction" yet
06:26:53 <goober> it's only the first model
06:27:04 <kristofer> byorgey, now I get some undefined reference errors
06:27:05 <orbitz> i'm unsure haskell needs a reaction
06:27:08 <goober> and likely, there's no chance for a visionary to redefine it and remove such limits
06:27:09 <ksf> c++ templates are turing complete, they're just ugly.
06:27:11 <orbitz> C was created on the fly
06:27:16 <orbitz> peopel sat down and thought abotu haskell
06:27:18 <nn64> luite_, thats exactly whats happening its complaneing about everything when trying to exacute everything
06:27:21 <kynky> haskell is pretty sweet, c++ seems a kludge
06:27:21 <BeelsebobWork_> @hoogle Monad m => (a -> b -> b) -> b -> [m a] -> m b
06:27:22 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
06:27:22 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
06:27:22 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:27:26 <goober> so is "template haskell" not a part of haskell?
06:27:26 <orbitz> but you coudl consider haskell a reaction to miranda
06:27:34 <orbitz> goober: it's an extension
06:27:35 <goober> its not a 3rd party preprocessor, right?
06:27:36 <luite_> nn64: just look up the missing packages in hoogle, you will see the package name, cabal install that
06:27:41 <yakov> orbitz, check out haskell history..
06:27:41 <orbitz> goober: i think yo uare looking at this the wrong way
06:27:49 <BeelsebobWork_> @hoogle foldM
06:27:50 <ksf> is th going to be in h'?
06:27:50 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
06:27:50 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
06:27:50 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
06:27:53 <byorgey> kristofer: undefined references to what?
06:27:55 <luite_> nn64: I think you'll need about 5 extra pacakges
06:27:57 <kynky> and D is just tidying up the mess from c++, sure its got soom cool things, but surely overdue in the oop world ?
06:28:00 <Saizan> goober: we don't have such limits in the first place, it's not like haskell has not learned from past languages, we surely have other new peculiar limits though :)
06:28:01 <goober> the problem with preprocessors is they dont understand the code itself
06:28:06 <yakov> orbitz, miranda might be the haskell of our days..
06:28:09 <kristofer> byorgey, `parseczm2zi1zi0zi0_TextziParserCombinatorsziParsecziError_zdf1_closure
06:28:12 <nn64> @hoogle Control.Monad.Writer
06:28:12 <lambdabot> module Control.Monad.Writer
06:28:12 <lambdabot> Control.Monad.Writer.Lazy newtype Writer w a
06:28:12 <lambdabot> Control.Monad.Writer.Lazy Writer :: (a, w) -> Writer w a
06:28:18 <kristofer> there's a lot printed out above that too
06:28:22 <ksf> goober, it's a specced extension that gets implemented by the various compilers/interpreters
06:28:22 <byorgey> kristofer: are you compiling with --make ?
06:28:23 <goober> Saizan: what are the new peculiar limits?
06:28:25 <orbitz> yakov: 'our days'?
06:28:30 <kristofer> byorgey, no
06:28:31 <nn64> ? that dosent tell me where to get it
06:28:39 <byorgey> kristofer: ok, you should =)
06:28:50 <goober> why doesn't core haskell have the functionality of template haskell ?
06:28:53 <kristofer> byorgey, hey that did it
06:28:56 <Saizan> goober: you've to understand the language before you can ask that
06:28:56 <kristofer> thanks ya'll
06:28:56 <goober> why cant you replace types in haskell
06:29:04 <ksf> goober, because it doesn't need to.
06:29:15 <ksf> it's designed to be as simple as possible.
06:29:16 <byorgey> kristofer: --make tells ghc to chase down dependencies and link in other libraries you need (like parsec)
06:29:20 <orbitz> goober: haskell is picking up the peices left by C, it is a very powerful language on its own
06:29:26 <orbitz> err
06:29:28 <orbitz> isn't****
06:29:32 <kynky> haskell is like a whole diff way of thinking to D/C++
06:29:34 <nn64> lunabot, hoogle tells me about the module but not how to retreve it
06:29:34 <luite_> nn64: use the website :)
06:29:36 <byorgey> kristofer: otherwise you would have to specify it manually, like  -package parsec
06:29:41 <kristofer> right, I was just realizign I didn't pull iln parsec at the command line
06:29:52 <byorgey> right
06:29:53 <nn64> luite_, which website
06:30:09 <vixey> goober, how did you get so interested in haskell?
06:30:10 <luite_> nn64: http://www.haskell.org/hoogle/?hoogle=Control.Monad.Writer <- tells you that you need to cabal install mtl
06:30:11 <lambdabot> Title: Control.Monad.Writer - Hoogle
06:30:31 <nn64> oh ok thanks
06:30:32 <orbitz> goober: if you would like to learn haskell i think you should forget abotu C/C++/D for a bit and concentrateon hwo haskell does things and then perhaps go back and compare and contrast.  just asking "i can do X like this in D, whyc an't i do X liek this in haskell" won't get you far
06:30:46 <goober> vixey: because I stopped learning
06:30:54 <goober> i know everything about C++ :P
06:31:10 <Asztal> hah!
06:31:10 <kynky> like comparing apples to oranges
06:31:39 <ksf> goober, if you only want to grok that you don't know stuff, have a look at http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
06:31:41 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/6q4ut7
06:32:00 <nn64> luite_, I already have mtl installed but its still saying it dosen't have it
06:32:13 <orbitz> ksf: did you see Cale's even/odds example from last night?
06:32:19 <ksf> yes
06:32:46 <ksf> kinda like the mutual recursive gcd example we had in class.
06:32:51 <luite_> nn64: hm, have you installed it using cabal install, for the same ghc version as your lambdabot uses?
06:33:16 <ksf> so far, i've never really come across a mutual recursion i wanted to implement, thou.
06:34:25 <Jedai> ksf: In Haskell it's far more often useful, with infinite data structure and recursion being the only control structure
06:34:28 <orbitz> ksf: can i express that as 1 expression though?
06:34:52 <ksf> urm...
06:35:02 <orbitz> indeed ic an
06:35:05 <ksf> feed it into @pl?
06:35:07 <orbitz> let evens2 = 0:(map (+1) (map (+1) evens2))
06:35:15 * vixey is wondering, what does 'control structure' actually mean?
06:35:15 <Jedai> ksf: A oft cited exemple are the miscellaneous infinite lists of primes, almost all use mutual recursion somewhere
06:35:50 <ksf> well i don't usually compute primes.
06:36:00 <Jedai> vixey: The exact term is escaping me (I'm not a native speaker), I mean things like loops for example
06:36:35 <ksf> vixey, stuff that is'nt a goto. it's a term from structured programming.
06:36:44 <byorgey> Jedai: no, 'control structure' is the right term, I think vixey was wondering on a more abstract level.
06:36:53 <yitz> Jedai: recursion is far from the only control structure in Haskell, but all others are ultimately built upon it
06:37:18 <ksf> recursion is a dataflow concept, not of control.
06:37:29 <ksf> if then else is a control structure.
06:37:35 <ksf> and pattern matching.
06:37:59 <Jedai> yitz: Right, one of the advantage of Haskell is that it's easy to create new control structures but at their core is always recursion (or if then else, though this one is redundant in truth)
06:38:07 <ksf> (==), otoh, isn't.
06:38:07 <yitz> the term "control structure" itself has an imperative flavor to it
06:38:10 <ksf> it's a function.
06:38:23 <ksf> pure like fresh snow.
06:39:03 <yitz> if-then-else is also a function, though it has abnormal syntax
06:39:18 <kristofer> what does >>= mean?
06:39:26 <Peaker> goober: can you come to #haskell-blah ? I don't want OT discussion of C++ here, but I want to ask you a question about it
06:39:36 <ksf> well, then pattern matching is.
06:39:53 <ksf> at some point you have to inject branching into any turing-complete language.
06:40:06 <Peaker> kristofer: it means: Build a new action, that first "executes" the left-hand action, hands its result to the right-side function, then executes that as well, and results in the right-side result
06:40:12 <Peaker> kristofer: or more simply, sequencing actions
06:40:24 <Jedai> kristofer: (>>=) is called 'bind', one of the function of the Monad typeclass, it's meaning depends on the monad in which it is used
06:40:24 <vixey> does 'if' count as one?
06:41:09 <yitz> ksf: you don't need "branching"
06:41:22 <ksf> I tend to disagree.
06:41:37 <ksf> not about the quotes, though.
06:42:09 <yitz> ksf: the lambda calculus can represent any turing-computable function, but it starts essentially with only the constant function and the identity function.
06:42:09 <ksf> yitz, try to do a minimal lisp and leave out both "if" and "cond"
06:42:23 <ksf> *groan*
06:42:36 <ksf> _without_ using abstract nonsense like church numerals.
06:43:00 <Philippa> ksf: are church booleans allowed?
06:43:03 <vixey> ksf, if you introduce some constants #t and #f with no way to discern between them.. yeah it'll be tricky :p
06:43:06 <yitz> ksf: heh. you wouldn't want to build a *real* language without some convenient conditional, of course.
06:44:26 <ksf> in fact, the functional implementations of car and cdr work just fine as bools.
06:44:47 <Philippa> ksf: yeah, that's because they're church booleans
06:45:00 <vixey> the problem with making a whole language oout of lambda is that you run the program and the result is like  \x\y\z\w->....
06:45:05 <ksf> I didn't yet decide whether or not that qualifies as abstract nonsense.
06:45:34 <yitz> only category theory is authentic abstract nonsense
06:45:38 <ksf> it'll surely be useful if you target e.g. gpus.
06:46:25 <Philippa> ksf: a useful thing to remember is that having raw maths as your 'low level' doesn't necessarily make something more 'abstract nonsense' than having, say, IA32 instructions
06:46:50 <ksf> in fact, maybe you could squeeze some performance out of the x86 simd instructions like that.
06:46:51 <Philippa> most of that raw maths supports at least one operational interpretation
06:47:52 <ksf> well you're going to have a hard time finding a chip without ints, loads,stores and jumps, fpgas cast aside.
06:48:14 <ksf> (which'd be cool, compiling down to configware)
06:48:43 <cknapp> What's the function to cast any Num to an Int?
06:48:52 <cknapp> or rather... any function
06:49:16 <ksf> was'nt the smallest possible instruction set "jump and decrement if not zero"?
06:49:34 <ksf> or something aggregate along those lines.
06:49:36 <yitz> @type fromIntegral . toInteger
06:49:37 <pizza_> ksf: switch jump and decrement
06:49:37 <lambdabot> forall b a. (Integral a, Num b) => a -> b
06:49:49 <Philippa> ksf: what's this crap about chips? Never hand-cranked a bit of computation before? :-)
06:50:09 <Philippa> (this is less silly a comment than you might think, consider the original definition of "computer")
06:50:16 <pizza_> and it can be == zero" or <= zero
06:50:23 <vixey> hehe
06:50:26 <ksf> like sorting soxen?
06:50:27 <yitz> cknapp: if it's not an Integral type to begin with, you first need to apply round or floor or ceil or something
06:50:51 <cknapp> yitz: thanks
06:51:07 <yitz> Philippa: cf. Analytical Engine II
06:51:15 <ksf> but then, floor and ceil give you an integral.
06:51:21 <Philippa> yitz: different value of "hand-cranked" :-)
06:51:45 <ksf> like bubble-sorting your xmonad windows?
06:52:10 <Philippa> ksf: within human memory, "computer" was a job role for people
06:52:20 <vixey> is anybody going to do something about the hackage.haskell.org usability problem?
06:53:01 <Igloo> What problem?
06:53:03 <Saizan> which problem in particular?
06:53:06 <ksf> my parents are both bank clerks, they did enough of it to last for generations, so I tend to suck at it ;)
06:53:47 <Philippa> heh. You get my point, anyway?
06:53:48 <ksf> especially as you just don't learn the tricks they learned in school anymore.
06:53:54 <vixey> you type into google "<something I want to get from hackage>" and then you get to the page with the _old_ version, and you don't notice and install the old version
06:54:10 <vixey> I've done this a couple times and I know I'm not the only one that makes this mistake too
06:54:18 <Philippa> also, church encoding is a fairly deep application of what should be classic software engineering principles
06:54:25 <ksf> vixey, cabal install <foo>
06:54:32 <vixey> you could color the background red on the old pages for example
06:54:33 <lilac> cknapp: i think the most general you can easily get is (Real r) => r -> Int
06:54:42 <vixey> anything that like, which differentiates older versions from current
06:55:14 <cknapp> lilac: I think I got it thanks... I'm starting to crash, so I'm mixing up a lot of words and ideas... and it's getting messy...
06:55:22 <jeffz`> vixey, I've never noticed that, I always visit hackage by the index page which shows all the package names, usually just for documentation, for installing things I use cabal install
06:55:24 <Saizan> vixey: you could file a ticket about that on hackage's trac
06:56:05 <quicksilver> vixey: personally I keep the hackage complete index as a permanently open tab
06:56:13 <quicksilver> vixey: and I search it with browser search when I'm looking for stuff.
06:56:26 <ksf> @quote bucky The stone does not penetrate the water molecules
06:56:26 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
06:56:32 <quicksilver> although I'm probably not a good example because I very rarely use anyhing on hackage.
06:56:40 <ksf> @remember bucky The stone does not penetrate the water molecules
06:56:40 <lambdabot> I will never forget.
06:57:05 <Saizan> quicksilver: and you still keep it permanently open?
06:57:11 <Philippa> ksf: I bet half your problems with church encoding're actually about it being too concrete/low-level, in fact :-)
06:57:16 <quicksilver> Saizan: yes. So I can help people here in this channel.
06:57:18 <quicksilver> Saizan: ;)
06:57:29 <Saizan> aah :)
06:58:11 <Peaker> Philippa: it is low-level, but not concrete...
06:58:13 <ksf> I don't have any problems without, I just don't usually consider it applicable to numbers.
06:58:33 <ksf> s/without/with it/
06:58:47 <ksf> though the original is true, too.
07:00:00 <ksf> in fact, I like the notion of Integers limiting maximum expression depth in real-world systems.
07:01:27 <Philippa> Peaker: it's entirely concrete if you accept that the lambda calculus is your substrate system
07:01:50 <Philippa> all this crap about 1s and 0s is specific to the systems we habitually run stuff on
07:01:52 <Peaker> Philippa: one definition from google define: "capable of being perceived by the senses; not abstract or imaginary; "concrete objects such as trees" "
07:02:33 <Philippa> which isn't the definition you're likely to see in a discussion of computing now, is it?
07:02:44 <ksf> Peaker, which makes it concrete on lisp machines.
07:03:14 <ksf> anyway, a tree is just an abstraction of its dna and molecules.
07:03:17 <vixey> lisp machines aren't lambda evaluators
07:03:25 <BeelsebobWork_> Philippa: that sounds a lot like the definition of concrete I'd use in computing
07:03:32 <vixey> they run some abstract machine which makes efficient implementation of that, right?
07:03:56 <ksf> vixey, i sincerely have no idea at all.
07:04:02 <ksf> I just know they run lisp.
07:04:05 <ksf> In hardware.
07:04:33 <Philippa> Beelsebob: by analogy rather than straight-up, usually
07:04:35 <ksf> and got at least cons/car/cdr/gc as primitives
07:05:15 <Philippa> otherwise, nothing but the physical representations for symbols you're pushing around is concrete
07:13:56 <Saizan> gc?
07:14:33 <ksf> garbage collector.
07:14:53 <Peaker> Philippa: I guess its easier for humans to visualize a representation of a number, than that of a lambda?
07:15:00 <ksf> "primitive" is a kind of mis-nomer there, read it as "invariant"
07:15:03 <Peaker> (in that sense, its more "concrete")
07:15:36 <ksf> humans don't use visualisations for their concepts of concrete numbers.
07:15:42 <ksf> numbers just are.
07:16:05 <ksf> bucky has some interesting stuff about this in his numerology.
07:17:58 <ksf> in fact, it appears to me that all numbers are constructed out of the concept one, three, and the idea that both are two concepts.
07:17:59 <Philippa> ksf: my point's that by the definition I was given, there's no such thing as a concrete number :-)
07:18:14 <ksf> which explains my intuition on prime numbers, at least below say 50 or so.
07:18:48 <Philippa> ksf: show me how to construct, say, e with just those things?
07:19:41 <ksf> if you show me a foam bubble from which you can approximate pi to n digits, sure.
07:20:51 <ksf> also, please show me the exact representation of e as a ieee float.
07:22:20 <ski_> (ksf : "term&proof-land" ?)
07:22:27 <ksf> yeah.
07:22:36 <ski_> elaborate ?
07:22:43 <vixey> having a representation of something .. makes it concrete? hehe
07:22:48 <vixey> seem like the opposite
07:23:20 <ksf> it surely makes it more concrete than a mathematical definition.
07:24:21 <ksf> ski_, you're not busy drafting vararg support into the type system for h'?
07:25:22 <vixey> How many different ways can varargs be done in haskell?
07:25:23 <vixey> I know 2
07:25:25 <ski_> ksf : no .. sadly to say, i never understood what you was hinting at with `(a : b : c : []) -> d' and `a -> (b -> (c -> d))'
07:25:48 <ksf> we were just talking about it.
07:25:55 <ksf> church encoding.
07:25:56 <ski_> (possibly i was missing context)
07:26:21 <ksf> lists are functions are lists
07:26:34 <ski_> > length !! 3
07:26:35 <lambdabot>   Couldn't match expected type `[a]'
07:27:20 <ksf> that'll give _|_, or Infinity, as length :: [a] -> a.
07:27:41 <ksf> nuke that.
07:27:53 <ksf> that'll be length length.
07:28:06 <ksf> (i'm seeing syntax problems creeping up)
07:29:01 <idnar> "concreteness" is all relative
07:29:20 <idnar> there's no way to work with anything other than representations
07:30:45 <vixey> sounds a lot like meaning in that way
07:32:24 <ksf> I'm not sure whether or not I'd be able to argue that fire is a mere representation should I be burned on a stake.
07:33:18 <ksf> And it also begs the question what oneself is a representation of.
07:38:04 <ksf> @remember bucky All you see is a little of my pink face and hands and my shoes and clothing, and you can't see me, which is entirely the thinking, abstract, metaphysical me. It becomes shocking to think that we recognize one another only as the touchable, nonthinking biological organism and its clothed ensemble.
07:38:04 <lambdabot> Done.
07:38:30 <vixey> @forget bucky All you see is a little of my pink face and hands and my shoes and clothing, and you can't see me, which is entirely the thinking, abstract, metaphysical me. It becomes shocking to think that we recognize one another only as the touchable, nonthinking biological organism and its clothed ensemble.
07:38:31 <lambdabot> Done.
07:38:41 <ksf> ?
07:39:18 <Philippa> <ksf> it surely makes it more concrete than a mathematical definition. <- a representation is just a concrete syntax for a mathematical definition
07:39:55 <ksf> Philippa, e cannot have a concrete representation.
07:39:56 <Philippa> to put it another way: that's not an ieee float, it's a chunk of $substrate
07:40:48 <Philippa> *sigh*
07:40:54 <Philippa> look, you're failing to define what one actually /is/
07:41:03 <Philippa> so it's not surprising that we're not lining up on this now, is it?
07:41:08 <ksf> even if you could use all the combinatory possibilities of all particles in the universe, you couldn't code it.
07:41:31 <Philippa> you're making an awful lot of assumptions there
07:41:51 <Philippa> not least about what's a valid 'code'
07:41:52 <ksf> i'm assuming that e is irrational and the universe finite.
07:42:02 <Philippa> those aren't the only things you're assuming
07:42:38 <ksf> i'm also using a certain definition of "concrete" that incorporates "computed"
07:43:25 <ksf> as analogy, the length of a list _is_ computed as soon as it contains a [].
07:43:26 <Philippa> yep. I suggest you continue unpacking it a little further, then I'll show you where the religion comes in
07:43:33 <ksf> you don't need to call length on it to do that.
07:43:56 <Philippa> there's a trivial counterexample available in, say, prolog
07:43:59 <wchogg> @seen conal
07:44:00 <lambdabot> I saw conal leaving #haskell and #ghc 1m 19d 10h 8m 14s ago, and .
07:44:23 <BeelsebobWork_> uh, lambdabot -- what crack have you been smoking?
07:44:25 <ksf> now you've lost me.
07:44:38 <Philippa> actually, right now I don't have time to have you define yourself clearly - I've got a date in another city to get to
07:44:57 <Philippa> Prolog allows you to write x:[] where x is unknown, and work with it
07:45:30 <Philippa> now, I know what you're trying to say: the data is there already because it's a trivial fold
07:45:46 <BeelsebobWork_> wchogg: wasn't really something to polute the reactive mailing list with, but your integrals could be cleaned up a decent amount using InfixApplicative
07:45:47 <Philippa> or to put it another way: [Void] is isomorpic to Nat
07:46:02 <vixey> sneaky use of Void instead of ()
07:46:06 <vixey> Phlippa++
07:47:12 <ksf> and Nat is... not concretely representable.
07:47:21 <ksf> I'm getting ultrafinitistic right now.
07:47:44 <Philippa> ksf: assume there's a ! in the definition if it helps
07:47:58 <Philippa> oh, and that we're using strict lists
07:47:58 <ksf> nope, it doesn't.
07:48:06 <ksf> just shifts the bottom around.
07:48:09 <Philippa> (otherwise there's no isomorphism)
07:48:10 <wchogg> BeelsebobWork_:  Not sure what you mean.
07:48:18 <Philippa> it shifts the bottom /out of the type/
07:48:27 <Philippa> that's relevant: no Nat contains a bottom
07:48:35 <Philippa> there're calculi that don't /have/ bottoms
07:48:48 <Philippa> it's not that hard to define a subset of Haskell that doesn't either
07:49:11 <ksf> a list that contains a [] is not isomorphic to the usual definition of nat in terms of succ, because the latter lacks an upper bound.
07:49:20 <BeelsebobWork_> wchogg: euler tau x0 v0 a = x <^(,)^> v ...
07:49:26 <BeelsebobWork_> and various other liftA2s
07:49:44 <Philippa> er, youwhat? What do you think 0 is?
07:49:53 <ksf> a lower bound?
07:49:54 <wchogg> BeelsebobWork_:  Ah, sure.  I agree.
07:50:00 <Philippa> right. So where's the list's upper bound?
07:50:22 <Philippa> assume, as already stated, that we're talking strict lists: there's no infinite list
07:50:39 <ksf> the list's upper bound is [].
07:50:44 <Philippa> no, it's not
07:50:51 <Philippa> that's the list's lower bound
07:51:01 <ksf> ...if its head is the lower.
07:51:12 <ksf> we're just thinking from differend ends.
07:51:18 <Philippa> and the outermost succ is the Nat's upper bound
07:51:25 <ksf> anyway: the point is that it has two.
07:51:50 <Saizan> if the outermost cons is a bound then the outermost succ is a bound too
07:52:00 <ksf> so there's a biggest (though unknown) integer?
07:52:09 <Philippa> there's a biggest (though unknown) list?
07:52:28 <ksf> if you want to concretely represent it, at least.
07:52:32 <Elly> I don't believe you
07:52:53 <lilac> ksf: suppose there were a biggest. apply cons or Succ to it. contradiction
07:53:10 <Philippa> ksf: same would apply to nats. Get used to it
07:53:25 <wchogg> BeelsebobWork_:  The main thing that was bothering me is that it feels kind of like what are simple intro comp. physics algorithms require you to get a bit grungy with the Event abstraction.  I might be being silly, though.
07:53:37 <Philippa> to put it another way: you're attempting to define lists from the concrete representations you know, and it's tripping you up
07:53:41 <ksf> you can't cons or succ further, because you don't have any particles or bits left.
07:53:46 <quicksilver> wchogg: you're not being silly. We don't quite have the right convenient (higher-level) combinators yet.
07:53:54 <Elly> ksf: how do you know there are a limited number of bits?
07:54:04 <ksf> nope, i'm just constructivist.
07:54:08 <Philonous> So the upper bound is the computers memory?
07:54:12 <eyeris> Is there an easy way to track down which application on Parsec's many is causing the exception "combinator 'many' is applied to a parser that accepts an empty string."?
07:54:12 <Philippa> and I've got better things to do than deal with someone who'll make claims about isomorphisms while being that wilfully sloppy
07:54:39 <ksf> Philonous, if you want to represent on a computer, yes.
07:54:40 <BeelsebobWork_> yeh, I have the same feeling, hence why my minor changes weren't really suitable for the list -- they didn't really contribute anything substantially nicer
07:54:54 <Saizan> eyeris: the ghci debugger maybe
07:54:56 <ksf> there are no infinite stripes of paper you can feed into a machine.
07:55:10 <eyeris> Saizan there is a debugger in ghci?
07:55:19 <lilac> ksf: that alone doesn't mean there aren't stripes of paper of every finite size
07:55:20 <Saizan> ?google ghci debugger
07:55:22 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
07:55:22 <lambdabot> Title: 3.5.ÔøΩThe GHCi Debugger
07:55:30 <Saizan> eyeris: yes ^^^^
07:55:32 <wchogg> eyeris:  Check...Monad Reader 10, I think, for a good tutorial on the debugger.
07:55:35 <eyeris> Holy mother of god
07:55:36 <eyeris> :)
07:55:45 <ksf> lilac, but that'll mean that there's an infinite number of stripes.
07:55:50 <tomh> mm how is haskell able to calc an integer with 2500+ digits?
07:55:56 <eyeris> I wish I found that earlier :)
07:56:02 <lilac> ksf: only if you want them all to exist at the same time :)
07:56:02 * ksf is getting confused.
07:56:07 <ksf> damn formalists.
07:56:08 <Elly> tomh: arbitrary precision support
07:56:18 <tomh> what does that mean?
07:56:34 <Elly> it means if you represent the numbers as strings (or some more efficient representation)
07:56:40 <Elly> there's no reason you can't have arbitrarily large integers
07:56:44 <tomh> ok
07:56:45 <Elly> it's just kinda slow compared to "real" integers
07:57:14 <tomh> ye was just talking to a friend and he challanged me to implement a factorial of 1..1000
07:57:30 <tomh> it was just one line of haskell, but apparently its not that easy in other languages :)
07:57:38 <vixey> > product [1..1000]
07:57:39 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
07:57:48 <Elly> well, in Java it's not many lines; in C it's a LOT of lines if you include the bigint library
07:57:52 <quicksilver> tomh: most modern languages have large integer support.
07:57:54 <lilac> > length . show . product $ [1..1000]
07:57:54 <Elly> but that makes sense
07:57:55 <lambdabot>   2568
07:58:00 <quicksilver> tomh: java/perl/python/ruby/haskell etc
07:58:03 <tomh> quicksilver not large enough :)
07:58:16 <quicksilver> by large I mean 'arbitrarily' large
07:58:37 <tomh> apperently c# didnt had one which could fit the 2568
07:58:38 <pizza_> Elly: it's not too many using libgmp in C ;)
07:58:55 <quicksilver> tomh: I think your C# programming friend is clueless.
07:58:56 <ksf> > log $ product [1..1000]
07:58:57 <lambdabot>   Infinity
07:58:59 <Elly> mzscheme can calculate that value quite handily
07:58:59 <ksf> blast.
07:59:06 <quicksilver> tomh: C# certainly has a large integer class
07:59:12 <tomh> ulong
07:59:13 <tomh> yes
07:59:14 <ksf> see? that's where formalism fails.
07:59:15 <Elly> > (log (fact 1000))
07:59:15 <Elly> 5912.128178488163
07:59:16 <pizza_> heh
07:59:16 <lambdabot>   Not in scope: `fact'
07:59:29 <tomh> but ulong cant contain 2568 digits..
07:59:38 <pizza_> ulong != bigint
07:59:53 <lilac> ksf: that's because it's defaulted to Double and run the product there.
08:00:10 <ksf> > log $ product [1..1000] :: Integer
08:00:11 <lambdabot>       No instance for (Floating Integer)
08:00:11 <lambdabot>        arising from a use of `log' a...
08:00:16 <ksf> :t log
08:00:17 <lambdabot> forall a. (Floating a) => a -> a
08:00:18 <Elly> ksf: it's about 5912
08:00:24 <Elly> as I said above :P
08:01:00 <lilac> is there an infinite-precision lazy floating point type somewhere?
08:01:03 <ksf> could've used Foreign.sizeOf, too.
08:01:21 <quicksilver> tomh: a quick google suggests in C# the simplest solution is to link to J# and use BigInteger
08:01:28 <Saizan> > exp 1 :: CReal
08:01:30 <lambdabot>   2.7182818284590452353602874713526624977572
08:01:46 <quicksilver> tomh: if that's actually true then the .NET developers are orders of magnitude more incompetent than I previiously imagined. *boggle*
08:02:11 <Saizan> lilac: CReal is from the numbers package, if it qualifies
08:02:20 <wchogg> quicksilver:  Hah, I think you found the same link I did.  I was really surprised to see that it wasn't in 3.5
08:02:28 <pizza_> fewer people use bigints in practice than the functional programming crowd may realize
08:02:42 <lilac> > log $ product [1..1000] :: CReal
08:02:47 <quicksilver> pizza_: I imagine most people use them every single day.
08:02:57 <lambdabot>   thread killed
08:02:59 <tomh> quicksilver: ye thats why my friend said it was harder in c# to achieve this functionality
08:03:00 <quicksilver> pizza_: unless they never use SSL or SSH.
08:03:07 <ksf> they come in handy in game logic programming.
08:03:20 <ksf> you don't want an account balance to wrap.
08:03:25 <quicksilver> lilac: I don't like to think of CReal as floatingpoint, thouhg.
08:03:38 <quicksilver> lilac: because floating point suggests precision problems.
08:03:45 <quicksilver> CReal is computable reals, hence the name...
08:03:48 <vegai> might be handy in Zimbabwean banking applications
08:04:35 <wchogg> why?
08:04:39 <ksf> also, bigints are useful if you don't have access to float, you can scale better.
08:04:56 <pizza_> quicksilver: i'd imagine few people work *on* openssl
08:05:45 <quicksilver> pizza_: true enough, but you see my point ;)
08:06:52 <pizza_> perhaps you mistook my statement as an attack on the utility of bigints; it wasn't
08:08:01 <ksf> One could argue about them being the default, but I prefer it that way.
08:08:06 <ksf> eases prototyping.
08:08:45 <ksf> and haskell seems to be designed to favour speed of code development over execution speed.
08:08:45 <wchogg> I have to admit, I don't think I had seen Applicative.Infix before but it's pretty cute.
08:11:23 <Peaker> the formatting is broken in http://hackage.haskell.org/packages/archive/InfixApplicative/1.0.1/doc/html/Control-Applicative-Infix.html
08:11:24 <mapreduce> How can I show that Haskell has the monomorphism restriction, using lambdabot?
08:11:29 <lambdabot> Title: Control.Applicative.Infix, http://tinyurl.com/589roe
08:11:31 <Peaker> <> brackets are probably not escaped properlty
08:12:53 <vixey> @let m = fmap
08:12:55 <lambdabot>  <local>:21:4:
08:12:55 <lambdabot>      Ambiguous type variable `f' in the constraint:
08:12:55 <lambdabot>        `Fu...
08:13:04 <vixey> @let m f o = fmap f o
08:13:07 <lambdabot>  Defined.
08:13:41 <ksf> Philippa, constructivism is "willful sloppyness"?
08:15:52 <Saizan> @where haddock
08:15:52 <lambdabot> http://www.haskell.org/haddock/
08:16:13 <Saizan> Peaker: it may be worth reporting
08:18:00 <quicksilver> mapreduce: I don't think you can, using lambdabot
08:18:16 <quicksilver> mapreduce: lambdabot runs with -fno-monomorphism-restriction and extended defaulting.
08:18:19 <quicksilver> I think.
08:18:36 <mapreduce> quicksilver: Ah, I see.
08:19:35 <mapreduce> Thanks.
08:20:06 <vixey> @let m = fmap -- isn't that monomorphism ?
08:20:08 <lambdabot>  <local>:21:0:
08:20:08 <lambdabot>      Equations for `L.m' have different numbers of arguments
08:20:08 <lambdabot>  ...
08:20:16 <vixey> @undef
08:20:33 <KoenigGunther> hi @all
08:20:41 <vixey> hi
08:21:06 <KoenigGunther> Well, I have a question regarding my Haskell homework :P
08:21:20 <KoenigGunther> We have to implement some functions for parsing
08:21:54 <eyeris> Why does choice (parsec) allow the empty string if none of the parsers passed to it accept the empty string>
08:21:55 <eyeris> ?
08:23:08 <Saizan> ?hoogle choice
08:23:09 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
08:23:09 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
08:23:09 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
08:23:34 <Philippa> <ksf> Philippa, constructivism is "willful sloppyness"? <- Using existential reasoning about how far you get with it and still calling it all constructivism is
08:23:36 <Saizan> ?ty choice
08:23:38 <lambdabot> Not in scope: `choice'
08:23:40 <hugo___> i have a function that returns Maybe (IO Image), but inside it i do IO Magic, and it just complaints, how do i solve this ? :/
08:23:57 <Philippa> so is applying it only sometimes, and then not acknowledging when you've been caught
08:24:05 <KoenigGunther> We do have the following script: http://paste.ubuntuusers.de/393107/...
08:24:05 <KoenigGunther> The task is to define a function nTimes :: Int -> Parse a b -> Parse a [b] that runs the parser n times
08:24:37 <eyeris> Saizan I don't follow.
08:24:45 <vixey> KoenigGunther, start with 0
08:25:02 <vixey> KoenigGunther, then do the case when the Int is 1 + something
08:25:15 <Saizan> eyeris: i was just refreshing my memory on choice, but i don't get why it would accept the empty string either
08:25:22 <vixey> nTimes 0 p = ...
08:25:32 <vixey> nTimes n p = ... (nTimes (n-1) p) ...
08:25:43 <lilac> KoenigGunther: looks like "Parse a" is a Monad. if so, nTimes = replicateM
08:26:05 <Saizan> hugo___: depends, you could use your IO Magic from inside the action you return wrapped in the Maybe
08:26:10 <KoenigGunther> okay, these were my thoughts, too :)
08:26:29 <eyeris> Ok. I thought it was because it had to return a string (since that's the inferred return type) since some of the options I pass to it could consume input but I tried "choice $ map try [...]" and that also returned the empty string
08:26:40 <Saizan> hugo___: or you can change your type to IO (Maybe (IO Image)) or IO (Maybe Image)
08:27:21 <KoenigGunther> my problem is the case when going from n = 0 to n = n+1... if i run a parser for the first time, the second parser would have to use the "rest" of the input string parser1 hasn't touched, right?
08:28:24 <hugo___> Saizan: both solutions are not elegant
08:28:41 <ksf> I use existential hypothesises, yes.
08:29:06 <ksf> You can't cook a tasty meal without imagining it first.
08:29:37 <Philippa> you can't have it both ways
08:29:58 <Saizan> eyeris: choice ps  = foldl (<|>) pzero ps
08:30:04 <KoenigGunther> i have to use the function >*>, but if i do so, i get totally confused with the type of the return value
08:30:05 <KoenigGunther> :D
08:30:06 <ksf> you mean they can't ever match up?
08:30:08 <Philippa> a constructivist cannot prove anything about the universe they inhabit
08:30:18 <Philippa> only those they can construct within it
08:30:24 <Saizan> eyeris: so it's very weird if it's returning any result that's not coming from the list of parsers
08:30:55 <quicksilver> hugo___: IO (Maybe Image) is the correct type, if it does any IO
08:31:00 <lilac> @type let a >>= f = \s -> a s Prelude.>>= uncurry f in (>>=) :: ([a] -> [(b,[a])]) -> (b -> [a] -> [(c,[a])]) -> ([a] -> [(c,[a])]) -- KoenigGunther
08:31:02 <lambdabot> forall a b c. ([a] -> [(b, [a])]) -> (b -> [a] -> [(c, [a])]) -> [a] -> [(c, [a])]
08:31:11 <quicksilver> hugo___: the type Maybe (IO Image) is the type of a function which does no IO, but (maybe) returns a function.
08:31:28 <quicksilver> hugo___: ...or action, I should say, And the action can do IO.
08:31:36 <quicksilver> (but won't until you execute it, of coursE)
08:31:59 <lilac> @type return b as = [(b,as)] in return :: b -> [a] -> [(b,[a])]
08:32:00 <lambdabot> parse error on input `='
08:32:11 <KoenigGunther> wow, ummmm... give me a second to understand what you did :P
08:32:11 <lilac> @type let return b as = [(b,as)] in return :: b -> [a] -> [(b,[a])]
08:32:13 <lambdabot> forall b a. b -> [a] -> [(b, [a])]
08:32:17 <ksf> a formalist cannot prove anything about the universe, either.
08:32:48 <vixey> ksf, doesn't a formalist ask which universe? :)
08:32:53 <KoenigGunther> Parse a b is no Monad
08:32:59 <eyeris> Saizan I found it. I just thought it was a different application of `many` that was throwing the exception
08:33:22 <Philippa> right. So, issue #2: do us a favour and a) define what /you/ mean by "concrete representation" and b) accept that just /maybe/ there are other definitions when not using your - apparently inconsistent - axiom set
08:33:32 <ksf> the one I'm pinching them in :)
08:33:33 <lilac> KoenigGunther: Parse a looks like StateT [] a to me
08:33:42 <lilac> or rather StateT [] [a]
08:34:04 <Philippa> and 3) that goof about bounds? Yeah, that was plain sloppiness
08:34:26 <Philippa> you /may/ have an argument based on representation size, but guess what? You gotta define what is or isn't a representation first to make it
08:34:46 <KoenigGunther> I don't know what StateT is
08:35:51 <lilac> KoenigGunther: i'm not entirely sure i used it correctly
08:36:38 <ksf> I already defined concrete representation: Codeable and computable. Actually, I introduces "computable" into it from stopping formalists to code a term.
08:36:52 <ksf> grammar this sentence not.
08:37:15 <Philippa> ksf: those terms aren't defined in your setting
08:37:33 <ksf> it's a methodical/operational definition.
08:37:36 <Philippa> Codeable may as well be representable with you defining "computable ^ representable", FFS
08:37:36 <lilac> KoenigGunther: i think Parser is isomorphic to StateT [a] [], more accurately.
08:37:48 <Philippa> and with that, I'm gone. Truly, better things to do
08:37:57 <Philippa> because with the number of assumptions you bury? Screw that
08:38:09 <hugo___> thanks quicksilver and Saizan :) it works now
08:38:10 <lilac> KoenigGunther: so "Parser a" is a Monad for all a
08:38:10 <KoenigGunther> lilac: Ah, okay
08:38:27 <ksf> huh? I'm not using the term "representable". It's fuzzy.
08:38:46 <ksf> ...because it doesn't imply computable as much as codeable.
08:38:59 <KoenigGunther> lilac: I am not very familiar with Monads yet, since we just introduced them in class :)
08:39:04 <lilac> KoenigGunther: "StateT a" is a monad transformer. it's essentially a type-level function which transforms one monad into another.
08:39:19 <KoenigGunther> lilac: Okay
08:39:31 <lilac> if you're not comfortable with monads, we can look at implementing nTimes without them
08:39:48 <KoenigGunther> lilac: That would be awesome :)
08:40:13 <KoenigGunther> the description of the task says that it should be possible to construct nTimes by just using the given functions... i thought of a function like         nTimes n p = (list p) >*> (nTimes (n-1) p)       but then i get into trouble with the types
08:40:40 <lilac> you'll also need an nTimes 0 case so the recursion terminates.
08:41:04 <KoenigGunther> yes, my recursion terminates by the statement         nTimes 1 p = list p
08:42:18 <ksf> seems to me that you're trying hard not to get my meaning, or you wouldn't need to split hairs instead of providing definitions that make sense in your interpretation of vocabulary.
08:43:17 <lilac> KoenigGunther: doesn't 'list' accept a parser any number of times?
08:43:27 <ksf> denotations of words, are, after all, volatile.
08:46:08 <KoenigGunther> yes, it does...
08:46:21 <KoenigGunther> i think i should give you the whole task :) sec please
08:47:07 * ksf tries to construct a cube out of 5 tetrahedra by squishing four of them until they've got three right angles
08:47:09 <lilac> KoenigGunther: "nTimes 1 p = list p" looks wrong then
08:47:32 <eyeris> Is there a function in Parsec that returns all of the input consumed by a parser?
08:47:43 <vixey> eyeris, parse
08:47:43 <eyeris> as opposed to what the parser returns
08:47:48 <vixey> oh
08:47:53 <vixey> yeah not sure
08:48:13 <vixey> you could hook on a parser at the end and run parse
08:48:21 <vixey> one that just gloms everything and returns it
08:48:31 <vixey> but then you have the complement of what you were looking for
08:48:43 * ksf gotta read up about "allspace-fillingness"
08:49:28 <lilac> eyeris: i believe not. but you can take the input stream before and after parsec and search for the latter in the former.
08:49:56 <KoenigGunther> Define a function
08:49:56 <KoenigGunther>    nTimes :: Int -> Parse a b -> Parse a [b]
08:49:56 <KoenigGunther> nTimes n p is supposed to identify exactly n objects delivered by the parser. Example
08:49:56 <KoenigGunther>    nTimes 2 (token 'a') "abcdef"
08:49:56 <KoenigGunther>    []
08:49:57 <KoenigGunther>    nTimes 2 (token 'a') "aabcdef"
08:49:59 <KoenigGunther>    [("aa", "bcdef")]
08:50:24 <vixey> KoenigGunther, did you try what I suggested?
08:51:18 <wchogg> I'm still learning the FFI, but I've got a question:  I have a function that needs me to pass in the & of an array, so it has type blah**.  I've already malloc'ed on the Haskell side so I have a Ptr Blah, but how do I get that extra level of indirection?  Or am I totally thinking of this wrong?
08:52:01 <KoenigGunther> vixey: yes, I did, but I am struggling :)
08:52:35 <vixey> why?
08:52:37 <lilac> KoenigGunther: 0 seems a reasonable value for n, so I'd start with nTimes 0 p.
08:52:54 <lilac> KoenigGunther: so what should nTimes 0 p do?
08:53:28 <quicksilver> wchogg: you could malloc again on the haskell side, although that seems ugly.
08:53:43 <quicksilver> wchogg: why does the function need a **? what's it planning to do? presumably, change the pointer.
08:54:07 <KoenigGunther> ummm - nothing... It has to return a value of type Parser a [b], so I would suggest to return []
08:54:10 <wchogg> quicksilver:  That's a good question.  I've only looked at the .h so I don't know what it's doing under the hood.
08:54:21 <wchogg> quicksilver:  Maybe I'll take a deeper gander.
08:54:32 <KoenigGunther> or the defined none-type in the file
08:54:59 <lilac> KoenigGunther: what should (nTimes 0 (token 'a') "abcdef") return?
08:55:13 <quicksilver> wchogg: I mean, in principle you malloc a place for the Ptr to go and then you have a Ptr (Ptr (...))
08:55:18 <KoenigGunther> []
08:55:29 <quicksilver> wchogg: but you may need to take care not to lose the inner Ptr if it needs freeing.
08:55:34 <lilac> KoenigGunther: why? "abcdef" starts with at least 0 'a's...
08:55:58 <KoenigGunther> ah, okay
08:56:25 <KoenigGunther> ["", "abcdef"] in that case
08:56:31 <wchogg> quicksilver:  Yeah, that seems goofy because that doesn't seem to translate what '&' does, y'know?
08:56:40 <quicksilver> wchogg: it can't, can it?
08:56:45 <lilac> KoenigGunther: do you mean [([], "abcdef")] ?
08:56:47 <quicksilver> wchogg: haskell slots aren't mutable.
08:56:51 <quicksilver> wchogg: you can't take the address of them.
08:56:54 <KoenigGunther> sorry, yes
08:56:56 <quicksilver> (safely...)
08:57:04 <lilac> KoenigGunther: ok, so that's half of the problem done.
08:57:28 <quicksilver> wchogg: but you can use malloc to allocate a specifically mutable slot.
08:57:36 <quicksilver> wchogg: which C-land is now safely allowed to mutate.
08:57:46 <quicksilver> as long as its done synchronously.
08:58:00 <lilac> KoenigGunther: you should now be able to write down a definition of "nTimes 0 p = ..."
08:58:49 <KoenigGunther> lilac: okay this would be nTimes :: Int -> Parse a b -> Parse a [b]
08:58:49 <KoenigGunther> nTimes 0 p = succeed []
08:59:21 <lilac> KoenigGunther: excellent.
08:59:53 <lilac> KoenigGunther: so now, let's assume we've got (nTimes (n-1) p) working and we want to write (nTimes n p)
09:00:10 <wchogg> quicksilver:  Yeah, I see your point.  So this function is just meant to fill an empty but allocated array.  I'll try the second malloc & see what happens.
09:00:54 <lilac> KoenigGunther: if the parser is going to match the input n times, then it must match n-1 times followed by once more.
09:02:18 <KoenigGunther> lilac: Yes
09:02:36 <wchogg> man...I kind of wish you could define a Functor instance on Ptr
09:03:01 <quicksilver> :P
09:03:05 <KoenigGunther> lilac: I would then have to invoke p on the second argument of the last element of (nTimes (n-1) p)
09:03:07 <quicksilver> it's not a functor so that would be a bit odd.
09:03:24 <lilac> KoenigGunther: you could. but you already have a function to invoke one parser then invoke another
09:03:34 <lilac> KoenigGunther: and (nTimes (n-1) p) is a parser
09:03:49 <wchogg> quicksilver:  I know!  But I just wish I could use fmap for my transformations & ignore the rest.
09:04:03 <wchogg> There's no way that would work though.
09:04:32 <KoenigGunther> lilac: Okay, so I would have to invoke p and then (nTimes (n-1) p) by writing p >*> (nTimes (n-1) p
09:04:53 <p_l> Has anyone tried using http://darcs.haskell.org/packages/protocol-buffers/ ?
09:04:53 <lambdabot> Title: Index of /packages/protocol-buffers
09:06:41 <vixey> @seen jkff
09:06:42 <lambdabot> I saw jkff leaving #haskell 6h 58m 26s ago, and .
09:07:07 <lilac> KoenigGunther: ok, nearly there. what type would that have?
09:07:13 <KoenigGunther> lilac: I get the error *** Term           : nTimes
09:07:13 <KoenigGunther> *** Type           : Int -> Parse a b -> [a] -> [((b,[b]),[a])]
09:07:13 <KoenigGunther> *** Does not match : Int -> Parse a b -> Parse a [b]
09:07:13 <KoenigGunther> so I have to do something in between p >*> (nTimes (n-1) p)
09:07:53 <lilac> KoenigGunther: do you see what's going wrong?
09:08:13 <lilac> what's the type of p >*> (nTimes (n-1) p)?
09:09:48 <KoenigGunther> lilac: should be Parse a (b, [b])
09:10:34 <lilac> KoenigGunther: ok, and you want Parse a [b]
09:11:05 <lilac> so you need to map (b, [b]) to [b]
09:13:05 <KoenigGunther> lilac: ahhhhhh which I can do by doing nTimes n p `build` (uncurry (:))
09:14:22 <KoenigGunther> lilac: Thank you so much for your patience!
09:14:30 <KoenigGunther> lilac: It works :P
09:14:56 <lilac> KoenigGunther: glad to hear it :)
09:15:33 <rogerfretwell> \h
09:17:36 <KoenigGunther> lilac: It hasn't even been very complicated seeing it now :D Again - thank you very, very much! You made my day (I worked on this task for about three hours O_O)
09:20:43 <cknapp> Good day, everyone
09:22:01 <mmorrow> i just thought of a rule-to-go-by yesterday that i think makes sense and that i'm going to try to follow from now on: if it would take you the same amount of time/effort to write the code that can /generate/ the code to solve a particular instance of a problem as it would to write the code itself to solve that instance of a problem, then the choice of what code to write should /obviously/ be the meta-code
09:22:26 <quicksilver> mmorrow: indeed.
09:22:39 <mmorrow> (and even if you are only ever going to need code for that one particular instance)
09:22:49 <quicksilver> mmorrow: how long will it take you to write the code which figures out which will take more effort, of those two choices?
09:23:04 <quicksilver> (or is it better to generate the code to do that)
09:23:08 <mmorrow> quicksilver: heh
09:23:11 <ToRA|MSR> mmorrow: nono, always write the code for the specific instance the first time once.  the second time always write the meta code
09:23:11 <wchogg> quicksilver:  Just as a note, it looks like you were right & if I just use new on the malloc'ed array I get the extra pointer & it all works fine.
09:23:13 <mmorrow> generate it!
09:23:32 <ToRA|MSR> mmorrow: there are always unexpected things that come up, and having a grounded example helps no-end
09:23:33 <quicksilver> wchogg: yeeha!
09:23:41 <quicksilver> ToRA|MSR: I think that's probably quite subjective.
09:23:47 <quicksilver> ToRA|MSR: but I'm in your camp, personally.
09:23:56 <ToRA|MSR> quicksilver: i'm biased by clase-induced-pain
09:24:09 <mmorrow> ToRA|MSR: i dunno though, i find writing the meta-code to actually point out more of the unexpected things that could come up
09:24:22 <quicksilver> ToRA|MSR: heck, when presented with the challenge of understanding conal's Reactive, I chose to reimplement it as my learning path.
09:24:25 <mmorrow> since you have to think about /all/ situations when writing it, rather than just this one at hand
09:24:27 <ToRA|MSR> quicksilver: certainly having a grounded example to look at and to use as a test-base for the meta code is helpful
09:24:39 * ksf should use crayons instead of a pencil while sketching stuff
09:24:49 <quicksilver> ToRA|MSR: and when now presented with the (new) challenge of reimplementing reactive, I had to have a concrete program I wanted to make work, to write it for.
09:25:03 <mmorrow> definitely. this is all assuming writing the code and writing the meta-code would take the /same/ amount of effort/time/risk/whatever
09:25:20 <mmorrow> if that's not the case, then the decision becomes not so simple
09:25:24 <ToRA|MSR> mmorrow: ah ok
09:25:43 <vixey> oh
09:25:53 <vixey> mmorrow you know you wrote that generic folds
09:25:58 <vixey> in TH
09:26:00 <mmorrow> vixey: yes
09:26:04 <vixey> I found a Agda 2 version
09:26:13 <mmorrow> ooh, cool!
09:26:22 <mmorrow> link?
09:26:55 <mmorrow> here's a link to that Fold code if anyone's interested:
09:26:57 <ksf> vixey, would you have been able to construct it without existentially assuming its existence?
09:26:58 * mmorrow pastes it..
09:27:10 <ksf> (just curious)
09:27:34 <vixey> mmorrow, page 30 and on http://www.cs.chalmers.se/~ulfn/darcs/AFP08/LectureNotes/AgdaIntro.pdf
09:27:39 <lambdabot> Title: Dependently Typed Programming in Agda, http://tinyurl.com/6xshnb
09:27:44 <mmorrow> vixey: sweet
09:29:02 <quicksilver> Control.Operad!
09:29:03 <wchogg> mmm...dependent types
09:29:07 <wchogg> tasty
09:29:35 <leimy> is there a good example of coroutines laying around anywhere either using the Continuation monad or a coroutine monad constructed just for that purpose?
09:29:56 <leimy> I'm thinking it'd be nice for isolating IO to have coroutine capabilities.
09:33:00 <leimy> I guess even something like "generator" would be nice really
09:37:53 <wchogg> So...is hsc2hs deprecated?  Hackage shows that it fails to build for 6.8 & 6.10
09:38:08 <Igloo> It comes with GHC
09:38:18 <chipdude> Hm.  Does the world need another explanation for monads?
09:38:46 <wchogg> Igloo - Ah, so it's just that I don't need to build it seperately.  Okay.
09:39:17 <jsn> chipdude: yes?
09:40:20 <kynky> should the question be, when will the world not need another explanation
09:42:19 <leimy> kynky: the answer is now? :-
09:42:20 <leimy> )
09:42:51 <mmorrow> here's that Fold code + examples: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=541
09:43:06 <kynky> :)
09:43:55 <leimy> I've been thinking it might be the approach to describing those things as monads is what throws off the non-mathematically inclinded :-)
09:44:28 <leimy> a subset of the audience may do better just thinking of monads as a way to have a class off stuff that's bindable, returnable and sequenceable :-)
09:45:11 <Apocalisp> or joinable and mappable
09:45:25 <StoneToad> I don't think that would really change stuff
09:45:36 <StoneToad> that's like saying instead of talking about 2 we'll just talk about 1+1
09:45:45 <quicksilver> leimy: doesn't lazy evaluation give you generators for free?
09:45:51 <quicksilver> leimy: (and generators are the most common use of coroutines)
09:45:57 <leimy> StoneToad: You'd be surprised how much perspective gets you
09:46:03 <leimy> quicksilver: it does but the type system might bite you :-)
09:46:15 <vixey> type systems don't bite :)
09:46:17 <quicksilver> I suppose "inside-out-left-folds" are a more complex coroutine like thing.
09:46:28 * quicksilver shows vixey his 4-fingered left hand to disprove that point.
09:46:33 <vixey> eee
09:46:38 <leimy> ouch
09:46:42 <quicksilver> vixey: I got a bit fresh with ocaml -rectypes.
09:46:46 <conal> Beelsebob: ("<BeelsebobWork_> I wonder if conal forgot to bump the dependancy in the cabal file").  yes, i did.
09:46:48 <leimy> heh
09:46:49 <vixey> yeah I was guess that was a ML prototype
09:47:08 <Beelsebob> conal: yeh, I figured that after I updated TypeCompose and everything worked :)
09:47:19 <leimy> I guess what I'm thinking is I'd like to basically "talk to" a function that can grab IO String's for me, then spit back a string at me while I do my business.
09:47:24 <conal> Beelsebob: i'll make a new release in a few minutes
09:47:27 <leimy> like interact but with a lot more logic involved :-)
09:47:32 <Nafai> I'm learning Debian packaging at work; I should learn how to automate (or better automate) converting cabal packages to .debs
09:47:33 <quicksilver> conal: I want to talk to you about joinE but I have to go find a train. If you're still here when I'm on the train I'll find you.
09:47:39 <quicksilver> leimy: that sounds like an inside-out-left-fold, yes.
09:47:41 <conal> quicksilver: cool
09:47:45 <leimy> quicksilver: basically :-)
09:48:07 <mmorrow> quicksilver: hopefully it wasn't a thumb.  having an opposable digit is crucial!
09:48:20 <conal> Beelsebob: sometimes i read the logs and catch these remarks, but not always.  would you do me a favor and email me when such goofs come to light?
09:48:29 <Beelsebob> can do :)
09:48:35 <leimy> basically I want a generic IO function to either get me more data or bail out based on it's first parameter.
09:48:36 <conal> Beelsebob: or ask someone else to
09:48:39 <conal> Beelsebob: thx
09:48:47 <leimy> and then to re-call me if I asked for more data :-)
09:48:53 <leimy> I guess I might not need coroutines for that.
09:49:03 <leimy> even though they kind of are.
09:49:13 <conal> "<BeelsebobWork_> conal's changes last night introduced a *major* space/time leak for me"  --  do you have any idea what changes?  i don't.
09:49:37 <leimy> but it'd be nice to not have to know the name of the thing, and be able to use a continuation return function with that parameter.
09:49:40 <Beelsebob> conal: oh, that turned out to be me -- I'd accidentally turned on -auto-all on Fieldtrip
09:49:54 <leimy> and based on the continuation return, that'd be the request for more or "I'm done".
09:49:57 <Beelsebob> so it was writing crazy amounts of profile
09:50:06 <leimy> hmmm, maybe too much callCC
09:50:09 <conal> Beelsebob: oh!  okay.
09:50:11 <dcoutts> Nafai: the linspire folks have written some excellent tools for translating cabal packages to debs
09:50:28 <mmorrow> leimey: i've found this function to be useful for similar things (although looks like you'd need its monadic counterpart):
09:50:30 <mmorrow> mutual :: (a -> (b -> s) -> r) -> (b -> (a -> r) -> s) -> a -> r
09:50:30 <mmorrow> mutual f g a = f a (\b -> mutual g f b)
09:50:38 <dcoutts> Nafai: I think they automated the whole thing
09:50:57 <dcoutts> Nafai: check the mailing lists, I think all their code is available
09:51:00 <mmorrow> @let mutual f g a = f a (\b -> g b (\a -> mutual f g a))
09:51:01 <lambdabot>  Defined.
09:51:12 <Nafai> dcoutts: Thanks for the info
09:51:15 <mmorrow> (you need to define it that way if you're not providing a type sig)
09:51:50 <mmorrow> (to get ghc to infer the type in the generality you want)
09:52:24 <mmorrow> so with mutual you can get:
09:52:26 <mmorrow> unfoldr f = mutual (\a k -> (k . f) a)
09:52:26 <mmorrow>                    (\m k -> maybe [] (\(b,a) -> b : k a) m)
09:52:31 <mmorrow> etc
09:52:54 <ski_> leimy : istr i did a laboration where we used `ContT' to simulate threads (using `yield' to switch context) .. that anything like what you meant ?
09:53:23 <wchogg> Oh #*(!...I'm getting /usr/local/lib/ghc-6.10.1/hsc2hs-0.67/template-hsc.h:4:19: error: HsFFI.h: No such file or directory when I try to run hsc2hs & I haven't found an easy answer.  Anyone hit this before?
09:54:35 <leimy> ski_: that sounds pretty close to the sort of thing I'm thinking of.  Like "green threads"
09:55:04 <Botje> green threads don't pollute the environment!
09:55:06 <ski_> (the laboration was for turtle graphics .. like <http://www.mdstud.chalmers.se/~md9slj/BellFlower.png> and <http://www.mdstud.chalmers.se/~md9slj/Tree.png>)
09:55:17 <mmorrow> leimy, ski_: yeah ContT is cool
09:55:24 <leimy> ContT is very cool
09:55:28 <leimy> I used it wrapped around IO
09:55:32 <leimy> for my ugly bowling program
09:55:38 <mmorrow> heh
09:56:14 <Zero_In_Mood> hi guys i got a lil problem with a program may someone would be so nice and help me ? :)
09:56:22 <leimy> well bowling is an example of interactive output that terminates in an unpredictable time.
09:56:26 <leimy> or input
09:56:46 * ski_ . o O ( ReaderT Resolution (StateT SnailState (StateT [Thread] (ContT () IO))) a )
09:57:01 <mmorrow> @unmtl ReaderT Resolution (StateT SnailState (StateT [Thread] (ContT () IO))) a
09:57:01 <lambdabot> Resolution -> SnailState -> [Thread] -> (a -> SnailState -> [Thread] -> IO ()) -> IO ()
09:57:06 <Beelsebob> ski_: ewwwwwww
09:57:16 <ski_> (.. with `newtype Thread = T ([Thread] -> IO ())')
09:57:20 <ski_> Beelsebob : how so ?
09:57:44 <Beelsebob> ski_: the amount of nasty nasty stateful stuff
09:57:56 <ski_> Beelsebob : originally we wrote the code using it, without monad transformers .. *that's* "ewww"
09:57:58 <mmorrow> Resolution -> SnailState -> [Thread] -> (a -> SnailState -> Thread) -> IO ()
09:58:33 <ski_> (i.e. without any custom monad at all)
09:58:37 <Zero_In_Mood> well i ll just ask (sry for my bad english)
09:58:38 <Zero_In_Mood>  well i just ask it in this room and check every few mintues.. would be pretty nice :)
09:58:38 <Zero_In_Mood>  the task is to make out of a string a data tree.. the treeis selcted like this: data VTree = S | W |V VTree VTree VTree Vtree
09:58:38 <Zero_In_Mood>  so.. the beginning is quite okay but in the end it ll be hard. i found a way how to do it for simpe examples
09:58:38 <Zero_In_Mood>  like "S", "W" or "VSWSW"
09:58:40 <Zero_In_Mood> but if "V" got another "V" in it.. so Tree in Tree it wont work and stopp.. my program is looking like this :
09:58:43 <Zero_In_Mood>  preToVt :: String -> VTree
09:58:45 <Zero_In_Mood>  preToVt "S" = S
09:58:47 <Zero_In_Mood>  preToVt "W" = W
09:58:49 <Zero_In_Mood> preToVt r = ( V (preToVt (r!!4:"")) (preToVt (r!!3:"")) (preToVt (r!!2:"")) (preToVt (r!!1:"")) )
09:59:33 <Saizan> Zero_In_Mood: use a pastebin next time, please.
09:59:53 <mmorrow> i think a TH lib that takes a Type as input (analogously to @unmtl) and derives the corresponding flattened type, then newtype wraps it + generates instances of Monad and Functor for it (along with whatever other mtl monad classes it should) + convenience functions (runFoo, etc) for the new flat newtype would be an /awesome/ly useful application of TH
10:00:14 <Zero_In_Mood> how can i Saizan ? sry im new here.
10:00:19 <mmorrow> and it would make for much faster code too
10:00:34 <Saizan> @paste
10:00:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:01:06 <Saizan> Zero_In_Mood: you click on that link and paste the code there, and paste back the url in channel
10:01:08 <mmorrow> ie look at (>>=) in the Monad instance for RWS vs. what is going on in ReaderT r (WriterT w (State s)) a
10:01:18 <mmorrow> RWS crushes in efficiency
10:01:32 <lilac> Zero_In_Mood: as a hint, think about writing preToVt :: String -> (VTree, String) where the return value also gives the rest of the (unparsed) string
10:02:36 <Zero_In_Mood> no aint allowed lilac.
10:03:07 <Zero_In_Mood> http://hpaste.org/12691
10:03:09 <Zero_In_Mood> eati nfor a sec
10:04:35 <lilac> Zero_In_Mood: are you allowed to write a helper function of that form?
10:05:16 <mmorrow> <leimy> well bowling is an example of interactive output that terminates in an unpredictable time.
10:05:22 <leimy> yes
10:05:30 <leimy> and interactive input :-)
10:05:35 <leimy> frames can end early
10:05:39 <leimy> or late in the case of the 10th
10:05:42 <mmorrow> that reminds me of dolio's use of ContT recently in some code the solve the Knights thing
10:05:56 <mmorrow> s/the/to/
10:05:56 * leimy digs up his nasty code and  pastes it
10:06:44 <leimy> http://paste.lisp.org/display/71586
10:06:48 <leimy> hpaste truncates my paste
10:07:06 <leimy> bowlFrame is pretty ugly :-)
10:08:08 <leimy> in all honesty... I was just happy I figured out how to express something as complex as bowling at all in Haskell
10:08:23 <leimy> actually in *any* language.
10:08:24 <mmorrow> dolio's is solution2 at http://haskell.org/haskellwiki/The_Knights_Tour
10:08:30 <lambdabot> Title: The Knights Tour - HaskellWiki
10:08:36 <leimy> it's difficult to describe in english
10:09:21 <leimy> LogicT is pretty awesome looking
10:09:24 <mmorrow> leimy: i have an instance of hpaste2 running here that allows pretty huge pastes: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
10:09:31 <leimy> oh cool
10:09:38 <olsner> hmm, return $ liftIO $ return == return?
10:09:50 <leimy> Hah Oleg's solution was > 1 line of code.
10:10:12 <mmorrow> heh
10:10:17 <leimy> but it is pure
10:10:57 <mmorrow> lunabot has LogicT in scope if anyone is interested in playing with it..
10:11:08 <leimy> neaty
10:11:09 <mmorrow> , [0..] `interleave` [1000..]
10:11:10 <leimy> erneat
10:11:23 <mmorrow> lunabot has to wakeup
10:11:23 <lunabot>  [0,1000,1,1001,2,1002,3,1003,4,1004,5,1005,6,1006,7,1007,8,1008,9,1009,10...
10:11:45 <mmorrow> (bot is running on a hosted webserver that's probably in a VM or something)
10:11:52 <leimy> , [0..] `zip` [1000..]
10:11:55 <lunabot>  [(0,1000),(1,1001),(2,1002),(3,1003),(4,1004),(5,1005),(6,1006),(7,1007),...
10:11:57 <leimy> ah!
10:11:59 <leimy> right
10:12:04 <quicksilver> conal: so, I may have reproduced the hang you reported in my joinE definition.
10:12:10 <quicksilver> conal: or something related, at any rate.
10:12:28 <mmorrow> , foldr interleave [] (tails [0..])
10:12:31 <lunabot>  [0,1,1,2,2,2,3,3,4,3,5,3,6,4,7,4,8,5,9,4,10,6,11,4,12,7,13,5,14,8,15,5,16...
10:12:31 <quicksilver> my joinE works fine for me in simple cases, but recursive snapshots hang.
10:12:48 <quicksilver> and I am presuming this is somehow related.
10:14:05 <araujo> hello
10:15:27 <mmorrow> lunabot does private msgs too (and'll return up to 32 lines therein instead of the 3 it'll do in-channel)
10:16:08 <chipdude> jsn: ah, my network troubles are solved
10:16:28 <chipdude> so I have a heavy background in C and a medium background in compilers, and here's my epiphany:
10:16:37 <chipdude> a monadic value represents a sequence point
10:16:59 <Twey> Yup
10:17:43 <leimy> yeah, that's an excellent way to think of it.
10:18:07 <quicksilver> what is a sequence point?
10:18:08 <chipdude> <grin> yay
10:18:35 <leimy> quicksilver:   what's not here "c = a + c++;"
10:18:40 <chipdude> quicksilver: a sequence point is an event of a guarantee that previous side effects will be visible
10:19:14 <leimy> also not here
10:19:15 <chipdude> there is a sequence point between evaluating left and right of &&, but not &
10:19:21 <leimy> foo(c++, c++, c++);
10:19:40 <leimy> = is not a sequence point :-)
10:19:41 <quicksilver> chipdude: yes. That's quite true although for a very general sense of "side-effect" indeed.
10:19:43 <leimy> the comma operator is :-)
10:19:51 <thief_grr> Trying to write a function that will find the position that a string occurs inside another string.  e.g. find "ba" "foobar" = 3
10:19:56 <leimy> but the , in a function call is not.
10:20:03 <quicksilver> chipdude: but some familiar monads have familiar notions of sequence point.
10:20:28 <thief_grr> what do you think is a good return value when the first string does not occur anywhere in the second?
10:20:31 <chipdude> quicksilver: well, sequence points never create side effects, they merely _order_ them, and I believe the same can be said of monadic value prodution
10:20:48 <quicksilver> chipdude: yes, but what you are ordering is something quite general.
10:21:27 <quicksilver> chipdude: the monadic notion of "side effect" is a much more general notion of effect than you get from the analogy with compiling C.
10:21:30 <chipdude> quicksilver: yes, _but_, if there are no side effects then ordering is not important, so any ordering of things that do not produce side effects may not occur and you'd never know
10:21:36 <quicksilver> it's a good analogy.
10:21:50 * chipdude <- often reasons by analogy, so yay
10:21:54 <quicksilver> for example in the list monad, the "side effect" is the accumulation of multiple results.
10:22:02 <quicksilver> that's a strange notion of "side effect" really ;)
10:22:12 <mmorrow> chipdude: in your analogy.. it's just a coincidence though that IO is a Monad, ie "side-effect" for a Monad in general wouldn't necessarily be a "real" side-effect
10:22:21 <chipdude> hm.
10:22:30 <leimy> yeah it's not universally true
10:22:39 <quicksilver> but it remains a sound intuition.
10:22:46 <leimy> but if you're dealing with side effects, getting stuff out of a monad is at a point of sequence
10:22:56 <mmorrow> but for "some generalized definition of side-effect" yeah, that analogy i'd say works
10:22:56 <quicksilver> just be prepared to embrace slightly weird senses of 'side effect' if you want to generalise to all possible monads.
10:22:57 <leimy> and never in between.
10:23:00 <leimy> so you're "safe" there :-)
10:23:43 <leimy> I just had to debug a coworkers code that worked great on windows in C with the same C compiler but not on linux due to a sequence point side-effect issue.
10:24:09 <quicksilver> leimy: clearly both compilers are broken ;)
10:24:21 <chipdude> leimy: pet peeve: it was gcc vs. msvc, not Linux vs. Win
10:24:37 <quicksilver> leimy: they should both have failed to compile the code and signalled that the sequencing was ambiguous.
10:24:41 <chipdude> and yeah, that'll happen.  "Try it and see" is almost always the wrong answer WRT C
10:24:51 <leimy> chipdude: gcc on windows vs gcc on linux
10:24:59 <leimy> different interpretation of that undefined code.
10:25:09 <chipdude> leimy: different versions?  different optimizaiton flags?  different CPUs?
10:25:10 <Lemmih> @tell thoughtpolice haskell-src-exts-0.4.4 is out. Do you have time to replace HsParser.y with it?
10:25:11 <lambdabot> Consider it noted.
10:25:17 <leimy> chipdude: same CPU
10:25:21 <leimy> different version of gcc
10:25:38 <leimy> and the compiler didn't warn about the undefined behavior, likely due to not using any warning flags :-)
10:25:46 <lilac> quicksilver: recursive snapshot is known to be broken
10:25:56 <chipdude> quicksilver: C's aliasing rules don't always allow that.        foo(++*p, ++*q);   // defined?  yes, unless p==q
10:26:16 <leimy> right
10:26:30 <leimy> though I'd NEVER write that code :-)
10:26:35 <chipdude> C is a good portable assembler but it does have its flaws
10:26:45 <leimy> anyone incrementing shit on the way to a function's argument should be punched in the face as hard as possible.
10:26:56 * chipdude uses ironic understatement and self-reference
10:27:05 <chipdude> Hehe
10:27:16 <leimy> C is debatably a good portable assembler
10:27:24 <leimy> I think it was designed for the PDP :-)
10:27:25 <luite_> leimy: I once did that in some compression code, so my compressed file became compiler-dependent
10:27:28 <chipdude> I wouldn't hire you to write C, then.  But that's a good attitude for other tasks
10:27:42 <leimy> oof.
10:27:50 * leimy used to do TONS of C and C++
10:27:58 <leimy> luckily I'm in Erlang most of my days now.
10:28:09 <leimy> trying to get some haskell in there too
10:28:12 <leimy> but it's tricky
10:28:15 <orbitz> i hope i never apply to a C job
10:28:24 <leimy> I'm surprised I got people to let me do Erlang :-)
10:28:24 <chipdude> C shouldn't be written by humans any more, IMO
10:28:35 <orbitz> chipdude: i'll agree to taht
10:28:35 <chipdude> Except for operating systems and other bare-metal stuff
10:28:47 <leimy> FFI only :-)
10:29:03 <lilac> C has its place in certain circumstances. when you want the machine to do something very specific at a very low level...
10:29:05 <leimy> actually one of my coworkers gets C libraries and always writes code to them in python using their FFI
10:29:26 <leimy> which I always found to be pretty smart in the long run but seemed really weird at first.... though I'm not a huge python fan.
10:29:31 <orbitz> hi
10:30:00 <lilac> orbitz: i think you need a sequence point after your 'hi'.
10:30:05 <leimy> heh
10:30:09 <lilac> it appears to have been evaluated out of order
10:30:15 <leimy> put "hi"
10:30:29 <orbitz> lilac: layouts man, new line!
10:30:32 <leimy> hmmm
10:30:35 <leimy> tell "hi"
10:30:36 <leimy> ?
10:30:45 <orbitz> > putStrLn "hi"
10:30:46 <chipdude> He says, he can shout; don't hear you
10:30:47 <lambdabot>   * Exception: "<IO ()>"
10:31:08 <quicksilver> lilac: I'm writing my own implementation.
10:31:30 <ski_> mmorrow : what's a "real" side-effect ?
10:31:47 <orbitz> getting hot in the thigh
10:31:55 <chipdude> ski_: ask Shroedinger's cat
10:32:03 <quicksilver> chipdude: C doesn't give you access to the carry bit (and similar). That disqualifies it from 'good portable assembler' for me.
10:32:52 <Peaker> conal: Heap profile of the pune (worm thing): http://img98.imageshack.us/img98/5985/punesq8.jpg
10:33:18 <chipdude> quicksilver: the C virtual machine is missing useful features that are basically universal at this point, I'll grant you that
10:33:22 <leimy> pune?
10:33:29 <leimy> is that like pwn?
10:33:29 <Peaker> leimy: do you know that game?
10:33:30 <chipdude> I think C's due for replacement now
10:33:31 <Elly> "C virtual machine", heh :P
10:33:38 <Peaker> leimy: no, its an awesome game from the early 90's
10:33:40 <leimy> Like "it has pwntential"?
10:33:46 <leimy> Hmm maybe not :-)
10:33:58 <quicksilver> chipdude: has any machine had an ALU withou a carry bit or overflow bit or similar? I guess my processor history is fairly weak.
10:33:59 <ozy`> > let x y = x' y where x' y' = show y' in x "dude"
10:34:01 <lambdabot>   "\"dude\""
10:34:08 <ozy`> damn I messed up
10:34:25 <conal> Peaker: nice!  what's the yellow cost center?
10:34:43 <Peaker> conal: let me start by saying it got me to compile the entire world with -p :-)
10:34:43 <vixey> > iterate show "dude"
10:34:45 <lambdabot>   ["dude","\"dude\"","\"\\\"dude\\\"\"","\"\\\"\\\\\\\"dude\\\\\\\"\\\"\"","\...
10:35:04 <conal> Peaker: was -p a hassle?
10:35:10 <ozy`> vixey: that works :p
10:35:25 <chipdude> quicksilver: I only know a bit of 6502, some of the 68x series, Z80/8080 by heart, and most of x86.  The more obscure things like microcontrollers and DSP have evaded me, let alone modern stuff like ARM
10:35:28 <Peaker> conal: well, the libs have a big dependency tree, and cabal-install does not have a feature (afaik) to recompile a whole dependency tree with an option
10:35:30 <leimy> bowling scores was the only application I could think of for "scanl" :-)
10:35:41 <Peaker> conal: and apparently the "process" bug I had is actually due to category-extras depending on "ghc" as if it was a package
10:35:51 <conal> Peaker: cabal feature request!  sounds like a pita without
10:35:52 <quicksilver> conal: let r = 0 `Stepper` (snapshotWithR (+) r mempty) in r
10:36:05 <chipdude> quicksilver: all the ones I know of have traditional carry and zero bits
10:36:11 * Peaker finds cabal-install's trac
10:36:18 <chipdude> (though the setting of the bits can vary)
10:36:25 <Peaker> conal: did you check out what the trac problem with highlighting patches was?
10:36:27 <conal> Peaker: just a minute ...
10:36:43 <quicksilver> chipdude: yup. And with them, you can implement reasonably efficient n*2 bit arithmetic on an n bit machine. Without them it's a nightmare.
10:36:45 <chipdude> For example, in the 6809, there were two ways to do addition.  If you add into the accumulator(s) you get carry and zero; if you use the LEA instructions to do it, you don't
10:36:56 <conal> Peaker: "highlighting patches"?
10:36:57 <quicksilver> chipdude: that's always bugged me about C :)
10:37:05 <chipdude> quicksilver: it's a fair cop, truly
10:37:07 <Peaker> conal: it has syntax highlighting for .diff/.patch files
10:37:39 <Peaker> conal: I re-attached the patch with a .patch extension in ticket #14, but it spews an error message which is probably reflected in some trac log
10:37:45 <ttt--> hi, i dont understand this code from mu-eval ... http://hpaste.org/12693  It seems to kill the "mainId" thread, but not the "forkIO $ interpreter" thread..  is that normal?
10:37:55 <conal> Peaker: i didn't see anything
10:38:10 <ski_> (chipdude : tsx  sta $0100,x  dex  tya  sta $0100,x  dex  txs)
10:38:30 <lilac> Peaker: that 'reinstall all with -prof' thing is a PITA. definitely worth filing a cabal bug :)
10:38:58 <quicksilver> although just for the records, -hT works without rebuilding. and -hT is pretty nifty.
10:39:04 <ttt--> If i replace the "forkIO $ interpreter.." with an endless IO action, it just keeps running
10:39:24 <conal> Peaker: about category-extras, if you think there's a usability problem, would you please contact ed kmett about it?
10:39:34 <Peaker> conal: Saizan told me that he already has
10:39:41 <conal> great.
10:39:51 <Peaker> conal: but I got a lot of confusing errors trying to upgrade reactive that turned out to be because of that
10:39:58 <yitz> leimy: http://hpaste.org/12694
10:40:56 <conal> quicksilver: oops -- my "Peaker: just a minute ..." was meant for you.
10:41:54 <leimy> yitz: That assumes you've got the whole game bowled?
10:41:59 <Peaker> conal: http://twistedmatrix.com/trac/changeset/25510  that's what trac's patch highlighting looks like
10:42:03 <lambdabot> Title: Changeset 25510 ‚Äì Twisted
10:42:28 <leimy> my goal was to give live updates of the bowling score while the bowling was going on.
10:42:34 * leimy will post output in a moment
10:42:34 <quicksilver> conal: I guessed ;)
10:42:36 <Peaker> conal: http://trac.haskell.org/reactive/attachment/ticket/14/reactive-snapshot-patches.patch  should look like that, but instead it invokes some kind of problem, are you sure you can't see any error in any trac log when you browse there?
10:42:38 <lambdabot> Title: #14: reactive-snapshot-patches.patch - reactive - Trac, http://tinyurl.com/6qpqco
10:43:02 <conal> Peaker: i don't know how to look at trac logs
10:43:45 <conal> Peaker: i wonder if *any* code.haskell.org tracs handle patch highlighting correctly.
10:44:04 <conal> Peaker: i'd love to get it fixed.  that highlighting is great
10:44:16 <yitz> leimy: no, just that you've given it complete frames, plus trailing balls for strike and spare at end.
10:44:37 <leimy> yitz: oh I see
10:44:38 <leimy> http://paste.lisp.org/display/71586#1
10:44:47 <Zero_In_Mood> lilac oh sorry yes i can write helper functions... sry roommate cooked n had to eat^^
10:44:52 <Peaker> conal: what is the trac server? any chance of ssh access?
10:45:06 <conal> Peaker: it's code.haskell.org
10:45:19 <conal> Peaker: anyone can get an account there
10:46:26 <conal> Peaker: what's that yellow cost center in http://img98.imageshack.us/img98/5985/punesq8.jpg
10:46:58 <yitz> leimy: so you could do that if you remove the error on trailing strike and spare, check that separately after the last frame.
10:46:59 <conal> Peaker: it looks like there's only one leak.  or only one large one.  which is great.
10:47:13 <leimy> yitz: ah
10:48:04 <yitz> leimy: of course, it recomputes the whole game so far every time. ok for bowling, but doesn't generalize to more expensive things.
10:48:15 <yitz> leimy: but it's simple and clear.
10:48:28 <leimy> Mine recomputes the whole game each time too
10:48:41 <leimy> because I knew it'd be small and not a big deal :-)
10:48:41 <Peaker> conal: I'm new to profiling...
10:48:54 <yitz> leimy: ok. to avoid that, you have to keep state of course.
10:48:56 <Peaker> conal: the .hp file is already truncated, it seems
10:48:58 <leimy> right
10:49:06 <conal> Peaker: oh, urg.
10:49:09 <leimy> that part wasn't as interesting :-)
10:49:28 <yitz> leimy: which part?
10:49:49 <ozy`> I have begun to despise top-level pattern-matching in function definitions... the wall of vertically aligned copies of the function name makes it so much harder to read
10:50:00 <leimy> yitz: avoiding recomputing the score over and over... I did not think that was really that interesting.
10:50:21 <leimy> But the exercise left me with a desire to have a more controlled and isolated IO component.
10:50:36 <leimy> hence my desire for "green threads" coroutines, or a generator like thing :-)
10:50:38 <lilac> Zero_In_Mood: what's your strategy for solving this problem?
10:50:40 <yitz> leimy: it would be interesting if you needed it :)
10:51:16 <leimy> I guess.
10:51:25 <Zero_In_Mood> dunno tried several things like looking from the end of the strign n working from the back...didnt work..
10:51:25 <leimy> It's not really needed, but I thought it'd be fun to try.
10:51:51 <Zero_In_Mood> now this.. and i like this idea atm the best... but still it aint fit with the undertree problem.. :(
10:52:14 <conal> would someone with Haskell/GHC profiling experience take a look at http://img98.imageshack.us/img98/5985/punesq8.jpg ?  I'd like to know what the names in the right column are telling us.
10:52:15 <leimy> the fun in Haskell, is the composing of little purposeful pieces, and my bowling app is not that way :-)
10:52:19 <Zero_In_Mood> but im out of ideas to solve it and neither can come up with another algorithm
10:52:45 <conal> and whether Peaker can get the full description somehow
10:52:59 <leimy> of course conal's reactive programming research is also something that seems like it'd be able to help me isolate the IO :-)
10:53:14 <Peaker> does the Haskell lexer have a maximal line length or such?
10:53:32 <conal> Peaker: i wonder if the description is a stack of entrypoint names, innermost first.
10:53:42 <yitz> ttt--: does the "endless IO action" yield every once in a while?
10:53:58 <conal> Peaker: maybe there's a profiling flag to control truncation.  we're losing a lot of context here.
10:55:01 <Peaker> conal: yay, I have ssh access, where are the trac logs?
10:55:08 <Peaker> conal: I'll look at the RTS options
10:55:25 <ttt--> yitz, it just kills the mainId thread, but another thread is already forked which keeps running
10:55:28 <conal> Peaker: all of the trac stuff is under /srv/trac
10:55:33 <yitz> leimy: yeah, you keep the UI to just UI, and keep the game logic pure
10:55:43 <lilac> Zero_In_Mood: ok. one thing you can observe is that what you want to do within a V is basically to run your algorithm again four times.
10:55:52 <yitz> ttt--: another thread?
10:55:58 <lilac> Zero_In_Mood: except you want each of those to start where the previous one finished
10:56:28 <ttt--> yitz, yeah. another forkIO is done on "forkIO $ interpreter..."
10:57:06 <yitz> ttt--: oh, yes. so you want to kill that also.
10:57:16 <ttt--> yitz, i think killing mainId just takes down the entire ghc process in mu-eval, so it doesnt matter
10:57:28 <leimy> yitz: that's the beauty of Haskell :-)
10:57:34 <leimy> I considered bowlFrame game logic
10:57:42 <leimy> but also UI
10:57:50 <ttt--> i need some erlang beauty too
10:58:03 <Zero_In_Mood> yeah i wanna run the algorithm four times again.. but may line only fits the simpliest case.. just now i have to find how to divide the string so it ll fit  the worst case with many V`s too.. the point is with !! i ll just get one char not 5 chars but i need 5 chars if its a V on that position... i guess
10:58:08 <leimy> the scoreFrame function I had just boils everything down to all the scenarios for each kind of frame and frame #
10:58:21 <leimy> and I find it easy to lookup what's happening at any point in the crappy looking style I wrote
10:58:27 <yitz> ttt--: right. that's what happens when you run it outside mueval. but in mueval it keeps going?
10:58:34 <leimy> your version is much cleaner looking however.
10:58:44 <leimy> mine looks like a giant case statement :-)
10:58:49 <conal> Peaker: i tried to turn on logging, but got a server error.  probably the same permission problem as earlier.
10:59:05 <conal> Peaker: i'll email the c.h.o support guys.  sigh.
10:59:16 <yitz> leimy: you can look up each case in mine also.
10:59:44 <leimy> yitz: I was having difficulty
11:00:05 <Peaker> conal: how do you turn it on?
11:00:14 <leimy> I mean I see that scoreFrame (10:b2:b3:_) is there
11:00:22 <yitz> leimy: the idea is that there are two notions of frame really - the balls that were rolled in the frame, and the balls that contribute to the frame's score.
11:00:23 <leimy> but that should only ever happen if it's the 10th frame
11:00:43 <yitz> leimy: no, any time there is a strike
11:00:48 <leimy> oh I see
11:00:51 <leimy> duh :-)
11:00:53 <leimy> that's the strike rule
11:00:58 <leimy> I don't know what I was thinking
11:01:00 <conal> Peaker: the trac admin web UI
11:01:14 <conal> Peaker: i'm cc'ing you on my c.h.o note
11:01:58 <Peaker> conal: ok, sure
11:02:13 <Peaker> conal: the permissions do seem a bit screwy in there
11:02:50 <conal> Peaker: definitely
11:03:08 <lilac> Zero_In_Mood: when you see a V, you want to run the algorithm 4 times, but you want each to start where the previous one finished.
11:03:16 <lilac> Zero_In_Mood: can you somehow work out where the previous one finished?
11:03:48 <conal> Peaker: email sent.
11:04:02 <Zero_In_Mood> hmm.. work out where the previous one finished ?!
11:04:30 <Zero_In_Mood> so u mean a case like "V W S W V W W S S" !?
11:04:47 <Peaker> conal: ah, its the config file saving itself that seems to be failing
11:05:12 <lilac> Zero_In_Mood: suppose we see "VVSSSSVWWWWSW". we need to know where the "VSSSS" finishes to parse the next bit.
11:05:34 <Zero_In_Mood> hmm
11:05:39 <conal> Peaker: yeah.
11:05:48 <Zero_In_Mood> 4 positions after the V
11:05:51 <Peaker> conal: do you know the uid/gid of the trac server (probably apache)? not www-data?
11:06:10 <conal> Peaker: would you mail c.h.o support about .patch highlighting?
11:06:23 <conal> Peaker: "ls -lt /srv/trac"
11:06:50 <lilac> Zero_In_Mood: right. suppose we made our parser tell us how far it had got.
11:06:54 <conal> Peaker: makes it pretty clear
11:07:21 <czShadoW> What about GHCi and Unicode? If I try to enter some UTF-8 string, it's escaped or something.
11:07:27 <czShadoW> > "≈Ωj≈Ø!"
11:07:29 <lambdabot>   "\381j\367!"
11:07:32 <conal> Peaker: haskeline is the one exception to the pattern.
11:08:14 <BobFunk> trying to install kibro, but getting an error, and no hits on google
11:08:23 <Peaker> conal: btw: The patch is on the reactive trac, not the FieldTrip trac, right?
11:08:33 <BobFunk> anybody knows what 'unsupported extension: PostfixOperators' means?
11:08:33 <Zero_In_Mood> well if the parser would tell us how far he got we could tell him how much are missing til finish  or well when a new V is started
11:08:54 <thoughtpolice> BobFunk: postfix operators are an extension, but before ghc 6.10.1, they are always on by default
11:08:55 <conal> Peaker: yes.
11:08:55 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
11:09:10 <thoughtpolice> with ghc 6.10.1, you now have to tell ghc it can use postfix operators by providing an '-XPostfixOperators' flag or something
11:09:17 <Peaker> conal: you tried changing the config on the FieldTrip trac, but the gid of the config file is FieldTrip-p<something> not www-data
11:09:29 <yitz> czShadoW: each Char in a String is UTF-16, not UTF-8.
11:09:29 <BobFunk> thoughtpolice: hmm - I'm compiling with ghc-6.8.2
11:09:31 <thoughtpolice> BobFunk: I take it you don't have 6.10.1?
11:09:32 <thoughtpolice> yeah
11:09:51 <conal> Peaker: oh -- i tried logging on the wrong trac.  lucky thing, since it revealed this problem.
11:09:55 <Peaker> conal: can you try enabling logging in the reactive one?
11:09:56 <yitz> czShadoW: the Show instance of String escapes anything that is not ASCII.
11:09:58 <conal> Peaker: i'll try reactive logging now.
11:10:07 <Peaker> conal: yeah, you can use: chgrp www-data /srv/trac/FieldTrip/conf/trac.ini
11:10:29 <lilac> thoughtpolice: PostfixOperators: is that left slices of unary operators?
11:10:47 <yitz> czShadoW: if you want to do UTF-8 stuff, use one of the UTF-8 encoding libraries from hackage.
11:10:47 <lilac> > let (0!) = 1; (n!) = n * (n-1!) in (10!)
11:10:48 <lambdabot>   <no location info>: Parse error in pattern
11:10:58 <thoughtpolice> lilac: I believe
11:11:02 <czShadoW> yitz: Oh, interesting, thanks.
11:11:29 <lilac> > let (!) 0 = 1; (!) n = n * ((n-1)!) in (10!)
11:11:31 <lambdabot>   3628800
11:11:43 <conal> quicksilver: sry taking so long
11:11:48 <thoughtpolice> @tell Lemmih I have a bunch of work to do today and until Saturday but over the weekend I'll take a stab at it
11:11:49 <lambdabot> Consider it noted.
11:12:02 <conal> Peaker: turned on logging for the reactive trac.  will try that chgrp next
11:13:11 <lilac> yitz: is it really UTF-16? I thought it was full unicode?
11:13:14 <BobFunk> thoughtpolice: so any idea on how I can get a simple: 'cabal install kibro' to not run into this problem?
11:13:14 <Peaker> conal: nothing goes to the log indeed
11:13:23 <Peaker> conal: you set warning level, can you set debug level?
11:13:28 <lilac> > '\1112111'
11:13:30 <lambdabot>   '\1112111'
11:13:43 <conal> Peaker: done
11:13:59 <ozy`> > read "\1112111"
11:14:01 <lambdabot>   * Exception: Prelude.read: no parse
11:14:09 * ozy` plots
11:14:16 <olsner> > read "\"\1112111\""
11:14:17 <lambdabot>   * Exception: Prelude.read: no parse
11:14:18 <lilac> > length "\1114111"
11:14:19 <lambdabot>   1
11:14:19 <wchogg> conal:  Did you get to see my last e-mail, about ODE's?
11:14:24 <olsner> > read "\"\1112111\"" :: String
11:14:26 <lambdabot>   "\1112111"
11:14:47 <ozy`> > read "\1112111" :: String
11:14:48 <lilac> > read "\"\1114112\"" :: String
11:14:49 <lambdabot>   "* Exception: Prelude.read: no parse
11:14:50 <lambdabot>   <no location info>:
11:14:50 <lambdabot>      lexical error in string/character literal at chara...
11:14:59 <ozy`> psh
11:15:03 <lilac> > read "\"\\1114112\"" :: String
11:15:04 <lambdabot>   "* Exception: Prelude.read: no parse
11:15:08 <lilac> > read "\"\\1114111\"" :: String
11:15:10 <lambdabot>   "\1114111"
11:15:41 <ozy`> > do putChar '\1112111'
11:15:42 <lambdabot>   * Exception: "<IO ()>"
11:15:58 <conal> Peaker: i can do that chgrp recursively for the FieldTrip trac.  do you see any reason not to?
11:16:02 <tonnnee> BONUS needs to finish the monads section in his learnyouahaskell
11:16:13 <Peaker> conal: nope, should be a good idea
11:16:22 <tonnnee> because its the end of the quarter
11:16:31 <tonnnee> GOGOGOGOGOGOGO
11:16:56 <Zero_In_Mood> so lilac did u have any idea or solution for my problem ?
11:19:03 <Peaker> conal: trac is being silent about the failure
11:19:55 <conal> Peaker: oh, :(
11:20:15 <Peaker> I'm asking #trac
11:24:09 <conal> Peaker: i don't have permission to do the chgrp :(
11:24:30 <Peaker> conal: the unix permission model sucks :-)
11:25:05 <Peaker> conal: I think some of the files there are www-data/www-data, is it failing on those? That's probably not a problem
11:26:12 <Peaker> conal: oh, it appears its simply not a udiff file heh
11:26:30 <conal> Peaker: "udiff"?
11:26:34 <conal> oh!
11:26:35 <Peaker> A darcs bundle is not a diff -u output
11:26:48 <conal> and .patch is assumed to be
11:27:16 <Peaker> yeah, I don't think anyone supports darcs bundles.. bzr bundles are "diff -u" outputs with a big comment at the end with the bzr metadata
11:27:22 <Peaker> I wonder why darcs doesn't do the same
11:28:47 <Zero_In_Mood> it seems as no one really wanna help me or i cant understand and interpret the hints as wished.. :(
11:29:22 <Peaker> conal: http://trac.haskell.org/reactive/attachment/ticket/13/snapshot.diff -- halleluja, it already worked :-)
11:29:25 <lambdabot> Title: #13: snapshot.diff - reactive - Trac, http://tinyurl.com/6apf3s
11:29:35 <Peaker> conal: maybe you want to cancel logging now (being a good citizen of their hard disk :-)
11:30:16 <conal> Peaker: thx.  will do.  i can leave it on error or warning.  suggestion?
11:30:38 <Peaker> conal: I guess you can turn it off if that's default until we have a problem then we can turn it on again
11:30:59 <jeffheard> This refuses to compile and I have no idea why...
11:31:01 <jeffheard> http://hpaste.org/12695
11:31:47 <jeffheard> says "parse error on where"
11:32:18 <wchogg> which where?
11:33:14 <centrinia> jeffheard: Try to align your "where" and its subsequent declarations.
11:33:21 <BMeph> jeffheard: The 'where' (in (|/|)'s definition) if indented before the 'if' which makes it outside of the definition's scope. Indent it more. :)
11:33:47 <centrinia> You can also use curly braces. :)
11:34:09 <jeffheard> blech on the curly braces...  I've never had this problem before indenting this way
11:34:25 <orbitz> have you ever had another defintion below your where?
11:34:39 <hellige> or else put the "if" part on the previous line after the =
11:36:05 <jeffheard> I suppose somehow despite coding Haskell for four years now, I've never run into that particular rule
11:36:09 <jeffheard> how odd
11:36:11 <jeffheard> that seems to have fixed it
11:36:28 <jeffheard> I was just trying to make it prettier
11:36:55 <Zero_In_Mood> hmm im once again pasting my code in here.. maybe some1 is so nice n will help me i still didnt find a way
11:36:55 <Zero_In_Mood> http://hpaste.org/12691
11:37:07 <hellige> wait
11:37:12 <hellige> there are tab characters in your code
11:37:32 <hellige> the definition of |/| is indented with a tab
11:37:38 <hellige> while the "where" is indented with spaces.
11:37:55 <jeffheard> oh crap.  got it.  darn textpad
11:38:18 <centrinia> Zero_In_Mood: I really don't understand what you are trying to do.
11:38:33 <hellige> yeah. with spaces, it should be fine as-is.
11:38:39 <Zero_In_Mood> i just get in a String and what i wanna get is the VTree
11:38:54 <centrinia> How is a VTree constructed?
11:38:57 <Zero_In_Mood> example String : "VWWSS" is the VTree : (V S S W W)
11:38:58 <centrinia> What is a VTree?
11:39:14 <Zero_In_Mood> a VTree is S or W or V VTree VTree VTree VTree
11:39:24 <ozy`> Zero_In_Mood: I think VT should be named VT and preToVT should be named pTV
11:39:33 <ozy`> that would help make it clearer what your code is for
11:40:00 <mmorrow> jeffheard: it wasn't the "if", but the fact that the where was lined up with the start of the other function decls that come after "... instance ... where"
11:40:00 <Zero_In_Mood> sorry ozy didnt chose the names... my profesor did it..
11:40:14 <ozy`> Zero_In_Mood: :p
11:40:23 <ozy`> you could at least comment them for our benefit though
11:40:27 <Zero_In_Mood> well and the fact im rotating the letters is because the String is a right to left linearilazed VTree
11:40:29 <jeffheard> mmorrow: yeah, the whole thing's littered with tabs for some reason
11:40:35 <mmorrow> {"let","where","of","do"} each start a layout context
11:40:56 <centrinia> > data VTree = S | W | V VTree VTree VTree VTree deriving (Show)
11:40:57 <lambdabot>   <no location info>: parse error on input `data'
11:41:20 <mmorrow> then the indent of the /first/ token seen after any of those tokens determines the minimal indent for that context
11:41:28 <Zero_In_Mood> i think that would be clear. if would help i can offer a program which is making right to left linearized String..
11:41:46 <Peaker> Zero_In_Mood: that definition doesn't make much sense..
11:42:01 <BMeph> Zero_in_Mood: Have you thought of using a helper function that goes through your string and divides it up for the converter function? The whole V _ _ _ _ wstructure ruins the assumption of a uniformly divided subtree structure. :)
11:42:03 <mmorrow> so it was trying to interpret your "where" under (|/|) as being at the same level as the definition of (|/|) itself
11:42:28 <Peaker> Zero_In_Mood: can you show what you'd like it to do in a recursive definition?
11:43:49 <Zero_In_Mood> well i can try to show on an example .. we got this String here "V W W S V S S S W"  -> first step: "(V (preToVt "W") (preToVt "W") (preToVt "S") (preToVt "V S S S W")
11:44:21 * mmorrow battled through the layout spec in the haskell report for about 2hrs to code up a minimal layout aware lexer to gain that information :)
11:44:28 <jeffheard> mmorrow: I got it.  I knew the rules, but apparently my editor did not.  Conveniently, because of the tabstops, I couldn't see that i was indented wrong
11:44:42 <ozy`> Zero_In_Mood: you'll want to use a helper function of type String -> (VTree, String)
11:44:48 <Zero_In_Mood> -> next step would be : (V W W S (V (preToVt "S") (preToVt "S") (preToVt "S") (preToVt "W")) thuis kinda..
11:44:51 <jeffheard> mmorrow: thanks, though.  That's the first time I've seen the layout rules explained that clearly
11:44:56 <ozy`> see if you can figure out what to do from there
11:45:23 <mmorrow> the spec gives the algo in /such/ a convoluted way i abandoned following their pseudo-code exactly (but still followed the rules exactly) and used a Tree to hold the output of the lexer
11:45:27 <jeffheard> mmorrow:  I usually get them right, but that's mostly out of conservatism in typing style rather than knowinthe the rules
11:45:31 <Zero_In_Mood> i dont see why a helper function of type String -> (VTree , String) may help me
11:46:02 <mmorrow> jeffheard: heh, that's exactly why i got them right before about two weeks ago as well :)
11:46:34 <ozy`> Zero_In_Mood: okay, lemme clarify: the String in the second part of the tuple would be the rest of the string that's left unparsed
11:47:08 <Zero_In_Mood> it ll show data error then
11:47:25 <Zero_In_Mood> cause after a VTree type like V there has to be 4 VTrees... no matter what
11:47:37 <mmorrow> (a Tree to hold the lexer output rather than inserting special tokens (of which there are two subtypes) which hold a number indicating the layout of the /previous/ token if ... if .. but .. then .. if ...BUT .. (etc ..))
11:48:30 <ozy`> Zero_In_Mood: you don't seem to understand what I'm saying, then...
11:48:37 <Zero_In_Mood> i guess i aint...
11:48:57 <Zero_In_Mood> :(
11:50:37 <mmorrow> here's that layout-aware lexer code if anyone's interested (120 lines): http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=544#a544
11:50:45 <vixey> Zero_In_Mood: 1) Write a function VTree -> String
11:50:51 <vixey> Zero_In_Mood: 2) invert it
11:51:06 <vixey> Zero_In_Mood: I can help with (2) once you did (1) :)
11:51:07 <mmorrow> oh, and the lexer output isn't a Tree but a Forest [(Lexeme, Pos)]
11:51:11 <Zero_In_Mood> i already got a VTree -> String function ^^
11:51:22 <Zero_In_Mood> that was task 1 on the sheet :)
11:51:32 <vixey> Zero_In_Mood: you should  hpaste everything you got  then
11:51:43 <Zero_In_Mood> hmm k lemme hpaste the other one too
11:52:16 <vixey> Zero_In_Mood: (Have you ever heard of continuation passing style before?)
11:52:41 <Zero_In_Mood> http://hpaste.org/12696
11:52:42 <mmorrow> (it only represents layout-relevant lexemes as constructors of the Lexeme datatype, and all others as | OtherL String
11:52:50 <mmorrow> )
11:52:51 <Zero_In_Mood> no i didnt vixey..
11:53:40 <vixey> Zero_In_Mood, think of a continuation as _what to do next_
11:54:07 <centrinia> Zero_In_Mood: Try this: http://hpaste.org/12697
11:55:00 <Zero_In_Mood> pretty hard looking.. i ll try to get into it centrinia..
11:55:19 <Zero_In_Mood> and vixey yh as u see on my code i tried to invert the first function VTree -> String but wasnt that easy
11:55:37 <vixey> Zero_In_Mood, It's actualyl really easy, you just need this one tool
11:55:45 <vixey> called continuation passing
11:56:29 <Zero_In_Mood> i dont know it lemme google it
11:56:39 <Zero_In_Mood> btw centrinia ur function making same mistake like mine
11:56:44 <Zero_In_Mood> Main> preToVt "VWWSVWWSS"
11:56:44 <Zero_In_Mood> V (V
11:56:44 <Zero_In_Mood> Program error: Prelude.!!: index too large
11:56:45 <jeffheard> thanks, mmorrow, everything compiles now
11:56:59 <mmorrow> jeffheard: cool :)
11:58:13 <centrinia> Zero_In_Mood: Here is the new one: http://hpaste.org/12697#a1
11:58:59 <centrinia> Main> preToVT "VWWSVWWSS"
11:59:27 <vixey> Zero_In_Mood, so say you are given the string "SWVWWWW..." and a continuation k, and I ask you to actually parse _one_ tree out of that string, and then plug that one tree and the whole rest of te string into the continuation
11:59:44 <vixey> Zero_In_Mood, that's = k S "WVWWW...", makes sense?
11:59:54 <Zero_In_Mood> SWVWWW aint possible ^^
12:00:12 <vixey> Zero_In_Mood, SWVWWW is possible as a *subsection* of a large parse
12:00:29 <Zero_In_Mood> hmm ^.^ ure confusing me.. :(
12:00:41 <vixey> well just to walk through a whole example,
12:01:01 <vixey> say you were doing the String  "VSWSW" into the tree V S W S W
12:01:26 <vixey> first thing you see is a 'V', so now you have to read 4 trees in and make each one a branch of the V
12:01:37 <vixey> so I give you the string "SWSW" and a continuation k
12:02:12 <Zero_In_Mood> continuation k ?
12:02:16 <vixey> yes
12:02:24 <vixey> Zero_In_Mood, so you must parse the first tree out and plug it into the continuation along with the entire rest of the string
12:02:35 <centrinia> Zero_In_Mood: Did you run my new post?
12:02:53 <Zero_In_Mood> yeah same mistake centrinia.
12:02:58 <centrinia> What is the result?
12:03:06 <ozy`> Zero_In_Mood: http://hpaste.org/12697#a2 <== do you have to parse text after you've got an entire node?
12:03:06 <Zero_In_Mood> hmm
12:03:50 <vixey> Zero_In_Mood, I don't want to just post a solution because that'd be boring, the derivation is the really interesting bit..
12:03:53 <Zero_In_Mood> so vixey if i take "SWSW" andi  take the first tree so the last W i should work with the continuation "SWS" for the next tree !?
12:04:03 <vixey> Zero_In_Mood, yeah that's exactly right
12:04:41 <vixey> Zero_In_Mood, so you can write the first two (easy) case for this now... like  preToVT ('S':rest) k = ? and preToVT ('W':rest) k = ..
12:05:11 <centrinia> Zero_In_Mood: Both ozy' and I have posted solutions.
12:05:35 <Zero_In_Mood> yeah centrinia urs aint working at winhugs.. same mistake again..
12:05:44 <centrinia> Zero_In_Mood: Were you running our posts or were you running your own code?
12:06:03 <Zero_In_Mood> and to ozys i just looked into it and the noparse at the data tree aint allowed.
12:06:22 <ozy`> Zero_In_Mood: tough shit, go rewrite it yourself
12:06:27 <Zero_In_Mood> were running ur code. thou im willingly to understand it like vixey is tryin to explain it right now..
12:06:34 <Zero_In_Mood> but thx for ur hard work..
12:06:39 <vixey> My way is simpler than both those pastes
12:06:44 <vixey> :)
12:06:58 <centrinia> Zero_In_Mood: Both ozy` and my own versions work.
12:07:05 <vixey> Zero_In_Mood, Do you know what haskell to write for those two cases though?
12:07:05 <Zero_In_Mood> so vixey : ('S':rest) k = S (preToVt rest k)
12:07:38 <ozy`> (you could do Just parse | Nothing instead of NoParse, if you must)
12:07:48 <vixey> Zero_In_Mood, not quite, There's two things wrong there that will give a type error but also,  I don't want you to keep going.. just plug S and the rest of parse into the continuation k
12:07:54 <ozy`> (and then put it in the Maybe monad)
12:07:59 <vixey> the rest of the string
12:08:04 <ozy`> (in fact...)
12:08:42 <Zero_In_Mood> hmm.. i didnt understand it ozy.. the NoParse thing.. thou for ur info im usin WinHugs maybe thats why ur code didnt work for me centrinia..
12:08:59 <centrinia> Uh, no.
12:09:04 <orbitz> any suggestions for fun/challenging haskell exercises?
12:09:29 <Zero_In_Mood> hmm..
12:09:39 <Zero_In_Mood> how can i put the rest into the continuation k ?
12:09:43 <centrinia> How do I declare a datatype with Lambdabot?
12:09:49 <orbitz>  @let
12:09:53 <orbitz> err
12:09:54 <orbitz> no obviously wrong
12:09:58 <mauke> centrinia: you don't
12:10:00 <vixey> Zero_In_Mood, just the rest of the text that more parsing will be done on
12:10:10 <orbitz> hay mauke
12:10:20 <mauke> hi, orbitz
12:10:48 <orbitz> mauke: do you...uhh...
12:10:49 <orbitz> yahoo?
12:10:57 <mauke> no, I don't think so
12:11:39 <Zero_In_Mood>  S (preToVt rest k) so if this is the wrogn way and i should just plug S how can i hmm.. someday i ll get headache from that hard thinking about one topic for so long..
12:11:58 <centrinia> Zero_In_Mood: How are you running your Haskell programs?
12:12:05 <vixey> Zero_In_Mood, Here's what I wrote:  preToVT'k ('S':xs) k = k S xs
12:12:18 <vixey> Zero_In_Mood, which is the inverse for:  vtToPre S = "S"
12:12:27 <mauke> quite but not entirely unrelated: http://home.cs.tum.edu/~mai/ploki/ploki-0.6.4/examples/calc.pk
12:12:35 <Zero_In_Mood> WinHugs  version: sep2006
12:12:38 <vixey> Zero_In_Mood, the W case is easy so two down one to go...
12:13:01 <mmorrow> , let foldCont f [] z = []; foldCont f (x:xs) = f z x xs (\z' rest -> foldCont z' f rest) in foldCont (\z x -> if x == 0 then 0 else z*x) ([1..10]++[0]++[1..10000000000]) 1
12:13:03 <vixey> Zero_In_Mood, before thinking about inverting the recursive equation, should take a moment to think about what preToVT'k does
12:13:11 <lunabot>  luna: Not in scope: `z'
12:13:13 <mmorrow> oops
12:13:45 <mmorrow> , let foldCont f [] z = z; foldCont f (x:xs) z = f z x xs (\z' rest -> foldCont z' f rest) in foldCont (\z x xs k-> if x == 0 then 0 else k (z*x) xs) ([1..10]++[0]++[1..10000000000]) 1
12:13:47 <vixey> Zero_In_Mood, so for example (with the two equations one for S and one for W),  preToVT'k "SXYZ" (\x y -> (x,y)) ~~> (S,"XYZ"), do you see why?
12:13:47 <lunabot>  luna: Couldn't match expected type `t1
12:13:52 <mmorrow> gah
12:14:10 <mmorrow> , let foldCont f [] z = z; foldCont f (x:xs) z = f z x xs (\z' rest -> foldCont z' f rest) in foldCont (\z x xs k-> if x == 0 then k 0 [] else k (z*x) xs) ([1..10]++[0]++[1..10000000000]) 1
12:14:12 <lunabot>  luna: Couldn't match expected type `t1
12:14:12 <Zero_In_Mood> yh yh im still checking ur preToVT'k thing is there a way to try some minor cases in winhugs without any minor details just with some numbers orso ?
12:14:29 <Zero_In_Mood> well i think i know whyvixey
12:14:44 <vixey> Zero_In_Mood, you can just run the program in your head, no need for a computer :)
12:14:55 <mmorrow> , let foldCont f [] z = z; foldCont f (x:xs) z = f z x xs (\z' rest -> foldCont f rest z') in foldCont (\z x xs k-> if x == 0 then k 0 [] else k (z*x) xs) ([1..10]++[0]++[1..10000000000]) 1
12:14:57 <Zero_In_Mood> \x y means we re splitting the "" into the first one and the rest and the function is to give it back like : "first element, the rest)
12:14:58 <lunabot>  0
12:15:05 <vixey> Zero_In_Mood, yes
12:15:10 <Zero_In_Mood> thats why we re gettin (S;"XYZ")
12:15:22 <mmorrow> , foldl (*) 1 ([1..10]++[0]++[1..10000000000])
12:15:28 <lunabot>  luna: out of memory (requested 2097152 bytes)
12:15:32 <vixey> Zero_In_Mood, my continuation there was (\x y -> (x,y)) it just pairs up the tree and the string
12:16:02 <Zero_In_Mood> so a continuation is just another helpin function ?
12:16:15 <vixey> not really, it's more fundamental
12:16:38 <Zero_In_Mood> hmm..
12:16:51 <centrinia> Zero_In_Mood: Try this new post: http://hpaste.org/12697#a3 :p
12:17:33 <mmorrow> Zero_In_Mood: you could kinda say that, but i'd say it's more like "a function that you're going to hand control off to (in one way or another)"
12:17:34 <Zero_In_Mood> so my preToVT'k :: String -> (Int -> Int) -> (VTree,String) type?
12:17:40 <vixey> Zero_In_Mood, you should try ot write a call to preToVT'k that takes the string "VWXYZ" with a call to preToVT'k inside the contiunation.. so that it returns the first two trees and the rest that is (V,W,"XYZ")
12:17:54 <vixey> Zero_In_Mood, no, forget types for the moment, they will be confusing
12:17:55 <centrinia> Zero_In_Mood: Did you get the new post to run?
12:18:33 <mmorrow> but the nice thing is, you could also just throw the continuation away and return whatever value you please
12:18:36 <vixey> Zero_In_Mood, (if you didn't know you don't have to write any types out by hand in haskell, it's just optional to do so -- the complier can figure them out)
12:18:45 <Zero_In_Mood> centrinia: Main> preToVt "VWWSVWWSS"
12:18:45 <Zero_In_Mood> V (V
12:18:45 <Zero_In_Mood> Program error: Prelude.!!: index too large
12:18:55 <Zero_In_Mood> hmm okay..
12:19:00 <centrinia> No, I meant the newest post.
12:19:07 <mmorrow> ("whatever value you please" in an appropriate sense ;)
12:19:10 <ozy`> Zero_In_Mood: check the page again
12:19:26 <vixey> centrinia, ozy`, do you both know how to invert the function using continuations? :)
12:19:43 <ozy`> vixey: nope!
12:19:56 <vixey> so stop .. distracting Zero_In_Mood :p
12:20:12 <Zero_In_Mood> Main> preToVt "VWWSVWWSS"
12:20:12 <Zero_In_Mood> Just (V W W S (V W W S S))
12:20:38 <Zero_In_Mood> yeah but stop distracting me.. it works as u can see thou u didnt change the linearization..
12:21:11 <centrinia> What do you mean by changing the linearization?
12:21:33 <Zero_In_Mood> well the task is that the string is a right to left linearized string of a VTree...
12:21:45 <Zero_In_Mood> but nvm it is a minor thing i can handle by myself.. thou
12:22:00 <Zero_In_Mood> vixey i didnt get it with the call to preToVT'k
12:22:15 <centrinia> If that is the case, http://hpaste.org/12697#a0 should work. :p
12:22:21 <Zero_In_Mood> which takes the string and gives another call again to preToVT'k inside the continuation..
12:22:33 <vixey> Zero_In_Mood, try to fill the blank in so that   preToVT'k "VWKYZ" _____ ~~> (V,W,"XYZ")
12:22:58 <vixey> Zero_In_Mood, first step is:  preToVT'k "VWKYZ" (\tree1 rest -> ____)
12:23:09 <Zero_In_Mood> k wait a sec ^^ lemme try
12:23:16 <vixey> oops
12:23:24 <vixey> preToVT'k "SWKYZ" (\tree1 rest -> ____) **
12:23:33 <vixey> shouldn't be using V yet just S and W
12:23:58 <Zero_In_Mood> how about
12:24:15 <Zero_In_Mood> (tree1,(preToVT'k rest))
12:24:24 <vixey> almost.. :)
12:24:36 <vixey> very close but preToVT'k rest never got its continuation
12:24:43 <Zero_In_Mood> (tree1,(preToVT'k rest) rest)
12:24:44 <Zero_In_Mood> ?
12:25:01 <vixey> no
12:25:19 <Zero_In_Mood> gimem a min to think about it
12:25:51 <Zero_In_Mood> (tree1,(preToVT'k rest (\tree1 rest -> ____)))
12:25:59 <vixey> yes great
12:26:10 <vixey> call it tree2 though
12:26:18 <Zero_In_Mood> yhright
12:26:33 <Zero_In_Mood> or in general (\x y -> x y)
12:26:50 <vixey> so you got this:   preToVT'k "SWKYZ" (\tree1 rest -> (tree1,(preToVT'k rest (\tree2 rest -> (tree2,rest)))))
12:27:06 <vixey> and when you run it, it gives.. (S,(W,"KYZ"))
12:27:16 <vixey> can you change it a bit to make it return (S,W,"KYZ") though?
12:27:35 <Zero_In_Mood> return (S,W,"KYZ") hmm..
12:28:29 <mmorrow> , let flat [] k = k []; flat (Node x [] : ts) k = flat ts (\xs -> k (x:xs)); flat (Node x ts : fs) k = flat ts (\xs -> flat fs (\ys -> k (x : xs ++ ys))) in flip flat id [Node 1 [Node 2 [Node 3 [], Node 4 []]], Node 5 [Node 6[]], Node 7 []]
12:28:31 <lunabot>  [1,2,3,4,5,6,7]
12:28:43 <Zero_In_Mood> it wouldnt be done just by deleting one ( and one ) !?
12:29:23 <mmorrow> err, i hope i didn't just give away the answer to the problem you're working on :-)
12:29:25 <vixey> Zero_In_Mood, well you have got (x,y) where y = (w,v), but we really need (x,w,v)
12:29:42 <mmorrow> what problem /are/ you working on?
12:30:13 <Zero_In_Mood> hmm.. so without any help function ?
12:30:52 <vixey> Zero_In_Mood, it's almost: preToVT'k "SWKYZ" (\tree1 rest -> (tree1,(preToVT'k rest (\tree2 rest -> (tree2,rest)))))  that you got before.. just modify it a bit
12:31:06 <mmorrow> oh cool, parsing (just saw your hpaste)
12:33:50 <Zero_In_Mood> i think i wont get it i didnt see which i have to change but neither i dunno why i have to delte the ( yet
12:34:19 <vixey> I think it's a bit difficult to see because there are so many brackets but..
12:34:36 <Zero_In_Mood> maybe...
12:34:56 <Zero_In_Mood> preToVT'k "SWKYZ" (\tree1 rest -> (tree1,(preToVT'k rest (\tree2 rest -> tree2,rest))))
12:35:24 <Zero_In_Mood> but dunno if its allowed to give out tree2,rest
12:35:42 <centrinia> vixey: Where is the implementation of preToVT'k ?
12:35:48 <nomeata> Hi. Is there a common name for
12:35:55 <vixey> centrinia, we're writing it now
12:35:55 <nomeata> @type foldl (.) id
12:35:57 <lambdabot> forall a. [a -> a] -> a -> a
12:36:06 <vixey> Zero_In_Mood, want me to show you?
12:36:18 <Zero_In_Mood> so may step isnt allowed ?
12:36:24 <vixey> that wasn't it no
12:36:35 <Zero_In_Mood> then it may be better to show me
12:36:39 <vixey> preToVT'k "SWKYZ" (\tree1 rest -> (preToVT'k rest (\tree2 rest -> (tree1,tree2,rest))))
12:36:54 <Zero_In_Mood> hu
12:37:00 <Zero_In_Mood> damn thas smart
12:37:01 <vixey> see how it evaluates,
12:37:14 <vixey> (preToVT'k "WKYZ" (\tree2 rest -> (S,tree2,rest))))
12:37:26 <vixey> (S,W,"KYZ")
12:37:49 <vixey> so that's 2 trees, now you know everything you need to write it for 3 or *4*
12:38:08 <vixey> Zero_In_Mood, infact you can write  preToVT'k ('V':rest) k = ... now :)
12:38:21 <vixey> just like this previous one
12:38:26 <vixey> with "SWKYZ"
12:38:42 <Zero_In_Mood> hmm yeah.. i guess i now know how to work with the yeah.. thats it... but... hmm...
12:39:03 <Zero_In_Mood> hmm before i ll ask something prolly better to try it out n see by myself
12:39:17 <ski_> nomeata : i call it `compose'
12:39:29 <Zero_In_Mood> im seeking for (V,X1,X2,X3,X4,rest) now right ?
12:39:38 <nomeata> ski_: but it‚Äôs not in the standard libs, is it?
12:39:54 <vixey> Zero_In_Mood, k (V tree1 tree2 tree3 tree3) rest
12:39:57 <ski_> not that i know
12:40:02 <ski_> @hoogle compose
12:40:03 <lambdabot> package TypeCompose
12:40:13 <Zero_In_Mood> tree3 two times ?
12:40:17 <vixey> oops
12:40:18 <vixey> no
12:40:31 * ski_ usually defines it, when needed, in a `Misc' module ..
12:40:35 <Zero_In_Mood> how can i delete the , ? thou well see later lemme try
12:41:07 <vixey> Zero_In_Mood, hpaste once you got something and ping me if you want :)
12:41:35 <Zero_In_Mood> well
12:42:02 <Zero_In_Mood> i still how ti implent it really but im just writing the 'k function now ^.^
12:46:16 <Zero_In_Mood> vixey
12:46:19 <Zero_In_Mood> for V it is :
12:46:19 <Zero_In_Mood> preToVT'k x (\w a -> (preToVT'k a (\x b -> (preToVT'k b (\y c -> (preToVT'k c (\z d -> (preToVT'k d (\l e -> (w,x,y,z,l,e))))))))
12:47:08 <vixey> Zero_In_Mood, that's exactly right except this one bit:  (preToVT'k d (\l e -> (w,x,y,z,l,e))
12:47:17 <mmorrow> hehe, cps++
12:47:36 <vixey> Zero_In_Mood, instead of returning that tuple, you've gotta plug the tree (V w x y z) and the rest of the string being parsed 'd' into the continuation
12:47:38 <vixey> 'k'
12:47:47 <Zero_In_Mood> hmm
12:48:13 <Zero_In_Mood> but i cant just write :
12:48:39 <mmorrow> nomeata, ski: apparently foldr is what you want there instead of foldl (i used foldl at first too until Cale showed me otherwise)
12:48:43 <Zero_In_Mood> (w x y z l),preToVT e x)
12:48:44 <Zero_In_Mood> !?
12:48:51 <Zero_In_Mood> (w x y z l),preToVT e f)
12:48:52 <vixey> hehe
12:48:59 <Zero_In_Mood> sry used x alrdy.. and
12:49:03 <Zero_In_Mood> ((w x y z l),preToVT e f)
12:49:05 <Zero_In_Mood> i mean like this..
12:49:06 <vixey> Zero_In_Mood, so hpaste the entire function? :)
12:49:10 <mmorrow> (since (.) is infixR)
12:49:10 <vixey> all 3 equations
12:49:24 <mmorrow> , src '(.)
12:49:27 <Zero_In_Mood> stil dont have all 3 were just working on the V one right now :( im bit slow... haskell aint my language
12:49:33 <Zero_In_Mood> neither is english so its double hard :)
12:49:34 <lunabot>  ) :: forall b c a . (b -> c) -> (a -> b) -> a -> c
12:49:34 <lunabot>  infixr 9 )
12:49:40 <mmorrow> haha
12:49:46 <vixey> Zero_In_Mood, your doing great!
12:49:47 <mmorrow> prettyprint fail!
12:50:11 <nomeata> mmorrow: I never know which one to take. Not that it will matter for the few ones I have
12:51:15 <mmorrow> nomeata: one nice "rule of thumb" (or something) that i've found is that the fold direction you (usually) want is the same as the fixity direction of the function you're giving to fold* in the first arg
12:51:15 <ehird> Where's the good haskell-mod eagain?
12:51:21 <ehird> I know there's a crap one and a good one :P
12:51:53 <mmorrow> that seems to be surprisingly applicable, although i'm not sure how to go about proving that that's /always/ true (in some appropriately restricted sense)
12:52:14 <Zero_In_Mood> btw i just noticed is he returning anything at my line above or should i write behind it : = ((w x y z l), (preToVT e f))
12:52:15 <Zero_In_Mood> !?
12:52:44 <nomeata> mmorrow: I‚Äôm also never sure what infixl actually means. I assume that it means (a . b . c) = ( (a . b) . c ), right?
12:52:51 <mmorrow> yes
12:53:30 <mmorrow> , ppDoc `fmap` foldl (|.|) [|id|] (replicate 6 [|id|])
12:53:34 <lunabot>  (((((id . id) . id) . id) . id) . id) . id
12:53:35 <mmorrow> , ppDoc `fmap` foldr (|.|) [|id|] (replicate 6 [|id|])
12:53:40 <lunabot>  id . (id . (id . (id . (id . (id . id)))))
12:54:05 <mmorrow> so since (.) is infixr, without parens the later would be the parse
12:54:32 <mmorrow> (i defined (|.|) to be:
12:54:45 <mmorrow> g |.| f = [|$g . $f|]
12:54:53 <mmorrow> (|.|) :: ExpQ -> ExpQ -> Exp!
12:55:00 <mmorrow> s/!/Q/
12:55:09 <mmorrow> )
12:55:32 <vixey> Zero_In_Mood; (don't look at this :p http://hpaste.org/12697#a5 )
12:55:51 <vixey> spoiler
12:56:29 <mmorrow> s/later/latter/
12:56:35 <Zero_In_Mood> so vixey its probably not right but i ll paste mine now lol :( i dunno just what i thought now^^
12:57:18 <Zero_In_Mood> http://hpaste.org/12691#a1
12:57:55 * vixey afk
12:58:04 <Zero_In_Mood> i guess i need to add = ((w x y z l),preToVT e f)
12:58:05 <vixey> you will get it if you try for a bit mre :)
12:58:30 <Zero_In_Mood> well its all hard since this continuation thing is all new to me..
12:58:35 <Zero_In_Mood> and im pretty new to programing kidna
12:58:58 <vixey> Zero_In_Mood, continuations are one of the most fundamental things in programming
12:59:32 * yitz coughs
12:59:39 <Botje> they're so fundamental nobody knows they're there :)
12:59:48 <orbitz> yitz: checkin for hernias?
12:59:48 <UrIko> hi
12:59:54 <mmorrow> Zero_In_Mood: vixey says that, but using continuation like you're using now is usually something that takes a lot longer to learn how to do than the short 10 minutes you've been trying it :)
12:59:55 <Zero_In_Mood> yh i see.. yeah .. just when im thinking logical it really is cool...
13:00:01 <yitz> orbitz: :)
13:00:01 <mmorrow> so i'd say you're doing well
13:00:13 <daf> @pl (\x -> f x || g x)
13:00:14 <lambdabot> liftM2 (||) f g
13:00:21 <daf> is this that sneaky reader monad again?
13:00:25 <Zero_In_Mood> far better than stupid long recursive function with many help functions
13:00:26 <Botje> yup
13:00:47 <vixey> Botje, yeah it's a bit sad.. you can imagine people didn't know about lambda nad stuff in the past
13:00:51 <daf> it seems to pop up when I don't expect it
13:01:04 <daf> it still seems a little magical
13:02:30 <Zero_In_Mood> im trying to fix my thing with the error messages but i cant come up with anything for this error message :
13:02:36 <Zero_In_Mood> ERROR file:.\preToVt.hs:13 - Syntax error in input (unexpected backslash (lambda))
13:02:53 <Zero_In_Mood> thou 13 is like 12 but in 12 there isnt any syntax error..
13:03:21 <jsn> Zero_In_Mood: well, can we see the file?
13:03:36 <Zero_In_Mood> http://hpaste.org/12691#a1
13:04:16 <Zero_In_Mood> ah lol
13:04:24 <Zero_In_Mood> i counted not really.. roflmao ^.^ hmm k..
13:05:27 <mauke> you can't use \ in a pattern
13:05:49 <Zero_In_Mood> hmm
13:06:18 <jsn> Zero_In_Mood: maybe you meant to include an '=' sign here: 'preToVT'k x  = (\w a ->'
13:06:35 <ehird> Mm? :)
13:06:38 <jsn> preToVT'k x = (\w a -> ...
13:07:07 <jsn> oh, wait
13:07:14 <jsn> they all have lambdas in the pattern
13:07:32 <jsn> patterns can have constructors in them
13:07:40 <Botje> just use a state monad already
13:07:46 <Zero_In_Mood> i know the first mistake
13:07:56 <jsn> Zero_In_Mood: which is?
13:08:07 <Zero_In_Mood> cant use /x cause first element is selcted by 'W' or 'S' in the first two patterns
13:08:33 <Zero_In_Mood> changed it by now.. now the next mistake but i can solve it too i guess ^^ just need some more time :D
13:12:35 <mmorrow> @pl \f xs k -> preToVT'k xs (\north xs -> preToVT'k xs (\east xs -> preToVT'k xs (\south xs -> preToVT'k xs (\west xs -> k (f north east south west) xs))))
13:12:36 <lambdabot> flip ((.) . preToVT'k) . (((flip preToVT'k . ((flip preToVT'k . (flip preToVT'k .)) .)) .) .) . flip ((.) . (.) . (.) . (.))
13:12:48 <mmorrow> sweet
13:13:02 <Zero_In_Mood> u re lucky that i dont understand ur thing really^^
13:13:38 <mmorrow> @quote pl
13:13:38 <lambdabot> pl says: const (((it hurts :) .) . flip flip [] . ((:) .))
13:13:43 <mmorrow> haha
13:13:56 <mauke> @unpl const (((it hurts :) .) . flip flip [] . ((:) .))
13:13:56 <lambdabot> (\ _ m s -> it hurts : ((:)) (m s) [])
13:14:46 <mmorrow> it was originally something like     @pl ... [it hurts, my eyes] .. arghh
13:14:56 <mmorrow> by sw17ch
13:15:32 <ehird> Nobody knows the link to the right haskell-mode? :S
13:15:40 <ozy`> @pl (\my eyes -> [it hurts, my eyes])
13:15:41 <lambdabot> ((it hurts :) .) . flip flip [] . ((:) .)
13:15:41 <mauke> @pl \argh my eyes -> it hurts : my eyes : []
13:15:41 <lambdabot> const (((it hurts :) .) . flip flip [] . ((:) .))
13:15:52 <Zero_In_Mood> damn nowsame lambda backslash error again in the V line :(
13:15:56 <mauke> @pl \argh my eyes -> [it hurts, my eyes]
13:15:56 <lambdabot> const (((it hurts :) .) . flip flip [] . ((:) .))
13:16:00 <centrinia> :t const ((it hurts :( . ))  . flip flip [] . ((:) . )))
13:16:01 <lambdabot> parse error on input `)'
13:16:13 <centrinia> :t const ((it hurts :( . ))  . flip flip [] . ((:) . ))
13:16:14 <lambdabot> Not in scope: `it'
13:16:14 <lambdabot> Not in scope: `hurts'
13:16:21 <centrinia> @unpl const ((it hurts :( . ))  . flip flip [] . ((:) . ))
13:16:22 <lambdabot> (\ _ n -> (it hurts : \ b c d -> b (c d)) (\ j -> ((:)) (n j) []))
13:16:24 <ozy`> Zero_In_Mood: make sure you don't mix up backslash (\) and forward slash (/)
13:16:25 <centrinia> Yeah. :)
13:16:33 <mmorrow> mauke: heh, nice manual unpl there
13:17:08 <ziman> @quote
13:17:08 <lambdabot> sioraiocht says: if you made a type class the same name as a type, I'd stab you in the face
13:17:47 <mauke> preflex: quote
13:17:48 <preflex>  <pizza> back when we had only 1 bit of memory we never had these organizational problems
13:17:56 <Peaker> preflex: be PoppaVic
13:17:56 <ziman> data Tree a = Tree a; instance Tree Tree where ... :)
13:17:57 <preflex>  you need to be aware of C before you screw with commo/net and THEN you need to consider the funnels/rules. Why is this remotely an issue?
13:18:07 <Zero_In_Mood> so
13:18:49 <centrinia> data Eq = Equal | NotEqual; :)
13:18:54 <Zero_In_Mood> / forward slash is the one i need? ^.^
13:19:09 <int-e> ziman: data Tree tree = Tree tree [Tree tree]
13:19:24 <ozy`> Zero_In_Mood: no, backslash starts a lambda. forward slash is the division operator
13:19:57 <Zero_In_Mood> what does lambda really mean lol ^.^:(
13:20:02 <centrinia> What does the predecrement operator do in Haskell?
13:20:04 <Peaker> @src Eq
13:20:05 <lambdabot> class  Eq a  where
13:20:05 <lambdabot>     (==), (/=)   :: a -> a -> Bool
13:20:20 <centrinia> Zero_In_Mood: It is an anonymous function. :)
13:20:25 <ski_> Zero_In_Mood : anonymous function
13:20:36 <int-e> centrinia: the what? -- introduces a one line comment
13:21:09 <quicksilver> conal: no worries ;) it's not a hurry in any sense
13:21:11 <Cale> centrinia: That's a good question... what "predecrement" would mean in the context of, say, the ST monad.
13:21:16 <centrinia> > map (\x -> x ++ " Hello World!") ["What up?!", "Hai!"]
13:21:18 <lambdabot>   ["What up?! Hello World!","Hai! Hello World!"]
13:21:34 <Zero_In_Mood> okay
13:21:41 <ozy`> Zero_In_Mood: the name "lambda" comes from lambda calculus. don't worry about it beyond that; just know that the name is used for creating functions without giving them names
13:22:05 <Peaker> Cale: how could it mean anything? pre/post-decrement need to return pure results to their user?
13:22:12 <idnar> it's also an inline function
13:22:13 <centrinia> @let s x y z = (x z) (y z)
13:22:14 <lambdabot>  Defined.
13:22:24 <centrinia> @let k x y = x
13:22:25 <lambdabot>  Defined.
13:22:27 <Cale> Peaker: I suppose you could define an action which decrements an STRef and gives you the new value at the same time.
13:22:42 <conal> quicksilver: thx.  and i hadn't forgotten.
13:22:51 <centrinia> > s k k (\x -> x^2) 3
13:22:52 <lambdabot>       Ambiguous occurrence `s'
13:22:52 <lambdabot>      It could refer to either `L.s', defined a...
13:22:52 <Peaker> @pl \x y z -> x z (y z)
13:22:53 <lambdabot> ap
13:23:03 <idnar> what is the "predecrement operator"?
13:23:16 <Peaker> Cale: wouldn't it have to be an action of ST type?
13:23:20 <centrinia> @pl \x y -> x
13:23:20 <lambdabot> const
13:23:22 <Cale> Peaker: yes
13:23:25 <quicksilver> conal: however, I had got off a train, been into town, come home, eaten dinner, and watched survivors. I wasn't holding my breath ;)
13:23:27 <centrinia> @unlet s
13:23:27 <lambdabot>   Parse error
13:23:29 <idnar> or was that a joke?
13:23:35 <conal> heh
13:23:36 <centrinia> It might be a joke.
13:23:39 <Peaker> Cale: well, it misses the point then, IMO:  blah = x - (++something);
13:23:47 <ozy`> @pl \x y -> y
13:23:47 <lambdabot> const id
13:23:56 <Peaker> quicksilver: survivors? Reality shows are so inane :)
13:24:03 <quicksilver> if 'decrement' were a ST action of some kind
13:24:09 <centrinia> @pl ap const const
13:24:10 <lambdabot> id
13:24:11 <quicksilver> then "f <**> (decrement x)"
13:24:12 <Cale> liftM2 (-) (return x) (preIncrement something)
13:24:12 <centrinia> Wow.
13:24:23 <quicksilver> would have the syntax of predecrement
13:24:25 <int-e> @type modify
13:24:26 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
13:24:28 <ski_> @let prePred ref = do x <- readIO ref; let {y = pred x}; writeRef ref y; return y
13:24:29 <lambdabot>  <local>:5:52: Not in scope: `writeRef'
13:24:29 <Peaker> Cale: liftM2 wants pure arguments
13:24:32 <idnar> @type (<**>)
13:24:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
13:24:35 <ski_> @let prePred ref = do x <- readIO ref; let {y = pred x}; writeIORef ref y; return y
13:24:36 <lambdabot>  <local>:5:52: Not in scope: `writeIORef'
13:24:40 <quicksilver> the little-known <**> makes the argument sideeffect happen  before.
13:24:49 <Cale> :t liftM2
13:24:50 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:24:55 <quicksilver> Peaker: survivors is a drama about the aftermath of a global pandemic.
13:24:57 <Peaker> Cale: oops, silly me
13:25:26 <ski_> @let prePred ref = do x <- Data.IORef.readIORef ref; let {y = pred x}; Data.IORef.writeIORef ref y; return y
13:25:27 <lambdabot>  <local>:5:22: Not in scope: `Data.IORef.readIORef'
13:25:27 <lambdabot>  
13:25:27 <lambdabot>  <local>:5:66: Not in s...
13:25:31 <centrinia> @pl ap (const (ap id id)) (ap (ap (const ap) (const (ap id id)))
13:25:32 <lambdabot> (line 1, column 61):
13:25:32 <lambdabot> unexpected end of input
13:25:32 <lambdabot> expecting variable, "(", operator or ")"
13:25:47 <ski_> @type let prePred ref = do x <- Data.IORef.readIORef ref; let {y = pred x}; Data.IORef.writeIORef ref y; return y in prePred -- hm ?
13:25:49 <lambdabot> forall a. (Enum a) => GHC.IOBase.IORef a -> IO a
13:25:55 <Peaker> Cale: sorry :)  well, that approximates the C meaning, but the stdlib's insistence on sequencing the side effect and the read is probably not worth working around :)
13:26:45 <centrinia> @pl ap (const (ap id id)) (ap (ap (const ap) (const (ap id id))))
13:26:46 <lambdabot> join id . ap (ap . const (join id))
13:27:11 <Peaker> quicksilver: ah, there's a show in Israel with that name (iirc) that is just an inane reality show most people watch (making me sad)
13:27:17 <mmorrow> @type join id
13:27:18 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
13:27:18 <lambdabot>     Probable cause: `id' is applied to too many arguments
13:27:18 <lambdabot>     In the first argument of `join', namely `id'
13:27:29 <mmorrow> @type (join id .)
13:27:30 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> c
13:27:30 <lambdabot>     Probable cause: `id' is applied to too many arguments
13:27:30 <lambdabot>     In the first argument of `join', namely `id'
13:27:34 <Cale> Peaker: What's much harder is postincrement.
13:27:38 <centrinia> @type ap (const (ap id id)) (ap (ap (const ap) (const (ap id id))))
13:27:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
13:27:40 <lambdabot>     Probable cause: `id' is applied to too few arguments
13:27:40 <lambdabot>     In the second argument of `ap', namely `id'
13:27:42 <Cale> er...
13:27:46 <mmorrow> ah
13:27:51 <Peaker> Cale: why?
13:27:54 <Cale> actually, no, that should be fine too :)
13:28:18 <Cale> I was thinking that it would have to only increment after the evaluation of the whole expression it's in, but that's not the case, is it?
13:28:19 <Peaker> Cale: postIncrement r = do { x <- get ; modify (+1) ; return x }
13:28:24 <Cale> yeah.
13:28:40 <Peaker> Cale: yeah, I think the order is even undefined in some cases in the C standard
13:28:50 <mmorrow> , ?f id id
13:28:55 <lunabot>  luna: Unbound implicit parameter (?f::(a1 -> a1) -> (a2 -> a2) -> a)
13:28:58 <int-e> > let post f = do { s <- get; put (f s); return s }; pre f = do { s <- f `liftM` get; put s; return s } in runState (liftM2 (,) (post succ) (pre succ)) 0
13:29:00 <lambdabot>   ((0,2),2)
13:29:19 <quicksilver> Peaker: get <* modify(+1)
13:29:22 <Peaker> int-e: put (f s) is (modify f) isn't it?
13:29:34 <int-e> Peaker: no, modify doesn't return anything
13:29:35 <centrinia> @type \x -> (( x ap) const)
13:29:35 <Peaker> @type (<*)
13:29:36 <lambdabot> forall (m :: * -> *) a b t a1 b1. (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
13:29:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:29:52 <Peaker> int-e: put doesn't either, does it?
13:30:08 <Peaker> quicksilver: cool
13:30:12 <quicksilver> "get <* modify(+1)" and "modify(+1) >> get"
13:30:14 <int-e> Peaker: oh. sorry, misread.
13:30:17 <mmorrow> , id id id
13:30:18 <quicksilver> respectively.
13:30:19 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
13:30:19 <Peaker> @type (*>)
13:30:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:30:32 <quicksilver> yeah, you could use *>
13:30:34 <Peaker> quicksilver: so  get <* modify (+1)     and modify (+1) *> get
13:30:34 <Zero_In_Mood> lilac i didnt get mine to work.. so i tried to understand urs and translate it to mine.. so that i wont copy it one to one...
13:30:36 <mmorrow> why can't ghc figure out join id?
13:30:38 <quicksilver> *> is just >>, for applicatives.
13:30:52 <Zero_In_Mood> but it seems i dont understand ur const function u re using... and
13:31:04 <int-e> Peaker: post f = liftM2 const get (modify f); pre f = modify f >> get. and it's prettier with Applicative, I believe.
13:31:05 <Zero_In_Mood> how k W xs can actually work ? or how he knows what k is ?
13:31:17 <centrinia> @pl let x = \t -> ((t ap) const) in x ( x ( x (x x) ) )
13:31:18 <lambdabot> ap
13:31:23 <centrinia> Hmm.
13:31:28 <centrinia> @pl let x = \t -> ((t ap) const) in x ( x (x x) )
13:31:28 <lambdabot> const
13:31:30 <mmorrow> join id :: (a -> a) -> (a -> )
13:31:33 <mmorrow> join id :: (a -> a) -> (a -> a)
13:31:38 <ski_> @hoogle (s -> s) -> m ()
13:31:38 <lambdabot> Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
13:31:38 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
13:31:38 <lambdabot> Data.Function fix :: (a -> a) -> a
13:31:41 <ski_> @hoogle (s -> (s,a)) -> m a
13:31:42 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
13:31:42 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
13:31:42 <Peaker> quicksilver: but there's no <* for Monads, is there? (<< sequences right to left, right?)
13:31:54 <mmorrow> @type join id :: (a -> a) -> (a -> a)
13:31:55 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
13:32:06 <Cale> Peaker: Every monad is an Applicative.
13:32:14 <mmorrow> i guess that implies polymorphic kinds?
13:32:18 <ski_> modifyIORef : atomicModifyIORef :: modify : ?
13:32:21 <Peaker> Cale: Yeah, I know, but everything is duplicated still because of the lack of subclassing
13:32:27 <Peaker> int-e: yeah, what I wrote to quicksilver above:   get <* modify (+1)     and modify (+1) *> get
13:32:42 <centrinia> Does the expression (\x -> (x ap) const) allow Haskell to emulate the SK combinator calculus?
13:32:44 <Peaker> Cale: so I'd assume every function on applicatives would have another name for monads
13:33:14 <Cale> But apparently this isn't the case ;)
13:33:19 <ski_> @type const ap const
13:33:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:33:26 <ski_> @type ap ap const
13:33:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = b1 -> a -> b
13:33:28 <lambdabot>     Probable cause: `const' is applied to too few arguments
13:33:28 <lambdabot>     In the second argument of `ap', namely `const'
13:33:31 <mmorrow> @type \x -> id x x
13:33:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> t
13:33:33 <lambdabot>     Probable cause: `id' is applied to too many arguments
13:33:33 <lambdabot>     In the expression: id x x
13:33:34 <mmorrow> ah, that's why
13:33:44 <quicksilver> Peaker: no, I don't think the utility of <* was realised for a while
13:33:50 <quicksilver> Peaker: it's very handy in parsers
13:33:55 <quicksilver> (whether they be monadic or applicative)
13:33:56 <Peaker> @pl do { x <- f ; g ; return x }
13:33:57 <lambdabot> (line 1, column 4):
13:33:57 <lambdabot> unexpected "{"
13:33:57 <lambdabot> expecting variable, "(", operator or end of input
13:34:01 <Peaker> @undo do { x <- f ; g ; return x }
13:34:02 <lambdabot> f >>= \ x -> g >> return x
13:34:09 <Peaker> @pl f >>= \ x -> g >> return x
13:34:09 <lambdabot> (g >>) . return =<< f
13:34:16 <Cale> Control.Applicative feels a little bare still. There ought to be a few more interesting things one can do with an arbitrary Applicative. Perhaps Data.Traversable mostly makes up for it.
13:34:26 <mmorrow> i wonder what one would call the class of functions that can be applied to themselves legally under haskell's type system?
13:35:06 <Cale> mmorrow: Functions completely polymorphic in their first parameter?
13:35:07 <mmorrow> @type id id id id id id id const const const const const flip flip flip
13:35:09 <lambdabot> forall b a c. b -> (a -> b -> c) -> a -> c
13:35:24 <Cale> oh, flip, hmm
13:35:32 <Peaker> Cale: what do you feel is missing?
13:36:05 <mmorrow> Cale: that sounds like it's pretty much it, but i'm not sure
13:36:18 <Zero_In_Mood> damn lilac sure will overred my highlight with this big spamming.. thou i dont know what const really is doing in ur function and  how the thing with k actually is working out... ^.^
13:36:18 <centrinia> Does Lambdabot have a command that transforms expressions into applications of ap and const?
13:36:35 <Cale> centrinia: @pl ?
13:36:42 <Cale> er, well, that's not all it does.
13:36:43 <mmorrow> centrinia: that sounds like @pl give ir take a flip or ten
13:37:08 <mmorrow> oh yeah, @pl uses liftM* etc too
13:37:08 <centrinia> How do you write flip in terms of ap and const?
13:37:14 <opqdonut> centrinia: you can find translators for lambda calculus -> SK
13:37:19 <opqdonut> which is effectively the same
13:37:48 <mmorrow> centrinia: write a translator and it can be added to lambdabot as a plugin!
13:37:55 <centrinia> Yeah. :)
13:37:57 <mmorrow> @sk
13:37:58 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
13:38:03 <opqdonut> centrinia: ((S((S(K((S(KS))K)))S))(KK))
13:38:14 <mmorrow> @ski
13:38:14 <lambdabot> Maybe you meant: ask src wiki
13:38:21 <mmorrow> that one's free
13:38:38 <centrinia> @sk \x y z -> (x z) (y z)
13:38:38 <lambdabot> Consider it noted.
13:38:39 <Peaker> what functions can you build with ap and const?
13:38:52 <mmorrow> i winder wtf @sk is doing
13:38:55 <opqdonut> Peaker: all
13:38:56 <mmorrow> *wonder
13:38:56 <goober> Peaker: -Blah
13:38:58 <mauke> mmorrow: '@ask'
13:39:03 <mmorrow> ahhh
13:39:10 <int-e> @unpl ((ap((ap(const((ap(const ap)const)))ap))(const const))
13:39:10 <lambdabot> Unbalanced parentheses
13:39:38 <centrinia> Peaker: ap is the S combinator and const is the K combinator. :)
13:39:58 <int-e> @unpl ((ap((ap(const((ap(const ap))const)))ap))(const const))
13:39:58 <lambdabot> ((\ h i j -> i >>= \ g -> j >>= \ h -> return (h g h)) (\ k -> k) ((\ _ -> (\ _ aa ab -> aa >>= \ y -> ab >>= \ x -> return (y x)) >>= \ s -> (\ c _ -> c) >>= \ r -> return (s r)) >>= \ m -> (\ ag
13:39:58 <lambdabot> ah -> ag >>= \ ae -> ah >>= \ ad -> return (ae ad)) >>= \ l -> return (m l)) (\ _ e _ -> e))
13:40:15 <mmorrow> @pl ((ap((ap(const((ap(const ap))const)))ap))(const const))
13:40:15 <lambdabot> liftM2 (.) ap (const const)
13:40:18 <opqdonut> int-e: check the type
13:40:19 <opqdonut> rather
13:40:34 <int-e> opqdonut: I did now.
13:40:34 <Peaker> centrinia: I don't know the combinators very well :-)
13:40:39 <Peaker> goober: what?
13:40:48 <Peaker> oh
13:40:59 <centrinia> The SK combinators can be used to effect lambda calculus.
13:41:49 <mmorrow> and they're turing complete
13:41:59 <mmorrow> well, s/and/thus/
13:42:10 <mmorrow> (and vice-versa)
13:42:41 <mmorrow> ((vice-versa as in "the lambda calculus can be used to effect the sk combinators))
13:42:46 <centrinia> @type (ap id id (ap id id))
13:42:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
13:42:48 <lambdabot>     Probable cause: `id' is applied to too few arguments
13:42:48 <lambdabot>     In the second argument of `ap', namely `id'
13:43:06 <mmorrow> too bad \bot doesn't have unsafeCoerce in scope
13:43:18 <centrinia> That's unsafe.
13:43:22 <centrinia> @unpl (ap id id (ap id id))
13:43:23 <lambdabot> ((\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ a -> a) (\ b -> b) ((\ c -> c) >>= \ l -> (\ d -> d) >>= \ k -> return (l k)))
13:43:23 <mmorrow> heh
13:43:23 <ozy`> and coercive
13:43:35 <ehird> I have some awful-looking code that as a bonus none of you will understand. Anyone have some tips on making it less ugly? :P http://hpaste.org/12698
13:43:40 <mmorrow> we could at least have it in scope for @type
13:43:47 <tromp> S (K (S (K (S S (K K))) K)) S also works as flip
13:44:57 <mmorrow> @type \f -> let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z
13:44:58 <lambdabot> Not in scope: `unsafeCoerce'
13:45:02 <mmorrow> (a -> b) -> b
13:45:07 <centrinia> ehird: Transform your code into pointless form to make it beautiful. :)
13:45:07 <mmorrow> the Y combinator
13:45:13 <mmorrow> (it works safely too :)
13:45:20 <ehird> centrinia: Shush you. :P
13:45:35 <mmorrow> but i looked at the asm and fix compiles more efficiently
13:45:46 <mmorrow> ooh, actually this is interesting:
13:46:02 <mmorrow> i looked at the asm for different fix variants:
13:46:09 <mmorrow> fix f = let x = f x in x
13:46:15 <mmorrow> fix f = f (fix f)
13:46:33 <mmorrow> and the one with "let" compile to /way/ more efficiewnt code than the other one
13:46:47 <conal> quicksilver: ping.  i'm finally ready.
13:46:53 <mmorrow> i think because "let" is a fundamental/basic construct in the STG language/machine
13:47:12 <lament> everything should be as pointless as possible, but no pointlesser.
13:47:14 <centrinia> That's pretty spineless, and tagless. :(
13:47:23 <Peaker> wow, emacs can show pdf's now
13:47:37 <ozy`> Peaker: it couldn't already?
13:47:43 <conal> Peaker: it can?!
13:47:46 <wchogg> Peaker:  how?
13:47:50 <cjb> Peaker: ooh, how?
13:47:58 <wchogg> We demand to know!
13:48:01 <conal> Peaker: i just discovered that i can view png files in emacs.  wild!
13:48:01 <Peaker> ozy`, conal, wchogg, cjb: A "DocView" elisp module, apparently
13:48:02 <centrinia> @pl \f -> let x = f x in x
13:48:02 <lambdabot> fix
13:48:10 <centrinia> That's pretty pointless.
13:48:11 <conal> wowzers
13:48:12 <Peaker> conal: oh, those I was viewing for a long while :-)
13:48:21 <conal> Emacs == God
13:48:38 * centrinia starts a holy war by mentioning yi and vi.
13:48:39 <conal> Peaker: i'm behind the times, apparently. ;)
13:48:57 <ozy`> ehird: I'm not sure how much you can do to beautify code that uses record syntax. they're pretty clumsy in Haskell
13:49:07 <Peaker> conal: the truncation problem was solved, btw
13:49:08 <ehird> ozy`: heck, it's not even the record syntax
13:49:11 <Peaker> conal: gonna post a new image soon
13:49:12 <ehird> it's more the clump of stuff below
13:49:17 <ehird> with the horrible wrapping and suc
13:49:18 <ehird> h
13:49:22 <conal> Peaker: super.  how'd you do it?
13:49:45 <ehird> http://hpaste.org/12698#a2 barely improved, but a bit thanks to oerjan
13:49:46 <ozy`> ehird: wrap right after the = and indent a couple spaces, then
13:49:54 <Peaker> conal: Apparently I missed a -C switch in the RTS switches to change the truncation length. That made the graph too small though, so hp2ps has a -M switch to separate the key/legend to a separate page
13:50:07 <ehird> ozy`: lines are still too long and have to wrap
13:50:11 <conal> Peaker: swell
13:50:12 <ehird> and I can't get them to wrap in any non-ugly way
13:50:31 <Peaker> conal: 80 is still too short a truncation, heh trying 100
13:50:43 <centrinia> @pl \i -> show i ++ " crop"
13:50:43 <lambdabot> (++ " crop") . show
13:50:48 <mmorrow> without the {-# NOINLINE z #-} in
13:50:50 <mmorrow> \f -> let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z
13:50:50 <conal> Peaker: heh
13:50:54 <mmorrow> the simplifier loops
13:50:59 <conal> Peaker: try 10^6
13:51:21 <Peaker> conal: :-)
13:51:27 <conal> heh
13:51:55 <wchogg> Peaker:  you're doing some profiling?
13:51:57 <conal> Peaker: serves us right for programming at multiple levels of abstraction.
13:52:07 <ehird> http://hpaste.org/12698#a3 IMO, even uglier
13:52:13 <Peaker> wchogg: yeah
13:52:38 <Peaker> conal: yeah, debugging multiple levels of abstraction all at the same time is difficult
13:53:02 <leadnose> ehird, I've found that aligning the "::" in records makes them look acceptable
13:53:08 <centrinia> Get an WHUXGA compatible screen to use 10^5 x 10^3 character terminals. :)
13:53:20 <ehird> leadnose: I'm talking about the stuf fbelow the record definitions
13:53:48 <conal> centrinia: holy frak.  i hadn't heard of WHUXGA.
13:54:15 <conal> centrinia: and now i want one!
13:54:19 <centrinia> It is just 7680x4800 pixels.
13:54:34 <conal> yow.
13:54:50 <centrinia> 37 megapixels is not that much.
13:54:53 <wchogg> Peaker:  which issue are you working on?
13:55:04 <conal> centrinia: it's *exactly* that much.
13:55:36 <Peaker> wchogg: I want to debug accumulating slowness that I have with a pune game clone. But I am debugging what seems to be a memory leak instead, first (easier), also, maybe its the same issue
13:56:16 <Peaker> imageshack sucks. Any good image hosting site to place profile graphs?
13:56:48 <ehird> Peaker: xs.to, imagesocket.com, they're a dime a dozen
13:56:52 <mauke> I don't know how good bayimg.com is
13:57:03 <ehird> mauke: that's run by the pirate bay peeps
13:57:14 <mauke> yes
13:57:41 <pumpkin_> dons: my RWH came in :D
13:58:20 <Peaker> imageshack is as slowa s hell
13:58:53 <pumpkin_> what cabal package provides CReal?
13:59:03 <Zero_In_Mood> btw u re still up to nice n fuckin ugly function with tree in haskell i still got one task left..
13:59:15 <pumpkin_> ?
14:00:05 <Sgeo> Thank you, mysterious Cznpy person
14:00:52 <Peaker> conal: http://bayimg.com/image/mamfjaabe.jpg  http://bayimg.com/image/mamflaabe.jpg
14:01:05 <ehird> Peaker: png!! png!!
14:01:21 <ozy`> Sgeo: wait, are you Sgeo?
14:01:29 <ehird> <ozy`> Sgeo: wait, are you Sgeo?
14:01:32 <opqdonut> aagh the quality
14:01:35 <opqdonut> it burns my eyes
14:01:37 <ehird> that is some question
14:01:55 <Peaker> conal: and the code is: http://hpaste.org/12699
14:02:00 <ozy`> ehird: it certainly was in the interrogative mood
14:02:12 <ehird> ozy`: wat
14:02:50 <Sgeo> I'm going to assume that ozy` thinks he knows a Sgeo from someone, and I'll just ask "Where?"
14:02:52 <conal> Peaker: great!  the whole call stack is there for yellow.
14:03:19 <ozy`> Sgeo: !trope Most Definitely Not A Villain
14:03:25 <Peaker> conal: My understanding of ghc's operational semantics is very limited
14:03:36 <Peaker> conal: why is fmap name-mangled?
14:03:45 <Sgeo> ozy`, I do go into SlashNET#tropers sometimes
14:04:20 <conal> Peaker: dunno.  maybe because it's a dictionary, i.e., there are a lot of different fmap functions.
14:04:32 <conal> s/it's a/it's in a/
14:04:49 <Peaker> so methods are in general mangled for each specific instance implementation, I see
14:05:02 <conal> Peaker: i'm just guessing.
14:05:06 <quicksilver> conal: well I'm still chasing it through, I can't quite articulate the entire problem
14:05:14 <Sgeo> ozy`, is that what you meant?
14:05:22 <quicksilver> conal: (let r = 0 `Stepper` (snapshotWithR (+) r mempty) in r)
14:05:29 <ehird> http://hpaste.org/12698#a6 Getting there. I guess.
14:05:32 <quicksilver> conal: this is the simplest example which clearly should work.
14:05:43 <ozy`> Sgeo: yes :p
14:05:49 <Sgeo> ah
14:06:03 <quicksilver> conal: the 'mempty' will never occur, of course, but somehow the code 'needs to check' if r is going to shift before that.
14:06:07 <conal> quicksilver: k
14:07:01 <quicksilver> conal: part of this is joinE because snapshotWithR uses catMaybesE which uses joinE
14:07:24 <conal> quicksilver: oh, yeah.
14:07:31 <quicksilver> conal: informally I think the problem is that catMaybes doesn't communicate the non-occurence of the Nothings that it filters out
14:07:42 <quicksilver> conal: rather, catMaybes does nothing until it gets its first Just.
14:07:46 <quicksilver> conal: ..which is too late
14:07:59 <Sgeo> ozy`, in tropers, are you ozy` or someone else?
14:08:20 <conal> quicksilver: i'm missing context.  in "the problem is ...", what problem?
14:08:24 <Peaker> conal: another profiling session (-hd instead -hC) looks the same, except for the names, and the culprit(yellow) is named PrimReactive.sat_swT3
14:08:33 <conal> quicksilver: nontermination?
14:08:49 <conal> Peaker: "sat".  hm.
14:08:51 <quicksilver> conal: yup, that reactive just hangs.
14:09:04 <conal> oh, okay.
14:09:09 <conal> quicksilver: which reactive?
14:09:14 <quicksilver> conal: I can't even observe the apparently safe initial 0
14:09:18 <quicksilver> conal: (let r = 0 `Stepper` (snapshotWithR (+) r mempty) in r)
14:09:39 <quicksilver> conal: that seems to me to be the simplest recursive snapshot which ought to work.
14:09:46 <ehird> anyone who can improve on http://hpaste.org/12698#a6?
14:09:49 <Peaker> conal: what's "I doubt these definitions work well.  They accumulate reactives without aging them" about?
14:10:29 <conal> Peaker: refers to the defs above.  Will clarify.
14:11:02 <quicksilver> conal: I think maybe this means I need improving times after all. (I'm not currently using anything like that)
14:11:20 <quicksilver> conal: because improving times are a way for catMaybesE to communicate non-occurrence 'early'
14:11:32 <conal> quicksilver: yeah.
14:11:36 <FunctorSalad> can Typeable deal with classes somehow?
14:11:59 <quicksilver> conal: although interestingly I have all sorts of things which do work, with my model ;)
14:12:04 <quicksilver> conal: just not recursive ones.
14:12:08 <conal> quicksilver: it's also why i don't use lists to represent events.
14:12:42 <quicksilver> inability to communicate non-occurrence?
14:13:04 <FunctorSalad> (say, cast :: (Typeable a, Show b, Typeable b) => a -> Maybe b
14:13:06 <FunctorSalad> )
14:13:29 <conal> quicksilver: because the list rep has empty and non-empty but no partial information in-between
14:13:37 <quicksilver> conal: *nod*
14:13:55 <FunctorSalad> hmm, wait. that sig I wrote seems pretty useless
14:14:04 <conal> quicksilver: event mappend would have to force nil-ness vs cons-ness too soon.
14:14:18 <FunctorSalad> should be cast :: (Typeable a) => a -> Maybe ExistentialShow
14:14:22 <quicksilver> FunctorSalad: AFAICR you can make existential wrappers typeable, so you can pass around a 'Showable'
14:14:25 <conal> quicksilver: i'm not delighted with my solution, btw.
14:14:41 <quicksilver> conal: which part fails to delight you?
14:14:49 <FunctorSalad> quicksilver: yeah, but Strings won't cast to ExistentialShow :(
14:14:58 <eu-prleu-peupeu> hello Hppl
14:15:10 <eu-prleu-peupeu> real world haskell still haven't arrived :/
14:15:24 <quicksilver> FunctorSalad: what you appear to want isn't possible.
14:15:32 <quicksilver> FunctorSalad: the information that something is showable has been lost.
14:15:36 <quicksilver> unless you save it.
14:15:44 <conal> quicksilver: nothing ever follows an infinite-time occurrence.  but that property isn't statically enforced.
14:16:08 <yitz> ehird: looks fine to me. Are you competing in a beauty contest?
14:16:11 <conal> quicksilver: also, the value at infinite time has to always be the same.
14:16:21 <quicksilver> conal: *nod*
14:16:23 <ehird> yitz: nope... but it looks ugly to me :\
14:16:27 <FunctorSalad> quicksilver: doesn't the Typeable instance hold such data? :) but I suppose we'd need quantification over typeclasses for that
14:16:28 <conal> quicksilver: or the monoid identity law fails.
14:16:37 <yitz> ehird: what's bothering you?
14:16:40 <conal> quicksilver: which QC discovered for me.
14:16:46 <ehird> yitz: not sure; just the general structure seems a bit ad-hoc.
14:16:59 <conal> quicksilver: so the representation contains "junk"
14:17:03 <quicksilver> FunctorSalad: no. Typeable just has a TypeRep which it can compare.
14:17:13 <quicksilver> FunctorSalad: there is no way of telling if a TypeRep represents a showable type.
14:17:21 <conal> quicksilver: besides.  it's clever, and i like simple & inevitable.
14:17:24 <yitz> ehird: in terms of the structure itself, hard to know without seeing what you want to do with it.
14:17:28 <quicksilver> conal: ;)
14:17:33 <Zero_In_Mood> since lilac is afk maybe one can short explain the const and why the constellation with k S xs is workin or how exactly it is workin at my hpaste ?
14:17:37 <ehird> yitz: well, that function as-is is pretty much it
14:17:39 <yitz> ehird: you seem to be fiddling with the cosmetics a lot though.
14:17:42 <quicksilver> conal: I will keep digging at this problem. I think there shuld be a simpler example
14:17:45 <Zero_In_Mood> http://hpaste.org/12697#a5
14:17:46 <FunctorSalad> data TypeRep = TypeRep { ... [classRep] ... } -- ? ;)
14:18:15 <conal> quicksilver: yeah.  though this is a good one so far.  just so i'm clear, you tried it in your implementation and not in mine?
14:18:16 <FunctorSalad> oh well, I'll find some workaround :)
14:18:25 <ehird> yitz: yeah... it's just that al lthe haskell code i've written always looks ugly to me, not like most haskell i've seen
14:18:53 <quicksilver> conal: yes, I haven't tried it in yours.
14:19:01 <quicksilver> conal: I would be interested if someone does.
14:19:23 <yitz> ehird: only thing I can think of is:
14:19:27 <yitz> Currency { name = name, holdings = 0, rate = Just 10 }
14:19:39 <yitz> can be changed to
14:19:51 <ehird> it's mostly the functions after that that bother me
14:20:53 <yitz> let blank = Currency { name = undefined, holdings = 0, rate = Just 10} in [ blank {name = name} | name <- names]
14:21:33 <yitz> ehird: it all seems simple and clear enough. I wouldn't spend any more time on it.
14:22:12 <Cale> ehird: What is this program, out of curiosity?
14:22:37 <ehird> Cale: I'd tell you if I had an hour to tell you. :P
14:23:08 <yitz> Cale: looks like something to do with optimizing political gain in return for payoffs
14:23:30 <ozy`> Cale: there's actually a diagram of it here: http://p.hagelb.org/cssh-crazy.png
14:23:31 <Cale> yitz: and music? :)
14:24:01 <yitz> Cale: everyone has to have a jingle nowadays
14:24:10 <Sgeo> Cale, it's a bank in a game
14:24:29 <Sgeo> the PBA is a bank with adjusting rates. People can deposit stuff, and get coins for the deposit
14:24:30 <ehird> Sgeo: what?
14:25:06 <Sgeo> People can then trade coins, or use those coins to withdraw other stuff in the PBA
14:25:31 <Sgeo> The rates in the PBA, as opposed to the competeting RBoA, automatically adjust
14:25:40 <yitz> it's a script kiddie bot?
14:25:57 <Sgeo> (btw, the PBA manufactures coins on a deposit, and destroys them on a withdrawa)
14:26:03 <Sgeo> yitz, what?
14:26:51 <Sgeo> http://agora-notary.wikidot.com/the-people-s-bank-of-agora is the PBA's contract
14:26:58 <yitz> that screen shot looks like scores of simultaneous ssh login attempts
14:28:06 <yitz> Sgeo: does the PBA ever get a cash infusion from the US Federal Reserve?
14:28:14 <Sgeo> yitz, it's a bank IN A GAME
14:28:26 <yitz> Sgeo: got it.
14:28:49 <conal> Peaker: i'm reading your Pune code now
14:29:01 <Sgeo> Hi aik
14:29:03 <Sgeo> erm ais523
14:29:14 <Peaker> conal: great, remember I'm an FRP newbie :-)
14:29:21 <ais523> Sgeo: it seemed easier to watch the discussion here than have you paste it to another channel every 10 seconds
14:29:29 <Sgeo> sorry
14:30:22 <ais523> but yes, the Perl bot for playing that particular game keeps getting confused, I hope the Haskell bot will do better
14:30:22 <conal> Peaker: np.  and you're ahead of most folks.
14:30:37 <Peaker> conal: Oh, I forgot that I added an event to reactive-glut to get this working (For key ups)
14:31:22 <conal> Peaker: cool.  would you send me a darcs patch?
14:31:29 <conal> i love getting help with this stuff.
14:31:43 <ais523> yay, I seem to keep ending up in channels full of darcs users nowadays
14:31:50 <ais523> although I suppose in #haskell that isn't particularly surprising
14:32:30 <Peaker> conal: sure, but I think its a bit ad-hoc, though GLUT is kind of broken (delivers fake key up events before each key down for each typematic repeat)
14:33:43 <pumpkin_> @hoogle CReal
14:33:44 <lambdabot> No results found
14:33:56 <Peaker> conal: how do I see the diff between my darcs repo and the upstream? (after I committed locally)
14:34:52 <Peaker> conal: (to see my reactive-glut patch and contribute that)
14:44:08 <conal> Peaker: what's "upstream"?
14:44:22 <Peaker> conal: the branch its pulling from
14:45:28 <conal> Peaker: to compare your change with whatever i've done since?
14:46:24 <Peaker> conal: to see what patches I have recorded locally that are not in the code.haskell.org repo
14:46:49 <conal> Peaker: i'd love to know the answer to that question.
14:47:04 <conal> Peaker: probably someone on #darcs could answer in a flash.
14:47:43 <tibbe> @seen dcoutts
14:47:43 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 4h 42m 38s ago.
14:48:12 <mm_freak> in Monad m => m a, what is a good notion for the type 'a'?
14:48:12 <tibbe> dcoutts: do you know how Data.Text is coming along?
14:48:22 <mm_freak> i'm currently referring to it as the "inner type"
14:48:41 <opqdonut> type parameter
14:48:59 <Saizan> Peaker: if you've done a record then you can darcs send to see the patches that aren't in the remote repo
14:49:12 <Peaker> Saizan: darcs send is insisting on actually using sendmail
14:49:43 <mm_freak> opqdonut: i mean, specific for monads‚Ä¶  i'd like to refer to it by a notion in a tutorial
14:49:45 <Saizan> Peaker: darcs send -O
14:50:02 <mm_freak> like "it adds structure to the inner type ‚Ä¶"
14:50:30 <opqdonut> mm_freak: inner type is ok
14:50:35 <opqdonut> how about encapsulated type?
14:50:38 <opqdonut> contained type?
14:50:40 <opqdonut> modified type?
14:50:46 <Peaker> Saizan: is it possible for it to be in unidiff patch format?
14:50:56 <dons> anyone else notice how little has changed in the latest ocaml release, vs the latest ghc release?
14:51:03 <mm_freak> hmm‚Ä¶  encapsulated type sounds good
14:51:11 <opqdonut> a bit technical perhaps
14:51:25 <mm_freak> yeah, i'll stick with "inner type", thanks
14:51:29 <monochrom> yeah, ocaml is mature.  *duck*
14:51:36 <mm_freak> seems like it's a good compromise
14:51:51 <opqdonut> monochrom: ITYM *ducks* ;)
14:51:55 <opqdonut> get your memes right
14:51:58 <monochrom> ghc or haskell still needs another paradigm shift before you can write a theorem prover in it.  *duck*
14:52:02 <mauke> no quack.
14:52:06 <ddarius> monochrom: That would work better if GHC wasn't itself mature.
14:52:20 <Peaker> Saizan: anyway, thanks
14:52:28 <opqdonut> ddarius: well it isn't!
14:53:14 <Peaker> conal: After messing around with git and darcs, I'm beginning to appreciate bzr's straightforward/simple UI more
14:53:20 <Saizan> Peaker: np, i don't know about unidiff
14:53:27 <Peaker> Saizan: as in diff -u format
14:54:07 <eu-prleu-peupeu> i like these kind of stories: Your Issuing bank has been unable to authorise payment with this card.
14:54:09 <eu-prleu-peupeu> oops
14:54:10 <eu-prleu-peupeu> lol
14:54:18 <eu-prleu-peupeu> i meant these: http://ocamlnews.blogspot.com/2008/11/stunning-slides-about-growth-of-ocaml.html
14:54:21 <lambdabot> Title: OCaml News: Stunning slides about the growth of OCaml at XenSource/Citrix, http://tinyurl.com/5ofjea
14:54:26 <eu-prleu-peupeu> its ocaml, but could easily be haskell
14:54:32 <Saizan> Peaker: yeah, i don't know if you can get that kind of output
14:54:59 <opqdonut> eu-prleu-peupeu: :D
14:55:00 <Cale> Peaker: bzr has a simpler UI than darcs?
14:55:11 <Peaker> Cale: IMO so far, it seems so
14:55:48 <Saizan> you can also use darcs changes -i to see what each patch is doing
14:56:11 <Peaker> Cale: bzr has diff/update/commit for workspace <-> branch,  and missing/pull/push for branch <-> branch,  and they work similarly
14:56:48 <mauke> what's a workspace/branch?
14:57:41 <Peaker> mauke: s/workspace/working tree (uncommitted changes)
14:58:12 <wchogg> Oh Citrix...
14:58:23 <wchogg> they used to be the bane of my existence
14:58:57 <opqdonut> err, xen is ocaml?
14:59:00 <opqdonut> or just a part?
14:59:37 <dons> i think the issue with ocaml now is the cathedral vs bazaar model.
14:59:46 <Peaker> Cale: missing tells you the diff between your branch and another branch, in terms of missing revisions in either side
14:59:52 <Botje> xen started at a university, so wouldn't surprise me
14:59:54 <dons> ghc is just moving an order of magnitude faster, because it is open
15:00:08 <dons> so we get in each yearly release the kind of features that are taking 5 years to get into ocaml now
15:00:49 <dons> game over.
15:01:09 <bos> darcs is simpler than bzr, and hg is about the same as darcs.
15:01:24 <Saizan> dons: steal them ML functors and we're set.
15:01:55 <dons> we got type families and GADTs, so we're fine.
15:02:05 <dons> more important by far is `par` and +RTS -N8
15:02:30 <Peaker> bos: what's the equivalent of "bzr missing"?
15:03:10 <bos> Peaker: in darcs? no idea.
15:03:38 <Peaker> bos: what would you say is more complex about bzr?
15:04:24 <bos> Peaker: in a meeting now, sorry
15:04:24 <Peaker> dons: what's -NB? I don't have it when I try: +RTS -?
15:04:43 <Peaker> oh that's 8, my font sucks :)
15:05:14 <Peaker> -N is not in -? either, but I can guess what that means :-)
15:06:21 <AnalogHole> Can anyone tell me how "runParser" works in this monad parsing example? http://hpaste.org/12700
15:06:27 <Saizan> it's the degree of awesomeness
15:06:38 <Peaker> 8 is not that awesome
15:06:42 <wchogg> Does it go to 11?
15:06:54 <AnalogHole> The turorial is not clear at all on how that part works. How does the type signature in newtype allow you to use runParser as a function?
15:06:59 <Peaker> conal: did you get the patch?
15:07:16 <mauke> AnalogHole: that's how records work
15:07:16 <hellige> Peaker: it's logarithmic, like warp speed in star trek
15:07:29 <hellige> Peaker: 10 would be infinity, so 8 is pretty good.
15:07:32 <mauke> data T = C { field1 :: Int, field2 :: Char }
15:07:40 <Peaker> hellige: warp 10 is the entire universe, according to The Final Unity
15:07:44 <mauke> now field1 :: T -> Int and field2 :: T -> Char
15:08:00 <hellige> Peaker: yeah, with -N10 ghc uses the entire universe to run your program. pretty sweet.
15:08:07 <AnalogHole> mauke: so how then do you use field1 ?
15:08:32 <mauke> field1 (C 42 'x') == 42
15:10:13 <Cale> AnalogHole: If it helps, using the record syntax like that is just like if it was defined like  newtype Parser a = Parser (String -> Either String (String, a))  together with a function  runParser (Parser x) s = x s
15:11:17 <AnalogHole> Cale: so is that sytactic sugar then? Allowing you to not have to implement a trivial function explicitly?
15:11:29 <Cale> AnalogHole: yeah
15:11:45 <Cale> AnalogHole: There are other things the record syntax allows for, but that's the main thing it's being used for here
15:12:21 <Cale> (It allows for easy 'updates', and pattern matching just some of the fields, in the case that there are many)
15:19:52 <AnalogHole> Ok, that makes sense, I guess.
15:20:52 <ksf> english punctuation is ambiguous, we should change it.
15:21:06 <ksf> "Through our experience with cubic packing, we know to look for an additional three planes of symmetry, characterized by a square distribution of vertices."
15:21:09 <BARACKOBAMA> in SDL, when you say quitHandler :: IO()
15:21:16 <BARACKOBAMA> what type is IO() ?
15:21:21 <mauke> IO ()
15:21:28 <mauke> what number is 4?
15:21:30 <wjt> ksf: you probably mean a colon not a comma after ambiguous :)
15:21:32 <Zero_In_Mood> input output
15:21:32 <ksf> that one parses as "(Through our experience with cubic packing) we know to look for an additional three planes of symmetry (characterized by a square distribution of vertices)."
15:21:42 <BARACKOBAMA> i know what IO means
15:21:53 <Zero_In_Mood> ah okay :)
15:21:53 <BARACKOBAMA> but the function getHandler has type IO? what does that mean
15:21:57 <Cale> BARACKOBAMA: IO () is a type. It's the type of IO actions which produce an empty tuple as their result.
15:22:03 <BARACKOBAMA> that is fantastic
15:22:04 <BARACKOBAMA> thank you
15:22:10 <ksf> speak of separation of syntax and semantics.
15:22:15 <Cale> quitHandler is not actually a function, but an action.
15:22:36 <BARACKOBAMA> gotcha
15:22:52 <ksf> well, I heard that chinese works like this: (english punctuation is ambiguous) we should change it
15:23:03 <pumpkin_> OMG WE HAZ BARACK OBAMA IN DA HOUSE
15:23:13 <BARACKOBAMA> i'm learning haskell
15:23:17 <BARACKOBAMA> so i can code a new government for y'all
15:23:26 <BARACKOBAMA> in SDL
15:23:47 <ksf> maybe I should switch to using parens instead of commata.
15:24:04 <mauke> just use ‚ÄΩ instead‚ÄΩ
15:24:20 <ksf> those look like flea droppings on my screen.
15:24:46 <pumpkin_> it's the interrobang
15:24:55 <pumpkin_> you need a UTF-8-capable irc client :D
15:24:56 <BARACKOBAMA> i wish i had an interrobang key
15:25:00 <BARACKOBAMA> oh wait
15:25:03 <BARACKOBAMA> xbindkeys :):):)
15:25:08 <ksf> it's utf8-capable.
15:25:37 <pumpkin_> ksf: then you're in the strange situation of having a system with no fonts on it that contain the interrobang, I guess ;)
15:25:46 <pumpkin_> or you aren't configured to use utf8 on this connection
15:25:59 <eu-prleu-peupeu> i find myself using Maybe quite often
15:26:20 <eu-prleu-peupeu> Maybe i shouldn't do that
15:26:39 <eu-prleu-peupeu> i mean, everything can "fail"... so...
15:26:46 <yitz> eu-prleu-peupeu: Then again, Maybe you should.
15:27:41 <ksf> ·ö†·ö¢·ö¶·ö®·ö±·ö¥
15:27:48 <blackh> eu-prleu-peupeu: I find myself using "yyy <- liftM (fromMaybe "") $ getField "yyy"" a lot
15:28:12 <blackh> ◊†◊î◊ì◊®!
15:28:13 <mauke> futhark!
15:28:28 <Saizan> yyy <- fromMaybe "" <$> getField "yyy"
15:28:47 <Saizan> ?type (<$>)
15:28:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:28:49 <eyeris> How can I compare a Word8 to a literal Char? (I'm trying to express isSpace for ByteStrings; surely this is available somwhere in the library)?
15:29:06 <blackh> Saizan: Thanks for that!
15:29:11 <mauke> ŒßŒ±œÉŒ∫ŒµŒªŒª
15:29:15 <ksf> ‰∑¢
15:29:25 <Saizan> eyeris: you want to use the interface at Data.ByteString.Char8
15:29:42 <Saizan> ?type chr . fromIntegral -- also
15:29:44 <ksf> hey that's not what i expected
15:29:44 <lambdabot> forall a. (Integral a) => a -> Char
15:30:08 * Saizan seen a square box
15:30:19 <mauke> U+4DE2 (e4 b7 a2): HEXAGRAM FOR PROGRESS [‰∑¢]
15:30:59 <eu-prleu-peupeu> the thing with Maybe is that i then use fromJust a lot
15:31:09 <eu-prleu-peupeu> which kind of... destroys the purpose of it
15:31:19 <nn-main> SamB,
15:31:27 <ksf> but it's yang-yin-yang-yin-yin-yin
15:31:30 <nn-main> SamB_XP,
15:32:42 <blackh> eu-prleu-peupeu: I have managed to avoid fromJust.  One thing you can do is fromMaybe (error "xxx"). I think that works.
15:32:51 <conal> Peaker: ping
15:32:57 <Peaker> conal: here
15:33:17 <eyeris> Saizan With Char8 I still have the problem that I can't write the constraint notSpace :: Char8 -> Bool
15:33:24 <Peaker> blackh: where'd you get the Hebrew "Great!" from? :)
15:33:31 <eyeris> because BS doesn't export Char8
15:33:41 <mauke> eyeris: there is no Char8 type
15:33:51 <eu-prleu-peupeu> are UArrays any good ?
15:33:52 <conal> i have a couple of comments on your game.  nothing deep.  one is to use vector2Polar in gvPosition.
15:33:54 <eyeris> Oh wait
15:33:55 <eyeris> I see
15:34:13 <blackh> Peaker: Well done. I am learning Hebrew. Here's "Haskell" in Hebrew:
15:34:18 <ksf> I got the interrobang, but it's vastly pixly and much too small to discern from a flee dropping.
15:34:21 <eu-prleu-peupeu> if i want to create a Texture data type, should i use them ?
15:34:32 <blackh> ◊î◊°◊ß◊ú
15:34:37 <eu-prleu-peupeu> can i define fmap for UArrays ?
15:34:46 <eu-prleu-peupeu> doesn't it break because they are strict ?
15:34:53 <eyeris> takeWhile in BS.Word8 takes (Word8 -> Bool) but takeWhile in BS.Char8 takes (Char -> Bool) so I can just use not.isSpace
15:34:54 <mauke> blackh: isn't that backwards?
15:34:59 <Peaker> blackh: I'm from Israel :)
15:35:46 <Peaker> conal: according to the type it seems like polar2Vector?
15:35:51 <blackh> mauke: Hebrew triggers latent dyslexia
15:36:09 <Peaker> Hebrew is read right-to-left
15:36:14 <conal> Peaker: according to the def.
15:36:27 <blackh> Peaker: I am from New Zealand - just learning Hebrew for the hell of it. :)
15:36:36 <conal> vector2Polar forwardSpeed dir
15:36:44 <mauke> u çop «ùpƒ±sdn p…ê«ù…π sƒ± …•sƒ±l∆Éu«ù
15:36:56 <blackh> mauke: I am impressed
15:36:57 <Zero_In_Mood> lol
15:37:04 <Zero_In_Mood> haskell in hebrew omfg...
15:37:06 <conal> Peaker: pos = integral (vector2Polar forwardSpeed dir)
15:37:38 <Peaker> conal: ah, cool
15:37:46 <conal> Peaker: i'd say "vel" instead of "delta", considering continuous time.
15:38:04 <Peaker> blackh: cool, if you need help with Hebrew there are some Israelis here :)
15:38:28 <conal> Peaker: also, i'd use uiIntegral from GLUTA
15:38:29 <Peaker> conal: yeah
15:39:02 <conal> Peaker: why does ticksGap count ticks?
15:39:20 <eu-prleu-peupeu> crazy stuff: http://www.geekologie.com/2008/11/gods_facebook_genesis_edition.php
15:39:24 <lambdabot> Title: God's Facebook: Genesis Edition - Geekologie, http://tinyurl.com/5hjcgm
15:39:35 <conal> Peaker: i think the count gets discarded by snapshot_
15:40:01 <Peaker> conal: yeah, I don't use it yet, but I thought I would
15:40:07 <Peaker> conal: I probably will
15:40:09 <conal> oh, okay.
15:40:12 <blackh> Peaker: Thanks. I am doing a big project in Haskell in my spare time and it's gobbled all my Hebrew study time up.
15:40:18 <ksf> I guess you have to be us american to laugh about it.
15:40:36 <Peaker> blackh: ◊ë◊î◊¶◊ú◊ó◊î ◊ë◊ú◊ô◊û◊ï◊ì◊ô ◊î◊¢◊ë◊®◊ô◊™!
15:41:09 <Peaker> conal: I was surprised the change to: FT.vector2Polar forwardSpeed <$> gDirection ticks ui    Just Worked :-)
15:41:25 <Peaker> conal: (I get it to compile on the first run more and more frequently, heh)
15:41:28 <conal> Peaker: :) !
15:41:42 <conal> Peaker: then there's the whole thing of using discrete time ticks at all.  i guess it's for growing your worm, which is segmented and accrues segments discretely.
15:42:02 <Peaker> conal: Yeah, also how do you use integral without it?
15:42:13 * ksf shudders
15:42:29 <conal> Peaker: for now uiIntegral.
15:42:41 <conal> Peaker: i want to eliminate the event aspect from integration.
15:43:02 <ksf> discrete time works well as long as you've got an upper bound on speed, which is the case.
15:43:12 <conal> Peaker: i guess  the discrete worm accumulation is inherent, but its rate has nothing to do with numerical integration rate.
15:43:20 <StoneToad> ksf: upper bound on speed?
15:43:23 <ksf> (at least at scales where i can pinch people)
15:43:27 <ksf> light speed.
15:43:51 <conal> Peaker: the nice thing about uiIntegral is that it's adaptive to complexity and machine burden.
15:43:56 <ksf> ...at least on scales where i can pinch people.
15:43:56 <conal> and machine speed.
15:44:18 <Peaker> conal: let me try using that...
15:44:24 <StoneToad> why does having an upper bound or not matter for discrete time
15:44:38 <ksf> because you get tunnel effects otherwise.
15:45:19 <conal> Peaker: when i get your reactive-glut code integrated, i can play with this code myself.
15:45:22 <ksf> something swooshing past an object it should collide with because it's too fast for the sample, i.e. frequecy of collision detection, interval.
15:45:33 <ksf> "frequency interval"...
15:45:41 <ksf> I'm going to let that one slip.
15:45:48 <StoneToad> oh right that kind of thing
15:46:02 <Peaker> conal: heh, yet another compiles on first run, lets see if it runs
15:46:22 <Peaker> conal: nope, this time it compiled and just hangs
15:47:13 <conal> hm
15:47:44 <Peaker> conal: does uiIntegral work ok?
15:48:10 <Peaker> conal: I changed both direction and position integrals to be uiIntegral, and that broke it
15:48:46 <conal> Peaker: hm.  i think so.
15:52:24 <conal> Peaker: how does the worm behave?  i.e., what movement?
15:53:53 <conal> Peaker: i'm guessing it's a growing, moving worm.
15:54:07 <Peaker> conal: Sorry, I killed the pune window but forgot its process thrashing
15:54:10 <Peaker> conal: killed my machine
15:54:16 <conal> Peaker: ouch
15:54:24 <Peaker> Amazing that Linux in 2008 still goes completely unresponsive if its memory thrashed
15:54:42 <Peaker> it can't even guarantee the console terminal enough resources to allow a login and a "kill" command
15:54:44 <Peaker> eventually I gave up
15:54:46 <Peaker> and rebooted
15:54:55 <conal> Peaker: wow
15:54:57 <ddarius> It's a conspiracy to get you to buy more memory.
15:54:59 <Peaker> The same is also true of Windows and Macs
15:55:21 <Peaker> No modern OS can handle memory thrashing except with ad-hoc quotas. That sucks.  Just guarantee some basic UI functionality :-(
15:55:50 <ksf> real time scheduling?
15:55:54 <ksf> cfq?
15:56:03 <ksf> *cfs
15:56:32 <ksf> nicing swapd?
15:56:49 <shepheb> my cabal-install wants base >= 4 for haskell-src-exts. does that mean I need 6.10.1?
15:56:59 <ksf> swapoff -a?
15:57:10 <Peaker> the problem, I think, is not CPU scheduling, but either guaranteeing a bit of locked RAM or reasonable disk I/O.  OS's can't guarantee either
15:57:15 <Cale> shepheb: apparently.
15:57:21 <Peaker> I guess swap is more damage than good
15:57:26 <Peaker> (with today's memory sizes)
15:57:37 <Cale> shepheb: You could also use an older version of the packages.
15:57:45 <Saizan> shepheb: you can cabal install haskell-src-exts-0.3.9
15:58:03 <jekor> How can I read a port number from a string? The PortNumber constructor is PortNum Word16. When I try to read :: Word16, instead of 80 I get 20480. Any ideas?
15:58:05 <conal> Peaker: one idea: use accumB instead of monoidB and see what what happens to memory use.
15:58:06 <ksf> not if you're running kde+firefox with 1g ram and don't want to have processes killed.
15:58:20 <shepheb> Saizan,Cale: okay, I'll go with 6.8-friendly versions
15:58:27 <ksf> multiple disks?
15:58:29 <Cale> jekor: Don't use the data constructor for PortNumber
15:58:44 <ksf> my swap partition isn't on my system disk...
15:58:52 <Peaker> conal: the uiIntegral broke it, gonna go back to using event-based integral
15:58:54 <conal> Peaker: e.g., mempty `accumB` (mappend <$> movingDisk ui)
15:58:58 <conal> Peaker: interesting.
15:59:09 <jekor> Cale: I get type errors if I don't.
15:59:13 <jekor> Oh...
15:59:21 <conal> Peaker: maybe uiIntegral is not as perf-adaptive as i thought.
15:59:32 <Peaker> conal: it seems to not work at all, not to work badly
15:59:43 <Cale> jekor: Read an Integer, and convert it with fromIntegral.
15:59:51 <Peaker> conal: it gets stuck and starts thrashing memory crazily, not drawing a single frame
16:00:00 <Peaker> conal: (and not responding to close-window events)
16:00:05 <jekor> Ah. Thanks.
16:00:09 <Cale> jekor: (or a Word16)
16:00:09 <conal> Peaker: that puzzles me.  except that it could be adaptive in the Borg sense of the word.
16:00:34 <jekor> Cale: That did the trick.
16:00:41 <olsner> hmmmm, Prelude.chr: bad argument
16:01:13 <ddarius> > 80*256
16:01:14 <lambdabot>   20480
16:01:32 <Cale> jekor: That module really should not export the PortNum constructor.
16:02:00 <Cale> jekor: That type takes care of the endianness issues.
16:02:27 <conal> Peaker: oh, also -- this program inevitably leaks space.   right?
16:02:33 <mmorrow> @let pair (<>) f g a = f a <> g a
16:02:34 <lambdabot>  Defined.
16:02:34 <conal> Peaker: i mean given what you want it to do.
16:02:45 <mmorrow> @let (.&&.) = pair (&&)
16:02:46 <lambdabot>  Defined.
16:02:47 <jekor> I think I understand.
16:02:54 <mmorrow> @let (.||.) = pair (||)
16:02:54 <lambdabot>   Parse error
16:03:05 <mmorrow> silly haskell-src-exts
16:03:08 <mmorrow> @let (.||.) = pair ( ||)
16:03:09 <lambdabot>  Defined.
16:03:25 <mmorrow> i thought mueval wasn't using haskell-src-exts anymore?
16:03:39 <Peaker> conal: Yeah, but games are short
16:03:44 <Peaker> conal: until a worm hits another worm or the wall
16:03:46 <Saizan> @let doesn't use mueval
16:03:47 <lambdabot>   Parse error
16:03:49 <Peaker> conal: then its restarted
16:03:52 <mmorrow> > unsafePerformGuillotine
16:03:53 <lambdabot>   Not in scope: `unsafePerformGuillotine'
16:03:56 <mmorrow> > unsafePerformIO
16:03:57 <lambdabot>   Not in scope: `unsafePerformIO'
16:04:00 <Peaker> conal: (collision detection is not yet implemented, heh)
16:04:04 <conal> Peaker: oh, okay.  and it leaks more than you'd expect?
16:04:35 <mmorrow> Saizan: ah, weird then
16:04:47 <Peaker> conal: With uiIntegral, it renders my machine unusable in 2 minutes heh
16:04:56 <Peaker> conal: without it, I am not sure
16:05:14 <conal> Peaker: oh!  sure it would.
16:05:23 <conal> because you're leaking per tick
16:05:27 <mmorrow> Saizan: i wonder why @let is having that parse error. haskell-src-exts has it because they modifed the parser to parse regular patterns and other random things
16:05:30 <Saizan> mmorrow: it parses the code before appending it to L.hs, not sure why that's needed though
16:05:37 <conal> and uiIntegral is adaptive.  it ticks faster, so leaks faster.
16:05:47 <Saizan> mmorrow: it does use haskell-src-exts
16:05:48 <mmorrow> ah, so parses it with haskell-src?
16:05:50 <conal> Peaker: oh, but you said you don't get any frames shown?
16:06:34 <Peaker> conal: right, but if I leave it running (showing nothing but a mal-drawn window) it kills my machine in 2 minutes
16:06:43 <Peaker> conal: even if I use xkill on the window the process continues leaking
16:06:57 <Peaker> conal: why am I leaking per tick?
16:06:58 <mmorrow> that's odd that haskell-src has that problem. in haskell-src-exts it was due to shoehorning (| ... |) in there
16:07:05 <shepheb> building hoogle is failing for me; I seem to need ~/.cabal/share/doc/hoogle-4.0.0.5/docs ... what is supposed to be there?
16:07:08 <conal> Peaker: my theory doesn't seem to fit what you're observing.
16:07:14 <Saizan> it's using haskell-src-exts since haskell-src has the unicode bug
16:07:23 <mmorrow> ah, heh
16:07:45 <Saizan> i guess haskell-src-exts should have a configurable parser
16:07:48 * mmorrow deletes all that extra stuff from his haskell-src-exts
16:07:57 <Saizan> with options to enable the special syntax
16:08:11 <conal> Peaker: i'm out of ideas. :(
16:08:18 <mmorrow> Saizan: that's a good idea
16:08:34 <Saizan> not sure how easy that is with happy
16:08:35 <conal> Peaker: though i'm curious about accumB vs monoidB/scanlB here.
16:08:42 <conal> Peaker: they work quite differently.
16:09:16 <Peaker> ok, I'll try accumB in a sec, trying to use uiIntegral on each of the integrals separately
16:09:22 <conal> Peaker: accumB ought to apply in this case, since your pieces are static.
16:09:27 <conal> oh, ok
16:09:29 <Peaker> conal: I changed just the direction integral to be uiIntegral and I got the first frame drawn before the same effect
16:10:06 <mmorrow> Saizan: heh, the happy parser is hellish (well, the haskell /syntax/ i should say) to add things to, but i think it'd be not that hard to #ifdef that extra syntax in Parser.y
16:10:13 <conal> Peaker: just one frame.  hm.  maybe it's a ghc scheduling thing.
16:10:15 * mmorrow doesn't volunteer ;)
16:10:21 <conal> Peaker: just a guess
16:10:48 <Peaker> conal: ok, changing just the pos to uiIntegral get the same effect as changing both
16:10:55 <Saizan> mmorrow: well, i meant configurable at runtime, not compile time
16:11:00 <Peaker> conal: I am not compiling/running with -threaded, btw, is that necessary?
16:11:27 <mmorrow> Saizan: oh. impossible without hacking the /generated-from-happy/ haskell code
16:11:34 * mmorrow runs
16:11:48 <mmorrow>  /that/ would be totally hellish
16:11:55 <conal> Peaker: i don't think so.  not sure.
16:12:02 <conal> Peaker: oh -- running under ghc or ghci?
16:12:12 <Peaker> conal: ghc
16:12:22 <Peaker> conal: I think I didn't compile with -O2 recently...
16:12:32 <conal> Peaker: i've not tested much other than under ghci
16:12:46 <conal> Peaker: and i think ghci acts like -threaded.
16:13:02 <conal> Peaker: would you compile -threaded and let me know?
16:13:16 <Peaker> sure
16:13:23 <conal> Peaker: also try running under ghci.
16:13:24 <Peaker> seems to behave the same
16:15:49 <mmorrow> @let swap = uncurry (flip (,))
16:15:50 <lambdabot>  Defined.
16:15:55 <Peaker> conal: what about the glut patch again?
16:17:04 * ksf tries to find the page that described that experiment that showed that an electron chooses to be electron or wave before it's forced to be observed as such.
16:17:17 <ksf> *particle
16:17:25 <ksf> see what chemistry did to me?
16:17:36 <opqdonut> double-slit?
16:17:44 <ksf> related, yes.
16:18:14 <ksf> the point was the instant of time the decision is made.
16:19:07 <ksf> iirc, an electron chooses to be one or the other way before it can tell what it should be.
16:19:10 <mmorrow> what do you mean by "choose"?
16:19:26 <ksf> lemme finish
16:19:39 <mmorrow> ok
16:20:16 <ksf> what either means that causality can be retro-fitted into time, or that it is really both or some super-concept of both, and does not need to decide what it is, after all.
16:20:33 <ksf> actually, I can't think of a good explanation of "choose".
16:20:59 <wchogg> ksf:  It doesn't choose.  It's a particle whose dynamics is governed by wave mechanics.
16:21:21 <ksf> that's one interpretation, yes.
16:21:37 <wchogg> Well, that's the math.
16:21:44 <ksf> I just remembered that I was impressed by the result and now challenge my own interpretation of it.
16:21:52 <ksf> well, math _is_ an interpretation.
16:22:22 <ksf> ...or model, doesn't matter in this case.
16:22:22 <SamB_XP> of quantum mechanics ?
16:22:27 <SamB_XP> not really ...
16:22:46 <mmorrow> isn't an electron what an electron is, and using our systems of mathematics applied to them /we/ can't decide what it is because the math "works" if we consider an electron to be a wave and likewise if we consider it to be a particle?
16:23:04 <ksf> nope it's not only math.
16:23:19 <ksf> you can really observe it behaving differently if you observe it differently.
16:23:26 <mmorrow> well, that's the only way we can say anything about electron, no?
16:23:28 <ksf> as in cinema-sized screen.
16:23:39 <mmorrow> *electronS
16:23:53 <SamB_XP> ksf: are you saying that it matters what kind of popcorn you eat or what kind of soda you drink as you watch the screen ?
16:24:29 <Peaker> conal: it seems to slow down more slowly (good thing) with accumB
16:24:35 <Peaker> conal: but its still noticably slowing down
16:24:43 <ksf> that is, if you had an appropriate double-slit experiment inside your crt tv, you'd see interference patterns, just like overlapping circles from two stones dropped into a fluid.
16:25:12 <SamB_XP> ksf: but then how would you use it to play gamecube ?
16:26:15 <ksf> I don't have a tv.
16:26:31 <SamB_XP> ksf: that makes it EVEN HARDER!
16:27:05 <ksf> i still have an analogue tv card somewhere, though.
16:27:11 <ksf> http://www.youtube.com/watch?v=DfPeprQ7oGc
16:27:14 <lambdabot> Title: YouTube - Dr Quantum - Double Slit Experiment
16:27:18 <mmorrow> why can't an electron be both? (i mean, the concept of a "particle" and of a "wave" are human construct after all)
16:27:41 <luqui> an electron is a solution to the schroedinger equation :-)
16:27:44 <SamB_XP> it can ;-P
16:27:58 <SamB_XP> it IS
16:28:01 <ksf> footballs don't create interference patterns.
16:28:21 <SamB_XP> because of their miniscule wavelength
16:28:26 <wchogg> Although I hate saying it's both a particle & a wave.  I think that tends to confuse the hell out of people.  That's why I was trying to make a distinction & say that it's a particle whose dynamics is wave-like.
16:28:53 <Peaker> I think the wave and the particle are in fact distinct, at least from all explanations I got.  The wave is the function that tells you where the particle is likely to be found, statistically.. So Electron is a   Behavior (Position -> Probability)
16:28:57 <wchogg> Elementary particles are point-particles, with no spatial extent that we can tell.
16:29:06 <mmorrow> heh, of course an electron isn't /actually/ a particle as in a litle beach ball, nor is it a wave as in a vibrating string
16:29:13 <ksf> that video's great, btw.
16:29:15 <Peaker> wchogg: type Electron = Behavior (Position -> Probability)
16:30:04 <ksf> but not if you stare hard enough at the slits...
16:30:26 <mmorrow> and while having dropped enough acid?
16:30:30 <mmorrow> ;)
16:31:27 <Peaker> I read some books by professors, and it seems even physics' PhD's understand QM worse than my superficial understanding (claiming things like QM implies that intelligent observers are special, physics-wise, because of the observation effect")..
16:31:41 <mmorrow> what was the experiment using some kind of metal where photons hitting the metal eject electrons?
16:32:08 <wchogg> mmorrow:  photoelectric effect
16:32:17 <mmorrow> ah yeah, that's the one
16:32:28 <wchogg> Peaker:  Don't take pop-physics for what working researchers think
16:32:31 <Philippa> Peaker: there were some idiot philosophers who ran with that idea, which has a lot to do with why it's persisted :-(
16:32:47 <ksf> like, Heisenberg?
16:33:08 <luqui> ugh, that Dr Quantum video pisses me off the same way what the bleep does...
16:33:22 <luqui> "simply by observing" = "whacking the electron with a photon"
16:33:28 <pumpkin_> dr quantum is awesome!
16:33:29 <wchogg> Quantum mechanics is all about teh linear algebra.  It's not nearly as spooky as people try to make it seem.
16:34:34 <ksf> there's no continuity in qm.
16:34:48 <luqui> ksf, what!?
16:34:49 <Peaker> Philippa: I guess a PhD does not mean much..
16:35:18 <Peaker> luqui: there are some funkier effects than actually whacking the electron with a photon directly, iiuc
16:35:30 <jekor> Is there a way to tell if send/recv (Network.Socket) are operating lazily, and if so, to force strictness?
16:35:35 <ksf> google "define quanta": discrete units of energy.
16:35:36 <Peaker> luqui: observations that are more subtle/indirect also collapse the wave function
16:36:28 <ksf> jekor, IO actions are strict, except hGetString.
16:36:31 <luqui> Peaker, sure, it's a beautiful fundamental piece of mathematics.  but "whacking it with a photon" is the essence: you can't measure something without affecting it
16:37:02 * pumpkin_ haz invisibul ruler
16:37:10 <jekor> I guess I have another issue then.
16:37:10 <pumpkin_> *intangibul
16:37:16 * edwardk waves hello.
16:37:22 <ksf> line buffering?
16:37:34 <ksf> missing flushes?
16:37:46 <ksf> wait... that should only be nescessary with handles.
16:37:49 <Peaker> luqui: you can measure some other thing which interacted with that electron before, and if you can deduce information about the electron from that, it will also collapse its wave function (iiuc)
16:38:32 <ksf> http://www.youtube.com/watch?v=G5poD3nXdJ8&feature=related
16:38:33 <lambdabot> Title: YouTube - What is Quantum entanglement
16:38:37 <Peaker> luqui: the nice example I read about is the slit experiment -- with a detector in one of the slits.  If you take the subset of the experiments in which the detector detected nothing
16:39:04 <Peaker> luqui: You'd intuitively say the detector is essentially "not there" if it detected nothing in those experiments, right?
16:39:09 <luqui> Peaker, no
16:39:33 <luqui> Peaker, I wouldn't.  it detected an absense of something, right?
16:39:45 <Peaker> luqui: yep. But there's no physical interaction
16:39:53 <Peaker> luqui: and its still measuring - thus affecting the wave function
16:39:56 <luqui> Peaker, of course there is.  it's just on the wave functions.
16:40:11 <ksf> One thing I discovered that makes understanding QM easier is assuming that space is a by-product of matter.
16:40:13 <Peaker> luqui: yeah, but no photon banging on an electron :-) no particles we know of at all
16:40:37 <polveroj> The Copenhagen interpretation feels like imperative programming to me, with wavefunction collapse a side-effect
16:40:43 <polveroj> I much prefer many-worlds
16:40:44 <luqui> Peaker, well what technique does the detector use?
16:40:48 <ksf> If it fails to explain stuff, it suceeds in nuking your preconceptions about space.
16:41:41 <Peaker> luqui: it captures the particle that would go through the slit, and beep if it got hit
16:42:27 <luqui> Peaker, so the particle never has a chance to go though that slit.
16:42:32 <ksf> so, what happenes if the detector is running but the beeper don't work?
16:42:48 <wchogg> I'm just going back to my prior advice.  It's linear algebra.  It works.  Don't spend too much brain power on what basic QM means.  The mind-breaking stuff comes in with attempts to quantize gravity in a way that's actually predicitive and/or mathematically correct.
16:42:50 <luqui> ksf, yeah!  Feynman.  It doesn't matter, still no interference!
16:43:16 <ksf> luqui, but you get protons shooting through both slits.
16:43:19 <Peaker> luqui: you could say the detector re-shoots another particle
16:43:24 <Peaker> luqui: that's identical to the first one
16:43:39 <luqui> Peaker, the ability to catch an electron is realized as a electric potential somewhere, which is changing the shape of the wave function
16:44:17 <erikc> is there a multiline string lib that does 'string interpolation' like ruby? (e.g. "this is the value of foo: ${foo}"
16:44:17 <SamB_XP> Peaker: it can't do that
16:44:21 <Peaker> SamB_XP: why?
16:44:44 <SamB_XP> because it can't know both where the electron was and how fast it was moving
16:45:35 <ksf> luqui, if we take bucky's definition of conscioness, we can regard the detector as conscious, for it has to be aware of otherness to detect.
16:46:00 <luqui> ksf, now I've lost you
16:46:08 <ksf> ...that is, it's a physical and metaphysical system, not just a physical one.
16:46:16 <SamB_XP> what the heck ?
16:46:26 <SamB_XP> who let in the philosophers ?
16:46:47 <ksf> ...like programs, swooshing through your cpu like a wizard's spell through the universe.
16:46:55 <ksf> meta-levels.
16:47:12 <Peaker> SamB_XP: well, I don't think re-shooting the particle is that important anyways :-)
16:47:31 <Peaker> SamB_XP: maybe a detector can beep when the electron passes through while still retaining most of its current properties
16:47:55 <SamB_XP> Peaker: go forth and calculate
16:48:28 <Peaker> luqui: I don't think its electric potential... but I don't know enough.  the pop physics books which formed my superficial knowledge suggested that physics does something akin to actually trying the various paths
16:49:12 <Peaker> luqui: and if multiple ones were possible, it would sum them up and so you wouldn't know which actually occurred
16:50:54 <luqui> Peaker, yeah, that's the Feynman interpretation
16:51:22 <luqui> Peaker, but which paths an electron may take are only reflected in electric potentials and other wave functions
16:51:35 <Peaker> I read that Feynman said that light only seems to travel in straight lines because its the only path that doesn't cancel out when you add all the possible paths light could take
16:51:48 <luqui> it's not like there's a little quantum electron in an otherwise classical world.  the wave function is affected by everything.
16:53:03 <luqui> ("other wave functions" is a bit of a handwave; there is really only one wave function)
16:53:31 <ksf> now we're speaking bucky.
16:54:16 <ksf> now i've lost myself.
16:55:47 <monochrom> I heard that Haskell only seems to be lazy because it's the only path that doesn't go into an infinite loop among all possible paths.  *duck*
16:56:41 <luqui> monochrom, nice :-)
16:57:01 <luqui> that's actually somewhat appropriate to outermost evaluation
16:57:03 <ksf> all possible paths that fulfill the spec yield the same denotations, operationally.
16:57:39 <ksf> ...not nescessarily in the same order or same amount of reductions, though.
16:59:04 <Peaker> conal: ping
17:12:09 <edwardk> @seen conal
17:12:10 <lambdabot> conal is in #darcs, #haskell and #ghc. I last heard conal speak 58m 47s ago.
17:12:34 <ikkebr> @seen dons
17:12:35 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 2h 10m 29s ago.
17:12:39 <edwardk> @msg conal withTimeF = inFuture duplicate
17:12:39 <lambdabot> Not enough privileges
17:12:44 <edwardk> ack
17:12:45 <edwardk> what happened
17:13:00 * edwardk sniffs.
17:15:00 <Peaker> maybe @tell?
17:15:06 <Peaker> or is that the same?
17:15:11 <edwardk> @help tell
17:15:11 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
17:15:15 <edwardk> @help msg
17:15:15 <lambdabot> msg <nick or channel> <msg>
17:15:19 <edwardk> ah
17:15:38 <edwardk> @tell conal withTimeF = inFuture duplicate; futVal = extract
17:15:38 <lambdabot> Consider it noted.
17:20:18 <dons> there, i had to say it, http://www.reddit.com/r/programming/comments/7hflk/ocaml_release_3110_has_landed/c06o08t
17:20:20 <lambdabot> Title: dons comments on OCaml release 3.11.0 has landed, http://tinyurl.com/64zfok
17:20:33 <dons> i wonder if i'm feeling up to a 'ocaml is dying' post yet. hmm.
17:21:01 <SamB_XP> what's the point ?
17:21:07 <SamB_XP> doesn't everyone already KNOW that ?
17:21:33 <blackh> Is it turning into F#?
17:21:47 <dons> no. it isn't turning into anything.
17:21:52 <edwardk> f# makes me sad
17:21:55 <dons> it's stopped. that's what.
17:22:02 <blackh> How about H#?
17:22:06 <SamB_XP> END OF THE LINE, FOLKS!
17:22:07 <dons> yeah. why not?
17:22:17 <blackh> (I'm just winding everyone up.
17:22:52 <pumpkin> the thank you list in RWH is enormous!
17:23:00 <blackh> Isn't F# going to expose the mainstream community to FP?
17:23:26 <SamB_XP> pumpkin: that's because of easy easy easy comment feature on online book ...
17:23:33 <dons> blackh: yes.
17:23:48 <p_l> blackh: Reading some comments when I was looking for tutorial it already is exposing a lot of people
17:23:53 <dons> and F# is kind of "Haskell-lite" so a good gateway drug
17:24:12 <blackh> That's what I thought.
17:24:54 <edwardk> dons: until you need 'forall' or need a real module because you don't have typeclasses
17:25:07 <edwardk> and then can't get modules that do anything more than .net namespaces
17:25:15 <erikc> f#'s only good feature vis-a-vis haskell is interoperablity with .net
17:25:19 <pumpkin> SamB_XP: it's awesome
17:25:41 <erikc> (but thats a pretty big one :)
17:25:46 * SamB_XP wonders if he made it on there or not
17:25:58 <Zao> erikc: You always have Salsa :)
17:26:13 <erikc> is that the haskell.net?
17:26:16 <Zao> No.
17:26:18 <erikc> oh
17:26:19 <erikc> heh
17:26:38 <Zao> http://www.haskell.org/haskellwiki/Salsa
17:26:39 <lambdabot> Title: Salsa - HaskellWiki
17:26:58 <erikc> interesting
17:27:36 <dons> erikc: there's a haskell bridge.
17:27:42 <dons> so you can call .NET stuff.
17:27:46 <dons> its just not using the .NET runtime.
17:28:26 <dons> there's more discussion about a CLR backend now.
17:29:37 <edwardk> @tell conal instance ComonadReader (Time t) (FutureG t) where askC = askC . unFuture -- "subsumes" futTime, but cannot be newtype derived
17:29:37 <lambdabot> Consider it noted.
17:34:07 <jaj> dons: is there some kind of fight between ocaml and haskell compilers?
17:34:19 <edwardk> more like a beating ;)
17:34:26 <luqui> lol
17:35:49 <dons> jaj, no. not any more. it felt like we were close a few years ago, but there's too few of them, and too many of us now.
17:36:08 <pumpkin> lol
17:36:11 <dons> its kinda fun that its a classic cathedral vs bazaar battle.
17:36:20 <edwardk> so in short, if you ask one of them, yes, if you ask someone around here, no ;)
17:36:23 <pumpkin> but they still generate smaller code don't they :P
17:36:35 <dons> they're moving glacially slower.
17:36:40 <edwardk> fewer coders = smaller code ;)
17:36:51 <dons> ghc gets in one release cycle what is taking 5-10 years in ocaml land now.
17:36:57 <dons> so yeah, i think its over.
17:37:01 <jaj> yeah but there are a lot of programming languages that are moving slower than haskell
17:37:07 <dons> yup
17:37:10 <Peaker> dons: how many people are contributing to ghc?
17:37:10 <jaj> C for example
17:37:37 <dons> Peaker: hmm. would be good to measure the contributors. it would be in the 100s now
17:37:44 <dons> at any given day, 5?
17:37:59 <Peaker> dons: wow, I'd think ghc would be one of the most intimidating projects to get into
17:38:09 <dons> i wrote about the differences, since i was kinda shocked how little this was for a major ocaml release, http://www.reddit.com/r/programming/comments/7hflk/ocaml_release_3110_has_landed/c06o08t
17:38:11 <lambdabot> Title: dons comments on OCaml release 3.11.0 has landed, http://tinyurl.com/64zfok
17:38:13 <erikc> C/C++ move so slowly that you cant look forward to using the new features in your career, if you are starting today
17:38:18 <blackh> Someone should abduct Eric S Raymond and make him learn Haskell.
17:38:30 <sjanssen> blackh: why?
17:38:37 <erikc> C++0x will be available across enough production compilers by the time you are retiring
17:38:43 <dons> pumpkin: and they're generating the same native code now, even before ghc gets its new code gen in spring.
17:38:44 <sbahra> [sbahra@centrino xml-1.3.2] runhaskell Setup.hs install
17:38:45 <sbahra> Installing: --user=/home/sbahra/software/tmp/lib/xml-1.3.2/ghc-6.8.3
17:38:45 <sbahra> ranlib: unrecognized option `--user=/home/sbahra/software/tmp/lib/xml-1.3.2/ghc-6.8.3/libHSxml-1.3.2.a'
17:38:45 <blackh> Because he has given Python a lift by supporting it.
17:38:49 <sbahra> Has anyone seen similar before?
17:38:51 <blackh> People listen to him
17:38:57 <dons> and this is all besides the parallelism push, which ocaml isn't even participating in.
17:39:22 <sbahra> Hi dons, I wanted to ask you about bytestring-lexing.
17:39:22 <sjanssen> sbahra: you're confusing --user with --prefix
17:39:27 <dons> sbahra: go for it
17:39:28 <jaj> is there any plan to get ghc to be able to bootstrap from hc files again?
17:39:30 <sbahra> sjanssen, stupid me
17:39:31 <sbahra> heh
17:39:32 <sjanssen> sbahra: you want --user --prefix=thatpath
17:39:37 <sbahra> Yes, yes :)
17:39:40 <dons> jaj, yes. once the new code gen lands, ghc becomes a cross compiler
17:39:48 <dons> so that kinda solves that.
17:39:51 <jaj> dons: nice :)
17:39:55 <sbahra> dons, it is reported as failing to build on hackage.
17:39:58 <dons> the initial commit was about a few days ago.
17:40:01 <dons> sbahra: ok. it builds.
17:40:04 <sbahra> dons, is this a problem with the build machine?
17:40:07 <dons> yeup
17:40:14 <sbahra> Ok. Wanted to make sure.
17:40:19 <dons> try it. cabal install bytestring-lexing is cheap
17:40:26 <sbahra> I am already using for some project.
17:40:47 <erikc> a lexing bytestring...swoon
17:40:51 <sbahra> But I wasn't sure if I wanted to submit it to FreeBSD ports if it isn't actively maintained or something. :-P
17:41:06 <dons> huge parts of ghc are rewritten from year to year (new smp runtime one year, new GC this year, new codegen this spring, new type checker last winter).
17:41:10 <dons> that's how fast things are moving.
17:41:31 <Zao> s/rewritten/breaking stuff/ :)
17:41:38 <pumpkin> how does the cross compiler work? I'd love to bring ghc to jailbroken iphone land but it's a real pain to get it bootstrapped
17:41:49 <sbahra> Thanks.
17:41:51 <dons> pumpkin: right. for now, i'd just use the debian arm build
17:41:59 <dons> and try to use that to generate the arm files for the iphone.
17:42:09 <pumpkin> I need to generate mach-o files
17:42:10 <sjanssen> dons: your post forgot spec constr
17:42:19 <Peaker> dons: is all that work done academically, or commercially funded?
17:42:29 <sjanssen> that was done about a year ago, right?
17:42:33 <dons> Peaker: MSR + academia. next year: commercially.
17:42:43 <dons> only a little was funded commercially
17:42:43 <shapr> Isn't MSR sort of commercial as well?
17:42:53 <sjanssen> dons: oh, what is this about commercial funding?
17:43:01 <dons> yeah. it is. that kind of stability for the last decade is why ghc is where it is.
17:43:02 <shapr> Yeah, what commercial funding?
17:43:05 <dons> sjanssen: yes. good thingss coming.
17:43:09 <Peaker> dons: That sounds great! I was under the impression that you, SPJ and 1-2 more are hacking on ghc :)
17:43:22 <shapr> Does the iPhone use an ARM? I want to get GHC on my BUG.
17:43:45 <jaj> shapr: yeah the iPhone is ARM based
17:43:53 <blackh> Threading doesn't work on the Debian arm version of ghc unless things have been fixed since I looked.
17:43:56 <dons> i think we've all pretty much realised we win by being the best organised. so we're ensuring we retain that.
17:43:58 <pumpkin> shapr: yeah, it's ARM
17:44:04 <shapr> ah, spiffy
17:44:10 <dons> get organised peoples!
17:44:20 <shapr> yes!
17:44:34 <sbahra> MSR?
17:44:38 <shapr> I gotta do CHUG...
17:44:38 <sbahra> Hi shapr
17:44:44 <pumpkin> microsoft research
17:44:46 <shapr> Anybody in the Boston area?
17:44:50 <sbahra> Ah, I see.
17:44:54 <edwardk> shapr: ooh, me! ;)
17:44:55 <dons> seen in #ocaml "I need a reason to think good about ocaml now that RWH is on my desk"
17:44:56 <shapr> sbahra: y0, come to Boston and visit for the CHUG?
17:45:01 <shapr> edwardk: Excellent, who are you again?
17:45:05 <sbahra> shapr, I have too many things right now :-P
17:45:06 <dons> see. this is how it happens. getting organised.
17:45:06 * shapr cackless
17:45:07 <sbahra> Oh, and hi edwardk :-P
17:45:11 <edwardk> heya samy
17:45:20 <jaj> dons: ghc is going to be commercially funded?
17:45:27 <dons> yup
17:45:28 <shapr> sbahra: C'mon, I'll introduce you to my bladeserver, unicycle, and all sorts of other interesting random hardware.
17:45:32 <pizza_> isn't it funded by microsoft?
17:45:35 <dons> yup
17:45:44 <pumpkin> why did MS go with F# (ocaml) over haskell if they're financing haskell research?
17:45:56 <edwardk> i want you to introduce him to your bladeserver while riding your unicycle.
17:45:56 <sjanssen> dons: is this secret stuff, or can you say something about it?
17:46:02 <shapr> edwardk: Um, no.
17:46:05 <dons> can't say anything more, but things are in the works.
17:46:07 <jaj> pumpkin: because they don't know what their research dept. is doing
17:46:12 <pumpkin> lol
17:46:13 <shapr> No riding the unicycle inside the apartment.
17:46:15 <dons> yes. well, they kinda do.
17:46:21 <Philippa> pumpkin: they're not financing haskell research for direct use on their part - F# was a different class of project for them at the time
17:46:22 <dons> they've enough they'll fund two systems.
17:46:27 <Philippa> and yeah, that too
17:46:32 <dons> let them fight it out and have one borrow from the other
17:46:39 <edwardk> what is the worst thing that could happen, really? its not like you'll fall and crack your head on the corner of the case. its already nicely buckled in for you
17:47:03 * shapr throws an HS21 blade at edwardk
17:47:20 * edwardk catches it and sells it on ebay... to shapr.
17:47:26 <shepheb> is it possible to build base 4 for 6.8.2?
17:47:30 <shapr> I want to get dual quad-core Xeons in that HS21 blade so I can try some heavy duty NDP :-)
17:47:54 <SamB_XP> why is it called HS21 ?
17:48:08 <jekor> Will an exception that's thrown within forkIO make it back to the parent thread? I'm noticing that my bracketed cleanup actions aren't getting called until the thread dies.
17:48:15 <edwardk> shapr seems to believe that if he can put together enough hardware, he can er... come up with a use for it all.
17:48:19 <shapr> SamB_XP: er, ask on #haskell-blah
17:48:55 <dons> shepheb: hmm. doubt it.
17:49:00 <dons> shepheb: would be an interesting project.
17:49:19 <dons> jekor: hmm. are they floating out of the bracket?
17:49:30 <shepheb> dons: bah. can I install 6.10.1 with a prefix or something, and without my 6.8.2 and 6.10.1 packages stepping on each other?
17:50:01 <jekor> dons: I'm having a hard time telling. I don't think so though, because I have a trace in them that I do see printed when I kill the program.
17:50:03 <FunctorSalad> ,type synthesize
17:50:13 <dons> shepheb: yes.
17:50:14 <lunabot>  luna: parse error on input `type'
17:50:15 <dons> just install it
17:50:18 <FunctorSalad> @type synthesize
17:50:19 <lambdabot> forall s t a. (Data a) => s -> (t -> s -> s) -> GenericQ (s -> t) -> a -> t
17:50:21 <dons> shepheb: they don't step on each other
17:50:27 <dons> you can always get at ghc-6.x.y
17:50:33 <dons> only the most recent one is symlinked as 'ghc'
17:50:37 <mmorrow> dons: i was looing at the Data.Binary source and it appears to use a standard State monad
17:50:54 <dons> for writing?
17:50:59 <mmorrow> i'm thinking of seeing how it would do with a cps state
17:51:03 <mmorrow> no, Get
17:51:10 <dons> ah. oh right, yes.
17:51:12 <mmorrow> i haven't looked a Put yet
17:51:13 <dons> it just pulls off the buffer
17:51:13 <FunctorSalad> anyone familiar with that synthesize function? "synthesize mempty mappend foo" should be a sensible usage, right?
17:51:16 <dons> Put is more complex
17:51:47 <twanvl_> you could also try an unboxed State monad, like ghc uses
17:51:49 <mmorrow> cool
17:51:55 <FunctorSalad> with foo something like "mkQ empty f", "f (InterestingCase x) = ...", "f _ = id"
17:52:33 <dons> twanvl_: we tried that, iirc
17:52:42 <dons> with no win, since we already aggressively inline everything
17:52:51 <dons> so all the state glue is boiled away
17:53:08 <dons> it  would be interesting to see if a CPS formulation produced better code
17:53:16 <mmorrow> twanvl_: it turns out that a cps state monad is (in my single test) twice as fast as unboxed tuples
17:53:46 <dons> mmorrow: you could write a rewrite rule to replace IO.>>= with the CPS>>= maybe
17:54:11 <twanvl_> it probably depends on how heavily the state is used
17:54:24 <mmorrow> ooh, i hadn't thought about using rewrite rules for anything. that could be interesting
17:54:33 <dons> "Currently, the Caml development team is equivalent to 0.5 person full time."
17:54:49 <dons> mmorrow: i've thought about using that to have IO always be strict
17:54:57 <conal> edwardk: thx for the pointers.
17:54:57 <lambdabot> conal: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:55:04 <mmorrow> twanvl_: http://moonpatio.com/repos/state-bench/
17:55:05 <lambdabot> Title: Index of /repos/state-bench
17:55:13 <mmorrow> dons: hmm
17:55:18 <chessguy> conal's a popular guy these days :)
17:55:26 <edwardk> conal: just started going through reactive hunting for opportunities
17:55:37 <conal> edwardk: great!
17:55:59 <conal> edwardk: the new reactive i'm designing will have more, of course.  i'm working on a series of blog posts.
17:56:15 <dons> basically, to work on ocaml, you have to apply to INRIA
17:56:30 <dons> that doesn't scale. so ghc will win (has won)
17:56:49 <gio123> is here any english speaker who has free 5 minute?
17:56:51 <jaj> dons: ocaml is developped by government researchers for sole sake of research
17:57:09 <edwardk> newtype ReactiveG t a = Reactive { unReactive :: Cofree (FutureG t) a } deriving (RunComonadCofree, ComonadCofree, Comonad, Copointed, Functor) -- would go a long way, because then the Cofree in there could be swapped out for Density (Cofree (FutureG t)) a, transparently -- gah thats a mouthful
17:57:11 <dons> conal: had dinner with antony courtney. he's keen to see the new reactive stuff. and glad to see FRP's second coming.
17:57:27 <jaj> I don't think they're interested in competing with haskell
17:57:36 <edwardk> then pulling an Event off of a Reactive is just using outCofree
17:57:38 <conal> dons: that's great.  how did you meet up with antony?
17:57:47 <dons> jaj, but that's orthogonal. they're not interested in open sourcing. which is why they're not competing
17:57:59 <dons> conal: was in ny giving a talk and he dropped by
17:58:11 <conal> dons: i want to get back our "genuinely functional user interfaces" work.  i don't think it was pursued after antony's phd.
17:58:12 <dons> he also was happy about Frag -- best yampa system ever :)
17:58:49 <conal> dons: nice :).  i'm tickled with the interest in an frp revival.
18:00:07 <dons> the 3d stuff is the key i think. reset people's expectations again. while being more accessible than Frag.
18:00:14 <dons> and showing the performance story
18:00:24 <edwardk> yeah. i think frag scared a lot of folks away
18:00:32 <dons> we should get the yampa arcade games up on hackage too
18:00:44 <dons> edwardk: its a sole programmer's vision in many ways
18:00:45 <Philippa> frag /as a serious example/ definitely does
18:00:48 <dons> just built on stock Yampa.
18:01:10 <dons> not even a haskell guy at the start of the project (good answer for "can we train up new people?")
18:01:17 <edwardk> *nods* i'm a former 3d guy, and it scared /me/ ;)
18:01:22 <conal> i haven't looked at frag.  heard it was pretty improvement.
18:01:27 <conal> oops -- pretty imperative.
18:01:38 <dons> conal: yes. deep down. glued together with ymapa
18:01:38 <conal> (emacs abbrev typo)
18:01:44 <dons> but very naively imperative.
18:01:51 <dons> raw "get the job done" FRP :)
18:01:54 <mmorrow> i find this amusing: my "Doodads" module http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=545#a545
18:01:54 <chessguy> http://hpaste.org/12701
18:02:03 <mmorrow> (clearly not finished yet)
18:02:09 <chessguy> i'm curious what ya'all think of this
18:02:10 <Philippa> yeah - I was only an amateur, but... yeah. The game sim had awful performance too, and there wasn't a good answer for "how do I scale this to the complexity you see even in decade-old games?"
18:02:23 <conal> dons: who did frag?  i've forgotten.
18:03:00 <chessguy> conal, author   = {Mun Hon Cheong},
18:03:00 <chessguy>  according to http://www.haskell.org/haskellwiki/Frag
18:03:02 <lambdabot> Title: Frag - HaskellWiki
18:03:22 <conal> chessguy: thx
18:03:41 <EvilTerran> mmorrow, er, what's it for?
18:05:02 <Philippa> I have to admit, I'm allergic enough to boxing that the idea of writing a game of, say, Quake 1's complexity in Haskell still feels a little too much like doing it in, say, C++
18:05:59 <Philippa> oh, that and to encoding a better record system
18:06:39 <Philippa> (anyone pointing out that strictly speaking Quake 1 used exactly one type for all entities will get a rant about how much QuakeC sucked!)
18:06:41 <mmorrow> EvilTerran: to have a little library of datatypes with symbolic names to use when they might make some code more clear (e.g. in a web program configuration .. "this" :/: ["that" :/: ["asdf"], "hai" :/: []])]
18:06:46 <erikc> heh
18:07:46 <dons> mfp: what do you think. is the long term future bright? or are the inefficiencies in the 'cathedral' model going to overwhelm the project eventually?
18:07:50 <Cale> mmorrow: Except, isn't it at the type level?
18:07:51 <mmorrow> newtype DirTree a = DirTree ((String :=> a) :/: [DirTree])
18:07:54 <mmorrow> yeah
18:08:29 <mmorrow> so i'd use them in newtype/type decls which would then allow me to use those symbols in expressions
18:08:38 <mmorrow> Cale: oh, i intend to fill in the definitions
18:08:53 <mmorrow> i'm just thinking of names at this point
18:09:12 * SamB_XP wonders how they came up with the term "Hofstadter-Moebius loop"
18:09:21 <erikc> haskell is perfectly suitable for building a AAA game, you just need to shape your data for performance
18:09:49 * edwardk is somewhat less optimistic than erikc about that
18:10:17 <SamB_XP> erikc: is that a game involving service to motorists ?
18:10:51 <erikc> edwardk: i mean, design your data the way you would in C, packed data structures, a database of your game data in table form
18:10:57 <erikc> then you can use haskell as a control language
18:10:59 <mmorrow> ("this" :=> (thisCGI :: CGI CGIResult) :/: [("that" :=> explode) :/: [("asdf" :=> blah) :/: []], ("hai" :=> output "hai") :/: []])]
18:11:02 <dons> hey, we write freaking OS kernels in haskell. we can write a game.
18:11:06 <erikc> and when haskell isnt fast enough, you can drop to C
18:11:10 <dons> and have done. many times.
18:11:17 <SamB_XP> dons: but does anyone play the OS ?
18:11:18 <erikc> because your data is in a C-friendly shape
18:11:21 <SamB_XP> er, I mean use it!
18:11:21 <Philippa> dons: games are a hell of a lot more complicated than OS kernels
18:11:24 <dons> erikc: or just parallelise it, and be done.
18:11:48 <dons> Philippa: we can get performance goodd enough for a game. and use the gpu for   the rest.
18:11:55 <erikc> dons: on a PC, i agree, consoles with asymmetric memory are a different story :)
18:11:56 <edwardk> dons: yeah, but every time i see 'low level haskell' designed for speed suitable enough for such a purpose my eyes bleed.
18:11:58 <Philippa> it ain't performance I'm worried about
18:11:58 <chessguy> so, anybody have any thoughts on http://hpaste.org/12701 ?
18:12:01 <dons> you might need to know what you're doing.
18:12:03 <FunctorSalad> top secret feature in Text.Printf.TH: "%H" shows the argument :)
18:12:16 <dons> edwardk: you might need to know what you're doing. that is very true. though getting less so.
18:12:27 <SamB_XP> dons: he said his eyes bleed
18:12:33 <SamB_XP> not that he doesn't comprehend the code
18:12:39 <SamB_XP> ... just that it's not pretty
18:13:23 <luqui> conal, I have been thinking Behavior should be Behavior a = a + F (Behavior a), where F is something like event, but has some continuous nature
18:13:28 <luqui> I'm not sure what that functor should be though
18:13:48 <luqui> er, I mean a * F (Behavior a)
18:14:28 <Philippa> dons: I don't know how much sense this is going to make to you, but I'd sooner write a game engine in Haskell than a game at the moment
18:15:33 <SamB_XP> ???
18:15:40 <SamB_XP> what would the game be written in, then ?
18:15:59 <edwardk> Behavior right now is Reactive `O` Fun more or less right?
18:15:59 <mmorrow> blood, sweat, and tears
18:16:18 <luqui> edwardk, right
18:16:21 <SamB_XP> mmorrow: how do you descramble them into something meaningful ?
18:16:22 <Philippa> a language with a better record system
18:16:27 <luqui> edwardk, and the comonad instance on that is tricky.
18:16:42 <SamB_XP> Philippa: ah, that makes sense
18:16:44 <Philippa> most likely, a language that prioritises existential over universal quantification, too
18:16:50 <luqui> edwardk, and has some ugly interactions
18:16:50 <erikc> i would write a game engine in C/Haskell and the game in Haskell/Prolog
18:16:52 <mmorrow> SamB_XP: beats me :-)
18:16:55 <SamB_XP> and you would implement this language as part of the engine ?
18:17:03 * BARACKOBAMA is writing a game engine and game in haskell
18:17:05 <Philippa> *shrug* - I might
18:17:16 <luqui> BARACKOBAMA, yay.  FRP-based?
18:17:20 <edwardk> yeah, you can make Reactive into a Cofree off Future, so it looks like the exponent comonad transformer applied to the cofree comonad of Future
18:17:21 <Philippa> depends how masochistic I'm feeling
18:17:25 <BARACKOBAMA> FRP?
18:17:26 <edwardk> just skimming the types
18:17:27 <SamB_XP> or, well, probably a fairly orthogonal component ?
18:17:48 <Philippa> right. It just needs to know how to manipulate the stuff at the interface with the engine
18:17:58 <luqui> edwardk, is the exponent comonad transformer the right one?
18:18:04 <edwardk> not sure
18:18:04 <luqui> (I don't know it)
18:18:06 <BARACKOBAMA> it's a mix between MMORPGs, mechwarrior and abstract expressionism
18:18:25 <luqui> BARACKOBAMA, yeah.  its half-existence is the reason I have not yet made a game library.
18:18:40 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Comonad/Exponent.hs has the basic exponent comonad
18:18:41 <luqui> BARACKOBAMA, because if it fully existed it would make a *great* game library
18:18:42 <lambdabot> http://tinyurl.com/5sp3vr
18:18:43 <BARACKOBAMA> what?
18:18:45 <BARACKOBAMA> if what fully existed
18:18:46 <luqui> edwardk, looking
18:18:48 <edwardk> i didn't bother writing in the transformer
18:18:53 <luqui> BARACKOBAMA, a good FRP library
18:19:03 <BARACKOBAMA> ok
18:19:09 * BARACKOBAMA frowns
18:19:18 <edwardk> but you can derive it the same way the Context comonad transformer works, just using the Monoid instances to provide the base value.
18:19:32 <edwardk> not sure if it fits either, just giving context (no pun intended)
18:19:39 <BARACKOBAMA> the wikipedia article on the subject describes it terribly
18:19:46 <BARACKOBAMA> and i mean terribly
18:19:51 <luqui> edwardk, oh, right, the dual to Writer.
18:19:55 <gio123> Cale: hi
18:20:00 <edwardk> luqui: yeah
18:20:03 <BARACKOBAMA> most programming literature is shit
18:20:07 <luqui> edwardk, the semantics of Behavior are the Exponent comonad over Time with additive monoid
18:20:30 <mfp> dons: I'm sure GHC will keep evolving faster than OCaml. It also needs to (both due to its role in PLT research and because it imposes a much harder task on itself, optimization-wise.) To be honest, I wouldn't bet for either OCaml or Haskell being in active use in 15 or 20 years. But this doesn't detract from their usefulness now and in the short- and medium-term from my POV :-)
18:20:42 <luqui> but how that makes it into the *implementation* is bugging me.  it is nonobvious
18:20:46 <edwardk> luqui: sounds right, that was where i was going with the quick sketch i was putting together in another window.
18:21:01 <mmorrow> i would hope no current languages are in use in 20 years ....
18:21:11 <mmorrow> but i'm sure some will be ..
18:21:27 * polveroj wishes he could do category theory in realtime and participate in this FRP discussion.
18:21:27 * luqui hopes for functional ones.
18:21:48 <mmorrow> (well, current languages that aren't brand-new/experimental that is)
18:22:03 <edwardk> luqui: the other observation i've been poking around at is using the density comonad of the cofree comonad for behaviors rather than the cofree comonad itself because there are some asymptotic problems
18:22:10 <luqui> polveroj, do ask questions.  not much category theory is needed.
18:22:35 * luqui looks up density comonad
18:22:35 <edwardk> er not for behaviors, i mean for reactive
18:22:48 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Comonad/Density.hs
18:22:50 <lambdabot> http://tinyurl.com/5pzotj
18:23:09 <edwardk> you can also read my first or second blog post on Kan extensions to get a better intuition for it
18:23:25 <jaj> I really can't imagine what working with a computer will be like in 20 years
18:23:25 <mfp> dons: regarding cathedral vs. bazaar, I tend to think that libs are more important on this regard (na√Øve as it is, the compiler already yields good, predictable performance; and it's OK if the language doesn't change much --- in fact that's a plus for many).
18:23:39 <edwardk> polveroj: i'll happily answer questions
18:23:46 <luqui> edwardk, thanks.  that's what I was about to ask.
18:24:16 <edwardk> luqui: the codensity monad may be a more accessible way to start since its related to ContT
18:24:58 <luqui> edwardk, hmm, ok.
18:25:05 <luqui> what are the asymptotic problems you mentioned?
18:25:14 <edwardk> if you think of a free monad as just repeatedly substituting new 'branches' wherever you made it down to a leaf during a bind that works fine until your tree starts to grow too big, then binds spend too much time traversing the intermediate structure.
18:26:07 <edwardk> the usual answer in those circumstances when you are doing this in say, scheme or something, is to carry around a continuation to apply tot he leaves. hence the intuition for using a variation on ContT. but really you never need the ability to just bail out with the crrent continuation
18:26:25 <edwardk> so universally quantifying over the result type yields a monad that is 'just the right size'
18:26:46 <luqui> oh!  that answers the question I had about ReadP the other day!
18:27:10 <sutats> Can someone with experience with gtk2hs tell me how to use the maze from loadMaze in solveMaze as in http://hpaste.org/12702 ?
18:27:13 <edwardk> another way to think of it is that Density carries around its bind argument in an accumulating parameter balling them up for one grand explosion
18:27:17 <edwardk> er Codensity
18:27:39 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Monad/Codensity.hs newtype Codensity m a = Codensity { runCodensity :: forall b. (a -> m b) -> m b }
18:27:41 <lambdabot> http://tinyurl.com/5rb3ll
18:28:04 <edwardk> you can clearly 'see' the bind argument right in the type
18:28:24 <edwardk> m >>= k = Codensity (\c -> runCodensity m (\a -> runCodensity (k a) c)) doesn't even care if f is a Functor!
18:28:45 <edwardk> hence it can't be fmapping all over the place to traverse it, it has to do it all at once.
18:29:35 <edwardk> er if 'm' is a functor i mean
18:30:01 <pumpkin> I don't get how arrays are implemented in haskell
18:30:03 <edwardk> the Yoneda type in category extras does the same thing for accumulating fmaps.
18:30:47 <edwardk> you can think of Yoneda as enforcing fmap fusion.
18:31:40 <conal> luqui: ("... Behavior a = a + F (Behavior a) ...").  is that constant case & non-constant case?
18:31:41 <Apocalisp> Do you know of any good articles that expose "object-oriented" as a non-concept?
18:31:51 <luqui> conal, I corrected the + to a *.
18:31:59 <luqui> conal, cofree over F.
18:32:16 <luqui> conal, essentially it is Reactive, but where the Event has some continuous nature.
18:32:24 <luqui> "now" * "how I get somewhere other than now"
18:32:34 <edwardk> hrmm
18:33:20 <Philippa_> Apocalisp: not really. There're some that point out that it's a big cluster concept and many conceptions of OO are dumb...
18:33:22 <edwardk> right now Event a ~ Future (Reactive a) right
18:33:29 <edwardk> er right?
18:33:40 <Apocalisp> Philippa: Any that particularly stand out in your mind?
18:33:47 <luqui> edwardk, aye.
18:33:58 <dons> mfp, yeah, libs are hugely important
18:34:00 <Philippa_> erm. I remember Paul Graham's one making some sense on the cluster concept bit
18:34:12 <Philippa_> the rest depends a lot on why you want to attack it
18:34:12 <luqui> i.e. i think of this mysterious F as "either an event occurrence, or some amount of time passing without an event occurring".  but it's still very fuzzy.
18:34:17 <edwardk> so that is just a partially unwrapped cofree comonad
18:34:18 <SamB_XP> is it like "RPG" for videogames ?
18:34:27 <dons> mfp, libs, new emerging platforms (iphone, multicore), bug fix turnaround time, stability
18:34:33 <Philippa_> there're some conceptions of OO I have some real respect for...
18:34:35 <SamB_XP> they used to call Zelda an RPG
18:34:36 <luqui> edwardk, yep.
18:34:43 <mfp> dons: I'd say, much more than the compiler/runtime (if it's not crap), in fact
18:35:02 <edwardk> in category extra terms outCofree :: Reactive a -> Event a -- more or less
18:35:07 <Philippa_> SamB_XP: these days it's under "Action RPG"
18:35:21 <jekor> How can I execute an action when a thread terminates? I'd like to accept a connection on a socket, pass the socket to a thread, establish another socket, pass that to another thread, and then close both sockets only after both threads are finished executing. Is there a way to do that?
18:35:29 * luqui continues reading about kan extensions
18:35:35 <edwardk> heh, that begs some sort of unfoldReactive :: Functor f => (a -> c) -> (a -> FutureG t a) -> a -> ReactiveG t c
18:35:44 <edwardk> unfoldReactive f g = Reactive . anaCofree f g
18:35:50 <Philippa_> of course, there's the minor issue of whether eg D&D played as a dungeon hack is an RPG...
18:36:43 <edwardk> since any infinite time ends the sequence of events represented by a Reactive, no?
18:37:04 <Apocalisp> Philippa: I don't want to attack it. I don't think it exists.
18:37:28 <Philippa_> that's a form of attack...
18:37:41 <Philippa_> do you know what a cluster concept is?
18:38:31 <Apocalisp> Yes, I think I know what you mean by that.
18:38:32 <Philippa_> I'm asking partly because a lot of people roll their eyes at people showing something "doesn't exist" by showing it to be a cluster concept
18:39:01 <Elly> what is a cluster concept?
18:39:03 <Philippa_> not least because there're ways of managing them
18:39:06 <edwardk> luqui: the text at the very end of the first kan extension post re: colimits is slightly off, the code that is in category extras is correct though
18:40:07 <Philippa_> Elly: it's a concept with no clear definition, or perhaps many partial definitions, such that some things are commonly agreed to be examples, some to not be examples, and others may well be considered either way
18:40:12 <Philippa_> "alive" is a good example
18:40:14 <Apocalisp> Philippa: I guess you could say that I want to attack the object-orientation of programmers by showing that object-oriented programming isn't really anything.
18:40:25 <Elly> I see
18:40:39 <Philippa_> Apocalisp: do you intend to do that by any means other than the cluster concept approach?
18:41:01 <Philippa_> Elly: similarly, "OO language" and "functional language" are cluster concepts
18:41:51 <Apocalisp> Philippa: I think my approach is essentially that. What you call "cluster concept", I'm calling a non-concept or, more strongly, an anti-concept.
18:41:59 <dejones> dons: You here?  Did you still want pictures of "Real World Haskell" arrivals?
18:42:13 <Philippa_> Apocalisp: expect not to convince an awful lot of people, then
18:42:34 <luqui> edwardk, just because I'm currently in the habit of being a pedant about this: instance Functor Trivial in that post doesn't obey the functor laws :-)
18:42:58 <Apocalisp> Philippa: I'm following up with actual concepts to replace it. :)
18:43:42 <Philippa_> better off presented with less aggression towards OO and more emphasis on the refinements, then
18:44:20 <edwardk> luqui: fmap f = id, so fmap id = id; fmap (f . g) = id = fmap f . fmap g = id . id
18:44:24 <edwardk> luqui: whats missing?
18:44:44 <Philippa_> I tend to think that "message-passing OO" is about as well defined as any other paradigm, btw
18:44:45 <luqui> edwardk, fmap id _|_ /= id
18:44:50 <luqui> edwardk, not strict enough
18:44:56 <luqui> er, fmap id /= id
18:45:22 <Apocalisp> I find it disheartening that expressing the view that a concept may be invalid and that one should check one's premises would be seen as aggression.
18:45:22 <edwardk> ah coz i didn't fmap f Trivial = Trivial
18:45:28 <luqui> right :-)
18:45:38 <edwardk> i'll file that under WONTFIX ;)
18:45:42 <luqui> haha
18:46:46 <Philippa_> Apocalisp: take a fairly strategic notion of aggression for a moment and then consider how much we only really have cluster concepts for
18:47:02 <Philippa_> "alive", "dead", "male", "female"...
18:48:00 <Philippa_> a more refined approach would be to suggest that one can only safely reason so far without refining which part of the cluster you're working with in practice
18:48:38 <Apocalisp> I don't think I'm prepared to accept "cluster concept" in that case.
18:49:15 <Philippa_> expect telling people "you're wrong" (and the word "invalid" amounts to it) over what are significantly philosophical matters to be considered aggressive
18:49:24 <Apocalisp> I'm fairly well versed in the process of concept-formation, and anything that doesn't qualify isn't one, cluster or no.
18:49:59 <Philippa_> cf "degenerate triangle"
18:50:27 <Apocalisp> You're probably right, inasmuch as people are religious about philosophical matters.
18:50:32 <Riastradh> Apocalisp, are you aware of Jonathan Rees's brief article on the variety of mostly independent notions one might mean by `OO'?
18:50:46 <SamB_XP> Apocalisp: you haven't been to my Ethics class, have you?
18:50:49 <Apocalisp> Riastradh: Yes, I am now, thanks!
18:50:55 <Philippa_> Apocalisp: I'm right insomuch as you'd effectively be pushing your religion on others
18:50:58 <SamB_XP> or you'd realize that "alive" and "dead" aren't really all that well defined
18:51:18 <SamB_XP> (though I'll grant you that OO is far more vague)
18:51:28 <Apocalisp> Philippa: I don't have one, and I couldn't push it even if I did.
18:51:37 <edwardk> luqui: did the kan stuff make sense?
18:51:47 <Philippa_> "cluster concepts are invalid" is a pretty religious statement from where I'm standing
18:52:03 <Philippa_> (for "emacs is better than vi" values of religious, granted)
18:52:03 <luqui> edwardk, so far it makes a reasonable amount of sense.  pretty abstract, but I think I'm following.  just finished the first article.
18:52:16 <SamB_XP> Philippa: heh
18:52:22 <SamB_XP> I thought people were over that
18:52:55 <Apocalisp> I don't know where you're standing. I'm not willing to accept that "cluster concept" has cognitive utility without knowing what it means exactly.
18:53:03 <twb> Why did "cabal install yi" want to install Cabal 1.4.0.2?
18:53:03 <Philippa_> Apocalisp: STFW
18:53:08 <SamB_XP> Apocalisp: what does mean mean ?
18:53:20 <SamB_XP> STFW ?
18:53:23 <edwardk> i mostly started thinking about them in terms of (Co)Yoneda and (Co)Density after that, which covers most of their uses and can be seen as just a high-falutin way of moving fmap, bind or extract out into an accumulating parameter.
18:53:29 <Philippa_> Search The ... Web
18:53:34 <SamB_XP> oh
18:53:37 <twb> SamB_XP: STFW = JFGI = RTFM
18:53:45 <Apocalisp> Oh, right. I shall, thanks.
18:53:45 <SamB_XP> I thout it was maybe a typo for STFU
18:53:55 <twb> SamB_XP: the sentiment is similar
18:54:32 <SamB_XP> http://justfuckinggoogleit.com
18:54:38 <lambdabot> Title: Just Fucking Google It
18:54:58 <Philippa_> *nod* - I'm no philosopher, I shouldn't be attempting in-depth explanation and justification of the concept where the work's been done by many others
18:55:02 <Riastradh> Apocalisp, perhaps rather than arguing against cognitive utility, it would be more fruitful to argue against communicative utility.  When a Java programmer extols his language's `OO', and a Dylan programmer extols his language's notion of `OO', the two will likely fail to communicate with one another.
18:55:57 <edwardk> question am i overlooking something, with the way Reactive works now, you rely on the sequence to be monotonically increasing or that you'll defer until it is, no? what if you just stored the delta t instead? or is that what the segment stuff is working towards?
18:55:57 <SamB_XP> does a Java programmer even know what Extol *means*?
18:56:36 <twb> Extol is a Christian metal band from Oslo in Norway!
18:57:12 <twb> Of course, lowercase "extol" would be different :-)
18:58:07 <Apocalisp> Riastradh: Thanks, but I think that before I communicate something, it has to make sense in my own mind first.
18:58:10 <Riastradh> Apocalisp, this failure to communicate doesn't (necessarily) imply that the two programmers have failed to think.  (Then again, we are talking about Java programmers, but never mind my editorialization...)
18:58:22 <twb> Riastradh: are there any active Dylan programmers left?  I guess they would've switched to Ruby or something equally icky.
18:58:41 <Riastradh> Yes, twb, there are.
18:59:41 <twb> Riastradh: funded by Apple, or are they FOSS?
18:59:50 <Riastradh> (I confess to choosing Dylan primarily because Rees's article uses precisely this example.)
19:00:46 <Riastradh> twb, the latter.  Google it.  Apple hasn't been involved in Dylan for twelve years (although they still cling to the source code of their Dylan implementation).
19:02:11 <SamB_XP> http://www.justfuckinggoogleit.com/mail/msg00007.html
19:02:14 <lambdabot> Title: [no subject]
19:03:02 <dons> mfp: is the OCaml community doing the things it needs to, to avoid turning into Clean? they're aware of the risk of stagnation, I take it?
19:03:21 <dons> batteries, hackathons?, building the commercial consortium.
19:03:23 <SamB_XP> dons: what's wrong with clean ? isn't it pure ?
19:03:32 <dons> doing things to counter the slow compiler dev.
19:03:47 * luqui decides he needs to backlog edwardk's blog more.  I knew there was something beautiful about the state monad! :-)
19:03:57 <edwardk> hah =)
19:04:24 <edwardk> luqui: you can do similar constructions for the other arrows and a bunch of other monad/comonad pairs
19:04:38 <edwardk> just try to shove everything to the right or left of the arrow
19:04:56 <dons> mfp: you're leading the work on community organising, in large part?
19:07:03 <sjanssen> @keal
19:07:03 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
19:07:11 <dons> the xavier slides from january are something in the righht direction. have people do all the other parts, since they can't contribute  to the core. though "refrain from unreasonable demands" is interesting.
19:07:23 <dons> is it fundamentally licensing  that prevents the system being opened up?
19:09:32 <Philippa_> ...to repeated nick changes?
19:09:50 <dons> hmm
19:10:33 <sjanssen> HowardTheDuck: that is a bit annoying
19:10:37 <dons> yes.
19:10:43 <dino-> Quick question before I take it to #xmonad: Can I put the xmobar on my other monitor of a dual-head setup?
19:10:46 <HowardTheDuck> it's part of a competition
19:10:48 <HowardTheDuck> i have no choice
19:10:51 <dons> dino-: yeah
19:10:56 <HowardTheDuck> don't you care about me winning
19:11:02 <dons> HowardTheDuck: perhaps part this channel then
19:11:04 <HowardTheDuck> or is your cheerleading dreams only of importance
19:11:13 <sjanssen> HowardTheDuck: where?  You're only joined to #haskell and #xmonad
19:11:15 <SamB_XP> HowardTheDuck: generally you should leave all other channels when you do that, yes
19:11:31 <HowardTheDuck> it's out of my hands
19:11:35 <HowardTheDuck> god has a mission for me
19:11:37 --- mode: ChanServ set +o dons
19:11:40 --- mode: ChanServ set +o sjanssen
19:11:41 --- kick: HowardTheDuck was kicked by dons (dons)
19:11:48 <HowardTheDuck> why even bother
19:11:48 --- mode: dons set +b *!*n=ush@*.syr.edu
19:11:48 --- kick: HowardTheDuck was kicked by dons (dons)
19:11:49 <FunctorSalad> seems like he has a mission for dons too ;)
19:11:58 <SamB_XP> sjanssen: actually, he just has it so you lonly see the channels you are both in
19:12:02 --- mode: ChanServ set -o sjanssen
19:12:06 <sjanssen> SamB_XP: ahhh
19:12:12 --- mode: ChanServ set -o dons
19:12:20 <SamB_XP> I can't even see that he
19:12:24 <SamB_XP> 's in xmonad
19:12:25 <SamB_XP> or whas
19:12:58 <glguy> because he is +i
19:13:23 <sjanssen> seems like an antisocial feature
19:13:31 <SamB_XP> yeah
19:13:45 <glguy> helps keep people who are pestering you in one channel from following you to another
19:14:09 <dons> mm
19:14:10 <SamB_XP> at least it lets you always see what channels you have in common with someone else, though
19:14:14 <sutats> Can someone with experience with gtk2hs tell me how to use the maze from loadMaze in solveMaze as in http://hpaste.org/12702 ?
19:14:16 <SamB_XP> regardless of the setting
19:14:48 <dons> how're things, glguy
19:15:09 <FunctorSalad> SamB_XP: I thought that setting was the default :)
19:15:28 <gwern> hm, new haskell-src-exts is out. I wonder if lhc can use it
19:15:34 <SamB_XP> FunctorSalad: maybe your client is antisocial too ?
19:15:48 <FunctorSalad> SamB_XP: possibly
19:15:49 <mmorrow> dons: ah, Put is a cps reader monad :)
19:16:02 <dons> mmorrow: yes.
19:16:06 <dons> we used to use ContT
19:16:53 <mmorrow> i'm a fan of flattening (manually) monads in favor of stacking them with transformers myself
19:17:34 <sjanssen> mmorrow: have you seen the MonadLab approach?
19:18:36 <dons> seen on twitter, might as well skip py3k and go straight to py10k (i.e. haskell :)
19:19:13 <mmorrow> sjanssen: yeah, i read the article (paper? can't recall) about it. i think that's a great idea. i'd also been thinking of writing some TH code to manually flatten monads given a type (like @unmtl), then wrap the flattened type in a newtype + generate instances of Monad+Functor + convenience functions for it
19:19:48 <sjanssen> mmorrow: it was a paper submitted to the Haskell Symposium
19:19:57 <sjanssen> mmorrow: what you describe is essentially what it does
19:20:04 <mmorrow> (my impression was that MonadLab just goes as far as constructing the /transformer/ instead of the fully flattened version ?)
19:20:17 <sjanssen> the user describes which features are required, and MonadLab generates the type and instance
19:20:18 <mmorrow> oh, cool
19:20:29 <sjanssen> mmorrow: ah, maybe it does generate code that uses the transformers though
19:20:29 <mmorrow> so MonadLab would do something like:
19:20:39 <sjanssen> shouldn't be hard to change that, I assume
19:20:44 <mmorrow> ah, yeah. i want to do the next step
19:20:57 <mmorrow> i think it'll really boost performance
19:21:21 <sjanssen> was it you that was talking about CPSing the various MTL Monads?
19:21:26 <mmorrow> e.g., check out the (>>=) in RWS vs. what's happening in (>>=) for ReaderT r (WriterT w (State s)) a
19:21:37 <mmorrow> sjanssen: dolio and I, yeah
19:21:49 <mmorrow> dolio actually wrote a cps version of the mtl
19:21:51 <sjanssen> on hackage yet? :)
19:21:56 <mmorrow> i'm not sure
19:22:22 <dons> ghc gets -fexplicit-call-stack
19:22:25 <dons> sweet.
19:22:41 <wy> Hi, I'm reading John Hughes' arrow paper, but found one monad use not very clear to me yet. http://hpaste.org/12703. I'm a littlle confused about the partial application of the type constructor StateMonad
19:22:44 <mmorrow> i have a mini non-mtl-compatible cps monad lib at http://moonpatio.com/repos/monad-cps/
19:22:49 <lambdabot> Title: Index of /repos/monad-cps
19:22:54 <dons> http://ghcmutterings.wordpress.com/2008/12/04/explicit-stack-traces/
19:22:56 <lambdabot> Title: Explicit Stack Traces ¬´ GHC Mutterings, http://tinyurl.com/5czx2z
19:22:58 <dons> this could be very useful!
19:23:25 <mmorrow> sjanssen: next time dolio's in here i'm gonna suggest he put it on hackage (if it isn't there already) though
19:24:00 <mmorrow> dons: ooh yeah, i've read about that a while ago but didn't know it was actually being worked on
19:24:00 <sjanssen> dons: I think you've made a new friend in HowardTheDuck :)
19:24:27 <dons> hehe
19:24:35 <dons> awesome. i like friends.
19:24:58 <twb> dons: they're a vice
19:24:59 <dons> am i preventing him from getting his haskell work done?
19:26:04 <sjanssen> Haskell trolling, more likely
19:26:22 <dons> ok. so we're done then.
19:28:45 <sjanssen> mmorrow: oh, I spoke to one of the MonadLab guys once.  He said there was a problem with using TH directly, because the instance code can't reference the type name (or something like that)
19:29:34 <mmorrow> sjanssen: hmm, i'm not sure exactly what he means by that.
19:30:06 <sjanssen> mmorrow: I dunno, I only half remember the conversation
19:30:11 <mmorrow> maybe it's a problem on account of how their taking input
19:30:28 <mmorrow> because i can't see a problem, but i'm thinking of taking as input:
19:30:56 <mmorrow> $(makeItFlatAndFastAndEasy [t|ReaderT r (WriterT w (State s)) a|]
19:30:58 <mmorrow> )
19:31:27 <mmorrow> i'm gonna check out the MonadLab code though, it sounds way interesting
19:31:50 <mmorrow> err, i would have had to have done in reality:
19:32:06 <mmorrow> [t|forall r w s a. ReaderT r (WriterT w (State s)) a|]
19:33:15 <mmorrow> (which would then generate essentially a copy of everything in the RWS module)
19:33:32 <mmorrow> @unmtl  ReaderT r (WriterT w (State s)) a
19:33:32 <lambdabot> r -> s -> (a, w, s)
19:33:45 <wy> Can anybody help me? I want to understand the code pasted at http://hpaste.org/12703
19:34:31 <mmorrow> whoa, @unmtl must specifically check for that type, because on second thought i don't think that's actually the type of a flat   ReaderT r (WriterT w (State s)) a
19:35:30 <mmorrow> oh no, it is that type
19:35:37 <sjanssen> the tuple would be nested
19:35:41 <mmorrow> ah yeah
19:35:43 <mmorrow> that's it
19:35:50 <mmorrow> exactly
19:36:59 <polveroj> wy: for each state type s, (StateMonad s) is a monad. Monads have one type parameter (ie are of kind * -> *), but StateMonad takes two (is * -> * -> *), so you have to give it one to make it a monad.
19:36:59 <polveroj>  
19:37:49 <wy> polveroj: Ah... It's clearer now
19:37:53 <polveroj> wy: this also means that (StateMonad Integer) and (StateMonad Char) are different monads
19:38:34 <mmorrow> it's because there's no way to convey the state type with the class mechanism (without doing that), so the mtl has to use two params + a functional dependency
19:39:04 <mmorrow> well, the functional dep isn't actually necessary, but without it you'd go crazy with all the type annotations you'd have to make
19:40:02 <wy> mmorrow: Let me make sure you are talking about another thing, right ? :P
19:40:17 <mmorrow> oh, oops. i'm not even talking about what you guys are talking about :)
19:40:20 <mmorrow> hehe
19:41:28 <mmorrow> i thought you were talking about the MonadState class from mtl for a second there (and was wondering why polveroj was talking about the kind of a class ;)
19:41:36 <wy> I just joined and asked one question. So you should say wy is not talking abot what you guys are talking about.
19:41:57 <dmwit> wy: What's your question?
19:41:57 <mmorrow> "you guys" := wy, polveroj
19:42:29 <wy> mmorrow: OK. that unified successfully
19:42:39 <mmorrow> heh
19:43:12 <wy> dmwit: about a use of partial type constructor I met. http://hpaste.org/12703. I seem to understand now
19:47:51 <twb> Hmm, looks like Yi's config format has changed again since last I used it
19:48:13 <twb> I have a YiConfig.hs with yiMain, but it seems to want a yi.hs with main.
19:48:53 <wy> polveroj: I see. So the monad type can only have one parameter. That is the type of the "value"?
19:51:33 <polveroj> wy: yeah.  The type signatures of the monad operations only make sense if "m" takes one parameter
19:52:10 <wy> :t (>>=)
19:52:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:52:41 <hydo> Is there a way to regenerate package.conf.inplace?
19:52:56 <hydo> I don't supposed touch(1)'ing it would work ;)
19:53:50 <Cale> hydo: package.conf.inplace?
19:54:04 <mmorrow> hydo: hehe, why did you mess with it?
19:54:18 <Cale> (I know what package.conf is)
19:54:44 <mmorrow> (i'm not sure the answer other than rebuilding from scratch)
19:54:54 <hydo> I didn't touch it!  I promise! (heh) I installed ghc via macports ( on osx ) and now I'm trying to install gtk2hs but it's croaking on not being able to find that file.
19:55:07 <mmorrow> Cale: oh, package.conf.inplace is in the ghc src tree
19:55:08 <hydo> Ok, so it is an integral file which should be there.
19:55:09 <Cale> hydo: You should use the GHC binary.
19:55:23 <mmorrow> or at least, it's generated at some point during the build process
19:55:26 <hydo> Cale: ah, ha!  ok... the .pkg from the ghc site?
19:55:35 <Cale> yeah
19:55:43 <hydo> Ok, on it!  Thanks again guys.
19:55:50 <Cale> I'm not certain about gtk2hs...
19:55:58 <Cale> but you still should be using that binary :)
19:56:05 <mmorrow> hydo: oh, that means you're trying to invoke ghc directly and not with its shell script wrapper that passes it the correct - B option
19:56:08 <mmorrow> -B
19:56:18 <hydo> oh
19:56:37 <mmorrow> this is what cat `which ghc` looks like on my sys:
19:56:40 <hydo> Well, macports was.  Either way, I'm gonna purge that package and install from the .pkg
19:56:53 <mmorrow> #!/bin/sh
19:56:54 <mmorrow> exec /usr/local/ghc/ghc-6.10.1/lib/ghc-6.10.1/ghc -B/usr/local/ghc/ghc-6.10.1/lib/ghc-6.10.1/. -dynload wrapped ${1+"$@"}
19:56:59 <mmorrow> yeah, macports i mean
20:00:47 <hydo> Cale/whoever: The first, and more official looking, one listed or the one "prepared by Christain Maeder" ?
20:01:58 <mmorrow> i'm not sure about the mac packages, but there are a bunch of mac users here..
20:02:43 * juhp stills thinks ghc-paths is bit silly currently anyway
20:03:09 <hydo> I'm grabbing the more official looking one... if the conventional wisdom says use the other one, welll, i'll download it too.. heh
20:10:01 <yuuki> Has anyone seen type combinators?  The idea is that any lambda expression can be represented by a combinator basis, and so I'm wondering if type products (pi-expressions) can be represented in the same way.
20:13:46 <luqui> yuuki, you mean as in dependent types?
20:14:13 <luqui> yuuki, i had a similar idea a while ago.  i suspect the answer is yes, but that it won't really help since it's not guaranteed unique (of course)
20:14:19 <yuuki> Yes, but more generally any of the pure type system (PTS) systems
20:14:52 <yuuki> luqui, is it not unique?
20:15:21 <byorgey> actually, I don't see how that would work with a PTS.
20:15:38 <byorgey> Pi terms don't express any sort of computation, they just... are.
20:15:43 <luqui> yuuki, of course not.   otherwise every identity function would be SKK, and determining whether a function is the identity would be decidable
20:15:53 <byorgey> they classify lambda expressions.
20:16:02 <yuuki> byorgey, but during abstraction pi-terms are reduced in the same way that lambda terms are, aren't they?
20:16:19 <luqui> byorgey, lambda terms don't express computation either
20:16:20 <yuuki> luqui, SKK should only have one type
20:16:39 <luqui> yuuki, huh?
20:16:53 <byorgey> yuuki: no, they aren't.
20:16:56 <byorgey> that's my point.
20:17:04 <luqui> yuuki, oh you're wondering whether combinator calculus can be *given* PTS types?
20:17:13 <byorgey> luqui: well, the reduction rules for application of lambdas then.
20:17:14 <luqui> not used in the representation?
20:17:22 <luqui> byorgey, there are such rules for pi terms
20:17:35 <yuuki> luqui, no, I'm wondering whether or not pi-terms can be represented using combinators
20:17:38 <byorgey> hm, I've never seen such rules
20:17:57 <byorgey> I've got to go to bed now but I'd be interested in discussing this more later =)
20:18:09 <yuuki> byorgey, yes, I'm pretty sure that the meaning of a pi-term is that it is reduced during beta-reduction to the body of the pi-term
20:20:57 <yuuki> luqui, I think SKK should only have one type, which is Pi x : a . a
20:21:45 <hydo> haha... holy crap.  All of that and I got the _exact_ same error.  "package.conf.inplace: openBinaryFile: does not exist"  looks like it's time to dig into gtk2hs's makefiles.
20:21:45 <luqui> yuuki, what about Pi x:a, id a ?
20:21:59 <luqui> or Pi x : a, s k k a ?
20:23:29 <hydo> make
20:23:31 <hydo> oops
20:23:32 <hydo> hh
20:25:30 <lpjhjdh> so I'm trying to build yi but I'm getting an error about Control.Category hidden in category-extras.  So I ghc-pkg expose category-extras and it still complains.
20:25:33 <dons> this review of RWH is awesome, http://www.amazon.com/review/RSLAPXI8MV0OB/ref=cm_cr_rdp_perm  "My guess is that this book will ignite the already growing haskell community. 10/10!". Woot. W're burning up!
20:25:38 <lpjhjdh> Am I doing something horribly wrong?
20:25:44 <dons> hmm.
20:25:52 <dons> oh, Control.Category is in base.
20:26:17 <lpjhjdh> oh, what is category-extras?
20:26:36 <yuuki> luqui, I think the type of (Pi x:a, id a) is *
20:26:39 <dons> a  big library of control structures
20:26:55 <luqui> yuuki, sure.  I'm saying the type of SKK could be Pi x:a, id a
20:27:00 <lpjhjdh> I see, thanks
20:27:08 <luqui> yuuki, which is the same as Pi x:a, a, but not decidably so
20:27:40 <yuuki> luqui, I don't think applications occur inside pi-terms?
20:28:14 <luqui> yuuki, then your calculus is very weak
20:29:07 <yuuki> luqui, oh I see
20:29:32 <yuuki> luqui, sorry, I am still trying to grok dependent types :)
20:29:53 <luqui> yuuki, sure.  they're very cool, but it takes a little stretch.
20:30:08 <yuuki> luqui, Pi x:a, id a should have a normal form
20:30:13 <luqui> I find them to be a lot more sensible than two-tiered systems like Hindley Milner in a lot of ways
20:30:45 <luqui> yuuki, well you hope it does.
20:30:48 <wy> polveroj: I found that I can't change newtype to type like "type StateMonad s a = s -> (a,s)". It doesn't allow me to apply StateMonad to only one argument. Is that the case for all type synonyms?
20:31:02 <yuuki> luqui, shouldn't we be able to find the normal form just like we can for lambda terms?
20:31:05 <luqui> yuuki, oh, that kind of normal form
20:31:41 <yuuki> luqui, for combinators, we should end up with only S's and K's that haven't met their reduction requirements
20:31:53 <luqui> yuuki, hmm.  I don't know if DT systems have confluent normal forms...
20:32:09 <EvilTerran> wy, if you can eta-reduce the type to eliminate the parameter yourself, you can do that, and then apply that type synonym partially
20:32:25 <yuuki> luqui, hmm... I thought all of the lambda cube systems were strongly normalizing?
20:32:30 <EvilTerran> wy, for instance, "type List = []" instead of "type List a = [a]"
20:32:41 <mmorrow> the binary package has a nice test/ directory :)
20:32:50 <yuuki> luqui, another question of mine is, why do we need pi-terms and lambda-terms as separate concepts?
20:32:57 <luqui> yuuki, I don't know enough theory to answer that.
20:33:05 <luqui> yuuki, the lambda cube thing, that is
20:33:22 <luqui> yuuki, the difference between pi and lambda is something I stressed over for a while
20:33:31 <luqui> but the answer I came to is... because they're different
20:33:54 <wy> EvilTerran: In this case type StateMonad s a = s -> (a,s), it doesn't seem to be possible?
20:33:59 <yuuki> luqui, are they different?
20:34:17 <mmorrow> yuuki: i found this post interesting: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
20:34:19 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
20:34:21 <EvilTerran> wy, indeed, you can't do that in this case
20:34:37 <luqui> yuuki, so if you have (t u), you're expecting t to be of the form \x. A, and the type of t to be Pi x. T
20:34:45 <wy> EvilTerran: So I have to use newtype here, because I need to apply it to one type argument
20:34:55 <mmorrow> he merges them there (or keeps them separate just for the sake of presentation, but makes it clear they need not be different concepts)
20:35:07 <luqui> yuuki, but say the type of t were \x. T
20:35:21 <hydo> If anyone has a sec for a question, I think in this case it's better asked with an image.  re: building gtk2hs, http://snurl.com/77s73
20:35:35 <Philippa_> yuuki: I would imagine that you need a larger combinator base
20:35:38 <luqui> yuuki, (i'm completely winging it by the way, I remember just by thinking it through I came to an obvious conclusion, but I don't remember it)
20:35:38 <mmorrow> yuuki: (while i'm sure you know, but just in case that post is by the author of cayenne)
20:35:54 <mmorrow> (and hbc)
20:36:18 <yuuki> mmorrow, I see.  I don't know about cayenne and hbc :)
20:36:19 <Philippa_> for approximately the same reasons that typed lambda calculi are bigger languagees than the untyped calculus
20:37:00 <hydo> Nevermind, answered my own question.
20:37:05 <mmorrow> yuuki: hbc was one of the first haskell compilers, and cayenne was one of the first compilers for a dependently typed lang
20:37:07 <mmorrow> http://www.cs.chalmers.se/~augustss/cayenne/
20:37:10 <luqui> yuuki, my brain is farting, actually, I can't come to the same conclusion again :-(
20:37:13 <lambdabot> Title: Cayenne
20:37:44 <mmorrow> err, cayenne was /the/ first compiler for ....
20:38:12 <mmorrow> well, cayenne is a language, and its compiler was ^^^
20:38:39 <yuuki> mmorrow thanks!
20:38:47 <mmorrow> no problem :)
20:38:49 <shepheb> I installed 6.10, but my cabal-install is broken now. it can't resolve dependencies
20:40:06 <FunctorSalad> shepheb: memory leak when resolving deps? then you need to install the newest cabal-install
20:40:19 <shepheb> manually, I suppose
20:40:27 <mmorrow> heh, this is my favorite line from that blog post:
20:40:29 <mmorrow> type Type = Expr
20:41:37 <Philippa_> yuuki: you might want to read up on Pure Type Systems
20:42:00 <luqui> Philippa_, is that not what he(?) was talking about?
20:42:07 <yuuki> Philippa_, yeah, I've been reading that.  That's what brought on my question, why the need for both Pi and Lambda
20:42:09 <shepheb> okay, I just grabbed and built cabal-install. cabal --version still shows Cabal 1.3 and cabal-install 0.4.9
20:42:27 <shepheb> path is correct, ghc is 6.10, ghc-pkg list Cabal shows 1.6
20:42:42 <b7j0c> hi! i have a question about a sort-of nontrivial piece of code: http://hpaste.org/12705
20:43:04 <b7j0c> my question is about how Error's propogate when connected with >>
20:43:50 <Philippa_> ah. To prevent an infinite progression of lambdas, I would've thought? The idea being that \... : pi ...
20:44:54 <b7j0c> in my function checkHeader in that hpaste, i have a series of functions that try to parse the header of an ogg file. but in the case of testing it with a non-ogg file, i get the Error from the *last* test in the sequence, not the first (where the failure would occur). why is that?
20:45:06 <yuuki> That's one of the things that bothers me about type systems.   There are two levels, the evaluation level and then a level of propositions about the evaluation level
20:45:23 <yuuki> But in PTS, even types have types, so why does it matter?
20:45:28 <mmorrow> yuuki: there doesn't have to be
20:45:35 <Philippa_> actually, it's proofs of the propositions :-)
20:45:36 <luqui> yuuki, dependent type systems unify them, but in the opposite direction I thought they would
20:45:51 <luqui> yuuki, they unify them so that the bottom level is also propositions
20:46:02 <b7j0c> oh maybe i should just try a cafe list post....
20:46:10 <Philippa_> luqui: ...not exactly
20:46:14 <yuuki> luqui, really?  could you give an example?
20:46:45 <luqui> b7j0c, i'm not sure about your code.  you know how the Either monad works?
20:46:57 <mmorrow> but a lang being dependently typed doesn't necessarily have to be one where expressions are required to be provably terminating
20:47:03 <Philippa_> rather, propositions can depend on it - but 1 isn't a type in its own right any more than Either is
20:47:17 <luqui> yuuki, what I meant by that was actually weaker than it sounded like.  I was referring to required termination proofs.
20:47:32 <yuuki> Hmm
20:47:33 <mmorrow> you could have one (e.g. cayenne) where you can do IO and write code that goes into an infinite loops just like you can do in haskell
20:47:34 <luqui> mmorrow, true, but they usually are.
20:47:54 <yuuki> If the expression is well-typed, then that itself is a termination proof, isn't it?
20:48:01 <mmorrow> (which is good when you want to actually use that lang for real-world tasks)
20:48:13 <luqui> mmorrow, is it in a partiality monad or some such, or can the type checker get into an infinite loop?
20:48:19 <Philippa_> yuuki: normally that requires a more complex type
20:48:30 <luqui> yuuki, yeah.  proving that something is well typed can be pretty involved.
20:48:43 <mmorrow> luqui: the type checker can loop.
20:48:59 <luqui> mmorrow, hmm.  I might like to look at cayenne a bit.
20:49:15 <yuuki> luqui, hmm... I thought that if you can construct it then it's well-typed
20:49:28 <mmorrow> luqui: it's great. i've been saying i'm gonna cabalize the code for forever now (but have yet to finish doing so ;)
20:49:31 <Cale> Heh, it would be funny to have a total language with a partial type system :)
20:50:12 <Cale> Once your program is compiled, you know it will terminate, but compilation might not :)
20:50:17 <mmorrow> luqui: here's a graphviz-rendered dep graph of the modules in the cayenne src http://code.haskell.org/~morrow/cayenne/cayenne.tred.png
20:50:25 <Philippa_> yuuki: Sort of. Thing is, the version you construct to be well-typed in that setting is different
20:50:47 <mmorrow> and here are haddocks for (hierarchicalized by me) cayenne http://code.haskell.org/~morrow/cayenne/haddock/
20:50:47 <Philippa_> same thing, but you're talking about it in different ways
20:50:47 <lambdabot> Title: cayenne-0.0: Cayenne
20:51:11 <Philippa_> anyway: having two (or more) levels is what types are about, no?
20:51:20 <Philippa_> otherwise you just have tests ;-)
20:51:23 <mmorrow> i kept the same module structure as the code you'll get, but just stuck everything under Cayenne. so there'd be no conflicts with other packages
20:52:09 <yuuki> Philippa_, I think the ':' operator is what makes the difference.  x : a says that x is of type a.
20:52:44 <mmorrow> luqui: here's some TH code where i tried to follow exactly the method used in the cayenne code to do the same (printf) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=484
20:52:48 <yuuki> Philippa, in PTSs, I think that only lambda-terms occur on the left and only pi-terms occur on the right
20:52:57 <Philippa_> right
20:53:01 <mmorrow> that printf code is from the cayenne paper (and is in test/)
20:54:26 <Philippa_> except that you will get lambdas inside the pis, and pis inside the lambdas
20:54:36 <mmorrow> Cale: heh, i wonder if such a thing could exist. (a total lang with a partial type system)
20:54:45 <mmorrow> i guess there's no reason why not?
20:54:58 <Philippa_> (\x:pi...-> ...) : ...
20:55:01 <Philippa_> etc
20:55:14 <EvilTerran> mmorrow, actually, it strikes me as being vaguely useful
20:55:15 <yuuki> Philippa, yes, but they are always on the left and right sides of : respectively
20:55:17 <dolio> Pis can occur on the left, too.
20:55:37 <mmorrow> EvilTerran: interesting. what's a use-case you see?
20:55:38 <yuuki> dolio, hmm, how so?
20:55:41 <EvilTerran> i'd rather my code fail to terminate at compile-time, when i'm there to fix it
20:55:47 <EvilTerran> than at run-time, when i may not be :)
20:55:52 <Philippa_> yuuki: pi ... : []
20:56:02 <mmorrow> EvilTerran: ah, yeah i see where you're coming from.
20:56:03 <Philippa_> er, *->*
20:56:33 <dolio> Like (a -> b) : *. That's (Pi x:a b) : *
20:56:44 <yuuki> Ahh, good point.
20:56:47 <dolio> Assuming a and b are appropriate.
20:57:07 <dolio> And you can put lambdas on the right, too, although it's a little more contived.
20:57:19 <yuuki> dolio, I'm trying to figure out why Pi and Lambda aren't the same symbol
20:57:23 <dolio> Like (a -> b) : (\k -> k) *
20:57:44 <dolio> Which of course reduces to (a -> b) : *
20:58:19 <Philippa_> yuuki: you've just been shown why, really
20:58:32 <Philippa_> the pi-terms have their own sorts
20:58:59 <dolio> (\x:a -> e:b) : pi (x:a) b but pi (x:a) b : *
20:59:18 <dolio> Depending on what exactly a and b are, of course. It might be [].
20:59:28 <yuuki> isn't (\ k:* -> k) * the same as (Pi k:* -> *) *
20:59:31 <dolio> Or something in a tower of universes.
21:00:09 <yuuki> yikes.  Not sure if I stated that correctly
21:00:31 <dolio> Pis don't get applied to things.
21:00:48 <dolio> So '(Pi k:* -> *) *' isn't syntactically valid, even.
21:01:26 <yuuki> dolio, I think that anything on the left side of a ':' can be applied to something
21:01:27 <dolio> Or, it's certainly somehow disallowed.
21:01:47 <dolio> Ill typed, I suppose.
21:02:12 <hydo> Is there a repo viewer for darcs.haskell.org other than darcs.haskell.org/darcsweb ?  because it's pretty messed up.
21:02:40 <yuuki> any term t whose type is (Pi x:A . B) can be applied to term of type A
21:02:55 <dolio> The typing rule for application is 'f : Pi x:a e, y : a ==> f x : e[x/y]'
21:02:55 <yuuki> That was supposed to be (Pi x:A . B )
21:02:59 <dons> hydo: hmm. make a bug report about darcsweb plz
21:03:00 <dons> ?bug
21:03:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:03:04 <dons> hydo: and igloo can update it.
21:03:14 <dons> hydo: normally i just use the web, then check out the src.
21:03:40 <dolio> But the type of 'Pi k:* *' is [] (I think that's right), not Pi x:a. b
21:03:45 <yuuki> Yes, so your claim amounts to the claim that no Pi term can have a type that is another pi term?
21:04:20 <yuuki> Because any pi-term whose type was a pi-term would be apply-able
21:04:25 <dolio> No Pi term does.
21:05:14 <dolio> The type of Pi x:A. B is given by whatever your axioms say it is given A and B.
21:05:24 <sjanssen> in the non-threaded RTS, are signal handlers executed during blocking foreign calls?
21:05:34 <Philippa_> which is required to be a sort, right?
21:05:56 <yuuki> dolio, dang, that's right.
21:05:59 <dolio> Yeah. It has to be a constant, I think.
21:06:58 <yuuki> dolio, it seems that the only purpose of typing for pi-terms is to restrain you from reusing them
21:08:03 <Philippa_> yuuki: how else do you keep things finite? If the type system gives lambdas other lambdas for types, checking never terminates because you spend forever building a tower of lambdas
21:08:09 <yuuki> dolio, isn't it odd that (Pi x : a . a) is of type * instead of some other type that reflects that pi-term's structure?
21:08:23 <mmorrow> heh
21:08:37 <mmorrow> @remember yuuki it seems that the only purpose of typing for pi-terms is to restrain you from reusing them
21:08:37 <lambdabot> Okay.
21:08:43 <sjanssen> ooh, the bug also manifests with gridselect!
21:08:55 <yuuki> mmorrow, haha, is that so odd?
21:09:14 <mmorrow> heh, i read that as s/reusing/using/ at first
21:09:27 <mmorrow> and didn't realize what it really said until after i @remembered it
21:09:35 <mmorrow> but still, it's funny to me :)
21:09:37 <yuuki> haha
21:09:54 <Philippa_> @remember mmorrow and didn't realize what it really said until after i @remembered it
21:09:55 <lambdabot> It is forever etched in my memory.
21:10:02 <mmorrow> hah
21:10:03 <Philippa_> had to be done :-)
21:10:13 <dolio> yuuki: I think I have to agree with Philippa_. I'm not sure type checking would terminate otherwise.
21:10:25 <yuuki> I dunno, types are supposed to be meaningful statements about expressions, but just blanketly saying that all pi-terms are of type * (or []) seems strange
21:10:44 <Philippa_> yuuki: that's not what's said though
21:11:00 <Philippa_> it's "all pi terms in which an A is bound within a B have sort C"
21:11:03 <dolio> Not all pi terms are *.
21:11:14 <yuuki> dolio, some are []
21:11:24 <Philippa_> some are wibble
21:11:52 <dmwit> Now now, let's not quibble.
21:11:58 <yuuki> right, hmm, maybe I can have an infinite set of sorts that curiously resemble lambda expressions :p
21:12:21 <dolio> And in a system with infinite universes, Pi a:SetN. b:SetM is Set(max(N+1,M)) or something like that.
21:12:33 <Philippa_> your sorts can be isomorphic to AxB, sure
21:12:38 <yuuki> Right right
21:13:33 <Philippa_> well, up to a point: you need a sort for As and a sort for Bs and...
21:13:48 <Philippa_> ...that's where * and [] /come from/
21:14:08 <yuuki> It is strange that the type of a term contains all of the information that can be reasoned about the term given the type system
21:14:32 <Philippa_> it doesn't
21:14:35 <luqui> dolio, but that's not necessary if you don't care about termination
21:14:37 <Philippa_> at least, not necessarily
21:14:40 <yuuki> It doesn't?
21:14:51 <Philippa_> consider a PTS in which Int : * and Int : []...
21:14:52 <yuuki> I think it does, for the systems where terms have only one type
21:14:57 <dolio> luqui: Sure. If we don't care about that, we can get rid of [] and say *:*.
21:15:03 <Philippa_> important condition :-)
21:15:22 <yuuki> Philippa, as far as I know, in the lambda cube every term has only one type
21:15:38 <Philippa_> sure. It's not true of PTSes in general
21:17:12 <yuuki> Barendregt is awesome
21:17:34 <dolio> Anyhow, I don't think it's necessarily more weird that Pi x:A. B has a type like * for a whole class of As and Bs than it is that 4, 5 and 6 all have type Int.
21:18:35 <yuuki> Hmm, it seems strange that 4, 5, and 6 have the same type
21:18:47 <yuuki> It seems like that keeps you from proving things about them
21:19:28 <dmwit> A type system where each type has only one inhabitant would be painful to use.
21:20:02 <yuuki> Well, types can be generalized, right?
21:20:08 <dolio> There is no type system, then, effectively.
21:20:27 <dmwit> Right, only a value system.
21:20:28 <dolio> There's only values, and every value has its own unique type.
21:20:29 <yuuki> You can have a function that will work on all integers without losing information about the integers themselves
21:21:30 <yuuki> dolio, well, \ x : a -> x would have the same type as \ y : a -> a
21:21:43 <yuuki> oops, \ y : a -> y
21:21:50 <dolio> That's the same value.
21:21:51 <dmwit> Those are the same value.
21:21:59 <dmwit> great minds, etc.
21:23:01 <Philippa_> yuuki: 4,5 and 6 having the same type doesn't prevent you proving things about them
21:23:19 <Philippa_> there are types that contain only (injections from) 4, 5 and 6
21:23:19 <yuuki> Hmm... so there is a happy medium between having expressive types and having a type for each value?
21:23:35 <dmwit> You bet there is!
21:23:44 <dmwit> Finding that medium has been the subject of fifty years of research.
21:24:20 <dmwit> Personally, HM-typing is my current favorite for the happy medium. =)
21:24:21 <dmwit> haskell++
21:24:30 <Philippa_> the obvious one would be the type of a pair containing an int x and the sum of proofs that x is 4, 5 and 6 respectively
21:24:37 <dolio> Incidentally, from what I've read of (I think) Dependent ML, they actually have types that contain only, say, 6.
21:24:47 <yuuki> dmwit, what is HM?
21:24:51 <luqui> HM is very useful.  but it does not adequately satisfy my desire for awesomeness
21:24:55 <dolio> And then integers in general are an existential quantification over all such types.
21:25:04 <dmwit> yuuki: Hindly-Milner; it's the type system Haskell uses.
21:25:04 <yuuki> I thought HM was just the inference algorithm
21:25:08 <lament> dmwit: by HM you of course mean "with all the extensions"?
21:25:09 <dmwit> might be
21:25:12 <markovChain> 
21:25:21 <dmwit> lament: Naturally. ;-)
21:25:29 <Philippa_> yuuki: no, the inference algorithm is an implementation of the H-M type system
21:25:42 <Philippa_> (Haskell's type system is actually a fairly large extension of it)
21:25:44 <dmwit> luqui: Well, dependent types are very nearly the last word in awesomeness.  But they are not a happy medium.
21:25:49 <dmwit> Type inference goes a really long way.
21:25:50 <dolio> But that's, I think, because they tried as hard as possible to keep a phase distinction between compile-time types and runtime values.
21:26:01 <dmwit> Having principle types is pretty nice, too.
21:26:21 <yuuki> Are you sure there is a H-M type system?
21:26:28 <Philippa_> yuuki: totally. Go read up already
21:26:51 <yuuki> Last time I read about it, H-M was the name of a type inference algorithm for systems in the lambda cube
21:27:00 <Philippa_> you're wrong
21:27:13 <dolio> It definitely can't infer types for everything in the lambda cube.
21:27:20 <dmwit> Nothing can!
21:27:23 <dolio> :)
21:27:31 <adu> what's a lambda cube?
21:27:35 <yuuki> Philippa, try googling about it
21:27:39 <Philippa_> H-M does rank-1 parametric polymorphism
21:27:39 <dmwit> ?go time cube
21:27:42 <lambdabot> http://www.timecube.com/
21:27:42 <lambdabot> Title: Time Cube
21:27:43 <Philippa_> yuuki: I don't need to
21:27:51 <yuuki> Philippa, you won't see anything about a Hindley
21:27:57 <dmwit> adu: It's a way of parameterizing several interesting languages.
21:28:03 <yuuki> Hindley-Milner system, you'll just see references to the algorithm
21:28:28 <adu> dmwit: are you into obscurantism?
21:28:39 <yuuki> Philippa, I think System F is the type system you're talking about
21:28:40 <dmwit> adu: In Haskell, you have terms that depend on terms, right?  These are called functions.
21:28:48 <Philippa_> yuuki: no, it's not
21:28:53 <Philippa_> kindly stop patronising me
21:28:54 <dmwit> adu: Sorry for the obscurity, I'm still typing. =)
21:29:10 <Philippa_> System F is /not/ the H-M system at all - it's rank-n, and has type annotations
21:29:17 <yuuki> Philippa, ... I'm not trying to patronize you, I'm trying to understand what you're talking about
21:29:28 <yuuki> System Fw is the rank-n System F
21:29:31 <Philippa_> you're doing it by telling me I'm wrong. This is rude
21:29:34 <Philippa_> no, it's not
21:29:38 <dmwit> adu: So, you could also imagine terms depending on types, types depending on types (polymorphism), and terms depending on types (dependent typing).
21:29:59 <dmwit> adu: And, it turns out you can have these features independently, so they can act as axes.
21:29:59 <Philippa_> hint: w isn't a natural number
21:30:28 <yuuki> Philippa, http://en.wikipedia.org/wiki/Type_inference#Hindley.E2.80.93Milner_type_inference_algorithm
21:30:30 <lambdabot> Title: Type inference - Wikipedia, the free encyclopedia, http://tinyurl.com/72ovj
21:30:34 <dolio> System Fw allows variables to quantify over order-n type functions.
21:30:36 <dmwit> adu: Since there are three "axes" (languages without the term-depending-on-term axis aren't so interesting), they call it a cube.
21:30:50 <Philippa_> yuuki: yes. There is an inference algorithm that was provided to go /with/ the type system
21:31:03 <Philippa_> but there is also a type system. The relationship's pretty close, of course
21:31:22 <yuuki> Philippa, do you know of any resource that mentions the Hindley-Milner type system?
21:31:31 * dmwit wonders briefly if this argument is worth winning for either side
21:31:33 <Philippa_> consider that the simply-typed lambda calculus /is/ its inference algorithm
21:31:38 <Philippa_> TaPL
21:32:38 <Philippa_> consider for a moment: there /has/ to be such a type system, merely filling in annotations for the lambdas doesn't give you a System F term
21:33:09 <Philippa_> nor is the simply-typed lambda calculus enough
21:34:01 <edwardk> @seen luqui
21:34:02 <lambdabot> luqui is in #haskell. I last heard luqui speak 9m 11s ago.
21:34:17 <Philippa_> also, if you're that worried try googling "hindley-milner type system"
21:34:24 <edwardk> @seen conal
21:34:24 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
21:34:28 <conal> edwardk: here
21:34:49 <edwardk> hey i made some progress tackling behaviors and futures categorically
21:35:02 <conal> cool!
21:35:32 <yuuki> Philippa, sorry for bugging you :)  I found some resources that mention it as a type system
21:35:39 * Philippa_ nods and sighs
21:35:56 <Philippa_> I guess you weren't to know that I've spent a lot of the last year working on a very close relative
21:36:21 <edwardk> type Future = (,) Time; type B = (->) Time, type Behavior = Density B a -- Density B a is isomorphic to B a
21:36:46 <Philippa_> (close enough that some people would simply consider the inference system/algorithm to /be/ Hindley-Milner)
21:36:56 <edwardk> now, (,) Time is left adjoint to (->) Time which is isomorphic to my Behavior type, so we can now abuse that adjunction
21:37:07 <pumpkin> I'm just reading up on functors and fmap in RWH and was wondering what can be done about the "no constraints" issue... is it not considered to be an issue, or are there proposals to alleviate it? I can envision wanting to fmap over a set, but even if set didn't require ord, it would definitely require eq
21:37:46 <edwardk> the unit of the adjunction: unit :: a -> Behavior (Future a) returns a behavior that returns a future at that moment of time it is queried with the value supplied.
21:37:59 <Cale> pumpkin: The problem is essentially that the Functor typeclass doesn't express what it means to be a Functor in general, only what it means to be an endofunctor on the category Hask of Haskell types and functions.
21:38:03 <adu> dmwit: I thought dependent typing was types depending on terms...?
21:38:21 <edwardk> the counit:: Future (Behavior a) -> a takes a future behavior and applies that behavior as it will be at the time of the future.
21:38:37 <Cale> pumpkin: Set is a functor on a different category, specifically, the subcategory of Hask which consists of types in Ord.
21:39:11 <conal> edwardk: i don't have the focus right now to take in what you're saying.  would you mind emailing it to me?  i can also then learn the concepts i'm missing as i read it.
21:39:15 <edwardk> leftAdjunct and rightAdjunct have meanings in terms of transforming functions that work with Futures into ones that work on behaviors and vice versa. leftAdjunct :: (Future a -> b) -> a -> Behavior b, and vice versa for rightAdjunct
21:39:24 <dmwit> adu: You're right, of course, terms depending on types is what you get in languages like LF.
21:40:01 <edwardk> my definition for Zap also works immediately there, as it is a superclass of Adjunction zap :: Behavior (a -> b) -> Future a -> b or zap :: Future (a -> b) -> Behavior a -> b
21:40:06 <adu> dmwit: what is LF?
21:40:14 <dmwit> "logical framework"
21:40:25 <pumpkin> Cale: interesting... so are there proposals on making fmap more general, or does the language not support that kind of generality?
21:40:27 <conal> edwardk: also, if you'll review & apply that category-extras patch i sent you, then people can run the code i'm attaching to my next blog post.
21:40:29 <edwardk> at = lowerDensity
21:40:30 <dmwit> It's kind of neat, but I've never had enough time to really try it out and understand it.
21:40:34 <dmwit> ?go twelf
21:40:46 <lambdabot> http://twelf.plparty.org/
21:40:46 <lambdabot> Title: The Twelf Tutorial, January 19 2009, Savannah, GA
21:41:10 <FunctorSalad> pumpkin: it's been done, see rmonad
21:41:13 <adu> dmwit: but the Vec type, isn't that deptypes?
21:41:13 <FunctorSalad> @where rmonad
21:41:14 <lambdabot> I know nothing about rmonad.
21:41:22 <pumpkin> looking now :)
21:41:22 <FunctorSalad> @google haskell rmonad
21:41:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
21:41:29 <lambdabot> Title: HackageDB: rmonad-0.3
21:41:30 <pumpkin> FunctorSalad: found it, thanks
21:41:34 <FunctorSalad> :)
21:41:38 <adu> dmwit: like Vec ::  Nat -> Type -> Type
21:41:40 <dmwit> I'm not sure I know what you're talking about now.
21:41:48 <dmwit> ah
21:41:50 <Cale> pumpkin: There are tricks you can do to make fmap work more generally, but they're somewhat ugly.
21:42:04 <edwardk> conal: and then the last couple of bits are that you can derive the state monad and context comonad parameterized by Time from the definitions for Behavior and Future above.
21:42:11 <adu> dmwit: its the most common example of a type you can't express (nicely) in Haskell
21:42:21 <dmwit> yep
21:42:31 <edwardk> conal: i will, but i left the VM that I have the category-extras code on at work ;)
21:42:50 <adu> dmwit: and isn't that an example of types depending on terms?
21:42:53 <Cale> pumpkin: The language of the future will probably have more direct support for categorical ideas :)
21:42:59 <pumpkin> yay
21:43:09 <edwardk> (it also has all the code for my current obsessions on it, hence why i got bored and started hacking on FRP today) ;)
21:43:18 <pumpkin> are things like haskell' or 2 already working towards that, or is it way in the future?
21:43:27 <dmwit> adu: ...yes?
21:43:34 <dmwit> I'm not sure where you're going with this.
21:43:47 <Cale> Haskell' is rather conservative. There's not currently a concerted Haskell 2 effort.
21:43:51 <FunctorSalad> by the way, why don't we just give every value a hash, so everything has an Eq and Ord instance that is suitable for things like Set
21:43:55 <conal> edwardk: thx.  would you email me your frp-related remarks.  i'll be able to take them in better later.
21:44:12 <adu> dmwit: where I'm going with this, is I was trying to dislodge your definition of "dependant types" as terms depending on types...
21:44:17 <edwardk> conal: i'm trying to see if i can mush them into a blog post as we speak
21:44:21 <dmwit> adu: I already admitted that was wrong.
21:44:26 <adu> oh ok :)
21:44:36 <Cale> FunctorSalad: In those cases, using Map is probably a better idea.
21:44:42 <dmwit> adu: I got dependent types and LF's extra stuff mixed up (again).
21:45:38 <jberg> what module do i have to load from ghci to use sort?
21:45:46 <Cale> jberg: Data.List
21:46:06 <jberg> thanks
21:46:23 <FunctorSalad> Cale: I meant the cases where Ord ist just used to build an internal tree for efficiency, e.g. Set and Map
21:46:41 <Cale> FunctorSalad: Things which ought to be considered equal might hash to different things, and vice versa.
21:47:10 <Cale> (things which ought to be considered different might hash to the same thing, unless these hashes are unbounded in size)
21:47:15 <FunctorSalad> Cale: yes, it doesn't solve the "a set can contain only one member from each Eq class"
21:47:25 <FunctorSalad> but the internal efficieny thing
21:48:05 <Cale> Usually it suffices to make up your own IDs and tag things with them.
21:49:17 <FunctorSalad> I just proposed this to get rid of the Ord constraint for Set :)
21:49:29 <pumpkin> what do people think of the haskell school of expression btw? (I'm reading RWH, but my gf's course is using SOE and I was curious)
21:49:39 <FunctorSalad> with Set you usually don't care about the ordering, you just need to have one
21:49:42 <Cale> It would be interesting to have a total (or even well) ordering on every type, but I think it's not computably realisable :)
21:50:17 <FunctorSalad> Cale: if the current hashing algorithms are as random as we think they are, you should worry about cosmic rays before you worry about hash collisions ;)
21:51:37 <FunctorSalad> (AFAIK)
21:52:09 <orbitz> what is SOE?
21:52:17 <pumpkin> haskell school of expression
21:52:18 <Cale> orbitz: School of Expression
21:52:23 <Cale> orbitz: It's a book about Haskell.
21:52:31 <orbitz> k
21:52:36 <Cale> (and well, functional programming in general)
21:52:41 <conal> edwardk: question about (possibly empty) lists: i know extact is partial.  does a comonad law fail?
21:53:16 <luqui> Cale, of course not.  function types, follows from rice :-)
21:53:28 <Cale> conal: Possibly empty lists aren't a comonad, are they?
21:53:38 <conal> i don't know
21:53:45 <luqui> no
21:53:52 <conal> what fails?
21:53:55 <luqui> they are not copointed
21:54:02 <conal> why not?
21:54:06 <FunctorSalad> luqui: you could hash (whatever representation the function has in memory)
21:54:11 <luqui> f a -> a,  where are you going to get the a?
21:54:16 <conal> bottom
21:54:30 <luqui> oh!  okay we have to find the law that violates I guess.
21:54:30 <edwardk> conal: one could argue that the segments you are defining aren't comonadic, unless you always allow them to be queried at time 0
21:54:49 <conal> edwardk: i do allow them.
21:54:53 <luqui> FunctorSalad, but that wouldn't be extensionally stable
21:55:05 <conal> edwardk: when they're empty, they return bottom at time 0.
21:55:15 <conal> extract exists.  does a law fail?
21:55:17 <edwardk> conal: then you have a hole in your semantics. you could argue that they'll never get queried through some sort of meta reasoning that perhaps would suffice
21:55:34 <conal> edwardk: i'm trying to ask an objective question.
21:55:44 <conal> edwardk: what fails?
21:55:49 <FunctorSalad> luqui: as in "equal functions hash to equal things"? right, but that hash should only be used for efficiency reasons, not for anything semantically important
21:55:50 <edwardk> you have a partial extract?
21:55:55 <conal> edwardk: what shape of hole?
21:56:00 <conal> edwardk: yes.
21:56:04 <FunctorSalad> luqui: (as in Set)
21:56:10 <luqui> FunctorSalad, so it can't be used as a well ordering
21:56:26 <edwardk> whenever you have a comonad you need to be able to extract and get a value. injecting undefined to fill the value isn't really satisfying the spirit of the law ;)
21:56:31 <luqui> or, I missed the context of the discussion.
21:56:52 <conal> edwardk: i'm not boasting about the partiality.  i want to know exactly what fails.
21:57:00 <edwardk> as for particular laws what is the result of extend extract?
21:57:07 <pumpkin> well I think the point was for things like set, you don't need an ordering, so even if a hash would give a meaningless ordering, you don't care
21:57:19 <FunctorSalad> luqui: the context was that I find the Ord context for Data.Set slightly questionable
21:57:22 <edwardk> extend extract = id should hold
21:57:28 <edwardk> that is what i'm worried about
21:57:35 <Cale> What's duplicate [] ?
21:57:36 <FunctorSalad> luqui: since the actual ordering doesn't matter for the semantics of Set
21:57:42 <pumpkin> Data.Set would still need Eq, and that could resolve issues with collisions (however unlikely)
21:57:43 <conal> Cale: [[]]
21:57:53 <conal> edwardk: that's more like what i'm looking.  thx.
21:57:57 <FunctorSalad> pumpkin: right
21:58:28 <Cale> Then (fmap extract . duplicate) is not the identity.
21:58:40 <conal> i can avoid this problem by removing Copointed as a parent of Comonad.
21:58:59 <conal> i don't think i need copointed
21:59:00 <pumpkin> FunctorSalad: I like that idea better than the current implementation :P same for map
21:59:02 <conal> just happens to be bundled.
21:59:27 <edwardk> which you get from C.F.C's CExtendable
21:59:38 <conal> edwardk: yes.
22:00:29 <FunctorSalad> pumpkin: hmm... on the other hand, if you put some function f into a set and later look up an function f' = f, but f' has a different hash now due to different representation... won't the lookup fail?
22:00:43 <FunctorSalad> (@ luqui too)
22:00:44 <luqui> FunctorSalad, Set.fromList [id, id.id, succ]   -- how many elements / Set.elem (id.id.id) s ?
22:01:00 <luqui> yeah that is what I just conjectured...
22:01:05 <edwardk> i just realized i seem to be heading in a slightly different direction towards how to represent time, while you seem to be moving to purely relative time, with 0 as now, i'm sitting here trying to abuse the context comonad, because the adjunction scenario mentioned before seems to suggest it
22:01:24 <pumpkin> FunctorSalad: it depends how you define the hash, I guess
22:02:05 <FunctorSalad> pumpkin: as luqui pointed out, there is no way to hash functions such that extensionally equal functions will hash to the same value
22:02:06 <mmorrow> edwardk: the typesyns in category-extras prompted rwbarton and i to each write a typesyn eliminator (w/ TH) (not to suggest anything of course ;):
22:02:15 <mmorrow> , (ppDoc . elimSyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
22:02:17 <edwardk> that would make something a bit like what luke suggested earlier, but instead of a * (Time -> a) or some variation thereof, it'd be the context comonad (Time, Time -> a), which can be queried for that time, or for points in the future of it by adding offsets
22:02:21 <lunabot>  Fix (Biff (,) Identity (Lift_ (,) Identity Maybe)) Int
22:02:32 <edwardk> mmorrow: i realize they are horrific ;)
22:02:32 <luqui> FunctorSalad, of course there is!
22:02:33 <luqui> const 0
22:02:39 <pumpkin> FunctorSalad: there's a way to order them though?
22:02:48 <mmorrow> (i had to add the _ to Lift on account of Lift being in TH and the ghc-api not doing qualified imports easily)
22:03:02 <Cale> (fmap extract . duplicate) [] = fmap extract [[]] = [extract []] = [undefined]
22:03:15 <mmorrow> edwardk: i love the Mutual type
22:03:21 <mmorrow> , src ''Mutual
22:03:22 <FunctorSalad> luqui: ;)
22:03:26 <edwardk> mmorrow: thanks, that one hurt my brain =)
22:03:27 <lunabot>  newtype Mutual p m n a = Mutual {runMutual :: (m (p a
22:03:27 <lunabot>                                                      (Mutual p n m a)))}
22:03:32 <mmorrow> heh
22:03:53 <FunctorSalad> pumpkin: hmm, I don't think that's possible either
22:03:53 <mmorrow> it made me think to write this function:
22:03:54 <edwardk> mmorrow: but i needed it for coideal comonad products and ideal monad coproducts iirc
22:04:09 <pumpkin> FunctorSalad: so in that case, your proposal isn't really losing much against the current situation
22:04:18 <mmorrow> mutual :: (a -> (b -> s) -> r) -> (b -> (a -> r) -> s) -> a -> r
22:04:19 <mmorrow> mutual f g a = f a (\b -> mutual g f b)
22:04:27 <mmorrow> and with it you can do:
22:04:36 <mmorrow> unfoldr f = mutual (\a k -> (k . f) a)
22:04:36 <mmorrow>                    (\m k -> maybe [] (\(b,a) -> b : k a) m)
22:04:40 <pumpkin> we can't make meaningful sets of functions, but we can remove the (seemingly) unnecessary requiement of Ord and go for the more relaxed Eq (maybe?) :P
22:05:01 <dmwit> Eq is hard on functions.
22:05:10 <pumpkin> yeah
22:05:10 <edwardk> luqui: how do you feel about say, something like (Time, Time -> a) w.r.t our earlier discussion?
22:05:17 <dmwit> It's the No Free Lunch theorem for compilers.
22:05:22 <pumpkin> :)
22:05:23 <luqui> actually, it's worse than Hard (capital H)
22:05:32 <pumpkin> yup
22:05:35 <mmorrow> edwardk: (and i wasn't being sarcastic about Mutual ;)
22:06:10 <FunctorSalad> luqui: how would you complete the requirement for the hash then? ;) clearly we can't have "extensionally different functions have different hashes"
22:06:12 <edwardk> mmorrow: i'm glad, coz i really do think i sprained something in my brainpan trying to figure out the coideal product stuff ;)
22:06:31 <FunctorSalad> luqui: but maybe something about "no more collisions than expected by chance"
22:06:58 <mmorrow> edwardk: heh, i've definitely sprained something in my brainspan as well trying to think of some i'm sure sweet ways to make use of it
22:07:03 <luqui> edwardk, yeah, that is a very nice one that i would like quite a lot.  can it be implemented efficiently?
22:07:46 <luqui> FunctorSalad, defining chance, etc.
22:07:59 <luqui> I would say const 0 meets the requirements for a hash function
22:08:05 <luqui> it's just a poor choice from an efficiency standpoint
22:08:11 <pumpkin> but you can't stick functions into sets right now, right, because they aren't Ord?
22:08:23 <luqui> pumpkin, yeap.
22:08:25 <edwardk> luqui: that is just the context comonad, so it permits all the usual tweaks, layering Density or Coyoneda over any of the parts of it that happen to be comonadic, etc. to fix leaks or time.
22:08:42 <luqui> pumpkin, you could manage certain functions; eg. Bool -> Bool can be massaged to go into a Set
22:08:56 <pumpkin> how?
22:09:01 <luqui> edwardk, ...   ....  .....   !!
22:09:08 <luqui> edwardk, I really need to read about this stuff
22:09:36 <edwardk> well, i don't know that anyone has written it up, thats why i figured i should tackle this as something practical to throw all of this crap at
22:09:38 <pumpkin> luqui: oh I see
22:09:39 <pumpkin> :P
22:10:32 <luqui> edwardk, yes yes yes!
22:10:44 <luqui> I am amazingly intrigued.
22:10:48 <pumpkin> so change Set to need (Hashable a) instead of (Ord a) :P
22:11:14 <luqui> maybe finally this is motivation for me to seriously consider category theory  (I have only seen it on the surface)
22:11:16 <pumpkin> except for things that are already Ord, it would use that :o
22:11:28 <luqui> or maybe haskelegory theory
22:11:46 <FunctorSalad> good name
22:12:01 <edwardk> luqui: technically i'm not looking at (Time, Time -> a) but instead ACompF Future Behavior a rather than ACompF Future B a where Behavior = Density B, where B = (->) Time, which would contort that first expression a bit
22:12:10 <mmorrow> pumpkin: however, you could use System.Mem.StableName to get a StableName for functions, then hashStableName to get an Int which you /can/ put in a Set
22:12:28 <mmorrow> (i haven't tried that exactly, but i've experimented with System.Mem.* a bit)
22:12:38 <pumpkin> mmorrow: but it wouldn't be a useful representation
22:12:48 <mmorrow> looks like one could do cool things with it
22:12:50 <luqui> edwardk, right I read about your adjunctions
22:12:52 <mmorrow> pumpkin: why?
22:13:21 <mmorrow> do you actually care what the ordering is, rather than that you just have /any/ ordering?
22:14:06 <edwardk> which appears to contort that first example into something like forall b. Behavior Time (Time -> b) ((Time -> b) -> a)
22:14:09 <mmorrow> it'll essentially give you a ptr to the function itself
22:14:18 <pumpkin> mmorrow: well the stable name would mean that f == f, not that if g had the same definition as f, it would be equal to f, right?
22:14:19 <jberg> can i access values from a scope higher up from a where clause?
22:14:20 <edwardk> which is a little weird
22:14:30 <dmwit> jberg: certainly
22:14:35 <jberg> ok cool
22:14:40 <mmorrow> pumpkin: well, if g realy /is/ f, then they'll have the same stable name
22:14:45 <pumpkin> mmorrow: and definitely not if g represented the same mapping, but had a different definition right?
22:14:55 <mmorrow> correct
22:15:18 <pumpkin> hmm
22:15:20 <mmorrow> so yeah, i see your use-case now
22:15:26 <luqui> edwardk, i can't really tell how that would work operationally
22:15:30 <pumpkin> I mean, I don't particularly care about adding functions to sets
22:15:41 <pumpkin> but it seems tough if you do :P
22:15:48 <mmorrow> or maybe i don't... but either way what you just described may be a problem if one cares about that in particular
22:15:48 <pumpkin> maybe just functions on finite domains for now
22:16:05 <edwardk> luqui: well, if we unlayer it abit, it may make more sense.
22:16:14 <mmorrow> i like using Map for such functions
22:16:30 <pumpkin> then you can store them in a Map
22:16:41 <pumpkin> or a Set
22:16:42 <mmorrow> because then you can do with such "functions" what you can do with functions in math
22:16:44 <pumpkin> yeah
22:16:49 <pumpkin> hmm
22:17:24 <mmorrow> but unfortunately the domain/range must be finite :(
22:17:30 <mmorrow> (obviously)
22:17:31 <luqui> edwardk, does any of this efficiently capture monotonicity?
22:17:35 <edwardk> peeling back to just Density B a, we get something values that look like exists b. Density ((Time -> b) -> a) (Time -> b) instead of Time -> a
22:17:39 <pumpkin> yup
22:17:44 <edwardk> yeah, because the monoid on Time
22:17:56 <luqui> so Time would be something clever?
22:17:59 <luqui> rather than a number
22:18:00 <edwardk> you have a 'current moment in time' and you can 'add to it' but i don't have to give you anything else
22:18:25 <pumpkin> mmorrow: I guess you could also work with functions equivalent to DFAs on infinite inputs
22:18:33 <pumpkin> that output booleans
22:18:40 <mmorrow> pumpkin: hmm, interesting.
22:18:55 <luqui> pumpkin, Stream Bool -> Bool  has decidable equality :-)
22:19:11 <pumpkin> I don't know what Stream is :o
22:19:24 <luqui> it's an infinite list.  Data Stream a = Stream a (Stream a)
22:19:25 <mmorrow> i'm not exactly cure what that means yet, but would one be able to e.g. take the intersection of the images of two such functions?
22:19:25 <pumpkin> but I'm assuming it's related to what I just said? :P
22:19:27 <pumpkin> ah
22:19:39 <mmorrow> (assuming  f : A -> C   g : B -> C)
22:19:52 <mmorrow> s/sure/cure/
22:19:54 <mmorrow> gah
22:19:58 <mmorrow> s/cure/sure/
22:20:46 <mmorrow> i guess not on account of the domain being infinite...
22:21:12 <edwardk> luqui: its not perfect because the design above doesn't prevent you from extracting the function and calling it with an earlier time
22:21:34 <luqui> hmm, so there would be a necessary inefficiency there if it were correct
22:21:34 <edwardk> you could tweak it a bit with some quantification games
22:21:52 <mmorrow> \f g -> Map.elems f `intersect` Map.elems g
22:22:27 <edwardk> you could make something like forall b. (Time b, Time b -> a) -- and quantify over b or something in a way that kept them from giving you another Time object without having obtained it from you first.
22:22:47 <edwardk> then you could write a function that took a delta and 'wound' the clock by that much gtiving you one back with the same type parameter
22:23:14 <edwardk> since it comes out of the box with an existential no one could give you one without cheating and using unsafeCoerce
22:23:40 <mmorrow> unsafeCoerce: the ninja weapon of choice
22:23:59 <edwardk> then its not the context comonad for Time, its the density comonad of that special 'keyed Time' functor
22:24:34 <mmorrow> oh hah, speaking of unsafeCoerce, i picked unsafecoerce.{com,org,info,net} the other week
22:24:37 <mmorrow> score!
22:24:47 <edwardk> nice
22:25:08 <luqui> edwardk, keyed time is something I've played with, but in a pretty different capacity
22:25:27 <mmorrow> unsafeperformio.com gave me the idea, and when i did a whois was stunned that no one had it
22:25:48 <luqui> edwardk, Time was a connection between time on the type level and on the value level.  So there were functions like transitive :; t :< t' -> t' :< t'' -> Time t -> Time t'
22:25:51 <luqui> er Time t''
22:26:18 <mmorrow> hpaste2 is also reachable via: unsafecoerce.com:8080
22:26:19 <edwardk> hrmm
22:26:24 <sjanssen> hi, can someone with GHC 6.10 on x86-64 tell me the output of "sizeOf True"?
22:26:35 <sjanssen> you'll need to load the Foreign.Storable module first
22:26:47 <mmorrow> > sizeOf True
22:26:48 <lambdabot>   Not in scope: `sizeOf'
22:26:51 <mmorrow> dang
22:27:02 <sjanssen> mmorrow: the bot doesn't import Foreign.* because it is unsafe
22:27:03 <mmorrow> , maxBound :: Int
22:27:05 <lunabot>  2147483647
22:27:17 <mmorrow> sjanssen: figured it was worth a shot ;)
22:27:27 <roconnor> , fix bitSize
22:27:29 <lunabot>  32
22:27:31 <sjanssen> I specifically need to know if Bool is considered 4 or 8 bytes on GHC > 6.8.x
22:27:46 <mmorrow> wuh, where is bitSize from?
22:27:53 <sjanssen> it is 4 on 6.8.3
22:27:59 <Cale> mmorrow: Data.Bits
22:28:08 <mmorrow> ahhh, hmm
22:28:14 <mmorrow> never noticed that one before
22:29:00 <lpjhjdh> Prelude Foreign> sizeOf True = 4
22:29:15 <lpjhjdh> on amd64 with 6.10.1
22:29:38 <sjanssen> lpjhjdh++ thanks for your help
22:29:46 * sjanssen is back to the drawing board
22:31:11 <pumpkin> can someone explain the basic idea of a constant-access-time array in FP?
22:31:45 <roconnor> pumpkin: easy.  Impertive programs don't have constant-access-time arrays
22:32:08 <pumpkin> hmm?
22:32:16 <QtPlatyp1s> roconnor: Yes they do.
22:32:19 <roconnor> because arrays have a fixed size limit
22:32:23 <Cale> pumpkin: What do you want explained? They're just normal immutable arrays.
22:32:33 <edwardk> luqui: well i have the 8 line implementation of the keyed clock idea more or less
22:32:36 <edwardk> @hpaste
22:32:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:32:36 <roconnor> so complexity is meaningless
22:32:39 <Cale> But constant access time is a bit of a lie.
22:32:59 <roconnor> or
22:33:07 <Cale> As the array grows, you incur at least log time. It's just that it's usually a cost which is hidden from you at the hardware level.
22:33:10 <roconnor> arrays in impertive code can be arbitarily big
22:33:19 <roconnor> and hence they cannot be constant time access
22:33:26 <pumpkin> Cale: I mean, how does the structure work, I can easily see how to get log n access through a tree structure
22:33:38 <pumpkin> roconnor: they can be amortized constant time, at least
22:33:44 <Cale> pumpkin: Immutable arrays in Haskell are primitive.
22:33:47 <pumpkin> oh
22:34:08 <edwardk> luqui: http://hpaste.org/12711
22:34:09 <luqui> http://hpaste.org/12710   -- extensional equality on functions
22:34:21 <luqui> (certain functions)  this is common haskell lore by now
22:35:16 <luqui> edwardk, okay, simple enough.   so... to make it efficient...
22:35:22 <edwardk> the behavior can be extracted to yield its current value. it can have an instance of Comonadcontext added to allow it to be asked for the current time
22:35:47 <edwardk> well, you wanted safe, so i gave safe. efficient is tricky with the existential in there ;)
22:35:55 <luqui> efficient is tricky period
22:36:00 <edwardk> yeah
22:36:47 <edwardk> i do like the general direction though of this 'context comonad frp'
22:37:09 <luqui> yeah it's pretty cool.  a lot of avenues we haven't explored before
22:38:18 <edwardk> so one thought is the Clock b -> a part of the behavior can be replaced with something else, but i'd need to know where the inefficiencies come from
22:39:23 <jkff> Whoohoo, RWH has shipped to me in St.-Petersburg!
22:39:44 <pumpkin> and to me in NH :)
22:39:49 <pumpkin> RWH all over the world!
22:39:57 <jkff> Tr00!
22:40:26 <luqui> edwardk, hmm.  the main thing is that we need to forget about the past.
22:40:45 <jkff> Or, to put it more functionally, \a b -> a
22:41:11 <edwardk> luqui: yeah, so far this only looks at the present for a behavior
22:41:31 <edwardk> you update it into the future by just bumping up the contents of the clock
22:41:39 <luqui> edwardk, oh, then the trick is locality.  usually it's easy to compute b (t+eps) using b t, for small eps
22:42:15 <edwardk> *nods* the other piece is that the equivalent formulation eneds to be done for Reactives
22:42:44 <luqui> well Reactives are simple if we have powerful behaviors
22:42:53 <edwardk> well, i have a memoizing context comonad, but it cheats
22:43:14 <edwardk> it internally unsafePerformIO's to memoize results
22:44:04 <luqui> pure memoization isn't really an option, because it's bad at forgetting
22:44:09 <edwardk> yeah
22:44:49 <edwardk> the idea there being that you bake in an LRU strategy or something, but since behaviors are modified incrementally you probably want to be able to update from a last position only.
22:45:40 <edwardk> if you really wanted to be fancy it'd be nice to have an accumulated error bound parameter, then this would be pretty simple
22:45:58 <luqui> edwardk, conal would be a fan of that
22:45:59 <edwardk> right now the 'naive' rep is (Time, Time -> a) right?
22:46:27 <luqui> yeah.  well, DTime -> a... whatever that means.  I like (Time, Time -> a), because it allows me to stay in my safe, absolute time world
22:49:16 <vegai> ohh, my RWH is in the same country already
22:49:27 <vegai> giddyup, mail guys
22:49:33 <vegai> godspeed!
22:49:46 <edwardk> ok, well i'm sticking to Time, Time -> a, because i have a categorical justification for it, maybe something horrid like Behavior a = Behavior Time (Time -> a) (Time ->  a -> DeltaT -> Maybe a) which when you updated time by a DeltaT would check the update function and return the slightly modified value or soemthing
22:50:05 <edwardk> yay for too many parameters ;)
22:50:08 <christo_m> why cant i declare functions in GHC? like f x = x * x or something
22:50:12 <christo_m> its giving me some parse error about =
22:50:21 <vegai> would it be easy to make a simple game on Reactive?
22:50:32 <pumpkin> christo_m: let before that
22:50:34 <vegai> seems like a perfect fit, but is it in practice?
22:50:48 <pumpkin> christo_m: but it's less expressive than doing so in a file, as the pattern matching isn't as cool
22:50:55 <christo_m> pumpkin, but that reminds me of ocaml :(
22:51:20 <pumpkin> christo_m: ghci is basicaly a large do statement that prints output at each command you enter
22:51:33 <pumpkin> (and that accepts : commands :P)
22:51:35 <edwardk> that would let the behavior have a lot of control over its local approximation.
22:51:36 <luqui> edwardk, hmm... that's interesting.
22:51:52 <luqui> edwardk, yeah, kind of reminds me of the list fusion hacks, making state explicit
22:52:04 <quicksilver> pumpkin: the pattern matching is just as cool
22:52:11 <quicksilver> pumpkin: you just have to separate clauses with ;
22:52:22 <edwardk> well if state was explicit then you'd pick up another layer of indirection in there in the form of an existential.
22:52:49 <christo_m> pumpkin, oh i see, i jus tnoticed in a tutorial they were simply defining functions like "f x = foo" etc, but i see what you mean now with the do statement
22:52:53 <edwardk> exists b. Behavior Time (Time -> b) (Time -> b -> DeltaT -> Maybe b) (b -> a)   -- ick!
22:52:57 <christo_m> GHC is written in haskell correct?
22:53:04 <QtPlatyp1s> christo_m: Yes
22:53:10 <edwardk> christo: yeah for the most part
22:53:19 <luqui> Oh, I was just thinking that the *actual* behavior would be a map over another behavior which manages the state.
22:53:23 <luqui> nothing remarkable...
22:53:37 <christo_m> just so everyone knows im gonna be in here a lot asking some dumb stuff, im new to functional programming sorta
22:53:46 <edwardk> christo_m: no problem
22:53:49 <luqui> christo_m, unacceptable!
22:53:49 <luqui> :-)
22:53:51 <christo_m> i looked at scheme before, and ocaml, but i dont know, i think i want to settle on haskell just becuase it sounds cool
22:54:07 <luqui> christo_m, haskell is way cooler than all those poser functional languages
22:54:07 <edwardk> i settled on haskell because it looked cooler than everyone else's code ;)
22:54:29 <christo_m> communities actually active here..in #ocaml i ask a question and id be lucky to get a reply the same day
22:54:37 <conal> i have a dilemma about comonads.  if i allow my sequences or my segments to be empty, then i lose extract.  if i don't, then i lose monoid.
22:54:40 <edwardk> oh, and because it was the first language that really made me change the way I thought in a very long time
22:54:50 <conal> and i want both.
22:55:02 <pumpkin> quicksilver: oh cool
22:55:14 <edwardk> you want monoid so you can glue together 0 length segments onto your existing behaviors?
22:55:14 <christo_m> edwardk, thats what im hoping itll do for me, i heard for some people it makes you start implementing the functional way of thought into languages that dont even support it
22:55:26 <luqui> conal, the plight of the mathematician... :-)
22:55:41 <luqui> conal, which monoid do you lose?
22:55:58 <edwardk> conal: sok, i wanted exponentials and coexponentials. then my world collapsed to a poset and i was stuck in a lattice unable to escape. now look at me.
22:56:00 <conal> luqui: concatenation of lists or of segments/signals
22:56:23 <edwardk> well, does it make sense to have an empty signal?
22:56:29 <conal> sure
22:56:35 <conal> length zero
22:56:49 <conal> if you don't pay attention, you might miss it.
22:57:22 <edwardk> lets suppose that we instead opt to say that a signal is a closed interval from [0,n] and that you concatenate them by overwriting one of the closed endpoints, what does that get you?
22:57:40 <edwardk> what fails in monoid land?
22:57:42 <luqui> you lose monoid, since there is no unit
22:57:42 <conal> edwardk: i was thinking along those lines also.
22:57:59 <luqui> er identity
22:58:03 <conal> wondering about double-values at transitions.
22:58:04 <edwardk> yeah, but i don't necessarily think you can have an identity for these
22:58:09 <conal> and yeah. i agree with luqui.
22:58:33 <conal> whether mappend is left- or right-biased at the overlap, one of the two identities will fail.
22:59:05 <edwardk> i can see that you can have an operation that leaves a signal alone, but you fundamentally have a signal because you want to ask it for a value at some point, don't you? ;)
22:59:12 <christo_m> hey you guys recommend some tuts to dive in with? im not really a beginner in programming, and ive read some of the wizard book so im just wondering if theres some intermediate haskell tut or like
22:59:20 <christo_m> Haskell for C programmers, ill try googling that now actually
22:59:32 <edwardk> christo_m: well, a lot of folks here recommend 'real world haskell'
22:59:47 <luqui> christo_m, depends on your bias, but RWH is pretty good.
22:59:50 <jkff> Do you mean SICP by the wizard book?
22:59:52 <edwardk> but they are all biased because well, i think half of the folks in here contributed during the feedback  cycle ;)
22:59:53 <conal> edwardk: i want to ask the value at any number of points within the signal.
22:59:55 <christo_m> jkff, yes
22:59:59 <conal> edwardk: including zero
23:00:18 <jkff> I'd recommend to read it to the end, and concurrently read RWH
23:00:45 <luqui> conal, you are perfectly free to ask at zero points =P
23:01:07 <edwardk> conal: i think your problem is you need to steal most 'list'-isms for your segments. add a 'null' and 'head' ;)
23:01:10 <christo_m> jkff, we'll see how much time i have, im currently a second year comp sci student and in the midst of exams :P
23:01:17 <christo_m> I probably shouldn't even be on IRC
23:01:28 <edwardk> then use the same logic, if not null then head ... else error "moron"
23:01:47 <edwardk> you shouldn't be asking questions of null lists
23:01:49 <edwardk> or null segments
23:01:56 <luqui> edwardk, not all segments are comonads, just most of them
23:01:59 <luqui> ?
23:02:03 <conal> edwardk: semantically, that's what i was suggesting earlier.  extract [] = bottom
23:02:11 <jkff> christo_m: Well, it's never late to read any of these.
23:02:14 <edwardk> exactly. the only way it can be a comonad is if it is non-empty
23:02:40 <edwardk> then segment isn't a comonad
23:03:51 <conal> the funny thing is i really will never sample a segment outside its domain.  so the empty extract will never occur.
23:03:52 <edwardk> you can have potentially empty segments with a monoidal structure or comonadic ones that lack the monoidal append operations but always have 'mass'
23:04:08 <luqui> the comonad instance feels awkward on finite segments.
23:04:25 <edwardk> conal: hence my earlier point about how you could ensure the correctness of your use cases by some meta-logical property
23:04:37 <conal> edwardk: ah, yes.
23:05:02 <edwardk> conal: the worry is by defining it as a comonad that someone ELSE will
23:05:23 <conal> edwardk: yep.
23:06:01 <edwardk> you could define it as a comonad over the kleisli category of the maybe monad or something ;)
23:06:07 <ski_> (not knowing context .. would it be awkward to provide both types, one for non-empty and the other for possibly empty ?)
23:06:47 <edwardk> then you'd have a discriminatable error case in the domain
23:06:59 <conal> ski_: the puzzle is how to get both a monoid and a comonad in the same type, since both are very useful.
23:07:12 <ski_> why the same type ?
23:07:25 <edwardk> conal: there is a paradox. you can point to it fairly quickly. mempty doesn't given you avalue to extract
23:07:33 <edwardk> extract mempty
23:07:48 <edwardk> so the types fail you
23:08:09 <Tell360> hello,all
23:08:22 <pumpkin> why is there no appendix a on RWH online?
23:08:25 <edwardk> now you can make a non-empty segment class for which there is a comonad instance. you can make a promotion from the non-empty segment class to the potentially empty class for which there is a monoid instance, but you can't convert back in general
23:09:06 <luqui> aye, extract mempty :: a, an inconsistency in your logic :-)
23:09:07 <edwardk> you could make something like Segment a -> Maybe (NonEmptySegment a) to possibly convert back to the comonad class
23:09:15 <ski_> (btw, hi edwardk)
23:09:20 <edwardk> heya ski
23:10:13 <Tell360> O:-)
23:10:17 <conal> edwardk: i don't buy your paradox.  mempty doesn't give me a value, but something else might.
23:10:25 <edwardk> conal: methinks the types are telling you you need two types. you can always convert down from the comonad to the monoid, but you need to downcast to get the monoid into the comonad
23:10:42 <conal> edwardk: okay, so that's a "can't" perspective.
23:10:53 <conal> edwardk: i'm looking for a can.
23:11:14 <edwardk> yeah but look at the type. extract mempty :: a
23:11:35 <conal> oh, and a has to be arbitrary.
23:11:41 <edwardk> i can't be hiding the a somewhere, because i don't know what it is
23:11:54 <conal> it can't be assumed to be in a particular class, with HasDefault.
23:12:00 <edwardk> yep
23:12:07 <conal> hm.  that does make it tough.
23:12:18 <conal> seems to leave us with only bottom
23:12:28 * luqui tries to program systems which form consistent logics if the language were total...
23:12:36 <edwardk> but if your types start puking bottoms on folks they won't like you
23:12:50 <pumpkin> @instances Monad
23:12:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:12:53 <edwardk> the above variation never dumps a bottom on the uninformed
23:13:23 <edwardk> and is no more onerous than checking for an empty list before converting it to a stream
23:13:37 <edwardk> in fact it is precisely the continuous analog to that case
23:14:37 <conal> edwardk: oh, okay.  so Segment is my monoid, and i have to try to get a NonEmptySegment before using extract and duplicate
23:14:45 <edwardk> yep
23:15:28 <luqui> conal, what would the world look like without a Monoid instance on Segment?
23:15:46 <conal> i don't know if that arrangement will be flexible, but i'll give it a try.
23:15:58 <conal> (flexible enough)
23:16:25 <luqui> sure.  my hunch is that in such a case, every segment should be measurable...
23:16:32 <luqui> er, nonzero measurable
23:16:59 <conal> luqui: i was expecting mappend to be central to my temporally modular interaction.  i'm not sure though.  i'm also playing with another idea.
23:17:11 <luqui> do tell?
23:17:32 <edwardk> so instead so far all you have is a semigroup
23:17:36 <conal> i will soon, in a blog post.  the details are swapped out right now.
23:17:49 <luqui> ok :-)
23:18:59 <luqui> meanwhile I'm working backward (or rather forward?).  I've got a very nice Event already coded up, and seeing what I can build on top of it.
23:19:23 <edwardk> luqui: what time model?
23:19:25 <conal> luqui: cool.
23:19:45 <luqui> edwardk, uh... well that's kind of the point.  I don't care.
23:19:50 <edwardk> hah
23:19:51 <luqui> technically it obeys the waiter set.
23:20:06 <luqui> er, actually no
23:20:15 <jdrake> Why does (^) not like negative exponents? It didn't catch this when loading the module, but only at the repl. So is this the kind of problem that wouldn't be caught by the main compiler?
23:20:21 <luqui> it is a discrete set of events.
23:20:27 <edwardk> @type (^)
23:20:28 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
23:20:31 <edwardk> @type (^^)
23:20:32 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
23:20:41 <luqui> just a set of separated (Time,a)
23:21:05 <jdrake> :t (**)
23:21:06 <lambdabot> forall a. (Floating a) => a -> a -> a
23:21:09 <jdrake> This works
23:21:16 <jdrake> :t 2^^(-1)
23:21:18 <lambdabot> forall t. (Fractional t) => t
23:21:22 <jdrake> > 2^^(-1)
23:21:23 <lambdabot>   0.5
23:21:51 <edwardk> jdrake: the naive version can be implemented through multiplication. how does it implement the negative version in general?
23:21:59 <edwardk> @src (^)
23:21:59 <lambdabot> x ^ 0            =  1
23:21:59 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:21:59 <lambdabot>   where f _ 0 y = y
23:21:59 <lambdabot>         f x n y = g x n
23:21:59 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:22:01 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:22:03 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:22:57 <edwardk> roots may not exist in many Num instances. try to find a square root of 2 in the rationals ;)
23:24:03 <edwardk> or a reciprocal in a Z mod p for some prime p
23:24:04 <jdrake> So this could happen in a compiled program at runtime?
23:24:49 <edwardk> yeah mostly because there is no 'Natural' type in haskell
23:25:47 <luqui> :t 42 :: Natural  -- ;-)
23:25:48 <lambdabot> Natural
23:26:12 <luqui> > let x::Natural = 1+x in x > 100
23:26:13 <lambdabot>   True
23:26:33 <jdrake> :t -1 :: Natural
23:26:34 <lambdabot> Natural
23:26:38 <jdrake> fail
23:26:39 <jkff> :t quot
23:26:40 <lambdabot> forall a. (Integral a) => a -> a -> a
23:26:43 <jkff> :t mod
23:26:44 <lambdabot> forall a. (Integral a) => a -> a -> a
23:26:47 <jkff> :t div
23:26:48 <lambdabot> forall a. (Integral a) => a -> a -> a
23:26:50 <jkff> Hmm
23:27:09 <luqui> > -1::Natural
23:27:10 <lambdabot>   * Exception: Natural: (-)
23:27:19 <edwardk> ah they bolted one on finally?
23:27:27 <edwardk> i'm glad i was sick of rewriting it ;)
23:27:31 <luqui> I think it's from the numbers library
23:27:43 <luqui> Data.Number. Natural or some such
23:27:46 <jdrake> But that is still runtime isn't it?
23:28:19 <edwardk> jdrake: well, sure, because because the operations for addition and subtraction are crammed in one typeclass
23:28:30 * luqui has big issues with Data.Number, because they boast a Computable Real type which is totally broken
23:29:08 <ManateeLazyCat> how to down case ?
23:29:15 <luqui> > toLower 'X'
23:29:16 <lambdabot>   'x'
23:29:22 <ManateeLazyCat> thanks
23:29:31 <blackh> Q: Is there a standard type class that gives a zero or null value, like MonadPlus but it only has 'mempty'?
23:29:35 <luqui> ManateeLazyCat, you'll need to import Data.Char
23:29:48 <jkff> blackh: Data.Monoid?
23:29:56 <luqui> no, that had mappend
23:30:02 <luqui> blackh, not that I know of
23:30:07 <blackh> Sorry I meant Monoid
23:30:11 <blackh> Tba ms
23:30:13 <blackh> Thanks
23:30:15 <ManateeLazyCat> luqui: Thanks, I know that through hoogle ;)
23:30:27 <luqui> :-)
23:30:33 <edwardk> there was once a MonadZero
23:30:45 <Tell360>  /join #haskell 497!!!
23:30:49 <jkff> btw, anyone read the "Programming from specifications" book? Is it really that seminal as they advertise it?
23:30:57 <luqui> really?  did haskell used to be perfect?
23:31:10 <ManateeLazyCat> I find study programming haskell with IRC is real nice
23:31:26 <edwardk> luqui: yes, then they released haskell 98
23:31:42 <edwardk> luqui: and monad comprehensions were wiped from the earth and monads began to fail.
23:32:22 <luqui> sigh
23:32:33 <edwardk> prior to that was a golden era full of hugs
23:32:46 <edwardk> or so i've been told
23:33:14 <Asztal> is there much of a difference between a monad comprehension and a do statement?
23:33:27 <luqui> nope.  just minor syntax differences
23:34:32 <pumpkin> is having an infinite list of events a common paradigm for functional event-based programming? I've only ever done simple stuff
23:35:07 <conal> pumpkin: yeah, fairly common.
23:35:20 <conal> pumpkin: and infinitely long behaviors/signals.
23:35:59 <conal> Asztal: there's a psychological difference, for me.  "do" looks & sounds imperative/sequential.
23:36:15 <conal> especially the word "do", which is the antithesis of functional programming in my mind.
23:36:25 <Giraffe> conal: i agree
23:36:27 <edwardk> i still want an 'undo' for comonads ;)
23:36:28 <conal> i'd replace it with "be";
23:36:31 <conal> ;)
23:36:36 <conal> Giraffe: glad to hear it!
23:36:48 <conal> edwardk: :)
23:36:50 <Giraffe> i was rather upset with what i saw with some code samples from people who just read about the do block and get crackin'
23:36:50 <luqui> edwardk, what would be your syntax for comonads?
23:36:59 <Giraffe> it's so...not functional...
23:37:14 <luqui> Giraffe, there are two ways to approach learning FP
23:37:40 <luqui> Giraffe, there's the "get stuff done, and gradually learn to think functionally", and "break head, can't do anything, and gradually relearn to program"
23:37:41 <edwardk> luqui: same syntax. it works for comonads too. just replace the sugar on ; with flipped extend instead of (>>=) and the types work out
23:37:58 <edwardk> luqui: you wind up using destructuring a lot more, but thats the nature of a comonad
23:38:01 <Asztal> I prefer the break head method. It's far more fun :)
23:38:04 <erikc> even with do notation, you really gotta know how to mentally desugar it, otherwise you wind up with some completely inscrutable type errors when you make a mistake
23:38:10 <ManateeLazyCat> "map toLower" do string down case, simple, like Haskell
23:38:16 <Giraffe> luqui: i feel like people do the first part, but never get to the "gradually learn to think functionally" part
23:38:17 <luqui> edwardk, what do you mean by destructuring?
23:38:54 <edwardk> undo (time,value) <- step1; step2 time
23:38:54 <luqui> Giraffe, but the question is, were they ever going to?  if they don't have the patience to gradually learn, would they have the patience to bash their head against the wall?
23:39:05 <edwardk> most uses require you to actually pattern match on the comonad
23:39:14 <luqui> Giraffe, I probably wouldn't have learned haskell by the latter method; i'd have just stayed in my perl bubble.
23:39:18 <Giraffe> luqui: most likely not
23:39:28 <luqui> but now I consider my mind to be pretty functional...
23:39:34 <edwardk> since comonadic actions look like w a -> b, in general you need to care about the shape of 'w'
23:39:34 <luqui> (or maybe dysfunctional)
23:39:58 <edwardk> this unfortunately means that you need to case more often, which limits the utility of the sugar
23:40:00 <luqui> edwardk, ah.  dually, monads do a lot of enstructuring
23:40:06 <luqui> return isn't the only way you build them...
23:40:11 <edwardk> yep
23:40:30 <edwardk> monads have a lot of control over the structure of the result, comonads actually generally can't change shape!
23:41:17 <edwardk> on the other hand a monadic action can usually only see one little value, while a comonadic one can see the whole structure its coming from.
23:43:20 <luqui> I wonder if there's a nice alternative sugar which would play to these advantages.   maybe that sugar is just plain old haskell =P
23:43:49 <edwardk> i.e. with a zipper comonad like Zipper f a = a * D f a (for a type family D that takes functor derivatives) it can see the state of the world from the perspective of the zipper to generate the element at a given position in the target structure, but the resulting Zipper after you extend that action will have to have the exact same shape as the original
23:44:52 <edwardk> while if you graft onto a zipper like thing monadically you add whole branches in computations willy nilly.
23:45:36 <luqui> yeah I see
23:46:04 * ski_ is not convinced a `do'-like thing is useful for comonads ..
23:46:15 <edwardk> ski: me neither to be honest. ;)
23:46:33 <edwardk> ski: the best i've come up with is a couple of fib like examples and they aren't very convincing ;)
23:46:39 <luqui> be { x <- nextLine; ... }
23:46:42 <ski_> (maybe if it was a kind of pattern .. hm)
23:47:07 <edwardk> ski: yeah one thought is to let them open cases or something
23:47:07 <luqui> ski_, oh, that's interesting.
23:47:30 <ski_> luqui : i have a few ideas i should try to work out sometime ..
23:47:52 <edwardk> undo foo of\nFoo x y z -> ....\nBar a b c -> ....
23:48:29 <luqui> edwardk, and if the cases produced bs, that would produce a w b?
23:48:44 <luqui> but that's just spelled extend $ case ... of
23:49:48 <edwardk> luqui: not quite, its written extend $ \x -> case x of ...
23:49:50 <ski_> rather `foo =>> \foo -> case foo of ...'
23:49:51 <edwardk> which is a pain in the ass ;)
23:49:53 <Smokey`> wow... somehow Haskell's 30mb OpenSuSE package installs into 326mb
23:50:06 <luqui> edwardk, oh you're right
23:50:19 <Smokey`> (GHC 6.10.1 that is)
23:51:20 <edwardk> or rather extend $ (\x -> case x of ...) . foo bar baz
23:51:21 <edwardk> ;)
23:51:47 <edwardk> since you have to perform the op that you want to pattern match on the result from even
23:51:58 <edwardk> its just messy
23:52:55 <jdrake> Is there a way to round a number up while keeping it Floating?
23:53:33 <edwardk> whoa crap i need to get some sleep or i'll be a zombie tomorrow
23:53:44 <ski_> @type (fromIntegral . ceiling) `asTypeOf` id
23:53:45 <edwardk> later folks
23:53:46 <lambdabot> forall a. (RealFrac a) => a -> a
23:54:38 <pumpkin> ski_: what does the asTypeOf do?
23:54:43 <pumpkin> :t asTypeOf
23:54:44 <lambdabot> forall a. a -> a -> a
23:54:48 <dmwit> asTypeOf = const
23:55:03 <dmwit> It is just used for restricting types.
23:55:08 <pumpkin> oh
23:55:15 <pumpkin> @type (fromIntegral . ceiling)
23:55:17 <lambdabot> forall b a. (RealFrac a, Num b) => a -> b
23:55:20 <dmwit> :t id `asTypeOf` (+)
23:55:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
23:55:22 <lambdabot>     Probable cause: `+' is applied to too few arguments
23:55:22 <lambdabot>     In the second argument of `asTypeOf', namely `(+)'
23:55:34 <ski_> @type fromIntegral . ceiling
23:55:35 <dmwit> :t id `asTypeOf` (+1)
23:55:36 <lambdabot> forall b a. (RealFrac a, Num b) => a -> b
23:55:36 <lambdabot> forall a. (Num a) => a -> a
23:55:47 <jdrake> :t ceiling
23:55:48 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
23:55:53 <pumpkin> ah, I see
23:55:58 <dmwit> jdrake!  Welcome back.
23:56:03 <dmwit> How's the port coming?
23:56:03 <jdrake> hey dmwit
23:56:17 <ski_> > Nothing `asTypeOf` Just 'a'
23:56:19 <lambdabot>   Nothing
23:56:23 <jdrake> dmwit, I think I need some context
23:56:51 <dmwit> Weren't you porting some Python GUI app to Haskell?
23:57:09 <jdrake> That project is on hold currently
23:57:40 <jdrake> I have some math to refamiliarize myself with (differential equations, fourier series, taylor, etc.)
23:57:49 <jdrake> I have just ordered a couple books on the cheap that might help :p
23:58:04 <jdrake> But I am doing a small project just now that is basically a mathematical analysis
23:59:12 <lpjhjdh> do any of you use yi --as vim as your main editor?
23:59:33 <jdrake> I think some graphs might be useful for my analysis
